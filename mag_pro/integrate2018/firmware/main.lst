CCS PCH C Compiler, Version 4.140, 33034               27-Jul-18 20:03

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   33546 bytes (51%)
                           Largest free fragment is 31978
               RAM used:   1983 (53%) at main() level
                           2369 (63%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   7BEC
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   5996
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1C0E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
....................  
.................... #define 24AA1025 
.................... //#define 24AA512 
....................  
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
06A2:  MOVLW  02
06A4:  MOVLB  8
06A6:  SUBWF  x4E,F
06A8:  BNC   06C2
06AA:  MOVLW  08
06AC:  MOVWF  FEA
06AE:  MOVLW  4E
06B0:  MOVWF  FE9
06B2:  MOVF   FEF,W
06B4:  BZ    06C2
06B6:  BRA    06BE
06B8:  BRA    06BA
06BA:  BRA    06BC
06BC:  NOP   
06BE:  DECFSZ FEF,F
06C0:  BRA    06B8
06C2:  MOVLB  0
06C4:  GOTO   1C1E (RETURN)
*
18E6:  MOVLW  08
18E8:  MOVWF  FEA
18EA:  MOVLW  56
18EC:  MOVWF  FE9
18EE:  MOVF   FEF,W
18F0:  BZ    190C
18F2:  MOVLW  0A
18F4:  MOVWF  01
18F6:  CLRF   00
18F8:  DECFSZ 00,F
18FA:  BRA    18F8
18FC:  DECFSZ 01,F
18FE:  BRA    18F6
1900:  MOVLW  5F
1902:  MOVWF  00
1904:  DECFSZ 00,F
1906:  BRA    1904
1908:  DECFSZ FEF,F
190A:  BRA    18F2
190C:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
1620:  BCF    F94.0
1622:  BCF    F8B.0
1624:  MOVLW  08
1626:  MOVWF  01
1628:  BRA    162A
162A:  NOP   
162C:  BSF    01.7
162E:  BRA    1650
1630:  BCF    01.7
1632:  MOVLB  9
1634:  RRCF   x0C,F
1636:  MOVLB  0
1638:  BTFSC  FD8.0
163A:  BSF    F8B.0
163C:  BTFSS  FD8.0
163E:  BCF    F8B.0
1640:  BSF    01.6
1642:  BRA    1650
1644:  BCF    01.6
1646:  DECFSZ 01,F
1648:  BRA    1632
164A:  BRA    164C
164C:  NOP   
164E:  BSF    F8B.0
1650:  MOVLW  10
1652:  MOVWF  FE9
1654:  DECFSZ FE9,F
1656:  BRA    1654
1658:  BRA    165A
165A:  NOP   
165C:  BTFSC  01.7
165E:  BRA    1630
1660:  BTFSC  01.6
1662:  BRA    1644
1664:  RETURN 0
*
5EE8:  BSF    F94.1
5EEA:  BTFSC  F82.1
5EEC:  BRA    5EEA
5EEE:  MOVLW  08
5EF0:  MOVWF  00
5EF2:  MOVLB  7
5EF4:  CLRF   xFC
5EF6:  BSF    00.7
5EF8:  BRA    5F1A
5EFA:  BCF    00.7
5EFC:  BRA    5F1A
5EFE:  MOVFF  7FC,02
5F02:  BCF    FD8.0
5F04:  BTFSC  F82.1
5F06:  BSF    FD8.0
5F08:  RRCF   02,F
5F0A:  BSF    00.6
5F0C:  BRA    5F1A
5F0E:  BCF    00.6
5F10:  DECFSZ 00,F
5F12:  BRA    5F02
5F14:  MOVFF  02,01
5F18:  BRA    5F32
5F1A:  MOVLW  10
5F1C:  BTFSC  00.7
5F1E:  MOVLW  04
5F20:  MOVWF  01
5F22:  DECFSZ 01,F
5F24:  BRA    5F22
5F26:  BRA    5F28
5F28:  BTFSC  00.7
5F2A:  BRA    5EFA
5F2C:  BTFSC  00.6
5F2E:  BRA    5F0E
5F30:  BRA    5F02
5F32:  MOVLB  0
5F34:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3388:  MOVLW  08
338A:  MOVWF  01
338C:  MOVLW  0A
338E:  MOVWF  00
3390:  DECFSZ 00,F
3392:  BRA    3390
3394:  BCF    F8B.3
3396:  BCF    F94.3
3398:  MOVLW  0B
339A:  MOVWF  00
339C:  DECFSZ 00,F
339E:  BRA    339C
33A0:  MOVLB  9
33A2:  RLCF   x23,F
33A4:  BCF    F8B.4
33A6:  BTFSC  FD8.0
33A8:  BSF    F94.4
33AA:  BTFSS  FD8.0
33AC:  BCF    F94.4
33AE:  BSF    F94.3
33B0:  BTFSS  F82.3
33B2:  BRA    33B0
33B4:  DECFSZ 01,F
33B6:  BRA    33BA
33B8:  BRA    33BE
33BA:  MOVLB  0
33BC:  BRA    338C
33BE:  MOVLW  0A
33C0:  MOVWF  00
33C2:  DECFSZ 00,F
33C4:  BRA    33C2
33C6:  BCF    F8B.3
33C8:  BCF    F94.3
33CA:  NOP   
33CC:  BSF    F94.4
33CE:  MOVLW  0B
33D0:  MOVWF  00
33D2:  DECFSZ 00,F
33D4:  BRA    33D2
33D6:  MOVLW  0B
33D8:  MOVWF  00
33DA:  DECFSZ 00,F
33DC:  BRA    33DA
33DE:  BSF    F94.3
33E0:  BTFSS  F82.3
33E2:  BRA    33E0
33E4:  CLRF   01
33E6:  MOVLW  0B
33E8:  MOVWF  00
33EA:  DECFSZ 00,F
33EC:  BRA    33EA
33EE:  BTFSC  F82.4
33F0:  BSF    01.0
33F2:  BCF    F8B.3
33F4:  BCF    F94.3
33F6:  BCF    F8B.4
33F8:  BCF    F94.4
33FA:  MOVLB  0
33FC:  RETURN 0
33FE:  MOVLW  08
3400:  MOVLB  9
3402:  MOVWF  x1F
3404:  MOVFF  00,920
3408:  BSF    F94.4
340A:  MOVLW  0B
340C:  MOVWF  00
340E:  DECFSZ 00,F
3410:  BRA    340E
3412:  BSF    F94.3
3414:  BTFSS  F82.3
3416:  BRA    3414
3418:  BTFSC  F82.4
341A:  BSF    FD8.0
341C:  BTFSS  F82.4
341E:  BCF    FD8.0
3420:  RLCF   01,F
3422:  MOVLW  0A
3424:  MOVWF  00
3426:  DECFSZ 00,F
3428:  BRA    3426
342A:  BCF    F94.3
342C:  BCF    F8B.3
342E:  DECFSZ x1F,F
3430:  BRA    3408
3432:  BSF    F94.4
3434:  MOVLW  0B
3436:  MOVWF  00
3438:  DECFSZ 00,F
343A:  BRA    3438
343C:  BCF    F8B.4
343E:  MOVF   x20,W
3440:  BTFSS  FD8.2
3442:  BCF    F94.4
3444:  NOP   
3446:  BSF    F94.3
3448:  BTFSS  F82.3
344A:  BRA    3448
344C:  MOVLW  0A
344E:  MOVWF  00
3450:  DECFSZ 00,F
3452:  BRA    3450
3454:  BCF    F8B.3
3456:  BCF    F94.3
3458:  MOVLW  0B
345A:  MOVWF  00
345C:  DECFSZ 00,F
345E:  BRA    345C
3460:  BCF    F8B.4
3462:  BCF    F94.4
3464:  MOVLB  0
3466:  RETURN 0
....................  
.................... #define ptr_start                       150 
.................... #if defined(24AA1025) 
.................... #define EEPROM_SIZE_endofkey            131071 
.................... #define EEPROM_SIZE_stofkey             115470 
.................... #endif 
.................... #if defined(24AA512) 
.................... #define EEPROM_SIZE_endofkey            65535 // 65535 - 57601 = 7934/16= 450 
.................... #define EEPROM_SIZE_stofkey             57600 // 57600/128 = 450 
.................... #endif 
.................... #define EEPROM_KEY_ST                   EEPROM_SIZE_stofkey+1 
.................... //=============================== 
....................  
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5CCC:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
5CCE:  BSF    F94.4
....................    port_b_pullups(0xff); 
5CD0:  BCF    FF1.7
.................... } 
5CD2:  GOTO   7D84 (RETURN)
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3A80:  MOVLB  9
3A82:  MOVF   x16,F
3A84:  BNZ   3A8C
3A86:  MOVF   x15,W
3A88:  SUBLW  00
3A8A:  BC    3A92
3A8C:  MOVLW  A8
3A8E:  MOVWF  x19
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3A90:  BRA    3A96
3A92:  MOVLW  A0
3A94:  MOVWF  x19
....................  
....................    i2c_start(); 
3A96:  BSF    F94.4
3A98:  MOVLW  0A
3A9A:  MOVWF  00
3A9C:  DECFSZ 00,F
3A9E:  BRA    3A9C
3AA0:  BSF    F94.3
3AA2:  MOVLW  0B
3AA4:  MOVWF  00
3AA6:  DECFSZ 00,F
3AA8:  BRA    3AA6
3AAA:  BCF    F8B.4
3AAC:  BCF    F94.4
3AAE:  MOVLW  0A
3AB0:  MOVWF  00
3AB2:  DECFSZ 00,F
3AB4:  BRA    3AB2
3AB6:  BCF    F8B.3
3AB8:  BCF    F94.3
....................    i2c_write(command); 
3ABA:  MOVFF  919,923
3ABE:  MOVLB  0
3AC0:  RCALL  3388
....................    i2c_write(address>>8); 
3AC2:  MOVFF  914,91B
3AC6:  MOVFF  915,91C
3ACA:  MOVFF  916,91D
3ACE:  MOVLB  9
3AD0:  CLRF   x1E
3AD2:  MOVFF  914,923
3AD6:  MOVLB  0
3AD8:  RCALL  3388
....................    i2c_write(address); 
3ADA:  MOVFF  913,923
3ADE:  RCALL  3388
....................    i2c_write(data); 
3AE0:  MOVFF  917,923
3AE4:  RCALL  3388
....................  
....................    i2c_stop(); 
3AE6:  BCF    F94.4
3AE8:  NOP   
3AEA:  BSF    F94.3
3AEC:  BTFSS  F82.3
3AEE:  BRA    3AEC
3AF0:  MOVLW  0A
3AF2:  MOVWF  00
3AF4:  DECFSZ 00,F
3AF6:  BRA    3AF4
3AF8:  BRA    3AFA
3AFA:  NOP   
3AFC:  BSF    F94.4
3AFE:  MOVLW  0A
3B00:  MOVWF  00
3B02:  DECFSZ 00,F
3B04:  BRA    3B02
....................    i2c_start(); 
3B06:  BSF    F94.4
3B08:  MOVLW  0A
3B0A:  MOVWF  00
3B0C:  DECFSZ 00,F
3B0E:  BRA    3B0C
3B10:  BSF    F94.3
3B12:  MOVLW  0B
3B14:  MOVWF  00
3B16:  DECFSZ 00,F
3B18:  BRA    3B16
3B1A:  BCF    F8B.4
3B1C:  BCF    F94.4
3B1E:  MOVLW  0A
3B20:  MOVWF  00
3B22:  DECFSZ 00,F
3B24:  BRA    3B22
3B26:  BCF    F8B.3
3B28:  BCF    F94.3
....................    status=i2c_write(command); 
3B2A:  MOVFF  919,923
3B2E:  RCALL  3388
3B30:  MOVF   01,W
3B32:  MOVLB  9
3B34:  BCF    x18.0
3B36:  BTFSC  01.0
3B38:  BSF    x18.0
....................    while(status==1) 
....................    { 
3B3A:  BTFSS  x18.0
3B3C:  BRA    3B7A
....................       i2c_start(); 
3B3E:  BSF    F94.4
3B40:  MOVLW  0A
3B42:  MOVWF  00
3B44:  DECFSZ 00,F
3B46:  BRA    3B44
3B48:  BSF    F94.3
3B4A:  MOVLW  0B
3B4C:  MOVWF  00
3B4E:  DECFSZ 00,F
3B50:  BRA    3B4E
3B52:  BTFSS  F82.3
3B54:  BRA    3B52
3B56:  BCF    F8B.4
3B58:  BCF    F94.4
3B5A:  MOVLW  0A
3B5C:  MOVWF  00
3B5E:  DECFSZ 00,F
3B60:  BRA    3B5E
3B62:  BCF    F8B.3
3B64:  BCF    F94.3
....................       status=i2c_write(command); 
3B66:  MOVFF  919,923
3B6A:  MOVLB  0
3B6C:  RCALL  3388
3B6E:  MOVF   01,W
3B70:  MOVLB  9
3B72:  BCF    x18.0
3B74:  BTFSC  01.0
3B76:  BSF    x18.0
....................    } 
3B78:  BRA    3B3A
....................    //delay_us(100); 
.................... } 
3B7A:  MOVLB  0
3B7C:  RETURN 0
....................  
....................  
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3468:  MOVLB  9
346A:  MOVF   x1B,F
346C:  BNZ   3474
346E:  MOVF   x1A,W
3470:  SUBLW  00
3472:  BC    347A
3474:  MOVLW  A8
3476:  MOVWF  x1D
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3478:  BRA    347E
347A:  MOVLW  A0
347C:  MOVWF  x1D
....................  
....................    i2c_start(); 
347E:  BSF    F94.4
3480:  MOVLW  0A
3482:  MOVWF  00
3484:  DECFSZ 00,F
3486:  BRA    3484
3488:  BSF    F94.3
348A:  MOVLW  0B
348C:  MOVWF  00
348E:  DECFSZ 00,F
3490:  BRA    348E
3492:  BTFSS  F82.3
3494:  BRA    3492
3496:  BCF    F8B.4
3498:  BCF    F94.4
349A:  MOVLW  0A
349C:  MOVWF  00
349E:  DECFSZ 00,F
34A0:  BRA    349E
34A2:  BCF    F8B.3
34A4:  BCF    F94.3
....................    i2c_write(command); 
34A6:  MOVFF  91D,923
34AA:  MOVLB  0
34AC:  RCALL  3388
....................    i2c_write(address>>8); 
34AE:  MOVFF  919,91F
34B2:  MOVFF  91A,920
34B6:  MOVFF  91B,921
34BA:  MOVLB  9
34BC:  CLRF   x22
34BE:  MOVFF  919,923
34C2:  MOVLB  0
34C4:  RCALL  3388
....................    i2c_write(address); 
34C6:  MOVFF  918,923
34CA:  RCALL  3388
....................    i2c_start(); 
34CC:  BSF    F94.4
34CE:  MOVLW  0A
34D0:  MOVWF  00
34D2:  DECFSZ 00,F
34D4:  BRA    34D2
34D6:  BSF    F94.3
34D8:  MOVLW  0B
34DA:  MOVWF  00
34DC:  DECFSZ 00,F
34DE:  BRA    34DC
34E0:  BTFSS  F82.3
34E2:  BRA    34E0
34E4:  BCF    F8B.4
34E6:  BCF    F94.4
34E8:  MOVLW  0A
34EA:  MOVWF  00
34EC:  DECFSZ 00,F
34EE:  BRA    34EC
34F0:  BCF    F8B.3
34F2:  BCF    F94.3
....................    i2c_write(command+1); 
34F4:  MOVLW  01
34F6:  MOVLB  9
34F8:  ADDWF  x1D,W
34FA:  MOVWF  x1E
34FC:  MOVWF  x23
34FE:  MOVLB  0
3500:  RCALL  3388
....................    data=i2c_read(0); 
3502:  CLRF   00
3504:  RCALL  33FE
3506:  MOVFF  01,91C
....................    i2c_stop(); 
350A:  BCF    F94.4
350C:  NOP   
350E:  BSF    F94.3
3510:  BTFSS  F82.3
3512:  BRA    3510
3514:  MOVLW  0A
3516:  MOVWF  00
3518:  DECFSZ 00,F
351A:  BRA    3518
351C:  BRA    351E
351E:  NOP   
3520:  BSF    F94.4
3522:  MOVLW  0A
3524:  MOVWF  00
3526:  DECFSZ 00,F
3528:  BRA    3526
....................    return(data); 
352A:  MOVLB  9
352C:  MOVFF  91C,01
.................... } 
3530:  MOVLB  0
3532:  RETURN 0
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr            0 
.................... #define strobe_ptrcard_addr         25     // 4 bytes 
.................... #define strobe_ptrcard_key          30     // 4 bytes 
.................... #define strobe_count_card           36     // 2 bytes 
.................... #define strobe_nameconsole          40     // 16 bytes  
.................... #define strobe_Master_SLV           58     // 1 byte 
.................... #define strobe_debugmode            59     // 1 byte 
.................... #define strobe_delaytime            60     // 1 byte 
.................... #define kindofKB                    61     // 1 byte 
.................... #define crypto_en                   62     // 1 byte 
.................... #define strobe_crypto_key           63     // 32 byte 
....................  
....................  
.................... #define wide_strobe_nameconsole     16  
.................... //============================================================== 
.................... #define numdata                  124    // 5+79+40=124 
.................... #define numdataofonecard         128    //  
....................  
.................... #if defined(24AA1025) 
.................... #define countcards               900    //43590/124 
.................... #endif 
....................  
.................... #if defined(24AA512) 
.................... #define countcards               450    //43590/124 
.................... #endif 
....................  
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdataofonecard]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... #if 0 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... } 
.................... #endif 
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4DFE:  MOVLB  9
4E00:  CLRF   x0D
4E02:  CLRF   x0C
4E04:  CLRF   x0B
4E06:  CLRF   x0A
4E08:  MOVF   x0D,W
4E0A:  SUBWF  x07,W
4E0C:  BNC   4E86
4E0E:  BNZ   4E26
4E10:  MOVF   x0C,W
4E12:  SUBWF  x06,W
4E14:  BNC   4E86
4E16:  BNZ   4E26
4E18:  MOVF   x0B,W
4E1A:  SUBWF  x05,W
4E1C:  BNC   4E86
4E1E:  BNZ   4E26
4E20:  MOVF   x04,W
4E22:  SUBWF  x0A,W
4E24:  BC    4E86
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4E26:  MOVF   x0A,W
4E28:  ADDWF  x00,W
4E2A:  MOVWF  x0E
4E2C:  MOVF   x0B,W
4E2E:  ADDWFC x01,W
4E30:  MOVWF  x0F
4E32:  MOVF   x0C,W
4E34:  ADDWFC x02,W
4E36:  MOVWF  x10
4E38:  MOVF   x0D,W
4E3A:  ADDWFC x03,W
4E3C:  MOVWF  x11
4E3E:  MOVF   x08,W
4E40:  ADDWF  x0A,W
4E42:  MOVWF  FE9
4E44:  MOVF   x09,W
4E46:  ADDWFC x0B,W
4E48:  MOVWF  FEA
4E4A:  MOVFF  FEF,912
4E4E:  MOVFF  911,916
4E52:  MOVFF  910,915
4E56:  MOVFF  90F,914
4E5A:  MOVFF  90E,913
4E5E:  MOVFF  912,917
4E62:  MOVLB  0
4E64:  CALL   3A80
....................       delay_us(10); 
4E68:  MOVLW  1A
4E6A:  MOVWF  00
4E6C:  DECFSZ 00,F
4E6E:  BRA    4E6C
4E70:  NOP   
....................    } 
4E72:  MOVLW  01
4E74:  MOVLB  9
4E76:  ADDWF  x0A,F
4E78:  BTFSC  FD8.0
4E7A:  INCF   x0B,F
4E7C:  BTFSC  FD8.2
4E7E:  INCF   x0C,F
4E80:  BTFSC  FD8.2
4E82:  INCF   x0D,F
4E84:  BRA    4E08
....................    return 1; 
4E86:  MOVLW  01
4E88:  MOVWF  01
.................... } 
4E8A:  MOVLB  0
4E8C:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len,unsigned int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4094:  MOVLB  9
4096:  CLRF   x11
4098:  CLRF   x10
409A:  CLRF   x0F
409C:  CLRF   x0E
409E:  MOVF   x11,W
40A0:  SUBWF  x0B,W
40A2:  BNC   4124
40A4:  BNZ   40BC
40A6:  MOVF   x10,W
40A8:  SUBWF  x0A,W
40AA:  BNC   4124
40AC:  BNZ   40BC
40AE:  MOVF   x0F,W
40B0:  SUBWF  x09,W
40B2:  BNC   4124
40B4:  BNZ   40BC
40B6:  MOVF   x08,W
40B8:  SUBWF  x0E,W
40BA:  BC    4124
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
40BC:  MOVF   x0C,W
40BE:  ADDWF  x0E,W
40C0:  MOVWF  01
40C2:  MOVF   x0D,W
40C4:  ADDWFC x0F,W
40C6:  MOVWF  03
40C8:  MOVFF  01,912
40CC:  MOVWF  x13
40CE:  MOVF   x0E,W
40D0:  ADDWF  x04,W
40D2:  MOVWF  x14
40D4:  MOVF   x0F,W
40D6:  ADDWFC x05,W
40D8:  MOVWF  x15
40DA:  MOVF   x10,W
40DC:  ADDWFC x06,W
40DE:  MOVWF  x16
40E0:  MOVF   x11,W
40E2:  ADDWFC x07,W
40E4:  MOVWF  x17
40E6:  MOVWF  x1B
40E8:  MOVFF  916,91A
40EC:  MOVFF  915,919
40F0:  MOVFF  914,918
40F4:  MOVLB  0
40F6:  CALL   3468
40FA:  MOVFF  913,FEA
40FE:  MOVFF  912,FE9
4102:  MOVFF  01,FEF
....................       delay_us(10); 
4106:  MOVLW  1A
4108:  MOVWF  00
410A:  DECFSZ 00,F
410C:  BRA    410A
410E:  NOP   
....................    } 
4110:  MOVLW  01
4112:  MOVLB  9
4114:  ADDWF  x0E,F
4116:  BTFSC  FD8.0
4118:  INCF   x0F,F
411A:  BTFSC  FD8.2
411C:  INCF   x10,F
411E:  BTFSC  FD8.2
4120:  INCF   x11,F
4122:  BRA    409E
.................... } 
4124:  MOVLB  0
4126:  RETURN 0
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
5D92:  MOVLB  7
5D94:  CLRF   xC1
5D96:  CLRF   xC0
5D98:  CLRF   xBF
5D9A:  CLRF   xBE
5D9C:  CLRF   xC5
5D9E:  CLRF   xC4
5DA0:  CLRF   xC3
5DA2:  CLRF   xC2
5DA4:  CLRF   xC9
5DA6:  CLRF   xC8
5DA8:  CLRF   xC7
5DAA:  CLRF   xC6
5DAC:  CLRF   xCD
5DAE:  CLRF   xCC
5DB0:  CLRF   xCB
5DB2:  CLRF   xCA
5DB4:  CLRF   xD1
5DB6:  CLRF   xD0
5DB8:  CLRF   xCF
5DBA:  CLRF   xCE
5DBC:  CLRF   19
5DBE:  BTFSC  FF2.7
5DC0:  BSF    19.7
5DC2:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
5DC4:  MOVLB  9
5DC6:  CLRF   x1B
5DC8:  CLRF   x1A
5DCA:  CLRF   x19
5DCC:  MOVFF  7BD,918
5DD0:  MOVLB  0
5DD2:  CALL   3468
5DD6:  BTFSC  19.7
5DD8:  BSF    FF2.7
5DDA:  MOVLB  7
5DDC:  MOVFF  01,7C2
5DE0:  CLRF   xC3
5DE2:  CLRF   xC4
5DE4:  CLRF   xC5
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
5DE6:  MOVLW  01
5DE8:  ADDWF  xBD,W
5DEA:  MOVWF  xD2
5DEC:  CLRF   19
5DEE:  BTFSC  FF2.7
5DF0:  BSF    19.7
5DF2:  BCF    FF2.7
5DF4:  MOVLB  9
5DF6:  CLRF   x1B
5DF8:  CLRF   x1A
5DFA:  CLRF   x19
5DFC:  MOVWF  x18
5DFE:  MOVLB  0
5E00:  CALL   3468
5E04:  BTFSC  19.7
5E06:  BSF    FF2.7
5E08:  MOVLB  7
5E0A:  CLRF   xC9
5E0C:  CLRF   xC8
5E0E:  CLRF   xC7
5E10:  MOVFF  01,7C6
....................    temp2<<=8; 
5E14:  MOVFF  7C8,7C9
5E18:  MOVFF  7C7,7C8
5E1C:  MOVFF  7C6,7C7
5E20:  CLRF   xC6
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
5E22:  MOVLW  02
5E24:  ADDWF  xBD,W
5E26:  MOVWF  xD2
5E28:  CLRF   19
5E2A:  BTFSC  FF2.7
5E2C:  BSF    19.7
5E2E:  BCF    FF2.7
5E30:  MOVLB  9
5E32:  CLRF   x1B
5E34:  CLRF   x1A
5E36:  CLRF   x19
5E38:  MOVWF  x18
5E3A:  MOVLB  0
5E3C:  CALL   3468
5E40:  BTFSC  19.7
5E42:  BSF    FF2.7
5E44:  MOVLB  7
5E46:  CLRF   xCD
5E48:  CLRF   xCC
5E4A:  CLRF   xCB
5E4C:  MOVFF  01,7CA
....................    temp3<<=16; 
5E50:  MOVFF  7CB,7CD
5E54:  MOVFF  7CA,7CC
5E58:  CLRF   xCA
5E5A:  CLRF   xCB
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
5E5C:  MOVLW  03
5E5E:  ADDWF  xBD,W
5E60:  MOVWF  xD2
5E62:  CLRF   19
5E64:  BTFSC  FF2.7
5E66:  BSF    19.7
5E68:  BCF    FF2.7
5E6A:  MOVLB  9
5E6C:  CLRF   x1B
5E6E:  CLRF   x1A
5E70:  CLRF   x19
5E72:  MOVWF  x18
5E74:  MOVLB  0
5E76:  CALL   3468
5E7A:  BTFSC  19.7
5E7C:  BSF    FF2.7
5E7E:  MOVLB  7
5E80:  CLRF   xD1
5E82:  CLRF   xD0
5E84:  CLRF   xCF
5E86:  MOVFF  01,7CE
....................    temp4<<=24; 
5E8A:  MOVFF  7CE,7D1
5E8E:  CLRF   xCE
5E90:  CLRF   xCF
5E92:  CLRF   xD0
....................    buffer = temp4|temp3|temp2|temp1; 
5E94:  MOVF   xCE,W
5E96:  IORWF  xCA,W
5E98:  MOVWF  xD2
5E9A:  MOVF   xCF,W
5E9C:  IORWF  xCB,W
5E9E:  MOVWF  xD3
5EA0:  MOVF   xD0,W
5EA2:  IORWF  xCC,W
5EA4:  MOVWF  xD4
5EA6:  MOVF   xD1,W
5EA8:  IORWF  xCD,W
5EAA:  MOVWF  xD5
5EAC:  MOVF   xC6,W
5EAE:  IORWF  xD2,F
5EB0:  MOVF   xC7,W
5EB2:  IORWF  xD3,F
5EB4:  MOVF   xC8,W
5EB6:  IORWF  xD4,F
5EB8:  MOVF   xC9,W
5EBA:  IORWF  xD5,F
5EBC:  MOVF   xD2,W
5EBE:  IORWF  xC2,W
5EC0:  MOVWF  xBE
5EC2:  MOVF   xD3,W
5EC4:  IORWF  xC3,W
5EC6:  MOVWF  xBF
5EC8:  MOVF   xD4,W
5ECA:  IORWF  xC4,W
5ECC:  MOVWF  xC0
5ECE:  MOVF   xD5,W
5ED0:  IORWF  xC5,W
5ED2:  MOVWF  xC1
....................    return(buffer); 
5ED4:  MOVFF  7BE,00
5ED8:  MOVFF  7BF,01
5EDC:  MOVFF  7C0,02
5EE0:  MOVFF  7C1,03
.................... } 
5EE4:  MOVLB  0
5EE6:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3B7E:  MOVLB  9
3B80:  CLRF   x08
3B82:  CLRF   x07
3B84:  CLRF   x06
3B86:  CLRF   x05
3B88:  CLRF   x09
3B8A:  CLRF   x0A
3B8C:  CLRF   x0B
3B8E:  CLRF   x0C
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3B90:  MOVFF  903,908
3B94:  MOVFF  902,907
3B98:  MOVFF  901,906
3B9C:  MOVFF  900,905
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3BA0:  MOVFF  905,909
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3BA4:  MOVFF  906,90A
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3BA8:  MOVFF  907,90B
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3BAC:  MOVFF  908,90C
....................    write_ext_eeprom((addr+0),temp1); 
3BB0:  CLRF   x16
3BB2:  CLRF   x15
3BB4:  CLRF   x14
3BB6:  MOVFF  904,913
3BBA:  MOVFF  909,917
3BBE:  MOVLB  0
3BC0:  RCALL  3A80
....................    write_ext_eeprom((addr+1),temp2); 
3BC2:  MOVLW  01
3BC4:  MOVLB  9
3BC6:  ADDWF  x04,W
3BC8:  MOVWF  x0D
3BCA:  CLRF   x16
3BCC:  CLRF   x15
3BCE:  CLRF   x14
3BD0:  MOVWF  x13
3BD2:  MOVFF  90A,917
3BD6:  MOVLB  0
3BD8:  RCALL  3A80
....................    write_ext_eeprom((addr+2),temp3); 
3BDA:  MOVLW  02
3BDC:  MOVLB  9
3BDE:  ADDWF  x04,W
3BE0:  MOVWF  x0D
3BE2:  CLRF   x16
3BE4:  CLRF   x15
3BE6:  CLRF   x14
3BE8:  MOVWF  x13
3BEA:  MOVFF  90B,917
3BEE:  MOVLB  0
3BF0:  RCALL  3A80
....................    write_ext_eeprom((addr+3),temp4); 
3BF2:  MOVLW  03
3BF4:  MOVLB  9
3BF6:  ADDWF  x04,W
3BF8:  MOVWF  x0D
3BFA:  CLRF   x16
3BFC:  CLRF   x15
3BFE:  CLRF   x14
3C00:  MOVWF  x13
3C02:  MOVFF  90C,917
3C06:  MOVLB  0
3C08:  RCALL  3A80
.................... } 
3C0A:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
5858:  MOVLB  8
585A:  CLRF   x53
585C:  CLRF   x52
585E:  CLRF   x54
5860:  CLRF   x55
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
5862:  MOVFF  851,853
5866:  MOVFF  850,852
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
586A:  MOVFF  852,854
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
586E:  MOVF   x53,W
5870:  MOVWF  x55
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
5872:  MOVLB  9
5874:  CLRF   x16
5876:  CLRF   x15
5878:  CLRF   x14
587A:  MOVLW  24
587C:  MOVWF  x13
587E:  MOVFF  854,917
5882:  MOVLB  0
5884:  CALL   3A80
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
5888:  MOVLB  9
588A:  CLRF   x16
588C:  CLRF   x15
588E:  CLRF   x14
5890:  MOVLW  25
5892:  MOVWF  x13
5894:  MOVFF  855,917
5898:  MOVLB  0
589A:  CALL   3A80
.................... } 
589E:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
3534:  MOVLB  9
3536:  CLRF   x01
3538:  CLRF   x00
353A:  CLRF   x03
353C:  CLRF   x02
353E:  CLRF   x05
3540:  CLRF   x04
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
3542:  CLRF   x1B
3544:  CLRF   x1A
3546:  CLRF   x19
3548:  MOVLW  24
354A:  MOVWF  x18
354C:  MOVLB  0
354E:  RCALL  3468
3550:  MOVLB  9
3552:  MOVFF  01,902
3556:  CLRF   x03
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3558:  CLRF   x1B
355A:  CLRF   x1A
355C:  CLRF   x19
355E:  MOVLW  25
3560:  MOVWF  x18
3562:  MOVLB  0
3564:  RCALL  3468
3566:  MOVLB  9
3568:  CLRF   x05
356A:  MOVFF  01,904
....................    temp2<<=8; 
356E:  MOVFF  904,905
3572:  CLRF   x04
....................    buffer = temp2|temp1; 
3574:  MOVF   x04,W
3576:  IORWF  x02,W
3578:  MOVWF  x00
357A:  MOVF   x05,W
357C:  IORWF  x03,W
357E:  MOVWF  x01
....................    return(buffer); 
3580:  MOVFF  900,01
3584:  MOVFF  901,02
.................... } 
3588:  MOVLB  0
358A:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................    /*for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    }*/ 
....................    //fprintf(COM2," ptr_card=%lu\n\r",ptr_card); 
....................    /*for(i=ptr_start;i<ptr_card;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
*
6876:  CLRF   23
6878:  CLRF   22
687A:  CLRF   21
687C:  MOVLW  96
687E:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
6880:  CLRF   27
6882:  MOVLW  01
6884:  MOVWF  26
6886:  MOVLW  C3
6888:  MOVWF  25
688A:  MOVLW  0F
688C:  MOVWF  24
688E:  CLRF   19
6890:  BTFSC  FF2.7
6892:  BSF    19.7
6894:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
6896:  MOVFF  23,903
689A:  MOVFF  22,902
689E:  MOVFF  21,901
68A2:  MOVFF  20,900
68A6:  MOVLW  19
68A8:  MOVLB  9
68AA:  MOVWF  x04
68AC:  MOVLB  0
68AE:  CALL   3B7E
68B2:  BTFSC  19.7
68B4:  BSF    FF2.7
68B6:  CLRF   19
68B8:  BTFSC  FF2.7
68BA:  BSF    19.7
68BC:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
68BE:  MOVFF  27,903
68C2:  MOVFF  26,902
68C6:  MOVFF  25,901
68CA:  MOVFF  24,900
68CE:  MOVLW  1E
68D0:  MOVLB  9
68D2:  MOVWF  x04
68D4:  MOVLB  0
68D6:  CALL   3B7E
68DA:  BTFSC  19.7
68DC:  BSF    FF2.7
68DE:  CLRF   19
68E0:  BTFSC  FF2.7
68E2:  BSF    19.7
68E4:  BCF    FF2.7
....................    save_coutcard(0); 
68E6:  MOVLB  8
68E8:  CLRF   x51
68EA:  CLRF   x50
68EC:  MOVLB  0
68EE:  CALL   5858
68F2:  BTFSC  19.7
68F4:  BSF    FF2.7
68F6:  CLRF   19
68F8:  BTFSC  FF2.7
68FA:  BSF    19.7
68FC:  BCF    FF2.7
....................    countcard=get_countcard(); 
68FE:  CALL   3534
6902:  BTFSC  19.7
6904:  BSF    FF2.7
6906:  MOVFF  02,FE
690A:  MOVFF  01,FD
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
690E:  GOTO   6BA8 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    ptr_card=ptr_start; 
6912:  CLRF   23
6914:  CLRF   22
6916:  CLRF   21
6918:  MOVLW  96
691A:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
691C:  CLRF   27
691E:  MOVLW  01
6920:  MOVWF  26
6922:  MOVLW  C3
6924:  MOVWF  25
6926:  MOVLW  0F
6928:  MOVWF  24
692A:  CLRF   19
692C:  BTFSC  FF2.7
692E:  BSF    19.7
6930:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
6932:  MOVFF  23,903
6936:  MOVFF  22,902
693A:  MOVFF  21,901
693E:  MOVFF  20,900
6942:  MOVLW  19
6944:  MOVLB  9
6946:  MOVWF  x04
6948:  MOVLB  0
694A:  CALL   3B7E
694E:  BTFSC  19.7
6950:  BSF    FF2.7
6952:  CLRF   19
6954:  BTFSC  FF2.7
6956:  BSF    19.7
6958:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
695A:  MOVFF  27,903
695E:  MOVFF  26,902
6962:  MOVFF  25,901
6966:  MOVFF  24,900
696A:  MOVLW  1E
696C:  MOVLB  9
696E:  MOVWF  x04
6970:  MOVLB  0
6972:  CALL   3B7E
6976:  BTFSC  19.7
6978:  BSF    FF2.7
697A:  CLRF   19
697C:  BTFSC  FF2.7
697E:  BSF    19.7
6980:  BCF    FF2.7
....................    save_coutcard(0); 
6982:  MOVLB  8
6984:  CLRF   x51
6986:  CLRF   x50
6988:  MOVLB  0
698A:  CALL   5858
698E:  BTFSC  19.7
6990:  BSF    FF2.7
.................... } 
6992:  GOTO   6C0C (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
*
5CD6:  CLRF   19
5CD8:  BTFSC  FF2.7
5CDA:  BSF    19.7
5CDC:  BCF    FF2.7
....................       EEPROM_read(strobe_pass_addr,20,password); 
5CDE:  MOVLB  9
5CE0:  CLRF   x07
5CE2:  CLRF   x06
5CE4:  CLRF   x05
5CE6:  CLRF   x04
5CE8:  CLRF   x0B
5CEA:  CLRF   x0A
5CEC:  CLRF   x09
5CEE:  MOVLW  14
5CF0:  MOVWF  x08
5CF2:  CLRF   x0D
5CF4:  MOVLW  55
5CF6:  MOVWF  x0C
5CF8:  MOVLB  0
5CFA:  CALL   4094
5CFE:  BTFSC  19.7
5D00:  BSF    FF2.7
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5D02:  INCFSZ 55,W
5D04:  BRA    5D90
5D06:  INCFSZ 56,W
5D08:  BRA    5D90
5D0A:  INCFSZ x64,W
5D0C:  BRA    5D90
....................       { 
....................          memset(buffer1,0,20); 
5D0E:  CLRF   FEA
5D10:  MOVLW  2D
5D12:  MOVWF  FE9
5D14:  CLRF   00
5D16:  CLRF   02
5D18:  MOVLW  14
5D1A:  MOVWF  01
5D1C:  CALL   35AE
....................          strcpy(buffer1,"admin"); 
5D20:  CLRF   FEA
5D22:  MOVLW  2D
5D24:  MOVWF  FE9
5D26:  MOVLW  00
5D28:  CALL   00BA
5D2C:  TBLRD*-
5D2E:  TBLRD*+
5D30:  MOVF   FF5,W
5D32:  MOVWF  FEE
5D34:  IORLW  00
5D36:  BNZ   5D2E
5D38:  CLRF   19
5D3A:  BTFSC  FF2.7
5D3C:  BSF    19.7
5D3E:  BCF    FF2.7
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
5D40:  MOVLB  9
5D42:  CLRF   x03
5D44:  CLRF   x02
5D46:  CLRF   x01
5D48:  CLRF   x00
5D4A:  CLRF   x07
5D4C:  CLRF   x06
5D4E:  CLRF   x05
5D50:  MOVLW  14
5D52:  MOVWF  x04
5D54:  CLRF   x09
5D56:  MOVLW  2D
5D58:  MOVWF  x08
5D5A:  MOVLB  0
5D5C:  CALL   4DFE
5D60:  BTFSC  19.7
5D62:  BSF    FF2.7
5D64:  CLRF   19
5D66:  BTFSC  FF2.7
5D68:  BSF    19.7
5D6A:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
5D6C:  MOVLB  9
5D6E:  CLRF   x07
5D70:  CLRF   x06
5D72:  CLRF   x05
5D74:  CLRF   x04
5D76:  CLRF   x0B
5D78:  CLRF   x0A
5D7A:  CLRF   x09
5D7C:  MOVLW  14
5D7E:  MOVWF  x08
5D80:  CLRF   x0D
5D82:  MOVLW  55
5D84:  MOVWF  x0C
5D86:  MOVLB  0
5D88:  CALL   4094
5D8C:  BTFSC  19.7
5D8E:  BSF    FF2.7
....................       } 
.................... } 
5D90:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
6996:  MOVLB  8
6998:  CLRF   x07
699A:  MOVF   x07,W
699C:  SUBLW  13
699E:  BNC   69B4
69A0:  CLRF   03
69A2:  MOVF   x07,W
69A4:  ADDLW  F3
69A6:  MOVWF  FE9
69A8:  MOVLW  07
69AA:  ADDWFC 03,W
69AC:  MOVWF  FEA
69AE:  SETF   FEF
69B0:  INCF   x07,F
69B2:  BRA    699A
69B4:  CLRF   19
69B6:  BTFSC  FF2.7
69B8:  BSF    19.7
69BA:  BCF    FF2.7
....................    EEPROM_write(strobe_pass_addr,20,buf); 
69BC:  MOVLB  9
69BE:  CLRF   x03
69C0:  CLRF   x02
69C2:  CLRF   x01
69C4:  CLRF   x00
69C6:  CLRF   x07
69C8:  CLRF   x06
69CA:  CLRF   x05
69CC:  MOVLW  14
69CE:  MOVWF  x04
69D0:  MOVLW  07
69D2:  MOVWF  x09
69D4:  MOVLW  F3
69D6:  MOVWF  x08
69D8:  MOVLB  0
69DA:  CALL   4DFE
69DE:  BTFSC  19.7
69E0:  BSF    FF2.7
.................... } 
69E2:  GOTO   6C70 (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
....................  
.................... #define CRYPTO_KEY_SIZE   32 
....................  
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 cryption_enable=0; 
....................  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int16 galois_mul2(unsigned int16 value) 
.................... { 
....................   signed int16 temp; 
....................   // cast to signed value 
....................   temp = (signed char) value; 
*
4128:  CLRF   03
412A:  MOVLB  9
412C:  MOVF   x0D,W
412E:  BTFSC  FE8.7
4130:  DECF   03,F
4132:  MOVWF  x0F
4134:  MOVFF  03,910
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
4138:  RRCF   x10,W
413A:  MOVWF  03
413C:  RRCF   x0F,W
413E:  MOVWF  02
4140:  RRCF   03,F
4142:  RRCF   02,F
4144:  RRCF   03,F
4146:  RRCF   02,F
4148:  RRCF   03,F
414A:  RRCF   02,F
414C:  RRCF   03,F
414E:  RRCF   02,F
4150:  RRCF   03,F
4152:  RRCF   02,F
4154:  RRCF   03,F
4156:  RRCF   02,F
4158:  MOVLW  01
415A:  ANDWF  03,F
415C:  MOVFF  02,90F
4160:  MOVFF  03,910
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
4164:  MOVLW  1B
4166:  ANDWF  x0F,F
4168:  CLRF   x10
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
416A:  BCF    FD8.0
416C:  RLCF   x0D,W
416E:  MOVWF  x11
4170:  RLCF   x0E,W
4172:  MOVWF  x12
4174:  MOVF   x11,W
4176:  XORWF  x0F,W
4178:  MOVWF  00
417A:  MOVF   x12,W
417C:  XORWF  x10,W
417E:  MOVWF  03
4180:  MOVFF  00,01
4184:  MOVWF  02
.................... } 
4186:  MOVLB  0
4188:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................     unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................  
....................   // In case of decryption 
....................   if (dir != 0)  
418A:  MOVLB  9
418C:  MOVF   x04,F
418E:  BTFSC  FD8.2
4190:  BRA    435C
....................   { 
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
4192:  CLRF   x09
4194:  MOVF   x09,W
4196:  SUBLW  09
4198:  BTFSS  FD8.0
419A:  BRA    4312
....................       //key schedule 
....................       key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[round]); 
419C:  MOVFF  902,01
41A0:  MOVFF  903,03
41A4:  MOVFF  902,90B
41A8:  MOVFF  903,90C
41AC:  MOVLW  0D
41AE:  ADDWF  x02,W
41B0:  MOVWF  FE9
41B2:  MOVLW  00
41B4:  ADDWFC x03,W
41B6:  MOVWF  FEA
41B8:  CLRF   03
41BA:  MOVF   FEF,W
41BC:  MOVLB  0
41BE:  CALL   00D0
41C2:  MOVLB  9
41C4:  MOVWF  x0D
41C6:  MOVFF  902,FE9
41CA:  MOVFF  903,FEA
41CE:  MOVF   FEF,W
41D0:  XORWF  x0D,F
41D2:  CLRF   03
41D4:  MOVF   x09,W
41D6:  MOVLB  0
41D8:  CALL   02F0
41DC:  MOVWF  01
41DE:  MOVLB  9
41E0:  MOVF   x0D,W
41E2:  XORWF  01,W
41E4:  MOVFF  90C,FEA
41E8:  MOVFF  90B,FE9
41EC:  MOVWF  FEF
....................       key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
41EE:  MOVLW  01
41F0:  ADDWF  x02,W
41F2:  MOVWF  01
41F4:  MOVLW  00
41F6:  ADDWFC x03,W
41F8:  MOVWF  03
41FA:  MOVFF  01,90B
41FE:  MOVWF  x0C
4200:  MOVLW  0E
4202:  ADDWF  x02,W
4204:  MOVWF  FE9
4206:  MOVLW  00
4208:  ADDWFC x03,W
420A:  MOVWF  FEA
420C:  CLRF   03
420E:  MOVF   FEF,W
4210:  MOVLB  0
4212:  CALL   00D0
4216:  MOVLB  9
4218:  MOVWF  x0D
421A:  MOVLW  01
421C:  ADDWF  x02,W
421E:  MOVWF  FE9
4220:  MOVLW  00
4222:  ADDWFC x03,W
4224:  MOVWF  FEA
4226:  MOVF   FEF,W
4228:  XORWF  x0D,W
422A:  MOVFF  90C,FEA
422E:  MOVFF  90B,FE9
4232:  MOVWF  FEF
....................       key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
4234:  MOVLW  02
4236:  ADDWF  x02,W
4238:  MOVWF  01
423A:  MOVLW  00
423C:  ADDWFC x03,W
423E:  MOVWF  03
4240:  MOVFF  01,90B
4244:  MOVWF  x0C
4246:  MOVLW  0F
4248:  ADDWF  x02,W
424A:  MOVWF  FE9
424C:  MOVLW  00
424E:  ADDWFC x03,W
4250:  MOVWF  FEA
4252:  CLRF   03
4254:  MOVF   FEF,W
4256:  MOVLB  0
4258:  CALL   00D0
425C:  MOVLB  9
425E:  MOVWF  x0D
4260:  MOVLW  02
4262:  ADDWF  x02,W
4264:  MOVWF  FE9
4266:  MOVLW  00
4268:  ADDWFC x03,W
426A:  MOVWF  FEA
426C:  MOVF   FEF,W
426E:  XORWF  x0D,W
4270:  MOVFF  90C,FEA
4274:  MOVFF  90B,FE9
4278:  MOVWF  FEF
....................       key[3] = (unsigned int8)(sbox[key[12]]^key[3]); 
427A:  MOVLW  03
427C:  ADDWF  x02,W
427E:  MOVWF  01
4280:  MOVLW  00
4282:  ADDWFC x03,W
4284:  MOVWF  03
4286:  MOVFF  01,90B
428A:  MOVWF  x0C
428C:  MOVLW  0C
428E:  ADDWF  x02,W
4290:  MOVWF  FE9
4292:  MOVLW  00
4294:  ADDWFC x03,W
4296:  MOVWF  FEA
4298:  CLRF   03
429A:  MOVF   FEF,W
429C:  MOVLB  0
429E:  CALL   00D0
42A2:  MOVLB  9
42A4:  MOVWF  x0D
42A6:  MOVLW  03
42A8:  ADDWF  x02,W
42AA:  MOVWF  FE9
42AC:  MOVLW  00
42AE:  ADDWFC x03,W
42B0:  MOVWF  FEA
42B2:  MOVF   FEF,W
42B4:  XORWF  x0D,W
42B6:  MOVFF  90C,FEA
42BA:  MOVFF  90B,FE9
42BE:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
42C0:  MOVLW  04
42C2:  MOVWF  x0A
42C4:  MOVF   x0A,W
42C6:  SUBLW  0F
42C8:  BNC   430E
....................         key[i] = key[i] ^ key[i-4]; 
42CA:  CLRF   03
42CC:  MOVF   x0A,W
42CE:  ADDWF  x02,W
42D0:  MOVWF  01
42D2:  MOVF   x03,W
42D4:  ADDWFC 03,F
42D6:  MOVFF  03,90C
42DA:  CLRF   03
42DC:  MOVF   x0A,W
42DE:  ADDWF  x02,W
42E0:  MOVWF  FE9
42E2:  MOVF   x03,W
42E4:  ADDWFC 03,W
42E6:  MOVWF  FEA
42E8:  MOVFF  FEF,90D
42EC:  MOVLW  04
42EE:  SUBWF  x0A,W
42F0:  CLRF   03
42F2:  ADDWF  x02,W
42F4:  MOVWF  FE9
42F6:  MOVF   x03,W
42F8:  ADDWFC 03,W
42FA:  MOVWF  FEA
42FC:  MOVF   FEF,W
42FE:  XORWF  x0D,W
4300:  MOVFF  90C,FEA
4304:  MOVFF  01,FE9
4308:  MOVWF  FEF
....................       } 
430A:  INCF   x0A,F
430C:  BRA    42C4
....................     } 
430E:  INCF   x09,F
4310:  BRA    4194
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++) 
4312:  CLRF   x0A
4314:  MOVF   x0A,W
4316:  SUBLW  0F
4318:  BNC   435C
....................     { 
....................       state[i]=state[i] ^ key[i]; 
431A:  CLRF   03
431C:  MOVF   x0A,W
431E:  ADDWF  x00,W
4320:  MOVWF  01
4322:  MOVF   x01,W
4324:  ADDWFC 03,F
4326:  MOVFF  03,90C
432A:  CLRF   03
432C:  MOVF   x0A,W
432E:  ADDWF  x00,W
4330:  MOVWF  FE9
4332:  MOVF   x01,W
4334:  ADDWFC 03,W
4336:  MOVWF  FEA
4338:  MOVFF  FEF,90D
433C:  CLRF   03
433E:  MOVF   x0A,W
4340:  ADDWF  x02,W
4342:  MOVWF  FE9
4344:  MOVF   x03,W
4346:  ADDWFC 03,W
4348:  MOVWF  FEA
434A:  MOVF   FEF,W
434C:  XORWF  x0D,W
434E:  MOVFF  90C,FEA
4352:  MOVFF  01,FE9
4356:  MOVWF  FEF
....................     } 
4358:  INCF   x0A,F
435A:  BRA    4314
....................   } 
....................   // main loop 
....................   for (round = 0; round < 10; round++) 
435C:  CLRF   x09
435E:  MOVF   x09,W
4360:  SUBLW  09
4362:  BTFSS  FD8.0
4364:  GOTO   4DAC
....................   { 
....................     if (dir != 0) 
4368:  MOVF   x04,F
436A:  BTFSC  FD8.2
436C:  BRA    44E6
....................     { 
....................           //Inverse key schedule 
....................           for (i=15; i>3; --i)  
436E:  MOVLW  0F
4370:  MOVWF  x0A
4372:  MOVF   x0A,W
4374:  SUBLW  03
4376:  BC    43BC
....................           { 
....................             key[i] = key[i] ^ key[i-4]; 
4378:  CLRF   03
437A:  MOVF   x0A,W
437C:  ADDWF  x02,W
437E:  MOVWF  01
4380:  MOVF   x03,W
4382:  ADDWFC 03,F
4384:  MOVFF  03,90C
4388:  CLRF   03
438A:  MOVF   x0A,W
438C:  ADDWF  x02,W
438E:  MOVWF  FE9
4390:  MOVF   x03,W
4392:  ADDWFC 03,W
4394:  MOVWF  FEA
4396:  MOVFF  FEF,90D
439A:  MOVLW  04
439C:  SUBWF  x0A,W
439E:  CLRF   03
43A0:  ADDWF  x02,W
43A2:  MOVWF  FE9
43A4:  MOVF   x03,W
43A6:  ADDWFC 03,W
43A8:  MOVWF  FEA
43AA:  MOVF   FEF,W
43AC:  XORWF  x0D,W
43AE:  MOVFF  90C,FEA
43B2:  MOVFF  01,FE9
43B6:  MOVWF  FEF
....................           }   
43B8:  DECF   x0A,F
43BA:  BRA    4372
....................           key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[9-round]); 
43BC:  MOVFF  902,01
43C0:  MOVFF  903,03
43C4:  MOVFF  902,90B
43C8:  MOVFF  903,90C
43CC:  MOVLW  0D
43CE:  ADDWF  x02,W
43D0:  MOVWF  FE9
43D2:  MOVLW  00
43D4:  ADDWFC x03,W
43D6:  MOVWF  FEA
43D8:  CLRF   03
43DA:  MOVF   FEF,W
43DC:  MOVLB  0
43DE:  CALL   00D0
43E2:  MOVLB  9
43E4:  MOVWF  x0D
43E6:  MOVFF  902,FE9
43EA:  MOVFF  903,FEA
43EE:  MOVF   FEF,W
43F0:  XORWF  x0D,F
43F2:  MOVLW  09
43F4:  BSF    FD8.0
43F6:  SUBFWB x09,W
43F8:  CLRF   03
43FA:  MOVLB  0
43FC:  CALL   02F0
4400:  MOVWF  01
4402:  MOVLB  9
4404:  MOVF   x0D,W
4406:  XORWF  01,W
4408:  MOVFF  90C,FEA
440C:  MOVFF  90B,FE9
4410:  MOVWF  FEF
....................           key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4412:  MOVLW  01
4414:  ADDWF  x02,W
4416:  MOVWF  01
4418:  MOVLW  00
441A:  ADDWFC x03,W
441C:  MOVWF  03
441E:  MOVFF  01,90B
4422:  MOVWF  x0C
4424:  MOVLW  0E
4426:  ADDWF  x02,W
4428:  MOVWF  FE9
442A:  MOVLW  00
442C:  ADDWFC x03,W
442E:  MOVWF  FEA
4430:  CLRF   03
4432:  MOVF   FEF,W
4434:  MOVLB  0
4436:  CALL   00D0
443A:  MOVLB  9
443C:  MOVWF  x0D
443E:  MOVLW  01
4440:  ADDWF  x02,W
4442:  MOVWF  FE9
4444:  MOVLW  00
4446:  ADDWFC x03,W
4448:  MOVWF  FEA
444A:  MOVF   FEF,W
444C:  XORWF  x0D,W
444E:  MOVFF  90C,FEA
4452:  MOVFF  90B,FE9
4456:  MOVWF  FEF
....................           key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
4458:  MOVLW  02
445A:  ADDWF  x02,W
445C:  MOVWF  01
445E:  MOVLW  00
4460:  ADDWFC x03,W
4462:  MOVWF  03
4464:  MOVFF  01,90B
4468:  MOVWF  x0C
446A:  MOVLW  0F
446C:  ADDWF  x02,W
446E:  MOVWF  FE9
4470:  MOVLW  00
4472:  ADDWFC x03,W
4474:  MOVWF  FEA
4476:  CLRF   03
4478:  MOVF   FEF,W
447A:  MOVLB  0
447C:  CALL   00D0
4480:  MOVLB  9
4482:  MOVWF  x0D
4484:  MOVLW  02
4486:  ADDWF  x02,W
4488:  MOVWF  FE9
448A:  MOVLW  00
448C:  ADDWFC x03,W
448E:  MOVWF  FEA
4490:  MOVF   FEF,W
4492:  XORWF  x0D,W
4494:  MOVFF  90C,FEA
4498:  MOVFF  90B,FE9
449C:  MOVWF  FEF
....................           key[3] = (unsigned int8)(sbox[key[12]]^key[3]);  
449E:  MOVLW  03
44A0:  ADDWF  x02,W
44A2:  MOVWF  01
44A4:  MOVLW  00
44A6:  ADDWFC x03,W
44A8:  MOVWF  03
44AA:  MOVFF  01,90B
44AE:  MOVWF  x0C
44B0:  MOVLW  0C
44B2:  ADDWF  x02,W
44B4:  MOVWF  FE9
44B6:  MOVLW  00
44B8:  ADDWFC x03,W
44BA:  MOVWF  FEA
44BC:  CLRF   03
44BE:  MOVF   FEF,W
44C0:  MOVLB  0
44C2:  CALL   00D0
44C6:  MOVLB  9
44C8:  MOVWF  x0D
44CA:  MOVLW  03
44CC:  ADDWF  x02,W
44CE:  MOVWF  FE9
44D0:  MOVLW  00
44D2:  ADDWFC x03,W
44D4:  MOVWF  FEA
44D6:  MOVF   FEF,W
44D8:  XORWF  x0D,W
44DA:  MOVFF  90C,FEA
44DE:  MOVFF  90B,FE9
44E2:  MOVWF  FEF
....................     }  
....................     else  
44E4:  BRA    46FE
....................     { 
....................         for (i = 0; i <16; i++) 
44E6:  CLRF   x0A
44E8:  MOVF   x0A,W
44EA:  SUBLW  0F
44EC:  BNC   453E
....................         { 
....................             // with shiftrow i+5 mod 16 
....................             state[i]=sbox[state[i] ^ key[i]]; 
44EE:  CLRF   03
44F0:  MOVF   x0A,W
44F2:  ADDWF  x00,W
44F4:  MOVWF  01
44F6:  MOVF   x01,W
44F8:  ADDWFC 03,F
44FA:  MOVFF  01,90B
44FE:  MOVFF  03,90C
4502:  CLRF   03
4504:  MOVF   x0A,W
4506:  ADDWF  x00,W
4508:  MOVWF  FE9
450A:  MOVF   x01,W
450C:  ADDWFC 03,W
450E:  MOVWF  FEA
4510:  MOVFF  FEF,90D
4514:  CLRF   03
4516:  MOVF   x0A,W
4518:  ADDWF  x02,W
451A:  MOVWF  FE9
451C:  MOVF   x03,W
451E:  ADDWFC 03,W
4520:  MOVWF  FEA
4522:  MOVF   FEF,W
4524:  XORWF  x0D,W
4526:  CLRF   03
4528:  MOVLB  0
452A:  CALL   00D0
452E:  MOVFF  90C,FEA
4532:  MOVFF  90B,FE9
4536:  MOVWF  FEF
....................         } 
4538:  MOVLB  9
453A:  INCF   x0A,F
453C:  BRA    44E8
....................         //shift rows 
....................         buf1 = state[1]; 
453E:  MOVLW  01
4540:  ADDWF  x00,W
4542:  MOVWF  FE9
4544:  MOVLW  00
4546:  ADDWFC x01,W
4548:  MOVWF  FEA
454A:  MOVFF  FEF,905
....................         state[1] = state[5]; 
454E:  MOVLW  01
4550:  ADDWF  x00,W
4552:  MOVWF  01
4554:  MOVLW  00
4556:  ADDWFC x01,W
4558:  MOVWF  03
455A:  MOVLW  05
455C:  ADDWF  x00,W
455E:  MOVWF  FE9
4560:  MOVLW  00
4562:  ADDWFC x01,W
4564:  MOVWF  FEA
4566:  MOVFF  FEF,90D
456A:  MOVFF  03,FEA
456E:  MOVFF  01,FE9
4572:  MOVFF  90D,FEF
....................         state[5] = state[9]; 
4576:  MOVLW  05
4578:  ADDWF  x00,W
457A:  MOVWF  01
457C:  MOVLW  00
457E:  ADDWFC x01,W
4580:  MOVWF  03
4582:  MOVLW  09
4584:  ADDWF  x00,W
4586:  MOVWF  FE9
4588:  MOVLW  00
458A:  ADDWFC x01,W
458C:  MOVWF  FEA
458E:  MOVFF  FEF,90D
4592:  MOVFF  03,FEA
4596:  MOVFF  01,FE9
459A:  MOVFF  90D,FEF
....................         state[9] = state[13]; 
459E:  MOVLW  09
45A0:  ADDWF  x00,W
45A2:  MOVWF  01
45A4:  MOVLW  00
45A6:  ADDWFC x01,W
45A8:  MOVWF  03
45AA:  MOVLW  0D
45AC:  ADDWF  x00,W
45AE:  MOVWF  FE9
45B0:  MOVLW  00
45B2:  ADDWFC x01,W
45B4:  MOVWF  FEA
45B6:  MOVFF  FEF,90D
45BA:  MOVFF  03,FEA
45BE:  MOVFF  01,FE9
45C2:  MOVFF  90D,FEF
....................         state[13] = buf1; 
45C6:  MOVLW  0D
45C8:  ADDWF  x00,W
45CA:  MOVWF  FE9
45CC:  MOVLW  00
45CE:  ADDWFC x01,W
45D0:  MOVWF  FEA
45D2:  MOVFF  905,FEF
....................      
....................         buf1 = state[2]; 
45D6:  MOVLW  02
45D8:  ADDWF  x00,W
45DA:  MOVWF  FE9
45DC:  MOVLW  00
45DE:  ADDWFC x01,W
45E0:  MOVWF  FEA
45E2:  MOVFF  FEF,905
....................         buf2 = state[6]; 
45E6:  MOVLW  06
45E8:  ADDWF  x00,W
45EA:  MOVWF  FE9
45EC:  MOVLW  00
45EE:  ADDWFC x01,W
45F0:  MOVWF  FEA
45F2:  MOVFF  FEF,906
....................         state[2] = state[10]; 
45F6:  MOVLW  02
45F8:  ADDWF  x00,W
45FA:  MOVWF  01
45FC:  MOVLW  00
45FE:  ADDWFC x01,W
4600:  MOVWF  03
4602:  MOVLW  0A
4604:  ADDWF  x00,W
4606:  MOVWF  FE9
4608:  MOVLW  00
460A:  ADDWFC x01,W
460C:  MOVWF  FEA
460E:  MOVFF  FEF,90D
4612:  MOVFF  03,FEA
4616:  MOVFF  01,FE9
461A:  MOVFF  90D,FEF
....................         state[6] = state[14]; 
461E:  MOVLW  06
4620:  ADDWF  x00,W
4622:  MOVWF  01
4624:  MOVLW  00
4626:  ADDWFC x01,W
4628:  MOVWF  03
462A:  MOVLW  0E
462C:  ADDWF  x00,W
462E:  MOVWF  FE9
4630:  MOVLW  00
4632:  ADDWFC x01,W
4634:  MOVWF  FEA
4636:  MOVFF  FEF,90D
463A:  MOVFF  03,FEA
463E:  MOVFF  01,FE9
4642:  MOVFF  90D,FEF
....................         state[10] = buf1; 
4646:  MOVLW  0A
4648:  ADDWF  x00,W
464A:  MOVWF  FE9
464C:  MOVLW  00
464E:  ADDWFC x01,W
4650:  MOVWF  FEA
4652:  MOVFF  905,FEF
....................         state[14] = buf2; 
4656:  MOVLW  0E
4658:  ADDWF  x00,W
465A:  MOVWF  FE9
465C:  MOVLW  00
465E:  ADDWFC x01,W
4660:  MOVWF  FEA
4662:  MOVFF  906,FEF
....................      
....................         buf1 = state[15]; 
4666:  MOVLW  0F
4668:  ADDWF  x00,W
466A:  MOVWF  FE9
466C:  MOVLW  00
466E:  ADDWFC x01,W
4670:  MOVWF  FEA
4672:  MOVFF  FEF,905
....................         state[15] = state[11]; 
4676:  MOVLW  0F
4678:  ADDWF  x00,W
467A:  MOVWF  01
467C:  MOVLW  00
467E:  ADDWFC x01,W
4680:  MOVWF  03
4682:  MOVLW  0B
4684:  ADDWF  x00,W
4686:  MOVWF  FE9
4688:  MOVLW  00
468A:  ADDWFC x01,W
468C:  MOVWF  FEA
468E:  MOVFF  FEF,90D
4692:  MOVFF  03,FEA
4696:  MOVFF  01,FE9
469A:  MOVFF  90D,FEF
....................         state[11] = state[7]; 
469E:  MOVLW  0B
46A0:  ADDWF  x00,W
46A2:  MOVWF  01
46A4:  MOVLW  00
46A6:  ADDWFC x01,W
46A8:  MOVWF  03
46AA:  MOVLW  07
46AC:  ADDWF  x00,W
46AE:  MOVWF  FE9
46B0:  MOVLW  00
46B2:  ADDWFC x01,W
46B4:  MOVWF  FEA
46B6:  MOVFF  FEF,90D
46BA:  MOVFF  03,FEA
46BE:  MOVFF  01,FE9
46C2:  MOVFF  90D,FEF
....................         state[7] = state[3]; 
46C6:  MOVLW  07
46C8:  ADDWF  x00,W
46CA:  MOVWF  01
46CC:  MOVLW  00
46CE:  ADDWFC x01,W
46D0:  MOVWF  03
46D2:  MOVLW  03
46D4:  ADDWF  x00,W
46D6:  MOVWF  FE9
46D8:  MOVLW  00
46DA:  ADDWFC x01,W
46DC:  MOVWF  FEA
46DE:  MOVFF  FEF,90D
46E2:  MOVFF  03,FEA
46E6:  MOVFF  01,FE9
46EA:  MOVFF  90D,FEF
....................         state[3] = buf1; 
46EE:  MOVLW  03
46F0:  ADDWF  x00,W
46F2:  MOVWF  FE9
46F4:  MOVLW  00
46F6:  ADDWFC x01,W
46F8:  MOVWF  FEA
46FA:  MOVFF  905,FEF
....................     } 
....................      
....................     //mixcol - inv mix 
....................     if (((round > 0) && (dir != 0)) || ((round < 9) && (dir == 0)))  
46FE:  MOVF   x09,F
4700:  BZ    4706
4702:  MOVF   x04,F
4704:  BNZ   4714
4706:  MOVF   x09,W
4708:  SUBLW  08
470A:  BTFSS  FD8.0
470C:  BRA    4A14
470E:  MOVF   x04,F
4710:  BTFSS  FD8.2
4712:  BRA    4A14
....................     { 
....................           for (i=0; i <4; i++) 
4714:  CLRF   x0A
4716:  MOVF   x0A,W
4718:  SUBLW  03
471A:  BTFSS  FD8.0
471C:  BRA    4A14
....................           { 
....................                 buf4 = (unsigned int8)(i << 2); 
471E:  RLCF   x0A,W
4720:  MOVWF  x08
4722:  RLCF   x08,F
4724:  MOVLW  FC
4726:  ANDWF  x08,F
....................                 if (dir != 0) 
4728:  MOVF   x04,F
472A:  BZ    4814
....................                 { 
....................                       // precompute for decryption 
....................                       buf1 = galois_mul2(galois_mul2((unsigned int8)(state[buf4]^state[buf4+2]))); 
472C:  CLRF   03
472E:  MOVF   x08,W
4730:  ADDWF  x00,W
4732:  MOVWF  FE9
4734:  MOVF   x01,W
4736:  ADDWFC 03,W
4738:  MOVWF  FEA
473A:  MOVFF  FEF,90B
473E:  MOVLW  02
4740:  ADDWF  x08,W
4742:  CLRF   03
4744:  ADDWF  x00,W
4746:  MOVWF  FE9
4748:  MOVF   x01,W
474A:  ADDWFC 03,W
474C:  MOVWF  FEA
474E:  MOVF   FEF,W
4750:  XORWF  x0B,F
4752:  CLRF   x0E
4754:  MOVFF  90B,90D
4758:  MOVLB  0
475A:  RCALL  4128
475C:  MOVFF  02,90C
4760:  MOVFF  01,90B
4764:  MOVFF  02,90E
4768:  MOVFF  01,90D
476C:  RCALL  4128
476E:  MOVFF  01,905
....................                       buf2 = galois_mul2(galois_mul2((unsigned int8)(state[buf4+1]^state[buf4+3]))); 
4772:  MOVLW  01
4774:  MOVLB  9
4776:  ADDWF  x08,W
4778:  CLRF   03
477A:  ADDWF  x00,W
477C:  MOVWF  FE9
477E:  MOVF   x01,W
4780:  ADDWFC 03,W
4782:  MOVWF  FEA
4784:  MOVFF  FEF,90B
4788:  MOVLW  03
478A:  ADDWF  x08,W
478C:  CLRF   03
478E:  ADDWF  x00,W
4790:  MOVWF  FE9
4792:  MOVF   x01,W
4794:  ADDWFC 03,W
4796:  MOVWF  FEA
4798:  MOVF   FEF,W
479A:  XORWF  x0B,F
479C:  CLRF   x0E
479E:  MOVFF  90B,90D
47A2:  MOVLB  0
47A4:  RCALL  4128
47A6:  MOVFF  02,90C
47AA:  MOVFF  01,90B
47AE:  MOVFF  02,90E
47B2:  MOVFF  01,90D
47B6:  RCALL  4128
47B8:  MOVFF  01,906
....................                       state[buf4] ^= buf1;  
47BC:  CLRF   03
47BE:  MOVLB  9
47C0:  MOVF   x08,W
47C2:  ADDWF  x00,W
47C4:  MOVWF  FE9
47C6:  MOVF   x01,W
47C8:  ADDWFC 03,W
47CA:  MOVWF  FEA
47CC:  MOVF   FEF,W
47CE:  XORWF  x05,W
47D0:  MOVWF  FEF
....................                       state[buf4+1] ^= buf2;  
47D2:  MOVLW  01
47D4:  ADDWF  x08,W
47D6:  CLRF   03
47D8:  ADDWF  x00,W
47DA:  MOVWF  FE9
47DC:  MOVF   x01,W
47DE:  ADDWFC 03,W
47E0:  MOVWF  FEA
47E2:  MOVF   FEF,W
47E4:  XORWF  x06,W
47E6:  MOVWF  FEF
....................                       state[buf4+2] ^= buf1;  
47E8:  MOVLW  02
47EA:  ADDWF  x08,W
47EC:  CLRF   03
47EE:  ADDWF  x00,W
47F0:  MOVWF  FE9
47F2:  MOVF   x01,W
47F4:  ADDWFC 03,W
47F6:  MOVWF  FEA
47F8:  MOVF   FEF,W
47FA:  XORWF  x05,W
47FC:  MOVWF  FEF
....................                       state[buf4+3] ^= buf2;  
47FE:  MOVLW  03
4800:  ADDWF  x08,W
4802:  CLRF   03
4804:  ADDWF  x00,W
4806:  MOVWF  FE9
4808:  MOVF   x01,W
480A:  ADDWFC 03,W
480C:  MOVWF  FEA
480E:  MOVF   FEF,W
4810:  XORWF  x06,W
4812:  MOVWF  FEF
....................                 } 
....................                 // in all cases 
....................                 buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
4814:  CLRF   03
4816:  MOVF   x08,W
4818:  ADDWF  x00,W
481A:  MOVWF  FE9
481C:  MOVF   x01,W
481E:  ADDWFC 03,W
4820:  MOVWF  FEA
4822:  MOVFF  FEF,90B
4826:  MOVLW  01
4828:  ADDWF  x08,W
482A:  CLRF   03
482C:  ADDWF  x00,W
482E:  MOVWF  FE9
4830:  MOVF   x01,W
4832:  ADDWFC 03,W
4834:  MOVWF  FEA
4836:  MOVF   FEF,W
4838:  XORWF  x0B,F
483A:  MOVLW  02
483C:  ADDWF  x08,W
483E:  CLRF   03
4840:  ADDWF  x00,W
4842:  MOVWF  FE9
4844:  MOVF   x01,W
4846:  ADDWFC 03,W
4848:  MOVWF  FEA
484A:  MOVF   FEF,W
484C:  XORWF  x0B,F
484E:  MOVLW  03
4850:  ADDWF  x08,W
4852:  CLRF   03
4854:  ADDWF  x00,W
4856:  MOVWF  FE9
4858:  MOVF   x01,W
485A:  ADDWFC 03,W
485C:  MOVWF  FEA
485E:  MOVF   FEF,W
4860:  XORWF  x0B,W
4862:  MOVWF  x05
....................                 buf2 = state[buf4]; 
4864:  CLRF   03
4866:  MOVF   x08,W
4868:  ADDWF  x00,W
486A:  MOVWF  FE9
486C:  MOVF   x01,W
486E:  ADDWFC 03,W
4870:  MOVWF  FEA
4872:  MOVFF  FEF,906
....................                 buf3 = state[buf4]^state[buf4+1];  
4876:  CLRF   03
4878:  MOVF   x08,W
487A:  ADDWF  x00,W
487C:  MOVWF  FE9
487E:  MOVF   x01,W
4880:  ADDWFC 03,W
4882:  MOVWF  FEA
4884:  MOVFF  FEF,90B
4888:  MOVLW  01
488A:  ADDWF  x08,W
488C:  CLRF   03
488E:  ADDWF  x00,W
4890:  MOVWF  FE9
4892:  MOVF   x01,W
4894:  ADDWFC 03,W
4896:  MOVWF  FEA
4898:  MOVF   FEF,W
489A:  XORWF  x0B,W
489C:  MOVWF  x07
....................                 buf3=galois_mul2(buf3);  
489E:  CLRF   x0E
48A0:  MOVFF  907,90D
48A4:  MOVLB  0
48A6:  RCALL  4128
48A8:  MOVFF  01,907
....................                 state[buf4] = state[buf4] ^ buf3 ^ buf1; 
48AC:  CLRF   03
48AE:  MOVLB  9
48B0:  MOVF   x08,W
48B2:  ADDWF  x00,W
48B4:  MOVWF  01
48B6:  MOVF   x01,W
48B8:  ADDWFC 03,F
48BA:  MOVFF  03,90C
48BE:  CLRF   03
48C0:  MOVF   x08,W
48C2:  ADDWF  x00,W
48C4:  MOVWF  FE9
48C6:  MOVF   x01,W
48C8:  ADDWFC 03,W
48CA:  MOVWF  FEA
48CC:  MOVF   FEF,W
48CE:  XORWF  x07,W
48D0:  XORWF  x05,W
48D2:  MOVFF  90C,FEA
48D6:  MOVFF  01,FE9
48DA:  MOVWF  FEF
....................                 buf3 = state[buf4+1]^state[buf4+2];  
48DC:  MOVLW  01
48DE:  ADDWF  x08,W
48E0:  CLRF   03
48E2:  ADDWF  x00,W
48E4:  MOVWF  FE9
48E6:  MOVF   x01,W
48E8:  ADDWFC 03,W
48EA:  MOVWF  FEA
48EC:  MOVFF  FEF,90B
48F0:  MOVLW  02
48F2:  ADDWF  x08,W
48F4:  CLRF   03
48F6:  ADDWF  x00,W
48F8:  MOVWF  FE9
48FA:  MOVF   x01,W
48FC:  ADDWFC 03,W
48FE:  MOVWF  FEA
4900:  MOVF   FEF,W
4902:  XORWF  x0B,W
4904:  MOVWF  x07
....................                 buf3=galois_mul2(buf3);  
4906:  CLRF   x0E
4908:  MOVFF  907,90D
490C:  MOVLB  0
490E:  RCALL  4128
4910:  MOVFF  01,907
....................                 state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
4914:  MOVLW  01
4916:  MOVLB  9
4918:  ADDWF  x08,W
491A:  CLRF   03
491C:  ADDWF  x00,W
491E:  MOVWF  01
4920:  MOVF   x01,W
4922:  ADDWFC 03,F
4924:  MOVFF  03,90C
4928:  MOVLW  01
492A:  ADDWF  x08,W
492C:  CLRF   03
492E:  ADDWF  x00,W
4930:  MOVWF  FE9
4932:  MOVF   x01,W
4934:  ADDWFC 03,W
4936:  MOVWF  FEA
4938:  MOVF   FEF,W
493A:  XORWF  x07,W
493C:  XORWF  x05,W
493E:  MOVFF  90C,FEA
4942:  MOVFF  01,FE9
4946:  MOVWF  FEF
....................                 buf3 = state[buf4+2]^state[buf4+3];  
4948:  MOVLW  02
494A:  ADDWF  x08,W
494C:  CLRF   03
494E:  ADDWF  x00,W
4950:  MOVWF  FE9
4952:  MOVF   x01,W
4954:  ADDWFC 03,W
4956:  MOVWF  FEA
4958:  MOVFF  FEF,90B
495C:  MOVLW  03
495E:  ADDWF  x08,W
4960:  CLRF   03
4962:  ADDWF  x00,W
4964:  MOVWF  FE9
4966:  MOVF   x01,W
4968:  ADDWFC 03,W
496A:  MOVWF  FEA
496C:  MOVF   FEF,W
496E:  XORWF  x0B,W
4970:  MOVWF  x07
....................                 buf3=galois_mul2(buf3);  
4972:  CLRF   x0E
4974:  MOVFF  907,90D
4978:  MOVLB  0
497A:  CALL   4128
497E:  MOVFF  01,907
....................                 state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
4982:  MOVLW  02
4984:  MOVLB  9
4986:  ADDWF  x08,W
4988:  CLRF   03
498A:  ADDWF  x00,W
498C:  MOVWF  01
498E:  MOVF   x01,W
4990:  ADDWFC 03,F
4992:  MOVFF  03,90C
4996:  MOVLW  02
4998:  ADDWF  x08,W
499A:  CLRF   03
499C:  ADDWF  x00,W
499E:  MOVWF  FE9
49A0:  MOVF   x01,W
49A2:  ADDWFC 03,W
49A4:  MOVWF  FEA
49A6:  MOVF   FEF,W
49A8:  XORWF  x07,W
49AA:  XORWF  x05,W
49AC:  MOVFF  90C,FEA
49B0:  MOVFF  01,FE9
49B4:  MOVWF  FEF
....................                 buf3 = state[buf4+3]^buf2;      
49B6:  MOVLW  03
49B8:  ADDWF  x08,W
49BA:  CLRF   03
49BC:  ADDWF  x00,W
49BE:  MOVWF  FE9
49C0:  MOVF   x01,W
49C2:  ADDWFC 03,W
49C4:  MOVWF  FEA
49C6:  MOVF   FEF,W
49C8:  XORWF  x06,W
49CA:  MOVWF  x07
....................                 buf3=galois_mul2(buf3);  
49CC:  CLRF   x0E
49CE:  MOVFF  907,90D
49D2:  MOVLB  0
49D4:  CALL   4128
49D8:  MOVFF  01,907
....................                 state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1;  
49DC:  MOVLW  03
49DE:  MOVLB  9
49E0:  ADDWF  x08,W
49E2:  CLRF   03
49E4:  ADDWF  x00,W
49E6:  MOVWF  01
49E8:  MOVF   x01,W
49EA:  ADDWFC 03,F
49EC:  MOVFF  03,90C
49F0:  MOVLW  03
49F2:  ADDWF  x08,W
49F4:  CLRF   03
49F6:  ADDWF  x00,W
49F8:  MOVWF  FE9
49FA:  MOVF   x01,W
49FC:  ADDWFC 03,W
49FE:  MOVWF  FEA
4A00:  MOVF   FEF,W
4A02:  XORWF  x07,W
4A04:  XORWF  x05,W
4A06:  MOVFF  90C,FEA
4A0A:  MOVFF  01,FE9
4A0E:  MOVWF  FEF
....................           } 
4A10:  INCF   x0A,F
4A12:  BRA    4716
....................     } 
....................      
....................     if (dir != 0)  
4A14:  MOVF   x04,F
4A16:  BTFSC  FD8.2
4A18:  BRA    4C34
....................     { 
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
4A1A:  MOVLW  0D
4A1C:  ADDWF  x00,W
4A1E:  MOVWF  FE9
4A20:  MOVLW  00
4A22:  ADDWFC x01,W
4A24:  MOVWF  FEA
4A26:  MOVFF  FEF,905
....................       state[13] = state[9]; 
4A2A:  MOVLW  0D
4A2C:  ADDWF  x00,W
4A2E:  MOVWF  01
4A30:  MOVLW  00
4A32:  ADDWFC x01,W
4A34:  MOVWF  03
4A36:  MOVLW  09
4A38:  ADDWF  x00,W
4A3A:  MOVWF  FE9
4A3C:  MOVLW  00
4A3E:  ADDWFC x01,W
4A40:  MOVWF  FEA
4A42:  MOVFF  FEF,90D
4A46:  MOVFF  03,FEA
4A4A:  MOVFF  01,FE9
4A4E:  MOVFF  90D,FEF
....................       state[9] = state[5]; 
4A52:  MOVLW  09
4A54:  ADDWF  x00,W
4A56:  MOVWF  01
4A58:  MOVLW  00
4A5A:  ADDWFC x01,W
4A5C:  MOVWF  03
4A5E:  MOVLW  05
4A60:  ADDWF  x00,W
4A62:  MOVWF  FE9
4A64:  MOVLW  00
4A66:  ADDWFC x01,W
4A68:  MOVWF  FEA
4A6A:  MOVFF  FEF,90D
4A6E:  MOVFF  03,FEA
4A72:  MOVFF  01,FE9
4A76:  MOVFF  90D,FEF
....................       state[5] = state[1]; 
4A7A:  MOVLW  05
4A7C:  ADDWF  x00,W
4A7E:  MOVWF  01
4A80:  MOVLW  00
4A82:  ADDWFC x01,W
4A84:  MOVWF  03
4A86:  MOVLW  01
4A88:  ADDWF  x00,W
4A8A:  MOVWF  FE9
4A8C:  MOVLW  00
4A8E:  ADDWFC x01,W
4A90:  MOVWF  FEA
4A92:  MOVFF  FEF,90D
4A96:  MOVFF  03,FEA
4A9A:  MOVFF  01,FE9
4A9E:  MOVFF  90D,FEF
....................       state[1] = buf1; 
4AA2:  MOVLW  01
4AA4:  ADDWF  x00,W
4AA6:  MOVWF  FE9
4AA8:  MOVLW  00
4AAA:  ADDWFC x01,W
4AAC:  MOVWF  FEA
4AAE:  MOVFF  905,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
4AB2:  MOVLW  0A
4AB4:  ADDWF  x00,W
4AB6:  MOVWF  FE9
4AB8:  MOVLW  00
4ABA:  ADDWFC x01,W
4ABC:  MOVWF  FEA
4ABE:  MOVFF  FEF,905
....................       buf2 = state[14]; 
4AC2:  MOVLW  0E
4AC4:  ADDWF  x00,W
4AC6:  MOVWF  FE9
4AC8:  MOVLW  00
4ACA:  ADDWFC x01,W
4ACC:  MOVWF  FEA
4ACE:  MOVFF  FEF,906
....................       state[10] = state[2]; 
4AD2:  MOVLW  0A
4AD4:  ADDWF  x00,W
4AD6:  MOVWF  01
4AD8:  MOVLW  00
4ADA:  ADDWFC x01,W
4ADC:  MOVWF  03
4ADE:  MOVLW  02
4AE0:  ADDWF  x00,W
4AE2:  MOVWF  FE9
4AE4:  MOVLW  00
4AE6:  ADDWFC x01,W
4AE8:  MOVWF  FEA
4AEA:  MOVFF  FEF,90D
4AEE:  MOVFF  03,FEA
4AF2:  MOVFF  01,FE9
4AF6:  MOVFF  90D,FEF
....................       state[14] = state[6]; 
4AFA:  MOVLW  0E
4AFC:  ADDWF  x00,W
4AFE:  MOVWF  01
4B00:  MOVLW  00
4B02:  ADDWFC x01,W
4B04:  MOVWF  03
4B06:  MOVLW  06
4B08:  ADDWF  x00,W
4B0A:  MOVWF  FE9
4B0C:  MOVLW  00
4B0E:  ADDWFC x01,W
4B10:  MOVWF  FEA
4B12:  MOVFF  FEF,90D
4B16:  MOVFF  03,FEA
4B1A:  MOVFF  01,FE9
4B1E:  MOVFF  90D,FEF
....................       state[2] = buf1; 
4B22:  MOVLW  02
4B24:  ADDWF  x00,W
4B26:  MOVWF  FE9
4B28:  MOVLW  00
4B2A:  ADDWFC x01,W
4B2C:  MOVWF  FEA
4B2E:  MOVFF  905,FEF
....................       state[6] = buf2; 
4B32:  MOVLW  06
4B34:  ADDWF  x00,W
4B36:  MOVWF  FE9
4B38:  MOVLW  00
4B3A:  ADDWFC x01,W
4B3C:  MOVWF  FEA
4B3E:  MOVFF  906,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
4B42:  MOVLW  03
4B44:  ADDWF  x00,W
4B46:  MOVWF  FE9
4B48:  MOVLW  00
4B4A:  ADDWFC x01,W
4B4C:  MOVWF  FEA
4B4E:  MOVFF  FEF,905
....................       state[3] = state[7]; 
4B52:  MOVLW  03
4B54:  ADDWF  x00,W
4B56:  MOVWF  01
4B58:  MOVLW  00
4B5A:  ADDWFC x01,W
4B5C:  MOVWF  03
4B5E:  MOVLW  07
4B60:  ADDWF  x00,W
4B62:  MOVWF  FE9
4B64:  MOVLW  00
4B66:  ADDWFC x01,W
4B68:  MOVWF  FEA
4B6A:  MOVFF  FEF,90D
4B6E:  MOVFF  03,FEA
4B72:  MOVFF  01,FE9
4B76:  MOVFF  90D,FEF
....................       state[7] = state[11]; 
4B7A:  MOVLW  07
4B7C:  ADDWF  x00,W
4B7E:  MOVWF  01
4B80:  MOVLW  00
4B82:  ADDWFC x01,W
4B84:  MOVWF  03
4B86:  MOVLW  0B
4B88:  ADDWF  x00,W
4B8A:  MOVWF  FE9
4B8C:  MOVLW  00
4B8E:  ADDWFC x01,W
4B90:  MOVWF  FEA
4B92:  MOVFF  FEF,90D
4B96:  MOVFF  03,FEA
4B9A:  MOVFF  01,FE9
4B9E:  MOVFF  90D,FEF
....................       state[11] = state[15]; 
4BA2:  MOVLW  0B
4BA4:  ADDWF  x00,W
4BA6:  MOVWF  01
4BA8:  MOVLW  00
4BAA:  ADDWFC x01,W
4BAC:  MOVWF  03
4BAE:  MOVLW  0F
4BB0:  ADDWF  x00,W
4BB2:  MOVWF  FE9
4BB4:  MOVLW  00
4BB6:  ADDWFC x01,W
4BB8:  MOVWF  FEA
4BBA:  MOVFF  FEF,90D
4BBE:  MOVFF  03,FEA
4BC2:  MOVFF  01,FE9
4BC6:  MOVFF  90D,FEF
....................       state[15] = buf1;          
4BCA:  MOVLW  0F
4BCC:  ADDWF  x00,W
4BCE:  MOVWF  FE9
4BD0:  MOVLW  00
4BD2:  ADDWFC x01,W
4BD4:  MOVWF  FEA
4BD6:  MOVFF  905,FEF
....................             
....................       for (i = 0; i <16; i++){ 
4BDA:  CLRF   x0A
4BDC:  MOVF   x0A,W
4BDE:  SUBLW  0F
4BE0:  BNC   4C32
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
4BE2:  CLRF   03
4BE4:  MOVF   x0A,W
4BE6:  ADDWF  x00,W
4BE8:  MOVWF  01
4BEA:  MOVF   x01,W
4BEC:  ADDWFC 03,F
4BEE:  MOVFF  01,90B
4BF2:  MOVFF  03,90C
4BF6:  CLRF   03
4BF8:  MOVF   x0A,W
4BFA:  ADDWF  x00,W
4BFC:  MOVWF  FE9
4BFE:  MOVF   x01,W
4C00:  ADDWFC 03,W
4C02:  MOVWF  FEA
4C04:  CLRF   03
4C06:  MOVF   FEF,W
4C08:  MOVLB  0
4C0A:  CALL   01E0
4C0E:  MOVLB  9
4C10:  MOVWF  x0D
4C12:  CLRF   03
4C14:  MOVF   x0A,W
4C16:  ADDWF  x02,W
4C18:  MOVWF  FE9
4C1A:  MOVF   x03,W
4C1C:  ADDWFC 03,W
4C1E:  MOVWF  FEA
4C20:  MOVF   FEF,W
4C22:  XORWF  x0D,W
4C24:  MOVFF  90C,FEA
4C28:  MOVFF  90B,FE9
4C2C:  MOVWF  FEF
....................       }  
4C2E:  INCF   x0A,F
4C30:  BRA    4BDC
....................     }  
....................     else  
4C32:  BRA    4DA6
....................     { 
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
4C34:  MOVFF  902,01
4C38:  MOVFF  903,03
4C3C:  MOVFF  902,90B
4C40:  MOVFF  903,90C
4C44:  MOVLW  0D
4C46:  ADDWF  x02,W
4C48:  MOVWF  FE9
4C4A:  MOVLW  00
4C4C:  ADDWFC x03,W
4C4E:  MOVWF  FEA
4C50:  CLRF   03
4C52:  MOVF   FEF,W
4C54:  MOVLB  0
4C56:  CALL   00D0
4C5A:  MOVLB  9
4C5C:  MOVWF  x0D
4C5E:  MOVFF  902,FE9
4C62:  MOVFF  903,FEA
4C66:  MOVF   FEF,W
4C68:  XORWF  x0D,F
4C6A:  CLRF   03
4C6C:  MOVF   x09,W
4C6E:  MOVLB  0
4C70:  CALL   02F0
4C74:  MOVWF  01
4C76:  MOVLB  9
4C78:  MOVF   x0D,W
4C7A:  XORWF  01,W
4C7C:  MOVFF  90C,FEA
4C80:  MOVFF  90B,FE9
4C84:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
4C86:  MOVLW  01
4C88:  ADDWF  x02,W
4C8A:  MOVWF  01
4C8C:  MOVLW  00
4C8E:  ADDWFC x03,W
4C90:  MOVWF  03
4C92:  MOVFF  01,90B
4C96:  MOVWF  x0C
4C98:  MOVLW  0E
4C9A:  ADDWF  x02,W
4C9C:  MOVWF  FE9
4C9E:  MOVLW  00
4CA0:  ADDWFC x03,W
4CA2:  MOVWF  FEA
4CA4:  CLRF   03
4CA6:  MOVF   FEF,W
4CA8:  MOVLB  0
4CAA:  CALL   00D0
4CAE:  MOVLB  9
4CB0:  MOVWF  x0D
4CB2:  MOVLW  01
4CB4:  ADDWF  x02,W
4CB6:  MOVWF  FE9
4CB8:  MOVLW  00
4CBA:  ADDWFC x03,W
4CBC:  MOVWF  FEA
4CBE:  MOVF   FEF,W
4CC0:  XORWF  x0D,W
4CC2:  MOVFF  90C,FEA
4CC6:  MOVFF  90B,FE9
4CCA:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
4CCC:  MOVLW  02
4CCE:  ADDWF  x02,W
4CD0:  MOVWF  01
4CD2:  MOVLW  00
4CD4:  ADDWFC x03,W
4CD6:  MOVWF  03
4CD8:  MOVFF  01,90B
4CDC:  MOVWF  x0C
4CDE:  MOVLW  0F
4CE0:  ADDWF  x02,W
4CE2:  MOVWF  FE9
4CE4:  MOVLW  00
4CE6:  ADDWFC x03,W
4CE8:  MOVWF  FEA
4CEA:  CLRF   03
4CEC:  MOVF   FEF,W
4CEE:  MOVLB  0
4CF0:  CALL   00D0
4CF4:  MOVLB  9
4CF6:  MOVWF  x0D
4CF8:  MOVLW  02
4CFA:  ADDWF  x02,W
4CFC:  MOVWF  FE9
4CFE:  MOVLW  00
4D00:  ADDWFC x03,W
4D02:  MOVWF  FEA
4D04:  MOVF   FEF,W
4D06:  XORWF  x0D,W
4D08:  MOVFF  90C,FEA
4D0C:  MOVFF  90B,FE9
4D10:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
4D12:  MOVLW  03
4D14:  ADDWF  x02,W
4D16:  MOVWF  01
4D18:  MOVLW  00
4D1A:  ADDWFC x03,W
4D1C:  MOVWF  03
4D1E:  MOVFF  01,90B
4D22:  MOVWF  x0C
4D24:  MOVLW  0C
4D26:  ADDWF  x02,W
4D28:  MOVWF  FE9
4D2A:  MOVLW  00
4D2C:  ADDWFC x03,W
4D2E:  MOVWF  FEA
4D30:  CLRF   03
4D32:  MOVF   FEF,W
4D34:  MOVLB  0
4D36:  CALL   00D0
4D3A:  MOVLB  9
4D3C:  MOVWF  x0D
4D3E:  MOVLW  03
4D40:  ADDWF  x02,W
4D42:  MOVWF  FE9
4D44:  MOVLW  00
4D46:  ADDWFC x03,W
4D48:  MOVWF  FEA
4D4A:  MOVF   FEF,W
4D4C:  XORWF  x0D,W
4D4E:  MOVFF  90C,FEA
4D52:  MOVFF  90B,FE9
4D56:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4D58:  MOVLW  04
4D5A:  MOVWF  x0A
4D5C:  MOVF   x0A,W
4D5E:  SUBLW  0F
4D60:  BNC   4DA6
....................         key[i] = key[i] ^ key[i-4]; 
4D62:  CLRF   03
4D64:  MOVF   x0A,W
4D66:  ADDWF  x02,W
4D68:  MOVWF  01
4D6A:  MOVF   x03,W
4D6C:  ADDWFC 03,F
4D6E:  MOVFF  03,90C
4D72:  CLRF   03
4D74:  MOVF   x0A,W
4D76:  ADDWF  x02,W
4D78:  MOVWF  FE9
4D7A:  MOVF   x03,W
4D7C:  ADDWFC 03,W
4D7E:  MOVWF  FEA
4D80:  MOVFF  FEF,90D
4D84:  MOVLW  04
4D86:  SUBWF  x0A,W
4D88:  CLRF   03
4D8A:  ADDWF  x02,W
4D8C:  MOVWF  FE9
4D8E:  MOVF   x03,W
4D90:  ADDWFC 03,W
4D92:  MOVWF  FEA
4D94:  MOVF   FEF,W
4D96:  XORWF  x0D,W
4D98:  MOVFF  90C,FEA
4D9C:  MOVFF  01,FE9
4DA0:  MOVWF  FEF
....................       } 
4DA2:  INCF   x0A,F
4DA4:  BRA    4D5C
....................     } 
....................   } 
4DA6:  INCF   x09,F
4DA8:  GOTO   435E
....................   if (dir == 0)  
4DAC:  MOVF   x04,F
4DAE:  BNZ   4DFA
....................   { 
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
4DB0:  CLRF   x0A
4DB2:  MOVF   x0A,W
4DB4:  SUBLW  0F
4DB6:  BNC   4DFA
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
4DB8:  CLRF   03
4DBA:  MOVF   x0A,W
4DBC:  ADDWF  x00,W
4DBE:  MOVWF  01
4DC0:  MOVF   x01,W
4DC2:  ADDWFC 03,F
4DC4:  MOVFF  03,90C
4DC8:  CLRF   03
4DCA:  MOVF   x0A,W
4DCC:  ADDWF  x00,W
4DCE:  MOVWF  FE9
4DD0:  MOVF   x01,W
4DD2:  ADDWFC 03,W
4DD4:  MOVWF  FEA
4DD6:  MOVFF  FEF,90D
4DDA:  CLRF   03
4DDC:  MOVF   x0A,W
4DDE:  ADDWF  x02,W
4DE0:  MOVWF  FE9
4DE2:  MOVF   x03,W
4DE4:  ADDWFC 03,W
4DE6:  MOVWF  FEA
4DE8:  MOVF   FEF,W
4DEA:  XORWF  x0D,W
4DEC:  MOVFF  90C,FEA
4DF0:  MOVFF  01,FE9
4DF4:  MOVWF  FEF
....................     } // enf for 
4DF6:  INCF   x0A,F
4DF8:  BRA    4DB2
....................   } // end if (!dir) 
.................... } // end function 
4DFA:  MOVLB  0
4DFC:  RETURN 0
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                  
....................  
.................... #define     wideofkeystore      16 
.................... #define     key_numbyte         wideofkeystore-4 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 kp_st=0; 
.................... int8 type_KB=0; 
....................  
.................... int8 key_data[wideofkeystore]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1F9C:  MOVLB  1
1F9E:  INCF   x5B,F
1FA0:  MOVF   x5B,W
1FA2:  SUBLW  01
1FA4:  BTFSC  FD8.0
1FA6:  BRA    214A
....................        switch (col) { 
1FA8:  MOVF   x5E,W
1FAA:  ADDLW  FB
1FAC:  BC    2030
1FAE:  ADDLW  05
1FB0:  MOVLB  0
1FB2:  GOTO   2154
....................          case 0   :  
....................                     output_low(COL0); 
1FB6:  BCF    F92.5
1FB8:  BCF    F89.5
....................                     output_high(COL1); 
1FBA:  BCF    F92.3
1FBC:  BSF    F89.3
....................                     output_high(COL2); 
1FBE:  BCF    F92.2
1FC0:  BSF    F89.2
....................                     output_high(COL3); 
1FC2:  BCF    F92.1
1FC4:  BSF    F89.1
....................                     output_high(COL4); 
1FC6:  BCF    F92.0
1FC8:  BSF    F89.0
....................                     break; 
1FCA:  MOVLB  1
1FCC:  BRA    2030
....................          case 1   :  
....................                     output_low(COL1); 
1FCE:  BCF    F92.3
1FD0:  BCF    F89.3
....................                     output_high(COL0); 
1FD2:  BCF    F92.5
1FD4:  BSF    F89.5
....................                     output_high(COL2); 
1FD6:  BCF    F92.2
1FD8:  BSF    F89.2
....................                     output_high(COL3); 
1FDA:  BCF    F92.1
1FDC:  BSF    F89.1
....................                     output_high(COL4); 
1FDE:  BCF    F92.0
1FE0:  BSF    F89.0
....................                     break; 
1FE2:  MOVLB  1
1FE4:  BRA    2030
....................          case 2   :  
....................                     output_low(COL2); 
1FE6:  BCF    F92.2
1FE8:  BCF    F89.2
....................                     output_high(COL1); 
1FEA:  BCF    F92.3
1FEC:  BSF    F89.3
....................                     output_high(COL0); 
1FEE:  BCF    F92.5
1FF0:  BSF    F89.5
....................                     output_high(COL3); 
1FF2:  BCF    F92.1
1FF4:  BSF    F89.1
....................                     output_high(COL4); 
1FF6:  BCF    F92.0
1FF8:  BSF    F89.0
....................                     break; 
1FFA:  MOVLB  1
1FFC:  BRA    2030
....................          case 3   :  
....................                     output_low(COL3); 
1FFE:  BCF    F92.1
2000:  BCF    F89.1
....................                     output_high(COL1); 
2002:  BCF    F92.3
2004:  BSF    F89.3
....................                     output_high(COL2); 
2006:  BCF    F92.2
2008:  BSF    F89.2
....................                     output_high(COL0); 
200A:  BCF    F92.5
200C:  BSF    F89.5
....................                     output_high(COL4); 
200E:  BCF    F92.0
2010:  BSF    F89.0
....................                     break; 
2012:  MOVLB  1
2014:  BRA    2030
....................          case 4   :  
....................                     output_low(COL4); 
2016:  BCF    F92.0
2018:  BCF    F89.0
....................                     output_high(COL1); 
201A:  BCF    F92.3
201C:  BSF    F89.3
....................                     output_high(COL2); 
201E:  BCF    F92.2
2020:  BSF    F89.2
....................                     output_high(COL3); 
2022:  BCF    F92.1
2024:  BSF    F89.1
....................                     output_high(COL0); 
2026:  BCF    F92.5
2028:  BSF    F89.5
....................                     break; 
202A:  MOVLB  1
202C:  BRA    2030
202E:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2030:  BTFSS  x5C.0
2032:  BRA    20B0
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2034:  BSF    F93.4
2036:  MOVLW  00
2038:  BTFSC  F81.4
203A:  MOVLW  01
203C:  MOVLB  8
203E:  MOVWF  x52
2040:  BSF    F93.5
2042:  MOVLW  00
2044:  BTFSC  F81.5
2046:  MOVLW  01
2048:  ANDWF  x52,F
204A:  BSF    F93.6
204C:  MOVLW  00
204E:  BTFSC  F81.6
2050:  MOVLW  01
2052:  ANDWF  x52,F
2054:  BSF    F93.7
2056:  MOVLW  00
2058:  BTFSC  F81.7
205A:  MOVLW  01
205C:  ANDWF  x52,W
205E:  BZ    20AC
....................          { 
....................             kchar=last_key; 
2060:  MOVFF  15D,850
....................             if(keydebug_en==0) 
2064:  MOVLB  1
2066:  MOVF   x44,F
2068:  BNZ   209A
....................             { 
....................                 //count_timer0=0; 
....................                 charac_timeout=0; 
206A:  CLRF   x00
206C:  MOVLB  0
206E:  CLRF   xFF
....................                 if(key_count_ms<wideofkeystore) 
2070:  MOVLB  1
2072:  MOVF   x47,W
2074:  SUBLW  0F
2076:  BNC   2098
....................                 { 
....................                     key_data[key_count_ms++]=kchar; 
2078:  MOVF   x47,W
207A:  INCF   x47,F
207C:  CLRF   03
207E:  ADDLW  4A
2080:  MOVWF  FE9
2082:  MOVLW  01
2084:  ADDWFC 03,W
2086:  MOVWF  FEA
2088:  MOVFF  850,FEF
....................                     fputc(kchar,COM2); 
208C:  MOVFF  850,90C
2090:  MOVLB  0
2092:  CALL   1620
2096:  MOVLB  1
....................                 } 
....................             } 
....................                else fputc(kchar,COM2); 
2098:  BRA    20A6
209A:  MOVFF  850,90C
209E:  MOVLB  0
20A0:  CALL   1620
20A4:  MOVLB  1
....................            kbd_down=FALSE; 
20A6:  BCF    x5C.0
....................            last_key=0; 
20A8:  CLRF   x5D
20AA:  MOVLB  8
....................          } 
....................        } else 
20AC:  BRA    2146
20AE:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
20B0:  BSF    F93.4
20B2:  MOVLW  00
20B4:  BTFSC  F81.4
20B6:  MOVLW  01
20B8:  MOVLB  8
20BA:  MOVWF  x52
20BC:  BSF    F93.5
20BE:  MOVLW  00
20C0:  BTFSC  F81.5
20C2:  MOVLW  01
20C4:  ANDWF  x52,F
20C6:  BSF    F93.6
20C8:  MOVLW  00
20CA:  BTFSC  F81.6
20CC:  MOVLW  01
20CE:  ANDWF  x52,F
20D0:  BSF    F93.7
20D2:  MOVLW  00
20D4:  BTFSC  F81.7
20D6:  MOVLW  01
20D8:  ANDWF  x52,W
20DA:  BNZ   213A
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
20DC:  BSF    F93.4
20DE:  BTFSC  F81.4
20E0:  BRA    20E6
....................                   row=0; 
20E2:  CLRF   x51
....................                 else if(input(ROW1)==0) 
20E4:  BRA    2108
20E6:  BSF    F93.5
20E8:  BTFSC  F81.5
20EA:  BRA    20F2
....................                   row=1; 
20EC:  MOVLW  01
20EE:  MOVWF  x51
....................                 else if(input(ROW2)==0) 
20F0:  BRA    2108
20F2:  BSF    F93.6
20F4:  BTFSC  F81.6
20F6:  BRA    20FE
....................                   row=2; 
20F8:  MOVLW  02
20FA:  MOVWF  x51
....................                 else if(input(ROW3)==0) 
20FC:  BRA    2108
20FE:  BSF    F93.7
2100:  BTFSC  F81.7
2102:  BRA    2108
....................                   row=3; 
2104:  MOVLW  03
2106:  MOVWF  x51
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
2108:  MOVF   x51,W
210A:  MULLW  05
210C:  MOVF   FF3,W
210E:  CLRF   x53
2110:  MOVWF  x52
2112:  CLRF   03
2114:  MOVLB  1
2116:  MOVF   x5E,W
2118:  MOVLB  8
211A:  ADDWF  x52,W
211C:  MOVWF  01
211E:  MOVF   x53,W
2120:  ADDWFC 03,F
2122:  MOVF   01,W
2124:  MOVLB  0
2126:  CALL   030A
212A:  MOVFF  FE8,15D
....................                 kbd_down = TRUE; 
212E:  MOVLB  1
2130:  BSF    x5C.0
....................                 set_tris_a(0xff); 
2132:  MOVLW  FF
2134:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2136:  BRA    2146
2138:  MOVLB  8
....................                { 
....................                   ++col; 
213A:  MOVLB  1
213C:  INCF   x5E,F
....................                   if(col==5) col=0; 
213E:  MOVF   x5E,W
2140:  SUBLW  05
2142:  BTFSC  FD8.2
2144:  CLRF   x5E
....................                } 
....................          } 
....................       kbd_call_count=0; 
2146:  MOVLB  1
2148:  CLRF   x5B
....................    } 
....................   return(kchar); 
214A:  MOVLB  8
214C:  MOVFF  850,01
.................... } 
2150:  MOVLB  0
2152:  RETURN 0
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2178:  MOVLW  E0
217A:  MOVLB  F
217C:  MOVWF  x48
217E:  BCF    FC2.6
2180:  BCF    FC2.7
2182:  MOVF   x49,W
2184:  ANDLW  E0
2186:  IORLW  17
2188:  MOVWF  x49
....................    switch(col) 
....................    { 
218A:  MOVLB  8
218C:  MOVF   x6D,W
218E:  ADDLW  FA
2190:  BC    225C
2192:  ADDLW  06
2194:  MOVLB  0
2196:  GOTO   2260
....................       case 0: 
....................         set_adc_channel(4); 
219A:  MOVLW  10
219C:  MOVWF  01
219E:  MOVF   FC2,W
21A0:  ANDLW  C3
21A2:  IORWF  01,W
21A4:  MOVWF  FC2
....................         adc=read_adc(); 
21A6:  BSF    FC2.1
21A8:  BTFSC  FC2.1
21AA:  BRA    21A8
21AC:  MOVFF  FC4,86E
....................         return adc; 
21B0:  MOVLB  8
21B2:  MOVFF  86E,01
21B6:  BRA    225C
....................       break; 
21B8:  BRA    225C
....................       case 1: 
....................         set_adc_channel(3); 
21BA:  MOVLW  0C
21BC:  MOVWF  01
21BE:  MOVF   FC2,W
21C0:  ANDLW  C3
21C2:  IORWF  01,W
21C4:  MOVWF  FC2
....................         adc=read_adc(); 
21C6:  BSF    FC2.1
21C8:  BTFSC  FC2.1
21CA:  BRA    21C8
21CC:  MOVFF  FC4,86E
....................         return adc; 
21D0:  MOVLB  8
21D2:  MOVFF  86E,01
21D6:  BRA    225C
....................       break; 
21D8:  BRA    225C
....................       case 2: 
....................         set_adc_channel(2); 
21DA:  MOVLW  08
21DC:  MOVWF  01
21DE:  MOVF   FC2,W
21E0:  ANDLW  C3
21E2:  IORWF  01,W
21E4:  MOVWF  FC2
....................         adc=read_adc(); 
21E6:  BSF    FC2.1
21E8:  BTFSC  FC2.1
21EA:  BRA    21E8
21EC:  MOVFF  FC4,86E
....................         return adc; 
21F0:  MOVLB  8
21F2:  MOVFF  86E,01
21F6:  BRA    225C
....................       break; 
21F8:  BRA    225C
....................       case 3: 
....................         set_adc_channel(1); 
21FA:  MOVLW  04
21FC:  MOVWF  01
21FE:  MOVF   FC2,W
2200:  ANDLW  C3
2202:  IORWF  01,W
2204:  MOVWF  FC2
....................         adc=read_adc(); 
2206:  BSF    FC2.1
2208:  BTFSC  FC2.1
220A:  BRA    2208
220C:  MOVFF  FC4,86E
....................         return adc; 
2210:  MOVLB  8
2212:  MOVFF  86E,01
2216:  BRA    225C
....................       break; 
2218:  BRA    225C
....................       case 4: 
....................         set_adc_channel(0); 
221A:  MOVLW  00
221C:  MOVWF  01
221E:  MOVF   FC2,W
2220:  ANDLW  C3
2222:  IORWF  01,W
2224:  MOVWF  FC2
....................         adc=read_adc(); 
2226:  BSF    FC2.1
2228:  BTFSC  FC2.1
222A:  BRA    2228
222C:  MOVFF  FC4,86E
....................         return adc; 
2230:  MOVLB  8
2232:  MOVFF  86E,01
2236:  BRA    225C
....................       break;      
2238:  BRA    225C
....................       case 5: 
....................         set_adc_channel(11); 
223A:  MOVLW  2C
223C:  MOVWF  01
223E:  MOVF   FC2,W
2240:  ANDLW  C3
2242:  IORWF  01,W
2244:  MOVWF  FC2
....................         adc=read_adc(); 
2246:  BSF    FC2.1
2248:  BTFSC  FC2.1
224A:  BRA    2248
224C:  MOVFF  FC4,86E
....................         return adc; 
2250:  MOVLB  8
2252:  MOVFF  86E,01
2256:  BRA    225C
....................       break;      
2258:  BRA    225C
225A:  MOVLB  8
....................    } 
.................... } 
225C:  MOVLB  0
225E:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
23D8:  MOVLB  8
23DA:  CLRF   x58
23DC:  CLRF   x57
23DE:  CLRF   x56
23E0:  CLRF   x55
23E2:  CLRF   x5C
23E4:  CLRF   x5B
23E6:  CLRF   x5A
23E8:  CLRF   x59
23EA:  CLRF   x60
23EC:  CLRF   x5F
23EE:  CLRF   x5E
23F0:  CLRF   x5D
23F2:  CLRF   x64
23F4:  CLRF   x63
23F6:  CLRF   x62
23F8:  CLRF   x61
23FA:  CLRF   x68
23FC:  CLRF   x67
23FE:  CLRF   x66
2400:  CLRF   x65
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2402:  CLRF   x54
2404:  CLRF   x53
2406:  MOVF   x54,W
2408:  SUBLW  01
240A:  BNC   2488
240C:  BNZ   2414
240E:  MOVF   x53,W
2410:  SUBLW  F3
2412:  BNC   2488
....................    { 
....................       col_0=read_col(0)+col_0; 
2414:  CLRF   x6D
2416:  MOVLB  0
2418:  RCALL  2178
241A:  MOVF   01,W
241C:  MOVLB  8
241E:  ADDWF  x55,F
2420:  MOVLW  00
2422:  ADDWFC x56,F
2424:  ADDWFC x57,F
2426:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2428:  MOVLW  01
242A:  MOVWF  x6D
242C:  MOVLB  0
242E:  RCALL  2178
2430:  MOVF   01,W
2432:  MOVLB  8
2434:  ADDWF  x59,F
2436:  MOVLW  00
2438:  ADDWFC x5A,F
243A:  ADDWFC x5B,F
243C:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
243E:  MOVLW  02
2440:  MOVWF  x6D
2442:  MOVLB  0
2444:  RCALL  2178
2446:  MOVF   01,W
2448:  MOVLB  8
244A:  ADDWF  x5D,F
244C:  MOVLW  00
244E:  ADDWFC x5E,F
2450:  ADDWFC x5F,F
2452:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
2454:  MOVLW  03
2456:  MOVWF  x6D
2458:  MOVLB  0
245A:  RCALL  2178
245C:  MOVF   01,W
245E:  MOVLB  8
2460:  ADDWF  x61,F
2462:  MOVLW  00
2464:  ADDWFC x62,F
2466:  ADDWFC x63,F
2468:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
246A:  MOVLW  04
246C:  MOVWF  x6D
246E:  MOVLB  0
2470:  RCALL  2178
2472:  MOVF   01,W
2474:  MOVLB  8
2476:  ADDWF  x65,F
2478:  MOVLW  00
247A:  ADDWFC x66,F
247C:  ADDWFC x67,F
247E:  ADDWFC x68,F
....................    } 
2480:  INCF   x53,F
2482:  BTFSC  FD8.2
2484:  INCF   x54,F
2486:  BRA    2406
....................    col_0=col_0/500; 
2488:  BCF    FD8.1
248A:  MOVFF  858,90F
248E:  MOVFF  857,90E
2492:  MOVFF  856,90D
2496:  MOVFF  855,90C
249A:  MOVLB  9
249C:  CLRF   x13
249E:  CLRF   x12
24A0:  MOVLW  01
24A2:  MOVWF  x11
24A4:  MOVLW  F4
24A6:  MOVWF  x10
24A8:  MOVLB  0
24AA:  RCALL  2286
24AC:  MOVFF  03,858
24B0:  MOVFF  02,857
24B4:  MOVFF  01,856
24B8:  MOVFF  00,855
....................    col_1=col_1/500; 
24BC:  BCF    FD8.1
24BE:  MOVFF  85C,90F
24C2:  MOVFF  85B,90E
24C6:  MOVFF  85A,90D
24CA:  MOVFF  859,90C
24CE:  MOVLB  9
24D0:  CLRF   x13
24D2:  CLRF   x12
24D4:  MOVLW  01
24D6:  MOVWF  x11
24D8:  MOVLW  F4
24DA:  MOVWF  x10
24DC:  MOVLB  0
24DE:  RCALL  2286
24E0:  MOVFF  03,85C
24E4:  MOVFF  02,85B
24E8:  MOVFF  01,85A
24EC:  MOVFF  00,859
....................    col_2=col_2/500; 
24F0:  BCF    FD8.1
24F2:  MOVFF  860,90F
24F6:  MOVFF  85F,90E
24FA:  MOVFF  85E,90D
24FE:  MOVFF  85D,90C
2502:  MOVLB  9
2504:  CLRF   x13
2506:  CLRF   x12
2508:  MOVLW  01
250A:  MOVWF  x11
250C:  MOVLW  F4
250E:  MOVWF  x10
2510:  MOVLB  0
2512:  RCALL  2286
2514:  MOVFF  03,860
2518:  MOVFF  02,85F
251C:  MOVFF  01,85E
2520:  MOVFF  00,85D
....................    col_3=col_3/500; 
2524:  BCF    FD8.1
2526:  MOVFF  864,90F
252A:  MOVFF  863,90E
252E:  MOVFF  862,90D
2532:  MOVFF  861,90C
2536:  MOVLB  9
2538:  CLRF   x13
253A:  CLRF   x12
253C:  MOVLW  01
253E:  MOVWF  x11
2540:  MOVLW  F4
2542:  MOVWF  x10
2544:  MOVLB  0
2546:  RCALL  2286
2548:  MOVFF  03,864
254C:  MOVFF  02,863
2550:  MOVFF  01,862
2554:  MOVFF  00,861
....................    col_4=col_4/500; 
2558:  BCF    FD8.1
255A:  MOVFF  868,90F
255E:  MOVFF  867,90E
2562:  MOVFF  866,90D
2566:  MOVFF  865,90C
256A:  MOVLB  9
256C:  CLRF   x13
256E:  CLRF   x12
2570:  MOVLW  01
2572:  MOVWF  x11
2574:  MOVLW  F4
2576:  MOVWF  x10
2578:  MOVLB  0
257A:  RCALL  2286
257C:  MOVFF  03,868
2580:  MOVFF  02,867
2584:  MOVFF  01,866
2588:  MOVFF  00,865
....................    if(keydebug_en) 
258C:  MOVLB  1
258E:  MOVF   x44,F
2590:  BTFSC  FD8.2
2592:  BRA    270E
....................    { 
....................       fprintf(COM2,"\r\n");      
2594:  MOVLW  0D
2596:  MOVLB  9
2598:  MOVWF  x0C
259A:  MOVLB  0
259C:  CALL   1620
25A0:  MOVLW  0A
25A2:  MOVLB  9
25A4:  MOVWF  x0C
25A6:  MOVLB  0
25A8:  CALL   1620
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
25AC:  MOVLW  BC
25AE:  MOVWF  FF6
25B0:  MOVLW  04
25B2:  MOVWF  FF7
25B4:  MOVLW  07
25B6:  MOVLB  9
25B8:  MOVWF  x00
25BA:  MOVLB  0
25BC:  CALL   1666
25C0:  MOVLW  41
25C2:  MOVWF  FE9
25C4:  MOVFF  858,903
25C8:  MOVFF  857,902
25CC:  MOVFF  856,901
25D0:  MOVFF  855,900
25D4:  RCALL  231A
25D6:  MOVLW  0D
25D8:  MOVLB  9
25DA:  MOVWF  x0C
25DC:  MOVLB  0
25DE:  CALL   1620
25E2:  MOVLW  0A
25E4:  MOVLB  9
25E6:  MOVWF  x0C
25E8:  MOVLB  0
25EA:  CALL   1620
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
25EE:  MOVLW  CA
25F0:  MOVWF  FF6
25F2:  MOVLW  04
25F4:  MOVWF  FF7
25F6:  MOVLW  07
25F8:  MOVLB  9
25FA:  MOVWF  x00
25FC:  MOVLB  0
25FE:  CALL   1666
2602:  MOVLW  41
2604:  MOVWF  FE9
2606:  MOVFF  85C,903
260A:  MOVFF  85B,902
260E:  MOVFF  85A,901
2612:  MOVFF  859,900
2616:  RCALL  231A
2618:  MOVLW  0D
261A:  MOVLB  9
261C:  MOVWF  x0C
261E:  MOVLB  0
2620:  CALL   1620
2624:  MOVLW  0A
2626:  MOVLB  9
2628:  MOVWF  x0C
262A:  MOVLB  0
262C:  CALL   1620
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2630:  MOVLW  D8
2632:  MOVWF  FF6
2634:  MOVLW  04
2636:  MOVWF  FF7
2638:  MOVLW  07
263A:  MOVLB  9
263C:  MOVWF  x00
263E:  MOVLB  0
2640:  CALL   1666
2644:  MOVLW  41
2646:  MOVWF  FE9
2648:  MOVFF  860,903
264C:  MOVFF  85F,902
2650:  MOVFF  85E,901
2654:  MOVFF  85D,900
2658:  RCALL  231A
265A:  MOVLW  0D
265C:  MOVLB  9
265E:  MOVWF  x0C
2660:  MOVLB  0
2662:  CALL   1620
2666:  MOVLW  0A
2668:  MOVLB  9
266A:  MOVWF  x0C
266C:  MOVLB  0
266E:  CALL   1620
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2672:  MOVLW  E6
2674:  MOVWF  FF6
2676:  MOVLW  04
2678:  MOVWF  FF7
267A:  MOVLW  07
267C:  MOVLB  9
267E:  MOVWF  x00
2680:  MOVLB  0
2682:  CALL   1666
2686:  MOVLW  41
2688:  MOVWF  FE9
268A:  MOVFF  864,903
268E:  MOVFF  863,902
2692:  MOVFF  862,901
2696:  MOVFF  861,900
269A:  RCALL  231A
269C:  MOVLW  0D
269E:  MOVLB  9
26A0:  MOVWF  x0C
26A2:  MOVLB  0
26A4:  CALL   1620
26A8:  MOVLW  0A
26AA:  MOVLB  9
26AC:  MOVWF  x0C
26AE:  MOVLB  0
26B0:  CALL   1620
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
26B4:  MOVLW  F4
26B6:  MOVWF  FF6
26B8:  MOVLW  04
26BA:  MOVWF  FF7
26BC:  MOVLW  07
26BE:  MOVLB  9
26C0:  MOVWF  x00
26C2:  MOVLB  0
26C4:  CALL   1666
26C8:  MOVLW  41
26CA:  MOVWF  FE9
26CC:  MOVFF  868,903
26D0:  MOVFF  867,902
26D4:  MOVFF  866,901
26D8:  MOVFF  865,900
26DC:  RCALL  231A
26DE:  MOVLW  0D
26E0:  MOVLB  9
26E2:  MOVWF  x0C
26E4:  MOVLB  0
26E6:  CALL   1620
26EA:  MOVLW  0A
26EC:  MOVLB  9
26EE:  MOVWF  x0C
26F0:  MOVLB  0
26F2:  CALL   1620
....................       fprintf(COM2,"\r\n"); 
26F6:  MOVLW  0D
26F8:  MOVLB  9
26FA:  MOVWF  x0C
26FC:  MOVLB  0
26FE:  CALL   1620
2702:  MOVLW  0A
2704:  MOVLB  9
2706:  MOVWF  x0C
2708:  MOVLB  0
270A:  CALL   1620
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
270E:  MOVLB  8
2710:  MOVF   x58,F
2712:  BNZ   2722
2714:  MOVF   x57,F
2716:  BNZ   2722
2718:  MOVF   x56,F
271A:  BNZ   2722
271C:  MOVF   x55,W
271E:  SUBLW  05
2720:  BC    2782
2722:  MOVF   x58,F
2724:  BNZ   2782
2726:  MOVF   x57,F
2728:  BNZ   2782
272A:  MOVF   x56,F
272C:  BNZ   2782
272E:  MOVF   x55,W
2730:  SUBLW  3B
2732:  BNC   2782
2734:  MOVF   x5C,F
2736:  BNZ   2746
2738:  MOVF   x5B,F
273A:  BNZ   2746
273C:  MOVF   x5A,F
273E:  BNZ   2746
2740:  MOVF   x59,W
2742:  SUBLW  64
2744:  BC    2782
2746:  MOVF   x60,F
2748:  BNZ   2758
274A:  MOVF   x5F,F
274C:  BNZ   2758
274E:  MOVF   x5E,F
2750:  BNZ   2758
2752:  MOVF   x5D,W
2754:  SUBLW  64
2756:  BC    2782
2758:  MOVF   x64,F
275A:  BNZ   276A
275C:  MOVF   x63,F
275E:  BNZ   276A
2760:  MOVF   x62,F
2762:  BNZ   276A
2764:  MOVF   x61,W
2766:  SUBLW  64
2768:  BC    2782
276A:  MOVF   x68,F
276C:  BNZ   277C
276E:  MOVF   x67,F
2770:  BNZ   277C
2772:  MOVF   x66,F
2774:  BNZ   277C
2776:  MOVF   x65,W
2778:  SUBLW  64
277A:  BC    2782
277C:  MOVLW  00
277E:  MOVWF  01
2780:  BRA    2A00
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
2782:  MOVF   x5C,F
2784:  BNZ   2794
2786:  MOVF   x5B,F
2788:  BNZ   2794
278A:  MOVF   x5A,F
278C:  BNZ   2794
278E:  MOVF   x59,W
2790:  SUBLW  05
2792:  BC    27F4
2794:  MOVF   x5C,F
2796:  BNZ   27F4
2798:  MOVF   x5B,F
279A:  BNZ   27F4
279C:  MOVF   x5A,F
279E:  BNZ   27F4
27A0:  MOVF   x59,W
27A2:  SUBLW  3B
27A4:  BNC   27F4
27A6:  MOVF   x58,F
27A8:  BNZ   27B8
27AA:  MOVF   x57,F
27AC:  BNZ   27B8
27AE:  MOVF   x56,F
27B0:  BNZ   27B8
27B2:  MOVF   x55,W
27B4:  SUBLW  64
27B6:  BC    27F4
27B8:  MOVF   x60,F
27BA:  BNZ   27CA
27BC:  MOVF   x5F,F
27BE:  BNZ   27CA
27C0:  MOVF   x5E,F
27C2:  BNZ   27CA
27C4:  MOVF   x5D,W
27C6:  SUBLW  64
27C8:  BC    27F4
27CA:  MOVF   x64,F
27CC:  BNZ   27DC
27CE:  MOVF   x63,F
27D0:  BNZ   27DC
27D2:  MOVF   x62,F
27D4:  BNZ   27DC
27D6:  MOVF   x61,W
27D8:  SUBLW  64
27DA:  BC    27F4
27DC:  MOVF   x68,F
27DE:  BNZ   27EE
27E0:  MOVF   x67,F
27E2:  BNZ   27EE
27E4:  MOVF   x66,F
27E6:  BNZ   27EE
27E8:  MOVF   x65,W
27EA:  SUBLW  64
27EC:  BC    27F4
27EE:  MOVLW  01
27F0:  MOVWF  01
27F2:  BRA    2A00
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
27F4:  MOVF   x60,F
27F6:  BNZ   2806
27F8:  MOVF   x5F,F
27FA:  BNZ   2806
27FC:  MOVF   x5E,F
27FE:  BNZ   2806
2800:  MOVF   x5D,W
2802:  SUBLW  05
2804:  BC    2866
2806:  MOVF   x60,F
2808:  BNZ   2866
280A:  MOVF   x5F,F
280C:  BNZ   2866
280E:  MOVF   x5E,F
2810:  BNZ   2866
2812:  MOVF   x5D,W
2814:  SUBLW  3B
2816:  BNC   2866
2818:  MOVF   x5C,F
281A:  BNZ   282A
281C:  MOVF   x5B,F
281E:  BNZ   282A
2820:  MOVF   x5A,F
2822:  BNZ   282A
2824:  MOVF   x59,W
2826:  SUBLW  64
2828:  BC    2866
282A:  MOVF   x58,F
282C:  BNZ   283C
282E:  MOVF   x57,F
2830:  BNZ   283C
2832:  MOVF   x56,F
2834:  BNZ   283C
2836:  MOVF   x55,W
2838:  SUBLW  64
283A:  BC    2866
283C:  MOVF   x64,F
283E:  BNZ   284E
2840:  MOVF   x63,F
2842:  BNZ   284E
2844:  MOVF   x62,F
2846:  BNZ   284E
2848:  MOVF   x61,W
284A:  SUBLW  64
284C:  BC    2866
284E:  MOVF   x68,F
2850:  BNZ   2860
2852:  MOVF   x67,F
2854:  BNZ   2860
2856:  MOVF   x66,F
2858:  BNZ   2860
285A:  MOVF   x65,W
285C:  SUBLW  64
285E:  BC    2866
2860:  MOVLW  02
2862:  MOVWF  01
2864:  BRA    2A00
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2866:  MOVF   x64,F
2868:  BNZ   2878
286A:  MOVF   x63,F
286C:  BNZ   2878
286E:  MOVF   x62,F
2870:  BNZ   2878
2872:  MOVF   x61,W
2874:  SUBLW  05
2876:  BC    28D8
2878:  MOVF   x64,F
287A:  BNZ   28D8
287C:  MOVF   x63,F
287E:  BNZ   28D8
2880:  MOVF   x62,F
2882:  BNZ   28D8
2884:  MOVF   x61,W
2886:  SUBLW  3B
2888:  BNC   28D8
288A:  MOVF   x5C,F
288C:  BNZ   289C
288E:  MOVF   x5B,F
2890:  BNZ   289C
2892:  MOVF   x5A,F
2894:  BNZ   289C
2896:  MOVF   x59,W
2898:  SUBLW  64
289A:  BC    28D8
289C:  MOVF   x60,F
289E:  BNZ   28AE
28A0:  MOVF   x5F,F
28A2:  BNZ   28AE
28A4:  MOVF   x5E,F
28A6:  BNZ   28AE
28A8:  MOVF   x5D,W
28AA:  SUBLW  64
28AC:  BC    28D8
28AE:  MOVF   x58,F
28B0:  BNZ   28C0
28B2:  MOVF   x57,F
28B4:  BNZ   28C0
28B6:  MOVF   x56,F
28B8:  BNZ   28C0
28BA:  MOVF   x55,W
28BC:  SUBLW  64
28BE:  BC    28D8
28C0:  MOVF   x68,F
28C2:  BNZ   28D2
28C4:  MOVF   x67,F
28C6:  BNZ   28D2
28C8:  MOVF   x66,F
28CA:  BNZ   28D2
28CC:  MOVF   x65,W
28CE:  SUBLW  64
28D0:  BC    28D8
28D2:  MOVLW  03
28D4:  MOVWF  01
28D6:  BRA    2A00
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
28D8:  MOVF   x68,F
28DA:  BNZ   28EA
28DC:  MOVF   x67,F
28DE:  BNZ   28EA
28E0:  MOVF   x66,F
28E2:  BNZ   28EA
28E4:  MOVF   x65,W
28E6:  SUBLW  05
28E8:  BC    294A
28EA:  MOVF   x68,F
28EC:  BNZ   294A
28EE:  MOVF   x67,F
28F0:  BNZ   294A
28F2:  MOVF   x66,F
28F4:  BNZ   294A
28F6:  MOVF   x65,W
28F8:  SUBLW  3B
28FA:  BNC   294A
28FC:  MOVF   x5C,F
28FE:  BNZ   290E
2900:  MOVF   x5B,F
2902:  BNZ   290E
2904:  MOVF   x5A,F
2906:  BNZ   290E
2908:  MOVF   x59,W
290A:  SUBLW  64
290C:  BC    294A
290E:  MOVF   x60,F
2910:  BNZ   2920
2912:  MOVF   x5F,F
2914:  BNZ   2920
2916:  MOVF   x5E,F
2918:  BNZ   2920
291A:  MOVF   x5D,W
291C:  SUBLW  64
291E:  BC    294A
2920:  MOVF   x64,F
2922:  BNZ   2932
2924:  MOVF   x63,F
2926:  BNZ   2932
2928:  MOVF   x62,F
292A:  BNZ   2932
292C:  MOVF   x61,W
292E:  SUBLW  64
2930:  BC    294A
2932:  MOVF   x58,F
2934:  BNZ   2944
2936:  MOVF   x57,F
2938:  BNZ   2944
293A:  MOVF   x56,F
293C:  BNZ   2944
293E:  MOVF   x55,W
2940:  SUBLW  64
2942:  BC    294A
2944:  MOVLW  04
2946:  MOVWF  01
2948:  BRA    2A00
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
294A:  MOVF   x68,F
294C:  BNZ   295E
294E:  MOVF   x67,F
2950:  BNZ   295E
2952:  MOVF   x66,F
2954:  BNZ   295E
2956:  MOVF   x65,W
2958:  SUBLW  C8
295A:  BTFSC  FD8.0
295C:  BRA    29FC
295E:  MOVF   x58,F
2960:  BTFSS  FD8.2
2962:  BRA    29FC
2964:  MOVF   x57,F
2966:  BTFSS  FD8.2
2968:  BRA    29FC
296A:  MOVF   x56,F
296C:  BTFSS  FD8.2
296E:  BRA    29FC
2970:  MOVF   x55,W
2972:  SUBLW  B3
2974:  BNC   29FC
2976:  MOVF   x58,F
2978:  BNZ   2988
297A:  MOVF   x57,F
297C:  BNZ   2988
297E:  MOVF   x56,F
2980:  BNZ   2988
2982:  MOVF   x55,W
2984:  SUBLW  64
2986:  BC    29FC
2988:  MOVF   x5C,F
298A:  BNZ   29FC
298C:  MOVF   x5B,F
298E:  BNZ   29FC
2990:  MOVF   x5A,F
2992:  BNZ   29FC
2994:  MOVF   x59,W
2996:  SUBLW  B3
2998:  BNC   29FC
299A:  MOVF   x5C,F
299C:  BNZ   29AC
299E:  MOVF   x5B,F
29A0:  BNZ   29AC
29A2:  MOVF   x5A,F
29A4:  BNZ   29AC
29A6:  MOVF   x59,W
29A8:  SUBLW  64
29AA:  BC    29FC
29AC:  MOVF   x60,F
29AE:  BNZ   29FC
29B0:  MOVF   x5F,F
29B2:  BNZ   29FC
29B4:  MOVF   x5E,F
29B6:  BNZ   29FC
29B8:  MOVF   x5D,W
29BA:  SUBLW  B3
29BC:  BNC   29FC
29BE:  MOVF   x60,F
29C0:  BNZ   29D0
29C2:  MOVF   x5F,F
29C4:  BNZ   29D0
29C6:  MOVF   x5E,F
29C8:  BNZ   29D0
29CA:  MOVF   x5D,W
29CC:  SUBLW  64
29CE:  BC    29FC
29D0:  MOVF   x64,F
29D2:  BNZ   29FC
29D4:  MOVF   x63,F
29D6:  BNZ   29FC
29D8:  MOVF   x62,F
29DA:  BNZ   29FC
29DC:  MOVF   x61,W
29DE:  SUBLW  B3
29E0:  BNC   29FC
29E2:  MOVF   x64,F
29E4:  BNZ   29F4
29E6:  MOVF   x63,F
29E8:  BNZ   29F4
29EA:  MOVF   x62,F
29EC:  BNZ   29F4
29EE:  MOVF   x61,W
29F0:  SUBLW  64
29F2:  BC    29FC
29F4:  MOVLW  04
29F6:  MOVWF  01
29F8:  BRA    2A00
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
29FA:  BRA    2A00
29FC:  MOVLW  FF
29FE:  MOVWF  01
.................... } 
2A00:  MOVLB  0
2A02:  GOTO   324E (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
2A06:  MOVLB  8
2A08:  CLRF   x58
2A0A:  CLRF   x57
2A0C:  CLRF   x56
2A0E:  CLRF   x55
2A10:  CLRF   x5C
2A12:  CLRF   x5B
2A14:  CLRF   x5A
2A16:  CLRF   x59
2A18:  CLRF   x60
2A1A:  CLRF   x5F
2A1C:  CLRF   x5E
2A1E:  CLRF   x5D
2A20:  CLRF   x64
2A22:  CLRF   x63
2A24:  CLRF   x62
2A26:  CLRF   x61
2A28:  CLRF   x68
2A2A:  CLRF   x67
2A2C:  CLRF   x66
2A2E:  CLRF   x65
2A30:  CLRF   x6C
2A32:  CLRF   x6B
2A34:  CLRF   x6A
2A36:  CLRF   x69
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2A38:  CLRF   x54
2A3A:  CLRF   x53
2A3C:  MOVF   x54,W
2A3E:  SUBLW  01
2A40:  BNC   2AE0
2A42:  BNZ   2A4A
2A44:  MOVF   x53,W
2A46:  SUBLW  F3
2A48:  BNC   2AE0
....................    { 
....................       col_0=read_col(0)+col_0; 
2A4A:  CLRF   x6D
2A4C:  MOVLB  0
2A4E:  CALL   2178
2A52:  MOVF   01,W
2A54:  MOVLB  8
2A56:  ADDWF  x55,F
2A58:  MOVLW  00
2A5A:  ADDWFC x56,F
2A5C:  ADDWFC x57,F
2A5E:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2A60:  MOVLW  01
2A62:  MOVWF  x6D
2A64:  MOVLB  0
2A66:  CALL   2178
2A6A:  MOVF   01,W
2A6C:  MOVLB  8
2A6E:  ADDWF  x59,F
2A70:  MOVLW  00
2A72:  ADDWFC x5A,F
2A74:  ADDWFC x5B,F
2A76:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
2A78:  MOVLW  02
2A7A:  MOVWF  x6D
2A7C:  MOVLB  0
2A7E:  CALL   2178
2A82:  MOVF   01,W
2A84:  MOVLB  8
2A86:  ADDWF  x5D,F
2A88:  MOVLW  00
2A8A:  ADDWFC x5E,F
2A8C:  ADDWFC x5F,F
2A8E:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
2A90:  MOVLW  03
2A92:  MOVWF  x6D
2A94:  MOVLB  0
2A96:  CALL   2178
2A9A:  MOVF   01,W
2A9C:  MOVLB  8
2A9E:  ADDWF  x61,F
2AA0:  MOVLW  00
2AA2:  ADDWFC x62,F
2AA4:  ADDWFC x63,F
2AA6:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
2AA8:  MOVLW  04
2AAA:  MOVWF  x6D
2AAC:  MOVLB  0
2AAE:  CALL   2178
2AB2:  MOVF   01,W
2AB4:  MOVLB  8
2AB6:  ADDWF  x65,F
2AB8:  MOVLW  00
2ABA:  ADDWFC x66,F
2ABC:  ADDWFC x67,F
2ABE:  ADDWFC x68,F
....................       col_5=read_col(5)+col_5; 
2AC0:  MOVLW  05
2AC2:  MOVWF  x6D
2AC4:  MOVLB  0
2AC6:  CALL   2178
2ACA:  MOVF   01,W
2ACC:  MOVLB  8
2ACE:  ADDWF  x69,F
2AD0:  MOVLW  00
2AD2:  ADDWFC x6A,F
2AD4:  ADDWFC x6B,F
2AD6:  ADDWFC x6C,F
....................    } 
2AD8:  INCF   x53,F
2ADA:  BTFSC  FD8.2
2ADC:  INCF   x54,F
2ADE:  BRA    2A3C
....................    col_0=col_0/500; 
2AE0:  BCF    FD8.1
2AE2:  MOVFF  858,90F
2AE6:  MOVFF  857,90E
2AEA:  MOVFF  856,90D
2AEE:  MOVFF  855,90C
2AF2:  MOVLB  9
2AF4:  CLRF   x13
2AF6:  CLRF   x12
2AF8:  MOVLW  01
2AFA:  MOVWF  x11
2AFC:  MOVLW  F4
2AFE:  MOVWF  x10
2B00:  MOVLB  0
2B02:  CALL   2286
2B06:  MOVFF  03,858
2B0A:  MOVFF  02,857
2B0E:  MOVFF  01,856
2B12:  MOVFF  00,855
....................    col_1=col_1/500; 
2B16:  BCF    FD8.1
2B18:  MOVFF  85C,90F
2B1C:  MOVFF  85B,90E
2B20:  MOVFF  85A,90D
2B24:  MOVFF  859,90C
2B28:  MOVLB  9
2B2A:  CLRF   x13
2B2C:  CLRF   x12
2B2E:  MOVLW  01
2B30:  MOVWF  x11
2B32:  MOVLW  F4
2B34:  MOVWF  x10
2B36:  MOVLB  0
2B38:  CALL   2286
2B3C:  MOVFF  03,85C
2B40:  MOVFF  02,85B
2B44:  MOVFF  01,85A
2B48:  MOVFF  00,859
....................    col_2=col_2/500; 
2B4C:  BCF    FD8.1
2B4E:  MOVFF  860,90F
2B52:  MOVFF  85F,90E
2B56:  MOVFF  85E,90D
2B5A:  MOVFF  85D,90C
2B5E:  MOVLB  9
2B60:  CLRF   x13
2B62:  CLRF   x12
2B64:  MOVLW  01
2B66:  MOVWF  x11
2B68:  MOVLW  F4
2B6A:  MOVWF  x10
2B6C:  MOVLB  0
2B6E:  CALL   2286
2B72:  MOVFF  03,860
2B76:  MOVFF  02,85F
2B7A:  MOVFF  01,85E
2B7E:  MOVFF  00,85D
....................    col_3=col_3/500; 
2B82:  BCF    FD8.1
2B84:  MOVFF  864,90F
2B88:  MOVFF  863,90E
2B8C:  MOVFF  862,90D
2B90:  MOVFF  861,90C
2B94:  MOVLB  9
2B96:  CLRF   x13
2B98:  CLRF   x12
2B9A:  MOVLW  01
2B9C:  MOVWF  x11
2B9E:  MOVLW  F4
2BA0:  MOVWF  x10
2BA2:  MOVLB  0
2BA4:  CALL   2286
2BA8:  MOVFF  03,864
2BAC:  MOVFF  02,863
2BB0:  MOVFF  01,862
2BB4:  MOVFF  00,861
....................    col_4=col_4/500; 
2BB8:  BCF    FD8.1
2BBA:  MOVFF  868,90F
2BBE:  MOVFF  867,90E
2BC2:  MOVFF  866,90D
2BC6:  MOVFF  865,90C
2BCA:  MOVLB  9
2BCC:  CLRF   x13
2BCE:  CLRF   x12
2BD0:  MOVLW  01
2BD2:  MOVWF  x11
2BD4:  MOVLW  F4
2BD6:  MOVWF  x10
2BD8:  MOVLB  0
2BDA:  CALL   2286
2BDE:  MOVFF  03,868
2BE2:  MOVFF  02,867
2BE6:  MOVFF  01,866
2BEA:  MOVFF  00,865
....................    col_5=col_5/500; 
2BEE:  BCF    FD8.1
2BF0:  MOVFF  86C,90F
2BF4:  MOVFF  86B,90E
2BF8:  MOVFF  86A,90D
2BFC:  MOVFF  869,90C
2C00:  MOVLB  9
2C02:  CLRF   x13
2C04:  CLRF   x12
2C06:  MOVLW  01
2C08:  MOVWF  x11
2C0A:  MOVLW  F4
2C0C:  MOVWF  x10
2C0E:  MOVLB  0
2C10:  CALL   2286
2C14:  MOVFF  03,86C
2C18:  MOVFF  02,86B
2C1C:  MOVFF  01,86A
2C20:  MOVFF  00,869
....................    if(keydebug_en) 
2C24:  MOVLB  1
2C26:  MOVF   x44,F
2C28:  BTFSC  FD8.2
2C2A:  BRA    2DF4
....................    { 
....................       fprintf(COM2,"\r\n");      
2C2C:  MOVLW  0D
2C2E:  MOVLB  9
2C30:  MOVWF  x0C
2C32:  MOVLB  0
2C34:  CALL   1620
2C38:  MOVLW  0A
2C3A:  MOVLB  9
2C3C:  MOVWF  x0C
2C3E:  MOVLB  0
2C40:  CALL   1620
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2C44:  MOVLW  02
2C46:  MOVWF  FF6
2C48:  MOVLW  05
2C4A:  MOVWF  FF7
2C4C:  MOVLW  07
2C4E:  MOVLB  9
2C50:  MOVWF  x00
2C52:  MOVLB  0
2C54:  CALL   1666
2C58:  MOVLW  41
2C5A:  MOVWF  FE9
2C5C:  MOVFF  858,903
2C60:  MOVFF  857,902
2C64:  MOVFF  856,901
2C68:  MOVFF  855,900
2C6C:  CALL   231A
2C70:  MOVLW  0D
2C72:  MOVLB  9
2C74:  MOVWF  x0C
2C76:  MOVLB  0
2C78:  CALL   1620
2C7C:  MOVLW  0A
2C7E:  MOVLB  9
2C80:  MOVWF  x0C
2C82:  MOVLB  0
2C84:  CALL   1620
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2C88:  MOVLW  10
2C8A:  MOVWF  FF6
2C8C:  MOVLW  05
2C8E:  MOVWF  FF7
2C90:  MOVLW  07
2C92:  MOVLB  9
2C94:  MOVWF  x00
2C96:  MOVLB  0
2C98:  CALL   1666
2C9C:  MOVLW  41
2C9E:  MOVWF  FE9
2CA0:  MOVFF  85C,903
2CA4:  MOVFF  85B,902
2CA8:  MOVFF  85A,901
2CAC:  MOVFF  859,900
2CB0:  CALL   231A
2CB4:  MOVLW  0D
2CB6:  MOVLB  9
2CB8:  MOVWF  x0C
2CBA:  MOVLB  0
2CBC:  CALL   1620
2CC0:  MOVLW  0A
2CC2:  MOVLB  9
2CC4:  MOVWF  x0C
2CC6:  MOVLB  0
2CC8:  CALL   1620
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2CCC:  MOVLW  1E
2CCE:  MOVWF  FF6
2CD0:  MOVLW  05
2CD2:  MOVWF  FF7
2CD4:  MOVLW  07
2CD6:  MOVLB  9
2CD8:  MOVWF  x00
2CDA:  MOVLB  0
2CDC:  CALL   1666
2CE0:  MOVLW  41
2CE2:  MOVWF  FE9
2CE4:  MOVFF  860,903
2CE8:  MOVFF  85F,902
2CEC:  MOVFF  85E,901
2CF0:  MOVFF  85D,900
2CF4:  CALL   231A
2CF8:  MOVLW  0D
2CFA:  MOVLB  9
2CFC:  MOVWF  x0C
2CFE:  MOVLB  0
2D00:  CALL   1620
2D04:  MOVLW  0A
2D06:  MOVLB  9
2D08:  MOVWF  x0C
2D0A:  MOVLB  0
2D0C:  CALL   1620
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2D10:  MOVLW  2C
2D12:  MOVWF  FF6
2D14:  MOVLW  05
2D16:  MOVWF  FF7
2D18:  MOVLW  07
2D1A:  MOVLB  9
2D1C:  MOVWF  x00
2D1E:  MOVLB  0
2D20:  CALL   1666
2D24:  MOVLW  41
2D26:  MOVWF  FE9
2D28:  MOVFF  864,903
2D2C:  MOVFF  863,902
2D30:  MOVFF  862,901
2D34:  MOVFF  861,900
2D38:  CALL   231A
2D3C:  MOVLW  0D
2D3E:  MOVLB  9
2D40:  MOVWF  x0C
2D42:  MOVLB  0
2D44:  CALL   1620
2D48:  MOVLW  0A
2D4A:  MOVLB  9
2D4C:  MOVWF  x0C
2D4E:  MOVLB  0
2D50:  CALL   1620
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2D54:  MOVLW  3A
2D56:  MOVWF  FF6
2D58:  MOVLW  05
2D5A:  MOVWF  FF7
2D5C:  MOVLW  07
2D5E:  MOVLB  9
2D60:  MOVWF  x00
2D62:  MOVLB  0
2D64:  CALL   1666
2D68:  MOVLW  41
2D6A:  MOVWF  FE9
2D6C:  MOVFF  868,903
2D70:  MOVFF  867,902
2D74:  MOVFF  866,901
2D78:  MOVFF  865,900
2D7C:  CALL   231A
2D80:  MOVLW  0D
2D82:  MOVLB  9
2D84:  MOVWF  x0C
2D86:  MOVLB  0
2D88:  CALL   1620
2D8C:  MOVLW  0A
2D8E:  MOVLB  9
2D90:  MOVWF  x0C
2D92:  MOVLB  0
2D94:  CALL   1620
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2D98:  MOVLW  48
2D9A:  MOVWF  FF6
2D9C:  MOVLW  05
2D9E:  MOVWF  FF7
2DA0:  MOVLW  07
2DA2:  MOVLB  9
2DA4:  MOVWF  x00
2DA6:  MOVLB  0
2DA8:  CALL   1666
2DAC:  MOVLW  41
2DAE:  MOVWF  FE9
2DB0:  MOVFF  86C,903
2DB4:  MOVFF  86B,902
2DB8:  MOVFF  86A,901
2DBC:  MOVFF  869,900
2DC0:  CALL   231A
2DC4:  MOVLW  0D
2DC6:  MOVLB  9
2DC8:  MOVWF  x0C
2DCA:  MOVLB  0
2DCC:  CALL   1620
2DD0:  MOVLW  0A
2DD2:  MOVLB  9
2DD4:  MOVWF  x0C
2DD6:  MOVLB  0
2DD8:  CALL   1620
....................       fprintf(COM2,"\r\n"); 
2DDC:  MOVLW  0D
2DDE:  MOVLB  9
2DE0:  MOVWF  x0C
2DE2:  MOVLB  0
2DE4:  CALL   1620
2DE8:  MOVLW  0A
2DEA:  MOVLB  9
2DEC:  MOVWF  x0C
2DEE:  MOVLB  0
2DF0:  CALL   1620
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2DF4:  MOVLB  8
2DF6:  MOVF   x58,F
2DF8:  BNZ   2E08
2DFA:  MOVF   x57,F
2DFC:  BNZ   2E08
2DFE:  MOVF   x56,F
2E00:  BNZ   2E08
2E02:  MOVF   x55,W
2E04:  SUBLW  05
2E06:  BC    2E7A
2E08:  MOVF   x58,F
2E0A:  BNZ   2E7A
2E0C:  MOVF   x57,F
2E0E:  BNZ   2E7A
2E10:  MOVF   x56,F
2E12:  BNZ   2E7A
2E14:  MOVF   x55,W
2E16:  SUBLW  3B
2E18:  BNC   2E7A
2E1A:  MOVF   x5C,F
2E1C:  BNZ   2E2C
2E1E:  MOVF   x5B,F
2E20:  BNZ   2E2C
2E22:  MOVF   x5A,F
2E24:  BNZ   2E2C
2E26:  MOVF   x59,W
2E28:  SUBLW  64
2E2A:  BC    2E7A
2E2C:  MOVF   x60,F
2E2E:  BNZ   2E3E
2E30:  MOVF   x5F,F
2E32:  BNZ   2E3E
2E34:  MOVF   x5E,F
2E36:  BNZ   2E3E
2E38:  MOVF   x5D,W
2E3A:  SUBLW  64
2E3C:  BC    2E7A
2E3E:  MOVF   x64,F
2E40:  BNZ   2E50
2E42:  MOVF   x63,F
2E44:  BNZ   2E50
2E46:  MOVF   x62,F
2E48:  BNZ   2E50
2E4A:  MOVF   x61,W
2E4C:  SUBLW  64
2E4E:  BC    2E7A
2E50:  MOVF   x68,F
2E52:  BNZ   2E62
2E54:  MOVF   x67,F
2E56:  BNZ   2E62
2E58:  MOVF   x66,F
2E5A:  BNZ   2E62
2E5C:  MOVF   x65,W
2E5E:  SUBLW  64
2E60:  BC    2E7A
2E62:  MOVF   x6C,F
2E64:  BNZ   2E74
2E66:  MOVF   x6B,F
2E68:  BNZ   2E74
2E6A:  MOVF   x6A,F
2E6C:  BNZ   2E74
2E6E:  MOVF   x69,W
2E70:  SUBLW  64
2E72:  BC    2E7A
2E74:  MOVLW  00
2E76:  MOVWF  01
2E78:  BRA    31F2
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2E7A:  MOVF   x5C,F
2E7C:  BNZ   2E8C
2E7E:  MOVF   x5B,F
2E80:  BNZ   2E8C
2E82:  MOVF   x5A,F
2E84:  BNZ   2E8C
2E86:  MOVF   x59,W
2E88:  SUBLW  05
2E8A:  BC    2EFE
2E8C:  MOVF   x5C,F
2E8E:  BNZ   2EFE
2E90:  MOVF   x5B,F
2E92:  BNZ   2EFE
2E94:  MOVF   x5A,F
2E96:  BNZ   2EFE
2E98:  MOVF   x59,W
2E9A:  SUBLW  3B
2E9C:  BNC   2EFE
2E9E:  MOVF   x58,F
2EA0:  BNZ   2EB0
2EA2:  MOVF   x57,F
2EA4:  BNZ   2EB0
2EA6:  MOVF   x56,F
2EA8:  BNZ   2EB0
2EAA:  MOVF   x55,W
2EAC:  SUBLW  64
2EAE:  BC    2EFE
2EB0:  MOVF   x60,F
2EB2:  BNZ   2EC2
2EB4:  MOVF   x5F,F
2EB6:  BNZ   2EC2
2EB8:  MOVF   x5E,F
2EBA:  BNZ   2EC2
2EBC:  MOVF   x5D,W
2EBE:  SUBLW  64
2EC0:  BC    2EFE
2EC2:  MOVF   x64,F
2EC4:  BNZ   2ED4
2EC6:  MOVF   x63,F
2EC8:  BNZ   2ED4
2ECA:  MOVF   x62,F
2ECC:  BNZ   2ED4
2ECE:  MOVF   x61,W
2ED0:  SUBLW  64
2ED2:  BC    2EFE
2ED4:  MOVF   x68,F
2ED6:  BNZ   2EE6
2ED8:  MOVF   x67,F
2EDA:  BNZ   2EE6
2EDC:  MOVF   x66,F
2EDE:  BNZ   2EE6
2EE0:  MOVF   x65,W
2EE2:  SUBLW  64
2EE4:  BC    2EFE
2EE6:  MOVF   x6C,F
2EE8:  BNZ   2EF8
2EEA:  MOVF   x6B,F
2EEC:  BNZ   2EF8
2EEE:  MOVF   x6A,F
2EF0:  BNZ   2EF8
2EF2:  MOVF   x69,W
2EF4:  SUBLW  64
2EF6:  BC    2EFE
2EF8:  MOVLW  01
2EFA:  MOVWF  01
2EFC:  BRA    31F2
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2EFE:  MOVF   x60,F
2F00:  BNZ   2F10
2F02:  MOVF   x5F,F
2F04:  BNZ   2F10
2F06:  MOVF   x5E,F
2F08:  BNZ   2F10
2F0A:  MOVF   x5D,W
2F0C:  SUBLW  05
2F0E:  BC    2F82
2F10:  MOVF   x60,F
2F12:  BNZ   2F82
2F14:  MOVF   x5F,F
2F16:  BNZ   2F82
2F18:  MOVF   x5E,F
2F1A:  BNZ   2F82
2F1C:  MOVF   x5D,W
2F1E:  SUBLW  3B
2F20:  BNC   2F82
2F22:  MOVF   x5C,F
2F24:  BNZ   2F34
2F26:  MOVF   x5B,F
2F28:  BNZ   2F34
2F2A:  MOVF   x5A,F
2F2C:  BNZ   2F34
2F2E:  MOVF   x59,W
2F30:  SUBLW  64
2F32:  BC    2F82
2F34:  MOVF   x58,F
2F36:  BNZ   2F46
2F38:  MOVF   x57,F
2F3A:  BNZ   2F46
2F3C:  MOVF   x56,F
2F3E:  BNZ   2F46
2F40:  MOVF   x55,W
2F42:  SUBLW  64
2F44:  BC    2F82
2F46:  MOVF   x64,F
2F48:  BNZ   2F58
2F4A:  MOVF   x63,F
2F4C:  BNZ   2F58
2F4E:  MOVF   x62,F
2F50:  BNZ   2F58
2F52:  MOVF   x61,W
2F54:  SUBLW  64
2F56:  BC    2F82
2F58:  MOVF   x68,F
2F5A:  BNZ   2F6A
2F5C:  MOVF   x67,F
2F5E:  BNZ   2F6A
2F60:  MOVF   x66,F
2F62:  BNZ   2F6A
2F64:  MOVF   x65,W
2F66:  SUBLW  64
2F68:  BC    2F82
2F6A:  MOVF   x6C,F
2F6C:  BNZ   2F7C
2F6E:  MOVF   x6B,F
2F70:  BNZ   2F7C
2F72:  MOVF   x6A,F
2F74:  BNZ   2F7C
2F76:  MOVF   x69,W
2F78:  SUBLW  64
2F7A:  BC    2F82
2F7C:  MOVLW  02
2F7E:  MOVWF  01
2F80:  BRA    31F2
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2F82:  MOVF   x64,F
2F84:  BNZ   2F94
2F86:  MOVF   x63,F
2F88:  BNZ   2F94
2F8A:  MOVF   x62,F
2F8C:  BNZ   2F94
2F8E:  MOVF   x61,W
2F90:  SUBLW  05
2F92:  BC    3006
2F94:  MOVF   x64,F
2F96:  BNZ   3006
2F98:  MOVF   x63,F
2F9A:  BNZ   3006
2F9C:  MOVF   x62,F
2F9E:  BNZ   3006
2FA0:  MOVF   x61,W
2FA2:  SUBLW  3B
2FA4:  BNC   3006
2FA6:  MOVF   x5C,F
2FA8:  BNZ   2FB8
2FAA:  MOVF   x5B,F
2FAC:  BNZ   2FB8
2FAE:  MOVF   x5A,F
2FB0:  BNZ   2FB8
2FB2:  MOVF   x59,W
2FB4:  SUBLW  64
2FB6:  BC    3006
2FB8:  MOVF   x60,F
2FBA:  BNZ   2FCA
2FBC:  MOVF   x5F,F
2FBE:  BNZ   2FCA
2FC0:  MOVF   x5E,F
2FC2:  BNZ   2FCA
2FC4:  MOVF   x5D,W
2FC6:  SUBLW  64
2FC8:  BC    3006
2FCA:  MOVF   x58,F
2FCC:  BNZ   2FDC
2FCE:  MOVF   x57,F
2FD0:  BNZ   2FDC
2FD2:  MOVF   x56,F
2FD4:  BNZ   2FDC
2FD6:  MOVF   x55,W
2FD8:  SUBLW  64
2FDA:  BC    3006
2FDC:  MOVF   x68,F
2FDE:  BNZ   2FEE
2FE0:  MOVF   x67,F
2FE2:  BNZ   2FEE
2FE4:  MOVF   x66,F
2FE6:  BNZ   2FEE
2FE8:  MOVF   x65,W
2FEA:  SUBLW  64
2FEC:  BC    3006
2FEE:  MOVF   x6C,F
2FF0:  BNZ   3000
2FF2:  MOVF   x6B,F
2FF4:  BNZ   3000
2FF6:  MOVF   x6A,F
2FF8:  BNZ   3000
2FFA:  MOVF   x69,W
2FFC:  SUBLW  64
2FFE:  BC    3006
3000:  MOVLW  03
3002:  MOVWF  01
3004:  BRA    31F2
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
3006:  MOVF   x68,F
3008:  BNZ   3018
300A:  MOVF   x67,F
300C:  BNZ   3018
300E:  MOVF   x66,F
3010:  BNZ   3018
3012:  MOVF   x65,W
3014:  SUBLW  05
3016:  BC    308A
3018:  MOVF   x68,F
301A:  BNZ   308A
301C:  MOVF   x67,F
301E:  BNZ   308A
3020:  MOVF   x66,F
3022:  BNZ   308A
3024:  MOVF   x65,W
3026:  SUBLW  3B
3028:  BNC   308A
302A:  MOVF   x5C,F
302C:  BNZ   303C
302E:  MOVF   x5B,F
3030:  BNZ   303C
3032:  MOVF   x5A,F
3034:  BNZ   303C
3036:  MOVF   x59,W
3038:  SUBLW  64
303A:  BC    308A
303C:  MOVF   x60,F
303E:  BNZ   304E
3040:  MOVF   x5F,F
3042:  BNZ   304E
3044:  MOVF   x5E,F
3046:  BNZ   304E
3048:  MOVF   x5D,W
304A:  SUBLW  64
304C:  BC    308A
304E:  MOVF   x64,F
3050:  BNZ   3060
3052:  MOVF   x63,F
3054:  BNZ   3060
3056:  MOVF   x62,F
3058:  BNZ   3060
305A:  MOVF   x61,W
305C:  SUBLW  64
305E:  BC    308A
3060:  MOVF   x58,F
3062:  BNZ   3072
3064:  MOVF   x57,F
3066:  BNZ   3072
3068:  MOVF   x56,F
306A:  BNZ   3072
306C:  MOVF   x55,W
306E:  SUBLW  64
3070:  BC    308A
3072:  MOVF   x6C,F
3074:  BNZ   3084
3076:  MOVF   x6B,F
3078:  BNZ   3084
307A:  MOVF   x6A,F
307C:  BNZ   3084
307E:  MOVF   x69,W
3080:  SUBLW  64
3082:  BC    308A
3084:  MOVLW  04
3086:  MOVWF  01
3088:  BRA    31F2
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
308A:  MOVF   x6C,F
308C:  BNZ   309C
308E:  MOVF   x6B,F
3090:  BNZ   309C
3092:  MOVF   x6A,F
3094:  BNZ   309C
3096:  MOVF   x69,W
3098:  SUBLW  05
309A:  BC    310E
309C:  MOVF   x6C,F
309E:  BNZ   310E
30A0:  MOVF   x6B,F
30A2:  BNZ   310E
30A4:  MOVF   x6A,F
30A6:  BNZ   310E
30A8:  MOVF   x69,W
30AA:  SUBLW  3B
30AC:  BNC   310E
30AE:  MOVF   x5C,F
30B0:  BNZ   30C0
30B2:  MOVF   x5B,F
30B4:  BNZ   30C0
30B6:  MOVF   x5A,F
30B8:  BNZ   30C0
30BA:  MOVF   x59,W
30BC:  SUBLW  64
30BE:  BC    310E
30C0:  MOVF   x60,F
30C2:  BNZ   30D2
30C4:  MOVF   x5F,F
30C6:  BNZ   30D2
30C8:  MOVF   x5E,F
30CA:  BNZ   30D2
30CC:  MOVF   x5D,W
30CE:  SUBLW  64
30D0:  BC    310E
30D2:  MOVF   x64,F
30D4:  BNZ   30E4
30D6:  MOVF   x63,F
30D8:  BNZ   30E4
30DA:  MOVF   x62,F
30DC:  BNZ   30E4
30DE:  MOVF   x61,W
30E0:  SUBLW  64
30E2:  BC    310E
30E4:  MOVF   x68,F
30E6:  BNZ   30F6
30E8:  MOVF   x67,F
30EA:  BNZ   30F6
30EC:  MOVF   x66,F
30EE:  BNZ   30F6
30F0:  MOVF   x65,W
30F2:  SUBLW  64
30F4:  BC    310E
30F6:  MOVF   x58,F
30F8:  BNZ   3108
30FA:  MOVF   x57,F
30FC:  BNZ   3108
30FE:  MOVF   x56,F
3100:  BNZ   3108
3102:  MOVF   x55,W
3104:  SUBLW  64
3106:  BC    310E
3108:  MOVLW  05
310A:  MOVWF  01
310C:  BRA    31F2
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
310E:  MOVF   x6C,F
3110:  BNZ   3122
3112:  MOVF   x6B,F
3114:  BNZ   3122
3116:  MOVF   x6A,F
3118:  BNZ   3122
311A:  MOVF   x69,W
311C:  SUBLW  C8
311E:  BTFSC  FD8.0
3120:  BRA    31EE
3122:  MOVF   x58,F
3124:  BTFSS  FD8.2
3126:  BRA    31EE
3128:  MOVF   x57,F
312A:  BTFSS  FD8.2
312C:  BRA    31EE
312E:  MOVF   x56,F
3130:  BTFSS  FD8.2
3132:  BRA    31EE
3134:  MOVF   x55,W
3136:  SUBLW  B3
3138:  BTFSS  FD8.0
313A:  BRA    31EE
313C:  MOVF   x58,F
313E:  BNZ   3150
3140:  MOVF   x57,F
3142:  BNZ   3150
3144:  MOVF   x56,F
3146:  BNZ   3150
3148:  MOVF   x55,W
314A:  SUBLW  64
314C:  BTFSC  FD8.0
314E:  BRA    31EE
3150:  MOVF   x5C,F
3152:  BTFSS  FD8.2
3154:  BRA    31EE
3156:  MOVF   x5B,F
3158:  BTFSS  FD8.2
315A:  BRA    31EE
315C:  MOVF   x5A,F
315E:  BTFSS  FD8.2
3160:  BRA    31EE
3162:  MOVF   x59,W
3164:  SUBLW  B3
3166:  BNC   31EE
3168:  MOVF   x5C,F
316A:  BNZ   317A
316C:  MOVF   x5B,F
316E:  BNZ   317A
3170:  MOVF   x5A,F
3172:  BNZ   317A
3174:  MOVF   x59,W
3176:  SUBLW  64
3178:  BC    31EE
317A:  MOVF   x60,F
317C:  BNZ   31EE
317E:  MOVF   x5F,F
3180:  BNZ   31EE
3182:  MOVF   x5E,F
3184:  BNZ   31EE
3186:  MOVF   x5D,W
3188:  SUBLW  B3
318A:  BNC   31EE
318C:  MOVF   x60,F
318E:  BNZ   319E
3190:  MOVF   x5F,F
3192:  BNZ   319E
3194:  MOVF   x5E,F
3196:  BNZ   319E
3198:  MOVF   x5D,W
319A:  SUBLW  64
319C:  BC    31EE
319E:  MOVF   x64,F
31A0:  BNZ   31EE
31A2:  MOVF   x63,F
31A4:  BNZ   31EE
31A6:  MOVF   x62,F
31A8:  BNZ   31EE
31AA:  MOVF   x61,W
31AC:  SUBLW  B3
31AE:  BNC   31EE
31B0:  MOVF   x64,F
31B2:  BNZ   31C2
31B4:  MOVF   x63,F
31B6:  BNZ   31C2
31B8:  MOVF   x62,F
31BA:  BNZ   31C2
31BC:  MOVF   x61,W
31BE:  SUBLW  64
31C0:  BC    31EE
31C2:  MOVF   x68,F
31C4:  BNZ   31EE
31C6:  MOVF   x67,F
31C8:  BNZ   31EE
31CA:  MOVF   x66,F
31CC:  BNZ   31EE
31CE:  MOVF   x65,W
31D0:  SUBLW  B3
31D2:  BNC   31EE
31D4:  MOVF   x68,F
31D6:  BNZ   31E6
31D8:  MOVF   x67,F
31DA:  BNZ   31E6
31DC:  MOVF   x66,F
31DE:  BNZ   31E6
31E0:  MOVF   x65,W
31E2:  SUBLW  64
31E4:  BC    31EE
31E6:  MOVLW  05
31E8:  MOVWF  01
31EA:  BRA    31F2
....................    else return 0xff; 
31EC:  BRA    31F2
31EE:  MOVLW  FF
31F0:  MOVWF  01
.................... } 
31F2:  MOVLB  0
31F4:  GOTO   325A (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
31F8:  MOVLW  20
31FA:  MOVLB  8
31FC:  MOVWF  x51
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
31FE:  BSF    F93.4
3200:  BTFSS  F81.4
3202:  BRA    3216
3204:  BSF    F93.5
3206:  BTFSS  F81.5
3208:  BRA    3216
320A:  BSF    F93.6
320C:  BTFSS  F81.6
320E:  BRA    3216
3210:  BSF    F93.7
3212:  BTFSC  F81.7
3214:  BRA    337C
....................     { 
....................        if(input(ROW0)==0) 
3216:  BSF    F93.4
3218:  BTFSC  F81.4
321A:  BRA    3220
....................          row=0; 
321C:  CLRF   x52
....................        else if(input(ROW1)==0) 
321E:  BRA    3242
3220:  BSF    F93.5
3222:  BTFSC  F81.5
3224:  BRA    322C
....................          row=1; 
3226:  MOVLW  01
3228:  MOVWF  x52
....................        else if(input(ROW2)==0) 
322A:  BRA    3242
322C:  BSF    F93.6
322E:  BTFSC  F81.6
3230:  BRA    3238
....................          row=2; 
3232:  MOVLW  02
3234:  MOVWF  x52
....................        else if(input(ROW3)==0) 
3236:  BRA    3242
3238:  BSF    F93.7
323A:  BTFSC  F81.7
323C:  BRA    3242
....................          row=3;      
323E:  MOVLW  03
3240:  MOVWF  x52
....................        if(type_KB==0)col=check_col(); 
3242:  MOVLB  1
3244:  MOVF   x49,F
3246:  BNZ   3254
3248:  MOVLB  0
324A:  GOTO   23D8
324E:  MOVFF  01,850
....................          else col=new_check_col(); 
3252:  BRA    325E
3254:  MOVLB  0
3256:  GOTO   2A06
325A:  MOVFF  01,850
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
325E:  MOVLB  8
3260:  INCFSZ x50,W
3262:  BRA    3266
3264:  BRA    334C
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
3266:  MOVLB  1
3268:  MOVF   x49,F
326A:  BNZ   3292
326C:  MOVLB  8
326E:  MOVF   x52,W
3270:  MULLW  05
3272:  MOVF   FF3,W
3274:  CLRF   x54
3276:  MOVWF  x53
3278:  CLRF   03
327A:  MOVF   x50,W
327C:  ADDWF  x53,W
327E:  MOVWF  01
3280:  MOVF   x54,W
3282:  ADDWFC 03,F
3284:  MOVF   01,W
3286:  MOVLB  0
3288:  CALL   030A
328C:  MOVFF  FE8,851
....................            else kchar =newKEYS[row][col]; 
3290:  BRA    32B6
3292:  MOVLB  8
3294:  MOVF   x52,W
3296:  MULLW  06
3298:  MOVF   FF3,W
329A:  CLRF   x54
329C:  MOVWF  x53
329E:  CLRF   03
32A0:  MOVF   x50,W
32A2:  ADDWF  x53,W
32A4:  MOVWF  01
32A6:  MOVF   x54,W
32A8:  ADDWFC 03,F
32AA:  MOVF   01,W
32AC:  MOVLB  0
32AE:  CALL   032E
32B2:  MOVFF  FE8,851
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
32B6:  MOVLB  1
32B8:  MOVF   x44,F
32BA:  BNZ   333E
....................             { 
....................               charac_timeout=0; 
32BC:  CLRF   x00
32BE:  MOVLB  0
32C0:  CLRF   xFF
....................                if(key_count_ms<wideofkeystore) 
32C2:  MOVLB  1
32C4:  MOVF   x47,W
32C6:  SUBLW  0F
32C8:  BNC   333C
....................                { 
....................                    key_data[key_count_ms++]=kchar; 
32CA:  MOVF   x47,W
32CC:  INCF   x47,F
32CE:  CLRF   03
32D0:  ADDLW  4A
32D2:  MOVWF  FE9
32D4:  MOVLW  01
32D6:  ADDWFC 03,W
32D8:  MOVWF  FEA
32DA:  MOVFF  851,FEF
....................                    fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
32DE:  MOVLW  56
32E0:  MOVWF  FF6
32E2:  MOVLW  05
32E4:  MOVWF  FF7
32E6:  MOVLW  09
32E8:  MOVLB  9
32EA:  MOVWF  x00
32EC:  MOVLB  0
32EE:  CALL   1666
32F2:  MOVFF  147,859
32F6:  MOVLW  18
32F8:  MOVLB  8
32FA:  MOVWF  x5A
32FC:  MOVLB  0
32FE:  CALL   1796
3302:  MOVLW  5D
3304:  MOVLB  9
3306:  MOVWF  x0C
3308:  MOVLB  0
330A:  CALL   1620
330E:  MOVLW  20
3310:  MOVLB  9
3312:  MOVWF  x0C
3314:  MOVLB  0
3316:  CALL   1620
331A:  MOVFF  851,90C
331E:  CALL   1620
3322:  MOVLW  0D
3324:  MOVLB  9
3326:  MOVWF  x0C
3328:  MOVLB  0
332A:  CALL   1620
332E:  MOVLW  0A
3330:  MOVLB  9
3332:  MOVWF  x0C
3334:  MOVLB  0
3336:  CALL   1620
333A:  MOVLB  1
....................                } 
....................             } 
....................                else fputc(kchar,COM2); 
333C:  BRA    334A
333E:  MOVFF  851,90C
3342:  MOVLB  0
3344:  CALL   1620
3348:  MOVLB  1
334A:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
334C:  BSF    F93.4
334E:  BTFSS  F81.4
3350:  BRA    334C
3352:  BSF    F93.5
3354:  BTFSS  F81.5
3356:  BRA    334C
3358:  BSF    F93.6
335A:  BTFSS  F81.6
335C:  BRA    334C
335E:  BSF    F93.7
3360:  BTFSS  F81.7
3362:  BRA    334C
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3364:  BSF    F93.4
3366:  BTFSS  F81.4
3368:  BRA    3364
336A:  BSF    F93.5
336C:  BTFSS  F81.5
336E:  BRA    3364
3370:  BSF    F93.6
3372:  BTFSS  F81.6
3374:  BRA    3364
3376:  BSF    F93.7
3378:  BTFSS  F81.7
337A:  BRA    3364
....................     } 
....................   set_tris_a(0xff);     
337C:  MOVLW  FF
337E:  MOVWF  F92
....................   return(kchar); 
3380:  MOVFF  851,01
.................... }//*/ 
3384:  MOVLB  0
3386:  RETURN 0
....................  
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int8 i,tempdata; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
5428:  MOVF   27,F
542A:  BTFSS  FD8.2
542C:  BRA    55E8
542E:  MOVF   26,W
5430:  SUBLW  01
5432:  BTFSS  FD8.0
5434:  BRA    55E8
5436:  BNZ   544A
5438:  MOVF   25,W
543A:  SUBLW  FF
543C:  BTFSS  FD8.0
543E:  BRA    55E8
5440:  BNZ   544A
5442:  MOVF   24,W
5444:  SUBLW  FE
5446:  BTFSS  FD8.0
5448:  BRA    55E8
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
544A:  MOVLB  1
544C:  MOVF   x4A,F
544E:  BNZ   5456
5450:  MOVF   x47,F
5452:  BTFSC  FD8.2
5454:  BRA    5594
....................       { 
....................          temp=get_countcard(); 
5456:  MOVLB  0
5458:  CALL   3534
545C:  MOVFF  02,853
5460:  MOVFF  01,852
....................          //fprintf(COM2," get_countcard=%lu\n\r",temp); 
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
5464:  MOVLB  8
5466:  RLCF   x52,W
5468:  MOVWF  x54
546A:  RLCF   x53,W
546C:  MOVWF  x55
546E:  RLCF   x54,F
5470:  RLCF   x55,F
5472:  RLCF   x54,F
5474:  RLCF   x55,F
5476:  RLCF   x54,F
5478:  RLCF   x55,F
547A:  MOVLW  F0
547C:  ANDWF  x54,F
547E:  MOVLW  0E
5480:  ADDWF  x54,F
5482:  MOVLW  C3
5484:  ADDWFC x55,F
5486:  MOVLW  01
5488:  MOVWF  x56
548A:  BCF    FD8.2
548C:  BTFSC  FD8.0
548E:  INCF   x56,F
5490:  CLRF   x57
5492:  MOVLW  01
5494:  ADDWF  x54,W
5496:  MOVWF  00
5498:  MOVLW  00
549A:  ADDWFC x55,W
549C:  MOVWF  01
549E:  MOVLW  00
54A0:  ADDWFC x56,W
54A2:  MOVWF  02
54A4:  MOVLW  00
54A6:  ADDWFC x57,W
54A8:  MOVWF  27
54AA:  MOVFF  02,26
54AE:  MOVFF  01,25
54B2:  MOVFF  00,24
....................          //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<wideofkeystore;i++) 
54B6:  CLRF   x50
54B8:  MOVF   x50,W
54BA:  SUBLW  0F
54BC:  BNC   5504
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
54BE:  MOVF   x50,W
54C0:  ADDWF  24,W
54C2:  MOVWF  00
54C4:  MOVLW  00
54C6:  ADDWFC 25,W
54C8:  MOVWF  01
54CA:  MOVLW  00
54CC:  ADDWFC 26,W
54CE:  MOVWF  02
54D0:  MOVLW  00
54D2:  ADDWFC 27,W
54D4:  MOVWF  03
54D6:  MOVWF  x57
54D8:  MOVFF  02,856
54DC:  MOVFF  01,855
54E0:  MOVFF  00,854
54E4:  MOVFF  FE8,916
54E8:  MOVFF  02,915
54EC:  MOVFF  01,914
54F0:  MOVFF  00,913
54F4:  MOVLB  9
54F6:  CLRF   x17
54F8:  MOVLB  0
54FA:  CALL   3A80
....................          } 
54FE:  MOVLB  8
5500:  INCF   x50,F
5502:  BRA    54B8
....................          for(i=0;i<wideofkeystore;i++) 
5504:  CLRF   x50
5506:  MOVF   x50,W
5508:  SUBLW  0F
550A:  BNC   5576
....................          { 
....................             tempdata=key_data[i]; 
550C:  CLRF   03
550E:  MOVF   x50,W
5510:  ADDLW  4A
5512:  MOVWF  FE9
5514:  MOVLW  01
5516:  ADDWFC 03,W
5518:  MOVWF  FEA
551A:  MOVFF  FEF,851
....................             write_ext_eeprom((int32)ptr_card_key++,tempdata); 
551E:  MOVFF  27,03
5522:  MOVFF  26,02
5526:  MOVFF  25,01
552A:  MOVFF  24,00
552E:  MOVLW  01
5530:  ADDWF  24,F
5532:  BTFSC  FD8.0
5534:  INCF   25,F
5536:  BTFSC  FD8.2
5538:  INCF   26,F
553A:  BTFSC  FD8.2
553C:  INCF   27,F
553E:  MOVFF  03,857
5542:  MOVFF  02,856
5546:  MOVFF  01,855
554A:  MOVFF  00,854
554E:  MOVFF  03,916
5552:  MOVFF  02,915
5556:  MOVFF  01,914
555A:  MOVFF  00,913
555E:  MOVFF  851,917
5562:  MOVLB  0
5564:  CALL   3A80
....................             //delay_us(100); 
....................             fprintf(COM2,"%c",tempdata); 
5568:  MOVFF  851,90C
556C:  CALL   1620
....................          } 
5570:  MOVLB  8
5572:  INCF   x50,F
5574:  BRA    5506
....................           //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................           /*fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<wideofkeystore;i++) 
....................           { 
....................             fprintf(COM2,"%c",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5576:  MOVFF  27,903
557A:  MOVFF  26,902
557E:  MOVFF  25,901
5582:  MOVFF  24,900
5586:  MOVLW  1E
5588:  MOVLB  9
558A:  MOVWF  x04
558C:  MOVLB  0
558E:  CALL   3B7E
5592:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
5594:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
5596:  MOVLW  01
5598:  MOVWF  FEA
559A:  MOVLW  4A
559C:  MOVWF  FE9
559E:  CLRF   00
55A0:  CLRF   02
55A2:  MOVLW  10
55A4:  MOVWF  01
55A6:  MOVLB  0
55A8:  CALL   35AE
....................       fprintf(COM2,"\r\n"); 
55AC:  MOVLW  0D
55AE:  MOVLB  9
55B0:  MOVWF  x0C
55B2:  MOVLB  0
55B4:  CALL   1620
55B8:  MOVLW  0A
55BA:  MOVLB  9
55BC:  MOVWF  x0C
55BE:  MOVLB  0
55C0:  CALL   1620
....................       fprintf(COM2,"Done save_key_new"); 
55C4:  MOVLW  68
55C6:  MOVWF  FF6
55C8:  MOVLW  05
55CA:  MOVWF  FF7
55CC:  CALL   174A
....................       fprintf(COM2,"\r\n"); 
55D0:  MOVLW  0D
55D2:  MOVLB  9
55D4:  MOVWF  x0C
55D6:  MOVLB  0
55D8:  CALL   1620
55DC:  MOVLW  0A
55DE:  MOVLB  9
55E0:  MOVWF  x0C
55E2:  MOVLB  0
55E4:  CALL   1620
....................    } 
.................... } 
55E8:  GOTO   5B20 (RETURN)
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 recEn[wideofkeystore]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
55EC:  MOVF   27,F
55EE:  BTFSS  FD8.2
55F0:  BRA    5854
55F2:  MOVF   26,W
55F4:  SUBLW  01
55F6:  BTFSS  FD8.0
55F8:  BRA    5854
55FA:  BNZ   560E
55FC:  MOVF   25,W
55FE:  SUBLW  FF
5600:  BTFSS  FD8.0
5602:  BRA    5854
5604:  BNZ   560E
5606:  MOVF   24,W
5608:  SUBLW  FE
560A:  BTFSS  FD8.0
560C:  BRA    5854
....................    {   
....................      for(i=0;i<key_numbyte;i++) 
560E:  MOVLB  8
5610:  CLRF   x50
5612:  MOVF   x50,W
5614:  SUBLW  0B
5616:  BNC   566A
....................      { 
....................         temp=key_data[i]; 
5618:  CLRF   03
561A:  MOVF   x50,W
561C:  ADDLW  4A
561E:  MOVWF  FE9
5620:  MOVLW  01
5622:  ADDWFC 03,W
5624:  MOVWF  FEA
5626:  CLRF   x52
5628:  MOVFF  FEF,851
....................         fputc(temp,COM2); 
562C:  MOVFF  851,90C
5630:  MOVLB  0
5632:  CALL   1620
....................         recEn[i]=key_data[i]; 
5636:  CLRF   03
5638:  MOVLB  8
563A:  MOVF   x50,W
563C:  ADDLW  54
563E:  MOVWF  01
5640:  MOVLW  08
5642:  ADDWFC 03,F
5644:  MOVFF  03,865
5648:  CLRF   03
564A:  MOVF   x50,W
564C:  ADDLW  4A
564E:  MOVWF  FE9
5650:  MOVLW  01
5652:  ADDWFC 03,W
5654:  MOVWF  FEA
5656:  MOVFF  FEF,866
565A:  MOVFF  865,FEA
565E:  MOVFF  01,FE9
5662:  MOVFF  866,FEF
....................      } 
5666:  INCF   x50,F
5668:  BRA    5612
....................      recEn[key_numbyte] = 0; 
566A:  CLRF   x60
....................      recEn[key_numbyte+1] = 0;          
566C:  CLRF   x61
....................      recEn[key_numbyte+2] = 0;          
566E:  CLRF   x62
....................      recEn[key_numbyte+3] = 0; 
5670:  CLRF   x63
.................... #if 0 
....................      fprintf(COM2,"\n\r"); 
....................      fprintf(COM2,"test_key:\n\r"); 
....................      for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................      fprintf(COM2,"\n\r"); 
....................      fprintf(COM2,"\n\rdatain:\n\r"); 
....................      for(i=0;i<16;i++) fprintf(COM2," %x",recEn[i]); 
....................      fprintf(COM2,"\n\r"); 
.................... #endif 
....................      EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
5672:  MOVLB  9
5674:  CLRF   x07
5676:  CLRF   x06
5678:  CLRF   x05
567A:  MOVLW  3F
567C:  MOVWF  x04
567E:  CLRF   x0B
5680:  CLRF   x0A
5682:  CLRF   x09
5684:  MOVLW  20
5686:  MOVWF  x08
5688:  MOVLW  01
568A:  MOVWF  x0D
568C:  MOVWF  x0C
568E:  MOVLB  0
5690:  CALL   4094
....................      aes_enc_dec((unsigned int8 *)&recEn[0], (unsigned int8 *)&crypto_key[0],0); 
5694:  MOVLW  08
5696:  MOVLB  9
5698:  MOVWF  x01
569A:  MOVLW  54
569C:  MOVWF  x00
569E:  MOVLW  01
56A0:  MOVWF  x03
56A2:  MOVWF  x02
56A4:  CLRF   x04
56A6:  MOVLB  0
56A8:  CALL   418A
....................      //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................       
....................      /* get the pointer of keyboard data */ 
....................      temp=get_countcard(); 
56AC:  CALL   3534
56B0:  MOVFF  02,852
56B4:  MOVFF  01,851
....................      ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
56B8:  MOVLB  8
56BA:  RLCF   x51,W
56BC:  MOVWF  x64
56BE:  RLCF   x52,W
56C0:  MOVWF  x65
56C2:  RLCF   x64,F
56C4:  RLCF   x65,F
56C6:  RLCF   x64,F
56C8:  RLCF   x65,F
56CA:  RLCF   x64,F
56CC:  RLCF   x65,F
56CE:  MOVLW  F0
56D0:  ANDWF  x64,F
56D2:  MOVLW  0E
56D4:  ADDWF  x64,F
56D6:  MOVLW  C3
56D8:  ADDWFC x65,F
56DA:  MOVLW  01
56DC:  MOVWF  x66
56DE:  BCF    FD8.2
56E0:  BTFSC  FD8.0
56E2:  INCF   x66,F
56E4:  CLRF   x67
56E6:  MOVLW  01
56E8:  ADDWF  x64,W
56EA:  MOVWF  00
56EC:  MOVLW  00
56EE:  ADDWFC x65,W
56F0:  MOVWF  01
56F2:  MOVLW  00
56F4:  ADDWFC x66,W
56F6:  MOVWF  02
56F8:  MOVLW  00
56FA:  ADDWFC x67,W
56FC:  MOVWF  27
56FE:  MOVFF  02,26
5702:  MOVFF  01,25
5706:  MOVFF  00,24
....................      /* delete the old data of key store area  */ 
....................      //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................      for(i=0;i<wideofkeystore;i++) 
570A:  CLRF   x50
570C:  MOVF   x50,W
570E:  SUBLW  0F
5710:  BNC   5758
....................      { 
....................         write_ext_eeprom((int32)(ptr_card_key+i),0); 
5712:  MOVF   x50,W
5714:  ADDWF  24,W
5716:  MOVWF  00
5718:  MOVLW  00
571A:  ADDWFC 25,W
571C:  MOVWF  01
571E:  MOVLW  00
5720:  ADDWFC 26,W
5722:  MOVWF  02
5724:  MOVLW  00
5726:  ADDWFC 27,W
5728:  MOVWF  03
572A:  MOVWF  x67
572C:  MOVFF  02,866
5730:  MOVFF  01,865
5734:  MOVFF  00,864
5738:  MOVFF  FE8,916
573C:  MOVFF  02,915
5740:  MOVFF  01,914
5744:  MOVFF  00,913
5748:  MOVLB  9
574A:  CLRF   x17
574C:  MOVLB  0
574E:  CALL   3A80
....................      } 
5752:  MOVLB  8
5754:  INCF   x50,F
5756:  BRA    570C
....................      fprintf(COM2,"\n\r"); 
5758:  MOVLW  0A
575A:  MOVLB  9
575C:  MOVWF  x0C
575E:  MOVLB  0
5760:  CALL   1620
5764:  MOVLW  0D
5766:  MOVLB  9
5768:  MOVWF  x0C
576A:  MOVLB  0
576C:  CALL   1620
....................      for(i=0;i<wideofkeystore;i++) fprintf(COM2,"%x",recEn[i]); 
5770:  MOVLB  8
5772:  CLRF   x50
5774:  MOVF   x50,W
5776:  SUBLW  0F
5778:  BNC   57A2
577A:  CLRF   03
577C:  MOVF   x50,W
577E:  ADDLW  54
5780:  MOVWF  FE9
5782:  MOVLW  08
5784:  ADDWFC 03,W
5786:  MOVWF  FEA
5788:  MOVFF  FEF,864
578C:  MOVFF  864,901
5790:  MOVLW  57
5792:  MOVLB  9
5794:  MOVWF  x02
5796:  MOVLB  0
5798:  CALL   4E8E
579C:  MOVLB  8
579E:  INCF   x50,F
57A0:  BRA    5774
....................      retval = EEPROM_write(ptr_card_key,wideofkeystore,recEn);  
57A2:  MOVFF  27,903
57A6:  MOVFF  26,902
57AA:  MOVFF  25,901
57AE:  MOVFF  24,900
57B2:  MOVLB  9
57B4:  CLRF   x07
57B6:  CLRF   x06
57B8:  CLRF   x05
57BA:  MOVLW  10
57BC:  MOVWF  x04
57BE:  MOVLW  08
57C0:  MOVWF  x09
57C2:  MOVLW  54
57C4:  MOVWF  x08
57C6:  MOVLB  0
57C8:  CALL   4DFE
57CC:  MOVFF  01,853
....................      if(retval!=0) 
57D0:  MOVLB  8
57D2:  MOVF   x53,F
57D4:  BZ    57FE
....................      { 
....................         ptr_card_key+=wideofkeystore; 
57D6:  MOVLW  10
57D8:  ADDWF  24,F
57DA:  MOVLW  00
57DC:  ADDWFC 25,F
57DE:  ADDWFC 26,F
57E0:  ADDWFC 27,F
....................         save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
57E2:  MOVFF  27,903
57E6:  MOVFF  26,902
57EA:  MOVFF  25,901
57EE:  MOVFF  24,900
57F2:  MOVLW  1E
57F4:  MOVLB  9
57F6:  MOVWF  x04
57F8:  MOVLB  0
57FA:  CALL   3B7E
....................      }          
....................       key_count_ms=0; 
57FE:  MOVLB  1
5800:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
5802:  MOVLW  01
5804:  MOVWF  FEA
5806:  MOVLW  4A
5808:  MOVWF  FE9
580A:  CLRF   00
580C:  CLRF   02
580E:  MOVLW  10
5810:  MOVWF  01
5812:  MOVLB  0
5814:  CALL   35AE
....................       fprintf(COM2,"\r\n"); 
5818:  MOVLW  0D
581A:  MOVLB  9
581C:  MOVWF  x0C
581E:  MOVLB  0
5820:  CALL   1620
5824:  MOVLW  0A
5826:  MOVLB  9
5828:  MOVWF  x0C
582A:  MOVLB  0
582C:  CALL   1620
....................       fprintf(COM2,"Done Encrypted PIN"); 
5830:  MOVLW  7A
5832:  MOVWF  FF6
5834:  MOVLW  05
5836:  MOVWF  FF7
5838:  CALL   174A
....................       fprintf(COM2,"\r\n"); 
583C:  MOVLW  0D
583E:  MOVLB  9
5840:  MOVWF  x0C
5842:  MOVLB  0
5844:  CALL   1620
5848:  MOVLW  0A
584A:  MOVLB  9
584C:  MOVWF  x0C
584E:  MOVLB  0
5850:  CALL   1620
....................    } 
.................... } 
5854:  GOTO   5B28 (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
5F36:  MOVLB  7
5F38:  CLRF   xFA
5F3A:  CLRF   xF9
5F3C:  CLRF   xFB
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
5F3E:  MOVF   xFA,F
5F40:  BTFSS  FD8.2
5F42:  BRA    6066
5F44:  MOVF   xF4,W
5F46:  SUBWF  xF9,W
5F48:  BTFSC  FD8.0
5F4A:  BRA    6066
5F4C:  MOVF   xFB,F
5F4E:  BTFSS  FD8.2
5F50:  BRA    6066
....................       c = fgetc(COM2);//getc(); 
5F52:  MOVLB  0
5F54:  RCALL  5EE8
5F56:  MOVFF  01,7F7
....................       switch(c) 
....................       { 
5F5A:  MOVLB  7
5F5C:  MOVF   xF7,W
5F5E:  XORLW  7F
5F60:  MOVLB  0
5F62:  BZ    5F6A
5F64:  XORLW  72
5F66:  BZ    5FB8
5F68:  BRA    5FF6
....................          case 0x7f:    
....................             if(nbcar>0)   
5F6A:  MOVLB  7
5F6C:  MOVF   xF9,F
5F6E:  BNZ   5F74
5F70:  MOVF   xFA,F
5F72:  BZ    5F9E
5F74:  CLRF   19
5F76:  BTFSC  FF2.7
5F78:  BSF    19.7
5F7A:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
5F7C:  MOVLW  7F
5F7E:  MOVLB  9
5F80:  MOVWF  x0C
5F82:  MOVLB  0
5F84:  CALL   1620
5F88:  BTFSC  19.7
5F8A:  BSF    FF2.7
....................                nbcar--; 
5F8C:  MOVLB  7
5F8E:  MOVF   xF9,W
5F90:  BTFSC  FD8.2
5F92:  DECF   xFA,F
5F94:  DECF   xF9,F
....................                fgetc(COM2);//getc(); 
5F96:  MOVLB  0
5F98:  RCALL  5EE8
....................             } 
....................             else fputc(0x07,COM2);    
5F9A:  BRA    5FB6
5F9C:  MOVLB  7
5F9E:  CLRF   19
5FA0:  BTFSC  FF2.7
5FA2:  BSF    19.7
5FA4:  BCF    FF2.7
5FA6:  MOVLW  07
5FA8:  MOVLB  9
5FAA:  MOVWF  x0C
5FAC:  MOVLB  0
5FAE:  CALL   1620
5FB2:  BTFSC  19.7
5FB4:  BSF    FF2.7
....................          break;  
5FB6:  BRA    6062
....................          case 0x0D:   
....................                keydebug_en=0; 
5FB8:  MOVLB  1
5FBA:  CLRF   x44
....................                set_tris_a(0xff); 
5FBC:  MOVLW  FF
5FBE:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
5FC0:  MOVFF  7F9,7F8
5FC4:  MOVLB  7
5FC6:  MOVF   xF4,W
5FC8:  SUBWF  xF8,W
5FCA:  BC    5FE0
....................                { 
....................                  chaine[i]=0; 
5FCC:  CLRF   03
5FCE:  MOVF   xF8,W
5FD0:  ADDWF  xF5,W
5FD2:  MOVWF  FE9
5FD4:  MOVF   xF6,W
5FD6:  ADDWFC 03,W
5FD8:  MOVWF  FEA
5FDA:  CLRF   FEF
....................                } 
5FDC:  INCF   xF8,F
5FDE:  BRA    5FC6
....................                if(nbcar==0)return(FAUX); 
5FE0:  MOVF   xF9,F
5FE2:  BNZ   5FEE
5FE4:  MOVF   xFA,F
5FE6:  BNZ   5FEE
5FE8:  MOVLW  00
5FEA:  MOVWF  01
5FEC:  BRA    606A
....................                fini=VRAI; 
5FEE:  MOVLW  01
5FF0:  MOVWF  xFB
....................          break; 
5FF2:  MOVLB  0
5FF4:  BRA    6062
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
5FF6:  MOVLB  7
5FF8:  MOVF   xF7,W
5FFA:  SUBLW  1F
5FFC:  BC    6064
5FFE:  MOVF   xF7,W
6000:  SUBLW  7E
6002:  BNC   6064
6004:  MOVLW  01
6006:  SUBWF  xF4,W
6008:  MOVF   xFA,F
600A:  BNZ   6064
600C:  SUBWF  xF9,W
600E:  BC    6064
....................             { 
....................                chaine[nbcar]=c; 
6010:  MOVF   xF5,W
6012:  ADDWF  xF9,W
6014:  MOVWF  FE9
6016:  MOVF   xF6,W
6018:  ADDWFC xFA,W
601A:  MOVWF  FEA
601C:  MOVFF  7F7,FEF
....................                nbcar++; 
6020:  INCF   xF9,F
6022:  BTFSC  FD8.2
6024:  INCF   xFA,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
6026:  DECFSZ xF3,W
6028:  BRA    6044
602A:  CLRF   19
602C:  BTFSC  FF2.7
602E:  BSF    19.7
6030:  BCF    FF2.7
6032:  MOVFF  7F7,90C
6036:  MOVLB  0
6038:  CALL   1620
603C:  BTFSC  19.7
603E:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
6040:  BRA    6062
6042:  MOVLB  7
6044:  MOVF   xF3,W
6046:  SUBLW  02
6048:  BNZ   6064
604A:  CLRF   19
604C:  BTFSC  FF2.7
604E:  BSF    19.7
6050:  BCF    FF2.7
6052:  MOVLW  2A
6054:  MOVLB  9
6056:  MOVWF  x0C
6058:  MOVLB  0
605A:  CALL   1620
605E:  BTFSC  19.7
6060:  BSF    FF2.7
6062:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
6064:  BRA    5F3E
....................    return(nbcar); 
6066:  MOVFF  7F9,01
.................... } 
606A:  MOVLB  0
606C:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
606E:  MOVFF  7F4,7F8
6072:  MOVFF  7F3,7F7
6076:  MOVFF  7F6,7FA
607A:  MOVFF  7F5,7F9
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
607E:  MOVFF  7F8,03
6082:  MOVLB  7
6084:  MOVFF  7F7,FE9
6088:  MOVFF  7F8,FEA
608C:  MOVF   FEF,F
608E:  BZ    60D6
6090:  MOVFF  7FA,03
6094:  MOVFF  7F9,FE9
6098:  MOVFF  7FA,FEA
609C:  MOVF   FEF,F
609E:  BZ    60D6
....................       if(*aa!=*bb) 
60A0:  MOVFF  7F7,FE9
60A4:  MOVFF  7F8,FEA
60A8:  MOVFF  FEF,7FB
60AC:  MOVFF  7FA,03
60B0:  MOVFF  7F9,FE9
60B4:  MOVFF  7FA,FEA
60B8:  MOVF   FEF,W
60BA:  SUBWF  xFB,W
60BC:  BZ    60C4
....................          return(1); 
60BE:  MOVLW  01
60C0:  MOVWF  01
60C2:  BRA    6102
....................       aa++; 
60C4:  INCF   xF7,F
60C6:  BTFSC  FD8.2
60C8:  INCF   xF8,F
....................       bb++; 
60CA:  INCF   xF9,F
60CC:  BTFSC  FD8.2
60CE:  INCF   xFA,F
....................    } 
60D0:  MOVLB  0
60D2:  BRA    607E
60D4:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
60D6:  MOVFF  7F8,03
60DA:  MOVFF  7F7,FE9
60DE:  MOVFF  7F8,FEA
60E2:  MOVFF  FEF,7FB
60E6:  MOVFF  7FA,03
60EA:  MOVFF  7F9,FE9
60EE:  MOVFF  7FA,FEA
60F2:  MOVF   FEF,W
60F4:  SUBWF  xFB,W
60F6:  BZ    60FE
60F8:  MOVLW  01
60FA:  MOVWF  01
60FC:  BRA    6102
....................    return(0); 
60FE:  MOVLW  00
6100:  MOVWF  01
.................... } 
6102:  MOVLB  0
6104:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
6A50:  MOVLB  7
6A52:  CLRF   xF5
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
6A54:  MOVFF  7F4,03
6A58:  MOVF   xF3,W
6A5A:  INCF   xF3,F
6A5C:  BTFSC  FD8.2
6A5E:  INCF   xF4,F
6A60:  MOVWF  FE9
6A62:  MOVFF  03,FEA
6A66:  MOVFF  FEF,7F7
6A6A:  MOVF   xF7,F
6A6C:  BZ    6A90
....................         if (c >= '0' && c <= '9') 
6A6E:  MOVF   xF7,W
6A70:  SUBLW  2F
6A72:  BC    6A82
6A74:  MOVF   xF7,W
6A76:  SUBLW  39
6A78:  BNC   6A82
....................             digit = (unsigned int) (c - '0'); 
6A7A:  MOVLW  30
6A7C:  SUBWF  xF7,W
6A7E:  MOVWF  xF6
....................         else 
6A80:  BRA    6A84
....................             break; 
6A82:  BRA    6A90
....................  
....................         val = (val * 10) + digit; 
6A84:  MOVF   xF5,W
6A86:  MULLW  0A
6A88:  MOVF   FF3,W
6A8A:  ADDWF  xF6,W
6A8C:  MOVWF  xF5
....................     } 
6A8E:  BRA    6A54
....................  
....................     return val; 
6A90:  CLRF   03
6A92:  MOVFF  7F5,01
6A96:  MOVFF  03,02
.................... } 
6A9A:  MOVLB  0
6A9C:  RETURN 0
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
06C8:  MOVLB  9
06CA:  CLRF   x3F
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
06CC:  CLRF   x40
06CE:  BTFSC  x37.0
06D0:  BSF    x40.7
06D2:  SWAPF  x38,W
06D4:  MOVWF  00
06D6:  RLCF   00,F
06D8:  RLCF   00,F
06DA:  MOVLW  C0
06DC:  ANDWF  00,F
06DE:  MOVF   00,W
06E0:  IORWF  x40,F
06E2:  SWAPF  x39,W
06E4:  MOVWF  00
06E6:  RLCF   00,F
06E8:  MOVLW  E0
06EA:  ANDWF  00,F
06EC:  MOVF   00,W
06EE:  IORWF  x40,F
06F0:  SWAPF  x3A,W
06F2:  MOVWF  00
06F4:  MOVLW  F0
06F6:  ANDWF  00,F
06F8:  MOVF   00,W
06FA:  IORWF  x40,F
06FC:  RLCF   x3B,W
06FE:  MOVWF  00
0700:  RLCF   00,F
0702:  RLCF   00,F
0704:  MOVLW  F8
0706:  ANDWF  00,F
0708:  MOVF   00,W
070A:  IORWF  x40,F
070C:  RLCF   x3C,W
070E:  MOVWF  00
0710:  RLCF   00,F
0712:  MOVLW  FC
0714:  ANDWF  00,F
0716:  MOVF   00,W
0718:  IORWF  x40,F
071A:  BCF    FD8.0
071C:  RLCF   x3D,W
071E:  IORWF  x40,F
0720:  MOVF   x3E,W
0722:  IORWF  x40,W
0724:  MOVWF  x3F
....................    return temp; 
0726:  MOVFF  93F,01
.................... } 
072A:  MOVLB  0
072C:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
072E:  MOVLB  9
0730:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
0732:  MOVF   x22,F
0734:  BNZ   080A
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
0736:  MOVF   x25,W
0738:  ADDWF  x23,W
073A:  MOVWF  FE9
073C:  MOVF   x26,W
073E:  ADDWFC x24,W
0740:  MOVWF  FEA
0742:  MOVFF  FEF,928
0746:  MOVLW  01
0748:  ADDWF  x23,W
074A:  MOVWF  x29
074C:  MOVLW  00
074E:  ADDWFC x24,W
0750:  MOVWF  x2A
0752:  MOVF   x25,W
0754:  ADDWF  x29,W
0756:  MOVWF  FE9
0758:  MOVF   x26,W
075A:  ADDWFC x2A,W
075C:  MOVWF  FEA
075E:  MOVF   FEF,W
0760:  XORWF  x28,F
0762:  MOVLW  02
0764:  ADDWF  x23,W
0766:  MOVWF  x2B
0768:  MOVLW  00
076A:  ADDWFC x24,W
076C:  MOVWF  x2C
076E:  MOVF   x25,W
0770:  ADDWF  x2B,W
0772:  MOVWF  FE9
0774:  MOVF   x26,W
0776:  ADDWFC x2C,W
0778:  MOVWF  FEA
077A:  MOVF   FEF,W
077C:  XORWF  x28,F
077E:  MOVLW  03
0780:  ADDWF  x23,W
0782:  MOVWF  x2D
0784:  MOVLW  00
0786:  ADDWFC x24,W
0788:  MOVWF  x2E
078A:  MOVF   x25,W
078C:  ADDWF  x2D,W
078E:  MOVWF  FE9
0790:  MOVF   x26,W
0792:  ADDWFC x2E,W
0794:  MOVWF  FEA
0796:  MOVF   FEF,W
0798:  XORWF  x28,F
079A:  MOVLW  04
079C:  ADDWF  x23,W
079E:  MOVWF  x2F
07A0:  MOVLW  00
07A2:  ADDWFC x24,W
07A4:  MOVWF  x30
07A6:  MOVF   x25,W
07A8:  ADDWF  x2F,W
07AA:  MOVWF  FE9
07AC:  MOVF   x26,W
07AE:  ADDWFC x30,W
07B0:  MOVWF  FEA
07B2:  MOVF   FEF,W
07B4:  XORWF  x28,F
07B6:  MOVLW  05
07B8:  ADDWF  x23,W
07BA:  MOVWF  x31
07BC:  MOVLW  00
07BE:  ADDWFC x24,W
07C0:  MOVWF  x32
07C2:  MOVF   x25,W
07C4:  ADDWF  x31,W
07C6:  MOVWF  FE9
07C8:  MOVF   x26,W
07CA:  ADDWFC x32,W
07CC:  MOVWF  FEA
07CE:  MOVF   FEF,W
07D0:  XORWF  x28,W
07D2:  BZ    07D8
07D4:  MOVLW  00
07D6:  BRA    07DA
07D8:  MOVLW  01
07DA:  MOVWF  x27
....................       if(temp==datain[offset+6]) return 1; 
07DC:  MOVLW  06
07DE:  ADDWF  x23,W
07E0:  MOVWF  x28
07E2:  MOVLW  00
07E4:  ADDWFC x24,W
07E6:  MOVWF  x29
07E8:  MOVF   x25,W
07EA:  ADDWF  x28,W
07EC:  MOVWF  FE9
07EE:  MOVF   x26,W
07F0:  ADDWFC x29,W
07F2:  MOVWF  FEA
07F4:  MOVF   FEF,W
07F6:  SUBWF  x27,W
07F8:  BNZ   0802
07FA:  MOVLW  01
07FC:  MOVWF  01
07FE:  BRA    08DA
....................          else return 0; 
0800:  BRA    0808
0802:  MOVLW  00
0804:  MOVWF  01
0806:  BRA    08DA
....................    } 
....................       else  
0808:  BRA    08DA
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
080A:  MOVF   x25,W
080C:  ADDWF  x23,W
080E:  MOVWF  FE9
0810:  MOVF   x26,W
0812:  ADDWFC x24,W
0814:  MOVWF  FEA
0816:  MOVFF  FEF,928
081A:  MOVLW  01
081C:  SUBWF  x23,W
081E:  MOVWF  x29
0820:  MOVLW  00
0822:  SUBWFB x24,W
0824:  MOVWF  x2A
0826:  MOVF   x25,W
0828:  ADDWF  x29,W
082A:  MOVWF  FE9
082C:  MOVF   x26,W
082E:  ADDWFC x2A,W
0830:  MOVWF  FEA
0832:  MOVF   FEF,W
0834:  XORWF  x28,F
0836:  MOVLW  02
0838:  SUBWF  x23,W
083A:  MOVWF  x2B
083C:  MOVLW  00
083E:  SUBWFB x24,W
0840:  MOVWF  x2C
0842:  MOVF   x25,W
0844:  ADDWF  x2B,W
0846:  MOVWF  FE9
0848:  MOVF   x26,W
084A:  ADDWFC x2C,W
084C:  MOVWF  FEA
084E:  MOVF   FEF,W
0850:  XORWF  x28,F
0852:  MOVLW  03
0854:  SUBWF  x23,W
0856:  MOVWF  x2D
0858:  MOVLW  00
085A:  SUBWFB x24,W
085C:  MOVWF  x2E
085E:  MOVF   x25,W
0860:  ADDWF  x2D,W
0862:  MOVWF  FE9
0864:  MOVF   x26,W
0866:  ADDWFC x2E,W
0868:  MOVWF  FEA
086A:  MOVF   FEF,W
086C:  XORWF  x28,F
086E:  MOVLW  04
0870:  SUBWF  x23,W
0872:  MOVWF  x2F
0874:  MOVLW  00
0876:  SUBWFB x24,W
0878:  MOVWF  x30
087A:  MOVF   x25,W
087C:  ADDWF  x2F,W
087E:  MOVWF  FE9
0880:  MOVF   x26,W
0882:  ADDWFC x30,W
0884:  MOVWF  FEA
0886:  MOVF   FEF,W
0888:  XORWF  x28,F
088A:  MOVLW  05
088C:  SUBWF  x23,W
088E:  MOVWF  x31
0890:  MOVLW  00
0892:  SUBWFB x24,W
0894:  MOVWF  x32
0896:  MOVF   x25,W
0898:  ADDWF  x31,W
089A:  MOVWF  FE9
089C:  MOVF   x26,W
089E:  ADDWFC x32,W
08A0:  MOVWF  FEA
08A2:  MOVF   FEF,W
08A4:  XORWF  x28,W
08A6:  BZ    08AC
08A8:  MOVLW  00
08AA:  BRA    08AE
08AC:  MOVLW  01
08AE:  MOVWF  x27
....................          if(temp==datain[offset-6]) return 1; 
08B0:  MOVLW  06
08B2:  SUBWF  x23,W
08B4:  MOVWF  x28
08B6:  MOVLW  00
08B8:  SUBWFB x24,W
08BA:  MOVWF  x29
08BC:  MOVF   x25,W
08BE:  ADDWF  x28,W
08C0:  MOVWF  FE9
08C2:  MOVF   x26,W
08C4:  ADDWFC x29,W
08C6:  MOVWF  FEA
08C8:  MOVF   FEF,W
08CA:  SUBWF  x27,W
08CC:  BNZ   08D6
08CE:  MOVLW  01
08D0:  MOVWF  01
08D2:  BRA    08DA
....................             else return 0;          
08D4:  BRA    08DA
08D6:  MOVLW  00
08D8:  MOVWF  01
....................       } 
.................... } 
08DA:  MOVLB  0
08DC:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
08DE:  MOVLB  9
08E0:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
08E2:  MOVF   x22,F
08E4:  BNZ   0982
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
08E6:  MOVF   x25,W
08E8:  ADDWF  x23,W
08EA:  MOVWF  FE9
08EC:  MOVF   x26,W
08EE:  ADDWFC x24,W
08F0:  MOVWF  FEA
08F2:  MOVFF  FEF,928
08F6:  MOVLW  01
08F8:  ADDWF  x23,W
08FA:  MOVWF  x29
08FC:  MOVLW  00
08FE:  ADDWFC x24,W
0900:  MOVWF  x2A
0902:  MOVF   x25,W
0904:  ADDWF  x29,W
0906:  MOVWF  FE9
0908:  MOVF   x26,W
090A:  ADDWFC x2A,W
090C:  MOVWF  FEA
090E:  MOVF   FEF,W
0910:  XORWF  x28,F
0912:  MOVLW  02
0914:  ADDWF  x23,W
0916:  MOVWF  x2B
0918:  MOVLW  00
091A:  ADDWFC x24,W
091C:  MOVWF  x2C
091E:  MOVF   x25,W
0920:  ADDWF  x2B,W
0922:  MOVWF  FE9
0924:  MOVF   x26,W
0926:  ADDWFC x2C,W
0928:  MOVWF  FEA
092A:  MOVF   FEF,W
092C:  XORWF  x28,F
092E:  MOVLW  03
0930:  ADDWF  x23,W
0932:  MOVWF  x2D
0934:  MOVLW  00
0936:  ADDWFC x24,W
0938:  MOVWF  x2E
093A:  MOVF   x25,W
093C:  ADDWF  x2D,W
093E:  MOVWF  FE9
0940:  MOVF   x26,W
0942:  ADDWFC x2E,W
0944:  MOVWF  FEA
0946:  MOVF   FEF,W
0948:  XORWF  x28,W
094A:  BZ    0950
094C:  MOVLW  00
094E:  BRA    0952
0950:  MOVLW  01
0952:  MOVWF  x27
....................       if(temp==datain[offset+4]) return 1; 
0954:  MOVLW  04
0956:  ADDWF  x23,W
0958:  MOVWF  x28
095A:  MOVLW  00
095C:  ADDWFC x24,W
095E:  MOVWF  x29
0960:  MOVF   x25,W
0962:  ADDWF  x28,W
0964:  MOVWF  FE9
0966:  MOVF   x26,W
0968:  ADDWFC x29,W
096A:  MOVWF  FEA
096C:  MOVF   FEF,W
096E:  SUBWF  x27,W
0970:  BNZ   097A
0972:  MOVLW  01
0974:  MOVWF  01
0976:  BRA    0A1A
....................          else return 0; 
0978:  BRA    0980
097A:  MOVLW  00
097C:  MOVWF  01
097E:  BRA    0A1A
....................    } 
....................    else 
0980:  BRA    0A1A
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0982:  MOVF   x25,W
0984:  ADDWF  x23,W
0986:  MOVWF  FE9
0988:  MOVF   x26,W
098A:  ADDWFC x24,W
098C:  MOVWF  FEA
098E:  MOVFF  FEF,928
0992:  MOVLW  01
0994:  SUBWF  x23,W
0996:  MOVWF  x29
0998:  MOVLW  00
099A:  SUBWFB x24,W
099C:  MOVWF  x2A
099E:  MOVF   x25,W
09A0:  ADDWF  x29,W
09A2:  MOVWF  FE9
09A4:  MOVF   x26,W
09A6:  ADDWFC x2A,W
09A8:  MOVWF  FEA
09AA:  MOVF   FEF,W
09AC:  XORWF  x28,F
09AE:  MOVLW  02
09B0:  SUBWF  x23,W
09B2:  MOVWF  x2B
09B4:  MOVLW  00
09B6:  SUBWFB x24,W
09B8:  MOVWF  x2C
09BA:  MOVF   x25,W
09BC:  ADDWF  x2B,W
09BE:  MOVWF  FE9
09C0:  MOVF   x26,W
09C2:  ADDWFC x2C,W
09C4:  MOVWF  FEA
09C6:  MOVF   FEF,W
09C8:  XORWF  x28,F
09CA:  MOVLW  03
09CC:  SUBWF  x23,W
09CE:  MOVWF  x2D
09D0:  MOVLW  00
09D2:  SUBWFB x24,W
09D4:  MOVWF  x2E
09D6:  MOVF   x25,W
09D8:  ADDWF  x2D,W
09DA:  MOVWF  FE9
09DC:  MOVF   x26,W
09DE:  ADDWFC x2E,W
09E0:  MOVWF  FEA
09E2:  MOVF   FEF,W
09E4:  XORWF  x28,W
09E6:  BZ    09EC
09E8:  MOVLW  00
09EA:  BRA    09EE
09EC:  MOVLW  01
09EE:  MOVWF  x27
....................       if(temp==datain[offset-4]) return 1; 
09F0:  MOVLW  04
09F2:  SUBWF  x23,W
09F4:  MOVWF  x28
09F6:  MOVLW  00
09F8:  SUBWFB x24,W
09FA:  MOVWF  x29
09FC:  MOVF   x25,W
09FE:  ADDWF  x28,W
0A00:  MOVWF  FE9
0A02:  MOVF   x26,W
0A04:  ADDWFC x29,W
0A06:  MOVWF  FEA
0A08:  MOVF   FEF,W
0A0A:  SUBWF  x27,W
0A0C:  BNZ   0A16
0A0E:  MOVLW  01
0A10:  MOVWF  01
0A12:  BRA    0A1A
....................          else return 0;                
0A14:  BRA    0A1A
0A16:  MOVLW  00
0A18:  MOVWF  01
....................    } 
.................... } 
0A1A:  MOVLB  0
0A1C:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0A1E:  MOVLB  9
0A20:  CLRF   x1E
0A22:  CLRF   x1F
0A24:  CLRF   x20
0A26:  CLRF   x21
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0A28:  CLRF   x1B
0A2A:  CLRF   x1A
0A2C:  RRCF   x17,W
0A2E:  MOVWF  03
0A30:  RRCF   x16,W
0A32:  MOVWF  02
0A34:  RRCF   03,F
0A36:  RRCF   02,F
0A38:  MOVLW  3F
0A3A:  ANDWF  03,F
0A3C:  MOVFF  02,01
0A40:  MOVF   x1B,W
0A42:  SUBWF  03,W
0A44:  BTFSS  FD8.0
0A46:  BRA    1006
0A48:  BNZ   0A52
0A4A:  MOVF   01,W
0A4C:  SUBWF  x1A,W
0A4E:  BTFSC  FD8.0
0A50:  BRA    1006
....................    { 
....................       if(track==0) 
0A52:  MOVF   x15,F
0A54:  BTFSS  FD8.2
0A56:  BRA    0D8C
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0A58:  MOVLW  06
0A5A:  ADDWF  x1A,W
0A5C:  MOVWF  x22
0A5E:  MOVLW  00
0A60:  ADDWFC x1B,W
0A62:  MOVWF  x23
0A64:  MOVF   x18,W
0A66:  ADDWF  x22,W
0A68:  MOVWF  FE9
0A6A:  MOVF   x19,W
0A6C:  ADDWFC x23,W
0A6E:  MOVWF  FEA
0A70:  MOVFF  FEF,924
0A74:  MOVLW  05
0A76:  ADDWF  x1A,W
0A78:  MOVWF  x25
0A7A:  MOVLW  00
0A7C:  ADDWFC x1B,W
0A7E:  MOVWF  x26
0A80:  MOVF   x18,W
0A82:  ADDWF  x25,W
0A84:  MOVWF  FE9
0A86:  MOVF   x19,W
0A88:  ADDWFC x26,W
0A8A:  MOVWF  FEA
0A8C:  MOVFF  FEF,927
0A90:  MOVLW  04
0A92:  ADDWF  x1A,W
0A94:  MOVWF  x28
0A96:  MOVLW  00
0A98:  ADDWFC x1B,W
0A9A:  MOVWF  x29
0A9C:  MOVF   x18,W
0A9E:  ADDWF  x28,W
0AA0:  MOVWF  FE9
0AA2:  MOVF   x19,W
0AA4:  ADDWFC x29,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEF,92A
0AAC:  MOVLW  03
0AAE:  ADDWF  x1A,W
0AB0:  MOVWF  x2B
0AB2:  MOVLW  00
0AB4:  ADDWFC x1B,W
0AB6:  MOVWF  x2C
0AB8:  MOVF   x18,W
0ABA:  ADDWF  x2B,W
0ABC:  MOVWF  FE9
0ABE:  MOVF   x19,W
0AC0:  ADDWFC x2C,W
0AC2:  MOVWF  FEA
0AC4:  MOVFF  FEF,92D
0AC8:  MOVLW  02
0ACA:  ADDWF  x1A,W
0ACC:  MOVWF  x2E
0ACE:  MOVLW  00
0AD0:  ADDWFC x1B,W
0AD2:  MOVWF  x2F
0AD4:  MOVF   x18,W
0AD6:  ADDWF  x2E,W
0AD8:  MOVWF  FE9
0ADA:  MOVF   x19,W
0ADC:  ADDWFC x2F,W
0ADE:  MOVWF  FEA
0AE0:  MOVFF  FEF,930
0AE4:  MOVLW  01
0AE6:  ADDWF  x1A,W
0AE8:  MOVWF  x31
0AEA:  MOVLW  00
0AEC:  ADDWFC x1B,W
0AEE:  MOVWF  x32
0AF0:  MOVF   x18,W
0AF2:  ADDWF  x31,W
0AF4:  MOVWF  FE9
0AF6:  MOVF   x19,W
0AF8:  ADDWFC x32,W
0AFA:  MOVWF  FEA
0AFC:  MOVFF  FEF,933
0B00:  MOVF   x18,W
0B02:  ADDWF  x1A,W
0B04:  MOVWF  FE9
0B06:  MOVF   x19,W
0B08:  ADDWFC x1B,W
0B0A:  MOVWF  FEA
0B0C:  MOVFF  FEF,934
0B10:  CLRF   x37
0B12:  MOVFF  924,938
0B16:  MOVFF  927,939
0B1A:  MOVFF  92A,93A
0B1E:  MOVFF  92D,93B
0B22:  MOVFF  930,93C
0B26:  MOVFF  933,93D
0B2A:  MOVFF  934,93E
0B2E:  MOVLB  0
0B30:  RCALL  06C8
0B32:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0B36:  MOVLW  0D
0B38:  MOVLB  9
0B3A:  ADDWF  x1A,W
0B3C:  MOVWF  x22
0B3E:  MOVLW  00
0B40:  ADDWFC x1B,W
0B42:  MOVWF  x23
0B44:  MOVF   x18,W
0B46:  ADDWF  x22,W
0B48:  MOVWF  FE9
0B4A:  MOVF   x19,W
0B4C:  ADDWFC x23,W
0B4E:  MOVWF  FEA
0B50:  MOVFF  FEF,924
0B54:  MOVLW  0C
0B56:  ADDWF  x1A,W
0B58:  MOVWF  x25
0B5A:  MOVLW  00
0B5C:  ADDWFC x1B,W
0B5E:  MOVWF  x26
0B60:  MOVF   x18,W
0B62:  ADDWF  x25,W
0B64:  MOVWF  FE9
0B66:  MOVF   x19,W
0B68:  ADDWFC x26,W
0B6A:  MOVWF  FEA
0B6C:  MOVFF  FEF,927
0B70:  MOVLW  0B
0B72:  ADDWF  x1A,W
0B74:  MOVWF  x28
0B76:  MOVLW  00
0B78:  ADDWFC x1B,W
0B7A:  MOVWF  x29
0B7C:  MOVF   x18,W
0B7E:  ADDWF  x28,W
0B80:  MOVWF  FE9
0B82:  MOVF   x19,W
0B84:  ADDWFC x29,W
0B86:  MOVWF  FEA
0B88:  MOVFF  FEF,92A
0B8C:  MOVLW  0A
0B8E:  ADDWF  x1A,W
0B90:  MOVWF  x2B
0B92:  MOVLW  00
0B94:  ADDWFC x1B,W
0B96:  MOVWF  x2C
0B98:  MOVF   x18,W
0B9A:  ADDWF  x2B,W
0B9C:  MOVWF  FE9
0B9E:  MOVF   x19,W
0BA0:  ADDWFC x2C,W
0BA2:  MOVWF  FEA
0BA4:  MOVFF  FEF,92D
0BA8:  MOVLW  09
0BAA:  ADDWF  x1A,W
0BAC:  MOVWF  x2E
0BAE:  MOVLW  00
0BB0:  ADDWFC x1B,W
0BB2:  MOVWF  x2F
0BB4:  MOVF   x18,W
0BB6:  ADDWF  x2E,W
0BB8:  MOVWF  FE9
0BBA:  MOVF   x19,W
0BBC:  ADDWFC x2F,W
0BBE:  MOVWF  FEA
0BC0:  MOVFF  FEF,930
0BC4:  MOVLW  08
0BC6:  ADDWF  x1A,W
0BC8:  MOVWF  x31
0BCA:  MOVLW  00
0BCC:  ADDWFC x1B,W
0BCE:  MOVWF  x32
0BD0:  MOVF   x18,W
0BD2:  ADDWF  x31,W
0BD4:  MOVWF  FE9
0BD6:  MOVF   x19,W
0BD8:  ADDWFC x32,W
0BDA:  MOVWF  FEA
0BDC:  MOVFF  FEF,933
0BE0:  MOVLW  07
0BE2:  ADDWF  x1A,W
0BE4:  MOVWF  x34
0BE6:  MOVLW  00
0BE8:  ADDWFC x1B,W
0BEA:  MOVWF  x35
0BEC:  MOVF   x18,W
0BEE:  ADDWF  x34,W
0BF0:  MOVWF  FE9
0BF2:  MOVF   x19,W
0BF4:  ADDWFC x35,W
0BF6:  MOVWF  FEA
0BF8:  MOVFF  FEF,936
0BFC:  CLRF   x37
0BFE:  MOVFF  924,938
0C02:  MOVFF  927,939
0C06:  MOVFF  92A,93A
0C0A:  MOVFF  92D,93B
0C0E:  MOVFF  930,93C
0C12:  MOVFF  933,93D
0C16:  MOVFF  936,93E
0C1A:  MOVLB  0
0C1C:  RCALL  06C8
0C1E:  MOVFF  01,91F
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0C22:  MOVLB  9
0C24:  MOVF   x1E,W
0C26:  SUBLW  45
0C28:  BTFSS  FD8.2
0C2A:  BRA    0D8A
0C2C:  MOVF   x1F,W
0C2E:  SUBLW  7C
0C30:  BTFSC  FD8.2
0C32:  BRA    0D8A
0C34:  MOVF   x1F,W
0C36:  SUBLW  3E
0C38:  BTFSC  FD8.2
0C3A:  BRA    0D8A
0C3C:  MOVF   x1F,W
0C3E:  SUBLW  1F
0C40:  BTFSC  FD8.2
0C42:  BRA    0D8A
....................          { 
....................             j=i; 
0C44:  MOVFF  91B,91D
0C48:  MOVFF  91A,91C
....................             CRC=1; 
0C4C:  MOVLW  01
0C4E:  MOVWF  x21
....................             temp2=temp; 
0C50:  MOVFF  91E,920
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0C54:  MOVF   x20,W
0C56:  SUBLW  1F
0C58:  BTFSC  FD8.2
0C5A:  BRA    0D74
0C5C:  MOVF   x1D,W
0C5E:  SUBLW  03
0C60:  BTFSS  FD8.0
0C62:  BRA    0D74
0C64:  BNZ   0C6E
0C66:  MOVF   x1C,W
0C68:  SUBLW  E7
0C6A:  BTFSS  FD8.0
0C6C:  BRA    0D74
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C6E:  CLRF   x22
0C70:  MOVFF  91D,924
0C74:  MOVFF  91C,923
0C78:  MOVFF  919,926
0C7C:  MOVFF  918,925
0C80:  MOVLB  0
0C82:  RCALL  072E
0C84:  MOVF   01,W
0C86:  MOVLB  9
0C88:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C8A:  MOVLW  06
0C8C:  ADDWF  x1C,W
0C8E:  MOVWF  x22
0C90:  MOVLW  00
0C92:  ADDWFC x1D,W
0C94:  MOVWF  x23
0C96:  MOVF   x18,W
0C98:  ADDWF  x22,W
0C9A:  MOVWF  FE9
0C9C:  MOVF   x19,W
0C9E:  ADDWFC x23,W
0CA0:  MOVWF  FEA
0CA2:  MOVFF  FEF,924
0CA6:  MOVLW  05
0CA8:  ADDWF  x1C,W
0CAA:  MOVWF  x25
0CAC:  MOVLW  00
0CAE:  ADDWFC x1D,W
0CB0:  MOVWF  x26
0CB2:  MOVF   x18,W
0CB4:  ADDWF  x25,W
0CB6:  MOVWF  FE9
0CB8:  MOVF   x19,W
0CBA:  ADDWFC x26,W
0CBC:  MOVWF  FEA
0CBE:  MOVFF  FEF,927
0CC2:  MOVLW  04
0CC4:  ADDWF  x1C,W
0CC6:  MOVWF  x28
0CC8:  MOVLW  00
0CCA:  ADDWFC x1D,W
0CCC:  MOVWF  x29
0CCE:  MOVF   x18,W
0CD0:  ADDWF  x28,W
0CD2:  MOVWF  FE9
0CD4:  MOVF   x19,W
0CD6:  ADDWFC x29,W
0CD8:  MOVWF  FEA
0CDA:  MOVFF  FEF,92A
0CDE:  MOVLW  03
0CE0:  ADDWF  x1C,W
0CE2:  MOVWF  x2B
0CE4:  MOVLW  00
0CE6:  ADDWFC x1D,W
0CE8:  MOVWF  x2C
0CEA:  MOVF   x18,W
0CEC:  ADDWF  x2B,W
0CEE:  MOVWF  FE9
0CF0:  MOVF   x19,W
0CF2:  ADDWFC x2C,W
0CF4:  MOVWF  FEA
0CF6:  MOVFF  FEF,92D
0CFA:  MOVLW  02
0CFC:  ADDWF  x1C,W
0CFE:  MOVWF  x2E
0D00:  MOVLW  00
0D02:  ADDWFC x1D,W
0D04:  MOVWF  x2F
0D06:  MOVF   x18,W
0D08:  ADDWF  x2E,W
0D0A:  MOVWF  FE9
0D0C:  MOVF   x19,W
0D0E:  ADDWFC x2F,W
0D10:  MOVWF  FEA
0D12:  MOVFF  FEF,930
0D16:  MOVLW  01
0D18:  ADDWF  x1C,W
0D1A:  MOVWF  x31
0D1C:  MOVLW  00
0D1E:  ADDWFC x1D,W
0D20:  MOVWF  x32
0D22:  MOVF   x18,W
0D24:  ADDWF  x31,W
0D26:  MOVWF  FE9
0D28:  MOVF   x19,W
0D2A:  ADDWFC x32,W
0D2C:  MOVWF  FEA
0D2E:  MOVFF  FEF,933
0D32:  MOVF   x18,W
0D34:  ADDWF  x1C,W
0D36:  MOVWF  FE9
0D38:  MOVF   x19,W
0D3A:  ADDWFC x1D,W
0D3C:  MOVWF  FEA
0D3E:  MOVFF  FEF,934
0D42:  CLRF   x37
0D44:  MOVFF  924,938
0D48:  MOVFF  927,939
0D4C:  MOVFF  92A,93A
0D50:  MOVFF  92D,93B
0D54:  MOVFF  930,93C
0D58:  MOVFF  933,93D
0D5C:  MOVFF  934,93E
0D60:  MOVLB  0
0D62:  RCALL  06C8
0D64:  MOVFF  01,920
....................                j=j+7; 
0D68:  MOVLW  07
0D6A:  MOVLB  9
0D6C:  ADDWF  x1C,F
0D6E:  MOVLW  00
0D70:  ADDWFC x1D,F
....................             } 
0D72:  BRA    0C54
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D74:  DECFSZ x21,W
0D76:  BRA    0D8A
....................             { 
....................                dir=0; 
0D78:  MOVLB  6
0D7A:  CLRF   xC8
....................                return i; 
0D7C:  MOVLB  9
0D7E:  MOVFF  91A,01
0D82:  MOVFF  91B,02
0D86:  GOTO   161C
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0D8A:  BRA    0FFE
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0D8C:  MOVLW  04
0D8E:  ADDWF  x1A,W
0D90:  MOVWF  x22
0D92:  MOVLW  00
0D94:  ADDWFC x1B,W
0D96:  MOVWF  x23
0D98:  MOVF   x18,W
0D9A:  ADDWF  x22,W
0D9C:  MOVWF  FE9
0D9E:  MOVF   x19,W
0DA0:  ADDWFC x23,W
0DA2:  MOVWF  FEA
0DA4:  MOVFF  FEF,924
0DA8:  MOVLW  03
0DAA:  ADDWF  x1A,W
0DAC:  MOVWF  x25
0DAE:  MOVLW  00
0DB0:  ADDWFC x1B,W
0DB2:  MOVWF  x26
0DB4:  MOVF   x18,W
0DB6:  ADDWF  x25,W
0DB8:  MOVWF  FE9
0DBA:  MOVF   x19,W
0DBC:  ADDWFC x26,W
0DBE:  MOVWF  FEA
0DC0:  MOVFF  FEF,927
0DC4:  MOVLW  02
0DC6:  ADDWF  x1A,W
0DC8:  MOVWF  x28
0DCA:  MOVLW  00
0DCC:  ADDWFC x1B,W
0DCE:  MOVWF  x29
0DD0:  MOVF   x18,W
0DD2:  ADDWF  x28,W
0DD4:  MOVWF  FE9
0DD6:  MOVF   x19,W
0DD8:  ADDWFC x29,W
0DDA:  MOVWF  FEA
0DDC:  MOVFF  FEF,92A
0DE0:  MOVLW  01
0DE2:  ADDWF  x1A,W
0DE4:  MOVWF  x2B
0DE6:  MOVLW  00
0DE8:  ADDWFC x1B,W
0DEA:  MOVWF  x2C
0DEC:  MOVF   x18,W
0DEE:  ADDWF  x2B,W
0DF0:  MOVWF  FE9
0DF2:  MOVF   x19,W
0DF4:  ADDWFC x2C,W
0DF6:  MOVWF  FEA
0DF8:  MOVFF  FEF,92D
0DFC:  MOVF   x18,W
0DFE:  ADDWF  x1A,W
0E00:  MOVWF  FE9
0E02:  MOVF   x19,W
0E04:  ADDWFC x1B,W
0E06:  MOVWF  FEA
0E08:  MOVFF  FEF,92E
0E0C:  CLRF   x37
0E0E:  CLRF   x38
0E10:  CLRF   x39
0E12:  MOVFF  924,93A
0E16:  MOVFF  927,93B
0E1A:  MOVFF  92A,93C
0E1E:  MOVFF  92D,93D
0E22:  MOVFF  92E,93E
0E26:  MOVLB  0
0E28:  RCALL  06C8
0E2A:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0E2E:  MOVLW  09
0E30:  MOVLB  9
0E32:  ADDWF  x1A,W
0E34:  MOVWF  x22
0E36:  MOVLW  00
0E38:  ADDWFC x1B,W
0E3A:  MOVWF  x23
0E3C:  MOVF   x18,W
0E3E:  ADDWF  x22,W
0E40:  MOVWF  FE9
0E42:  MOVF   x19,W
0E44:  ADDWFC x23,W
0E46:  MOVWF  FEA
0E48:  MOVFF  FEF,924
0E4C:  MOVLW  08
0E4E:  ADDWF  x1A,W
0E50:  MOVWF  x25
0E52:  MOVLW  00
0E54:  ADDWFC x1B,W
0E56:  MOVWF  x26
0E58:  MOVF   x18,W
0E5A:  ADDWF  x25,W
0E5C:  MOVWF  FE9
0E5E:  MOVF   x19,W
0E60:  ADDWFC x26,W
0E62:  MOVWF  FEA
0E64:  MOVFF  FEF,927
0E68:  MOVLW  07
0E6A:  ADDWF  x1A,W
0E6C:  MOVWF  x28
0E6E:  MOVLW  00
0E70:  ADDWFC x1B,W
0E72:  MOVWF  x29
0E74:  MOVF   x18,W
0E76:  ADDWF  x28,W
0E78:  MOVWF  FE9
0E7A:  MOVF   x19,W
0E7C:  ADDWFC x29,W
0E7E:  MOVWF  FEA
0E80:  MOVFF  FEF,92A
0E84:  MOVLW  06
0E86:  ADDWF  x1A,W
0E88:  MOVWF  x2B
0E8A:  MOVLW  00
0E8C:  ADDWFC x1B,W
0E8E:  MOVWF  x2C
0E90:  MOVF   x18,W
0E92:  ADDWF  x2B,W
0E94:  MOVWF  FE9
0E96:  MOVF   x19,W
0E98:  ADDWFC x2C,W
0E9A:  MOVWF  FEA
0E9C:  MOVFF  FEF,92D
0EA0:  MOVLW  05
0EA2:  ADDWF  x1A,W
0EA4:  MOVWF  x2E
0EA6:  MOVLW  00
0EA8:  ADDWFC x1B,W
0EAA:  MOVWF  x2F
0EAC:  MOVF   x18,W
0EAE:  ADDWF  x2E,W
0EB0:  MOVWF  FE9
0EB2:  MOVF   x19,W
0EB4:  ADDWFC x2F,W
0EB6:  MOVWF  FEA
0EB8:  MOVFF  FEF,930
0EBC:  CLRF   x37
0EBE:  CLRF   x38
0EC0:  CLRF   x39
0EC2:  MOVFF  924,93A
0EC6:  MOVFF  927,93B
0ECA:  MOVFF  92A,93C
0ECE:  MOVFF  92D,93D
0ED2:  MOVFF  930,93E
0ED6:  MOVLB  0
0ED8:  CALL   06C8
0EDC:  MOVFF  01,91F
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0EE0:  MOVLB  9
0EE2:  MOVF   x1E,W
0EE4:  SUBLW  0B
0EE6:  BTFSS  FD8.2
0EE8:  BRA    0FFE
0EEA:  MOVF   x1F,W
0EEC:  SUBLW  1F
0EEE:  BTFSC  FD8.2
0EF0:  BRA    0FFE
0EF2:  MOVF   x1F,W
0EF4:  SUBLW  0F
0EF6:  BTFSC  FD8.2
0EF8:  BRA    0FFE
....................             { 
....................                j=i; 
0EFA:  MOVFF  91B,91D
0EFE:  MOVFF  91A,91C
....................                CRC=1; 
0F02:  MOVLW  01
0F04:  MOVWF  x21
....................                temp2=temp; 
0F06:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0F0A:  MOVF   x20,W
0F0C:  SUBLW  1F
0F0E:  BZ    0FEA
0F10:  MOVF   x1D,W
0F12:  SUBLW  01
0F14:  BNC   0FEA
0F16:  BNZ   0F1E
0F18:  MOVF   x1C,W
0F1A:  SUBLW  F3
0F1C:  BNC   0FEA
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0F1E:  CLRF   x22
0F20:  MOVFF  91D,924
0F24:  MOVFF  91C,923
0F28:  MOVFF  919,926
0F2C:  MOVFF  918,925
0F30:  MOVLB  0
0F32:  RCALL  08DE
0F34:  MOVF   01,W
0F36:  MOVLB  9
0F38:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0F3A:  MOVLW  04
0F3C:  ADDWF  x1C,W
0F3E:  MOVWF  x22
0F40:  MOVLW  00
0F42:  ADDWFC x1D,W
0F44:  MOVWF  x23
0F46:  MOVF   x18,W
0F48:  ADDWF  x22,W
0F4A:  MOVWF  FE9
0F4C:  MOVF   x19,W
0F4E:  ADDWFC x23,W
0F50:  MOVWF  FEA
0F52:  MOVFF  FEF,924
0F56:  MOVLW  03
0F58:  ADDWF  x1C,W
0F5A:  MOVWF  x25
0F5C:  MOVLW  00
0F5E:  ADDWFC x1D,W
0F60:  MOVWF  x26
0F62:  MOVF   x18,W
0F64:  ADDWF  x25,W
0F66:  MOVWF  FE9
0F68:  MOVF   x19,W
0F6A:  ADDWFC x26,W
0F6C:  MOVWF  FEA
0F6E:  MOVFF  FEF,927
0F72:  MOVLW  02
0F74:  ADDWF  x1C,W
0F76:  MOVWF  x28
0F78:  MOVLW  00
0F7A:  ADDWFC x1D,W
0F7C:  MOVWF  x29
0F7E:  MOVF   x18,W
0F80:  ADDWF  x28,W
0F82:  MOVWF  FE9
0F84:  MOVF   x19,W
0F86:  ADDWFC x29,W
0F88:  MOVWF  FEA
0F8A:  MOVFF  FEF,92A
0F8E:  MOVLW  01
0F90:  ADDWF  x1C,W
0F92:  MOVWF  x2B
0F94:  MOVLW  00
0F96:  ADDWFC x1D,W
0F98:  MOVWF  x2C
0F9A:  MOVF   x18,W
0F9C:  ADDWF  x2B,W
0F9E:  MOVWF  FE9
0FA0:  MOVF   x19,W
0FA2:  ADDWFC x2C,W
0FA4:  MOVWF  FEA
0FA6:  MOVFF  FEF,92D
0FAA:  MOVF   x18,W
0FAC:  ADDWF  x1C,W
0FAE:  MOVWF  FE9
0FB0:  MOVF   x19,W
0FB2:  ADDWFC x1D,W
0FB4:  MOVWF  FEA
0FB6:  MOVFF  FEF,92E
0FBA:  CLRF   x37
0FBC:  CLRF   x38
0FBE:  CLRF   x39
0FC0:  MOVFF  924,93A
0FC4:  MOVFF  927,93B
0FC8:  MOVFF  92A,93C
0FCC:  MOVFF  92D,93D
0FD0:  MOVFF  92E,93E
0FD4:  MOVLB  0
0FD6:  CALL   06C8
0FDA:  MOVFF  01,920
....................                   j=j+5; 
0FDE:  MOVLW  05
0FE0:  MOVLB  9
0FE2:  ADDWF  x1C,F
0FE4:  MOVLW  00
0FE6:  ADDWFC x1D,F
....................                } 
0FE8:  BRA    0F0A
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0FEA:  DECFSZ x21,W
0FEC:  BRA    0FFE
....................                { 
....................                   dir=0; 
0FEE:  MOVLB  6
0FF0:  CLRF   xC8
....................                   return i; 
0FF2:  MOVLB  9
0FF4:  MOVFF  91A,01
0FF8:  MOVFF  91B,02
0FFC:  BRA    161C
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0FFE:  INCF   x1A,F
1000:  BTFSC  FD8.2
1002:  INCF   x1B,F
1004:  BRA    0A2C
....................    for(i=end_point;i>end_point/4;i--) 
1006:  MOVFF  917,91B
100A:  MOVFF  916,91A
100E:  RRCF   x17,W
1010:  MOVWF  03
1012:  RRCF   x16,W
1014:  MOVWF  02
1016:  RRCF   03,F
1018:  RRCF   02,F
101A:  MOVLW  3F
101C:  ANDWF  03,F
101E:  MOVFF  02,01
1022:  MOVF   03,W
1024:  SUBWF  x1B,W
1026:  BTFSS  FD8.0
1028:  BRA    1616
102A:  BNZ   1034
102C:  MOVF   x1A,W
102E:  SUBWF  01,W
1030:  BTFSC  FD8.0
1032:  BRA    1616
....................    { 
....................       if(track==0) 
1034:  MOVF   x15,F
1036:  BTFSS  FD8.2
1038:  BRA    138C
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
103A:  MOVLW  06
103C:  SUBWF  x1A,W
103E:  MOVWF  x22
1040:  MOVLW  00
1042:  SUBWFB x1B,W
1044:  MOVWF  x23
1046:  MOVF   x18,W
1048:  ADDWF  x22,W
104A:  MOVWF  FE9
104C:  MOVF   x19,W
104E:  ADDWFC x23,W
1050:  MOVWF  FEA
1052:  MOVFF  FEF,924
1056:  MOVLW  05
1058:  SUBWF  x1A,W
105A:  MOVWF  x25
105C:  MOVLW  00
105E:  SUBWFB x1B,W
1060:  MOVWF  x26
1062:  MOVF   x18,W
1064:  ADDWF  x25,W
1066:  MOVWF  FE9
1068:  MOVF   x19,W
106A:  ADDWFC x26,W
106C:  MOVWF  FEA
106E:  MOVFF  FEF,927
1072:  MOVLW  04
1074:  SUBWF  x1A,W
1076:  MOVWF  x28
1078:  MOVLW  00
107A:  SUBWFB x1B,W
107C:  MOVWF  x29
107E:  MOVF   x18,W
1080:  ADDWF  x28,W
1082:  MOVWF  FE9
1084:  MOVF   x19,W
1086:  ADDWFC x29,W
1088:  MOVWF  FEA
108A:  MOVFF  FEF,92A
108E:  MOVLW  03
1090:  SUBWF  x1A,W
1092:  MOVWF  x2B
1094:  MOVLW  00
1096:  SUBWFB x1B,W
1098:  MOVWF  x2C
109A:  MOVF   x18,W
109C:  ADDWF  x2B,W
109E:  MOVWF  FE9
10A0:  MOVF   x19,W
10A2:  ADDWFC x2C,W
10A4:  MOVWF  FEA
10A6:  MOVFF  FEF,92D
10AA:  MOVLW  02
10AC:  SUBWF  x1A,W
10AE:  MOVWF  x2E
10B0:  MOVLW  00
10B2:  SUBWFB x1B,W
10B4:  MOVWF  x2F
10B6:  MOVF   x18,W
10B8:  ADDWF  x2E,W
10BA:  MOVWF  FE9
10BC:  MOVF   x19,W
10BE:  ADDWFC x2F,W
10C0:  MOVWF  FEA
10C2:  MOVFF  FEF,930
10C6:  MOVLW  01
10C8:  SUBWF  x1A,W
10CA:  MOVWF  x31
10CC:  MOVLW  00
10CE:  SUBWFB x1B,W
10D0:  MOVWF  x32
10D2:  MOVF   x18,W
10D4:  ADDWF  x31,W
10D6:  MOVWF  FE9
10D8:  MOVF   x19,W
10DA:  ADDWFC x32,W
10DC:  MOVWF  FEA
10DE:  MOVFF  FEF,933
10E2:  MOVF   x18,W
10E4:  ADDWF  x1A,W
10E6:  MOVWF  FE9
10E8:  MOVF   x19,W
10EA:  ADDWFC x1B,W
10EC:  MOVWF  FEA
10EE:  MOVFF  FEF,934
10F2:  CLRF   x37
10F4:  MOVFF  924,938
10F8:  MOVFF  927,939
10FC:  MOVFF  92A,93A
1100:  MOVFF  92D,93B
1104:  MOVFF  930,93C
1108:  MOVFF  933,93D
110C:  MOVFF  934,93E
1110:  MOVLB  0
1112:  CALL   06C8
1116:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
111A:  MOVLW  0D
111C:  MOVLB  9
111E:  SUBWF  x1A,W
1120:  MOVWF  x22
1122:  MOVLW  00
1124:  SUBWFB x1B,W
1126:  MOVWF  x23
1128:  MOVF   x18,W
112A:  ADDWF  x22,W
112C:  MOVWF  FE9
112E:  MOVF   x19,W
1130:  ADDWFC x23,W
1132:  MOVWF  FEA
1134:  MOVFF  FEF,924
1138:  MOVLW  0C
113A:  SUBWF  x1A,W
113C:  MOVWF  x25
113E:  MOVLW  00
1140:  SUBWFB x1B,W
1142:  MOVWF  x26
1144:  MOVF   x18,W
1146:  ADDWF  x25,W
1148:  MOVWF  FE9
114A:  MOVF   x19,W
114C:  ADDWFC x26,W
114E:  MOVWF  FEA
1150:  MOVFF  FEF,927
1154:  MOVLW  0B
1156:  SUBWF  x1A,W
1158:  MOVWF  x28
115A:  MOVLW  00
115C:  SUBWFB x1B,W
115E:  MOVWF  x29
1160:  MOVF   x18,W
1162:  ADDWF  x28,W
1164:  MOVWF  FE9
1166:  MOVF   x19,W
1168:  ADDWFC x29,W
116A:  MOVWF  FEA
116C:  MOVFF  FEF,92A
1170:  MOVLW  0A
1172:  SUBWF  x1A,W
1174:  MOVWF  x2B
1176:  MOVLW  00
1178:  SUBWFB x1B,W
117A:  MOVWF  x2C
117C:  MOVF   x18,W
117E:  ADDWF  x2B,W
1180:  MOVWF  FE9
1182:  MOVF   x19,W
1184:  ADDWFC x2C,W
1186:  MOVWF  FEA
1188:  MOVFF  FEF,92D
118C:  MOVLW  09
118E:  SUBWF  x1A,W
1190:  MOVWF  x2E
1192:  MOVLW  00
1194:  SUBWFB x1B,W
1196:  MOVWF  x2F
1198:  MOVF   x18,W
119A:  ADDWF  x2E,W
119C:  MOVWF  FE9
119E:  MOVF   x19,W
11A0:  ADDWFC x2F,W
11A2:  MOVWF  FEA
11A4:  MOVFF  FEF,930
11A8:  MOVLW  08
11AA:  SUBWF  x1A,W
11AC:  MOVWF  x31
11AE:  MOVLW  00
11B0:  SUBWFB x1B,W
11B2:  MOVWF  x32
11B4:  MOVF   x18,W
11B6:  ADDWF  x31,W
11B8:  MOVWF  FE9
11BA:  MOVF   x19,W
11BC:  ADDWFC x32,W
11BE:  MOVWF  FEA
11C0:  MOVFF  FEF,933
11C4:  MOVLW  07
11C6:  SUBWF  x1A,W
11C8:  MOVWF  x34
11CA:  MOVLW  00
11CC:  SUBWFB x1B,W
11CE:  MOVWF  x35
11D0:  MOVF   x18,W
11D2:  ADDWF  x34,W
11D4:  MOVWF  FE9
11D6:  MOVF   x19,W
11D8:  ADDWFC x35,W
11DA:  MOVWF  FEA
11DC:  MOVFF  FEF,936
11E0:  CLRF   x37
11E2:  MOVFF  924,938
11E6:  MOVFF  927,939
11EA:  MOVFF  92A,93A
11EE:  MOVFF  92D,93B
11F2:  MOVFF  930,93C
11F6:  MOVFF  933,93D
11FA:  MOVFF  936,93E
11FE:  MOVLB  0
1200:  CALL   06C8
1204:  MOVFF  01,91F
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
1208:  MOVLB  9
120A:  MOVF   x1E,W
120C:  SUBLW  45
120E:  BTFSS  FD8.2
1210:  BRA    138A
1212:  MOVF   x1F,W
1214:  SUBLW  7C
1216:  BTFSC  FD8.2
1218:  BRA    138A
121A:  MOVF   x1F,W
121C:  SUBLW  3E
121E:  BTFSC  FD8.2
1220:  BRA    138A
1222:  MOVF   x1F,W
1224:  SUBLW  1F
1226:  BTFSC  FD8.2
1228:  BRA    138A
122A:  MOVF   x1F,W
122C:  SUBLW  0F
122E:  BTFSC  FD8.2
1230:  BRA    138A
1232:  MOVF   x1F,W
1234:  SUBLW  78
1236:  BTFSC  FD8.2
1238:  BRA    138A
....................          { 
....................             j=i; 
123A:  MOVFF  91B,91D
123E:  MOVFF  91A,91C
....................             CRC=1; 
1242:  MOVLW  01
1244:  MOVWF  x21
....................             temp2=temp; 
1246:  MOVFF  91E,920
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
124A:  MOVF   x20,W
124C:  SUBLW  1F
124E:  BTFSC  FD8.2
1250:  BRA    136A
1252:  MOVF   x1D,F
1254:  BNZ   125E
1256:  MOVF   x1C,W
1258:  SUBLW  01
125A:  BTFSC  FD8.0
125C:  BRA    136A
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
125E:  MOVLW  01
1260:  MOVWF  x22
1262:  MOVFF  91D,924
1266:  MOVFF  91C,923
126A:  MOVFF  919,926
126E:  MOVFF  918,925
1272:  MOVLB  0
1274:  CALL   072E
1278:  MOVF   01,W
127A:  MOVLB  9
127C:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
127E:  MOVLW  06
1280:  SUBWF  x1C,W
1282:  MOVWF  x22
1284:  MOVLW  00
1286:  SUBWFB x1D,W
1288:  MOVWF  x23
128A:  MOVF   x18,W
128C:  ADDWF  x22,W
128E:  MOVWF  FE9
1290:  MOVF   x19,W
1292:  ADDWFC x23,W
1294:  MOVWF  FEA
1296:  MOVFF  FEF,924
129A:  MOVLW  05
129C:  SUBWF  x1C,W
129E:  MOVWF  x25
12A0:  MOVLW  00
12A2:  SUBWFB x1D,W
12A4:  MOVWF  x26
12A6:  MOVF   x18,W
12A8:  ADDWF  x25,W
12AA:  MOVWF  FE9
12AC:  MOVF   x19,W
12AE:  ADDWFC x26,W
12B0:  MOVWF  FEA
12B2:  MOVFF  FEF,927
12B6:  MOVLW  04
12B8:  SUBWF  x1C,W
12BA:  MOVWF  x28
12BC:  MOVLW  00
12BE:  SUBWFB x1D,W
12C0:  MOVWF  x29
12C2:  MOVF   x18,W
12C4:  ADDWF  x28,W
12C6:  MOVWF  FE9
12C8:  MOVF   x19,W
12CA:  ADDWFC x29,W
12CC:  MOVWF  FEA
12CE:  MOVFF  FEF,92A
12D2:  MOVLW  03
12D4:  SUBWF  x1C,W
12D6:  MOVWF  x2B
12D8:  MOVLW  00
12DA:  SUBWFB x1D,W
12DC:  MOVWF  x2C
12DE:  MOVF   x18,W
12E0:  ADDWF  x2B,W
12E2:  MOVWF  FE9
12E4:  MOVF   x19,W
12E6:  ADDWFC x2C,W
12E8:  MOVWF  FEA
12EA:  MOVFF  FEF,92D
12EE:  MOVLW  02
12F0:  SUBWF  x1C,W
12F2:  MOVWF  x2E
12F4:  MOVLW  00
12F6:  SUBWFB x1D,W
12F8:  MOVWF  x2F
12FA:  MOVF   x18,W
12FC:  ADDWF  x2E,W
12FE:  MOVWF  FE9
1300:  MOVF   x19,W
1302:  ADDWFC x2F,W
1304:  MOVWF  FEA
1306:  MOVFF  FEF,930
130A:  MOVLW  01
130C:  SUBWF  x1C,W
130E:  MOVWF  x31
1310:  MOVLW  00
1312:  SUBWFB x1D,W
1314:  MOVWF  x32
1316:  MOVF   x18,W
1318:  ADDWF  x31,W
131A:  MOVWF  FE9
131C:  MOVF   x19,W
131E:  ADDWFC x32,W
1320:  MOVWF  FEA
1322:  MOVFF  FEF,933
1326:  MOVF   x18,W
1328:  ADDWF  x1C,W
132A:  MOVWF  FE9
132C:  MOVF   x19,W
132E:  ADDWFC x1D,W
1330:  MOVWF  FEA
1332:  MOVFF  FEF,934
1336:  CLRF   x37
1338:  MOVFF  924,938
133C:  MOVFF  927,939
1340:  MOVFF  92A,93A
1344:  MOVFF  92D,93B
1348:  MOVFF  930,93C
134C:  MOVFF  933,93D
1350:  MOVFF  934,93E
1354:  MOVLB  0
1356:  CALL   06C8
135A:  MOVFF  01,920
....................                j=j-7;             
135E:  MOVLW  07
1360:  MOVLB  9
1362:  SUBWF  x1C,F
1364:  MOVLW  00
1366:  SUBWFB x1D,F
....................              } 
1368:  BRA    124A
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
136A:  DECFSZ x21,W
136C:  BRA    1382
....................             { 
....................                dir=1; 
136E:  MOVLW  01
1370:  MOVLB  6
1372:  MOVWF  xC8
....................                return i; 
1374:  MOVLB  9
1376:  MOVFF  91A,01
137A:  MOVFF  91B,02
137E:  BRA    161C
....................             } 
....................             else return 0; 
1380:  BRA    138A
1382:  MOVLW  00
1384:  MOVWF  01
1386:  MOVWF  02
1388:  BRA    161C
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
138A:  BRA    160C
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
138C:  MOVLW  04
138E:  SUBWF  x1A,W
1390:  MOVWF  x22
1392:  MOVLW  00
1394:  SUBWFB x1B,W
1396:  MOVWF  x23
1398:  MOVF   x18,W
139A:  ADDWF  x22,W
139C:  MOVWF  FE9
139E:  MOVF   x19,W
13A0:  ADDWFC x23,W
13A2:  MOVWF  FEA
13A4:  MOVFF  FEF,924
13A8:  MOVLW  03
13AA:  SUBWF  x1A,W
13AC:  MOVWF  x25
13AE:  MOVLW  00
13B0:  SUBWFB x1B,W
13B2:  MOVWF  x26
13B4:  MOVF   x18,W
13B6:  ADDWF  x25,W
13B8:  MOVWF  FE9
13BA:  MOVF   x19,W
13BC:  ADDWFC x26,W
13BE:  MOVWF  FEA
13C0:  MOVFF  FEF,927
13C4:  MOVLW  02
13C6:  SUBWF  x1A,W
13C8:  MOVWF  x28
13CA:  MOVLW  00
13CC:  SUBWFB x1B,W
13CE:  MOVWF  x29
13D0:  MOVF   x18,W
13D2:  ADDWF  x28,W
13D4:  MOVWF  FE9
13D6:  MOVF   x19,W
13D8:  ADDWFC x29,W
13DA:  MOVWF  FEA
13DC:  MOVFF  FEF,92A
13E0:  MOVLW  01
13E2:  SUBWF  x1A,W
13E4:  MOVWF  x2B
13E6:  MOVLW  00
13E8:  SUBWFB x1B,W
13EA:  MOVWF  x2C
13EC:  MOVF   x18,W
13EE:  ADDWF  x2B,W
13F0:  MOVWF  FE9
13F2:  MOVF   x19,W
13F4:  ADDWFC x2C,W
13F6:  MOVWF  FEA
13F8:  MOVFF  FEF,92D
13FC:  MOVF   x18,W
13FE:  ADDWF  x1A,W
1400:  MOVWF  FE9
1402:  MOVF   x19,W
1404:  ADDWFC x1B,W
1406:  MOVWF  FEA
1408:  MOVFF  FEF,92E
140C:  CLRF   x37
140E:  CLRF   x38
1410:  CLRF   x39
1412:  MOVFF  924,93A
1416:  MOVFF  927,93B
141A:  MOVFF  92A,93C
141E:  MOVFF  92D,93D
1422:  MOVFF  92E,93E
1426:  MOVLB  0
1428:  CALL   06C8
142C:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1430:  MOVLW  09
1432:  MOVLB  9
1434:  SUBWF  x1A,W
1436:  MOVWF  x22
1438:  MOVLW  00
143A:  SUBWFB x1B,W
143C:  MOVWF  x23
143E:  MOVF   x18,W
1440:  ADDWF  x22,W
1442:  MOVWF  FE9
1444:  MOVF   x19,W
1446:  ADDWFC x23,W
1448:  MOVWF  FEA
144A:  MOVFF  FEF,924
144E:  MOVLW  08
1450:  SUBWF  x1A,W
1452:  MOVWF  x25
1454:  MOVLW  00
1456:  SUBWFB x1B,W
1458:  MOVWF  x26
145A:  MOVF   x18,W
145C:  ADDWF  x25,W
145E:  MOVWF  FE9
1460:  MOVF   x19,W
1462:  ADDWFC x26,W
1464:  MOVWF  FEA
1466:  MOVFF  FEF,927
146A:  MOVLW  07
146C:  SUBWF  x1A,W
146E:  MOVWF  x28
1470:  MOVLW  00
1472:  SUBWFB x1B,W
1474:  MOVWF  x29
1476:  MOVF   x18,W
1478:  ADDWF  x28,W
147A:  MOVWF  FE9
147C:  MOVF   x19,W
147E:  ADDWFC x29,W
1480:  MOVWF  FEA
1482:  MOVFF  FEF,92A
1486:  MOVLW  06
1488:  SUBWF  x1A,W
148A:  MOVWF  x2B
148C:  MOVLW  00
148E:  SUBWFB x1B,W
1490:  MOVWF  x2C
1492:  MOVF   x18,W
1494:  ADDWF  x2B,W
1496:  MOVWF  FE9
1498:  MOVF   x19,W
149A:  ADDWFC x2C,W
149C:  MOVWF  FEA
149E:  MOVFF  FEF,92D
14A2:  MOVLW  05
14A4:  SUBWF  x1A,W
14A6:  MOVWF  x2E
14A8:  MOVLW  00
14AA:  SUBWFB x1B,W
14AC:  MOVWF  x2F
14AE:  MOVF   x18,W
14B0:  ADDWF  x2E,W
14B2:  MOVWF  FE9
14B4:  MOVF   x19,W
14B6:  ADDWFC x2F,W
14B8:  MOVWF  FEA
14BA:  MOVFF  FEF,930
14BE:  CLRF   x37
14C0:  CLRF   x38
14C2:  CLRF   x39
14C4:  MOVFF  924,93A
14C8:  MOVFF  927,93B
14CC:  MOVFF  92A,93C
14D0:  MOVFF  92D,93D
14D4:  MOVFF  930,93E
14D8:  MOVLB  0
14DA:  CALL   06C8
14DE:  MOVFF  01,91F
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
14E2:  MOVLB  9
14E4:  MOVF   x1E,W
14E6:  SUBLW  0B
14E8:  BTFSS  FD8.2
14EA:  BRA    160C
14EC:  MOVF   x1F,W
14EE:  SUBLW  1F
14F0:  BTFSC  FD8.2
14F2:  BRA    160C
14F4:  MOVF   x1F,W
14F6:  SUBLW  0F
14F8:  BTFSC  FD8.2
14FA:  BRA    160C
....................             { 
....................                j=i; 
14FC:  MOVFF  91B,91D
1500:  MOVFF  91A,91C
....................                CRC=1; 
1504:  MOVLW  01
1506:  MOVWF  x21
....................                temp2=temp; 
1508:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
150C:  MOVF   x20,W
150E:  SUBLW  1F
1510:  BZ    15EC
1512:  MOVF   x1D,F
1514:  BNZ   151C
1516:  MOVF   x1C,W
1518:  SUBLW  01
151A:  BC    15EC
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
151C:  MOVLW  01
151E:  MOVWF  x22
1520:  MOVFF  91D,924
1524:  MOVFF  91C,923
1528:  MOVFF  919,926
152C:  MOVFF  918,925
1530:  MOVLB  0
1532:  CALL   08DE
1536:  MOVF   01,W
1538:  MOVLB  9
153A:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
153C:  MOVLW  04
153E:  SUBWF  x1C,W
1540:  MOVWF  x22
1542:  MOVLW  00
1544:  SUBWFB x1D,W
1546:  MOVWF  x23
1548:  MOVF   x18,W
154A:  ADDWF  x22,W
154C:  MOVWF  FE9
154E:  MOVF   x19,W
1550:  ADDWFC x23,W
1552:  MOVWF  FEA
1554:  MOVFF  FEF,924
1558:  MOVLW  03
155A:  SUBWF  x1C,W
155C:  MOVWF  x25
155E:  MOVLW  00
1560:  SUBWFB x1D,W
1562:  MOVWF  x26
1564:  MOVF   x18,W
1566:  ADDWF  x25,W
1568:  MOVWF  FE9
156A:  MOVF   x19,W
156C:  ADDWFC x26,W
156E:  MOVWF  FEA
1570:  MOVFF  FEF,927
1574:  MOVLW  02
1576:  SUBWF  x1C,W
1578:  MOVWF  x28
157A:  MOVLW  00
157C:  SUBWFB x1D,W
157E:  MOVWF  x29
1580:  MOVF   x18,W
1582:  ADDWF  x28,W
1584:  MOVWF  FE9
1586:  MOVF   x19,W
1588:  ADDWFC x29,W
158A:  MOVWF  FEA
158C:  MOVFF  FEF,92A
1590:  MOVLW  01
1592:  SUBWF  x1C,W
1594:  MOVWF  x2B
1596:  MOVLW  00
1598:  SUBWFB x1D,W
159A:  MOVWF  x2C
159C:  MOVF   x18,W
159E:  ADDWF  x2B,W
15A0:  MOVWF  FE9
15A2:  MOVF   x19,W
15A4:  ADDWFC x2C,W
15A6:  MOVWF  FEA
15A8:  MOVFF  FEF,92D
15AC:  MOVF   x18,W
15AE:  ADDWF  x1C,W
15B0:  MOVWF  FE9
15B2:  MOVF   x19,W
15B4:  ADDWFC x1D,W
15B6:  MOVWF  FEA
15B8:  MOVFF  FEF,92E
15BC:  CLRF   x37
15BE:  CLRF   x38
15C0:  CLRF   x39
15C2:  MOVFF  924,93A
15C6:  MOVFF  927,93B
15CA:  MOVFF  92A,93C
15CE:  MOVFF  92D,93D
15D2:  MOVFF  92E,93E
15D6:  MOVLB  0
15D8:  CALL   06C8
15DC:  MOVFF  01,920
....................                   j=j-5; 
15E0:  MOVLW  05
15E2:  MOVLB  9
15E4:  SUBWF  x1C,F
15E6:  MOVLW  00
15E8:  SUBWFB x1D,F
....................                } 
15EA:  BRA    150C
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
15EC:  DECFSZ x21,W
15EE:  BRA    1604
....................                { 
....................                   dir=1; 
15F0:  MOVLW  01
15F2:  MOVLB  6
15F4:  MOVWF  xC8
....................                   return i; 
15F6:  MOVLB  9
15F8:  MOVFF  91A,01
15FC:  MOVFF  91B,02
1600:  BRA    161C
....................                } 
....................                   else return 0; 
1602:  BRA    160C
1604:  MOVLW  00
1606:  MOVWF  01
1608:  MOVWF  02
160A:  BRA    161C
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
160C:  MOVF   x1A,W
160E:  BTFSC  FD8.2
1610:  DECF   x1B,F
1612:  DECF   x1A,F
1614:  BRA    100E
....................    return 0; 
1616:  MOVLW  00
1618:  MOVWF  01
161A:  MOVWF  02
.................... } 
161C:  MOVLB  0
161E:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
35C8:  MOVLB  9
35CA:  CLRF   x02
35CC:  MOVLW  01
35CE:  MOVWF  x01
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
35D0:  MOVFF  8F7,915
35D4:  MOVFF  8F9,917
35D8:  MOVFF  8F8,916
35DC:  MOVFF  8FB,919
35E0:  MOVFF  8FA,918
35E4:  MOVLB  0
35E6:  CALL   0A1E
35EA:  MOVFF  02,902
35EE:  MOVFF  01,901
....................    if(temp==0) return 0; 
35F2:  MOVLB  9
35F4:  MOVF   x01,F
35F6:  BNZ   3602
35F8:  MOVF   x02,F
35FA:  BNZ   3602
35FC:  MOVLW  00
35FE:  MOVWF  01
3600:  BRA    3A7C
....................    j=temp; 
3602:  MOVFF  902,900
3606:  MOVFF  901,8FF
....................    if(dir==0) 
360A:  MOVLB  6
360C:  MOVF   xC8,F
360E:  BTFSS  FD8.2
3610:  BRA    383E
....................    { 
....................       if(track==0) 
3612:  MOVLB  8
3614:  MOVF   xF7,F
3616:  BTFSS  FD8.2
3618:  BRA    3756
....................       { 
....................             for(i=0;i<79;i++) 
361A:  CLRF   xFE
361C:  MOVF   xFE,W
361E:  SUBLW  4E
3620:  BTFSS  FD8.0
3622:  BRA    3754
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3624:  CLRF   03
3626:  MOVF   xFE,W
3628:  ADDWF  xFC,W
362A:  MOVWF  01
362C:  MOVF   xFD,W
362E:  ADDWFC 03,F
3630:  MOVFF  01,903
3634:  MOVFF  03,904
3638:  MOVLW  05
363A:  MOVLB  8
363C:  ADDWF  xFF,W
363E:  MOVLB  9
3640:  MOVWF  x05
3642:  MOVLW  00
3644:  ADDWFC x00,W
3646:  MOVWF  x06
3648:  MOVLB  8
364A:  MOVF   xFA,W
364C:  MOVLB  9
364E:  ADDWF  x05,W
3650:  MOVWF  FE9
3652:  MOVLB  8
3654:  MOVF   xFB,W
3656:  MOVLB  9
3658:  ADDWFC x06,W
365A:  MOVWF  FEA
365C:  MOVFF  FEF,907
3660:  MOVLW  04
3662:  MOVLB  8
3664:  ADDWF  xFF,W
3666:  MOVLB  9
3668:  MOVWF  x08
366A:  MOVLW  00
366C:  ADDWFC x00,W
366E:  MOVWF  x09
3670:  MOVLB  8
3672:  MOVF   xFA,W
3674:  MOVLB  9
3676:  ADDWF  x08,W
3678:  MOVWF  FE9
367A:  MOVLB  8
367C:  MOVF   xFB,W
367E:  MOVLB  9
3680:  ADDWFC x09,W
3682:  MOVWF  FEA
3684:  MOVFF  FEF,90A
3688:  MOVLW  03
368A:  MOVLB  8
368C:  ADDWF  xFF,W
368E:  MOVLB  9
3690:  MOVWF  x0B
3692:  MOVLW  00
3694:  ADDWFC x00,W
3696:  MOVWF  x0C
3698:  MOVLB  8
369A:  MOVF   xFA,W
369C:  MOVLB  9
369E:  ADDWF  x0B,W
36A0:  MOVWF  FE9
36A2:  MOVLB  8
36A4:  MOVF   xFB,W
36A6:  MOVLB  9
36A8:  ADDWFC x0C,W
36AA:  MOVWF  FEA
36AC:  MOVFF  FEF,90D
36B0:  MOVLW  02
36B2:  MOVLB  8
36B4:  ADDWF  xFF,W
36B6:  MOVLB  9
36B8:  MOVWF  x0E
36BA:  MOVLW  00
36BC:  ADDWFC x00,W
36BE:  MOVWF  x0F
36C0:  MOVLB  8
36C2:  MOVF   xFA,W
36C4:  MOVLB  9
36C6:  ADDWF  x0E,W
36C8:  MOVWF  FE9
36CA:  MOVLB  8
36CC:  MOVF   xFB,W
36CE:  MOVLB  9
36D0:  ADDWFC x0F,W
36D2:  MOVWF  FEA
36D4:  MOVFF  FEF,910
36D8:  MOVLW  01
36DA:  MOVLB  8
36DC:  ADDWF  xFF,W
36DE:  MOVLB  9
36E0:  MOVWF  x11
36E2:  MOVLW  00
36E4:  ADDWFC x00,W
36E6:  MOVWF  x12
36E8:  MOVLB  8
36EA:  MOVF   xFA,W
36EC:  MOVLB  9
36EE:  ADDWF  x11,W
36F0:  MOVWF  FE9
36F2:  MOVLB  8
36F4:  MOVF   xFB,W
36F6:  MOVLB  9
36F8:  ADDWFC x12,W
36FA:  MOVWF  FEA
36FC:  MOVFF  FEF,913
3700:  MOVLB  8
3702:  MOVF   xFA,W
3704:  ADDWF  xFF,W
3706:  MOVWF  FE9
3708:  MOVF   xFB,W
370A:  MOVLB  9
370C:  ADDWFC x00,W
370E:  MOVWF  FEA
3710:  MOVFF  FEF,914
3714:  CLRF   x37
3716:  CLRF   x38
3718:  MOVFF  907,939
371C:  MOVFF  90A,93A
3720:  MOVFF  90D,93B
3724:  MOVFF  910,93C
3728:  MOVFF  913,93D
372C:  MOVFF  914,93E
3730:  MOVLB  0
3732:  CALL   06C8
3736:  MOVFF  904,FEA
373A:  MOVFF  903,FE9
373E:  MOVFF  01,FEF
....................                j=j+7; 
3742:  MOVLW  07
3744:  MOVLB  8
3746:  ADDWF  xFF,F
3748:  MOVLW  00
374A:  MOVLB  9
374C:  ADDWFC x00,F
....................             } 
374E:  MOVLB  8
3750:  INCF   xFE,F
3752:  BRA    361C
....................       } 
....................          else  
3754:  BRA    383A
....................          { 
....................             for(i=0;i<40;i++) 
3756:  CLRF   xFE
3758:  MOVF   xFE,W
375A:  SUBLW  27
375C:  BNC   383A
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
375E:  CLRF   03
3760:  MOVF   xFE,W
3762:  ADDWF  xFC,W
3764:  MOVWF  01
3766:  MOVF   xFD,W
3768:  ADDWFC 03,F
376A:  MOVFF  01,903
376E:  MOVFF  03,904
3772:  MOVLW  03
3774:  MOVLB  8
3776:  ADDWF  xFF,W
3778:  MOVLB  9
377A:  MOVWF  x05
377C:  MOVLW  00
377E:  ADDWFC x00,W
3780:  MOVWF  x06
3782:  MOVLB  8
3784:  MOVF   xFA,W
3786:  MOVLB  9
3788:  ADDWF  x05,W
378A:  MOVWF  FE9
378C:  MOVLB  8
378E:  MOVF   xFB,W
3790:  MOVLB  9
3792:  ADDWFC x06,W
3794:  MOVWF  FEA
3796:  MOVFF  FEF,907
379A:  MOVLW  02
379C:  MOVLB  8
379E:  ADDWF  xFF,W
37A0:  MOVLB  9
37A2:  MOVWF  x08
37A4:  MOVLW  00
37A6:  ADDWFC x00,W
37A8:  MOVWF  x09
37AA:  MOVLB  8
37AC:  MOVF   xFA,W
37AE:  MOVLB  9
37B0:  ADDWF  x08,W
37B2:  MOVWF  FE9
37B4:  MOVLB  8
37B6:  MOVF   xFB,W
37B8:  MOVLB  9
37BA:  ADDWFC x09,W
37BC:  MOVWF  FEA
37BE:  MOVFF  FEF,90A
37C2:  MOVLW  01
37C4:  MOVLB  8
37C6:  ADDWF  xFF,W
37C8:  MOVLB  9
37CA:  MOVWF  x0B
37CC:  MOVLW  00
37CE:  ADDWFC x00,W
37D0:  MOVWF  x0C
37D2:  MOVLB  8
37D4:  MOVF   xFA,W
37D6:  MOVLB  9
37D8:  ADDWF  x0B,W
37DA:  MOVWF  FE9
37DC:  MOVLB  8
37DE:  MOVF   xFB,W
37E0:  MOVLB  9
37E2:  ADDWFC x0C,W
37E4:  MOVWF  FEA
37E6:  MOVFF  FEF,90D
37EA:  MOVLB  8
37EC:  MOVF   xFA,W
37EE:  ADDWF  xFF,W
37F0:  MOVWF  FE9
37F2:  MOVF   xFB,W
37F4:  MOVLB  9
37F6:  ADDWFC x00,W
37F8:  MOVWF  FEA
37FA:  MOVFF  FEF,90E
37FE:  CLRF   x37
3800:  CLRF   x38
3802:  CLRF   x39
3804:  CLRF   x3A
3806:  MOVFF  907,93B
380A:  MOVFF  90A,93C
380E:  MOVFF  90D,93D
3812:  MOVFF  90E,93E
3816:  MOVLB  0
3818:  CALL   06C8
381C:  MOVFF  904,FEA
3820:  MOVFF  903,FE9
3824:  MOVFF  01,FEF
....................                j=j+5; 
3828:  MOVLW  05
382A:  MOVLB  8
382C:  ADDWF  xFF,F
382E:  MOVLW  00
3830:  MOVLB  9
3832:  ADDWFC x00,F
....................             }          
3834:  MOVLB  8
3836:  INCF   xFE,F
3838:  BRA    3758
....................          } 
....................    } 
....................       else  
383A:  BRA    3A66
383C:  MOVLB  6
....................       { 
....................          if(track==0) 
383E:  MOVLB  8
3840:  MOVF   xF7,F
3842:  BTFSS  FD8.2
3844:  BRA    3982
....................          { 
....................             for(i=0;i<79;i++) 
3846:  CLRF   xFE
3848:  MOVF   xFE,W
384A:  SUBLW  4E
384C:  BTFSS  FD8.0
384E:  BRA    3980
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3850:  CLRF   03
3852:  MOVF   xFE,W
3854:  ADDWF  xFC,W
3856:  MOVWF  01
3858:  MOVF   xFD,W
385A:  ADDWFC 03,F
385C:  MOVFF  01,903
3860:  MOVFF  03,904
3864:  MOVLW  05
3866:  MOVLB  8
3868:  SUBWF  xFF,W
386A:  MOVLB  9
386C:  MOVWF  x05
386E:  MOVLW  00
3870:  SUBWFB x00,W
3872:  MOVWF  x06
3874:  MOVLB  8
3876:  MOVF   xFA,W
3878:  MOVLB  9
387A:  ADDWF  x05,W
387C:  MOVWF  FE9
387E:  MOVLB  8
3880:  MOVF   xFB,W
3882:  MOVLB  9
3884:  ADDWFC x06,W
3886:  MOVWF  FEA
3888:  MOVFF  FEF,907
388C:  MOVLW  04
388E:  MOVLB  8
3890:  SUBWF  xFF,W
3892:  MOVLB  9
3894:  MOVWF  x08
3896:  MOVLW  00
3898:  SUBWFB x00,W
389A:  MOVWF  x09
389C:  MOVLB  8
389E:  MOVF   xFA,W
38A0:  MOVLB  9
38A2:  ADDWF  x08,W
38A4:  MOVWF  FE9
38A6:  MOVLB  8
38A8:  MOVF   xFB,W
38AA:  MOVLB  9
38AC:  ADDWFC x09,W
38AE:  MOVWF  FEA
38B0:  MOVFF  FEF,90A
38B4:  MOVLW  03
38B6:  MOVLB  8
38B8:  SUBWF  xFF,W
38BA:  MOVLB  9
38BC:  MOVWF  x0B
38BE:  MOVLW  00
38C0:  SUBWFB x00,W
38C2:  MOVWF  x0C
38C4:  MOVLB  8
38C6:  MOVF   xFA,W
38C8:  MOVLB  9
38CA:  ADDWF  x0B,W
38CC:  MOVWF  FE9
38CE:  MOVLB  8
38D0:  MOVF   xFB,W
38D2:  MOVLB  9
38D4:  ADDWFC x0C,W
38D6:  MOVWF  FEA
38D8:  MOVFF  FEF,90D
38DC:  MOVLW  02
38DE:  MOVLB  8
38E0:  SUBWF  xFF,W
38E2:  MOVLB  9
38E4:  MOVWF  x0E
38E6:  MOVLW  00
38E8:  SUBWFB x00,W
38EA:  MOVWF  x0F
38EC:  MOVLB  8
38EE:  MOVF   xFA,W
38F0:  MOVLB  9
38F2:  ADDWF  x0E,W
38F4:  MOVWF  FE9
38F6:  MOVLB  8
38F8:  MOVF   xFB,W
38FA:  MOVLB  9
38FC:  ADDWFC x0F,W
38FE:  MOVWF  FEA
3900:  MOVFF  FEF,910
3904:  MOVLW  01
3906:  MOVLB  8
3908:  SUBWF  xFF,W
390A:  MOVLB  9
390C:  MOVWF  x11
390E:  MOVLW  00
3910:  SUBWFB x00,W
3912:  MOVWF  x12
3914:  MOVLB  8
3916:  MOVF   xFA,W
3918:  MOVLB  9
391A:  ADDWF  x11,W
391C:  MOVWF  FE9
391E:  MOVLB  8
3920:  MOVF   xFB,W
3922:  MOVLB  9
3924:  ADDWFC x12,W
3926:  MOVWF  FEA
3928:  MOVFF  FEF,913
392C:  MOVLB  8
392E:  MOVF   xFA,W
3930:  ADDWF  xFF,W
3932:  MOVWF  FE9
3934:  MOVF   xFB,W
3936:  MOVLB  9
3938:  ADDWFC x00,W
393A:  MOVWF  FEA
393C:  MOVFF  FEF,914
3940:  CLRF   x37
3942:  CLRF   x38
3944:  MOVFF  907,939
3948:  MOVFF  90A,93A
394C:  MOVFF  90D,93B
3950:  MOVFF  910,93C
3954:  MOVFF  913,93D
3958:  MOVFF  914,93E
395C:  MOVLB  0
395E:  CALL   06C8
3962:  MOVFF  904,FEA
3966:  MOVFF  903,FE9
396A:  MOVFF  01,FEF
....................                j=j-7; 
396E:  MOVLW  07
3970:  MOVLB  8
3972:  SUBWF  xFF,F
3974:  MOVLW  00
3976:  MOVLB  9
3978:  SUBWFB x00,F
....................             } 
397A:  MOVLB  8
397C:  INCF   xFE,F
397E:  BRA    3848
....................          } 
....................             else 
3980:  BRA    3A66
....................             { 
....................                for(i=0;i<40;i++) 
3982:  CLRF   xFE
3984:  MOVF   xFE,W
3986:  SUBLW  27
3988:  BNC   3A66
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
398A:  CLRF   03
398C:  MOVF   xFE,W
398E:  ADDWF  xFC,W
3990:  MOVWF  01
3992:  MOVF   xFD,W
3994:  ADDWFC 03,F
3996:  MOVFF  01,903
399A:  MOVFF  03,904
399E:  MOVLW  03
39A0:  MOVLB  8
39A2:  SUBWF  xFF,W
39A4:  MOVLB  9
39A6:  MOVWF  x05
39A8:  MOVLW  00
39AA:  SUBWFB x00,W
39AC:  MOVWF  x06
39AE:  MOVLB  8
39B0:  MOVF   xFA,W
39B2:  MOVLB  9
39B4:  ADDWF  x05,W
39B6:  MOVWF  FE9
39B8:  MOVLB  8
39BA:  MOVF   xFB,W
39BC:  MOVLB  9
39BE:  ADDWFC x06,W
39C0:  MOVWF  FEA
39C2:  MOVFF  FEF,907
39C6:  MOVLW  02
39C8:  MOVLB  8
39CA:  SUBWF  xFF,W
39CC:  MOVLB  9
39CE:  MOVWF  x08
39D0:  MOVLW  00
39D2:  SUBWFB x00,W
39D4:  MOVWF  x09
39D6:  MOVLB  8
39D8:  MOVF   xFA,W
39DA:  MOVLB  9
39DC:  ADDWF  x08,W
39DE:  MOVWF  FE9
39E0:  MOVLB  8
39E2:  MOVF   xFB,W
39E4:  MOVLB  9
39E6:  ADDWFC x09,W
39E8:  MOVWF  FEA
39EA:  MOVFF  FEF,90A
39EE:  MOVLW  01
39F0:  MOVLB  8
39F2:  SUBWF  xFF,W
39F4:  MOVLB  9
39F6:  MOVWF  x0B
39F8:  MOVLW  00
39FA:  SUBWFB x00,W
39FC:  MOVWF  x0C
39FE:  MOVLB  8
3A00:  MOVF   xFA,W
3A02:  MOVLB  9
3A04:  ADDWF  x0B,W
3A06:  MOVWF  FE9
3A08:  MOVLB  8
3A0A:  MOVF   xFB,W
3A0C:  MOVLB  9
3A0E:  ADDWFC x0C,W
3A10:  MOVWF  FEA
3A12:  MOVFF  FEF,90D
3A16:  MOVLB  8
3A18:  MOVF   xFA,W
3A1A:  ADDWF  xFF,W
3A1C:  MOVWF  FE9
3A1E:  MOVF   xFB,W
3A20:  MOVLB  9
3A22:  ADDWFC x00,W
3A24:  MOVWF  FEA
3A26:  MOVFF  FEF,90E
3A2A:  CLRF   x37
3A2C:  CLRF   x38
3A2E:  CLRF   x39
3A30:  CLRF   x3A
3A32:  MOVFF  907,93B
3A36:  MOVFF  90A,93C
3A3A:  MOVFF  90D,93D
3A3E:  MOVFF  90E,93E
3A42:  MOVLB  0
3A44:  CALL   06C8
3A48:  MOVFF  904,FEA
3A4C:  MOVFF  903,FE9
3A50:  MOVFF  01,FEF
....................                   j=j-5; 
3A54:  MOVLW  05
3A56:  MOVLB  8
3A58:  SUBWF  xFF,F
3A5A:  MOVLW  00
3A5C:  MOVLB  9
3A5E:  SUBWFB x00,F
....................                }             
3A60:  MOVLB  8
3A62:  INCF   xFE,F
3A64:  BRA    3984
....................             } 
....................       } 
....................       memset(datin,0,sizeof(datin)); 
3A66:  MOVFF  8FB,FEA
3A6A:  MOVFF  8FA,FE9
3A6E:  CLRF   00
3A70:  CLRF   02
3A72:  MOVLW  02
3A74:  MOVWF  01
3A76:  MOVLB  0
3A78:  RCALL  35AE
3A7A:  MOVLB  9
.................... } 
3A7C:  MOVLB  0
3A7E:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1856:  MOVLW  8E
1858:  MOVWF  FF6
185A:  MOVLW  05
185C:  MOVWF  FF7
185E:  RCALL  174A
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1860:  MOVLB  8
1862:  CLRF   x57
1864:  CLRF   x56
1866:  MOVF   x57,W
1868:  SUBLW  03
186A:  BNC   189A
186C:  BNZ   1874
186E:  MOVF   x56,W
1870:  SUBLW  51
1872:  BNC   189A
1874:  MOVLW  46
1876:  ADDWF  x56,W
1878:  MOVWF  FE9
187A:  MOVLW  02
187C:  ADDWFC x57,W
187E:  MOVWF  FEA
1880:  MOVFF  FEF,858
1884:  MOVFF  858,859
1888:  MOVLW  18
188A:  MOVWF  x5A
188C:  MOVLB  0
188E:  RCALL  1796
1890:  MOVLB  8
1892:  INCF   x56,F
1894:  BTFSC  FD8.2
1896:  INCF   x57,F
1898:  BRA    1866
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
189A:  MOVLW  A4
189C:  MOVWF  FF6
189E:  MOVLW  05
18A0:  MOVWF  FF7
18A2:  MOVLB  0
18A4:  RCALL  174A
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
18A6:  MOVLB  8
18A8:  CLRF   x57
18AA:  CLRF   x56
18AC:  MOVF   x57,W
18AE:  SUBLW  01
18B0:  BNC   18E0
18B2:  BNZ   18BA
18B4:  MOVF   x56,W
18B6:  SUBLW  2B
18B8:  BNC   18E0
18BA:  MOVLW  98
18BC:  ADDWF  x56,W
18BE:  MOVWF  FE9
18C0:  MOVLW  05
18C2:  ADDWFC x57,W
18C4:  MOVWF  FEA
18C6:  MOVFF  FEF,858
18CA:  MOVFF  858,859
18CE:  MOVLW  18
18D0:  MOVWF  x5A
18D2:  MOVLB  0
18D4:  RCALL  1796
18D6:  MOVLB  8
18D8:  INCF   x56,F
18DA:  BTFSC  FD8.2
18DC:  INCF   x57,F
18DE:  BRA    18AC
.................... } 
18E0:  MOVLB  0
18E2:  GOTO   1B70 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3C0C:  MOVLW  01
3C0E:  MOVLB  6
3C10:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3C12:  MOVLB  0
3C14:  RCALL  3534
3C16:  MOVFF  02,854
3C1A:  MOVFF  01,853
3C1E:  MOVFF  02,856
3C22:  MOVFF  01,855
3C26:  MOVLB  8
3C28:  CLRF   x58
3C2A:  MOVLW  7C
3C2C:  MOVWF  x57
3C2E:  MOVLB  0
3C30:  RCALL  358C
3C32:  MOVFF  01,853
3C36:  MOVLW  96
3C38:  MOVLB  8
3C3A:  ADDWF  01,W
3C3C:  MOVWF  01
3C3E:  MOVLW  00
3C40:  ADDWFC 02,W
3C42:  MOVFF  01,20
3C46:  MOVWF  21
3C48:  CLRF   22
3C4A:  CLRF   23
....................    if(datinbuf==0)  
3C4C:  MOVLB  6
3C4E:  MOVF   xD5,F
3C50:  BNZ   3C74
....................    { 
....................       countbit_T1=0; 
3C52:  CLRF   xCA
3C54:  CLRF   xC9
....................       countbit_T2=0; 
3C56:  CLRF   xCC
3C58:  CLRF   xCB
....................       bug_countbit_T1=0; 
3C5A:  CLRF   xCE
3C5C:  CLRF   xCD
....................       bug_countbit_T2=0; 
3C5E:  CLRF   xD0
3C60:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3C62:  MOVF   xD9,F
3C64:  BNZ   3C70
3C66:  MOVLB  1
3C68:  SETF   x00
3C6A:  MOVLB  0
3C6C:  SETF   xFF
3C6E:  MOVLB  6
....................       saving_flag=0; 
3C70:  CLRF   xD8
....................       return; 
3C72:  BRA    4008
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3C74:  MOVLW  BA
3C76:  MOVWF  FF6
3C78:  MOVLW  05
3C7A:  MOVWF  FF7
3C7C:  MOVLB  0
3C7E:  CALL   174A
....................    //key_count=0; 
....................    enable_getpin=1; 
3C82:  MOVLW  01
3C84:  MOVLB  1
3C86:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3C88:  MOVFF  6CA,852
3C8C:  MOVFF  6C9,851
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3C90:  MOVLB  8
3C92:  CLRF   xF7
3C94:  MOVFF  852,8F9
3C98:  MOVFF  851,8F8
3C9C:  MOVLW  02
3C9E:  MOVWF  xFB
3CA0:  MOVLW  46
3CA2:  MOVWF  xFA
3CA4:  MOVLW  01
3CA6:  MOVWF  xFD
3CA8:  MOVLW  CF
3CAA:  MOVWF  xFC
3CAC:  MOVLB  0
3CAE:  RCALL  35C8
....................    countbit_T1=0; 
3CB0:  MOVLB  6
3CB2:  CLRF   xCA
3CB4:  CLRF   xC9
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3CB6:  MOVFF  6CC,852
3CBA:  MOVFF  6CB,851
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3CBE:  MOVLW  01
3CC0:  MOVLB  8
3CC2:  MOVWF  xF7
3CC4:  MOVFF  852,8F9
3CC8:  MOVFF  851,8F8
3CCC:  MOVLW  05
3CCE:  MOVWF  xFB
3CD0:  MOVLW  98
3CD2:  MOVWF  xFA
3CD4:  MOVLW  02
3CD6:  MOVWF  xFD
3CD8:  MOVLW  1E
3CDA:  MOVWF  xFC
3CDC:  MOVLB  0
3CDE:  RCALL  35C8
....................    countbit_T2=0; 
3CE0:  MOVLB  6
3CE2:  CLRF   xCC
3CE4:  CLRF   xCB
....................    saving_flag=0; 
3CE6:  CLRF   xD8
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3CE8:  MOVLW  20
3CEA:  MOVLB  1
3CEC:  ADDWF  xCF,W
3CEE:  MOVLB  8
3CF0:  MOVWF  x50
....................    if((ptr_card<EEPROM_SIZE_stofkey)&&(temp=='%')) 
3CF2:  MOVF   23,F
3CF4:  BTFSS  FD8.2
3CF6:  BRA    4006
3CF8:  MOVF   22,W
3CFA:  SUBLW  01
3CFC:  BTFSS  FD8.0
3CFE:  BRA    4006
3D00:  BNZ   3D14
3D02:  MOVF   21,W
3D04:  SUBLW  C3
3D06:  BTFSS  FD8.0
3D08:  BRA    4006
3D0A:  BNZ   3D14
3D0C:  MOVF   20,W
3D0E:  SUBLW  0D
3D10:  BTFSS  FD8.0
3D12:  BRA    4006
3D14:  MOVF   x50,W
3D16:  SUBLW  25
3D18:  BTFSS  FD8.2
3D1A:  BRA    4006
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3D1C:  MOVFF  23,03
3D20:  MOVFF  22,02
3D24:  MOVFF  21,01
3D28:  MOVFF  20,00
3D2C:  MOVLW  01
3D2E:  ADDWF  20,F
3D30:  BTFSC  FD8.0
3D32:  INCF   21,F
3D34:  BTFSC  FD8.2
3D36:  INCF   22,F
3D38:  BTFSC  FD8.2
3D3A:  INCF   23,F
3D3C:  MOVFF  01,854
3D40:  MOVFF  00,853
3D44:  MOVLB  9
3D46:  CLRF   x16
3D48:  CLRF   x15
3D4A:  MOVFF  01,914
3D4E:  MOVFF  00,913
3D52:  MOVFF  1CB,917
3D56:  MOVLB  0
3D58:  RCALL  3A80
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3D5A:  MOVFF  23,03
3D5E:  MOVFF  22,02
3D62:  MOVFF  21,01
3D66:  MOVFF  20,00
3D6A:  MOVLW  01
3D6C:  ADDWF  20,F
3D6E:  BTFSC  FD8.0
3D70:  INCF   21,F
3D72:  BTFSC  FD8.2
3D74:  INCF   22,F
3D76:  BTFSC  FD8.2
3D78:  INCF   23,F
3D7A:  MOVFF  01,854
3D7E:  MOVFF  00,853
3D82:  MOVLB  9
3D84:  CLRF   x16
3D86:  CLRF   x15
3D88:  MOVFF  01,914
3D8C:  MOVFF  00,913
3D90:  MOVFF  1CA,917
3D94:  MOVLB  0
3D96:  RCALL  3A80
....................          write_ext_eeprom((long int)ptr_card++,h); 
3D98:  MOVFF  23,03
3D9C:  MOVFF  22,02
3DA0:  MOVFF  21,01
3DA4:  MOVFF  20,00
3DA8:  MOVLW  01
3DAA:  ADDWF  20,F
3DAC:  BTFSC  FD8.0
3DAE:  INCF   21,F
3DB0:  BTFSC  FD8.2
3DB2:  INCF   22,F
3DB4:  BTFSC  FD8.2
3DB6:  INCF   23,F
3DB8:  MOVFF  01,854
3DBC:  MOVFF  00,853
3DC0:  MOVLB  9
3DC2:  CLRF   x16
3DC4:  CLRF   x15
3DC6:  MOVFF  01,914
3DCA:  MOVFF  00,913
3DCE:  MOVFF  1CC,917
3DD2:  MOVLB  0
3DD4:  RCALL  3A80
....................          write_ext_eeprom((long int)ptr_card++,min); 
3DD6:  MOVFF  23,03
3DDA:  MOVFF  22,02
3DDE:  MOVFF  21,01
3DE2:  MOVFF  20,00
3DE6:  MOVLW  01
3DE8:  ADDWF  20,F
3DEA:  BTFSC  FD8.0
3DEC:  INCF   21,F
3DEE:  BTFSC  FD8.2
3DF0:  INCF   22,F
3DF2:  BTFSC  FD8.2
3DF4:  INCF   23,F
3DF6:  MOVFF  01,854
3DFA:  MOVFF  00,853
3DFE:  MOVLB  9
3E00:  CLRF   x16
3E02:  CLRF   x15
3E04:  MOVFF  01,914
3E08:  MOVFF  00,913
3E0C:  MOVFF  1CD,917
3E10:  MOVLB  0
3E12:  RCALL  3A80
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3E14:  MOVFF  23,03
3E18:  MOVFF  22,02
3E1C:  MOVFF  21,01
3E20:  MOVFF  20,00
3E24:  MOVLW  01
3E26:  ADDWF  20,F
3E28:  BTFSC  FD8.0
3E2A:  INCF   21,F
3E2C:  BTFSC  FD8.2
3E2E:  INCF   22,F
3E30:  BTFSC  FD8.2
3E32:  INCF   23,F
3E34:  MOVFF  01,854
3E38:  MOVFF  00,853
3E3C:  MOVLB  9
3E3E:  CLRF   x16
3E40:  CLRF   x15
3E42:  MOVFF  01,914
3E46:  MOVFF  00,913
3E4A:  MOVFF  1CE,917
3E4E:  MOVLB  0
3E50:  RCALL  3A80
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3E52:  MOVLB  6
3E54:  CLRF   xD4
3E56:  CLRF   xD3
3E58:  MOVF   xD4,F
3E5A:  BNZ   3EBE
3E5C:  MOVF   xD3,W
3E5E:  SUBLW  4E
3E60:  BNC   3EBE
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3E62:  MOVFF  23,03
3E66:  MOVFF  22,02
3E6A:  MOVFF  21,01
3E6E:  MOVFF  20,00
3E72:  MOVLW  01
3E74:  ADDWF  20,F
3E76:  BTFSC  FD8.0
3E78:  INCF   21,F
3E7A:  BTFSC  FD8.2
3E7C:  INCF   22,F
3E7E:  BTFSC  FD8.2
3E80:  INCF   23,F
3E82:  MOVFF  01,854
3E86:  MOVFF  00,853
3E8A:  MOVLW  CF
3E8C:  ADDWF  xD3,W
3E8E:  MOVWF  FE9
3E90:  MOVLW  01
3E92:  ADDWFC xD4,W
3E94:  MOVWF  FEA
3E96:  MOVF   FEF,W
3E98:  ANDLW  3F
3E9A:  ADDLW  20
3E9C:  MOVLB  8
3E9E:  MOVWF  x55
3EA0:  MOVLB  9
3EA2:  CLRF   x16
3EA4:  CLRF   x15
3EA6:  MOVFF  01,914
3EAA:  MOVFF  00,913
3EAE:  MOVWF  x17
3EB0:  MOVLB  0
3EB2:  RCALL  3A80
....................              
....................          } 
3EB4:  MOVLB  6
3EB6:  INCF   xD3,F
3EB8:  BTFSC  FD8.2
3EBA:  INCF   xD4,F
3EBC:  BRA    3E58
....................          memset(Track1,0,sizeof(Track1)); 
3EBE:  MOVLW  01
3EC0:  MOVWF  FEA
3EC2:  MOVLW  CF
3EC4:  MOVWF  FE9
3EC6:  CLRF   00
3EC8:  CLRF   02
3ECA:  MOVLW  4F
3ECC:  MOVWF  01
3ECE:  MOVLB  0
3ED0:  CALL   35AE
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3ED4:  MOVLB  6
3ED6:  CLRF   xD4
3ED8:  CLRF   xD3
3EDA:  MOVF   xD4,F
3EDC:  BNZ   3F40
3EDE:  MOVF   xD3,W
3EE0:  SUBLW  27
3EE2:  BNC   3F40
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3EE4:  MOVFF  23,03
3EE8:  MOVFF  22,02
3EEC:  MOVFF  21,01
3EF0:  MOVFF  20,00
3EF4:  MOVLW  01
3EF6:  ADDWF  20,F
3EF8:  BTFSC  FD8.0
3EFA:  INCF   21,F
3EFC:  BTFSC  FD8.2
3EFE:  INCF   22,F
3F00:  BTFSC  FD8.2
3F02:  INCF   23,F
3F04:  MOVFF  01,854
3F08:  MOVFF  00,853
3F0C:  MOVLW  1E
3F0E:  ADDWF  xD3,W
3F10:  MOVWF  FE9
3F12:  MOVLW  02
3F14:  ADDWFC xD4,W
3F16:  MOVWF  FEA
3F18:  MOVF   FEF,W
3F1A:  ANDLW  0F
3F1C:  ADDLW  30
3F1E:  MOVLB  8
3F20:  MOVWF  x55
3F22:  MOVLB  9
3F24:  CLRF   x16
3F26:  CLRF   x15
3F28:  MOVFF  01,914
3F2C:  MOVFF  00,913
3F30:  MOVWF  x17
3F32:  MOVLB  0
3F34:  RCALL  3A80
....................          }  
3F36:  MOVLB  6
3F38:  INCF   xD3,F
3F3A:  BTFSC  FD8.2
3F3C:  INCF   xD4,F
3F3E:  BRA    3EDA
....................          memset(Track2,0,sizeof(Track2)); 
3F40:  MOVLW  02
3F42:  MOVWF  FEA
3F44:  MOVLW  1E
3F46:  MOVWF  FE9
3F48:  CLRF   00
3F4A:  CLRF   02
3F4C:  MOVLW  28
3F4E:  MOVWF  01
3F50:  MOVLB  0
3F52:  CALL   35AE
....................         fprintf(COM2,"\r\n"); 
3F56:  MOVLW  0D
3F58:  MOVLB  9
3F5A:  MOVWF  x0C
3F5C:  MOVLB  0
3F5E:  CALL   1620
3F62:  MOVLW  0A
3F64:  MOVLB  9
3F66:  MOVWF  x0C
3F68:  MOVLB  0
3F6A:  CALL   1620
....................         fprintf(COM2,"Done"); 
3F6E:  MOVLW  D0
3F70:  MOVWF  FF6
3F72:  MOVLW  05
3F74:  MOVWF  FF7
3F76:  CALL   174A
....................              
....................         fprintf(COM2,"\r\n"); 
3F7A:  MOVLW  0D
3F7C:  MOVLB  9
3F7E:  MOVWF  x0C
3F80:  MOVLB  0
3F82:  CALL   1620
3F86:  MOVLW  0A
3F88:  MOVLB  9
3F8A:  MOVWF  x0C
3F8C:  MOVLB  0
3F8E:  CALL   1620
....................         fprintf(COM2,"Waiting for PIN number"); 
3F92:  MOVLW  D6
3F94:  MOVWF  FF6
3F96:  MOVLW  05
3F98:  MOVWF  FF7
3F9A:  CALL   174A
....................         memset(key_data,0,sizeof(key_data));  
3F9E:  MOVLW  01
3FA0:  MOVWF  FEA
3FA2:  MOVLW  4A
3FA4:  MOVWF  FE9
3FA6:  CLRF   00
3FA8:  CLRF   02
3FAA:  MOVLW  10
3FAC:  MOVWF  01
3FAE:  CALL   35AE
....................         fprintf(COM2,"\r\n"); 
3FB2:  MOVLW  0D
3FB4:  MOVLB  9
3FB6:  MOVWF  x0C
3FB8:  MOVLB  0
3FBA:  CALL   1620
3FBE:  MOVLW  0A
3FC0:  MOVLB  9
3FC2:  MOVWF  x0C
3FC4:  MOVLB  0
3FC6:  CALL   1620
....................         charac_timeout=0; 
3FCA:  MOVLB  1
3FCC:  CLRF   x00
3FCE:  MOVLB  0
3FD0:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3FD2:  MOVFF  23,903
3FD6:  MOVFF  22,902
3FDA:  MOVFF  21,901
3FDE:  MOVFF  20,900
3FE2:  MOVLW  19
3FE4:  MOVLB  9
3FE6:  MOVWF  x04
3FE8:  MOVLB  0
3FEA:  RCALL  3B7E
....................       datinbuf=0; 
3FEC:  MOVLB  6
3FEE:  CLRF   xD5
....................       saving_flag=0; 
3FF0:  CLRF   xD8
....................       data_avai=1; 
3FF2:  MOVLW  01
3FF4:  MOVWF  xD9
....................       enable_getpin=1; 
3FF6:  MOVLB  1
3FF8:  MOVWF  x45
....................       charac_timeout=0; 
3FFA:  CLRF   x00
3FFC:  MOVLB  0
3FFE:  CLRF   xFF
....................       key_count_ms=0; 
4000:  MOVLB  1
4002:  CLRF   x47
4004:  MOVLB  8
4006:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
4008:  MOVLB  0
400A:  GOTO   5A18 (RETURN)
.................... //========================= 
.................... void saving_card_encrypt() 
.................... { 
*
4ED8:  MOVLB  8
4EDA:  CLRF   x54
....................    int8 temp,i,j,u; 
....................    int8 countbyte=0; 
....................    int16 tempcount; 
....................    int8 carddata[numdataofonecard]; 
....................    int8 encryptblock[16]; 
....................    int8 tempkey[16]; 
....................    saving_flag=1; 
4EDC:  MOVLW  01
4EDE:  MOVLB  6
4EE0:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdataofonecard)+ptr_start); 
4EE2:  MOVLB  0
4EE4:  CALL   3534
4EE8:  MOVFF  02,8F8
4EEC:  MOVFF  01,8F7
4EF0:  MOVLB  8
4EF2:  RLCF   xF7,F
4EF4:  RLCF   xF8,F
4EF6:  RLCF   xF7,F
4EF8:  RLCF   xF8,F
4EFA:  RLCF   xF7,F
4EFC:  RLCF   xF8,F
4EFE:  RLCF   xF7,F
4F00:  RLCF   xF8,F
4F02:  RLCF   xF7,F
4F04:  RLCF   xF8,F
4F06:  RLCF   xF7,F
4F08:  RLCF   xF8,F
4F0A:  RLCF   xF7,F
4F0C:  RLCF   xF8,F
4F0E:  MOVLW  80
4F10:  ANDWF  xF7,F
4F12:  MOVLW  96
4F14:  ADDWF  xF7,W
4F16:  MOVWF  01
4F18:  MOVLW  00
4F1A:  ADDWFC xF8,W
4F1C:  MOVFF  01,20
4F20:  MOVWF  21
4F22:  CLRF   22
4F24:  CLRF   23
....................    if(datinbuf==0)  
4F26:  MOVLB  6
4F28:  MOVF   xD5,F
4F2A:  BNZ   4F4E
....................    { 
....................       countbit_T1=0; 
4F2C:  CLRF   xCA
4F2E:  CLRF   xC9
....................       countbit_T2=0; 
4F30:  CLRF   xCC
4F32:  CLRF   xCB
....................       bug_countbit_T1=0; 
4F34:  CLRF   xCE
4F36:  CLRF   xCD
....................       bug_countbit_T2=0; 
4F38:  CLRF   xD0
4F3A:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
4F3C:  MOVF   xD9,F
4F3E:  BNZ   4F4A
4F40:  MOVLB  1
4F42:  SETF   x00
4F44:  MOVLB  0
4F46:  SETF   xFF
4F48:  MOVLB  6
....................       saving_flag=0; 
4F4A:  CLRF   xD8
....................       return; 
4F4C:  BRA    5422
....................    }//*/ 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
4F4E:  MOVLW  EE
4F50:  MOVWF  FF6
4F52:  MOVLW  05
4F54:  MOVWF  FF7
4F56:  MOVLB  0
4F58:  CALL   174A
....................    //key_count=0; 
....................    enable_getpin=1; 
4F5C:  MOVLW  01
4F5E:  MOVLB  1
4F60:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
4F62:  MOVFF  6CA,856
4F66:  MOVFF  6C9,855
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
4F6A:  MOVLB  8
4F6C:  CLRF   xF7
4F6E:  MOVFF  856,8F9
4F72:  MOVFF  855,8F8
4F76:  MOVLW  02
4F78:  MOVWF  xFB
4F7A:  MOVLW  46
4F7C:  MOVWF  xFA
4F7E:  MOVLW  01
4F80:  MOVWF  xFD
4F82:  MOVLW  CF
4F84:  MOVWF  xFC
4F86:  MOVLB  0
4F88:  CALL   35C8
....................    countbit_T1=0; 
4F8C:  MOVLB  6
4F8E:  CLRF   xCA
4F90:  CLRF   xC9
....................    tempcount=countbit_T2;    
4F92:  MOVFF  6CC,856
4F96:  MOVFF  6CB,855
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
4F9A:  MOVLW  01
4F9C:  MOVLB  8
4F9E:  MOVWF  xF7
4FA0:  MOVFF  856,8F9
4FA4:  MOVFF  855,8F8
4FA8:  MOVLW  05
4FAA:  MOVWF  xFB
4FAC:  MOVLW  98
4FAE:  MOVWF  xFA
4FB0:  MOVLW  02
4FB2:  MOVWF  xFD
4FB4:  MOVLW  1E
4FB6:  MOVWF  xFC
4FB8:  MOVLB  0
4FBA:  CALL   35C8
....................    countbit_T2=0; 
4FBE:  MOVLB  6
4FC0:  CLRF   xCC
4FC2:  CLRF   xCB
....................    saving_flag=0; 
4FC4:  CLRF   xD8
....................    temp=Track1[0]+0x20; 
4FC6:  MOVLW  20
4FC8:  MOVLB  1
4FCA:  ADDWF  xCF,W
4FCC:  MOVLB  8
4FCE:  MOVWF  x50
....................    memset(carddata,0,sizeof(carddata));  
4FD0:  MOVLW  08
4FD2:  MOVWF  FEA
4FD4:  MOVLW  57
4FD6:  MOVWF  FE9
4FD8:  CLRF   00
4FDA:  CLRF   02
4FDC:  MOVLW  80
4FDE:  MOVWF  01
4FE0:  MOVLB  0
4FE2:  CALL   35AE
....................    if((ptr_card<EEPROM_SIZE_stofkey)) 
4FE6:  MOVF   23,F
4FE8:  BTFSS  FD8.2
4FEA:  BRA    5420
4FEC:  MOVF   22,W
4FEE:  SUBLW  01
4FF0:  BTFSS  FD8.0
4FF2:  BRA    5420
4FF4:  BNZ   5008
4FF6:  MOVF   21,W
4FF8:  SUBLW  C3
4FFA:  BTFSS  FD8.0
4FFC:  BRA    5420
4FFE:  BNZ   5008
5000:  MOVF   20,W
5002:  SUBLW  0D
5004:  BTFSS  FD8.0
5006:  BRA    5420
....................    { 
....................          countbyte = 0; 
5008:  MOVLB  8
500A:  CLRF   x54
....................          carddata[countbyte++]=date;    
500C:  MOVF   x54,W
500E:  INCF   x54,F
5010:  CLRF   03
5012:  ADDLW  57
5014:  MOVWF  FE9
5016:  MOVLW  08
5018:  ADDWFC 03,W
501A:  MOVWF  FEA
501C:  MOVFF  1CB,FEF
....................          carddata[countbyte++]=mon;    
5020:  MOVF   x54,W
5022:  INCF   x54,F
5024:  CLRF   03
5026:  ADDLW  57
5028:  MOVWF  FE9
502A:  MOVLW  08
502C:  ADDWFC 03,W
502E:  MOVWF  FEA
5030:  MOVFF  1CA,FEF
....................          carddata[countbyte++]=h;    
5034:  MOVF   x54,W
5036:  INCF   x54,F
5038:  CLRF   03
503A:  ADDLW  57
503C:  MOVWF  FE9
503E:  MOVLW  08
5040:  ADDWFC 03,W
5042:  MOVWF  FEA
5044:  MOVFF  1CC,FEF
....................          carddata[countbyte++]=min;    
5048:  MOVF   x54,W
504A:  INCF   x54,F
504C:  CLRF   03
504E:  ADDLW  57
5050:  MOVWF  FE9
5052:  MOVLW  08
5054:  ADDWFC 03,W
5056:  MOVWF  FEA
5058:  MOVFF  1CD,FEF
....................          carddata[countbyte++]=sec; 
505C:  MOVF   x54,W
505E:  INCF   x54,F
5060:  CLRF   03
5062:  ADDLW  57
5064:  MOVWF  FE9
5066:  MOVLW  08
5068:  ADDWFC 03,W
506A:  MOVWF  FEA
506C:  MOVFF  1CE,FEF
....................          carddata[countbyte++]=0xff;             
5070:  MOVF   x54,W
5072:  INCF   x54,F
5074:  CLRF   03
5076:  ADDLW  57
5078:  MOVWF  FE9
507A:  MOVLW  08
507C:  ADDWFC 03,W
507E:  MOVWF  FEA
5080:  SETF   FEF
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
5082:  MOVLB  6
5084:  CLRF   xD4
5086:  CLRF   xD3
5088:  MOVF   xD4,F
508A:  BNZ   50D6
508C:  MOVF   xD3,W
508E:  SUBLW  4E
5090:  BNC   50D6
....................          { 
....................             temp = (INT8)((Track1[countbit]&0b00111111)+0x20); 
5092:  MOVLW  CF
5094:  ADDWF  xD3,W
5096:  MOVWF  FE9
5098:  MOVLW  01
509A:  ADDWFC xD4,W
509C:  MOVWF  FEA
509E:  MOVF   FEF,W
50A0:  ANDLW  3F
50A2:  ADDLW  20
50A4:  MOVLB  8
50A6:  MOVWF  x50
....................             carddata[countbyte++] = temp; 
50A8:  MOVF   x54,W
50AA:  INCF   x54,F
50AC:  CLRF   03
50AE:  ADDLW  57
50B0:  MOVWF  FE9
50B2:  MOVLW  08
50B4:  ADDWFC 03,W
50B6:  MOVWF  FEA
50B8:  MOVFF  850,FEF
....................             if(temp=='?') 
50BC:  MOVF   x50,W
50BE:  SUBLW  3F
50C0:  BNZ   50CC
....................             { 
....................                countbit = numbyteoftrack1; 
50C2:  MOVLB  6
50C4:  CLRF   xD4
50C6:  MOVLW  4F
50C8:  MOVWF  xD3
50CA:  MOVLB  8
....................             }      
....................          } 
50CC:  MOVLB  6
50CE:  INCF   xD3,F
50D0:  BTFSC  FD8.2
50D2:  INCF   xD4,F
50D4:  BRA    5088
....................          countbyte = numbyteoftrack1+6; 
50D6:  MOVLW  55
50D8:  MOVLB  8
50DA:  MOVWF  x54
....................          fprintf(COM2,"countbyte: %u",countbyte); 
50DC:  MOVLW  04
50DE:  MOVWF  FF6
50E0:  MOVLW  06
50E2:  MOVWF  FF7
50E4:  MOVLW  0B
50E6:  MOVLB  9
50E8:  MOVWF  x00
50EA:  MOVLB  0
50EC:  CALL   1666
50F0:  MOVFF  854,900
50F4:  MOVLW  1B
50F6:  MOVLB  9
50F8:  MOVWF  x01
50FA:  MOVLB  0
50FC:  CALL   400E
....................          memset(Track1,0,sizeof(Track1)); 
5100:  MOVLW  01
5102:  MOVWF  FEA
5104:  MOVLW  CF
5106:  MOVWF  FE9
5108:  CLRF   00
510A:  CLRF   02
510C:  MOVLW  4F
510E:  MOVWF  01
5110:  CALL   35AE
....................          carddata[countbyte++]=0xfe; 
5114:  MOVLB  8
5116:  MOVF   x54,W
5118:  INCF   x54,F
511A:  CLRF   03
511C:  ADDLW  57
511E:  MOVWF  FE9
5120:  MOVLW  08
5122:  ADDWFC 03,W
5124:  MOVWF  FEA
5126:  MOVLW  FE
5128:  MOVWF  FEF
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
512A:  MOVLB  6
512C:  CLRF   xD4
512E:  CLRF   xD3
5130:  MOVF   xD4,F
5132:  BNZ   517E
5134:  MOVF   xD3,W
5136:  SUBLW  27
5138:  BNC   517E
....................          { 
....................             temp = (INT8)((Track2[countbit]&0b00001111)+0x30); 
513A:  MOVLW  1E
513C:  ADDWF  xD3,W
513E:  MOVWF  FE9
5140:  MOVLW  02
5142:  ADDWFC xD4,W
5144:  MOVWF  FEA
5146:  MOVF   FEF,W
5148:  ANDLW  0F
514A:  ADDLW  30
514C:  MOVLB  8
514E:  MOVWF  x50
....................             carddata[countbyte++] = temp; 
5150:  MOVF   x54,W
5152:  INCF   x54,F
5154:  CLRF   03
5156:  ADDLW  57
5158:  MOVWF  FE9
515A:  MOVLW  08
515C:  ADDWFC 03,W
515E:  MOVWF  FEA
5160:  MOVFF  850,FEF
....................             if(temp=='?') 
5164:  MOVF   x50,W
5166:  SUBLW  3F
5168:  BNZ   5174
....................             { 
....................                countbit = numbyteoftrack2; 
516A:  MOVLB  6
516C:  CLRF   xD4
516E:  MOVLW  28
5170:  MOVWF  xD3
5172:  MOVLB  8
....................             } 
....................          } 
5174:  MOVLB  6
5176:  INCF   xD3,F
5178:  BTFSC  FD8.2
517A:  INCF   xD4,F
517C:  BRA    5130
....................          countbyte = numbyteoftrack1+numbyteoftrack2+7;          
517E:  MOVLW  7E
5180:  MOVLB  8
5182:  MOVWF  x54
....................          fprintf(COM2,"countbyte: %u",countbyte); 
5184:  MOVLW  12
5186:  MOVWF  FF6
5188:  MOVLW  06
518A:  MOVWF  FF7
518C:  MOVLW  0B
518E:  MOVLB  9
5190:  MOVWF  x00
5192:  MOVLB  0
5194:  CALL   1666
5198:  MOVFF  854,900
519C:  MOVLW  1B
519E:  MOVLB  9
51A0:  MOVWF  x01
51A2:  MOVLB  0
51A4:  CALL   400E
....................          for(i=countbyte;i<numdataofonecard;i++) 
51A8:  MOVFF  854,851
51AC:  MOVLB  8
51AE:  MOVF   x51,W
51B0:  SUBLW  7F
51B2:  BNC   51C8
....................          { 
....................              carddata[i] = 0; 
51B4:  CLRF   03
51B6:  MOVF   x51,W
51B8:  ADDLW  57
51BA:  MOVWF  FE9
51BC:  MOVLW  08
51BE:  ADDWFC 03,W
51C0:  MOVWF  FEA
51C2:  CLRF   FEF
....................          } 
51C4:  INCF   x51,F
51C6:  BRA    51AE
....................          carddata[numdataofonecard-1]=0xfc; 
51C8:  MOVLW  FC
51CA:  MOVWF  xD6
....................          for(i=0;i<8;i++) 
51CC:  CLRF   x51
51CE:  MOVF   x51,W
51D0:  SUBLW  07
51D2:  BNC   5288
....................          { 
....................              for(j=0;j<16;j++) 
51D4:  CLRF   x52
51D6:  MOVF   x52,W
51D8:  SUBLW  0F
51DA:  BNC   5214
....................              { 
....................                 encryptblock[j] = carddata[i*16+j]; 
51DC:  CLRF   03
51DE:  MOVF   x52,W
51E0:  ADDLW  D7
51E2:  MOVWF  01
51E4:  MOVLW  08
51E6:  ADDWFC 03,F
51E8:  MOVFF  03,8F8
51EC:  MOVF   x51,W
51EE:  MULLW  10
51F0:  MOVF   FF3,W
51F2:  ADDWF  x52,W
51F4:  CLRF   03
51F6:  ADDLW  57
51F8:  MOVWF  FE9
51FA:  MOVLW  08
51FC:  ADDWFC 03,W
51FE:  MOVWF  FEA
5200:  MOVFF  FEF,8F9
5204:  MOVFF  8F8,FEA
5208:  MOVFF  01,FE9
520C:  MOVFF  8F9,FEF
....................              } 
5210:  INCF   x52,F
5212:  BRA    51D6
....................              EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
5214:  MOVLB  9
5216:  CLRF   x07
5218:  CLRF   x06
521A:  CLRF   x05
521C:  MOVLW  3F
521E:  MOVWF  x04
5220:  CLRF   x0B
5222:  CLRF   x0A
5224:  CLRF   x09
5226:  MOVLW  20
5228:  MOVWF  x08
522A:  MOVLW  01
522C:  MOVWF  x0D
522E:  MOVWF  x0C
5230:  MOVLB  0
5232:  CALL   4094
....................              aes_enc_dec((unsigned int8 *)&encryptblock[0], (unsigned int8 *)&crypto_key[0],0); 
5236:  MOVLW  08
5238:  MOVLB  9
523A:  MOVWF  x01
523C:  MOVLW  D7
523E:  MOVWF  x00
5240:  MOVLW  01
5242:  MOVWF  x03
5244:  MOVWF  x02
5246:  CLRF   x04
5248:  MOVLB  0
524A:  CALL   418A
....................              /*for(u=0;u<16;u++) 
....................              { 
....................                 encryptblock[u];  
....................                 fprintf(COM2,"%x",encryptblock[u]); 
....................              }*/ 
....................              EEPROM_write(ptr_card,16,encryptblock); 
524E:  MOVFF  23,903
5252:  MOVFF  22,902
5256:  MOVFF  21,901
525A:  MOVFF  20,900
525E:  MOVLB  9
5260:  CLRF   x07
5262:  CLRF   x06
5264:  CLRF   x05
5266:  MOVLW  10
5268:  MOVWF  x04
526A:  MOVLW  08
526C:  MOVWF  x09
526E:  MOVLW  D7
5270:  MOVWF  x08
5272:  MOVLB  0
5274:  RCALL  4DFE
....................              ptr_card=ptr_card+16; 
5276:  MOVLW  10
5278:  ADDWF  20,F
527A:  MOVLW  00
527C:  ADDWFC 21,F
527E:  ADDWFC 22,F
5280:  ADDWFC 23,F
....................          } 
5282:  MOVLB  8
5284:  INCF   x51,F
5286:  BRA    51CE
....................          fprintf(COM2,"\r\n"); 
5288:  MOVLW  0D
528A:  MOVLB  9
528C:  MOVWF  x0C
528E:  MOVLB  0
5290:  CALL   1620
5294:  MOVLW  0A
5296:  MOVLB  9
5298:  MOVWF  x0C
529A:  MOVLB  0
529C:  CALL   1620
....................          fprintf(COM2,"card data: %lu",ptr_card); 
52A0:  MOVLW  20
52A2:  MOVWF  FF6
52A4:  MOVLW  06
52A6:  MOVWF  FF7
52A8:  MOVLW  0B
52AA:  MOVLB  9
52AC:  MOVWF  x00
52AE:  MOVLB  0
52B0:  CALL   1666
52B4:  MOVLW  41
52B6:  MOVWF  FE9
52B8:  MOVFF  23,903
52BC:  MOVFF  22,902
52C0:  MOVFF  21,901
52C4:  MOVFF  20,900
52C8:  CALL   231A
....................          fprintf(COM2,"\r\n"); 
52CC:  MOVLW  0D
52CE:  MOVLB  9
52D0:  MOVWF  x0C
52D2:  MOVLB  0
52D4:  CALL   1620
52D8:  MOVLW  0A
52DA:  MOVLB  9
52DC:  MOVWF  x0C
52DE:  MOVLB  0
52E0:  CALL   1620
....................          EEPROM_read(ptr_card-128,128,&carddata); 
52E4:  MOVLW  80
52E6:  SUBWF  20,W
52E8:  MOVLB  8
52EA:  MOVWF  xF7
52EC:  MOVLW  00
52EE:  SUBWFB 21,W
52F0:  MOVWF  xF8
52F2:  MOVLW  00
52F4:  SUBWFB 22,W
52F6:  MOVWF  xF9
52F8:  MOVLW  00
52FA:  SUBWFB 23,W
52FC:  MOVWF  xFA
52FE:  MOVFF  FE8,907
5302:  MOVFF  8F9,906
5306:  MOVFF  8F8,905
530A:  MOVFF  8F7,904
530E:  MOVLB  9
5310:  CLRF   x0B
5312:  CLRF   x0A
5314:  CLRF   x09
5316:  MOVLW  80
5318:  MOVWF  x08
531A:  MOVLW  08
531C:  MOVWF  x0D
531E:  MOVLW  57
5320:  MOVWF  x0C
5322:  MOVLB  0
5324:  CALL   4094
....................          for(i=0;i<numdataofonecard;i++) 
5328:  MOVLB  8
532A:  CLRF   x51
532C:  MOVF   x51,W
532E:  SUBLW  7F
5330:  BNC   5358
....................          { 
....................              fprintf(COM2,"%x",carddata[i]); 
5332:  CLRF   03
5334:  MOVF   x51,W
5336:  ADDLW  57
5338:  MOVWF  FE9
533A:  MOVLW  08
533C:  ADDWFC 03,W
533E:  MOVWF  FEA
5340:  MOVFF  FEF,8F7
5344:  MOVFF  8F7,901
5348:  MOVLW  57
534A:  MOVLB  9
534C:  MOVWF  x02
534E:  MOVLB  0
5350:  RCALL  4E8E
....................          } 
5352:  MOVLB  8
5354:  INCF   x51,F
5356:  BRA    532C
....................          memset(Track2,0,sizeof(Track2)); 
5358:  MOVLW  02
535A:  MOVWF  FEA
535C:  MOVLW  1E
535E:  MOVWF  FE9
5360:  CLRF   00
5362:  CLRF   02
5364:  MOVLW  28
5366:  MOVWF  01
5368:  MOVLB  0
536A:  CALL   35AE
....................         fprintf(COM2,"\r\n"); 
536E:  MOVLW  0D
5370:  MOVLB  9
5372:  MOVWF  x0C
5374:  MOVLB  0
5376:  CALL   1620
537A:  MOVLW  0A
537C:  MOVLB  9
537E:  MOVWF  x0C
5380:  MOVLB  0
5382:  CALL   1620
....................         fprintf(COM2,"Done"); 
5386:  MOVLW  30
5388:  MOVWF  FF6
538A:  MOVLW  06
538C:  MOVWF  FF7
538E:  CALL   174A
....................              
....................         fprintf(COM2,"\r\n"); 
5392:  MOVLW  0D
5394:  MOVLB  9
5396:  MOVWF  x0C
5398:  MOVLB  0
539A:  CALL   1620
539E:  MOVLW  0A
53A0:  MOVLB  9
53A2:  MOVWF  x0C
53A4:  MOVLB  0
53A6:  CALL   1620
....................         fprintf(COM2,"Waiting for PIN number"); 
53AA:  MOVLW  36
53AC:  MOVWF  FF6
53AE:  MOVLW  06
53B0:  MOVWF  FF7
53B2:  CALL   174A
....................         memset(key_data,0,sizeof(key_data));  
53B6:  MOVLW  01
53B8:  MOVWF  FEA
53BA:  MOVLW  4A
53BC:  MOVWF  FE9
53BE:  CLRF   00
53C0:  CLRF   02
53C2:  MOVLW  10
53C4:  MOVWF  01
53C6:  CALL   35AE
....................         fprintf(COM2,"\r\n"); 
53CA:  MOVLW  0D
53CC:  MOVLB  9
53CE:  MOVWF  x0C
53D0:  MOVLB  0
53D2:  CALL   1620
53D6:  MOVLW  0A
53D8:  MOVLB  9
53DA:  MOVWF  x0C
53DC:  MOVLB  0
53DE:  CALL   1620
....................         charac_timeout=0; 
53E2:  MOVLB  1
53E4:  CLRF   x00
53E6:  MOVLB  0
53E8:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       //ptr_card = ptr_card+numdataofonecard; 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
53EA:  MOVFF  23,903
53EE:  MOVFF  22,902
53F2:  MOVFF  21,901
53F6:  MOVFF  20,900
53FA:  MOVLW  19
53FC:  MOVLB  9
53FE:  MOVWF  x04
5400:  MOVLB  0
5402:  CALL   3B7E
....................       datinbuf=0; 
5406:  MOVLB  6
5408:  CLRF   xD5
....................       saving_flag=0; 
540A:  CLRF   xD8
....................       data_avai=1; 
540C:  MOVLW  01
540E:  MOVWF  xD9
....................       enable_getpin=1; 
5410:  MOVLB  1
5412:  MOVWF  x45
....................       charac_timeout=0; 
5414:  CLRF   x00
5416:  MOVLB  0
5418:  CLRF   xFF
....................       key_count_ms=0; 
541A:  MOVLB  1
541C:  CLRF   x47
541E:  MOVLB  0
5420:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
5422:  MOVLB  0
5424:  GOTO   5A22 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
190E:  MOVLW  01
1910:  MOVLB  8
1912:  MOVWF  x4D
1914:  MOVWF  x4E
1916:  MOVWF  x4F
1918:  MOVWF  x50
191A:  CLRF   x51
191C:  MOVWF  x52
191E:  MOVWF  x53
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1920:  MOVLB  6
1922:  CLRF   xD2
1924:  CLRF   xD1
....................    mcr_timeout=0; 
1926:  CLRF   xC7
1928:  CLRF   xC6
192A:  CLRF   xC5
192C:  CLRF   xC4
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
192E:  MOVF   xD2,W
1930:  SUBLW  FD
1932:  BNC   1950
1934:  BNZ   193C
1936:  MOVF   xD1,W
1938:  SUBLW  E7
193A:  BNC   1950
193C:  BSF    F93.1
193E:  BTFSS  F81.1
1940:  BRA    1950
1942:  BSF    F94.5
1944:  BTFSS  F82.5
1946:  BRA    1950
....................       card_timeout++; 
1948:  INCF   xD1,F
194A:  BTFSC  FD8.2
194C:  INCF   xD2,F
....................    } 
194E:  BRA    192E
....................    card_timeout=0; 
1950:  CLRF   xD2
1952:  CLRF   xD1
....................    buffertrack1[bug_countbit_T1++]=0; 
1954:  MOVFF  6CE,03
1958:  MOVF   xCD,W
195A:  INCF   xCD,F
195C:  BTFSC  FD8.2
195E:  INCF   xCE,F
1960:  MOVLB  8
1962:  MOVWF  x56
1964:  MOVLW  46
1966:  ADDWF  x56,W
1968:  MOVWF  FE9
196A:  MOVLW  02
196C:  ADDWFC 03,W
196E:  MOVWF  FEA
1970:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1972:  MOVLB  6
1974:  MOVFF  6CE,03
1978:  MOVF   xCD,W
197A:  INCF   xCD,F
197C:  BTFSC  FD8.2
197E:  INCF   xCE,F
1980:  MOVLB  8
1982:  MOVWF  x56
1984:  MOVLW  46
1986:  ADDWF  x56,W
1988:  MOVWF  FE9
198A:  MOVLW  02
198C:  ADDWFC 03,W
198E:  MOVWF  FEA
1990:  MOVLW  01
1992:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1994:  MOVLB  6
1996:  MOVFF  6D0,03
199A:  MOVF   xCF,W
199C:  INCF   xCF,F
199E:  BTFSC  FD8.2
19A0:  INCF   xD0,F
19A2:  MOVLB  8
19A4:  MOVWF  x56
19A6:  MOVLW  98
19A8:  ADDWF  x56,W
19AA:  MOVWF  FE9
19AC:  MOVLW  05
19AE:  ADDWFC 03,W
19B0:  MOVWF  FEA
19B2:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
19B4:  MOVLB  6
19B6:  MOVFF  6D0,03
19BA:  MOVF   xCF,W
19BC:  INCF   xCF,F
19BE:  BTFSC  FD8.2
19C0:  INCF   xD0,F
19C2:  MOVLB  8
19C4:  MOVWF  x56
19C6:  MOVLW  98
19C8:  ADDWF  x56,W
19CA:  MOVWF  FE9
19CC:  MOVLW  05
19CE:  ADDWFC 03,W
19D0:  MOVWF  FEA
19D2:  MOVLW  01
19D4:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
19D6:  MOVLB  6
19D8:  MOVF   xCE,W
19DA:  SUBLW  03
19DC:  BTFSS  FD8.0
19DE:  BRA    1ABE
19E0:  BNZ   19EA
19E2:  MOVF   xCD,W
19E4:  SUBLW  51
19E6:  BTFSS  FD8.0
19E8:  BRA    1ABE
19EA:  MOVF   xD0,W
19EC:  SUBLW  01
19EE:  BTFSS  FD8.0
19F0:  BRA    1ABE
19F2:  BNZ   19FA
19F4:  MOVF   xCF,W
19F6:  SUBLW  2B
19F8:  BNC   1ABE
19FA:  MOVF   xD2,W
19FC:  SUBLW  FF
19FE:  BNC   1ABE
1A00:  BNZ   1A08
1A02:  MOVF   xD1,W
1A04:  SUBLW  DB
1A06:  BNC   1ABE
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
1A08:  MOVF   xDB,F
1A0A:  BZ    1A14
....................          { 
....................             bug_countbit_T1=0; 
1A0C:  CLRF   xCE
1A0E:  CLRF   xCD
....................             bug_countbit_T2=0; 
1A10:  CLRF   xD0
1A12:  CLRF   xCF
....................          } 
....................          card_timeout++; 
1A14:  INCF   xD1,F
1A16:  BTFSC  FD8.2
1A18:  INCF   xD2,F
....................          mcr_timeout=0; 
1A1A:  CLRF   xC7
1A1C:  CLRF   xC6
1A1E:  CLRF   xC5
1A20:  CLRF   xC4
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1A22:  BSF    F93.2
1A24:  MOVLB  8
1A26:  CLRF   x4D
1A28:  BTFSC  F81.2
1A2A:  INCF   x4D,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1A2C:  MOVF   x4D,F
1A2E:  BNZ   1A6C
1A30:  DECFSZ x4E,W
1A32:  BRA    1A6C
....................          { 
....................             ST1_old = 0; 
1A34:  CLRF   x4E
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1A36:  MOVLW  46
1A38:  MOVLB  6
1A3A:  ADDWF  xCD,W
1A3C:  MOVWF  FE9
1A3E:  MOVLW  02
1A40:  ADDWFC xCE,W
1A42:  MOVWF  FEA
1A44:  BSF    F93.1
1A46:  MOVLW  00
1A48:  BTFSS  F81.1
1A4A:  MOVLW  01
1A4C:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1A4E:  MOVLW  98
1A50:  ADDWF  xCF,W
1A52:  MOVWF  FE9
1A54:  MOVLW  05
1A56:  ADDWFC xD0,W
1A58:  MOVWF  FEA
1A5A:  MOVFF  851,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1A5E:  INCF   xCD,F
1A60:  BTFSC  FD8.2
1A62:  INCF   xCE,F
....................             card_timeout=0; 
1A64:  CLRF   xD2
1A66:  CLRF   xD1
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A68:  BRA    1A76
1A6A:  MOVLB  8
1A6C:  DECFSZ x4D,W
1A6E:  BRA    1A74
1A70:  MOVLW  01
1A72:  MOVWF  x4E
1A74:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A76:  BSF    F93.3
1A78:  MOVLB  8
1A7A:  CLRF   x4F
1A7C:  BTFSC  F81.3
1A7E:  INCF   x4F,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A80:  MOVF   x4F,F
1A82:  BNZ   1AA2
1A84:  DECFSZ x50,W
1A86:  BRA    1AA2
....................          { 
....................             ST2_old = 0; 
1A88:  CLRF   x50
....................             Bit_t2 = !input(MCR_DATA2); 
1A8A:  BSF    F94.5
1A8C:  CLRF   x51
1A8E:  BTFSS  F82.5
1A90:  INCF   x51,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A92:  MOVLB  6
1A94:  INCF   xCF,F
1A96:  BTFSC  FD8.2
1A98:  INCF   xD0,F
....................             card_timeout=0; 
1A9A:  CLRF   xD2
1A9C:  CLRF   xD1
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A9E:  BRA    1AAC
1AA0:  MOVLB  8
1AA2:  DECFSZ x4F,W
1AA4:  BRA    1AAA
1AA6:  MOVLW  01
1AA8:  MOVWF  x50
1AAA:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1AAC:  BSF    F93.0
1AAE:  BTFSS  F81.0
1AB0:  BRA    1ABC
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1AB2:  CLRF   xDB
....................             card_timeout=65500; 
1AB4:  SETF   xD2
1AB6:  MOVLW  DC
1AB8:  MOVWF  xD1
....................             break;            
1ABA:  BRA    1ABE
....................          } 
....................       } 
1ABC:  BRA    19D8
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1ABE:  CLRF   xD2
1AC0:  CLRF   xD1
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1AC2:  MOVLB  9
1AC4:  CLRF   x15
1AC6:  MOVFF  6CE,917
1ACA:  MOVFF  6CD,916
1ACE:  MOVLW  02
1AD0:  MOVWF  x19
1AD2:  MOVLW  46
1AD4:  MOVWF  x18
1AD6:  MOVLB  0
1AD8:  CALL   0A1E
1ADC:  MOVFF  01,852
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1AE0:  MOVLW  01
1AE2:  MOVLB  9
1AE4:  MOVWF  x15
1AE6:  MOVFF  6D0,917
1AEA:  MOVFF  6CF,916
1AEE:  MOVLW  05
1AF0:  MOVWF  x19
1AF2:  MOVLW  98
1AF4:  MOVWF  x18
1AF6:  MOVLB  0
1AF8:  CALL   0A1E
1AFC:  MOVFF  01,853
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1B00:  MOVLB  6
1B02:  DECFSZ xD6,W
1B04:  BRA    1B9A
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1B06:  MOVLW  4E
1B08:  MOVWF  FF6
1B0A:  MOVLW  06
1B0C:  MOVWF  FF7
1B0E:  MOVLW  0E
1B10:  MOVLB  9
1B12:  MOVWF  x00
1B14:  MOVLB  0
1B16:  RCALL  1666
1B18:  MOVLW  10
1B1A:  MOVWF  FE9
1B1C:  MOVFF  6CE,857
1B20:  MOVFF  6CD,856
1B24:  RCALL  168E
1B26:  MOVLW  0D
1B28:  MOVLB  9
1B2A:  MOVWF  x0C
1B2C:  MOVLB  0
1B2E:  RCALL  1620
1B30:  MOVLW  0A
1B32:  MOVLB  9
1B34:  MOVWF  x0C
1B36:  MOVLB  0
1B38:  RCALL  1620
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1B3A:  MOVLW  62
1B3C:  MOVWF  FF6
1B3E:  MOVLW  06
1B40:  MOVWF  FF7
1B42:  MOVLW  0E
1B44:  MOVLB  9
1B46:  MOVWF  x00
1B48:  MOVLB  0
1B4A:  RCALL  1666
1B4C:  MOVLW  10
1B4E:  MOVWF  FE9
1B50:  MOVFF  6D0,857
1B54:  MOVFF  6CF,856
1B58:  RCALL  168E
1B5A:  MOVLW  0D
1B5C:  MOVLB  9
1B5E:  MOVWF  x0C
1B60:  MOVLB  0
1B62:  RCALL  1620
1B64:  MOVLW  0A
1B66:  MOVLB  9
1B68:  MOVWF  x0C
1B6A:  MOVLB  0
1B6C:  RCALL  1620
....................          debug_reader();       
1B6E:  BRA    1856
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B70:  MOVLB  8
1B72:  MOVF   x52,F
1B74:  BNZ   1B84
1B76:  MOVLW  76
1B78:  MOVWF  FF6
1B7A:  MOVLW  06
1B7C:  MOVWF  FF7
1B7E:  MOVLB  0
1B80:  RCALL  174A
1B82:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B84:  MOVF   x53,F
1B86:  BNZ   1B96
1B88:  MOVLW  8C
1B8A:  MOVWF  FF6
1B8C:  MOVLW  06
1B8E:  MOVWF  FF7
1B90:  MOVLB  0
1B92:  RCALL  174A
1B94:  MOVLB  8
....................       } 
....................          else 
1B96:  BRA    1BA6
1B98:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B9A:  MOVLW  0F
1B9C:  MOVLB  8
1B9E:  MOVWF  x56
1BA0:  MOVLB  0
1BA2:  RCALL  18E6
1BA4:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1BA6:  MOVF   x52,F
1BA8:  BZ    1BAE
1BAA:  MOVF   x53,F
1BAC:  BNZ   1BCE
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1BAE:  MOVLB  6
1BB0:  CLRF   xD0
1BB2:  CLRF   xCF
....................          bug_countbit_T1=0; 
1BB4:  CLRF   xCE
1BB6:  CLRF   xCD
....................          reading_fg=0; 
1BB8:  CLRF   xDA
....................          count_reading_error++; 
1BBA:  INCF   xDB,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1BBC:  CLRF   xC7
1BBE:  CLRF   xC6
1BC0:  CLRF   xC5
1BC2:  CLRF   xC4
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1BC4:  MOVLW  00
1BC6:  MOVWF  01
1BC8:  BRA    1C08
....................       } 
....................          else  
1BCA:  BRA    1C04
1BCC:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1BCE:  MOVLW  01
1BD0:  MOVLB  6
1BD2:  MOVWF  xD5
....................             reading_fg=1; 
1BD4:  MOVWF  xDA
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1BD6:  MOVFF  6D0,6CC
1BDA:  MOVFF  6CF,6CB
....................             countbit_T1=bug_countbit_T1; 
1BDE:  MOVFF  6CE,6CA
1BE2:  MOVFF  6CD,6C9
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1BE6:  CLRF   xCE
1BE8:  CLRF   xCD
....................             bug_countbit_T2=0;  
1BEA:  CLRF   xD0
1BEC:  CLRF   xCF
....................             mcr_timeout=0; 
1BEE:  CLRF   xC7
1BF0:  CLRF   xC6
1BF2:  CLRF   xC5
1BF4:  CLRF   xC4
....................             charac_timeout=0; 
1BF6:  MOVLB  1
1BF8:  CLRF   x00
1BFA:  MOVLB  0
1BFC:  CLRF   xFF
....................             return 1; 
1BFE:  MOVWF  01
1C00:  MOVLB  6
1C02:  BRA    1C08
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1C04:  MOVLW  00
1C06:  MOVWF  01
.................... } 
1C08:  MOVLB  0
1C0A:  GOTO   1C30 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       delay_us(500); 
1C0E:  MOVLW  02
1C10:  MOVLB  8
1C12:  MOVWF  x4D
1C14:  MOVLW  FA
1C16:  MOVWF  x4E
1C18:  MOVLB  0
1C1A:  GOTO   06A2
1C1E:  MOVLB  8
1C20:  DECFSZ x4D,F
1C22:  BRA    1C14
....................       if(saving_flag==1) return;      
1C24:  MOVLB  6
1C26:  DECFSZ xD8,W
1C28:  BRA    1C2C
1C2A:  BRA    1C42
....................       cardread_st=mcr_read(); 
1C2C:  MOVLB  0
1C2E:  BRA    190E
1C30:  MOVFF  01,6D7
....................       mcr_timeout=0; 
1C34:  MOVLB  6
1C36:  CLRF   xC7
1C38:  CLRF   xC6
1C3A:  CLRF   xC5
1C3C:  CLRF   xC4
....................       card_timeout=0;      
1C3E:  CLRF   xD2
1C40:  CLRF   xD1
.................... } 
.................... //==================================== 
.................... #if 0 
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... #endif 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
1C42:  BCF    FF0.0
1C44:  MOVLB  0
1C46:  GOTO   006C
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
69E6:  CLRF   19
69E8:  BTFSC  FF2.7
69EA:  BSF    19.7
69EC:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
69EE:  MOVLB  9
69F0:  CLRF   x16
69F2:  CLRF   x15
69F4:  CLRF   x14
69F6:  MOVLW  3C
69F8:  MOVWF  x13
69FA:  MOVLW  03
69FC:  MOVWF  x17
69FE:  MOVLB  0
6A00:  CALL   3A80
6A04:  BTFSC  19.7
6A06:  BSF    FF2.7
6A08:  CLRF   19
6A0A:  BTFSC  FF2.7
6A0C:  BSF    19.7
6A0E:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
6A10:  MOVLB  9
6A12:  CLRF   x16
6A14:  CLRF   x15
6A16:  CLRF   x14
6A18:  MOVLW  3A
6A1A:  MOVWF  x13
6A1C:  MOVLW  01
6A1E:  MOVWF  x17
6A20:  MOVLB  0
6A22:  CALL   3A80
6A26:  BTFSC  19.7
6A28:  BSF    FF2.7
6A2A:  CLRF   19
6A2C:  BTFSC  FF2.7
6A2E:  BSF    19.7
6A30:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV);  
6A32:  MOVLB  9
6A34:  CLRF   x1B
6A36:  CLRF   x1A
6A38:  CLRF   x19
6A3A:  MOVLW  3A
6A3C:  MOVWF  x18
6A3E:  MOVLB  0
6A40:  CALL   3468
6A44:  BTFSC  19.7
6A46:  BSF    FF2.7
6A48:  MOVFF  01,6E2
.................... } 
6A4C:  GOTO   6D2A (RETURN)
.................... //================================ 
.................... void downloaddataregular() 
.................... { 
*
6254:  MOVLB  7
6256:  CLRF   xF6
6258:  CLRF   xF5
....................     int8 index,i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 temp[50]; 
....................     rec[0]=0; 
625A:  MOVLB  0
625C:  CLRF   x7D
625E:  CLRF   19
6260:  BTFSC  FF2.7
6262:  BSF    19.7
6264:  BCF    FF2.7
....................     count_card_tg=get_countcard(); 
6266:  CALL   3534
626A:  BTFSC  19.7
626C:  BSF    FF2.7
626E:  MOVFF  02,6E1
6272:  MOVFF  01,6E0
6276:  CLRF   19
6278:  BTFSC  FF2.7
627A:  BSF    19.7
627C:  BCF    FF2.7
....................     adr=count_card*numdata; 
627E:  MOVFF  6DF,856
6282:  MOVFF  6DE,855
6286:  MOVLB  8
6288:  CLRF   x58
628A:  MOVLW  7C
628C:  MOVWF  x57
628E:  MOVLB  0
6290:  CALL   358C
6294:  BTFSC  19.7
6296:  BSF    FF2.7
6298:  MOVFF  02,7F6
629C:  MOVFF  01,7F5
....................     addr_key=EEPROM_KEY_ST; 
62A0:  MOVLB  6
62A2:  CLRF   xE6
62A4:  MOVLW  01
62A6:  MOVWF  xE5
62A8:  MOVLW  C3
62AA:  MOVWF  xE4
62AC:  MOVLW  0F
62AE:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
62B0:  MOVF   xDF,W
62B2:  SUBWF  xE1,W
62B4:  BTFSS  FD8.0
62B6:  BRA    6650
62B8:  BNZ   62C2
62BA:  MOVF   xDE,W
62BC:  SUBWF  xE0,W
62BE:  BTFSS  FD8.0
62C0:  BRA    6650
62C2:  CLRF   19
62C4:  BTFSC  FF2.7
62C6:  BSF    19.7
62C8:  BCF    FF2.7
....................         adr=count_card*numdata+ptr_start; 
62CA:  MOVFF  6DF,856
62CE:  MOVFF  6DE,855
62D2:  MOVLB  8
62D4:  CLRF   x58
62D6:  MOVLW  7C
62D8:  MOVWF  x57
62DA:  MOVLB  0
62DC:  CALL   358C
62E0:  BTFSC  19.7
62E2:  BSF    FF2.7
62E4:  MOVLW  96
62E6:  MOVLB  8
62E8:  ADDWF  01,W
62EA:  MOVLB  7
62EC:  MOVWF  xF5
62EE:  MOVLW  00
62F0:  MOVLB  8
62F2:  ADDWFC 02,W
62F4:  MOVLB  7
62F6:  MOVWF  xF6
....................         EEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
62F8:  MOVLW  7C
62FA:  SUBWF  xF5,W
62FC:  MOVLB  8
62FE:  MOVWF  x2B
6300:  MOVLW  00
6302:  MOVLB  7
6304:  SUBWFB xF6,W
6306:  MOVLB  8
6308:  MOVWF  x2C
630A:  CLRF   19
630C:  BTFSC  FF2.7
630E:  BSF    19.7
6310:  BCF    FF2.7
6312:  MOVLB  9
6314:  CLRF   x07
6316:  CLRF   x06
6318:  MOVWF  x05
631A:  MOVFF  82B,904
631E:  CLRF   x0B
6320:  CLRF   x0A
6322:  CLRF   x09
6324:  MOVLW  7C
6326:  MOVWF  x08
6328:  CLRF   x0D
632A:  MOVLW  7D
632C:  MOVWF  x0C
632E:  MOVLB  0
6330:  CALL   4094
6334:  BTFSC  19.7
6336:  BSF    FF2.7
....................         fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
6338:  MOVLW  10
633A:  MOVWF  FE9
633C:  CLRF   19
633E:  BTFSC  FF2.7
6340:  BSF    19.7
6342:  BCF    FF2.7
6344:  MOVFF  6DF,851
6348:  MOVFF  6DE,850
634C:  CALL   58A0
6350:  BTFSC  19.7
6352:  BSF    FF2.7
6354:  CLRF   19
6356:  BTFSC  FF2.7
6358:  BSF    19.7
635A:  BCF    FF2.7
635C:  MOVLW  29
635E:  MOVLB  9
6360:  MOVWF  x0C
6362:  MOVLB  0
6364:  CALL   1620
6368:  BTFSC  19.7
636A:  BSF    FF2.7
636C:  MOVFF  7D,82B
6370:  MOVLW  01
6372:  MOVLB  8
6374:  MOVWF  x2C
6376:  MOVLB  0
6378:  RCALL  613A
637A:  CLRF   19
637C:  BTFSC  FF2.7
637E:  BSF    19.7
6380:  BCF    FF2.7
6382:  MOVLW  2F
6384:  MOVLB  9
6386:  MOVWF  x0C
6388:  MOVLB  0
638A:  CALL   1620
638E:  BTFSC  19.7
6390:  BSF    FF2.7
6392:  MOVFF  7E,82B
6396:  MOVLW  01
6398:  MOVLB  8
639A:  MOVWF  x2C
639C:  MOVLB  0
639E:  RCALL  613A
63A0:  CLRF   19
63A2:  BTFSC  FF2.7
63A4:  BSF    19.7
63A6:  BCF    FF2.7
63A8:  MOVLW  20
63AA:  MOVLB  9
63AC:  MOVWF  x0C
63AE:  MOVLB  0
63B0:  CALL   1620
63B4:  BTFSC  19.7
63B6:  BSF    FF2.7
63B8:  MOVFF  7F,82B
63BC:  MOVLW  01
63BE:  MOVLB  8
63C0:  MOVWF  x2C
63C2:  MOVLB  0
63C4:  RCALL  613A
63C6:  CLRF   19
63C8:  BTFSC  FF2.7
63CA:  BSF    19.7
63CC:  BCF    FF2.7
63CE:  MOVLW  3A
63D0:  MOVLB  9
63D2:  MOVWF  x0C
63D4:  MOVLB  0
63D6:  CALL   1620
63DA:  BTFSC  19.7
63DC:  BSF    FF2.7
63DE:  MOVFF  80,82B
63E2:  MOVLW  01
63E4:  MOVLB  8
63E6:  MOVWF  x2C
63E8:  MOVLB  0
63EA:  RCALL  613A
63EC:  CLRF   19
63EE:  BTFSC  FF2.7
63F0:  BSF    19.7
63F2:  BCF    FF2.7
63F4:  MOVLW  3A
63F6:  MOVLB  9
63F8:  MOVWF  x0C
63FA:  MOVLB  0
63FC:  CALL   1620
6400:  BTFSC  19.7
6402:  BSF    FF2.7
6404:  MOVFF  81,82B
6408:  MOVLW  01
640A:  MOVLB  8
640C:  MOVWF  x2C
640E:  MOVLB  0
6410:  RCALL  613A
....................         ee_dat=0; 
6412:  MOVLB  6
6414:  CLRF   xDD
....................         index=0; 
6416:  MOVLB  7
6418:  CLRF   xF3
....................         fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
641A:  MOVLW  4A
641C:  MOVWF  FF6
641E:  MOVLW  1C
6420:  MOVWF  FF7
6422:  CLRF   19
6424:  BTFSC  FF2.7
6426:  BSF    19.7
6428:  BCF    FF2.7
642A:  MOVLB  0
642C:  CALL   174A
6430:  BTFSC  19.7
6432:  BSF    FF2.7
....................         while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................         { 
6434:  MOVLB  7
6436:  MOVF   xF3,W
6438:  SUBLW  4E
643A:  BNC   6498
643C:  MOVLB  6
643E:  MOVF   xDD,W
6440:  SUBLW  3F
6442:  BTFSS  FD8.2
6444:  BRA    644A
6446:  MOVLB  7
6448:  BRA    6498
....................            ee_dat = rec[index+5]; 
644A:  MOVLW  05
644C:  MOVLB  7
644E:  ADDWF  xF3,W
6450:  CLRF   03
6452:  ADDLW  7D
6454:  MOVWF  FE9
6456:  MOVLW  00
6458:  ADDWFC 03,W
645A:  MOVWF  FEA
645C:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
6460:  MOVLB  6
6462:  MOVF   xDD,W
6464:  SUBLW  1F
6466:  BC    6484
6468:  MOVF   xDD,W
646A:  SUBLW  7E
646C:  BNC   6484
646E:  CLRF   19
6470:  BTFSC  FF2.7
6472:  BSF    19.7
6474:  BCF    FF2.7
6476:  MOVFF  6DD,90C
647A:  MOVLB  0
647C:  CALL   1620
6480:  BTFSC  19.7
6482:  BSF    FF2.7
....................            index++; 
6484:  MOVLB  7
6486:  INCF   xF3,F
....................            if(ee_dat==0)break; 
6488:  MOVLB  6
648A:  MOVF   xDD,F
648C:  BNZ   6492
648E:  MOVLB  7
6490:  BRA    6498
....................         } 
6492:  MOVLB  0
6494:  BRA    6434
6496:  MOVLB  7
....................         fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
6498:  MOVLW  5C
649A:  MOVWF  FF6
649C:  MOVLW  1C
649E:  MOVWF  FF7
64A0:  CLRF   19
64A2:  BTFSC  FF2.7
64A4:  BSF    19.7
64A6:  BCF    FF2.7
64A8:  MOVLB  0
64AA:  CALL   174A
64AE:  BTFSC  19.7
64B0:  BSF    FF2.7
....................         index=0; 
64B2:  MOVLB  7
64B4:  CLRF   xF3
....................         ee_dat=0; 
64B6:  MOVLB  6
64B8:  CLRF   xDD
....................         while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................         { 
64BA:  MOVLB  7
64BC:  MOVF   xF3,W
64BE:  SUBLW  27
64C0:  BNC   6520
64C2:  MOVLB  6
64C4:  MOVF   xDD,W
64C6:  SUBLW  3F
64C8:  BTFSS  FD8.2
64CA:  BRA    64D0
64CC:  MOVLB  7
64CE:  BRA    6520
....................            ee_dat = rec[index+5+numbyteoftrack1]; 
64D0:  MOVLW  05
64D2:  MOVLB  7
64D4:  ADDWF  xF3,W
64D6:  ADDLW  4F
64D8:  CLRF   03
64DA:  ADDLW  7D
64DC:  MOVWF  FE9
64DE:  MOVLW  00
64E0:  ADDWFC 03,W
64E2:  MOVWF  FEA
64E4:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
64E8:  MOVLB  6
64EA:  MOVF   xDD,W
64EC:  SUBLW  1F
64EE:  BC    650C
64F0:  MOVF   xDD,W
64F2:  SUBLW  7E
64F4:  BNC   650C
64F6:  CLRF   19
64F8:  BTFSC  FF2.7
64FA:  BSF    19.7
64FC:  BCF    FF2.7
64FE:  MOVFF  6DD,90C
6502:  MOVLB  0
6504:  CALL   1620
6508:  BTFSC  19.7
650A:  BSF    FF2.7
....................            index++; 
650C:  MOVLB  7
650E:  INCF   xF3,F
....................            if(ee_dat==0)break; 
6510:  MOVLB  6
6512:  MOVF   xDD,F
6514:  BNZ   651C
6516:  MOVLB  7
6518:  BRA    6520
651A:  MOVLB  6
....................         } 
651C:  BRA    64BA
651E:  MOVLB  7
....................         index=0; 
6520:  CLRF   xF3
....................  
....................         fprintf(COM2,"\r\nPIN Number:\r\n"); 
6522:  MOVLW  6E
6524:  MOVWF  FF6
6526:  MOVLW  1C
6528:  MOVWF  FF7
652A:  CLRF   19
652C:  BTFSC  FF2.7
652E:  BSF    19.7
6530:  BCF    FF2.7
6532:  MOVLB  0
6534:  CALL   174A
6538:  BTFSC  19.7
653A:  BSF    FF2.7
....................  
....................         if((ptr_card_key>addr_key)) //&& 
653C:  MOVLB  6
653E:  MOVF   xE6,W
6540:  SUBWF  27,W
6542:  BTFSS  FD8.0
6544:  BRA    6648
6546:  BNZ   6564
6548:  MOVF   xE5,W
654A:  SUBWF  26,W
654C:  BTFSS  FD8.0
654E:  BRA    6648
6550:  BNZ   6564
6552:  MOVF   xE4,W
6554:  SUBWF  25,W
6556:  BTFSS  FD8.0
6558:  BRA    6648
655A:  BNZ   6564
655C:  MOVF   24,W
655E:  SUBWF  xE3,W
6560:  BTFSC  FD8.0
6562:  BRA    6648
....................         { 
....................            i=0; 
6564:  MOVLB  7
6566:  CLRF   xF4
....................            do 
....................            { 
....................               ee_dat=read_ext_eeprom(i+addr_key); 
6568:  MOVF   xF4,W
656A:  MOVLB  6
656C:  ADDWF  xE3,W
656E:  MOVLB  8
6570:  MOVWF  x2B
6572:  MOVLW  00
6574:  MOVLB  6
6576:  ADDWFC xE4,W
6578:  MOVLB  8
657A:  MOVWF  x2C
657C:  MOVLW  00
657E:  MOVLB  6
6580:  ADDWFC xE5,W
6582:  MOVLB  8
6584:  MOVWF  x2D
6586:  MOVLW  00
6588:  MOVLB  6
658A:  ADDWFC xE6,W
658C:  MOVLB  8
658E:  MOVWF  x2E
6590:  CLRF   19
6592:  BTFSC  FF2.7
6594:  BSF    19.7
6596:  BCF    FF2.7
6598:  MOVFF  FE8,91B
659C:  MOVFF  82D,91A
65A0:  MOVFF  82C,919
65A4:  MOVFF  82B,918
65A8:  MOVLB  0
65AA:  CALL   3468
65AE:  BTFSC  19.7
65B0:  BSF    FF2.7
65B2:  MOVFF  01,6DD
....................               if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
65B6:  MOVLB  6
65B8:  MOVF   xDD,W
65BA:  SUBLW  2F
65BC:  BC    65C4
65BE:  MOVF   xDD,W
65C0:  SUBLW  39
65C2:  BC    65DC
65C4:  MOVF   xDD,W
65C6:  SUBLW  23
65C8:  BZ    65DC
65CA:  MOVF   xDD,W
65CC:  SUBLW  2A
65CE:  BZ    65DC
65D0:  MOVF   xDD,W
65D2:  SUBLW  40
65D4:  BC    65F2
65D6:  MOVF   xDD,W
65D8:  SUBLW  5A
65DA:  BNC   65F2
65DC:  CLRF   19
65DE:  BTFSC  FF2.7
65E0:  BSF    19.7
65E2:  BCF    FF2.7
....................               { 
....................                  fprintf(COM2,"%c",ee_dat); 
65E4:  MOVFF  6DD,90C
65E8:  MOVLB  0
65EA:  CALL   1620
65EE:  BTFSC  19.7
65F0:  BSF    FF2.7
....................               } 
....................               i++; 
65F2:  MOVLB  7
65F4:  INCF   xF4,F
....................            } 
....................            while((i<wideofkeystore)&&(ee_dat!=0)); 
65F6:  MOVF   xF4,W
65F8:  SUBLW  0F
65FA:  BNC   6608
65FC:  MOVLB  6
65FE:  MOVF   xDD,F
6600:  BTFSC  FD8.2
6602:  BRA    6608
6604:  MOVLB  7
6606:  BRA    6568
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
6608:  MOVLW  10
660A:  MOVLB  6
660C:  ADDWF  xE3,F
660E:  MOVLW  00
6610:  ADDWFC xE4,F
6612:  ADDWFC xE5,F
6614:  ADDWFC xE6,F
6616:  CLRF   19
6618:  BTFSC  FF2.7
661A:  BSF    19.7
661C:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
661E:  MOVLW  0A
6620:  MOVLB  9
6622:  MOVWF  x0C
6624:  MOVLB  0
6626:  CALL   1620
662A:  BTFSC  19.7
662C:  BSF    FF2.7
662E:  CLRF   19
6630:  BTFSC  FF2.7
6632:  BSF    19.7
6634:  BCF    FF2.7
6636:  MOVLW  0D
6638:  MOVLB  9
663A:  MOVWF  x0C
663C:  MOVLB  0
663E:  CALL   1620
6642:  BTFSC  19.7
6644:  BSF    FF2.7
6646:  MOVLB  6
....................         } 
....................         count_card++; 
6648:  INCF   xDE,F
664A:  BTFSC  FD8.2
664C:  INCF   xDF,F
....................     }  
664E:  BRA    62B0
.................... } 
6650:  MOVLB  0
6652:  GOTO   6B5C (RETURN)
.................... //================================ 
.................... void downloaddataEncrypt() 
.................... { 
6656:  MOVLB  7
6658:  CLRF   xF5
665A:  CLRF   xF4
665C:  CLRF   19
665E:  BTFSC  FF2.7
6660:  BSF    19.7
6662:  BCF    FF2.7
....................     int8 i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 keydatatemp[16]; 
....................     count_card_tg=get_countcard(); 
6664:  MOVLB  0
6666:  CALL   3534
666A:  BTFSC  19.7
666C:  BSF    FF2.7
666E:  MOVFF  02,6E1
6672:  MOVFF  01,6E0
....................     adr=count_card*numdataofonecard; 
6676:  MOVLB  6
6678:  RLCF   xDE,W
667A:  MOVLB  7
667C:  MOVWF  xF4
667E:  MOVLB  6
6680:  RLCF   xDF,W
6682:  MOVLB  7
6684:  MOVWF  xF5
6686:  RLCF   xF4,F
6688:  RLCF   xF5,F
668A:  RLCF   xF4,F
668C:  RLCF   xF5,F
668E:  RLCF   xF4,F
6690:  RLCF   xF5,F
6692:  RLCF   xF4,F
6694:  RLCF   xF5,F
6696:  RLCF   xF4,F
6698:  RLCF   xF5,F
669A:  RLCF   xF4,F
669C:  RLCF   xF5,F
669E:  MOVLW  80
66A0:  ANDWF  xF4,F
....................     addr_key=EEPROM_KEY_ST; 
66A2:  MOVLB  6
66A4:  CLRF   xE6
66A6:  MOVLW  01
66A8:  MOVWF  xE5
66AA:  MOVLW  C3
66AC:  MOVWF  xE4
66AE:  MOVLW  0F
66B0:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
66B2:  MOVF   xDF,W
66B4:  SUBWF  xE1,W
66B6:  BTFSS  FD8.0
66B8:  BRA    6870
66BA:  BNZ   66C4
66BC:  MOVF   xDE,W
66BE:  SUBWF  xE0,W
66C0:  BTFSS  FD8.0
66C2:  BRA    6870
....................         adr=count_card*numdataofonecard+ptr_start; 
66C4:  RLCF   xDE,W
66C6:  MOVLB  8
66C8:  MOVWF  x08
66CA:  MOVLB  6
66CC:  RLCF   xDF,W
66CE:  MOVLB  8
66D0:  MOVWF  x09
66D2:  RLCF   x08,F
66D4:  RLCF   x09,F
66D6:  RLCF   x08,F
66D8:  RLCF   x09,F
66DA:  RLCF   x08,F
66DC:  RLCF   x09,F
66DE:  RLCF   x08,F
66E0:  RLCF   x09,F
66E2:  RLCF   x08,F
66E4:  RLCF   x09,F
66E6:  RLCF   x08,F
66E8:  RLCF   x09,F
66EA:  MOVLW  80
66EC:  ANDWF  x08,F
66EE:  MOVLW  96
66F0:  ADDWF  x08,W
66F2:  MOVLB  7
66F4:  MOVWF  xF4
66F6:  MOVLW  00
66F8:  MOVLB  8
66FA:  ADDWFC x09,W
66FC:  MOVLB  7
66FE:  MOVWF  xF5
....................         memset(rec,0,sizeof(rec)); 
6700:  CLRF   FEA
6702:  MOVLW  7D
6704:  MOVWF  FE9
6706:  CLRF   00
6708:  CLRF   02
670A:  MOVLW  80
670C:  MOVWF  01
670E:  MOVLB  0
6710:  CALL   35AE
....................         EEPROM_read((unsigned int16)(adr-numdataofonecard),numdataofonecard,rec); 
6714:  MOVLW  80
6716:  MOVLB  7
6718:  SUBWF  xF4,W
671A:  MOVLB  8
671C:  MOVWF  x08
671E:  MOVLW  00
6720:  MOVLB  7
6722:  SUBWFB xF5,W
6724:  MOVLB  8
6726:  MOVWF  x09
6728:  CLRF   19
672A:  BTFSC  FF2.7
672C:  BSF    19.7
672E:  BCF    FF2.7
6730:  MOVLB  9
6732:  CLRF   x07
6734:  CLRF   x06
6736:  MOVWF  x05
6738:  MOVFF  808,904
673C:  CLRF   x0B
673E:  CLRF   x0A
6740:  CLRF   x09
6742:  MOVLW  80
6744:  MOVWF  x08
6746:  CLRF   x0D
6748:  MOVLW  7D
674A:  MOVWF  x0C
674C:  MOVLB  0
674E:  CALL   4094
6752:  BTFSC  19.7
6754:  BSF    FF2.7
....................         for(i=0;i<numdataofonecard;i++) 
6756:  MOVLB  7
6758:  CLRF   xF3
675A:  MOVF   xF3,W
675C:  SUBLW  7F
675E:  BNC   6794
....................         { 
....................            fprintf(COM2,"%x",rec[i]);  
6760:  CLRF   03
6762:  MOVF   xF3,W
6764:  ADDLW  7D
6766:  MOVWF  FE9
6768:  MOVLW  00
676A:  ADDWFC 03,W
676C:  MOVWF  FEA
676E:  MOVFF  FEF,808
6772:  CLRF   19
6774:  BTFSC  FF2.7
6776:  BSF    19.7
6778:  BCF    FF2.7
677A:  MOVFF  808,901
677E:  MOVLW  57
6780:  MOVLB  9
6782:  MOVWF  x02
6784:  MOVLB  0
6786:  CALL   4E8E
678A:  BTFSC  19.7
678C:  BSF    FF2.7
....................         } 
678E:  MOVLB  7
6790:  INCF   xF3,F
6792:  BRA    675A
....................  
....................         if((ptr_card_key>addr_key)) 
6794:  MOVLB  6
6796:  MOVF   xE6,W
6798:  SUBWF  27,W
679A:  BNC   6868
679C:  BNZ   67B4
679E:  MOVF   xE5,W
67A0:  SUBWF  26,W
67A2:  BNC   6868
67A4:  BNZ   67B4
67A6:  MOVF   xE4,W
67A8:  SUBWF  25,W
67AA:  BNC   6868
67AC:  BNZ   67B4
67AE:  MOVF   24,W
67B0:  SUBWF  xE3,W
67B2:  BC    6868
67B4:  CLRF   19
67B6:  BTFSC  FF2.7
67B8:  BSF    19.7
67BA:  BCF    FF2.7
....................         { 
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            EEPROM_read(addr_key,wideofkeystore,keydatatemp); 
67BC:  MOVFF  6E6,907
67C0:  MOVFF  6E5,906
67C4:  MOVFF  6E4,905
67C8:  MOVFF  6E3,904
67CC:  MOVLB  9
67CE:  CLRF   x0B
67D0:  CLRF   x0A
67D2:  CLRF   x09
67D4:  MOVLW  10
67D6:  MOVWF  x08
67D8:  MOVLW  07
67DA:  MOVWF  x0D
67DC:  MOVLW  F8
67DE:  MOVWF  x0C
67E0:  MOVLB  0
67E2:  CALL   4094
67E6:  BTFSC  19.7
67E8:  BSF    FF2.7
....................            for(i=0;i<wideofkeystore;i++) 
67EA:  MOVLB  7
67EC:  CLRF   xF3
67EE:  MOVF   xF3,W
67F0:  SUBLW  0F
67F2:  BNC   6828
....................            { 
....................                fprintf(COM2,"%x",keydatatemp[i]); 
67F4:  CLRF   03
67F6:  MOVF   xF3,W
67F8:  ADDLW  F8
67FA:  MOVWF  FE9
67FC:  MOVLW  07
67FE:  ADDWFC 03,W
6800:  MOVWF  FEA
6802:  MOVFF  FEF,808
6806:  CLRF   19
6808:  BTFSC  FF2.7
680A:  BSF    19.7
680C:  BCF    FF2.7
680E:  MOVFF  808,901
6812:  MOVLW  57
6814:  MOVLB  9
6816:  MOVWF  x02
6818:  MOVLB  0
681A:  CALL   4E8E
681E:  BTFSC  19.7
6820:  BSF    FF2.7
....................            } 
6822:  MOVLB  7
6824:  INCF   xF3,F
6826:  BRA    67EE
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
6828:  MOVLW  10
682A:  MOVLB  6
682C:  ADDWF  xE3,F
682E:  MOVLW  00
6830:  ADDWFC xE4,F
6832:  ADDWFC xE5,F
6834:  ADDWFC xE6,F
6836:  CLRF   19
6838:  BTFSC  FF2.7
683A:  BSF    19.7
683C:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
683E:  MOVLW  0A
6840:  MOVLB  9
6842:  MOVWF  x0C
6844:  MOVLB  0
6846:  CALL   1620
684A:  BTFSC  19.7
684C:  BSF    FF2.7
684E:  CLRF   19
6850:  BTFSC  FF2.7
6852:  BSF    19.7
6854:  BCF    FF2.7
6856:  MOVLW  0D
6858:  MOVLB  9
685A:  MOVWF  x0C
685C:  MOVLB  0
685E:  CALL   1620
6862:  BTFSC  19.7
6864:  BSF    FF2.7
6866:  MOVLB  6
....................         } 
....................         count_card++; 
6868:  INCF   xDE,F
686A:  BTFSC  FD8.2
686C:  INCF   xDF,F
....................     }  
686E:  BRA    66B2
.................... } 
6870:  MOVLB  0
6872:  GOTO   6B5C (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int16 countchar; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
6A9E:  MOVLW  06
6AA0:  MOVWF  FEA
6AA2:  MOVLW  E7
6AA4:  MOVWF  FE9
6AA6:  GOTO   6106
6AAA:  CLRF   19
6AAC:  BTFSC  FF2.7
6AAE:  BSF    19.7
6AB0:  BCF    FF2.7
6AB2:  MOVLW  3E
6AB4:  MOVLB  9
6AB6:  MOVWF  x0C
6AB8:  MOVLB  0
6ABA:  CALL   1620
6ABE:  BTFSC  19.7
6AC0:  BSF    FF2.7
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
6AC2:  MOVLW  01
6AC4:  MOVLB  7
6AC6:  MOVWF  xF3
6AC8:  MOVLW  14
6ACA:  MOVWF  xF4
6ACC:  MOVLW  01
6ACE:  MOVWF  xF6
6AD0:  MOVLW  62
6AD2:  MOVWF  xF5
6AD4:  MOVLB  0
6AD6:  CALL   5F36
6ADA:  CLRF   19
6ADC:  BTFSC  FF2.7
6ADE:  BSF    19.7
6AE0:  BCF    FF2.7
....................       printf("\n\r"); 
6AE2:  MOVLW  0A
6AE4:  MOVLB  9
6AE6:  MOVWF  x0C
6AE8:  MOVLB  0
6AEA:  CALL   1620
6AEE:  BTFSC  19.7
6AF0:  BSF    FF2.7
6AF2:  CLRF   19
6AF4:  BTFSC  FF2.7
6AF6:  BSF    19.7
6AF8:  BCF    FF2.7
6AFA:  MOVLW  0D
6AFC:  MOVLB  9
6AFE:  MOVWF  x0C
6B00:  MOVLB  0
6B02:  CALL   1620
6B06:  BTFSC  19.7
6B08:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
6B0A:  CLRF   FEA
6B0C:  MOVLW  41
6B0E:  MOVWF  FE9
6B10:  MOVLW  00
6B12:  CALL   0356
6B16:  TBLRD*-
6B18:  TBLRD*+
6B1A:  MOVF   FF5,W
6B1C:  MOVWF  FEE
6B1E:  IORLW  00
6B20:  BNZ   6B18
....................       index=0; 
6B22:  MOVLB  7
6B24:  CLRF   xBD
....................       ee_dat=0; 
6B26:  MOVLB  6
6B28:  CLRF   xDD
....................       count_card=1; 
6B2A:  CLRF   xDF
6B2C:  MOVLW  01
6B2E:  MOVWF  xDE
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6B30:  MOVLB  7
6B32:  MOVWF  xF4
6B34:  MOVLW  62
6B36:  MOVWF  xF3
6B38:  CLRF   xF6
6B3A:  MOVLW  41
6B3C:  MOVWF  xF5
6B3E:  MOVLB  0
6B40:  CALL   606E
6B44:  MOVF   01,F
6B46:  BNZ   6B5C
....................       { 
....................          if(cryption_enable==0) downloaddataregular(); 
6B48:  MOVLB  1
6B4A:  MOVF   x22,F
6B4C:  BNZ   6B58
6B4E:  MOVLB  0
6B50:  GOTO   6254
....................          else downloaddataEncrypt(); 
6B54:  MOVLB  0
6B56:  BRA    6B5C
6B58:  MOVLB  0
6B5A:  BRA    6656
....................       }  
....................       strcpy(buffer2,"f"); 
6B5C:  CLRF   FEA
6B5E:  MOVLW  41
6B60:  MOVWF  FE9
6B62:  MOVLW  00
6B64:  CALL   0368
6B68:  TBLRD*-
6B6A:  TBLRD*+
6B6C:  MOVF   FF5,W
6B6E:  MOVWF  FEE
6B70:  IORLW  00
6B72:  BNZ   6B6A
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6B74:  MOVLW  01
6B76:  MOVLB  7
6B78:  MOVWF  xF4
6B7A:  MOVLW  62
6B7C:  MOVWF  xF3
6B7E:  CLRF   xF6
6B80:  MOVLW  41
6B82:  MOVWF  xF5
6B84:  MOVLB  0
6B86:  CALL   606E
6B8A:  MOVF   01,F
6B8C:  BNZ   6BC0
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6B8E:  MOVLW  7E
6B90:  MOVWF  FF6
6B92:  MOVLW  1C
6B94:  MOVWF  FF7
6B96:  CLRF   19
6B98:  BTFSC  FF2.7
6B9A:  BSF    19.7
6B9C:  BCF    FF2.7
6B9E:  CALL   174A
6BA2:  BTFSC  19.7
6BA4:  BSF    FF2.7
....................          format_eepromext(); 
6BA6:  BRA    6876
....................          fprintf(COM2," exit\n\r");  
6BA8:  MOVLW  8C
6BAA:  MOVWF  FF6
6BAC:  MOVLW  1C
6BAE:  MOVWF  FF7
6BB0:  CLRF   19
6BB2:  BTFSC  FF2.7
6BB4:  BSF    19.7
6BB6:  BCF    FF2.7
6BB8:  CALL   174A
6BBC:  BTFSC  19.7
6BBE:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
6BC0:  CLRF   FEA
6BC2:  MOVLW  41
6BC4:  MOVWF  FE9
6BC6:  MOVLW  00
6BC8:  CALL   037A
6BCC:  TBLRD*-
6BCE:  TBLRD*+
6BD0:  MOVF   FF5,W
6BD2:  MOVWF  FEE
6BD4:  IORLW  00
6BD6:  BNZ   6BCE
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6BD8:  MOVLW  01
6BDA:  MOVLB  7
6BDC:  MOVWF  xF4
6BDE:  MOVLW  62
6BE0:  MOVWF  xF3
6BE2:  CLRF   xF6
6BE4:  MOVLW  41
6BE6:  MOVWF  xF5
6BE8:  MOVLB  0
6BEA:  CALL   606E
6BEE:  MOVF   01,F
6BF0:  BNZ   6C24
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6BF2:  MOVLW  94
6BF4:  MOVWF  FF6
6BF6:  MOVLW  1C
6BF8:  MOVWF  FF7
6BFA:  CLRF   19
6BFC:  BTFSC  FF2.7
6BFE:  BSF    19.7
6C00:  BCF    FF2.7
6C02:  CALL   174A
6C06:  BTFSC  19.7
6C08:  BSF    FF2.7
....................          ease_eeprom(); 
6C0A:  BRA    6912
....................          fprintf(COM2," exit\n\r");  
6C0C:  MOVLW  A2
6C0E:  MOVWF  FF6
6C10:  MOVLW  1C
6C12:  MOVWF  FF7
6C14:  CLRF   19
6C16:  BTFSC  FF2.7
6C18:  BSF    19.7
6C1A:  BCF    FF2.7
6C1C:  CALL   174A
6C20:  BTFSC  19.7
6C22:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6C24:  CLRF   FEA
6C26:  MOVLW  41
6C28:  MOVWF  FE9
6C2A:  MOVLW  00
6C2C:  CALL   0390
6C30:  TBLRD*-
6C32:  TBLRD*+
6C34:  MOVF   FF5,W
6C36:  MOVWF  FEE
6C38:  IORLW  00
6C3A:  BNZ   6C32
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6C3C:  MOVLW  01
6C3E:  MOVLB  7
6C40:  MOVWF  xF4
6C42:  MOVLW  62
6C44:  MOVWF  xF3
6C46:  CLRF   xF6
6C48:  MOVLW  41
6C4A:  MOVWF  xF5
6C4C:  MOVLB  0
6C4E:  CALL   606E
6C52:  MOVF   01,F
6C54:  BNZ   6C8C
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
6C56:  MOVLW  AA
6C58:  MOVWF  FF6
6C5A:  MOVLW  1C
6C5C:  MOVWF  FF7
6C5E:  CLRF   19
6C60:  BTFSC  FF2.7
6C62:  BSF    19.7
6C64:  BCF    FF2.7
6C66:  CALL   174A
6C6A:  BTFSC  19.7
6C6C:  BSF    FF2.7
....................          reset_password(); 
6C6E:  BRA    6996
....................          init_password(); 
6C70:  CALL   5CD6
....................          fprintf(COM2," exit\n\r");  
6C74:  MOVLW  C0
6C76:  MOVWF  FF6
6C78:  MOVLW  1C
6C7A:  MOVWF  FF7
6C7C:  CLRF   19
6C7E:  BTFSC  FF2.7
6C80:  BSF    19.7
6C82:  BCF    FF2.7
6C84:  CALL   174A
6C88:  BTFSC  19.7
6C8A:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
6C8C:  CLRF   FEA
6C8E:  MOVLW  41
6C90:  MOVWF  FE9
6C92:  MOVLW  00
6C94:  CALL   03A6
6C98:  TBLRD*-
6C9A:  TBLRD*+
6C9C:  MOVF   FF5,W
6C9E:  MOVWF  FEE
6CA0:  IORLW  00
6CA2:  BNZ   6C9A
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6CA4:  MOVLW  01
6CA6:  MOVLB  7
6CA8:  MOVWF  xF4
6CAA:  MOVLW  62
6CAC:  MOVWF  xF3
6CAE:  CLRF   xF6
6CB0:  MOVLW  41
6CB2:  MOVWF  xF5
6CB4:  MOVLB  0
6CB6:  CALL   606E
6CBA:  MOVF   01,F
6CBC:  BNZ   6CDE
....................       { 
....................          keydebug_en=1; 
6CBE:  MOVLW  01
6CC0:  MOVLB  1
6CC2:  MOVWF  x44
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
6CC4:  MOVLW  C8
6CC6:  MOVWF  FF6
6CC8:  MOVLW  1C
6CCA:  MOVWF  FF7
6CCC:  CLRF   19
6CCE:  BTFSC  FF2.7
6CD0:  BSF    19.7
6CD2:  BCF    FF2.7
6CD4:  MOVLB  0
6CD6:  CALL   174A
6CDA:  BTFSC  19.7
6CDC:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
6CDE:  CLRF   FEA
6CE0:  MOVLW  41
6CE2:  MOVWF  FE9
6CE4:  MOVLW  00
6CE6:  CALL   03BC
6CEA:  TBLRD*-
6CEC:  TBLRD*+
6CEE:  MOVF   FF5,W
6CF0:  MOVWF  FEE
6CF2:  IORLW  00
6CF4:  BNZ   6CEC
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6CF6:  MOVLW  01
6CF8:  MOVLB  7
6CFA:  MOVWF  xF4
6CFC:  MOVLW  62
6CFE:  MOVWF  xF3
6D00:  CLRF   xF6
6D02:  MOVLW  41
6D04:  MOVWF  xF5
6D06:  MOVLB  0
6D08:  CALL   606E
6D0C:  MOVF   01,F
6D0E:  BNZ   6D2A
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6D10:  MOVLW  DC
6D12:  MOVWF  FF6
6D14:  MOVLW  1C
6D16:  MOVWF  FF7
6D18:  CLRF   19
6D1A:  BTFSC  FF2.7
6D1C:  BSF    19.7
6D1E:  BCF    FF2.7
6D20:  CALL   174A
6D24:  BTFSC  19.7
6D26:  BSF    FF2.7
....................          rstfact(); 
6D28:  BRA    69E6
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
6D2A:  CLRF   FEA
6D2C:  MOVLW  41
6D2E:  MOVWF  FE9
6D30:  MOVLW  00
6D32:  CALL   03D4
6D36:  TBLRD*-
6D38:  TBLRD*+
6D3A:  MOVF   FF5,W
6D3C:  MOVWF  FEE
6D3E:  IORLW  00
6D40:  BNZ   6D38
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6D42:  MOVLW  01
6D44:  MOVLB  7
6D46:  MOVWF  xF4
6D48:  MOVLW  62
6D4A:  MOVWF  xF3
6D4C:  CLRF   xF6
6D4E:  MOVLW  41
6D50:  MOVWF  xF5
6D52:  MOVLB  0
6D54:  CALL   606E
6D58:  MOVF   01,F
6D5A:  BNZ   6D82
....................       { 
....................          mode=LOGOFF; 
6D5C:  MOVLB  6
6D5E:  CLRF   xDC
....................          keydebug_en=0; 
6D60:  MOVLB  1
6D62:  CLRF   x44
....................          set_tris_a(0xff); 
6D64:  MOVLW  FF
6D66:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
6D68:  MOVLW  EC
6D6A:  MOVWF  FF6
6D6C:  MOVLW  1C
6D6E:  MOVWF  FF7
6D70:  CLRF   19
6D72:  BTFSC  FF2.7
6D74:  BSF    19.7
6D76:  BCF    FF2.7
6D78:  MOVLB  0
6D7A:  CALL   174A
6D7E:  BTFSC  19.7
6D80:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
6D82:  CLRF   FEA
6D84:  MOVLW  41
6D86:  MOVWF  FE9
6D88:  MOVLW  00
6D8A:  CALL   03E6
6D8E:  TBLRD*-
6D90:  TBLRD*+
6D92:  MOVF   FF5,W
6D94:  MOVWF  FEE
6D96:  IORLW  00
6D98:  BNZ   6D90
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6D9A:  MOVLW  01
6D9C:  MOVLB  7
6D9E:  MOVWF  xF4
6DA0:  MOVLW  62
6DA2:  MOVWF  xF3
6DA4:  CLRF   xF6
6DA6:  MOVLW  41
6DA8:  MOVWF  xF5
6DAA:  MOVLB  0
6DAC:  CALL   606E
6DB0:  MOVF   01,F
6DB2:  BNZ   6E2C
....................       { 
....................          fprintf(COM2,"New console name>"); 
6DB4:  MOVLW  F4
6DB6:  MOVWF  FF6
6DB8:  MOVLW  1C
6DBA:  MOVWF  FF7
6DBC:  CLRF   19
6DBE:  BTFSC  FF2.7
6DC0:  BSF    19.7
6DC2:  BCF    FF2.7
6DC4:  CALL   174A
6DC8:  BTFSC  19.7
6DCA:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,wide_strobe_nameconsole, console); 
6DCC:  MOVLW  01
6DCE:  MOVLB  7
6DD0:  MOVWF  xF3
6DD2:  MOVLW  10
6DD4:  MOVWF  xF4
6DD6:  MOVLW  06
6DD8:  MOVWF  xF6
6DDA:  MOVLW  E7
6DDC:  MOVWF  xF5
6DDE:  MOVLB  0
6DE0:  CALL   5F36
6DE4:  CLRF   19
6DE6:  BTFSC  FF2.7
6DE8:  BSF    19.7
6DEA:  BCF    FF2.7
....................          EEPROM_write(strobe_nameconsole,wide_strobe_nameconsole,console); 
6DEC:  MOVLB  9
6DEE:  CLRF   x03
6DF0:  CLRF   x02
6DF2:  CLRF   x01
6DF4:  MOVLW  28
6DF6:  MOVWF  x00
6DF8:  CLRF   x07
6DFA:  CLRF   x06
6DFC:  CLRF   x05
6DFE:  MOVLW  10
6E00:  MOVWF  x04
6E02:  MOVLW  06
6E04:  MOVWF  x09
6E06:  MOVLW  E7
6E08:  MOVWF  x08
6E0A:  MOVLB  0
6E0C:  CALL   4DFE
6E10:  BTFSC  19.7
6E12:  BSF    FF2.7
....................          fprintf(COM2," OK\n\r"); 
6E14:  MOVLW  06
6E16:  MOVWF  FF6
6E18:  MOVLW  1D
6E1A:  MOVWF  FF7
6E1C:  CLRF   19
6E1E:  BTFSC  FF2.7
6E20:  BSF    19.7
6E22:  BCF    FF2.7
6E24:  CALL   174A
6E28:  BTFSC  19.7
6E2A:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
6E2C:  CLRF   FEA
6E2E:  MOVLW  41
6E30:  MOVWF  FE9
6E32:  MOVLW  00
6E34:  CALL   03F8
6E38:  TBLRD*-
6E3A:  TBLRD*+
6E3C:  MOVF   FF5,W
6E3E:  MOVWF  FEE
6E40:  IORLW  00
6E42:  BNZ   6E3A
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6E44:  MOVLW  01
6E46:  MOVLB  7
6E48:  MOVWF  xF4
6E4A:  MOVLW  62
6E4C:  MOVWF  xF3
6E4E:  CLRF   xF6
6E50:  MOVLW  41
6E52:  MOVWF  xF5
6E54:  MOVLB  0
6E56:  CALL   606E
6E5A:  MOVF   01,F
6E5C:  BTFSS  FD8.2
6E5E:  BRA    700E
6E60:  CLRF   19
6E62:  BTFSC  FF2.7
6E64:  BSF    19.7
6E66:  BCF    FF2.7
....................       { 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6E68:  MOVLB  9
6E6A:  CLRF   x1B
6E6C:  CLRF   x1A
6E6E:  CLRF   x19
6E70:  MOVLW  3A
6E72:  MOVWF  x18
6E74:  MOVLB  0
6E76:  CALL   3468
6E7A:  BTFSC  19.7
6E7C:  BSF    FF2.7
6E7E:  MOVFF  01,6E2
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6E82:  MOVLB  6
6E84:  MOVF   xE2,F
6E86:  BNZ   6EA6
6E88:  MOVLW  0C
6E8A:  MOVWF  FF6
6E8C:  MOVLW  1D
6E8E:  MOVWF  FF7
6E90:  CLRF   19
6E92:  BTFSC  FF2.7
6E94:  BSF    19.7
6E96:  BCF    FF2.7
6E98:  MOVLB  0
6E9A:  CALL   174A
6E9E:  BTFSC  19.7
6EA0:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6EA2:  BRA    6EC0
6EA4:  MOVLB  6
6EA6:  MOVLW  10
6EA8:  MOVWF  FF6
6EAA:  MOVLW  1D
6EAC:  MOVWF  FF7
6EAE:  CLRF   19
6EB0:  BTFSC  FF2.7
6EB2:  BSF    19.7
6EB4:  BCF    FF2.7
6EB6:  MOVLB  0
6EB8:  CALL   174A
6EBC:  BTFSC  19.7
6EBE:  BSF    FF2.7
6EC0:  CLRF   19
6EC2:  BTFSC  FF2.7
6EC4:  BSF    19.7
6EC6:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
6EC8:  MOVLB  9
6ECA:  CLRF   x1B
6ECC:  CLRF   x1A
6ECE:  CLRF   x19
6ED0:  MOVLW  3C
6ED2:  MOVWF  x18
6ED4:  MOVLB  0
6ED6:  CALL   3468
6EDA:  BTFSC  19.7
6EDC:  BSF    FF2.7
6EDE:  MOVFF  01,15A
6EE2:  CLRF   19
6EE4:  BTFSC  FF2.7
6EE6:  BSF    19.7
6EE8:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
6EEA:  MOVLW  5B
6EEC:  MOVLB  9
6EEE:  MOVWF  x0C
6EF0:  MOVLB  0
6EF2:  CALL   1620
6EF6:  BTFSC  19.7
6EF8:  BSF    FF2.7
6EFA:  CLRF   19
6EFC:  BTFSC  FF2.7
6EFE:  BSF    19.7
6F00:  BCF    FF2.7
6F02:  MOVFF  15A,900
6F06:  MOVLW  1B
6F08:  MOVLB  9
6F0A:  MOVWF  x01
6F0C:  MOVLB  0
6F0E:  CALL   400E
6F12:  BTFSC  19.7
6F14:  BSF    FF2.7
6F16:  CLRF   19
6F18:  BTFSC  FF2.7
6F1A:  BSF    19.7
6F1C:  BCF    FF2.7
6F1E:  MOVLW  5D
6F20:  MOVLB  9
6F22:  MOVWF  x0C
6F24:  MOVLB  0
6F26:  CALL   1620
6F2A:  BTFSC  19.7
6F2C:  BSF    FF2.7
....................           
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
6F2E:  MOVFF  1CB,82B
6F32:  MOVLW  01
6F34:  MOVLB  8
6F36:  MOVWF  x2C
6F38:  MOVLB  0
6F3A:  CALL   613A
6F3E:  CLRF   19
6F40:  BTFSC  FF2.7
6F42:  BSF    19.7
6F44:  BCF    FF2.7
6F46:  MOVLW  2F
6F48:  MOVLB  9
6F4A:  MOVWF  x0C
6F4C:  MOVLB  0
6F4E:  CALL   1620
6F52:  BTFSC  19.7
6F54:  BSF    FF2.7
6F56:  MOVFF  1CA,82B
6F5A:  MOVLW  01
6F5C:  MOVLB  8
6F5E:  MOVWF  x2C
6F60:  MOVLB  0
6F62:  CALL   613A
6F66:  CLRF   19
6F68:  BTFSC  FF2.7
6F6A:  BSF    19.7
6F6C:  BCF    FF2.7
6F6E:  MOVLW  20
6F70:  MOVLB  9
6F72:  MOVWF  x0C
6F74:  MOVLB  0
6F76:  CALL   1620
6F7A:  BTFSC  19.7
6F7C:  BSF    FF2.7
6F7E:  MOVFF  1CC,82B
6F82:  MOVLW  01
6F84:  MOVLB  8
6F86:  MOVWF  x2C
6F88:  MOVLB  0
6F8A:  CALL   613A
6F8E:  CLRF   19
6F90:  BTFSC  FF2.7
6F92:  BSF    19.7
6F94:  BCF    FF2.7
6F96:  MOVLW  3A
6F98:  MOVLB  9
6F9A:  MOVWF  x0C
6F9C:  MOVLB  0
6F9E:  CALL   1620
6FA2:  BTFSC  19.7
6FA4:  BSF    FF2.7
6FA6:  MOVFF  1CD,82B
6FAA:  MOVLW  01
6FAC:  MOVLB  8
6FAE:  MOVWF  x2C
6FB0:  MOVLB  0
6FB2:  CALL   613A
6FB6:  CLRF   19
6FB8:  BTFSC  FF2.7
6FBA:  BSF    19.7
6FBC:  BCF    FF2.7
6FBE:  MOVLW  3A
6FC0:  MOVLB  9
6FC2:  MOVWF  x0C
6FC4:  MOVLB  0
6FC6:  CALL   1620
6FCA:  BTFSC  19.7
6FCC:  BSF    FF2.7
6FCE:  MOVFF  1CE,82B
6FD2:  MOVLW  01
6FD4:  MOVLB  8
6FD6:  MOVWF  x2C
6FD8:  MOVLB  0
6FDA:  CALL   613A
6FDE:  CLRF   19
6FE0:  BTFSC  FF2.7
6FE2:  BSF    19.7
6FE4:  BCF    FF2.7
....................           
....................          fprintf(COM2,"\n\r"); 
6FE6:  MOVLW  0A
6FE8:  MOVLB  9
6FEA:  MOVWF  x0C
6FEC:  MOVLB  0
6FEE:  CALL   1620
6FF2:  BTFSC  19.7
6FF4:  BSF    FF2.7
6FF6:  CLRF   19
6FF8:  BTFSC  FF2.7
6FFA:  BSF    19.7
6FFC:  BCF    FF2.7
6FFE:  MOVLW  0D
7000:  MOVLB  9
7002:  MOVWF  x0C
7004:  MOVLB  0
7006:  CALL   1620
700A:  BTFSC  19.7
700C:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
700E:  CLRF   FEA
7010:  MOVLW  41
7012:  MOVWF  FE9
7014:  MOVLW  00
7016:  CALL   040A
701A:  TBLRD*-
701C:  TBLRD*+
701E:  MOVF   FF5,W
7020:  MOVWF  FEE
7022:  IORLW  00
7024:  BNZ   701C
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7026:  MOVLW  01
7028:  MOVLB  7
702A:  MOVWF  xF4
702C:  MOVLW  62
702E:  MOVWF  xF3
7030:  CLRF   xF6
7032:  MOVLW  41
7034:  MOVWF  xF5
7036:  MOVLB  0
7038:  CALL   606E
703C:  MOVF   01,F
703E:  BTFSS  FD8.2
7040:  BRA    7240
....................       { 
....................          fprintf(COM2,"Year>"); 
7042:  MOVLW  14
7044:  MOVWF  FF6
7046:  MOVLW  1D
7048:  MOVWF  FF7
704A:  CLRF   19
704C:  BTFSC  FF2.7
704E:  BSF    19.7
7050:  BCF    FF2.7
7052:  CALL   174A
7056:  BTFSC  19.7
7058:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
705A:  MOVLW  01
705C:  MOVLB  7
705E:  MOVWF  xF3
7060:  MOVLW  03
7062:  MOVWF  xF4
7064:  MOVLW  07
7066:  MOVWF  xF6
7068:  MOVLW  C1
706A:  MOVWF  xF5
706C:  MOVLB  0
706E:  CALL   5F36
....................          year=(unsigned int8)strtoi(temp); 
7072:  MOVLW  07
7074:  MOVLB  7
7076:  MOVWF  xF4
7078:  MOVLW  C1
707A:  MOVWF  xF3
707C:  MOVLB  0
707E:  RCALL  6A50
7080:  MOVFF  01,1C9
....................          fprintf(COM2,"Month>"); 
7084:  MOVLW  1A
7086:  MOVWF  FF6
7088:  MOVLW  1D
708A:  MOVWF  FF7
708C:  CLRF   19
708E:  BTFSC  FF2.7
7090:  BSF    19.7
7092:  BCF    FF2.7
7094:  CALL   174A
7098:  BTFSC  19.7
709A:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
709C:  MOVLW  01
709E:  MOVLB  7
70A0:  MOVWF  xF3
70A2:  MOVLW  03
70A4:  MOVWF  xF4
70A6:  MOVLW  07
70A8:  MOVWF  xF6
70AA:  MOVLW  C1
70AC:  MOVWF  xF5
70AE:  MOVLB  0
70B0:  CALL   5F36
....................          mon=(unsigned int8)strtoi(temp); 
70B4:  MOVLW  07
70B6:  MOVLB  7
70B8:  MOVWF  xF4
70BA:  MOVLW  C1
70BC:  MOVWF  xF3
70BE:  MOVLB  0
70C0:  RCALL  6A50
70C2:  MOVFF  01,1CA
....................          fprintf(COM2,"Date>"); 
70C6:  MOVLW  22
70C8:  MOVWF  FF6
70CA:  MOVLW  1D
70CC:  MOVWF  FF7
70CE:  CLRF   19
70D0:  BTFSC  FF2.7
70D2:  BSF    19.7
70D4:  BCF    FF2.7
70D6:  CALL   174A
70DA:  BTFSC  19.7
70DC:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
70DE:  MOVLW  01
70E0:  MOVLB  7
70E2:  MOVWF  xF3
70E4:  MOVLW  03
70E6:  MOVWF  xF4
70E8:  MOVLW  07
70EA:  MOVWF  xF6
70EC:  MOVLW  C1
70EE:  MOVWF  xF5
70F0:  MOVLB  0
70F2:  CALL   5F36
....................          date = (unsigned int8)strtoi(temp); 
70F6:  MOVLW  07
70F8:  MOVLB  7
70FA:  MOVWF  xF4
70FC:  MOVLW  C1
70FE:  MOVWF  xF3
7100:  MOVLB  0
7102:  RCALL  6A50
7104:  MOVFF  01,1CB
....................          fprintf(COM2,"Day>"); 
7108:  MOVLW  28
710A:  MOVWF  FF6
710C:  MOVLW  1D
710E:  MOVWF  FF7
7110:  CLRF   19
7112:  BTFSC  FF2.7
7114:  BSF    19.7
7116:  BCF    FF2.7
7118:  CALL   174A
711C:  BTFSC  19.7
711E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7120:  MOVLW  01
7122:  MOVLB  7
7124:  MOVWF  xF3
7126:  MOVLW  03
7128:  MOVWF  xF4
712A:  MOVLW  07
712C:  MOVWF  xF6
712E:  MOVLW  C1
7130:  MOVWF  xF5
7132:  MOVLB  0
7134:  CALL   5F36
....................          day = (unsigned int8)strtoi(temp); 
7138:  MOVLW  07
713A:  MOVLB  7
713C:  MOVWF  xF4
713E:  MOVLW  C1
7140:  MOVWF  xF3
7142:  MOVLB  0
7144:  RCALL  6A50
7146:  MOVFF  01,1C8
....................          fprintf(COM2,"Hour>"); 
714A:  MOVLW  2E
714C:  MOVWF  FF6
714E:  MOVLW  1D
7150:  MOVWF  FF7
7152:  CLRF   19
7154:  BTFSC  FF2.7
7156:  BSF    19.7
7158:  BCF    FF2.7
715A:  CALL   174A
715E:  BTFSC  19.7
7160:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7162:  MOVLW  01
7164:  MOVLB  7
7166:  MOVWF  xF3
7168:  MOVLW  03
716A:  MOVWF  xF4
716C:  MOVLW  07
716E:  MOVWF  xF6
7170:  MOVLW  C1
7172:  MOVWF  xF5
7174:  MOVLB  0
7176:  CALL   5F36
....................          h = (unsigned int8)strtoi(temp); 
717A:  MOVLW  07
717C:  MOVLB  7
717E:  MOVWF  xF4
7180:  MOVLW  C1
7182:  MOVWF  xF3
7184:  MOVLB  0
7186:  RCALL  6A50
7188:  MOVFF  01,1CC
....................          fprintf(COM2,"Minutes>"); 
718C:  MOVLW  34
718E:  MOVWF  FF6
7190:  MOVLW  1D
7192:  MOVWF  FF7
7194:  CLRF   19
7196:  BTFSC  FF2.7
7198:  BSF    19.7
719A:  BCF    FF2.7
719C:  CALL   174A
71A0:  BTFSC  19.7
71A2:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
71A4:  MOVLW  01
71A6:  MOVLB  7
71A8:  MOVWF  xF3
71AA:  MOVLW  03
71AC:  MOVWF  xF4
71AE:  MOVLW  07
71B0:  MOVWF  xF6
71B2:  MOVLW  C1
71B4:  MOVWF  xF5
71B6:  MOVLB  0
71B8:  CALL   5F36
....................          min = (unsigned int8)strtoi(temp);                   
71BC:  MOVLW  07
71BE:  MOVLB  7
71C0:  MOVWF  xF4
71C2:  MOVLW  C1
71C4:  MOVWF  xF3
71C6:  MOVLB  0
71C8:  RCALL  6A50
71CA:  MOVFF  01,1CD
....................          fprintf(COM2,"Seconds>"); 
71CE:  MOVLW  3E
71D0:  MOVWF  FF6
71D2:  MOVLW  1D
71D4:  MOVWF  FF7
71D6:  CLRF   19
71D8:  BTFSC  FF2.7
71DA:  BSF    19.7
71DC:  BCF    FF2.7
71DE:  CALL   174A
71E2:  BTFSC  19.7
71E4:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
71E6:  MOVLW  01
71E8:  MOVLB  7
71EA:  MOVWF  xF3
71EC:  MOVLW  03
71EE:  MOVWF  xF4
71F0:  MOVLW  07
71F2:  MOVWF  xF6
71F4:  MOVLW  C1
71F6:  MOVWF  xF5
71F8:  MOVLB  0
71FA:  CALL   5F36
....................          sec = (unsigned int8)strtoi(temp);                   
71FE:  MOVLW  07
7200:  MOVLB  7
7202:  MOVWF  xF4
7204:  MOVLW  C1
7206:  MOVWF  xF3
7208:  MOVLB  0
720A:  RCALL  6A50
720C:  MOVFF  01,1CE
7210:  CLRF   19
7212:  BTFSC  FF2.7
7214:  BSF    19.7
7216:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
7218:  MOVLW  0A
721A:  MOVLB  9
721C:  MOVWF  x0C
721E:  MOVLB  0
7220:  CALL   1620
7224:  BTFSC  19.7
7226:  BSF    FF2.7
7228:  CLRF   19
722A:  BTFSC  FF2.7
722C:  BSF    19.7
722E:  BCF    FF2.7
7230:  MOVLW  0D
7232:  MOVLB  9
7234:  MOVWF  x0C
7236:  MOVLB  0
7238:  CALL   1620
723C:  BTFSC  19.7
723E:  BSF    FF2.7
....................          /* rtc_set_datetime(date,mon,year,day,h,min); */ 
....................       } 
....................       strcpy(buffer2,"MS"); 
7240:  CLRF   FEA
7242:  MOVLW  41
7244:  MOVWF  FE9
7246:  MOVLW  00
7248:  CALL   041E
724C:  TBLRD*-
724E:  TBLRD*+
7250:  MOVF   FF5,W
7252:  MOVWF  FEE
7254:  IORLW  00
7256:  BNZ   724E
....................       if(!stringcomp(buffer_uart,buffer2)) 
7258:  MOVLW  01
725A:  MOVLB  7
725C:  MOVWF  xF4
725E:  MOVLW  62
7260:  MOVWF  xF3
7262:  CLRF   xF6
7264:  MOVLW  41
7266:  MOVWF  xF5
7268:  MOVLB  0
726A:  CALL   606E
726E:  MOVF   01,F
7270:  BTFSS  FD8.2
7272:  BRA    7386
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
7274:  MOVLW  48
7276:  MOVWF  FF6
7278:  MOVLW  1D
727A:  MOVWF  FF7
727C:  CLRF   19
727E:  BTFSC  FF2.7
7280:  BSF    19.7
7282:  BCF    FF2.7
7284:  CALL   174A
7288:  BTFSC  19.7
728A:  BSF    FF2.7
728C:  CLRF   19
728E:  BTFSC  FF2.7
7290:  BSF    19.7
7292:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7294:  MOVLW  0A
7296:  MOVLB  9
7298:  MOVWF  x0C
729A:  MOVLB  0
729C:  CALL   1620
72A0:  BTFSC  19.7
72A2:  BSF    FF2.7
72A4:  CLRF   19
72A6:  BTFSC  FF2.7
72A8:  BSF    19.7
72AA:  BCF    FF2.7
72AC:  MOVLW  0D
72AE:  MOVLB  9
72B0:  MOVWF  x0C
72B2:  MOVLB  0
72B4:  CALL   1620
72B8:  BTFSC  19.7
72BA:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
72BC:  MOVLW  68
72BE:  MOVWF  FF6
72C0:  MOVLW  1D
72C2:  MOVWF  FF7
72C4:  CLRF   19
72C6:  BTFSC  FF2.7
72C8:  BSF    19.7
72CA:  BCF    FF2.7
72CC:  CALL   174A
72D0:  BTFSC  19.7
72D2:  BSF    FF2.7
72D4:  CLRF   19
72D6:  BTFSC  FF2.7
72D8:  BSF    19.7
72DA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
72DC:  MOVLW  0A
72DE:  MOVLB  9
72E0:  MOVWF  x0C
72E2:  MOVLB  0
72E4:  CALL   1620
72E8:  BTFSC  19.7
72EA:  BSF    FF2.7
72EC:  CLRF   19
72EE:  BTFSC  FF2.7
72F0:  BSF    19.7
72F2:  BCF    FF2.7
72F4:  MOVLW  0D
72F6:  MOVLB  9
72F8:  MOVWF  x0C
72FA:  MOVLB  0
72FC:  CALL   1620
7300:  BTFSC  19.7
7302:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7304:  MOVLW  01
7306:  MOVLB  7
7308:  MOVWF  xF3
730A:  MOVLW  03
730C:  MOVWF  xF4
730E:  MOVLW  07
7310:  MOVWF  xF6
7312:  MOVLW  C1
7314:  MOVWF  xF5
7316:  MOVLB  0
7318:  CALL   5F36
....................           mode_sl = (unsigned int8)strtoi(temp); 
731C:  MOVLW  07
731E:  MOVLB  7
7320:  MOVWF  xF4
7322:  MOVLW  C1
7324:  MOVWF  xF3
7326:  MOVLB  0
7328:  CALL   6A50
732C:  MOVFF  01,6E2
7330:  CLRF   19
7332:  BTFSC  FF2.7
7334:  BSF    19.7
7336:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
7338:  MOVLB  9
733A:  CLRF   x16
733C:  CLRF   x15
733E:  CLRF   x14
7340:  MOVLW  3A
7342:  MOVWF  x13
7344:  MOVFF  6E2,917
7348:  MOVLB  0
734A:  CALL   3A80
734E:  BTFSC  19.7
7350:  BSF    FF2.7
....................           set_tris_a(0xff); 
7352:  MOVLW  FF
7354:  MOVWF  F92
7356:  CLRF   19
7358:  BTFSC  FF2.7
735A:  BSF    19.7
735C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
735E:  MOVLW  0A
7360:  MOVLB  9
7362:  MOVWF  x0C
7364:  MOVLB  0
7366:  CALL   1620
736A:  BTFSC  19.7
736C:  BSF    FF2.7
736E:  CLRF   19
7370:  BTFSC  FF2.7
7372:  BSF    19.7
7374:  BCF    FF2.7
7376:  MOVLW  0D
7378:  MOVLB  9
737A:  MOVWF  x0C
737C:  MOVLB  0
737E:  CALL   1620
7382:  BTFSC  19.7
7384:  BSF    FF2.7
....................       } 
....................       
....................       strcpy(buffer2,"tran time"); 
7386:  CLRF   FEA
7388:  MOVLW  41
738A:  MOVWF  FE9
738C:  MOVLW  00
738E:  CALL   0432
7392:  TBLRD*-
7394:  TBLRD*+
7396:  MOVF   FF5,W
7398:  MOVWF  FEE
739A:  IORLW  00
739C:  BNZ   7394
....................       if(!stringcomp(buffer_uart,buffer2)) 
739E:  MOVLW  01
73A0:  MOVLB  7
73A2:  MOVWF  xF4
73A4:  MOVLW  62
73A6:  MOVWF  xF3
73A8:  CLRF   xF6
73AA:  MOVLW  41
73AC:  MOVWF  xF5
73AE:  MOVLB  0
73B0:  CALL   606E
73B4:  MOVF   01,F
73B6:  BNZ   747E
....................       { 
....................           fprintf(COM2,"Input Number"); 
73B8:  MOVLW  88
73BA:  MOVWF  FF6
73BC:  MOVLW  1D
73BE:  MOVWF  FF7
73C0:  CLRF   19
73C2:  BTFSC  FF2.7
73C4:  BSF    19.7
73C6:  BCF    FF2.7
73C8:  CALL   174A
73CC:  BTFSC  19.7
73CE:  BSF    FF2.7
73D0:  CLRF   19
73D2:  BTFSC  FF2.7
73D4:  BSF    19.7
73D6:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
73D8:  MOVLW  0A
73DA:  MOVLB  9
73DC:  MOVWF  x0C
73DE:  MOVLB  0
73E0:  CALL   1620
73E4:  BTFSC  19.7
73E6:  BSF    FF2.7
73E8:  CLRF   19
73EA:  BTFSC  FF2.7
73EC:  BSF    19.7
73EE:  BCF    FF2.7
73F0:  MOVLW  0D
73F2:  MOVLB  9
73F4:  MOVWF  x0C
73F6:  MOVLB  0
73F8:  CALL   1620
73FC:  BTFSC  19.7
73FE:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7400:  MOVLW  01
7402:  MOVLB  7
7404:  MOVWF  xF3
7406:  MOVLW  03
7408:  MOVWF  xF4
740A:  MOVLW  07
740C:  MOVWF  xF6
740E:  MOVLW  C1
7410:  MOVWF  xF5
7412:  MOVLB  0
7414:  CALL   5F36
....................           delaycharaction = (unsigned int8)strtoi(temp); 
7418:  MOVLW  07
741A:  MOVLB  7
741C:  MOVWF  xF4
741E:  MOVLW  C1
7420:  MOVWF  xF3
7422:  MOVLB  0
7424:  CALL   6A50
7428:  MOVFF  01,15A
742C:  CLRF   19
742E:  BTFSC  FF2.7
7430:  BSF    19.7
7432:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
7434:  MOVLB  9
7436:  CLRF   x16
7438:  CLRF   x15
743A:  CLRF   x14
743C:  MOVLW  3C
743E:  MOVWF  x13
7440:  MOVFF  15A,917
7444:  MOVLB  0
7446:  CALL   3A80
744A:  BTFSC  19.7
744C:  BSF    FF2.7
744E:  CLRF   19
7450:  BTFSC  FF2.7
7452:  BSF    19.7
7454:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7456:  MOVLW  0A
7458:  MOVLB  9
745A:  MOVWF  x0C
745C:  MOVLB  0
745E:  CALL   1620
7462:  BTFSC  19.7
7464:  BSF    FF2.7
7466:  CLRF   19
7468:  BTFSC  FF2.7
746A:  BSF    19.7
746C:  BCF    FF2.7
746E:  MOVLW  0D
7470:  MOVLB  9
7472:  MOVWF  x0C
7474:  MOVLB  0
7476:  CALL   1620
747A:  BTFSC  19.7
747C:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
747E:  CLRF   FEA
7480:  MOVLW  41
7482:  MOVWF  FE9
7484:  MOVLW  00
7486:  CALL   044C
748A:  TBLRD*-
748C:  TBLRD*+
748E:  MOVF   FF5,W
7490:  MOVWF  FEE
7492:  IORLW  00
7494:  BNZ   748C
....................       if(!stringcomp(buffer_uart,buffer2)) 
7496:  MOVLW  01
7498:  MOVLB  7
749A:  MOVWF  xF4
749C:  MOVLW  62
749E:  MOVWF  xF3
74A0:  CLRF   xF6
74A2:  MOVLW  41
74A4:  MOVWF  xF5
74A6:  MOVLB  0
74A8:  CALL   606E
74AC:  MOVF   01,F
74AE:  BTFSS  FD8.2
74B0:  BRA    75C0
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
74B2:  MOVLW  96
74B4:  MOVWF  FF6
74B6:  MOVLW  1D
74B8:  MOVWF  FF7
74BA:  CLRF   19
74BC:  BTFSC  FF2.7
74BE:  BSF    19.7
74C0:  BCF    FF2.7
74C2:  CALL   174A
74C6:  BTFSC  19.7
74C8:  BSF    FF2.7
74CA:  CLRF   19
74CC:  BTFSC  FF2.7
74CE:  BSF    19.7
74D0:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
74D2:  MOVLW  0A
74D4:  MOVLB  9
74D6:  MOVWF  x0C
74D8:  MOVLB  0
74DA:  CALL   1620
74DE:  BTFSC  19.7
74E0:  BSF    FF2.7
74E2:  CLRF   19
74E4:  BTFSC  FF2.7
74E6:  BSF    19.7
74E8:  BCF    FF2.7
74EA:  MOVLW  0D
74EC:  MOVLB  9
74EE:  MOVWF  x0C
74F0:  MOVLB  0
74F2:  CALL   1620
74F6:  BTFSC  19.7
74F8:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
74FA:  MOVLW  BC
74FC:  MOVWF  FF6
74FE:  MOVLW  1D
7500:  MOVWF  FF7
7502:  CLRF   19
7504:  BTFSC  FF2.7
7506:  BSF    19.7
7508:  BCF    FF2.7
750A:  CALL   174A
750E:  BTFSC  19.7
7510:  BSF    FF2.7
7512:  CLRF   19
7514:  BTFSC  FF2.7
7516:  BSF    19.7
7518:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
751A:  MOVLW  0A
751C:  MOVLB  9
751E:  MOVWF  x0C
7520:  MOVLB  0
7522:  CALL   1620
7526:  BTFSC  19.7
7528:  BSF    FF2.7
752A:  CLRF   19
752C:  BTFSC  FF2.7
752E:  BSF    19.7
7530:  BCF    FF2.7
7532:  MOVLW  0D
7534:  MOVLB  9
7536:  MOVWF  x0C
7538:  MOVLB  0
753A:  CALL   1620
753E:  BTFSC  19.7
7540:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7542:  MOVLW  01
7544:  MOVLB  7
7546:  MOVWF  xF3
7548:  MOVLW  03
754A:  MOVWF  xF4
754C:  MOVLW  07
754E:  MOVWF  xF6
7550:  MOVLW  C1
7552:  MOVWF  xF5
7554:  MOVLB  0
7556:  CALL   5F36
....................           type_KB=(unsigned int8)strtoi(temp); 
755A:  MOVLW  07
755C:  MOVLB  7
755E:  MOVWF  xF4
7560:  MOVLW  C1
7562:  MOVWF  xF3
7564:  MOVLB  0
7566:  CALL   6A50
756A:  MOVFF  01,149
756E:  CLRF   19
7570:  BTFSC  FF2.7
7572:  BSF    19.7
7574:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
7576:  MOVLB  9
7578:  CLRF   x16
757A:  CLRF   x15
757C:  CLRF   x14
757E:  MOVLW  3D
7580:  MOVWF  x13
7582:  MOVFF  149,917
7586:  MOVLB  0
7588:  CALL   3A80
758C:  BTFSC  19.7
758E:  BSF    FF2.7
7590:  CLRF   19
7592:  BTFSC  FF2.7
7594:  BSF    19.7
7596:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
7598:  MOVLW  0A
759A:  MOVLB  9
759C:  MOVWF  x0C
759E:  MOVLB  0
75A0:  CALL   1620
75A4:  BTFSC  19.7
75A6:  BSF    FF2.7
75A8:  CLRF   19
75AA:  BTFSC  FF2.7
75AC:  BSF    19.7
75AE:  BCF    FF2.7
75B0:  MOVLW  0D
75B2:  MOVLB  9
75B4:  MOVWF  x0C
75B6:  MOVLB  0
75B8:  CALL   1620
75BC:  BTFSC  19.7
75BE:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       strcpy(buffer2,"h"); 
75C0:  CLRF   FEA
75C2:  MOVLW  41
75C4:  MOVWF  FE9
75C6:  MOVLW  00
75C8:  CALL   0462
75CC:  TBLRD*-
75CE:  TBLRD*+
75D0:  MOVF   FF5,W
75D2:  MOVWF  FEE
75D4:  IORLW  00
75D6:  BNZ   75CE
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
75D8:  MOVLW  01
75DA:  MOVLB  7
75DC:  MOVWF  xF4
75DE:  MOVLW  62
75E0:  MOVWF  xF3
75E2:  CLRF   xF6
75E4:  MOVLW  41
75E6:  MOVWF  xF5
75E8:  MOVLB  0
75EA:  CALL   606E
75EE:  MOVF   01,F
75F0:  BTFSS  FD8.2
75F2:  BRA    7762
....................       { 
....................          printf("h-> Help\n\r"); 
75F4:  MOVLW  E2
75F6:  MOVWF  FF6
75F8:  MOVLW  1D
75FA:  MOVWF  FF7
75FC:  CLRF   19
75FE:  BTFSC  FF2.7
7600:  BSF    19.7
7602:  BCF    FF2.7
7604:  CALL   174A
7608:  BTFSC  19.7
760A:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
760C:  MOVLW  EE
760E:  MOVWF  FF6
7610:  MOVLW  1D
7612:  MOVWF  FF7
7614:  CLRF   19
7616:  BTFSC  FF2.7
7618:  BSF    19.7
761A:  BCF    FF2.7
761C:  CALL   174A
7620:  BTFSC  19.7
7622:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
7624:  MOVLW  00
7626:  MOVWF  FF6
7628:  MOVLW  1E
762A:  MOVWF  FF7
762C:  CLRF   19
762E:  BTFSC  FF2.7
7630:  BSF    19.7
7632:  BCF    FF2.7
7634:  CALL   174A
7638:  BTFSC  19.7
763A:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
763C:  MOVLW  12
763E:  MOVWF  FF6
7640:  MOVLW  1E
7642:  MOVWF  FF7
7644:  CLRF   19
7646:  BTFSC  FF2.7
7648:  BSF    19.7
764A:  BCF    FF2.7
764C:  CALL   174A
7650:  BTFSC  19.7
7652:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
7654:  MOVLW  32
7656:  MOVWF  FF6
7658:  MOVLW  1E
765A:  MOVWF  FF7
765C:  CLRF   19
765E:  BTFSC  FF2.7
7660:  BSF    19.7
7662:  BCF    FF2.7
7664:  CALL   174A
7668:  BTFSC  19.7
766A:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
766C:  MOVLW  4E
766E:  MOVWF  FF6
7670:  MOVLW  1E
7672:  MOVWF  FF7
7674:  CLRF   19
7676:  BTFSC  FF2.7
7678:  BSF    19.7
767A:  BCF    FF2.7
767C:  CALL   174A
7680:  BTFSC  19.7
7682:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
7684:  MOVLW  5C
7686:  MOVWF  FF6
7688:  MOVLW  1E
768A:  MOVWF  FF7
768C:  CLRF   19
768E:  BTFSC  FF2.7
7690:  BSF    19.7
7692:  BCF    FF2.7
7694:  CALL   174A
7698:  BTFSC  19.7
769A:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
769C:  MOVLW  68
769E:  MOVWF  FF6
76A0:  MOVLW  1E
76A2:  MOVWF  FF7
76A4:  CLRF   19
76A6:  BTFSC  FF2.7
76A8:  BSF    19.7
76AA:  BCF    FF2.7
76AC:  CALL   174A
76B0:  BTFSC  19.7
76B2:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
76B4:  MOVLW  90
76B6:  MOVWF  FF6
76B8:  MOVLW  1E
76BA:  MOVWF  FF7
76BC:  CLRF   19
76BE:  BTFSC  FF2.7
76C0:  BSF    19.7
76C2:  BCF    FF2.7
76C4:  CALL   174A
76C8:  BTFSC  19.7
76CA:  BSF    FF2.7
76CC:  CLRF   19
76CE:  BTFSC  FF2.7
76D0:  BSF    19.7
76D2:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
76D4:  MOVLB  9
76D6:  CLRF   x1B
76D8:  CLRF   x1A
76DA:  CLRF   x19
76DC:  MOVLW  3D
76DE:  MOVWF  x18
76E0:  MOVLB  0
76E2:  CALL   3468
76E6:  BTFSC  19.7
76E8:  BSF    FF2.7
76EA:  MOVFF  01,7F3
76EE:  MOVLW  AC
76F0:  MOVWF  FF6
76F2:  MOVLW  1E
76F4:  MOVWF  FF7
76F6:  CLRF   19
76F8:  BTFSC  FF2.7
76FA:  BSF    19.7
76FC:  BCF    FF2.7
76FE:  MOVLW  06
7700:  MOVLB  9
7702:  MOVWF  x00
7704:  MOVLB  0
7706:  CALL   1666
770A:  BTFSC  19.7
770C:  BSF    FF2.7
770E:  CLRF   19
7710:  BTFSC  FF2.7
7712:  BSF    19.7
7714:  BCF    FF2.7
7716:  MOVFF  7F3,859
771A:  MOVLW  18
771C:  MOVLB  8
771E:  MOVWF  x5A
7720:  MOVLB  0
7722:  CALL   1796
7726:  BTFSC  19.7
7728:  BSF    FF2.7
772A:  MOVLW  B4
772C:  MOVWF  FF6
772E:  MOVLW  1E
7730:  MOVWF  FF7
7732:  CLRF   19
7734:  BTFSC  FF2.7
7736:  BSF    19.7
7738:  BCF    FF2.7
773A:  MOVLW  1D
773C:  MOVLB  9
773E:  MOVWF  x00
7740:  MOVLB  0
7742:  CALL   1666
7746:  BTFSC  19.7
7748:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
774A:  MOVLW  D2
774C:  MOVWF  FF6
774E:  MOVLW  1E
7750:  MOVWF  FF7
7752:  CLRF   19
7754:  BTFSC  FF2.7
7756:  BSF    19.7
7758:  BCF    FF2.7
775A:  CALL   174A
775E:  BTFSC  19.7
7760:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................       } 
....................       strcpy(buffer2,"password"); 
7762:  CLRF   FEA
7764:  MOVLW  41
7766:  MOVWF  FE9
7768:  MOVLW  00
776A:  CALL   0474
776E:  TBLRD*-
7770:  TBLRD*+
7772:  MOVF   FF5,W
7774:  MOVWF  FEE
7776:  IORLW  00
7778:  BNZ   7770
....................       if(!stringcomp(buffer_uart,buffer2))  
777A:  MOVLW  01
777C:  MOVLB  7
777E:  MOVWF  xF4
7780:  MOVLW  62
7782:  MOVWF  xF3
7784:  CLRF   xF6
7786:  MOVLW  41
7788:  MOVWF  xF5
778A:  MOVLB  0
778C:  CALL   606E
7790:  MOVF   01,F
7792:  BTFSS  FD8.2
7794:  BRA    78F4
....................       { 
....................          fprintf(COM2,"old password:"); 
7796:  MOVLW  EC
7798:  MOVWF  FF6
779A:  MOVLW  1E
779C:  MOVWF  FF7
779E:  CLRF   19
77A0:  BTFSC  FF2.7
77A2:  BSF    19.7
77A4:  BCF    FF2.7
77A6:  CALL   174A
77AA:  BTFSC  19.7
77AC:  BSF    FF2.7
77AE:  CLRF   19
77B0:  BTFSC  FF2.7
77B2:  BSF    19.7
77B4:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
77B6:  MOVLB  9
77B8:  CLRF   x07
77BA:  CLRF   x06
77BC:  CLRF   x05
77BE:  CLRF   x04
77C0:  CLRF   x0B
77C2:  CLRF   x0A
77C4:  CLRF   x09
77C6:  MOVLW  14
77C8:  MOVWF  x08
77CA:  CLRF   x0D
77CC:  MOVLW  55
77CE:  MOVWF  x0C
77D0:  MOVLB  0
77D2:  CALL   4094
77D6:  BTFSC  19.7
77D8:  BSF    FF2.7
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
77DA:  MOVLW  02
77DC:  MOVLB  7
77DE:  MOVWF  xF3
77E0:  MOVLW  14
77E2:  MOVWF  xF4
77E4:  CLRF   xF6
77E6:  MOVLW  69
77E8:  MOVWF  xF5
77EA:  MOVLB  0
77EC:  CALL   5F36
....................          if(!stringcomp(entpassword,password)) 
77F0:  MOVLB  7
77F2:  CLRF   xF4
77F4:  MOVLW  69
77F6:  MOVWF  xF3
77F8:  CLRF   xF6
77FA:  MOVLW  55
77FC:  MOVWF  xF5
77FE:  MOVLB  0
7800:  CALL   606E
7804:  MOVF   01,F
7806:  BNZ   78DC
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
7808:  MOVLW  FA
780A:  MOVWF  FF6
780C:  MOVLW  1E
780E:  MOVWF  FF7
7810:  CLRF   19
7812:  BTFSC  FF2.7
7814:  BSF    19.7
7816:  BCF    FF2.7
7818:  CALL   174A
781C:  BTFSC  19.7
781E:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
7820:  MOVLW  02
7822:  MOVLB  7
7824:  MOVWF  xF3
7826:  MOVLW  14
7828:  MOVWF  xF4
782A:  CLRF   xF6
782C:  MOVLW  69
782E:  MOVWF  xF5
7830:  MOVLB  0
7832:  CALL   5F36
....................             fprintf(COM2,"\n\ragain:"); 
7836:  MOVLW  02
7838:  MOVWF  FF6
783A:  MOVLW  1F
783C:  MOVWF  FF7
783E:  CLRF   19
7840:  BTFSC  FF2.7
7842:  BSF    19.7
7844:  BCF    FF2.7
7846:  CALL   174A
784A:  BTFSC  19.7
784C:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
784E:  MOVLW  02
7850:  MOVLB  7
7852:  MOVWF  xF3
7854:  MOVLW  14
7856:  MOVWF  xF4
7858:  CLRF   xF6
785A:  MOVLW  55
785C:  MOVWF  xF5
785E:  MOVLB  0
7860:  CALL   5F36
....................             if(!stringcomp(entpassword,password)) 
7864:  MOVLB  7
7866:  CLRF   xF4
7868:  MOVLW  69
786A:  MOVWF  xF3
786C:  CLRF   xF6
786E:  MOVLW  55
7870:  MOVWF  xF5
7872:  MOVLB  0
7874:  CALL   606E
7878:  MOVF   01,F
787A:  BNZ   78C2
787C:  CLRF   19
787E:  BTFSC  FF2.7
7880:  BSF    19.7
7882:  BCF    FF2.7
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
7884:  MOVLB  9
7886:  CLRF   x03
7888:  CLRF   x02
788A:  CLRF   x01
788C:  CLRF   x00
788E:  CLRF   x07
7890:  CLRF   x06
7892:  CLRF   x05
7894:  MOVLW  14
7896:  MOVWF  x04
7898:  CLRF   x09
789A:  MOVLW  55
789C:  MOVWF  x08
789E:  MOVLB  0
78A0:  CALL   4DFE
78A4:  BTFSC  19.7
78A6:  BSF    FF2.7
....................                fprintf(COM2,"\n\rOK\n\r");    
78A8:  MOVLW  0C
78AA:  MOVWF  FF6
78AC:  MOVLW  1F
78AE:  MOVWF  FF7
78B0:  CLRF   19
78B2:  BTFSC  FF2.7
78B4:  BSF    19.7
78B6:  BCF    FF2.7
78B8:  CALL   174A
78BC:  BTFSC  19.7
78BE:  BSF    FF2.7
....................             } 
....................                else 
78C0:  BRA    78DA
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
78C2:  MOVLW  14
78C4:  MOVWF  FF6
78C6:  MOVLW  1F
78C8:  MOVWF  FF7
78CA:  CLRF   19
78CC:  BTFSC  FF2.7
78CE:  BSF    19.7
78D0:  BCF    FF2.7
78D2:  CALL   174A
78D6:  BTFSC  19.7
78D8:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
78DA:  BRA    78F4
....................             { 
....................                fprintf(COM2," X\n\r"); 
78DC:  MOVLW  1C
78DE:  MOVWF  FF6
78E0:  MOVLW  1F
78E2:  MOVWF  FF7
78E4:  CLRF   19
78E6:  BTFSC  FF2.7
78E8:  BSF    19.7
78EA:  BCF    FF2.7
78EC:  CALL   174A
78F0:  BTFSC  19.7
78F2:  BSF    FF2.7
....................             }    
....................       } 
....................         strcpy(buffer2,"crypto"); 
78F4:  CLRF   FEA
78F6:  MOVLW  41
78F8:  MOVWF  FE9
78FA:  MOVLW  00
78FC:  CALL   048E
7900:  TBLRD*-
7902:  TBLRD*+
7904:  MOVF   FF5,W
7906:  MOVWF  FEE
7908:  IORLW  00
790A:  BNZ   7902
....................         if(!stringcomp(buffer_uart,buffer2))  
790C:  MOVLW  01
790E:  MOVLB  7
7910:  MOVWF  xF4
7912:  MOVLW  62
7914:  MOVWF  xF3
7916:  CLRF   xF6
7918:  MOVLW  41
791A:  MOVWF  xF5
791C:  MOVLB  0
791E:  CALL   606E
7922:  MOVF   01,F
7924:  BTFSS  FD8.2
7926:  BRA    7AA6
....................         { 
....................             memset(crypto_key,0,sizeof(crypto_key)); 
7928:  MOVLW  01
792A:  MOVWF  FEA
792C:  MOVWF  FE9
792E:  CLRF   00
7930:  CLRF   02
7932:  MOVLW  21
7934:  MOVWF  01
7936:  CALL   35AE
....................             fprintf(COM2,"New crypto key>"); 
793A:  MOVLW  22
793C:  MOVWF  FF6
793E:  MOVLW  1F
7940:  MOVWF  FF7
7942:  CLRF   19
7944:  BTFSC  FF2.7
7946:  BSF    19.7
7948:  BCF    FF2.7
794A:  CALL   174A
794E:  BTFSC  19.7
7950:  BSF    FF2.7
....................             countchar = (int16)USART_getstring(EN_ECHO, CRYPTO_KEY_SIZE, crypto_key); 
7952:  MOVLW  01
7954:  MOVLB  7
7956:  MOVWF  xF3
7958:  MOVLW  20
795A:  MOVWF  xF4
795C:  MOVLW  01
795E:  MOVWF  xF6
7960:  MOVWF  xF5
7962:  MOVLB  0
7964:  CALL   5F36
7968:  MOVLB  7
796A:  CLRF   xC0
796C:  MOVFF  01,7BF
7970:  CLRF   19
7972:  BTFSC  FF2.7
7974:  BSF    19.7
7976:  BCF    FF2.7
....................             EEPROM_write(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
7978:  MOVLB  9
797A:  CLRF   x03
797C:  CLRF   x02
797E:  CLRF   x01
7980:  MOVLW  3F
7982:  MOVWF  x00
7984:  CLRF   x07
7986:  CLRF   x06
7988:  CLRF   x05
798A:  MOVLW  20
798C:  MOVWF  x04
798E:  MOVLW  01
7990:  MOVWF  x09
7992:  MOVWF  x08
7994:  MOVLB  0
7996:  CALL   4DFE
799A:  BTFSC  19.7
799C:  BSF    FF2.7
....................              
....................             if(countchar>2) 
799E:  MOVLB  7
79A0:  MOVF   xC0,F
79A2:  BNZ   79AA
79A4:  MOVF   xBF,W
79A6:  SUBLW  02
79A8:  BC    7A68
....................             { 
....................                 cryption_enable = 1; 
79AA:  MOVLW  01
79AC:  MOVLB  1
79AE:  MOVWF  x22
79B0:  CLRF   19
79B2:  BTFSC  FF2.7
79B4:  BSF    19.7
79B6:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable);                    
79B8:  MOVLB  9
79BA:  CLRF   x16
79BC:  CLRF   x15
79BE:  CLRF   x14
79C0:  MOVLW  3E
79C2:  MOVWF  x13
79C4:  MOVFF  122,917
79C8:  MOVLB  0
79CA:  CALL   3A80
79CE:  BTFSC  19.7
79D0:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rNew crypto key: "); 
79D2:  MOVLW  32
79D4:  MOVWF  FF6
79D6:  MOVLW  1F
79D8:  MOVWF  FF7
79DA:  CLRF   19
79DC:  BTFSC  FF2.7
79DE:  BSF    19.7
79E0:  BCF    FF2.7
79E2:  CALL   174A
79E6:  BTFSC  19.7
79E8:  BSF    FF2.7
....................                 for(i=0;i<CRYPTO_KEY_SIZE;i++) 
79EA:  MOVLB  7
79EC:  CLRF   xBE
79EE:  MOVF   xBE,W
79F0:  SUBLW  1F
79F2:  BNC   7A34
....................                 { 
....................                     fprintf(COM2,"%c",read_ext_eeprom(strobe_crypto_key+i)); 
79F4:  MOVLW  3F
79F6:  ADDWF  xBE,W
79F8:  MOVWF  xF3
79FA:  CLRF   19
79FC:  BTFSC  FF2.7
79FE:  BSF    19.7
7A00:  BCF    FF2.7
7A02:  MOVLB  9
7A04:  CLRF   x1B
7A06:  CLRF   x1A
7A08:  CLRF   x19
7A0A:  MOVWF  x18
7A0C:  MOVLB  0
7A0E:  CALL   3468
7A12:  BTFSC  19.7
7A14:  BSF    FF2.7
7A16:  MOVFF  01,7F3
7A1A:  CLRF   19
7A1C:  BTFSC  FF2.7
7A1E:  BSF    19.7
7A20:  BCF    FF2.7
7A22:  MOVFF  01,90C
7A26:  CALL   1620
7A2A:  BTFSC  19.7
7A2C:  BSF    FF2.7
....................                 } 
7A2E:  MOVLB  7
7A30:  INCF   xBE,F
7A32:  BRA    79EE
7A34:  CLRF   19
7A36:  BTFSC  FF2.7
7A38:  BSF    19.7
7A3A:  BCF    FF2.7
....................                 fprintf(COM2,"\n\r"); 
7A3C:  MOVLW  0A
7A3E:  MOVLB  9
7A40:  MOVWF  x0C
7A42:  MOVLB  0
7A44:  CALL   1620
7A48:  BTFSC  19.7
7A4A:  BSF    FF2.7
7A4C:  CLRF   19
7A4E:  BTFSC  FF2.7
7A50:  BSF    19.7
7A52:  BCF    FF2.7
7A54:  MOVLW  0D
7A56:  MOVLB  9
7A58:  MOVWF  x0C
7A5A:  MOVLB  0
7A5C:  CALL   1620
7A60:  BTFSC  19.7
7A62:  BSF    FF2.7
....................             } 
....................             else 
7A64:  BRA    7AA6
7A66:  MOVLB  7
....................             { 
....................                 cryption_enable = 0; 
7A68:  MOVLB  1
7A6A:  CLRF   x22
7A6C:  CLRF   19
7A6E:  BTFSC  FF2.7
7A70:  BSF    19.7
7A72:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable); 
7A74:  MOVLB  9
7A76:  CLRF   x16
7A78:  CLRF   x15
7A7A:  CLRF   x14
7A7C:  MOVLW  3E
7A7E:  MOVWF  x13
7A80:  MOVFF  122,917
7A84:  MOVLB  0
7A86:  CALL   3A80
7A8A:  BTFSC  19.7
7A8C:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rcrypto is disable\n\r"); 
7A8E:  MOVLW  46
7A90:  MOVWF  FF6
7A92:  MOVLW  1F
7A94:  MOVWF  FF7
7A96:  CLRF   19
7A98:  BTFSC  FF2.7
7A9A:  BSF    19.7
7A9C:  BCF    FF2.7
7A9E:  CALL   174A
7AA2:  BTFSC  19.7
7AA4:  BSF    FF2.7
....................             } 
....................         } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
7AA6:  CLRF   FEA
7AA8:  MOVLW  41
7AAA:  MOVWF  FE9
7AAC:  MOVLW  00
7AAE:  CALL   04A6
7AB2:  TBLRD*-
7AB4:  TBLRD*+
7AB6:  MOVF   FF5,W
7AB8:  MOVWF  FEE
7ABA:  IORLW  00
7ABC:  BNZ   7AB4
....................       if(!stringcomp(buffer_uart,buffer2)) 
7ABE:  MOVLW  01
7AC0:  MOVLB  7
7AC2:  MOVWF  xF4
7AC4:  MOVLW  62
7AC6:  MOVWF  xF3
7AC8:  CLRF   xF6
7ACA:  MOVLW  41
7ACC:  MOVWF  xF5
7ACE:  MOVLB  0
7AD0:  CALL   606E
7AD4:  MOVF   01,F
7AD6:  BTFSS  FD8.2
7AD8:  BRA    7BE8
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
7ADA:  MOVLW  5C
7ADC:  MOVWF  FF6
7ADE:  MOVLW  1F
7AE0:  MOVWF  FF7
7AE2:  CLRF   19
7AE4:  BTFSC  FF2.7
7AE6:  BSF    19.7
7AE8:  BCF    FF2.7
7AEA:  CALL   174A
7AEE:  BTFSC  19.7
7AF0:  BSF    FF2.7
7AF2:  CLRF   19
7AF4:  BTFSC  FF2.7
7AF6:  BSF    19.7
7AF8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7AFA:  MOVLW  0A
7AFC:  MOVLB  9
7AFE:  MOVWF  x0C
7B00:  MOVLB  0
7B02:  CALL   1620
7B06:  BTFSC  19.7
7B08:  BSF    FF2.7
7B0A:  CLRF   19
7B0C:  BTFSC  FF2.7
7B0E:  BSF    19.7
7B10:  BCF    FF2.7
7B12:  MOVLW  0D
7B14:  MOVLB  9
7B16:  MOVWF  x0C
7B18:  MOVLB  0
7B1A:  CALL   1620
7B1E:  BTFSC  19.7
7B20:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
7B22:  MOVLW  7C
7B24:  MOVWF  FF6
7B26:  MOVLW  1F
7B28:  MOVWF  FF7
7B2A:  CLRF   19
7B2C:  BTFSC  FF2.7
7B2E:  BSF    19.7
7B30:  BCF    FF2.7
7B32:  CALL   174A
7B36:  BTFSC  19.7
7B38:  BSF    FF2.7
7B3A:  CLRF   19
7B3C:  BTFSC  FF2.7
7B3E:  BSF    19.7
7B40:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7B42:  MOVLW  0A
7B44:  MOVLB  9
7B46:  MOVWF  x0C
7B48:  MOVLB  0
7B4A:  CALL   1620
7B4E:  BTFSC  19.7
7B50:  BSF    FF2.7
7B52:  CLRF   19
7B54:  BTFSC  FF2.7
7B56:  BSF    19.7
7B58:  BCF    FF2.7
7B5A:  MOVLW  0D
7B5C:  MOVLB  9
7B5E:  MOVWF  x0C
7B60:  MOVLB  0
7B62:  CALL   1620
7B66:  BTFSC  19.7
7B68:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7B6A:  MOVLW  01
7B6C:  MOVLB  7
7B6E:  MOVWF  xF3
7B70:  MOVLW  03
7B72:  MOVWF  xF4
7B74:  MOVLW  07
7B76:  MOVWF  xF6
7B78:  MOVLW  C1
7B7A:  MOVWF  xF5
7B7C:  MOVLB  0
7B7E:  CALL   5F36
....................           debugmode = (unsigned int8)strtoi(temp); 
7B82:  MOVLW  07
7B84:  MOVLB  7
7B86:  MOVWF  xF4
7B88:  MOVLW  C1
7B8A:  MOVWF  xF3
7B8C:  MOVLB  0
7B8E:  CALL   6A50
7B92:  MOVFF  01,6D6
7B96:  CLRF   19
7B98:  BTFSC  FF2.7
7B9A:  BSF    19.7
7B9C:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
7B9E:  MOVLB  9
7BA0:  CLRF   x16
7BA2:  CLRF   x15
7BA4:  CLRF   x14
7BA6:  MOVLW  3B
7BA8:  MOVWF  x13
7BAA:  MOVFF  6D6,917
7BAE:  MOVLB  0
7BB0:  CALL   3A80
7BB4:  BTFSC  19.7
7BB6:  BSF    FF2.7
7BB8:  CLRF   19
7BBA:  BTFSC  FF2.7
7BBC:  BSF    19.7
7BBE:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7BC0:  MOVLW  0A
7BC2:  MOVLB  9
7BC4:  MOVWF  x0C
7BC6:  MOVLB  0
7BC8:  CALL   1620
7BCC:  BTFSC  19.7
7BCE:  BSF    FF2.7
7BD0:  CLRF   19
7BD2:  BTFSC  FF2.7
7BD4:  BSF    19.7
7BD6:  BCF    FF2.7
7BD8:  MOVLW  0D
7BDA:  MOVLB  9
7BDC:  MOVWF  x0C
7BDE:  MOVLB  0
7BE0:  CALL   1620
7BE4:  BTFSC  19.7
7BE6:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
7BE8:  GOTO   8308 (RETURN)
.................... //=============================================== 
....................  
....................  
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    if(keydebug_en==1) 
*
5996:  MOVLB  1
5998:  DECFSZ x44,W
599A:  BRA    59B6
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
599C:  MOVLB  6
599E:  MOVF   xE2,F
59A0:  BNZ   59AA
59A2:  MOVLB  0
59A4:  CALL   1F9C
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
59A8:  BRA    59B4
59AA:  MOVLB  0
59AC:  CALL   31F8
59B0:  MOVFF  01,84F
59B4:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
59B6:  DECFSZ x45,W
59B8:  BRA    59D2
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
59BA:  MOVLB  6
59BC:  MOVF   xE2,F
59BE:  BNZ   59C8
59C0:  MOVLB  0
59C2:  CALL   1F9C
....................          else temp=kbd_getc_slv(); 
59C6:  BRA    59D2
59C8:  MOVLB  0
59CA:  CALL   31F8
59CE:  MOVFF  01,84F
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
59D2:  MOVLB  6
59D4:  MOVF   xC7,F
59D6:  BNZ   59F6
59D8:  MOVF   xC6,F
59DA:  BNZ   59F6
59DC:  MOVF   xC5,F
59DE:  BNZ   59F6
59E0:  MOVF   xC4,W
59E2:  SUBLW  04
59E4:  BNC   59F6
59E6:  MOVLW  01
59E8:  ADDWF  xC4,F
59EA:  BTFSC  FD8.0
59EC:  INCF   xC5,F
59EE:  BTFSC  FD8.2
59F0:  INCF   xC6,F
59F2:  BTFSC  FD8.2
59F4:  INCF   xC7,F
....................   if(mcr_timeout==5) 
59F6:  MOVF   xC4,W
59F8:  SUBLW  05
59FA:  BNZ   5A66
59FC:  MOVF   xC5,F
59FE:  BNZ   5A66
5A00:  MOVF   xC6,F
5A02:  BNZ   5A66
5A04:  MOVF   xC7,F
5A06:  BNZ   5A66
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1) 
5A08:  DECFSZ xDA,W
5A0A:  BRA    5A24
....................       { 
....................           if(cryption_enable==0)  
5A0C:  MOVLB  1
5A0E:  MOVF   x22,F
5A10:  BNZ   5A1C
....................           { 
....................                 saving_card(); 
5A12:  MOVLB  0
5A14:  GOTO   3C0C
....................           } 
....................           else  
5A18:  BRA    5A22
5A1A:  MOVLB  1
....................           { 
....................                 saving_card_encrypt(); 
5A1C:  MOVLB  0
5A1E:  GOTO   4ED8
5A22:  MOVLB  6
....................           } 
....................       } 
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
5A24:  MOVLW  02
5A26:  MOVWF  FEA
5A28:  MOVLW  46
5A2A:  MOVWF  FE9
5A2C:  CLRF   00
5A2E:  MOVLW  03
5A30:  MOVWF  02
5A32:  MOVLW  52
5A34:  MOVWF  01
5A36:  MOVLB  0
5A38:  CALL   35AE
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
5A3C:  MOVLW  05
5A3E:  MOVWF  FEA
5A40:  MOVLW  98
5A42:  MOVWF  FE9
5A44:  CLRF   00
5A46:  MOVLW  01
5A48:  MOVWF  02
5A4A:  MOVLW  2C
5A4C:  MOVWF  01
5A4E:  CALL   35AE
....................       //debug_card(); 
....................       count_reading_error=0; 
5A52:  MOVLB  6
5A54:  CLRF   xDB
....................       mcr_timeout++;   
5A56:  MOVLW  01
5A58:  ADDWF  xC4,F
5A5A:  BTFSC  FD8.0
5A5C:  INCF   xC5,F
5A5E:  BTFSC  FD8.2
5A60:  INCF   xC6,F
5A62:  BTFSC  FD8.2
5A64:  INCF   xC7,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
5A66:  MOVLB  9
5A68:  CLRF   x1B
5A6A:  CLRF   x1A
5A6C:  CLRF   x19
5A6E:  MOVLW  3C
5A70:  MOVWF  x18
5A72:  MOVLB  0
5A74:  CALL   3468
5A78:  MOVFF  01,15A
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
5A7C:  MOVLW  02
5A7E:  MOVLB  8
5A80:  MOVWF  x56
5A82:  MOVLW  BC
5A84:  MOVWF  x55
5A86:  CLRF   x58
5A88:  MOVFF  15A,857
5A8C:  MOVLB  0
5A8E:  CALL   358C
5A92:  MOVFF  02,03
5A96:  MOVF   01,W
5A98:  MOVLB  1
5A9A:  MOVF   x00,W
5A9C:  SUBWF  02,W
5A9E:  BNC   5ABE
5AA0:  BNZ   5AB0
5AA2:  MOVF   01,W
5AA4:  MOVLB  0
5AA6:  SUBWF  xFF,W
5AA8:  BTFSS  FD8.0
5AAA:  BRA    5AB0
5AAC:  MOVLB  1
5AAE:  BRA    5ABE
5AB0:  MOVLB  0
5AB2:  INCF   xFF,F
5AB4:  BTFSS  FD8.2
5AB6:  BRA    5ABE
5AB8:  MOVLB  1
5ABA:  INCF   x00,F
5ABC:  MOVLB  0
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
5ABE:  MOVLW  02
5AC0:  MOVLB  8
5AC2:  MOVWF  x56
5AC4:  MOVLW  BC
5AC6:  MOVWF  x55
5AC8:  CLRF   x58
5ACA:  MOVFF  15A,857
5ACE:  MOVLB  0
5AD0:  CALL   358C
5AD4:  MOVFF  02,03
5AD8:  MOVF   01,W
5ADA:  SUBWF  xFF,W
5ADC:  BNZ   5BA2
5ADE:  MOVF   03,W
5AE0:  MOVLB  1
5AE2:  SUBWF  x00,W
5AE4:  BTFSC  FD8.2
5AE6:  BRA    5AEC
5AE8:  MOVLB  0
5AEA:  BRA    5BA2
....................   { 
....................       charac_timeout++; 
5AEC:  MOVLB  0
5AEE:  INCF   xFF,F
5AF0:  BTFSS  FD8.2
5AF2:  BRA    5AFA
5AF4:  MOVLB  1
5AF6:  INCF   x00,F
5AF8:  MOVLB  0
....................       buf=get_countcard(); 
5AFA:  CALL   3534
5AFE:  MOVFF  02,84E
5B02:  MOVFF  01,84D
....................       if(buf<countcards) 
5B06:  MOVLB  8
5B08:  MOVF   x4E,W
5B0A:  SUBLW  03
5B0C:  BNC   5B42
5B0E:  BNZ   5B16
5B10:  MOVF   x4D,W
5B12:  SUBLW  83
5B14:  BNC   5B42
....................       { 
....................          if(cryption_enable==0)  
5B16:  MOVLB  1
5B18:  MOVF   x22,F
5B1A:  BNZ   5B24
....................          { 
....................             save_key_new(); 
5B1C:  MOVLB  0
5B1E:  BRA    5428
....................          } 
....................          else 
5B20:  BRA    5B28
5B22:  MOVLB  1
....................          { 
....................             save_key_encrypt(); 
5B24:  MOVLB  0
5B26:  BRA    55EC
....................          } 
....................          buf=buf+1; 
5B28:  MOVLW  01
5B2A:  MOVLB  8
5B2C:  ADDWF  x4D,F
5B2E:  MOVLW  00
5B30:  ADDWFC x4E,F
....................          save_coutcard(buf); 
5B32:  MOVFF  84E,851
5B36:  MOVFF  84D,850
5B3A:  MOVLB  0
5B3C:  RCALL  5858
....................       } 
....................          else 
5B3E:  BRA    5B52
5B40:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
5B42:  MOVLW  A8
5B44:  MOVWF  FF6
5B46:  MOVLW  5B
5B48:  MOVWF  FF7
5B4A:  MOVLB  0
5B4C:  CALL   174A
....................             return; 
5B50:  BRA    5BA2
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
5B52:  MOVLW  B8
5B54:  MOVWF  FF6
5B56:  MOVLW  5B
5B58:  MOVWF  FF7
5B5A:  CALL   174A
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
5B5E:  MOVLW  C8
5B60:  MOVWF  FF6
5B62:  MOVLW  5B
5B64:  MOVWF  FF7
5B66:  MOVLW  14
5B68:  MOVLB  9
5B6A:  MOVWF  x00
5B6C:  MOVLB  0
5B6E:  CALL   1666
5B72:  MOVLW  10
5B74:  MOVWF  FE9
5B76:  MOVFF  84E,851
5B7A:  MOVFF  84D,850
5B7E:  RCALL  58A0
5B80:  MOVLW  DF
5B82:  MOVWF  FF6
5B84:  MOVLW  5B
5B86:  MOVWF  FF7
5B88:  MOVLW  03
5B8A:  MOVLB  9
5B8C:  MOVWF  x00
5B8E:  MOVLB  0
5B90:  CALL   1666
....................       data_avai=0; 
5B94:  MOVLB  6
5B96:  CLRF   xD9
....................       enable_getpin=0; 
5B98:  MOVLB  1
5B9A:  CLRF   x45
....................       //dis_getpin; 
....................       output_low(LED); 
5B9C:  BCF    F92.6
5B9E:  BCF    F89.6
5BA0:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
5BA2:  BCF    FF2.2
5BA4:  GOTO   006C
.................... void main() 
.................... {  
*
7BEC:  CLRF   FF8
7BEE:  BCF    FD0.7
7BF0:  BSF    07.7
7BF2:  CLRF   FEA
7BF4:  CLRF   FE9
7BF6:  BCF    F94.0
7BF8:  BSF    F8B.0
7BFA:  CLRF   23
7BFC:  CLRF   22
7BFE:  CLRF   21
7C00:  MOVLW  96
7C02:  MOVWF  20
7C04:  CLRF   27
7C06:  MOVLW  01
7C08:  MOVWF  26
7C0A:  MOVLW  C3
7C0C:  MOVWF  25
7C0E:  MOVLW  0F
7C10:  MOVWF  24
7C12:  CLRF   xFE
7C14:  CLRF   xFD
7C16:  MOVLB  1
7C18:  SETF   x00
7C1A:  MOVLB  0
7C1C:  SETF   xFF
7C1E:  MOVLB  1
7C20:  CLRF   x22
7C22:  CLRF   x43
7C24:  CLRF   x44
7C26:  CLRF   x45
7C28:  MOVLW  64
7C2A:  MOVWF  x46
7C2C:  CLRF   x47
7C2E:  CLRF   x48
7C30:  CLRF   x49
7C32:  CLRF   x5A
7C34:  CLRF   x5F
7C36:  CLRF   xC6
7C38:  CLRF   xC7
7C3A:  MOVLW  0E
7C3C:  MOVWF  xC9
7C3E:  MOVLW  01
7C40:  MOVWF  xCA
7C42:  MOVWF  xCB
7C44:  CLRF   xCC
7C46:  CLRF   xCD
7C48:  CLRF   xCE
7C4A:  MOVLB  6
7C4C:  CLRF   xC7
7C4E:  CLRF   xC6
7C50:  CLRF   xC5
7C52:  CLRF   xC4
7C54:  CLRF   xC8
7C56:  CLRF   xCA
7C58:  CLRF   xC9
7C5A:  CLRF   xCC
7C5C:  CLRF   xCB
7C5E:  CLRF   xCE
7C60:  CLRF   xCD
7C62:  CLRF   xD0
7C64:  CLRF   xCF
7C66:  MOVLW  FD
7C68:  MOVWF  xD2
7C6A:  MOVLW  E8
7C6C:  MOVWF  xD1
7C6E:  CLRF   xD4
7C70:  CLRF   xD3
7C72:  CLRF   xD5
7C74:  CLRF   xD6
7C76:  CLRF   xD7
7C78:  CLRF   xD8
7C7A:  CLRF   xD9
7C7C:  CLRF   xDA
7C7E:  CLRF   xDB
7C80:  CLRF   xDC
7C82:  CLRF   xDD
7C84:  CLRF   xDF
7C86:  MOVLW  01
7C88:  MOVWF  xDE
7C8A:  CLRF   xE1
7C8C:  CLRF   xE0
7C8E:  CLRF   xE2
7C90:  CLRF   xE6
7C92:  CLRF   xE5
7C94:  CLRF   xE4
7C96:  CLRF   xE3
7C98:  MOVLW  FF
7C9A:  MOVLB  F
7C9C:  MOVWF  x48
7C9E:  BCF    FC2.6
7CA0:  BCF    FC2.7
7CA2:  MOVF   x49,W
7CA4:  ANDLW  E0
7CA6:  IORLW  1F
7CA8:  MOVWF  x49
7CAA:  CLRF   FD2
7CAC:  CLRF   FD1
7CAE:  CLRF   1A
7CB0:  CLRF   1B
7CB2:  MOVLW  E8
7CB4:  MOVLB  1
7CB6:  MOVWF  x23
7CB8:  MOVLW  E9
7CBA:  MOVWF  x24
7CBC:  MOVLW  EA
7CBE:  MOVWF  x25
7CC0:  MOVLW  EB
7CC2:  MOVWF  x26
7CC4:  MOVLW  ED
7CC6:  MOVWF  x27
7CC8:  MOVLW  EE
7CCA:  MOVWF  x28
7CCC:  MOVLW  EF
7CCE:  MOVWF  x29
7CD0:  MOVLW  F0
7CD2:  MOVWF  x2A
7CD4:  MOVLW  F2
7CD6:  MOVWF  x2B
7CD8:  MOVLW  F3
7CDA:  MOVWF  x2C
7CDC:  MOVLW  F4
7CDE:  MOVWF  x2D
7CE0:  MOVLW  F5
7CE2:  MOVWF  x2E
7CE4:  MOVLW  F7
7CE6:  MOVWF  x2F
7CE8:  MOVLW  F8
7CEA:  MOVWF  x30
7CEC:  MOVLW  F9
7CEE:  MOVWF  x31
7CF0:  MOVLW  FA
7CF2:  MOVWF  x32
7CF4:  MOVLW  67
7CF6:  MOVWF  x33
7CF8:  MOVLW  43
7CFA:  MOVWF  x34
7CFC:  MOVLW  C3
7CFE:  MOVWF  x35
7D00:  MOVLW  D1
7D02:  MOVWF  x36
7D04:  MOVLW  51
7D06:  MOVWF  x37
7D08:  MOVLW  9A
7D0A:  MOVWF  x38
7D0C:  MOVLW  B4
7D0E:  MOVWF  x39
7D10:  MOVLW  F2
7D12:  MOVWF  x3A
7D14:  MOVLW  CD
7D16:  MOVWF  x3B
7D18:  MOVLW  9A
7D1A:  MOVWF  x3C
7D1C:  MOVLW  78
7D1E:  MOVWF  x3D
7D20:  MOVLW  AB
7D22:  MOVWF  x3E
7D24:  MOVLW  09
7D26:  MOVWF  x3F
7D28:  MOVLW  A5
7D2A:  MOVWF  x40
7D2C:  MOVLW  11
7D2E:  MOVWF  x41
7D30:  MOVLW  BD
7D32:  MOVWF  x42
7D34:  CLRF   x5B
7D36:  BCF    x5C.0
7D38:  CLRF   x5D
7D3A:  CLRF   x5E
7D3C:  CLRF   x60
7D3E:  BCF    x5C.1
7D40:  CLRF   x61
7D42:  MOVLB  6
7D44:  CLRF   xF7
7D46:  CLRF   xF8
7D48:  CLRF   xF9
7D4A:  CLRF   xFA
7D4C:  CLRF   xFB
7D4E:  CLRF   xFC
7D50:  CLRF   xFD
7D52:  CLRF   xFE
7D54:  CLRF   xFF
7D56:  MOVLB  7
7D58:  CLRF   x00
7D5A:  CLRF   x03
7D5C:  CLRF   x05
7D5E:  CLRF   x04
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    RPINR1=5; 
7D60:  MOVLW  05
7D62:  MOVLB  E
7D64:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
7D66:  MOVLB  1
7D68:  SETF   x00
7D6A:  MOVLB  0
7D6C:  SETF   xFF
....................    setup_oscillator(OSC_32MHZ); 
7D6E:  MOVLW  70
7D70:  MOVWF  FD3
7D72:  MOVLW  40
7D74:  MOVWF  F9B
7D76:  MOVF   FD3,W
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
7D78:  BCF    FF2.6
7D7A:  BCF    FF2.7
7D7C:  BTFSC  FF2.7
7D7E:  BRA    7D7A
....................    init_ext_eeprom(); 
7D80:  GOTO   5CCC
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif   
....................    //===================================== 
....................    delay_ms(1000); 
7D84:  MOVLW  04
7D86:  MOVLB  7
7D88:  MOVWF  xBD
7D8A:  CLRF   19
7D8C:  BTFSC  FF2.7
7D8E:  BSF    19.7
7D90:  BCF    FF2.7
7D92:  MOVLW  FA
7D94:  MOVLB  8
7D96:  MOVWF  x56
7D98:  MOVLB  0
7D9A:  CALL   18E6
7D9E:  BTFSC  19.7
7DA0:  BSF    FF2.7
7DA2:  MOVLB  7
7DA4:  DECFSZ xBD,F
7DA6:  BRA    7D8A
....................    init_password(); 
7DA8:  MOVLB  0
7DAA:  CALL   5CD6
....................    //===================================== 
....................    fprintf(COM2,"\n\rbooting\n\r"); 
7DAE:  MOVLW  E4
7DB0:  MOVWF  FF6
7DB2:  MOVLW  5B
7DB4:  MOVWF  FF7
7DB6:  CLRF   19
7DB8:  BTFSC  FF2.7
7DBA:  BSF    19.7
7DBC:  BCF    FF2.7
7DBE:  CALL   174A
7DC2:  BTFSC  19.7
7DC4:  BSF    FF2.7
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
7DC6:  MOVLW  19
7DC8:  MOVLB  7
7DCA:  MOVWF  xBD
7DCC:  MOVLB  0
7DCE:  CALL   5D92
7DD2:  MOVFF  03,23
7DD6:  MOVFF  02,22
7DDA:  MOVFF  01,21
7DDE:  MOVFF  00,20
....................    fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
7DE2:  MOVLW  F0
7DE4:  MOVWF  FF6
7DE6:  MOVLW  5B
7DE8:  MOVWF  FF7
7DEA:  CLRF   19
7DEC:  BTFSC  FF2.7
7DEE:  BSF    19.7
7DF0:  BCF    FF2.7
7DF2:  MOVLW  0E
7DF4:  MOVLB  9
7DF6:  MOVWF  x00
7DF8:  MOVLB  0
7DFA:  CALL   1666
7DFE:  BTFSC  19.7
7E00:  BSF    FF2.7
7E02:  MOVLW  41
7E04:  MOVWF  FE9
7E06:  CLRF   19
7E08:  BTFSC  FF2.7
7E0A:  BSF    19.7
7E0C:  BCF    FF2.7
7E0E:  MOVFF  23,903
7E12:  MOVFF  22,902
7E16:  MOVFF  21,901
7E1A:  MOVFF  20,900
7E1E:  CALL   231A
7E22:  BTFSC  19.7
7E24:  BSF    FF2.7
7E26:  CLRF   19
7E28:  BTFSC  FF2.7
7E2A:  BSF    19.7
7E2C:  BCF    FF2.7
7E2E:  MOVLW  0A
7E30:  MOVLB  9
7E32:  MOVWF  x0C
7E34:  MOVLB  0
7E36:  CALL   1620
7E3A:  BTFSC  19.7
7E3C:  BSF    FF2.7
7E3E:  CLRF   19
7E40:  BTFSC  FF2.7
7E42:  BSF    19.7
7E44:  BCF    FF2.7
7E46:  MOVLW  0D
7E48:  MOVLB  9
7E4A:  MOVWF  x0C
7E4C:  MOVLB  0
7E4E:  CALL   1620
7E52:  BTFSC  19.7
7E54:  BSF    FF2.7
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
7E56:  MOVLW  1E
7E58:  MOVLB  7
7E5A:  MOVWF  xBD
7E5C:  MOVLB  0
7E5E:  CALL   5D92
7E62:  MOVFF  03,27
7E66:  MOVFF  02,26
7E6A:  MOVFF  01,25
7E6E:  MOVFF  00,24
....................    fprintf(COM2,"max address: 0x%lx\n\r", EEPROM_SIZE_endofkey); 
7E72:  MOVLW  04
7E74:  MOVWF  FF6
7E76:  MOVLW  5C
7E78:  MOVWF  FF7
7E7A:  CLRF   19
7E7C:  BTFSC  FF2.7
7E7E:  BSF    19.7
7E80:  BCF    FF2.7
7E82:  MOVLW  0F
7E84:  MOVLB  9
7E86:  MOVWF  x00
7E88:  MOVLB  0
7E8A:  CALL   1666
7E8E:  BTFSC  19.7
7E90:  BSF    FF2.7
7E92:  CLRF   19
7E94:  BTFSC  FF2.7
7E96:  BSF    19.7
7E98:  BCF    FF2.7
7E9A:  MOVLB  9
7E9C:  CLRF   x01
7E9E:  MOVLW  57
7EA0:  MOVWF  x02
7EA2:  MOVLB  0
7EA4:  CALL   4E8E
7EA8:  BTFSC  19.7
7EAA:  BSF    FF2.7
7EAC:  CLRF   19
7EAE:  BTFSC  FF2.7
7EB0:  BSF    19.7
7EB2:  BCF    FF2.7
7EB4:  MOVLW  01
7EB6:  MOVLB  9
7EB8:  MOVWF  x01
7EBA:  MOVLW  57
7EBC:  MOVWF  x02
7EBE:  MOVLB  0
7EC0:  CALL   4E8E
7EC4:  BTFSC  19.7
7EC6:  BSF    FF2.7
7EC8:  CLRF   19
7ECA:  BTFSC  FF2.7
7ECC:  BSF    19.7
7ECE:  BCF    FF2.7
7ED0:  MOVLB  9
7ED2:  SETF   x01
7ED4:  MOVLW  57
7ED6:  MOVWF  x02
7ED8:  MOVLB  0
7EDA:  CALL   4E8E
7EDE:  BTFSC  19.7
7EE0:  BSF    FF2.7
7EE2:  CLRF   19
7EE4:  BTFSC  FF2.7
7EE6:  BSF    19.7
7EE8:  BCF    FF2.7
7EEA:  MOVLB  9
7EEC:  SETF   x01
7EEE:  MOVLW  57
7EF0:  MOVWF  x02
7EF2:  MOVLB  0
7EF4:  CALL   4E8E
7EF8:  BTFSC  19.7
7EFA:  BSF    FF2.7
7EFC:  CLRF   19
7EFE:  BTFSC  FF2.7
7F00:  BSF    19.7
7F02:  BCF    FF2.7
7F04:  MOVLW  0A
7F06:  MOVLB  9
7F08:  MOVWF  x0C
7F0A:  MOVLB  0
7F0C:  CALL   1620
7F10:  BTFSC  19.7
7F12:  BSF    FF2.7
7F14:  CLRF   19
7F16:  BTFSC  FF2.7
7F18:  BSF    19.7
7F1A:  BCF    FF2.7
7F1C:  MOVLW  0D
7F1E:  MOVLB  9
7F20:  MOVWF  x0C
7F22:  MOVLB  0
7F24:  CALL   1620
7F28:  BTFSC  19.7
7F2A:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
7F2C:  MOVLW  1A
7F2E:  MOVWF  FF6
7F30:  MOVLW  5C
7F32:  MOVWF  FF7
7F34:  CLRF   19
7F36:  BTFSC  FF2.7
7F38:  BSF    19.7
7F3A:  BCF    FF2.7
7F3C:  MOVLW  12
7F3E:  MOVLB  9
7F40:  MOVWF  x00
7F42:  MOVLB  0
7F44:  CALL   1666
7F48:  BTFSC  19.7
7F4A:  BSF    FF2.7
7F4C:  MOVLW  41
7F4E:  MOVWF  FE9
7F50:  CLRF   19
7F52:  BTFSC  FF2.7
7F54:  BSF    19.7
7F56:  BCF    FF2.7
7F58:  MOVFF  27,903
7F5C:  MOVFF  26,902
7F60:  MOVFF  25,901
7F64:  MOVFF  24,900
7F68:  CALL   231A
7F6C:  BTFSC  19.7
7F6E:  BSF    FF2.7
7F70:  CLRF   19
7F72:  BTFSC  FF2.7
7F74:  BSF    19.7
7F76:  BCF    FF2.7
7F78:  MOVLW  0A
7F7A:  MOVLB  9
7F7C:  MOVWF  x0C
7F7E:  MOVLB  0
7F80:  CALL   1620
7F84:  BTFSC  19.7
7F86:  BSF    FF2.7
7F88:  CLRF   19
7F8A:  BTFSC  FF2.7
7F8C:  BSF    19.7
7F8E:  BCF    FF2.7
7F90:  MOVLW  0D
7F92:  MOVLB  9
7F94:  MOVWF  x0C
7F96:  MOVLB  0
7F98:  CALL   1620
7F9C:  BTFSC  19.7
7F9E:  BSF    FF2.7
7FA0:  CLRF   19
7FA2:  BTFSC  FF2.7
7FA4:  BSF    19.7
7FA6:  BCF    FF2.7
....................    countcard=get_countcard(); 
7FA8:  CALL   3534
7FAC:  BTFSC  19.7
7FAE:  BSF    FF2.7
7FB0:  MOVFF  02,FE
7FB4:  MOVFF  01,FD
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
7FB8:  MOVLB  1
7FBA:  SETF   x00
7FBC:  MOVLB  0
7FBE:  SETF   xFF
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
7FC0:  MOVLW  C7
7FC2:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
7FC4:  MOVLW  37
7FC6:  MOVWF  FCD
7FC8:  CLRF   F9A
7FCA:  CLRF   19
7FCC:  BTFSC  FF2.7
7FCE:  BSF    19.7
7FD0:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
7FD2:  MOVLB  9
7FD4:  CLRF   x1B
7FD6:  CLRF   x1A
7FD8:  CLRF   x19
7FDA:  MOVLW  3C
7FDC:  MOVWF  x18
7FDE:  MOVLB  0
7FE0:  CALL   3468
7FE4:  BTFSC  19.7
7FE6:  BSF    FF2.7
7FE8:  MOVFF  01,15A
....................    if(delaycharaction==0)delaycharaction=1; 
7FEC:  MOVLB  1
7FEE:  MOVF   x5A,F
7FF0:  BNZ   7FF6
7FF2:  MOVLW  01
7FF4:  MOVWF  x5A
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
7FF6:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
7FF8:  BSF    FF0.3
7FFA:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
7FFC:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
7FFE:  MOVLW  C0
8000:  IORWF  FF2,F
....................   
....................     mcr_timeout=10000; 
8002:  MOVLB  6
8004:  CLRF   xC7
8006:  CLRF   xC6
8008:  MOVLW  27
800A:  MOVWF  xC5
800C:  MOVLW  10
800E:  MOVWF  xC4
8010:  CLRF   19
8012:  BTFSC  FF2.7
8014:  BSF    19.7
8016:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
8018:  MOVLB  9
801A:  CLRF   x1B
801C:  CLRF   x1A
801E:  CLRF   x19
8020:  MOVLW  3A
8022:  MOVWF  x18
8024:  MOVLB  0
8026:  CALL   3468
802A:  BTFSC  19.7
802C:  BSF    FF2.7
802E:  MOVFF  01,6E2
8032:  CLRF   19
8034:  BTFSC  FF2.7
8036:  BSF    19.7
8038:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
803A:  MOVLB  9
803C:  CLRF   x1B
803E:  CLRF   x1A
8040:  CLRF   x19
8042:  MOVLW  3B
8044:  MOVWF  x18
8046:  MOVLB  0
8048:  CALL   3468
804C:  BTFSC  19.7
804E:  BSF    FF2.7
8050:  MOVFF  01,6D6
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
8054:  MOVLB  1
8056:  SETF   x00
8058:  MOVLB  0
805A:  SETF   xFF
805C:  CLRF   19
805E:  BTFSC  FF2.7
8060:  BSF    19.7
8062:  BCF    FF2.7
....................     
....................    EEPROM_read(strobe_nameconsole,wide_strobe_nameconsole,console); 
8064:  MOVLB  9
8066:  CLRF   x07
8068:  CLRF   x06
806A:  CLRF   x05
806C:  MOVLW  28
806E:  MOVWF  x04
8070:  CLRF   x0B
8072:  CLRF   x0A
8074:  CLRF   x09
8076:  MOVLW  10
8078:  MOVWF  x08
807A:  MOVLW  06
807C:  MOVWF  x0D
807E:  MOVLW  E7
8080:  MOVWF  x0C
8082:  MOVLB  0
8084:  CALL   4094
8088:  BTFSC  19.7
808A:  BSF    FF2.7
....................    set_tris_a(0xff);  
808C:  MOVLW  FF
808E:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
8090:  MOVLW  E0
8092:  MOVLB  F
8094:  MOVWF  x48
8096:  BCF    FC2.6
8098:  BCF    FC2.7
809A:  MOVF   x49,W
809C:  ANDLW  E0
809E:  IORLW  1F
80A0:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
80A2:  MOVF   FC1,W
80A4:  ANDLW  C0
80A6:  IORLW  03
80A8:  MOVWF  FC1
80AA:  BCF    FC1.7
80AC:  BSF    FC2.0
80AE:  BSF    FC1.6
80B0:  BSF    FC2.1
80B2:  BTFSC  FC2.1
80B4:  BRA    80B2
80B6:  BCF    FC1.6
80B8:  CLRF   19
80BA:  BTFSC  FF2.7
80BC:  BSF    19.7
80BE:  BCF    FF2.7
....................     
....................    type_KB=read_ext_eeprom(kindofKB); 
80C0:  MOVLB  9
80C2:  CLRF   x1B
80C4:  CLRF   x1A
80C6:  CLRF   x19
80C8:  MOVLW  3D
80CA:  MOVWF  x18
80CC:  MOVLB  0
80CE:  CALL   3468
80D2:  BTFSC  19.7
80D4:  BSF    FF2.7
80D6:  MOVFF  01,149
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
80DA:  MOVLB  1
80DC:  MOVF   x49,F
80DE:  BZ    80FE
80E0:  MOVLW  32
80E2:  MOVWF  FF6
80E4:  MOVLW  5C
80E6:  MOVWF  FF7
80E8:  CLRF   19
80EA:  BTFSC  FF2.7
80EC:  BSF    19.7
80EE:  BCF    FF2.7
80F0:  MOVLB  0
80F2:  CALL   174A
80F6:  BTFSC  19.7
80F8:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
80FA:  BRA    8118
80FC:  MOVLB  1
80FE:  MOVLW  46
8100:  MOVWF  FF6
8102:  MOVLW  5C
8104:  MOVWF  FF7
8106:  CLRF   19
8108:  BTFSC  FF2.7
810A:  BSF    19.7
810C:  BCF    FF2.7
810E:  MOVLB  0
8110:  CALL   174A
8114:  BTFSC  19.7
8116:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
8118:  MOVLB  6
811A:  MOVF   xE2,F
811C:  BNZ   813C
811E:  MOVLW  5A
8120:  MOVWF  FF6
8122:  MOVLW  5C
8124:  MOVWF  FF7
8126:  CLRF   19
8128:  BTFSC  FF2.7
812A:  BSF    19.7
812C:  BCF    FF2.7
812E:  MOVLB  0
8130:  CALL   174A
8134:  BTFSC  19.7
8136:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
8138:  BRA    8156
813A:  MOVLB  6
813C:  MOVLW  74
813E:  MOVWF  FF6
8140:  MOVLW  5C
8142:  MOVWF  FF7
8144:  CLRF   19
8146:  BTFSC  FF2.7
8148:  BSF    19.7
814A:  BCF    FF2.7
814C:  MOVLB  0
814E:  CALL   174A
8152:  BTFSC  19.7
8154:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
8156:  MOVLW  01
8158:  MOVWF  FEA
815A:  MOVLW  4A
815C:  MOVWF  FE9
815E:  CLRF   00
8160:  CLRF   02
8162:  MOVLW  10
8164:  MOVWF  01
8166:  CALL   35AE
....................    //save_coutcard(448); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
816A:  MOVLB  7
816C:  CLRF   x01
816E:  MOVF   x01,W
8170:  SUBLW  13
8172:  BNC   8188
....................    { 
....................       password[i] = 0; 
8174:  CLRF   03
8176:  MOVF   x01,W
8178:  ADDLW  55
817A:  MOVWF  FE9
817C:  MOVLW  00
817E:  ADDWFC 03,W
8180:  MOVWF  FEA
8182:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 0 
....................    disable_interrupts(GLOBAL); 
....................    save_coutcard(0); 
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................     
....................    save_key_encrypt(); 
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
....................     
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_data in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_key in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],1); 
....................    //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rdecrypted:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    while(1); 
.................... #endif 
.................... #if 0 
8184:  INCF   x01,F
8186:  BRA    816E
8188:  CLRF   19
818A:  BTFSC  FF2.7
818C:  BSF    19.7
818E:  BCF    FF2.7
....................     fprintf(COM2,"\n\reeprom test\n\r"); 
....................     fprintf(COM2,"\n\reeprom is writing\n\r"); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         //write_ext_eeprom(115535+i,i); 
....................     } 
....................     write_ext_eeprom(EEPROM_KEY_ST,210); 
....................     write_ext_eeprom(EEPROM_SIZE_endofkey,123); 
....................     fprintf(COM2,"\n\r"); 
....................     fprintf(COM2,"eeprom is reading: %u",read_ext_eeprom(EEPROM_KEY_ST)); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         fprintf(COM2," %u",read_ext_eeprom(115535+i)); 
....................     } 
....................     while(1); 
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
8190:  MOVLB  9
8192:  CLRF   x07
8194:  CLRF   x06
8196:  CLRF   x05
8198:  CLRF   x04
819A:  CLRF   x0B
819C:  CLRF   x0A
819E:  CLRF   x09
81A0:  MOVLW  14
81A2:  MOVWF  x08
81A4:  CLRF   x0D
81A6:  MOVLW  55
81A8:  MOVWF  x0C
81AA:  MOVLB  0
81AC:  CALL   4094
81B0:  BTFSC  19.7
81B2:  BSF    FF2.7
81B4:  CLRF   19
81B6:  BTFSC  FF2.7
81B8:  BSF    19.7
81BA:  BCF    FF2.7
....................    cryption_enable = read_ext_eeprom(crypto_en); 
81BC:  MOVLB  9
81BE:  CLRF   x1B
81C0:  CLRF   x1A
81C2:  CLRF   x19
81C4:  MOVLW  3E
81C6:  MOVWF  x18
81C8:  MOVLB  0
81CA:  CALL   3468
81CE:  BTFSC  19.7
81D0:  BSF    FF2.7
81D2:  MOVFF  01,122
....................    if(cryption_enable!=0) 
81D6:  MOVLB  1
81D8:  MOVF   x22,F
81DA:  BZ    8228
....................    { 
....................         fprintf(COM2,"\n\crypto is enable\n\r"); 
81DC:  MOVLW  8C
81DE:  MOVWF  FF6
81E0:  MOVLW  5C
81E2:  MOVWF  FF7
81E4:  CLRF   19
81E6:  BTFSC  FF2.7
81E8:  BSF    19.7
81EA:  BCF    FF2.7
81EC:  MOVLB  0
81EE:  CALL   174A
81F2:  BTFSC  19.7
81F4:  BSF    FF2.7
81F6:  CLRF   19
81F8:  BTFSC  FF2.7
81FA:  BSF    19.7
81FC:  BCF    FF2.7
....................         EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key);  
81FE:  MOVLB  9
8200:  CLRF   x07
8202:  CLRF   x06
8204:  CLRF   x05
8206:  MOVLW  3F
8208:  MOVWF  x04
820A:  CLRF   x0B
820C:  CLRF   x0A
820E:  CLRF   x09
8210:  MOVLW  20
8212:  MOVWF  x08
8214:  MOVLW  01
8216:  MOVWF  x0D
8218:  MOVWF  x0C
821A:  MOVLB  0
821C:  CALL   4094
8220:  BTFSC  19.7
8222:  BSF    FF2.7
....................    } 
....................    else 
8224:  BRA    8242
8226:  MOVLB  1
....................    { 
....................        fprintf(COM2,"\n\crypto is disable\n\r"); 
8228:  MOVLW  A0
822A:  MOVWF  FF6
822C:  MOVLW  5C
822E:  MOVWF  FF7
8230:  CLRF   19
8232:  BTFSC  FF2.7
8234:  BSF    19.7
8236:  BCF    FF2.7
8238:  MOVLB  0
823A:  CALL   174A
823E:  BTFSC  19.7
8240:  BSF    FF2.7
....................    } 
.................... #if 0    
....................    fprintf(COM2,"\n\crypto key:\n\r"); 
....................    for(i=0;i<CRYPTO_KEY_SIZE;i++) 
....................    { 
....................         fprintf(COM2,"%c",crypto_key[i]); 
....................    } 
....................    fprintf(COM2,"\n\r"); 
.................... #endif    
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
8242:  MOVLB  6
8244:  MOVF   xDC,F
8246:  BNZ   82FE
....................       { 
....................          fprintf(COM2,"password:"); 
8248:  MOVLW  B6
824A:  MOVWF  FF6
824C:  MOVLW  5C
824E:  MOVWF  FF7
8250:  CLRF   19
8252:  BTFSC  FF2.7
8254:  BSF    19.7
8256:  BCF    FF2.7
8258:  MOVLB  0
825A:  CALL   174A
825E:  BTFSC  19.7
8260:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
8262:  MOVLW  02
8264:  MOVLB  7
8266:  MOVWF  xF3
8268:  MOVLW  14
826A:  MOVWF  xF4
826C:  MOVLW  01
826E:  MOVWF  xF6
8270:  MOVLW  62
8272:  MOVWF  xF5
8274:  MOVLB  0
8276:  CALL   5F36
827A:  CLRF   19
827C:  BTFSC  FF2.7
827E:  BSF    19.7
8280:  BCF    FF2.7
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
8282:  MOVLB  9
8284:  CLRF   x07
8286:  CLRF   x06
8288:  CLRF   x05
828A:  CLRF   x04
828C:  CLRF   x0B
828E:  CLRF   x0A
8290:  CLRF   x09
8292:  MOVLW  14
8294:  MOVWF  x08
8296:  CLRF   x0D
8298:  MOVLW  55
829A:  MOVWF  x0C
829C:  MOVLB  0
829E:  CALL   4094
82A2:  BTFSC  19.7
82A4:  BSF    FF2.7
....................          if(!stringcomp(buffer_uart,password)) 
82A6:  MOVLW  01
82A8:  MOVLB  7
82AA:  MOVWF  xF4
82AC:  MOVLW  62
82AE:  MOVWF  xF3
82B0:  CLRF   xF6
82B2:  MOVLW  55
82B4:  MOVWF  xF5
82B6:  MOVLB  0
82B8:  CALL   606E
82BC:  MOVF   01,F
82BE:  BNZ   82E2
....................          { 
....................             mode=LOGON; 
82C0:  MOVLW  01
82C2:  MOVLB  6
82C4:  MOVWF  xDC
....................             fprintf(COM2," OK\n\r"); 
82C6:  MOVLW  C0
82C8:  MOVWF  FF6
82CA:  MOVLW  5C
82CC:  MOVWF  FF7
82CE:  CLRF   19
82D0:  BTFSC  FF2.7
82D2:  BSF    19.7
82D4:  BCF    FF2.7
82D6:  MOVLB  0
82D8:  CALL   174A
82DC:  BTFSC  19.7
82DE:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
82E0:  BRA    82FA
82E2:  MOVLW  C6
82E4:  MOVWF  FF6
82E6:  MOVLW  5C
82E8:  MOVWF  FF7
82EA:  CLRF   19
82EC:  BTFSC  FF2.7
82EE:  BSF    19.7
82F0:  BCF    FF2.7
82F2:  CALL   174A
82F6:  BTFSC  19.7
82F8:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
82FA:  BRA    8308
82FC:  MOVLB  6
82FE:  DECFSZ xDC,W
8300:  BRA    830A
8302:  MOVLB  0
8304:  GOTO   6A9E
8308:  MOVLB  6
....................    } 
830A:  BRA    8244
.................... } 
830C:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

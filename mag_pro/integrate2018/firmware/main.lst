CCS PCH C Compiler, Version 4.140, 33034               22-Jul-18 21:53

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   33476 bytes (51%)
                           Largest free fragment is 32048
               RAM used:   1983 (53%) at main() level
                           2369 (63%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   7CCA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   59EE
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1BEE
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0686:  MOVLW  02
0688:  MOVLB  8
068A:  SUBWF  x4E,F
068C:  BNC   06A6
068E:  MOVLW  08
0690:  MOVWF  FEA
0692:  MOVLW  4E
0694:  MOVWF  FE9
0696:  MOVF   FEF,W
0698:  BZ    06A6
069A:  BRA    06A2
069C:  BRA    069E
069E:  BRA    06A0
06A0:  NOP   
06A2:  DECFSZ FEF,F
06A4:  BRA    069C
06A6:  MOVLB  0
06A8:  GOTO   1BFE (RETURN)
*
18C6:  MOVLW  08
18C8:  MOVWF  FEA
18CA:  MOVLW  56
18CC:  MOVWF  FE9
18CE:  MOVF   FEF,W
18D0:  BZ    18EC
18D2:  MOVLW  0A
18D4:  MOVWF  01
18D6:  CLRF   00
18D8:  DECFSZ 00,F
18DA:  BRA    18D8
18DC:  DECFSZ 01,F
18DE:  BRA    18D6
18E0:  MOVLW  5F
18E2:  MOVWF  00
18E4:  DECFSZ 00,F
18E6:  BRA    18E4
18E8:  DECFSZ FEF,F
18EA:  BRA    18D2
18EC:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
1604:  BCF    F94.0
1606:  BCF    F8B.0
1608:  MOVLW  08
160A:  MOVWF  01
160C:  BRA    160E
160E:  NOP   
1610:  BSF    01.7
1612:  BRA    1634
1614:  BCF    01.7
1616:  MOVLB  9
1618:  RRCF   x0C,F
161A:  MOVLB  0
161C:  BTFSC  FD8.0
161E:  BSF    F8B.0
1620:  BTFSS  FD8.0
1622:  BCF    F8B.0
1624:  BSF    01.6
1626:  BRA    1634
1628:  BCF    01.6
162A:  DECFSZ 01,F
162C:  BRA    1616
162E:  BRA    1630
1630:  NOP   
1632:  BSF    F8B.0
1634:  MOVLW  10
1636:  MOVWF  FE9
1638:  DECFSZ FE9,F
163A:  BRA    1638
163C:  BRA    163E
163E:  NOP   
1640:  BTFSC  01.7
1642:  BRA    1614
1644:  BTFSC  01.6
1646:  BRA    1628
1648:  RETURN 0
*
5F46:  BSF    F94.1
5F48:  BTFSC  F82.1
5F4A:  BRA    5F48
5F4C:  MOVLW  08
5F4E:  MOVWF  00
5F50:  MOVLB  7
5F52:  CLRF   xFC
5F54:  BSF    00.7
5F56:  BRA    5F78
5F58:  BCF    00.7
5F5A:  BRA    5F78
5F5C:  MOVFF  7FC,02
5F60:  BCF    FD8.0
5F62:  BTFSC  F82.1
5F64:  BSF    FD8.0
5F66:  RRCF   02,F
5F68:  BSF    00.6
5F6A:  BRA    5F78
5F6C:  BCF    00.6
5F6E:  DECFSZ 00,F
5F70:  BRA    5F60
5F72:  MOVFF  02,01
5F76:  BRA    5F90
5F78:  MOVLW  10
5F7A:  BTFSC  00.7
5F7C:  MOVLW  04
5F7E:  MOVWF  01
5F80:  DECFSZ 01,F
5F82:  BRA    5F80
5F84:  BRA    5F86
5F86:  BTFSC  00.7
5F88:  BRA    5F58
5F8A:  BTFSC  00.6
5F8C:  BRA    5F6C
5F8E:  BRA    5F60
5F90:  MOVLB  0
5F92:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3370:  MOVLW  08
3372:  MOVWF  01
3374:  MOVLW  0A
3376:  MOVWF  00
3378:  DECFSZ 00,F
337A:  BRA    3378
337C:  BCF    F8B.3
337E:  BCF    F94.3
3380:  MOVLW  0B
3382:  MOVWF  00
3384:  DECFSZ 00,F
3386:  BRA    3384
3388:  MOVLB  9
338A:  RLCF   x23,F
338C:  BCF    F8B.4
338E:  BTFSC  FD8.0
3390:  BSF    F94.4
3392:  BTFSS  FD8.0
3394:  BCF    F94.4
3396:  BSF    F94.3
3398:  BTFSS  F82.3
339A:  BRA    3398
339C:  DECFSZ 01,F
339E:  BRA    33A2
33A0:  BRA    33A6
33A2:  MOVLB  0
33A4:  BRA    3374
33A6:  MOVLW  0A
33A8:  MOVWF  00
33AA:  DECFSZ 00,F
33AC:  BRA    33AA
33AE:  BCF    F8B.3
33B0:  BCF    F94.3
33B2:  NOP   
33B4:  BSF    F94.4
33B6:  MOVLW  0B
33B8:  MOVWF  00
33BA:  DECFSZ 00,F
33BC:  BRA    33BA
33BE:  MOVLW  0B
33C0:  MOVWF  00
33C2:  DECFSZ 00,F
33C4:  BRA    33C2
33C6:  BSF    F94.3
33C8:  BTFSS  F82.3
33CA:  BRA    33C8
33CC:  CLRF   01
33CE:  MOVLW  0B
33D0:  MOVWF  00
33D2:  DECFSZ 00,F
33D4:  BRA    33D2
33D6:  BTFSC  F82.4
33D8:  BSF    01.0
33DA:  BCF    F8B.3
33DC:  BCF    F94.3
33DE:  BCF    F8B.4
33E0:  BCF    F94.4
33E2:  MOVLB  0
33E4:  RETURN 0
33E6:  MOVLW  08
33E8:  MOVLB  9
33EA:  MOVWF  x1F
33EC:  MOVFF  00,920
33F0:  BSF    F94.4
33F2:  MOVLW  0B
33F4:  MOVWF  00
33F6:  DECFSZ 00,F
33F8:  BRA    33F6
33FA:  BSF    F94.3
33FC:  BTFSS  F82.3
33FE:  BRA    33FC
3400:  BTFSC  F82.4
3402:  BSF    FD8.0
3404:  BTFSS  F82.4
3406:  BCF    FD8.0
3408:  RLCF   01,F
340A:  MOVLW  0A
340C:  MOVWF  00
340E:  DECFSZ 00,F
3410:  BRA    340E
3412:  BCF    F94.3
3414:  BCF    F8B.3
3416:  DECFSZ x1F,F
3418:  BRA    33F0
341A:  BSF    F94.4
341C:  MOVLW  0B
341E:  MOVWF  00
3420:  DECFSZ 00,F
3422:  BRA    3420
3424:  BCF    F8B.4
3426:  MOVF   x20,W
3428:  BTFSS  FD8.2
342A:  BCF    F94.4
342C:  NOP   
342E:  BSF    F94.3
3430:  BTFSS  F82.3
3432:  BRA    3430
3434:  MOVLW  0A
3436:  MOVWF  00
3438:  DECFSZ 00,F
343A:  BRA    3438
343C:  BCF    F8B.3
343E:  BCF    F94.3
3440:  MOVLW  0B
3442:  MOVWF  00
3444:  DECFSZ 00,F
3446:  BRA    3444
3448:  BCF    F8B.4
344A:  BCF    F94.4
344C:  MOVLB  0
344E:  RETURN 0
....................  
.................... #define ptr_start                       150 
.................... #define EEPROM_SIZE_endofkey            131071 
.................... #define EEPROM_SIZE_stofkey             115470 
.................... #define EEPROM_KEY_ST                   EEPROM_SIZE_stofkey+1 
.................... //=============================== 
....................  
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5CF8:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
5CFA:  BSF    F94.4
....................    port_b_pullups(0xff); 
5CFC:  BCF    FF1.7
.................... } 
5CFE:  GOTO   7E62 (RETURN)
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3A6C:  MOVLB  9
3A6E:  MOVF   x16,F
3A70:  BNZ   3A78
3A72:  MOVF   x15,W
3A74:  SUBLW  00
3A76:  BC    3A7E
3A78:  MOVLW  A8
3A7A:  MOVWF  x19
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3A7C:  BRA    3A82
3A7E:  MOVLW  A0
3A80:  MOVWF  x19
....................  
....................    i2c_start(); 
3A82:  BSF    F94.4
3A84:  MOVLW  0A
3A86:  MOVWF  00
3A88:  DECFSZ 00,F
3A8A:  BRA    3A88
3A8C:  BSF    F94.3
3A8E:  MOVLW  0B
3A90:  MOVWF  00
3A92:  DECFSZ 00,F
3A94:  BRA    3A92
3A96:  BCF    F8B.4
3A98:  BCF    F94.4
3A9A:  MOVLW  0A
3A9C:  MOVWF  00
3A9E:  DECFSZ 00,F
3AA0:  BRA    3A9E
3AA2:  BCF    F8B.3
3AA4:  BCF    F94.3
....................    i2c_write(command); 
3AA6:  MOVFF  919,923
3AAA:  MOVLB  0
3AAC:  RCALL  3370
....................    i2c_write(address>>8); 
3AAE:  MOVFF  914,91B
3AB2:  MOVFF  915,91C
3AB6:  MOVFF  916,91D
3ABA:  MOVLB  9
3ABC:  CLRF   x1E
3ABE:  MOVFF  914,923
3AC2:  MOVLB  0
3AC4:  RCALL  3370
....................    i2c_write(address); 
3AC6:  MOVFF  913,923
3ACA:  RCALL  3370
....................    i2c_write(data); 
3ACC:  MOVFF  917,923
3AD0:  RCALL  3370
....................  
....................    i2c_stop(); 
3AD2:  BCF    F94.4
3AD4:  NOP   
3AD6:  BSF    F94.3
3AD8:  BTFSS  F82.3
3ADA:  BRA    3AD8
3ADC:  MOVLW  0A
3ADE:  MOVWF  00
3AE0:  DECFSZ 00,F
3AE2:  BRA    3AE0
3AE4:  BRA    3AE6
3AE6:  NOP   
3AE8:  BSF    F94.4
3AEA:  MOVLW  0A
3AEC:  MOVWF  00
3AEE:  DECFSZ 00,F
3AF0:  BRA    3AEE
....................    i2c_start(); 
3AF2:  BSF    F94.4
3AF4:  MOVLW  0A
3AF6:  MOVWF  00
3AF8:  DECFSZ 00,F
3AFA:  BRA    3AF8
3AFC:  BSF    F94.3
3AFE:  MOVLW  0B
3B00:  MOVWF  00
3B02:  DECFSZ 00,F
3B04:  BRA    3B02
3B06:  BCF    F8B.4
3B08:  BCF    F94.4
3B0A:  MOVLW  0A
3B0C:  MOVWF  00
3B0E:  DECFSZ 00,F
3B10:  BRA    3B0E
3B12:  BCF    F8B.3
3B14:  BCF    F94.3
....................    status=i2c_write(command); 
3B16:  MOVFF  919,923
3B1A:  RCALL  3370
3B1C:  MOVF   01,W
3B1E:  MOVLB  9
3B20:  BCF    x18.0
3B22:  BTFSC  01.0
3B24:  BSF    x18.0
....................    while(status==1) 
....................    { 
3B26:  BTFSS  x18.0
3B28:  BRA    3B66
....................       i2c_start(); 
3B2A:  BSF    F94.4
3B2C:  MOVLW  0A
3B2E:  MOVWF  00
3B30:  DECFSZ 00,F
3B32:  BRA    3B30
3B34:  BSF    F94.3
3B36:  MOVLW  0B
3B38:  MOVWF  00
3B3A:  DECFSZ 00,F
3B3C:  BRA    3B3A
3B3E:  BTFSS  F82.3
3B40:  BRA    3B3E
3B42:  BCF    F8B.4
3B44:  BCF    F94.4
3B46:  MOVLW  0A
3B48:  MOVWF  00
3B4A:  DECFSZ 00,F
3B4C:  BRA    3B4A
3B4E:  BCF    F8B.3
3B50:  BCF    F94.3
....................       status=i2c_write(command); 
3B52:  MOVFF  919,923
3B56:  MOVLB  0
3B58:  RCALL  3370
3B5A:  MOVF   01,W
3B5C:  MOVLB  9
3B5E:  BCF    x18.0
3B60:  BTFSC  01.0
3B62:  BSF    x18.0
....................    } 
3B64:  BRA    3B26
....................    //delay_us(100); 
.................... } 
3B66:  MOVLB  0
3B68:  RETURN 0
....................  
....................  
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3450:  MOVLB  9
3452:  MOVF   x1B,F
3454:  BNZ   345C
3456:  MOVF   x1A,W
3458:  SUBLW  00
345A:  BC    3462
345C:  MOVLW  A8
345E:  MOVWF  x1D
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3460:  BRA    3466
3462:  MOVLW  A0
3464:  MOVWF  x1D
....................  
....................    i2c_start(); 
3466:  BSF    F94.4
3468:  MOVLW  0A
346A:  MOVWF  00
346C:  DECFSZ 00,F
346E:  BRA    346C
3470:  BSF    F94.3
3472:  MOVLW  0B
3474:  MOVWF  00
3476:  DECFSZ 00,F
3478:  BRA    3476
347A:  BTFSS  F82.3
347C:  BRA    347A
347E:  BCF    F8B.4
3480:  BCF    F94.4
3482:  MOVLW  0A
3484:  MOVWF  00
3486:  DECFSZ 00,F
3488:  BRA    3486
348A:  BCF    F8B.3
348C:  BCF    F94.3
....................    i2c_write(command); 
348E:  MOVFF  91D,923
3492:  MOVLB  0
3494:  RCALL  3370
....................    i2c_write(address>>8); 
3496:  MOVFF  919,91F
349A:  MOVFF  91A,920
349E:  MOVFF  91B,921
34A2:  MOVLB  9
34A4:  CLRF   x22
34A6:  MOVFF  919,923
34AA:  MOVLB  0
34AC:  RCALL  3370
....................    i2c_write(address); 
34AE:  MOVFF  918,923
34B2:  RCALL  3370
....................    i2c_start(); 
34B4:  BSF    F94.4
34B6:  MOVLW  0A
34B8:  MOVWF  00
34BA:  DECFSZ 00,F
34BC:  BRA    34BA
34BE:  BSF    F94.3
34C0:  MOVLW  0B
34C2:  MOVWF  00
34C4:  DECFSZ 00,F
34C6:  BRA    34C4
34C8:  BTFSS  F82.3
34CA:  BRA    34C8
34CC:  BCF    F8B.4
34CE:  BCF    F94.4
34D0:  MOVLW  0A
34D2:  MOVWF  00
34D4:  DECFSZ 00,F
34D6:  BRA    34D4
34D8:  BCF    F8B.3
34DA:  BCF    F94.3
....................    i2c_write(command+1); 
34DC:  MOVLW  01
34DE:  MOVLB  9
34E0:  ADDWF  x1D,W
34E2:  MOVWF  x1E
34E4:  MOVWF  x23
34E6:  MOVLB  0
34E8:  RCALL  3370
....................    data=i2c_read(0); 
34EA:  CLRF   00
34EC:  RCALL  33E6
34EE:  MOVFF  01,91C
....................    i2c_stop(); 
34F2:  BCF    F94.4
34F4:  NOP   
34F6:  BSF    F94.3
34F8:  BTFSS  F82.3
34FA:  BRA    34F8
34FC:  MOVLW  0A
34FE:  MOVWF  00
3500:  DECFSZ 00,F
3502:  BRA    3500
3504:  BRA    3506
3506:  NOP   
3508:  BSF    F94.4
350A:  MOVLW  0A
350C:  MOVWF  00
350E:  DECFSZ 00,F
3510:  BRA    350E
....................    return(data); 
3512:  MOVLB  9
3514:  MOVFF  91C,01
.................... } 
3518:  MOVLB  0
351A:  RETURN 0
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr            0 
.................... #define strobe_ptrcard_addr         25     // 4 bytes 
.................... #define strobe_ptrcard_key          30     // 4 bytes 
.................... #define strobe_count_card           36     // 2 bytes 
.................... #define strobe_nameconsole          40     // 16 bytes  
.................... #define strobe_Master_SLV           58     // 1 byte 
.................... #define strobe_debugmode            59     // 1 byte 
.................... #define strobe_delaytime            60     // 1 byte 
.................... #define kindofKB                    61     // 1 byte 
.................... #define crypto_en                   62     // 1 byte 
.................... #define strobe_crypto_key           63     // 32 byte 
....................  
....................  
.................... #define wide_strobe_nameconsole     16  
.................... //============================================================== 
.................... #define numdata                  124    // 5+79+40=124 
.................... #define numdataofonecard         128    //  
.................... #define countcards               930    //43590/124 
....................  
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdataofonecard]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... #if 0 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... } 
.................... #endif 
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4EF6:  MOVLB  9
4EF8:  CLRF   x0D
4EFA:  CLRF   x0C
4EFC:  CLRF   x0B
4EFE:  CLRF   x0A
4F00:  MOVF   x0D,W
4F02:  SUBWF  x07,W
4F04:  BNC   4F7E
4F06:  BNZ   4F1E
4F08:  MOVF   x0C,W
4F0A:  SUBWF  x06,W
4F0C:  BNC   4F7E
4F0E:  BNZ   4F1E
4F10:  MOVF   x0B,W
4F12:  SUBWF  x05,W
4F14:  BNC   4F7E
4F16:  BNZ   4F1E
4F18:  MOVF   x04,W
4F1A:  SUBWF  x0A,W
4F1C:  BC    4F7E
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4F1E:  MOVF   x0A,W
4F20:  ADDWF  x00,W
4F22:  MOVWF  x0E
4F24:  MOVF   x0B,W
4F26:  ADDWFC x01,W
4F28:  MOVWF  x0F
4F2A:  MOVF   x0C,W
4F2C:  ADDWFC x02,W
4F2E:  MOVWF  x10
4F30:  MOVF   x0D,W
4F32:  ADDWFC x03,W
4F34:  MOVWF  x11
4F36:  MOVF   x08,W
4F38:  ADDWF  x0A,W
4F3A:  MOVWF  FE9
4F3C:  MOVF   x09,W
4F3E:  ADDWFC x0B,W
4F40:  MOVWF  FEA
4F42:  MOVFF  FEF,912
4F46:  MOVFF  911,916
4F4A:  MOVFF  910,915
4F4E:  MOVFF  90F,914
4F52:  MOVFF  90E,913
4F56:  MOVFF  912,917
4F5A:  MOVLB  0
4F5C:  CALL   3A6C
....................       delay_us(10); 
4F60:  MOVLW  1A
4F62:  MOVWF  00
4F64:  DECFSZ 00,F
4F66:  BRA    4F64
4F68:  NOP   
....................    } 
4F6A:  MOVLW  01
4F6C:  MOVLB  9
4F6E:  ADDWF  x0A,F
4F70:  BTFSC  FD8.0
4F72:  INCF   x0B,F
4F74:  BTFSC  FD8.2
4F76:  INCF   x0C,F
4F78:  BTFSC  FD8.2
4F7A:  INCF   x0D,F
4F7C:  BRA    4F00
....................    return 1; 
4F7E:  MOVLW  01
4F80:  MOVWF  01
.................... } 
4F82:  MOVLB  0
4F84:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len,unsigned int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4004:  MOVLB  9
4006:  CLRF   x11
4008:  CLRF   x10
400A:  CLRF   x0F
400C:  CLRF   x0E
400E:  MOVF   x11,W
4010:  SUBWF  x0B,W
4012:  BNC   4094
4014:  BNZ   402C
4016:  MOVF   x10,W
4018:  SUBWF  x0A,W
401A:  BNC   4094
401C:  BNZ   402C
401E:  MOVF   x0F,W
4020:  SUBWF  x09,W
4022:  BNC   4094
4024:  BNZ   402C
4026:  MOVF   x08,W
4028:  SUBWF  x0E,W
402A:  BC    4094
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
402C:  MOVF   x0C,W
402E:  ADDWF  x0E,W
4030:  MOVWF  01
4032:  MOVF   x0D,W
4034:  ADDWFC x0F,W
4036:  MOVWF  03
4038:  MOVFF  01,912
403C:  MOVWF  x13
403E:  MOVF   x0E,W
4040:  ADDWF  x04,W
4042:  MOVWF  x14
4044:  MOVF   x0F,W
4046:  ADDWFC x05,W
4048:  MOVWF  x15
404A:  MOVF   x10,W
404C:  ADDWFC x06,W
404E:  MOVWF  x16
4050:  MOVF   x11,W
4052:  ADDWFC x07,W
4054:  MOVWF  x17
4056:  MOVWF  x1B
4058:  MOVFF  916,91A
405C:  MOVFF  915,919
4060:  MOVFF  914,918
4064:  MOVLB  0
4066:  CALL   3450
406A:  MOVFF  913,FEA
406E:  MOVFF  912,FE9
4072:  MOVFF  01,FEF
....................       delay_us(10); 
4076:  MOVLW  1A
4078:  MOVWF  00
407A:  DECFSZ 00,F
407C:  BRA    407A
407E:  NOP   
....................    } 
4080:  MOVLW  01
4082:  MOVLB  9
4084:  ADDWF  x0E,F
4086:  BTFSC  FD8.0
4088:  INCF   x0F,F
408A:  BTFSC  FD8.2
408C:  INCF   x10,F
408E:  BTFSC  FD8.2
4090:  INCF   x11,F
4092:  BRA    400E
.................... } 
4094:  MOVLB  0
4096:  RETURN 0
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
5DBE:  MOVLB  7
5DC0:  CLRF   xC1
5DC2:  CLRF   xC0
5DC4:  CLRF   xBF
5DC6:  CLRF   xBE
5DC8:  CLRF   xC5
5DCA:  CLRF   xC4
5DCC:  CLRF   xC3
5DCE:  CLRF   xC2
5DD0:  CLRF   xC9
5DD2:  CLRF   xC8
5DD4:  CLRF   xC7
5DD6:  CLRF   xC6
5DD8:  CLRF   xCD
5DDA:  CLRF   xCC
5DDC:  CLRF   xCB
5DDE:  CLRF   xCA
5DE0:  CLRF   xD1
5DE2:  CLRF   xD0
5DE4:  CLRF   xCF
5DE6:  CLRF   xCE
5DE8:  CLRF   19
5DEA:  BTFSC  FF2.7
5DEC:  BSF    19.7
5DEE:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
5DF0:  MOVLB  9
5DF2:  CLRF   x1B
5DF4:  CLRF   x1A
5DF6:  CLRF   x19
5DF8:  MOVFF  7BD,918
5DFC:  MOVLB  0
5DFE:  CALL   3450
5E02:  BTFSC  19.7
5E04:  BSF    FF2.7
5E06:  MOVLB  7
5E08:  MOVFF  01,7C2
5E0C:  CLRF   xC3
5E0E:  CLRF   xC4
5E10:  CLRF   xC5
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
5E12:  MOVLW  01
5E14:  ADDWF  xBD,W
5E16:  MOVWF  xD2
5E18:  CLRF   19
5E1A:  BTFSC  FF2.7
5E1C:  BSF    19.7
5E1E:  BCF    FF2.7
5E20:  MOVLB  9
5E22:  CLRF   x1B
5E24:  CLRF   x1A
5E26:  CLRF   x19
5E28:  MOVWF  x18
5E2A:  MOVLB  0
5E2C:  CALL   3450
5E30:  BTFSC  19.7
5E32:  BSF    FF2.7
5E34:  MOVLB  7
5E36:  CLRF   xC9
5E38:  CLRF   xC8
5E3A:  CLRF   xC7
5E3C:  MOVFF  01,7C6
....................    temp2<<=8; 
5E40:  MOVFF  7C8,7C9
5E44:  MOVFF  7C7,7C8
5E48:  MOVFF  7C6,7C7
5E4C:  CLRF   xC6
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
5E4E:  MOVLW  02
5E50:  ADDWF  xBD,W
5E52:  MOVWF  xD2
5E54:  CLRF   19
5E56:  BTFSC  FF2.7
5E58:  BSF    19.7
5E5A:  BCF    FF2.7
5E5C:  MOVLB  9
5E5E:  CLRF   x1B
5E60:  CLRF   x1A
5E62:  CLRF   x19
5E64:  MOVWF  x18
5E66:  MOVLB  0
5E68:  CALL   3450
5E6C:  BTFSC  19.7
5E6E:  BSF    FF2.7
5E70:  MOVLB  7
5E72:  CLRF   xCD
5E74:  CLRF   xCC
5E76:  CLRF   xCB
5E78:  MOVFF  01,7CA
....................    temp3<<=16; 
5E7C:  MOVFF  7CB,7CD
5E80:  MOVFF  7CA,7CC
5E84:  CLRF   xCA
5E86:  CLRF   xCB
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
5E88:  MOVLW  03
5E8A:  ADDWF  xBD,W
5E8C:  MOVWF  xD2
5E8E:  CLRF   19
5E90:  BTFSC  FF2.7
5E92:  BSF    19.7
5E94:  BCF    FF2.7
5E96:  MOVLB  9
5E98:  CLRF   x1B
5E9A:  CLRF   x1A
5E9C:  CLRF   x19
5E9E:  MOVWF  x18
5EA0:  MOVLB  0
5EA2:  CALL   3450
5EA6:  BTFSC  19.7
5EA8:  BSF    FF2.7
5EAA:  MOVLB  7
5EAC:  CLRF   xD1
5EAE:  CLRF   xD0
5EB0:  CLRF   xCF
5EB2:  MOVFF  01,7CE
....................    temp4<<=24; 
5EB6:  MOVFF  7CE,7D1
5EBA:  CLRF   xCE
5EBC:  CLRF   xCF
5EBE:  CLRF   xD0
....................    buffer = temp4|temp3|temp2|temp1; 
5EC0:  MOVF   xCE,W
5EC2:  IORWF  xCA,W
5EC4:  MOVWF  xD2
5EC6:  MOVF   xCF,W
5EC8:  IORWF  xCB,W
5ECA:  MOVWF  xD3
5ECC:  MOVF   xD0,W
5ECE:  IORWF  xCC,W
5ED0:  MOVWF  xD4
5ED2:  MOVF   xD1,W
5ED4:  IORWF  xCD,W
5ED6:  MOVWF  xD5
5ED8:  MOVF   xC6,W
5EDA:  IORWF  xD2,F
5EDC:  MOVF   xC7,W
5EDE:  IORWF  xD3,F
5EE0:  MOVF   xC8,W
5EE2:  IORWF  xD4,F
5EE4:  MOVF   xC9,W
5EE6:  IORWF  xD5,F
5EE8:  MOVF   xD2,W
5EEA:  IORWF  xC2,W
5EEC:  MOVWF  xBE
5EEE:  MOVF   xD3,W
5EF0:  IORWF  xC3,W
5EF2:  MOVWF  xBF
5EF4:  MOVF   xD4,W
5EF6:  IORWF  xC4,W
5EF8:  MOVWF  xC0
5EFA:  MOVF   xD5,W
5EFC:  IORWF  xC5,W
5EFE:  MOVWF  xC1
....................    return(buffer); 
5F00:  MOVFF  7BE,00
5F04:  MOVFF  7BF,01
5F08:  MOVFF  7C0,02
5F0C:  MOVFF  7C1,03
.................... } 
5F10:  MOVLB  0
5F12:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3B6A:  MOVLB  8
3B6C:  CLRF   xFF
3B6E:  CLRF   xFE
3B70:  CLRF   xFD
3B72:  CLRF   xFC
3B74:  MOVLB  9
3B76:  CLRF   x00
3B78:  CLRF   x01
3B7A:  CLRF   x02
3B7C:  CLRF   x03
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3B7E:  MOVFF  8FA,8FF
3B82:  MOVFF  8F9,8FE
3B86:  MOVFF  8F8,8FD
3B8A:  MOVFF  8F7,8FC
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3B8E:  MOVFF  8FC,900
3B92:  MOVLB  9
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3B94:  MOVFF  8FD,901
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3B98:  MOVFF  8FE,902
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3B9C:  MOVFF  8FF,903
....................    write_ext_eeprom((addr+0),temp1); 
3BA0:  CLRF   x16
3BA2:  CLRF   x15
3BA4:  CLRF   x14
3BA6:  MOVFF  8FB,913
3BAA:  MOVFF  900,917
3BAE:  MOVLB  0
3BB0:  RCALL  3A6C
....................    write_ext_eeprom((addr+1),temp2); 
3BB2:  MOVLW  01
3BB4:  MOVLB  8
3BB6:  ADDWF  xFB,W
3BB8:  MOVLB  9
3BBA:  MOVWF  x04
3BBC:  CLRF   x16
3BBE:  CLRF   x15
3BC0:  CLRF   x14
3BC2:  MOVWF  x13
3BC4:  MOVFF  901,917
3BC8:  MOVLB  0
3BCA:  RCALL  3A6C
....................    write_ext_eeprom((addr+2),temp3); 
3BCC:  MOVLW  02
3BCE:  MOVLB  8
3BD0:  ADDWF  xFB,W
3BD2:  MOVLB  9
3BD4:  MOVWF  x04
3BD6:  CLRF   x16
3BD8:  CLRF   x15
3BDA:  CLRF   x14
3BDC:  MOVWF  x13
3BDE:  MOVFF  902,917
3BE2:  MOVLB  0
3BE4:  RCALL  3A6C
....................    write_ext_eeprom((addr+3),temp4); 
3BE6:  MOVLW  03
3BE8:  MOVLB  8
3BEA:  ADDWF  xFB,W
3BEC:  MOVLB  9
3BEE:  MOVWF  x04
3BF0:  CLRF   x16
3BF2:  CLRF   x15
3BF4:  CLRF   x14
3BF6:  MOVWF  x13
3BF8:  MOVFF  903,917
3BFC:  MOVLB  0
3BFE:  RCALL  3A6C
.................... } 
3C00:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
58B0:  MOVLB  8
58B2:  CLRF   x53
58B4:  CLRF   x52
58B6:  CLRF   x54
58B8:  CLRF   x55
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
58BA:  MOVFF  851,853
58BE:  MOVFF  850,852
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
58C2:  MOVFF  852,854
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
58C6:  MOVF   x53,W
58C8:  MOVWF  x55
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
58CA:  MOVLB  9
58CC:  CLRF   x16
58CE:  CLRF   x15
58D0:  CLRF   x14
58D2:  MOVLW  24
58D4:  MOVWF  x13
58D6:  MOVFF  854,917
58DA:  MOVLB  0
58DC:  CALL   3A6C
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
58E0:  MOVLB  9
58E2:  CLRF   x16
58E4:  CLRF   x15
58E6:  CLRF   x14
58E8:  MOVLW  25
58EA:  MOVWF  x13
58EC:  MOVFF  855,917
58F0:  MOVLB  0
58F2:  CALL   3A6C
.................... } 
58F6:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
351C:  MOVLB  8
351E:  CLRF   xF8
3520:  CLRF   xF7
3522:  CLRF   xFA
3524:  CLRF   xF9
3526:  CLRF   xFC
3528:  CLRF   xFB
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
352A:  MOVLB  9
352C:  CLRF   x1B
352E:  CLRF   x1A
3530:  CLRF   x19
3532:  MOVLW  24
3534:  MOVWF  x18
3536:  MOVLB  0
3538:  RCALL  3450
353A:  MOVLB  8
353C:  MOVFF  01,8F9
3540:  CLRF   xFA
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3542:  MOVLB  9
3544:  CLRF   x1B
3546:  CLRF   x1A
3548:  CLRF   x19
354A:  MOVLW  25
354C:  MOVWF  x18
354E:  MOVLB  0
3550:  RCALL  3450
3552:  MOVLB  8
3554:  CLRF   xFC
3556:  MOVFF  01,8FB
....................    temp2<<=8; 
355A:  MOVFF  8FB,8FC
355E:  CLRF   xFB
....................    buffer = temp2|temp1; 
3560:  MOVF   xFB,W
3562:  IORWF  xF9,W
3564:  MOVWF  xF7
3566:  MOVF   xFC,W
3568:  IORWF  xFA,W
356A:  MOVWF  xF8
....................    return(buffer); 
356C:  MOVFF  8F7,01
3570:  MOVFF  8F8,02
.................... } 
3574:  MOVLB  0
3576:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................    /*for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    }*/ 
....................    //fprintf(COM2," ptr_card=%lu\n\r",ptr_card); 
....................    /*for(i=ptr_start;i<ptr_card;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
*
689C:  CLRF   23
689E:  CLRF   22
68A0:  CLRF   21
68A2:  MOVLW  96
68A4:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
68A6:  CLRF   27
68A8:  MOVLW  01
68AA:  MOVWF  26
68AC:  MOVLW  C3
68AE:  MOVWF  25
68B0:  MOVLW  0F
68B2:  MOVWF  24
68B4:  CLRF   19
68B6:  BTFSC  FF2.7
68B8:  BSF    19.7
68BA:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
68BC:  MOVFF  23,8FA
68C0:  MOVFF  22,8F9
68C4:  MOVFF  21,8F8
68C8:  MOVFF  20,8F7
68CC:  MOVLW  19
68CE:  MOVLB  8
68D0:  MOVWF  xFB
68D2:  MOVLB  0
68D4:  CALL   3B6A
68D8:  BTFSC  19.7
68DA:  BSF    FF2.7
68DC:  CLRF   19
68DE:  BTFSC  FF2.7
68E0:  BSF    19.7
68E2:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
68E4:  MOVFF  27,8FA
68E8:  MOVFF  26,8F9
68EC:  MOVFF  25,8F8
68F0:  MOVFF  24,8F7
68F4:  MOVLW  1E
68F6:  MOVLB  8
68F8:  MOVWF  xFB
68FA:  MOVLB  0
68FC:  CALL   3B6A
6900:  BTFSC  19.7
6902:  BSF    FF2.7
6904:  CLRF   19
6906:  BTFSC  FF2.7
6908:  BSF    19.7
690A:  BCF    FF2.7
....................    save_coutcard(0); 
690C:  MOVLB  8
690E:  CLRF   x51
6910:  CLRF   x50
6912:  MOVLB  0
6914:  CALL   58B0
6918:  BTFSC  19.7
691A:  BSF    FF2.7
691C:  CLRF   19
691E:  BTFSC  FF2.7
6920:  BSF    19.7
6922:  BCF    FF2.7
....................    countcard=get_countcard(); 
6924:  CALL   351C
6928:  BTFSC  19.7
692A:  BSF    FF2.7
692C:  MOVFF  02,FE
6930:  MOVFF  01,FD
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
6934:  GOTO   6C94 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    ptr_card=ptr_start; 
6938:  CLRF   23
693A:  CLRF   22
693C:  CLRF   21
693E:  MOVLW  96
6940:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
6942:  CLRF   27
6944:  MOVLW  01
6946:  MOVWF  26
6948:  MOVLW  C3
694A:  MOVWF  25
694C:  MOVLW  0F
694E:  MOVWF  24
6950:  CLRF   19
6952:  BTFSC  FF2.7
6954:  BSF    19.7
6956:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
6958:  MOVFF  23,8FA
695C:  MOVFF  22,8F9
6960:  MOVFF  21,8F8
6964:  MOVFF  20,8F7
6968:  MOVLW  19
696A:  MOVLB  8
696C:  MOVWF  xFB
696E:  MOVLB  0
6970:  CALL   3B6A
6974:  BTFSC  19.7
6976:  BSF    FF2.7
6978:  CLRF   19
697A:  BTFSC  FF2.7
697C:  BSF    19.7
697E:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
6980:  MOVFF  27,8FA
6984:  MOVFF  26,8F9
6988:  MOVFF  25,8F8
698C:  MOVFF  24,8F7
6990:  MOVLW  1E
6992:  MOVLB  8
6994:  MOVWF  xFB
6996:  MOVLB  0
6998:  CALL   3B6A
699C:  BTFSC  19.7
699E:  BSF    FF2.7
69A0:  CLRF   19
69A2:  BTFSC  FF2.7
69A4:  BSF    19.7
69A6:  BCF    FF2.7
....................    save_coutcard(0); 
69A8:  MOVLB  8
69AA:  CLRF   x51
69AC:  CLRF   x50
69AE:  MOVLB  0
69B0:  CALL   58B0
69B4:  BTFSC  19.7
69B6:  BSF    FF2.7
.................... } 
69B8:  GOTO   6CF8 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
*
5D02:  CLRF   19
5D04:  BTFSC  FF2.7
5D06:  BSF    19.7
5D08:  BCF    FF2.7
....................       EEPROM_read(strobe_pass_addr,20,password); 
5D0A:  MOVLB  9
5D0C:  CLRF   x07
5D0E:  CLRF   x06
5D10:  CLRF   x05
5D12:  CLRF   x04
5D14:  CLRF   x0B
5D16:  CLRF   x0A
5D18:  CLRF   x09
5D1A:  MOVLW  14
5D1C:  MOVWF  x08
5D1E:  CLRF   x0D
5D20:  MOVLW  55
5D22:  MOVWF  x0C
5D24:  MOVLB  0
5D26:  CALL   4004
5D2A:  BTFSC  19.7
5D2C:  BSF    FF2.7
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5D2E:  INCFSZ 55,W
5D30:  BRA    5DBC
5D32:  INCFSZ 56,W
5D34:  BRA    5DBC
5D36:  INCFSZ x64,W
5D38:  BRA    5DBC
....................       { 
....................          memset(buffer1,0,20); 
5D3A:  CLRF   FEA
5D3C:  MOVLW  2D
5D3E:  MOVWF  FE9
5D40:  CLRF   00
5D42:  CLRF   02
5D44:  MOVLW  14
5D46:  MOVWF  01
5D48:  CALL   359A
....................          strcpy(buffer1,"admin"); 
5D4C:  CLRF   FEA
5D4E:  MOVLW  2D
5D50:  MOVWF  FE9
5D52:  MOVLW  00
5D54:  CALL   00BA
5D58:  TBLRD*-
5D5A:  TBLRD*+
5D5C:  MOVF   FF5,W
5D5E:  MOVWF  FEE
5D60:  IORLW  00
5D62:  BNZ   5D5A
5D64:  CLRF   19
5D66:  BTFSC  FF2.7
5D68:  BSF    19.7
5D6A:  BCF    FF2.7
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
5D6C:  MOVLB  9
5D6E:  CLRF   x03
5D70:  CLRF   x02
5D72:  CLRF   x01
5D74:  CLRF   x00
5D76:  CLRF   x07
5D78:  CLRF   x06
5D7A:  CLRF   x05
5D7C:  MOVLW  14
5D7E:  MOVWF  x04
5D80:  CLRF   x09
5D82:  MOVLW  2D
5D84:  MOVWF  x08
5D86:  MOVLB  0
5D88:  CALL   4EF6
5D8C:  BTFSC  19.7
5D8E:  BSF    FF2.7
5D90:  CLRF   19
5D92:  BTFSC  FF2.7
5D94:  BSF    19.7
5D96:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
5D98:  MOVLB  9
5D9A:  CLRF   x07
5D9C:  CLRF   x06
5D9E:  CLRF   x05
5DA0:  CLRF   x04
5DA2:  CLRF   x0B
5DA4:  CLRF   x0A
5DA6:  CLRF   x09
5DA8:  MOVLW  14
5DAA:  MOVWF  x08
5DAC:  CLRF   x0D
5DAE:  MOVLW  55
5DB0:  MOVWF  x0C
5DB2:  MOVLB  0
5DB4:  CALL   4004
5DB8:  BTFSC  19.7
5DBA:  BSF    FF2.7
....................       } 
.................... } 
5DBC:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
69BC:  MOVLB  8
69BE:  CLRF   x07
69C0:  MOVF   x07,W
69C2:  SUBLW  13
69C4:  BNC   69DA
69C6:  CLRF   03
69C8:  MOVF   x07,W
69CA:  ADDLW  F3
69CC:  MOVWF  FE9
69CE:  MOVLW  07
69D0:  ADDWFC 03,W
69D2:  MOVWF  FEA
69D4:  SETF   FEF
69D6:  INCF   x07,F
69D8:  BRA    69C0
69DA:  CLRF   19
69DC:  BTFSC  FF2.7
69DE:  BSF    19.7
69E0:  BCF    FF2.7
....................    EEPROM_write(strobe_pass_addr,20,buf); 
69E2:  MOVLB  9
69E4:  CLRF   x03
69E6:  CLRF   x02
69E8:  CLRF   x01
69EA:  CLRF   x00
69EC:  CLRF   x07
69EE:  CLRF   x06
69F0:  CLRF   x05
69F2:  MOVLW  14
69F4:  MOVWF  x04
69F6:  MOVLW  07
69F8:  MOVWF  x09
69FA:  MOVLW  F3
69FC:  MOVWF  x08
69FE:  MOVLB  0
6A00:  CALL   4EF6
6A04:  BTFSC  19.7
6A06:  BSF    FF2.7
.................... } 
6A08:  GOTO   6D5C (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
....................  
.................... #define CRYPTO_KEY_SIZE   32 
....................  
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 cryption_enable=0; 
....................  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int16 galois_mul2(unsigned int16 value) 
.................... { 
....................   signed int16 temp; 
....................   // cast to signed value 
....................   temp = (signed char) value; 
*
4098:  CLRF   03
409A:  MOVLB  9
409C:  MOVF   x0D,W
409E:  BTFSC  FE8.7
40A0:  DECF   03,F
40A2:  MOVWF  x0F
40A4:  MOVFF  03,910
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
40A8:  RRCF   x10,W
40AA:  MOVWF  03
40AC:  RRCF   x0F,W
40AE:  MOVWF  02
40B0:  RRCF   03,F
40B2:  RRCF   02,F
40B4:  RRCF   03,F
40B6:  RRCF   02,F
40B8:  RRCF   03,F
40BA:  RRCF   02,F
40BC:  RRCF   03,F
40BE:  RRCF   02,F
40C0:  RRCF   03,F
40C2:  RRCF   02,F
40C4:  RRCF   03,F
40C6:  RRCF   02,F
40C8:  MOVLW  01
40CA:  ANDWF  03,F
40CC:  MOVFF  02,90F
40D0:  MOVFF  03,910
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
40D4:  MOVLW  1B
40D6:  ANDWF  x0F,F
40D8:  CLRF   x10
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
40DA:  BCF    FD8.0
40DC:  RLCF   x0D,W
40DE:  MOVWF  x11
40E0:  RLCF   x0E,W
40E2:  MOVWF  x12
40E4:  MOVF   x11,W
40E6:  XORWF  x0F,W
40E8:  MOVWF  00
40EA:  MOVF   x12,W
40EC:  XORWF  x10,W
40EE:  MOVWF  03
40F0:  MOVFF  00,01
40F4:  MOVWF  02
.................... } 
40F6:  MOVLB  0
40F8:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................     unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................  
....................   // In case of decryption 
....................   if (dir != 0)  
40FA:  MOVLB  8
40FC:  MOVF   xFB,F
40FE:  BTFSC  FD8.2
4100:  BRA    430A
....................   { 
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
4102:  MOVLB  9
4104:  CLRF   x00
4106:  MOVF   x00,W
4108:  SUBLW  09
410A:  BTFSS  FD8.0
410C:  BRA    42B4
....................       //key schedule 
....................       key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[round]); 
410E:  MOVFF  8F9,01
4112:  MOVFF  8FA,03
4116:  MOVFF  8F9,902
411A:  MOVFF  8FA,903
411E:  MOVLW  0D
4120:  MOVLB  8
4122:  ADDWF  xF9,W
4124:  MOVWF  FE9
4126:  MOVLW  00
4128:  ADDWFC xFA,W
412A:  MOVWF  FEA
412C:  CLRF   03
412E:  MOVF   FEF,W
4130:  MOVLB  0
4132:  CALL   00D0
4136:  MOVLB  9
4138:  MOVWF  x04
413A:  MOVLB  8
413C:  MOVFF  8F9,FE9
4140:  MOVFF  8FA,FEA
4144:  MOVF   FEF,W
4146:  MOVLB  9
4148:  XORWF  x04,F
414A:  CLRF   03
414C:  MOVF   x00,W
414E:  MOVLB  0
4150:  CALL   02F0
4154:  MOVWF  01
4156:  MOVLB  9
4158:  MOVF   x04,W
415A:  XORWF  01,W
415C:  MOVFF  903,FEA
4160:  MOVFF  902,FE9
4164:  MOVWF  FEF
....................       key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4166:  MOVLW  01
4168:  MOVLB  8
416A:  ADDWF  xF9,W
416C:  MOVWF  01
416E:  MOVLW  00
4170:  ADDWFC xFA,W
4172:  MOVWF  03
4174:  MOVFF  01,902
4178:  MOVLB  9
417A:  MOVWF  x03
417C:  MOVLW  0E
417E:  MOVLB  8
4180:  ADDWF  xF9,W
4182:  MOVWF  FE9
4184:  MOVLW  00
4186:  ADDWFC xFA,W
4188:  MOVWF  FEA
418A:  CLRF   03
418C:  MOVF   FEF,W
418E:  MOVLB  0
4190:  CALL   00D0
4194:  MOVLB  9
4196:  MOVWF  x04
4198:  MOVLW  01
419A:  MOVLB  8
419C:  ADDWF  xF9,W
419E:  MOVWF  FE9
41A0:  MOVLW  00
41A2:  ADDWFC xFA,W
41A4:  MOVWF  FEA
41A6:  MOVF   FEF,W
41A8:  MOVLB  9
41AA:  XORWF  x04,W
41AC:  MOVFF  903,FEA
41B0:  MOVFF  902,FE9
41B4:  MOVWF  FEF
....................       key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
41B6:  MOVLW  02
41B8:  MOVLB  8
41BA:  ADDWF  xF9,W
41BC:  MOVWF  01
41BE:  MOVLW  00
41C0:  ADDWFC xFA,W
41C2:  MOVWF  03
41C4:  MOVFF  01,902
41C8:  MOVLB  9
41CA:  MOVWF  x03
41CC:  MOVLW  0F
41CE:  MOVLB  8
41D0:  ADDWF  xF9,W
41D2:  MOVWF  FE9
41D4:  MOVLW  00
41D6:  ADDWFC xFA,W
41D8:  MOVWF  FEA
41DA:  CLRF   03
41DC:  MOVF   FEF,W
41DE:  MOVLB  0
41E0:  CALL   00D0
41E4:  MOVLB  9
41E6:  MOVWF  x04
41E8:  MOVLW  02
41EA:  MOVLB  8
41EC:  ADDWF  xF9,W
41EE:  MOVWF  FE9
41F0:  MOVLW  00
41F2:  ADDWFC xFA,W
41F4:  MOVWF  FEA
41F6:  MOVF   FEF,W
41F8:  MOVLB  9
41FA:  XORWF  x04,W
41FC:  MOVFF  903,FEA
4200:  MOVFF  902,FE9
4204:  MOVWF  FEF
....................       key[3] = (unsigned int8)(sbox[key[12]]^key[3]); 
4206:  MOVLW  03
4208:  MOVLB  8
420A:  ADDWF  xF9,W
420C:  MOVWF  01
420E:  MOVLW  00
4210:  ADDWFC xFA,W
4212:  MOVWF  03
4214:  MOVFF  01,902
4218:  MOVLB  9
421A:  MOVWF  x03
421C:  MOVLW  0C
421E:  MOVLB  8
4220:  ADDWF  xF9,W
4222:  MOVWF  FE9
4224:  MOVLW  00
4226:  ADDWFC xFA,W
4228:  MOVWF  FEA
422A:  CLRF   03
422C:  MOVF   FEF,W
422E:  MOVLB  0
4230:  CALL   00D0
4234:  MOVLB  9
4236:  MOVWF  x04
4238:  MOVLW  03
423A:  MOVLB  8
423C:  ADDWF  xF9,W
423E:  MOVWF  FE9
4240:  MOVLW  00
4242:  ADDWFC xFA,W
4244:  MOVWF  FEA
4246:  MOVF   FEF,W
4248:  MOVLB  9
424A:  XORWF  x04,W
424C:  MOVFF  903,FEA
4250:  MOVFF  902,FE9
4254:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4256:  MOVLW  04
4258:  MOVWF  x01
425A:  MOVF   x01,W
425C:  SUBLW  0F
425E:  BNC   42B0
....................         key[i] = key[i] ^ key[i-4]; 
4260:  CLRF   03
4262:  MOVF   x01,W
4264:  MOVLB  8
4266:  ADDWF  xF9,W
4268:  MOVWF  01
426A:  MOVF   xFA,W
426C:  ADDWFC 03,F
426E:  MOVLB  9
4270:  MOVFF  03,903
4274:  CLRF   03
4276:  MOVF   x01,W
4278:  MOVLB  8
427A:  ADDWF  xF9,W
427C:  MOVWF  FE9
427E:  MOVF   xFA,W
4280:  ADDWFC 03,W
4282:  MOVWF  FEA
4284:  MOVFF  FEF,904
4288:  MOVLW  04
428A:  MOVLB  9
428C:  SUBWF  x01,W
428E:  CLRF   03
4290:  MOVLB  8
4292:  ADDWF  xF9,W
4294:  MOVWF  FE9
4296:  MOVF   xFA,W
4298:  ADDWFC 03,W
429A:  MOVWF  FEA
429C:  MOVF   FEF,W
429E:  MOVLB  9
42A0:  XORWF  x04,W
42A2:  MOVFF  903,FEA
42A6:  MOVFF  01,FE9
42AA:  MOVWF  FEF
....................       } 
42AC:  INCF   x01,F
42AE:  BRA    425A
....................     } 
42B0:  INCF   x00,F
42B2:  BRA    4106
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++) 
42B4:  CLRF   x01
42B6:  MOVF   x01,W
42B8:  SUBLW  0F
42BA:  BNC   430A
....................     { 
....................       state[i]=state[i] ^ key[i]; 
42BC:  CLRF   03
42BE:  MOVF   x01,W
42C0:  MOVLB  8
42C2:  ADDWF  xF7,W
42C4:  MOVWF  01
42C6:  MOVF   xF8,W
42C8:  ADDWFC 03,F
42CA:  MOVLB  9
42CC:  MOVFF  03,903
42D0:  CLRF   03
42D2:  MOVF   x01,W
42D4:  MOVLB  8
42D6:  ADDWF  xF7,W
42D8:  MOVWF  FE9
42DA:  MOVF   xF8,W
42DC:  ADDWFC 03,W
42DE:  MOVWF  FEA
42E0:  MOVFF  FEF,904
42E4:  CLRF   03
42E6:  MOVLB  9
42E8:  MOVF   x01,W
42EA:  MOVLB  8
42EC:  ADDWF  xF9,W
42EE:  MOVWF  FE9
42F0:  MOVF   xFA,W
42F2:  ADDWFC 03,W
42F4:  MOVWF  FEA
42F6:  MOVF   FEF,W
42F8:  MOVLB  9
42FA:  XORWF  x04,W
42FC:  MOVFF  903,FEA
4300:  MOVFF  01,FE9
4304:  MOVWF  FEF
....................     } 
4306:  INCF   x01,F
4308:  BRA    42B6
....................   } 
....................   // main loop 
....................   for (round = 0; round < 10; round++) 
430A:  MOVLB  9
430C:  CLRF   x00
430E:  MOVF   x00,W
4310:  SUBLW  09
4312:  BTFSS  FD8.0
4314:  GOTO   4E92
....................   { 
....................     if (dir != 0) 
4318:  MOVLB  8
431A:  MOVF   xFB,F
431C:  BTFSC  FD8.2
431E:  BRA    44CC
....................     { 
....................           //Inverse key schedule 
....................           for (i=15; i>3; --i)  
4320:  MOVLW  0F
4322:  MOVLB  9
4324:  MOVWF  x01
4326:  MOVF   x01,W
4328:  SUBLW  03
432A:  BC    437C
....................           { 
....................             key[i] = key[i] ^ key[i-4]; 
432C:  CLRF   03
432E:  MOVF   x01,W
4330:  MOVLB  8
4332:  ADDWF  xF9,W
4334:  MOVWF  01
4336:  MOVF   xFA,W
4338:  ADDWFC 03,F
433A:  MOVLB  9
433C:  MOVFF  03,903
4340:  CLRF   03
4342:  MOVF   x01,W
4344:  MOVLB  8
4346:  ADDWF  xF9,W
4348:  MOVWF  FE9
434A:  MOVF   xFA,W
434C:  ADDWFC 03,W
434E:  MOVWF  FEA
4350:  MOVFF  FEF,904
4354:  MOVLW  04
4356:  MOVLB  9
4358:  SUBWF  x01,W
435A:  CLRF   03
435C:  MOVLB  8
435E:  ADDWF  xF9,W
4360:  MOVWF  FE9
4362:  MOVF   xFA,W
4364:  ADDWFC 03,W
4366:  MOVWF  FEA
4368:  MOVF   FEF,W
436A:  MOVLB  9
436C:  XORWF  x04,W
436E:  MOVFF  903,FEA
4372:  MOVFF  01,FE9
4376:  MOVWF  FEF
....................           }   
4378:  DECF   x01,F
437A:  BRA    4326
....................           key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[9-round]); 
437C:  MOVFF  8F9,01
4380:  MOVFF  8FA,03
4384:  MOVFF  8F9,902
4388:  MOVFF  8FA,903
438C:  MOVLW  0D
438E:  MOVLB  8
4390:  ADDWF  xF9,W
4392:  MOVWF  FE9
4394:  MOVLW  00
4396:  ADDWFC xFA,W
4398:  MOVWF  FEA
439A:  CLRF   03
439C:  MOVF   FEF,W
439E:  MOVLB  0
43A0:  CALL   00D0
43A4:  MOVLB  9
43A6:  MOVWF  x04
43A8:  MOVLB  8
43AA:  MOVFF  8F9,FE9
43AE:  MOVFF  8FA,FEA
43B2:  MOVF   FEF,W
43B4:  MOVLB  9
43B6:  XORWF  x04,F
43B8:  MOVLW  09
43BA:  BSF    FD8.0
43BC:  SUBFWB x00,W
43BE:  CLRF   03
43C0:  MOVLB  0
43C2:  CALL   02F0
43C6:  MOVWF  01
43C8:  MOVLB  9
43CA:  MOVF   x04,W
43CC:  XORWF  01,W
43CE:  MOVFF  903,FEA
43D2:  MOVFF  902,FE9
43D6:  MOVWF  FEF
....................           key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
43D8:  MOVLW  01
43DA:  MOVLB  8
43DC:  ADDWF  xF9,W
43DE:  MOVWF  01
43E0:  MOVLW  00
43E2:  ADDWFC xFA,W
43E4:  MOVWF  03
43E6:  MOVFF  01,902
43EA:  MOVLB  9
43EC:  MOVWF  x03
43EE:  MOVLW  0E
43F0:  MOVLB  8
43F2:  ADDWF  xF9,W
43F4:  MOVWF  FE9
43F6:  MOVLW  00
43F8:  ADDWFC xFA,W
43FA:  MOVWF  FEA
43FC:  CLRF   03
43FE:  MOVF   FEF,W
4400:  MOVLB  0
4402:  CALL   00D0
4406:  MOVLB  9
4408:  MOVWF  x04
440A:  MOVLW  01
440C:  MOVLB  8
440E:  ADDWF  xF9,W
4410:  MOVWF  FE9
4412:  MOVLW  00
4414:  ADDWFC xFA,W
4416:  MOVWF  FEA
4418:  MOVF   FEF,W
441A:  MOVLB  9
441C:  XORWF  x04,W
441E:  MOVFF  903,FEA
4422:  MOVFF  902,FE9
4426:  MOVWF  FEF
....................           key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
4428:  MOVLW  02
442A:  MOVLB  8
442C:  ADDWF  xF9,W
442E:  MOVWF  01
4430:  MOVLW  00
4432:  ADDWFC xFA,W
4434:  MOVWF  03
4436:  MOVFF  01,902
443A:  MOVLB  9
443C:  MOVWF  x03
443E:  MOVLW  0F
4440:  MOVLB  8
4442:  ADDWF  xF9,W
4444:  MOVWF  FE9
4446:  MOVLW  00
4448:  ADDWFC xFA,W
444A:  MOVWF  FEA
444C:  CLRF   03
444E:  MOVF   FEF,W
4450:  MOVLB  0
4452:  CALL   00D0
4456:  MOVLB  9
4458:  MOVWF  x04
445A:  MOVLW  02
445C:  MOVLB  8
445E:  ADDWF  xF9,W
4460:  MOVWF  FE9
4462:  MOVLW  00
4464:  ADDWFC xFA,W
4466:  MOVWF  FEA
4468:  MOVF   FEF,W
446A:  MOVLB  9
446C:  XORWF  x04,W
446E:  MOVFF  903,FEA
4472:  MOVFF  902,FE9
4476:  MOVWF  FEF
....................           key[3] = (unsigned int8)(sbox[key[12]]^key[3]);  
4478:  MOVLW  03
447A:  MOVLB  8
447C:  ADDWF  xF9,W
447E:  MOVWF  01
4480:  MOVLW  00
4482:  ADDWFC xFA,W
4484:  MOVWF  03
4486:  MOVFF  01,902
448A:  MOVLB  9
448C:  MOVWF  x03
448E:  MOVLW  0C
4490:  MOVLB  8
4492:  ADDWF  xF9,W
4494:  MOVWF  FE9
4496:  MOVLW  00
4498:  ADDWFC xFA,W
449A:  MOVWF  FEA
449C:  CLRF   03
449E:  MOVF   FEF,W
44A0:  MOVLB  0
44A2:  CALL   00D0
44A6:  MOVLB  9
44A8:  MOVWF  x04
44AA:  MOVLW  03
44AC:  MOVLB  8
44AE:  ADDWF  xF9,W
44B0:  MOVWF  FE9
44B2:  MOVLW  00
44B4:  ADDWFC xFA,W
44B6:  MOVWF  FEA
44B8:  MOVF   FEF,W
44BA:  MOVLB  9
44BC:  XORWF  x04,W
44BE:  MOVFF  903,FEA
44C2:  MOVFF  902,FE9
44C6:  MOVWF  FEF
....................     }  
....................     else  
44C8:  BRA    4726
44CA:  MOVLB  8
....................     { 
....................         for (i = 0; i <16; i++) 
44CC:  MOVLB  9
44CE:  CLRF   x01
44D0:  MOVF   x01,W
44D2:  SUBLW  0F
44D4:  BNC   4532
....................         { 
....................             // with shiftrow i+5 mod 16 
....................             state[i]=sbox[state[i] ^ key[i]]; 
44D6:  CLRF   03
44D8:  MOVF   x01,W
44DA:  MOVLB  8
44DC:  ADDWF  xF7,W
44DE:  MOVWF  01
44E0:  MOVF   xF8,W
44E2:  ADDWFC 03,F
44E4:  MOVFF  01,902
44E8:  MOVLB  9
44EA:  MOVFF  03,903
44EE:  CLRF   03
44F0:  MOVF   x01,W
44F2:  MOVLB  8
44F4:  ADDWF  xF7,W
44F6:  MOVWF  FE9
44F8:  MOVF   xF8,W
44FA:  ADDWFC 03,W
44FC:  MOVWF  FEA
44FE:  MOVFF  FEF,904
4502:  CLRF   03
4504:  MOVLB  9
4506:  MOVF   x01,W
4508:  MOVLB  8
450A:  ADDWF  xF9,W
450C:  MOVWF  FE9
450E:  MOVF   xFA,W
4510:  ADDWFC 03,W
4512:  MOVWF  FEA
4514:  MOVF   FEF,W
4516:  MOVLB  9
4518:  XORWF  x04,W
451A:  CLRF   03
451C:  MOVLB  0
451E:  CALL   00D0
4522:  MOVFF  903,FEA
4526:  MOVFF  902,FE9
452A:  MOVWF  FEF
....................         } 
452C:  MOVLB  9
452E:  INCF   x01,F
4530:  BRA    44D0
....................         //shift rows 
....................         buf1 = state[1]; 
4532:  MOVLW  01
4534:  MOVLB  8
4536:  ADDWF  xF7,W
4538:  MOVWF  FE9
453A:  MOVLW  00
453C:  ADDWFC xF8,W
453E:  MOVWF  FEA
4540:  MOVFF  FEF,8FC
....................         state[1] = state[5]; 
4544:  MOVLW  01
4546:  ADDWF  xF7,W
4548:  MOVWF  01
454A:  MOVLW  00
454C:  ADDWFC xF8,W
454E:  MOVWF  03
4550:  MOVLW  05
4552:  MOVLB  8
4554:  ADDWF  xF7,W
4556:  MOVWF  FE9
4558:  MOVLW  00
455A:  ADDWFC xF8,W
455C:  MOVWF  FEA
455E:  MOVFF  FEF,904
4562:  MOVLB  9
4564:  MOVFF  03,FEA
4568:  MOVFF  01,FE9
456C:  MOVFF  904,FEF
....................         state[5] = state[9]; 
4570:  MOVLW  05
4572:  MOVLB  8
4574:  ADDWF  xF7,W
4576:  MOVWF  01
4578:  MOVLW  00
457A:  ADDWFC xF8,W
457C:  MOVWF  03
457E:  MOVLW  09
4580:  MOVLB  8
4582:  ADDWF  xF7,W
4584:  MOVWF  FE9
4586:  MOVLW  00
4588:  ADDWFC xF8,W
458A:  MOVWF  FEA
458C:  MOVFF  FEF,904
4590:  MOVLB  9
4592:  MOVFF  03,FEA
4596:  MOVFF  01,FE9
459A:  MOVFF  904,FEF
....................         state[9] = state[13]; 
459E:  MOVLW  09
45A0:  MOVLB  8
45A2:  ADDWF  xF7,W
45A4:  MOVWF  01
45A6:  MOVLW  00
45A8:  ADDWFC xF8,W
45AA:  MOVWF  03
45AC:  MOVLW  0D
45AE:  MOVLB  8
45B0:  ADDWF  xF7,W
45B2:  MOVWF  FE9
45B4:  MOVLW  00
45B6:  ADDWFC xF8,W
45B8:  MOVWF  FEA
45BA:  MOVFF  FEF,904
45BE:  MOVLB  9
45C0:  MOVFF  03,FEA
45C4:  MOVFF  01,FE9
45C8:  MOVFF  904,FEF
....................         state[13] = buf1; 
45CC:  MOVLW  0D
45CE:  MOVLB  8
45D0:  ADDWF  xF7,W
45D2:  MOVWF  FE9
45D4:  MOVLW  00
45D6:  ADDWFC xF8,W
45D8:  MOVWF  FEA
45DA:  MOVFF  8FC,FEF
....................      
....................         buf1 = state[2]; 
45DE:  MOVLW  02
45E0:  ADDWF  xF7,W
45E2:  MOVWF  FE9
45E4:  MOVLW  00
45E6:  ADDWFC xF8,W
45E8:  MOVWF  FEA
45EA:  MOVFF  FEF,8FC
....................         buf2 = state[6]; 
45EE:  MOVLW  06
45F0:  ADDWF  xF7,W
45F2:  MOVWF  FE9
45F4:  MOVLW  00
45F6:  ADDWFC xF8,W
45F8:  MOVWF  FEA
45FA:  MOVFF  FEF,8FD
....................         state[2] = state[10]; 
45FE:  MOVLW  02
4600:  ADDWF  xF7,W
4602:  MOVWF  01
4604:  MOVLW  00
4606:  ADDWFC xF8,W
4608:  MOVWF  03
460A:  MOVLW  0A
460C:  MOVLB  8
460E:  ADDWF  xF7,W
4610:  MOVWF  FE9
4612:  MOVLW  00
4614:  ADDWFC xF8,W
4616:  MOVWF  FEA
4618:  MOVFF  FEF,904
461C:  MOVLB  9
461E:  MOVFF  03,FEA
4622:  MOVFF  01,FE9
4626:  MOVFF  904,FEF
....................         state[6] = state[14]; 
462A:  MOVLW  06
462C:  MOVLB  8
462E:  ADDWF  xF7,W
4630:  MOVWF  01
4632:  MOVLW  00
4634:  ADDWFC xF8,W
4636:  MOVWF  03
4638:  MOVLW  0E
463A:  MOVLB  8
463C:  ADDWF  xF7,W
463E:  MOVWF  FE9
4640:  MOVLW  00
4642:  ADDWFC xF8,W
4644:  MOVWF  FEA
4646:  MOVFF  FEF,904
464A:  MOVLB  9
464C:  MOVFF  03,FEA
4650:  MOVFF  01,FE9
4654:  MOVFF  904,FEF
....................         state[10] = buf1; 
4658:  MOVLW  0A
465A:  MOVLB  8
465C:  ADDWF  xF7,W
465E:  MOVWF  FE9
4660:  MOVLW  00
4662:  ADDWFC xF8,W
4664:  MOVWF  FEA
4666:  MOVFF  8FC,FEF
....................         state[14] = buf2; 
466A:  MOVLW  0E
466C:  ADDWF  xF7,W
466E:  MOVWF  FE9
4670:  MOVLW  00
4672:  ADDWFC xF8,W
4674:  MOVWF  FEA
4676:  MOVFF  8FD,FEF
....................      
....................         buf1 = state[15]; 
467A:  MOVLW  0F
467C:  ADDWF  xF7,W
467E:  MOVWF  FE9
4680:  MOVLW  00
4682:  ADDWFC xF8,W
4684:  MOVWF  FEA
4686:  MOVFF  FEF,8FC
....................         state[15] = state[11]; 
468A:  MOVLW  0F
468C:  ADDWF  xF7,W
468E:  MOVWF  01
4690:  MOVLW  00
4692:  ADDWFC xF8,W
4694:  MOVWF  03
4696:  MOVLW  0B
4698:  MOVLB  8
469A:  ADDWF  xF7,W
469C:  MOVWF  FE9
469E:  MOVLW  00
46A0:  ADDWFC xF8,W
46A2:  MOVWF  FEA
46A4:  MOVFF  FEF,904
46A8:  MOVLB  9
46AA:  MOVFF  03,FEA
46AE:  MOVFF  01,FE9
46B2:  MOVFF  904,FEF
....................         state[11] = state[7]; 
46B6:  MOVLW  0B
46B8:  MOVLB  8
46BA:  ADDWF  xF7,W
46BC:  MOVWF  01
46BE:  MOVLW  00
46C0:  ADDWFC xF8,W
46C2:  MOVWF  03
46C4:  MOVLW  07
46C6:  MOVLB  8
46C8:  ADDWF  xF7,W
46CA:  MOVWF  FE9
46CC:  MOVLW  00
46CE:  ADDWFC xF8,W
46D0:  MOVWF  FEA
46D2:  MOVFF  FEF,904
46D6:  MOVLB  9
46D8:  MOVFF  03,FEA
46DC:  MOVFF  01,FE9
46E0:  MOVFF  904,FEF
....................         state[7] = state[3]; 
46E4:  MOVLW  07
46E6:  MOVLB  8
46E8:  ADDWF  xF7,W
46EA:  MOVWF  01
46EC:  MOVLW  00
46EE:  ADDWFC xF8,W
46F0:  MOVWF  03
46F2:  MOVLW  03
46F4:  MOVLB  8
46F6:  ADDWF  xF7,W
46F8:  MOVWF  FE9
46FA:  MOVLW  00
46FC:  ADDWFC xF8,W
46FE:  MOVWF  FEA
4700:  MOVFF  FEF,904
4704:  MOVLB  9
4706:  MOVFF  03,FEA
470A:  MOVFF  01,FE9
470E:  MOVFF  904,FEF
....................         state[3] = buf1; 
4712:  MOVLW  03
4714:  MOVLB  8
4716:  ADDWF  xF7,W
4718:  MOVWF  FE9
471A:  MOVLW  00
471C:  ADDWFC xF8,W
471E:  MOVWF  FEA
4720:  MOVFF  8FC,FEF
4724:  MOVLB  9
....................     } 
....................      
....................     //mixcol - inv mix 
....................     if (((round > 0) && (dir != 0)) || ((round < 9) && (dir == 0)))  
4726:  MOVF   x00,F
4728:  BZ    4732
472A:  MOVLB  8
472C:  MOVF   xFB,F
472E:  BNZ   4746
4730:  MOVLB  9
4732:  MOVF   x00,W
4734:  SUBLW  08
4736:  BTFSS  FD8.0
4738:  BRA    4A8A
473A:  MOVLB  8
473C:  MOVF   xFB,F
473E:  BTFSC  FD8.2
4740:  BRA    4746
4742:  MOVLB  9
4744:  BRA    4A8A
....................     { 
....................           for (i=0; i <4; i++) 
4746:  MOVLB  9
4748:  CLRF   x01
474A:  MOVF   x01,W
474C:  SUBLW  03
474E:  BTFSS  FD8.0
4750:  BRA    4A8A
....................           { 
....................                 buf4 = (unsigned int8)(i << 2); 
4752:  RLCF   x01,W
4754:  MOVLB  8
4756:  MOVWF  xFF
4758:  RLCF   xFF,F
475A:  MOVLW  FC
475C:  ANDWF  xFF,F
....................                 if (dir != 0) 
475E:  MOVF   xFB,F
4760:  BZ    484E
....................                 { 
....................                       // precompute for decryption 
....................                       buf1 = galois_mul2(galois_mul2((unsigned int8)(state[buf4]^state[buf4+2]))); 
4762:  CLRF   03
4764:  MOVF   xFF,W
4766:  ADDWF  xF7,W
4768:  MOVWF  FE9
476A:  MOVF   xF8,W
476C:  ADDWFC 03,W
476E:  MOVWF  FEA
4770:  MOVFF  FEF,902
4774:  MOVLW  02
4776:  ADDWF  xFF,W
4778:  CLRF   03
477A:  ADDWF  xF7,W
477C:  MOVWF  FE9
477E:  MOVF   xF8,W
4780:  ADDWFC 03,W
4782:  MOVWF  FEA
4784:  MOVF   FEF,W
4786:  MOVLB  9
4788:  XORWF  x02,F
478A:  CLRF   x0E
478C:  MOVFF  902,90D
4790:  MOVLB  0
4792:  RCALL  4098
4794:  MOVFF  02,903
4798:  MOVFF  01,902
479C:  MOVFF  02,90E
47A0:  MOVFF  01,90D
47A4:  RCALL  4098
47A6:  MOVFF  01,8FC
....................                       buf2 = galois_mul2(galois_mul2((unsigned int8)(state[buf4+1]^state[buf4+3]))); 
47AA:  MOVLW  01
47AC:  MOVLB  8
47AE:  ADDWF  xFF,W
47B0:  CLRF   03
47B2:  ADDWF  xF7,W
47B4:  MOVWF  FE9
47B6:  MOVF   xF8,W
47B8:  ADDWFC 03,W
47BA:  MOVWF  FEA
47BC:  MOVFF  FEF,902
47C0:  MOVLW  03
47C2:  ADDWF  xFF,W
47C4:  CLRF   03
47C6:  ADDWF  xF7,W
47C8:  MOVWF  FE9
47CA:  MOVF   xF8,W
47CC:  ADDWFC 03,W
47CE:  MOVWF  FEA
47D0:  MOVF   FEF,W
47D2:  MOVLB  9
47D4:  XORWF  x02,F
47D6:  CLRF   x0E
47D8:  MOVFF  902,90D
47DC:  MOVLB  0
47DE:  RCALL  4098
47E0:  MOVFF  02,903
47E4:  MOVFF  01,902
47E8:  MOVFF  02,90E
47EC:  MOVFF  01,90D
47F0:  RCALL  4098
47F2:  MOVFF  01,8FD
....................                       state[buf4] ^= buf1;  
47F6:  CLRF   03
47F8:  MOVLB  8
47FA:  MOVF   xFF,W
47FC:  ADDWF  xF7,W
47FE:  MOVWF  FE9
4800:  MOVF   xF8,W
4802:  ADDWFC 03,W
4804:  MOVWF  FEA
4806:  MOVF   FEF,W
4808:  XORWF  xFC,W
480A:  MOVWF  FEF
....................                       state[buf4+1] ^= buf2;  
480C:  MOVLW  01
480E:  ADDWF  xFF,W
4810:  CLRF   03
4812:  ADDWF  xF7,W
4814:  MOVWF  FE9
4816:  MOVF   xF8,W
4818:  ADDWFC 03,W
481A:  MOVWF  FEA
481C:  MOVF   FEF,W
481E:  XORWF  xFD,W
4820:  MOVWF  FEF
....................                       state[buf4+2] ^= buf1;  
4822:  MOVLW  02
4824:  ADDWF  xFF,W
4826:  CLRF   03
4828:  ADDWF  xF7,W
482A:  MOVWF  FE9
482C:  MOVF   xF8,W
482E:  ADDWFC 03,W
4830:  MOVWF  FEA
4832:  MOVF   FEF,W
4834:  XORWF  xFC,W
4836:  MOVWF  FEF
....................                       state[buf4+3] ^= buf2;  
4838:  MOVLW  03
483A:  ADDWF  xFF,W
483C:  CLRF   03
483E:  ADDWF  xF7,W
4840:  MOVWF  FE9
4842:  MOVF   xF8,W
4844:  ADDWFC 03,W
4846:  MOVWF  FEA
4848:  MOVF   FEF,W
484A:  XORWF  xFD,W
484C:  MOVWF  FEF
....................                 } 
....................                 // in all cases 
....................                 buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
484E:  CLRF   03
4850:  MOVF   xFF,W
4852:  ADDWF  xF7,W
4854:  MOVWF  FE9
4856:  MOVF   xF8,W
4858:  ADDWFC 03,W
485A:  MOVWF  FEA
485C:  MOVFF  FEF,902
4860:  MOVLW  01
4862:  ADDWF  xFF,W
4864:  CLRF   03
4866:  ADDWF  xF7,W
4868:  MOVWF  FE9
486A:  MOVF   xF8,W
486C:  ADDWFC 03,W
486E:  MOVWF  FEA
4870:  MOVF   FEF,W
4872:  MOVLB  9
4874:  XORWF  x02,F
4876:  MOVLW  02
4878:  MOVLB  8
487A:  ADDWF  xFF,W
487C:  CLRF   03
487E:  ADDWF  xF7,W
4880:  MOVWF  FE9
4882:  MOVF   xF8,W
4884:  ADDWFC 03,W
4886:  MOVWF  FEA
4888:  MOVF   FEF,W
488A:  MOVLB  9
488C:  XORWF  x02,F
488E:  MOVLW  03
4890:  MOVLB  8
4892:  ADDWF  xFF,W
4894:  CLRF   03
4896:  ADDWF  xF7,W
4898:  MOVWF  FE9
489A:  MOVF   xF8,W
489C:  ADDWFC 03,W
489E:  MOVWF  FEA
48A0:  MOVF   FEF,W
48A2:  MOVLB  9
48A4:  XORWF  x02,W
48A6:  MOVLB  8
48A8:  MOVWF  xFC
....................                 buf2 = state[buf4]; 
48AA:  CLRF   03
48AC:  MOVF   xFF,W
48AE:  ADDWF  xF7,W
48B0:  MOVWF  FE9
48B2:  MOVF   xF8,W
48B4:  ADDWFC 03,W
48B6:  MOVWF  FEA
48B8:  MOVFF  FEF,8FD
....................                 buf3 = state[buf4]^state[buf4+1];  
48BC:  CLRF   03
48BE:  MOVF   xFF,W
48C0:  ADDWF  xF7,W
48C2:  MOVWF  FE9
48C4:  MOVF   xF8,W
48C6:  ADDWFC 03,W
48C8:  MOVWF  FEA
48CA:  MOVFF  FEF,902
48CE:  MOVLW  01
48D0:  ADDWF  xFF,W
48D2:  CLRF   03
48D4:  ADDWF  xF7,W
48D6:  MOVWF  FE9
48D8:  MOVF   xF8,W
48DA:  ADDWFC 03,W
48DC:  MOVWF  FEA
48DE:  MOVF   FEF,W
48E0:  MOVLB  9
48E2:  XORWF  x02,W
48E4:  MOVLB  8
48E6:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
48E8:  MOVLB  9
48EA:  CLRF   x0E
48EC:  MOVFF  8FE,90D
48F0:  MOVLB  0
48F2:  CALL   4098
48F6:  MOVFF  01,8FE
....................                 state[buf4] = state[buf4] ^ buf3 ^ buf1; 
48FA:  CLRF   03
48FC:  MOVLB  8
48FE:  MOVF   xFF,W
4900:  ADDWF  xF7,W
4902:  MOVWF  01
4904:  MOVF   xF8,W
4906:  ADDWFC 03,F
4908:  MOVLB  9
490A:  MOVFF  03,903
490E:  CLRF   03
4910:  MOVLB  8
4912:  MOVF   xFF,W
4914:  ADDWF  xF7,W
4916:  MOVWF  FE9
4918:  MOVF   xF8,W
491A:  ADDWFC 03,W
491C:  MOVWF  FEA
491E:  MOVF   FEF,W
4920:  XORWF  xFE,W
4922:  XORWF  xFC,W
4924:  MOVLB  9
4926:  MOVFF  903,FEA
492A:  MOVFF  01,FE9
492E:  MOVWF  FEF
....................                 buf3 = state[buf4+1]^state[buf4+2];  
4930:  MOVLW  01
4932:  MOVLB  8
4934:  ADDWF  xFF,W
4936:  CLRF   03
4938:  ADDWF  xF7,W
493A:  MOVWF  FE9
493C:  MOVF   xF8,W
493E:  ADDWFC 03,W
4940:  MOVWF  FEA
4942:  MOVFF  FEF,902
4946:  MOVLW  02
4948:  ADDWF  xFF,W
494A:  CLRF   03
494C:  ADDWF  xF7,W
494E:  MOVWF  FE9
4950:  MOVF   xF8,W
4952:  ADDWFC 03,W
4954:  MOVWF  FEA
4956:  MOVF   FEF,W
4958:  MOVLB  9
495A:  XORWF  x02,W
495C:  MOVLB  8
495E:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
4960:  MOVLB  9
4962:  CLRF   x0E
4964:  MOVFF  8FE,90D
4968:  MOVLB  0
496A:  CALL   4098
496E:  MOVFF  01,8FE
....................                 state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
4972:  MOVLW  01
4974:  MOVLB  8
4976:  ADDWF  xFF,W
4978:  CLRF   03
497A:  ADDWF  xF7,W
497C:  MOVWF  01
497E:  MOVF   xF8,W
4980:  ADDWFC 03,F
4982:  MOVFF  03,903
4986:  MOVLW  01
4988:  MOVLB  8
498A:  ADDWF  xFF,W
498C:  CLRF   03
498E:  ADDWF  xF7,W
4990:  MOVWF  FE9
4992:  MOVF   xF8,W
4994:  ADDWFC 03,W
4996:  MOVWF  FEA
4998:  MOVF   FEF,W
499A:  XORWF  xFE,W
499C:  XORWF  xFC,W
499E:  MOVLB  9
49A0:  MOVFF  903,FEA
49A4:  MOVFF  01,FE9
49A8:  MOVWF  FEF
....................                 buf3 = state[buf4+2]^state[buf4+3];  
49AA:  MOVLW  02
49AC:  MOVLB  8
49AE:  ADDWF  xFF,W
49B0:  CLRF   03
49B2:  ADDWF  xF7,W
49B4:  MOVWF  FE9
49B6:  MOVF   xF8,W
49B8:  ADDWFC 03,W
49BA:  MOVWF  FEA
49BC:  MOVFF  FEF,902
49C0:  MOVLW  03
49C2:  ADDWF  xFF,W
49C4:  CLRF   03
49C6:  ADDWF  xF7,W
49C8:  MOVWF  FE9
49CA:  MOVF   xF8,W
49CC:  ADDWFC 03,W
49CE:  MOVWF  FEA
49D0:  MOVF   FEF,W
49D2:  MOVLB  9
49D4:  XORWF  x02,W
49D6:  MOVLB  8
49D8:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
49DA:  MOVLB  9
49DC:  CLRF   x0E
49DE:  MOVFF  8FE,90D
49E2:  MOVLB  0
49E4:  CALL   4098
49E8:  MOVFF  01,8FE
....................                 state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
49EC:  MOVLW  02
49EE:  MOVLB  8
49F0:  ADDWF  xFF,W
49F2:  CLRF   03
49F4:  ADDWF  xF7,W
49F6:  MOVWF  01
49F8:  MOVF   xF8,W
49FA:  ADDWFC 03,F
49FC:  MOVFF  03,903
4A00:  MOVLW  02
4A02:  MOVLB  8
4A04:  ADDWF  xFF,W
4A06:  CLRF   03
4A08:  ADDWF  xF7,W
4A0A:  MOVWF  FE9
4A0C:  MOVF   xF8,W
4A0E:  ADDWFC 03,W
4A10:  MOVWF  FEA
4A12:  MOVF   FEF,W
4A14:  XORWF  xFE,W
4A16:  XORWF  xFC,W
4A18:  MOVLB  9
4A1A:  MOVFF  903,FEA
4A1E:  MOVFF  01,FE9
4A22:  MOVWF  FEF
....................                 buf3 = state[buf4+3]^buf2;      
4A24:  MOVLW  03
4A26:  MOVLB  8
4A28:  ADDWF  xFF,W
4A2A:  CLRF   03
4A2C:  ADDWF  xF7,W
4A2E:  MOVWF  FE9
4A30:  MOVF   xF8,W
4A32:  ADDWFC 03,W
4A34:  MOVWF  FEA
4A36:  MOVF   FEF,W
4A38:  XORWF  xFD,W
4A3A:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
4A3C:  MOVLB  9
4A3E:  CLRF   x0E
4A40:  MOVFF  8FE,90D
4A44:  MOVLB  0
4A46:  CALL   4098
4A4A:  MOVFF  01,8FE
....................                 state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1;  
4A4E:  MOVLW  03
4A50:  MOVLB  8
4A52:  ADDWF  xFF,W
4A54:  CLRF   03
4A56:  ADDWF  xF7,W
4A58:  MOVWF  01
4A5A:  MOVF   xF8,W
4A5C:  ADDWFC 03,F
4A5E:  MOVFF  03,903
4A62:  MOVLW  03
4A64:  MOVLB  8
4A66:  ADDWF  xFF,W
4A68:  CLRF   03
4A6A:  ADDWF  xF7,W
4A6C:  MOVWF  FE9
4A6E:  MOVF   xF8,W
4A70:  ADDWFC 03,W
4A72:  MOVWF  FEA
4A74:  MOVF   FEF,W
4A76:  XORWF  xFE,W
4A78:  XORWF  xFC,W
4A7A:  MOVLB  9
4A7C:  MOVFF  903,FEA
4A80:  MOVFF  01,FE9
4A84:  MOVWF  FEF
....................           } 
4A86:  INCF   x01,F
4A88:  BRA    474A
....................     } 
....................      
....................     if (dir != 0)  
4A8A:  MOVLB  8
4A8C:  MOVF   xFB,F
4A8E:  BTFSC  FD8.2
4A90:  BRA    4CEA
....................     { 
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
4A92:  MOVLW  0D
4A94:  ADDWF  xF7,W
4A96:  MOVWF  FE9
4A98:  MOVLW  00
4A9A:  ADDWFC xF8,W
4A9C:  MOVWF  FEA
4A9E:  MOVFF  FEF,8FC
....................       state[13] = state[9]; 
4AA2:  MOVLW  0D
4AA4:  ADDWF  xF7,W
4AA6:  MOVWF  01
4AA8:  MOVLW  00
4AAA:  ADDWFC xF8,W
4AAC:  MOVWF  03
4AAE:  MOVLW  09
4AB0:  MOVLB  8
4AB2:  ADDWF  xF7,W
4AB4:  MOVWF  FE9
4AB6:  MOVLW  00
4AB8:  ADDWFC xF8,W
4ABA:  MOVWF  FEA
4ABC:  MOVFF  FEF,904
4AC0:  MOVLB  9
4AC2:  MOVFF  03,FEA
4AC6:  MOVFF  01,FE9
4ACA:  MOVFF  904,FEF
....................       state[9] = state[5]; 
4ACE:  MOVLW  09
4AD0:  MOVLB  8
4AD2:  ADDWF  xF7,W
4AD4:  MOVWF  01
4AD6:  MOVLW  00
4AD8:  ADDWFC xF8,W
4ADA:  MOVWF  03
4ADC:  MOVLW  05
4ADE:  MOVLB  8
4AE0:  ADDWF  xF7,W
4AE2:  MOVWF  FE9
4AE4:  MOVLW  00
4AE6:  ADDWFC xF8,W
4AE8:  MOVWF  FEA
4AEA:  MOVFF  FEF,904
4AEE:  MOVLB  9
4AF0:  MOVFF  03,FEA
4AF4:  MOVFF  01,FE9
4AF8:  MOVFF  904,FEF
....................       state[5] = state[1]; 
4AFC:  MOVLW  05
4AFE:  MOVLB  8
4B00:  ADDWF  xF7,W
4B02:  MOVWF  01
4B04:  MOVLW  00
4B06:  ADDWFC xF8,W
4B08:  MOVWF  03
4B0A:  MOVLW  01
4B0C:  MOVLB  8
4B0E:  ADDWF  xF7,W
4B10:  MOVWF  FE9
4B12:  MOVLW  00
4B14:  ADDWFC xF8,W
4B16:  MOVWF  FEA
4B18:  MOVFF  FEF,904
4B1C:  MOVLB  9
4B1E:  MOVFF  03,FEA
4B22:  MOVFF  01,FE9
4B26:  MOVFF  904,FEF
....................       state[1] = buf1; 
4B2A:  MOVLW  01
4B2C:  MOVLB  8
4B2E:  ADDWF  xF7,W
4B30:  MOVWF  FE9
4B32:  MOVLW  00
4B34:  ADDWFC xF8,W
4B36:  MOVWF  FEA
4B38:  MOVFF  8FC,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
4B3C:  MOVLW  0A
4B3E:  ADDWF  xF7,W
4B40:  MOVWF  FE9
4B42:  MOVLW  00
4B44:  ADDWFC xF8,W
4B46:  MOVWF  FEA
4B48:  MOVFF  FEF,8FC
....................       buf2 = state[14]; 
4B4C:  MOVLW  0E
4B4E:  ADDWF  xF7,W
4B50:  MOVWF  FE9
4B52:  MOVLW  00
4B54:  ADDWFC xF8,W
4B56:  MOVWF  FEA
4B58:  MOVFF  FEF,8FD
....................       state[10] = state[2]; 
4B5C:  MOVLW  0A
4B5E:  ADDWF  xF7,W
4B60:  MOVWF  01
4B62:  MOVLW  00
4B64:  ADDWFC xF8,W
4B66:  MOVWF  03
4B68:  MOVLW  02
4B6A:  MOVLB  8
4B6C:  ADDWF  xF7,W
4B6E:  MOVWF  FE9
4B70:  MOVLW  00
4B72:  ADDWFC xF8,W
4B74:  MOVWF  FEA
4B76:  MOVFF  FEF,904
4B7A:  MOVLB  9
4B7C:  MOVFF  03,FEA
4B80:  MOVFF  01,FE9
4B84:  MOVFF  904,FEF
....................       state[14] = state[6]; 
4B88:  MOVLW  0E
4B8A:  MOVLB  8
4B8C:  ADDWF  xF7,W
4B8E:  MOVWF  01
4B90:  MOVLW  00
4B92:  ADDWFC xF8,W
4B94:  MOVWF  03
4B96:  MOVLW  06
4B98:  MOVLB  8
4B9A:  ADDWF  xF7,W
4B9C:  MOVWF  FE9
4B9E:  MOVLW  00
4BA0:  ADDWFC xF8,W
4BA2:  MOVWF  FEA
4BA4:  MOVFF  FEF,904
4BA8:  MOVLB  9
4BAA:  MOVFF  03,FEA
4BAE:  MOVFF  01,FE9
4BB2:  MOVFF  904,FEF
....................       state[2] = buf1; 
4BB6:  MOVLW  02
4BB8:  MOVLB  8
4BBA:  ADDWF  xF7,W
4BBC:  MOVWF  FE9
4BBE:  MOVLW  00
4BC0:  ADDWFC xF8,W
4BC2:  MOVWF  FEA
4BC4:  MOVFF  8FC,FEF
....................       state[6] = buf2; 
4BC8:  MOVLW  06
4BCA:  ADDWF  xF7,W
4BCC:  MOVWF  FE9
4BCE:  MOVLW  00
4BD0:  ADDWFC xF8,W
4BD2:  MOVWF  FEA
4BD4:  MOVFF  8FD,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
4BD8:  MOVLW  03
4BDA:  ADDWF  xF7,W
4BDC:  MOVWF  FE9
4BDE:  MOVLW  00
4BE0:  ADDWFC xF8,W
4BE2:  MOVWF  FEA
4BE4:  MOVFF  FEF,8FC
....................       state[3] = state[7]; 
4BE8:  MOVLW  03
4BEA:  ADDWF  xF7,W
4BEC:  MOVWF  01
4BEE:  MOVLW  00
4BF0:  ADDWFC xF8,W
4BF2:  MOVWF  03
4BF4:  MOVLW  07
4BF6:  MOVLB  8
4BF8:  ADDWF  xF7,W
4BFA:  MOVWF  FE9
4BFC:  MOVLW  00
4BFE:  ADDWFC xF8,W
4C00:  MOVWF  FEA
4C02:  MOVFF  FEF,904
4C06:  MOVLB  9
4C08:  MOVFF  03,FEA
4C0C:  MOVFF  01,FE9
4C10:  MOVFF  904,FEF
....................       state[7] = state[11]; 
4C14:  MOVLW  07
4C16:  MOVLB  8
4C18:  ADDWF  xF7,W
4C1A:  MOVWF  01
4C1C:  MOVLW  00
4C1E:  ADDWFC xF8,W
4C20:  MOVWF  03
4C22:  MOVLW  0B
4C24:  MOVLB  8
4C26:  ADDWF  xF7,W
4C28:  MOVWF  FE9
4C2A:  MOVLW  00
4C2C:  ADDWFC xF8,W
4C2E:  MOVWF  FEA
4C30:  MOVFF  FEF,904
4C34:  MOVLB  9
4C36:  MOVFF  03,FEA
4C3A:  MOVFF  01,FE9
4C3E:  MOVFF  904,FEF
....................       state[11] = state[15]; 
4C42:  MOVLW  0B
4C44:  MOVLB  8
4C46:  ADDWF  xF7,W
4C48:  MOVWF  01
4C4A:  MOVLW  00
4C4C:  ADDWFC xF8,W
4C4E:  MOVWF  03
4C50:  MOVLW  0F
4C52:  MOVLB  8
4C54:  ADDWF  xF7,W
4C56:  MOVWF  FE9
4C58:  MOVLW  00
4C5A:  ADDWFC xF8,W
4C5C:  MOVWF  FEA
4C5E:  MOVFF  FEF,904
4C62:  MOVLB  9
4C64:  MOVFF  03,FEA
4C68:  MOVFF  01,FE9
4C6C:  MOVFF  904,FEF
....................       state[15] = buf1;          
4C70:  MOVLW  0F
4C72:  MOVLB  8
4C74:  ADDWF  xF7,W
4C76:  MOVWF  FE9
4C78:  MOVLW  00
4C7A:  ADDWFC xF8,W
4C7C:  MOVWF  FEA
4C7E:  MOVFF  8FC,FEF
....................             
....................       for (i = 0; i <16; i++){ 
4C82:  MOVLB  9
4C84:  CLRF   x01
4C86:  MOVF   x01,W
4C88:  SUBLW  0F
4C8A:  BNC   4CE6
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
4C8C:  CLRF   03
4C8E:  MOVF   x01,W
4C90:  MOVLB  8
4C92:  ADDWF  xF7,W
4C94:  MOVWF  01
4C96:  MOVF   xF8,W
4C98:  ADDWFC 03,F
4C9A:  MOVFF  01,902
4C9E:  MOVLB  9
4CA0:  MOVFF  03,903
4CA4:  CLRF   03
4CA6:  MOVF   x01,W
4CA8:  MOVLB  8
4CAA:  ADDWF  xF7,W
4CAC:  MOVWF  FE9
4CAE:  MOVF   xF8,W
4CB0:  ADDWFC 03,W
4CB2:  MOVWF  FEA
4CB4:  CLRF   03
4CB6:  MOVF   FEF,W
4CB8:  MOVLB  0
4CBA:  CALL   01E0
4CBE:  MOVLB  9
4CC0:  MOVWF  x04
4CC2:  CLRF   03
4CC4:  MOVF   x01,W
4CC6:  MOVLB  8
4CC8:  ADDWF  xF9,W
4CCA:  MOVWF  FE9
4CCC:  MOVF   xFA,W
4CCE:  ADDWFC 03,W
4CD0:  MOVWF  FEA
4CD2:  MOVF   FEF,W
4CD4:  MOVLB  9
4CD6:  XORWF  x04,W
4CD8:  MOVFF  903,FEA
4CDC:  MOVFF  902,FE9
4CE0:  MOVWF  FEF
....................       }  
4CE2:  INCF   x01,F
4CE4:  BRA    4C86
....................     }  
....................     else  
4CE6:  BRA    4E8C
4CE8:  MOVLB  8
....................     { 
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
4CEA:  MOVFF  8F9,01
4CEE:  MOVFF  8FA,03
4CF2:  MOVFF  8F9,902
4CF6:  MOVFF  8FA,903
4CFA:  MOVLW  0D
4CFC:  MOVLB  8
4CFE:  ADDWF  xF9,W
4D00:  MOVWF  FE9
4D02:  MOVLW  00
4D04:  ADDWFC xFA,W
4D06:  MOVWF  FEA
4D08:  CLRF   03
4D0A:  MOVF   FEF,W
4D0C:  MOVLB  0
4D0E:  CALL   00D0
4D12:  MOVLB  9
4D14:  MOVWF  x04
4D16:  MOVLB  8
4D18:  MOVFF  8F9,FE9
4D1C:  MOVFF  8FA,FEA
4D20:  MOVF   FEF,W
4D22:  MOVLB  9
4D24:  XORWF  x04,F
4D26:  CLRF   03
4D28:  MOVF   x00,W
4D2A:  MOVLB  0
4D2C:  CALL   02F0
4D30:  MOVWF  01
4D32:  MOVLB  9
4D34:  MOVF   x04,W
4D36:  XORWF  01,W
4D38:  MOVFF  903,FEA
4D3C:  MOVFF  902,FE9
4D40:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
4D42:  MOVLW  01
4D44:  MOVLB  8
4D46:  ADDWF  xF9,W
4D48:  MOVWF  01
4D4A:  MOVLW  00
4D4C:  ADDWFC xFA,W
4D4E:  MOVWF  03
4D50:  MOVFF  01,902
4D54:  MOVLB  9
4D56:  MOVWF  x03
4D58:  MOVLW  0E
4D5A:  MOVLB  8
4D5C:  ADDWF  xF9,W
4D5E:  MOVWF  FE9
4D60:  MOVLW  00
4D62:  ADDWFC xFA,W
4D64:  MOVWF  FEA
4D66:  CLRF   03
4D68:  MOVF   FEF,W
4D6A:  MOVLB  0
4D6C:  CALL   00D0
4D70:  MOVLB  9
4D72:  MOVWF  x04
4D74:  MOVLW  01
4D76:  MOVLB  8
4D78:  ADDWF  xF9,W
4D7A:  MOVWF  FE9
4D7C:  MOVLW  00
4D7E:  ADDWFC xFA,W
4D80:  MOVWF  FEA
4D82:  MOVF   FEF,W
4D84:  MOVLB  9
4D86:  XORWF  x04,W
4D88:  MOVFF  903,FEA
4D8C:  MOVFF  902,FE9
4D90:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
4D92:  MOVLW  02
4D94:  MOVLB  8
4D96:  ADDWF  xF9,W
4D98:  MOVWF  01
4D9A:  MOVLW  00
4D9C:  ADDWFC xFA,W
4D9E:  MOVWF  03
4DA0:  MOVFF  01,902
4DA4:  MOVLB  9
4DA6:  MOVWF  x03
4DA8:  MOVLW  0F
4DAA:  MOVLB  8
4DAC:  ADDWF  xF9,W
4DAE:  MOVWF  FE9
4DB0:  MOVLW  00
4DB2:  ADDWFC xFA,W
4DB4:  MOVWF  FEA
4DB6:  CLRF   03
4DB8:  MOVF   FEF,W
4DBA:  MOVLB  0
4DBC:  CALL   00D0
4DC0:  MOVLB  9
4DC2:  MOVWF  x04
4DC4:  MOVLW  02
4DC6:  MOVLB  8
4DC8:  ADDWF  xF9,W
4DCA:  MOVWF  FE9
4DCC:  MOVLW  00
4DCE:  ADDWFC xFA,W
4DD0:  MOVWF  FEA
4DD2:  MOVF   FEF,W
4DD4:  MOVLB  9
4DD6:  XORWF  x04,W
4DD8:  MOVFF  903,FEA
4DDC:  MOVFF  902,FE9
4DE0:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
4DE2:  MOVLW  03
4DE4:  MOVLB  8
4DE6:  ADDWF  xF9,W
4DE8:  MOVWF  01
4DEA:  MOVLW  00
4DEC:  ADDWFC xFA,W
4DEE:  MOVWF  03
4DF0:  MOVFF  01,902
4DF4:  MOVLB  9
4DF6:  MOVWF  x03
4DF8:  MOVLW  0C
4DFA:  MOVLB  8
4DFC:  ADDWF  xF9,W
4DFE:  MOVWF  FE9
4E00:  MOVLW  00
4E02:  ADDWFC xFA,W
4E04:  MOVWF  FEA
4E06:  CLRF   03
4E08:  MOVF   FEF,W
4E0A:  MOVLB  0
4E0C:  CALL   00D0
4E10:  MOVLB  9
4E12:  MOVWF  x04
4E14:  MOVLW  03
4E16:  MOVLB  8
4E18:  ADDWF  xF9,W
4E1A:  MOVWF  FE9
4E1C:  MOVLW  00
4E1E:  ADDWFC xFA,W
4E20:  MOVWF  FEA
4E22:  MOVF   FEF,W
4E24:  MOVLB  9
4E26:  XORWF  x04,W
4E28:  MOVFF  903,FEA
4E2C:  MOVFF  902,FE9
4E30:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4E32:  MOVLW  04
4E34:  MOVWF  x01
4E36:  MOVF   x01,W
4E38:  SUBLW  0F
4E3A:  BNC   4E8C
....................         key[i] = key[i] ^ key[i-4]; 
4E3C:  CLRF   03
4E3E:  MOVF   x01,W
4E40:  MOVLB  8
4E42:  ADDWF  xF9,W
4E44:  MOVWF  01
4E46:  MOVF   xFA,W
4E48:  ADDWFC 03,F
4E4A:  MOVLB  9
4E4C:  MOVFF  03,903
4E50:  CLRF   03
4E52:  MOVF   x01,W
4E54:  MOVLB  8
4E56:  ADDWF  xF9,W
4E58:  MOVWF  FE9
4E5A:  MOVF   xFA,W
4E5C:  ADDWFC 03,W
4E5E:  MOVWF  FEA
4E60:  MOVFF  FEF,904
4E64:  MOVLW  04
4E66:  MOVLB  9
4E68:  SUBWF  x01,W
4E6A:  CLRF   03
4E6C:  MOVLB  8
4E6E:  ADDWF  xF9,W
4E70:  MOVWF  FE9
4E72:  MOVF   xFA,W
4E74:  ADDWFC 03,W
4E76:  MOVWF  FEA
4E78:  MOVF   FEF,W
4E7A:  MOVLB  9
4E7C:  XORWF  x04,W
4E7E:  MOVFF  903,FEA
4E82:  MOVFF  01,FE9
4E86:  MOVWF  FEF
....................       } 
4E88:  INCF   x01,F
4E8A:  BRA    4E36
....................     } 
....................   } 
4E8C:  INCF   x00,F
4E8E:  GOTO   430E
....................   if (dir == 0)  
4E92:  MOVLB  8
4E94:  MOVF   xFB,F
4E96:  BNZ   4EF2
....................   { 
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
4E98:  MOVLB  9
4E9A:  CLRF   x01
4E9C:  MOVF   x01,W
4E9E:  SUBLW  0F
4EA0:  BNC   4EF0
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
4EA2:  CLRF   03
4EA4:  MOVF   x01,W
4EA6:  MOVLB  8
4EA8:  ADDWF  xF7,W
4EAA:  MOVWF  01
4EAC:  MOVF   xF8,W
4EAE:  ADDWFC 03,F
4EB0:  MOVLB  9
4EB2:  MOVFF  03,903
4EB6:  CLRF   03
4EB8:  MOVF   x01,W
4EBA:  MOVLB  8
4EBC:  ADDWF  xF7,W
4EBE:  MOVWF  FE9
4EC0:  MOVF   xF8,W
4EC2:  ADDWFC 03,W
4EC4:  MOVWF  FEA
4EC6:  MOVFF  FEF,904
4ECA:  CLRF   03
4ECC:  MOVLB  9
4ECE:  MOVF   x01,W
4ED0:  MOVLB  8
4ED2:  ADDWF  xF9,W
4ED4:  MOVWF  FE9
4ED6:  MOVF   xFA,W
4ED8:  ADDWFC 03,W
4EDA:  MOVWF  FEA
4EDC:  MOVF   FEF,W
4EDE:  MOVLB  9
4EE0:  XORWF  x04,W
4EE2:  MOVFF  903,FEA
4EE6:  MOVFF  01,FE9
4EEA:  MOVWF  FEF
....................     } // enf for 
4EEC:  INCF   x01,F
4EEE:  BRA    4E9C
4EF0:  MOVLB  8
....................   } // end if (!dir) 
.................... } // end function 
4EF2:  MOVLB  0
4EF4:  RETURN 0
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                  
....................  
.................... #define     wideofkeystore      16 
.................... #define     key_numbyte         wideofkeystore-4 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 kp_st=0; 
.................... int8 type_KB=0; 
....................  
.................... int8 key_data[wideofkeystore]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1F7C:  MOVLB  1
1F7E:  INCF   x5B,F
1F80:  MOVF   x5B,W
1F82:  SUBLW  01
1F84:  BTFSC  FD8.0
1F86:  BRA    212A
....................        switch (col) { 
1F88:  MOVF   x5E,W
1F8A:  ADDLW  FB
1F8C:  BC    2010
1F8E:  ADDLW  05
1F90:  MOVLB  0
1F92:  GOTO   2134
....................          case 0   :  
....................                     output_low(COL0); 
1F96:  BCF    F92.5
1F98:  BCF    F89.5
....................                     output_high(COL1); 
1F9A:  BCF    F92.3
1F9C:  BSF    F89.3
....................                     output_high(COL2); 
1F9E:  BCF    F92.2
1FA0:  BSF    F89.2
....................                     output_high(COL3); 
1FA2:  BCF    F92.1
1FA4:  BSF    F89.1
....................                     output_high(COL4); 
1FA6:  BCF    F92.0
1FA8:  BSF    F89.0
....................                     break; 
1FAA:  MOVLB  1
1FAC:  BRA    2010
....................          case 1   :  
....................                     output_low(COL1); 
1FAE:  BCF    F92.3
1FB0:  BCF    F89.3
....................                     output_high(COL0); 
1FB2:  BCF    F92.5
1FB4:  BSF    F89.5
....................                     output_high(COL2); 
1FB6:  BCF    F92.2
1FB8:  BSF    F89.2
....................                     output_high(COL3); 
1FBA:  BCF    F92.1
1FBC:  BSF    F89.1
....................                     output_high(COL4); 
1FBE:  BCF    F92.0
1FC0:  BSF    F89.0
....................                     break; 
1FC2:  MOVLB  1
1FC4:  BRA    2010
....................          case 2   :  
....................                     output_low(COL2); 
1FC6:  BCF    F92.2
1FC8:  BCF    F89.2
....................                     output_high(COL1); 
1FCA:  BCF    F92.3
1FCC:  BSF    F89.3
....................                     output_high(COL0); 
1FCE:  BCF    F92.5
1FD0:  BSF    F89.5
....................                     output_high(COL3); 
1FD2:  BCF    F92.1
1FD4:  BSF    F89.1
....................                     output_high(COL4); 
1FD6:  BCF    F92.0
1FD8:  BSF    F89.0
....................                     break; 
1FDA:  MOVLB  1
1FDC:  BRA    2010
....................          case 3   :  
....................                     output_low(COL3); 
1FDE:  BCF    F92.1
1FE0:  BCF    F89.1
....................                     output_high(COL1); 
1FE2:  BCF    F92.3
1FE4:  BSF    F89.3
....................                     output_high(COL2); 
1FE6:  BCF    F92.2
1FE8:  BSF    F89.2
....................                     output_high(COL0); 
1FEA:  BCF    F92.5
1FEC:  BSF    F89.5
....................                     output_high(COL4); 
1FEE:  BCF    F92.0
1FF0:  BSF    F89.0
....................                     break; 
1FF2:  MOVLB  1
1FF4:  BRA    2010
....................          case 4   :  
....................                     output_low(COL4); 
1FF6:  BCF    F92.0
1FF8:  BCF    F89.0
....................                     output_high(COL1); 
1FFA:  BCF    F92.3
1FFC:  BSF    F89.3
....................                     output_high(COL2); 
1FFE:  BCF    F92.2
2000:  BSF    F89.2
....................                     output_high(COL3); 
2002:  BCF    F92.1
2004:  BSF    F89.1
....................                     output_high(COL0); 
2006:  BCF    F92.5
2008:  BSF    F89.5
....................                     break; 
200A:  MOVLB  1
200C:  BRA    2010
200E:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2010:  BTFSS  x5C.0
2012:  BRA    2090
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2014:  BSF    F93.4
2016:  MOVLW  00
2018:  BTFSC  F81.4
201A:  MOVLW  01
201C:  MOVLB  8
201E:  MOVWF  x52
2020:  BSF    F93.5
2022:  MOVLW  00
2024:  BTFSC  F81.5
2026:  MOVLW  01
2028:  ANDWF  x52,F
202A:  BSF    F93.6
202C:  MOVLW  00
202E:  BTFSC  F81.6
2030:  MOVLW  01
2032:  ANDWF  x52,F
2034:  BSF    F93.7
2036:  MOVLW  00
2038:  BTFSC  F81.7
203A:  MOVLW  01
203C:  ANDWF  x52,W
203E:  BZ    208C
....................          { 
....................             kchar=last_key; 
2040:  MOVFF  15D,850
....................             if(keydebug_en==0) 
2044:  MOVLB  1
2046:  MOVF   x44,F
2048:  BNZ   207A
....................             { 
....................                 //count_timer0=0; 
....................                 charac_timeout=0; 
204A:  CLRF   x00
204C:  MOVLB  0
204E:  CLRF   xFF
....................                 if(key_count_ms<wideofkeystore) 
2050:  MOVLB  1
2052:  MOVF   x47,W
2054:  SUBLW  0F
2056:  BNC   2078
....................                 { 
....................                     key_data[key_count_ms++]=kchar; 
2058:  MOVF   x47,W
205A:  INCF   x47,F
205C:  CLRF   03
205E:  ADDLW  4A
2060:  MOVWF  FE9
2062:  MOVLW  01
2064:  ADDWFC 03,W
2066:  MOVWF  FEA
2068:  MOVFF  850,FEF
....................                     fputc(kchar,COM2); 
206C:  MOVFF  850,90C
2070:  MOVLB  0
2072:  CALL   1604
2076:  MOVLB  1
....................                 } 
....................             } 
....................                else fputc(kchar,COM2); 
2078:  BRA    2086
207A:  MOVFF  850,90C
207E:  MOVLB  0
2080:  CALL   1604
2084:  MOVLB  1
....................            kbd_down=FALSE; 
2086:  BCF    x5C.0
....................            last_key=0; 
2088:  CLRF   x5D
208A:  MOVLB  8
....................          } 
....................        } else 
208C:  BRA    2126
208E:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
2090:  BSF    F93.4
2092:  MOVLW  00
2094:  BTFSC  F81.4
2096:  MOVLW  01
2098:  MOVLB  8
209A:  MOVWF  x52
209C:  BSF    F93.5
209E:  MOVLW  00
20A0:  BTFSC  F81.5
20A2:  MOVLW  01
20A4:  ANDWF  x52,F
20A6:  BSF    F93.6
20A8:  MOVLW  00
20AA:  BTFSC  F81.6
20AC:  MOVLW  01
20AE:  ANDWF  x52,F
20B0:  BSF    F93.7
20B2:  MOVLW  00
20B4:  BTFSC  F81.7
20B6:  MOVLW  01
20B8:  ANDWF  x52,W
20BA:  BNZ   211A
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
20BC:  BSF    F93.4
20BE:  BTFSC  F81.4
20C0:  BRA    20C6
....................                   row=0; 
20C2:  CLRF   x51
....................                 else if(input(ROW1)==0) 
20C4:  BRA    20E8
20C6:  BSF    F93.5
20C8:  BTFSC  F81.5
20CA:  BRA    20D2
....................                   row=1; 
20CC:  MOVLW  01
20CE:  MOVWF  x51
....................                 else if(input(ROW2)==0) 
20D0:  BRA    20E8
20D2:  BSF    F93.6
20D4:  BTFSC  F81.6
20D6:  BRA    20DE
....................                   row=2; 
20D8:  MOVLW  02
20DA:  MOVWF  x51
....................                 else if(input(ROW3)==0) 
20DC:  BRA    20E8
20DE:  BSF    F93.7
20E0:  BTFSC  F81.7
20E2:  BRA    20E8
....................                   row=3; 
20E4:  MOVLW  03
20E6:  MOVWF  x51
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
20E8:  MOVF   x51,W
20EA:  MULLW  05
20EC:  MOVF   FF3,W
20EE:  CLRF   x53
20F0:  MOVWF  x52
20F2:  CLRF   03
20F4:  MOVLB  1
20F6:  MOVF   x5E,W
20F8:  MOVLB  8
20FA:  ADDWF  x52,W
20FC:  MOVWF  01
20FE:  MOVF   x53,W
2100:  ADDWFC 03,F
2102:  MOVF   01,W
2104:  MOVLB  0
2106:  CALL   030A
210A:  MOVFF  FE8,15D
....................                 kbd_down = TRUE; 
210E:  MOVLB  1
2110:  BSF    x5C.0
....................                 set_tris_a(0xff); 
2112:  MOVLW  FF
2114:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2116:  BRA    2126
2118:  MOVLB  8
....................                { 
....................                   ++col; 
211A:  MOVLB  1
211C:  INCF   x5E,F
....................                   if(col==5) col=0; 
211E:  MOVF   x5E,W
2120:  SUBLW  05
2122:  BTFSC  FD8.2
2124:  CLRF   x5E
....................                } 
....................          } 
....................       kbd_call_count=0; 
2126:  MOVLB  1
2128:  CLRF   x5B
....................    } 
....................   return(kchar); 
212A:  MOVLB  8
212C:  MOVFF  850,01
.................... } 
2130:  MOVLB  0
2132:  RETURN 0
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2158:  MOVLW  E0
215A:  MOVLB  F
215C:  MOVWF  x48
215E:  BCF    FC2.6
2160:  BCF    FC2.7
2162:  MOVF   x49,W
2164:  ANDLW  E0
2166:  IORLW  17
2168:  MOVWF  x49
....................    switch(col) 
....................    { 
216A:  MOVLB  8
216C:  MOVF   x6D,W
216E:  ADDLW  FA
2170:  BC    223C
2172:  ADDLW  06
2174:  MOVLB  0
2176:  GOTO   2240
....................       case 0: 
....................         set_adc_channel(4); 
217A:  MOVLW  10
217C:  MOVWF  01
217E:  MOVF   FC2,W
2180:  ANDLW  C3
2182:  IORWF  01,W
2184:  MOVWF  FC2
....................         adc=read_adc(); 
2186:  BSF    FC2.1
2188:  BTFSC  FC2.1
218A:  BRA    2188
218C:  MOVFF  FC4,86E
....................         return adc; 
2190:  MOVLB  8
2192:  MOVFF  86E,01
2196:  BRA    223C
....................       break; 
2198:  BRA    223C
....................       case 1: 
....................         set_adc_channel(3); 
219A:  MOVLW  0C
219C:  MOVWF  01
219E:  MOVF   FC2,W
21A0:  ANDLW  C3
21A2:  IORWF  01,W
21A4:  MOVWF  FC2
....................         adc=read_adc(); 
21A6:  BSF    FC2.1
21A8:  BTFSC  FC2.1
21AA:  BRA    21A8
21AC:  MOVFF  FC4,86E
....................         return adc; 
21B0:  MOVLB  8
21B2:  MOVFF  86E,01
21B6:  BRA    223C
....................       break; 
21B8:  BRA    223C
....................       case 2: 
....................         set_adc_channel(2); 
21BA:  MOVLW  08
21BC:  MOVWF  01
21BE:  MOVF   FC2,W
21C0:  ANDLW  C3
21C2:  IORWF  01,W
21C4:  MOVWF  FC2
....................         adc=read_adc(); 
21C6:  BSF    FC2.1
21C8:  BTFSC  FC2.1
21CA:  BRA    21C8
21CC:  MOVFF  FC4,86E
....................         return adc; 
21D0:  MOVLB  8
21D2:  MOVFF  86E,01
21D6:  BRA    223C
....................       break; 
21D8:  BRA    223C
....................       case 3: 
....................         set_adc_channel(1); 
21DA:  MOVLW  04
21DC:  MOVWF  01
21DE:  MOVF   FC2,W
21E0:  ANDLW  C3
21E2:  IORWF  01,W
21E4:  MOVWF  FC2
....................         adc=read_adc(); 
21E6:  BSF    FC2.1
21E8:  BTFSC  FC2.1
21EA:  BRA    21E8
21EC:  MOVFF  FC4,86E
....................         return adc; 
21F0:  MOVLB  8
21F2:  MOVFF  86E,01
21F6:  BRA    223C
....................       break; 
21F8:  BRA    223C
....................       case 4: 
....................         set_adc_channel(0); 
21FA:  MOVLW  00
21FC:  MOVWF  01
21FE:  MOVF   FC2,W
2200:  ANDLW  C3
2202:  IORWF  01,W
2204:  MOVWF  FC2
....................         adc=read_adc(); 
2206:  BSF    FC2.1
2208:  BTFSC  FC2.1
220A:  BRA    2208
220C:  MOVFF  FC4,86E
....................         return adc; 
2210:  MOVLB  8
2212:  MOVFF  86E,01
2216:  BRA    223C
....................       break;      
2218:  BRA    223C
....................       case 5: 
....................         set_adc_channel(11); 
221A:  MOVLW  2C
221C:  MOVWF  01
221E:  MOVF   FC2,W
2220:  ANDLW  C3
2222:  IORWF  01,W
2224:  MOVWF  FC2
....................         adc=read_adc(); 
2226:  BSF    FC2.1
2228:  BTFSC  FC2.1
222A:  BRA    2228
222C:  MOVFF  FC4,86E
....................         return adc; 
2230:  MOVLB  8
2232:  MOVFF  86E,01
2236:  BRA    223C
....................       break;      
2238:  BRA    223C
223A:  MOVLB  8
....................    } 
.................... } 
223C:  MOVLB  0
223E:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
23C0:  MOVLB  8
23C2:  CLRF   x58
23C4:  CLRF   x57
23C6:  CLRF   x56
23C8:  CLRF   x55
23CA:  CLRF   x5C
23CC:  CLRF   x5B
23CE:  CLRF   x5A
23D0:  CLRF   x59
23D2:  CLRF   x60
23D4:  CLRF   x5F
23D6:  CLRF   x5E
23D8:  CLRF   x5D
23DA:  CLRF   x64
23DC:  CLRF   x63
23DE:  CLRF   x62
23E0:  CLRF   x61
23E2:  CLRF   x68
23E4:  CLRF   x67
23E6:  CLRF   x66
23E8:  CLRF   x65
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
23EA:  CLRF   x54
23EC:  CLRF   x53
23EE:  MOVF   x54,W
23F0:  SUBLW  01
23F2:  BNC   2470
23F4:  BNZ   23FC
23F6:  MOVF   x53,W
23F8:  SUBLW  F3
23FA:  BNC   2470
....................    { 
....................       col_0=read_col(0)+col_0; 
23FC:  CLRF   x6D
23FE:  MOVLB  0
2400:  RCALL  2158
2402:  MOVF   01,W
2404:  MOVLB  8
2406:  ADDWF  x55,F
2408:  MOVLW  00
240A:  ADDWFC x56,F
240C:  ADDWFC x57,F
240E:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2410:  MOVLW  01
2412:  MOVWF  x6D
2414:  MOVLB  0
2416:  RCALL  2158
2418:  MOVF   01,W
241A:  MOVLB  8
241C:  ADDWF  x59,F
241E:  MOVLW  00
2420:  ADDWFC x5A,F
2422:  ADDWFC x5B,F
2424:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
2426:  MOVLW  02
2428:  MOVWF  x6D
242A:  MOVLB  0
242C:  RCALL  2158
242E:  MOVF   01,W
2430:  MOVLB  8
2432:  ADDWF  x5D,F
2434:  MOVLW  00
2436:  ADDWFC x5E,F
2438:  ADDWFC x5F,F
243A:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
243C:  MOVLW  03
243E:  MOVWF  x6D
2440:  MOVLB  0
2442:  RCALL  2158
2444:  MOVF   01,W
2446:  MOVLB  8
2448:  ADDWF  x61,F
244A:  MOVLW  00
244C:  ADDWFC x62,F
244E:  ADDWFC x63,F
2450:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
2452:  MOVLW  04
2454:  MOVWF  x6D
2456:  MOVLB  0
2458:  RCALL  2158
245A:  MOVF   01,W
245C:  MOVLB  8
245E:  ADDWF  x65,F
2460:  MOVLW  00
2462:  ADDWFC x66,F
2464:  ADDWFC x67,F
2466:  ADDWFC x68,F
....................    } 
2468:  INCF   x53,F
246A:  BTFSC  FD8.2
246C:  INCF   x54,F
246E:  BRA    23EE
....................    col_0=col_0/500; 
2470:  BCF    FD8.1
2472:  MOVFF  858,90F
2476:  MOVFF  857,90E
247A:  MOVFF  856,90D
247E:  MOVFF  855,90C
2482:  MOVLB  9
2484:  CLRF   x13
2486:  CLRF   x12
2488:  MOVLW  01
248A:  MOVWF  x11
248C:  MOVLW  F4
248E:  MOVWF  x10
2490:  MOVLB  0
2492:  RCALL  2266
2494:  MOVFF  03,858
2498:  MOVFF  02,857
249C:  MOVFF  01,856
24A0:  MOVFF  00,855
....................    col_1=col_1/500; 
24A4:  BCF    FD8.1
24A6:  MOVFF  85C,90F
24AA:  MOVFF  85B,90E
24AE:  MOVFF  85A,90D
24B2:  MOVFF  859,90C
24B6:  MOVLB  9
24B8:  CLRF   x13
24BA:  CLRF   x12
24BC:  MOVLW  01
24BE:  MOVWF  x11
24C0:  MOVLW  F4
24C2:  MOVWF  x10
24C4:  MOVLB  0
24C6:  RCALL  2266
24C8:  MOVFF  03,85C
24CC:  MOVFF  02,85B
24D0:  MOVFF  01,85A
24D4:  MOVFF  00,859
....................    col_2=col_2/500; 
24D8:  BCF    FD8.1
24DA:  MOVFF  860,90F
24DE:  MOVFF  85F,90E
24E2:  MOVFF  85E,90D
24E6:  MOVFF  85D,90C
24EA:  MOVLB  9
24EC:  CLRF   x13
24EE:  CLRF   x12
24F0:  MOVLW  01
24F2:  MOVWF  x11
24F4:  MOVLW  F4
24F6:  MOVWF  x10
24F8:  MOVLB  0
24FA:  RCALL  2266
24FC:  MOVFF  03,860
2500:  MOVFF  02,85F
2504:  MOVFF  01,85E
2508:  MOVFF  00,85D
....................    col_3=col_3/500; 
250C:  BCF    FD8.1
250E:  MOVFF  864,90F
2512:  MOVFF  863,90E
2516:  MOVFF  862,90D
251A:  MOVFF  861,90C
251E:  MOVLB  9
2520:  CLRF   x13
2522:  CLRF   x12
2524:  MOVLW  01
2526:  MOVWF  x11
2528:  MOVLW  F4
252A:  MOVWF  x10
252C:  MOVLB  0
252E:  RCALL  2266
2530:  MOVFF  03,864
2534:  MOVFF  02,863
2538:  MOVFF  01,862
253C:  MOVFF  00,861
....................    col_4=col_4/500; 
2540:  BCF    FD8.1
2542:  MOVFF  868,90F
2546:  MOVFF  867,90E
254A:  MOVFF  866,90D
254E:  MOVFF  865,90C
2552:  MOVLB  9
2554:  CLRF   x13
2556:  CLRF   x12
2558:  MOVLW  01
255A:  MOVWF  x11
255C:  MOVLW  F4
255E:  MOVWF  x10
2560:  MOVLB  0
2562:  RCALL  2266
2564:  MOVFF  03,868
2568:  MOVFF  02,867
256C:  MOVFF  01,866
2570:  MOVFF  00,865
....................    if(keydebug_en) 
2574:  MOVLB  1
2576:  MOVF   x44,F
2578:  BTFSC  FD8.2
257A:  BRA    26F6
....................    { 
....................       fprintf(COM2,"\r\n");      
257C:  MOVLW  0D
257E:  MOVLB  9
2580:  MOVWF  x0C
2582:  MOVLB  0
2584:  CALL   1604
2588:  MOVLW  0A
258A:  MOVLB  9
258C:  MOVWF  x0C
258E:  MOVLB  0
2590:  CALL   1604
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2594:  MOVLW  BC
2596:  MOVWF  FF6
2598:  MOVLW  04
259A:  MOVWF  FF7
259C:  MOVLW  07
259E:  MOVLB  8
25A0:  MOVWF  xF7
25A2:  MOVLB  0
25A4:  CALL   164A
25A8:  MOVLW  41
25AA:  MOVWF  FE9
25AC:  MOVFF  858,8FA
25B0:  MOVFF  857,8F9
25B4:  MOVFF  856,8F8
25B8:  MOVFF  855,8F7
25BC:  RCALL  22FA
25BE:  MOVLW  0D
25C0:  MOVLB  9
25C2:  MOVWF  x0C
25C4:  MOVLB  0
25C6:  CALL   1604
25CA:  MOVLW  0A
25CC:  MOVLB  9
25CE:  MOVWF  x0C
25D0:  MOVLB  0
25D2:  CALL   1604
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
25D6:  MOVLW  CA
25D8:  MOVWF  FF6
25DA:  MOVLW  04
25DC:  MOVWF  FF7
25DE:  MOVLW  07
25E0:  MOVLB  8
25E2:  MOVWF  xF7
25E4:  MOVLB  0
25E6:  CALL   164A
25EA:  MOVLW  41
25EC:  MOVWF  FE9
25EE:  MOVFF  85C,8FA
25F2:  MOVFF  85B,8F9
25F6:  MOVFF  85A,8F8
25FA:  MOVFF  859,8F7
25FE:  RCALL  22FA
2600:  MOVLW  0D
2602:  MOVLB  9
2604:  MOVWF  x0C
2606:  MOVLB  0
2608:  CALL   1604
260C:  MOVLW  0A
260E:  MOVLB  9
2610:  MOVWF  x0C
2612:  MOVLB  0
2614:  CALL   1604
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2618:  MOVLW  D8
261A:  MOVWF  FF6
261C:  MOVLW  04
261E:  MOVWF  FF7
2620:  MOVLW  07
2622:  MOVLB  8
2624:  MOVWF  xF7
2626:  MOVLB  0
2628:  CALL   164A
262C:  MOVLW  41
262E:  MOVWF  FE9
2630:  MOVFF  860,8FA
2634:  MOVFF  85F,8F9
2638:  MOVFF  85E,8F8
263C:  MOVFF  85D,8F7
2640:  RCALL  22FA
2642:  MOVLW  0D
2644:  MOVLB  9
2646:  MOVWF  x0C
2648:  MOVLB  0
264A:  CALL   1604
264E:  MOVLW  0A
2650:  MOVLB  9
2652:  MOVWF  x0C
2654:  MOVLB  0
2656:  CALL   1604
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
265A:  MOVLW  E6
265C:  MOVWF  FF6
265E:  MOVLW  04
2660:  MOVWF  FF7
2662:  MOVLW  07
2664:  MOVLB  8
2666:  MOVWF  xF7
2668:  MOVLB  0
266A:  CALL   164A
266E:  MOVLW  41
2670:  MOVWF  FE9
2672:  MOVFF  864,8FA
2676:  MOVFF  863,8F9
267A:  MOVFF  862,8F8
267E:  MOVFF  861,8F7
2682:  RCALL  22FA
2684:  MOVLW  0D
2686:  MOVLB  9
2688:  MOVWF  x0C
268A:  MOVLB  0
268C:  CALL   1604
2690:  MOVLW  0A
2692:  MOVLB  9
2694:  MOVWF  x0C
2696:  MOVLB  0
2698:  CALL   1604
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
269C:  MOVLW  F4
269E:  MOVWF  FF6
26A0:  MOVLW  04
26A2:  MOVWF  FF7
26A4:  MOVLW  07
26A6:  MOVLB  8
26A8:  MOVWF  xF7
26AA:  MOVLB  0
26AC:  CALL   164A
26B0:  MOVLW  41
26B2:  MOVWF  FE9
26B4:  MOVFF  868,8FA
26B8:  MOVFF  867,8F9
26BC:  MOVFF  866,8F8
26C0:  MOVFF  865,8F7
26C4:  RCALL  22FA
26C6:  MOVLW  0D
26C8:  MOVLB  9
26CA:  MOVWF  x0C
26CC:  MOVLB  0
26CE:  CALL   1604
26D2:  MOVLW  0A
26D4:  MOVLB  9
26D6:  MOVWF  x0C
26D8:  MOVLB  0
26DA:  CALL   1604
....................       fprintf(COM2,"\r\n"); 
26DE:  MOVLW  0D
26E0:  MOVLB  9
26E2:  MOVWF  x0C
26E4:  MOVLB  0
26E6:  CALL   1604
26EA:  MOVLW  0A
26EC:  MOVLB  9
26EE:  MOVWF  x0C
26F0:  MOVLB  0
26F2:  CALL   1604
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
26F6:  MOVLB  8
26F8:  MOVF   x58,F
26FA:  BNZ   270A
26FC:  MOVF   x57,F
26FE:  BNZ   270A
2700:  MOVF   x56,F
2702:  BNZ   270A
2704:  MOVF   x55,W
2706:  SUBLW  05
2708:  BC    276A
270A:  MOVF   x58,F
270C:  BNZ   276A
270E:  MOVF   x57,F
2710:  BNZ   276A
2712:  MOVF   x56,F
2714:  BNZ   276A
2716:  MOVF   x55,W
2718:  SUBLW  3B
271A:  BNC   276A
271C:  MOVF   x5C,F
271E:  BNZ   272E
2720:  MOVF   x5B,F
2722:  BNZ   272E
2724:  MOVF   x5A,F
2726:  BNZ   272E
2728:  MOVF   x59,W
272A:  SUBLW  64
272C:  BC    276A
272E:  MOVF   x60,F
2730:  BNZ   2740
2732:  MOVF   x5F,F
2734:  BNZ   2740
2736:  MOVF   x5E,F
2738:  BNZ   2740
273A:  MOVF   x5D,W
273C:  SUBLW  64
273E:  BC    276A
2740:  MOVF   x64,F
2742:  BNZ   2752
2744:  MOVF   x63,F
2746:  BNZ   2752
2748:  MOVF   x62,F
274A:  BNZ   2752
274C:  MOVF   x61,W
274E:  SUBLW  64
2750:  BC    276A
2752:  MOVF   x68,F
2754:  BNZ   2764
2756:  MOVF   x67,F
2758:  BNZ   2764
275A:  MOVF   x66,F
275C:  BNZ   2764
275E:  MOVF   x65,W
2760:  SUBLW  64
2762:  BC    276A
2764:  MOVLW  00
2766:  MOVWF  01
2768:  BRA    29E8
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
276A:  MOVF   x5C,F
276C:  BNZ   277C
276E:  MOVF   x5B,F
2770:  BNZ   277C
2772:  MOVF   x5A,F
2774:  BNZ   277C
2776:  MOVF   x59,W
2778:  SUBLW  05
277A:  BC    27DC
277C:  MOVF   x5C,F
277E:  BNZ   27DC
2780:  MOVF   x5B,F
2782:  BNZ   27DC
2784:  MOVF   x5A,F
2786:  BNZ   27DC
2788:  MOVF   x59,W
278A:  SUBLW  3B
278C:  BNC   27DC
278E:  MOVF   x58,F
2790:  BNZ   27A0
2792:  MOVF   x57,F
2794:  BNZ   27A0
2796:  MOVF   x56,F
2798:  BNZ   27A0
279A:  MOVF   x55,W
279C:  SUBLW  64
279E:  BC    27DC
27A0:  MOVF   x60,F
27A2:  BNZ   27B2
27A4:  MOVF   x5F,F
27A6:  BNZ   27B2
27A8:  MOVF   x5E,F
27AA:  BNZ   27B2
27AC:  MOVF   x5D,W
27AE:  SUBLW  64
27B0:  BC    27DC
27B2:  MOVF   x64,F
27B4:  BNZ   27C4
27B6:  MOVF   x63,F
27B8:  BNZ   27C4
27BA:  MOVF   x62,F
27BC:  BNZ   27C4
27BE:  MOVF   x61,W
27C0:  SUBLW  64
27C2:  BC    27DC
27C4:  MOVF   x68,F
27C6:  BNZ   27D6
27C8:  MOVF   x67,F
27CA:  BNZ   27D6
27CC:  MOVF   x66,F
27CE:  BNZ   27D6
27D0:  MOVF   x65,W
27D2:  SUBLW  64
27D4:  BC    27DC
27D6:  MOVLW  01
27D8:  MOVWF  01
27DA:  BRA    29E8
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
27DC:  MOVF   x60,F
27DE:  BNZ   27EE
27E0:  MOVF   x5F,F
27E2:  BNZ   27EE
27E4:  MOVF   x5E,F
27E6:  BNZ   27EE
27E8:  MOVF   x5D,W
27EA:  SUBLW  05
27EC:  BC    284E
27EE:  MOVF   x60,F
27F0:  BNZ   284E
27F2:  MOVF   x5F,F
27F4:  BNZ   284E
27F6:  MOVF   x5E,F
27F8:  BNZ   284E
27FA:  MOVF   x5D,W
27FC:  SUBLW  3B
27FE:  BNC   284E
2800:  MOVF   x5C,F
2802:  BNZ   2812
2804:  MOVF   x5B,F
2806:  BNZ   2812
2808:  MOVF   x5A,F
280A:  BNZ   2812
280C:  MOVF   x59,W
280E:  SUBLW  64
2810:  BC    284E
2812:  MOVF   x58,F
2814:  BNZ   2824
2816:  MOVF   x57,F
2818:  BNZ   2824
281A:  MOVF   x56,F
281C:  BNZ   2824
281E:  MOVF   x55,W
2820:  SUBLW  64
2822:  BC    284E
2824:  MOVF   x64,F
2826:  BNZ   2836
2828:  MOVF   x63,F
282A:  BNZ   2836
282C:  MOVF   x62,F
282E:  BNZ   2836
2830:  MOVF   x61,W
2832:  SUBLW  64
2834:  BC    284E
2836:  MOVF   x68,F
2838:  BNZ   2848
283A:  MOVF   x67,F
283C:  BNZ   2848
283E:  MOVF   x66,F
2840:  BNZ   2848
2842:  MOVF   x65,W
2844:  SUBLW  64
2846:  BC    284E
2848:  MOVLW  02
284A:  MOVWF  01
284C:  BRA    29E8
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
284E:  MOVF   x64,F
2850:  BNZ   2860
2852:  MOVF   x63,F
2854:  BNZ   2860
2856:  MOVF   x62,F
2858:  BNZ   2860
285A:  MOVF   x61,W
285C:  SUBLW  05
285E:  BC    28C0
2860:  MOVF   x64,F
2862:  BNZ   28C0
2864:  MOVF   x63,F
2866:  BNZ   28C0
2868:  MOVF   x62,F
286A:  BNZ   28C0
286C:  MOVF   x61,W
286E:  SUBLW  3B
2870:  BNC   28C0
2872:  MOVF   x5C,F
2874:  BNZ   2884
2876:  MOVF   x5B,F
2878:  BNZ   2884
287A:  MOVF   x5A,F
287C:  BNZ   2884
287E:  MOVF   x59,W
2880:  SUBLW  64
2882:  BC    28C0
2884:  MOVF   x60,F
2886:  BNZ   2896
2888:  MOVF   x5F,F
288A:  BNZ   2896
288C:  MOVF   x5E,F
288E:  BNZ   2896
2890:  MOVF   x5D,W
2892:  SUBLW  64
2894:  BC    28C0
2896:  MOVF   x58,F
2898:  BNZ   28A8
289A:  MOVF   x57,F
289C:  BNZ   28A8
289E:  MOVF   x56,F
28A0:  BNZ   28A8
28A2:  MOVF   x55,W
28A4:  SUBLW  64
28A6:  BC    28C0
28A8:  MOVF   x68,F
28AA:  BNZ   28BA
28AC:  MOVF   x67,F
28AE:  BNZ   28BA
28B0:  MOVF   x66,F
28B2:  BNZ   28BA
28B4:  MOVF   x65,W
28B6:  SUBLW  64
28B8:  BC    28C0
28BA:  MOVLW  03
28BC:  MOVWF  01
28BE:  BRA    29E8
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
28C0:  MOVF   x68,F
28C2:  BNZ   28D2
28C4:  MOVF   x67,F
28C6:  BNZ   28D2
28C8:  MOVF   x66,F
28CA:  BNZ   28D2
28CC:  MOVF   x65,W
28CE:  SUBLW  05
28D0:  BC    2932
28D2:  MOVF   x68,F
28D4:  BNZ   2932
28D6:  MOVF   x67,F
28D8:  BNZ   2932
28DA:  MOVF   x66,F
28DC:  BNZ   2932
28DE:  MOVF   x65,W
28E0:  SUBLW  3B
28E2:  BNC   2932
28E4:  MOVF   x5C,F
28E6:  BNZ   28F6
28E8:  MOVF   x5B,F
28EA:  BNZ   28F6
28EC:  MOVF   x5A,F
28EE:  BNZ   28F6
28F0:  MOVF   x59,W
28F2:  SUBLW  64
28F4:  BC    2932
28F6:  MOVF   x60,F
28F8:  BNZ   2908
28FA:  MOVF   x5F,F
28FC:  BNZ   2908
28FE:  MOVF   x5E,F
2900:  BNZ   2908
2902:  MOVF   x5D,W
2904:  SUBLW  64
2906:  BC    2932
2908:  MOVF   x64,F
290A:  BNZ   291A
290C:  MOVF   x63,F
290E:  BNZ   291A
2910:  MOVF   x62,F
2912:  BNZ   291A
2914:  MOVF   x61,W
2916:  SUBLW  64
2918:  BC    2932
291A:  MOVF   x58,F
291C:  BNZ   292C
291E:  MOVF   x57,F
2920:  BNZ   292C
2922:  MOVF   x56,F
2924:  BNZ   292C
2926:  MOVF   x55,W
2928:  SUBLW  64
292A:  BC    2932
292C:  MOVLW  04
292E:  MOVWF  01
2930:  BRA    29E8
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2932:  MOVF   x68,F
2934:  BNZ   2946
2936:  MOVF   x67,F
2938:  BNZ   2946
293A:  MOVF   x66,F
293C:  BNZ   2946
293E:  MOVF   x65,W
2940:  SUBLW  C8
2942:  BTFSC  FD8.0
2944:  BRA    29E4
2946:  MOVF   x58,F
2948:  BTFSS  FD8.2
294A:  BRA    29E4
294C:  MOVF   x57,F
294E:  BTFSS  FD8.2
2950:  BRA    29E4
2952:  MOVF   x56,F
2954:  BTFSS  FD8.2
2956:  BRA    29E4
2958:  MOVF   x55,W
295A:  SUBLW  B3
295C:  BNC   29E4
295E:  MOVF   x58,F
2960:  BNZ   2970
2962:  MOVF   x57,F
2964:  BNZ   2970
2966:  MOVF   x56,F
2968:  BNZ   2970
296A:  MOVF   x55,W
296C:  SUBLW  64
296E:  BC    29E4
2970:  MOVF   x5C,F
2972:  BNZ   29E4
2974:  MOVF   x5B,F
2976:  BNZ   29E4
2978:  MOVF   x5A,F
297A:  BNZ   29E4
297C:  MOVF   x59,W
297E:  SUBLW  B3
2980:  BNC   29E4
2982:  MOVF   x5C,F
2984:  BNZ   2994
2986:  MOVF   x5B,F
2988:  BNZ   2994
298A:  MOVF   x5A,F
298C:  BNZ   2994
298E:  MOVF   x59,W
2990:  SUBLW  64
2992:  BC    29E4
2994:  MOVF   x60,F
2996:  BNZ   29E4
2998:  MOVF   x5F,F
299A:  BNZ   29E4
299C:  MOVF   x5E,F
299E:  BNZ   29E4
29A0:  MOVF   x5D,W
29A2:  SUBLW  B3
29A4:  BNC   29E4
29A6:  MOVF   x60,F
29A8:  BNZ   29B8
29AA:  MOVF   x5F,F
29AC:  BNZ   29B8
29AE:  MOVF   x5E,F
29B0:  BNZ   29B8
29B2:  MOVF   x5D,W
29B4:  SUBLW  64
29B6:  BC    29E4
29B8:  MOVF   x64,F
29BA:  BNZ   29E4
29BC:  MOVF   x63,F
29BE:  BNZ   29E4
29C0:  MOVF   x62,F
29C2:  BNZ   29E4
29C4:  MOVF   x61,W
29C6:  SUBLW  B3
29C8:  BNC   29E4
29CA:  MOVF   x64,F
29CC:  BNZ   29DC
29CE:  MOVF   x63,F
29D0:  BNZ   29DC
29D2:  MOVF   x62,F
29D4:  BNZ   29DC
29D6:  MOVF   x61,W
29D8:  SUBLW  64
29DA:  BC    29E4
29DC:  MOVLW  04
29DE:  MOVWF  01
29E0:  BRA    29E8
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
29E2:  BRA    29E8
29E4:  MOVLW  FF
29E6:  MOVWF  01
.................... } 
29E8:  MOVLB  0
29EA:  GOTO   3236 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
29EE:  MOVLB  8
29F0:  CLRF   x58
29F2:  CLRF   x57
29F4:  CLRF   x56
29F6:  CLRF   x55
29F8:  CLRF   x5C
29FA:  CLRF   x5B
29FC:  CLRF   x5A
29FE:  CLRF   x59
2A00:  CLRF   x60
2A02:  CLRF   x5F
2A04:  CLRF   x5E
2A06:  CLRF   x5D
2A08:  CLRF   x64
2A0A:  CLRF   x63
2A0C:  CLRF   x62
2A0E:  CLRF   x61
2A10:  CLRF   x68
2A12:  CLRF   x67
2A14:  CLRF   x66
2A16:  CLRF   x65
2A18:  CLRF   x6C
2A1A:  CLRF   x6B
2A1C:  CLRF   x6A
2A1E:  CLRF   x69
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2A20:  CLRF   x54
2A22:  CLRF   x53
2A24:  MOVF   x54,W
2A26:  SUBLW  01
2A28:  BNC   2AC8
2A2A:  BNZ   2A32
2A2C:  MOVF   x53,W
2A2E:  SUBLW  F3
2A30:  BNC   2AC8
....................    { 
....................       col_0=read_col(0)+col_0; 
2A32:  CLRF   x6D
2A34:  MOVLB  0
2A36:  CALL   2158
2A3A:  MOVF   01,W
2A3C:  MOVLB  8
2A3E:  ADDWF  x55,F
2A40:  MOVLW  00
2A42:  ADDWFC x56,F
2A44:  ADDWFC x57,F
2A46:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2A48:  MOVLW  01
2A4A:  MOVWF  x6D
2A4C:  MOVLB  0
2A4E:  CALL   2158
2A52:  MOVF   01,W
2A54:  MOVLB  8
2A56:  ADDWF  x59,F
2A58:  MOVLW  00
2A5A:  ADDWFC x5A,F
2A5C:  ADDWFC x5B,F
2A5E:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
2A60:  MOVLW  02
2A62:  MOVWF  x6D
2A64:  MOVLB  0
2A66:  CALL   2158
2A6A:  MOVF   01,W
2A6C:  MOVLB  8
2A6E:  ADDWF  x5D,F
2A70:  MOVLW  00
2A72:  ADDWFC x5E,F
2A74:  ADDWFC x5F,F
2A76:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
2A78:  MOVLW  03
2A7A:  MOVWF  x6D
2A7C:  MOVLB  0
2A7E:  CALL   2158
2A82:  MOVF   01,W
2A84:  MOVLB  8
2A86:  ADDWF  x61,F
2A88:  MOVLW  00
2A8A:  ADDWFC x62,F
2A8C:  ADDWFC x63,F
2A8E:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
2A90:  MOVLW  04
2A92:  MOVWF  x6D
2A94:  MOVLB  0
2A96:  CALL   2158
2A9A:  MOVF   01,W
2A9C:  MOVLB  8
2A9E:  ADDWF  x65,F
2AA0:  MOVLW  00
2AA2:  ADDWFC x66,F
2AA4:  ADDWFC x67,F
2AA6:  ADDWFC x68,F
....................       col_5=read_col(5)+col_5; 
2AA8:  MOVLW  05
2AAA:  MOVWF  x6D
2AAC:  MOVLB  0
2AAE:  CALL   2158
2AB2:  MOVF   01,W
2AB4:  MOVLB  8
2AB6:  ADDWF  x69,F
2AB8:  MOVLW  00
2ABA:  ADDWFC x6A,F
2ABC:  ADDWFC x6B,F
2ABE:  ADDWFC x6C,F
....................    } 
2AC0:  INCF   x53,F
2AC2:  BTFSC  FD8.2
2AC4:  INCF   x54,F
2AC6:  BRA    2A24
....................    col_0=col_0/500; 
2AC8:  BCF    FD8.1
2ACA:  MOVFF  858,90F
2ACE:  MOVFF  857,90E
2AD2:  MOVFF  856,90D
2AD6:  MOVFF  855,90C
2ADA:  MOVLB  9
2ADC:  CLRF   x13
2ADE:  CLRF   x12
2AE0:  MOVLW  01
2AE2:  MOVWF  x11
2AE4:  MOVLW  F4
2AE6:  MOVWF  x10
2AE8:  MOVLB  0
2AEA:  CALL   2266
2AEE:  MOVFF  03,858
2AF2:  MOVFF  02,857
2AF6:  MOVFF  01,856
2AFA:  MOVFF  00,855
....................    col_1=col_1/500; 
2AFE:  BCF    FD8.1
2B00:  MOVFF  85C,90F
2B04:  MOVFF  85B,90E
2B08:  MOVFF  85A,90D
2B0C:  MOVFF  859,90C
2B10:  MOVLB  9
2B12:  CLRF   x13
2B14:  CLRF   x12
2B16:  MOVLW  01
2B18:  MOVWF  x11
2B1A:  MOVLW  F4
2B1C:  MOVWF  x10
2B1E:  MOVLB  0
2B20:  CALL   2266
2B24:  MOVFF  03,85C
2B28:  MOVFF  02,85B
2B2C:  MOVFF  01,85A
2B30:  MOVFF  00,859
....................    col_2=col_2/500; 
2B34:  BCF    FD8.1
2B36:  MOVFF  860,90F
2B3A:  MOVFF  85F,90E
2B3E:  MOVFF  85E,90D
2B42:  MOVFF  85D,90C
2B46:  MOVLB  9
2B48:  CLRF   x13
2B4A:  CLRF   x12
2B4C:  MOVLW  01
2B4E:  MOVWF  x11
2B50:  MOVLW  F4
2B52:  MOVWF  x10
2B54:  MOVLB  0
2B56:  CALL   2266
2B5A:  MOVFF  03,860
2B5E:  MOVFF  02,85F
2B62:  MOVFF  01,85E
2B66:  MOVFF  00,85D
....................    col_3=col_3/500; 
2B6A:  BCF    FD8.1
2B6C:  MOVFF  864,90F
2B70:  MOVFF  863,90E
2B74:  MOVFF  862,90D
2B78:  MOVFF  861,90C
2B7C:  MOVLB  9
2B7E:  CLRF   x13
2B80:  CLRF   x12
2B82:  MOVLW  01
2B84:  MOVWF  x11
2B86:  MOVLW  F4
2B88:  MOVWF  x10
2B8A:  MOVLB  0
2B8C:  CALL   2266
2B90:  MOVFF  03,864
2B94:  MOVFF  02,863
2B98:  MOVFF  01,862
2B9C:  MOVFF  00,861
....................    col_4=col_4/500; 
2BA0:  BCF    FD8.1
2BA2:  MOVFF  868,90F
2BA6:  MOVFF  867,90E
2BAA:  MOVFF  866,90D
2BAE:  MOVFF  865,90C
2BB2:  MOVLB  9
2BB4:  CLRF   x13
2BB6:  CLRF   x12
2BB8:  MOVLW  01
2BBA:  MOVWF  x11
2BBC:  MOVLW  F4
2BBE:  MOVWF  x10
2BC0:  MOVLB  0
2BC2:  CALL   2266
2BC6:  MOVFF  03,868
2BCA:  MOVFF  02,867
2BCE:  MOVFF  01,866
2BD2:  MOVFF  00,865
....................    col_5=col_5/500; 
2BD6:  BCF    FD8.1
2BD8:  MOVFF  86C,90F
2BDC:  MOVFF  86B,90E
2BE0:  MOVFF  86A,90D
2BE4:  MOVFF  869,90C
2BE8:  MOVLB  9
2BEA:  CLRF   x13
2BEC:  CLRF   x12
2BEE:  MOVLW  01
2BF0:  MOVWF  x11
2BF2:  MOVLW  F4
2BF4:  MOVWF  x10
2BF6:  MOVLB  0
2BF8:  CALL   2266
2BFC:  MOVFF  03,86C
2C00:  MOVFF  02,86B
2C04:  MOVFF  01,86A
2C08:  MOVFF  00,869
....................    if(keydebug_en) 
2C0C:  MOVLB  1
2C0E:  MOVF   x44,F
2C10:  BTFSC  FD8.2
2C12:  BRA    2DDC
....................    { 
....................       fprintf(COM2,"\r\n");      
2C14:  MOVLW  0D
2C16:  MOVLB  9
2C18:  MOVWF  x0C
2C1A:  MOVLB  0
2C1C:  CALL   1604
2C20:  MOVLW  0A
2C22:  MOVLB  9
2C24:  MOVWF  x0C
2C26:  MOVLB  0
2C28:  CALL   1604
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2C2C:  MOVLW  02
2C2E:  MOVWF  FF6
2C30:  MOVLW  05
2C32:  MOVWF  FF7
2C34:  MOVLW  07
2C36:  MOVLB  8
2C38:  MOVWF  xF7
2C3A:  MOVLB  0
2C3C:  CALL   164A
2C40:  MOVLW  41
2C42:  MOVWF  FE9
2C44:  MOVFF  858,8FA
2C48:  MOVFF  857,8F9
2C4C:  MOVFF  856,8F8
2C50:  MOVFF  855,8F7
2C54:  CALL   22FA
2C58:  MOVLW  0D
2C5A:  MOVLB  9
2C5C:  MOVWF  x0C
2C5E:  MOVLB  0
2C60:  CALL   1604
2C64:  MOVLW  0A
2C66:  MOVLB  9
2C68:  MOVWF  x0C
2C6A:  MOVLB  0
2C6C:  CALL   1604
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2C70:  MOVLW  10
2C72:  MOVWF  FF6
2C74:  MOVLW  05
2C76:  MOVWF  FF7
2C78:  MOVLW  07
2C7A:  MOVLB  8
2C7C:  MOVWF  xF7
2C7E:  MOVLB  0
2C80:  CALL   164A
2C84:  MOVLW  41
2C86:  MOVWF  FE9
2C88:  MOVFF  85C,8FA
2C8C:  MOVFF  85B,8F9
2C90:  MOVFF  85A,8F8
2C94:  MOVFF  859,8F7
2C98:  CALL   22FA
2C9C:  MOVLW  0D
2C9E:  MOVLB  9
2CA0:  MOVWF  x0C
2CA2:  MOVLB  0
2CA4:  CALL   1604
2CA8:  MOVLW  0A
2CAA:  MOVLB  9
2CAC:  MOVWF  x0C
2CAE:  MOVLB  0
2CB0:  CALL   1604
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2CB4:  MOVLW  1E
2CB6:  MOVWF  FF6
2CB8:  MOVLW  05
2CBA:  MOVWF  FF7
2CBC:  MOVLW  07
2CBE:  MOVLB  8
2CC0:  MOVWF  xF7
2CC2:  MOVLB  0
2CC4:  CALL   164A
2CC8:  MOVLW  41
2CCA:  MOVWF  FE9
2CCC:  MOVFF  860,8FA
2CD0:  MOVFF  85F,8F9
2CD4:  MOVFF  85E,8F8
2CD8:  MOVFF  85D,8F7
2CDC:  CALL   22FA
2CE0:  MOVLW  0D
2CE2:  MOVLB  9
2CE4:  MOVWF  x0C
2CE6:  MOVLB  0
2CE8:  CALL   1604
2CEC:  MOVLW  0A
2CEE:  MOVLB  9
2CF0:  MOVWF  x0C
2CF2:  MOVLB  0
2CF4:  CALL   1604
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2CF8:  MOVLW  2C
2CFA:  MOVWF  FF6
2CFC:  MOVLW  05
2CFE:  MOVWF  FF7
2D00:  MOVLW  07
2D02:  MOVLB  8
2D04:  MOVWF  xF7
2D06:  MOVLB  0
2D08:  CALL   164A
2D0C:  MOVLW  41
2D0E:  MOVWF  FE9
2D10:  MOVFF  864,8FA
2D14:  MOVFF  863,8F9
2D18:  MOVFF  862,8F8
2D1C:  MOVFF  861,8F7
2D20:  CALL   22FA
2D24:  MOVLW  0D
2D26:  MOVLB  9
2D28:  MOVWF  x0C
2D2A:  MOVLB  0
2D2C:  CALL   1604
2D30:  MOVLW  0A
2D32:  MOVLB  9
2D34:  MOVWF  x0C
2D36:  MOVLB  0
2D38:  CALL   1604
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2D3C:  MOVLW  3A
2D3E:  MOVWF  FF6
2D40:  MOVLW  05
2D42:  MOVWF  FF7
2D44:  MOVLW  07
2D46:  MOVLB  8
2D48:  MOVWF  xF7
2D4A:  MOVLB  0
2D4C:  CALL   164A
2D50:  MOVLW  41
2D52:  MOVWF  FE9
2D54:  MOVFF  868,8FA
2D58:  MOVFF  867,8F9
2D5C:  MOVFF  866,8F8
2D60:  MOVFF  865,8F7
2D64:  CALL   22FA
2D68:  MOVLW  0D
2D6A:  MOVLB  9
2D6C:  MOVWF  x0C
2D6E:  MOVLB  0
2D70:  CALL   1604
2D74:  MOVLW  0A
2D76:  MOVLB  9
2D78:  MOVWF  x0C
2D7A:  MOVLB  0
2D7C:  CALL   1604
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2D80:  MOVLW  48
2D82:  MOVWF  FF6
2D84:  MOVLW  05
2D86:  MOVWF  FF7
2D88:  MOVLW  07
2D8A:  MOVLB  8
2D8C:  MOVWF  xF7
2D8E:  MOVLB  0
2D90:  CALL   164A
2D94:  MOVLW  41
2D96:  MOVWF  FE9
2D98:  MOVFF  86C,8FA
2D9C:  MOVFF  86B,8F9
2DA0:  MOVFF  86A,8F8
2DA4:  MOVFF  869,8F7
2DA8:  CALL   22FA
2DAC:  MOVLW  0D
2DAE:  MOVLB  9
2DB0:  MOVWF  x0C
2DB2:  MOVLB  0
2DB4:  CALL   1604
2DB8:  MOVLW  0A
2DBA:  MOVLB  9
2DBC:  MOVWF  x0C
2DBE:  MOVLB  0
2DC0:  CALL   1604
....................       fprintf(COM2,"\r\n"); 
2DC4:  MOVLW  0D
2DC6:  MOVLB  9
2DC8:  MOVWF  x0C
2DCA:  MOVLB  0
2DCC:  CALL   1604
2DD0:  MOVLW  0A
2DD2:  MOVLB  9
2DD4:  MOVWF  x0C
2DD6:  MOVLB  0
2DD8:  CALL   1604
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2DDC:  MOVLB  8
2DDE:  MOVF   x58,F
2DE0:  BNZ   2DF0
2DE2:  MOVF   x57,F
2DE4:  BNZ   2DF0
2DE6:  MOVF   x56,F
2DE8:  BNZ   2DF0
2DEA:  MOVF   x55,W
2DEC:  SUBLW  05
2DEE:  BC    2E62
2DF0:  MOVF   x58,F
2DF2:  BNZ   2E62
2DF4:  MOVF   x57,F
2DF6:  BNZ   2E62
2DF8:  MOVF   x56,F
2DFA:  BNZ   2E62
2DFC:  MOVF   x55,W
2DFE:  SUBLW  3B
2E00:  BNC   2E62
2E02:  MOVF   x5C,F
2E04:  BNZ   2E14
2E06:  MOVF   x5B,F
2E08:  BNZ   2E14
2E0A:  MOVF   x5A,F
2E0C:  BNZ   2E14
2E0E:  MOVF   x59,W
2E10:  SUBLW  64
2E12:  BC    2E62
2E14:  MOVF   x60,F
2E16:  BNZ   2E26
2E18:  MOVF   x5F,F
2E1A:  BNZ   2E26
2E1C:  MOVF   x5E,F
2E1E:  BNZ   2E26
2E20:  MOVF   x5D,W
2E22:  SUBLW  64
2E24:  BC    2E62
2E26:  MOVF   x64,F
2E28:  BNZ   2E38
2E2A:  MOVF   x63,F
2E2C:  BNZ   2E38
2E2E:  MOVF   x62,F
2E30:  BNZ   2E38
2E32:  MOVF   x61,W
2E34:  SUBLW  64
2E36:  BC    2E62
2E38:  MOVF   x68,F
2E3A:  BNZ   2E4A
2E3C:  MOVF   x67,F
2E3E:  BNZ   2E4A
2E40:  MOVF   x66,F
2E42:  BNZ   2E4A
2E44:  MOVF   x65,W
2E46:  SUBLW  64
2E48:  BC    2E62
2E4A:  MOVF   x6C,F
2E4C:  BNZ   2E5C
2E4E:  MOVF   x6B,F
2E50:  BNZ   2E5C
2E52:  MOVF   x6A,F
2E54:  BNZ   2E5C
2E56:  MOVF   x69,W
2E58:  SUBLW  64
2E5A:  BC    2E62
2E5C:  MOVLW  00
2E5E:  MOVWF  01
2E60:  BRA    31DA
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2E62:  MOVF   x5C,F
2E64:  BNZ   2E74
2E66:  MOVF   x5B,F
2E68:  BNZ   2E74
2E6A:  MOVF   x5A,F
2E6C:  BNZ   2E74
2E6E:  MOVF   x59,W
2E70:  SUBLW  05
2E72:  BC    2EE6
2E74:  MOVF   x5C,F
2E76:  BNZ   2EE6
2E78:  MOVF   x5B,F
2E7A:  BNZ   2EE6
2E7C:  MOVF   x5A,F
2E7E:  BNZ   2EE6
2E80:  MOVF   x59,W
2E82:  SUBLW  3B
2E84:  BNC   2EE6
2E86:  MOVF   x58,F
2E88:  BNZ   2E98
2E8A:  MOVF   x57,F
2E8C:  BNZ   2E98
2E8E:  MOVF   x56,F
2E90:  BNZ   2E98
2E92:  MOVF   x55,W
2E94:  SUBLW  64
2E96:  BC    2EE6
2E98:  MOVF   x60,F
2E9A:  BNZ   2EAA
2E9C:  MOVF   x5F,F
2E9E:  BNZ   2EAA
2EA0:  MOVF   x5E,F
2EA2:  BNZ   2EAA
2EA4:  MOVF   x5D,W
2EA6:  SUBLW  64
2EA8:  BC    2EE6
2EAA:  MOVF   x64,F
2EAC:  BNZ   2EBC
2EAE:  MOVF   x63,F
2EB0:  BNZ   2EBC
2EB2:  MOVF   x62,F
2EB4:  BNZ   2EBC
2EB6:  MOVF   x61,W
2EB8:  SUBLW  64
2EBA:  BC    2EE6
2EBC:  MOVF   x68,F
2EBE:  BNZ   2ECE
2EC0:  MOVF   x67,F
2EC2:  BNZ   2ECE
2EC4:  MOVF   x66,F
2EC6:  BNZ   2ECE
2EC8:  MOVF   x65,W
2ECA:  SUBLW  64
2ECC:  BC    2EE6
2ECE:  MOVF   x6C,F
2ED0:  BNZ   2EE0
2ED2:  MOVF   x6B,F
2ED4:  BNZ   2EE0
2ED6:  MOVF   x6A,F
2ED8:  BNZ   2EE0
2EDA:  MOVF   x69,W
2EDC:  SUBLW  64
2EDE:  BC    2EE6
2EE0:  MOVLW  01
2EE2:  MOVWF  01
2EE4:  BRA    31DA
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2EE6:  MOVF   x60,F
2EE8:  BNZ   2EF8
2EEA:  MOVF   x5F,F
2EEC:  BNZ   2EF8
2EEE:  MOVF   x5E,F
2EF0:  BNZ   2EF8
2EF2:  MOVF   x5D,W
2EF4:  SUBLW  05
2EF6:  BC    2F6A
2EF8:  MOVF   x60,F
2EFA:  BNZ   2F6A
2EFC:  MOVF   x5F,F
2EFE:  BNZ   2F6A
2F00:  MOVF   x5E,F
2F02:  BNZ   2F6A
2F04:  MOVF   x5D,W
2F06:  SUBLW  3B
2F08:  BNC   2F6A
2F0A:  MOVF   x5C,F
2F0C:  BNZ   2F1C
2F0E:  MOVF   x5B,F
2F10:  BNZ   2F1C
2F12:  MOVF   x5A,F
2F14:  BNZ   2F1C
2F16:  MOVF   x59,W
2F18:  SUBLW  64
2F1A:  BC    2F6A
2F1C:  MOVF   x58,F
2F1E:  BNZ   2F2E
2F20:  MOVF   x57,F
2F22:  BNZ   2F2E
2F24:  MOVF   x56,F
2F26:  BNZ   2F2E
2F28:  MOVF   x55,W
2F2A:  SUBLW  64
2F2C:  BC    2F6A
2F2E:  MOVF   x64,F
2F30:  BNZ   2F40
2F32:  MOVF   x63,F
2F34:  BNZ   2F40
2F36:  MOVF   x62,F
2F38:  BNZ   2F40
2F3A:  MOVF   x61,W
2F3C:  SUBLW  64
2F3E:  BC    2F6A
2F40:  MOVF   x68,F
2F42:  BNZ   2F52
2F44:  MOVF   x67,F
2F46:  BNZ   2F52
2F48:  MOVF   x66,F
2F4A:  BNZ   2F52
2F4C:  MOVF   x65,W
2F4E:  SUBLW  64
2F50:  BC    2F6A
2F52:  MOVF   x6C,F
2F54:  BNZ   2F64
2F56:  MOVF   x6B,F
2F58:  BNZ   2F64
2F5A:  MOVF   x6A,F
2F5C:  BNZ   2F64
2F5E:  MOVF   x69,W
2F60:  SUBLW  64
2F62:  BC    2F6A
2F64:  MOVLW  02
2F66:  MOVWF  01
2F68:  BRA    31DA
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2F6A:  MOVF   x64,F
2F6C:  BNZ   2F7C
2F6E:  MOVF   x63,F
2F70:  BNZ   2F7C
2F72:  MOVF   x62,F
2F74:  BNZ   2F7C
2F76:  MOVF   x61,W
2F78:  SUBLW  05
2F7A:  BC    2FEE
2F7C:  MOVF   x64,F
2F7E:  BNZ   2FEE
2F80:  MOVF   x63,F
2F82:  BNZ   2FEE
2F84:  MOVF   x62,F
2F86:  BNZ   2FEE
2F88:  MOVF   x61,W
2F8A:  SUBLW  3B
2F8C:  BNC   2FEE
2F8E:  MOVF   x5C,F
2F90:  BNZ   2FA0
2F92:  MOVF   x5B,F
2F94:  BNZ   2FA0
2F96:  MOVF   x5A,F
2F98:  BNZ   2FA0
2F9A:  MOVF   x59,W
2F9C:  SUBLW  64
2F9E:  BC    2FEE
2FA0:  MOVF   x60,F
2FA2:  BNZ   2FB2
2FA4:  MOVF   x5F,F
2FA6:  BNZ   2FB2
2FA8:  MOVF   x5E,F
2FAA:  BNZ   2FB2
2FAC:  MOVF   x5D,W
2FAE:  SUBLW  64
2FB0:  BC    2FEE
2FB2:  MOVF   x58,F
2FB4:  BNZ   2FC4
2FB6:  MOVF   x57,F
2FB8:  BNZ   2FC4
2FBA:  MOVF   x56,F
2FBC:  BNZ   2FC4
2FBE:  MOVF   x55,W
2FC0:  SUBLW  64
2FC2:  BC    2FEE
2FC4:  MOVF   x68,F
2FC6:  BNZ   2FD6
2FC8:  MOVF   x67,F
2FCA:  BNZ   2FD6
2FCC:  MOVF   x66,F
2FCE:  BNZ   2FD6
2FD0:  MOVF   x65,W
2FD2:  SUBLW  64
2FD4:  BC    2FEE
2FD6:  MOVF   x6C,F
2FD8:  BNZ   2FE8
2FDA:  MOVF   x6B,F
2FDC:  BNZ   2FE8
2FDE:  MOVF   x6A,F
2FE0:  BNZ   2FE8
2FE2:  MOVF   x69,W
2FE4:  SUBLW  64
2FE6:  BC    2FEE
2FE8:  MOVLW  03
2FEA:  MOVWF  01
2FEC:  BRA    31DA
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
2FEE:  MOVF   x68,F
2FF0:  BNZ   3000
2FF2:  MOVF   x67,F
2FF4:  BNZ   3000
2FF6:  MOVF   x66,F
2FF8:  BNZ   3000
2FFA:  MOVF   x65,W
2FFC:  SUBLW  05
2FFE:  BC    3072
3000:  MOVF   x68,F
3002:  BNZ   3072
3004:  MOVF   x67,F
3006:  BNZ   3072
3008:  MOVF   x66,F
300A:  BNZ   3072
300C:  MOVF   x65,W
300E:  SUBLW  3B
3010:  BNC   3072
3012:  MOVF   x5C,F
3014:  BNZ   3024
3016:  MOVF   x5B,F
3018:  BNZ   3024
301A:  MOVF   x5A,F
301C:  BNZ   3024
301E:  MOVF   x59,W
3020:  SUBLW  64
3022:  BC    3072
3024:  MOVF   x60,F
3026:  BNZ   3036
3028:  MOVF   x5F,F
302A:  BNZ   3036
302C:  MOVF   x5E,F
302E:  BNZ   3036
3030:  MOVF   x5D,W
3032:  SUBLW  64
3034:  BC    3072
3036:  MOVF   x64,F
3038:  BNZ   3048
303A:  MOVF   x63,F
303C:  BNZ   3048
303E:  MOVF   x62,F
3040:  BNZ   3048
3042:  MOVF   x61,W
3044:  SUBLW  64
3046:  BC    3072
3048:  MOVF   x58,F
304A:  BNZ   305A
304C:  MOVF   x57,F
304E:  BNZ   305A
3050:  MOVF   x56,F
3052:  BNZ   305A
3054:  MOVF   x55,W
3056:  SUBLW  64
3058:  BC    3072
305A:  MOVF   x6C,F
305C:  BNZ   306C
305E:  MOVF   x6B,F
3060:  BNZ   306C
3062:  MOVF   x6A,F
3064:  BNZ   306C
3066:  MOVF   x69,W
3068:  SUBLW  64
306A:  BC    3072
306C:  MOVLW  04
306E:  MOVWF  01
3070:  BRA    31DA
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
3072:  MOVF   x6C,F
3074:  BNZ   3084
3076:  MOVF   x6B,F
3078:  BNZ   3084
307A:  MOVF   x6A,F
307C:  BNZ   3084
307E:  MOVF   x69,W
3080:  SUBLW  05
3082:  BC    30F6
3084:  MOVF   x6C,F
3086:  BNZ   30F6
3088:  MOVF   x6B,F
308A:  BNZ   30F6
308C:  MOVF   x6A,F
308E:  BNZ   30F6
3090:  MOVF   x69,W
3092:  SUBLW  3B
3094:  BNC   30F6
3096:  MOVF   x5C,F
3098:  BNZ   30A8
309A:  MOVF   x5B,F
309C:  BNZ   30A8
309E:  MOVF   x5A,F
30A0:  BNZ   30A8
30A2:  MOVF   x59,W
30A4:  SUBLW  64
30A6:  BC    30F6
30A8:  MOVF   x60,F
30AA:  BNZ   30BA
30AC:  MOVF   x5F,F
30AE:  BNZ   30BA
30B0:  MOVF   x5E,F
30B2:  BNZ   30BA
30B4:  MOVF   x5D,W
30B6:  SUBLW  64
30B8:  BC    30F6
30BA:  MOVF   x64,F
30BC:  BNZ   30CC
30BE:  MOVF   x63,F
30C0:  BNZ   30CC
30C2:  MOVF   x62,F
30C4:  BNZ   30CC
30C6:  MOVF   x61,W
30C8:  SUBLW  64
30CA:  BC    30F6
30CC:  MOVF   x68,F
30CE:  BNZ   30DE
30D0:  MOVF   x67,F
30D2:  BNZ   30DE
30D4:  MOVF   x66,F
30D6:  BNZ   30DE
30D8:  MOVF   x65,W
30DA:  SUBLW  64
30DC:  BC    30F6
30DE:  MOVF   x58,F
30E0:  BNZ   30F0
30E2:  MOVF   x57,F
30E4:  BNZ   30F0
30E6:  MOVF   x56,F
30E8:  BNZ   30F0
30EA:  MOVF   x55,W
30EC:  SUBLW  64
30EE:  BC    30F6
30F0:  MOVLW  05
30F2:  MOVWF  01
30F4:  BRA    31DA
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
30F6:  MOVF   x6C,F
30F8:  BNZ   310A
30FA:  MOVF   x6B,F
30FC:  BNZ   310A
30FE:  MOVF   x6A,F
3100:  BNZ   310A
3102:  MOVF   x69,W
3104:  SUBLW  C8
3106:  BTFSC  FD8.0
3108:  BRA    31D6
310A:  MOVF   x58,F
310C:  BTFSS  FD8.2
310E:  BRA    31D6
3110:  MOVF   x57,F
3112:  BTFSS  FD8.2
3114:  BRA    31D6
3116:  MOVF   x56,F
3118:  BTFSS  FD8.2
311A:  BRA    31D6
311C:  MOVF   x55,W
311E:  SUBLW  B3
3120:  BTFSS  FD8.0
3122:  BRA    31D6
3124:  MOVF   x58,F
3126:  BNZ   3138
3128:  MOVF   x57,F
312A:  BNZ   3138
312C:  MOVF   x56,F
312E:  BNZ   3138
3130:  MOVF   x55,W
3132:  SUBLW  64
3134:  BTFSC  FD8.0
3136:  BRA    31D6
3138:  MOVF   x5C,F
313A:  BTFSS  FD8.2
313C:  BRA    31D6
313E:  MOVF   x5B,F
3140:  BTFSS  FD8.2
3142:  BRA    31D6
3144:  MOVF   x5A,F
3146:  BTFSS  FD8.2
3148:  BRA    31D6
314A:  MOVF   x59,W
314C:  SUBLW  B3
314E:  BNC   31D6
3150:  MOVF   x5C,F
3152:  BNZ   3162
3154:  MOVF   x5B,F
3156:  BNZ   3162
3158:  MOVF   x5A,F
315A:  BNZ   3162
315C:  MOVF   x59,W
315E:  SUBLW  64
3160:  BC    31D6
3162:  MOVF   x60,F
3164:  BNZ   31D6
3166:  MOVF   x5F,F
3168:  BNZ   31D6
316A:  MOVF   x5E,F
316C:  BNZ   31D6
316E:  MOVF   x5D,W
3170:  SUBLW  B3
3172:  BNC   31D6
3174:  MOVF   x60,F
3176:  BNZ   3186
3178:  MOVF   x5F,F
317A:  BNZ   3186
317C:  MOVF   x5E,F
317E:  BNZ   3186
3180:  MOVF   x5D,W
3182:  SUBLW  64
3184:  BC    31D6
3186:  MOVF   x64,F
3188:  BNZ   31D6
318A:  MOVF   x63,F
318C:  BNZ   31D6
318E:  MOVF   x62,F
3190:  BNZ   31D6
3192:  MOVF   x61,W
3194:  SUBLW  B3
3196:  BNC   31D6
3198:  MOVF   x64,F
319A:  BNZ   31AA
319C:  MOVF   x63,F
319E:  BNZ   31AA
31A0:  MOVF   x62,F
31A2:  BNZ   31AA
31A4:  MOVF   x61,W
31A6:  SUBLW  64
31A8:  BC    31D6
31AA:  MOVF   x68,F
31AC:  BNZ   31D6
31AE:  MOVF   x67,F
31B0:  BNZ   31D6
31B2:  MOVF   x66,F
31B4:  BNZ   31D6
31B6:  MOVF   x65,W
31B8:  SUBLW  B3
31BA:  BNC   31D6
31BC:  MOVF   x68,F
31BE:  BNZ   31CE
31C0:  MOVF   x67,F
31C2:  BNZ   31CE
31C4:  MOVF   x66,F
31C6:  BNZ   31CE
31C8:  MOVF   x65,W
31CA:  SUBLW  64
31CC:  BC    31D6
31CE:  MOVLW  05
31D0:  MOVWF  01
31D2:  BRA    31DA
....................    else return 0xff; 
31D4:  BRA    31DA
31D6:  MOVLW  FF
31D8:  MOVWF  01
.................... } 
31DA:  MOVLB  0
31DC:  GOTO   3242 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
31E0:  MOVLW  20
31E2:  MOVLB  8
31E4:  MOVWF  x51
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
31E6:  BSF    F93.4
31E8:  BTFSS  F81.4
31EA:  BRA    31FE
31EC:  BSF    F93.5
31EE:  BTFSS  F81.5
31F0:  BRA    31FE
31F2:  BSF    F93.6
31F4:  BTFSS  F81.6
31F6:  BRA    31FE
31F8:  BSF    F93.7
31FA:  BTFSC  F81.7
31FC:  BRA    3364
....................     { 
....................        if(input(ROW0)==0) 
31FE:  BSF    F93.4
3200:  BTFSC  F81.4
3202:  BRA    3208
....................          row=0; 
3204:  CLRF   x52
....................        else if(input(ROW1)==0) 
3206:  BRA    322A
3208:  BSF    F93.5
320A:  BTFSC  F81.5
320C:  BRA    3214
....................          row=1; 
320E:  MOVLW  01
3210:  MOVWF  x52
....................        else if(input(ROW2)==0) 
3212:  BRA    322A
3214:  BSF    F93.6
3216:  BTFSC  F81.6
3218:  BRA    3220
....................          row=2; 
321A:  MOVLW  02
321C:  MOVWF  x52
....................        else if(input(ROW3)==0) 
321E:  BRA    322A
3220:  BSF    F93.7
3222:  BTFSC  F81.7
3224:  BRA    322A
....................          row=3;      
3226:  MOVLW  03
3228:  MOVWF  x52
....................        if(type_KB==0)col=check_col(); 
322A:  MOVLB  1
322C:  MOVF   x49,F
322E:  BNZ   323C
3230:  MOVLB  0
3232:  GOTO   23C0
3236:  MOVFF  01,850
....................          else col=new_check_col(); 
323A:  BRA    3246
323C:  MOVLB  0
323E:  GOTO   29EE
3242:  MOVFF  01,850
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
3246:  MOVLB  8
3248:  INCFSZ x50,W
324A:  BRA    324E
324C:  BRA    3334
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
324E:  MOVLB  1
3250:  MOVF   x49,F
3252:  BNZ   327A
3254:  MOVLB  8
3256:  MOVF   x52,W
3258:  MULLW  05
325A:  MOVF   FF3,W
325C:  CLRF   x54
325E:  MOVWF  x53
3260:  CLRF   03
3262:  MOVF   x50,W
3264:  ADDWF  x53,W
3266:  MOVWF  01
3268:  MOVF   x54,W
326A:  ADDWFC 03,F
326C:  MOVF   01,W
326E:  MOVLB  0
3270:  CALL   030A
3274:  MOVFF  FE8,851
....................            else kchar =newKEYS[row][col]; 
3278:  BRA    329E
327A:  MOVLB  8
327C:  MOVF   x52,W
327E:  MULLW  06
3280:  MOVF   FF3,W
3282:  CLRF   x54
3284:  MOVWF  x53
3286:  CLRF   03
3288:  MOVF   x50,W
328A:  ADDWF  x53,W
328C:  MOVWF  01
328E:  MOVF   x54,W
3290:  ADDWFC 03,F
3292:  MOVF   01,W
3294:  MOVLB  0
3296:  CALL   032E
329A:  MOVFF  FE8,851
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
329E:  MOVLB  1
32A0:  MOVF   x44,F
32A2:  BNZ   3326
....................             { 
....................               charac_timeout=0; 
32A4:  CLRF   x00
32A6:  MOVLB  0
32A8:  CLRF   xFF
....................                if(key_count_ms<wideofkeystore) 
32AA:  MOVLB  1
32AC:  MOVF   x47,W
32AE:  SUBLW  0F
32B0:  BNC   3324
....................                { 
....................                    key_data[key_count_ms++]=kchar; 
32B2:  MOVF   x47,W
32B4:  INCF   x47,F
32B6:  CLRF   03
32B8:  ADDLW  4A
32BA:  MOVWF  FE9
32BC:  MOVLW  01
32BE:  ADDWFC 03,W
32C0:  MOVWF  FEA
32C2:  MOVFF  851,FEF
....................                    fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
32C6:  MOVLW  56
32C8:  MOVWF  FF6
32CA:  MOVLW  05
32CC:  MOVWF  FF7
32CE:  MOVLW  09
32D0:  MOVLB  8
32D2:  MOVWF  xF7
32D4:  MOVLB  0
32D6:  CALL   164A
32DA:  MOVFF  147,859
32DE:  MOVLW  18
32E0:  MOVLB  8
32E2:  MOVWF  x5A
32E4:  MOVLB  0
32E6:  CALL   177A
32EA:  MOVLW  5D
32EC:  MOVLB  9
32EE:  MOVWF  x0C
32F0:  MOVLB  0
32F2:  CALL   1604
32F6:  MOVLW  20
32F8:  MOVLB  9
32FA:  MOVWF  x0C
32FC:  MOVLB  0
32FE:  CALL   1604
3302:  MOVFF  851,90C
3306:  CALL   1604
330A:  MOVLW  0D
330C:  MOVLB  9
330E:  MOVWF  x0C
3310:  MOVLB  0
3312:  CALL   1604
3316:  MOVLW  0A
3318:  MOVLB  9
331A:  MOVWF  x0C
331C:  MOVLB  0
331E:  CALL   1604
3322:  MOVLB  1
....................                } 
....................             } 
....................                else fputc(kchar,COM2); 
3324:  BRA    3332
3326:  MOVFF  851,90C
332A:  MOVLB  0
332C:  CALL   1604
3330:  MOVLB  1
3332:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3334:  BSF    F93.4
3336:  BTFSS  F81.4
3338:  BRA    3334
333A:  BSF    F93.5
333C:  BTFSS  F81.5
333E:  BRA    3334
3340:  BSF    F93.6
3342:  BTFSS  F81.6
3344:  BRA    3334
3346:  BSF    F93.7
3348:  BTFSS  F81.7
334A:  BRA    3334
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
334C:  BSF    F93.4
334E:  BTFSS  F81.4
3350:  BRA    334C
3352:  BSF    F93.5
3354:  BTFSS  F81.5
3356:  BRA    334C
3358:  BSF    F93.6
335A:  BTFSS  F81.6
335C:  BRA    334C
335E:  BSF    F93.7
3360:  BTFSS  F81.7
3362:  BRA    334C
....................     } 
....................   set_tris_a(0xff);     
3364:  MOVLW  FF
3366:  MOVWF  F92
....................   return(kchar); 
3368:  MOVFF  851,01
.................... }//*/ 
336C:  MOVLB  0
336E:  RETURN 0
....................  
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int8 i,tempdata; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
5476:  MOVF   27,F
5478:  BTFSS  FD8.2
547A:  BRA    5634
547C:  MOVF   26,W
547E:  SUBLW  01
5480:  BTFSS  FD8.0
5482:  BRA    5634
5484:  BNZ   5498
5486:  MOVF   25,W
5488:  SUBLW  FF
548A:  BTFSS  FD8.0
548C:  BRA    5634
548E:  BNZ   5498
5490:  MOVF   24,W
5492:  SUBLW  FE
5494:  BTFSS  FD8.0
5496:  BRA    5634
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
5498:  MOVLB  1
549A:  MOVF   x4A,F
549C:  BNZ   54A4
549E:  MOVF   x47,F
54A0:  BTFSC  FD8.2
54A2:  BRA    55E0
....................       { 
....................          temp=get_countcard(); 
54A4:  MOVLB  0
54A6:  CALL   351C
54AA:  MOVFF  02,853
54AE:  MOVFF  01,852
....................          //fprintf(COM2," get_countcard=%lu\n\r",temp); 
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
54B2:  MOVLB  8
54B4:  RLCF   x52,W
54B6:  MOVWF  x54
54B8:  RLCF   x53,W
54BA:  MOVWF  x55
54BC:  RLCF   x54,F
54BE:  RLCF   x55,F
54C0:  RLCF   x54,F
54C2:  RLCF   x55,F
54C4:  RLCF   x54,F
54C6:  RLCF   x55,F
54C8:  MOVLW  F0
54CA:  ANDWF  x54,F
54CC:  MOVLW  0E
54CE:  ADDWF  x54,F
54D0:  MOVLW  C3
54D2:  ADDWFC x55,F
54D4:  MOVLW  01
54D6:  MOVWF  x56
54D8:  BCF    FD8.2
54DA:  BTFSC  FD8.0
54DC:  INCF   x56,F
54DE:  CLRF   x57
54E0:  MOVLW  01
54E2:  ADDWF  x54,W
54E4:  MOVWF  00
54E6:  MOVLW  00
54E8:  ADDWFC x55,W
54EA:  MOVWF  01
54EC:  MOVLW  00
54EE:  ADDWFC x56,W
54F0:  MOVWF  02
54F2:  MOVLW  00
54F4:  ADDWFC x57,W
54F6:  MOVWF  27
54F8:  MOVFF  02,26
54FC:  MOVFF  01,25
5500:  MOVFF  00,24
....................          //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<wideofkeystore;i++) 
5504:  CLRF   x50
5506:  MOVF   x50,W
5508:  SUBLW  0F
550A:  BNC   5552
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
550C:  MOVF   x50,W
550E:  ADDWF  24,W
5510:  MOVWF  00
5512:  MOVLW  00
5514:  ADDWFC 25,W
5516:  MOVWF  01
5518:  MOVLW  00
551A:  ADDWFC 26,W
551C:  MOVWF  02
551E:  MOVLW  00
5520:  ADDWFC 27,W
5522:  MOVWF  03
5524:  MOVWF  x57
5526:  MOVFF  02,856
552A:  MOVFF  01,855
552E:  MOVFF  00,854
5532:  MOVFF  FE8,916
5536:  MOVFF  02,915
553A:  MOVFF  01,914
553E:  MOVFF  00,913
5542:  MOVLB  9
5544:  CLRF   x17
5546:  MOVLB  0
5548:  CALL   3A6C
....................          } 
554C:  MOVLB  8
554E:  INCF   x50,F
5550:  BRA    5506
....................          for(i=0;i<wideofkeystore;i++) 
5552:  CLRF   x50
5554:  MOVF   x50,W
5556:  SUBLW  0F
5558:  BNC   55C4
....................          { 
....................             tempdata=key_data[i]; 
555A:  CLRF   03
555C:  MOVF   x50,W
555E:  ADDLW  4A
5560:  MOVWF  FE9
5562:  MOVLW  01
5564:  ADDWFC 03,W
5566:  MOVWF  FEA
5568:  MOVFF  FEF,851
....................             write_ext_eeprom((int32)ptr_card_key++,tempdata); 
556C:  MOVFF  27,03
5570:  MOVFF  26,02
5574:  MOVFF  25,01
5578:  MOVFF  24,00
557C:  MOVLW  01
557E:  ADDWF  24,F
5580:  BTFSC  FD8.0
5582:  INCF   25,F
5584:  BTFSC  FD8.2
5586:  INCF   26,F
5588:  BTFSC  FD8.2
558A:  INCF   27,F
558C:  MOVFF  03,857
5590:  MOVFF  02,856
5594:  MOVFF  01,855
5598:  MOVFF  00,854
559C:  MOVFF  03,916
55A0:  MOVFF  02,915
55A4:  MOVFF  01,914
55A8:  MOVFF  00,913
55AC:  MOVFF  851,917
55B0:  MOVLB  0
55B2:  CALL   3A6C
....................             //delay_us(100); 
....................             fprintf(COM2,"%c",tempdata); 
55B6:  MOVFF  851,90C
55BA:  CALL   1604
....................          } 
55BE:  MOVLB  8
55C0:  INCF   x50,F
55C2:  BRA    5554
....................           //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................           /*fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<wideofkeystore;i++) 
....................           { 
....................             fprintf(COM2,"%c",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
55C4:  MOVFF  27,8FA
55C8:  MOVFF  26,8F9
55CC:  MOVFF  25,8F8
55D0:  MOVFF  24,8F7
55D4:  MOVLW  1E
55D6:  MOVWF  xFB
55D8:  MOVLB  0
55DA:  CALL   3B6A
55DE:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
55E0:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
55E2:  MOVLW  01
55E4:  MOVWF  FEA
55E6:  MOVLW  4A
55E8:  MOVWF  FE9
55EA:  CLRF   00
55EC:  CLRF   02
55EE:  MOVLW  10
55F0:  MOVWF  01
55F2:  MOVLB  0
55F4:  CALL   359A
....................       fprintf(COM2,"\r\n"); 
55F8:  MOVLW  0D
55FA:  MOVLB  9
55FC:  MOVWF  x0C
55FE:  MOVLB  0
5600:  CALL   1604
5604:  MOVLW  0A
5606:  MOVLB  9
5608:  MOVWF  x0C
560A:  MOVLB  0
560C:  CALL   1604
....................       fprintf(COM2,"Done save_key_new"); 
5610:  MOVLW  68
5612:  MOVWF  FF6
5614:  MOVLW  05
5616:  MOVWF  FF7
5618:  CALL   172E
....................       fprintf(COM2,"\r\n"); 
561C:  MOVLW  0D
561E:  MOVLB  9
5620:  MOVWF  x0C
5622:  MOVLB  0
5624:  CALL   1604
5628:  MOVLW  0A
562A:  MOVLB  9
562C:  MOVWF  x0C
562E:  MOVLB  0
5630:  CALL   1604
....................    } 
.................... } 
5634:  GOTO   5B78 (RETURN)
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 recEn[wideofkeystore]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
5638:  MOVF   27,F
563A:  BTFSS  FD8.2
563C:  BRA    58AC
563E:  MOVF   26,W
5640:  SUBLW  01
5642:  BTFSS  FD8.0
5644:  BRA    58AC
5646:  BNZ   565A
5648:  MOVF   25,W
564A:  SUBLW  FF
564C:  BTFSS  FD8.0
564E:  BRA    58AC
5650:  BNZ   565A
5652:  MOVF   24,W
5654:  SUBLW  FE
5656:  BTFSS  FD8.0
5658:  BRA    58AC
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
565A:  MOVLB  1
565C:  MOVF   x4A,F
565E:  BNZ   5666
5660:  MOVF   x47,F
5662:  BTFSC  FD8.2
5664:  BRA    5858
....................       {    
....................          for(i=0;i<key_numbyte;i++) 
5666:  MOVLB  8
5668:  CLRF   x50
566A:  MOVF   x50,W
566C:  SUBLW  0B
566E:  BNC   56C2
....................          { 
....................             temp=key_data[i]; 
5670:  CLRF   03
5672:  MOVF   x50,W
5674:  ADDLW  4A
5676:  MOVWF  FE9
5678:  MOVLW  01
567A:  ADDWFC 03,W
567C:  MOVWF  FEA
567E:  CLRF   x52
5680:  MOVFF  FEF,851
....................             fputc(temp,COM2); 
5684:  MOVFF  851,90C
5688:  MOVLB  0
568A:  CALL   1604
....................             recEn[i]=key_data[i]; 
568E:  CLRF   03
5690:  MOVLB  8
5692:  MOVF   x50,W
5694:  ADDLW  54
5696:  MOVWF  01
5698:  MOVLW  08
569A:  ADDWFC 03,F
569C:  MOVFF  03,865
56A0:  CLRF   03
56A2:  MOVF   x50,W
56A4:  ADDLW  4A
56A6:  MOVWF  FE9
56A8:  MOVLW  01
56AA:  ADDWFC 03,W
56AC:  MOVWF  FEA
56AE:  MOVFF  FEF,866
56B2:  MOVFF  865,FEA
56B6:  MOVFF  01,FE9
56BA:  MOVFF  866,FEF
....................          } 
56BE:  INCF   x50,F
56C0:  BRA    566A
....................          recEn[key_numbyte] = 0; 
56C2:  CLRF   x60
....................          recEn[key_numbyte+1] = 0;          
56C4:  CLRF   x61
....................          recEn[key_numbyte+2] = 0;          
56C6:  CLRF   x62
....................          recEn[key_numbyte+3] = 0; 
56C8:  CLRF   x63
....................     #if 0 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"test_key:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"\n\rdatain:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2," %x",recEn[i]); 
....................          fprintf(COM2,"\n\r"); 
....................     #endif 
....................          EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
56CA:  MOVLB  9
56CC:  CLRF   x07
56CE:  CLRF   x06
56D0:  CLRF   x05
56D2:  MOVLW  3F
56D4:  MOVWF  x04
56D6:  CLRF   x0B
56D8:  CLRF   x0A
56DA:  CLRF   x09
56DC:  MOVLW  20
56DE:  MOVWF  x08
56E0:  MOVLW  01
56E2:  MOVWF  x0D
56E4:  MOVWF  x0C
56E6:  MOVLB  0
56E8:  CALL   4004
....................          aes_enc_dec((unsigned int8 *)&recEn[0], (unsigned int8 *)&crypto_key[0],0); 
56EC:  MOVLW  08
56EE:  MOVLB  8
56F0:  MOVWF  xF8
56F2:  MOVLW  54
56F4:  MOVWF  xF7
56F6:  MOVLW  01
56F8:  MOVWF  xFA
56FA:  MOVWF  xF9
56FC:  CLRF   xFB
56FE:  MOVLB  0
5700:  CALL   40FA
....................          //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................           
....................          /* get the pointer of keyboard data */ 
....................          temp=get_countcard(); 
5704:  CALL   351C
5708:  MOVFF  02,852
570C:  MOVFF  01,851
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
5710:  MOVLB  8
5712:  RLCF   x51,W
5714:  MOVWF  x64
5716:  RLCF   x52,W
5718:  MOVWF  x65
571A:  RLCF   x64,F
571C:  RLCF   x65,F
571E:  RLCF   x64,F
5720:  RLCF   x65,F
5722:  RLCF   x64,F
5724:  RLCF   x65,F
5726:  MOVLW  F0
5728:  ANDWF  x64,F
572A:  MOVLW  0E
572C:  ADDWF  x64,F
572E:  MOVLW  C3
5730:  ADDWFC x65,F
5732:  MOVLW  01
5734:  MOVWF  x66
5736:  BCF    FD8.2
5738:  BTFSC  FD8.0
573A:  INCF   x66,F
573C:  CLRF   x67
573E:  MOVLW  01
5740:  ADDWF  x64,W
5742:  MOVWF  00
5744:  MOVLW  00
5746:  ADDWFC x65,W
5748:  MOVWF  01
574A:  MOVLW  00
574C:  ADDWFC x66,W
574E:  MOVWF  02
5750:  MOVLW  00
5752:  ADDWFC x67,W
5754:  MOVWF  27
5756:  MOVFF  02,26
575A:  MOVFF  01,25
575E:  MOVFF  00,24
....................          /* delete the old data of key store area  */ 
....................          //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<wideofkeystore;i++) 
5762:  CLRF   x50
5764:  MOVF   x50,W
5766:  SUBLW  0F
5768:  BNC   57B0
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
576A:  MOVF   x50,W
576C:  ADDWF  24,W
576E:  MOVWF  00
5770:  MOVLW  00
5772:  ADDWFC 25,W
5774:  MOVWF  01
5776:  MOVLW  00
5778:  ADDWFC 26,W
577A:  MOVWF  02
577C:  MOVLW  00
577E:  ADDWFC 27,W
5780:  MOVWF  03
5782:  MOVWF  x67
5784:  MOVFF  02,866
5788:  MOVFF  01,865
578C:  MOVFF  00,864
5790:  MOVFF  FE8,916
5794:  MOVFF  02,915
5798:  MOVFF  01,914
579C:  MOVFF  00,913
57A0:  MOVLB  9
57A2:  CLRF   x17
57A4:  MOVLB  0
57A6:  CALL   3A6C
....................          } 
57AA:  MOVLB  8
57AC:  INCF   x50,F
57AE:  BRA    5764
....................          fprintf(COM2,"\n\r"); 
57B0:  MOVLW  0A
57B2:  MOVLB  9
57B4:  MOVWF  x0C
57B6:  MOVLB  0
57B8:  CALL   1604
57BC:  MOVLW  0D
57BE:  MOVLB  9
57C0:  MOVWF  x0C
57C2:  MOVLB  0
57C4:  CALL   1604
....................          for(i=0;i<wideofkeystore;i++) fprintf(COM2,"%x",recEn[i]); 
57C8:  MOVLB  8
57CA:  CLRF   x50
57CC:  MOVF   x50,W
57CE:  SUBLW  0F
57D0:  BNC   57FA
57D2:  CLRF   03
57D4:  MOVF   x50,W
57D6:  ADDLW  54
57D8:  MOVWF  FE9
57DA:  MOVLW  08
57DC:  ADDWFC 03,W
57DE:  MOVWF  FEA
57E0:  MOVFF  FEF,864
57E4:  MOVFF  864,901
57E8:  MOVLW  57
57EA:  MOVLB  9
57EC:  MOVWF  x02
57EE:  MOVLB  0
57F0:  CALL   4F86
57F4:  MOVLB  8
57F6:  INCF   x50,F
57F8:  BRA    57CC
....................          retval = EEPROM_write(ptr_card_key,wideofkeystore,recEn);  
57FA:  MOVFF  27,903
57FE:  MOVFF  26,902
5802:  MOVFF  25,901
5806:  MOVFF  24,900
580A:  MOVLB  9
580C:  CLRF   x07
580E:  CLRF   x06
5810:  CLRF   x05
5812:  MOVLW  10
5814:  MOVWF  x04
5816:  MOVLW  08
5818:  MOVWF  x09
581A:  MOVLW  54
581C:  MOVWF  x08
581E:  MOVLB  0
5820:  CALL   4EF6
5824:  MOVFF  01,853
....................          if(retval!=0) 
5828:  MOVLB  8
582A:  MOVF   x53,F
582C:  BZ    5856
....................          { 
....................             ptr_card_key+=wideofkeystore; 
582E:  MOVLW  10
5830:  ADDWF  24,F
5832:  MOVLW  00
5834:  ADDWFC 25,F
5836:  ADDWFC 26,F
5838:  ADDWFC 27,F
....................             save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
583A:  MOVFF  27,8FA
583E:  MOVFF  26,8F9
5842:  MOVFF  25,8F8
5846:  MOVFF  24,8F7
584A:  MOVLW  1E
584C:  MOVWF  xFB
584E:  MOVLB  0
5850:  CALL   3B6A
5854:  MOVLB  8
5856:  MOVLB  1
....................          }          
....................       } 
....................       key_count_ms=0; 
5858:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
585A:  MOVLW  01
585C:  MOVWF  FEA
585E:  MOVLW  4A
5860:  MOVWF  FE9
5862:  CLRF   00
5864:  CLRF   02
5866:  MOVLW  10
5868:  MOVWF  01
586A:  MOVLB  0
586C:  CALL   359A
....................       fprintf(COM2,"\r\n"); 
5870:  MOVLW  0D
5872:  MOVLB  9
5874:  MOVWF  x0C
5876:  MOVLB  0
5878:  CALL   1604
587C:  MOVLW  0A
587E:  MOVLB  9
5880:  MOVWF  x0C
5882:  MOVLB  0
5884:  CALL   1604
....................       fprintf(COM2,"Done Encrypted PIN"); 
5888:  MOVLW  7A
588A:  MOVWF  FF6
588C:  MOVLW  05
588E:  MOVWF  FF7
5890:  CALL   172E
....................       fprintf(COM2,"\r\n"); 
5894:  MOVLW  0D
5896:  MOVLB  9
5898:  MOVWF  x0C
589A:  MOVLB  0
589C:  CALL   1604
58A0:  MOVLW  0A
58A2:  MOVLB  9
58A4:  MOVWF  x0C
58A6:  MOVLB  0
58A8:  CALL   1604
....................    } 
.................... } 
58AC:  GOTO   5B80 (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
5F94:  MOVLB  7
5F96:  CLRF   xFA
5F98:  CLRF   xF9
5F9A:  CLRF   xFB
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
5F9C:  MOVF   xFA,F
5F9E:  BTFSS  FD8.2
5FA0:  BRA    60C4
5FA2:  MOVF   xF4,W
5FA4:  SUBWF  xF9,W
5FA6:  BTFSC  FD8.0
5FA8:  BRA    60C4
5FAA:  MOVF   xFB,F
5FAC:  BTFSS  FD8.2
5FAE:  BRA    60C4
....................       c = fgetc(COM2);//getc(); 
5FB0:  MOVLB  0
5FB2:  RCALL  5F46
5FB4:  MOVFF  01,7F7
....................       switch(c) 
....................       { 
5FB8:  MOVLB  7
5FBA:  MOVF   xF7,W
5FBC:  XORLW  7F
5FBE:  MOVLB  0
5FC0:  BZ    5FC8
5FC2:  XORLW  72
5FC4:  BZ    6016
5FC6:  BRA    6054
....................          case 0x7f:    
....................             if(nbcar>0)   
5FC8:  MOVLB  7
5FCA:  MOVF   xF9,F
5FCC:  BNZ   5FD2
5FCE:  MOVF   xFA,F
5FD0:  BZ    5FFC
5FD2:  CLRF   19
5FD4:  BTFSC  FF2.7
5FD6:  BSF    19.7
5FD8:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
5FDA:  MOVLW  7F
5FDC:  MOVLB  9
5FDE:  MOVWF  x0C
5FE0:  MOVLB  0
5FE2:  CALL   1604
5FE6:  BTFSC  19.7
5FE8:  BSF    FF2.7
....................                nbcar--; 
5FEA:  MOVLB  7
5FEC:  MOVF   xF9,W
5FEE:  BTFSC  FD8.2
5FF0:  DECF   xFA,F
5FF2:  DECF   xF9,F
....................                fgetc(COM2);//getc(); 
5FF4:  MOVLB  0
5FF6:  RCALL  5F46
....................             } 
....................             else fputc(0x07,COM2);    
5FF8:  BRA    6014
5FFA:  MOVLB  7
5FFC:  CLRF   19
5FFE:  BTFSC  FF2.7
6000:  BSF    19.7
6002:  BCF    FF2.7
6004:  MOVLW  07
6006:  MOVLB  9
6008:  MOVWF  x0C
600A:  MOVLB  0
600C:  CALL   1604
6010:  BTFSC  19.7
6012:  BSF    FF2.7
....................          break;  
6014:  BRA    60C0
....................          case 0x0D:   
....................                keydebug_en=0; 
6016:  MOVLB  1
6018:  CLRF   x44
....................                set_tris_a(0xff); 
601A:  MOVLW  FF
601C:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
601E:  MOVFF  7F9,7F8
6022:  MOVLB  7
6024:  MOVF   xF4,W
6026:  SUBWF  xF8,W
6028:  BC    603E
....................                { 
....................                  chaine[i]=0; 
602A:  CLRF   03
602C:  MOVF   xF8,W
602E:  ADDWF  xF5,W
6030:  MOVWF  FE9
6032:  MOVF   xF6,W
6034:  ADDWFC 03,W
6036:  MOVWF  FEA
6038:  CLRF   FEF
....................                } 
603A:  INCF   xF8,F
603C:  BRA    6024
....................                if(nbcar==0)return(FAUX); 
603E:  MOVF   xF9,F
6040:  BNZ   604C
6042:  MOVF   xFA,F
6044:  BNZ   604C
6046:  MOVLW  00
6048:  MOVWF  01
604A:  BRA    60C8
....................                fini=VRAI; 
604C:  MOVLW  01
604E:  MOVWF  xFB
....................          break; 
6050:  MOVLB  0
6052:  BRA    60C0
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
6054:  MOVLB  7
6056:  MOVF   xF7,W
6058:  SUBLW  1F
605A:  BC    60C2
605C:  MOVF   xF7,W
605E:  SUBLW  7E
6060:  BNC   60C2
6062:  MOVLW  01
6064:  SUBWF  xF4,W
6066:  MOVF   xFA,F
6068:  BNZ   60C2
606A:  SUBWF  xF9,W
606C:  BC    60C2
....................             { 
....................                chaine[nbcar]=c; 
606E:  MOVF   xF5,W
6070:  ADDWF  xF9,W
6072:  MOVWF  FE9
6074:  MOVF   xF6,W
6076:  ADDWFC xFA,W
6078:  MOVWF  FEA
607A:  MOVFF  7F7,FEF
....................                nbcar++; 
607E:  INCF   xF9,F
6080:  BTFSC  FD8.2
6082:  INCF   xFA,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
6084:  DECFSZ xF3,W
6086:  BRA    60A2
6088:  CLRF   19
608A:  BTFSC  FF2.7
608C:  BSF    19.7
608E:  BCF    FF2.7
6090:  MOVFF  7F7,90C
6094:  MOVLB  0
6096:  CALL   1604
609A:  BTFSC  19.7
609C:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
609E:  BRA    60C0
60A0:  MOVLB  7
60A2:  MOVF   xF3,W
60A4:  SUBLW  02
60A6:  BNZ   60C2
60A8:  CLRF   19
60AA:  BTFSC  FF2.7
60AC:  BSF    19.7
60AE:  BCF    FF2.7
60B0:  MOVLW  2A
60B2:  MOVLB  9
60B4:  MOVWF  x0C
60B6:  MOVLB  0
60B8:  CALL   1604
60BC:  BTFSC  19.7
60BE:  BSF    FF2.7
60C0:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
60C2:  BRA    5F9C
....................    return(nbcar); 
60C4:  MOVFF  7F9,01
.................... } 
60C8:  MOVLB  0
60CA:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
60CC:  MOVFF  7F4,7F8
60D0:  MOVFF  7F3,7F7
60D4:  MOVFF  7F6,7FA
60D8:  MOVFF  7F5,7F9
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
60DC:  MOVFF  7F8,03
60E0:  MOVLB  7
60E2:  MOVFF  7F7,FE9
60E6:  MOVFF  7F8,FEA
60EA:  MOVF   FEF,F
60EC:  BZ    6134
60EE:  MOVFF  7FA,03
60F2:  MOVFF  7F9,FE9
60F6:  MOVFF  7FA,FEA
60FA:  MOVF   FEF,F
60FC:  BZ    6134
....................       if(*aa!=*bb) 
60FE:  MOVFF  7F7,FE9
6102:  MOVFF  7F8,FEA
6106:  MOVFF  FEF,7FB
610A:  MOVFF  7FA,03
610E:  MOVFF  7F9,FE9
6112:  MOVFF  7FA,FEA
6116:  MOVF   FEF,W
6118:  SUBWF  xFB,W
611A:  BZ    6122
....................          return(1); 
611C:  MOVLW  01
611E:  MOVWF  01
6120:  BRA    6160
....................       aa++; 
6122:  INCF   xF7,F
6124:  BTFSC  FD8.2
6126:  INCF   xF8,F
....................       bb++; 
6128:  INCF   xF9,F
612A:  BTFSC  FD8.2
612C:  INCF   xFA,F
....................    } 
612E:  MOVLB  0
6130:  BRA    60DC
6132:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
6134:  MOVFF  7F8,03
6138:  MOVFF  7F7,FE9
613C:  MOVFF  7F8,FEA
6140:  MOVFF  FEF,7FB
6144:  MOVFF  7FA,03
6148:  MOVFF  7F9,FE9
614C:  MOVFF  7FA,FEA
6150:  MOVF   FEF,W
6152:  SUBWF  xFB,W
6154:  BZ    615C
6156:  MOVLW  01
6158:  MOVWF  01
615A:  BRA    6160
....................    return(0); 
615C:  MOVLW  00
615E:  MOVWF  01
.................... } 
6160:  MOVLB  0
6162:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
6B3C:  MOVLB  7
6B3E:  CLRF   xF5
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
6B40:  MOVFF  7F4,03
6B44:  MOVF   xF3,W
6B46:  INCF   xF3,F
6B48:  BTFSC  FD8.2
6B4A:  INCF   xF4,F
6B4C:  MOVWF  FE9
6B4E:  MOVFF  03,FEA
6B52:  MOVFF  FEF,7F7
6B56:  MOVF   xF7,F
6B58:  BZ    6B7C
....................         if (c >= '0' && c <= '9') 
6B5A:  MOVF   xF7,W
6B5C:  SUBLW  2F
6B5E:  BC    6B6E
6B60:  MOVF   xF7,W
6B62:  SUBLW  39
6B64:  BNC   6B6E
....................             digit = (unsigned int) (c - '0'); 
6B66:  MOVLW  30
6B68:  SUBWF  xF7,W
6B6A:  MOVWF  xF6
....................         else 
6B6C:  BRA    6B70
....................             break; 
6B6E:  BRA    6B7C
....................  
....................         val = (val * 10) + digit; 
6B70:  MOVF   xF5,W
6B72:  MULLW  0A
6B74:  MOVF   FF3,W
6B76:  ADDWF  xF6,W
6B78:  MOVWF  xF5
....................     } 
6B7A:  BRA    6B40
....................  
....................     return val; 
6B7C:  CLRF   03
6B7E:  MOVFF  7F5,01
6B82:  MOVFF  03,02
.................... } 
6B86:  MOVLB  0
6B88:  RETURN 0
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
06AC:  MOVLB  9
06AE:  CLRF   x3F
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
06B0:  CLRF   x40
06B2:  BTFSC  x37.0
06B4:  BSF    x40.7
06B6:  SWAPF  x38,W
06B8:  MOVWF  00
06BA:  RLCF   00,F
06BC:  RLCF   00,F
06BE:  MOVLW  C0
06C0:  ANDWF  00,F
06C2:  MOVF   00,W
06C4:  IORWF  x40,F
06C6:  SWAPF  x39,W
06C8:  MOVWF  00
06CA:  RLCF   00,F
06CC:  MOVLW  E0
06CE:  ANDWF  00,F
06D0:  MOVF   00,W
06D2:  IORWF  x40,F
06D4:  SWAPF  x3A,W
06D6:  MOVWF  00
06D8:  MOVLW  F0
06DA:  ANDWF  00,F
06DC:  MOVF   00,W
06DE:  IORWF  x40,F
06E0:  RLCF   x3B,W
06E2:  MOVWF  00
06E4:  RLCF   00,F
06E6:  RLCF   00,F
06E8:  MOVLW  F8
06EA:  ANDWF  00,F
06EC:  MOVF   00,W
06EE:  IORWF  x40,F
06F0:  RLCF   x3C,W
06F2:  MOVWF  00
06F4:  RLCF   00,F
06F6:  MOVLW  FC
06F8:  ANDWF  00,F
06FA:  MOVF   00,W
06FC:  IORWF  x40,F
06FE:  BCF    FD8.0
0700:  RLCF   x3D,W
0702:  IORWF  x40,F
0704:  MOVF   x3E,W
0706:  IORWF  x40,W
0708:  MOVWF  x3F
....................    return temp; 
070A:  MOVFF  93F,01
.................... } 
070E:  MOVLB  0
0710:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0712:  MOVLB  9
0714:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
0716:  MOVF   x22,F
0718:  BNZ   07EE
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
071A:  MOVF   x25,W
071C:  ADDWF  x23,W
071E:  MOVWF  FE9
0720:  MOVF   x26,W
0722:  ADDWFC x24,W
0724:  MOVWF  FEA
0726:  MOVFF  FEF,928
072A:  MOVLW  01
072C:  ADDWF  x23,W
072E:  MOVWF  x29
0730:  MOVLW  00
0732:  ADDWFC x24,W
0734:  MOVWF  x2A
0736:  MOVF   x25,W
0738:  ADDWF  x29,W
073A:  MOVWF  FE9
073C:  MOVF   x26,W
073E:  ADDWFC x2A,W
0740:  MOVWF  FEA
0742:  MOVF   FEF,W
0744:  XORWF  x28,F
0746:  MOVLW  02
0748:  ADDWF  x23,W
074A:  MOVWF  x2B
074C:  MOVLW  00
074E:  ADDWFC x24,W
0750:  MOVWF  x2C
0752:  MOVF   x25,W
0754:  ADDWF  x2B,W
0756:  MOVWF  FE9
0758:  MOVF   x26,W
075A:  ADDWFC x2C,W
075C:  MOVWF  FEA
075E:  MOVF   FEF,W
0760:  XORWF  x28,F
0762:  MOVLW  03
0764:  ADDWF  x23,W
0766:  MOVWF  x2D
0768:  MOVLW  00
076A:  ADDWFC x24,W
076C:  MOVWF  x2E
076E:  MOVF   x25,W
0770:  ADDWF  x2D,W
0772:  MOVWF  FE9
0774:  MOVF   x26,W
0776:  ADDWFC x2E,W
0778:  MOVWF  FEA
077A:  MOVF   FEF,W
077C:  XORWF  x28,F
077E:  MOVLW  04
0780:  ADDWF  x23,W
0782:  MOVWF  x2F
0784:  MOVLW  00
0786:  ADDWFC x24,W
0788:  MOVWF  x30
078A:  MOVF   x25,W
078C:  ADDWF  x2F,W
078E:  MOVWF  FE9
0790:  MOVF   x26,W
0792:  ADDWFC x30,W
0794:  MOVWF  FEA
0796:  MOVF   FEF,W
0798:  XORWF  x28,F
079A:  MOVLW  05
079C:  ADDWF  x23,W
079E:  MOVWF  x31
07A0:  MOVLW  00
07A2:  ADDWFC x24,W
07A4:  MOVWF  x32
07A6:  MOVF   x25,W
07A8:  ADDWF  x31,W
07AA:  MOVWF  FE9
07AC:  MOVF   x26,W
07AE:  ADDWFC x32,W
07B0:  MOVWF  FEA
07B2:  MOVF   FEF,W
07B4:  XORWF  x28,W
07B6:  BZ    07BC
07B8:  MOVLW  00
07BA:  BRA    07BE
07BC:  MOVLW  01
07BE:  MOVWF  x27
....................       if(temp==datain[offset+6]) return 1; 
07C0:  MOVLW  06
07C2:  ADDWF  x23,W
07C4:  MOVWF  x28
07C6:  MOVLW  00
07C8:  ADDWFC x24,W
07CA:  MOVWF  x29
07CC:  MOVF   x25,W
07CE:  ADDWF  x28,W
07D0:  MOVWF  FE9
07D2:  MOVF   x26,W
07D4:  ADDWFC x29,W
07D6:  MOVWF  FEA
07D8:  MOVF   FEF,W
07DA:  SUBWF  x27,W
07DC:  BNZ   07E6
07DE:  MOVLW  01
07E0:  MOVWF  01
07E2:  BRA    08BE
....................          else return 0; 
07E4:  BRA    07EC
07E6:  MOVLW  00
07E8:  MOVWF  01
07EA:  BRA    08BE
....................    } 
....................       else  
07EC:  BRA    08BE
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
07EE:  MOVF   x25,W
07F0:  ADDWF  x23,W
07F2:  MOVWF  FE9
07F4:  MOVF   x26,W
07F6:  ADDWFC x24,W
07F8:  MOVWF  FEA
07FA:  MOVFF  FEF,928
07FE:  MOVLW  01
0800:  SUBWF  x23,W
0802:  MOVWF  x29
0804:  MOVLW  00
0806:  SUBWFB x24,W
0808:  MOVWF  x2A
080A:  MOVF   x25,W
080C:  ADDWF  x29,W
080E:  MOVWF  FE9
0810:  MOVF   x26,W
0812:  ADDWFC x2A,W
0814:  MOVWF  FEA
0816:  MOVF   FEF,W
0818:  XORWF  x28,F
081A:  MOVLW  02
081C:  SUBWF  x23,W
081E:  MOVWF  x2B
0820:  MOVLW  00
0822:  SUBWFB x24,W
0824:  MOVWF  x2C
0826:  MOVF   x25,W
0828:  ADDWF  x2B,W
082A:  MOVWF  FE9
082C:  MOVF   x26,W
082E:  ADDWFC x2C,W
0830:  MOVWF  FEA
0832:  MOVF   FEF,W
0834:  XORWF  x28,F
0836:  MOVLW  03
0838:  SUBWF  x23,W
083A:  MOVWF  x2D
083C:  MOVLW  00
083E:  SUBWFB x24,W
0840:  MOVWF  x2E
0842:  MOVF   x25,W
0844:  ADDWF  x2D,W
0846:  MOVWF  FE9
0848:  MOVF   x26,W
084A:  ADDWFC x2E,W
084C:  MOVWF  FEA
084E:  MOVF   FEF,W
0850:  XORWF  x28,F
0852:  MOVLW  04
0854:  SUBWF  x23,W
0856:  MOVWF  x2F
0858:  MOVLW  00
085A:  SUBWFB x24,W
085C:  MOVWF  x30
085E:  MOVF   x25,W
0860:  ADDWF  x2F,W
0862:  MOVWF  FE9
0864:  MOVF   x26,W
0866:  ADDWFC x30,W
0868:  MOVWF  FEA
086A:  MOVF   FEF,W
086C:  XORWF  x28,F
086E:  MOVLW  05
0870:  SUBWF  x23,W
0872:  MOVWF  x31
0874:  MOVLW  00
0876:  SUBWFB x24,W
0878:  MOVWF  x32
087A:  MOVF   x25,W
087C:  ADDWF  x31,W
087E:  MOVWF  FE9
0880:  MOVF   x26,W
0882:  ADDWFC x32,W
0884:  MOVWF  FEA
0886:  MOVF   FEF,W
0888:  XORWF  x28,W
088A:  BZ    0890
088C:  MOVLW  00
088E:  BRA    0892
0890:  MOVLW  01
0892:  MOVWF  x27
....................          if(temp==datain[offset-6]) return 1; 
0894:  MOVLW  06
0896:  SUBWF  x23,W
0898:  MOVWF  x28
089A:  MOVLW  00
089C:  SUBWFB x24,W
089E:  MOVWF  x29
08A0:  MOVF   x25,W
08A2:  ADDWF  x28,W
08A4:  MOVWF  FE9
08A6:  MOVF   x26,W
08A8:  ADDWFC x29,W
08AA:  MOVWF  FEA
08AC:  MOVF   FEF,W
08AE:  SUBWF  x27,W
08B0:  BNZ   08BA
08B2:  MOVLW  01
08B4:  MOVWF  01
08B6:  BRA    08BE
....................             else return 0;          
08B8:  BRA    08BE
08BA:  MOVLW  00
08BC:  MOVWF  01
....................       } 
.................... } 
08BE:  MOVLB  0
08C0:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
08C2:  MOVLB  9
08C4:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
08C6:  MOVF   x22,F
08C8:  BNZ   0966
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
08CA:  MOVF   x25,W
08CC:  ADDWF  x23,W
08CE:  MOVWF  FE9
08D0:  MOVF   x26,W
08D2:  ADDWFC x24,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEF,928
08DA:  MOVLW  01
08DC:  ADDWF  x23,W
08DE:  MOVWF  x29
08E0:  MOVLW  00
08E2:  ADDWFC x24,W
08E4:  MOVWF  x2A
08E6:  MOVF   x25,W
08E8:  ADDWF  x29,W
08EA:  MOVWF  FE9
08EC:  MOVF   x26,W
08EE:  ADDWFC x2A,W
08F0:  MOVWF  FEA
08F2:  MOVF   FEF,W
08F4:  XORWF  x28,F
08F6:  MOVLW  02
08F8:  ADDWF  x23,W
08FA:  MOVWF  x2B
08FC:  MOVLW  00
08FE:  ADDWFC x24,W
0900:  MOVWF  x2C
0902:  MOVF   x25,W
0904:  ADDWF  x2B,W
0906:  MOVWF  FE9
0908:  MOVF   x26,W
090A:  ADDWFC x2C,W
090C:  MOVWF  FEA
090E:  MOVF   FEF,W
0910:  XORWF  x28,F
0912:  MOVLW  03
0914:  ADDWF  x23,W
0916:  MOVWF  x2D
0918:  MOVLW  00
091A:  ADDWFC x24,W
091C:  MOVWF  x2E
091E:  MOVF   x25,W
0920:  ADDWF  x2D,W
0922:  MOVWF  FE9
0924:  MOVF   x26,W
0926:  ADDWFC x2E,W
0928:  MOVWF  FEA
092A:  MOVF   FEF,W
092C:  XORWF  x28,W
092E:  BZ    0934
0930:  MOVLW  00
0932:  BRA    0936
0934:  MOVLW  01
0936:  MOVWF  x27
....................       if(temp==datain[offset+4]) return 1; 
0938:  MOVLW  04
093A:  ADDWF  x23,W
093C:  MOVWF  x28
093E:  MOVLW  00
0940:  ADDWFC x24,W
0942:  MOVWF  x29
0944:  MOVF   x25,W
0946:  ADDWF  x28,W
0948:  MOVWF  FE9
094A:  MOVF   x26,W
094C:  ADDWFC x29,W
094E:  MOVWF  FEA
0950:  MOVF   FEF,W
0952:  SUBWF  x27,W
0954:  BNZ   095E
0956:  MOVLW  01
0958:  MOVWF  01
095A:  BRA    09FE
....................          else return 0; 
095C:  BRA    0964
095E:  MOVLW  00
0960:  MOVWF  01
0962:  BRA    09FE
....................    } 
....................    else 
0964:  BRA    09FE
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0966:  MOVF   x25,W
0968:  ADDWF  x23,W
096A:  MOVWF  FE9
096C:  MOVF   x26,W
096E:  ADDWFC x24,W
0970:  MOVWF  FEA
0972:  MOVFF  FEF,928
0976:  MOVLW  01
0978:  SUBWF  x23,W
097A:  MOVWF  x29
097C:  MOVLW  00
097E:  SUBWFB x24,W
0980:  MOVWF  x2A
0982:  MOVF   x25,W
0984:  ADDWF  x29,W
0986:  MOVWF  FE9
0988:  MOVF   x26,W
098A:  ADDWFC x2A,W
098C:  MOVWF  FEA
098E:  MOVF   FEF,W
0990:  XORWF  x28,F
0992:  MOVLW  02
0994:  SUBWF  x23,W
0996:  MOVWF  x2B
0998:  MOVLW  00
099A:  SUBWFB x24,W
099C:  MOVWF  x2C
099E:  MOVF   x25,W
09A0:  ADDWF  x2B,W
09A2:  MOVWF  FE9
09A4:  MOVF   x26,W
09A6:  ADDWFC x2C,W
09A8:  MOVWF  FEA
09AA:  MOVF   FEF,W
09AC:  XORWF  x28,F
09AE:  MOVLW  03
09B0:  SUBWF  x23,W
09B2:  MOVWF  x2D
09B4:  MOVLW  00
09B6:  SUBWFB x24,W
09B8:  MOVWF  x2E
09BA:  MOVF   x25,W
09BC:  ADDWF  x2D,W
09BE:  MOVWF  FE9
09C0:  MOVF   x26,W
09C2:  ADDWFC x2E,W
09C4:  MOVWF  FEA
09C6:  MOVF   FEF,W
09C8:  XORWF  x28,W
09CA:  BZ    09D0
09CC:  MOVLW  00
09CE:  BRA    09D2
09D0:  MOVLW  01
09D2:  MOVWF  x27
....................       if(temp==datain[offset-4]) return 1; 
09D4:  MOVLW  04
09D6:  SUBWF  x23,W
09D8:  MOVWF  x28
09DA:  MOVLW  00
09DC:  SUBWFB x24,W
09DE:  MOVWF  x29
09E0:  MOVF   x25,W
09E2:  ADDWF  x28,W
09E4:  MOVWF  FE9
09E6:  MOVF   x26,W
09E8:  ADDWFC x29,W
09EA:  MOVWF  FEA
09EC:  MOVF   FEF,W
09EE:  SUBWF  x27,W
09F0:  BNZ   09FA
09F2:  MOVLW  01
09F4:  MOVWF  01
09F6:  BRA    09FE
....................          else return 0;                
09F8:  BRA    09FE
09FA:  MOVLW  00
09FC:  MOVWF  01
....................    } 
.................... } 
09FE:  MOVLB  0
0A00:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0A02:  MOVLB  9
0A04:  CLRF   x1E
0A06:  CLRF   x1F
0A08:  CLRF   x20
0A0A:  CLRF   x21
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0A0C:  CLRF   x1B
0A0E:  CLRF   x1A
0A10:  RRCF   x17,W
0A12:  MOVWF  03
0A14:  RRCF   x16,W
0A16:  MOVWF  02
0A18:  RRCF   03,F
0A1A:  RRCF   02,F
0A1C:  MOVLW  3F
0A1E:  ANDWF  03,F
0A20:  MOVFF  02,01
0A24:  MOVF   x1B,W
0A26:  SUBWF  03,W
0A28:  BTFSS  FD8.0
0A2A:  BRA    0FEA
0A2C:  BNZ   0A36
0A2E:  MOVF   01,W
0A30:  SUBWF  x1A,W
0A32:  BTFSC  FD8.0
0A34:  BRA    0FEA
....................    { 
....................       if(track==0) 
0A36:  MOVF   x15,F
0A38:  BTFSS  FD8.2
0A3A:  BRA    0D70
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0A3C:  MOVLW  06
0A3E:  ADDWF  x1A,W
0A40:  MOVWF  x22
0A42:  MOVLW  00
0A44:  ADDWFC x1B,W
0A46:  MOVWF  x23
0A48:  MOVF   x18,W
0A4A:  ADDWF  x22,W
0A4C:  MOVWF  FE9
0A4E:  MOVF   x19,W
0A50:  ADDWFC x23,W
0A52:  MOVWF  FEA
0A54:  MOVFF  FEF,924
0A58:  MOVLW  05
0A5A:  ADDWF  x1A,W
0A5C:  MOVWF  x25
0A5E:  MOVLW  00
0A60:  ADDWFC x1B,W
0A62:  MOVWF  x26
0A64:  MOVF   x18,W
0A66:  ADDWF  x25,W
0A68:  MOVWF  FE9
0A6A:  MOVF   x19,W
0A6C:  ADDWFC x26,W
0A6E:  MOVWF  FEA
0A70:  MOVFF  FEF,927
0A74:  MOVLW  04
0A76:  ADDWF  x1A,W
0A78:  MOVWF  x28
0A7A:  MOVLW  00
0A7C:  ADDWFC x1B,W
0A7E:  MOVWF  x29
0A80:  MOVF   x18,W
0A82:  ADDWF  x28,W
0A84:  MOVWF  FE9
0A86:  MOVF   x19,W
0A88:  ADDWFC x29,W
0A8A:  MOVWF  FEA
0A8C:  MOVFF  FEF,92A
0A90:  MOVLW  03
0A92:  ADDWF  x1A,W
0A94:  MOVWF  x2B
0A96:  MOVLW  00
0A98:  ADDWFC x1B,W
0A9A:  MOVWF  x2C
0A9C:  MOVF   x18,W
0A9E:  ADDWF  x2B,W
0AA0:  MOVWF  FE9
0AA2:  MOVF   x19,W
0AA4:  ADDWFC x2C,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEF,92D
0AAC:  MOVLW  02
0AAE:  ADDWF  x1A,W
0AB0:  MOVWF  x2E
0AB2:  MOVLW  00
0AB4:  ADDWFC x1B,W
0AB6:  MOVWF  x2F
0AB8:  MOVF   x18,W
0ABA:  ADDWF  x2E,W
0ABC:  MOVWF  FE9
0ABE:  MOVF   x19,W
0AC0:  ADDWFC x2F,W
0AC2:  MOVWF  FEA
0AC4:  MOVFF  FEF,930
0AC8:  MOVLW  01
0ACA:  ADDWF  x1A,W
0ACC:  MOVWF  x31
0ACE:  MOVLW  00
0AD0:  ADDWFC x1B,W
0AD2:  MOVWF  x32
0AD4:  MOVF   x18,W
0AD6:  ADDWF  x31,W
0AD8:  MOVWF  FE9
0ADA:  MOVF   x19,W
0ADC:  ADDWFC x32,W
0ADE:  MOVWF  FEA
0AE0:  MOVFF  FEF,933
0AE4:  MOVF   x18,W
0AE6:  ADDWF  x1A,W
0AE8:  MOVWF  FE9
0AEA:  MOVF   x19,W
0AEC:  ADDWFC x1B,W
0AEE:  MOVWF  FEA
0AF0:  MOVFF  FEF,934
0AF4:  CLRF   x37
0AF6:  MOVFF  924,938
0AFA:  MOVFF  927,939
0AFE:  MOVFF  92A,93A
0B02:  MOVFF  92D,93B
0B06:  MOVFF  930,93C
0B0A:  MOVFF  933,93D
0B0E:  MOVFF  934,93E
0B12:  MOVLB  0
0B14:  RCALL  06AC
0B16:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0B1A:  MOVLW  0D
0B1C:  MOVLB  9
0B1E:  ADDWF  x1A,W
0B20:  MOVWF  x22
0B22:  MOVLW  00
0B24:  ADDWFC x1B,W
0B26:  MOVWF  x23
0B28:  MOVF   x18,W
0B2A:  ADDWF  x22,W
0B2C:  MOVWF  FE9
0B2E:  MOVF   x19,W
0B30:  ADDWFC x23,W
0B32:  MOVWF  FEA
0B34:  MOVFF  FEF,924
0B38:  MOVLW  0C
0B3A:  ADDWF  x1A,W
0B3C:  MOVWF  x25
0B3E:  MOVLW  00
0B40:  ADDWFC x1B,W
0B42:  MOVWF  x26
0B44:  MOVF   x18,W
0B46:  ADDWF  x25,W
0B48:  MOVWF  FE9
0B4A:  MOVF   x19,W
0B4C:  ADDWFC x26,W
0B4E:  MOVWF  FEA
0B50:  MOVFF  FEF,927
0B54:  MOVLW  0B
0B56:  ADDWF  x1A,W
0B58:  MOVWF  x28
0B5A:  MOVLW  00
0B5C:  ADDWFC x1B,W
0B5E:  MOVWF  x29
0B60:  MOVF   x18,W
0B62:  ADDWF  x28,W
0B64:  MOVWF  FE9
0B66:  MOVF   x19,W
0B68:  ADDWFC x29,W
0B6A:  MOVWF  FEA
0B6C:  MOVFF  FEF,92A
0B70:  MOVLW  0A
0B72:  ADDWF  x1A,W
0B74:  MOVWF  x2B
0B76:  MOVLW  00
0B78:  ADDWFC x1B,W
0B7A:  MOVWF  x2C
0B7C:  MOVF   x18,W
0B7E:  ADDWF  x2B,W
0B80:  MOVWF  FE9
0B82:  MOVF   x19,W
0B84:  ADDWFC x2C,W
0B86:  MOVWF  FEA
0B88:  MOVFF  FEF,92D
0B8C:  MOVLW  09
0B8E:  ADDWF  x1A,W
0B90:  MOVWF  x2E
0B92:  MOVLW  00
0B94:  ADDWFC x1B,W
0B96:  MOVWF  x2F
0B98:  MOVF   x18,W
0B9A:  ADDWF  x2E,W
0B9C:  MOVWF  FE9
0B9E:  MOVF   x19,W
0BA0:  ADDWFC x2F,W
0BA2:  MOVWF  FEA
0BA4:  MOVFF  FEF,930
0BA8:  MOVLW  08
0BAA:  ADDWF  x1A,W
0BAC:  MOVWF  x31
0BAE:  MOVLW  00
0BB0:  ADDWFC x1B,W
0BB2:  MOVWF  x32
0BB4:  MOVF   x18,W
0BB6:  ADDWF  x31,W
0BB8:  MOVWF  FE9
0BBA:  MOVF   x19,W
0BBC:  ADDWFC x32,W
0BBE:  MOVWF  FEA
0BC0:  MOVFF  FEF,933
0BC4:  MOVLW  07
0BC6:  ADDWF  x1A,W
0BC8:  MOVWF  x34
0BCA:  MOVLW  00
0BCC:  ADDWFC x1B,W
0BCE:  MOVWF  x35
0BD0:  MOVF   x18,W
0BD2:  ADDWF  x34,W
0BD4:  MOVWF  FE9
0BD6:  MOVF   x19,W
0BD8:  ADDWFC x35,W
0BDA:  MOVWF  FEA
0BDC:  MOVFF  FEF,936
0BE0:  CLRF   x37
0BE2:  MOVFF  924,938
0BE6:  MOVFF  927,939
0BEA:  MOVFF  92A,93A
0BEE:  MOVFF  92D,93B
0BF2:  MOVFF  930,93C
0BF6:  MOVFF  933,93D
0BFA:  MOVFF  936,93E
0BFE:  MOVLB  0
0C00:  RCALL  06AC
0C02:  MOVFF  01,91F
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0C06:  MOVLB  9
0C08:  MOVF   x1E,W
0C0A:  SUBLW  45
0C0C:  BTFSS  FD8.2
0C0E:  BRA    0D6E
0C10:  MOVF   x1F,W
0C12:  SUBLW  7C
0C14:  BTFSC  FD8.2
0C16:  BRA    0D6E
0C18:  MOVF   x1F,W
0C1A:  SUBLW  3E
0C1C:  BTFSC  FD8.2
0C1E:  BRA    0D6E
0C20:  MOVF   x1F,W
0C22:  SUBLW  1F
0C24:  BTFSC  FD8.2
0C26:  BRA    0D6E
....................          { 
....................             j=i; 
0C28:  MOVFF  91B,91D
0C2C:  MOVFF  91A,91C
....................             CRC=1; 
0C30:  MOVLW  01
0C32:  MOVWF  x21
....................             temp2=temp; 
0C34:  MOVFF  91E,920
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0C38:  MOVF   x20,W
0C3A:  SUBLW  1F
0C3C:  BTFSC  FD8.2
0C3E:  BRA    0D58
0C40:  MOVF   x1D,W
0C42:  SUBLW  03
0C44:  BTFSS  FD8.0
0C46:  BRA    0D58
0C48:  BNZ   0C52
0C4A:  MOVF   x1C,W
0C4C:  SUBLW  E7
0C4E:  BTFSS  FD8.0
0C50:  BRA    0D58
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C52:  CLRF   x22
0C54:  MOVFF  91D,924
0C58:  MOVFF  91C,923
0C5C:  MOVFF  919,926
0C60:  MOVFF  918,925
0C64:  MOVLB  0
0C66:  RCALL  0712
0C68:  MOVF   01,W
0C6A:  MOVLB  9
0C6C:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C6E:  MOVLW  06
0C70:  ADDWF  x1C,W
0C72:  MOVWF  x22
0C74:  MOVLW  00
0C76:  ADDWFC x1D,W
0C78:  MOVWF  x23
0C7A:  MOVF   x18,W
0C7C:  ADDWF  x22,W
0C7E:  MOVWF  FE9
0C80:  MOVF   x19,W
0C82:  ADDWFC x23,W
0C84:  MOVWF  FEA
0C86:  MOVFF  FEF,924
0C8A:  MOVLW  05
0C8C:  ADDWF  x1C,W
0C8E:  MOVWF  x25
0C90:  MOVLW  00
0C92:  ADDWFC x1D,W
0C94:  MOVWF  x26
0C96:  MOVF   x18,W
0C98:  ADDWF  x25,W
0C9A:  MOVWF  FE9
0C9C:  MOVF   x19,W
0C9E:  ADDWFC x26,W
0CA0:  MOVWF  FEA
0CA2:  MOVFF  FEF,927
0CA6:  MOVLW  04
0CA8:  ADDWF  x1C,W
0CAA:  MOVWF  x28
0CAC:  MOVLW  00
0CAE:  ADDWFC x1D,W
0CB0:  MOVWF  x29
0CB2:  MOVF   x18,W
0CB4:  ADDWF  x28,W
0CB6:  MOVWF  FE9
0CB8:  MOVF   x19,W
0CBA:  ADDWFC x29,W
0CBC:  MOVWF  FEA
0CBE:  MOVFF  FEF,92A
0CC2:  MOVLW  03
0CC4:  ADDWF  x1C,W
0CC6:  MOVWF  x2B
0CC8:  MOVLW  00
0CCA:  ADDWFC x1D,W
0CCC:  MOVWF  x2C
0CCE:  MOVF   x18,W
0CD0:  ADDWF  x2B,W
0CD2:  MOVWF  FE9
0CD4:  MOVF   x19,W
0CD6:  ADDWFC x2C,W
0CD8:  MOVWF  FEA
0CDA:  MOVFF  FEF,92D
0CDE:  MOVLW  02
0CE0:  ADDWF  x1C,W
0CE2:  MOVWF  x2E
0CE4:  MOVLW  00
0CE6:  ADDWFC x1D,W
0CE8:  MOVWF  x2F
0CEA:  MOVF   x18,W
0CEC:  ADDWF  x2E,W
0CEE:  MOVWF  FE9
0CF0:  MOVF   x19,W
0CF2:  ADDWFC x2F,W
0CF4:  MOVWF  FEA
0CF6:  MOVFF  FEF,930
0CFA:  MOVLW  01
0CFC:  ADDWF  x1C,W
0CFE:  MOVWF  x31
0D00:  MOVLW  00
0D02:  ADDWFC x1D,W
0D04:  MOVWF  x32
0D06:  MOVF   x18,W
0D08:  ADDWF  x31,W
0D0A:  MOVWF  FE9
0D0C:  MOVF   x19,W
0D0E:  ADDWFC x32,W
0D10:  MOVWF  FEA
0D12:  MOVFF  FEF,933
0D16:  MOVF   x18,W
0D18:  ADDWF  x1C,W
0D1A:  MOVWF  FE9
0D1C:  MOVF   x19,W
0D1E:  ADDWFC x1D,W
0D20:  MOVWF  FEA
0D22:  MOVFF  FEF,934
0D26:  CLRF   x37
0D28:  MOVFF  924,938
0D2C:  MOVFF  927,939
0D30:  MOVFF  92A,93A
0D34:  MOVFF  92D,93B
0D38:  MOVFF  930,93C
0D3C:  MOVFF  933,93D
0D40:  MOVFF  934,93E
0D44:  MOVLB  0
0D46:  RCALL  06AC
0D48:  MOVFF  01,920
....................                j=j+7; 
0D4C:  MOVLW  07
0D4E:  MOVLB  9
0D50:  ADDWF  x1C,F
0D52:  MOVLW  00
0D54:  ADDWFC x1D,F
....................             } 
0D56:  BRA    0C38
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D58:  DECFSZ x21,W
0D5A:  BRA    0D6E
....................             { 
....................                dir=0; 
0D5C:  MOVLB  6
0D5E:  CLRF   xC8
....................                return i; 
0D60:  MOVLB  9
0D62:  MOVFF  91A,01
0D66:  MOVFF  91B,02
0D6A:  GOTO   1600
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0D6E:  BRA    0FE2
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0D70:  MOVLW  04
0D72:  ADDWF  x1A,W
0D74:  MOVWF  x22
0D76:  MOVLW  00
0D78:  ADDWFC x1B,W
0D7A:  MOVWF  x23
0D7C:  MOVF   x18,W
0D7E:  ADDWF  x22,W
0D80:  MOVWF  FE9
0D82:  MOVF   x19,W
0D84:  ADDWFC x23,W
0D86:  MOVWF  FEA
0D88:  MOVFF  FEF,924
0D8C:  MOVLW  03
0D8E:  ADDWF  x1A,W
0D90:  MOVWF  x25
0D92:  MOVLW  00
0D94:  ADDWFC x1B,W
0D96:  MOVWF  x26
0D98:  MOVF   x18,W
0D9A:  ADDWF  x25,W
0D9C:  MOVWF  FE9
0D9E:  MOVF   x19,W
0DA0:  ADDWFC x26,W
0DA2:  MOVWF  FEA
0DA4:  MOVFF  FEF,927
0DA8:  MOVLW  02
0DAA:  ADDWF  x1A,W
0DAC:  MOVWF  x28
0DAE:  MOVLW  00
0DB0:  ADDWFC x1B,W
0DB2:  MOVWF  x29
0DB4:  MOVF   x18,W
0DB6:  ADDWF  x28,W
0DB8:  MOVWF  FE9
0DBA:  MOVF   x19,W
0DBC:  ADDWFC x29,W
0DBE:  MOVWF  FEA
0DC0:  MOVFF  FEF,92A
0DC4:  MOVLW  01
0DC6:  ADDWF  x1A,W
0DC8:  MOVWF  x2B
0DCA:  MOVLW  00
0DCC:  ADDWFC x1B,W
0DCE:  MOVWF  x2C
0DD0:  MOVF   x18,W
0DD2:  ADDWF  x2B,W
0DD4:  MOVWF  FE9
0DD6:  MOVF   x19,W
0DD8:  ADDWFC x2C,W
0DDA:  MOVWF  FEA
0DDC:  MOVFF  FEF,92D
0DE0:  MOVF   x18,W
0DE2:  ADDWF  x1A,W
0DE4:  MOVWF  FE9
0DE6:  MOVF   x19,W
0DE8:  ADDWFC x1B,W
0DEA:  MOVWF  FEA
0DEC:  MOVFF  FEF,92E
0DF0:  CLRF   x37
0DF2:  CLRF   x38
0DF4:  CLRF   x39
0DF6:  MOVFF  924,93A
0DFA:  MOVFF  927,93B
0DFE:  MOVFF  92A,93C
0E02:  MOVFF  92D,93D
0E06:  MOVFF  92E,93E
0E0A:  MOVLB  0
0E0C:  RCALL  06AC
0E0E:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0E12:  MOVLW  09
0E14:  MOVLB  9
0E16:  ADDWF  x1A,W
0E18:  MOVWF  x22
0E1A:  MOVLW  00
0E1C:  ADDWFC x1B,W
0E1E:  MOVWF  x23
0E20:  MOVF   x18,W
0E22:  ADDWF  x22,W
0E24:  MOVWF  FE9
0E26:  MOVF   x19,W
0E28:  ADDWFC x23,W
0E2A:  MOVWF  FEA
0E2C:  MOVFF  FEF,924
0E30:  MOVLW  08
0E32:  ADDWF  x1A,W
0E34:  MOVWF  x25
0E36:  MOVLW  00
0E38:  ADDWFC x1B,W
0E3A:  MOVWF  x26
0E3C:  MOVF   x18,W
0E3E:  ADDWF  x25,W
0E40:  MOVWF  FE9
0E42:  MOVF   x19,W
0E44:  ADDWFC x26,W
0E46:  MOVWF  FEA
0E48:  MOVFF  FEF,927
0E4C:  MOVLW  07
0E4E:  ADDWF  x1A,W
0E50:  MOVWF  x28
0E52:  MOVLW  00
0E54:  ADDWFC x1B,W
0E56:  MOVWF  x29
0E58:  MOVF   x18,W
0E5A:  ADDWF  x28,W
0E5C:  MOVWF  FE9
0E5E:  MOVF   x19,W
0E60:  ADDWFC x29,W
0E62:  MOVWF  FEA
0E64:  MOVFF  FEF,92A
0E68:  MOVLW  06
0E6A:  ADDWF  x1A,W
0E6C:  MOVWF  x2B
0E6E:  MOVLW  00
0E70:  ADDWFC x1B,W
0E72:  MOVWF  x2C
0E74:  MOVF   x18,W
0E76:  ADDWF  x2B,W
0E78:  MOVWF  FE9
0E7A:  MOVF   x19,W
0E7C:  ADDWFC x2C,W
0E7E:  MOVWF  FEA
0E80:  MOVFF  FEF,92D
0E84:  MOVLW  05
0E86:  ADDWF  x1A,W
0E88:  MOVWF  x2E
0E8A:  MOVLW  00
0E8C:  ADDWFC x1B,W
0E8E:  MOVWF  x2F
0E90:  MOVF   x18,W
0E92:  ADDWF  x2E,W
0E94:  MOVWF  FE9
0E96:  MOVF   x19,W
0E98:  ADDWFC x2F,W
0E9A:  MOVWF  FEA
0E9C:  MOVFF  FEF,930
0EA0:  CLRF   x37
0EA2:  CLRF   x38
0EA4:  CLRF   x39
0EA6:  MOVFF  924,93A
0EAA:  MOVFF  927,93B
0EAE:  MOVFF  92A,93C
0EB2:  MOVFF  92D,93D
0EB6:  MOVFF  930,93E
0EBA:  MOVLB  0
0EBC:  CALL   06AC
0EC0:  MOVFF  01,91F
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0EC4:  MOVLB  9
0EC6:  MOVF   x1E,W
0EC8:  SUBLW  0B
0ECA:  BTFSS  FD8.2
0ECC:  BRA    0FE2
0ECE:  MOVF   x1F,W
0ED0:  SUBLW  1F
0ED2:  BTFSC  FD8.2
0ED4:  BRA    0FE2
0ED6:  MOVF   x1F,W
0ED8:  SUBLW  0F
0EDA:  BTFSC  FD8.2
0EDC:  BRA    0FE2
....................             { 
....................                j=i; 
0EDE:  MOVFF  91B,91D
0EE2:  MOVFF  91A,91C
....................                CRC=1; 
0EE6:  MOVLW  01
0EE8:  MOVWF  x21
....................                temp2=temp; 
0EEA:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0EEE:  MOVF   x20,W
0EF0:  SUBLW  1F
0EF2:  BZ    0FCE
0EF4:  MOVF   x1D,W
0EF6:  SUBLW  01
0EF8:  BNC   0FCE
0EFA:  BNZ   0F02
0EFC:  MOVF   x1C,W
0EFE:  SUBLW  F3
0F00:  BNC   0FCE
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0F02:  CLRF   x22
0F04:  MOVFF  91D,924
0F08:  MOVFF  91C,923
0F0C:  MOVFF  919,926
0F10:  MOVFF  918,925
0F14:  MOVLB  0
0F16:  RCALL  08C2
0F18:  MOVF   01,W
0F1A:  MOVLB  9
0F1C:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0F1E:  MOVLW  04
0F20:  ADDWF  x1C,W
0F22:  MOVWF  x22
0F24:  MOVLW  00
0F26:  ADDWFC x1D,W
0F28:  MOVWF  x23
0F2A:  MOVF   x18,W
0F2C:  ADDWF  x22,W
0F2E:  MOVWF  FE9
0F30:  MOVF   x19,W
0F32:  ADDWFC x23,W
0F34:  MOVWF  FEA
0F36:  MOVFF  FEF,924
0F3A:  MOVLW  03
0F3C:  ADDWF  x1C,W
0F3E:  MOVWF  x25
0F40:  MOVLW  00
0F42:  ADDWFC x1D,W
0F44:  MOVWF  x26
0F46:  MOVF   x18,W
0F48:  ADDWF  x25,W
0F4A:  MOVWF  FE9
0F4C:  MOVF   x19,W
0F4E:  ADDWFC x26,W
0F50:  MOVWF  FEA
0F52:  MOVFF  FEF,927
0F56:  MOVLW  02
0F58:  ADDWF  x1C,W
0F5A:  MOVWF  x28
0F5C:  MOVLW  00
0F5E:  ADDWFC x1D,W
0F60:  MOVWF  x29
0F62:  MOVF   x18,W
0F64:  ADDWF  x28,W
0F66:  MOVWF  FE9
0F68:  MOVF   x19,W
0F6A:  ADDWFC x29,W
0F6C:  MOVWF  FEA
0F6E:  MOVFF  FEF,92A
0F72:  MOVLW  01
0F74:  ADDWF  x1C,W
0F76:  MOVWF  x2B
0F78:  MOVLW  00
0F7A:  ADDWFC x1D,W
0F7C:  MOVWF  x2C
0F7E:  MOVF   x18,W
0F80:  ADDWF  x2B,W
0F82:  MOVWF  FE9
0F84:  MOVF   x19,W
0F86:  ADDWFC x2C,W
0F88:  MOVWF  FEA
0F8A:  MOVFF  FEF,92D
0F8E:  MOVF   x18,W
0F90:  ADDWF  x1C,W
0F92:  MOVWF  FE9
0F94:  MOVF   x19,W
0F96:  ADDWFC x1D,W
0F98:  MOVWF  FEA
0F9A:  MOVFF  FEF,92E
0F9E:  CLRF   x37
0FA0:  CLRF   x38
0FA2:  CLRF   x39
0FA4:  MOVFF  924,93A
0FA8:  MOVFF  927,93B
0FAC:  MOVFF  92A,93C
0FB0:  MOVFF  92D,93D
0FB4:  MOVFF  92E,93E
0FB8:  MOVLB  0
0FBA:  CALL   06AC
0FBE:  MOVFF  01,920
....................                   j=j+5; 
0FC2:  MOVLW  05
0FC4:  MOVLB  9
0FC6:  ADDWF  x1C,F
0FC8:  MOVLW  00
0FCA:  ADDWFC x1D,F
....................                } 
0FCC:  BRA    0EEE
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0FCE:  DECFSZ x21,W
0FD0:  BRA    0FE2
....................                { 
....................                   dir=0; 
0FD2:  MOVLB  6
0FD4:  CLRF   xC8
....................                   return i; 
0FD6:  MOVLB  9
0FD8:  MOVFF  91A,01
0FDC:  MOVFF  91B,02
0FE0:  BRA    1600
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0FE2:  INCF   x1A,F
0FE4:  BTFSC  FD8.2
0FE6:  INCF   x1B,F
0FE8:  BRA    0A10
....................    for(i=end_point;i>end_point/4;i--) 
0FEA:  MOVFF  917,91B
0FEE:  MOVFF  916,91A
0FF2:  RRCF   x17,W
0FF4:  MOVWF  03
0FF6:  RRCF   x16,W
0FF8:  MOVWF  02
0FFA:  RRCF   03,F
0FFC:  RRCF   02,F
0FFE:  MOVLW  3F
1000:  ANDWF  03,F
1002:  MOVFF  02,01
1006:  MOVF   03,W
1008:  SUBWF  x1B,W
100A:  BTFSS  FD8.0
100C:  BRA    15FA
100E:  BNZ   1018
1010:  MOVF   x1A,W
1012:  SUBWF  01,W
1014:  BTFSC  FD8.0
1016:  BRA    15FA
....................    { 
....................       if(track==0) 
1018:  MOVF   x15,F
101A:  BTFSS  FD8.2
101C:  BRA    1370
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
101E:  MOVLW  06
1020:  SUBWF  x1A,W
1022:  MOVWF  x22
1024:  MOVLW  00
1026:  SUBWFB x1B,W
1028:  MOVWF  x23
102A:  MOVF   x18,W
102C:  ADDWF  x22,W
102E:  MOVWF  FE9
1030:  MOVF   x19,W
1032:  ADDWFC x23,W
1034:  MOVWF  FEA
1036:  MOVFF  FEF,924
103A:  MOVLW  05
103C:  SUBWF  x1A,W
103E:  MOVWF  x25
1040:  MOVLW  00
1042:  SUBWFB x1B,W
1044:  MOVWF  x26
1046:  MOVF   x18,W
1048:  ADDWF  x25,W
104A:  MOVWF  FE9
104C:  MOVF   x19,W
104E:  ADDWFC x26,W
1050:  MOVWF  FEA
1052:  MOVFF  FEF,927
1056:  MOVLW  04
1058:  SUBWF  x1A,W
105A:  MOVWF  x28
105C:  MOVLW  00
105E:  SUBWFB x1B,W
1060:  MOVWF  x29
1062:  MOVF   x18,W
1064:  ADDWF  x28,W
1066:  MOVWF  FE9
1068:  MOVF   x19,W
106A:  ADDWFC x29,W
106C:  MOVWF  FEA
106E:  MOVFF  FEF,92A
1072:  MOVLW  03
1074:  SUBWF  x1A,W
1076:  MOVWF  x2B
1078:  MOVLW  00
107A:  SUBWFB x1B,W
107C:  MOVWF  x2C
107E:  MOVF   x18,W
1080:  ADDWF  x2B,W
1082:  MOVWF  FE9
1084:  MOVF   x19,W
1086:  ADDWFC x2C,W
1088:  MOVWF  FEA
108A:  MOVFF  FEF,92D
108E:  MOVLW  02
1090:  SUBWF  x1A,W
1092:  MOVWF  x2E
1094:  MOVLW  00
1096:  SUBWFB x1B,W
1098:  MOVWF  x2F
109A:  MOVF   x18,W
109C:  ADDWF  x2E,W
109E:  MOVWF  FE9
10A0:  MOVF   x19,W
10A2:  ADDWFC x2F,W
10A4:  MOVWF  FEA
10A6:  MOVFF  FEF,930
10AA:  MOVLW  01
10AC:  SUBWF  x1A,W
10AE:  MOVWF  x31
10B0:  MOVLW  00
10B2:  SUBWFB x1B,W
10B4:  MOVWF  x32
10B6:  MOVF   x18,W
10B8:  ADDWF  x31,W
10BA:  MOVWF  FE9
10BC:  MOVF   x19,W
10BE:  ADDWFC x32,W
10C0:  MOVWF  FEA
10C2:  MOVFF  FEF,933
10C6:  MOVF   x18,W
10C8:  ADDWF  x1A,W
10CA:  MOVWF  FE9
10CC:  MOVF   x19,W
10CE:  ADDWFC x1B,W
10D0:  MOVWF  FEA
10D2:  MOVFF  FEF,934
10D6:  CLRF   x37
10D8:  MOVFF  924,938
10DC:  MOVFF  927,939
10E0:  MOVFF  92A,93A
10E4:  MOVFF  92D,93B
10E8:  MOVFF  930,93C
10EC:  MOVFF  933,93D
10F0:  MOVFF  934,93E
10F4:  MOVLB  0
10F6:  CALL   06AC
10FA:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
10FE:  MOVLW  0D
1100:  MOVLB  9
1102:  SUBWF  x1A,W
1104:  MOVWF  x22
1106:  MOVLW  00
1108:  SUBWFB x1B,W
110A:  MOVWF  x23
110C:  MOVF   x18,W
110E:  ADDWF  x22,W
1110:  MOVWF  FE9
1112:  MOVF   x19,W
1114:  ADDWFC x23,W
1116:  MOVWF  FEA
1118:  MOVFF  FEF,924
111C:  MOVLW  0C
111E:  SUBWF  x1A,W
1120:  MOVWF  x25
1122:  MOVLW  00
1124:  SUBWFB x1B,W
1126:  MOVWF  x26
1128:  MOVF   x18,W
112A:  ADDWF  x25,W
112C:  MOVWF  FE9
112E:  MOVF   x19,W
1130:  ADDWFC x26,W
1132:  MOVWF  FEA
1134:  MOVFF  FEF,927
1138:  MOVLW  0B
113A:  SUBWF  x1A,W
113C:  MOVWF  x28
113E:  MOVLW  00
1140:  SUBWFB x1B,W
1142:  MOVWF  x29
1144:  MOVF   x18,W
1146:  ADDWF  x28,W
1148:  MOVWF  FE9
114A:  MOVF   x19,W
114C:  ADDWFC x29,W
114E:  MOVWF  FEA
1150:  MOVFF  FEF,92A
1154:  MOVLW  0A
1156:  SUBWF  x1A,W
1158:  MOVWF  x2B
115A:  MOVLW  00
115C:  SUBWFB x1B,W
115E:  MOVWF  x2C
1160:  MOVF   x18,W
1162:  ADDWF  x2B,W
1164:  MOVWF  FE9
1166:  MOVF   x19,W
1168:  ADDWFC x2C,W
116A:  MOVWF  FEA
116C:  MOVFF  FEF,92D
1170:  MOVLW  09
1172:  SUBWF  x1A,W
1174:  MOVWF  x2E
1176:  MOVLW  00
1178:  SUBWFB x1B,W
117A:  MOVWF  x2F
117C:  MOVF   x18,W
117E:  ADDWF  x2E,W
1180:  MOVWF  FE9
1182:  MOVF   x19,W
1184:  ADDWFC x2F,W
1186:  MOVWF  FEA
1188:  MOVFF  FEF,930
118C:  MOVLW  08
118E:  SUBWF  x1A,W
1190:  MOVWF  x31
1192:  MOVLW  00
1194:  SUBWFB x1B,W
1196:  MOVWF  x32
1198:  MOVF   x18,W
119A:  ADDWF  x31,W
119C:  MOVWF  FE9
119E:  MOVF   x19,W
11A0:  ADDWFC x32,W
11A2:  MOVWF  FEA
11A4:  MOVFF  FEF,933
11A8:  MOVLW  07
11AA:  SUBWF  x1A,W
11AC:  MOVWF  x34
11AE:  MOVLW  00
11B0:  SUBWFB x1B,W
11B2:  MOVWF  x35
11B4:  MOVF   x18,W
11B6:  ADDWF  x34,W
11B8:  MOVWF  FE9
11BA:  MOVF   x19,W
11BC:  ADDWFC x35,W
11BE:  MOVWF  FEA
11C0:  MOVFF  FEF,936
11C4:  CLRF   x37
11C6:  MOVFF  924,938
11CA:  MOVFF  927,939
11CE:  MOVFF  92A,93A
11D2:  MOVFF  92D,93B
11D6:  MOVFF  930,93C
11DA:  MOVFF  933,93D
11DE:  MOVFF  936,93E
11E2:  MOVLB  0
11E4:  CALL   06AC
11E8:  MOVFF  01,91F
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
11EC:  MOVLB  9
11EE:  MOVF   x1E,W
11F0:  SUBLW  45
11F2:  BTFSS  FD8.2
11F4:  BRA    136E
11F6:  MOVF   x1F,W
11F8:  SUBLW  7C
11FA:  BTFSC  FD8.2
11FC:  BRA    136E
11FE:  MOVF   x1F,W
1200:  SUBLW  3E
1202:  BTFSC  FD8.2
1204:  BRA    136E
1206:  MOVF   x1F,W
1208:  SUBLW  1F
120A:  BTFSC  FD8.2
120C:  BRA    136E
120E:  MOVF   x1F,W
1210:  SUBLW  0F
1212:  BTFSC  FD8.2
1214:  BRA    136E
1216:  MOVF   x1F,W
1218:  SUBLW  78
121A:  BTFSC  FD8.2
121C:  BRA    136E
....................          { 
....................             j=i; 
121E:  MOVFF  91B,91D
1222:  MOVFF  91A,91C
....................             CRC=1; 
1226:  MOVLW  01
1228:  MOVWF  x21
....................             temp2=temp; 
122A:  MOVFF  91E,920
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
122E:  MOVF   x20,W
1230:  SUBLW  1F
1232:  BTFSC  FD8.2
1234:  BRA    134E
1236:  MOVF   x1D,F
1238:  BNZ   1242
123A:  MOVF   x1C,W
123C:  SUBLW  01
123E:  BTFSC  FD8.0
1240:  BRA    134E
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1242:  MOVLW  01
1244:  MOVWF  x22
1246:  MOVFF  91D,924
124A:  MOVFF  91C,923
124E:  MOVFF  919,926
1252:  MOVFF  918,925
1256:  MOVLB  0
1258:  CALL   0712
125C:  MOVF   01,W
125E:  MOVLB  9
1260:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1262:  MOVLW  06
1264:  SUBWF  x1C,W
1266:  MOVWF  x22
1268:  MOVLW  00
126A:  SUBWFB x1D,W
126C:  MOVWF  x23
126E:  MOVF   x18,W
1270:  ADDWF  x22,W
1272:  MOVWF  FE9
1274:  MOVF   x19,W
1276:  ADDWFC x23,W
1278:  MOVWF  FEA
127A:  MOVFF  FEF,924
127E:  MOVLW  05
1280:  SUBWF  x1C,W
1282:  MOVWF  x25
1284:  MOVLW  00
1286:  SUBWFB x1D,W
1288:  MOVWF  x26
128A:  MOVF   x18,W
128C:  ADDWF  x25,W
128E:  MOVWF  FE9
1290:  MOVF   x19,W
1292:  ADDWFC x26,W
1294:  MOVWF  FEA
1296:  MOVFF  FEF,927
129A:  MOVLW  04
129C:  SUBWF  x1C,W
129E:  MOVWF  x28
12A0:  MOVLW  00
12A2:  SUBWFB x1D,W
12A4:  MOVWF  x29
12A6:  MOVF   x18,W
12A8:  ADDWF  x28,W
12AA:  MOVWF  FE9
12AC:  MOVF   x19,W
12AE:  ADDWFC x29,W
12B0:  MOVWF  FEA
12B2:  MOVFF  FEF,92A
12B6:  MOVLW  03
12B8:  SUBWF  x1C,W
12BA:  MOVWF  x2B
12BC:  MOVLW  00
12BE:  SUBWFB x1D,W
12C0:  MOVWF  x2C
12C2:  MOVF   x18,W
12C4:  ADDWF  x2B,W
12C6:  MOVWF  FE9
12C8:  MOVF   x19,W
12CA:  ADDWFC x2C,W
12CC:  MOVWF  FEA
12CE:  MOVFF  FEF,92D
12D2:  MOVLW  02
12D4:  SUBWF  x1C,W
12D6:  MOVWF  x2E
12D8:  MOVLW  00
12DA:  SUBWFB x1D,W
12DC:  MOVWF  x2F
12DE:  MOVF   x18,W
12E0:  ADDWF  x2E,W
12E2:  MOVWF  FE9
12E4:  MOVF   x19,W
12E6:  ADDWFC x2F,W
12E8:  MOVWF  FEA
12EA:  MOVFF  FEF,930
12EE:  MOVLW  01
12F0:  SUBWF  x1C,W
12F2:  MOVWF  x31
12F4:  MOVLW  00
12F6:  SUBWFB x1D,W
12F8:  MOVWF  x32
12FA:  MOVF   x18,W
12FC:  ADDWF  x31,W
12FE:  MOVWF  FE9
1300:  MOVF   x19,W
1302:  ADDWFC x32,W
1304:  MOVWF  FEA
1306:  MOVFF  FEF,933
130A:  MOVF   x18,W
130C:  ADDWF  x1C,W
130E:  MOVWF  FE9
1310:  MOVF   x19,W
1312:  ADDWFC x1D,W
1314:  MOVWF  FEA
1316:  MOVFF  FEF,934
131A:  CLRF   x37
131C:  MOVFF  924,938
1320:  MOVFF  927,939
1324:  MOVFF  92A,93A
1328:  MOVFF  92D,93B
132C:  MOVFF  930,93C
1330:  MOVFF  933,93D
1334:  MOVFF  934,93E
1338:  MOVLB  0
133A:  CALL   06AC
133E:  MOVFF  01,920
....................                j=j-7;             
1342:  MOVLW  07
1344:  MOVLB  9
1346:  SUBWF  x1C,F
1348:  MOVLW  00
134A:  SUBWFB x1D,F
....................              } 
134C:  BRA    122E
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
134E:  DECFSZ x21,W
1350:  BRA    1366
....................             { 
....................                dir=1; 
1352:  MOVLW  01
1354:  MOVLB  6
1356:  MOVWF  xC8
....................                return i; 
1358:  MOVLB  9
135A:  MOVFF  91A,01
135E:  MOVFF  91B,02
1362:  BRA    1600
....................             } 
....................             else return 0; 
1364:  BRA    136E
1366:  MOVLW  00
1368:  MOVWF  01
136A:  MOVWF  02
136C:  BRA    1600
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
136E:  BRA    15F0
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1370:  MOVLW  04
1372:  SUBWF  x1A,W
1374:  MOVWF  x22
1376:  MOVLW  00
1378:  SUBWFB x1B,W
137A:  MOVWF  x23
137C:  MOVF   x18,W
137E:  ADDWF  x22,W
1380:  MOVWF  FE9
1382:  MOVF   x19,W
1384:  ADDWFC x23,W
1386:  MOVWF  FEA
1388:  MOVFF  FEF,924
138C:  MOVLW  03
138E:  SUBWF  x1A,W
1390:  MOVWF  x25
1392:  MOVLW  00
1394:  SUBWFB x1B,W
1396:  MOVWF  x26
1398:  MOVF   x18,W
139A:  ADDWF  x25,W
139C:  MOVWF  FE9
139E:  MOVF   x19,W
13A0:  ADDWFC x26,W
13A2:  MOVWF  FEA
13A4:  MOVFF  FEF,927
13A8:  MOVLW  02
13AA:  SUBWF  x1A,W
13AC:  MOVWF  x28
13AE:  MOVLW  00
13B0:  SUBWFB x1B,W
13B2:  MOVWF  x29
13B4:  MOVF   x18,W
13B6:  ADDWF  x28,W
13B8:  MOVWF  FE9
13BA:  MOVF   x19,W
13BC:  ADDWFC x29,W
13BE:  MOVWF  FEA
13C0:  MOVFF  FEF,92A
13C4:  MOVLW  01
13C6:  SUBWF  x1A,W
13C8:  MOVWF  x2B
13CA:  MOVLW  00
13CC:  SUBWFB x1B,W
13CE:  MOVWF  x2C
13D0:  MOVF   x18,W
13D2:  ADDWF  x2B,W
13D4:  MOVWF  FE9
13D6:  MOVF   x19,W
13D8:  ADDWFC x2C,W
13DA:  MOVWF  FEA
13DC:  MOVFF  FEF,92D
13E0:  MOVF   x18,W
13E2:  ADDWF  x1A,W
13E4:  MOVWF  FE9
13E6:  MOVF   x19,W
13E8:  ADDWFC x1B,W
13EA:  MOVWF  FEA
13EC:  MOVFF  FEF,92E
13F0:  CLRF   x37
13F2:  CLRF   x38
13F4:  CLRF   x39
13F6:  MOVFF  924,93A
13FA:  MOVFF  927,93B
13FE:  MOVFF  92A,93C
1402:  MOVFF  92D,93D
1406:  MOVFF  92E,93E
140A:  MOVLB  0
140C:  CALL   06AC
1410:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1414:  MOVLW  09
1416:  MOVLB  9
1418:  SUBWF  x1A,W
141A:  MOVWF  x22
141C:  MOVLW  00
141E:  SUBWFB x1B,W
1420:  MOVWF  x23
1422:  MOVF   x18,W
1424:  ADDWF  x22,W
1426:  MOVWF  FE9
1428:  MOVF   x19,W
142A:  ADDWFC x23,W
142C:  MOVWF  FEA
142E:  MOVFF  FEF,924
1432:  MOVLW  08
1434:  SUBWF  x1A,W
1436:  MOVWF  x25
1438:  MOVLW  00
143A:  SUBWFB x1B,W
143C:  MOVWF  x26
143E:  MOVF   x18,W
1440:  ADDWF  x25,W
1442:  MOVWF  FE9
1444:  MOVF   x19,W
1446:  ADDWFC x26,W
1448:  MOVWF  FEA
144A:  MOVFF  FEF,927
144E:  MOVLW  07
1450:  SUBWF  x1A,W
1452:  MOVWF  x28
1454:  MOVLW  00
1456:  SUBWFB x1B,W
1458:  MOVWF  x29
145A:  MOVF   x18,W
145C:  ADDWF  x28,W
145E:  MOVWF  FE9
1460:  MOVF   x19,W
1462:  ADDWFC x29,W
1464:  MOVWF  FEA
1466:  MOVFF  FEF,92A
146A:  MOVLW  06
146C:  SUBWF  x1A,W
146E:  MOVWF  x2B
1470:  MOVLW  00
1472:  SUBWFB x1B,W
1474:  MOVWF  x2C
1476:  MOVF   x18,W
1478:  ADDWF  x2B,W
147A:  MOVWF  FE9
147C:  MOVF   x19,W
147E:  ADDWFC x2C,W
1480:  MOVWF  FEA
1482:  MOVFF  FEF,92D
1486:  MOVLW  05
1488:  SUBWF  x1A,W
148A:  MOVWF  x2E
148C:  MOVLW  00
148E:  SUBWFB x1B,W
1490:  MOVWF  x2F
1492:  MOVF   x18,W
1494:  ADDWF  x2E,W
1496:  MOVWF  FE9
1498:  MOVF   x19,W
149A:  ADDWFC x2F,W
149C:  MOVWF  FEA
149E:  MOVFF  FEF,930
14A2:  CLRF   x37
14A4:  CLRF   x38
14A6:  CLRF   x39
14A8:  MOVFF  924,93A
14AC:  MOVFF  927,93B
14B0:  MOVFF  92A,93C
14B4:  MOVFF  92D,93D
14B8:  MOVFF  930,93E
14BC:  MOVLB  0
14BE:  CALL   06AC
14C2:  MOVFF  01,91F
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
14C6:  MOVLB  9
14C8:  MOVF   x1E,W
14CA:  SUBLW  0B
14CC:  BTFSS  FD8.2
14CE:  BRA    15F0
14D0:  MOVF   x1F,W
14D2:  SUBLW  1F
14D4:  BTFSC  FD8.2
14D6:  BRA    15F0
14D8:  MOVF   x1F,W
14DA:  SUBLW  0F
14DC:  BTFSC  FD8.2
14DE:  BRA    15F0
....................             { 
....................                j=i; 
14E0:  MOVFF  91B,91D
14E4:  MOVFF  91A,91C
....................                CRC=1; 
14E8:  MOVLW  01
14EA:  MOVWF  x21
....................                temp2=temp; 
14EC:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
14F0:  MOVF   x20,W
14F2:  SUBLW  1F
14F4:  BZ    15D0
14F6:  MOVF   x1D,F
14F8:  BNZ   1500
14FA:  MOVF   x1C,W
14FC:  SUBLW  01
14FE:  BC    15D0
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1500:  MOVLW  01
1502:  MOVWF  x22
1504:  MOVFF  91D,924
1508:  MOVFF  91C,923
150C:  MOVFF  919,926
1510:  MOVFF  918,925
1514:  MOVLB  0
1516:  CALL   08C2
151A:  MOVF   01,W
151C:  MOVLB  9
151E:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1520:  MOVLW  04
1522:  SUBWF  x1C,W
1524:  MOVWF  x22
1526:  MOVLW  00
1528:  SUBWFB x1D,W
152A:  MOVWF  x23
152C:  MOVF   x18,W
152E:  ADDWF  x22,W
1530:  MOVWF  FE9
1532:  MOVF   x19,W
1534:  ADDWFC x23,W
1536:  MOVWF  FEA
1538:  MOVFF  FEF,924
153C:  MOVLW  03
153E:  SUBWF  x1C,W
1540:  MOVWF  x25
1542:  MOVLW  00
1544:  SUBWFB x1D,W
1546:  MOVWF  x26
1548:  MOVF   x18,W
154A:  ADDWF  x25,W
154C:  MOVWF  FE9
154E:  MOVF   x19,W
1550:  ADDWFC x26,W
1552:  MOVWF  FEA
1554:  MOVFF  FEF,927
1558:  MOVLW  02
155A:  SUBWF  x1C,W
155C:  MOVWF  x28
155E:  MOVLW  00
1560:  SUBWFB x1D,W
1562:  MOVWF  x29
1564:  MOVF   x18,W
1566:  ADDWF  x28,W
1568:  MOVWF  FE9
156A:  MOVF   x19,W
156C:  ADDWFC x29,W
156E:  MOVWF  FEA
1570:  MOVFF  FEF,92A
1574:  MOVLW  01
1576:  SUBWF  x1C,W
1578:  MOVWF  x2B
157A:  MOVLW  00
157C:  SUBWFB x1D,W
157E:  MOVWF  x2C
1580:  MOVF   x18,W
1582:  ADDWF  x2B,W
1584:  MOVWF  FE9
1586:  MOVF   x19,W
1588:  ADDWFC x2C,W
158A:  MOVWF  FEA
158C:  MOVFF  FEF,92D
1590:  MOVF   x18,W
1592:  ADDWF  x1C,W
1594:  MOVWF  FE9
1596:  MOVF   x19,W
1598:  ADDWFC x1D,W
159A:  MOVWF  FEA
159C:  MOVFF  FEF,92E
15A0:  CLRF   x37
15A2:  CLRF   x38
15A4:  CLRF   x39
15A6:  MOVFF  924,93A
15AA:  MOVFF  927,93B
15AE:  MOVFF  92A,93C
15B2:  MOVFF  92D,93D
15B6:  MOVFF  92E,93E
15BA:  MOVLB  0
15BC:  CALL   06AC
15C0:  MOVFF  01,920
....................                   j=j-5; 
15C4:  MOVLW  05
15C6:  MOVLB  9
15C8:  SUBWF  x1C,F
15CA:  MOVLW  00
15CC:  SUBWFB x1D,F
....................                } 
15CE:  BRA    14F0
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
15D0:  DECFSZ x21,W
15D2:  BRA    15E8
....................                { 
....................                   dir=1; 
15D4:  MOVLW  01
15D6:  MOVLB  6
15D8:  MOVWF  xC8
....................                   return i; 
15DA:  MOVLB  9
15DC:  MOVFF  91A,01
15E0:  MOVFF  91B,02
15E4:  BRA    1600
....................                } 
....................                   else return 0; 
15E6:  BRA    15F0
15E8:  MOVLW  00
15EA:  MOVWF  01
15EC:  MOVWF  02
15EE:  BRA    1600
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
15F0:  MOVF   x1A,W
15F2:  BTFSC  FD8.2
15F4:  DECF   x1B,F
15F6:  DECF   x1A,F
15F8:  BRA    0FF2
....................    return 0; 
15FA:  MOVLW  00
15FC:  MOVWF  01
15FE:  MOVWF  02
.................... } 
1600:  MOVLB  0
1602:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
35B4:  MOVLB  9
35B6:  CLRF   x02
35B8:  MOVLW  01
35BA:  MOVWF  x01
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
35BC:  MOVFF  8F7,915
35C0:  MOVFF  8F9,917
35C4:  MOVFF  8F8,916
35C8:  MOVFF  8FB,919
35CC:  MOVFF  8FA,918
35D0:  MOVLB  0
35D2:  CALL   0A02
35D6:  MOVFF  02,902
35DA:  MOVFF  01,901
....................    if(temp==0) return 0; 
35DE:  MOVLB  9
35E0:  MOVF   x01,F
35E2:  BNZ   35EE
35E4:  MOVF   x02,F
35E6:  BNZ   35EE
35E8:  MOVLW  00
35EA:  MOVWF  01
35EC:  BRA    3A68
....................    j=temp; 
35EE:  MOVFF  902,900
35F2:  MOVFF  901,8FF
....................    if(dir==0) 
35F6:  MOVLB  6
35F8:  MOVF   xC8,F
35FA:  BTFSS  FD8.2
35FC:  BRA    382A
....................    { 
....................       if(track==0) 
35FE:  MOVLB  8
3600:  MOVF   xF7,F
3602:  BTFSS  FD8.2
3604:  BRA    3742
....................       { 
....................             for(i=0;i<79;i++) 
3606:  CLRF   xFE
3608:  MOVF   xFE,W
360A:  SUBLW  4E
360C:  BTFSS  FD8.0
360E:  BRA    3740
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3610:  CLRF   03
3612:  MOVF   xFE,W
3614:  ADDWF  xFC,W
3616:  MOVWF  01
3618:  MOVF   xFD,W
361A:  ADDWFC 03,F
361C:  MOVFF  01,903
3620:  MOVFF  03,904
3624:  MOVLW  05
3626:  MOVLB  8
3628:  ADDWF  xFF,W
362A:  MOVLB  9
362C:  MOVWF  x05
362E:  MOVLW  00
3630:  ADDWFC x00,W
3632:  MOVWF  x06
3634:  MOVLB  8
3636:  MOVF   xFA,W
3638:  MOVLB  9
363A:  ADDWF  x05,W
363C:  MOVWF  FE9
363E:  MOVLB  8
3640:  MOVF   xFB,W
3642:  MOVLB  9
3644:  ADDWFC x06,W
3646:  MOVWF  FEA
3648:  MOVFF  FEF,907
364C:  MOVLW  04
364E:  MOVLB  8
3650:  ADDWF  xFF,W
3652:  MOVLB  9
3654:  MOVWF  x08
3656:  MOVLW  00
3658:  ADDWFC x00,W
365A:  MOVWF  x09
365C:  MOVLB  8
365E:  MOVF   xFA,W
3660:  MOVLB  9
3662:  ADDWF  x08,W
3664:  MOVWF  FE9
3666:  MOVLB  8
3668:  MOVF   xFB,W
366A:  MOVLB  9
366C:  ADDWFC x09,W
366E:  MOVWF  FEA
3670:  MOVFF  FEF,90A
3674:  MOVLW  03
3676:  MOVLB  8
3678:  ADDWF  xFF,W
367A:  MOVLB  9
367C:  MOVWF  x0B
367E:  MOVLW  00
3680:  ADDWFC x00,W
3682:  MOVWF  x0C
3684:  MOVLB  8
3686:  MOVF   xFA,W
3688:  MOVLB  9
368A:  ADDWF  x0B,W
368C:  MOVWF  FE9
368E:  MOVLB  8
3690:  MOVF   xFB,W
3692:  MOVLB  9
3694:  ADDWFC x0C,W
3696:  MOVWF  FEA
3698:  MOVFF  FEF,90D
369C:  MOVLW  02
369E:  MOVLB  8
36A0:  ADDWF  xFF,W
36A2:  MOVLB  9
36A4:  MOVWF  x0E
36A6:  MOVLW  00
36A8:  ADDWFC x00,W
36AA:  MOVWF  x0F
36AC:  MOVLB  8
36AE:  MOVF   xFA,W
36B0:  MOVLB  9
36B2:  ADDWF  x0E,W
36B4:  MOVWF  FE9
36B6:  MOVLB  8
36B8:  MOVF   xFB,W
36BA:  MOVLB  9
36BC:  ADDWFC x0F,W
36BE:  MOVWF  FEA
36C0:  MOVFF  FEF,910
36C4:  MOVLW  01
36C6:  MOVLB  8
36C8:  ADDWF  xFF,W
36CA:  MOVLB  9
36CC:  MOVWF  x11
36CE:  MOVLW  00
36D0:  ADDWFC x00,W
36D2:  MOVWF  x12
36D4:  MOVLB  8
36D6:  MOVF   xFA,W
36D8:  MOVLB  9
36DA:  ADDWF  x11,W
36DC:  MOVWF  FE9
36DE:  MOVLB  8
36E0:  MOVF   xFB,W
36E2:  MOVLB  9
36E4:  ADDWFC x12,W
36E6:  MOVWF  FEA
36E8:  MOVFF  FEF,913
36EC:  MOVLB  8
36EE:  MOVF   xFA,W
36F0:  ADDWF  xFF,W
36F2:  MOVWF  FE9
36F4:  MOVF   xFB,W
36F6:  MOVLB  9
36F8:  ADDWFC x00,W
36FA:  MOVWF  FEA
36FC:  MOVFF  FEF,914
3700:  CLRF   x37
3702:  CLRF   x38
3704:  MOVFF  907,939
3708:  MOVFF  90A,93A
370C:  MOVFF  90D,93B
3710:  MOVFF  910,93C
3714:  MOVFF  913,93D
3718:  MOVFF  914,93E
371C:  MOVLB  0
371E:  CALL   06AC
3722:  MOVFF  904,FEA
3726:  MOVFF  903,FE9
372A:  MOVFF  01,FEF
....................                j=j+7; 
372E:  MOVLW  07
3730:  MOVLB  8
3732:  ADDWF  xFF,F
3734:  MOVLW  00
3736:  MOVLB  9
3738:  ADDWFC x00,F
....................             } 
373A:  MOVLB  8
373C:  INCF   xFE,F
373E:  BRA    3608
....................       } 
....................          else  
3740:  BRA    3826
....................          { 
....................             for(i=0;i<40;i++) 
3742:  CLRF   xFE
3744:  MOVF   xFE,W
3746:  SUBLW  27
3748:  BNC   3826
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
374A:  CLRF   03
374C:  MOVF   xFE,W
374E:  ADDWF  xFC,W
3750:  MOVWF  01
3752:  MOVF   xFD,W
3754:  ADDWFC 03,F
3756:  MOVFF  01,903
375A:  MOVFF  03,904
375E:  MOVLW  03
3760:  MOVLB  8
3762:  ADDWF  xFF,W
3764:  MOVLB  9
3766:  MOVWF  x05
3768:  MOVLW  00
376A:  ADDWFC x00,W
376C:  MOVWF  x06
376E:  MOVLB  8
3770:  MOVF   xFA,W
3772:  MOVLB  9
3774:  ADDWF  x05,W
3776:  MOVWF  FE9
3778:  MOVLB  8
377A:  MOVF   xFB,W
377C:  MOVLB  9
377E:  ADDWFC x06,W
3780:  MOVWF  FEA
3782:  MOVFF  FEF,907
3786:  MOVLW  02
3788:  MOVLB  8
378A:  ADDWF  xFF,W
378C:  MOVLB  9
378E:  MOVWF  x08
3790:  MOVLW  00
3792:  ADDWFC x00,W
3794:  MOVWF  x09
3796:  MOVLB  8
3798:  MOVF   xFA,W
379A:  MOVLB  9
379C:  ADDWF  x08,W
379E:  MOVWF  FE9
37A0:  MOVLB  8
37A2:  MOVF   xFB,W
37A4:  MOVLB  9
37A6:  ADDWFC x09,W
37A8:  MOVWF  FEA
37AA:  MOVFF  FEF,90A
37AE:  MOVLW  01
37B0:  MOVLB  8
37B2:  ADDWF  xFF,W
37B4:  MOVLB  9
37B6:  MOVWF  x0B
37B8:  MOVLW  00
37BA:  ADDWFC x00,W
37BC:  MOVWF  x0C
37BE:  MOVLB  8
37C0:  MOVF   xFA,W
37C2:  MOVLB  9
37C4:  ADDWF  x0B,W
37C6:  MOVWF  FE9
37C8:  MOVLB  8
37CA:  MOVF   xFB,W
37CC:  MOVLB  9
37CE:  ADDWFC x0C,W
37D0:  MOVWF  FEA
37D2:  MOVFF  FEF,90D
37D6:  MOVLB  8
37D8:  MOVF   xFA,W
37DA:  ADDWF  xFF,W
37DC:  MOVWF  FE9
37DE:  MOVF   xFB,W
37E0:  MOVLB  9
37E2:  ADDWFC x00,W
37E4:  MOVWF  FEA
37E6:  MOVFF  FEF,90E
37EA:  CLRF   x37
37EC:  CLRF   x38
37EE:  CLRF   x39
37F0:  CLRF   x3A
37F2:  MOVFF  907,93B
37F6:  MOVFF  90A,93C
37FA:  MOVFF  90D,93D
37FE:  MOVFF  90E,93E
3802:  MOVLB  0
3804:  CALL   06AC
3808:  MOVFF  904,FEA
380C:  MOVFF  903,FE9
3810:  MOVFF  01,FEF
....................                j=j+5; 
3814:  MOVLW  05
3816:  MOVLB  8
3818:  ADDWF  xFF,F
381A:  MOVLW  00
381C:  MOVLB  9
381E:  ADDWFC x00,F
....................             }          
3820:  MOVLB  8
3822:  INCF   xFE,F
3824:  BRA    3744
....................          } 
....................    } 
....................       else  
3826:  BRA    3A52
3828:  MOVLB  6
....................       { 
....................          if(track==0) 
382A:  MOVLB  8
382C:  MOVF   xF7,F
382E:  BTFSS  FD8.2
3830:  BRA    396E
....................          { 
....................             for(i=0;i<79;i++) 
3832:  CLRF   xFE
3834:  MOVF   xFE,W
3836:  SUBLW  4E
3838:  BTFSS  FD8.0
383A:  BRA    396C
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
383C:  CLRF   03
383E:  MOVF   xFE,W
3840:  ADDWF  xFC,W
3842:  MOVWF  01
3844:  MOVF   xFD,W
3846:  ADDWFC 03,F
3848:  MOVFF  01,903
384C:  MOVFF  03,904
3850:  MOVLW  05
3852:  MOVLB  8
3854:  SUBWF  xFF,W
3856:  MOVLB  9
3858:  MOVWF  x05
385A:  MOVLW  00
385C:  SUBWFB x00,W
385E:  MOVWF  x06
3860:  MOVLB  8
3862:  MOVF   xFA,W
3864:  MOVLB  9
3866:  ADDWF  x05,W
3868:  MOVWF  FE9
386A:  MOVLB  8
386C:  MOVF   xFB,W
386E:  MOVLB  9
3870:  ADDWFC x06,W
3872:  MOVWF  FEA
3874:  MOVFF  FEF,907
3878:  MOVLW  04
387A:  MOVLB  8
387C:  SUBWF  xFF,W
387E:  MOVLB  9
3880:  MOVWF  x08
3882:  MOVLW  00
3884:  SUBWFB x00,W
3886:  MOVWF  x09
3888:  MOVLB  8
388A:  MOVF   xFA,W
388C:  MOVLB  9
388E:  ADDWF  x08,W
3890:  MOVWF  FE9
3892:  MOVLB  8
3894:  MOVF   xFB,W
3896:  MOVLB  9
3898:  ADDWFC x09,W
389A:  MOVWF  FEA
389C:  MOVFF  FEF,90A
38A0:  MOVLW  03
38A2:  MOVLB  8
38A4:  SUBWF  xFF,W
38A6:  MOVLB  9
38A8:  MOVWF  x0B
38AA:  MOVLW  00
38AC:  SUBWFB x00,W
38AE:  MOVWF  x0C
38B0:  MOVLB  8
38B2:  MOVF   xFA,W
38B4:  MOVLB  9
38B6:  ADDWF  x0B,W
38B8:  MOVWF  FE9
38BA:  MOVLB  8
38BC:  MOVF   xFB,W
38BE:  MOVLB  9
38C0:  ADDWFC x0C,W
38C2:  MOVWF  FEA
38C4:  MOVFF  FEF,90D
38C8:  MOVLW  02
38CA:  MOVLB  8
38CC:  SUBWF  xFF,W
38CE:  MOVLB  9
38D0:  MOVWF  x0E
38D2:  MOVLW  00
38D4:  SUBWFB x00,W
38D6:  MOVWF  x0F
38D8:  MOVLB  8
38DA:  MOVF   xFA,W
38DC:  MOVLB  9
38DE:  ADDWF  x0E,W
38E0:  MOVWF  FE9
38E2:  MOVLB  8
38E4:  MOVF   xFB,W
38E6:  MOVLB  9
38E8:  ADDWFC x0F,W
38EA:  MOVWF  FEA
38EC:  MOVFF  FEF,910
38F0:  MOVLW  01
38F2:  MOVLB  8
38F4:  SUBWF  xFF,W
38F6:  MOVLB  9
38F8:  MOVWF  x11
38FA:  MOVLW  00
38FC:  SUBWFB x00,W
38FE:  MOVWF  x12
3900:  MOVLB  8
3902:  MOVF   xFA,W
3904:  MOVLB  9
3906:  ADDWF  x11,W
3908:  MOVWF  FE9
390A:  MOVLB  8
390C:  MOVF   xFB,W
390E:  MOVLB  9
3910:  ADDWFC x12,W
3912:  MOVWF  FEA
3914:  MOVFF  FEF,913
3918:  MOVLB  8
391A:  MOVF   xFA,W
391C:  ADDWF  xFF,W
391E:  MOVWF  FE9
3920:  MOVF   xFB,W
3922:  MOVLB  9
3924:  ADDWFC x00,W
3926:  MOVWF  FEA
3928:  MOVFF  FEF,914
392C:  CLRF   x37
392E:  CLRF   x38
3930:  MOVFF  907,939
3934:  MOVFF  90A,93A
3938:  MOVFF  90D,93B
393C:  MOVFF  910,93C
3940:  MOVFF  913,93D
3944:  MOVFF  914,93E
3948:  MOVLB  0
394A:  CALL   06AC
394E:  MOVFF  904,FEA
3952:  MOVFF  903,FE9
3956:  MOVFF  01,FEF
....................                j=j-7; 
395A:  MOVLW  07
395C:  MOVLB  8
395E:  SUBWF  xFF,F
3960:  MOVLW  00
3962:  MOVLB  9
3964:  SUBWFB x00,F
....................             } 
3966:  MOVLB  8
3968:  INCF   xFE,F
396A:  BRA    3834
....................          } 
....................             else 
396C:  BRA    3A52
....................             { 
....................                for(i=0;i<40;i++) 
396E:  CLRF   xFE
3970:  MOVF   xFE,W
3972:  SUBLW  27
3974:  BNC   3A52
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3976:  CLRF   03
3978:  MOVF   xFE,W
397A:  ADDWF  xFC,W
397C:  MOVWF  01
397E:  MOVF   xFD,W
3980:  ADDWFC 03,F
3982:  MOVFF  01,903
3986:  MOVFF  03,904
398A:  MOVLW  03
398C:  MOVLB  8
398E:  SUBWF  xFF,W
3990:  MOVLB  9
3992:  MOVWF  x05
3994:  MOVLW  00
3996:  SUBWFB x00,W
3998:  MOVWF  x06
399A:  MOVLB  8
399C:  MOVF   xFA,W
399E:  MOVLB  9
39A0:  ADDWF  x05,W
39A2:  MOVWF  FE9
39A4:  MOVLB  8
39A6:  MOVF   xFB,W
39A8:  MOVLB  9
39AA:  ADDWFC x06,W
39AC:  MOVWF  FEA
39AE:  MOVFF  FEF,907
39B2:  MOVLW  02
39B4:  MOVLB  8
39B6:  SUBWF  xFF,W
39B8:  MOVLB  9
39BA:  MOVWF  x08
39BC:  MOVLW  00
39BE:  SUBWFB x00,W
39C0:  MOVWF  x09
39C2:  MOVLB  8
39C4:  MOVF   xFA,W
39C6:  MOVLB  9
39C8:  ADDWF  x08,W
39CA:  MOVWF  FE9
39CC:  MOVLB  8
39CE:  MOVF   xFB,W
39D0:  MOVLB  9
39D2:  ADDWFC x09,W
39D4:  MOVWF  FEA
39D6:  MOVFF  FEF,90A
39DA:  MOVLW  01
39DC:  MOVLB  8
39DE:  SUBWF  xFF,W
39E0:  MOVLB  9
39E2:  MOVWF  x0B
39E4:  MOVLW  00
39E6:  SUBWFB x00,W
39E8:  MOVWF  x0C
39EA:  MOVLB  8
39EC:  MOVF   xFA,W
39EE:  MOVLB  9
39F0:  ADDWF  x0B,W
39F2:  MOVWF  FE9
39F4:  MOVLB  8
39F6:  MOVF   xFB,W
39F8:  MOVLB  9
39FA:  ADDWFC x0C,W
39FC:  MOVWF  FEA
39FE:  MOVFF  FEF,90D
3A02:  MOVLB  8
3A04:  MOVF   xFA,W
3A06:  ADDWF  xFF,W
3A08:  MOVWF  FE9
3A0A:  MOVF   xFB,W
3A0C:  MOVLB  9
3A0E:  ADDWFC x00,W
3A10:  MOVWF  FEA
3A12:  MOVFF  FEF,90E
3A16:  CLRF   x37
3A18:  CLRF   x38
3A1A:  CLRF   x39
3A1C:  CLRF   x3A
3A1E:  MOVFF  907,93B
3A22:  MOVFF  90A,93C
3A26:  MOVFF  90D,93D
3A2A:  MOVFF  90E,93E
3A2E:  MOVLB  0
3A30:  CALL   06AC
3A34:  MOVFF  904,FEA
3A38:  MOVFF  903,FE9
3A3C:  MOVFF  01,FEF
....................                   j=j-5; 
3A40:  MOVLW  05
3A42:  MOVLB  8
3A44:  SUBWF  xFF,F
3A46:  MOVLW  00
3A48:  MOVLB  9
3A4A:  SUBWFB x00,F
....................                }             
3A4C:  MOVLB  8
3A4E:  INCF   xFE,F
3A50:  BRA    3970
....................             } 
....................       } 
....................       memset(datin,0,sizeof(datin)); 
3A52:  MOVFF  8FB,FEA
3A56:  MOVFF  8FA,FE9
3A5A:  CLRF   00
3A5C:  CLRF   02
3A5E:  MOVLW  02
3A60:  MOVWF  01
3A62:  MOVLB  0
3A64:  RCALL  359A
3A66:  MOVLB  9
.................... } 
3A68:  MOVLB  0
3A6A:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1836:  MOVLW  8E
1838:  MOVWF  FF6
183A:  MOVLW  05
183C:  MOVWF  FF7
183E:  RCALL  172E
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1840:  MOVLB  8
1842:  CLRF   x57
1844:  CLRF   x56
1846:  MOVF   x57,W
1848:  SUBLW  03
184A:  BNC   187A
184C:  BNZ   1854
184E:  MOVF   x56,W
1850:  SUBLW  51
1852:  BNC   187A
1854:  MOVLW  46
1856:  ADDWF  x56,W
1858:  MOVWF  FE9
185A:  MOVLW  02
185C:  ADDWFC x57,W
185E:  MOVWF  FEA
1860:  MOVFF  FEF,858
1864:  MOVFF  858,859
1868:  MOVLW  18
186A:  MOVWF  x5A
186C:  MOVLB  0
186E:  RCALL  177A
1870:  MOVLB  8
1872:  INCF   x56,F
1874:  BTFSC  FD8.2
1876:  INCF   x57,F
1878:  BRA    1846
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
187A:  MOVLW  A4
187C:  MOVWF  FF6
187E:  MOVLW  05
1880:  MOVWF  FF7
1882:  MOVLB  0
1884:  RCALL  172E
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1886:  MOVLB  8
1888:  CLRF   x57
188A:  CLRF   x56
188C:  MOVF   x57,W
188E:  SUBLW  01
1890:  BNC   18C0
1892:  BNZ   189A
1894:  MOVF   x56,W
1896:  SUBLW  2B
1898:  BNC   18C0
189A:  MOVLW  98
189C:  ADDWF  x56,W
189E:  MOVWF  FE9
18A0:  MOVLW  05
18A2:  ADDWFC x57,W
18A4:  MOVWF  FEA
18A6:  MOVFF  FEF,858
18AA:  MOVFF  858,859
18AE:  MOVLW  18
18B0:  MOVWF  x5A
18B2:  MOVLB  0
18B4:  RCALL  177A
18B6:  MOVLB  8
18B8:  INCF   x56,F
18BA:  BTFSC  FD8.2
18BC:  INCF   x57,F
18BE:  BRA    188C
.................... } 
18C0:  MOVLB  0
18C2:  GOTO   1B50 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3C02:  MOVLW  01
3C04:  MOVLB  6
3C06:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3C08:  MOVLB  0
3C0A:  RCALL  351C
3C0C:  MOVFF  02,854
3C10:  MOVFF  01,853
3C14:  MOVFF  02,856
3C18:  MOVFF  01,855
3C1C:  MOVLB  8
3C1E:  CLRF   x58
3C20:  MOVLW  7C
3C22:  MOVWF  x57
3C24:  MOVLB  0
3C26:  RCALL  3578
3C28:  MOVFF  01,853
3C2C:  MOVLW  96
3C2E:  MOVLB  8
3C30:  ADDWF  01,W
3C32:  MOVWF  01
3C34:  MOVLW  00
3C36:  ADDWFC 02,W
3C38:  MOVFF  01,20
3C3C:  MOVWF  21
3C3E:  CLRF   22
3C40:  CLRF   23
....................    if(datinbuf==0)  
3C42:  MOVLB  6
3C44:  MOVF   xD5,F
3C46:  BNZ   3C6A
....................    { 
....................       countbit_T1=0; 
3C48:  CLRF   xCA
3C4A:  CLRF   xC9
....................       countbit_T2=0; 
3C4C:  CLRF   xCC
3C4E:  CLRF   xCB
....................       bug_countbit_T1=0; 
3C50:  CLRF   xCE
3C52:  CLRF   xCD
....................       bug_countbit_T2=0; 
3C54:  CLRF   xD0
3C56:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3C58:  MOVF   xD9,F
3C5A:  BNZ   3C66
3C5C:  MOVLB  1
3C5E:  SETF   x00
3C60:  MOVLB  0
3C62:  SETF   xFF
3C64:  MOVLB  6
....................       saving_flag=0; 
3C66:  CLRF   xD8
....................       return; 
3C68:  BRA    3FFE
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3C6A:  MOVLW  BA
3C6C:  MOVWF  FF6
3C6E:  MOVLW  05
3C70:  MOVWF  FF7
3C72:  MOVLB  0
3C74:  CALL   172E
....................    //key_count=0; 
....................    enable_getpin=1; 
3C78:  MOVLW  01
3C7A:  MOVLB  1
3C7C:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3C7E:  MOVFF  6CA,852
3C82:  MOVFF  6C9,851
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3C86:  MOVLB  8
3C88:  CLRF   xF7
3C8A:  MOVFF  852,8F9
3C8E:  MOVFF  851,8F8
3C92:  MOVLW  02
3C94:  MOVWF  xFB
3C96:  MOVLW  46
3C98:  MOVWF  xFA
3C9A:  MOVLW  01
3C9C:  MOVWF  xFD
3C9E:  MOVLW  CF
3CA0:  MOVWF  xFC
3CA2:  MOVLB  0
3CA4:  RCALL  35B4
....................    countbit_T1=0; 
3CA6:  MOVLB  6
3CA8:  CLRF   xCA
3CAA:  CLRF   xC9
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3CAC:  MOVFF  6CC,852
3CB0:  MOVFF  6CB,851
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3CB4:  MOVLW  01
3CB6:  MOVLB  8
3CB8:  MOVWF  xF7
3CBA:  MOVFF  852,8F9
3CBE:  MOVFF  851,8F8
3CC2:  MOVLW  05
3CC4:  MOVWF  xFB
3CC6:  MOVLW  98
3CC8:  MOVWF  xFA
3CCA:  MOVLW  02
3CCC:  MOVWF  xFD
3CCE:  MOVLW  1E
3CD0:  MOVWF  xFC
3CD2:  MOVLB  0
3CD4:  RCALL  35B4
....................    countbit_T2=0; 
3CD6:  MOVLB  6
3CD8:  CLRF   xCC
3CDA:  CLRF   xCB
....................    saving_flag=0; 
3CDC:  CLRF   xD8
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3CDE:  MOVLW  20
3CE0:  MOVLB  1
3CE2:  ADDWF  xCF,W
3CE4:  MOVLB  8
3CE6:  MOVWF  x50
....................    if((ptr_card<EEPROM_SIZE_stofkey)&&(temp=='%')) 
3CE8:  MOVF   23,F
3CEA:  BTFSS  FD8.2
3CEC:  BRA    3FFC
3CEE:  MOVF   22,W
3CF0:  SUBLW  01
3CF2:  BTFSS  FD8.0
3CF4:  BRA    3FFC
3CF6:  BNZ   3D0A
3CF8:  MOVF   21,W
3CFA:  SUBLW  C3
3CFC:  BTFSS  FD8.0
3CFE:  BRA    3FFC
3D00:  BNZ   3D0A
3D02:  MOVF   20,W
3D04:  SUBLW  0D
3D06:  BTFSS  FD8.0
3D08:  BRA    3FFC
3D0A:  MOVF   x50,W
3D0C:  SUBLW  25
3D0E:  BTFSS  FD8.2
3D10:  BRA    3FFC
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3D12:  MOVFF  23,03
3D16:  MOVFF  22,02
3D1A:  MOVFF  21,01
3D1E:  MOVFF  20,00
3D22:  MOVLW  01
3D24:  ADDWF  20,F
3D26:  BTFSC  FD8.0
3D28:  INCF   21,F
3D2A:  BTFSC  FD8.2
3D2C:  INCF   22,F
3D2E:  BTFSC  FD8.2
3D30:  INCF   23,F
3D32:  MOVFF  01,854
3D36:  MOVFF  00,853
3D3A:  MOVLB  9
3D3C:  CLRF   x16
3D3E:  CLRF   x15
3D40:  MOVFF  01,914
3D44:  MOVFF  00,913
3D48:  MOVFF  1CB,917
3D4C:  MOVLB  0
3D4E:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3D50:  MOVFF  23,03
3D54:  MOVFF  22,02
3D58:  MOVFF  21,01
3D5C:  MOVFF  20,00
3D60:  MOVLW  01
3D62:  ADDWF  20,F
3D64:  BTFSC  FD8.0
3D66:  INCF   21,F
3D68:  BTFSC  FD8.2
3D6A:  INCF   22,F
3D6C:  BTFSC  FD8.2
3D6E:  INCF   23,F
3D70:  MOVFF  01,854
3D74:  MOVFF  00,853
3D78:  MOVLB  9
3D7A:  CLRF   x16
3D7C:  CLRF   x15
3D7E:  MOVFF  01,914
3D82:  MOVFF  00,913
3D86:  MOVFF  1CA,917
3D8A:  MOVLB  0
3D8C:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,h); 
3D8E:  MOVFF  23,03
3D92:  MOVFF  22,02
3D96:  MOVFF  21,01
3D9A:  MOVFF  20,00
3D9E:  MOVLW  01
3DA0:  ADDWF  20,F
3DA2:  BTFSC  FD8.0
3DA4:  INCF   21,F
3DA6:  BTFSC  FD8.2
3DA8:  INCF   22,F
3DAA:  BTFSC  FD8.2
3DAC:  INCF   23,F
3DAE:  MOVFF  01,854
3DB2:  MOVFF  00,853
3DB6:  MOVLB  9
3DB8:  CLRF   x16
3DBA:  CLRF   x15
3DBC:  MOVFF  01,914
3DC0:  MOVFF  00,913
3DC4:  MOVFF  1CC,917
3DC8:  MOVLB  0
3DCA:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,min); 
3DCC:  MOVFF  23,03
3DD0:  MOVFF  22,02
3DD4:  MOVFF  21,01
3DD8:  MOVFF  20,00
3DDC:  MOVLW  01
3DDE:  ADDWF  20,F
3DE0:  BTFSC  FD8.0
3DE2:  INCF   21,F
3DE4:  BTFSC  FD8.2
3DE6:  INCF   22,F
3DE8:  BTFSC  FD8.2
3DEA:  INCF   23,F
3DEC:  MOVFF  01,854
3DF0:  MOVFF  00,853
3DF4:  MOVLB  9
3DF6:  CLRF   x16
3DF8:  CLRF   x15
3DFA:  MOVFF  01,914
3DFE:  MOVFF  00,913
3E02:  MOVFF  1CD,917
3E06:  MOVLB  0
3E08:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3E0A:  MOVFF  23,03
3E0E:  MOVFF  22,02
3E12:  MOVFF  21,01
3E16:  MOVFF  20,00
3E1A:  MOVLW  01
3E1C:  ADDWF  20,F
3E1E:  BTFSC  FD8.0
3E20:  INCF   21,F
3E22:  BTFSC  FD8.2
3E24:  INCF   22,F
3E26:  BTFSC  FD8.2
3E28:  INCF   23,F
3E2A:  MOVFF  01,854
3E2E:  MOVFF  00,853
3E32:  MOVLB  9
3E34:  CLRF   x16
3E36:  CLRF   x15
3E38:  MOVFF  01,914
3E3C:  MOVFF  00,913
3E40:  MOVFF  1CE,917
3E44:  MOVLB  0
3E46:  RCALL  3A6C
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3E48:  MOVLB  6
3E4A:  CLRF   xD4
3E4C:  CLRF   xD3
3E4E:  MOVF   xD4,F
3E50:  BNZ   3EB4
3E52:  MOVF   xD3,W
3E54:  SUBLW  4E
3E56:  BNC   3EB4
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3E58:  MOVFF  23,03
3E5C:  MOVFF  22,02
3E60:  MOVFF  21,01
3E64:  MOVFF  20,00
3E68:  MOVLW  01
3E6A:  ADDWF  20,F
3E6C:  BTFSC  FD8.0
3E6E:  INCF   21,F
3E70:  BTFSC  FD8.2
3E72:  INCF   22,F
3E74:  BTFSC  FD8.2
3E76:  INCF   23,F
3E78:  MOVFF  01,854
3E7C:  MOVFF  00,853
3E80:  MOVLW  CF
3E82:  ADDWF  xD3,W
3E84:  MOVWF  FE9
3E86:  MOVLW  01
3E88:  ADDWFC xD4,W
3E8A:  MOVWF  FEA
3E8C:  MOVF   FEF,W
3E8E:  ANDLW  3F
3E90:  ADDLW  20
3E92:  MOVLB  8
3E94:  MOVWF  x55
3E96:  MOVLB  9
3E98:  CLRF   x16
3E9A:  CLRF   x15
3E9C:  MOVFF  01,914
3EA0:  MOVFF  00,913
3EA4:  MOVWF  x17
3EA6:  MOVLB  0
3EA8:  RCALL  3A6C
....................              
....................          } 
3EAA:  MOVLB  6
3EAC:  INCF   xD3,F
3EAE:  BTFSC  FD8.2
3EB0:  INCF   xD4,F
3EB2:  BRA    3E4E
....................          memset(Track1,0,sizeof(Track1)); 
3EB4:  MOVLW  01
3EB6:  MOVWF  FEA
3EB8:  MOVLW  CF
3EBA:  MOVWF  FE9
3EBC:  CLRF   00
3EBE:  CLRF   02
3EC0:  MOVLW  4F
3EC2:  MOVWF  01
3EC4:  MOVLB  0
3EC6:  CALL   359A
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3ECA:  MOVLB  6
3ECC:  CLRF   xD4
3ECE:  CLRF   xD3
3ED0:  MOVF   xD4,F
3ED2:  BNZ   3F36
3ED4:  MOVF   xD3,W
3ED6:  SUBLW  27
3ED8:  BNC   3F36
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3EDA:  MOVFF  23,03
3EDE:  MOVFF  22,02
3EE2:  MOVFF  21,01
3EE6:  MOVFF  20,00
3EEA:  MOVLW  01
3EEC:  ADDWF  20,F
3EEE:  BTFSC  FD8.0
3EF0:  INCF   21,F
3EF2:  BTFSC  FD8.2
3EF4:  INCF   22,F
3EF6:  BTFSC  FD8.2
3EF8:  INCF   23,F
3EFA:  MOVFF  01,854
3EFE:  MOVFF  00,853
3F02:  MOVLW  1E
3F04:  ADDWF  xD3,W
3F06:  MOVWF  FE9
3F08:  MOVLW  02
3F0A:  ADDWFC xD4,W
3F0C:  MOVWF  FEA
3F0E:  MOVF   FEF,W
3F10:  ANDLW  0F
3F12:  ADDLW  30
3F14:  MOVLB  8
3F16:  MOVWF  x55
3F18:  MOVLB  9
3F1A:  CLRF   x16
3F1C:  CLRF   x15
3F1E:  MOVFF  01,914
3F22:  MOVFF  00,913
3F26:  MOVWF  x17
3F28:  MOVLB  0
3F2A:  RCALL  3A6C
....................          }  
3F2C:  MOVLB  6
3F2E:  INCF   xD3,F
3F30:  BTFSC  FD8.2
3F32:  INCF   xD4,F
3F34:  BRA    3ED0
....................          memset(Track2,0,sizeof(Track2)); 
3F36:  MOVLW  02
3F38:  MOVWF  FEA
3F3A:  MOVLW  1E
3F3C:  MOVWF  FE9
3F3E:  CLRF   00
3F40:  CLRF   02
3F42:  MOVLW  28
3F44:  MOVWF  01
3F46:  MOVLB  0
3F48:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
3F4C:  MOVLW  0D
3F4E:  MOVLB  9
3F50:  MOVWF  x0C
3F52:  MOVLB  0
3F54:  CALL   1604
3F58:  MOVLW  0A
3F5A:  MOVLB  9
3F5C:  MOVWF  x0C
3F5E:  MOVLB  0
3F60:  CALL   1604
....................         fprintf(COM2,"Done"); 
3F64:  MOVLW  D0
3F66:  MOVWF  FF6
3F68:  MOVLW  05
3F6A:  MOVWF  FF7
3F6C:  CALL   172E
....................              
....................         fprintf(COM2,"\r\n"); 
3F70:  MOVLW  0D
3F72:  MOVLB  9
3F74:  MOVWF  x0C
3F76:  MOVLB  0
3F78:  CALL   1604
3F7C:  MOVLW  0A
3F7E:  MOVLB  9
3F80:  MOVWF  x0C
3F82:  MOVLB  0
3F84:  CALL   1604
....................         fprintf(COM2,"Waiting for PIN number"); 
3F88:  MOVLW  D6
3F8A:  MOVWF  FF6
3F8C:  MOVLW  05
3F8E:  MOVWF  FF7
3F90:  CALL   172E
....................         memset(key_data,0,sizeof(key_data));  
3F94:  MOVLW  01
3F96:  MOVWF  FEA
3F98:  MOVLW  4A
3F9A:  MOVWF  FE9
3F9C:  CLRF   00
3F9E:  CLRF   02
3FA0:  MOVLW  10
3FA2:  MOVWF  01
3FA4:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
3FA8:  MOVLW  0D
3FAA:  MOVLB  9
3FAC:  MOVWF  x0C
3FAE:  MOVLB  0
3FB0:  CALL   1604
3FB4:  MOVLW  0A
3FB6:  MOVLB  9
3FB8:  MOVWF  x0C
3FBA:  MOVLB  0
3FBC:  CALL   1604
....................         charac_timeout=0; 
3FC0:  MOVLB  1
3FC2:  CLRF   x00
3FC4:  MOVLB  0
3FC6:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3FC8:  MOVFF  23,8FA
3FCC:  MOVFF  22,8F9
3FD0:  MOVFF  21,8F8
3FD4:  MOVFF  20,8F7
3FD8:  MOVLW  19
3FDA:  MOVLB  8
3FDC:  MOVWF  xFB
3FDE:  MOVLB  0
3FE0:  RCALL  3B6A
....................       datinbuf=0; 
3FE2:  MOVLB  6
3FE4:  CLRF   xD5
....................       saving_flag=0; 
3FE6:  CLRF   xD8
....................       data_avai=1; 
3FE8:  MOVLW  01
3FEA:  MOVWF  xD9
....................       enable_getpin=1; 
3FEC:  MOVLB  1
3FEE:  MOVWF  x45
....................       charac_timeout=0; 
3FF0:  CLRF   x00
3FF2:  MOVLB  0
3FF4:  CLRF   xFF
....................       key_count_ms=0; 
3FF6:  MOVLB  1
3FF8:  CLRF   x47
3FFA:  MOVLB  8
3FFC:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3FFE:  MOVLB  0
4000:  GOTO   5A70 (RETURN)
.................... //========================= 
.................... void saving_card_encrypt() 
.................... { 
*
4FD0:  MOVLB  8
4FD2:  CLRF   x54
....................    int8 temp,i,j,u; 
....................    int8 countbyte=0; 
....................    int16 tempcount; 
....................    int8 carddata[numdataofonecard]; 
....................    int8 encryptblock[16]; 
....................    int8 tempkey[16]; 
....................    saving_flag=1; 
4FD4:  MOVLW  01
4FD6:  MOVLB  6
4FD8:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdataofonecard)+ptr_start); 
4FDA:  MOVLB  0
4FDC:  CALL   351C
4FE0:  MOVFF  02,8F8
4FE4:  MOVFF  01,8F7
4FE8:  MOVLB  8
4FEA:  RLCF   xF7,F
4FEC:  RLCF   xF8,F
4FEE:  RLCF   xF7,F
4FF0:  RLCF   xF8,F
4FF2:  RLCF   xF7,F
4FF4:  RLCF   xF8,F
4FF6:  RLCF   xF7,F
4FF8:  RLCF   xF8,F
4FFA:  RLCF   xF7,F
4FFC:  RLCF   xF8,F
4FFE:  RLCF   xF7,F
5000:  RLCF   xF8,F
5002:  RLCF   xF7,F
5004:  RLCF   xF8,F
5006:  MOVLW  80
5008:  ANDWF  xF7,F
500A:  MOVLW  96
500C:  ADDWF  xF7,W
500E:  MOVWF  01
5010:  MOVLW  00
5012:  ADDWFC xF8,W
5014:  MOVFF  01,20
5018:  MOVWF  21
501A:  CLRF   22
501C:  CLRF   23
....................    if(datinbuf==0)  
501E:  MOVLB  6
5020:  MOVF   xD5,F
5022:  BNZ   5046
....................    { 
....................       countbit_T1=0; 
5024:  CLRF   xCA
5026:  CLRF   xC9
....................       countbit_T2=0; 
5028:  CLRF   xCC
502A:  CLRF   xCB
....................       bug_countbit_T1=0; 
502C:  CLRF   xCE
502E:  CLRF   xCD
....................       bug_countbit_T2=0; 
5030:  CLRF   xD0
5032:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
5034:  MOVF   xD9,F
5036:  BNZ   5042
5038:  MOVLB  1
503A:  SETF   x00
503C:  MOVLB  0
503E:  SETF   xFF
5040:  MOVLB  6
....................       saving_flag=0; 
5042:  CLRF   xD8
....................       return; 
5044:  BRA    5470
....................    }//*/ 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
5046:  MOVLW  EE
5048:  MOVWF  FF6
504A:  MOVLW  05
504C:  MOVWF  FF7
504E:  MOVLB  0
5050:  CALL   172E
....................    //key_count=0; 
....................    enable_getpin=1; 
5054:  MOVLW  01
5056:  MOVLB  1
5058:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
505A:  MOVFF  6CA,856
505E:  MOVFF  6C9,855
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
5062:  MOVLB  8
5064:  CLRF   xF7
5066:  MOVFF  856,8F9
506A:  MOVFF  855,8F8
506E:  MOVLW  02
5070:  MOVWF  xFB
5072:  MOVLW  46
5074:  MOVWF  xFA
5076:  MOVLW  01
5078:  MOVWF  xFD
507A:  MOVLW  CF
507C:  MOVWF  xFC
507E:  MOVLB  0
5080:  CALL   35B4
....................    countbit_T1=0; 
5084:  MOVLB  6
5086:  CLRF   xCA
5088:  CLRF   xC9
....................    tempcount=countbit_T2;    
508A:  MOVFF  6CC,856
508E:  MOVFF  6CB,855
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
5092:  MOVLW  01
5094:  MOVLB  8
5096:  MOVWF  xF7
5098:  MOVFF  856,8F9
509C:  MOVFF  855,8F8
50A0:  MOVLW  05
50A2:  MOVWF  xFB
50A4:  MOVLW  98
50A6:  MOVWF  xFA
50A8:  MOVLW  02
50AA:  MOVWF  xFD
50AC:  MOVLW  1E
50AE:  MOVWF  xFC
50B0:  MOVLB  0
50B2:  CALL   35B4
....................    countbit_T2=0; 
50B6:  MOVLB  6
50B8:  CLRF   xCC
50BA:  CLRF   xCB
....................    saving_flag=0; 
50BC:  CLRF   xD8
....................    temp=Track1[0]+0x20; 
50BE:  MOVLW  20
50C0:  MOVLB  1
50C2:  ADDWF  xCF,W
50C4:  MOVLB  8
50C6:  MOVWF  x50
....................    if((ptr_card<EEPROM_SIZE_stofkey)) 
50C8:  MOVF   23,F
50CA:  BTFSS  FD8.2
50CC:  BRA    546E
50CE:  MOVF   22,W
50D0:  SUBLW  01
50D2:  BTFSS  FD8.0
50D4:  BRA    546E
50D6:  BNZ   50EA
50D8:  MOVF   21,W
50DA:  SUBLW  C3
50DC:  BTFSS  FD8.0
50DE:  BRA    546E
50E0:  BNZ   50EA
50E2:  MOVF   20,W
50E4:  SUBLW  0D
50E6:  BTFSS  FD8.0
50E8:  BRA    546E
....................    { 
....................          countbyte = 0; 
50EA:  CLRF   x54
....................          carddata[countbyte++]=date;    
50EC:  MOVF   x54,W
50EE:  INCF   x54,F
50F0:  CLRF   03
50F2:  ADDLW  57
50F4:  MOVWF  FE9
50F6:  MOVLW  08
50F8:  ADDWFC 03,W
50FA:  MOVWF  FEA
50FC:  MOVFF  1CB,FEF
....................          carddata[countbyte++]=mon;    
5100:  MOVF   x54,W
5102:  INCF   x54,F
5104:  CLRF   03
5106:  ADDLW  57
5108:  MOVWF  FE9
510A:  MOVLW  08
510C:  ADDWFC 03,W
510E:  MOVWF  FEA
5110:  MOVFF  1CA,FEF
....................          carddata[countbyte++]=h;    
5114:  MOVF   x54,W
5116:  INCF   x54,F
5118:  CLRF   03
511A:  ADDLW  57
511C:  MOVWF  FE9
511E:  MOVLW  08
5120:  ADDWFC 03,W
5122:  MOVWF  FEA
5124:  MOVFF  1CC,FEF
....................          carddata[countbyte++]=min;    
5128:  MOVF   x54,W
512A:  INCF   x54,F
512C:  CLRF   03
512E:  ADDLW  57
5130:  MOVWF  FE9
5132:  MOVLW  08
5134:  ADDWFC 03,W
5136:  MOVWF  FEA
5138:  MOVFF  1CD,FEF
....................          carddata[countbyte++]=sec;    
513C:  MOVF   x54,W
513E:  INCF   x54,F
5140:  CLRF   03
5142:  ADDLW  57
5144:  MOVWF  FE9
5146:  MOVLW  08
5148:  ADDWFC 03,W
514A:  MOVWF  FEA
514C:  MOVFF  1CE,FEF
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
5150:  MOVLB  6
5152:  CLRF   xD4
5154:  CLRF   xD3
5156:  MOVF   xD4,F
5158:  BNZ   519A
515A:  MOVF   xD3,W
515C:  SUBLW  4E
515E:  BNC   519A
....................          { 
....................             carddata[countbyte++] = (INT8)((Track1[countbit]&0b00111111)+0x20);       
5160:  MOVLB  8
5162:  MOVF   x54,W
5164:  INCF   x54,F
5166:  CLRF   03
5168:  ADDLW  57
516A:  MOVWF  01
516C:  MOVLW  08
516E:  ADDWFC 03,F
5170:  MOVLW  CF
5172:  MOVLB  6
5174:  ADDWF  xD3,W
5176:  MOVWF  FE9
5178:  MOVLW  01
517A:  ADDWFC xD4,W
517C:  MOVWF  FEA
517E:  MOVF   FEF,W
5180:  ANDLW  3F
5182:  ADDLW  20
5184:  MOVLB  8
5186:  MOVFF  03,FEA
518A:  MOVFF  01,FE9
518E:  MOVWF  FEF
....................          } 
5190:  MOVLB  6
5192:  INCF   xD3,F
5194:  BTFSC  FD8.2
5196:  INCF   xD4,F
5198:  BRA    5156
....................          memset(Track1,0,sizeof(Track1)); 
519A:  MOVLW  01
519C:  MOVWF  FEA
519E:  MOVLW  CF
51A0:  MOVWF  FE9
51A2:  CLRF   00
51A4:  CLRF   02
51A6:  MOVLW  4F
51A8:  MOVWF  01
51AA:  MOVLB  0
51AC:  CALL   359A
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
51B0:  MOVLB  6
51B2:  CLRF   xD4
51B4:  CLRF   xD3
51B6:  MOVF   xD4,F
51B8:  BNZ   51FA
51BA:  MOVF   xD3,W
51BC:  SUBLW  27
51BE:  BNC   51FA
....................          { 
....................             carddata[countbyte++] = (INT8)((Track2[countbit]&0b00001111)+0x30);            
51C0:  MOVLB  8
51C2:  MOVF   x54,W
51C4:  INCF   x54,F
51C6:  CLRF   03
51C8:  ADDLW  57
51CA:  MOVWF  01
51CC:  MOVLW  08
51CE:  ADDWFC 03,F
51D0:  MOVLW  1E
51D2:  MOVLB  6
51D4:  ADDWF  xD3,W
51D6:  MOVWF  FE9
51D8:  MOVLW  02
51DA:  ADDWFC xD4,W
51DC:  MOVWF  FEA
51DE:  MOVF   FEF,W
51E0:  ANDLW  0F
51E2:  ADDLW  30
51E4:  MOVLB  8
51E6:  MOVFF  03,FEA
51EA:  MOVFF  01,FE9
51EE:  MOVWF  FEF
....................          }  
51F0:  MOVLB  6
51F2:  INCF   xD3,F
51F4:  BTFSC  FD8.2
51F6:  INCF   xD4,F
51F8:  BRA    51B6
....................          for(i=countbyte;i<numdataofonecard;i++) 
51FA:  MOVFF  854,851
51FE:  MOVLB  8
5200:  MOVF   x51,W
5202:  SUBLW  7F
5204:  BNC   521A
....................          { 
....................              carddata[i] = 0; 
5206:  CLRF   03
5208:  MOVF   x51,W
520A:  ADDLW  57
520C:  MOVWF  FE9
520E:  MOVLW  08
5210:  ADDWFC 03,W
5212:  MOVWF  FEA
5214:  CLRF   FEF
....................          } 
5216:  INCF   x51,F
5218:  BRA    5200
....................          for(i=0;i<8;i++) 
521A:  CLRF   x51
521C:  MOVF   x51,W
521E:  SUBLW  07
5220:  BNC   52D6
....................          { 
....................              for(j=0;j<16;j++) 
5222:  CLRF   x52
5224:  MOVF   x52,W
5226:  SUBLW  0F
5228:  BNC   5262
....................              { 
....................                 encryptblock[j] = carddata[i*16+j]; 
522A:  CLRF   03
522C:  MOVF   x52,W
522E:  ADDLW  D7
5230:  MOVWF  01
5232:  MOVLW  08
5234:  ADDWFC 03,F
5236:  MOVFF  03,8F8
523A:  MOVF   x51,W
523C:  MULLW  10
523E:  MOVF   FF3,W
5240:  ADDWF  x52,W
5242:  CLRF   03
5244:  ADDLW  57
5246:  MOVWF  FE9
5248:  MOVLW  08
524A:  ADDWFC 03,W
524C:  MOVWF  FEA
524E:  MOVFF  FEF,8F9
5252:  MOVFF  8F8,FEA
5256:  MOVFF  01,FE9
525A:  MOVFF  8F9,FEF
....................              } 
525E:  INCF   x52,F
5260:  BRA    5224
....................              EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
5262:  MOVLB  9
5264:  CLRF   x07
5266:  CLRF   x06
5268:  CLRF   x05
526A:  MOVLW  3F
526C:  MOVWF  x04
526E:  CLRF   x0B
5270:  CLRF   x0A
5272:  CLRF   x09
5274:  MOVLW  20
5276:  MOVWF  x08
5278:  MOVLW  01
527A:  MOVWF  x0D
527C:  MOVWF  x0C
527E:  MOVLB  0
5280:  CALL   4004
....................              aes_enc_dec((unsigned int8 *)&encryptblock[0], (unsigned int8 *)&crypto_key[0],0); 
5284:  MOVLW  08
5286:  MOVLB  8
5288:  MOVWF  xF8
528A:  MOVLW  D7
528C:  MOVWF  xF7
528E:  MOVLW  01
5290:  MOVWF  xFA
5292:  MOVWF  xF9
5294:  CLRF   xFB
5296:  MOVLB  0
5298:  CALL   40FA
....................              /*for(u=0;u<16;u++) 
....................              { 
....................                 encryptblock[u];  
....................                 fprintf(COM2,"%x",encryptblock[u]); 
....................              }*/ 
....................              EEPROM_write(ptr_card,16,encryptblock); 
529C:  MOVFF  23,903
52A0:  MOVFF  22,902
52A4:  MOVFF  21,901
52A8:  MOVFF  20,900
52AC:  MOVLB  9
52AE:  CLRF   x07
52B0:  CLRF   x06
52B2:  CLRF   x05
52B4:  MOVLW  10
52B6:  MOVWF  x04
52B8:  MOVLW  08
52BA:  MOVWF  x09
52BC:  MOVLW  D7
52BE:  MOVWF  x08
52C0:  MOVLB  0
52C2:  RCALL  4EF6
....................              ptr_card=ptr_card+16; 
52C4:  MOVLW  10
52C6:  ADDWF  20,F
52C8:  MOVLW  00
52CA:  ADDWFC 21,F
52CC:  ADDWFC 22,F
52CE:  ADDWFC 23,F
....................          } 
52D0:  MOVLB  8
52D2:  INCF   x51,F
52D4:  BRA    521C
....................          fprintf(COM2,"\r\n"); 
52D6:  MOVLW  0D
52D8:  MOVLB  9
52DA:  MOVWF  x0C
52DC:  MOVLB  0
52DE:  CALL   1604
52E2:  MOVLW  0A
52E4:  MOVLB  9
52E6:  MOVWF  x0C
52E8:  MOVLB  0
52EA:  CALL   1604
....................          fprintf(COM2,"card data: %lu",ptr_card); 
52EE:  MOVLW  04
52F0:  MOVWF  FF6
52F2:  MOVLW  06
52F4:  MOVWF  FF7
52F6:  MOVLW  0B
52F8:  MOVLB  8
52FA:  MOVWF  xF7
52FC:  MOVLB  0
52FE:  CALL   164A
5302:  MOVLW  41
5304:  MOVWF  FE9
5306:  MOVFF  23,8FA
530A:  MOVFF  22,8F9
530E:  MOVFF  21,8F8
5312:  MOVFF  20,8F7
5316:  CALL   22FA
....................          fprintf(COM2,"\r\n"); 
531A:  MOVLW  0D
531C:  MOVLB  9
531E:  MOVWF  x0C
5320:  MOVLB  0
5322:  CALL   1604
5326:  MOVLW  0A
5328:  MOVLB  9
532A:  MOVWF  x0C
532C:  MOVLB  0
532E:  CALL   1604
....................          EEPROM_read(ptr_card-128,128,&carddata); 
5332:  MOVLW  80
5334:  SUBWF  20,W
5336:  MOVLB  8
5338:  MOVWF  xF7
533A:  MOVLW  00
533C:  SUBWFB 21,W
533E:  MOVWF  xF8
5340:  MOVLW  00
5342:  SUBWFB 22,W
5344:  MOVWF  xF9
5346:  MOVLW  00
5348:  SUBWFB 23,W
534A:  MOVWF  xFA
534C:  MOVFF  FE8,907
5350:  MOVFF  8F9,906
5354:  MOVFF  8F8,905
5358:  MOVFF  8F7,904
535C:  MOVLB  9
535E:  CLRF   x0B
5360:  CLRF   x0A
5362:  CLRF   x09
5364:  MOVLW  80
5366:  MOVWF  x08
5368:  MOVLW  08
536A:  MOVWF  x0D
536C:  MOVLW  57
536E:  MOVWF  x0C
5370:  MOVLB  0
5372:  CALL   4004
....................          for(i=0;i<numdataofonecard;i++) 
5376:  MOVLB  8
5378:  CLRF   x51
537A:  MOVF   x51,W
537C:  SUBLW  7F
537E:  BNC   53A6
....................          { 
....................              fprintf(COM2,"%x",carddata[i]); 
5380:  CLRF   03
5382:  MOVF   x51,W
5384:  ADDLW  57
5386:  MOVWF  FE9
5388:  MOVLW  08
538A:  ADDWFC 03,W
538C:  MOVWF  FEA
538E:  MOVFF  FEF,8F7
5392:  MOVFF  8F7,901
5396:  MOVLW  57
5398:  MOVLB  9
539A:  MOVWF  x02
539C:  MOVLB  0
539E:  RCALL  4F86
....................          } 
53A0:  MOVLB  8
53A2:  INCF   x51,F
53A4:  BRA    537A
....................          memset(Track2,0,sizeof(Track2)); 
53A6:  MOVLW  02
53A8:  MOVWF  FEA
53AA:  MOVLW  1E
53AC:  MOVWF  FE9
53AE:  CLRF   00
53B0:  CLRF   02
53B2:  MOVLW  28
53B4:  MOVWF  01
53B6:  MOVLB  0
53B8:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
53BC:  MOVLW  0D
53BE:  MOVLB  9
53C0:  MOVWF  x0C
53C2:  MOVLB  0
53C4:  CALL   1604
53C8:  MOVLW  0A
53CA:  MOVLB  9
53CC:  MOVWF  x0C
53CE:  MOVLB  0
53D0:  CALL   1604
....................         fprintf(COM2,"Done"); 
53D4:  MOVLW  14
53D6:  MOVWF  FF6
53D8:  MOVLW  06
53DA:  MOVWF  FF7
53DC:  CALL   172E
....................              
....................         fprintf(COM2,"\r\n"); 
53E0:  MOVLW  0D
53E2:  MOVLB  9
53E4:  MOVWF  x0C
53E6:  MOVLB  0
53E8:  CALL   1604
53EC:  MOVLW  0A
53EE:  MOVLB  9
53F0:  MOVWF  x0C
53F2:  MOVLB  0
53F4:  CALL   1604
....................         fprintf(COM2,"Waiting for PIN number"); 
53F8:  MOVLW  1A
53FA:  MOVWF  FF6
53FC:  MOVLW  06
53FE:  MOVWF  FF7
5400:  CALL   172E
....................         memset(key_data,0,sizeof(key_data));  
5404:  MOVLW  01
5406:  MOVWF  FEA
5408:  MOVLW  4A
540A:  MOVWF  FE9
540C:  CLRF   00
540E:  CLRF   02
5410:  MOVLW  10
5412:  MOVWF  01
5414:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
5418:  MOVLW  0D
541A:  MOVLB  9
541C:  MOVWF  x0C
541E:  MOVLB  0
5420:  CALL   1604
5424:  MOVLW  0A
5426:  MOVLB  9
5428:  MOVWF  x0C
542A:  MOVLB  0
542C:  CALL   1604
....................         charac_timeout=0; 
5430:  MOVLB  1
5432:  CLRF   x00
5434:  MOVLB  0
5436:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       //ptr_card = ptr_card+numdataofonecard; 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5438:  MOVFF  23,8FA
543C:  MOVFF  22,8F9
5440:  MOVFF  21,8F8
5444:  MOVFF  20,8F7
5448:  MOVLW  19
544A:  MOVLB  8
544C:  MOVWF  xFB
544E:  MOVLB  0
5450:  CALL   3B6A
....................       datinbuf=0; 
5454:  MOVLB  6
5456:  CLRF   xD5
....................       saving_flag=0; 
5458:  CLRF   xD8
....................       data_avai=1; 
545A:  MOVLW  01
545C:  MOVWF  xD9
....................       enable_getpin=1; 
545E:  MOVLB  1
5460:  MOVWF  x45
....................       charac_timeout=0; 
5462:  CLRF   x00
5464:  MOVLB  0
5466:  CLRF   xFF
....................       key_count_ms=0; 
5468:  MOVLB  1
546A:  CLRF   x47
546C:  MOVLB  8
546E:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
5470:  MOVLB  0
5472:  GOTO   5A7A (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
18EE:  MOVLW  01
18F0:  MOVLB  8
18F2:  MOVWF  x4D
18F4:  MOVWF  x4E
18F6:  MOVWF  x4F
18F8:  MOVWF  x50
18FA:  CLRF   x51
18FC:  MOVWF  x52
18FE:  MOVWF  x53
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1900:  MOVLB  6
1902:  CLRF   xD2
1904:  CLRF   xD1
....................    mcr_timeout=0; 
1906:  CLRF   xC7
1908:  CLRF   xC6
190A:  CLRF   xC5
190C:  CLRF   xC4
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
190E:  MOVF   xD2,W
1910:  SUBLW  FD
1912:  BNC   1930
1914:  BNZ   191C
1916:  MOVF   xD1,W
1918:  SUBLW  E7
191A:  BNC   1930
191C:  BSF    F93.1
191E:  BTFSS  F81.1
1920:  BRA    1930
1922:  BSF    F94.5
1924:  BTFSS  F82.5
1926:  BRA    1930
....................       card_timeout++; 
1928:  INCF   xD1,F
192A:  BTFSC  FD8.2
192C:  INCF   xD2,F
....................    } 
192E:  BRA    190E
....................    card_timeout=0; 
1930:  CLRF   xD2
1932:  CLRF   xD1
....................    buffertrack1[bug_countbit_T1++]=0; 
1934:  MOVFF  6CE,03
1938:  MOVF   xCD,W
193A:  INCF   xCD,F
193C:  BTFSC  FD8.2
193E:  INCF   xCE,F
1940:  MOVLB  8
1942:  MOVWF  x56
1944:  MOVLW  46
1946:  ADDWF  x56,W
1948:  MOVWF  FE9
194A:  MOVLW  02
194C:  ADDWFC 03,W
194E:  MOVWF  FEA
1950:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1952:  MOVLB  6
1954:  MOVFF  6CE,03
1958:  MOVF   xCD,W
195A:  INCF   xCD,F
195C:  BTFSC  FD8.2
195E:  INCF   xCE,F
1960:  MOVLB  8
1962:  MOVWF  x56
1964:  MOVLW  46
1966:  ADDWF  x56,W
1968:  MOVWF  FE9
196A:  MOVLW  02
196C:  ADDWFC 03,W
196E:  MOVWF  FEA
1970:  MOVLW  01
1972:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1974:  MOVLB  6
1976:  MOVFF  6D0,03
197A:  MOVF   xCF,W
197C:  INCF   xCF,F
197E:  BTFSC  FD8.2
1980:  INCF   xD0,F
1982:  MOVLB  8
1984:  MOVWF  x56
1986:  MOVLW  98
1988:  ADDWF  x56,W
198A:  MOVWF  FE9
198C:  MOVLW  05
198E:  ADDWFC 03,W
1990:  MOVWF  FEA
1992:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1994:  MOVLB  6
1996:  MOVFF  6D0,03
199A:  MOVF   xCF,W
199C:  INCF   xCF,F
199E:  BTFSC  FD8.2
19A0:  INCF   xD0,F
19A2:  MOVLB  8
19A4:  MOVWF  x56
19A6:  MOVLW  98
19A8:  ADDWF  x56,W
19AA:  MOVWF  FE9
19AC:  MOVLW  05
19AE:  ADDWFC 03,W
19B0:  MOVWF  FEA
19B2:  MOVLW  01
19B4:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
19B6:  MOVLB  6
19B8:  MOVF   xCE,W
19BA:  SUBLW  03
19BC:  BTFSS  FD8.0
19BE:  BRA    1A9E
19C0:  BNZ   19CA
19C2:  MOVF   xCD,W
19C4:  SUBLW  51
19C6:  BTFSS  FD8.0
19C8:  BRA    1A9E
19CA:  MOVF   xD0,W
19CC:  SUBLW  01
19CE:  BTFSS  FD8.0
19D0:  BRA    1A9E
19D2:  BNZ   19DA
19D4:  MOVF   xCF,W
19D6:  SUBLW  2B
19D8:  BNC   1A9E
19DA:  MOVF   xD2,W
19DC:  SUBLW  FF
19DE:  BNC   1A9E
19E0:  BNZ   19E8
19E2:  MOVF   xD1,W
19E4:  SUBLW  DB
19E6:  BNC   1A9E
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
19E8:  MOVF   xDB,F
19EA:  BZ    19F4
....................          { 
....................             bug_countbit_T1=0; 
19EC:  CLRF   xCE
19EE:  CLRF   xCD
....................             bug_countbit_T2=0; 
19F0:  CLRF   xD0
19F2:  CLRF   xCF
....................          } 
....................          card_timeout++; 
19F4:  INCF   xD1,F
19F6:  BTFSC  FD8.2
19F8:  INCF   xD2,F
....................          mcr_timeout=0; 
19FA:  CLRF   xC7
19FC:  CLRF   xC6
19FE:  CLRF   xC5
1A00:  CLRF   xC4
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1A02:  BSF    F93.2
1A04:  MOVLB  8
1A06:  CLRF   x4D
1A08:  BTFSC  F81.2
1A0A:  INCF   x4D,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1A0C:  MOVF   x4D,F
1A0E:  BNZ   1A4C
1A10:  DECFSZ x4E,W
1A12:  BRA    1A4C
....................          { 
....................             ST1_old = 0; 
1A14:  CLRF   x4E
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1A16:  MOVLW  46
1A18:  MOVLB  6
1A1A:  ADDWF  xCD,W
1A1C:  MOVWF  FE9
1A1E:  MOVLW  02
1A20:  ADDWFC xCE,W
1A22:  MOVWF  FEA
1A24:  BSF    F93.1
1A26:  MOVLW  00
1A28:  BTFSS  F81.1
1A2A:  MOVLW  01
1A2C:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1A2E:  MOVLW  98
1A30:  ADDWF  xCF,W
1A32:  MOVWF  FE9
1A34:  MOVLW  05
1A36:  ADDWFC xD0,W
1A38:  MOVWF  FEA
1A3A:  MOVFF  851,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1A3E:  INCF   xCD,F
1A40:  BTFSC  FD8.2
1A42:  INCF   xCE,F
....................             card_timeout=0; 
1A44:  CLRF   xD2
1A46:  CLRF   xD1
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A48:  BRA    1A56
1A4A:  MOVLB  8
1A4C:  DECFSZ x4D,W
1A4E:  BRA    1A54
1A50:  MOVLW  01
1A52:  MOVWF  x4E
1A54:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A56:  BSF    F93.3
1A58:  MOVLB  8
1A5A:  CLRF   x4F
1A5C:  BTFSC  F81.3
1A5E:  INCF   x4F,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A60:  MOVF   x4F,F
1A62:  BNZ   1A82
1A64:  DECFSZ x50,W
1A66:  BRA    1A82
....................          { 
....................             ST2_old = 0; 
1A68:  CLRF   x50
....................             Bit_t2 = !input(MCR_DATA2); 
1A6A:  BSF    F94.5
1A6C:  CLRF   x51
1A6E:  BTFSS  F82.5
1A70:  INCF   x51,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A72:  MOVLB  6
1A74:  INCF   xCF,F
1A76:  BTFSC  FD8.2
1A78:  INCF   xD0,F
....................             card_timeout=0; 
1A7A:  CLRF   xD2
1A7C:  CLRF   xD1
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A7E:  BRA    1A8C
1A80:  MOVLB  8
1A82:  DECFSZ x4F,W
1A84:  BRA    1A8A
1A86:  MOVLW  01
1A88:  MOVWF  x50
1A8A:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1A8C:  BSF    F93.0
1A8E:  BTFSS  F81.0
1A90:  BRA    1A9C
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1A92:  CLRF   xDB
....................             card_timeout=65500; 
1A94:  SETF   xD2
1A96:  MOVLW  DC
1A98:  MOVWF  xD1
....................             break;            
1A9A:  BRA    1A9E
....................          } 
....................       } 
1A9C:  BRA    19B8
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1A9E:  CLRF   xD2
1AA0:  CLRF   xD1
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1AA2:  MOVLB  9
1AA4:  CLRF   x15
1AA6:  MOVFF  6CE,917
1AAA:  MOVFF  6CD,916
1AAE:  MOVLW  02
1AB0:  MOVWF  x19
1AB2:  MOVLW  46
1AB4:  MOVWF  x18
1AB6:  MOVLB  0
1AB8:  CALL   0A02
1ABC:  MOVFF  01,852
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1AC0:  MOVLW  01
1AC2:  MOVLB  9
1AC4:  MOVWF  x15
1AC6:  MOVFF  6D0,917
1ACA:  MOVFF  6CF,916
1ACE:  MOVLW  05
1AD0:  MOVWF  x19
1AD2:  MOVLW  98
1AD4:  MOVWF  x18
1AD6:  MOVLB  0
1AD8:  CALL   0A02
1ADC:  MOVFF  01,853
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1AE0:  MOVLB  6
1AE2:  DECFSZ xD6,W
1AE4:  BRA    1B7A
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1AE6:  MOVLW  32
1AE8:  MOVWF  FF6
1AEA:  MOVLW  06
1AEC:  MOVWF  FF7
1AEE:  MOVLW  0E
1AF0:  MOVLB  8
1AF2:  MOVWF  xF7
1AF4:  MOVLB  0
1AF6:  RCALL  164A
1AF8:  MOVLW  10
1AFA:  MOVWF  FE9
1AFC:  MOVFF  6CE,857
1B00:  MOVFF  6CD,856
1B04:  RCALL  1672
1B06:  MOVLW  0D
1B08:  MOVLB  9
1B0A:  MOVWF  x0C
1B0C:  MOVLB  0
1B0E:  RCALL  1604
1B10:  MOVLW  0A
1B12:  MOVLB  9
1B14:  MOVWF  x0C
1B16:  MOVLB  0
1B18:  RCALL  1604
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1B1A:  MOVLW  46
1B1C:  MOVWF  FF6
1B1E:  MOVLW  06
1B20:  MOVWF  FF7
1B22:  MOVLW  0E
1B24:  MOVLB  8
1B26:  MOVWF  xF7
1B28:  MOVLB  0
1B2A:  RCALL  164A
1B2C:  MOVLW  10
1B2E:  MOVWF  FE9
1B30:  MOVFF  6D0,857
1B34:  MOVFF  6CF,856
1B38:  RCALL  1672
1B3A:  MOVLW  0D
1B3C:  MOVLB  9
1B3E:  MOVWF  x0C
1B40:  MOVLB  0
1B42:  RCALL  1604
1B44:  MOVLW  0A
1B46:  MOVLB  9
1B48:  MOVWF  x0C
1B4A:  MOVLB  0
1B4C:  RCALL  1604
....................          debug_reader();       
1B4E:  BRA    1836
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B50:  MOVLB  8
1B52:  MOVF   x52,F
1B54:  BNZ   1B64
1B56:  MOVLW  5A
1B58:  MOVWF  FF6
1B5A:  MOVLW  06
1B5C:  MOVWF  FF7
1B5E:  MOVLB  0
1B60:  RCALL  172E
1B62:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B64:  MOVF   x53,F
1B66:  BNZ   1B76
1B68:  MOVLW  70
1B6A:  MOVWF  FF6
1B6C:  MOVLW  06
1B6E:  MOVWF  FF7
1B70:  MOVLB  0
1B72:  RCALL  172E
1B74:  MOVLB  8
....................       } 
....................          else 
1B76:  BRA    1B86
1B78:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B7A:  MOVLW  0F
1B7C:  MOVLB  8
1B7E:  MOVWF  x56
1B80:  MOVLB  0
1B82:  RCALL  18C6
1B84:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1B86:  MOVF   x52,F
1B88:  BZ    1B8E
1B8A:  MOVF   x53,F
1B8C:  BNZ   1BAE
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1B8E:  MOVLB  6
1B90:  CLRF   xD0
1B92:  CLRF   xCF
....................          bug_countbit_T1=0; 
1B94:  CLRF   xCE
1B96:  CLRF   xCD
....................          reading_fg=0; 
1B98:  CLRF   xDA
....................          count_reading_error++; 
1B9A:  INCF   xDB,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1B9C:  CLRF   xC7
1B9E:  CLRF   xC6
1BA0:  CLRF   xC5
1BA2:  CLRF   xC4
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1BA4:  MOVLW  00
1BA6:  MOVWF  01
1BA8:  BRA    1BE8
....................       } 
....................          else  
1BAA:  BRA    1BE4
1BAC:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1BAE:  MOVLW  01
1BB0:  MOVLB  6
1BB2:  MOVWF  xD5
....................             reading_fg=1; 
1BB4:  MOVWF  xDA
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1BB6:  MOVFF  6D0,6CC
1BBA:  MOVFF  6CF,6CB
....................             countbit_T1=bug_countbit_T1; 
1BBE:  MOVFF  6CE,6CA
1BC2:  MOVFF  6CD,6C9
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1BC6:  CLRF   xCE
1BC8:  CLRF   xCD
....................             bug_countbit_T2=0;  
1BCA:  CLRF   xD0
1BCC:  CLRF   xCF
....................             mcr_timeout=0; 
1BCE:  CLRF   xC7
1BD0:  CLRF   xC6
1BD2:  CLRF   xC5
1BD4:  CLRF   xC4
....................             charac_timeout=0; 
1BD6:  MOVLB  1
1BD8:  CLRF   x00
1BDA:  MOVLB  0
1BDC:  CLRF   xFF
....................             return 1; 
1BDE:  MOVWF  01
1BE0:  MOVLB  6
1BE2:  BRA    1BE8
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1BE4:  MOVLW  00
1BE6:  MOVWF  01
.................... } 
1BE8:  MOVLB  0
1BEA:  GOTO   1C10 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       delay_us(500); 
1BEE:  MOVLW  02
1BF0:  MOVLB  8
1BF2:  MOVWF  x4D
1BF4:  MOVLW  FA
1BF6:  MOVWF  x4E
1BF8:  MOVLB  0
1BFA:  GOTO   0686
1BFE:  MOVLB  8
1C00:  DECFSZ x4D,F
1C02:  BRA    1BF4
....................       if(saving_flag==1) return;      
1C04:  MOVLB  6
1C06:  DECFSZ xD8,W
1C08:  BRA    1C0C
1C0A:  BRA    1C22
....................       cardread_st=mcr_read(); 
1C0C:  MOVLB  0
1C0E:  BRA    18EE
1C10:  MOVFF  01,6D7
....................       mcr_timeout=0; 
1C14:  MOVLB  6
1C16:  CLRF   xC7
1C18:  CLRF   xC6
1C1A:  CLRF   xC5
1C1C:  CLRF   xC4
....................       card_timeout=0;      
1C1E:  CLRF   xD2
1C20:  CLRF   xD1
.................... } 
.................... //==================================== 
.................... #if 0 
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... #endif 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
1C22:  BCF    FF0.0
1C24:  MOVLB  0
1C26:  GOTO   006C
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
6A0C:  CLRF   19
6A0E:  BTFSC  FF2.7
6A10:  BSF    19.7
6A12:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
6A14:  MOVLB  9
6A16:  CLRF   x16
6A18:  CLRF   x15
6A1A:  CLRF   x14
6A1C:  MOVLW  3C
6A1E:  MOVWF  x13
6A20:  MOVLW  03
6A22:  MOVWF  x17
6A24:  MOVLB  0
6A26:  CALL   3A6C
6A2A:  BTFSC  19.7
6A2C:  BSF    FF2.7
6A2E:  CLRF   19
6A30:  BTFSC  FF2.7
6A32:  BSF    19.7
6A34:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
6A36:  MOVLB  9
6A38:  CLRF   x16
6A3A:  CLRF   x15
6A3C:  CLRF   x14
6A3E:  MOVLW  3A
6A40:  MOVWF  x13
6A42:  MOVLW  01
6A44:  MOVWF  x17
6A46:  MOVLB  0
6A48:  CALL   3A6C
6A4C:  BTFSC  19.7
6A4E:  BSF    FF2.7
6A50:  CLRF   19
6A52:  BTFSC  FF2.7
6A54:  BSF    19.7
6A56:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV);  
6A58:  MOVLB  9
6A5A:  CLRF   x1B
6A5C:  CLRF   x1A
6A5E:  CLRF   x19
6A60:  MOVLW  3A
6A62:  MOVWF  x18
6A64:  MOVLB  0
6A66:  CALL   3450
6A6A:  BTFSC  19.7
6A6C:  BSF    FF2.7
6A6E:  MOVFF  01,6E2
.................... } 
6A72:  GOTO   6E16 (RETURN)
.................... //================================ 
.................... void downloaddataregular() 
.................... { 
*
627A:  MOVLB  7
627C:  CLRF   xF6
627E:  CLRF   xF5
....................     int8 index,i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 temp[50]; 
....................     rec[0]=0; 
6280:  MOVLB  0
6282:  CLRF   x7D
6284:  CLRF   19
6286:  BTFSC  FF2.7
6288:  BSF    19.7
628A:  BCF    FF2.7
....................     count_card_tg=get_countcard(); 
628C:  CALL   351C
6290:  BTFSC  19.7
6292:  BSF    FF2.7
6294:  MOVFF  02,6E1
6298:  MOVFF  01,6E0
629C:  CLRF   19
629E:  BTFSC  FF2.7
62A0:  BSF    19.7
62A2:  BCF    FF2.7
....................     adr=count_card*numdata; 
62A4:  MOVFF  6DF,856
62A8:  MOVFF  6DE,855
62AC:  MOVLB  8
62AE:  CLRF   x58
62B0:  MOVLW  7C
62B2:  MOVWF  x57
62B4:  MOVLB  0
62B6:  CALL   3578
62BA:  BTFSC  19.7
62BC:  BSF    FF2.7
62BE:  MOVFF  02,7F6
62C2:  MOVFF  01,7F5
....................     addr_key=EEPROM_KEY_ST; 
62C6:  MOVLB  6
62C8:  CLRF   xE6
62CA:  MOVLW  01
62CC:  MOVWF  xE5
62CE:  MOVLW  C3
62D0:  MOVWF  xE4
62D2:  MOVLW  0F
62D4:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
62D6:  MOVF   xDF,W
62D8:  SUBWF  xE1,W
62DA:  BTFSS  FD8.0
62DC:  BRA    6676
62DE:  BNZ   62E8
62E0:  MOVF   xDE,W
62E2:  SUBWF  xE0,W
62E4:  BTFSS  FD8.0
62E6:  BRA    6676
62E8:  CLRF   19
62EA:  BTFSC  FF2.7
62EC:  BSF    19.7
62EE:  BCF    FF2.7
....................         adr=count_card*numdata+ptr_start; 
62F0:  MOVFF  6DF,856
62F4:  MOVFF  6DE,855
62F8:  MOVLB  8
62FA:  CLRF   x58
62FC:  MOVLW  7C
62FE:  MOVWF  x57
6300:  MOVLB  0
6302:  CALL   3578
6306:  BTFSC  19.7
6308:  BSF    FF2.7
630A:  MOVLW  96
630C:  MOVLB  8
630E:  ADDWF  01,W
6310:  MOVLB  7
6312:  MOVWF  xF5
6314:  MOVLW  00
6316:  MOVLB  8
6318:  ADDWFC 02,W
631A:  MOVLB  7
631C:  MOVWF  xF6
....................         EEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
631E:  MOVLW  7C
6320:  SUBWF  xF5,W
6322:  MOVLB  8
6324:  MOVWF  x2B
6326:  MOVLW  00
6328:  MOVLB  7
632A:  SUBWFB xF6,W
632C:  MOVLB  8
632E:  MOVWF  x2C
6330:  CLRF   19
6332:  BTFSC  FF2.7
6334:  BSF    19.7
6336:  BCF    FF2.7
6338:  MOVLB  9
633A:  CLRF   x07
633C:  CLRF   x06
633E:  MOVWF  x05
6340:  MOVFF  82B,904
6344:  CLRF   x0B
6346:  CLRF   x0A
6348:  CLRF   x09
634A:  MOVLW  7C
634C:  MOVWF  x08
634E:  CLRF   x0D
6350:  MOVLW  7D
6352:  MOVWF  x0C
6354:  MOVLB  0
6356:  CALL   4004
635A:  BTFSC  19.7
635C:  BSF    FF2.7
....................         fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
635E:  MOVLW  10
6360:  MOVWF  FE9
6362:  CLRF   19
6364:  BTFSC  FF2.7
6366:  BSF    19.7
6368:  BCF    FF2.7
636A:  MOVFF  6DF,851
636E:  MOVFF  6DE,850
6372:  CALL   58F8
6376:  BTFSC  19.7
6378:  BSF    FF2.7
637A:  CLRF   19
637C:  BTFSC  FF2.7
637E:  BSF    19.7
6380:  BCF    FF2.7
6382:  MOVLW  29
6384:  MOVLB  9
6386:  MOVWF  x0C
6388:  MOVLB  0
638A:  CALL   1604
638E:  BTFSC  19.7
6390:  BSF    FF2.7
6392:  MOVFF  7D,82B
6396:  MOVLW  01
6398:  MOVLB  8
639A:  MOVWF  x2C
639C:  MOVLB  0
639E:  RCALL  6164
63A0:  CLRF   19
63A2:  BTFSC  FF2.7
63A4:  BSF    19.7
63A6:  BCF    FF2.7
63A8:  MOVLW  2F
63AA:  MOVLB  9
63AC:  MOVWF  x0C
63AE:  MOVLB  0
63B0:  CALL   1604
63B4:  BTFSC  19.7
63B6:  BSF    FF2.7
63B8:  MOVFF  7E,82B
63BC:  MOVLW  01
63BE:  MOVLB  8
63C0:  MOVWF  x2C
63C2:  MOVLB  0
63C4:  RCALL  6164
63C6:  CLRF   19
63C8:  BTFSC  FF2.7
63CA:  BSF    19.7
63CC:  BCF    FF2.7
63CE:  MOVLW  20
63D0:  MOVLB  9
63D2:  MOVWF  x0C
63D4:  MOVLB  0
63D6:  CALL   1604
63DA:  BTFSC  19.7
63DC:  BSF    FF2.7
63DE:  MOVFF  7F,82B
63E2:  MOVLW  01
63E4:  MOVLB  8
63E6:  MOVWF  x2C
63E8:  MOVLB  0
63EA:  RCALL  6164
63EC:  CLRF   19
63EE:  BTFSC  FF2.7
63F0:  BSF    19.7
63F2:  BCF    FF2.7
63F4:  MOVLW  3A
63F6:  MOVLB  9
63F8:  MOVWF  x0C
63FA:  MOVLB  0
63FC:  CALL   1604
6400:  BTFSC  19.7
6402:  BSF    FF2.7
6404:  MOVFF  80,82B
6408:  MOVLW  01
640A:  MOVLB  8
640C:  MOVWF  x2C
640E:  MOVLB  0
6410:  RCALL  6164
6412:  CLRF   19
6414:  BTFSC  FF2.7
6416:  BSF    19.7
6418:  BCF    FF2.7
641A:  MOVLW  3A
641C:  MOVLB  9
641E:  MOVWF  x0C
6420:  MOVLB  0
6422:  CALL   1604
6426:  BTFSC  19.7
6428:  BSF    FF2.7
642A:  MOVFF  81,82B
642E:  MOVLW  01
6430:  MOVLB  8
6432:  MOVWF  x2C
6434:  MOVLB  0
6436:  RCALL  6164
....................         ee_dat=0; 
6438:  MOVLB  6
643A:  CLRF   xDD
....................         index=0; 
643C:  MOVLB  7
643E:  CLRF   xF3
....................         fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
6440:  MOVLW  2A
6442:  MOVWF  FF6
6444:  MOVLW  1C
6446:  MOVWF  FF7
6448:  CLRF   19
644A:  BTFSC  FF2.7
644C:  BSF    19.7
644E:  BCF    FF2.7
6450:  MOVLB  0
6452:  CALL   172E
6456:  BTFSC  19.7
6458:  BSF    FF2.7
....................         while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................         { 
645A:  MOVLB  7
645C:  MOVF   xF3,W
645E:  SUBLW  4E
6460:  BNC   64BE
6462:  MOVLB  6
6464:  MOVF   xDD,W
6466:  SUBLW  3F
6468:  BTFSS  FD8.2
646A:  BRA    6470
646C:  MOVLB  7
646E:  BRA    64BE
....................            ee_dat = rec[index+5]; 
6470:  MOVLW  05
6472:  MOVLB  7
6474:  ADDWF  xF3,W
6476:  CLRF   03
6478:  ADDLW  7D
647A:  MOVWF  FE9
647C:  MOVLW  00
647E:  ADDWFC 03,W
6480:  MOVWF  FEA
6482:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
6486:  MOVLB  6
6488:  MOVF   xDD,W
648A:  SUBLW  1F
648C:  BC    64AA
648E:  MOVF   xDD,W
6490:  SUBLW  7E
6492:  BNC   64AA
6494:  CLRF   19
6496:  BTFSC  FF2.7
6498:  BSF    19.7
649A:  BCF    FF2.7
649C:  MOVFF  6DD,90C
64A0:  MOVLB  0
64A2:  CALL   1604
64A6:  BTFSC  19.7
64A8:  BSF    FF2.7
....................            index++; 
64AA:  MOVLB  7
64AC:  INCF   xF3,F
....................            if(ee_dat==0)break; 
64AE:  MOVLB  6
64B0:  MOVF   xDD,F
64B2:  BNZ   64B8
64B4:  MOVLB  7
64B6:  BRA    64BE
....................         } 
64B8:  MOVLB  0
64BA:  BRA    645A
64BC:  MOVLB  7
....................         fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
64BE:  MOVLW  3C
64C0:  MOVWF  FF6
64C2:  MOVLW  1C
64C4:  MOVWF  FF7
64C6:  CLRF   19
64C8:  BTFSC  FF2.7
64CA:  BSF    19.7
64CC:  BCF    FF2.7
64CE:  MOVLB  0
64D0:  CALL   172E
64D4:  BTFSC  19.7
64D6:  BSF    FF2.7
....................         index=0; 
64D8:  MOVLB  7
64DA:  CLRF   xF3
....................         ee_dat=0; 
64DC:  MOVLB  6
64DE:  CLRF   xDD
....................         while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................         { 
64E0:  MOVLB  7
64E2:  MOVF   xF3,W
64E4:  SUBLW  27
64E6:  BNC   6546
64E8:  MOVLB  6
64EA:  MOVF   xDD,W
64EC:  SUBLW  3F
64EE:  BTFSS  FD8.2
64F0:  BRA    64F6
64F2:  MOVLB  7
64F4:  BRA    6546
....................            ee_dat = rec[index+5+numbyteoftrack1]; 
64F6:  MOVLW  05
64F8:  MOVLB  7
64FA:  ADDWF  xF3,W
64FC:  ADDLW  4F
64FE:  CLRF   03
6500:  ADDLW  7D
6502:  MOVWF  FE9
6504:  MOVLW  00
6506:  ADDWFC 03,W
6508:  MOVWF  FEA
650A:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
650E:  MOVLB  6
6510:  MOVF   xDD,W
6512:  SUBLW  1F
6514:  BC    6532
6516:  MOVF   xDD,W
6518:  SUBLW  7E
651A:  BNC   6532
651C:  CLRF   19
651E:  BTFSC  FF2.7
6520:  BSF    19.7
6522:  BCF    FF2.7
6524:  MOVFF  6DD,90C
6528:  MOVLB  0
652A:  CALL   1604
652E:  BTFSC  19.7
6530:  BSF    FF2.7
....................            index++; 
6532:  MOVLB  7
6534:  INCF   xF3,F
....................            if(ee_dat==0)break; 
6536:  MOVLB  6
6538:  MOVF   xDD,F
653A:  BNZ   6542
653C:  MOVLB  7
653E:  BRA    6546
6540:  MOVLB  6
....................         } 
6542:  BRA    64E0
6544:  MOVLB  7
....................         index=0; 
6546:  CLRF   xF3
....................  
....................         fprintf(COM2,"\r\nPIN Number:\r\n"); 
6548:  MOVLW  4E
654A:  MOVWF  FF6
654C:  MOVLW  1C
654E:  MOVWF  FF7
6550:  CLRF   19
6552:  BTFSC  FF2.7
6554:  BSF    19.7
6556:  BCF    FF2.7
6558:  MOVLB  0
655A:  CALL   172E
655E:  BTFSC  19.7
6560:  BSF    FF2.7
....................  
....................         if((ptr_card_key>addr_key)) //&& 
6562:  MOVLB  6
6564:  MOVF   xE6,W
6566:  SUBWF  27,W
6568:  BTFSS  FD8.0
656A:  BRA    666E
656C:  BNZ   658A
656E:  MOVF   xE5,W
6570:  SUBWF  26,W
6572:  BTFSS  FD8.0
6574:  BRA    666E
6576:  BNZ   658A
6578:  MOVF   xE4,W
657A:  SUBWF  25,W
657C:  BTFSS  FD8.0
657E:  BRA    666E
6580:  BNZ   658A
6582:  MOVF   24,W
6584:  SUBWF  xE3,W
6586:  BTFSC  FD8.0
6588:  BRA    666E
....................         { 
....................            i=0; 
658A:  MOVLB  7
658C:  CLRF   xF4
....................            do 
....................            { 
....................               ee_dat=read_ext_eeprom(i+addr_key); 
658E:  MOVF   xF4,W
6590:  MOVLB  6
6592:  ADDWF  xE3,W
6594:  MOVLB  8
6596:  MOVWF  x2B
6598:  MOVLW  00
659A:  MOVLB  6
659C:  ADDWFC xE4,W
659E:  MOVLB  8
65A0:  MOVWF  x2C
65A2:  MOVLW  00
65A4:  MOVLB  6
65A6:  ADDWFC xE5,W
65A8:  MOVLB  8
65AA:  MOVWF  x2D
65AC:  MOVLW  00
65AE:  MOVLB  6
65B0:  ADDWFC xE6,W
65B2:  MOVLB  8
65B4:  MOVWF  x2E
65B6:  CLRF   19
65B8:  BTFSC  FF2.7
65BA:  BSF    19.7
65BC:  BCF    FF2.7
65BE:  MOVFF  FE8,91B
65C2:  MOVFF  82D,91A
65C6:  MOVFF  82C,919
65CA:  MOVFF  82B,918
65CE:  MOVLB  0
65D0:  CALL   3450
65D4:  BTFSC  19.7
65D6:  BSF    FF2.7
65D8:  MOVFF  01,6DD
....................               if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
65DC:  MOVLB  6
65DE:  MOVF   xDD,W
65E0:  SUBLW  2F
65E2:  BC    65EA
65E4:  MOVF   xDD,W
65E6:  SUBLW  39
65E8:  BC    6602
65EA:  MOVF   xDD,W
65EC:  SUBLW  23
65EE:  BZ    6602
65F0:  MOVF   xDD,W
65F2:  SUBLW  2A
65F4:  BZ    6602
65F6:  MOVF   xDD,W
65F8:  SUBLW  40
65FA:  BC    6618
65FC:  MOVF   xDD,W
65FE:  SUBLW  5A
6600:  BNC   6618
6602:  CLRF   19
6604:  BTFSC  FF2.7
6606:  BSF    19.7
6608:  BCF    FF2.7
....................               { 
....................                  fprintf(COM2,"%c",ee_dat); 
660A:  MOVFF  6DD,90C
660E:  MOVLB  0
6610:  CALL   1604
6614:  BTFSC  19.7
6616:  BSF    FF2.7
....................               } 
....................               i++; 
6618:  MOVLB  7
661A:  INCF   xF4,F
....................            } 
....................            while((i<wideofkeystore)&&(ee_dat!=0)); 
661C:  MOVF   xF4,W
661E:  SUBLW  0F
6620:  BNC   662E
6622:  MOVLB  6
6624:  MOVF   xDD,F
6626:  BTFSC  FD8.2
6628:  BRA    662E
662A:  MOVLB  7
662C:  BRA    658E
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
662E:  MOVLW  10
6630:  MOVLB  6
6632:  ADDWF  xE3,F
6634:  MOVLW  00
6636:  ADDWFC xE4,F
6638:  ADDWFC xE5,F
663A:  ADDWFC xE6,F
663C:  CLRF   19
663E:  BTFSC  FF2.7
6640:  BSF    19.7
6642:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
6644:  MOVLW  0A
6646:  MOVLB  9
6648:  MOVWF  x0C
664A:  MOVLB  0
664C:  CALL   1604
6650:  BTFSC  19.7
6652:  BSF    FF2.7
6654:  CLRF   19
6656:  BTFSC  FF2.7
6658:  BSF    19.7
665A:  BCF    FF2.7
665C:  MOVLW  0D
665E:  MOVLB  9
6660:  MOVWF  x0C
6662:  MOVLB  0
6664:  CALL   1604
6668:  BTFSC  19.7
666A:  BSF    FF2.7
666C:  MOVLB  6
....................         } 
....................         count_card++; 
666E:  INCF   xDE,F
6670:  BTFSC  FD8.2
6672:  INCF   xDF,F
....................     }  
6674:  BRA    62D6
.................... } 
6676:  MOVLB  0
6678:  GOTO   6C48 (RETURN)
.................... //================================ 
.................... void downloaddataEncrypt() 
.................... { 
667C:  MOVLB  7
667E:  CLRF   xF5
6680:  CLRF   xF4
6682:  CLRF   19
6684:  BTFSC  FF2.7
6686:  BSF    19.7
6688:  BCF    FF2.7
....................     int8 i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 keydatatemp[16]; 
....................     count_card_tg=get_countcard(); 
668A:  MOVLB  0
668C:  CALL   351C
6690:  BTFSC  19.7
6692:  BSF    FF2.7
6694:  MOVFF  02,6E1
6698:  MOVFF  01,6E0
....................     adr=count_card*numdataofonecard; 
669C:  MOVLB  6
669E:  RLCF   xDE,W
66A0:  MOVLB  7
66A2:  MOVWF  xF4
66A4:  MOVLB  6
66A6:  RLCF   xDF,W
66A8:  MOVLB  7
66AA:  MOVWF  xF5
66AC:  RLCF   xF4,F
66AE:  RLCF   xF5,F
66B0:  RLCF   xF4,F
66B2:  RLCF   xF5,F
66B4:  RLCF   xF4,F
66B6:  RLCF   xF5,F
66B8:  RLCF   xF4,F
66BA:  RLCF   xF5,F
66BC:  RLCF   xF4,F
66BE:  RLCF   xF5,F
66C0:  RLCF   xF4,F
66C2:  RLCF   xF5,F
66C4:  MOVLW  80
66C6:  ANDWF  xF4,F
....................     addr_key=EEPROM_KEY_ST; 
66C8:  MOVLB  6
66CA:  CLRF   xE6
66CC:  MOVLW  01
66CE:  MOVWF  xE5
66D0:  MOVLW  C3
66D2:  MOVWF  xE4
66D4:  MOVLW  0F
66D6:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
66D8:  MOVF   xDF,W
66DA:  SUBWF  xE1,W
66DC:  BTFSS  FD8.0
66DE:  BRA    6896
66E0:  BNZ   66EA
66E2:  MOVF   xDE,W
66E4:  SUBWF  xE0,W
66E6:  BTFSS  FD8.0
66E8:  BRA    6896
....................         adr=count_card*numdataofonecard+ptr_start; 
66EA:  RLCF   xDE,W
66EC:  MOVLB  8
66EE:  MOVWF  x08
66F0:  MOVLB  6
66F2:  RLCF   xDF,W
66F4:  MOVLB  8
66F6:  MOVWF  x09
66F8:  RLCF   x08,F
66FA:  RLCF   x09,F
66FC:  RLCF   x08,F
66FE:  RLCF   x09,F
6700:  RLCF   x08,F
6702:  RLCF   x09,F
6704:  RLCF   x08,F
6706:  RLCF   x09,F
6708:  RLCF   x08,F
670A:  RLCF   x09,F
670C:  RLCF   x08,F
670E:  RLCF   x09,F
6710:  MOVLW  80
6712:  ANDWF  x08,F
6714:  MOVLW  96
6716:  ADDWF  x08,W
6718:  MOVLB  7
671A:  MOVWF  xF4
671C:  MOVLW  00
671E:  MOVLB  8
6720:  ADDWFC x09,W
6722:  MOVLB  7
6724:  MOVWF  xF5
....................         memset(rec,0,sizeof(rec)); 
6726:  CLRF   FEA
6728:  MOVLW  7D
672A:  MOVWF  FE9
672C:  CLRF   00
672E:  CLRF   02
6730:  MOVLW  80
6732:  MOVWF  01
6734:  MOVLB  0
6736:  CALL   359A
....................         EEPROM_read((unsigned int16)(adr-numdataofonecard),numdataofonecard,rec); 
673A:  MOVLW  80
673C:  MOVLB  7
673E:  SUBWF  xF4,W
6740:  MOVLB  8
6742:  MOVWF  x08
6744:  MOVLW  00
6746:  MOVLB  7
6748:  SUBWFB xF5,W
674A:  MOVLB  8
674C:  MOVWF  x09
674E:  CLRF   19
6750:  BTFSC  FF2.7
6752:  BSF    19.7
6754:  BCF    FF2.7
6756:  MOVLB  9
6758:  CLRF   x07
675A:  CLRF   x06
675C:  MOVWF  x05
675E:  MOVFF  808,904
6762:  CLRF   x0B
6764:  CLRF   x0A
6766:  CLRF   x09
6768:  MOVLW  80
676A:  MOVWF  x08
676C:  CLRF   x0D
676E:  MOVLW  7D
6770:  MOVWF  x0C
6772:  MOVLB  0
6774:  CALL   4004
6778:  BTFSC  19.7
677A:  BSF    FF2.7
....................         for(i=0;i<numdataofonecard;i++) 
677C:  MOVLB  7
677E:  CLRF   xF3
6780:  MOVF   xF3,W
6782:  SUBLW  7F
6784:  BNC   67BA
....................         { 
....................            fprintf(COM2,"%x",rec[i]);  
6786:  CLRF   03
6788:  MOVF   xF3,W
678A:  ADDLW  7D
678C:  MOVWF  FE9
678E:  MOVLW  00
6790:  ADDWFC 03,W
6792:  MOVWF  FEA
6794:  MOVFF  FEF,808
6798:  CLRF   19
679A:  BTFSC  FF2.7
679C:  BSF    19.7
679E:  BCF    FF2.7
67A0:  MOVFF  808,901
67A4:  MOVLW  57
67A6:  MOVLB  9
67A8:  MOVWF  x02
67AA:  MOVLB  0
67AC:  CALL   4F86
67B0:  BTFSC  19.7
67B2:  BSF    FF2.7
....................         } 
67B4:  MOVLB  7
67B6:  INCF   xF3,F
67B8:  BRA    6780
....................  
....................         if((ptr_card_key>addr_key)) 
67BA:  MOVLB  6
67BC:  MOVF   xE6,W
67BE:  SUBWF  27,W
67C0:  BNC   688E
67C2:  BNZ   67DA
67C4:  MOVF   xE5,W
67C6:  SUBWF  26,W
67C8:  BNC   688E
67CA:  BNZ   67DA
67CC:  MOVF   xE4,W
67CE:  SUBWF  25,W
67D0:  BNC   688E
67D2:  BNZ   67DA
67D4:  MOVF   24,W
67D6:  SUBWF  xE3,W
67D8:  BC    688E
67DA:  CLRF   19
67DC:  BTFSC  FF2.7
67DE:  BSF    19.7
67E0:  BCF    FF2.7
....................         { 
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            EEPROM_read(addr_key,wideofkeystore,keydatatemp); 
67E2:  MOVFF  6E6,907
67E6:  MOVFF  6E5,906
67EA:  MOVFF  6E4,905
67EE:  MOVFF  6E3,904
67F2:  MOVLB  9
67F4:  CLRF   x0B
67F6:  CLRF   x0A
67F8:  CLRF   x09
67FA:  MOVLW  10
67FC:  MOVWF  x08
67FE:  MOVLW  07
6800:  MOVWF  x0D
6802:  MOVLW  F8
6804:  MOVWF  x0C
6806:  MOVLB  0
6808:  CALL   4004
680C:  BTFSC  19.7
680E:  BSF    FF2.7
....................            for(i=0;i<wideofkeystore;i++) 
6810:  MOVLB  7
6812:  CLRF   xF3
6814:  MOVF   xF3,W
6816:  SUBLW  0F
6818:  BNC   684E
....................            { 
....................                fprintf(COM2,"%x",keydatatemp[i]); 
681A:  CLRF   03
681C:  MOVF   xF3,W
681E:  ADDLW  F8
6820:  MOVWF  FE9
6822:  MOVLW  07
6824:  ADDWFC 03,W
6826:  MOVWF  FEA
6828:  MOVFF  FEF,808
682C:  CLRF   19
682E:  BTFSC  FF2.7
6830:  BSF    19.7
6832:  BCF    FF2.7
6834:  MOVFF  808,901
6838:  MOVLW  57
683A:  MOVLB  9
683C:  MOVWF  x02
683E:  MOVLB  0
6840:  CALL   4F86
6844:  BTFSC  19.7
6846:  BSF    FF2.7
....................            } 
6848:  MOVLB  7
684A:  INCF   xF3,F
684C:  BRA    6814
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
684E:  MOVLW  10
6850:  MOVLB  6
6852:  ADDWF  xE3,F
6854:  MOVLW  00
6856:  ADDWFC xE4,F
6858:  ADDWFC xE5,F
685A:  ADDWFC xE6,F
685C:  CLRF   19
685E:  BTFSC  FF2.7
6860:  BSF    19.7
6862:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
6864:  MOVLW  0A
6866:  MOVLB  9
6868:  MOVWF  x0C
686A:  MOVLB  0
686C:  CALL   1604
6870:  BTFSC  19.7
6872:  BSF    FF2.7
6874:  CLRF   19
6876:  BTFSC  FF2.7
6878:  BSF    19.7
687A:  BCF    FF2.7
687C:  MOVLW  0D
687E:  MOVLB  9
6880:  MOVWF  x0C
6882:  MOVLB  0
6884:  CALL   1604
6888:  BTFSC  19.7
688A:  BSF    FF2.7
688C:  MOVLB  6
....................         } 
....................         count_card++; 
688E:  INCF   xDE,F
6890:  BTFSC  FD8.2
6892:  INCF   xDF,F
....................     }  
6894:  BRA    66D8
.................... } 
6896:  MOVLB  0
6898:  GOTO   6C48 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int16 countchar; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
6B8A:  MOVLW  06
6B8C:  MOVWF  FEA
6B8E:  MOVLW  E7
6B90:  MOVWF  FE9
6B92:  CALL   5F14
6B96:  CLRF   19
6B98:  BTFSC  FF2.7
6B9A:  BSF    19.7
6B9C:  BCF    FF2.7
6B9E:  MOVLW  3E
6BA0:  MOVLB  9
6BA2:  MOVWF  x0C
6BA4:  MOVLB  0
6BA6:  CALL   1604
6BAA:  BTFSC  19.7
6BAC:  BSF    FF2.7
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
6BAE:  MOVLW  01
6BB0:  MOVLB  7
6BB2:  MOVWF  xF3
6BB4:  MOVLW  14
6BB6:  MOVWF  xF4
6BB8:  MOVLW  01
6BBA:  MOVWF  xF6
6BBC:  MOVLW  62
6BBE:  MOVWF  xF5
6BC0:  MOVLB  0
6BC2:  CALL   5F94
6BC6:  CLRF   19
6BC8:  BTFSC  FF2.7
6BCA:  BSF    19.7
6BCC:  BCF    FF2.7
....................       printf("\n\r"); 
6BCE:  MOVLW  0A
6BD0:  MOVLB  9
6BD2:  MOVWF  x0C
6BD4:  MOVLB  0
6BD6:  CALL   1604
6BDA:  BTFSC  19.7
6BDC:  BSF    FF2.7
6BDE:  CLRF   19
6BE0:  BTFSC  FF2.7
6BE2:  BSF    19.7
6BE4:  BCF    FF2.7
6BE6:  MOVLW  0D
6BE8:  MOVLB  9
6BEA:  MOVWF  x0C
6BEC:  MOVLB  0
6BEE:  CALL   1604
6BF2:  BTFSC  19.7
6BF4:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
6BF6:  CLRF   FEA
6BF8:  MOVLW  41
6BFA:  MOVWF  FE9
6BFC:  MOVLW  00
6BFE:  CALL   0356
6C02:  TBLRD*-
6C04:  TBLRD*+
6C06:  MOVF   FF5,W
6C08:  MOVWF  FEE
6C0A:  IORLW  00
6C0C:  BNZ   6C04
....................       index=0; 
6C0E:  MOVLB  7
6C10:  CLRF   xBD
....................       ee_dat=0; 
6C12:  MOVLB  6
6C14:  CLRF   xDD
....................       count_card=1; 
6C16:  CLRF   xDF
6C18:  MOVLW  01
6C1A:  MOVWF  xDE
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6C1C:  MOVLB  7
6C1E:  MOVWF  xF4
6C20:  MOVLW  62
6C22:  MOVWF  xF3
6C24:  CLRF   xF6
6C26:  MOVLW  41
6C28:  MOVWF  xF5
6C2A:  MOVLB  0
6C2C:  CALL   60CC
6C30:  MOVF   01,F
6C32:  BNZ   6C48
....................       { 
....................          if(cryption_enable==0) downloaddataregular(); 
6C34:  MOVLB  1
6C36:  MOVF   x22,F
6C38:  BNZ   6C44
6C3A:  MOVLB  0
6C3C:  GOTO   627A
....................          else downloaddataEncrypt(); 
6C40:  MOVLB  0
6C42:  BRA    6C48
6C44:  MOVLB  0
6C46:  BRA    667C
....................       }  
....................       strcpy(buffer2,"f"); 
6C48:  CLRF   FEA
6C4A:  MOVLW  41
6C4C:  MOVWF  FE9
6C4E:  MOVLW  00
6C50:  CALL   0368
6C54:  TBLRD*-
6C56:  TBLRD*+
6C58:  MOVF   FF5,W
6C5A:  MOVWF  FEE
6C5C:  IORLW  00
6C5E:  BNZ   6C56
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6C60:  MOVLW  01
6C62:  MOVLB  7
6C64:  MOVWF  xF4
6C66:  MOVLW  62
6C68:  MOVWF  xF3
6C6A:  CLRF   xF6
6C6C:  MOVLW  41
6C6E:  MOVWF  xF5
6C70:  MOVLB  0
6C72:  CALL   60CC
6C76:  MOVF   01,F
6C78:  BNZ   6CAC
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6C7A:  MOVLW  5E
6C7C:  MOVWF  FF6
6C7E:  MOVLW  1C
6C80:  MOVWF  FF7
6C82:  CLRF   19
6C84:  BTFSC  FF2.7
6C86:  BSF    19.7
6C88:  BCF    FF2.7
6C8A:  CALL   172E
6C8E:  BTFSC  19.7
6C90:  BSF    FF2.7
....................          format_eepromext(); 
6C92:  BRA    689C
....................          fprintf(COM2," exit\n\r");  
6C94:  MOVLW  6C
6C96:  MOVWF  FF6
6C98:  MOVLW  1C
6C9A:  MOVWF  FF7
6C9C:  CLRF   19
6C9E:  BTFSC  FF2.7
6CA0:  BSF    19.7
6CA2:  BCF    FF2.7
6CA4:  CALL   172E
6CA8:  BTFSC  19.7
6CAA:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
6CAC:  CLRF   FEA
6CAE:  MOVLW  41
6CB0:  MOVWF  FE9
6CB2:  MOVLW  00
6CB4:  CALL   037A
6CB8:  TBLRD*-
6CBA:  TBLRD*+
6CBC:  MOVF   FF5,W
6CBE:  MOVWF  FEE
6CC0:  IORLW  00
6CC2:  BNZ   6CBA
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6CC4:  MOVLW  01
6CC6:  MOVLB  7
6CC8:  MOVWF  xF4
6CCA:  MOVLW  62
6CCC:  MOVWF  xF3
6CCE:  CLRF   xF6
6CD0:  MOVLW  41
6CD2:  MOVWF  xF5
6CD4:  MOVLB  0
6CD6:  CALL   60CC
6CDA:  MOVF   01,F
6CDC:  BNZ   6D10
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6CDE:  MOVLW  74
6CE0:  MOVWF  FF6
6CE2:  MOVLW  1C
6CE4:  MOVWF  FF7
6CE6:  CLRF   19
6CE8:  BTFSC  FF2.7
6CEA:  BSF    19.7
6CEC:  BCF    FF2.7
6CEE:  CALL   172E
6CF2:  BTFSC  19.7
6CF4:  BSF    FF2.7
....................          ease_eeprom(); 
6CF6:  BRA    6938
....................          fprintf(COM2," exit\n\r");  
6CF8:  MOVLW  82
6CFA:  MOVWF  FF6
6CFC:  MOVLW  1C
6CFE:  MOVWF  FF7
6D00:  CLRF   19
6D02:  BTFSC  FF2.7
6D04:  BSF    19.7
6D06:  BCF    FF2.7
6D08:  CALL   172E
6D0C:  BTFSC  19.7
6D0E:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6D10:  CLRF   FEA
6D12:  MOVLW  41
6D14:  MOVWF  FE9
6D16:  MOVLW  00
6D18:  CALL   0390
6D1C:  TBLRD*-
6D1E:  TBLRD*+
6D20:  MOVF   FF5,W
6D22:  MOVWF  FEE
6D24:  IORLW  00
6D26:  BNZ   6D1E
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6D28:  MOVLW  01
6D2A:  MOVLB  7
6D2C:  MOVWF  xF4
6D2E:  MOVLW  62
6D30:  MOVWF  xF3
6D32:  CLRF   xF6
6D34:  MOVLW  41
6D36:  MOVWF  xF5
6D38:  MOVLB  0
6D3A:  CALL   60CC
6D3E:  MOVF   01,F
6D40:  BNZ   6D78
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
6D42:  MOVLW  8A
6D44:  MOVWF  FF6
6D46:  MOVLW  1C
6D48:  MOVWF  FF7
6D4A:  CLRF   19
6D4C:  BTFSC  FF2.7
6D4E:  BSF    19.7
6D50:  BCF    FF2.7
6D52:  CALL   172E
6D56:  BTFSC  19.7
6D58:  BSF    FF2.7
....................          reset_password(); 
6D5A:  BRA    69BC
....................          init_password(); 
6D5C:  CALL   5D02
....................          fprintf(COM2," exit\n\r");  
6D60:  MOVLW  A0
6D62:  MOVWF  FF6
6D64:  MOVLW  1C
6D66:  MOVWF  FF7
6D68:  CLRF   19
6D6A:  BTFSC  FF2.7
6D6C:  BSF    19.7
6D6E:  BCF    FF2.7
6D70:  CALL   172E
6D74:  BTFSC  19.7
6D76:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
6D78:  CLRF   FEA
6D7A:  MOVLW  41
6D7C:  MOVWF  FE9
6D7E:  MOVLW  00
6D80:  CALL   03A6
6D84:  TBLRD*-
6D86:  TBLRD*+
6D88:  MOVF   FF5,W
6D8A:  MOVWF  FEE
6D8C:  IORLW  00
6D8E:  BNZ   6D86
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6D90:  MOVLW  01
6D92:  MOVLB  7
6D94:  MOVWF  xF4
6D96:  MOVLW  62
6D98:  MOVWF  xF3
6D9A:  CLRF   xF6
6D9C:  MOVLW  41
6D9E:  MOVWF  xF5
6DA0:  MOVLB  0
6DA2:  CALL   60CC
6DA6:  MOVF   01,F
6DA8:  BNZ   6DCA
....................       { 
....................          keydebug_en=1; 
6DAA:  MOVLW  01
6DAC:  MOVLB  1
6DAE:  MOVWF  x44
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
6DB0:  MOVLW  A8
6DB2:  MOVWF  FF6
6DB4:  MOVLW  1C
6DB6:  MOVWF  FF7
6DB8:  CLRF   19
6DBA:  BTFSC  FF2.7
6DBC:  BSF    19.7
6DBE:  BCF    FF2.7
6DC0:  MOVLB  0
6DC2:  CALL   172E
6DC6:  BTFSC  19.7
6DC8:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
6DCA:  CLRF   FEA
6DCC:  MOVLW  41
6DCE:  MOVWF  FE9
6DD0:  MOVLW  00
6DD2:  CALL   03BC
6DD6:  TBLRD*-
6DD8:  TBLRD*+
6DDA:  MOVF   FF5,W
6DDC:  MOVWF  FEE
6DDE:  IORLW  00
6DE0:  BNZ   6DD8
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6DE2:  MOVLW  01
6DE4:  MOVLB  7
6DE6:  MOVWF  xF4
6DE8:  MOVLW  62
6DEA:  MOVWF  xF3
6DEC:  CLRF   xF6
6DEE:  MOVLW  41
6DF0:  MOVWF  xF5
6DF2:  MOVLB  0
6DF4:  CALL   60CC
6DF8:  MOVF   01,F
6DFA:  BNZ   6E16
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6DFC:  MOVLW  BC
6DFE:  MOVWF  FF6
6E00:  MOVLW  1C
6E02:  MOVWF  FF7
6E04:  CLRF   19
6E06:  BTFSC  FF2.7
6E08:  BSF    19.7
6E0A:  BCF    FF2.7
6E0C:  CALL   172E
6E10:  BTFSC  19.7
6E12:  BSF    FF2.7
....................          rstfact(); 
6E14:  BRA    6A0C
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
6E16:  CLRF   FEA
6E18:  MOVLW  41
6E1A:  MOVWF  FE9
6E1C:  MOVLW  00
6E1E:  CALL   03D4
6E22:  TBLRD*-
6E24:  TBLRD*+
6E26:  MOVF   FF5,W
6E28:  MOVWF  FEE
6E2A:  IORLW  00
6E2C:  BNZ   6E24
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6E2E:  MOVLW  01
6E30:  MOVLB  7
6E32:  MOVWF  xF4
6E34:  MOVLW  62
6E36:  MOVWF  xF3
6E38:  CLRF   xF6
6E3A:  MOVLW  41
6E3C:  MOVWF  xF5
6E3E:  MOVLB  0
6E40:  CALL   60CC
6E44:  MOVF   01,F
6E46:  BNZ   6E6E
....................       { 
....................          mode=LOGOFF; 
6E48:  MOVLB  6
6E4A:  CLRF   xDC
....................          keydebug_en=0; 
6E4C:  MOVLB  1
6E4E:  CLRF   x44
....................          set_tris_a(0xff); 
6E50:  MOVLW  FF
6E52:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
6E54:  MOVLW  CC
6E56:  MOVWF  FF6
6E58:  MOVLW  1C
6E5A:  MOVWF  FF7
6E5C:  CLRF   19
6E5E:  BTFSC  FF2.7
6E60:  BSF    19.7
6E62:  BCF    FF2.7
6E64:  MOVLB  0
6E66:  CALL   172E
6E6A:  BTFSC  19.7
6E6C:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
6E6E:  CLRF   FEA
6E70:  MOVLW  41
6E72:  MOVWF  FE9
6E74:  MOVLW  00
6E76:  CALL   03E6
6E7A:  TBLRD*-
6E7C:  TBLRD*+
6E7E:  MOVF   FF5,W
6E80:  MOVWF  FEE
6E82:  IORLW  00
6E84:  BNZ   6E7C
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6E86:  MOVLW  01
6E88:  MOVLB  7
6E8A:  MOVWF  xF4
6E8C:  MOVLW  62
6E8E:  MOVWF  xF3
6E90:  CLRF   xF6
6E92:  MOVLW  41
6E94:  MOVWF  xF5
6E96:  MOVLB  0
6E98:  CALL   60CC
6E9C:  MOVF   01,F
6E9E:  BNZ   6F18
....................       { 
....................          fprintf(COM2,"New console name>"); 
6EA0:  MOVLW  D4
6EA2:  MOVWF  FF6
6EA4:  MOVLW  1C
6EA6:  MOVWF  FF7
6EA8:  CLRF   19
6EAA:  BTFSC  FF2.7
6EAC:  BSF    19.7
6EAE:  BCF    FF2.7
6EB0:  CALL   172E
6EB4:  BTFSC  19.7
6EB6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,wide_strobe_nameconsole, console); 
6EB8:  MOVLW  01
6EBA:  MOVLB  7
6EBC:  MOVWF  xF3
6EBE:  MOVLW  10
6EC0:  MOVWF  xF4
6EC2:  MOVLW  06
6EC4:  MOVWF  xF6
6EC6:  MOVLW  E7
6EC8:  MOVWF  xF5
6ECA:  MOVLB  0
6ECC:  CALL   5F94
6ED0:  CLRF   19
6ED2:  BTFSC  FF2.7
6ED4:  BSF    19.7
6ED6:  BCF    FF2.7
....................          EEPROM_write(strobe_nameconsole,wide_strobe_nameconsole,console); 
6ED8:  MOVLB  9
6EDA:  CLRF   x03
6EDC:  CLRF   x02
6EDE:  CLRF   x01
6EE0:  MOVLW  28
6EE2:  MOVWF  x00
6EE4:  CLRF   x07
6EE6:  CLRF   x06
6EE8:  CLRF   x05
6EEA:  MOVLW  10
6EEC:  MOVWF  x04
6EEE:  MOVLW  06
6EF0:  MOVWF  x09
6EF2:  MOVLW  E7
6EF4:  MOVWF  x08
6EF6:  MOVLB  0
6EF8:  CALL   4EF6
6EFC:  BTFSC  19.7
6EFE:  BSF    FF2.7
....................          fprintf(COM2," OK\n\r"); 
6F00:  MOVLW  E6
6F02:  MOVWF  FF6
6F04:  MOVLW  1C
6F06:  MOVWF  FF7
6F08:  CLRF   19
6F0A:  BTFSC  FF2.7
6F0C:  BSF    19.7
6F0E:  BCF    FF2.7
6F10:  CALL   172E
6F14:  BTFSC  19.7
6F16:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
6F18:  CLRF   FEA
6F1A:  MOVLW  41
6F1C:  MOVWF  FE9
6F1E:  MOVLW  00
6F20:  CALL   03F8
6F24:  TBLRD*-
6F26:  TBLRD*+
6F28:  MOVF   FF5,W
6F2A:  MOVWF  FEE
6F2C:  IORLW  00
6F2E:  BNZ   6F26
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6F30:  MOVLW  01
6F32:  MOVLB  7
6F34:  MOVWF  xF4
6F36:  MOVLW  62
6F38:  MOVWF  xF3
6F3A:  CLRF   xF6
6F3C:  MOVLW  41
6F3E:  MOVWF  xF5
6F40:  MOVLB  0
6F42:  CALL   60CC
6F46:  MOVF   01,F
6F48:  BTFSS  FD8.2
6F4A:  BRA    70EC
6F4C:  CLRF   19
6F4E:  BTFSC  FF2.7
6F50:  BSF    19.7
6F52:  BCF    FF2.7
....................       { 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6F54:  MOVLB  9
6F56:  CLRF   x1B
6F58:  CLRF   x1A
6F5A:  CLRF   x19
6F5C:  MOVLW  3A
6F5E:  MOVWF  x18
6F60:  MOVLB  0
6F62:  CALL   3450
6F66:  BTFSC  19.7
6F68:  BSF    FF2.7
6F6A:  MOVFF  01,6E2
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6F6E:  MOVLB  6
6F70:  MOVF   xE2,F
6F72:  BNZ   6F92
6F74:  MOVLW  EC
6F76:  MOVWF  FF6
6F78:  MOVLW  1C
6F7A:  MOVWF  FF7
6F7C:  CLRF   19
6F7E:  BTFSC  FF2.7
6F80:  BSF    19.7
6F82:  BCF    FF2.7
6F84:  MOVLB  0
6F86:  CALL   172E
6F8A:  BTFSC  19.7
6F8C:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6F8E:  BRA    6FAC
6F90:  MOVLB  6
6F92:  MOVLW  F0
6F94:  MOVWF  FF6
6F96:  MOVLW  1C
6F98:  MOVWF  FF7
6F9A:  CLRF   19
6F9C:  BTFSC  FF2.7
6F9E:  BSF    19.7
6FA0:  BCF    FF2.7
6FA2:  MOVLB  0
6FA4:  CALL   172E
6FA8:  BTFSC  19.7
6FAA:  BSF    FF2.7
6FAC:  CLRF   19
6FAE:  BTFSC  FF2.7
6FB0:  BSF    19.7
6FB2:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
6FB4:  MOVLB  9
6FB6:  CLRF   x1B
6FB8:  CLRF   x1A
6FBA:  CLRF   x19
6FBC:  MOVLW  3C
6FBE:  MOVWF  x18
6FC0:  MOVLB  0
6FC2:  CALL   3450
6FC6:  BTFSC  19.7
6FC8:  BSF    FF2.7
6FCA:  MOVFF  01,15A
6FCE:  CLRF   19
6FD0:  BTFSC  FF2.7
6FD2:  BSF    19.7
6FD4:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
6FD6:  MOVLW  5B
6FD8:  MOVLB  9
6FDA:  MOVWF  x0C
6FDC:  MOVLB  0
6FDE:  CALL   1604
6FE2:  BTFSC  19.7
6FE4:  BSF    FF2.7
6FE6:  MOVFF  15A,7F3
6FEA:  MOVLW  1B
6FEC:  MOVLB  7
6FEE:  MOVWF  xF4
6FF0:  MOVLB  0
6FF2:  BRA    6A76
6FF4:  CLRF   19
6FF6:  BTFSC  FF2.7
6FF8:  BSF    19.7
6FFA:  BCF    FF2.7
6FFC:  MOVLW  5D
6FFE:  MOVLB  9
7000:  MOVWF  x0C
7002:  MOVLB  0
7004:  CALL   1604
7008:  BTFSC  19.7
700A:  BSF    FF2.7
....................           
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
700C:  MOVFF  1CB,82B
7010:  MOVLW  01
7012:  MOVLB  8
7014:  MOVWF  x2C
7016:  MOVLB  0
7018:  CALL   6164
701C:  CLRF   19
701E:  BTFSC  FF2.7
7020:  BSF    19.7
7022:  BCF    FF2.7
7024:  MOVLW  2F
7026:  MOVLB  9
7028:  MOVWF  x0C
702A:  MOVLB  0
702C:  CALL   1604
7030:  BTFSC  19.7
7032:  BSF    FF2.7
7034:  MOVFF  1CA,82B
7038:  MOVLW  01
703A:  MOVLB  8
703C:  MOVWF  x2C
703E:  MOVLB  0
7040:  CALL   6164
7044:  CLRF   19
7046:  BTFSC  FF2.7
7048:  BSF    19.7
704A:  BCF    FF2.7
704C:  MOVLW  20
704E:  MOVLB  9
7050:  MOVWF  x0C
7052:  MOVLB  0
7054:  CALL   1604
7058:  BTFSC  19.7
705A:  BSF    FF2.7
705C:  MOVFF  1CC,82B
7060:  MOVLW  01
7062:  MOVLB  8
7064:  MOVWF  x2C
7066:  MOVLB  0
7068:  CALL   6164
706C:  CLRF   19
706E:  BTFSC  FF2.7
7070:  BSF    19.7
7072:  BCF    FF2.7
7074:  MOVLW  3A
7076:  MOVLB  9
7078:  MOVWF  x0C
707A:  MOVLB  0
707C:  CALL   1604
7080:  BTFSC  19.7
7082:  BSF    FF2.7
7084:  MOVFF  1CD,82B
7088:  MOVLW  01
708A:  MOVLB  8
708C:  MOVWF  x2C
708E:  MOVLB  0
7090:  CALL   6164
7094:  CLRF   19
7096:  BTFSC  FF2.7
7098:  BSF    19.7
709A:  BCF    FF2.7
709C:  MOVLW  3A
709E:  MOVLB  9
70A0:  MOVWF  x0C
70A2:  MOVLB  0
70A4:  CALL   1604
70A8:  BTFSC  19.7
70AA:  BSF    FF2.7
70AC:  MOVFF  1CE,82B
70B0:  MOVLW  01
70B2:  MOVLB  8
70B4:  MOVWF  x2C
70B6:  MOVLB  0
70B8:  CALL   6164
70BC:  CLRF   19
70BE:  BTFSC  FF2.7
70C0:  BSF    19.7
70C2:  BCF    FF2.7
....................           
....................          fprintf(COM2,"\n\r"); 
70C4:  MOVLW  0A
70C6:  MOVLB  9
70C8:  MOVWF  x0C
70CA:  MOVLB  0
70CC:  CALL   1604
70D0:  BTFSC  19.7
70D2:  BSF    FF2.7
70D4:  CLRF   19
70D6:  BTFSC  FF2.7
70D8:  BSF    19.7
70DA:  BCF    FF2.7
70DC:  MOVLW  0D
70DE:  MOVLB  9
70E0:  MOVWF  x0C
70E2:  MOVLB  0
70E4:  CALL   1604
70E8:  BTFSC  19.7
70EA:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
70EC:  CLRF   FEA
70EE:  MOVLW  41
70F0:  MOVWF  FE9
70F2:  MOVLW  00
70F4:  CALL   040A
70F8:  TBLRD*-
70FA:  TBLRD*+
70FC:  MOVF   FF5,W
70FE:  MOVWF  FEE
7100:  IORLW  00
7102:  BNZ   70FA
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7104:  MOVLW  01
7106:  MOVLB  7
7108:  MOVWF  xF4
710A:  MOVLW  62
710C:  MOVWF  xF3
710E:  CLRF   xF6
7110:  MOVLW  41
7112:  MOVWF  xF5
7114:  MOVLB  0
7116:  CALL   60CC
711A:  MOVF   01,F
711C:  BTFSS  FD8.2
711E:  BRA    731E
....................       { 
....................          fprintf(COM2,"Year>"); 
7120:  MOVLW  F4
7122:  MOVWF  FF6
7124:  MOVLW  1C
7126:  MOVWF  FF7
7128:  CLRF   19
712A:  BTFSC  FF2.7
712C:  BSF    19.7
712E:  BCF    FF2.7
7130:  CALL   172E
7134:  BTFSC  19.7
7136:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7138:  MOVLW  01
713A:  MOVLB  7
713C:  MOVWF  xF3
713E:  MOVLW  03
7140:  MOVWF  xF4
7142:  MOVLW  07
7144:  MOVWF  xF6
7146:  MOVLW  C1
7148:  MOVWF  xF5
714A:  MOVLB  0
714C:  CALL   5F94
....................          year=(unsigned int8)strtoi(temp); 
7150:  MOVLW  07
7152:  MOVLB  7
7154:  MOVWF  xF4
7156:  MOVLW  C1
7158:  MOVWF  xF3
715A:  MOVLB  0
715C:  RCALL  6B3C
715E:  MOVFF  01,1C9
....................          fprintf(COM2,"Month>"); 
7162:  MOVLW  FA
7164:  MOVWF  FF6
7166:  MOVLW  1C
7168:  MOVWF  FF7
716A:  CLRF   19
716C:  BTFSC  FF2.7
716E:  BSF    19.7
7170:  BCF    FF2.7
7172:  CALL   172E
7176:  BTFSC  19.7
7178:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
717A:  MOVLW  01
717C:  MOVLB  7
717E:  MOVWF  xF3
7180:  MOVLW  03
7182:  MOVWF  xF4
7184:  MOVLW  07
7186:  MOVWF  xF6
7188:  MOVLW  C1
718A:  MOVWF  xF5
718C:  MOVLB  0
718E:  CALL   5F94
....................          mon=(unsigned int8)strtoi(temp); 
7192:  MOVLW  07
7194:  MOVLB  7
7196:  MOVWF  xF4
7198:  MOVLW  C1
719A:  MOVWF  xF3
719C:  MOVLB  0
719E:  RCALL  6B3C
71A0:  MOVFF  01,1CA
....................          fprintf(COM2,"Date>"); 
71A4:  MOVLW  02
71A6:  MOVWF  FF6
71A8:  MOVLW  1D
71AA:  MOVWF  FF7
71AC:  CLRF   19
71AE:  BTFSC  FF2.7
71B0:  BSF    19.7
71B2:  BCF    FF2.7
71B4:  CALL   172E
71B8:  BTFSC  19.7
71BA:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
71BC:  MOVLW  01
71BE:  MOVLB  7
71C0:  MOVWF  xF3
71C2:  MOVLW  03
71C4:  MOVWF  xF4
71C6:  MOVLW  07
71C8:  MOVWF  xF6
71CA:  MOVLW  C1
71CC:  MOVWF  xF5
71CE:  MOVLB  0
71D0:  CALL   5F94
....................          date = (unsigned int8)strtoi(temp); 
71D4:  MOVLW  07
71D6:  MOVLB  7
71D8:  MOVWF  xF4
71DA:  MOVLW  C1
71DC:  MOVWF  xF3
71DE:  MOVLB  0
71E0:  RCALL  6B3C
71E2:  MOVFF  01,1CB
....................          fprintf(COM2,"Day>"); 
71E6:  MOVLW  08
71E8:  MOVWF  FF6
71EA:  MOVLW  1D
71EC:  MOVWF  FF7
71EE:  CLRF   19
71F0:  BTFSC  FF2.7
71F2:  BSF    19.7
71F4:  BCF    FF2.7
71F6:  CALL   172E
71FA:  BTFSC  19.7
71FC:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
71FE:  MOVLW  01
7200:  MOVLB  7
7202:  MOVWF  xF3
7204:  MOVLW  03
7206:  MOVWF  xF4
7208:  MOVLW  07
720A:  MOVWF  xF6
720C:  MOVLW  C1
720E:  MOVWF  xF5
7210:  MOVLB  0
7212:  CALL   5F94
....................          day = (unsigned int8)strtoi(temp); 
7216:  MOVLW  07
7218:  MOVLB  7
721A:  MOVWF  xF4
721C:  MOVLW  C1
721E:  MOVWF  xF3
7220:  MOVLB  0
7222:  RCALL  6B3C
7224:  MOVFF  01,1C8
....................          fprintf(COM2,"Hour>"); 
7228:  MOVLW  0E
722A:  MOVWF  FF6
722C:  MOVLW  1D
722E:  MOVWF  FF7
7230:  CLRF   19
7232:  BTFSC  FF2.7
7234:  BSF    19.7
7236:  BCF    FF2.7
7238:  CALL   172E
723C:  BTFSC  19.7
723E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7240:  MOVLW  01
7242:  MOVLB  7
7244:  MOVWF  xF3
7246:  MOVLW  03
7248:  MOVWF  xF4
724A:  MOVLW  07
724C:  MOVWF  xF6
724E:  MOVLW  C1
7250:  MOVWF  xF5
7252:  MOVLB  0
7254:  CALL   5F94
....................          h = (unsigned int8)strtoi(temp); 
7258:  MOVLW  07
725A:  MOVLB  7
725C:  MOVWF  xF4
725E:  MOVLW  C1
7260:  MOVWF  xF3
7262:  MOVLB  0
7264:  RCALL  6B3C
7266:  MOVFF  01,1CC
....................          fprintf(COM2,"Minutes>"); 
726A:  MOVLW  14
726C:  MOVWF  FF6
726E:  MOVLW  1D
7270:  MOVWF  FF7
7272:  CLRF   19
7274:  BTFSC  FF2.7
7276:  BSF    19.7
7278:  BCF    FF2.7
727A:  CALL   172E
727E:  BTFSC  19.7
7280:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7282:  MOVLW  01
7284:  MOVLB  7
7286:  MOVWF  xF3
7288:  MOVLW  03
728A:  MOVWF  xF4
728C:  MOVLW  07
728E:  MOVWF  xF6
7290:  MOVLW  C1
7292:  MOVWF  xF5
7294:  MOVLB  0
7296:  CALL   5F94
....................          min = (unsigned int8)strtoi(temp);                   
729A:  MOVLW  07
729C:  MOVLB  7
729E:  MOVWF  xF4
72A0:  MOVLW  C1
72A2:  MOVWF  xF3
72A4:  MOVLB  0
72A6:  RCALL  6B3C
72A8:  MOVFF  01,1CD
....................          fprintf(COM2,"Seconds>"); 
72AC:  MOVLW  1E
72AE:  MOVWF  FF6
72B0:  MOVLW  1D
72B2:  MOVWF  FF7
72B4:  CLRF   19
72B6:  BTFSC  FF2.7
72B8:  BSF    19.7
72BA:  BCF    FF2.7
72BC:  CALL   172E
72C0:  BTFSC  19.7
72C2:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
72C4:  MOVLW  01
72C6:  MOVLB  7
72C8:  MOVWF  xF3
72CA:  MOVLW  03
72CC:  MOVWF  xF4
72CE:  MOVLW  07
72D0:  MOVWF  xF6
72D2:  MOVLW  C1
72D4:  MOVWF  xF5
72D6:  MOVLB  0
72D8:  CALL   5F94
....................          sec = (unsigned int8)strtoi(temp);                   
72DC:  MOVLW  07
72DE:  MOVLB  7
72E0:  MOVWF  xF4
72E2:  MOVLW  C1
72E4:  MOVWF  xF3
72E6:  MOVLB  0
72E8:  RCALL  6B3C
72EA:  MOVFF  01,1CE
72EE:  CLRF   19
72F0:  BTFSC  FF2.7
72F2:  BSF    19.7
72F4:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
72F6:  MOVLW  0A
72F8:  MOVLB  9
72FA:  MOVWF  x0C
72FC:  MOVLB  0
72FE:  CALL   1604
7302:  BTFSC  19.7
7304:  BSF    FF2.7
7306:  CLRF   19
7308:  BTFSC  FF2.7
730A:  BSF    19.7
730C:  BCF    FF2.7
730E:  MOVLW  0D
7310:  MOVLB  9
7312:  MOVWF  x0C
7314:  MOVLB  0
7316:  CALL   1604
731A:  BTFSC  19.7
731C:  BSF    FF2.7
....................          /* rtc_set_datetime(date,mon,year,day,h,min); */ 
....................       } 
....................       strcpy(buffer2,"MS"); 
731E:  CLRF   FEA
7320:  MOVLW  41
7322:  MOVWF  FE9
7324:  MOVLW  00
7326:  CALL   041E
732A:  TBLRD*-
732C:  TBLRD*+
732E:  MOVF   FF5,W
7330:  MOVWF  FEE
7332:  IORLW  00
7334:  BNZ   732C
....................       if(!stringcomp(buffer_uart,buffer2)) 
7336:  MOVLW  01
7338:  MOVLB  7
733A:  MOVWF  xF4
733C:  MOVLW  62
733E:  MOVWF  xF3
7340:  CLRF   xF6
7342:  MOVLW  41
7344:  MOVWF  xF5
7346:  MOVLB  0
7348:  CALL   60CC
734C:  MOVF   01,F
734E:  BTFSS  FD8.2
7350:  BRA    7464
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
7352:  MOVLW  28
7354:  MOVWF  FF6
7356:  MOVLW  1D
7358:  MOVWF  FF7
735A:  CLRF   19
735C:  BTFSC  FF2.7
735E:  BSF    19.7
7360:  BCF    FF2.7
7362:  CALL   172E
7366:  BTFSC  19.7
7368:  BSF    FF2.7
736A:  CLRF   19
736C:  BTFSC  FF2.7
736E:  BSF    19.7
7370:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7372:  MOVLW  0A
7374:  MOVLB  9
7376:  MOVWF  x0C
7378:  MOVLB  0
737A:  CALL   1604
737E:  BTFSC  19.7
7380:  BSF    FF2.7
7382:  CLRF   19
7384:  BTFSC  FF2.7
7386:  BSF    19.7
7388:  BCF    FF2.7
738A:  MOVLW  0D
738C:  MOVLB  9
738E:  MOVWF  x0C
7390:  MOVLB  0
7392:  CALL   1604
7396:  BTFSC  19.7
7398:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
739A:  MOVLW  48
739C:  MOVWF  FF6
739E:  MOVLW  1D
73A0:  MOVWF  FF7
73A2:  CLRF   19
73A4:  BTFSC  FF2.7
73A6:  BSF    19.7
73A8:  BCF    FF2.7
73AA:  CALL   172E
73AE:  BTFSC  19.7
73B0:  BSF    FF2.7
73B2:  CLRF   19
73B4:  BTFSC  FF2.7
73B6:  BSF    19.7
73B8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
73BA:  MOVLW  0A
73BC:  MOVLB  9
73BE:  MOVWF  x0C
73C0:  MOVLB  0
73C2:  CALL   1604
73C6:  BTFSC  19.7
73C8:  BSF    FF2.7
73CA:  CLRF   19
73CC:  BTFSC  FF2.7
73CE:  BSF    19.7
73D0:  BCF    FF2.7
73D2:  MOVLW  0D
73D4:  MOVLB  9
73D6:  MOVWF  x0C
73D8:  MOVLB  0
73DA:  CALL   1604
73DE:  BTFSC  19.7
73E0:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
73E2:  MOVLW  01
73E4:  MOVLB  7
73E6:  MOVWF  xF3
73E8:  MOVLW  03
73EA:  MOVWF  xF4
73EC:  MOVLW  07
73EE:  MOVWF  xF6
73F0:  MOVLW  C1
73F2:  MOVWF  xF5
73F4:  MOVLB  0
73F6:  CALL   5F94
....................           mode_sl = (unsigned int8)strtoi(temp); 
73FA:  MOVLW  07
73FC:  MOVLB  7
73FE:  MOVWF  xF4
7400:  MOVLW  C1
7402:  MOVWF  xF3
7404:  MOVLB  0
7406:  CALL   6B3C
740A:  MOVFF  01,6E2
740E:  CLRF   19
7410:  BTFSC  FF2.7
7412:  BSF    19.7
7414:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
7416:  MOVLB  9
7418:  CLRF   x16
741A:  CLRF   x15
741C:  CLRF   x14
741E:  MOVLW  3A
7420:  MOVWF  x13
7422:  MOVFF  6E2,917
7426:  MOVLB  0
7428:  CALL   3A6C
742C:  BTFSC  19.7
742E:  BSF    FF2.7
....................           set_tris_a(0xff); 
7430:  MOVLW  FF
7432:  MOVWF  F92
7434:  CLRF   19
7436:  BTFSC  FF2.7
7438:  BSF    19.7
743A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
743C:  MOVLW  0A
743E:  MOVLB  9
7440:  MOVWF  x0C
7442:  MOVLB  0
7444:  CALL   1604
7448:  BTFSC  19.7
744A:  BSF    FF2.7
744C:  CLRF   19
744E:  BTFSC  FF2.7
7450:  BSF    19.7
7452:  BCF    FF2.7
7454:  MOVLW  0D
7456:  MOVLB  9
7458:  MOVWF  x0C
745A:  MOVLB  0
745C:  CALL   1604
7460:  BTFSC  19.7
7462:  BSF    FF2.7
....................       } 
....................       
....................       strcpy(buffer2,"tran time"); 
7464:  CLRF   FEA
7466:  MOVLW  41
7468:  MOVWF  FE9
746A:  MOVLW  00
746C:  CALL   0432
7470:  TBLRD*-
7472:  TBLRD*+
7474:  MOVF   FF5,W
7476:  MOVWF  FEE
7478:  IORLW  00
747A:  BNZ   7472
....................       if(!stringcomp(buffer_uart,buffer2)) 
747C:  MOVLW  01
747E:  MOVLB  7
7480:  MOVWF  xF4
7482:  MOVLW  62
7484:  MOVWF  xF3
7486:  CLRF   xF6
7488:  MOVLW  41
748A:  MOVWF  xF5
748C:  MOVLB  0
748E:  CALL   60CC
7492:  MOVF   01,F
7494:  BNZ   755C
....................       { 
....................           fprintf(COM2,"Input Number"); 
7496:  MOVLW  68
7498:  MOVWF  FF6
749A:  MOVLW  1D
749C:  MOVWF  FF7
749E:  CLRF   19
74A0:  BTFSC  FF2.7
74A2:  BSF    19.7
74A4:  BCF    FF2.7
74A6:  CALL   172E
74AA:  BTFSC  19.7
74AC:  BSF    FF2.7
74AE:  CLRF   19
74B0:  BTFSC  FF2.7
74B2:  BSF    19.7
74B4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
74B6:  MOVLW  0A
74B8:  MOVLB  9
74BA:  MOVWF  x0C
74BC:  MOVLB  0
74BE:  CALL   1604
74C2:  BTFSC  19.7
74C4:  BSF    FF2.7
74C6:  CLRF   19
74C8:  BTFSC  FF2.7
74CA:  BSF    19.7
74CC:  BCF    FF2.7
74CE:  MOVLW  0D
74D0:  MOVLB  9
74D2:  MOVWF  x0C
74D4:  MOVLB  0
74D6:  CALL   1604
74DA:  BTFSC  19.7
74DC:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
74DE:  MOVLW  01
74E0:  MOVLB  7
74E2:  MOVWF  xF3
74E4:  MOVLW  03
74E6:  MOVWF  xF4
74E8:  MOVLW  07
74EA:  MOVWF  xF6
74EC:  MOVLW  C1
74EE:  MOVWF  xF5
74F0:  MOVLB  0
74F2:  CALL   5F94
....................           delaycharaction = (unsigned int8)strtoi(temp); 
74F6:  MOVLW  07
74F8:  MOVLB  7
74FA:  MOVWF  xF4
74FC:  MOVLW  C1
74FE:  MOVWF  xF3
7500:  MOVLB  0
7502:  CALL   6B3C
7506:  MOVFF  01,15A
750A:  CLRF   19
750C:  BTFSC  FF2.7
750E:  BSF    19.7
7510:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
7512:  MOVLB  9
7514:  CLRF   x16
7516:  CLRF   x15
7518:  CLRF   x14
751A:  MOVLW  3C
751C:  MOVWF  x13
751E:  MOVFF  15A,917
7522:  MOVLB  0
7524:  CALL   3A6C
7528:  BTFSC  19.7
752A:  BSF    FF2.7
752C:  CLRF   19
752E:  BTFSC  FF2.7
7530:  BSF    19.7
7532:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7534:  MOVLW  0A
7536:  MOVLB  9
7538:  MOVWF  x0C
753A:  MOVLB  0
753C:  CALL   1604
7540:  BTFSC  19.7
7542:  BSF    FF2.7
7544:  CLRF   19
7546:  BTFSC  FF2.7
7548:  BSF    19.7
754A:  BCF    FF2.7
754C:  MOVLW  0D
754E:  MOVLB  9
7550:  MOVWF  x0C
7552:  MOVLB  0
7554:  CALL   1604
7558:  BTFSC  19.7
755A:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
755C:  CLRF   FEA
755E:  MOVLW  41
7560:  MOVWF  FE9
7562:  MOVLW  00
7564:  CALL   044C
7568:  TBLRD*-
756A:  TBLRD*+
756C:  MOVF   FF5,W
756E:  MOVWF  FEE
7570:  IORLW  00
7572:  BNZ   756A
....................       if(!stringcomp(buffer_uart,buffer2)) 
7574:  MOVLW  01
7576:  MOVLB  7
7578:  MOVWF  xF4
757A:  MOVLW  62
757C:  MOVWF  xF3
757E:  CLRF   xF6
7580:  MOVLW  41
7582:  MOVWF  xF5
7584:  MOVLB  0
7586:  CALL   60CC
758A:  MOVF   01,F
758C:  BTFSS  FD8.2
758E:  BRA    769E
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
7590:  MOVLW  76
7592:  MOVWF  FF6
7594:  MOVLW  1D
7596:  MOVWF  FF7
7598:  CLRF   19
759A:  BTFSC  FF2.7
759C:  BSF    19.7
759E:  BCF    FF2.7
75A0:  CALL   172E
75A4:  BTFSC  19.7
75A6:  BSF    FF2.7
75A8:  CLRF   19
75AA:  BTFSC  FF2.7
75AC:  BSF    19.7
75AE:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
75B0:  MOVLW  0A
75B2:  MOVLB  9
75B4:  MOVWF  x0C
75B6:  MOVLB  0
75B8:  CALL   1604
75BC:  BTFSC  19.7
75BE:  BSF    FF2.7
75C0:  CLRF   19
75C2:  BTFSC  FF2.7
75C4:  BSF    19.7
75C6:  BCF    FF2.7
75C8:  MOVLW  0D
75CA:  MOVLB  9
75CC:  MOVWF  x0C
75CE:  MOVLB  0
75D0:  CALL   1604
75D4:  BTFSC  19.7
75D6:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
75D8:  MOVLW  9C
75DA:  MOVWF  FF6
75DC:  MOVLW  1D
75DE:  MOVWF  FF7
75E0:  CLRF   19
75E2:  BTFSC  FF2.7
75E4:  BSF    19.7
75E6:  BCF    FF2.7
75E8:  CALL   172E
75EC:  BTFSC  19.7
75EE:  BSF    FF2.7
75F0:  CLRF   19
75F2:  BTFSC  FF2.7
75F4:  BSF    19.7
75F6:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
75F8:  MOVLW  0A
75FA:  MOVLB  9
75FC:  MOVWF  x0C
75FE:  MOVLB  0
7600:  CALL   1604
7604:  BTFSC  19.7
7606:  BSF    FF2.7
7608:  CLRF   19
760A:  BTFSC  FF2.7
760C:  BSF    19.7
760E:  BCF    FF2.7
7610:  MOVLW  0D
7612:  MOVLB  9
7614:  MOVWF  x0C
7616:  MOVLB  0
7618:  CALL   1604
761C:  BTFSC  19.7
761E:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7620:  MOVLW  01
7622:  MOVLB  7
7624:  MOVWF  xF3
7626:  MOVLW  03
7628:  MOVWF  xF4
762A:  MOVLW  07
762C:  MOVWF  xF6
762E:  MOVLW  C1
7630:  MOVWF  xF5
7632:  MOVLB  0
7634:  CALL   5F94
....................           type_KB=(unsigned int8)strtoi(temp); 
7638:  MOVLW  07
763A:  MOVLB  7
763C:  MOVWF  xF4
763E:  MOVLW  C1
7640:  MOVWF  xF3
7642:  MOVLB  0
7644:  CALL   6B3C
7648:  MOVFF  01,149
764C:  CLRF   19
764E:  BTFSC  FF2.7
7650:  BSF    19.7
7652:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
7654:  MOVLB  9
7656:  CLRF   x16
7658:  CLRF   x15
765A:  CLRF   x14
765C:  MOVLW  3D
765E:  MOVWF  x13
7660:  MOVFF  149,917
7664:  MOVLB  0
7666:  CALL   3A6C
766A:  BTFSC  19.7
766C:  BSF    FF2.7
766E:  CLRF   19
7670:  BTFSC  FF2.7
7672:  BSF    19.7
7674:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
7676:  MOVLW  0A
7678:  MOVLB  9
767A:  MOVWF  x0C
767C:  MOVLB  0
767E:  CALL   1604
7682:  BTFSC  19.7
7684:  BSF    FF2.7
7686:  CLRF   19
7688:  BTFSC  FF2.7
768A:  BSF    19.7
768C:  BCF    FF2.7
768E:  MOVLW  0D
7690:  MOVLB  9
7692:  MOVWF  x0C
7694:  MOVLB  0
7696:  CALL   1604
769A:  BTFSC  19.7
769C:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       strcpy(buffer2,"h"); 
769E:  CLRF   FEA
76A0:  MOVLW  41
76A2:  MOVWF  FE9
76A4:  MOVLW  00
76A6:  CALL   0462
76AA:  TBLRD*-
76AC:  TBLRD*+
76AE:  MOVF   FF5,W
76B0:  MOVWF  FEE
76B2:  IORLW  00
76B4:  BNZ   76AC
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
76B6:  MOVLW  01
76B8:  MOVLB  7
76BA:  MOVWF  xF4
76BC:  MOVLW  62
76BE:  MOVWF  xF3
76C0:  CLRF   xF6
76C2:  MOVLW  41
76C4:  MOVWF  xF5
76C6:  MOVLB  0
76C8:  CALL   60CC
76CC:  MOVF   01,F
76CE:  BTFSS  FD8.2
76D0:  BRA    7840
....................       { 
....................          printf("h-> Help\n\r"); 
76D2:  MOVLW  C2
76D4:  MOVWF  FF6
76D6:  MOVLW  1D
76D8:  MOVWF  FF7
76DA:  CLRF   19
76DC:  BTFSC  FF2.7
76DE:  BSF    19.7
76E0:  BCF    FF2.7
76E2:  CALL   172E
76E6:  BTFSC  19.7
76E8:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
76EA:  MOVLW  CE
76EC:  MOVWF  FF6
76EE:  MOVLW  1D
76F0:  MOVWF  FF7
76F2:  CLRF   19
76F4:  BTFSC  FF2.7
76F6:  BSF    19.7
76F8:  BCF    FF2.7
76FA:  CALL   172E
76FE:  BTFSC  19.7
7700:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
7702:  MOVLW  E0
7704:  MOVWF  FF6
7706:  MOVLW  1D
7708:  MOVWF  FF7
770A:  CLRF   19
770C:  BTFSC  FF2.7
770E:  BSF    19.7
7710:  BCF    FF2.7
7712:  CALL   172E
7716:  BTFSC  19.7
7718:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
771A:  MOVLW  F2
771C:  MOVWF  FF6
771E:  MOVLW  1D
7720:  MOVWF  FF7
7722:  CLRF   19
7724:  BTFSC  FF2.7
7726:  BSF    19.7
7728:  BCF    FF2.7
772A:  CALL   172E
772E:  BTFSC  19.7
7730:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
7732:  MOVLW  12
7734:  MOVWF  FF6
7736:  MOVLW  1E
7738:  MOVWF  FF7
773A:  CLRF   19
773C:  BTFSC  FF2.7
773E:  BSF    19.7
7740:  BCF    FF2.7
7742:  CALL   172E
7746:  BTFSC  19.7
7748:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
774A:  MOVLW  2E
774C:  MOVWF  FF6
774E:  MOVLW  1E
7750:  MOVWF  FF7
7752:  CLRF   19
7754:  BTFSC  FF2.7
7756:  BSF    19.7
7758:  BCF    FF2.7
775A:  CALL   172E
775E:  BTFSC  19.7
7760:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
7762:  MOVLW  3C
7764:  MOVWF  FF6
7766:  MOVLW  1E
7768:  MOVWF  FF7
776A:  CLRF   19
776C:  BTFSC  FF2.7
776E:  BSF    19.7
7770:  BCF    FF2.7
7772:  CALL   172E
7776:  BTFSC  19.7
7778:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
777A:  MOVLW  48
777C:  MOVWF  FF6
777E:  MOVLW  1E
7780:  MOVWF  FF7
7782:  CLRF   19
7784:  BTFSC  FF2.7
7786:  BSF    19.7
7788:  BCF    FF2.7
778A:  CALL   172E
778E:  BTFSC  19.7
7790:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
7792:  MOVLW  70
7794:  MOVWF  FF6
7796:  MOVLW  1E
7798:  MOVWF  FF7
779A:  CLRF   19
779C:  BTFSC  FF2.7
779E:  BSF    19.7
77A0:  BCF    FF2.7
77A2:  CALL   172E
77A6:  BTFSC  19.7
77A8:  BSF    FF2.7
77AA:  CLRF   19
77AC:  BTFSC  FF2.7
77AE:  BSF    19.7
77B0:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
77B2:  MOVLB  9
77B4:  CLRF   x1B
77B6:  CLRF   x1A
77B8:  CLRF   x19
77BA:  MOVLW  3D
77BC:  MOVWF  x18
77BE:  MOVLB  0
77C0:  CALL   3450
77C4:  BTFSC  19.7
77C6:  BSF    FF2.7
77C8:  MOVFF  01,7F3
77CC:  MOVLW  8C
77CE:  MOVWF  FF6
77D0:  MOVLW  1E
77D2:  MOVWF  FF7
77D4:  CLRF   19
77D6:  BTFSC  FF2.7
77D8:  BSF    19.7
77DA:  BCF    FF2.7
77DC:  MOVLW  06
77DE:  MOVLB  8
77E0:  MOVWF  xF7
77E2:  MOVLB  0
77E4:  CALL   164A
77E8:  BTFSC  19.7
77EA:  BSF    FF2.7
77EC:  CLRF   19
77EE:  BTFSC  FF2.7
77F0:  BSF    19.7
77F2:  BCF    FF2.7
77F4:  MOVFF  7F3,859
77F8:  MOVLW  18
77FA:  MOVLB  8
77FC:  MOVWF  x5A
77FE:  MOVLB  0
7800:  CALL   177A
7804:  BTFSC  19.7
7806:  BSF    FF2.7
7808:  MOVLW  94
780A:  MOVWF  FF6
780C:  MOVLW  1E
780E:  MOVWF  FF7
7810:  CLRF   19
7812:  BTFSC  FF2.7
7814:  BSF    19.7
7816:  BCF    FF2.7
7818:  MOVLW  1D
781A:  MOVLB  8
781C:  MOVWF  xF7
781E:  MOVLB  0
7820:  CALL   164A
7824:  BTFSC  19.7
7826:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
7828:  MOVLW  B2
782A:  MOVWF  FF6
782C:  MOVLW  1E
782E:  MOVWF  FF7
7830:  CLRF   19
7832:  BTFSC  FF2.7
7834:  BSF    19.7
7836:  BCF    FF2.7
7838:  CALL   172E
783C:  BTFSC  19.7
783E:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................       } 
....................       strcpy(buffer2,"password"); 
7840:  CLRF   FEA
7842:  MOVLW  41
7844:  MOVWF  FE9
7846:  MOVLW  00
7848:  CALL   0474
784C:  TBLRD*-
784E:  TBLRD*+
7850:  MOVF   FF5,W
7852:  MOVWF  FEE
7854:  IORLW  00
7856:  BNZ   784E
....................       if(!stringcomp(buffer_uart,buffer2))  
7858:  MOVLW  01
785A:  MOVLB  7
785C:  MOVWF  xF4
785E:  MOVLW  62
7860:  MOVWF  xF3
7862:  CLRF   xF6
7864:  MOVLW  41
7866:  MOVWF  xF5
7868:  MOVLB  0
786A:  CALL   60CC
786E:  MOVF   01,F
7870:  BTFSS  FD8.2
7872:  BRA    79D2
....................       { 
....................          fprintf(COM2,"old password:"); 
7874:  MOVLW  CC
7876:  MOVWF  FF6
7878:  MOVLW  1E
787A:  MOVWF  FF7
787C:  CLRF   19
787E:  BTFSC  FF2.7
7880:  BSF    19.7
7882:  BCF    FF2.7
7884:  CALL   172E
7888:  BTFSC  19.7
788A:  BSF    FF2.7
788C:  CLRF   19
788E:  BTFSC  FF2.7
7890:  BSF    19.7
7892:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
7894:  MOVLB  9
7896:  CLRF   x07
7898:  CLRF   x06
789A:  CLRF   x05
789C:  CLRF   x04
789E:  CLRF   x0B
78A0:  CLRF   x0A
78A2:  CLRF   x09
78A4:  MOVLW  14
78A6:  MOVWF  x08
78A8:  CLRF   x0D
78AA:  MOVLW  55
78AC:  MOVWF  x0C
78AE:  MOVLB  0
78B0:  CALL   4004
78B4:  BTFSC  19.7
78B6:  BSF    FF2.7
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
78B8:  MOVLW  02
78BA:  MOVLB  7
78BC:  MOVWF  xF3
78BE:  MOVLW  14
78C0:  MOVWF  xF4
78C2:  CLRF   xF6
78C4:  MOVLW  69
78C6:  MOVWF  xF5
78C8:  MOVLB  0
78CA:  CALL   5F94
....................          if(!stringcomp(entpassword,password)) 
78CE:  MOVLB  7
78D0:  CLRF   xF4
78D2:  MOVLW  69
78D4:  MOVWF  xF3
78D6:  CLRF   xF6
78D8:  MOVLW  55
78DA:  MOVWF  xF5
78DC:  MOVLB  0
78DE:  CALL   60CC
78E2:  MOVF   01,F
78E4:  BNZ   79BA
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
78E6:  MOVLW  DA
78E8:  MOVWF  FF6
78EA:  MOVLW  1E
78EC:  MOVWF  FF7
78EE:  CLRF   19
78F0:  BTFSC  FF2.7
78F2:  BSF    19.7
78F4:  BCF    FF2.7
78F6:  CALL   172E
78FA:  BTFSC  19.7
78FC:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
78FE:  MOVLW  02
7900:  MOVLB  7
7902:  MOVWF  xF3
7904:  MOVLW  14
7906:  MOVWF  xF4
7908:  CLRF   xF6
790A:  MOVLW  69
790C:  MOVWF  xF5
790E:  MOVLB  0
7910:  CALL   5F94
....................             fprintf(COM2,"\n\ragain:"); 
7914:  MOVLW  E2
7916:  MOVWF  FF6
7918:  MOVLW  1E
791A:  MOVWF  FF7
791C:  CLRF   19
791E:  BTFSC  FF2.7
7920:  BSF    19.7
7922:  BCF    FF2.7
7924:  CALL   172E
7928:  BTFSC  19.7
792A:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
792C:  MOVLW  02
792E:  MOVLB  7
7930:  MOVWF  xF3
7932:  MOVLW  14
7934:  MOVWF  xF4
7936:  CLRF   xF6
7938:  MOVLW  55
793A:  MOVWF  xF5
793C:  MOVLB  0
793E:  CALL   5F94
....................             if(!stringcomp(entpassword,password)) 
7942:  MOVLB  7
7944:  CLRF   xF4
7946:  MOVLW  69
7948:  MOVWF  xF3
794A:  CLRF   xF6
794C:  MOVLW  55
794E:  MOVWF  xF5
7950:  MOVLB  0
7952:  CALL   60CC
7956:  MOVF   01,F
7958:  BNZ   79A0
795A:  CLRF   19
795C:  BTFSC  FF2.7
795E:  BSF    19.7
7960:  BCF    FF2.7
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
7962:  MOVLB  9
7964:  CLRF   x03
7966:  CLRF   x02
7968:  CLRF   x01
796A:  CLRF   x00
796C:  CLRF   x07
796E:  CLRF   x06
7970:  CLRF   x05
7972:  MOVLW  14
7974:  MOVWF  x04
7976:  CLRF   x09
7978:  MOVLW  55
797A:  MOVWF  x08
797C:  MOVLB  0
797E:  CALL   4EF6
7982:  BTFSC  19.7
7984:  BSF    FF2.7
....................                fprintf(COM2,"\n\rOK\n\r");    
7986:  MOVLW  EC
7988:  MOVWF  FF6
798A:  MOVLW  1E
798C:  MOVWF  FF7
798E:  CLRF   19
7990:  BTFSC  FF2.7
7992:  BSF    19.7
7994:  BCF    FF2.7
7996:  CALL   172E
799A:  BTFSC  19.7
799C:  BSF    FF2.7
....................             } 
....................                else 
799E:  BRA    79B8
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
79A0:  MOVLW  F4
79A2:  MOVWF  FF6
79A4:  MOVLW  1E
79A6:  MOVWF  FF7
79A8:  CLRF   19
79AA:  BTFSC  FF2.7
79AC:  BSF    19.7
79AE:  BCF    FF2.7
79B0:  CALL   172E
79B4:  BTFSC  19.7
79B6:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
79B8:  BRA    79D2
....................             { 
....................                fprintf(COM2," X\n\r"); 
79BA:  MOVLW  FC
79BC:  MOVWF  FF6
79BE:  MOVLW  1E
79C0:  MOVWF  FF7
79C2:  CLRF   19
79C4:  BTFSC  FF2.7
79C6:  BSF    19.7
79C8:  BCF    FF2.7
79CA:  CALL   172E
79CE:  BTFSC  19.7
79D0:  BSF    FF2.7
....................             }    
....................       } 
....................         strcpy(buffer2,"crypto"); 
79D2:  CLRF   FEA
79D4:  MOVLW  41
79D6:  MOVWF  FE9
79D8:  MOVLW  00
79DA:  CALL   048E
79DE:  TBLRD*-
79E0:  TBLRD*+
79E2:  MOVF   FF5,W
79E4:  MOVWF  FEE
79E6:  IORLW  00
79E8:  BNZ   79E0
....................         if(!stringcomp(buffer_uart,buffer2))  
79EA:  MOVLW  01
79EC:  MOVLB  7
79EE:  MOVWF  xF4
79F0:  MOVLW  62
79F2:  MOVWF  xF3
79F4:  CLRF   xF6
79F6:  MOVLW  41
79F8:  MOVWF  xF5
79FA:  MOVLB  0
79FC:  CALL   60CC
7A00:  MOVF   01,F
7A02:  BTFSS  FD8.2
7A04:  BRA    7B84
....................         { 
....................             memset(crypto_key,0,sizeof(crypto_key)); 
7A06:  MOVLW  01
7A08:  MOVWF  FEA
7A0A:  MOVWF  FE9
7A0C:  CLRF   00
7A0E:  CLRF   02
7A10:  MOVLW  21
7A12:  MOVWF  01
7A14:  CALL   359A
....................             fprintf(COM2,"New crypto key>"); 
7A18:  MOVLW  02
7A1A:  MOVWF  FF6
7A1C:  MOVLW  1F
7A1E:  MOVWF  FF7
7A20:  CLRF   19
7A22:  BTFSC  FF2.7
7A24:  BSF    19.7
7A26:  BCF    FF2.7
7A28:  CALL   172E
7A2C:  BTFSC  19.7
7A2E:  BSF    FF2.7
....................             countchar = (int16)USART_getstring(EN_ECHO, CRYPTO_KEY_SIZE, crypto_key); 
7A30:  MOVLW  01
7A32:  MOVLB  7
7A34:  MOVWF  xF3
7A36:  MOVLW  20
7A38:  MOVWF  xF4
7A3A:  MOVLW  01
7A3C:  MOVWF  xF6
7A3E:  MOVWF  xF5
7A40:  MOVLB  0
7A42:  CALL   5F94
7A46:  MOVLB  7
7A48:  CLRF   xC0
7A4A:  MOVFF  01,7BF
7A4E:  CLRF   19
7A50:  BTFSC  FF2.7
7A52:  BSF    19.7
7A54:  BCF    FF2.7
....................             EEPROM_write(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
7A56:  MOVLB  9
7A58:  CLRF   x03
7A5A:  CLRF   x02
7A5C:  CLRF   x01
7A5E:  MOVLW  3F
7A60:  MOVWF  x00
7A62:  CLRF   x07
7A64:  CLRF   x06
7A66:  CLRF   x05
7A68:  MOVLW  20
7A6A:  MOVWF  x04
7A6C:  MOVLW  01
7A6E:  MOVWF  x09
7A70:  MOVWF  x08
7A72:  MOVLB  0
7A74:  CALL   4EF6
7A78:  BTFSC  19.7
7A7A:  BSF    FF2.7
....................              
....................             if(countchar>2) 
7A7C:  MOVLB  7
7A7E:  MOVF   xC0,F
7A80:  BNZ   7A88
7A82:  MOVF   xBF,W
7A84:  SUBLW  02
7A86:  BC    7B46
....................             { 
....................                 cryption_enable = 1; 
7A88:  MOVLW  01
7A8A:  MOVLB  1
7A8C:  MOVWF  x22
7A8E:  CLRF   19
7A90:  BTFSC  FF2.7
7A92:  BSF    19.7
7A94:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable);                    
7A96:  MOVLB  9
7A98:  CLRF   x16
7A9A:  CLRF   x15
7A9C:  CLRF   x14
7A9E:  MOVLW  3E
7AA0:  MOVWF  x13
7AA2:  MOVFF  122,917
7AA6:  MOVLB  0
7AA8:  CALL   3A6C
7AAC:  BTFSC  19.7
7AAE:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rNew crypto key: "); 
7AB0:  MOVLW  12
7AB2:  MOVWF  FF6
7AB4:  MOVLW  1F
7AB6:  MOVWF  FF7
7AB8:  CLRF   19
7ABA:  BTFSC  FF2.7
7ABC:  BSF    19.7
7ABE:  BCF    FF2.7
7AC0:  CALL   172E
7AC4:  BTFSC  19.7
7AC6:  BSF    FF2.7
....................                 for(i=0;i<CRYPTO_KEY_SIZE;i++) 
7AC8:  MOVLB  7
7ACA:  CLRF   xBE
7ACC:  MOVF   xBE,W
7ACE:  SUBLW  1F
7AD0:  BNC   7B12
....................                 { 
....................                     fprintf(COM2,"%c",read_ext_eeprom(strobe_crypto_key+i)); 
7AD2:  MOVLW  3F
7AD4:  ADDWF  xBE,W
7AD6:  MOVWF  xF3
7AD8:  CLRF   19
7ADA:  BTFSC  FF2.7
7ADC:  BSF    19.7
7ADE:  BCF    FF2.7
7AE0:  MOVLB  9
7AE2:  CLRF   x1B
7AE4:  CLRF   x1A
7AE6:  CLRF   x19
7AE8:  MOVWF  x18
7AEA:  MOVLB  0
7AEC:  CALL   3450
7AF0:  BTFSC  19.7
7AF2:  BSF    FF2.7
7AF4:  MOVFF  01,7F3
7AF8:  CLRF   19
7AFA:  BTFSC  FF2.7
7AFC:  BSF    19.7
7AFE:  BCF    FF2.7
7B00:  MOVFF  01,90C
7B04:  CALL   1604
7B08:  BTFSC  19.7
7B0A:  BSF    FF2.7
....................                 } 
7B0C:  MOVLB  7
7B0E:  INCF   xBE,F
7B10:  BRA    7ACC
7B12:  CLRF   19
7B14:  BTFSC  FF2.7
7B16:  BSF    19.7
7B18:  BCF    FF2.7
....................                 fprintf(COM2,"\n\r"); 
7B1A:  MOVLW  0A
7B1C:  MOVLB  9
7B1E:  MOVWF  x0C
7B20:  MOVLB  0
7B22:  CALL   1604
7B26:  BTFSC  19.7
7B28:  BSF    FF2.7
7B2A:  CLRF   19
7B2C:  BTFSC  FF2.7
7B2E:  BSF    19.7
7B30:  BCF    FF2.7
7B32:  MOVLW  0D
7B34:  MOVLB  9
7B36:  MOVWF  x0C
7B38:  MOVLB  0
7B3A:  CALL   1604
7B3E:  BTFSC  19.7
7B40:  BSF    FF2.7
....................             } 
....................             else 
7B42:  BRA    7B84
7B44:  MOVLB  7
....................             { 
....................                 cryption_enable = 0; 
7B46:  MOVLB  1
7B48:  CLRF   x22
7B4A:  CLRF   19
7B4C:  BTFSC  FF2.7
7B4E:  BSF    19.7
7B50:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable); 
7B52:  MOVLB  9
7B54:  CLRF   x16
7B56:  CLRF   x15
7B58:  CLRF   x14
7B5A:  MOVLW  3E
7B5C:  MOVWF  x13
7B5E:  MOVFF  122,917
7B62:  MOVLB  0
7B64:  CALL   3A6C
7B68:  BTFSC  19.7
7B6A:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rcrypto is disable\n\r"); 
7B6C:  MOVLW  26
7B6E:  MOVWF  FF6
7B70:  MOVLW  1F
7B72:  MOVWF  FF7
7B74:  CLRF   19
7B76:  BTFSC  FF2.7
7B78:  BSF    19.7
7B7A:  BCF    FF2.7
7B7C:  CALL   172E
7B80:  BTFSC  19.7
7B82:  BSF    FF2.7
....................             } 
....................         } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
7B84:  CLRF   FEA
7B86:  MOVLW  41
7B88:  MOVWF  FE9
7B8A:  MOVLW  00
7B8C:  CALL   04A6
7B90:  TBLRD*-
7B92:  TBLRD*+
7B94:  MOVF   FF5,W
7B96:  MOVWF  FEE
7B98:  IORLW  00
7B9A:  BNZ   7B92
....................       if(!stringcomp(buffer_uart,buffer2)) 
7B9C:  MOVLW  01
7B9E:  MOVLB  7
7BA0:  MOVWF  xF4
7BA2:  MOVLW  62
7BA4:  MOVWF  xF3
7BA6:  CLRF   xF6
7BA8:  MOVLW  41
7BAA:  MOVWF  xF5
7BAC:  MOVLB  0
7BAE:  CALL   60CC
7BB2:  MOVF   01,F
7BB4:  BTFSS  FD8.2
7BB6:  BRA    7CC6
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
7BB8:  MOVLW  3C
7BBA:  MOVWF  FF6
7BBC:  MOVLW  1F
7BBE:  MOVWF  FF7
7BC0:  CLRF   19
7BC2:  BTFSC  FF2.7
7BC4:  BSF    19.7
7BC6:  BCF    FF2.7
7BC8:  CALL   172E
7BCC:  BTFSC  19.7
7BCE:  BSF    FF2.7
7BD0:  CLRF   19
7BD2:  BTFSC  FF2.7
7BD4:  BSF    19.7
7BD6:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7BD8:  MOVLW  0A
7BDA:  MOVLB  9
7BDC:  MOVWF  x0C
7BDE:  MOVLB  0
7BE0:  CALL   1604
7BE4:  BTFSC  19.7
7BE6:  BSF    FF2.7
7BE8:  CLRF   19
7BEA:  BTFSC  FF2.7
7BEC:  BSF    19.7
7BEE:  BCF    FF2.7
7BF0:  MOVLW  0D
7BF2:  MOVLB  9
7BF4:  MOVWF  x0C
7BF6:  MOVLB  0
7BF8:  CALL   1604
7BFC:  BTFSC  19.7
7BFE:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
7C00:  MOVLW  5C
7C02:  MOVWF  FF6
7C04:  MOVLW  1F
7C06:  MOVWF  FF7
7C08:  CLRF   19
7C0A:  BTFSC  FF2.7
7C0C:  BSF    19.7
7C0E:  BCF    FF2.7
7C10:  CALL   172E
7C14:  BTFSC  19.7
7C16:  BSF    FF2.7
7C18:  CLRF   19
7C1A:  BTFSC  FF2.7
7C1C:  BSF    19.7
7C1E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7C20:  MOVLW  0A
7C22:  MOVLB  9
7C24:  MOVWF  x0C
7C26:  MOVLB  0
7C28:  CALL   1604
7C2C:  BTFSC  19.7
7C2E:  BSF    FF2.7
7C30:  CLRF   19
7C32:  BTFSC  FF2.7
7C34:  BSF    19.7
7C36:  BCF    FF2.7
7C38:  MOVLW  0D
7C3A:  MOVLB  9
7C3C:  MOVWF  x0C
7C3E:  MOVLB  0
7C40:  CALL   1604
7C44:  BTFSC  19.7
7C46:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7C48:  MOVLW  01
7C4A:  MOVLB  7
7C4C:  MOVWF  xF3
7C4E:  MOVLW  03
7C50:  MOVWF  xF4
7C52:  MOVLW  07
7C54:  MOVWF  xF6
7C56:  MOVLW  C1
7C58:  MOVWF  xF5
7C5A:  MOVLB  0
7C5C:  CALL   5F94
....................           debugmode = (unsigned int8)strtoi(temp); 
7C60:  MOVLW  07
7C62:  MOVLB  7
7C64:  MOVWF  xF4
7C66:  MOVLW  C1
7C68:  MOVWF  xF3
7C6A:  MOVLB  0
7C6C:  CALL   6B3C
7C70:  MOVFF  01,6D6
7C74:  CLRF   19
7C76:  BTFSC  FF2.7
7C78:  BSF    19.7
7C7A:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
7C7C:  MOVLB  9
7C7E:  CLRF   x16
7C80:  CLRF   x15
7C82:  CLRF   x14
7C84:  MOVLW  3B
7C86:  MOVWF  x13
7C88:  MOVFF  6D6,917
7C8C:  MOVLB  0
7C8E:  CALL   3A6C
7C92:  BTFSC  19.7
7C94:  BSF    FF2.7
7C96:  CLRF   19
7C98:  BTFSC  FF2.7
7C9A:  BSF    19.7
7C9C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7C9E:  MOVLW  0A
7CA0:  MOVLB  9
7CA2:  MOVWF  x0C
7CA4:  MOVLB  0
7CA6:  CALL   1604
7CAA:  BTFSC  19.7
7CAC:  BSF    FF2.7
7CAE:  CLRF   19
7CB0:  BTFSC  FF2.7
7CB2:  BSF    19.7
7CB4:  BCF    FF2.7
7CB6:  MOVLW  0D
7CB8:  MOVLB  9
7CBA:  MOVWF  x0C
7CBC:  MOVLB  0
7CBE:  CALL   1604
7CC2:  BTFSC  19.7
7CC4:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
7CC6:  GOTO   82C2 (RETURN)
.................... //=============================================== 
....................  
....................  
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    if(keydebug_en==1) 
*
59EE:  MOVLB  1
59F0:  DECFSZ x44,W
59F2:  BRA    5A0E
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
59F4:  MOVLB  6
59F6:  MOVF   xE2,F
59F8:  BNZ   5A02
59FA:  MOVLB  0
59FC:  CALL   1F7C
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
5A00:  BRA    5A0C
5A02:  MOVLB  0
5A04:  CALL   31E0
5A08:  MOVFF  01,84F
5A0C:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
5A0E:  DECFSZ x45,W
5A10:  BRA    5A2A
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
5A12:  MOVLB  6
5A14:  MOVF   xE2,F
5A16:  BNZ   5A20
5A18:  MOVLB  0
5A1A:  CALL   1F7C
....................          else temp=kbd_getc_slv(); 
5A1E:  BRA    5A2A
5A20:  MOVLB  0
5A22:  CALL   31E0
5A26:  MOVFF  01,84F
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
5A2A:  MOVLB  6
5A2C:  MOVF   xC7,F
5A2E:  BNZ   5A4E
5A30:  MOVF   xC6,F
5A32:  BNZ   5A4E
5A34:  MOVF   xC5,F
5A36:  BNZ   5A4E
5A38:  MOVF   xC4,W
5A3A:  SUBLW  04
5A3C:  BNC   5A4E
5A3E:  MOVLW  01
5A40:  ADDWF  xC4,F
5A42:  BTFSC  FD8.0
5A44:  INCF   xC5,F
5A46:  BTFSC  FD8.2
5A48:  INCF   xC6,F
5A4A:  BTFSC  FD8.2
5A4C:  INCF   xC7,F
....................   if(mcr_timeout==5) 
5A4E:  MOVF   xC4,W
5A50:  SUBLW  05
5A52:  BNZ   5ABE
5A54:  MOVF   xC5,F
5A56:  BNZ   5ABE
5A58:  MOVF   xC6,F
5A5A:  BNZ   5ABE
5A5C:  MOVF   xC7,F
5A5E:  BNZ   5ABE
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1) 
5A60:  DECFSZ xDA,W
5A62:  BRA    5A7C
....................       { 
....................           if(cryption_enable==0)  
5A64:  MOVLB  1
5A66:  MOVF   x22,F
5A68:  BNZ   5A74
....................           { 
....................                 saving_card(); 
5A6A:  MOVLB  0
5A6C:  GOTO   3C02
....................           } 
....................           else  
5A70:  BRA    5A7A
5A72:  MOVLB  1
....................           { 
....................                 saving_card_encrypt(); 
5A74:  MOVLB  0
5A76:  GOTO   4FD0
5A7A:  MOVLB  6
....................           } 
....................       } 
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
5A7C:  MOVLW  02
5A7E:  MOVWF  FEA
5A80:  MOVLW  46
5A82:  MOVWF  FE9
5A84:  CLRF   00
5A86:  MOVLW  03
5A88:  MOVWF  02
5A8A:  MOVLW  52
5A8C:  MOVWF  01
5A8E:  MOVLB  0
5A90:  CALL   359A
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
5A94:  MOVLW  05
5A96:  MOVWF  FEA
5A98:  MOVLW  98
5A9A:  MOVWF  FE9
5A9C:  CLRF   00
5A9E:  MOVLW  01
5AA0:  MOVWF  02
5AA2:  MOVLW  2C
5AA4:  MOVWF  01
5AA6:  CALL   359A
....................       //debug_card(); 
....................       count_reading_error=0; 
5AAA:  MOVLB  6
5AAC:  CLRF   xDB
....................       mcr_timeout++;   
5AAE:  MOVLW  01
5AB0:  ADDWF  xC4,F
5AB2:  BTFSC  FD8.0
5AB4:  INCF   xC5,F
5AB6:  BTFSC  FD8.2
5AB8:  INCF   xC6,F
5ABA:  BTFSC  FD8.2
5ABC:  INCF   xC7,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
5ABE:  MOVLB  9
5AC0:  CLRF   x1B
5AC2:  CLRF   x1A
5AC4:  CLRF   x19
5AC6:  MOVLW  3C
5AC8:  MOVWF  x18
5ACA:  MOVLB  0
5ACC:  CALL   3450
5AD0:  MOVFF  01,15A
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
5AD4:  MOVLW  02
5AD6:  MOVLB  8
5AD8:  MOVWF  x56
5ADA:  MOVLW  BC
5ADC:  MOVWF  x55
5ADE:  CLRF   x58
5AE0:  MOVFF  15A,857
5AE4:  MOVLB  0
5AE6:  CALL   3578
5AEA:  MOVFF  02,03
5AEE:  MOVF   01,W
5AF0:  MOVLB  1
5AF2:  MOVF   x00,W
5AF4:  SUBWF  02,W
5AF6:  BNC   5B16
5AF8:  BNZ   5B08
5AFA:  MOVF   01,W
5AFC:  MOVLB  0
5AFE:  SUBWF  xFF,W
5B00:  BTFSS  FD8.0
5B02:  BRA    5B08
5B04:  MOVLB  1
5B06:  BRA    5B16
5B08:  MOVLB  0
5B0A:  INCF   xFF,F
5B0C:  BTFSS  FD8.2
5B0E:  BRA    5B16
5B10:  MOVLB  1
5B12:  INCF   x00,F
5B14:  MOVLB  0
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
5B16:  MOVLW  02
5B18:  MOVLB  8
5B1A:  MOVWF  x56
5B1C:  MOVLW  BC
5B1E:  MOVWF  x55
5B20:  CLRF   x58
5B22:  MOVFF  15A,857
5B26:  MOVLB  0
5B28:  CALL   3578
5B2C:  MOVFF  02,03
5B30:  MOVF   01,W
5B32:  SUBWF  xFF,W
5B34:  BNZ   5BFA
5B36:  MOVF   03,W
5B38:  MOVLB  1
5B3A:  SUBWF  x00,W
5B3C:  BTFSC  FD8.2
5B3E:  BRA    5B44
5B40:  MOVLB  0
5B42:  BRA    5BFA
....................   { 
....................       charac_timeout++; 
5B44:  MOVLB  0
5B46:  INCF   xFF,F
5B48:  BTFSS  FD8.2
5B4A:  BRA    5B52
5B4C:  MOVLB  1
5B4E:  INCF   x00,F
5B50:  MOVLB  0
....................       buf=get_countcard(); 
5B52:  CALL   351C
5B56:  MOVFF  02,84E
5B5A:  MOVFF  01,84D
....................       if(buf<countcards) 
5B5E:  MOVLB  8
5B60:  MOVF   x4E,W
5B62:  SUBLW  03
5B64:  BNC   5B9A
5B66:  BNZ   5B6E
5B68:  MOVF   x4D,W
5B6A:  SUBLW  A1
5B6C:  BNC   5B9A
....................       { 
....................          if(cryption_enable==0)  
5B6E:  MOVLB  1
5B70:  MOVF   x22,F
5B72:  BNZ   5B7C
....................          { 
....................             save_key_new(); 
5B74:  MOVLB  0
5B76:  BRA    5476
....................          } 
....................          else 
5B78:  BRA    5B80
5B7A:  MOVLB  1
....................          { 
....................             save_key_encrypt(); 
5B7C:  MOVLB  0
5B7E:  BRA    5638
....................          } 
....................          buf=buf+1; 
5B80:  MOVLW  01
5B82:  MOVLB  8
5B84:  ADDWF  x4D,F
5B86:  MOVLW  00
5B88:  ADDWFC x4E,F
....................          save_coutcard(buf); 
5B8A:  MOVFF  84E,851
5B8E:  MOVFF  84D,850
5B92:  MOVLB  0
5B94:  RCALL  58B0
....................       } 
....................          else 
5B96:  BRA    5BAA
5B98:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
5B9A:  MOVLW  00
5B9C:  MOVWF  FF6
5B9E:  MOVLW  5C
5BA0:  MOVWF  FF7
5BA2:  MOVLB  0
5BA4:  CALL   172E
....................             return; 
5BA8:  BRA    5BFA
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
5BAA:  MOVLW  10
5BAC:  MOVWF  FF6
5BAE:  MOVLW  5C
5BB0:  MOVWF  FF7
5BB2:  CALL   172E
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
5BB6:  MOVLW  20
5BB8:  MOVWF  FF6
5BBA:  MOVLW  5C
5BBC:  MOVWF  FF7
5BBE:  MOVLW  14
5BC0:  MOVLB  8
5BC2:  MOVWF  xF7
5BC4:  MOVLB  0
5BC6:  CALL   164A
5BCA:  MOVLW  10
5BCC:  MOVWF  FE9
5BCE:  MOVFF  84E,851
5BD2:  MOVFF  84D,850
5BD6:  RCALL  58F8
5BD8:  MOVLW  37
5BDA:  MOVWF  FF6
5BDC:  MOVLW  5C
5BDE:  MOVWF  FF7
5BE0:  MOVLW  03
5BE2:  MOVLB  8
5BE4:  MOVWF  xF7
5BE6:  MOVLB  0
5BE8:  CALL   164A
....................       data_avai=0; 
5BEC:  MOVLB  6
5BEE:  CLRF   xD9
....................       enable_getpin=0; 
5BF0:  MOVLB  1
5BF2:  CLRF   x45
....................       //dis_getpin; 
....................       output_low(LED); 
5BF4:  BCF    F92.6
5BF6:  BCF    F89.6
5BF8:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
5BFA:  BCF    FF2.2
5BFC:  GOTO   006C
.................... void main() 
.................... {  
*
7CCA:  CLRF   FF8
7CCC:  BCF    FD0.7
7CCE:  BSF    07.7
7CD0:  CLRF   FEA
7CD2:  CLRF   FE9
7CD4:  BCF    F94.0
7CD6:  BSF    F8B.0
7CD8:  CLRF   23
7CDA:  CLRF   22
7CDC:  CLRF   21
7CDE:  MOVLW  96
7CE0:  MOVWF  20
7CE2:  CLRF   27
7CE4:  MOVLW  01
7CE6:  MOVWF  26
7CE8:  MOVLW  C3
7CEA:  MOVWF  25
7CEC:  MOVLW  0F
7CEE:  MOVWF  24
7CF0:  CLRF   xFE
7CF2:  CLRF   xFD
7CF4:  MOVLB  1
7CF6:  SETF   x00
7CF8:  MOVLB  0
7CFA:  SETF   xFF
7CFC:  MOVLB  1
7CFE:  CLRF   x22
7D00:  CLRF   x43
7D02:  CLRF   x44
7D04:  CLRF   x45
7D06:  MOVLW  64
7D08:  MOVWF  x46
7D0A:  CLRF   x47
7D0C:  CLRF   x48
7D0E:  CLRF   x49
7D10:  CLRF   x5A
7D12:  CLRF   x5F
7D14:  CLRF   xC6
7D16:  CLRF   xC7
7D18:  MOVLW  0E
7D1A:  MOVWF  xC9
7D1C:  MOVLW  01
7D1E:  MOVWF  xCA
7D20:  MOVWF  xCB
7D22:  CLRF   xCC
7D24:  CLRF   xCD
7D26:  CLRF   xCE
7D28:  MOVLB  6
7D2A:  CLRF   xC7
7D2C:  CLRF   xC6
7D2E:  CLRF   xC5
7D30:  CLRF   xC4
7D32:  CLRF   xC8
7D34:  CLRF   xCA
7D36:  CLRF   xC9
7D38:  CLRF   xCC
7D3A:  CLRF   xCB
7D3C:  CLRF   xCE
7D3E:  CLRF   xCD
7D40:  CLRF   xD0
7D42:  CLRF   xCF
7D44:  MOVLW  FD
7D46:  MOVWF  xD2
7D48:  MOVLW  E8
7D4A:  MOVWF  xD1
7D4C:  CLRF   xD4
7D4E:  CLRF   xD3
7D50:  CLRF   xD5
7D52:  CLRF   xD6
7D54:  CLRF   xD7
7D56:  CLRF   xD8
7D58:  CLRF   xD9
7D5A:  CLRF   xDA
7D5C:  CLRF   xDB
7D5E:  CLRF   xDC
7D60:  CLRF   xDD
7D62:  CLRF   xDF
7D64:  MOVLW  01
7D66:  MOVWF  xDE
7D68:  CLRF   xE1
7D6A:  CLRF   xE0
7D6C:  CLRF   xE2
7D6E:  CLRF   xE6
7D70:  CLRF   xE5
7D72:  CLRF   xE4
7D74:  CLRF   xE3
7D76:  MOVLW  FF
7D78:  MOVLB  F
7D7A:  MOVWF  x48
7D7C:  BCF    FC2.6
7D7E:  BCF    FC2.7
7D80:  MOVF   x49,W
7D82:  ANDLW  E0
7D84:  IORLW  1F
7D86:  MOVWF  x49
7D88:  CLRF   FD2
7D8A:  CLRF   FD1
7D8C:  CLRF   1A
7D8E:  CLRF   1B
7D90:  MOVLW  E8
7D92:  MOVLB  1
7D94:  MOVWF  x23
7D96:  MOVLW  E9
7D98:  MOVWF  x24
7D9A:  MOVLW  EA
7D9C:  MOVWF  x25
7D9E:  MOVLW  EB
7DA0:  MOVWF  x26
7DA2:  MOVLW  ED
7DA4:  MOVWF  x27
7DA6:  MOVLW  EE
7DA8:  MOVWF  x28
7DAA:  MOVLW  EF
7DAC:  MOVWF  x29
7DAE:  MOVLW  F0
7DB0:  MOVWF  x2A
7DB2:  MOVLW  F2
7DB4:  MOVWF  x2B
7DB6:  MOVLW  F3
7DB8:  MOVWF  x2C
7DBA:  MOVLW  F4
7DBC:  MOVWF  x2D
7DBE:  MOVLW  F5
7DC0:  MOVWF  x2E
7DC2:  MOVLW  F7
7DC4:  MOVWF  x2F
7DC6:  MOVLW  F8
7DC8:  MOVWF  x30
7DCA:  MOVLW  F9
7DCC:  MOVWF  x31
7DCE:  MOVLW  FA
7DD0:  MOVWF  x32
7DD2:  MOVLW  67
7DD4:  MOVWF  x33
7DD6:  MOVLW  43
7DD8:  MOVWF  x34
7DDA:  MOVLW  C3
7DDC:  MOVWF  x35
7DDE:  MOVLW  D1
7DE0:  MOVWF  x36
7DE2:  MOVLW  51
7DE4:  MOVWF  x37
7DE6:  MOVLW  9A
7DE8:  MOVWF  x38
7DEA:  MOVLW  B4
7DEC:  MOVWF  x39
7DEE:  MOVLW  F2
7DF0:  MOVWF  x3A
7DF2:  MOVLW  CD
7DF4:  MOVWF  x3B
7DF6:  MOVLW  9A
7DF8:  MOVWF  x3C
7DFA:  MOVLW  78
7DFC:  MOVWF  x3D
7DFE:  MOVLW  AB
7E00:  MOVWF  x3E
7E02:  MOVLW  09
7E04:  MOVWF  x3F
7E06:  MOVLW  A5
7E08:  MOVWF  x40
7E0A:  MOVLW  11
7E0C:  MOVWF  x41
7E0E:  MOVLW  BD
7E10:  MOVWF  x42
7E12:  CLRF   x5B
7E14:  BCF    x5C.0
7E16:  CLRF   x5D
7E18:  CLRF   x5E
7E1A:  CLRF   x60
7E1C:  BCF    x5C.1
7E1E:  CLRF   x61
7E20:  MOVLB  6
7E22:  CLRF   xF7
7E24:  CLRF   xF8
7E26:  CLRF   xF9
7E28:  CLRF   xFA
7E2A:  CLRF   xFB
7E2C:  CLRF   xFC
7E2E:  CLRF   xFD
7E30:  CLRF   xFE
7E32:  CLRF   xFF
7E34:  MOVLB  7
7E36:  CLRF   x00
7E38:  CLRF   x03
7E3A:  CLRF   x05
7E3C:  CLRF   x04
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    RPINR1=5; 
7E3E:  MOVLW  05
7E40:  MOVLB  E
7E42:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
7E44:  MOVLB  1
7E46:  SETF   x00
7E48:  MOVLB  0
7E4A:  SETF   xFF
....................    setup_oscillator(OSC_32MHZ); 
7E4C:  MOVLW  70
7E4E:  MOVWF  FD3
7E50:  MOVLW  40
7E52:  MOVWF  F9B
7E54:  MOVF   FD3,W
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
7E56:  BCF    FF2.6
7E58:  BCF    FF2.7
7E5A:  BTFSC  FF2.7
7E5C:  BRA    7E58
....................    init_ext_eeprom(); 
7E5E:  GOTO   5CF8
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif   
....................    //===================================== 
....................    delay_ms(1000); 
7E62:  MOVLW  04
7E64:  MOVLB  7
7E66:  MOVWF  xBD
7E68:  CLRF   19
7E6A:  BTFSC  FF2.7
7E6C:  BSF    19.7
7E6E:  BCF    FF2.7
7E70:  MOVLW  FA
7E72:  MOVLB  8
7E74:  MOVWF  x56
7E76:  MOVLB  0
7E78:  CALL   18C6
7E7C:  BTFSC  19.7
7E7E:  BSF    FF2.7
7E80:  MOVLB  7
7E82:  DECFSZ xBD,F
7E84:  BRA    7E68
....................    init_password(); 
7E86:  MOVLB  0
7E88:  CALL   5D02
....................    //===================================== 
....................     
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
7E8C:  MOVLW  19
7E8E:  MOVLB  7
7E90:  MOVWF  xBD
7E92:  MOVLB  0
7E94:  CALL   5DBE
7E98:  MOVFF  03,23
7E9C:  MOVFF  02,22
7EA0:  MOVFF  01,21
7EA4:  MOVFF  00,20
....................    printf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
7EA8:  CLRF   FEA
7EAA:  MOVLW  01
7EAC:  MOVWF  FE9
7EAE:  CALL   5F14
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
7EB2:  MOVLW  1E
7EB4:  MOVLB  7
7EB6:  MOVWF  xBD
7EB8:  MOVLB  0
7EBA:  CALL   5DBE
7EBE:  MOVFF  03,27
7EC2:  MOVFF  02,26
7EC6:  MOVFF  01,25
7ECA:  MOVFF  00,24
....................    fprintf(COM2,"booting\n\r"); 
7ECE:  MOVLW  3C
7ED0:  MOVWF  FF6
7ED2:  MOVLW  5C
7ED4:  MOVWF  FF7
7ED6:  CLRF   19
7ED8:  BTFSC  FF2.7
7EDA:  BSF    19.7
7EDC:  BCF    FF2.7
7EDE:  CALL   172E
7EE2:  BTFSC  19.7
7EE4:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
7EE6:  MOVLW  46
7EE8:  MOVWF  FF6
7EEA:  MOVLW  5C
7EEC:  MOVWF  FF7
7EEE:  CLRF   19
7EF0:  BTFSC  FF2.7
7EF2:  BSF    19.7
7EF4:  BCF    FF2.7
7EF6:  MOVLW  12
7EF8:  MOVLB  8
7EFA:  MOVWF  xF7
7EFC:  MOVLB  0
7EFE:  CALL   164A
7F02:  BTFSC  19.7
7F04:  BSF    FF2.7
7F06:  MOVLW  41
7F08:  MOVWF  FE9
7F0A:  CLRF   19
7F0C:  BTFSC  FF2.7
7F0E:  BSF    19.7
7F10:  BCF    FF2.7
7F12:  MOVFF  27,8FA
7F16:  MOVFF  26,8F9
7F1A:  MOVFF  25,8F8
7F1E:  MOVFF  24,8F7
7F22:  CALL   22FA
7F26:  BTFSC  19.7
7F28:  BSF    FF2.7
7F2A:  CLRF   19
7F2C:  BTFSC  FF2.7
7F2E:  BSF    19.7
7F30:  BCF    FF2.7
7F32:  MOVLW  0A
7F34:  MOVLB  9
7F36:  MOVWF  x0C
7F38:  MOVLB  0
7F3A:  CALL   1604
7F3E:  BTFSC  19.7
7F40:  BSF    FF2.7
7F42:  CLRF   19
7F44:  BTFSC  FF2.7
7F46:  BSF    19.7
7F48:  BCF    FF2.7
7F4A:  MOVLW  0D
7F4C:  MOVLB  9
7F4E:  MOVWF  x0C
7F50:  MOVLB  0
7F52:  CALL   1604
7F56:  BTFSC  19.7
7F58:  BSF    FF2.7
7F5A:  CLRF   19
7F5C:  BTFSC  FF2.7
7F5E:  BSF    19.7
7F60:  BCF    FF2.7
....................    countcard=get_countcard(); 
7F62:  CALL   351C
7F66:  BTFSC  19.7
7F68:  BSF    FF2.7
7F6A:  MOVFF  02,FE
7F6E:  MOVFF  01,FD
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
7F72:  MOVLB  1
7F74:  SETF   x00
7F76:  MOVLB  0
7F78:  SETF   xFF
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
7F7A:  MOVLW  C7
7F7C:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
7F7E:  MOVLW  37
7F80:  MOVWF  FCD
7F82:  CLRF   F9A
7F84:  CLRF   19
7F86:  BTFSC  FF2.7
7F88:  BSF    19.7
7F8A:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
7F8C:  MOVLB  9
7F8E:  CLRF   x1B
7F90:  CLRF   x1A
7F92:  CLRF   x19
7F94:  MOVLW  3C
7F96:  MOVWF  x18
7F98:  MOVLB  0
7F9A:  CALL   3450
7F9E:  BTFSC  19.7
7FA0:  BSF    FF2.7
7FA2:  MOVFF  01,15A
....................    if(delaycharaction==0)delaycharaction=1; 
7FA6:  MOVLB  1
7FA8:  MOVF   x5A,F
7FAA:  BNZ   7FB0
7FAC:  MOVLW  01
7FAE:  MOVWF  x5A
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
7FB0:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
7FB2:  BSF    FF0.3
7FB4:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
7FB6:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
7FB8:  MOVLW  C0
7FBA:  IORWF  FF2,F
....................   
....................     mcr_timeout=10000; 
7FBC:  MOVLB  6
7FBE:  CLRF   xC7
7FC0:  CLRF   xC6
7FC2:  MOVLW  27
7FC4:  MOVWF  xC5
7FC6:  MOVLW  10
7FC8:  MOVWF  xC4
7FCA:  CLRF   19
7FCC:  BTFSC  FF2.7
7FCE:  BSF    19.7
7FD0:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
7FD2:  MOVLB  9
7FD4:  CLRF   x1B
7FD6:  CLRF   x1A
7FD8:  CLRF   x19
7FDA:  MOVLW  3A
7FDC:  MOVWF  x18
7FDE:  MOVLB  0
7FE0:  CALL   3450
7FE4:  BTFSC  19.7
7FE6:  BSF    FF2.7
7FE8:  MOVFF  01,6E2
7FEC:  CLRF   19
7FEE:  BTFSC  FF2.7
7FF0:  BSF    19.7
7FF2:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
7FF4:  MOVLB  9
7FF6:  CLRF   x1B
7FF8:  CLRF   x1A
7FFA:  CLRF   x19
7FFC:  MOVLW  3B
7FFE:  MOVWF  x18
8000:  MOVLB  0
8002:  CALL   3450
8006:  BTFSC  19.7
8008:  BSF    FF2.7
800A:  MOVFF  01,6D6
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
800E:  MOVLB  1
8010:  SETF   x00
8012:  MOVLB  0
8014:  SETF   xFF
8016:  CLRF   19
8018:  BTFSC  FF2.7
801A:  BSF    19.7
801C:  BCF    FF2.7
....................     
....................    EEPROM_read(strobe_nameconsole,wide_strobe_nameconsole,console); 
801E:  MOVLB  9
8020:  CLRF   x07
8022:  CLRF   x06
8024:  CLRF   x05
8026:  MOVLW  28
8028:  MOVWF  x04
802A:  CLRF   x0B
802C:  CLRF   x0A
802E:  CLRF   x09
8030:  MOVLW  10
8032:  MOVWF  x08
8034:  MOVLW  06
8036:  MOVWF  x0D
8038:  MOVLW  E7
803A:  MOVWF  x0C
803C:  MOVLB  0
803E:  CALL   4004
8042:  BTFSC  19.7
8044:  BSF    FF2.7
....................    set_tris_a(0xff);  
8046:  MOVLW  FF
8048:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
804A:  MOVLW  E0
804C:  MOVLB  F
804E:  MOVWF  x48
8050:  BCF    FC2.6
8052:  BCF    FC2.7
8054:  MOVF   x49,W
8056:  ANDLW  E0
8058:  IORLW  1F
805A:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
805C:  MOVF   FC1,W
805E:  ANDLW  C0
8060:  IORLW  03
8062:  MOVWF  FC1
8064:  BCF    FC1.7
8066:  BSF    FC2.0
8068:  BSF    FC1.6
806A:  BSF    FC2.1
806C:  BTFSC  FC2.1
806E:  BRA    806C
8070:  BCF    FC1.6
8072:  CLRF   19
8074:  BTFSC  FF2.7
8076:  BSF    19.7
8078:  BCF    FF2.7
....................     
....................    type_KB=read_ext_eeprom(kindofKB); 
807A:  MOVLB  9
807C:  CLRF   x1B
807E:  CLRF   x1A
8080:  CLRF   x19
8082:  MOVLW  3D
8084:  MOVWF  x18
8086:  MOVLB  0
8088:  CALL   3450
808C:  BTFSC  19.7
808E:  BSF    FF2.7
8090:  MOVFF  01,149
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
8094:  MOVLB  1
8096:  MOVF   x49,F
8098:  BZ    80B8
809A:  MOVLW  5E
809C:  MOVWF  FF6
809E:  MOVLW  5C
80A0:  MOVWF  FF7
80A2:  CLRF   19
80A4:  BTFSC  FF2.7
80A6:  BSF    19.7
80A8:  BCF    FF2.7
80AA:  MOVLB  0
80AC:  CALL   172E
80B0:  BTFSC  19.7
80B2:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
80B4:  BRA    80D2
80B6:  MOVLB  1
80B8:  MOVLW  72
80BA:  MOVWF  FF6
80BC:  MOVLW  5C
80BE:  MOVWF  FF7
80C0:  CLRF   19
80C2:  BTFSC  FF2.7
80C4:  BSF    19.7
80C6:  BCF    FF2.7
80C8:  MOVLB  0
80CA:  CALL   172E
80CE:  BTFSC  19.7
80D0:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
80D2:  MOVLB  6
80D4:  MOVF   xE2,F
80D6:  BNZ   80F6
80D8:  MOVLW  86
80DA:  MOVWF  FF6
80DC:  MOVLW  5C
80DE:  MOVWF  FF7
80E0:  CLRF   19
80E2:  BTFSC  FF2.7
80E4:  BSF    19.7
80E6:  BCF    FF2.7
80E8:  MOVLB  0
80EA:  CALL   172E
80EE:  BTFSC  19.7
80F0:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
80F2:  BRA    8110
80F4:  MOVLB  6
80F6:  MOVLW  A0
80F8:  MOVWF  FF6
80FA:  MOVLW  5C
80FC:  MOVWF  FF7
80FE:  CLRF   19
8100:  BTFSC  FF2.7
8102:  BSF    19.7
8104:  BCF    FF2.7
8106:  MOVLB  0
8108:  CALL   172E
810C:  BTFSC  19.7
810E:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
8110:  MOVLW  01
8112:  MOVWF  FEA
8114:  MOVLW  4A
8116:  MOVWF  FE9
8118:  CLRF   00
811A:  CLRF   02
811C:  MOVLW  10
811E:  MOVWF  01
8120:  CALL   359A
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
8124:  MOVLB  7
8126:  CLRF   x01
8128:  MOVF   x01,W
812A:  SUBLW  13
812C:  BNC   8142
....................    { 
....................       password[i] = 0; 
812E:  CLRF   03
8130:  MOVF   x01,W
8132:  ADDLW  55
8134:  MOVWF  FE9
8136:  MOVLW  00
8138:  ADDWFC 03,W
813A:  MOVWF  FEA
813C:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 0 
....................    disable_interrupts(GLOBAL); 
....................    save_coutcard(0); 
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................     
....................    save_key_encrypt(); 
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
....................     
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_data in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_key in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],1); 
....................    //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rdecrypted:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    while(1); 
.................... #endif 
.................... #if 0 
813E:  INCF   x01,F
8140:  BRA    8128
8142:  CLRF   19
8144:  BTFSC  FF2.7
8146:  BSF    19.7
8148:  BCF    FF2.7
....................     fprintf(COM2,"\n\reeprom test\n\r"); 
....................     fprintf(COM2,"\n\reeprom is writing\n\r"); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         //write_ext_eeprom(115535+i,i); 
....................     } 
....................     write_ext_eeprom(EEPROM_KEY_ST,210); 
....................     write_ext_eeprom(EEPROM_SIZE_endofkey,123); 
....................     fprintf(COM2,"\n\r"); 
....................     fprintf(COM2,"eeprom is reading: %u",read_ext_eeprom(EEPROM_KEY_ST)); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         fprintf(COM2," %u",read_ext_eeprom(115535+i)); 
....................     } 
....................     while(1); 
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
814A:  MOVLB  9
814C:  CLRF   x07
814E:  CLRF   x06
8150:  CLRF   x05
8152:  CLRF   x04
8154:  CLRF   x0B
8156:  CLRF   x0A
8158:  CLRF   x09
815A:  MOVLW  14
815C:  MOVWF  x08
815E:  CLRF   x0D
8160:  MOVLW  55
8162:  MOVWF  x0C
8164:  MOVLB  0
8166:  CALL   4004
816A:  BTFSC  19.7
816C:  BSF    FF2.7
816E:  CLRF   19
8170:  BTFSC  FF2.7
8172:  BSF    19.7
8174:  BCF    FF2.7
....................    cryption_enable = read_ext_eeprom(crypto_en); 
8176:  MOVLB  9
8178:  CLRF   x1B
817A:  CLRF   x1A
817C:  CLRF   x19
817E:  MOVLW  3E
8180:  MOVWF  x18
8182:  MOVLB  0
8184:  CALL   3450
8188:  BTFSC  19.7
818A:  BSF    FF2.7
818C:  MOVFF  01,122
....................    if(cryption_enable!=0) 
8190:  MOVLB  1
8192:  MOVF   x22,F
8194:  BZ    81E2
....................    { 
....................         fprintf(COM2,"\n\crypto is enable\n\r"); 
8196:  MOVLW  B8
8198:  MOVWF  FF6
819A:  MOVLW  5C
819C:  MOVWF  FF7
819E:  CLRF   19
81A0:  BTFSC  FF2.7
81A2:  BSF    19.7
81A4:  BCF    FF2.7
81A6:  MOVLB  0
81A8:  CALL   172E
81AC:  BTFSC  19.7
81AE:  BSF    FF2.7
81B0:  CLRF   19
81B2:  BTFSC  FF2.7
81B4:  BSF    19.7
81B6:  BCF    FF2.7
....................         EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key);  
81B8:  MOVLB  9
81BA:  CLRF   x07
81BC:  CLRF   x06
81BE:  CLRF   x05
81C0:  MOVLW  3F
81C2:  MOVWF  x04
81C4:  CLRF   x0B
81C6:  CLRF   x0A
81C8:  CLRF   x09
81CA:  MOVLW  20
81CC:  MOVWF  x08
81CE:  MOVLW  01
81D0:  MOVWF  x0D
81D2:  MOVWF  x0C
81D4:  MOVLB  0
81D6:  CALL   4004
81DA:  BTFSC  19.7
81DC:  BSF    FF2.7
....................    } 
....................    else 
81DE:  BRA    81FC
81E0:  MOVLB  1
....................    { 
....................        fprintf(COM2,"\n\crypto is disable\n\r"); 
81E2:  MOVLW  CC
81E4:  MOVWF  FF6
81E6:  MOVLW  5C
81E8:  MOVWF  FF7
81EA:  CLRF   19
81EC:  BTFSC  FF2.7
81EE:  BSF    19.7
81F0:  BCF    FF2.7
81F2:  MOVLB  0
81F4:  CALL   172E
81F8:  BTFSC  19.7
81FA:  BSF    FF2.7
....................    } 
.................... #if 0    
....................    fprintf(COM2,"\n\crypto key:\n\r"); 
....................    for(i=0;i<CRYPTO_KEY_SIZE;i++) 
....................    { 
....................         fprintf(COM2,"%c",crypto_key[i]); 
....................    } 
....................    fprintf(COM2,"\n\r"); 
.................... #endif    
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
81FC:  MOVLB  6
81FE:  MOVF   xDC,F
8200:  BNZ   82B8
....................       { 
....................          fprintf(COM2,"password:"); 
8202:  MOVLW  E2
8204:  MOVWF  FF6
8206:  MOVLW  5C
8208:  MOVWF  FF7
820A:  CLRF   19
820C:  BTFSC  FF2.7
820E:  BSF    19.7
8210:  BCF    FF2.7
8212:  MOVLB  0
8214:  CALL   172E
8218:  BTFSC  19.7
821A:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
821C:  MOVLW  02
821E:  MOVLB  7
8220:  MOVWF  xF3
8222:  MOVLW  14
8224:  MOVWF  xF4
8226:  MOVLW  01
8228:  MOVWF  xF6
822A:  MOVLW  62
822C:  MOVWF  xF5
822E:  MOVLB  0
8230:  CALL   5F94
8234:  CLRF   19
8236:  BTFSC  FF2.7
8238:  BSF    19.7
823A:  BCF    FF2.7
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
823C:  MOVLB  9
823E:  CLRF   x07
8240:  CLRF   x06
8242:  CLRF   x05
8244:  CLRF   x04
8246:  CLRF   x0B
8248:  CLRF   x0A
824A:  CLRF   x09
824C:  MOVLW  14
824E:  MOVWF  x08
8250:  CLRF   x0D
8252:  MOVLW  55
8254:  MOVWF  x0C
8256:  MOVLB  0
8258:  CALL   4004
825C:  BTFSC  19.7
825E:  BSF    FF2.7
....................          if(!stringcomp(buffer_uart,password)) 
8260:  MOVLW  01
8262:  MOVLB  7
8264:  MOVWF  xF4
8266:  MOVLW  62
8268:  MOVWF  xF3
826A:  CLRF   xF6
826C:  MOVLW  55
826E:  MOVWF  xF5
8270:  MOVLB  0
8272:  CALL   60CC
8276:  MOVF   01,F
8278:  BNZ   829C
....................          { 
....................             mode=LOGON; 
827A:  MOVLW  01
827C:  MOVLB  6
827E:  MOVWF  xDC
....................             fprintf(COM2," OK\n\r"); 
8280:  MOVLW  EC
8282:  MOVWF  FF6
8284:  MOVLW  5C
8286:  MOVWF  FF7
8288:  CLRF   19
828A:  BTFSC  FF2.7
828C:  BSF    19.7
828E:  BCF    FF2.7
8290:  MOVLB  0
8292:  CALL   172E
8296:  BTFSC  19.7
8298:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
829A:  BRA    82B4
829C:  MOVLW  F2
829E:  MOVWF  FF6
82A0:  MOVLW  5C
82A2:  MOVWF  FF7
82A4:  CLRF   19
82A6:  BTFSC  FF2.7
82A8:  BSF    19.7
82AA:  BCF    FF2.7
82AC:  CALL   172E
82B0:  BTFSC  19.7
82B2:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
82B4:  BRA    82C2
82B6:  MOVLB  6
82B8:  DECFSZ xDC,W
82BA:  BRA    82C4
82BC:  MOVLB  0
82BE:  GOTO   6B8A
82C2:  MOVLB  6
....................    } 
82C4:  BRA    81FE
.................... } 
82C6:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

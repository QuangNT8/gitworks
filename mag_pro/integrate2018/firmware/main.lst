CCS PCH C Compiler, Version 4.140, 33034               22-Jul-18 17:51

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   30946 bytes (47%)
                           Largest free fragment is 34578
               RAM used:   1979 (52%) at main() level
                           2148 (57%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   7326
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   518A
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1BA8
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0642:  MOVLW  02
0644:  MOVLB  8
0646:  SUBWF  x27,F
0648:  BNC   0662
064A:  MOVLW  08
064C:  MOVWF  FEA
064E:  MOVLW  27
0650:  MOVWF  FE9
0652:  MOVF   FEF,W
0654:  BZ    0662
0656:  BRA    065E
0658:  BRA    065A
065A:  BRA    065C
065C:  NOP   
065E:  DECFSZ FEF,F
0660:  BRA    0658
0662:  MOVLB  0
0664:  GOTO   1BB8 (RETURN)
*
1882:  MOVLW  08
1884:  MOVWF  FEA
1886:  MOVLW  2F
1888:  MOVWF  FE9
188A:  MOVF   FEF,W
188C:  BZ    18A8
188E:  MOVLW  0A
1890:  MOVWF  01
1892:  CLRF   00
1894:  DECFSZ 00,F
1896:  BRA    1894
1898:  DECFSZ 01,F
189A:  BRA    1892
189C:  MOVLW  5F
189E:  MOVWF  00
18A0:  DECFSZ 00,F
18A2:  BRA    18A0
18A4:  DECFSZ FEF,F
18A6:  BRA    188E
18A8:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
15C0:  BCF    F94.0
15C2:  BCF    F8B.0
15C4:  MOVLW  08
15C6:  MOVWF  01
15C8:  BRA    15CA
15CA:  NOP   
15CC:  BSF    01.7
15CE:  BRA    15F0
15D0:  BCF    01.7
15D2:  MOVLB  8
15D4:  RRCF   x52,F
15D6:  MOVLB  0
15D8:  BTFSC  FD8.0
15DA:  BSF    F8B.0
15DC:  BTFSS  FD8.0
15DE:  BCF    F8B.0
15E0:  BSF    01.6
15E2:  BRA    15F0
15E4:  BCF    01.6
15E6:  DECFSZ 01,F
15E8:  BRA    15D2
15EA:  BRA    15EC
15EC:  NOP   
15EE:  BSF    F8B.0
15F0:  MOVLW  10
15F2:  MOVWF  FE9
15F4:  DECFSZ FE9,F
15F6:  BRA    15F4
15F8:  BRA    15FA
15FA:  NOP   
15FC:  BTFSC  01.7
15FE:  BRA    15D0
1600:  BTFSC  01.6
1602:  BRA    15E4
1604:  RETURN 0
*
5744:  BSF    F94.1
5746:  BTFSC  F82.1
5748:  BRA    5746
574A:  MOVLW  08
574C:  MOVWF  00
574E:  MOVLB  7
5750:  CLRF   xFA
5752:  BSF    00.7
5754:  BRA    5776
5756:  BCF    00.7
5758:  BRA    5776
575A:  MOVFF  7FA,02
575E:  BCF    FD8.0
5760:  BTFSC  F82.1
5762:  BSF    FD8.0
5764:  RRCF   02,F
5766:  BSF    00.6
5768:  BRA    5776
576A:  BCF    00.6
576C:  DECFSZ 00,F
576E:  BRA    575E
5770:  MOVFF  02,01
5774:  BRA    578E
5776:  MOVLW  10
5778:  BTFSC  00.7
577A:  MOVLW  04
577C:  MOVWF  01
577E:  DECFSZ 01,F
5780:  BRA    577E
5782:  BRA    5784
5784:  BTFSC  00.7
5786:  BRA    5756
5788:  BTFSC  00.6
578A:  BRA    576A
578C:  BRA    575E
578E:  MOVLB  0
5790:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3320:  MOVLW  08
3322:  MOVWF  01
3324:  MOVLW  0A
3326:  MOVWF  00
3328:  DECFSZ 00,F
332A:  BRA    3328
332C:  BCF    F8B.3
332E:  BCF    F94.3
3330:  MOVLW  0B
3332:  MOVWF  00
3334:  DECFSZ 00,F
3336:  BRA    3334
3338:  MOVLB  8
333A:  RLCF   x5C,F
333C:  BCF    F8B.4
333E:  BTFSC  FD8.0
3340:  BSF    F94.4
3342:  BTFSS  FD8.0
3344:  BCF    F94.4
3346:  BSF    F94.3
3348:  BTFSS  F82.3
334A:  BRA    3348
334C:  DECFSZ 01,F
334E:  BRA    3352
3350:  BRA    3356
3352:  MOVLB  0
3354:  BRA    3324
3356:  MOVLW  0A
3358:  MOVWF  00
335A:  DECFSZ 00,F
335C:  BRA    335A
335E:  BCF    F8B.3
3360:  BCF    F94.3
3362:  NOP   
3364:  BSF    F94.4
3366:  MOVLW  0B
3368:  MOVWF  00
336A:  DECFSZ 00,F
336C:  BRA    336A
336E:  MOVLW  0B
3370:  MOVWF  00
3372:  DECFSZ 00,F
3374:  BRA    3372
3376:  BSF    F94.3
3378:  BTFSS  F82.3
337A:  BRA    3378
337C:  CLRF   01
337E:  MOVLW  0B
3380:  MOVWF  00
3382:  DECFSZ 00,F
3384:  BRA    3382
3386:  BTFSC  F82.4
3388:  BSF    01.0
338A:  BCF    F8B.3
338C:  BCF    F94.3
338E:  BCF    F8B.4
3390:  BCF    F94.4
3392:  MOVLB  0
3394:  RETURN 0
3396:  MOVLW  08
3398:  MOVLB  8
339A:  MOVWF  x4A
339C:  MOVFF  00,84B
33A0:  BSF    F94.4
33A2:  MOVLW  0B
33A4:  MOVWF  00
33A6:  DECFSZ 00,F
33A8:  BRA    33A6
33AA:  BSF    F94.3
33AC:  BTFSS  F82.3
33AE:  BRA    33AC
33B0:  BTFSC  F82.4
33B2:  BSF    FD8.0
33B4:  BTFSS  F82.4
33B6:  BCF    FD8.0
33B8:  RLCF   01,F
33BA:  MOVLW  0A
33BC:  MOVWF  00
33BE:  DECFSZ 00,F
33C0:  BRA    33BE
33C2:  BCF    F94.3
33C4:  BCF    F8B.3
33C6:  DECFSZ x4A,F
33C8:  BRA    33A0
33CA:  BSF    F94.4
33CC:  MOVLW  0B
33CE:  MOVWF  00
33D0:  DECFSZ 00,F
33D2:  BRA    33D0
33D4:  BCF    F8B.4
33D6:  MOVF   x4B,W
33D8:  BTFSS  FD8.2
33DA:  BCF    F94.4
33DC:  NOP   
33DE:  BSF    F94.3
33E0:  BTFSS  F82.3
33E2:  BRA    33E0
33E4:  MOVLW  0A
33E6:  MOVWF  00
33E8:  DECFSZ 00,F
33EA:  BRA    33E8
33EC:  BCF    F8B.3
33EE:  BCF    F94.3
33F0:  MOVLW  0B
33F2:  MOVWF  00
33F4:  DECFSZ 00,F
33F6:  BRA    33F4
33F8:  BCF    F8B.4
33FA:  BCF    F94.4
33FC:  MOVLB  0
33FE:  RETURN 0
....................  
.................... #define ptr_start                       150 
.................... #define EEPROM_SIZE_endofkey            131071 
.................... #define EEPROM_SIZE_stofkey             115470 
.................... #define EEPROM_KEY_ST                   EEPROM_SIZE_stofkey+1 
.................... //=============================== 
....................  
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5462:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
5464:  BSF    F94.4
....................    port_b_pullups(0xff); 
5466:  BCF    FF1.7
.................... } 
5468:  GOTO   74B8 (RETURN)
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3934:  MOVLB  8
3936:  MOVF   x53,F
3938:  BNZ   3940
393A:  MOVF   x52,W
393C:  SUBLW  00
393E:  BC    3946
3940:  MOVLW  A8
3942:  MOVWF  x56
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3944:  BRA    394A
3946:  MOVLW  A0
3948:  MOVWF  x56
....................  
....................    i2c_start(); 
394A:  BSF    F94.4
394C:  MOVLW  0A
394E:  MOVWF  00
3950:  DECFSZ 00,F
3952:  BRA    3950
3954:  BSF    F94.3
3956:  MOVLW  0B
3958:  MOVWF  00
395A:  DECFSZ 00,F
395C:  BRA    395A
395E:  BCF    F8B.4
3960:  BCF    F94.4
3962:  MOVLW  0A
3964:  MOVWF  00
3966:  DECFSZ 00,F
3968:  BRA    3966
396A:  BCF    F8B.3
396C:  BCF    F94.3
....................    i2c_write(command); 
396E:  MOVFF  856,85C
3972:  MOVLB  0
3974:  RCALL  3320
....................    i2c_write(address>>8); 
3976:  MOVFF  851,858
397A:  MOVFF  852,859
397E:  MOVFF  853,85A
3982:  MOVLB  8
3984:  CLRF   x5B
3986:  MOVFF  851,85C
398A:  MOVLB  0
398C:  RCALL  3320
....................    i2c_write(address); 
398E:  MOVFF  850,85C
3992:  RCALL  3320
....................    i2c_write(data); 
3994:  MOVFF  854,85C
3998:  RCALL  3320
....................  
....................    i2c_stop(); 
399A:  BCF    F94.4
399C:  NOP   
399E:  BSF    F94.3
39A0:  BTFSS  F82.3
39A2:  BRA    39A0
39A4:  MOVLW  0A
39A6:  MOVWF  00
39A8:  DECFSZ 00,F
39AA:  BRA    39A8
39AC:  BRA    39AE
39AE:  NOP   
39B0:  BSF    F94.4
39B2:  MOVLW  0A
39B4:  MOVWF  00
39B6:  DECFSZ 00,F
39B8:  BRA    39B6
....................    i2c_start(); 
39BA:  BSF    F94.4
39BC:  MOVLW  0A
39BE:  MOVWF  00
39C0:  DECFSZ 00,F
39C2:  BRA    39C0
39C4:  BSF    F94.3
39C6:  MOVLW  0B
39C8:  MOVWF  00
39CA:  DECFSZ 00,F
39CC:  BRA    39CA
39CE:  BCF    F8B.4
39D0:  BCF    F94.4
39D2:  MOVLW  0A
39D4:  MOVWF  00
39D6:  DECFSZ 00,F
39D8:  BRA    39D6
39DA:  BCF    F8B.3
39DC:  BCF    F94.3
....................    status=i2c_write(command); 
39DE:  MOVFF  856,85C
39E2:  RCALL  3320
39E4:  MOVF   01,W
39E6:  MOVLB  8
39E8:  BCF    x55.0
39EA:  BTFSC  01.0
39EC:  BSF    x55.0
....................    while(status==1) 
....................    { 
39EE:  BTFSS  x55.0
39F0:  BRA    3A2E
....................       i2c_start(); 
39F2:  BSF    F94.4
39F4:  MOVLW  0A
39F6:  MOVWF  00
39F8:  DECFSZ 00,F
39FA:  BRA    39F8
39FC:  BSF    F94.3
39FE:  MOVLW  0B
3A00:  MOVWF  00
3A02:  DECFSZ 00,F
3A04:  BRA    3A02
3A06:  BTFSS  F82.3
3A08:  BRA    3A06
3A0A:  BCF    F8B.4
3A0C:  BCF    F94.4
3A0E:  MOVLW  0A
3A10:  MOVWF  00
3A12:  DECFSZ 00,F
3A14:  BRA    3A12
3A16:  BCF    F8B.3
3A18:  BCF    F94.3
....................       status=i2c_write(command); 
3A1A:  MOVFF  856,85C
3A1E:  MOVLB  0
3A20:  RCALL  3320
3A22:  MOVF   01,W
3A24:  MOVLB  8
3A26:  BCF    x55.0
3A28:  BTFSC  01.0
3A2A:  BSF    x55.0
....................    } 
3A2C:  BRA    39EE
....................    //delay_us(100); 
.................... } 
3A2E:  MOVLB  0
3A30:  RETURN 0
....................  
....................  
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3400:  MOVLB  8
3402:  MOVF   x46,F
3404:  BNZ   340C
3406:  MOVF   x45,W
3408:  SUBLW  00
340A:  BC    3412
340C:  MOVLW  A8
340E:  MOVWF  x48
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3410:  BRA    3416
3412:  MOVLW  A0
3414:  MOVWF  x48
....................  
....................    i2c_start(); 
3416:  BSF    F94.4
3418:  MOVLW  0A
341A:  MOVWF  00
341C:  DECFSZ 00,F
341E:  BRA    341C
3420:  BSF    F94.3
3422:  MOVLW  0B
3424:  MOVWF  00
3426:  DECFSZ 00,F
3428:  BRA    3426
342A:  BTFSS  F82.3
342C:  BRA    342A
342E:  BCF    F8B.4
3430:  BCF    F94.4
3432:  MOVLW  0A
3434:  MOVWF  00
3436:  DECFSZ 00,F
3438:  BRA    3436
343A:  BCF    F8B.3
343C:  BCF    F94.3
....................    i2c_write(command); 
343E:  MOVFF  848,85C
3442:  MOVLB  0
3444:  RCALL  3320
....................    i2c_write(address>>8); 
3446:  MOVFF  844,84A
344A:  MOVFF  845,84B
344E:  MOVFF  846,84C
3452:  MOVLB  8
3454:  CLRF   x4D
3456:  MOVFF  844,85C
345A:  MOVLB  0
345C:  RCALL  3320
....................    i2c_write(address); 
345E:  MOVFF  843,85C
3462:  RCALL  3320
....................    i2c_start(); 
3464:  BSF    F94.4
3466:  MOVLW  0A
3468:  MOVWF  00
346A:  DECFSZ 00,F
346C:  BRA    346A
346E:  BSF    F94.3
3470:  MOVLW  0B
3472:  MOVWF  00
3474:  DECFSZ 00,F
3476:  BRA    3474
3478:  BTFSS  F82.3
347A:  BRA    3478
347C:  BCF    F8B.4
347E:  BCF    F94.4
3480:  MOVLW  0A
3482:  MOVWF  00
3484:  DECFSZ 00,F
3486:  BRA    3484
3488:  BCF    F8B.3
348A:  BCF    F94.3
....................    i2c_write(command+1); 
348C:  MOVLW  01
348E:  MOVLB  8
3490:  ADDWF  x48,W
3492:  MOVWF  x49
3494:  MOVWF  x5C
3496:  MOVLB  0
3498:  RCALL  3320
....................    data=i2c_read(0); 
349A:  CLRF   00
349C:  RCALL  3396
349E:  MOVFF  01,847
....................    i2c_stop(); 
34A2:  BCF    F94.4
34A4:  NOP   
34A6:  BSF    F94.3
34A8:  BTFSS  F82.3
34AA:  BRA    34A8
34AC:  MOVLW  0A
34AE:  MOVWF  00
34B0:  DECFSZ 00,F
34B2:  BRA    34B0
34B4:  BRA    34B6
34B6:  NOP   
34B8:  BSF    F94.4
34BA:  MOVLW  0A
34BC:  MOVWF  00
34BE:  DECFSZ 00,F
34C0:  BRA    34BE
....................    return(data); 
34C2:  MOVLB  8
34C4:  MOVFF  847,01
.................... } 
34C8:  MOVLB  0
34CA:  RETURN 0
....................  
....................  
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE_stofkey) return(0); 
*
5962:  MOVLB  7
5964:  MOVF   xF5,W
5966:  ADDWF  xF3,W
5968:  MOVF   xF6,W
596A:  ADDWFC xF4,W
596C:  MOVWF  xFC
....................    for(i=0;i<len;i++) 
596E:  CLRF   xFA
5970:  CLRF   xF9
5972:  MOVF   xFA,W
5974:  SUBWF  xF6,W
5976:  BNC   59D2
5978:  BNZ   5980
597A:  MOVF   xF5,W
597C:  SUBWF  xF9,W
597E:  BC    59D2
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
5980:  MOVF   xF7,W
5982:  ADDWF  xF9,W
5984:  MOVWF  01
5986:  MOVF   xF8,W
5988:  ADDWFC xFA,W
598A:  MOVWF  03
598C:  MOVFF  01,7FB
5990:  MOVWF  xFC
5992:  MOVF   xF9,W
5994:  ADDWF  xF3,W
5996:  MOVWF  xFD
5998:  MOVF   xFA,W
599A:  ADDWFC xF4,W
599C:  MOVWF  xFE
599E:  CLRF   19
59A0:  BTFSC  FF2.7
59A2:  BSF    19.7
59A4:  BCF    FF2.7
59A6:  MOVLB  8
59A8:  CLRF   x46
59AA:  CLRF   x45
59AC:  MOVWF  x44
59AE:  MOVFF  7FD,843
59B2:  MOVLB  0
59B4:  CALL   3400
59B8:  BTFSC  19.7
59BA:  BSF    FF2.7
59BC:  MOVFF  7FC,FEA
59C0:  MOVFF  7FB,FE9
59C4:  MOVFF  01,FEF
....................    } 
59C8:  MOVLB  7
59CA:  INCF   xF9,F
59CC:  BTFSC  FD8.2
59CE:  INCF   xFA,F
59D0:  BRA    5972
....................     
.................... } 
59D2:  MOVLB  0
59D4:  GOTO   5F44 (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr            0 
.................... #define strobe_ptrcard_addr         25     // 4 bytes 
.................... #define strobe_ptrcard_key          30     // 4 bytes 
.................... #define strobe_count_card           36     // 2 bytes 
.................... #define strobe_nameconsole          40     // 16 bytes  
.................... #define strobe_Master_SLV           58     // 1 byte 
.................... #define strobe_debugmode            59     // 1 byte 
.................... #define strobe_delaytime            60     // 1 byte 
.................... #define kindofKB                    61     // 1 byte 
.................... #define crypto_en                   62     // 1 byte 
.................... #define strobe_crypto_key           63     // 32 byte 
....................  
....................  
.................... #define wide_strobe_nameconsole     16  
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards               930   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... #if 0 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... } 
.................... #endif 
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4D90:  MOVLB  8
4D92:  CLRF   x4A
4D94:  CLRF   x49
4D96:  CLRF   x48
4D98:  CLRF   x47
4D9A:  MOVF   x4A,W
4D9C:  SUBWF  x44,W
4D9E:  BNC   4E18
4DA0:  BNZ   4DB8
4DA2:  MOVF   x49,W
4DA4:  SUBWF  x43,W
4DA6:  BNC   4E18
4DA8:  BNZ   4DB8
4DAA:  MOVF   x48,W
4DAC:  SUBWF  x42,W
4DAE:  BNC   4E18
4DB0:  BNZ   4DB8
4DB2:  MOVF   x41,W
4DB4:  SUBWF  x47,W
4DB6:  BC    4E18
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4DB8:  MOVF   x47,W
4DBA:  ADDWF  x3D,W
4DBC:  MOVWF  x4B
4DBE:  MOVF   x48,W
4DC0:  ADDWFC x3E,W
4DC2:  MOVWF  x4C
4DC4:  MOVF   x49,W
4DC6:  ADDWFC x3F,W
4DC8:  MOVWF  x4D
4DCA:  MOVF   x4A,W
4DCC:  ADDWFC x40,W
4DCE:  MOVWF  x4E
4DD0:  MOVF   x45,W
4DD2:  ADDWF  x47,W
4DD4:  MOVWF  FE9
4DD6:  MOVF   x46,W
4DD8:  ADDWFC x48,W
4DDA:  MOVWF  FEA
4DDC:  MOVFF  FEF,84F
4DE0:  MOVFF  84E,853
4DE4:  MOVFF  84D,852
4DE8:  MOVFF  84C,851
4DEC:  MOVFF  84B,850
4DF0:  MOVFF  84F,854
4DF4:  MOVLB  0
4DF6:  CALL   3934
....................       delay_us(10); 
4DFA:  MOVLW  1A
4DFC:  MOVWF  00
4DFE:  DECFSZ 00,F
4E00:  BRA    4DFE
4E02:  NOP   
....................    } 
4E04:  MOVLW  01
4E06:  MOVLB  8
4E08:  ADDWF  x47,F
4E0A:  BTFSC  FD8.0
4E0C:  INCF   x48,F
4E0E:  BTFSC  FD8.2
4E10:  INCF   x49,F
4E12:  BTFSC  FD8.2
4E14:  INCF   x4A,F
4E16:  BRA    4D9A
....................    return 1; 
4E18:  MOVLW  01
4E1A:  MOVWF  01
.................... } 
4E1C:  MOVLB  0
4E1E:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
546C:  MOVLB  7
546E:  CLRF   xFE
5470:  CLRF   xFD
5472:  CLRF   xFC
5474:  CLRF   xFB
5476:  MOVF   xFE,W
5478:  SUBWF  xF8,W
547A:  BNC   5518
547C:  BNZ   5494
547E:  MOVF   xFD,W
5480:  SUBWF  xF7,W
5482:  BNC   5518
5484:  BNZ   5494
5486:  MOVF   xFC,W
5488:  SUBWF  xF6,W
548A:  BNC   5518
548C:  BNZ   5494
548E:  MOVF   xF5,W
5490:  SUBWF  xFB,W
5492:  BC    5518
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
5494:  MOVF   xF9,W
5496:  ADDWF  xFB,W
5498:  MOVWF  01
549A:  MOVF   xFA,W
549C:  ADDWFC xFC,W
549E:  MOVWF  03
54A0:  MOVFF  01,7FF
54A4:  MOVFF  FE8,800
54A8:  MOVF   xFB,W
54AA:  ADDWF  xF1,W
54AC:  MOVLB  8
54AE:  MOVWF  x01
54B0:  MOVLB  7
54B2:  MOVF   xFC,W
54B4:  ADDWFC xF2,W
54B6:  MOVLB  8
54B8:  MOVWF  x02
54BA:  MOVLB  7
54BC:  MOVF   xFD,W
54BE:  ADDWFC xF3,W
54C0:  MOVLB  8
54C2:  MOVWF  x03
54C4:  MOVLB  7
54C6:  MOVF   xFE,W
54C8:  ADDWFC xF4,W
54CA:  MOVLB  8
54CC:  MOVWF  x04
54CE:  CLRF   19
54D0:  BTFSC  FF2.7
54D2:  BSF    19.7
54D4:  BCF    FF2.7
54D6:  MOVWF  x46
54D8:  MOVFF  803,845
54DC:  MOVFF  802,844
54E0:  MOVFF  801,843
54E4:  MOVLB  0
54E6:  CALL   3400
54EA:  BTFSC  19.7
54EC:  BSF    FF2.7
54EE:  MOVFF  800,FEA
54F2:  MOVFF  7FF,FE9
54F6:  MOVFF  01,FEF
....................       delay_us(10); 
54FA:  MOVLW  1A
54FC:  MOVWF  00
54FE:  DECFSZ 00,F
5500:  BRA    54FE
5502:  NOP   
....................    } 
5504:  MOVLW  01
5506:  MOVLB  7
5508:  ADDWF  xFB,F
550A:  BTFSC  FD8.0
550C:  INCF   xFC,F
550E:  BTFSC  FD8.2
5510:  INCF   xFD,F
5512:  BTFSC  FD8.2
5514:  INCF   xFE,F
5516:  BRA    5476
.................... } 
5518:  MOVLB  0
551A:  RETURN 0
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
55BC:  MOVLB  7
55BE:  CLRF   xBD
55C0:  CLRF   xBC
55C2:  CLRF   xBB
55C4:  CLRF   xBA
55C6:  CLRF   xC1
55C8:  CLRF   xC0
55CA:  CLRF   xBF
55CC:  CLRF   xBE
55CE:  CLRF   xC5
55D0:  CLRF   xC4
55D2:  CLRF   xC3
55D4:  CLRF   xC2
55D6:  CLRF   xC9
55D8:  CLRF   xC8
55DA:  CLRF   xC7
55DC:  CLRF   xC6
55DE:  CLRF   xCD
55E0:  CLRF   xCC
55E2:  CLRF   xCB
55E4:  CLRF   xCA
55E6:  CLRF   19
55E8:  BTFSC  FF2.7
55EA:  BSF    19.7
55EC:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
55EE:  MOVLB  8
55F0:  CLRF   x46
55F2:  CLRF   x45
55F4:  CLRF   x44
55F6:  MOVFF  7B9,843
55FA:  MOVLB  0
55FC:  CALL   3400
5600:  BTFSC  19.7
5602:  BSF    FF2.7
5604:  MOVLB  7
5606:  MOVFF  01,7BE
560A:  CLRF   xBF
560C:  CLRF   xC0
560E:  CLRF   xC1
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
5610:  MOVLW  01
5612:  ADDWF  xB9,W
5614:  MOVWF  xCE
5616:  CLRF   19
5618:  BTFSC  FF2.7
561A:  BSF    19.7
561C:  BCF    FF2.7
561E:  MOVLB  8
5620:  CLRF   x46
5622:  CLRF   x45
5624:  CLRF   x44
5626:  MOVWF  x43
5628:  MOVLB  0
562A:  CALL   3400
562E:  BTFSC  19.7
5630:  BSF    FF2.7
5632:  MOVLB  7
5634:  CLRF   xC5
5636:  CLRF   xC4
5638:  CLRF   xC3
563A:  MOVFF  01,7C2
....................    temp2<<=8; 
563E:  MOVFF  7C4,7C5
5642:  MOVFF  7C3,7C4
5646:  MOVFF  7C2,7C3
564A:  CLRF   xC2
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
564C:  MOVLW  02
564E:  ADDWF  xB9,W
5650:  MOVWF  xCE
5652:  CLRF   19
5654:  BTFSC  FF2.7
5656:  BSF    19.7
5658:  BCF    FF2.7
565A:  MOVLB  8
565C:  CLRF   x46
565E:  CLRF   x45
5660:  CLRF   x44
5662:  MOVWF  x43
5664:  MOVLB  0
5666:  CALL   3400
566A:  BTFSC  19.7
566C:  BSF    FF2.7
566E:  MOVLB  7
5670:  CLRF   xC9
5672:  CLRF   xC8
5674:  CLRF   xC7
5676:  MOVFF  01,7C6
....................    temp3<<=16; 
567A:  MOVFF  7C7,7C9
567E:  MOVFF  7C6,7C8
5682:  CLRF   xC6
5684:  CLRF   xC7
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
5686:  MOVLW  03
5688:  ADDWF  xB9,W
568A:  MOVWF  xCE
568C:  CLRF   19
568E:  BTFSC  FF2.7
5690:  BSF    19.7
5692:  BCF    FF2.7
5694:  MOVLB  8
5696:  CLRF   x46
5698:  CLRF   x45
569A:  CLRF   x44
569C:  MOVWF  x43
569E:  MOVLB  0
56A0:  CALL   3400
56A4:  BTFSC  19.7
56A6:  BSF    FF2.7
56A8:  MOVLB  7
56AA:  CLRF   xCD
56AC:  CLRF   xCC
56AE:  CLRF   xCB
56B0:  MOVFF  01,7CA
....................    temp4<<=24; 
56B4:  MOVFF  7CA,7CD
56B8:  CLRF   xCA
56BA:  CLRF   xCB
56BC:  CLRF   xCC
....................    buffer = temp4|temp3|temp2|temp1; 
56BE:  MOVF   xCA,W
56C0:  IORWF  xC6,W
56C2:  MOVWF  xCE
56C4:  MOVF   xCB,W
56C6:  IORWF  xC7,W
56C8:  MOVWF  xCF
56CA:  MOVF   xCC,W
56CC:  IORWF  xC8,W
56CE:  MOVWF  xD0
56D0:  MOVF   xCD,W
56D2:  IORWF  xC9,W
56D4:  MOVWF  xD1
56D6:  MOVF   xC2,W
56D8:  IORWF  xCE,F
56DA:  MOVF   xC3,W
56DC:  IORWF  xCF,F
56DE:  MOVF   xC4,W
56E0:  IORWF  xD0,F
56E2:  MOVF   xC5,W
56E4:  IORWF  xD1,F
56E6:  MOVF   xCE,W
56E8:  IORWF  xBE,W
56EA:  MOVWF  xBA
56EC:  MOVF   xCF,W
56EE:  IORWF  xBF,W
56F0:  MOVWF  xBB
56F2:  MOVF   xD0,W
56F4:  IORWF  xC0,W
56F6:  MOVWF  xBC
56F8:  MOVF   xD1,W
56FA:  IORWF  xC1,W
56FC:  MOVWF  xBD
....................    return(buffer); 
56FE:  MOVFF  7BA,00
5702:  MOVFF  7BB,01
5706:  MOVFF  7BC,02
570A:  MOVFF  7BD,03
.................... } 
570E:  MOVLB  0
5710:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3A32:  MOVLB  8
3A34:  CLRF   x45
3A36:  CLRF   x44
3A38:  CLRF   x43
3A3A:  CLRF   x42
3A3C:  CLRF   x46
3A3E:  CLRF   x47
3A40:  CLRF   x48
3A42:  CLRF   x49
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3A44:  MOVFF  840,845
3A48:  MOVFF  83F,844
3A4C:  MOVFF  83E,843
3A50:  MOVFF  83D,842
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3A54:  MOVFF  842,846
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3A58:  MOVFF  843,847
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3A5C:  MOVFF  844,848
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3A60:  MOVFF  845,849
....................    write_ext_eeprom((addr+0),temp1); 
3A64:  CLRF   x53
3A66:  CLRF   x52
3A68:  CLRF   x51
3A6A:  MOVFF  841,850
3A6E:  MOVFF  846,854
3A72:  MOVLB  0
3A74:  RCALL  3934
....................    write_ext_eeprom((addr+1),temp2); 
3A76:  MOVLW  01
3A78:  MOVLB  8
3A7A:  ADDWF  x41,W
3A7C:  MOVWF  x4A
3A7E:  CLRF   x53
3A80:  CLRF   x52
3A82:  CLRF   x51
3A84:  MOVWF  x50
3A86:  MOVFF  847,854
3A8A:  MOVLB  0
3A8C:  RCALL  3934
....................    write_ext_eeprom((addr+2),temp3); 
3A8E:  MOVLW  02
3A90:  MOVLB  8
3A92:  ADDWF  x41,W
3A94:  MOVWF  x4A
3A96:  CLRF   x53
3A98:  CLRF   x52
3A9A:  CLRF   x51
3A9C:  MOVWF  x50
3A9E:  MOVFF  848,854
3AA2:  MOVLB  0
3AA4:  RCALL  3934
....................    write_ext_eeprom((addr+3),temp4); 
3AA6:  MOVLW  03
3AA8:  MOVLB  8
3AAA:  ADDWF  x41,W
3AAC:  MOVWF  x4A
3AAE:  CLRF   x53
3AB0:  CLRF   x52
3AB2:  CLRF   x51
3AB4:  MOVWF  x50
3AB6:  MOVFF  849,854
3ABA:  MOVLB  0
3ABC:  RCALL  3934
.................... } 
3ABE:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
504E:  MOVLB  8
5050:  CLRF   x2C
5052:  CLRF   x2B
5054:  CLRF   x2D
5056:  CLRF   x2E
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
5058:  MOVFF  82A,82C
505C:  MOVFF  829,82B
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
5060:  MOVFF  82B,82D
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
5064:  MOVF   x2C,W
5066:  MOVWF  x2E
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
5068:  CLRF   x53
506A:  CLRF   x52
506C:  CLRF   x51
506E:  MOVLW  24
5070:  MOVWF  x50
5072:  MOVFF  82D,854
5076:  MOVLB  0
5078:  CALL   3934
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
507C:  MOVLB  8
507E:  CLRF   x53
5080:  CLRF   x52
5082:  CLRF   x51
5084:  MOVLW  25
5086:  MOVWF  x50
5088:  MOVFF  82E,854
508C:  MOVLB  0
508E:  CALL   3934
.................... } 
5092:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
34CC:  MOVLB  8
34CE:  CLRF   x3E
34D0:  CLRF   x3D
34D2:  CLRF   x40
34D4:  CLRF   x3F
34D6:  CLRF   x42
34D8:  CLRF   x41
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
34DA:  CLRF   x46
34DC:  CLRF   x45
34DE:  CLRF   x44
34E0:  MOVLW  24
34E2:  MOVWF  x43
34E4:  MOVLB  0
34E6:  RCALL  3400
34E8:  MOVLB  8
34EA:  MOVFF  01,83F
34EE:  CLRF   x40
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
34F0:  CLRF   x46
34F2:  CLRF   x45
34F4:  CLRF   x44
34F6:  MOVLW  25
34F8:  MOVWF  x43
34FA:  MOVLB  0
34FC:  RCALL  3400
34FE:  MOVLB  8
3500:  CLRF   x42
3502:  MOVFF  01,841
....................    temp2<<=8; 
3506:  MOVFF  841,842
350A:  CLRF   x41
....................    buffer = temp2|temp1; 
350C:  MOVF   x41,W
350E:  IORWF  x3F,W
3510:  MOVWF  x3D
3512:  MOVF   x42,W
3514:  IORWF  x40,W
3516:  MOVWF  x3E
....................    return(buffer); 
3518:  MOVFF  83D,01
351C:  MOVFF  83E,02
.................... } 
3520:  MOVLB  0
3522:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................    /*for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    }*/ 
....................    //fprintf(COM2," ptr_card=%lu\n\r",ptr_card); 
....................    /*for(i=ptr_start;i<ptr_card;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
*
5AF2:  CLRF   23
5AF4:  CLRF   22
5AF6:  CLRF   21
5AF8:  MOVLW  96
5AFA:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5AFC:  CLRF   27
5AFE:  MOVLW  01
5B00:  MOVWF  26
5B02:  MOVLW  C3
5B04:  MOVWF  25
5B06:  MOVLW  0F
5B08:  MOVWF  24
5B0A:  CLRF   19
5B0C:  BTFSC  FF2.7
5B0E:  BSF    19.7
5B10:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5B12:  MOVFF  23,840
5B16:  MOVFF  22,83F
5B1A:  MOVFF  21,83E
5B1E:  MOVFF  20,83D
5B22:  MOVLW  19
5B24:  MOVLB  8
5B26:  MOVWF  x41
5B28:  MOVLB  0
5B2A:  CALL   3A32
5B2E:  BTFSC  19.7
5B30:  BSF    FF2.7
5B32:  CLRF   19
5B34:  BTFSC  FF2.7
5B36:  BSF    19.7
5B38:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5B3A:  MOVFF  27,840
5B3E:  MOVFF  26,83F
5B42:  MOVFF  25,83E
5B46:  MOVFF  24,83D
5B4A:  MOVLW  1E
5B4C:  MOVLB  8
5B4E:  MOVWF  x41
5B50:  MOVLB  0
5B52:  CALL   3A32
5B56:  BTFSC  19.7
5B58:  BSF    FF2.7
5B5A:  CLRF   19
5B5C:  BTFSC  FF2.7
5B5E:  BSF    19.7
5B60:  BCF    FF2.7
....................    save_coutcard(0); 
5B62:  MOVLB  8
5B64:  CLRF   x2A
5B66:  CLRF   x29
5B68:  MOVLB  0
5B6A:  CALL   504E
5B6E:  BTFSC  19.7
5B70:  BSF    FF2.7
5B72:  CLRF   19
5B74:  BTFSC  FF2.7
5B76:  BSF    19.7
5B78:  BCF    FF2.7
....................    countcard=get_countcard(); 
5B7A:  CALL   34CC
5B7E:  BTFSC  19.7
5B80:  BSF    FF2.7
5B82:  MOVFF  02,FA
5B86:  MOVFF  01,F9
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
5B8A:  GOTO   62EA (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    ptr_card=ptr_start; 
5B8E:  CLRF   23
5B90:  CLRF   22
5B92:  CLRF   21
5B94:  MOVLW  96
5B96:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5B98:  CLRF   27
5B9A:  MOVLW  01
5B9C:  MOVWF  26
5B9E:  MOVLW  C3
5BA0:  MOVWF  25
5BA2:  MOVLW  0F
5BA4:  MOVWF  24
5BA6:  CLRF   19
5BA8:  BTFSC  FF2.7
5BAA:  BSF    19.7
5BAC:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5BAE:  MOVFF  23,840
5BB2:  MOVFF  22,83F
5BB6:  MOVFF  21,83E
5BBA:  MOVFF  20,83D
5BBE:  MOVLW  19
5BC0:  MOVLB  8
5BC2:  MOVWF  x41
5BC4:  MOVLB  0
5BC6:  CALL   3A32
5BCA:  BTFSC  19.7
5BCC:  BSF    FF2.7
5BCE:  CLRF   19
5BD0:  BTFSC  FF2.7
5BD2:  BSF    19.7
5BD4:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5BD6:  MOVFF  27,840
5BDA:  MOVFF  26,83F
5BDE:  MOVFF  25,83E
5BE2:  MOVFF  24,83D
5BE6:  MOVLW  1E
5BE8:  MOVLB  8
5BEA:  MOVWF  x41
5BEC:  MOVLB  0
5BEE:  CALL   3A32
5BF2:  BTFSC  19.7
5BF4:  BSF    FF2.7
5BF6:  CLRF   19
5BF8:  BTFSC  FF2.7
5BFA:  BSF    19.7
5BFC:  BCF    FF2.7
....................    save_coutcard(0); 
5BFE:  MOVLB  8
5C00:  CLRF   x2A
5C02:  CLRF   x29
5C04:  MOVLB  0
5C06:  CALL   504E
5C0A:  BTFSC  19.7
5C0C:  BSF    FF2.7
.................... } 
5C0E:  GOTO   634E (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
551C:  MOVLB  7
551E:  CLRF   xF4
5520:  CLRF   xF3
5522:  CLRF   xF2
5524:  CLRF   xF1
5526:  CLRF   xF8
5528:  CLRF   xF7
552A:  CLRF   xF6
552C:  MOVLW  14
552E:  MOVWF  xF5
5530:  CLRF   xFA
5532:  MOVLW  55
5534:  MOVWF  xF9
5536:  MOVLB  0
5538:  RCALL  546C
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
553A:  INCFSZ 55,W
553C:  BRA    55BA
553E:  INCFSZ 56,W
5540:  BRA    55BA
5542:  INCFSZ x64,W
5544:  BRA    55BA
....................       { 
....................          memset(buffer1,0,20); 
5546:  CLRF   FEA
5548:  MOVLW  2D
554A:  MOVWF  FE9
554C:  CLRF   00
554E:  CLRF   02
5550:  MOVLW  14
5552:  MOVWF  01
5554:  CALL   3546
....................          strcpy(buffer1,"admin"); 
5558:  CLRF   FEA
555A:  MOVLW  2D
555C:  MOVWF  FE9
555E:  MOVLW  00
5560:  CALL   00BA
5564:  TBLRD*-
5566:  TBLRD*+
5568:  MOVF   FF5,W
556A:  MOVWF  FEE
556C:  IORLW  00
556E:  BNZ   5566
5570:  CLRF   19
5572:  BTFSC  FF2.7
5574:  BSF    19.7
5576:  BCF    FF2.7
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
5578:  MOVLB  8
557A:  CLRF   x40
557C:  CLRF   x3F
557E:  CLRF   x3E
5580:  CLRF   x3D
5582:  CLRF   x44
5584:  CLRF   x43
5586:  CLRF   x42
5588:  MOVLW  14
558A:  MOVWF  x41
558C:  CLRF   x46
558E:  MOVLW  2D
5590:  MOVWF  x45
5592:  MOVLB  0
5594:  CALL   4D90
5598:  BTFSC  19.7
559A:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
559C:  MOVLB  7
559E:  CLRF   xF4
55A0:  CLRF   xF3
55A2:  CLRF   xF2
55A4:  CLRF   xF1
55A6:  CLRF   xF8
55A8:  CLRF   xF7
55AA:  CLRF   xF6
55AC:  MOVLW  14
55AE:  MOVWF  xF5
55B0:  CLRF   xFA
55B2:  MOVLW  55
55B4:  MOVWF  xF9
55B6:  MOVLB  0
55B8:  RCALL  546C
....................       } 
.................... } 
55BA:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
5C12:  MOVLB  8
5C14:  CLRF   x05
5C16:  MOVF   x05,W
5C18:  SUBLW  13
5C1A:  BNC   5C30
5C1C:  CLRF   03
5C1E:  MOVF   x05,W
5C20:  ADDLW  F1
5C22:  MOVWF  FE9
5C24:  MOVLW  07
5C26:  ADDWFC 03,W
5C28:  MOVWF  FEA
5C2A:  SETF   FEF
5C2C:  INCF   x05,F
5C2E:  BRA    5C16
5C30:  CLRF   19
5C32:  BTFSC  FF2.7
5C34:  BSF    19.7
5C36:  BCF    FF2.7
....................    EEPROM_write(strobe_pass_addr,20,buf); 
5C38:  CLRF   x40
5C3A:  CLRF   x3F
5C3C:  CLRF   x3E
5C3E:  CLRF   x3D
5C40:  CLRF   x44
5C42:  CLRF   x43
5C44:  CLRF   x42
5C46:  MOVLW  14
5C48:  MOVWF  x41
5C4A:  MOVLW  07
5C4C:  MOVWF  x46
5C4E:  MOVLW  F1
5C50:  MOVWF  x45
5C52:  MOVLB  0
5C54:  CALL   4D90
5C58:  BTFSC  19.7
5C5A:  BSF    FF2.7
.................... } 
5C5C:  GOTO   63B2 (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
....................  
.................... #define CRYPTO_KEY_SIZE   32 
....................  
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 cryption_enable=0; 
....................  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int16 galois_mul2(unsigned int16 value) 
.................... { 
....................   signed int16 temp; 
....................   // cast to signed value 
....................   temp = (signed char) value; 
*
406E:  CLRF   03
4070:  MOVLB  8
4072:  MOVF   x4A,W
4074:  BTFSC  FE8.7
4076:  DECF   03,F
4078:  MOVWF  x4C
407A:  MOVFF  03,84D
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
407E:  RRCF   x4D,W
4080:  MOVWF  03
4082:  RRCF   x4C,W
4084:  MOVWF  02
4086:  RRCF   03,F
4088:  RRCF   02,F
408A:  RRCF   03,F
408C:  RRCF   02,F
408E:  RRCF   03,F
4090:  RRCF   02,F
4092:  RRCF   03,F
4094:  RRCF   02,F
4096:  RRCF   03,F
4098:  RRCF   02,F
409A:  RRCF   03,F
409C:  RRCF   02,F
409E:  MOVLW  01
40A0:  ANDWF  03,F
40A2:  MOVFF  02,84C
40A6:  MOVFF  03,84D
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
40AA:  MOVLW  1B
40AC:  ANDWF  x4C,F
40AE:  CLRF   x4D
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
40B0:  BCF    FD8.0
40B2:  RLCF   x4A,W
40B4:  MOVWF  x4E
40B6:  RLCF   x4B,W
40B8:  MOVWF  x4F
40BA:  MOVF   x4E,W
40BC:  XORWF  x4C,W
40BE:  MOVWF  00
40C0:  MOVF   x4F,W
40C2:  XORWF  x4D,W
40C4:  MOVWF  03
40C6:  MOVFF  00,01
40CA:  MOVWF  02
.................... } 
40CC:  MOVLB  0
40CE:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................     unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................  
....................   // In case of decryption 
....................   if (dir != 0)  
40D0:  MOVLB  8
40D2:  MOVF   x41,F
40D4:  BTFSC  FD8.2
40D6:  BRA    42A2
....................   { 
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
40D8:  CLRF   x46
40DA:  MOVF   x46,W
40DC:  SUBLW  09
40DE:  BTFSS  FD8.0
40E0:  BRA    4258
....................       //key schedule 
....................       key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[round]); 
40E2:  MOVFF  83F,01
40E6:  MOVFF  840,03
40EA:  MOVFF  83F,848
40EE:  MOVFF  840,849
40F2:  MOVLW  0D
40F4:  ADDWF  x3F,W
40F6:  MOVWF  FE9
40F8:  MOVLW  00
40FA:  ADDWFC x40,W
40FC:  MOVWF  FEA
40FE:  CLRF   03
4100:  MOVF   FEF,W
4102:  MOVLB  0
4104:  CALL   00D0
4108:  MOVLB  8
410A:  MOVWF  x4A
410C:  MOVFF  83F,FE9
4110:  MOVFF  840,FEA
4114:  MOVF   FEF,W
4116:  XORWF  x4A,F
4118:  CLRF   03
411A:  MOVF   x46,W
411C:  MOVLB  0
411E:  CALL   02F0
4122:  MOVWF  01
4124:  MOVLB  8
4126:  MOVF   x4A,W
4128:  XORWF  01,W
412A:  MOVFF  849,FEA
412E:  MOVFF  848,FE9
4132:  MOVWF  FEF
....................       key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4134:  MOVLW  01
4136:  ADDWF  x3F,W
4138:  MOVWF  01
413A:  MOVLW  00
413C:  ADDWFC x40,W
413E:  MOVWF  03
4140:  MOVFF  01,848
4144:  MOVWF  x49
4146:  MOVLW  0E
4148:  ADDWF  x3F,W
414A:  MOVWF  FE9
414C:  MOVLW  00
414E:  ADDWFC x40,W
4150:  MOVWF  FEA
4152:  CLRF   03
4154:  MOVF   FEF,W
4156:  MOVLB  0
4158:  CALL   00D0
415C:  MOVLB  8
415E:  MOVWF  x4A
4160:  MOVLW  01
4162:  ADDWF  x3F,W
4164:  MOVWF  FE9
4166:  MOVLW  00
4168:  ADDWFC x40,W
416A:  MOVWF  FEA
416C:  MOVF   FEF,W
416E:  XORWF  x4A,W
4170:  MOVFF  849,FEA
4174:  MOVFF  848,FE9
4178:  MOVWF  FEF
....................       key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
417A:  MOVLW  02
417C:  ADDWF  x3F,W
417E:  MOVWF  01
4180:  MOVLW  00
4182:  ADDWFC x40,W
4184:  MOVWF  03
4186:  MOVFF  01,848
418A:  MOVWF  x49
418C:  MOVLW  0F
418E:  ADDWF  x3F,W
4190:  MOVWF  FE9
4192:  MOVLW  00
4194:  ADDWFC x40,W
4196:  MOVWF  FEA
4198:  CLRF   03
419A:  MOVF   FEF,W
419C:  MOVLB  0
419E:  CALL   00D0
41A2:  MOVLB  8
41A4:  MOVWF  x4A
41A6:  MOVLW  02
41A8:  ADDWF  x3F,W
41AA:  MOVWF  FE9
41AC:  MOVLW  00
41AE:  ADDWFC x40,W
41B0:  MOVWF  FEA
41B2:  MOVF   FEF,W
41B4:  XORWF  x4A,W
41B6:  MOVFF  849,FEA
41BA:  MOVFF  848,FE9
41BE:  MOVWF  FEF
....................       key[3] = (unsigned int8)(sbox[key[12]]^key[3]); 
41C0:  MOVLW  03
41C2:  ADDWF  x3F,W
41C4:  MOVWF  01
41C6:  MOVLW  00
41C8:  ADDWFC x40,W
41CA:  MOVWF  03
41CC:  MOVFF  01,848
41D0:  MOVWF  x49
41D2:  MOVLW  0C
41D4:  ADDWF  x3F,W
41D6:  MOVWF  FE9
41D8:  MOVLW  00
41DA:  ADDWFC x40,W
41DC:  MOVWF  FEA
41DE:  CLRF   03
41E0:  MOVF   FEF,W
41E2:  MOVLB  0
41E4:  CALL   00D0
41E8:  MOVLB  8
41EA:  MOVWF  x4A
41EC:  MOVLW  03
41EE:  ADDWF  x3F,W
41F0:  MOVWF  FE9
41F2:  MOVLW  00
41F4:  ADDWFC x40,W
41F6:  MOVWF  FEA
41F8:  MOVF   FEF,W
41FA:  XORWF  x4A,W
41FC:  MOVFF  849,FEA
4200:  MOVFF  848,FE9
4204:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4206:  MOVLW  04
4208:  MOVWF  x47
420A:  MOVF   x47,W
420C:  SUBLW  0F
420E:  BNC   4254
....................         key[i] = key[i] ^ key[i-4]; 
4210:  CLRF   03
4212:  MOVF   x47,W
4214:  ADDWF  x3F,W
4216:  MOVWF  01
4218:  MOVF   x40,W
421A:  ADDWFC 03,F
421C:  MOVFF  03,849
4220:  CLRF   03
4222:  MOVF   x47,W
4224:  ADDWF  x3F,W
4226:  MOVWF  FE9
4228:  MOVF   x40,W
422A:  ADDWFC 03,W
422C:  MOVWF  FEA
422E:  MOVFF  FEF,84A
4232:  MOVLW  04
4234:  SUBWF  x47,W
4236:  CLRF   03
4238:  ADDWF  x3F,W
423A:  MOVWF  FE9
423C:  MOVF   x40,W
423E:  ADDWFC 03,W
4240:  MOVWF  FEA
4242:  MOVF   FEF,W
4244:  XORWF  x4A,W
4246:  MOVFF  849,FEA
424A:  MOVFF  01,FE9
424E:  MOVWF  FEF
....................       } 
4250:  INCF   x47,F
4252:  BRA    420A
....................     } 
4254:  INCF   x46,F
4256:  BRA    40DA
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++) 
4258:  CLRF   x47
425A:  MOVF   x47,W
425C:  SUBLW  0F
425E:  BNC   42A2
....................     { 
....................       state[i]=state[i] ^ key[i]; 
4260:  CLRF   03
4262:  MOVF   x47,W
4264:  ADDWF  x3D,W
4266:  MOVWF  01
4268:  MOVF   x3E,W
426A:  ADDWFC 03,F
426C:  MOVFF  03,849
4270:  CLRF   03
4272:  MOVF   x47,W
4274:  ADDWF  x3D,W
4276:  MOVWF  FE9
4278:  MOVF   x3E,W
427A:  ADDWFC 03,W
427C:  MOVWF  FEA
427E:  MOVFF  FEF,84A
4282:  CLRF   03
4284:  MOVF   x47,W
4286:  ADDWF  x3F,W
4288:  MOVWF  FE9
428A:  MOVF   x40,W
428C:  ADDWFC 03,W
428E:  MOVWF  FEA
4290:  MOVF   FEF,W
4292:  XORWF  x4A,W
4294:  MOVFF  849,FEA
4298:  MOVFF  01,FE9
429C:  MOVWF  FEF
....................     } 
429E:  INCF   x47,F
42A0:  BRA    425A
....................   } 
....................   // main loop 
....................   for (round = 0; round < 10; round++) 
42A2:  CLRF   x46
42A4:  MOVF   x46,W
42A6:  SUBLW  09
42A8:  BTFSS  FD8.0
42AA:  GOTO   4CF2
....................   { 
....................     if (dir != 0) 
42AE:  MOVF   x41,F
42B0:  BTFSC  FD8.2
42B2:  BRA    442C
....................     { 
....................           //Inverse key schedule 
....................           for (i=15; i>3; --i)  
42B4:  MOVLW  0F
42B6:  MOVWF  x47
42B8:  MOVF   x47,W
42BA:  SUBLW  03
42BC:  BC    4302
....................           { 
....................             key[i] = key[i] ^ key[i-4]; 
42BE:  CLRF   03
42C0:  MOVF   x47,W
42C2:  ADDWF  x3F,W
42C4:  MOVWF  01
42C6:  MOVF   x40,W
42C8:  ADDWFC 03,F
42CA:  MOVFF  03,849
42CE:  CLRF   03
42D0:  MOVF   x47,W
42D2:  ADDWF  x3F,W
42D4:  MOVWF  FE9
42D6:  MOVF   x40,W
42D8:  ADDWFC 03,W
42DA:  MOVWF  FEA
42DC:  MOVFF  FEF,84A
42E0:  MOVLW  04
42E2:  SUBWF  x47,W
42E4:  CLRF   03
42E6:  ADDWF  x3F,W
42E8:  MOVWF  FE9
42EA:  MOVF   x40,W
42EC:  ADDWFC 03,W
42EE:  MOVWF  FEA
42F0:  MOVF   FEF,W
42F2:  XORWF  x4A,W
42F4:  MOVFF  849,FEA
42F8:  MOVFF  01,FE9
42FC:  MOVWF  FEF
....................           }   
42FE:  DECF   x47,F
4300:  BRA    42B8
....................           key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[9-round]); 
4302:  MOVFF  83F,01
4306:  MOVFF  840,03
430A:  MOVFF  83F,848
430E:  MOVFF  840,849
4312:  MOVLW  0D
4314:  ADDWF  x3F,W
4316:  MOVWF  FE9
4318:  MOVLW  00
431A:  ADDWFC x40,W
431C:  MOVWF  FEA
431E:  CLRF   03
4320:  MOVF   FEF,W
4322:  MOVLB  0
4324:  CALL   00D0
4328:  MOVLB  8
432A:  MOVWF  x4A
432C:  MOVFF  83F,FE9
4330:  MOVFF  840,FEA
4334:  MOVF   FEF,W
4336:  XORWF  x4A,F
4338:  MOVLW  09
433A:  BSF    FD8.0
433C:  SUBFWB x46,W
433E:  CLRF   03
4340:  MOVLB  0
4342:  CALL   02F0
4346:  MOVWF  01
4348:  MOVLB  8
434A:  MOVF   x4A,W
434C:  XORWF  01,W
434E:  MOVFF  849,FEA
4352:  MOVFF  848,FE9
4356:  MOVWF  FEF
....................           key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4358:  MOVLW  01
435A:  ADDWF  x3F,W
435C:  MOVWF  01
435E:  MOVLW  00
4360:  ADDWFC x40,W
4362:  MOVWF  03
4364:  MOVFF  01,848
4368:  MOVWF  x49
436A:  MOVLW  0E
436C:  ADDWF  x3F,W
436E:  MOVWF  FE9
4370:  MOVLW  00
4372:  ADDWFC x40,W
4374:  MOVWF  FEA
4376:  CLRF   03
4378:  MOVF   FEF,W
437A:  MOVLB  0
437C:  CALL   00D0
4380:  MOVLB  8
4382:  MOVWF  x4A
4384:  MOVLW  01
4386:  ADDWF  x3F,W
4388:  MOVWF  FE9
438A:  MOVLW  00
438C:  ADDWFC x40,W
438E:  MOVWF  FEA
4390:  MOVF   FEF,W
4392:  XORWF  x4A,W
4394:  MOVFF  849,FEA
4398:  MOVFF  848,FE9
439C:  MOVWF  FEF
....................           key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
439E:  MOVLW  02
43A0:  ADDWF  x3F,W
43A2:  MOVWF  01
43A4:  MOVLW  00
43A6:  ADDWFC x40,W
43A8:  MOVWF  03
43AA:  MOVFF  01,848
43AE:  MOVWF  x49
43B0:  MOVLW  0F
43B2:  ADDWF  x3F,W
43B4:  MOVWF  FE9
43B6:  MOVLW  00
43B8:  ADDWFC x40,W
43BA:  MOVWF  FEA
43BC:  CLRF   03
43BE:  MOVF   FEF,W
43C0:  MOVLB  0
43C2:  CALL   00D0
43C6:  MOVLB  8
43C8:  MOVWF  x4A
43CA:  MOVLW  02
43CC:  ADDWF  x3F,W
43CE:  MOVWF  FE9
43D0:  MOVLW  00
43D2:  ADDWFC x40,W
43D4:  MOVWF  FEA
43D6:  MOVF   FEF,W
43D8:  XORWF  x4A,W
43DA:  MOVFF  849,FEA
43DE:  MOVFF  848,FE9
43E2:  MOVWF  FEF
....................           key[3] = (unsigned int8)(sbox[key[12]]^key[3]);  
43E4:  MOVLW  03
43E6:  ADDWF  x3F,W
43E8:  MOVWF  01
43EA:  MOVLW  00
43EC:  ADDWFC x40,W
43EE:  MOVWF  03
43F0:  MOVFF  01,848
43F4:  MOVWF  x49
43F6:  MOVLW  0C
43F8:  ADDWF  x3F,W
43FA:  MOVWF  FE9
43FC:  MOVLW  00
43FE:  ADDWFC x40,W
4400:  MOVWF  FEA
4402:  CLRF   03
4404:  MOVF   FEF,W
4406:  MOVLB  0
4408:  CALL   00D0
440C:  MOVLB  8
440E:  MOVWF  x4A
4410:  MOVLW  03
4412:  ADDWF  x3F,W
4414:  MOVWF  FE9
4416:  MOVLW  00
4418:  ADDWFC x40,W
441A:  MOVWF  FEA
441C:  MOVF   FEF,W
441E:  XORWF  x4A,W
4420:  MOVFF  849,FEA
4424:  MOVFF  848,FE9
4428:  MOVWF  FEF
....................     }  
....................     else  
442A:  BRA    4644
....................     { 
....................         for (i = 0; i <16; i++) 
442C:  CLRF   x47
442E:  MOVF   x47,W
4430:  SUBLW  0F
4432:  BNC   4484
....................         { 
....................             // with shiftrow i+5 mod 16 
....................             state[i]=sbox[state[i] ^ key[i]]; 
4434:  CLRF   03
4436:  MOVF   x47,W
4438:  ADDWF  x3D,W
443A:  MOVWF  01
443C:  MOVF   x3E,W
443E:  ADDWFC 03,F
4440:  MOVFF  01,848
4444:  MOVFF  03,849
4448:  CLRF   03
444A:  MOVF   x47,W
444C:  ADDWF  x3D,W
444E:  MOVWF  FE9
4450:  MOVF   x3E,W
4452:  ADDWFC 03,W
4454:  MOVWF  FEA
4456:  MOVFF  FEF,84A
445A:  CLRF   03
445C:  MOVF   x47,W
445E:  ADDWF  x3F,W
4460:  MOVWF  FE9
4462:  MOVF   x40,W
4464:  ADDWFC 03,W
4466:  MOVWF  FEA
4468:  MOVF   FEF,W
446A:  XORWF  x4A,W
446C:  CLRF   03
446E:  MOVLB  0
4470:  CALL   00D0
4474:  MOVFF  849,FEA
4478:  MOVFF  848,FE9
447C:  MOVWF  FEF
....................         } 
447E:  MOVLB  8
4480:  INCF   x47,F
4482:  BRA    442E
....................         //shift rows 
....................         buf1 = state[1]; 
4484:  MOVLW  01
4486:  ADDWF  x3D,W
4488:  MOVWF  FE9
448A:  MOVLW  00
448C:  ADDWFC x3E,W
448E:  MOVWF  FEA
4490:  MOVFF  FEF,842
....................         state[1] = state[5]; 
4494:  MOVLW  01
4496:  ADDWF  x3D,W
4498:  MOVWF  01
449A:  MOVLW  00
449C:  ADDWFC x3E,W
449E:  MOVWF  03
44A0:  MOVLW  05
44A2:  ADDWF  x3D,W
44A4:  MOVWF  FE9
44A6:  MOVLW  00
44A8:  ADDWFC x3E,W
44AA:  MOVWF  FEA
44AC:  MOVFF  FEF,84A
44B0:  MOVFF  03,FEA
44B4:  MOVFF  01,FE9
44B8:  MOVFF  84A,FEF
....................         state[5] = state[9]; 
44BC:  MOVLW  05
44BE:  ADDWF  x3D,W
44C0:  MOVWF  01
44C2:  MOVLW  00
44C4:  ADDWFC x3E,W
44C6:  MOVWF  03
44C8:  MOVLW  09
44CA:  ADDWF  x3D,W
44CC:  MOVWF  FE9
44CE:  MOVLW  00
44D0:  ADDWFC x3E,W
44D2:  MOVWF  FEA
44D4:  MOVFF  FEF,84A
44D8:  MOVFF  03,FEA
44DC:  MOVFF  01,FE9
44E0:  MOVFF  84A,FEF
....................         state[9] = state[13]; 
44E4:  MOVLW  09
44E6:  ADDWF  x3D,W
44E8:  MOVWF  01
44EA:  MOVLW  00
44EC:  ADDWFC x3E,W
44EE:  MOVWF  03
44F0:  MOVLW  0D
44F2:  ADDWF  x3D,W
44F4:  MOVWF  FE9
44F6:  MOVLW  00
44F8:  ADDWFC x3E,W
44FA:  MOVWF  FEA
44FC:  MOVFF  FEF,84A
4500:  MOVFF  03,FEA
4504:  MOVFF  01,FE9
4508:  MOVFF  84A,FEF
....................         state[13] = buf1; 
450C:  MOVLW  0D
450E:  ADDWF  x3D,W
4510:  MOVWF  FE9
4512:  MOVLW  00
4514:  ADDWFC x3E,W
4516:  MOVWF  FEA
4518:  MOVFF  842,FEF
....................      
....................         buf1 = state[2]; 
451C:  MOVLW  02
451E:  ADDWF  x3D,W
4520:  MOVWF  FE9
4522:  MOVLW  00
4524:  ADDWFC x3E,W
4526:  MOVWF  FEA
4528:  MOVFF  FEF,842
....................         buf2 = state[6]; 
452C:  MOVLW  06
452E:  ADDWF  x3D,W
4530:  MOVWF  FE9
4532:  MOVLW  00
4534:  ADDWFC x3E,W
4536:  MOVWF  FEA
4538:  MOVFF  FEF,843
....................         state[2] = state[10]; 
453C:  MOVLW  02
453E:  ADDWF  x3D,W
4540:  MOVWF  01
4542:  MOVLW  00
4544:  ADDWFC x3E,W
4546:  MOVWF  03
4548:  MOVLW  0A
454A:  ADDWF  x3D,W
454C:  MOVWF  FE9
454E:  MOVLW  00
4550:  ADDWFC x3E,W
4552:  MOVWF  FEA
4554:  MOVFF  FEF,84A
4558:  MOVFF  03,FEA
455C:  MOVFF  01,FE9
4560:  MOVFF  84A,FEF
....................         state[6] = state[14]; 
4564:  MOVLW  06
4566:  ADDWF  x3D,W
4568:  MOVWF  01
456A:  MOVLW  00
456C:  ADDWFC x3E,W
456E:  MOVWF  03
4570:  MOVLW  0E
4572:  ADDWF  x3D,W
4574:  MOVWF  FE9
4576:  MOVLW  00
4578:  ADDWFC x3E,W
457A:  MOVWF  FEA
457C:  MOVFF  FEF,84A
4580:  MOVFF  03,FEA
4584:  MOVFF  01,FE9
4588:  MOVFF  84A,FEF
....................         state[10] = buf1; 
458C:  MOVLW  0A
458E:  ADDWF  x3D,W
4590:  MOVWF  FE9
4592:  MOVLW  00
4594:  ADDWFC x3E,W
4596:  MOVWF  FEA
4598:  MOVFF  842,FEF
....................         state[14] = buf2; 
459C:  MOVLW  0E
459E:  ADDWF  x3D,W
45A0:  MOVWF  FE9
45A2:  MOVLW  00
45A4:  ADDWFC x3E,W
45A6:  MOVWF  FEA
45A8:  MOVFF  843,FEF
....................      
....................         buf1 = state[15]; 
45AC:  MOVLW  0F
45AE:  ADDWF  x3D,W
45B0:  MOVWF  FE9
45B2:  MOVLW  00
45B4:  ADDWFC x3E,W
45B6:  MOVWF  FEA
45B8:  MOVFF  FEF,842
....................         state[15] = state[11]; 
45BC:  MOVLW  0F
45BE:  ADDWF  x3D,W
45C0:  MOVWF  01
45C2:  MOVLW  00
45C4:  ADDWFC x3E,W
45C6:  MOVWF  03
45C8:  MOVLW  0B
45CA:  ADDWF  x3D,W
45CC:  MOVWF  FE9
45CE:  MOVLW  00
45D0:  ADDWFC x3E,W
45D2:  MOVWF  FEA
45D4:  MOVFF  FEF,84A
45D8:  MOVFF  03,FEA
45DC:  MOVFF  01,FE9
45E0:  MOVFF  84A,FEF
....................         state[11] = state[7]; 
45E4:  MOVLW  0B
45E6:  ADDWF  x3D,W
45E8:  MOVWF  01
45EA:  MOVLW  00
45EC:  ADDWFC x3E,W
45EE:  MOVWF  03
45F0:  MOVLW  07
45F2:  ADDWF  x3D,W
45F4:  MOVWF  FE9
45F6:  MOVLW  00
45F8:  ADDWFC x3E,W
45FA:  MOVWF  FEA
45FC:  MOVFF  FEF,84A
4600:  MOVFF  03,FEA
4604:  MOVFF  01,FE9
4608:  MOVFF  84A,FEF
....................         state[7] = state[3]; 
460C:  MOVLW  07
460E:  ADDWF  x3D,W
4610:  MOVWF  01
4612:  MOVLW  00
4614:  ADDWFC x3E,W
4616:  MOVWF  03
4618:  MOVLW  03
461A:  ADDWF  x3D,W
461C:  MOVWF  FE9
461E:  MOVLW  00
4620:  ADDWFC x3E,W
4622:  MOVWF  FEA
4624:  MOVFF  FEF,84A
4628:  MOVFF  03,FEA
462C:  MOVFF  01,FE9
4630:  MOVFF  84A,FEF
....................         state[3] = buf1; 
4634:  MOVLW  03
4636:  ADDWF  x3D,W
4638:  MOVWF  FE9
463A:  MOVLW  00
463C:  ADDWFC x3E,W
463E:  MOVWF  FEA
4640:  MOVFF  842,FEF
....................     } 
....................      
....................     //mixcol - inv mix 
....................     if (((round > 0) && (dir != 0)) || ((round < 9) && (dir == 0)))  
4644:  MOVF   x46,F
4646:  BZ    464C
4648:  MOVF   x41,F
464A:  BNZ   465A
464C:  MOVF   x46,W
464E:  SUBLW  08
4650:  BTFSS  FD8.0
4652:  BRA    495A
4654:  MOVF   x41,F
4656:  BTFSS  FD8.2
4658:  BRA    495A
....................     { 
....................           for (i=0; i <4; i++) 
465A:  CLRF   x47
465C:  MOVF   x47,W
465E:  SUBLW  03
4660:  BTFSS  FD8.0
4662:  BRA    495A
....................           { 
....................                 buf4 = (unsigned int8)(i << 2); 
4664:  RLCF   x47,W
4666:  MOVWF  x45
4668:  RLCF   x45,F
466A:  MOVLW  FC
466C:  ANDWF  x45,F
....................                 if (dir != 0) 
466E:  MOVF   x41,F
4670:  BZ    475A
....................                 { 
....................                       // precompute for decryption 
....................                       buf1 = galois_mul2(galois_mul2((unsigned int8)(state[buf4]^state[buf4+2]))); 
4672:  CLRF   03
4674:  MOVF   x45,W
4676:  ADDWF  x3D,W
4678:  MOVWF  FE9
467A:  MOVF   x3E,W
467C:  ADDWFC 03,W
467E:  MOVWF  FEA
4680:  MOVFF  FEF,848
4684:  MOVLW  02
4686:  ADDWF  x45,W
4688:  CLRF   03
468A:  ADDWF  x3D,W
468C:  MOVWF  FE9
468E:  MOVF   x3E,W
4690:  ADDWFC 03,W
4692:  MOVWF  FEA
4694:  MOVF   FEF,W
4696:  XORWF  x48,F
4698:  CLRF   x4B
469A:  MOVFF  848,84A
469E:  MOVLB  0
46A0:  RCALL  406E
46A2:  MOVFF  02,849
46A6:  MOVFF  01,848
46AA:  MOVFF  02,84B
46AE:  MOVFF  01,84A
46B2:  RCALL  406E
46B4:  MOVFF  01,842
....................                       buf2 = galois_mul2(galois_mul2((unsigned int8)(state[buf4+1]^state[buf4+3]))); 
46B8:  MOVLW  01
46BA:  MOVLB  8
46BC:  ADDWF  x45,W
46BE:  CLRF   03
46C0:  ADDWF  x3D,W
46C2:  MOVWF  FE9
46C4:  MOVF   x3E,W
46C6:  ADDWFC 03,W
46C8:  MOVWF  FEA
46CA:  MOVFF  FEF,848
46CE:  MOVLW  03
46D0:  ADDWF  x45,W
46D2:  CLRF   03
46D4:  ADDWF  x3D,W
46D6:  MOVWF  FE9
46D8:  MOVF   x3E,W
46DA:  ADDWFC 03,W
46DC:  MOVWF  FEA
46DE:  MOVF   FEF,W
46E0:  XORWF  x48,F
46E2:  CLRF   x4B
46E4:  MOVFF  848,84A
46E8:  MOVLB  0
46EA:  RCALL  406E
46EC:  MOVFF  02,849
46F0:  MOVFF  01,848
46F4:  MOVFF  02,84B
46F8:  MOVFF  01,84A
46FC:  RCALL  406E
46FE:  MOVFF  01,843
....................                       state[buf4] ^= buf1;  
4702:  CLRF   03
4704:  MOVLB  8
4706:  MOVF   x45,W
4708:  ADDWF  x3D,W
470A:  MOVWF  FE9
470C:  MOVF   x3E,W
470E:  ADDWFC 03,W
4710:  MOVWF  FEA
4712:  MOVF   FEF,W
4714:  XORWF  x42,W
4716:  MOVWF  FEF
....................                       state[buf4+1] ^= buf2;  
4718:  MOVLW  01
471A:  ADDWF  x45,W
471C:  CLRF   03
471E:  ADDWF  x3D,W
4720:  MOVWF  FE9
4722:  MOVF   x3E,W
4724:  ADDWFC 03,W
4726:  MOVWF  FEA
4728:  MOVF   FEF,W
472A:  XORWF  x43,W
472C:  MOVWF  FEF
....................                       state[buf4+2] ^= buf1;  
472E:  MOVLW  02
4730:  ADDWF  x45,W
4732:  CLRF   03
4734:  ADDWF  x3D,W
4736:  MOVWF  FE9
4738:  MOVF   x3E,W
473A:  ADDWFC 03,W
473C:  MOVWF  FEA
473E:  MOVF   FEF,W
4740:  XORWF  x42,W
4742:  MOVWF  FEF
....................                       state[buf4+3] ^= buf2;  
4744:  MOVLW  03
4746:  ADDWF  x45,W
4748:  CLRF   03
474A:  ADDWF  x3D,W
474C:  MOVWF  FE9
474E:  MOVF   x3E,W
4750:  ADDWFC 03,W
4752:  MOVWF  FEA
4754:  MOVF   FEF,W
4756:  XORWF  x43,W
4758:  MOVWF  FEF
....................                 } 
....................                 // in all cases 
....................                 buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
475A:  CLRF   03
475C:  MOVF   x45,W
475E:  ADDWF  x3D,W
4760:  MOVWF  FE9
4762:  MOVF   x3E,W
4764:  ADDWFC 03,W
4766:  MOVWF  FEA
4768:  MOVFF  FEF,848
476C:  MOVLW  01
476E:  ADDWF  x45,W
4770:  CLRF   03
4772:  ADDWF  x3D,W
4774:  MOVWF  FE9
4776:  MOVF   x3E,W
4778:  ADDWFC 03,W
477A:  MOVWF  FEA
477C:  MOVF   FEF,W
477E:  XORWF  x48,F
4780:  MOVLW  02
4782:  ADDWF  x45,W
4784:  CLRF   03
4786:  ADDWF  x3D,W
4788:  MOVWF  FE9
478A:  MOVF   x3E,W
478C:  ADDWFC 03,W
478E:  MOVWF  FEA
4790:  MOVF   FEF,W
4792:  XORWF  x48,F
4794:  MOVLW  03
4796:  ADDWF  x45,W
4798:  CLRF   03
479A:  ADDWF  x3D,W
479C:  MOVWF  FE9
479E:  MOVF   x3E,W
47A0:  ADDWFC 03,W
47A2:  MOVWF  FEA
47A4:  MOVF   FEF,W
47A6:  XORWF  x48,W
47A8:  MOVWF  x42
....................                 buf2 = state[buf4]; 
47AA:  CLRF   03
47AC:  MOVF   x45,W
47AE:  ADDWF  x3D,W
47B0:  MOVWF  FE9
47B2:  MOVF   x3E,W
47B4:  ADDWFC 03,W
47B6:  MOVWF  FEA
47B8:  MOVFF  FEF,843
....................                 buf3 = state[buf4]^state[buf4+1];  
47BC:  CLRF   03
47BE:  MOVF   x45,W
47C0:  ADDWF  x3D,W
47C2:  MOVWF  FE9
47C4:  MOVF   x3E,W
47C6:  ADDWFC 03,W
47C8:  MOVWF  FEA
47CA:  MOVFF  FEF,848
47CE:  MOVLW  01
47D0:  ADDWF  x45,W
47D2:  CLRF   03
47D4:  ADDWF  x3D,W
47D6:  MOVWF  FE9
47D8:  MOVF   x3E,W
47DA:  ADDWFC 03,W
47DC:  MOVWF  FEA
47DE:  MOVF   FEF,W
47E0:  XORWF  x48,W
47E2:  MOVWF  x44
....................                 buf3=galois_mul2(buf3);  
47E4:  CLRF   x4B
47E6:  MOVFF  844,84A
47EA:  MOVLB  0
47EC:  RCALL  406E
47EE:  MOVFF  01,844
....................                 state[buf4] = state[buf4] ^ buf3 ^ buf1; 
47F2:  CLRF   03
47F4:  MOVLB  8
47F6:  MOVF   x45,W
47F8:  ADDWF  x3D,W
47FA:  MOVWF  01
47FC:  MOVF   x3E,W
47FE:  ADDWFC 03,F
4800:  MOVFF  03,849
4804:  CLRF   03
4806:  MOVF   x45,W
4808:  ADDWF  x3D,W
480A:  MOVWF  FE9
480C:  MOVF   x3E,W
480E:  ADDWFC 03,W
4810:  MOVWF  FEA
4812:  MOVF   FEF,W
4814:  XORWF  x44,W
4816:  XORWF  x42,W
4818:  MOVFF  849,FEA
481C:  MOVFF  01,FE9
4820:  MOVWF  FEF
....................                 buf3 = state[buf4+1]^state[buf4+2];  
4822:  MOVLW  01
4824:  ADDWF  x45,W
4826:  CLRF   03
4828:  ADDWF  x3D,W
482A:  MOVWF  FE9
482C:  MOVF   x3E,W
482E:  ADDWFC 03,W
4830:  MOVWF  FEA
4832:  MOVFF  FEF,848
4836:  MOVLW  02
4838:  ADDWF  x45,W
483A:  CLRF   03
483C:  ADDWF  x3D,W
483E:  MOVWF  FE9
4840:  MOVF   x3E,W
4842:  ADDWFC 03,W
4844:  MOVWF  FEA
4846:  MOVF   FEF,W
4848:  XORWF  x48,W
484A:  MOVWF  x44
....................                 buf3=galois_mul2(buf3);  
484C:  CLRF   x4B
484E:  MOVFF  844,84A
4852:  MOVLB  0
4854:  RCALL  406E
4856:  MOVFF  01,844
....................                 state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
485A:  MOVLW  01
485C:  MOVLB  8
485E:  ADDWF  x45,W
4860:  CLRF   03
4862:  ADDWF  x3D,W
4864:  MOVWF  01
4866:  MOVF   x3E,W
4868:  ADDWFC 03,F
486A:  MOVFF  03,849
486E:  MOVLW  01
4870:  ADDWF  x45,W
4872:  CLRF   03
4874:  ADDWF  x3D,W
4876:  MOVWF  FE9
4878:  MOVF   x3E,W
487A:  ADDWFC 03,W
487C:  MOVWF  FEA
487E:  MOVF   FEF,W
4880:  XORWF  x44,W
4882:  XORWF  x42,W
4884:  MOVFF  849,FEA
4888:  MOVFF  01,FE9
488C:  MOVWF  FEF
....................                 buf3 = state[buf4+2]^state[buf4+3];  
488E:  MOVLW  02
4890:  ADDWF  x45,W
4892:  CLRF   03
4894:  ADDWF  x3D,W
4896:  MOVWF  FE9
4898:  MOVF   x3E,W
489A:  ADDWFC 03,W
489C:  MOVWF  FEA
489E:  MOVFF  FEF,848
48A2:  MOVLW  03
48A4:  ADDWF  x45,W
48A6:  CLRF   03
48A8:  ADDWF  x3D,W
48AA:  MOVWF  FE9
48AC:  MOVF   x3E,W
48AE:  ADDWFC 03,W
48B0:  MOVWF  FEA
48B2:  MOVF   FEF,W
48B4:  XORWF  x48,W
48B6:  MOVWF  x44
....................                 buf3=galois_mul2(buf3);  
48B8:  CLRF   x4B
48BA:  MOVFF  844,84A
48BE:  MOVLB  0
48C0:  CALL   406E
48C4:  MOVFF  01,844
....................                 state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
48C8:  MOVLW  02
48CA:  MOVLB  8
48CC:  ADDWF  x45,W
48CE:  CLRF   03
48D0:  ADDWF  x3D,W
48D2:  MOVWF  01
48D4:  MOVF   x3E,W
48D6:  ADDWFC 03,F
48D8:  MOVFF  03,849
48DC:  MOVLW  02
48DE:  ADDWF  x45,W
48E0:  CLRF   03
48E2:  ADDWF  x3D,W
48E4:  MOVWF  FE9
48E6:  MOVF   x3E,W
48E8:  ADDWFC 03,W
48EA:  MOVWF  FEA
48EC:  MOVF   FEF,W
48EE:  XORWF  x44,W
48F0:  XORWF  x42,W
48F2:  MOVFF  849,FEA
48F6:  MOVFF  01,FE9
48FA:  MOVWF  FEF
....................                 buf3 = state[buf4+3]^buf2;      
48FC:  MOVLW  03
48FE:  ADDWF  x45,W
4900:  CLRF   03
4902:  ADDWF  x3D,W
4904:  MOVWF  FE9
4906:  MOVF   x3E,W
4908:  ADDWFC 03,W
490A:  MOVWF  FEA
490C:  MOVF   FEF,W
490E:  XORWF  x43,W
4910:  MOVWF  x44
....................                 buf3=galois_mul2(buf3);  
4912:  CLRF   x4B
4914:  MOVFF  844,84A
4918:  MOVLB  0
491A:  CALL   406E
491E:  MOVFF  01,844
....................                 state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1;  
4922:  MOVLW  03
4924:  MOVLB  8
4926:  ADDWF  x45,W
4928:  CLRF   03
492A:  ADDWF  x3D,W
492C:  MOVWF  01
492E:  MOVF   x3E,W
4930:  ADDWFC 03,F
4932:  MOVFF  03,849
4936:  MOVLW  03
4938:  ADDWF  x45,W
493A:  CLRF   03
493C:  ADDWF  x3D,W
493E:  MOVWF  FE9
4940:  MOVF   x3E,W
4942:  ADDWFC 03,W
4944:  MOVWF  FEA
4946:  MOVF   FEF,W
4948:  XORWF  x44,W
494A:  XORWF  x42,W
494C:  MOVFF  849,FEA
4950:  MOVFF  01,FE9
4954:  MOVWF  FEF
....................           } 
4956:  INCF   x47,F
4958:  BRA    465C
....................     } 
....................      
....................     if (dir != 0)  
495A:  MOVF   x41,F
495C:  BTFSC  FD8.2
495E:  BRA    4B7A
....................     { 
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
4960:  MOVLW  0D
4962:  ADDWF  x3D,W
4964:  MOVWF  FE9
4966:  MOVLW  00
4968:  ADDWFC x3E,W
496A:  MOVWF  FEA
496C:  MOVFF  FEF,842
....................       state[13] = state[9]; 
4970:  MOVLW  0D
4972:  ADDWF  x3D,W
4974:  MOVWF  01
4976:  MOVLW  00
4978:  ADDWFC x3E,W
497A:  MOVWF  03
497C:  MOVLW  09
497E:  ADDWF  x3D,W
4980:  MOVWF  FE9
4982:  MOVLW  00
4984:  ADDWFC x3E,W
4986:  MOVWF  FEA
4988:  MOVFF  FEF,84A
498C:  MOVFF  03,FEA
4990:  MOVFF  01,FE9
4994:  MOVFF  84A,FEF
....................       state[9] = state[5]; 
4998:  MOVLW  09
499A:  ADDWF  x3D,W
499C:  MOVWF  01
499E:  MOVLW  00
49A0:  ADDWFC x3E,W
49A2:  MOVWF  03
49A4:  MOVLW  05
49A6:  ADDWF  x3D,W
49A8:  MOVWF  FE9
49AA:  MOVLW  00
49AC:  ADDWFC x3E,W
49AE:  MOVWF  FEA
49B0:  MOVFF  FEF,84A
49B4:  MOVFF  03,FEA
49B8:  MOVFF  01,FE9
49BC:  MOVFF  84A,FEF
....................       state[5] = state[1]; 
49C0:  MOVLW  05
49C2:  ADDWF  x3D,W
49C4:  MOVWF  01
49C6:  MOVLW  00
49C8:  ADDWFC x3E,W
49CA:  MOVWF  03
49CC:  MOVLW  01
49CE:  ADDWF  x3D,W
49D0:  MOVWF  FE9
49D2:  MOVLW  00
49D4:  ADDWFC x3E,W
49D6:  MOVWF  FEA
49D8:  MOVFF  FEF,84A
49DC:  MOVFF  03,FEA
49E0:  MOVFF  01,FE9
49E4:  MOVFF  84A,FEF
....................       state[1] = buf1; 
49E8:  MOVLW  01
49EA:  ADDWF  x3D,W
49EC:  MOVWF  FE9
49EE:  MOVLW  00
49F0:  ADDWFC x3E,W
49F2:  MOVWF  FEA
49F4:  MOVFF  842,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
49F8:  MOVLW  0A
49FA:  ADDWF  x3D,W
49FC:  MOVWF  FE9
49FE:  MOVLW  00
4A00:  ADDWFC x3E,W
4A02:  MOVWF  FEA
4A04:  MOVFF  FEF,842
....................       buf2 = state[14]; 
4A08:  MOVLW  0E
4A0A:  ADDWF  x3D,W
4A0C:  MOVWF  FE9
4A0E:  MOVLW  00
4A10:  ADDWFC x3E,W
4A12:  MOVWF  FEA
4A14:  MOVFF  FEF,843
....................       state[10] = state[2]; 
4A18:  MOVLW  0A
4A1A:  ADDWF  x3D,W
4A1C:  MOVWF  01
4A1E:  MOVLW  00
4A20:  ADDWFC x3E,W
4A22:  MOVWF  03
4A24:  MOVLW  02
4A26:  ADDWF  x3D,W
4A28:  MOVWF  FE9
4A2A:  MOVLW  00
4A2C:  ADDWFC x3E,W
4A2E:  MOVWF  FEA
4A30:  MOVFF  FEF,84A
4A34:  MOVFF  03,FEA
4A38:  MOVFF  01,FE9
4A3C:  MOVFF  84A,FEF
....................       state[14] = state[6]; 
4A40:  MOVLW  0E
4A42:  ADDWF  x3D,W
4A44:  MOVWF  01
4A46:  MOVLW  00
4A48:  ADDWFC x3E,W
4A4A:  MOVWF  03
4A4C:  MOVLW  06
4A4E:  ADDWF  x3D,W
4A50:  MOVWF  FE9
4A52:  MOVLW  00
4A54:  ADDWFC x3E,W
4A56:  MOVWF  FEA
4A58:  MOVFF  FEF,84A
4A5C:  MOVFF  03,FEA
4A60:  MOVFF  01,FE9
4A64:  MOVFF  84A,FEF
....................       state[2] = buf1; 
4A68:  MOVLW  02
4A6A:  ADDWF  x3D,W
4A6C:  MOVWF  FE9
4A6E:  MOVLW  00
4A70:  ADDWFC x3E,W
4A72:  MOVWF  FEA
4A74:  MOVFF  842,FEF
....................       state[6] = buf2; 
4A78:  MOVLW  06
4A7A:  ADDWF  x3D,W
4A7C:  MOVWF  FE9
4A7E:  MOVLW  00
4A80:  ADDWFC x3E,W
4A82:  MOVWF  FEA
4A84:  MOVFF  843,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
4A88:  MOVLW  03
4A8A:  ADDWF  x3D,W
4A8C:  MOVWF  FE9
4A8E:  MOVLW  00
4A90:  ADDWFC x3E,W
4A92:  MOVWF  FEA
4A94:  MOVFF  FEF,842
....................       state[3] = state[7]; 
4A98:  MOVLW  03
4A9A:  ADDWF  x3D,W
4A9C:  MOVWF  01
4A9E:  MOVLW  00
4AA0:  ADDWFC x3E,W
4AA2:  MOVWF  03
4AA4:  MOVLW  07
4AA6:  ADDWF  x3D,W
4AA8:  MOVWF  FE9
4AAA:  MOVLW  00
4AAC:  ADDWFC x3E,W
4AAE:  MOVWF  FEA
4AB0:  MOVFF  FEF,84A
4AB4:  MOVFF  03,FEA
4AB8:  MOVFF  01,FE9
4ABC:  MOVFF  84A,FEF
....................       state[7] = state[11]; 
4AC0:  MOVLW  07
4AC2:  ADDWF  x3D,W
4AC4:  MOVWF  01
4AC6:  MOVLW  00
4AC8:  ADDWFC x3E,W
4ACA:  MOVWF  03
4ACC:  MOVLW  0B
4ACE:  ADDWF  x3D,W
4AD0:  MOVWF  FE9
4AD2:  MOVLW  00
4AD4:  ADDWFC x3E,W
4AD6:  MOVWF  FEA
4AD8:  MOVFF  FEF,84A
4ADC:  MOVFF  03,FEA
4AE0:  MOVFF  01,FE9
4AE4:  MOVFF  84A,FEF
....................       state[11] = state[15]; 
4AE8:  MOVLW  0B
4AEA:  ADDWF  x3D,W
4AEC:  MOVWF  01
4AEE:  MOVLW  00
4AF0:  ADDWFC x3E,W
4AF2:  MOVWF  03
4AF4:  MOVLW  0F
4AF6:  ADDWF  x3D,W
4AF8:  MOVWF  FE9
4AFA:  MOVLW  00
4AFC:  ADDWFC x3E,W
4AFE:  MOVWF  FEA
4B00:  MOVFF  FEF,84A
4B04:  MOVFF  03,FEA
4B08:  MOVFF  01,FE9
4B0C:  MOVFF  84A,FEF
....................       state[15] = buf1;          
4B10:  MOVLW  0F
4B12:  ADDWF  x3D,W
4B14:  MOVWF  FE9
4B16:  MOVLW  00
4B18:  ADDWFC x3E,W
4B1A:  MOVWF  FEA
4B1C:  MOVFF  842,FEF
....................             
....................       for (i = 0; i <16; i++){ 
4B20:  CLRF   x47
4B22:  MOVF   x47,W
4B24:  SUBLW  0F
4B26:  BNC   4B78
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
4B28:  CLRF   03
4B2A:  MOVF   x47,W
4B2C:  ADDWF  x3D,W
4B2E:  MOVWF  01
4B30:  MOVF   x3E,W
4B32:  ADDWFC 03,F
4B34:  MOVFF  01,848
4B38:  MOVFF  03,849
4B3C:  CLRF   03
4B3E:  MOVF   x47,W
4B40:  ADDWF  x3D,W
4B42:  MOVWF  FE9
4B44:  MOVF   x3E,W
4B46:  ADDWFC 03,W
4B48:  MOVWF  FEA
4B4A:  CLRF   03
4B4C:  MOVF   FEF,W
4B4E:  MOVLB  0
4B50:  CALL   01E0
4B54:  MOVLB  8
4B56:  MOVWF  x4A
4B58:  CLRF   03
4B5A:  MOVF   x47,W
4B5C:  ADDWF  x3F,W
4B5E:  MOVWF  FE9
4B60:  MOVF   x40,W
4B62:  ADDWFC 03,W
4B64:  MOVWF  FEA
4B66:  MOVF   FEF,W
4B68:  XORWF  x4A,W
4B6A:  MOVFF  849,FEA
4B6E:  MOVFF  848,FE9
4B72:  MOVWF  FEF
....................       }  
4B74:  INCF   x47,F
4B76:  BRA    4B22
....................     }  
....................     else  
4B78:  BRA    4CEC
....................     { 
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
4B7A:  MOVFF  83F,01
4B7E:  MOVFF  840,03
4B82:  MOVFF  83F,848
4B86:  MOVFF  840,849
4B8A:  MOVLW  0D
4B8C:  ADDWF  x3F,W
4B8E:  MOVWF  FE9
4B90:  MOVLW  00
4B92:  ADDWFC x40,W
4B94:  MOVWF  FEA
4B96:  CLRF   03
4B98:  MOVF   FEF,W
4B9A:  MOVLB  0
4B9C:  CALL   00D0
4BA0:  MOVLB  8
4BA2:  MOVWF  x4A
4BA4:  MOVFF  83F,FE9
4BA8:  MOVFF  840,FEA
4BAC:  MOVF   FEF,W
4BAE:  XORWF  x4A,F
4BB0:  CLRF   03
4BB2:  MOVF   x46,W
4BB4:  MOVLB  0
4BB6:  CALL   02F0
4BBA:  MOVWF  01
4BBC:  MOVLB  8
4BBE:  MOVF   x4A,W
4BC0:  XORWF  01,W
4BC2:  MOVFF  849,FEA
4BC6:  MOVFF  848,FE9
4BCA:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
4BCC:  MOVLW  01
4BCE:  ADDWF  x3F,W
4BD0:  MOVWF  01
4BD2:  MOVLW  00
4BD4:  ADDWFC x40,W
4BD6:  MOVWF  03
4BD8:  MOVFF  01,848
4BDC:  MOVWF  x49
4BDE:  MOVLW  0E
4BE0:  ADDWF  x3F,W
4BE2:  MOVWF  FE9
4BE4:  MOVLW  00
4BE6:  ADDWFC x40,W
4BE8:  MOVWF  FEA
4BEA:  CLRF   03
4BEC:  MOVF   FEF,W
4BEE:  MOVLB  0
4BF0:  CALL   00D0
4BF4:  MOVLB  8
4BF6:  MOVWF  x4A
4BF8:  MOVLW  01
4BFA:  ADDWF  x3F,W
4BFC:  MOVWF  FE9
4BFE:  MOVLW  00
4C00:  ADDWFC x40,W
4C02:  MOVWF  FEA
4C04:  MOVF   FEF,W
4C06:  XORWF  x4A,W
4C08:  MOVFF  849,FEA
4C0C:  MOVFF  848,FE9
4C10:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
4C12:  MOVLW  02
4C14:  ADDWF  x3F,W
4C16:  MOVWF  01
4C18:  MOVLW  00
4C1A:  ADDWFC x40,W
4C1C:  MOVWF  03
4C1E:  MOVFF  01,848
4C22:  MOVWF  x49
4C24:  MOVLW  0F
4C26:  ADDWF  x3F,W
4C28:  MOVWF  FE9
4C2A:  MOVLW  00
4C2C:  ADDWFC x40,W
4C2E:  MOVWF  FEA
4C30:  CLRF   03
4C32:  MOVF   FEF,W
4C34:  MOVLB  0
4C36:  CALL   00D0
4C3A:  MOVLB  8
4C3C:  MOVWF  x4A
4C3E:  MOVLW  02
4C40:  ADDWF  x3F,W
4C42:  MOVWF  FE9
4C44:  MOVLW  00
4C46:  ADDWFC x40,W
4C48:  MOVWF  FEA
4C4A:  MOVF   FEF,W
4C4C:  XORWF  x4A,W
4C4E:  MOVFF  849,FEA
4C52:  MOVFF  848,FE9
4C56:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
4C58:  MOVLW  03
4C5A:  ADDWF  x3F,W
4C5C:  MOVWF  01
4C5E:  MOVLW  00
4C60:  ADDWFC x40,W
4C62:  MOVWF  03
4C64:  MOVFF  01,848
4C68:  MOVWF  x49
4C6A:  MOVLW  0C
4C6C:  ADDWF  x3F,W
4C6E:  MOVWF  FE9
4C70:  MOVLW  00
4C72:  ADDWFC x40,W
4C74:  MOVWF  FEA
4C76:  CLRF   03
4C78:  MOVF   FEF,W
4C7A:  MOVLB  0
4C7C:  CALL   00D0
4C80:  MOVLB  8
4C82:  MOVWF  x4A
4C84:  MOVLW  03
4C86:  ADDWF  x3F,W
4C88:  MOVWF  FE9
4C8A:  MOVLW  00
4C8C:  ADDWFC x40,W
4C8E:  MOVWF  FEA
4C90:  MOVF   FEF,W
4C92:  XORWF  x4A,W
4C94:  MOVFF  849,FEA
4C98:  MOVFF  848,FE9
4C9C:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4C9E:  MOVLW  04
4CA0:  MOVWF  x47
4CA2:  MOVF   x47,W
4CA4:  SUBLW  0F
4CA6:  BNC   4CEC
....................         key[i] = key[i] ^ key[i-4]; 
4CA8:  CLRF   03
4CAA:  MOVF   x47,W
4CAC:  ADDWF  x3F,W
4CAE:  MOVWF  01
4CB0:  MOVF   x40,W
4CB2:  ADDWFC 03,F
4CB4:  MOVFF  03,849
4CB8:  CLRF   03
4CBA:  MOVF   x47,W
4CBC:  ADDWF  x3F,W
4CBE:  MOVWF  FE9
4CC0:  MOVF   x40,W
4CC2:  ADDWFC 03,W
4CC4:  MOVWF  FEA
4CC6:  MOVFF  FEF,84A
4CCA:  MOVLW  04
4CCC:  SUBWF  x47,W
4CCE:  CLRF   03
4CD0:  ADDWF  x3F,W
4CD2:  MOVWF  FE9
4CD4:  MOVF   x40,W
4CD6:  ADDWFC 03,W
4CD8:  MOVWF  FEA
4CDA:  MOVF   FEF,W
4CDC:  XORWF  x4A,W
4CDE:  MOVFF  849,FEA
4CE2:  MOVFF  01,FE9
4CE6:  MOVWF  FEF
....................       } 
4CE8:  INCF   x47,F
4CEA:  BRA    4CA2
....................     } 
....................   } 
4CEC:  INCF   x46,F
4CEE:  GOTO   42A4
....................   if (dir == 0)  
4CF2:  MOVF   x41,F
4CF4:  BNZ   4D40
....................   { 
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
4CF6:  CLRF   x47
4CF8:  MOVF   x47,W
4CFA:  SUBLW  0F
4CFC:  BNC   4D40
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
4CFE:  CLRF   03
4D00:  MOVF   x47,W
4D02:  ADDWF  x3D,W
4D04:  MOVWF  01
4D06:  MOVF   x3E,W
4D08:  ADDWFC 03,F
4D0A:  MOVFF  03,849
4D0E:  CLRF   03
4D10:  MOVF   x47,W
4D12:  ADDWF  x3D,W
4D14:  MOVWF  FE9
4D16:  MOVF   x3E,W
4D18:  ADDWFC 03,W
4D1A:  MOVWF  FEA
4D1C:  MOVFF  FEF,84A
4D20:  CLRF   03
4D22:  MOVF   x47,W
4D24:  ADDWF  x3F,W
4D26:  MOVWF  FE9
4D28:  MOVF   x40,W
4D2A:  ADDWFC 03,W
4D2C:  MOVWF  FEA
4D2E:  MOVF   FEF,W
4D30:  XORWF  x4A,W
4D32:  MOVFF  849,FEA
4D36:  MOVFF  01,FE9
4D3A:  MOVWF  FEF
....................     } // enf for 
4D3C:  INCF   x47,F
4D3E:  BRA    4CF8
....................   } // end if (!dir) 
.................... } // end function 
4D40:  MOVLB  0
4D42:  GOTO   4EC8 (RETURN)
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                  
....................  
.................... #define     wideofkeystore      16 
.................... #define     key_numbyte         wideofkeystore-4 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 kp_st=0; 
.................... int8 type_KB=0; 
....................  
.................... int8 key_data[wideofkeystore]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1F36:  MOVLB  1
1F38:  INCF   x57,F
1F3A:  MOVF   x57,W
1F3C:  SUBLW  01
1F3E:  BTFSC  FD8.0
1F40:  BRA    20E4
....................        switch (col) { 
1F42:  MOVF   x5A,W
1F44:  ADDLW  FB
1F46:  BC    1FCA
1F48:  ADDLW  05
1F4A:  MOVLB  0
1F4C:  GOTO   20EE
....................          case 0   :  
....................                     output_low(COL0); 
1F50:  BCF    F92.5
1F52:  BCF    F89.5
....................                     output_high(COL1); 
1F54:  BCF    F92.3
1F56:  BSF    F89.3
....................                     output_high(COL2); 
1F58:  BCF    F92.2
1F5A:  BSF    F89.2
....................                     output_high(COL3); 
1F5C:  BCF    F92.1
1F5E:  BSF    F89.1
....................                     output_high(COL4); 
1F60:  BCF    F92.0
1F62:  BSF    F89.0
....................                     break; 
1F64:  MOVLB  1
1F66:  BRA    1FCA
....................          case 1   :  
....................                     output_low(COL1); 
1F68:  BCF    F92.3
1F6A:  BCF    F89.3
....................                     output_high(COL0); 
1F6C:  BCF    F92.5
1F6E:  BSF    F89.5
....................                     output_high(COL2); 
1F70:  BCF    F92.2
1F72:  BSF    F89.2
....................                     output_high(COL3); 
1F74:  BCF    F92.1
1F76:  BSF    F89.1
....................                     output_high(COL4); 
1F78:  BCF    F92.0
1F7A:  BSF    F89.0
....................                     break; 
1F7C:  MOVLB  1
1F7E:  BRA    1FCA
....................          case 2   :  
....................                     output_low(COL2); 
1F80:  BCF    F92.2
1F82:  BCF    F89.2
....................                     output_high(COL1); 
1F84:  BCF    F92.3
1F86:  BSF    F89.3
....................                     output_high(COL0); 
1F88:  BCF    F92.5
1F8A:  BSF    F89.5
....................                     output_high(COL3); 
1F8C:  BCF    F92.1
1F8E:  BSF    F89.1
....................                     output_high(COL4); 
1F90:  BCF    F92.0
1F92:  BSF    F89.0
....................                     break; 
1F94:  MOVLB  1
1F96:  BRA    1FCA
....................          case 3   :  
....................                     output_low(COL3); 
1F98:  BCF    F92.1
1F9A:  BCF    F89.1
....................                     output_high(COL1); 
1F9C:  BCF    F92.3
1F9E:  BSF    F89.3
....................                     output_high(COL2); 
1FA0:  BCF    F92.2
1FA2:  BSF    F89.2
....................                     output_high(COL0); 
1FA4:  BCF    F92.5
1FA6:  BSF    F89.5
....................                     output_high(COL4); 
1FA8:  BCF    F92.0
1FAA:  BSF    F89.0
....................                     break; 
1FAC:  MOVLB  1
1FAE:  BRA    1FCA
....................          case 4   :  
....................                     output_low(COL4); 
1FB0:  BCF    F92.0
1FB2:  BCF    F89.0
....................                     output_high(COL1); 
1FB4:  BCF    F92.3
1FB6:  BSF    F89.3
....................                     output_high(COL2); 
1FB8:  BCF    F92.2
1FBA:  BSF    F89.2
....................                     output_high(COL3); 
1FBC:  BCF    F92.1
1FBE:  BSF    F89.1
....................                     output_high(COL0); 
1FC0:  BCF    F92.5
1FC2:  BSF    F89.5
....................                     break; 
1FC4:  MOVLB  1
1FC6:  BRA    1FCA
1FC8:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
1FCA:  BTFSS  x58.0
1FCC:  BRA    204A
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
1FCE:  BSF    F93.4
1FD0:  MOVLW  00
1FD2:  BTFSC  F81.4
1FD4:  MOVLW  01
1FD6:  MOVLB  8
1FD8:  MOVWF  x2B
1FDA:  BSF    F93.5
1FDC:  MOVLW  00
1FDE:  BTFSC  F81.5
1FE0:  MOVLW  01
1FE2:  ANDWF  x2B,F
1FE4:  BSF    F93.6
1FE6:  MOVLW  00
1FE8:  BTFSC  F81.6
1FEA:  MOVLW  01
1FEC:  ANDWF  x2B,F
1FEE:  BSF    F93.7
1FF0:  MOVLW  00
1FF2:  BTFSC  F81.7
1FF4:  MOVLW  01
1FF6:  ANDWF  x2B,W
1FF8:  BZ    2046
....................          { 
....................             kchar=last_key; 
1FFA:  MOVFF  159,829
....................             if(keydebug_en==0) 
1FFE:  MOVLB  1
2000:  MOVF   x40,F
2002:  BNZ   2034
....................             { 
....................                 //count_timer0=0; 
....................                 charac_timeout=0; 
2004:  MOVLB  0
2006:  CLRF   xFC
2008:  CLRF   xFB
....................                 if(key_count_ms<wideofkeystore) 
200A:  MOVLB  1
200C:  MOVF   x43,W
200E:  SUBLW  0F
2010:  BNC   2032
....................                 { 
....................                     key_data[key_count_ms++]=kchar; 
2012:  MOVF   x43,W
2014:  INCF   x43,F
2016:  CLRF   03
2018:  ADDLW  46
201A:  MOVWF  FE9
201C:  MOVLW  01
201E:  ADDWFC 03,W
2020:  MOVWF  FEA
2022:  MOVFF  829,FEF
....................                     fputc(kchar,COM2); 
2026:  MOVFF  829,852
202A:  MOVLB  0
202C:  CALL   15C0
2030:  MOVLB  1
....................                 } 
....................             } 
....................                else fputc(kchar,COM2); 
2032:  BRA    2040
2034:  MOVFF  829,852
2038:  MOVLB  0
203A:  CALL   15C0
203E:  MOVLB  1
....................            kbd_down=FALSE; 
2040:  BCF    x58.0
....................            last_key=0; 
2042:  CLRF   x59
2044:  MOVLB  8
....................          } 
....................        } else 
2046:  BRA    20E0
2048:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
204A:  BSF    F93.4
204C:  MOVLW  00
204E:  BTFSC  F81.4
2050:  MOVLW  01
2052:  MOVLB  8
2054:  MOVWF  x2B
2056:  BSF    F93.5
2058:  MOVLW  00
205A:  BTFSC  F81.5
205C:  MOVLW  01
205E:  ANDWF  x2B,F
2060:  BSF    F93.6
2062:  MOVLW  00
2064:  BTFSC  F81.6
2066:  MOVLW  01
2068:  ANDWF  x2B,F
206A:  BSF    F93.7
206C:  MOVLW  00
206E:  BTFSC  F81.7
2070:  MOVLW  01
2072:  ANDWF  x2B,W
2074:  BNZ   20D4
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
2076:  BSF    F93.4
2078:  BTFSC  F81.4
207A:  BRA    2080
....................                   row=0; 
207C:  CLRF   x2A
....................                 else if(input(ROW1)==0) 
207E:  BRA    20A2
2080:  BSF    F93.5
2082:  BTFSC  F81.5
2084:  BRA    208C
....................                   row=1; 
2086:  MOVLW  01
2088:  MOVWF  x2A
....................                 else if(input(ROW2)==0) 
208A:  BRA    20A2
208C:  BSF    F93.6
208E:  BTFSC  F81.6
2090:  BRA    2098
....................                   row=2; 
2092:  MOVLW  02
2094:  MOVWF  x2A
....................                 else if(input(ROW3)==0) 
2096:  BRA    20A2
2098:  BSF    F93.7
209A:  BTFSC  F81.7
209C:  BRA    20A2
....................                   row=3; 
209E:  MOVLW  03
20A0:  MOVWF  x2A
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
20A2:  MOVF   x2A,W
20A4:  MULLW  05
20A6:  MOVF   FF3,W
20A8:  CLRF   x2C
20AA:  MOVWF  x2B
20AC:  CLRF   03
20AE:  MOVLB  1
20B0:  MOVF   x5A,W
20B2:  MOVLB  8
20B4:  ADDWF  x2B,W
20B6:  MOVWF  01
20B8:  MOVF   x2C,W
20BA:  ADDWFC 03,F
20BC:  MOVF   01,W
20BE:  MOVLB  0
20C0:  CALL   030A
20C4:  MOVFF  FE8,159
....................                 kbd_down = TRUE; 
20C8:  MOVLB  1
20CA:  BSF    x58.0
....................                 set_tris_a(0xff); 
20CC:  MOVLW  FF
20CE:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
20D0:  BRA    20E0
20D2:  MOVLB  8
....................                { 
....................                   ++col; 
20D4:  MOVLB  1
20D6:  INCF   x5A,F
....................                   if(col==5) col=0; 
20D8:  MOVF   x5A,W
20DA:  SUBLW  05
20DC:  BTFSC  FD8.2
20DE:  CLRF   x5A
....................                } 
....................          } 
....................       kbd_call_count=0; 
20E0:  MOVLB  1
20E2:  CLRF   x57
....................    } 
....................   return(kchar); 
20E4:  MOVLB  8
20E6:  MOVFF  829,01
.................... } 
20EA:  MOVLB  0
20EC:  RETURN 0
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2112:  MOVLW  E0
2114:  MOVLB  F
2116:  MOVWF  x48
2118:  BCF    FC2.6
211A:  BCF    FC2.7
211C:  MOVF   x49,W
211E:  ANDLW  E0
2120:  IORLW  17
2122:  MOVWF  x49
....................    switch(col) 
....................    { 
2124:  MOVLB  8
2126:  MOVF   x46,W
2128:  ADDLW  FA
212A:  BC    21F6
212C:  ADDLW  06
212E:  MOVLB  0
2130:  GOTO   21FA
....................       case 0: 
....................         set_adc_channel(4); 
2134:  MOVLW  10
2136:  MOVWF  01
2138:  MOVF   FC2,W
213A:  ANDLW  C3
213C:  IORWF  01,W
213E:  MOVWF  FC2
....................         adc=read_adc(); 
2140:  BSF    FC2.1
2142:  BTFSC  FC2.1
2144:  BRA    2142
2146:  MOVFF  FC4,847
....................         return adc; 
214A:  MOVLB  8
214C:  MOVFF  847,01
2150:  BRA    21F6
....................       break; 
2152:  BRA    21F6
....................       case 1: 
....................         set_adc_channel(3); 
2154:  MOVLW  0C
2156:  MOVWF  01
2158:  MOVF   FC2,W
215A:  ANDLW  C3
215C:  IORWF  01,W
215E:  MOVWF  FC2
....................         adc=read_adc(); 
2160:  BSF    FC2.1
2162:  BTFSC  FC2.1
2164:  BRA    2162
2166:  MOVFF  FC4,847
....................         return adc; 
216A:  MOVLB  8
216C:  MOVFF  847,01
2170:  BRA    21F6
....................       break; 
2172:  BRA    21F6
....................       case 2: 
....................         set_adc_channel(2); 
2174:  MOVLW  08
2176:  MOVWF  01
2178:  MOVF   FC2,W
217A:  ANDLW  C3
217C:  IORWF  01,W
217E:  MOVWF  FC2
....................         adc=read_adc(); 
2180:  BSF    FC2.1
2182:  BTFSC  FC2.1
2184:  BRA    2182
2186:  MOVFF  FC4,847
....................         return adc; 
218A:  MOVLB  8
218C:  MOVFF  847,01
2190:  BRA    21F6
....................       break; 
2192:  BRA    21F6
....................       case 3: 
....................         set_adc_channel(1); 
2194:  MOVLW  04
2196:  MOVWF  01
2198:  MOVF   FC2,W
219A:  ANDLW  C3
219C:  IORWF  01,W
219E:  MOVWF  FC2
....................         adc=read_adc(); 
21A0:  BSF    FC2.1
21A2:  BTFSC  FC2.1
21A4:  BRA    21A2
21A6:  MOVFF  FC4,847
....................         return adc; 
21AA:  MOVLB  8
21AC:  MOVFF  847,01
21B0:  BRA    21F6
....................       break; 
21B2:  BRA    21F6
....................       case 4: 
....................         set_adc_channel(0); 
21B4:  MOVLW  00
21B6:  MOVWF  01
21B8:  MOVF   FC2,W
21BA:  ANDLW  C3
21BC:  IORWF  01,W
21BE:  MOVWF  FC2
....................         adc=read_adc(); 
21C0:  BSF    FC2.1
21C2:  BTFSC  FC2.1
21C4:  BRA    21C2
21C6:  MOVFF  FC4,847
....................         return adc; 
21CA:  MOVLB  8
21CC:  MOVFF  847,01
21D0:  BRA    21F6
....................       break;      
21D2:  BRA    21F6
....................       case 5: 
....................         set_adc_channel(11); 
21D4:  MOVLW  2C
21D6:  MOVWF  01
21D8:  MOVF   FC2,W
21DA:  ANDLW  C3
21DC:  IORWF  01,W
21DE:  MOVWF  FC2
....................         adc=read_adc(); 
21E0:  BSF    FC2.1
21E2:  BTFSC  FC2.1
21E4:  BRA    21E2
21E6:  MOVFF  FC4,847
....................         return adc; 
21EA:  MOVLB  8
21EC:  MOVFF  847,01
21F0:  BRA    21F6
....................       break;      
21F2:  BRA    21F6
21F4:  MOVLB  8
....................    } 
.................... } 
21F6:  MOVLB  0
21F8:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
2374:  MOVLB  8
2376:  CLRF   x31
2378:  CLRF   x30
237A:  CLRF   x2F
237C:  CLRF   x2E
237E:  CLRF   x35
2380:  CLRF   x34
2382:  CLRF   x33
2384:  CLRF   x32
2386:  CLRF   x39
2388:  CLRF   x38
238A:  CLRF   x37
238C:  CLRF   x36
238E:  CLRF   x3D
2390:  CLRF   x3C
2392:  CLRF   x3B
2394:  CLRF   x3A
2396:  CLRF   x41
2398:  CLRF   x40
239A:  CLRF   x3F
239C:  CLRF   x3E
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
239E:  CLRF   x2D
23A0:  CLRF   x2C
23A2:  MOVF   x2D,W
23A4:  SUBLW  01
23A6:  BNC   2424
23A8:  BNZ   23B0
23AA:  MOVF   x2C,W
23AC:  SUBLW  F3
23AE:  BNC   2424
....................    { 
....................       col_0=read_col(0)+col_0; 
23B0:  CLRF   x46
23B2:  MOVLB  0
23B4:  RCALL  2112
23B6:  MOVF   01,W
23B8:  MOVLB  8
23BA:  ADDWF  x2E,F
23BC:  MOVLW  00
23BE:  ADDWFC x2F,F
23C0:  ADDWFC x30,F
23C2:  ADDWFC x31,F
....................       col_1=read_col(1)+col_1; 
23C4:  MOVLW  01
23C6:  MOVWF  x46
23C8:  MOVLB  0
23CA:  RCALL  2112
23CC:  MOVF   01,W
23CE:  MOVLB  8
23D0:  ADDWF  x32,F
23D2:  MOVLW  00
23D4:  ADDWFC x33,F
23D6:  ADDWFC x34,F
23D8:  ADDWFC x35,F
....................       col_2=read_col(2)+col_2; 
23DA:  MOVLW  02
23DC:  MOVWF  x46
23DE:  MOVLB  0
23E0:  RCALL  2112
23E2:  MOVF   01,W
23E4:  MOVLB  8
23E6:  ADDWF  x36,F
23E8:  MOVLW  00
23EA:  ADDWFC x37,F
23EC:  ADDWFC x38,F
23EE:  ADDWFC x39,F
....................       col_3=read_col(3)+col_3; 
23F0:  MOVLW  03
23F2:  MOVWF  x46
23F4:  MOVLB  0
23F6:  RCALL  2112
23F8:  MOVF   01,W
23FA:  MOVLB  8
23FC:  ADDWF  x3A,F
23FE:  MOVLW  00
2400:  ADDWFC x3B,F
2402:  ADDWFC x3C,F
2404:  ADDWFC x3D,F
....................       col_4=read_col(4)+col_4; 
2406:  MOVLW  04
2408:  MOVWF  x46
240A:  MOVLB  0
240C:  RCALL  2112
240E:  MOVF   01,W
2410:  MOVLB  8
2412:  ADDWF  x3E,F
2414:  MOVLW  00
2416:  ADDWFC x3F,F
2418:  ADDWFC x40,F
241A:  ADDWFC x41,F
....................    } 
241C:  INCF   x2C,F
241E:  BTFSC  FD8.2
2420:  INCF   x2D,F
2422:  BRA    23A2
....................    col_0=col_0/500; 
2424:  BCF    FD8.1
2426:  MOVFF  831,855
242A:  MOVFF  830,854
242E:  MOVFF  82F,853
2432:  MOVFF  82E,852
2436:  CLRF   x59
2438:  CLRF   x58
243A:  MOVLW  01
243C:  MOVWF  x57
243E:  MOVLW  F4
2440:  MOVWF  x56
2442:  MOVLB  0
2444:  RCALL  2220
2446:  MOVFF  03,831
244A:  MOVFF  02,830
244E:  MOVFF  01,82F
2452:  MOVFF  00,82E
....................    col_1=col_1/500; 
2456:  BCF    FD8.1
2458:  MOVFF  835,855
245C:  MOVFF  834,854
2460:  MOVFF  833,853
2464:  MOVFF  832,852
2468:  MOVLB  8
246A:  CLRF   x59
246C:  CLRF   x58
246E:  MOVLW  01
2470:  MOVWF  x57
2472:  MOVLW  F4
2474:  MOVWF  x56
2476:  MOVLB  0
2478:  RCALL  2220
247A:  MOVFF  03,835
247E:  MOVFF  02,834
2482:  MOVFF  01,833
2486:  MOVFF  00,832
....................    col_2=col_2/500; 
248A:  BCF    FD8.1
248C:  MOVFF  839,855
2490:  MOVFF  838,854
2494:  MOVFF  837,853
2498:  MOVFF  836,852
249C:  MOVLB  8
249E:  CLRF   x59
24A0:  CLRF   x58
24A2:  MOVLW  01
24A4:  MOVWF  x57
24A6:  MOVLW  F4
24A8:  MOVWF  x56
24AA:  MOVLB  0
24AC:  RCALL  2220
24AE:  MOVFF  03,839
24B2:  MOVFF  02,838
24B6:  MOVFF  01,837
24BA:  MOVFF  00,836
....................    col_3=col_3/500; 
24BE:  BCF    FD8.1
24C0:  MOVFF  83D,855
24C4:  MOVFF  83C,854
24C8:  MOVFF  83B,853
24CC:  MOVFF  83A,852
24D0:  MOVLB  8
24D2:  CLRF   x59
24D4:  CLRF   x58
24D6:  MOVLW  01
24D8:  MOVWF  x57
24DA:  MOVLW  F4
24DC:  MOVWF  x56
24DE:  MOVLB  0
24E0:  RCALL  2220
24E2:  MOVFF  03,83D
24E6:  MOVFF  02,83C
24EA:  MOVFF  01,83B
24EE:  MOVFF  00,83A
....................    col_4=col_4/500; 
24F2:  BCF    FD8.1
24F4:  MOVFF  841,855
24F8:  MOVFF  840,854
24FC:  MOVFF  83F,853
2500:  MOVFF  83E,852
2504:  MOVLB  8
2506:  CLRF   x59
2508:  CLRF   x58
250A:  MOVLW  01
250C:  MOVWF  x57
250E:  MOVLW  F4
2510:  MOVWF  x56
2512:  MOVLB  0
2514:  RCALL  2220
2516:  MOVFF  03,841
251A:  MOVFF  02,840
251E:  MOVFF  01,83F
2522:  MOVFF  00,83E
....................    if(keydebug_en) 
2526:  MOVLB  1
2528:  MOVF   x40,F
252A:  BTFSC  FD8.2
252C:  BRA    26A8
....................    { 
....................       fprintf(COM2,"\r\n");      
252E:  MOVLW  0D
2530:  MOVLB  8
2532:  MOVWF  x52
2534:  MOVLB  0
2536:  CALL   15C0
253A:  MOVLW  0A
253C:  MOVLB  8
253E:  MOVWF  x52
2540:  MOVLB  0
2542:  CALL   15C0
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2546:  MOVLW  BC
2548:  MOVWF  FF6
254A:  MOVLW  04
254C:  MOVWF  FF7
254E:  MOVLW  07
2550:  MOVLB  8
2552:  MOVWF  x46
2554:  MOVLB  0
2556:  CALL   1606
255A:  MOVLW  41
255C:  MOVWF  FE9
255E:  MOVFF  831,849
2562:  MOVFF  830,848
2566:  MOVFF  82F,847
256A:  MOVFF  82E,846
256E:  RCALL  22B4
2570:  MOVLW  0D
2572:  MOVLB  8
2574:  MOVWF  x52
2576:  MOVLB  0
2578:  CALL   15C0
257C:  MOVLW  0A
257E:  MOVLB  8
2580:  MOVWF  x52
2582:  MOVLB  0
2584:  CALL   15C0
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2588:  MOVLW  CA
258A:  MOVWF  FF6
258C:  MOVLW  04
258E:  MOVWF  FF7
2590:  MOVLW  07
2592:  MOVLB  8
2594:  MOVWF  x46
2596:  MOVLB  0
2598:  CALL   1606
259C:  MOVLW  41
259E:  MOVWF  FE9
25A0:  MOVFF  835,849
25A4:  MOVFF  834,848
25A8:  MOVFF  833,847
25AC:  MOVFF  832,846
25B0:  RCALL  22B4
25B2:  MOVLW  0D
25B4:  MOVLB  8
25B6:  MOVWF  x52
25B8:  MOVLB  0
25BA:  CALL   15C0
25BE:  MOVLW  0A
25C0:  MOVLB  8
25C2:  MOVWF  x52
25C4:  MOVLB  0
25C6:  CALL   15C0
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
25CA:  MOVLW  D8
25CC:  MOVWF  FF6
25CE:  MOVLW  04
25D0:  MOVWF  FF7
25D2:  MOVLW  07
25D4:  MOVLB  8
25D6:  MOVWF  x46
25D8:  MOVLB  0
25DA:  CALL   1606
25DE:  MOVLW  41
25E0:  MOVWF  FE9
25E2:  MOVFF  839,849
25E6:  MOVFF  838,848
25EA:  MOVFF  837,847
25EE:  MOVFF  836,846
25F2:  RCALL  22B4
25F4:  MOVLW  0D
25F6:  MOVLB  8
25F8:  MOVWF  x52
25FA:  MOVLB  0
25FC:  CALL   15C0
2600:  MOVLW  0A
2602:  MOVLB  8
2604:  MOVWF  x52
2606:  MOVLB  0
2608:  CALL   15C0
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
260C:  MOVLW  E6
260E:  MOVWF  FF6
2610:  MOVLW  04
2612:  MOVWF  FF7
2614:  MOVLW  07
2616:  MOVLB  8
2618:  MOVWF  x46
261A:  MOVLB  0
261C:  CALL   1606
2620:  MOVLW  41
2622:  MOVWF  FE9
2624:  MOVFF  83D,849
2628:  MOVFF  83C,848
262C:  MOVFF  83B,847
2630:  MOVFF  83A,846
2634:  RCALL  22B4
2636:  MOVLW  0D
2638:  MOVLB  8
263A:  MOVWF  x52
263C:  MOVLB  0
263E:  CALL   15C0
2642:  MOVLW  0A
2644:  MOVLB  8
2646:  MOVWF  x52
2648:  MOVLB  0
264A:  CALL   15C0
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
264E:  MOVLW  F4
2650:  MOVWF  FF6
2652:  MOVLW  04
2654:  MOVWF  FF7
2656:  MOVLW  07
2658:  MOVLB  8
265A:  MOVWF  x46
265C:  MOVLB  0
265E:  CALL   1606
2662:  MOVLW  41
2664:  MOVWF  FE9
2666:  MOVFF  841,849
266A:  MOVFF  840,848
266E:  MOVFF  83F,847
2672:  MOVFF  83E,846
2676:  RCALL  22B4
2678:  MOVLW  0D
267A:  MOVLB  8
267C:  MOVWF  x52
267E:  MOVLB  0
2680:  CALL   15C0
2684:  MOVLW  0A
2686:  MOVLB  8
2688:  MOVWF  x52
268A:  MOVLB  0
268C:  CALL   15C0
....................       fprintf(COM2,"\r\n"); 
2690:  MOVLW  0D
2692:  MOVLB  8
2694:  MOVWF  x52
2696:  MOVLB  0
2698:  CALL   15C0
269C:  MOVLW  0A
269E:  MOVLB  8
26A0:  MOVWF  x52
26A2:  MOVLB  0
26A4:  CALL   15C0
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
26A8:  MOVLB  8
26AA:  MOVF   x31,F
26AC:  BNZ   26BC
26AE:  MOVF   x30,F
26B0:  BNZ   26BC
26B2:  MOVF   x2F,F
26B4:  BNZ   26BC
26B6:  MOVF   x2E,W
26B8:  SUBLW  05
26BA:  BC    271C
26BC:  MOVF   x31,F
26BE:  BNZ   271C
26C0:  MOVF   x30,F
26C2:  BNZ   271C
26C4:  MOVF   x2F,F
26C6:  BNZ   271C
26C8:  MOVF   x2E,W
26CA:  SUBLW  3B
26CC:  BNC   271C
26CE:  MOVF   x35,F
26D0:  BNZ   26E0
26D2:  MOVF   x34,F
26D4:  BNZ   26E0
26D6:  MOVF   x33,F
26D8:  BNZ   26E0
26DA:  MOVF   x32,W
26DC:  SUBLW  64
26DE:  BC    271C
26E0:  MOVF   x39,F
26E2:  BNZ   26F2
26E4:  MOVF   x38,F
26E6:  BNZ   26F2
26E8:  MOVF   x37,F
26EA:  BNZ   26F2
26EC:  MOVF   x36,W
26EE:  SUBLW  64
26F0:  BC    271C
26F2:  MOVF   x3D,F
26F4:  BNZ   2704
26F6:  MOVF   x3C,F
26F8:  BNZ   2704
26FA:  MOVF   x3B,F
26FC:  BNZ   2704
26FE:  MOVF   x3A,W
2700:  SUBLW  64
2702:  BC    271C
2704:  MOVF   x41,F
2706:  BNZ   2716
2708:  MOVF   x40,F
270A:  BNZ   2716
270C:  MOVF   x3F,F
270E:  BNZ   2716
2710:  MOVF   x3E,W
2712:  SUBLW  64
2714:  BC    271C
2716:  MOVLW  00
2718:  MOVWF  01
271A:  BRA    299A
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
271C:  MOVF   x35,F
271E:  BNZ   272E
2720:  MOVF   x34,F
2722:  BNZ   272E
2724:  MOVF   x33,F
2726:  BNZ   272E
2728:  MOVF   x32,W
272A:  SUBLW  05
272C:  BC    278E
272E:  MOVF   x35,F
2730:  BNZ   278E
2732:  MOVF   x34,F
2734:  BNZ   278E
2736:  MOVF   x33,F
2738:  BNZ   278E
273A:  MOVF   x32,W
273C:  SUBLW  3B
273E:  BNC   278E
2740:  MOVF   x31,F
2742:  BNZ   2752
2744:  MOVF   x30,F
2746:  BNZ   2752
2748:  MOVF   x2F,F
274A:  BNZ   2752
274C:  MOVF   x2E,W
274E:  SUBLW  64
2750:  BC    278E
2752:  MOVF   x39,F
2754:  BNZ   2764
2756:  MOVF   x38,F
2758:  BNZ   2764
275A:  MOVF   x37,F
275C:  BNZ   2764
275E:  MOVF   x36,W
2760:  SUBLW  64
2762:  BC    278E
2764:  MOVF   x3D,F
2766:  BNZ   2776
2768:  MOVF   x3C,F
276A:  BNZ   2776
276C:  MOVF   x3B,F
276E:  BNZ   2776
2770:  MOVF   x3A,W
2772:  SUBLW  64
2774:  BC    278E
2776:  MOVF   x41,F
2778:  BNZ   2788
277A:  MOVF   x40,F
277C:  BNZ   2788
277E:  MOVF   x3F,F
2780:  BNZ   2788
2782:  MOVF   x3E,W
2784:  SUBLW  64
2786:  BC    278E
2788:  MOVLW  01
278A:  MOVWF  01
278C:  BRA    299A
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
278E:  MOVF   x39,F
2790:  BNZ   27A0
2792:  MOVF   x38,F
2794:  BNZ   27A0
2796:  MOVF   x37,F
2798:  BNZ   27A0
279A:  MOVF   x36,W
279C:  SUBLW  05
279E:  BC    2800
27A0:  MOVF   x39,F
27A2:  BNZ   2800
27A4:  MOVF   x38,F
27A6:  BNZ   2800
27A8:  MOVF   x37,F
27AA:  BNZ   2800
27AC:  MOVF   x36,W
27AE:  SUBLW  3B
27B0:  BNC   2800
27B2:  MOVF   x35,F
27B4:  BNZ   27C4
27B6:  MOVF   x34,F
27B8:  BNZ   27C4
27BA:  MOVF   x33,F
27BC:  BNZ   27C4
27BE:  MOVF   x32,W
27C0:  SUBLW  64
27C2:  BC    2800
27C4:  MOVF   x31,F
27C6:  BNZ   27D6
27C8:  MOVF   x30,F
27CA:  BNZ   27D6
27CC:  MOVF   x2F,F
27CE:  BNZ   27D6
27D0:  MOVF   x2E,W
27D2:  SUBLW  64
27D4:  BC    2800
27D6:  MOVF   x3D,F
27D8:  BNZ   27E8
27DA:  MOVF   x3C,F
27DC:  BNZ   27E8
27DE:  MOVF   x3B,F
27E0:  BNZ   27E8
27E2:  MOVF   x3A,W
27E4:  SUBLW  64
27E6:  BC    2800
27E8:  MOVF   x41,F
27EA:  BNZ   27FA
27EC:  MOVF   x40,F
27EE:  BNZ   27FA
27F0:  MOVF   x3F,F
27F2:  BNZ   27FA
27F4:  MOVF   x3E,W
27F6:  SUBLW  64
27F8:  BC    2800
27FA:  MOVLW  02
27FC:  MOVWF  01
27FE:  BRA    299A
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2800:  MOVF   x3D,F
2802:  BNZ   2812
2804:  MOVF   x3C,F
2806:  BNZ   2812
2808:  MOVF   x3B,F
280A:  BNZ   2812
280C:  MOVF   x3A,W
280E:  SUBLW  05
2810:  BC    2872
2812:  MOVF   x3D,F
2814:  BNZ   2872
2816:  MOVF   x3C,F
2818:  BNZ   2872
281A:  MOVF   x3B,F
281C:  BNZ   2872
281E:  MOVF   x3A,W
2820:  SUBLW  3B
2822:  BNC   2872
2824:  MOVF   x35,F
2826:  BNZ   2836
2828:  MOVF   x34,F
282A:  BNZ   2836
282C:  MOVF   x33,F
282E:  BNZ   2836
2830:  MOVF   x32,W
2832:  SUBLW  64
2834:  BC    2872
2836:  MOVF   x39,F
2838:  BNZ   2848
283A:  MOVF   x38,F
283C:  BNZ   2848
283E:  MOVF   x37,F
2840:  BNZ   2848
2842:  MOVF   x36,W
2844:  SUBLW  64
2846:  BC    2872
2848:  MOVF   x31,F
284A:  BNZ   285A
284C:  MOVF   x30,F
284E:  BNZ   285A
2850:  MOVF   x2F,F
2852:  BNZ   285A
2854:  MOVF   x2E,W
2856:  SUBLW  64
2858:  BC    2872
285A:  MOVF   x41,F
285C:  BNZ   286C
285E:  MOVF   x40,F
2860:  BNZ   286C
2862:  MOVF   x3F,F
2864:  BNZ   286C
2866:  MOVF   x3E,W
2868:  SUBLW  64
286A:  BC    2872
286C:  MOVLW  03
286E:  MOVWF  01
2870:  BRA    299A
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2872:  MOVF   x41,F
2874:  BNZ   2884
2876:  MOVF   x40,F
2878:  BNZ   2884
287A:  MOVF   x3F,F
287C:  BNZ   2884
287E:  MOVF   x3E,W
2880:  SUBLW  05
2882:  BC    28E4
2884:  MOVF   x41,F
2886:  BNZ   28E4
2888:  MOVF   x40,F
288A:  BNZ   28E4
288C:  MOVF   x3F,F
288E:  BNZ   28E4
2890:  MOVF   x3E,W
2892:  SUBLW  3B
2894:  BNC   28E4
2896:  MOVF   x35,F
2898:  BNZ   28A8
289A:  MOVF   x34,F
289C:  BNZ   28A8
289E:  MOVF   x33,F
28A0:  BNZ   28A8
28A2:  MOVF   x32,W
28A4:  SUBLW  64
28A6:  BC    28E4
28A8:  MOVF   x39,F
28AA:  BNZ   28BA
28AC:  MOVF   x38,F
28AE:  BNZ   28BA
28B0:  MOVF   x37,F
28B2:  BNZ   28BA
28B4:  MOVF   x36,W
28B6:  SUBLW  64
28B8:  BC    28E4
28BA:  MOVF   x3D,F
28BC:  BNZ   28CC
28BE:  MOVF   x3C,F
28C0:  BNZ   28CC
28C2:  MOVF   x3B,F
28C4:  BNZ   28CC
28C6:  MOVF   x3A,W
28C8:  SUBLW  64
28CA:  BC    28E4
28CC:  MOVF   x31,F
28CE:  BNZ   28DE
28D0:  MOVF   x30,F
28D2:  BNZ   28DE
28D4:  MOVF   x2F,F
28D6:  BNZ   28DE
28D8:  MOVF   x2E,W
28DA:  SUBLW  64
28DC:  BC    28E4
28DE:  MOVLW  04
28E0:  MOVWF  01
28E2:  BRA    299A
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
28E4:  MOVF   x41,F
28E6:  BNZ   28F8
28E8:  MOVF   x40,F
28EA:  BNZ   28F8
28EC:  MOVF   x3F,F
28EE:  BNZ   28F8
28F0:  MOVF   x3E,W
28F2:  SUBLW  C8
28F4:  BTFSC  FD8.0
28F6:  BRA    2996
28F8:  MOVF   x31,F
28FA:  BTFSS  FD8.2
28FC:  BRA    2996
28FE:  MOVF   x30,F
2900:  BTFSS  FD8.2
2902:  BRA    2996
2904:  MOVF   x2F,F
2906:  BTFSS  FD8.2
2908:  BRA    2996
290A:  MOVF   x2E,W
290C:  SUBLW  B3
290E:  BNC   2996
2910:  MOVF   x31,F
2912:  BNZ   2922
2914:  MOVF   x30,F
2916:  BNZ   2922
2918:  MOVF   x2F,F
291A:  BNZ   2922
291C:  MOVF   x2E,W
291E:  SUBLW  64
2920:  BC    2996
2922:  MOVF   x35,F
2924:  BNZ   2996
2926:  MOVF   x34,F
2928:  BNZ   2996
292A:  MOVF   x33,F
292C:  BNZ   2996
292E:  MOVF   x32,W
2930:  SUBLW  B3
2932:  BNC   2996
2934:  MOVF   x35,F
2936:  BNZ   2946
2938:  MOVF   x34,F
293A:  BNZ   2946
293C:  MOVF   x33,F
293E:  BNZ   2946
2940:  MOVF   x32,W
2942:  SUBLW  64
2944:  BC    2996
2946:  MOVF   x39,F
2948:  BNZ   2996
294A:  MOVF   x38,F
294C:  BNZ   2996
294E:  MOVF   x37,F
2950:  BNZ   2996
2952:  MOVF   x36,W
2954:  SUBLW  B3
2956:  BNC   2996
2958:  MOVF   x39,F
295A:  BNZ   296A
295C:  MOVF   x38,F
295E:  BNZ   296A
2960:  MOVF   x37,F
2962:  BNZ   296A
2964:  MOVF   x36,W
2966:  SUBLW  64
2968:  BC    2996
296A:  MOVF   x3D,F
296C:  BNZ   2996
296E:  MOVF   x3C,F
2970:  BNZ   2996
2972:  MOVF   x3B,F
2974:  BNZ   2996
2976:  MOVF   x3A,W
2978:  SUBLW  B3
297A:  BNC   2996
297C:  MOVF   x3D,F
297E:  BNZ   298E
2980:  MOVF   x3C,F
2982:  BNZ   298E
2984:  MOVF   x3B,F
2986:  BNZ   298E
2988:  MOVF   x3A,W
298A:  SUBLW  64
298C:  BC    2996
298E:  MOVLW  04
2990:  MOVWF  01
2992:  BRA    299A
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2994:  BRA    299A
2996:  MOVLW  FF
2998:  MOVWF  01
.................... } 
299A:  MOVLB  0
299C:  GOTO   31E6 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
29A0:  MOVLB  8
29A2:  CLRF   x31
29A4:  CLRF   x30
29A6:  CLRF   x2F
29A8:  CLRF   x2E
29AA:  CLRF   x35
29AC:  CLRF   x34
29AE:  CLRF   x33
29B0:  CLRF   x32
29B2:  CLRF   x39
29B4:  CLRF   x38
29B6:  CLRF   x37
29B8:  CLRF   x36
29BA:  CLRF   x3D
29BC:  CLRF   x3C
29BE:  CLRF   x3B
29C0:  CLRF   x3A
29C2:  CLRF   x41
29C4:  CLRF   x40
29C6:  CLRF   x3F
29C8:  CLRF   x3E
29CA:  CLRF   x45
29CC:  CLRF   x44
29CE:  CLRF   x43
29D0:  CLRF   x42
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
29D2:  CLRF   x2D
29D4:  CLRF   x2C
29D6:  MOVF   x2D,W
29D8:  SUBLW  01
29DA:  BNC   2A7A
29DC:  BNZ   29E4
29DE:  MOVF   x2C,W
29E0:  SUBLW  F3
29E2:  BNC   2A7A
....................    { 
....................       col_0=read_col(0)+col_0; 
29E4:  CLRF   x46
29E6:  MOVLB  0
29E8:  CALL   2112
29EC:  MOVF   01,W
29EE:  MOVLB  8
29F0:  ADDWF  x2E,F
29F2:  MOVLW  00
29F4:  ADDWFC x2F,F
29F6:  ADDWFC x30,F
29F8:  ADDWFC x31,F
....................       col_1=read_col(1)+col_1; 
29FA:  MOVLW  01
29FC:  MOVWF  x46
29FE:  MOVLB  0
2A00:  CALL   2112
2A04:  MOVF   01,W
2A06:  MOVLB  8
2A08:  ADDWF  x32,F
2A0A:  MOVLW  00
2A0C:  ADDWFC x33,F
2A0E:  ADDWFC x34,F
2A10:  ADDWFC x35,F
....................       col_2=read_col(2)+col_2; 
2A12:  MOVLW  02
2A14:  MOVWF  x46
2A16:  MOVLB  0
2A18:  CALL   2112
2A1C:  MOVF   01,W
2A1E:  MOVLB  8
2A20:  ADDWF  x36,F
2A22:  MOVLW  00
2A24:  ADDWFC x37,F
2A26:  ADDWFC x38,F
2A28:  ADDWFC x39,F
....................       col_3=read_col(3)+col_3; 
2A2A:  MOVLW  03
2A2C:  MOVWF  x46
2A2E:  MOVLB  0
2A30:  CALL   2112
2A34:  MOVF   01,W
2A36:  MOVLB  8
2A38:  ADDWF  x3A,F
2A3A:  MOVLW  00
2A3C:  ADDWFC x3B,F
2A3E:  ADDWFC x3C,F
2A40:  ADDWFC x3D,F
....................       col_4=read_col(4)+col_4; 
2A42:  MOVLW  04
2A44:  MOVWF  x46
2A46:  MOVLB  0
2A48:  CALL   2112
2A4C:  MOVF   01,W
2A4E:  MOVLB  8
2A50:  ADDWF  x3E,F
2A52:  MOVLW  00
2A54:  ADDWFC x3F,F
2A56:  ADDWFC x40,F
2A58:  ADDWFC x41,F
....................       col_5=read_col(5)+col_5; 
2A5A:  MOVLW  05
2A5C:  MOVWF  x46
2A5E:  MOVLB  0
2A60:  CALL   2112
2A64:  MOVF   01,W
2A66:  MOVLB  8
2A68:  ADDWF  x42,F
2A6A:  MOVLW  00
2A6C:  ADDWFC x43,F
2A6E:  ADDWFC x44,F
2A70:  ADDWFC x45,F
....................    } 
2A72:  INCF   x2C,F
2A74:  BTFSC  FD8.2
2A76:  INCF   x2D,F
2A78:  BRA    29D6
....................    col_0=col_0/500; 
2A7A:  BCF    FD8.1
2A7C:  MOVFF  831,855
2A80:  MOVFF  830,854
2A84:  MOVFF  82F,853
2A88:  MOVFF  82E,852
2A8C:  CLRF   x59
2A8E:  CLRF   x58
2A90:  MOVLW  01
2A92:  MOVWF  x57
2A94:  MOVLW  F4
2A96:  MOVWF  x56
2A98:  MOVLB  0
2A9A:  CALL   2220
2A9E:  MOVFF  03,831
2AA2:  MOVFF  02,830
2AA6:  MOVFF  01,82F
2AAA:  MOVFF  00,82E
....................    col_1=col_1/500; 
2AAE:  BCF    FD8.1
2AB0:  MOVFF  835,855
2AB4:  MOVFF  834,854
2AB8:  MOVFF  833,853
2ABC:  MOVFF  832,852
2AC0:  MOVLB  8
2AC2:  CLRF   x59
2AC4:  CLRF   x58
2AC6:  MOVLW  01
2AC8:  MOVWF  x57
2ACA:  MOVLW  F4
2ACC:  MOVWF  x56
2ACE:  MOVLB  0
2AD0:  CALL   2220
2AD4:  MOVFF  03,835
2AD8:  MOVFF  02,834
2ADC:  MOVFF  01,833
2AE0:  MOVFF  00,832
....................    col_2=col_2/500; 
2AE4:  BCF    FD8.1
2AE6:  MOVFF  839,855
2AEA:  MOVFF  838,854
2AEE:  MOVFF  837,853
2AF2:  MOVFF  836,852
2AF6:  MOVLB  8
2AF8:  CLRF   x59
2AFA:  CLRF   x58
2AFC:  MOVLW  01
2AFE:  MOVWF  x57
2B00:  MOVLW  F4
2B02:  MOVWF  x56
2B04:  MOVLB  0
2B06:  CALL   2220
2B0A:  MOVFF  03,839
2B0E:  MOVFF  02,838
2B12:  MOVFF  01,837
2B16:  MOVFF  00,836
....................    col_3=col_3/500; 
2B1A:  BCF    FD8.1
2B1C:  MOVFF  83D,855
2B20:  MOVFF  83C,854
2B24:  MOVFF  83B,853
2B28:  MOVFF  83A,852
2B2C:  MOVLB  8
2B2E:  CLRF   x59
2B30:  CLRF   x58
2B32:  MOVLW  01
2B34:  MOVWF  x57
2B36:  MOVLW  F4
2B38:  MOVWF  x56
2B3A:  MOVLB  0
2B3C:  CALL   2220
2B40:  MOVFF  03,83D
2B44:  MOVFF  02,83C
2B48:  MOVFF  01,83B
2B4C:  MOVFF  00,83A
....................    col_4=col_4/500; 
2B50:  BCF    FD8.1
2B52:  MOVFF  841,855
2B56:  MOVFF  840,854
2B5A:  MOVFF  83F,853
2B5E:  MOVFF  83E,852
2B62:  MOVLB  8
2B64:  CLRF   x59
2B66:  CLRF   x58
2B68:  MOVLW  01
2B6A:  MOVWF  x57
2B6C:  MOVLW  F4
2B6E:  MOVWF  x56
2B70:  MOVLB  0
2B72:  CALL   2220
2B76:  MOVFF  03,841
2B7A:  MOVFF  02,840
2B7E:  MOVFF  01,83F
2B82:  MOVFF  00,83E
....................    col_5=col_5/500; 
2B86:  BCF    FD8.1
2B88:  MOVFF  845,855
2B8C:  MOVFF  844,854
2B90:  MOVFF  843,853
2B94:  MOVFF  842,852
2B98:  MOVLB  8
2B9A:  CLRF   x59
2B9C:  CLRF   x58
2B9E:  MOVLW  01
2BA0:  MOVWF  x57
2BA2:  MOVLW  F4
2BA4:  MOVWF  x56
2BA6:  MOVLB  0
2BA8:  CALL   2220
2BAC:  MOVFF  03,845
2BB0:  MOVFF  02,844
2BB4:  MOVFF  01,843
2BB8:  MOVFF  00,842
....................    if(keydebug_en) 
2BBC:  MOVLB  1
2BBE:  MOVF   x40,F
2BC0:  BTFSC  FD8.2
2BC2:  BRA    2D8C
....................    { 
....................       fprintf(COM2,"\r\n");      
2BC4:  MOVLW  0D
2BC6:  MOVLB  8
2BC8:  MOVWF  x52
2BCA:  MOVLB  0
2BCC:  CALL   15C0
2BD0:  MOVLW  0A
2BD2:  MOVLB  8
2BD4:  MOVWF  x52
2BD6:  MOVLB  0
2BD8:  CALL   15C0
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2BDC:  MOVLW  02
2BDE:  MOVWF  FF6
2BE0:  MOVLW  05
2BE2:  MOVWF  FF7
2BE4:  MOVLW  07
2BE6:  MOVLB  8
2BE8:  MOVWF  x46
2BEA:  MOVLB  0
2BEC:  CALL   1606
2BF0:  MOVLW  41
2BF2:  MOVWF  FE9
2BF4:  MOVFF  831,849
2BF8:  MOVFF  830,848
2BFC:  MOVFF  82F,847
2C00:  MOVFF  82E,846
2C04:  CALL   22B4
2C08:  MOVLW  0D
2C0A:  MOVLB  8
2C0C:  MOVWF  x52
2C0E:  MOVLB  0
2C10:  CALL   15C0
2C14:  MOVLW  0A
2C16:  MOVLB  8
2C18:  MOVWF  x52
2C1A:  MOVLB  0
2C1C:  CALL   15C0
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2C20:  MOVLW  10
2C22:  MOVWF  FF6
2C24:  MOVLW  05
2C26:  MOVWF  FF7
2C28:  MOVLW  07
2C2A:  MOVLB  8
2C2C:  MOVWF  x46
2C2E:  MOVLB  0
2C30:  CALL   1606
2C34:  MOVLW  41
2C36:  MOVWF  FE9
2C38:  MOVFF  835,849
2C3C:  MOVFF  834,848
2C40:  MOVFF  833,847
2C44:  MOVFF  832,846
2C48:  CALL   22B4
2C4C:  MOVLW  0D
2C4E:  MOVLB  8
2C50:  MOVWF  x52
2C52:  MOVLB  0
2C54:  CALL   15C0
2C58:  MOVLW  0A
2C5A:  MOVLB  8
2C5C:  MOVWF  x52
2C5E:  MOVLB  0
2C60:  CALL   15C0
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2C64:  MOVLW  1E
2C66:  MOVWF  FF6
2C68:  MOVLW  05
2C6A:  MOVWF  FF7
2C6C:  MOVLW  07
2C6E:  MOVLB  8
2C70:  MOVWF  x46
2C72:  MOVLB  0
2C74:  CALL   1606
2C78:  MOVLW  41
2C7A:  MOVWF  FE9
2C7C:  MOVFF  839,849
2C80:  MOVFF  838,848
2C84:  MOVFF  837,847
2C88:  MOVFF  836,846
2C8C:  CALL   22B4
2C90:  MOVLW  0D
2C92:  MOVLB  8
2C94:  MOVWF  x52
2C96:  MOVLB  0
2C98:  CALL   15C0
2C9C:  MOVLW  0A
2C9E:  MOVLB  8
2CA0:  MOVWF  x52
2CA2:  MOVLB  0
2CA4:  CALL   15C0
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2CA8:  MOVLW  2C
2CAA:  MOVWF  FF6
2CAC:  MOVLW  05
2CAE:  MOVWF  FF7
2CB0:  MOVLW  07
2CB2:  MOVLB  8
2CB4:  MOVWF  x46
2CB6:  MOVLB  0
2CB8:  CALL   1606
2CBC:  MOVLW  41
2CBE:  MOVWF  FE9
2CC0:  MOVFF  83D,849
2CC4:  MOVFF  83C,848
2CC8:  MOVFF  83B,847
2CCC:  MOVFF  83A,846
2CD0:  CALL   22B4
2CD4:  MOVLW  0D
2CD6:  MOVLB  8
2CD8:  MOVWF  x52
2CDA:  MOVLB  0
2CDC:  CALL   15C0
2CE0:  MOVLW  0A
2CE2:  MOVLB  8
2CE4:  MOVWF  x52
2CE6:  MOVLB  0
2CE8:  CALL   15C0
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2CEC:  MOVLW  3A
2CEE:  MOVWF  FF6
2CF0:  MOVLW  05
2CF2:  MOVWF  FF7
2CF4:  MOVLW  07
2CF6:  MOVLB  8
2CF8:  MOVWF  x46
2CFA:  MOVLB  0
2CFC:  CALL   1606
2D00:  MOVLW  41
2D02:  MOVWF  FE9
2D04:  MOVFF  841,849
2D08:  MOVFF  840,848
2D0C:  MOVFF  83F,847
2D10:  MOVFF  83E,846
2D14:  CALL   22B4
2D18:  MOVLW  0D
2D1A:  MOVLB  8
2D1C:  MOVWF  x52
2D1E:  MOVLB  0
2D20:  CALL   15C0
2D24:  MOVLW  0A
2D26:  MOVLB  8
2D28:  MOVWF  x52
2D2A:  MOVLB  0
2D2C:  CALL   15C0
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2D30:  MOVLW  48
2D32:  MOVWF  FF6
2D34:  MOVLW  05
2D36:  MOVWF  FF7
2D38:  MOVLW  07
2D3A:  MOVLB  8
2D3C:  MOVWF  x46
2D3E:  MOVLB  0
2D40:  CALL   1606
2D44:  MOVLW  41
2D46:  MOVWF  FE9
2D48:  MOVFF  845,849
2D4C:  MOVFF  844,848
2D50:  MOVFF  843,847
2D54:  MOVFF  842,846
2D58:  CALL   22B4
2D5C:  MOVLW  0D
2D5E:  MOVLB  8
2D60:  MOVWF  x52
2D62:  MOVLB  0
2D64:  CALL   15C0
2D68:  MOVLW  0A
2D6A:  MOVLB  8
2D6C:  MOVWF  x52
2D6E:  MOVLB  0
2D70:  CALL   15C0
....................       fprintf(COM2,"\r\n"); 
2D74:  MOVLW  0D
2D76:  MOVLB  8
2D78:  MOVWF  x52
2D7A:  MOVLB  0
2D7C:  CALL   15C0
2D80:  MOVLW  0A
2D82:  MOVLB  8
2D84:  MOVWF  x52
2D86:  MOVLB  0
2D88:  CALL   15C0
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2D8C:  MOVLB  8
2D8E:  MOVF   x31,F
2D90:  BNZ   2DA0
2D92:  MOVF   x30,F
2D94:  BNZ   2DA0
2D96:  MOVF   x2F,F
2D98:  BNZ   2DA0
2D9A:  MOVF   x2E,W
2D9C:  SUBLW  05
2D9E:  BC    2E12
2DA0:  MOVF   x31,F
2DA2:  BNZ   2E12
2DA4:  MOVF   x30,F
2DA6:  BNZ   2E12
2DA8:  MOVF   x2F,F
2DAA:  BNZ   2E12
2DAC:  MOVF   x2E,W
2DAE:  SUBLW  3B
2DB0:  BNC   2E12
2DB2:  MOVF   x35,F
2DB4:  BNZ   2DC4
2DB6:  MOVF   x34,F
2DB8:  BNZ   2DC4
2DBA:  MOVF   x33,F
2DBC:  BNZ   2DC4
2DBE:  MOVF   x32,W
2DC0:  SUBLW  64
2DC2:  BC    2E12
2DC4:  MOVF   x39,F
2DC6:  BNZ   2DD6
2DC8:  MOVF   x38,F
2DCA:  BNZ   2DD6
2DCC:  MOVF   x37,F
2DCE:  BNZ   2DD6
2DD0:  MOVF   x36,W
2DD2:  SUBLW  64
2DD4:  BC    2E12
2DD6:  MOVF   x3D,F
2DD8:  BNZ   2DE8
2DDA:  MOVF   x3C,F
2DDC:  BNZ   2DE8
2DDE:  MOVF   x3B,F
2DE0:  BNZ   2DE8
2DE2:  MOVF   x3A,W
2DE4:  SUBLW  64
2DE6:  BC    2E12
2DE8:  MOVF   x41,F
2DEA:  BNZ   2DFA
2DEC:  MOVF   x40,F
2DEE:  BNZ   2DFA
2DF0:  MOVF   x3F,F
2DF2:  BNZ   2DFA
2DF4:  MOVF   x3E,W
2DF6:  SUBLW  64
2DF8:  BC    2E12
2DFA:  MOVF   x45,F
2DFC:  BNZ   2E0C
2DFE:  MOVF   x44,F
2E00:  BNZ   2E0C
2E02:  MOVF   x43,F
2E04:  BNZ   2E0C
2E06:  MOVF   x42,W
2E08:  SUBLW  64
2E0A:  BC    2E12
2E0C:  MOVLW  00
2E0E:  MOVWF  01
2E10:  BRA    318A
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2E12:  MOVF   x35,F
2E14:  BNZ   2E24
2E16:  MOVF   x34,F
2E18:  BNZ   2E24
2E1A:  MOVF   x33,F
2E1C:  BNZ   2E24
2E1E:  MOVF   x32,W
2E20:  SUBLW  05
2E22:  BC    2E96
2E24:  MOVF   x35,F
2E26:  BNZ   2E96
2E28:  MOVF   x34,F
2E2A:  BNZ   2E96
2E2C:  MOVF   x33,F
2E2E:  BNZ   2E96
2E30:  MOVF   x32,W
2E32:  SUBLW  3B
2E34:  BNC   2E96
2E36:  MOVF   x31,F
2E38:  BNZ   2E48
2E3A:  MOVF   x30,F
2E3C:  BNZ   2E48
2E3E:  MOVF   x2F,F
2E40:  BNZ   2E48
2E42:  MOVF   x2E,W
2E44:  SUBLW  64
2E46:  BC    2E96
2E48:  MOVF   x39,F
2E4A:  BNZ   2E5A
2E4C:  MOVF   x38,F
2E4E:  BNZ   2E5A
2E50:  MOVF   x37,F
2E52:  BNZ   2E5A
2E54:  MOVF   x36,W
2E56:  SUBLW  64
2E58:  BC    2E96
2E5A:  MOVF   x3D,F
2E5C:  BNZ   2E6C
2E5E:  MOVF   x3C,F
2E60:  BNZ   2E6C
2E62:  MOVF   x3B,F
2E64:  BNZ   2E6C
2E66:  MOVF   x3A,W
2E68:  SUBLW  64
2E6A:  BC    2E96
2E6C:  MOVF   x41,F
2E6E:  BNZ   2E7E
2E70:  MOVF   x40,F
2E72:  BNZ   2E7E
2E74:  MOVF   x3F,F
2E76:  BNZ   2E7E
2E78:  MOVF   x3E,W
2E7A:  SUBLW  64
2E7C:  BC    2E96
2E7E:  MOVF   x45,F
2E80:  BNZ   2E90
2E82:  MOVF   x44,F
2E84:  BNZ   2E90
2E86:  MOVF   x43,F
2E88:  BNZ   2E90
2E8A:  MOVF   x42,W
2E8C:  SUBLW  64
2E8E:  BC    2E96
2E90:  MOVLW  01
2E92:  MOVWF  01
2E94:  BRA    318A
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2E96:  MOVF   x39,F
2E98:  BNZ   2EA8
2E9A:  MOVF   x38,F
2E9C:  BNZ   2EA8
2E9E:  MOVF   x37,F
2EA0:  BNZ   2EA8
2EA2:  MOVF   x36,W
2EA4:  SUBLW  05
2EA6:  BC    2F1A
2EA8:  MOVF   x39,F
2EAA:  BNZ   2F1A
2EAC:  MOVF   x38,F
2EAE:  BNZ   2F1A
2EB0:  MOVF   x37,F
2EB2:  BNZ   2F1A
2EB4:  MOVF   x36,W
2EB6:  SUBLW  3B
2EB8:  BNC   2F1A
2EBA:  MOVF   x35,F
2EBC:  BNZ   2ECC
2EBE:  MOVF   x34,F
2EC0:  BNZ   2ECC
2EC2:  MOVF   x33,F
2EC4:  BNZ   2ECC
2EC6:  MOVF   x32,W
2EC8:  SUBLW  64
2ECA:  BC    2F1A
2ECC:  MOVF   x31,F
2ECE:  BNZ   2EDE
2ED0:  MOVF   x30,F
2ED2:  BNZ   2EDE
2ED4:  MOVF   x2F,F
2ED6:  BNZ   2EDE
2ED8:  MOVF   x2E,W
2EDA:  SUBLW  64
2EDC:  BC    2F1A
2EDE:  MOVF   x3D,F
2EE0:  BNZ   2EF0
2EE2:  MOVF   x3C,F
2EE4:  BNZ   2EF0
2EE6:  MOVF   x3B,F
2EE8:  BNZ   2EF0
2EEA:  MOVF   x3A,W
2EEC:  SUBLW  64
2EEE:  BC    2F1A
2EF0:  MOVF   x41,F
2EF2:  BNZ   2F02
2EF4:  MOVF   x40,F
2EF6:  BNZ   2F02
2EF8:  MOVF   x3F,F
2EFA:  BNZ   2F02
2EFC:  MOVF   x3E,W
2EFE:  SUBLW  64
2F00:  BC    2F1A
2F02:  MOVF   x45,F
2F04:  BNZ   2F14
2F06:  MOVF   x44,F
2F08:  BNZ   2F14
2F0A:  MOVF   x43,F
2F0C:  BNZ   2F14
2F0E:  MOVF   x42,W
2F10:  SUBLW  64
2F12:  BC    2F1A
2F14:  MOVLW  02
2F16:  MOVWF  01
2F18:  BRA    318A
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2F1A:  MOVF   x3D,F
2F1C:  BNZ   2F2C
2F1E:  MOVF   x3C,F
2F20:  BNZ   2F2C
2F22:  MOVF   x3B,F
2F24:  BNZ   2F2C
2F26:  MOVF   x3A,W
2F28:  SUBLW  05
2F2A:  BC    2F9E
2F2C:  MOVF   x3D,F
2F2E:  BNZ   2F9E
2F30:  MOVF   x3C,F
2F32:  BNZ   2F9E
2F34:  MOVF   x3B,F
2F36:  BNZ   2F9E
2F38:  MOVF   x3A,W
2F3A:  SUBLW  3B
2F3C:  BNC   2F9E
2F3E:  MOVF   x35,F
2F40:  BNZ   2F50
2F42:  MOVF   x34,F
2F44:  BNZ   2F50
2F46:  MOVF   x33,F
2F48:  BNZ   2F50
2F4A:  MOVF   x32,W
2F4C:  SUBLW  64
2F4E:  BC    2F9E
2F50:  MOVF   x39,F
2F52:  BNZ   2F62
2F54:  MOVF   x38,F
2F56:  BNZ   2F62
2F58:  MOVF   x37,F
2F5A:  BNZ   2F62
2F5C:  MOVF   x36,W
2F5E:  SUBLW  64
2F60:  BC    2F9E
2F62:  MOVF   x31,F
2F64:  BNZ   2F74
2F66:  MOVF   x30,F
2F68:  BNZ   2F74
2F6A:  MOVF   x2F,F
2F6C:  BNZ   2F74
2F6E:  MOVF   x2E,W
2F70:  SUBLW  64
2F72:  BC    2F9E
2F74:  MOVF   x41,F
2F76:  BNZ   2F86
2F78:  MOVF   x40,F
2F7A:  BNZ   2F86
2F7C:  MOVF   x3F,F
2F7E:  BNZ   2F86
2F80:  MOVF   x3E,W
2F82:  SUBLW  64
2F84:  BC    2F9E
2F86:  MOVF   x45,F
2F88:  BNZ   2F98
2F8A:  MOVF   x44,F
2F8C:  BNZ   2F98
2F8E:  MOVF   x43,F
2F90:  BNZ   2F98
2F92:  MOVF   x42,W
2F94:  SUBLW  64
2F96:  BC    2F9E
2F98:  MOVLW  03
2F9A:  MOVWF  01
2F9C:  BRA    318A
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
2F9E:  MOVF   x41,F
2FA0:  BNZ   2FB0
2FA2:  MOVF   x40,F
2FA4:  BNZ   2FB0
2FA6:  MOVF   x3F,F
2FA8:  BNZ   2FB0
2FAA:  MOVF   x3E,W
2FAC:  SUBLW  05
2FAE:  BC    3022
2FB0:  MOVF   x41,F
2FB2:  BNZ   3022
2FB4:  MOVF   x40,F
2FB6:  BNZ   3022
2FB8:  MOVF   x3F,F
2FBA:  BNZ   3022
2FBC:  MOVF   x3E,W
2FBE:  SUBLW  3B
2FC0:  BNC   3022
2FC2:  MOVF   x35,F
2FC4:  BNZ   2FD4
2FC6:  MOVF   x34,F
2FC8:  BNZ   2FD4
2FCA:  MOVF   x33,F
2FCC:  BNZ   2FD4
2FCE:  MOVF   x32,W
2FD0:  SUBLW  64
2FD2:  BC    3022
2FD4:  MOVF   x39,F
2FD6:  BNZ   2FE6
2FD8:  MOVF   x38,F
2FDA:  BNZ   2FE6
2FDC:  MOVF   x37,F
2FDE:  BNZ   2FE6
2FE0:  MOVF   x36,W
2FE2:  SUBLW  64
2FE4:  BC    3022
2FE6:  MOVF   x3D,F
2FE8:  BNZ   2FF8
2FEA:  MOVF   x3C,F
2FEC:  BNZ   2FF8
2FEE:  MOVF   x3B,F
2FF0:  BNZ   2FF8
2FF2:  MOVF   x3A,W
2FF4:  SUBLW  64
2FF6:  BC    3022
2FF8:  MOVF   x31,F
2FFA:  BNZ   300A
2FFC:  MOVF   x30,F
2FFE:  BNZ   300A
3000:  MOVF   x2F,F
3002:  BNZ   300A
3004:  MOVF   x2E,W
3006:  SUBLW  64
3008:  BC    3022
300A:  MOVF   x45,F
300C:  BNZ   301C
300E:  MOVF   x44,F
3010:  BNZ   301C
3012:  MOVF   x43,F
3014:  BNZ   301C
3016:  MOVF   x42,W
3018:  SUBLW  64
301A:  BC    3022
301C:  MOVLW  04
301E:  MOVWF  01
3020:  BRA    318A
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
3022:  MOVF   x45,F
3024:  BNZ   3034
3026:  MOVF   x44,F
3028:  BNZ   3034
302A:  MOVF   x43,F
302C:  BNZ   3034
302E:  MOVF   x42,W
3030:  SUBLW  05
3032:  BC    30A6
3034:  MOVF   x45,F
3036:  BNZ   30A6
3038:  MOVF   x44,F
303A:  BNZ   30A6
303C:  MOVF   x43,F
303E:  BNZ   30A6
3040:  MOVF   x42,W
3042:  SUBLW  3B
3044:  BNC   30A6
3046:  MOVF   x35,F
3048:  BNZ   3058
304A:  MOVF   x34,F
304C:  BNZ   3058
304E:  MOVF   x33,F
3050:  BNZ   3058
3052:  MOVF   x32,W
3054:  SUBLW  64
3056:  BC    30A6
3058:  MOVF   x39,F
305A:  BNZ   306A
305C:  MOVF   x38,F
305E:  BNZ   306A
3060:  MOVF   x37,F
3062:  BNZ   306A
3064:  MOVF   x36,W
3066:  SUBLW  64
3068:  BC    30A6
306A:  MOVF   x3D,F
306C:  BNZ   307C
306E:  MOVF   x3C,F
3070:  BNZ   307C
3072:  MOVF   x3B,F
3074:  BNZ   307C
3076:  MOVF   x3A,W
3078:  SUBLW  64
307A:  BC    30A6
307C:  MOVF   x41,F
307E:  BNZ   308E
3080:  MOVF   x40,F
3082:  BNZ   308E
3084:  MOVF   x3F,F
3086:  BNZ   308E
3088:  MOVF   x3E,W
308A:  SUBLW  64
308C:  BC    30A6
308E:  MOVF   x31,F
3090:  BNZ   30A0
3092:  MOVF   x30,F
3094:  BNZ   30A0
3096:  MOVF   x2F,F
3098:  BNZ   30A0
309A:  MOVF   x2E,W
309C:  SUBLW  64
309E:  BC    30A6
30A0:  MOVLW  05
30A2:  MOVWF  01
30A4:  BRA    318A
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
30A6:  MOVF   x45,F
30A8:  BNZ   30BA
30AA:  MOVF   x44,F
30AC:  BNZ   30BA
30AE:  MOVF   x43,F
30B0:  BNZ   30BA
30B2:  MOVF   x42,W
30B4:  SUBLW  C8
30B6:  BTFSC  FD8.0
30B8:  BRA    3186
30BA:  MOVF   x31,F
30BC:  BTFSS  FD8.2
30BE:  BRA    3186
30C0:  MOVF   x30,F
30C2:  BTFSS  FD8.2
30C4:  BRA    3186
30C6:  MOVF   x2F,F
30C8:  BTFSS  FD8.2
30CA:  BRA    3186
30CC:  MOVF   x2E,W
30CE:  SUBLW  B3
30D0:  BTFSS  FD8.0
30D2:  BRA    3186
30D4:  MOVF   x31,F
30D6:  BNZ   30E8
30D8:  MOVF   x30,F
30DA:  BNZ   30E8
30DC:  MOVF   x2F,F
30DE:  BNZ   30E8
30E0:  MOVF   x2E,W
30E2:  SUBLW  64
30E4:  BTFSC  FD8.0
30E6:  BRA    3186
30E8:  MOVF   x35,F
30EA:  BTFSS  FD8.2
30EC:  BRA    3186
30EE:  MOVF   x34,F
30F0:  BTFSS  FD8.2
30F2:  BRA    3186
30F4:  MOVF   x33,F
30F6:  BTFSS  FD8.2
30F8:  BRA    3186
30FA:  MOVF   x32,W
30FC:  SUBLW  B3
30FE:  BNC   3186
3100:  MOVF   x35,F
3102:  BNZ   3112
3104:  MOVF   x34,F
3106:  BNZ   3112
3108:  MOVF   x33,F
310A:  BNZ   3112
310C:  MOVF   x32,W
310E:  SUBLW  64
3110:  BC    3186
3112:  MOVF   x39,F
3114:  BNZ   3186
3116:  MOVF   x38,F
3118:  BNZ   3186
311A:  MOVF   x37,F
311C:  BNZ   3186
311E:  MOVF   x36,W
3120:  SUBLW  B3
3122:  BNC   3186
3124:  MOVF   x39,F
3126:  BNZ   3136
3128:  MOVF   x38,F
312A:  BNZ   3136
312C:  MOVF   x37,F
312E:  BNZ   3136
3130:  MOVF   x36,W
3132:  SUBLW  64
3134:  BC    3186
3136:  MOVF   x3D,F
3138:  BNZ   3186
313A:  MOVF   x3C,F
313C:  BNZ   3186
313E:  MOVF   x3B,F
3140:  BNZ   3186
3142:  MOVF   x3A,W
3144:  SUBLW  B3
3146:  BNC   3186
3148:  MOVF   x3D,F
314A:  BNZ   315A
314C:  MOVF   x3C,F
314E:  BNZ   315A
3150:  MOVF   x3B,F
3152:  BNZ   315A
3154:  MOVF   x3A,W
3156:  SUBLW  64
3158:  BC    3186
315A:  MOVF   x41,F
315C:  BNZ   3186
315E:  MOVF   x40,F
3160:  BNZ   3186
3162:  MOVF   x3F,F
3164:  BNZ   3186
3166:  MOVF   x3E,W
3168:  SUBLW  B3
316A:  BNC   3186
316C:  MOVF   x41,F
316E:  BNZ   317E
3170:  MOVF   x40,F
3172:  BNZ   317E
3174:  MOVF   x3F,F
3176:  BNZ   317E
3178:  MOVF   x3E,W
317A:  SUBLW  64
317C:  BC    3186
317E:  MOVLW  05
3180:  MOVWF  01
3182:  BRA    318A
....................    else return 0xff; 
3184:  BRA    318A
3186:  MOVLW  FF
3188:  MOVWF  01
.................... } 
318A:  MOVLB  0
318C:  GOTO   31F2 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
3190:  MOVLW  20
3192:  MOVLB  8
3194:  MOVWF  x2A
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
3196:  BSF    F93.4
3198:  BTFSS  F81.4
319A:  BRA    31AE
319C:  BSF    F93.5
319E:  BTFSS  F81.5
31A0:  BRA    31AE
31A2:  BSF    F93.6
31A4:  BTFSS  F81.6
31A6:  BRA    31AE
31A8:  BSF    F93.7
31AA:  BTFSC  F81.7
31AC:  BRA    3314
....................     { 
....................        if(input(ROW0)==0) 
31AE:  BSF    F93.4
31B0:  BTFSC  F81.4
31B2:  BRA    31B8
....................          row=0; 
31B4:  CLRF   x2B
....................        else if(input(ROW1)==0) 
31B6:  BRA    31DA
31B8:  BSF    F93.5
31BA:  BTFSC  F81.5
31BC:  BRA    31C4
....................          row=1; 
31BE:  MOVLW  01
31C0:  MOVWF  x2B
....................        else if(input(ROW2)==0) 
31C2:  BRA    31DA
31C4:  BSF    F93.6
31C6:  BTFSC  F81.6
31C8:  BRA    31D0
....................          row=2; 
31CA:  MOVLW  02
31CC:  MOVWF  x2B
....................        else if(input(ROW3)==0) 
31CE:  BRA    31DA
31D0:  BSF    F93.7
31D2:  BTFSC  F81.7
31D4:  BRA    31DA
....................          row=3;      
31D6:  MOVLW  03
31D8:  MOVWF  x2B
....................        if(type_KB==0)col=check_col(); 
31DA:  MOVLB  1
31DC:  MOVF   x45,F
31DE:  BNZ   31EC
31E0:  MOVLB  0
31E2:  GOTO   2374
31E6:  MOVFF  01,829
....................          else col=new_check_col(); 
31EA:  BRA    31F6
31EC:  MOVLB  0
31EE:  GOTO   29A0
31F2:  MOVFF  01,829
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
31F6:  MOVLB  8
31F8:  INCFSZ x29,W
31FA:  BRA    31FE
31FC:  BRA    32E4
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
31FE:  MOVLB  1
3200:  MOVF   x45,F
3202:  BNZ   322A
3204:  MOVLB  8
3206:  MOVF   x2B,W
3208:  MULLW  05
320A:  MOVF   FF3,W
320C:  CLRF   x2D
320E:  MOVWF  x2C
3210:  CLRF   03
3212:  MOVF   x29,W
3214:  ADDWF  x2C,W
3216:  MOVWF  01
3218:  MOVF   x2D,W
321A:  ADDWFC 03,F
321C:  MOVF   01,W
321E:  MOVLB  0
3220:  CALL   030A
3224:  MOVFF  FE8,82A
....................            else kchar =newKEYS[row][col]; 
3228:  BRA    324E
322A:  MOVLB  8
322C:  MOVF   x2B,W
322E:  MULLW  06
3230:  MOVF   FF3,W
3232:  CLRF   x2D
3234:  MOVWF  x2C
3236:  CLRF   03
3238:  MOVF   x29,W
323A:  ADDWF  x2C,W
323C:  MOVWF  01
323E:  MOVF   x2D,W
3240:  ADDWFC 03,F
3242:  MOVF   01,W
3244:  MOVLB  0
3246:  CALL   032E
324A:  MOVFF  FE8,82A
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
324E:  MOVLB  1
3250:  MOVF   x40,F
3252:  BNZ   32D6
....................             { 
....................               charac_timeout=0; 
3254:  MOVLB  0
3256:  CLRF   xFC
3258:  CLRF   xFB
....................                if(key_count_ms<wideofkeystore) 
325A:  MOVLB  1
325C:  MOVF   x43,W
325E:  SUBLW  0F
3260:  BNC   32D4
....................                { 
....................                    key_data[key_count_ms++]=kchar; 
3262:  MOVF   x43,W
3264:  INCF   x43,F
3266:  CLRF   03
3268:  ADDLW  46
326A:  MOVWF  FE9
326C:  MOVLW  01
326E:  ADDWFC 03,W
3270:  MOVWF  FEA
3272:  MOVFF  82A,FEF
....................                    fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
3276:  MOVLW  56
3278:  MOVWF  FF6
327A:  MOVLW  05
327C:  MOVWF  FF7
327E:  MOVLW  09
3280:  MOVLB  8
3282:  MOVWF  x46
3284:  MOVLB  0
3286:  CALL   1606
328A:  MOVFF  143,832
328E:  MOVLW  18
3290:  MOVLB  8
3292:  MOVWF  x33
3294:  MOVLB  0
3296:  CALL   1736
329A:  MOVLW  5D
329C:  MOVLB  8
329E:  MOVWF  x52
32A0:  MOVLB  0
32A2:  CALL   15C0
32A6:  MOVLW  20
32A8:  MOVLB  8
32AA:  MOVWF  x52
32AC:  MOVLB  0
32AE:  CALL   15C0
32B2:  MOVFF  82A,852
32B6:  CALL   15C0
32BA:  MOVLW  0D
32BC:  MOVLB  8
32BE:  MOVWF  x52
32C0:  MOVLB  0
32C2:  CALL   15C0
32C6:  MOVLW  0A
32C8:  MOVLB  8
32CA:  MOVWF  x52
32CC:  MOVLB  0
32CE:  CALL   15C0
32D2:  MOVLB  1
....................                } 
....................             } 
....................                else fputc(kchar,COM2); 
32D4:  BRA    32E2
32D6:  MOVFF  82A,852
32DA:  MOVLB  0
32DC:  CALL   15C0
32E0:  MOVLB  1
32E2:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
32E4:  BSF    F93.4
32E6:  BTFSS  F81.4
32E8:  BRA    32E4
32EA:  BSF    F93.5
32EC:  BTFSS  F81.5
32EE:  BRA    32E4
32F0:  BSF    F93.6
32F2:  BTFSS  F81.6
32F4:  BRA    32E4
32F6:  BSF    F93.7
32F8:  BTFSS  F81.7
32FA:  BRA    32E4
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
32FC:  BSF    F93.4
32FE:  BTFSS  F81.4
3300:  BRA    32FC
3302:  BSF    F93.5
3304:  BTFSS  F81.5
3306:  BRA    32FC
3308:  BSF    F93.6
330A:  BTFSS  F81.6
330C:  BRA    32FC
330E:  BSF    F93.7
3310:  BTFSS  F81.7
3312:  BRA    32FC
....................     } 
....................   set_tris_a(0xff);     
3314:  MOVLW  FF
3316:  MOVWF  F92
....................   return(kchar); 
3318:  MOVFF  82A,01
.................... }//*/ 
331C:  MOVLB  0
331E:  RETURN 0
....................  
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int8 i,tempdata; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
3EB6:  MOVF   27,F
3EB8:  BTFSS  FD8.2
3EBA:  BRA    406A
3EBC:  MOVF   26,W
3EBE:  SUBLW  01
3EC0:  BTFSS  FD8.0
3EC2:  BRA    406A
3EC4:  BNZ   3ED8
3EC6:  MOVF   25,W
3EC8:  SUBLW  FF
3ECA:  BTFSS  FD8.0
3ECC:  BRA    406A
3ECE:  BNZ   3ED8
3ED0:  MOVF   24,W
3ED2:  SUBLW  FE
3ED4:  BTFSS  FD8.0
3ED6:  BRA    406A
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
3ED8:  MOVLB  1
3EDA:  MOVF   x46,F
3EDC:  BNZ   3EE4
3EDE:  MOVF   x43,F
3EE0:  BTFSC  FD8.2
3EE2:  BRA    4016
....................       { 
....................          temp=get_countcard(); 
3EE4:  MOVLB  0
3EE6:  CALL   34CC
3EEA:  MOVFF  02,82C
3EEE:  MOVFF  01,82B
....................          //fprintf(COM2," get_countcard=%lu\n\r",temp); 
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
3EF2:  MOVLB  8
3EF4:  RLCF   x2B,W
3EF6:  MOVWF  x2D
3EF8:  RLCF   x2C,W
3EFA:  MOVWF  x2E
3EFC:  RLCF   x2D,F
3EFE:  RLCF   x2E,F
3F00:  RLCF   x2D,F
3F02:  RLCF   x2E,F
3F04:  RLCF   x2D,F
3F06:  RLCF   x2E,F
3F08:  MOVLW  F0
3F0A:  ANDWF  x2D,F
3F0C:  MOVLW  0E
3F0E:  ADDWF  x2D,F
3F10:  MOVLW  C3
3F12:  ADDWFC x2E,F
3F14:  MOVLW  01
3F16:  MOVWF  x2F
3F18:  BCF    FD8.2
3F1A:  BTFSC  FD8.0
3F1C:  INCF   x2F,F
3F1E:  CLRF   x30
3F20:  MOVLW  01
3F22:  ADDWF  x2D,W
3F24:  MOVWF  00
3F26:  MOVLW  00
3F28:  ADDWFC x2E,W
3F2A:  MOVWF  01
3F2C:  MOVLW  00
3F2E:  ADDWFC x2F,W
3F30:  MOVWF  02
3F32:  MOVLW  00
3F34:  ADDWFC x30,W
3F36:  MOVWF  27
3F38:  MOVFF  02,26
3F3C:  MOVFF  01,25
3F40:  MOVFF  00,24
....................          //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<wideofkeystore;i++) 
3F44:  CLRF   x29
3F46:  MOVF   x29,W
3F48:  SUBLW  0F
3F4A:  BNC   3F8C
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
3F4C:  MOVF   x29,W
3F4E:  ADDWF  24,W
3F50:  MOVWF  00
3F52:  MOVLW  00
3F54:  ADDWFC 25,W
3F56:  MOVWF  01
3F58:  MOVLW  00
3F5A:  ADDWFC 26,W
3F5C:  MOVWF  02
3F5E:  MOVLW  00
3F60:  ADDWFC 27,W
3F62:  MOVWF  03
3F64:  MOVWF  x30
3F66:  MOVFF  02,82F
3F6A:  MOVFF  01,82E
3F6E:  MOVFF  00,82D
3F72:  MOVWF  x53
3F74:  MOVFF  02,852
3F78:  MOVFF  01,851
3F7C:  MOVFF  00,850
3F80:  CLRF   x54
3F82:  MOVLB  0
3F84:  RCALL  3934
....................          } 
3F86:  MOVLB  8
3F88:  INCF   x29,F
3F8A:  BRA    3F46
....................          for(i=0;i<wideofkeystore;i++) 
3F8C:  CLRF   x29
3F8E:  MOVF   x29,W
3F90:  SUBLW  0F
3F92:  BNC   3FFC
....................          { 
....................             tempdata=key_data[i]; 
3F94:  CLRF   03
3F96:  MOVF   x29,W
3F98:  ADDLW  46
3F9A:  MOVWF  FE9
3F9C:  MOVLW  01
3F9E:  ADDWFC 03,W
3FA0:  MOVWF  FEA
3FA2:  MOVFF  FEF,82A
....................             write_ext_eeprom((int32)ptr_card_key++,tempdata); 
3FA6:  MOVFF  27,03
3FAA:  MOVFF  26,02
3FAE:  MOVFF  25,01
3FB2:  MOVFF  24,00
3FB6:  MOVLW  01
3FB8:  ADDWF  24,F
3FBA:  BTFSC  FD8.0
3FBC:  INCF   25,F
3FBE:  BTFSC  FD8.2
3FC0:  INCF   26,F
3FC2:  BTFSC  FD8.2
3FC4:  INCF   27,F
3FC6:  MOVFF  03,830
3FCA:  MOVFF  02,82F
3FCE:  MOVFF  01,82E
3FD2:  MOVFF  00,82D
3FD6:  MOVFF  03,853
3FDA:  MOVFF  02,852
3FDE:  MOVFF  01,851
3FE2:  MOVFF  00,850
3FE6:  MOVFF  82A,854
3FEA:  MOVLB  0
3FEC:  RCALL  3934
....................             //delay_us(100); 
....................             fprintf(COM2,"%c",tempdata); 
3FEE:  MOVFF  82A,852
3FF2:  CALL   15C0
....................          } 
3FF6:  MOVLB  8
3FF8:  INCF   x29,F
3FFA:  BRA    3F8E
....................           //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................           /*fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<wideofkeystore;i++) 
....................           { 
....................             fprintf(COM2,"%c",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
3FFC:  MOVFF  27,840
4000:  MOVFF  26,83F
4004:  MOVFF  25,83E
4008:  MOVFF  24,83D
400C:  MOVLW  1E
400E:  MOVWF  x41
4010:  MOVLB  0
4012:  RCALL  3A32
4014:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
4016:  CLRF   x43
....................       memset(key_data,0,sizeof(key_data));  
4018:  MOVLW  01
401A:  MOVWF  FEA
401C:  MOVLW  46
401E:  MOVWF  FE9
4020:  CLRF   00
4022:  CLRF   02
4024:  MOVLW  10
4026:  MOVWF  01
4028:  MOVLB  0
402A:  CALL   3546
....................       fprintf(COM2,"\r\n"); 
402E:  MOVLW  0D
4030:  MOVLB  8
4032:  MOVWF  x52
4034:  MOVLB  0
4036:  CALL   15C0
403A:  MOVLW  0A
403C:  MOVLB  8
403E:  MOVWF  x52
4040:  MOVLB  0
4042:  CALL   15C0
....................       fprintf(COM2,"Done save_key_new"); 
4046:  MOVLW  68
4048:  MOVWF  FF6
404A:  MOVLW  05
404C:  MOVWF  FF7
404E:  CALL   16EA
....................       fprintf(COM2,"\r\n"); 
4052:  MOVLW  0D
4054:  MOVLB  8
4056:  MOVWF  x52
4058:  MOVLB  0
405A:  CALL   15C0
405E:  MOVLW  0A
4060:  MOVLB  8
4062:  MOVWF  x52
4064:  MOVLB  0
4066:  CALL   15C0
....................    } 
.................... } 
406A:  GOTO   52E2 (RETURN)
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 rec[wideofkeystore]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
4E20:  MOVF   27,F
4E22:  BTFSS  FD8.2
4E24:  BRA    504A
4E26:  MOVF   26,W
4E28:  SUBLW  01
4E2A:  BTFSS  FD8.0
4E2C:  BRA    504A
4E2E:  BNZ   4E42
4E30:  MOVF   25,W
4E32:  SUBLW  FF
4E34:  BTFSS  FD8.0
4E36:  BRA    504A
4E38:  BNZ   4E42
4E3A:  MOVF   24,W
4E3C:  SUBLW  FE
4E3E:  BTFSS  FD8.0
4E40:  BRA    504A
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
4E42:  MOVLB  1
4E44:  MOVF   x46,F
4E46:  BNZ   4E4E
4E48:  MOVF   x43,F
4E4A:  BTFSC  FD8.2
4E4C:  BRA    4FF6
....................       {    
....................          for(i=0;i<key_numbyte;i++) 
4E4E:  MOVLB  8
4E50:  CLRF   x29
4E52:  MOVF   x29,W
4E54:  SUBLW  0B
4E56:  BNC   4EAA
....................          { 
....................             temp=key_data[i]; 
4E58:  CLRF   03
4E5A:  MOVF   x29,W
4E5C:  ADDLW  46
4E5E:  MOVWF  FE9
4E60:  MOVLW  01
4E62:  ADDWFC 03,W
4E64:  MOVWF  FEA
4E66:  CLRF   x2B
4E68:  MOVFF  FEF,82A
....................             fputc(temp,COM2); 
4E6C:  MOVFF  82A,852
4E70:  MOVLB  0
4E72:  CALL   15C0
....................             rec[i]=key_data[i]; 
4E76:  CLRF   03
4E78:  MOVLB  8
4E7A:  MOVF   x29,W
4E7C:  ADDLW  2D
4E7E:  MOVWF  01
4E80:  MOVLW  08
4E82:  ADDWFC 03,F
4E84:  MOVFF  03,83E
4E88:  CLRF   03
4E8A:  MOVF   x29,W
4E8C:  ADDLW  46
4E8E:  MOVWF  FE9
4E90:  MOVLW  01
4E92:  ADDWFC 03,W
4E94:  MOVWF  FEA
4E96:  MOVFF  FEF,83F
4E9A:  MOVFF  83E,FEA
4E9E:  MOVFF  01,FE9
4EA2:  MOVFF  83F,FEF
....................          } 
4EA6:  INCF   x29,F
4EA8:  BRA    4E52
....................          rec[key_numbyte] = 0; 
4EAA:  CLRF   x39
....................          rec[key_numbyte+1] = 0;          
4EAC:  CLRF   x3A
....................          rec[key_numbyte+2] = 0;          
4EAE:  CLRF   x3B
....................          rec[key_numbyte+3] = 0; 
4EB0:  CLRF   x3C
....................     #if 0 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"test_key:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"\n\rdatain:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2," %x",rec[i]); 
....................          fprintf(COM2,"\n\r"); 
....................     #endif 
....................          aes_enc_dec((unsigned int8 *)&rec[0], (unsigned int8 *)&crypto_key[0],0); 
4EB2:  MOVLW  08
4EB4:  MOVWF  x3E
4EB6:  MOVLW  2D
4EB8:  MOVWF  x3D
4EBA:  CLRF   x40
4EBC:  MOVLW  FD
4EBE:  MOVWF  x3F
4EC0:  CLRF   x41
4EC2:  MOVLB  0
4EC4:  GOTO   40D0
....................          //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................           
....................          /* get the pointer of keyboard data */ 
....................          temp=get_countcard(); 
4EC8:  CALL   34CC
4ECC:  MOVFF  02,82B
4ED0:  MOVFF  01,82A
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
4ED4:  MOVLB  8
4ED6:  RLCF   x2A,W
4ED8:  MOVWF  x3D
4EDA:  RLCF   x2B,W
4EDC:  MOVWF  x3E
4EDE:  RLCF   x3D,F
4EE0:  RLCF   x3E,F
4EE2:  RLCF   x3D,F
4EE4:  RLCF   x3E,F
4EE6:  RLCF   x3D,F
4EE8:  RLCF   x3E,F
4EEA:  MOVLW  F0
4EEC:  ANDWF  x3D,F
4EEE:  MOVLW  0E
4EF0:  ADDWF  x3D,F
4EF2:  MOVLW  C3
4EF4:  ADDWFC x3E,F
4EF6:  MOVLW  01
4EF8:  MOVWF  x3F
4EFA:  BCF    FD8.2
4EFC:  BTFSC  FD8.0
4EFE:  INCF   x3F,F
4F00:  CLRF   x40
4F02:  MOVLW  01
4F04:  ADDWF  x3D,W
4F06:  MOVWF  00
4F08:  MOVLW  00
4F0A:  ADDWFC x3E,W
4F0C:  MOVWF  01
4F0E:  MOVLW  00
4F10:  ADDWFC x3F,W
4F12:  MOVWF  02
4F14:  MOVLW  00
4F16:  ADDWFC x40,W
4F18:  MOVWF  27
4F1A:  MOVFF  02,26
4F1E:  MOVFF  01,25
4F22:  MOVFF  00,24
....................          /* delete the old data of key store area  */ 
....................          for(i=0;i<wideofkeystore;i++) 
4F26:  CLRF   x29
4F28:  MOVF   x29,W
4F2A:  SUBLW  0F
4F2C:  BNC   4F70
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
4F2E:  MOVF   x29,W
4F30:  ADDWF  24,W
4F32:  MOVWF  00
4F34:  MOVLW  00
4F36:  ADDWFC 25,W
4F38:  MOVWF  01
4F3A:  MOVLW  00
4F3C:  ADDWFC 26,W
4F3E:  MOVWF  02
4F40:  MOVLW  00
4F42:  ADDWFC 27,W
4F44:  MOVWF  03
4F46:  MOVWF  x40
4F48:  MOVFF  02,83F
4F4C:  MOVFF  01,83E
4F50:  MOVFF  00,83D
4F54:  MOVWF  x53
4F56:  MOVFF  02,852
4F5A:  MOVFF  01,851
4F5E:  MOVFF  00,850
4F62:  CLRF   x54
4F64:  MOVLB  0
4F66:  CALL   3934
....................          } 
4F6A:  MOVLB  8
4F6C:  INCF   x29,F
4F6E:  BRA    4F28
....................           
....................          for(i=0;i<wideofkeystore;i++) fprintf(COM2,"%x",rec[i]); 
4F70:  CLRF   x29
4F72:  MOVF   x29,W
4F74:  SUBLW  0F
4F76:  BNC   4F9C
4F78:  CLRF   03
4F7A:  MOVF   x29,W
4F7C:  ADDLW  2D
4F7E:  MOVWF  FE9
4F80:  MOVLW  08
4F82:  ADDWFC 03,W
4F84:  MOVWF  FEA
4F86:  MOVFF  FEF,83D
4F8A:  MOVFF  83D,83E
4F8E:  MOVLW  57
4F90:  MOVWF  x3F
4F92:  MOVLB  0
4F94:  RCALL  4D46
4F96:  MOVLB  8
4F98:  INCF   x29,F
4F9A:  BRA    4F72
....................          retval = EEPROM_write(ptr_card_key,wideofkeystore,rec);  
4F9C:  MOVFF  27,840
4FA0:  MOVFF  26,83F
4FA4:  MOVFF  25,83E
4FA8:  MOVFF  24,83D
4FAC:  CLRF   x44
4FAE:  CLRF   x43
4FB0:  CLRF   x42
4FB2:  MOVLW  10
4FB4:  MOVWF  x41
4FB6:  MOVLW  08
4FB8:  MOVWF  x46
4FBA:  MOVLW  2D
4FBC:  MOVWF  x45
4FBE:  MOVLB  0
4FC0:  RCALL  4D90
4FC2:  MOVFF  01,82C
....................          if(retval!=0) 
4FC6:  MOVLB  8
4FC8:  MOVF   x2C,F
4FCA:  BZ    4FF4
....................          { 
....................             ptr_card_key+=wideofkeystore; 
4FCC:  MOVLW  10
4FCE:  ADDWF  24,F
4FD0:  MOVLW  00
4FD2:  ADDWFC 25,F
4FD4:  ADDWFC 26,F
4FD6:  ADDWFC 27,F
....................             save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
4FD8:  MOVFF  27,840
4FDC:  MOVFF  26,83F
4FE0:  MOVFF  25,83E
4FE4:  MOVFF  24,83D
4FE8:  MOVLW  1E
4FEA:  MOVWF  x41
4FEC:  MOVLB  0
4FEE:  CALL   3A32
4FF2:  MOVLB  8
4FF4:  MOVLB  1
....................          }          
....................       } 
....................       key_count_ms=0; 
4FF6:  CLRF   x43
....................       memset(key_data,0,sizeof(key_data));  
4FF8:  MOVLW  01
4FFA:  MOVWF  FEA
4FFC:  MOVLW  46
4FFE:  MOVWF  FE9
5000:  CLRF   00
5002:  CLRF   02
5004:  MOVLW  10
5006:  MOVWF  01
5008:  MOVLB  0
500A:  CALL   3546
....................       fprintf(COM2,"\r\n"); 
500E:  MOVLW  0D
5010:  MOVLB  8
5012:  MOVWF  x52
5014:  MOVLB  0
5016:  CALL   15C0
501A:  MOVLW  0A
501C:  MOVLB  8
501E:  MOVWF  x52
5020:  MOVLB  0
5022:  CALL   15C0
....................       fprintf(COM2,"Done Encrypted PIN"); 
5026:  MOVLW  7A
5028:  MOVWF  FF6
502A:  MOVLW  05
502C:  MOVWF  FF7
502E:  CALL   16EA
....................       fprintf(COM2,"\r\n"); 
5032:  MOVLW  0D
5034:  MOVLB  8
5036:  MOVWF  x52
5038:  MOVLB  0
503A:  CALL   15C0
503E:  MOVLW  0A
5040:  MOVLB  8
5042:  MOVWF  x52
5044:  MOVLB  0
5046:  CALL   15C0
....................    } 
.................... } 
504A:  GOTO   52EA (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
5792:  MOVLB  7
5794:  CLRF   xF8
5796:  CLRF   xF7
5798:  CLRF   xF9
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
579A:  MOVF   xF8,F
579C:  BTFSS  FD8.2
579E:  BRA    58C2
57A0:  MOVF   xF2,W
57A2:  SUBWF  xF7,W
57A4:  BTFSC  FD8.0
57A6:  BRA    58C2
57A8:  MOVF   xF9,F
57AA:  BTFSS  FD8.2
57AC:  BRA    58C2
....................       c = fgetc(COM2);//getc(); 
57AE:  MOVLB  0
57B0:  RCALL  5744
57B2:  MOVFF  01,7F5
....................       switch(c) 
....................       { 
57B6:  MOVLB  7
57B8:  MOVF   xF5,W
57BA:  XORLW  7F
57BC:  MOVLB  0
57BE:  BZ    57C6
57C0:  XORLW  72
57C2:  BZ    5814
57C4:  BRA    5852
....................          case 0x7f:    
....................             if(nbcar>0)   
57C6:  MOVLB  7
57C8:  MOVF   xF7,F
57CA:  BNZ   57D0
57CC:  MOVF   xF8,F
57CE:  BZ    57FA
57D0:  CLRF   19
57D2:  BTFSC  FF2.7
57D4:  BSF    19.7
57D6:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
57D8:  MOVLW  7F
57DA:  MOVLB  8
57DC:  MOVWF  x52
57DE:  MOVLB  0
57E0:  CALL   15C0
57E4:  BTFSC  19.7
57E6:  BSF    FF2.7
....................                nbcar--; 
57E8:  MOVLB  7
57EA:  MOVF   xF7,W
57EC:  BTFSC  FD8.2
57EE:  DECF   xF8,F
57F0:  DECF   xF7,F
....................                fgetc(COM2);//getc(); 
57F2:  MOVLB  0
57F4:  RCALL  5744
....................             } 
....................             else fputc(0x07,COM2);    
57F6:  BRA    5812
57F8:  MOVLB  7
57FA:  CLRF   19
57FC:  BTFSC  FF2.7
57FE:  BSF    19.7
5800:  BCF    FF2.7
5802:  MOVLW  07
5804:  MOVLB  8
5806:  MOVWF  x52
5808:  MOVLB  0
580A:  CALL   15C0
580E:  BTFSC  19.7
5810:  BSF    FF2.7
....................          break;  
5812:  BRA    58BE
....................          case 0x0D:   
....................                keydebug_en=0; 
5814:  MOVLB  1
5816:  CLRF   x40
....................                set_tris_a(0xff); 
5818:  MOVLW  FF
581A:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
581C:  MOVFF  7F7,7F6
5820:  MOVLB  7
5822:  MOVF   xF2,W
5824:  SUBWF  xF6,W
5826:  BC    583C
....................                { 
....................                  chaine[i]=0; 
5828:  CLRF   03
582A:  MOVF   xF6,W
582C:  ADDWF  xF3,W
582E:  MOVWF  FE9
5830:  MOVF   xF4,W
5832:  ADDWFC 03,W
5834:  MOVWF  FEA
5836:  CLRF   FEF
....................                } 
5838:  INCF   xF6,F
583A:  BRA    5822
....................                if(nbcar==0)return(FAUX); 
583C:  MOVF   xF7,F
583E:  BNZ   584A
5840:  MOVF   xF8,F
5842:  BNZ   584A
5844:  MOVLW  00
5846:  MOVWF  01
5848:  BRA    58C6
....................                fini=VRAI; 
584A:  MOVLW  01
584C:  MOVWF  xF9
....................          break; 
584E:  MOVLB  0
5850:  BRA    58BE
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
5852:  MOVLB  7
5854:  MOVF   xF5,W
5856:  SUBLW  1F
5858:  BC    58C0
585A:  MOVF   xF5,W
585C:  SUBLW  7E
585E:  BNC   58C0
5860:  MOVLW  01
5862:  SUBWF  xF2,W
5864:  MOVF   xF8,F
5866:  BNZ   58C0
5868:  SUBWF  xF7,W
586A:  BC    58C0
....................             { 
....................                chaine[nbcar]=c; 
586C:  MOVF   xF3,W
586E:  ADDWF  xF7,W
5870:  MOVWF  FE9
5872:  MOVF   xF4,W
5874:  ADDWFC xF8,W
5876:  MOVWF  FEA
5878:  MOVFF  7F5,FEF
....................                nbcar++; 
587C:  INCF   xF7,F
587E:  BTFSC  FD8.2
5880:  INCF   xF8,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
5882:  DECFSZ xF1,W
5884:  BRA    58A0
5886:  CLRF   19
5888:  BTFSC  FF2.7
588A:  BSF    19.7
588C:  BCF    FF2.7
588E:  MOVFF  7F5,852
5892:  MOVLB  0
5894:  CALL   15C0
5898:  BTFSC  19.7
589A:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
589C:  BRA    58BE
589E:  MOVLB  7
58A0:  MOVF   xF1,W
58A2:  SUBLW  02
58A4:  BNZ   58C0
58A6:  CLRF   19
58A8:  BTFSC  FF2.7
58AA:  BSF    19.7
58AC:  BCF    FF2.7
58AE:  MOVLW  2A
58B0:  MOVLB  8
58B2:  MOVWF  x52
58B4:  MOVLB  0
58B6:  CALL   15C0
58BA:  BTFSC  19.7
58BC:  BSF    FF2.7
58BE:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
58C0:  BRA    579A
....................    return(nbcar); 
58C2:  MOVFF  7F7,01
.................... } 
58C6:  MOVLB  0
58C8:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
58CA:  MOVFF  7F2,7F6
58CE:  MOVFF  7F1,7F5
58D2:  MOVFF  7F4,7F8
58D6:  MOVFF  7F3,7F7
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
58DA:  MOVFF  7F6,03
58DE:  MOVLB  7
58E0:  MOVFF  7F5,FE9
58E4:  MOVFF  7F6,FEA
58E8:  MOVF   FEF,F
58EA:  BZ    5932
58EC:  MOVFF  7F8,03
58F0:  MOVFF  7F7,FE9
58F4:  MOVFF  7F8,FEA
58F8:  MOVF   FEF,F
58FA:  BZ    5932
....................       if(*aa!=*bb) 
58FC:  MOVFF  7F5,FE9
5900:  MOVFF  7F6,FEA
5904:  MOVFF  FEF,7F9
5908:  MOVFF  7F8,03
590C:  MOVFF  7F7,FE9
5910:  MOVFF  7F8,FEA
5914:  MOVF   FEF,W
5916:  SUBWF  xF9,W
5918:  BZ    5920
....................          return(1); 
591A:  MOVLW  01
591C:  MOVWF  01
591E:  BRA    595E
....................       aa++; 
5920:  INCF   xF5,F
5922:  BTFSC  FD8.2
5924:  INCF   xF6,F
....................       bb++; 
5926:  INCF   xF7,F
5928:  BTFSC  FD8.2
592A:  INCF   xF8,F
....................    } 
592C:  MOVLB  0
592E:  BRA    58DA
5930:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
5932:  MOVFF  7F6,03
5936:  MOVFF  7F5,FE9
593A:  MOVFF  7F6,FEA
593E:  MOVFF  FEF,7F9
5942:  MOVFF  7F8,03
5946:  MOVFF  7F7,FE9
594A:  MOVFF  7F8,FEA
594E:  MOVF   FEF,W
5950:  SUBWF  xF9,W
5952:  BZ    595A
5954:  MOVLW  01
5956:  MOVWF  01
5958:  BRA    595E
....................    return(0); 
595A:  MOVLW  00
595C:  MOVWF  01
.................... } 
595E:  MOVLB  0
5960:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
5D90:  MOVLB  7
5D92:  CLRF   xF3
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
5D94:  MOVFF  7F2,03
5D98:  MOVF   xF1,W
5D9A:  INCF   xF1,F
5D9C:  BTFSC  FD8.2
5D9E:  INCF   xF2,F
5DA0:  MOVWF  FE9
5DA2:  MOVFF  03,FEA
5DA6:  MOVFF  FEF,7F5
5DAA:  MOVF   xF5,F
5DAC:  BZ    5DD0
....................         if (c >= '0' && c <= '9') 
5DAE:  MOVF   xF5,W
5DB0:  SUBLW  2F
5DB2:  BC    5DC2
5DB4:  MOVF   xF5,W
5DB6:  SUBLW  39
5DB8:  BNC   5DC2
....................             digit = (unsigned int) (c - '0'); 
5DBA:  MOVLW  30
5DBC:  SUBWF  xF5,W
5DBE:  MOVWF  xF4
....................         else 
5DC0:  BRA    5DC4
....................             break; 
5DC2:  BRA    5DD0
....................  
....................         val = (val * 10) + digit; 
5DC4:  MOVF   xF3,W
5DC6:  MULLW  0A
5DC8:  MOVF   FF3,W
5DCA:  ADDWF  xF4,W
5DCC:  MOVWF  xF3
....................     } 
5DCE:  BRA    5D94
....................  
....................     return val; 
5DD0:  CLRF   03
5DD2:  MOVFF  7F3,01
5DD6:  MOVFF  03,02
.................... } 
5DDA:  MOVLB  0
5DDC:  RETURN 0
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
0668:  MOVLB  8
066A:  CLRF   x62
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
066C:  CLRF   x63
066E:  BTFSC  x5A.0
0670:  BSF    x63.7
0672:  SWAPF  x5B,W
0674:  MOVWF  00
0676:  RLCF   00,F
0678:  RLCF   00,F
067A:  MOVLW  C0
067C:  ANDWF  00,F
067E:  MOVF   00,W
0680:  IORWF  x63,F
0682:  SWAPF  x5C,W
0684:  MOVWF  00
0686:  RLCF   00,F
0688:  MOVLW  E0
068A:  ANDWF  00,F
068C:  MOVF   00,W
068E:  IORWF  x63,F
0690:  SWAPF  x5D,W
0692:  MOVWF  00
0694:  MOVLW  F0
0696:  ANDWF  00,F
0698:  MOVF   00,W
069A:  IORWF  x63,F
069C:  RLCF   x5E,W
069E:  MOVWF  00
06A0:  RLCF   00,F
06A2:  RLCF   00,F
06A4:  MOVLW  F8
06A6:  ANDWF  00,F
06A8:  MOVF   00,W
06AA:  IORWF  x63,F
06AC:  RLCF   x5F,W
06AE:  MOVWF  00
06B0:  RLCF   00,F
06B2:  MOVLW  FC
06B4:  ANDWF  00,F
06B6:  MOVF   00,W
06B8:  IORWF  x63,F
06BA:  BCF    FD8.0
06BC:  RLCF   x60,W
06BE:  IORWF  x63,F
06C0:  MOVF   x61,W
06C2:  IORWF  x63,W
06C4:  MOVWF  x62
....................    return temp; 
06C6:  MOVFF  862,01
.................... } 
06CA:  MOVLB  0
06CC:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
06CE:  MOVLB  8
06D0:  CLRF   x4A
....................    int8 temp=0; 
....................    if(direct==0) 
06D2:  MOVF   x45,F
06D4:  BNZ   07AA
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
06D6:  MOVF   x48,W
06D8:  ADDWF  x46,W
06DA:  MOVWF  FE9
06DC:  MOVF   x49,W
06DE:  ADDWFC x47,W
06E0:  MOVWF  FEA
06E2:  MOVFF  FEF,84B
06E6:  MOVLW  01
06E8:  ADDWF  x46,W
06EA:  MOVWF  x4C
06EC:  MOVLW  00
06EE:  ADDWFC x47,W
06F0:  MOVWF  x4D
06F2:  MOVF   x48,W
06F4:  ADDWF  x4C,W
06F6:  MOVWF  FE9
06F8:  MOVF   x49,W
06FA:  ADDWFC x4D,W
06FC:  MOVWF  FEA
06FE:  MOVF   FEF,W
0700:  XORWF  x4B,F
0702:  MOVLW  02
0704:  ADDWF  x46,W
0706:  MOVWF  x4E
0708:  MOVLW  00
070A:  ADDWFC x47,W
070C:  MOVWF  x4F
070E:  MOVF   x48,W
0710:  ADDWF  x4E,W
0712:  MOVWF  FE9
0714:  MOVF   x49,W
0716:  ADDWFC x4F,W
0718:  MOVWF  FEA
071A:  MOVF   FEF,W
071C:  XORWF  x4B,F
071E:  MOVLW  03
0720:  ADDWF  x46,W
0722:  MOVWF  x50
0724:  MOVLW  00
0726:  ADDWFC x47,W
0728:  MOVWF  x51
072A:  MOVF   x48,W
072C:  ADDWF  x50,W
072E:  MOVWF  FE9
0730:  MOVF   x49,W
0732:  ADDWFC x51,W
0734:  MOVWF  FEA
0736:  MOVF   FEF,W
0738:  XORWF  x4B,F
073A:  MOVLW  04
073C:  ADDWF  x46,W
073E:  MOVWF  x52
0740:  MOVLW  00
0742:  ADDWFC x47,W
0744:  MOVWF  x53
0746:  MOVF   x48,W
0748:  ADDWF  x52,W
074A:  MOVWF  FE9
074C:  MOVF   x49,W
074E:  ADDWFC x53,W
0750:  MOVWF  FEA
0752:  MOVF   FEF,W
0754:  XORWF  x4B,F
0756:  MOVLW  05
0758:  ADDWF  x46,W
075A:  MOVWF  x54
075C:  MOVLW  00
075E:  ADDWFC x47,W
0760:  MOVWF  x55
0762:  MOVF   x48,W
0764:  ADDWF  x54,W
0766:  MOVWF  FE9
0768:  MOVF   x49,W
076A:  ADDWFC x55,W
076C:  MOVWF  FEA
076E:  MOVF   FEF,W
0770:  XORWF  x4B,W
0772:  BZ    0778
0774:  MOVLW  00
0776:  BRA    077A
0778:  MOVLW  01
077A:  MOVWF  x4A
....................       if(temp==datain[offset+6]) return 1; 
077C:  MOVLW  06
077E:  ADDWF  x46,W
0780:  MOVWF  x4B
0782:  MOVLW  00
0784:  ADDWFC x47,W
0786:  MOVWF  x4C
0788:  MOVF   x48,W
078A:  ADDWF  x4B,W
078C:  MOVWF  FE9
078E:  MOVF   x49,W
0790:  ADDWFC x4C,W
0792:  MOVWF  FEA
0794:  MOVF   FEF,W
0796:  SUBWF  x4A,W
0798:  BNZ   07A2
079A:  MOVLW  01
079C:  MOVWF  01
079E:  BRA    087A
....................          else return 0; 
07A0:  BRA    07A8
07A2:  MOVLW  00
07A4:  MOVWF  01
07A6:  BRA    087A
....................    } 
....................       else  
07A8:  BRA    087A
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
07AA:  MOVF   x48,W
07AC:  ADDWF  x46,W
07AE:  MOVWF  FE9
07B0:  MOVF   x49,W
07B2:  ADDWFC x47,W
07B4:  MOVWF  FEA
07B6:  MOVFF  FEF,84B
07BA:  MOVLW  01
07BC:  SUBWF  x46,W
07BE:  MOVWF  x4C
07C0:  MOVLW  00
07C2:  SUBWFB x47,W
07C4:  MOVWF  x4D
07C6:  MOVF   x48,W
07C8:  ADDWF  x4C,W
07CA:  MOVWF  FE9
07CC:  MOVF   x49,W
07CE:  ADDWFC x4D,W
07D0:  MOVWF  FEA
07D2:  MOVF   FEF,W
07D4:  XORWF  x4B,F
07D6:  MOVLW  02
07D8:  SUBWF  x46,W
07DA:  MOVWF  x4E
07DC:  MOVLW  00
07DE:  SUBWFB x47,W
07E0:  MOVWF  x4F
07E2:  MOVF   x48,W
07E4:  ADDWF  x4E,W
07E6:  MOVWF  FE9
07E8:  MOVF   x49,W
07EA:  ADDWFC x4F,W
07EC:  MOVWF  FEA
07EE:  MOVF   FEF,W
07F0:  XORWF  x4B,F
07F2:  MOVLW  03
07F4:  SUBWF  x46,W
07F6:  MOVWF  x50
07F8:  MOVLW  00
07FA:  SUBWFB x47,W
07FC:  MOVWF  x51
07FE:  MOVF   x48,W
0800:  ADDWF  x50,W
0802:  MOVWF  FE9
0804:  MOVF   x49,W
0806:  ADDWFC x51,W
0808:  MOVWF  FEA
080A:  MOVF   FEF,W
080C:  XORWF  x4B,F
080E:  MOVLW  04
0810:  SUBWF  x46,W
0812:  MOVWF  x52
0814:  MOVLW  00
0816:  SUBWFB x47,W
0818:  MOVWF  x53
081A:  MOVF   x48,W
081C:  ADDWF  x52,W
081E:  MOVWF  FE9
0820:  MOVF   x49,W
0822:  ADDWFC x53,W
0824:  MOVWF  FEA
0826:  MOVF   FEF,W
0828:  XORWF  x4B,F
082A:  MOVLW  05
082C:  SUBWF  x46,W
082E:  MOVWF  x54
0830:  MOVLW  00
0832:  SUBWFB x47,W
0834:  MOVWF  x55
0836:  MOVF   x48,W
0838:  ADDWF  x54,W
083A:  MOVWF  FE9
083C:  MOVF   x49,W
083E:  ADDWFC x55,W
0840:  MOVWF  FEA
0842:  MOVF   FEF,W
0844:  XORWF  x4B,W
0846:  BZ    084C
0848:  MOVLW  00
084A:  BRA    084E
084C:  MOVLW  01
084E:  MOVWF  x4A
....................          if(temp==datain[offset-6]) return 1; 
0850:  MOVLW  06
0852:  SUBWF  x46,W
0854:  MOVWF  x4B
0856:  MOVLW  00
0858:  SUBWFB x47,W
085A:  MOVWF  x4C
085C:  MOVF   x48,W
085E:  ADDWF  x4B,W
0860:  MOVWF  FE9
0862:  MOVF   x49,W
0864:  ADDWFC x4C,W
0866:  MOVWF  FEA
0868:  MOVF   FEF,W
086A:  SUBWF  x4A,W
086C:  BNZ   0876
086E:  MOVLW  01
0870:  MOVWF  01
0872:  BRA    087A
....................             else return 0;          
0874:  BRA    087A
0876:  MOVLW  00
0878:  MOVWF  01
....................       } 
.................... } 
087A:  MOVLB  0
087C:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
087E:  MOVLB  8
0880:  CLRF   x4A
....................    int8 temp=0; 
....................    if(direct==0) 
0882:  MOVF   x45,F
0884:  BNZ   0922
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
0886:  MOVF   x48,W
0888:  ADDWF  x46,W
088A:  MOVWF  FE9
088C:  MOVF   x49,W
088E:  ADDWFC x47,W
0890:  MOVWF  FEA
0892:  MOVFF  FEF,84B
0896:  MOVLW  01
0898:  ADDWF  x46,W
089A:  MOVWF  x4C
089C:  MOVLW  00
089E:  ADDWFC x47,W
08A0:  MOVWF  x4D
08A2:  MOVF   x48,W
08A4:  ADDWF  x4C,W
08A6:  MOVWF  FE9
08A8:  MOVF   x49,W
08AA:  ADDWFC x4D,W
08AC:  MOVWF  FEA
08AE:  MOVF   FEF,W
08B0:  XORWF  x4B,F
08B2:  MOVLW  02
08B4:  ADDWF  x46,W
08B6:  MOVWF  x4E
08B8:  MOVLW  00
08BA:  ADDWFC x47,W
08BC:  MOVWF  x4F
08BE:  MOVF   x48,W
08C0:  ADDWF  x4E,W
08C2:  MOVWF  FE9
08C4:  MOVF   x49,W
08C6:  ADDWFC x4F,W
08C8:  MOVWF  FEA
08CA:  MOVF   FEF,W
08CC:  XORWF  x4B,F
08CE:  MOVLW  03
08D0:  ADDWF  x46,W
08D2:  MOVWF  x50
08D4:  MOVLW  00
08D6:  ADDWFC x47,W
08D8:  MOVWF  x51
08DA:  MOVF   x48,W
08DC:  ADDWF  x50,W
08DE:  MOVWF  FE9
08E0:  MOVF   x49,W
08E2:  ADDWFC x51,W
08E4:  MOVWF  FEA
08E6:  MOVF   FEF,W
08E8:  XORWF  x4B,W
08EA:  BZ    08F0
08EC:  MOVLW  00
08EE:  BRA    08F2
08F0:  MOVLW  01
08F2:  MOVWF  x4A
....................       if(temp==datain[offset+4]) return 1; 
08F4:  MOVLW  04
08F6:  ADDWF  x46,W
08F8:  MOVWF  x4B
08FA:  MOVLW  00
08FC:  ADDWFC x47,W
08FE:  MOVWF  x4C
0900:  MOVF   x48,W
0902:  ADDWF  x4B,W
0904:  MOVWF  FE9
0906:  MOVF   x49,W
0908:  ADDWFC x4C,W
090A:  MOVWF  FEA
090C:  MOVF   FEF,W
090E:  SUBWF  x4A,W
0910:  BNZ   091A
0912:  MOVLW  01
0914:  MOVWF  01
0916:  BRA    09BA
....................          else return 0; 
0918:  BRA    0920
091A:  MOVLW  00
091C:  MOVWF  01
091E:  BRA    09BA
....................    } 
....................    else 
0920:  BRA    09BA
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0922:  MOVF   x48,W
0924:  ADDWF  x46,W
0926:  MOVWF  FE9
0928:  MOVF   x49,W
092A:  ADDWFC x47,W
092C:  MOVWF  FEA
092E:  MOVFF  FEF,84B
0932:  MOVLW  01
0934:  SUBWF  x46,W
0936:  MOVWF  x4C
0938:  MOVLW  00
093A:  SUBWFB x47,W
093C:  MOVWF  x4D
093E:  MOVF   x48,W
0940:  ADDWF  x4C,W
0942:  MOVWF  FE9
0944:  MOVF   x49,W
0946:  ADDWFC x4D,W
0948:  MOVWF  FEA
094A:  MOVF   FEF,W
094C:  XORWF  x4B,F
094E:  MOVLW  02
0950:  SUBWF  x46,W
0952:  MOVWF  x4E
0954:  MOVLW  00
0956:  SUBWFB x47,W
0958:  MOVWF  x4F
095A:  MOVF   x48,W
095C:  ADDWF  x4E,W
095E:  MOVWF  FE9
0960:  MOVF   x49,W
0962:  ADDWFC x4F,W
0964:  MOVWF  FEA
0966:  MOVF   FEF,W
0968:  XORWF  x4B,F
096A:  MOVLW  03
096C:  SUBWF  x46,W
096E:  MOVWF  x50
0970:  MOVLW  00
0972:  SUBWFB x47,W
0974:  MOVWF  x51
0976:  MOVF   x48,W
0978:  ADDWF  x50,W
097A:  MOVWF  FE9
097C:  MOVF   x49,W
097E:  ADDWFC x51,W
0980:  MOVWF  FEA
0982:  MOVF   FEF,W
0984:  XORWF  x4B,W
0986:  BZ    098C
0988:  MOVLW  00
098A:  BRA    098E
098C:  MOVLW  01
098E:  MOVWF  x4A
....................       if(temp==datain[offset-4]) return 1; 
0990:  MOVLW  04
0992:  SUBWF  x46,W
0994:  MOVWF  x4B
0996:  MOVLW  00
0998:  SUBWFB x47,W
099A:  MOVWF  x4C
099C:  MOVF   x48,W
099E:  ADDWF  x4B,W
09A0:  MOVWF  FE9
09A2:  MOVF   x49,W
09A4:  ADDWFC x4C,W
09A6:  MOVWF  FEA
09A8:  MOVF   FEF,W
09AA:  SUBWF  x4A,W
09AC:  BNZ   09B6
09AE:  MOVLW  01
09B0:  MOVWF  01
09B2:  BRA    09BA
....................          else return 0;                
09B4:  BRA    09BA
09B6:  MOVLW  00
09B8:  MOVWF  01
....................    } 
.................... } 
09BA:  MOVLB  0
09BC:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
09BE:  MOVLB  8
09C0:  CLRF   x41
09C2:  CLRF   x42
09C4:  CLRF   x43
09C6:  CLRF   x44
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
09C8:  CLRF   x3E
09CA:  CLRF   x3D
09CC:  RRCF   x3A,W
09CE:  MOVWF  03
09D0:  RRCF   x39,W
09D2:  MOVWF  02
09D4:  RRCF   03,F
09D6:  RRCF   02,F
09D8:  MOVLW  3F
09DA:  ANDWF  03,F
09DC:  MOVFF  02,01
09E0:  MOVF   x3E,W
09E2:  SUBWF  03,W
09E4:  BTFSS  FD8.0
09E6:  BRA    0FA6
09E8:  BNZ   09F2
09EA:  MOVF   01,W
09EC:  SUBWF  x3D,W
09EE:  BTFSC  FD8.0
09F0:  BRA    0FA6
....................    { 
....................       if(track==0) 
09F2:  MOVF   x38,F
09F4:  BTFSS  FD8.2
09F6:  BRA    0D2C
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
09F8:  MOVLW  06
09FA:  ADDWF  x3D,W
09FC:  MOVWF  x45
09FE:  MOVLW  00
0A00:  ADDWFC x3E,W
0A02:  MOVWF  x46
0A04:  MOVF   x3B,W
0A06:  ADDWF  x45,W
0A08:  MOVWF  FE9
0A0A:  MOVF   x3C,W
0A0C:  ADDWFC x46,W
0A0E:  MOVWF  FEA
0A10:  MOVFF  FEF,847
0A14:  MOVLW  05
0A16:  ADDWF  x3D,W
0A18:  MOVWF  x48
0A1A:  MOVLW  00
0A1C:  ADDWFC x3E,W
0A1E:  MOVWF  x49
0A20:  MOVF   x3B,W
0A22:  ADDWF  x48,W
0A24:  MOVWF  FE9
0A26:  MOVF   x3C,W
0A28:  ADDWFC x49,W
0A2A:  MOVWF  FEA
0A2C:  MOVFF  FEF,84A
0A30:  MOVLW  04
0A32:  ADDWF  x3D,W
0A34:  MOVWF  x4B
0A36:  MOVLW  00
0A38:  ADDWFC x3E,W
0A3A:  MOVWF  x4C
0A3C:  MOVF   x3B,W
0A3E:  ADDWF  x4B,W
0A40:  MOVWF  FE9
0A42:  MOVF   x3C,W
0A44:  ADDWFC x4C,W
0A46:  MOVWF  FEA
0A48:  MOVFF  FEF,84D
0A4C:  MOVLW  03
0A4E:  ADDWF  x3D,W
0A50:  MOVWF  x4E
0A52:  MOVLW  00
0A54:  ADDWFC x3E,W
0A56:  MOVWF  x4F
0A58:  MOVF   x3B,W
0A5A:  ADDWF  x4E,W
0A5C:  MOVWF  FE9
0A5E:  MOVF   x3C,W
0A60:  ADDWFC x4F,W
0A62:  MOVWF  FEA
0A64:  MOVFF  FEF,850
0A68:  MOVLW  02
0A6A:  ADDWF  x3D,W
0A6C:  MOVWF  x51
0A6E:  MOVLW  00
0A70:  ADDWFC x3E,W
0A72:  MOVWF  x52
0A74:  MOVF   x3B,W
0A76:  ADDWF  x51,W
0A78:  MOVWF  FE9
0A7A:  MOVF   x3C,W
0A7C:  ADDWFC x52,W
0A7E:  MOVWF  FEA
0A80:  MOVFF  FEF,853
0A84:  MOVLW  01
0A86:  ADDWF  x3D,W
0A88:  MOVWF  x54
0A8A:  MOVLW  00
0A8C:  ADDWFC x3E,W
0A8E:  MOVWF  x55
0A90:  MOVF   x3B,W
0A92:  ADDWF  x54,W
0A94:  MOVWF  FE9
0A96:  MOVF   x3C,W
0A98:  ADDWFC x55,W
0A9A:  MOVWF  FEA
0A9C:  MOVFF  FEF,856
0AA0:  MOVF   x3B,W
0AA2:  ADDWF  x3D,W
0AA4:  MOVWF  FE9
0AA6:  MOVF   x3C,W
0AA8:  ADDWFC x3E,W
0AAA:  MOVWF  FEA
0AAC:  MOVFF  FEF,857
0AB0:  CLRF   x5A
0AB2:  MOVFF  847,85B
0AB6:  MOVFF  84A,85C
0ABA:  MOVFF  84D,85D
0ABE:  MOVFF  850,85E
0AC2:  MOVFF  853,85F
0AC6:  MOVFF  856,860
0ACA:  MOVFF  857,861
0ACE:  MOVLB  0
0AD0:  RCALL  0668
0AD2:  MOVFF  01,841
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0AD6:  MOVLW  0D
0AD8:  MOVLB  8
0ADA:  ADDWF  x3D,W
0ADC:  MOVWF  x45
0ADE:  MOVLW  00
0AE0:  ADDWFC x3E,W
0AE2:  MOVWF  x46
0AE4:  MOVF   x3B,W
0AE6:  ADDWF  x45,W
0AE8:  MOVWF  FE9
0AEA:  MOVF   x3C,W
0AEC:  ADDWFC x46,W
0AEE:  MOVWF  FEA
0AF0:  MOVFF  FEF,847
0AF4:  MOVLW  0C
0AF6:  ADDWF  x3D,W
0AF8:  MOVWF  x48
0AFA:  MOVLW  00
0AFC:  ADDWFC x3E,W
0AFE:  MOVWF  x49
0B00:  MOVF   x3B,W
0B02:  ADDWF  x48,W
0B04:  MOVWF  FE9
0B06:  MOVF   x3C,W
0B08:  ADDWFC x49,W
0B0A:  MOVWF  FEA
0B0C:  MOVFF  FEF,84A
0B10:  MOVLW  0B
0B12:  ADDWF  x3D,W
0B14:  MOVWF  x4B
0B16:  MOVLW  00
0B18:  ADDWFC x3E,W
0B1A:  MOVWF  x4C
0B1C:  MOVF   x3B,W
0B1E:  ADDWF  x4B,W
0B20:  MOVWF  FE9
0B22:  MOVF   x3C,W
0B24:  ADDWFC x4C,W
0B26:  MOVWF  FEA
0B28:  MOVFF  FEF,84D
0B2C:  MOVLW  0A
0B2E:  ADDWF  x3D,W
0B30:  MOVWF  x4E
0B32:  MOVLW  00
0B34:  ADDWFC x3E,W
0B36:  MOVWF  x4F
0B38:  MOVF   x3B,W
0B3A:  ADDWF  x4E,W
0B3C:  MOVWF  FE9
0B3E:  MOVF   x3C,W
0B40:  ADDWFC x4F,W
0B42:  MOVWF  FEA
0B44:  MOVFF  FEF,850
0B48:  MOVLW  09
0B4A:  ADDWF  x3D,W
0B4C:  MOVWF  x51
0B4E:  MOVLW  00
0B50:  ADDWFC x3E,W
0B52:  MOVWF  x52
0B54:  MOVF   x3B,W
0B56:  ADDWF  x51,W
0B58:  MOVWF  FE9
0B5A:  MOVF   x3C,W
0B5C:  ADDWFC x52,W
0B5E:  MOVWF  FEA
0B60:  MOVFF  FEF,853
0B64:  MOVLW  08
0B66:  ADDWF  x3D,W
0B68:  MOVWF  x54
0B6A:  MOVLW  00
0B6C:  ADDWFC x3E,W
0B6E:  MOVWF  x55
0B70:  MOVF   x3B,W
0B72:  ADDWF  x54,W
0B74:  MOVWF  FE9
0B76:  MOVF   x3C,W
0B78:  ADDWFC x55,W
0B7A:  MOVWF  FEA
0B7C:  MOVFF  FEF,856
0B80:  MOVLW  07
0B82:  ADDWF  x3D,W
0B84:  MOVWF  x57
0B86:  MOVLW  00
0B88:  ADDWFC x3E,W
0B8A:  MOVWF  x58
0B8C:  MOVF   x3B,W
0B8E:  ADDWF  x57,W
0B90:  MOVWF  FE9
0B92:  MOVF   x3C,W
0B94:  ADDWFC x58,W
0B96:  MOVWF  FEA
0B98:  MOVFF  FEF,859
0B9C:  CLRF   x5A
0B9E:  MOVFF  847,85B
0BA2:  MOVFF  84A,85C
0BA6:  MOVFF  84D,85D
0BAA:  MOVFF  850,85E
0BAE:  MOVFF  853,85F
0BB2:  MOVFF  856,860
0BB6:  MOVFF  859,861
0BBA:  MOVLB  0
0BBC:  RCALL  0668
0BBE:  MOVFF  01,842
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0BC2:  MOVLB  8
0BC4:  MOVF   x41,W
0BC6:  SUBLW  45
0BC8:  BTFSS  FD8.2
0BCA:  BRA    0D2A
0BCC:  MOVF   x42,W
0BCE:  SUBLW  7C
0BD0:  BTFSC  FD8.2
0BD2:  BRA    0D2A
0BD4:  MOVF   x42,W
0BD6:  SUBLW  3E
0BD8:  BTFSC  FD8.2
0BDA:  BRA    0D2A
0BDC:  MOVF   x42,W
0BDE:  SUBLW  1F
0BE0:  BTFSC  FD8.2
0BE2:  BRA    0D2A
....................          { 
....................             j=i; 
0BE4:  MOVFF  83E,840
0BE8:  MOVFF  83D,83F
....................             CRC=1; 
0BEC:  MOVLW  01
0BEE:  MOVWF  x44
....................             temp2=temp; 
0BF0:  MOVFF  841,843
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0BF4:  MOVF   x43,W
0BF6:  SUBLW  1F
0BF8:  BTFSC  FD8.2
0BFA:  BRA    0D14
0BFC:  MOVF   x40,W
0BFE:  SUBLW  03
0C00:  BTFSS  FD8.0
0C02:  BRA    0D14
0C04:  BNZ   0C0E
0C06:  MOVF   x3F,W
0C08:  SUBLW  E7
0C0A:  BTFSS  FD8.0
0C0C:  BRA    0D14
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C0E:  CLRF   x45
0C10:  MOVFF  840,847
0C14:  MOVFF  83F,846
0C18:  MOVFF  83C,849
0C1C:  MOVFF  83B,848
0C20:  MOVLB  0
0C22:  RCALL  06CE
0C24:  MOVF   01,W
0C26:  MOVLB  8
0C28:  ANDWF  x44,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C2A:  MOVLW  06
0C2C:  ADDWF  x3F,W
0C2E:  MOVWF  x45
0C30:  MOVLW  00
0C32:  ADDWFC x40,W
0C34:  MOVWF  x46
0C36:  MOVF   x3B,W
0C38:  ADDWF  x45,W
0C3A:  MOVWF  FE9
0C3C:  MOVF   x3C,W
0C3E:  ADDWFC x46,W
0C40:  MOVWF  FEA
0C42:  MOVFF  FEF,847
0C46:  MOVLW  05
0C48:  ADDWF  x3F,W
0C4A:  MOVWF  x48
0C4C:  MOVLW  00
0C4E:  ADDWFC x40,W
0C50:  MOVWF  x49
0C52:  MOVF   x3B,W
0C54:  ADDWF  x48,W
0C56:  MOVWF  FE9
0C58:  MOVF   x3C,W
0C5A:  ADDWFC x49,W
0C5C:  MOVWF  FEA
0C5E:  MOVFF  FEF,84A
0C62:  MOVLW  04
0C64:  ADDWF  x3F,W
0C66:  MOVWF  x4B
0C68:  MOVLW  00
0C6A:  ADDWFC x40,W
0C6C:  MOVWF  x4C
0C6E:  MOVF   x3B,W
0C70:  ADDWF  x4B,W
0C72:  MOVWF  FE9
0C74:  MOVF   x3C,W
0C76:  ADDWFC x4C,W
0C78:  MOVWF  FEA
0C7A:  MOVFF  FEF,84D
0C7E:  MOVLW  03
0C80:  ADDWF  x3F,W
0C82:  MOVWF  x4E
0C84:  MOVLW  00
0C86:  ADDWFC x40,W
0C88:  MOVWF  x4F
0C8A:  MOVF   x3B,W
0C8C:  ADDWF  x4E,W
0C8E:  MOVWF  FE9
0C90:  MOVF   x3C,W
0C92:  ADDWFC x4F,W
0C94:  MOVWF  FEA
0C96:  MOVFF  FEF,850
0C9A:  MOVLW  02
0C9C:  ADDWF  x3F,W
0C9E:  MOVWF  x51
0CA0:  MOVLW  00
0CA2:  ADDWFC x40,W
0CA4:  MOVWF  x52
0CA6:  MOVF   x3B,W
0CA8:  ADDWF  x51,W
0CAA:  MOVWF  FE9
0CAC:  MOVF   x3C,W
0CAE:  ADDWFC x52,W
0CB0:  MOVWF  FEA
0CB2:  MOVFF  FEF,853
0CB6:  MOVLW  01
0CB8:  ADDWF  x3F,W
0CBA:  MOVWF  x54
0CBC:  MOVLW  00
0CBE:  ADDWFC x40,W
0CC0:  MOVWF  x55
0CC2:  MOVF   x3B,W
0CC4:  ADDWF  x54,W
0CC6:  MOVWF  FE9
0CC8:  MOVF   x3C,W
0CCA:  ADDWFC x55,W
0CCC:  MOVWF  FEA
0CCE:  MOVFF  FEF,856
0CD2:  MOVF   x3B,W
0CD4:  ADDWF  x3F,W
0CD6:  MOVWF  FE9
0CD8:  MOVF   x3C,W
0CDA:  ADDWFC x40,W
0CDC:  MOVWF  FEA
0CDE:  MOVFF  FEF,857
0CE2:  CLRF   x5A
0CE4:  MOVFF  847,85B
0CE8:  MOVFF  84A,85C
0CEC:  MOVFF  84D,85D
0CF0:  MOVFF  850,85E
0CF4:  MOVFF  853,85F
0CF8:  MOVFF  856,860
0CFC:  MOVFF  857,861
0D00:  MOVLB  0
0D02:  RCALL  0668
0D04:  MOVFF  01,843
....................                j=j+7; 
0D08:  MOVLW  07
0D0A:  MOVLB  8
0D0C:  ADDWF  x3F,F
0D0E:  MOVLW  00
0D10:  ADDWFC x40,F
....................             } 
0D12:  BRA    0BF4
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D14:  DECFSZ x44,W
0D16:  BRA    0D2A
....................             { 
....................                dir=0; 
0D18:  MOVLB  6
0D1A:  CLRF   xC4
....................                return i; 
0D1C:  MOVLB  8
0D1E:  MOVFF  83D,01
0D22:  MOVFF  83E,02
0D26:  GOTO   15BC
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0D2A:  BRA    0F9E
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0D2C:  MOVLW  04
0D2E:  ADDWF  x3D,W
0D30:  MOVWF  x45
0D32:  MOVLW  00
0D34:  ADDWFC x3E,W
0D36:  MOVWF  x46
0D38:  MOVF   x3B,W
0D3A:  ADDWF  x45,W
0D3C:  MOVWF  FE9
0D3E:  MOVF   x3C,W
0D40:  ADDWFC x46,W
0D42:  MOVWF  FEA
0D44:  MOVFF  FEF,847
0D48:  MOVLW  03
0D4A:  ADDWF  x3D,W
0D4C:  MOVWF  x48
0D4E:  MOVLW  00
0D50:  ADDWFC x3E,W
0D52:  MOVWF  x49
0D54:  MOVF   x3B,W
0D56:  ADDWF  x48,W
0D58:  MOVWF  FE9
0D5A:  MOVF   x3C,W
0D5C:  ADDWFC x49,W
0D5E:  MOVWF  FEA
0D60:  MOVFF  FEF,84A
0D64:  MOVLW  02
0D66:  ADDWF  x3D,W
0D68:  MOVWF  x4B
0D6A:  MOVLW  00
0D6C:  ADDWFC x3E,W
0D6E:  MOVWF  x4C
0D70:  MOVF   x3B,W
0D72:  ADDWF  x4B,W
0D74:  MOVWF  FE9
0D76:  MOVF   x3C,W
0D78:  ADDWFC x4C,W
0D7A:  MOVWF  FEA
0D7C:  MOVFF  FEF,84D
0D80:  MOVLW  01
0D82:  ADDWF  x3D,W
0D84:  MOVWF  x4E
0D86:  MOVLW  00
0D88:  ADDWFC x3E,W
0D8A:  MOVWF  x4F
0D8C:  MOVF   x3B,W
0D8E:  ADDWF  x4E,W
0D90:  MOVWF  FE9
0D92:  MOVF   x3C,W
0D94:  ADDWFC x4F,W
0D96:  MOVWF  FEA
0D98:  MOVFF  FEF,850
0D9C:  MOVF   x3B,W
0D9E:  ADDWF  x3D,W
0DA0:  MOVWF  FE9
0DA2:  MOVF   x3C,W
0DA4:  ADDWFC x3E,W
0DA6:  MOVWF  FEA
0DA8:  MOVFF  FEF,851
0DAC:  CLRF   x5A
0DAE:  CLRF   x5B
0DB0:  CLRF   x5C
0DB2:  MOVFF  847,85D
0DB6:  MOVFF  84A,85E
0DBA:  MOVFF  84D,85F
0DBE:  MOVFF  850,860
0DC2:  MOVFF  851,861
0DC6:  MOVLB  0
0DC8:  RCALL  0668
0DCA:  MOVFF  01,841
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0DCE:  MOVLW  09
0DD0:  MOVLB  8
0DD2:  ADDWF  x3D,W
0DD4:  MOVWF  x45
0DD6:  MOVLW  00
0DD8:  ADDWFC x3E,W
0DDA:  MOVWF  x46
0DDC:  MOVF   x3B,W
0DDE:  ADDWF  x45,W
0DE0:  MOVWF  FE9
0DE2:  MOVF   x3C,W
0DE4:  ADDWFC x46,W
0DE6:  MOVWF  FEA
0DE8:  MOVFF  FEF,847
0DEC:  MOVLW  08
0DEE:  ADDWF  x3D,W
0DF0:  MOVWF  x48
0DF2:  MOVLW  00
0DF4:  ADDWFC x3E,W
0DF6:  MOVWF  x49
0DF8:  MOVF   x3B,W
0DFA:  ADDWF  x48,W
0DFC:  MOVWF  FE9
0DFE:  MOVF   x3C,W
0E00:  ADDWFC x49,W
0E02:  MOVWF  FEA
0E04:  MOVFF  FEF,84A
0E08:  MOVLW  07
0E0A:  ADDWF  x3D,W
0E0C:  MOVWF  x4B
0E0E:  MOVLW  00
0E10:  ADDWFC x3E,W
0E12:  MOVWF  x4C
0E14:  MOVF   x3B,W
0E16:  ADDWF  x4B,W
0E18:  MOVWF  FE9
0E1A:  MOVF   x3C,W
0E1C:  ADDWFC x4C,W
0E1E:  MOVWF  FEA
0E20:  MOVFF  FEF,84D
0E24:  MOVLW  06
0E26:  ADDWF  x3D,W
0E28:  MOVWF  x4E
0E2A:  MOVLW  00
0E2C:  ADDWFC x3E,W
0E2E:  MOVWF  x4F
0E30:  MOVF   x3B,W
0E32:  ADDWF  x4E,W
0E34:  MOVWF  FE9
0E36:  MOVF   x3C,W
0E38:  ADDWFC x4F,W
0E3A:  MOVWF  FEA
0E3C:  MOVFF  FEF,850
0E40:  MOVLW  05
0E42:  ADDWF  x3D,W
0E44:  MOVWF  x51
0E46:  MOVLW  00
0E48:  ADDWFC x3E,W
0E4A:  MOVWF  x52
0E4C:  MOVF   x3B,W
0E4E:  ADDWF  x51,W
0E50:  MOVWF  FE9
0E52:  MOVF   x3C,W
0E54:  ADDWFC x52,W
0E56:  MOVWF  FEA
0E58:  MOVFF  FEF,853
0E5C:  CLRF   x5A
0E5E:  CLRF   x5B
0E60:  CLRF   x5C
0E62:  MOVFF  847,85D
0E66:  MOVFF  84A,85E
0E6A:  MOVFF  84D,85F
0E6E:  MOVFF  850,860
0E72:  MOVFF  853,861
0E76:  MOVLB  0
0E78:  CALL   0668
0E7C:  MOVFF  01,842
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0E80:  MOVLB  8
0E82:  MOVF   x41,W
0E84:  SUBLW  0B
0E86:  BTFSS  FD8.2
0E88:  BRA    0F9E
0E8A:  MOVF   x42,W
0E8C:  SUBLW  1F
0E8E:  BTFSC  FD8.2
0E90:  BRA    0F9E
0E92:  MOVF   x42,W
0E94:  SUBLW  0F
0E96:  BTFSC  FD8.2
0E98:  BRA    0F9E
....................             { 
....................                j=i; 
0E9A:  MOVFF  83E,840
0E9E:  MOVFF  83D,83F
....................                CRC=1; 
0EA2:  MOVLW  01
0EA4:  MOVWF  x44
....................                temp2=temp; 
0EA6:  MOVFF  841,843
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0EAA:  MOVF   x43,W
0EAC:  SUBLW  1F
0EAE:  BZ    0F8A
0EB0:  MOVF   x40,W
0EB2:  SUBLW  01
0EB4:  BNC   0F8A
0EB6:  BNZ   0EBE
0EB8:  MOVF   x3F,W
0EBA:  SUBLW  F3
0EBC:  BNC   0F8A
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0EBE:  CLRF   x45
0EC0:  MOVFF  840,847
0EC4:  MOVFF  83F,846
0EC8:  MOVFF  83C,849
0ECC:  MOVFF  83B,848
0ED0:  MOVLB  0
0ED2:  RCALL  087E
0ED4:  MOVF   01,W
0ED6:  MOVLB  8
0ED8:  ANDWF  x44,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0EDA:  MOVLW  04
0EDC:  ADDWF  x3F,W
0EDE:  MOVWF  x45
0EE0:  MOVLW  00
0EE2:  ADDWFC x40,W
0EE4:  MOVWF  x46
0EE6:  MOVF   x3B,W
0EE8:  ADDWF  x45,W
0EEA:  MOVWF  FE9
0EEC:  MOVF   x3C,W
0EEE:  ADDWFC x46,W
0EF0:  MOVWF  FEA
0EF2:  MOVFF  FEF,847
0EF6:  MOVLW  03
0EF8:  ADDWF  x3F,W
0EFA:  MOVWF  x48
0EFC:  MOVLW  00
0EFE:  ADDWFC x40,W
0F00:  MOVWF  x49
0F02:  MOVF   x3B,W
0F04:  ADDWF  x48,W
0F06:  MOVWF  FE9
0F08:  MOVF   x3C,W
0F0A:  ADDWFC x49,W
0F0C:  MOVWF  FEA
0F0E:  MOVFF  FEF,84A
0F12:  MOVLW  02
0F14:  ADDWF  x3F,W
0F16:  MOVWF  x4B
0F18:  MOVLW  00
0F1A:  ADDWFC x40,W
0F1C:  MOVWF  x4C
0F1E:  MOVF   x3B,W
0F20:  ADDWF  x4B,W
0F22:  MOVWF  FE9
0F24:  MOVF   x3C,W
0F26:  ADDWFC x4C,W
0F28:  MOVWF  FEA
0F2A:  MOVFF  FEF,84D
0F2E:  MOVLW  01
0F30:  ADDWF  x3F,W
0F32:  MOVWF  x4E
0F34:  MOVLW  00
0F36:  ADDWFC x40,W
0F38:  MOVWF  x4F
0F3A:  MOVF   x3B,W
0F3C:  ADDWF  x4E,W
0F3E:  MOVWF  FE9
0F40:  MOVF   x3C,W
0F42:  ADDWFC x4F,W
0F44:  MOVWF  FEA
0F46:  MOVFF  FEF,850
0F4A:  MOVF   x3B,W
0F4C:  ADDWF  x3F,W
0F4E:  MOVWF  FE9
0F50:  MOVF   x3C,W
0F52:  ADDWFC x40,W
0F54:  MOVWF  FEA
0F56:  MOVFF  FEF,851
0F5A:  CLRF   x5A
0F5C:  CLRF   x5B
0F5E:  CLRF   x5C
0F60:  MOVFF  847,85D
0F64:  MOVFF  84A,85E
0F68:  MOVFF  84D,85F
0F6C:  MOVFF  850,860
0F70:  MOVFF  851,861
0F74:  MOVLB  0
0F76:  CALL   0668
0F7A:  MOVFF  01,843
....................                   j=j+5; 
0F7E:  MOVLW  05
0F80:  MOVLB  8
0F82:  ADDWF  x3F,F
0F84:  MOVLW  00
0F86:  ADDWFC x40,F
....................                } 
0F88:  BRA    0EAA
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0F8A:  DECFSZ x44,W
0F8C:  BRA    0F9E
....................                { 
....................                   dir=0; 
0F8E:  MOVLB  6
0F90:  CLRF   xC4
....................                   return i; 
0F92:  MOVLB  8
0F94:  MOVFF  83D,01
0F98:  MOVFF  83E,02
0F9C:  BRA    15BC
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0F9E:  INCF   x3D,F
0FA0:  BTFSC  FD8.2
0FA2:  INCF   x3E,F
0FA4:  BRA    09CC
....................    for(i=end_point;i>end_point/4;i--) 
0FA6:  MOVFF  83A,83E
0FAA:  MOVFF  839,83D
0FAE:  RRCF   x3A,W
0FB0:  MOVWF  03
0FB2:  RRCF   x39,W
0FB4:  MOVWF  02
0FB6:  RRCF   03,F
0FB8:  RRCF   02,F
0FBA:  MOVLW  3F
0FBC:  ANDWF  03,F
0FBE:  MOVFF  02,01
0FC2:  MOVF   03,W
0FC4:  SUBWF  x3E,W
0FC6:  BTFSS  FD8.0
0FC8:  BRA    15B6
0FCA:  BNZ   0FD4
0FCC:  MOVF   x3D,W
0FCE:  SUBWF  01,W
0FD0:  BTFSC  FD8.0
0FD2:  BRA    15B6
....................    { 
....................       if(track==0) 
0FD4:  MOVF   x38,F
0FD6:  BTFSS  FD8.2
0FD8:  BRA    132C
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
0FDA:  MOVLW  06
0FDC:  SUBWF  x3D,W
0FDE:  MOVWF  x45
0FE0:  MOVLW  00
0FE2:  SUBWFB x3E,W
0FE4:  MOVWF  x46
0FE6:  MOVF   x3B,W
0FE8:  ADDWF  x45,W
0FEA:  MOVWF  FE9
0FEC:  MOVF   x3C,W
0FEE:  ADDWFC x46,W
0FF0:  MOVWF  FEA
0FF2:  MOVFF  FEF,847
0FF6:  MOVLW  05
0FF8:  SUBWF  x3D,W
0FFA:  MOVWF  x48
0FFC:  MOVLW  00
0FFE:  SUBWFB x3E,W
1000:  MOVWF  x49
1002:  MOVF   x3B,W
1004:  ADDWF  x48,W
1006:  MOVWF  FE9
1008:  MOVF   x3C,W
100A:  ADDWFC x49,W
100C:  MOVWF  FEA
100E:  MOVFF  FEF,84A
1012:  MOVLW  04
1014:  SUBWF  x3D,W
1016:  MOVWF  x4B
1018:  MOVLW  00
101A:  SUBWFB x3E,W
101C:  MOVWF  x4C
101E:  MOVF   x3B,W
1020:  ADDWF  x4B,W
1022:  MOVWF  FE9
1024:  MOVF   x3C,W
1026:  ADDWFC x4C,W
1028:  MOVWF  FEA
102A:  MOVFF  FEF,84D
102E:  MOVLW  03
1030:  SUBWF  x3D,W
1032:  MOVWF  x4E
1034:  MOVLW  00
1036:  SUBWFB x3E,W
1038:  MOVWF  x4F
103A:  MOVF   x3B,W
103C:  ADDWF  x4E,W
103E:  MOVWF  FE9
1040:  MOVF   x3C,W
1042:  ADDWFC x4F,W
1044:  MOVWF  FEA
1046:  MOVFF  FEF,850
104A:  MOVLW  02
104C:  SUBWF  x3D,W
104E:  MOVWF  x51
1050:  MOVLW  00
1052:  SUBWFB x3E,W
1054:  MOVWF  x52
1056:  MOVF   x3B,W
1058:  ADDWF  x51,W
105A:  MOVWF  FE9
105C:  MOVF   x3C,W
105E:  ADDWFC x52,W
1060:  MOVWF  FEA
1062:  MOVFF  FEF,853
1066:  MOVLW  01
1068:  SUBWF  x3D,W
106A:  MOVWF  x54
106C:  MOVLW  00
106E:  SUBWFB x3E,W
1070:  MOVWF  x55
1072:  MOVF   x3B,W
1074:  ADDWF  x54,W
1076:  MOVWF  FE9
1078:  MOVF   x3C,W
107A:  ADDWFC x55,W
107C:  MOVWF  FEA
107E:  MOVFF  FEF,856
1082:  MOVF   x3B,W
1084:  ADDWF  x3D,W
1086:  MOVWF  FE9
1088:  MOVF   x3C,W
108A:  ADDWFC x3E,W
108C:  MOVWF  FEA
108E:  MOVFF  FEF,857
1092:  CLRF   x5A
1094:  MOVFF  847,85B
1098:  MOVFF  84A,85C
109C:  MOVFF  84D,85D
10A0:  MOVFF  850,85E
10A4:  MOVFF  853,85F
10A8:  MOVFF  856,860
10AC:  MOVFF  857,861
10B0:  MOVLB  0
10B2:  CALL   0668
10B6:  MOVFF  01,841
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
10BA:  MOVLW  0D
10BC:  MOVLB  8
10BE:  SUBWF  x3D,W
10C0:  MOVWF  x45
10C2:  MOVLW  00
10C4:  SUBWFB x3E,W
10C6:  MOVWF  x46
10C8:  MOVF   x3B,W
10CA:  ADDWF  x45,W
10CC:  MOVWF  FE9
10CE:  MOVF   x3C,W
10D0:  ADDWFC x46,W
10D2:  MOVWF  FEA
10D4:  MOVFF  FEF,847
10D8:  MOVLW  0C
10DA:  SUBWF  x3D,W
10DC:  MOVWF  x48
10DE:  MOVLW  00
10E0:  SUBWFB x3E,W
10E2:  MOVWF  x49
10E4:  MOVF   x3B,W
10E6:  ADDWF  x48,W
10E8:  MOVWF  FE9
10EA:  MOVF   x3C,W
10EC:  ADDWFC x49,W
10EE:  MOVWF  FEA
10F0:  MOVFF  FEF,84A
10F4:  MOVLW  0B
10F6:  SUBWF  x3D,W
10F8:  MOVWF  x4B
10FA:  MOVLW  00
10FC:  SUBWFB x3E,W
10FE:  MOVWF  x4C
1100:  MOVF   x3B,W
1102:  ADDWF  x4B,W
1104:  MOVWF  FE9
1106:  MOVF   x3C,W
1108:  ADDWFC x4C,W
110A:  MOVWF  FEA
110C:  MOVFF  FEF,84D
1110:  MOVLW  0A
1112:  SUBWF  x3D,W
1114:  MOVWF  x4E
1116:  MOVLW  00
1118:  SUBWFB x3E,W
111A:  MOVWF  x4F
111C:  MOVF   x3B,W
111E:  ADDWF  x4E,W
1120:  MOVWF  FE9
1122:  MOVF   x3C,W
1124:  ADDWFC x4F,W
1126:  MOVWF  FEA
1128:  MOVFF  FEF,850
112C:  MOVLW  09
112E:  SUBWF  x3D,W
1130:  MOVWF  x51
1132:  MOVLW  00
1134:  SUBWFB x3E,W
1136:  MOVWF  x52
1138:  MOVF   x3B,W
113A:  ADDWF  x51,W
113C:  MOVWF  FE9
113E:  MOVF   x3C,W
1140:  ADDWFC x52,W
1142:  MOVWF  FEA
1144:  MOVFF  FEF,853
1148:  MOVLW  08
114A:  SUBWF  x3D,W
114C:  MOVWF  x54
114E:  MOVLW  00
1150:  SUBWFB x3E,W
1152:  MOVWF  x55
1154:  MOVF   x3B,W
1156:  ADDWF  x54,W
1158:  MOVWF  FE9
115A:  MOVF   x3C,W
115C:  ADDWFC x55,W
115E:  MOVWF  FEA
1160:  MOVFF  FEF,856
1164:  MOVLW  07
1166:  SUBWF  x3D,W
1168:  MOVWF  x57
116A:  MOVLW  00
116C:  SUBWFB x3E,W
116E:  MOVWF  x58
1170:  MOVF   x3B,W
1172:  ADDWF  x57,W
1174:  MOVWF  FE9
1176:  MOVF   x3C,W
1178:  ADDWFC x58,W
117A:  MOVWF  FEA
117C:  MOVFF  FEF,859
1180:  CLRF   x5A
1182:  MOVFF  847,85B
1186:  MOVFF  84A,85C
118A:  MOVFF  84D,85D
118E:  MOVFF  850,85E
1192:  MOVFF  853,85F
1196:  MOVFF  856,860
119A:  MOVFF  859,861
119E:  MOVLB  0
11A0:  CALL   0668
11A4:  MOVFF  01,842
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
11A8:  MOVLB  8
11AA:  MOVF   x41,W
11AC:  SUBLW  45
11AE:  BTFSS  FD8.2
11B0:  BRA    132A
11B2:  MOVF   x42,W
11B4:  SUBLW  7C
11B6:  BTFSC  FD8.2
11B8:  BRA    132A
11BA:  MOVF   x42,W
11BC:  SUBLW  3E
11BE:  BTFSC  FD8.2
11C0:  BRA    132A
11C2:  MOVF   x42,W
11C4:  SUBLW  1F
11C6:  BTFSC  FD8.2
11C8:  BRA    132A
11CA:  MOVF   x42,W
11CC:  SUBLW  0F
11CE:  BTFSC  FD8.2
11D0:  BRA    132A
11D2:  MOVF   x42,W
11D4:  SUBLW  78
11D6:  BTFSC  FD8.2
11D8:  BRA    132A
....................          { 
....................             j=i; 
11DA:  MOVFF  83E,840
11DE:  MOVFF  83D,83F
....................             CRC=1; 
11E2:  MOVLW  01
11E4:  MOVWF  x44
....................             temp2=temp; 
11E6:  MOVFF  841,843
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
11EA:  MOVF   x43,W
11EC:  SUBLW  1F
11EE:  BTFSC  FD8.2
11F0:  BRA    130A
11F2:  MOVF   x40,F
11F4:  BNZ   11FE
11F6:  MOVF   x3F,W
11F8:  SUBLW  01
11FA:  BTFSC  FD8.0
11FC:  BRA    130A
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
11FE:  MOVLW  01
1200:  MOVWF  x45
1202:  MOVFF  840,847
1206:  MOVFF  83F,846
120A:  MOVFF  83C,849
120E:  MOVFF  83B,848
1212:  MOVLB  0
1214:  CALL   06CE
1218:  MOVF   01,W
121A:  MOVLB  8
121C:  ANDWF  x44,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
121E:  MOVLW  06
1220:  SUBWF  x3F,W
1222:  MOVWF  x45
1224:  MOVLW  00
1226:  SUBWFB x40,W
1228:  MOVWF  x46
122A:  MOVF   x3B,W
122C:  ADDWF  x45,W
122E:  MOVWF  FE9
1230:  MOVF   x3C,W
1232:  ADDWFC x46,W
1234:  MOVWF  FEA
1236:  MOVFF  FEF,847
123A:  MOVLW  05
123C:  SUBWF  x3F,W
123E:  MOVWF  x48
1240:  MOVLW  00
1242:  SUBWFB x40,W
1244:  MOVWF  x49
1246:  MOVF   x3B,W
1248:  ADDWF  x48,W
124A:  MOVWF  FE9
124C:  MOVF   x3C,W
124E:  ADDWFC x49,W
1250:  MOVWF  FEA
1252:  MOVFF  FEF,84A
1256:  MOVLW  04
1258:  SUBWF  x3F,W
125A:  MOVWF  x4B
125C:  MOVLW  00
125E:  SUBWFB x40,W
1260:  MOVWF  x4C
1262:  MOVF   x3B,W
1264:  ADDWF  x4B,W
1266:  MOVWF  FE9
1268:  MOVF   x3C,W
126A:  ADDWFC x4C,W
126C:  MOVWF  FEA
126E:  MOVFF  FEF,84D
1272:  MOVLW  03
1274:  SUBWF  x3F,W
1276:  MOVWF  x4E
1278:  MOVLW  00
127A:  SUBWFB x40,W
127C:  MOVWF  x4F
127E:  MOVF   x3B,W
1280:  ADDWF  x4E,W
1282:  MOVWF  FE9
1284:  MOVF   x3C,W
1286:  ADDWFC x4F,W
1288:  MOVWF  FEA
128A:  MOVFF  FEF,850
128E:  MOVLW  02
1290:  SUBWF  x3F,W
1292:  MOVWF  x51
1294:  MOVLW  00
1296:  SUBWFB x40,W
1298:  MOVWF  x52
129A:  MOVF   x3B,W
129C:  ADDWF  x51,W
129E:  MOVWF  FE9
12A0:  MOVF   x3C,W
12A2:  ADDWFC x52,W
12A4:  MOVWF  FEA
12A6:  MOVFF  FEF,853
12AA:  MOVLW  01
12AC:  SUBWF  x3F,W
12AE:  MOVWF  x54
12B0:  MOVLW  00
12B2:  SUBWFB x40,W
12B4:  MOVWF  x55
12B6:  MOVF   x3B,W
12B8:  ADDWF  x54,W
12BA:  MOVWF  FE9
12BC:  MOVF   x3C,W
12BE:  ADDWFC x55,W
12C0:  MOVWF  FEA
12C2:  MOVFF  FEF,856
12C6:  MOVF   x3B,W
12C8:  ADDWF  x3F,W
12CA:  MOVWF  FE9
12CC:  MOVF   x3C,W
12CE:  ADDWFC x40,W
12D0:  MOVWF  FEA
12D2:  MOVFF  FEF,857
12D6:  CLRF   x5A
12D8:  MOVFF  847,85B
12DC:  MOVFF  84A,85C
12E0:  MOVFF  84D,85D
12E4:  MOVFF  850,85E
12E8:  MOVFF  853,85F
12EC:  MOVFF  856,860
12F0:  MOVFF  857,861
12F4:  MOVLB  0
12F6:  CALL   0668
12FA:  MOVFF  01,843
....................                j=j-7;             
12FE:  MOVLW  07
1300:  MOVLB  8
1302:  SUBWF  x3F,F
1304:  MOVLW  00
1306:  SUBWFB x40,F
....................              } 
1308:  BRA    11EA
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
130A:  DECFSZ x44,W
130C:  BRA    1322
....................             { 
....................                dir=1; 
130E:  MOVLW  01
1310:  MOVLB  6
1312:  MOVWF  xC4
....................                return i; 
1314:  MOVLB  8
1316:  MOVFF  83D,01
131A:  MOVFF  83E,02
131E:  BRA    15BC
....................             } 
....................             else return 0; 
1320:  BRA    132A
1322:  MOVLW  00
1324:  MOVWF  01
1326:  MOVWF  02
1328:  BRA    15BC
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
132A:  BRA    15AC
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
132C:  MOVLW  04
132E:  SUBWF  x3D,W
1330:  MOVWF  x45
1332:  MOVLW  00
1334:  SUBWFB x3E,W
1336:  MOVWF  x46
1338:  MOVF   x3B,W
133A:  ADDWF  x45,W
133C:  MOVWF  FE9
133E:  MOVF   x3C,W
1340:  ADDWFC x46,W
1342:  MOVWF  FEA
1344:  MOVFF  FEF,847
1348:  MOVLW  03
134A:  SUBWF  x3D,W
134C:  MOVWF  x48
134E:  MOVLW  00
1350:  SUBWFB x3E,W
1352:  MOVWF  x49
1354:  MOVF   x3B,W
1356:  ADDWF  x48,W
1358:  MOVWF  FE9
135A:  MOVF   x3C,W
135C:  ADDWFC x49,W
135E:  MOVWF  FEA
1360:  MOVFF  FEF,84A
1364:  MOVLW  02
1366:  SUBWF  x3D,W
1368:  MOVWF  x4B
136A:  MOVLW  00
136C:  SUBWFB x3E,W
136E:  MOVWF  x4C
1370:  MOVF   x3B,W
1372:  ADDWF  x4B,W
1374:  MOVWF  FE9
1376:  MOVF   x3C,W
1378:  ADDWFC x4C,W
137A:  MOVWF  FEA
137C:  MOVFF  FEF,84D
1380:  MOVLW  01
1382:  SUBWF  x3D,W
1384:  MOVWF  x4E
1386:  MOVLW  00
1388:  SUBWFB x3E,W
138A:  MOVWF  x4F
138C:  MOVF   x3B,W
138E:  ADDWF  x4E,W
1390:  MOVWF  FE9
1392:  MOVF   x3C,W
1394:  ADDWFC x4F,W
1396:  MOVWF  FEA
1398:  MOVFF  FEF,850
139C:  MOVF   x3B,W
139E:  ADDWF  x3D,W
13A0:  MOVWF  FE9
13A2:  MOVF   x3C,W
13A4:  ADDWFC x3E,W
13A6:  MOVWF  FEA
13A8:  MOVFF  FEF,851
13AC:  CLRF   x5A
13AE:  CLRF   x5B
13B0:  CLRF   x5C
13B2:  MOVFF  847,85D
13B6:  MOVFF  84A,85E
13BA:  MOVFF  84D,85F
13BE:  MOVFF  850,860
13C2:  MOVFF  851,861
13C6:  MOVLB  0
13C8:  CALL   0668
13CC:  MOVFF  01,841
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
13D0:  MOVLW  09
13D2:  MOVLB  8
13D4:  SUBWF  x3D,W
13D6:  MOVWF  x45
13D8:  MOVLW  00
13DA:  SUBWFB x3E,W
13DC:  MOVWF  x46
13DE:  MOVF   x3B,W
13E0:  ADDWF  x45,W
13E2:  MOVWF  FE9
13E4:  MOVF   x3C,W
13E6:  ADDWFC x46,W
13E8:  MOVWF  FEA
13EA:  MOVFF  FEF,847
13EE:  MOVLW  08
13F0:  SUBWF  x3D,W
13F2:  MOVWF  x48
13F4:  MOVLW  00
13F6:  SUBWFB x3E,W
13F8:  MOVWF  x49
13FA:  MOVF   x3B,W
13FC:  ADDWF  x48,W
13FE:  MOVWF  FE9
1400:  MOVF   x3C,W
1402:  ADDWFC x49,W
1404:  MOVWF  FEA
1406:  MOVFF  FEF,84A
140A:  MOVLW  07
140C:  SUBWF  x3D,W
140E:  MOVWF  x4B
1410:  MOVLW  00
1412:  SUBWFB x3E,W
1414:  MOVWF  x4C
1416:  MOVF   x3B,W
1418:  ADDWF  x4B,W
141A:  MOVWF  FE9
141C:  MOVF   x3C,W
141E:  ADDWFC x4C,W
1420:  MOVWF  FEA
1422:  MOVFF  FEF,84D
1426:  MOVLW  06
1428:  SUBWF  x3D,W
142A:  MOVWF  x4E
142C:  MOVLW  00
142E:  SUBWFB x3E,W
1430:  MOVWF  x4F
1432:  MOVF   x3B,W
1434:  ADDWF  x4E,W
1436:  MOVWF  FE9
1438:  MOVF   x3C,W
143A:  ADDWFC x4F,W
143C:  MOVWF  FEA
143E:  MOVFF  FEF,850
1442:  MOVLW  05
1444:  SUBWF  x3D,W
1446:  MOVWF  x51
1448:  MOVLW  00
144A:  SUBWFB x3E,W
144C:  MOVWF  x52
144E:  MOVF   x3B,W
1450:  ADDWF  x51,W
1452:  MOVWF  FE9
1454:  MOVF   x3C,W
1456:  ADDWFC x52,W
1458:  MOVWF  FEA
145A:  MOVFF  FEF,853
145E:  CLRF   x5A
1460:  CLRF   x5B
1462:  CLRF   x5C
1464:  MOVFF  847,85D
1468:  MOVFF  84A,85E
146C:  MOVFF  84D,85F
1470:  MOVFF  850,860
1474:  MOVFF  853,861
1478:  MOVLB  0
147A:  CALL   0668
147E:  MOVFF  01,842
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
1482:  MOVLB  8
1484:  MOVF   x41,W
1486:  SUBLW  0B
1488:  BTFSS  FD8.2
148A:  BRA    15AC
148C:  MOVF   x42,W
148E:  SUBLW  1F
1490:  BTFSC  FD8.2
1492:  BRA    15AC
1494:  MOVF   x42,W
1496:  SUBLW  0F
1498:  BTFSC  FD8.2
149A:  BRA    15AC
....................             { 
....................                j=i; 
149C:  MOVFF  83E,840
14A0:  MOVFF  83D,83F
....................                CRC=1; 
14A4:  MOVLW  01
14A6:  MOVWF  x44
....................                temp2=temp; 
14A8:  MOVFF  841,843
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
14AC:  MOVF   x43,W
14AE:  SUBLW  1F
14B0:  BZ    158C
14B2:  MOVF   x40,F
14B4:  BNZ   14BC
14B6:  MOVF   x3F,W
14B8:  SUBLW  01
14BA:  BC    158C
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
14BC:  MOVLW  01
14BE:  MOVWF  x45
14C0:  MOVFF  840,847
14C4:  MOVFF  83F,846
14C8:  MOVFF  83C,849
14CC:  MOVFF  83B,848
14D0:  MOVLB  0
14D2:  CALL   087E
14D6:  MOVF   01,W
14D8:  MOVLB  8
14DA:  ANDWF  x44,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
14DC:  MOVLW  04
14DE:  SUBWF  x3F,W
14E0:  MOVWF  x45
14E2:  MOVLW  00
14E4:  SUBWFB x40,W
14E6:  MOVWF  x46
14E8:  MOVF   x3B,W
14EA:  ADDWF  x45,W
14EC:  MOVWF  FE9
14EE:  MOVF   x3C,W
14F0:  ADDWFC x46,W
14F2:  MOVWF  FEA
14F4:  MOVFF  FEF,847
14F8:  MOVLW  03
14FA:  SUBWF  x3F,W
14FC:  MOVWF  x48
14FE:  MOVLW  00
1500:  SUBWFB x40,W
1502:  MOVWF  x49
1504:  MOVF   x3B,W
1506:  ADDWF  x48,W
1508:  MOVWF  FE9
150A:  MOVF   x3C,W
150C:  ADDWFC x49,W
150E:  MOVWF  FEA
1510:  MOVFF  FEF,84A
1514:  MOVLW  02
1516:  SUBWF  x3F,W
1518:  MOVWF  x4B
151A:  MOVLW  00
151C:  SUBWFB x40,W
151E:  MOVWF  x4C
1520:  MOVF   x3B,W
1522:  ADDWF  x4B,W
1524:  MOVWF  FE9
1526:  MOVF   x3C,W
1528:  ADDWFC x4C,W
152A:  MOVWF  FEA
152C:  MOVFF  FEF,84D
1530:  MOVLW  01
1532:  SUBWF  x3F,W
1534:  MOVWF  x4E
1536:  MOVLW  00
1538:  SUBWFB x40,W
153A:  MOVWF  x4F
153C:  MOVF   x3B,W
153E:  ADDWF  x4E,W
1540:  MOVWF  FE9
1542:  MOVF   x3C,W
1544:  ADDWFC x4F,W
1546:  MOVWF  FEA
1548:  MOVFF  FEF,850
154C:  MOVF   x3B,W
154E:  ADDWF  x3F,W
1550:  MOVWF  FE9
1552:  MOVF   x3C,W
1554:  ADDWFC x40,W
1556:  MOVWF  FEA
1558:  MOVFF  FEF,851
155C:  CLRF   x5A
155E:  CLRF   x5B
1560:  CLRF   x5C
1562:  MOVFF  847,85D
1566:  MOVFF  84A,85E
156A:  MOVFF  84D,85F
156E:  MOVFF  850,860
1572:  MOVFF  851,861
1576:  MOVLB  0
1578:  CALL   0668
157C:  MOVFF  01,843
....................                   j=j-5; 
1580:  MOVLW  05
1582:  MOVLB  8
1584:  SUBWF  x3F,F
1586:  MOVLW  00
1588:  SUBWFB x40,F
....................                } 
158A:  BRA    14AC
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
158C:  DECFSZ x44,W
158E:  BRA    15A4
....................                { 
....................                   dir=1; 
1590:  MOVLW  01
1592:  MOVLB  6
1594:  MOVWF  xC4
....................                   return i; 
1596:  MOVLB  8
1598:  MOVFF  83D,01
159C:  MOVFF  83E,02
15A0:  BRA    15BC
....................                } 
....................                   else return 0; 
15A2:  BRA    15AC
15A4:  MOVLW  00
15A6:  MOVWF  01
15A8:  MOVWF  02
15AA:  BRA    15BC
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
15AC:  MOVF   x3D,W
15AE:  BTFSC  FD8.2
15B0:  DECF   x3E,F
15B2:  DECF   x3D,F
15B4:  BRA    0FAE
....................    return 0; 
15B6:  MOVLW  00
15B8:  MOVWF  01
15BA:  MOVWF  02
.................... } 
15BC:  MOVLB  0
15BE:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
3560:  MOVLB  8
3562:  CLRF   x37
3564:  MOVLW  01
3566:  MOVWF  x36
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3568:  MOVFF  82C,838
356C:  MOVFF  82E,83A
3570:  MOVFF  82D,839
3574:  MOVFF  830,83C
3578:  MOVFF  82F,83B
357C:  MOVLB  0
357E:  CALL   09BE
3582:  MOVFF  02,837
3586:  MOVFF  01,836
....................    if(temp==0) return 0; 
358A:  MOVLB  8
358C:  MOVF   x36,F
358E:  BNZ   359A
3590:  MOVF   x37,F
3592:  BNZ   359A
3594:  MOVLW  00
3596:  MOVWF  01
3598:  BRA    3930
....................    j=temp; 
359A:  MOVFF  837,835
359E:  MOVFF  836,834
....................    if(dir==0) 
35A2:  MOVLB  6
35A4:  MOVF   xC4,F
35A6:  BTFSS  FD8.2
35A8:  BRA    3764
....................    { 
....................       if(track==0) 
35AA:  MOVLB  8
35AC:  MOVF   x2C,F
35AE:  BTFSS  FD8.2
35B0:  BRA    36A8
....................       { 
....................             for(i=0;i<79;i++) 
35B2:  CLRF   x33
35B4:  MOVF   x33,W
35B6:  SUBLW  4E
35B8:  BNC   36A6
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
35BA:  CLRF   03
35BC:  MOVF   x33,W
35BE:  ADDWF  x31,W
35C0:  MOVWF  01
35C2:  MOVF   x32,W
35C4:  ADDWFC 03,F
35C6:  MOVFF  01,838
35CA:  MOVFF  03,839
35CE:  MOVLW  05
35D0:  ADDWF  x34,W
35D2:  MOVWF  x3A
35D4:  MOVLW  00
35D6:  ADDWFC x35,W
35D8:  MOVWF  x3B
35DA:  MOVF   x2F,W
35DC:  ADDWF  x3A,W
35DE:  MOVWF  FE9
35E0:  MOVF   x30,W
35E2:  ADDWFC x3B,W
35E4:  MOVWF  FEA
35E6:  MOVFF  FEF,83C
35EA:  MOVLW  04
35EC:  ADDWF  x34,W
35EE:  MOVWF  x3D
35F0:  MOVLW  00
35F2:  ADDWFC x35,W
35F4:  MOVWF  x3E
35F6:  MOVF   x2F,W
35F8:  ADDWF  x3D,W
35FA:  MOVWF  FE9
35FC:  MOVF   x30,W
35FE:  ADDWFC x3E,W
3600:  MOVWF  FEA
3602:  MOVFF  FEF,83F
3606:  MOVLW  03
3608:  ADDWF  x34,W
360A:  MOVWF  x40
360C:  MOVLW  00
360E:  ADDWFC x35,W
3610:  MOVWF  x41
3612:  MOVF   x2F,W
3614:  ADDWF  x40,W
3616:  MOVWF  FE9
3618:  MOVF   x30,W
361A:  ADDWFC x41,W
361C:  MOVWF  FEA
361E:  MOVFF  FEF,842
3622:  MOVLW  02
3624:  ADDWF  x34,W
3626:  MOVWF  x43
3628:  MOVLW  00
362A:  ADDWFC x35,W
362C:  MOVWF  x44
362E:  MOVF   x2F,W
3630:  ADDWF  x43,W
3632:  MOVWF  FE9
3634:  MOVF   x30,W
3636:  ADDWFC x44,W
3638:  MOVWF  FEA
363A:  MOVFF  FEF,845
363E:  MOVLW  01
3640:  ADDWF  x34,W
3642:  MOVWF  x46
3644:  MOVLW  00
3646:  ADDWFC x35,W
3648:  MOVWF  x47
364A:  MOVF   x2F,W
364C:  ADDWF  x46,W
364E:  MOVWF  FE9
3650:  MOVF   x30,W
3652:  ADDWFC x47,W
3654:  MOVWF  FEA
3656:  MOVFF  FEF,848
365A:  MOVF   x2F,W
365C:  ADDWF  x34,W
365E:  MOVWF  FE9
3660:  MOVF   x30,W
3662:  ADDWFC x35,W
3664:  MOVWF  FEA
3666:  MOVFF  FEF,849
366A:  CLRF   x5A
366C:  CLRF   x5B
366E:  MOVFF  83C,85C
3672:  MOVFF  83F,85D
3676:  MOVFF  842,85E
367A:  MOVFF  845,85F
367E:  MOVFF  848,860
3682:  MOVFF  849,861
3686:  MOVLB  0
3688:  CALL   0668
368C:  MOVFF  839,FEA
3690:  MOVFF  838,FE9
3694:  MOVFF  01,FEF
....................                j=j+7; 
3698:  MOVLW  07
369A:  MOVLB  8
369C:  ADDWF  x34,F
369E:  MOVLW  00
36A0:  ADDWFC x35,F
....................             } 
36A2:  INCF   x33,F
36A4:  BRA    35B4
....................       } 
....................          else  
36A6:  BRA    3760
....................          { 
....................             for(i=0;i<40;i++) 
36A8:  CLRF   x33
36AA:  MOVF   x33,W
36AC:  SUBLW  27
36AE:  BNC   3760
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
36B0:  CLRF   03
36B2:  MOVF   x33,W
36B4:  ADDWF  x31,W
36B6:  MOVWF  01
36B8:  MOVF   x32,W
36BA:  ADDWFC 03,F
36BC:  MOVFF  01,838
36C0:  MOVFF  03,839
36C4:  MOVLW  03
36C6:  ADDWF  x34,W
36C8:  MOVWF  x3A
36CA:  MOVLW  00
36CC:  ADDWFC x35,W
36CE:  MOVWF  x3B
36D0:  MOVF   x2F,W
36D2:  ADDWF  x3A,W
36D4:  MOVWF  FE9
36D6:  MOVF   x30,W
36D8:  ADDWFC x3B,W
36DA:  MOVWF  FEA
36DC:  MOVFF  FEF,83C
36E0:  MOVLW  02
36E2:  ADDWF  x34,W
36E4:  MOVWF  x3D
36E6:  MOVLW  00
36E8:  ADDWFC x35,W
36EA:  MOVWF  x3E
36EC:  MOVF   x2F,W
36EE:  ADDWF  x3D,W
36F0:  MOVWF  FE9
36F2:  MOVF   x30,W
36F4:  ADDWFC x3E,W
36F6:  MOVWF  FEA
36F8:  MOVFF  FEF,83F
36FC:  MOVLW  01
36FE:  ADDWF  x34,W
3700:  MOVWF  x40
3702:  MOVLW  00
3704:  ADDWFC x35,W
3706:  MOVWF  x41
3708:  MOVF   x2F,W
370A:  ADDWF  x40,W
370C:  MOVWF  FE9
370E:  MOVF   x30,W
3710:  ADDWFC x41,W
3712:  MOVWF  FEA
3714:  MOVFF  FEF,842
3718:  MOVF   x2F,W
371A:  ADDWF  x34,W
371C:  MOVWF  FE9
371E:  MOVF   x30,W
3720:  ADDWFC x35,W
3722:  MOVWF  FEA
3724:  MOVFF  FEF,843
3728:  CLRF   x5A
372A:  CLRF   x5B
372C:  CLRF   x5C
372E:  CLRF   x5D
3730:  MOVFF  83C,85E
3734:  MOVFF  83F,85F
3738:  MOVFF  842,860
373C:  MOVFF  843,861
3740:  MOVLB  0
3742:  CALL   0668
3746:  MOVFF  839,FEA
374A:  MOVFF  838,FE9
374E:  MOVFF  01,FEF
....................                j=j+5; 
3752:  MOVLW  05
3754:  MOVLB  8
3756:  ADDWF  x34,F
3758:  MOVLW  00
375A:  ADDWFC x35,F
....................             }          
375C:  INCF   x33,F
375E:  BRA    36AA
....................          } 
....................    } 
....................       else  
3760:  BRA    391A
3762:  MOVLB  6
....................       { 
....................          if(track==0) 
3764:  MOVLB  8
3766:  MOVF   x2C,F
3768:  BTFSS  FD8.2
376A:  BRA    3862
....................          { 
....................             for(i=0;i<79;i++) 
376C:  CLRF   x33
376E:  MOVF   x33,W
3770:  SUBLW  4E
3772:  BNC   3860
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3774:  CLRF   03
3776:  MOVF   x33,W
3778:  ADDWF  x31,W
377A:  MOVWF  01
377C:  MOVF   x32,W
377E:  ADDWFC 03,F
3780:  MOVFF  01,838
3784:  MOVFF  03,839
3788:  MOVLW  05
378A:  SUBWF  x34,W
378C:  MOVWF  x3A
378E:  MOVLW  00
3790:  SUBWFB x35,W
3792:  MOVWF  x3B
3794:  MOVF   x2F,W
3796:  ADDWF  x3A,W
3798:  MOVWF  FE9
379A:  MOVF   x30,W
379C:  ADDWFC x3B,W
379E:  MOVWF  FEA
37A0:  MOVFF  FEF,83C
37A4:  MOVLW  04
37A6:  SUBWF  x34,W
37A8:  MOVWF  x3D
37AA:  MOVLW  00
37AC:  SUBWFB x35,W
37AE:  MOVWF  x3E
37B0:  MOVF   x2F,W
37B2:  ADDWF  x3D,W
37B4:  MOVWF  FE9
37B6:  MOVF   x30,W
37B8:  ADDWFC x3E,W
37BA:  MOVWF  FEA
37BC:  MOVFF  FEF,83F
37C0:  MOVLW  03
37C2:  SUBWF  x34,W
37C4:  MOVWF  x40
37C6:  MOVLW  00
37C8:  SUBWFB x35,W
37CA:  MOVWF  x41
37CC:  MOVF   x2F,W
37CE:  ADDWF  x40,W
37D0:  MOVWF  FE9
37D2:  MOVF   x30,W
37D4:  ADDWFC x41,W
37D6:  MOVWF  FEA
37D8:  MOVFF  FEF,842
37DC:  MOVLW  02
37DE:  SUBWF  x34,W
37E0:  MOVWF  x43
37E2:  MOVLW  00
37E4:  SUBWFB x35,W
37E6:  MOVWF  x44
37E8:  MOVF   x2F,W
37EA:  ADDWF  x43,W
37EC:  MOVWF  FE9
37EE:  MOVF   x30,W
37F0:  ADDWFC x44,W
37F2:  MOVWF  FEA
37F4:  MOVFF  FEF,845
37F8:  MOVLW  01
37FA:  SUBWF  x34,W
37FC:  MOVWF  x46
37FE:  MOVLW  00
3800:  SUBWFB x35,W
3802:  MOVWF  x47
3804:  MOVF   x2F,W
3806:  ADDWF  x46,W
3808:  MOVWF  FE9
380A:  MOVF   x30,W
380C:  ADDWFC x47,W
380E:  MOVWF  FEA
3810:  MOVFF  FEF,848
3814:  MOVF   x2F,W
3816:  ADDWF  x34,W
3818:  MOVWF  FE9
381A:  MOVF   x30,W
381C:  ADDWFC x35,W
381E:  MOVWF  FEA
3820:  MOVFF  FEF,849
3824:  CLRF   x5A
3826:  CLRF   x5B
3828:  MOVFF  83C,85C
382C:  MOVFF  83F,85D
3830:  MOVFF  842,85E
3834:  MOVFF  845,85F
3838:  MOVFF  848,860
383C:  MOVFF  849,861
3840:  MOVLB  0
3842:  CALL   0668
3846:  MOVFF  839,FEA
384A:  MOVFF  838,FE9
384E:  MOVFF  01,FEF
....................                j=j-7; 
3852:  MOVLW  07
3854:  MOVLB  8
3856:  SUBWF  x34,F
3858:  MOVLW  00
385A:  SUBWFB x35,F
....................             } 
385C:  INCF   x33,F
385E:  BRA    376E
....................          } 
....................             else 
3860:  BRA    391A
....................             { 
....................                for(i=0;i<40;i++) 
3862:  CLRF   x33
3864:  MOVF   x33,W
3866:  SUBLW  27
3868:  BNC   391A
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
386A:  CLRF   03
386C:  MOVF   x33,W
386E:  ADDWF  x31,W
3870:  MOVWF  01
3872:  MOVF   x32,W
3874:  ADDWFC 03,F
3876:  MOVFF  01,838
387A:  MOVFF  03,839
387E:  MOVLW  03
3880:  SUBWF  x34,W
3882:  MOVWF  x3A
3884:  MOVLW  00
3886:  SUBWFB x35,W
3888:  MOVWF  x3B
388A:  MOVF   x2F,W
388C:  ADDWF  x3A,W
388E:  MOVWF  FE9
3890:  MOVF   x30,W
3892:  ADDWFC x3B,W
3894:  MOVWF  FEA
3896:  MOVFF  FEF,83C
389A:  MOVLW  02
389C:  SUBWF  x34,W
389E:  MOVWF  x3D
38A0:  MOVLW  00
38A2:  SUBWFB x35,W
38A4:  MOVWF  x3E
38A6:  MOVF   x2F,W
38A8:  ADDWF  x3D,W
38AA:  MOVWF  FE9
38AC:  MOVF   x30,W
38AE:  ADDWFC x3E,W
38B0:  MOVWF  FEA
38B2:  MOVFF  FEF,83F
38B6:  MOVLW  01
38B8:  SUBWF  x34,W
38BA:  MOVWF  x40
38BC:  MOVLW  00
38BE:  SUBWFB x35,W
38C0:  MOVWF  x41
38C2:  MOVF   x2F,W
38C4:  ADDWF  x40,W
38C6:  MOVWF  FE9
38C8:  MOVF   x30,W
38CA:  ADDWFC x41,W
38CC:  MOVWF  FEA
38CE:  MOVFF  FEF,842
38D2:  MOVF   x2F,W
38D4:  ADDWF  x34,W
38D6:  MOVWF  FE9
38D8:  MOVF   x30,W
38DA:  ADDWFC x35,W
38DC:  MOVWF  FEA
38DE:  MOVFF  FEF,843
38E2:  CLRF   x5A
38E4:  CLRF   x5B
38E6:  CLRF   x5C
38E8:  CLRF   x5D
38EA:  MOVFF  83C,85E
38EE:  MOVFF  83F,85F
38F2:  MOVFF  842,860
38F6:  MOVFF  843,861
38FA:  MOVLB  0
38FC:  CALL   0668
3900:  MOVFF  839,FEA
3904:  MOVFF  838,FE9
3908:  MOVFF  01,FEF
....................                   j=j-5; 
390C:  MOVLW  05
390E:  MOVLB  8
3910:  SUBWF  x34,F
3912:  MOVLW  00
3914:  SUBWFB x35,F
....................                }             
3916:  INCF   x33,F
3918:  BRA    3864
....................             } 
....................       } 
....................       memset(datin,0,sizeof(datin)); 
391A:  MOVFF  830,FEA
391E:  MOVFF  82F,FE9
3922:  CLRF   00
3924:  CLRF   02
3926:  MOVLW  02
3928:  MOVWF  01
392A:  MOVLB  0
392C:  RCALL  3546
392E:  MOVLB  8
.................... } 
3930:  MOVLB  0
3932:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
17F2:  MOVLW  8E
17F4:  MOVWF  FF6
17F6:  MOVLW  05
17F8:  MOVWF  FF7
17FA:  RCALL  16EA
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
17FC:  MOVLB  8
17FE:  CLRF   x30
1800:  CLRF   x2F
1802:  MOVF   x30,W
1804:  SUBLW  03
1806:  BNC   1836
1808:  BNZ   1810
180A:  MOVF   x2F,W
180C:  SUBLW  51
180E:  BNC   1836
1810:  MOVLW  42
1812:  ADDWF  x2F,W
1814:  MOVWF  FE9
1816:  MOVLW  02
1818:  ADDWFC x30,W
181A:  MOVWF  FEA
181C:  MOVFF  FEF,831
1820:  MOVFF  831,832
1824:  MOVLW  18
1826:  MOVWF  x33
1828:  MOVLB  0
182A:  RCALL  1736
182C:  MOVLB  8
182E:  INCF   x2F,F
1830:  BTFSC  FD8.2
1832:  INCF   x30,F
1834:  BRA    1802
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1836:  MOVLW  A4
1838:  MOVWF  FF6
183A:  MOVLW  05
183C:  MOVWF  FF7
183E:  MOVLB  0
1840:  RCALL  16EA
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1842:  MOVLB  8
1844:  CLRF   x30
1846:  CLRF   x2F
1848:  MOVF   x30,W
184A:  SUBLW  01
184C:  BNC   187C
184E:  BNZ   1856
1850:  MOVF   x2F,W
1852:  SUBLW  2B
1854:  BNC   187C
1856:  MOVLW  94
1858:  ADDWF  x2F,W
185A:  MOVWF  FE9
185C:  MOVLW  05
185E:  ADDWFC x30,W
1860:  MOVWF  FEA
1862:  MOVFF  FEF,831
1866:  MOVFF  831,832
186A:  MOVLW  18
186C:  MOVWF  x33
186E:  MOVLB  0
1870:  RCALL  1736
1872:  MOVLB  8
1874:  INCF   x2F,F
1876:  BTFSC  FD8.2
1878:  INCF   x30,F
187A:  BRA    1848
.................... } 
187C:  MOVLB  0
187E:  GOTO   1B0C (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3AC0:  MOVLW  01
3AC2:  MOVLB  6
3AC4:  MOVWF  xD4
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3AC6:  MOVLB  0
3AC8:  RCALL  34CC
3ACA:  MOVFF  02,82D
3ACE:  MOVFF  01,82C
3AD2:  MOVFF  02,82F
3AD6:  MOVFF  01,82E
3ADA:  MOVLB  8
3ADC:  CLRF   x31
3ADE:  MOVLW  7C
3AE0:  MOVWF  x30
3AE2:  MOVLB  0
3AE4:  RCALL  3524
3AE6:  MOVFF  01,82C
3AEA:  MOVLW  96
3AEC:  MOVLB  8
3AEE:  ADDWF  01,W
3AF0:  MOVWF  01
3AF2:  MOVLW  00
3AF4:  ADDWFC 02,W
3AF6:  MOVFF  01,20
3AFA:  MOVWF  21
3AFC:  CLRF   22
3AFE:  CLRF   23
....................    if(datinbuf==0)  
3B00:  MOVLB  6
3B02:  MOVF   xD1,F
3B04:  BNZ   3B26
....................    { 
....................       countbit_T1=0; 
3B06:  CLRF   xC6
3B08:  CLRF   xC5
....................       countbit_T2=0; 
3B0A:  CLRF   xC8
3B0C:  CLRF   xC7
....................       bug_countbit_T1=0; 
3B0E:  CLRF   xCA
3B10:  CLRF   xC9
....................       bug_countbit_T2=0; 
3B12:  CLRF   xCC
3B14:  CLRF   xCB
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3B16:  MOVF   xD5,F
3B18:  BNZ   3B22
3B1A:  MOVLB  0
3B1C:  SETF   xFC
3B1E:  SETF   xFB
3B20:  MOVLB  6
....................       saving_flag=0; 
3B22:  CLRF   xD4
....................       return; 
3B24:  BRA    3EB0
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3B26:  MOVLW  BA
3B28:  MOVWF  FF6
3B2A:  MOVLW  05
3B2C:  MOVWF  FF7
3B2E:  MOVLB  0
3B30:  CALL   16EA
....................    //key_count=0; 
....................    enable_getpin=1; 
3B34:  MOVLW  01
3B36:  MOVLB  1
3B38:  MOVWF  x41
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3B3A:  MOVFF  6C6,82B
3B3E:  MOVFF  6C5,82A
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3B42:  MOVLB  8
3B44:  CLRF   x2C
3B46:  MOVFF  82B,82E
3B4A:  MOVFF  82A,82D
3B4E:  MOVLW  02
3B50:  MOVWF  x30
3B52:  MOVLW  42
3B54:  MOVWF  x2F
3B56:  MOVLW  01
3B58:  MOVWF  x32
3B5A:  MOVLW  CB
3B5C:  MOVWF  x31
3B5E:  MOVLB  0
3B60:  RCALL  3560
....................    countbit_T1=0; 
3B62:  MOVLB  6
3B64:  CLRF   xC6
3B66:  CLRF   xC5
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3B68:  MOVFF  6C8,82B
3B6C:  MOVFF  6C7,82A
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3B70:  MOVLW  01
3B72:  MOVLB  8
3B74:  MOVWF  x2C
3B76:  MOVFF  82B,82E
3B7A:  MOVFF  82A,82D
3B7E:  MOVLW  05
3B80:  MOVWF  x30
3B82:  MOVLW  94
3B84:  MOVWF  x2F
3B86:  MOVLW  02
3B88:  MOVWF  x32
3B8A:  MOVLW  1A
3B8C:  MOVWF  x31
3B8E:  MOVLB  0
3B90:  RCALL  3560
....................    countbit_T2=0; 
3B92:  MOVLB  6
3B94:  CLRF   xC8
3B96:  CLRF   xC7
....................    saving_flag=0; 
3B98:  CLRF   xD4
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3B9A:  MOVLW  20
3B9C:  MOVLB  1
3B9E:  ADDWF  xCB,W
3BA0:  MOVLB  8
3BA2:  MOVWF  x29
....................    if((ptr_card<EEPROM_SIZE_stofkey)&&(temp=='%')) 
3BA4:  MOVF   23,F
3BA6:  BTFSS  FD8.2
3BA8:  BRA    3EAE
3BAA:  MOVF   22,W
3BAC:  SUBLW  01
3BAE:  BTFSS  FD8.0
3BB0:  BRA    3EAE
3BB2:  BNZ   3BC6
3BB4:  MOVF   21,W
3BB6:  SUBLW  C3
3BB8:  BTFSS  FD8.0
3BBA:  BRA    3EAE
3BBC:  BNZ   3BC6
3BBE:  MOVF   20,W
3BC0:  SUBLW  0D
3BC2:  BTFSS  FD8.0
3BC4:  BRA    3EAE
3BC6:  MOVF   x29,W
3BC8:  SUBLW  25
3BCA:  BTFSS  FD8.2
3BCC:  BRA    3EAE
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3BCE:  MOVFF  23,03
3BD2:  MOVFF  22,02
3BD6:  MOVFF  21,01
3BDA:  MOVFF  20,00
3BDE:  MOVLW  01
3BE0:  ADDWF  20,F
3BE2:  BTFSC  FD8.0
3BE4:  INCF   21,F
3BE6:  BTFSC  FD8.2
3BE8:  INCF   22,F
3BEA:  BTFSC  FD8.2
3BEC:  INCF   23,F
3BEE:  MOVFF  01,82D
3BF2:  MOVFF  00,82C
3BF6:  CLRF   x53
3BF8:  CLRF   x52
3BFA:  MOVFF  01,851
3BFE:  MOVFF  00,850
3C02:  MOVFF  1C7,854
3C06:  MOVLB  0
3C08:  RCALL  3934
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3C0A:  MOVFF  23,03
3C0E:  MOVFF  22,02
3C12:  MOVFF  21,01
3C16:  MOVFF  20,00
3C1A:  MOVLW  01
3C1C:  ADDWF  20,F
3C1E:  BTFSC  FD8.0
3C20:  INCF   21,F
3C22:  BTFSC  FD8.2
3C24:  INCF   22,F
3C26:  BTFSC  FD8.2
3C28:  INCF   23,F
3C2A:  MOVFF  01,82D
3C2E:  MOVFF  00,82C
3C32:  MOVLB  8
3C34:  CLRF   x53
3C36:  CLRF   x52
3C38:  MOVFF  01,851
3C3C:  MOVFF  00,850
3C40:  MOVFF  1C6,854
3C44:  MOVLB  0
3C46:  RCALL  3934
....................          write_ext_eeprom((long int)ptr_card++,h); 
3C48:  MOVFF  23,03
3C4C:  MOVFF  22,02
3C50:  MOVFF  21,01
3C54:  MOVFF  20,00
3C58:  MOVLW  01
3C5A:  ADDWF  20,F
3C5C:  BTFSC  FD8.0
3C5E:  INCF   21,F
3C60:  BTFSC  FD8.2
3C62:  INCF   22,F
3C64:  BTFSC  FD8.2
3C66:  INCF   23,F
3C68:  MOVFF  01,82D
3C6C:  MOVFF  00,82C
3C70:  MOVLB  8
3C72:  CLRF   x53
3C74:  CLRF   x52
3C76:  MOVFF  01,851
3C7A:  MOVFF  00,850
3C7E:  MOVFF  1C8,854
3C82:  MOVLB  0
3C84:  RCALL  3934
....................          write_ext_eeprom((long int)ptr_card++,min); 
3C86:  MOVFF  23,03
3C8A:  MOVFF  22,02
3C8E:  MOVFF  21,01
3C92:  MOVFF  20,00
3C96:  MOVLW  01
3C98:  ADDWF  20,F
3C9A:  BTFSC  FD8.0
3C9C:  INCF   21,F
3C9E:  BTFSC  FD8.2
3CA0:  INCF   22,F
3CA2:  BTFSC  FD8.2
3CA4:  INCF   23,F
3CA6:  MOVFF  01,82D
3CAA:  MOVFF  00,82C
3CAE:  MOVLB  8
3CB0:  CLRF   x53
3CB2:  CLRF   x52
3CB4:  MOVFF  01,851
3CB8:  MOVFF  00,850
3CBC:  MOVFF  1C9,854
3CC0:  MOVLB  0
3CC2:  RCALL  3934
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3CC4:  MOVFF  23,03
3CC8:  MOVFF  22,02
3CCC:  MOVFF  21,01
3CD0:  MOVFF  20,00
3CD4:  MOVLW  01
3CD6:  ADDWF  20,F
3CD8:  BTFSC  FD8.0
3CDA:  INCF   21,F
3CDC:  BTFSC  FD8.2
3CDE:  INCF   22,F
3CE0:  BTFSC  FD8.2
3CE2:  INCF   23,F
3CE4:  MOVFF  01,82D
3CE8:  MOVFF  00,82C
3CEC:  MOVLB  8
3CEE:  CLRF   x53
3CF0:  CLRF   x52
3CF2:  MOVFF  01,851
3CF6:  MOVFF  00,850
3CFA:  MOVFF  1CA,854
3CFE:  MOVLB  0
3D00:  RCALL  3934
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3D02:  MOVLB  6
3D04:  CLRF   xD0
3D06:  CLRF   xCF
3D08:  MOVF   xD0,F
3D0A:  BNZ   3D6C
3D0C:  MOVF   xCF,W
3D0E:  SUBLW  4E
3D10:  BNC   3D6C
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3D12:  MOVFF  23,03
3D16:  MOVFF  22,02
3D1A:  MOVFF  21,01
3D1E:  MOVFF  20,00
3D22:  MOVLW  01
3D24:  ADDWF  20,F
3D26:  BTFSC  FD8.0
3D28:  INCF   21,F
3D2A:  BTFSC  FD8.2
3D2C:  INCF   22,F
3D2E:  BTFSC  FD8.2
3D30:  INCF   23,F
3D32:  MOVFF  01,82D
3D36:  MOVFF  00,82C
3D3A:  MOVLW  CB
3D3C:  ADDWF  xCF,W
3D3E:  MOVWF  FE9
3D40:  MOVLW  01
3D42:  ADDWFC xD0,W
3D44:  MOVWF  FEA
3D46:  MOVF   FEF,W
3D48:  ANDLW  3F
3D4A:  ADDLW  20
3D4C:  MOVLB  8
3D4E:  MOVWF  x2E
3D50:  CLRF   x53
3D52:  CLRF   x52
3D54:  MOVFF  01,851
3D58:  MOVFF  00,850
3D5C:  MOVWF  x54
3D5E:  MOVLB  0
3D60:  RCALL  3934
....................              
....................          } 
3D62:  MOVLB  6
3D64:  INCF   xCF,F
3D66:  BTFSC  FD8.2
3D68:  INCF   xD0,F
3D6A:  BRA    3D08
....................          memset(Track1,0,sizeof(Track1)); 
3D6C:  MOVLW  01
3D6E:  MOVWF  FEA
3D70:  MOVLW  CB
3D72:  MOVWF  FE9
3D74:  CLRF   00
3D76:  CLRF   02
3D78:  MOVLW  4F
3D7A:  MOVWF  01
3D7C:  MOVLB  0
3D7E:  CALL   3546
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3D82:  MOVLB  6
3D84:  CLRF   xD0
3D86:  CLRF   xCF
3D88:  MOVF   xD0,F
3D8A:  BNZ   3DEC
3D8C:  MOVF   xCF,W
3D8E:  SUBLW  27
3D90:  BNC   3DEC
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3D92:  MOVFF  23,03
3D96:  MOVFF  22,02
3D9A:  MOVFF  21,01
3D9E:  MOVFF  20,00
3DA2:  MOVLW  01
3DA4:  ADDWF  20,F
3DA6:  BTFSC  FD8.0
3DA8:  INCF   21,F
3DAA:  BTFSC  FD8.2
3DAC:  INCF   22,F
3DAE:  BTFSC  FD8.2
3DB0:  INCF   23,F
3DB2:  MOVFF  01,82D
3DB6:  MOVFF  00,82C
3DBA:  MOVLW  1A
3DBC:  ADDWF  xCF,W
3DBE:  MOVWF  FE9
3DC0:  MOVLW  02
3DC2:  ADDWFC xD0,W
3DC4:  MOVWF  FEA
3DC6:  MOVF   FEF,W
3DC8:  ANDLW  0F
3DCA:  ADDLW  30
3DCC:  MOVLB  8
3DCE:  MOVWF  x2E
3DD0:  CLRF   x53
3DD2:  CLRF   x52
3DD4:  MOVFF  01,851
3DD8:  MOVFF  00,850
3DDC:  MOVWF  x54
3DDE:  MOVLB  0
3DE0:  RCALL  3934
....................          }  
3DE2:  MOVLB  6
3DE4:  INCF   xCF,F
3DE6:  BTFSC  FD8.2
3DE8:  INCF   xD0,F
3DEA:  BRA    3D88
....................          memset(Track2,0,sizeof(Track2)); 
3DEC:  MOVLW  02
3DEE:  MOVWF  FEA
3DF0:  MOVLW  1A
3DF2:  MOVWF  FE9
3DF4:  CLRF   00
3DF6:  CLRF   02
3DF8:  MOVLW  28
3DFA:  MOVWF  01
3DFC:  MOVLB  0
3DFE:  CALL   3546
....................         fprintf(COM2,"\r\n"); 
3E02:  MOVLW  0D
3E04:  MOVLB  8
3E06:  MOVWF  x52
3E08:  MOVLB  0
3E0A:  CALL   15C0
3E0E:  MOVLW  0A
3E10:  MOVLB  8
3E12:  MOVWF  x52
3E14:  MOVLB  0
3E16:  CALL   15C0
....................         fprintf(COM2,"Done"); 
3E1A:  MOVLW  D0
3E1C:  MOVWF  FF6
3E1E:  MOVLW  05
3E20:  MOVWF  FF7
3E22:  CALL   16EA
....................              
....................         fprintf(COM2,"\r\n"); 
3E26:  MOVLW  0D
3E28:  MOVLB  8
3E2A:  MOVWF  x52
3E2C:  MOVLB  0
3E2E:  CALL   15C0
3E32:  MOVLW  0A
3E34:  MOVLB  8
3E36:  MOVWF  x52
3E38:  MOVLB  0
3E3A:  CALL   15C0
....................         fprintf(COM2,"Waiting for PIN number"); 
3E3E:  MOVLW  D6
3E40:  MOVWF  FF6
3E42:  MOVLW  05
3E44:  MOVWF  FF7
3E46:  CALL   16EA
....................         memset(key_data,0,sizeof(key_data));  
3E4A:  MOVLW  01
3E4C:  MOVWF  FEA
3E4E:  MOVLW  46
3E50:  MOVWF  FE9
3E52:  CLRF   00
3E54:  CLRF   02
3E56:  MOVLW  10
3E58:  MOVWF  01
3E5A:  CALL   3546
....................         fprintf(COM2,"\r\n"); 
3E5E:  MOVLW  0D
3E60:  MOVLB  8
3E62:  MOVWF  x52
3E64:  MOVLB  0
3E66:  CALL   15C0
3E6A:  MOVLW  0A
3E6C:  MOVLB  8
3E6E:  MOVWF  x52
3E70:  MOVLB  0
3E72:  CALL   15C0
....................         charac_timeout=0; 
3E76:  CLRF   xFC
3E78:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3E7A:  MOVFF  23,840
3E7E:  MOVFF  22,83F
3E82:  MOVFF  21,83E
3E86:  MOVFF  20,83D
3E8A:  MOVLW  19
3E8C:  MOVLB  8
3E8E:  MOVWF  x41
3E90:  MOVLB  0
3E92:  RCALL  3A32
....................       datinbuf=0; 
3E94:  MOVLB  6
3E96:  CLRF   xD1
....................       saving_flag=0; 
3E98:  CLRF   xD4
....................       data_avai=1; 
3E9A:  MOVLW  01
3E9C:  MOVWF  xD5
....................       enable_getpin=1; 
3E9E:  MOVLB  1
3EA0:  MOVWF  x41
....................       charac_timeout=0; 
3EA2:  MOVLB  0
3EA4:  CLRF   xFC
3EA6:  CLRF   xFB
....................       key_count_ms=0; 
3EA8:  MOVLB  1
3EAA:  CLRF   x43
3EAC:  MOVLB  8
3EAE:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3EB0:  MOVLB  0
3EB2:  GOTO   5206 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
18AA:  MOVLW  01
18AC:  MOVLB  8
18AE:  MOVWF  x26
18B0:  MOVWF  x27
18B2:  MOVWF  x28
18B4:  MOVWF  x29
18B6:  CLRF   x2A
18B8:  MOVWF  x2B
18BA:  MOVWF  x2C
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
18BC:  MOVLB  6
18BE:  CLRF   xCE
18C0:  CLRF   xCD
....................    mcr_timeout=0; 
18C2:  CLRF   xC3
18C4:  CLRF   xC2
18C6:  CLRF   xC1
18C8:  CLRF   xC0
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
18CA:  MOVF   xCE,W
18CC:  SUBLW  FD
18CE:  BNC   18EC
18D0:  BNZ   18D8
18D2:  MOVF   xCD,W
18D4:  SUBLW  E7
18D6:  BNC   18EC
18D8:  BSF    F93.1
18DA:  BTFSS  F81.1
18DC:  BRA    18EC
18DE:  BSF    F94.5
18E0:  BTFSS  F82.5
18E2:  BRA    18EC
....................       card_timeout++; 
18E4:  INCF   xCD,F
18E6:  BTFSC  FD8.2
18E8:  INCF   xCE,F
....................    } 
18EA:  BRA    18CA
....................    card_timeout=0; 
18EC:  CLRF   xCE
18EE:  CLRF   xCD
....................    buffertrack1[bug_countbit_T1++]=0; 
18F0:  MOVFF  6CA,03
18F4:  MOVF   xC9,W
18F6:  INCF   xC9,F
18F8:  BTFSC  FD8.2
18FA:  INCF   xCA,F
18FC:  MOVLB  8
18FE:  MOVWF  x2F
1900:  MOVLW  42
1902:  ADDWF  x2F,W
1904:  MOVWF  FE9
1906:  MOVLW  02
1908:  ADDWFC 03,W
190A:  MOVWF  FEA
190C:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
190E:  MOVLB  6
1910:  MOVFF  6CA,03
1914:  MOVF   xC9,W
1916:  INCF   xC9,F
1918:  BTFSC  FD8.2
191A:  INCF   xCA,F
191C:  MOVLB  8
191E:  MOVWF  x2F
1920:  MOVLW  42
1922:  ADDWF  x2F,W
1924:  MOVWF  FE9
1926:  MOVLW  02
1928:  ADDWFC 03,W
192A:  MOVWF  FEA
192C:  MOVLW  01
192E:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1930:  MOVLB  6
1932:  MOVFF  6CC,03
1936:  MOVF   xCB,W
1938:  INCF   xCB,F
193A:  BTFSC  FD8.2
193C:  INCF   xCC,F
193E:  MOVLB  8
1940:  MOVWF  x2F
1942:  MOVLW  94
1944:  ADDWF  x2F,W
1946:  MOVWF  FE9
1948:  MOVLW  05
194A:  ADDWFC 03,W
194C:  MOVWF  FEA
194E:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1950:  MOVLB  6
1952:  MOVFF  6CC,03
1956:  MOVF   xCB,W
1958:  INCF   xCB,F
195A:  BTFSC  FD8.2
195C:  INCF   xCC,F
195E:  MOVLB  8
1960:  MOVWF  x2F
1962:  MOVLW  94
1964:  ADDWF  x2F,W
1966:  MOVWF  FE9
1968:  MOVLW  05
196A:  ADDWFC 03,W
196C:  MOVWF  FEA
196E:  MOVLW  01
1970:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1972:  MOVLB  6
1974:  MOVF   xCA,W
1976:  SUBLW  03
1978:  BTFSS  FD8.0
197A:  BRA    1A5A
197C:  BNZ   1986
197E:  MOVF   xC9,W
1980:  SUBLW  51
1982:  BTFSS  FD8.0
1984:  BRA    1A5A
1986:  MOVF   xCC,W
1988:  SUBLW  01
198A:  BTFSS  FD8.0
198C:  BRA    1A5A
198E:  BNZ   1996
1990:  MOVF   xCB,W
1992:  SUBLW  2B
1994:  BNC   1A5A
1996:  MOVF   xCE,W
1998:  SUBLW  FF
199A:  BNC   1A5A
199C:  BNZ   19A4
199E:  MOVF   xCD,W
19A0:  SUBLW  DB
19A2:  BNC   1A5A
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
19A4:  MOVF   xD7,F
19A6:  BZ    19B0
....................          { 
....................             bug_countbit_T1=0; 
19A8:  CLRF   xCA
19AA:  CLRF   xC9
....................             bug_countbit_T2=0; 
19AC:  CLRF   xCC
19AE:  CLRF   xCB
....................          } 
....................          card_timeout++; 
19B0:  INCF   xCD,F
19B2:  BTFSC  FD8.2
19B4:  INCF   xCE,F
....................          mcr_timeout=0; 
19B6:  CLRF   xC3
19B8:  CLRF   xC2
19BA:  CLRF   xC1
19BC:  CLRF   xC0
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
19BE:  BSF    F93.2
19C0:  MOVLB  8
19C2:  CLRF   x26
19C4:  BTFSC  F81.2
19C6:  INCF   x26,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
19C8:  MOVF   x26,F
19CA:  BNZ   1A08
19CC:  DECFSZ x27,W
19CE:  BRA    1A08
....................          { 
....................             ST1_old = 0; 
19D0:  CLRF   x27
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
19D2:  MOVLW  42
19D4:  MOVLB  6
19D6:  ADDWF  xC9,W
19D8:  MOVWF  FE9
19DA:  MOVLW  02
19DC:  ADDWFC xCA,W
19DE:  MOVWF  FEA
19E0:  BSF    F93.1
19E2:  MOVLW  00
19E4:  BTFSS  F81.1
19E6:  MOVLW  01
19E8:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
19EA:  MOVLW  94
19EC:  ADDWF  xCB,W
19EE:  MOVWF  FE9
19F0:  MOVLW  05
19F2:  ADDWFC xCC,W
19F4:  MOVWF  FEA
19F6:  MOVFF  82A,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
19FA:  INCF   xC9,F
19FC:  BTFSC  FD8.2
19FE:  INCF   xCA,F
....................             card_timeout=0; 
1A00:  CLRF   xCE
1A02:  CLRF   xCD
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A04:  BRA    1A12
1A06:  MOVLB  8
1A08:  DECFSZ x26,W
1A0A:  BRA    1A10
1A0C:  MOVLW  01
1A0E:  MOVWF  x27
1A10:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A12:  BSF    F93.3
1A14:  MOVLB  8
1A16:  CLRF   x28
1A18:  BTFSC  F81.3
1A1A:  INCF   x28,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A1C:  MOVF   x28,F
1A1E:  BNZ   1A3E
1A20:  DECFSZ x29,W
1A22:  BRA    1A3E
....................          { 
....................             ST2_old = 0; 
1A24:  CLRF   x29
....................             Bit_t2 = !input(MCR_DATA2); 
1A26:  BSF    F94.5
1A28:  CLRF   x2A
1A2A:  BTFSS  F82.5
1A2C:  INCF   x2A,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A2E:  MOVLB  6
1A30:  INCF   xCB,F
1A32:  BTFSC  FD8.2
1A34:  INCF   xCC,F
....................             card_timeout=0; 
1A36:  CLRF   xCE
1A38:  CLRF   xCD
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A3A:  BRA    1A48
1A3C:  MOVLB  8
1A3E:  DECFSZ x28,W
1A40:  BRA    1A46
1A42:  MOVLW  01
1A44:  MOVWF  x29
1A46:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1A48:  BSF    F93.0
1A4A:  BTFSS  F81.0
1A4C:  BRA    1A58
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1A4E:  CLRF   xD7
....................             card_timeout=65500; 
1A50:  SETF   xCE
1A52:  MOVLW  DC
1A54:  MOVWF  xCD
....................             break;            
1A56:  BRA    1A5A
....................          } 
....................       } 
1A58:  BRA    1974
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1A5A:  CLRF   xCE
1A5C:  CLRF   xCD
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1A5E:  MOVLB  8
1A60:  CLRF   x38
1A62:  MOVFF  6CA,83A
1A66:  MOVFF  6C9,839
1A6A:  MOVLW  02
1A6C:  MOVWF  x3C
1A6E:  MOVLW  42
1A70:  MOVWF  x3B
1A72:  MOVLB  0
1A74:  CALL   09BE
1A78:  MOVFF  01,82B
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1A7C:  MOVLW  01
1A7E:  MOVLB  8
1A80:  MOVWF  x38
1A82:  MOVFF  6CC,83A
1A86:  MOVFF  6CB,839
1A8A:  MOVLW  05
1A8C:  MOVWF  x3C
1A8E:  MOVLW  94
1A90:  MOVWF  x3B
1A92:  MOVLB  0
1A94:  CALL   09BE
1A98:  MOVFF  01,82C
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1A9C:  MOVLB  6
1A9E:  DECFSZ xD2,W
1AA0:  BRA    1B36
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1AA2:  MOVLW  EE
1AA4:  MOVWF  FF6
1AA6:  MOVLW  05
1AA8:  MOVWF  FF7
1AAA:  MOVLW  0E
1AAC:  MOVLB  8
1AAE:  MOVWF  x46
1AB0:  MOVLB  0
1AB2:  RCALL  1606
1AB4:  MOVLW  10
1AB6:  MOVWF  FE9
1AB8:  MOVFF  6CA,830
1ABC:  MOVFF  6C9,82F
1AC0:  RCALL  162E
1AC2:  MOVLW  0D
1AC4:  MOVLB  8
1AC6:  MOVWF  x52
1AC8:  MOVLB  0
1ACA:  RCALL  15C0
1ACC:  MOVLW  0A
1ACE:  MOVLB  8
1AD0:  MOVWF  x52
1AD2:  MOVLB  0
1AD4:  RCALL  15C0
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1AD6:  MOVLW  02
1AD8:  MOVWF  FF6
1ADA:  MOVLW  06
1ADC:  MOVWF  FF7
1ADE:  MOVLW  0E
1AE0:  MOVLB  8
1AE2:  MOVWF  x46
1AE4:  MOVLB  0
1AE6:  RCALL  1606
1AE8:  MOVLW  10
1AEA:  MOVWF  FE9
1AEC:  MOVFF  6CC,830
1AF0:  MOVFF  6CB,82F
1AF4:  RCALL  162E
1AF6:  MOVLW  0D
1AF8:  MOVLB  8
1AFA:  MOVWF  x52
1AFC:  MOVLB  0
1AFE:  RCALL  15C0
1B00:  MOVLW  0A
1B02:  MOVLB  8
1B04:  MOVWF  x52
1B06:  MOVLB  0
1B08:  RCALL  15C0
....................          debug_reader();       
1B0A:  BRA    17F2
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B0C:  MOVLB  8
1B0E:  MOVF   x2B,F
1B10:  BNZ   1B20
1B12:  MOVLW  16
1B14:  MOVWF  FF6
1B16:  MOVLW  06
1B18:  MOVWF  FF7
1B1A:  MOVLB  0
1B1C:  RCALL  16EA
1B1E:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B20:  MOVF   x2C,F
1B22:  BNZ   1B32
1B24:  MOVLW  2C
1B26:  MOVWF  FF6
1B28:  MOVLW  06
1B2A:  MOVWF  FF7
1B2C:  MOVLB  0
1B2E:  RCALL  16EA
1B30:  MOVLB  8
....................       } 
....................          else 
1B32:  BRA    1B42
1B34:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B36:  MOVLW  0F
1B38:  MOVLB  8
1B3A:  MOVWF  x2F
1B3C:  MOVLB  0
1B3E:  RCALL  1882
1B40:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1B42:  MOVF   x2B,F
1B44:  BZ    1B4A
1B46:  MOVF   x2C,F
1B48:  BNZ   1B6A
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1B4A:  MOVLB  6
1B4C:  CLRF   xCC
1B4E:  CLRF   xCB
....................          bug_countbit_T1=0; 
1B50:  CLRF   xCA
1B52:  CLRF   xC9
....................          reading_fg=0; 
1B54:  CLRF   xD6
....................          count_reading_error++; 
1B56:  INCF   xD7,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1B58:  CLRF   xC3
1B5A:  CLRF   xC2
1B5C:  CLRF   xC1
1B5E:  CLRF   xC0
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1B60:  MOVLW  00
1B62:  MOVWF  01
1B64:  BRA    1BA2
....................       } 
....................          else  
1B66:  BRA    1B9E
1B68:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1B6A:  MOVLW  01
1B6C:  MOVLB  6
1B6E:  MOVWF  xD1
....................             reading_fg=1; 
1B70:  MOVWF  xD6
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1B72:  MOVFF  6CC,6C8
1B76:  MOVFF  6CB,6C7
....................             countbit_T1=bug_countbit_T1; 
1B7A:  MOVFF  6CA,6C6
1B7E:  MOVFF  6C9,6C5
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1B82:  CLRF   xCA
1B84:  CLRF   xC9
....................             bug_countbit_T2=0;  
1B86:  CLRF   xCC
1B88:  CLRF   xCB
....................             mcr_timeout=0; 
1B8A:  CLRF   xC3
1B8C:  CLRF   xC2
1B8E:  CLRF   xC1
1B90:  CLRF   xC0
....................             charac_timeout=0; 
1B92:  MOVLB  0
1B94:  CLRF   xFC
1B96:  CLRF   xFB
....................             return 1; 
1B98:  MOVWF  01
1B9A:  MOVLB  6
1B9C:  BRA    1BA2
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1B9E:  MOVLW  00
1BA0:  MOVWF  01
.................... } 
1BA2:  MOVLB  0
1BA4:  GOTO   1BCA (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       delay_us(500); 
1BA8:  MOVLW  02
1BAA:  MOVLB  8
1BAC:  MOVWF  x26
1BAE:  MOVLW  FA
1BB0:  MOVWF  x27
1BB2:  MOVLB  0
1BB4:  GOTO   0642
1BB8:  MOVLB  8
1BBA:  DECFSZ x26,F
1BBC:  BRA    1BAE
....................       if(saving_flag==1) return;      
1BBE:  MOVLB  6
1BC0:  DECFSZ xD4,W
1BC2:  BRA    1BC6
1BC4:  BRA    1BDC
....................       cardread_st=mcr_read(); 
1BC6:  MOVLB  0
1BC8:  BRA    18AA
1BCA:  MOVFF  01,6D3
....................       mcr_timeout=0; 
1BCE:  MOVLB  6
1BD0:  CLRF   xC3
1BD2:  CLRF   xC2
1BD4:  CLRF   xC1
1BD6:  CLRF   xC0
....................       card_timeout=0;      
1BD8:  CLRF   xCE
1BDA:  CLRF   xCD
.................... } 
.................... //==================================== 
.................... #if 0 
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... #endif 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
1BDC:  BCF    FF0.0
1BDE:  MOVLB  0
1BE0:  GOTO   006C
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
5C60:  CLRF   19
5C62:  BTFSC  FF2.7
5C64:  BSF    19.7
5C66:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
5C68:  MOVLB  8
5C6A:  CLRF   x53
5C6C:  CLRF   x52
5C6E:  CLRF   x51
5C70:  MOVLW  3C
5C72:  MOVWF  x50
5C74:  MOVLW  03
5C76:  MOVWF  x54
5C78:  MOVLB  0
5C7A:  CALL   3934
5C7E:  BTFSC  19.7
5C80:  BSF    FF2.7
5C82:  CLRF   19
5C84:  BTFSC  FF2.7
5C86:  BSF    19.7
5C88:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
5C8A:  MOVLB  8
5C8C:  CLRF   x53
5C8E:  CLRF   x52
5C90:  CLRF   x51
5C92:  MOVLW  3A
5C94:  MOVWF  x50
5C96:  MOVLW  01
5C98:  MOVWF  x54
5C9A:  MOVLB  0
5C9C:  CALL   3934
5CA0:  BTFSC  19.7
5CA2:  BSF    FF2.7
5CA4:  CLRF   19
5CA6:  BTFSC  FF2.7
5CA8:  BSF    19.7
5CAA:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV);  
5CAC:  MOVLB  8
5CAE:  CLRF   x46
5CB0:  CLRF   x45
5CB2:  CLRF   x44
5CB4:  MOVLW  3A
5CB6:  MOVWF  x43
5CB8:  MOVLB  0
5CBA:  CALL   3400
5CBE:  BTFSC  19.7
5CC0:  BSF    FF2.7
5CC2:  MOVFF  01,6DE
.................... } 
5CC6:  GOTO   646E (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int16 countchar; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
5DDE:  MOVLW  06
5DE0:  MOVWF  FEA
5DE2:  MOVLW  E3
5DE4:  MOVWF  FE9
5DE6:  RCALL  5712
5DE8:  CLRF   19
5DEA:  BTFSC  FF2.7
5DEC:  BSF    19.7
5DEE:  BCF    FF2.7
5DF0:  MOVLW  3E
5DF2:  MOVLB  8
5DF4:  MOVWF  x52
5DF6:  MOVLB  0
5DF8:  CALL   15C0
5DFC:  BTFSC  19.7
5DFE:  BSF    FF2.7
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
5E00:  MOVLW  01
5E02:  MOVLB  7
5E04:  MOVWF  xF1
5E06:  MOVLW  14
5E08:  MOVWF  xF2
5E0A:  MOVLW  01
5E0C:  MOVWF  xF4
5E0E:  MOVLW  5E
5E10:  MOVWF  xF3
5E12:  MOVLB  0
5E14:  RCALL  5792
5E16:  CLRF   19
5E18:  BTFSC  FF2.7
5E1A:  BSF    19.7
5E1C:  BCF    FF2.7
....................       printf("\n\r"); 
5E1E:  MOVLW  0A
5E20:  MOVLB  8
5E22:  MOVWF  x52
5E24:  MOVLB  0
5E26:  CALL   15C0
5E2A:  BTFSC  19.7
5E2C:  BSF    FF2.7
5E2E:  CLRF   19
5E30:  BTFSC  FF2.7
5E32:  BSF    19.7
5E34:  BCF    FF2.7
5E36:  MOVLW  0D
5E38:  MOVLB  8
5E3A:  MOVWF  x52
5E3C:  MOVLB  0
5E3E:  CALL   15C0
5E42:  BTFSC  19.7
5E44:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
5E46:  CLRF   FEA
5E48:  MOVLW  41
5E4A:  MOVWF  FE9
5E4C:  MOVLW  00
5E4E:  CALL   0356
5E52:  TBLRD*-
5E54:  TBLRD*+
5E56:  MOVF   FF5,W
5E58:  MOVWF  FEE
5E5A:  IORLW  00
5E5C:  BNZ   5E54
....................       index=0; 
5E5E:  MOVLB  7
5E60:  CLRF   xB9
....................       ee_dat=0; 
5E62:  MOVLB  6
5E64:  CLRF   xD9
....................       count_card=1; 
5E66:  CLRF   xDB
5E68:  MOVLW  01
5E6A:  MOVWF  xDA
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
5E6C:  MOVLB  7
5E6E:  MOVWF  xF2
5E70:  MOVLW  5E
5E72:  MOVWF  xF1
5E74:  CLRF   xF4
5E76:  MOVLW  41
5E78:  MOVWF  xF3
5E7A:  MOVLB  0
5E7C:  RCALL  58CA
5E7E:  MOVF   01,F
5E80:  BTFSS  FD8.2
5E82:  BRA    629E
....................       { 
....................          unsigned long adr=0; 
5E84:  MOVLB  7
5E86:  CLRF   xF0
5E88:  CLRF   xEF
....................          //unsigned int count=0; 
....................          rec[0]=0; 
5E8A:  MOVLB  0
5E8C:  CLRF   x7D
5E8E:  CLRF   19
5E90:  BTFSC  FF2.7
5E92:  BSF    19.7
5E94:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
5E96:  CALL   34CC
5E9A:  BTFSC  19.7
5E9C:  BSF    FF2.7
5E9E:  MOVFF  02,6DD
5EA2:  MOVFF  01,6DC
5EA6:  CLRF   19
5EA8:  BTFSC  FF2.7
5EAA:  BSF    19.7
5EAC:  BCF    FF2.7
....................          adr=count_card*numdata; 
5EAE:  MOVFF  6DB,82F
5EB2:  MOVFF  6DA,82E
5EB6:  MOVLB  8
5EB8:  CLRF   x31
5EBA:  MOVLW  7C
5EBC:  MOVWF  x30
5EBE:  MOVLB  0
5EC0:  CALL   3524
5EC4:  BTFSC  19.7
5EC6:  BSF    FF2.7
5EC8:  MOVFF  02,7F0
5ECC:  MOVFF  01,7EF
....................          addr_key=EEPROM_KEY_ST; 
5ED0:  MOVLB  6
5ED2:  CLRF   xE2
5ED4:  MOVLW  01
5ED6:  MOVWF  xE1
5ED8:  MOVLW  C3
5EDA:  MOVWF  xE0
5EDC:  MOVLW  0F
5EDE:  MOVWF  xDF
....................          while(count_card<=count_card_tg) 
....................          { 
5EE0:  MOVF   xDB,W
5EE2:  SUBWF  xDD,W
5EE4:  BTFSS  FD8.0
5EE6:  BRA    629C
5EE8:  BNZ   5EF2
5EEA:  MOVF   xDA,W
5EEC:  SUBWF  xDC,W
5EEE:  BTFSS  FD8.0
5EF0:  BRA    629C
5EF2:  CLRF   19
5EF4:  BTFSC  FF2.7
5EF6:  BSF    19.7
5EF8:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
5EFA:  MOVFF  6DB,82F
5EFE:  MOVFF  6DA,82E
5F02:  MOVLB  8
5F04:  CLRF   x31
5F06:  MOVLW  7C
5F08:  MOVWF  x30
5F0A:  MOVLB  0
5F0C:  CALL   3524
5F10:  BTFSC  19.7
5F12:  BSF    FF2.7
5F14:  MOVLW  96
5F16:  MOVLB  7
5F18:  ADDWF  01,W
5F1A:  MOVWF  xEF
5F1C:  MOVLW  00
5F1E:  ADDWFC 02,W
5F20:  MOVWF  xF0
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
5F22:  MOVLW  7C
5F24:  SUBWF  xEF,W
5F26:  MOVWF  xF1
5F28:  MOVLW  00
5F2A:  SUBWFB xF0,W
5F2C:  MOVWF  xF2
5F2E:  MOVWF  xF4
5F30:  MOVFF  7F1,7F3
5F34:  CLRF   xF6
5F36:  MOVLW  7C
5F38:  MOVWF  xF5
5F3A:  CLRF   xF8
5F3C:  MOVLW  7D
5F3E:  MOVWF  xF7
5F40:  MOVLB  0
5F42:  BRA    5962
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
5F44:  MOVLW  10
5F46:  MOVWF  FE9
5F48:  CLRF   19
5F4A:  BTFSC  FF2.7
5F4C:  BSF    19.7
5F4E:  BCF    FF2.7
5F50:  MOVFF  6DB,82A
5F54:  MOVFF  6DA,829
5F58:  CALL   5094
5F5C:  BTFSC  19.7
5F5E:  BSF    FF2.7
5F60:  CLRF   19
5F62:  BTFSC  FF2.7
5F64:  BSF    19.7
5F66:  BCF    FF2.7
5F68:  MOVLW  29
5F6A:  MOVLB  8
5F6C:  MOVWF  x52
5F6E:  MOVLB  0
5F70:  CALL   15C0
5F74:  BTFSC  19.7
5F76:  BSF    FF2.7
5F78:  MOVFF  7D,7F1
5F7C:  MOVLW  01
5F7E:  MOVLB  7
5F80:  MOVWF  xF2
5F82:  MOVLB  0
5F84:  RCALL  59D8
5F86:  CLRF   19
5F88:  BTFSC  FF2.7
5F8A:  BSF    19.7
5F8C:  BCF    FF2.7
5F8E:  MOVLW  2F
5F90:  MOVLB  8
5F92:  MOVWF  x52
5F94:  MOVLB  0
5F96:  CALL   15C0
5F9A:  BTFSC  19.7
5F9C:  BSF    FF2.7
5F9E:  MOVFF  7E,7F1
5FA2:  MOVLW  01
5FA4:  MOVLB  7
5FA6:  MOVWF  xF2
5FA8:  MOVLB  0
5FAA:  RCALL  59D8
5FAC:  CLRF   19
5FAE:  BTFSC  FF2.7
5FB0:  BSF    19.7
5FB2:  BCF    FF2.7
5FB4:  MOVLW  20
5FB6:  MOVLB  8
5FB8:  MOVWF  x52
5FBA:  MOVLB  0
5FBC:  CALL   15C0
5FC0:  BTFSC  19.7
5FC2:  BSF    FF2.7
5FC4:  MOVFF  7F,7F1
5FC8:  MOVLW  01
5FCA:  MOVLB  7
5FCC:  MOVWF  xF2
5FCE:  MOVLB  0
5FD0:  RCALL  59D8
5FD2:  CLRF   19
5FD4:  BTFSC  FF2.7
5FD6:  BSF    19.7
5FD8:  BCF    FF2.7
5FDA:  MOVLW  3A
5FDC:  MOVLB  8
5FDE:  MOVWF  x52
5FE0:  MOVLB  0
5FE2:  CALL   15C0
5FE6:  BTFSC  19.7
5FE8:  BSF    FF2.7
5FEA:  MOVFF  80,7F1
5FEE:  MOVLW  01
5FF0:  MOVLB  7
5FF2:  MOVWF  xF2
5FF4:  MOVLB  0
5FF6:  RCALL  59D8
5FF8:  CLRF   19
5FFA:  BTFSC  FF2.7
5FFC:  BSF    19.7
5FFE:  BCF    FF2.7
6000:  MOVLW  3A
6002:  MOVLB  8
6004:  MOVWF  x52
6006:  MOVLB  0
6008:  CALL   15C0
600C:  BTFSC  19.7
600E:  BSF    FF2.7
6010:  MOVFF  81,7F1
6014:  MOVLW  01
6016:  MOVLB  7
6018:  MOVWF  xF2
601A:  MOVLB  0
601C:  RCALL  59D8
....................             ee_dat=0; 
601E:  MOVLB  6
6020:  CLRF   xD9
....................             index=0; 
6022:  MOVLB  7
6024:  CLRF   xB9
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
6026:  MOVLW  E4
6028:  MOVWF  FF6
602A:  MOVLW  1B
602C:  MOVWF  FF7
602E:  CLRF   19
6030:  BTFSC  FF2.7
6032:  BSF    19.7
6034:  BCF    FF2.7
6036:  MOVLB  0
6038:  CALL   16EA
603C:  BTFSC  19.7
603E:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
6040:  MOVLB  7
6042:  MOVF   xB9,W
6044:  SUBLW  4E
6046:  BNC   60A4
6048:  MOVLB  6
604A:  MOVF   xD9,W
604C:  SUBLW  3F
604E:  BTFSS  FD8.2
6050:  BRA    6056
6052:  MOVLB  7
6054:  BRA    60A4
....................                ee_dat = rec[index+5]; 
6056:  MOVLW  05
6058:  MOVLB  7
605A:  ADDWF  xB9,W
605C:  CLRF   03
605E:  ADDLW  7D
6060:  MOVWF  FE9
6062:  MOVLW  00
6064:  ADDWFC 03,W
6066:  MOVWF  FEA
6068:  MOVFF  FEF,6D9
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
606C:  MOVLB  6
606E:  MOVF   xD9,W
6070:  SUBLW  1F
6072:  BC    6090
6074:  MOVF   xD9,W
6076:  SUBLW  7E
6078:  BNC   6090
607A:  CLRF   19
607C:  BTFSC  FF2.7
607E:  BSF    19.7
6080:  BCF    FF2.7
6082:  MOVFF  6D9,852
6086:  MOVLB  0
6088:  CALL   15C0
608C:  BTFSC  19.7
608E:  BSF    FF2.7
....................                index++; 
6090:  MOVLB  7
6092:  INCF   xB9,F
....................                if(ee_dat==0)break; 
6094:  MOVLB  6
6096:  MOVF   xD9,F
6098:  BNZ   609E
609A:  MOVLB  7
609C:  BRA    60A4
....................             } 
609E:  MOVLB  0
60A0:  BRA    6040
60A2:  MOVLB  7
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
60A4:  MOVLW  F6
60A6:  MOVWF  FF6
60A8:  MOVLW  1B
60AA:  MOVWF  FF7
60AC:  CLRF   19
60AE:  BTFSC  FF2.7
60B0:  BSF    19.7
60B2:  BCF    FF2.7
60B4:  MOVLB  0
60B6:  CALL   16EA
60BA:  BTFSC  19.7
60BC:  BSF    FF2.7
....................             index=0; 
60BE:  MOVLB  7
60C0:  CLRF   xB9
....................             ee_dat=0; 
60C2:  MOVLB  6
60C4:  CLRF   xD9
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
60C6:  MOVLB  7
60C8:  MOVF   xB9,W
60CA:  SUBLW  27
60CC:  BNC   612C
60CE:  MOVLB  6
60D0:  MOVF   xD9,W
60D2:  SUBLW  3F
60D4:  BTFSS  FD8.2
60D6:  BRA    60DC
60D8:  MOVLB  7
60DA:  BRA    612C
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
60DC:  MOVLW  05
60DE:  MOVLB  7
60E0:  ADDWF  xB9,W
60E2:  ADDLW  4F
60E4:  CLRF   03
60E6:  ADDLW  7D
60E8:  MOVWF  FE9
60EA:  MOVLW  00
60EC:  ADDWFC 03,W
60EE:  MOVWF  FEA
60F0:  MOVFF  FEF,6D9
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
60F4:  MOVLB  6
60F6:  MOVF   xD9,W
60F8:  SUBLW  1F
60FA:  BC    6118
60FC:  MOVF   xD9,W
60FE:  SUBLW  7E
6100:  BNC   6118
6102:  CLRF   19
6104:  BTFSC  FF2.7
6106:  BSF    19.7
6108:  BCF    FF2.7
610A:  MOVFF  6D9,852
610E:  MOVLB  0
6110:  CALL   15C0
6114:  BTFSC  19.7
6116:  BSF    FF2.7
....................                index++; 
6118:  MOVLB  7
611A:  INCF   xB9,F
....................                if(ee_dat==0)break; 
611C:  MOVLB  6
611E:  MOVF   xD9,F
6120:  BNZ   6128
6122:  MOVLB  7
6124:  BRA    612C
6126:  MOVLB  6
....................             } 
6128:  BRA    60C6
612A:  MOVLB  7
....................             index=0; 
612C:  CLRF   xB9
....................             //ee_dat=0; 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
612E:  MOVLW  08
6130:  MOVWF  FF6
6132:  MOVLW  1C
6134:  MOVWF  FF7
6136:  CLRF   19
6138:  BTFSC  FF2.7
613A:  BSF    19.7
613C:  BCF    FF2.7
613E:  MOVLB  0
6140:  CALL   16EA
6144:  BTFSC  19.7
6146:  BSF    FF2.7
....................             //fprintf(COM2,"addr_key =%lu \n\r",addr_key);  
....................             //fprintf(COM2," ptr_card_key=%lu \n\r",ptr_card_key); 
....................              
....................             if((ptr_card_key>addr_key)) //&& 
6148:  MOVLB  6
614A:  MOVF   xE2,W
614C:  SUBWF  27,W
614E:  BTFSS  FD8.0
6150:  BRA    6294
6152:  BNZ   6170
6154:  MOVF   xE1,W
6156:  SUBWF  26,W
6158:  BTFSS  FD8.0
615A:  BRA    6294
615C:  BNZ   6170
615E:  MOVF   xE0,W
6160:  SUBWF  25,W
6162:  BTFSS  FD8.0
6164:  BRA    6294
6166:  BNZ   6170
6168:  MOVF   24,W
616A:  SUBWF  xDF,W
616C:  BTFSC  FD8.0
616E:  BRA    6294
....................             { 
....................                i=0; 
6170:  MOVLB  7
6172:  CLRF   xBA
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
6174:  MOVF   xBA,W
6176:  MOVLB  6
6178:  ADDWF  xDF,W
617A:  MOVLB  7
617C:  MOVWF  xF1
617E:  MOVLW  00
6180:  MOVLB  6
6182:  ADDWFC xE0,W
6184:  MOVLB  7
6186:  MOVWF  xF2
6188:  MOVLW  00
618A:  MOVLB  6
618C:  ADDWFC xE1,W
618E:  MOVLB  7
6190:  MOVWF  xF3
6192:  MOVLW  00
6194:  MOVLB  6
6196:  ADDWFC xE2,W
6198:  MOVLB  7
619A:  MOVWF  xF4
619C:  CLRF   19
619E:  BTFSC  FF2.7
61A0:  BSF    19.7
61A2:  BCF    FF2.7
61A4:  MOVFF  FE8,846
61A8:  MOVFF  7F3,845
61AC:  MOVFF  7F2,844
61B0:  MOVFF  7F1,843
61B4:  MOVLB  0
61B6:  CALL   3400
61BA:  BTFSC  19.7
61BC:  BSF    FF2.7
61BE:  MOVFF  01,6D9
....................                   if(cryption_enable==0) 
61C2:  MOVLB  1
61C4:  MOVF   x1E,F
61C6:  BNZ   620A
....................                   { 
....................                       if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
61C8:  MOVLB  6
61CA:  MOVF   xD9,W
61CC:  SUBLW  2F
61CE:  BC    61D6
61D0:  MOVF   xD9,W
61D2:  SUBLW  39
61D4:  BC    61EE
61D6:  MOVF   xD9,W
61D8:  SUBLW  23
61DA:  BZ    61EE
61DC:  MOVF   xD9,W
61DE:  SUBLW  2A
61E0:  BZ    61EE
61E2:  MOVF   xD9,W
61E4:  SUBLW  40
61E6:  BC    6206
61E8:  MOVF   xD9,W
61EA:  SUBLW  5A
61EC:  BNC   6206
61EE:  CLRF   19
61F0:  BTFSC  FF2.7
61F2:  BSF    19.7
61F4:  BCF    FF2.7
....................                       { 
....................                          fprintf(COM2,"%c",ee_dat); 
61F6:  MOVFF  6D9,852
61FA:  MOVLB  0
61FC:  CALL   15C0
6200:  BTFSC  19.7
6202:  BSF    FF2.7
6204:  MOVLB  6
....................                       } 
....................                   } 
....................                   else 
6206:  BRA    623E
6208:  MOVLB  1
620A:  CLRF   19
620C:  BTFSC  FF2.7
620E:  BSF    19.7
6210:  BCF    FF2.7
....................                   { 
....................                       fprintf(COM2," %x",ee_dat); 
6212:  MOVLW  20
6214:  MOVLB  8
6216:  MOVWF  x52
6218:  MOVLB  0
621A:  CALL   15C0
621E:  BTFSC  19.7
6220:  BSF    FF2.7
6222:  CLRF   19
6224:  BTFSC  FF2.7
6226:  BSF    19.7
6228:  BCF    FF2.7
622A:  MOVFF  6D9,83E
622E:  MOVLW  57
6230:  MOVLB  8
6232:  MOVWF  x3F
6234:  MOVLB  0
6236:  CALL   4D46
623A:  BTFSC  19.7
623C:  BSF    FF2.7
....................                   } 
....................                   i++; 
623E:  MOVLB  7
6240:  INCF   xBA,F
....................                } 
....................                while((i<wideofkeystore)&&(ee_dat!=0)); 
6242:  MOVF   xBA,W
6244:  SUBLW  0F
6246:  BNC   6254
6248:  MOVLB  6
624A:  MOVF   xD9,F
624C:  BTFSC  FD8.2
624E:  BRA    6254
6250:  MOVLB  7
6252:  BRA    6174
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+wideofkeystore; 
6254:  MOVLW  10
6256:  MOVLB  6
6258:  ADDWF  xDF,F
625A:  MOVLW  00
625C:  ADDWFC xE0,F
625E:  ADDWFC xE1,F
6260:  ADDWFC xE2,F
6262:  CLRF   19
6264:  BTFSC  FF2.7
6266:  BSF    19.7
6268:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
626A:  MOVLW  0A
626C:  MOVLB  8
626E:  MOVWF  x52
6270:  MOVLB  0
6272:  CALL   15C0
6276:  BTFSC  19.7
6278:  BSF    FF2.7
627A:  CLRF   19
627C:  BTFSC  FF2.7
627E:  BSF    19.7
6280:  BCF    FF2.7
6282:  MOVLW  0D
6284:  MOVLB  8
6286:  MOVWF  x52
6288:  MOVLB  0
628A:  CALL   15C0
628E:  BTFSC  19.7
6290:  BSF    FF2.7
6292:  MOVLB  6
....................             } 
....................             count_card++; 
6294:  INCF   xDA,F
6296:  BTFSC  FD8.2
6298:  INCF   xDB,F
....................          } 
629A:  BRA    5EE0
629C:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
629E:  CLRF   FEA
62A0:  MOVLW  41
62A2:  MOVWF  FE9
62A4:  MOVLW  00
62A6:  CALL   0368
62AA:  TBLRD*-
62AC:  TBLRD*+
62AE:  MOVF   FF5,W
62B0:  MOVWF  FEE
62B2:  IORLW  00
62B4:  BNZ   62AC
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
62B6:  MOVLW  01
62B8:  MOVLB  7
62BA:  MOVWF  xF2
62BC:  MOVLW  5E
62BE:  MOVWF  xF1
62C0:  CLRF   xF4
62C2:  MOVLW  41
62C4:  MOVWF  xF3
62C6:  MOVLB  0
62C8:  CALL   58CA
62CC:  MOVF   01,F
62CE:  BNZ   6302
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
62D0:  MOVLW  18
62D2:  MOVWF  FF6
62D4:  MOVLW  1C
62D6:  MOVWF  FF7
62D8:  CLRF   19
62DA:  BTFSC  FF2.7
62DC:  BSF    19.7
62DE:  BCF    FF2.7
62E0:  CALL   16EA
62E4:  BTFSC  19.7
62E6:  BSF    FF2.7
....................          format_eepromext(); 
62E8:  BRA    5AF2
....................          fprintf(COM2," exit\n\r");  
62EA:  MOVLW  26
62EC:  MOVWF  FF6
62EE:  MOVLW  1C
62F0:  MOVWF  FF7
62F2:  CLRF   19
62F4:  BTFSC  FF2.7
62F6:  BSF    19.7
62F8:  BCF    FF2.7
62FA:  CALL   16EA
62FE:  BTFSC  19.7
6300:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
6302:  CLRF   FEA
6304:  MOVLW  41
6306:  MOVWF  FE9
6308:  MOVLW  00
630A:  CALL   037A
630E:  TBLRD*-
6310:  TBLRD*+
6312:  MOVF   FF5,W
6314:  MOVWF  FEE
6316:  IORLW  00
6318:  BNZ   6310
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
631A:  MOVLW  01
631C:  MOVLB  7
631E:  MOVWF  xF2
6320:  MOVLW  5E
6322:  MOVWF  xF1
6324:  CLRF   xF4
6326:  MOVLW  41
6328:  MOVWF  xF3
632A:  MOVLB  0
632C:  CALL   58CA
6330:  MOVF   01,F
6332:  BNZ   6366
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6334:  MOVLW  2E
6336:  MOVWF  FF6
6338:  MOVLW  1C
633A:  MOVWF  FF7
633C:  CLRF   19
633E:  BTFSC  FF2.7
6340:  BSF    19.7
6342:  BCF    FF2.7
6344:  CALL   16EA
6348:  BTFSC  19.7
634A:  BSF    FF2.7
....................          ease_eeprom(); 
634C:  BRA    5B8E
....................          fprintf(COM2," exit\n\r");  
634E:  MOVLW  3C
6350:  MOVWF  FF6
6352:  MOVLW  1C
6354:  MOVWF  FF7
6356:  CLRF   19
6358:  BTFSC  FF2.7
635A:  BSF    19.7
635C:  BCF    FF2.7
635E:  CALL   16EA
6362:  BTFSC  19.7
6364:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6366:  CLRF   FEA
6368:  MOVLW  41
636A:  MOVWF  FE9
636C:  MOVLW  00
636E:  CALL   0390
6372:  TBLRD*-
6374:  TBLRD*+
6376:  MOVF   FF5,W
6378:  MOVWF  FEE
637A:  IORLW  00
637C:  BNZ   6374
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
637E:  MOVLW  01
6380:  MOVLB  7
6382:  MOVWF  xF2
6384:  MOVLW  5E
6386:  MOVWF  xF1
6388:  CLRF   xF4
638A:  MOVLW  41
638C:  MOVWF  xF3
638E:  MOVLB  0
6390:  CALL   58CA
6394:  MOVF   01,F
6396:  BNZ   63CE
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
6398:  MOVLW  44
639A:  MOVWF  FF6
639C:  MOVLW  1C
639E:  MOVWF  FF7
63A0:  CLRF   19
63A2:  BTFSC  FF2.7
63A4:  BSF    19.7
63A6:  BCF    FF2.7
63A8:  CALL   16EA
63AC:  BTFSC  19.7
63AE:  BSF    FF2.7
....................          reset_password(); 
63B0:  BRA    5C12
....................          init_password(); 
63B2:  CALL   551C
....................          fprintf(COM2," exit\n\r");  
63B6:  MOVLW  5A
63B8:  MOVWF  FF6
63BA:  MOVLW  1C
63BC:  MOVWF  FF7
63BE:  CLRF   19
63C0:  BTFSC  FF2.7
63C2:  BSF    19.7
63C4:  BCF    FF2.7
63C6:  CALL   16EA
63CA:  BTFSC  19.7
63CC:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
63CE:  CLRF   FEA
63D0:  MOVLW  41
63D2:  MOVWF  FE9
63D4:  MOVLW  00
63D6:  CALL   03A6
63DA:  TBLRD*-
63DC:  TBLRD*+
63DE:  MOVF   FF5,W
63E0:  MOVWF  FEE
63E2:  IORLW  00
63E4:  BNZ   63DC
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
63E6:  MOVLW  01
63E8:  MOVLB  7
63EA:  MOVWF  xF2
63EC:  MOVLW  5E
63EE:  MOVWF  xF1
63F0:  CLRF   xF4
63F2:  MOVLW  41
63F4:  MOVWF  xF3
63F6:  MOVLB  0
63F8:  CALL   58CA
63FC:  MOVF   01,F
63FE:  BNZ   6420
....................       { 
....................          keydebug_en=1; 
6400:  MOVLW  01
6402:  MOVLB  1
6404:  MOVWF  x40
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
6406:  MOVLW  62
6408:  MOVWF  FF6
640A:  MOVLW  1C
640C:  MOVWF  FF7
640E:  CLRF   19
6410:  BTFSC  FF2.7
6412:  BSF    19.7
6414:  BCF    FF2.7
6416:  MOVLB  0
6418:  CALL   16EA
641C:  BTFSC  19.7
641E:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
6420:  CLRF   FEA
6422:  MOVLW  41
6424:  MOVWF  FE9
6426:  MOVLW  00
6428:  CALL   03BC
642C:  TBLRD*-
642E:  TBLRD*+
6430:  MOVF   FF5,W
6432:  MOVWF  FEE
6434:  IORLW  00
6436:  BNZ   642E
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6438:  MOVLW  01
643A:  MOVLB  7
643C:  MOVWF  xF2
643E:  MOVLW  5E
6440:  MOVWF  xF1
6442:  CLRF   xF4
6444:  MOVLW  41
6446:  MOVWF  xF3
6448:  MOVLB  0
644A:  CALL   58CA
644E:  MOVF   01,F
6450:  BNZ   646E
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6452:  MOVLW  76
6454:  MOVWF  FF6
6456:  MOVLW  1C
6458:  MOVWF  FF7
645A:  CLRF   19
645C:  BTFSC  FF2.7
645E:  BSF    19.7
6460:  BCF    FF2.7
6462:  CALL   16EA
6466:  BTFSC  19.7
6468:  BSF    FF2.7
....................          rstfact(); 
646A:  GOTO   5C60
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
646E:  CLRF   FEA
6470:  MOVLW  41
6472:  MOVWF  FE9
6474:  MOVLW  00
6476:  CALL   03D4
647A:  TBLRD*-
647C:  TBLRD*+
647E:  MOVF   FF5,W
6480:  MOVWF  FEE
6482:  IORLW  00
6484:  BNZ   647C
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6486:  MOVLW  01
6488:  MOVLB  7
648A:  MOVWF  xF2
648C:  MOVLW  5E
648E:  MOVWF  xF1
6490:  CLRF   xF4
6492:  MOVLW  41
6494:  MOVWF  xF3
6496:  MOVLB  0
6498:  CALL   58CA
649C:  MOVF   01,F
649E:  BNZ   64C6
....................       { 
....................          mode=LOGOFF; 
64A0:  MOVLB  6
64A2:  CLRF   xD8
....................          keydebug_en=0; 
64A4:  MOVLB  1
64A6:  CLRF   x40
....................          set_tris_a(0xff); 
64A8:  MOVLW  FF
64AA:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
64AC:  MOVLW  86
64AE:  MOVWF  FF6
64B0:  MOVLW  1C
64B2:  MOVWF  FF7
64B4:  CLRF   19
64B6:  BTFSC  FF2.7
64B8:  BSF    19.7
64BA:  BCF    FF2.7
64BC:  MOVLB  0
64BE:  CALL   16EA
64C2:  BTFSC  19.7
64C4:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
64C6:  CLRF   FEA
64C8:  MOVLW  41
64CA:  MOVWF  FE9
64CC:  MOVLW  00
64CE:  CALL   03E6
64D2:  TBLRD*-
64D4:  TBLRD*+
64D6:  MOVF   FF5,W
64D8:  MOVWF  FEE
64DA:  IORLW  00
64DC:  BNZ   64D4
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
64DE:  MOVLW  01
64E0:  MOVLB  7
64E2:  MOVWF  xF2
64E4:  MOVLW  5E
64E6:  MOVWF  xF1
64E8:  CLRF   xF4
64EA:  MOVLW  41
64EC:  MOVWF  xF3
64EE:  MOVLB  0
64F0:  CALL   58CA
64F4:  MOVF   01,F
64F6:  BNZ   6570
....................       { 
....................          fprintf(COM2,"New console name>"); 
64F8:  MOVLW  8E
64FA:  MOVWF  FF6
64FC:  MOVLW  1C
64FE:  MOVWF  FF7
6500:  CLRF   19
6502:  BTFSC  FF2.7
6504:  BSF    19.7
6506:  BCF    FF2.7
6508:  CALL   16EA
650C:  BTFSC  19.7
650E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,wide_strobe_nameconsole, console); 
6510:  MOVLW  01
6512:  MOVLB  7
6514:  MOVWF  xF1
6516:  MOVLW  10
6518:  MOVWF  xF2
651A:  MOVLW  06
651C:  MOVWF  xF4
651E:  MOVLW  E3
6520:  MOVWF  xF3
6522:  MOVLB  0
6524:  CALL   5792
6528:  CLRF   19
652A:  BTFSC  FF2.7
652C:  BSF    19.7
652E:  BCF    FF2.7
....................          EEPROM_write(strobe_nameconsole,wide_strobe_nameconsole,console); 
6530:  MOVLB  8
6532:  CLRF   x40
6534:  CLRF   x3F
6536:  CLRF   x3E
6538:  MOVLW  28
653A:  MOVWF  x3D
653C:  CLRF   x44
653E:  CLRF   x43
6540:  CLRF   x42
6542:  MOVLW  10
6544:  MOVWF  x41
6546:  MOVLW  06
6548:  MOVWF  x46
654A:  MOVLW  E3
654C:  MOVWF  x45
654E:  MOVLB  0
6550:  CALL   4D90
6554:  BTFSC  19.7
6556:  BSF    FF2.7
....................          fprintf(COM2," OK\n\r"); 
6558:  MOVLW  A0
655A:  MOVWF  FF6
655C:  MOVLW  1C
655E:  MOVWF  FF7
6560:  CLRF   19
6562:  BTFSC  FF2.7
6564:  BSF    19.7
6566:  BCF    FF2.7
6568:  CALL   16EA
656C:  BTFSC  19.7
656E:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
6570:  CLRF   FEA
6572:  MOVLW  41
6574:  MOVWF  FE9
6576:  MOVLW  00
6578:  CALL   03F8
657C:  TBLRD*-
657E:  TBLRD*+
6580:  MOVF   FF5,W
6582:  MOVWF  FEE
6584:  IORLW  00
6586:  BNZ   657E
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6588:  MOVLW  01
658A:  MOVLB  7
658C:  MOVWF  xF2
658E:  MOVLW  5E
6590:  MOVWF  xF1
6592:  CLRF   xF4
6594:  MOVLW  41
6596:  MOVWF  xF3
6598:  MOVLB  0
659A:  CALL   58CA
659E:  MOVF   01,F
65A0:  BTFSS  FD8.2
65A2:  BRA    6746
65A4:  CLRF   19
65A6:  BTFSC  FF2.7
65A8:  BSF    19.7
65AA:  BCF    FF2.7
....................       { 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
65AC:  MOVLB  8
65AE:  CLRF   x46
65B0:  CLRF   x45
65B2:  CLRF   x44
65B4:  MOVLW  3A
65B6:  MOVWF  x43
65B8:  MOVLB  0
65BA:  CALL   3400
65BE:  BTFSC  19.7
65C0:  BSF    FF2.7
65C2:  MOVFF  01,6DE
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
65C6:  MOVLB  6
65C8:  MOVF   xDE,F
65CA:  BNZ   65EA
65CC:  MOVLW  A6
65CE:  MOVWF  FF6
65D0:  MOVLW  1C
65D2:  MOVWF  FF7
65D4:  CLRF   19
65D6:  BTFSC  FF2.7
65D8:  BSF    19.7
65DA:  BCF    FF2.7
65DC:  MOVLB  0
65DE:  CALL   16EA
65E2:  BTFSC  19.7
65E4:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
65E6:  BRA    6604
65E8:  MOVLB  6
65EA:  MOVLW  AA
65EC:  MOVWF  FF6
65EE:  MOVLW  1C
65F0:  MOVWF  FF7
65F2:  CLRF   19
65F4:  BTFSC  FF2.7
65F6:  BSF    19.7
65F8:  BCF    FF2.7
65FA:  MOVLB  0
65FC:  CALL   16EA
6600:  BTFSC  19.7
6602:  BSF    FF2.7
6604:  CLRF   19
6606:  BTFSC  FF2.7
6608:  BSF    19.7
660A:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
660C:  MOVLB  8
660E:  CLRF   x46
6610:  CLRF   x45
6612:  CLRF   x44
6614:  MOVLW  3C
6616:  MOVWF  x43
6618:  MOVLB  0
661A:  CALL   3400
661E:  BTFSC  19.7
6620:  BSF    FF2.7
6622:  MOVFF  01,156
6626:  CLRF   19
6628:  BTFSC  FF2.7
662A:  BSF    19.7
662C:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
662E:  MOVLW  5B
6630:  MOVLB  8
6632:  MOVWF  x52
6634:  MOVLB  0
6636:  CALL   15C0
663A:  BTFSC  19.7
663C:  BSF    FF2.7
663E:  MOVFF  156,7F1
6642:  MOVLW  1B
6644:  MOVLB  7
6646:  MOVWF  xF2
6648:  MOVLB  0
664A:  GOTO   5CCA
664E:  CLRF   19
6650:  BTFSC  FF2.7
6652:  BSF    19.7
6654:  BCF    FF2.7
6656:  MOVLW  5D
6658:  MOVLB  8
665A:  MOVWF  x52
665C:  MOVLB  0
665E:  CALL   15C0
6662:  BTFSC  19.7
6664:  BSF    FF2.7
....................           
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
6666:  MOVFF  1C7,7F1
666A:  MOVLW  01
666C:  MOVLB  7
666E:  MOVWF  xF2
6670:  MOVLB  0
6672:  CALL   59D8
6676:  CLRF   19
6678:  BTFSC  FF2.7
667A:  BSF    19.7
667C:  BCF    FF2.7
667E:  MOVLW  2F
6680:  MOVLB  8
6682:  MOVWF  x52
6684:  MOVLB  0
6686:  CALL   15C0
668A:  BTFSC  19.7
668C:  BSF    FF2.7
668E:  MOVFF  1C6,7F1
6692:  MOVLW  01
6694:  MOVLB  7
6696:  MOVWF  xF2
6698:  MOVLB  0
669A:  CALL   59D8
669E:  CLRF   19
66A0:  BTFSC  FF2.7
66A2:  BSF    19.7
66A4:  BCF    FF2.7
66A6:  MOVLW  20
66A8:  MOVLB  8
66AA:  MOVWF  x52
66AC:  MOVLB  0
66AE:  CALL   15C0
66B2:  BTFSC  19.7
66B4:  BSF    FF2.7
66B6:  MOVFF  1C8,7F1
66BA:  MOVLW  01
66BC:  MOVLB  7
66BE:  MOVWF  xF2
66C0:  MOVLB  0
66C2:  CALL   59D8
66C6:  CLRF   19
66C8:  BTFSC  FF2.7
66CA:  BSF    19.7
66CC:  BCF    FF2.7
66CE:  MOVLW  3A
66D0:  MOVLB  8
66D2:  MOVWF  x52
66D4:  MOVLB  0
66D6:  CALL   15C0
66DA:  BTFSC  19.7
66DC:  BSF    FF2.7
66DE:  MOVFF  1C9,7F1
66E2:  MOVLW  01
66E4:  MOVLB  7
66E6:  MOVWF  xF2
66E8:  MOVLB  0
66EA:  CALL   59D8
66EE:  CLRF   19
66F0:  BTFSC  FF2.7
66F2:  BSF    19.7
66F4:  BCF    FF2.7
66F6:  MOVLW  3A
66F8:  MOVLB  8
66FA:  MOVWF  x52
66FC:  MOVLB  0
66FE:  CALL   15C0
6702:  BTFSC  19.7
6704:  BSF    FF2.7
6706:  MOVFF  1CA,7F1
670A:  MOVLW  01
670C:  MOVLB  7
670E:  MOVWF  xF2
6710:  MOVLB  0
6712:  CALL   59D8
6716:  CLRF   19
6718:  BTFSC  FF2.7
671A:  BSF    19.7
671C:  BCF    FF2.7
....................           
....................          fprintf(COM2,"\n\r"); 
671E:  MOVLW  0A
6720:  MOVLB  8
6722:  MOVWF  x52
6724:  MOVLB  0
6726:  CALL   15C0
672A:  BTFSC  19.7
672C:  BSF    FF2.7
672E:  CLRF   19
6730:  BTFSC  FF2.7
6732:  BSF    19.7
6734:  BCF    FF2.7
6736:  MOVLW  0D
6738:  MOVLB  8
673A:  MOVWF  x52
673C:  MOVLB  0
673E:  CALL   15C0
6742:  BTFSC  19.7
6744:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
6746:  CLRF   FEA
6748:  MOVLW  41
674A:  MOVWF  FE9
674C:  MOVLW  00
674E:  CALL   040A
6752:  TBLRD*-
6754:  TBLRD*+
6756:  MOVF   FF5,W
6758:  MOVWF  FEE
675A:  IORLW  00
675C:  BNZ   6754
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
675E:  MOVLW  01
6760:  MOVLB  7
6762:  MOVWF  xF2
6764:  MOVLW  5E
6766:  MOVWF  xF1
6768:  CLRF   xF4
676A:  MOVLW  41
676C:  MOVWF  xF3
676E:  MOVLB  0
6770:  CALL   58CA
6774:  MOVF   01,F
6776:  BTFSS  FD8.2
6778:  BRA    6986
....................       { 
....................          fprintf(COM2,"Year>"); 
677A:  MOVLW  AE
677C:  MOVWF  FF6
677E:  MOVLW  1C
6780:  MOVWF  FF7
6782:  CLRF   19
6784:  BTFSC  FF2.7
6786:  BSF    19.7
6788:  BCF    FF2.7
678A:  CALL   16EA
678E:  BTFSC  19.7
6790:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6792:  MOVLW  01
6794:  MOVLB  7
6796:  MOVWF  xF1
6798:  MOVLW  03
679A:  MOVWF  xF2
679C:  MOVLW  07
679E:  MOVWF  xF4
67A0:  MOVLW  BD
67A2:  MOVWF  xF3
67A4:  MOVLB  0
67A6:  CALL   5792
....................          year=(unsigned int8)strtoi(temp); 
67AA:  MOVLW  07
67AC:  MOVLB  7
67AE:  MOVWF  xF2
67B0:  MOVLW  BD
67B2:  MOVWF  xF1
67B4:  MOVLB  0
67B6:  CALL   5D90
67BA:  MOVFF  01,1C5
....................          fprintf(COM2,"Month>"); 
67BE:  MOVLW  B4
67C0:  MOVWF  FF6
67C2:  MOVLW  1C
67C4:  MOVWF  FF7
67C6:  CLRF   19
67C8:  BTFSC  FF2.7
67CA:  BSF    19.7
67CC:  BCF    FF2.7
67CE:  CALL   16EA
67D2:  BTFSC  19.7
67D4:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
67D6:  MOVLW  01
67D8:  MOVLB  7
67DA:  MOVWF  xF1
67DC:  MOVLW  03
67DE:  MOVWF  xF2
67E0:  MOVLW  07
67E2:  MOVWF  xF4
67E4:  MOVLW  BD
67E6:  MOVWF  xF3
67E8:  MOVLB  0
67EA:  CALL   5792
....................          mon=(unsigned int8)strtoi(temp); 
67EE:  MOVLW  07
67F0:  MOVLB  7
67F2:  MOVWF  xF2
67F4:  MOVLW  BD
67F6:  MOVWF  xF1
67F8:  MOVLB  0
67FA:  CALL   5D90
67FE:  MOVFF  01,1C6
....................          fprintf(COM2,"Date>"); 
6802:  MOVLW  BC
6804:  MOVWF  FF6
6806:  MOVLW  1C
6808:  MOVWF  FF7
680A:  CLRF   19
680C:  BTFSC  FF2.7
680E:  BSF    19.7
6810:  BCF    FF2.7
6812:  CALL   16EA
6816:  BTFSC  19.7
6818:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
681A:  MOVLW  01
681C:  MOVLB  7
681E:  MOVWF  xF1
6820:  MOVLW  03
6822:  MOVWF  xF2
6824:  MOVLW  07
6826:  MOVWF  xF4
6828:  MOVLW  BD
682A:  MOVWF  xF3
682C:  MOVLB  0
682E:  CALL   5792
....................          date = (unsigned int8)strtoi(temp); 
6832:  MOVLW  07
6834:  MOVLB  7
6836:  MOVWF  xF2
6838:  MOVLW  BD
683A:  MOVWF  xF1
683C:  MOVLB  0
683E:  CALL   5D90
6842:  MOVFF  01,1C7
....................          fprintf(COM2,"Day>"); 
6846:  MOVLW  C2
6848:  MOVWF  FF6
684A:  MOVLW  1C
684C:  MOVWF  FF7
684E:  CLRF   19
6850:  BTFSC  FF2.7
6852:  BSF    19.7
6854:  BCF    FF2.7
6856:  CALL   16EA
685A:  BTFSC  19.7
685C:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
685E:  MOVLW  01
6860:  MOVLB  7
6862:  MOVWF  xF1
6864:  MOVLW  03
6866:  MOVWF  xF2
6868:  MOVLW  07
686A:  MOVWF  xF4
686C:  MOVLW  BD
686E:  MOVWF  xF3
6870:  MOVLB  0
6872:  CALL   5792
....................          day = (unsigned int8)strtoi(temp); 
6876:  MOVLW  07
6878:  MOVLB  7
687A:  MOVWF  xF2
687C:  MOVLW  BD
687E:  MOVWF  xF1
6880:  MOVLB  0
6882:  CALL   5D90
6886:  MOVFF  01,1C4
....................          fprintf(COM2,"Hour>"); 
688A:  MOVLW  C8
688C:  MOVWF  FF6
688E:  MOVLW  1C
6890:  MOVWF  FF7
6892:  CLRF   19
6894:  BTFSC  FF2.7
6896:  BSF    19.7
6898:  BCF    FF2.7
689A:  CALL   16EA
689E:  BTFSC  19.7
68A0:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
68A2:  MOVLW  01
68A4:  MOVLB  7
68A6:  MOVWF  xF1
68A8:  MOVLW  03
68AA:  MOVWF  xF2
68AC:  MOVLW  07
68AE:  MOVWF  xF4
68B0:  MOVLW  BD
68B2:  MOVWF  xF3
68B4:  MOVLB  0
68B6:  CALL   5792
....................          h = (unsigned int8)strtoi(temp); 
68BA:  MOVLW  07
68BC:  MOVLB  7
68BE:  MOVWF  xF2
68C0:  MOVLW  BD
68C2:  MOVWF  xF1
68C4:  MOVLB  0
68C6:  CALL   5D90
68CA:  MOVFF  01,1C8
....................          fprintf(COM2,"Minutes>"); 
68CE:  MOVLW  CE
68D0:  MOVWF  FF6
68D2:  MOVLW  1C
68D4:  MOVWF  FF7
68D6:  CLRF   19
68D8:  BTFSC  FF2.7
68DA:  BSF    19.7
68DC:  BCF    FF2.7
68DE:  CALL   16EA
68E2:  BTFSC  19.7
68E4:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
68E6:  MOVLW  01
68E8:  MOVLB  7
68EA:  MOVWF  xF1
68EC:  MOVLW  03
68EE:  MOVWF  xF2
68F0:  MOVLW  07
68F2:  MOVWF  xF4
68F4:  MOVLW  BD
68F6:  MOVWF  xF3
68F8:  MOVLB  0
68FA:  CALL   5792
....................          min = (unsigned int8)strtoi(temp);                   
68FE:  MOVLW  07
6900:  MOVLB  7
6902:  MOVWF  xF2
6904:  MOVLW  BD
6906:  MOVWF  xF1
6908:  MOVLB  0
690A:  CALL   5D90
690E:  MOVFF  01,1C9
....................          fprintf(COM2,"Seconds>"); 
6912:  MOVLW  D8
6914:  MOVWF  FF6
6916:  MOVLW  1C
6918:  MOVWF  FF7
691A:  CLRF   19
691C:  BTFSC  FF2.7
691E:  BSF    19.7
6920:  BCF    FF2.7
6922:  CALL   16EA
6926:  BTFSC  19.7
6928:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
692A:  MOVLW  01
692C:  MOVLB  7
692E:  MOVWF  xF1
6930:  MOVLW  03
6932:  MOVWF  xF2
6934:  MOVLW  07
6936:  MOVWF  xF4
6938:  MOVLW  BD
693A:  MOVWF  xF3
693C:  MOVLB  0
693E:  CALL   5792
....................          sec = (unsigned int8)strtoi(temp);                   
6942:  MOVLW  07
6944:  MOVLB  7
6946:  MOVWF  xF2
6948:  MOVLW  BD
694A:  MOVWF  xF1
694C:  MOVLB  0
694E:  CALL   5D90
6952:  MOVFF  01,1CA
6956:  CLRF   19
6958:  BTFSC  FF2.7
695A:  BSF    19.7
695C:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
695E:  MOVLW  0A
6960:  MOVLB  8
6962:  MOVWF  x52
6964:  MOVLB  0
6966:  CALL   15C0
696A:  BTFSC  19.7
696C:  BSF    FF2.7
696E:  CLRF   19
6970:  BTFSC  FF2.7
6972:  BSF    19.7
6974:  BCF    FF2.7
6976:  MOVLW  0D
6978:  MOVLB  8
697A:  MOVWF  x52
697C:  MOVLB  0
697E:  CALL   15C0
6982:  BTFSC  19.7
6984:  BSF    FF2.7
....................          /* rtc_set_datetime(date,mon,year,day,h,min); */ 
....................       } 
....................       strcpy(buffer2,"MS"); 
6986:  CLRF   FEA
6988:  MOVLW  41
698A:  MOVWF  FE9
698C:  MOVLW  00
698E:  CALL   041E
6992:  TBLRD*-
6994:  TBLRD*+
6996:  MOVF   FF5,W
6998:  MOVWF  FEE
699A:  IORLW  00
699C:  BNZ   6994
....................       if(!stringcomp(buffer_uart,buffer2)) 
699E:  MOVLW  01
69A0:  MOVLB  7
69A2:  MOVWF  xF2
69A4:  MOVLW  5E
69A6:  MOVWF  xF1
69A8:  CLRF   xF4
69AA:  MOVLW  41
69AC:  MOVWF  xF3
69AE:  MOVLB  0
69B0:  CALL   58CA
69B4:  MOVF   01,F
69B6:  BTFSS  FD8.2
69B8:  BRA    6ACC
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
69BA:  MOVLW  E2
69BC:  MOVWF  FF6
69BE:  MOVLW  1C
69C0:  MOVWF  FF7
69C2:  CLRF   19
69C4:  BTFSC  FF2.7
69C6:  BSF    19.7
69C8:  BCF    FF2.7
69CA:  CALL   16EA
69CE:  BTFSC  19.7
69D0:  BSF    FF2.7
69D2:  CLRF   19
69D4:  BTFSC  FF2.7
69D6:  BSF    19.7
69D8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
69DA:  MOVLW  0A
69DC:  MOVLB  8
69DE:  MOVWF  x52
69E0:  MOVLB  0
69E2:  CALL   15C0
69E6:  BTFSC  19.7
69E8:  BSF    FF2.7
69EA:  CLRF   19
69EC:  BTFSC  FF2.7
69EE:  BSF    19.7
69F0:  BCF    FF2.7
69F2:  MOVLW  0D
69F4:  MOVLB  8
69F6:  MOVWF  x52
69F8:  MOVLB  0
69FA:  CALL   15C0
69FE:  BTFSC  19.7
6A00:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
6A02:  MOVLW  02
6A04:  MOVWF  FF6
6A06:  MOVLW  1D
6A08:  MOVWF  FF7
6A0A:  CLRF   19
6A0C:  BTFSC  FF2.7
6A0E:  BSF    19.7
6A10:  BCF    FF2.7
6A12:  CALL   16EA
6A16:  BTFSC  19.7
6A18:  BSF    FF2.7
6A1A:  CLRF   19
6A1C:  BTFSC  FF2.7
6A1E:  BSF    19.7
6A20:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6A22:  MOVLW  0A
6A24:  MOVLB  8
6A26:  MOVWF  x52
6A28:  MOVLB  0
6A2A:  CALL   15C0
6A2E:  BTFSC  19.7
6A30:  BSF    FF2.7
6A32:  CLRF   19
6A34:  BTFSC  FF2.7
6A36:  BSF    19.7
6A38:  BCF    FF2.7
6A3A:  MOVLW  0D
6A3C:  MOVLB  8
6A3E:  MOVWF  x52
6A40:  MOVLB  0
6A42:  CALL   15C0
6A46:  BTFSC  19.7
6A48:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6A4A:  MOVLW  01
6A4C:  MOVLB  7
6A4E:  MOVWF  xF1
6A50:  MOVLW  03
6A52:  MOVWF  xF2
6A54:  MOVLW  07
6A56:  MOVWF  xF4
6A58:  MOVLW  BD
6A5A:  MOVWF  xF3
6A5C:  MOVLB  0
6A5E:  CALL   5792
....................           mode_sl = (unsigned int8)strtoi(temp); 
6A62:  MOVLW  07
6A64:  MOVLB  7
6A66:  MOVWF  xF2
6A68:  MOVLW  BD
6A6A:  MOVWF  xF1
6A6C:  MOVLB  0
6A6E:  CALL   5D90
6A72:  MOVFF  01,6DE
6A76:  CLRF   19
6A78:  BTFSC  FF2.7
6A7A:  BSF    19.7
6A7C:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
6A7E:  MOVLB  8
6A80:  CLRF   x53
6A82:  CLRF   x52
6A84:  CLRF   x51
6A86:  MOVLW  3A
6A88:  MOVWF  x50
6A8A:  MOVFF  6DE,854
6A8E:  MOVLB  0
6A90:  CALL   3934
6A94:  BTFSC  19.7
6A96:  BSF    FF2.7
....................           set_tris_a(0xff); 
6A98:  MOVLW  FF
6A9A:  MOVWF  F92
6A9C:  CLRF   19
6A9E:  BTFSC  FF2.7
6AA0:  BSF    19.7
6AA2:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6AA4:  MOVLW  0A
6AA6:  MOVLB  8
6AA8:  MOVWF  x52
6AAA:  MOVLB  0
6AAC:  CALL   15C0
6AB0:  BTFSC  19.7
6AB2:  BSF    FF2.7
6AB4:  CLRF   19
6AB6:  BTFSC  FF2.7
6AB8:  BSF    19.7
6ABA:  BCF    FF2.7
6ABC:  MOVLW  0D
6ABE:  MOVLB  8
6AC0:  MOVWF  x52
6AC2:  MOVLB  0
6AC4:  CALL   15C0
6AC8:  BTFSC  19.7
6ACA:  BSF    FF2.7
....................       } 
....................       
....................       strcpy(buffer2,"tran time"); 
6ACC:  CLRF   FEA
6ACE:  MOVLW  41
6AD0:  MOVWF  FE9
6AD2:  MOVLW  00
6AD4:  CALL   0432
6AD8:  TBLRD*-
6ADA:  TBLRD*+
6ADC:  MOVF   FF5,W
6ADE:  MOVWF  FEE
6AE0:  IORLW  00
6AE2:  BNZ   6ADA
....................       if(!stringcomp(buffer_uart,buffer2)) 
6AE4:  MOVLW  01
6AE6:  MOVLB  7
6AE8:  MOVWF  xF2
6AEA:  MOVLW  5E
6AEC:  MOVWF  xF1
6AEE:  CLRF   xF4
6AF0:  MOVLW  41
6AF2:  MOVWF  xF3
6AF4:  MOVLB  0
6AF6:  CALL   58CA
6AFA:  MOVF   01,F
6AFC:  BNZ   6BC4
....................       { 
....................           fprintf(COM2,"Input Number"); 
6AFE:  MOVLW  22
6B00:  MOVWF  FF6
6B02:  MOVLW  1D
6B04:  MOVWF  FF7
6B06:  CLRF   19
6B08:  BTFSC  FF2.7
6B0A:  BSF    19.7
6B0C:  BCF    FF2.7
6B0E:  CALL   16EA
6B12:  BTFSC  19.7
6B14:  BSF    FF2.7
6B16:  CLRF   19
6B18:  BTFSC  FF2.7
6B1A:  BSF    19.7
6B1C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6B1E:  MOVLW  0A
6B20:  MOVLB  8
6B22:  MOVWF  x52
6B24:  MOVLB  0
6B26:  CALL   15C0
6B2A:  BTFSC  19.7
6B2C:  BSF    FF2.7
6B2E:  CLRF   19
6B30:  BTFSC  FF2.7
6B32:  BSF    19.7
6B34:  BCF    FF2.7
6B36:  MOVLW  0D
6B38:  MOVLB  8
6B3A:  MOVWF  x52
6B3C:  MOVLB  0
6B3E:  CALL   15C0
6B42:  BTFSC  19.7
6B44:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6B46:  MOVLW  01
6B48:  MOVLB  7
6B4A:  MOVWF  xF1
6B4C:  MOVLW  03
6B4E:  MOVWF  xF2
6B50:  MOVLW  07
6B52:  MOVWF  xF4
6B54:  MOVLW  BD
6B56:  MOVWF  xF3
6B58:  MOVLB  0
6B5A:  CALL   5792
....................           delaycharaction = (unsigned int8)strtoi(temp); 
6B5E:  MOVLW  07
6B60:  MOVLB  7
6B62:  MOVWF  xF2
6B64:  MOVLW  BD
6B66:  MOVWF  xF1
6B68:  MOVLB  0
6B6A:  CALL   5D90
6B6E:  MOVFF  01,156
6B72:  CLRF   19
6B74:  BTFSC  FF2.7
6B76:  BSF    19.7
6B78:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
6B7A:  MOVLB  8
6B7C:  CLRF   x53
6B7E:  CLRF   x52
6B80:  CLRF   x51
6B82:  MOVLW  3C
6B84:  MOVWF  x50
6B86:  MOVFF  156,854
6B8A:  MOVLB  0
6B8C:  CALL   3934
6B90:  BTFSC  19.7
6B92:  BSF    FF2.7
6B94:  CLRF   19
6B96:  BTFSC  FF2.7
6B98:  BSF    19.7
6B9A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6B9C:  MOVLW  0A
6B9E:  MOVLB  8
6BA0:  MOVWF  x52
6BA2:  MOVLB  0
6BA4:  CALL   15C0
6BA8:  BTFSC  19.7
6BAA:  BSF    FF2.7
6BAC:  CLRF   19
6BAE:  BTFSC  FF2.7
6BB0:  BSF    19.7
6BB2:  BCF    FF2.7
6BB4:  MOVLW  0D
6BB6:  MOVLB  8
6BB8:  MOVWF  x52
6BBA:  MOVLB  0
6BBC:  CALL   15C0
6BC0:  BTFSC  19.7
6BC2:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
6BC4:  CLRF   FEA
6BC6:  MOVLW  41
6BC8:  MOVWF  FE9
6BCA:  MOVLW  00
6BCC:  CALL   044C
6BD0:  TBLRD*-
6BD2:  TBLRD*+
6BD4:  MOVF   FF5,W
6BD6:  MOVWF  FEE
6BD8:  IORLW  00
6BDA:  BNZ   6BD2
....................       if(!stringcomp(buffer_uart,buffer2)) 
6BDC:  MOVLW  01
6BDE:  MOVLB  7
6BE0:  MOVWF  xF2
6BE2:  MOVLW  5E
6BE4:  MOVWF  xF1
6BE6:  CLRF   xF4
6BE8:  MOVLW  41
6BEA:  MOVWF  xF3
6BEC:  MOVLB  0
6BEE:  CALL   58CA
6BF2:  MOVF   01,F
6BF4:  BTFSS  FD8.2
6BF6:  BRA    6D06
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
6BF8:  MOVLW  30
6BFA:  MOVWF  FF6
6BFC:  MOVLW  1D
6BFE:  MOVWF  FF7
6C00:  CLRF   19
6C02:  BTFSC  FF2.7
6C04:  BSF    19.7
6C06:  BCF    FF2.7
6C08:  CALL   16EA
6C0C:  BTFSC  19.7
6C0E:  BSF    FF2.7
6C10:  CLRF   19
6C12:  BTFSC  FF2.7
6C14:  BSF    19.7
6C16:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6C18:  MOVLW  0A
6C1A:  MOVLB  8
6C1C:  MOVWF  x52
6C1E:  MOVLB  0
6C20:  CALL   15C0
6C24:  BTFSC  19.7
6C26:  BSF    FF2.7
6C28:  CLRF   19
6C2A:  BTFSC  FF2.7
6C2C:  BSF    19.7
6C2E:  BCF    FF2.7
6C30:  MOVLW  0D
6C32:  MOVLB  8
6C34:  MOVWF  x52
6C36:  MOVLB  0
6C38:  CALL   15C0
6C3C:  BTFSC  19.7
6C3E:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
6C40:  MOVLW  56
6C42:  MOVWF  FF6
6C44:  MOVLW  1D
6C46:  MOVWF  FF7
6C48:  CLRF   19
6C4A:  BTFSC  FF2.7
6C4C:  BSF    19.7
6C4E:  BCF    FF2.7
6C50:  CALL   16EA
6C54:  BTFSC  19.7
6C56:  BSF    FF2.7
6C58:  CLRF   19
6C5A:  BTFSC  FF2.7
6C5C:  BSF    19.7
6C5E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6C60:  MOVLW  0A
6C62:  MOVLB  8
6C64:  MOVWF  x52
6C66:  MOVLB  0
6C68:  CALL   15C0
6C6C:  BTFSC  19.7
6C6E:  BSF    FF2.7
6C70:  CLRF   19
6C72:  BTFSC  FF2.7
6C74:  BSF    19.7
6C76:  BCF    FF2.7
6C78:  MOVLW  0D
6C7A:  MOVLB  8
6C7C:  MOVWF  x52
6C7E:  MOVLB  0
6C80:  CALL   15C0
6C84:  BTFSC  19.7
6C86:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6C88:  MOVLW  01
6C8A:  MOVLB  7
6C8C:  MOVWF  xF1
6C8E:  MOVLW  03
6C90:  MOVWF  xF2
6C92:  MOVLW  07
6C94:  MOVWF  xF4
6C96:  MOVLW  BD
6C98:  MOVWF  xF3
6C9A:  MOVLB  0
6C9C:  CALL   5792
....................           type_KB=(unsigned int8)strtoi(temp); 
6CA0:  MOVLW  07
6CA2:  MOVLB  7
6CA4:  MOVWF  xF2
6CA6:  MOVLW  BD
6CA8:  MOVWF  xF1
6CAA:  MOVLB  0
6CAC:  CALL   5D90
6CB0:  MOVFF  01,145
6CB4:  CLRF   19
6CB6:  BTFSC  FF2.7
6CB8:  BSF    19.7
6CBA:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
6CBC:  MOVLB  8
6CBE:  CLRF   x53
6CC0:  CLRF   x52
6CC2:  CLRF   x51
6CC4:  MOVLW  3D
6CC6:  MOVWF  x50
6CC8:  MOVFF  145,854
6CCC:  MOVLB  0
6CCE:  CALL   3934
6CD2:  BTFSC  19.7
6CD4:  BSF    FF2.7
6CD6:  CLRF   19
6CD8:  BTFSC  FF2.7
6CDA:  BSF    19.7
6CDC:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
6CDE:  MOVLW  0A
6CE0:  MOVLB  8
6CE2:  MOVWF  x52
6CE4:  MOVLB  0
6CE6:  CALL   15C0
6CEA:  BTFSC  19.7
6CEC:  BSF    FF2.7
6CEE:  CLRF   19
6CF0:  BTFSC  FF2.7
6CF2:  BSF    19.7
6CF4:  BCF    FF2.7
6CF6:  MOVLW  0D
6CF8:  MOVLB  8
6CFA:  MOVWF  x52
6CFC:  MOVLB  0
6CFE:  CALL   15C0
6D02:  BTFSC  19.7
6D04:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       strcpy(buffer2,"h"); 
6D06:  CLRF   FEA
6D08:  MOVLW  41
6D0A:  MOVWF  FE9
6D0C:  MOVLW  00
6D0E:  CALL   0462
6D12:  TBLRD*-
6D14:  TBLRD*+
6D16:  MOVF   FF5,W
6D18:  MOVWF  FEE
6D1A:  IORLW  00
6D1C:  BNZ   6D14
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
6D1E:  MOVLW  01
6D20:  MOVLB  7
6D22:  MOVWF  xF2
6D24:  MOVLW  5E
6D26:  MOVWF  xF1
6D28:  CLRF   xF4
6D2A:  MOVLW  41
6D2C:  MOVWF  xF3
6D2E:  MOVLB  0
6D30:  CALL   58CA
6D34:  MOVF   01,F
6D36:  BTFSS  FD8.2
6D38:  BRA    6EA8
....................       { 
....................          printf("h-> Help\n\r"); 
6D3A:  MOVLW  7C
6D3C:  MOVWF  FF6
6D3E:  MOVLW  1D
6D40:  MOVWF  FF7
6D42:  CLRF   19
6D44:  BTFSC  FF2.7
6D46:  BSF    19.7
6D48:  BCF    FF2.7
6D4A:  CALL   16EA
6D4E:  BTFSC  19.7
6D50:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
6D52:  MOVLW  88
6D54:  MOVWF  FF6
6D56:  MOVLW  1D
6D58:  MOVWF  FF7
6D5A:  CLRF   19
6D5C:  BTFSC  FF2.7
6D5E:  BSF    19.7
6D60:  BCF    FF2.7
6D62:  CALL   16EA
6D66:  BTFSC  19.7
6D68:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
6D6A:  MOVLW  9A
6D6C:  MOVWF  FF6
6D6E:  MOVLW  1D
6D70:  MOVWF  FF7
6D72:  CLRF   19
6D74:  BTFSC  FF2.7
6D76:  BSF    19.7
6D78:  BCF    FF2.7
6D7A:  CALL   16EA
6D7E:  BTFSC  19.7
6D80:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
6D82:  MOVLW  AC
6D84:  MOVWF  FF6
6D86:  MOVLW  1D
6D88:  MOVWF  FF7
6D8A:  CLRF   19
6D8C:  BTFSC  FF2.7
6D8E:  BSF    19.7
6D90:  BCF    FF2.7
6D92:  CALL   16EA
6D96:  BTFSC  19.7
6D98:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
6D9A:  MOVLW  CC
6D9C:  MOVWF  FF6
6D9E:  MOVLW  1D
6DA0:  MOVWF  FF7
6DA2:  CLRF   19
6DA4:  BTFSC  FF2.7
6DA6:  BSF    19.7
6DA8:  BCF    FF2.7
6DAA:  CALL   16EA
6DAE:  BTFSC  19.7
6DB0:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
6DB2:  MOVLW  E8
6DB4:  MOVWF  FF6
6DB6:  MOVLW  1D
6DB8:  MOVWF  FF7
6DBA:  CLRF   19
6DBC:  BTFSC  FF2.7
6DBE:  BSF    19.7
6DC0:  BCF    FF2.7
6DC2:  CALL   16EA
6DC6:  BTFSC  19.7
6DC8:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
6DCA:  MOVLW  F6
6DCC:  MOVWF  FF6
6DCE:  MOVLW  1D
6DD0:  MOVWF  FF7
6DD2:  CLRF   19
6DD4:  BTFSC  FF2.7
6DD6:  BSF    19.7
6DD8:  BCF    FF2.7
6DDA:  CALL   16EA
6DDE:  BTFSC  19.7
6DE0:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
6DE2:  MOVLW  02
6DE4:  MOVWF  FF6
6DE6:  MOVLW  1E
6DE8:  MOVWF  FF7
6DEA:  CLRF   19
6DEC:  BTFSC  FF2.7
6DEE:  BSF    19.7
6DF0:  BCF    FF2.7
6DF2:  CALL   16EA
6DF6:  BTFSC  19.7
6DF8:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
6DFA:  MOVLW  2A
6DFC:  MOVWF  FF6
6DFE:  MOVLW  1E
6E00:  MOVWF  FF7
6E02:  CLRF   19
6E04:  BTFSC  FF2.7
6E06:  BSF    19.7
6E08:  BCF    FF2.7
6E0A:  CALL   16EA
6E0E:  BTFSC  19.7
6E10:  BSF    FF2.7
6E12:  CLRF   19
6E14:  BTFSC  FF2.7
6E16:  BSF    19.7
6E18:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
6E1A:  MOVLB  8
6E1C:  CLRF   x46
6E1E:  CLRF   x45
6E20:  CLRF   x44
6E22:  MOVLW  3D
6E24:  MOVWF  x43
6E26:  MOVLB  0
6E28:  CALL   3400
6E2C:  BTFSC  19.7
6E2E:  BSF    FF2.7
6E30:  MOVFF  01,7F1
6E34:  MOVLW  46
6E36:  MOVWF  FF6
6E38:  MOVLW  1E
6E3A:  MOVWF  FF7
6E3C:  CLRF   19
6E3E:  BTFSC  FF2.7
6E40:  BSF    19.7
6E42:  BCF    FF2.7
6E44:  MOVLW  06
6E46:  MOVLB  8
6E48:  MOVWF  x46
6E4A:  MOVLB  0
6E4C:  CALL   1606
6E50:  BTFSC  19.7
6E52:  BSF    FF2.7
6E54:  CLRF   19
6E56:  BTFSC  FF2.7
6E58:  BSF    19.7
6E5A:  BCF    FF2.7
6E5C:  MOVFF  7F1,832
6E60:  MOVLW  18
6E62:  MOVLB  8
6E64:  MOVWF  x33
6E66:  MOVLB  0
6E68:  CALL   1736
6E6C:  BTFSC  19.7
6E6E:  BSF    FF2.7
6E70:  MOVLW  4E
6E72:  MOVWF  FF6
6E74:  MOVLW  1E
6E76:  MOVWF  FF7
6E78:  CLRF   19
6E7A:  BTFSC  FF2.7
6E7C:  BSF    19.7
6E7E:  BCF    FF2.7
6E80:  MOVLW  1D
6E82:  MOVLB  8
6E84:  MOVWF  x46
6E86:  MOVLB  0
6E88:  CALL   1606
6E8C:  BTFSC  19.7
6E8E:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
6E90:  MOVLW  6C
6E92:  MOVWF  FF6
6E94:  MOVLW  1E
6E96:  MOVWF  FF7
6E98:  CLRF   19
6E9A:  BTFSC  FF2.7
6E9C:  BSF    19.7
6E9E:  BCF    FF2.7
6EA0:  CALL   16EA
6EA4:  BTFSC  19.7
6EA6:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................       } 
....................       strcpy(buffer2,"password"); 
6EA8:  CLRF   FEA
6EAA:  MOVLW  41
6EAC:  MOVWF  FE9
6EAE:  MOVLW  00
6EB0:  CALL   0474
6EB4:  TBLRD*-
6EB6:  TBLRD*+
6EB8:  MOVF   FF5,W
6EBA:  MOVWF  FEE
6EBC:  IORLW  00
6EBE:  BNZ   6EB6
....................       if(!stringcomp(buffer_uart,buffer2))  
6EC0:  MOVLW  01
6EC2:  MOVLB  7
6EC4:  MOVWF  xF2
6EC6:  MOVLW  5E
6EC8:  MOVWF  xF1
6ECA:  CLRF   xF4
6ECC:  MOVLW  41
6ECE:  MOVWF  xF3
6ED0:  MOVLB  0
6ED2:  CALL   58CA
6ED6:  MOVF   01,F
6ED8:  BTFSS  FD8.2
6EDA:  BRA    702E
....................       { 
....................          fprintf(COM2,"old password:"); 
6EDC:  MOVLW  86
6EDE:  MOVWF  FF6
6EE0:  MOVLW  1E
6EE2:  MOVWF  FF7
6EE4:  CLRF   19
6EE6:  BTFSC  FF2.7
6EE8:  BSF    19.7
6EEA:  BCF    FF2.7
6EEC:  CALL   16EA
6EF0:  BTFSC  19.7
6EF2:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
6EF4:  MOVLB  7
6EF6:  CLRF   xF4
6EF8:  CLRF   xF3
6EFA:  CLRF   xF2
6EFC:  CLRF   xF1
6EFE:  CLRF   xF8
6F00:  CLRF   xF7
6F02:  CLRF   xF6
6F04:  MOVLW  14
6F06:  MOVWF  xF5
6F08:  CLRF   xFA
6F0A:  MOVLW  55
6F0C:  MOVWF  xF9
6F0E:  MOVLB  0
6F10:  CALL   546C
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
6F14:  MOVLW  02
6F16:  MOVLB  7
6F18:  MOVWF  xF1
6F1A:  MOVLW  14
6F1C:  MOVWF  xF2
6F1E:  CLRF   xF4
6F20:  MOVLW  69
6F22:  MOVWF  xF3
6F24:  MOVLB  0
6F26:  CALL   5792
....................          if(!stringcomp(entpassword,password)) 
6F2A:  MOVLB  7
6F2C:  CLRF   xF2
6F2E:  MOVLW  69
6F30:  MOVWF  xF1
6F32:  CLRF   xF4
6F34:  MOVLW  55
6F36:  MOVWF  xF3
6F38:  MOVLB  0
6F3A:  CALL   58CA
6F3E:  MOVF   01,F
6F40:  BNZ   7016
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
6F42:  MOVLW  94
6F44:  MOVWF  FF6
6F46:  MOVLW  1E
6F48:  MOVWF  FF7
6F4A:  CLRF   19
6F4C:  BTFSC  FF2.7
6F4E:  BSF    19.7
6F50:  BCF    FF2.7
6F52:  CALL   16EA
6F56:  BTFSC  19.7
6F58:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
6F5A:  MOVLW  02
6F5C:  MOVLB  7
6F5E:  MOVWF  xF1
6F60:  MOVLW  14
6F62:  MOVWF  xF2
6F64:  CLRF   xF4
6F66:  MOVLW  69
6F68:  MOVWF  xF3
6F6A:  MOVLB  0
6F6C:  CALL   5792
....................             fprintf(COM2,"\n\ragain:"); 
6F70:  MOVLW  9C
6F72:  MOVWF  FF6
6F74:  MOVLW  1E
6F76:  MOVWF  FF7
6F78:  CLRF   19
6F7A:  BTFSC  FF2.7
6F7C:  BSF    19.7
6F7E:  BCF    FF2.7
6F80:  CALL   16EA
6F84:  BTFSC  19.7
6F86:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
6F88:  MOVLW  02
6F8A:  MOVLB  7
6F8C:  MOVWF  xF1
6F8E:  MOVLW  14
6F90:  MOVWF  xF2
6F92:  CLRF   xF4
6F94:  MOVLW  55
6F96:  MOVWF  xF3
6F98:  MOVLB  0
6F9A:  CALL   5792
....................             if(!stringcomp(entpassword,password)) 
6F9E:  MOVLB  7
6FA0:  CLRF   xF2
6FA2:  MOVLW  69
6FA4:  MOVWF  xF1
6FA6:  CLRF   xF4
6FA8:  MOVLW  55
6FAA:  MOVWF  xF3
6FAC:  MOVLB  0
6FAE:  CALL   58CA
6FB2:  MOVF   01,F
6FB4:  BNZ   6FFC
6FB6:  CLRF   19
6FB8:  BTFSC  FF2.7
6FBA:  BSF    19.7
6FBC:  BCF    FF2.7
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
6FBE:  MOVLB  8
6FC0:  CLRF   x40
6FC2:  CLRF   x3F
6FC4:  CLRF   x3E
6FC6:  CLRF   x3D
6FC8:  CLRF   x44
6FCA:  CLRF   x43
6FCC:  CLRF   x42
6FCE:  MOVLW  14
6FD0:  MOVWF  x41
6FD2:  CLRF   x46
6FD4:  MOVLW  55
6FD6:  MOVWF  x45
6FD8:  MOVLB  0
6FDA:  CALL   4D90
6FDE:  BTFSC  19.7
6FE0:  BSF    FF2.7
....................                fprintf(COM2,"\n\rOK\n\r");    
6FE2:  MOVLW  A6
6FE4:  MOVWF  FF6
6FE6:  MOVLW  1E
6FE8:  MOVWF  FF7
6FEA:  CLRF   19
6FEC:  BTFSC  FF2.7
6FEE:  BSF    19.7
6FF0:  BCF    FF2.7
6FF2:  CALL   16EA
6FF6:  BTFSC  19.7
6FF8:  BSF    FF2.7
....................             } 
....................                else 
6FFA:  BRA    7014
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
6FFC:  MOVLW  AE
6FFE:  MOVWF  FF6
7000:  MOVLW  1E
7002:  MOVWF  FF7
7004:  CLRF   19
7006:  BTFSC  FF2.7
7008:  BSF    19.7
700A:  BCF    FF2.7
700C:  CALL   16EA
7010:  BTFSC  19.7
7012:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
7014:  BRA    702E
....................             { 
....................                fprintf(COM2," X\n\r"); 
7016:  MOVLW  B6
7018:  MOVWF  FF6
701A:  MOVLW  1E
701C:  MOVWF  FF7
701E:  CLRF   19
7020:  BTFSC  FF2.7
7022:  BSF    19.7
7024:  BCF    FF2.7
7026:  CALL   16EA
702A:  BTFSC  19.7
702C:  BSF    FF2.7
....................             }    
....................       } 
....................         strcpy(buffer2,"crypto"); 
702E:  CLRF   FEA
7030:  MOVLW  41
7032:  MOVWF  FE9
7034:  MOVLW  00
7036:  CALL   048E
703A:  TBLRD*-
703C:  TBLRD*+
703E:  MOVF   FF5,W
7040:  MOVWF  FEE
7042:  IORLW  00
7044:  BNZ   703C
....................         if(!stringcomp(buffer_uart,buffer2))  
7046:  MOVLW  01
7048:  MOVLB  7
704A:  MOVWF  xF2
704C:  MOVLW  5E
704E:  MOVWF  xF1
7050:  CLRF   xF4
7052:  MOVLW  41
7054:  MOVWF  xF3
7056:  MOVLB  0
7058:  CALL   58CA
705C:  MOVF   01,F
705E:  BTFSS  FD8.2
7060:  BRA    71E0
....................         { 
....................             memset(crypto_key,0,sizeof(crypto_key)); 
7062:  CLRF   FEA
7064:  MOVLW  FD
7066:  MOVWF  FE9
7068:  CLRF   00
706A:  CLRF   02
706C:  MOVLW  21
706E:  MOVWF  01
7070:  CALL   3546
....................             fprintf(COM2,"New crypto key>"); 
7074:  MOVLW  BC
7076:  MOVWF  FF6
7078:  MOVLW  1E
707A:  MOVWF  FF7
707C:  CLRF   19
707E:  BTFSC  FF2.7
7080:  BSF    19.7
7082:  BCF    FF2.7
7084:  CALL   16EA
7088:  BTFSC  19.7
708A:  BSF    FF2.7
....................             countchar = (int16)USART_getstring(EN_ECHO, CRYPTO_KEY_SIZE, crypto_key); 
708C:  MOVLW  01
708E:  MOVLB  7
7090:  MOVWF  xF1
7092:  MOVLW  20
7094:  MOVWF  xF2
7096:  CLRF   xF4
7098:  MOVLW  FD
709A:  MOVWF  xF3
709C:  MOVLB  0
709E:  CALL   5792
70A2:  MOVLB  7
70A4:  CLRF   xBC
70A6:  MOVFF  01,7BB
70AA:  CLRF   19
70AC:  BTFSC  FF2.7
70AE:  BSF    19.7
70B0:  BCF    FF2.7
....................             EEPROM_write(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
70B2:  MOVLB  8
70B4:  CLRF   x40
70B6:  CLRF   x3F
70B8:  CLRF   x3E
70BA:  MOVLW  3F
70BC:  MOVWF  x3D
70BE:  CLRF   x44
70C0:  CLRF   x43
70C2:  CLRF   x42
70C4:  MOVLW  20
70C6:  MOVWF  x41
70C8:  CLRF   x46
70CA:  MOVLW  FD
70CC:  MOVWF  x45
70CE:  MOVLB  0
70D0:  CALL   4D90
70D4:  BTFSC  19.7
70D6:  BSF    FF2.7
....................              
....................             if(countchar>2) 
70D8:  MOVLB  7
70DA:  MOVF   xBC,F
70DC:  BNZ   70E4
70DE:  MOVF   xBB,W
70E0:  SUBLW  02
70E2:  BC    71A2
....................             { 
....................                 cryption_enable = 1; 
70E4:  MOVLW  01
70E6:  MOVLB  1
70E8:  MOVWF  x1E
70EA:  CLRF   19
70EC:  BTFSC  FF2.7
70EE:  BSF    19.7
70F0:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable);                    
70F2:  MOVLB  8
70F4:  CLRF   x53
70F6:  CLRF   x52
70F8:  CLRF   x51
70FA:  MOVLW  3E
70FC:  MOVWF  x50
70FE:  MOVFF  11E,854
7102:  MOVLB  0
7104:  CALL   3934
7108:  BTFSC  19.7
710A:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rNew crypto key: "); 
710C:  MOVLW  CC
710E:  MOVWF  FF6
7110:  MOVLW  1E
7112:  MOVWF  FF7
7114:  CLRF   19
7116:  BTFSC  FF2.7
7118:  BSF    19.7
711A:  BCF    FF2.7
711C:  CALL   16EA
7120:  BTFSC  19.7
7122:  BSF    FF2.7
....................                 for(i=0;i<CRYPTO_KEY_SIZE;i++) 
7124:  MOVLB  7
7126:  CLRF   xBA
7128:  MOVF   xBA,W
712A:  SUBLW  1F
712C:  BNC   716E
....................                 { 
....................                     fprintf(COM2,"%c",read_ext_eeprom(strobe_crypto_key+i)); 
712E:  MOVLW  3F
7130:  ADDWF  xBA,W
7132:  MOVWF  xF1
7134:  CLRF   19
7136:  BTFSC  FF2.7
7138:  BSF    19.7
713A:  BCF    FF2.7
713C:  MOVLB  8
713E:  CLRF   x46
7140:  CLRF   x45
7142:  CLRF   x44
7144:  MOVWF  x43
7146:  MOVLB  0
7148:  CALL   3400
714C:  BTFSC  19.7
714E:  BSF    FF2.7
7150:  MOVFF  01,7F1
7154:  CLRF   19
7156:  BTFSC  FF2.7
7158:  BSF    19.7
715A:  BCF    FF2.7
715C:  MOVFF  01,852
7160:  CALL   15C0
7164:  BTFSC  19.7
7166:  BSF    FF2.7
....................                 } 
7168:  MOVLB  7
716A:  INCF   xBA,F
716C:  BRA    7128
716E:  CLRF   19
7170:  BTFSC  FF2.7
7172:  BSF    19.7
7174:  BCF    FF2.7
....................                 fprintf(COM2,"\n\r"); 
7176:  MOVLW  0A
7178:  MOVLB  8
717A:  MOVWF  x52
717C:  MOVLB  0
717E:  CALL   15C0
7182:  BTFSC  19.7
7184:  BSF    FF2.7
7186:  CLRF   19
7188:  BTFSC  FF2.7
718A:  BSF    19.7
718C:  BCF    FF2.7
718E:  MOVLW  0D
7190:  MOVLB  8
7192:  MOVWF  x52
7194:  MOVLB  0
7196:  CALL   15C0
719A:  BTFSC  19.7
719C:  BSF    FF2.7
....................             } 
....................             else 
719E:  BRA    71E0
71A0:  MOVLB  7
....................             { 
....................                 cryption_enable = 0; 
71A2:  MOVLB  1
71A4:  CLRF   x1E
71A6:  CLRF   19
71A8:  BTFSC  FF2.7
71AA:  BSF    19.7
71AC:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable); 
71AE:  MOVLB  8
71B0:  CLRF   x53
71B2:  CLRF   x52
71B4:  CLRF   x51
71B6:  MOVLW  3E
71B8:  MOVWF  x50
71BA:  MOVFF  11E,854
71BE:  MOVLB  0
71C0:  CALL   3934
71C4:  BTFSC  19.7
71C6:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rcrypto is disable\n\r"); 
71C8:  MOVLW  E0
71CA:  MOVWF  FF6
71CC:  MOVLW  1E
71CE:  MOVWF  FF7
71D0:  CLRF   19
71D2:  BTFSC  FF2.7
71D4:  BSF    19.7
71D6:  BCF    FF2.7
71D8:  CALL   16EA
71DC:  BTFSC  19.7
71DE:  BSF    FF2.7
....................             } 
....................         } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
71E0:  CLRF   FEA
71E2:  MOVLW  41
71E4:  MOVWF  FE9
71E6:  MOVLW  00
71E8:  CALL   04A6
71EC:  TBLRD*-
71EE:  TBLRD*+
71F0:  MOVF   FF5,W
71F2:  MOVWF  FEE
71F4:  IORLW  00
71F6:  BNZ   71EE
....................       if(!stringcomp(buffer_uart,buffer2)) 
71F8:  MOVLW  01
71FA:  MOVLB  7
71FC:  MOVWF  xF2
71FE:  MOVLW  5E
7200:  MOVWF  xF1
7202:  CLRF   xF4
7204:  MOVLW  41
7206:  MOVWF  xF3
7208:  MOVLB  0
720A:  CALL   58CA
720E:  MOVF   01,F
7210:  BTFSS  FD8.2
7212:  BRA    7322
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
7214:  MOVLW  F6
7216:  MOVWF  FF6
7218:  MOVLW  1E
721A:  MOVWF  FF7
721C:  CLRF   19
721E:  BTFSC  FF2.7
7220:  BSF    19.7
7222:  BCF    FF2.7
7224:  CALL   16EA
7228:  BTFSC  19.7
722A:  BSF    FF2.7
722C:  CLRF   19
722E:  BTFSC  FF2.7
7230:  BSF    19.7
7232:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7234:  MOVLW  0A
7236:  MOVLB  8
7238:  MOVWF  x52
723A:  MOVLB  0
723C:  CALL   15C0
7240:  BTFSC  19.7
7242:  BSF    FF2.7
7244:  CLRF   19
7246:  BTFSC  FF2.7
7248:  BSF    19.7
724A:  BCF    FF2.7
724C:  MOVLW  0D
724E:  MOVLB  8
7250:  MOVWF  x52
7252:  MOVLB  0
7254:  CALL   15C0
7258:  BTFSC  19.7
725A:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
725C:  MOVLW  16
725E:  MOVWF  FF6
7260:  MOVLW  1F
7262:  MOVWF  FF7
7264:  CLRF   19
7266:  BTFSC  FF2.7
7268:  BSF    19.7
726A:  BCF    FF2.7
726C:  CALL   16EA
7270:  BTFSC  19.7
7272:  BSF    FF2.7
7274:  CLRF   19
7276:  BTFSC  FF2.7
7278:  BSF    19.7
727A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
727C:  MOVLW  0A
727E:  MOVLB  8
7280:  MOVWF  x52
7282:  MOVLB  0
7284:  CALL   15C0
7288:  BTFSC  19.7
728A:  BSF    FF2.7
728C:  CLRF   19
728E:  BTFSC  FF2.7
7290:  BSF    19.7
7292:  BCF    FF2.7
7294:  MOVLW  0D
7296:  MOVLB  8
7298:  MOVWF  x52
729A:  MOVLB  0
729C:  CALL   15C0
72A0:  BTFSC  19.7
72A2:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
72A4:  MOVLW  01
72A6:  MOVLB  7
72A8:  MOVWF  xF1
72AA:  MOVLW  03
72AC:  MOVWF  xF2
72AE:  MOVLW  07
72B0:  MOVWF  xF4
72B2:  MOVLW  BD
72B4:  MOVWF  xF3
72B6:  MOVLB  0
72B8:  CALL   5792
....................           debugmode = (unsigned int8)strtoi(temp); 
72BC:  MOVLW  07
72BE:  MOVLB  7
72C0:  MOVWF  xF2
72C2:  MOVLW  BD
72C4:  MOVWF  xF1
72C6:  MOVLB  0
72C8:  CALL   5D90
72CC:  MOVFF  01,6D2
72D0:  CLRF   19
72D2:  BTFSC  FF2.7
72D4:  BSF    19.7
72D6:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
72D8:  MOVLB  8
72DA:  CLRF   x53
72DC:  CLRF   x52
72DE:  CLRF   x51
72E0:  MOVLW  3B
72E2:  MOVWF  x50
72E4:  MOVFF  6D2,854
72E8:  MOVLB  0
72EA:  CALL   3934
72EE:  BTFSC  19.7
72F0:  BSF    FF2.7
72F2:  CLRF   19
72F4:  BTFSC  FF2.7
72F6:  BSF    19.7
72F8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
72FA:  MOVLW  0A
72FC:  MOVLB  8
72FE:  MOVWF  x52
7300:  MOVLB  0
7302:  CALL   15C0
7306:  BTFSC  19.7
7308:  BSF    FF2.7
730A:  CLRF   19
730C:  BTFSC  FF2.7
730E:  BSF    19.7
7310:  BCF    FF2.7
7312:  MOVLW  0D
7314:  MOVLB  8
7316:  MOVWF  x52
7318:  MOVLB  0
731A:  CALL   15C0
731E:  BTFSC  19.7
7320:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
7322:  GOTO   78E0 (RETURN)
.................... //=============================================== 
....................  
....................  
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    if(keydebug_en==1) 
*
518A:  MOVLB  1
518C:  DECFSZ x40,W
518E:  BRA    51AA
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
5190:  MOVLB  6
5192:  MOVF   xDE,F
5194:  BNZ   519E
5196:  MOVLB  0
5198:  CALL   1F36
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
519C:  BRA    51A8
519E:  MOVLB  0
51A0:  CALL   3190
51A4:  MOVFF  01,828
51A8:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
51AA:  DECFSZ x41,W
51AC:  BRA    51C6
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
51AE:  MOVLB  6
51B0:  MOVF   xDE,F
51B2:  BNZ   51BC
51B4:  MOVLB  0
51B6:  CALL   1F36
....................          else temp=kbd_getc_slv(); 
51BA:  BRA    51C6
51BC:  MOVLB  0
51BE:  CALL   3190
51C2:  MOVFF  01,828
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
51C6:  MOVLB  6
51C8:  MOVF   xC3,F
51CA:  BNZ   51EA
51CC:  MOVF   xC2,F
51CE:  BNZ   51EA
51D0:  MOVF   xC1,F
51D2:  BNZ   51EA
51D4:  MOVF   xC0,W
51D6:  SUBLW  04
51D8:  BNC   51EA
51DA:  MOVLW  01
51DC:  ADDWF  xC0,F
51DE:  BTFSC  FD8.0
51E0:  INCF   xC1,F
51E2:  BTFSC  FD8.2
51E4:  INCF   xC2,F
51E6:  BTFSC  FD8.2
51E8:  INCF   xC3,F
....................   if(mcr_timeout==5) 
51EA:  MOVF   xC0,W
51EC:  SUBLW  05
51EE:  BNZ   524A
51F0:  MOVF   xC1,F
51F2:  BNZ   524A
51F4:  MOVF   xC2,F
51F6:  BNZ   524A
51F8:  MOVF   xC3,F
51FA:  BNZ   524A
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
51FC:  DECFSZ xD6,W
51FE:  BRA    5208
5200:  MOVLB  0
5202:  GOTO   3AC0
5206:  MOVLB  6
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
5208:  MOVLW  02
520A:  MOVWF  FEA
520C:  MOVLW  42
520E:  MOVWF  FE9
5210:  CLRF   00
5212:  MOVLW  03
5214:  MOVWF  02
5216:  MOVLW  52
5218:  MOVWF  01
521A:  MOVLB  0
521C:  CALL   3546
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
5220:  MOVLW  05
5222:  MOVWF  FEA
5224:  MOVLW  94
5226:  MOVWF  FE9
5228:  CLRF   00
522A:  MOVLW  01
522C:  MOVWF  02
522E:  MOVLW  2C
5230:  MOVWF  01
5232:  CALL   3546
....................       //debug_card(); 
....................       count_reading_error=0; 
5236:  MOVLB  6
5238:  CLRF   xD7
....................       mcr_timeout++;   
523A:  MOVLW  01
523C:  ADDWF  xC0,F
523E:  BTFSC  FD8.0
5240:  INCF   xC1,F
5242:  BTFSC  FD8.2
5244:  INCF   xC2,F
5246:  BTFSC  FD8.2
5248:  INCF   xC3,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
524A:  MOVLB  8
524C:  CLRF   x46
524E:  CLRF   x45
5250:  CLRF   x44
5252:  MOVLW  3C
5254:  MOVWF  x43
5256:  MOVLB  0
5258:  CALL   3400
525C:  MOVFF  01,156
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
5260:  MOVLW  02
5262:  MOVLB  8
5264:  MOVWF  x2F
5266:  MOVLW  BC
5268:  MOVWF  x2E
526A:  CLRF   x31
526C:  MOVFF  156,830
5270:  MOVLB  0
5272:  CALL   3524
5276:  MOVFF  02,03
527A:  MOVF   xFC,W
527C:  SUBWF  02,W
527E:  BNC   528E
5280:  BNZ   5288
5282:  MOVF   01,W
5284:  SUBWF  xFB,W
5286:  BC    528E
5288:  INCF   xFB,F
528A:  BTFSC  FD8.2
528C:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
528E:  MOVLW  02
5290:  MOVLB  8
5292:  MOVWF  x2F
5294:  MOVLW  BC
5296:  MOVWF  x2E
5298:  CLRF   x31
529A:  MOVFF  156,830
529E:  MOVLB  0
52A0:  CALL   3524
52A4:  MOVFF  02,03
52A8:  MOVF   01,W
52AA:  SUBWF  xFB,W
52AC:  BNZ   5364
52AE:  MOVF   03,W
52B0:  SUBWF  xFC,W
52B2:  BNZ   5364
....................   { 
....................       charac_timeout++; 
52B4:  INCF   xFB,F
52B6:  BTFSC  FD8.2
52B8:  INCF   xFC,F
....................       buf=get_countcard(); 
52BA:  CALL   34CC
52BE:  MOVFF  02,827
52C2:  MOVFF  01,826
....................       if(buf<countcards) 
52C6:  MOVLB  8
52C8:  MOVF   x27,W
52CA:  SUBLW  03
52CC:  BNC   5304
52CE:  BNZ   52D6
52D0:  MOVF   x26,W
52D2:  SUBLW  A1
52D4:  BNC   5304
....................       { 
....................          if(cryption_enable==0)  
52D6:  MOVLB  1
52D8:  MOVF   x1E,F
52DA:  BNZ   52E6
....................          { 
....................             save_key_new(); 
52DC:  MOVLB  0
52DE:  GOTO   3EB6
....................          } 
....................          else 
52E2:  BRA    52EA
52E4:  MOVLB  1
....................          { 
....................             save_key_encrypt(); 
52E6:  MOVLB  0
52E8:  BRA    4E20
....................          } 
....................          buf=buf+1; 
52EA:  MOVLW  01
52EC:  MOVLB  8
52EE:  ADDWF  x26,F
52F0:  MOVLW  00
52F2:  ADDWFC x27,F
....................          save_coutcard(buf); 
52F4:  MOVFF  827,82A
52F8:  MOVFF  826,829
52FC:  MOVLB  0
52FE:  RCALL  504E
....................       } 
....................          else 
5300:  BRA    5314
5302:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
5304:  MOVLW  6A
5306:  MOVWF  FF6
5308:  MOVLW  53
530A:  MOVWF  FF7
530C:  MOVLB  0
530E:  CALL   16EA
....................             return; 
5312:  BRA    5364
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
5314:  MOVLW  7A
5316:  MOVWF  FF6
5318:  MOVLW  53
531A:  MOVWF  FF7
531C:  CALL   16EA
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
5320:  MOVLW  8A
5322:  MOVWF  FF6
5324:  MOVLW  53
5326:  MOVWF  FF7
5328:  MOVLW  14
532A:  MOVLB  8
532C:  MOVWF  x46
532E:  MOVLB  0
5330:  CALL   1606
5334:  MOVLW  10
5336:  MOVWF  FE9
5338:  MOVFF  827,82A
533C:  MOVFF  826,829
5340:  RCALL  5094
5342:  MOVLW  A1
5344:  MOVWF  FF6
5346:  MOVLW  53
5348:  MOVWF  FF7
534A:  MOVLW  03
534C:  MOVLB  8
534E:  MOVWF  x46
5350:  MOVLB  0
5352:  CALL   1606
....................       data_avai=0; 
5356:  MOVLB  6
5358:  CLRF   xD5
....................       enable_getpin=0; 
535A:  MOVLB  1
535C:  CLRF   x41
....................       //dis_getpin; 
....................       output_low(LED); 
535E:  BCF    F92.6
5360:  BCF    F89.6
5362:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
5364:  BCF    FF2.2
5366:  GOTO   006C
.................... void main() 
.................... {  
*
7326:  CLRF   FF8
7328:  BCF    FD0.7
732A:  BSF    07.7
732C:  CLRF   FEA
732E:  CLRF   FE9
7330:  BCF    F94.0
7332:  BSF    F8B.0
7334:  CLRF   23
7336:  CLRF   22
7338:  CLRF   21
733A:  MOVLW  96
733C:  MOVWF  20
733E:  CLRF   27
7340:  MOVLW  01
7342:  MOVWF  26
7344:  MOVLW  C3
7346:  MOVWF  25
7348:  MOVLW  0F
734A:  MOVWF  24
734C:  CLRF   xFA
734E:  CLRF   xF9
7350:  SETF   xFC
7352:  SETF   xFB
7354:  MOVLB  1
7356:  CLRF   x1E
7358:  CLRF   x3F
735A:  CLRF   x40
735C:  CLRF   x41
735E:  MOVLW  64
7360:  MOVWF  x42
7362:  CLRF   x43
7364:  CLRF   x44
7366:  CLRF   x45
7368:  CLRF   x56
736A:  CLRF   x5B
736C:  CLRF   xC2
736E:  CLRF   xC3
7370:  MOVLW  0E
7372:  MOVWF  xC5
7374:  MOVLW  01
7376:  MOVWF  xC6
7378:  MOVWF  xC7
737A:  CLRF   xC8
737C:  CLRF   xC9
737E:  CLRF   xCA
7380:  MOVLB  6
7382:  CLRF   xC3
7384:  CLRF   xC2
7386:  CLRF   xC1
7388:  CLRF   xC0
738A:  CLRF   xC4
738C:  CLRF   xC6
738E:  CLRF   xC5
7390:  CLRF   xC8
7392:  CLRF   xC7
7394:  CLRF   xCA
7396:  CLRF   xC9
7398:  CLRF   xCC
739A:  CLRF   xCB
739C:  MOVLW  FD
739E:  MOVWF  xCE
73A0:  MOVLW  E8
73A2:  MOVWF  xCD
73A4:  CLRF   xD0
73A6:  CLRF   xCF
73A8:  CLRF   xD1
73AA:  CLRF   xD2
73AC:  CLRF   xD3
73AE:  CLRF   xD4
73B0:  CLRF   xD5
73B2:  CLRF   xD6
73B4:  CLRF   xD7
73B6:  CLRF   xD8
73B8:  CLRF   xD9
73BA:  CLRF   xDB
73BC:  MOVLW  01
73BE:  MOVWF  xDA
73C0:  CLRF   xDD
73C2:  CLRF   xDC
73C4:  CLRF   xDE
73C6:  CLRF   xE2
73C8:  CLRF   xE1
73CA:  CLRF   xE0
73CC:  CLRF   xDF
73CE:  MOVLW  FF
73D0:  MOVLB  F
73D2:  MOVWF  x48
73D4:  BCF    FC2.6
73D6:  BCF    FC2.7
73D8:  MOVF   x49,W
73DA:  ANDLW  E0
73DC:  IORLW  1F
73DE:  MOVWF  x49
73E0:  CLRF   FD2
73E2:  CLRF   FD1
73E4:  CLRF   1A
73E6:  CLRF   1B
73E8:  MOVLW  E8
73EA:  MOVLB  1
73EC:  MOVWF  x1F
73EE:  MOVLW  E9
73F0:  MOVWF  x20
73F2:  MOVLW  EA
73F4:  MOVWF  x21
73F6:  MOVLW  EB
73F8:  MOVWF  x22
73FA:  MOVLW  ED
73FC:  MOVWF  x23
73FE:  MOVLW  EE
7400:  MOVWF  x24
7402:  MOVLW  EF
7404:  MOVWF  x25
7406:  MOVLW  F0
7408:  MOVWF  x26
740A:  MOVLW  F2
740C:  MOVWF  x27
740E:  MOVLW  F3
7410:  MOVWF  x28
7412:  MOVLW  F4
7414:  MOVWF  x29
7416:  MOVLW  F5
7418:  MOVWF  x2A
741A:  MOVLW  F7
741C:  MOVWF  x2B
741E:  MOVLW  F8
7420:  MOVWF  x2C
7422:  MOVLW  F9
7424:  MOVWF  x2D
7426:  MOVLW  FA
7428:  MOVWF  x2E
742A:  MOVLW  67
742C:  MOVWF  x2F
742E:  MOVLW  43
7430:  MOVWF  x30
7432:  MOVLW  C3
7434:  MOVWF  x31
7436:  MOVLW  D1
7438:  MOVWF  x32
743A:  MOVLW  51
743C:  MOVWF  x33
743E:  MOVLW  9A
7440:  MOVWF  x34
7442:  MOVLW  B4
7444:  MOVWF  x35
7446:  MOVLW  F2
7448:  MOVWF  x36
744A:  MOVLW  CD
744C:  MOVWF  x37
744E:  MOVLW  9A
7450:  MOVWF  x38
7452:  MOVLW  78
7454:  MOVWF  x39
7456:  MOVLW  AB
7458:  MOVWF  x3A
745A:  MOVLW  09
745C:  MOVWF  x3B
745E:  MOVLW  A5
7460:  MOVWF  x3C
7462:  MOVLW  11
7464:  MOVWF  x3D
7466:  MOVLW  BD
7468:  MOVWF  x3E
746A:  CLRF   x57
746C:  BCF    x58.0
746E:  CLRF   x59
7470:  CLRF   x5A
7472:  CLRF   x5C
7474:  BCF    x58.1
7476:  CLRF   x5D
7478:  MOVLB  6
747A:  CLRF   xF3
747C:  CLRF   xF4
747E:  CLRF   xF5
7480:  CLRF   xF6
7482:  CLRF   xF7
7484:  CLRF   xF8
7486:  CLRF   xF9
7488:  CLRF   xFA
748A:  CLRF   xFB
748C:  CLRF   xFC
748E:  CLRF   xFF
7490:  MOVLB  7
7492:  CLRF   x01
7494:  CLRF   x00
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    RPINR1=5; 
7496:  MOVLW  05
7498:  MOVLB  E
749A:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
749C:  MOVLB  0
749E:  SETF   xFC
74A0:  SETF   xFB
....................    setup_oscillator(OSC_32MHZ); 
74A2:  MOVLW  70
74A4:  MOVWF  FD3
74A6:  MOVLW  40
74A8:  MOVWF  F9B
74AA:  MOVF   FD3,W
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
74AC:  BCF    FF2.6
74AE:  BCF    FF2.7
74B0:  BTFSC  FF2.7
74B2:  BRA    74AE
....................    init_ext_eeprom(); 
74B4:  GOTO   5462
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif   
....................    //===================================== 
....................    delay_ms(1000); 
74B8:  MOVLW  04
74BA:  MOVLB  7
74BC:  MOVWF  xB9
74BE:  CLRF   19
74C0:  BTFSC  FF2.7
74C2:  BSF    19.7
74C4:  BCF    FF2.7
74C6:  MOVLW  FA
74C8:  MOVLB  8
74CA:  MOVWF  x2F
74CC:  MOVLB  0
74CE:  CALL   1882
74D2:  BTFSC  19.7
74D4:  BSF    FF2.7
74D6:  MOVLB  7
74D8:  DECFSZ xB9,F
74DA:  BRA    74BE
....................    init_password(); 
74DC:  MOVLB  0
74DE:  CALL   551C
....................    //===================================== 
....................     
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
74E2:  MOVLW  19
74E4:  MOVLB  7
74E6:  MOVWF  xB9
74E8:  MOVLB  0
74EA:  CALL   55BC
74EE:  MOVFF  03,23
74F2:  MOVFF  02,22
74F6:  MOVFF  01,21
74FA:  MOVFF  00,20
....................    printf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
74FE:  CLRF   FEA
7500:  MOVLW  01
7502:  MOVWF  FE9
7504:  CALL   5712
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
7508:  MOVLW  1E
750A:  MOVLB  7
750C:  MOVWF  xB9
750E:  MOVLB  0
7510:  CALL   55BC
7514:  MOVFF  03,27
7518:  MOVFF  02,26
751C:  MOVFF  01,25
7520:  MOVFF  00,24
....................    fprintf(COM2,"booting\n\r"); 
7524:  MOVLW  A6
7526:  MOVWF  FF6
7528:  MOVLW  53
752A:  MOVWF  FF7
752C:  CLRF   19
752E:  BTFSC  FF2.7
7530:  BSF    19.7
7532:  BCF    FF2.7
7534:  CALL   16EA
7538:  BTFSC  19.7
753A:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
753C:  MOVLW  B0
753E:  MOVWF  FF6
7540:  MOVLW  53
7542:  MOVWF  FF7
7544:  CLRF   19
7546:  BTFSC  FF2.7
7548:  BSF    19.7
754A:  BCF    FF2.7
754C:  MOVLW  12
754E:  MOVLB  8
7550:  MOVWF  x46
7552:  MOVLB  0
7554:  CALL   1606
7558:  BTFSC  19.7
755A:  BSF    FF2.7
755C:  MOVLW  41
755E:  MOVWF  FE9
7560:  CLRF   19
7562:  BTFSC  FF2.7
7564:  BSF    19.7
7566:  BCF    FF2.7
7568:  MOVFF  27,849
756C:  MOVFF  26,848
7570:  MOVFF  25,847
7574:  MOVFF  24,846
7578:  CALL   22B4
757C:  BTFSC  19.7
757E:  BSF    FF2.7
7580:  CLRF   19
7582:  BTFSC  FF2.7
7584:  BSF    19.7
7586:  BCF    FF2.7
7588:  MOVLW  0A
758A:  MOVLB  8
758C:  MOVWF  x52
758E:  MOVLB  0
7590:  CALL   15C0
7594:  BTFSC  19.7
7596:  BSF    FF2.7
7598:  CLRF   19
759A:  BTFSC  FF2.7
759C:  BSF    19.7
759E:  BCF    FF2.7
75A0:  MOVLW  0D
75A2:  MOVLB  8
75A4:  MOVWF  x52
75A6:  MOVLB  0
75A8:  CALL   15C0
75AC:  BTFSC  19.7
75AE:  BSF    FF2.7
75B0:  CLRF   19
75B2:  BTFSC  FF2.7
75B4:  BSF    19.7
75B6:  BCF    FF2.7
....................    countcard=get_countcard(); 
75B8:  CALL   34CC
75BC:  BTFSC  19.7
75BE:  BSF    FF2.7
75C0:  MOVFF  02,FA
75C4:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
75C8:  SETF   xFC
75CA:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
75CC:  MOVLW  C7
75CE:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
75D0:  MOVLW  37
75D2:  MOVWF  FCD
75D4:  CLRF   F9A
75D6:  CLRF   19
75D8:  BTFSC  FF2.7
75DA:  BSF    19.7
75DC:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
75DE:  MOVLB  8
75E0:  CLRF   x46
75E2:  CLRF   x45
75E4:  CLRF   x44
75E6:  MOVLW  3C
75E8:  MOVWF  x43
75EA:  MOVLB  0
75EC:  CALL   3400
75F0:  BTFSC  19.7
75F2:  BSF    FF2.7
75F4:  MOVFF  01,156
....................    if(delaycharaction==0)delaycharaction=1; 
75F8:  MOVLB  1
75FA:  MOVF   x56,F
75FC:  BNZ   7602
75FE:  MOVLW  01
7600:  MOVWF  x56
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
7602:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
7604:  BSF    FF0.3
7606:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
7608:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
760A:  MOVLW  C0
760C:  IORWF  FF2,F
....................   
....................     mcr_timeout=10000; 
760E:  MOVLB  6
7610:  CLRF   xC3
7612:  CLRF   xC2
7614:  MOVLW  27
7616:  MOVWF  xC1
7618:  MOVLW  10
761A:  MOVWF  xC0
761C:  CLRF   19
761E:  BTFSC  FF2.7
7620:  BSF    19.7
7622:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
7624:  MOVLB  8
7626:  CLRF   x46
7628:  CLRF   x45
762A:  CLRF   x44
762C:  MOVLW  3A
762E:  MOVWF  x43
7630:  MOVLB  0
7632:  CALL   3400
7636:  BTFSC  19.7
7638:  BSF    FF2.7
763A:  MOVFF  01,6DE
763E:  CLRF   19
7640:  BTFSC  FF2.7
7642:  BSF    19.7
7644:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
7646:  MOVLB  8
7648:  CLRF   x46
764A:  CLRF   x45
764C:  CLRF   x44
764E:  MOVLW  3B
7650:  MOVWF  x43
7652:  MOVLB  0
7654:  CALL   3400
7658:  BTFSC  19.7
765A:  BSF    FF2.7
765C:  MOVFF  01,6D2
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
7660:  SETF   xFC
7662:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,wide_strobe_nameconsole,console); 
7664:  MOVLB  7
7666:  CLRF   xF4
7668:  CLRF   xF3
766A:  CLRF   xF2
766C:  MOVLW  28
766E:  MOVWF  xF1
7670:  CLRF   xF8
7672:  CLRF   xF7
7674:  CLRF   xF6
7676:  MOVLW  10
7678:  MOVWF  xF5
767A:  MOVLW  06
767C:  MOVWF  xFA
767E:  MOVLW  E3
7680:  MOVWF  xF9
7682:  MOVLB  0
7684:  CALL   546C
....................    set_tris_a(0xff);  
7688:  MOVLW  FF
768A:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
768C:  MOVLW  E0
768E:  MOVLB  F
7690:  MOVWF  x48
7692:  BCF    FC2.6
7694:  BCF    FC2.7
7696:  MOVF   x49,W
7698:  ANDLW  E0
769A:  IORLW  1F
769C:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
769E:  MOVF   FC1,W
76A0:  ANDLW  C0
76A2:  IORLW  03
76A4:  MOVWF  FC1
76A6:  BCF    FC1.7
76A8:  BSF    FC2.0
76AA:  BSF    FC1.6
76AC:  BSF    FC2.1
76AE:  BTFSC  FC2.1
76B0:  BRA    76AE
76B2:  BCF    FC1.6
76B4:  CLRF   19
76B6:  BTFSC  FF2.7
76B8:  BSF    19.7
76BA:  BCF    FF2.7
....................     
....................    type_KB=read_ext_eeprom(kindofKB); 
76BC:  MOVLB  8
76BE:  CLRF   x46
76C0:  CLRF   x45
76C2:  CLRF   x44
76C4:  MOVLW  3D
76C6:  MOVWF  x43
76C8:  MOVLB  0
76CA:  CALL   3400
76CE:  BTFSC  19.7
76D0:  BSF    FF2.7
76D2:  MOVFF  01,145
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
76D6:  MOVLB  1
76D8:  MOVF   x45,F
76DA:  BZ    76FA
76DC:  MOVLW  C8
76DE:  MOVWF  FF6
76E0:  MOVLW  53
76E2:  MOVWF  FF7
76E4:  CLRF   19
76E6:  BTFSC  FF2.7
76E8:  BSF    19.7
76EA:  BCF    FF2.7
76EC:  MOVLB  0
76EE:  CALL   16EA
76F2:  BTFSC  19.7
76F4:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
76F6:  BRA    7714
76F8:  MOVLB  1
76FA:  MOVLW  DC
76FC:  MOVWF  FF6
76FE:  MOVLW  53
7700:  MOVWF  FF7
7702:  CLRF   19
7704:  BTFSC  FF2.7
7706:  BSF    19.7
7708:  BCF    FF2.7
770A:  MOVLB  0
770C:  CALL   16EA
7710:  BTFSC  19.7
7712:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
7714:  MOVLB  6
7716:  MOVF   xDE,F
7718:  BNZ   7738
771A:  MOVLW  F0
771C:  MOVWF  FF6
771E:  MOVLW  53
7720:  MOVWF  FF7
7722:  CLRF   19
7724:  BTFSC  FF2.7
7726:  BSF    19.7
7728:  BCF    FF2.7
772A:  MOVLB  0
772C:  CALL   16EA
7730:  BTFSC  19.7
7732:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
7734:  BRA    7752
7736:  MOVLB  6
7738:  MOVLW  0A
773A:  MOVWF  FF6
773C:  MOVLW  54
773E:  MOVWF  FF7
7740:  CLRF   19
7742:  BTFSC  FF2.7
7744:  BSF    19.7
7746:  BCF    FF2.7
7748:  MOVLB  0
774A:  CALL   16EA
774E:  BTFSC  19.7
7750:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
7752:  MOVLW  01
7754:  MOVWF  FEA
7756:  MOVLW  46
7758:  MOVWF  FE9
775A:  CLRF   00
775C:  CLRF   02
775E:  MOVLW  10
7760:  MOVWF  01
7762:  CALL   3546
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
7766:  MOVLB  6
7768:  CLRF   xFD
776A:  MOVF   xFD,W
776C:  SUBLW  13
776E:  BNC   7784
....................    { 
....................       password[i] = 0; 
7770:  CLRF   03
7772:  MOVF   xFD,W
7774:  ADDLW  55
7776:  MOVWF  FE9
7778:  MOVLW  00
777A:  ADDWFC 03,W
777C:  MOVWF  FEA
777E:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 0 
....................    disable_interrupts(GLOBAL); 
....................    save_coutcard(0); 
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................     
....................    save_key_encrypt(); 
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
....................     
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_data in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_key in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],1); 
....................    //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rdecrypted:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    while(1); 
.................... #endif 
.................... #if 0 
7780:  INCF   xFD,F
7782:  BRA    776A
....................     fprintf(COM2,"\n\reeprom test\n\r"); 
....................     fprintf(COM2,"\n\reeprom is writing\n\r"); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         //write_ext_eeprom(115535+i,i); 
....................     } 
....................     write_ext_eeprom(EEPROM_KEY_ST,210); 
....................     write_ext_eeprom(EEPROM_SIZE_endofkey,123); 
....................     fprintf(COM2,"\n\r"); 
....................     fprintf(COM2,"eeprom is reading: %u",read_ext_eeprom(EEPROM_KEY_ST)); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         fprintf(COM2," %u",read_ext_eeprom(115535+i)); 
....................     } 
....................     while(1); 
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
7784:  MOVLB  7
7786:  CLRF   xF4
7788:  CLRF   xF3
778A:  CLRF   xF2
778C:  CLRF   xF1
778E:  CLRF   xF8
7790:  CLRF   xF7
7792:  CLRF   xF6
7794:  MOVLW  14
7796:  MOVWF  xF5
7798:  CLRF   xFA
779A:  MOVLW  55
779C:  MOVWF  xF9
779E:  MOVLB  0
77A0:  CALL   546C
77A4:  CLRF   19
77A6:  BTFSC  FF2.7
77A8:  BSF    19.7
77AA:  BCF    FF2.7
....................    cryption_enable = read_ext_eeprom(crypto_en); 
77AC:  MOVLB  8
77AE:  CLRF   x46
77B0:  CLRF   x45
77B2:  CLRF   x44
77B4:  MOVLW  3E
77B6:  MOVWF  x43
77B8:  MOVLB  0
77BA:  CALL   3400
77BE:  BTFSC  19.7
77C0:  BSF    FF2.7
77C2:  MOVFF  01,11E
....................    if(cryption_enable!=0) 
77C6:  MOVLB  1
77C8:  MOVF   x1E,F
77CA:  BZ    780C
....................    { 
....................         fprintf(COM2,"\n\crypto is enable\n\r"); 
77CC:  MOVLW  22
77CE:  MOVWF  FF6
77D0:  MOVLW  54
77D2:  MOVWF  FF7
77D4:  CLRF   19
77D6:  BTFSC  FF2.7
77D8:  BSF    19.7
77DA:  BCF    FF2.7
77DC:  MOVLB  0
77DE:  CALL   16EA
77E2:  BTFSC  19.7
77E4:  BSF    FF2.7
....................         EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key);  
77E6:  MOVLB  7
77E8:  CLRF   xF4
77EA:  CLRF   xF3
77EC:  CLRF   xF2
77EE:  MOVLW  3F
77F0:  MOVWF  xF1
77F2:  CLRF   xF8
77F4:  CLRF   xF7
77F6:  CLRF   xF6
77F8:  MOVLW  20
77FA:  MOVWF  xF5
77FC:  CLRF   xFA
77FE:  MOVLW  FD
7800:  MOVWF  xF9
7802:  MOVLB  0
7804:  CALL   546C
....................    } 
....................    else 
7808:  BRA    7826
780A:  MOVLB  1
....................    { 
....................        fprintf(COM2,"\n\crypto is disable\n\r"); 
780C:  MOVLW  36
780E:  MOVWF  FF6
7810:  MOVLW  54
7812:  MOVWF  FF7
7814:  CLRF   19
7816:  BTFSC  FF2.7
7818:  BSF    19.7
781A:  BCF    FF2.7
781C:  MOVLB  0
781E:  CALL   16EA
7822:  BTFSC  19.7
7824:  BSF    FF2.7
....................    } 
.................... #if 0    
....................    fprintf(COM2,"\n\crypto key:\n\r"); 
....................    for(i=0;i<CRYPTO_KEY_SIZE;i++) 
....................    { 
....................         fprintf(COM2,"%c",crypto_key[i]); 
....................    } 
....................    fprintf(COM2,"\n\r"); 
.................... #endif    
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
7826:  MOVLB  6
7828:  MOVF   xD8,F
782A:  BNZ   78D6
....................       { 
....................          fprintf(COM2,"password:"); 
782C:  MOVLW  4C
782E:  MOVWF  FF6
7830:  MOVLW  54
7832:  MOVWF  FF7
7834:  CLRF   19
7836:  BTFSC  FF2.7
7838:  BSF    19.7
783A:  BCF    FF2.7
783C:  MOVLB  0
783E:  CALL   16EA
7842:  BTFSC  19.7
7844:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
7846:  MOVLW  02
7848:  MOVLB  7
784A:  MOVWF  xF1
784C:  MOVLW  14
784E:  MOVWF  xF2
7850:  MOVLW  01
7852:  MOVWF  xF4
7854:  MOVLW  5E
7856:  MOVWF  xF3
7858:  MOVLB  0
785A:  CALL   5792
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
785E:  MOVLB  7
7860:  CLRF   xF4
7862:  CLRF   xF3
7864:  CLRF   xF2
7866:  CLRF   xF1
7868:  CLRF   xF8
786A:  CLRF   xF7
786C:  CLRF   xF6
786E:  MOVLW  14
7870:  MOVWF  xF5
7872:  CLRF   xFA
7874:  MOVLW  55
7876:  MOVWF  xF9
7878:  MOVLB  0
787A:  CALL   546C
....................          if(!stringcomp(buffer_uart,password)) 
787E:  MOVLW  01
7880:  MOVLB  7
7882:  MOVWF  xF2
7884:  MOVLW  5E
7886:  MOVWF  xF1
7888:  CLRF   xF4
788A:  MOVLW  55
788C:  MOVWF  xF3
788E:  MOVLB  0
7890:  CALL   58CA
7894:  MOVF   01,F
7896:  BNZ   78BA
....................          { 
....................             mode=LOGON; 
7898:  MOVLW  01
789A:  MOVLB  6
789C:  MOVWF  xD8
....................             fprintf(COM2," OK\n\r"); 
789E:  MOVLW  56
78A0:  MOVWF  FF6
78A2:  MOVLW  54
78A4:  MOVWF  FF7
78A6:  CLRF   19
78A8:  BTFSC  FF2.7
78AA:  BSF    19.7
78AC:  BCF    FF2.7
78AE:  MOVLB  0
78B0:  CALL   16EA
78B4:  BTFSC  19.7
78B6:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
78B8:  BRA    78D2
78BA:  MOVLW  5C
78BC:  MOVWF  FF6
78BE:  MOVLW  54
78C0:  MOVWF  FF7
78C2:  CLRF   19
78C4:  BTFSC  FF2.7
78C6:  BSF    19.7
78C8:  BCF    FF2.7
78CA:  CALL   16EA
78CE:  BTFSC  19.7
78D0:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
78D2:  BRA    78E0
78D4:  MOVLB  6
78D6:  DECFSZ xD8,W
78D8:  BRA    78E2
78DA:  MOVLB  0
78DC:  GOTO   5DDE
78E0:  MOVLB  6
....................    } 
78E2:  BRA    7828
.................... } 
78E4:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

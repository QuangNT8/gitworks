CCS PCH C Compiler, Version 4.140, 33034               26-Jul-18 20:51

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   33748 bytes (52%)
                           Largest free fragment is 31776
               RAM used:   1983 (53%) at main() level
                           2369 (63%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   7CEE
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   59DA
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1BEE
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
....................  
.................... //#define 24AA1025 
.................... #define 24AA512 
....................  
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0686:  MOVLW  02
0688:  MOVLB  8
068A:  SUBWF  x4E,F
068C:  BNC   06A6
068E:  MOVLW  08
0690:  MOVWF  FEA
0692:  MOVLW  4E
0694:  MOVWF  FE9
0696:  MOVF   FEF,W
0698:  BZ    06A6
069A:  BRA    06A2
069C:  BRA    069E
069E:  BRA    06A0
06A0:  NOP   
06A2:  DECFSZ FEF,F
06A4:  BRA    069C
06A6:  MOVLB  0
06A8:  GOTO   1BFE (RETURN)
*
18C6:  MOVLW  08
18C8:  MOVWF  FEA
18CA:  MOVLW  56
18CC:  MOVWF  FE9
18CE:  MOVF   FEF,W
18D0:  BZ    18EC
18D2:  MOVLW  0A
18D4:  MOVWF  01
18D6:  CLRF   00
18D8:  DECFSZ 00,F
18DA:  BRA    18D8
18DC:  DECFSZ 01,F
18DE:  BRA    18D6
18E0:  MOVLW  5F
18E2:  MOVWF  00
18E4:  DECFSZ 00,F
18E6:  BRA    18E4
18E8:  DECFSZ FEF,F
18EA:  BRA    18D2
18EC:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
1604:  BCF    F94.0
1606:  BCF    F8B.0
1608:  MOVLW  08
160A:  MOVWF  01
160C:  BRA    160E
160E:  NOP   
1610:  BSF    01.7
1612:  BRA    1634
1614:  BCF    01.7
1616:  MOVLB  9
1618:  RRCF   x0C,F
161A:  MOVLB  0
161C:  BTFSC  FD8.0
161E:  BSF    F8B.0
1620:  BTFSS  FD8.0
1622:  BCF    F8B.0
1624:  BSF    01.6
1626:  BRA    1634
1628:  BCF    01.6
162A:  DECFSZ 01,F
162C:  BRA    1616
162E:  BRA    1630
1630:  NOP   
1632:  BSF    F8B.0
1634:  MOVLW  10
1636:  MOVWF  FE9
1638:  DECFSZ FE9,F
163A:  BRA    1638
163C:  BRA    163E
163E:  NOP   
1640:  BTFSC  01.7
1642:  BRA    1614
1644:  BTFSC  01.6
1646:  BRA    1628
1648:  RETURN 0
*
5F30:  BSF    F94.1
5F32:  BTFSC  F82.1
5F34:  BRA    5F32
5F36:  MOVLW  08
5F38:  MOVWF  00
5F3A:  MOVLB  7
5F3C:  CLRF   xFC
5F3E:  BSF    00.7
5F40:  BRA    5F62
5F42:  BCF    00.7
5F44:  BRA    5F62
5F46:  MOVFF  7FC,02
5F4A:  BCF    FD8.0
5F4C:  BTFSC  F82.1
5F4E:  BSF    FD8.0
5F50:  RRCF   02,F
5F52:  BSF    00.6
5F54:  BRA    5F62
5F56:  BCF    00.6
5F58:  DECFSZ 00,F
5F5A:  BRA    5F4A
5F5C:  MOVFF  02,01
5F60:  BRA    5F7A
5F62:  MOVLW  10
5F64:  BTFSC  00.7
5F66:  MOVLW  04
5F68:  MOVWF  01
5F6A:  DECFSZ 01,F
5F6C:  BRA    5F6A
5F6E:  BRA    5F70
5F70:  BTFSC  00.7
5F72:  BRA    5F42
5F74:  BTFSC  00.6
5F76:  BRA    5F56
5F78:  BRA    5F4A
5F7A:  MOVLB  0
5F7C:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3370:  MOVLW  08
3372:  MOVWF  01
3374:  MOVLW  0A
3376:  MOVWF  00
3378:  DECFSZ 00,F
337A:  BRA    3378
337C:  BCF    F8B.3
337E:  BCF    F94.3
3380:  MOVLW  0B
3382:  MOVWF  00
3384:  DECFSZ 00,F
3386:  BRA    3384
3388:  MOVLB  9
338A:  RLCF   x23,F
338C:  BCF    F8B.4
338E:  BTFSC  FD8.0
3390:  BSF    F94.4
3392:  BTFSS  FD8.0
3394:  BCF    F94.4
3396:  BSF    F94.3
3398:  BTFSS  F82.3
339A:  BRA    3398
339C:  DECFSZ 01,F
339E:  BRA    33A2
33A0:  BRA    33A6
33A2:  MOVLB  0
33A4:  BRA    3374
33A6:  MOVLW  0A
33A8:  MOVWF  00
33AA:  DECFSZ 00,F
33AC:  BRA    33AA
33AE:  BCF    F8B.3
33B0:  BCF    F94.3
33B2:  NOP   
33B4:  BSF    F94.4
33B6:  MOVLW  0B
33B8:  MOVWF  00
33BA:  DECFSZ 00,F
33BC:  BRA    33BA
33BE:  MOVLW  0B
33C0:  MOVWF  00
33C2:  DECFSZ 00,F
33C4:  BRA    33C2
33C6:  BSF    F94.3
33C8:  BTFSS  F82.3
33CA:  BRA    33C8
33CC:  CLRF   01
33CE:  MOVLW  0B
33D0:  MOVWF  00
33D2:  DECFSZ 00,F
33D4:  BRA    33D2
33D6:  BTFSC  F82.4
33D8:  BSF    01.0
33DA:  BCF    F8B.3
33DC:  BCF    F94.3
33DE:  BCF    F8B.4
33E0:  BCF    F94.4
33E2:  MOVLB  0
33E4:  RETURN 0
33E6:  MOVLW  08
33E8:  MOVLB  9
33EA:  MOVWF  x1F
33EC:  MOVFF  00,920
33F0:  BSF    F94.4
33F2:  MOVLW  0B
33F4:  MOVWF  00
33F6:  DECFSZ 00,F
33F8:  BRA    33F6
33FA:  BSF    F94.3
33FC:  BTFSS  F82.3
33FE:  BRA    33FC
3400:  BTFSC  F82.4
3402:  BSF    FD8.0
3404:  BTFSS  F82.4
3406:  BCF    FD8.0
3408:  RLCF   01,F
340A:  MOVLW  0A
340C:  MOVWF  00
340E:  DECFSZ 00,F
3410:  BRA    340E
3412:  BCF    F94.3
3414:  BCF    F8B.3
3416:  DECFSZ x1F,F
3418:  BRA    33F0
341A:  BSF    F94.4
341C:  MOVLW  0B
341E:  MOVWF  00
3420:  DECFSZ 00,F
3422:  BRA    3420
3424:  BCF    F8B.4
3426:  MOVF   x20,W
3428:  BTFSS  FD8.2
342A:  BCF    F94.4
342C:  NOP   
342E:  BSF    F94.3
3430:  BTFSS  F82.3
3432:  BRA    3430
3434:  MOVLW  0A
3436:  MOVWF  00
3438:  DECFSZ 00,F
343A:  BRA    3438
343C:  BCF    F8B.3
343E:  BCF    F94.3
3440:  MOVLW  0B
3442:  MOVWF  00
3444:  DECFSZ 00,F
3446:  BRA    3444
3448:  BCF    F8B.4
344A:  BCF    F94.4
344C:  MOVLB  0
344E:  RETURN 0
....................  
.................... #define ptr_start                       150 
.................... #if defined(24AA1025) 
.................... #define EEPROM_SIZE_endofkey            131071 
.................... #define EEPROM_SIZE_stofkey             115470 
.................... #endif 
.................... #if defined(24AA512) 
.................... #define EEPROM_SIZE_endofkey            65535 // 65535 - 57601 = 7934/16= 450 
.................... #define EEPROM_SIZE_stofkey             57600 // 57600/128 = 450 
.................... #endif 
.................... #define EEPROM_KEY_ST                   EEPROM_SIZE_stofkey+1 
.................... //=============================== 
....................  
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5D10:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
5D12:  BSF    F94.4
....................    port_b_pullups(0xff); 
5D14:  BCF    FF1.7
.................... } 
5D16:  GOTO   7E84 (RETURN)
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
*
3A6C:  MOVLB  9
3A6E:  MOVF   x16,F
3A70:  BNZ   3A78
3A72:  MOVF   x15,W
3A74:  SUBLW  00
3A76:  BC    3A7E
3A78:  MOVLW  A2
3A7A:  MOVWF  x19
.................... #endif 
....................    else command=0xa0; 
3A7C:  BRA    3A82
3A7E:  MOVLW  A0
3A80:  MOVWF  x19
....................  
....................    i2c_start(); 
3A82:  BSF    F94.4
3A84:  MOVLW  0A
3A86:  MOVWF  00
3A88:  DECFSZ 00,F
3A8A:  BRA    3A88
3A8C:  BSF    F94.3
3A8E:  MOVLW  0B
3A90:  MOVWF  00
3A92:  DECFSZ 00,F
3A94:  BRA    3A92
3A96:  BCF    F8B.4
3A98:  BCF    F94.4
3A9A:  MOVLW  0A
3A9C:  MOVWF  00
3A9E:  DECFSZ 00,F
3AA0:  BRA    3A9E
3AA2:  BCF    F8B.3
3AA4:  BCF    F94.3
....................    i2c_write(command); 
3AA6:  MOVFF  919,923
3AAA:  MOVLB  0
3AAC:  RCALL  3370
....................    i2c_write(address>>8); 
3AAE:  MOVFF  914,91B
3AB2:  MOVFF  915,91C
3AB6:  MOVFF  916,91D
3ABA:  MOVLB  9
3ABC:  CLRF   x1E
3ABE:  MOVFF  914,923
3AC2:  MOVLB  0
3AC4:  RCALL  3370
....................    i2c_write(address); 
3AC6:  MOVFF  913,923
3ACA:  RCALL  3370
....................    i2c_write(data); 
3ACC:  MOVFF  917,923
3AD0:  RCALL  3370
....................  
....................    i2c_stop(); 
3AD2:  BCF    F94.4
3AD4:  NOP   
3AD6:  BSF    F94.3
3AD8:  BTFSS  F82.3
3ADA:  BRA    3AD8
3ADC:  MOVLW  0A
3ADE:  MOVWF  00
3AE0:  DECFSZ 00,F
3AE2:  BRA    3AE0
3AE4:  BRA    3AE6
3AE6:  NOP   
3AE8:  BSF    F94.4
3AEA:  MOVLW  0A
3AEC:  MOVWF  00
3AEE:  DECFSZ 00,F
3AF0:  BRA    3AEE
....................    i2c_start(); 
3AF2:  BSF    F94.4
3AF4:  MOVLW  0A
3AF6:  MOVWF  00
3AF8:  DECFSZ 00,F
3AFA:  BRA    3AF8
3AFC:  BSF    F94.3
3AFE:  MOVLW  0B
3B00:  MOVWF  00
3B02:  DECFSZ 00,F
3B04:  BRA    3B02
3B06:  BCF    F8B.4
3B08:  BCF    F94.4
3B0A:  MOVLW  0A
3B0C:  MOVWF  00
3B0E:  DECFSZ 00,F
3B10:  BRA    3B0E
3B12:  BCF    F8B.3
3B14:  BCF    F94.3
....................    status=i2c_write(command); 
3B16:  MOVFF  919,923
3B1A:  RCALL  3370
3B1C:  MOVF   01,W
3B1E:  MOVLB  9
3B20:  BCF    x18.0
3B22:  BTFSC  01.0
3B24:  BSF    x18.0
....................    while(status==1) 
....................    { 
3B26:  BTFSS  x18.0
3B28:  BRA    3B66
....................       i2c_start(); 
3B2A:  BSF    F94.4
3B2C:  MOVLW  0A
3B2E:  MOVWF  00
3B30:  DECFSZ 00,F
3B32:  BRA    3B30
3B34:  BSF    F94.3
3B36:  MOVLW  0B
3B38:  MOVWF  00
3B3A:  DECFSZ 00,F
3B3C:  BRA    3B3A
3B3E:  BTFSS  F82.3
3B40:  BRA    3B3E
3B42:  BCF    F8B.4
3B44:  BCF    F94.4
3B46:  MOVLW  0A
3B48:  MOVWF  00
3B4A:  DECFSZ 00,F
3B4C:  BRA    3B4A
3B4E:  BCF    F8B.3
3B50:  BCF    F94.3
....................       status=i2c_write(command); 
3B52:  MOVFF  919,923
3B56:  MOVLB  0
3B58:  RCALL  3370
3B5A:  MOVF   01,W
3B5C:  MOVLB  9
3B5E:  BCF    x18.0
3B60:  BTFSC  01.0
3B62:  BSF    x18.0
....................    } 
3B64:  BRA    3B26
....................    //delay_us(100); 
.................... } 
3B66:  MOVLB  0
3B68:  RETURN 0
....................  
....................  
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
*
3450:  MOVLB  9
3452:  MOVF   x1B,F
3454:  BNZ   345C
3456:  MOVF   x1A,W
3458:  SUBLW  00
345A:  BC    3462
345C:  MOVLW  A2
345E:  MOVWF  x1D
.................... #endif 
....................    else command=0xa0; 
3460:  BRA    3466
3462:  MOVLW  A0
3464:  MOVWF  x1D
....................  
....................    i2c_start(); 
3466:  BSF    F94.4
3468:  MOVLW  0A
346A:  MOVWF  00
346C:  DECFSZ 00,F
346E:  BRA    346C
3470:  BSF    F94.3
3472:  MOVLW  0B
3474:  MOVWF  00
3476:  DECFSZ 00,F
3478:  BRA    3476
347A:  BTFSS  F82.3
347C:  BRA    347A
347E:  BCF    F8B.4
3480:  BCF    F94.4
3482:  MOVLW  0A
3484:  MOVWF  00
3486:  DECFSZ 00,F
3488:  BRA    3486
348A:  BCF    F8B.3
348C:  BCF    F94.3
....................    i2c_write(command); 
348E:  MOVFF  91D,923
3492:  MOVLB  0
3494:  RCALL  3370
....................    i2c_write(address>>8); 
3496:  MOVFF  919,91F
349A:  MOVFF  91A,920
349E:  MOVFF  91B,921
34A2:  MOVLB  9
34A4:  CLRF   x22
34A6:  MOVFF  919,923
34AA:  MOVLB  0
34AC:  RCALL  3370
....................    i2c_write(address); 
34AE:  MOVFF  918,923
34B2:  RCALL  3370
....................    i2c_start(); 
34B4:  BSF    F94.4
34B6:  MOVLW  0A
34B8:  MOVWF  00
34BA:  DECFSZ 00,F
34BC:  BRA    34BA
34BE:  BSF    F94.3
34C0:  MOVLW  0B
34C2:  MOVWF  00
34C4:  DECFSZ 00,F
34C6:  BRA    34C4
34C8:  BTFSS  F82.3
34CA:  BRA    34C8
34CC:  BCF    F8B.4
34CE:  BCF    F94.4
34D0:  MOVLW  0A
34D2:  MOVWF  00
34D4:  DECFSZ 00,F
34D6:  BRA    34D4
34D8:  BCF    F8B.3
34DA:  BCF    F94.3
....................    i2c_write(command+1); 
34DC:  MOVLW  01
34DE:  MOVLB  9
34E0:  ADDWF  x1D,W
34E2:  MOVWF  x1E
34E4:  MOVWF  x23
34E6:  MOVLB  0
34E8:  RCALL  3370
....................    data=i2c_read(0); 
34EA:  CLRF   00
34EC:  RCALL  33E6
34EE:  MOVFF  01,91C
....................    i2c_stop(); 
34F2:  BCF    F94.4
34F4:  NOP   
34F6:  BSF    F94.3
34F8:  BTFSS  F82.3
34FA:  BRA    34F8
34FC:  MOVLW  0A
34FE:  MOVWF  00
3500:  DECFSZ 00,F
3502:  BRA    3500
3504:  BRA    3506
3506:  NOP   
3508:  BSF    F94.4
350A:  MOVLW  0A
350C:  MOVWF  00
350E:  DECFSZ 00,F
3510:  BRA    350E
....................    return(data); 
3512:  MOVLB  9
3514:  MOVFF  91C,01
.................... } 
3518:  MOVLB  0
351A:  RETURN 0
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr            0 
.................... #define strobe_ptrcard_addr         25     // 4 bytes 
.................... #define strobe_ptrcard_key          30     // 4 bytes 
.................... #define strobe_count_card           36     // 2 bytes 
.................... #define strobe_nameconsole          40     // 16 bytes  
.................... #define strobe_Master_SLV           58     // 1 byte 
.................... #define strobe_debugmode            59     // 1 byte 
.................... #define strobe_delaytime            60     // 1 byte 
.................... #define kindofKB                    61     // 1 byte 
.................... #define crypto_en                   62     // 1 byte 
.................... #define strobe_crypto_key           63     // 32 byte 
....................  
....................  
.................... #define wide_strobe_nameconsole     16  
.................... //============================================================== 
.................... #define numdata                  124    // 5+79+40=124 
.................... #define numdataofonecard         128    //  
.................... #define countcards               930    //43590/124 
....................  
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdataofonecard]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... #if 0 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... } 
.................... #endif 
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4EE8:  MOVLB  9
4EEA:  CLRF   x04
4EEC:  CLRF   x03
4EEE:  CLRF   x02
4EF0:  CLRF   x01
4EF2:  MOVF   x04,W
4EF4:  MOVLB  8
4EF6:  SUBWF  xFE,W
4EF8:  BNC   4F9C
4EFA:  BNZ   4F24
4EFC:  MOVLB  9
4EFE:  MOVF   x03,W
4F00:  MOVLB  8
4F02:  SUBWF  xFD,W
4F04:  BNC   4F9C
4F06:  BNZ   4F24
4F08:  MOVLB  9
4F0A:  MOVF   x02,W
4F0C:  MOVLB  8
4F0E:  SUBWF  xFC,W
4F10:  BNC   4F9C
4F12:  BNZ   4F24
4F14:  MOVF   xFB,W
4F16:  MOVLB  9
4F18:  SUBWF  x01,W
4F1A:  BTFSS  FD8.0
4F1C:  BRA    4F22
4F1E:  MOVLB  8
4F20:  BRA    4F9C
4F22:  MOVLB  8
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4F24:  MOVLB  9
4F26:  MOVF   x01,W
4F28:  MOVLB  8
4F2A:  ADDWF  xF7,W
4F2C:  MOVLB  9
4F2E:  MOVWF  x05
4F30:  MOVF   x02,W
4F32:  MOVLB  8
4F34:  ADDWFC xF8,W
4F36:  MOVLB  9
4F38:  MOVWF  x06
4F3A:  MOVF   x03,W
4F3C:  MOVLB  8
4F3E:  ADDWFC xF9,W
4F40:  MOVLB  9
4F42:  MOVWF  x07
4F44:  MOVF   x04,W
4F46:  MOVLB  8
4F48:  ADDWFC xFA,W
4F4A:  MOVLB  9
4F4C:  MOVWF  x08
4F4E:  MOVLB  8
4F50:  MOVF   xFF,W
4F52:  MOVLB  9
4F54:  ADDWF  x01,W
4F56:  MOVWF  FE9
4F58:  MOVF   x00,W
4F5A:  ADDWFC x02,W
4F5C:  MOVWF  FEA
4F5E:  MOVFF  FEF,909
4F62:  MOVFF  908,916
4F66:  MOVFF  907,915
4F6A:  MOVFF  906,914
4F6E:  MOVFF  905,913
4F72:  MOVFF  909,917
4F76:  MOVLB  0
4F78:  CALL   3A6C
....................       delay_us(10); 
4F7C:  MOVLW  1A
4F7E:  MOVWF  00
4F80:  DECFSZ 00,F
4F82:  BRA    4F80
4F84:  NOP   
....................    } 
4F86:  MOVLW  01
4F88:  MOVLB  9
4F8A:  ADDWF  x01,F
4F8C:  BTFSC  FD8.0
4F8E:  INCF   x02,F
4F90:  BTFSC  FD8.2
4F92:  INCF   x03,F
4F94:  BTFSC  FD8.2
4F96:  INCF   x04,F
4F98:  BRA    4EF2
4F9A:  MOVLB  8
....................    return 1; 
4F9C:  MOVLW  01
4F9E:  MOVWF  01
.................... } 
4FA0:  MOVLB  0
4FA2:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len,unsigned int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
3FF6:  MOVLB  9
3FF8:  CLRF   x11
3FFA:  CLRF   x10
3FFC:  CLRF   x0F
3FFE:  CLRF   x0E
4000:  MOVF   x11,W
4002:  SUBWF  x0B,W
4004:  BNC   4086
4006:  BNZ   401E
4008:  MOVF   x10,W
400A:  SUBWF  x0A,W
400C:  BNC   4086
400E:  BNZ   401E
4010:  MOVF   x0F,W
4012:  SUBWF  x09,W
4014:  BNC   4086
4016:  BNZ   401E
4018:  MOVF   x08,W
401A:  SUBWF  x0E,W
401C:  BC    4086
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
401E:  MOVF   x0C,W
4020:  ADDWF  x0E,W
4022:  MOVWF  01
4024:  MOVF   x0D,W
4026:  ADDWFC x0F,W
4028:  MOVWF  03
402A:  MOVFF  01,912
402E:  MOVWF  x13
4030:  MOVF   x0E,W
4032:  ADDWF  x04,W
4034:  MOVWF  x14
4036:  MOVF   x0F,W
4038:  ADDWFC x05,W
403A:  MOVWF  x15
403C:  MOVF   x10,W
403E:  ADDWFC x06,W
4040:  MOVWF  x16
4042:  MOVF   x11,W
4044:  ADDWFC x07,W
4046:  MOVWF  x17
4048:  MOVWF  x1B
404A:  MOVFF  916,91A
404E:  MOVFF  915,919
4052:  MOVFF  914,918
4056:  MOVLB  0
4058:  CALL   3450
405C:  MOVFF  913,FEA
4060:  MOVFF  912,FE9
4064:  MOVFF  01,FEF
....................       delay_us(10); 
4068:  MOVLW  1A
406A:  MOVWF  00
406C:  DECFSZ 00,F
406E:  BRA    406C
4070:  NOP   
....................    } 
4072:  MOVLW  01
4074:  MOVLB  9
4076:  ADDWF  x0E,F
4078:  BTFSC  FD8.0
407A:  INCF   x0F,F
407C:  BTFSC  FD8.2
407E:  INCF   x10,F
4080:  BTFSC  FD8.2
4082:  INCF   x11,F
4084:  BRA    4000
.................... } 
4086:  MOVLB  0
4088:  RETURN 0
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
5DDA:  MOVLB  7
5DDC:  CLRF   xC1
5DDE:  CLRF   xC0
5DE0:  CLRF   xBF
5DE2:  CLRF   xBE
5DE4:  CLRF   xC5
5DE6:  CLRF   xC4
5DE8:  CLRF   xC3
5DEA:  CLRF   xC2
5DEC:  CLRF   xC9
5DEE:  CLRF   xC8
5DF0:  CLRF   xC7
5DF2:  CLRF   xC6
5DF4:  CLRF   xCD
5DF6:  CLRF   xCC
5DF8:  CLRF   xCB
5DFA:  CLRF   xCA
5DFC:  CLRF   xD1
5DFE:  CLRF   xD0
5E00:  CLRF   xCF
5E02:  CLRF   xCE
5E04:  CLRF   19
5E06:  BTFSC  FF2.7
5E08:  BSF    19.7
5E0A:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
5E0C:  MOVLB  9
5E0E:  CLRF   x1B
5E10:  CLRF   x1A
5E12:  CLRF   x19
5E14:  MOVFF  7BD,918
5E18:  MOVLB  0
5E1A:  CALL   3450
5E1E:  BTFSC  19.7
5E20:  BSF    FF2.7
5E22:  MOVLB  7
5E24:  MOVFF  01,7C2
5E28:  CLRF   xC3
5E2A:  CLRF   xC4
5E2C:  CLRF   xC5
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
5E2E:  MOVLW  01
5E30:  ADDWF  xBD,W
5E32:  MOVWF  xD2
5E34:  CLRF   19
5E36:  BTFSC  FF2.7
5E38:  BSF    19.7
5E3A:  BCF    FF2.7
5E3C:  MOVLB  9
5E3E:  CLRF   x1B
5E40:  CLRF   x1A
5E42:  CLRF   x19
5E44:  MOVWF  x18
5E46:  MOVLB  0
5E48:  CALL   3450
5E4C:  BTFSC  19.7
5E4E:  BSF    FF2.7
5E50:  MOVLB  7
5E52:  CLRF   xC9
5E54:  CLRF   xC8
5E56:  CLRF   xC7
5E58:  MOVFF  01,7C6
....................    temp2<<=8; 
5E5C:  MOVFF  7C8,7C9
5E60:  MOVFF  7C7,7C8
5E64:  MOVFF  7C6,7C7
5E68:  CLRF   xC6
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
5E6A:  MOVLW  02
5E6C:  ADDWF  xBD,W
5E6E:  MOVWF  xD2
5E70:  CLRF   19
5E72:  BTFSC  FF2.7
5E74:  BSF    19.7
5E76:  BCF    FF2.7
5E78:  MOVLB  9
5E7A:  CLRF   x1B
5E7C:  CLRF   x1A
5E7E:  CLRF   x19
5E80:  MOVWF  x18
5E82:  MOVLB  0
5E84:  CALL   3450
5E88:  BTFSC  19.7
5E8A:  BSF    FF2.7
5E8C:  MOVLB  7
5E8E:  CLRF   xCD
5E90:  CLRF   xCC
5E92:  CLRF   xCB
5E94:  MOVFF  01,7CA
....................    temp3<<=16; 
5E98:  MOVFF  7CB,7CD
5E9C:  MOVFF  7CA,7CC
5EA0:  CLRF   xCA
5EA2:  CLRF   xCB
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
5EA4:  MOVLW  03
5EA6:  ADDWF  xBD,W
5EA8:  MOVWF  xD2
5EAA:  CLRF   19
5EAC:  BTFSC  FF2.7
5EAE:  BSF    19.7
5EB0:  BCF    FF2.7
5EB2:  MOVLB  9
5EB4:  CLRF   x1B
5EB6:  CLRF   x1A
5EB8:  CLRF   x19
5EBA:  MOVWF  x18
5EBC:  MOVLB  0
5EBE:  CALL   3450
5EC2:  BTFSC  19.7
5EC4:  BSF    FF2.7
5EC6:  MOVLB  7
5EC8:  CLRF   xD1
5ECA:  CLRF   xD0
5ECC:  CLRF   xCF
5ECE:  MOVFF  01,7CE
....................    temp4<<=24; 
5ED2:  MOVFF  7CE,7D1
5ED6:  CLRF   xCE
5ED8:  CLRF   xCF
5EDA:  CLRF   xD0
....................    buffer = temp4|temp3|temp2|temp1; 
5EDC:  MOVF   xCE,W
5EDE:  IORWF  xCA,W
5EE0:  MOVWF  xD2
5EE2:  MOVF   xCF,W
5EE4:  IORWF  xCB,W
5EE6:  MOVWF  xD3
5EE8:  MOVF   xD0,W
5EEA:  IORWF  xCC,W
5EEC:  MOVWF  xD4
5EEE:  MOVF   xD1,W
5EF0:  IORWF  xCD,W
5EF2:  MOVWF  xD5
5EF4:  MOVF   xC6,W
5EF6:  IORWF  xD2,F
5EF8:  MOVF   xC7,W
5EFA:  IORWF  xD3,F
5EFC:  MOVF   xC8,W
5EFE:  IORWF  xD4,F
5F00:  MOVF   xC9,W
5F02:  IORWF  xD5,F
5F04:  MOVF   xD2,W
5F06:  IORWF  xC2,W
5F08:  MOVWF  xBE
5F0A:  MOVF   xD3,W
5F0C:  IORWF  xC3,W
5F0E:  MOVWF  xBF
5F10:  MOVF   xD4,W
5F12:  IORWF  xC4,W
5F14:  MOVWF  xC0
5F16:  MOVF   xD5,W
5F18:  IORWF  xC5,W
5F1A:  MOVWF  xC1
....................    return(buffer); 
5F1C:  MOVFF  7BE,00
5F20:  MOVFF  7BF,01
5F24:  MOVFF  7C0,02
5F28:  MOVFF  7C1,03
.................... } 
5F2C:  MOVLB  0
5F2E:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3B6A:  MOVLB  8
3B6C:  CLRF   xFF
3B6E:  CLRF   xFE
3B70:  CLRF   xFD
3B72:  CLRF   xFC
3B74:  MOVLB  9
3B76:  CLRF   x00
3B78:  CLRF   x01
3B7A:  CLRF   x02
3B7C:  CLRF   x03
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3B7E:  MOVFF  8FA,8FF
3B82:  MOVFF  8F9,8FE
3B86:  MOVFF  8F8,8FD
3B8A:  MOVFF  8F7,8FC
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3B8E:  MOVFF  8FC,900
3B92:  MOVLB  9
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3B94:  MOVFF  8FD,901
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3B98:  MOVFF  8FE,902
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3B9C:  MOVFF  8FF,903
....................    write_ext_eeprom((addr+0),temp1); 
3BA0:  CLRF   x16
3BA2:  CLRF   x15
3BA4:  CLRF   x14
3BA6:  MOVFF  8FB,913
3BAA:  MOVFF  900,917
3BAE:  MOVLB  0
3BB0:  RCALL  3A6C
....................    write_ext_eeprom((addr+1),temp2); 
3BB2:  MOVLW  01
3BB4:  MOVLB  8
3BB6:  ADDWF  xFB,W
3BB8:  MOVLB  9
3BBA:  MOVWF  x04
3BBC:  CLRF   x16
3BBE:  CLRF   x15
3BC0:  CLRF   x14
3BC2:  MOVWF  x13
3BC4:  MOVFF  901,917
3BC8:  MOVLB  0
3BCA:  RCALL  3A6C
....................    write_ext_eeprom((addr+2),temp3); 
3BCC:  MOVLW  02
3BCE:  MOVLB  8
3BD0:  ADDWF  xFB,W
3BD2:  MOVLB  9
3BD4:  MOVWF  x04
3BD6:  CLRF   x16
3BD8:  CLRF   x15
3BDA:  CLRF   x14
3BDC:  MOVWF  x13
3BDE:  MOVFF  902,917
3BE2:  MOVLB  0
3BE4:  RCALL  3A6C
....................    write_ext_eeprom((addr+3),temp4); 
3BE6:  MOVLW  03
3BE8:  MOVLB  8
3BEA:  ADDWF  xFB,W
3BEC:  MOVLB  9
3BEE:  MOVWF  x04
3BF0:  CLRF   x16
3BF2:  CLRF   x15
3BF4:  CLRF   x14
3BF6:  MOVWF  x13
3BF8:  MOVFF  903,917
3BFC:  MOVLB  0
3BFE:  RCALL  3A6C
.................... } 
3C00:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
589C:  MOVLB  8
589E:  CLRF   x53
58A0:  CLRF   x52
58A2:  CLRF   x54
58A4:  CLRF   x55
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
58A6:  MOVFF  851,853
58AA:  MOVFF  850,852
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
58AE:  MOVFF  852,854
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
58B2:  MOVF   x53,W
58B4:  MOVWF  x55
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
58B6:  MOVLB  9
58B8:  CLRF   x16
58BA:  CLRF   x15
58BC:  CLRF   x14
58BE:  MOVLW  24
58C0:  MOVWF  x13
58C2:  MOVFF  854,917
58C6:  MOVLB  0
58C8:  CALL   3A6C
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
58CC:  MOVLB  9
58CE:  CLRF   x16
58D0:  CLRF   x15
58D2:  CLRF   x14
58D4:  MOVLW  25
58D6:  MOVWF  x13
58D8:  MOVFF  855,917
58DC:  MOVLB  0
58DE:  CALL   3A6C
.................... } 
58E2:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
351C:  MOVLB  8
351E:  CLRF   xF8
3520:  CLRF   xF7
3522:  CLRF   xFA
3524:  CLRF   xF9
3526:  CLRF   xFC
3528:  CLRF   xFB
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
352A:  MOVLB  9
352C:  CLRF   x1B
352E:  CLRF   x1A
3530:  CLRF   x19
3532:  MOVLW  24
3534:  MOVWF  x18
3536:  MOVLB  0
3538:  RCALL  3450
353A:  MOVLB  8
353C:  MOVFF  01,8F9
3540:  CLRF   xFA
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3542:  MOVLB  9
3544:  CLRF   x1B
3546:  CLRF   x1A
3548:  CLRF   x19
354A:  MOVLW  25
354C:  MOVWF  x18
354E:  MOVLB  0
3550:  RCALL  3450
3552:  MOVLB  8
3554:  CLRF   xFC
3556:  MOVFF  01,8FB
....................    temp2<<=8; 
355A:  MOVFF  8FB,8FC
355E:  CLRF   xFB
....................    buffer = temp2|temp1; 
3560:  MOVF   xFB,W
3562:  IORWF  xF9,W
3564:  MOVWF  xF7
3566:  MOVF   xFC,W
3568:  IORWF  xFA,W
356A:  MOVWF  xF8
....................    return(buffer); 
356C:  MOVFF  8F7,01
3570:  MOVFF  8F8,02
.................... } 
3574:  MOVLB  0
3576:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................    /*for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    }*/ 
....................    //fprintf(COM2," ptr_card=%lu\n\r",ptr_card); 
....................    /*for(i=ptr_start;i<ptr_card;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
*
68B6:  CLRF   23
68B8:  CLRF   22
68BA:  CLRF   21
68BC:  MOVLW  96
68BE:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
68C0:  CLRF   27
68C2:  CLRF   26
68C4:  MOVLW  E1
68C6:  MOVWF  25
68C8:  MOVLW  01
68CA:  MOVWF  24
68CC:  CLRF   19
68CE:  BTFSC  FF2.7
68D0:  BSF    19.7
68D2:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
68D4:  MOVFF  23,8FA
68D8:  MOVFF  22,8F9
68DC:  MOVFF  21,8F8
68E0:  MOVFF  20,8F7
68E4:  MOVLW  19
68E6:  MOVLB  8
68E8:  MOVWF  xFB
68EA:  MOVLB  0
68EC:  CALL   3B6A
68F0:  BTFSC  19.7
68F2:  BSF    FF2.7
68F4:  CLRF   19
68F6:  BTFSC  FF2.7
68F8:  BSF    19.7
68FA:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
68FC:  MOVFF  27,8FA
6900:  MOVFF  26,8F9
6904:  MOVFF  25,8F8
6908:  MOVFF  24,8F7
690C:  MOVLW  1E
690E:  MOVLB  8
6910:  MOVWF  xFB
6912:  MOVLB  0
6914:  CALL   3B6A
6918:  BTFSC  19.7
691A:  BSF    FF2.7
691C:  CLRF   19
691E:  BTFSC  FF2.7
6920:  BSF    19.7
6922:  BCF    FF2.7
....................    save_coutcard(0); 
6924:  MOVLB  8
6926:  CLRF   x51
6928:  CLRF   x50
692A:  MOVLB  0
692C:  CALL   589C
6930:  BTFSC  19.7
6932:  BSF    FF2.7
6934:  CLRF   19
6936:  BTFSC  FF2.7
6938:  BSF    19.7
693A:  BCF    FF2.7
....................    countcard=get_countcard(); 
693C:  CALL   351C
6940:  BTFSC  19.7
6942:  BSF    FF2.7
6944:  MOVFF  02,FE
6948:  MOVFF  01,FD
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
694C:  GOTO   6CAC (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    ptr_card=ptr_start; 
6950:  CLRF   23
6952:  CLRF   22
6954:  CLRF   21
6956:  MOVLW  96
6958:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
695A:  CLRF   27
695C:  CLRF   26
695E:  MOVLW  E1
6960:  MOVWF  25
6962:  MOVLW  01
6964:  MOVWF  24
6966:  CLRF   19
6968:  BTFSC  FF2.7
696A:  BSF    19.7
696C:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
696E:  MOVFF  23,8FA
6972:  MOVFF  22,8F9
6976:  MOVFF  21,8F8
697A:  MOVFF  20,8F7
697E:  MOVLW  19
6980:  MOVLB  8
6982:  MOVWF  xFB
6984:  MOVLB  0
6986:  CALL   3B6A
698A:  BTFSC  19.7
698C:  BSF    FF2.7
698E:  CLRF   19
6990:  BTFSC  FF2.7
6992:  BSF    19.7
6994:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
6996:  MOVFF  27,8FA
699A:  MOVFF  26,8F9
699E:  MOVFF  25,8F8
69A2:  MOVFF  24,8F7
69A6:  MOVLW  1E
69A8:  MOVLB  8
69AA:  MOVWF  xFB
69AC:  MOVLB  0
69AE:  CALL   3B6A
69B2:  BTFSC  19.7
69B4:  BSF    FF2.7
69B6:  CLRF   19
69B8:  BTFSC  FF2.7
69BA:  BSF    19.7
69BC:  BCF    FF2.7
....................    save_coutcard(0); 
69BE:  MOVLB  8
69C0:  CLRF   x51
69C2:  CLRF   x50
69C4:  MOVLB  0
69C6:  CALL   589C
69CA:  BTFSC  19.7
69CC:  BSF    FF2.7
.................... } 
69CE:  GOTO   6D10 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
*
5D1A:  CLRF   19
5D1C:  BTFSC  FF2.7
5D1E:  BSF    19.7
5D20:  BCF    FF2.7
....................       EEPROM_read(strobe_pass_addr,20,password); 
5D22:  MOVLB  9
5D24:  CLRF   x07
5D26:  CLRF   x06
5D28:  CLRF   x05
5D2A:  CLRF   x04
5D2C:  CLRF   x0B
5D2E:  CLRF   x0A
5D30:  CLRF   x09
5D32:  MOVLW  14
5D34:  MOVWF  x08
5D36:  CLRF   x0D
5D38:  MOVLW  55
5D3A:  MOVWF  x0C
5D3C:  MOVLB  0
5D3E:  CALL   3FF6
5D42:  BTFSC  19.7
5D44:  BSF    FF2.7
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5D46:  INCFSZ 55,W
5D48:  BRA    5DD8
5D4A:  INCFSZ 56,W
5D4C:  BRA    5DD8
5D4E:  INCFSZ x64,W
5D50:  BRA    5DD8
....................       { 
....................          memset(buffer1,0,20); 
5D52:  CLRF   FEA
5D54:  MOVLW  2D
5D56:  MOVWF  FE9
5D58:  CLRF   00
5D5A:  CLRF   02
5D5C:  MOVLW  14
5D5E:  MOVWF  01
5D60:  CALL   359A
....................          strcpy(buffer1,"admin"); 
5D64:  CLRF   FEA
5D66:  MOVLW  2D
5D68:  MOVWF  FE9
5D6A:  MOVLW  00
5D6C:  CALL   00BA
5D70:  TBLRD*-
5D72:  TBLRD*+
5D74:  MOVF   FF5,W
5D76:  MOVWF  FEE
5D78:  IORLW  00
5D7A:  BNZ   5D72
5D7C:  CLRF   19
5D7E:  BTFSC  FF2.7
5D80:  BSF    19.7
5D82:  BCF    FF2.7
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
5D84:  MOVLB  8
5D86:  CLRF   xFA
5D88:  CLRF   xF9
5D8A:  CLRF   xF8
5D8C:  CLRF   xF7
5D8E:  CLRF   xFE
5D90:  CLRF   xFD
5D92:  CLRF   xFC
5D94:  MOVLW  14
5D96:  MOVWF  xFB
5D98:  MOVLB  9
5D9A:  CLRF   x00
5D9C:  MOVLW  2D
5D9E:  MOVLB  8
5DA0:  MOVWF  xFF
5DA2:  MOVLB  0
5DA4:  CALL   4EE8
5DA8:  BTFSC  19.7
5DAA:  BSF    FF2.7
5DAC:  CLRF   19
5DAE:  BTFSC  FF2.7
5DB0:  BSF    19.7
5DB2:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
5DB4:  MOVLB  9
5DB6:  CLRF   x07
5DB8:  CLRF   x06
5DBA:  CLRF   x05
5DBC:  CLRF   x04
5DBE:  CLRF   x0B
5DC0:  CLRF   x0A
5DC2:  CLRF   x09
5DC4:  MOVLW  14
5DC6:  MOVWF  x08
5DC8:  CLRF   x0D
5DCA:  MOVLW  55
5DCC:  MOVWF  x0C
5DCE:  MOVLB  0
5DD0:  CALL   3FF6
5DD4:  BTFSC  19.7
5DD6:  BSF    FF2.7
....................       } 
.................... } 
5DD8:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
69D2:  MOVLB  8
69D4:  CLRF   x07
69D6:  MOVF   x07,W
69D8:  SUBLW  13
69DA:  BNC   69F0
69DC:  CLRF   03
69DE:  MOVF   x07,W
69E0:  ADDLW  F3
69E2:  MOVWF  FE9
69E4:  MOVLW  07
69E6:  ADDWFC 03,W
69E8:  MOVWF  FEA
69EA:  SETF   FEF
69EC:  INCF   x07,F
69EE:  BRA    69D6
69F0:  CLRF   19
69F2:  BTFSC  FF2.7
69F4:  BSF    19.7
69F6:  BCF    FF2.7
....................    EEPROM_write(strobe_pass_addr,20,buf); 
69F8:  CLRF   xFA
69FA:  CLRF   xF9
69FC:  CLRF   xF8
69FE:  CLRF   xF7
6A00:  CLRF   xFE
6A02:  CLRF   xFD
6A04:  CLRF   xFC
6A06:  MOVLW  14
6A08:  MOVWF  xFB
6A0A:  MOVLW  07
6A0C:  MOVLB  9
6A0E:  MOVWF  x00
6A10:  MOVLW  F3
6A12:  MOVLB  8
6A14:  MOVWF  xFF
6A16:  MOVLB  0
6A18:  CALL   4EE8
6A1C:  BTFSC  19.7
6A1E:  BSF    FF2.7
.................... } 
6A20:  GOTO   6D74 (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
....................  
.................... #define CRYPTO_KEY_SIZE   32 
....................  
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 cryption_enable=0; 
....................  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int16 galois_mul2(unsigned int16 value) 
.................... { 
....................   signed int16 temp; 
....................   // cast to signed value 
....................   temp = (signed char) value; 
*
408A:  CLRF   03
408C:  MOVLB  9
408E:  MOVF   x0D,W
4090:  BTFSC  FE8.7
4092:  DECF   03,F
4094:  MOVWF  x0F
4096:  MOVFF  03,910
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
409A:  RRCF   x10,W
409C:  MOVWF  03
409E:  RRCF   x0F,W
40A0:  MOVWF  02
40A2:  RRCF   03,F
40A4:  RRCF   02,F
40A6:  RRCF   03,F
40A8:  RRCF   02,F
40AA:  RRCF   03,F
40AC:  RRCF   02,F
40AE:  RRCF   03,F
40B0:  RRCF   02,F
40B2:  RRCF   03,F
40B4:  RRCF   02,F
40B6:  RRCF   03,F
40B8:  RRCF   02,F
40BA:  MOVLW  01
40BC:  ANDWF  03,F
40BE:  MOVFF  02,90F
40C2:  MOVFF  03,910
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
40C6:  MOVLW  1B
40C8:  ANDWF  x0F,F
40CA:  CLRF   x10
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
40CC:  BCF    FD8.0
40CE:  RLCF   x0D,W
40D0:  MOVWF  x11
40D2:  RLCF   x0E,W
40D4:  MOVWF  x12
40D6:  MOVF   x11,W
40D8:  XORWF  x0F,W
40DA:  MOVWF  00
40DC:  MOVF   x12,W
40DE:  XORWF  x10,W
40E0:  MOVWF  03
40E2:  MOVFF  00,01
40E6:  MOVWF  02
.................... } 
40E8:  MOVLB  0
40EA:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................     unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................  
....................   // In case of decryption 
....................   if (dir != 0)  
40EC:  MOVLB  8
40EE:  MOVF   xFB,F
40F0:  BTFSC  FD8.2
40F2:  BRA    42FC
....................   { 
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
40F4:  MOVLB  9
40F6:  CLRF   x00
40F8:  MOVF   x00,W
40FA:  SUBLW  09
40FC:  BTFSS  FD8.0
40FE:  BRA    42A6
....................       //key schedule 
....................       key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[round]); 
4100:  MOVFF  8F9,01
4104:  MOVFF  8FA,03
4108:  MOVFF  8F9,902
410C:  MOVFF  8FA,903
4110:  MOVLW  0D
4112:  MOVLB  8
4114:  ADDWF  xF9,W
4116:  MOVWF  FE9
4118:  MOVLW  00
411A:  ADDWFC xFA,W
411C:  MOVWF  FEA
411E:  CLRF   03
4120:  MOVF   FEF,W
4122:  MOVLB  0
4124:  CALL   00D0
4128:  MOVLB  9
412A:  MOVWF  x04
412C:  MOVLB  8
412E:  MOVFF  8F9,FE9
4132:  MOVFF  8FA,FEA
4136:  MOVF   FEF,W
4138:  MOVLB  9
413A:  XORWF  x04,F
413C:  CLRF   03
413E:  MOVF   x00,W
4140:  MOVLB  0
4142:  CALL   02F0
4146:  MOVWF  01
4148:  MOVLB  9
414A:  MOVF   x04,W
414C:  XORWF  01,W
414E:  MOVFF  903,FEA
4152:  MOVFF  902,FE9
4156:  MOVWF  FEF
....................       key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4158:  MOVLW  01
415A:  MOVLB  8
415C:  ADDWF  xF9,W
415E:  MOVWF  01
4160:  MOVLW  00
4162:  ADDWFC xFA,W
4164:  MOVWF  03
4166:  MOVFF  01,902
416A:  MOVLB  9
416C:  MOVWF  x03
416E:  MOVLW  0E
4170:  MOVLB  8
4172:  ADDWF  xF9,W
4174:  MOVWF  FE9
4176:  MOVLW  00
4178:  ADDWFC xFA,W
417A:  MOVWF  FEA
417C:  CLRF   03
417E:  MOVF   FEF,W
4180:  MOVLB  0
4182:  CALL   00D0
4186:  MOVLB  9
4188:  MOVWF  x04
418A:  MOVLW  01
418C:  MOVLB  8
418E:  ADDWF  xF9,W
4190:  MOVWF  FE9
4192:  MOVLW  00
4194:  ADDWFC xFA,W
4196:  MOVWF  FEA
4198:  MOVF   FEF,W
419A:  MOVLB  9
419C:  XORWF  x04,W
419E:  MOVFF  903,FEA
41A2:  MOVFF  902,FE9
41A6:  MOVWF  FEF
....................       key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
41A8:  MOVLW  02
41AA:  MOVLB  8
41AC:  ADDWF  xF9,W
41AE:  MOVWF  01
41B0:  MOVLW  00
41B2:  ADDWFC xFA,W
41B4:  MOVWF  03
41B6:  MOVFF  01,902
41BA:  MOVLB  9
41BC:  MOVWF  x03
41BE:  MOVLW  0F
41C0:  MOVLB  8
41C2:  ADDWF  xF9,W
41C4:  MOVWF  FE9
41C6:  MOVLW  00
41C8:  ADDWFC xFA,W
41CA:  MOVWF  FEA
41CC:  CLRF   03
41CE:  MOVF   FEF,W
41D0:  MOVLB  0
41D2:  CALL   00D0
41D6:  MOVLB  9
41D8:  MOVWF  x04
41DA:  MOVLW  02
41DC:  MOVLB  8
41DE:  ADDWF  xF9,W
41E0:  MOVWF  FE9
41E2:  MOVLW  00
41E4:  ADDWFC xFA,W
41E6:  MOVWF  FEA
41E8:  MOVF   FEF,W
41EA:  MOVLB  9
41EC:  XORWF  x04,W
41EE:  MOVFF  903,FEA
41F2:  MOVFF  902,FE9
41F6:  MOVWF  FEF
....................       key[3] = (unsigned int8)(sbox[key[12]]^key[3]); 
41F8:  MOVLW  03
41FA:  MOVLB  8
41FC:  ADDWF  xF9,W
41FE:  MOVWF  01
4200:  MOVLW  00
4202:  ADDWFC xFA,W
4204:  MOVWF  03
4206:  MOVFF  01,902
420A:  MOVLB  9
420C:  MOVWF  x03
420E:  MOVLW  0C
4210:  MOVLB  8
4212:  ADDWF  xF9,W
4214:  MOVWF  FE9
4216:  MOVLW  00
4218:  ADDWFC xFA,W
421A:  MOVWF  FEA
421C:  CLRF   03
421E:  MOVF   FEF,W
4220:  MOVLB  0
4222:  CALL   00D0
4226:  MOVLB  9
4228:  MOVWF  x04
422A:  MOVLW  03
422C:  MOVLB  8
422E:  ADDWF  xF9,W
4230:  MOVWF  FE9
4232:  MOVLW  00
4234:  ADDWFC xFA,W
4236:  MOVWF  FEA
4238:  MOVF   FEF,W
423A:  MOVLB  9
423C:  XORWF  x04,W
423E:  MOVFF  903,FEA
4242:  MOVFF  902,FE9
4246:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4248:  MOVLW  04
424A:  MOVWF  x01
424C:  MOVF   x01,W
424E:  SUBLW  0F
4250:  BNC   42A2
....................         key[i] = key[i] ^ key[i-4]; 
4252:  CLRF   03
4254:  MOVF   x01,W
4256:  MOVLB  8
4258:  ADDWF  xF9,W
425A:  MOVWF  01
425C:  MOVF   xFA,W
425E:  ADDWFC 03,F
4260:  MOVLB  9
4262:  MOVFF  03,903
4266:  CLRF   03
4268:  MOVF   x01,W
426A:  MOVLB  8
426C:  ADDWF  xF9,W
426E:  MOVWF  FE9
4270:  MOVF   xFA,W
4272:  ADDWFC 03,W
4274:  MOVWF  FEA
4276:  MOVFF  FEF,904
427A:  MOVLW  04
427C:  MOVLB  9
427E:  SUBWF  x01,W
4280:  CLRF   03
4282:  MOVLB  8
4284:  ADDWF  xF9,W
4286:  MOVWF  FE9
4288:  MOVF   xFA,W
428A:  ADDWFC 03,W
428C:  MOVWF  FEA
428E:  MOVF   FEF,W
4290:  MOVLB  9
4292:  XORWF  x04,W
4294:  MOVFF  903,FEA
4298:  MOVFF  01,FE9
429C:  MOVWF  FEF
....................       } 
429E:  INCF   x01,F
42A0:  BRA    424C
....................     } 
42A2:  INCF   x00,F
42A4:  BRA    40F8
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++) 
42A6:  CLRF   x01
42A8:  MOVF   x01,W
42AA:  SUBLW  0F
42AC:  BNC   42FC
....................     { 
....................       state[i]=state[i] ^ key[i]; 
42AE:  CLRF   03
42B0:  MOVF   x01,W
42B2:  MOVLB  8
42B4:  ADDWF  xF7,W
42B6:  MOVWF  01
42B8:  MOVF   xF8,W
42BA:  ADDWFC 03,F
42BC:  MOVLB  9
42BE:  MOVFF  03,903
42C2:  CLRF   03
42C4:  MOVF   x01,W
42C6:  MOVLB  8
42C8:  ADDWF  xF7,W
42CA:  MOVWF  FE9
42CC:  MOVF   xF8,W
42CE:  ADDWFC 03,W
42D0:  MOVWF  FEA
42D2:  MOVFF  FEF,904
42D6:  CLRF   03
42D8:  MOVLB  9
42DA:  MOVF   x01,W
42DC:  MOVLB  8
42DE:  ADDWF  xF9,W
42E0:  MOVWF  FE9
42E2:  MOVF   xFA,W
42E4:  ADDWFC 03,W
42E6:  MOVWF  FEA
42E8:  MOVF   FEF,W
42EA:  MOVLB  9
42EC:  XORWF  x04,W
42EE:  MOVFF  903,FEA
42F2:  MOVFF  01,FE9
42F6:  MOVWF  FEF
....................     } 
42F8:  INCF   x01,F
42FA:  BRA    42A8
....................   } 
....................   // main loop 
....................   for (round = 0; round < 10; round++) 
42FC:  MOVLB  9
42FE:  CLRF   x00
4300:  MOVF   x00,W
4302:  SUBLW  09
4304:  BTFSS  FD8.0
4306:  GOTO   4E84
....................   { 
....................     if (dir != 0) 
430A:  MOVLB  8
430C:  MOVF   xFB,F
430E:  BTFSC  FD8.2
4310:  BRA    44BE
....................     { 
....................           //Inverse key schedule 
....................           for (i=15; i>3; --i)  
4312:  MOVLW  0F
4314:  MOVLB  9
4316:  MOVWF  x01
4318:  MOVF   x01,W
431A:  SUBLW  03
431C:  BC    436E
....................           { 
....................             key[i] = key[i] ^ key[i-4]; 
431E:  CLRF   03
4320:  MOVF   x01,W
4322:  MOVLB  8
4324:  ADDWF  xF9,W
4326:  MOVWF  01
4328:  MOVF   xFA,W
432A:  ADDWFC 03,F
432C:  MOVLB  9
432E:  MOVFF  03,903
4332:  CLRF   03
4334:  MOVF   x01,W
4336:  MOVLB  8
4338:  ADDWF  xF9,W
433A:  MOVWF  FE9
433C:  MOVF   xFA,W
433E:  ADDWFC 03,W
4340:  MOVWF  FEA
4342:  MOVFF  FEF,904
4346:  MOVLW  04
4348:  MOVLB  9
434A:  SUBWF  x01,W
434C:  CLRF   03
434E:  MOVLB  8
4350:  ADDWF  xF9,W
4352:  MOVWF  FE9
4354:  MOVF   xFA,W
4356:  ADDWFC 03,W
4358:  MOVWF  FEA
435A:  MOVF   FEF,W
435C:  MOVLB  9
435E:  XORWF  x04,W
4360:  MOVFF  903,FEA
4364:  MOVFF  01,FE9
4368:  MOVWF  FEF
....................           }   
436A:  DECF   x01,F
436C:  BRA    4318
....................           key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[9-round]); 
436E:  MOVFF  8F9,01
4372:  MOVFF  8FA,03
4376:  MOVFF  8F9,902
437A:  MOVFF  8FA,903
437E:  MOVLW  0D
4380:  MOVLB  8
4382:  ADDWF  xF9,W
4384:  MOVWF  FE9
4386:  MOVLW  00
4388:  ADDWFC xFA,W
438A:  MOVWF  FEA
438C:  CLRF   03
438E:  MOVF   FEF,W
4390:  MOVLB  0
4392:  CALL   00D0
4396:  MOVLB  9
4398:  MOVWF  x04
439A:  MOVLB  8
439C:  MOVFF  8F9,FE9
43A0:  MOVFF  8FA,FEA
43A4:  MOVF   FEF,W
43A6:  MOVLB  9
43A8:  XORWF  x04,F
43AA:  MOVLW  09
43AC:  BSF    FD8.0
43AE:  SUBFWB x00,W
43B0:  CLRF   03
43B2:  MOVLB  0
43B4:  CALL   02F0
43B8:  MOVWF  01
43BA:  MOVLB  9
43BC:  MOVF   x04,W
43BE:  XORWF  01,W
43C0:  MOVFF  903,FEA
43C4:  MOVFF  902,FE9
43C8:  MOVWF  FEF
....................           key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
43CA:  MOVLW  01
43CC:  MOVLB  8
43CE:  ADDWF  xF9,W
43D0:  MOVWF  01
43D2:  MOVLW  00
43D4:  ADDWFC xFA,W
43D6:  MOVWF  03
43D8:  MOVFF  01,902
43DC:  MOVLB  9
43DE:  MOVWF  x03
43E0:  MOVLW  0E
43E2:  MOVLB  8
43E4:  ADDWF  xF9,W
43E6:  MOVWF  FE9
43E8:  MOVLW  00
43EA:  ADDWFC xFA,W
43EC:  MOVWF  FEA
43EE:  CLRF   03
43F0:  MOVF   FEF,W
43F2:  MOVLB  0
43F4:  CALL   00D0
43F8:  MOVLB  9
43FA:  MOVWF  x04
43FC:  MOVLW  01
43FE:  MOVLB  8
4400:  ADDWF  xF9,W
4402:  MOVWF  FE9
4404:  MOVLW  00
4406:  ADDWFC xFA,W
4408:  MOVWF  FEA
440A:  MOVF   FEF,W
440C:  MOVLB  9
440E:  XORWF  x04,W
4410:  MOVFF  903,FEA
4414:  MOVFF  902,FE9
4418:  MOVWF  FEF
....................           key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
441A:  MOVLW  02
441C:  MOVLB  8
441E:  ADDWF  xF9,W
4420:  MOVWF  01
4422:  MOVLW  00
4424:  ADDWFC xFA,W
4426:  MOVWF  03
4428:  MOVFF  01,902
442C:  MOVLB  9
442E:  MOVWF  x03
4430:  MOVLW  0F
4432:  MOVLB  8
4434:  ADDWF  xF9,W
4436:  MOVWF  FE9
4438:  MOVLW  00
443A:  ADDWFC xFA,W
443C:  MOVWF  FEA
443E:  CLRF   03
4440:  MOVF   FEF,W
4442:  MOVLB  0
4444:  CALL   00D0
4448:  MOVLB  9
444A:  MOVWF  x04
444C:  MOVLW  02
444E:  MOVLB  8
4450:  ADDWF  xF9,W
4452:  MOVWF  FE9
4454:  MOVLW  00
4456:  ADDWFC xFA,W
4458:  MOVWF  FEA
445A:  MOVF   FEF,W
445C:  MOVLB  9
445E:  XORWF  x04,W
4460:  MOVFF  903,FEA
4464:  MOVFF  902,FE9
4468:  MOVWF  FEF
....................           key[3] = (unsigned int8)(sbox[key[12]]^key[3]);  
446A:  MOVLW  03
446C:  MOVLB  8
446E:  ADDWF  xF9,W
4470:  MOVWF  01
4472:  MOVLW  00
4474:  ADDWFC xFA,W
4476:  MOVWF  03
4478:  MOVFF  01,902
447C:  MOVLB  9
447E:  MOVWF  x03
4480:  MOVLW  0C
4482:  MOVLB  8
4484:  ADDWF  xF9,W
4486:  MOVWF  FE9
4488:  MOVLW  00
448A:  ADDWFC xFA,W
448C:  MOVWF  FEA
448E:  CLRF   03
4490:  MOVF   FEF,W
4492:  MOVLB  0
4494:  CALL   00D0
4498:  MOVLB  9
449A:  MOVWF  x04
449C:  MOVLW  03
449E:  MOVLB  8
44A0:  ADDWF  xF9,W
44A2:  MOVWF  FE9
44A4:  MOVLW  00
44A6:  ADDWFC xFA,W
44A8:  MOVWF  FEA
44AA:  MOVF   FEF,W
44AC:  MOVLB  9
44AE:  XORWF  x04,W
44B0:  MOVFF  903,FEA
44B4:  MOVFF  902,FE9
44B8:  MOVWF  FEF
....................     }  
....................     else  
44BA:  BRA    4718
44BC:  MOVLB  8
....................     { 
....................         for (i = 0; i <16; i++) 
44BE:  MOVLB  9
44C0:  CLRF   x01
44C2:  MOVF   x01,W
44C4:  SUBLW  0F
44C6:  BNC   4524
....................         { 
....................             // with shiftrow i+5 mod 16 
....................             state[i]=sbox[state[i] ^ key[i]]; 
44C8:  CLRF   03
44CA:  MOVF   x01,W
44CC:  MOVLB  8
44CE:  ADDWF  xF7,W
44D0:  MOVWF  01
44D2:  MOVF   xF8,W
44D4:  ADDWFC 03,F
44D6:  MOVFF  01,902
44DA:  MOVLB  9
44DC:  MOVFF  03,903
44E0:  CLRF   03
44E2:  MOVF   x01,W
44E4:  MOVLB  8
44E6:  ADDWF  xF7,W
44E8:  MOVWF  FE9
44EA:  MOVF   xF8,W
44EC:  ADDWFC 03,W
44EE:  MOVWF  FEA
44F0:  MOVFF  FEF,904
44F4:  CLRF   03
44F6:  MOVLB  9
44F8:  MOVF   x01,W
44FA:  MOVLB  8
44FC:  ADDWF  xF9,W
44FE:  MOVWF  FE9
4500:  MOVF   xFA,W
4502:  ADDWFC 03,W
4504:  MOVWF  FEA
4506:  MOVF   FEF,W
4508:  MOVLB  9
450A:  XORWF  x04,W
450C:  CLRF   03
450E:  MOVLB  0
4510:  CALL   00D0
4514:  MOVFF  903,FEA
4518:  MOVFF  902,FE9
451C:  MOVWF  FEF
....................         } 
451E:  MOVLB  9
4520:  INCF   x01,F
4522:  BRA    44C2
....................         //shift rows 
....................         buf1 = state[1]; 
4524:  MOVLW  01
4526:  MOVLB  8
4528:  ADDWF  xF7,W
452A:  MOVWF  FE9
452C:  MOVLW  00
452E:  ADDWFC xF8,W
4530:  MOVWF  FEA
4532:  MOVFF  FEF,8FC
....................         state[1] = state[5]; 
4536:  MOVLW  01
4538:  ADDWF  xF7,W
453A:  MOVWF  01
453C:  MOVLW  00
453E:  ADDWFC xF8,W
4540:  MOVWF  03
4542:  MOVLW  05
4544:  MOVLB  8
4546:  ADDWF  xF7,W
4548:  MOVWF  FE9
454A:  MOVLW  00
454C:  ADDWFC xF8,W
454E:  MOVWF  FEA
4550:  MOVFF  FEF,904
4554:  MOVLB  9
4556:  MOVFF  03,FEA
455A:  MOVFF  01,FE9
455E:  MOVFF  904,FEF
....................         state[5] = state[9]; 
4562:  MOVLW  05
4564:  MOVLB  8
4566:  ADDWF  xF7,W
4568:  MOVWF  01
456A:  MOVLW  00
456C:  ADDWFC xF8,W
456E:  MOVWF  03
4570:  MOVLW  09
4572:  MOVLB  8
4574:  ADDWF  xF7,W
4576:  MOVWF  FE9
4578:  MOVLW  00
457A:  ADDWFC xF8,W
457C:  MOVWF  FEA
457E:  MOVFF  FEF,904
4582:  MOVLB  9
4584:  MOVFF  03,FEA
4588:  MOVFF  01,FE9
458C:  MOVFF  904,FEF
....................         state[9] = state[13]; 
4590:  MOVLW  09
4592:  MOVLB  8
4594:  ADDWF  xF7,W
4596:  MOVWF  01
4598:  MOVLW  00
459A:  ADDWFC xF8,W
459C:  MOVWF  03
459E:  MOVLW  0D
45A0:  MOVLB  8
45A2:  ADDWF  xF7,W
45A4:  MOVWF  FE9
45A6:  MOVLW  00
45A8:  ADDWFC xF8,W
45AA:  MOVWF  FEA
45AC:  MOVFF  FEF,904
45B0:  MOVLB  9
45B2:  MOVFF  03,FEA
45B6:  MOVFF  01,FE9
45BA:  MOVFF  904,FEF
....................         state[13] = buf1; 
45BE:  MOVLW  0D
45C0:  MOVLB  8
45C2:  ADDWF  xF7,W
45C4:  MOVWF  FE9
45C6:  MOVLW  00
45C8:  ADDWFC xF8,W
45CA:  MOVWF  FEA
45CC:  MOVFF  8FC,FEF
....................      
....................         buf1 = state[2]; 
45D0:  MOVLW  02
45D2:  ADDWF  xF7,W
45D4:  MOVWF  FE9
45D6:  MOVLW  00
45D8:  ADDWFC xF8,W
45DA:  MOVWF  FEA
45DC:  MOVFF  FEF,8FC
....................         buf2 = state[6]; 
45E0:  MOVLW  06
45E2:  ADDWF  xF7,W
45E4:  MOVWF  FE9
45E6:  MOVLW  00
45E8:  ADDWFC xF8,W
45EA:  MOVWF  FEA
45EC:  MOVFF  FEF,8FD
....................         state[2] = state[10]; 
45F0:  MOVLW  02
45F2:  ADDWF  xF7,W
45F4:  MOVWF  01
45F6:  MOVLW  00
45F8:  ADDWFC xF8,W
45FA:  MOVWF  03
45FC:  MOVLW  0A
45FE:  MOVLB  8
4600:  ADDWF  xF7,W
4602:  MOVWF  FE9
4604:  MOVLW  00
4606:  ADDWFC xF8,W
4608:  MOVWF  FEA
460A:  MOVFF  FEF,904
460E:  MOVLB  9
4610:  MOVFF  03,FEA
4614:  MOVFF  01,FE9
4618:  MOVFF  904,FEF
....................         state[6] = state[14]; 
461C:  MOVLW  06
461E:  MOVLB  8
4620:  ADDWF  xF7,W
4622:  MOVWF  01
4624:  MOVLW  00
4626:  ADDWFC xF8,W
4628:  MOVWF  03
462A:  MOVLW  0E
462C:  MOVLB  8
462E:  ADDWF  xF7,W
4630:  MOVWF  FE9
4632:  MOVLW  00
4634:  ADDWFC xF8,W
4636:  MOVWF  FEA
4638:  MOVFF  FEF,904
463C:  MOVLB  9
463E:  MOVFF  03,FEA
4642:  MOVFF  01,FE9
4646:  MOVFF  904,FEF
....................         state[10] = buf1; 
464A:  MOVLW  0A
464C:  MOVLB  8
464E:  ADDWF  xF7,W
4650:  MOVWF  FE9
4652:  MOVLW  00
4654:  ADDWFC xF8,W
4656:  MOVWF  FEA
4658:  MOVFF  8FC,FEF
....................         state[14] = buf2; 
465C:  MOVLW  0E
465E:  ADDWF  xF7,W
4660:  MOVWF  FE9
4662:  MOVLW  00
4664:  ADDWFC xF8,W
4666:  MOVWF  FEA
4668:  MOVFF  8FD,FEF
....................      
....................         buf1 = state[15]; 
466C:  MOVLW  0F
466E:  ADDWF  xF7,W
4670:  MOVWF  FE9
4672:  MOVLW  00
4674:  ADDWFC xF8,W
4676:  MOVWF  FEA
4678:  MOVFF  FEF,8FC
....................         state[15] = state[11]; 
467C:  MOVLW  0F
467E:  ADDWF  xF7,W
4680:  MOVWF  01
4682:  MOVLW  00
4684:  ADDWFC xF8,W
4686:  MOVWF  03
4688:  MOVLW  0B
468A:  MOVLB  8
468C:  ADDWF  xF7,W
468E:  MOVWF  FE9
4690:  MOVLW  00
4692:  ADDWFC xF8,W
4694:  MOVWF  FEA
4696:  MOVFF  FEF,904
469A:  MOVLB  9
469C:  MOVFF  03,FEA
46A0:  MOVFF  01,FE9
46A4:  MOVFF  904,FEF
....................         state[11] = state[7]; 
46A8:  MOVLW  0B
46AA:  MOVLB  8
46AC:  ADDWF  xF7,W
46AE:  MOVWF  01
46B0:  MOVLW  00
46B2:  ADDWFC xF8,W
46B4:  MOVWF  03
46B6:  MOVLW  07
46B8:  MOVLB  8
46BA:  ADDWF  xF7,W
46BC:  MOVWF  FE9
46BE:  MOVLW  00
46C0:  ADDWFC xF8,W
46C2:  MOVWF  FEA
46C4:  MOVFF  FEF,904
46C8:  MOVLB  9
46CA:  MOVFF  03,FEA
46CE:  MOVFF  01,FE9
46D2:  MOVFF  904,FEF
....................         state[7] = state[3]; 
46D6:  MOVLW  07
46D8:  MOVLB  8
46DA:  ADDWF  xF7,W
46DC:  MOVWF  01
46DE:  MOVLW  00
46E0:  ADDWFC xF8,W
46E2:  MOVWF  03
46E4:  MOVLW  03
46E6:  MOVLB  8
46E8:  ADDWF  xF7,W
46EA:  MOVWF  FE9
46EC:  MOVLW  00
46EE:  ADDWFC xF8,W
46F0:  MOVWF  FEA
46F2:  MOVFF  FEF,904
46F6:  MOVLB  9
46F8:  MOVFF  03,FEA
46FC:  MOVFF  01,FE9
4700:  MOVFF  904,FEF
....................         state[3] = buf1; 
4704:  MOVLW  03
4706:  MOVLB  8
4708:  ADDWF  xF7,W
470A:  MOVWF  FE9
470C:  MOVLW  00
470E:  ADDWFC xF8,W
4710:  MOVWF  FEA
4712:  MOVFF  8FC,FEF
4716:  MOVLB  9
....................     } 
....................      
....................     //mixcol - inv mix 
....................     if (((round > 0) && (dir != 0)) || ((round < 9) && (dir == 0)))  
4718:  MOVF   x00,F
471A:  BZ    4724
471C:  MOVLB  8
471E:  MOVF   xFB,F
4720:  BNZ   4738
4722:  MOVLB  9
4724:  MOVF   x00,W
4726:  SUBLW  08
4728:  BTFSS  FD8.0
472A:  BRA    4A7C
472C:  MOVLB  8
472E:  MOVF   xFB,F
4730:  BTFSC  FD8.2
4732:  BRA    4738
4734:  MOVLB  9
4736:  BRA    4A7C
....................     { 
....................           for (i=0; i <4; i++) 
4738:  MOVLB  9
473A:  CLRF   x01
473C:  MOVF   x01,W
473E:  SUBLW  03
4740:  BTFSS  FD8.0
4742:  BRA    4A7C
....................           { 
....................                 buf4 = (unsigned int8)(i << 2); 
4744:  RLCF   x01,W
4746:  MOVLB  8
4748:  MOVWF  xFF
474A:  RLCF   xFF,F
474C:  MOVLW  FC
474E:  ANDWF  xFF,F
....................                 if (dir != 0) 
4750:  MOVF   xFB,F
4752:  BZ    4840
....................                 { 
....................                       // precompute for decryption 
....................                       buf1 = galois_mul2(galois_mul2((unsigned int8)(state[buf4]^state[buf4+2]))); 
4754:  CLRF   03
4756:  MOVF   xFF,W
4758:  ADDWF  xF7,W
475A:  MOVWF  FE9
475C:  MOVF   xF8,W
475E:  ADDWFC 03,W
4760:  MOVWF  FEA
4762:  MOVFF  FEF,902
4766:  MOVLW  02
4768:  ADDWF  xFF,W
476A:  CLRF   03
476C:  ADDWF  xF7,W
476E:  MOVWF  FE9
4770:  MOVF   xF8,W
4772:  ADDWFC 03,W
4774:  MOVWF  FEA
4776:  MOVF   FEF,W
4778:  MOVLB  9
477A:  XORWF  x02,F
477C:  CLRF   x0E
477E:  MOVFF  902,90D
4782:  MOVLB  0
4784:  RCALL  408A
4786:  MOVFF  02,903
478A:  MOVFF  01,902
478E:  MOVFF  02,90E
4792:  MOVFF  01,90D
4796:  RCALL  408A
4798:  MOVFF  01,8FC
....................                       buf2 = galois_mul2(galois_mul2((unsigned int8)(state[buf4+1]^state[buf4+3]))); 
479C:  MOVLW  01
479E:  MOVLB  8
47A0:  ADDWF  xFF,W
47A2:  CLRF   03
47A4:  ADDWF  xF7,W
47A6:  MOVWF  FE9
47A8:  MOVF   xF8,W
47AA:  ADDWFC 03,W
47AC:  MOVWF  FEA
47AE:  MOVFF  FEF,902
47B2:  MOVLW  03
47B4:  ADDWF  xFF,W
47B6:  CLRF   03
47B8:  ADDWF  xF7,W
47BA:  MOVWF  FE9
47BC:  MOVF   xF8,W
47BE:  ADDWFC 03,W
47C0:  MOVWF  FEA
47C2:  MOVF   FEF,W
47C4:  MOVLB  9
47C6:  XORWF  x02,F
47C8:  CLRF   x0E
47CA:  MOVFF  902,90D
47CE:  MOVLB  0
47D0:  RCALL  408A
47D2:  MOVFF  02,903
47D6:  MOVFF  01,902
47DA:  MOVFF  02,90E
47DE:  MOVFF  01,90D
47E2:  RCALL  408A
47E4:  MOVFF  01,8FD
....................                       state[buf4] ^= buf1;  
47E8:  CLRF   03
47EA:  MOVLB  8
47EC:  MOVF   xFF,W
47EE:  ADDWF  xF7,W
47F0:  MOVWF  FE9
47F2:  MOVF   xF8,W
47F4:  ADDWFC 03,W
47F6:  MOVWF  FEA
47F8:  MOVF   FEF,W
47FA:  XORWF  xFC,W
47FC:  MOVWF  FEF
....................                       state[buf4+1] ^= buf2;  
47FE:  MOVLW  01
4800:  ADDWF  xFF,W
4802:  CLRF   03
4804:  ADDWF  xF7,W
4806:  MOVWF  FE9
4808:  MOVF   xF8,W
480A:  ADDWFC 03,W
480C:  MOVWF  FEA
480E:  MOVF   FEF,W
4810:  XORWF  xFD,W
4812:  MOVWF  FEF
....................                       state[buf4+2] ^= buf1;  
4814:  MOVLW  02
4816:  ADDWF  xFF,W
4818:  CLRF   03
481A:  ADDWF  xF7,W
481C:  MOVWF  FE9
481E:  MOVF   xF8,W
4820:  ADDWFC 03,W
4822:  MOVWF  FEA
4824:  MOVF   FEF,W
4826:  XORWF  xFC,W
4828:  MOVWF  FEF
....................                       state[buf4+3] ^= buf2;  
482A:  MOVLW  03
482C:  ADDWF  xFF,W
482E:  CLRF   03
4830:  ADDWF  xF7,W
4832:  MOVWF  FE9
4834:  MOVF   xF8,W
4836:  ADDWFC 03,W
4838:  MOVWF  FEA
483A:  MOVF   FEF,W
483C:  XORWF  xFD,W
483E:  MOVWF  FEF
....................                 } 
....................                 // in all cases 
....................                 buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
4840:  CLRF   03
4842:  MOVF   xFF,W
4844:  ADDWF  xF7,W
4846:  MOVWF  FE9
4848:  MOVF   xF8,W
484A:  ADDWFC 03,W
484C:  MOVWF  FEA
484E:  MOVFF  FEF,902
4852:  MOVLW  01
4854:  ADDWF  xFF,W
4856:  CLRF   03
4858:  ADDWF  xF7,W
485A:  MOVWF  FE9
485C:  MOVF   xF8,W
485E:  ADDWFC 03,W
4860:  MOVWF  FEA
4862:  MOVF   FEF,W
4864:  MOVLB  9
4866:  XORWF  x02,F
4868:  MOVLW  02
486A:  MOVLB  8
486C:  ADDWF  xFF,W
486E:  CLRF   03
4870:  ADDWF  xF7,W
4872:  MOVWF  FE9
4874:  MOVF   xF8,W
4876:  ADDWFC 03,W
4878:  MOVWF  FEA
487A:  MOVF   FEF,W
487C:  MOVLB  9
487E:  XORWF  x02,F
4880:  MOVLW  03
4882:  MOVLB  8
4884:  ADDWF  xFF,W
4886:  CLRF   03
4888:  ADDWF  xF7,W
488A:  MOVWF  FE9
488C:  MOVF   xF8,W
488E:  ADDWFC 03,W
4890:  MOVWF  FEA
4892:  MOVF   FEF,W
4894:  MOVLB  9
4896:  XORWF  x02,W
4898:  MOVLB  8
489A:  MOVWF  xFC
....................                 buf2 = state[buf4]; 
489C:  CLRF   03
489E:  MOVF   xFF,W
48A0:  ADDWF  xF7,W
48A2:  MOVWF  FE9
48A4:  MOVF   xF8,W
48A6:  ADDWFC 03,W
48A8:  MOVWF  FEA
48AA:  MOVFF  FEF,8FD
....................                 buf3 = state[buf4]^state[buf4+1];  
48AE:  CLRF   03
48B0:  MOVF   xFF,W
48B2:  ADDWF  xF7,W
48B4:  MOVWF  FE9
48B6:  MOVF   xF8,W
48B8:  ADDWFC 03,W
48BA:  MOVWF  FEA
48BC:  MOVFF  FEF,902
48C0:  MOVLW  01
48C2:  ADDWF  xFF,W
48C4:  CLRF   03
48C6:  ADDWF  xF7,W
48C8:  MOVWF  FE9
48CA:  MOVF   xF8,W
48CC:  ADDWFC 03,W
48CE:  MOVWF  FEA
48D0:  MOVF   FEF,W
48D2:  MOVLB  9
48D4:  XORWF  x02,W
48D6:  MOVLB  8
48D8:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
48DA:  MOVLB  9
48DC:  CLRF   x0E
48DE:  MOVFF  8FE,90D
48E2:  MOVLB  0
48E4:  CALL   408A
48E8:  MOVFF  01,8FE
....................                 state[buf4] = state[buf4] ^ buf3 ^ buf1; 
48EC:  CLRF   03
48EE:  MOVLB  8
48F0:  MOVF   xFF,W
48F2:  ADDWF  xF7,W
48F4:  MOVWF  01
48F6:  MOVF   xF8,W
48F8:  ADDWFC 03,F
48FA:  MOVLB  9
48FC:  MOVFF  03,903
4900:  CLRF   03
4902:  MOVLB  8
4904:  MOVF   xFF,W
4906:  ADDWF  xF7,W
4908:  MOVWF  FE9
490A:  MOVF   xF8,W
490C:  ADDWFC 03,W
490E:  MOVWF  FEA
4910:  MOVF   FEF,W
4912:  XORWF  xFE,W
4914:  XORWF  xFC,W
4916:  MOVLB  9
4918:  MOVFF  903,FEA
491C:  MOVFF  01,FE9
4920:  MOVWF  FEF
....................                 buf3 = state[buf4+1]^state[buf4+2];  
4922:  MOVLW  01
4924:  MOVLB  8
4926:  ADDWF  xFF,W
4928:  CLRF   03
492A:  ADDWF  xF7,W
492C:  MOVWF  FE9
492E:  MOVF   xF8,W
4930:  ADDWFC 03,W
4932:  MOVWF  FEA
4934:  MOVFF  FEF,902
4938:  MOVLW  02
493A:  ADDWF  xFF,W
493C:  CLRF   03
493E:  ADDWF  xF7,W
4940:  MOVWF  FE9
4942:  MOVF   xF8,W
4944:  ADDWFC 03,W
4946:  MOVWF  FEA
4948:  MOVF   FEF,W
494A:  MOVLB  9
494C:  XORWF  x02,W
494E:  MOVLB  8
4950:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
4952:  MOVLB  9
4954:  CLRF   x0E
4956:  MOVFF  8FE,90D
495A:  MOVLB  0
495C:  CALL   408A
4960:  MOVFF  01,8FE
....................                 state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
4964:  MOVLW  01
4966:  MOVLB  8
4968:  ADDWF  xFF,W
496A:  CLRF   03
496C:  ADDWF  xF7,W
496E:  MOVWF  01
4970:  MOVF   xF8,W
4972:  ADDWFC 03,F
4974:  MOVFF  03,903
4978:  MOVLW  01
497A:  MOVLB  8
497C:  ADDWF  xFF,W
497E:  CLRF   03
4980:  ADDWF  xF7,W
4982:  MOVWF  FE9
4984:  MOVF   xF8,W
4986:  ADDWFC 03,W
4988:  MOVWF  FEA
498A:  MOVF   FEF,W
498C:  XORWF  xFE,W
498E:  XORWF  xFC,W
4990:  MOVLB  9
4992:  MOVFF  903,FEA
4996:  MOVFF  01,FE9
499A:  MOVWF  FEF
....................                 buf3 = state[buf4+2]^state[buf4+3];  
499C:  MOVLW  02
499E:  MOVLB  8
49A0:  ADDWF  xFF,W
49A2:  CLRF   03
49A4:  ADDWF  xF7,W
49A6:  MOVWF  FE9
49A8:  MOVF   xF8,W
49AA:  ADDWFC 03,W
49AC:  MOVWF  FEA
49AE:  MOVFF  FEF,902
49B2:  MOVLW  03
49B4:  ADDWF  xFF,W
49B6:  CLRF   03
49B8:  ADDWF  xF7,W
49BA:  MOVWF  FE9
49BC:  MOVF   xF8,W
49BE:  ADDWFC 03,W
49C0:  MOVWF  FEA
49C2:  MOVF   FEF,W
49C4:  MOVLB  9
49C6:  XORWF  x02,W
49C8:  MOVLB  8
49CA:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
49CC:  MOVLB  9
49CE:  CLRF   x0E
49D0:  MOVFF  8FE,90D
49D4:  MOVLB  0
49D6:  CALL   408A
49DA:  MOVFF  01,8FE
....................                 state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
49DE:  MOVLW  02
49E0:  MOVLB  8
49E2:  ADDWF  xFF,W
49E4:  CLRF   03
49E6:  ADDWF  xF7,W
49E8:  MOVWF  01
49EA:  MOVF   xF8,W
49EC:  ADDWFC 03,F
49EE:  MOVFF  03,903
49F2:  MOVLW  02
49F4:  MOVLB  8
49F6:  ADDWF  xFF,W
49F8:  CLRF   03
49FA:  ADDWF  xF7,W
49FC:  MOVWF  FE9
49FE:  MOVF   xF8,W
4A00:  ADDWFC 03,W
4A02:  MOVWF  FEA
4A04:  MOVF   FEF,W
4A06:  XORWF  xFE,W
4A08:  XORWF  xFC,W
4A0A:  MOVLB  9
4A0C:  MOVFF  903,FEA
4A10:  MOVFF  01,FE9
4A14:  MOVWF  FEF
....................                 buf3 = state[buf4+3]^buf2;      
4A16:  MOVLW  03
4A18:  MOVLB  8
4A1A:  ADDWF  xFF,W
4A1C:  CLRF   03
4A1E:  ADDWF  xF7,W
4A20:  MOVWF  FE9
4A22:  MOVF   xF8,W
4A24:  ADDWFC 03,W
4A26:  MOVWF  FEA
4A28:  MOVF   FEF,W
4A2A:  XORWF  xFD,W
4A2C:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
4A2E:  MOVLB  9
4A30:  CLRF   x0E
4A32:  MOVFF  8FE,90D
4A36:  MOVLB  0
4A38:  CALL   408A
4A3C:  MOVFF  01,8FE
....................                 state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1;  
4A40:  MOVLW  03
4A42:  MOVLB  8
4A44:  ADDWF  xFF,W
4A46:  CLRF   03
4A48:  ADDWF  xF7,W
4A4A:  MOVWF  01
4A4C:  MOVF   xF8,W
4A4E:  ADDWFC 03,F
4A50:  MOVFF  03,903
4A54:  MOVLW  03
4A56:  MOVLB  8
4A58:  ADDWF  xFF,W
4A5A:  CLRF   03
4A5C:  ADDWF  xF7,W
4A5E:  MOVWF  FE9
4A60:  MOVF   xF8,W
4A62:  ADDWFC 03,W
4A64:  MOVWF  FEA
4A66:  MOVF   FEF,W
4A68:  XORWF  xFE,W
4A6A:  XORWF  xFC,W
4A6C:  MOVLB  9
4A6E:  MOVFF  903,FEA
4A72:  MOVFF  01,FE9
4A76:  MOVWF  FEF
....................           } 
4A78:  INCF   x01,F
4A7A:  BRA    473C
....................     } 
....................      
....................     if (dir != 0)  
4A7C:  MOVLB  8
4A7E:  MOVF   xFB,F
4A80:  BTFSC  FD8.2
4A82:  BRA    4CDC
....................     { 
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
4A84:  MOVLW  0D
4A86:  ADDWF  xF7,W
4A88:  MOVWF  FE9
4A8A:  MOVLW  00
4A8C:  ADDWFC xF8,W
4A8E:  MOVWF  FEA
4A90:  MOVFF  FEF,8FC
....................       state[13] = state[9]; 
4A94:  MOVLW  0D
4A96:  ADDWF  xF7,W
4A98:  MOVWF  01
4A9A:  MOVLW  00
4A9C:  ADDWFC xF8,W
4A9E:  MOVWF  03
4AA0:  MOVLW  09
4AA2:  MOVLB  8
4AA4:  ADDWF  xF7,W
4AA6:  MOVWF  FE9
4AA8:  MOVLW  00
4AAA:  ADDWFC xF8,W
4AAC:  MOVWF  FEA
4AAE:  MOVFF  FEF,904
4AB2:  MOVLB  9
4AB4:  MOVFF  03,FEA
4AB8:  MOVFF  01,FE9
4ABC:  MOVFF  904,FEF
....................       state[9] = state[5]; 
4AC0:  MOVLW  09
4AC2:  MOVLB  8
4AC4:  ADDWF  xF7,W
4AC6:  MOVWF  01
4AC8:  MOVLW  00
4ACA:  ADDWFC xF8,W
4ACC:  MOVWF  03
4ACE:  MOVLW  05
4AD0:  MOVLB  8
4AD2:  ADDWF  xF7,W
4AD4:  MOVWF  FE9
4AD6:  MOVLW  00
4AD8:  ADDWFC xF8,W
4ADA:  MOVWF  FEA
4ADC:  MOVFF  FEF,904
4AE0:  MOVLB  9
4AE2:  MOVFF  03,FEA
4AE6:  MOVFF  01,FE9
4AEA:  MOVFF  904,FEF
....................       state[5] = state[1]; 
4AEE:  MOVLW  05
4AF0:  MOVLB  8
4AF2:  ADDWF  xF7,W
4AF4:  MOVWF  01
4AF6:  MOVLW  00
4AF8:  ADDWFC xF8,W
4AFA:  MOVWF  03
4AFC:  MOVLW  01
4AFE:  MOVLB  8
4B00:  ADDWF  xF7,W
4B02:  MOVWF  FE9
4B04:  MOVLW  00
4B06:  ADDWFC xF8,W
4B08:  MOVWF  FEA
4B0A:  MOVFF  FEF,904
4B0E:  MOVLB  9
4B10:  MOVFF  03,FEA
4B14:  MOVFF  01,FE9
4B18:  MOVFF  904,FEF
....................       state[1] = buf1; 
4B1C:  MOVLW  01
4B1E:  MOVLB  8
4B20:  ADDWF  xF7,W
4B22:  MOVWF  FE9
4B24:  MOVLW  00
4B26:  ADDWFC xF8,W
4B28:  MOVWF  FEA
4B2A:  MOVFF  8FC,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
4B2E:  MOVLW  0A
4B30:  ADDWF  xF7,W
4B32:  MOVWF  FE9
4B34:  MOVLW  00
4B36:  ADDWFC xF8,W
4B38:  MOVWF  FEA
4B3A:  MOVFF  FEF,8FC
....................       buf2 = state[14]; 
4B3E:  MOVLW  0E
4B40:  ADDWF  xF7,W
4B42:  MOVWF  FE9
4B44:  MOVLW  00
4B46:  ADDWFC xF8,W
4B48:  MOVWF  FEA
4B4A:  MOVFF  FEF,8FD
....................       state[10] = state[2]; 
4B4E:  MOVLW  0A
4B50:  ADDWF  xF7,W
4B52:  MOVWF  01
4B54:  MOVLW  00
4B56:  ADDWFC xF8,W
4B58:  MOVWF  03
4B5A:  MOVLW  02
4B5C:  MOVLB  8
4B5E:  ADDWF  xF7,W
4B60:  MOVWF  FE9
4B62:  MOVLW  00
4B64:  ADDWFC xF8,W
4B66:  MOVWF  FEA
4B68:  MOVFF  FEF,904
4B6C:  MOVLB  9
4B6E:  MOVFF  03,FEA
4B72:  MOVFF  01,FE9
4B76:  MOVFF  904,FEF
....................       state[14] = state[6]; 
4B7A:  MOVLW  0E
4B7C:  MOVLB  8
4B7E:  ADDWF  xF7,W
4B80:  MOVWF  01
4B82:  MOVLW  00
4B84:  ADDWFC xF8,W
4B86:  MOVWF  03
4B88:  MOVLW  06
4B8A:  MOVLB  8
4B8C:  ADDWF  xF7,W
4B8E:  MOVWF  FE9
4B90:  MOVLW  00
4B92:  ADDWFC xF8,W
4B94:  MOVWF  FEA
4B96:  MOVFF  FEF,904
4B9A:  MOVLB  9
4B9C:  MOVFF  03,FEA
4BA0:  MOVFF  01,FE9
4BA4:  MOVFF  904,FEF
....................       state[2] = buf1; 
4BA8:  MOVLW  02
4BAA:  MOVLB  8
4BAC:  ADDWF  xF7,W
4BAE:  MOVWF  FE9
4BB0:  MOVLW  00
4BB2:  ADDWFC xF8,W
4BB4:  MOVWF  FEA
4BB6:  MOVFF  8FC,FEF
....................       state[6] = buf2; 
4BBA:  MOVLW  06
4BBC:  ADDWF  xF7,W
4BBE:  MOVWF  FE9
4BC0:  MOVLW  00
4BC2:  ADDWFC xF8,W
4BC4:  MOVWF  FEA
4BC6:  MOVFF  8FD,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
4BCA:  MOVLW  03
4BCC:  ADDWF  xF7,W
4BCE:  MOVWF  FE9
4BD0:  MOVLW  00
4BD2:  ADDWFC xF8,W
4BD4:  MOVWF  FEA
4BD6:  MOVFF  FEF,8FC
....................       state[3] = state[7]; 
4BDA:  MOVLW  03
4BDC:  ADDWF  xF7,W
4BDE:  MOVWF  01
4BE0:  MOVLW  00
4BE2:  ADDWFC xF8,W
4BE4:  MOVWF  03
4BE6:  MOVLW  07
4BE8:  MOVLB  8
4BEA:  ADDWF  xF7,W
4BEC:  MOVWF  FE9
4BEE:  MOVLW  00
4BF0:  ADDWFC xF8,W
4BF2:  MOVWF  FEA
4BF4:  MOVFF  FEF,904
4BF8:  MOVLB  9
4BFA:  MOVFF  03,FEA
4BFE:  MOVFF  01,FE9
4C02:  MOVFF  904,FEF
....................       state[7] = state[11]; 
4C06:  MOVLW  07
4C08:  MOVLB  8
4C0A:  ADDWF  xF7,W
4C0C:  MOVWF  01
4C0E:  MOVLW  00
4C10:  ADDWFC xF8,W
4C12:  MOVWF  03
4C14:  MOVLW  0B
4C16:  MOVLB  8
4C18:  ADDWF  xF7,W
4C1A:  MOVWF  FE9
4C1C:  MOVLW  00
4C1E:  ADDWFC xF8,W
4C20:  MOVWF  FEA
4C22:  MOVFF  FEF,904
4C26:  MOVLB  9
4C28:  MOVFF  03,FEA
4C2C:  MOVFF  01,FE9
4C30:  MOVFF  904,FEF
....................       state[11] = state[15]; 
4C34:  MOVLW  0B
4C36:  MOVLB  8
4C38:  ADDWF  xF7,W
4C3A:  MOVWF  01
4C3C:  MOVLW  00
4C3E:  ADDWFC xF8,W
4C40:  MOVWF  03
4C42:  MOVLW  0F
4C44:  MOVLB  8
4C46:  ADDWF  xF7,W
4C48:  MOVWF  FE9
4C4A:  MOVLW  00
4C4C:  ADDWFC xF8,W
4C4E:  MOVWF  FEA
4C50:  MOVFF  FEF,904
4C54:  MOVLB  9
4C56:  MOVFF  03,FEA
4C5A:  MOVFF  01,FE9
4C5E:  MOVFF  904,FEF
....................       state[15] = buf1;          
4C62:  MOVLW  0F
4C64:  MOVLB  8
4C66:  ADDWF  xF7,W
4C68:  MOVWF  FE9
4C6A:  MOVLW  00
4C6C:  ADDWFC xF8,W
4C6E:  MOVWF  FEA
4C70:  MOVFF  8FC,FEF
....................             
....................       for (i = 0; i <16; i++){ 
4C74:  MOVLB  9
4C76:  CLRF   x01
4C78:  MOVF   x01,W
4C7A:  SUBLW  0F
4C7C:  BNC   4CD8
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
4C7E:  CLRF   03
4C80:  MOVF   x01,W
4C82:  MOVLB  8
4C84:  ADDWF  xF7,W
4C86:  MOVWF  01
4C88:  MOVF   xF8,W
4C8A:  ADDWFC 03,F
4C8C:  MOVFF  01,902
4C90:  MOVLB  9
4C92:  MOVFF  03,903
4C96:  CLRF   03
4C98:  MOVF   x01,W
4C9A:  MOVLB  8
4C9C:  ADDWF  xF7,W
4C9E:  MOVWF  FE9
4CA0:  MOVF   xF8,W
4CA2:  ADDWFC 03,W
4CA4:  MOVWF  FEA
4CA6:  CLRF   03
4CA8:  MOVF   FEF,W
4CAA:  MOVLB  0
4CAC:  CALL   01E0
4CB0:  MOVLB  9
4CB2:  MOVWF  x04
4CB4:  CLRF   03
4CB6:  MOVF   x01,W
4CB8:  MOVLB  8
4CBA:  ADDWF  xF9,W
4CBC:  MOVWF  FE9
4CBE:  MOVF   xFA,W
4CC0:  ADDWFC 03,W
4CC2:  MOVWF  FEA
4CC4:  MOVF   FEF,W
4CC6:  MOVLB  9
4CC8:  XORWF  x04,W
4CCA:  MOVFF  903,FEA
4CCE:  MOVFF  902,FE9
4CD2:  MOVWF  FEF
....................       }  
4CD4:  INCF   x01,F
4CD6:  BRA    4C78
....................     }  
....................     else  
4CD8:  BRA    4E7E
4CDA:  MOVLB  8
....................     { 
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
4CDC:  MOVFF  8F9,01
4CE0:  MOVFF  8FA,03
4CE4:  MOVFF  8F9,902
4CE8:  MOVFF  8FA,903
4CEC:  MOVLW  0D
4CEE:  MOVLB  8
4CF0:  ADDWF  xF9,W
4CF2:  MOVWF  FE9
4CF4:  MOVLW  00
4CF6:  ADDWFC xFA,W
4CF8:  MOVWF  FEA
4CFA:  CLRF   03
4CFC:  MOVF   FEF,W
4CFE:  MOVLB  0
4D00:  CALL   00D0
4D04:  MOVLB  9
4D06:  MOVWF  x04
4D08:  MOVLB  8
4D0A:  MOVFF  8F9,FE9
4D0E:  MOVFF  8FA,FEA
4D12:  MOVF   FEF,W
4D14:  MOVLB  9
4D16:  XORWF  x04,F
4D18:  CLRF   03
4D1A:  MOVF   x00,W
4D1C:  MOVLB  0
4D1E:  CALL   02F0
4D22:  MOVWF  01
4D24:  MOVLB  9
4D26:  MOVF   x04,W
4D28:  XORWF  01,W
4D2A:  MOVFF  903,FEA
4D2E:  MOVFF  902,FE9
4D32:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
4D34:  MOVLW  01
4D36:  MOVLB  8
4D38:  ADDWF  xF9,W
4D3A:  MOVWF  01
4D3C:  MOVLW  00
4D3E:  ADDWFC xFA,W
4D40:  MOVWF  03
4D42:  MOVFF  01,902
4D46:  MOVLB  9
4D48:  MOVWF  x03
4D4A:  MOVLW  0E
4D4C:  MOVLB  8
4D4E:  ADDWF  xF9,W
4D50:  MOVWF  FE9
4D52:  MOVLW  00
4D54:  ADDWFC xFA,W
4D56:  MOVWF  FEA
4D58:  CLRF   03
4D5A:  MOVF   FEF,W
4D5C:  MOVLB  0
4D5E:  CALL   00D0
4D62:  MOVLB  9
4D64:  MOVWF  x04
4D66:  MOVLW  01
4D68:  MOVLB  8
4D6A:  ADDWF  xF9,W
4D6C:  MOVWF  FE9
4D6E:  MOVLW  00
4D70:  ADDWFC xFA,W
4D72:  MOVWF  FEA
4D74:  MOVF   FEF,W
4D76:  MOVLB  9
4D78:  XORWF  x04,W
4D7A:  MOVFF  903,FEA
4D7E:  MOVFF  902,FE9
4D82:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
4D84:  MOVLW  02
4D86:  MOVLB  8
4D88:  ADDWF  xF9,W
4D8A:  MOVWF  01
4D8C:  MOVLW  00
4D8E:  ADDWFC xFA,W
4D90:  MOVWF  03
4D92:  MOVFF  01,902
4D96:  MOVLB  9
4D98:  MOVWF  x03
4D9A:  MOVLW  0F
4D9C:  MOVLB  8
4D9E:  ADDWF  xF9,W
4DA0:  MOVWF  FE9
4DA2:  MOVLW  00
4DA4:  ADDWFC xFA,W
4DA6:  MOVWF  FEA
4DA8:  CLRF   03
4DAA:  MOVF   FEF,W
4DAC:  MOVLB  0
4DAE:  CALL   00D0
4DB2:  MOVLB  9
4DB4:  MOVWF  x04
4DB6:  MOVLW  02
4DB8:  MOVLB  8
4DBA:  ADDWF  xF9,W
4DBC:  MOVWF  FE9
4DBE:  MOVLW  00
4DC0:  ADDWFC xFA,W
4DC2:  MOVWF  FEA
4DC4:  MOVF   FEF,W
4DC6:  MOVLB  9
4DC8:  XORWF  x04,W
4DCA:  MOVFF  903,FEA
4DCE:  MOVFF  902,FE9
4DD2:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
4DD4:  MOVLW  03
4DD6:  MOVLB  8
4DD8:  ADDWF  xF9,W
4DDA:  MOVWF  01
4DDC:  MOVLW  00
4DDE:  ADDWFC xFA,W
4DE0:  MOVWF  03
4DE2:  MOVFF  01,902
4DE6:  MOVLB  9
4DE8:  MOVWF  x03
4DEA:  MOVLW  0C
4DEC:  MOVLB  8
4DEE:  ADDWF  xF9,W
4DF0:  MOVWF  FE9
4DF2:  MOVLW  00
4DF4:  ADDWFC xFA,W
4DF6:  MOVWF  FEA
4DF8:  CLRF   03
4DFA:  MOVF   FEF,W
4DFC:  MOVLB  0
4DFE:  CALL   00D0
4E02:  MOVLB  9
4E04:  MOVWF  x04
4E06:  MOVLW  03
4E08:  MOVLB  8
4E0A:  ADDWF  xF9,W
4E0C:  MOVWF  FE9
4E0E:  MOVLW  00
4E10:  ADDWFC xFA,W
4E12:  MOVWF  FEA
4E14:  MOVF   FEF,W
4E16:  MOVLB  9
4E18:  XORWF  x04,W
4E1A:  MOVFF  903,FEA
4E1E:  MOVFF  902,FE9
4E22:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4E24:  MOVLW  04
4E26:  MOVWF  x01
4E28:  MOVF   x01,W
4E2A:  SUBLW  0F
4E2C:  BNC   4E7E
....................         key[i] = key[i] ^ key[i-4]; 
4E2E:  CLRF   03
4E30:  MOVF   x01,W
4E32:  MOVLB  8
4E34:  ADDWF  xF9,W
4E36:  MOVWF  01
4E38:  MOVF   xFA,W
4E3A:  ADDWFC 03,F
4E3C:  MOVLB  9
4E3E:  MOVFF  03,903
4E42:  CLRF   03
4E44:  MOVF   x01,W
4E46:  MOVLB  8
4E48:  ADDWF  xF9,W
4E4A:  MOVWF  FE9
4E4C:  MOVF   xFA,W
4E4E:  ADDWFC 03,W
4E50:  MOVWF  FEA
4E52:  MOVFF  FEF,904
4E56:  MOVLW  04
4E58:  MOVLB  9
4E5A:  SUBWF  x01,W
4E5C:  CLRF   03
4E5E:  MOVLB  8
4E60:  ADDWF  xF9,W
4E62:  MOVWF  FE9
4E64:  MOVF   xFA,W
4E66:  ADDWFC 03,W
4E68:  MOVWF  FEA
4E6A:  MOVF   FEF,W
4E6C:  MOVLB  9
4E6E:  XORWF  x04,W
4E70:  MOVFF  903,FEA
4E74:  MOVFF  01,FE9
4E78:  MOVWF  FEF
....................       } 
4E7A:  INCF   x01,F
4E7C:  BRA    4E28
....................     } 
....................   } 
4E7E:  INCF   x00,F
4E80:  GOTO   4300
....................   if (dir == 0)  
4E84:  MOVLB  8
4E86:  MOVF   xFB,F
4E88:  BNZ   4EE4
....................   { 
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
4E8A:  MOVLB  9
4E8C:  CLRF   x01
4E8E:  MOVF   x01,W
4E90:  SUBLW  0F
4E92:  BNC   4EE2
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
4E94:  CLRF   03
4E96:  MOVF   x01,W
4E98:  MOVLB  8
4E9A:  ADDWF  xF7,W
4E9C:  MOVWF  01
4E9E:  MOVF   xF8,W
4EA0:  ADDWFC 03,F
4EA2:  MOVLB  9
4EA4:  MOVFF  03,903
4EA8:  CLRF   03
4EAA:  MOVF   x01,W
4EAC:  MOVLB  8
4EAE:  ADDWF  xF7,W
4EB0:  MOVWF  FE9
4EB2:  MOVF   xF8,W
4EB4:  ADDWFC 03,W
4EB6:  MOVWF  FEA
4EB8:  MOVFF  FEF,904
4EBC:  CLRF   03
4EBE:  MOVLB  9
4EC0:  MOVF   x01,W
4EC2:  MOVLB  8
4EC4:  ADDWF  xF9,W
4EC6:  MOVWF  FE9
4EC8:  MOVF   xFA,W
4ECA:  ADDWFC 03,W
4ECC:  MOVWF  FEA
4ECE:  MOVF   FEF,W
4ED0:  MOVLB  9
4ED2:  XORWF  x04,W
4ED4:  MOVFF  903,FEA
4ED8:  MOVFF  01,FE9
4EDC:  MOVWF  FEF
....................     } // enf for 
4EDE:  INCF   x01,F
4EE0:  BRA    4E8E
4EE2:  MOVLB  8
....................   } // end if (!dir) 
.................... } // end function 
4EE4:  MOVLB  0
4EE6:  RETURN 0
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                  
....................  
.................... #define     wideofkeystore      16 
.................... #define     key_numbyte         wideofkeystore-4 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 kp_st=0; 
.................... int8 type_KB=0; 
....................  
.................... int8 key_data[wideofkeystore]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1F7C:  MOVLB  1
1F7E:  INCF   x5B,F
1F80:  MOVF   x5B,W
1F82:  SUBLW  01
1F84:  BTFSC  FD8.0
1F86:  BRA    212A
....................        switch (col) { 
1F88:  MOVF   x5E,W
1F8A:  ADDLW  FB
1F8C:  BC    2010
1F8E:  ADDLW  05
1F90:  MOVLB  0
1F92:  GOTO   2134
....................          case 0   :  
....................                     output_low(COL0); 
1F96:  BCF    F92.5
1F98:  BCF    F89.5
....................                     output_high(COL1); 
1F9A:  BCF    F92.3
1F9C:  BSF    F89.3
....................                     output_high(COL2); 
1F9E:  BCF    F92.2
1FA0:  BSF    F89.2
....................                     output_high(COL3); 
1FA2:  BCF    F92.1
1FA4:  BSF    F89.1
....................                     output_high(COL4); 
1FA6:  BCF    F92.0
1FA8:  BSF    F89.0
....................                     break; 
1FAA:  MOVLB  1
1FAC:  BRA    2010
....................          case 1   :  
....................                     output_low(COL1); 
1FAE:  BCF    F92.3
1FB0:  BCF    F89.3
....................                     output_high(COL0); 
1FB2:  BCF    F92.5
1FB4:  BSF    F89.5
....................                     output_high(COL2); 
1FB6:  BCF    F92.2
1FB8:  BSF    F89.2
....................                     output_high(COL3); 
1FBA:  BCF    F92.1
1FBC:  BSF    F89.1
....................                     output_high(COL4); 
1FBE:  BCF    F92.0
1FC0:  BSF    F89.0
....................                     break; 
1FC2:  MOVLB  1
1FC4:  BRA    2010
....................          case 2   :  
....................                     output_low(COL2); 
1FC6:  BCF    F92.2
1FC8:  BCF    F89.2
....................                     output_high(COL1); 
1FCA:  BCF    F92.3
1FCC:  BSF    F89.3
....................                     output_high(COL0); 
1FCE:  BCF    F92.5
1FD0:  BSF    F89.5
....................                     output_high(COL3); 
1FD2:  BCF    F92.1
1FD4:  BSF    F89.1
....................                     output_high(COL4); 
1FD6:  BCF    F92.0
1FD8:  BSF    F89.0
....................                     break; 
1FDA:  MOVLB  1
1FDC:  BRA    2010
....................          case 3   :  
....................                     output_low(COL3); 
1FDE:  BCF    F92.1
1FE0:  BCF    F89.1
....................                     output_high(COL1); 
1FE2:  BCF    F92.3
1FE4:  BSF    F89.3
....................                     output_high(COL2); 
1FE6:  BCF    F92.2
1FE8:  BSF    F89.2
....................                     output_high(COL0); 
1FEA:  BCF    F92.5
1FEC:  BSF    F89.5
....................                     output_high(COL4); 
1FEE:  BCF    F92.0
1FF0:  BSF    F89.0
....................                     break; 
1FF2:  MOVLB  1
1FF4:  BRA    2010
....................          case 4   :  
....................                     output_low(COL4); 
1FF6:  BCF    F92.0
1FF8:  BCF    F89.0
....................                     output_high(COL1); 
1FFA:  BCF    F92.3
1FFC:  BSF    F89.3
....................                     output_high(COL2); 
1FFE:  BCF    F92.2
2000:  BSF    F89.2
....................                     output_high(COL3); 
2002:  BCF    F92.1
2004:  BSF    F89.1
....................                     output_high(COL0); 
2006:  BCF    F92.5
2008:  BSF    F89.5
....................                     break; 
200A:  MOVLB  1
200C:  BRA    2010
200E:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2010:  BTFSS  x5C.0
2012:  BRA    2090
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2014:  BSF    F93.4
2016:  MOVLW  00
2018:  BTFSC  F81.4
201A:  MOVLW  01
201C:  MOVLB  8
201E:  MOVWF  x52
2020:  BSF    F93.5
2022:  MOVLW  00
2024:  BTFSC  F81.5
2026:  MOVLW  01
2028:  ANDWF  x52,F
202A:  BSF    F93.6
202C:  MOVLW  00
202E:  BTFSC  F81.6
2030:  MOVLW  01
2032:  ANDWF  x52,F
2034:  BSF    F93.7
2036:  MOVLW  00
2038:  BTFSC  F81.7
203A:  MOVLW  01
203C:  ANDWF  x52,W
203E:  BZ    208C
....................          { 
....................             kchar=last_key; 
2040:  MOVFF  15D,850
....................             if(keydebug_en==0) 
2044:  MOVLB  1
2046:  MOVF   x44,F
2048:  BNZ   207A
....................             { 
....................                 //count_timer0=0; 
....................                 charac_timeout=0; 
204A:  CLRF   x00
204C:  MOVLB  0
204E:  CLRF   xFF
....................                 if(key_count_ms<wideofkeystore) 
2050:  MOVLB  1
2052:  MOVF   x47,W
2054:  SUBLW  0F
2056:  BNC   2078
....................                 { 
....................                     key_data[key_count_ms++]=kchar; 
2058:  MOVF   x47,W
205A:  INCF   x47,F
205C:  CLRF   03
205E:  ADDLW  4A
2060:  MOVWF  FE9
2062:  MOVLW  01
2064:  ADDWFC 03,W
2066:  MOVWF  FEA
2068:  MOVFF  850,FEF
....................                     fputc(kchar,COM2); 
206C:  MOVFF  850,90C
2070:  MOVLB  0
2072:  CALL   1604
2076:  MOVLB  1
....................                 } 
....................             } 
....................                else fputc(kchar,COM2); 
2078:  BRA    2086
207A:  MOVFF  850,90C
207E:  MOVLB  0
2080:  CALL   1604
2084:  MOVLB  1
....................            kbd_down=FALSE; 
2086:  BCF    x5C.0
....................            last_key=0; 
2088:  CLRF   x5D
208A:  MOVLB  8
....................          } 
....................        } else 
208C:  BRA    2126
208E:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
2090:  BSF    F93.4
2092:  MOVLW  00
2094:  BTFSC  F81.4
2096:  MOVLW  01
2098:  MOVLB  8
209A:  MOVWF  x52
209C:  BSF    F93.5
209E:  MOVLW  00
20A0:  BTFSC  F81.5
20A2:  MOVLW  01
20A4:  ANDWF  x52,F
20A6:  BSF    F93.6
20A8:  MOVLW  00
20AA:  BTFSC  F81.6
20AC:  MOVLW  01
20AE:  ANDWF  x52,F
20B0:  BSF    F93.7
20B2:  MOVLW  00
20B4:  BTFSC  F81.7
20B6:  MOVLW  01
20B8:  ANDWF  x52,W
20BA:  BNZ   211A
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
20BC:  BSF    F93.4
20BE:  BTFSC  F81.4
20C0:  BRA    20C6
....................                   row=0; 
20C2:  CLRF   x51
....................                 else if(input(ROW1)==0) 
20C4:  BRA    20E8
20C6:  BSF    F93.5
20C8:  BTFSC  F81.5
20CA:  BRA    20D2
....................                   row=1; 
20CC:  MOVLW  01
20CE:  MOVWF  x51
....................                 else if(input(ROW2)==0) 
20D0:  BRA    20E8
20D2:  BSF    F93.6
20D4:  BTFSC  F81.6
20D6:  BRA    20DE
....................                   row=2; 
20D8:  MOVLW  02
20DA:  MOVWF  x51
....................                 else if(input(ROW3)==0) 
20DC:  BRA    20E8
20DE:  BSF    F93.7
20E0:  BTFSC  F81.7
20E2:  BRA    20E8
....................                   row=3; 
20E4:  MOVLW  03
20E6:  MOVWF  x51
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
20E8:  MOVF   x51,W
20EA:  MULLW  05
20EC:  MOVF   FF3,W
20EE:  CLRF   x53
20F0:  MOVWF  x52
20F2:  CLRF   03
20F4:  MOVLB  1
20F6:  MOVF   x5E,W
20F8:  MOVLB  8
20FA:  ADDWF  x52,W
20FC:  MOVWF  01
20FE:  MOVF   x53,W
2100:  ADDWFC 03,F
2102:  MOVF   01,W
2104:  MOVLB  0
2106:  CALL   030A
210A:  MOVFF  FE8,15D
....................                 kbd_down = TRUE; 
210E:  MOVLB  1
2110:  BSF    x5C.0
....................                 set_tris_a(0xff); 
2112:  MOVLW  FF
2114:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2116:  BRA    2126
2118:  MOVLB  8
....................                { 
....................                   ++col; 
211A:  MOVLB  1
211C:  INCF   x5E,F
....................                   if(col==5) col=0; 
211E:  MOVF   x5E,W
2120:  SUBLW  05
2122:  BTFSC  FD8.2
2124:  CLRF   x5E
....................                } 
....................          } 
....................       kbd_call_count=0; 
2126:  MOVLB  1
2128:  CLRF   x5B
....................    } 
....................   return(kchar); 
212A:  MOVLB  8
212C:  MOVFF  850,01
.................... } 
2130:  MOVLB  0
2132:  RETURN 0
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2158:  MOVLW  E0
215A:  MOVLB  F
215C:  MOVWF  x48
215E:  BCF    FC2.6
2160:  BCF    FC2.7
2162:  MOVF   x49,W
2164:  ANDLW  E0
2166:  IORLW  17
2168:  MOVWF  x49
....................    switch(col) 
....................    { 
216A:  MOVLB  8
216C:  MOVF   x6D,W
216E:  ADDLW  FA
2170:  BC    223C
2172:  ADDLW  06
2174:  MOVLB  0
2176:  GOTO   2240
....................       case 0: 
....................         set_adc_channel(4); 
217A:  MOVLW  10
217C:  MOVWF  01
217E:  MOVF   FC2,W
2180:  ANDLW  C3
2182:  IORWF  01,W
2184:  MOVWF  FC2
....................         adc=read_adc(); 
2186:  BSF    FC2.1
2188:  BTFSC  FC2.1
218A:  BRA    2188
218C:  MOVFF  FC4,86E
....................         return adc; 
2190:  MOVLB  8
2192:  MOVFF  86E,01
2196:  BRA    223C
....................       break; 
2198:  BRA    223C
....................       case 1: 
....................         set_adc_channel(3); 
219A:  MOVLW  0C
219C:  MOVWF  01
219E:  MOVF   FC2,W
21A0:  ANDLW  C3
21A2:  IORWF  01,W
21A4:  MOVWF  FC2
....................         adc=read_adc(); 
21A6:  BSF    FC2.1
21A8:  BTFSC  FC2.1
21AA:  BRA    21A8
21AC:  MOVFF  FC4,86E
....................         return adc; 
21B0:  MOVLB  8
21B2:  MOVFF  86E,01
21B6:  BRA    223C
....................       break; 
21B8:  BRA    223C
....................       case 2: 
....................         set_adc_channel(2); 
21BA:  MOVLW  08
21BC:  MOVWF  01
21BE:  MOVF   FC2,W
21C0:  ANDLW  C3
21C2:  IORWF  01,W
21C4:  MOVWF  FC2
....................         adc=read_adc(); 
21C6:  BSF    FC2.1
21C8:  BTFSC  FC2.1
21CA:  BRA    21C8
21CC:  MOVFF  FC4,86E
....................         return adc; 
21D0:  MOVLB  8
21D2:  MOVFF  86E,01
21D6:  BRA    223C
....................       break; 
21D8:  BRA    223C
....................       case 3: 
....................         set_adc_channel(1); 
21DA:  MOVLW  04
21DC:  MOVWF  01
21DE:  MOVF   FC2,W
21E0:  ANDLW  C3
21E2:  IORWF  01,W
21E4:  MOVWF  FC2
....................         adc=read_adc(); 
21E6:  BSF    FC2.1
21E8:  BTFSC  FC2.1
21EA:  BRA    21E8
21EC:  MOVFF  FC4,86E
....................         return adc; 
21F0:  MOVLB  8
21F2:  MOVFF  86E,01
21F6:  BRA    223C
....................       break; 
21F8:  BRA    223C
....................       case 4: 
....................         set_adc_channel(0); 
21FA:  MOVLW  00
21FC:  MOVWF  01
21FE:  MOVF   FC2,W
2200:  ANDLW  C3
2202:  IORWF  01,W
2204:  MOVWF  FC2
....................         adc=read_adc(); 
2206:  BSF    FC2.1
2208:  BTFSC  FC2.1
220A:  BRA    2208
220C:  MOVFF  FC4,86E
....................         return adc; 
2210:  MOVLB  8
2212:  MOVFF  86E,01
2216:  BRA    223C
....................       break;      
2218:  BRA    223C
....................       case 5: 
....................         set_adc_channel(11); 
221A:  MOVLW  2C
221C:  MOVWF  01
221E:  MOVF   FC2,W
2220:  ANDLW  C3
2222:  IORWF  01,W
2224:  MOVWF  FC2
....................         adc=read_adc(); 
2226:  BSF    FC2.1
2228:  BTFSC  FC2.1
222A:  BRA    2228
222C:  MOVFF  FC4,86E
....................         return adc; 
2230:  MOVLB  8
2232:  MOVFF  86E,01
2236:  BRA    223C
....................       break;      
2238:  BRA    223C
223A:  MOVLB  8
....................    } 
.................... } 
223C:  MOVLB  0
223E:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
23C0:  MOVLB  8
23C2:  CLRF   x58
23C4:  CLRF   x57
23C6:  CLRF   x56
23C8:  CLRF   x55
23CA:  CLRF   x5C
23CC:  CLRF   x5B
23CE:  CLRF   x5A
23D0:  CLRF   x59
23D2:  CLRF   x60
23D4:  CLRF   x5F
23D6:  CLRF   x5E
23D8:  CLRF   x5D
23DA:  CLRF   x64
23DC:  CLRF   x63
23DE:  CLRF   x62
23E0:  CLRF   x61
23E2:  CLRF   x68
23E4:  CLRF   x67
23E6:  CLRF   x66
23E8:  CLRF   x65
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
23EA:  CLRF   x54
23EC:  CLRF   x53
23EE:  MOVF   x54,W
23F0:  SUBLW  01
23F2:  BNC   2470
23F4:  BNZ   23FC
23F6:  MOVF   x53,W
23F8:  SUBLW  F3
23FA:  BNC   2470
....................    { 
....................       col_0=read_col(0)+col_0; 
23FC:  CLRF   x6D
23FE:  MOVLB  0
2400:  RCALL  2158
2402:  MOVF   01,W
2404:  MOVLB  8
2406:  ADDWF  x55,F
2408:  MOVLW  00
240A:  ADDWFC x56,F
240C:  ADDWFC x57,F
240E:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2410:  MOVLW  01
2412:  MOVWF  x6D
2414:  MOVLB  0
2416:  RCALL  2158
2418:  MOVF   01,W
241A:  MOVLB  8
241C:  ADDWF  x59,F
241E:  MOVLW  00
2420:  ADDWFC x5A,F
2422:  ADDWFC x5B,F
2424:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
2426:  MOVLW  02
2428:  MOVWF  x6D
242A:  MOVLB  0
242C:  RCALL  2158
242E:  MOVF   01,W
2430:  MOVLB  8
2432:  ADDWF  x5D,F
2434:  MOVLW  00
2436:  ADDWFC x5E,F
2438:  ADDWFC x5F,F
243A:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
243C:  MOVLW  03
243E:  MOVWF  x6D
2440:  MOVLB  0
2442:  RCALL  2158
2444:  MOVF   01,W
2446:  MOVLB  8
2448:  ADDWF  x61,F
244A:  MOVLW  00
244C:  ADDWFC x62,F
244E:  ADDWFC x63,F
2450:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
2452:  MOVLW  04
2454:  MOVWF  x6D
2456:  MOVLB  0
2458:  RCALL  2158
245A:  MOVF   01,W
245C:  MOVLB  8
245E:  ADDWF  x65,F
2460:  MOVLW  00
2462:  ADDWFC x66,F
2464:  ADDWFC x67,F
2466:  ADDWFC x68,F
....................    } 
2468:  INCF   x53,F
246A:  BTFSC  FD8.2
246C:  INCF   x54,F
246E:  BRA    23EE
....................    col_0=col_0/500; 
2470:  BCF    FD8.1
2472:  MOVFF  858,90F
2476:  MOVFF  857,90E
247A:  MOVFF  856,90D
247E:  MOVFF  855,90C
2482:  MOVLB  9
2484:  CLRF   x13
2486:  CLRF   x12
2488:  MOVLW  01
248A:  MOVWF  x11
248C:  MOVLW  F4
248E:  MOVWF  x10
2490:  MOVLB  0
2492:  RCALL  2266
2494:  MOVFF  03,858
2498:  MOVFF  02,857
249C:  MOVFF  01,856
24A0:  MOVFF  00,855
....................    col_1=col_1/500; 
24A4:  BCF    FD8.1
24A6:  MOVFF  85C,90F
24AA:  MOVFF  85B,90E
24AE:  MOVFF  85A,90D
24B2:  MOVFF  859,90C
24B6:  MOVLB  9
24B8:  CLRF   x13
24BA:  CLRF   x12
24BC:  MOVLW  01
24BE:  MOVWF  x11
24C0:  MOVLW  F4
24C2:  MOVWF  x10
24C4:  MOVLB  0
24C6:  RCALL  2266
24C8:  MOVFF  03,85C
24CC:  MOVFF  02,85B
24D0:  MOVFF  01,85A
24D4:  MOVFF  00,859
....................    col_2=col_2/500; 
24D8:  BCF    FD8.1
24DA:  MOVFF  860,90F
24DE:  MOVFF  85F,90E
24E2:  MOVFF  85E,90D
24E6:  MOVFF  85D,90C
24EA:  MOVLB  9
24EC:  CLRF   x13
24EE:  CLRF   x12
24F0:  MOVLW  01
24F2:  MOVWF  x11
24F4:  MOVLW  F4
24F6:  MOVWF  x10
24F8:  MOVLB  0
24FA:  RCALL  2266
24FC:  MOVFF  03,860
2500:  MOVFF  02,85F
2504:  MOVFF  01,85E
2508:  MOVFF  00,85D
....................    col_3=col_3/500; 
250C:  BCF    FD8.1
250E:  MOVFF  864,90F
2512:  MOVFF  863,90E
2516:  MOVFF  862,90D
251A:  MOVFF  861,90C
251E:  MOVLB  9
2520:  CLRF   x13
2522:  CLRF   x12
2524:  MOVLW  01
2526:  MOVWF  x11
2528:  MOVLW  F4
252A:  MOVWF  x10
252C:  MOVLB  0
252E:  RCALL  2266
2530:  MOVFF  03,864
2534:  MOVFF  02,863
2538:  MOVFF  01,862
253C:  MOVFF  00,861
....................    col_4=col_4/500; 
2540:  BCF    FD8.1
2542:  MOVFF  868,90F
2546:  MOVFF  867,90E
254A:  MOVFF  866,90D
254E:  MOVFF  865,90C
2552:  MOVLB  9
2554:  CLRF   x13
2556:  CLRF   x12
2558:  MOVLW  01
255A:  MOVWF  x11
255C:  MOVLW  F4
255E:  MOVWF  x10
2560:  MOVLB  0
2562:  RCALL  2266
2564:  MOVFF  03,868
2568:  MOVFF  02,867
256C:  MOVFF  01,866
2570:  MOVFF  00,865
....................    if(keydebug_en) 
2574:  MOVLB  1
2576:  MOVF   x44,F
2578:  BTFSC  FD8.2
257A:  BRA    26F6
....................    { 
....................       fprintf(COM2,"\r\n");      
257C:  MOVLW  0D
257E:  MOVLB  9
2580:  MOVWF  x0C
2582:  MOVLB  0
2584:  CALL   1604
2588:  MOVLW  0A
258A:  MOVLB  9
258C:  MOVWF  x0C
258E:  MOVLB  0
2590:  CALL   1604
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2594:  MOVLW  BC
2596:  MOVWF  FF6
2598:  MOVLW  04
259A:  MOVWF  FF7
259C:  MOVLW  07
259E:  MOVLB  8
25A0:  MOVWF  xF7
25A2:  MOVLB  0
25A4:  CALL   164A
25A8:  MOVLW  41
25AA:  MOVWF  FE9
25AC:  MOVFF  858,8FA
25B0:  MOVFF  857,8F9
25B4:  MOVFF  856,8F8
25B8:  MOVFF  855,8F7
25BC:  RCALL  22FA
25BE:  MOVLW  0D
25C0:  MOVLB  9
25C2:  MOVWF  x0C
25C4:  MOVLB  0
25C6:  CALL   1604
25CA:  MOVLW  0A
25CC:  MOVLB  9
25CE:  MOVWF  x0C
25D0:  MOVLB  0
25D2:  CALL   1604
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
25D6:  MOVLW  CA
25D8:  MOVWF  FF6
25DA:  MOVLW  04
25DC:  MOVWF  FF7
25DE:  MOVLW  07
25E0:  MOVLB  8
25E2:  MOVWF  xF7
25E4:  MOVLB  0
25E6:  CALL   164A
25EA:  MOVLW  41
25EC:  MOVWF  FE9
25EE:  MOVFF  85C,8FA
25F2:  MOVFF  85B,8F9
25F6:  MOVFF  85A,8F8
25FA:  MOVFF  859,8F7
25FE:  RCALL  22FA
2600:  MOVLW  0D
2602:  MOVLB  9
2604:  MOVWF  x0C
2606:  MOVLB  0
2608:  CALL   1604
260C:  MOVLW  0A
260E:  MOVLB  9
2610:  MOVWF  x0C
2612:  MOVLB  0
2614:  CALL   1604
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2618:  MOVLW  D8
261A:  MOVWF  FF6
261C:  MOVLW  04
261E:  MOVWF  FF7
2620:  MOVLW  07
2622:  MOVLB  8
2624:  MOVWF  xF7
2626:  MOVLB  0
2628:  CALL   164A
262C:  MOVLW  41
262E:  MOVWF  FE9
2630:  MOVFF  860,8FA
2634:  MOVFF  85F,8F9
2638:  MOVFF  85E,8F8
263C:  MOVFF  85D,8F7
2640:  RCALL  22FA
2642:  MOVLW  0D
2644:  MOVLB  9
2646:  MOVWF  x0C
2648:  MOVLB  0
264A:  CALL   1604
264E:  MOVLW  0A
2650:  MOVLB  9
2652:  MOVWF  x0C
2654:  MOVLB  0
2656:  CALL   1604
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
265A:  MOVLW  E6
265C:  MOVWF  FF6
265E:  MOVLW  04
2660:  MOVWF  FF7
2662:  MOVLW  07
2664:  MOVLB  8
2666:  MOVWF  xF7
2668:  MOVLB  0
266A:  CALL   164A
266E:  MOVLW  41
2670:  MOVWF  FE9
2672:  MOVFF  864,8FA
2676:  MOVFF  863,8F9
267A:  MOVFF  862,8F8
267E:  MOVFF  861,8F7
2682:  RCALL  22FA
2684:  MOVLW  0D
2686:  MOVLB  9
2688:  MOVWF  x0C
268A:  MOVLB  0
268C:  CALL   1604
2690:  MOVLW  0A
2692:  MOVLB  9
2694:  MOVWF  x0C
2696:  MOVLB  0
2698:  CALL   1604
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
269C:  MOVLW  F4
269E:  MOVWF  FF6
26A0:  MOVLW  04
26A2:  MOVWF  FF7
26A4:  MOVLW  07
26A6:  MOVLB  8
26A8:  MOVWF  xF7
26AA:  MOVLB  0
26AC:  CALL   164A
26B0:  MOVLW  41
26B2:  MOVWF  FE9
26B4:  MOVFF  868,8FA
26B8:  MOVFF  867,8F9
26BC:  MOVFF  866,8F8
26C0:  MOVFF  865,8F7
26C4:  RCALL  22FA
26C6:  MOVLW  0D
26C8:  MOVLB  9
26CA:  MOVWF  x0C
26CC:  MOVLB  0
26CE:  CALL   1604
26D2:  MOVLW  0A
26D4:  MOVLB  9
26D6:  MOVWF  x0C
26D8:  MOVLB  0
26DA:  CALL   1604
....................       fprintf(COM2,"\r\n"); 
26DE:  MOVLW  0D
26E0:  MOVLB  9
26E2:  MOVWF  x0C
26E4:  MOVLB  0
26E6:  CALL   1604
26EA:  MOVLW  0A
26EC:  MOVLB  9
26EE:  MOVWF  x0C
26F0:  MOVLB  0
26F2:  CALL   1604
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
26F6:  MOVLB  8
26F8:  MOVF   x58,F
26FA:  BNZ   270A
26FC:  MOVF   x57,F
26FE:  BNZ   270A
2700:  MOVF   x56,F
2702:  BNZ   270A
2704:  MOVF   x55,W
2706:  SUBLW  05
2708:  BC    276A
270A:  MOVF   x58,F
270C:  BNZ   276A
270E:  MOVF   x57,F
2710:  BNZ   276A
2712:  MOVF   x56,F
2714:  BNZ   276A
2716:  MOVF   x55,W
2718:  SUBLW  3B
271A:  BNC   276A
271C:  MOVF   x5C,F
271E:  BNZ   272E
2720:  MOVF   x5B,F
2722:  BNZ   272E
2724:  MOVF   x5A,F
2726:  BNZ   272E
2728:  MOVF   x59,W
272A:  SUBLW  64
272C:  BC    276A
272E:  MOVF   x60,F
2730:  BNZ   2740
2732:  MOVF   x5F,F
2734:  BNZ   2740
2736:  MOVF   x5E,F
2738:  BNZ   2740
273A:  MOVF   x5D,W
273C:  SUBLW  64
273E:  BC    276A
2740:  MOVF   x64,F
2742:  BNZ   2752
2744:  MOVF   x63,F
2746:  BNZ   2752
2748:  MOVF   x62,F
274A:  BNZ   2752
274C:  MOVF   x61,W
274E:  SUBLW  64
2750:  BC    276A
2752:  MOVF   x68,F
2754:  BNZ   2764
2756:  MOVF   x67,F
2758:  BNZ   2764
275A:  MOVF   x66,F
275C:  BNZ   2764
275E:  MOVF   x65,W
2760:  SUBLW  64
2762:  BC    276A
2764:  MOVLW  00
2766:  MOVWF  01
2768:  BRA    29E8
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
276A:  MOVF   x5C,F
276C:  BNZ   277C
276E:  MOVF   x5B,F
2770:  BNZ   277C
2772:  MOVF   x5A,F
2774:  BNZ   277C
2776:  MOVF   x59,W
2778:  SUBLW  05
277A:  BC    27DC
277C:  MOVF   x5C,F
277E:  BNZ   27DC
2780:  MOVF   x5B,F
2782:  BNZ   27DC
2784:  MOVF   x5A,F
2786:  BNZ   27DC
2788:  MOVF   x59,W
278A:  SUBLW  3B
278C:  BNC   27DC
278E:  MOVF   x58,F
2790:  BNZ   27A0
2792:  MOVF   x57,F
2794:  BNZ   27A0
2796:  MOVF   x56,F
2798:  BNZ   27A0
279A:  MOVF   x55,W
279C:  SUBLW  64
279E:  BC    27DC
27A0:  MOVF   x60,F
27A2:  BNZ   27B2
27A4:  MOVF   x5F,F
27A6:  BNZ   27B2
27A8:  MOVF   x5E,F
27AA:  BNZ   27B2
27AC:  MOVF   x5D,W
27AE:  SUBLW  64
27B0:  BC    27DC
27B2:  MOVF   x64,F
27B4:  BNZ   27C4
27B6:  MOVF   x63,F
27B8:  BNZ   27C4
27BA:  MOVF   x62,F
27BC:  BNZ   27C4
27BE:  MOVF   x61,W
27C0:  SUBLW  64
27C2:  BC    27DC
27C4:  MOVF   x68,F
27C6:  BNZ   27D6
27C8:  MOVF   x67,F
27CA:  BNZ   27D6
27CC:  MOVF   x66,F
27CE:  BNZ   27D6
27D0:  MOVF   x65,W
27D2:  SUBLW  64
27D4:  BC    27DC
27D6:  MOVLW  01
27D8:  MOVWF  01
27DA:  BRA    29E8
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
27DC:  MOVF   x60,F
27DE:  BNZ   27EE
27E0:  MOVF   x5F,F
27E2:  BNZ   27EE
27E4:  MOVF   x5E,F
27E6:  BNZ   27EE
27E8:  MOVF   x5D,W
27EA:  SUBLW  05
27EC:  BC    284E
27EE:  MOVF   x60,F
27F0:  BNZ   284E
27F2:  MOVF   x5F,F
27F4:  BNZ   284E
27F6:  MOVF   x5E,F
27F8:  BNZ   284E
27FA:  MOVF   x5D,W
27FC:  SUBLW  3B
27FE:  BNC   284E
2800:  MOVF   x5C,F
2802:  BNZ   2812
2804:  MOVF   x5B,F
2806:  BNZ   2812
2808:  MOVF   x5A,F
280A:  BNZ   2812
280C:  MOVF   x59,W
280E:  SUBLW  64
2810:  BC    284E
2812:  MOVF   x58,F
2814:  BNZ   2824
2816:  MOVF   x57,F
2818:  BNZ   2824
281A:  MOVF   x56,F
281C:  BNZ   2824
281E:  MOVF   x55,W
2820:  SUBLW  64
2822:  BC    284E
2824:  MOVF   x64,F
2826:  BNZ   2836
2828:  MOVF   x63,F
282A:  BNZ   2836
282C:  MOVF   x62,F
282E:  BNZ   2836
2830:  MOVF   x61,W
2832:  SUBLW  64
2834:  BC    284E
2836:  MOVF   x68,F
2838:  BNZ   2848
283A:  MOVF   x67,F
283C:  BNZ   2848
283E:  MOVF   x66,F
2840:  BNZ   2848
2842:  MOVF   x65,W
2844:  SUBLW  64
2846:  BC    284E
2848:  MOVLW  02
284A:  MOVWF  01
284C:  BRA    29E8
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
284E:  MOVF   x64,F
2850:  BNZ   2860
2852:  MOVF   x63,F
2854:  BNZ   2860
2856:  MOVF   x62,F
2858:  BNZ   2860
285A:  MOVF   x61,W
285C:  SUBLW  05
285E:  BC    28C0
2860:  MOVF   x64,F
2862:  BNZ   28C0
2864:  MOVF   x63,F
2866:  BNZ   28C0
2868:  MOVF   x62,F
286A:  BNZ   28C0
286C:  MOVF   x61,W
286E:  SUBLW  3B
2870:  BNC   28C0
2872:  MOVF   x5C,F
2874:  BNZ   2884
2876:  MOVF   x5B,F
2878:  BNZ   2884
287A:  MOVF   x5A,F
287C:  BNZ   2884
287E:  MOVF   x59,W
2880:  SUBLW  64
2882:  BC    28C0
2884:  MOVF   x60,F
2886:  BNZ   2896
2888:  MOVF   x5F,F
288A:  BNZ   2896
288C:  MOVF   x5E,F
288E:  BNZ   2896
2890:  MOVF   x5D,W
2892:  SUBLW  64
2894:  BC    28C0
2896:  MOVF   x58,F
2898:  BNZ   28A8
289A:  MOVF   x57,F
289C:  BNZ   28A8
289E:  MOVF   x56,F
28A0:  BNZ   28A8
28A2:  MOVF   x55,W
28A4:  SUBLW  64
28A6:  BC    28C0
28A8:  MOVF   x68,F
28AA:  BNZ   28BA
28AC:  MOVF   x67,F
28AE:  BNZ   28BA
28B0:  MOVF   x66,F
28B2:  BNZ   28BA
28B4:  MOVF   x65,W
28B6:  SUBLW  64
28B8:  BC    28C0
28BA:  MOVLW  03
28BC:  MOVWF  01
28BE:  BRA    29E8
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
28C0:  MOVF   x68,F
28C2:  BNZ   28D2
28C4:  MOVF   x67,F
28C6:  BNZ   28D2
28C8:  MOVF   x66,F
28CA:  BNZ   28D2
28CC:  MOVF   x65,W
28CE:  SUBLW  05
28D0:  BC    2932
28D2:  MOVF   x68,F
28D4:  BNZ   2932
28D6:  MOVF   x67,F
28D8:  BNZ   2932
28DA:  MOVF   x66,F
28DC:  BNZ   2932
28DE:  MOVF   x65,W
28E0:  SUBLW  3B
28E2:  BNC   2932
28E4:  MOVF   x5C,F
28E6:  BNZ   28F6
28E8:  MOVF   x5B,F
28EA:  BNZ   28F6
28EC:  MOVF   x5A,F
28EE:  BNZ   28F6
28F0:  MOVF   x59,W
28F2:  SUBLW  64
28F4:  BC    2932
28F6:  MOVF   x60,F
28F8:  BNZ   2908
28FA:  MOVF   x5F,F
28FC:  BNZ   2908
28FE:  MOVF   x5E,F
2900:  BNZ   2908
2902:  MOVF   x5D,W
2904:  SUBLW  64
2906:  BC    2932
2908:  MOVF   x64,F
290A:  BNZ   291A
290C:  MOVF   x63,F
290E:  BNZ   291A
2910:  MOVF   x62,F
2912:  BNZ   291A
2914:  MOVF   x61,W
2916:  SUBLW  64
2918:  BC    2932
291A:  MOVF   x58,F
291C:  BNZ   292C
291E:  MOVF   x57,F
2920:  BNZ   292C
2922:  MOVF   x56,F
2924:  BNZ   292C
2926:  MOVF   x55,W
2928:  SUBLW  64
292A:  BC    2932
292C:  MOVLW  04
292E:  MOVWF  01
2930:  BRA    29E8
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2932:  MOVF   x68,F
2934:  BNZ   2946
2936:  MOVF   x67,F
2938:  BNZ   2946
293A:  MOVF   x66,F
293C:  BNZ   2946
293E:  MOVF   x65,W
2940:  SUBLW  C8
2942:  BTFSC  FD8.0
2944:  BRA    29E4
2946:  MOVF   x58,F
2948:  BTFSS  FD8.2
294A:  BRA    29E4
294C:  MOVF   x57,F
294E:  BTFSS  FD8.2
2950:  BRA    29E4
2952:  MOVF   x56,F
2954:  BTFSS  FD8.2
2956:  BRA    29E4
2958:  MOVF   x55,W
295A:  SUBLW  B3
295C:  BNC   29E4
295E:  MOVF   x58,F
2960:  BNZ   2970
2962:  MOVF   x57,F
2964:  BNZ   2970
2966:  MOVF   x56,F
2968:  BNZ   2970
296A:  MOVF   x55,W
296C:  SUBLW  64
296E:  BC    29E4
2970:  MOVF   x5C,F
2972:  BNZ   29E4
2974:  MOVF   x5B,F
2976:  BNZ   29E4
2978:  MOVF   x5A,F
297A:  BNZ   29E4
297C:  MOVF   x59,W
297E:  SUBLW  B3
2980:  BNC   29E4
2982:  MOVF   x5C,F
2984:  BNZ   2994
2986:  MOVF   x5B,F
2988:  BNZ   2994
298A:  MOVF   x5A,F
298C:  BNZ   2994
298E:  MOVF   x59,W
2990:  SUBLW  64
2992:  BC    29E4
2994:  MOVF   x60,F
2996:  BNZ   29E4
2998:  MOVF   x5F,F
299A:  BNZ   29E4
299C:  MOVF   x5E,F
299E:  BNZ   29E4
29A0:  MOVF   x5D,W
29A2:  SUBLW  B3
29A4:  BNC   29E4
29A6:  MOVF   x60,F
29A8:  BNZ   29B8
29AA:  MOVF   x5F,F
29AC:  BNZ   29B8
29AE:  MOVF   x5E,F
29B0:  BNZ   29B8
29B2:  MOVF   x5D,W
29B4:  SUBLW  64
29B6:  BC    29E4
29B8:  MOVF   x64,F
29BA:  BNZ   29E4
29BC:  MOVF   x63,F
29BE:  BNZ   29E4
29C0:  MOVF   x62,F
29C2:  BNZ   29E4
29C4:  MOVF   x61,W
29C6:  SUBLW  B3
29C8:  BNC   29E4
29CA:  MOVF   x64,F
29CC:  BNZ   29DC
29CE:  MOVF   x63,F
29D0:  BNZ   29DC
29D2:  MOVF   x62,F
29D4:  BNZ   29DC
29D6:  MOVF   x61,W
29D8:  SUBLW  64
29DA:  BC    29E4
29DC:  MOVLW  04
29DE:  MOVWF  01
29E0:  BRA    29E8
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
29E2:  BRA    29E8
29E4:  MOVLW  FF
29E6:  MOVWF  01
.................... } 
29E8:  MOVLB  0
29EA:  GOTO   3236 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
29EE:  MOVLB  8
29F0:  CLRF   x58
29F2:  CLRF   x57
29F4:  CLRF   x56
29F6:  CLRF   x55
29F8:  CLRF   x5C
29FA:  CLRF   x5B
29FC:  CLRF   x5A
29FE:  CLRF   x59
2A00:  CLRF   x60
2A02:  CLRF   x5F
2A04:  CLRF   x5E
2A06:  CLRF   x5D
2A08:  CLRF   x64
2A0A:  CLRF   x63
2A0C:  CLRF   x62
2A0E:  CLRF   x61
2A10:  CLRF   x68
2A12:  CLRF   x67
2A14:  CLRF   x66
2A16:  CLRF   x65
2A18:  CLRF   x6C
2A1A:  CLRF   x6B
2A1C:  CLRF   x6A
2A1E:  CLRF   x69
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2A20:  CLRF   x54
2A22:  CLRF   x53
2A24:  MOVF   x54,W
2A26:  SUBLW  01
2A28:  BNC   2AC8
2A2A:  BNZ   2A32
2A2C:  MOVF   x53,W
2A2E:  SUBLW  F3
2A30:  BNC   2AC8
....................    { 
....................       col_0=read_col(0)+col_0; 
2A32:  CLRF   x6D
2A34:  MOVLB  0
2A36:  CALL   2158
2A3A:  MOVF   01,W
2A3C:  MOVLB  8
2A3E:  ADDWF  x55,F
2A40:  MOVLW  00
2A42:  ADDWFC x56,F
2A44:  ADDWFC x57,F
2A46:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2A48:  MOVLW  01
2A4A:  MOVWF  x6D
2A4C:  MOVLB  0
2A4E:  CALL   2158
2A52:  MOVF   01,W
2A54:  MOVLB  8
2A56:  ADDWF  x59,F
2A58:  MOVLW  00
2A5A:  ADDWFC x5A,F
2A5C:  ADDWFC x5B,F
2A5E:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
2A60:  MOVLW  02
2A62:  MOVWF  x6D
2A64:  MOVLB  0
2A66:  CALL   2158
2A6A:  MOVF   01,W
2A6C:  MOVLB  8
2A6E:  ADDWF  x5D,F
2A70:  MOVLW  00
2A72:  ADDWFC x5E,F
2A74:  ADDWFC x5F,F
2A76:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
2A78:  MOVLW  03
2A7A:  MOVWF  x6D
2A7C:  MOVLB  0
2A7E:  CALL   2158
2A82:  MOVF   01,W
2A84:  MOVLB  8
2A86:  ADDWF  x61,F
2A88:  MOVLW  00
2A8A:  ADDWFC x62,F
2A8C:  ADDWFC x63,F
2A8E:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
2A90:  MOVLW  04
2A92:  MOVWF  x6D
2A94:  MOVLB  0
2A96:  CALL   2158
2A9A:  MOVF   01,W
2A9C:  MOVLB  8
2A9E:  ADDWF  x65,F
2AA0:  MOVLW  00
2AA2:  ADDWFC x66,F
2AA4:  ADDWFC x67,F
2AA6:  ADDWFC x68,F
....................       col_5=read_col(5)+col_5; 
2AA8:  MOVLW  05
2AAA:  MOVWF  x6D
2AAC:  MOVLB  0
2AAE:  CALL   2158
2AB2:  MOVF   01,W
2AB4:  MOVLB  8
2AB6:  ADDWF  x69,F
2AB8:  MOVLW  00
2ABA:  ADDWFC x6A,F
2ABC:  ADDWFC x6B,F
2ABE:  ADDWFC x6C,F
....................    } 
2AC0:  INCF   x53,F
2AC2:  BTFSC  FD8.2
2AC4:  INCF   x54,F
2AC6:  BRA    2A24
....................    col_0=col_0/500; 
2AC8:  BCF    FD8.1
2ACA:  MOVFF  858,90F
2ACE:  MOVFF  857,90E
2AD2:  MOVFF  856,90D
2AD6:  MOVFF  855,90C
2ADA:  MOVLB  9
2ADC:  CLRF   x13
2ADE:  CLRF   x12
2AE0:  MOVLW  01
2AE2:  MOVWF  x11
2AE4:  MOVLW  F4
2AE6:  MOVWF  x10
2AE8:  MOVLB  0
2AEA:  CALL   2266
2AEE:  MOVFF  03,858
2AF2:  MOVFF  02,857
2AF6:  MOVFF  01,856
2AFA:  MOVFF  00,855
....................    col_1=col_1/500; 
2AFE:  BCF    FD8.1
2B00:  MOVFF  85C,90F
2B04:  MOVFF  85B,90E
2B08:  MOVFF  85A,90D
2B0C:  MOVFF  859,90C
2B10:  MOVLB  9
2B12:  CLRF   x13
2B14:  CLRF   x12
2B16:  MOVLW  01
2B18:  MOVWF  x11
2B1A:  MOVLW  F4
2B1C:  MOVWF  x10
2B1E:  MOVLB  0
2B20:  CALL   2266
2B24:  MOVFF  03,85C
2B28:  MOVFF  02,85B
2B2C:  MOVFF  01,85A
2B30:  MOVFF  00,859
....................    col_2=col_2/500; 
2B34:  BCF    FD8.1
2B36:  MOVFF  860,90F
2B3A:  MOVFF  85F,90E
2B3E:  MOVFF  85E,90D
2B42:  MOVFF  85D,90C
2B46:  MOVLB  9
2B48:  CLRF   x13
2B4A:  CLRF   x12
2B4C:  MOVLW  01
2B4E:  MOVWF  x11
2B50:  MOVLW  F4
2B52:  MOVWF  x10
2B54:  MOVLB  0
2B56:  CALL   2266
2B5A:  MOVFF  03,860
2B5E:  MOVFF  02,85F
2B62:  MOVFF  01,85E
2B66:  MOVFF  00,85D
....................    col_3=col_3/500; 
2B6A:  BCF    FD8.1
2B6C:  MOVFF  864,90F
2B70:  MOVFF  863,90E
2B74:  MOVFF  862,90D
2B78:  MOVFF  861,90C
2B7C:  MOVLB  9
2B7E:  CLRF   x13
2B80:  CLRF   x12
2B82:  MOVLW  01
2B84:  MOVWF  x11
2B86:  MOVLW  F4
2B88:  MOVWF  x10
2B8A:  MOVLB  0
2B8C:  CALL   2266
2B90:  MOVFF  03,864
2B94:  MOVFF  02,863
2B98:  MOVFF  01,862
2B9C:  MOVFF  00,861
....................    col_4=col_4/500; 
2BA0:  BCF    FD8.1
2BA2:  MOVFF  868,90F
2BA6:  MOVFF  867,90E
2BAA:  MOVFF  866,90D
2BAE:  MOVFF  865,90C
2BB2:  MOVLB  9
2BB4:  CLRF   x13
2BB6:  CLRF   x12
2BB8:  MOVLW  01
2BBA:  MOVWF  x11
2BBC:  MOVLW  F4
2BBE:  MOVWF  x10
2BC0:  MOVLB  0
2BC2:  CALL   2266
2BC6:  MOVFF  03,868
2BCA:  MOVFF  02,867
2BCE:  MOVFF  01,866
2BD2:  MOVFF  00,865
....................    col_5=col_5/500; 
2BD6:  BCF    FD8.1
2BD8:  MOVFF  86C,90F
2BDC:  MOVFF  86B,90E
2BE0:  MOVFF  86A,90D
2BE4:  MOVFF  869,90C
2BE8:  MOVLB  9
2BEA:  CLRF   x13
2BEC:  CLRF   x12
2BEE:  MOVLW  01
2BF0:  MOVWF  x11
2BF2:  MOVLW  F4
2BF4:  MOVWF  x10
2BF6:  MOVLB  0
2BF8:  CALL   2266
2BFC:  MOVFF  03,86C
2C00:  MOVFF  02,86B
2C04:  MOVFF  01,86A
2C08:  MOVFF  00,869
....................    if(keydebug_en) 
2C0C:  MOVLB  1
2C0E:  MOVF   x44,F
2C10:  BTFSC  FD8.2
2C12:  BRA    2DDC
....................    { 
....................       fprintf(COM2,"\r\n");      
2C14:  MOVLW  0D
2C16:  MOVLB  9
2C18:  MOVWF  x0C
2C1A:  MOVLB  0
2C1C:  CALL   1604
2C20:  MOVLW  0A
2C22:  MOVLB  9
2C24:  MOVWF  x0C
2C26:  MOVLB  0
2C28:  CALL   1604
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2C2C:  MOVLW  02
2C2E:  MOVWF  FF6
2C30:  MOVLW  05
2C32:  MOVWF  FF7
2C34:  MOVLW  07
2C36:  MOVLB  8
2C38:  MOVWF  xF7
2C3A:  MOVLB  0
2C3C:  CALL   164A
2C40:  MOVLW  41
2C42:  MOVWF  FE9
2C44:  MOVFF  858,8FA
2C48:  MOVFF  857,8F9
2C4C:  MOVFF  856,8F8
2C50:  MOVFF  855,8F7
2C54:  CALL   22FA
2C58:  MOVLW  0D
2C5A:  MOVLB  9
2C5C:  MOVWF  x0C
2C5E:  MOVLB  0
2C60:  CALL   1604
2C64:  MOVLW  0A
2C66:  MOVLB  9
2C68:  MOVWF  x0C
2C6A:  MOVLB  0
2C6C:  CALL   1604
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2C70:  MOVLW  10
2C72:  MOVWF  FF6
2C74:  MOVLW  05
2C76:  MOVWF  FF7
2C78:  MOVLW  07
2C7A:  MOVLB  8
2C7C:  MOVWF  xF7
2C7E:  MOVLB  0
2C80:  CALL   164A
2C84:  MOVLW  41
2C86:  MOVWF  FE9
2C88:  MOVFF  85C,8FA
2C8C:  MOVFF  85B,8F9
2C90:  MOVFF  85A,8F8
2C94:  MOVFF  859,8F7
2C98:  CALL   22FA
2C9C:  MOVLW  0D
2C9E:  MOVLB  9
2CA0:  MOVWF  x0C
2CA2:  MOVLB  0
2CA4:  CALL   1604
2CA8:  MOVLW  0A
2CAA:  MOVLB  9
2CAC:  MOVWF  x0C
2CAE:  MOVLB  0
2CB0:  CALL   1604
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2CB4:  MOVLW  1E
2CB6:  MOVWF  FF6
2CB8:  MOVLW  05
2CBA:  MOVWF  FF7
2CBC:  MOVLW  07
2CBE:  MOVLB  8
2CC0:  MOVWF  xF7
2CC2:  MOVLB  0
2CC4:  CALL   164A
2CC8:  MOVLW  41
2CCA:  MOVWF  FE9
2CCC:  MOVFF  860,8FA
2CD0:  MOVFF  85F,8F9
2CD4:  MOVFF  85E,8F8
2CD8:  MOVFF  85D,8F7
2CDC:  CALL   22FA
2CE0:  MOVLW  0D
2CE2:  MOVLB  9
2CE4:  MOVWF  x0C
2CE6:  MOVLB  0
2CE8:  CALL   1604
2CEC:  MOVLW  0A
2CEE:  MOVLB  9
2CF0:  MOVWF  x0C
2CF2:  MOVLB  0
2CF4:  CALL   1604
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2CF8:  MOVLW  2C
2CFA:  MOVWF  FF6
2CFC:  MOVLW  05
2CFE:  MOVWF  FF7
2D00:  MOVLW  07
2D02:  MOVLB  8
2D04:  MOVWF  xF7
2D06:  MOVLB  0
2D08:  CALL   164A
2D0C:  MOVLW  41
2D0E:  MOVWF  FE9
2D10:  MOVFF  864,8FA
2D14:  MOVFF  863,8F9
2D18:  MOVFF  862,8F8
2D1C:  MOVFF  861,8F7
2D20:  CALL   22FA
2D24:  MOVLW  0D
2D26:  MOVLB  9
2D28:  MOVWF  x0C
2D2A:  MOVLB  0
2D2C:  CALL   1604
2D30:  MOVLW  0A
2D32:  MOVLB  9
2D34:  MOVWF  x0C
2D36:  MOVLB  0
2D38:  CALL   1604
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2D3C:  MOVLW  3A
2D3E:  MOVWF  FF6
2D40:  MOVLW  05
2D42:  MOVWF  FF7
2D44:  MOVLW  07
2D46:  MOVLB  8
2D48:  MOVWF  xF7
2D4A:  MOVLB  0
2D4C:  CALL   164A
2D50:  MOVLW  41
2D52:  MOVWF  FE9
2D54:  MOVFF  868,8FA
2D58:  MOVFF  867,8F9
2D5C:  MOVFF  866,8F8
2D60:  MOVFF  865,8F7
2D64:  CALL   22FA
2D68:  MOVLW  0D
2D6A:  MOVLB  9
2D6C:  MOVWF  x0C
2D6E:  MOVLB  0
2D70:  CALL   1604
2D74:  MOVLW  0A
2D76:  MOVLB  9
2D78:  MOVWF  x0C
2D7A:  MOVLB  0
2D7C:  CALL   1604
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2D80:  MOVLW  48
2D82:  MOVWF  FF6
2D84:  MOVLW  05
2D86:  MOVWF  FF7
2D88:  MOVLW  07
2D8A:  MOVLB  8
2D8C:  MOVWF  xF7
2D8E:  MOVLB  0
2D90:  CALL   164A
2D94:  MOVLW  41
2D96:  MOVWF  FE9
2D98:  MOVFF  86C,8FA
2D9C:  MOVFF  86B,8F9
2DA0:  MOVFF  86A,8F8
2DA4:  MOVFF  869,8F7
2DA8:  CALL   22FA
2DAC:  MOVLW  0D
2DAE:  MOVLB  9
2DB0:  MOVWF  x0C
2DB2:  MOVLB  0
2DB4:  CALL   1604
2DB8:  MOVLW  0A
2DBA:  MOVLB  9
2DBC:  MOVWF  x0C
2DBE:  MOVLB  0
2DC0:  CALL   1604
....................       fprintf(COM2,"\r\n"); 
2DC4:  MOVLW  0D
2DC6:  MOVLB  9
2DC8:  MOVWF  x0C
2DCA:  MOVLB  0
2DCC:  CALL   1604
2DD0:  MOVLW  0A
2DD2:  MOVLB  9
2DD4:  MOVWF  x0C
2DD6:  MOVLB  0
2DD8:  CALL   1604
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2DDC:  MOVLB  8
2DDE:  MOVF   x58,F
2DE0:  BNZ   2DF0
2DE2:  MOVF   x57,F
2DE4:  BNZ   2DF0
2DE6:  MOVF   x56,F
2DE8:  BNZ   2DF0
2DEA:  MOVF   x55,W
2DEC:  SUBLW  05
2DEE:  BC    2E62
2DF0:  MOVF   x58,F
2DF2:  BNZ   2E62
2DF4:  MOVF   x57,F
2DF6:  BNZ   2E62
2DF8:  MOVF   x56,F
2DFA:  BNZ   2E62
2DFC:  MOVF   x55,W
2DFE:  SUBLW  3B
2E00:  BNC   2E62
2E02:  MOVF   x5C,F
2E04:  BNZ   2E14
2E06:  MOVF   x5B,F
2E08:  BNZ   2E14
2E0A:  MOVF   x5A,F
2E0C:  BNZ   2E14
2E0E:  MOVF   x59,W
2E10:  SUBLW  64
2E12:  BC    2E62
2E14:  MOVF   x60,F
2E16:  BNZ   2E26
2E18:  MOVF   x5F,F
2E1A:  BNZ   2E26
2E1C:  MOVF   x5E,F
2E1E:  BNZ   2E26
2E20:  MOVF   x5D,W
2E22:  SUBLW  64
2E24:  BC    2E62
2E26:  MOVF   x64,F
2E28:  BNZ   2E38
2E2A:  MOVF   x63,F
2E2C:  BNZ   2E38
2E2E:  MOVF   x62,F
2E30:  BNZ   2E38
2E32:  MOVF   x61,W
2E34:  SUBLW  64
2E36:  BC    2E62
2E38:  MOVF   x68,F
2E3A:  BNZ   2E4A
2E3C:  MOVF   x67,F
2E3E:  BNZ   2E4A
2E40:  MOVF   x66,F
2E42:  BNZ   2E4A
2E44:  MOVF   x65,W
2E46:  SUBLW  64
2E48:  BC    2E62
2E4A:  MOVF   x6C,F
2E4C:  BNZ   2E5C
2E4E:  MOVF   x6B,F
2E50:  BNZ   2E5C
2E52:  MOVF   x6A,F
2E54:  BNZ   2E5C
2E56:  MOVF   x69,W
2E58:  SUBLW  64
2E5A:  BC    2E62
2E5C:  MOVLW  00
2E5E:  MOVWF  01
2E60:  BRA    31DA
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2E62:  MOVF   x5C,F
2E64:  BNZ   2E74
2E66:  MOVF   x5B,F
2E68:  BNZ   2E74
2E6A:  MOVF   x5A,F
2E6C:  BNZ   2E74
2E6E:  MOVF   x59,W
2E70:  SUBLW  05
2E72:  BC    2EE6
2E74:  MOVF   x5C,F
2E76:  BNZ   2EE6
2E78:  MOVF   x5B,F
2E7A:  BNZ   2EE6
2E7C:  MOVF   x5A,F
2E7E:  BNZ   2EE6
2E80:  MOVF   x59,W
2E82:  SUBLW  3B
2E84:  BNC   2EE6
2E86:  MOVF   x58,F
2E88:  BNZ   2E98
2E8A:  MOVF   x57,F
2E8C:  BNZ   2E98
2E8E:  MOVF   x56,F
2E90:  BNZ   2E98
2E92:  MOVF   x55,W
2E94:  SUBLW  64
2E96:  BC    2EE6
2E98:  MOVF   x60,F
2E9A:  BNZ   2EAA
2E9C:  MOVF   x5F,F
2E9E:  BNZ   2EAA
2EA0:  MOVF   x5E,F
2EA2:  BNZ   2EAA
2EA4:  MOVF   x5D,W
2EA6:  SUBLW  64
2EA8:  BC    2EE6
2EAA:  MOVF   x64,F
2EAC:  BNZ   2EBC
2EAE:  MOVF   x63,F
2EB0:  BNZ   2EBC
2EB2:  MOVF   x62,F
2EB4:  BNZ   2EBC
2EB6:  MOVF   x61,W
2EB8:  SUBLW  64
2EBA:  BC    2EE6
2EBC:  MOVF   x68,F
2EBE:  BNZ   2ECE
2EC0:  MOVF   x67,F
2EC2:  BNZ   2ECE
2EC4:  MOVF   x66,F
2EC6:  BNZ   2ECE
2EC8:  MOVF   x65,W
2ECA:  SUBLW  64
2ECC:  BC    2EE6
2ECE:  MOVF   x6C,F
2ED0:  BNZ   2EE0
2ED2:  MOVF   x6B,F
2ED4:  BNZ   2EE0
2ED6:  MOVF   x6A,F
2ED8:  BNZ   2EE0
2EDA:  MOVF   x69,W
2EDC:  SUBLW  64
2EDE:  BC    2EE6
2EE0:  MOVLW  01
2EE2:  MOVWF  01
2EE4:  BRA    31DA
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2EE6:  MOVF   x60,F
2EE8:  BNZ   2EF8
2EEA:  MOVF   x5F,F
2EEC:  BNZ   2EF8
2EEE:  MOVF   x5E,F
2EF0:  BNZ   2EF8
2EF2:  MOVF   x5D,W
2EF4:  SUBLW  05
2EF6:  BC    2F6A
2EF8:  MOVF   x60,F
2EFA:  BNZ   2F6A
2EFC:  MOVF   x5F,F
2EFE:  BNZ   2F6A
2F00:  MOVF   x5E,F
2F02:  BNZ   2F6A
2F04:  MOVF   x5D,W
2F06:  SUBLW  3B
2F08:  BNC   2F6A
2F0A:  MOVF   x5C,F
2F0C:  BNZ   2F1C
2F0E:  MOVF   x5B,F
2F10:  BNZ   2F1C
2F12:  MOVF   x5A,F
2F14:  BNZ   2F1C
2F16:  MOVF   x59,W
2F18:  SUBLW  64
2F1A:  BC    2F6A
2F1C:  MOVF   x58,F
2F1E:  BNZ   2F2E
2F20:  MOVF   x57,F
2F22:  BNZ   2F2E
2F24:  MOVF   x56,F
2F26:  BNZ   2F2E
2F28:  MOVF   x55,W
2F2A:  SUBLW  64
2F2C:  BC    2F6A
2F2E:  MOVF   x64,F
2F30:  BNZ   2F40
2F32:  MOVF   x63,F
2F34:  BNZ   2F40
2F36:  MOVF   x62,F
2F38:  BNZ   2F40
2F3A:  MOVF   x61,W
2F3C:  SUBLW  64
2F3E:  BC    2F6A
2F40:  MOVF   x68,F
2F42:  BNZ   2F52
2F44:  MOVF   x67,F
2F46:  BNZ   2F52
2F48:  MOVF   x66,F
2F4A:  BNZ   2F52
2F4C:  MOVF   x65,W
2F4E:  SUBLW  64
2F50:  BC    2F6A
2F52:  MOVF   x6C,F
2F54:  BNZ   2F64
2F56:  MOVF   x6B,F
2F58:  BNZ   2F64
2F5A:  MOVF   x6A,F
2F5C:  BNZ   2F64
2F5E:  MOVF   x69,W
2F60:  SUBLW  64
2F62:  BC    2F6A
2F64:  MOVLW  02
2F66:  MOVWF  01
2F68:  BRA    31DA
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2F6A:  MOVF   x64,F
2F6C:  BNZ   2F7C
2F6E:  MOVF   x63,F
2F70:  BNZ   2F7C
2F72:  MOVF   x62,F
2F74:  BNZ   2F7C
2F76:  MOVF   x61,W
2F78:  SUBLW  05
2F7A:  BC    2FEE
2F7C:  MOVF   x64,F
2F7E:  BNZ   2FEE
2F80:  MOVF   x63,F
2F82:  BNZ   2FEE
2F84:  MOVF   x62,F
2F86:  BNZ   2FEE
2F88:  MOVF   x61,W
2F8A:  SUBLW  3B
2F8C:  BNC   2FEE
2F8E:  MOVF   x5C,F
2F90:  BNZ   2FA0
2F92:  MOVF   x5B,F
2F94:  BNZ   2FA0
2F96:  MOVF   x5A,F
2F98:  BNZ   2FA0
2F9A:  MOVF   x59,W
2F9C:  SUBLW  64
2F9E:  BC    2FEE
2FA0:  MOVF   x60,F
2FA2:  BNZ   2FB2
2FA4:  MOVF   x5F,F
2FA6:  BNZ   2FB2
2FA8:  MOVF   x5E,F
2FAA:  BNZ   2FB2
2FAC:  MOVF   x5D,W
2FAE:  SUBLW  64
2FB0:  BC    2FEE
2FB2:  MOVF   x58,F
2FB4:  BNZ   2FC4
2FB6:  MOVF   x57,F
2FB8:  BNZ   2FC4
2FBA:  MOVF   x56,F
2FBC:  BNZ   2FC4
2FBE:  MOVF   x55,W
2FC0:  SUBLW  64
2FC2:  BC    2FEE
2FC4:  MOVF   x68,F
2FC6:  BNZ   2FD6
2FC8:  MOVF   x67,F
2FCA:  BNZ   2FD6
2FCC:  MOVF   x66,F
2FCE:  BNZ   2FD6
2FD0:  MOVF   x65,W
2FD2:  SUBLW  64
2FD4:  BC    2FEE
2FD6:  MOVF   x6C,F
2FD8:  BNZ   2FE8
2FDA:  MOVF   x6B,F
2FDC:  BNZ   2FE8
2FDE:  MOVF   x6A,F
2FE0:  BNZ   2FE8
2FE2:  MOVF   x69,W
2FE4:  SUBLW  64
2FE6:  BC    2FEE
2FE8:  MOVLW  03
2FEA:  MOVWF  01
2FEC:  BRA    31DA
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
2FEE:  MOVF   x68,F
2FF0:  BNZ   3000
2FF2:  MOVF   x67,F
2FF4:  BNZ   3000
2FF6:  MOVF   x66,F
2FF8:  BNZ   3000
2FFA:  MOVF   x65,W
2FFC:  SUBLW  05
2FFE:  BC    3072
3000:  MOVF   x68,F
3002:  BNZ   3072
3004:  MOVF   x67,F
3006:  BNZ   3072
3008:  MOVF   x66,F
300A:  BNZ   3072
300C:  MOVF   x65,W
300E:  SUBLW  3B
3010:  BNC   3072
3012:  MOVF   x5C,F
3014:  BNZ   3024
3016:  MOVF   x5B,F
3018:  BNZ   3024
301A:  MOVF   x5A,F
301C:  BNZ   3024
301E:  MOVF   x59,W
3020:  SUBLW  64
3022:  BC    3072
3024:  MOVF   x60,F
3026:  BNZ   3036
3028:  MOVF   x5F,F
302A:  BNZ   3036
302C:  MOVF   x5E,F
302E:  BNZ   3036
3030:  MOVF   x5D,W
3032:  SUBLW  64
3034:  BC    3072
3036:  MOVF   x64,F
3038:  BNZ   3048
303A:  MOVF   x63,F
303C:  BNZ   3048
303E:  MOVF   x62,F
3040:  BNZ   3048
3042:  MOVF   x61,W
3044:  SUBLW  64
3046:  BC    3072
3048:  MOVF   x58,F
304A:  BNZ   305A
304C:  MOVF   x57,F
304E:  BNZ   305A
3050:  MOVF   x56,F
3052:  BNZ   305A
3054:  MOVF   x55,W
3056:  SUBLW  64
3058:  BC    3072
305A:  MOVF   x6C,F
305C:  BNZ   306C
305E:  MOVF   x6B,F
3060:  BNZ   306C
3062:  MOVF   x6A,F
3064:  BNZ   306C
3066:  MOVF   x69,W
3068:  SUBLW  64
306A:  BC    3072
306C:  MOVLW  04
306E:  MOVWF  01
3070:  BRA    31DA
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
3072:  MOVF   x6C,F
3074:  BNZ   3084
3076:  MOVF   x6B,F
3078:  BNZ   3084
307A:  MOVF   x6A,F
307C:  BNZ   3084
307E:  MOVF   x69,W
3080:  SUBLW  05
3082:  BC    30F6
3084:  MOVF   x6C,F
3086:  BNZ   30F6
3088:  MOVF   x6B,F
308A:  BNZ   30F6
308C:  MOVF   x6A,F
308E:  BNZ   30F6
3090:  MOVF   x69,W
3092:  SUBLW  3B
3094:  BNC   30F6
3096:  MOVF   x5C,F
3098:  BNZ   30A8
309A:  MOVF   x5B,F
309C:  BNZ   30A8
309E:  MOVF   x5A,F
30A0:  BNZ   30A8
30A2:  MOVF   x59,W
30A4:  SUBLW  64
30A6:  BC    30F6
30A8:  MOVF   x60,F
30AA:  BNZ   30BA
30AC:  MOVF   x5F,F
30AE:  BNZ   30BA
30B0:  MOVF   x5E,F
30B2:  BNZ   30BA
30B4:  MOVF   x5D,W
30B6:  SUBLW  64
30B8:  BC    30F6
30BA:  MOVF   x64,F
30BC:  BNZ   30CC
30BE:  MOVF   x63,F
30C0:  BNZ   30CC
30C2:  MOVF   x62,F
30C4:  BNZ   30CC
30C6:  MOVF   x61,W
30C8:  SUBLW  64
30CA:  BC    30F6
30CC:  MOVF   x68,F
30CE:  BNZ   30DE
30D0:  MOVF   x67,F
30D2:  BNZ   30DE
30D4:  MOVF   x66,F
30D6:  BNZ   30DE
30D8:  MOVF   x65,W
30DA:  SUBLW  64
30DC:  BC    30F6
30DE:  MOVF   x58,F
30E0:  BNZ   30F0
30E2:  MOVF   x57,F
30E4:  BNZ   30F0
30E6:  MOVF   x56,F
30E8:  BNZ   30F0
30EA:  MOVF   x55,W
30EC:  SUBLW  64
30EE:  BC    30F6
30F0:  MOVLW  05
30F2:  MOVWF  01
30F4:  BRA    31DA
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
30F6:  MOVF   x6C,F
30F8:  BNZ   310A
30FA:  MOVF   x6B,F
30FC:  BNZ   310A
30FE:  MOVF   x6A,F
3100:  BNZ   310A
3102:  MOVF   x69,W
3104:  SUBLW  C8
3106:  BTFSC  FD8.0
3108:  BRA    31D6
310A:  MOVF   x58,F
310C:  BTFSS  FD8.2
310E:  BRA    31D6
3110:  MOVF   x57,F
3112:  BTFSS  FD8.2
3114:  BRA    31D6
3116:  MOVF   x56,F
3118:  BTFSS  FD8.2
311A:  BRA    31D6
311C:  MOVF   x55,W
311E:  SUBLW  B3
3120:  BTFSS  FD8.0
3122:  BRA    31D6
3124:  MOVF   x58,F
3126:  BNZ   3138
3128:  MOVF   x57,F
312A:  BNZ   3138
312C:  MOVF   x56,F
312E:  BNZ   3138
3130:  MOVF   x55,W
3132:  SUBLW  64
3134:  BTFSC  FD8.0
3136:  BRA    31D6
3138:  MOVF   x5C,F
313A:  BTFSS  FD8.2
313C:  BRA    31D6
313E:  MOVF   x5B,F
3140:  BTFSS  FD8.2
3142:  BRA    31D6
3144:  MOVF   x5A,F
3146:  BTFSS  FD8.2
3148:  BRA    31D6
314A:  MOVF   x59,W
314C:  SUBLW  B3
314E:  BNC   31D6
3150:  MOVF   x5C,F
3152:  BNZ   3162
3154:  MOVF   x5B,F
3156:  BNZ   3162
3158:  MOVF   x5A,F
315A:  BNZ   3162
315C:  MOVF   x59,W
315E:  SUBLW  64
3160:  BC    31D6
3162:  MOVF   x60,F
3164:  BNZ   31D6
3166:  MOVF   x5F,F
3168:  BNZ   31D6
316A:  MOVF   x5E,F
316C:  BNZ   31D6
316E:  MOVF   x5D,W
3170:  SUBLW  B3
3172:  BNC   31D6
3174:  MOVF   x60,F
3176:  BNZ   3186
3178:  MOVF   x5F,F
317A:  BNZ   3186
317C:  MOVF   x5E,F
317E:  BNZ   3186
3180:  MOVF   x5D,W
3182:  SUBLW  64
3184:  BC    31D6
3186:  MOVF   x64,F
3188:  BNZ   31D6
318A:  MOVF   x63,F
318C:  BNZ   31D6
318E:  MOVF   x62,F
3190:  BNZ   31D6
3192:  MOVF   x61,W
3194:  SUBLW  B3
3196:  BNC   31D6
3198:  MOVF   x64,F
319A:  BNZ   31AA
319C:  MOVF   x63,F
319E:  BNZ   31AA
31A0:  MOVF   x62,F
31A2:  BNZ   31AA
31A4:  MOVF   x61,W
31A6:  SUBLW  64
31A8:  BC    31D6
31AA:  MOVF   x68,F
31AC:  BNZ   31D6
31AE:  MOVF   x67,F
31B0:  BNZ   31D6
31B2:  MOVF   x66,F
31B4:  BNZ   31D6
31B6:  MOVF   x65,W
31B8:  SUBLW  B3
31BA:  BNC   31D6
31BC:  MOVF   x68,F
31BE:  BNZ   31CE
31C0:  MOVF   x67,F
31C2:  BNZ   31CE
31C4:  MOVF   x66,F
31C6:  BNZ   31CE
31C8:  MOVF   x65,W
31CA:  SUBLW  64
31CC:  BC    31D6
31CE:  MOVLW  05
31D0:  MOVWF  01
31D2:  BRA    31DA
....................    else return 0xff; 
31D4:  BRA    31DA
31D6:  MOVLW  FF
31D8:  MOVWF  01
.................... } 
31DA:  MOVLB  0
31DC:  GOTO   3242 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
31E0:  MOVLW  20
31E2:  MOVLB  8
31E4:  MOVWF  x51
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
31E6:  BSF    F93.4
31E8:  BTFSS  F81.4
31EA:  BRA    31FE
31EC:  BSF    F93.5
31EE:  BTFSS  F81.5
31F0:  BRA    31FE
31F2:  BSF    F93.6
31F4:  BTFSS  F81.6
31F6:  BRA    31FE
31F8:  BSF    F93.7
31FA:  BTFSC  F81.7
31FC:  BRA    3364
....................     { 
....................        if(input(ROW0)==0) 
31FE:  BSF    F93.4
3200:  BTFSC  F81.4
3202:  BRA    3208
....................          row=0; 
3204:  CLRF   x52
....................        else if(input(ROW1)==0) 
3206:  BRA    322A
3208:  BSF    F93.5
320A:  BTFSC  F81.5
320C:  BRA    3214
....................          row=1; 
320E:  MOVLW  01
3210:  MOVWF  x52
....................        else if(input(ROW2)==0) 
3212:  BRA    322A
3214:  BSF    F93.6
3216:  BTFSC  F81.6
3218:  BRA    3220
....................          row=2; 
321A:  MOVLW  02
321C:  MOVWF  x52
....................        else if(input(ROW3)==0) 
321E:  BRA    322A
3220:  BSF    F93.7
3222:  BTFSC  F81.7
3224:  BRA    322A
....................          row=3;      
3226:  MOVLW  03
3228:  MOVWF  x52
....................        if(type_KB==0)col=check_col(); 
322A:  MOVLB  1
322C:  MOVF   x49,F
322E:  BNZ   323C
3230:  MOVLB  0
3232:  GOTO   23C0
3236:  MOVFF  01,850
....................          else col=new_check_col(); 
323A:  BRA    3246
323C:  MOVLB  0
323E:  GOTO   29EE
3242:  MOVFF  01,850
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
3246:  MOVLB  8
3248:  INCFSZ x50,W
324A:  BRA    324E
324C:  BRA    3334
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
324E:  MOVLB  1
3250:  MOVF   x49,F
3252:  BNZ   327A
3254:  MOVLB  8
3256:  MOVF   x52,W
3258:  MULLW  05
325A:  MOVF   FF3,W
325C:  CLRF   x54
325E:  MOVWF  x53
3260:  CLRF   03
3262:  MOVF   x50,W
3264:  ADDWF  x53,W
3266:  MOVWF  01
3268:  MOVF   x54,W
326A:  ADDWFC 03,F
326C:  MOVF   01,W
326E:  MOVLB  0
3270:  CALL   030A
3274:  MOVFF  FE8,851
....................            else kchar =newKEYS[row][col]; 
3278:  BRA    329E
327A:  MOVLB  8
327C:  MOVF   x52,W
327E:  MULLW  06
3280:  MOVF   FF3,W
3282:  CLRF   x54
3284:  MOVWF  x53
3286:  CLRF   03
3288:  MOVF   x50,W
328A:  ADDWF  x53,W
328C:  MOVWF  01
328E:  MOVF   x54,W
3290:  ADDWFC 03,F
3292:  MOVF   01,W
3294:  MOVLB  0
3296:  CALL   032E
329A:  MOVFF  FE8,851
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
329E:  MOVLB  1
32A0:  MOVF   x44,F
32A2:  BNZ   3326
....................             { 
....................               charac_timeout=0; 
32A4:  CLRF   x00
32A6:  MOVLB  0
32A8:  CLRF   xFF
....................                if(key_count_ms<wideofkeystore) 
32AA:  MOVLB  1
32AC:  MOVF   x47,W
32AE:  SUBLW  0F
32B0:  BNC   3324
....................                { 
....................                    key_data[key_count_ms++]=kchar; 
32B2:  MOVF   x47,W
32B4:  INCF   x47,F
32B6:  CLRF   03
32B8:  ADDLW  4A
32BA:  MOVWF  FE9
32BC:  MOVLW  01
32BE:  ADDWFC 03,W
32C0:  MOVWF  FEA
32C2:  MOVFF  851,FEF
....................                    fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
32C6:  MOVLW  56
32C8:  MOVWF  FF6
32CA:  MOVLW  05
32CC:  MOVWF  FF7
32CE:  MOVLW  09
32D0:  MOVLB  8
32D2:  MOVWF  xF7
32D4:  MOVLB  0
32D6:  CALL   164A
32DA:  MOVFF  147,859
32DE:  MOVLW  18
32E0:  MOVLB  8
32E2:  MOVWF  x5A
32E4:  MOVLB  0
32E6:  CALL   177A
32EA:  MOVLW  5D
32EC:  MOVLB  9
32EE:  MOVWF  x0C
32F0:  MOVLB  0
32F2:  CALL   1604
32F6:  MOVLW  20
32F8:  MOVLB  9
32FA:  MOVWF  x0C
32FC:  MOVLB  0
32FE:  CALL   1604
3302:  MOVFF  851,90C
3306:  CALL   1604
330A:  MOVLW  0D
330C:  MOVLB  9
330E:  MOVWF  x0C
3310:  MOVLB  0
3312:  CALL   1604
3316:  MOVLW  0A
3318:  MOVLB  9
331A:  MOVWF  x0C
331C:  MOVLB  0
331E:  CALL   1604
3322:  MOVLB  1
....................                } 
....................             } 
....................                else fputc(kchar,COM2); 
3324:  BRA    3332
3326:  MOVFF  851,90C
332A:  MOVLB  0
332C:  CALL   1604
3330:  MOVLB  1
3332:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3334:  BSF    F93.4
3336:  BTFSS  F81.4
3338:  BRA    3334
333A:  BSF    F93.5
333C:  BTFSS  F81.5
333E:  BRA    3334
3340:  BSF    F93.6
3342:  BTFSS  F81.6
3344:  BRA    3334
3346:  BSF    F93.7
3348:  BTFSS  F81.7
334A:  BRA    3334
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
334C:  BSF    F93.4
334E:  BTFSS  F81.4
3350:  BRA    334C
3352:  BSF    F93.5
3354:  BTFSS  F81.5
3356:  BRA    334C
3358:  BSF    F93.6
335A:  BTFSS  F81.6
335C:  BRA    334C
335E:  BSF    F93.7
3360:  BTFSS  F81.7
3362:  BRA    334C
....................     } 
....................   set_tris_a(0xff);     
3364:  MOVLW  FF
3366:  MOVWF  F92
....................   return(kchar); 
3368:  MOVFF  851,01
.................... }//*/ 
336C:  MOVLB  0
336E:  RETURN 0
....................  
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int8 i,tempdata; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
54B6:  MOVF   27,F
54B8:  BTFSS  FD8.2
54BA:  BRA    5650
54BC:  MOVF   26,F
54BE:  BTFSS  FD8.2
54C0:  BRA    5650
54C2:  MOVF   25,W
54C4:  SUBLW  FF
54C6:  BTFSS  FD8.0
54C8:  BRA    5650
54CA:  BNZ   54D4
54CC:  MOVF   24,W
54CE:  SUBLW  FE
54D0:  BTFSS  FD8.0
54D2:  BRA    5650
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
54D4:  MOVLB  1
54D6:  MOVF   x4A,F
54D8:  BNZ   54E0
54DA:  MOVF   x47,F
54DC:  BTFSC  FD8.2
54DE:  BRA    55FC
....................       { 
....................          temp=get_countcard(); 
54E0:  MOVLB  0
54E2:  CALL   351C
54E6:  MOVFF  02,853
54EA:  MOVFF  01,852
....................          //fprintf(COM2," get_countcard=%lu\n\r",temp); 
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
54EE:  MOVLB  8
54F0:  RLCF   x52,W
54F2:  MOVWF  x54
54F4:  RLCF   x53,W
54F6:  MOVWF  x55
54F8:  RLCF   x54,F
54FA:  RLCF   x55,F
54FC:  RLCF   x54,F
54FE:  RLCF   x55,F
5500:  RLCF   x54,F
5502:  RLCF   x55,F
5504:  MOVLW  F0
5506:  ANDWF  x54,F
5508:  MOVLW  E1
550A:  ADDWF  x55,F
550C:  MOVLW  01
550E:  ADDWF  x54,W
5510:  MOVWF  01
5512:  MOVLW  00
5514:  ADDWFC x55,W
5516:  MOVFF  01,24
551A:  MOVWF  25
551C:  CLRF   26
551E:  CLRF   27
....................          //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<wideofkeystore;i++) 
5520:  CLRF   x50
5522:  MOVF   x50,W
5524:  SUBLW  0F
5526:  BNC   556E
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
5528:  MOVF   x50,W
552A:  ADDWF  24,W
552C:  MOVWF  00
552E:  MOVLW  00
5530:  ADDWFC 25,W
5532:  MOVWF  01
5534:  MOVLW  00
5536:  ADDWFC 26,W
5538:  MOVWF  02
553A:  MOVLW  00
553C:  ADDWFC 27,W
553E:  MOVWF  03
5540:  MOVWF  x57
5542:  MOVFF  02,856
5546:  MOVFF  01,855
554A:  MOVFF  00,854
554E:  MOVFF  FE8,916
5552:  MOVFF  02,915
5556:  MOVFF  01,914
555A:  MOVFF  00,913
555E:  MOVLB  9
5560:  CLRF   x17
5562:  MOVLB  0
5564:  CALL   3A6C
....................          } 
5568:  MOVLB  8
556A:  INCF   x50,F
556C:  BRA    5522
....................          for(i=0;i<wideofkeystore;i++) 
556E:  CLRF   x50
5570:  MOVF   x50,W
5572:  SUBLW  0F
5574:  BNC   55E0
....................          { 
....................             tempdata=key_data[i]; 
5576:  CLRF   03
5578:  MOVF   x50,W
557A:  ADDLW  4A
557C:  MOVWF  FE9
557E:  MOVLW  01
5580:  ADDWFC 03,W
5582:  MOVWF  FEA
5584:  MOVFF  FEF,851
....................             write_ext_eeprom((int32)ptr_card_key++,tempdata); 
5588:  MOVFF  27,03
558C:  MOVFF  26,02
5590:  MOVFF  25,01
5594:  MOVFF  24,00
5598:  MOVLW  01
559A:  ADDWF  24,F
559C:  BTFSC  FD8.0
559E:  INCF   25,F
55A0:  BTFSC  FD8.2
55A2:  INCF   26,F
55A4:  BTFSC  FD8.2
55A6:  INCF   27,F
55A8:  MOVFF  03,857
55AC:  MOVFF  02,856
55B0:  MOVFF  01,855
55B4:  MOVFF  00,854
55B8:  MOVFF  03,916
55BC:  MOVFF  02,915
55C0:  MOVFF  01,914
55C4:  MOVFF  00,913
55C8:  MOVFF  851,917
55CC:  MOVLB  0
55CE:  CALL   3A6C
....................             //delay_us(100); 
....................             fprintf(COM2,"%c",tempdata); 
55D2:  MOVFF  851,90C
55D6:  CALL   1604
....................          } 
55DA:  MOVLB  8
55DC:  INCF   x50,F
55DE:  BRA    5570
....................           //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................           /*fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<wideofkeystore;i++) 
....................           { 
....................             fprintf(COM2,"%c",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
55E0:  MOVFF  27,8FA
55E4:  MOVFF  26,8F9
55E8:  MOVFF  25,8F8
55EC:  MOVFF  24,8F7
55F0:  MOVLW  1E
55F2:  MOVWF  xFB
55F4:  MOVLB  0
55F6:  CALL   3B6A
55FA:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
55FC:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
55FE:  MOVLW  01
5600:  MOVWF  FEA
5602:  MOVLW  4A
5604:  MOVWF  FE9
5606:  CLRF   00
5608:  CLRF   02
560A:  MOVLW  10
560C:  MOVWF  01
560E:  MOVLB  0
5610:  CALL   359A
....................       fprintf(COM2,"\r\n"); 
5614:  MOVLW  0D
5616:  MOVLB  9
5618:  MOVWF  x0C
561A:  MOVLB  0
561C:  CALL   1604
5620:  MOVLW  0A
5622:  MOVLB  9
5624:  MOVWF  x0C
5626:  MOVLB  0
5628:  CALL   1604
....................       fprintf(COM2,"Done save_key_new"); 
562C:  MOVLW  68
562E:  MOVWF  FF6
5630:  MOVLW  05
5632:  MOVWF  FF7
5634:  CALL   172E
....................       fprintf(COM2,"\r\n"); 
5638:  MOVLW  0D
563A:  MOVLB  9
563C:  MOVWF  x0C
563E:  MOVLB  0
5640:  CALL   1604
5644:  MOVLW  0A
5646:  MOVLB  9
5648:  MOVWF  x0C
564A:  MOVLB  0
564C:  CALL   1604
....................    } 
.................... } 
5650:  GOTO   5B64 (RETURN)
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 recEn[wideofkeystore]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
5654:  MOVF   27,F
5656:  BTFSS  FD8.2
5658:  BRA    5898
565A:  MOVF   26,F
565C:  BTFSS  FD8.2
565E:  BRA    5898
5660:  MOVF   25,W
5662:  SUBLW  FF
5664:  BTFSS  FD8.0
5666:  BRA    5898
5668:  BNZ   5672
566A:  MOVF   24,W
566C:  SUBLW  FE
566E:  BTFSS  FD8.0
5670:  BRA    5898
....................    {   
....................      for(i=0;i<key_numbyte;i++) 
5672:  MOVLB  8
5674:  CLRF   x50
5676:  MOVF   x50,W
5678:  SUBLW  0B
567A:  BNC   56CE
....................      { 
....................         temp=key_data[i]; 
567C:  CLRF   03
567E:  MOVF   x50,W
5680:  ADDLW  4A
5682:  MOVWF  FE9
5684:  MOVLW  01
5686:  ADDWFC 03,W
5688:  MOVWF  FEA
568A:  CLRF   x52
568C:  MOVFF  FEF,851
....................         fputc(temp,COM2); 
5690:  MOVFF  851,90C
5694:  MOVLB  0
5696:  CALL   1604
....................         recEn[i]=key_data[i]; 
569A:  CLRF   03
569C:  MOVLB  8
569E:  MOVF   x50,W
56A0:  ADDLW  54
56A2:  MOVWF  01
56A4:  MOVLW  08
56A6:  ADDWFC 03,F
56A8:  MOVFF  03,865
56AC:  CLRF   03
56AE:  MOVF   x50,W
56B0:  ADDLW  4A
56B2:  MOVWF  FE9
56B4:  MOVLW  01
56B6:  ADDWFC 03,W
56B8:  MOVWF  FEA
56BA:  MOVFF  FEF,866
56BE:  MOVFF  865,FEA
56C2:  MOVFF  01,FE9
56C6:  MOVFF  866,FEF
....................      } 
56CA:  INCF   x50,F
56CC:  BRA    5676
....................      recEn[key_numbyte] = 0; 
56CE:  CLRF   x60
....................      recEn[key_numbyte+1] = 0;          
56D0:  CLRF   x61
....................      recEn[key_numbyte+2] = 0;          
56D2:  CLRF   x62
....................      recEn[key_numbyte+3] = 0; 
56D4:  CLRF   x63
.................... #if 0 
....................      fprintf(COM2,"\n\r"); 
....................      fprintf(COM2,"test_key:\n\r"); 
....................      for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................      fprintf(COM2,"\n\r"); 
....................      fprintf(COM2,"\n\rdatain:\n\r"); 
....................      for(i=0;i<16;i++) fprintf(COM2," %x",recEn[i]); 
....................      fprintf(COM2,"\n\r"); 
.................... #endif 
....................      EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
56D6:  MOVLB  9
56D8:  CLRF   x07
56DA:  CLRF   x06
56DC:  CLRF   x05
56DE:  MOVLW  3F
56E0:  MOVWF  x04
56E2:  CLRF   x0B
56E4:  CLRF   x0A
56E6:  CLRF   x09
56E8:  MOVLW  20
56EA:  MOVWF  x08
56EC:  MOVLW  01
56EE:  MOVWF  x0D
56F0:  MOVWF  x0C
56F2:  MOVLB  0
56F4:  CALL   3FF6
....................      aes_enc_dec((unsigned int8 *)&recEn[0], (unsigned int8 *)&crypto_key[0],0); 
56F8:  MOVLW  08
56FA:  MOVLB  8
56FC:  MOVWF  xF8
56FE:  MOVLW  54
5700:  MOVWF  xF7
5702:  MOVLW  01
5704:  MOVWF  xFA
5706:  MOVWF  xF9
5708:  CLRF   xFB
570A:  MOVLB  0
570C:  CALL   40EC
....................      //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................       
....................      /* get the pointer of keyboard data */ 
....................      temp=get_countcard(); 
5710:  CALL   351C
5714:  MOVFF  02,852
5718:  MOVFF  01,851
....................      ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
571C:  MOVLB  8
571E:  RLCF   x51,W
5720:  MOVWF  x64
5722:  RLCF   x52,W
5724:  MOVWF  x65
5726:  RLCF   x64,F
5728:  RLCF   x65,F
572A:  RLCF   x64,F
572C:  RLCF   x65,F
572E:  RLCF   x64,F
5730:  RLCF   x65,F
5732:  MOVLW  F0
5734:  ANDWF  x64,F
5736:  MOVLW  E1
5738:  ADDWF  x65,F
573A:  MOVLW  01
573C:  ADDWF  x64,W
573E:  MOVWF  01
5740:  MOVLW  00
5742:  ADDWFC x65,W
5744:  MOVFF  01,24
5748:  MOVWF  25
574A:  CLRF   26
574C:  CLRF   27
....................      /* delete the old data of key store area  */ 
....................      //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................      for(i=0;i<wideofkeystore;i++) 
574E:  CLRF   x50
5750:  MOVF   x50,W
5752:  SUBLW  0F
5754:  BNC   579C
....................      { 
....................         write_ext_eeprom((int32)(ptr_card_key+i),0); 
5756:  MOVF   x50,W
5758:  ADDWF  24,W
575A:  MOVWF  00
575C:  MOVLW  00
575E:  ADDWFC 25,W
5760:  MOVWF  01
5762:  MOVLW  00
5764:  ADDWFC 26,W
5766:  MOVWF  02
5768:  MOVLW  00
576A:  ADDWFC 27,W
576C:  MOVWF  03
576E:  MOVWF  x67
5770:  MOVFF  02,866
5774:  MOVFF  01,865
5778:  MOVFF  00,864
577C:  MOVFF  FE8,916
5780:  MOVFF  02,915
5784:  MOVFF  01,914
5788:  MOVFF  00,913
578C:  MOVLB  9
578E:  CLRF   x17
5790:  MOVLB  0
5792:  CALL   3A6C
....................      } 
5796:  MOVLB  8
5798:  INCF   x50,F
579A:  BRA    5750
....................      fprintf(COM2,"\n\r"); 
579C:  MOVLW  0A
579E:  MOVLB  9
57A0:  MOVWF  x0C
57A2:  MOVLB  0
57A4:  CALL   1604
57A8:  MOVLW  0D
57AA:  MOVLB  9
57AC:  MOVWF  x0C
57AE:  MOVLB  0
57B0:  CALL   1604
....................      for(i=0;i<wideofkeystore;i++) fprintf(COM2,"%x",recEn[i]); 
57B4:  MOVLB  8
57B6:  CLRF   x50
57B8:  MOVF   x50,W
57BA:  SUBLW  0F
57BC:  BNC   57E6
57BE:  CLRF   03
57C0:  MOVF   x50,W
57C2:  ADDLW  54
57C4:  MOVWF  FE9
57C6:  MOVLW  08
57C8:  ADDWFC 03,W
57CA:  MOVWF  FEA
57CC:  MOVFF  FEF,864
57D0:  MOVFF  864,901
57D4:  MOVLW  57
57D6:  MOVLB  9
57D8:  MOVWF  x02
57DA:  MOVLB  0
57DC:  CALL   4FA4
57E0:  MOVLB  8
57E2:  INCF   x50,F
57E4:  BRA    57B8
....................      retval = EEPROM_write(ptr_card_key,wideofkeystore,recEn);  
57E6:  MOVFF  27,8FA
57EA:  MOVFF  26,8F9
57EE:  MOVFF  25,8F8
57F2:  MOVFF  24,8F7
57F6:  CLRF   xFE
57F8:  CLRF   xFD
57FA:  CLRF   xFC
57FC:  MOVLW  10
57FE:  MOVWF  xFB
5800:  MOVLW  08
5802:  MOVLB  9
5804:  MOVWF  x00
5806:  MOVLW  54
5808:  MOVLB  8
580A:  MOVWF  xFF
580C:  MOVLB  0
580E:  CALL   4EE8
5812:  MOVFF  01,853
....................      if(retval!=0) 
5816:  MOVLB  8
5818:  MOVF   x53,F
581A:  BZ    5842
....................      { 
....................         ptr_card_key+=wideofkeystore; 
581C:  MOVLW  10
581E:  ADDWF  24,F
5820:  MOVLW  00
5822:  ADDWFC 25,F
5824:  ADDWFC 26,F
5826:  ADDWFC 27,F
....................         save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5828:  MOVFF  27,8FA
582C:  MOVFF  26,8F9
5830:  MOVFF  25,8F8
5834:  MOVFF  24,8F7
5838:  MOVLW  1E
583A:  MOVWF  xFB
583C:  MOVLB  0
583E:  CALL   3B6A
....................      }          
....................       key_count_ms=0; 
5842:  MOVLB  1
5844:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
5846:  MOVLW  01
5848:  MOVWF  FEA
584A:  MOVLW  4A
584C:  MOVWF  FE9
584E:  CLRF   00
5850:  CLRF   02
5852:  MOVLW  10
5854:  MOVWF  01
5856:  MOVLB  0
5858:  CALL   359A
....................       fprintf(COM2,"\r\n"); 
585C:  MOVLW  0D
585E:  MOVLB  9
5860:  MOVWF  x0C
5862:  MOVLB  0
5864:  CALL   1604
5868:  MOVLW  0A
586A:  MOVLB  9
586C:  MOVWF  x0C
586E:  MOVLB  0
5870:  CALL   1604
....................       fprintf(COM2,"Done Encrypted PIN"); 
5874:  MOVLW  7A
5876:  MOVWF  FF6
5878:  MOVLW  05
587A:  MOVWF  FF7
587C:  CALL   172E
....................       fprintf(COM2,"\r\n"); 
5880:  MOVLW  0D
5882:  MOVLB  9
5884:  MOVWF  x0C
5886:  MOVLB  0
5888:  CALL   1604
588C:  MOVLW  0A
588E:  MOVLB  9
5890:  MOVWF  x0C
5892:  MOVLB  0
5894:  CALL   1604
....................    } 
.................... } 
5898:  GOTO   5B6C (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
5F7E:  MOVLB  7
5F80:  CLRF   xFA
5F82:  CLRF   xF9
5F84:  CLRF   xFB
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
5F86:  MOVF   xFA,F
5F88:  BTFSS  FD8.2
5F8A:  BRA    60AE
5F8C:  MOVF   xF4,W
5F8E:  SUBWF  xF9,W
5F90:  BTFSC  FD8.0
5F92:  BRA    60AE
5F94:  MOVF   xFB,F
5F96:  BTFSS  FD8.2
5F98:  BRA    60AE
....................       c = fgetc(COM2);//getc(); 
5F9A:  MOVLB  0
5F9C:  RCALL  5F30
5F9E:  MOVFF  01,7F7
....................       switch(c) 
....................       { 
5FA2:  MOVLB  7
5FA4:  MOVF   xF7,W
5FA6:  XORLW  7F
5FA8:  MOVLB  0
5FAA:  BZ    5FB2
5FAC:  XORLW  72
5FAE:  BZ    6000
5FB0:  BRA    603E
....................          case 0x7f:    
....................             if(nbcar>0)   
5FB2:  MOVLB  7
5FB4:  MOVF   xF9,F
5FB6:  BNZ   5FBC
5FB8:  MOVF   xFA,F
5FBA:  BZ    5FE6
5FBC:  CLRF   19
5FBE:  BTFSC  FF2.7
5FC0:  BSF    19.7
5FC2:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
5FC4:  MOVLW  7F
5FC6:  MOVLB  9
5FC8:  MOVWF  x0C
5FCA:  MOVLB  0
5FCC:  CALL   1604
5FD0:  BTFSC  19.7
5FD2:  BSF    FF2.7
....................                nbcar--; 
5FD4:  MOVLB  7
5FD6:  MOVF   xF9,W
5FD8:  BTFSC  FD8.2
5FDA:  DECF   xFA,F
5FDC:  DECF   xF9,F
....................                fgetc(COM2);//getc(); 
5FDE:  MOVLB  0
5FE0:  RCALL  5F30
....................             } 
....................             else fputc(0x07,COM2);    
5FE2:  BRA    5FFE
5FE4:  MOVLB  7
5FE6:  CLRF   19
5FE8:  BTFSC  FF2.7
5FEA:  BSF    19.7
5FEC:  BCF    FF2.7
5FEE:  MOVLW  07
5FF0:  MOVLB  9
5FF2:  MOVWF  x0C
5FF4:  MOVLB  0
5FF6:  CALL   1604
5FFA:  BTFSC  19.7
5FFC:  BSF    FF2.7
....................          break;  
5FFE:  BRA    60AA
....................          case 0x0D:   
....................                keydebug_en=0; 
6000:  MOVLB  1
6002:  CLRF   x44
....................                set_tris_a(0xff); 
6004:  MOVLW  FF
6006:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
6008:  MOVFF  7F9,7F8
600C:  MOVLB  7
600E:  MOVF   xF4,W
6010:  SUBWF  xF8,W
6012:  BC    6028
....................                { 
....................                  chaine[i]=0; 
6014:  CLRF   03
6016:  MOVF   xF8,W
6018:  ADDWF  xF5,W
601A:  MOVWF  FE9
601C:  MOVF   xF6,W
601E:  ADDWFC 03,W
6020:  MOVWF  FEA
6022:  CLRF   FEF
....................                } 
6024:  INCF   xF8,F
6026:  BRA    600E
....................                if(nbcar==0)return(FAUX); 
6028:  MOVF   xF9,F
602A:  BNZ   6036
602C:  MOVF   xFA,F
602E:  BNZ   6036
6030:  MOVLW  00
6032:  MOVWF  01
6034:  BRA    60B2
....................                fini=VRAI; 
6036:  MOVLW  01
6038:  MOVWF  xFB
....................          break; 
603A:  MOVLB  0
603C:  BRA    60AA
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
603E:  MOVLB  7
6040:  MOVF   xF7,W
6042:  SUBLW  1F
6044:  BC    60AC
6046:  MOVF   xF7,W
6048:  SUBLW  7E
604A:  BNC   60AC
604C:  MOVLW  01
604E:  SUBWF  xF4,W
6050:  MOVF   xFA,F
6052:  BNZ   60AC
6054:  SUBWF  xF9,W
6056:  BC    60AC
....................             { 
....................                chaine[nbcar]=c; 
6058:  MOVF   xF5,W
605A:  ADDWF  xF9,W
605C:  MOVWF  FE9
605E:  MOVF   xF6,W
6060:  ADDWFC xFA,W
6062:  MOVWF  FEA
6064:  MOVFF  7F7,FEF
....................                nbcar++; 
6068:  INCF   xF9,F
606A:  BTFSC  FD8.2
606C:  INCF   xFA,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
606E:  DECFSZ xF3,W
6070:  BRA    608C
6072:  CLRF   19
6074:  BTFSC  FF2.7
6076:  BSF    19.7
6078:  BCF    FF2.7
607A:  MOVFF  7F7,90C
607E:  MOVLB  0
6080:  CALL   1604
6084:  BTFSC  19.7
6086:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
6088:  BRA    60AA
608A:  MOVLB  7
608C:  MOVF   xF3,W
608E:  SUBLW  02
6090:  BNZ   60AC
6092:  CLRF   19
6094:  BTFSC  FF2.7
6096:  BSF    19.7
6098:  BCF    FF2.7
609A:  MOVLW  2A
609C:  MOVLB  9
609E:  MOVWF  x0C
60A0:  MOVLB  0
60A2:  CALL   1604
60A6:  BTFSC  19.7
60A8:  BSF    FF2.7
60AA:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
60AC:  BRA    5F86
....................    return(nbcar); 
60AE:  MOVFF  7F9,01
.................... } 
60B2:  MOVLB  0
60B4:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
60B6:  MOVFF  7F4,7F8
60BA:  MOVFF  7F3,7F7
60BE:  MOVFF  7F6,7FA
60C2:  MOVFF  7F5,7F9
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
60C6:  MOVFF  7F8,03
60CA:  MOVLB  7
60CC:  MOVFF  7F7,FE9
60D0:  MOVFF  7F8,FEA
60D4:  MOVF   FEF,F
60D6:  BZ    611E
60D8:  MOVFF  7FA,03
60DC:  MOVFF  7F9,FE9
60E0:  MOVFF  7FA,FEA
60E4:  MOVF   FEF,F
60E6:  BZ    611E
....................       if(*aa!=*bb) 
60E8:  MOVFF  7F7,FE9
60EC:  MOVFF  7F8,FEA
60F0:  MOVFF  FEF,7FB
60F4:  MOVFF  7FA,03
60F8:  MOVFF  7F9,FE9
60FC:  MOVFF  7FA,FEA
6100:  MOVF   FEF,W
6102:  SUBWF  xFB,W
6104:  BZ    610C
....................          return(1); 
6106:  MOVLW  01
6108:  MOVWF  01
610A:  BRA    614A
....................       aa++; 
610C:  INCF   xF7,F
610E:  BTFSC  FD8.2
6110:  INCF   xF8,F
....................       bb++; 
6112:  INCF   xF9,F
6114:  BTFSC  FD8.2
6116:  INCF   xFA,F
....................    } 
6118:  MOVLB  0
611A:  BRA    60C6
611C:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
611E:  MOVFF  7F8,03
6122:  MOVFF  7F7,FE9
6126:  MOVFF  7F8,FEA
612A:  MOVFF  FEF,7FB
612E:  MOVFF  7FA,03
6132:  MOVFF  7F9,FE9
6136:  MOVFF  7FA,FEA
613A:  MOVF   FEF,W
613C:  SUBWF  xFB,W
613E:  BZ    6146
6140:  MOVLW  01
6142:  MOVWF  01
6144:  BRA    614A
....................    return(0); 
6146:  MOVLW  00
6148:  MOVWF  01
.................... } 
614A:  MOVLB  0
614C:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
6B54:  MOVLB  7
6B56:  CLRF   xF5
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
6B58:  MOVFF  7F4,03
6B5C:  MOVF   xF3,W
6B5E:  INCF   xF3,F
6B60:  BTFSC  FD8.2
6B62:  INCF   xF4,F
6B64:  MOVWF  FE9
6B66:  MOVFF  03,FEA
6B6A:  MOVFF  FEF,7F7
6B6E:  MOVF   xF7,F
6B70:  BZ    6B94
....................         if (c >= '0' && c <= '9') 
6B72:  MOVF   xF7,W
6B74:  SUBLW  2F
6B76:  BC    6B86
6B78:  MOVF   xF7,W
6B7A:  SUBLW  39
6B7C:  BNC   6B86
....................             digit = (unsigned int) (c - '0'); 
6B7E:  MOVLW  30
6B80:  SUBWF  xF7,W
6B82:  MOVWF  xF6
....................         else 
6B84:  BRA    6B88
....................             break; 
6B86:  BRA    6B94
....................  
....................         val = (val * 10) + digit; 
6B88:  MOVF   xF5,W
6B8A:  MULLW  0A
6B8C:  MOVF   FF3,W
6B8E:  ADDWF  xF6,W
6B90:  MOVWF  xF5
....................     } 
6B92:  BRA    6B58
....................  
....................     return val; 
6B94:  CLRF   03
6B96:  MOVFF  7F5,01
6B9A:  MOVFF  03,02
.................... } 
6B9E:  MOVLB  0
6BA0:  RETURN 0
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
06AC:  MOVLB  9
06AE:  CLRF   x3F
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
06B0:  CLRF   x40
06B2:  BTFSC  x37.0
06B4:  BSF    x40.7
06B6:  SWAPF  x38,W
06B8:  MOVWF  00
06BA:  RLCF   00,F
06BC:  RLCF   00,F
06BE:  MOVLW  C0
06C0:  ANDWF  00,F
06C2:  MOVF   00,W
06C4:  IORWF  x40,F
06C6:  SWAPF  x39,W
06C8:  MOVWF  00
06CA:  RLCF   00,F
06CC:  MOVLW  E0
06CE:  ANDWF  00,F
06D0:  MOVF   00,W
06D2:  IORWF  x40,F
06D4:  SWAPF  x3A,W
06D6:  MOVWF  00
06D8:  MOVLW  F0
06DA:  ANDWF  00,F
06DC:  MOVF   00,W
06DE:  IORWF  x40,F
06E0:  RLCF   x3B,W
06E2:  MOVWF  00
06E4:  RLCF   00,F
06E6:  RLCF   00,F
06E8:  MOVLW  F8
06EA:  ANDWF  00,F
06EC:  MOVF   00,W
06EE:  IORWF  x40,F
06F0:  RLCF   x3C,W
06F2:  MOVWF  00
06F4:  RLCF   00,F
06F6:  MOVLW  FC
06F8:  ANDWF  00,F
06FA:  MOVF   00,W
06FC:  IORWF  x40,F
06FE:  BCF    FD8.0
0700:  RLCF   x3D,W
0702:  IORWF  x40,F
0704:  MOVF   x3E,W
0706:  IORWF  x40,W
0708:  MOVWF  x3F
....................    return temp; 
070A:  MOVFF  93F,01
.................... } 
070E:  MOVLB  0
0710:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0712:  MOVLB  9
0714:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
0716:  MOVF   x22,F
0718:  BNZ   07EE
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
071A:  MOVF   x25,W
071C:  ADDWF  x23,W
071E:  MOVWF  FE9
0720:  MOVF   x26,W
0722:  ADDWFC x24,W
0724:  MOVWF  FEA
0726:  MOVFF  FEF,928
072A:  MOVLW  01
072C:  ADDWF  x23,W
072E:  MOVWF  x29
0730:  MOVLW  00
0732:  ADDWFC x24,W
0734:  MOVWF  x2A
0736:  MOVF   x25,W
0738:  ADDWF  x29,W
073A:  MOVWF  FE9
073C:  MOVF   x26,W
073E:  ADDWFC x2A,W
0740:  MOVWF  FEA
0742:  MOVF   FEF,W
0744:  XORWF  x28,F
0746:  MOVLW  02
0748:  ADDWF  x23,W
074A:  MOVWF  x2B
074C:  MOVLW  00
074E:  ADDWFC x24,W
0750:  MOVWF  x2C
0752:  MOVF   x25,W
0754:  ADDWF  x2B,W
0756:  MOVWF  FE9
0758:  MOVF   x26,W
075A:  ADDWFC x2C,W
075C:  MOVWF  FEA
075E:  MOVF   FEF,W
0760:  XORWF  x28,F
0762:  MOVLW  03
0764:  ADDWF  x23,W
0766:  MOVWF  x2D
0768:  MOVLW  00
076A:  ADDWFC x24,W
076C:  MOVWF  x2E
076E:  MOVF   x25,W
0770:  ADDWF  x2D,W
0772:  MOVWF  FE9
0774:  MOVF   x26,W
0776:  ADDWFC x2E,W
0778:  MOVWF  FEA
077A:  MOVF   FEF,W
077C:  XORWF  x28,F
077E:  MOVLW  04
0780:  ADDWF  x23,W
0782:  MOVWF  x2F
0784:  MOVLW  00
0786:  ADDWFC x24,W
0788:  MOVWF  x30
078A:  MOVF   x25,W
078C:  ADDWF  x2F,W
078E:  MOVWF  FE9
0790:  MOVF   x26,W
0792:  ADDWFC x30,W
0794:  MOVWF  FEA
0796:  MOVF   FEF,W
0798:  XORWF  x28,F
079A:  MOVLW  05
079C:  ADDWF  x23,W
079E:  MOVWF  x31
07A0:  MOVLW  00
07A2:  ADDWFC x24,W
07A4:  MOVWF  x32
07A6:  MOVF   x25,W
07A8:  ADDWF  x31,W
07AA:  MOVWF  FE9
07AC:  MOVF   x26,W
07AE:  ADDWFC x32,W
07B0:  MOVWF  FEA
07B2:  MOVF   FEF,W
07B4:  XORWF  x28,W
07B6:  BZ    07BC
07B8:  MOVLW  00
07BA:  BRA    07BE
07BC:  MOVLW  01
07BE:  MOVWF  x27
....................       if(temp==datain[offset+6]) return 1; 
07C0:  MOVLW  06
07C2:  ADDWF  x23,W
07C4:  MOVWF  x28
07C6:  MOVLW  00
07C8:  ADDWFC x24,W
07CA:  MOVWF  x29
07CC:  MOVF   x25,W
07CE:  ADDWF  x28,W
07D0:  MOVWF  FE9
07D2:  MOVF   x26,W
07D4:  ADDWFC x29,W
07D6:  MOVWF  FEA
07D8:  MOVF   FEF,W
07DA:  SUBWF  x27,W
07DC:  BNZ   07E6
07DE:  MOVLW  01
07E0:  MOVWF  01
07E2:  BRA    08BE
....................          else return 0; 
07E4:  BRA    07EC
07E6:  MOVLW  00
07E8:  MOVWF  01
07EA:  BRA    08BE
....................    } 
....................       else  
07EC:  BRA    08BE
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
07EE:  MOVF   x25,W
07F0:  ADDWF  x23,W
07F2:  MOVWF  FE9
07F4:  MOVF   x26,W
07F6:  ADDWFC x24,W
07F8:  MOVWF  FEA
07FA:  MOVFF  FEF,928
07FE:  MOVLW  01
0800:  SUBWF  x23,W
0802:  MOVWF  x29
0804:  MOVLW  00
0806:  SUBWFB x24,W
0808:  MOVWF  x2A
080A:  MOVF   x25,W
080C:  ADDWF  x29,W
080E:  MOVWF  FE9
0810:  MOVF   x26,W
0812:  ADDWFC x2A,W
0814:  MOVWF  FEA
0816:  MOVF   FEF,W
0818:  XORWF  x28,F
081A:  MOVLW  02
081C:  SUBWF  x23,W
081E:  MOVWF  x2B
0820:  MOVLW  00
0822:  SUBWFB x24,W
0824:  MOVWF  x2C
0826:  MOVF   x25,W
0828:  ADDWF  x2B,W
082A:  MOVWF  FE9
082C:  MOVF   x26,W
082E:  ADDWFC x2C,W
0830:  MOVWF  FEA
0832:  MOVF   FEF,W
0834:  XORWF  x28,F
0836:  MOVLW  03
0838:  SUBWF  x23,W
083A:  MOVWF  x2D
083C:  MOVLW  00
083E:  SUBWFB x24,W
0840:  MOVWF  x2E
0842:  MOVF   x25,W
0844:  ADDWF  x2D,W
0846:  MOVWF  FE9
0848:  MOVF   x26,W
084A:  ADDWFC x2E,W
084C:  MOVWF  FEA
084E:  MOVF   FEF,W
0850:  XORWF  x28,F
0852:  MOVLW  04
0854:  SUBWF  x23,W
0856:  MOVWF  x2F
0858:  MOVLW  00
085A:  SUBWFB x24,W
085C:  MOVWF  x30
085E:  MOVF   x25,W
0860:  ADDWF  x2F,W
0862:  MOVWF  FE9
0864:  MOVF   x26,W
0866:  ADDWFC x30,W
0868:  MOVWF  FEA
086A:  MOVF   FEF,W
086C:  XORWF  x28,F
086E:  MOVLW  05
0870:  SUBWF  x23,W
0872:  MOVWF  x31
0874:  MOVLW  00
0876:  SUBWFB x24,W
0878:  MOVWF  x32
087A:  MOVF   x25,W
087C:  ADDWF  x31,W
087E:  MOVWF  FE9
0880:  MOVF   x26,W
0882:  ADDWFC x32,W
0884:  MOVWF  FEA
0886:  MOVF   FEF,W
0888:  XORWF  x28,W
088A:  BZ    0890
088C:  MOVLW  00
088E:  BRA    0892
0890:  MOVLW  01
0892:  MOVWF  x27
....................          if(temp==datain[offset-6]) return 1; 
0894:  MOVLW  06
0896:  SUBWF  x23,W
0898:  MOVWF  x28
089A:  MOVLW  00
089C:  SUBWFB x24,W
089E:  MOVWF  x29
08A0:  MOVF   x25,W
08A2:  ADDWF  x28,W
08A4:  MOVWF  FE9
08A6:  MOVF   x26,W
08A8:  ADDWFC x29,W
08AA:  MOVWF  FEA
08AC:  MOVF   FEF,W
08AE:  SUBWF  x27,W
08B0:  BNZ   08BA
08B2:  MOVLW  01
08B4:  MOVWF  01
08B6:  BRA    08BE
....................             else return 0;          
08B8:  BRA    08BE
08BA:  MOVLW  00
08BC:  MOVWF  01
....................       } 
.................... } 
08BE:  MOVLB  0
08C0:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
08C2:  MOVLB  9
08C4:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
08C6:  MOVF   x22,F
08C8:  BNZ   0966
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
08CA:  MOVF   x25,W
08CC:  ADDWF  x23,W
08CE:  MOVWF  FE9
08D0:  MOVF   x26,W
08D2:  ADDWFC x24,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEF,928
08DA:  MOVLW  01
08DC:  ADDWF  x23,W
08DE:  MOVWF  x29
08E0:  MOVLW  00
08E2:  ADDWFC x24,W
08E4:  MOVWF  x2A
08E6:  MOVF   x25,W
08E8:  ADDWF  x29,W
08EA:  MOVWF  FE9
08EC:  MOVF   x26,W
08EE:  ADDWFC x2A,W
08F0:  MOVWF  FEA
08F2:  MOVF   FEF,W
08F4:  XORWF  x28,F
08F6:  MOVLW  02
08F8:  ADDWF  x23,W
08FA:  MOVWF  x2B
08FC:  MOVLW  00
08FE:  ADDWFC x24,W
0900:  MOVWF  x2C
0902:  MOVF   x25,W
0904:  ADDWF  x2B,W
0906:  MOVWF  FE9
0908:  MOVF   x26,W
090A:  ADDWFC x2C,W
090C:  MOVWF  FEA
090E:  MOVF   FEF,W
0910:  XORWF  x28,F
0912:  MOVLW  03
0914:  ADDWF  x23,W
0916:  MOVWF  x2D
0918:  MOVLW  00
091A:  ADDWFC x24,W
091C:  MOVWF  x2E
091E:  MOVF   x25,W
0920:  ADDWF  x2D,W
0922:  MOVWF  FE9
0924:  MOVF   x26,W
0926:  ADDWFC x2E,W
0928:  MOVWF  FEA
092A:  MOVF   FEF,W
092C:  XORWF  x28,W
092E:  BZ    0934
0930:  MOVLW  00
0932:  BRA    0936
0934:  MOVLW  01
0936:  MOVWF  x27
....................       if(temp==datain[offset+4]) return 1; 
0938:  MOVLW  04
093A:  ADDWF  x23,W
093C:  MOVWF  x28
093E:  MOVLW  00
0940:  ADDWFC x24,W
0942:  MOVWF  x29
0944:  MOVF   x25,W
0946:  ADDWF  x28,W
0948:  MOVWF  FE9
094A:  MOVF   x26,W
094C:  ADDWFC x29,W
094E:  MOVWF  FEA
0950:  MOVF   FEF,W
0952:  SUBWF  x27,W
0954:  BNZ   095E
0956:  MOVLW  01
0958:  MOVWF  01
095A:  BRA    09FE
....................          else return 0; 
095C:  BRA    0964
095E:  MOVLW  00
0960:  MOVWF  01
0962:  BRA    09FE
....................    } 
....................    else 
0964:  BRA    09FE
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0966:  MOVF   x25,W
0968:  ADDWF  x23,W
096A:  MOVWF  FE9
096C:  MOVF   x26,W
096E:  ADDWFC x24,W
0970:  MOVWF  FEA
0972:  MOVFF  FEF,928
0976:  MOVLW  01
0978:  SUBWF  x23,W
097A:  MOVWF  x29
097C:  MOVLW  00
097E:  SUBWFB x24,W
0980:  MOVWF  x2A
0982:  MOVF   x25,W
0984:  ADDWF  x29,W
0986:  MOVWF  FE9
0988:  MOVF   x26,W
098A:  ADDWFC x2A,W
098C:  MOVWF  FEA
098E:  MOVF   FEF,W
0990:  XORWF  x28,F
0992:  MOVLW  02
0994:  SUBWF  x23,W
0996:  MOVWF  x2B
0998:  MOVLW  00
099A:  SUBWFB x24,W
099C:  MOVWF  x2C
099E:  MOVF   x25,W
09A0:  ADDWF  x2B,W
09A2:  MOVWF  FE9
09A4:  MOVF   x26,W
09A6:  ADDWFC x2C,W
09A8:  MOVWF  FEA
09AA:  MOVF   FEF,W
09AC:  XORWF  x28,F
09AE:  MOVLW  03
09B0:  SUBWF  x23,W
09B2:  MOVWF  x2D
09B4:  MOVLW  00
09B6:  SUBWFB x24,W
09B8:  MOVWF  x2E
09BA:  MOVF   x25,W
09BC:  ADDWF  x2D,W
09BE:  MOVWF  FE9
09C0:  MOVF   x26,W
09C2:  ADDWFC x2E,W
09C4:  MOVWF  FEA
09C6:  MOVF   FEF,W
09C8:  XORWF  x28,W
09CA:  BZ    09D0
09CC:  MOVLW  00
09CE:  BRA    09D2
09D0:  MOVLW  01
09D2:  MOVWF  x27
....................       if(temp==datain[offset-4]) return 1; 
09D4:  MOVLW  04
09D6:  SUBWF  x23,W
09D8:  MOVWF  x28
09DA:  MOVLW  00
09DC:  SUBWFB x24,W
09DE:  MOVWF  x29
09E0:  MOVF   x25,W
09E2:  ADDWF  x28,W
09E4:  MOVWF  FE9
09E6:  MOVF   x26,W
09E8:  ADDWFC x29,W
09EA:  MOVWF  FEA
09EC:  MOVF   FEF,W
09EE:  SUBWF  x27,W
09F0:  BNZ   09FA
09F2:  MOVLW  01
09F4:  MOVWF  01
09F6:  BRA    09FE
....................          else return 0;                
09F8:  BRA    09FE
09FA:  MOVLW  00
09FC:  MOVWF  01
....................    } 
.................... } 
09FE:  MOVLB  0
0A00:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0A02:  MOVLB  9
0A04:  CLRF   x1E
0A06:  CLRF   x1F
0A08:  CLRF   x20
0A0A:  CLRF   x21
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0A0C:  CLRF   x1B
0A0E:  CLRF   x1A
0A10:  RRCF   x17,W
0A12:  MOVWF  03
0A14:  RRCF   x16,W
0A16:  MOVWF  02
0A18:  RRCF   03,F
0A1A:  RRCF   02,F
0A1C:  MOVLW  3F
0A1E:  ANDWF  03,F
0A20:  MOVFF  02,01
0A24:  MOVF   x1B,W
0A26:  SUBWF  03,W
0A28:  BTFSS  FD8.0
0A2A:  BRA    0FEA
0A2C:  BNZ   0A36
0A2E:  MOVF   01,W
0A30:  SUBWF  x1A,W
0A32:  BTFSC  FD8.0
0A34:  BRA    0FEA
....................    { 
....................       if(track==0) 
0A36:  MOVF   x15,F
0A38:  BTFSS  FD8.2
0A3A:  BRA    0D70
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0A3C:  MOVLW  06
0A3E:  ADDWF  x1A,W
0A40:  MOVWF  x22
0A42:  MOVLW  00
0A44:  ADDWFC x1B,W
0A46:  MOVWF  x23
0A48:  MOVF   x18,W
0A4A:  ADDWF  x22,W
0A4C:  MOVWF  FE9
0A4E:  MOVF   x19,W
0A50:  ADDWFC x23,W
0A52:  MOVWF  FEA
0A54:  MOVFF  FEF,924
0A58:  MOVLW  05
0A5A:  ADDWF  x1A,W
0A5C:  MOVWF  x25
0A5E:  MOVLW  00
0A60:  ADDWFC x1B,W
0A62:  MOVWF  x26
0A64:  MOVF   x18,W
0A66:  ADDWF  x25,W
0A68:  MOVWF  FE9
0A6A:  MOVF   x19,W
0A6C:  ADDWFC x26,W
0A6E:  MOVWF  FEA
0A70:  MOVFF  FEF,927
0A74:  MOVLW  04
0A76:  ADDWF  x1A,W
0A78:  MOVWF  x28
0A7A:  MOVLW  00
0A7C:  ADDWFC x1B,W
0A7E:  MOVWF  x29
0A80:  MOVF   x18,W
0A82:  ADDWF  x28,W
0A84:  MOVWF  FE9
0A86:  MOVF   x19,W
0A88:  ADDWFC x29,W
0A8A:  MOVWF  FEA
0A8C:  MOVFF  FEF,92A
0A90:  MOVLW  03
0A92:  ADDWF  x1A,W
0A94:  MOVWF  x2B
0A96:  MOVLW  00
0A98:  ADDWFC x1B,W
0A9A:  MOVWF  x2C
0A9C:  MOVF   x18,W
0A9E:  ADDWF  x2B,W
0AA0:  MOVWF  FE9
0AA2:  MOVF   x19,W
0AA4:  ADDWFC x2C,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEF,92D
0AAC:  MOVLW  02
0AAE:  ADDWF  x1A,W
0AB0:  MOVWF  x2E
0AB2:  MOVLW  00
0AB4:  ADDWFC x1B,W
0AB6:  MOVWF  x2F
0AB8:  MOVF   x18,W
0ABA:  ADDWF  x2E,W
0ABC:  MOVWF  FE9
0ABE:  MOVF   x19,W
0AC0:  ADDWFC x2F,W
0AC2:  MOVWF  FEA
0AC4:  MOVFF  FEF,930
0AC8:  MOVLW  01
0ACA:  ADDWF  x1A,W
0ACC:  MOVWF  x31
0ACE:  MOVLW  00
0AD0:  ADDWFC x1B,W
0AD2:  MOVWF  x32
0AD4:  MOVF   x18,W
0AD6:  ADDWF  x31,W
0AD8:  MOVWF  FE9
0ADA:  MOVF   x19,W
0ADC:  ADDWFC x32,W
0ADE:  MOVWF  FEA
0AE0:  MOVFF  FEF,933
0AE4:  MOVF   x18,W
0AE6:  ADDWF  x1A,W
0AE8:  MOVWF  FE9
0AEA:  MOVF   x19,W
0AEC:  ADDWFC x1B,W
0AEE:  MOVWF  FEA
0AF0:  MOVFF  FEF,934
0AF4:  CLRF   x37
0AF6:  MOVFF  924,938
0AFA:  MOVFF  927,939
0AFE:  MOVFF  92A,93A
0B02:  MOVFF  92D,93B
0B06:  MOVFF  930,93C
0B0A:  MOVFF  933,93D
0B0E:  MOVFF  934,93E
0B12:  MOVLB  0
0B14:  RCALL  06AC
0B16:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0B1A:  MOVLW  0D
0B1C:  MOVLB  9
0B1E:  ADDWF  x1A,W
0B20:  MOVWF  x22
0B22:  MOVLW  00
0B24:  ADDWFC x1B,W
0B26:  MOVWF  x23
0B28:  MOVF   x18,W
0B2A:  ADDWF  x22,W
0B2C:  MOVWF  FE9
0B2E:  MOVF   x19,W
0B30:  ADDWFC x23,W
0B32:  MOVWF  FEA
0B34:  MOVFF  FEF,924
0B38:  MOVLW  0C
0B3A:  ADDWF  x1A,W
0B3C:  MOVWF  x25
0B3E:  MOVLW  00
0B40:  ADDWFC x1B,W
0B42:  MOVWF  x26
0B44:  MOVF   x18,W
0B46:  ADDWF  x25,W
0B48:  MOVWF  FE9
0B4A:  MOVF   x19,W
0B4C:  ADDWFC x26,W
0B4E:  MOVWF  FEA
0B50:  MOVFF  FEF,927
0B54:  MOVLW  0B
0B56:  ADDWF  x1A,W
0B58:  MOVWF  x28
0B5A:  MOVLW  00
0B5C:  ADDWFC x1B,W
0B5E:  MOVWF  x29
0B60:  MOVF   x18,W
0B62:  ADDWF  x28,W
0B64:  MOVWF  FE9
0B66:  MOVF   x19,W
0B68:  ADDWFC x29,W
0B6A:  MOVWF  FEA
0B6C:  MOVFF  FEF,92A
0B70:  MOVLW  0A
0B72:  ADDWF  x1A,W
0B74:  MOVWF  x2B
0B76:  MOVLW  00
0B78:  ADDWFC x1B,W
0B7A:  MOVWF  x2C
0B7C:  MOVF   x18,W
0B7E:  ADDWF  x2B,W
0B80:  MOVWF  FE9
0B82:  MOVF   x19,W
0B84:  ADDWFC x2C,W
0B86:  MOVWF  FEA
0B88:  MOVFF  FEF,92D
0B8C:  MOVLW  09
0B8E:  ADDWF  x1A,W
0B90:  MOVWF  x2E
0B92:  MOVLW  00
0B94:  ADDWFC x1B,W
0B96:  MOVWF  x2F
0B98:  MOVF   x18,W
0B9A:  ADDWF  x2E,W
0B9C:  MOVWF  FE9
0B9E:  MOVF   x19,W
0BA0:  ADDWFC x2F,W
0BA2:  MOVWF  FEA
0BA4:  MOVFF  FEF,930
0BA8:  MOVLW  08
0BAA:  ADDWF  x1A,W
0BAC:  MOVWF  x31
0BAE:  MOVLW  00
0BB0:  ADDWFC x1B,W
0BB2:  MOVWF  x32
0BB4:  MOVF   x18,W
0BB6:  ADDWF  x31,W
0BB8:  MOVWF  FE9
0BBA:  MOVF   x19,W
0BBC:  ADDWFC x32,W
0BBE:  MOVWF  FEA
0BC0:  MOVFF  FEF,933
0BC4:  MOVLW  07
0BC6:  ADDWF  x1A,W
0BC8:  MOVWF  x34
0BCA:  MOVLW  00
0BCC:  ADDWFC x1B,W
0BCE:  MOVWF  x35
0BD0:  MOVF   x18,W
0BD2:  ADDWF  x34,W
0BD4:  MOVWF  FE9
0BD6:  MOVF   x19,W
0BD8:  ADDWFC x35,W
0BDA:  MOVWF  FEA
0BDC:  MOVFF  FEF,936
0BE0:  CLRF   x37
0BE2:  MOVFF  924,938
0BE6:  MOVFF  927,939
0BEA:  MOVFF  92A,93A
0BEE:  MOVFF  92D,93B
0BF2:  MOVFF  930,93C
0BF6:  MOVFF  933,93D
0BFA:  MOVFF  936,93E
0BFE:  MOVLB  0
0C00:  RCALL  06AC
0C02:  MOVFF  01,91F
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0C06:  MOVLB  9
0C08:  MOVF   x1E,W
0C0A:  SUBLW  45
0C0C:  BTFSS  FD8.2
0C0E:  BRA    0D6E
0C10:  MOVF   x1F,W
0C12:  SUBLW  7C
0C14:  BTFSC  FD8.2
0C16:  BRA    0D6E
0C18:  MOVF   x1F,W
0C1A:  SUBLW  3E
0C1C:  BTFSC  FD8.2
0C1E:  BRA    0D6E
0C20:  MOVF   x1F,W
0C22:  SUBLW  1F
0C24:  BTFSC  FD8.2
0C26:  BRA    0D6E
....................          { 
....................             j=i; 
0C28:  MOVFF  91B,91D
0C2C:  MOVFF  91A,91C
....................             CRC=1; 
0C30:  MOVLW  01
0C32:  MOVWF  x21
....................             temp2=temp; 
0C34:  MOVFF  91E,920
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0C38:  MOVF   x20,W
0C3A:  SUBLW  1F
0C3C:  BTFSC  FD8.2
0C3E:  BRA    0D58
0C40:  MOVF   x1D,W
0C42:  SUBLW  03
0C44:  BTFSS  FD8.0
0C46:  BRA    0D58
0C48:  BNZ   0C52
0C4A:  MOVF   x1C,W
0C4C:  SUBLW  E7
0C4E:  BTFSS  FD8.0
0C50:  BRA    0D58
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C52:  CLRF   x22
0C54:  MOVFF  91D,924
0C58:  MOVFF  91C,923
0C5C:  MOVFF  919,926
0C60:  MOVFF  918,925
0C64:  MOVLB  0
0C66:  RCALL  0712
0C68:  MOVF   01,W
0C6A:  MOVLB  9
0C6C:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C6E:  MOVLW  06
0C70:  ADDWF  x1C,W
0C72:  MOVWF  x22
0C74:  MOVLW  00
0C76:  ADDWFC x1D,W
0C78:  MOVWF  x23
0C7A:  MOVF   x18,W
0C7C:  ADDWF  x22,W
0C7E:  MOVWF  FE9
0C80:  MOVF   x19,W
0C82:  ADDWFC x23,W
0C84:  MOVWF  FEA
0C86:  MOVFF  FEF,924
0C8A:  MOVLW  05
0C8C:  ADDWF  x1C,W
0C8E:  MOVWF  x25
0C90:  MOVLW  00
0C92:  ADDWFC x1D,W
0C94:  MOVWF  x26
0C96:  MOVF   x18,W
0C98:  ADDWF  x25,W
0C9A:  MOVWF  FE9
0C9C:  MOVF   x19,W
0C9E:  ADDWFC x26,W
0CA0:  MOVWF  FEA
0CA2:  MOVFF  FEF,927
0CA6:  MOVLW  04
0CA8:  ADDWF  x1C,W
0CAA:  MOVWF  x28
0CAC:  MOVLW  00
0CAE:  ADDWFC x1D,W
0CB0:  MOVWF  x29
0CB2:  MOVF   x18,W
0CB4:  ADDWF  x28,W
0CB6:  MOVWF  FE9
0CB8:  MOVF   x19,W
0CBA:  ADDWFC x29,W
0CBC:  MOVWF  FEA
0CBE:  MOVFF  FEF,92A
0CC2:  MOVLW  03
0CC4:  ADDWF  x1C,W
0CC6:  MOVWF  x2B
0CC8:  MOVLW  00
0CCA:  ADDWFC x1D,W
0CCC:  MOVWF  x2C
0CCE:  MOVF   x18,W
0CD0:  ADDWF  x2B,W
0CD2:  MOVWF  FE9
0CD4:  MOVF   x19,W
0CD6:  ADDWFC x2C,W
0CD8:  MOVWF  FEA
0CDA:  MOVFF  FEF,92D
0CDE:  MOVLW  02
0CE0:  ADDWF  x1C,W
0CE2:  MOVWF  x2E
0CE4:  MOVLW  00
0CE6:  ADDWFC x1D,W
0CE8:  MOVWF  x2F
0CEA:  MOVF   x18,W
0CEC:  ADDWF  x2E,W
0CEE:  MOVWF  FE9
0CF0:  MOVF   x19,W
0CF2:  ADDWFC x2F,W
0CF4:  MOVWF  FEA
0CF6:  MOVFF  FEF,930
0CFA:  MOVLW  01
0CFC:  ADDWF  x1C,W
0CFE:  MOVWF  x31
0D00:  MOVLW  00
0D02:  ADDWFC x1D,W
0D04:  MOVWF  x32
0D06:  MOVF   x18,W
0D08:  ADDWF  x31,W
0D0A:  MOVWF  FE9
0D0C:  MOVF   x19,W
0D0E:  ADDWFC x32,W
0D10:  MOVWF  FEA
0D12:  MOVFF  FEF,933
0D16:  MOVF   x18,W
0D18:  ADDWF  x1C,W
0D1A:  MOVWF  FE9
0D1C:  MOVF   x19,W
0D1E:  ADDWFC x1D,W
0D20:  MOVWF  FEA
0D22:  MOVFF  FEF,934
0D26:  CLRF   x37
0D28:  MOVFF  924,938
0D2C:  MOVFF  927,939
0D30:  MOVFF  92A,93A
0D34:  MOVFF  92D,93B
0D38:  MOVFF  930,93C
0D3C:  MOVFF  933,93D
0D40:  MOVFF  934,93E
0D44:  MOVLB  0
0D46:  RCALL  06AC
0D48:  MOVFF  01,920
....................                j=j+7; 
0D4C:  MOVLW  07
0D4E:  MOVLB  9
0D50:  ADDWF  x1C,F
0D52:  MOVLW  00
0D54:  ADDWFC x1D,F
....................             } 
0D56:  BRA    0C38
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D58:  DECFSZ x21,W
0D5A:  BRA    0D6E
....................             { 
....................                dir=0; 
0D5C:  MOVLB  6
0D5E:  CLRF   xC8
....................                return i; 
0D60:  MOVLB  9
0D62:  MOVFF  91A,01
0D66:  MOVFF  91B,02
0D6A:  GOTO   1600
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0D6E:  BRA    0FE2
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0D70:  MOVLW  04
0D72:  ADDWF  x1A,W
0D74:  MOVWF  x22
0D76:  MOVLW  00
0D78:  ADDWFC x1B,W
0D7A:  MOVWF  x23
0D7C:  MOVF   x18,W
0D7E:  ADDWF  x22,W
0D80:  MOVWF  FE9
0D82:  MOVF   x19,W
0D84:  ADDWFC x23,W
0D86:  MOVWF  FEA
0D88:  MOVFF  FEF,924
0D8C:  MOVLW  03
0D8E:  ADDWF  x1A,W
0D90:  MOVWF  x25
0D92:  MOVLW  00
0D94:  ADDWFC x1B,W
0D96:  MOVWF  x26
0D98:  MOVF   x18,W
0D9A:  ADDWF  x25,W
0D9C:  MOVWF  FE9
0D9E:  MOVF   x19,W
0DA0:  ADDWFC x26,W
0DA2:  MOVWF  FEA
0DA4:  MOVFF  FEF,927
0DA8:  MOVLW  02
0DAA:  ADDWF  x1A,W
0DAC:  MOVWF  x28
0DAE:  MOVLW  00
0DB0:  ADDWFC x1B,W
0DB2:  MOVWF  x29
0DB4:  MOVF   x18,W
0DB6:  ADDWF  x28,W
0DB8:  MOVWF  FE9
0DBA:  MOVF   x19,W
0DBC:  ADDWFC x29,W
0DBE:  MOVWF  FEA
0DC0:  MOVFF  FEF,92A
0DC4:  MOVLW  01
0DC6:  ADDWF  x1A,W
0DC8:  MOVWF  x2B
0DCA:  MOVLW  00
0DCC:  ADDWFC x1B,W
0DCE:  MOVWF  x2C
0DD0:  MOVF   x18,W
0DD2:  ADDWF  x2B,W
0DD4:  MOVWF  FE9
0DD6:  MOVF   x19,W
0DD8:  ADDWFC x2C,W
0DDA:  MOVWF  FEA
0DDC:  MOVFF  FEF,92D
0DE0:  MOVF   x18,W
0DE2:  ADDWF  x1A,W
0DE4:  MOVWF  FE9
0DE6:  MOVF   x19,W
0DE8:  ADDWFC x1B,W
0DEA:  MOVWF  FEA
0DEC:  MOVFF  FEF,92E
0DF0:  CLRF   x37
0DF2:  CLRF   x38
0DF4:  CLRF   x39
0DF6:  MOVFF  924,93A
0DFA:  MOVFF  927,93B
0DFE:  MOVFF  92A,93C
0E02:  MOVFF  92D,93D
0E06:  MOVFF  92E,93E
0E0A:  MOVLB  0
0E0C:  RCALL  06AC
0E0E:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0E12:  MOVLW  09
0E14:  MOVLB  9
0E16:  ADDWF  x1A,W
0E18:  MOVWF  x22
0E1A:  MOVLW  00
0E1C:  ADDWFC x1B,W
0E1E:  MOVWF  x23
0E20:  MOVF   x18,W
0E22:  ADDWF  x22,W
0E24:  MOVWF  FE9
0E26:  MOVF   x19,W
0E28:  ADDWFC x23,W
0E2A:  MOVWF  FEA
0E2C:  MOVFF  FEF,924
0E30:  MOVLW  08
0E32:  ADDWF  x1A,W
0E34:  MOVWF  x25
0E36:  MOVLW  00
0E38:  ADDWFC x1B,W
0E3A:  MOVWF  x26
0E3C:  MOVF   x18,W
0E3E:  ADDWF  x25,W
0E40:  MOVWF  FE9
0E42:  MOVF   x19,W
0E44:  ADDWFC x26,W
0E46:  MOVWF  FEA
0E48:  MOVFF  FEF,927
0E4C:  MOVLW  07
0E4E:  ADDWF  x1A,W
0E50:  MOVWF  x28
0E52:  MOVLW  00
0E54:  ADDWFC x1B,W
0E56:  MOVWF  x29
0E58:  MOVF   x18,W
0E5A:  ADDWF  x28,W
0E5C:  MOVWF  FE9
0E5E:  MOVF   x19,W
0E60:  ADDWFC x29,W
0E62:  MOVWF  FEA
0E64:  MOVFF  FEF,92A
0E68:  MOVLW  06
0E6A:  ADDWF  x1A,W
0E6C:  MOVWF  x2B
0E6E:  MOVLW  00
0E70:  ADDWFC x1B,W
0E72:  MOVWF  x2C
0E74:  MOVF   x18,W
0E76:  ADDWF  x2B,W
0E78:  MOVWF  FE9
0E7A:  MOVF   x19,W
0E7C:  ADDWFC x2C,W
0E7E:  MOVWF  FEA
0E80:  MOVFF  FEF,92D
0E84:  MOVLW  05
0E86:  ADDWF  x1A,W
0E88:  MOVWF  x2E
0E8A:  MOVLW  00
0E8C:  ADDWFC x1B,W
0E8E:  MOVWF  x2F
0E90:  MOVF   x18,W
0E92:  ADDWF  x2E,W
0E94:  MOVWF  FE9
0E96:  MOVF   x19,W
0E98:  ADDWFC x2F,W
0E9A:  MOVWF  FEA
0E9C:  MOVFF  FEF,930
0EA0:  CLRF   x37
0EA2:  CLRF   x38
0EA4:  CLRF   x39
0EA6:  MOVFF  924,93A
0EAA:  MOVFF  927,93B
0EAE:  MOVFF  92A,93C
0EB2:  MOVFF  92D,93D
0EB6:  MOVFF  930,93E
0EBA:  MOVLB  0
0EBC:  CALL   06AC
0EC0:  MOVFF  01,91F
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0EC4:  MOVLB  9
0EC6:  MOVF   x1E,W
0EC8:  SUBLW  0B
0ECA:  BTFSS  FD8.2
0ECC:  BRA    0FE2
0ECE:  MOVF   x1F,W
0ED0:  SUBLW  1F
0ED2:  BTFSC  FD8.2
0ED4:  BRA    0FE2
0ED6:  MOVF   x1F,W
0ED8:  SUBLW  0F
0EDA:  BTFSC  FD8.2
0EDC:  BRA    0FE2
....................             { 
....................                j=i; 
0EDE:  MOVFF  91B,91D
0EE2:  MOVFF  91A,91C
....................                CRC=1; 
0EE6:  MOVLW  01
0EE8:  MOVWF  x21
....................                temp2=temp; 
0EEA:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0EEE:  MOVF   x20,W
0EF0:  SUBLW  1F
0EF2:  BZ    0FCE
0EF4:  MOVF   x1D,W
0EF6:  SUBLW  01
0EF8:  BNC   0FCE
0EFA:  BNZ   0F02
0EFC:  MOVF   x1C,W
0EFE:  SUBLW  F3
0F00:  BNC   0FCE
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0F02:  CLRF   x22
0F04:  MOVFF  91D,924
0F08:  MOVFF  91C,923
0F0C:  MOVFF  919,926
0F10:  MOVFF  918,925
0F14:  MOVLB  0
0F16:  RCALL  08C2
0F18:  MOVF   01,W
0F1A:  MOVLB  9
0F1C:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0F1E:  MOVLW  04
0F20:  ADDWF  x1C,W
0F22:  MOVWF  x22
0F24:  MOVLW  00
0F26:  ADDWFC x1D,W
0F28:  MOVWF  x23
0F2A:  MOVF   x18,W
0F2C:  ADDWF  x22,W
0F2E:  MOVWF  FE9
0F30:  MOVF   x19,W
0F32:  ADDWFC x23,W
0F34:  MOVWF  FEA
0F36:  MOVFF  FEF,924
0F3A:  MOVLW  03
0F3C:  ADDWF  x1C,W
0F3E:  MOVWF  x25
0F40:  MOVLW  00
0F42:  ADDWFC x1D,W
0F44:  MOVWF  x26
0F46:  MOVF   x18,W
0F48:  ADDWF  x25,W
0F4A:  MOVWF  FE9
0F4C:  MOVF   x19,W
0F4E:  ADDWFC x26,W
0F50:  MOVWF  FEA
0F52:  MOVFF  FEF,927
0F56:  MOVLW  02
0F58:  ADDWF  x1C,W
0F5A:  MOVWF  x28
0F5C:  MOVLW  00
0F5E:  ADDWFC x1D,W
0F60:  MOVWF  x29
0F62:  MOVF   x18,W
0F64:  ADDWF  x28,W
0F66:  MOVWF  FE9
0F68:  MOVF   x19,W
0F6A:  ADDWFC x29,W
0F6C:  MOVWF  FEA
0F6E:  MOVFF  FEF,92A
0F72:  MOVLW  01
0F74:  ADDWF  x1C,W
0F76:  MOVWF  x2B
0F78:  MOVLW  00
0F7A:  ADDWFC x1D,W
0F7C:  MOVWF  x2C
0F7E:  MOVF   x18,W
0F80:  ADDWF  x2B,W
0F82:  MOVWF  FE9
0F84:  MOVF   x19,W
0F86:  ADDWFC x2C,W
0F88:  MOVWF  FEA
0F8A:  MOVFF  FEF,92D
0F8E:  MOVF   x18,W
0F90:  ADDWF  x1C,W
0F92:  MOVWF  FE9
0F94:  MOVF   x19,W
0F96:  ADDWFC x1D,W
0F98:  MOVWF  FEA
0F9A:  MOVFF  FEF,92E
0F9E:  CLRF   x37
0FA0:  CLRF   x38
0FA2:  CLRF   x39
0FA4:  MOVFF  924,93A
0FA8:  MOVFF  927,93B
0FAC:  MOVFF  92A,93C
0FB0:  MOVFF  92D,93D
0FB4:  MOVFF  92E,93E
0FB8:  MOVLB  0
0FBA:  CALL   06AC
0FBE:  MOVFF  01,920
....................                   j=j+5; 
0FC2:  MOVLW  05
0FC4:  MOVLB  9
0FC6:  ADDWF  x1C,F
0FC8:  MOVLW  00
0FCA:  ADDWFC x1D,F
....................                } 
0FCC:  BRA    0EEE
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0FCE:  DECFSZ x21,W
0FD0:  BRA    0FE2
....................                { 
....................                   dir=0; 
0FD2:  MOVLB  6
0FD4:  CLRF   xC8
....................                   return i; 
0FD6:  MOVLB  9
0FD8:  MOVFF  91A,01
0FDC:  MOVFF  91B,02
0FE0:  BRA    1600
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0FE2:  INCF   x1A,F
0FE4:  BTFSC  FD8.2
0FE6:  INCF   x1B,F
0FE8:  BRA    0A10
....................    for(i=end_point;i>end_point/4;i--) 
0FEA:  MOVFF  917,91B
0FEE:  MOVFF  916,91A
0FF2:  RRCF   x17,W
0FF4:  MOVWF  03
0FF6:  RRCF   x16,W
0FF8:  MOVWF  02
0FFA:  RRCF   03,F
0FFC:  RRCF   02,F
0FFE:  MOVLW  3F
1000:  ANDWF  03,F
1002:  MOVFF  02,01
1006:  MOVF   03,W
1008:  SUBWF  x1B,W
100A:  BTFSS  FD8.0
100C:  BRA    15FA
100E:  BNZ   1018
1010:  MOVF   x1A,W
1012:  SUBWF  01,W
1014:  BTFSC  FD8.0
1016:  BRA    15FA
....................    { 
....................       if(track==0) 
1018:  MOVF   x15,F
101A:  BTFSS  FD8.2
101C:  BRA    1370
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
101E:  MOVLW  06
1020:  SUBWF  x1A,W
1022:  MOVWF  x22
1024:  MOVLW  00
1026:  SUBWFB x1B,W
1028:  MOVWF  x23
102A:  MOVF   x18,W
102C:  ADDWF  x22,W
102E:  MOVWF  FE9
1030:  MOVF   x19,W
1032:  ADDWFC x23,W
1034:  MOVWF  FEA
1036:  MOVFF  FEF,924
103A:  MOVLW  05
103C:  SUBWF  x1A,W
103E:  MOVWF  x25
1040:  MOVLW  00
1042:  SUBWFB x1B,W
1044:  MOVWF  x26
1046:  MOVF   x18,W
1048:  ADDWF  x25,W
104A:  MOVWF  FE9
104C:  MOVF   x19,W
104E:  ADDWFC x26,W
1050:  MOVWF  FEA
1052:  MOVFF  FEF,927
1056:  MOVLW  04
1058:  SUBWF  x1A,W
105A:  MOVWF  x28
105C:  MOVLW  00
105E:  SUBWFB x1B,W
1060:  MOVWF  x29
1062:  MOVF   x18,W
1064:  ADDWF  x28,W
1066:  MOVWF  FE9
1068:  MOVF   x19,W
106A:  ADDWFC x29,W
106C:  MOVWF  FEA
106E:  MOVFF  FEF,92A
1072:  MOVLW  03
1074:  SUBWF  x1A,W
1076:  MOVWF  x2B
1078:  MOVLW  00
107A:  SUBWFB x1B,W
107C:  MOVWF  x2C
107E:  MOVF   x18,W
1080:  ADDWF  x2B,W
1082:  MOVWF  FE9
1084:  MOVF   x19,W
1086:  ADDWFC x2C,W
1088:  MOVWF  FEA
108A:  MOVFF  FEF,92D
108E:  MOVLW  02
1090:  SUBWF  x1A,W
1092:  MOVWF  x2E
1094:  MOVLW  00
1096:  SUBWFB x1B,W
1098:  MOVWF  x2F
109A:  MOVF   x18,W
109C:  ADDWF  x2E,W
109E:  MOVWF  FE9
10A0:  MOVF   x19,W
10A2:  ADDWFC x2F,W
10A4:  MOVWF  FEA
10A6:  MOVFF  FEF,930
10AA:  MOVLW  01
10AC:  SUBWF  x1A,W
10AE:  MOVWF  x31
10B0:  MOVLW  00
10B2:  SUBWFB x1B,W
10B4:  MOVWF  x32
10B6:  MOVF   x18,W
10B8:  ADDWF  x31,W
10BA:  MOVWF  FE9
10BC:  MOVF   x19,W
10BE:  ADDWFC x32,W
10C0:  MOVWF  FEA
10C2:  MOVFF  FEF,933
10C6:  MOVF   x18,W
10C8:  ADDWF  x1A,W
10CA:  MOVWF  FE9
10CC:  MOVF   x19,W
10CE:  ADDWFC x1B,W
10D0:  MOVWF  FEA
10D2:  MOVFF  FEF,934
10D6:  CLRF   x37
10D8:  MOVFF  924,938
10DC:  MOVFF  927,939
10E0:  MOVFF  92A,93A
10E4:  MOVFF  92D,93B
10E8:  MOVFF  930,93C
10EC:  MOVFF  933,93D
10F0:  MOVFF  934,93E
10F4:  MOVLB  0
10F6:  CALL   06AC
10FA:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
10FE:  MOVLW  0D
1100:  MOVLB  9
1102:  SUBWF  x1A,W
1104:  MOVWF  x22
1106:  MOVLW  00
1108:  SUBWFB x1B,W
110A:  MOVWF  x23
110C:  MOVF   x18,W
110E:  ADDWF  x22,W
1110:  MOVWF  FE9
1112:  MOVF   x19,W
1114:  ADDWFC x23,W
1116:  MOVWF  FEA
1118:  MOVFF  FEF,924
111C:  MOVLW  0C
111E:  SUBWF  x1A,W
1120:  MOVWF  x25
1122:  MOVLW  00
1124:  SUBWFB x1B,W
1126:  MOVWF  x26
1128:  MOVF   x18,W
112A:  ADDWF  x25,W
112C:  MOVWF  FE9
112E:  MOVF   x19,W
1130:  ADDWFC x26,W
1132:  MOVWF  FEA
1134:  MOVFF  FEF,927
1138:  MOVLW  0B
113A:  SUBWF  x1A,W
113C:  MOVWF  x28
113E:  MOVLW  00
1140:  SUBWFB x1B,W
1142:  MOVWF  x29
1144:  MOVF   x18,W
1146:  ADDWF  x28,W
1148:  MOVWF  FE9
114A:  MOVF   x19,W
114C:  ADDWFC x29,W
114E:  MOVWF  FEA
1150:  MOVFF  FEF,92A
1154:  MOVLW  0A
1156:  SUBWF  x1A,W
1158:  MOVWF  x2B
115A:  MOVLW  00
115C:  SUBWFB x1B,W
115E:  MOVWF  x2C
1160:  MOVF   x18,W
1162:  ADDWF  x2B,W
1164:  MOVWF  FE9
1166:  MOVF   x19,W
1168:  ADDWFC x2C,W
116A:  MOVWF  FEA
116C:  MOVFF  FEF,92D
1170:  MOVLW  09
1172:  SUBWF  x1A,W
1174:  MOVWF  x2E
1176:  MOVLW  00
1178:  SUBWFB x1B,W
117A:  MOVWF  x2F
117C:  MOVF   x18,W
117E:  ADDWF  x2E,W
1180:  MOVWF  FE9
1182:  MOVF   x19,W
1184:  ADDWFC x2F,W
1186:  MOVWF  FEA
1188:  MOVFF  FEF,930
118C:  MOVLW  08
118E:  SUBWF  x1A,W
1190:  MOVWF  x31
1192:  MOVLW  00
1194:  SUBWFB x1B,W
1196:  MOVWF  x32
1198:  MOVF   x18,W
119A:  ADDWF  x31,W
119C:  MOVWF  FE9
119E:  MOVF   x19,W
11A0:  ADDWFC x32,W
11A2:  MOVWF  FEA
11A4:  MOVFF  FEF,933
11A8:  MOVLW  07
11AA:  SUBWF  x1A,W
11AC:  MOVWF  x34
11AE:  MOVLW  00
11B0:  SUBWFB x1B,W
11B2:  MOVWF  x35
11B4:  MOVF   x18,W
11B6:  ADDWF  x34,W
11B8:  MOVWF  FE9
11BA:  MOVF   x19,W
11BC:  ADDWFC x35,W
11BE:  MOVWF  FEA
11C0:  MOVFF  FEF,936
11C4:  CLRF   x37
11C6:  MOVFF  924,938
11CA:  MOVFF  927,939
11CE:  MOVFF  92A,93A
11D2:  MOVFF  92D,93B
11D6:  MOVFF  930,93C
11DA:  MOVFF  933,93D
11DE:  MOVFF  936,93E
11E2:  MOVLB  0
11E4:  CALL   06AC
11E8:  MOVFF  01,91F
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
11EC:  MOVLB  9
11EE:  MOVF   x1E,W
11F0:  SUBLW  45
11F2:  BTFSS  FD8.2
11F4:  BRA    136E
11F6:  MOVF   x1F,W
11F8:  SUBLW  7C
11FA:  BTFSC  FD8.2
11FC:  BRA    136E
11FE:  MOVF   x1F,W
1200:  SUBLW  3E
1202:  BTFSC  FD8.2
1204:  BRA    136E
1206:  MOVF   x1F,W
1208:  SUBLW  1F
120A:  BTFSC  FD8.2
120C:  BRA    136E
120E:  MOVF   x1F,W
1210:  SUBLW  0F
1212:  BTFSC  FD8.2
1214:  BRA    136E
1216:  MOVF   x1F,W
1218:  SUBLW  78
121A:  BTFSC  FD8.2
121C:  BRA    136E
....................          { 
....................             j=i; 
121E:  MOVFF  91B,91D
1222:  MOVFF  91A,91C
....................             CRC=1; 
1226:  MOVLW  01
1228:  MOVWF  x21
....................             temp2=temp; 
122A:  MOVFF  91E,920
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
122E:  MOVF   x20,W
1230:  SUBLW  1F
1232:  BTFSC  FD8.2
1234:  BRA    134E
1236:  MOVF   x1D,F
1238:  BNZ   1242
123A:  MOVF   x1C,W
123C:  SUBLW  01
123E:  BTFSC  FD8.0
1240:  BRA    134E
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1242:  MOVLW  01
1244:  MOVWF  x22
1246:  MOVFF  91D,924
124A:  MOVFF  91C,923
124E:  MOVFF  919,926
1252:  MOVFF  918,925
1256:  MOVLB  0
1258:  CALL   0712
125C:  MOVF   01,W
125E:  MOVLB  9
1260:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1262:  MOVLW  06
1264:  SUBWF  x1C,W
1266:  MOVWF  x22
1268:  MOVLW  00
126A:  SUBWFB x1D,W
126C:  MOVWF  x23
126E:  MOVF   x18,W
1270:  ADDWF  x22,W
1272:  MOVWF  FE9
1274:  MOVF   x19,W
1276:  ADDWFC x23,W
1278:  MOVWF  FEA
127A:  MOVFF  FEF,924
127E:  MOVLW  05
1280:  SUBWF  x1C,W
1282:  MOVWF  x25
1284:  MOVLW  00
1286:  SUBWFB x1D,W
1288:  MOVWF  x26
128A:  MOVF   x18,W
128C:  ADDWF  x25,W
128E:  MOVWF  FE9
1290:  MOVF   x19,W
1292:  ADDWFC x26,W
1294:  MOVWF  FEA
1296:  MOVFF  FEF,927
129A:  MOVLW  04
129C:  SUBWF  x1C,W
129E:  MOVWF  x28
12A0:  MOVLW  00
12A2:  SUBWFB x1D,W
12A4:  MOVWF  x29
12A6:  MOVF   x18,W
12A8:  ADDWF  x28,W
12AA:  MOVWF  FE9
12AC:  MOVF   x19,W
12AE:  ADDWFC x29,W
12B0:  MOVWF  FEA
12B2:  MOVFF  FEF,92A
12B6:  MOVLW  03
12B8:  SUBWF  x1C,W
12BA:  MOVWF  x2B
12BC:  MOVLW  00
12BE:  SUBWFB x1D,W
12C0:  MOVWF  x2C
12C2:  MOVF   x18,W
12C4:  ADDWF  x2B,W
12C6:  MOVWF  FE9
12C8:  MOVF   x19,W
12CA:  ADDWFC x2C,W
12CC:  MOVWF  FEA
12CE:  MOVFF  FEF,92D
12D2:  MOVLW  02
12D4:  SUBWF  x1C,W
12D6:  MOVWF  x2E
12D8:  MOVLW  00
12DA:  SUBWFB x1D,W
12DC:  MOVWF  x2F
12DE:  MOVF   x18,W
12E0:  ADDWF  x2E,W
12E2:  MOVWF  FE9
12E4:  MOVF   x19,W
12E6:  ADDWFC x2F,W
12E8:  MOVWF  FEA
12EA:  MOVFF  FEF,930
12EE:  MOVLW  01
12F0:  SUBWF  x1C,W
12F2:  MOVWF  x31
12F4:  MOVLW  00
12F6:  SUBWFB x1D,W
12F8:  MOVWF  x32
12FA:  MOVF   x18,W
12FC:  ADDWF  x31,W
12FE:  MOVWF  FE9
1300:  MOVF   x19,W
1302:  ADDWFC x32,W
1304:  MOVWF  FEA
1306:  MOVFF  FEF,933
130A:  MOVF   x18,W
130C:  ADDWF  x1C,W
130E:  MOVWF  FE9
1310:  MOVF   x19,W
1312:  ADDWFC x1D,W
1314:  MOVWF  FEA
1316:  MOVFF  FEF,934
131A:  CLRF   x37
131C:  MOVFF  924,938
1320:  MOVFF  927,939
1324:  MOVFF  92A,93A
1328:  MOVFF  92D,93B
132C:  MOVFF  930,93C
1330:  MOVFF  933,93D
1334:  MOVFF  934,93E
1338:  MOVLB  0
133A:  CALL   06AC
133E:  MOVFF  01,920
....................                j=j-7;             
1342:  MOVLW  07
1344:  MOVLB  9
1346:  SUBWF  x1C,F
1348:  MOVLW  00
134A:  SUBWFB x1D,F
....................              } 
134C:  BRA    122E
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
134E:  DECFSZ x21,W
1350:  BRA    1366
....................             { 
....................                dir=1; 
1352:  MOVLW  01
1354:  MOVLB  6
1356:  MOVWF  xC8
....................                return i; 
1358:  MOVLB  9
135A:  MOVFF  91A,01
135E:  MOVFF  91B,02
1362:  BRA    1600
....................             } 
....................             else return 0; 
1364:  BRA    136E
1366:  MOVLW  00
1368:  MOVWF  01
136A:  MOVWF  02
136C:  BRA    1600
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
136E:  BRA    15F0
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1370:  MOVLW  04
1372:  SUBWF  x1A,W
1374:  MOVWF  x22
1376:  MOVLW  00
1378:  SUBWFB x1B,W
137A:  MOVWF  x23
137C:  MOVF   x18,W
137E:  ADDWF  x22,W
1380:  MOVWF  FE9
1382:  MOVF   x19,W
1384:  ADDWFC x23,W
1386:  MOVWF  FEA
1388:  MOVFF  FEF,924
138C:  MOVLW  03
138E:  SUBWF  x1A,W
1390:  MOVWF  x25
1392:  MOVLW  00
1394:  SUBWFB x1B,W
1396:  MOVWF  x26
1398:  MOVF   x18,W
139A:  ADDWF  x25,W
139C:  MOVWF  FE9
139E:  MOVF   x19,W
13A0:  ADDWFC x26,W
13A2:  MOVWF  FEA
13A4:  MOVFF  FEF,927
13A8:  MOVLW  02
13AA:  SUBWF  x1A,W
13AC:  MOVWF  x28
13AE:  MOVLW  00
13B0:  SUBWFB x1B,W
13B2:  MOVWF  x29
13B4:  MOVF   x18,W
13B6:  ADDWF  x28,W
13B8:  MOVWF  FE9
13BA:  MOVF   x19,W
13BC:  ADDWFC x29,W
13BE:  MOVWF  FEA
13C0:  MOVFF  FEF,92A
13C4:  MOVLW  01
13C6:  SUBWF  x1A,W
13C8:  MOVWF  x2B
13CA:  MOVLW  00
13CC:  SUBWFB x1B,W
13CE:  MOVWF  x2C
13D0:  MOVF   x18,W
13D2:  ADDWF  x2B,W
13D4:  MOVWF  FE9
13D6:  MOVF   x19,W
13D8:  ADDWFC x2C,W
13DA:  MOVWF  FEA
13DC:  MOVFF  FEF,92D
13E0:  MOVF   x18,W
13E2:  ADDWF  x1A,W
13E4:  MOVWF  FE9
13E6:  MOVF   x19,W
13E8:  ADDWFC x1B,W
13EA:  MOVWF  FEA
13EC:  MOVFF  FEF,92E
13F0:  CLRF   x37
13F2:  CLRF   x38
13F4:  CLRF   x39
13F6:  MOVFF  924,93A
13FA:  MOVFF  927,93B
13FE:  MOVFF  92A,93C
1402:  MOVFF  92D,93D
1406:  MOVFF  92E,93E
140A:  MOVLB  0
140C:  CALL   06AC
1410:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1414:  MOVLW  09
1416:  MOVLB  9
1418:  SUBWF  x1A,W
141A:  MOVWF  x22
141C:  MOVLW  00
141E:  SUBWFB x1B,W
1420:  MOVWF  x23
1422:  MOVF   x18,W
1424:  ADDWF  x22,W
1426:  MOVWF  FE9
1428:  MOVF   x19,W
142A:  ADDWFC x23,W
142C:  MOVWF  FEA
142E:  MOVFF  FEF,924
1432:  MOVLW  08
1434:  SUBWF  x1A,W
1436:  MOVWF  x25
1438:  MOVLW  00
143A:  SUBWFB x1B,W
143C:  MOVWF  x26
143E:  MOVF   x18,W
1440:  ADDWF  x25,W
1442:  MOVWF  FE9
1444:  MOVF   x19,W
1446:  ADDWFC x26,W
1448:  MOVWF  FEA
144A:  MOVFF  FEF,927
144E:  MOVLW  07
1450:  SUBWF  x1A,W
1452:  MOVWF  x28
1454:  MOVLW  00
1456:  SUBWFB x1B,W
1458:  MOVWF  x29
145A:  MOVF   x18,W
145C:  ADDWF  x28,W
145E:  MOVWF  FE9
1460:  MOVF   x19,W
1462:  ADDWFC x29,W
1464:  MOVWF  FEA
1466:  MOVFF  FEF,92A
146A:  MOVLW  06
146C:  SUBWF  x1A,W
146E:  MOVWF  x2B
1470:  MOVLW  00
1472:  SUBWFB x1B,W
1474:  MOVWF  x2C
1476:  MOVF   x18,W
1478:  ADDWF  x2B,W
147A:  MOVWF  FE9
147C:  MOVF   x19,W
147E:  ADDWFC x2C,W
1480:  MOVWF  FEA
1482:  MOVFF  FEF,92D
1486:  MOVLW  05
1488:  SUBWF  x1A,W
148A:  MOVWF  x2E
148C:  MOVLW  00
148E:  SUBWFB x1B,W
1490:  MOVWF  x2F
1492:  MOVF   x18,W
1494:  ADDWF  x2E,W
1496:  MOVWF  FE9
1498:  MOVF   x19,W
149A:  ADDWFC x2F,W
149C:  MOVWF  FEA
149E:  MOVFF  FEF,930
14A2:  CLRF   x37
14A4:  CLRF   x38
14A6:  CLRF   x39
14A8:  MOVFF  924,93A
14AC:  MOVFF  927,93B
14B0:  MOVFF  92A,93C
14B4:  MOVFF  92D,93D
14B8:  MOVFF  930,93E
14BC:  MOVLB  0
14BE:  CALL   06AC
14C2:  MOVFF  01,91F
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
14C6:  MOVLB  9
14C8:  MOVF   x1E,W
14CA:  SUBLW  0B
14CC:  BTFSS  FD8.2
14CE:  BRA    15F0
14D0:  MOVF   x1F,W
14D2:  SUBLW  1F
14D4:  BTFSC  FD8.2
14D6:  BRA    15F0
14D8:  MOVF   x1F,W
14DA:  SUBLW  0F
14DC:  BTFSC  FD8.2
14DE:  BRA    15F0
....................             { 
....................                j=i; 
14E0:  MOVFF  91B,91D
14E4:  MOVFF  91A,91C
....................                CRC=1; 
14E8:  MOVLW  01
14EA:  MOVWF  x21
....................                temp2=temp; 
14EC:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
14F0:  MOVF   x20,W
14F2:  SUBLW  1F
14F4:  BZ    15D0
14F6:  MOVF   x1D,F
14F8:  BNZ   1500
14FA:  MOVF   x1C,W
14FC:  SUBLW  01
14FE:  BC    15D0
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1500:  MOVLW  01
1502:  MOVWF  x22
1504:  MOVFF  91D,924
1508:  MOVFF  91C,923
150C:  MOVFF  919,926
1510:  MOVFF  918,925
1514:  MOVLB  0
1516:  CALL   08C2
151A:  MOVF   01,W
151C:  MOVLB  9
151E:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1520:  MOVLW  04
1522:  SUBWF  x1C,W
1524:  MOVWF  x22
1526:  MOVLW  00
1528:  SUBWFB x1D,W
152A:  MOVWF  x23
152C:  MOVF   x18,W
152E:  ADDWF  x22,W
1530:  MOVWF  FE9
1532:  MOVF   x19,W
1534:  ADDWFC x23,W
1536:  MOVWF  FEA
1538:  MOVFF  FEF,924
153C:  MOVLW  03
153E:  SUBWF  x1C,W
1540:  MOVWF  x25
1542:  MOVLW  00
1544:  SUBWFB x1D,W
1546:  MOVWF  x26
1548:  MOVF   x18,W
154A:  ADDWF  x25,W
154C:  MOVWF  FE9
154E:  MOVF   x19,W
1550:  ADDWFC x26,W
1552:  MOVWF  FEA
1554:  MOVFF  FEF,927
1558:  MOVLW  02
155A:  SUBWF  x1C,W
155C:  MOVWF  x28
155E:  MOVLW  00
1560:  SUBWFB x1D,W
1562:  MOVWF  x29
1564:  MOVF   x18,W
1566:  ADDWF  x28,W
1568:  MOVWF  FE9
156A:  MOVF   x19,W
156C:  ADDWFC x29,W
156E:  MOVWF  FEA
1570:  MOVFF  FEF,92A
1574:  MOVLW  01
1576:  SUBWF  x1C,W
1578:  MOVWF  x2B
157A:  MOVLW  00
157C:  SUBWFB x1D,W
157E:  MOVWF  x2C
1580:  MOVF   x18,W
1582:  ADDWF  x2B,W
1584:  MOVWF  FE9
1586:  MOVF   x19,W
1588:  ADDWFC x2C,W
158A:  MOVWF  FEA
158C:  MOVFF  FEF,92D
1590:  MOVF   x18,W
1592:  ADDWF  x1C,W
1594:  MOVWF  FE9
1596:  MOVF   x19,W
1598:  ADDWFC x1D,W
159A:  MOVWF  FEA
159C:  MOVFF  FEF,92E
15A0:  CLRF   x37
15A2:  CLRF   x38
15A4:  CLRF   x39
15A6:  MOVFF  924,93A
15AA:  MOVFF  927,93B
15AE:  MOVFF  92A,93C
15B2:  MOVFF  92D,93D
15B6:  MOVFF  92E,93E
15BA:  MOVLB  0
15BC:  CALL   06AC
15C0:  MOVFF  01,920
....................                   j=j-5; 
15C4:  MOVLW  05
15C6:  MOVLB  9
15C8:  SUBWF  x1C,F
15CA:  MOVLW  00
15CC:  SUBWFB x1D,F
....................                } 
15CE:  BRA    14F0
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
15D0:  DECFSZ x21,W
15D2:  BRA    15E8
....................                { 
....................                   dir=1; 
15D4:  MOVLW  01
15D6:  MOVLB  6
15D8:  MOVWF  xC8
....................                   return i; 
15DA:  MOVLB  9
15DC:  MOVFF  91A,01
15E0:  MOVFF  91B,02
15E4:  BRA    1600
....................                } 
....................                   else return 0; 
15E6:  BRA    15F0
15E8:  MOVLW  00
15EA:  MOVWF  01
15EC:  MOVWF  02
15EE:  BRA    1600
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
15F0:  MOVF   x1A,W
15F2:  BTFSC  FD8.2
15F4:  DECF   x1B,F
15F6:  DECF   x1A,F
15F8:  BRA    0FF2
....................    return 0; 
15FA:  MOVLW  00
15FC:  MOVWF  01
15FE:  MOVWF  02
.................... } 
1600:  MOVLB  0
1602:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
35B4:  MOVLB  9
35B6:  CLRF   x02
35B8:  MOVLW  01
35BA:  MOVWF  x01
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
35BC:  MOVFF  8F7,915
35C0:  MOVFF  8F9,917
35C4:  MOVFF  8F8,916
35C8:  MOVFF  8FB,919
35CC:  MOVFF  8FA,918
35D0:  MOVLB  0
35D2:  CALL   0A02
35D6:  MOVFF  02,902
35DA:  MOVFF  01,901
....................    if(temp==0) return 0; 
35DE:  MOVLB  9
35E0:  MOVF   x01,F
35E2:  BNZ   35EE
35E4:  MOVF   x02,F
35E6:  BNZ   35EE
35E8:  MOVLW  00
35EA:  MOVWF  01
35EC:  BRA    3A68
....................    j=temp; 
35EE:  MOVFF  902,900
35F2:  MOVFF  901,8FF
....................    if(dir==0) 
35F6:  MOVLB  6
35F8:  MOVF   xC8,F
35FA:  BTFSS  FD8.2
35FC:  BRA    382A
....................    { 
....................       if(track==0) 
35FE:  MOVLB  8
3600:  MOVF   xF7,F
3602:  BTFSS  FD8.2
3604:  BRA    3742
....................       { 
....................             for(i=0;i<79;i++) 
3606:  CLRF   xFE
3608:  MOVF   xFE,W
360A:  SUBLW  4E
360C:  BTFSS  FD8.0
360E:  BRA    3740
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3610:  CLRF   03
3612:  MOVF   xFE,W
3614:  ADDWF  xFC,W
3616:  MOVWF  01
3618:  MOVF   xFD,W
361A:  ADDWFC 03,F
361C:  MOVFF  01,903
3620:  MOVFF  03,904
3624:  MOVLW  05
3626:  MOVLB  8
3628:  ADDWF  xFF,W
362A:  MOVLB  9
362C:  MOVWF  x05
362E:  MOVLW  00
3630:  ADDWFC x00,W
3632:  MOVWF  x06
3634:  MOVLB  8
3636:  MOVF   xFA,W
3638:  MOVLB  9
363A:  ADDWF  x05,W
363C:  MOVWF  FE9
363E:  MOVLB  8
3640:  MOVF   xFB,W
3642:  MOVLB  9
3644:  ADDWFC x06,W
3646:  MOVWF  FEA
3648:  MOVFF  FEF,907
364C:  MOVLW  04
364E:  MOVLB  8
3650:  ADDWF  xFF,W
3652:  MOVLB  9
3654:  MOVWF  x08
3656:  MOVLW  00
3658:  ADDWFC x00,W
365A:  MOVWF  x09
365C:  MOVLB  8
365E:  MOVF   xFA,W
3660:  MOVLB  9
3662:  ADDWF  x08,W
3664:  MOVWF  FE9
3666:  MOVLB  8
3668:  MOVF   xFB,W
366A:  MOVLB  9
366C:  ADDWFC x09,W
366E:  MOVWF  FEA
3670:  MOVFF  FEF,90A
3674:  MOVLW  03
3676:  MOVLB  8
3678:  ADDWF  xFF,W
367A:  MOVLB  9
367C:  MOVWF  x0B
367E:  MOVLW  00
3680:  ADDWFC x00,W
3682:  MOVWF  x0C
3684:  MOVLB  8
3686:  MOVF   xFA,W
3688:  MOVLB  9
368A:  ADDWF  x0B,W
368C:  MOVWF  FE9
368E:  MOVLB  8
3690:  MOVF   xFB,W
3692:  MOVLB  9
3694:  ADDWFC x0C,W
3696:  MOVWF  FEA
3698:  MOVFF  FEF,90D
369C:  MOVLW  02
369E:  MOVLB  8
36A0:  ADDWF  xFF,W
36A2:  MOVLB  9
36A4:  MOVWF  x0E
36A6:  MOVLW  00
36A8:  ADDWFC x00,W
36AA:  MOVWF  x0F
36AC:  MOVLB  8
36AE:  MOVF   xFA,W
36B0:  MOVLB  9
36B2:  ADDWF  x0E,W
36B4:  MOVWF  FE9
36B6:  MOVLB  8
36B8:  MOVF   xFB,W
36BA:  MOVLB  9
36BC:  ADDWFC x0F,W
36BE:  MOVWF  FEA
36C0:  MOVFF  FEF,910
36C4:  MOVLW  01
36C6:  MOVLB  8
36C8:  ADDWF  xFF,W
36CA:  MOVLB  9
36CC:  MOVWF  x11
36CE:  MOVLW  00
36D0:  ADDWFC x00,W
36D2:  MOVWF  x12
36D4:  MOVLB  8
36D6:  MOVF   xFA,W
36D8:  MOVLB  9
36DA:  ADDWF  x11,W
36DC:  MOVWF  FE9
36DE:  MOVLB  8
36E0:  MOVF   xFB,W
36E2:  MOVLB  9
36E4:  ADDWFC x12,W
36E6:  MOVWF  FEA
36E8:  MOVFF  FEF,913
36EC:  MOVLB  8
36EE:  MOVF   xFA,W
36F0:  ADDWF  xFF,W
36F2:  MOVWF  FE9
36F4:  MOVF   xFB,W
36F6:  MOVLB  9
36F8:  ADDWFC x00,W
36FA:  MOVWF  FEA
36FC:  MOVFF  FEF,914
3700:  CLRF   x37
3702:  CLRF   x38
3704:  MOVFF  907,939
3708:  MOVFF  90A,93A
370C:  MOVFF  90D,93B
3710:  MOVFF  910,93C
3714:  MOVFF  913,93D
3718:  MOVFF  914,93E
371C:  MOVLB  0
371E:  CALL   06AC
3722:  MOVFF  904,FEA
3726:  MOVFF  903,FE9
372A:  MOVFF  01,FEF
....................                j=j+7; 
372E:  MOVLW  07
3730:  MOVLB  8
3732:  ADDWF  xFF,F
3734:  MOVLW  00
3736:  MOVLB  9
3738:  ADDWFC x00,F
....................             } 
373A:  MOVLB  8
373C:  INCF   xFE,F
373E:  BRA    3608
....................       } 
....................          else  
3740:  BRA    3826
....................          { 
....................             for(i=0;i<40;i++) 
3742:  CLRF   xFE
3744:  MOVF   xFE,W
3746:  SUBLW  27
3748:  BNC   3826
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
374A:  CLRF   03
374C:  MOVF   xFE,W
374E:  ADDWF  xFC,W
3750:  MOVWF  01
3752:  MOVF   xFD,W
3754:  ADDWFC 03,F
3756:  MOVFF  01,903
375A:  MOVFF  03,904
375E:  MOVLW  03
3760:  MOVLB  8
3762:  ADDWF  xFF,W
3764:  MOVLB  9
3766:  MOVWF  x05
3768:  MOVLW  00
376A:  ADDWFC x00,W
376C:  MOVWF  x06
376E:  MOVLB  8
3770:  MOVF   xFA,W
3772:  MOVLB  9
3774:  ADDWF  x05,W
3776:  MOVWF  FE9
3778:  MOVLB  8
377A:  MOVF   xFB,W
377C:  MOVLB  9
377E:  ADDWFC x06,W
3780:  MOVWF  FEA
3782:  MOVFF  FEF,907
3786:  MOVLW  02
3788:  MOVLB  8
378A:  ADDWF  xFF,W
378C:  MOVLB  9
378E:  MOVWF  x08
3790:  MOVLW  00
3792:  ADDWFC x00,W
3794:  MOVWF  x09
3796:  MOVLB  8
3798:  MOVF   xFA,W
379A:  MOVLB  9
379C:  ADDWF  x08,W
379E:  MOVWF  FE9
37A0:  MOVLB  8
37A2:  MOVF   xFB,W
37A4:  MOVLB  9
37A6:  ADDWFC x09,W
37A8:  MOVWF  FEA
37AA:  MOVFF  FEF,90A
37AE:  MOVLW  01
37B0:  MOVLB  8
37B2:  ADDWF  xFF,W
37B4:  MOVLB  9
37B6:  MOVWF  x0B
37B8:  MOVLW  00
37BA:  ADDWFC x00,W
37BC:  MOVWF  x0C
37BE:  MOVLB  8
37C0:  MOVF   xFA,W
37C2:  MOVLB  9
37C4:  ADDWF  x0B,W
37C6:  MOVWF  FE9
37C8:  MOVLB  8
37CA:  MOVF   xFB,W
37CC:  MOVLB  9
37CE:  ADDWFC x0C,W
37D0:  MOVWF  FEA
37D2:  MOVFF  FEF,90D
37D6:  MOVLB  8
37D8:  MOVF   xFA,W
37DA:  ADDWF  xFF,W
37DC:  MOVWF  FE9
37DE:  MOVF   xFB,W
37E0:  MOVLB  9
37E2:  ADDWFC x00,W
37E4:  MOVWF  FEA
37E6:  MOVFF  FEF,90E
37EA:  CLRF   x37
37EC:  CLRF   x38
37EE:  CLRF   x39
37F0:  CLRF   x3A
37F2:  MOVFF  907,93B
37F6:  MOVFF  90A,93C
37FA:  MOVFF  90D,93D
37FE:  MOVFF  90E,93E
3802:  MOVLB  0
3804:  CALL   06AC
3808:  MOVFF  904,FEA
380C:  MOVFF  903,FE9
3810:  MOVFF  01,FEF
....................                j=j+5; 
3814:  MOVLW  05
3816:  MOVLB  8
3818:  ADDWF  xFF,F
381A:  MOVLW  00
381C:  MOVLB  9
381E:  ADDWFC x00,F
....................             }          
3820:  MOVLB  8
3822:  INCF   xFE,F
3824:  BRA    3744
....................          } 
....................    } 
....................       else  
3826:  BRA    3A52
3828:  MOVLB  6
....................       { 
....................          if(track==0) 
382A:  MOVLB  8
382C:  MOVF   xF7,F
382E:  BTFSS  FD8.2
3830:  BRA    396E
....................          { 
....................             for(i=0;i<79;i++) 
3832:  CLRF   xFE
3834:  MOVF   xFE,W
3836:  SUBLW  4E
3838:  BTFSS  FD8.0
383A:  BRA    396C
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
383C:  CLRF   03
383E:  MOVF   xFE,W
3840:  ADDWF  xFC,W
3842:  MOVWF  01
3844:  MOVF   xFD,W
3846:  ADDWFC 03,F
3848:  MOVFF  01,903
384C:  MOVFF  03,904
3850:  MOVLW  05
3852:  MOVLB  8
3854:  SUBWF  xFF,W
3856:  MOVLB  9
3858:  MOVWF  x05
385A:  MOVLW  00
385C:  SUBWFB x00,W
385E:  MOVWF  x06
3860:  MOVLB  8
3862:  MOVF   xFA,W
3864:  MOVLB  9
3866:  ADDWF  x05,W
3868:  MOVWF  FE9
386A:  MOVLB  8
386C:  MOVF   xFB,W
386E:  MOVLB  9
3870:  ADDWFC x06,W
3872:  MOVWF  FEA
3874:  MOVFF  FEF,907
3878:  MOVLW  04
387A:  MOVLB  8
387C:  SUBWF  xFF,W
387E:  MOVLB  9
3880:  MOVWF  x08
3882:  MOVLW  00
3884:  SUBWFB x00,W
3886:  MOVWF  x09
3888:  MOVLB  8
388A:  MOVF   xFA,W
388C:  MOVLB  9
388E:  ADDWF  x08,W
3890:  MOVWF  FE9
3892:  MOVLB  8
3894:  MOVF   xFB,W
3896:  MOVLB  9
3898:  ADDWFC x09,W
389A:  MOVWF  FEA
389C:  MOVFF  FEF,90A
38A0:  MOVLW  03
38A2:  MOVLB  8
38A4:  SUBWF  xFF,W
38A6:  MOVLB  9
38A8:  MOVWF  x0B
38AA:  MOVLW  00
38AC:  SUBWFB x00,W
38AE:  MOVWF  x0C
38B0:  MOVLB  8
38B2:  MOVF   xFA,W
38B4:  MOVLB  9
38B6:  ADDWF  x0B,W
38B8:  MOVWF  FE9
38BA:  MOVLB  8
38BC:  MOVF   xFB,W
38BE:  MOVLB  9
38C0:  ADDWFC x0C,W
38C2:  MOVWF  FEA
38C4:  MOVFF  FEF,90D
38C8:  MOVLW  02
38CA:  MOVLB  8
38CC:  SUBWF  xFF,W
38CE:  MOVLB  9
38D0:  MOVWF  x0E
38D2:  MOVLW  00
38D4:  SUBWFB x00,W
38D6:  MOVWF  x0F
38D8:  MOVLB  8
38DA:  MOVF   xFA,W
38DC:  MOVLB  9
38DE:  ADDWF  x0E,W
38E0:  MOVWF  FE9
38E2:  MOVLB  8
38E4:  MOVF   xFB,W
38E6:  MOVLB  9
38E8:  ADDWFC x0F,W
38EA:  MOVWF  FEA
38EC:  MOVFF  FEF,910
38F0:  MOVLW  01
38F2:  MOVLB  8
38F4:  SUBWF  xFF,W
38F6:  MOVLB  9
38F8:  MOVWF  x11
38FA:  MOVLW  00
38FC:  SUBWFB x00,W
38FE:  MOVWF  x12
3900:  MOVLB  8
3902:  MOVF   xFA,W
3904:  MOVLB  9
3906:  ADDWF  x11,W
3908:  MOVWF  FE9
390A:  MOVLB  8
390C:  MOVF   xFB,W
390E:  MOVLB  9
3910:  ADDWFC x12,W
3912:  MOVWF  FEA
3914:  MOVFF  FEF,913
3918:  MOVLB  8
391A:  MOVF   xFA,W
391C:  ADDWF  xFF,W
391E:  MOVWF  FE9
3920:  MOVF   xFB,W
3922:  MOVLB  9
3924:  ADDWFC x00,W
3926:  MOVWF  FEA
3928:  MOVFF  FEF,914
392C:  CLRF   x37
392E:  CLRF   x38
3930:  MOVFF  907,939
3934:  MOVFF  90A,93A
3938:  MOVFF  90D,93B
393C:  MOVFF  910,93C
3940:  MOVFF  913,93D
3944:  MOVFF  914,93E
3948:  MOVLB  0
394A:  CALL   06AC
394E:  MOVFF  904,FEA
3952:  MOVFF  903,FE9
3956:  MOVFF  01,FEF
....................                j=j-7; 
395A:  MOVLW  07
395C:  MOVLB  8
395E:  SUBWF  xFF,F
3960:  MOVLW  00
3962:  MOVLB  9
3964:  SUBWFB x00,F
....................             } 
3966:  MOVLB  8
3968:  INCF   xFE,F
396A:  BRA    3834
....................          } 
....................             else 
396C:  BRA    3A52
....................             { 
....................                for(i=0;i<40;i++) 
396E:  CLRF   xFE
3970:  MOVF   xFE,W
3972:  SUBLW  27
3974:  BNC   3A52
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3976:  CLRF   03
3978:  MOVF   xFE,W
397A:  ADDWF  xFC,W
397C:  MOVWF  01
397E:  MOVF   xFD,W
3980:  ADDWFC 03,F
3982:  MOVFF  01,903
3986:  MOVFF  03,904
398A:  MOVLW  03
398C:  MOVLB  8
398E:  SUBWF  xFF,W
3990:  MOVLB  9
3992:  MOVWF  x05
3994:  MOVLW  00
3996:  SUBWFB x00,W
3998:  MOVWF  x06
399A:  MOVLB  8
399C:  MOVF   xFA,W
399E:  MOVLB  9
39A0:  ADDWF  x05,W
39A2:  MOVWF  FE9
39A4:  MOVLB  8
39A6:  MOVF   xFB,W
39A8:  MOVLB  9
39AA:  ADDWFC x06,W
39AC:  MOVWF  FEA
39AE:  MOVFF  FEF,907
39B2:  MOVLW  02
39B4:  MOVLB  8
39B6:  SUBWF  xFF,W
39B8:  MOVLB  9
39BA:  MOVWF  x08
39BC:  MOVLW  00
39BE:  SUBWFB x00,W
39C0:  MOVWF  x09
39C2:  MOVLB  8
39C4:  MOVF   xFA,W
39C6:  MOVLB  9
39C8:  ADDWF  x08,W
39CA:  MOVWF  FE9
39CC:  MOVLB  8
39CE:  MOVF   xFB,W
39D0:  MOVLB  9
39D2:  ADDWFC x09,W
39D4:  MOVWF  FEA
39D6:  MOVFF  FEF,90A
39DA:  MOVLW  01
39DC:  MOVLB  8
39DE:  SUBWF  xFF,W
39E0:  MOVLB  9
39E2:  MOVWF  x0B
39E4:  MOVLW  00
39E6:  SUBWFB x00,W
39E8:  MOVWF  x0C
39EA:  MOVLB  8
39EC:  MOVF   xFA,W
39EE:  MOVLB  9
39F0:  ADDWF  x0B,W
39F2:  MOVWF  FE9
39F4:  MOVLB  8
39F6:  MOVF   xFB,W
39F8:  MOVLB  9
39FA:  ADDWFC x0C,W
39FC:  MOVWF  FEA
39FE:  MOVFF  FEF,90D
3A02:  MOVLB  8
3A04:  MOVF   xFA,W
3A06:  ADDWF  xFF,W
3A08:  MOVWF  FE9
3A0A:  MOVF   xFB,W
3A0C:  MOVLB  9
3A0E:  ADDWFC x00,W
3A10:  MOVWF  FEA
3A12:  MOVFF  FEF,90E
3A16:  CLRF   x37
3A18:  CLRF   x38
3A1A:  CLRF   x39
3A1C:  CLRF   x3A
3A1E:  MOVFF  907,93B
3A22:  MOVFF  90A,93C
3A26:  MOVFF  90D,93D
3A2A:  MOVFF  90E,93E
3A2E:  MOVLB  0
3A30:  CALL   06AC
3A34:  MOVFF  904,FEA
3A38:  MOVFF  903,FE9
3A3C:  MOVFF  01,FEF
....................                   j=j-5; 
3A40:  MOVLW  05
3A42:  MOVLB  8
3A44:  SUBWF  xFF,F
3A46:  MOVLW  00
3A48:  MOVLB  9
3A4A:  SUBWFB x00,F
....................                }             
3A4C:  MOVLB  8
3A4E:  INCF   xFE,F
3A50:  BRA    3970
....................             } 
....................       } 
....................       memset(datin,0,sizeof(datin)); 
3A52:  MOVFF  8FB,FEA
3A56:  MOVFF  8FA,FE9
3A5A:  CLRF   00
3A5C:  CLRF   02
3A5E:  MOVLW  02
3A60:  MOVWF  01
3A62:  MOVLB  0
3A64:  RCALL  359A
3A66:  MOVLB  9
.................... } 
3A68:  MOVLB  0
3A6A:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1836:  MOVLW  8E
1838:  MOVWF  FF6
183A:  MOVLW  05
183C:  MOVWF  FF7
183E:  RCALL  172E
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1840:  MOVLB  8
1842:  CLRF   x57
1844:  CLRF   x56
1846:  MOVF   x57,W
1848:  SUBLW  03
184A:  BNC   187A
184C:  BNZ   1854
184E:  MOVF   x56,W
1850:  SUBLW  51
1852:  BNC   187A
1854:  MOVLW  46
1856:  ADDWF  x56,W
1858:  MOVWF  FE9
185A:  MOVLW  02
185C:  ADDWFC x57,W
185E:  MOVWF  FEA
1860:  MOVFF  FEF,858
1864:  MOVFF  858,859
1868:  MOVLW  18
186A:  MOVWF  x5A
186C:  MOVLB  0
186E:  RCALL  177A
1870:  MOVLB  8
1872:  INCF   x56,F
1874:  BTFSC  FD8.2
1876:  INCF   x57,F
1878:  BRA    1846
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
187A:  MOVLW  A4
187C:  MOVWF  FF6
187E:  MOVLW  05
1880:  MOVWF  FF7
1882:  MOVLB  0
1884:  RCALL  172E
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1886:  MOVLB  8
1888:  CLRF   x57
188A:  CLRF   x56
188C:  MOVF   x57,W
188E:  SUBLW  01
1890:  BNC   18C0
1892:  BNZ   189A
1894:  MOVF   x56,W
1896:  SUBLW  2B
1898:  BNC   18C0
189A:  MOVLW  98
189C:  ADDWF  x56,W
189E:  MOVWF  FE9
18A0:  MOVLW  05
18A2:  ADDWFC x57,W
18A4:  MOVWF  FEA
18A6:  MOVFF  FEF,858
18AA:  MOVFF  858,859
18AE:  MOVLW  18
18B0:  MOVWF  x5A
18B2:  MOVLB  0
18B4:  RCALL  177A
18B6:  MOVLB  8
18B8:  INCF   x56,F
18BA:  BTFSC  FD8.2
18BC:  INCF   x57,F
18BE:  BRA    188C
.................... } 
18C0:  MOVLB  0
18C2:  GOTO   1B50 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3C02:  MOVLW  01
3C04:  MOVLB  6
3C06:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3C08:  MOVLB  0
3C0A:  RCALL  351C
3C0C:  MOVFF  02,854
3C10:  MOVFF  01,853
3C14:  MOVFF  02,856
3C18:  MOVFF  01,855
3C1C:  MOVLB  8
3C1E:  CLRF   x58
3C20:  MOVLW  7C
3C22:  MOVWF  x57
3C24:  MOVLB  0
3C26:  RCALL  3578
3C28:  MOVFF  01,853
3C2C:  MOVLW  96
3C2E:  MOVLB  8
3C30:  ADDWF  01,W
3C32:  MOVWF  01
3C34:  MOVLW  00
3C36:  ADDWFC 02,W
3C38:  MOVFF  01,20
3C3C:  MOVWF  21
3C3E:  CLRF   22
3C40:  CLRF   23
....................    if(datinbuf==0)  
3C42:  MOVLB  6
3C44:  MOVF   xD5,F
3C46:  BNZ   3C6A
....................    { 
....................       countbit_T1=0; 
3C48:  CLRF   xCA
3C4A:  CLRF   xC9
....................       countbit_T2=0; 
3C4C:  CLRF   xCC
3C4E:  CLRF   xCB
....................       bug_countbit_T1=0; 
3C50:  CLRF   xCE
3C52:  CLRF   xCD
....................       bug_countbit_T2=0; 
3C54:  CLRF   xD0
3C56:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3C58:  MOVF   xD9,F
3C5A:  BNZ   3C66
3C5C:  MOVLB  1
3C5E:  SETF   x00
3C60:  MOVLB  0
3C62:  SETF   xFF
3C64:  MOVLB  6
....................       saving_flag=0; 
3C66:  CLRF   xD8
....................       return; 
3C68:  BRA    3FF0
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3C6A:  MOVLW  BA
3C6C:  MOVWF  FF6
3C6E:  MOVLW  05
3C70:  MOVWF  FF7
3C72:  MOVLB  0
3C74:  CALL   172E
....................    //key_count=0; 
....................    enable_getpin=1; 
3C78:  MOVLW  01
3C7A:  MOVLB  1
3C7C:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3C7E:  MOVFF  6CA,852
3C82:  MOVFF  6C9,851
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3C86:  MOVLB  8
3C88:  CLRF   xF7
3C8A:  MOVFF  852,8F9
3C8E:  MOVFF  851,8F8
3C92:  MOVLW  02
3C94:  MOVWF  xFB
3C96:  MOVLW  46
3C98:  MOVWF  xFA
3C9A:  MOVLW  01
3C9C:  MOVWF  xFD
3C9E:  MOVLW  CF
3CA0:  MOVWF  xFC
3CA2:  MOVLB  0
3CA4:  RCALL  35B4
....................    countbit_T1=0; 
3CA6:  MOVLB  6
3CA8:  CLRF   xCA
3CAA:  CLRF   xC9
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3CAC:  MOVFF  6CC,852
3CB0:  MOVFF  6CB,851
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3CB4:  MOVLW  01
3CB6:  MOVLB  8
3CB8:  MOVWF  xF7
3CBA:  MOVFF  852,8F9
3CBE:  MOVFF  851,8F8
3CC2:  MOVLW  05
3CC4:  MOVWF  xFB
3CC6:  MOVLW  98
3CC8:  MOVWF  xFA
3CCA:  MOVLW  02
3CCC:  MOVWF  xFD
3CCE:  MOVLW  1E
3CD0:  MOVWF  xFC
3CD2:  MOVLB  0
3CD4:  RCALL  35B4
....................    countbit_T2=0; 
3CD6:  MOVLB  6
3CD8:  CLRF   xCC
3CDA:  CLRF   xCB
....................    saving_flag=0; 
3CDC:  CLRF   xD8
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3CDE:  MOVLW  20
3CE0:  MOVLB  1
3CE2:  ADDWF  xCF,W
3CE4:  MOVLB  8
3CE6:  MOVWF  x50
....................    if((ptr_card<EEPROM_SIZE_stofkey)&&(temp=='%')) 
3CE8:  MOVF   23,F
3CEA:  BTFSS  FD8.2
3CEC:  BRA    3FEE
3CEE:  MOVF   22,F
3CF0:  BTFSS  FD8.2
3CF2:  BRA    3FEE
3CF4:  MOVF   21,W
3CF6:  SUBLW  E0
3CF8:  BTFSS  FD8.0
3CFA:  BRA    3FEE
3CFC:  MOVF   x50,W
3CFE:  SUBLW  25
3D00:  BTFSS  FD8.2
3D02:  BRA    3FEE
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3D04:  MOVFF  23,03
3D08:  MOVFF  22,02
3D0C:  MOVFF  21,01
3D10:  MOVFF  20,00
3D14:  MOVLW  01
3D16:  ADDWF  20,F
3D18:  BTFSC  FD8.0
3D1A:  INCF   21,F
3D1C:  BTFSC  FD8.2
3D1E:  INCF   22,F
3D20:  BTFSC  FD8.2
3D22:  INCF   23,F
3D24:  MOVFF  01,854
3D28:  MOVFF  00,853
3D2C:  MOVLB  9
3D2E:  CLRF   x16
3D30:  CLRF   x15
3D32:  MOVFF  01,914
3D36:  MOVFF  00,913
3D3A:  MOVFF  1CB,917
3D3E:  MOVLB  0
3D40:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3D42:  MOVFF  23,03
3D46:  MOVFF  22,02
3D4A:  MOVFF  21,01
3D4E:  MOVFF  20,00
3D52:  MOVLW  01
3D54:  ADDWF  20,F
3D56:  BTFSC  FD8.0
3D58:  INCF   21,F
3D5A:  BTFSC  FD8.2
3D5C:  INCF   22,F
3D5E:  BTFSC  FD8.2
3D60:  INCF   23,F
3D62:  MOVFF  01,854
3D66:  MOVFF  00,853
3D6A:  MOVLB  9
3D6C:  CLRF   x16
3D6E:  CLRF   x15
3D70:  MOVFF  01,914
3D74:  MOVFF  00,913
3D78:  MOVFF  1CA,917
3D7C:  MOVLB  0
3D7E:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,h); 
3D80:  MOVFF  23,03
3D84:  MOVFF  22,02
3D88:  MOVFF  21,01
3D8C:  MOVFF  20,00
3D90:  MOVLW  01
3D92:  ADDWF  20,F
3D94:  BTFSC  FD8.0
3D96:  INCF   21,F
3D98:  BTFSC  FD8.2
3D9A:  INCF   22,F
3D9C:  BTFSC  FD8.2
3D9E:  INCF   23,F
3DA0:  MOVFF  01,854
3DA4:  MOVFF  00,853
3DA8:  MOVLB  9
3DAA:  CLRF   x16
3DAC:  CLRF   x15
3DAE:  MOVFF  01,914
3DB2:  MOVFF  00,913
3DB6:  MOVFF  1CC,917
3DBA:  MOVLB  0
3DBC:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,min); 
3DBE:  MOVFF  23,03
3DC2:  MOVFF  22,02
3DC6:  MOVFF  21,01
3DCA:  MOVFF  20,00
3DCE:  MOVLW  01
3DD0:  ADDWF  20,F
3DD2:  BTFSC  FD8.0
3DD4:  INCF   21,F
3DD6:  BTFSC  FD8.2
3DD8:  INCF   22,F
3DDA:  BTFSC  FD8.2
3DDC:  INCF   23,F
3DDE:  MOVFF  01,854
3DE2:  MOVFF  00,853
3DE6:  MOVLB  9
3DE8:  CLRF   x16
3DEA:  CLRF   x15
3DEC:  MOVFF  01,914
3DF0:  MOVFF  00,913
3DF4:  MOVFF  1CD,917
3DF8:  MOVLB  0
3DFA:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3DFC:  MOVFF  23,03
3E00:  MOVFF  22,02
3E04:  MOVFF  21,01
3E08:  MOVFF  20,00
3E0C:  MOVLW  01
3E0E:  ADDWF  20,F
3E10:  BTFSC  FD8.0
3E12:  INCF   21,F
3E14:  BTFSC  FD8.2
3E16:  INCF   22,F
3E18:  BTFSC  FD8.2
3E1A:  INCF   23,F
3E1C:  MOVFF  01,854
3E20:  MOVFF  00,853
3E24:  MOVLB  9
3E26:  CLRF   x16
3E28:  CLRF   x15
3E2A:  MOVFF  01,914
3E2E:  MOVFF  00,913
3E32:  MOVFF  1CE,917
3E36:  MOVLB  0
3E38:  RCALL  3A6C
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3E3A:  MOVLB  6
3E3C:  CLRF   xD4
3E3E:  CLRF   xD3
3E40:  MOVF   xD4,F
3E42:  BNZ   3EA6
3E44:  MOVF   xD3,W
3E46:  SUBLW  4E
3E48:  BNC   3EA6
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3E4A:  MOVFF  23,03
3E4E:  MOVFF  22,02
3E52:  MOVFF  21,01
3E56:  MOVFF  20,00
3E5A:  MOVLW  01
3E5C:  ADDWF  20,F
3E5E:  BTFSC  FD8.0
3E60:  INCF   21,F
3E62:  BTFSC  FD8.2
3E64:  INCF   22,F
3E66:  BTFSC  FD8.2
3E68:  INCF   23,F
3E6A:  MOVFF  01,854
3E6E:  MOVFF  00,853
3E72:  MOVLW  CF
3E74:  ADDWF  xD3,W
3E76:  MOVWF  FE9
3E78:  MOVLW  01
3E7A:  ADDWFC xD4,W
3E7C:  MOVWF  FEA
3E7E:  MOVF   FEF,W
3E80:  ANDLW  3F
3E82:  ADDLW  20
3E84:  MOVLB  8
3E86:  MOVWF  x55
3E88:  MOVLB  9
3E8A:  CLRF   x16
3E8C:  CLRF   x15
3E8E:  MOVFF  01,914
3E92:  MOVFF  00,913
3E96:  MOVWF  x17
3E98:  MOVLB  0
3E9A:  RCALL  3A6C
....................              
....................          } 
3E9C:  MOVLB  6
3E9E:  INCF   xD3,F
3EA0:  BTFSC  FD8.2
3EA2:  INCF   xD4,F
3EA4:  BRA    3E40
....................          memset(Track1,0,sizeof(Track1)); 
3EA6:  MOVLW  01
3EA8:  MOVWF  FEA
3EAA:  MOVLW  CF
3EAC:  MOVWF  FE9
3EAE:  CLRF   00
3EB0:  CLRF   02
3EB2:  MOVLW  4F
3EB4:  MOVWF  01
3EB6:  MOVLB  0
3EB8:  CALL   359A
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3EBC:  MOVLB  6
3EBE:  CLRF   xD4
3EC0:  CLRF   xD3
3EC2:  MOVF   xD4,F
3EC4:  BNZ   3F28
3EC6:  MOVF   xD3,W
3EC8:  SUBLW  27
3ECA:  BNC   3F28
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3ECC:  MOVFF  23,03
3ED0:  MOVFF  22,02
3ED4:  MOVFF  21,01
3ED8:  MOVFF  20,00
3EDC:  MOVLW  01
3EDE:  ADDWF  20,F
3EE0:  BTFSC  FD8.0
3EE2:  INCF   21,F
3EE4:  BTFSC  FD8.2
3EE6:  INCF   22,F
3EE8:  BTFSC  FD8.2
3EEA:  INCF   23,F
3EEC:  MOVFF  01,854
3EF0:  MOVFF  00,853
3EF4:  MOVLW  1E
3EF6:  ADDWF  xD3,W
3EF8:  MOVWF  FE9
3EFA:  MOVLW  02
3EFC:  ADDWFC xD4,W
3EFE:  MOVWF  FEA
3F00:  MOVF   FEF,W
3F02:  ANDLW  0F
3F04:  ADDLW  30
3F06:  MOVLB  8
3F08:  MOVWF  x55
3F0A:  MOVLB  9
3F0C:  CLRF   x16
3F0E:  CLRF   x15
3F10:  MOVFF  01,914
3F14:  MOVFF  00,913
3F18:  MOVWF  x17
3F1A:  MOVLB  0
3F1C:  RCALL  3A6C
....................          }  
3F1E:  MOVLB  6
3F20:  INCF   xD3,F
3F22:  BTFSC  FD8.2
3F24:  INCF   xD4,F
3F26:  BRA    3EC2
....................          memset(Track2,0,sizeof(Track2)); 
3F28:  MOVLW  02
3F2A:  MOVWF  FEA
3F2C:  MOVLW  1E
3F2E:  MOVWF  FE9
3F30:  CLRF   00
3F32:  CLRF   02
3F34:  MOVLW  28
3F36:  MOVWF  01
3F38:  MOVLB  0
3F3A:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
3F3E:  MOVLW  0D
3F40:  MOVLB  9
3F42:  MOVWF  x0C
3F44:  MOVLB  0
3F46:  CALL   1604
3F4A:  MOVLW  0A
3F4C:  MOVLB  9
3F4E:  MOVWF  x0C
3F50:  MOVLB  0
3F52:  CALL   1604
....................         fprintf(COM2,"Done"); 
3F56:  MOVLW  D0
3F58:  MOVWF  FF6
3F5A:  MOVLW  05
3F5C:  MOVWF  FF7
3F5E:  CALL   172E
....................              
....................         fprintf(COM2,"\r\n"); 
3F62:  MOVLW  0D
3F64:  MOVLB  9
3F66:  MOVWF  x0C
3F68:  MOVLB  0
3F6A:  CALL   1604
3F6E:  MOVLW  0A
3F70:  MOVLB  9
3F72:  MOVWF  x0C
3F74:  MOVLB  0
3F76:  CALL   1604
....................         fprintf(COM2,"Waiting for PIN number"); 
3F7A:  MOVLW  D6
3F7C:  MOVWF  FF6
3F7E:  MOVLW  05
3F80:  MOVWF  FF7
3F82:  CALL   172E
....................         memset(key_data,0,sizeof(key_data));  
3F86:  MOVLW  01
3F88:  MOVWF  FEA
3F8A:  MOVLW  4A
3F8C:  MOVWF  FE9
3F8E:  CLRF   00
3F90:  CLRF   02
3F92:  MOVLW  10
3F94:  MOVWF  01
3F96:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
3F9A:  MOVLW  0D
3F9C:  MOVLB  9
3F9E:  MOVWF  x0C
3FA0:  MOVLB  0
3FA2:  CALL   1604
3FA6:  MOVLW  0A
3FA8:  MOVLB  9
3FAA:  MOVWF  x0C
3FAC:  MOVLB  0
3FAE:  CALL   1604
....................         charac_timeout=0; 
3FB2:  MOVLB  1
3FB4:  CLRF   x00
3FB6:  MOVLB  0
3FB8:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3FBA:  MOVFF  23,8FA
3FBE:  MOVFF  22,8F9
3FC2:  MOVFF  21,8F8
3FC6:  MOVFF  20,8F7
3FCA:  MOVLW  19
3FCC:  MOVLB  8
3FCE:  MOVWF  xFB
3FD0:  MOVLB  0
3FD2:  RCALL  3B6A
....................       datinbuf=0; 
3FD4:  MOVLB  6
3FD6:  CLRF   xD5
....................       saving_flag=0; 
3FD8:  CLRF   xD8
....................       data_avai=1; 
3FDA:  MOVLW  01
3FDC:  MOVWF  xD9
....................       enable_getpin=1; 
3FDE:  MOVLB  1
3FE0:  MOVWF  x45
....................       charac_timeout=0; 
3FE2:  CLRF   x00
3FE4:  MOVLB  0
3FE6:  CLRF   xFF
....................       key_count_ms=0; 
3FE8:  MOVLB  1
3FEA:  CLRF   x47
3FEC:  MOVLB  8
3FEE:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3FF0:  MOVLB  0
3FF2:  GOTO   5A5C (RETURN)
.................... //========================= 
.................... void saving_card_encrypt() 
.................... { 
*
4FEE:  MOVLB  8
4FF0:  CLRF   x54
....................    int8 temp,i,j,u; 
....................    int8 countbyte=0; 
....................    int16 tempcount; 
....................    int8 carddata[numdataofonecard]; 
....................    int8 encryptblock[16]; 
....................    int8 tempkey[16]; 
....................    saving_flag=1; 
4FF2:  MOVLW  01
4FF4:  MOVLB  6
4FF6:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdataofonecard)+ptr_start); 
4FF8:  MOVLB  0
4FFA:  CALL   351C
4FFE:  MOVFF  02,8F8
5002:  MOVFF  01,8F7
5006:  MOVLB  8
5008:  RLCF   xF7,F
500A:  RLCF   xF8,F
500C:  RLCF   xF7,F
500E:  RLCF   xF8,F
5010:  RLCF   xF7,F
5012:  RLCF   xF8,F
5014:  RLCF   xF7,F
5016:  RLCF   xF8,F
5018:  RLCF   xF7,F
501A:  RLCF   xF8,F
501C:  RLCF   xF7,F
501E:  RLCF   xF8,F
5020:  RLCF   xF7,F
5022:  RLCF   xF8,F
5024:  MOVLW  80
5026:  ANDWF  xF7,F
5028:  MOVLW  96
502A:  ADDWF  xF7,W
502C:  MOVWF  01
502E:  MOVLW  00
5030:  ADDWFC xF8,W
5032:  MOVFF  01,20
5036:  MOVWF  21
5038:  CLRF   22
503A:  CLRF   23
....................    if(datinbuf==0)  
503C:  MOVLB  6
503E:  MOVF   xD5,F
5040:  BNZ   5064
....................    { 
....................       countbit_T1=0; 
5042:  CLRF   xCA
5044:  CLRF   xC9
....................       countbit_T2=0; 
5046:  CLRF   xCC
5048:  CLRF   xCB
....................       bug_countbit_T1=0; 
504A:  CLRF   xCE
504C:  CLRF   xCD
....................       bug_countbit_T2=0; 
504E:  CLRF   xD0
5050:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
5052:  MOVF   xD9,F
5054:  BNZ   5060
5056:  MOVLB  1
5058:  SETF   x00
505A:  MOVLB  0
505C:  SETF   xFF
505E:  MOVLB  6
....................       saving_flag=0; 
5060:  CLRF   xD8
....................       return; 
5062:  BRA    54B0
....................    }//*/ 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
5064:  MOVLW  EE
5066:  MOVWF  FF6
5068:  MOVLW  05
506A:  MOVWF  FF7
506C:  MOVLB  0
506E:  CALL   172E
....................    //key_count=0; 
....................    enable_getpin=1; 
5072:  MOVLW  01
5074:  MOVLB  1
5076:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
5078:  MOVFF  6CA,856
507C:  MOVFF  6C9,855
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
5080:  MOVLB  8
5082:  CLRF   xF7
5084:  MOVFF  856,8F9
5088:  MOVFF  855,8F8
508C:  MOVLW  02
508E:  MOVWF  xFB
5090:  MOVLW  46
5092:  MOVWF  xFA
5094:  MOVLW  01
5096:  MOVWF  xFD
5098:  MOVLW  CF
509A:  MOVWF  xFC
509C:  MOVLB  0
509E:  CALL   35B4
....................    countbit_T1=0; 
50A2:  MOVLB  6
50A4:  CLRF   xCA
50A6:  CLRF   xC9
....................    tempcount=countbit_T2;    
50A8:  MOVFF  6CC,856
50AC:  MOVFF  6CB,855
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
50B0:  MOVLW  01
50B2:  MOVLB  8
50B4:  MOVWF  xF7
50B6:  MOVFF  856,8F9
50BA:  MOVFF  855,8F8
50BE:  MOVLW  05
50C0:  MOVWF  xFB
50C2:  MOVLW  98
50C4:  MOVWF  xFA
50C6:  MOVLW  02
50C8:  MOVWF  xFD
50CA:  MOVLW  1E
50CC:  MOVWF  xFC
50CE:  MOVLB  0
50D0:  CALL   35B4
....................    countbit_T2=0; 
50D4:  MOVLB  6
50D6:  CLRF   xCC
50D8:  CLRF   xCB
....................    saving_flag=0; 
50DA:  CLRF   xD8
....................    temp=Track1[0]+0x20; 
50DC:  MOVLW  20
50DE:  MOVLB  1
50E0:  ADDWF  xCF,W
50E2:  MOVLB  8
50E4:  MOVWF  x50
....................    if((ptr_card<EEPROM_SIZE_stofkey)) 
50E6:  MOVF   23,F
50E8:  BTFSS  FD8.2
50EA:  BRA    54AE
50EC:  MOVF   22,F
50EE:  BTFSS  FD8.2
50F0:  BRA    54AE
50F2:  MOVF   21,W
50F4:  SUBLW  E0
50F6:  BTFSS  FD8.0
50F8:  BRA    54AE
....................    { 
....................          countbyte = 0; 
50FA:  CLRF   x54
....................          carddata[countbyte++]=date;    
50FC:  MOVF   x54,W
50FE:  INCF   x54,F
5100:  CLRF   03
5102:  ADDLW  57
5104:  MOVWF  FE9
5106:  MOVLW  08
5108:  ADDWFC 03,W
510A:  MOVWF  FEA
510C:  MOVFF  1CB,FEF
....................          carddata[countbyte++]=mon;    
5110:  MOVF   x54,W
5112:  INCF   x54,F
5114:  CLRF   03
5116:  ADDLW  57
5118:  MOVWF  FE9
511A:  MOVLW  08
511C:  ADDWFC 03,W
511E:  MOVWF  FEA
5120:  MOVFF  1CA,FEF
....................          carddata[countbyte++]=h;    
5124:  MOVF   x54,W
5126:  INCF   x54,F
5128:  CLRF   03
512A:  ADDLW  57
512C:  MOVWF  FE9
512E:  MOVLW  08
5130:  ADDWFC 03,W
5132:  MOVWF  FEA
5134:  MOVFF  1CC,FEF
....................          carddata[countbyte++]=min;    
5138:  MOVF   x54,W
513A:  INCF   x54,F
513C:  CLRF   03
513E:  ADDLW  57
5140:  MOVWF  FE9
5142:  MOVLW  08
5144:  ADDWFC 03,W
5146:  MOVWF  FEA
5148:  MOVFF  1CD,FEF
....................          carddata[countbyte++]=sec; 
514C:  MOVF   x54,W
514E:  INCF   x54,F
5150:  CLRF   03
5152:  ADDLW  57
5154:  MOVWF  FE9
5156:  MOVLW  08
5158:  ADDWFC 03,W
515A:  MOVWF  FEA
515C:  MOVFF  1CE,FEF
....................          carddata[countbyte++]=0xff;             
5160:  MOVF   x54,W
5162:  INCF   x54,F
5164:  CLRF   03
5166:  ADDLW  57
5168:  MOVWF  FE9
516A:  MOVLW  08
516C:  ADDWFC 03,W
516E:  MOVWF  FEA
5170:  SETF   FEF
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
5172:  MOVLB  6
5174:  CLRF   xD4
5176:  CLRF   xD3
5178:  MOVF   xD4,F
517A:  BNZ   51BC
517C:  MOVF   xD3,W
517E:  SUBLW  4E
5180:  BNC   51BC
....................          { 
....................             carddata[countbyte++] = (INT8)((Track1[countbit]&0b00111111)+0x20);       
5182:  MOVLB  8
5184:  MOVF   x54,W
5186:  INCF   x54,F
5188:  CLRF   03
518A:  ADDLW  57
518C:  MOVWF  01
518E:  MOVLW  08
5190:  ADDWFC 03,F
5192:  MOVLW  CF
5194:  MOVLB  6
5196:  ADDWF  xD3,W
5198:  MOVWF  FE9
519A:  MOVLW  01
519C:  ADDWFC xD4,W
519E:  MOVWF  FEA
51A0:  MOVF   FEF,W
51A2:  ANDLW  3F
51A4:  ADDLW  20
51A6:  MOVLB  8
51A8:  MOVFF  03,FEA
51AC:  MOVFF  01,FE9
51B0:  MOVWF  FEF
....................          } 
51B2:  MOVLB  6
51B4:  INCF   xD3,F
51B6:  BTFSC  FD8.2
51B8:  INCF   xD4,F
51BA:  BRA    5178
....................          memset(Track1,0,sizeof(Track1)); 
51BC:  MOVLW  01
51BE:  MOVWF  FEA
51C0:  MOVLW  CF
51C2:  MOVWF  FE9
51C4:  CLRF   00
51C6:  CLRF   02
51C8:  MOVLW  4F
51CA:  MOVWF  01
51CC:  MOVLB  0
51CE:  CALL   359A
....................          carddata[countbyte++]=0xfe; 
51D2:  MOVLB  8
51D4:  MOVF   x54,W
51D6:  INCF   x54,F
51D8:  CLRF   03
51DA:  ADDLW  57
51DC:  MOVWF  FE9
51DE:  MOVLW  08
51E0:  ADDWFC 03,W
51E2:  MOVWF  FEA
51E4:  MOVLW  FE
51E6:  MOVWF  FEF
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
51E8:  MOVLB  6
51EA:  CLRF   xD4
51EC:  CLRF   xD3
51EE:  MOVF   xD4,F
51F0:  BNZ   5232
51F2:  MOVF   xD3,W
51F4:  SUBLW  27
51F6:  BNC   5232
....................          { 
....................             carddata[countbyte++] = (INT8)((Track2[countbit]&0b00001111)+0x30);            
51F8:  MOVLB  8
51FA:  MOVF   x54,W
51FC:  INCF   x54,F
51FE:  CLRF   03
5200:  ADDLW  57
5202:  MOVWF  01
5204:  MOVLW  08
5206:  ADDWFC 03,F
5208:  MOVLW  1E
520A:  MOVLB  6
520C:  ADDWF  xD3,W
520E:  MOVWF  FE9
5210:  MOVLW  02
5212:  ADDWFC xD4,W
5214:  MOVWF  FEA
5216:  MOVF   FEF,W
5218:  ANDLW  0F
521A:  ADDLW  30
521C:  MOVLB  8
521E:  MOVFF  03,FEA
5222:  MOVFF  01,FE9
5226:  MOVWF  FEF
....................          }  
5228:  MOVLB  6
522A:  INCF   xD3,F
522C:  BTFSC  FD8.2
522E:  INCF   xD4,F
5230:  BRA    51EE
....................          for(i=countbyte;i<numdataofonecard;i++) 
5232:  MOVFF  854,851
5236:  MOVLB  8
5238:  MOVF   x51,W
523A:  SUBLW  7F
523C:  BNC   5252
....................          { 
....................              carddata[i] = 0; 
523E:  CLRF   03
5240:  MOVF   x51,W
5242:  ADDLW  57
5244:  MOVWF  FE9
5246:  MOVLW  08
5248:  ADDWFC 03,W
524A:  MOVWF  FEA
524C:  CLRF   FEF
....................          } 
524E:  INCF   x51,F
5250:  BRA    5238
....................          carddata[numdataofonecard-1]=0xfc; 
5252:  MOVLW  FC
5254:  MOVWF  xD6
....................          for(i=0;i<8;i++) 
5256:  CLRF   x51
5258:  MOVF   x51,W
525A:  SUBLW  07
525C:  BNC   5316
....................          { 
....................              for(j=0;j<16;j++) 
525E:  CLRF   x52
5260:  MOVF   x52,W
5262:  SUBLW  0F
5264:  BNC   529E
....................              { 
....................                 encryptblock[j] = carddata[i*16+j]; 
5266:  CLRF   03
5268:  MOVF   x52,W
526A:  ADDLW  D7
526C:  MOVWF  01
526E:  MOVLW  08
5270:  ADDWFC 03,F
5272:  MOVFF  03,8F8
5276:  MOVF   x51,W
5278:  MULLW  10
527A:  MOVF   FF3,W
527C:  ADDWF  x52,W
527E:  CLRF   03
5280:  ADDLW  57
5282:  MOVWF  FE9
5284:  MOVLW  08
5286:  ADDWFC 03,W
5288:  MOVWF  FEA
528A:  MOVFF  FEF,8F9
528E:  MOVFF  8F8,FEA
5292:  MOVFF  01,FE9
5296:  MOVFF  8F9,FEF
....................              } 
529A:  INCF   x52,F
529C:  BRA    5260
....................              EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
529E:  MOVLB  9
52A0:  CLRF   x07
52A2:  CLRF   x06
52A4:  CLRF   x05
52A6:  MOVLW  3F
52A8:  MOVWF  x04
52AA:  CLRF   x0B
52AC:  CLRF   x0A
52AE:  CLRF   x09
52B0:  MOVLW  20
52B2:  MOVWF  x08
52B4:  MOVLW  01
52B6:  MOVWF  x0D
52B8:  MOVWF  x0C
52BA:  MOVLB  0
52BC:  CALL   3FF6
....................              aes_enc_dec((unsigned int8 *)&encryptblock[0], (unsigned int8 *)&crypto_key[0],0); 
52C0:  MOVLW  08
52C2:  MOVLB  8
52C4:  MOVWF  xF8
52C6:  MOVLW  D7
52C8:  MOVWF  xF7
52CA:  MOVLW  01
52CC:  MOVWF  xFA
52CE:  MOVWF  xF9
52D0:  CLRF   xFB
52D2:  MOVLB  0
52D4:  CALL   40EC
....................              /*for(u=0;u<16;u++) 
....................              { 
....................                 encryptblock[u];  
....................                 fprintf(COM2,"%x",encryptblock[u]); 
....................              }*/ 
....................              EEPROM_write(ptr_card,16,encryptblock); 
52D8:  MOVFF  23,8FA
52DC:  MOVFF  22,8F9
52E0:  MOVFF  21,8F8
52E4:  MOVFF  20,8F7
52E8:  MOVLB  8
52EA:  CLRF   xFE
52EC:  CLRF   xFD
52EE:  CLRF   xFC
52F0:  MOVLW  10
52F2:  MOVWF  xFB
52F4:  MOVLW  08
52F6:  MOVLB  9
52F8:  MOVWF  x00
52FA:  MOVLW  D7
52FC:  MOVLB  8
52FE:  MOVWF  xFF
5300:  MOVLB  0
5302:  RCALL  4EE8
....................              ptr_card=ptr_card+16; 
5304:  MOVLW  10
5306:  ADDWF  20,F
5308:  MOVLW  00
530A:  ADDWFC 21,F
530C:  ADDWFC 22,F
530E:  ADDWFC 23,F
....................          } 
5310:  MOVLB  8
5312:  INCF   x51,F
5314:  BRA    5258
....................          fprintf(COM2,"\r\n"); 
5316:  MOVLW  0D
5318:  MOVLB  9
531A:  MOVWF  x0C
531C:  MOVLB  0
531E:  CALL   1604
5322:  MOVLW  0A
5324:  MOVLB  9
5326:  MOVWF  x0C
5328:  MOVLB  0
532A:  CALL   1604
....................          fprintf(COM2,"card data: %lu",ptr_card); 
532E:  MOVLW  04
5330:  MOVWF  FF6
5332:  MOVLW  06
5334:  MOVWF  FF7
5336:  MOVLW  0B
5338:  MOVLB  8
533A:  MOVWF  xF7
533C:  MOVLB  0
533E:  CALL   164A
5342:  MOVLW  41
5344:  MOVWF  FE9
5346:  MOVFF  23,8FA
534A:  MOVFF  22,8F9
534E:  MOVFF  21,8F8
5352:  MOVFF  20,8F7
5356:  CALL   22FA
....................          fprintf(COM2,"\r\n"); 
535A:  MOVLW  0D
535C:  MOVLB  9
535E:  MOVWF  x0C
5360:  MOVLB  0
5362:  CALL   1604
5366:  MOVLW  0A
5368:  MOVLB  9
536A:  MOVWF  x0C
536C:  MOVLB  0
536E:  CALL   1604
....................          EEPROM_read(ptr_card-128,128,&carddata); 
5372:  MOVLW  80
5374:  SUBWF  20,W
5376:  MOVLB  8
5378:  MOVWF  xF7
537A:  MOVLW  00
537C:  SUBWFB 21,W
537E:  MOVWF  xF8
5380:  MOVLW  00
5382:  SUBWFB 22,W
5384:  MOVWF  xF9
5386:  MOVLW  00
5388:  SUBWFB 23,W
538A:  MOVWF  xFA
538C:  MOVFF  FE8,907
5390:  MOVFF  8F9,906
5394:  MOVFF  8F8,905
5398:  MOVFF  8F7,904
539C:  MOVLB  9
539E:  CLRF   x0B
53A0:  CLRF   x0A
53A2:  CLRF   x09
53A4:  MOVLW  80
53A6:  MOVWF  x08
53A8:  MOVLW  08
53AA:  MOVWF  x0D
53AC:  MOVLW  57
53AE:  MOVWF  x0C
53B0:  MOVLB  0
53B2:  CALL   3FF6
....................          for(i=0;i<numdataofonecard;i++) 
53B6:  MOVLB  8
53B8:  CLRF   x51
53BA:  MOVF   x51,W
53BC:  SUBLW  7F
53BE:  BNC   53E6
....................          { 
....................              fprintf(COM2,"%x",carddata[i]); 
53C0:  CLRF   03
53C2:  MOVF   x51,W
53C4:  ADDLW  57
53C6:  MOVWF  FE9
53C8:  MOVLW  08
53CA:  ADDWFC 03,W
53CC:  MOVWF  FEA
53CE:  MOVFF  FEF,8F7
53D2:  MOVFF  8F7,901
53D6:  MOVLW  57
53D8:  MOVLB  9
53DA:  MOVWF  x02
53DC:  MOVLB  0
53DE:  RCALL  4FA4
....................          } 
53E0:  MOVLB  8
53E2:  INCF   x51,F
53E4:  BRA    53BA
....................          memset(Track2,0,sizeof(Track2)); 
53E6:  MOVLW  02
53E8:  MOVWF  FEA
53EA:  MOVLW  1E
53EC:  MOVWF  FE9
53EE:  CLRF   00
53F0:  CLRF   02
53F2:  MOVLW  28
53F4:  MOVWF  01
53F6:  MOVLB  0
53F8:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
53FC:  MOVLW  0D
53FE:  MOVLB  9
5400:  MOVWF  x0C
5402:  MOVLB  0
5404:  CALL   1604
5408:  MOVLW  0A
540A:  MOVLB  9
540C:  MOVWF  x0C
540E:  MOVLB  0
5410:  CALL   1604
....................         fprintf(COM2,"Done"); 
5414:  MOVLW  14
5416:  MOVWF  FF6
5418:  MOVLW  06
541A:  MOVWF  FF7
541C:  CALL   172E
....................              
....................         fprintf(COM2,"\r\n"); 
5420:  MOVLW  0D
5422:  MOVLB  9
5424:  MOVWF  x0C
5426:  MOVLB  0
5428:  CALL   1604
542C:  MOVLW  0A
542E:  MOVLB  9
5430:  MOVWF  x0C
5432:  MOVLB  0
5434:  CALL   1604
....................         fprintf(COM2,"Waiting for PIN number"); 
5438:  MOVLW  1A
543A:  MOVWF  FF6
543C:  MOVLW  06
543E:  MOVWF  FF7
5440:  CALL   172E
....................         memset(key_data,0,sizeof(key_data));  
5444:  MOVLW  01
5446:  MOVWF  FEA
5448:  MOVLW  4A
544A:  MOVWF  FE9
544C:  CLRF   00
544E:  CLRF   02
5450:  MOVLW  10
5452:  MOVWF  01
5454:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
5458:  MOVLW  0D
545A:  MOVLB  9
545C:  MOVWF  x0C
545E:  MOVLB  0
5460:  CALL   1604
5464:  MOVLW  0A
5466:  MOVLB  9
5468:  MOVWF  x0C
546A:  MOVLB  0
546C:  CALL   1604
....................         charac_timeout=0; 
5470:  MOVLB  1
5472:  CLRF   x00
5474:  MOVLB  0
5476:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       //ptr_card = ptr_card+numdataofonecard; 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5478:  MOVFF  23,8FA
547C:  MOVFF  22,8F9
5480:  MOVFF  21,8F8
5484:  MOVFF  20,8F7
5488:  MOVLW  19
548A:  MOVLB  8
548C:  MOVWF  xFB
548E:  MOVLB  0
5490:  CALL   3B6A
....................       datinbuf=0; 
5494:  MOVLB  6
5496:  CLRF   xD5
....................       saving_flag=0; 
5498:  CLRF   xD8
....................       data_avai=1; 
549A:  MOVLW  01
549C:  MOVWF  xD9
....................       enable_getpin=1; 
549E:  MOVLB  1
54A0:  MOVWF  x45
....................       charac_timeout=0; 
54A2:  CLRF   x00
54A4:  MOVLB  0
54A6:  CLRF   xFF
....................       key_count_ms=0; 
54A8:  MOVLB  1
54AA:  CLRF   x47
54AC:  MOVLB  8
54AE:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
54B0:  MOVLB  0
54B2:  GOTO   5A66 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
18EE:  MOVLW  01
18F0:  MOVLB  8
18F2:  MOVWF  x4D
18F4:  MOVWF  x4E
18F6:  MOVWF  x4F
18F8:  MOVWF  x50
18FA:  CLRF   x51
18FC:  MOVWF  x52
18FE:  MOVWF  x53
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1900:  MOVLB  6
1902:  CLRF   xD2
1904:  CLRF   xD1
....................    mcr_timeout=0; 
1906:  CLRF   xC7
1908:  CLRF   xC6
190A:  CLRF   xC5
190C:  CLRF   xC4
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
190E:  MOVF   xD2,W
1910:  SUBLW  FD
1912:  BNC   1930
1914:  BNZ   191C
1916:  MOVF   xD1,W
1918:  SUBLW  E7
191A:  BNC   1930
191C:  BSF    F93.1
191E:  BTFSS  F81.1
1920:  BRA    1930
1922:  BSF    F94.5
1924:  BTFSS  F82.5
1926:  BRA    1930
....................       card_timeout++; 
1928:  INCF   xD1,F
192A:  BTFSC  FD8.2
192C:  INCF   xD2,F
....................    } 
192E:  BRA    190E
....................    card_timeout=0; 
1930:  CLRF   xD2
1932:  CLRF   xD1
....................    buffertrack1[bug_countbit_T1++]=0; 
1934:  MOVFF  6CE,03
1938:  MOVF   xCD,W
193A:  INCF   xCD,F
193C:  BTFSC  FD8.2
193E:  INCF   xCE,F
1940:  MOVLB  8
1942:  MOVWF  x56
1944:  MOVLW  46
1946:  ADDWF  x56,W
1948:  MOVWF  FE9
194A:  MOVLW  02
194C:  ADDWFC 03,W
194E:  MOVWF  FEA
1950:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1952:  MOVLB  6
1954:  MOVFF  6CE,03
1958:  MOVF   xCD,W
195A:  INCF   xCD,F
195C:  BTFSC  FD8.2
195E:  INCF   xCE,F
1960:  MOVLB  8
1962:  MOVWF  x56
1964:  MOVLW  46
1966:  ADDWF  x56,W
1968:  MOVWF  FE9
196A:  MOVLW  02
196C:  ADDWFC 03,W
196E:  MOVWF  FEA
1970:  MOVLW  01
1972:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1974:  MOVLB  6
1976:  MOVFF  6D0,03
197A:  MOVF   xCF,W
197C:  INCF   xCF,F
197E:  BTFSC  FD8.2
1980:  INCF   xD0,F
1982:  MOVLB  8
1984:  MOVWF  x56
1986:  MOVLW  98
1988:  ADDWF  x56,W
198A:  MOVWF  FE9
198C:  MOVLW  05
198E:  ADDWFC 03,W
1990:  MOVWF  FEA
1992:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1994:  MOVLB  6
1996:  MOVFF  6D0,03
199A:  MOVF   xCF,W
199C:  INCF   xCF,F
199E:  BTFSC  FD8.2
19A0:  INCF   xD0,F
19A2:  MOVLB  8
19A4:  MOVWF  x56
19A6:  MOVLW  98
19A8:  ADDWF  x56,W
19AA:  MOVWF  FE9
19AC:  MOVLW  05
19AE:  ADDWFC 03,W
19B0:  MOVWF  FEA
19B2:  MOVLW  01
19B4:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
19B6:  MOVLB  6
19B8:  MOVF   xCE,W
19BA:  SUBLW  03
19BC:  BTFSS  FD8.0
19BE:  BRA    1A9E
19C0:  BNZ   19CA
19C2:  MOVF   xCD,W
19C4:  SUBLW  51
19C6:  BTFSS  FD8.0
19C8:  BRA    1A9E
19CA:  MOVF   xD0,W
19CC:  SUBLW  01
19CE:  BTFSS  FD8.0
19D0:  BRA    1A9E
19D2:  BNZ   19DA
19D4:  MOVF   xCF,W
19D6:  SUBLW  2B
19D8:  BNC   1A9E
19DA:  MOVF   xD2,W
19DC:  SUBLW  FF
19DE:  BNC   1A9E
19E0:  BNZ   19E8
19E2:  MOVF   xD1,W
19E4:  SUBLW  DB
19E6:  BNC   1A9E
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
19E8:  MOVF   xDB,F
19EA:  BZ    19F4
....................          { 
....................             bug_countbit_T1=0; 
19EC:  CLRF   xCE
19EE:  CLRF   xCD
....................             bug_countbit_T2=0; 
19F0:  CLRF   xD0
19F2:  CLRF   xCF
....................          } 
....................          card_timeout++; 
19F4:  INCF   xD1,F
19F6:  BTFSC  FD8.2
19F8:  INCF   xD2,F
....................          mcr_timeout=0; 
19FA:  CLRF   xC7
19FC:  CLRF   xC6
19FE:  CLRF   xC5
1A00:  CLRF   xC4
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1A02:  BSF    F93.2
1A04:  MOVLB  8
1A06:  CLRF   x4D
1A08:  BTFSC  F81.2
1A0A:  INCF   x4D,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1A0C:  MOVF   x4D,F
1A0E:  BNZ   1A4C
1A10:  DECFSZ x4E,W
1A12:  BRA    1A4C
....................          { 
....................             ST1_old = 0; 
1A14:  CLRF   x4E
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1A16:  MOVLW  46
1A18:  MOVLB  6
1A1A:  ADDWF  xCD,W
1A1C:  MOVWF  FE9
1A1E:  MOVLW  02
1A20:  ADDWFC xCE,W
1A22:  MOVWF  FEA
1A24:  BSF    F93.1
1A26:  MOVLW  00
1A28:  BTFSS  F81.1
1A2A:  MOVLW  01
1A2C:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1A2E:  MOVLW  98
1A30:  ADDWF  xCF,W
1A32:  MOVWF  FE9
1A34:  MOVLW  05
1A36:  ADDWFC xD0,W
1A38:  MOVWF  FEA
1A3A:  MOVFF  851,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1A3E:  INCF   xCD,F
1A40:  BTFSC  FD8.2
1A42:  INCF   xCE,F
....................             card_timeout=0; 
1A44:  CLRF   xD2
1A46:  CLRF   xD1
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A48:  BRA    1A56
1A4A:  MOVLB  8
1A4C:  DECFSZ x4D,W
1A4E:  BRA    1A54
1A50:  MOVLW  01
1A52:  MOVWF  x4E
1A54:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A56:  BSF    F93.3
1A58:  MOVLB  8
1A5A:  CLRF   x4F
1A5C:  BTFSC  F81.3
1A5E:  INCF   x4F,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A60:  MOVF   x4F,F
1A62:  BNZ   1A82
1A64:  DECFSZ x50,W
1A66:  BRA    1A82
....................          { 
....................             ST2_old = 0; 
1A68:  CLRF   x50
....................             Bit_t2 = !input(MCR_DATA2); 
1A6A:  BSF    F94.5
1A6C:  CLRF   x51
1A6E:  BTFSS  F82.5
1A70:  INCF   x51,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A72:  MOVLB  6
1A74:  INCF   xCF,F
1A76:  BTFSC  FD8.2
1A78:  INCF   xD0,F
....................             card_timeout=0; 
1A7A:  CLRF   xD2
1A7C:  CLRF   xD1
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A7E:  BRA    1A8C
1A80:  MOVLB  8
1A82:  DECFSZ x4F,W
1A84:  BRA    1A8A
1A86:  MOVLW  01
1A88:  MOVWF  x50
1A8A:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1A8C:  BSF    F93.0
1A8E:  BTFSS  F81.0
1A90:  BRA    1A9C
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1A92:  CLRF   xDB
....................             card_timeout=65500; 
1A94:  SETF   xD2
1A96:  MOVLW  DC
1A98:  MOVWF  xD1
....................             break;            
1A9A:  BRA    1A9E
....................          } 
....................       } 
1A9C:  BRA    19B8
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1A9E:  CLRF   xD2
1AA0:  CLRF   xD1
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1AA2:  MOVLB  9
1AA4:  CLRF   x15
1AA6:  MOVFF  6CE,917
1AAA:  MOVFF  6CD,916
1AAE:  MOVLW  02
1AB0:  MOVWF  x19
1AB2:  MOVLW  46
1AB4:  MOVWF  x18
1AB6:  MOVLB  0
1AB8:  CALL   0A02
1ABC:  MOVFF  01,852
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1AC0:  MOVLW  01
1AC2:  MOVLB  9
1AC4:  MOVWF  x15
1AC6:  MOVFF  6D0,917
1ACA:  MOVFF  6CF,916
1ACE:  MOVLW  05
1AD0:  MOVWF  x19
1AD2:  MOVLW  98
1AD4:  MOVWF  x18
1AD6:  MOVLB  0
1AD8:  CALL   0A02
1ADC:  MOVFF  01,853
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1AE0:  MOVLB  6
1AE2:  DECFSZ xD6,W
1AE4:  BRA    1B7A
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1AE6:  MOVLW  32
1AE8:  MOVWF  FF6
1AEA:  MOVLW  06
1AEC:  MOVWF  FF7
1AEE:  MOVLW  0E
1AF0:  MOVLB  8
1AF2:  MOVWF  xF7
1AF4:  MOVLB  0
1AF6:  RCALL  164A
1AF8:  MOVLW  10
1AFA:  MOVWF  FE9
1AFC:  MOVFF  6CE,857
1B00:  MOVFF  6CD,856
1B04:  RCALL  1672
1B06:  MOVLW  0D
1B08:  MOVLB  9
1B0A:  MOVWF  x0C
1B0C:  MOVLB  0
1B0E:  RCALL  1604
1B10:  MOVLW  0A
1B12:  MOVLB  9
1B14:  MOVWF  x0C
1B16:  MOVLB  0
1B18:  RCALL  1604
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1B1A:  MOVLW  46
1B1C:  MOVWF  FF6
1B1E:  MOVLW  06
1B20:  MOVWF  FF7
1B22:  MOVLW  0E
1B24:  MOVLB  8
1B26:  MOVWF  xF7
1B28:  MOVLB  0
1B2A:  RCALL  164A
1B2C:  MOVLW  10
1B2E:  MOVWF  FE9
1B30:  MOVFF  6D0,857
1B34:  MOVFF  6CF,856
1B38:  RCALL  1672
1B3A:  MOVLW  0D
1B3C:  MOVLB  9
1B3E:  MOVWF  x0C
1B40:  MOVLB  0
1B42:  RCALL  1604
1B44:  MOVLW  0A
1B46:  MOVLB  9
1B48:  MOVWF  x0C
1B4A:  MOVLB  0
1B4C:  RCALL  1604
....................          debug_reader();       
1B4E:  BRA    1836
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B50:  MOVLB  8
1B52:  MOVF   x52,F
1B54:  BNZ   1B64
1B56:  MOVLW  5A
1B58:  MOVWF  FF6
1B5A:  MOVLW  06
1B5C:  MOVWF  FF7
1B5E:  MOVLB  0
1B60:  RCALL  172E
1B62:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B64:  MOVF   x53,F
1B66:  BNZ   1B76
1B68:  MOVLW  70
1B6A:  MOVWF  FF6
1B6C:  MOVLW  06
1B6E:  MOVWF  FF7
1B70:  MOVLB  0
1B72:  RCALL  172E
1B74:  MOVLB  8
....................       } 
....................          else 
1B76:  BRA    1B86
1B78:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B7A:  MOVLW  0F
1B7C:  MOVLB  8
1B7E:  MOVWF  x56
1B80:  MOVLB  0
1B82:  RCALL  18C6
1B84:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1B86:  MOVF   x52,F
1B88:  BZ    1B8E
1B8A:  MOVF   x53,F
1B8C:  BNZ   1BAE
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1B8E:  MOVLB  6
1B90:  CLRF   xD0
1B92:  CLRF   xCF
....................          bug_countbit_T1=0; 
1B94:  CLRF   xCE
1B96:  CLRF   xCD
....................          reading_fg=0; 
1B98:  CLRF   xDA
....................          count_reading_error++; 
1B9A:  INCF   xDB,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1B9C:  CLRF   xC7
1B9E:  CLRF   xC6
1BA0:  CLRF   xC5
1BA2:  CLRF   xC4
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1BA4:  MOVLW  00
1BA6:  MOVWF  01
1BA8:  BRA    1BE8
....................       } 
....................          else  
1BAA:  BRA    1BE4
1BAC:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1BAE:  MOVLW  01
1BB0:  MOVLB  6
1BB2:  MOVWF  xD5
....................             reading_fg=1; 
1BB4:  MOVWF  xDA
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1BB6:  MOVFF  6D0,6CC
1BBA:  MOVFF  6CF,6CB
....................             countbit_T1=bug_countbit_T1; 
1BBE:  MOVFF  6CE,6CA
1BC2:  MOVFF  6CD,6C9
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1BC6:  CLRF   xCE
1BC8:  CLRF   xCD
....................             bug_countbit_T2=0;  
1BCA:  CLRF   xD0
1BCC:  CLRF   xCF
....................             mcr_timeout=0; 
1BCE:  CLRF   xC7
1BD0:  CLRF   xC6
1BD2:  CLRF   xC5
1BD4:  CLRF   xC4
....................             charac_timeout=0; 
1BD6:  MOVLB  1
1BD8:  CLRF   x00
1BDA:  MOVLB  0
1BDC:  CLRF   xFF
....................             return 1; 
1BDE:  MOVWF  01
1BE0:  MOVLB  6
1BE2:  BRA    1BE8
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1BE4:  MOVLW  00
1BE6:  MOVWF  01
.................... } 
1BE8:  MOVLB  0
1BEA:  GOTO   1C10 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       delay_us(500); 
1BEE:  MOVLW  02
1BF0:  MOVLB  8
1BF2:  MOVWF  x4D
1BF4:  MOVLW  FA
1BF6:  MOVWF  x4E
1BF8:  MOVLB  0
1BFA:  GOTO   0686
1BFE:  MOVLB  8
1C00:  DECFSZ x4D,F
1C02:  BRA    1BF4
....................       if(saving_flag==1) return;      
1C04:  MOVLB  6
1C06:  DECFSZ xD8,W
1C08:  BRA    1C0C
1C0A:  BRA    1C22
....................       cardread_st=mcr_read(); 
1C0C:  MOVLB  0
1C0E:  BRA    18EE
1C10:  MOVFF  01,6D7
....................       mcr_timeout=0; 
1C14:  MOVLB  6
1C16:  CLRF   xC7
1C18:  CLRF   xC6
1C1A:  CLRF   xC5
1C1C:  CLRF   xC4
....................       card_timeout=0;      
1C1E:  CLRF   xD2
1C20:  CLRF   xD1
.................... } 
.................... //==================================== 
.................... #if 0 
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... #endif 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
1C22:  BCF    FF0.0
1C24:  MOVLB  0
1C26:  GOTO   006C
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
6A24:  CLRF   19
6A26:  BTFSC  FF2.7
6A28:  BSF    19.7
6A2A:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
6A2C:  MOVLB  9
6A2E:  CLRF   x16
6A30:  CLRF   x15
6A32:  CLRF   x14
6A34:  MOVLW  3C
6A36:  MOVWF  x13
6A38:  MOVLW  03
6A3A:  MOVWF  x17
6A3C:  MOVLB  0
6A3E:  CALL   3A6C
6A42:  BTFSC  19.7
6A44:  BSF    FF2.7
6A46:  CLRF   19
6A48:  BTFSC  FF2.7
6A4A:  BSF    19.7
6A4C:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
6A4E:  MOVLB  9
6A50:  CLRF   x16
6A52:  CLRF   x15
6A54:  CLRF   x14
6A56:  MOVLW  3A
6A58:  MOVWF  x13
6A5A:  MOVLW  01
6A5C:  MOVWF  x17
6A5E:  MOVLB  0
6A60:  CALL   3A6C
6A64:  BTFSC  19.7
6A66:  BSF    FF2.7
6A68:  CLRF   19
6A6A:  BTFSC  FF2.7
6A6C:  BSF    19.7
6A6E:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV);  
6A70:  MOVLB  9
6A72:  CLRF   x1B
6A74:  CLRF   x1A
6A76:  CLRF   x19
6A78:  MOVLW  3A
6A7A:  MOVWF  x18
6A7C:  MOVLB  0
6A7E:  CALL   3450
6A82:  BTFSC  19.7
6A84:  BSF    FF2.7
6A86:  MOVFF  01,6E2
.................... } 
6A8A:  GOTO   6E2E (RETURN)
.................... //================================ 
.................... void downloaddataregular() 
.................... { 
*
6298:  MOVLB  7
629A:  CLRF   xF6
629C:  CLRF   xF5
....................     int8 index,i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 temp[50]; 
....................     rec[0]=0; 
629E:  MOVLB  0
62A0:  CLRF   x7D
62A2:  CLRF   19
62A4:  BTFSC  FF2.7
62A6:  BSF    19.7
62A8:  BCF    FF2.7
....................     count_card_tg=get_countcard(); 
62AA:  CALL   351C
62AE:  BTFSC  19.7
62B0:  BSF    FF2.7
62B2:  MOVFF  02,6E1
62B6:  MOVFF  01,6E0
62BA:  CLRF   19
62BC:  BTFSC  FF2.7
62BE:  BSF    19.7
62C0:  BCF    FF2.7
....................     adr=count_card*numdata; 
62C2:  MOVFF  6DF,856
62C6:  MOVFF  6DE,855
62CA:  MOVLB  8
62CC:  CLRF   x58
62CE:  MOVLW  7C
62D0:  MOVWF  x57
62D2:  MOVLB  0
62D4:  CALL   3578
62D8:  BTFSC  19.7
62DA:  BSF    FF2.7
62DC:  MOVFF  02,7F6
62E0:  MOVFF  01,7F5
....................     addr_key=EEPROM_KEY_ST; 
62E4:  MOVLB  6
62E6:  CLRF   xE6
62E8:  CLRF   xE5
62EA:  MOVLW  E1
62EC:  MOVWF  xE4
62EE:  MOVLW  01
62F0:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
62F2:  MOVF   xDF,W
62F4:  SUBWF  xE1,W
62F6:  BTFSS  FD8.0
62F8:  BRA    6692
62FA:  BNZ   6304
62FC:  MOVF   xDE,W
62FE:  SUBWF  xE0,W
6300:  BTFSS  FD8.0
6302:  BRA    6692
6304:  CLRF   19
6306:  BTFSC  FF2.7
6308:  BSF    19.7
630A:  BCF    FF2.7
....................         adr=count_card*numdata+ptr_start; 
630C:  MOVFF  6DF,856
6310:  MOVFF  6DE,855
6314:  MOVLB  8
6316:  CLRF   x58
6318:  MOVLW  7C
631A:  MOVWF  x57
631C:  MOVLB  0
631E:  CALL   3578
6322:  BTFSC  19.7
6324:  BSF    FF2.7
6326:  MOVLW  96
6328:  MOVLB  8
632A:  ADDWF  01,W
632C:  MOVLB  7
632E:  MOVWF  xF5
6330:  MOVLW  00
6332:  MOVLB  8
6334:  ADDWFC 02,W
6336:  MOVLB  7
6338:  MOVWF  xF6
....................         EEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
633A:  MOVLW  7C
633C:  SUBWF  xF5,W
633E:  MOVLB  8
6340:  MOVWF  x2B
6342:  MOVLW  00
6344:  MOVLB  7
6346:  SUBWFB xF6,W
6348:  MOVLB  8
634A:  MOVWF  x2C
634C:  CLRF   19
634E:  BTFSC  FF2.7
6350:  BSF    19.7
6352:  BCF    FF2.7
6354:  MOVLB  9
6356:  CLRF   x07
6358:  CLRF   x06
635A:  MOVWF  x05
635C:  MOVFF  82B,904
6360:  CLRF   x0B
6362:  CLRF   x0A
6364:  CLRF   x09
6366:  MOVLW  7C
6368:  MOVWF  x08
636A:  CLRF   x0D
636C:  MOVLW  7D
636E:  MOVWF  x0C
6370:  MOVLB  0
6372:  CALL   3FF6
6376:  BTFSC  19.7
6378:  BSF    FF2.7
....................         fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
637A:  MOVLW  10
637C:  MOVWF  FE9
637E:  CLRF   19
6380:  BTFSC  FF2.7
6382:  BSF    19.7
6384:  BCF    FF2.7
6386:  MOVFF  6DF,851
638A:  MOVFF  6DE,850
638E:  CALL   58E4
6392:  BTFSC  19.7
6394:  BSF    FF2.7
6396:  CLRF   19
6398:  BTFSC  FF2.7
639A:  BSF    19.7
639C:  BCF    FF2.7
639E:  MOVLW  29
63A0:  MOVLB  9
63A2:  MOVWF  x0C
63A4:  MOVLB  0
63A6:  CALL   1604
63AA:  BTFSC  19.7
63AC:  BSF    FF2.7
63AE:  MOVFF  7D,82B
63B2:  MOVLW  01
63B4:  MOVLB  8
63B6:  MOVWF  x2C
63B8:  MOVLB  0
63BA:  RCALL  6182
63BC:  CLRF   19
63BE:  BTFSC  FF2.7
63C0:  BSF    19.7
63C2:  BCF    FF2.7
63C4:  MOVLW  2F
63C6:  MOVLB  9
63C8:  MOVWF  x0C
63CA:  MOVLB  0
63CC:  CALL   1604
63D0:  BTFSC  19.7
63D2:  BSF    FF2.7
63D4:  MOVFF  7E,82B
63D8:  MOVLW  01
63DA:  MOVLB  8
63DC:  MOVWF  x2C
63DE:  MOVLB  0
63E0:  RCALL  6182
63E2:  CLRF   19
63E4:  BTFSC  FF2.7
63E6:  BSF    19.7
63E8:  BCF    FF2.7
63EA:  MOVLW  20
63EC:  MOVLB  9
63EE:  MOVWF  x0C
63F0:  MOVLB  0
63F2:  CALL   1604
63F6:  BTFSC  19.7
63F8:  BSF    FF2.7
63FA:  MOVFF  7F,82B
63FE:  MOVLW  01
6400:  MOVLB  8
6402:  MOVWF  x2C
6404:  MOVLB  0
6406:  RCALL  6182
6408:  CLRF   19
640A:  BTFSC  FF2.7
640C:  BSF    19.7
640E:  BCF    FF2.7
6410:  MOVLW  3A
6412:  MOVLB  9
6414:  MOVWF  x0C
6416:  MOVLB  0
6418:  CALL   1604
641C:  BTFSC  19.7
641E:  BSF    FF2.7
6420:  MOVFF  80,82B
6424:  MOVLW  01
6426:  MOVLB  8
6428:  MOVWF  x2C
642A:  MOVLB  0
642C:  RCALL  6182
642E:  CLRF   19
6430:  BTFSC  FF2.7
6432:  BSF    19.7
6434:  BCF    FF2.7
6436:  MOVLW  3A
6438:  MOVLB  9
643A:  MOVWF  x0C
643C:  MOVLB  0
643E:  CALL   1604
6442:  BTFSC  19.7
6444:  BSF    FF2.7
6446:  MOVFF  81,82B
644A:  MOVLW  01
644C:  MOVLB  8
644E:  MOVWF  x2C
6450:  MOVLB  0
6452:  RCALL  6182
....................         ee_dat=0; 
6454:  MOVLB  6
6456:  CLRF   xDD
....................         index=0; 
6458:  MOVLB  7
645A:  CLRF   xF3
....................         fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
645C:  MOVLW  2A
645E:  MOVWF  FF6
6460:  MOVLW  1C
6462:  MOVWF  FF7
6464:  CLRF   19
6466:  BTFSC  FF2.7
6468:  BSF    19.7
646A:  BCF    FF2.7
646C:  MOVLB  0
646E:  CALL   172E
6472:  BTFSC  19.7
6474:  BSF    FF2.7
....................         while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................         { 
6476:  MOVLB  7
6478:  MOVF   xF3,W
647A:  SUBLW  4E
647C:  BNC   64DA
647E:  MOVLB  6
6480:  MOVF   xDD,W
6482:  SUBLW  3F
6484:  BTFSS  FD8.2
6486:  BRA    648C
6488:  MOVLB  7
648A:  BRA    64DA
....................            ee_dat = rec[index+5]; 
648C:  MOVLW  05
648E:  MOVLB  7
6490:  ADDWF  xF3,W
6492:  CLRF   03
6494:  ADDLW  7D
6496:  MOVWF  FE9
6498:  MOVLW  00
649A:  ADDWFC 03,W
649C:  MOVWF  FEA
649E:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
64A2:  MOVLB  6
64A4:  MOVF   xDD,W
64A6:  SUBLW  1F
64A8:  BC    64C6
64AA:  MOVF   xDD,W
64AC:  SUBLW  7E
64AE:  BNC   64C6
64B0:  CLRF   19
64B2:  BTFSC  FF2.7
64B4:  BSF    19.7
64B6:  BCF    FF2.7
64B8:  MOVFF  6DD,90C
64BC:  MOVLB  0
64BE:  CALL   1604
64C2:  BTFSC  19.7
64C4:  BSF    FF2.7
....................            index++; 
64C6:  MOVLB  7
64C8:  INCF   xF3,F
....................            if(ee_dat==0)break; 
64CA:  MOVLB  6
64CC:  MOVF   xDD,F
64CE:  BNZ   64D4
64D0:  MOVLB  7
64D2:  BRA    64DA
....................         } 
64D4:  MOVLB  0
64D6:  BRA    6476
64D8:  MOVLB  7
....................         fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
64DA:  MOVLW  3C
64DC:  MOVWF  FF6
64DE:  MOVLW  1C
64E0:  MOVWF  FF7
64E2:  CLRF   19
64E4:  BTFSC  FF2.7
64E6:  BSF    19.7
64E8:  BCF    FF2.7
64EA:  MOVLB  0
64EC:  CALL   172E
64F0:  BTFSC  19.7
64F2:  BSF    FF2.7
....................         index=0; 
64F4:  MOVLB  7
64F6:  CLRF   xF3
....................         ee_dat=0; 
64F8:  MOVLB  6
64FA:  CLRF   xDD
....................         while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................         { 
64FC:  MOVLB  7
64FE:  MOVF   xF3,W
6500:  SUBLW  27
6502:  BNC   6562
6504:  MOVLB  6
6506:  MOVF   xDD,W
6508:  SUBLW  3F
650A:  BTFSS  FD8.2
650C:  BRA    6512
650E:  MOVLB  7
6510:  BRA    6562
....................            ee_dat = rec[index+5+numbyteoftrack1]; 
6512:  MOVLW  05
6514:  MOVLB  7
6516:  ADDWF  xF3,W
6518:  ADDLW  4F
651A:  CLRF   03
651C:  ADDLW  7D
651E:  MOVWF  FE9
6520:  MOVLW  00
6522:  ADDWFC 03,W
6524:  MOVWF  FEA
6526:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
652A:  MOVLB  6
652C:  MOVF   xDD,W
652E:  SUBLW  1F
6530:  BC    654E
6532:  MOVF   xDD,W
6534:  SUBLW  7E
6536:  BNC   654E
6538:  CLRF   19
653A:  BTFSC  FF2.7
653C:  BSF    19.7
653E:  BCF    FF2.7
6540:  MOVFF  6DD,90C
6544:  MOVLB  0
6546:  CALL   1604
654A:  BTFSC  19.7
654C:  BSF    FF2.7
....................            index++; 
654E:  MOVLB  7
6550:  INCF   xF3,F
....................            if(ee_dat==0)break; 
6552:  MOVLB  6
6554:  MOVF   xDD,F
6556:  BNZ   655E
6558:  MOVLB  7
655A:  BRA    6562
655C:  MOVLB  6
....................         } 
655E:  BRA    64FC
6560:  MOVLB  7
....................         index=0; 
6562:  CLRF   xF3
....................  
....................         fprintf(COM2,"\r\nPIN Number:\r\n"); 
6564:  MOVLW  4E
6566:  MOVWF  FF6
6568:  MOVLW  1C
656A:  MOVWF  FF7
656C:  CLRF   19
656E:  BTFSC  FF2.7
6570:  BSF    19.7
6572:  BCF    FF2.7
6574:  MOVLB  0
6576:  CALL   172E
657A:  BTFSC  19.7
657C:  BSF    FF2.7
....................  
....................         if((ptr_card_key>addr_key)) //&& 
657E:  MOVLB  6
6580:  MOVF   xE6,W
6582:  SUBWF  27,W
6584:  BTFSS  FD8.0
6586:  BRA    668A
6588:  BNZ   65A6
658A:  MOVF   xE5,W
658C:  SUBWF  26,W
658E:  BTFSS  FD8.0
6590:  BRA    668A
6592:  BNZ   65A6
6594:  MOVF   xE4,W
6596:  SUBWF  25,W
6598:  BTFSS  FD8.0
659A:  BRA    668A
659C:  BNZ   65A6
659E:  MOVF   24,W
65A0:  SUBWF  xE3,W
65A2:  BTFSC  FD8.0
65A4:  BRA    668A
....................         { 
....................            i=0; 
65A6:  MOVLB  7
65A8:  CLRF   xF4
....................            do 
....................            { 
....................               ee_dat=read_ext_eeprom(i+addr_key); 
65AA:  MOVF   xF4,W
65AC:  MOVLB  6
65AE:  ADDWF  xE3,W
65B0:  MOVLB  8
65B2:  MOVWF  x2B
65B4:  MOVLW  00
65B6:  MOVLB  6
65B8:  ADDWFC xE4,W
65BA:  MOVLB  8
65BC:  MOVWF  x2C
65BE:  MOVLW  00
65C0:  MOVLB  6
65C2:  ADDWFC xE5,W
65C4:  MOVLB  8
65C6:  MOVWF  x2D
65C8:  MOVLW  00
65CA:  MOVLB  6
65CC:  ADDWFC xE6,W
65CE:  MOVLB  8
65D0:  MOVWF  x2E
65D2:  CLRF   19
65D4:  BTFSC  FF2.7
65D6:  BSF    19.7
65D8:  BCF    FF2.7
65DA:  MOVFF  FE8,91B
65DE:  MOVFF  82D,91A
65E2:  MOVFF  82C,919
65E6:  MOVFF  82B,918
65EA:  MOVLB  0
65EC:  CALL   3450
65F0:  BTFSC  19.7
65F2:  BSF    FF2.7
65F4:  MOVFF  01,6DD
....................               if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
65F8:  MOVLB  6
65FA:  MOVF   xDD,W
65FC:  SUBLW  2F
65FE:  BC    6606
6600:  MOVF   xDD,W
6602:  SUBLW  39
6604:  BC    661E
6606:  MOVF   xDD,W
6608:  SUBLW  23
660A:  BZ    661E
660C:  MOVF   xDD,W
660E:  SUBLW  2A
6610:  BZ    661E
6612:  MOVF   xDD,W
6614:  SUBLW  40
6616:  BC    6634
6618:  MOVF   xDD,W
661A:  SUBLW  5A
661C:  BNC   6634
661E:  CLRF   19
6620:  BTFSC  FF2.7
6622:  BSF    19.7
6624:  BCF    FF2.7
....................               { 
....................                  fprintf(COM2,"%c",ee_dat); 
6626:  MOVFF  6DD,90C
662A:  MOVLB  0
662C:  CALL   1604
6630:  BTFSC  19.7
6632:  BSF    FF2.7
....................               } 
....................               i++; 
6634:  MOVLB  7
6636:  INCF   xF4,F
....................            } 
....................            while((i<wideofkeystore)&&(ee_dat!=0)); 
6638:  MOVF   xF4,W
663A:  SUBLW  0F
663C:  BNC   664A
663E:  MOVLB  6
6640:  MOVF   xDD,F
6642:  BTFSC  FD8.2
6644:  BRA    664A
6646:  MOVLB  7
6648:  BRA    65AA
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
664A:  MOVLW  10
664C:  MOVLB  6
664E:  ADDWF  xE3,F
6650:  MOVLW  00
6652:  ADDWFC xE4,F
6654:  ADDWFC xE5,F
6656:  ADDWFC xE6,F
6658:  CLRF   19
665A:  BTFSC  FF2.7
665C:  BSF    19.7
665E:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
6660:  MOVLW  0A
6662:  MOVLB  9
6664:  MOVWF  x0C
6666:  MOVLB  0
6668:  CALL   1604
666C:  BTFSC  19.7
666E:  BSF    FF2.7
6670:  CLRF   19
6672:  BTFSC  FF2.7
6674:  BSF    19.7
6676:  BCF    FF2.7
6678:  MOVLW  0D
667A:  MOVLB  9
667C:  MOVWF  x0C
667E:  MOVLB  0
6680:  CALL   1604
6684:  BTFSC  19.7
6686:  BSF    FF2.7
6688:  MOVLB  6
....................         } 
....................         count_card++; 
668A:  INCF   xDE,F
668C:  BTFSC  FD8.2
668E:  INCF   xDF,F
....................     }  
6690:  BRA    62F2
.................... } 
6692:  MOVLB  0
6694:  GOTO   6C60 (RETURN)
.................... //================================ 
.................... void downloaddataEncrypt() 
.................... { 
6698:  MOVLB  7
669A:  CLRF   xF5
669C:  CLRF   xF4
669E:  CLRF   19
66A0:  BTFSC  FF2.7
66A2:  BSF    19.7
66A4:  BCF    FF2.7
....................     int8 i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 keydatatemp[16]; 
....................     count_card_tg=get_countcard(); 
66A6:  MOVLB  0
66A8:  CALL   351C
66AC:  BTFSC  19.7
66AE:  BSF    FF2.7
66B0:  MOVFF  02,6E1
66B4:  MOVFF  01,6E0
....................     adr=count_card*numdataofonecard; 
66B8:  MOVLB  6
66BA:  RLCF   xDE,W
66BC:  MOVLB  7
66BE:  MOVWF  xF4
66C0:  MOVLB  6
66C2:  RLCF   xDF,W
66C4:  MOVLB  7
66C6:  MOVWF  xF5
66C8:  RLCF   xF4,F
66CA:  RLCF   xF5,F
66CC:  RLCF   xF4,F
66CE:  RLCF   xF5,F
66D0:  RLCF   xF4,F
66D2:  RLCF   xF5,F
66D4:  RLCF   xF4,F
66D6:  RLCF   xF5,F
66D8:  RLCF   xF4,F
66DA:  RLCF   xF5,F
66DC:  RLCF   xF4,F
66DE:  RLCF   xF5,F
66E0:  MOVLW  80
66E2:  ANDWF  xF4,F
....................     addr_key=EEPROM_KEY_ST; 
66E4:  MOVLB  6
66E6:  CLRF   xE6
66E8:  CLRF   xE5
66EA:  MOVLW  E1
66EC:  MOVWF  xE4
66EE:  MOVLW  01
66F0:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
66F2:  MOVF   xDF,W
66F4:  SUBWF  xE1,W
66F6:  BTFSS  FD8.0
66F8:  BRA    68B0
66FA:  BNZ   6704
66FC:  MOVF   xDE,W
66FE:  SUBWF  xE0,W
6700:  BTFSS  FD8.0
6702:  BRA    68B0
....................         adr=count_card*numdataofonecard+ptr_start; 
6704:  RLCF   xDE,W
6706:  MOVLB  8
6708:  MOVWF  x08
670A:  MOVLB  6
670C:  RLCF   xDF,W
670E:  MOVLB  8
6710:  MOVWF  x09
6712:  RLCF   x08,F
6714:  RLCF   x09,F
6716:  RLCF   x08,F
6718:  RLCF   x09,F
671A:  RLCF   x08,F
671C:  RLCF   x09,F
671E:  RLCF   x08,F
6720:  RLCF   x09,F
6722:  RLCF   x08,F
6724:  RLCF   x09,F
6726:  RLCF   x08,F
6728:  RLCF   x09,F
672A:  MOVLW  80
672C:  ANDWF  x08,F
672E:  MOVLW  96
6730:  ADDWF  x08,W
6732:  MOVLB  7
6734:  MOVWF  xF4
6736:  MOVLW  00
6738:  MOVLB  8
673A:  ADDWFC x09,W
673C:  MOVLB  7
673E:  MOVWF  xF5
....................         memset(rec,0,sizeof(rec)); 
6740:  CLRF   FEA
6742:  MOVLW  7D
6744:  MOVWF  FE9
6746:  CLRF   00
6748:  CLRF   02
674A:  MOVLW  80
674C:  MOVWF  01
674E:  MOVLB  0
6750:  CALL   359A
....................         EEPROM_read((unsigned int16)(adr-numdataofonecard),numdataofonecard,rec); 
6754:  MOVLW  80
6756:  MOVLB  7
6758:  SUBWF  xF4,W
675A:  MOVLB  8
675C:  MOVWF  x08
675E:  MOVLW  00
6760:  MOVLB  7
6762:  SUBWFB xF5,W
6764:  MOVLB  8
6766:  MOVWF  x09
6768:  CLRF   19
676A:  BTFSC  FF2.7
676C:  BSF    19.7
676E:  BCF    FF2.7
6770:  MOVLB  9
6772:  CLRF   x07
6774:  CLRF   x06
6776:  MOVWF  x05
6778:  MOVFF  808,904
677C:  CLRF   x0B
677E:  CLRF   x0A
6780:  CLRF   x09
6782:  MOVLW  80
6784:  MOVWF  x08
6786:  CLRF   x0D
6788:  MOVLW  7D
678A:  MOVWF  x0C
678C:  MOVLB  0
678E:  CALL   3FF6
6792:  BTFSC  19.7
6794:  BSF    FF2.7
....................         for(i=0;i<numdataofonecard;i++) 
6796:  MOVLB  7
6798:  CLRF   xF3
679A:  MOVF   xF3,W
679C:  SUBLW  7F
679E:  BNC   67D4
....................         { 
....................            fprintf(COM2,"%x",rec[i]);  
67A0:  CLRF   03
67A2:  MOVF   xF3,W
67A4:  ADDLW  7D
67A6:  MOVWF  FE9
67A8:  MOVLW  00
67AA:  ADDWFC 03,W
67AC:  MOVWF  FEA
67AE:  MOVFF  FEF,808
67B2:  CLRF   19
67B4:  BTFSC  FF2.7
67B6:  BSF    19.7
67B8:  BCF    FF2.7
67BA:  MOVFF  808,901
67BE:  MOVLW  57
67C0:  MOVLB  9
67C2:  MOVWF  x02
67C4:  MOVLB  0
67C6:  CALL   4FA4
67CA:  BTFSC  19.7
67CC:  BSF    FF2.7
....................         } 
67CE:  MOVLB  7
67D0:  INCF   xF3,F
67D2:  BRA    679A
....................  
....................         if((ptr_card_key>addr_key)) 
67D4:  MOVLB  6
67D6:  MOVF   xE6,W
67D8:  SUBWF  27,W
67DA:  BNC   68A8
67DC:  BNZ   67F4
67DE:  MOVF   xE5,W
67E0:  SUBWF  26,W
67E2:  BNC   68A8
67E4:  BNZ   67F4
67E6:  MOVF   xE4,W
67E8:  SUBWF  25,W
67EA:  BNC   68A8
67EC:  BNZ   67F4
67EE:  MOVF   24,W
67F0:  SUBWF  xE3,W
67F2:  BC    68A8
67F4:  CLRF   19
67F6:  BTFSC  FF2.7
67F8:  BSF    19.7
67FA:  BCF    FF2.7
....................         { 
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            EEPROM_read(addr_key,wideofkeystore,keydatatemp); 
67FC:  MOVFF  6E6,907
6800:  MOVFF  6E5,906
6804:  MOVFF  6E4,905
6808:  MOVFF  6E3,904
680C:  MOVLB  9
680E:  CLRF   x0B
6810:  CLRF   x0A
6812:  CLRF   x09
6814:  MOVLW  10
6816:  MOVWF  x08
6818:  MOVLW  07
681A:  MOVWF  x0D
681C:  MOVLW  F8
681E:  MOVWF  x0C
6820:  MOVLB  0
6822:  CALL   3FF6
6826:  BTFSC  19.7
6828:  BSF    FF2.7
....................            for(i=0;i<wideofkeystore;i++) 
682A:  MOVLB  7
682C:  CLRF   xF3
682E:  MOVF   xF3,W
6830:  SUBLW  0F
6832:  BNC   6868
....................            { 
....................                fprintf(COM2,"%x",keydatatemp[i]); 
6834:  CLRF   03
6836:  MOVF   xF3,W
6838:  ADDLW  F8
683A:  MOVWF  FE9
683C:  MOVLW  07
683E:  ADDWFC 03,W
6840:  MOVWF  FEA
6842:  MOVFF  FEF,808
6846:  CLRF   19
6848:  BTFSC  FF2.7
684A:  BSF    19.7
684C:  BCF    FF2.7
684E:  MOVFF  808,901
6852:  MOVLW  57
6854:  MOVLB  9
6856:  MOVWF  x02
6858:  MOVLB  0
685A:  CALL   4FA4
685E:  BTFSC  19.7
6860:  BSF    FF2.7
....................            } 
6862:  MOVLB  7
6864:  INCF   xF3,F
6866:  BRA    682E
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
6868:  MOVLW  10
686A:  MOVLB  6
686C:  ADDWF  xE3,F
686E:  MOVLW  00
6870:  ADDWFC xE4,F
6872:  ADDWFC xE5,F
6874:  ADDWFC xE6,F
6876:  CLRF   19
6878:  BTFSC  FF2.7
687A:  BSF    19.7
687C:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
687E:  MOVLW  0A
6880:  MOVLB  9
6882:  MOVWF  x0C
6884:  MOVLB  0
6886:  CALL   1604
688A:  BTFSC  19.7
688C:  BSF    FF2.7
688E:  CLRF   19
6890:  BTFSC  FF2.7
6892:  BSF    19.7
6894:  BCF    FF2.7
6896:  MOVLW  0D
6898:  MOVLB  9
689A:  MOVWF  x0C
689C:  MOVLB  0
689E:  CALL   1604
68A2:  BTFSC  19.7
68A4:  BSF    FF2.7
68A6:  MOVLB  6
....................         } 
....................         count_card++; 
68A8:  INCF   xDE,F
68AA:  BTFSC  FD8.2
68AC:  INCF   xDF,F
....................     }  
68AE:  BRA    66F2
.................... } 
68B0:  MOVLB  0
68B2:  GOTO   6C60 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int16 countchar; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
6BA2:  MOVLW  06
6BA4:  MOVWF  FEA
6BA6:  MOVLW  E7
6BA8:  MOVWF  FE9
6BAA:  GOTO   614E
6BAE:  CLRF   19
6BB0:  BTFSC  FF2.7
6BB2:  BSF    19.7
6BB4:  BCF    FF2.7
6BB6:  MOVLW  3E
6BB8:  MOVLB  9
6BBA:  MOVWF  x0C
6BBC:  MOVLB  0
6BBE:  CALL   1604
6BC2:  BTFSC  19.7
6BC4:  BSF    FF2.7
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
6BC6:  MOVLW  01
6BC8:  MOVLB  7
6BCA:  MOVWF  xF3
6BCC:  MOVLW  14
6BCE:  MOVWF  xF4
6BD0:  MOVLW  01
6BD2:  MOVWF  xF6
6BD4:  MOVLW  62
6BD6:  MOVWF  xF5
6BD8:  MOVLB  0
6BDA:  CALL   5F7E
6BDE:  CLRF   19
6BE0:  BTFSC  FF2.7
6BE2:  BSF    19.7
6BE4:  BCF    FF2.7
....................       printf("\n\r"); 
6BE6:  MOVLW  0A
6BE8:  MOVLB  9
6BEA:  MOVWF  x0C
6BEC:  MOVLB  0
6BEE:  CALL   1604
6BF2:  BTFSC  19.7
6BF4:  BSF    FF2.7
6BF6:  CLRF   19
6BF8:  BTFSC  FF2.7
6BFA:  BSF    19.7
6BFC:  BCF    FF2.7
6BFE:  MOVLW  0D
6C00:  MOVLB  9
6C02:  MOVWF  x0C
6C04:  MOVLB  0
6C06:  CALL   1604
6C0A:  BTFSC  19.7
6C0C:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
6C0E:  CLRF   FEA
6C10:  MOVLW  41
6C12:  MOVWF  FE9
6C14:  MOVLW  00
6C16:  CALL   0356
6C1A:  TBLRD*-
6C1C:  TBLRD*+
6C1E:  MOVF   FF5,W
6C20:  MOVWF  FEE
6C22:  IORLW  00
6C24:  BNZ   6C1C
....................       index=0; 
6C26:  MOVLB  7
6C28:  CLRF   xBD
....................       ee_dat=0; 
6C2A:  MOVLB  6
6C2C:  CLRF   xDD
....................       count_card=1; 
6C2E:  CLRF   xDF
6C30:  MOVLW  01
6C32:  MOVWF  xDE
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6C34:  MOVLB  7
6C36:  MOVWF  xF4
6C38:  MOVLW  62
6C3A:  MOVWF  xF3
6C3C:  CLRF   xF6
6C3E:  MOVLW  41
6C40:  MOVWF  xF5
6C42:  MOVLB  0
6C44:  CALL   60B6
6C48:  MOVF   01,F
6C4A:  BNZ   6C60
....................       { 
....................          if(cryption_enable==0) downloaddataregular(); 
6C4C:  MOVLB  1
6C4E:  MOVF   x22,F
6C50:  BNZ   6C5C
6C52:  MOVLB  0
6C54:  GOTO   6298
....................          else downloaddataEncrypt(); 
6C58:  MOVLB  0
6C5A:  BRA    6C60
6C5C:  MOVLB  0
6C5E:  BRA    6698
....................       }  
....................       strcpy(buffer2,"f"); 
6C60:  CLRF   FEA
6C62:  MOVLW  41
6C64:  MOVWF  FE9
6C66:  MOVLW  00
6C68:  CALL   0368
6C6C:  TBLRD*-
6C6E:  TBLRD*+
6C70:  MOVF   FF5,W
6C72:  MOVWF  FEE
6C74:  IORLW  00
6C76:  BNZ   6C6E
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6C78:  MOVLW  01
6C7A:  MOVLB  7
6C7C:  MOVWF  xF4
6C7E:  MOVLW  62
6C80:  MOVWF  xF3
6C82:  CLRF   xF6
6C84:  MOVLW  41
6C86:  MOVWF  xF5
6C88:  MOVLB  0
6C8A:  CALL   60B6
6C8E:  MOVF   01,F
6C90:  BNZ   6CC4
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6C92:  MOVLW  5E
6C94:  MOVWF  FF6
6C96:  MOVLW  1C
6C98:  MOVWF  FF7
6C9A:  CLRF   19
6C9C:  BTFSC  FF2.7
6C9E:  BSF    19.7
6CA0:  BCF    FF2.7
6CA2:  CALL   172E
6CA6:  BTFSC  19.7
6CA8:  BSF    FF2.7
....................          format_eepromext(); 
6CAA:  BRA    68B6
....................          fprintf(COM2," exit\n\r");  
6CAC:  MOVLW  6C
6CAE:  MOVWF  FF6
6CB0:  MOVLW  1C
6CB2:  MOVWF  FF7
6CB4:  CLRF   19
6CB6:  BTFSC  FF2.7
6CB8:  BSF    19.7
6CBA:  BCF    FF2.7
6CBC:  CALL   172E
6CC0:  BTFSC  19.7
6CC2:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
6CC4:  CLRF   FEA
6CC6:  MOVLW  41
6CC8:  MOVWF  FE9
6CCA:  MOVLW  00
6CCC:  CALL   037A
6CD0:  TBLRD*-
6CD2:  TBLRD*+
6CD4:  MOVF   FF5,W
6CD6:  MOVWF  FEE
6CD8:  IORLW  00
6CDA:  BNZ   6CD2
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6CDC:  MOVLW  01
6CDE:  MOVLB  7
6CE0:  MOVWF  xF4
6CE2:  MOVLW  62
6CE4:  MOVWF  xF3
6CE6:  CLRF   xF6
6CE8:  MOVLW  41
6CEA:  MOVWF  xF5
6CEC:  MOVLB  0
6CEE:  CALL   60B6
6CF2:  MOVF   01,F
6CF4:  BNZ   6D28
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6CF6:  MOVLW  74
6CF8:  MOVWF  FF6
6CFA:  MOVLW  1C
6CFC:  MOVWF  FF7
6CFE:  CLRF   19
6D00:  BTFSC  FF2.7
6D02:  BSF    19.7
6D04:  BCF    FF2.7
6D06:  CALL   172E
6D0A:  BTFSC  19.7
6D0C:  BSF    FF2.7
....................          ease_eeprom(); 
6D0E:  BRA    6950
....................          fprintf(COM2," exit\n\r");  
6D10:  MOVLW  82
6D12:  MOVWF  FF6
6D14:  MOVLW  1C
6D16:  MOVWF  FF7
6D18:  CLRF   19
6D1A:  BTFSC  FF2.7
6D1C:  BSF    19.7
6D1E:  BCF    FF2.7
6D20:  CALL   172E
6D24:  BTFSC  19.7
6D26:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6D28:  CLRF   FEA
6D2A:  MOVLW  41
6D2C:  MOVWF  FE9
6D2E:  MOVLW  00
6D30:  CALL   0390
6D34:  TBLRD*-
6D36:  TBLRD*+
6D38:  MOVF   FF5,W
6D3A:  MOVWF  FEE
6D3C:  IORLW  00
6D3E:  BNZ   6D36
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6D40:  MOVLW  01
6D42:  MOVLB  7
6D44:  MOVWF  xF4
6D46:  MOVLW  62
6D48:  MOVWF  xF3
6D4A:  CLRF   xF6
6D4C:  MOVLW  41
6D4E:  MOVWF  xF5
6D50:  MOVLB  0
6D52:  CALL   60B6
6D56:  MOVF   01,F
6D58:  BNZ   6D90
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
6D5A:  MOVLW  8A
6D5C:  MOVWF  FF6
6D5E:  MOVLW  1C
6D60:  MOVWF  FF7
6D62:  CLRF   19
6D64:  BTFSC  FF2.7
6D66:  BSF    19.7
6D68:  BCF    FF2.7
6D6A:  CALL   172E
6D6E:  BTFSC  19.7
6D70:  BSF    FF2.7
....................          reset_password(); 
6D72:  BRA    69D2
....................          init_password(); 
6D74:  CALL   5D1A
....................          fprintf(COM2," exit\n\r");  
6D78:  MOVLW  A0
6D7A:  MOVWF  FF6
6D7C:  MOVLW  1C
6D7E:  MOVWF  FF7
6D80:  CLRF   19
6D82:  BTFSC  FF2.7
6D84:  BSF    19.7
6D86:  BCF    FF2.7
6D88:  CALL   172E
6D8C:  BTFSC  19.7
6D8E:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
6D90:  CLRF   FEA
6D92:  MOVLW  41
6D94:  MOVWF  FE9
6D96:  MOVLW  00
6D98:  CALL   03A6
6D9C:  TBLRD*-
6D9E:  TBLRD*+
6DA0:  MOVF   FF5,W
6DA2:  MOVWF  FEE
6DA4:  IORLW  00
6DA6:  BNZ   6D9E
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6DA8:  MOVLW  01
6DAA:  MOVLB  7
6DAC:  MOVWF  xF4
6DAE:  MOVLW  62
6DB0:  MOVWF  xF3
6DB2:  CLRF   xF6
6DB4:  MOVLW  41
6DB6:  MOVWF  xF5
6DB8:  MOVLB  0
6DBA:  CALL   60B6
6DBE:  MOVF   01,F
6DC0:  BNZ   6DE2
....................       { 
....................          keydebug_en=1; 
6DC2:  MOVLW  01
6DC4:  MOVLB  1
6DC6:  MOVWF  x44
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
6DC8:  MOVLW  A8
6DCA:  MOVWF  FF6
6DCC:  MOVLW  1C
6DCE:  MOVWF  FF7
6DD0:  CLRF   19
6DD2:  BTFSC  FF2.7
6DD4:  BSF    19.7
6DD6:  BCF    FF2.7
6DD8:  MOVLB  0
6DDA:  CALL   172E
6DDE:  BTFSC  19.7
6DE0:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
6DE2:  CLRF   FEA
6DE4:  MOVLW  41
6DE6:  MOVWF  FE9
6DE8:  MOVLW  00
6DEA:  CALL   03BC
6DEE:  TBLRD*-
6DF0:  TBLRD*+
6DF2:  MOVF   FF5,W
6DF4:  MOVWF  FEE
6DF6:  IORLW  00
6DF8:  BNZ   6DF0
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6DFA:  MOVLW  01
6DFC:  MOVLB  7
6DFE:  MOVWF  xF4
6E00:  MOVLW  62
6E02:  MOVWF  xF3
6E04:  CLRF   xF6
6E06:  MOVLW  41
6E08:  MOVWF  xF5
6E0A:  MOVLB  0
6E0C:  CALL   60B6
6E10:  MOVF   01,F
6E12:  BNZ   6E2E
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6E14:  MOVLW  BC
6E16:  MOVWF  FF6
6E18:  MOVLW  1C
6E1A:  MOVWF  FF7
6E1C:  CLRF   19
6E1E:  BTFSC  FF2.7
6E20:  BSF    19.7
6E22:  BCF    FF2.7
6E24:  CALL   172E
6E28:  BTFSC  19.7
6E2A:  BSF    FF2.7
....................          rstfact(); 
6E2C:  BRA    6A24
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
6E2E:  CLRF   FEA
6E30:  MOVLW  41
6E32:  MOVWF  FE9
6E34:  MOVLW  00
6E36:  CALL   03D4
6E3A:  TBLRD*-
6E3C:  TBLRD*+
6E3E:  MOVF   FF5,W
6E40:  MOVWF  FEE
6E42:  IORLW  00
6E44:  BNZ   6E3C
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6E46:  MOVLW  01
6E48:  MOVLB  7
6E4A:  MOVWF  xF4
6E4C:  MOVLW  62
6E4E:  MOVWF  xF3
6E50:  CLRF   xF6
6E52:  MOVLW  41
6E54:  MOVWF  xF5
6E56:  MOVLB  0
6E58:  CALL   60B6
6E5C:  MOVF   01,F
6E5E:  BNZ   6E86
....................       { 
....................          mode=LOGOFF; 
6E60:  MOVLB  6
6E62:  CLRF   xDC
....................          keydebug_en=0; 
6E64:  MOVLB  1
6E66:  CLRF   x44
....................          set_tris_a(0xff); 
6E68:  MOVLW  FF
6E6A:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
6E6C:  MOVLW  CC
6E6E:  MOVWF  FF6
6E70:  MOVLW  1C
6E72:  MOVWF  FF7
6E74:  CLRF   19
6E76:  BTFSC  FF2.7
6E78:  BSF    19.7
6E7A:  BCF    FF2.7
6E7C:  MOVLB  0
6E7E:  CALL   172E
6E82:  BTFSC  19.7
6E84:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
6E86:  CLRF   FEA
6E88:  MOVLW  41
6E8A:  MOVWF  FE9
6E8C:  MOVLW  00
6E8E:  CALL   03E6
6E92:  TBLRD*-
6E94:  TBLRD*+
6E96:  MOVF   FF5,W
6E98:  MOVWF  FEE
6E9A:  IORLW  00
6E9C:  BNZ   6E94
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6E9E:  MOVLW  01
6EA0:  MOVLB  7
6EA2:  MOVWF  xF4
6EA4:  MOVLW  62
6EA6:  MOVWF  xF3
6EA8:  CLRF   xF6
6EAA:  MOVLW  41
6EAC:  MOVWF  xF5
6EAE:  MOVLB  0
6EB0:  CALL   60B6
6EB4:  MOVF   01,F
6EB6:  BNZ   6F34
....................       { 
....................          fprintf(COM2,"New console name>"); 
6EB8:  MOVLW  D4
6EBA:  MOVWF  FF6
6EBC:  MOVLW  1C
6EBE:  MOVWF  FF7
6EC0:  CLRF   19
6EC2:  BTFSC  FF2.7
6EC4:  BSF    19.7
6EC6:  BCF    FF2.7
6EC8:  CALL   172E
6ECC:  BTFSC  19.7
6ECE:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,wide_strobe_nameconsole, console); 
6ED0:  MOVLW  01
6ED2:  MOVLB  7
6ED4:  MOVWF  xF3
6ED6:  MOVLW  10
6ED8:  MOVWF  xF4
6EDA:  MOVLW  06
6EDC:  MOVWF  xF6
6EDE:  MOVLW  E7
6EE0:  MOVWF  xF5
6EE2:  MOVLB  0
6EE4:  CALL   5F7E
6EE8:  CLRF   19
6EEA:  BTFSC  FF2.7
6EEC:  BSF    19.7
6EEE:  BCF    FF2.7
....................          EEPROM_write(strobe_nameconsole,wide_strobe_nameconsole,console); 
6EF0:  MOVLB  8
6EF2:  CLRF   xFA
6EF4:  CLRF   xF9
6EF6:  CLRF   xF8
6EF8:  MOVLW  28
6EFA:  MOVWF  xF7
6EFC:  CLRF   xFE
6EFE:  CLRF   xFD
6F00:  CLRF   xFC
6F02:  MOVLW  10
6F04:  MOVWF  xFB
6F06:  MOVLW  06
6F08:  MOVLB  9
6F0A:  MOVWF  x00
6F0C:  MOVLW  E7
6F0E:  MOVLB  8
6F10:  MOVWF  xFF
6F12:  MOVLB  0
6F14:  CALL   4EE8
6F18:  BTFSC  19.7
6F1A:  BSF    FF2.7
....................          fprintf(COM2," OK\n\r"); 
6F1C:  MOVLW  E6
6F1E:  MOVWF  FF6
6F20:  MOVLW  1C
6F22:  MOVWF  FF7
6F24:  CLRF   19
6F26:  BTFSC  FF2.7
6F28:  BSF    19.7
6F2A:  BCF    FF2.7
6F2C:  CALL   172E
6F30:  BTFSC  19.7
6F32:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
6F34:  CLRF   FEA
6F36:  MOVLW  41
6F38:  MOVWF  FE9
6F3A:  MOVLW  00
6F3C:  CALL   03F8
6F40:  TBLRD*-
6F42:  TBLRD*+
6F44:  MOVF   FF5,W
6F46:  MOVWF  FEE
6F48:  IORLW  00
6F4A:  BNZ   6F42
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6F4C:  MOVLW  01
6F4E:  MOVLB  7
6F50:  MOVWF  xF4
6F52:  MOVLW  62
6F54:  MOVWF  xF3
6F56:  CLRF   xF6
6F58:  MOVLW  41
6F5A:  MOVWF  xF5
6F5C:  MOVLB  0
6F5E:  CALL   60B6
6F62:  MOVF   01,F
6F64:  BTFSS  FD8.2
6F66:  BRA    7108
6F68:  CLRF   19
6F6A:  BTFSC  FF2.7
6F6C:  BSF    19.7
6F6E:  BCF    FF2.7
....................       { 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6F70:  MOVLB  9
6F72:  CLRF   x1B
6F74:  CLRF   x1A
6F76:  CLRF   x19
6F78:  MOVLW  3A
6F7A:  MOVWF  x18
6F7C:  MOVLB  0
6F7E:  CALL   3450
6F82:  BTFSC  19.7
6F84:  BSF    FF2.7
6F86:  MOVFF  01,6E2
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6F8A:  MOVLB  6
6F8C:  MOVF   xE2,F
6F8E:  BNZ   6FAE
6F90:  MOVLW  EC
6F92:  MOVWF  FF6
6F94:  MOVLW  1C
6F96:  MOVWF  FF7
6F98:  CLRF   19
6F9A:  BTFSC  FF2.7
6F9C:  BSF    19.7
6F9E:  BCF    FF2.7
6FA0:  MOVLB  0
6FA2:  CALL   172E
6FA6:  BTFSC  19.7
6FA8:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6FAA:  BRA    6FC8
6FAC:  MOVLB  6
6FAE:  MOVLW  F0
6FB0:  MOVWF  FF6
6FB2:  MOVLW  1C
6FB4:  MOVWF  FF7
6FB6:  CLRF   19
6FB8:  BTFSC  FF2.7
6FBA:  BSF    19.7
6FBC:  BCF    FF2.7
6FBE:  MOVLB  0
6FC0:  CALL   172E
6FC4:  BTFSC  19.7
6FC6:  BSF    FF2.7
6FC8:  CLRF   19
6FCA:  BTFSC  FF2.7
6FCC:  BSF    19.7
6FCE:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
6FD0:  MOVLB  9
6FD2:  CLRF   x1B
6FD4:  CLRF   x1A
6FD6:  CLRF   x19
6FD8:  MOVLW  3C
6FDA:  MOVWF  x18
6FDC:  MOVLB  0
6FDE:  CALL   3450
6FE2:  BTFSC  19.7
6FE4:  BSF    FF2.7
6FE6:  MOVFF  01,15A
6FEA:  CLRF   19
6FEC:  BTFSC  FF2.7
6FEE:  BSF    19.7
6FF0:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
6FF2:  MOVLW  5B
6FF4:  MOVLB  9
6FF6:  MOVWF  x0C
6FF8:  MOVLB  0
6FFA:  CALL   1604
6FFE:  BTFSC  19.7
7000:  BSF    FF2.7
7002:  MOVFF  15A,7F3
7006:  MOVLW  1B
7008:  MOVLB  7
700A:  MOVWF  xF4
700C:  MOVLB  0
700E:  BRA    6A8E
7010:  CLRF   19
7012:  BTFSC  FF2.7
7014:  BSF    19.7
7016:  BCF    FF2.7
7018:  MOVLW  5D
701A:  MOVLB  9
701C:  MOVWF  x0C
701E:  MOVLB  0
7020:  CALL   1604
7024:  BTFSC  19.7
7026:  BSF    FF2.7
....................           
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
7028:  MOVFF  1CB,82B
702C:  MOVLW  01
702E:  MOVLB  8
7030:  MOVWF  x2C
7032:  MOVLB  0
7034:  CALL   6182
7038:  CLRF   19
703A:  BTFSC  FF2.7
703C:  BSF    19.7
703E:  BCF    FF2.7
7040:  MOVLW  2F
7042:  MOVLB  9
7044:  MOVWF  x0C
7046:  MOVLB  0
7048:  CALL   1604
704C:  BTFSC  19.7
704E:  BSF    FF2.7
7050:  MOVFF  1CA,82B
7054:  MOVLW  01
7056:  MOVLB  8
7058:  MOVWF  x2C
705A:  MOVLB  0
705C:  CALL   6182
7060:  CLRF   19
7062:  BTFSC  FF2.7
7064:  BSF    19.7
7066:  BCF    FF2.7
7068:  MOVLW  20
706A:  MOVLB  9
706C:  MOVWF  x0C
706E:  MOVLB  0
7070:  CALL   1604
7074:  BTFSC  19.7
7076:  BSF    FF2.7
7078:  MOVFF  1CC,82B
707C:  MOVLW  01
707E:  MOVLB  8
7080:  MOVWF  x2C
7082:  MOVLB  0
7084:  CALL   6182
7088:  CLRF   19
708A:  BTFSC  FF2.7
708C:  BSF    19.7
708E:  BCF    FF2.7
7090:  MOVLW  3A
7092:  MOVLB  9
7094:  MOVWF  x0C
7096:  MOVLB  0
7098:  CALL   1604
709C:  BTFSC  19.7
709E:  BSF    FF2.7
70A0:  MOVFF  1CD,82B
70A4:  MOVLW  01
70A6:  MOVLB  8
70A8:  MOVWF  x2C
70AA:  MOVLB  0
70AC:  CALL   6182
70B0:  CLRF   19
70B2:  BTFSC  FF2.7
70B4:  BSF    19.7
70B6:  BCF    FF2.7
70B8:  MOVLW  3A
70BA:  MOVLB  9
70BC:  MOVWF  x0C
70BE:  MOVLB  0
70C0:  CALL   1604
70C4:  BTFSC  19.7
70C6:  BSF    FF2.7
70C8:  MOVFF  1CE,82B
70CC:  MOVLW  01
70CE:  MOVLB  8
70D0:  MOVWF  x2C
70D2:  MOVLB  0
70D4:  CALL   6182
70D8:  CLRF   19
70DA:  BTFSC  FF2.7
70DC:  BSF    19.7
70DE:  BCF    FF2.7
....................           
....................          fprintf(COM2,"\n\r"); 
70E0:  MOVLW  0A
70E2:  MOVLB  9
70E4:  MOVWF  x0C
70E6:  MOVLB  0
70E8:  CALL   1604
70EC:  BTFSC  19.7
70EE:  BSF    FF2.7
70F0:  CLRF   19
70F2:  BTFSC  FF2.7
70F4:  BSF    19.7
70F6:  BCF    FF2.7
70F8:  MOVLW  0D
70FA:  MOVLB  9
70FC:  MOVWF  x0C
70FE:  MOVLB  0
7100:  CALL   1604
7104:  BTFSC  19.7
7106:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
7108:  CLRF   FEA
710A:  MOVLW  41
710C:  MOVWF  FE9
710E:  MOVLW  00
7110:  CALL   040A
7114:  TBLRD*-
7116:  TBLRD*+
7118:  MOVF   FF5,W
711A:  MOVWF  FEE
711C:  IORLW  00
711E:  BNZ   7116
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7120:  MOVLW  01
7122:  MOVLB  7
7124:  MOVWF  xF4
7126:  MOVLW  62
7128:  MOVWF  xF3
712A:  CLRF   xF6
712C:  MOVLW  41
712E:  MOVWF  xF5
7130:  MOVLB  0
7132:  CALL   60B6
7136:  MOVF   01,F
7138:  BTFSS  FD8.2
713A:  BRA    733A
....................       { 
....................          fprintf(COM2,"Year>"); 
713C:  MOVLW  F4
713E:  MOVWF  FF6
7140:  MOVLW  1C
7142:  MOVWF  FF7
7144:  CLRF   19
7146:  BTFSC  FF2.7
7148:  BSF    19.7
714A:  BCF    FF2.7
714C:  CALL   172E
7150:  BTFSC  19.7
7152:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7154:  MOVLW  01
7156:  MOVLB  7
7158:  MOVWF  xF3
715A:  MOVLW  03
715C:  MOVWF  xF4
715E:  MOVLW  07
7160:  MOVWF  xF6
7162:  MOVLW  C1
7164:  MOVWF  xF5
7166:  MOVLB  0
7168:  CALL   5F7E
....................          year=(unsigned int8)strtoi(temp); 
716C:  MOVLW  07
716E:  MOVLB  7
7170:  MOVWF  xF4
7172:  MOVLW  C1
7174:  MOVWF  xF3
7176:  MOVLB  0
7178:  RCALL  6B54
717A:  MOVFF  01,1C9
....................          fprintf(COM2,"Month>"); 
717E:  MOVLW  FA
7180:  MOVWF  FF6
7182:  MOVLW  1C
7184:  MOVWF  FF7
7186:  CLRF   19
7188:  BTFSC  FF2.7
718A:  BSF    19.7
718C:  BCF    FF2.7
718E:  CALL   172E
7192:  BTFSC  19.7
7194:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7196:  MOVLW  01
7198:  MOVLB  7
719A:  MOVWF  xF3
719C:  MOVLW  03
719E:  MOVWF  xF4
71A0:  MOVLW  07
71A2:  MOVWF  xF6
71A4:  MOVLW  C1
71A6:  MOVWF  xF5
71A8:  MOVLB  0
71AA:  CALL   5F7E
....................          mon=(unsigned int8)strtoi(temp); 
71AE:  MOVLW  07
71B0:  MOVLB  7
71B2:  MOVWF  xF4
71B4:  MOVLW  C1
71B6:  MOVWF  xF3
71B8:  MOVLB  0
71BA:  RCALL  6B54
71BC:  MOVFF  01,1CA
....................          fprintf(COM2,"Date>"); 
71C0:  MOVLW  02
71C2:  MOVWF  FF6
71C4:  MOVLW  1D
71C6:  MOVWF  FF7
71C8:  CLRF   19
71CA:  BTFSC  FF2.7
71CC:  BSF    19.7
71CE:  BCF    FF2.7
71D0:  CALL   172E
71D4:  BTFSC  19.7
71D6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
71D8:  MOVLW  01
71DA:  MOVLB  7
71DC:  MOVWF  xF3
71DE:  MOVLW  03
71E0:  MOVWF  xF4
71E2:  MOVLW  07
71E4:  MOVWF  xF6
71E6:  MOVLW  C1
71E8:  MOVWF  xF5
71EA:  MOVLB  0
71EC:  CALL   5F7E
....................          date = (unsigned int8)strtoi(temp); 
71F0:  MOVLW  07
71F2:  MOVLB  7
71F4:  MOVWF  xF4
71F6:  MOVLW  C1
71F8:  MOVWF  xF3
71FA:  MOVLB  0
71FC:  RCALL  6B54
71FE:  MOVFF  01,1CB
....................          fprintf(COM2,"Day>"); 
7202:  MOVLW  08
7204:  MOVWF  FF6
7206:  MOVLW  1D
7208:  MOVWF  FF7
720A:  CLRF   19
720C:  BTFSC  FF2.7
720E:  BSF    19.7
7210:  BCF    FF2.7
7212:  CALL   172E
7216:  BTFSC  19.7
7218:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
721A:  MOVLW  01
721C:  MOVLB  7
721E:  MOVWF  xF3
7220:  MOVLW  03
7222:  MOVWF  xF4
7224:  MOVLW  07
7226:  MOVWF  xF6
7228:  MOVLW  C1
722A:  MOVWF  xF5
722C:  MOVLB  0
722E:  CALL   5F7E
....................          day = (unsigned int8)strtoi(temp); 
7232:  MOVLW  07
7234:  MOVLB  7
7236:  MOVWF  xF4
7238:  MOVLW  C1
723A:  MOVWF  xF3
723C:  MOVLB  0
723E:  RCALL  6B54
7240:  MOVFF  01,1C8
....................          fprintf(COM2,"Hour>"); 
7244:  MOVLW  0E
7246:  MOVWF  FF6
7248:  MOVLW  1D
724A:  MOVWF  FF7
724C:  CLRF   19
724E:  BTFSC  FF2.7
7250:  BSF    19.7
7252:  BCF    FF2.7
7254:  CALL   172E
7258:  BTFSC  19.7
725A:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
725C:  MOVLW  01
725E:  MOVLB  7
7260:  MOVWF  xF3
7262:  MOVLW  03
7264:  MOVWF  xF4
7266:  MOVLW  07
7268:  MOVWF  xF6
726A:  MOVLW  C1
726C:  MOVWF  xF5
726E:  MOVLB  0
7270:  CALL   5F7E
....................          h = (unsigned int8)strtoi(temp); 
7274:  MOVLW  07
7276:  MOVLB  7
7278:  MOVWF  xF4
727A:  MOVLW  C1
727C:  MOVWF  xF3
727E:  MOVLB  0
7280:  RCALL  6B54
7282:  MOVFF  01,1CC
....................          fprintf(COM2,"Minutes>"); 
7286:  MOVLW  14
7288:  MOVWF  FF6
728A:  MOVLW  1D
728C:  MOVWF  FF7
728E:  CLRF   19
7290:  BTFSC  FF2.7
7292:  BSF    19.7
7294:  BCF    FF2.7
7296:  CALL   172E
729A:  BTFSC  19.7
729C:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
729E:  MOVLW  01
72A0:  MOVLB  7
72A2:  MOVWF  xF3
72A4:  MOVLW  03
72A6:  MOVWF  xF4
72A8:  MOVLW  07
72AA:  MOVWF  xF6
72AC:  MOVLW  C1
72AE:  MOVWF  xF5
72B0:  MOVLB  0
72B2:  CALL   5F7E
....................          min = (unsigned int8)strtoi(temp);                   
72B6:  MOVLW  07
72B8:  MOVLB  7
72BA:  MOVWF  xF4
72BC:  MOVLW  C1
72BE:  MOVWF  xF3
72C0:  MOVLB  0
72C2:  RCALL  6B54
72C4:  MOVFF  01,1CD
....................          fprintf(COM2,"Seconds>"); 
72C8:  MOVLW  1E
72CA:  MOVWF  FF6
72CC:  MOVLW  1D
72CE:  MOVWF  FF7
72D0:  CLRF   19
72D2:  BTFSC  FF2.7
72D4:  BSF    19.7
72D6:  BCF    FF2.7
72D8:  CALL   172E
72DC:  BTFSC  19.7
72DE:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
72E0:  MOVLW  01
72E2:  MOVLB  7
72E4:  MOVWF  xF3
72E6:  MOVLW  03
72E8:  MOVWF  xF4
72EA:  MOVLW  07
72EC:  MOVWF  xF6
72EE:  MOVLW  C1
72F0:  MOVWF  xF5
72F2:  MOVLB  0
72F4:  CALL   5F7E
....................          sec = (unsigned int8)strtoi(temp);                   
72F8:  MOVLW  07
72FA:  MOVLB  7
72FC:  MOVWF  xF4
72FE:  MOVLW  C1
7300:  MOVWF  xF3
7302:  MOVLB  0
7304:  RCALL  6B54
7306:  MOVFF  01,1CE
730A:  CLRF   19
730C:  BTFSC  FF2.7
730E:  BSF    19.7
7310:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
7312:  MOVLW  0A
7314:  MOVLB  9
7316:  MOVWF  x0C
7318:  MOVLB  0
731A:  CALL   1604
731E:  BTFSC  19.7
7320:  BSF    FF2.7
7322:  CLRF   19
7324:  BTFSC  FF2.7
7326:  BSF    19.7
7328:  BCF    FF2.7
732A:  MOVLW  0D
732C:  MOVLB  9
732E:  MOVWF  x0C
7330:  MOVLB  0
7332:  CALL   1604
7336:  BTFSC  19.7
7338:  BSF    FF2.7
....................          /* rtc_set_datetime(date,mon,year,day,h,min); */ 
....................       } 
....................       strcpy(buffer2,"MS"); 
733A:  CLRF   FEA
733C:  MOVLW  41
733E:  MOVWF  FE9
7340:  MOVLW  00
7342:  CALL   041E
7346:  TBLRD*-
7348:  TBLRD*+
734A:  MOVF   FF5,W
734C:  MOVWF  FEE
734E:  IORLW  00
7350:  BNZ   7348
....................       if(!stringcomp(buffer_uart,buffer2)) 
7352:  MOVLW  01
7354:  MOVLB  7
7356:  MOVWF  xF4
7358:  MOVLW  62
735A:  MOVWF  xF3
735C:  CLRF   xF6
735E:  MOVLW  41
7360:  MOVWF  xF5
7362:  MOVLB  0
7364:  CALL   60B6
7368:  MOVF   01,F
736A:  BTFSS  FD8.2
736C:  BRA    7480
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
736E:  MOVLW  28
7370:  MOVWF  FF6
7372:  MOVLW  1D
7374:  MOVWF  FF7
7376:  CLRF   19
7378:  BTFSC  FF2.7
737A:  BSF    19.7
737C:  BCF    FF2.7
737E:  CALL   172E
7382:  BTFSC  19.7
7384:  BSF    FF2.7
7386:  CLRF   19
7388:  BTFSC  FF2.7
738A:  BSF    19.7
738C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
738E:  MOVLW  0A
7390:  MOVLB  9
7392:  MOVWF  x0C
7394:  MOVLB  0
7396:  CALL   1604
739A:  BTFSC  19.7
739C:  BSF    FF2.7
739E:  CLRF   19
73A0:  BTFSC  FF2.7
73A2:  BSF    19.7
73A4:  BCF    FF2.7
73A6:  MOVLW  0D
73A8:  MOVLB  9
73AA:  MOVWF  x0C
73AC:  MOVLB  0
73AE:  CALL   1604
73B2:  BTFSC  19.7
73B4:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
73B6:  MOVLW  48
73B8:  MOVWF  FF6
73BA:  MOVLW  1D
73BC:  MOVWF  FF7
73BE:  CLRF   19
73C0:  BTFSC  FF2.7
73C2:  BSF    19.7
73C4:  BCF    FF2.7
73C6:  CALL   172E
73CA:  BTFSC  19.7
73CC:  BSF    FF2.7
73CE:  CLRF   19
73D0:  BTFSC  FF2.7
73D2:  BSF    19.7
73D4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
73D6:  MOVLW  0A
73D8:  MOVLB  9
73DA:  MOVWF  x0C
73DC:  MOVLB  0
73DE:  CALL   1604
73E2:  BTFSC  19.7
73E4:  BSF    FF2.7
73E6:  CLRF   19
73E8:  BTFSC  FF2.7
73EA:  BSF    19.7
73EC:  BCF    FF2.7
73EE:  MOVLW  0D
73F0:  MOVLB  9
73F2:  MOVWF  x0C
73F4:  MOVLB  0
73F6:  CALL   1604
73FA:  BTFSC  19.7
73FC:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
73FE:  MOVLW  01
7400:  MOVLB  7
7402:  MOVWF  xF3
7404:  MOVLW  03
7406:  MOVWF  xF4
7408:  MOVLW  07
740A:  MOVWF  xF6
740C:  MOVLW  C1
740E:  MOVWF  xF5
7410:  MOVLB  0
7412:  CALL   5F7E
....................           mode_sl = (unsigned int8)strtoi(temp); 
7416:  MOVLW  07
7418:  MOVLB  7
741A:  MOVWF  xF4
741C:  MOVLW  C1
741E:  MOVWF  xF3
7420:  MOVLB  0
7422:  CALL   6B54
7426:  MOVFF  01,6E2
742A:  CLRF   19
742C:  BTFSC  FF2.7
742E:  BSF    19.7
7430:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
7432:  MOVLB  9
7434:  CLRF   x16
7436:  CLRF   x15
7438:  CLRF   x14
743A:  MOVLW  3A
743C:  MOVWF  x13
743E:  MOVFF  6E2,917
7442:  MOVLB  0
7444:  CALL   3A6C
7448:  BTFSC  19.7
744A:  BSF    FF2.7
....................           set_tris_a(0xff); 
744C:  MOVLW  FF
744E:  MOVWF  F92
7450:  CLRF   19
7452:  BTFSC  FF2.7
7454:  BSF    19.7
7456:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7458:  MOVLW  0A
745A:  MOVLB  9
745C:  MOVWF  x0C
745E:  MOVLB  0
7460:  CALL   1604
7464:  BTFSC  19.7
7466:  BSF    FF2.7
7468:  CLRF   19
746A:  BTFSC  FF2.7
746C:  BSF    19.7
746E:  BCF    FF2.7
7470:  MOVLW  0D
7472:  MOVLB  9
7474:  MOVWF  x0C
7476:  MOVLB  0
7478:  CALL   1604
747C:  BTFSC  19.7
747E:  BSF    FF2.7
....................       } 
....................       
....................       strcpy(buffer2,"tran time"); 
7480:  CLRF   FEA
7482:  MOVLW  41
7484:  MOVWF  FE9
7486:  MOVLW  00
7488:  CALL   0432
748C:  TBLRD*-
748E:  TBLRD*+
7490:  MOVF   FF5,W
7492:  MOVWF  FEE
7494:  IORLW  00
7496:  BNZ   748E
....................       if(!stringcomp(buffer_uart,buffer2)) 
7498:  MOVLW  01
749A:  MOVLB  7
749C:  MOVWF  xF4
749E:  MOVLW  62
74A0:  MOVWF  xF3
74A2:  CLRF   xF6
74A4:  MOVLW  41
74A6:  MOVWF  xF5
74A8:  MOVLB  0
74AA:  CALL   60B6
74AE:  MOVF   01,F
74B0:  BNZ   7578
....................       { 
....................           fprintf(COM2,"Input Number"); 
74B2:  MOVLW  68
74B4:  MOVWF  FF6
74B6:  MOVLW  1D
74B8:  MOVWF  FF7
74BA:  CLRF   19
74BC:  BTFSC  FF2.7
74BE:  BSF    19.7
74C0:  BCF    FF2.7
74C2:  CALL   172E
74C6:  BTFSC  19.7
74C8:  BSF    FF2.7
74CA:  CLRF   19
74CC:  BTFSC  FF2.7
74CE:  BSF    19.7
74D0:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
74D2:  MOVLW  0A
74D4:  MOVLB  9
74D6:  MOVWF  x0C
74D8:  MOVLB  0
74DA:  CALL   1604
74DE:  BTFSC  19.7
74E0:  BSF    FF2.7
74E2:  CLRF   19
74E4:  BTFSC  FF2.7
74E6:  BSF    19.7
74E8:  BCF    FF2.7
74EA:  MOVLW  0D
74EC:  MOVLB  9
74EE:  MOVWF  x0C
74F0:  MOVLB  0
74F2:  CALL   1604
74F6:  BTFSC  19.7
74F8:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
74FA:  MOVLW  01
74FC:  MOVLB  7
74FE:  MOVWF  xF3
7500:  MOVLW  03
7502:  MOVWF  xF4
7504:  MOVLW  07
7506:  MOVWF  xF6
7508:  MOVLW  C1
750A:  MOVWF  xF5
750C:  MOVLB  0
750E:  CALL   5F7E
....................           delaycharaction = (unsigned int8)strtoi(temp); 
7512:  MOVLW  07
7514:  MOVLB  7
7516:  MOVWF  xF4
7518:  MOVLW  C1
751A:  MOVWF  xF3
751C:  MOVLB  0
751E:  CALL   6B54
7522:  MOVFF  01,15A
7526:  CLRF   19
7528:  BTFSC  FF2.7
752A:  BSF    19.7
752C:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
752E:  MOVLB  9
7530:  CLRF   x16
7532:  CLRF   x15
7534:  CLRF   x14
7536:  MOVLW  3C
7538:  MOVWF  x13
753A:  MOVFF  15A,917
753E:  MOVLB  0
7540:  CALL   3A6C
7544:  BTFSC  19.7
7546:  BSF    FF2.7
7548:  CLRF   19
754A:  BTFSC  FF2.7
754C:  BSF    19.7
754E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7550:  MOVLW  0A
7552:  MOVLB  9
7554:  MOVWF  x0C
7556:  MOVLB  0
7558:  CALL   1604
755C:  BTFSC  19.7
755E:  BSF    FF2.7
7560:  CLRF   19
7562:  BTFSC  FF2.7
7564:  BSF    19.7
7566:  BCF    FF2.7
7568:  MOVLW  0D
756A:  MOVLB  9
756C:  MOVWF  x0C
756E:  MOVLB  0
7570:  CALL   1604
7574:  BTFSC  19.7
7576:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
7578:  CLRF   FEA
757A:  MOVLW  41
757C:  MOVWF  FE9
757E:  MOVLW  00
7580:  CALL   044C
7584:  TBLRD*-
7586:  TBLRD*+
7588:  MOVF   FF5,W
758A:  MOVWF  FEE
758C:  IORLW  00
758E:  BNZ   7586
....................       if(!stringcomp(buffer_uart,buffer2)) 
7590:  MOVLW  01
7592:  MOVLB  7
7594:  MOVWF  xF4
7596:  MOVLW  62
7598:  MOVWF  xF3
759A:  CLRF   xF6
759C:  MOVLW  41
759E:  MOVWF  xF5
75A0:  MOVLB  0
75A2:  CALL   60B6
75A6:  MOVF   01,F
75A8:  BTFSS  FD8.2
75AA:  BRA    76BA
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
75AC:  MOVLW  76
75AE:  MOVWF  FF6
75B0:  MOVLW  1D
75B2:  MOVWF  FF7
75B4:  CLRF   19
75B6:  BTFSC  FF2.7
75B8:  BSF    19.7
75BA:  BCF    FF2.7
75BC:  CALL   172E
75C0:  BTFSC  19.7
75C2:  BSF    FF2.7
75C4:  CLRF   19
75C6:  BTFSC  FF2.7
75C8:  BSF    19.7
75CA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
75CC:  MOVLW  0A
75CE:  MOVLB  9
75D0:  MOVWF  x0C
75D2:  MOVLB  0
75D4:  CALL   1604
75D8:  BTFSC  19.7
75DA:  BSF    FF2.7
75DC:  CLRF   19
75DE:  BTFSC  FF2.7
75E0:  BSF    19.7
75E2:  BCF    FF2.7
75E4:  MOVLW  0D
75E6:  MOVLB  9
75E8:  MOVWF  x0C
75EA:  MOVLB  0
75EC:  CALL   1604
75F0:  BTFSC  19.7
75F2:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
75F4:  MOVLW  9C
75F6:  MOVWF  FF6
75F8:  MOVLW  1D
75FA:  MOVWF  FF7
75FC:  CLRF   19
75FE:  BTFSC  FF2.7
7600:  BSF    19.7
7602:  BCF    FF2.7
7604:  CALL   172E
7608:  BTFSC  19.7
760A:  BSF    FF2.7
760C:  CLRF   19
760E:  BTFSC  FF2.7
7610:  BSF    19.7
7612:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7614:  MOVLW  0A
7616:  MOVLB  9
7618:  MOVWF  x0C
761A:  MOVLB  0
761C:  CALL   1604
7620:  BTFSC  19.7
7622:  BSF    FF2.7
7624:  CLRF   19
7626:  BTFSC  FF2.7
7628:  BSF    19.7
762A:  BCF    FF2.7
762C:  MOVLW  0D
762E:  MOVLB  9
7630:  MOVWF  x0C
7632:  MOVLB  0
7634:  CALL   1604
7638:  BTFSC  19.7
763A:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
763C:  MOVLW  01
763E:  MOVLB  7
7640:  MOVWF  xF3
7642:  MOVLW  03
7644:  MOVWF  xF4
7646:  MOVLW  07
7648:  MOVWF  xF6
764A:  MOVLW  C1
764C:  MOVWF  xF5
764E:  MOVLB  0
7650:  CALL   5F7E
....................           type_KB=(unsigned int8)strtoi(temp); 
7654:  MOVLW  07
7656:  MOVLB  7
7658:  MOVWF  xF4
765A:  MOVLW  C1
765C:  MOVWF  xF3
765E:  MOVLB  0
7660:  CALL   6B54
7664:  MOVFF  01,149
7668:  CLRF   19
766A:  BTFSC  FF2.7
766C:  BSF    19.7
766E:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
7670:  MOVLB  9
7672:  CLRF   x16
7674:  CLRF   x15
7676:  CLRF   x14
7678:  MOVLW  3D
767A:  MOVWF  x13
767C:  MOVFF  149,917
7680:  MOVLB  0
7682:  CALL   3A6C
7686:  BTFSC  19.7
7688:  BSF    FF2.7
768A:  CLRF   19
768C:  BTFSC  FF2.7
768E:  BSF    19.7
7690:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
7692:  MOVLW  0A
7694:  MOVLB  9
7696:  MOVWF  x0C
7698:  MOVLB  0
769A:  CALL   1604
769E:  BTFSC  19.7
76A0:  BSF    FF2.7
76A2:  CLRF   19
76A4:  BTFSC  FF2.7
76A6:  BSF    19.7
76A8:  BCF    FF2.7
76AA:  MOVLW  0D
76AC:  MOVLB  9
76AE:  MOVWF  x0C
76B0:  MOVLB  0
76B2:  CALL   1604
76B6:  BTFSC  19.7
76B8:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       strcpy(buffer2,"h"); 
76BA:  CLRF   FEA
76BC:  MOVLW  41
76BE:  MOVWF  FE9
76C0:  MOVLW  00
76C2:  CALL   0462
76C6:  TBLRD*-
76C8:  TBLRD*+
76CA:  MOVF   FF5,W
76CC:  MOVWF  FEE
76CE:  IORLW  00
76D0:  BNZ   76C8
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
76D2:  MOVLW  01
76D4:  MOVLB  7
76D6:  MOVWF  xF4
76D8:  MOVLW  62
76DA:  MOVWF  xF3
76DC:  CLRF   xF6
76DE:  MOVLW  41
76E0:  MOVWF  xF5
76E2:  MOVLB  0
76E4:  CALL   60B6
76E8:  MOVF   01,F
76EA:  BTFSS  FD8.2
76EC:  BRA    785C
....................       { 
....................          printf("h-> Help\n\r"); 
76EE:  MOVLW  C2
76F0:  MOVWF  FF6
76F2:  MOVLW  1D
76F4:  MOVWF  FF7
76F6:  CLRF   19
76F8:  BTFSC  FF2.7
76FA:  BSF    19.7
76FC:  BCF    FF2.7
76FE:  CALL   172E
7702:  BTFSC  19.7
7704:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
7706:  MOVLW  CE
7708:  MOVWF  FF6
770A:  MOVLW  1D
770C:  MOVWF  FF7
770E:  CLRF   19
7710:  BTFSC  FF2.7
7712:  BSF    19.7
7714:  BCF    FF2.7
7716:  CALL   172E
771A:  BTFSC  19.7
771C:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
771E:  MOVLW  E0
7720:  MOVWF  FF6
7722:  MOVLW  1D
7724:  MOVWF  FF7
7726:  CLRF   19
7728:  BTFSC  FF2.7
772A:  BSF    19.7
772C:  BCF    FF2.7
772E:  CALL   172E
7732:  BTFSC  19.7
7734:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
7736:  MOVLW  F2
7738:  MOVWF  FF6
773A:  MOVLW  1D
773C:  MOVWF  FF7
773E:  CLRF   19
7740:  BTFSC  FF2.7
7742:  BSF    19.7
7744:  BCF    FF2.7
7746:  CALL   172E
774A:  BTFSC  19.7
774C:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
774E:  MOVLW  12
7750:  MOVWF  FF6
7752:  MOVLW  1E
7754:  MOVWF  FF7
7756:  CLRF   19
7758:  BTFSC  FF2.7
775A:  BSF    19.7
775C:  BCF    FF2.7
775E:  CALL   172E
7762:  BTFSC  19.7
7764:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
7766:  MOVLW  2E
7768:  MOVWF  FF6
776A:  MOVLW  1E
776C:  MOVWF  FF7
776E:  CLRF   19
7770:  BTFSC  FF2.7
7772:  BSF    19.7
7774:  BCF    FF2.7
7776:  CALL   172E
777A:  BTFSC  19.7
777C:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
777E:  MOVLW  3C
7780:  MOVWF  FF6
7782:  MOVLW  1E
7784:  MOVWF  FF7
7786:  CLRF   19
7788:  BTFSC  FF2.7
778A:  BSF    19.7
778C:  BCF    FF2.7
778E:  CALL   172E
7792:  BTFSC  19.7
7794:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
7796:  MOVLW  48
7798:  MOVWF  FF6
779A:  MOVLW  1E
779C:  MOVWF  FF7
779E:  CLRF   19
77A0:  BTFSC  FF2.7
77A2:  BSF    19.7
77A4:  BCF    FF2.7
77A6:  CALL   172E
77AA:  BTFSC  19.7
77AC:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
77AE:  MOVLW  70
77B0:  MOVWF  FF6
77B2:  MOVLW  1E
77B4:  MOVWF  FF7
77B6:  CLRF   19
77B8:  BTFSC  FF2.7
77BA:  BSF    19.7
77BC:  BCF    FF2.7
77BE:  CALL   172E
77C2:  BTFSC  19.7
77C4:  BSF    FF2.7
77C6:  CLRF   19
77C8:  BTFSC  FF2.7
77CA:  BSF    19.7
77CC:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
77CE:  MOVLB  9
77D0:  CLRF   x1B
77D2:  CLRF   x1A
77D4:  CLRF   x19
77D6:  MOVLW  3D
77D8:  MOVWF  x18
77DA:  MOVLB  0
77DC:  CALL   3450
77E0:  BTFSC  19.7
77E2:  BSF    FF2.7
77E4:  MOVFF  01,7F3
77E8:  MOVLW  8C
77EA:  MOVWF  FF6
77EC:  MOVLW  1E
77EE:  MOVWF  FF7
77F0:  CLRF   19
77F2:  BTFSC  FF2.7
77F4:  BSF    19.7
77F6:  BCF    FF2.7
77F8:  MOVLW  06
77FA:  MOVLB  8
77FC:  MOVWF  xF7
77FE:  MOVLB  0
7800:  CALL   164A
7804:  BTFSC  19.7
7806:  BSF    FF2.7
7808:  CLRF   19
780A:  BTFSC  FF2.7
780C:  BSF    19.7
780E:  BCF    FF2.7
7810:  MOVFF  7F3,859
7814:  MOVLW  18
7816:  MOVLB  8
7818:  MOVWF  x5A
781A:  MOVLB  0
781C:  CALL   177A
7820:  BTFSC  19.7
7822:  BSF    FF2.7
7824:  MOVLW  94
7826:  MOVWF  FF6
7828:  MOVLW  1E
782A:  MOVWF  FF7
782C:  CLRF   19
782E:  BTFSC  FF2.7
7830:  BSF    19.7
7832:  BCF    FF2.7
7834:  MOVLW  1D
7836:  MOVLB  8
7838:  MOVWF  xF7
783A:  MOVLB  0
783C:  CALL   164A
7840:  BTFSC  19.7
7842:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
7844:  MOVLW  B2
7846:  MOVWF  FF6
7848:  MOVLW  1E
784A:  MOVWF  FF7
784C:  CLRF   19
784E:  BTFSC  FF2.7
7850:  BSF    19.7
7852:  BCF    FF2.7
7854:  CALL   172E
7858:  BTFSC  19.7
785A:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................       } 
....................       strcpy(buffer2,"password"); 
785C:  CLRF   FEA
785E:  MOVLW  41
7860:  MOVWF  FE9
7862:  MOVLW  00
7864:  CALL   0474
7868:  TBLRD*-
786A:  TBLRD*+
786C:  MOVF   FF5,W
786E:  MOVWF  FEE
7870:  IORLW  00
7872:  BNZ   786A
....................       if(!stringcomp(buffer_uart,buffer2))  
7874:  MOVLW  01
7876:  MOVLB  7
7878:  MOVWF  xF4
787A:  MOVLW  62
787C:  MOVWF  xF3
787E:  CLRF   xF6
7880:  MOVLW  41
7882:  MOVWF  xF5
7884:  MOVLB  0
7886:  CALL   60B6
788A:  MOVF   01,F
788C:  BTFSS  FD8.2
788E:  BRA    79F2
....................       { 
....................          fprintf(COM2,"old password:"); 
7890:  MOVLW  CC
7892:  MOVWF  FF6
7894:  MOVLW  1E
7896:  MOVWF  FF7
7898:  CLRF   19
789A:  BTFSC  FF2.7
789C:  BSF    19.7
789E:  BCF    FF2.7
78A0:  CALL   172E
78A4:  BTFSC  19.7
78A6:  BSF    FF2.7
78A8:  CLRF   19
78AA:  BTFSC  FF2.7
78AC:  BSF    19.7
78AE:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
78B0:  MOVLB  9
78B2:  CLRF   x07
78B4:  CLRF   x06
78B6:  CLRF   x05
78B8:  CLRF   x04
78BA:  CLRF   x0B
78BC:  CLRF   x0A
78BE:  CLRF   x09
78C0:  MOVLW  14
78C2:  MOVWF  x08
78C4:  CLRF   x0D
78C6:  MOVLW  55
78C8:  MOVWF  x0C
78CA:  MOVLB  0
78CC:  CALL   3FF6
78D0:  BTFSC  19.7
78D2:  BSF    FF2.7
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
78D4:  MOVLW  02
78D6:  MOVLB  7
78D8:  MOVWF  xF3
78DA:  MOVLW  14
78DC:  MOVWF  xF4
78DE:  CLRF   xF6
78E0:  MOVLW  69
78E2:  MOVWF  xF5
78E4:  MOVLB  0
78E6:  CALL   5F7E
....................          if(!stringcomp(entpassword,password)) 
78EA:  MOVLB  7
78EC:  CLRF   xF4
78EE:  MOVLW  69
78F0:  MOVWF  xF3
78F2:  CLRF   xF6
78F4:  MOVLW  55
78F6:  MOVWF  xF5
78F8:  MOVLB  0
78FA:  CALL   60B6
78FE:  MOVF   01,F
7900:  BNZ   79DA
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
7902:  MOVLW  DA
7904:  MOVWF  FF6
7906:  MOVLW  1E
7908:  MOVWF  FF7
790A:  CLRF   19
790C:  BTFSC  FF2.7
790E:  BSF    19.7
7910:  BCF    FF2.7
7912:  CALL   172E
7916:  BTFSC  19.7
7918:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
791A:  MOVLW  02
791C:  MOVLB  7
791E:  MOVWF  xF3
7920:  MOVLW  14
7922:  MOVWF  xF4
7924:  CLRF   xF6
7926:  MOVLW  69
7928:  MOVWF  xF5
792A:  MOVLB  0
792C:  CALL   5F7E
....................             fprintf(COM2,"\n\ragain:"); 
7930:  MOVLW  E2
7932:  MOVWF  FF6
7934:  MOVLW  1E
7936:  MOVWF  FF7
7938:  CLRF   19
793A:  BTFSC  FF2.7
793C:  BSF    19.7
793E:  BCF    FF2.7
7940:  CALL   172E
7944:  BTFSC  19.7
7946:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
7948:  MOVLW  02
794A:  MOVLB  7
794C:  MOVWF  xF3
794E:  MOVLW  14
7950:  MOVWF  xF4
7952:  CLRF   xF6
7954:  MOVLW  55
7956:  MOVWF  xF5
7958:  MOVLB  0
795A:  CALL   5F7E
....................             if(!stringcomp(entpassword,password)) 
795E:  MOVLB  7
7960:  CLRF   xF4
7962:  MOVLW  69
7964:  MOVWF  xF3
7966:  CLRF   xF6
7968:  MOVLW  55
796A:  MOVWF  xF5
796C:  MOVLB  0
796E:  CALL   60B6
7972:  MOVF   01,F
7974:  BNZ   79C0
7976:  CLRF   19
7978:  BTFSC  FF2.7
797A:  BSF    19.7
797C:  BCF    FF2.7
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
797E:  MOVLB  8
7980:  CLRF   xFA
7982:  CLRF   xF9
7984:  CLRF   xF8
7986:  CLRF   xF7
7988:  CLRF   xFE
798A:  CLRF   xFD
798C:  CLRF   xFC
798E:  MOVLW  14
7990:  MOVWF  xFB
7992:  MOVLB  9
7994:  CLRF   x00
7996:  MOVLW  55
7998:  MOVLB  8
799A:  MOVWF  xFF
799C:  MOVLB  0
799E:  CALL   4EE8
79A2:  BTFSC  19.7
79A4:  BSF    FF2.7
....................                fprintf(COM2,"\n\rOK\n\r");    
79A6:  MOVLW  EC
79A8:  MOVWF  FF6
79AA:  MOVLW  1E
79AC:  MOVWF  FF7
79AE:  CLRF   19
79B0:  BTFSC  FF2.7
79B2:  BSF    19.7
79B4:  BCF    FF2.7
79B6:  CALL   172E
79BA:  BTFSC  19.7
79BC:  BSF    FF2.7
....................             } 
....................                else 
79BE:  BRA    79D8
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
79C0:  MOVLW  F4
79C2:  MOVWF  FF6
79C4:  MOVLW  1E
79C6:  MOVWF  FF7
79C8:  CLRF   19
79CA:  BTFSC  FF2.7
79CC:  BSF    19.7
79CE:  BCF    FF2.7
79D0:  CALL   172E
79D4:  BTFSC  19.7
79D6:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
79D8:  BRA    79F2
....................             { 
....................                fprintf(COM2," X\n\r"); 
79DA:  MOVLW  FC
79DC:  MOVWF  FF6
79DE:  MOVLW  1E
79E0:  MOVWF  FF7
79E2:  CLRF   19
79E4:  BTFSC  FF2.7
79E6:  BSF    19.7
79E8:  BCF    FF2.7
79EA:  CALL   172E
79EE:  BTFSC  19.7
79F0:  BSF    FF2.7
....................             }    
....................       } 
....................         strcpy(buffer2,"crypto"); 
79F2:  CLRF   FEA
79F4:  MOVLW  41
79F6:  MOVWF  FE9
79F8:  MOVLW  00
79FA:  CALL   048E
79FE:  TBLRD*-
7A00:  TBLRD*+
7A02:  MOVF   FF5,W
7A04:  MOVWF  FEE
7A06:  IORLW  00
7A08:  BNZ   7A00
....................         if(!stringcomp(buffer_uart,buffer2))  
7A0A:  MOVLW  01
7A0C:  MOVLB  7
7A0E:  MOVWF  xF4
7A10:  MOVLW  62
7A12:  MOVWF  xF3
7A14:  CLRF   xF6
7A16:  MOVLW  41
7A18:  MOVWF  xF5
7A1A:  MOVLB  0
7A1C:  CALL   60B6
7A20:  MOVF   01,F
7A22:  BTFSS  FD8.2
7A24:  BRA    7BA8
....................         { 
....................             memset(crypto_key,0,sizeof(crypto_key)); 
7A26:  MOVLW  01
7A28:  MOVWF  FEA
7A2A:  MOVWF  FE9
7A2C:  CLRF   00
7A2E:  CLRF   02
7A30:  MOVLW  21
7A32:  MOVWF  01
7A34:  CALL   359A
....................             fprintf(COM2,"New crypto key>"); 
7A38:  MOVLW  02
7A3A:  MOVWF  FF6
7A3C:  MOVLW  1F
7A3E:  MOVWF  FF7
7A40:  CLRF   19
7A42:  BTFSC  FF2.7
7A44:  BSF    19.7
7A46:  BCF    FF2.7
7A48:  CALL   172E
7A4C:  BTFSC  19.7
7A4E:  BSF    FF2.7
....................             countchar = (int16)USART_getstring(EN_ECHO, CRYPTO_KEY_SIZE, crypto_key); 
7A50:  MOVLW  01
7A52:  MOVLB  7
7A54:  MOVWF  xF3
7A56:  MOVLW  20
7A58:  MOVWF  xF4
7A5A:  MOVLW  01
7A5C:  MOVWF  xF6
7A5E:  MOVWF  xF5
7A60:  MOVLB  0
7A62:  CALL   5F7E
7A66:  MOVLB  7
7A68:  CLRF   xC0
7A6A:  MOVFF  01,7BF
7A6E:  CLRF   19
7A70:  BTFSC  FF2.7
7A72:  BSF    19.7
7A74:  BCF    FF2.7
....................             EEPROM_write(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
7A76:  MOVLB  8
7A78:  CLRF   xFA
7A7A:  CLRF   xF9
7A7C:  CLRF   xF8
7A7E:  MOVLW  3F
7A80:  MOVWF  xF7
7A82:  CLRF   xFE
7A84:  CLRF   xFD
7A86:  CLRF   xFC
7A88:  MOVLW  20
7A8A:  MOVWF  xFB
7A8C:  MOVLW  01
7A8E:  MOVLB  9
7A90:  MOVWF  x00
7A92:  MOVLB  8
7A94:  MOVWF  xFF
7A96:  MOVLB  0
7A98:  CALL   4EE8
7A9C:  BTFSC  19.7
7A9E:  BSF    FF2.7
....................              
....................             if(countchar>2) 
7AA0:  MOVLB  7
7AA2:  MOVF   xC0,F
7AA4:  BNZ   7AAC
7AA6:  MOVF   xBF,W
7AA8:  SUBLW  02
7AAA:  BC    7B6A
....................             { 
....................                 cryption_enable = 1; 
7AAC:  MOVLW  01
7AAE:  MOVLB  1
7AB0:  MOVWF  x22
7AB2:  CLRF   19
7AB4:  BTFSC  FF2.7
7AB6:  BSF    19.7
7AB8:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable);                    
7ABA:  MOVLB  9
7ABC:  CLRF   x16
7ABE:  CLRF   x15
7AC0:  CLRF   x14
7AC2:  MOVLW  3E
7AC4:  MOVWF  x13
7AC6:  MOVFF  122,917
7ACA:  MOVLB  0
7ACC:  CALL   3A6C
7AD0:  BTFSC  19.7
7AD2:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rNew crypto key: "); 
7AD4:  MOVLW  12
7AD6:  MOVWF  FF6
7AD8:  MOVLW  1F
7ADA:  MOVWF  FF7
7ADC:  CLRF   19
7ADE:  BTFSC  FF2.7
7AE0:  BSF    19.7
7AE2:  BCF    FF2.7
7AE4:  CALL   172E
7AE8:  BTFSC  19.7
7AEA:  BSF    FF2.7
....................                 for(i=0;i<CRYPTO_KEY_SIZE;i++) 
7AEC:  MOVLB  7
7AEE:  CLRF   xBE
7AF0:  MOVF   xBE,W
7AF2:  SUBLW  1F
7AF4:  BNC   7B36
....................                 { 
....................                     fprintf(COM2,"%c",read_ext_eeprom(strobe_crypto_key+i)); 
7AF6:  MOVLW  3F
7AF8:  ADDWF  xBE,W
7AFA:  MOVWF  xF3
7AFC:  CLRF   19
7AFE:  BTFSC  FF2.7
7B00:  BSF    19.7
7B02:  BCF    FF2.7
7B04:  MOVLB  9
7B06:  CLRF   x1B
7B08:  CLRF   x1A
7B0A:  CLRF   x19
7B0C:  MOVWF  x18
7B0E:  MOVLB  0
7B10:  CALL   3450
7B14:  BTFSC  19.7
7B16:  BSF    FF2.7
7B18:  MOVFF  01,7F3
7B1C:  CLRF   19
7B1E:  BTFSC  FF2.7
7B20:  BSF    19.7
7B22:  BCF    FF2.7
7B24:  MOVFF  01,90C
7B28:  CALL   1604
7B2C:  BTFSC  19.7
7B2E:  BSF    FF2.7
....................                 } 
7B30:  MOVLB  7
7B32:  INCF   xBE,F
7B34:  BRA    7AF0
7B36:  CLRF   19
7B38:  BTFSC  FF2.7
7B3A:  BSF    19.7
7B3C:  BCF    FF2.7
....................                 fprintf(COM2,"\n\r"); 
7B3E:  MOVLW  0A
7B40:  MOVLB  9
7B42:  MOVWF  x0C
7B44:  MOVLB  0
7B46:  CALL   1604
7B4A:  BTFSC  19.7
7B4C:  BSF    FF2.7
7B4E:  CLRF   19
7B50:  BTFSC  FF2.7
7B52:  BSF    19.7
7B54:  BCF    FF2.7
7B56:  MOVLW  0D
7B58:  MOVLB  9
7B5A:  MOVWF  x0C
7B5C:  MOVLB  0
7B5E:  CALL   1604
7B62:  BTFSC  19.7
7B64:  BSF    FF2.7
....................             } 
....................             else 
7B66:  BRA    7BA8
7B68:  MOVLB  7
....................             { 
....................                 cryption_enable = 0; 
7B6A:  MOVLB  1
7B6C:  CLRF   x22
7B6E:  CLRF   19
7B70:  BTFSC  FF2.7
7B72:  BSF    19.7
7B74:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable); 
7B76:  MOVLB  9
7B78:  CLRF   x16
7B7A:  CLRF   x15
7B7C:  CLRF   x14
7B7E:  MOVLW  3E
7B80:  MOVWF  x13
7B82:  MOVFF  122,917
7B86:  MOVLB  0
7B88:  CALL   3A6C
7B8C:  BTFSC  19.7
7B8E:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rcrypto is disable\n\r"); 
7B90:  MOVLW  26
7B92:  MOVWF  FF6
7B94:  MOVLW  1F
7B96:  MOVWF  FF7
7B98:  CLRF   19
7B9A:  BTFSC  FF2.7
7B9C:  BSF    19.7
7B9E:  BCF    FF2.7
7BA0:  CALL   172E
7BA4:  BTFSC  19.7
7BA6:  BSF    FF2.7
....................             } 
....................         } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
7BA8:  CLRF   FEA
7BAA:  MOVLW  41
7BAC:  MOVWF  FE9
7BAE:  MOVLW  00
7BB0:  CALL   04A6
7BB4:  TBLRD*-
7BB6:  TBLRD*+
7BB8:  MOVF   FF5,W
7BBA:  MOVWF  FEE
7BBC:  IORLW  00
7BBE:  BNZ   7BB6
....................       if(!stringcomp(buffer_uart,buffer2)) 
7BC0:  MOVLW  01
7BC2:  MOVLB  7
7BC4:  MOVWF  xF4
7BC6:  MOVLW  62
7BC8:  MOVWF  xF3
7BCA:  CLRF   xF6
7BCC:  MOVLW  41
7BCE:  MOVWF  xF5
7BD0:  MOVLB  0
7BD2:  CALL   60B6
7BD6:  MOVF   01,F
7BD8:  BTFSS  FD8.2
7BDA:  BRA    7CEA
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
7BDC:  MOVLW  3C
7BDE:  MOVWF  FF6
7BE0:  MOVLW  1F
7BE2:  MOVWF  FF7
7BE4:  CLRF   19
7BE6:  BTFSC  FF2.7
7BE8:  BSF    19.7
7BEA:  BCF    FF2.7
7BEC:  CALL   172E
7BF0:  BTFSC  19.7
7BF2:  BSF    FF2.7
7BF4:  CLRF   19
7BF6:  BTFSC  FF2.7
7BF8:  BSF    19.7
7BFA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7BFC:  MOVLW  0A
7BFE:  MOVLB  9
7C00:  MOVWF  x0C
7C02:  MOVLB  0
7C04:  CALL   1604
7C08:  BTFSC  19.7
7C0A:  BSF    FF2.7
7C0C:  CLRF   19
7C0E:  BTFSC  FF2.7
7C10:  BSF    19.7
7C12:  BCF    FF2.7
7C14:  MOVLW  0D
7C16:  MOVLB  9
7C18:  MOVWF  x0C
7C1A:  MOVLB  0
7C1C:  CALL   1604
7C20:  BTFSC  19.7
7C22:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
7C24:  MOVLW  5C
7C26:  MOVWF  FF6
7C28:  MOVLW  1F
7C2A:  MOVWF  FF7
7C2C:  CLRF   19
7C2E:  BTFSC  FF2.7
7C30:  BSF    19.7
7C32:  BCF    FF2.7
7C34:  CALL   172E
7C38:  BTFSC  19.7
7C3A:  BSF    FF2.7
7C3C:  CLRF   19
7C3E:  BTFSC  FF2.7
7C40:  BSF    19.7
7C42:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7C44:  MOVLW  0A
7C46:  MOVLB  9
7C48:  MOVWF  x0C
7C4A:  MOVLB  0
7C4C:  CALL   1604
7C50:  BTFSC  19.7
7C52:  BSF    FF2.7
7C54:  CLRF   19
7C56:  BTFSC  FF2.7
7C58:  BSF    19.7
7C5A:  BCF    FF2.7
7C5C:  MOVLW  0D
7C5E:  MOVLB  9
7C60:  MOVWF  x0C
7C62:  MOVLB  0
7C64:  CALL   1604
7C68:  BTFSC  19.7
7C6A:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7C6C:  MOVLW  01
7C6E:  MOVLB  7
7C70:  MOVWF  xF3
7C72:  MOVLW  03
7C74:  MOVWF  xF4
7C76:  MOVLW  07
7C78:  MOVWF  xF6
7C7A:  MOVLW  C1
7C7C:  MOVWF  xF5
7C7E:  MOVLB  0
7C80:  CALL   5F7E
....................           debugmode = (unsigned int8)strtoi(temp); 
7C84:  MOVLW  07
7C86:  MOVLB  7
7C88:  MOVWF  xF4
7C8A:  MOVLW  C1
7C8C:  MOVWF  xF3
7C8E:  MOVLB  0
7C90:  CALL   6B54
7C94:  MOVFF  01,6D6
7C98:  CLRF   19
7C9A:  BTFSC  FF2.7
7C9C:  BSF    19.7
7C9E:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
7CA0:  MOVLB  9
7CA2:  CLRF   x16
7CA4:  CLRF   x15
7CA6:  CLRF   x14
7CA8:  MOVLW  3B
7CAA:  MOVWF  x13
7CAC:  MOVFF  6D6,917
7CB0:  MOVLB  0
7CB2:  CALL   3A6C
7CB6:  BTFSC  19.7
7CB8:  BSF    FF2.7
7CBA:  CLRF   19
7CBC:  BTFSC  FF2.7
7CBE:  BSF    19.7
7CC0:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7CC2:  MOVLW  0A
7CC4:  MOVLB  9
7CC6:  MOVWF  x0C
7CC8:  MOVLB  0
7CCA:  CALL   1604
7CCE:  BTFSC  19.7
7CD0:  BSF    FF2.7
7CD2:  CLRF   19
7CD4:  BTFSC  FF2.7
7CD6:  BSF    19.7
7CD8:  BCF    FF2.7
7CDA:  MOVLW  0D
7CDC:  MOVLB  9
7CDE:  MOVWF  x0C
7CE0:  MOVLB  0
7CE2:  CALL   1604
7CE6:  BTFSC  19.7
7CE8:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
7CEA:  GOTO   83D2 (RETURN)
.................... //=============================================== 
....................  
....................  
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    if(keydebug_en==1) 
*
59DA:  MOVLB  1
59DC:  DECFSZ x44,W
59DE:  BRA    59FA
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
59E0:  MOVLB  6
59E2:  MOVF   xE2,F
59E4:  BNZ   59EE
59E6:  MOVLB  0
59E8:  CALL   1F7C
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
59EC:  BRA    59F8
59EE:  MOVLB  0
59F0:  CALL   31E0
59F4:  MOVFF  01,84F
59F8:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
59FA:  DECFSZ x45,W
59FC:  BRA    5A16
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
59FE:  MOVLB  6
5A00:  MOVF   xE2,F
5A02:  BNZ   5A0C
5A04:  MOVLB  0
5A06:  CALL   1F7C
....................          else temp=kbd_getc_slv(); 
5A0A:  BRA    5A16
5A0C:  MOVLB  0
5A0E:  CALL   31E0
5A12:  MOVFF  01,84F
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
5A16:  MOVLB  6
5A18:  MOVF   xC7,F
5A1A:  BNZ   5A3A
5A1C:  MOVF   xC6,F
5A1E:  BNZ   5A3A
5A20:  MOVF   xC5,F
5A22:  BNZ   5A3A
5A24:  MOVF   xC4,W
5A26:  SUBLW  04
5A28:  BNC   5A3A
5A2A:  MOVLW  01
5A2C:  ADDWF  xC4,F
5A2E:  BTFSC  FD8.0
5A30:  INCF   xC5,F
5A32:  BTFSC  FD8.2
5A34:  INCF   xC6,F
5A36:  BTFSC  FD8.2
5A38:  INCF   xC7,F
....................   if(mcr_timeout==5) 
5A3A:  MOVF   xC4,W
5A3C:  SUBLW  05
5A3E:  BNZ   5AAA
5A40:  MOVF   xC5,F
5A42:  BNZ   5AAA
5A44:  MOVF   xC6,F
5A46:  BNZ   5AAA
5A48:  MOVF   xC7,F
5A4A:  BNZ   5AAA
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1) 
5A4C:  DECFSZ xDA,W
5A4E:  BRA    5A68
....................       { 
....................           if(cryption_enable==0)  
5A50:  MOVLB  1
5A52:  MOVF   x22,F
5A54:  BNZ   5A60
....................           { 
....................                 saving_card(); 
5A56:  MOVLB  0
5A58:  GOTO   3C02
....................           } 
....................           else  
5A5C:  BRA    5A66
5A5E:  MOVLB  1
....................           { 
....................                 saving_card_encrypt(); 
5A60:  MOVLB  0
5A62:  GOTO   4FEE
5A66:  MOVLB  6
....................           } 
....................       } 
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
5A68:  MOVLW  02
5A6A:  MOVWF  FEA
5A6C:  MOVLW  46
5A6E:  MOVWF  FE9
5A70:  CLRF   00
5A72:  MOVLW  03
5A74:  MOVWF  02
5A76:  MOVLW  52
5A78:  MOVWF  01
5A7A:  MOVLB  0
5A7C:  CALL   359A
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
5A80:  MOVLW  05
5A82:  MOVWF  FEA
5A84:  MOVLW  98
5A86:  MOVWF  FE9
5A88:  CLRF   00
5A8A:  MOVLW  01
5A8C:  MOVWF  02
5A8E:  MOVLW  2C
5A90:  MOVWF  01
5A92:  CALL   359A
....................       //debug_card(); 
....................       count_reading_error=0; 
5A96:  MOVLB  6
5A98:  CLRF   xDB
....................       mcr_timeout++;   
5A9A:  MOVLW  01
5A9C:  ADDWF  xC4,F
5A9E:  BTFSC  FD8.0
5AA0:  INCF   xC5,F
5AA2:  BTFSC  FD8.2
5AA4:  INCF   xC6,F
5AA6:  BTFSC  FD8.2
5AA8:  INCF   xC7,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
5AAA:  MOVLB  9
5AAC:  CLRF   x1B
5AAE:  CLRF   x1A
5AB0:  CLRF   x19
5AB2:  MOVLW  3C
5AB4:  MOVWF  x18
5AB6:  MOVLB  0
5AB8:  CALL   3450
5ABC:  MOVFF  01,15A
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
5AC0:  MOVLW  02
5AC2:  MOVLB  8
5AC4:  MOVWF  x56
5AC6:  MOVLW  BC
5AC8:  MOVWF  x55
5ACA:  CLRF   x58
5ACC:  MOVFF  15A,857
5AD0:  MOVLB  0
5AD2:  CALL   3578
5AD6:  MOVFF  02,03
5ADA:  MOVF   01,W
5ADC:  MOVLB  1
5ADE:  MOVF   x00,W
5AE0:  SUBWF  02,W
5AE2:  BNC   5B02
5AE4:  BNZ   5AF4
5AE6:  MOVF   01,W
5AE8:  MOVLB  0
5AEA:  SUBWF  xFF,W
5AEC:  BTFSS  FD8.0
5AEE:  BRA    5AF4
5AF0:  MOVLB  1
5AF2:  BRA    5B02
5AF4:  MOVLB  0
5AF6:  INCF   xFF,F
5AF8:  BTFSS  FD8.2
5AFA:  BRA    5B02
5AFC:  MOVLB  1
5AFE:  INCF   x00,F
5B00:  MOVLB  0
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
5B02:  MOVLW  02
5B04:  MOVLB  8
5B06:  MOVWF  x56
5B08:  MOVLW  BC
5B0A:  MOVWF  x55
5B0C:  CLRF   x58
5B0E:  MOVFF  15A,857
5B12:  MOVLB  0
5B14:  CALL   3578
5B18:  MOVFF  02,03
5B1C:  MOVF   01,W
5B1E:  SUBWF  xFF,W
5B20:  BNZ   5BE6
5B22:  MOVF   03,W
5B24:  MOVLB  1
5B26:  SUBWF  x00,W
5B28:  BTFSC  FD8.2
5B2A:  BRA    5B30
5B2C:  MOVLB  0
5B2E:  BRA    5BE6
....................   { 
....................       charac_timeout++; 
5B30:  MOVLB  0
5B32:  INCF   xFF,F
5B34:  BTFSS  FD8.2
5B36:  BRA    5B3E
5B38:  MOVLB  1
5B3A:  INCF   x00,F
5B3C:  MOVLB  0
....................       buf=get_countcard(); 
5B3E:  CALL   351C
5B42:  MOVFF  02,84E
5B46:  MOVFF  01,84D
....................       if(buf<countcards) 
5B4A:  MOVLB  8
5B4C:  MOVF   x4E,W
5B4E:  SUBLW  03
5B50:  BNC   5B86
5B52:  BNZ   5B5A
5B54:  MOVF   x4D,W
5B56:  SUBLW  A1
5B58:  BNC   5B86
....................       { 
....................          if(cryption_enable==0)  
5B5A:  MOVLB  1
5B5C:  MOVF   x22,F
5B5E:  BNZ   5B68
....................          { 
....................             save_key_new(); 
5B60:  MOVLB  0
5B62:  BRA    54B6
....................          } 
....................          else 
5B64:  BRA    5B6C
5B66:  MOVLB  1
....................          { 
....................             save_key_encrypt(); 
5B68:  MOVLB  0
5B6A:  BRA    5654
....................          } 
....................          buf=buf+1; 
5B6C:  MOVLW  01
5B6E:  MOVLB  8
5B70:  ADDWF  x4D,F
5B72:  MOVLW  00
5B74:  ADDWFC x4E,F
....................          save_coutcard(buf); 
5B76:  MOVFF  84E,851
5B7A:  MOVFF  84D,850
5B7E:  MOVLB  0
5B80:  RCALL  589C
....................       } 
....................          else 
5B82:  BRA    5B96
5B84:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
5B86:  MOVLW  EC
5B88:  MOVWF  FF6
5B8A:  MOVLW  5B
5B8C:  MOVWF  FF7
5B8E:  MOVLB  0
5B90:  CALL   172E
....................             return; 
5B94:  BRA    5BE6
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
5B96:  MOVLW  FC
5B98:  MOVWF  FF6
5B9A:  MOVLW  5B
5B9C:  MOVWF  FF7
5B9E:  CALL   172E
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
5BA2:  MOVLW  0C
5BA4:  MOVWF  FF6
5BA6:  MOVLW  5C
5BA8:  MOVWF  FF7
5BAA:  MOVLW  14
5BAC:  MOVLB  8
5BAE:  MOVWF  xF7
5BB0:  MOVLB  0
5BB2:  CALL   164A
5BB6:  MOVLW  10
5BB8:  MOVWF  FE9
5BBA:  MOVFF  84E,851
5BBE:  MOVFF  84D,850
5BC2:  RCALL  58E4
5BC4:  MOVLW  23
5BC6:  MOVWF  FF6
5BC8:  MOVLW  5C
5BCA:  MOVWF  FF7
5BCC:  MOVLW  03
5BCE:  MOVLB  8
5BD0:  MOVWF  xF7
5BD2:  MOVLB  0
5BD4:  CALL   164A
....................       data_avai=0; 
5BD8:  MOVLB  6
5BDA:  CLRF   xD9
....................       enable_getpin=0; 
5BDC:  MOVLB  1
5BDE:  CLRF   x45
....................       //dis_getpin; 
....................       output_low(LED); 
5BE0:  BCF    F92.6
5BE2:  BCF    F89.6
5BE4:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
5BE6:  BCF    FF2.2
5BE8:  GOTO   006C
.................... void main() 
.................... {  
*
7CEE:  CLRF   FF8
7CF0:  BCF    FD0.7
7CF2:  BSF    07.7
7CF4:  CLRF   FEA
7CF6:  CLRF   FE9
7CF8:  BCF    F94.0
7CFA:  BSF    F8B.0
7CFC:  CLRF   23
7CFE:  CLRF   22
7D00:  CLRF   21
7D02:  MOVLW  96
7D04:  MOVWF  20
7D06:  CLRF   27
7D08:  CLRF   26
7D0A:  MOVLW  E1
7D0C:  MOVWF  25
7D0E:  MOVLW  01
7D10:  MOVWF  24
7D12:  CLRF   xFE
7D14:  CLRF   xFD
7D16:  MOVLB  1
7D18:  SETF   x00
7D1A:  MOVLB  0
7D1C:  SETF   xFF
7D1E:  MOVLB  1
7D20:  CLRF   x22
7D22:  CLRF   x43
7D24:  CLRF   x44
7D26:  CLRF   x45
7D28:  MOVLW  64
7D2A:  MOVWF  x46
7D2C:  CLRF   x47
7D2E:  CLRF   x48
7D30:  CLRF   x49
7D32:  CLRF   x5A
7D34:  CLRF   x5F
7D36:  CLRF   xC6
7D38:  CLRF   xC7
7D3A:  MOVLW  0E
7D3C:  MOVWF  xC9
7D3E:  MOVLW  01
7D40:  MOVWF  xCA
7D42:  MOVWF  xCB
7D44:  CLRF   xCC
7D46:  CLRF   xCD
7D48:  CLRF   xCE
7D4A:  MOVLB  6
7D4C:  CLRF   xC7
7D4E:  CLRF   xC6
7D50:  CLRF   xC5
7D52:  CLRF   xC4
7D54:  CLRF   xC8
7D56:  CLRF   xCA
7D58:  CLRF   xC9
7D5A:  CLRF   xCC
7D5C:  CLRF   xCB
7D5E:  CLRF   xCE
7D60:  CLRF   xCD
7D62:  CLRF   xD0
7D64:  CLRF   xCF
7D66:  MOVLW  FD
7D68:  MOVWF  xD2
7D6A:  MOVLW  E8
7D6C:  MOVWF  xD1
7D6E:  CLRF   xD4
7D70:  CLRF   xD3
7D72:  CLRF   xD5
7D74:  CLRF   xD6
7D76:  CLRF   xD7
7D78:  CLRF   xD8
7D7A:  CLRF   xD9
7D7C:  CLRF   xDA
7D7E:  CLRF   xDB
7D80:  CLRF   xDC
7D82:  CLRF   xDD
7D84:  CLRF   xDF
7D86:  MOVLW  01
7D88:  MOVWF  xDE
7D8A:  CLRF   xE1
7D8C:  CLRF   xE0
7D8E:  CLRF   xE2
7D90:  CLRF   xE6
7D92:  CLRF   xE5
7D94:  CLRF   xE4
7D96:  CLRF   xE3
7D98:  MOVLW  FF
7D9A:  MOVLB  F
7D9C:  MOVWF  x48
7D9E:  BCF    FC2.6
7DA0:  BCF    FC2.7
7DA2:  MOVF   x49,W
7DA4:  ANDLW  E0
7DA6:  IORLW  1F
7DA8:  MOVWF  x49
7DAA:  CLRF   FD2
7DAC:  CLRF   FD1
7DAE:  CLRF   1A
7DB0:  CLRF   1B
7DB2:  MOVLW  E8
7DB4:  MOVLB  1
7DB6:  MOVWF  x23
7DB8:  MOVLW  E9
7DBA:  MOVWF  x24
7DBC:  MOVLW  EA
7DBE:  MOVWF  x25
7DC0:  MOVLW  EB
7DC2:  MOVWF  x26
7DC4:  MOVLW  ED
7DC6:  MOVWF  x27
7DC8:  MOVLW  EE
7DCA:  MOVWF  x28
7DCC:  MOVLW  EF
7DCE:  MOVWF  x29
7DD0:  MOVLW  F0
7DD2:  MOVWF  x2A
7DD4:  MOVLW  F2
7DD6:  MOVWF  x2B
7DD8:  MOVLW  F3
7DDA:  MOVWF  x2C
7DDC:  MOVLW  F4
7DDE:  MOVWF  x2D
7DE0:  MOVLW  F5
7DE2:  MOVWF  x2E
7DE4:  MOVLW  F7
7DE6:  MOVWF  x2F
7DE8:  MOVLW  F8
7DEA:  MOVWF  x30
7DEC:  MOVLW  F9
7DEE:  MOVWF  x31
7DF0:  MOVLW  FA
7DF2:  MOVWF  x32
7DF4:  MOVLW  67
7DF6:  MOVWF  x33
7DF8:  MOVLW  43
7DFA:  MOVWF  x34
7DFC:  MOVLW  C3
7DFE:  MOVWF  x35
7E00:  MOVLW  D1
7E02:  MOVWF  x36
7E04:  MOVLW  51
7E06:  MOVWF  x37
7E08:  MOVLW  9A
7E0A:  MOVWF  x38
7E0C:  MOVLW  B4
7E0E:  MOVWF  x39
7E10:  MOVLW  F2
7E12:  MOVWF  x3A
7E14:  MOVLW  CD
7E16:  MOVWF  x3B
7E18:  MOVLW  9A
7E1A:  MOVWF  x3C
7E1C:  MOVLW  78
7E1E:  MOVWF  x3D
7E20:  MOVLW  AB
7E22:  MOVWF  x3E
7E24:  MOVLW  09
7E26:  MOVWF  x3F
7E28:  MOVLW  A5
7E2A:  MOVWF  x40
7E2C:  MOVLW  11
7E2E:  MOVWF  x41
7E30:  MOVLW  BD
7E32:  MOVWF  x42
7E34:  CLRF   x5B
7E36:  BCF    x5C.0
7E38:  CLRF   x5D
7E3A:  CLRF   x5E
7E3C:  CLRF   x60
7E3E:  BCF    x5C.1
7E40:  CLRF   x61
7E42:  MOVLB  6
7E44:  CLRF   xF7
7E46:  CLRF   xF8
7E48:  CLRF   xF9
7E4A:  CLRF   xFA
7E4C:  CLRF   xFB
7E4E:  CLRF   xFC
7E50:  CLRF   xFD
7E52:  CLRF   xFE
7E54:  CLRF   xFF
7E56:  MOVLB  7
7E58:  CLRF   x00
7E5A:  CLRF   x03
7E5C:  CLRF   x05
7E5E:  CLRF   x04
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    RPINR1=5; 
7E60:  MOVLW  05
7E62:  MOVLB  E
7E64:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
7E66:  MOVLB  1
7E68:  SETF   x00
7E6A:  MOVLB  0
7E6C:  SETF   xFF
....................    setup_oscillator(OSC_32MHZ); 
7E6E:  MOVLW  70
7E70:  MOVWF  FD3
7E72:  MOVLW  40
7E74:  MOVWF  F9B
7E76:  MOVF   FD3,W
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
7E78:  BCF    FF2.6
7E7A:  BCF    FF2.7
7E7C:  BTFSC  FF2.7
7E7E:  BRA    7E7A
....................    init_ext_eeprom(); 
7E80:  GOTO   5D10
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif   
....................    //===================================== 
....................    delay_ms(1000); 
7E84:  MOVLW  04
7E86:  MOVLB  7
7E88:  MOVWF  xBD
7E8A:  CLRF   19
7E8C:  BTFSC  FF2.7
7E8E:  BSF    19.7
7E90:  BCF    FF2.7
7E92:  MOVLW  FA
7E94:  MOVLB  8
7E96:  MOVWF  x56
7E98:  MOVLB  0
7E9A:  CALL   18C6
7E9E:  BTFSC  19.7
7EA0:  BSF    FF2.7
7EA2:  MOVLB  7
7EA4:  DECFSZ xBD,F
7EA6:  BRA    7E8A
....................    init_password(); 
7EA8:  MOVLB  0
7EAA:  CALL   5D1A
....................    //===================================== 
....................    fprintf(COM2,"\n\rbooting\n\r"); 
7EAE:  MOVLW  28
7EB0:  MOVWF  FF6
7EB2:  MOVLW  5C
7EB4:  MOVWF  FF7
7EB6:  CLRF   19
7EB8:  BTFSC  FF2.7
7EBA:  BSF    19.7
7EBC:  BCF    FF2.7
7EBE:  CALL   172E
7EC2:  BTFSC  19.7
7EC4:  BSF    FF2.7
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
7EC6:  MOVLW  19
7EC8:  MOVLB  7
7ECA:  MOVWF  xBD
7ECC:  MOVLB  0
7ECE:  CALL   5DDA
7ED2:  MOVFF  03,23
7ED6:  MOVFF  02,22
7EDA:  MOVFF  01,21
7EDE:  MOVFF  00,20
....................    fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
7EE2:  MOVLW  34
7EE4:  MOVWF  FF6
7EE6:  MOVLW  5C
7EE8:  MOVWF  FF7
7EEA:  CLRF   19
7EEC:  BTFSC  FF2.7
7EEE:  BSF    19.7
7EF0:  BCF    FF2.7
7EF2:  MOVLW  0E
7EF4:  MOVLB  8
7EF6:  MOVWF  xF7
7EF8:  MOVLB  0
7EFA:  CALL   164A
7EFE:  BTFSC  19.7
7F00:  BSF    FF2.7
7F02:  MOVLW  41
7F04:  MOVWF  FE9
7F06:  CLRF   19
7F08:  BTFSC  FF2.7
7F0A:  BSF    19.7
7F0C:  BCF    FF2.7
7F0E:  MOVFF  23,8FA
7F12:  MOVFF  22,8F9
7F16:  MOVFF  21,8F8
7F1A:  MOVFF  20,8F7
7F1E:  CALL   22FA
7F22:  BTFSC  19.7
7F24:  BSF    FF2.7
7F26:  CLRF   19
7F28:  BTFSC  FF2.7
7F2A:  BSF    19.7
7F2C:  BCF    FF2.7
7F2E:  MOVLW  0A
7F30:  MOVLB  9
7F32:  MOVWF  x0C
7F34:  MOVLB  0
7F36:  CALL   1604
7F3A:  BTFSC  19.7
7F3C:  BSF    FF2.7
7F3E:  CLRF   19
7F40:  BTFSC  FF2.7
7F42:  BSF    19.7
7F44:  BCF    FF2.7
7F46:  MOVLW  0D
7F48:  MOVLB  9
7F4A:  MOVWF  x0C
7F4C:  MOVLB  0
7F4E:  CALL   1604
7F52:  BTFSC  19.7
7F54:  BSF    FF2.7
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
7F56:  MOVLW  1E
7F58:  MOVLB  7
7F5A:  MOVWF  xBD
7F5C:  MOVLB  0
7F5E:  CALL   5DDA
7F62:  MOVFF  03,27
7F66:  MOVFF  02,26
7F6A:  MOVFF  01,25
7F6E:  MOVFF  00,24
....................    fprintf(COM2,"max address: 0x%lx\n\r", EEPROM_SIZE_endofkey); 
7F72:  MOVLW  48
7F74:  MOVWF  FF6
7F76:  MOVLW  5C
7F78:  MOVWF  FF7
7F7A:  CLRF   19
7F7C:  BTFSC  FF2.7
7F7E:  BSF    19.7
7F80:  BCF    FF2.7
7F82:  MOVLW  0F
7F84:  MOVLB  8
7F86:  MOVWF  xF7
7F88:  MOVLB  0
7F8A:  CALL   164A
7F8E:  BTFSC  19.7
7F90:  BSF    FF2.7
7F92:  CLRF   19
7F94:  BTFSC  FF2.7
7F96:  BSF    19.7
7F98:  BCF    FF2.7
7F9A:  MOVLB  9
7F9C:  SETF   x01
7F9E:  MOVLW  57
7FA0:  MOVWF  x02
7FA2:  MOVLB  0
7FA4:  CALL   4FA4
7FA8:  BTFSC  19.7
7FAA:  BSF    FF2.7
7FAC:  CLRF   19
7FAE:  BTFSC  FF2.7
7FB0:  BSF    19.7
7FB2:  BCF    FF2.7
7FB4:  MOVLB  9
7FB6:  SETF   x01
7FB8:  MOVLW  57
7FBA:  MOVWF  x02
7FBC:  MOVLB  0
7FBE:  CALL   4FA4
7FC2:  BTFSC  19.7
7FC4:  BSF    FF2.7
7FC6:  CLRF   19
7FC8:  BTFSC  FF2.7
7FCA:  BSF    19.7
7FCC:  BCF    FF2.7
7FCE:  MOVLW  0A
7FD0:  MOVLB  9
7FD2:  MOVWF  x0C
7FD4:  MOVLB  0
7FD6:  CALL   1604
7FDA:  BTFSC  19.7
7FDC:  BSF    FF2.7
7FDE:  CLRF   19
7FE0:  BTFSC  FF2.7
7FE2:  BSF    19.7
7FE4:  BCF    FF2.7
7FE6:  MOVLW  0D
7FE8:  MOVLB  9
7FEA:  MOVWF  x0C
7FEC:  MOVLB  0
7FEE:  CALL   1604
7FF2:  BTFSC  19.7
7FF4:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
7FF6:  MOVLW  5E
7FF8:  MOVWF  FF6
7FFA:  MOVLW  5C
7FFC:  MOVWF  FF7
7FFE:  CLRF   19
8000:  BTFSC  FF2.7
8002:  BSF    19.7
8004:  BCF    FF2.7
8006:  MOVLW  12
8008:  MOVLB  8
800A:  MOVWF  xF7
800C:  MOVLB  0
800E:  CALL   164A
8012:  BTFSC  19.7
8014:  BSF    FF2.7
8016:  MOVLW  41
8018:  MOVWF  FE9
801A:  CLRF   19
801C:  BTFSC  FF2.7
801E:  BSF    19.7
8020:  BCF    FF2.7
8022:  MOVFF  27,8FA
8026:  MOVFF  26,8F9
802A:  MOVFF  25,8F8
802E:  MOVFF  24,8F7
8032:  CALL   22FA
8036:  BTFSC  19.7
8038:  BSF    FF2.7
803A:  CLRF   19
803C:  BTFSC  FF2.7
803E:  BSF    19.7
8040:  BCF    FF2.7
8042:  MOVLW  0A
8044:  MOVLB  9
8046:  MOVWF  x0C
8048:  MOVLB  0
804A:  CALL   1604
804E:  BTFSC  19.7
8050:  BSF    FF2.7
8052:  CLRF   19
8054:  BTFSC  FF2.7
8056:  BSF    19.7
8058:  BCF    FF2.7
805A:  MOVLW  0D
805C:  MOVLB  9
805E:  MOVWF  x0C
8060:  MOVLB  0
8062:  CALL   1604
8066:  BTFSC  19.7
8068:  BSF    FF2.7
806A:  CLRF   19
806C:  BTFSC  FF2.7
806E:  BSF    19.7
8070:  BCF    FF2.7
....................    countcard=get_countcard(); 
8072:  CALL   351C
8076:  BTFSC  19.7
8078:  BSF    FF2.7
807A:  MOVFF  02,FE
807E:  MOVFF  01,FD
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
8082:  MOVLB  1
8084:  SETF   x00
8086:  MOVLB  0
8088:  SETF   xFF
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
808A:  MOVLW  C7
808C:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
808E:  MOVLW  37
8090:  MOVWF  FCD
8092:  CLRF   F9A
8094:  CLRF   19
8096:  BTFSC  FF2.7
8098:  BSF    19.7
809A:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
809C:  MOVLB  9
809E:  CLRF   x1B
80A0:  CLRF   x1A
80A2:  CLRF   x19
80A4:  MOVLW  3C
80A6:  MOVWF  x18
80A8:  MOVLB  0
80AA:  CALL   3450
80AE:  BTFSC  19.7
80B0:  BSF    FF2.7
80B2:  MOVFF  01,15A
....................    if(delaycharaction==0)delaycharaction=1; 
80B6:  MOVLB  1
80B8:  MOVF   x5A,F
80BA:  BNZ   80C0
80BC:  MOVLW  01
80BE:  MOVWF  x5A
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
80C0:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
80C2:  BSF    FF0.3
80C4:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
80C6:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
80C8:  MOVLW  C0
80CA:  IORWF  FF2,F
....................   
....................     mcr_timeout=10000; 
80CC:  MOVLB  6
80CE:  CLRF   xC7
80D0:  CLRF   xC6
80D2:  MOVLW  27
80D4:  MOVWF  xC5
80D6:  MOVLW  10
80D8:  MOVWF  xC4
80DA:  CLRF   19
80DC:  BTFSC  FF2.7
80DE:  BSF    19.7
80E0:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
80E2:  MOVLB  9
80E4:  CLRF   x1B
80E6:  CLRF   x1A
80E8:  CLRF   x19
80EA:  MOVLW  3A
80EC:  MOVWF  x18
80EE:  MOVLB  0
80F0:  CALL   3450
80F4:  BTFSC  19.7
80F6:  BSF    FF2.7
80F8:  MOVFF  01,6E2
80FC:  CLRF   19
80FE:  BTFSC  FF2.7
8100:  BSF    19.7
8102:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
8104:  MOVLB  9
8106:  CLRF   x1B
8108:  CLRF   x1A
810A:  CLRF   x19
810C:  MOVLW  3B
810E:  MOVWF  x18
8110:  MOVLB  0
8112:  CALL   3450
8116:  BTFSC  19.7
8118:  BSF    FF2.7
811A:  MOVFF  01,6D6
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
811E:  MOVLB  1
8120:  SETF   x00
8122:  MOVLB  0
8124:  SETF   xFF
8126:  CLRF   19
8128:  BTFSC  FF2.7
812A:  BSF    19.7
812C:  BCF    FF2.7
....................     
....................    EEPROM_read(strobe_nameconsole,wide_strobe_nameconsole,console); 
812E:  MOVLB  9
8130:  CLRF   x07
8132:  CLRF   x06
8134:  CLRF   x05
8136:  MOVLW  28
8138:  MOVWF  x04
813A:  CLRF   x0B
813C:  CLRF   x0A
813E:  CLRF   x09
8140:  MOVLW  10
8142:  MOVWF  x08
8144:  MOVLW  06
8146:  MOVWF  x0D
8148:  MOVLW  E7
814A:  MOVWF  x0C
814C:  MOVLB  0
814E:  CALL   3FF6
8152:  BTFSC  19.7
8154:  BSF    FF2.7
....................    set_tris_a(0xff);  
8156:  MOVLW  FF
8158:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
815A:  MOVLW  E0
815C:  MOVLB  F
815E:  MOVWF  x48
8160:  BCF    FC2.6
8162:  BCF    FC2.7
8164:  MOVF   x49,W
8166:  ANDLW  E0
8168:  IORLW  1F
816A:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
816C:  MOVF   FC1,W
816E:  ANDLW  C0
8170:  IORLW  03
8172:  MOVWF  FC1
8174:  BCF    FC1.7
8176:  BSF    FC2.0
8178:  BSF    FC1.6
817A:  BSF    FC2.1
817C:  BTFSC  FC2.1
817E:  BRA    817C
8180:  BCF    FC1.6
8182:  CLRF   19
8184:  BTFSC  FF2.7
8186:  BSF    19.7
8188:  BCF    FF2.7
....................     
....................    type_KB=read_ext_eeprom(kindofKB); 
818A:  MOVLB  9
818C:  CLRF   x1B
818E:  CLRF   x1A
8190:  CLRF   x19
8192:  MOVLW  3D
8194:  MOVWF  x18
8196:  MOVLB  0
8198:  CALL   3450
819C:  BTFSC  19.7
819E:  BSF    FF2.7
81A0:  MOVFF  01,149
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
81A4:  MOVLB  1
81A6:  MOVF   x49,F
81A8:  BZ    81C8
81AA:  MOVLW  76
81AC:  MOVWF  FF6
81AE:  MOVLW  5C
81B0:  MOVWF  FF7
81B2:  CLRF   19
81B4:  BTFSC  FF2.7
81B6:  BSF    19.7
81B8:  BCF    FF2.7
81BA:  MOVLB  0
81BC:  CALL   172E
81C0:  BTFSC  19.7
81C2:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
81C4:  BRA    81E2
81C6:  MOVLB  1
81C8:  MOVLW  8A
81CA:  MOVWF  FF6
81CC:  MOVLW  5C
81CE:  MOVWF  FF7
81D0:  CLRF   19
81D2:  BTFSC  FF2.7
81D4:  BSF    19.7
81D6:  BCF    FF2.7
81D8:  MOVLB  0
81DA:  CALL   172E
81DE:  BTFSC  19.7
81E0:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
81E2:  MOVLB  6
81E4:  MOVF   xE2,F
81E6:  BNZ   8206
81E8:  MOVLW  9E
81EA:  MOVWF  FF6
81EC:  MOVLW  5C
81EE:  MOVWF  FF7
81F0:  CLRF   19
81F2:  BTFSC  FF2.7
81F4:  BSF    19.7
81F6:  BCF    FF2.7
81F8:  MOVLB  0
81FA:  CALL   172E
81FE:  BTFSC  19.7
8200:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
8202:  BRA    8220
8204:  MOVLB  6
8206:  MOVLW  B8
8208:  MOVWF  FF6
820A:  MOVLW  5C
820C:  MOVWF  FF7
820E:  CLRF   19
8210:  BTFSC  FF2.7
8212:  BSF    19.7
8214:  BCF    FF2.7
8216:  MOVLB  0
8218:  CALL   172E
821C:  BTFSC  19.7
821E:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
8220:  MOVLW  01
8222:  MOVWF  FEA
8224:  MOVLW  4A
8226:  MOVWF  FE9
8228:  CLRF   00
822A:  CLRF   02
822C:  MOVLW  10
822E:  MOVWF  01
8230:  CALL   359A
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
8234:  MOVLB  7
8236:  CLRF   x01
8238:  MOVF   x01,W
823A:  SUBLW  13
823C:  BNC   8252
....................    { 
....................       password[i] = 0; 
823E:  CLRF   03
8240:  MOVF   x01,W
8242:  ADDLW  55
8244:  MOVWF  FE9
8246:  MOVLW  00
8248:  ADDWFC 03,W
824A:  MOVWF  FEA
824C:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 0 
....................    disable_interrupts(GLOBAL); 
....................    save_coutcard(0); 
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................     
....................    save_key_encrypt(); 
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
....................     
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_data in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_key in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],1); 
....................    //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rdecrypted:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    while(1); 
.................... #endif 
.................... #if 0 
824E:  INCF   x01,F
8250:  BRA    8238
8252:  CLRF   19
8254:  BTFSC  FF2.7
8256:  BSF    19.7
8258:  BCF    FF2.7
....................     fprintf(COM2,"\n\reeprom test\n\r"); 
....................     fprintf(COM2,"\n\reeprom is writing\n\r"); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         //write_ext_eeprom(115535+i,i); 
....................     } 
....................     write_ext_eeprom(EEPROM_KEY_ST,210); 
....................     write_ext_eeprom(EEPROM_SIZE_endofkey,123); 
....................     fprintf(COM2,"\n\r"); 
....................     fprintf(COM2,"eeprom is reading: %u",read_ext_eeprom(EEPROM_KEY_ST)); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         fprintf(COM2," %u",read_ext_eeprom(115535+i)); 
....................     } 
....................     while(1); 
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
825A:  MOVLB  9
825C:  CLRF   x07
825E:  CLRF   x06
8260:  CLRF   x05
8262:  CLRF   x04
8264:  CLRF   x0B
8266:  CLRF   x0A
8268:  CLRF   x09
826A:  MOVLW  14
826C:  MOVWF  x08
826E:  CLRF   x0D
8270:  MOVLW  55
8272:  MOVWF  x0C
8274:  MOVLB  0
8276:  CALL   3FF6
827A:  BTFSC  19.7
827C:  BSF    FF2.7
827E:  CLRF   19
8280:  BTFSC  FF2.7
8282:  BSF    19.7
8284:  BCF    FF2.7
....................    cryption_enable = read_ext_eeprom(crypto_en); 
8286:  MOVLB  9
8288:  CLRF   x1B
828A:  CLRF   x1A
828C:  CLRF   x19
828E:  MOVLW  3E
8290:  MOVWF  x18
8292:  MOVLB  0
8294:  CALL   3450
8298:  BTFSC  19.7
829A:  BSF    FF2.7
829C:  MOVFF  01,122
....................    if(cryption_enable!=0) 
82A0:  MOVLB  1
82A2:  MOVF   x22,F
82A4:  BZ    82F2
....................    { 
....................         fprintf(COM2,"\n\crypto is enable\n\r"); 
82A6:  MOVLW  D0
82A8:  MOVWF  FF6
82AA:  MOVLW  5C
82AC:  MOVWF  FF7
82AE:  CLRF   19
82B0:  BTFSC  FF2.7
82B2:  BSF    19.7
82B4:  BCF    FF2.7
82B6:  MOVLB  0
82B8:  CALL   172E
82BC:  BTFSC  19.7
82BE:  BSF    FF2.7
82C0:  CLRF   19
82C2:  BTFSC  FF2.7
82C4:  BSF    19.7
82C6:  BCF    FF2.7
....................         EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key);  
82C8:  MOVLB  9
82CA:  CLRF   x07
82CC:  CLRF   x06
82CE:  CLRF   x05
82D0:  MOVLW  3F
82D2:  MOVWF  x04
82D4:  CLRF   x0B
82D6:  CLRF   x0A
82D8:  CLRF   x09
82DA:  MOVLW  20
82DC:  MOVWF  x08
82DE:  MOVLW  01
82E0:  MOVWF  x0D
82E2:  MOVWF  x0C
82E4:  MOVLB  0
82E6:  CALL   3FF6
82EA:  BTFSC  19.7
82EC:  BSF    FF2.7
....................    } 
....................    else 
82EE:  BRA    830C
82F0:  MOVLB  1
....................    { 
....................        fprintf(COM2,"\n\crypto is disable\n\r"); 
82F2:  MOVLW  E4
82F4:  MOVWF  FF6
82F6:  MOVLW  5C
82F8:  MOVWF  FF7
82FA:  CLRF   19
82FC:  BTFSC  FF2.7
82FE:  BSF    19.7
8300:  BCF    FF2.7
8302:  MOVLB  0
8304:  CALL   172E
8308:  BTFSC  19.7
830A:  BSF    FF2.7
....................    } 
.................... #if 0    
....................    fprintf(COM2,"\n\crypto key:\n\r"); 
....................    for(i=0;i<CRYPTO_KEY_SIZE;i++) 
....................    { 
....................         fprintf(COM2,"%c",crypto_key[i]); 
....................    } 
....................    fprintf(COM2,"\n\r"); 
.................... #endif    
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
830C:  MOVLB  6
830E:  MOVF   xDC,F
8310:  BNZ   83C8
....................       { 
....................          fprintf(COM2,"password:"); 
8312:  MOVLW  FA
8314:  MOVWF  FF6
8316:  MOVLW  5C
8318:  MOVWF  FF7
831A:  CLRF   19
831C:  BTFSC  FF2.7
831E:  BSF    19.7
8320:  BCF    FF2.7
8322:  MOVLB  0
8324:  CALL   172E
8328:  BTFSC  19.7
832A:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
832C:  MOVLW  02
832E:  MOVLB  7
8330:  MOVWF  xF3
8332:  MOVLW  14
8334:  MOVWF  xF4
8336:  MOVLW  01
8338:  MOVWF  xF6
833A:  MOVLW  62
833C:  MOVWF  xF5
833E:  MOVLB  0
8340:  CALL   5F7E
8344:  CLRF   19
8346:  BTFSC  FF2.7
8348:  BSF    19.7
834A:  BCF    FF2.7
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
834C:  MOVLB  9
834E:  CLRF   x07
8350:  CLRF   x06
8352:  CLRF   x05
8354:  CLRF   x04
8356:  CLRF   x0B
8358:  CLRF   x0A
835A:  CLRF   x09
835C:  MOVLW  14
835E:  MOVWF  x08
8360:  CLRF   x0D
8362:  MOVLW  55
8364:  MOVWF  x0C
8366:  MOVLB  0
8368:  CALL   3FF6
836C:  BTFSC  19.7
836E:  BSF    FF2.7
....................          if(!stringcomp(buffer_uart,password)) 
8370:  MOVLW  01
8372:  MOVLB  7
8374:  MOVWF  xF4
8376:  MOVLW  62
8378:  MOVWF  xF3
837A:  CLRF   xF6
837C:  MOVLW  55
837E:  MOVWF  xF5
8380:  MOVLB  0
8382:  CALL   60B6
8386:  MOVF   01,F
8388:  BNZ   83AC
....................          { 
....................             mode=LOGON; 
838A:  MOVLW  01
838C:  MOVLB  6
838E:  MOVWF  xDC
....................             fprintf(COM2," OK\n\r"); 
8390:  MOVLW  04
8392:  MOVWF  FF6
8394:  MOVLW  5D
8396:  MOVWF  FF7
8398:  CLRF   19
839A:  BTFSC  FF2.7
839C:  BSF    19.7
839E:  BCF    FF2.7
83A0:  MOVLB  0
83A2:  CALL   172E
83A6:  BTFSC  19.7
83A8:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
83AA:  BRA    83C4
83AC:  MOVLW  0A
83AE:  MOVWF  FF6
83B0:  MOVLW  5D
83B2:  MOVWF  FF7
83B4:  CLRF   19
83B6:  BTFSC  FF2.7
83B8:  BSF    19.7
83BA:  BCF    FF2.7
83BC:  CALL   172E
83C0:  BTFSC  19.7
83C2:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
83C4:  BRA    83D2
83C6:  MOVLB  6
83C8:  DECFSZ xDC,W
83CA:  BRA    83D4
83CC:  MOVLB  0
83CE:  GOTO   6BA2
83D2:  MOVLB  6
....................    } 
83D4:  BRA    830E
.................... } 
83D6:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

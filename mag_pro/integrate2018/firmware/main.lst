CCS PCH C Compiler, Version 4.140, 33034               21-Jul-18 15:22

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   33534 bytes (51%)
                           Largest free fragment is 31990
               RAM used:   1987 (53%) at main() level
                           2154 (57%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   7A48
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   4302
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1BF0
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
066E:  MOVLW  02
0670:  MOVLB  8
0672:  SUBWF  x2D,F
0674:  BNC   068E
0676:  MOVLW  08
0678:  MOVWF  FEA
067A:  MOVLW  2D
067C:  MOVWF  FE9
067E:  MOVF   FEF,W
0680:  BZ    068E
0682:  BRA    068A
0684:  BRA    0686
0686:  BRA    0688
0688:  NOP   
068A:  DECFSZ FEF,F
068C:  BRA    0684
068E:  MOVLB  0
0690:  GOTO   1C00 (RETURN)
*
18BE:  MOVLW  08
18C0:  MOVWF  FEA
18C2:  MOVLW  35
18C4:  MOVWF  FE9
18C6:  MOVF   FEF,W
18C8:  BZ    18E4
18CA:  MOVLW  0A
18CC:  MOVWF  01
18CE:  CLRF   00
18D0:  DECFSZ 00,F
18D2:  BRA    18D0
18D4:  DECFSZ 01,F
18D6:  BRA    18CE
18D8:  MOVLW  5F
18DA:  MOVWF  00
18DC:  DECFSZ 00,F
18DE:  BRA    18DC
18E0:  DECFSZ FEF,F
18E2:  BRA    18CA
18E4:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
0694:  BCF    F94.0
0696:  BCF    F8B.0
0698:  MOVLW  08
069A:  MOVWF  01
069C:  BRA    069E
069E:  NOP   
06A0:  BSF    01.7
06A2:  BRA    06C4
06A4:  BCF    01.7
06A6:  MOVLB  8
06A8:  RRCF   x58,F
06AA:  MOVLB  0
06AC:  BTFSC  FD8.0
06AE:  BSF    F8B.0
06B0:  BTFSS  FD8.0
06B2:  BCF    F8B.0
06B4:  BSF    01.6
06B6:  BRA    06C4
06B8:  BCF    01.6
06BA:  DECFSZ 01,F
06BC:  BRA    06A6
06BE:  BRA    06C0
06C0:  NOP   
06C2:  BSF    F8B.0
06C4:  MOVLW  10
06C6:  MOVWF  FE9
06C8:  DECFSZ FE9,F
06CA:  BRA    06C8
06CC:  BRA    06CE
06CE:  NOP   
06D0:  BTFSC  01.7
06D2:  BRA    06A4
06D4:  BTFSC  01.6
06D6:  BRA    06B8
06D8:  RETURN 0
*
5B1E:  BSF    F94.1
5B20:  BTFSC  F82.1
5B22:  BRA    5B20
5B24:  MOVLW  08
5B26:  MOVWF  00
5B28:  MOVLB  8
5B2A:  CLRF   x00
5B2C:  BSF    00.7
5B2E:  BRA    5B50
5B30:  BCF    00.7
5B32:  BRA    5B50
5B34:  MOVFF  800,02
5B38:  BCF    FD8.0
5B3A:  BTFSC  F82.1
5B3C:  BSF    FD8.0
5B3E:  RRCF   02,F
5B40:  BSF    00.6
5B42:  BRA    5B50
5B44:  BCF    00.6
5B46:  DECFSZ 00,F
5B48:  BRA    5B38
5B4A:  MOVFF  02,01
5B4E:  BRA    5B68
5B50:  MOVLW  10
5B52:  BTFSC  00.7
5B54:  MOVLW  04
5B56:  MOVWF  01
5B58:  DECFSZ 01,F
5B5A:  BRA    5B58
5B5C:  BRA    5B5E
5B5E:  BTFSC  00.7
5B60:  BRA    5B30
5B62:  BTFSC  00.6
5B64:  BRA    5B44
5B66:  BRA    5B38
5B68:  MOVLB  0
5B6A:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
346E:  MOVLW  08
3470:  MOVWF  01
3472:  MOVLW  0A
3474:  MOVWF  00
3476:  DECFSZ 00,F
3478:  BRA    3476
347A:  BCF    F8B.3
347C:  BCF    F94.3
347E:  MOVLW  0B
3480:  MOVWF  00
3482:  DECFSZ 00,F
3484:  BRA    3482
3486:  MOVLB  8
3488:  RLCF   x4C,F
348A:  BCF    F8B.4
348C:  BTFSC  FD8.0
348E:  BSF    F94.4
3490:  BTFSS  FD8.0
3492:  BCF    F94.4
3494:  BSF    F94.3
3496:  BTFSS  F82.3
3498:  BRA    3496
349A:  DECFSZ 01,F
349C:  BRA    34A0
349E:  BRA    34A4
34A0:  MOVLB  0
34A2:  BRA    3472
34A4:  MOVLW  0A
34A6:  MOVWF  00
34A8:  DECFSZ 00,F
34AA:  BRA    34A8
34AC:  BCF    F8B.3
34AE:  BCF    F94.3
34B0:  NOP   
34B2:  BSF    F94.4
34B4:  MOVLW  0B
34B6:  MOVWF  00
34B8:  DECFSZ 00,F
34BA:  BRA    34B8
34BC:  MOVLW  0B
34BE:  MOVWF  00
34C0:  DECFSZ 00,F
34C2:  BRA    34C0
34C4:  BSF    F94.3
34C6:  BTFSS  F82.3
34C8:  BRA    34C6
34CA:  CLRF   01
34CC:  MOVLW  0B
34CE:  MOVWF  00
34D0:  DECFSZ 00,F
34D2:  BRA    34D0
34D4:  BTFSC  F82.4
34D6:  BSF    01.0
34D8:  BCF    F8B.3
34DA:  BCF    F94.3
34DC:  BCF    F8B.4
34DE:  BCF    F94.4
34E0:  MOVLB  0
34E2:  RETURN 0
34E4:  MOVLW  08
34E6:  MOVLB  8
34E8:  MOVWF  x3F
34EA:  MOVFF  00,840
34EE:  BSF    F94.4
34F0:  MOVLW  0B
34F2:  MOVWF  00
34F4:  DECFSZ 00,F
34F6:  BRA    34F4
34F8:  BSF    F94.3
34FA:  BTFSS  F82.3
34FC:  BRA    34FA
34FE:  BTFSC  F82.4
3500:  BSF    FD8.0
3502:  BTFSS  F82.4
3504:  BCF    FD8.0
3506:  RLCF   01,F
3508:  MOVLW  0A
350A:  MOVWF  00
350C:  DECFSZ 00,F
350E:  BRA    350C
3510:  BCF    F94.3
3512:  BCF    F8B.3
3514:  DECFSZ x3F,F
3516:  BRA    34EE
3518:  BSF    F94.4
351A:  MOVLW  0B
351C:  MOVWF  00
351E:  DECFSZ 00,F
3520:  BRA    351E
3522:  BCF    F8B.4
3524:  MOVF   x40,W
3526:  BTFSS  FD8.2
3528:  BCF    F94.4
352A:  NOP   
352C:  BSF    F94.3
352E:  BTFSS  F82.3
3530:  BRA    352E
3532:  MOVLW  0A
3534:  MOVWF  00
3536:  DECFSZ 00,F
3538:  BRA    3536
353A:  BCF    F8B.3
353C:  BCF    F94.3
353E:  MOVLW  0B
3540:  MOVWF  00
3542:  DECFSZ 00,F
3544:  BRA    3542
3546:  BCF    F8B.4
3548:  BCF    F94.4
354A:  MOVLB  0
354C:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE_key    131071 
.................... #define EEPROM_SIZE        115470 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
4628:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
462A:  BSF    F94.4
....................    port_b_pullups(0xff); 
462C:  BCF    FF1.7
.................... } 
462E:  GOTO   7C04 (RETURN)
.................... /* 
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
....................    if(address<0xffff)i2c_write(0xa0); 
....................       else if(address>=0xffff) i2c_write(0xa2); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
....................    i2c_start(); 
....................    status=i2c_write(0xa0); 
....................    while(status==1) 
....................    { 
....................       i2c_start(); 
....................       status=i2c_write(0xa0); 
....................    } 
....................    i2c_stop(); 
.................... } 
.................... */ 
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3A9E:  MOVLB  8
3AA0:  MOVF   x43,F
3AA2:  BNZ   3AAA
3AA4:  MOVF   x42,W
3AA6:  SUBLW  00
3AA8:  BC    3AB0
3AAA:  MOVLW  A8
3AAC:  MOVWF  x46
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3AAE:  BRA    3AB4
3AB0:  MOVLW  A0
3AB2:  MOVWF  x46
....................  
....................    i2c_start(); 
3AB4:  BSF    F94.4
3AB6:  MOVLW  0A
3AB8:  MOVWF  00
3ABA:  DECFSZ 00,F
3ABC:  BRA    3ABA
3ABE:  BSF    F94.3
3AC0:  MOVLW  0B
3AC2:  MOVWF  00
3AC4:  DECFSZ 00,F
3AC6:  BRA    3AC4
3AC8:  BCF    F8B.4
3ACA:  BCF    F94.4
3ACC:  MOVLW  0A
3ACE:  MOVWF  00
3AD0:  DECFSZ 00,F
3AD2:  BRA    3AD0
3AD4:  BCF    F8B.3
3AD6:  BCF    F94.3
....................    i2c_write(command); 
3AD8:  MOVFF  846,84C
3ADC:  MOVLB  0
3ADE:  RCALL  346E
....................    i2c_write(address>>8); 
3AE0:  MOVFF  841,848
3AE4:  MOVFF  842,849
3AE8:  MOVFF  843,84A
3AEC:  MOVLB  8
3AEE:  CLRF   x4B
3AF0:  MOVFF  841,84C
3AF4:  MOVLB  0
3AF6:  RCALL  346E
....................    i2c_write(address); 
3AF8:  MOVFF  840,84C
3AFC:  RCALL  346E
....................    i2c_write(data); 
3AFE:  MOVFF  844,84C
3B02:  RCALL  346E
....................  
....................    i2c_stop(); 
3B04:  BCF    F94.4
3B06:  NOP   
3B08:  BSF    F94.3
3B0A:  BTFSS  F82.3
3B0C:  BRA    3B0A
3B0E:  MOVLW  0A
3B10:  MOVWF  00
3B12:  DECFSZ 00,F
3B14:  BRA    3B12
3B16:  BRA    3B18
3B18:  NOP   
3B1A:  BSF    F94.4
3B1C:  MOVLW  0A
3B1E:  MOVWF  00
3B20:  DECFSZ 00,F
3B22:  BRA    3B20
....................    i2c_start(); 
3B24:  BSF    F94.4
3B26:  MOVLW  0A
3B28:  MOVWF  00
3B2A:  DECFSZ 00,F
3B2C:  BRA    3B2A
3B2E:  BSF    F94.3
3B30:  MOVLW  0B
3B32:  MOVWF  00
3B34:  DECFSZ 00,F
3B36:  BRA    3B34
3B38:  BCF    F8B.4
3B3A:  BCF    F94.4
3B3C:  MOVLW  0A
3B3E:  MOVWF  00
3B40:  DECFSZ 00,F
3B42:  BRA    3B40
3B44:  BCF    F8B.3
3B46:  BCF    F94.3
....................    status=i2c_write(command); 
3B48:  MOVFF  846,84C
3B4C:  RCALL  346E
3B4E:  MOVF   01,W
3B50:  MOVLB  8
3B52:  BCF    x45.0
3B54:  BTFSC  01.0
3B56:  BSF    x45.0
....................    while(status==1) 
....................    { 
3B58:  BTFSS  x45.0
3B5A:  BRA    3B98
....................       i2c_start(); 
3B5C:  BSF    F94.4
3B5E:  MOVLW  0A
3B60:  MOVWF  00
3B62:  DECFSZ 00,F
3B64:  BRA    3B62
3B66:  BSF    F94.3
3B68:  MOVLW  0B
3B6A:  MOVWF  00
3B6C:  DECFSZ 00,F
3B6E:  BRA    3B6C
3B70:  BTFSS  F82.3
3B72:  BRA    3B70
3B74:  BCF    F8B.4
3B76:  BCF    F94.4
3B78:  MOVLW  0A
3B7A:  MOVWF  00
3B7C:  DECFSZ 00,F
3B7E:  BRA    3B7C
3B80:  BCF    F8B.3
3B82:  BCF    F94.3
....................       status=i2c_write(command); 
3B84:  MOVFF  846,84C
3B88:  MOVLB  0
3B8A:  RCALL  346E
3B8C:  MOVF   01,W
3B8E:  MOVLB  8
3B90:  BCF    x45.0
3B92:  BTFSC  01.0
3B94:  BSF    x45.0
....................    } 
3B96:  BRA    3B58
....................    //delay_us(100); 
.................... } 
3B98:  MOVLB  0
3B9A:  RETURN 0
....................  
.................... /* 
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(0xa1); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    return(data); 
.................... } 
.................... */ 
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
354E:  MOVLB  8
3550:  MOVF   x3B,F
3552:  BNZ   355A
3554:  MOVF   x3A,W
3556:  SUBLW  00
3558:  BC    3560
355A:  MOVLW  A8
355C:  MOVWF  x3D
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
355E:  BRA    3564
3560:  MOVLW  A0
3562:  MOVWF  x3D
....................  
....................    i2c_start(); 
3564:  BSF    F94.4
3566:  MOVLW  0A
3568:  MOVWF  00
356A:  DECFSZ 00,F
356C:  BRA    356A
356E:  BSF    F94.3
3570:  MOVLW  0B
3572:  MOVWF  00
3574:  DECFSZ 00,F
3576:  BRA    3574
3578:  BTFSS  F82.3
357A:  BRA    3578
357C:  BCF    F8B.4
357E:  BCF    F94.4
3580:  MOVLW  0A
3582:  MOVWF  00
3584:  DECFSZ 00,F
3586:  BRA    3584
3588:  BCF    F8B.3
358A:  BCF    F94.3
....................    i2c_write(command); 
358C:  MOVFF  83D,84C
3590:  MOVLB  0
3592:  RCALL  346E
....................    i2c_write(address>>8); 
3594:  MOVFF  839,83F
3598:  MOVFF  83A,840
359C:  MOVFF  83B,841
35A0:  MOVLB  8
35A2:  CLRF   x42
35A4:  MOVFF  839,84C
35A8:  MOVLB  0
35AA:  RCALL  346E
....................    i2c_write(address); 
35AC:  MOVFF  838,84C
35B0:  RCALL  346E
....................    i2c_start(); 
35B2:  BSF    F94.4
35B4:  MOVLW  0A
35B6:  MOVWF  00
35B8:  DECFSZ 00,F
35BA:  BRA    35B8
35BC:  BSF    F94.3
35BE:  MOVLW  0B
35C0:  MOVWF  00
35C2:  DECFSZ 00,F
35C4:  BRA    35C2
35C6:  BTFSS  F82.3
35C8:  BRA    35C6
35CA:  BCF    F8B.4
35CC:  BCF    F94.4
35CE:  MOVLW  0A
35D0:  MOVWF  00
35D2:  DECFSZ 00,F
35D4:  BRA    35D2
35D6:  BCF    F8B.3
35D8:  BCF    F94.3
....................    i2c_write(command+1); 
35DA:  MOVLW  01
35DC:  MOVLB  8
35DE:  ADDWF  x3D,W
35E0:  MOVWF  x3E
35E2:  MOVWF  x4C
35E4:  MOVLB  0
35E6:  RCALL  346E
....................    data=i2c_read(0); 
35E8:  CLRF   00
35EA:  RCALL  34E4
35EC:  MOVFF  01,83C
....................    i2c_stop(); 
35F0:  BCF    F94.4
35F2:  NOP   
35F4:  BSF    F94.3
35F6:  BTFSS  F82.3
35F8:  BRA    35F6
35FA:  MOVLW  0A
35FC:  MOVWF  00
35FE:  DECFSZ 00,F
3600:  BRA    35FE
3602:  BRA    3604
3604:  NOP   
3606:  BSF    F94.4
3608:  MOVLW  0A
360A:  MOVWF  00
360C:  DECFSZ 00,F
360E:  BRA    360C
....................    return(data); 
3610:  MOVLB  8
3612:  MOVFF  83C,01
.................... } 
3616:  MOVLB  0
3618:  RETURN 0
....................  
....................  
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
5D3C:  MOVLB  7
5D3E:  MOVF   xFB,W
5D40:  ADDWF  xF9,W
5D42:  MOVLB  7
5D44:  MOVF   xFC,W
5D46:  ADDWFC xFA,W
5D48:  MOVLB  8
5D4A:  MOVWF  x02
....................    for(i=0;i<len;i++) 
5D4C:  CLRF   x00
5D4E:  MOVLB  7
5D50:  CLRF   xFF
5D52:  MOVLB  8
5D54:  MOVF   x00,W
5D56:  MOVLB  7
5D58:  SUBWF  xFC,W
5D5A:  BNC   5DC4
5D5C:  BNZ   5D64
5D5E:  MOVF   xFB,W
5D60:  SUBWF  xFF,W
5D62:  BC    5DC4
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
5D64:  MOVF   xFD,W
5D66:  ADDWF  xFF,W
5D68:  MOVWF  01
5D6A:  MOVF   xFE,W
5D6C:  MOVLB  8
5D6E:  ADDWFC x00,W
5D70:  MOVWF  03
5D72:  MOVFF  01,801
5D76:  MOVWF  x02
5D78:  MOVLB  7
5D7A:  MOVF   xFF,W
5D7C:  ADDWF  xF9,W
5D7E:  MOVLB  8
5D80:  MOVWF  x03
5D82:  MOVF   x00,W
5D84:  MOVLB  7
5D86:  ADDWFC xFA,W
5D88:  MOVLB  8
5D8A:  MOVWF  x04
5D8C:  CLRF   19
5D8E:  BTFSC  FF2.7
5D90:  BSF    19.7
5D92:  BCF    FF2.7
5D94:  CLRF   x3B
5D96:  CLRF   x3A
5D98:  MOVWF  x39
5D9A:  MOVFF  803,838
5D9E:  MOVLB  0
5DA0:  CALL   354E
5DA4:  BTFSC  19.7
5DA6:  BSF    FF2.7
5DA8:  MOVFF  802,FEA
5DAC:  MOVFF  801,FE9
5DB0:  MOVFF  01,FEF
....................    } 
5DB4:  MOVLB  7
5DB6:  INCF   xFF,F
5DB8:  BTFSS  FD8.2
5DBA:  BRA    5DC2
5DBC:  MOVLB  8
5DBE:  INCF   x00,F
5DC0:  MOVLB  7
5DC2:  BRA    5D52
....................     
.................... } 
5DC4:  MOVLB  0
5DC6:  GOTO   65C4 (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_mobile_num0        65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_two_number        149 
.................... #define kindofKB                 126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards               930   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
3694:  MOVLB  8
3696:  CLRF   x41
3698:  MOVF   x3E,W
369A:  SUBWF  x41,W
369C:  BC    36B2
....................    { 
....................       inputdat[i]=0; 
369E:  CLRF   03
36A0:  MOVF   x41,W
36A2:  ADDWF  x3F,W
36A4:  MOVWF  FE9
36A6:  MOVF   x40,W
36A8:  ADDWFC 03,W
36AA:  MOVWF  FEA
36AC:  CLRF   FEF
....................    } 
36AE:  INCF   x41,F
36B0:  BRA    3698
.................... } 
36B2:  MOVLB  0
36B4:  RETURN 0
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
46FA:  MOVLB  8
46FC:  CLRF   x19
46FE:  CLRF   x18
4700:  CLRF   x17
4702:  CLRF   x16
4704:  MOVF   x19,W
4706:  SUBWF  x13,W
4708:  BNC   478E
470A:  BNZ   4722
470C:  MOVF   x18,W
470E:  SUBWF  x12,W
4710:  BNC   478E
4712:  BNZ   4722
4714:  MOVF   x17,W
4716:  SUBWF  x11,W
4718:  BNC   478E
471A:  BNZ   4722
471C:  MOVF   x10,W
471E:  SUBWF  x16,W
4720:  BC    478E
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4722:  MOVF   x16,W
4724:  ADDWF  x0C,W
4726:  MOVWF  x1A
4728:  MOVF   x17,W
472A:  ADDWFC x0D,W
472C:  MOVWF  x1B
472E:  MOVF   x18,W
4730:  ADDWFC x0E,W
4732:  MOVWF  x1C
4734:  MOVF   x19,W
4736:  ADDWFC x0F,W
4738:  MOVWF  x1D
473A:  MOVF   x14,W
473C:  ADDWF  x16,W
473E:  MOVWF  FE9
4740:  MOVF   x15,W
4742:  ADDWFC x17,W
4744:  MOVWF  FEA
4746:  MOVFF  FEF,81E
474A:  CLRF   19
474C:  BTFSC  FF2.7
474E:  BSF    19.7
4750:  BCF    FF2.7
4752:  MOVFF  81D,843
4756:  MOVFF  81C,842
475A:  MOVFF  81B,841
475E:  MOVFF  81A,840
4762:  MOVFF  81E,844
4766:  MOVLB  0
4768:  CALL   3A9E
476C:  BTFSC  19.7
476E:  BSF    FF2.7
....................       delay_us(10); 
4770:  MOVLW  1A
4772:  MOVWF  00
4774:  DECFSZ 00,F
4776:  BRA    4774
4778:  NOP   
....................    } 
477A:  MOVLW  01
477C:  MOVLB  8
477E:  ADDWF  x16,F
4780:  BTFSC  FD8.0
4782:  INCF   x17,F
4784:  BTFSC  FD8.2
4786:  INCF   x18,F
4788:  BTFSC  FD8.2
478A:  INCF   x19,F
478C:  BRA    4704
....................    return 1; 
478E:  MOVLW  01
4790:  MOVWF  01
.................... } 
4792:  MOVLB  0
4794:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4632:  MOVLB  8
4634:  CLRF   x04
4636:  CLRF   x03
4638:  CLRF   x02
463A:  CLRF   x01
463C:  MOVF   x04,W
463E:  MOVLB  7
4640:  SUBWF  xFE,W
4642:  BNC   46F6
4644:  BNZ   466E
4646:  MOVLB  8
4648:  MOVF   x03,W
464A:  MOVLB  7
464C:  SUBWF  xFD,W
464E:  BNC   46F6
4650:  BNZ   466E
4652:  MOVLB  8
4654:  MOVF   x02,W
4656:  MOVLB  7
4658:  SUBWF  xFC,W
465A:  BNC   46F6
465C:  BNZ   466E
465E:  MOVF   xFB,W
4660:  MOVLB  8
4662:  SUBWF  x01,W
4664:  BTFSS  FD8.0
4666:  BRA    466C
4668:  MOVLB  7
466A:  BRA    46F6
466C:  MOVLB  7
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
466E:  MOVF   xFF,W
4670:  MOVLB  8
4672:  ADDWF  x01,W
4674:  MOVWF  01
4676:  MOVF   x00,W
4678:  ADDWFC x02,W
467A:  MOVWF  03
467C:  MOVFF  01,805
4680:  MOVWF  x06
4682:  MOVF   x01,W
4684:  MOVLB  7
4686:  ADDWF  xF7,W
4688:  MOVLB  8
468A:  MOVWF  x07
468C:  MOVF   x02,W
468E:  MOVLB  7
4690:  ADDWFC xF8,W
4692:  MOVLB  8
4694:  MOVWF  x08
4696:  MOVF   x03,W
4698:  MOVLB  7
469A:  ADDWFC xF9,W
469C:  MOVLB  8
469E:  MOVWF  x09
46A0:  MOVF   x04,W
46A2:  MOVLB  7
46A4:  ADDWFC xFA,W
46A6:  MOVLB  8
46A8:  MOVWF  x0A
46AA:  CLRF   19
46AC:  BTFSC  FF2.7
46AE:  BSF    19.7
46B0:  BCF    FF2.7
46B2:  MOVWF  x3B
46B4:  MOVFF  809,83A
46B8:  MOVFF  808,839
46BC:  MOVFF  807,838
46C0:  MOVLB  0
46C2:  CALL   354E
46C6:  BTFSC  19.7
46C8:  BSF    FF2.7
46CA:  MOVFF  806,FEA
46CE:  MOVFF  805,FE9
46D2:  MOVFF  01,FEF
....................       delay_us(10); 
46D6:  MOVLW  1A
46D8:  MOVWF  00
46DA:  DECFSZ 00,F
46DC:  BRA    46DA
46DE:  NOP   
....................    } 
46E0:  MOVLW  01
46E2:  MOVLB  8
46E4:  ADDWF  x01,F
46E6:  BTFSC  FD8.0
46E8:  INCF   x02,F
46EA:  BTFSC  FD8.2
46EC:  INCF   x03,F
46EE:  BTFSC  FD8.2
46F0:  INCF   x04,F
46F2:  BRA    463C
46F4:  MOVLB  7
.................... } 
46F6:  MOVLB  0
46F8:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
4A08:  MOVLB  7
4A0A:  CLRF   xC5
4A0C:  CLRF   xC4
4A0E:  CLRF   xC3
4A10:  CLRF   xC2
4A12:  CLRF   xC9
4A14:  CLRF   xC8
4A16:  CLRF   xC7
4A18:  CLRF   xC6
4A1A:  CLRF   xCD
4A1C:  CLRF   xCC
4A1E:  CLRF   xCB
4A20:  CLRF   xCA
4A22:  CLRF   xD1
4A24:  CLRF   xD0
4A26:  CLRF   xCF
4A28:  CLRF   xCE
4A2A:  CLRF   xD5
4A2C:  CLRF   xD4
4A2E:  CLRF   xD3
4A30:  CLRF   xD2
4A32:  CLRF   19
4A34:  BTFSC  FF2.7
4A36:  BSF    19.7
4A38:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
4A3A:  MOVLB  8
4A3C:  CLRF   x3B
4A3E:  CLRF   x3A
4A40:  CLRF   x39
4A42:  MOVFF  7C1,838
4A46:  MOVLB  0
4A48:  CALL   354E
4A4C:  BTFSC  19.7
4A4E:  BSF    FF2.7
4A50:  MOVLB  7
4A52:  MOVFF  01,7C6
4A56:  CLRF   xC7
4A58:  CLRF   xC8
4A5A:  CLRF   xC9
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
4A5C:  MOVLW  01
4A5E:  ADDWF  xC1,W
4A60:  MOVWF  xD6
4A62:  CLRF   19
4A64:  BTFSC  FF2.7
4A66:  BSF    19.7
4A68:  BCF    FF2.7
4A6A:  MOVLB  8
4A6C:  CLRF   x3B
4A6E:  CLRF   x3A
4A70:  CLRF   x39
4A72:  MOVWF  x38
4A74:  MOVLB  0
4A76:  CALL   354E
4A7A:  BTFSC  19.7
4A7C:  BSF    FF2.7
4A7E:  MOVLB  7
4A80:  CLRF   xCD
4A82:  CLRF   xCC
4A84:  CLRF   xCB
4A86:  MOVFF  01,7CA
....................    temp2<<=8; 
4A8A:  MOVFF  7CC,7CD
4A8E:  MOVFF  7CB,7CC
4A92:  MOVFF  7CA,7CB
4A96:  CLRF   xCA
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
4A98:  MOVLW  02
4A9A:  ADDWF  xC1,W
4A9C:  MOVWF  xD6
4A9E:  CLRF   19
4AA0:  BTFSC  FF2.7
4AA2:  BSF    19.7
4AA4:  BCF    FF2.7
4AA6:  MOVLB  8
4AA8:  CLRF   x3B
4AAA:  CLRF   x3A
4AAC:  CLRF   x39
4AAE:  MOVWF  x38
4AB0:  MOVLB  0
4AB2:  CALL   354E
4AB6:  BTFSC  19.7
4AB8:  BSF    FF2.7
4ABA:  MOVLB  7
4ABC:  CLRF   xD1
4ABE:  CLRF   xD0
4AC0:  CLRF   xCF
4AC2:  MOVFF  01,7CE
....................    temp3<<=16; 
4AC6:  MOVFF  7CF,7D1
4ACA:  MOVFF  7CE,7D0
4ACE:  CLRF   xCE
4AD0:  CLRF   xCF
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
4AD2:  MOVLW  03
4AD4:  ADDWF  xC1,W
4AD6:  MOVWF  xD6
4AD8:  CLRF   19
4ADA:  BTFSC  FF2.7
4ADC:  BSF    19.7
4ADE:  BCF    FF2.7
4AE0:  MOVLB  8
4AE2:  CLRF   x3B
4AE4:  CLRF   x3A
4AE6:  CLRF   x39
4AE8:  MOVWF  x38
4AEA:  MOVLB  0
4AEC:  CALL   354E
4AF0:  BTFSC  19.7
4AF2:  BSF    FF2.7
4AF4:  MOVLB  7
4AF6:  CLRF   xD5
4AF8:  CLRF   xD4
4AFA:  CLRF   xD3
4AFC:  MOVFF  01,7D2
....................    temp4<<=24; 
4B00:  MOVFF  7D2,7D5
4B04:  CLRF   xD2
4B06:  CLRF   xD3
4B08:  CLRF   xD4
....................    buffer = temp4|temp3|temp2|temp1; 
4B0A:  MOVF   xD2,W
4B0C:  IORWF  xCE,W
4B0E:  MOVWF  xD6
4B10:  MOVF   xD3,W
4B12:  IORWF  xCF,W
4B14:  MOVWF  xD7
4B16:  MOVF   xD4,W
4B18:  IORWF  xD0,W
4B1A:  MOVWF  xD8
4B1C:  MOVF   xD5,W
4B1E:  IORWF  xD1,W
4B20:  MOVWF  xD9
4B22:  MOVF   xCA,W
4B24:  IORWF  xD6,F
4B26:  MOVF   xCB,W
4B28:  IORWF  xD7,F
4B2A:  MOVF   xCC,W
4B2C:  IORWF  xD8,F
4B2E:  MOVF   xCD,W
4B30:  IORWF  xD9,F
4B32:  MOVF   xD6,W
4B34:  IORWF  xC6,W
4B36:  MOVWF  xC2
4B38:  MOVF   xD7,W
4B3A:  IORWF  xC7,W
4B3C:  MOVWF  xC3
4B3E:  MOVF   xD8,W
4B40:  IORWF  xC8,W
4B42:  MOVWF  xC4
4B44:  MOVF   xD9,W
4B46:  IORWF  xC9,W
4B48:  MOVWF  xC5
....................    return(buffer); 
4B4A:  MOVFF  7C2,00
4B4E:  MOVFF  7C3,01
4B52:  MOVFF  7C4,02
4B56:  MOVFF  7C5,03
.................... } 
4B5A:  MOVLB  0
4B5C:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3B9C:  MOVLB  8
3B9E:  CLRF   x3A
3BA0:  CLRF   x39
3BA2:  CLRF   x38
3BA4:  CLRF   x37
3BA6:  CLRF   x3B
3BA8:  CLRF   x3C
3BAA:  CLRF   x3D
3BAC:  CLRF   x3E
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3BAE:  MOVFF  835,83A
3BB2:  MOVFF  834,839
3BB6:  MOVFF  833,838
3BBA:  MOVFF  832,837
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3BBE:  MOVFF  837,83B
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3BC2:  MOVFF  838,83C
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3BC6:  MOVFF  839,83D
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3BCA:  MOVFF  83A,83E
....................    write_ext_eeprom((addr+0),temp1); 
3BCE:  CLRF   x43
3BD0:  CLRF   x42
3BD2:  CLRF   x41
3BD4:  MOVFF  836,840
3BD8:  MOVFF  83B,844
3BDC:  MOVLB  0
3BDE:  RCALL  3A9E
....................    write_ext_eeprom((addr+1),temp2); 
3BE0:  MOVLW  01
3BE2:  MOVLB  8
3BE4:  ADDWF  x36,W
3BE6:  MOVWF  x3F
3BE8:  CLRF   x43
3BEA:  CLRF   x42
3BEC:  CLRF   x41
3BEE:  MOVWF  x40
3BF0:  MOVFF  83C,844
3BF4:  MOVLB  0
3BF6:  RCALL  3A9E
....................    write_ext_eeprom((addr+2),temp3); 
3BF8:  MOVLW  02
3BFA:  MOVLB  8
3BFC:  ADDWF  x36,W
3BFE:  MOVWF  x3F
3C00:  CLRF   x43
3C02:  CLRF   x42
3C04:  CLRF   x41
3C06:  MOVWF  x40
3C08:  MOVFF  83D,844
3C0C:  MOVLB  0
3C0E:  RCALL  3A9E
....................    write_ext_eeprom((addr+3),temp4); 
3C10:  MOVLW  03
3C12:  MOVLB  8
3C14:  ADDWF  x36,W
3C16:  MOVWF  x3F
3C18:  CLRF   x43
3C1A:  CLRF   x42
3C1C:  CLRF   x41
3C1E:  MOVWF  x40
3C20:  MOVFF  83E,844
3C24:  MOVLB  0
3C26:  RCALL  3A9E
.................... } 
3C28:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
41CA:  MOVLB  8
41CC:  CLRF   x32
41CE:  CLRF   x31
41D0:  CLRF   x33
41D2:  CLRF   x34
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
41D4:  MOVFF  830,832
41D8:  MOVFF  82F,831
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
41DC:  MOVFF  831,833
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
41E0:  MOVF   x32,W
41E2:  MOVWF  x34
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
41E4:  CLRF   x43
41E6:  CLRF   x42
41E8:  CLRF   x41
41EA:  MOVLW  28
41EC:  MOVWF  x40
41EE:  MOVFF  833,844
41F2:  MOVLB  0
41F4:  RCALL  3A9E
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
41F6:  MOVLB  8
41F8:  CLRF   x43
41FA:  CLRF   x42
41FC:  CLRF   x41
41FE:  MOVLW  29
4200:  MOVWF  x40
4202:  MOVFF  834,844
4206:  MOVLB  0
4208:  RCALL  3A9E
.................... } 
420A:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
361A:  MOVLB  8
361C:  CLRF   x33
361E:  CLRF   x32
3620:  CLRF   x35
3622:  CLRF   x34
3624:  CLRF   x37
3626:  CLRF   x36
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
3628:  CLRF   x3B
362A:  CLRF   x3A
362C:  CLRF   x39
362E:  MOVLW  28
3630:  MOVWF  x38
3632:  MOVLB  0
3634:  RCALL  354E
3636:  MOVLB  8
3638:  MOVFF  01,834
363C:  CLRF   x35
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
363E:  CLRF   x3B
3640:  CLRF   x3A
3642:  CLRF   x39
3644:  MOVLW  29
3646:  MOVWF  x38
3648:  MOVLB  0
364A:  RCALL  354E
364C:  MOVLB  8
364E:  CLRF   x37
3650:  MOVFF  01,836
....................    temp2<<=8; 
3654:  MOVFF  836,837
3658:  CLRF   x36
....................    buffer = temp2|temp1; 
365A:  MOVF   x36,W
365C:  IORWF  x34,W
365E:  MOVWF  x32
3660:  MOVF   x37,W
3662:  IORWF  x35,W
3664:  MOVWF  x33
....................    return(buffer); 
3666:  MOVFF  832,01
366A:  MOVFF  833,02
.................... } 
366E:  MOVLB  0
3670:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2,"EEPROM_KEY_ST=%lu\n\r",EEPROM_KEY_ST); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
5EE4:  MOVLB  7
5EE6:  CLRF   xFA
5EE8:  MOVLW  01
5EEA:  MOVWF  xF9
5EEC:  MOVLW  C3
5EEE:  MOVWF  xF8
5EF0:  MOVLW  0F
5EF2:  MOVWF  xF7
5EF4:  MOVF   xFA,W
5EF6:  SUBWF  27,W
5EF8:  BNC   5F4C
5EFA:  BNZ   5F12
5EFC:  MOVF   xF9,W
5EFE:  SUBWF  26,W
5F00:  BNC   5F4C
5F02:  BNZ   5F12
5F04:  MOVF   xF8,W
5F06:  SUBWF  25,W
5F08:  BNC   5F4C
5F0A:  BNZ   5F12
5F0C:  MOVF   24,W
5F0E:  SUBWF  xF7,W
5F10:  BC    5F4C
5F12:  CLRF   19
5F14:  BTFSC  FF2.7
5F16:  BSF    19.7
5F18:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5F1A:  MOVFF  7FA,843
5F1E:  MOVFF  7F9,842
5F22:  MOVFF  7F8,841
5F26:  MOVFF  7F7,840
5F2A:  MOVLB  8
5F2C:  CLRF   x44
5F2E:  MOVLB  0
5F30:  CALL   3A9E
5F34:  BTFSC  19.7
5F36:  BSF    FF2.7
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    } 
5F38:  MOVLW  01
5F3A:  MOVLB  7
5F3C:  ADDWF  xF7,F
5F3E:  BTFSC  FD8.0
5F40:  INCF   xF8,F
5F42:  BTFSC  FD8.2
5F44:  INCF   xF9,F
5F46:  BTFSC  FD8.2
5F48:  INCF   xFA,F
5F4A:  BRA    5EF4
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=ptr_start;i<ptr_card;i++) 
5F4C:  CLRF   xFA
5F4E:  CLRF   xF9
5F50:  CLRF   xF8
5F52:  MOVLW  96
5F54:  MOVWF  xF7
5F56:  MOVF   xFA,W
5F58:  SUBWF  23,W
5F5A:  BNC   5FAE
5F5C:  BNZ   5F74
5F5E:  MOVF   xF9,W
5F60:  SUBWF  22,W
5F62:  BNC   5FAE
5F64:  BNZ   5F74
5F66:  MOVF   xF8,W
5F68:  SUBWF  21,W
5F6A:  BNC   5FAE
5F6C:  BNZ   5F74
5F6E:  MOVF   20,W
5F70:  SUBWF  xF7,W
5F72:  BC    5FAE
5F74:  CLRF   19
5F76:  BTFSC  FF2.7
5F78:  BSF    19.7
5F7A:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5F7C:  MOVFF  7FA,843
5F80:  MOVFF  7F9,842
5F84:  MOVFF  7F8,841
5F88:  MOVFF  7F7,840
5F8C:  MOVLB  8
5F8E:  CLRF   x44
5F90:  MOVLB  0
5F92:  CALL   3A9E
5F96:  BTFSC  19.7
5F98:  BSF    FF2.7
....................    } 
5F9A:  MOVLW  01
5F9C:  MOVLB  7
5F9E:  ADDWF  xF7,F
5FA0:  BTFSC  FD8.0
5FA2:  INCF   xF8,F
5FA4:  BTFSC  FD8.2
5FA6:  INCF   xF9,F
5FA8:  BTFSC  FD8.2
5FAA:  INCF   xFA,F
5FAC:  BRA    5F56
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
5FAE:  CLRF   23
5FB0:  CLRF   22
5FB2:  CLRF   21
5FB4:  MOVLW  96
5FB6:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5FB8:  CLRF   27
5FBA:  MOVLW  01
5FBC:  MOVWF  26
5FBE:  MOVLW  C3
5FC0:  MOVWF  25
5FC2:  MOVLW  0F
5FC4:  MOVWF  24
5FC6:  CLRF   19
5FC8:  BTFSC  FF2.7
5FCA:  BSF    19.7
5FCC:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5FCE:  MOVFF  23,835
5FD2:  MOVFF  22,834
5FD6:  MOVFF  21,833
5FDA:  MOVFF  20,832
5FDE:  MOVLW  19
5FE0:  MOVLB  8
5FE2:  MOVWF  x36
5FE4:  MOVLB  0
5FE6:  CALL   3B9C
5FEA:  BTFSC  19.7
5FEC:  BSF    FF2.7
5FEE:  CLRF   19
5FF0:  BTFSC  FF2.7
5FF2:  BSF    19.7
5FF4:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5FF6:  MOVFF  27,835
5FFA:  MOVFF  26,834
5FFE:  MOVFF  25,833
6002:  MOVFF  24,832
6006:  MOVLW  1E
6008:  MOVLB  8
600A:  MOVWF  x36
600C:  MOVLB  0
600E:  CALL   3B9C
6012:  BTFSC  19.7
6014:  BSF    FF2.7
6016:  CLRF   19
6018:  BTFSC  FF2.7
601A:  BSF    19.7
601C:  BCF    FF2.7
....................    save_coutcard(0); 
601E:  MOVLB  8
6020:  CLRF   x30
6022:  CLRF   x2F
6024:  MOVLB  0
6026:  CALL   41CA
602A:  BTFSC  19.7
602C:  BSF    FF2.7
602E:  CLRF   19
6030:  BTFSC  FF2.7
6032:  BSF    19.7
6034:  BCF    FF2.7
....................    countcard=get_countcard(); 
6036:  CALL   361A
603A:  BTFSC  19.7
603C:  BSF    FF2.7
603E:  MOVFF  02,FA
6042:  MOVFF  01,F9
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
6046:  GOTO   6936 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    /*for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    ptr_card=ptr_start; 
604A:  CLRF   23
604C:  CLRF   22
604E:  CLRF   21
6050:  MOVLW  96
6052:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
6054:  CLRF   27
6056:  MOVLW  01
6058:  MOVWF  26
605A:  MOVLW  C3
605C:  MOVWF  25
605E:  MOVLW  0F
6060:  MOVWF  24
6062:  CLRF   19
6064:  BTFSC  FF2.7
6066:  BSF    19.7
6068:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
606A:  MOVFF  23,835
606E:  MOVFF  22,834
6072:  MOVFF  21,833
6076:  MOVFF  20,832
607A:  MOVLW  19
607C:  MOVLB  8
607E:  MOVWF  x36
6080:  MOVLB  0
6082:  CALL   3B9C
6086:  BTFSC  19.7
6088:  BSF    FF2.7
608A:  CLRF   19
608C:  BTFSC  FF2.7
608E:  BSF    19.7
6090:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
6092:  MOVFF  27,835
6096:  MOVFF  26,834
609A:  MOVFF  25,833
609E:  MOVFF  24,832
60A2:  MOVLW  1E
60A4:  MOVLB  8
60A6:  MOVWF  x36
60A8:  MOVLB  0
60AA:  CALL   3B9C
60AE:  BTFSC  19.7
60B0:  BSF    FF2.7
60B2:  CLRF   19
60B4:  BTFSC  FF2.7
60B6:  BSF    19.7
60B8:  BCF    FF2.7
....................    save_coutcard(0); 
60BA:  MOVLB  8
60BC:  CLRF   x30
60BE:  CLRF   x2F
60C0:  MOVLB  0
60C2:  CALL   41CA
60C6:  BTFSC  19.7
60C8:  BSF    FF2.7
.................... } 
60CA:  GOTO   699C (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
4796:  MOVLB  7
4798:  CLRF   xFA
479A:  CLRF   xF9
479C:  CLRF   xF8
479E:  CLRF   xF7
47A0:  CLRF   xFE
47A2:  CLRF   xFD
47A4:  CLRF   xFC
47A6:  MOVLW  14
47A8:  MOVWF  xFB
47AA:  MOVLB  8
47AC:  CLRF   x00
47AE:  MOVLW  55
47B0:  MOVLB  7
47B2:  MOVWF  xFF
47B4:  MOVLB  0
47B6:  RCALL  4632
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
47B8:  INCFSZ 55,W
47BA:  BRA    482C
47BC:  INCFSZ 56,W
47BE:  BRA    482C
47C0:  INCFSZ x64,W
47C2:  BRA    482C
....................       { 
....................          memset(buffer1,0,20); 
47C4:  CLRF   FEA
47C6:  MOVLW  2D
47C8:  MOVWF  FE9
47CA:  CLRF   00
47CC:  CLRF   02
47CE:  MOVLW  14
47D0:  MOVWF  01
47D2:  RCALL  4032
....................          strcpy(buffer1,"admin"); 
47D4:  CLRF   FEA
47D6:  MOVLW  2D
47D8:  MOVWF  FE9
47DA:  MOVLW  00
47DC:  CALL   00BA
47E0:  TBLRD*-
47E2:  TBLRD*+
47E4:  MOVF   FF5,W
47E6:  MOVWF  FEE
47E8:  IORLW  00
47EA:  BNZ   47E2
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
47EC:  MOVLB  8
47EE:  CLRF   x0F
47F0:  CLRF   x0E
47F2:  CLRF   x0D
47F4:  CLRF   x0C
47F6:  CLRF   x13
47F8:  CLRF   x12
47FA:  CLRF   x11
47FC:  MOVLW  14
47FE:  MOVWF  x10
4800:  CLRF   x15
4802:  MOVLW  2D
4804:  MOVWF  x14
4806:  MOVLB  0
4808:  RCALL  46FA
....................          EEPROM_read(strobe_pass_addr,20,password); 
480A:  MOVLB  7
480C:  CLRF   xFA
480E:  CLRF   xF9
4810:  CLRF   xF8
4812:  CLRF   xF7
4814:  CLRF   xFE
4816:  CLRF   xFD
4818:  CLRF   xFC
481A:  MOVLW  14
481C:  MOVWF  xFB
481E:  MOVLB  8
4820:  CLRF   x00
4822:  MOVLW  55
4824:  MOVLB  7
4826:  MOVWF  xFF
4828:  MOVLB  0
482A:  RCALL  4632
....................       } 
.................... } 
482C:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
60CE:  MOVLB  8
60D0:  CLRF   x0B
60D2:  MOVF   x0B,W
60D4:  SUBLW  13
60D6:  BNC   60EC
60D8:  CLRF   03
60DA:  MOVF   x0B,W
60DC:  ADDLW  F7
60DE:  MOVWF  FE9
60E0:  MOVLW  07
60E2:  ADDWFC 03,W
60E4:  MOVWF  FEA
60E6:  SETF   FEF
60E8:  INCF   x0B,F
60EA:  BRA    60D2
....................    EEPROM_write(strobe_pass_addr,20,buf); 
60EC:  CLRF   x0F
60EE:  CLRF   x0E
60F0:  CLRF   x0D
60F2:  CLRF   x0C
60F4:  CLRF   x13
60F6:  CLRF   x12
60F8:  CLRF   x11
60FA:  MOVLW  14
60FC:  MOVWF  x10
60FE:  MOVLW  07
6100:  MOVWF  x15
6102:  MOVLW  F7
6104:  MOVWF  x14
6106:  MOVLB  0
6108:  CALL   46FA
.................... } 
610C:  GOTO   6A02 (RETURN)
.................... //============================================ 
.................... void reset_2nd_number() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0; 
....................    EEPROM_write(strobe_mobile_num0,20,buf); 
.................... } 
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
482E:  BSF    F94.4
4830:  MOVLW  0A
4832:  MOVWF  00
4834:  DECFSZ 00,F
4836:  BRA    4834
4838:  BSF    F94.3
483A:  MOVLW  0B
483C:  MOVWF  00
483E:  DECFSZ 00,F
4840:  BRA    483E
4842:  BCF    F8B.4
4844:  BCF    F94.4
4846:  MOVLW  0A
4848:  MOVWF  00
484A:  DECFSZ 00,F
484C:  BRA    484A
484E:  BCF    F8B.3
4850:  BCF    F94.3
4852:  CLRF   19
4854:  BTFSC  FF2.7
4856:  BSF    19.7
4858:  BCF    FF2.7
....................    i2c_write(0xD0); 
485A:  MOVLW  D0
485C:  MOVLB  8
485E:  MOVWF  x4C
4860:  MOVLB  0
4862:  CALL   346E
4866:  BTFSC  19.7
4868:  BSF    FF2.7
486A:  CLRF   19
486C:  BTFSC  FF2.7
486E:  BSF    19.7
4870:  BCF    FF2.7
....................    i2c_write(address); 
4872:  MOVFF  7FB,84C
4876:  CALL   346E
487A:  BTFSC  19.7
487C:  BSF    FF2.7
....................    i2c_start(); 
487E:  BSF    F94.4
4880:  MOVLW  0A
4882:  MOVWF  00
4884:  DECFSZ 00,F
4886:  BRA    4884
4888:  BSF    F94.3
488A:  MOVLW  0B
488C:  MOVWF  00
488E:  DECFSZ 00,F
4890:  BRA    488E
4892:  BTFSS  F82.3
4894:  BRA    4892
4896:  BCF    F8B.4
4898:  BCF    F94.4
489A:  MOVLW  0A
489C:  MOVWF  00
489E:  DECFSZ 00,F
48A0:  BRA    489E
48A2:  BCF    F8B.3
48A4:  BCF    F94.3
48A6:  CLRF   19
48A8:  BTFSC  FF2.7
48AA:  BSF    19.7
48AC:  BCF    FF2.7
....................    i2c_write(0xD1); 
48AE:  MOVLW  D1
48B0:  MOVLB  8
48B2:  MOVWF  x4C
48B4:  MOVLB  0
48B6:  CALL   346E
48BA:  BTFSC  19.7
48BC:  BSF    FF2.7
....................    result = i2c_read(0); 
48BE:  CLRF   00
48C0:  CLRF   19
48C2:  BTFSC  FF2.7
48C4:  BSF    19.7
48C6:  BCF    FF2.7
48C8:  CALL   34E4
48CC:  BTFSC  19.7
48CE:  BSF    FF2.7
48D0:  MOVFF  01,7FC
....................    i2c_stop(); 
48D4:  BCF    F94.4
48D6:  NOP   
48D8:  BSF    F94.3
48DA:  BTFSS  F82.3
48DC:  BRA    48DA
48DE:  MOVLW  0A
48E0:  MOVWF  00
48E2:  DECFSZ 00,F
48E4:  BRA    48E2
48E6:  BRA    48E8
48E8:  NOP   
48EA:  BSF    F94.4
48EC:  MOVLW  0A
48EE:  MOVWF  00
48F0:  DECFSZ 00,F
48F2:  BRA    48F0
....................     
....................    return(result); 
48F4:  MOVLB  7
48F6:  MOVFF  7FC,01
.................... } 
48FA:  MOVLB  0
48FC:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
62C0:  BSF    F94.4
62C2:  MOVLW  0A
62C4:  MOVWF  00
62C6:  DECFSZ 00,F
62C8:  BRA    62C6
62CA:  BSF    F94.3
62CC:  MOVLW  0B
62CE:  MOVWF  00
62D0:  DECFSZ 00,F
62D2:  BRA    62D0
62D4:  BCF    F8B.4
62D6:  BCF    F94.4
62D8:  MOVLW  0A
62DA:  MOVWF  00
62DC:  DECFSZ 00,F
62DE:  BRA    62DC
62E0:  BCF    F8B.3
62E2:  BCF    F94.3
....................    delay_us(10); 
62E4:  MOVLW  1A
62E6:  MOVWF  00
62E8:  DECFSZ 00,F
62EA:  BRA    62E8
62EC:  NOP   
62EE:  CLRF   19
62F0:  BTFSC  FF2.7
62F2:  BSF    19.7
62F4:  BCF    FF2.7
....................    i2c_write(0xD0); 
62F6:  MOVLW  D0
62F8:  MOVLB  8
62FA:  MOVWF  x4C
62FC:  MOVLB  0
62FE:  CALL   346E
6302:  BTFSC  19.7
6304:  BSF    FF2.7
....................    delay_us(10); 
6306:  MOVLW  1A
6308:  MOVWF  00
630A:  DECFSZ 00,F
630C:  BRA    630A
630E:  NOP   
6310:  CLRF   19
6312:  BTFSC  FF2.7
6314:  BSF    19.7
6316:  BCF    FF2.7
....................    i2c_write(address); 
6318:  MOVFF  7FE,84C
631C:  CALL   346E
6320:  BTFSC  19.7
6322:  BSF    FF2.7
....................    delay_us(10); 
6324:  MOVLW  1A
6326:  MOVWF  00
6328:  DECFSZ 00,F
632A:  BRA    6328
632C:  NOP   
632E:  CLRF   19
6330:  BTFSC  FF2.7
6332:  BSF    19.7
6334:  BCF    FF2.7
....................    i2c_write(data); 
6336:  MOVFF  7FF,84C
633A:  CALL   346E
633E:  BTFSC  19.7
6340:  BSF    FF2.7
....................    i2c_stop(); 
6342:  BCF    F94.4
6344:  NOP   
6346:  BSF    F94.3
6348:  BTFSS  F82.3
634A:  BRA    6348
634C:  MOVLW  0A
634E:  MOVWF  00
6350:  DECFSZ 00,F
6352:  BRA    6350
6354:  BRA    6356
6356:  NOP   
6358:  BSF    F94.4
635A:  MOVLW  0A
635C:  MOVWF  00
635E:  DECFSZ 00,F
6360:  BRA    635E
....................    delay_us(10); 
6362:  MOVLW  1A
6364:  MOVWF  00
6366:  DECFSZ 00,F
6368:  BRA    6366
636A:  NOP   
.................... } 
636C:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
*
48FE:  MOVLB  7
4900:  CLRF   xFB
4902:  MOVLB  0
4904:  RCALL  482E
4906:  MOVFF  01,7C1
....................     
....................    data &= 0x7F; 
490A:  MOVLB  7
490C:  BCF    xC1.7
....................     
....................    i2c_start(); 
490E:  BSF    F94.4
4910:  MOVLW  0A
4912:  MOVWF  00
4914:  DECFSZ 00,F
4916:  BRA    4914
4918:  BSF    F94.3
491A:  MOVLW  0B
491C:  MOVWF  00
491E:  DECFSZ 00,F
4920:  BRA    491E
4922:  BCF    F8B.4
4924:  BCF    F94.4
4926:  MOVLW  0A
4928:  MOVWF  00
492A:  DECFSZ 00,F
492C:  BRA    492A
492E:  BCF    F8B.3
4930:  BCF    F94.3
4932:  CLRF   19
4934:  BTFSC  FF2.7
4936:  BSF    19.7
4938:  BCF    FF2.7
....................    i2c_write(0xD0); 
493A:  MOVLW  D0
493C:  MOVLB  8
493E:  MOVWF  x4C
4940:  MOVLB  0
4942:  CALL   346E
4946:  BTFSC  19.7
4948:  BSF    FF2.7
494A:  CLRF   19
494C:  BTFSC  FF2.7
494E:  BSF    19.7
4950:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
4952:  MOVLB  8
4954:  CLRF   x4C
4956:  MOVLB  0
4958:  CALL   346E
495C:  BTFSC  19.7
495E:  BSF    FF2.7
4960:  CLRF   19
4962:  BTFSC  FF2.7
4964:  BSF    19.7
4966:  BCF    FF2.7
....................    i2c_write(data); 
4968:  MOVFF  7C1,84C
496C:  CALL   346E
4970:  BTFSC  19.7
4972:  BSF    FF2.7
....................    i2c_start(); 
4974:  BSF    F94.4
4976:  MOVLW  0A
4978:  MOVWF  00
497A:  DECFSZ 00,F
497C:  BRA    497A
497E:  BSF    F94.3
4980:  MOVLW  0B
4982:  MOVWF  00
4984:  DECFSZ 00,F
4986:  BRA    4984
4988:  BTFSS  F82.3
498A:  BRA    4988
498C:  BCF    F8B.4
498E:  BCF    F94.4
4990:  MOVLW  0A
4992:  MOVWF  00
4994:  DECFSZ 00,F
4996:  BRA    4994
4998:  BCF    F8B.3
499A:  BCF    F94.3
499C:  CLRF   19
499E:  BTFSC  FF2.7
49A0:  BSF    19.7
49A2:  BCF    FF2.7
....................    i2c_write(0xD0); 
49A4:  MOVLW  D0
49A6:  MOVLB  8
49A8:  MOVWF  x4C
49AA:  MOVLB  0
49AC:  CALL   346E
49B0:  BTFSC  19.7
49B2:  BSF    FF2.7
49B4:  CLRF   19
49B6:  BTFSC  FF2.7
49B8:  BSF    19.7
49BA:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
49BC:  MOVLW  07
49BE:  MOVLB  8
49C0:  MOVWF  x4C
49C2:  MOVLB  0
49C4:  CALL   346E
49C8:  BTFSC  19.7
49CA:  BSF    FF2.7
49CC:  CLRF   19
49CE:  BTFSC  FF2.7
49D0:  BSF    19.7
49D2:  BCF    FF2.7
....................    i2c_write(0x80); 
49D4:  MOVLW  80
49D6:  MOVLB  8
49D8:  MOVWF  x4C
49DA:  MOVLB  0
49DC:  CALL   346E
49E0:  BTFSC  19.7
49E2:  BSF    FF2.7
....................    i2c_stop(); 
49E4:  BCF    F94.4
49E6:  NOP   
49E8:  BSF    F94.3
49EA:  BTFSS  F82.3
49EC:  BRA    49EA
49EE:  MOVLW  0A
49F0:  MOVWF  00
49F2:  DECFSZ 00,F
49F4:  BRA    49F2
49F6:  BRA    49F8
49F8:  NOP   
49FA:  BSF    F94.4
49FC:  MOVLW  0A
49FE:  MOVWF  00
4A00:  DECFSZ 00,F
4A02:  BRA    4A00
.................... } 
4A04:  GOTO   7C54 (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
636E:  CLRF   19
6370:  BTFSC  FF2.7
6372:  BSF    19.7
6374:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
6376:  MOVFF  7FD,83E
637A:  MOVLW  0A
637C:  MOVLB  8
637E:  MOVWF  x3F
6380:  MOVLB  0
6382:  CALL   173A
6386:  BTFSC  19.7
6388:  BSF    FF2.7
638A:  MOVFF  01,7FE
....................    nibl=data-(nibh*10); 
638E:  MOVLB  7
6390:  MOVF   xFE,W
6392:  MULLW  0A
6394:  MOVF   FF3,W
6396:  SUBWF  xFD,W
6398:  MOVWF  xFF
....................  
....................    return((nibh<<4)|nibl); 
639A:  SWAPF  xFE,W
639C:  MOVWF  00
639E:  MOVLW  F0
63A0:  ANDWF  00,F
63A2:  MOVF   00,W
63A4:  IORWF  xFF,W
63A6:  MOVWF  01
.................... } 
63A8:  MOVLB  0
63AA:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
617A:  MOVFF  7FC,7FD
....................    data=(i>>4)*10; 
617E:  MOVLB  7
6180:  SWAPF  xFD,W
6182:  MOVWF  00
6184:  MOVLW  0F
6186:  ANDWF  00,F
6188:  MOVF   00,W
618A:  MULLW  0A
618C:  MOVFF  FF3,7FC
....................    data=data+(i<<4>>4); 
6190:  SWAPF  xFD,W
6192:  MOVWF  00
6194:  MOVLW  F0
6196:  ANDWF  00,F
6198:  MOVF   00,W
619A:  SWAPF  00,F
619C:  MOVLW  0F
619E:  ANDWF  00,F
61A0:  MOVF   00,W
61A2:  ADDWF  xFC,F
....................  
....................    return data; 
61A4:  MOVFF  7FC,01
.................... } 
61A8:  MOVLB  0
61AA:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
63AC:  MOVLB  7
63AE:  CLRF   xFE
63B0:  CLRF   xFF
63B2:  MOVLB  0
63B4:  RCALL  62C0
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
63B6:  MOVFF  7FC,7FD
63BA:  RCALL  636E
63BC:  MOVFF  01,7FD
63C0:  MOVLW  01
63C2:  MOVLB  7
63C4:  MOVWF  xFE
63C6:  MOVFF  01,7FF
63CA:  MOVLB  0
63CC:  RCALL  62C0
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
63CE:  MOVFF  7FB,7FD
63D2:  RCALL  636E
63D4:  MOVFF  01,7FD
63D8:  MOVLW  02
63DA:  MOVLB  7
63DC:  MOVWF  xFE
63DE:  MOVFF  01,7FF
63E2:  MOVLB  0
63E4:  RCALL  62C0
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
63E6:  MOVFF  7FA,7FD
63EA:  RCALL  636E
63EC:  MOVFF  01,7FD
63F0:  MOVLW  03
63F2:  MOVLB  7
63F4:  MOVWF  xFE
63F6:  MOVFF  01,7FF
63FA:  MOVLB  0
63FC:  RCALL  62C0
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
63FE:  MOVFF  7F7,7FD
6402:  RCALL  636E
6404:  MOVFF  01,7FD
6408:  MOVLW  04
640A:  MOVLB  7
640C:  MOVWF  xFE
640E:  MOVFF  01,7FF
6412:  MOVLB  0
6414:  RCALL  62C0
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
6416:  MOVFF  7F8,7FD
641A:  RCALL  636E
641C:  MOVFF  01,7FD
6420:  MOVLW  05
6422:  MOVLB  7
6424:  MOVWF  xFE
6426:  MOVFF  01,7FF
642A:  MOVLB  0
642C:  RCALL  62C0
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
642E:  MOVFF  7F9,7FD
6432:  RCALL  636E
6434:  MOVFF  01,7FD
6438:  MOVLW  06
643A:  MOVLB  7
643C:  MOVWF  xFE
643E:  MOVFF  01,7FF
6442:  MOVLB  0
6444:  RCALL  62C0
....................    write_DS1307(DS1307_CONTROL,0);    
6446:  MOVLW  07
6448:  MOVLB  7
644A:  MOVWF  xFE
644C:  CLRF   xFF
644E:  MOVLB  0
6450:  RCALL  62C0
.................... } 
6452:  GOTO   70A8 (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
6BE8:  MOVLW  04
6BEA:  MOVLB  7
6BEC:  MOVWF  xFB
6BEE:  MOVLB  0
6BF0:  CALL   482E
6BF4:  MOVFF  01,7F7
6BF8:  MOVFF  01,7FC
6BFC:  CALL   617A
6C00:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
6C04:  MOVLW  05
6C06:  MOVLB  7
6C08:  MOVWF  xFB
6C0A:  MOVLB  0
6C0C:  CALL   482E
6C10:  MOVFF  01,7F7
6C14:  MOVFF  01,7FC
6C18:  CALL   617A
6C1C:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
6C20:  MOVLW  06
6C22:  MOVLB  7
6C24:  MOVWF  xFB
6C26:  MOVLB  0
6C28:  CALL   482E
6C2C:  MOVFF  01,7F7
6C30:  MOVFF  01,7FC
6C34:  CALL   617A
6C38:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
6C3C:  MOVLW  03
6C3E:  MOVLB  7
6C40:  MOVWF  xFB
6C42:  MOVLB  0
6C44:  CALL   482E
6C48:  MOVFF  01,7F7
6C4C:  MOVFF  01,7FC
6C50:  CALL   617A
6C54:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
6C58:  MOVLW  02
6C5A:  MOVLB  7
6C5C:  MOVWF  xFB
6C5E:  MOVLB  0
6C60:  CALL   482E
6C64:  MOVFF  01,7F7
6C68:  MOVFF  01,7FC
6C6C:  CALL   617A
6C70:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
6C74:  MOVLW  01
6C76:  MOVLB  7
6C78:  MOVWF  xFB
6C7A:  MOVLB  0
6C7C:  CALL   482E
6C80:  MOVFF  01,7F7
6C84:  MOVFF  01,7FC
6C88:  CALL   617A
6C8C:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
6C90:  MOVLB  7
6C92:  CLRF   xFB
6C94:  MOVLB  0
6C96:  CALL   482E
6C9A:  MOVFF  01,7F7
6C9E:  MOVFF  01,7FC
6CA2:  CALL   617A
6CA6:  MOVFF  01,103
6CAA:  CLRF   19
6CAC:  BTFSC  FF2.7
6CAE:  BSF    19.7
6CB0:  BCF    FF2.7
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0,booting=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... int16 count_checking=10; 
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
.................... #define CRYPTO_KEY_SIZE   32 
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int16 galois_mul2(unsigned int16 value) 
.................... { 
....................   signed int16 temp; 
....................   // cast to signed value 
....................   temp = (signed char) value; 
*
4B90:  CLRF   03
4B92:  MOVLB  7
4B94:  MOVF   xE2,W
4B96:  BTFSC  FE8.7
4B98:  DECF   03,F
4B9A:  MOVWF  xE4
4B9C:  MOVFF  03,7E5
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
4BA0:  RRCF   xE5,W
4BA2:  MOVWF  03
4BA4:  RRCF   xE4,W
4BA6:  MOVWF  02
4BA8:  RRCF   03,F
4BAA:  RRCF   02,F
4BAC:  RRCF   03,F
4BAE:  RRCF   02,F
4BB0:  RRCF   03,F
4BB2:  RRCF   02,F
4BB4:  RRCF   03,F
4BB6:  RRCF   02,F
4BB8:  RRCF   03,F
4BBA:  RRCF   02,F
4BBC:  RRCF   03,F
4BBE:  RRCF   02,F
4BC0:  MOVLW  01
4BC2:  ANDWF  03,F
4BC4:  MOVFF  02,7E4
4BC8:  MOVFF  03,7E5
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
4BCC:  MOVLW  1B
4BCE:  ANDWF  xE4,F
4BD0:  CLRF   xE5
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
4BD2:  BCF    FD8.0
4BD4:  RLCF   xE2,W
4BD6:  MOVWF  xE6
4BD8:  RLCF   xE3,W
4BDA:  MOVWF  xE7
4BDC:  MOVF   xE6,W
4BDE:  XORWF  xE4,W
4BE0:  MOVWF  00
4BE2:  MOVF   xE7,W
4BE4:  XORWF  xE5,W
4BE6:  MOVWF  03
4BE8:  MOVFF  00,01
4BEC:  MOVWF  02
.................... } 
4BEE:  MOVLB  0
4BF0:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................     unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................  
....................   // In case of decryption 
....................   if (dir != 0)  
4BF2:  MOVLB  7
4BF4:  MOVF   xD9,F
4BF6:  BTFSC  FD8.2
4BF8:  BRA    4DC4
....................   { 
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
4BFA:  CLRF   xDE
4BFC:  MOVF   xDE,W
4BFE:  SUBLW  09
4C00:  BTFSS  FD8.0
4C02:  BRA    4D7A
....................       //key schedule 
....................       key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[round]); 
4C04:  MOVFF  7D7,01
4C08:  MOVFF  7D8,03
4C0C:  MOVFF  7D7,7E0
4C10:  MOVFF  7D8,7E1
4C14:  MOVLW  0D
4C16:  ADDWF  xD7,W
4C18:  MOVWF  FE9
4C1A:  MOVLW  00
4C1C:  ADDWFC xD8,W
4C1E:  MOVWF  FEA
4C20:  CLRF   03
4C22:  MOVF   FEF,W
4C24:  MOVLB  0
4C26:  CALL   00D0
4C2A:  MOVLB  7
4C2C:  MOVWF  xE2
4C2E:  MOVFF  7D7,FE9
4C32:  MOVFF  7D8,FEA
4C36:  MOVF   FEF,W
4C38:  XORWF  xE2,F
4C3A:  CLRF   03
4C3C:  MOVF   xDE,W
4C3E:  MOVLB  0
4C40:  CALL   02F0
4C44:  MOVWF  01
4C46:  MOVLB  7
4C48:  MOVF   xE2,W
4C4A:  XORWF  01,W
4C4C:  MOVFF  7E1,FEA
4C50:  MOVFF  7E0,FE9
4C54:  MOVWF  FEF
....................       key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4C56:  MOVLW  01
4C58:  ADDWF  xD7,W
4C5A:  MOVWF  01
4C5C:  MOVLW  00
4C5E:  ADDWFC xD8,W
4C60:  MOVWF  03
4C62:  MOVFF  01,7E0
4C66:  MOVWF  xE1
4C68:  MOVLW  0E
4C6A:  ADDWF  xD7,W
4C6C:  MOVWF  FE9
4C6E:  MOVLW  00
4C70:  ADDWFC xD8,W
4C72:  MOVWF  FEA
4C74:  CLRF   03
4C76:  MOVF   FEF,W
4C78:  MOVLB  0
4C7A:  CALL   00D0
4C7E:  MOVLB  7
4C80:  MOVWF  xE2
4C82:  MOVLW  01
4C84:  ADDWF  xD7,W
4C86:  MOVWF  FE9
4C88:  MOVLW  00
4C8A:  ADDWFC xD8,W
4C8C:  MOVWF  FEA
4C8E:  MOVF   FEF,W
4C90:  XORWF  xE2,W
4C92:  MOVFF  7E1,FEA
4C96:  MOVFF  7E0,FE9
4C9A:  MOVWF  FEF
....................       key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
4C9C:  MOVLW  02
4C9E:  ADDWF  xD7,W
4CA0:  MOVWF  01
4CA2:  MOVLW  00
4CA4:  ADDWFC xD8,W
4CA6:  MOVWF  03
4CA8:  MOVFF  01,7E0
4CAC:  MOVWF  xE1
4CAE:  MOVLW  0F
4CB0:  ADDWF  xD7,W
4CB2:  MOVWF  FE9
4CB4:  MOVLW  00
4CB6:  ADDWFC xD8,W
4CB8:  MOVWF  FEA
4CBA:  CLRF   03
4CBC:  MOVF   FEF,W
4CBE:  MOVLB  0
4CC0:  CALL   00D0
4CC4:  MOVLB  7
4CC6:  MOVWF  xE2
4CC8:  MOVLW  02
4CCA:  ADDWF  xD7,W
4CCC:  MOVWF  FE9
4CCE:  MOVLW  00
4CD0:  ADDWFC xD8,W
4CD2:  MOVWF  FEA
4CD4:  MOVF   FEF,W
4CD6:  XORWF  xE2,W
4CD8:  MOVFF  7E1,FEA
4CDC:  MOVFF  7E0,FE9
4CE0:  MOVWF  FEF
....................       key[3] = (unsigned int8)(sbox[key[12]]^key[3]); 
4CE2:  MOVLW  03
4CE4:  ADDWF  xD7,W
4CE6:  MOVWF  01
4CE8:  MOVLW  00
4CEA:  ADDWFC xD8,W
4CEC:  MOVWF  03
4CEE:  MOVFF  01,7E0
4CF2:  MOVWF  xE1
4CF4:  MOVLW  0C
4CF6:  ADDWF  xD7,W
4CF8:  MOVWF  FE9
4CFA:  MOVLW  00
4CFC:  ADDWFC xD8,W
4CFE:  MOVWF  FEA
4D00:  CLRF   03
4D02:  MOVF   FEF,W
4D04:  MOVLB  0
4D06:  CALL   00D0
4D0A:  MOVLB  7
4D0C:  MOVWF  xE2
4D0E:  MOVLW  03
4D10:  ADDWF  xD7,W
4D12:  MOVWF  FE9
4D14:  MOVLW  00
4D16:  ADDWFC xD8,W
4D18:  MOVWF  FEA
4D1A:  MOVF   FEF,W
4D1C:  XORWF  xE2,W
4D1E:  MOVFF  7E1,FEA
4D22:  MOVFF  7E0,FE9
4D26:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4D28:  MOVLW  04
4D2A:  MOVWF  xDF
4D2C:  MOVF   xDF,W
4D2E:  SUBLW  0F
4D30:  BNC   4D76
....................         key[i] = key[i] ^ key[i-4]; 
4D32:  CLRF   03
4D34:  MOVF   xDF,W
4D36:  ADDWF  xD7,W
4D38:  MOVWF  01
4D3A:  MOVF   xD8,W
4D3C:  ADDWFC 03,F
4D3E:  MOVFF  03,7E1
4D42:  CLRF   03
4D44:  MOVF   xDF,W
4D46:  ADDWF  xD7,W
4D48:  MOVWF  FE9
4D4A:  MOVF   xD8,W
4D4C:  ADDWFC 03,W
4D4E:  MOVWF  FEA
4D50:  MOVFF  FEF,7E2
4D54:  MOVLW  04
4D56:  SUBWF  xDF,W
4D58:  CLRF   03
4D5A:  ADDWF  xD7,W
4D5C:  MOVWF  FE9
4D5E:  MOVF   xD8,W
4D60:  ADDWFC 03,W
4D62:  MOVWF  FEA
4D64:  MOVF   FEF,W
4D66:  XORWF  xE2,W
4D68:  MOVFF  7E1,FEA
4D6C:  MOVFF  01,FE9
4D70:  MOVWF  FEF
....................       } 
4D72:  INCF   xDF,F
4D74:  BRA    4D2C
....................     } 
4D76:  INCF   xDE,F
4D78:  BRA    4BFC
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++) 
4D7A:  CLRF   xDF
4D7C:  MOVF   xDF,W
4D7E:  SUBLW  0F
4D80:  BNC   4DC4
....................     { 
....................       state[i]=state[i] ^ key[i]; 
4D82:  CLRF   03
4D84:  MOVF   xDF,W
4D86:  ADDWF  xD5,W
4D88:  MOVWF  01
4D8A:  MOVF   xD6,W
4D8C:  ADDWFC 03,F
4D8E:  MOVFF  03,7E1
4D92:  CLRF   03
4D94:  MOVF   xDF,W
4D96:  ADDWF  xD5,W
4D98:  MOVWF  FE9
4D9A:  MOVF   xD6,W
4D9C:  ADDWFC 03,W
4D9E:  MOVWF  FEA
4DA0:  MOVFF  FEF,7E2
4DA4:  CLRF   03
4DA6:  MOVF   xDF,W
4DA8:  ADDWF  xD7,W
4DAA:  MOVWF  FE9
4DAC:  MOVF   xD8,W
4DAE:  ADDWFC 03,W
4DB0:  MOVWF  FEA
4DB2:  MOVF   FEF,W
4DB4:  XORWF  xE2,W
4DB6:  MOVFF  7E1,FEA
4DBA:  MOVFF  01,FE9
4DBE:  MOVWF  FEF
....................     } 
4DC0:  INCF   xDF,F
4DC2:  BRA    4D7C
....................   } 
....................   // main loop 
....................   for (round = 0; round < 10; round++) 
4DC4:  CLRF   xDE
4DC6:  MOVF   xDE,W
4DC8:  SUBLW  09
4DCA:  BTFSS  FD8.0
4DCC:  GOTO   5814
....................   { 
....................     if (dir != 0) 
4DD0:  MOVF   xD9,F
4DD2:  BTFSC  FD8.2
4DD4:  BRA    4F4E
....................     { 
....................           //Inverse key schedule 
....................           for (i=15; i>3; --i)  
4DD6:  MOVLW  0F
4DD8:  MOVWF  xDF
4DDA:  MOVF   xDF,W
4DDC:  SUBLW  03
4DDE:  BC    4E24
....................           { 
....................             key[i] = key[i] ^ key[i-4]; 
4DE0:  CLRF   03
4DE2:  MOVF   xDF,W
4DE4:  ADDWF  xD7,W
4DE6:  MOVWF  01
4DE8:  MOVF   xD8,W
4DEA:  ADDWFC 03,F
4DEC:  MOVFF  03,7E1
4DF0:  CLRF   03
4DF2:  MOVF   xDF,W
4DF4:  ADDWF  xD7,W
4DF6:  MOVWF  FE9
4DF8:  MOVF   xD8,W
4DFA:  ADDWFC 03,W
4DFC:  MOVWF  FEA
4DFE:  MOVFF  FEF,7E2
4E02:  MOVLW  04
4E04:  SUBWF  xDF,W
4E06:  CLRF   03
4E08:  ADDWF  xD7,W
4E0A:  MOVWF  FE9
4E0C:  MOVF   xD8,W
4E0E:  ADDWFC 03,W
4E10:  MOVWF  FEA
4E12:  MOVF   FEF,W
4E14:  XORWF  xE2,W
4E16:  MOVFF  7E1,FEA
4E1A:  MOVFF  01,FE9
4E1E:  MOVWF  FEF
....................           }   
4E20:  DECF   xDF,F
4E22:  BRA    4DDA
....................           key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[9-round]); 
4E24:  MOVFF  7D7,01
4E28:  MOVFF  7D8,03
4E2C:  MOVFF  7D7,7E0
4E30:  MOVFF  7D8,7E1
4E34:  MOVLW  0D
4E36:  ADDWF  xD7,W
4E38:  MOVWF  FE9
4E3A:  MOVLW  00
4E3C:  ADDWFC xD8,W
4E3E:  MOVWF  FEA
4E40:  CLRF   03
4E42:  MOVF   FEF,W
4E44:  MOVLB  0
4E46:  CALL   00D0
4E4A:  MOVLB  7
4E4C:  MOVWF  xE2
4E4E:  MOVFF  7D7,FE9
4E52:  MOVFF  7D8,FEA
4E56:  MOVF   FEF,W
4E58:  XORWF  xE2,F
4E5A:  MOVLW  09
4E5C:  BSF    FD8.0
4E5E:  SUBFWB xDE,W
4E60:  CLRF   03
4E62:  MOVLB  0
4E64:  CALL   02F0
4E68:  MOVWF  01
4E6A:  MOVLB  7
4E6C:  MOVF   xE2,W
4E6E:  XORWF  01,W
4E70:  MOVFF  7E1,FEA
4E74:  MOVFF  7E0,FE9
4E78:  MOVWF  FEF
....................           key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4E7A:  MOVLW  01
4E7C:  ADDWF  xD7,W
4E7E:  MOVWF  01
4E80:  MOVLW  00
4E82:  ADDWFC xD8,W
4E84:  MOVWF  03
4E86:  MOVFF  01,7E0
4E8A:  MOVWF  xE1
4E8C:  MOVLW  0E
4E8E:  ADDWF  xD7,W
4E90:  MOVWF  FE9
4E92:  MOVLW  00
4E94:  ADDWFC xD8,W
4E96:  MOVWF  FEA
4E98:  CLRF   03
4E9A:  MOVF   FEF,W
4E9C:  MOVLB  0
4E9E:  CALL   00D0
4EA2:  MOVLB  7
4EA4:  MOVWF  xE2
4EA6:  MOVLW  01
4EA8:  ADDWF  xD7,W
4EAA:  MOVWF  FE9
4EAC:  MOVLW  00
4EAE:  ADDWFC xD8,W
4EB0:  MOVWF  FEA
4EB2:  MOVF   FEF,W
4EB4:  XORWF  xE2,W
4EB6:  MOVFF  7E1,FEA
4EBA:  MOVFF  7E0,FE9
4EBE:  MOVWF  FEF
....................           key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
4EC0:  MOVLW  02
4EC2:  ADDWF  xD7,W
4EC4:  MOVWF  01
4EC6:  MOVLW  00
4EC8:  ADDWFC xD8,W
4ECA:  MOVWF  03
4ECC:  MOVFF  01,7E0
4ED0:  MOVWF  xE1
4ED2:  MOVLW  0F
4ED4:  ADDWF  xD7,W
4ED6:  MOVWF  FE9
4ED8:  MOVLW  00
4EDA:  ADDWFC xD8,W
4EDC:  MOVWF  FEA
4EDE:  CLRF   03
4EE0:  MOVF   FEF,W
4EE2:  MOVLB  0
4EE4:  CALL   00D0
4EE8:  MOVLB  7
4EEA:  MOVWF  xE2
4EEC:  MOVLW  02
4EEE:  ADDWF  xD7,W
4EF0:  MOVWF  FE9
4EF2:  MOVLW  00
4EF4:  ADDWFC xD8,W
4EF6:  MOVWF  FEA
4EF8:  MOVF   FEF,W
4EFA:  XORWF  xE2,W
4EFC:  MOVFF  7E1,FEA
4F00:  MOVFF  7E0,FE9
4F04:  MOVWF  FEF
....................           key[3] = (unsigned int8)(sbox[key[12]]^key[3]);  
4F06:  MOVLW  03
4F08:  ADDWF  xD7,W
4F0A:  MOVWF  01
4F0C:  MOVLW  00
4F0E:  ADDWFC xD8,W
4F10:  MOVWF  03
4F12:  MOVFF  01,7E0
4F16:  MOVWF  xE1
4F18:  MOVLW  0C
4F1A:  ADDWF  xD7,W
4F1C:  MOVWF  FE9
4F1E:  MOVLW  00
4F20:  ADDWFC xD8,W
4F22:  MOVWF  FEA
4F24:  CLRF   03
4F26:  MOVF   FEF,W
4F28:  MOVLB  0
4F2A:  CALL   00D0
4F2E:  MOVLB  7
4F30:  MOVWF  xE2
4F32:  MOVLW  03
4F34:  ADDWF  xD7,W
4F36:  MOVWF  FE9
4F38:  MOVLW  00
4F3A:  ADDWFC xD8,W
4F3C:  MOVWF  FEA
4F3E:  MOVF   FEF,W
4F40:  XORWF  xE2,W
4F42:  MOVFF  7E1,FEA
4F46:  MOVFF  7E0,FE9
4F4A:  MOVWF  FEF
....................     }  
....................     else  
4F4C:  BRA    5166
....................     { 
....................         for (i = 0; i <16; i++) 
4F4E:  CLRF   xDF
4F50:  MOVF   xDF,W
4F52:  SUBLW  0F
4F54:  BNC   4FA6
....................         { 
....................             // with shiftrow i+5 mod 16 
....................             state[i]=sbox[state[i] ^ key[i]]; 
4F56:  CLRF   03
4F58:  MOVF   xDF,W
4F5A:  ADDWF  xD5,W
4F5C:  MOVWF  01
4F5E:  MOVF   xD6,W
4F60:  ADDWFC 03,F
4F62:  MOVFF  01,7E0
4F66:  MOVFF  03,7E1
4F6A:  CLRF   03
4F6C:  MOVF   xDF,W
4F6E:  ADDWF  xD5,W
4F70:  MOVWF  FE9
4F72:  MOVF   xD6,W
4F74:  ADDWFC 03,W
4F76:  MOVWF  FEA
4F78:  MOVFF  FEF,7E2
4F7C:  CLRF   03
4F7E:  MOVF   xDF,W
4F80:  ADDWF  xD7,W
4F82:  MOVWF  FE9
4F84:  MOVF   xD8,W
4F86:  ADDWFC 03,W
4F88:  MOVWF  FEA
4F8A:  MOVF   FEF,W
4F8C:  XORWF  xE2,W
4F8E:  CLRF   03
4F90:  MOVLB  0
4F92:  CALL   00D0
4F96:  MOVFF  7E1,FEA
4F9A:  MOVFF  7E0,FE9
4F9E:  MOVWF  FEF
....................         } 
4FA0:  MOVLB  7
4FA2:  INCF   xDF,F
4FA4:  BRA    4F50
....................         //shift rows 
....................         buf1 = state[1]; 
4FA6:  MOVLW  01
4FA8:  ADDWF  xD5,W
4FAA:  MOVWF  FE9
4FAC:  MOVLW  00
4FAE:  ADDWFC xD6,W
4FB0:  MOVWF  FEA
4FB2:  MOVFF  FEF,7DA
....................         state[1] = state[5]; 
4FB6:  MOVLW  01
4FB8:  ADDWF  xD5,W
4FBA:  MOVWF  01
4FBC:  MOVLW  00
4FBE:  ADDWFC xD6,W
4FC0:  MOVWF  03
4FC2:  MOVLW  05
4FC4:  ADDWF  xD5,W
4FC6:  MOVWF  FE9
4FC8:  MOVLW  00
4FCA:  ADDWFC xD6,W
4FCC:  MOVWF  FEA
4FCE:  MOVFF  FEF,7E2
4FD2:  MOVFF  03,FEA
4FD6:  MOVFF  01,FE9
4FDA:  MOVFF  7E2,FEF
....................         state[5] = state[9]; 
4FDE:  MOVLW  05
4FE0:  ADDWF  xD5,W
4FE2:  MOVWF  01
4FE4:  MOVLW  00
4FE6:  ADDWFC xD6,W
4FE8:  MOVWF  03
4FEA:  MOVLW  09
4FEC:  ADDWF  xD5,W
4FEE:  MOVWF  FE9
4FF0:  MOVLW  00
4FF2:  ADDWFC xD6,W
4FF4:  MOVWF  FEA
4FF6:  MOVFF  FEF,7E2
4FFA:  MOVFF  03,FEA
4FFE:  MOVFF  01,FE9
5002:  MOVFF  7E2,FEF
....................         state[9] = state[13]; 
5006:  MOVLW  09
5008:  ADDWF  xD5,W
500A:  MOVWF  01
500C:  MOVLW  00
500E:  ADDWFC xD6,W
5010:  MOVWF  03
5012:  MOVLW  0D
5014:  ADDWF  xD5,W
5016:  MOVWF  FE9
5018:  MOVLW  00
501A:  ADDWFC xD6,W
501C:  MOVWF  FEA
501E:  MOVFF  FEF,7E2
5022:  MOVFF  03,FEA
5026:  MOVFF  01,FE9
502A:  MOVFF  7E2,FEF
....................         state[13] = buf1; 
502E:  MOVLW  0D
5030:  ADDWF  xD5,W
5032:  MOVWF  FE9
5034:  MOVLW  00
5036:  ADDWFC xD6,W
5038:  MOVWF  FEA
503A:  MOVFF  7DA,FEF
....................      
....................         buf1 = state[2]; 
503E:  MOVLW  02
5040:  ADDWF  xD5,W
5042:  MOVWF  FE9
5044:  MOVLW  00
5046:  ADDWFC xD6,W
5048:  MOVWF  FEA
504A:  MOVFF  FEF,7DA
....................         buf2 = state[6]; 
504E:  MOVLW  06
5050:  ADDWF  xD5,W
5052:  MOVWF  FE9
5054:  MOVLW  00
5056:  ADDWFC xD6,W
5058:  MOVWF  FEA
505A:  MOVFF  FEF,7DB
....................         state[2] = state[10]; 
505E:  MOVLW  02
5060:  ADDWF  xD5,W
5062:  MOVWF  01
5064:  MOVLW  00
5066:  ADDWFC xD6,W
5068:  MOVWF  03
506A:  MOVLW  0A
506C:  ADDWF  xD5,W
506E:  MOVWF  FE9
5070:  MOVLW  00
5072:  ADDWFC xD6,W
5074:  MOVWF  FEA
5076:  MOVFF  FEF,7E2
507A:  MOVFF  03,FEA
507E:  MOVFF  01,FE9
5082:  MOVFF  7E2,FEF
....................         state[6] = state[14]; 
5086:  MOVLW  06
5088:  ADDWF  xD5,W
508A:  MOVWF  01
508C:  MOVLW  00
508E:  ADDWFC xD6,W
5090:  MOVWF  03
5092:  MOVLW  0E
5094:  ADDWF  xD5,W
5096:  MOVWF  FE9
5098:  MOVLW  00
509A:  ADDWFC xD6,W
509C:  MOVWF  FEA
509E:  MOVFF  FEF,7E2
50A2:  MOVFF  03,FEA
50A6:  MOVFF  01,FE9
50AA:  MOVFF  7E2,FEF
....................         state[10] = buf1; 
50AE:  MOVLW  0A
50B0:  ADDWF  xD5,W
50B2:  MOVWF  FE9
50B4:  MOVLW  00
50B6:  ADDWFC xD6,W
50B8:  MOVWF  FEA
50BA:  MOVFF  7DA,FEF
....................         state[14] = buf2; 
50BE:  MOVLW  0E
50C0:  ADDWF  xD5,W
50C2:  MOVWF  FE9
50C4:  MOVLW  00
50C6:  ADDWFC xD6,W
50C8:  MOVWF  FEA
50CA:  MOVFF  7DB,FEF
....................      
....................         buf1 = state[15]; 
50CE:  MOVLW  0F
50D0:  ADDWF  xD5,W
50D2:  MOVWF  FE9
50D4:  MOVLW  00
50D6:  ADDWFC xD6,W
50D8:  MOVWF  FEA
50DA:  MOVFF  FEF,7DA
....................         state[15] = state[11]; 
50DE:  MOVLW  0F
50E0:  ADDWF  xD5,W
50E2:  MOVWF  01
50E4:  MOVLW  00
50E6:  ADDWFC xD6,W
50E8:  MOVWF  03
50EA:  MOVLW  0B
50EC:  ADDWF  xD5,W
50EE:  MOVWF  FE9
50F0:  MOVLW  00
50F2:  ADDWFC xD6,W
50F4:  MOVWF  FEA
50F6:  MOVFF  FEF,7E2
50FA:  MOVFF  03,FEA
50FE:  MOVFF  01,FE9
5102:  MOVFF  7E2,FEF
....................         state[11] = state[7]; 
5106:  MOVLW  0B
5108:  ADDWF  xD5,W
510A:  MOVWF  01
510C:  MOVLW  00
510E:  ADDWFC xD6,W
5110:  MOVWF  03
5112:  MOVLW  07
5114:  ADDWF  xD5,W
5116:  MOVWF  FE9
5118:  MOVLW  00
511A:  ADDWFC xD6,W
511C:  MOVWF  FEA
511E:  MOVFF  FEF,7E2
5122:  MOVFF  03,FEA
5126:  MOVFF  01,FE9
512A:  MOVFF  7E2,FEF
....................         state[7] = state[3]; 
512E:  MOVLW  07
5130:  ADDWF  xD5,W
5132:  MOVWF  01
5134:  MOVLW  00
5136:  ADDWFC xD6,W
5138:  MOVWF  03
513A:  MOVLW  03
513C:  ADDWF  xD5,W
513E:  MOVWF  FE9
5140:  MOVLW  00
5142:  ADDWFC xD6,W
5144:  MOVWF  FEA
5146:  MOVFF  FEF,7E2
514A:  MOVFF  03,FEA
514E:  MOVFF  01,FE9
5152:  MOVFF  7E2,FEF
....................         state[3] = buf1; 
5156:  MOVLW  03
5158:  ADDWF  xD5,W
515A:  MOVWF  FE9
515C:  MOVLW  00
515E:  ADDWFC xD6,W
5160:  MOVWF  FEA
5162:  MOVFF  7DA,FEF
....................     } 
....................      
....................     //mixcol - inv mix 
....................     if (((round > 0) && (dir != 0)) || ((round < 9) && (dir == 0)))  
5166:  MOVF   xDE,F
5168:  BZ    516E
516A:  MOVF   xD9,F
516C:  BNZ   517C
516E:  MOVF   xDE,W
5170:  SUBLW  08
5172:  BTFSS  FD8.0
5174:  BRA    547C
5176:  MOVF   xD9,F
5178:  BTFSS  FD8.2
517A:  BRA    547C
....................     { 
....................           for (i=0; i <4; i++) 
517C:  CLRF   xDF
517E:  MOVF   xDF,W
5180:  SUBLW  03
5182:  BTFSS  FD8.0
5184:  BRA    547C
....................           { 
....................                 buf4 = (unsigned int8)(i << 2); 
5186:  RLCF   xDF,W
5188:  MOVWF  xDD
518A:  RLCF   xDD,F
518C:  MOVLW  FC
518E:  ANDWF  xDD,F
....................                 if (dir != 0) 
5190:  MOVF   xD9,F
5192:  BZ    527C
....................                 { 
....................                       // precompute for decryption 
....................                       buf1 = galois_mul2(galois_mul2((unsigned int8)(state[buf4]^state[buf4+2]))); 
5194:  CLRF   03
5196:  MOVF   xDD,W
5198:  ADDWF  xD5,W
519A:  MOVWF  FE9
519C:  MOVF   xD6,W
519E:  ADDWFC 03,W
51A0:  MOVWF  FEA
51A2:  MOVFF  FEF,7E0
51A6:  MOVLW  02
51A8:  ADDWF  xDD,W
51AA:  CLRF   03
51AC:  ADDWF  xD5,W
51AE:  MOVWF  FE9
51B0:  MOVF   xD6,W
51B2:  ADDWFC 03,W
51B4:  MOVWF  FEA
51B6:  MOVF   FEF,W
51B8:  XORWF  xE0,F
51BA:  CLRF   xE3
51BC:  MOVFF  7E0,7E2
51C0:  MOVLB  0
51C2:  RCALL  4B90
51C4:  MOVFF  02,7E1
51C8:  MOVFF  01,7E0
51CC:  MOVFF  02,7E3
51D0:  MOVFF  01,7E2
51D4:  RCALL  4B90
51D6:  MOVFF  01,7DA
....................                       buf2 = galois_mul2(galois_mul2((unsigned int8)(state[buf4+1]^state[buf4+3]))); 
51DA:  MOVLW  01
51DC:  MOVLB  7
51DE:  ADDWF  xDD,W
51E0:  CLRF   03
51E2:  ADDWF  xD5,W
51E4:  MOVWF  FE9
51E6:  MOVF   xD6,W
51E8:  ADDWFC 03,W
51EA:  MOVWF  FEA
51EC:  MOVFF  FEF,7E0
51F0:  MOVLW  03
51F2:  ADDWF  xDD,W
51F4:  CLRF   03
51F6:  ADDWF  xD5,W
51F8:  MOVWF  FE9
51FA:  MOVF   xD6,W
51FC:  ADDWFC 03,W
51FE:  MOVWF  FEA
5200:  MOVF   FEF,W
5202:  XORWF  xE0,F
5204:  CLRF   xE3
5206:  MOVFF  7E0,7E2
520A:  MOVLB  0
520C:  RCALL  4B90
520E:  MOVFF  02,7E1
5212:  MOVFF  01,7E0
5216:  MOVFF  02,7E3
521A:  MOVFF  01,7E2
521E:  RCALL  4B90
5220:  MOVFF  01,7DB
....................                       state[buf4] ^= buf1;  
5224:  CLRF   03
5226:  MOVLB  7
5228:  MOVF   xDD,W
522A:  ADDWF  xD5,W
522C:  MOVWF  FE9
522E:  MOVF   xD6,W
5230:  ADDWFC 03,W
5232:  MOVWF  FEA
5234:  MOVF   FEF,W
5236:  XORWF  xDA,W
5238:  MOVWF  FEF
....................                       state[buf4+1] ^= buf2;  
523A:  MOVLW  01
523C:  ADDWF  xDD,W
523E:  CLRF   03
5240:  ADDWF  xD5,W
5242:  MOVWF  FE9
5244:  MOVF   xD6,W
5246:  ADDWFC 03,W
5248:  MOVWF  FEA
524A:  MOVF   FEF,W
524C:  XORWF  xDB,W
524E:  MOVWF  FEF
....................                       state[buf4+2] ^= buf1;  
5250:  MOVLW  02
5252:  ADDWF  xDD,W
5254:  CLRF   03
5256:  ADDWF  xD5,W
5258:  MOVWF  FE9
525A:  MOVF   xD6,W
525C:  ADDWFC 03,W
525E:  MOVWF  FEA
5260:  MOVF   FEF,W
5262:  XORWF  xDA,W
5264:  MOVWF  FEF
....................                       state[buf4+3] ^= buf2;  
5266:  MOVLW  03
5268:  ADDWF  xDD,W
526A:  CLRF   03
526C:  ADDWF  xD5,W
526E:  MOVWF  FE9
5270:  MOVF   xD6,W
5272:  ADDWFC 03,W
5274:  MOVWF  FEA
5276:  MOVF   FEF,W
5278:  XORWF  xDB,W
527A:  MOVWF  FEF
....................                 } 
....................                 // in all cases 
....................                 buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
527C:  CLRF   03
527E:  MOVF   xDD,W
5280:  ADDWF  xD5,W
5282:  MOVWF  FE9
5284:  MOVF   xD6,W
5286:  ADDWFC 03,W
5288:  MOVWF  FEA
528A:  MOVFF  FEF,7E0
528E:  MOVLW  01
5290:  ADDWF  xDD,W
5292:  CLRF   03
5294:  ADDWF  xD5,W
5296:  MOVWF  FE9
5298:  MOVF   xD6,W
529A:  ADDWFC 03,W
529C:  MOVWF  FEA
529E:  MOVF   FEF,W
52A0:  XORWF  xE0,F
52A2:  MOVLW  02
52A4:  ADDWF  xDD,W
52A6:  CLRF   03
52A8:  ADDWF  xD5,W
52AA:  MOVWF  FE9
52AC:  MOVF   xD6,W
52AE:  ADDWFC 03,W
52B0:  MOVWF  FEA
52B2:  MOVF   FEF,W
52B4:  XORWF  xE0,F
52B6:  MOVLW  03
52B8:  ADDWF  xDD,W
52BA:  CLRF   03
52BC:  ADDWF  xD5,W
52BE:  MOVWF  FE9
52C0:  MOVF   xD6,W
52C2:  ADDWFC 03,W
52C4:  MOVWF  FEA
52C6:  MOVF   FEF,W
52C8:  XORWF  xE0,W
52CA:  MOVWF  xDA
....................                 buf2 = state[buf4]; 
52CC:  CLRF   03
52CE:  MOVF   xDD,W
52D0:  ADDWF  xD5,W
52D2:  MOVWF  FE9
52D4:  MOVF   xD6,W
52D6:  ADDWFC 03,W
52D8:  MOVWF  FEA
52DA:  MOVFF  FEF,7DB
....................                 buf3 = state[buf4]^state[buf4+1];  
52DE:  CLRF   03
52E0:  MOVF   xDD,W
52E2:  ADDWF  xD5,W
52E4:  MOVWF  FE9
52E6:  MOVF   xD6,W
52E8:  ADDWFC 03,W
52EA:  MOVWF  FEA
52EC:  MOVFF  FEF,7E0
52F0:  MOVLW  01
52F2:  ADDWF  xDD,W
52F4:  CLRF   03
52F6:  ADDWF  xD5,W
52F8:  MOVWF  FE9
52FA:  MOVF   xD6,W
52FC:  ADDWFC 03,W
52FE:  MOVWF  FEA
5300:  MOVF   FEF,W
5302:  XORWF  xE0,W
5304:  MOVWF  xDC
....................                 buf3=galois_mul2(buf3);  
5306:  CLRF   xE3
5308:  MOVFF  7DC,7E2
530C:  MOVLB  0
530E:  RCALL  4B90
5310:  MOVFF  01,7DC
....................                 state[buf4] = state[buf4] ^ buf3 ^ buf1; 
5314:  CLRF   03
5316:  MOVLB  7
5318:  MOVF   xDD,W
531A:  ADDWF  xD5,W
531C:  MOVWF  01
531E:  MOVF   xD6,W
5320:  ADDWFC 03,F
5322:  MOVFF  03,7E1
5326:  CLRF   03
5328:  MOVF   xDD,W
532A:  ADDWF  xD5,W
532C:  MOVWF  FE9
532E:  MOVF   xD6,W
5330:  ADDWFC 03,W
5332:  MOVWF  FEA
5334:  MOVF   FEF,W
5336:  XORWF  xDC,W
5338:  XORWF  xDA,W
533A:  MOVFF  7E1,FEA
533E:  MOVFF  01,FE9
5342:  MOVWF  FEF
....................                 buf3 = state[buf4+1]^state[buf4+2];  
5344:  MOVLW  01
5346:  ADDWF  xDD,W
5348:  CLRF   03
534A:  ADDWF  xD5,W
534C:  MOVWF  FE9
534E:  MOVF   xD6,W
5350:  ADDWFC 03,W
5352:  MOVWF  FEA
5354:  MOVFF  FEF,7E0
5358:  MOVLW  02
535A:  ADDWF  xDD,W
535C:  CLRF   03
535E:  ADDWF  xD5,W
5360:  MOVWF  FE9
5362:  MOVF   xD6,W
5364:  ADDWFC 03,W
5366:  MOVWF  FEA
5368:  MOVF   FEF,W
536A:  XORWF  xE0,W
536C:  MOVWF  xDC
....................                 buf3=galois_mul2(buf3);  
536E:  CLRF   xE3
5370:  MOVFF  7DC,7E2
5374:  MOVLB  0
5376:  RCALL  4B90
5378:  MOVFF  01,7DC
....................                 state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
537C:  MOVLW  01
537E:  MOVLB  7
5380:  ADDWF  xDD,W
5382:  CLRF   03
5384:  ADDWF  xD5,W
5386:  MOVWF  01
5388:  MOVF   xD6,W
538A:  ADDWFC 03,F
538C:  MOVFF  03,7E1
5390:  MOVLW  01
5392:  ADDWF  xDD,W
5394:  CLRF   03
5396:  ADDWF  xD5,W
5398:  MOVWF  FE9
539A:  MOVF   xD6,W
539C:  ADDWFC 03,W
539E:  MOVWF  FEA
53A0:  MOVF   FEF,W
53A2:  XORWF  xDC,W
53A4:  XORWF  xDA,W
53A6:  MOVFF  7E1,FEA
53AA:  MOVFF  01,FE9
53AE:  MOVWF  FEF
....................                 buf3 = state[buf4+2]^state[buf4+3];  
53B0:  MOVLW  02
53B2:  ADDWF  xDD,W
53B4:  CLRF   03
53B6:  ADDWF  xD5,W
53B8:  MOVWF  FE9
53BA:  MOVF   xD6,W
53BC:  ADDWFC 03,W
53BE:  MOVWF  FEA
53C0:  MOVFF  FEF,7E0
53C4:  MOVLW  03
53C6:  ADDWF  xDD,W
53C8:  CLRF   03
53CA:  ADDWF  xD5,W
53CC:  MOVWF  FE9
53CE:  MOVF   xD6,W
53D0:  ADDWFC 03,W
53D2:  MOVWF  FEA
53D4:  MOVF   FEF,W
53D6:  XORWF  xE0,W
53D8:  MOVWF  xDC
....................                 buf3=galois_mul2(buf3);  
53DA:  CLRF   xE3
53DC:  MOVFF  7DC,7E2
53E0:  MOVLB  0
53E2:  CALL   4B90
53E6:  MOVFF  01,7DC
....................                 state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
53EA:  MOVLW  02
53EC:  MOVLB  7
53EE:  ADDWF  xDD,W
53F0:  CLRF   03
53F2:  ADDWF  xD5,W
53F4:  MOVWF  01
53F6:  MOVF   xD6,W
53F8:  ADDWFC 03,F
53FA:  MOVFF  03,7E1
53FE:  MOVLW  02
5400:  ADDWF  xDD,W
5402:  CLRF   03
5404:  ADDWF  xD5,W
5406:  MOVWF  FE9
5408:  MOVF   xD6,W
540A:  ADDWFC 03,W
540C:  MOVWF  FEA
540E:  MOVF   FEF,W
5410:  XORWF  xDC,W
5412:  XORWF  xDA,W
5414:  MOVFF  7E1,FEA
5418:  MOVFF  01,FE9
541C:  MOVWF  FEF
....................                 buf3 = state[buf4+3]^buf2;      
541E:  MOVLW  03
5420:  ADDWF  xDD,W
5422:  CLRF   03
5424:  ADDWF  xD5,W
5426:  MOVWF  FE9
5428:  MOVF   xD6,W
542A:  ADDWFC 03,W
542C:  MOVWF  FEA
542E:  MOVF   FEF,W
5430:  XORWF  xDB,W
5432:  MOVWF  xDC
....................                 buf3=galois_mul2(buf3);  
5434:  CLRF   xE3
5436:  MOVFF  7DC,7E2
543A:  MOVLB  0
543C:  CALL   4B90
5440:  MOVFF  01,7DC
....................                 state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1;  
5444:  MOVLW  03
5446:  MOVLB  7
5448:  ADDWF  xDD,W
544A:  CLRF   03
544C:  ADDWF  xD5,W
544E:  MOVWF  01
5450:  MOVF   xD6,W
5452:  ADDWFC 03,F
5454:  MOVFF  03,7E1
5458:  MOVLW  03
545A:  ADDWF  xDD,W
545C:  CLRF   03
545E:  ADDWF  xD5,W
5460:  MOVWF  FE9
5462:  MOVF   xD6,W
5464:  ADDWFC 03,W
5466:  MOVWF  FEA
5468:  MOVF   FEF,W
546A:  XORWF  xDC,W
546C:  XORWF  xDA,W
546E:  MOVFF  7E1,FEA
5472:  MOVFF  01,FE9
5476:  MOVWF  FEF
....................           } 
5478:  INCF   xDF,F
547A:  BRA    517E
....................     } 
....................      
....................     if (dir != 0)  
547C:  MOVF   xD9,F
547E:  BTFSC  FD8.2
5480:  BRA    569C
....................     { 
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
5482:  MOVLW  0D
5484:  ADDWF  xD5,W
5486:  MOVWF  FE9
5488:  MOVLW  00
548A:  ADDWFC xD6,W
548C:  MOVWF  FEA
548E:  MOVFF  FEF,7DA
....................       state[13] = state[9]; 
5492:  MOVLW  0D
5494:  ADDWF  xD5,W
5496:  MOVWF  01
5498:  MOVLW  00
549A:  ADDWFC xD6,W
549C:  MOVWF  03
549E:  MOVLW  09
54A0:  ADDWF  xD5,W
54A2:  MOVWF  FE9
54A4:  MOVLW  00
54A6:  ADDWFC xD6,W
54A8:  MOVWF  FEA
54AA:  MOVFF  FEF,7E2
54AE:  MOVFF  03,FEA
54B2:  MOVFF  01,FE9
54B6:  MOVFF  7E2,FEF
....................       state[9] = state[5]; 
54BA:  MOVLW  09
54BC:  ADDWF  xD5,W
54BE:  MOVWF  01
54C0:  MOVLW  00
54C2:  ADDWFC xD6,W
54C4:  MOVWF  03
54C6:  MOVLW  05
54C8:  ADDWF  xD5,W
54CA:  MOVWF  FE9
54CC:  MOVLW  00
54CE:  ADDWFC xD6,W
54D0:  MOVWF  FEA
54D2:  MOVFF  FEF,7E2
54D6:  MOVFF  03,FEA
54DA:  MOVFF  01,FE9
54DE:  MOVFF  7E2,FEF
....................       state[5] = state[1]; 
54E2:  MOVLW  05
54E4:  ADDWF  xD5,W
54E6:  MOVWF  01
54E8:  MOVLW  00
54EA:  ADDWFC xD6,W
54EC:  MOVWF  03
54EE:  MOVLW  01
54F0:  ADDWF  xD5,W
54F2:  MOVWF  FE9
54F4:  MOVLW  00
54F6:  ADDWFC xD6,W
54F8:  MOVWF  FEA
54FA:  MOVFF  FEF,7E2
54FE:  MOVFF  03,FEA
5502:  MOVFF  01,FE9
5506:  MOVFF  7E2,FEF
....................       state[1] = buf1; 
550A:  MOVLW  01
550C:  ADDWF  xD5,W
550E:  MOVWF  FE9
5510:  MOVLW  00
5512:  ADDWFC xD6,W
5514:  MOVWF  FEA
5516:  MOVFF  7DA,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
551A:  MOVLW  0A
551C:  ADDWF  xD5,W
551E:  MOVWF  FE9
5520:  MOVLW  00
5522:  ADDWFC xD6,W
5524:  MOVWF  FEA
5526:  MOVFF  FEF,7DA
....................       buf2 = state[14]; 
552A:  MOVLW  0E
552C:  ADDWF  xD5,W
552E:  MOVWF  FE9
5530:  MOVLW  00
5532:  ADDWFC xD6,W
5534:  MOVWF  FEA
5536:  MOVFF  FEF,7DB
....................       state[10] = state[2]; 
553A:  MOVLW  0A
553C:  ADDWF  xD5,W
553E:  MOVWF  01
5540:  MOVLW  00
5542:  ADDWFC xD6,W
5544:  MOVWF  03
5546:  MOVLW  02
5548:  ADDWF  xD5,W
554A:  MOVWF  FE9
554C:  MOVLW  00
554E:  ADDWFC xD6,W
5550:  MOVWF  FEA
5552:  MOVFF  FEF,7E2
5556:  MOVFF  03,FEA
555A:  MOVFF  01,FE9
555E:  MOVFF  7E2,FEF
....................       state[14] = state[6]; 
5562:  MOVLW  0E
5564:  ADDWF  xD5,W
5566:  MOVWF  01
5568:  MOVLW  00
556A:  ADDWFC xD6,W
556C:  MOVWF  03
556E:  MOVLW  06
5570:  ADDWF  xD5,W
5572:  MOVWF  FE9
5574:  MOVLW  00
5576:  ADDWFC xD6,W
5578:  MOVWF  FEA
557A:  MOVFF  FEF,7E2
557E:  MOVFF  03,FEA
5582:  MOVFF  01,FE9
5586:  MOVFF  7E2,FEF
....................       state[2] = buf1; 
558A:  MOVLW  02
558C:  ADDWF  xD5,W
558E:  MOVWF  FE9
5590:  MOVLW  00
5592:  ADDWFC xD6,W
5594:  MOVWF  FEA
5596:  MOVFF  7DA,FEF
....................       state[6] = buf2; 
559A:  MOVLW  06
559C:  ADDWF  xD5,W
559E:  MOVWF  FE9
55A0:  MOVLW  00
55A2:  ADDWFC xD6,W
55A4:  MOVWF  FEA
55A6:  MOVFF  7DB,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
55AA:  MOVLW  03
55AC:  ADDWF  xD5,W
55AE:  MOVWF  FE9
55B0:  MOVLW  00
55B2:  ADDWFC xD6,W
55B4:  MOVWF  FEA
55B6:  MOVFF  FEF,7DA
....................       state[3] = state[7]; 
55BA:  MOVLW  03
55BC:  ADDWF  xD5,W
55BE:  MOVWF  01
55C0:  MOVLW  00
55C2:  ADDWFC xD6,W
55C4:  MOVWF  03
55C6:  MOVLW  07
55C8:  ADDWF  xD5,W
55CA:  MOVWF  FE9
55CC:  MOVLW  00
55CE:  ADDWFC xD6,W
55D0:  MOVWF  FEA
55D2:  MOVFF  FEF,7E2
55D6:  MOVFF  03,FEA
55DA:  MOVFF  01,FE9
55DE:  MOVFF  7E2,FEF
....................       state[7] = state[11]; 
55E2:  MOVLW  07
55E4:  ADDWF  xD5,W
55E6:  MOVWF  01
55E8:  MOVLW  00
55EA:  ADDWFC xD6,W
55EC:  MOVWF  03
55EE:  MOVLW  0B
55F0:  ADDWF  xD5,W
55F2:  MOVWF  FE9
55F4:  MOVLW  00
55F6:  ADDWFC xD6,W
55F8:  MOVWF  FEA
55FA:  MOVFF  FEF,7E2
55FE:  MOVFF  03,FEA
5602:  MOVFF  01,FE9
5606:  MOVFF  7E2,FEF
....................       state[11] = state[15]; 
560A:  MOVLW  0B
560C:  ADDWF  xD5,W
560E:  MOVWF  01
5610:  MOVLW  00
5612:  ADDWFC xD6,W
5614:  MOVWF  03
5616:  MOVLW  0F
5618:  ADDWF  xD5,W
561A:  MOVWF  FE9
561C:  MOVLW  00
561E:  ADDWFC xD6,W
5620:  MOVWF  FEA
5622:  MOVFF  FEF,7E2
5626:  MOVFF  03,FEA
562A:  MOVFF  01,FE9
562E:  MOVFF  7E2,FEF
....................       state[15] = buf1;          
5632:  MOVLW  0F
5634:  ADDWF  xD5,W
5636:  MOVWF  FE9
5638:  MOVLW  00
563A:  ADDWFC xD6,W
563C:  MOVWF  FEA
563E:  MOVFF  7DA,FEF
....................             
....................       for (i = 0; i <16; i++){ 
5642:  CLRF   xDF
5644:  MOVF   xDF,W
5646:  SUBLW  0F
5648:  BNC   569A
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
564A:  CLRF   03
564C:  MOVF   xDF,W
564E:  ADDWF  xD5,W
5650:  MOVWF  01
5652:  MOVF   xD6,W
5654:  ADDWFC 03,F
5656:  MOVFF  01,7E0
565A:  MOVFF  03,7E1
565E:  CLRF   03
5660:  MOVF   xDF,W
5662:  ADDWF  xD5,W
5664:  MOVWF  FE9
5666:  MOVF   xD6,W
5668:  ADDWFC 03,W
566A:  MOVWF  FEA
566C:  CLRF   03
566E:  MOVF   FEF,W
5670:  MOVLB  0
5672:  CALL   01E0
5676:  MOVLB  7
5678:  MOVWF  xE2
567A:  CLRF   03
567C:  MOVF   xDF,W
567E:  ADDWF  xD7,W
5680:  MOVWF  FE9
5682:  MOVF   xD8,W
5684:  ADDWFC 03,W
5686:  MOVWF  FEA
5688:  MOVF   FEF,W
568A:  XORWF  xE2,W
568C:  MOVFF  7E1,FEA
5690:  MOVFF  7E0,FE9
5694:  MOVWF  FEF
....................       }  
5696:  INCF   xDF,F
5698:  BRA    5644
....................     }  
....................     else  
569A:  BRA    580E
....................     { 
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
569C:  MOVFF  7D7,01
56A0:  MOVFF  7D8,03
56A4:  MOVFF  7D7,7E0
56A8:  MOVFF  7D8,7E1
56AC:  MOVLW  0D
56AE:  ADDWF  xD7,W
56B0:  MOVWF  FE9
56B2:  MOVLW  00
56B4:  ADDWFC xD8,W
56B6:  MOVWF  FEA
56B8:  CLRF   03
56BA:  MOVF   FEF,W
56BC:  MOVLB  0
56BE:  CALL   00D0
56C2:  MOVLB  7
56C4:  MOVWF  xE2
56C6:  MOVFF  7D7,FE9
56CA:  MOVFF  7D8,FEA
56CE:  MOVF   FEF,W
56D0:  XORWF  xE2,F
56D2:  CLRF   03
56D4:  MOVF   xDE,W
56D6:  MOVLB  0
56D8:  CALL   02F0
56DC:  MOVWF  01
56DE:  MOVLB  7
56E0:  MOVF   xE2,W
56E2:  XORWF  01,W
56E4:  MOVFF  7E1,FEA
56E8:  MOVFF  7E0,FE9
56EC:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
56EE:  MOVLW  01
56F0:  ADDWF  xD7,W
56F2:  MOVWF  01
56F4:  MOVLW  00
56F6:  ADDWFC xD8,W
56F8:  MOVWF  03
56FA:  MOVFF  01,7E0
56FE:  MOVWF  xE1
5700:  MOVLW  0E
5702:  ADDWF  xD7,W
5704:  MOVWF  FE9
5706:  MOVLW  00
5708:  ADDWFC xD8,W
570A:  MOVWF  FEA
570C:  CLRF   03
570E:  MOVF   FEF,W
5710:  MOVLB  0
5712:  CALL   00D0
5716:  MOVLB  7
5718:  MOVWF  xE2
571A:  MOVLW  01
571C:  ADDWF  xD7,W
571E:  MOVWF  FE9
5720:  MOVLW  00
5722:  ADDWFC xD8,W
5724:  MOVWF  FEA
5726:  MOVF   FEF,W
5728:  XORWF  xE2,W
572A:  MOVFF  7E1,FEA
572E:  MOVFF  7E0,FE9
5732:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
5734:  MOVLW  02
5736:  ADDWF  xD7,W
5738:  MOVWF  01
573A:  MOVLW  00
573C:  ADDWFC xD8,W
573E:  MOVWF  03
5740:  MOVFF  01,7E0
5744:  MOVWF  xE1
5746:  MOVLW  0F
5748:  ADDWF  xD7,W
574A:  MOVWF  FE9
574C:  MOVLW  00
574E:  ADDWFC xD8,W
5750:  MOVWF  FEA
5752:  CLRF   03
5754:  MOVF   FEF,W
5756:  MOVLB  0
5758:  CALL   00D0
575C:  MOVLB  7
575E:  MOVWF  xE2
5760:  MOVLW  02
5762:  ADDWF  xD7,W
5764:  MOVWF  FE9
5766:  MOVLW  00
5768:  ADDWFC xD8,W
576A:  MOVWF  FEA
576C:  MOVF   FEF,W
576E:  XORWF  xE2,W
5770:  MOVFF  7E1,FEA
5774:  MOVFF  7E0,FE9
5778:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
577A:  MOVLW  03
577C:  ADDWF  xD7,W
577E:  MOVWF  01
5780:  MOVLW  00
5782:  ADDWFC xD8,W
5784:  MOVWF  03
5786:  MOVFF  01,7E0
578A:  MOVWF  xE1
578C:  MOVLW  0C
578E:  ADDWF  xD7,W
5790:  MOVWF  FE9
5792:  MOVLW  00
5794:  ADDWFC xD8,W
5796:  MOVWF  FEA
5798:  CLRF   03
579A:  MOVF   FEF,W
579C:  MOVLB  0
579E:  CALL   00D0
57A2:  MOVLB  7
57A4:  MOVWF  xE2
57A6:  MOVLW  03
57A8:  ADDWF  xD7,W
57AA:  MOVWF  FE9
57AC:  MOVLW  00
57AE:  ADDWFC xD8,W
57B0:  MOVWF  FEA
57B2:  MOVF   FEF,W
57B4:  XORWF  xE2,W
57B6:  MOVFF  7E1,FEA
57BA:  MOVFF  7E0,FE9
57BE:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
57C0:  MOVLW  04
57C2:  MOVWF  xDF
57C4:  MOVF   xDF,W
57C6:  SUBLW  0F
57C8:  BNC   580E
....................         key[i] = key[i] ^ key[i-4]; 
57CA:  CLRF   03
57CC:  MOVF   xDF,W
57CE:  ADDWF  xD7,W
57D0:  MOVWF  01
57D2:  MOVF   xD8,W
57D4:  ADDWFC 03,F
57D6:  MOVFF  03,7E1
57DA:  CLRF   03
57DC:  MOVF   xDF,W
57DE:  ADDWF  xD7,W
57E0:  MOVWF  FE9
57E2:  MOVF   xD8,W
57E4:  ADDWFC 03,W
57E6:  MOVWF  FEA
57E8:  MOVFF  FEF,7E2
57EC:  MOVLW  04
57EE:  SUBWF  xDF,W
57F0:  CLRF   03
57F2:  ADDWF  xD7,W
57F4:  MOVWF  FE9
57F6:  MOVF   xD8,W
57F8:  ADDWFC 03,W
57FA:  MOVWF  FEA
57FC:  MOVF   FEF,W
57FE:  XORWF  xE2,W
5800:  MOVFF  7E1,FEA
5804:  MOVFF  01,FE9
5808:  MOVWF  FEF
....................       } 
580A:  INCF   xDF,F
580C:  BRA    57C4
....................     } 
....................   } 
580E:  INCF   xDE,F
5810:  GOTO   4DC6
....................   if (dir == 0)  
5814:  MOVF   xD9,F
5816:  BNZ   5862
....................   { 
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
5818:  CLRF   xDF
581A:  MOVF   xDF,W
581C:  SUBLW  0F
581E:  BNC   5862
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
5820:  CLRF   03
5822:  MOVF   xDF,W
5824:  ADDWF  xD5,W
5826:  MOVWF  01
5828:  MOVF   xD6,W
582A:  ADDWFC 03,F
582C:  MOVFF  03,7E1
5830:  CLRF   03
5832:  MOVF   xDF,W
5834:  ADDWF  xD5,W
5836:  MOVWF  FE9
5838:  MOVF   xD6,W
583A:  ADDWFC 03,W
583C:  MOVWF  FEA
583E:  MOVFF  FEF,7E2
5842:  CLRF   03
5844:  MOVF   xDF,W
5846:  ADDWF  xD7,W
5848:  MOVWF  FE9
584A:  MOVF   xD8,W
584C:  ADDWFC 03,W
584E:  MOVWF  FEA
5850:  MOVF   FEF,W
5852:  XORWF  xE2,W
5854:  MOVFF  7E1,FEA
5858:  MOVFF  01,FE9
585C:  MOVWF  FEF
....................     } // enf for 
585E:  INCF   xDF,F
5860:  BRA    581A
....................   } // end if (!dir) 
.................... } // end function 
5862:  MOVLB  0
5864:  RETURN 0
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... int8 type_KB=0; 
.................... #define key_numbyte  12 
....................  
.................... int8 key_data[key_numbyte]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
207E:  MOVLB  1
2080:  INCF   x62,F
2082:  MOVF   x62,W
2084:  SUBLW  01
2086:  BTFSC  FD8.0
2088:  BRA    222E
....................        switch (col) { 
208A:  MOVF   x65,W
208C:  ADDLW  FB
208E:  BC    2112
2090:  ADDLW  05
2092:  MOVLB  0
2094:  GOTO   2238
....................          case 0   :  
....................                     output_low(COL0); 
2098:  BCF    F92.5
209A:  BCF    F89.5
....................                     output_high(COL1); 
209C:  BCF    F92.3
209E:  BSF    F89.3
....................                     output_high(COL2); 
20A0:  BCF    F92.2
20A2:  BSF    F89.2
....................                     output_high(COL3); 
20A4:  BCF    F92.1
20A6:  BSF    F89.1
....................                     output_high(COL4); 
20A8:  BCF    F92.0
20AA:  BSF    F89.0
....................                     break; 
20AC:  MOVLB  1
20AE:  BRA    2112
....................          case 1   :  
....................                     output_low(COL1); 
20B0:  BCF    F92.3
20B2:  BCF    F89.3
....................                     output_high(COL0); 
20B4:  BCF    F92.5
20B6:  BSF    F89.5
....................                     output_high(COL2); 
20B8:  BCF    F92.2
20BA:  BSF    F89.2
....................                     output_high(COL3); 
20BC:  BCF    F92.1
20BE:  BSF    F89.1
....................                     output_high(COL4); 
20C0:  BCF    F92.0
20C2:  BSF    F89.0
....................                     break; 
20C4:  MOVLB  1
20C6:  BRA    2112
....................          case 2   :  
....................                     output_low(COL2); 
20C8:  BCF    F92.2
20CA:  BCF    F89.2
....................                     output_high(COL1); 
20CC:  BCF    F92.3
20CE:  BSF    F89.3
....................                     output_high(COL0); 
20D0:  BCF    F92.5
20D2:  BSF    F89.5
....................                     output_high(COL3); 
20D4:  BCF    F92.1
20D6:  BSF    F89.1
....................                     output_high(COL4); 
20D8:  BCF    F92.0
20DA:  BSF    F89.0
....................                     break; 
20DC:  MOVLB  1
20DE:  BRA    2112
....................          case 3   :  
....................                     output_low(COL3); 
20E0:  BCF    F92.1
20E2:  BCF    F89.1
....................                     output_high(COL1); 
20E4:  BCF    F92.3
20E6:  BSF    F89.3
....................                     output_high(COL2); 
20E8:  BCF    F92.2
20EA:  BSF    F89.2
....................                     output_high(COL0); 
20EC:  BCF    F92.5
20EE:  BSF    F89.5
....................                     output_high(COL4); 
20F0:  BCF    F92.0
20F2:  BSF    F89.0
....................                     break; 
20F4:  MOVLB  1
20F6:  BRA    2112
....................          case 4   :  
....................                     output_low(COL4); 
20F8:  BCF    F92.0
20FA:  BCF    F89.0
....................                     output_high(COL1); 
20FC:  BCF    F92.3
20FE:  BSF    F89.3
....................                     output_high(COL2); 
2100:  BCF    F92.2
2102:  BSF    F89.2
....................                     output_high(COL3); 
2104:  BCF    F92.1
2106:  BSF    F89.1
....................                     output_high(COL0); 
2108:  BCF    F92.5
210A:  BSF    F89.5
....................                     break; 
210C:  MOVLB  1
210E:  BRA    2112
2110:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2112:  BTFSS  x63.0
2114:  BRA    2194
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2116:  BSF    F93.4
2118:  MOVLW  00
211A:  BTFSC  F81.4
211C:  MOVLW  01
211E:  MOVLB  8
2120:  MOVWF  x31
2122:  BSF    F93.5
2124:  MOVLW  00
2126:  BTFSC  F81.5
2128:  MOVLW  01
212A:  ANDWF  x31,F
212C:  BSF    F93.6
212E:  MOVLW  00
2130:  BTFSC  F81.6
2132:  MOVLW  01
2134:  ANDWF  x31,F
2136:  BSF    F93.7
2138:  MOVLW  00
213A:  BTFSC  F81.7
213C:  MOVLW  01
213E:  ANDWF  x31,W
2140:  BZ    2190
....................          { 
....................             kchar=last_key; 
2142:  MOVFF  164,82F
....................             if(keydebug_en==0) 
2146:  MOVLB  1
2148:  MOVF   x4C,F
214A:  BNZ   217E
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
214C:  CLRF   x4A
214E:  CLRF   x49
....................               charac_timeout=0; 
2150:  MOVLB  0
2152:  CLRF   xFC
2154:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
2156:  MOVLB  1
2158:  MOVF   x4F,W
215A:  SUBLW  0B
215C:  BNC   2172
215E:  MOVF   x4F,W
2160:  INCF   x4F,F
2162:  CLRF   03
2164:  ADDLW  55
2166:  MOVWF  FE9
2168:  MOVLW  01
216A:  ADDWFC 03,W
216C:  MOVWF  FEA
216E:  MOVFF  82F,FEF
....................                fputc(kchar,COM2); 
2172:  MOVFF  82F,858
2176:  MOVLB  0
2178:  CALL   0694
....................             } 
....................                else fputc(kchar,COM2); 
217C:  BRA    2188
217E:  MOVFF  82F,858
2182:  MOVLB  0
2184:  CALL   0694
....................            kbd_down=FALSE; 
2188:  MOVLB  1
218A:  BCF    x63.0
....................            last_key=0; 
218C:  CLRF   x64
218E:  MOVLB  8
....................          } 
....................        } else 
2190:  BRA    222A
2192:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
2194:  BSF    F93.4
2196:  MOVLW  00
2198:  BTFSC  F81.4
219A:  MOVLW  01
219C:  MOVLB  8
219E:  MOVWF  x31
21A0:  BSF    F93.5
21A2:  MOVLW  00
21A4:  BTFSC  F81.5
21A6:  MOVLW  01
21A8:  ANDWF  x31,F
21AA:  BSF    F93.6
21AC:  MOVLW  00
21AE:  BTFSC  F81.6
21B0:  MOVLW  01
21B2:  ANDWF  x31,F
21B4:  BSF    F93.7
21B6:  MOVLW  00
21B8:  BTFSC  F81.7
21BA:  MOVLW  01
21BC:  ANDWF  x31,W
21BE:  BNZ   221E
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
21C0:  BSF    F93.4
21C2:  BTFSC  F81.4
21C4:  BRA    21CA
....................                   row=0; 
21C6:  CLRF   x30
....................                 else if(input(ROW1)==0) 
21C8:  BRA    21EC
21CA:  BSF    F93.5
21CC:  BTFSC  F81.5
21CE:  BRA    21D6
....................                   row=1; 
21D0:  MOVLW  01
21D2:  MOVWF  x30
....................                 else if(input(ROW2)==0) 
21D4:  BRA    21EC
21D6:  BSF    F93.6
21D8:  BTFSC  F81.6
21DA:  BRA    21E2
....................                   row=2; 
21DC:  MOVLW  02
21DE:  MOVWF  x30
....................                 else if(input(ROW3)==0) 
21E0:  BRA    21EC
21E2:  BSF    F93.7
21E4:  BTFSC  F81.7
21E6:  BRA    21EC
....................                   row=3; 
21E8:  MOVLW  03
21EA:  MOVWF  x30
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
21EC:  MOVF   x30,W
21EE:  MULLW  05
21F0:  MOVF   FF3,W
21F2:  CLRF   x32
21F4:  MOVWF  x31
21F6:  CLRF   03
21F8:  MOVLB  1
21FA:  MOVF   x65,W
21FC:  MOVLB  8
21FE:  ADDWF  x31,W
2200:  MOVWF  01
2202:  MOVF   x32,W
2204:  ADDWFC 03,F
2206:  MOVF   01,W
2208:  MOVLB  0
220A:  CALL   030A
220E:  MOVFF  FE8,164
....................                 kbd_down = TRUE; 
2212:  MOVLB  1
2214:  BSF    x63.0
....................                 set_tris_a(0xff); 
2216:  MOVLW  FF
2218:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
221A:  BRA    222A
221C:  MOVLB  8
....................                { 
....................                   ++col; 
221E:  MOVLB  1
2220:  INCF   x65,F
....................                   if(col==5) col=0; 
2222:  MOVF   x65,W
2224:  SUBLW  05
2226:  BTFSC  FD8.2
2228:  CLRF   x65
....................                } 
....................          } 
....................       kbd_call_count=0; 
222A:  MOVLB  1
222C:  CLRF   x62
....................    } 
....................   return(kchar); 
222E:  MOVLB  8
2230:  MOVFF  82F,01
.................... } 
2234:  MOVLB  0
2236:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
225C:  MOVLW  E0
225E:  MOVLB  F
2260:  MOVWF  x48
2262:  BCF    FC2.6
2264:  BCF    FC2.7
2266:  MOVF   x49,W
2268:  ANDLW  E0
226A:  IORLW  17
226C:  MOVWF  x49
....................    switch(col) 
....................    { 
226E:  MOVLB  8
2270:  MOVF   x4C,W
2272:  ADDLW  FA
2274:  BC    2340
2276:  ADDLW  06
2278:  MOVLB  0
227A:  GOTO   2344
....................       case 0: 
....................         set_adc_channel(4); 
227E:  MOVLW  10
2280:  MOVWF  01
2282:  MOVF   FC2,W
2284:  ANDLW  C3
2286:  IORWF  01,W
2288:  MOVWF  FC2
....................         adc=read_adc(); 
228A:  BSF    FC2.1
228C:  BTFSC  FC2.1
228E:  BRA    228C
2290:  MOVFF  FC4,84D
....................         return adc; 
2294:  MOVLB  8
2296:  MOVFF  84D,01
229A:  BRA    2340
....................       break; 
229C:  BRA    2340
....................       case 1: 
....................         set_adc_channel(3); 
229E:  MOVLW  0C
22A0:  MOVWF  01
22A2:  MOVF   FC2,W
22A4:  ANDLW  C3
22A6:  IORWF  01,W
22A8:  MOVWF  FC2
....................         adc=read_adc(); 
22AA:  BSF    FC2.1
22AC:  BTFSC  FC2.1
22AE:  BRA    22AC
22B0:  MOVFF  FC4,84D
....................         return adc; 
22B4:  MOVLB  8
22B6:  MOVFF  84D,01
22BA:  BRA    2340
....................       break; 
22BC:  BRA    2340
....................       case 2: 
....................         set_adc_channel(2); 
22BE:  MOVLW  08
22C0:  MOVWF  01
22C2:  MOVF   FC2,W
22C4:  ANDLW  C3
22C6:  IORWF  01,W
22C8:  MOVWF  FC2
....................         adc=read_adc(); 
22CA:  BSF    FC2.1
22CC:  BTFSC  FC2.1
22CE:  BRA    22CC
22D0:  MOVFF  FC4,84D
....................         return adc; 
22D4:  MOVLB  8
22D6:  MOVFF  84D,01
22DA:  BRA    2340
....................       break; 
22DC:  BRA    2340
....................       case 3: 
....................         set_adc_channel(1); 
22DE:  MOVLW  04
22E0:  MOVWF  01
22E2:  MOVF   FC2,W
22E4:  ANDLW  C3
22E6:  IORWF  01,W
22E8:  MOVWF  FC2
....................         adc=read_adc(); 
22EA:  BSF    FC2.1
22EC:  BTFSC  FC2.1
22EE:  BRA    22EC
22F0:  MOVFF  FC4,84D
....................         return adc; 
22F4:  MOVLB  8
22F6:  MOVFF  84D,01
22FA:  BRA    2340
....................       break; 
22FC:  BRA    2340
....................       case 4: 
....................         set_adc_channel(0); 
22FE:  MOVLW  00
2300:  MOVWF  01
2302:  MOVF   FC2,W
2304:  ANDLW  C3
2306:  IORWF  01,W
2308:  MOVWF  FC2
....................         adc=read_adc(); 
230A:  BSF    FC2.1
230C:  BTFSC  FC2.1
230E:  BRA    230C
2310:  MOVFF  FC4,84D
....................         return adc; 
2314:  MOVLB  8
2316:  MOVFF  84D,01
231A:  BRA    2340
....................       break;      
231C:  BRA    2340
....................       case 5: 
....................         set_adc_channel(11); 
231E:  MOVLW  2C
2320:  MOVWF  01
2322:  MOVF   FC2,W
2324:  ANDLW  C3
2326:  IORWF  01,W
2328:  MOVWF  FC2
....................         adc=read_adc(); 
232A:  BSF    FC2.1
232C:  BTFSC  FC2.1
232E:  BRA    232C
2330:  MOVFF  FC4,84D
....................         return adc; 
2334:  MOVLB  8
2336:  MOVFF  84D,01
233A:  BRA    2340
....................       break;      
233C:  BRA    2340
233E:  MOVLB  8
....................    } 
.................... } 
2340:  MOVLB  0
2342:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
24BE:  MOVLB  8
24C0:  CLRF   x37
24C2:  CLRF   x36
24C4:  CLRF   x35
24C6:  CLRF   x34
24C8:  CLRF   x3B
24CA:  CLRF   x3A
24CC:  CLRF   x39
24CE:  CLRF   x38
24D0:  CLRF   x3F
24D2:  CLRF   x3E
24D4:  CLRF   x3D
24D6:  CLRF   x3C
24D8:  CLRF   x43
24DA:  CLRF   x42
24DC:  CLRF   x41
24DE:  CLRF   x40
24E0:  CLRF   x47
24E2:  CLRF   x46
24E4:  CLRF   x45
24E6:  CLRF   x44
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
24E8:  CLRF   x33
24EA:  CLRF   x32
24EC:  MOVF   x33,W
24EE:  SUBLW  01
24F0:  BNC   256E
24F2:  BNZ   24FA
24F4:  MOVF   x32,W
24F6:  SUBLW  F3
24F8:  BNC   256E
....................    { 
....................       col_0=read_col(0)+col_0; 
24FA:  CLRF   x4C
24FC:  MOVLB  0
24FE:  RCALL  225C
2500:  MOVF   01,W
2502:  MOVLB  8
2504:  ADDWF  x34,F
2506:  MOVLW  00
2508:  ADDWFC x35,F
250A:  ADDWFC x36,F
250C:  ADDWFC x37,F
....................       col_1=read_col(1)+col_1; 
250E:  MOVLW  01
2510:  MOVWF  x4C
2512:  MOVLB  0
2514:  RCALL  225C
2516:  MOVF   01,W
2518:  MOVLB  8
251A:  ADDWF  x38,F
251C:  MOVLW  00
251E:  ADDWFC x39,F
2520:  ADDWFC x3A,F
2522:  ADDWFC x3B,F
....................       col_2=read_col(2)+col_2; 
2524:  MOVLW  02
2526:  MOVWF  x4C
2528:  MOVLB  0
252A:  RCALL  225C
252C:  MOVF   01,W
252E:  MOVLB  8
2530:  ADDWF  x3C,F
2532:  MOVLW  00
2534:  ADDWFC x3D,F
2536:  ADDWFC x3E,F
2538:  ADDWFC x3F,F
....................       col_3=read_col(3)+col_3; 
253A:  MOVLW  03
253C:  MOVWF  x4C
253E:  MOVLB  0
2540:  RCALL  225C
2542:  MOVF   01,W
2544:  MOVLB  8
2546:  ADDWF  x40,F
2548:  MOVLW  00
254A:  ADDWFC x41,F
254C:  ADDWFC x42,F
254E:  ADDWFC x43,F
....................       col_4=read_col(4)+col_4; 
2550:  MOVLW  04
2552:  MOVWF  x4C
2554:  MOVLB  0
2556:  RCALL  225C
2558:  MOVF   01,W
255A:  MOVLB  8
255C:  ADDWF  x44,F
255E:  MOVLW  00
2560:  ADDWFC x45,F
2562:  ADDWFC x46,F
2564:  ADDWFC x47,F
....................    } 
2566:  INCF   x32,F
2568:  BTFSC  FD8.2
256A:  INCF   x33,F
256C:  BRA    24EC
....................    col_0=col_0/500; 
256E:  BCF    FD8.1
2570:  MOVFF  837,85B
2574:  MOVFF  836,85A
2578:  MOVFF  835,859
257C:  MOVFF  834,858
2580:  CLRF   x5F
2582:  CLRF   x5E
2584:  MOVLW  01
2586:  MOVWF  x5D
2588:  MOVLW  F4
258A:  MOVWF  x5C
258C:  MOVLB  0
258E:  RCALL  236A
2590:  MOVFF  03,837
2594:  MOVFF  02,836
2598:  MOVFF  01,835
259C:  MOVFF  00,834
....................    col_1=col_1/500; 
25A0:  BCF    FD8.1
25A2:  MOVFF  83B,85B
25A6:  MOVFF  83A,85A
25AA:  MOVFF  839,859
25AE:  MOVFF  838,858
25B2:  MOVLB  8
25B4:  CLRF   x5F
25B6:  CLRF   x5E
25B8:  MOVLW  01
25BA:  MOVWF  x5D
25BC:  MOVLW  F4
25BE:  MOVWF  x5C
25C0:  MOVLB  0
25C2:  RCALL  236A
25C4:  MOVFF  03,83B
25C8:  MOVFF  02,83A
25CC:  MOVFF  01,839
25D0:  MOVFF  00,838
....................    col_2=col_2/500; 
25D4:  BCF    FD8.1
25D6:  MOVFF  83F,85B
25DA:  MOVFF  83E,85A
25DE:  MOVFF  83D,859
25E2:  MOVFF  83C,858
25E6:  MOVLB  8
25E8:  CLRF   x5F
25EA:  CLRF   x5E
25EC:  MOVLW  01
25EE:  MOVWF  x5D
25F0:  MOVLW  F4
25F2:  MOVWF  x5C
25F4:  MOVLB  0
25F6:  RCALL  236A
25F8:  MOVFF  03,83F
25FC:  MOVFF  02,83E
2600:  MOVFF  01,83D
2604:  MOVFF  00,83C
....................    col_3=col_3/500; 
2608:  BCF    FD8.1
260A:  MOVFF  843,85B
260E:  MOVFF  842,85A
2612:  MOVFF  841,859
2616:  MOVFF  840,858
261A:  MOVLB  8
261C:  CLRF   x5F
261E:  CLRF   x5E
2620:  MOVLW  01
2622:  MOVWF  x5D
2624:  MOVLW  F4
2626:  MOVWF  x5C
2628:  MOVLB  0
262A:  RCALL  236A
262C:  MOVFF  03,843
2630:  MOVFF  02,842
2634:  MOVFF  01,841
2638:  MOVFF  00,840
....................    col_4=col_4/500; 
263C:  BCF    FD8.1
263E:  MOVFF  847,85B
2642:  MOVFF  846,85A
2646:  MOVFF  845,859
264A:  MOVFF  844,858
264E:  MOVLB  8
2650:  CLRF   x5F
2652:  CLRF   x5E
2654:  MOVLW  01
2656:  MOVWF  x5D
2658:  MOVLW  F4
265A:  MOVWF  x5C
265C:  MOVLB  0
265E:  RCALL  236A
2660:  MOVFF  03,847
2664:  MOVFF  02,846
2668:  MOVFF  01,845
266C:  MOVFF  00,844
....................    if(keydebug_en) 
2670:  MOVLB  1
2672:  MOVF   x4C,F
2674:  BTFSC  FD8.2
2676:  BRA    27F2
....................    { 
....................       fprintf(COM2,"\r\n");      
2678:  MOVLW  0D
267A:  MOVLB  8
267C:  MOVWF  x58
267E:  MOVLB  0
2680:  CALL   0694
2684:  MOVLW  0A
2686:  MOVLB  8
2688:  MOVWF  x58
268A:  MOVLB  0
268C:  CALL   0694
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2690:  MOVLW  EA
2692:  MOVWF  FF6
2694:  MOVLW  04
2696:  MOVWF  FF7
2698:  MOVLW  07
269A:  MOVLB  8
269C:  MOVWF  x4C
269E:  MOVLB  0
26A0:  CALL   1652
26A4:  MOVLW  41
26A6:  MOVWF  FE9
26A8:  MOVFF  837,84F
26AC:  MOVFF  836,84E
26B0:  MOVFF  835,84D
26B4:  MOVFF  834,84C
26B8:  RCALL  23FE
26BA:  MOVLW  0D
26BC:  MOVLB  8
26BE:  MOVWF  x58
26C0:  MOVLB  0
26C2:  CALL   0694
26C6:  MOVLW  0A
26C8:  MOVLB  8
26CA:  MOVWF  x58
26CC:  MOVLB  0
26CE:  CALL   0694
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
26D2:  MOVLW  F8
26D4:  MOVWF  FF6
26D6:  MOVLW  04
26D8:  MOVWF  FF7
26DA:  MOVLW  07
26DC:  MOVLB  8
26DE:  MOVWF  x4C
26E0:  MOVLB  0
26E2:  CALL   1652
26E6:  MOVLW  41
26E8:  MOVWF  FE9
26EA:  MOVFF  83B,84F
26EE:  MOVFF  83A,84E
26F2:  MOVFF  839,84D
26F6:  MOVFF  838,84C
26FA:  RCALL  23FE
26FC:  MOVLW  0D
26FE:  MOVLB  8
2700:  MOVWF  x58
2702:  MOVLB  0
2704:  CALL   0694
2708:  MOVLW  0A
270A:  MOVLB  8
270C:  MOVWF  x58
270E:  MOVLB  0
2710:  CALL   0694
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2714:  MOVLW  06
2716:  MOVWF  FF6
2718:  MOVLW  05
271A:  MOVWF  FF7
271C:  MOVLW  07
271E:  MOVLB  8
2720:  MOVWF  x4C
2722:  MOVLB  0
2724:  CALL   1652
2728:  MOVLW  41
272A:  MOVWF  FE9
272C:  MOVFF  83F,84F
2730:  MOVFF  83E,84E
2734:  MOVFF  83D,84D
2738:  MOVFF  83C,84C
273C:  RCALL  23FE
273E:  MOVLW  0D
2740:  MOVLB  8
2742:  MOVWF  x58
2744:  MOVLB  0
2746:  CALL   0694
274A:  MOVLW  0A
274C:  MOVLB  8
274E:  MOVWF  x58
2750:  MOVLB  0
2752:  CALL   0694
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2756:  MOVLW  14
2758:  MOVWF  FF6
275A:  MOVLW  05
275C:  MOVWF  FF7
275E:  MOVLW  07
2760:  MOVLB  8
2762:  MOVWF  x4C
2764:  MOVLB  0
2766:  CALL   1652
276A:  MOVLW  41
276C:  MOVWF  FE9
276E:  MOVFF  843,84F
2772:  MOVFF  842,84E
2776:  MOVFF  841,84D
277A:  MOVFF  840,84C
277E:  RCALL  23FE
2780:  MOVLW  0D
2782:  MOVLB  8
2784:  MOVWF  x58
2786:  MOVLB  0
2788:  CALL   0694
278C:  MOVLW  0A
278E:  MOVLB  8
2790:  MOVWF  x58
2792:  MOVLB  0
2794:  CALL   0694
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2798:  MOVLW  22
279A:  MOVWF  FF6
279C:  MOVLW  05
279E:  MOVWF  FF7
27A0:  MOVLW  07
27A2:  MOVLB  8
27A4:  MOVWF  x4C
27A6:  MOVLB  0
27A8:  CALL   1652
27AC:  MOVLW  41
27AE:  MOVWF  FE9
27B0:  MOVFF  847,84F
27B4:  MOVFF  846,84E
27B8:  MOVFF  845,84D
27BC:  MOVFF  844,84C
27C0:  RCALL  23FE
27C2:  MOVLW  0D
27C4:  MOVLB  8
27C6:  MOVWF  x58
27C8:  MOVLB  0
27CA:  CALL   0694
27CE:  MOVLW  0A
27D0:  MOVLB  8
27D2:  MOVWF  x58
27D4:  MOVLB  0
27D6:  CALL   0694
....................       fprintf(COM2,"\r\n"); 
27DA:  MOVLW  0D
27DC:  MOVLB  8
27DE:  MOVWF  x58
27E0:  MOVLB  0
27E2:  CALL   0694
27E6:  MOVLW  0A
27E8:  MOVLB  8
27EA:  MOVWF  x58
27EC:  MOVLB  0
27EE:  CALL   0694
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
27F2:  MOVLB  8
27F4:  MOVF   x37,F
27F6:  BNZ   2806
27F8:  MOVF   x36,F
27FA:  BNZ   2806
27FC:  MOVF   x35,F
27FE:  BNZ   2806
2800:  MOVF   x34,W
2802:  SUBLW  05
2804:  BC    2866
2806:  MOVF   x37,F
2808:  BNZ   2866
280A:  MOVF   x36,F
280C:  BNZ   2866
280E:  MOVF   x35,F
2810:  BNZ   2866
2812:  MOVF   x34,W
2814:  SUBLW  3B
2816:  BNC   2866
2818:  MOVF   x3B,F
281A:  BNZ   282A
281C:  MOVF   x3A,F
281E:  BNZ   282A
2820:  MOVF   x39,F
2822:  BNZ   282A
2824:  MOVF   x38,W
2826:  SUBLW  64
2828:  BC    2866
282A:  MOVF   x3F,F
282C:  BNZ   283C
282E:  MOVF   x3E,F
2830:  BNZ   283C
2832:  MOVF   x3D,F
2834:  BNZ   283C
2836:  MOVF   x3C,W
2838:  SUBLW  64
283A:  BC    2866
283C:  MOVF   x43,F
283E:  BNZ   284E
2840:  MOVF   x42,F
2842:  BNZ   284E
2844:  MOVF   x41,F
2846:  BNZ   284E
2848:  MOVF   x40,W
284A:  SUBLW  64
284C:  BC    2866
284E:  MOVF   x47,F
2850:  BNZ   2860
2852:  MOVF   x46,F
2854:  BNZ   2860
2856:  MOVF   x45,F
2858:  BNZ   2860
285A:  MOVF   x44,W
285C:  SUBLW  64
285E:  BC    2866
2860:  MOVLW  00
2862:  MOVWF  01
2864:  BRA    2AE4
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
2866:  MOVF   x3B,F
2868:  BNZ   2878
286A:  MOVF   x3A,F
286C:  BNZ   2878
286E:  MOVF   x39,F
2870:  BNZ   2878
2872:  MOVF   x38,W
2874:  SUBLW  05
2876:  BC    28D8
2878:  MOVF   x3B,F
287A:  BNZ   28D8
287C:  MOVF   x3A,F
287E:  BNZ   28D8
2880:  MOVF   x39,F
2882:  BNZ   28D8
2884:  MOVF   x38,W
2886:  SUBLW  3B
2888:  BNC   28D8
288A:  MOVF   x37,F
288C:  BNZ   289C
288E:  MOVF   x36,F
2890:  BNZ   289C
2892:  MOVF   x35,F
2894:  BNZ   289C
2896:  MOVF   x34,W
2898:  SUBLW  64
289A:  BC    28D8
289C:  MOVF   x3F,F
289E:  BNZ   28AE
28A0:  MOVF   x3E,F
28A2:  BNZ   28AE
28A4:  MOVF   x3D,F
28A6:  BNZ   28AE
28A8:  MOVF   x3C,W
28AA:  SUBLW  64
28AC:  BC    28D8
28AE:  MOVF   x43,F
28B0:  BNZ   28C0
28B2:  MOVF   x42,F
28B4:  BNZ   28C0
28B6:  MOVF   x41,F
28B8:  BNZ   28C0
28BA:  MOVF   x40,W
28BC:  SUBLW  64
28BE:  BC    28D8
28C0:  MOVF   x47,F
28C2:  BNZ   28D2
28C4:  MOVF   x46,F
28C6:  BNZ   28D2
28C8:  MOVF   x45,F
28CA:  BNZ   28D2
28CC:  MOVF   x44,W
28CE:  SUBLW  64
28D0:  BC    28D8
28D2:  MOVLW  01
28D4:  MOVWF  01
28D6:  BRA    2AE4
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
28D8:  MOVF   x3F,F
28DA:  BNZ   28EA
28DC:  MOVF   x3E,F
28DE:  BNZ   28EA
28E0:  MOVF   x3D,F
28E2:  BNZ   28EA
28E4:  MOVF   x3C,W
28E6:  SUBLW  05
28E8:  BC    294A
28EA:  MOVF   x3F,F
28EC:  BNZ   294A
28EE:  MOVF   x3E,F
28F0:  BNZ   294A
28F2:  MOVF   x3D,F
28F4:  BNZ   294A
28F6:  MOVF   x3C,W
28F8:  SUBLW  3B
28FA:  BNC   294A
28FC:  MOVF   x3B,F
28FE:  BNZ   290E
2900:  MOVF   x3A,F
2902:  BNZ   290E
2904:  MOVF   x39,F
2906:  BNZ   290E
2908:  MOVF   x38,W
290A:  SUBLW  64
290C:  BC    294A
290E:  MOVF   x37,F
2910:  BNZ   2920
2912:  MOVF   x36,F
2914:  BNZ   2920
2916:  MOVF   x35,F
2918:  BNZ   2920
291A:  MOVF   x34,W
291C:  SUBLW  64
291E:  BC    294A
2920:  MOVF   x43,F
2922:  BNZ   2932
2924:  MOVF   x42,F
2926:  BNZ   2932
2928:  MOVF   x41,F
292A:  BNZ   2932
292C:  MOVF   x40,W
292E:  SUBLW  64
2930:  BC    294A
2932:  MOVF   x47,F
2934:  BNZ   2944
2936:  MOVF   x46,F
2938:  BNZ   2944
293A:  MOVF   x45,F
293C:  BNZ   2944
293E:  MOVF   x44,W
2940:  SUBLW  64
2942:  BC    294A
2944:  MOVLW  02
2946:  MOVWF  01
2948:  BRA    2AE4
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
294A:  MOVF   x43,F
294C:  BNZ   295C
294E:  MOVF   x42,F
2950:  BNZ   295C
2952:  MOVF   x41,F
2954:  BNZ   295C
2956:  MOVF   x40,W
2958:  SUBLW  05
295A:  BC    29BC
295C:  MOVF   x43,F
295E:  BNZ   29BC
2960:  MOVF   x42,F
2962:  BNZ   29BC
2964:  MOVF   x41,F
2966:  BNZ   29BC
2968:  MOVF   x40,W
296A:  SUBLW  3B
296C:  BNC   29BC
296E:  MOVF   x3B,F
2970:  BNZ   2980
2972:  MOVF   x3A,F
2974:  BNZ   2980
2976:  MOVF   x39,F
2978:  BNZ   2980
297A:  MOVF   x38,W
297C:  SUBLW  64
297E:  BC    29BC
2980:  MOVF   x3F,F
2982:  BNZ   2992
2984:  MOVF   x3E,F
2986:  BNZ   2992
2988:  MOVF   x3D,F
298A:  BNZ   2992
298C:  MOVF   x3C,W
298E:  SUBLW  64
2990:  BC    29BC
2992:  MOVF   x37,F
2994:  BNZ   29A4
2996:  MOVF   x36,F
2998:  BNZ   29A4
299A:  MOVF   x35,F
299C:  BNZ   29A4
299E:  MOVF   x34,W
29A0:  SUBLW  64
29A2:  BC    29BC
29A4:  MOVF   x47,F
29A6:  BNZ   29B6
29A8:  MOVF   x46,F
29AA:  BNZ   29B6
29AC:  MOVF   x45,F
29AE:  BNZ   29B6
29B0:  MOVF   x44,W
29B2:  SUBLW  64
29B4:  BC    29BC
29B6:  MOVLW  03
29B8:  MOVWF  01
29BA:  BRA    2AE4
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
29BC:  MOVF   x47,F
29BE:  BNZ   29CE
29C0:  MOVF   x46,F
29C2:  BNZ   29CE
29C4:  MOVF   x45,F
29C6:  BNZ   29CE
29C8:  MOVF   x44,W
29CA:  SUBLW  05
29CC:  BC    2A2E
29CE:  MOVF   x47,F
29D0:  BNZ   2A2E
29D2:  MOVF   x46,F
29D4:  BNZ   2A2E
29D6:  MOVF   x45,F
29D8:  BNZ   2A2E
29DA:  MOVF   x44,W
29DC:  SUBLW  3B
29DE:  BNC   2A2E
29E0:  MOVF   x3B,F
29E2:  BNZ   29F2
29E4:  MOVF   x3A,F
29E6:  BNZ   29F2
29E8:  MOVF   x39,F
29EA:  BNZ   29F2
29EC:  MOVF   x38,W
29EE:  SUBLW  64
29F0:  BC    2A2E
29F2:  MOVF   x3F,F
29F4:  BNZ   2A04
29F6:  MOVF   x3E,F
29F8:  BNZ   2A04
29FA:  MOVF   x3D,F
29FC:  BNZ   2A04
29FE:  MOVF   x3C,W
2A00:  SUBLW  64
2A02:  BC    2A2E
2A04:  MOVF   x43,F
2A06:  BNZ   2A16
2A08:  MOVF   x42,F
2A0A:  BNZ   2A16
2A0C:  MOVF   x41,F
2A0E:  BNZ   2A16
2A10:  MOVF   x40,W
2A12:  SUBLW  64
2A14:  BC    2A2E
2A16:  MOVF   x37,F
2A18:  BNZ   2A28
2A1A:  MOVF   x36,F
2A1C:  BNZ   2A28
2A1E:  MOVF   x35,F
2A20:  BNZ   2A28
2A22:  MOVF   x34,W
2A24:  SUBLW  64
2A26:  BC    2A2E
2A28:  MOVLW  04
2A2A:  MOVWF  01
2A2C:  BRA    2AE4
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2A2E:  MOVF   x47,F
2A30:  BNZ   2A42
2A32:  MOVF   x46,F
2A34:  BNZ   2A42
2A36:  MOVF   x45,F
2A38:  BNZ   2A42
2A3A:  MOVF   x44,W
2A3C:  SUBLW  C8
2A3E:  BTFSC  FD8.0
2A40:  BRA    2AE0
2A42:  MOVF   x37,F
2A44:  BTFSS  FD8.2
2A46:  BRA    2AE0
2A48:  MOVF   x36,F
2A4A:  BTFSS  FD8.2
2A4C:  BRA    2AE0
2A4E:  MOVF   x35,F
2A50:  BTFSS  FD8.2
2A52:  BRA    2AE0
2A54:  MOVF   x34,W
2A56:  SUBLW  B3
2A58:  BNC   2AE0
2A5A:  MOVF   x37,F
2A5C:  BNZ   2A6C
2A5E:  MOVF   x36,F
2A60:  BNZ   2A6C
2A62:  MOVF   x35,F
2A64:  BNZ   2A6C
2A66:  MOVF   x34,W
2A68:  SUBLW  64
2A6A:  BC    2AE0
2A6C:  MOVF   x3B,F
2A6E:  BNZ   2AE0
2A70:  MOVF   x3A,F
2A72:  BNZ   2AE0
2A74:  MOVF   x39,F
2A76:  BNZ   2AE0
2A78:  MOVF   x38,W
2A7A:  SUBLW  B3
2A7C:  BNC   2AE0
2A7E:  MOVF   x3B,F
2A80:  BNZ   2A90
2A82:  MOVF   x3A,F
2A84:  BNZ   2A90
2A86:  MOVF   x39,F
2A88:  BNZ   2A90
2A8A:  MOVF   x38,W
2A8C:  SUBLW  64
2A8E:  BC    2AE0
2A90:  MOVF   x3F,F
2A92:  BNZ   2AE0
2A94:  MOVF   x3E,F
2A96:  BNZ   2AE0
2A98:  MOVF   x3D,F
2A9A:  BNZ   2AE0
2A9C:  MOVF   x3C,W
2A9E:  SUBLW  B3
2AA0:  BNC   2AE0
2AA2:  MOVF   x3F,F
2AA4:  BNZ   2AB4
2AA6:  MOVF   x3E,F
2AA8:  BNZ   2AB4
2AAA:  MOVF   x3D,F
2AAC:  BNZ   2AB4
2AAE:  MOVF   x3C,W
2AB0:  SUBLW  64
2AB2:  BC    2AE0
2AB4:  MOVF   x43,F
2AB6:  BNZ   2AE0
2AB8:  MOVF   x42,F
2ABA:  BNZ   2AE0
2ABC:  MOVF   x41,F
2ABE:  BNZ   2AE0
2AC0:  MOVF   x40,W
2AC2:  SUBLW  B3
2AC4:  BNC   2AE0
2AC6:  MOVF   x43,F
2AC8:  BNZ   2AD8
2ACA:  MOVF   x42,F
2ACC:  BNZ   2AD8
2ACE:  MOVF   x41,F
2AD0:  BNZ   2AD8
2AD2:  MOVF   x40,W
2AD4:  SUBLW  64
2AD6:  BC    2AE0
2AD8:  MOVLW  04
2ADA:  MOVWF  01
2ADC:  BRA    2AE4
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2ADE:  BRA    2AE4
2AE0:  MOVLW  FF
2AE2:  MOVWF  01
.................... } 
2AE4:  MOVLB  0
2AE6:  GOTO   3330 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
2AEA:  MOVLB  8
2AEC:  CLRF   x37
2AEE:  CLRF   x36
2AF0:  CLRF   x35
2AF2:  CLRF   x34
2AF4:  CLRF   x3B
2AF6:  CLRF   x3A
2AF8:  CLRF   x39
2AFA:  CLRF   x38
2AFC:  CLRF   x3F
2AFE:  CLRF   x3E
2B00:  CLRF   x3D
2B02:  CLRF   x3C
2B04:  CLRF   x43
2B06:  CLRF   x42
2B08:  CLRF   x41
2B0A:  CLRF   x40
2B0C:  CLRF   x47
2B0E:  CLRF   x46
2B10:  CLRF   x45
2B12:  CLRF   x44
2B14:  CLRF   x4B
2B16:  CLRF   x4A
2B18:  CLRF   x49
2B1A:  CLRF   x48
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2B1C:  CLRF   x33
2B1E:  CLRF   x32
2B20:  MOVF   x33,W
2B22:  SUBLW  01
2B24:  BNC   2BC4
2B26:  BNZ   2B2E
2B28:  MOVF   x32,W
2B2A:  SUBLW  F3
2B2C:  BNC   2BC4
....................    { 
....................       col_0=read_col(0)+col_0; 
2B2E:  CLRF   x4C
2B30:  MOVLB  0
2B32:  CALL   225C
2B36:  MOVF   01,W
2B38:  MOVLB  8
2B3A:  ADDWF  x34,F
2B3C:  MOVLW  00
2B3E:  ADDWFC x35,F
2B40:  ADDWFC x36,F
2B42:  ADDWFC x37,F
....................       col_1=read_col(1)+col_1; 
2B44:  MOVLW  01
2B46:  MOVWF  x4C
2B48:  MOVLB  0
2B4A:  CALL   225C
2B4E:  MOVF   01,W
2B50:  MOVLB  8
2B52:  ADDWF  x38,F
2B54:  MOVLW  00
2B56:  ADDWFC x39,F
2B58:  ADDWFC x3A,F
2B5A:  ADDWFC x3B,F
....................       col_2=read_col(2)+col_2; 
2B5C:  MOVLW  02
2B5E:  MOVWF  x4C
2B60:  MOVLB  0
2B62:  CALL   225C
2B66:  MOVF   01,W
2B68:  MOVLB  8
2B6A:  ADDWF  x3C,F
2B6C:  MOVLW  00
2B6E:  ADDWFC x3D,F
2B70:  ADDWFC x3E,F
2B72:  ADDWFC x3F,F
....................       col_3=read_col(3)+col_3; 
2B74:  MOVLW  03
2B76:  MOVWF  x4C
2B78:  MOVLB  0
2B7A:  CALL   225C
2B7E:  MOVF   01,W
2B80:  MOVLB  8
2B82:  ADDWF  x40,F
2B84:  MOVLW  00
2B86:  ADDWFC x41,F
2B88:  ADDWFC x42,F
2B8A:  ADDWFC x43,F
....................       col_4=read_col(4)+col_4; 
2B8C:  MOVLW  04
2B8E:  MOVWF  x4C
2B90:  MOVLB  0
2B92:  CALL   225C
2B96:  MOVF   01,W
2B98:  MOVLB  8
2B9A:  ADDWF  x44,F
2B9C:  MOVLW  00
2B9E:  ADDWFC x45,F
2BA0:  ADDWFC x46,F
2BA2:  ADDWFC x47,F
....................       col_5=read_col(5)+col_5; 
2BA4:  MOVLW  05
2BA6:  MOVWF  x4C
2BA8:  MOVLB  0
2BAA:  CALL   225C
2BAE:  MOVF   01,W
2BB0:  MOVLB  8
2BB2:  ADDWF  x48,F
2BB4:  MOVLW  00
2BB6:  ADDWFC x49,F
2BB8:  ADDWFC x4A,F
2BBA:  ADDWFC x4B,F
....................    } 
2BBC:  INCF   x32,F
2BBE:  BTFSC  FD8.2
2BC0:  INCF   x33,F
2BC2:  BRA    2B20
....................    col_0=col_0/500; 
2BC4:  BCF    FD8.1
2BC6:  MOVFF  837,85B
2BCA:  MOVFF  836,85A
2BCE:  MOVFF  835,859
2BD2:  MOVFF  834,858
2BD6:  CLRF   x5F
2BD8:  CLRF   x5E
2BDA:  MOVLW  01
2BDC:  MOVWF  x5D
2BDE:  MOVLW  F4
2BE0:  MOVWF  x5C
2BE2:  MOVLB  0
2BE4:  CALL   236A
2BE8:  MOVFF  03,837
2BEC:  MOVFF  02,836
2BF0:  MOVFF  01,835
2BF4:  MOVFF  00,834
....................    col_1=col_1/500; 
2BF8:  BCF    FD8.1
2BFA:  MOVFF  83B,85B
2BFE:  MOVFF  83A,85A
2C02:  MOVFF  839,859
2C06:  MOVFF  838,858
2C0A:  MOVLB  8
2C0C:  CLRF   x5F
2C0E:  CLRF   x5E
2C10:  MOVLW  01
2C12:  MOVWF  x5D
2C14:  MOVLW  F4
2C16:  MOVWF  x5C
2C18:  MOVLB  0
2C1A:  CALL   236A
2C1E:  MOVFF  03,83B
2C22:  MOVFF  02,83A
2C26:  MOVFF  01,839
2C2A:  MOVFF  00,838
....................    col_2=col_2/500; 
2C2E:  BCF    FD8.1
2C30:  MOVFF  83F,85B
2C34:  MOVFF  83E,85A
2C38:  MOVFF  83D,859
2C3C:  MOVFF  83C,858
2C40:  MOVLB  8
2C42:  CLRF   x5F
2C44:  CLRF   x5E
2C46:  MOVLW  01
2C48:  MOVWF  x5D
2C4A:  MOVLW  F4
2C4C:  MOVWF  x5C
2C4E:  MOVLB  0
2C50:  CALL   236A
2C54:  MOVFF  03,83F
2C58:  MOVFF  02,83E
2C5C:  MOVFF  01,83D
2C60:  MOVFF  00,83C
....................    col_3=col_3/500; 
2C64:  BCF    FD8.1
2C66:  MOVFF  843,85B
2C6A:  MOVFF  842,85A
2C6E:  MOVFF  841,859
2C72:  MOVFF  840,858
2C76:  MOVLB  8
2C78:  CLRF   x5F
2C7A:  CLRF   x5E
2C7C:  MOVLW  01
2C7E:  MOVWF  x5D
2C80:  MOVLW  F4
2C82:  MOVWF  x5C
2C84:  MOVLB  0
2C86:  CALL   236A
2C8A:  MOVFF  03,843
2C8E:  MOVFF  02,842
2C92:  MOVFF  01,841
2C96:  MOVFF  00,840
....................    col_4=col_4/500; 
2C9A:  BCF    FD8.1
2C9C:  MOVFF  847,85B
2CA0:  MOVFF  846,85A
2CA4:  MOVFF  845,859
2CA8:  MOVFF  844,858
2CAC:  MOVLB  8
2CAE:  CLRF   x5F
2CB0:  CLRF   x5E
2CB2:  MOVLW  01
2CB4:  MOVWF  x5D
2CB6:  MOVLW  F4
2CB8:  MOVWF  x5C
2CBA:  MOVLB  0
2CBC:  CALL   236A
2CC0:  MOVFF  03,847
2CC4:  MOVFF  02,846
2CC8:  MOVFF  01,845
2CCC:  MOVFF  00,844
....................    col_5=col_5/500; 
2CD0:  BCF    FD8.1
2CD2:  MOVFF  84B,85B
2CD6:  MOVFF  84A,85A
2CDA:  MOVFF  849,859
2CDE:  MOVFF  848,858
2CE2:  MOVLB  8
2CE4:  CLRF   x5F
2CE6:  CLRF   x5E
2CE8:  MOVLW  01
2CEA:  MOVWF  x5D
2CEC:  MOVLW  F4
2CEE:  MOVWF  x5C
2CF0:  MOVLB  0
2CF2:  CALL   236A
2CF6:  MOVFF  03,84B
2CFA:  MOVFF  02,84A
2CFE:  MOVFF  01,849
2D02:  MOVFF  00,848
....................    if(keydebug_en) 
2D06:  MOVLB  1
2D08:  MOVF   x4C,F
2D0A:  BTFSC  FD8.2
2D0C:  BRA    2ED6
....................    { 
....................       fprintf(COM2,"\r\n");      
2D0E:  MOVLW  0D
2D10:  MOVLB  8
2D12:  MOVWF  x58
2D14:  MOVLB  0
2D16:  CALL   0694
2D1A:  MOVLW  0A
2D1C:  MOVLB  8
2D1E:  MOVWF  x58
2D20:  MOVLB  0
2D22:  CALL   0694
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2D26:  MOVLW  30
2D28:  MOVWF  FF6
2D2A:  MOVLW  05
2D2C:  MOVWF  FF7
2D2E:  MOVLW  07
2D30:  MOVLB  8
2D32:  MOVWF  x4C
2D34:  MOVLB  0
2D36:  CALL   1652
2D3A:  MOVLW  41
2D3C:  MOVWF  FE9
2D3E:  MOVFF  837,84F
2D42:  MOVFF  836,84E
2D46:  MOVFF  835,84D
2D4A:  MOVFF  834,84C
2D4E:  CALL   23FE
2D52:  MOVLW  0D
2D54:  MOVLB  8
2D56:  MOVWF  x58
2D58:  MOVLB  0
2D5A:  CALL   0694
2D5E:  MOVLW  0A
2D60:  MOVLB  8
2D62:  MOVWF  x58
2D64:  MOVLB  0
2D66:  CALL   0694
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2D6A:  MOVLW  3E
2D6C:  MOVWF  FF6
2D6E:  MOVLW  05
2D70:  MOVWF  FF7
2D72:  MOVLW  07
2D74:  MOVLB  8
2D76:  MOVWF  x4C
2D78:  MOVLB  0
2D7A:  CALL   1652
2D7E:  MOVLW  41
2D80:  MOVWF  FE9
2D82:  MOVFF  83B,84F
2D86:  MOVFF  83A,84E
2D8A:  MOVFF  839,84D
2D8E:  MOVFF  838,84C
2D92:  CALL   23FE
2D96:  MOVLW  0D
2D98:  MOVLB  8
2D9A:  MOVWF  x58
2D9C:  MOVLB  0
2D9E:  CALL   0694
2DA2:  MOVLW  0A
2DA4:  MOVLB  8
2DA6:  MOVWF  x58
2DA8:  MOVLB  0
2DAA:  CALL   0694
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2DAE:  MOVLW  4C
2DB0:  MOVWF  FF6
2DB2:  MOVLW  05
2DB4:  MOVWF  FF7
2DB6:  MOVLW  07
2DB8:  MOVLB  8
2DBA:  MOVWF  x4C
2DBC:  MOVLB  0
2DBE:  CALL   1652
2DC2:  MOVLW  41
2DC4:  MOVWF  FE9
2DC6:  MOVFF  83F,84F
2DCA:  MOVFF  83E,84E
2DCE:  MOVFF  83D,84D
2DD2:  MOVFF  83C,84C
2DD6:  CALL   23FE
2DDA:  MOVLW  0D
2DDC:  MOVLB  8
2DDE:  MOVWF  x58
2DE0:  MOVLB  0
2DE2:  CALL   0694
2DE6:  MOVLW  0A
2DE8:  MOVLB  8
2DEA:  MOVWF  x58
2DEC:  MOVLB  0
2DEE:  CALL   0694
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2DF2:  MOVLW  5A
2DF4:  MOVWF  FF6
2DF6:  MOVLW  05
2DF8:  MOVWF  FF7
2DFA:  MOVLW  07
2DFC:  MOVLB  8
2DFE:  MOVWF  x4C
2E00:  MOVLB  0
2E02:  CALL   1652
2E06:  MOVLW  41
2E08:  MOVWF  FE9
2E0A:  MOVFF  843,84F
2E0E:  MOVFF  842,84E
2E12:  MOVFF  841,84D
2E16:  MOVFF  840,84C
2E1A:  CALL   23FE
2E1E:  MOVLW  0D
2E20:  MOVLB  8
2E22:  MOVWF  x58
2E24:  MOVLB  0
2E26:  CALL   0694
2E2A:  MOVLW  0A
2E2C:  MOVLB  8
2E2E:  MOVWF  x58
2E30:  MOVLB  0
2E32:  CALL   0694
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2E36:  MOVLW  68
2E38:  MOVWF  FF6
2E3A:  MOVLW  05
2E3C:  MOVWF  FF7
2E3E:  MOVLW  07
2E40:  MOVLB  8
2E42:  MOVWF  x4C
2E44:  MOVLB  0
2E46:  CALL   1652
2E4A:  MOVLW  41
2E4C:  MOVWF  FE9
2E4E:  MOVFF  847,84F
2E52:  MOVFF  846,84E
2E56:  MOVFF  845,84D
2E5A:  MOVFF  844,84C
2E5E:  CALL   23FE
2E62:  MOVLW  0D
2E64:  MOVLB  8
2E66:  MOVWF  x58
2E68:  MOVLB  0
2E6A:  CALL   0694
2E6E:  MOVLW  0A
2E70:  MOVLB  8
2E72:  MOVWF  x58
2E74:  MOVLB  0
2E76:  CALL   0694
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2E7A:  MOVLW  76
2E7C:  MOVWF  FF6
2E7E:  MOVLW  05
2E80:  MOVWF  FF7
2E82:  MOVLW  07
2E84:  MOVLB  8
2E86:  MOVWF  x4C
2E88:  MOVLB  0
2E8A:  CALL   1652
2E8E:  MOVLW  41
2E90:  MOVWF  FE9
2E92:  MOVFF  84B,84F
2E96:  MOVFF  84A,84E
2E9A:  MOVFF  849,84D
2E9E:  MOVFF  848,84C
2EA2:  CALL   23FE
2EA6:  MOVLW  0D
2EA8:  MOVLB  8
2EAA:  MOVWF  x58
2EAC:  MOVLB  0
2EAE:  CALL   0694
2EB2:  MOVLW  0A
2EB4:  MOVLB  8
2EB6:  MOVWF  x58
2EB8:  MOVLB  0
2EBA:  CALL   0694
....................       fprintf(COM2,"\r\n"); 
2EBE:  MOVLW  0D
2EC0:  MOVLB  8
2EC2:  MOVWF  x58
2EC4:  MOVLB  0
2EC6:  CALL   0694
2ECA:  MOVLW  0A
2ECC:  MOVLB  8
2ECE:  MOVWF  x58
2ED0:  MOVLB  0
2ED2:  CALL   0694
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2ED6:  MOVLB  8
2ED8:  MOVF   x37,F
2EDA:  BNZ   2EEA
2EDC:  MOVF   x36,F
2EDE:  BNZ   2EEA
2EE0:  MOVF   x35,F
2EE2:  BNZ   2EEA
2EE4:  MOVF   x34,W
2EE6:  SUBLW  05
2EE8:  BC    2F5C
2EEA:  MOVF   x37,F
2EEC:  BNZ   2F5C
2EEE:  MOVF   x36,F
2EF0:  BNZ   2F5C
2EF2:  MOVF   x35,F
2EF4:  BNZ   2F5C
2EF6:  MOVF   x34,W
2EF8:  SUBLW  3B
2EFA:  BNC   2F5C
2EFC:  MOVF   x3B,F
2EFE:  BNZ   2F0E
2F00:  MOVF   x3A,F
2F02:  BNZ   2F0E
2F04:  MOVF   x39,F
2F06:  BNZ   2F0E
2F08:  MOVF   x38,W
2F0A:  SUBLW  64
2F0C:  BC    2F5C
2F0E:  MOVF   x3F,F
2F10:  BNZ   2F20
2F12:  MOVF   x3E,F
2F14:  BNZ   2F20
2F16:  MOVF   x3D,F
2F18:  BNZ   2F20
2F1A:  MOVF   x3C,W
2F1C:  SUBLW  64
2F1E:  BC    2F5C
2F20:  MOVF   x43,F
2F22:  BNZ   2F32
2F24:  MOVF   x42,F
2F26:  BNZ   2F32
2F28:  MOVF   x41,F
2F2A:  BNZ   2F32
2F2C:  MOVF   x40,W
2F2E:  SUBLW  64
2F30:  BC    2F5C
2F32:  MOVF   x47,F
2F34:  BNZ   2F44
2F36:  MOVF   x46,F
2F38:  BNZ   2F44
2F3A:  MOVF   x45,F
2F3C:  BNZ   2F44
2F3E:  MOVF   x44,W
2F40:  SUBLW  64
2F42:  BC    2F5C
2F44:  MOVF   x4B,F
2F46:  BNZ   2F56
2F48:  MOVF   x4A,F
2F4A:  BNZ   2F56
2F4C:  MOVF   x49,F
2F4E:  BNZ   2F56
2F50:  MOVF   x48,W
2F52:  SUBLW  64
2F54:  BC    2F5C
2F56:  MOVLW  00
2F58:  MOVWF  01
2F5A:  BRA    32D4
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2F5C:  MOVF   x3B,F
2F5E:  BNZ   2F6E
2F60:  MOVF   x3A,F
2F62:  BNZ   2F6E
2F64:  MOVF   x39,F
2F66:  BNZ   2F6E
2F68:  MOVF   x38,W
2F6A:  SUBLW  05
2F6C:  BC    2FE0
2F6E:  MOVF   x3B,F
2F70:  BNZ   2FE0
2F72:  MOVF   x3A,F
2F74:  BNZ   2FE0
2F76:  MOVF   x39,F
2F78:  BNZ   2FE0
2F7A:  MOVF   x38,W
2F7C:  SUBLW  3B
2F7E:  BNC   2FE0
2F80:  MOVF   x37,F
2F82:  BNZ   2F92
2F84:  MOVF   x36,F
2F86:  BNZ   2F92
2F88:  MOVF   x35,F
2F8A:  BNZ   2F92
2F8C:  MOVF   x34,W
2F8E:  SUBLW  64
2F90:  BC    2FE0
2F92:  MOVF   x3F,F
2F94:  BNZ   2FA4
2F96:  MOVF   x3E,F
2F98:  BNZ   2FA4
2F9A:  MOVF   x3D,F
2F9C:  BNZ   2FA4
2F9E:  MOVF   x3C,W
2FA0:  SUBLW  64
2FA2:  BC    2FE0
2FA4:  MOVF   x43,F
2FA6:  BNZ   2FB6
2FA8:  MOVF   x42,F
2FAA:  BNZ   2FB6
2FAC:  MOVF   x41,F
2FAE:  BNZ   2FB6
2FB0:  MOVF   x40,W
2FB2:  SUBLW  64
2FB4:  BC    2FE0
2FB6:  MOVF   x47,F
2FB8:  BNZ   2FC8
2FBA:  MOVF   x46,F
2FBC:  BNZ   2FC8
2FBE:  MOVF   x45,F
2FC0:  BNZ   2FC8
2FC2:  MOVF   x44,W
2FC4:  SUBLW  64
2FC6:  BC    2FE0
2FC8:  MOVF   x4B,F
2FCA:  BNZ   2FDA
2FCC:  MOVF   x4A,F
2FCE:  BNZ   2FDA
2FD0:  MOVF   x49,F
2FD2:  BNZ   2FDA
2FD4:  MOVF   x48,W
2FD6:  SUBLW  64
2FD8:  BC    2FE0
2FDA:  MOVLW  01
2FDC:  MOVWF  01
2FDE:  BRA    32D4
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2FE0:  MOVF   x3F,F
2FE2:  BNZ   2FF2
2FE4:  MOVF   x3E,F
2FE6:  BNZ   2FF2
2FE8:  MOVF   x3D,F
2FEA:  BNZ   2FF2
2FEC:  MOVF   x3C,W
2FEE:  SUBLW  05
2FF0:  BC    3064
2FF2:  MOVF   x3F,F
2FF4:  BNZ   3064
2FF6:  MOVF   x3E,F
2FF8:  BNZ   3064
2FFA:  MOVF   x3D,F
2FFC:  BNZ   3064
2FFE:  MOVF   x3C,W
3000:  SUBLW  3B
3002:  BNC   3064
3004:  MOVF   x3B,F
3006:  BNZ   3016
3008:  MOVF   x3A,F
300A:  BNZ   3016
300C:  MOVF   x39,F
300E:  BNZ   3016
3010:  MOVF   x38,W
3012:  SUBLW  64
3014:  BC    3064
3016:  MOVF   x37,F
3018:  BNZ   3028
301A:  MOVF   x36,F
301C:  BNZ   3028
301E:  MOVF   x35,F
3020:  BNZ   3028
3022:  MOVF   x34,W
3024:  SUBLW  64
3026:  BC    3064
3028:  MOVF   x43,F
302A:  BNZ   303A
302C:  MOVF   x42,F
302E:  BNZ   303A
3030:  MOVF   x41,F
3032:  BNZ   303A
3034:  MOVF   x40,W
3036:  SUBLW  64
3038:  BC    3064
303A:  MOVF   x47,F
303C:  BNZ   304C
303E:  MOVF   x46,F
3040:  BNZ   304C
3042:  MOVF   x45,F
3044:  BNZ   304C
3046:  MOVF   x44,W
3048:  SUBLW  64
304A:  BC    3064
304C:  MOVF   x4B,F
304E:  BNZ   305E
3050:  MOVF   x4A,F
3052:  BNZ   305E
3054:  MOVF   x49,F
3056:  BNZ   305E
3058:  MOVF   x48,W
305A:  SUBLW  64
305C:  BC    3064
305E:  MOVLW  02
3060:  MOVWF  01
3062:  BRA    32D4
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
3064:  MOVF   x43,F
3066:  BNZ   3076
3068:  MOVF   x42,F
306A:  BNZ   3076
306C:  MOVF   x41,F
306E:  BNZ   3076
3070:  MOVF   x40,W
3072:  SUBLW  05
3074:  BC    30E8
3076:  MOVF   x43,F
3078:  BNZ   30E8
307A:  MOVF   x42,F
307C:  BNZ   30E8
307E:  MOVF   x41,F
3080:  BNZ   30E8
3082:  MOVF   x40,W
3084:  SUBLW  3B
3086:  BNC   30E8
3088:  MOVF   x3B,F
308A:  BNZ   309A
308C:  MOVF   x3A,F
308E:  BNZ   309A
3090:  MOVF   x39,F
3092:  BNZ   309A
3094:  MOVF   x38,W
3096:  SUBLW  64
3098:  BC    30E8
309A:  MOVF   x3F,F
309C:  BNZ   30AC
309E:  MOVF   x3E,F
30A0:  BNZ   30AC
30A2:  MOVF   x3D,F
30A4:  BNZ   30AC
30A6:  MOVF   x3C,W
30A8:  SUBLW  64
30AA:  BC    30E8
30AC:  MOVF   x37,F
30AE:  BNZ   30BE
30B0:  MOVF   x36,F
30B2:  BNZ   30BE
30B4:  MOVF   x35,F
30B6:  BNZ   30BE
30B8:  MOVF   x34,W
30BA:  SUBLW  64
30BC:  BC    30E8
30BE:  MOVF   x47,F
30C0:  BNZ   30D0
30C2:  MOVF   x46,F
30C4:  BNZ   30D0
30C6:  MOVF   x45,F
30C8:  BNZ   30D0
30CA:  MOVF   x44,W
30CC:  SUBLW  64
30CE:  BC    30E8
30D0:  MOVF   x4B,F
30D2:  BNZ   30E2
30D4:  MOVF   x4A,F
30D6:  BNZ   30E2
30D8:  MOVF   x49,F
30DA:  BNZ   30E2
30DC:  MOVF   x48,W
30DE:  SUBLW  64
30E0:  BC    30E8
30E2:  MOVLW  03
30E4:  MOVWF  01
30E6:  BRA    32D4
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
30E8:  MOVF   x47,F
30EA:  BNZ   30FA
30EC:  MOVF   x46,F
30EE:  BNZ   30FA
30F0:  MOVF   x45,F
30F2:  BNZ   30FA
30F4:  MOVF   x44,W
30F6:  SUBLW  05
30F8:  BC    316C
30FA:  MOVF   x47,F
30FC:  BNZ   316C
30FE:  MOVF   x46,F
3100:  BNZ   316C
3102:  MOVF   x45,F
3104:  BNZ   316C
3106:  MOVF   x44,W
3108:  SUBLW  3B
310A:  BNC   316C
310C:  MOVF   x3B,F
310E:  BNZ   311E
3110:  MOVF   x3A,F
3112:  BNZ   311E
3114:  MOVF   x39,F
3116:  BNZ   311E
3118:  MOVF   x38,W
311A:  SUBLW  64
311C:  BC    316C
311E:  MOVF   x3F,F
3120:  BNZ   3130
3122:  MOVF   x3E,F
3124:  BNZ   3130
3126:  MOVF   x3D,F
3128:  BNZ   3130
312A:  MOVF   x3C,W
312C:  SUBLW  64
312E:  BC    316C
3130:  MOVF   x43,F
3132:  BNZ   3142
3134:  MOVF   x42,F
3136:  BNZ   3142
3138:  MOVF   x41,F
313A:  BNZ   3142
313C:  MOVF   x40,W
313E:  SUBLW  64
3140:  BC    316C
3142:  MOVF   x37,F
3144:  BNZ   3154
3146:  MOVF   x36,F
3148:  BNZ   3154
314A:  MOVF   x35,F
314C:  BNZ   3154
314E:  MOVF   x34,W
3150:  SUBLW  64
3152:  BC    316C
3154:  MOVF   x4B,F
3156:  BNZ   3166
3158:  MOVF   x4A,F
315A:  BNZ   3166
315C:  MOVF   x49,F
315E:  BNZ   3166
3160:  MOVF   x48,W
3162:  SUBLW  64
3164:  BC    316C
3166:  MOVLW  04
3168:  MOVWF  01
316A:  BRA    32D4
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
316C:  MOVF   x4B,F
316E:  BNZ   317E
3170:  MOVF   x4A,F
3172:  BNZ   317E
3174:  MOVF   x49,F
3176:  BNZ   317E
3178:  MOVF   x48,W
317A:  SUBLW  05
317C:  BC    31F0
317E:  MOVF   x4B,F
3180:  BNZ   31F0
3182:  MOVF   x4A,F
3184:  BNZ   31F0
3186:  MOVF   x49,F
3188:  BNZ   31F0
318A:  MOVF   x48,W
318C:  SUBLW  3B
318E:  BNC   31F0
3190:  MOVF   x3B,F
3192:  BNZ   31A2
3194:  MOVF   x3A,F
3196:  BNZ   31A2
3198:  MOVF   x39,F
319A:  BNZ   31A2
319C:  MOVF   x38,W
319E:  SUBLW  64
31A0:  BC    31F0
31A2:  MOVF   x3F,F
31A4:  BNZ   31B4
31A6:  MOVF   x3E,F
31A8:  BNZ   31B4
31AA:  MOVF   x3D,F
31AC:  BNZ   31B4
31AE:  MOVF   x3C,W
31B0:  SUBLW  64
31B2:  BC    31F0
31B4:  MOVF   x43,F
31B6:  BNZ   31C6
31B8:  MOVF   x42,F
31BA:  BNZ   31C6
31BC:  MOVF   x41,F
31BE:  BNZ   31C6
31C0:  MOVF   x40,W
31C2:  SUBLW  64
31C4:  BC    31F0
31C6:  MOVF   x47,F
31C8:  BNZ   31D8
31CA:  MOVF   x46,F
31CC:  BNZ   31D8
31CE:  MOVF   x45,F
31D0:  BNZ   31D8
31D2:  MOVF   x44,W
31D4:  SUBLW  64
31D6:  BC    31F0
31D8:  MOVF   x37,F
31DA:  BNZ   31EA
31DC:  MOVF   x36,F
31DE:  BNZ   31EA
31E0:  MOVF   x35,F
31E2:  BNZ   31EA
31E4:  MOVF   x34,W
31E6:  SUBLW  64
31E8:  BC    31F0
31EA:  MOVLW  05
31EC:  MOVWF  01
31EE:  BRA    32D4
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
31F0:  MOVF   x4B,F
31F2:  BNZ   3204
31F4:  MOVF   x4A,F
31F6:  BNZ   3204
31F8:  MOVF   x49,F
31FA:  BNZ   3204
31FC:  MOVF   x48,W
31FE:  SUBLW  C8
3200:  BTFSC  FD8.0
3202:  BRA    32D0
3204:  MOVF   x37,F
3206:  BTFSS  FD8.2
3208:  BRA    32D0
320A:  MOVF   x36,F
320C:  BTFSS  FD8.2
320E:  BRA    32D0
3210:  MOVF   x35,F
3212:  BTFSS  FD8.2
3214:  BRA    32D0
3216:  MOVF   x34,W
3218:  SUBLW  B3
321A:  BTFSS  FD8.0
321C:  BRA    32D0
321E:  MOVF   x37,F
3220:  BNZ   3232
3222:  MOVF   x36,F
3224:  BNZ   3232
3226:  MOVF   x35,F
3228:  BNZ   3232
322A:  MOVF   x34,W
322C:  SUBLW  64
322E:  BTFSC  FD8.0
3230:  BRA    32D0
3232:  MOVF   x3B,F
3234:  BTFSS  FD8.2
3236:  BRA    32D0
3238:  MOVF   x3A,F
323A:  BTFSS  FD8.2
323C:  BRA    32D0
323E:  MOVF   x39,F
3240:  BTFSS  FD8.2
3242:  BRA    32D0
3244:  MOVF   x38,W
3246:  SUBLW  B3
3248:  BNC   32D0
324A:  MOVF   x3B,F
324C:  BNZ   325C
324E:  MOVF   x3A,F
3250:  BNZ   325C
3252:  MOVF   x39,F
3254:  BNZ   325C
3256:  MOVF   x38,W
3258:  SUBLW  64
325A:  BC    32D0
325C:  MOVF   x3F,F
325E:  BNZ   32D0
3260:  MOVF   x3E,F
3262:  BNZ   32D0
3264:  MOVF   x3D,F
3266:  BNZ   32D0
3268:  MOVF   x3C,W
326A:  SUBLW  B3
326C:  BNC   32D0
326E:  MOVF   x3F,F
3270:  BNZ   3280
3272:  MOVF   x3E,F
3274:  BNZ   3280
3276:  MOVF   x3D,F
3278:  BNZ   3280
327A:  MOVF   x3C,W
327C:  SUBLW  64
327E:  BC    32D0
3280:  MOVF   x43,F
3282:  BNZ   32D0
3284:  MOVF   x42,F
3286:  BNZ   32D0
3288:  MOVF   x41,F
328A:  BNZ   32D0
328C:  MOVF   x40,W
328E:  SUBLW  B3
3290:  BNC   32D0
3292:  MOVF   x43,F
3294:  BNZ   32A4
3296:  MOVF   x42,F
3298:  BNZ   32A4
329A:  MOVF   x41,F
329C:  BNZ   32A4
329E:  MOVF   x40,W
32A0:  SUBLW  64
32A2:  BC    32D0
32A4:  MOVF   x47,F
32A6:  BNZ   32D0
32A8:  MOVF   x46,F
32AA:  BNZ   32D0
32AC:  MOVF   x45,F
32AE:  BNZ   32D0
32B0:  MOVF   x44,W
32B2:  SUBLW  B3
32B4:  BNC   32D0
32B6:  MOVF   x47,F
32B8:  BNZ   32C8
32BA:  MOVF   x46,F
32BC:  BNZ   32C8
32BE:  MOVF   x45,F
32C0:  BNZ   32C8
32C2:  MOVF   x44,W
32C4:  SUBLW  64
32C6:  BC    32D0
32C8:  MOVLW  05
32CA:  MOVWF  01
32CC:  BRA    32D4
....................    else return 0xff; 
32CE:  BRA    32D4
32D0:  MOVLW  FF
32D2:  MOVWF  01
.................... } 
32D4:  MOVLB  0
32D6:  GOTO   333C (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
32DA:  MOVLW  20
32DC:  MOVLB  8
32DE:  MOVWF  x30
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
32E0:  BSF    F93.4
32E2:  BTFSS  F81.4
32E4:  BRA    32F8
32E6:  BSF    F93.5
32E8:  BTFSS  F81.5
32EA:  BRA    32F8
32EC:  BSF    F93.6
32EE:  BTFSS  F81.6
32F0:  BRA    32F8
32F2:  BSF    F93.7
32F4:  BTFSC  F81.7
32F6:  BRA    3462
....................     { 
....................        if(input(ROW0)==0) 
32F8:  BSF    F93.4
32FA:  BTFSC  F81.4
32FC:  BRA    3302
....................          row=0; 
32FE:  CLRF   x31
....................        else if(input(ROW1)==0) 
3300:  BRA    3324
3302:  BSF    F93.5
3304:  BTFSC  F81.5
3306:  BRA    330E
....................          row=1; 
3308:  MOVLW  01
330A:  MOVWF  x31
....................        else if(input(ROW2)==0) 
330C:  BRA    3324
330E:  BSF    F93.6
3310:  BTFSC  F81.6
3312:  BRA    331A
....................          row=2; 
3314:  MOVLW  02
3316:  MOVWF  x31
....................        else if(input(ROW3)==0) 
3318:  BRA    3324
331A:  BSF    F93.7
331C:  BTFSC  F81.7
331E:  BRA    3324
....................          row=3;      
3320:  MOVLW  03
3322:  MOVWF  x31
....................        if(type_KB==0)col=check_col(); 
3324:  MOVLB  1
3326:  MOVF   x54,F
3328:  BNZ   3336
332A:  MOVLB  0
332C:  GOTO   24BE
3330:  MOVFF  01,82F
....................          else col=new_check_col(); 
3334:  BRA    3340
3336:  MOVLB  0
3338:  GOTO   2AEA
333C:  MOVFF  01,82F
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
3340:  MOVLB  8
3342:  INCFSZ x2F,W
3344:  BRA    3348
3346:  BRA    3432
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
3348:  MOVLB  1
334A:  MOVF   x54,F
334C:  BNZ   3374
334E:  MOVLB  8
3350:  MOVF   x31,W
3352:  MULLW  05
3354:  MOVF   FF3,W
3356:  CLRF   x33
3358:  MOVWF  x32
335A:  CLRF   03
335C:  MOVF   x2F,W
335E:  ADDWF  x32,W
3360:  MOVWF  01
3362:  MOVF   x33,W
3364:  ADDWFC 03,F
3366:  MOVF   01,W
3368:  MOVLB  0
336A:  CALL   030A
336E:  MOVFF  FE8,830
....................            else kchar =newKEYS[row][col]; 
3372:  BRA    3398
3374:  MOVLB  8
3376:  MOVF   x31,W
3378:  MULLW  06
337A:  MOVF   FF3,W
337C:  CLRF   x33
337E:  MOVWF  x32
3380:  CLRF   03
3382:  MOVF   x2F,W
3384:  ADDWF  x32,W
3386:  MOVWF  01
3388:  MOVF   x33,W
338A:  ADDWFC 03,F
338C:  MOVF   01,W
338E:  MOVLB  0
3390:  CALL   032E
3394:  MOVFF  FE8,830
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
3398:  MOVLB  1
339A:  MOVF   x4C,F
339C:  BNZ   3424
....................             { 
....................               charac_timeout=0; 
339E:  MOVLB  0
33A0:  CLRF   xFC
33A2:  CLRF   xFB
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
33A4:  MOVLB  1
33A6:  MOVF   x4F,W
33A8:  SUBLW  0B
33AA:  BNC   33C0
33AC:  MOVF   x4F,W
33AE:  INCF   x4F,F
33B0:  CLRF   03
33B2:  ADDLW  55
33B4:  MOVWF  FE9
33B6:  MOVLW  01
33B8:  ADDWFC 03,W
33BA:  MOVWF  FEA
33BC:  MOVFF  830,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
33C0:  MOVLW  84
33C2:  MOVWF  FF6
33C4:  MOVLW  05
33C6:  MOVWF  FF7
33C8:  MOVLW  09
33CA:  MOVLB  8
33CC:  MOVWF  x4C
33CE:  MOVLB  0
33D0:  CALL   1652
33D4:  MOVFF  14F,838
33D8:  MOVLW  18
33DA:  MOVLB  8
33DC:  MOVWF  x39
33DE:  MOVLB  0
33E0:  CALL   1766
33E4:  MOVLW  5D
33E6:  MOVLB  8
33E8:  MOVWF  x58
33EA:  MOVLB  0
33EC:  CALL   0694
33F0:  MOVLW  20
33F2:  MOVLB  8
33F4:  MOVWF  x58
33F6:  MOVLB  0
33F8:  CALL   0694
33FC:  MOVFF  830,858
3400:  CALL   0694
3404:  MOVLW  0D
3406:  MOVLB  8
3408:  MOVWF  x58
340A:  MOVLB  0
340C:  CALL   0694
3410:  MOVLW  0A
3412:  MOVLB  8
3414:  MOVWF  x58
3416:  MOVLB  0
3418:  CALL   0694
....................                count_checking=0; 
341C:  MOVLB  1
341E:  CLRF   x07
3420:  CLRF   x06
....................             } 
....................                else fputc(kchar,COM2); 
3422:  BRA    3430
3424:  MOVFF  830,858
3428:  MOVLB  0
342A:  CALL   0694
342E:  MOVLB  1
3430:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3432:  BSF    F93.4
3434:  BTFSS  F81.4
3436:  BRA    3432
3438:  BSF    F93.5
343A:  BTFSS  F81.5
343C:  BRA    3432
343E:  BSF    F93.6
3440:  BTFSS  F81.6
3442:  BRA    3432
3444:  BSF    F93.7
3446:  BTFSS  F81.7
3448:  BRA    3432
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
344A:  BSF    F93.4
344C:  BTFSS  F81.4
344E:  BRA    344A
3450:  BSF    F93.5
3452:  BTFSS  F81.5
3454:  BRA    344A
3456:  BSF    F93.6
3458:  BTFSS  F81.6
345A:  BRA    344A
345C:  BSF    F93.7
345E:  BTFSS  F81.7
3460:  BRA    344A
....................     } 
....................   set_tris_a(0xff);     
3462:  MOVLW  FF
3464:  MOVWF  F92
....................   return(kchar); 
3466:  MOVFF  830,01
.................... }//*/ 
346A:  MOVLB  0
346C:  RETURN 0
.................... //============================================ 
.................... //=========================================================== 
.................... #if 0 
.................... void write_kb_i2ceeprom(void) 
.................... { 
....................       unsigned long adr; 
....................       unsigned int i; 
....................       unsigned int crc; 
....................       char rec[34]; 
....................       char retval; 
....................  
....................       RTC_get_time();                                 /* Lecture de l'heure actuelle */ 
....................  
....................       rec[0]=33;                                    /* Prochaine chaine dans 33 cars. */ 
....................       rec[1]=32;                                    /* Nombre de bytes de la chaine */ 
....................       rec[2]=(unsigned char)((heure_actuelle.annee)-2000);   /* Année en byte */ 
....................       rec[3]=heure_actuelle.mois;                        /* Mois en byte */ 
....................       rec[4]=heure_actuelle.jour;                        /* Jour en byte */ 
....................       rec[5]=heure_actuelle.heure;                     /* Heure en byte */ 
....................       rec[6]=heure_actuelle.minute;                     /* Minute en byte */ 
....................       rec[7]=heure_actuelle.seconde;                     /* Seconde en byte */ 
....................  
....................       rec[8]=0x01;                                 /* Type Clavier */ 
....................  
....................       for(i=0;i<KB_char_cnt && i<12;i++)   /* Copie du nombre de byte dans le tampon de clavier */ 
....................          rec[9+i]=KB_buf[i]; 
....................  
....................       i=i+9;                  /* Ajout des 8 bytes pour l'entête + 1 byte pour le pointeur  */ 
....................     
....................       while(i<33)               /* Mettre des 0 comme "padding" */ 
....................       { 
....................          rec[i]=0x00; 
....................          i++; 
....................       } 
....................  
....................       crc=crcccitt(0, &rec[1], 30);   /* Calcul du CRC 16 (CCITT) de la chaine */ 
....................  
....................       rec[31]=(unsigned char)(crc & 0x00FF); 
....................       rec[32]=(unsigned char)((crc & 0xFF00)>>8); 
....................  
....................       rec[33]=0xFF;            /* Terminaison de la liste par 0xFF */ 
....................  
....................       /** Encryption de la chaine */ 
....................       rijndael('c', (unsigned char *)&rec[1], (unsigned char *)&crypto_key[0]); 
....................       rijndael('c', (unsigned char *)&rec[17], (unsigned char *)&crypto_key[16]); 
....................  
....................       read_eeptr(&adr);         /* Lecture de l'adresse de fin de liste */ 
....................  
....................       retval=I2CEEPROM_write(adr,34,rec);   /* Écriture de la chaine */ 
....................  
....................       if(retval!=0) 
....................          write_eeptr(adr+33);         /* Ajuster le pointeur d'ajout de chaine dans la liste  */ 
....................  
.................... } 
.................... #endif 
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 rec[16]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
58C8:  MOVF   27,F
58CA:  BTFSS  FD8.2
58CC:  BRA    5B1A
58CE:  MOVF   26,W
58D0:  SUBLW  01
58D2:  BTFSS  FD8.0
58D4:  BRA    5B1A
58D6:  BNZ   58EA
58D8:  MOVF   25,W
58DA:  SUBLW  FF
58DC:  BTFSS  FD8.0
58DE:  BRA    5B1A
58E0:  BNZ   58EA
58E2:  MOVF   24,W
58E4:  SUBLW  FE
58E6:  BTFSS  FD8.0
58E8:  BRA    5B1A
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
58EA:  MOVLB  1
58EC:  MOVF   x55,F
58EE:  BNZ   58F6
58F0:  MOVF   x4F,F
58F2:  BTFSC  FD8.2
58F4:  BRA    5A80
....................       {    
....................          for(i=0;i<key_numbyte;i++) 
58F6:  MOVLB  7
58F8:  CLRF   xC1
58FA:  MOVF   xC1,W
58FC:  SUBLW  0B
58FE:  BNC   595E
....................          { 
....................             temp=key_data[i]; 
5900:  CLRF   03
5902:  MOVF   xC1,W
5904:  ADDLW  55
5906:  MOVWF  FE9
5908:  MOVLW  01
590A:  ADDWFC 03,W
590C:  MOVWF  FEA
590E:  CLRF   xC3
5910:  MOVFF  FEF,7C2
5914:  CLRF   19
5916:  BTFSC  FF2.7
5918:  BSF    19.7
591A:  BCF    FF2.7
....................             fputc(temp,COM2); 
591C:  MOVFF  7C2,858
5920:  MOVLB  0
5922:  CALL   0694
5926:  BTFSC  19.7
5928:  BSF    FF2.7
....................             rec[i]=key_data[i]; 
592A:  CLRF   03
592C:  MOVLB  7
592E:  MOVF   xC1,W
5930:  ADDLW  C5
5932:  MOVWF  01
5934:  MOVLW  07
5936:  ADDWFC 03,F
5938:  MOVFF  03,7D6
593C:  CLRF   03
593E:  MOVF   xC1,W
5940:  ADDLW  55
5942:  MOVWF  FE9
5944:  MOVLW  01
5946:  ADDWFC 03,W
5948:  MOVWF  FEA
594A:  MOVFF  FEF,7D7
594E:  MOVFF  7D6,FEA
5952:  MOVFF  01,FE9
5956:  MOVFF  7D7,FEF
....................          } 
595A:  INCF   xC1,F
595C:  BRA    58FA
....................          rec[key_numbyte] = 0; 
595E:  CLRF   xD1
....................          rec[key_numbyte+1] = 0;          
5960:  CLRF   xD2
....................          rec[key_numbyte+2] = 0;          
5962:  CLRF   xD3
....................          rec[key_numbyte+3] = 0; 
5964:  CLRF   xD4
....................     #if 0 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"test_key:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"\n\rdatain:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2," %x",rec[i]); 
....................          fprintf(COM2,"\n\r"); 
....................     #endif 
....................          //rijndael('c', (unsigned char *)&rec[0], (unsigned char *)&crypto_key[0]); 
....................          aes_enc_dec((unsigned int8 *)&rec[0], (unsigned int8 *)&crypto_key[0],0); 
5966:  MOVLW  07
5968:  MOVWF  xD6
596A:  MOVLW  C5
596C:  MOVWF  xD5
596E:  MOVLW  01
5970:  MOVWF  xD8
5972:  MOVLW  08
5974:  MOVWF  xD7
5976:  CLRF   xD9
5978:  MOVLB  0
597A:  CALL   4BF2
597E:  CLRF   19
5980:  BTFSC  FF2.7
5982:  BSF    19.7
5984:  BCF    FF2.7
....................          //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................           
....................          /* get the pointer of keyboard data */ 
....................          temp=get_countcard(); 
5986:  CALL   361A
598A:  BTFSC  19.7
598C:  BSF    FF2.7
598E:  MOVFF  02,7C3
5992:  MOVFF  01,7C2
....................          ptr_card_key=(int32)(((temp)*16)+EEPROM_KEY_ST); 
5996:  MOVLB  7
5998:  RLCF   xC2,W
599A:  MOVWF  xD5
599C:  RLCF   xC3,W
599E:  MOVWF  xD6
59A0:  RLCF   xD5,F
59A2:  RLCF   xD6,F
59A4:  RLCF   xD5,F
59A6:  RLCF   xD6,F
59A8:  RLCF   xD5,F
59AA:  RLCF   xD6,F
59AC:  MOVLW  F0
59AE:  ANDWF  xD5,F
59B0:  MOVLW  0E
59B2:  ADDWF  xD5,F
59B4:  MOVLW  C3
59B6:  ADDWFC xD6,F
59B8:  MOVLW  01
59BA:  MOVWF  xD7
59BC:  BCF    FD8.2
59BE:  BTFSC  FD8.0
59C0:  INCF   xD7,F
59C2:  CLRF   xD8
59C4:  MOVLW  01
59C6:  ADDWF  xD5,W
59C8:  MOVWF  00
59CA:  MOVLW  00
59CC:  ADDWFC xD6,W
59CE:  MOVWF  01
59D0:  MOVLW  00
59D2:  ADDWFC xD7,W
59D4:  MOVWF  02
59D6:  MOVLW  00
59D8:  ADDWFC xD8,W
59DA:  MOVWF  27
59DC:  MOVFF  02,26
59E0:  MOVFF  01,25
59E4:  MOVFF  00,24
....................           
....................          for(i=0;i<16;i++) fprintf(COM2,"%x",rec[i]); 
59E8:  CLRF   xC1
59EA:  MOVF   xC1,W
59EC:  SUBLW  0F
59EE:  BNC   5A14
59F0:  CLRF   03
59F2:  MOVF   xC1,W
59F4:  ADDLW  C5
59F6:  MOVWF  FE9
59F8:  MOVLW  07
59FA:  ADDWFC 03,W
59FC:  MOVWF  FEA
59FE:  MOVFF  FEF,7D5
5A02:  MOVFF  7D5,7D6
5A06:  MOVLW  57
5A08:  MOVWF  xD7
5A0A:  MOVLB  0
5A0C:  RCALL  5866
5A0E:  MOVLB  7
5A10:  INCF   xC1,F
5A12:  BRA    59EA
....................          retval = EEPROM_write(ptr_card_key,16,rec);   /* Écriture de la chaine */ 
5A14:  MOVFF  27,80F
5A18:  MOVFF  26,80E
5A1C:  MOVFF  25,80D
5A20:  MOVFF  24,80C
5A24:  MOVLB  8
5A26:  CLRF   x13
5A28:  CLRF   x12
5A2A:  CLRF   x11
5A2C:  MOVLW  10
5A2E:  MOVWF  x10
5A30:  MOVLW  07
5A32:  MOVWF  x15
5A34:  MOVLW  C5
5A36:  MOVWF  x14
5A38:  MOVLB  0
5A3A:  CALL   46FA
5A3E:  MOVFF  01,7C4
....................          if(retval!=0) 
5A42:  MOVLB  7
5A44:  MOVF   xC4,F
5A46:  BZ    5A7E
....................          { 
....................             ptr_card_key+=16; 
5A48:  MOVLW  10
5A4A:  ADDWF  24,F
5A4C:  MOVLW  00
5A4E:  ADDWFC 25,F
5A50:  ADDWFC 26,F
5A52:  ADDWFC 27,F
5A54:  CLRF   19
5A56:  BTFSC  FF2.7
5A58:  BSF    19.7
5A5A:  BCF    FF2.7
....................             save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5A5C:  MOVFF  27,835
5A60:  MOVFF  26,834
5A64:  MOVFF  25,833
5A68:  MOVFF  24,832
5A6C:  MOVLW  1E
5A6E:  MOVLB  8
5A70:  MOVWF  x36
5A72:  MOVLB  0
5A74:  CALL   3B9C
5A78:  BTFSC  19.7
5A7A:  BSF    FF2.7
5A7C:  MOVLB  7
5A7E:  MOVLB  1
....................          }          
....................       } 
....................       key_count_ms=0; 
5A80:  CLRF   x4F
5A82:  CLRF   19
5A84:  BTFSC  FF2.7
5A86:  BSF    19.7
5A88:  BCF    FF2.7
....................       del_buf(key_numbyte,key_data); 
5A8A:  MOVLW  0C
5A8C:  MOVLB  8
5A8E:  MOVWF  x3E
5A90:  MOVLW  01
5A92:  MOVWF  x40
5A94:  MOVLW  55
5A96:  MOVWF  x3F
5A98:  MOVLB  0
5A9A:  CALL   3694
5A9E:  BTFSC  19.7
5AA0:  BSF    FF2.7
5AA2:  CLRF   19
5AA4:  BTFSC  FF2.7
5AA6:  BSF    19.7
5AA8:  BCF    FF2.7
....................       fprintf(COM2,"\r\n"); 
5AAA:  MOVLW  0D
5AAC:  MOVLB  8
5AAE:  MOVWF  x58
5AB0:  MOVLB  0
5AB2:  CALL   0694
5AB6:  BTFSC  19.7
5AB8:  BSF    FF2.7
5ABA:  CLRF   19
5ABC:  BTFSC  FF2.7
5ABE:  BSF    19.7
5AC0:  BCF    FF2.7
5AC2:  MOVLW  0A
5AC4:  MOVLB  8
5AC6:  MOVWF  x58
5AC8:  MOVLB  0
5ACA:  CALL   0694
5ACE:  BTFSC  19.7
5AD0:  BSF    FF2.7
....................       fprintf(COM2,"Done PIN"); 
5AD2:  MOVLW  96
5AD4:  MOVWF  FF6
5AD6:  MOVLW  05
5AD8:  MOVWF  FF7
5ADA:  CLRF   19
5ADC:  BTFSC  FF2.7
5ADE:  BSF    19.7
5AE0:  BCF    FF2.7
5AE2:  CALL   06DA
5AE6:  BTFSC  19.7
5AE8:  BSF    FF2.7
5AEA:  CLRF   19
5AEC:  BTFSC  FF2.7
5AEE:  BSF    19.7
5AF0:  BCF    FF2.7
....................       fprintf(COM2,"\r\n"); 
5AF2:  MOVLW  0D
5AF4:  MOVLB  8
5AF6:  MOVWF  x58
5AF8:  MOVLB  0
5AFA:  CALL   0694
5AFE:  BTFSC  19.7
5B00:  BSF    FF2.7
5B02:  CLRF   19
5B04:  BTFSC  FF2.7
5B06:  BSF    19.7
5B08:  BCF    FF2.7
5B0A:  MOVLW  0A
5B0C:  MOVLB  8
5B0E:  MOVWF  x58
5B10:  MOVLB  0
5B12:  CALL   0694
5B16:  BTFSC  19.7
5B18:  BSF    FF2.7
....................    } 
.................... } 
5B1A:  GOTO   7FA2 (RETURN)
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
404C:  MOVF   27,F
404E:  BTFSS  FD8.2
4050:  BRA    41C6
4052:  MOVF   26,W
4054:  SUBLW  01
4056:  BTFSS  FD8.0
4058:  BRA    41C6
405A:  BNZ   406E
405C:  MOVF   25,W
405E:  SUBLW  FF
4060:  BTFSS  FD8.0
4062:  BRA    41C6
4064:  BNZ   406E
4066:  MOVF   24,W
4068:  SUBLW  FE
406A:  BTFSS  FD8.0
406C:  BRA    41C6
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
406E:  MOVLB  1
4070:  MOVF   x55,F
4072:  BNZ   407A
4074:  MOVF   x4F,F
4076:  BTFSC  FD8.2
4078:  BRA    4174
....................       { 
....................          temp=get_countcard(); 
407A:  MOVLB  0
407C:  CALL   361A
4080:  MOVFF  02,831
4084:  MOVFF  01,830
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
4088:  MOVFF  831,835
408C:  MOVFF  830,834
4090:  MOVLB  8
4092:  CLRF   x37
4094:  MOVLW  0C
4096:  MOVWF  x36
4098:  MOVLB  0
409A:  CALL   3672
409E:  MOVFF  02,833
40A2:  MOVFF  01,832
40A6:  MOVLW  0E
40A8:  MOVLB  8
40AA:  ADDWF  x32,F
40AC:  MOVLW  C3
40AE:  ADDWFC x33,F
40B0:  MOVLW  01
40B2:  MOVWF  x34
40B4:  BCF    FD8.2
40B6:  BTFSC  FD8.0
40B8:  INCF   x34,F
40BA:  CLRF   x35
40BC:  MOVLW  01
40BE:  ADDWF  x32,W
40C0:  MOVWF  00
40C2:  MOVLW  00
40C4:  ADDWFC x33,W
40C6:  MOVWF  01
40C8:  MOVLW  00
40CA:  ADDWFC x34,W
40CC:  MOVWF  02
40CE:  MOVLW  00
40D0:  ADDWFC x35,W
40D2:  MOVWF  27
40D4:  MOVFF  02,26
40D8:  MOVFF  01,25
40DC:  MOVFF  00,24
....................          for(i=0;i<key_numbyte-5;i++) 
40E0:  CLRF   x2F
40E2:  MOVF   x2F,W
40E4:  SUBLW  06
40E6:  BNC   4146
....................          { 
....................             temp=key_data[i]; 
40E8:  CLRF   03
40EA:  MOVF   x2F,W
40EC:  ADDLW  55
40EE:  MOVWF  FE9
40F0:  MOVLW  01
40F2:  ADDWFC 03,W
40F4:  MOVWF  FEA
40F6:  CLRF   x31
40F8:  MOVFF  FEF,830
....................             write_ext_eeprom((long int)ptr_card_key++,temp); 
40FC:  MOVFF  27,03
4100:  MOVFF  26,02
4104:  MOVFF  25,01
4108:  MOVFF  24,00
410C:  MOVLW  01
410E:  ADDWF  24,F
4110:  BTFSC  FD8.0
4112:  INCF   25,F
4114:  BTFSC  FD8.2
4116:  INCF   26,F
4118:  BTFSC  FD8.2
411A:  INCF   27,F
411C:  MOVFF  01,833
4120:  MOVFF  00,832
4124:  CLRF   x43
4126:  CLRF   x42
4128:  MOVFF  01,841
412C:  MOVFF  00,840
4130:  MOVFF  830,844
4134:  MOVLB  0
4136:  RCALL  3A9E
....................             //delay_us(100); 
....................             fputc(temp,COM2); 
4138:  MOVFF  830,858
413C:  CALL   0694
....................          } 
4140:  MOVLB  8
4142:  INCF   x2F,F
4144:  BRA    40E2
....................          /*fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<key_numbyte;i++) 
....................           { 
....................             fprintf(COM2,"read key=%c\n\r",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          write_ext_eeprom((long int)ptr_card_key,0); 
4146:  CLRF   x43
4148:  CLRF   x42
414A:  MOVFF  25,841
414E:  MOVFF  24,840
4152:  CLRF   x44
4154:  MOVLB  0
4156:  RCALL  3A9E
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
4158:  MOVFF  27,835
415C:  MOVFF  26,834
4160:  MOVFF  25,833
4164:  MOVFF  24,832
4168:  MOVLW  1E
416A:  MOVLB  8
416C:  MOVWF  x36
416E:  MOVLB  0
4170:  RCALL  3B9C
4172:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
4174:  CLRF   x4F
....................       del_buf(key_numbyte,key_data); 
4176:  MOVLW  0C
4178:  MOVLB  8
417A:  MOVWF  x3E
417C:  MOVLW  01
417E:  MOVWF  x40
4180:  MOVLW  55
4182:  MOVWF  x3F
4184:  MOVLB  0
4186:  CALL   3694
....................       fprintf(COM2,"\r\n"); 
418A:  MOVLW  0D
418C:  MOVLB  8
418E:  MOVWF  x58
4190:  MOVLB  0
4192:  CALL   0694
4196:  MOVLW  0A
4198:  MOVLB  8
419A:  MOVWF  x58
419C:  MOVLB  0
419E:  CALL   0694
....................       fprintf(COM2,"Done PIN"); 
41A2:  MOVLW  A0
41A4:  MOVWF  FF6
41A6:  MOVLW  05
41A8:  MOVWF  FF7
41AA:  CALL   06DA
....................       fprintf(COM2,"\r\n"); 
41AE:  MOVLW  0D
41B0:  MOVLB  8
41B2:  MOVWF  x58
41B4:  MOVLB  0
41B6:  CALL   0694
41BA:  MOVLW  0A
41BC:  MOVLB  8
41BE:  MOVWF  x58
41C0:  MOVLB  0
41C2:  CALL   0694
....................    } 
.................... } 
41C6:  GOTO   448A (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
5B6C:  MOVLB  7
5B6E:  CLRF   xFE
5B70:  CLRF   xFD
5B72:  CLRF   xFF
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
5B74:  MOVF   xFE,F
5B76:  BTFSS  FD8.2
5B78:  BRA    5C9C
5B7A:  MOVF   xF8,W
5B7C:  SUBWF  xFD,W
5B7E:  BTFSC  FD8.0
5B80:  BRA    5C9C
5B82:  MOVF   xFF,F
5B84:  BTFSS  FD8.2
5B86:  BRA    5C9C
....................       c = fgetc(COM2);//getc(); 
5B88:  MOVLB  0
5B8A:  RCALL  5B1E
5B8C:  MOVFF  01,7FB
....................       switch(c) 
....................       { 
5B90:  MOVLB  7
5B92:  MOVF   xFB,W
5B94:  XORLW  7F
5B96:  MOVLB  0
5B98:  BZ    5BA0
5B9A:  XORLW  72
5B9C:  BZ    5BEE
5B9E:  BRA    5C2C
....................          case 0x7f:    
....................             if(nbcar>0)   
5BA0:  MOVLB  7
5BA2:  MOVF   xFD,F
5BA4:  BNZ   5BAA
5BA6:  MOVF   xFE,F
5BA8:  BZ    5BD4
5BAA:  CLRF   19
5BAC:  BTFSC  FF2.7
5BAE:  BSF    19.7
5BB0:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
5BB2:  MOVLW  7F
5BB4:  MOVLB  8
5BB6:  MOVWF  x58
5BB8:  MOVLB  0
5BBA:  CALL   0694
5BBE:  BTFSC  19.7
5BC0:  BSF    FF2.7
....................                nbcar--; 
5BC2:  MOVLB  7
5BC4:  MOVF   xFD,W
5BC6:  BTFSC  FD8.2
5BC8:  DECF   xFE,F
5BCA:  DECF   xFD,F
....................                fgetc(COM2);//getc(); 
5BCC:  MOVLB  0
5BCE:  RCALL  5B1E
....................             } 
....................             else fputc(0x07,COM2);    
5BD0:  BRA    5BEC
5BD2:  MOVLB  7
5BD4:  CLRF   19
5BD6:  BTFSC  FF2.7
5BD8:  BSF    19.7
5BDA:  BCF    FF2.7
5BDC:  MOVLW  07
5BDE:  MOVLB  8
5BE0:  MOVWF  x58
5BE2:  MOVLB  0
5BE4:  CALL   0694
5BE8:  BTFSC  19.7
5BEA:  BSF    FF2.7
....................          break;  
5BEC:  BRA    5C98
....................          case 0x0D:   
....................                keydebug_en=0; 
5BEE:  MOVLB  1
5BF0:  CLRF   x4C
....................                set_tris_a(0xff); 
5BF2:  MOVLW  FF
5BF4:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
5BF6:  MOVFF  7FD,7FC
5BFA:  MOVLB  7
5BFC:  MOVF   xF8,W
5BFE:  SUBWF  xFC,W
5C00:  BC    5C16
....................                { 
....................                  chaine[i]=0; 
5C02:  CLRF   03
5C04:  MOVF   xFC,W
5C06:  ADDWF  xF9,W
5C08:  MOVWF  FE9
5C0A:  MOVF   xFA,W
5C0C:  ADDWFC 03,W
5C0E:  MOVWF  FEA
5C10:  CLRF   FEF
....................                } 
5C12:  INCF   xFC,F
5C14:  BRA    5BFC
....................                if(nbcar==0)return(FAUX); 
5C16:  MOVF   xFD,F
5C18:  BNZ   5C24
5C1A:  MOVF   xFE,F
5C1C:  BNZ   5C24
5C1E:  MOVLW  00
5C20:  MOVWF  01
5C22:  BRA    5CA0
....................                fini=VRAI; 
5C24:  MOVLW  01
5C26:  MOVWF  xFF
....................          break; 
5C28:  MOVLB  0
5C2A:  BRA    5C98
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
5C2C:  MOVLB  7
5C2E:  MOVF   xFB,W
5C30:  SUBLW  1F
5C32:  BC    5C9A
5C34:  MOVF   xFB,W
5C36:  SUBLW  7E
5C38:  BNC   5C9A
5C3A:  MOVLW  01
5C3C:  SUBWF  xF8,W
5C3E:  MOVF   xFE,F
5C40:  BNZ   5C9A
5C42:  SUBWF  xFD,W
5C44:  BC    5C9A
....................             { 
....................                chaine[nbcar]=c; 
5C46:  MOVF   xF9,W
5C48:  ADDWF  xFD,W
5C4A:  MOVWF  FE9
5C4C:  MOVF   xFA,W
5C4E:  ADDWFC xFE,W
5C50:  MOVWF  FEA
5C52:  MOVFF  7FB,FEF
....................                nbcar++; 
5C56:  INCF   xFD,F
5C58:  BTFSC  FD8.2
5C5A:  INCF   xFE,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
5C5C:  DECFSZ xF7,W
5C5E:  BRA    5C7A
5C60:  CLRF   19
5C62:  BTFSC  FF2.7
5C64:  BSF    19.7
5C66:  BCF    FF2.7
5C68:  MOVFF  7FB,858
5C6C:  MOVLB  0
5C6E:  CALL   0694
5C72:  BTFSC  19.7
5C74:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
5C76:  BRA    5C98
5C78:  MOVLB  7
5C7A:  MOVF   xF7,W
5C7C:  SUBLW  02
5C7E:  BNZ   5C9A
5C80:  CLRF   19
5C82:  BTFSC  FF2.7
5C84:  BSF    19.7
5C86:  BCF    FF2.7
5C88:  MOVLW  2A
5C8A:  MOVLB  8
5C8C:  MOVWF  x58
5C8E:  MOVLB  0
5C90:  CALL   0694
5C94:  BTFSC  19.7
5C96:  BSF    FF2.7
5C98:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
5C9A:  BRA    5B74
....................    return(nbcar); 
5C9C:  MOVFF  7FD,01
.................... } 
5CA0:  MOVLB  0
5CA2:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
5CA4:  MOVFF  7F8,7FC
5CA8:  MOVFF  7F7,7FB
5CAC:  MOVFF  7FA,7FE
5CB0:  MOVFF  7F9,7FD
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
5CB4:  MOVFF  7FC,03
5CB8:  MOVLB  7
5CBA:  MOVFF  7FB,FE9
5CBE:  MOVFF  7FC,FEA
5CC2:  MOVF   FEF,F
5CC4:  BZ    5D0C
5CC6:  MOVFF  7FE,03
5CCA:  MOVFF  7FD,FE9
5CCE:  MOVFF  7FE,FEA
5CD2:  MOVF   FEF,F
5CD4:  BZ    5D0C
....................       if(*aa!=*bb) 
5CD6:  MOVFF  7FB,FE9
5CDA:  MOVFF  7FC,FEA
5CDE:  MOVFF  FEF,7FF
5CE2:  MOVFF  7FE,03
5CE6:  MOVFF  7FD,FE9
5CEA:  MOVFF  7FE,FEA
5CEE:  MOVF   FEF,W
5CF0:  SUBWF  xFF,W
5CF2:  BZ    5CFA
....................          return(1); 
5CF4:  MOVLW  01
5CF6:  MOVWF  01
5CF8:  BRA    5D38
....................       aa++; 
5CFA:  INCF   xFB,F
5CFC:  BTFSC  FD8.2
5CFE:  INCF   xFC,F
....................       bb++; 
5D00:  INCF   xFD,F
5D02:  BTFSC  FD8.2
5D04:  INCF   xFE,F
....................    } 
5D06:  MOVLB  0
5D08:  BRA    5CB4
5D0A:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
5D0C:  MOVFF  7FC,03
5D10:  MOVFF  7FB,FE9
5D14:  MOVFF  7FC,FEA
5D18:  MOVFF  FEF,7FF
5D1C:  MOVFF  7FE,03
5D20:  MOVFF  7FD,FE9
5D24:  MOVFF  7FE,FEA
5D28:  MOVF   FEF,W
5D2A:  SUBWF  xFF,W
5D2C:  BZ    5D34
5D2E:  MOVLW  01
5D30:  MOVWF  01
5D32:  BRA    5D38
....................    return(0); 
5D34:  MOVLW  00
5D36:  MOVWF  01
.................... } 
5D38:  MOVLB  0
5D3A:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
6272:  MOVLB  7
6274:  CLRF   xF9
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
6276:  MOVFF  7F8,03
627A:  MOVF   xF7,W
627C:  INCF   xF7,F
627E:  BTFSC  FD8.2
6280:  INCF   xF8,F
6282:  MOVWF  FE9
6284:  MOVFF  03,FEA
6288:  MOVFF  FEF,7FB
628C:  MOVF   xFB,F
628E:  BZ    62B2
....................         if (c >= '0' && c <= '9') 
6290:  MOVF   xFB,W
6292:  SUBLW  2F
6294:  BC    62A4
6296:  MOVF   xFB,W
6298:  SUBLW  39
629A:  BNC   62A4
....................             digit = (unsigned int) (c - '0'); 
629C:  MOVLW  30
629E:  SUBWF  xFB,W
62A0:  MOVWF  xFA
....................         else 
62A2:  BRA    62A6
....................             break; 
62A4:  BRA    62B2
....................  
....................         val = (val * 10) + digit; 
62A6:  MOVF   xF9,W
62A8:  MULLW  0A
62AA:  MOVF   FF3,W
62AC:  ADDWF  xFA,W
62AE:  MOVWF  xF9
....................     } 
62B0:  BRA    6276
....................  
....................     return val; 
62B2:  CLRF   03
62B4:  MOVFF  7F9,01
62B8:  MOVFF  03,02
.................... } 
62BC:  MOVLB  0
62BE:  RETURN 0
....................  
.................... int8 receiver_state=0,booting_done=0; 
.................... int16 over_byte=0; 
.................... //#include <GSM.c>  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
06FA:  MOVLB  8
06FC:  CLRF   x68
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
06FE:  CLRF   x69
0700:  BTFSC  x60.0
0702:  BSF    x69.7
0704:  SWAPF  x61,W
0706:  MOVWF  00
0708:  RLCF   00,F
070A:  RLCF   00,F
070C:  MOVLW  C0
070E:  ANDWF  00,F
0710:  MOVF   00,W
0712:  IORWF  x69,F
0714:  SWAPF  x62,W
0716:  MOVWF  00
0718:  RLCF   00,F
071A:  MOVLW  E0
071C:  ANDWF  00,F
071E:  MOVF   00,W
0720:  IORWF  x69,F
0722:  SWAPF  x63,W
0724:  MOVWF  00
0726:  MOVLW  F0
0728:  ANDWF  00,F
072A:  MOVF   00,W
072C:  IORWF  x69,F
072E:  RLCF   x64,W
0730:  MOVWF  00
0732:  RLCF   00,F
0734:  RLCF   00,F
0736:  MOVLW  F8
0738:  ANDWF  00,F
073A:  MOVF   00,W
073C:  IORWF  x69,F
073E:  RLCF   x65,W
0740:  MOVWF  00
0742:  RLCF   00,F
0744:  MOVLW  FC
0746:  ANDWF  00,F
0748:  MOVF   00,W
074A:  IORWF  x69,F
074C:  BCF    FD8.0
074E:  RLCF   x66,W
0750:  IORWF  x69,F
0752:  MOVF   x67,W
0754:  IORWF  x69,W
0756:  MOVWF  x68
....................    return temp; 
0758:  MOVFF  868,01
.................... } 
075C:  MOVLB  0
075E:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0760:  MOVLB  8
0762:  CLRF   x50
....................    int8 temp=0; 
....................    if(direct==0) 
0764:  MOVF   x4B,F
0766:  BNZ   083C
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
0768:  MOVF   x4E,W
076A:  ADDWF  x4C,W
076C:  MOVWF  FE9
076E:  MOVF   x4F,W
0770:  ADDWFC x4D,W
0772:  MOVWF  FEA
0774:  MOVFF  FEF,851
0778:  MOVLW  01
077A:  ADDWF  x4C,W
077C:  MOVWF  x52
077E:  MOVLW  00
0780:  ADDWFC x4D,W
0782:  MOVWF  x53
0784:  MOVF   x4E,W
0786:  ADDWF  x52,W
0788:  MOVWF  FE9
078A:  MOVF   x4F,W
078C:  ADDWFC x53,W
078E:  MOVWF  FEA
0790:  MOVF   FEF,W
0792:  XORWF  x51,F
0794:  MOVLW  02
0796:  ADDWF  x4C,W
0798:  MOVWF  x54
079A:  MOVLW  00
079C:  ADDWFC x4D,W
079E:  MOVWF  x55
07A0:  MOVF   x4E,W
07A2:  ADDWF  x54,W
07A4:  MOVWF  FE9
07A6:  MOVF   x4F,W
07A8:  ADDWFC x55,W
07AA:  MOVWF  FEA
07AC:  MOVF   FEF,W
07AE:  XORWF  x51,F
07B0:  MOVLW  03
07B2:  ADDWF  x4C,W
07B4:  MOVWF  x56
07B6:  MOVLW  00
07B8:  ADDWFC x4D,W
07BA:  MOVWF  x57
07BC:  MOVF   x4E,W
07BE:  ADDWF  x56,W
07C0:  MOVWF  FE9
07C2:  MOVF   x4F,W
07C4:  ADDWFC x57,W
07C6:  MOVWF  FEA
07C8:  MOVF   FEF,W
07CA:  XORWF  x51,F
07CC:  MOVLW  04
07CE:  ADDWF  x4C,W
07D0:  MOVWF  x58
07D2:  MOVLW  00
07D4:  ADDWFC x4D,W
07D6:  MOVWF  x59
07D8:  MOVF   x4E,W
07DA:  ADDWF  x58,W
07DC:  MOVWF  FE9
07DE:  MOVF   x4F,W
07E0:  ADDWFC x59,W
07E2:  MOVWF  FEA
07E4:  MOVF   FEF,W
07E6:  XORWF  x51,F
07E8:  MOVLW  05
07EA:  ADDWF  x4C,W
07EC:  MOVWF  x5A
07EE:  MOVLW  00
07F0:  ADDWFC x4D,W
07F2:  MOVWF  x5B
07F4:  MOVF   x4E,W
07F6:  ADDWF  x5A,W
07F8:  MOVWF  FE9
07FA:  MOVF   x4F,W
07FC:  ADDWFC x5B,W
07FE:  MOVWF  FEA
0800:  MOVF   FEF,W
0802:  XORWF  x51,W
0804:  BZ    080A
0806:  MOVLW  00
0808:  BRA    080C
080A:  MOVLW  01
080C:  MOVWF  x50
....................       if(temp==datain[offset+6]) return 1; 
080E:  MOVLW  06
0810:  ADDWF  x4C,W
0812:  MOVWF  x51
0814:  MOVLW  00
0816:  ADDWFC x4D,W
0818:  MOVWF  x52
081A:  MOVF   x4E,W
081C:  ADDWF  x51,W
081E:  MOVWF  FE9
0820:  MOVF   x4F,W
0822:  ADDWFC x52,W
0824:  MOVWF  FEA
0826:  MOVF   FEF,W
0828:  SUBWF  x50,W
082A:  BNZ   0834
082C:  MOVLW  01
082E:  MOVWF  01
0830:  BRA    090C
....................          else return 0; 
0832:  BRA    083A
0834:  MOVLW  00
0836:  MOVWF  01
0838:  BRA    090C
....................    } 
....................       else  
083A:  BRA    090C
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
083C:  MOVF   x4E,W
083E:  ADDWF  x4C,W
0840:  MOVWF  FE9
0842:  MOVF   x4F,W
0844:  ADDWFC x4D,W
0846:  MOVWF  FEA
0848:  MOVFF  FEF,851
084C:  MOVLW  01
084E:  SUBWF  x4C,W
0850:  MOVWF  x52
0852:  MOVLW  00
0854:  SUBWFB x4D,W
0856:  MOVWF  x53
0858:  MOVF   x4E,W
085A:  ADDWF  x52,W
085C:  MOVWF  FE9
085E:  MOVF   x4F,W
0860:  ADDWFC x53,W
0862:  MOVWF  FEA
0864:  MOVF   FEF,W
0866:  XORWF  x51,F
0868:  MOVLW  02
086A:  SUBWF  x4C,W
086C:  MOVWF  x54
086E:  MOVLW  00
0870:  SUBWFB x4D,W
0872:  MOVWF  x55
0874:  MOVF   x4E,W
0876:  ADDWF  x54,W
0878:  MOVWF  FE9
087A:  MOVF   x4F,W
087C:  ADDWFC x55,W
087E:  MOVWF  FEA
0880:  MOVF   FEF,W
0882:  XORWF  x51,F
0884:  MOVLW  03
0886:  SUBWF  x4C,W
0888:  MOVWF  x56
088A:  MOVLW  00
088C:  SUBWFB x4D,W
088E:  MOVWF  x57
0890:  MOVF   x4E,W
0892:  ADDWF  x56,W
0894:  MOVWF  FE9
0896:  MOVF   x4F,W
0898:  ADDWFC x57,W
089A:  MOVWF  FEA
089C:  MOVF   FEF,W
089E:  XORWF  x51,F
08A0:  MOVLW  04
08A2:  SUBWF  x4C,W
08A4:  MOVWF  x58
08A6:  MOVLW  00
08A8:  SUBWFB x4D,W
08AA:  MOVWF  x59
08AC:  MOVF   x4E,W
08AE:  ADDWF  x58,W
08B0:  MOVWF  FE9
08B2:  MOVF   x4F,W
08B4:  ADDWFC x59,W
08B6:  MOVWF  FEA
08B8:  MOVF   FEF,W
08BA:  XORWF  x51,F
08BC:  MOVLW  05
08BE:  SUBWF  x4C,W
08C0:  MOVWF  x5A
08C2:  MOVLW  00
08C4:  SUBWFB x4D,W
08C6:  MOVWF  x5B
08C8:  MOVF   x4E,W
08CA:  ADDWF  x5A,W
08CC:  MOVWF  FE9
08CE:  MOVF   x4F,W
08D0:  ADDWFC x5B,W
08D2:  MOVWF  FEA
08D4:  MOVF   FEF,W
08D6:  XORWF  x51,W
08D8:  BZ    08DE
08DA:  MOVLW  00
08DC:  BRA    08E0
08DE:  MOVLW  01
08E0:  MOVWF  x50
....................          if(temp==datain[offset-6]) return 1; 
08E2:  MOVLW  06
08E4:  SUBWF  x4C,W
08E6:  MOVWF  x51
08E8:  MOVLW  00
08EA:  SUBWFB x4D,W
08EC:  MOVWF  x52
08EE:  MOVF   x4E,W
08F0:  ADDWF  x51,W
08F2:  MOVWF  FE9
08F4:  MOVF   x4F,W
08F6:  ADDWFC x52,W
08F8:  MOVWF  FEA
08FA:  MOVF   FEF,W
08FC:  SUBWF  x50,W
08FE:  BNZ   0908
0900:  MOVLW  01
0902:  MOVWF  01
0904:  BRA    090C
....................             else return 0;          
0906:  BRA    090C
0908:  MOVLW  00
090A:  MOVWF  01
....................       } 
.................... } 
090C:  MOVLB  0
090E:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
0910:  MOVLB  8
0912:  CLRF   x50
....................    int8 temp=0; 
....................    if(direct==0) 
0914:  MOVF   x4B,F
0916:  BNZ   09B4
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
0918:  MOVF   x4E,W
091A:  ADDWF  x4C,W
091C:  MOVWF  FE9
091E:  MOVF   x4F,W
0920:  ADDWFC x4D,W
0922:  MOVWF  FEA
0924:  MOVFF  FEF,851
0928:  MOVLW  01
092A:  ADDWF  x4C,W
092C:  MOVWF  x52
092E:  MOVLW  00
0930:  ADDWFC x4D,W
0932:  MOVWF  x53
0934:  MOVF   x4E,W
0936:  ADDWF  x52,W
0938:  MOVWF  FE9
093A:  MOVF   x4F,W
093C:  ADDWFC x53,W
093E:  MOVWF  FEA
0940:  MOVF   FEF,W
0942:  XORWF  x51,F
0944:  MOVLW  02
0946:  ADDWF  x4C,W
0948:  MOVWF  x54
094A:  MOVLW  00
094C:  ADDWFC x4D,W
094E:  MOVWF  x55
0950:  MOVF   x4E,W
0952:  ADDWF  x54,W
0954:  MOVWF  FE9
0956:  MOVF   x4F,W
0958:  ADDWFC x55,W
095A:  MOVWF  FEA
095C:  MOVF   FEF,W
095E:  XORWF  x51,F
0960:  MOVLW  03
0962:  ADDWF  x4C,W
0964:  MOVWF  x56
0966:  MOVLW  00
0968:  ADDWFC x4D,W
096A:  MOVWF  x57
096C:  MOVF   x4E,W
096E:  ADDWF  x56,W
0970:  MOVWF  FE9
0972:  MOVF   x4F,W
0974:  ADDWFC x57,W
0976:  MOVWF  FEA
0978:  MOVF   FEF,W
097A:  XORWF  x51,W
097C:  BZ    0982
097E:  MOVLW  00
0980:  BRA    0984
0982:  MOVLW  01
0984:  MOVWF  x50
....................       if(temp==datain[offset+4]) return 1; 
0986:  MOVLW  04
0988:  ADDWF  x4C,W
098A:  MOVWF  x51
098C:  MOVLW  00
098E:  ADDWFC x4D,W
0990:  MOVWF  x52
0992:  MOVF   x4E,W
0994:  ADDWF  x51,W
0996:  MOVWF  FE9
0998:  MOVF   x4F,W
099A:  ADDWFC x52,W
099C:  MOVWF  FEA
099E:  MOVF   FEF,W
09A0:  SUBWF  x50,W
09A2:  BNZ   09AC
09A4:  MOVLW  01
09A6:  MOVWF  01
09A8:  BRA    0A4C
....................          else return 0; 
09AA:  BRA    09B2
09AC:  MOVLW  00
09AE:  MOVWF  01
09B0:  BRA    0A4C
....................    } 
....................    else 
09B2:  BRA    0A4C
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
09B4:  MOVF   x4E,W
09B6:  ADDWF  x4C,W
09B8:  MOVWF  FE9
09BA:  MOVF   x4F,W
09BC:  ADDWFC x4D,W
09BE:  MOVWF  FEA
09C0:  MOVFF  FEF,851
09C4:  MOVLW  01
09C6:  SUBWF  x4C,W
09C8:  MOVWF  x52
09CA:  MOVLW  00
09CC:  SUBWFB x4D,W
09CE:  MOVWF  x53
09D0:  MOVF   x4E,W
09D2:  ADDWF  x52,W
09D4:  MOVWF  FE9
09D6:  MOVF   x4F,W
09D8:  ADDWFC x53,W
09DA:  MOVWF  FEA
09DC:  MOVF   FEF,W
09DE:  XORWF  x51,F
09E0:  MOVLW  02
09E2:  SUBWF  x4C,W
09E4:  MOVWF  x54
09E6:  MOVLW  00
09E8:  SUBWFB x4D,W
09EA:  MOVWF  x55
09EC:  MOVF   x4E,W
09EE:  ADDWF  x54,W
09F0:  MOVWF  FE9
09F2:  MOVF   x4F,W
09F4:  ADDWFC x55,W
09F6:  MOVWF  FEA
09F8:  MOVF   FEF,W
09FA:  XORWF  x51,F
09FC:  MOVLW  03
09FE:  SUBWF  x4C,W
0A00:  MOVWF  x56
0A02:  MOVLW  00
0A04:  SUBWFB x4D,W
0A06:  MOVWF  x57
0A08:  MOVF   x4E,W
0A0A:  ADDWF  x56,W
0A0C:  MOVWF  FE9
0A0E:  MOVF   x4F,W
0A10:  ADDWFC x57,W
0A12:  MOVWF  FEA
0A14:  MOVF   FEF,W
0A16:  XORWF  x51,W
0A18:  BZ    0A1E
0A1A:  MOVLW  00
0A1C:  BRA    0A20
0A1E:  MOVLW  01
0A20:  MOVWF  x50
....................       if(temp==datain[offset-4]) return 1; 
0A22:  MOVLW  04
0A24:  SUBWF  x4C,W
0A26:  MOVWF  x51
0A28:  MOVLW  00
0A2A:  SUBWFB x4D,W
0A2C:  MOVWF  x52
0A2E:  MOVF   x4E,W
0A30:  ADDWF  x51,W
0A32:  MOVWF  FE9
0A34:  MOVF   x4F,W
0A36:  ADDWFC x52,W
0A38:  MOVWF  FEA
0A3A:  MOVF   FEF,W
0A3C:  SUBWF  x50,W
0A3E:  BNZ   0A48
0A40:  MOVLW  01
0A42:  MOVWF  01
0A44:  BRA    0A4C
....................          else return 0;                
0A46:  BRA    0A4C
0A48:  MOVLW  00
0A4A:  MOVWF  01
....................    } 
.................... } 
0A4C:  MOVLB  0
0A4E:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0A50:  MOVLB  8
0A52:  CLRF   x47
0A54:  CLRF   x48
0A56:  CLRF   x49
0A58:  CLRF   x4A
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0A5A:  CLRF   x44
0A5C:  CLRF   x43
0A5E:  RRCF   x40,W
0A60:  MOVWF  03
0A62:  RRCF   x3F,W
0A64:  MOVWF  02
0A66:  RRCF   03,F
0A68:  RRCF   02,F
0A6A:  MOVLW  3F
0A6C:  ANDWF  03,F
0A6E:  MOVFF  02,01
0A72:  MOVF   x44,W
0A74:  SUBWF  03,W
0A76:  BTFSS  FD8.0
0A78:  BRA    1038
0A7A:  BNZ   0A84
0A7C:  MOVF   01,W
0A7E:  SUBWF  x43,W
0A80:  BTFSC  FD8.0
0A82:  BRA    1038
....................    { 
....................       if(track==0) 
0A84:  MOVF   x3E,F
0A86:  BTFSS  FD8.2
0A88:  BRA    0DBE
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0A8A:  MOVLW  06
0A8C:  ADDWF  x43,W
0A8E:  MOVWF  x4B
0A90:  MOVLW  00
0A92:  ADDWFC x44,W
0A94:  MOVWF  x4C
0A96:  MOVF   x41,W
0A98:  ADDWF  x4B,W
0A9A:  MOVWF  FE9
0A9C:  MOVF   x42,W
0A9E:  ADDWFC x4C,W
0AA0:  MOVWF  FEA
0AA2:  MOVFF  FEF,84D
0AA6:  MOVLW  05
0AA8:  ADDWF  x43,W
0AAA:  MOVWF  x4E
0AAC:  MOVLW  00
0AAE:  ADDWFC x44,W
0AB0:  MOVWF  x4F
0AB2:  MOVF   x41,W
0AB4:  ADDWF  x4E,W
0AB6:  MOVWF  FE9
0AB8:  MOVF   x42,W
0ABA:  ADDWFC x4F,W
0ABC:  MOVWF  FEA
0ABE:  MOVFF  FEF,850
0AC2:  MOVLW  04
0AC4:  ADDWF  x43,W
0AC6:  MOVWF  x51
0AC8:  MOVLW  00
0ACA:  ADDWFC x44,W
0ACC:  MOVWF  x52
0ACE:  MOVF   x41,W
0AD0:  ADDWF  x51,W
0AD2:  MOVWF  FE9
0AD4:  MOVF   x42,W
0AD6:  ADDWFC x52,W
0AD8:  MOVWF  FEA
0ADA:  MOVFF  FEF,853
0ADE:  MOVLW  03
0AE0:  ADDWF  x43,W
0AE2:  MOVWF  x54
0AE4:  MOVLW  00
0AE6:  ADDWFC x44,W
0AE8:  MOVWF  x55
0AEA:  MOVF   x41,W
0AEC:  ADDWF  x54,W
0AEE:  MOVWF  FE9
0AF0:  MOVF   x42,W
0AF2:  ADDWFC x55,W
0AF4:  MOVWF  FEA
0AF6:  MOVFF  FEF,856
0AFA:  MOVLW  02
0AFC:  ADDWF  x43,W
0AFE:  MOVWF  x57
0B00:  MOVLW  00
0B02:  ADDWFC x44,W
0B04:  MOVWF  x58
0B06:  MOVF   x41,W
0B08:  ADDWF  x57,W
0B0A:  MOVWF  FE9
0B0C:  MOVF   x42,W
0B0E:  ADDWFC x58,W
0B10:  MOVWF  FEA
0B12:  MOVFF  FEF,859
0B16:  MOVLW  01
0B18:  ADDWF  x43,W
0B1A:  MOVWF  x5A
0B1C:  MOVLW  00
0B1E:  ADDWFC x44,W
0B20:  MOVWF  x5B
0B22:  MOVF   x41,W
0B24:  ADDWF  x5A,W
0B26:  MOVWF  FE9
0B28:  MOVF   x42,W
0B2A:  ADDWFC x5B,W
0B2C:  MOVWF  FEA
0B2E:  MOVFF  FEF,85C
0B32:  MOVF   x41,W
0B34:  ADDWF  x43,W
0B36:  MOVWF  FE9
0B38:  MOVF   x42,W
0B3A:  ADDWFC x44,W
0B3C:  MOVWF  FEA
0B3E:  MOVFF  FEF,85D
0B42:  CLRF   x60
0B44:  MOVFF  84D,861
0B48:  MOVFF  850,862
0B4C:  MOVFF  853,863
0B50:  MOVFF  856,864
0B54:  MOVFF  859,865
0B58:  MOVFF  85C,866
0B5C:  MOVFF  85D,867
0B60:  MOVLB  0
0B62:  RCALL  06FA
0B64:  MOVFF  01,847
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0B68:  MOVLW  0D
0B6A:  MOVLB  8
0B6C:  ADDWF  x43,W
0B6E:  MOVWF  x4B
0B70:  MOVLW  00
0B72:  ADDWFC x44,W
0B74:  MOVWF  x4C
0B76:  MOVF   x41,W
0B78:  ADDWF  x4B,W
0B7A:  MOVWF  FE9
0B7C:  MOVF   x42,W
0B7E:  ADDWFC x4C,W
0B80:  MOVWF  FEA
0B82:  MOVFF  FEF,84D
0B86:  MOVLW  0C
0B88:  ADDWF  x43,W
0B8A:  MOVWF  x4E
0B8C:  MOVLW  00
0B8E:  ADDWFC x44,W
0B90:  MOVWF  x4F
0B92:  MOVF   x41,W
0B94:  ADDWF  x4E,W
0B96:  MOVWF  FE9
0B98:  MOVF   x42,W
0B9A:  ADDWFC x4F,W
0B9C:  MOVWF  FEA
0B9E:  MOVFF  FEF,850
0BA2:  MOVLW  0B
0BA4:  ADDWF  x43,W
0BA6:  MOVWF  x51
0BA8:  MOVLW  00
0BAA:  ADDWFC x44,W
0BAC:  MOVWF  x52
0BAE:  MOVF   x41,W
0BB0:  ADDWF  x51,W
0BB2:  MOVWF  FE9
0BB4:  MOVF   x42,W
0BB6:  ADDWFC x52,W
0BB8:  MOVWF  FEA
0BBA:  MOVFF  FEF,853
0BBE:  MOVLW  0A
0BC0:  ADDWF  x43,W
0BC2:  MOVWF  x54
0BC4:  MOVLW  00
0BC6:  ADDWFC x44,W
0BC8:  MOVWF  x55
0BCA:  MOVF   x41,W
0BCC:  ADDWF  x54,W
0BCE:  MOVWF  FE9
0BD0:  MOVF   x42,W
0BD2:  ADDWFC x55,W
0BD4:  MOVWF  FEA
0BD6:  MOVFF  FEF,856
0BDA:  MOVLW  09
0BDC:  ADDWF  x43,W
0BDE:  MOVWF  x57
0BE0:  MOVLW  00
0BE2:  ADDWFC x44,W
0BE4:  MOVWF  x58
0BE6:  MOVF   x41,W
0BE8:  ADDWF  x57,W
0BEA:  MOVWF  FE9
0BEC:  MOVF   x42,W
0BEE:  ADDWFC x58,W
0BF0:  MOVWF  FEA
0BF2:  MOVFF  FEF,859
0BF6:  MOVLW  08
0BF8:  ADDWF  x43,W
0BFA:  MOVWF  x5A
0BFC:  MOVLW  00
0BFE:  ADDWFC x44,W
0C00:  MOVWF  x5B
0C02:  MOVF   x41,W
0C04:  ADDWF  x5A,W
0C06:  MOVWF  FE9
0C08:  MOVF   x42,W
0C0A:  ADDWFC x5B,W
0C0C:  MOVWF  FEA
0C0E:  MOVFF  FEF,85C
0C12:  MOVLW  07
0C14:  ADDWF  x43,W
0C16:  MOVWF  x5D
0C18:  MOVLW  00
0C1A:  ADDWFC x44,W
0C1C:  MOVWF  x5E
0C1E:  MOVF   x41,W
0C20:  ADDWF  x5D,W
0C22:  MOVWF  FE9
0C24:  MOVF   x42,W
0C26:  ADDWFC x5E,W
0C28:  MOVWF  FEA
0C2A:  MOVFF  FEF,85F
0C2E:  CLRF   x60
0C30:  MOVFF  84D,861
0C34:  MOVFF  850,862
0C38:  MOVFF  853,863
0C3C:  MOVFF  856,864
0C40:  MOVFF  859,865
0C44:  MOVFF  85C,866
0C48:  MOVFF  85F,867
0C4C:  MOVLB  0
0C4E:  RCALL  06FA
0C50:  MOVFF  01,848
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0C54:  MOVLB  8
0C56:  MOVF   x47,W
0C58:  SUBLW  45
0C5A:  BTFSS  FD8.2
0C5C:  BRA    0DBC
0C5E:  MOVF   x48,W
0C60:  SUBLW  7C
0C62:  BTFSC  FD8.2
0C64:  BRA    0DBC
0C66:  MOVF   x48,W
0C68:  SUBLW  3E
0C6A:  BTFSC  FD8.2
0C6C:  BRA    0DBC
0C6E:  MOVF   x48,W
0C70:  SUBLW  1F
0C72:  BTFSC  FD8.2
0C74:  BRA    0DBC
....................          { 
....................             j=i; 
0C76:  MOVFF  844,846
0C7A:  MOVFF  843,845
....................             CRC=1; 
0C7E:  MOVLW  01
0C80:  MOVWF  x4A
....................             temp2=temp; 
0C82:  MOVFF  847,849
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0C86:  MOVF   x49,W
0C88:  SUBLW  1F
0C8A:  BTFSC  FD8.2
0C8C:  BRA    0DA6
0C8E:  MOVF   x46,W
0C90:  SUBLW  03
0C92:  BTFSS  FD8.0
0C94:  BRA    0DA6
0C96:  BNZ   0CA0
0C98:  MOVF   x45,W
0C9A:  SUBLW  E7
0C9C:  BTFSS  FD8.0
0C9E:  BRA    0DA6
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0CA0:  CLRF   x4B
0CA2:  MOVFF  846,84D
0CA6:  MOVFF  845,84C
0CAA:  MOVFF  842,84F
0CAE:  MOVFF  841,84E
0CB2:  MOVLB  0
0CB4:  RCALL  0760
0CB6:  MOVF   01,W
0CB8:  MOVLB  8
0CBA:  ANDWF  x4A,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0CBC:  MOVLW  06
0CBE:  ADDWF  x45,W
0CC0:  MOVWF  x4B
0CC2:  MOVLW  00
0CC4:  ADDWFC x46,W
0CC6:  MOVWF  x4C
0CC8:  MOVF   x41,W
0CCA:  ADDWF  x4B,W
0CCC:  MOVWF  FE9
0CCE:  MOVF   x42,W
0CD0:  ADDWFC x4C,W
0CD2:  MOVWF  FEA
0CD4:  MOVFF  FEF,84D
0CD8:  MOVLW  05
0CDA:  ADDWF  x45,W
0CDC:  MOVWF  x4E
0CDE:  MOVLW  00
0CE0:  ADDWFC x46,W
0CE2:  MOVWF  x4F
0CE4:  MOVF   x41,W
0CE6:  ADDWF  x4E,W
0CE8:  MOVWF  FE9
0CEA:  MOVF   x42,W
0CEC:  ADDWFC x4F,W
0CEE:  MOVWF  FEA
0CF0:  MOVFF  FEF,850
0CF4:  MOVLW  04
0CF6:  ADDWF  x45,W
0CF8:  MOVWF  x51
0CFA:  MOVLW  00
0CFC:  ADDWFC x46,W
0CFE:  MOVWF  x52
0D00:  MOVF   x41,W
0D02:  ADDWF  x51,W
0D04:  MOVWF  FE9
0D06:  MOVF   x42,W
0D08:  ADDWFC x52,W
0D0A:  MOVWF  FEA
0D0C:  MOVFF  FEF,853
0D10:  MOVLW  03
0D12:  ADDWF  x45,W
0D14:  MOVWF  x54
0D16:  MOVLW  00
0D18:  ADDWFC x46,W
0D1A:  MOVWF  x55
0D1C:  MOVF   x41,W
0D1E:  ADDWF  x54,W
0D20:  MOVWF  FE9
0D22:  MOVF   x42,W
0D24:  ADDWFC x55,W
0D26:  MOVWF  FEA
0D28:  MOVFF  FEF,856
0D2C:  MOVLW  02
0D2E:  ADDWF  x45,W
0D30:  MOVWF  x57
0D32:  MOVLW  00
0D34:  ADDWFC x46,W
0D36:  MOVWF  x58
0D38:  MOVF   x41,W
0D3A:  ADDWF  x57,W
0D3C:  MOVWF  FE9
0D3E:  MOVF   x42,W
0D40:  ADDWFC x58,W
0D42:  MOVWF  FEA
0D44:  MOVFF  FEF,859
0D48:  MOVLW  01
0D4A:  ADDWF  x45,W
0D4C:  MOVWF  x5A
0D4E:  MOVLW  00
0D50:  ADDWFC x46,W
0D52:  MOVWF  x5B
0D54:  MOVF   x41,W
0D56:  ADDWF  x5A,W
0D58:  MOVWF  FE9
0D5A:  MOVF   x42,W
0D5C:  ADDWFC x5B,W
0D5E:  MOVWF  FEA
0D60:  MOVFF  FEF,85C
0D64:  MOVF   x41,W
0D66:  ADDWF  x45,W
0D68:  MOVWF  FE9
0D6A:  MOVF   x42,W
0D6C:  ADDWFC x46,W
0D6E:  MOVWF  FEA
0D70:  MOVFF  FEF,85D
0D74:  CLRF   x60
0D76:  MOVFF  84D,861
0D7A:  MOVFF  850,862
0D7E:  MOVFF  853,863
0D82:  MOVFF  856,864
0D86:  MOVFF  859,865
0D8A:  MOVFF  85C,866
0D8E:  MOVFF  85D,867
0D92:  MOVLB  0
0D94:  RCALL  06FA
0D96:  MOVFF  01,849
....................                j=j+7; 
0D9A:  MOVLW  07
0D9C:  MOVLB  8
0D9E:  ADDWF  x45,F
0DA0:  MOVLW  00
0DA2:  ADDWFC x46,F
....................             } 
0DA4:  BRA    0C86
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0DA6:  DECFSZ x4A,W
0DA8:  BRA    0DBC
....................             { 
....................                dir=0; 
0DAA:  MOVLB  6
0DAC:  CLRF   xCC
....................                return i; 
0DAE:  MOVLB  8
0DB0:  MOVFF  843,01
0DB4:  MOVFF  844,02
0DB8:  GOTO   164E
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0DBC:  BRA    1030
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0DBE:  MOVLW  04
0DC0:  ADDWF  x43,W
0DC2:  MOVWF  x4B
0DC4:  MOVLW  00
0DC6:  ADDWFC x44,W
0DC8:  MOVWF  x4C
0DCA:  MOVF   x41,W
0DCC:  ADDWF  x4B,W
0DCE:  MOVWF  FE9
0DD0:  MOVF   x42,W
0DD2:  ADDWFC x4C,W
0DD4:  MOVWF  FEA
0DD6:  MOVFF  FEF,84D
0DDA:  MOVLW  03
0DDC:  ADDWF  x43,W
0DDE:  MOVWF  x4E
0DE0:  MOVLW  00
0DE2:  ADDWFC x44,W
0DE4:  MOVWF  x4F
0DE6:  MOVF   x41,W
0DE8:  ADDWF  x4E,W
0DEA:  MOVWF  FE9
0DEC:  MOVF   x42,W
0DEE:  ADDWFC x4F,W
0DF0:  MOVWF  FEA
0DF2:  MOVFF  FEF,850
0DF6:  MOVLW  02
0DF8:  ADDWF  x43,W
0DFA:  MOVWF  x51
0DFC:  MOVLW  00
0DFE:  ADDWFC x44,W
0E00:  MOVWF  x52
0E02:  MOVF   x41,W
0E04:  ADDWF  x51,W
0E06:  MOVWF  FE9
0E08:  MOVF   x42,W
0E0A:  ADDWFC x52,W
0E0C:  MOVWF  FEA
0E0E:  MOVFF  FEF,853
0E12:  MOVLW  01
0E14:  ADDWF  x43,W
0E16:  MOVWF  x54
0E18:  MOVLW  00
0E1A:  ADDWFC x44,W
0E1C:  MOVWF  x55
0E1E:  MOVF   x41,W
0E20:  ADDWF  x54,W
0E22:  MOVWF  FE9
0E24:  MOVF   x42,W
0E26:  ADDWFC x55,W
0E28:  MOVWF  FEA
0E2A:  MOVFF  FEF,856
0E2E:  MOVF   x41,W
0E30:  ADDWF  x43,W
0E32:  MOVWF  FE9
0E34:  MOVF   x42,W
0E36:  ADDWFC x44,W
0E38:  MOVWF  FEA
0E3A:  MOVFF  FEF,857
0E3E:  CLRF   x60
0E40:  CLRF   x61
0E42:  CLRF   x62
0E44:  MOVFF  84D,863
0E48:  MOVFF  850,864
0E4C:  MOVFF  853,865
0E50:  MOVFF  856,866
0E54:  MOVFF  857,867
0E58:  MOVLB  0
0E5A:  RCALL  06FA
0E5C:  MOVFF  01,847
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0E60:  MOVLW  09
0E62:  MOVLB  8
0E64:  ADDWF  x43,W
0E66:  MOVWF  x4B
0E68:  MOVLW  00
0E6A:  ADDWFC x44,W
0E6C:  MOVWF  x4C
0E6E:  MOVF   x41,W
0E70:  ADDWF  x4B,W
0E72:  MOVWF  FE9
0E74:  MOVF   x42,W
0E76:  ADDWFC x4C,W
0E78:  MOVWF  FEA
0E7A:  MOVFF  FEF,84D
0E7E:  MOVLW  08
0E80:  ADDWF  x43,W
0E82:  MOVWF  x4E
0E84:  MOVLW  00
0E86:  ADDWFC x44,W
0E88:  MOVWF  x4F
0E8A:  MOVF   x41,W
0E8C:  ADDWF  x4E,W
0E8E:  MOVWF  FE9
0E90:  MOVF   x42,W
0E92:  ADDWFC x4F,W
0E94:  MOVWF  FEA
0E96:  MOVFF  FEF,850
0E9A:  MOVLW  07
0E9C:  ADDWF  x43,W
0E9E:  MOVWF  x51
0EA0:  MOVLW  00
0EA2:  ADDWFC x44,W
0EA4:  MOVWF  x52
0EA6:  MOVF   x41,W
0EA8:  ADDWF  x51,W
0EAA:  MOVWF  FE9
0EAC:  MOVF   x42,W
0EAE:  ADDWFC x52,W
0EB0:  MOVWF  FEA
0EB2:  MOVFF  FEF,853
0EB6:  MOVLW  06
0EB8:  ADDWF  x43,W
0EBA:  MOVWF  x54
0EBC:  MOVLW  00
0EBE:  ADDWFC x44,W
0EC0:  MOVWF  x55
0EC2:  MOVF   x41,W
0EC4:  ADDWF  x54,W
0EC6:  MOVWF  FE9
0EC8:  MOVF   x42,W
0ECA:  ADDWFC x55,W
0ECC:  MOVWF  FEA
0ECE:  MOVFF  FEF,856
0ED2:  MOVLW  05
0ED4:  ADDWF  x43,W
0ED6:  MOVWF  x57
0ED8:  MOVLW  00
0EDA:  ADDWFC x44,W
0EDC:  MOVWF  x58
0EDE:  MOVF   x41,W
0EE0:  ADDWF  x57,W
0EE2:  MOVWF  FE9
0EE4:  MOVF   x42,W
0EE6:  ADDWFC x58,W
0EE8:  MOVWF  FEA
0EEA:  MOVFF  FEF,859
0EEE:  CLRF   x60
0EF0:  CLRF   x61
0EF2:  CLRF   x62
0EF4:  MOVFF  84D,863
0EF8:  MOVFF  850,864
0EFC:  MOVFF  853,865
0F00:  MOVFF  856,866
0F04:  MOVFF  859,867
0F08:  MOVLB  0
0F0A:  CALL   06FA
0F0E:  MOVFF  01,848
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0F12:  MOVLB  8
0F14:  MOVF   x47,W
0F16:  SUBLW  0B
0F18:  BTFSS  FD8.2
0F1A:  BRA    1030
0F1C:  MOVF   x48,W
0F1E:  SUBLW  1F
0F20:  BTFSC  FD8.2
0F22:  BRA    1030
0F24:  MOVF   x48,W
0F26:  SUBLW  0F
0F28:  BTFSC  FD8.2
0F2A:  BRA    1030
....................             { 
....................                j=i; 
0F2C:  MOVFF  844,846
0F30:  MOVFF  843,845
....................                CRC=1; 
0F34:  MOVLW  01
0F36:  MOVWF  x4A
....................                temp2=temp; 
0F38:  MOVFF  847,849
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0F3C:  MOVF   x49,W
0F3E:  SUBLW  1F
0F40:  BZ    101C
0F42:  MOVF   x46,W
0F44:  SUBLW  01
0F46:  BNC   101C
0F48:  BNZ   0F50
0F4A:  MOVF   x45,W
0F4C:  SUBLW  F3
0F4E:  BNC   101C
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0F50:  CLRF   x4B
0F52:  MOVFF  846,84D
0F56:  MOVFF  845,84C
0F5A:  MOVFF  842,84F
0F5E:  MOVFF  841,84E
0F62:  MOVLB  0
0F64:  RCALL  0910
0F66:  MOVF   01,W
0F68:  MOVLB  8
0F6A:  ANDWF  x4A,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0F6C:  MOVLW  04
0F6E:  ADDWF  x45,W
0F70:  MOVWF  x4B
0F72:  MOVLW  00
0F74:  ADDWFC x46,W
0F76:  MOVWF  x4C
0F78:  MOVF   x41,W
0F7A:  ADDWF  x4B,W
0F7C:  MOVWF  FE9
0F7E:  MOVF   x42,W
0F80:  ADDWFC x4C,W
0F82:  MOVWF  FEA
0F84:  MOVFF  FEF,84D
0F88:  MOVLW  03
0F8A:  ADDWF  x45,W
0F8C:  MOVWF  x4E
0F8E:  MOVLW  00
0F90:  ADDWFC x46,W
0F92:  MOVWF  x4F
0F94:  MOVF   x41,W
0F96:  ADDWF  x4E,W
0F98:  MOVWF  FE9
0F9A:  MOVF   x42,W
0F9C:  ADDWFC x4F,W
0F9E:  MOVWF  FEA
0FA0:  MOVFF  FEF,850
0FA4:  MOVLW  02
0FA6:  ADDWF  x45,W
0FA8:  MOVWF  x51
0FAA:  MOVLW  00
0FAC:  ADDWFC x46,W
0FAE:  MOVWF  x52
0FB0:  MOVF   x41,W
0FB2:  ADDWF  x51,W
0FB4:  MOVWF  FE9
0FB6:  MOVF   x42,W
0FB8:  ADDWFC x52,W
0FBA:  MOVWF  FEA
0FBC:  MOVFF  FEF,853
0FC0:  MOVLW  01
0FC2:  ADDWF  x45,W
0FC4:  MOVWF  x54
0FC6:  MOVLW  00
0FC8:  ADDWFC x46,W
0FCA:  MOVWF  x55
0FCC:  MOVF   x41,W
0FCE:  ADDWF  x54,W
0FD0:  MOVWF  FE9
0FD2:  MOVF   x42,W
0FD4:  ADDWFC x55,W
0FD6:  MOVWF  FEA
0FD8:  MOVFF  FEF,856
0FDC:  MOVF   x41,W
0FDE:  ADDWF  x45,W
0FE0:  MOVWF  FE9
0FE2:  MOVF   x42,W
0FE4:  ADDWFC x46,W
0FE6:  MOVWF  FEA
0FE8:  MOVFF  FEF,857
0FEC:  CLRF   x60
0FEE:  CLRF   x61
0FF0:  CLRF   x62
0FF2:  MOVFF  84D,863
0FF6:  MOVFF  850,864
0FFA:  MOVFF  853,865
0FFE:  MOVFF  856,866
1002:  MOVFF  857,867
1006:  MOVLB  0
1008:  CALL   06FA
100C:  MOVFF  01,849
....................                   j=j+5; 
1010:  MOVLW  05
1012:  MOVLB  8
1014:  ADDWF  x45,F
1016:  MOVLW  00
1018:  ADDWFC x46,F
....................                } 
101A:  BRA    0F3C
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
101C:  DECFSZ x4A,W
101E:  BRA    1030
....................                { 
....................                   dir=0; 
1020:  MOVLB  6
1022:  CLRF   xCC
....................                   return i; 
1024:  MOVLB  8
1026:  MOVFF  843,01
102A:  MOVFF  844,02
102E:  BRA    164E
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
1030:  INCF   x43,F
1032:  BTFSC  FD8.2
1034:  INCF   x44,F
1036:  BRA    0A5E
....................    for(i=end_point;i>end_point/4;i--) 
1038:  MOVFF  840,844
103C:  MOVFF  83F,843
1040:  RRCF   x40,W
1042:  MOVWF  03
1044:  RRCF   x3F,W
1046:  MOVWF  02
1048:  RRCF   03,F
104A:  RRCF   02,F
104C:  MOVLW  3F
104E:  ANDWF  03,F
1050:  MOVFF  02,01
1054:  MOVF   03,W
1056:  SUBWF  x44,W
1058:  BTFSS  FD8.0
105A:  BRA    1648
105C:  BNZ   1066
105E:  MOVF   x43,W
1060:  SUBWF  01,W
1062:  BTFSC  FD8.0
1064:  BRA    1648
....................    { 
....................       if(track==0) 
1066:  MOVF   x3E,F
1068:  BTFSS  FD8.2
106A:  BRA    13BE
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
106C:  MOVLW  06
106E:  SUBWF  x43,W
1070:  MOVWF  x4B
1072:  MOVLW  00
1074:  SUBWFB x44,W
1076:  MOVWF  x4C
1078:  MOVF   x41,W
107A:  ADDWF  x4B,W
107C:  MOVWF  FE9
107E:  MOVF   x42,W
1080:  ADDWFC x4C,W
1082:  MOVWF  FEA
1084:  MOVFF  FEF,84D
1088:  MOVLW  05
108A:  SUBWF  x43,W
108C:  MOVWF  x4E
108E:  MOVLW  00
1090:  SUBWFB x44,W
1092:  MOVWF  x4F
1094:  MOVF   x41,W
1096:  ADDWF  x4E,W
1098:  MOVWF  FE9
109A:  MOVF   x42,W
109C:  ADDWFC x4F,W
109E:  MOVWF  FEA
10A0:  MOVFF  FEF,850
10A4:  MOVLW  04
10A6:  SUBWF  x43,W
10A8:  MOVWF  x51
10AA:  MOVLW  00
10AC:  SUBWFB x44,W
10AE:  MOVWF  x52
10B0:  MOVF   x41,W
10B2:  ADDWF  x51,W
10B4:  MOVWF  FE9
10B6:  MOVF   x42,W
10B8:  ADDWFC x52,W
10BA:  MOVWF  FEA
10BC:  MOVFF  FEF,853
10C0:  MOVLW  03
10C2:  SUBWF  x43,W
10C4:  MOVWF  x54
10C6:  MOVLW  00
10C8:  SUBWFB x44,W
10CA:  MOVWF  x55
10CC:  MOVF   x41,W
10CE:  ADDWF  x54,W
10D0:  MOVWF  FE9
10D2:  MOVF   x42,W
10D4:  ADDWFC x55,W
10D6:  MOVWF  FEA
10D8:  MOVFF  FEF,856
10DC:  MOVLW  02
10DE:  SUBWF  x43,W
10E0:  MOVWF  x57
10E2:  MOVLW  00
10E4:  SUBWFB x44,W
10E6:  MOVWF  x58
10E8:  MOVF   x41,W
10EA:  ADDWF  x57,W
10EC:  MOVWF  FE9
10EE:  MOVF   x42,W
10F0:  ADDWFC x58,W
10F2:  MOVWF  FEA
10F4:  MOVFF  FEF,859
10F8:  MOVLW  01
10FA:  SUBWF  x43,W
10FC:  MOVWF  x5A
10FE:  MOVLW  00
1100:  SUBWFB x44,W
1102:  MOVWF  x5B
1104:  MOVF   x41,W
1106:  ADDWF  x5A,W
1108:  MOVWF  FE9
110A:  MOVF   x42,W
110C:  ADDWFC x5B,W
110E:  MOVWF  FEA
1110:  MOVFF  FEF,85C
1114:  MOVF   x41,W
1116:  ADDWF  x43,W
1118:  MOVWF  FE9
111A:  MOVF   x42,W
111C:  ADDWFC x44,W
111E:  MOVWF  FEA
1120:  MOVFF  FEF,85D
1124:  CLRF   x60
1126:  MOVFF  84D,861
112A:  MOVFF  850,862
112E:  MOVFF  853,863
1132:  MOVFF  856,864
1136:  MOVFF  859,865
113A:  MOVFF  85C,866
113E:  MOVFF  85D,867
1142:  MOVLB  0
1144:  CALL   06FA
1148:  MOVFF  01,847
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
114C:  MOVLW  0D
114E:  MOVLB  8
1150:  SUBWF  x43,W
1152:  MOVWF  x4B
1154:  MOVLW  00
1156:  SUBWFB x44,W
1158:  MOVWF  x4C
115A:  MOVF   x41,W
115C:  ADDWF  x4B,W
115E:  MOVWF  FE9
1160:  MOVF   x42,W
1162:  ADDWFC x4C,W
1164:  MOVWF  FEA
1166:  MOVFF  FEF,84D
116A:  MOVLW  0C
116C:  SUBWF  x43,W
116E:  MOVWF  x4E
1170:  MOVLW  00
1172:  SUBWFB x44,W
1174:  MOVWF  x4F
1176:  MOVF   x41,W
1178:  ADDWF  x4E,W
117A:  MOVWF  FE9
117C:  MOVF   x42,W
117E:  ADDWFC x4F,W
1180:  MOVWF  FEA
1182:  MOVFF  FEF,850
1186:  MOVLW  0B
1188:  SUBWF  x43,W
118A:  MOVWF  x51
118C:  MOVLW  00
118E:  SUBWFB x44,W
1190:  MOVWF  x52
1192:  MOVF   x41,W
1194:  ADDWF  x51,W
1196:  MOVWF  FE9
1198:  MOVF   x42,W
119A:  ADDWFC x52,W
119C:  MOVWF  FEA
119E:  MOVFF  FEF,853
11A2:  MOVLW  0A
11A4:  SUBWF  x43,W
11A6:  MOVWF  x54
11A8:  MOVLW  00
11AA:  SUBWFB x44,W
11AC:  MOVWF  x55
11AE:  MOVF   x41,W
11B0:  ADDWF  x54,W
11B2:  MOVWF  FE9
11B4:  MOVF   x42,W
11B6:  ADDWFC x55,W
11B8:  MOVWF  FEA
11BA:  MOVFF  FEF,856
11BE:  MOVLW  09
11C0:  SUBWF  x43,W
11C2:  MOVWF  x57
11C4:  MOVLW  00
11C6:  SUBWFB x44,W
11C8:  MOVWF  x58
11CA:  MOVF   x41,W
11CC:  ADDWF  x57,W
11CE:  MOVWF  FE9
11D0:  MOVF   x42,W
11D2:  ADDWFC x58,W
11D4:  MOVWF  FEA
11D6:  MOVFF  FEF,859
11DA:  MOVLW  08
11DC:  SUBWF  x43,W
11DE:  MOVWF  x5A
11E0:  MOVLW  00
11E2:  SUBWFB x44,W
11E4:  MOVWF  x5B
11E6:  MOVF   x41,W
11E8:  ADDWF  x5A,W
11EA:  MOVWF  FE9
11EC:  MOVF   x42,W
11EE:  ADDWFC x5B,W
11F0:  MOVWF  FEA
11F2:  MOVFF  FEF,85C
11F6:  MOVLW  07
11F8:  SUBWF  x43,W
11FA:  MOVWF  x5D
11FC:  MOVLW  00
11FE:  SUBWFB x44,W
1200:  MOVWF  x5E
1202:  MOVF   x41,W
1204:  ADDWF  x5D,W
1206:  MOVWF  FE9
1208:  MOVF   x42,W
120A:  ADDWFC x5E,W
120C:  MOVWF  FEA
120E:  MOVFF  FEF,85F
1212:  CLRF   x60
1214:  MOVFF  84D,861
1218:  MOVFF  850,862
121C:  MOVFF  853,863
1220:  MOVFF  856,864
1224:  MOVFF  859,865
1228:  MOVFF  85C,866
122C:  MOVFF  85F,867
1230:  MOVLB  0
1232:  CALL   06FA
1236:  MOVFF  01,848
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
123A:  MOVLB  8
123C:  MOVF   x47,W
123E:  SUBLW  45
1240:  BTFSS  FD8.2
1242:  BRA    13BC
1244:  MOVF   x48,W
1246:  SUBLW  7C
1248:  BTFSC  FD8.2
124A:  BRA    13BC
124C:  MOVF   x48,W
124E:  SUBLW  3E
1250:  BTFSC  FD8.2
1252:  BRA    13BC
1254:  MOVF   x48,W
1256:  SUBLW  1F
1258:  BTFSC  FD8.2
125A:  BRA    13BC
125C:  MOVF   x48,W
125E:  SUBLW  0F
1260:  BTFSC  FD8.2
1262:  BRA    13BC
1264:  MOVF   x48,W
1266:  SUBLW  78
1268:  BTFSC  FD8.2
126A:  BRA    13BC
....................          { 
....................             j=i; 
126C:  MOVFF  844,846
1270:  MOVFF  843,845
....................             CRC=1; 
1274:  MOVLW  01
1276:  MOVWF  x4A
....................             temp2=temp; 
1278:  MOVFF  847,849
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
127C:  MOVF   x49,W
127E:  SUBLW  1F
1280:  BTFSC  FD8.2
1282:  BRA    139C
1284:  MOVF   x46,F
1286:  BNZ   1290
1288:  MOVF   x45,W
128A:  SUBLW  01
128C:  BTFSC  FD8.0
128E:  BRA    139C
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1290:  MOVLW  01
1292:  MOVWF  x4B
1294:  MOVFF  846,84D
1298:  MOVFF  845,84C
129C:  MOVFF  842,84F
12A0:  MOVFF  841,84E
12A4:  MOVLB  0
12A6:  CALL   0760
12AA:  MOVF   01,W
12AC:  MOVLB  8
12AE:  ANDWF  x4A,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
12B0:  MOVLW  06
12B2:  SUBWF  x45,W
12B4:  MOVWF  x4B
12B6:  MOVLW  00
12B8:  SUBWFB x46,W
12BA:  MOVWF  x4C
12BC:  MOVF   x41,W
12BE:  ADDWF  x4B,W
12C0:  MOVWF  FE9
12C2:  MOVF   x42,W
12C4:  ADDWFC x4C,W
12C6:  MOVWF  FEA
12C8:  MOVFF  FEF,84D
12CC:  MOVLW  05
12CE:  SUBWF  x45,W
12D0:  MOVWF  x4E
12D2:  MOVLW  00
12D4:  SUBWFB x46,W
12D6:  MOVWF  x4F
12D8:  MOVF   x41,W
12DA:  ADDWF  x4E,W
12DC:  MOVWF  FE9
12DE:  MOVF   x42,W
12E0:  ADDWFC x4F,W
12E2:  MOVWF  FEA
12E4:  MOVFF  FEF,850
12E8:  MOVLW  04
12EA:  SUBWF  x45,W
12EC:  MOVWF  x51
12EE:  MOVLW  00
12F0:  SUBWFB x46,W
12F2:  MOVWF  x52
12F4:  MOVF   x41,W
12F6:  ADDWF  x51,W
12F8:  MOVWF  FE9
12FA:  MOVF   x42,W
12FC:  ADDWFC x52,W
12FE:  MOVWF  FEA
1300:  MOVFF  FEF,853
1304:  MOVLW  03
1306:  SUBWF  x45,W
1308:  MOVWF  x54
130A:  MOVLW  00
130C:  SUBWFB x46,W
130E:  MOVWF  x55
1310:  MOVF   x41,W
1312:  ADDWF  x54,W
1314:  MOVWF  FE9
1316:  MOVF   x42,W
1318:  ADDWFC x55,W
131A:  MOVWF  FEA
131C:  MOVFF  FEF,856
1320:  MOVLW  02
1322:  SUBWF  x45,W
1324:  MOVWF  x57
1326:  MOVLW  00
1328:  SUBWFB x46,W
132A:  MOVWF  x58
132C:  MOVF   x41,W
132E:  ADDWF  x57,W
1330:  MOVWF  FE9
1332:  MOVF   x42,W
1334:  ADDWFC x58,W
1336:  MOVWF  FEA
1338:  MOVFF  FEF,859
133C:  MOVLW  01
133E:  SUBWF  x45,W
1340:  MOVWF  x5A
1342:  MOVLW  00
1344:  SUBWFB x46,W
1346:  MOVWF  x5B
1348:  MOVF   x41,W
134A:  ADDWF  x5A,W
134C:  MOVWF  FE9
134E:  MOVF   x42,W
1350:  ADDWFC x5B,W
1352:  MOVWF  FEA
1354:  MOVFF  FEF,85C
1358:  MOVF   x41,W
135A:  ADDWF  x45,W
135C:  MOVWF  FE9
135E:  MOVF   x42,W
1360:  ADDWFC x46,W
1362:  MOVWF  FEA
1364:  MOVFF  FEF,85D
1368:  CLRF   x60
136A:  MOVFF  84D,861
136E:  MOVFF  850,862
1372:  MOVFF  853,863
1376:  MOVFF  856,864
137A:  MOVFF  859,865
137E:  MOVFF  85C,866
1382:  MOVFF  85D,867
1386:  MOVLB  0
1388:  CALL   06FA
138C:  MOVFF  01,849
....................                j=j-7;             
1390:  MOVLW  07
1392:  MOVLB  8
1394:  SUBWF  x45,F
1396:  MOVLW  00
1398:  SUBWFB x46,F
....................              } 
139A:  BRA    127C
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
139C:  DECFSZ x4A,W
139E:  BRA    13B4
....................             { 
....................                dir=1; 
13A0:  MOVLW  01
13A2:  MOVLB  6
13A4:  MOVWF  xCC
....................                return i; 
13A6:  MOVLB  8
13A8:  MOVFF  843,01
13AC:  MOVFF  844,02
13B0:  BRA    164E
....................             } 
....................             else return 0; 
13B2:  BRA    13BC
13B4:  MOVLW  00
13B6:  MOVWF  01
13B8:  MOVWF  02
13BA:  BRA    164E
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
13BC:  BRA    163E
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
13BE:  MOVLW  04
13C0:  SUBWF  x43,W
13C2:  MOVWF  x4B
13C4:  MOVLW  00
13C6:  SUBWFB x44,W
13C8:  MOVWF  x4C
13CA:  MOVF   x41,W
13CC:  ADDWF  x4B,W
13CE:  MOVWF  FE9
13D0:  MOVF   x42,W
13D2:  ADDWFC x4C,W
13D4:  MOVWF  FEA
13D6:  MOVFF  FEF,84D
13DA:  MOVLW  03
13DC:  SUBWF  x43,W
13DE:  MOVWF  x4E
13E0:  MOVLW  00
13E2:  SUBWFB x44,W
13E4:  MOVWF  x4F
13E6:  MOVF   x41,W
13E8:  ADDWF  x4E,W
13EA:  MOVWF  FE9
13EC:  MOVF   x42,W
13EE:  ADDWFC x4F,W
13F0:  MOVWF  FEA
13F2:  MOVFF  FEF,850
13F6:  MOVLW  02
13F8:  SUBWF  x43,W
13FA:  MOVWF  x51
13FC:  MOVLW  00
13FE:  SUBWFB x44,W
1400:  MOVWF  x52
1402:  MOVF   x41,W
1404:  ADDWF  x51,W
1406:  MOVWF  FE9
1408:  MOVF   x42,W
140A:  ADDWFC x52,W
140C:  MOVWF  FEA
140E:  MOVFF  FEF,853
1412:  MOVLW  01
1414:  SUBWF  x43,W
1416:  MOVWF  x54
1418:  MOVLW  00
141A:  SUBWFB x44,W
141C:  MOVWF  x55
141E:  MOVF   x41,W
1420:  ADDWF  x54,W
1422:  MOVWF  FE9
1424:  MOVF   x42,W
1426:  ADDWFC x55,W
1428:  MOVWF  FEA
142A:  MOVFF  FEF,856
142E:  MOVF   x41,W
1430:  ADDWF  x43,W
1432:  MOVWF  FE9
1434:  MOVF   x42,W
1436:  ADDWFC x44,W
1438:  MOVWF  FEA
143A:  MOVFF  FEF,857
143E:  CLRF   x60
1440:  CLRF   x61
1442:  CLRF   x62
1444:  MOVFF  84D,863
1448:  MOVFF  850,864
144C:  MOVFF  853,865
1450:  MOVFF  856,866
1454:  MOVFF  857,867
1458:  MOVLB  0
145A:  CALL   06FA
145E:  MOVFF  01,847
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1462:  MOVLW  09
1464:  MOVLB  8
1466:  SUBWF  x43,W
1468:  MOVWF  x4B
146A:  MOVLW  00
146C:  SUBWFB x44,W
146E:  MOVWF  x4C
1470:  MOVF   x41,W
1472:  ADDWF  x4B,W
1474:  MOVWF  FE9
1476:  MOVF   x42,W
1478:  ADDWFC x4C,W
147A:  MOVWF  FEA
147C:  MOVFF  FEF,84D
1480:  MOVLW  08
1482:  SUBWF  x43,W
1484:  MOVWF  x4E
1486:  MOVLW  00
1488:  SUBWFB x44,W
148A:  MOVWF  x4F
148C:  MOVF   x41,W
148E:  ADDWF  x4E,W
1490:  MOVWF  FE9
1492:  MOVF   x42,W
1494:  ADDWFC x4F,W
1496:  MOVWF  FEA
1498:  MOVFF  FEF,850
149C:  MOVLW  07
149E:  SUBWF  x43,W
14A0:  MOVWF  x51
14A2:  MOVLW  00
14A4:  SUBWFB x44,W
14A6:  MOVWF  x52
14A8:  MOVF   x41,W
14AA:  ADDWF  x51,W
14AC:  MOVWF  FE9
14AE:  MOVF   x42,W
14B0:  ADDWFC x52,W
14B2:  MOVWF  FEA
14B4:  MOVFF  FEF,853
14B8:  MOVLW  06
14BA:  SUBWF  x43,W
14BC:  MOVWF  x54
14BE:  MOVLW  00
14C0:  SUBWFB x44,W
14C2:  MOVWF  x55
14C4:  MOVF   x41,W
14C6:  ADDWF  x54,W
14C8:  MOVWF  FE9
14CA:  MOVF   x42,W
14CC:  ADDWFC x55,W
14CE:  MOVWF  FEA
14D0:  MOVFF  FEF,856
14D4:  MOVLW  05
14D6:  SUBWF  x43,W
14D8:  MOVWF  x57
14DA:  MOVLW  00
14DC:  SUBWFB x44,W
14DE:  MOVWF  x58
14E0:  MOVF   x41,W
14E2:  ADDWF  x57,W
14E4:  MOVWF  FE9
14E6:  MOVF   x42,W
14E8:  ADDWFC x58,W
14EA:  MOVWF  FEA
14EC:  MOVFF  FEF,859
14F0:  CLRF   x60
14F2:  CLRF   x61
14F4:  CLRF   x62
14F6:  MOVFF  84D,863
14FA:  MOVFF  850,864
14FE:  MOVFF  853,865
1502:  MOVFF  856,866
1506:  MOVFF  859,867
150A:  MOVLB  0
150C:  CALL   06FA
1510:  MOVFF  01,848
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
1514:  MOVLB  8
1516:  MOVF   x47,W
1518:  SUBLW  0B
151A:  BTFSS  FD8.2
151C:  BRA    163E
151E:  MOVF   x48,W
1520:  SUBLW  1F
1522:  BTFSC  FD8.2
1524:  BRA    163E
1526:  MOVF   x48,W
1528:  SUBLW  0F
152A:  BTFSC  FD8.2
152C:  BRA    163E
....................             { 
....................                j=i; 
152E:  MOVFF  844,846
1532:  MOVFF  843,845
....................                CRC=1; 
1536:  MOVLW  01
1538:  MOVWF  x4A
....................                temp2=temp; 
153A:  MOVFF  847,849
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
153E:  MOVF   x49,W
1540:  SUBLW  1F
1542:  BZ    161E
1544:  MOVF   x46,F
1546:  BNZ   154E
1548:  MOVF   x45,W
154A:  SUBLW  01
154C:  BC    161E
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
154E:  MOVLW  01
1550:  MOVWF  x4B
1552:  MOVFF  846,84D
1556:  MOVFF  845,84C
155A:  MOVFF  842,84F
155E:  MOVFF  841,84E
1562:  MOVLB  0
1564:  CALL   0910
1568:  MOVF   01,W
156A:  MOVLB  8
156C:  ANDWF  x4A,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
156E:  MOVLW  04
1570:  SUBWF  x45,W
1572:  MOVWF  x4B
1574:  MOVLW  00
1576:  SUBWFB x46,W
1578:  MOVWF  x4C
157A:  MOVF   x41,W
157C:  ADDWF  x4B,W
157E:  MOVWF  FE9
1580:  MOVF   x42,W
1582:  ADDWFC x4C,W
1584:  MOVWF  FEA
1586:  MOVFF  FEF,84D
158A:  MOVLW  03
158C:  SUBWF  x45,W
158E:  MOVWF  x4E
1590:  MOVLW  00
1592:  SUBWFB x46,W
1594:  MOVWF  x4F
1596:  MOVF   x41,W
1598:  ADDWF  x4E,W
159A:  MOVWF  FE9
159C:  MOVF   x42,W
159E:  ADDWFC x4F,W
15A0:  MOVWF  FEA
15A2:  MOVFF  FEF,850
15A6:  MOVLW  02
15A8:  SUBWF  x45,W
15AA:  MOVWF  x51
15AC:  MOVLW  00
15AE:  SUBWFB x46,W
15B0:  MOVWF  x52
15B2:  MOVF   x41,W
15B4:  ADDWF  x51,W
15B6:  MOVWF  FE9
15B8:  MOVF   x42,W
15BA:  ADDWFC x52,W
15BC:  MOVWF  FEA
15BE:  MOVFF  FEF,853
15C2:  MOVLW  01
15C4:  SUBWF  x45,W
15C6:  MOVWF  x54
15C8:  MOVLW  00
15CA:  SUBWFB x46,W
15CC:  MOVWF  x55
15CE:  MOVF   x41,W
15D0:  ADDWF  x54,W
15D2:  MOVWF  FE9
15D4:  MOVF   x42,W
15D6:  ADDWFC x55,W
15D8:  MOVWF  FEA
15DA:  MOVFF  FEF,856
15DE:  MOVF   x41,W
15E0:  ADDWF  x45,W
15E2:  MOVWF  FE9
15E4:  MOVF   x42,W
15E6:  ADDWFC x46,W
15E8:  MOVWF  FEA
15EA:  MOVFF  FEF,857
15EE:  CLRF   x60
15F0:  CLRF   x61
15F2:  CLRF   x62
15F4:  MOVFF  84D,863
15F8:  MOVFF  850,864
15FC:  MOVFF  853,865
1600:  MOVFF  856,866
1604:  MOVFF  857,867
1608:  MOVLB  0
160A:  CALL   06FA
160E:  MOVFF  01,849
....................                   j=j-5; 
1612:  MOVLW  05
1614:  MOVLB  8
1616:  SUBWF  x45,F
1618:  MOVLW  00
161A:  SUBWFB x46,F
....................                } 
161C:  BRA    153E
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
161E:  DECFSZ x4A,W
1620:  BRA    1636
....................                { 
....................                   dir=1; 
1622:  MOVLW  01
1624:  MOVLB  6
1626:  MOVWF  xCC
....................                   return i; 
1628:  MOVLB  8
162A:  MOVFF  843,01
162E:  MOVFF  844,02
1632:  BRA    164E
....................                } 
....................                   else return 0; 
1634:  BRA    163E
1636:  MOVLW  00
1638:  MOVWF  01
163A:  MOVWF  02
163C:  BRA    164E
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
163E:  MOVF   x43,W
1640:  BTFSC  FD8.2
1642:  DECF   x44,F
1644:  DECF   x43,F
1646:  BRA    1040
....................    return 0; 
1648:  MOVLW  00
164A:  MOVWF  01
164C:  MOVWF  02
.................... } 
164E:  MOVLB  0
1650:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
36B6:  MOVLB  8
36B8:  CLRF   x3D
36BA:  MOVLW  01
36BC:  MOVWF  x3C
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
36BE:  MOVFF  832,83E
36C2:  MOVFF  834,840
36C6:  MOVFF  833,83F
36CA:  MOVFF  836,842
36CE:  MOVFF  835,841
36D2:  MOVLB  0
36D4:  CALL   0A50
36D8:  MOVFF  02,83D
36DC:  MOVFF  01,83C
....................    if(temp==0) return 0; 
36E0:  MOVLB  8
36E2:  MOVF   x3C,F
36E4:  BNZ   36F0
36E6:  MOVF   x3D,F
36E8:  BNZ   36F0
36EA:  MOVLW  00
36EC:  MOVWF  01
36EE:  BRA    3A9A
....................    j=temp; 
36F0:  MOVFF  83D,83B
36F4:  MOVFF  83C,83A
....................    if(dir==0) 
36F8:  MOVLB  6
36FA:  MOVF   xCC,F
36FC:  BTFSS  FD8.2
36FE:  BRA    38BA
....................    { 
....................       if(track==0) 
3700:  MOVLB  8
3702:  MOVF   x32,F
3704:  BTFSS  FD8.2
3706:  BRA    37FE
....................       { 
....................             for(i=0;i<79;i++) 
3708:  CLRF   x39
370A:  MOVF   x39,W
370C:  SUBLW  4E
370E:  BNC   37FC
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3710:  CLRF   03
3712:  MOVF   x39,W
3714:  ADDWF  x37,W
3716:  MOVWF  01
3718:  MOVF   x38,W
371A:  ADDWFC 03,F
371C:  MOVFF  01,83E
3720:  MOVFF  03,83F
3724:  MOVLW  05
3726:  ADDWF  x3A,W
3728:  MOVWF  x40
372A:  MOVLW  00
372C:  ADDWFC x3B,W
372E:  MOVWF  x41
3730:  MOVF   x35,W
3732:  ADDWF  x40,W
3734:  MOVWF  FE9
3736:  MOVF   x36,W
3738:  ADDWFC x41,W
373A:  MOVWF  FEA
373C:  MOVFF  FEF,842
3740:  MOVLW  04
3742:  ADDWF  x3A,W
3744:  MOVWF  x43
3746:  MOVLW  00
3748:  ADDWFC x3B,W
374A:  MOVWF  x44
374C:  MOVF   x35,W
374E:  ADDWF  x43,W
3750:  MOVWF  FE9
3752:  MOVF   x36,W
3754:  ADDWFC x44,W
3756:  MOVWF  FEA
3758:  MOVFF  FEF,845
375C:  MOVLW  03
375E:  ADDWF  x3A,W
3760:  MOVWF  x46
3762:  MOVLW  00
3764:  ADDWFC x3B,W
3766:  MOVWF  x47
3768:  MOVF   x35,W
376A:  ADDWF  x46,W
376C:  MOVWF  FE9
376E:  MOVF   x36,W
3770:  ADDWFC x47,W
3772:  MOVWF  FEA
3774:  MOVFF  FEF,848
3778:  MOVLW  02
377A:  ADDWF  x3A,W
377C:  MOVWF  x49
377E:  MOVLW  00
3780:  ADDWFC x3B,W
3782:  MOVWF  x4A
3784:  MOVF   x35,W
3786:  ADDWF  x49,W
3788:  MOVWF  FE9
378A:  MOVF   x36,W
378C:  ADDWFC x4A,W
378E:  MOVWF  FEA
3790:  MOVFF  FEF,84B
3794:  MOVLW  01
3796:  ADDWF  x3A,W
3798:  MOVWF  x4C
379A:  MOVLW  00
379C:  ADDWFC x3B,W
379E:  MOVWF  x4D
37A0:  MOVF   x35,W
37A2:  ADDWF  x4C,W
37A4:  MOVWF  FE9
37A6:  MOVF   x36,W
37A8:  ADDWFC x4D,W
37AA:  MOVWF  FEA
37AC:  MOVFF  FEF,84E
37B0:  MOVF   x35,W
37B2:  ADDWF  x3A,W
37B4:  MOVWF  FE9
37B6:  MOVF   x36,W
37B8:  ADDWFC x3B,W
37BA:  MOVWF  FEA
37BC:  MOVFF  FEF,84F
37C0:  CLRF   x60
37C2:  CLRF   x61
37C4:  MOVFF  842,862
37C8:  MOVFF  845,863
37CC:  MOVFF  848,864
37D0:  MOVFF  84B,865
37D4:  MOVFF  84E,866
37D8:  MOVFF  84F,867
37DC:  MOVLB  0
37DE:  CALL   06FA
37E2:  MOVFF  83F,FEA
37E6:  MOVFF  83E,FE9
37EA:  MOVFF  01,FEF
....................                j=j+7; 
37EE:  MOVLW  07
37F0:  MOVLB  8
37F2:  ADDWF  x3A,F
37F4:  MOVLW  00
37F6:  ADDWFC x3B,F
....................             } 
37F8:  INCF   x39,F
37FA:  BRA    370A
....................       } 
....................          else  
37FC:  BRA    38B6
....................          { 
....................             for(i=0;i<40;i++) 
37FE:  CLRF   x39
3800:  MOVF   x39,W
3802:  SUBLW  27
3804:  BNC   38B6
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3806:  CLRF   03
3808:  MOVF   x39,W
380A:  ADDWF  x37,W
380C:  MOVWF  01
380E:  MOVF   x38,W
3810:  ADDWFC 03,F
3812:  MOVFF  01,83E
3816:  MOVFF  03,83F
381A:  MOVLW  03
381C:  ADDWF  x3A,W
381E:  MOVWF  x40
3820:  MOVLW  00
3822:  ADDWFC x3B,W
3824:  MOVWF  x41
3826:  MOVF   x35,W
3828:  ADDWF  x40,W
382A:  MOVWF  FE9
382C:  MOVF   x36,W
382E:  ADDWFC x41,W
3830:  MOVWF  FEA
3832:  MOVFF  FEF,842
3836:  MOVLW  02
3838:  ADDWF  x3A,W
383A:  MOVWF  x43
383C:  MOVLW  00
383E:  ADDWFC x3B,W
3840:  MOVWF  x44
3842:  MOVF   x35,W
3844:  ADDWF  x43,W
3846:  MOVWF  FE9
3848:  MOVF   x36,W
384A:  ADDWFC x44,W
384C:  MOVWF  FEA
384E:  MOVFF  FEF,845
3852:  MOVLW  01
3854:  ADDWF  x3A,W
3856:  MOVWF  x46
3858:  MOVLW  00
385A:  ADDWFC x3B,W
385C:  MOVWF  x47
385E:  MOVF   x35,W
3860:  ADDWF  x46,W
3862:  MOVWF  FE9
3864:  MOVF   x36,W
3866:  ADDWFC x47,W
3868:  MOVWF  FEA
386A:  MOVFF  FEF,848
386E:  MOVF   x35,W
3870:  ADDWF  x3A,W
3872:  MOVWF  FE9
3874:  MOVF   x36,W
3876:  ADDWFC x3B,W
3878:  MOVWF  FEA
387A:  MOVFF  FEF,849
387E:  CLRF   x60
3880:  CLRF   x61
3882:  CLRF   x62
3884:  CLRF   x63
3886:  MOVFF  842,864
388A:  MOVFF  845,865
388E:  MOVFF  848,866
3892:  MOVFF  849,867
3896:  MOVLB  0
3898:  CALL   06FA
389C:  MOVFF  83F,FEA
38A0:  MOVFF  83E,FE9
38A4:  MOVFF  01,FEF
....................                j=j+5; 
38A8:  MOVLW  05
38AA:  MOVLB  8
38AC:  ADDWF  x3A,F
38AE:  MOVLW  00
38B0:  ADDWFC x3B,F
....................             }          
38B2:  INCF   x39,F
38B4:  BRA    3800
....................          } 
....................    } 
....................       else  
38B6:  BRA    3A70
38B8:  MOVLB  6
....................       { 
....................          if(track==0) 
38BA:  MOVLB  8
38BC:  MOVF   x32,F
38BE:  BTFSS  FD8.2
38C0:  BRA    39B8
....................          { 
....................             for(i=0;i<79;i++) 
38C2:  CLRF   x39
38C4:  MOVF   x39,W
38C6:  SUBLW  4E
38C8:  BNC   39B6
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
38CA:  CLRF   03
38CC:  MOVF   x39,W
38CE:  ADDWF  x37,W
38D0:  MOVWF  01
38D2:  MOVF   x38,W
38D4:  ADDWFC 03,F
38D6:  MOVFF  01,83E
38DA:  MOVFF  03,83F
38DE:  MOVLW  05
38E0:  SUBWF  x3A,W
38E2:  MOVWF  x40
38E4:  MOVLW  00
38E6:  SUBWFB x3B,W
38E8:  MOVWF  x41
38EA:  MOVF   x35,W
38EC:  ADDWF  x40,W
38EE:  MOVWF  FE9
38F0:  MOVF   x36,W
38F2:  ADDWFC x41,W
38F4:  MOVWF  FEA
38F6:  MOVFF  FEF,842
38FA:  MOVLW  04
38FC:  SUBWF  x3A,W
38FE:  MOVWF  x43
3900:  MOVLW  00
3902:  SUBWFB x3B,W
3904:  MOVWF  x44
3906:  MOVF   x35,W
3908:  ADDWF  x43,W
390A:  MOVWF  FE9
390C:  MOVF   x36,W
390E:  ADDWFC x44,W
3910:  MOVWF  FEA
3912:  MOVFF  FEF,845
3916:  MOVLW  03
3918:  SUBWF  x3A,W
391A:  MOVWF  x46
391C:  MOVLW  00
391E:  SUBWFB x3B,W
3920:  MOVWF  x47
3922:  MOVF   x35,W
3924:  ADDWF  x46,W
3926:  MOVWF  FE9
3928:  MOVF   x36,W
392A:  ADDWFC x47,W
392C:  MOVWF  FEA
392E:  MOVFF  FEF,848
3932:  MOVLW  02
3934:  SUBWF  x3A,W
3936:  MOVWF  x49
3938:  MOVLW  00
393A:  SUBWFB x3B,W
393C:  MOVWF  x4A
393E:  MOVF   x35,W
3940:  ADDWF  x49,W
3942:  MOVWF  FE9
3944:  MOVF   x36,W
3946:  ADDWFC x4A,W
3948:  MOVWF  FEA
394A:  MOVFF  FEF,84B
394E:  MOVLW  01
3950:  SUBWF  x3A,W
3952:  MOVWF  x4C
3954:  MOVLW  00
3956:  SUBWFB x3B,W
3958:  MOVWF  x4D
395A:  MOVF   x35,W
395C:  ADDWF  x4C,W
395E:  MOVWF  FE9
3960:  MOVF   x36,W
3962:  ADDWFC x4D,W
3964:  MOVWF  FEA
3966:  MOVFF  FEF,84E
396A:  MOVF   x35,W
396C:  ADDWF  x3A,W
396E:  MOVWF  FE9
3970:  MOVF   x36,W
3972:  ADDWFC x3B,W
3974:  MOVWF  FEA
3976:  MOVFF  FEF,84F
397A:  CLRF   x60
397C:  CLRF   x61
397E:  MOVFF  842,862
3982:  MOVFF  845,863
3986:  MOVFF  848,864
398A:  MOVFF  84B,865
398E:  MOVFF  84E,866
3992:  MOVFF  84F,867
3996:  MOVLB  0
3998:  CALL   06FA
399C:  MOVFF  83F,FEA
39A0:  MOVFF  83E,FE9
39A4:  MOVFF  01,FEF
....................                j=j-7; 
39A8:  MOVLW  07
39AA:  MOVLB  8
39AC:  SUBWF  x3A,F
39AE:  MOVLW  00
39B0:  SUBWFB x3B,F
....................             } 
39B2:  INCF   x39,F
39B4:  BRA    38C4
....................          } 
....................             else 
39B6:  BRA    3A70
....................             { 
....................                for(i=0;i<40;i++) 
39B8:  CLRF   x39
39BA:  MOVF   x39,W
39BC:  SUBLW  27
39BE:  BNC   3A70
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
39C0:  CLRF   03
39C2:  MOVF   x39,W
39C4:  ADDWF  x37,W
39C6:  MOVWF  01
39C8:  MOVF   x38,W
39CA:  ADDWFC 03,F
39CC:  MOVFF  01,83E
39D0:  MOVFF  03,83F
39D4:  MOVLW  03
39D6:  SUBWF  x3A,W
39D8:  MOVWF  x40
39DA:  MOVLW  00
39DC:  SUBWFB x3B,W
39DE:  MOVWF  x41
39E0:  MOVF   x35,W
39E2:  ADDWF  x40,W
39E4:  MOVWF  FE9
39E6:  MOVF   x36,W
39E8:  ADDWFC x41,W
39EA:  MOVWF  FEA
39EC:  MOVFF  FEF,842
39F0:  MOVLW  02
39F2:  SUBWF  x3A,W
39F4:  MOVWF  x43
39F6:  MOVLW  00
39F8:  SUBWFB x3B,W
39FA:  MOVWF  x44
39FC:  MOVF   x35,W
39FE:  ADDWF  x43,W
3A00:  MOVWF  FE9
3A02:  MOVF   x36,W
3A04:  ADDWFC x44,W
3A06:  MOVWF  FEA
3A08:  MOVFF  FEF,845
3A0C:  MOVLW  01
3A0E:  SUBWF  x3A,W
3A10:  MOVWF  x46
3A12:  MOVLW  00
3A14:  SUBWFB x3B,W
3A16:  MOVWF  x47
3A18:  MOVF   x35,W
3A1A:  ADDWF  x46,W
3A1C:  MOVWF  FE9
3A1E:  MOVF   x36,W
3A20:  ADDWFC x47,W
3A22:  MOVWF  FEA
3A24:  MOVFF  FEF,848
3A28:  MOVF   x35,W
3A2A:  ADDWF  x3A,W
3A2C:  MOVWF  FE9
3A2E:  MOVF   x36,W
3A30:  ADDWFC x3B,W
3A32:  MOVWF  FEA
3A34:  MOVFF  FEF,849
3A38:  CLRF   x60
3A3A:  CLRF   x61
3A3C:  CLRF   x62
3A3E:  CLRF   x63
3A40:  MOVFF  842,864
3A44:  MOVFF  845,865
3A48:  MOVFF  848,866
3A4C:  MOVFF  849,867
3A50:  MOVLB  0
3A52:  CALL   06FA
3A56:  MOVFF  83F,FEA
3A5A:  MOVFF  83E,FE9
3A5E:  MOVFF  01,FEF
....................                   j=j-5; 
3A62:  MOVLW  05
3A64:  MOVLB  8
3A66:  SUBWF  x3A,F
3A68:  MOVLW  00
3A6A:  SUBWFB x3B,F
....................                }             
3A6C:  INCF   x39,F
3A6E:  BRA    39BA
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3A70:  MOVF   x32,F
3A72:  BNZ   3A88
3A74:  MOVLW  52
3A76:  MOVWF  x3E
3A78:  MOVFF  836,840
3A7C:  MOVFF  835,83F
3A80:  MOVLB  0
3A82:  RCALL  3694
....................          else del_buf(numbyteofbuffer2,datin); 
3A84:  BRA    3A98
3A86:  MOVLB  8
3A88:  MOVLW  2C
3A8A:  MOVWF  x3E
3A8C:  MOVFF  836,840
3A90:  MOVFF  835,83F
3A94:  MOVLB  0
3A96:  RCALL  3694
3A98:  MOVLB  8
.................... } 
3A9A:  MOVLB  0
3A9C:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
182A:  MOVLW  AA
182C:  MOVWF  FF6
182E:  MOVLW  05
1830:  MOVWF  FF7
1832:  CALL   06DA
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1836:  MOVLB  8
1838:  CLRF   x36
183A:  CLRF   x35
183C:  MOVF   x36,W
183E:  SUBLW  03
1840:  BNC   1870
1842:  BNZ   184A
1844:  MOVF   x35,W
1846:  SUBLW  51
1848:  BNC   1870
184A:  MOVLW  4A
184C:  ADDWF  x35,W
184E:  MOVWF  FE9
1850:  MOVLW  02
1852:  ADDWFC x36,W
1854:  MOVWF  FEA
1856:  MOVFF  FEF,837
185A:  MOVFF  837,838
185E:  MOVLW  18
1860:  MOVWF  x39
1862:  MOVLB  0
1864:  RCALL  1766
1866:  MOVLB  8
1868:  INCF   x35,F
186A:  BTFSC  FD8.2
186C:  INCF   x36,F
186E:  BRA    183C
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1870:  MOVLW  C0
1872:  MOVWF  FF6
1874:  MOVLW  05
1876:  MOVWF  FF7
1878:  MOVLB  0
187A:  CALL   06DA
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
187E:  MOVLB  8
1880:  CLRF   x36
1882:  CLRF   x35
1884:  MOVF   x36,W
1886:  SUBLW  01
1888:  BNC   18B8
188A:  BNZ   1892
188C:  MOVF   x35,W
188E:  SUBLW  2B
1890:  BNC   18B8
1892:  MOVLW  9C
1894:  ADDWF  x35,W
1896:  MOVWF  FE9
1898:  MOVLW  05
189A:  ADDWFC x36,W
189C:  MOVWF  FEA
189E:  MOVFF  FEF,837
18A2:  MOVFF  837,838
18A6:  MOVLW  18
18A8:  MOVWF  x39
18AA:  MOVLB  0
18AC:  RCALL  1766
18AE:  MOVLB  8
18B0:  INCF   x35,F
18B2:  BTFSC  FD8.2
18B4:  INCF   x36,F
18B6:  BRA    1884
.................... } 
18B8:  MOVLB  0
18BA:  GOTO   1B50 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3C2A:  MOVLW  01
3C2C:  MOVLB  6
3C2E:  MOVWF  xDC
....................    //rtc_get_date(date,mon,year,day); 
....................    //rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3C30:  MOVLB  0
3C32:  RCALL  361A
3C34:  MOVFF  02,833
3C38:  MOVFF  01,832
3C3C:  MOVFF  02,835
3C40:  MOVFF  01,834
3C44:  MOVLB  8
3C46:  CLRF   x37
3C48:  MOVLW  7C
3C4A:  MOVWF  x36
3C4C:  MOVLB  0
3C4E:  RCALL  3672
3C50:  MOVFF  01,832
3C54:  MOVLW  96
3C56:  MOVLB  8
3C58:  ADDWF  01,W
3C5A:  MOVWF  01
3C5C:  MOVLW  00
3C5E:  ADDWFC 02,W
3C60:  MOVFF  01,20
3C64:  MOVWF  21
3C66:  CLRF   22
3C68:  CLRF   23
....................    if(datinbuf==0)  
3C6A:  MOVLB  6
3C6C:  MOVF   xD9,F
3C6E:  BNZ   3C90
....................    { 
....................       countbit_T1=0; 
3C70:  CLRF   xCE
3C72:  CLRF   xCD
....................       countbit_T2=0; 
3C74:  CLRF   xD0
3C76:  CLRF   xCF
....................       bug_countbit_T1=0; 
3C78:  CLRF   xD2
3C7A:  CLRF   xD1
....................       bug_countbit_T2=0; 
3C7C:  CLRF   xD4
3C7E:  CLRF   xD3
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3C80:  MOVF   xDD,F
3C82:  BNZ   3C8C
3C84:  MOVLB  0
3C86:  SETF   xFC
3C88:  SETF   xFB
3C8A:  MOVLB  6
....................       saving_flag=0; 
3C8C:  CLRF   xDC
....................       return; 
3C8E:  BRA    402C
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3C90:  MOVLW  D6
3C92:  MOVWF  FF6
3C94:  MOVLW  05
3C96:  MOVWF  FF7
3C98:  MOVLB  0
3C9A:  CALL   06DA
....................    key_timeout=0; 
3C9E:  MOVLB  1
3CA0:  CLRF   x4A
3CA2:  CLRF   x49
....................    //key_count=0; 
....................    enable_getpin=1; 
3CA4:  MOVLW  01
3CA6:  MOVWF  x4D
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3CA8:  MOVFF  6CE,831
3CAC:  MOVFF  6CD,830
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3CB0:  MOVLB  8
3CB2:  CLRF   x32
3CB4:  MOVFF  831,834
3CB8:  MOVFF  830,833
3CBC:  MOVLW  02
3CBE:  MOVWF  x36
3CC0:  MOVLW  4A
3CC2:  MOVWF  x35
3CC4:  MOVLW  01
3CC6:  MOVWF  x38
3CC8:  MOVLW  D3
3CCA:  MOVWF  x37
3CCC:  MOVLB  0
3CCE:  RCALL  36B6
....................    countbit_T1=0; 
3CD0:  MOVLB  6
3CD2:  CLRF   xCE
3CD4:  CLRF   xCD
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3CD6:  MOVFF  6D0,831
3CDA:  MOVFF  6CF,830
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3CDE:  MOVLW  01
3CE0:  MOVLB  8
3CE2:  MOVWF  x32
3CE4:  MOVFF  831,834
3CE8:  MOVFF  830,833
3CEC:  MOVLW  05
3CEE:  MOVWF  x36
3CF0:  MOVLW  9C
3CF2:  MOVWF  x35
3CF4:  MOVLW  02
3CF6:  MOVWF  x38
3CF8:  MOVLW  22
3CFA:  MOVWF  x37
3CFC:  MOVLB  0
3CFE:  RCALL  36B6
....................    countbit_T2=0; 
3D00:  MOVLB  6
3D02:  CLRF   xD0
3D04:  CLRF   xCF
....................    saving_flag=0; 
3D06:  CLRF   xDC
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3D08:  MOVLW  20
3D0A:  MOVLB  1
3D0C:  ADDWF  xD3,W
3D0E:  MOVLB  8
3D10:  MOVWF  x2F
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
3D12:  MOVF   23,F
3D14:  BTFSS  FD8.2
3D16:  BRA    402A
3D18:  MOVF   22,W
3D1A:  SUBLW  01
3D1C:  BTFSS  FD8.0
3D1E:  BRA    402A
3D20:  BNZ   3D34
3D22:  MOVF   21,W
3D24:  SUBLW  C3
3D26:  BTFSS  FD8.0
3D28:  BRA    402A
3D2A:  BNZ   3D34
3D2C:  MOVF   20,W
3D2E:  SUBLW  0D
3D30:  BTFSS  FD8.0
3D32:  BRA    402A
3D34:  MOVF   x2F,W
3D36:  SUBLW  25
3D38:  BTFSS  FD8.2
3D3A:  BRA    402A
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3D3C:  MOVFF  23,03
3D40:  MOVFF  22,02
3D44:  MOVFF  21,01
3D48:  MOVFF  20,00
3D4C:  MOVLW  01
3D4E:  ADDWF  20,F
3D50:  BTFSC  FD8.0
3D52:  INCF   21,F
3D54:  BTFSC  FD8.2
3D56:  INCF   22,F
3D58:  BTFSC  FD8.2
3D5A:  INCF   23,F
3D5C:  MOVFF  01,833
3D60:  MOVFF  00,832
3D64:  CLRF   x43
3D66:  CLRF   x42
3D68:  MOVFF  01,841
3D6C:  MOVFF  00,840
3D70:  MOVFF  100,844
3D74:  MOVLB  0
3D76:  RCALL  3A9E
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3D78:  MOVFF  23,03
3D7C:  MOVFF  22,02
3D80:  MOVFF  21,01
3D84:  MOVFF  20,00
3D88:  MOVLW  01
3D8A:  ADDWF  20,F
3D8C:  BTFSC  FD8.0
3D8E:  INCF   21,F
3D90:  BTFSC  FD8.2
3D92:  INCF   22,F
3D94:  BTFSC  FD8.2
3D96:  INCF   23,F
3D98:  MOVFF  01,833
3D9C:  MOVFF  00,832
3DA0:  MOVLB  8
3DA2:  CLRF   x43
3DA4:  CLRF   x42
3DA6:  MOVFF  01,841
3DAA:  MOVFF  00,840
3DAE:  MOVFF  FF,844
3DB2:  MOVLB  0
3DB4:  RCALL  3A9E
....................          write_ext_eeprom((long int)ptr_card++,h); 
3DB6:  MOVFF  23,03
3DBA:  MOVFF  22,02
3DBE:  MOVFF  21,01
3DC2:  MOVFF  20,00
3DC6:  MOVLW  01
3DC8:  ADDWF  20,F
3DCA:  BTFSC  FD8.0
3DCC:  INCF   21,F
3DCE:  BTFSC  FD8.2
3DD0:  INCF   22,F
3DD2:  BTFSC  FD8.2
3DD4:  INCF   23,F
3DD6:  MOVFF  01,833
3DDA:  MOVFF  00,832
3DDE:  MOVLB  8
3DE0:  CLRF   x43
3DE2:  CLRF   x42
3DE4:  MOVFF  01,841
3DE8:  MOVFF  00,840
3DEC:  MOVFF  101,844
3DF0:  MOVLB  0
3DF2:  RCALL  3A9E
....................          write_ext_eeprom((long int)ptr_card++,min); 
3DF4:  MOVFF  23,03
3DF8:  MOVFF  22,02
3DFC:  MOVFF  21,01
3E00:  MOVFF  20,00
3E04:  MOVLW  01
3E06:  ADDWF  20,F
3E08:  BTFSC  FD8.0
3E0A:  INCF   21,F
3E0C:  BTFSC  FD8.2
3E0E:  INCF   22,F
3E10:  BTFSC  FD8.2
3E12:  INCF   23,F
3E14:  MOVFF  01,833
3E18:  MOVFF  00,832
3E1C:  MOVLB  8
3E1E:  CLRF   x43
3E20:  CLRF   x42
3E22:  MOVFF  01,841
3E26:  MOVFF  00,840
3E2A:  MOVFF  102,844
3E2E:  MOVLB  0
3E30:  RCALL  3A9E
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3E32:  MOVFF  23,03
3E36:  MOVFF  22,02
3E3A:  MOVFF  21,01
3E3E:  MOVFF  20,00
3E42:  MOVLW  01
3E44:  ADDWF  20,F
3E46:  BTFSC  FD8.0
3E48:  INCF   21,F
3E4A:  BTFSC  FD8.2
3E4C:  INCF   22,F
3E4E:  BTFSC  FD8.2
3E50:  INCF   23,F
3E52:  MOVFF  01,833
3E56:  MOVFF  00,832
3E5A:  MOVLB  8
3E5C:  CLRF   x43
3E5E:  CLRF   x42
3E60:  MOVFF  01,841
3E64:  MOVFF  00,840
3E68:  MOVFF  103,844
3E6C:  MOVLB  0
3E6E:  RCALL  3A9E
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3E70:  MOVLB  6
3E72:  CLRF   xD8
3E74:  CLRF   xD7
3E76:  MOVF   xD8,F
3E78:  BNZ   3EDA
3E7A:  MOVF   xD7,W
3E7C:  SUBLW  4E
3E7E:  BNC   3EDA
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3E80:  MOVFF  23,03
3E84:  MOVFF  22,02
3E88:  MOVFF  21,01
3E8C:  MOVFF  20,00
3E90:  MOVLW  01
3E92:  ADDWF  20,F
3E94:  BTFSC  FD8.0
3E96:  INCF   21,F
3E98:  BTFSC  FD8.2
3E9A:  INCF   22,F
3E9C:  BTFSC  FD8.2
3E9E:  INCF   23,F
3EA0:  MOVFF  01,833
3EA4:  MOVFF  00,832
3EA8:  MOVLW  D3
3EAA:  ADDWF  xD7,W
3EAC:  MOVWF  FE9
3EAE:  MOVLW  01
3EB0:  ADDWFC xD8,W
3EB2:  MOVWF  FEA
3EB4:  MOVF   FEF,W
3EB6:  ANDLW  3F
3EB8:  ADDLW  20
3EBA:  MOVLB  8
3EBC:  MOVWF  x34
3EBE:  CLRF   x43
3EC0:  CLRF   x42
3EC2:  MOVFF  01,841
3EC6:  MOVFF  00,840
3ECA:  MOVWF  x44
3ECC:  MOVLB  0
3ECE:  RCALL  3A9E
....................              
....................          } 
3ED0:  MOVLB  6
3ED2:  INCF   xD7,F
3ED4:  BTFSC  FD8.2
3ED6:  INCF   xD8,F
3ED8:  BRA    3E76
....................          del_buf(numbyteoftrack1,Track1); 
3EDA:  MOVLW  4F
3EDC:  MOVLB  8
3EDE:  MOVWF  x3E
3EE0:  MOVLW  01
3EE2:  MOVWF  x40
3EE4:  MOVLW  D3
3EE6:  MOVWF  x3F
3EE8:  MOVLB  0
3EEA:  CALL   3694
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3EEE:  MOVLB  6
3EF0:  CLRF   xD8
3EF2:  CLRF   xD7
3EF4:  MOVF   xD8,F
3EF6:  BNZ   3F58
3EF8:  MOVF   xD7,W
3EFA:  SUBLW  27
3EFC:  BNC   3F58
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3EFE:  MOVFF  23,03
3F02:  MOVFF  22,02
3F06:  MOVFF  21,01
3F0A:  MOVFF  20,00
3F0E:  MOVLW  01
3F10:  ADDWF  20,F
3F12:  BTFSC  FD8.0
3F14:  INCF   21,F
3F16:  BTFSC  FD8.2
3F18:  INCF   22,F
3F1A:  BTFSC  FD8.2
3F1C:  INCF   23,F
3F1E:  MOVFF  01,833
3F22:  MOVFF  00,832
3F26:  MOVLW  22
3F28:  ADDWF  xD7,W
3F2A:  MOVWF  FE9
3F2C:  MOVLW  02
3F2E:  ADDWFC xD8,W
3F30:  MOVWF  FEA
3F32:  MOVF   FEF,W
3F34:  ANDLW  0F
3F36:  ADDLW  30
3F38:  MOVLB  8
3F3A:  MOVWF  x34
3F3C:  CLRF   x43
3F3E:  CLRF   x42
3F40:  MOVFF  01,841
3F44:  MOVFF  00,840
3F48:  MOVWF  x44
3F4A:  MOVLB  0
3F4C:  RCALL  3A9E
....................          }  
3F4E:  MOVLB  6
3F50:  INCF   xD7,F
3F52:  BTFSC  FD8.2
3F54:  INCF   xD8,F
3F56:  BRA    3EF4
....................          del_buf(numbyteoftrack2,Track2); 
3F58:  MOVLW  28
3F5A:  MOVLB  8
3F5C:  MOVWF  x3E
3F5E:  MOVLW  02
3F60:  MOVWF  x40
3F62:  MOVLW  22
3F64:  MOVWF  x3F
3F66:  MOVLB  0
3F68:  CALL   3694
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
3F6C:  MOVLW  0D
3F6E:  MOVLB  8
3F70:  MOVWF  x58
3F72:  MOVLB  0
3F74:  CALL   0694
3F78:  MOVLW  0A
3F7A:  MOVLB  8
3F7C:  MOVWF  x58
3F7E:  MOVLB  0
3F80:  CALL   0694
....................       fprintf(COM2,"Done"); 
3F84:  MOVLW  EC
3F86:  MOVWF  FF6
3F88:  MOVLW  05
3F8A:  MOVWF  FF7
3F8C:  CALL   06DA
....................       if(KP_mode) 
3F90:  MOVLB  1
3F92:  MOVF   x50,F
3F94:  BZ    3FAC
....................       { 
....................          printf("\n\rKey release\n\r"); 
3F96:  MOVLW  F2
3F98:  MOVWF  FF6
3F9A:  MOVLW  05
3F9C:  MOVWF  FF7
3F9E:  MOVLB  0
3FA0:  CALL   06DA
....................          keyprss_off; 
3FA4:  BCF    F92.7
3FA6:  BCF    F89.7
....................          kp_st=0; 
3FA8:  MOVLB  1
3FAA:  CLRF   x51
....................       }   
....................       count_kp=0xffff; 
3FAC:  SETF   x53
3FAE:  SETF   x52
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
3FB0:  MOVLW  0D
3FB2:  MOVLB  8
3FB4:  MOVWF  x58
3FB6:  MOVLB  0
3FB8:  CALL   0694
3FBC:  MOVLW  0A
3FBE:  MOVLB  8
3FC0:  MOVWF  x58
3FC2:  MOVLB  0
3FC4:  CALL   0694
....................       fprintf(COM2,"Waiting for PIN number"); 
3FC8:  MOVLW  02
3FCA:  MOVWF  FF6
3FCC:  MOVLW  06
3FCE:  MOVWF  FF7
3FD0:  CALL   06DA
....................       count_checking=0; 
3FD4:  MOVLB  1
3FD6:  CLRF   x07
3FD8:  CLRF   x06
....................       fprintf(COM2,"\r\n"); 
3FDA:  MOVLW  0D
3FDC:  MOVLB  8
3FDE:  MOVWF  x58
3FE0:  MOVLB  0
3FE2:  CALL   0694
3FE6:  MOVLW  0A
3FE8:  MOVLB  8
3FEA:  MOVWF  x58
3FEC:  MOVLB  0
3FEE:  CALL   0694
....................       charac_timeout=0; 
3FF2:  CLRF   xFC
3FF4:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3FF6:  MOVFF  23,835
3FFA:  MOVFF  22,834
3FFE:  MOVFF  21,833
4002:  MOVFF  20,832
4006:  MOVLW  19
4008:  MOVLB  8
400A:  MOVWF  x36
400C:  MOVLB  0
400E:  RCALL  3B9C
....................       datinbuf=0; 
4010:  MOVLB  6
4012:  CLRF   xD9
....................       saving_flag=0; 
4014:  CLRF   xDC
....................       data_avai=1; 
4016:  MOVLW  01
4018:  MOVWF  xDD
....................       enable_getpin=1; 
401A:  MOVLB  1
401C:  MOVWF  x4D
....................       charac_timeout=0; 
401E:  MOVLB  0
4020:  CLRF   xFC
4022:  CLRF   xFB
....................       key_count_ms=0; 
4024:  MOVLB  1
4026:  CLRF   x4F
4028:  MOVLB  8
402A:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
402C:  MOVLB  0
402E:  GOTO   43BA (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
18E6:  MOVLW  01
18E8:  MOVLB  8
18EA:  MOVWF  x2C
18EC:  MOVWF  x2D
18EE:  MOVWF  x2E
18F0:  MOVWF  x2F
18F2:  CLRF   x30
18F4:  MOVWF  x31
18F6:  MOVWF  x32
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
18F8:  MOVLB  6
18FA:  CLRF   xD6
18FC:  CLRF   xD5
....................    mcr_timeout=0; 
18FE:  CLRF   xCB
1900:  CLRF   xCA
1902:  CLRF   xC9
1904:  CLRF   xC8
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
1906:  MOVF   xD6,W
1908:  SUBLW  FD
190A:  BNC   1928
190C:  BNZ   1914
190E:  MOVF   xD5,W
1910:  SUBLW  E7
1912:  BNC   1928
1914:  BSF    F93.1
1916:  BTFSS  F81.1
1918:  BRA    1928
191A:  BSF    F94.5
191C:  BTFSS  F82.5
191E:  BRA    1928
....................       card_timeout++; 
1920:  INCF   xD5,F
1922:  BTFSC  FD8.2
1924:  INCF   xD6,F
....................    } 
1926:  BRA    1906
....................    card_timeout=0; 
1928:  CLRF   xD6
192A:  CLRF   xD5
....................    buffertrack1[bug_countbit_T1++]=0; 
192C:  MOVFF  6D2,03
1930:  MOVF   xD1,W
1932:  INCF   xD1,F
1934:  BTFSC  FD8.2
1936:  INCF   xD2,F
1938:  MOVLB  8
193A:  MOVWF  x35
193C:  MOVLW  4A
193E:  ADDWF  x35,W
1940:  MOVWF  FE9
1942:  MOVLW  02
1944:  ADDWFC 03,W
1946:  MOVWF  FEA
1948:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
194A:  MOVLB  6
194C:  MOVFF  6D2,03
1950:  MOVF   xD1,W
1952:  INCF   xD1,F
1954:  BTFSC  FD8.2
1956:  INCF   xD2,F
1958:  MOVLB  8
195A:  MOVWF  x35
195C:  MOVLW  4A
195E:  ADDWF  x35,W
1960:  MOVWF  FE9
1962:  MOVLW  02
1964:  ADDWFC 03,W
1966:  MOVWF  FEA
1968:  MOVLW  01
196A:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
196C:  MOVLB  6
196E:  MOVFF  6D4,03
1972:  MOVF   xD3,W
1974:  INCF   xD3,F
1976:  BTFSC  FD8.2
1978:  INCF   xD4,F
197A:  MOVLB  8
197C:  MOVWF  x35
197E:  MOVLW  9C
1980:  ADDWF  x35,W
1982:  MOVWF  FE9
1984:  MOVLW  05
1986:  ADDWFC 03,W
1988:  MOVWF  FEA
198A:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
198C:  MOVLB  6
198E:  MOVFF  6D4,03
1992:  MOVF   xD3,W
1994:  INCF   xD3,F
1996:  BTFSC  FD8.2
1998:  INCF   xD4,F
199A:  MOVLB  8
199C:  MOVWF  x35
199E:  MOVLW  9C
19A0:  ADDWF  x35,W
19A2:  MOVWF  FE9
19A4:  MOVLW  05
19A6:  ADDWFC 03,W
19A8:  MOVWF  FEA
19AA:  MOVLW  01
19AC:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
19AE:  MOVLB  6
19B0:  MOVF   xD2,W
19B2:  SUBLW  03
19B4:  BTFSS  FD8.0
19B6:  BRA    1A96
19B8:  BNZ   19C2
19BA:  MOVF   xD1,W
19BC:  SUBLW  51
19BE:  BTFSS  FD8.0
19C0:  BRA    1A96
19C2:  MOVF   xD4,W
19C4:  SUBLW  01
19C6:  BTFSS  FD8.0
19C8:  BRA    1A96
19CA:  BNZ   19D2
19CC:  MOVF   xD3,W
19CE:  SUBLW  2B
19D0:  BNC   1A96
19D2:  MOVF   xD6,W
19D4:  SUBLW  FF
19D6:  BNC   1A96
19D8:  BNZ   19E0
19DA:  MOVF   xD5,W
19DC:  SUBLW  DB
19DE:  BNC   1A96
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
19E0:  MOVF   xDF,F
19E2:  BZ    19EC
....................          { 
....................             bug_countbit_T1=0; 
19E4:  CLRF   xD2
19E6:  CLRF   xD1
....................             bug_countbit_T2=0; 
19E8:  CLRF   xD4
19EA:  CLRF   xD3
....................          } 
....................          card_timeout++; 
19EC:  INCF   xD5,F
19EE:  BTFSC  FD8.2
19F0:  INCF   xD6,F
....................          mcr_timeout=0; 
19F2:  CLRF   xCB
19F4:  CLRF   xCA
19F6:  CLRF   xC9
19F8:  CLRF   xC8
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
19FA:  BSF    F93.2
19FC:  MOVLB  8
19FE:  CLRF   x2C
1A00:  BTFSC  F81.2
1A02:  INCF   x2C,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1A04:  MOVF   x2C,F
1A06:  BNZ   1A44
1A08:  DECFSZ x2D,W
1A0A:  BRA    1A44
....................          { 
....................             ST1_old = 0; 
1A0C:  CLRF   x2D
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1A0E:  MOVLW  4A
1A10:  MOVLB  6
1A12:  ADDWF  xD1,W
1A14:  MOVWF  FE9
1A16:  MOVLW  02
1A18:  ADDWFC xD2,W
1A1A:  MOVWF  FEA
1A1C:  BSF    F93.1
1A1E:  MOVLW  00
1A20:  BTFSS  F81.1
1A22:  MOVLW  01
1A24:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1A26:  MOVLW  9C
1A28:  ADDWF  xD3,W
1A2A:  MOVWF  FE9
1A2C:  MOVLW  05
1A2E:  ADDWFC xD4,W
1A30:  MOVWF  FEA
1A32:  MOVFF  830,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1A36:  INCF   xD1,F
1A38:  BTFSC  FD8.2
1A3A:  INCF   xD2,F
....................             card_timeout=0; 
1A3C:  CLRF   xD6
1A3E:  CLRF   xD5
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A40:  BRA    1A4E
1A42:  MOVLB  8
1A44:  DECFSZ x2C,W
1A46:  BRA    1A4C
1A48:  MOVLW  01
1A4A:  MOVWF  x2D
1A4C:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A4E:  BSF    F93.3
1A50:  MOVLB  8
1A52:  CLRF   x2E
1A54:  BTFSC  F81.3
1A56:  INCF   x2E,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A58:  MOVF   x2E,F
1A5A:  BNZ   1A7A
1A5C:  DECFSZ x2F,W
1A5E:  BRA    1A7A
....................          { 
....................             ST2_old = 0; 
1A60:  CLRF   x2F
....................             Bit_t2 = !input(MCR_DATA2); 
1A62:  BSF    F94.5
1A64:  CLRF   x30
1A66:  BTFSS  F82.5
1A68:  INCF   x30,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A6A:  MOVLB  6
1A6C:  INCF   xD3,F
1A6E:  BTFSC  FD8.2
1A70:  INCF   xD4,F
....................             card_timeout=0; 
1A72:  CLRF   xD6
1A74:  CLRF   xD5
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A76:  BRA    1A84
1A78:  MOVLB  8
1A7A:  DECFSZ x2E,W
1A7C:  BRA    1A82
1A7E:  MOVLW  01
1A80:  MOVWF  x2F
1A82:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1A84:  BSF    F93.0
1A86:  BTFSS  F81.0
1A88:  BRA    1A94
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1A8A:  CLRF   xDF
....................             card_timeout=65500; 
1A8C:  SETF   xD6
1A8E:  MOVLW  DC
1A90:  MOVWF  xD5
....................             break;            
1A92:  BRA    1A96
....................          } 
....................       } 
1A94:  BRA    19B0
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1A96:  CLRF   xD6
1A98:  CLRF   xD5
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1A9A:  MOVLB  8
1A9C:  CLRF   x3E
1A9E:  MOVFF  6D2,840
1AA2:  MOVFF  6D1,83F
1AA6:  MOVLW  02
1AA8:  MOVWF  x42
1AAA:  MOVLW  4A
1AAC:  MOVWF  x41
1AAE:  MOVLB  0
1AB0:  CALL   0A50
1AB4:  MOVFF  01,831
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1AB8:  MOVLW  01
1ABA:  MOVLB  8
1ABC:  MOVWF  x3E
1ABE:  MOVFF  6D4,840
1AC2:  MOVFF  6D3,83F
1AC6:  MOVLW  05
1AC8:  MOVWF  x42
1ACA:  MOVLW  9C
1ACC:  MOVWF  x41
1ACE:  MOVLB  0
1AD0:  CALL   0A50
1AD4:  MOVFF  01,832
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1AD8:  MOVLB  6
1ADA:  DECFSZ xDA,W
1ADC:  BRA    1B7E
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1ADE:  MOVLW  1A
1AE0:  MOVWF  FF6
1AE2:  MOVLW  06
1AE4:  MOVWF  FF7
1AE6:  MOVLW  0E
1AE8:  MOVLB  8
1AEA:  MOVWF  x4C
1AEC:  MOVLB  0
1AEE:  RCALL  1652
1AF0:  MOVLW  10
1AF2:  MOVWF  FE9
1AF4:  MOVFF  6D2,836
1AF8:  MOVFF  6D1,835
1AFC:  RCALL  167C
1AFE:  MOVLW  0D
1B00:  MOVLB  8
1B02:  MOVWF  x58
1B04:  MOVLB  0
1B06:  CALL   0694
1B0A:  MOVLW  0A
1B0C:  MOVLB  8
1B0E:  MOVWF  x58
1B10:  MOVLB  0
1B12:  CALL   0694
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1B16:  MOVLW  2E
1B18:  MOVWF  FF6
1B1A:  MOVLW  06
1B1C:  MOVWF  FF7
1B1E:  MOVLW  0E
1B20:  MOVLB  8
1B22:  MOVWF  x4C
1B24:  MOVLB  0
1B26:  RCALL  1652
1B28:  MOVLW  10
1B2A:  MOVWF  FE9
1B2C:  MOVFF  6D4,836
1B30:  MOVFF  6D3,835
1B34:  RCALL  167C
1B36:  MOVLW  0D
1B38:  MOVLB  8
1B3A:  MOVWF  x58
1B3C:  MOVLB  0
1B3E:  CALL   0694
1B42:  MOVLW  0A
1B44:  MOVLB  8
1B46:  MOVWF  x58
1B48:  MOVLB  0
1B4A:  CALL   0694
....................          debug_reader();       
1B4E:  BRA    182A
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B50:  MOVLB  8
1B52:  MOVF   x31,F
1B54:  BNZ   1B66
1B56:  MOVLW  42
1B58:  MOVWF  FF6
1B5A:  MOVLW  06
1B5C:  MOVWF  FF7
1B5E:  MOVLB  0
1B60:  CALL   06DA
1B64:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B66:  MOVF   x32,F
1B68:  BNZ   1B7A
1B6A:  MOVLW  58
1B6C:  MOVWF  FF6
1B6E:  MOVLW  06
1B70:  MOVWF  FF7
1B72:  MOVLB  0
1B74:  CALL   06DA
1B78:  MOVLB  8
....................       } 
....................          else 
1B7A:  BRA    1B8A
1B7C:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B7E:  MOVLW  0F
1B80:  MOVLB  8
1B82:  MOVWF  x35
1B84:  MOVLB  0
1B86:  RCALL  18BE
1B88:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1B8A:  MOVF   x31,F
1B8C:  BZ    1B92
1B8E:  MOVF   x32,F
1B90:  BNZ   1BB2
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1B92:  MOVLB  6
1B94:  CLRF   xD4
1B96:  CLRF   xD3
....................          bug_countbit_T1=0; 
1B98:  CLRF   xD2
1B9A:  CLRF   xD1
....................          reading_fg=0; 
1B9C:  CLRF   xDE
....................          count_reading_error++; 
1B9E:  INCF   xDF,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1BA0:  CLRF   xCB
1BA2:  CLRF   xCA
1BA4:  CLRF   xC9
1BA6:  CLRF   xC8
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1BA8:  MOVLW  00
1BAA:  MOVWF  01
1BAC:  BRA    1BEA
....................       } 
....................          else  
1BAE:  BRA    1BE6
1BB0:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1BB2:  MOVLW  01
1BB4:  MOVLB  6
1BB6:  MOVWF  xD9
....................             reading_fg=1; 
1BB8:  MOVWF  xDE
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1BBA:  MOVFF  6D4,6D0
1BBE:  MOVFF  6D3,6CF
....................             countbit_T1=bug_countbit_T1; 
1BC2:  MOVFF  6D2,6CE
1BC6:  MOVFF  6D1,6CD
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1BCA:  CLRF   xD2
1BCC:  CLRF   xD1
....................             bug_countbit_T2=0;  
1BCE:  CLRF   xD4
1BD0:  CLRF   xD3
....................             mcr_timeout=0; 
1BD2:  CLRF   xCB
1BD4:  CLRF   xCA
1BD6:  CLRF   xC9
1BD8:  CLRF   xC8
....................             charac_timeout=0; 
1BDA:  MOVLB  0
1BDC:  CLRF   xFC
1BDE:  CLRF   xFB
....................             return 1; 
1BE0:  MOVWF  01
1BE2:  MOVLB  6
1BE4:  BRA    1BEA
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1BE6:  MOVLW  00
1BE8:  MOVWF  01
.................... } 
1BEA:  MOVLB  0
1BEC:  GOTO   1C58 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
1BF0:  MOVLW  02
1BF2:  MOVLB  8
1BF4:  MOVWF  x2C
1BF6:  MOVLW  FA
1BF8:  MOVWF  x2D
1BFA:  MOVLB  0
1BFC:  GOTO   066E
1C00:  MOVLB  8
1C02:  DECFSZ x2C,F
1C04:  BRA    1BF6
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
1C06:  MOVLB  6
1C08:  DECFSZ xDC,W
1C0A:  BRA    1C0E
1C0C:  BRA    1C6A
....................       if((KP_mode)&&(enable_getpin==0)&&(booting==1)) 
1C0E:  MOVLB  1
1C10:  MOVF   x50,F
1C12:  BZ    1C54
1C14:  MOVF   x4D,F
1C16:  BNZ   1C54
1C18:  DECFSZ x05,W
1C1A:  BRA    1C54
....................       { 
....................          if(kp_st==1) 
1C1C:  DECFSZ x51,W
1C1E:  BRA    1C38
....................          { 
....................             printf("\n\rKey release.\n\r"); 
1C20:  MOVLW  72
1C22:  MOVWF  FF6
1C24:  MOVLW  1C
1C26:  MOVWF  FF7
1C28:  MOVLB  0
1C2A:  CALL   06DA
....................             keyprss_off; 
1C2E:  BCF    F92.7
1C30:  BCF    F89.7
....................             kp_st=0; 
1C32:  MOVLB  1
1C34:  CLRF   x51
....................          } 
....................          else 
1C36:  BRA    1C54
....................          { 
....................             printf("\n\rKey press.\n\r"); 
1C38:  MOVLW  84
1C3A:  MOVWF  FF6
1C3C:  MOVLW  1C
1C3E:  MOVWF  FF7
1C40:  MOVLB  0
1C42:  CALL   06DA
....................             keyprss_on; 
1C46:  BCF    F92.7
1C48:  BSF    F89.7
....................             kp_st=1;  
1C4A:  MOVLW  01
1C4C:  MOVLB  1
1C4E:  MOVWF  x51
....................             count_kp=0; 
1C50:  CLRF   x53
1C52:  CLRF   x52
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1C54:  MOVLB  0
1C56:  BRA    18E6
1C58:  MOVFF  01,6DB
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1C5C:  MOVLB  6
1C5E:  CLRF   xCB
1C60:  CLRF   xCA
1C62:  CLRF   xC9
1C64:  CLRF   xC8
....................       card_timeout=0; 
1C66:  CLRF   xD6
1C68:  CLRF   xD5
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1C6A:  BCF    FF0.0
1C6C:  MOVLB  0
1C6E:  GOTO   006C
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
6110:  CLRF   19
6112:  BTFSC  FF2.7
6114:  BSF    19.7
6116:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
6118:  MOVLB  8
611A:  CLRF   x43
611C:  CLRF   x42
611E:  CLRF   x41
6120:  MOVLW  94
6122:  MOVWF  x40
6124:  MOVLW  03
6126:  MOVWF  x44
6128:  MOVLB  0
612A:  CALL   3A9E
612E:  BTFSC  19.7
6130:  BSF    FF2.7
6132:  CLRF   19
6134:  BTFSC  FF2.7
6136:  BSF    19.7
6138:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
613A:  MOVLB  8
613C:  CLRF   x43
613E:  CLRF   x42
6140:  CLRF   x41
6142:  MOVLW  91
6144:  MOVWF  x40
6146:  MOVLW  01
6148:  MOVWF  x44
614A:  MOVLB  0
614C:  CALL   3A9E
6150:  BTFSC  19.7
6152:  BSF    FF2.7
6154:  CLRF   19
6156:  BTFSC  FF2.7
6158:  BSF    19.7
615A:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
615C:  MOVLB  8
615E:  CLRF   x3B
6160:  CLRF   x3A
6162:  CLRF   x39
6164:  MOVLW  91
6166:  MOVWF  x38
6168:  MOVLB  0
616A:  CALL   354E
616E:  BTFSC  19.7
6170:  BSF    FF2.7
6172:  MOVFF  01,6E6
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
....................    #endif 
....................     
.................... } 
6176:  GOTO   6ABE (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
6456:  MOVLW  06
6458:  MOVWF  FEA
645A:  MOVLW  EB
645C:  MOVWF  FE9
645E:  CALL   4B5E
6462:  CLRF   19
6464:  BTFSC  FF2.7
6466:  BSF    19.7
6468:  BCF    FF2.7
646A:  MOVLW  3E
646C:  MOVLB  8
646E:  MOVWF  x58
6470:  MOVLB  0
6472:  CALL   0694
6476:  BTFSC  19.7
6478:  BSF    FF2.7
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
647A:  MOVLW  01
647C:  MOVLB  7
647E:  MOVWF  xF7
6480:  MOVLW  14
6482:  MOVWF  xF8
6484:  MOVLW  01
6486:  MOVWF  xFA
6488:  MOVLW  69
648A:  MOVWF  xF9
648C:  MOVLB  0
648E:  CALL   5B6C
6492:  CLRF   19
6494:  BTFSC  FF2.7
6496:  BSF    19.7
6498:  BCF    FF2.7
....................       printf("\n\r"); 
649A:  MOVLW  0A
649C:  MOVLB  8
649E:  MOVWF  x58
64A0:  MOVLB  0
64A2:  CALL   0694
64A6:  BTFSC  19.7
64A8:  BSF    FF2.7
64AA:  CLRF   19
64AC:  BTFSC  FF2.7
64AE:  BSF    19.7
64B0:  BCF    FF2.7
64B2:  MOVLW  0D
64B4:  MOVLB  8
64B6:  MOVWF  x58
64B8:  MOVLB  0
64BA:  CALL   0694
64BE:  BTFSC  19.7
64C0:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
64C2:  CLRF   FEA
64C4:  MOVLW  41
64C6:  MOVWF  FE9
64C8:  MOVLW  00
64CA:  CALL   0356
64CE:  TBLRD*-
64D0:  TBLRD*+
64D2:  MOVF   FF5,W
64D4:  MOVWF  FEE
64D6:  IORLW  00
64D8:  BNZ   64D0
....................       index=0; 
64DA:  MOVLB  7
64DC:  CLRF   xC1
....................       ee_dat=0; 
64DE:  MOVLB  6
64E0:  CLRF   xE1
....................       count_card=1; 
64E2:  CLRF   xE3
64E4:  MOVLW  01
64E6:  MOVWF  xE2
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
64E8:  MOVLB  7
64EA:  MOVWF  xF8
64EC:  MOVLW  69
64EE:  MOVWF  xF7
64F0:  CLRF   xFA
64F2:  MOVLW  41
64F4:  MOVWF  xF9
64F6:  MOVLB  0
64F8:  CALL   5CA4
64FC:  MOVF   01,F
64FE:  BTFSS  FD8.2
6500:  BRA    68E8
....................       { 
....................          unsigned long adr=0; 
6502:  MOVLB  7
6504:  CLRF   xF6
6506:  CLRF   xF5
....................          //unsigned int count=0; 
....................          rec[0]=0; 
6508:  MOVLB  0
650A:  CLRF   x7D
650C:  CLRF   19
650E:  BTFSC  FF2.7
6510:  BSF    19.7
6512:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
6514:  CALL   361A
6518:  BTFSC  19.7
651A:  BSF    FF2.7
651C:  MOVFF  02,6E5
6520:  MOVFF  01,6E4
6524:  CLRF   19
6526:  BTFSC  FF2.7
6528:  BSF    19.7
652A:  BCF    FF2.7
....................          adr=count_card*numdata; 
652C:  MOVFF  6E3,835
6530:  MOVFF  6E2,834
6534:  MOVLB  8
6536:  CLRF   x37
6538:  MOVLW  7C
653A:  MOVWF  x36
653C:  MOVLB  0
653E:  CALL   3672
6542:  BTFSC  19.7
6544:  BSF    FF2.7
6546:  MOVFF  02,7F6
654A:  MOVFF  01,7F5
....................          addr_key=EEPROM_KEY_ST; 
654E:  MOVLB  6
6550:  CLRF   xEA
6552:  MOVLW  01
6554:  MOVWF  xE9
6556:  MOVLW  C3
6558:  MOVWF  xE8
655A:  MOVLW  0F
655C:  MOVWF  xE7
....................          while(count_card<=count_card_tg) 
....................          { 
655E:  MOVF   xE3,W
6560:  SUBWF  xE5,W
6562:  BTFSS  FD8.0
6564:  BRA    68E6
6566:  BNZ   6570
6568:  MOVF   xE2,W
656A:  SUBWF  xE4,W
656C:  BTFSS  FD8.0
656E:  BRA    68E6
6570:  CLRF   19
6572:  BTFSC  FF2.7
6574:  BSF    19.7
6576:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
6578:  MOVFF  6E3,835
657C:  MOVFF  6E2,834
6580:  MOVLB  8
6582:  CLRF   x37
6584:  MOVLW  7C
6586:  MOVWF  x36
6588:  MOVLB  0
658A:  CALL   3672
658E:  BTFSC  19.7
6590:  BSF    FF2.7
6592:  MOVLW  96
6594:  MOVLB  7
6596:  ADDWF  01,W
6598:  MOVWF  xF5
659A:  MOVLW  00
659C:  ADDWFC 02,W
659E:  MOVWF  xF6
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
65A0:  MOVLW  7C
65A2:  SUBWF  xF5,W
65A4:  MOVWF  xF7
65A6:  MOVLW  00
65A8:  SUBWFB xF6,W
65AA:  MOVWF  xF8
65AC:  MOVWF  xFA
65AE:  MOVFF  7F7,7F9
65B2:  CLRF   xFC
65B4:  MOVLW  7C
65B6:  MOVWF  xFB
65B8:  CLRF   xFE
65BA:  MOVLW  7D
65BC:  MOVWF  xFD
65BE:  MOVLB  0
65C0:  GOTO   5D3C
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
65C4:  MOVLW  10
65C6:  MOVWF  FE9
65C8:  CLRF   19
65CA:  BTFSC  FF2.7
65CC:  BSF    19.7
65CE:  BCF    FF2.7
65D0:  MOVFF  6E3,830
65D4:  MOVFF  6E2,82F
65D8:  CALL   420C
65DC:  BTFSC  19.7
65DE:  BSF    FF2.7
65E0:  CLRF   19
65E2:  BTFSC  FF2.7
65E4:  BSF    19.7
65E6:  BCF    FF2.7
65E8:  MOVLW  29
65EA:  MOVLB  8
65EC:  MOVWF  x58
65EE:  MOVLB  0
65F0:  CALL   0694
65F4:  BTFSC  19.7
65F6:  BSF    FF2.7
65F8:  MOVFF  7D,7F7
65FC:  MOVLW  01
65FE:  MOVLB  7
6600:  MOVWF  xF8
6602:  MOVLB  0
6604:  CALL   5DCA
6608:  CLRF   19
660A:  BTFSC  FF2.7
660C:  BSF    19.7
660E:  BCF    FF2.7
6610:  MOVLW  2F
6612:  MOVLB  8
6614:  MOVWF  x58
6616:  MOVLB  0
6618:  CALL   0694
661C:  BTFSC  19.7
661E:  BSF    FF2.7
6620:  MOVFF  7E,7F7
6624:  MOVLW  01
6626:  MOVLB  7
6628:  MOVWF  xF8
662A:  MOVLB  0
662C:  CALL   5DCA
6630:  CLRF   19
6632:  BTFSC  FF2.7
6634:  BSF    19.7
6636:  BCF    FF2.7
6638:  MOVLW  20
663A:  MOVLB  8
663C:  MOVWF  x58
663E:  MOVLB  0
6640:  CALL   0694
6644:  BTFSC  19.7
6646:  BSF    FF2.7
6648:  MOVFF  7F,7F7
664C:  MOVLW  01
664E:  MOVLB  7
6650:  MOVWF  xF8
6652:  MOVLB  0
6654:  CALL   5DCA
6658:  CLRF   19
665A:  BTFSC  FF2.7
665C:  BSF    19.7
665E:  BCF    FF2.7
6660:  MOVLW  3A
6662:  MOVLB  8
6664:  MOVWF  x58
6666:  MOVLB  0
6668:  CALL   0694
666C:  BTFSC  19.7
666E:  BSF    FF2.7
6670:  MOVFF  80,7F7
6674:  MOVLW  01
6676:  MOVLB  7
6678:  MOVWF  xF8
667A:  MOVLB  0
667C:  CALL   5DCA
6680:  CLRF   19
6682:  BTFSC  FF2.7
6684:  BSF    19.7
6686:  BCF    FF2.7
6688:  MOVLW  3A
668A:  MOVLB  8
668C:  MOVWF  x58
668E:  MOVLB  0
6690:  CALL   0694
6694:  BTFSC  19.7
6696:  BSF    FF2.7
6698:  MOVFF  81,7F7
669C:  MOVLW  01
669E:  MOVLB  7
66A0:  MOVWF  xF8
66A2:  MOVLB  0
66A4:  CALL   5DCA
....................             ee_dat=0; 
66A8:  MOVLB  6
66AA:  CLRF   xE1
....................             index=0; 
66AC:  MOVLB  7
66AE:  CLRF   xC1
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
66B0:  MOVLW  B8
66B2:  MOVWF  FF6
66B4:  MOVLW  1C
66B6:  MOVWF  FF7
66B8:  CLRF   19
66BA:  BTFSC  FF2.7
66BC:  BSF    19.7
66BE:  BCF    FF2.7
66C0:  MOVLB  0
66C2:  CALL   06DA
66C6:  BTFSC  19.7
66C8:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
66CA:  MOVLB  7
66CC:  MOVF   xC1,W
66CE:  SUBLW  4E
66D0:  BNC   672E
66D2:  MOVLB  6
66D4:  MOVF   xE1,W
66D6:  SUBLW  3F
66D8:  BTFSS  FD8.2
66DA:  BRA    66E0
66DC:  MOVLB  7
66DE:  BRA    672E
....................                ee_dat = rec[index+5]; 
66E0:  MOVLW  05
66E2:  MOVLB  7
66E4:  ADDWF  xC1,W
66E6:  CLRF   03
66E8:  ADDLW  7D
66EA:  MOVWF  FE9
66EC:  MOVLW  00
66EE:  ADDWFC 03,W
66F0:  MOVWF  FEA
66F2:  MOVFF  FEF,6E1
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
66F6:  MOVLB  6
66F8:  MOVF   xE1,W
66FA:  SUBLW  1F
66FC:  BC    671A
66FE:  MOVF   xE1,W
6700:  SUBLW  7E
6702:  BNC   671A
6704:  CLRF   19
6706:  BTFSC  FF2.7
6708:  BSF    19.7
670A:  BCF    FF2.7
670C:  MOVFF  6E1,858
6710:  MOVLB  0
6712:  CALL   0694
6716:  BTFSC  19.7
6718:  BSF    FF2.7
....................                index++; 
671A:  MOVLB  7
671C:  INCF   xC1,F
....................                if(ee_dat==0)break; 
671E:  MOVLB  6
6720:  MOVF   xE1,F
6722:  BNZ   6728
6724:  MOVLB  7
6726:  BRA    672E
....................             } 
6728:  MOVLB  0
672A:  BRA    66CA
672C:  MOVLB  7
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
672E:  MOVLW  CA
6730:  MOVWF  FF6
6732:  MOVLW  1C
6734:  MOVWF  FF7
6736:  CLRF   19
6738:  BTFSC  FF2.7
673A:  BSF    19.7
673C:  BCF    FF2.7
673E:  MOVLB  0
6740:  CALL   06DA
6744:  BTFSC  19.7
6746:  BSF    FF2.7
....................             index=0; 
6748:  MOVLB  7
674A:  CLRF   xC1
....................             ee_dat=0; 
674C:  MOVLB  6
674E:  CLRF   xE1
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
6750:  MOVLB  7
6752:  MOVF   xC1,W
6754:  SUBLW  27
6756:  BNC   67B6
6758:  MOVLB  6
675A:  MOVF   xE1,W
675C:  SUBLW  3F
675E:  BTFSS  FD8.2
6760:  BRA    6766
6762:  MOVLB  7
6764:  BRA    67B6
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
6766:  MOVLW  05
6768:  MOVLB  7
676A:  ADDWF  xC1,W
676C:  ADDLW  4F
676E:  CLRF   03
6770:  ADDLW  7D
6772:  MOVWF  FE9
6774:  MOVLW  00
6776:  ADDWFC 03,W
6778:  MOVWF  FEA
677A:  MOVFF  FEF,6E1
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
677E:  MOVLB  6
6780:  MOVF   xE1,W
6782:  SUBLW  1F
6784:  BC    67A2
6786:  MOVF   xE1,W
6788:  SUBLW  7E
678A:  BNC   67A2
678C:  CLRF   19
678E:  BTFSC  FF2.7
6790:  BSF    19.7
6792:  BCF    FF2.7
6794:  MOVFF  6E1,858
6798:  MOVLB  0
679A:  CALL   0694
679E:  BTFSC  19.7
67A0:  BSF    FF2.7
....................                index++; 
67A2:  MOVLB  7
67A4:  INCF   xC1,F
....................                if(ee_dat==0)break; 
67A6:  MOVLB  6
67A8:  MOVF   xE1,F
67AA:  BNZ   67B2
67AC:  MOVLB  7
67AE:  BRA    67B6
67B0:  MOVLB  6
....................             } 
67B2:  BRA    6750
67B4:  MOVLB  7
....................             index=0; 
67B6:  CLRF   xC1
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
67B8:  MOVLW  DC
67BA:  MOVWF  FF6
67BC:  MOVLW  1C
67BE:  MOVWF  FF7
67C0:  CLRF   19
67C2:  BTFSC  FF2.7
67C4:  BSF    19.7
67C6:  BCF    FF2.7
67C8:  MOVLB  0
67CA:  CALL   06DA
67CE:  BTFSC  19.7
67D0:  BSF    FF2.7
....................             //fprintf(COM2,"addr_key =%lu \n\r",addr_key);  
....................             //fprintf(COM2," ptr_card_key=%lu \n\r",ptr_card_key);  
....................             if(ptr_card_key>addr_key) 
67D2:  MOVLB  6
67D4:  MOVF   xEA,W
67D6:  SUBWF  27,W
67D8:  BTFSS  FD8.0
67DA:  BRA    68DE
67DC:  BNZ   67FA
67DE:  MOVF   xE9,W
67E0:  SUBWF  26,W
67E2:  BTFSS  FD8.0
67E4:  BRA    68DE
67E6:  BNZ   67FA
67E8:  MOVF   xE8,W
67EA:  SUBWF  25,W
67EC:  BTFSS  FD8.0
67EE:  BRA    68DE
67F0:  BNZ   67FA
67F2:  MOVF   24,W
67F4:  SUBWF  xE7,W
67F6:  BTFSC  FD8.0
67F8:  BRA    68DE
....................             { 
....................                i=0; 
67FA:  MOVLB  7
67FC:  CLRF   xC2
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
67FE:  MOVF   xC2,W
6800:  MOVLB  6
6802:  ADDWF  xE7,W
6804:  MOVLB  7
6806:  MOVWF  xF7
6808:  MOVLW  00
680A:  MOVLB  6
680C:  ADDWFC xE8,W
680E:  MOVLB  7
6810:  MOVWF  xF8
6812:  MOVLW  00
6814:  MOVLB  6
6816:  ADDWFC xE9,W
6818:  MOVLB  7
681A:  MOVWF  xF9
681C:  MOVLW  00
681E:  MOVLB  6
6820:  ADDWFC xEA,W
6822:  MOVLB  7
6824:  MOVWF  xFA
6826:  CLRF   19
6828:  BTFSC  FF2.7
682A:  BSF    19.7
682C:  BCF    FF2.7
682E:  MOVFF  FE8,83B
6832:  MOVFF  7F9,83A
6836:  MOVFF  7F8,839
683A:  MOVFF  7F7,838
683E:  MOVLB  0
6840:  CALL   354E
6844:  BTFSC  19.7
6846:  BSF    FF2.7
6848:  MOVFF  01,6E1
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
684C:  MOVLB  6
684E:  MOVF   xE1,W
6850:  SUBLW  2F
6852:  BC    685A
6854:  MOVF   xE1,W
6856:  SUBLW  39
6858:  BC    6872
685A:  MOVF   xE1,W
685C:  SUBLW  23
685E:  BZ    6872
6860:  MOVF   xE1,W
6862:  SUBLW  2A
6864:  BZ    6872
6866:  MOVF   xE1,W
6868:  SUBLW  40
686A:  BC    6888
686C:  MOVF   xE1,W
686E:  SUBLW  5A
6870:  BNC   6888
6872:  CLRF   19
6874:  BTFSC  FF2.7
6876:  BSF    19.7
6878:  BCF    FF2.7
....................                      fputc(ee_dat,COM2); 
687A:  MOVFF  6E1,858
687E:  MOVLB  0
6880:  CALL   0694
6884:  BTFSC  19.7
6886:  BSF    FF2.7
....................                   i++; 
6888:  MOVLB  7
688A:  INCF   xC2,F
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
688C:  MOVF   xC2,W
688E:  SUBLW  0B
6890:  BNC   689E
6892:  MOVLB  6
6894:  MOVF   xE1,F
6896:  BTFSC  FD8.2
6898:  BRA    689E
689A:  MOVLB  7
689C:  BRA    67FE
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+key_numbyte; 
689E:  MOVLW  0C
68A0:  MOVLB  6
68A2:  ADDWF  xE7,F
68A4:  MOVLW  00
68A6:  ADDWFC xE8,F
68A8:  ADDWFC xE9,F
68AA:  ADDWFC xEA,F
68AC:  CLRF   19
68AE:  BTFSC  FF2.7
68B0:  BSF    19.7
68B2:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
68B4:  MOVLW  0A
68B6:  MOVLB  8
68B8:  MOVWF  x58
68BA:  MOVLB  0
68BC:  CALL   0694
68C0:  BTFSC  19.7
68C2:  BSF    FF2.7
68C4:  CLRF   19
68C6:  BTFSC  FF2.7
68C8:  BSF    19.7
68CA:  BCF    FF2.7
68CC:  MOVLW  0D
68CE:  MOVLB  8
68D0:  MOVWF  x58
68D2:  MOVLB  0
68D4:  CALL   0694
68D8:  BTFSC  19.7
68DA:  BSF    FF2.7
68DC:  MOVLB  6
....................             } 
....................             count_card++; 
68DE:  INCF   xE2,F
68E0:  BTFSC  FD8.2
68E2:  INCF   xE3,F
....................          } 
68E4:  BRA    655E
68E6:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
68E8:  CLRF   FEA
68EA:  MOVLW  41
68EC:  MOVWF  FE9
68EE:  MOVLW  00
68F0:  CALL   0368
68F4:  TBLRD*-
68F6:  TBLRD*+
68F8:  MOVF   FF5,W
68FA:  MOVWF  FEE
68FC:  IORLW  00
68FE:  BNZ   68F6
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6900:  MOVLW  01
6902:  MOVLB  7
6904:  MOVWF  xF8
6906:  MOVLW  69
6908:  MOVWF  xF7
690A:  CLRF   xFA
690C:  MOVLW  41
690E:  MOVWF  xF9
6910:  MOVLB  0
6912:  CALL   5CA4
6916:  MOVF   01,F
6918:  BNZ   694E
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
691A:  MOVLW  EC
691C:  MOVWF  FF6
691E:  MOVLW  1C
6920:  MOVWF  FF7
6922:  CLRF   19
6924:  BTFSC  FF2.7
6926:  BSF    19.7
6928:  BCF    FF2.7
692A:  CALL   06DA
692E:  BTFSC  19.7
6930:  BSF    FF2.7
....................          format_eepromext(); 
6932:  GOTO   5EE4
....................          fprintf(COM2," exit\n\r");  
6936:  MOVLW  FA
6938:  MOVWF  FF6
693A:  MOVLW  1C
693C:  MOVWF  FF7
693E:  CLRF   19
6940:  BTFSC  FF2.7
6942:  BSF    19.7
6944:  BCF    FF2.7
6946:  CALL   06DA
694A:  BTFSC  19.7
694C:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
694E:  CLRF   FEA
6950:  MOVLW  41
6952:  MOVWF  FE9
6954:  MOVLW  00
6956:  CALL   037A
695A:  TBLRD*-
695C:  TBLRD*+
695E:  MOVF   FF5,W
6960:  MOVWF  FEE
6962:  IORLW  00
6964:  BNZ   695C
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6966:  MOVLW  01
6968:  MOVLB  7
696A:  MOVWF  xF8
696C:  MOVLW  69
696E:  MOVWF  xF7
6970:  CLRF   xFA
6972:  MOVLW  41
6974:  MOVWF  xF9
6976:  MOVLB  0
6978:  CALL   5CA4
697C:  MOVF   01,F
697E:  BNZ   69B4
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6980:  MOVLW  02
6982:  MOVWF  FF6
6984:  MOVLW  1D
6986:  MOVWF  FF7
6988:  CLRF   19
698A:  BTFSC  FF2.7
698C:  BSF    19.7
698E:  BCF    FF2.7
6990:  CALL   06DA
6994:  BTFSC  19.7
6996:  BSF    FF2.7
....................          ease_eeprom(); 
6998:  GOTO   604A
....................          fprintf(COM2," exit\n\r");  
699C:  MOVLW  10
699E:  MOVWF  FF6
69A0:  MOVLW  1D
69A2:  MOVWF  FF7
69A4:  CLRF   19
69A6:  BTFSC  FF2.7
69A8:  BSF    19.7
69AA:  BCF    FF2.7
69AC:  CALL   06DA
69B0:  BTFSC  19.7
69B2:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
69B4:  CLRF   FEA
69B6:  MOVLW  41
69B8:  MOVWF  FE9
69BA:  MOVLW  00
69BC:  CALL   0390
69C0:  TBLRD*-
69C2:  TBLRD*+
69C4:  MOVF   FF5,W
69C6:  MOVWF  FEE
69C8:  IORLW  00
69CA:  BNZ   69C2
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
69CC:  MOVLW  01
69CE:  MOVLB  7
69D0:  MOVWF  xF8
69D2:  MOVLW  69
69D4:  MOVWF  xF7
69D6:  CLRF   xFA
69D8:  MOVLW  41
69DA:  MOVWF  xF9
69DC:  MOVLB  0
69DE:  CALL   5CA4
69E2:  MOVF   01,F
69E4:  BNZ   6A1E
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
69E6:  MOVLW  18
69E8:  MOVWF  FF6
69EA:  MOVLW  1D
69EC:  MOVWF  FF7
69EE:  CLRF   19
69F0:  BTFSC  FF2.7
69F2:  BSF    19.7
69F4:  BCF    FF2.7
69F6:  CALL   06DA
69FA:  BTFSC  19.7
69FC:  BSF    FF2.7
....................          reset_password(); 
69FE:  GOTO   60CE
....................          init_password(); 
6A02:  CALL   4796
....................          fprintf(COM2," exit\n\r");  
6A06:  MOVLW  2E
6A08:  MOVWF  FF6
6A0A:  MOVLW  1D
6A0C:  MOVWF  FF7
6A0E:  CLRF   19
6A10:  BTFSC  FF2.7
6A12:  BSF    19.7
6A14:  BCF    FF2.7
6A16:  CALL   06DA
6A1A:  BTFSC  19.7
6A1C:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
6A1E:  CLRF   FEA
6A20:  MOVLW  41
6A22:  MOVWF  FE9
6A24:  MOVLW  00
6A26:  CALL   03A6
6A2A:  TBLRD*-
6A2C:  TBLRD*+
6A2E:  MOVF   FF5,W
6A30:  MOVWF  FEE
6A32:  IORLW  00
6A34:  BNZ   6A2C
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6A36:  MOVLW  01
6A38:  MOVLB  7
6A3A:  MOVWF  xF8
6A3C:  MOVLW  69
6A3E:  MOVWF  xF7
6A40:  CLRF   xFA
6A42:  MOVLW  41
6A44:  MOVWF  xF9
6A46:  MOVLB  0
6A48:  CALL   5CA4
6A4C:  MOVF   01,F
6A4E:  BNZ   6A70
....................       { 
....................          keydebug_en=1; 
6A50:  MOVLW  01
6A52:  MOVLB  1
6A54:  MOVWF  x4C
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
6A56:  MOVLW  36
6A58:  MOVWF  FF6
6A5A:  MOVLW  1D
6A5C:  MOVWF  FF7
6A5E:  CLRF   19
6A60:  BTFSC  FF2.7
6A62:  BSF    19.7
6A64:  BCF    FF2.7
6A66:  MOVLB  0
6A68:  CALL   06DA
6A6C:  BTFSC  19.7
6A6E:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
6A70:  CLRF   FEA
6A72:  MOVLW  41
6A74:  MOVWF  FE9
6A76:  MOVLW  00
6A78:  CALL   03BC
6A7C:  TBLRD*-
6A7E:  TBLRD*+
6A80:  MOVF   FF5,W
6A82:  MOVWF  FEE
6A84:  IORLW  00
6A86:  BNZ   6A7E
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6A88:  MOVLW  01
6A8A:  MOVLB  7
6A8C:  MOVWF  xF8
6A8E:  MOVLW  69
6A90:  MOVWF  xF7
6A92:  CLRF   xFA
6A94:  MOVLW  41
6A96:  MOVWF  xF9
6A98:  MOVLB  0
6A9A:  CALL   5CA4
6A9E:  MOVF   01,F
6AA0:  BNZ   6ABE
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6AA2:  MOVLW  4A
6AA4:  MOVWF  FF6
6AA6:  MOVLW  1D
6AA8:  MOVWF  FF7
6AAA:  CLRF   19
6AAC:  BTFSC  FF2.7
6AAE:  BSF    19.7
6AB0:  BCF    FF2.7
6AB2:  CALL   06DA
6AB6:  BTFSC  19.7
6AB8:  BSF    FF2.7
....................          rstfact(); 
6ABA:  GOTO   6110
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
6ABE:  CLRF   FEA
6AC0:  MOVLW  41
6AC2:  MOVWF  FE9
6AC4:  MOVLW  00
6AC6:  CALL   03D4
6ACA:  TBLRD*-
6ACC:  TBLRD*+
6ACE:  MOVF   FF5,W
6AD0:  MOVWF  FEE
6AD2:  IORLW  00
6AD4:  BNZ   6ACC
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6AD6:  MOVLW  01
6AD8:  MOVLB  7
6ADA:  MOVWF  xF8
6ADC:  MOVLW  69
6ADE:  MOVWF  xF7
6AE0:  CLRF   xFA
6AE2:  MOVLW  41
6AE4:  MOVWF  xF9
6AE6:  MOVLB  0
6AE8:  CALL   5CA4
6AEC:  MOVF   01,F
6AEE:  BNZ   6B16
....................       { 
....................          mode=LOGOFF; 
6AF0:  MOVLB  6
6AF2:  CLRF   xE0
....................          keydebug_en=0; 
6AF4:  MOVLB  1
6AF6:  CLRF   x4C
....................          set_tris_a(0xff); 
6AF8:  MOVLW  FF
6AFA:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
6AFC:  MOVLW  5A
6AFE:  MOVWF  FF6
6B00:  MOVLW  1D
6B02:  MOVWF  FF7
6B04:  CLRF   19
6B06:  BTFSC  FF2.7
6B08:  BSF    19.7
6B0A:  BCF    FF2.7
6B0C:  MOVLB  0
6B0E:  CALL   06DA
6B12:  BTFSC  19.7
6B14:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
6B16:  CLRF   FEA
6B18:  MOVLW  41
6B1A:  MOVWF  FE9
6B1C:  MOVLW  00
6B1E:  CALL   03E6
6B22:  TBLRD*-
6B24:  TBLRD*+
6B26:  MOVF   FF5,W
6B28:  MOVWF  FEE
6B2A:  IORLW  00
6B2C:  BNZ   6B24
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6B2E:  MOVLW  01
6B30:  MOVLB  7
6B32:  MOVWF  xF8
6B34:  MOVLW  69
6B36:  MOVWF  xF7
6B38:  CLRF   xFA
6B3A:  MOVLW  41
6B3C:  MOVWF  xF9
6B3E:  MOVLB  0
6B40:  CALL   5CA4
6B44:  MOVF   01,F
6B46:  BNZ   6BB4
....................       { 
....................          fprintf(COM2,"New console name>"); 
6B48:  MOVLW  62
6B4A:  MOVWF  FF6
6B4C:  MOVLW  1D
6B4E:  MOVWF  FF7
6B50:  CLRF   19
6B52:  BTFSC  FF2.7
6B54:  BSF    19.7
6B56:  BCF    FF2.7
6B58:  CALL   06DA
6B5C:  BTFSC  19.7
6B5E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,16, console); 
6B60:  MOVLW  01
6B62:  MOVLB  7
6B64:  MOVWF  xF7
6B66:  MOVLW  10
6B68:  MOVWF  xF8
6B6A:  MOVLW  06
6B6C:  MOVWF  xFA
6B6E:  MOVLW  EB
6B70:  MOVWF  xF9
6B72:  MOVLB  0
6B74:  CALL   5B6C
....................          EEPROM_write(strobe_nameconsole,16,console); 
6B78:  MOVLB  8
6B7A:  CLRF   x0F
6B7C:  CLRF   x0E
6B7E:  CLRF   x0D
6B80:  MOVLW  66
6B82:  MOVWF  x0C
6B84:  CLRF   x13
6B86:  CLRF   x12
6B88:  CLRF   x11
6B8A:  MOVLW  10
6B8C:  MOVWF  x10
6B8E:  MOVLW  06
6B90:  MOVWF  x15
6B92:  MOVLW  EB
6B94:  MOVWF  x14
6B96:  MOVLB  0
6B98:  CALL   46FA
....................          fprintf(COM2," OK\n\r"); 
6B9C:  MOVLW  74
6B9E:  MOVWF  FF6
6BA0:  MOVLW  1D
6BA2:  MOVWF  FF7
6BA4:  CLRF   19
6BA6:  BTFSC  FF2.7
6BA8:  BSF    19.7
6BAA:  BCF    FF2.7
6BAC:  CALL   06DA
6BB0:  BTFSC  19.7
6BB2:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
6BB4:  CLRF   FEA
6BB6:  MOVLW  41
6BB8:  MOVWF  FE9
6BBA:  MOVLW  00
6BBC:  CALL   03F8
6BC0:  TBLRD*-
6BC2:  TBLRD*+
6BC4:  MOVF   FF5,W
6BC6:  MOVWF  FEE
6BC8:  IORLW  00
6BCA:  BNZ   6BC2
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6BCC:  MOVLW  01
6BCE:  MOVLB  7
6BD0:  MOVWF  xF8
6BD2:  MOVLW  69
6BD4:  MOVWF  xF7
6BD6:  CLRF   xFA
6BD8:  MOVLW  41
6BDA:  MOVWF  xF9
6BDC:  MOVLB  0
6BDE:  CALL   5CA4
6BE2:  MOVF   01,F
6BE4:  BTFSS  FD8.2
6BE6:  BRA    6E4C
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
*
6CB2:  MOVLB  8
6CB4:  CLRF   x3B
6CB6:  CLRF   x3A
6CB8:  CLRF   x39
6CBA:  MOVLW  91
6CBC:  MOVWF  x38
6CBE:  MOVLB  0
6CC0:  CALL   354E
6CC4:  BTFSC  19.7
6CC6:  BSF    FF2.7
6CC8:  MOVFF  01,6E6
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6CCC:  MOVLB  6
6CCE:  MOVF   xE6,F
6CD0:  BNZ   6CF0
6CD2:  MOVLW  7A
6CD4:  MOVWF  FF6
6CD6:  MOVLW  1D
6CD8:  MOVWF  FF7
6CDA:  CLRF   19
6CDC:  BTFSC  FF2.7
6CDE:  BSF    19.7
6CE0:  BCF    FF2.7
6CE2:  MOVLB  0
6CE4:  CALL   06DA
6CE8:  BTFSC  19.7
6CEA:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6CEC:  BRA    6D0A
6CEE:  MOVLB  6
6CF0:  MOVLW  7E
6CF2:  MOVWF  FF6
6CF4:  MOVLW  1D
6CF6:  MOVWF  FF7
6CF8:  CLRF   19
6CFA:  BTFSC  FF2.7
6CFC:  BSF    19.7
6CFE:  BCF    FF2.7
6D00:  MOVLB  0
6D02:  CALL   06DA
6D06:  BTFSC  19.7
6D08:  BSF    FF2.7
6D0A:  CLRF   19
6D0C:  BTFSC  FF2.7
6D0E:  BSF    19.7
6D10:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
6D12:  MOVLB  8
6D14:  CLRF   x3B
6D16:  CLRF   x3A
6D18:  CLRF   x39
6D1A:  MOVLW  94
6D1C:  MOVWF  x38
6D1E:  MOVLB  0
6D20:  CALL   354E
6D24:  BTFSC  19.7
6D26:  BSF    FF2.7
6D28:  MOVFF  01,161
6D2C:  CLRF   19
6D2E:  BTFSC  FF2.7
6D30:  BSF    19.7
6D32:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
6D34:  MOVLW  5B
6D36:  MOVLB  8
6D38:  MOVWF  x58
6D3A:  MOVLB  0
6D3C:  CALL   0694
6D40:  BTFSC  19.7
6D42:  BSF    FF2.7
6D44:  MOVFF  161,7F7
6D48:  MOVLW  1B
6D4A:  MOVLB  7
6D4C:  MOVWF  xF8
6D4E:  MOVLB  0
6D50:  GOTO   61AC
6D54:  CLRF   19
6D56:  BTFSC  FF2.7
6D58:  BSF    19.7
6D5A:  BCF    FF2.7
6D5C:  MOVLW  5D
6D5E:  MOVLB  8
6D60:  MOVWF  x58
6D62:  MOVLB  0
6D64:  CALL   0694
6D68:  BTFSC  19.7
6D6A:  BSF    FF2.7
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
6D6C:  MOVFF  100,7F7
6D70:  MOVLW  01
6D72:  MOVLB  7
6D74:  MOVWF  xF8
6D76:  MOVLB  0
6D78:  CALL   5DCA
6D7C:  CLRF   19
6D7E:  BTFSC  FF2.7
6D80:  BSF    19.7
6D82:  BCF    FF2.7
6D84:  MOVLW  2F
6D86:  MOVLB  8
6D88:  MOVWF  x58
6D8A:  MOVLB  0
6D8C:  CALL   0694
6D90:  BTFSC  19.7
6D92:  BSF    FF2.7
6D94:  MOVFF  FF,7F7
6D98:  MOVLW  01
6D9A:  MOVLB  7
6D9C:  MOVWF  xF8
6D9E:  MOVLB  0
6DA0:  CALL   5DCA
6DA4:  CLRF   19
6DA6:  BTFSC  FF2.7
6DA8:  BSF    19.7
6DAA:  BCF    FF2.7
6DAC:  MOVLW  20
6DAE:  MOVLB  8
6DB0:  MOVWF  x58
6DB2:  MOVLB  0
6DB4:  CALL   0694
6DB8:  BTFSC  19.7
6DBA:  BSF    FF2.7
6DBC:  MOVFF  101,7F7
6DC0:  MOVLW  01
6DC2:  MOVLB  7
6DC4:  MOVWF  xF8
6DC6:  MOVLB  0
6DC8:  CALL   5DCA
6DCC:  CLRF   19
6DCE:  BTFSC  FF2.7
6DD0:  BSF    19.7
6DD2:  BCF    FF2.7
6DD4:  MOVLW  3A
6DD6:  MOVLB  8
6DD8:  MOVWF  x58
6DDA:  MOVLB  0
6DDC:  CALL   0694
6DE0:  BTFSC  19.7
6DE2:  BSF    FF2.7
6DE4:  MOVFF  102,7F7
6DE8:  MOVLW  01
6DEA:  MOVLB  7
6DEC:  MOVWF  xF8
6DEE:  MOVLB  0
6DF0:  CALL   5DCA
6DF4:  CLRF   19
6DF6:  BTFSC  FF2.7
6DF8:  BSF    19.7
6DFA:  BCF    FF2.7
6DFC:  MOVLW  3A
6DFE:  MOVLB  8
6E00:  MOVWF  x58
6E02:  MOVLB  0
6E04:  CALL   0694
6E08:  BTFSC  19.7
6E0A:  BSF    FF2.7
6E0C:  MOVFF  103,7F7
6E10:  MOVLW  01
6E12:  MOVLB  7
6E14:  MOVWF  xF8
6E16:  MOVLB  0
6E18:  CALL   5DCA
6E1C:  CLRF   19
6E1E:  BTFSC  FF2.7
6E20:  BSF    19.7
6E22:  BCF    FF2.7
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
6E24:  MOVLW  0A
6E26:  MOVLB  8
6E28:  MOVWF  x58
6E2A:  MOVLB  0
6E2C:  CALL   0694
6E30:  BTFSC  19.7
6E32:  BSF    FF2.7
6E34:  CLRF   19
6E36:  BTFSC  FF2.7
6E38:  BSF    19.7
6E3A:  BCF    FF2.7
6E3C:  MOVLW  0D
6E3E:  MOVLB  8
6E40:  MOVWF  x58
6E42:  MOVLB  0
6E44:  CALL   0694
6E48:  BTFSC  19.7
6E4A:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
6E4C:  CLRF   FEA
6E4E:  MOVLW  41
6E50:  MOVWF  FE9
6E52:  MOVLW  00
6E54:  CALL   040A
6E58:  TBLRD*-
6E5A:  TBLRD*+
6E5C:  MOVF   FF5,W
6E5E:  MOVWF  FEE
6E60:  IORLW  00
6E62:  BNZ   6E5A
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
6E64:  MOVLW  01
6E66:  MOVLB  7
6E68:  MOVWF  xF8
6E6A:  MOVLW  69
6E6C:  MOVWF  xF7
6E6E:  CLRF   xFA
6E70:  MOVLW  41
6E72:  MOVWF  xF9
6E74:  MOVLB  0
6E76:  CALL   5CA4
6E7A:  MOVF   01,F
6E7C:  BTFSS  FD8.2
6E7E:  BRA    70A8
....................       { 
....................          fprintf(COM2,"Year>"); 
6E80:  MOVLW  82
6E82:  MOVWF  FF6
6E84:  MOVLW  1D
6E86:  MOVWF  FF7
6E88:  CLRF   19
6E8A:  BTFSC  FF2.7
6E8C:  BSF    19.7
6E8E:  BCF    FF2.7
6E90:  CALL   06DA
6E94:  BTFSC  19.7
6E96:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6E98:  MOVLW  01
6E9A:  MOVLB  7
6E9C:  MOVWF  xF7
6E9E:  MOVLW  03
6EA0:  MOVWF  xF8
6EA2:  MOVLW  07
6EA4:  MOVWF  xFA
6EA6:  MOVLW  C3
6EA8:  MOVWF  xF9
6EAA:  MOVLB  0
6EAC:  CALL   5B6C
....................          year=(unsigned int8)strtoi(temp); 
6EB0:  MOVLW  07
6EB2:  MOVLB  7
6EB4:  MOVWF  xF8
6EB6:  MOVLW  C3
6EB8:  MOVWF  xF7
6EBA:  MOVLB  0
6EBC:  CALL   6272
6EC0:  MOVFF  01,FE
....................          fprintf(COM2,"Month>"); 
6EC4:  MOVLW  88
6EC6:  MOVWF  FF6
6EC8:  MOVLW  1D
6ECA:  MOVWF  FF7
6ECC:  CLRF   19
6ECE:  BTFSC  FF2.7
6ED0:  BSF    19.7
6ED2:  BCF    FF2.7
6ED4:  CALL   06DA
6ED8:  BTFSC  19.7
6EDA:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6EDC:  MOVLW  01
6EDE:  MOVLB  7
6EE0:  MOVWF  xF7
6EE2:  MOVLW  03
6EE4:  MOVWF  xF8
6EE6:  MOVLW  07
6EE8:  MOVWF  xFA
6EEA:  MOVLW  C3
6EEC:  MOVWF  xF9
6EEE:  MOVLB  0
6EF0:  CALL   5B6C
....................          mon=(unsigned int8)strtoi(temp); 
6EF4:  MOVLW  07
6EF6:  MOVLB  7
6EF8:  MOVWF  xF8
6EFA:  MOVLW  C3
6EFC:  MOVWF  xF7
6EFE:  MOVLB  0
6F00:  CALL   6272
6F04:  MOVFF  01,FF
....................          fprintf(COM2,"Date>"); 
6F08:  MOVLW  90
6F0A:  MOVWF  FF6
6F0C:  MOVLW  1D
6F0E:  MOVWF  FF7
6F10:  CLRF   19
6F12:  BTFSC  FF2.7
6F14:  BSF    19.7
6F16:  BCF    FF2.7
6F18:  CALL   06DA
6F1C:  BTFSC  19.7
6F1E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6F20:  MOVLW  01
6F22:  MOVLB  7
6F24:  MOVWF  xF7
6F26:  MOVLW  03
6F28:  MOVWF  xF8
6F2A:  MOVLW  07
6F2C:  MOVWF  xFA
6F2E:  MOVLW  C3
6F30:  MOVWF  xF9
6F32:  MOVLB  0
6F34:  CALL   5B6C
....................          date = (unsigned int8)strtoi(temp); 
6F38:  MOVLW  07
6F3A:  MOVLB  7
6F3C:  MOVWF  xF8
6F3E:  MOVLW  C3
6F40:  MOVWF  xF7
6F42:  MOVLB  0
6F44:  CALL   6272
6F48:  MOVFF  01,100
....................          fprintf(COM2,"Day>"); 
6F4C:  MOVLW  96
6F4E:  MOVWF  FF6
6F50:  MOVLW  1D
6F52:  MOVWF  FF7
6F54:  CLRF   19
6F56:  BTFSC  FF2.7
6F58:  BSF    19.7
6F5A:  BCF    FF2.7
6F5C:  CALL   06DA
6F60:  BTFSC  19.7
6F62:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6F64:  MOVLW  01
6F66:  MOVLB  7
6F68:  MOVWF  xF7
6F6A:  MOVLW  03
6F6C:  MOVWF  xF8
6F6E:  MOVLW  07
6F70:  MOVWF  xFA
6F72:  MOVLW  C3
6F74:  MOVWF  xF9
6F76:  MOVLB  0
6F78:  CALL   5B6C
....................          day = (unsigned int8)strtoi(temp); 
6F7C:  MOVLW  07
6F7E:  MOVLB  7
6F80:  MOVWF  xF8
6F82:  MOVLW  C3
6F84:  MOVWF  xF7
6F86:  MOVLB  0
6F88:  CALL   6272
6F8C:  MOVFF  01,FD
....................          fprintf(COM2,"Hour>"); 
6F90:  MOVLW  9C
6F92:  MOVWF  FF6
6F94:  MOVLW  1D
6F96:  MOVWF  FF7
6F98:  CLRF   19
6F9A:  BTFSC  FF2.7
6F9C:  BSF    19.7
6F9E:  BCF    FF2.7
6FA0:  CALL   06DA
6FA4:  BTFSC  19.7
6FA6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6FA8:  MOVLW  01
6FAA:  MOVLB  7
6FAC:  MOVWF  xF7
6FAE:  MOVLW  03
6FB0:  MOVWF  xF8
6FB2:  MOVLW  07
6FB4:  MOVWF  xFA
6FB6:  MOVLW  C3
6FB8:  MOVWF  xF9
6FBA:  MOVLB  0
6FBC:  CALL   5B6C
....................          h = (unsigned int8)strtoi(temp); 
6FC0:  MOVLW  07
6FC2:  MOVLB  7
6FC4:  MOVWF  xF8
6FC6:  MOVLW  C3
6FC8:  MOVWF  xF7
6FCA:  MOVLB  0
6FCC:  CALL   6272
6FD0:  MOVFF  01,101
....................          fprintf(COM2,"Minutes>"); 
6FD4:  MOVLW  A2
6FD6:  MOVWF  FF6
6FD8:  MOVLW  1D
6FDA:  MOVWF  FF7
6FDC:  CLRF   19
6FDE:  BTFSC  FF2.7
6FE0:  BSF    19.7
6FE2:  BCF    FF2.7
6FE4:  CALL   06DA
6FE8:  BTFSC  19.7
6FEA:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6FEC:  MOVLW  01
6FEE:  MOVLB  7
6FF0:  MOVWF  xF7
6FF2:  MOVLW  03
6FF4:  MOVWF  xF8
6FF6:  MOVLW  07
6FF8:  MOVWF  xFA
6FFA:  MOVLW  C3
6FFC:  MOVWF  xF9
6FFE:  MOVLB  0
7000:  CALL   5B6C
....................          min = (unsigned int8)strtoi(temp);                   
7004:  MOVLW  07
7006:  MOVLB  7
7008:  MOVWF  xF8
700A:  MOVLW  C3
700C:  MOVWF  xF7
700E:  MOVLB  0
7010:  CALL   6272
7014:  MOVFF  01,102
....................          fprintf(COM2,"Seconds>"); 
7018:  MOVLW  AC
701A:  MOVWF  FF6
701C:  MOVLW  1D
701E:  MOVWF  FF7
7020:  CLRF   19
7022:  BTFSC  FF2.7
7024:  BSF    19.7
7026:  BCF    FF2.7
7028:  CALL   06DA
702C:  BTFSC  19.7
702E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7030:  MOVLW  01
7032:  MOVLB  7
7034:  MOVWF  xF7
7036:  MOVLW  03
7038:  MOVWF  xF8
703A:  MOVLW  07
703C:  MOVWF  xFA
703E:  MOVLW  C3
7040:  MOVWF  xF9
7042:  MOVLB  0
7044:  CALL   5B6C
....................          sec = (unsigned int8)strtoi(temp);                   
7048:  MOVLW  07
704A:  MOVLB  7
704C:  MOVWF  xF8
704E:  MOVLW  C3
7050:  MOVWF  xF7
7052:  MOVLB  0
7054:  CALL   6272
7058:  MOVFF  01,103
705C:  CLRF   19
705E:  BTFSC  FF2.7
7060:  BSF    19.7
7062:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
7064:  MOVLW  0A
7066:  MOVLB  8
7068:  MOVWF  x58
706A:  MOVLB  0
706C:  CALL   0694
7070:  BTFSC  19.7
7072:  BSF    FF2.7
7074:  CLRF   19
7076:  BTFSC  FF2.7
7078:  BSF    19.7
707A:  BCF    FF2.7
707C:  MOVLW  0D
707E:  MOVLB  8
7080:  MOVWF  x58
7082:  MOVLB  0
7084:  CALL   0694
7088:  BTFSC  19.7
708A:  BSF    FF2.7
....................          rtc_set_datetime(date,mon,year,day,h,min); 
708C:  MOVFF  100,7F7
7090:  MOVFF  FF,7F8
7094:  MOVFF  FE,7F9
7098:  MOVFF  FD,7FA
709C:  MOVFF  101,7FB
70A0:  MOVFF  102,7FC
70A4:  GOTO   63AC
....................       } 
....................       strcpy(buffer2,"MS"); 
70A8:  CLRF   FEA
70AA:  MOVLW  41
70AC:  MOVWF  FE9
70AE:  MOVLW  00
70B0:  CALL   041E
70B4:  TBLRD*-
70B6:  TBLRD*+
70B8:  MOVF   FF5,W
70BA:  MOVWF  FEE
70BC:  IORLW  00
70BE:  BNZ   70B6
....................       if(!stringcomp(buffer_uart,buffer2)) 
70C0:  MOVLW  01
70C2:  MOVLB  7
70C4:  MOVWF  xF8
70C6:  MOVLW  69
70C8:  MOVWF  xF7
70CA:  CLRF   xFA
70CC:  MOVLW  41
70CE:  MOVWF  xF9
70D0:  MOVLB  0
70D2:  CALL   5CA4
70D6:  MOVF   01,F
70D8:  BTFSS  FD8.2
70DA:  BRA    71EE
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
70DC:  MOVLW  B6
70DE:  MOVWF  FF6
70E0:  MOVLW  1D
70E2:  MOVWF  FF7
70E4:  CLRF   19
70E6:  BTFSC  FF2.7
70E8:  BSF    19.7
70EA:  BCF    FF2.7
70EC:  CALL   06DA
70F0:  BTFSC  19.7
70F2:  BSF    FF2.7
70F4:  CLRF   19
70F6:  BTFSC  FF2.7
70F8:  BSF    19.7
70FA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
70FC:  MOVLW  0A
70FE:  MOVLB  8
7100:  MOVWF  x58
7102:  MOVLB  0
7104:  CALL   0694
7108:  BTFSC  19.7
710A:  BSF    FF2.7
710C:  CLRF   19
710E:  BTFSC  FF2.7
7110:  BSF    19.7
7112:  BCF    FF2.7
7114:  MOVLW  0D
7116:  MOVLB  8
7118:  MOVWF  x58
711A:  MOVLB  0
711C:  CALL   0694
7120:  BTFSC  19.7
7122:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
7124:  MOVLW  D6
7126:  MOVWF  FF6
7128:  MOVLW  1D
712A:  MOVWF  FF7
712C:  CLRF   19
712E:  BTFSC  FF2.7
7130:  BSF    19.7
7132:  BCF    FF2.7
7134:  CALL   06DA
7138:  BTFSC  19.7
713A:  BSF    FF2.7
713C:  CLRF   19
713E:  BTFSC  FF2.7
7140:  BSF    19.7
7142:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7144:  MOVLW  0A
7146:  MOVLB  8
7148:  MOVWF  x58
714A:  MOVLB  0
714C:  CALL   0694
7150:  BTFSC  19.7
7152:  BSF    FF2.7
7154:  CLRF   19
7156:  BTFSC  FF2.7
7158:  BSF    19.7
715A:  BCF    FF2.7
715C:  MOVLW  0D
715E:  MOVLB  8
7160:  MOVWF  x58
7162:  MOVLB  0
7164:  CALL   0694
7168:  BTFSC  19.7
716A:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
716C:  MOVLW  01
716E:  MOVLB  7
7170:  MOVWF  xF7
7172:  MOVLW  03
7174:  MOVWF  xF8
7176:  MOVLW  07
7178:  MOVWF  xFA
717A:  MOVLW  C3
717C:  MOVWF  xF9
717E:  MOVLB  0
7180:  CALL   5B6C
....................           mode_sl = (unsigned int8)strtoi(temp); 
7184:  MOVLW  07
7186:  MOVLB  7
7188:  MOVWF  xF8
718A:  MOVLW  C3
718C:  MOVWF  xF7
718E:  MOVLB  0
7190:  CALL   6272
7194:  MOVFF  01,6E6
7198:  CLRF   19
719A:  BTFSC  FF2.7
719C:  BSF    19.7
719E:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
71A0:  MOVLB  8
71A2:  CLRF   x43
71A4:  CLRF   x42
71A6:  CLRF   x41
71A8:  MOVLW  91
71AA:  MOVWF  x40
71AC:  MOVFF  6E6,844
71B0:  MOVLB  0
71B2:  CALL   3A9E
71B6:  BTFSC  19.7
71B8:  BSF    FF2.7
....................           set_tris_a(0xff); 
71BA:  MOVLW  FF
71BC:  MOVWF  F92
71BE:  CLRF   19
71C0:  BTFSC  FF2.7
71C2:  BSF    19.7
71C4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
71C6:  MOVLW  0A
71C8:  MOVLB  8
71CA:  MOVWF  x58
71CC:  MOVLB  0
71CE:  CALL   0694
71D2:  BTFSC  19.7
71D4:  BSF    FF2.7
71D6:  CLRF   19
71D8:  BTFSC  FF2.7
71DA:  BSF    19.7
71DC:  BCF    FF2.7
71DE:  MOVLW  0D
71E0:  MOVLB  8
71E2:  MOVWF  x58
71E4:  MOVLB  0
71E6:  CALL   0694
71EA:  BTFSC  19.7
71EC:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"KP"); 
71EE:  CLRF   FEA
71F0:  MOVLW  41
71F2:  MOVWF  FE9
71F4:  MOVLW  00
71F6:  CALL   0432
71FA:  TBLRD*-
71FC:  TBLRD*+
71FE:  MOVF   FF5,W
7200:  MOVWF  FEE
7202:  IORLW  00
7204:  BNZ   71FC
....................       if(!stringcomp(buffer_uart,buffer2)) 
7206:  MOVLW  01
7208:  MOVLB  7
720A:  MOVWF  xF8
720C:  MOVLW  69
720E:  MOVWF  xF7
7210:  CLRF   xFA
7212:  MOVLW  41
7214:  MOVWF  xF9
7216:  MOVLB  0
7218:  CALL   5CA4
721C:  MOVF   01,F
721E:  BTFSS  FD8.2
7220:  BRA    7330
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
7222:  MOVLW  F6
7224:  MOVWF  FF6
7226:  MOVLW  1D
7228:  MOVWF  FF7
722A:  CLRF   19
722C:  BTFSC  FF2.7
722E:  BSF    19.7
7230:  BCF    FF2.7
7232:  CALL   06DA
7236:  BTFSC  19.7
7238:  BSF    FF2.7
723A:  CLRF   19
723C:  BTFSC  FF2.7
723E:  BSF    19.7
7240:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7242:  MOVLW  0A
7244:  MOVLB  8
7246:  MOVWF  x58
7248:  MOVLB  0
724A:  CALL   0694
724E:  BTFSC  19.7
7250:  BSF    FF2.7
7252:  CLRF   19
7254:  BTFSC  FF2.7
7256:  BSF    19.7
7258:  BCF    FF2.7
725A:  MOVLW  0D
725C:  MOVLB  8
725E:  MOVWF  x58
7260:  MOVLB  0
7262:  CALL   0694
7266:  BTFSC  19.7
7268:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
726A:  MOVLW  14
726C:  MOVWF  FF6
726E:  MOVLW  1E
7270:  MOVWF  FF7
7272:  CLRF   19
7274:  BTFSC  FF2.7
7276:  BSF    19.7
7278:  BCF    FF2.7
727A:  CALL   06DA
727E:  BTFSC  19.7
7280:  BSF    FF2.7
7282:  CLRF   19
7284:  BTFSC  FF2.7
7286:  BSF    19.7
7288:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
728A:  MOVLW  0A
728C:  MOVLB  8
728E:  MOVWF  x58
7290:  MOVLB  0
7292:  CALL   0694
7296:  BTFSC  19.7
7298:  BSF    FF2.7
729A:  CLRF   19
729C:  BTFSC  FF2.7
729E:  BSF    19.7
72A0:  BCF    FF2.7
72A2:  MOVLW  0D
72A4:  MOVLB  8
72A6:  MOVWF  x58
72A8:  MOVLB  0
72AA:  CALL   0694
72AE:  BTFSC  19.7
72B0:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
72B2:  MOVLW  01
72B4:  MOVLB  7
72B6:  MOVWF  xF7
72B8:  MOVLW  03
72BA:  MOVWF  xF8
72BC:  MOVLW  07
72BE:  MOVWF  xFA
72C0:  MOVLW  C3
72C2:  MOVWF  xF9
72C4:  MOVLB  0
72C6:  CALL   5B6C
....................           KP_mode = (unsigned int8)strtoi(temp); 
72CA:  MOVLW  07
72CC:  MOVLB  7
72CE:  MOVWF  xF8
72D0:  MOVLW  C3
72D2:  MOVWF  xF7
72D4:  MOVLB  0
72D6:  CALL   6272
72DA:  MOVFF  01,150
72DE:  CLRF   19
72E0:  BTFSC  FF2.7
72E2:  BSF    19.7
72E4:  BCF    FF2.7
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
72E6:  MOVLB  8
72E8:  CLRF   x43
72EA:  CLRF   x42
72EC:  CLRF   x41
72EE:  MOVLW  7F
72F0:  MOVWF  x40
72F2:  MOVFF  150,844
72F6:  MOVLB  0
72F8:  CALL   3A9E
72FC:  BTFSC  19.7
72FE:  BSF    FF2.7
7300:  CLRF   19
7302:  BTFSC  FF2.7
7304:  BSF    19.7
7306:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7308:  MOVLW  0A
730A:  MOVLB  8
730C:  MOVWF  x58
730E:  MOVLB  0
7310:  CALL   0694
7314:  BTFSC  19.7
7316:  BSF    FF2.7
7318:  CLRF   19
731A:  BTFSC  FF2.7
731C:  BSF    19.7
731E:  BCF    FF2.7
7320:  MOVLW  0D
7322:  MOVLB  8
7324:  MOVWF  x58
7326:  MOVLB  0
7328:  CALL   0694
732C:  BTFSC  19.7
732E:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"tran time"); 
7330:  CLRF   FEA
7332:  MOVLW  41
7334:  MOVWF  FE9
7336:  MOVLW  00
7338:  CALL   0446
733C:  TBLRD*-
733E:  TBLRD*+
7340:  MOVF   FF5,W
7342:  MOVWF  FEE
7344:  IORLW  00
7346:  BNZ   733E
....................       if(!stringcomp(buffer_uart,buffer2)) 
7348:  MOVLW  01
734A:  MOVLB  7
734C:  MOVWF  xF8
734E:  MOVLW  69
7350:  MOVWF  xF7
7352:  CLRF   xFA
7354:  MOVLW  41
7356:  MOVWF  xF9
7358:  MOVLB  0
735A:  CALL   5CA4
735E:  MOVF   01,F
7360:  BNZ   7428
....................       { 
....................           fprintf(COM2,"Input Number"); 
7362:  MOVLW  32
7364:  MOVWF  FF6
7366:  MOVLW  1E
7368:  MOVWF  FF7
736A:  CLRF   19
736C:  BTFSC  FF2.7
736E:  BSF    19.7
7370:  BCF    FF2.7
7372:  CALL   06DA
7376:  BTFSC  19.7
7378:  BSF    FF2.7
737A:  CLRF   19
737C:  BTFSC  FF2.7
737E:  BSF    19.7
7380:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7382:  MOVLW  0A
7384:  MOVLB  8
7386:  MOVWF  x58
7388:  MOVLB  0
738A:  CALL   0694
738E:  BTFSC  19.7
7390:  BSF    FF2.7
7392:  CLRF   19
7394:  BTFSC  FF2.7
7396:  BSF    19.7
7398:  BCF    FF2.7
739A:  MOVLW  0D
739C:  MOVLB  8
739E:  MOVWF  x58
73A0:  MOVLB  0
73A2:  CALL   0694
73A6:  BTFSC  19.7
73A8:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
73AA:  MOVLW  01
73AC:  MOVLB  7
73AE:  MOVWF  xF7
73B0:  MOVLW  03
73B2:  MOVWF  xF8
73B4:  MOVLW  07
73B6:  MOVWF  xFA
73B8:  MOVLW  C3
73BA:  MOVWF  xF9
73BC:  MOVLB  0
73BE:  CALL   5B6C
....................           delaycharaction = (unsigned int8)strtoi(temp); 
73C2:  MOVLW  07
73C4:  MOVLB  7
73C6:  MOVWF  xF8
73C8:  MOVLW  C3
73CA:  MOVWF  xF7
73CC:  MOVLB  0
73CE:  CALL   6272
73D2:  MOVFF  01,161
73D6:  CLRF   19
73D8:  BTFSC  FF2.7
73DA:  BSF    19.7
73DC:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
73DE:  MOVLB  8
73E0:  CLRF   x43
73E2:  CLRF   x42
73E4:  CLRF   x41
73E6:  MOVLW  94
73E8:  MOVWF  x40
73EA:  MOVFF  161,844
73EE:  MOVLB  0
73F0:  CALL   3A9E
73F4:  BTFSC  19.7
73F6:  BSF    FF2.7
73F8:  CLRF   19
73FA:  BTFSC  FF2.7
73FC:  BSF    19.7
73FE:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7400:  MOVLW  0A
7402:  MOVLB  8
7404:  MOVWF  x58
7406:  MOVLB  0
7408:  CALL   0694
740C:  BTFSC  19.7
740E:  BSF    FF2.7
7410:  CLRF   19
7412:  BTFSC  FF2.7
7414:  BSF    19.7
7416:  BCF    FF2.7
7418:  MOVLW  0D
741A:  MOVLB  8
741C:  MOVWF  x58
741E:  MOVLB  0
7420:  CALL   0694
7424:  BTFSC  19.7
7426:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
7428:  CLRF   FEA
742A:  MOVLW  41
742C:  MOVWF  FE9
742E:  MOVLW  00
7430:  CALL   0460
7434:  TBLRD*-
7436:  TBLRD*+
7438:  MOVF   FF5,W
743A:  MOVWF  FEE
743C:  IORLW  00
743E:  BNZ   7436
....................       if(!stringcomp(buffer_uart,buffer2)) 
7440:  MOVLW  01
7442:  MOVLB  7
7444:  MOVWF  xF8
7446:  MOVLW  69
7448:  MOVWF  xF7
744A:  CLRF   xFA
744C:  MOVLW  41
744E:  MOVWF  xF9
7450:  MOVLB  0
7452:  CALL   5CA4
7456:  MOVF   01,F
7458:  BTFSS  FD8.2
745A:  BRA    756A
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
745C:  MOVLW  40
745E:  MOVWF  FF6
7460:  MOVLW  1E
7462:  MOVWF  FF7
7464:  CLRF   19
7466:  BTFSC  FF2.7
7468:  BSF    19.7
746A:  BCF    FF2.7
746C:  CALL   06DA
7470:  BTFSC  19.7
7472:  BSF    FF2.7
7474:  CLRF   19
7476:  BTFSC  FF2.7
7478:  BSF    19.7
747A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
747C:  MOVLW  0A
747E:  MOVLB  8
7480:  MOVWF  x58
7482:  MOVLB  0
7484:  CALL   0694
7488:  BTFSC  19.7
748A:  BSF    FF2.7
748C:  CLRF   19
748E:  BTFSC  FF2.7
7490:  BSF    19.7
7492:  BCF    FF2.7
7494:  MOVLW  0D
7496:  MOVLB  8
7498:  MOVWF  x58
749A:  MOVLB  0
749C:  CALL   0694
74A0:  BTFSC  19.7
74A2:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
74A4:  MOVLW  66
74A6:  MOVWF  FF6
74A8:  MOVLW  1E
74AA:  MOVWF  FF7
74AC:  CLRF   19
74AE:  BTFSC  FF2.7
74B0:  BSF    19.7
74B2:  BCF    FF2.7
74B4:  CALL   06DA
74B8:  BTFSC  19.7
74BA:  BSF    FF2.7
74BC:  CLRF   19
74BE:  BTFSC  FF2.7
74C0:  BSF    19.7
74C2:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
74C4:  MOVLW  0A
74C6:  MOVLB  8
74C8:  MOVWF  x58
74CA:  MOVLB  0
74CC:  CALL   0694
74D0:  BTFSC  19.7
74D2:  BSF    FF2.7
74D4:  CLRF   19
74D6:  BTFSC  FF2.7
74D8:  BSF    19.7
74DA:  BCF    FF2.7
74DC:  MOVLW  0D
74DE:  MOVLB  8
74E0:  MOVWF  x58
74E2:  MOVLB  0
74E4:  CALL   0694
74E8:  BTFSC  19.7
74EA:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
74EC:  MOVLW  01
74EE:  MOVLB  7
74F0:  MOVWF  xF7
74F2:  MOVLW  03
74F4:  MOVWF  xF8
74F6:  MOVLW  07
74F8:  MOVWF  xFA
74FA:  MOVLW  C3
74FC:  MOVWF  xF9
74FE:  MOVLB  0
7500:  CALL   5B6C
....................           type_KB=(unsigned int8)strtoi(temp); 
7504:  MOVLW  07
7506:  MOVLB  7
7508:  MOVWF  xF8
750A:  MOVLW  C3
750C:  MOVWF  xF7
750E:  MOVLB  0
7510:  CALL   6272
7514:  MOVFF  01,154
7518:  CLRF   19
751A:  BTFSC  FF2.7
751C:  BSF    19.7
751E:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
7520:  MOVLB  8
7522:  CLRF   x43
7524:  CLRF   x42
7526:  CLRF   x41
7528:  MOVLW  7E
752A:  MOVWF  x40
752C:  MOVFF  154,844
7530:  MOVLB  0
7532:  CALL   3A9E
7536:  BTFSC  19.7
7538:  BSF    FF2.7
753A:  CLRF   19
753C:  BTFSC  FF2.7
753E:  BSF    19.7
7540:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
7542:  MOVLW  0A
7544:  MOVLB  8
7546:  MOVWF  x58
7548:  MOVLB  0
754A:  CALL   0694
754E:  BTFSC  19.7
7550:  BSF    FF2.7
7552:  CLRF   19
7554:  BTFSC  FF2.7
7556:  BSF    19.7
7558:  BCF    FF2.7
755A:  MOVLW  0D
755C:  MOVLB  8
755E:  MOVWF  x58
7560:  MOVLB  0
7562:  CALL   0694
7566:  BTFSC  19.7
7568:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
756A:  CLRF   FEA
756C:  MOVLW  41
756E:  MOVWF  FE9
7570:  MOVLW  00
7572:  CALL   0476
7576:  TBLRD*-
7578:  TBLRD*+
757A:  MOVF   FF5,W
757C:  MOVWF  FEE
757E:  IORLW  00
7580:  BNZ   7578
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7582:  MOVLW  01
7584:  MOVLB  7
7586:  MOVWF  xF8
7588:  MOVLW  69
758A:  MOVWF  xF7
758C:  CLRF   xFA
758E:  MOVLW  41
7590:  MOVWF  xF9
7592:  MOVLB  0
7594:  CALL   5CA4
7598:  MOVF   01,F
759A:  BTFSS  FD8.2
759C:  BRA    7784
....................       { 
....................          printf("h-> Help\n\r"); 
759E:  MOVLW  8C
75A0:  MOVWF  FF6
75A2:  MOVLW  1E
75A4:  MOVWF  FF7
75A6:  CLRF   19
75A8:  BTFSC  FF2.7
75AA:  BSF    19.7
75AC:  BCF    FF2.7
75AE:  CALL   06DA
75B2:  BTFSC  19.7
75B4:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
75B6:  MOVLW  98
75B8:  MOVWF  FF6
75BA:  MOVLW  1E
75BC:  MOVWF  FF7
75BE:  CLRF   19
75C0:  BTFSC  FF2.7
75C2:  BSF    19.7
75C4:  BCF    FF2.7
75C6:  CALL   06DA
75CA:  BTFSC  19.7
75CC:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
75CE:  MOVLW  AA
75D0:  MOVWF  FF6
75D2:  MOVLW  1E
75D4:  MOVWF  FF7
75D6:  CLRF   19
75D8:  BTFSC  FF2.7
75DA:  BSF    19.7
75DC:  BCF    FF2.7
75DE:  CALL   06DA
75E2:  BTFSC  19.7
75E4:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
75E6:  MOVLW  BC
75E8:  MOVWF  FF6
75EA:  MOVLW  1E
75EC:  MOVWF  FF7
75EE:  CLRF   19
75F0:  BTFSC  FF2.7
75F2:  BSF    19.7
75F4:  BCF    FF2.7
75F6:  CALL   06DA
75FA:  BTFSC  19.7
75FC:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
75FE:  MOVLW  DC
7600:  MOVWF  FF6
7602:  MOVLW  1E
7604:  MOVWF  FF7
7606:  CLRF   19
7608:  BTFSC  FF2.7
760A:  BSF    19.7
760C:  BCF    FF2.7
760E:  CALL   06DA
7612:  BTFSC  19.7
7614:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
7616:  MOVLW  F8
7618:  MOVWF  FF6
761A:  MOVLW  1E
761C:  MOVWF  FF7
761E:  CLRF   19
7620:  BTFSC  FF2.7
7622:  BSF    19.7
7624:  BCF    FF2.7
7626:  CALL   06DA
762A:  BTFSC  19.7
762C:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
762E:  MOVLW  06
7630:  MOVWF  FF6
7632:  MOVLW  1F
7634:  MOVWF  FF7
7636:  CLRF   19
7638:  BTFSC  FF2.7
763A:  BSF    19.7
763C:  BCF    FF2.7
763E:  CALL   06DA
7642:  BTFSC  19.7
7644:  BSF    FF2.7
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
7646:  MOVLW  12
7648:  MOVWF  FF6
764A:  MOVLW  1F
764C:  MOVWF  FF7
764E:  CLRF   19
7650:  BTFSC  FF2.7
7652:  BSF    19.7
7654:  BCF    FF2.7
7656:  CALL   06DA
765A:  BTFSC  19.7
765C:  BSF    FF2.7
765E:  CLRF   19
7660:  BTFSC  FF2.7
7662:  BSF    19.7
7664:  BCF    FF2.7
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
7666:  MOVLB  8
7668:  CLRF   x3B
766A:  CLRF   x3A
766C:  CLRF   x39
766E:  MOVLW  7F
7670:  MOVWF  x38
7672:  MOVLB  0
7674:  CALL   354E
7678:  BTFSC  19.7
767A:  BSF    FF2.7
767C:  MOVFF  01,150
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
7680:  MOVLB  1
7682:  MOVF   x50,F
7684:  BZ    76A4
7686:  MOVLW  3E
7688:  MOVWF  FF6
768A:  MOVLW  1F
768C:  MOVWF  FF7
768E:  CLRF   19
7690:  BTFSC  FF2.7
7692:  BSF    19.7
7694:  BCF    FF2.7
7696:  MOVLB  0
7698:  CALL   06DA
769C:  BTFSC  19.7
769E:  BSF    FF2.7
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
76A0:  BRA    76BE
76A2:  MOVLB  1
76A4:  MOVLW  60
76A6:  MOVWF  FF6
76A8:  MOVLW  1F
76AA:  MOVWF  FF7
76AC:  CLRF   19
76AE:  BTFSC  FF2.7
76B0:  BSF    19.7
76B2:  BCF    FF2.7
76B4:  MOVLB  0
76B6:  CALL   06DA
76BA:  BTFSC  19.7
76BC:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
76BE:  MOVLW  84
76C0:  MOVWF  FF6
76C2:  MOVLW  1F
76C4:  MOVWF  FF7
76C6:  CLRF   19
76C8:  BTFSC  FF2.7
76CA:  BSF    19.7
76CC:  BCF    FF2.7
76CE:  CALL   06DA
76D2:  BTFSC  19.7
76D4:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
76D6:  MOVLW  AC
76D8:  MOVWF  FF6
76DA:  MOVLW  1F
76DC:  MOVWF  FF7
76DE:  CLRF   19
76E0:  BTFSC  FF2.7
76E2:  BSF    19.7
76E4:  BCF    FF2.7
76E6:  CALL   06DA
76EA:  BTFSC  19.7
76EC:  BSF    FF2.7
76EE:  CLRF   19
76F0:  BTFSC  FF2.7
76F2:  BSF    19.7
76F4:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
76F6:  MOVLB  8
76F8:  CLRF   x3B
76FA:  CLRF   x3A
76FC:  CLRF   x39
76FE:  MOVLW  7E
7700:  MOVWF  x38
7702:  MOVLB  0
7704:  CALL   354E
7708:  BTFSC  19.7
770A:  BSF    FF2.7
770C:  MOVFF  01,7F7
7710:  MOVLW  C8
7712:  MOVWF  FF6
7714:  MOVLW  1F
7716:  MOVWF  FF7
7718:  CLRF   19
771A:  BTFSC  FF2.7
771C:  BSF    19.7
771E:  BCF    FF2.7
7720:  MOVLW  06
7722:  MOVLB  8
7724:  MOVWF  x4C
7726:  MOVLB  0
7728:  CALL   1652
772C:  BTFSC  19.7
772E:  BSF    FF2.7
7730:  CLRF   19
7732:  BTFSC  FF2.7
7734:  BSF    19.7
7736:  BCF    FF2.7
7738:  MOVFF  7F7,838
773C:  MOVLW  18
773E:  MOVLB  8
7740:  MOVWF  x39
7742:  MOVLB  0
7744:  CALL   1766
7748:  BTFSC  19.7
774A:  BSF    FF2.7
774C:  MOVLW  D0
774E:  MOVWF  FF6
7750:  MOVLW  1F
7752:  MOVWF  FF7
7754:  CLRF   19
7756:  BTFSC  FF2.7
7758:  BSF    19.7
775A:  BCF    FF2.7
775C:  MOVLW  1D
775E:  MOVLB  8
7760:  MOVWF  x4C
7762:  MOVLB  0
7764:  CALL   1652
7768:  BTFSC  19.7
776A:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
776C:  MOVLW  EE
776E:  MOVWF  FF6
7770:  MOVLW  1F
7772:  MOVWF  FF7
7774:  CLRF   19
7776:  BTFSC  FF2.7
7778:  BSF    19.7
777A:  BCF    FF2.7
777C:  CALL   06DA
7780:  BTFSC  19.7
7782:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
7784:  CLRF   FEA
7786:  MOVLW  41
7788:  MOVWF  FE9
778A:  MOVLW  00
778C:  CALL   0488
7790:  TBLRD*-
7792:  TBLRD*+
7794:  MOVF   FF5,W
7796:  MOVWF  FEE
7798:  IORLW  00
779A:  BNZ   7792
....................       if(!stringcomp(buffer_uart,buffer2))  
779C:  MOVLW  01
779E:  MOVLB  7
77A0:  MOVWF  xF8
77A2:  MOVLW  69
77A4:  MOVWF  xF7
77A6:  CLRF   xFA
77A8:  MOVLW  41
77AA:  MOVWF  xF9
77AC:  MOVLB  0
77AE:  CALL   5CA4
77B2:  MOVF   01,F
77B4:  BTFSS  FD8.2
77B6:  BRA    7902
....................       { 
....................          fprintf(COM2,"old password:"); 
77B8:  MOVLW  08
77BA:  MOVWF  FF6
77BC:  MOVLW  20
77BE:  MOVWF  FF7
77C0:  CLRF   19
77C2:  BTFSC  FF2.7
77C4:  BSF    19.7
77C6:  BCF    FF2.7
77C8:  CALL   06DA
77CC:  BTFSC  19.7
77CE:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
77D0:  MOVLB  7
77D2:  CLRF   xFA
77D4:  CLRF   xF9
77D6:  CLRF   xF8
77D8:  CLRF   xF7
77DA:  CLRF   xFE
77DC:  CLRF   xFD
77DE:  CLRF   xFC
77E0:  MOVLW  14
77E2:  MOVWF  xFB
77E4:  MOVLB  8
77E6:  CLRF   x00
77E8:  MOVLW  55
77EA:  MOVLB  7
77EC:  MOVWF  xFF
77EE:  MOVLB  0
77F0:  CALL   4632
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
77F4:  MOVLW  02
77F6:  MOVLB  7
77F8:  MOVWF  xF7
77FA:  MOVLW  14
77FC:  MOVWF  xF8
77FE:  CLRF   xFA
7800:  MOVLW  69
7802:  MOVWF  xF9
7804:  MOVLB  0
7806:  CALL   5B6C
....................          if(!stringcomp(entpassword,password)) 
780A:  MOVLB  7
780C:  CLRF   xF8
780E:  MOVLW  69
7810:  MOVWF  xF7
7812:  CLRF   xFA
7814:  MOVLW  55
7816:  MOVWF  xF9
7818:  MOVLB  0
781A:  CALL   5CA4
781E:  MOVF   01,F
7820:  BNZ   78EA
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
7822:  MOVLW  16
7824:  MOVWF  FF6
7826:  MOVLW  20
7828:  MOVWF  FF7
782A:  CLRF   19
782C:  BTFSC  FF2.7
782E:  BSF    19.7
7830:  BCF    FF2.7
7832:  CALL   06DA
7836:  BTFSC  19.7
7838:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
783A:  MOVLW  02
783C:  MOVLB  7
783E:  MOVWF  xF7
7840:  MOVLW  14
7842:  MOVWF  xF8
7844:  CLRF   xFA
7846:  MOVLW  69
7848:  MOVWF  xF9
784A:  MOVLB  0
784C:  CALL   5B6C
....................             fprintf(COM2,"\n\ragain:"); 
7850:  MOVLW  1E
7852:  MOVWF  FF6
7854:  MOVLW  20
7856:  MOVWF  FF7
7858:  CLRF   19
785A:  BTFSC  FF2.7
785C:  BSF    19.7
785E:  BCF    FF2.7
7860:  CALL   06DA
7864:  BTFSC  19.7
7866:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
7868:  MOVLW  02
786A:  MOVLB  7
786C:  MOVWF  xF7
786E:  MOVLW  14
7870:  MOVWF  xF8
7872:  CLRF   xFA
7874:  MOVLW  55
7876:  MOVWF  xF9
7878:  MOVLB  0
787A:  CALL   5B6C
....................             if(!stringcomp(entpassword,password)) 
787E:  MOVLB  7
7880:  CLRF   xF8
7882:  MOVLW  69
7884:  MOVWF  xF7
7886:  CLRF   xFA
7888:  MOVLW  55
788A:  MOVWF  xF9
788C:  MOVLB  0
788E:  CALL   5CA4
7892:  MOVF   01,F
7894:  BNZ   78D0
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
7896:  MOVLB  8
7898:  CLRF   x0F
789A:  CLRF   x0E
789C:  CLRF   x0D
789E:  CLRF   x0C
78A0:  CLRF   x13
78A2:  CLRF   x12
78A4:  CLRF   x11
78A6:  MOVLW  14
78A8:  MOVWF  x10
78AA:  CLRF   x15
78AC:  MOVLW  55
78AE:  MOVWF  x14
78B0:  MOVLB  0
78B2:  CALL   46FA
....................                fprintf(COM2,"\n\rOK\n\r");    
78B6:  MOVLW  28
78B8:  MOVWF  FF6
78BA:  MOVLW  20
78BC:  MOVWF  FF7
78BE:  CLRF   19
78C0:  BTFSC  FF2.7
78C2:  BSF    19.7
78C4:  BCF    FF2.7
78C6:  CALL   06DA
78CA:  BTFSC  19.7
78CC:  BSF    FF2.7
....................             } 
....................                else 
78CE:  BRA    78E8
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
78D0:  MOVLW  30
78D2:  MOVWF  FF6
78D4:  MOVLW  20
78D6:  MOVWF  FF7
78D8:  CLRF   19
78DA:  BTFSC  FF2.7
78DC:  BSF    19.7
78DE:  BCF    FF2.7
78E0:  CALL   06DA
78E4:  BTFSC  19.7
78E6:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
78E8:  BRA    7902
....................             { 
....................                fprintf(COM2," X\n\r"); 
78EA:  MOVLW  38
78EC:  MOVWF  FF6
78EE:  MOVLW  20
78F0:  MOVWF  FF7
78F2:  CLRF   19
78F4:  BTFSC  FF2.7
78F6:  BSF    19.7
78F8:  BCF    FF2.7
78FA:  CALL   06DA
78FE:  BTFSC  19.7
7900:  BSF    FF2.7
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
7902:  CLRF   FEA
7904:  MOVLW  41
7906:  MOVWF  FE9
7908:  MOVLW  00
790A:  CALL   04A2
790E:  TBLRD*-
7910:  TBLRD*+
7912:  MOVF   FF5,W
7914:  MOVWF  FEE
7916:  IORLW  00
7918:  BNZ   7910
....................       if(!stringcomp(buffer_uart,buffer2)) 
791A:  MOVLW  01
791C:  MOVLB  7
791E:  MOVWF  xF8
7920:  MOVLW  69
7922:  MOVWF  xF7
7924:  CLRF   xFA
7926:  MOVLW  41
7928:  MOVWF  xF9
792A:  MOVLB  0
792C:  CALL   5CA4
7930:  MOVF   01,F
7932:  BTFSS  FD8.2
7934:  BRA    7A44
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
7936:  MOVLW  3E
7938:  MOVWF  FF6
793A:  MOVLW  20
793C:  MOVWF  FF7
793E:  CLRF   19
7940:  BTFSC  FF2.7
7942:  BSF    19.7
7944:  BCF    FF2.7
7946:  CALL   06DA
794A:  BTFSC  19.7
794C:  BSF    FF2.7
794E:  CLRF   19
7950:  BTFSC  FF2.7
7952:  BSF    19.7
7954:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7956:  MOVLW  0A
7958:  MOVLB  8
795A:  MOVWF  x58
795C:  MOVLB  0
795E:  CALL   0694
7962:  BTFSC  19.7
7964:  BSF    FF2.7
7966:  CLRF   19
7968:  BTFSC  FF2.7
796A:  BSF    19.7
796C:  BCF    FF2.7
796E:  MOVLW  0D
7970:  MOVLB  8
7972:  MOVWF  x58
7974:  MOVLB  0
7976:  CALL   0694
797A:  BTFSC  19.7
797C:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
797E:  MOVLW  5E
7980:  MOVWF  FF6
7982:  MOVLW  20
7984:  MOVWF  FF7
7986:  CLRF   19
7988:  BTFSC  FF2.7
798A:  BSF    19.7
798C:  BCF    FF2.7
798E:  CALL   06DA
7992:  BTFSC  19.7
7994:  BSF    FF2.7
7996:  CLRF   19
7998:  BTFSC  FF2.7
799A:  BSF    19.7
799C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
799E:  MOVLW  0A
79A0:  MOVLB  8
79A2:  MOVWF  x58
79A4:  MOVLB  0
79A6:  CALL   0694
79AA:  BTFSC  19.7
79AC:  BSF    FF2.7
79AE:  CLRF   19
79B0:  BTFSC  FF2.7
79B2:  BSF    19.7
79B4:  BCF    FF2.7
79B6:  MOVLW  0D
79B8:  MOVLB  8
79BA:  MOVWF  x58
79BC:  MOVLB  0
79BE:  CALL   0694
79C2:  BTFSC  19.7
79C4:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
79C6:  MOVLW  01
79C8:  MOVLB  7
79CA:  MOVWF  xF7
79CC:  MOVLW  03
79CE:  MOVWF  xF8
79D0:  MOVLW  07
79D2:  MOVWF  xFA
79D4:  MOVLW  C3
79D6:  MOVWF  xF9
79D8:  MOVLB  0
79DA:  CALL   5B6C
....................           debugmode = (unsigned int8)strtoi(temp); 
79DE:  MOVLW  07
79E0:  MOVLB  7
79E2:  MOVWF  xF8
79E4:  MOVLW  C3
79E6:  MOVWF  xF7
79E8:  MOVLB  0
79EA:  CALL   6272
79EE:  MOVFF  01,6DA
79F2:  CLRF   19
79F4:  BTFSC  FF2.7
79F6:  BSF    19.7
79F8:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
79FA:  MOVLB  8
79FC:  CLRF   x43
79FE:  CLRF   x42
7A00:  CLRF   x41
7A02:  MOVLW  92
7A04:  MOVWF  x40
7A06:  MOVFF  6DA,844
7A0A:  MOVLB  0
7A0C:  CALL   3A9E
7A10:  BTFSC  19.7
7A12:  BSF    FF2.7
7A14:  CLRF   19
7A16:  BTFSC  FF2.7
7A18:  BSF    19.7
7A1A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7A1C:  MOVLW  0A
7A1E:  MOVLB  8
7A20:  MOVWF  x58
7A22:  MOVLB  0
7A24:  CALL   0694
7A28:  BTFSC  19.7
7A2A:  BSF    FF2.7
7A2C:  CLRF   19
7A2E:  BTFSC  FF2.7
7A30:  BSF    19.7
7A32:  BCF    FF2.7
7A34:  MOVLW  0D
7A36:  MOVLB  8
7A38:  MOVWF  x58
7A3A:  MOVLB  0
7A3C:  CALL   0694
7A40:  BTFSC  19.7
7A42:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
7A44:  GOTO   82FC (RETURN)
.................... //=============================================== 
....................  
....................  
.................... //========================= 
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
4302:  MOVLB  1
4304:  MOVF   x50,F
4306:  BZ    4342
....................    { 
....................       if(count_kp<500)count_kp++; 
4308:  MOVF   x53,W
430A:  SUBLW  01
430C:  BNC   431C
430E:  BNZ   4316
4310:  MOVF   x52,W
4312:  SUBLW  F3
4314:  BNC   431C
4316:  INCF   x52,F
4318:  BTFSC  FD8.2
431A:  INCF   x53,F
....................       if(count_kp==500) 
431C:  MOVF   x52,W
431E:  SUBLW  F4
4320:  BNZ   4342
4322:  DECFSZ x53,W
4324:  BRA    4342
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
4326:  MOVLW  0A
4328:  MOVWF  FF6
432A:  MOVLW  45
432C:  MOVWF  FF7
432E:  MOVLB  0
4330:  CALL   06DA
....................             keyprss_off; 
4334:  BCF    F92.7
4336:  BCF    F89.7
....................             kp_st=0;     
4338:  MOVLB  1
433A:  CLRF   x51
....................             count_kp++; 
433C:  INCF   x52,F
433E:  BTFSC  FD8.2
4340:  INCF   x53,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
4342:  DECFSZ x4C,W
4344:  BRA    4360
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
4346:  MOVLB  6
4348:  MOVF   xE6,F
434A:  BNZ   4354
434C:  MOVLB  0
434E:  CALL   207E
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
4352:  BRA    435E
4354:  MOVLB  0
4356:  CALL   32DA
435A:  MOVFF  01,82E
435E:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
4360:  DECFSZ x4D,W
4362:  BRA    437C
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
4364:  MOVLB  6
4366:  MOVF   xE6,F
4368:  BNZ   4372
436A:  MOVLB  0
436C:  CALL   207E
....................          else temp=kbd_getc_slv(); 
4370:  BRA    437C
4372:  MOVLB  0
4374:  CALL   32DA
4378:  MOVFF  01,82E
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
437C:  MOVLB  6
437E:  MOVF   xCB,F
4380:  BNZ   43A0
4382:  MOVF   xCA,F
4384:  BNZ   43A0
4386:  MOVF   xC9,F
4388:  BNZ   43A0
438A:  MOVF   xC8,W
438C:  SUBLW  04
438E:  BNC   43A0
4390:  MOVLW  01
4392:  ADDWF  xC8,F
4394:  BTFSC  FD8.0
4396:  INCF   xC9,F
4398:  BTFSC  FD8.2
439A:  INCF   xCA,F
439C:  BTFSC  FD8.2
439E:  INCF   xCB,F
....................   if(mcr_timeout==5) 
43A0:  MOVF   xC8,W
43A2:  SUBLW  05
43A4:  BNZ   43FA
43A6:  MOVF   xC9,F
43A8:  BNZ   43FA
43AA:  MOVF   xCA,F
43AC:  BNZ   43FA
43AE:  MOVF   xCB,F
43B0:  BNZ   43FA
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
43B2:  DECFSZ xDE,W
43B4:  BRA    43BC
43B6:  MOVLB  0
43B8:  BRA    3C2A
43BA:  MOVLB  6
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
43BC:  MOVLW  02
43BE:  MOVWF  FEA
43C0:  MOVLW  4A
43C2:  MOVWF  FE9
43C4:  CLRF   00
43C6:  MOVLW  03
43C8:  MOVWF  02
43CA:  MOVLW  52
43CC:  MOVWF  01
43CE:  MOVLB  0
43D0:  RCALL  4032
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
43D2:  MOVLW  05
43D4:  MOVWF  FEA
43D6:  MOVLW  9C
43D8:  MOVWF  FE9
43DA:  CLRF   00
43DC:  MOVLW  01
43DE:  MOVWF  02
43E0:  MOVLW  2C
43E2:  MOVWF  01
43E4:  RCALL  4032
....................       //debug_card(); 
....................       count_reading_error=0; 
43E6:  MOVLB  6
43E8:  CLRF   xDF
....................       mcr_timeout++;   
43EA:  MOVLW  01
43EC:  ADDWF  xC8,F
43EE:  BTFSC  FD8.0
43F0:  INCF   xC9,F
43F2:  BTFSC  FD8.2
43F4:  INCF   xCA,F
43F6:  BTFSC  FD8.2
43F8:  INCF   xCB,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
43FA:  MOVLB  8
43FC:  CLRF   x3B
43FE:  CLRF   x3A
4400:  CLRF   x39
4402:  MOVLW  94
4404:  MOVWF  x38
4406:  MOVLB  0
4408:  CALL   354E
440C:  MOVFF  01,161
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
4410:  MOVLW  02
4412:  MOVLB  8
4414:  MOVWF  x35
4416:  MOVLW  BC
4418:  MOVWF  x34
441A:  CLRF   x37
441C:  MOVFF  161,836
4420:  MOVLB  0
4422:  CALL   3672
4426:  MOVFF  02,03
442A:  MOVF   xFC,W
442C:  SUBWF  02,W
442E:  BNC   443E
4430:  BNZ   4438
4432:  MOVF   01,W
4434:  SUBWF  xFB,W
4436:  BC    443E
4438:  INCF   xFB,F
443A:  BTFSC  FD8.2
443C:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
443E:  MOVLW  02
4440:  MOVLB  8
4442:  MOVWF  x35
4444:  MOVLW  BC
4446:  MOVWF  x34
4448:  CLRF   x37
444A:  MOVFF  161,836
444E:  MOVLB  0
4450:  CALL   3672
4454:  MOVFF  02,03
4458:  MOVF   01,W
445A:  SUBWF  xFB,W
445C:  BNZ   4504
445E:  MOVF   03,W
4460:  SUBWF  xFC,W
4462:  BNZ   4504
....................   { 
....................       charac_timeout++; 
4464:  INCF   xFB,F
4466:  BTFSC  FD8.2
4468:  INCF   xFC,F
....................       buf=get_countcard(); 
446A:  CALL   361A
446E:  MOVFF  02,82D
4472:  MOVFF  01,82C
....................       if(buf<countcards) 
4476:  MOVLB  8
4478:  MOVF   x2D,W
447A:  SUBLW  03
447C:  BNC   44A4
447E:  BNZ   4486
4480:  MOVF   x2C,W
4482:  SUBLW  A1
4484:  BNC   44A4
....................       { 
....................          save_key_new(); 
4486:  MOVLB  0
4488:  BRA    404C
....................          buf=buf+1; 
448A:  MOVLW  01
448C:  MOVLB  8
448E:  ADDWF  x2C,F
4490:  MOVLW  00
4492:  ADDWFC x2D,F
....................          save_coutcard(buf); 
4494:  MOVFF  82D,830
4498:  MOVFF  82C,82F
449C:  MOVLB  0
449E:  RCALL  41CA
....................       } 
....................          else 
44A0:  BRA    44B4
44A2:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
44A4:  MOVLW  1A
44A6:  MOVWF  FF6
44A8:  MOVLW  45
44AA:  MOVWF  FF7
44AC:  MOVLB  0
44AE:  CALL   06DA
....................             return; 
44B2:  BRA    4504
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
44B4:  MOVLW  2A
44B6:  MOVWF  FF6
44B8:  MOVLW  45
44BA:  MOVWF  FF7
44BC:  CALL   06DA
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
44C0:  MOVLW  3A
44C2:  MOVWF  FF6
44C4:  MOVLW  45
44C6:  MOVWF  FF7
44C8:  MOVLW  14
44CA:  MOVLB  8
44CC:  MOVWF  x4C
44CE:  MOVLB  0
44D0:  CALL   1652
44D4:  MOVLW  10
44D6:  MOVWF  FE9
44D8:  MOVFF  82D,830
44DC:  MOVFF  82C,82F
44E0:  RCALL  420C
44E2:  MOVLW  51
44E4:  MOVWF  FF6
44E6:  MOVLW  45
44E8:  MOVWF  FF7
44EA:  MOVLW  03
44EC:  MOVLB  8
44EE:  MOVWF  x4C
44F0:  MOVLB  0
44F2:  CALL   1652
....................       data_avai=0; 
44F6:  MOVLB  6
44F8:  CLRF   xDD
....................       enable_getpin=0; 
44FA:  MOVLB  1
44FC:  CLRF   x4D
....................       //dis_getpin; 
....................       output_low(LED); 
44FE:  BCF    F92.6
4500:  BCF    F89.6
4502:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
4504:  BCF    FF2.2
4506:  GOTO   006C
.................... void main() 
.................... {  
*
7A48:  CLRF   FF8
7A4A:  BCF    FD0.7
7A4C:  BSF    07.7
7A4E:  CLRF   FEA
7A50:  CLRF   FE9
7A52:  BCF    F94.0
7A54:  BSF    F8B.0
7A56:  CLRF   23
7A58:  CLRF   22
7A5A:  CLRF   21
7A5C:  MOVLW  96
7A5E:  MOVWF  20
7A60:  CLRF   27
7A62:  MOVLW  01
7A64:  MOVWF  26
7A66:  MOVLW  C3
7A68:  MOVWF  25
7A6A:  MOVLW  0F
7A6C:  MOVWF  24
7A6E:  CLRF   xFA
7A70:  CLRF   xF9
7A72:  SETF   xFC
7A74:  SETF   xFB
7A76:  MOVLW  0E
7A78:  MOVWF  xFE
7A7A:  MOVLW  01
7A7C:  MOVWF  xFF
7A7E:  MOVLB  1
7A80:  MOVWF  x00
7A82:  CLRF   x01
7A84:  CLRF   x02
7A86:  CLRF   x03
7A88:  CLRF   x04
7A8A:  CLRF   x05
7A8C:  CLRF   x07
7A8E:  MOVLW  0A
7A90:  MOVWF  x06
7A92:  MOVLW  03
7A94:  MOVWF  x4A
7A96:  MOVLW  E8
7A98:  MOVWF  x49
7A9A:  CLRF   x4B
7A9C:  CLRF   x4C
7A9E:  CLRF   x4D
7AA0:  MOVLW  64
7AA2:  MOVWF  x4E
7AA4:  CLRF   x4F
7AA6:  CLRF   x50
7AA8:  CLRF   x51
7AAA:  CLRF   x53
7AAC:  CLRF   x52
7AAE:  CLRF   x54
7AB0:  CLRF   x61
7AB2:  CLRF   x66
7AB4:  CLRF   xCD
7AB6:  CLRF   xCE
7AB8:  CLRF   xCF
7ABA:  CLRF   xD0
7ABC:  CLRF   xD2
7ABE:  CLRF   xD1
7AC0:  MOVLB  6
7AC2:  CLRF   xCB
7AC4:  CLRF   xCA
7AC6:  CLRF   xC9
7AC8:  CLRF   xC8
7ACA:  CLRF   xCC
7ACC:  CLRF   xCE
7ACE:  CLRF   xCD
7AD0:  CLRF   xD0
7AD2:  CLRF   xCF
7AD4:  CLRF   xD2
7AD6:  CLRF   xD1
7AD8:  CLRF   xD4
7ADA:  CLRF   xD3
7ADC:  MOVLW  FD
7ADE:  MOVWF  xD6
7AE0:  MOVLW  E8
7AE2:  MOVWF  xD5
7AE4:  CLRF   xD8
7AE6:  CLRF   xD7
7AE8:  CLRF   xD9
7AEA:  CLRF   xDA
7AEC:  CLRF   xDB
7AEE:  CLRF   xDC
7AF0:  CLRF   xDD
7AF2:  CLRF   xDE
7AF4:  CLRF   xDF
7AF6:  CLRF   xE0
7AF8:  CLRF   xE1
7AFA:  CLRF   xE3
7AFC:  MOVLW  01
7AFE:  MOVWF  xE2
7B00:  CLRF   xE5
7B02:  CLRF   xE4
7B04:  CLRF   xE6
7B06:  CLRF   xEA
7B08:  CLRF   xE9
7B0A:  CLRF   xE8
7B0C:  CLRF   xE7
7B0E:  MOVLW  FF
7B10:  MOVLB  F
7B12:  MOVWF  x48
7B14:  BCF    FC2.6
7B16:  BCF    FC2.7
7B18:  MOVF   x49,W
7B1A:  ANDLW  E0
7B1C:  IORLW  1F
7B1E:  MOVWF  x49
7B20:  CLRF   FD2
7B22:  CLRF   FD1
7B24:  CLRF   1A
7B26:  CLRF   1B
7B28:  MOVLW  E8
7B2A:  MOVLB  1
7B2C:  MOVWF  x29
7B2E:  MOVLW  E9
7B30:  MOVWF  x2A
7B32:  MOVLW  EA
7B34:  MOVWF  x2B
7B36:  MOVLW  EB
7B38:  MOVWF  x2C
7B3A:  MOVLW  ED
7B3C:  MOVWF  x2D
7B3E:  MOVLW  EE
7B40:  MOVWF  x2E
7B42:  MOVLW  EF
7B44:  MOVWF  x2F
7B46:  MOVLW  F0
7B48:  MOVWF  x30
7B4A:  MOVLW  F2
7B4C:  MOVWF  x31
7B4E:  MOVLW  F3
7B50:  MOVWF  x32
7B52:  MOVLW  F4
7B54:  MOVWF  x33
7B56:  MOVLW  F5
7B58:  MOVWF  x34
7B5A:  MOVLW  F7
7B5C:  MOVWF  x35
7B5E:  MOVLW  F8
7B60:  MOVWF  x36
7B62:  MOVLW  F9
7B64:  MOVWF  x37
7B66:  MOVLW  FA
7B68:  MOVWF  x38
7B6A:  MOVLW  67
7B6C:  MOVWF  x39
7B6E:  MOVLW  43
7B70:  MOVWF  x3A
7B72:  MOVLW  C3
7B74:  MOVWF  x3B
7B76:  MOVLW  D1
7B78:  MOVWF  x3C
7B7A:  MOVLW  51
7B7C:  MOVWF  x3D
7B7E:  MOVLW  9A
7B80:  MOVWF  x3E
7B82:  MOVLW  B4
7B84:  MOVWF  x3F
7B86:  MOVLW  F2
7B88:  MOVWF  x40
7B8A:  MOVLW  CD
7B8C:  MOVWF  x41
7B8E:  MOVLW  9A
7B90:  MOVWF  x42
7B92:  MOVLW  78
7B94:  MOVWF  x43
7B96:  MOVLW  AB
7B98:  MOVWF  x44
7B9A:  MOVLW  09
7B9C:  MOVWF  x45
7B9E:  MOVLW  A5
7BA0:  MOVWF  x46
7BA2:  MOVLW  11
7BA4:  MOVWF  x47
7BA6:  MOVLW  BD
7BA8:  MOVWF  x48
7BAA:  CLRF   x62
7BAC:  BCF    x63.0
7BAE:  CLRF   x64
7BB0:  CLRF   x65
7BB2:  CLRF   x67
7BB4:  BCF    x63.1
7BB6:  CLRF   x68
7BB8:  MOVLB  6
7BBA:  CLRF   xFB
7BBC:  CLRF   xFC
7BBE:  CLRF   xFD
7BC0:  CLRF   xFE
7BC2:  CLRF   xFF
7BC4:  MOVLB  7
7BC6:  CLRF   x00
7BC8:  CLRF   x01
7BCA:  CLRF   x02
7BCC:  CLRF   x03
7BCE:  CLRF   x04
7BD0:  CLRF   x07
7BD2:  CLRF   x09
7BD4:  CLRF   x08
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................     RPINR1=5; 
7BD6:  MOVLW  05
7BD8:  MOVLB  E
7BDA:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
7BDC:  MOVLB  0
7BDE:  SETF   xFC
7BE0:  SETF   xFB
....................    key_timeout=0xffff; 
7BE2:  MOVLB  1
7BE4:  SETF   x4A
7BE6:  SETF   x49
....................    setup_oscillator(OSC_32MHZ); 
7BE8:  MOVLW  70
7BEA:  MOVWF  FD3
7BEC:  MOVLW  40
7BEE:  MOVWF  F9B
7BF0:  MOVF   FD3,W
....................    keyprss_off; 
7BF2:  BCF    F92.7
7BF4:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
7BF6:  BCF    FF2.6
7BF8:  BCF    FF2.7
7BFA:  BTFSC  FF2.7
7BFC:  BRA    7BF8
....................    init_ext_eeprom(); 
7BFE:  MOVLB  0
7C00:  GOTO   4628
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
7C04:  MOVLW  04
7C06:  MOVLB  7
7C08:  MOVWF  xC1
7C0A:  CLRF   19
7C0C:  BTFSC  FF2.7
7C0E:  BSF    19.7
7C10:  BCF    FF2.7
7C12:  MOVLW  FA
7C14:  MOVLB  8
7C16:  MOVWF  x35
7C18:  MOVLB  0
7C1A:  CALL   18BE
7C1E:  BTFSC  19.7
7C20:  BSF    FF2.7
7C22:  MOVLB  7
7C24:  DECFSZ xC1,F
7C26:  BRA    7C0A
....................    init_password(); 
7C28:  MOVLB  0
7C2A:  CALL   4796
7C2E:  CLRF   19
7C30:  BTFSC  FF2.7
7C32:  BSF    19.7
7C34:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
7C36:  MOVLB  8
7C38:  CLRF   x3B
7C3A:  CLRF   x3A
7C3C:  CLRF   x39
7C3E:  MOVLW  7F
7C40:  MOVWF  x38
7C42:  MOVLB  0
7C44:  CALL   354E
7C48:  BTFSC  19.7
7C4A:  BSF    FF2.7
7C4C:  MOVFF  01,150
....................    //===================================== 
....................    rtc_init(); 
7C50:  GOTO   48FE
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
7C54:  MOVLW  19
7C56:  MOVLB  7
7C58:  MOVWF  xC1
7C5A:  MOVLB  0
7C5C:  CALL   4A08
7C60:  MOVFF  03,23
7C64:  MOVFF  02,22
7C68:  MOVFF  01,21
7C6C:  MOVFF  00,20
....................    printf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
7C70:  CLRF   FEA
7C72:  MOVLW  01
7C74:  MOVWF  FE9
7C76:  CALL   4B5E
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
7C7A:  MOVLW  1E
7C7C:  MOVLB  7
7C7E:  MOVWF  xC1
7C80:  MOVLB  0
7C82:  CALL   4A08
7C86:  MOVFF  03,27
7C8A:  MOVFF  02,26
7C8E:  MOVFF  01,25
7C92:  MOVFF  00,24
....................    fprintf(COM2,"booting\n\r"); 
7C96:  MOVLW  56
7C98:  MOVWF  FF6
7C9A:  MOVLW  45
7C9C:  MOVWF  FF7
7C9E:  CLRF   19
7CA0:  BTFSC  FF2.7
7CA2:  BSF    19.7
7CA4:  BCF    FF2.7
7CA6:  CALL   06DA
7CAA:  BTFSC  19.7
7CAC:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
7CAE:  MOVLW  60
7CB0:  MOVWF  FF6
7CB2:  MOVLW  45
7CB4:  MOVWF  FF7
7CB6:  CLRF   19
7CB8:  BTFSC  FF2.7
7CBA:  BSF    19.7
7CBC:  BCF    FF2.7
7CBE:  MOVLW  12
7CC0:  MOVLB  8
7CC2:  MOVWF  x4C
7CC4:  MOVLB  0
7CC6:  CALL   1652
7CCA:  BTFSC  19.7
7CCC:  BSF    FF2.7
7CCE:  MOVLW  41
7CD0:  MOVWF  FE9
7CD2:  CLRF   19
7CD4:  BTFSC  FF2.7
7CD6:  BSF    19.7
7CD8:  BCF    FF2.7
7CDA:  MOVFF  27,84F
7CDE:  MOVFF  26,84E
7CE2:  MOVFF  25,84D
7CE6:  MOVFF  24,84C
7CEA:  CALL   23FE
7CEE:  BTFSC  19.7
7CF0:  BSF    FF2.7
7CF2:  CLRF   19
7CF4:  BTFSC  FF2.7
7CF6:  BSF    19.7
7CF8:  BCF    FF2.7
7CFA:  MOVLW  0A
7CFC:  MOVLB  8
7CFE:  MOVWF  x58
7D00:  MOVLB  0
7D02:  CALL   0694
7D06:  BTFSC  19.7
7D08:  BSF    FF2.7
7D0A:  CLRF   19
7D0C:  BTFSC  FF2.7
7D0E:  BSF    19.7
7D10:  BCF    FF2.7
7D12:  MOVLW  0D
7D14:  MOVLB  8
7D16:  MOVWF  x58
7D18:  MOVLB  0
7D1A:  CALL   0694
7D1E:  BTFSC  19.7
7D20:  BSF    FF2.7
7D22:  CLRF   19
7D24:  BTFSC  FF2.7
7D26:  BSF    19.7
7D28:  BCF    FF2.7
....................    countcard=get_countcard(); 
7D2A:  CALL   361A
7D2E:  BTFSC  19.7
7D30:  BSF    FF2.7
7D32:  MOVFF  02,FA
7D36:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
7D3A:  SETF   xFC
7D3C:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
7D3E:  MOVLW  C7
7D40:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
7D42:  MOVLW  37
7D44:  MOVWF  FCD
7D46:  CLRF   F9A
7D48:  CLRF   19
7D4A:  BTFSC  FF2.7
7D4C:  BSF    19.7
7D4E:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
7D50:  MOVLB  8
7D52:  CLRF   x3B
7D54:  CLRF   x3A
7D56:  CLRF   x39
7D58:  MOVLW  94
7D5A:  MOVWF  x38
7D5C:  MOVLB  0
7D5E:  CALL   354E
7D62:  BTFSC  19.7
7D64:  BSF    FF2.7
7D66:  MOVFF  01,161
....................    if(delaycharaction==0)delaycharaction=1; 
7D6A:  MOVLB  1
7D6C:  MOVF   x61,F
7D6E:  BNZ   7D74
7D70:  MOVLW  01
7D72:  MOVWF  x61
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
7D74:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
7D76:  BSF    FF0.3
7D78:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
7D7A:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
7D7C:  MOVLW  C0
7D7E:  IORWF  FF2,F
....................   
....................    mcr_timeout=10000; 
7D80:  MOVLB  6
7D82:  CLRF   xCB
7D84:  CLRF   xCA
7D86:  MOVLW  27
7D88:  MOVWF  xC9
7D8A:  MOVLW  10
7D8C:  MOVWF  xC8
7D8E:  CLRF   19
7D90:  BTFSC  FF2.7
7D92:  BSF    19.7
7D94:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
7D96:  MOVLB  8
7D98:  CLRF   x3B
7D9A:  CLRF   x3A
7D9C:  CLRF   x39
7D9E:  MOVLW  91
7DA0:  MOVWF  x38
7DA2:  MOVLB  0
7DA4:  CALL   354E
7DA8:  BTFSC  19.7
7DAA:  BSF    FF2.7
7DAC:  MOVFF  01,6E6
7DB0:  CLRF   19
7DB2:  BTFSC  FF2.7
7DB4:  BSF    19.7
7DB6:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
7DB8:  MOVLB  8
7DBA:  CLRF   x3B
7DBC:  CLRF   x3A
7DBE:  CLRF   x39
7DC0:  MOVLW  92
7DC2:  MOVWF  x38
7DC4:  MOVLB  0
7DC6:  CALL   354E
7DCA:  BTFSC  19.7
7DCC:  BSF    FF2.7
7DCE:  MOVFF  01,6DA
....................     key_timeout=1000; 
7DD2:  MOVLW  03
7DD4:  MOVLB  1
7DD6:  MOVWF  x4A
7DD8:  MOVLW  E8
7DDA:  MOVWF  x49
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
7DDC:  MOVLB  0
7DDE:  SETF   xFC
7DE0:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    booting_done=1; 
7DE2:  MOVLW  01
7DE4:  MOVLB  1
7DE6:  MOVWF  xD0
....................    booting=1; 
7DE8:  MOVWF  x05
....................    charac_timeout=0xffffffff; 
7DEA:  MOVLB  0
7DEC:  SETF   xFC
7DEE:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
7DF0:  MOVLB  7
7DF2:  CLRF   xFA
7DF4:  CLRF   xF9
7DF6:  CLRF   xF8
7DF8:  MOVLW  66
7DFA:  MOVWF  xF7
7DFC:  CLRF   xFE
7DFE:  CLRF   xFD
7E00:  CLRF   xFC
7E02:  MOVLW  10
7E04:  MOVWF  xFB
7E06:  MOVLW  06
7E08:  MOVLB  8
7E0A:  MOVWF  x00
7E0C:  MOVLW  EB
7E0E:  MOVLB  7
7E10:  MOVWF  xFF
7E12:  MOVLB  0
7E14:  CALL   4632
....................    set_tris_a(0xff);  
7E18:  MOVLW  FF
7E1A:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
7E1C:  MOVLW  E0
7E1E:  MOVLB  F
7E20:  MOVWF  x48
7E22:  BCF    FC2.6
7E24:  BCF    FC2.7
7E26:  MOVF   x49,W
7E28:  ANDLW  E0
7E2A:  IORLW  1F
7E2C:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
7E2E:  MOVF   FC1,W
7E30:  ANDLW  C0
7E32:  IORLW  03
7E34:  MOVWF  FC1
7E36:  BCF    FC1.7
7E38:  BSF    FC2.0
7E3A:  BSF    FC1.6
7E3C:  BSF    FC2.1
7E3E:  BTFSC  FC2.1
7E40:  BRA    7E3E
7E42:  BCF    FC1.6
7E44:  CLRF   19
7E46:  BTFSC  FF2.7
7E48:  BSF    19.7
7E4A:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
7E4C:  MOVLB  8
7E4E:  CLRF   x3B
7E50:  CLRF   x3A
7E52:  CLRF   x39
7E54:  MOVLW  7F
7E56:  MOVWF  x38
7E58:  MOVLB  0
7E5A:  CALL   354E
7E5E:  BTFSC  19.7
7E60:  BSF    FF2.7
7E62:  MOVFF  01,150
7E66:  CLRF   19
7E68:  BTFSC  FF2.7
7E6A:  BSF    19.7
7E6C:  BCF    FF2.7
....................    type_KB=read_ext_eeprom(kindofKB); 
7E6E:  MOVLB  8
7E70:  CLRF   x3B
7E72:  CLRF   x3A
7E74:  CLRF   x39
7E76:  MOVLW  7E
7E78:  MOVWF  x38
7E7A:  MOVLB  0
7E7C:  CALL   354E
7E80:  BTFSC  19.7
7E82:  BSF    FF2.7
7E84:  MOVFF  01,154
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
7E88:  MOVLB  1
7E8A:  MOVF   x54,F
7E8C:  BZ    7EAC
7E8E:  MOVLW  78
7E90:  MOVWF  FF6
7E92:  MOVLW  45
7E94:  MOVWF  FF7
7E96:  CLRF   19
7E98:  BTFSC  FF2.7
7E9A:  BSF    19.7
7E9C:  BCF    FF2.7
7E9E:  MOVLB  0
7EA0:  CALL   06DA
7EA4:  BTFSC  19.7
7EA6:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
7EA8:  BRA    7EC6
7EAA:  MOVLB  1
7EAC:  MOVLW  8C
7EAE:  MOVWF  FF6
7EB0:  MOVLW  45
7EB2:  MOVWF  FF7
7EB4:  CLRF   19
7EB6:  BTFSC  FF2.7
7EB8:  BSF    19.7
7EBA:  BCF    FF2.7
7EBC:  MOVLB  0
7EBE:  CALL   06DA
7EC2:  BTFSC  19.7
7EC4:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
7EC6:  MOVLB  6
7EC8:  MOVF   xE6,F
7ECA:  BNZ   7EEA
7ECC:  MOVLW  A0
7ECE:  MOVWF  FF6
7ED0:  MOVLW  45
7ED2:  MOVWF  FF7
7ED4:  CLRF   19
7ED6:  BTFSC  FF2.7
7ED8:  BSF    19.7
7EDA:  BCF    FF2.7
7EDC:  MOVLB  0
7EDE:  CALL   06DA
7EE2:  BTFSC  19.7
7EE4:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
7EE6:  BRA    7F04
7EE8:  MOVLB  6
7EEA:  MOVLW  BA
7EEC:  MOVWF  FF6
7EEE:  MOVLW  45
7EF0:  MOVWF  FF7
7EF2:  CLRF   19
7EF4:  BTFSC  FF2.7
7EF6:  BSF    19.7
7EF8:  BCF    FF2.7
7EFA:  MOVLB  0
7EFC:  CALL   06DA
7F00:  BTFSC  19.7
7F02:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
7F04:  MOVLW  01
7F06:  MOVWF  FEA
7F08:  MOVLW  55
7F0A:  MOVWF  FE9
7F0C:  CLRF   00
7F0E:  CLRF   02
7F10:  MOVLW  0C
7F12:  MOVWF  01
7F14:  CALL   4032
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
7F18:  MOVLB  7
7F1A:  CLRF   x05
7F1C:  MOVF   x05,W
7F1E:  SUBLW  13
7F20:  BNC   7F36
....................    { 
....................       password[i] = 0; 
7F22:  CLRF   03
7F24:  MOVF   x05,W
7F26:  ADDLW  55
7F28:  MOVWF  FE9
7F2A:  MOVLW  00
7F2C:  ADDWFC 03,W
7F2E:  MOVWF  FEA
7F30:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 1 
7F32:  INCF   x05,F
7F34:  BRA    7F1C
....................    disable_interrupts(GLOBAL); 
7F36:  BCF    FF2.6
7F38:  BCF    FF2.7
7F3A:  BTFSC  FF2.7
7F3C:  BRA    7F38
7F3E:  CLRF   19
7F40:  BTFSC  FF2.7
7F42:  BSF    19.7
7F44:  BCF    FF2.7
....................    save_coutcard(0); 
7F46:  MOVLB  8
7F48:  CLRF   x30
7F4A:  CLRF   x2F
7F4C:  MOVLB  0
7F4E:  CALL   41CA
7F52:  BTFSC  19.7
7F54:  BSF    FF2.7
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
7F56:  MOVLW  01
7F58:  MOVWF  FEA
7F5A:  MOVLW  55
7F5C:  MOVWF  FE9
7F5E:  MOVLW  00
7F60:  CALL   04B8
7F64:  TBLRD*-
7F66:  TBLRD*+
7F68:  MOVF   FF5,W
7F6A:  MOVWF  FEE
7F6C:  IORLW  00
7F6E:  BNZ   7F66
....................    memset(crypto_key,0,sizeof(crypto_key));  
7F70:  MOVLW  01
7F72:  MOVWF  FEA
7F74:  MOVLW  08
7F76:  MOVWF  FE9
7F78:  CLRF   00
7F7A:  CLRF   02
7F7C:  MOVLW  21
7F7E:  MOVWF  01
7F80:  CALL   4032
....................    strcpy(crypto_key,"quang102"); 
7F84:  MOVLW  01
7F86:  MOVWF  FEA
7F88:  MOVLW  08
7F8A:  MOVWF  FE9
7F8C:  MOVLW  00
7F8E:  CALL   04D0
7F92:  TBLRD*-
7F94:  TBLRD*+
7F96:  MOVF   FF5,W
7F98:  MOVWF  FEE
7F9A:  IORLW  00
7F9C:  BNZ   7F94
....................     
....................    save_key_encrypt(); 
7F9E:  GOTO   58C8
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
7FA2:  MOVLB  7
7FA4:  CLRF   xFA
7FA6:  MOVLW  01
7FA8:  MOVWF  xF9
7FAA:  MOVLW  C3
7FAC:  MOVWF  xF8
7FAE:  MOVLW  0F
7FB0:  MOVWF  xF7
7FB2:  CLRF   xFE
7FB4:  CLRF   xFD
7FB6:  CLRF   xFC
7FB8:  MOVLW  10
7FBA:  MOVWF  xFB
7FBC:  MOVLW  07
7FBE:  MOVLB  8
7FC0:  MOVWF  x00
7FC2:  MOVLW  8F
7FC4:  MOVLB  7
7FC6:  MOVWF  xFF
7FC8:  MOVLB  0
7FCA:  CALL   4632
....................    memset(crypto_key,0,sizeof(crypto_key));  
7FCE:  MOVLW  01
7FD0:  MOVWF  FEA
7FD2:  MOVLW  08
7FD4:  MOVWF  FE9
7FD6:  CLRF   00
7FD8:  CLRF   02
7FDA:  MOVLW  21
7FDC:  MOVWF  01
7FDE:  CALL   4032
....................    strcpy(crypto_key,"quang102"); 
7FE2:  MOVLW  01
7FE4:  MOVWF  FEA
7FE6:  MOVLW  08
7FE8:  MOVWF  FE9
7FEA:  MOVLW  00
7FEC:  CALL   04D0
7FF0:  TBLRD*-
7FF2:  TBLRD*+
7FF4:  MOVF   FF5,W
7FF6:  MOVWF  FEE
7FF8:  IORLW  00
7FFA:  BNZ   7FF2
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
7FFC:  MOVLW  0C
7FFE:  MOVLB  7
8000:  MOVWF  xC1
8002:  CLRF   19
8004:  BTFSC  FF2.7
8006:  BSF    19.7
8008:  BCF    FF2.7
800A:  MOVLW  FA
800C:  MOVLB  8
800E:  MOVWF  x35
8010:  MOVLB  0
8012:  CALL   18BE
8016:  BTFSC  19.7
8018:  BSF    FF2.7
801A:  MOVLB  7
801C:  DECFSZ xC1,F
801E:  BRA    8002
8020:  CLRF   19
8022:  BTFSC  FF2.7
8024:  BSF    19.7
8026:  BCF    FF2.7
....................     
....................    fprintf(COM2,"\n\r"); 
8028:  MOVLW  0A
802A:  MOVLB  8
802C:  MOVWF  x58
802E:  MOVLB  0
8030:  CALL   0694
8034:  BTFSC  19.7
8036:  BSF    FF2.7
8038:  CLRF   19
803A:  BTFSC  FF2.7
803C:  BSF    19.7
803E:  BCF    FF2.7
8040:  MOVLW  0D
8042:  MOVLB  8
8044:  MOVWF  x58
8046:  MOVLB  0
8048:  CALL   0694
804C:  BTFSC  19.7
804E:  BSF    FF2.7
....................    fprintf(COM2,"test_data in:\n\r"); 
8050:  MOVLW  D2
8052:  MOVWF  FF6
8054:  MOVLW  45
8056:  MOVWF  FF7
8058:  CLRF   19
805A:  BTFSC  FF2.7
805C:  BSF    19.7
805E:  BCF    FF2.7
8060:  CALL   06DA
8064:  BTFSC  19.7
8066:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
8068:  MOVLB  7
806A:  CLRF   x05
806C:  MOVF   x05,W
806E:  SUBLW  0F
8070:  BNC   8098
8072:  CLRF   03
8074:  MOVF   x05,W
8076:  ADDLW  8F
8078:  MOVWF  FE9
807A:  MOVLW  07
807C:  ADDWFC 03,W
807E:  MOVWF  FEA
8080:  MOVFF  FEF,7C1
8084:  MOVFF  7C1,7D6
8088:  MOVLW  57
808A:  MOVWF  xD7
808C:  MOVLB  0
808E:  CALL   5866
8092:  MOVLB  7
8094:  INCF   x05,F
8096:  BRA    806C
8098:  CLRF   19
809A:  BTFSC  FF2.7
809C:  BSF    19.7
809E:  BCF    FF2.7
....................    fprintf(COM2,"\n\r"); 
80A0:  MOVLW  0A
80A2:  MOVLB  8
80A4:  MOVWF  x58
80A6:  MOVLB  0
80A8:  CALL   0694
80AC:  BTFSC  19.7
80AE:  BSF    FF2.7
80B0:  CLRF   19
80B2:  BTFSC  FF2.7
80B4:  BSF    19.7
80B6:  BCF    FF2.7
80B8:  MOVLW  0D
80BA:  MOVLB  8
80BC:  MOVWF  x58
80BE:  MOVLB  0
80C0:  CALL   0694
80C4:  BTFSC  19.7
80C6:  BSF    FF2.7
....................    fprintf(COM2,"test_key in:\n\r"); 
80C8:  MOVLW  E2
80CA:  MOVWF  FF6
80CC:  MOVLW  45
80CE:  MOVWF  FF7
80D0:  CLRF   19
80D2:  BTFSC  FF2.7
80D4:  BSF    19.7
80D6:  BCF    FF2.7
80D8:  CALL   06DA
80DC:  BTFSC  19.7
80DE:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
80E0:  MOVLB  7
80E2:  CLRF   x05
80E4:  MOVF   x05,W
80E6:  SUBLW  0F
80E8:  BNC   8110
80EA:  CLRF   03
80EC:  MOVF   x05,W
80EE:  ADDLW  08
80F0:  MOVWF  FE9
80F2:  MOVLW  01
80F4:  ADDWFC 03,W
80F6:  MOVWF  FEA
80F8:  MOVFF  FEF,7C1
80FC:  MOVFF  7C1,7D6
8100:  MOVLW  57
8102:  MOVWF  xD7
8104:  MOVLB  0
8106:  CALL   5866
810A:  MOVLB  7
810C:  INCF   x05,F
810E:  BRA    80E4
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],1); 
8110:  MOVLW  07
8112:  MOVWF  xD6
8114:  MOVLW  8F
8116:  MOVWF  xD5
8118:  MOVLW  01
811A:  MOVWF  xD8
811C:  MOVLW  08
811E:  MOVWF  xD7
8120:  MOVLW  01
8122:  MOVWF  xD9
8124:  MOVLB  0
8126:  CALL   4BF2
812A:  CLRF   19
812C:  BTFSC  FF2.7
812E:  BSF    19.7
8130:  BCF    FF2.7
....................    //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................    fprintf(COM2,"\n\r"); 
8132:  MOVLW  0A
8134:  MOVLB  8
8136:  MOVWF  x58
8138:  MOVLB  0
813A:  CALL   0694
813E:  BTFSC  19.7
8140:  BSF    FF2.7
8142:  CLRF   19
8144:  BTFSC  FF2.7
8146:  BSF    19.7
8148:  BCF    FF2.7
814A:  MOVLW  0D
814C:  MOVLB  8
814E:  MOVWF  x58
8150:  MOVLB  0
8152:  CALL   0694
8156:  BTFSC  19.7
8158:  BSF    FF2.7
....................    fprintf(COM2,"\n\rdecrypted:\n\r"); 
815A:  MOVLW  F2
815C:  MOVWF  FF6
815E:  MOVLW  45
8160:  MOVWF  FF7
8162:  CLRF   19
8164:  BTFSC  FF2.7
8166:  BSF    19.7
8168:  BCF    FF2.7
816A:  CALL   06DA
816E:  BTFSC  19.7
8170:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
8172:  MOVLB  7
8174:  CLRF   x05
8176:  MOVF   x05,W
8178:  SUBLW  0F
817A:  BNC   81A2
817C:  CLRF   03
817E:  MOVF   x05,W
8180:  ADDLW  8F
8182:  MOVWF  FE9
8184:  MOVLW  07
8186:  ADDWFC 03,W
8188:  MOVWF  FEA
818A:  MOVFF  FEF,7C1
818E:  MOVFF  7C1,7D6
8192:  MOVLW  57
8194:  MOVWF  xD7
8196:  MOVLB  0
8198:  CALL   5866
819C:  MOVLB  7
819E:  INCF   x05,F
81A0:  BRA    8176
81A2:  CLRF   19
81A4:  BTFSC  FF2.7
81A6:  BSF    19.7
81A8:  BCF    FF2.7
....................    fprintf(COM2,"\n\r"); 
81AA:  MOVLW  0A
81AC:  MOVLB  8
81AE:  MOVWF  x58
81B0:  MOVLB  0
81B2:  CALL   0694
81B6:  BTFSC  19.7
81B8:  BSF    FF2.7
81BA:  CLRF   19
81BC:  BTFSC  FF2.7
81BE:  BSF    19.7
81C0:  BCF    FF2.7
81C2:  MOVLW  0D
81C4:  MOVLB  8
81C6:  MOVWF  x58
81C8:  MOVLB  0
81CA:  CALL   0694
81CE:  BTFSC  19.7
81D0:  BSF    FF2.7
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
81D2:  MOVLW  02
81D4:  MOVWF  FF6
81D6:  MOVLW  46
81D8:  MOVWF  FF7
81DA:  CLRF   19
81DC:  BTFSC  FF2.7
81DE:  BSF    19.7
81E0:  BCF    FF2.7
81E2:  CALL   06DA
81E6:  BTFSC  19.7
81E8:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
81EA:  MOVLB  7
81EC:  CLRF   x05
81EE:  MOVF   x05,W
81F0:  SUBLW  0F
81F2:  BNC   821A
81F4:  CLRF   03
81F6:  MOVF   x05,W
81F8:  ADDLW  08
81FA:  MOVWF  FE9
81FC:  MOVLW  01
81FE:  ADDWFC 03,W
8200:  MOVWF  FEA
8202:  MOVFF  FEF,7C1
8206:  MOVFF  7C1,7D6
820A:  MOVLW  57
820C:  MOVWF  xD7
820E:  MOVLB  0
8210:  CALL   5866
8214:  MOVLB  7
8216:  INCF   x05,F
8218:  BRA    81EE
....................    while(1); 
821A:  BRA    821A
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
821C:  CLRF   xFA
821E:  CLRF   xF9
8220:  CLRF   xF8
8222:  CLRF   xF7
8224:  CLRF   xFE
8226:  CLRF   xFD
8228:  CLRF   xFC
822A:  MOVLW  14
822C:  MOVWF  xFB
822E:  MOVLB  8
8230:  CLRF   x00
8232:  MOVLW  55
8234:  MOVLB  7
8236:  MOVWF  xFF
8238:  MOVLB  0
823A:  CALL   4632
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
823E:  MOVLB  6
8240:  MOVF   xE0,F
8242:  BNZ   82F2
....................       { 
....................          fprintf(COM2,"password:"); 
8244:  MOVLW  12
8246:  MOVWF  FF6
8248:  MOVLW  46
824A:  MOVWF  FF7
824C:  CLRF   19
824E:  BTFSC  FF2.7
8250:  BSF    19.7
8252:  BCF    FF2.7
8254:  MOVLB  0
8256:  CALL   06DA
825A:  BTFSC  19.7
825C:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
825E:  MOVLW  02
8260:  MOVLB  7
8262:  MOVWF  xF7
8264:  MOVLW  14
8266:  MOVWF  xF8
8268:  MOVLW  01
826A:  MOVWF  xFA
826C:  MOVLW  69
826E:  MOVWF  xF9
8270:  MOVLB  0
8272:  CALL   5B6C
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
8276:  MOVLB  7
8278:  CLRF   xFA
827A:  CLRF   xF9
827C:  CLRF   xF8
827E:  CLRF   xF7
8280:  CLRF   xFE
8282:  CLRF   xFD
8284:  CLRF   xFC
8286:  MOVLW  14
8288:  MOVWF  xFB
828A:  MOVLB  8
828C:  CLRF   x00
828E:  MOVLW  55
8290:  MOVLB  7
8292:  MOVWF  xFF
8294:  MOVLB  0
8296:  CALL   4632
....................          if(!stringcomp(buffer_uart,password)) 
829A:  MOVLW  01
829C:  MOVLB  7
829E:  MOVWF  xF8
82A0:  MOVLW  69
82A2:  MOVWF  xF7
82A4:  CLRF   xFA
82A6:  MOVLW  55
82A8:  MOVWF  xF9
82AA:  MOVLB  0
82AC:  CALL   5CA4
82B0:  MOVF   01,F
82B2:  BNZ   82D6
....................          { 
....................             mode=LOGON; 
82B4:  MOVLW  01
82B6:  MOVLB  6
82B8:  MOVWF  xE0
....................             fprintf(COM2," OK\n\r"); 
82BA:  MOVLW  1C
82BC:  MOVWF  FF6
82BE:  MOVLW  46
82C0:  MOVWF  FF7
82C2:  CLRF   19
82C4:  BTFSC  FF2.7
82C6:  BSF    19.7
82C8:  BCF    FF2.7
82CA:  MOVLB  0
82CC:  CALL   06DA
82D0:  BTFSC  19.7
82D2:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
82D4:  BRA    82EE
82D6:  MOVLW  22
82D8:  MOVWF  FF6
82DA:  MOVLW  46
82DC:  MOVWF  FF7
82DE:  CLRF   19
82E0:  BTFSC  FF2.7
82E2:  BSF    19.7
82E4:  BCF    FF2.7
82E6:  CALL   06DA
82EA:  BTFSC  19.7
82EC:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
82EE:  BRA    82FC
82F0:  MOVLB  6
82F2:  DECFSZ xE0,W
82F4:  BRA    82FE
82F6:  MOVLB  0
82F8:  GOTO   6456
82FC:  MOVLB  6
....................    } 
82FE:  BRA    8240
.................... } 
8300:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

CCS PCH C Compiler, Version 4.140, 33034               21-Jul-18 12:10

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   33358 bytes (51%)
                           Largest free fragment is 32166
               RAM used:   1987 (53%) at main() level
                           2154 (57%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   79DA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   430A
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1BF8
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0676:  MOVLW  02
0678:  MOVLB  8
067A:  SUBWF  x2D,F
067C:  BNC   0696
067E:  MOVLW  08
0680:  MOVWF  FEA
0682:  MOVLW  2D
0684:  MOVWF  FE9
0686:  MOVF   FEF,W
0688:  BZ    0696
068A:  BRA    0692
068C:  BRA    068E
068E:  BRA    0690
0690:  NOP   
0692:  DECFSZ FEF,F
0694:  BRA    068C
0696:  MOVLB  0
0698:  GOTO   1C08 (RETURN)
*
18C6:  MOVLW  08
18C8:  MOVWF  FEA
18CA:  MOVLW  35
18CC:  MOVWF  FE9
18CE:  MOVF   FEF,W
18D0:  BZ    18EC
18D2:  MOVLW  0A
18D4:  MOVWF  01
18D6:  CLRF   00
18D8:  DECFSZ 00,F
18DA:  BRA    18D8
18DC:  DECFSZ 01,F
18DE:  BRA    18D6
18E0:  MOVLW  5F
18E2:  MOVWF  00
18E4:  DECFSZ 00,F
18E6:  BRA    18E4
18E8:  DECFSZ FEF,F
18EA:  BRA    18D2
18EC:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
069C:  BCF    F94.0
069E:  BCF    F8B.0
06A0:  MOVLW  08
06A2:  MOVWF  01
06A4:  BRA    06A6
06A6:  NOP   
06A8:  BSF    01.7
06AA:  BRA    06CC
06AC:  BCF    01.7
06AE:  MOVLB  8
06B0:  RRCF   x58,F
06B2:  MOVLB  0
06B4:  BTFSC  FD8.0
06B6:  BSF    F8B.0
06B8:  BTFSS  FD8.0
06BA:  BCF    F8B.0
06BC:  BSF    01.6
06BE:  BRA    06CC
06C0:  BCF    01.6
06C2:  DECFSZ 01,F
06C4:  BRA    06AE
06C6:  BRA    06C8
06C8:  NOP   
06CA:  BSF    F8B.0
06CC:  MOVLW  10
06CE:  MOVWF  FE9
06D0:  DECFSZ FE9,F
06D2:  BRA    06D0
06D4:  BRA    06D6
06D6:  NOP   
06D8:  BTFSC  01.7
06DA:  BRA    06AC
06DC:  BTFSC  01.6
06DE:  BRA    06C0
06E0:  RETURN 0
*
5AB0:  BSF    F94.1
5AB2:  BTFSC  F82.1
5AB4:  BRA    5AB2
5AB6:  MOVLW  08
5AB8:  MOVWF  00
5ABA:  MOVLB  8
5ABC:  CLRF   x00
5ABE:  BSF    00.7
5AC0:  BRA    5AE2
5AC2:  BCF    00.7
5AC4:  BRA    5AE2
5AC6:  MOVFF  800,02
5ACA:  BCF    FD8.0
5ACC:  BTFSC  F82.1
5ACE:  BSF    FD8.0
5AD0:  RRCF   02,F
5AD2:  BSF    00.6
5AD4:  BRA    5AE2
5AD6:  BCF    00.6
5AD8:  DECFSZ 00,F
5ADA:  BRA    5ACA
5ADC:  MOVFF  02,01
5AE0:  BRA    5AFA
5AE2:  MOVLW  10
5AE4:  BTFSC  00.7
5AE6:  MOVLW  04
5AE8:  MOVWF  01
5AEA:  DECFSZ 01,F
5AEC:  BRA    5AEA
5AEE:  BRA    5AF0
5AF0:  BTFSC  00.7
5AF2:  BRA    5AC2
5AF4:  BTFSC  00.6
5AF6:  BRA    5AD6
5AF8:  BRA    5ACA
5AFA:  MOVLB  0
5AFC:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3476:  MOVLW  08
3478:  MOVWF  01
347A:  MOVLW  0A
347C:  MOVWF  00
347E:  DECFSZ 00,F
3480:  BRA    347E
3482:  BCF    F8B.3
3484:  BCF    F94.3
3486:  MOVLW  0B
3488:  MOVWF  00
348A:  DECFSZ 00,F
348C:  BRA    348A
348E:  MOVLB  8
3490:  RLCF   x4C,F
3492:  BCF    F8B.4
3494:  BTFSC  FD8.0
3496:  BSF    F94.4
3498:  BTFSS  FD8.0
349A:  BCF    F94.4
349C:  BSF    F94.3
349E:  BTFSS  F82.3
34A0:  BRA    349E
34A2:  DECFSZ 01,F
34A4:  BRA    34A8
34A6:  BRA    34AC
34A8:  MOVLB  0
34AA:  BRA    347A
34AC:  MOVLW  0A
34AE:  MOVWF  00
34B0:  DECFSZ 00,F
34B2:  BRA    34B0
34B4:  BCF    F8B.3
34B6:  BCF    F94.3
34B8:  NOP   
34BA:  BSF    F94.4
34BC:  MOVLW  0B
34BE:  MOVWF  00
34C0:  DECFSZ 00,F
34C2:  BRA    34C0
34C4:  MOVLW  0B
34C6:  MOVWF  00
34C8:  DECFSZ 00,F
34CA:  BRA    34C8
34CC:  BSF    F94.3
34CE:  BTFSS  F82.3
34D0:  BRA    34CE
34D2:  CLRF   01
34D4:  MOVLW  0B
34D6:  MOVWF  00
34D8:  DECFSZ 00,F
34DA:  BRA    34D8
34DC:  BTFSC  F82.4
34DE:  BSF    01.0
34E0:  BCF    F8B.3
34E2:  BCF    F94.3
34E4:  BCF    F8B.4
34E6:  BCF    F94.4
34E8:  MOVLB  0
34EA:  RETURN 0
34EC:  MOVLW  08
34EE:  MOVLB  8
34F0:  MOVWF  x3F
34F2:  MOVFF  00,840
34F6:  BSF    F94.4
34F8:  MOVLW  0B
34FA:  MOVWF  00
34FC:  DECFSZ 00,F
34FE:  BRA    34FC
3500:  BSF    F94.3
3502:  BTFSS  F82.3
3504:  BRA    3502
3506:  BTFSC  F82.4
3508:  BSF    FD8.0
350A:  BTFSS  F82.4
350C:  BCF    FD8.0
350E:  RLCF   01,F
3510:  MOVLW  0A
3512:  MOVWF  00
3514:  DECFSZ 00,F
3516:  BRA    3514
3518:  BCF    F94.3
351A:  BCF    F8B.3
351C:  DECFSZ x3F,F
351E:  BRA    34F6
3520:  BSF    F94.4
3522:  MOVLW  0B
3524:  MOVWF  00
3526:  DECFSZ 00,F
3528:  BRA    3526
352A:  BCF    F8B.4
352C:  MOVF   x40,W
352E:  BTFSS  FD8.2
3530:  BCF    F94.4
3532:  NOP   
3534:  BSF    F94.3
3536:  BTFSS  F82.3
3538:  BRA    3536
353A:  MOVLW  0A
353C:  MOVWF  00
353E:  DECFSZ 00,F
3540:  BRA    353E
3542:  BCF    F8B.3
3544:  BCF    F94.3
3546:  MOVLW  0B
3548:  MOVWF  00
354A:  DECFSZ 00,F
354C:  BRA    354A
354E:  BCF    F8B.4
3550:  BCF    F94.4
3552:  MOVLB  0
3554:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE_key    131071 
.................... #define EEPROM_SIZE        115470 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
4630:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
4632:  BSF    F94.4
....................    port_b_pullups(0xff); 
4634:  BCF    FF1.7
.................... } 
4636:  GOTO   7B96 (RETURN)
.................... /* 
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
....................    if(address<0xffff)i2c_write(0xa0); 
....................       else if(address>=0xffff) i2c_write(0xa2); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
....................    i2c_start(); 
....................    status=i2c_write(0xa0); 
....................    while(status==1) 
....................    { 
....................       i2c_start(); 
....................       status=i2c_write(0xa0); 
....................    } 
....................    i2c_stop(); 
.................... } 
.................... */ 
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3AA6:  MOVLB  8
3AA8:  MOVF   x43,F
3AAA:  BNZ   3AB2
3AAC:  MOVF   x42,W
3AAE:  SUBLW  00
3AB0:  BC    3AB8
3AB2:  MOVLW  A8
3AB4:  MOVWF  x46
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3AB6:  BRA    3ABC
3AB8:  MOVLW  A0
3ABA:  MOVWF  x46
....................  
....................    i2c_start(); 
3ABC:  BSF    F94.4
3ABE:  MOVLW  0A
3AC0:  MOVWF  00
3AC2:  DECFSZ 00,F
3AC4:  BRA    3AC2
3AC6:  BSF    F94.3
3AC8:  MOVLW  0B
3ACA:  MOVWF  00
3ACC:  DECFSZ 00,F
3ACE:  BRA    3ACC
3AD0:  BCF    F8B.4
3AD2:  BCF    F94.4
3AD4:  MOVLW  0A
3AD6:  MOVWF  00
3AD8:  DECFSZ 00,F
3ADA:  BRA    3AD8
3ADC:  BCF    F8B.3
3ADE:  BCF    F94.3
....................    i2c_write(command); 
3AE0:  MOVFF  846,84C
3AE4:  MOVLB  0
3AE6:  RCALL  3476
....................    i2c_write(address>>8); 
3AE8:  MOVFF  841,848
3AEC:  MOVFF  842,849
3AF0:  MOVFF  843,84A
3AF4:  MOVLB  8
3AF6:  CLRF   x4B
3AF8:  MOVFF  841,84C
3AFC:  MOVLB  0
3AFE:  RCALL  3476
....................    i2c_write(address); 
3B00:  MOVFF  840,84C
3B04:  RCALL  3476
....................    i2c_write(data); 
3B06:  MOVFF  844,84C
3B0A:  RCALL  3476
....................  
....................    i2c_stop(); 
3B0C:  BCF    F94.4
3B0E:  NOP   
3B10:  BSF    F94.3
3B12:  BTFSS  F82.3
3B14:  BRA    3B12
3B16:  MOVLW  0A
3B18:  MOVWF  00
3B1A:  DECFSZ 00,F
3B1C:  BRA    3B1A
3B1E:  BRA    3B20
3B20:  NOP   
3B22:  BSF    F94.4
3B24:  MOVLW  0A
3B26:  MOVWF  00
3B28:  DECFSZ 00,F
3B2A:  BRA    3B28
....................    i2c_start(); 
3B2C:  BSF    F94.4
3B2E:  MOVLW  0A
3B30:  MOVWF  00
3B32:  DECFSZ 00,F
3B34:  BRA    3B32
3B36:  BSF    F94.3
3B38:  MOVLW  0B
3B3A:  MOVWF  00
3B3C:  DECFSZ 00,F
3B3E:  BRA    3B3C
3B40:  BCF    F8B.4
3B42:  BCF    F94.4
3B44:  MOVLW  0A
3B46:  MOVWF  00
3B48:  DECFSZ 00,F
3B4A:  BRA    3B48
3B4C:  BCF    F8B.3
3B4E:  BCF    F94.3
....................    status=i2c_write(command); 
3B50:  MOVFF  846,84C
3B54:  RCALL  3476
3B56:  MOVF   01,W
3B58:  MOVLB  8
3B5A:  BCF    x45.0
3B5C:  BTFSC  01.0
3B5E:  BSF    x45.0
....................    while(status==1) 
....................    { 
3B60:  BTFSS  x45.0
3B62:  BRA    3BA0
....................       i2c_start(); 
3B64:  BSF    F94.4
3B66:  MOVLW  0A
3B68:  MOVWF  00
3B6A:  DECFSZ 00,F
3B6C:  BRA    3B6A
3B6E:  BSF    F94.3
3B70:  MOVLW  0B
3B72:  MOVWF  00
3B74:  DECFSZ 00,F
3B76:  BRA    3B74
3B78:  BTFSS  F82.3
3B7A:  BRA    3B78
3B7C:  BCF    F8B.4
3B7E:  BCF    F94.4
3B80:  MOVLW  0A
3B82:  MOVWF  00
3B84:  DECFSZ 00,F
3B86:  BRA    3B84
3B88:  BCF    F8B.3
3B8A:  BCF    F94.3
....................       status=i2c_write(command); 
3B8C:  MOVFF  846,84C
3B90:  MOVLB  0
3B92:  RCALL  3476
3B94:  MOVF   01,W
3B96:  MOVLB  8
3B98:  BCF    x45.0
3B9A:  BTFSC  01.0
3B9C:  BSF    x45.0
....................    } 
3B9E:  BRA    3B60
....................    //delay_us(100); 
.................... } 
3BA0:  MOVLB  0
3BA2:  RETURN 0
....................  
.................... /* 
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(0xa1); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    return(data); 
.................... } 
.................... */ 
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3556:  MOVLB  8
3558:  MOVF   x3B,F
355A:  BNZ   3562
355C:  MOVF   x3A,W
355E:  SUBLW  00
3560:  BC    3568
3562:  MOVLW  A8
3564:  MOVWF  x3D
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3566:  BRA    356C
3568:  MOVLW  A0
356A:  MOVWF  x3D
....................  
....................    i2c_start(); 
356C:  BSF    F94.4
356E:  MOVLW  0A
3570:  MOVWF  00
3572:  DECFSZ 00,F
3574:  BRA    3572
3576:  BSF    F94.3
3578:  MOVLW  0B
357A:  MOVWF  00
357C:  DECFSZ 00,F
357E:  BRA    357C
3580:  BTFSS  F82.3
3582:  BRA    3580
3584:  BCF    F8B.4
3586:  BCF    F94.4
3588:  MOVLW  0A
358A:  MOVWF  00
358C:  DECFSZ 00,F
358E:  BRA    358C
3590:  BCF    F8B.3
3592:  BCF    F94.3
....................    i2c_write(command); 
3594:  MOVFF  83D,84C
3598:  MOVLB  0
359A:  RCALL  3476
....................    i2c_write(address>>8); 
359C:  MOVFF  839,83F
35A0:  MOVFF  83A,840
35A4:  MOVFF  83B,841
35A8:  MOVLB  8
35AA:  CLRF   x42
35AC:  MOVFF  839,84C
35B0:  MOVLB  0
35B2:  RCALL  3476
....................    i2c_write(address); 
35B4:  MOVFF  838,84C
35B8:  RCALL  3476
....................    i2c_start(); 
35BA:  BSF    F94.4
35BC:  MOVLW  0A
35BE:  MOVWF  00
35C0:  DECFSZ 00,F
35C2:  BRA    35C0
35C4:  BSF    F94.3
35C6:  MOVLW  0B
35C8:  MOVWF  00
35CA:  DECFSZ 00,F
35CC:  BRA    35CA
35CE:  BTFSS  F82.3
35D0:  BRA    35CE
35D2:  BCF    F8B.4
35D4:  BCF    F94.4
35D6:  MOVLW  0A
35D8:  MOVWF  00
35DA:  DECFSZ 00,F
35DC:  BRA    35DA
35DE:  BCF    F8B.3
35E0:  BCF    F94.3
....................    i2c_write(command+1); 
35E2:  MOVLW  01
35E4:  MOVLB  8
35E6:  ADDWF  x3D,W
35E8:  MOVWF  x3E
35EA:  MOVWF  x4C
35EC:  MOVLB  0
35EE:  RCALL  3476
....................    data=i2c_read(0); 
35F0:  CLRF   00
35F2:  RCALL  34EC
35F4:  MOVFF  01,83C
....................    i2c_stop(); 
35F8:  BCF    F94.4
35FA:  NOP   
35FC:  BSF    F94.3
35FE:  BTFSS  F82.3
3600:  BRA    35FE
3602:  MOVLW  0A
3604:  MOVWF  00
3606:  DECFSZ 00,F
3608:  BRA    3606
360A:  BRA    360C
360C:  NOP   
360E:  BSF    F94.4
3610:  MOVLW  0A
3612:  MOVWF  00
3614:  DECFSZ 00,F
3616:  BRA    3614
....................    return(data); 
3618:  MOVLB  8
361A:  MOVFF  83C,01
.................... } 
361E:  MOVLB  0
3620:  RETURN 0
....................  
....................  
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
5CCE:  MOVLB  7
5CD0:  MOVF   xFB,W
5CD2:  ADDWF  xF9,W
5CD4:  MOVLB  7
5CD6:  MOVF   xFC,W
5CD8:  ADDWFC xFA,W
5CDA:  MOVLB  8
5CDC:  MOVWF  x02
....................    for(i=0;i<len;i++) 
5CDE:  CLRF   x00
5CE0:  MOVLB  7
5CE2:  CLRF   xFF
5CE4:  MOVLB  8
5CE6:  MOVF   x00,W
5CE8:  MOVLB  7
5CEA:  SUBWF  xFC,W
5CEC:  BNC   5D56
5CEE:  BNZ   5CF6
5CF0:  MOVF   xFB,W
5CF2:  SUBWF  xFF,W
5CF4:  BC    5D56
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
5CF6:  MOVF   xFD,W
5CF8:  ADDWF  xFF,W
5CFA:  MOVWF  01
5CFC:  MOVF   xFE,W
5CFE:  MOVLB  8
5D00:  ADDWFC x00,W
5D02:  MOVWF  03
5D04:  MOVFF  01,801
5D08:  MOVWF  x02
5D0A:  MOVLB  7
5D0C:  MOVF   xFF,W
5D0E:  ADDWF  xF9,W
5D10:  MOVLB  8
5D12:  MOVWF  x03
5D14:  MOVF   x00,W
5D16:  MOVLB  7
5D18:  ADDWFC xFA,W
5D1A:  MOVLB  8
5D1C:  MOVWF  x04
5D1E:  CLRF   19
5D20:  BTFSC  FF2.7
5D22:  BSF    19.7
5D24:  BCF    FF2.7
5D26:  CLRF   x3B
5D28:  CLRF   x3A
5D2A:  MOVWF  x39
5D2C:  MOVFF  803,838
5D30:  MOVLB  0
5D32:  CALL   3556
5D36:  BTFSC  19.7
5D38:  BSF    FF2.7
5D3A:  MOVFF  802,FEA
5D3E:  MOVFF  801,FE9
5D42:  MOVFF  01,FEF
....................    } 
5D46:  MOVLB  7
5D48:  INCF   xFF,F
5D4A:  BTFSS  FD8.2
5D4C:  BRA    5D54
5D4E:  MOVLB  8
5D50:  INCF   x00,F
5D52:  MOVLB  7
5D54:  BRA    5CE4
....................     
.................... } 
5D56:  MOVLB  0
5D58:  GOTO   6556 (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_mobile_num0        65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_two_number        149 
.................... #define kindofKB                 126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards               930   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
369C:  MOVLB  8
369E:  CLRF   x41
36A0:  MOVF   x3E,W
36A2:  SUBWF  x41,W
36A4:  BC    36BA
....................    { 
....................       inputdat[i]=0; 
36A6:  CLRF   03
36A8:  MOVF   x41,W
36AA:  ADDWF  x3F,W
36AC:  MOVWF  FE9
36AE:  MOVF   x40,W
36B0:  ADDWFC 03,W
36B2:  MOVWF  FEA
36B4:  CLRF   FEF
....................    } 
36B6:  INCF   x41,F
36B8:  BRA    36A0
.................... } 
36BA:  MOVLB  0
36BC:  RETURN 0
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4702:  MOVLB  8
4704:  CLRF   x19
4706:  CLRF   x18
4708:  CLRF   x17
470A:  CLRF   x16
470C:  MOVF   x19,W
470E:  SUBWF  x13,W
4710:  BNC   4796
4712:  BNZ   472A
4714:  MOVF   x18,W
4716:  SUBWF  x12,W
4718:  BNC   4796
471A:  BNZ   472A
471C:  MOVF   x17,W
471E:  SUBWF  x11,W
4720:  BNC   4796
4722:  BNZ   472A
4724:  MOVF   x10,W
4726:  SUBWF  x16,W
4728:  BC    4796
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
472A:  MOVF   x16,W
472C:  ADDWF  x0C,W
472E:  MOVWF  x1A
4730:  MOVF   x17,W
4732:  ADDWFC x0D,W
4734:  MOVWF  x1B
4736:  MOVF   x18,W
4738:  ADDWFC x0E,W
473A:  MOVWF  x1C
473C:  MOVF   x19,W
473E:  ADDWFC x0F,W
4740:  MOVWF  x1D
4742:  MOVF   x14,W
4744:  ADDWF  x16,W
4746:  MOVWF  FE9
4748:  MOVF   x15,W
474A:  ADDWFC x17,W
474C:  MOVWF  FEA
474E:  MOVFF  FEF,81E
4752:  CLRF   19
4754:  BTFSC  FF2.7
4756:  BSF    19.7
4758:  BCF    FF2.7
475A:  MOVFF  81D,843
475E:  MOVFF  81C,842
4762:  MOVFF  81B,841
4766:  MOVFF  81A,840
476A:  MOVFF  81E,844
476E:  MOVLB  0
4770:  CALL   3AA6
4774:  BTFSC  19.7
4776:  BSF    FF2.7
....................       delay_us(10); 
4778:  MOVLW  1A
477A:  MOVWF  00
477C:  DECFSZ 00,F
477E:  BRA    477C
4780:  NOP   
....................    } 
4782:  MOVLW  01
4784:  MOVLB  8
4786:  ADDWF  x16,F
4788:  BTFSC  FD8.0
478A:  INCF   x17,F
478C:  BTFSC  FD8.2
478E:  INCF   x18,F
4790:  BTFSC  FD8.2
4792:  INCF   x19,F
4794:  BRA    470C
....................    return 1; 
4796:  MOVLW  01
4798:  MOVWF  01
.................... } 
479A:  MOVLB  0
479C:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
463A:  MOVLB  8
463C:  CLRF   x04
463E:  CLRF   x03
4640:  CLRF   x02
4642:  CLRF   x01
4644:  MOVF   x04,W
4646:  MOVLB  7
4648:  SUBWF  xFE,W
464A:  BNC   46FE
464C:  BNZ   4676
464E:  MOVLB  8
4650:  MOVF   x03,W
4652:  MOVLB  7
4654:  SUBWF  xFD,W
4656:  BNC   46FE
4658:  BNZ   4676
465A:  MOVLB  8
465C:  MOVF   x02,W
465E:  MOVLB  7
4660:  SUBWF  xFC,W
4662:  BNC   46FE
4664:  BNZ   4676
4666:  MOVF   xFB,W
4668:  MOVLB  8
466A:  SUBWF  x01,W
466C:  BTFSS  FD8.0
466E:  BRA    4674
4670:  MOVLB  7
4672:  BRA    46FE
4674:  MOVLB  7
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
4676:  MOVF   xFF,W
4678:  MOVLB  8
467A:  ADDWF  x01,W
467C:  MOVWF  01
467E:  MOVF   x00,W
4680:  ADDWFC x02,W
4682:  MOVWF  03
4684:  MOVFF  01,805
4688:  MOVWF  x06
468A:  MOVF   x01,W
468C:  MOVLB  7
468E:  ADDWF  xF7,W
4690:  MOVLB  8
4692:  MOVWF  x07
4694:  MOVF   x02,W
4696:  MOVLB  7
4698:  ADDWFC xF8,W
469A:  MOVLB  8
469C:  MOVWF  x08
469E:  MOVF   x03,W
46A0:  MOVLB  7
46A2:  ADDWFC xF9,W
46A4:  MOVLB  8
46A6:  MOVWF  x09
46A8:  MOVF   x04,W
46AA:  MOVLB  7
46AC:  ADDWFC xFA,W
46AE:  MOVLB  8
46B0:  MOVWF  x0A
46B2:  CLRF   19
46B4:  BTFSC  FF2.7
46B6:  BSF    19.7
46B8:  BCF    FF2.7
46BA:  MOVWF  x3B
46BC:  MOVFF  809,83A
46C0:  MOVFF  808,839
46C4:  MOVFF  807,838
46C8:  MOVLB  0
46CA:  CALL   3556
46CE:  BTFSC  19.7
46D0:  BSF    FF2.7
46D2:  MOVFF  806,FEA
46D6:  MOVFF  805,FE9
46DA:  MOVFF  01,FEF
....................       delay_us(10); 
46DE:  MOVLW  1A
46E0:  MOVWF  00
46E2:  DECFSZ 00,F
46E4:  BRA    46E2
46E6:  NOP   
....................    } 
46E8:  MOVLW  01
46EA:  MOVLB  8
46EC:  ADDWF  x01,F
46EE:  BTFSC  FD8.0
46F0:  INCF   x02,F
46F2:  BTFSC  FD8.2
46F4:  INCF   x03,F
46F6:  BTFSC  FD8.2
46F8:  INCF   x04,F
46FA:  BRA    4644
46FC:  MOVLB  7
.................... } 
46FE:  MOVLB  0
4700:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
4A10:  MOVLB  7
4A12:  CLRF   xC5
4A14:  CLRF   xC4
4A16:  CLRF   xC3
4A18:  CLRF   xC2
4A1A:  CLRF   xC9
4A1C:  CLRF   xC8
4A1E:  CLRF   xC7
4A20:  CLRF   xC6
4A22:  CLRF   xCD
4A24:  CLRF   xCC
4A26:  CLRF   xCB
4A28:  CLRF   xCA
4A2A:  CLRF   xD1
4A2C:  CLRF   xD0
4A2E:  CLRF   xCF
4A30:  CLRF   xCE
4A32:  CLRF   xD5
4A34:  CLRF   xD4
4A36:  CLRF   xD3
4A38:  CLRF   xD2
4A3A:  CLRF   19
4A3C:  BTFSC  FF2.7
4A3E:  BSF    19.7
4A40:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
4A42:  MOVLB  8
4A44:  CLRF   x3B
4A46:  CLRF   x3A
4A48:  CLRF   x39
4A4A:  MOVFF  7C1,838
4A4E:  MOVLB  0
4A50:  CALL   3556
4A54:  BTFSC  19.7
4A56:  BSF    FF2.7
4A58:  MOVLB  7
4A5A:  MOVFF  01,7C6
4A5E:  CLRF   xC7
4A60:  CLRF   xC8
4A62:  CLRF   xC9
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
4A64:  MOVLW  01
4A66:  ADDWF  xC1,W
4A68:  MOVWF  xD6
4A6A:  CLRF   19
4A6C:  BTFSC  FF2.7
4A6E:  BSF    19.7
4A70:  BCF    FF2.7
4A72:  MOVLB  8
4A74:  CLRF   x3B
4A76:  CLRF   x3A
4A78:  CLRF   x39
4A7A:  MOVWF  x38
4A7C:  MOVLB  0
4A7E:  CALL   3556
4A82:  BTFSC  19.7
4A84:  BSF    FF2.7
4A86:  MOVLB  7
4A88:  CLRF   xCD
4A8A:  CLRF   xCC
4A8C:  CLRF   xCB
4A8E:  MOVFF  01,7CA
....................    temp2<<=8; 
4A92:  MOVFF  7CC,7CD
4A96:  MOVFF  7CB,7CC
4A9A:  MOVFF  7CA,7CB
4A9E:  CLRF   xCA
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
4AA0:  MOVLW  02
4AA2:  ADDWF  xC1,W
4AA4:  MOVWF  xD6
4AA6:  CLRF   19
4AA8:  BTFSC  FF2.7
4AAA:  BSF    19.7
4AAC:  BCF    FF2.7
4AAE:  MOVLB  8
4AB0:  CLRF   x3B
4AB2:  CLRF   x3A
4AB4:  CLRF   x39
4AB6:  MOVWF  x38
4AB8:  MOVLB  0
4ABA:  CALL   3556
4ABE:  BTFSC  19.7
4AC0:  BSF    FF2.7
4AC2:  MOVLB  7
4AC4:  CLRF   xD1
4AC6:  CLRF   xD0
4AC8:  CLRF   xCF
4ACA:  MOVFF  01,7CE
....................    temp3<<=16; 
4ACE:  MOVFF  7CF,7D1
4AD2:  MOVFF  7CE,7D0
4AD6:  CLRF   xCE
4AD8:  CLRF   xCF
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
4ADA:  MOVLW  03
4ADC:  ADDWF  xC1,W
4ADE:  MOVWF  xD6
4AE0:  CLRF   19
4AE2:  BTFSC  FF2.7
4AE4:  BSF    19.7
4AE6:  BCF    FF2.7
4AE8:  MOVLB  8
4AEA:  CLRF   x3B
4AEC:  CLRF   x3A
4AEE:  CLRF   x39
4AF0:  MOVWF  x38
4AF2:  MOVLB  0
4AF4:  CALL   3556
4AF8:  BTFSC  19.7
4AFA:  BSF    FF2.7
4AFC:  MOVLB  7
4AFE:  CLRF   xD5
4B00:  CLRF   xD4
4B02:  CLRF   xD3
4B04:  MOVFF  01,7D2
....................    temp4<<=24; 
4B08:  MOVFF  7D2,7D5
4B0C:  CLRF   xD2
4B0E:  CLRF   xD3
4B10:  CLRF   xD4
....................    buffer = temp4|temp3|temp2|temp1; 
4B12:  MOVF   xD2,W
4B14:  IORWF  xCE,W
4B16:  MOVWF  xD6
4B18:  MOVF   xD3,W
4B1A:  IORWF  xCF,W
4B1C:  MOVWF  xD7
4B1E:  MOVF   xD4,W
4B20:  IORWF  xD0,W
4B22:  MOVWF  xD8
4B24:  MOVF   xD5,W
4B26:  IORWF  xD1,W
4B28:  MOVWF  xD9
4B2A:  MOVF   xCA,W
4B2C:  IORWF  xD6,F
4B2E:  MOVF   xCB,W
4B30:  IORWF  xD7,F
4B32:  MOVF   xCC,W
4B34:  IORWF  xD8,F
4B36:  MOVF   xCD,W
4B38:  IORWF  xD9,F
4B3A:  MOVF   xD6,W
4B3C:  IORWF  xC6,W
4B3E:  MOVWF  xC2
4B40:  MOVF   xD7,W
4B42:  IORWF  xC7,W
4B44:  MOVWF  xC3
4B46:  MOVF   xD8,W
4B48:  IORWF  xC8,W
4B4A:  MOVWF  xC4
4B4C:  MOVF   xD9,W
4B4E:  IORWF  xC9,W
4B50:  MOVWF  xC5
....................    return(buffer); 
4B52:  MOVFF  7C2,00
4B56:  MOVFF  7C3,01
4B5A:  MOVFF  7C4,02
4B5E:  MOVFF  7C5,03
.................... } 
4B62:  MOVLB  0
4B64:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3BA4:  MOVLB  8
3BA6:  CLRF   x3A
3BA8:  CLRF   x39
3BAA:  CLRF   x38
3BAC:  CLRF   x37
3BAE:  CLRF   x3B
3BB0:  CLRF   x3C
3BB2:  CLRF   x3D
3BB4:  CLRF   x3E
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3BB6:  MOVFF  835,83A
3BBA:  MOVFF  834,839
3BBE:  MOVFF  833,838
3BC2:  MOVFF  832,837
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3BC6:  MOVFF  837,83B
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3BCA:  MOVFF  838,83C
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3BCE:  MOVFF  839,83D
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3BD2:  MOVFF  83A,83E
....................    write_ext_eeprom((addr+0),temp1); 
3BD6:  CLRF   x43
3BD8:  CLRF   x42
3BDA:  CLRF   x41
3BDC:  MOVFF  836,840
3BE0:  MOVFF  83B,844
3BE4:  MOVLB  0
3BE6:  RCALL  3AA6
....................    write_ext_eeprom((addr+1),temp2); 
3BE8:  MOVLW  01
3BEA:  MOVLB  8
3BEC:  ADDWF  x36,W
3BEE:  MOVWF  x3F
3BF0:  CLRF   x43
3BF2:  CLRF   x42
3BF4:  CLRF   x41
3BF6:  MOVWF  x40
3BF8:  MOVFF  83C,844
3BFC:  MOVLB  0
3BFE:  RCALL  3AA6
....................    write_ext_eeprom((addr+2),temp3); 
3C00:  MOVLW  02
3C02:  MOVLB  8
3C04:  ADDWF  x36,W
3C06:  MOVWF  x3F
3C08:  CLRF   x43
3C0A:  CLRF   x42
3C0C:  CLRF   x41
3C0E:  MOVWF  x40
3C10:  MOVFF  83D,844
3C14:  MOVLB  0
3C16:  RCALL  3AA6
....................    write_ext_eeprom((addr+3),temp4); 
3C18:  MOVLW  03
3C1A:  MOVLB  8
3C1C:  ADDWF  x36,W
3C1E:  MOVWF  x3F
3C20:  CLRF   x43
3C22:  CLRF   x42
3C24:  CLRF   x41
3C26:  MOVWF  x40
3C28:  MOVFF  83E,844
3C2C:  MOVLB  0
3C2E:  RCALL  3AA6
.................... } 
3C30:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
41D2:  MOVLB  8
41D4:  CLRF   x32
41D6:  CLRF   x31
41D8:  CLRF   x33
41DA:  CLRF   x34
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
41DC:  MOVFF  830,832
41E0:  MOVFF  82F,831
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
41E4:  MOVFF  831,833
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
41E8:  MOVF   x32,W
41EA:  MOVWF  x34
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
41EC:  CLRF   x43
41EE:  CLRF   x42
41F0:  CLRF   x41
41F2:  MOVLW  28
41F4:  MOVWF  x40
41F6:  MOVFF  833,844
41FA:  MOVLB  0
41FC:  RCALL  3AA6
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
41FE:  MOVLB  8
4200:  CLRF   x43
4202:  CLRF   x42
4204:  CLRF   x41
4206:  MOVLW  29
4208:  MOVWF  x40
420A:  MOVFF  834,844
420E:  MOVLB  0
4210:  RCALL  3AA6
.................... } 
4212:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
3622:  MOVLB  8
3624:  CLRF   x33
3626:  CLRF   x32
3628:  CLRF   x35
362A:  CLRF   x34
362C:  CLRF   x37
362E:  CLRF   x36
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
3630:  CLRF   x3B
3632:  CLRF   x3A
3634:  CLRF   x39
3636:  MOVLW  28
3638:  MOVWF  x38
363A:  MOVLB  0
363C:  RCALL  3556
363E:  MOVLB  8
3640:  MOVFF  01,834
3644:  CLRF   x35
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3646:  CLRF   x3B
3648:  CLRF   x3A
364A:  CLRF   x39
364C:  MOVLW  29
364E:  MOVWF  x38
3650:  MOVLB  0
3652:  RCALL  3556
3654:  MOVLB  8
3656:  CLRF   x37
3658:  MOVFF  01,836
....................    temp2<<=8; 
365C:  MOVFF  836,837
3660:  CLRF   x36
....................    buffer = temp2|temp1; 
3662:  MOVF   x36,W
3664:  IORWF  x34,W
3666:  MOVWF  x32
3668:  MOVF   x37,W
366A:  IORWF  x35,W
366C:  MOVWF  x33
....................    return(buffer); 
366E:  MOVFF  832,01
3672:  MOVFF  833,02
.................... } 
3676:  MOVLB  0
3678:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2,"EEPROM_KEY_ST=%lu\n\r",EEPROM_KEY_ST); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
5E76:  MOVLB  7
5E78:  CLRF   xFA
5E7A:  MOVLW  01
5E7C:  MOVWF  xF9
5E7E:  MOVLW  C3
5E80:  MOVWF  xF8
5E82:  MOVLW  0F
5E84:  MOVWF  xF7
5E86:  MOVF   xFA,W
5E88:  SUBWF  27,W
5E8A:  BNC   5EDE
5E8C:  BNZ   5EA4
5E8E:  MOVF   xF9,W
5E90:  SUBWF  26,W
5E92:  BNC   5EDE
5E94:  BNZ   5EA4
5E96:  MOVF   xF8,W
5E98:  SUBWF  25,W
5E9A:  BNC   5EDE
5E9C:  BNZ   5EA4
5E9E:  MOVF   24,W
5EA0:  SUBWF  xF7,W
5EA2:  BC    5EDE
5EA4:  CLRF   19
5EA6:  BTFSC  FF2.7
5EA8:  BSF    19.7
5EAA:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5EAC:  MOVFF  7FA,843
5EB0:  MOVFF  7F9,842
5EB4:  MOVFF  7F8,841
5EB8:  MOVFF  7F7,840
5EBC:  MOVLB  8
5EBE:  CLRF   x44
5EC0:  MOVLB  0
5EC2:  CALL   3AA6
5EC6:  BTFSC  19.7
5EC8:  BSF    FF2.7
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    } 
5ECA:  MOVLW  01
5ECC:  MOVLB  7
5ECE:  ADDWF  xF7,F
5ED0:  BTFSC  FD8.0
5ED2:  INCF   xF8,F
5ED4:  BTFSC  FD8.2
5ED6:  INCF   xF9,F
5ED8:  BTFSC  FD8.2
5EDA:  INCF   xFA,F
5EDC:  BRA    5E86
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=ptr_start;i<ptr_card;i++) 
5EDE:  CLRF   xFA
5EE0:  CLRF   xF9
5EE2:  CLRF   xF8
5EE4:  MOVLW  96
5EE6:  MOVWF  xF7
5EE8:  MOVF   xFA,W
5EEA:  SUBWF  23,W
5EEC:  BNC   5F40
5EEE:  BNZ   5F06
5EF0:  MOVF   xF9,W
5EF2:  SUBWF  22,W
5EF4:  BNC   5F40
5EF6:  BNZ   5F06
5EF8:  MOVF   xF8,W
5EFA:  SUBWF  21,W
5EFC:  BNC   5F40
5EFE:  BNZ   5F06
5F00:  MOVF   20,W
5F02:  SUBWF  xF7,W
5F04:  BC    5F40
5F06:  CLRF   19
5F08:  BTFSC  FF2.7
5F0A:  BSF    19.7
5F0C:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5F0E:  MOVFF  7FA,843
5F12:  MOVFF  7F9,842
5F16:  MOVFF  7F8,841
5F1A:  MOVFF  7F7,840
5F1E:  MOVLB  8
5F20:  CLRF   x44
5F22:  MOVLB  0
5F24:  CALL   3AA6
5F28:  BTFSC  19.7
5F2A:  BSF    FF2.7
....................    } 
5F2C:  MOVLW  01
5F2E:  MOVLB  7
5F30:  ADDWF  xF7,F
5F32:  BTFSC  FD8.0
5F34:  INCF   xF8,F
5F36:  BTFSC  FD8.2
5F38:  INCF   xF9,F
5F3A:  BTFSC  FD8.2
5F3C:  INCF   xFA,F
5F3E:  BRA    5EE8
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
5F40:  CLRF   23
5F42:  CLRF   22
5F44:  CLRF   21
5F46:  MOVLW  96
5F48:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5F4A:  CLRF   27
5F4C:  MOVLW  01
5F4E:  MOVWF  26
5F50:  MOVLW  C3
5F52:  MOVWF  25
5F54:  MOVLW  0F
5F56:  MOVWF  24
5F58:  CLRF   19
5F5A:  BTFSC  FF2.7
5F5C:  BSF    19.7
5F5E:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5F60:  MOVFF  23,835
5F64:  MOVFF  22,834
5F68:  MOVFF  21,833
5F6C:  MOVFF  20,832
5F70:  MOVLW  19
5F72:  MOVLB  8
5F74:  MOVWF  x36
5F76:  MOVLB  0
5F78:  CALL   3BA4
5F7C:  BTFSC  19.7
5F7E:  BSF    FF2.7
5F80:  CLRF   19
5F82:  BTFSC  FF2.7
5F84:  BSF    19.7
5F86:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5F88:  MOVFF  27,835
5F8C:  MOVFF  26,834
5F90:  MOVFF  25,833
5F94:  MOVFF  24,832
5F98:  MOVLW  1E
5F9A:  MOVLB  8
5F9C:  MOVWF  x36
5F9E:  MOVLB  0
5FA0:  CALL   3BA4
5FA4:  BTFSC  19.7
5FA6:  BSF    FF2.7
5FA8:  CLRF   19
5FAA:  BTFSC  FF2.7
5FAC:  BSF    19.7
5FAE:  BCF    FF2.7
....................    save_coutcard(0); 
5FB0:  MOVLB  8
5FB2:  CLRF   x30
5FB4:  CLRF   x2F
5FB6:  MOVLB  0
5FB8:  CALL   41D2
5FBC:  BTFSC  19.7
5FBE:  BSF    FF2.7
5FC0:  CLRF   19
5FC2:  BTFSC  FF2.7
5FC4:  BSF    19.7
5FC6:  BCF    FF2.7
....................    countcard=get_countcard(); 
5FC8:  CALL   3622
5FCC:  BTFSC  19.7
5FCE:  BSF    FF2.7
5FD0:  MOVFF  02,FA
5FD4:  MOVFF  01,F9
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
5FD8:  GOTO   68C8 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    /*for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    ptr_card=ptr_start; 
5FDC:  CLRF   23
5FDE:  CLRF   22
5FE0:  CLRF   21
5FE2:  MOVLW  96
5FE4:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5FE6:  CLRF   27
5FE8:  MOVLW  01
5FEA:  MOVWF  26
5FEC:  MOVLW  C3
5FEE:  MOVWF  25
5FF0:  MOVLW  0F
5FF2:  MOVWF  24
5FF4:  CLRF   19
5FF6:  BTFSC  FF2.7
5FF8:  BSF    19.7
5FFA:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5FFC:  MOVFF  23,835
6000:  MOVFF  22,834
6004:  MOVFF  21,833
6008:  MOVFF  20,832
600C:  MOVLW  19
600E:  MOVLB  8
6010:  MOVWF  x36
6012:  MOVLB  0
6014:  CALL   3BA4
6018:  BTFSC  19.7
601A:  BSF    FF2.7
601C:  CLRF   19
601E:  BTFSC  FF2.7
6020:  BSF    19.7
6022:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
6024:  MOVFF  27,835
6028:  MOVFF  26,834
602C:  MOVFF  25,833
6030:  MOVFF  24,832
6034:  MOVLW  1E
6036:  MOVLB  8
6038:  MOVWF  x36
603A:  MOVLB  0
603C:  CALL   3BA4
6040:  BTFSC  19.7
6042:  BSF    FF2.7
6044:  CLRF   19
6046:  BTFSC  FF2.7
6048:  BSF    19.7
604A:  BCF    FF2.7
....................    save_coutcard(0); 
604C:  MOVLB  8
604E:  CLRF   x30
6050:  CLRF   x2F
6052:  MOVLB  0
6054:  CALL   41D2
6058:  BTFSC  19.7
605A:  BSF    FF2.7
.................... } 
605C:  GOTO   692E (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
479E:  MOVLB  7
47A0:  CLRF   xFA
47A2:  CLRF   xF9
47A4:  CLRF   xF8
47A6:  CLRF   xF7
47A8:  CLRF   xFE
47AA:  CLRF   xFD
47AC:  CLRF   xFC
47AE:  MOVLW  14
47B0:  MOVWF  xFB
47B2:  MOVLB  8
47B4:  CLRF   x00
47B6:  MOVLW  55
47B8:  MOVLB  7
47BA:  MOVWF  xFF
47BC:  MOVLB  0
47BE:  RCALL  463A
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
47C0:  INCFSZ 55,W
47C2:  BRA    4834
47C4:  INCFSZ 56,W
47C6:  BRA    4834
47C8:  INCFSZ x64,W
47CA:  BRA    4834
....................       { 
....................          memset(buffer1,0,20); 
47CC:  CLRF   FEA
47CE:  MOVLW  2D
47D0:  MOVWF  FE9
47D2:  CLRF   00
47D4:  CLRF   02
47D6:  MOVLW  14
47D8:  MOVWF  01
47DA:  RCALL  403A
....................          strcpy(buffer1,"admin"); 
47DC:  CLRF   FEA
47DE:  MOVLW  2D
47E0:  MOVWF  FE9
47E2:  MOVLW  00
47E4:  CALL   00BA
47E8:  TBLRD*-
47EA:  TBLRD*+
47EC:  MOVF   FF5,W
47EE:  MOVWF  FEE
47F0:  IORLW  00
47F2:  BNZ   47EA
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
47F4:  MOVLB  8
47F6:  CLRF   x0F
47F8:  CLRF   x0E
47FA:  CLRF   x0D
47FC:  CLRF   x0C
47FE:  CLRF   x13
4800:  CLRF   x12
4802:  CLRF   x11
4804:  MOVLW  14
4806:  MOVWF  x10
4808:  CLRF   x15
480A:  MOVLW  2D
480C:  MOVWF  x14
480E:  MOVLB  0
4810:  RCALL  4702
....................          EEPROM_read(strobe_pass_addr,20,password); 
4812:  MOVLB  7
4814:  CLRF   xFA
4816:  CLRF   xF9
4818:  CLRF   xF8
481A:  CLRF   xF7
481C:  CLRF   xFE
481E:  CLRF   xFD
4820:  CLRF   xFC
4822:  MOVLW  14
4824:  MOVWF  xFB
4826:  MOVLB  8
4828:  CLRF   x00
482A:  MOVLW  55
482C:  MOVLB  7
482E:  MOVWF  xFF
4830:  MOVLB  0
4832:  RCALL  463A
....................       } 
.................... } 
4834:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
6060:  MOVLB  8
6062:  CLRF   x0B
6064:  MOVF   x0B,W
6066:  SUBLW  13
6068:  BNC   607E
606A:  CLRF   03
606C:  MOVF   x0B,W
606E:  ADDLW  F7
6070:  MOVWF  FE9
6072:  MOVLW  07
6074:  ADDWFC 03,W
6076:  MOVWF  FEA
6078:  SETF   FEF
607A:  INCF   x0B,F
607C:  BRA    6064
....................    EEPROM_write(strobe_pass_addr,20,buf); 
607E:  CLRF   x0F
6080:  CLRF   x0E
6082:  CLRF   x0D
6084:  CLRF   x0C
6086:  CLRF   x13
6088:  CLRF   x12
608A:  CLRF   x11
608C:  MOVLW  14
608E:  MOVWF  x10
6090:  MOVLW  07
6092:  MOVWF  x15
6094:  MOVLW  F7
6096:  MOVWF  x14
6098:  MOVLB  0
609A:  CALL   4702
.................... } 
609E:  GOTO   6994 (RETURN)
.................... //============================================ 
.................... void reset_2nd_number() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0; 
....................    EEPROM_write(strobe_mobile_num0,20,buf); 
.................... } 
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
4836:  BSF    F94.4
4838:  MOVLW  0A
483A:  MOVWF  00
483C:  DECFSZ 00,F
483E:  BRA    483C
4840:  BSF    F94.3
4842:  MOVLW  0B
4844:  MOVWF  00
4846:  DECFSZ 00,F
4848:  BRA    4846
484A:  BCF    F8B.4
484C:  BCF    F94.4
484E:  MOVLW  0A
4850:  MOVWF  00
4852:  DECFSZ 00,F
4854:  BRA    4852
4856:  BCF    F8B.3
4858:  BCF    F94.3
485A:  CLRF   19
485C:  BTFSC  FF2.7
485E:  BSF    19.7
4860:  BCF    FF2.7
....................    i2c_write(0xD0); 
4862:  MOVLW  D0
4864:  MOVLB  8
4866:  MOVWF  x4C
4868:  MOVLB  0
486A:  CALL   3476
486E:  BTFSC  19.7
4870:  BSF    FF2.7
4872:  CLRF   19
4874:  BTFSC  FF2.7
4876:  BSF    19.7
4878:  BCF    FF2.7
....................    i2c_write(address); 
487A:  MOVFF  7FB,84C
487E:  CALL   3476
4882:  BTFSC  19.7
4884:  BSF    FF2.7
....................    i2c_start(); 
4886:  BSF    F94.4
4888:  MOVLW  0A
488A:  MOVWF  00
488C:  DECFSZ 00,F
488E:  BRA    488C
4890:  BSF    F94.3
4892:  MOVLW  0B
4894:  MOVWF  00
4896:  DECFSZ 00,F
4898:  BRA    4896
489A:  BTFSS  F82.3
489C:  BRA    489A
489E:  BCF    F8B.4
48A0:  BCF    F94.4
48A2:  MOVLW  0A
48A4:  MOVWF  00
48A6:  DECFSZ 00,F
48A8:  BRA    48A6
48AA:  BCF    F8B.3
48AC:  BCF    F94.3
48AE:  CLRF   19
48B0:  BTFSC  FF2.7
48B2:  BSF    19.7
48B4:  BCF    FF2.7
....................    i2c_write(0xD1); 
48B6:  MOVLW  D1
48B8:  MOVLB  8
48BA:  MOVWF  x4C
48BC:  MOVLB  0
48BE:  CALL   3476
48C2:  BTFSC  19.7
48C4:  BSF    FF2.7
....................    result = i2c_read(0); 
48C6:  CLRF   00
48C8:  CLRF   19
48CA:  BTFSC  FF2.7
48CC:  BSF    19.7
48CE:  BCF    FF2.7
48D0:  CALL   34EC
48D4:  BTFSC  19.7
48D6:  BSF    FF2.7
48D8:  MOVFF  01,7FC
....................    i2c_stop(); 
48DC:  BCF    F94.4
48DE:  NOP   
48E0:  BSF    F94.3
48E2:  BTFSS  F82.3
48E4:  BRA    48E2
48E6:  MOVLW  0A
48E8:  MOVWF  00
48EA:  DECFSZ 00,F
48EC:  BRA    48EA
48EE:  BRA    48F0
48F0:  NOP   
48F2:  BSF    F94.4
48F4:  MOVLW  0A
48F6:  MOVWF  00
48F8:  DECFSZ 00,F
48FA:  BRA    48F8
....................     
....................    return(result); 
48FC:  MOVLB  7
48FE:  MOVFF  7FC,01
.................... } 
4902:  MOVLB  0
4904:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
6252:  BSF    F94.4
6254:  MOVLW  0A
6256:  MOVWF  00
6258:  DECFSZ 00,F
625A:  BRA    6258
625C:  BSF    F94.3
625E:  MOVLW  0B
6260:  MOVWF  00
6262:  DECFSZ 00,F
6264:  BRA    6262
6266:  BCF    F8B.4
6268:  BCF    F94.4
626A:  MOVLW  0A
626C:  MOVWF  00
626E:  DECFSZ 00,F
6270:  BRA    626E
6272:  BCF    F8B.3
6274:  BCF    F94.3
....................    delay_us(10); 
6276:  MOVLW  1A
6278:  MOVWF  00
627A:  DECFSZ 00,F
627C:  BRA    627A
627E:  NOP   
6280:  CLRF   19
6282:  BTFSC  FF2.7
6284:  BSF    19.7
6286:  BCF    FF2.7
....................    i2c_write(0xD0); 
6288:  MOVLW  D0
628A:  MOVLB  8
628C:  MOVWF  x4C
628E:  MOVLB  0
6290:  CALL   3476
6294:  BTFSC  19.7
6296:  BSF    FF2.7
....................    delay_us(10); 
6298:  MOVLW  1A
629A:  MOVWF  00
629C:  DECFSZ 00,F
629E:  BRA    629C
62A0:  NOP   
62A2:  CLRF   19
62A4:  BTFSC  FF2.7
62A6:  BSF    19.7
62A8:  BCF    FF2.7
....................    i2c_write(address); 
62AA:  MOVFF  7FE,84C
62AE:  CALL   3476
62B2:  BTFSC  19.7
62B4:  BSF    FF2.7
....................    delay_us(10); 
62B6:  MOVLW  1A
62B8:  MOVWF  00
62BA:  DECFSZ 00,F
62BC:  BRA    62BA
62BE:  NOP   
62C0:  CLRF   19
62C2:  BTFSC  FF2.7
62C4:  BSF    19.7
62C6:  BCF    FF2.7
....................    i2c_write(data); 
62C8:  MOVFF  7FF,84C
62CC:  CALL   3476
62D0:  BTFSC  19.7
62D2:  BSF    FF2.7
....................    i2c_stop(); 
62D4:  BCF    F94.4
62D6:  NOP   
62D8:  BSF    F94.3
62DA:  BTFSS  F82.3
62DC:  BRA    62DA
62DE:  MOVLW  0A
62E0:  MOVWF  00
62E2:  DECFSZ 00,F
62E4:  BRA    62E2
62E6:  BRA    62E8
62E8:  NOP   
62EA:  BSF    F94.4
62EC:  MOVLW  0A
62EE:  MOVWF  00
62F0:  DECFSZ 00,F
62F2:  BRA    62F0
....................    delay_us(10); 
62F4:  MOVLW  1A
62F6:  MOVWF  00
62F8:  DECFSZ 00,F
62FA:  BRA    62F8
62FC:  NOP   
.................... } 
62FE:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
*
4906:  MOVLB  7
4908:  CLRF   xFB
490A:  MOVLB  0
490C:  RCALL  4836
490E:  MOVFF  01,7C1
....................     
....................    data &= 0x7F; 
4912:  MOVLB  7
4914:  BCF    xC1.7
....................     
....................    i2c_start(); 
4916:  BSF    F94.4
4918:  MOVLW  0A
491A:  MOVWF  00
491C:  DECFSZ 00,F
491E:  BRA    491C
4920:  BSF    F94.3
4922:  MOVLW  0B
4924:  MOVWF  00
4926:  DECFSZ 00,F
4928:  BRA    4926
492A:  BCF    F8B.4
492C:  BCF    F94.4
492E:  MOVLW  0A
4930:  MOVWF  00
4932:  DECFSZ 00,F
4934:  BRA    4932
4936:  BCF    F8B.3
4938:  BCF    F94.3
493A:  CLRF   19
493C:  BTFSC  FF2.7
493E:  BSF    19.7
4940:  BCF    FF2.7
....................    i2c_write(0xD0); 
4942:  MOVLW  D0
4944:  MOVLB  8
4946:  MOVWF  x4C
4948:  MOVLB  0
494A:  CALL   3476
494E:  BTFSC  19.7
4950:  BSF    FF2.7
4952:  CLRF   19
4954:  BTFSC  FF2.7
4956:  BSF    19.7
4958:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
495A:  MOVLB  8
495C:  CLRF   x4C
495E:  MOVLB  0
4960:  CALL   3476
4964:  BTFSC  19.7
4966:  BSF    FF2.7
4968:  CLRF   19
496A:  BTFSC  FF2.7
496C:  BSF    19.7
496E:  BCF    FF2.7
....................    i2c_write(data); 
4970:  MOVFF  7C1,84C
4974:  CALL   3476
4978:  BTFSC  19.7
497A:  BSF    FF2.7
....................    i2c_start(); 
497C:  BSF    F94.4
497E:  MOVLW  0A
4980:  MOVWF  00
4982:  DECFSZ 00,F
4984:  BRA    4982
4986:  BSF    F94.3
4988:  MOVLW  0B
498A:  MOVWF  00
498C:  DECFSZ 00,F
498E:  BRA    498C
4990:  BTFSS  F82.3
4992:  BRA    4990
4994:  BCF    F8B.4
4996:  BCF    F94.4
4998:  MOVLW  0A
499A:  MOVWF  00
499C:  DECFSZ 00,F
499E:  BRA    499C
49A0:  BCF    F8B.3
49A2:  BCF    F94.3
49A4:  CLRF   19
49A6:  BTFSC  FF2.7
49A8:  BSF    19.7
49AA:  BCF    FF2.7
....................    i2c_write(0xD0); 
49AC:  MOVLW  D0
49AE:  MOVLB  8
49B0:  MOVWF  x4C
49B2:  MOVLB  0
49B4:  CALL   3476
49B8:  BTFSC  19.7
49BA:  BSF    FF2.7
49BC:  CLRF   19
49BE:  BTFSC  FF2.7
49C0:  BSF    19.7
49C2:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
49C4:  MOVLW  07
49C6:  MOVLB  8
49C8:  MOVWF  x4C
49CA:  MOVLB  0
49CC:  CALL   3476
49D0:  BTFSC  19.7
49D2:  BSF    FF2.7
49D4:  CLRF   19
49D6:  BTFSC  FF2.7
49D8:  BSF    19.7
49DA:  BCF    FF2.7
....................    i2c_write(0x80); 
49DC:  MOVLW  80
49DE:  MOVLB  8
49E0:  MOVWF  x4C
49E2:  MOVLB  0
49E4:  CALL   3476
49E8:  BTFSC  19.7
49EA:  BSF    FF2.7
....................    i2c_stop(); 
49EC:  BCF    F94.4
49EE:  NOP   
49F0:  BSF    F94.3
49F2:  BTFSS  F82.3
49F4:  BRA    49F2
49F6:  MOVLW  0A
49F8:  MOVWF  00
49FA:  DECFSZ 00,F
49FC:  BRA    49FA
49FE:  BRA    4A00
4A00:  NOP   
4A02:  BSF    F94.4
4A04:  MOVLW  0A
4A06:  MOVWF  00
4A08:  DECFSZ 00,F
4A0A:  BRA    4A08
.................... } 
4A0C:  GOTO   7BE6 (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
6300:  CLRF   19
6302:  BTFSC  FF2.7
6304:  BSF    19.7
6306:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
6308:  MOVFF  7FD,83E
630C:  MOVLW  0A
630E:  MOVLB  8
6310:  MOVWF  x3F
6312:  MOVLB  0
6314:  CALL   1742
6318:  BTFSC  19.7
631A:  BSF    FF2.7
631C:  MOVFF  01,7FE
....................    nibl=data-(nibh*10); 
6320:  MOVLB  7
6322:  MOVF   xFE,W
6324:  MULLW  0A
6326:  MOVF   FF3,W
6328:  SUBWF  xFD,W
632A:  MOVWF  xFF
....................  
....................    return((nibh<<4)|nibl); 
632C:  SWAPF  xFE,W
632E:  MOVWF  00
6330:  MOVLW  F0
6332:  ANDWF  00,F
6334:  MOVF   00,W
6336:  IORWF  xFF,W
6338:  MOVWF  01
.................... } 
633A:  MOVLB  0
633C:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
610C:  MOVFF  7FC,7FD
....................    data=(i>>4)*10; 
6110:  MOVLB  7
6112:  SWAPF  xFD,W
6114:  MOVWF  00
6116:  MOVLW  0F
6118:  ANDWF  00,F
611A:  MOVF   00,W
611C:  MULLW  0A
611E:  MOVFF  FF3,7FC
....................    data=data+(i<<4>>4); 
6122:  SWAPF  xFD,W
6124:  MOVWF  00
6126:  MOVLW  F0
6128:  ANDWF  00,F
612A:  MOVF   00,W
612C:  SWAPF  00,F
612E:  MOVLW  0F
6130:  ANDWF  00,F
6132:  MOVF   00,W
6134:  ADDWF  xFC,F
....................  
....................    return data; 
6136:  MOVFF  7FC,01
.................... } 
613A:  MOVLB  0
613C:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
633E:  MOVLB  7
6340:  CLRF   xFE
6342:  CLRF   xFF
6344:  MOVLB  0
6346:  RCALL  6252
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
6348:  MOVFF  7FC,7FD
634C:  RCALL  6300
634E:  MOVFF  01,7FD
6352:  MOVLW  01
6354:  MOVLB  7
6356:  MOVWF  xFE
6358:  MOVFF  01,7FF
635C:  MOVLB  0
635E:  RCALL  6252
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
6360:  MOVFF  7FB,7FD
6364:  RCALL  6300
6366:  MOVFF  01,7FD
636A:  MOVLW  02
636C:  MOVLB  7
636E:  MOVWF  xFE
6370:  MOVFF  01,7FF
6374:  MOVLB  0
6376:  RCALL  6252
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
6378:  MOVFF  7FA,7FD
637C:  RCALL  6300
637E:  MOVFF  01,7FD
6382:  MOVLW  03
6384:  MOVLB  7
6386:  MOVWF  xFE
6388:  MOVFF  01,7FF
638C:  MOVLB  0
638E:  RCALL  6252
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
6390:  MOVFF  7F7,7FD
6394:  RCALL  6300
6396:  MOVFF  01,7FD
639A:  MOVLW  04
639C:  MOVLB  7
639E:  MOVWF  xFE
63A0:  MOVFF  01,7FF
63A4:  MOVLB  0
63A6:  RCALL  6252
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
63A8:  MOVFF  7F8,7FD
63AC:  RCALL  6300
63AE:  MOVFF  01,7FD
63B2:  MOVLW  05
63B4:  MOVLB  7
63B6:  MOVWF  xFE
63B8:  MOVFF  01,7FF
63BC:  MOVLB  0
63BE:  RCALL  6252
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
63C0:  MOVFF  7F9,7FD
63C4:  RCALL  6300
63C6:  MOVFF  01,7FD
63CA:  MOVLW  06
63CC:  MOVLB  7
63CE:  MOVWF  xFE
63D0:  MOVFF  01,7FF
63D4:  MOVLB  0
63D6:  RCALL  6252
....................    write_DS1307(DS1307_CONTROL,0);    
63D8:  MOVLW  07
63DA:  MOVLB  7
63DC:  MOVWF  xFE
63DE:  CLRF   xFF
63E0:  MOVLB  0
63E2:  RCALL  6252
.................... } 
63E4:  GOTO   703A (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
6B7A:  MOVLW  04
6B7C:  MOVLB  7
6B7E:  MOVWF  xFB
6B80:  MOVLB  0
6B82:  CALL   4836
6B86:  MOVFF  01,7F7
6B8A:  MOVFF  01,7FC
6B8E:  CALL   610C
6B92:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
6B96:  MOVLW  05
6B98:  MOVLB  7
6B9A:  MOVWF  xFB
6B9C:  MOVLB  0
6B9E:  CALL   4836
6BA2:  MOVFF  01,7F7
6BA6:  MOVFF  01,7FC
6BAA:  CALL   610C
6BAE:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
6BB2:  MOVLW  06
6BB4:  MOVLB  7
6BB6:  MOVWF  xFB
6BB8:  MOVLB  0
6BBA:  CALL   4836
6BBE:  MOVFF  01,7F7
6BC2:  MOVFF  01,7FC
6BC6:  CALL   610C
6BCA:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
6BCE:  MOVLW  03
6BD0:  MOVLB  7
6BD2:  MOVWF  xFB
6BD4:  MOVLB  0
6BD6:  CALL   4836
6BDA:  MOVFF  01,7F7
6BDE:  MOVFF  01,7FC
6BE2:  CALL   610C
6BE6:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
6BEA:  MOVLW  02
6BEC:  MOVLB  7
6BEE:  MOVWF  xFB
6BF0:  MOVLB  0
6BF2:  CALL   4836
6BF6:  MOVFF  01,7F7
6BFA:  MOVFF  01,7FC
6BFE:  CALL   610C
6C02:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
6C06:  MOVLW  01
6C08:  MOVLB  7
6C0A:  MOVWF  xFB
6C0C:  MOVLB  0
6C0E:  CALL   4836
6C12:  MOVFF  01,7F7
6C16:  MOVFF  01,7FC
6C1A:  CALL   610C
6C1E:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
6C22:  MOVLB  7
6C24:  CLRF   xFB
6C26:  MOVLB  0
6C28:  CALL   4836
6C2C:  MOVFF  01,7F7
6C30:  MOVFF  01,7FC
6C34:  CALL   610C
6C38:  MOVFF  01,103
6C3C:  CLRF   19
6C3E:  BTFSC  FF2.7
6C40:  BSF    19.7
6C42:  BCF    FF2.7
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0,booting=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... int16 count_checking=10; 
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
.................... #define CRYPTO_KEY_SIZE   32 
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[256] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[256] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[10] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int8 galois_mul2(unsigned int8 value) 
.................... { 
....................   signed int8 temp; 
....................   // cast to signed value 
....................   temp = (signed int8) value; 
*
4E38:  MOVFF  7CD,7CE
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
4E3C:  CLRF   00
4E3E:  MOVLB  7
4E40:  BTFSC  xCE.7
4E42:  BSF    00.0
4E44:  MOVFF  00,7CE
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
4E48:  MOVLW  1B
4E4A:  ANDWF  xCE,F
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
4E4C:  BCF    FD8.0
4E4E:  RLCF   xCD,W
4E50:  XORWF  xCE,W
4E52:  MOVWF  01
.................... } 
4E54:  MOVLB  0
4E56:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................   unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................     
....................   // In case of decryption 
....................   if (dir) { 
4E58:  MOVLB  7
4E5A:  MOVF   xC5,F
4E5C:  BTFSC  FD8.2
4E5E:  BRA    502A
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
4E60:  CLRF   xCA
4E62:  MOVF   xCA,W
4E64:  SUBLW  09
4E66:  BTFSS  FD8.0
4E68:  BRA    4FE0
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
4E6A:  MOVFF  7C3,01
4E6E:  MOVFF  7C4,03
4E72:  MOVFF  7C3,7CC
4E76:  MOVFF  7C4,7CD
4E7A:  MOVLW  0D
4E7C:  ADDWF  xC3,W
4E7E:  MOVWF  FE9
4E80:  MOVLW  00
4E82:  ADDWFC xC4,W
4E84:  MOVWF  FEA
4E86:  CLRF   03
4E88:  MOVF   FEF,W
4E8A:  MOVLB  0
4E8C:  CALL   00D0
4E90:  MOVLB  7
4E92:  MOVWF  xCE
4E94:  MOVFF  7C3,FE9
4E98:  MOVFF  7C4,FEA
4E9C:  MOVF   FEF,W
4E9E:  XORWF  xCE,F
4EA0:  CLRF   03
4EA2:  MOVF   xCA,W
4EA4:  MOVLB  0
4EA6:  CALL   02F0
4EAA:  MOVWF  01
4EAC:  MOVLB  7
4EAE:  MOVF   xCE,W
4EB0:  XORWF  01,W
4EB2:  MOVFF  7CD,FEA
4EB6:  MOVFF  7CC,FE9
4EBA:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
4EBC:  MOVLW  01
4EBE:  ADDWF  xC3,W
4EC0:  MOVWF  01
4EC2:  MOVLW  00
4EC4:  ADDWFC xC4,W
4EC6:  MOVWF  03
4EC8:  MOVFF  01,7CC
4ECC:  MOVWF  xCD
4ECE:  MOVLW  0E
4ED0:  ADDWF  xC3,W
4ED2:  MOVWF  FE9
4ED4:  MOVLW  00
4ED6:  ADDWFC xC4,W
4ED8:  MOVWF  FEA
4EDA:  CLRF   03
4EDC:  MOVF   FEF,W
4EDE:  MOVLB  0
4EE0:  CALL   00D0
4EE4:  MOVLB  7
4EE6:  MOVWF  xCE
4EE8:  MOVLW  01
4EEA:  ADDWF  xC3,W
4EEC:  MOVWF  FE9
4EEE:  MOVLW  00
4EF0:  ADDWFC xC4,W
4EF2:  MOVWF  FEA
4EF4:  MOVF   FEF,W
4EF6:  XORWF  xCE,W
4EF8:  MOVFF  7CD,FEA
4EFC:  MOVFF  7CC,FE9
4F00:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
4F02:  MOVLW  02
4F04:  ADDWF  xC3,W
4F06:  MOVWF  01
4F08:  MOVLW  00
4F0A:  ADDWFC xC4,W
4F0C:  MOVWF  03
4F0E:  MOVFF  01,7CC
4F12:  MOVWF  xCD
4F14:  MOVLW  0F
4F16:  ADDWF  xC3,W
4F18:  MOVWF  FE9
4F1A:  MOVLW  00
4F1C:  ADDWFC xC4,W
4F1E:  MOVWF  FEA
4F20:  CLRF   03
4F22:  MOVF   FEF,W
4F24:  MOVLB  0
4F26:  CALL   00D0
4F2A:  MOVLB  7
4F2C:  MOVWF  xCE
4F2E:  MOVLW  02
4F30:  ADDWF  xC3,W
4F32:  MOVWF  FE9
4F34:  MOVLW  00
4F36:  ADDWFC xC4,W
4F38:  MOVWF  FEA
4F3A:  MOVF   FEF,W
4F3C:  XORWF  xCE,W
4F3E:  MOVFF  7CD,FEA
4F42:  MOVFF  7CC,FE9
4F46:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
4F48:  MOVLW  03
4F4A:  ADDWF  xC3,W
4F4C:  MOVWF  01
4F4E:  MOVLW  00
4F50:  ADDWFC xC4,W
4F52:  MOVWF  03
4F54:  MOVFF  01,7CC
4F58:  MOVWF  xCD
4F5A:  MOVLW  0C
4F5C:  ADDWF  xC3,W
4F5E:  MOVWF  FE9
4F60:  MOVLW  00
4F62:  ADDWFC xC4,W
4F64:  MOVWF  FEA
4F66:  CLRF   03
4F68:  MOVF   FEF,W
4F6A:  MOVLB  0
4F6C:  CALL   00D0
4F70:  MOVLB  7
4F72:  MOVWF  xCE
4F74:  MOVLW  03
4F76:  ADDWF  xC3,W
4F78:  MOVWF  FE9
4F7A:  MOVLW  00
4F7C:  ADDWFC xC4,W
4F7E:  MOVWF  FEA
4F80:  MOVF   FEF,W
4F82:  XORWF  xCE,W
4F84:  MOVFF  7CD,FEA
4F88:  MOVFF  7CC,FE9
4F8C:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4F8E:  MOVLW  04
4F90:  MOVWF  xCB
4F92:  MOVF   xCB,W
4F94:  SUBLW  0F
4F96:  BNC   4FDC
....................         key[i] = key[i] ^ key[i-4]; 
4F98:  CLRF   03
4F9A:  MOVF   xCB,W
4F9C:  ADDWF  xC3,W
4F9E:  MOVWF  01
4FA0:  MOVF   xC4,W
4FA2:  ADDWFC 03,F
4FA4:  MOVFF  03,7CD
4FA8:  CLRF   03
4FAA:  MOVF   xCB,W
4FAC:  ADDWF  xC3,W
4FAE:  MOVWF  FE9
4FB0:  MOVF   xC4,W
4FB2:  ADDWFC 03,W
4FB4:  MOVWF  FEA
4FB6:  MOVFF  FEF,7CE
4FBA:  MOVLW  04
4FBC:  SUBWF  xCB,W
4FBE:  CLRF   03
4FC0:  ADDWF  xC3,W
4FC2:  MOVWF  FE9
4FC4:  MOVF   xC4,W
4FC6:  ADDWFC 03,W
4FC8:  MOVWF  FEA
4FCA:  MOVF   FEF,W
4FCC:  XORWF  xCE,W
4FCE:  MOVFF  7CD,FEA
4FD2:  MOVFF  01,FE9
4FD6:  MOVWF  FEF
....................       } 
4FD8:  INCF   xCB,F
4FDA:  BRA    4F92
....................     } 
4FDC:  INCF   xCA,F
4FDE:  BRA    4E62
....................      
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++){ 
4FE0:  CLRF   xCB
4FE2:  MOVF   xCB,W
4FE4:  SUBLW  0F
4FE6:  BNC   502A
....................       state[i]=state[i] ^ key[i]; 
4FE8:  CLRF   03
4FEA:  MOVF   xCB,W
4FEC:  ADDWF  xC1,W
4FEE:  MOVWF  01
4FF0:  MOVF   xC2,W
4FF2:  ADDWFC 03,F
4FF4:  MOVFF  03,7CD
4FF8:  CLRF   03
4FFA:  MOVF   xCB,W
4FFC:  ADDWF  xC1,W
4FFE:  MOVWF  FE9
5000:  MOVF   xC2,W
5002:  ADDWFC 03,W
5004:  MOVWF  FEA
5006:  MOVFF  FEF,7CE
500A:  CLRF   03
500C:  MOVF   xCB,W
500E:  ADDWF  xC3,W
5010:  MOVWF  FE9
5012:  MOVF   xC4,W
5014:  ADDWFC 03,W
5016:  MOVWF  FEA
5018:  MOVF   FEF,W
501A:  XORWF  xCE,W
501C:  MOVFF  7CD,FEA
5020:  MOVFF  01,FE9
5024:  MOVWF  FEF
....................     } 
5026:  INCF   xCB,F
5028:  BRA    4FE2
....................   } 
....................    
....................   // main loop 
....................   for (round = 0; round < 10; round++){ 
502A:  CLRF   xCA
502C:  MOVF   xCA,W
502E:  SUBLW  09
5030:  BTFSS  FD8.0
5032:  GOTO   5A5C
....................     if (dir){ 
5036:  MOVF   xC5,F
5038:  BTFSC  FD8.2
503A:  BRA    51B4
....................       //Inverse key schedule 
....................       for (i=15; i>3; --i) { 
503C:  MOVLW  0F
503E:  MOVWF  xCB
5040:  MOVF   xCB,W
5042:  SUBLW  03
5044:  BC    508A
.................... 	key[i] = key[i] ^ key[i-4]; 
5046:  CLRF   03
5048:  MOVF   xCB,W
504A:  ADDWF  xC3,W
504C:  MOVWF  01
504E:  MOVF   xC4,W
5050:  ADDWFC 03,F
5052:  MOVFF  03,7CD
5056:  CLRF   03
5058:  MOVF   xCB,W
505A:  ADDWF  xC3,W
505C:  MOVWF  FE9
505E:  MOVF   xC4,W
5060:  ADDWFC 03,W
5062:  MOVWF  FEA
5064:  MOVFF  FEF,7CE
5068:  MOVLW  04
506A:  SUBWF  xCB,W
506C:  CLRF   03
506E:  ADDWF  xC3,W
5070:  MOVWF  FE9
5072:  MOVF   xC4,W
5074:  ADDWFC 03,W
5076:  MOVWF  FEA
5078:  MOVF   FEF,W
507A:  XORWF  xCE,W
507C:  MOVFF  7CD,FEA
5080:  MOVFF  01,FE9
5084:  MOVWF  FEF
....................       }   
5086:  DECF   xCB,F
5088:  BRA    5040
....................       key[0] = sbox[key[13]]^key[0]^Rcon[9-round]; 
508A:  MOVFF  7C3,01
508E:  MOVFF  7C4,03
5092:  MOVFF  7C3,7CC
5096:  MOVFF  7C4,7CD
509A:  MOVLW  0D
509C:  ADDWF  xC3,W
509E:  MOVWF  FE9
50A0:  MOVLW  00
50A2:  ADDWFC xC4,W
50A4:  MOVWF  FEA
50A6:  CLRF   03
50A8:  MOVF   FEF,W
50AA:  MOVLB  0
50AC:  CALL   00D0
50B0:  MOVLB  7
50B2:  MOVWF  xCE
50B4:  MOVFF  7C3,FE9
50B8:  MOVFF  7C4,FEA
50BC:  MOVF   FEF,W
50BE:  XORWF  xCE,F
50C0:  MOVLW  09
50C2:  BSF    FD8.0
50C4:  SUBFWB xCA,W
50C6:  CLRF   03
50C8:  MOVLB  0
50CA:  CALL   02F0
50CE:  MOVWF  01
50D0:  MOVLB  7
50D2:  MOVF   xCE,W
50D4:  XORWF  01,W
50D6:  MOVFF  7CD,FEA
50DA:  MOVFF  7CC,FE9
50DE:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
50E0:  MOVLW  01
50E2:  ADDWF  xC3,W
50E4:  MOVWF  01
50E6:  MOVLW  00
50E8:  ADDWFC xC4,W
50EA:  MOVWF  03
50EC:  MOVFF  01,7CC
50F0:  MOVWF  xCD
50F2:  MOVLW  0E
50F4:  ADDWF  xC3,W
50F6:  MOVWF  FE9
50F8:  MOVLW  00
50FA:  ADDWFC xC4,W
50FC:  MOVWF  FEA
50FE:  CLRF   03
5100:  MOVF   FEF,W
5102:  MOVLB  0
5104:  CALL   00D0
5108:  MOVLB  7
510A:  MOVWF  xCE
510C:  MOVLW  01
510E:  ADDWF  xC3,W
5110:  MOVWF  FE9
5112:  MOVLW  00
5114:  ADDWFC xC4,W
5116:  MOVWF  FEA
5118:  MOVF   FEF,W
511A:  XORWF  xCE,W
511C:  MOVFF  7CD,FEA
5120:  MOVFF  7CC,FE9
5124:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
5126:  MOVLW  02
5128:  ADDWF  xC3,W
512A:  MOVWF  01
512C:  MOVLW  00
512E:  ADDWFC xC4,W
5130:  MOVWF  03
5132:  MOVFF  01,7CC
5136:  MOVWF  xCD
5138:  MOVLW  0F
513A:  ADDWF  xC3,W
513C:  MOVWF  FE9
513E:  MOVLW  00
5140:  ADDWFC xC4,W
5142:  MOVWF  FEA
5144:  CLRF   03
5146:  MOVF   FEF,W
5148:  MOVLB  0
514A:  CALL   00D0
514E:  MOVLB  7
5150:  MOVWF  xCE
5152:  MOVLW  02
5154:  ADDWF  xC3,W
5156:  MOVWF  FE9
5158:  MOVLW  00
515A:  ADDWFC xC4,W
515C:  MOVWF  FEA
515E:  MOVF   FEF,W
5160:  XORWF  xCE,W
5162:  MOVFF  7CD,FEA
5166:  MOVFF  7CC,FE9
516A:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3];  
516C:  MOVLW  03
516E:  ADDWF  xC3,W
5170:  MOVWF  01
5172:  MOVLW  00
5174:  ADDWFC xC4,W
5176:  MOVWF  03
5178:  MOVFF  01,7CC
517C:  MOVWF  xCD
517E:  MOVLW  0C
5180:  ADDWF  xC3,W
5182:  MOVWF  FE9
5184:  MOVLW  00
5186:  ADDWFC xC4,W
5188:  MOVWF  FEA
518A:  CLRF   03
518C:  MOVF   FEF,W
518E:  MOVLB  0
5190:  CALL   00D0
5194:  MOVLB  7
5196:  MOVWF  xCE
5198:  MOVLW  03
519A:  ADDWF  xC3,W
519C:  MOVWF  FE9
519E:  MOVLW  00
51A0:  ADDWFC xC4,W
51A2:  MOVWF  FEA
51A4:  MOVF   FEF,W
51A6:  XORWF  xCE,W
51A8:  MOVFF  7CD,FEA
51AC:  MOVFF  7CC,FE9
51B0:  MOVWF  FEF
....................     } else { 
51B2:  BRA    53CC
....................       for (i = 0; i <16; i++){ 
51B4:  CLRF   xCB
51B6:  MOVF   xCB,W
51B8:  SUBLW  0F
51BA:  BNC   520C
....................         // with shiftrow i+5 mod 16 
.................... 	state[i]=sbox[state[i] ^ key[i]]; 
51BC:  CLRF   03
51BE:  MOVF   xCB,W
51C0:  ADDWF  xC1,W
51C2:  MOVWF  01
51C4:  MOVF   xC2,W
51C6:  ADDWFC 03,F
51C8:  MOVFF  01,7CC
51CC:  MOVFF  03,7CD
51D0:  CLRF   03
51D2:  MOVF   xCB,W
51D4:  ADDWF  xC1,W
51D6:  MOVWF  FE9
51D8:  MOVF   xC2,W
51DA:  ADDWFC 03,W
51DC:  MOVWF  FEA
51DE:  MOVFF  FEF,7CE
51E2:  CLRF   03
51E4:  MOVF   xCB,W
51E6:  ADDWF  xC3,W
51E8:  MOVWF  FE9
51EA:  MOVF   xC4,W
51EC:  ADDWFC 03,W
51EE:  MOVWF  FEA
51F0:  MOVF   FEF,W
51F2:  XORWF  xCE,W
51F4:  CLRF   03
51F6:  MOVLB  0
51F8:  CALL   00D0
51FC:  MOVFF  7CD,FEA
5200:  MOVFF  7CC,FE9
5204:  MOVWF  FEF
....................       } 
5206:  MOVLB  7
5208:  INCF   xCB,F
520A:  BRA    51B6
....................       //shift rows 
....................       buf1 = state[1]; 
520C:  MOVLW  01
520E:  ADDWF  xC1,W
5210:  MOVWF  FE9
5212:  MOVLW  00
5214:  ADDWFC xC2,W
5216:  MOVWF  FEA
5218:  MOVFF  FEF,7C6
....................       state[1] = state[5]; 
521C:  MOVLW  01
521E:  ADDWF  xC1,W
5220:  MOVWF  01
5222:  MOVLW  00
5224:  ADDWFC xC2,W
5226:  MOVWF  03
5228:  MOVLW  05
522A:  ADDWF  xC1,W
522C:  MOVWF  FE9
522E:  MOVLW  00
5230:  ADDWFC xC2,W
5232:  MOVWF  FEA
5234:  MOVFF  FEF,7CE
5238:  MOVFF  03,FEA
523C:  MOVFF  01,FE9
5240:  MOVFF  7CE,FEF
....................       state[5] = state[9]; 
5244:  MOVLW  05
5246:  ADDWF  xC1,W
5248:  MOVWF  01
524A:  MOVLW  00
524C:  ADDWFC xC2,W
524E:  MOVWF  03
5250:  MOVLW  09
5252:  ADDWF  xC1,W
5254:  MOVWF  FE9
5256:  MOVLW  00
5258:  ADDWFC xC2,W
525A:  MOVWF  FEA
525C:  MOVFF  FEF,7CE
5260:  MOVFF  03,FEA
5264:  MOVFF  01,FE9
5268:  MOVFF  7CE,FEF
....................       state[9] = state[13]; 
526C:  MOVLW  09
526E:  ADDWF  xC1,W
5270:  MOVWF  01
5272:  MOVLW  00
5274:  ADDWFC xC2,W
5276:  MOVWF  03
5278:  MOVLW  0D
527A:  ADDWF  xC1,W
527C:  MOVWF  FE9
527E:  MOVLW  00
5280:  ADDWFC xC2,W
5282:  MOVWF  FEA
5284:  MOVFF  FEF,7CE
5288:  MOVFF  03,FEA
528C:  MOVFF  01,FE9
5290:  MOVFF  7CE,FEF
....................       state[13] = buf1; 
5294:  MOVLW  0D
5296:  ADDWF  xC1,W
5298:  MOVWF  FE9
529A:  MOVLW  00
529C:  ADDWFC xC2,W
529E:  MOVWF  FEA
52A0:  MOVFF  7C6,FEF
....................  
....................       buf1 = state[2]; 
52A4:  MOVLW  02
52A6:  ADDWF  xC1,W
52A8:  MOVWF  FE9
52AA:  MOVLW  00
52AC:  ADDWFC xC2,W
52AE:  MOVWF  FEA
52B0:  MOVFF  FEF,7C6
....................       buf2 = state[6]; 
52B4:  MOVLW  06
52B6:  ADDWF  xC1,W
52B8:  MOVWF  FE9
52BA:  MOVLW  00
52BC:  ADDWFC xC2,W
52BE:  MOVWF  FEA
52C0:  MOVFF  FEF,7C7
....................       state[2] = state[10]; 
52C4:  MOVLW  02
52C6:  ADDWF  xC1,W
52C8:  MOVWF  01
52CA:  MOVLW  00
52CC:  ADDWFC xC2,W
52CE:  MOVWF  03
52D0:  MOVLW  0A
52D2:  ADDWF  xC1,W
52D4:  MOVWF  FE9
52D6:  MOVLW  00
52D8:  ADDWFC xC2,W
52DA:  MOVWF  FEA
52DC:  MOVFF  FEF,7CE
52E0:  MOVFF  03,FEA
52E4:  MOVFF  01,FE9
52E8:  MOVFF  7CE,FEF
....................       state[6] = state[14]; 
52EC:  MOVLW  06
52EE:  ADDWF  xC1,W
52F0:  MOVWF  01
52F2:  MOVLW  00
52F4:  ADDWFC xC2,W
52F6:  MOVWF  03
52F8:  MOVLW  0E
52FA:  ADDWF  xC1,W
52FC:  MOVWF  FE9
52FE:  MOVLW  00
5300:  ADDWFC xC2,W
5302:  MOVWF  FEA
5304:  MOVFF  FEF,7CE
5308:  MOVFF  03,FEA
530C:  MOVFF  01,FE9
5310:  MOVFF  7CE,FEF
....................       state[10] = buf1; 
5314:  MOVLW  0A
5316:  ADDWF  xC1,W
5318:  MOVWF  FE9
531A:  MOVLW  00
531C:  ADDWFC xC2,W
531E:  MOVWF  FEA
5320:  MOVFF  7C6,FEF
....................       state[14] = buf2; 
5324:  MOVLW  0E
5326:  ADDWF  xC1,W
5328:  MOVWF  FE9
532A:  MOVLW  00
532C:  ADDWFC xC2,W
532E:  MOVWF  FEA
5330:  MOVFF  7C7,FEF
....................  
....................       buf1 = state[15]; 
5334:  MOVLW  0F
5336:  ADDWF  xC1,W
5338:  MOVWF  FE9
533A:  MOVLW  00
533C:  ADDWFC xC2,W
533E:  MOVWF  FEA
5340:  MOVFF  FEF,7C6
....................       state[15] = state[11]; 
5344:  MOVLW  0F
5346:  ADDWF  xC1,W
5348:  MOVWF  01
534A:  MOVLW  00
534C:  ADDWFC xC2,W
534E:  MOVWF  03
5350:  MOVLW  0B
5352:  ADDWF  xC1,W
5354:  MOVWF  FE9
5356:  MOVLW  00
5358:  ADDWFC xC2,W
535A:  MOVWF  FEA
535C:  MOVFF  FEF,7CE
5360:  MOVFF  03,FEA
5364:  MOVFF  01,FE9
5368:  MOVFF  7CE,FEF
....................       state[11] = state[7]; 
536C:  MOVLW  0B
536E:  ADDWF  xC1,W
5370:  MOVWF  01
5372:  MOVLW  00
5374:  ADDWFC xC2,W
5376:  MOVWF  03
5378:  MOVLW  07
537A:  ADDWF  xC1,W
537C:  MOVWF  FE9
537E:  MOVLW  00
5380:  ADDWFC xC2,W
5382:  MOVWF  FEA
5384:  MOVFF  FEF,7CE
5388:  MOVFF  03,FEA
538C:  MOVFF  01,FE9
5390:  MOVFF  7CE,FEF
....................       state[7] = state[3]; 
5394:  MOVLW  07
5396:  ADDWF  xC1,W
5398:  MOVWF  01
539A:  MOVLW  00
539C:  ADDWFC xC2,W
539E:  MOVWF  03
53A0:  MOVLW  03
53A2:  ADDWF  xC1,W
53A4:  MOVWF  FE9
53A6:  MOVLW  00
53A8:  ADDWFC xC2,W
53AA:  MOVWF  FEA
53AC:  MOVFF  FEF,7CE
53B0:  MOVFF  03,FEA
53B4:  MOVFF  01,FE9
53B8:  MOVFF  7CE,FEF
....................       state[3] = buf1; 
53BC:  MOVLW  03
53BE:  ADDWF  xC1,W
53C0:  MOVWF  FE9
53C2:  MOVLW  00
53C4:  ADDWFC xC2,W
53C6:  MOVWF  FEA
53C8:  MOVFF  7C6,FEF
....................     } 
....................     //mixcol - inv mix 
....................     if ((round > 0 && dir) || (round < 9 && !dir)) { 
53CC:  MOVF   xCA,F
53CE:  BZ    53D4
53D0:  MOVF   xC5,F
53D2:  BNZ   53E2
53D4:  MOVF   xCA,W
53D6:  SUBLW  08
53D8:  BTFSS  FD8.0
53DA:  BRA    56C4
53DC:  MOVF   xC5,F
53DE:  BTFSS  FD8.2
53E0:  BRA    56C4
....................       for (i=0; i <4; i++){ 
53E2:  CLRF   xCB
53E4:  MOVF   xCB,W
53E6:  SUBLW  03
53E8:  BTFSS  FD8.0
53EA:  BRA    56C4
....................         buf4 = (i << 2); 
53EC:  RLCF   xCB,W
53EE:  MOVWF  xC9
53F0:  RLCF   xC9,F
53F2:  MOVLW  FC
53F4:  ANDWF  xC9,F
....................         if (dir){ 
53F6:  MOVF   xC5,F
53F8:  BZ    54CE
....................           // precompute for decryption 
....................           buf1 = galois_mul2(galois_mul2(state[buf4]^state[buf4+2])); 
53FA:  CLRF   03
53FC:  MOVF   xC9,W
53FE:  ADDWF  xC1,W
5400:  MOVWF  FE9
5402:  MOVF   xC2,W
5404:  ADDWFC 03,W
5406:  MOVWF  FEA
5408:  MOVFF  FEF,7CC
540C:  MOVLW  02
540E:  ADDWF  xC9,W
5410:  CLRF   03
5412:  ADDWF  xC1,W
5414:  MOVWF  FE9
5416:  MOVF   xC2,W
5418:  ADDWFC 03,W
541A:  MOVWF  FEA
541C:  MOVF   FEF,W
541E:  XORWF  xCC,F
5420:  MOVFF  7CC,7CD
5424:  MOVLB  0
5426:  RCALL  4E38
5428:  MOVFF  01,7CC
542C:  MOVFF  01,7CD
5430:  RCALL  4E38
5432:  MOVFF  01,7C6
....................           buf2 = galois_mul2(galois_mul2(state[buf4+1]^state[buf4+3])); 
5436:  MOVLW  01
5438:  MOVLB  7
543A:  ADDWF  xC9,W
543C:  CLRF   03
543E:  ADDWF  xC1,W
5440:  MOVWF  FE9
5442:  MOVF   xC2,W
5444:  ADDWFC 03,W
5446:  MOVWF  FEA
5448:  MOVFF  FEF,7CC
544C:  MOVLW  03
544E:  ADDWF  xC9,W
5450:  CLRF   03
5452:  ADDWF  xC1,W
5454:  MOVWF  FE9
5456:  MOVF   xC2,W
5458:  ADDWFC 03,W
545A:  MOVWF  FEA
545C:  MOVF   FEF,W
545E:  XORWF  xCC,F
5460:  MOVFF  7CC,7CD
5464:  MOVLB  0
5466:  RCALL  4E38
5468:  MOVFF  01,7CC
546C:  MOVFF  01,7CD
5470:  RCALL  4E38
5472:  MOVFF  01,7C7
....................           state[buf4] ^= buf1; state[buf4+1] ^= buf2; state[buf4+2] ^= buf1; state[buf4+3] ^= buf2;  
5476:  CLRF   03
5478:  MOVLB  7
547A:  MOVF   xC9,W
547C:  ADDWF  xC1,W
547E:  MOVWF  FE9
5480:  MOVF   xC2,W
5482:  ADDWFC 03,W
5484:  MOVWF  FEA
5486:  MOVF   FEF,W
5488:  XORWF  xC6,W
548A:  MOVWF  FEF
548C:  MOVLW  01
548E:  ADDWF  xC9,W
5490:  CLRF   03
5492:  ADDWF  xC1,W
5494:  MOVWF  FE9
5496:  MOVF   xC2,W
5498:  ADDWFC 03,W
549A:  MOVWF  FEA
549C:  MOVF   FEF,W
549E:  XORWF  xC7,W
54A0:  MOVWF  FEF
54A2:  MOVLW  02
54A4:  ADDWF  xC9,W
54A6:  CLRF   03
54A8:  ADDWF  xC1,W
54AA:  MOVWF  FE9
54AC:  MOVF   xC2,W
54AE:  ADDWFC 03,W
54B0:  MOVWF  FEA
54B2:  MOVF   FEF,W
54B4:  XORWF  xC6,W
54B6:  MOVWF  FEF
54B8:  MOVLW  03
54BA:  ADDWF  xC9,W
54BC:  CLRF   03
54BE:  ADDWF  xC1,W
54C0:  MOVWF  FE9
54C2:  MOVF   xC2,W
54C4:  ADDWFC 03,W
54C6:  MOVWF  FEA
54C8:  MOVF   FEF,W
54CA:  XORWF  xC7,W
54CC:  MOVWF  FEF
....................         } 
....................         // in all cases 
....................         buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
54CE:  CLRF   03
54D0:  MOVF   xC9,W
54D2:  ADDWF  xC1,W
54D4:  MOVWF  FE9
54D6:  MOVF   xC2,W
54D8:  ADDWFC 03,W
54DA:  MOVWF  FEA
54DC:  MOVFF  FEF,7CC
54E0:  MOVLW  01
54E2:  ADDWF  xC9,W
54E4:  CLRF   03
54E6:  ADDWF  xC1,W
54E8:  MOVWF  FE9
54EA:  MOVF   xC2,W
54EC:  ADDWFC 03,W
54EE:  MOVWF  FEA
54F0:  MOVF   FEF,W
54F2:  XORWF  xCC,F
54F4:  MOVLW  02
54F6:  ADDWF  xC9,W
54F8:  CLRF   03
54FA:  ADDWF  xC1,W
54FC:  MOVWF  FE9
54FE:  MOVF   xC2,W
5500:  ADDWFC 03,W
5502:  MOVWF  FEA
5504:  MOVF   FEF,W
5506:  XORWF  xCC,F
5508:  MOVLW  03
550A:  ADDWF  xC9,W
550C:  CLRF   03
550E:  ADDWF  xC1,W
5510:  MOVWF  FE9
5512:  MOVF   xC2,W
5514:  ADDWFC 03,W
5516:  MOVWF  FEA
5518:  MOVF   FEF,W
551A:  XORWF  xCC,W
551C:  MOVWF  xC6
....................         buf2 = state[buf4]; 
551E:  CLRF   03
5520:  MOVF   xC9,W
5522:  ADDWF  xC1,W
5524:  MOVWF  FE9
5526:  MOVF   xC2,W
5528:  ADDWFC 03,W
552A:  MOVWF  FEA
552C:  MOVFF  FEF,7C7
....................         buf3 = state[buf4]^state[buf4+1]; buf3=galois_mul2(buf3); state[buf4] = state[buf4] ^ buf3 ^ buf1; 
5530:  CLRF   03
5532:  MOVF   xC9,W
5534:  ADDWF  xC1,W
5536:  MOVWF  FE9
5538:  MOVF   xC2,W
553A:  ADDWFC 03,W
553C:  MOVWF  FEA
553E:  MOVFF  FEF,7CC
5542:  MOVLW  01
5544:  ADDWF  xC9,W
5546:  CLRF   03
5548:  ADDWF  xC1,W
554A:  MOVWF  FE9
554C:  MOVF   xC2,W
554E:  ADDWFC 03,W
5550:  MOVWF  FEA
5552:  MOVF   FEF,W
5554:  XORWF  xCC,W
5556:  MOVWF  xC8
5558:  MOVFF  7C8,7CD
555C:  MOVLB  0
555E:  RCALL  4E38
5560:  MOVFF  01,7C8
5564:  CLRF   03
5566:  MOVLB  7
5568:  MOVF   xC9,W
556A:  ADDWF  xC1,W
556C:  MOVWF  01
556E:  MOVF   xC2,W
5570:  ADDWFC 03,F
5572:  MOVFF  03,7CD
5576:  CLRF   03
5578:  MOVF   xC9,W
557A:  ADDWF  xC1,W
557C:  MOVWF  FE9
557E:  MOVF   xC2,W
5580:  ADDWFC 03,W
5582:  MOVWF  FEA
5584:  MOVF   FEF,W
5586:  XORWF  xC8,W
5588:  XORWF  xC6,W
558A:  MOVFF  7CD,FEA
558E:  MOVFF  01,FE9
5592:  MOVWF  FEF
....................         buf3 = state[buf4+1]^state[buf4+2]; buf3=galois_mul2(buf3); state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
5594:  MOVLW  01
5596:  ADDWF  xC9,W
5598:  CLRF   03
559A:  ADDWF  xC1,W
559C:  MOVWF  FE9
559E:  MOVF   xC2,W
55A0:  ADDWFC 03,W
55A2:  MOVWF  FEA
55A4:  MOVFF  FEF,7CC
55A8:  MOVLW  02
55AA:  ADDWF  xC9,W
55AC:  CLRF   03
55AE:  ADDWF  xC1,W
55B0:  MOVWF  FE9
55B2:  MOVF   xC2,W
55B4:  ADDWFC 03,W
55B6:  MOVWF  FEA
55B8:  MOVF   FEF,W
55BA:  XORWF  xCC,W
55BC:  MOVWF  xC8
55BE:  MOVFF  7C8,7CD
55C2:  MOVLB  0
55C4:  RCALL  4E38
55C6:  MOVFF  01,7C8
55CA:  MOVLW  01
55CC:  MOVLB  7
55CE:  ADDWF  xC9,W
55D0:  CLRF   03
55D2:  ADDWF  xC1,W
55D4:  MOVWF  01
55D6:  MOVF   xC2,W
55D8:  ADDWFC 03,F
55DA:  MOVFF  03,7CD
55DE:  MOVLW  01
55E0:  ADDWF  xC9,W
55E2:  CLRF   03
55E4:  ADDWF  xC1,W
55E6:  MOVWF  FE9
55E8:  MOVF   xC2,W
55EA:  ADDWFC 03,W
55EC:  MOVWF  FEA
55EE:  MOVF   FEF,W
55F0:  XORWF  xC8,W
55F2:  XORWF  xC6,W
55F4:  MOVFF  7CD,FEA
55F8:  MOVFF  01,FE9
55FC:  MOVWF  FEF
....................         buf3 = state[buf4+2]^state[buf4+3]; buf3=galois_mul2(buf3); state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
55FE:  MOVLW  02
5600:  ADDWF  xC9,W
5602:  CLRF   03
5604:  ADDWF  xC1,W
5606:  MOVWF  FE9
5608:  MOVF   xC2,W
560A:  ADDWFC 03,W
560C:  MOVWF  FEA
560E:  MOVFF  FEF,7CC
5612:  MOVLW  03
5614:  ADDWF  xC9,W
5616:  CLRF   03
5618:  ADDWF  xC1,W
561A:  MOVWF  FE9
561C:  MOVF   xC2,W
561E:  ADDWFC 03,W
5620:  MOVWF  FEA
5622:  MOVF   FEF,W
5624:  XORWF  xCC,W
5626:  MOVWF  xC8
5628:  MOVFF  7C8,7CD
562C:  MOVLB  0
562E:  RCALL  4E38
5630:  MOVFF  01,7C8
5634:  MOVLW  02
5636:  MOVLB  7
5638:  ADDWF  xC9,W
563A:  CLRF   03
563C:  ADDWF  xC1,W
563E:  MOVWF  01
5640:  MOVF   xC2,W
5642:  ADDWFC 03,F
5644:  MOVFF  03,7CD
5648:  MOVLW  02
564A:  ADDWF  xC9,W
564C:  CLRF   03
564E:  ADDWF  xC1,W
5650:  MOVWF  FE9
5652:  MOVF   xC2,W
5654:  ADDWFC 03,W
5656:  MOVWF  FEA
5658:  MOVF   FEF,W
565A:  XORWF  xC8,W
565C:  XORWF  xC6,W
565E:  MOVFF  7CD,FEA
5662:  MOVFF  01,FE9
5666:  MOVWF  FEF
....................         buf3 = state[buf4+3]^buf2;     buf3=galois_mul2(buf3); state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1; 
5668:  MOVLW  03
566A:  ADDWF  xC9,W
566C:  CLRF   03
566E:  ADDWF  xC1,W
5670:  MOVWF  FE9
5672:  MOVF   xC2,W
5674:  ADDWFC 03,W
5676:  MOVWF  FEA
5678:  MOVF   FEF,W
567A:  XORWF  xC7,W
567C:  MOVWF  xC8
567E:  MOVFF  7C8,7CD
5682:  MOVLB  0
5684:  CALL   4E38
5688:  MOVFF  01,7C8
568C:  MOVLW  03
568E:  MOVLB  7
5690:  ADDWF  xC9,W
5692:  CLRF   03
5694:  ADDWF  xC1,W
5696:  MOVWF  01
5698:  MOVF   xC2,W
569A:  ADDWFC 03,F
569C:  MOVFF  03,7CD
56A0:  MOVLW  03
56A2:  ADDWF  xC9,W
56A4:  CLRF   03
56A6:  ADDWF  xC1,W
56A8:  MOVWF  FE9
56AA:  MOVF   xC2,W
56AC:  ADDWFC 03,W
56AE:  MOVWF  FEA
56B0:  MOVF   FEF,W
56B2:  XORWF  xC8,W
56B4:  XORWF  xC6,W
56B6:  MOVFF  7CD,FEA
56BA:  MOVFF  01,FE9
56BE:  MOVWF  FEF
....................       } 
56C0:  INCF   xCB,F
56C2:  BRA    53E4
....................     } 
....................      
....................     if (dir) { 
56C4:  MOVF   xC5,F
56C6:  BTFSC  FD8.2
56C8:  BRA    58E4
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
56CA:  MOVLW  0D
56CC:  ADDWF  xC1,W
56CE:  MOVWF  FE9
56D0:  MOVLW  00
56D2:  ADDWFC xC2,W
56D4:  MOVWF  FEA
56D6:  MOVFF  FEF,7C6
....................       state[13] = state[9]; 
56DA:  MOVLW  0D
56DC:  ADDWF  xC1,W
56DE:  MOVWF  01
56E0:  MOVLW  00
56E2:  ADDWFC xC2,W
56E4:  MOVWF  03
56E6:  MOVLW  09
56E8:  ADDWF  xC1,W
56EA:  MOVWF  FE9
56EC:  MOVLW  00
56EE:  ADDWFC xC2,W
56F0:  MOVWF  FEA
56F2:  MOVFF  FEF,7CE
56F6:  MOVFF  03,FEA
56FA:  MOVFF  01,FE9
56FE:  MOVFF  7CE,FEF
....................       state[9] = state[5]; 
5702:  MOVLW  09
5704:  ADDWF  xC1,W
5706:  MOVWF  01
5708:  MOVLW  00
570A:  ADDWFC xC2,W
570C:  MOVWF  03
570E:  MOVLW  05
5710:  ADDWF  xC1,W
5712:  MOVWF  FE9
5714:  MOVLW  00
5716:  ADDWFC xC2,W
5718:  MOVWF  FEA
571A:  MOVFF  FEF,7CE
571E:  MOVFF  03,FEA
5722:  MOVFF  01,FE9
5726:  MOVFF  7CE,FEF
....................       state[5] = state[1]; 
572A:  MOVLW  05
572C:  ADDWF  xC1,W
572E:  MOVWF  01
5730:  MOVLW  00
5732:  ADDWFC xC2,W
5734:  MOVWF  03
5736:  MOVLW  01
5738:  ADDWF  xC1,W
573A:  MOVWF  FE9
573C:  MOVLW  00
573E:  ADDWFC xC2,W
5740:  MOVWF  FEA
5742:  MOVFF  FEF,7CE
5746:  MOVFF  03,FEA
574A:  MOVFF  01,FE9
574E:  MOVFF  7CE,FEF
....................       state[1] = buf1; 
5752:  MOVLW  01
5754:  ADDWF  xC1,W
5756:  MOVWF  FE9
5758:  MOVLW  00
575A:  ADDWFC xC2,W
575C:  MOVWF  FEA
575E:  MOVFF  7C6,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
5762:  MOVLW  0A
5764:  ADDWF  xC1,W
5766:  MOVWF  FE9
5768:  MOVLW  00
576A:  ADDWFC xC2,W
576C:  MOVWF  FEA
576E:  MOVFF  FEF,7C6
....................       buf2 = state[14]; 
5772:  MOVLW  0E
5774:  ADDWF  xC1,W
5776:  MOVWF  FE9
5778:  MOVLW  00
577A:  ADDWFC xC2,W
577C:  MOVWF  FEA
577E:  MOVFF  FEF,7C7
....................       state[10] = state[2]; 
5782:  MOVLW  0A
5784:  ADDWF  xC1,W
5786:  MOVWF  01
5788:  MOVLW  00
578A:  ADDWFC xC2,W
578C:  MOVWF  03
578E:  MOVLW  02
5790:  ADDWF  xC1,W
5792:  MOVWF  FE9
5794:  MOVLW  00
5796:  ADDWFC xC2,W
5798:  MOVWF  FEA
579A:  MOVFF  FEF,7CE
579E:  MOVFF  03,FEA
57A2:  MOVFF  01,FE9
57A6:  MOVFF  7CE,FEF
....................       state[14] = state[6]; 
57AA:  MOVLW  0E
57AC:  ADDWF  xC1,W
57AE:  MOVWF  01
57B0:  MOVLW  00
57B2:  ADDWFC xC2,W
57B4:  MOVWF  03
57B6:  MOVLW  06
57B8:  ADDWF  xC1,W
57BA:  MOVWF  FE9
57BC:  MOVLW  00
57BE:  ADDWFC xC2,W
57C0:  MOVWF  FEA
57C2:  MOVFF  FEF,7CE
57C6:  MOVFF  03,FEA
57CA:  MOVFF  01,FE9
57CE:  MOVFF  7CE,FEF
....................       state[2] = buf1; 
57D2:  MOVLW  02
57D4:  ADDWF  xC1,W
57D6:  MOVWF  FE9
57D8:  MOVLW  00
57DA:  ADDWFC xC2,W
57DC:  MOVWF  FEA
57DE:  MOVFF  7C6,FEF
....................       state[6] = buf2; 
57E2:  MOVLW  06
57E4:  ADDWF  xC1,W
57E6:  MOVWF  FE9
57E8:  MOVLW  00
57EA:  ADDWFC xC2,W
57EC:  MOVWF  FEA
57EE:  MOVFF  7C7,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
57F2:  MOVLW  03
57F4:  ADDWF  xC1,W
57F6:  MOVWF  FE9
57F8:  MOVLW  00
57FA:  ADDWFC xC2,W
57FC:  MOVWF  FEA
57FE:  MOVFF  FEF,7C6
....................       state[3] = state[7]; 
5802:  MOVLW  03
5804:  ADDWF  xC1,W
5806:  MOVWF  01
5808:  MOVLW  00
580A:  ADDWFC xC2,W
580C:  MOVWF  03
580E:  MOVLW  07
5810:  ADDWF  xC1,W
5812:  MOVWF  FE9
5814:  MOVLW  00
5816:  ADDWFC xC2,W
5818:  MOVWF  FEA
581A:  MOVFF  FEF,7CE
581E:  MOVFF  03,FEA
5822:  MOVFF  01,FE9
5826:  MOVFF  7CE,FEF
....................       state[7] = state[11]; 
582A:  MOVLW  07
582C:  ADDWF  xC1,W
582E:  MOVWF  01
5830:  MOVLW  00
5832:  ADDWFC xC2,W
5834:  MOVWF  03
5836:  MOVLW  0B
5838:  ADDWF  xC1,W
583A:  MOVWF  FE9
583C:  MOVLW  00
583E:  ADDWFC xC2,W
5840:  MOVWF  FEA
5842:  MOVFF  FEF,7CE
5846:  MOVFF  03,FEA
584A:  MOVFF  01,FE9
584E:  MOVFF  7CE,FEF
....................       state[11] = state[15]; 
5852:  MOVLW  0B
5854:  ADDWF  xC1,W
5856:  MOVWF  01
5858:  MOVLW  00
585A:  ADDWFC xC2,W
585C:  MOVWF  03
585E:  MOVLW  0F
5860:  ADDWF  xC1,W
5862:  MOVWF  FE9
5864:  MOVLW  00
5866:  ADDWFC xC2,W
5868:  MOVWF  FEA
586A:  MOVFF  FEF,7CE
586E:  MOVFF  03,FEA
5872:  MOVFF  01,FE9
5876:  MOVFF  7CE,FEF
....................       state[15] = buf1;          
587A:  MOVLW  0F
587C:  ADDWF  xC1,W
587E:  MOVWF  FE9
5880:  MOVLW  00
5882:  ADDWFC xC2,W
5884:  MOVWF  FEA
5886:  MOVFF  7C6,FEF
....................             
....................       for (i = 0; i <16; i++){ 
588A:  CLRF   xCB
588C:  MOVF   xCB,W
588E:  SUBLW  0F
5890:  BNC   58E2
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
5892:  CLRF   03
5894:  MOVF   xCB,W
5896:  ADDWF  xC1,W
5898:  MOVWF  01
589A:  MOVF   xC2,W
589C:  ADDWFC 03,F
589E:  MOVFF  01,7CC
58A2:  MOVFF  03,7CD
58A6:  CLRF   03
58A8:  MOVF   xCB,W
58AA:  ADDWF  xC1,W
58AC:  MOVWF  FE9
58AE:  MOVF   xC2,W
58B0:  ADDWFC 03,W
58B2:  MOVWF  FEA
58B4:  CLRF   03
58B6:  MOVF   FEF,W
58B8:  MOVLB  0
58BA:  CALL   01E0
58BE:  MOVLB  7
58C0:  MOVWF  xCE
58C2:  CLRF   03
58C4:  MOVF   xCB,W
58C6:  ADDWF  xC3,W
58C8:  MOVWF  FE9
58CA:  MOVF   xC4,W
58CC:  ADDWFC 03,W
58CE:  MOVWF  FEA
58D0:  MOVF   FEF,W
58D2:  XORWF  xCE,W
58D4:  MOVFF  7CD,FEA
58D8:  MOVFF  7CC,FE9
58DC:  MOVWF  FEF
....................       }  
58DE:  INCF   xCB,F
58E0:  BRA    588C
....................     } else { 
58E2:  BRA    5A56
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
58E4:  MOVFF  7C3,01
58E8:  MOVFF  7C4,03
58EC:  MOVFF  7C3,7CC
58F0:  MOVFF  7C4,7CD
58F4:  MOVLW  0D
58F6:  ADDWF  xC3,W
58F8:  MOVWF  FE9
58FA:  MOVLW  00
58FC:  ADDWFC xC4,W
58FE:  MOVWF  FEA
5900:  CLRF   03
5902:  MOVF   FEF,W
5904:  MOVLB  0
5906:  CALL   00D0
590A:  MOVLB  7
590C:  MOVWF  xCE
590E:  MOVFF  7C3,FE9
5912:  MOVFF  7C4,FEA
5916:  MOVF   FEF,W
5918:  XORWF  xCE,F
591A:  CLRF   03
591C:  MOVF   xCA,W
591E:  MOVLB  0
5920:  CALL   02F0
5924:  MOVWF  01
5926:  MOVLB  7
5928:  MOVF   xCE,W
592A:  XORWF  01,W
592C:  MOVFF  7CD,FEA
5930:  MOVFF  7CC,FE9
5934:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
5936:  MOVLW  01
5938:  ADDWF  xC3,W
593A:  MOVWF  01
593C:  MOVLW  00
593E:  ADDWFC xC4,W
5940:  MOVWF  03
5942:  MOVFF  01,7CC
5946:  MOVWF  xCD
5948:  MOVLW  0E
594A:  ADDWF  xC3,W
594C:  MOVWF  FE9
594E:  MOVLW  00
5950:  ADDWFC xC4,W
5952:  MOVWF  FEA
5954:  CLRF   03
5956:  MOVF   FEF,W
5958:  MOVLB  0
595A:  CALL   00D0
595E:  MOVLB  7
5960:  MOVWF  xCE
5962:  MOVLW  01
5964:  ADDWF  xC3,W
5966:  MOVWF  FE9
5968:  MOVLW  00
596A:  ADDWFC xC4,W
596C:  MOVWF  FEA
596E:  MOVF   FEF,W
5970:  XORWF  xCE,W
5972:  MOVFF  7CD,FEA
5976:  MOVFF  7CC,FE9
597A:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
597C:  MOVLW  02
597E:  ADDWF  xC3,W
5980:  MOVWF  01
5982:  MOVLW  00
5984:  ADDWFC xC4,W
5986:  MOVWF  03
5988:  MOVFF  01,7CC
598C:  MOVWF  xCD
598E:  MOVLW  0F
5990:  ADDWF  xC3,W
5992:  MOVWF  FE9
5994:  MOVLW  00
5996:  ADDWFC xC4,W
5998:  MOVWF  FEA
599A:  CLRF   03
599C:  MOVF   FEF,W
599E:  MOVLB  0
59A0:  CALL   00D0
59A4:  MOVLB  7
59A6:  MOVWF  xCE
59A8:  MOVLW  02
59AA:  ADDWF  xC3,W
59AC:  MOVWF  FE9
59AE:  MOVLW  00
59B0:  ADDWFC xC4,W
59B2:  MOVWF  FEA
59B4:  MOVF   FEF,W
59B6:  XORWF  xCE,W
59B8:  MOVFF  7CD,FEA
59BC:  MOVFF  7CC,FE9
59C0:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
59C2:  MOVLW  03
59C4:  ADDWF  xC3,W
59C6:  MOVWF  01
59C8:  MOVLW  00
59CA:  ADDWFC xC4,W
59CC:  MOVWF  03
59CE:  MOVFF  01,7CC
59D2:  MOVWF  xCD
59D4:  MOVLW  0C
59D6:  ADDWF  xC3,W
59D8:  MOVWF  FE9
59DA:  MOVLW  00
59DC:  ADDWFC xC4,W
59DE:  MOVWF  FEA
59E0:  CLRF   03
59E2:  MOVF   FEF,W
59E4:  MOVLB  0
59E6:  CALL   00D0
59EA:  MOVLB  7
59EC:  MOVWF  xCE
59EE:  MOVLW  03
59F0:  ADDWF  xC3,W
59F2:  MOVWF  FE9
59F4:  MOVLW  00
59F6:  ADDWFC xC4,W
59F8:  MOVWF  FEA
59FA:  MOVF   FEF,W
59FC:  XORWF  xCE,W
59FE:  MOVFF  7CD,FEA
5A02:  MOVFF  7CC,FE9
5A06:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
5A08:  MOVLW  04
5A0A:  MOVWF  xCB
5A0C:  MOVF   xCB,W
5A0E:  SUBLW  0F
5A10:  BNC   5A56
....................         key[i] = key[i] ^ key[i-4]; 
5A12:  CLRF   03
5A14:  MOVF   xCB,W
5A16:  ADDWF  xC3,W
5A18:  MOVWF  01
5A1A:  MOVF   xC4,W
5A1C:  ADDWFC 03,F
5A1E:  MOVFF  03,7CD
5A22:  CLRF   03
5A24:  MOVF   xCB,W
5A26:  ADDWF  xC3,W
5A28:  MOVWF  FE9
5A2A:  MOVF   xC4,W
5A2C:  ADDWFC 03,W
5A2E:  MOVWF  FEA
5A30:  MOVFF  FEF,7CE
5A34:  MOVLW  04
5A36:  SUBWF  xCB,W
5A38:  CLRF   03
5A3A:  ADDWF  xC3,W
5A3C:  MOVWF  FE9
5A3E:  MOVF   xC4,W
5A40:  ADDWFC 03,W
5A42:  MOVWF  FEA
5A44:  MOVF   FEF,W
5A46:  XORWF  xCE,W
5A48:  MOVFF  7CD,FEA
5A4C:  MOVFF  01,FE9
5A50:  MOVWF  FEF
....................       } 
5A52:  INCF   xCB,F
5A54:  BRA    5A0C
....................     } 
....................   } 
5A56:  INCF   xCA,F
5A58:  GOTO   502C
....................   if (!dir) { 
5A5C:  MOVF   xC5,F
5A5E:  BNZ   5AAA
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
5A60:  CLRF   xCB
5A62:  MOVF   xCB,W
5A64:  SUBLW  0F
5A66:  BNC   5AAA
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
5A68:  CLRF   03
5A6A:  MOVF   xCB,W
5A6C:  ADDWF  xC1,W
5A6E:  MOVWF  01
5A70:  MOVF   xC2,W
5A72:  ADDWFC 03,F
5A74:  MOVFF  03,7CD
5A78:  CLRF   03
5A7A:  MOVF   xCB,W
5A7C:  ADDWF  xC1,W
5A7E:  MOVWF  FE9
5A80:  MOVF   xC2,W
5A82:  ADDWFC 03,W
5A84:  MOVWF  FEA
5A86:  MOVFF  FEF,7CE
5A8A:  CLRF   03
5A8C:  MOVF   xCB,W
5A8E:  ADDWF  xC3,W
5A90:  MOVWF  FE9
5A92:  MOVF   xC4,W
5A94:  ADDWFC 03,W
5A96:  MOVWF  FEA
5A98:  MOVF   FEF,W
5A9A:  XORWF  xCE,W
5A9C:  MOVFF  7CD,FEA
5AA0:  MOVFF  01,FE9
5AA4:  MOVWF  FEF
....................     } // enf for 
5AA6:  INCF   xCB,F
5AA8:  BRA    5A62
....................   } // end if (!dir) 
.................... } // end function 
5AAA:  MOVLB  0
5AAC:  GOTO   807A (RETURN)
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... int8 type_KB=0; 
.................... #define key_numbyte  12 
....................  
.................... int8 key_data[key_numbyte]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
2086:  MOVLB  1
2088:  INCF   x62,F
208A:  MOVF   x62,W
208C:  SUBLW  01
208E:  BTFSC  FD8.0
2090:  BRA    2236
....................        switch (col) { 
2092:  MOVF   x65,W
2094:  ADDLW  FB
2096:  BC    211A
2098:  ADDLW  05
209A:  MOVLB  0
209C:  GOTO   2240
....................          case 0   :  
....................                     output_low(COL0); 
20A0:  BCF    F92.5
20A2:  BCF    F89.5
....................                     output_high(COL1); 
20A4:  BCF    F92.3
20A6:  BSF    F89.3
....................                     output_high(COL2); 
20A8:  BCF    F92.2
20AA:  BSF    F89.2
....................                     output_high(COL3); 
20AC:  BCF    F92.1
20AE:  BSF    F89.1
....................                     output_high(COL4); 
20B0:  BCF    F92.0
20B2:  BSF    F89.0
....................                     break; 
20B4:  MOVLB  1
20B6:  BRA    211A
....................          case 1   :  
....................                     output_low(COL1); 
20B8:  BCF    F92.3
20BA:  BCF    F89.3
....................                     output_high(COL0); 
20BC:  BCF    F92.5
20BE:  BSF    F89.5
....................                     output_high(COL2); 
20C0:  BCF    F92.2
20C2:  BSF    F89.2
....................                     output_high(COL3); 
20C4:  BCF    F92.1
20C6:  BSF    F89.1
....................                     output_high(COL4); 
20C8:  BCF    F92.0
20CA:  BSF    F89.0
....................                     break; 
20CC:  MOVLB  1
20CE:  BRA    211A
....................          case 2   :  
....................                     output_low(COL2); 
20D0:  BCF    F92.2
20D2:  BCF    F89.2
....................                     output_high(COL1); 
20D4:  BCF    F92.3
20D6:  BSF    F89.3
....................                     output_high(COL0); 
20D8:  BCF    F92.5
20DA:  BSF    F89.5
....................                     output_high(COL3); 
20DC:  BCF    F92.1
20DE:  BSF    F89.1
....................                     output_high(COL4); 
20E0:  BCF    F92.0
20E2:  BSF    F89.0
....................                     break; 
20E4:  MOVLB  1
20E6:  BRA    211A
....................          case 3   :  
....................                     output_low(COL3); 
20E8:  BCF    F92.1
20EA:  BCF    F89.1
....................                     output_high(COL1); 
20EC:  BCF    F92.3
20EE:  BSF    F89.3
....................                     output_high(COL2); 
20F0:  BCF    F92.2
20F2:  BSF    F89.2
....................                     output_high(COL0); 
20F4:  BCF    F92.5
20F6:  BSF    F89.5
....................                     output_high(COL4); 
20F8:  BCF    F92.0
20FA:  BSF    F89.0
....................                     break; 
20FC:  MOVLB  1
20FE:  BRA    211A
....................          case 4   :  
....................                     output_low(COL4); 
2100:  BCF    F92.0
2102:  BCF    F89.0
....................                     output_high(COL1); 
2104:  BCF    F92.3
2106:  BSF    F89.3
....................                     output_high(COL2); 
2108:  BCF    F92.2
210A:  BSF    F89.2
....................                     output_high(COL3); 
210C:  BCF    F92.1
210E:  BSF    F89.1
....................                     output_high(COL0); 
2110:  BCF    F92.5
2112:  BSF    F89.5
....................                     break; 
2114:  MOVLB  1
2116:  BRA    211A
2118:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
211A:  BTFSS  x63.0
211C:  BRA    219C
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
211E:  BSF    F93.4
2120:  MOVLW  00
2122:  BTFSC  F81.4
2124:  MOVLW  01
2126:  MOVLB  8
2128:  MOVWF  x31
212A:  BSF    F93.5
212C:  MOVLW  00
212E:  BTFSC  F81.5
2130:  MOVLW  01
2132:  ANDWF  x31,F
2134:  BSF    F93.6
2136:  MOVLW  00
2138:  BTFSC  F81.6
213A:  MOVLW  01
213C:  ANDWF  x31,F
213E:  BSF    F93.7
2140:  MOVLW  00
2142:  BTFSC  F81.7
2144:  MOVLW  01
2146:  ANDWF  x31,W
2148:  BZ    2198
....................          { 
....................             kchar=last_key; 
214A:  MOVFF  164,82F
....................             if(keydebug_en==0) 
214E:  MOVLB  1
2150:  MOVF   x4C,F
2152:  BNZ   2186
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
2154:  CLRF   x4A
2156:  CLRF   x49
....................               charac_timeout=0; 
2158:  MOVLB  0
215A:  CLRF   xFC
215C:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
215E:  MOVLB  1
2160:  MOVF   x4F,W
2162:  SUBLW  0B
2164:  BNC   217A
2166:  MOVF   x4F,W
2168:  INCF   x4F,F
216A:  CLRF   03
216C:  ADDLW  55
216E:  MOVWF  FE9
2170:  MOVLW  01
2172:  ADDWFC 03,W
2174:  MOVWF  FEA
2176:  MOVFF  82F,FEF
....................                fputc(kchar,COM2); 
217A:  MOVFF  82F,858
217E:  MOVLB  0
2180:  CALL   069C
....................             } 
....................                else fputc(kchar,COM2); 
2184:  BRA    2190
2186:  MOVFF  82F,858
218A:  MOVLB  0
218C:  CALL   069C
....................            kbd_down=FALSE; 
2190:  MOVLB  1
2192:  BCF    x63.0
....................            last_key=0; 
2194:  CLRF   x64
2196:  MOVLB  8
....................          } 
....................        } else 
2198:  BRA    2232
219A:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
219C:  BSF    F93.4
219E:  MOVLW  00
21A0:  BTFSC  F81.4
21A2:  MOVLW  01
21A4:  MOVLB  8
21A6:  MOVWF  x31
21A8:  BSF    F93.5
21AA:  MOVLW  00
21AC:  BTFSC  F81.5
21AE:  MOVLW  01
21B0:  ANDWF  x31,F
21B2:  BSF    F93.6
21B4:  MOVLW  00
21B6:  BTFSC  F81.6
21B8:  MOVLW  01
21BA:  ANDWF  x31,F
21BC:  BSF    F93.7
21BE:  MOVLW  00
21C0:  BTFSC  F81.7
21C2:  MOVLW  01
21C4:  ANDWF  x31,W
21C6:  BNZ   2226
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
21C8:  BSF    F93.4
21CA:  BTFSC  F81.4
21CC:  BRA    21D2
....................                   row=0; 
21CE:  CLRF   x30
....................                 else if(input(ROW1)==0) 
21D0:  BRA    21F4
21D2:  BSF    F93.5
21D4:  BTFSC  F81.5
21D6:  BRA    21DE
....................                   row=1; 
21D8:  MOVLW  01
21DA:  MOVWF  x30
....................                 else if(input(ROW2)==0) 
21DC:  BRA    21F4
21DE:  BSF    F93.6
21E0:  BTFSC  F81.6
21E2:  BRA    21EA
....................                   row=2; 
21E4:  MOVLW  02
21E6:  MOVWF  x30
....................                 else if(input(ROW3)==0) 
21E8:  BRA    21F4
21EA:  BSF    F93.7
21EC:  BTFSC  F81.7
21EE:  BRA    21F4
....................                   row=3; 
21F0:  MOVLW  03
21F2:  MOVWF  x30
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
21F4:  MOVF   x30,W
21F6:  MULLW  05
21F8:  MOVF   FF3,W
21FA:  CLRF   x32
21FC:  MOVWF  x31
21FE:  CLRF   03
2200:  MOVLB  1
2202:  MOVF   x65,W
2204:  MOVLB  8
2206:  ADDWF  x31,W
2208:  MOVWF  01
220A:  MOVF   x32,W
220C:  ADDWFC 03,F
220E:  MOVF   01,W
2210:  MOVLB  0
2212:  CALL   030A
2216:  MOVFF  FE8,164
....................                 kbd_down = TRUE; 
221A:  MOVLB  1
221C:  BSF    x63.0
....................                 set_tris_a(0xff); 
221E:  MOVLW  FF
2220:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2222:  BRA    2232
2224:  MOVLB  8
....................                { 
....................                   ++col; 
2226:  MOVLB  1
2228:  INCF   x65,F
....................                   if(col==5) col=0; 
222A:  MOVF   x65,W
222C:  SUBLW  05
222E:  BTFSC  FD8.2
2230:  CLRF   x65
....................                } 
....................          } 
....................       kbd_call_count=0; 
2232:  MOVLB  1
2234:  CLRF   x62
....................    } 
....................   return(kchar); 
2236:  MOVLB  8
2238:  MOVFF  82F,01
.................... } 
223C:  MOVLB  0
223E:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2264:  MOVLW  E0
2266:  MOVLB  F
2268:  MOVWF  x48
226A:  BCF    FC2.6
226C:  BCF    FC2.7
226E:  MOVF   x49,W
2270:  ANDLW  E0
2272:  IORLW  17
2274:  MOVWF  x49
....................    switch(col) 
....................    { 
2276:  MOVLB  8
2278:  MOVF   x4C,W
227A:  ADDLW  FA
227C:  BC    2348
227E:  ADDLW  06
2280:  MOVLB  0
2282:  GOTO   234C
....................       case 0: 
....................         set_adc_channel(4); 
2286:  MOVLW  10
2288:  MOVWF  01
228A:  MOVF   FC2,W
228C:  ANDLW  C3
228E:  IORWF  01,W
2290:  MOVWF  FC2
....................         adc=read_adc(); 
2292:  BSF    FC2.1
2294:  BTFSC  FC2.1
2296:  BRA    2294
2298:  MOVFF  FC4,84D
....................         return adc; 
229C:  MOVLB  8
229E:  MOVFF  84D,01
22A2:  BRA    2348
....................       break; 
22A4:  BRA    2348
....................       case 1: 
....................         set_adc_channel(3); 
22A6:  MOVLW  0C
22A8:  MOVWF  01
22AA:  MOVF   FC2,W
22AC:  ANDLW  C3
22AE:  IORWF  01,W
22B0:  MOVWF  FC2
....................         adc=read_adc(); 
22B2:  BSF    FC2.1
22B4:  BTFSC  FC2.1
22B6:  BRA    22B4
22B8:  MOVFF  FC4,84D
....................         return adc; 
22BC:  MOVLB  8
22BE:  MOVFF  84D,01
22C2:  BRA    2348
....................       break; 
22C4:  BRA    2348
....................       case 2: 
....................         set_adc_channel(2); 
22C6:  MOVLW  08
22C8:  MOVWF  01
22CA:  MOVF   FC2,W
22CC:  ANDLW  C3
22CE:  IORWF  01,W
22D0:  MOVWF  FC2
....................         adc=read_adc(); 
22D2:  BSF    FC2.1
22D4:  BTFSC  FC2.1
22D6:  BRA    22D4
22D8:  MOVFF  FC4,84D
....................         return adc; 
22DC:  MOVLB  8
22DE:  MOVFF  84D,01
22E2:  BRA    2348
....................       break; 
22E4:  BRA    2348
....................       case 3: 
....................         set_adc_channel(1); 
22E6:  MOVLW  04
22E8:  MOVWF  01
22EA:  MOVF   FC2,W
22EC:  ANDLW  C3
22EE:  IORWF  01,W
22F0:  MOVWF  FC2
....................         adc=read_adc(); 
22F2:  BSF    FC2.1
22F4:  BTFSC  FC2.1
22F6:  BRA    22F4
22F8:  MOVFF  FC4,84D
....................         return adc; 
22FC:  MOVLB  8
22FE:  MOVFF  84D,01
2302:  BRA    2348
....................       break; 
2304:  BRA    2348
....................       case 4: 
....................         set_adc_channel(0); 
2306:  MOVLW  00
2308:  MOVWF  01
230A:  MOVF   FC2,W
230C:  ANDLW  C3
230E:  IORWF  01,W
2310:  MOVWF  FC2
....................         adc=read_adc(); 
2312:  BSF    FC2.1
2314:  BTFSC  FC2.1
2316:  BRA    2314
2318:  MOVFF  FC4,84D
....................         return adc; 
231C:  MOVLB  8
231E:  MOVFF  84D,01
2322:  BRA    2348
....................       break;      
2324:  BRA    2348
....................       case 5: 
....................         set_adc_channel(11); 
2326:  MOVLW  2C
2328:  MOVWF  01
232A:  MOVF   FC2,W
232C:  ANDLW  C3
232E:  IORWF  01,W
2330:  MOVWF  FC2
....................         adc=read_adc(); 
2332:  BSF    FC2.1
2334:  BTFSC  FC2.1
2336:  BRA    2334
2338:  MOVFF  FC4,84D
....................         return adc; 
233C:  MOVLB  8
233E:  MOVFF  84D,01
2342:  BRA    2348
....................       break;      
2344:  BRA    2348
2346:  MOVLB  8
....................    } 
.................... } 
2348:  MOVLB  0
234A:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
24C6:  MOVLB  8
24C8:  CLRF   x37
24CA:  CLRF   x36
24CC:  CLRF   x35
24CE:  CLRF   x34
24D0:  CLRF   x3B
24D2:  CLRF   x3A
24D4:  CLRF   x39
24D6:  CLRF   x38
24D8:  CLRF   x3F
24DA:  CLRF   x3E
24DC:  CLRF   x3D
24DE:  CLRF   x3C
24E0:  CLRF   x43
24E2:  CLRF   x42
24E4:  CLRF   x41
24E6:  CLRF   x40
24E8:  CLRF   x47
24EA:  CLRF   x46
24EC:  CLRF   x45
24EE:  CLRF   x44
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
24F0:  CLRF   x33
24F2:  CLRF   x32
24F4:  MOVF   x33,W
24F6:  SUBLW  01
24F8:  BNC   2576
24FA:  BNZ   2502
24FC:  MOVF   x32,W
24FE:  SUBLW  F3
2500:  BNC   2576
....................    { 
....................       col_0=read_col(0)+col_0; 
2502:  CLRF   x4C
2504:  MOVLB  0
2506:  RCALL  2264
2508:  MOVF   01,W
250A:  MOVLB  8
250C:  ADDWF  x34,F
250E:  MOVLW  00
2510:  ADDWFC x35,F
2512:  ADDWFC x36,F
2514:  ADDWFC x37,F
....................       col_1=read_col(1)+col_1; 
2516:  MOVLW  01
2518:  MOVWF  x4C
251A:  MOVLB  0
251C:  RCALL  2264
251E:  MOVF   01,W
2520:  MOVLB  8
2522:  ADDWF  x38,F
2524:  MOVLW  00
2526:  ADDWFC x39,F
2528:  ADDWFC x3A,F
252A:  ADDWFC x3B,F
....................       col_2=read_col(2)+col_2; 
252C:  MOVLW  02
252E:  MOVWF  x4C
2530:  MOVLB  0
2532:  RCALL  2264
2534:  MOVF   01,W
2536:  MOVLB  8
2538:  ADDWF  x3C,F
253A:  MOVLW  00
253C:  ADDWFC x3D,F
253E:  ADDWFC x3E,F
2540:  ADDWFC x3F,F
....................       col_3=read_col(3)+col_3; 
2542:  MOVLW  03
2544:  MOVWF  x4C
2546:  MOVLB  0
2548:  RCALL  2264
254A:  MOVF   01,W
254C:  MOVLB  8
254E:  ADDWF  x40,F
2550:  MOVLW  00
2552:  ADDWFC x41,F
2554:  ADDWFC x42,F
2556:  ADDWFC x43,F
....................       col_4=read_col(4)+col_4; 
2558:  MOVLW  04
255A:  MOVWF  x4C
255C:  MOVLB  0
255E:  RCALL  2264
2560:  MOVF   01,W
2562:  MOVLB  8
2564:  ADDWF  x44,F
2566:  MOVLW  00
2568:  ADDWFC x45,F
256A:  ADDWFC x46,F
256C:  ADDWFC x47,F
....................    } 
256E:  INCF   x32,F
2570:  BTFSC  FD8.2
2572:  INCF   x33,F
2574:  BRA    24F4
....................    col_0=col_0/500; 
2576:  BCF    FD8.1
2578:  MOVFF  837,85B
257C:  MOVFF  836,85A
2580:  MOVFF  835,859
2584:  MOVFF  834,858
2588:  CLRF   x5F
258A:  CLRF   x5E
258C:  MOVLW  01
258E:  MOVWF  x5D
2590:  MOVLW  F4
2592:  MOVWF  x5C
2594:  MOVLB  0
2596:  RCALL  2372
2598:  MOVFF  03,837
259C:  MOVFF  02,836
25A0:  MOVFF  01,835
25A4:  MOVFF  00,834
....................    col_1=col_1/500; 
25A8:  BCF    FD8.1
25AA:  MOVFF  83B,85B
25AE:  MOVFF  83A,85A
25B2:  MOVFF  839,859
25B6:  MOVFF  838,858
25BA:  MOVLB  8
25BC:  CLRF   x5F
25BE:  CLRF   x5E
25C0:  MOVLW  01
25C2:  MOVWF  x5D
25C4:  MOVLW  F4
25C6:  MOVWF  x5C
25C8:  MOVLB  0
25CA:  RCALL  2372
25CC:  MOVFF  03,83B
25D0:  MOVFF  02,83A
25D4:  MOVFF  01,839
25D8:  MOVFF  00,838
....................    col_2=col_2/500; 
25DC:  BCF    FD8.1
25DE:  MOVFF  83F,85B
25E2:  MOVFF  83E,85A
25E6:  MOVFF  83D,859
25EA:  MOVFF  83C,858
25EE:  MOVLB  8
25F0:  CLRF   x5F
25F2:  CLRF   x5E
25F4:  MOVLW  01
25F6:  MOVWF  x5D
25F8:  MOVLW  F4
25FA:  MOVWF  x5C
25FC:  MOVLB  0
25FE:  RCALL  2372
2600:  MOVFF  03,83F
2604:  MOVFF  02,83E
2608:  MOVFF  01,83D
260C:  MOVFF  00,83C
....................    col_3=col_3/500; 
2610:  BCF    FD8.1
2612:  MOVFF  843,85B
2616:  MOVFF  842,85A
261A:  MOVFF  841,859
261E:  MOVFF  840,858
2622:  MOVLB  8
2624:  CLRF   x5F
2626:  CLRF   x5E
2628:  MOVLW  01
262A:  MOVWF  x5D
262C:  MOVLW  F4
262E:  MOVWF  x5C
2630:  MOVLB  0
2632:  RCALL  2372
2634:  MOVFF  03,843
2638:  MOVFF  02,842
263C:  MOVFF  01,841
2640:  MOVFF  00,840
....................    col_4=col_4/500; 
2644:  BCF    FD8.1
2646:  MOVFF  847,85B
264A:  MOVFF  846,85A
264E:  MOVFF  845,859
2652:  MOVFF  844,858
2656:  MOVLB  8
2658:  CLRF   x5F
265A:  CLRF   x5E
265C:  MOVLW  01
265E:  MOVWF  x5D
2660:  MOVLW  F4
2662:  MOVWF  x5C
2664:  MOVLB  0
2666:  RCALL  2372
2668:  MOVFF  03,847
266C:  MOVFF  02,846
2670:  MOVFF  01,845
2674:  MOVFF  00,844
....................    if(keydebug_en) 
2678:  MOVLB  1
267A:  MOVF   x4C,F
267C:  BTFSC  FD8.2
267E:  BRA    27FA
....................    { 
....................       fprintf(COM2,"\r\n");      
2680:  MOVLW  0D
2682:  MOVLB  8
2684:  MOVWF  x58
2686:  MOVLB  0
2688:  CALL   069C
268C:  MOVLW  0A
268E:  MOVLB  8
2690:  MOVWF  x58
2692:  MOVLB  0
2694:  CALL   069C
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2698:  MOVLW  F2
269A:  MOVWF  FF6
269C:  MOVLW  04
269E:  MOVWF  FF7
26A0:  MOVLW  07
26A2:  MOVLB  8
26A4:  MOVWF  x4C
26A6:  MOVLB  0
26A8:  CALL   165A
26AC:  MOVLW  41
26AE:  MOVWF  FE9
26B0:  MOVFF  837,84F
26B4:  MOVFF  836,84E
26B8:  MOVFF  835,84D
26BC:  MOVFF  834,84C
26C0:  RCALL  2406
26C2:  MOVLW  0D
26C4:  MOVLB  8
26C6:  MOVWF  x58
26C8:  MOVLB  0
26CA:  CALL   069C
26CE:  MOVLW  0A
26D0:  MOVLB  8
26D2:  MOVWF  x58
26D4:  MOVLB  0
26D6:  CALL   069C
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
26DA:  MOVLW  00
26DC:  MOVWF  FF6
26DE:  MOVLW  05
26E0:  MOVWF  FF7
26E2:  MOVLW  07
26E4:  MOVLB  8
26E6:  MOVWF  x4C
26E8:  MOVLB  0
26EA:  CALL   165A
26EE:  MOVLW  41
26F0:  MOVWF  FE9
26F2:  MOVFF  83B,84F
26F6:  MOVFF  83A,84E
26FA:  MOVFF  839,84D
26FE:  MOVFF  838,84C
2702:  RCALL  2406
2704:  MOVLW  0D
2706:  MOVLB  8
2708:  MOVWF  x58
270A:  MOVLB  0
270C:  CALL   069C
2710:  MOVLW  0A
2712:  MOVLB  8
2714:  MOVWF  x58
2716:  MOVLB  0
2718:  CALL   069C
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
271C:  MOVLW  0E
271E:  MOVWF  FF6
2720:  MOVLW  05
2722:  MOVWF  FF7
2724:  MOVLW  07
2726:  MOVLB  8
2728:  MOVWF  x4C
272A:  MOVLB  0
272C:  CALL   165A
2730:  MOVLW  41
2732:  MOVWF  FE9
2734:  MOVFF  83F,84F
2738:  MOVFF  83E,84E
273C:  MOVFF  83D,84D
2740:  MOVFF  83C,84C
2744:  RCALL  2406
2746:  MOVLW  0D
2748:  MOVLB  8
274A:  MOVWF  x58
274C:  MOVLB  0
274E:  CALL   069C
2752:  MOVLW  0A
2754:  MOVLB  8
2756:  MOVWF  x58
2758:  MOVLB  0
275A:  CALL   069C
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
275E:  MOVLW  1C
2760:  MOVWF  FF6
2762:  MOVLW  05
2764:  MOVWF  FF7
2766:  MOVLW  07
2768:  MOVLB  8
276A:  MOVWF  x4C
276C:  MOVLB  0
276E:  CALL   165A
2772:  MOVLW  41
2774:  MOVWF  FE9
2776:  MOVFF  843,84F
277A:  MOVFF  842,84E
277E:  MOVFF  841,84D
2782:  MOVFF  840,84C
2786:  RCALL  2406
2788:  MOVLW  0D
278A:  MOVLB  8
278C:  MOVWF  x58
278E:  MOVLB  0
2790:  CALL   069C
2794:  MOVLW  0A
2796:  MOVLB  8
2798:  MOVWF  x58
279A:  MOVLB  0
279C:  CALL   069C
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
27A0:  MOVLW  2A
27A2:  MOVWF  FF6
27A4:  MOVLW  05
27A6:  MOVWF  FF7
27A8:  MOVLW  07
27AA:  MOVLB  8
27AC:  MOVWF  x4C
27AE:  MOVLB  0
27B0:  CALL   165A
27B4:  MOVLW  41
27B6:  MOVWF  FE9
27B8:  MOVFF  847,84F
27BC:  MOVFF  846,84E
27C0:  MOVFF  845,84D
27C4:  MOVFF  844,84C
27C8:  RCALL  2406
27CA:  MOVLW  0D
27CC:  MOVLB  8
27CE:  MOVWF  x58
27D0:  MOVLB  0
27D2:  CALL   069C
27D6:  MOVLW  0A
27D8:  MOVLB  8
27DA:  MOVWF  x58
27DC:  MOVLB  0
27DE:  CALL   069C
....................       fprintf(COM2,"\r\n"); 
27E2:  MOVLW  0D
27E4:  MOVLB  8
27E6:  MOVWF  x58
27E8:  MOVLB  0
27EA:  CALL   069C
27EE:  MOVLW  0A
27F0:  MOVLB  8
27F2:  MOVWF  x58
27F4:  MOVLB  0
27F6:  CALL   069C
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
27FA:  MOVLB  8
27FC:  MOVF   x37,F
27FE:  BNZ   280E
2800:  MOVF   x36,F
2802:  BNZ   280E
2804:  MOVF   x35,F
2806:  BNZ   280E
2808:  MOVF   x34,W
280A:  SUBLW  05
280C:  BC    286E
280E:  MOVF   x37,F
2810:  BNZ   286E
2812:  MOVF   x36,F
2814:  BNZ   286E
2816:  MOVF   x35,F
2818:  BNZ   286E
281A:  MOVF   x34,W
281C:  SUBLW  3B
281E:  BNC   286E
2820:  MOVF   x3B,F
2822:  BNZ   2832
2824:  MOVF   x3A,F
2826:  BNZ   2832
2828:  MOVF   x39,F
282A:  BNZ   2832
282C:  MOVF   x38,W
282E:  SUBLW  64
2830:  BC    286E
2832:  MOVF   x3F,F
2834:  BNZ   2844
2836:  MOVF   x3E,F
2838:  BNZ   2844
283A:  MOVF   x3D,F
283C:  BNZ   2844
283E:  MOVF   x3C,W
2840:  SUBLW  64
2842:  BC    286E
2844:  MOVF   x43,F
2846:  BNZ   2856
2848:  MOVF   x42,F
284A:  BNZ   2856
284C:  MOVF   x41,F
284E:  BNZ   2856
2850:  MOVF   x40,W
2852:  SUBLW  64
2854:  BC    286E
2856:  MOVF   x47,F
2858:  BNZ   2868
285A:  MOVF   x46,F
285C:  BNZ   2868
285E:  MOVF   x45,F
2860:  BNZ   2868
2862:  MOVF   x44,W
2864:  SUBLW  64
2866:  BC    286E
2868:  MOVLW  00
286A:  MOVWF  01
286C:  BRA    2AEC
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
286E:  MOVF   x3B,F
2870:  BNZ   2880
2872:  MOVF   x3A,F
2874:  BNZ   2880
2876:  MOVF   x39,F
2878:  BNZ   2880
287A:  MOVF   x38,W
287C:  SUBLW  05
287E:  BC    28E0
2880:  MOVF   x3B,F
2882:  BNZ   28E0
2884:  MOVF   x3A,F
2886:  BNZ   28E0
2888:  MOVF   x39,F
288A:  BNZ   28E0
288C:  MOVF   x38,W
288E:  SUBLW  3B
2890:  BNC   28E0
2892:  MOVF   x37,F
2894:  BNZ   28A4
2896:  MOVF   x36,F
2898:  BNZ   28A4
289A:  MOVF   x35,F
289C:  BNZ   28A4
289E:  MOVF   x34,W
28A0:  SUBLW  64
28A2:  BC    28E0
28A4:  MOVF   x3F,F
28A6:  BNZ   28B6
28A8:  MOVF   x3E,F
28AA:  BNZ   28B6
28AC:  MOVF   x3D,F
28AE:  BNZ   28B6
28B0:  MOVF   x3C,W
28B2:  SUBLW  64
28B4:  BC    28E0
28B6:  MOVF   x43,F
28B8:  BNZ   28C8
28BA:  MOVF   x42,F
28BC:  BNZ   28C8
28BE:  MOVF   x41,F
28C0:  BNZ   28C8
28C2:  MOVF   x40,W
28C4:  SUBLW  64
28C6:  BC    28E0
28C8:  MOVF   x47,F
28CA:  BNZ   28DA
28CC:  MOVF   x46,F
28CE:  BNZ   28DA
28D0:  MOVF   x45,F
28D2:  BNZ   28DA
28D4:  MOVF   x44,W
28D6:  SUBLW  64
28D8:  BC    28E0
28DA:  MOVLW  01
28DC:  MOVWF  01
28DE:  BRA    2AEC
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
28E0:  MOVF   x3F,F
28E2:  BNZ   28F2
28E4:  MOVF   x3E,F
28E6:  BNZ   28F2
28E8:  MOVF   x3D,F
28EA:  BNZ   28F2
28EC:  MOVF   x3C,W
28EE:  SUBLW  05
28F0:  BC    2952
28F2:  MOVF   x3F,F
28F4:  BNZ   2952
28F6:  MOVF   x3E,F
28F8:  BNZ   2952
28FA:  MOVF   x3D,F
28FC:  BNZ   2952
28FE:  MOVF   x3C,W
2900:  SUBLW  3B
2902:  BNC   2952
2904:  MOVF   x3B,F
2906:  BNZ   2916
2908:  MOVF   x3A,F
290A:  BNZ   2916
290C:  MOVF   x39,F
290E:  BNZ   2916
2910:  MOVF   x38,W
2912:  SUBLW  64
2914:  BC    2952
2916:  MOVF   x37,F
2918:  BNZ   2928
291A:  MOVF   x36,F
291C:  BNZ   2928
291E:  MOVF   x35,F
2920:  BNZ   2928
2922:  MOVF   x34,W
2924:  SUBLW  64
2926:  BC    2952
2928:  MOVF   x43,F
292A:  BNZ   293A
292C:  MOVF   x42,F
292E:  BNZ   293A
2930:  MOVF   x41,F
2932:  BNZ   293A
2934:  MOVF   x40,W
2936:  SUBLW  64
2938:  BC    2952
293A:  MOVF   x47,F
293C:  BNZ   294C
293E:  MOVF   x46,F
2940:  BNZ   294C
2942:  MOVF   x45,F
2944:  BNZ   294C
2946:  MOVF   x44,W
2948:  SUBLW  64
294A:  BC    2952
294C:  MOVLW  02
294E:  MOVWF  01
2950:  BRA    2AEC
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2952:  MOVF   x43,F
2954:  BNZ   2964
2956:  MOVF   x42,F
2958:  BNZ   2964
295A:  MOVF   x41,F
295C:  BNZ   2964
295E:  MOVF   x40,W
2960:  SUBLW  05
2962:  BC    29C4
2964:  MOVF   x43,F
2966:  BNZ   29C4
2968:  MOVF   x42,F
296A:  BNZ   29C4
296C:  MOVF   x41,F
296E:  BNZ   29C4
2970:  MOVF   x40,W
2972:  SUBLW  3B
2974:  BNC   29C4
2976:  MOVF   x3B,F
2978:  BNZ   2988
297A:  MOVF   x3A,F
297C:  BNZ   2988
297E:  MOVF   x39,F
2980:  BNZ   2988
2982:  MOVF   x38,W
2984:  SUBLW  64
2986:  BC    29C4
2988:  MOVF   x3F,F
298A:  BNZ   299A
298C:  MOVF   x3E,F
298E:  BNZ   299A
2990:  MOVF   x3D,F
2992:  BNZ   299A
2994:  MOVF   x3C,W
2996:  SUBLW  64
2998:  BC    29C4
299A:  MOVF   x37,F
299C:  BNZ   29AC
299E:  MOVF   x36,F
29A0:  BNZ   29AC
29A2:  MOVF   x35,F
29A4:  BNZ   29AC
29A6:  MOVF   x34,W
29A8:  SUBLW  64
29AA:  BC    29C4
29AC:  MOVF   x47,F
29AE:  BNZ   29BE
29B0:  MOVF   x46,F
29B2:  BNZ   29BE
29B4:  MOVF   x45,F
29B6:  BNZ   29BE
29B8:  MOVF   x44,W
29BA:  SUBLW  64
29BC:  BC    29C4
29BE:  MOVLW  03
29C0:  MOVWF  01
29C2:  BRA    2AEC
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
29C4:  MOVF   x47,F
29C6:  BNZ   29D6
29C8:  MOVF   x46,F
29CA:  BNZ   29D6
29CC:  MOVF   x45,F
29CE:  BNZ   29D6
29D0:  MOVF   x44,W
29D2:  SUBLW  05
29D4:  BC    2A36
29D6:  MOVF   x47,F
29D8:  BNZ   2A36
29DA:  MOVF   x46,F
29DC:  BNZ   2A36
29DE:  MOVF   x45,F
29E0:  BNZ   2A36
29E2:  MOVF   x44,W
29E4:  SUBLW  3B
29E6:  BNC   2A36
29E8:  MOVF   x3B,F
29EA:  BNZ   29FA
29EC:  MOVF   x3A,F
29EE:  BNZ   29FA
29F0:  MOVF   x39,F
29F2:  BNZ   29FA
29F4:  MOVF   x38,W
29F6:  SUBLW  64
29F8:  BC    2A36
29FA:  MOVF   x3F,F
29FC:  BNZ   2A0C
29FE:  MOVF   x3E,F
2A00:  BNZ   2A0C
2A02:  MOVF   x3D,F
2A04:  BNZ   2A0C
2A06:  MOVF   x3C,W
2A08:  SUBLW  64
2A0A:  BC    2A36
2A0C:  MOVF   x43,F
2A0E:  BNZ   2A1E
2A10:  MOVF   x42,F
2A12:  BNZ   2A1E
2A14:  MOVF   x41,F
2A16:  BNZ   2A1E
2A18:  MOVF   x40,W
2A1A:  SUBLW  64
2A1C:  BC    2A36
2A1E:  MOVF   x37,F
2A20:  BNZ   2A30
2A22:  MOVF   x36,F
2A24:  BNZ   2A30
2A26:  MOVF   x35,F
2A28:  BNZ   2A30
2A2A:  MOVF   x34,W
2A2C:  SUBLW  64
2A2E:  BC    2A36
2A30:  MOVLW  04
2A32:  MOVWF  01
2A34:  BRA    2AEC
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2A36:  MOVF   x47,F
2A38:  BNZ   2A4A
2A3A:  MOVF   x46,F
2A3C:  BNZ   2A4A
2A3E:  MOVF   x45,F
2A40:  BNZ   2A4A
2A42:  MOVF   x44,W
2A44:  SUBLW  C8
2A46:  BTFSC  FD8.0
2A48:  BRA    2AE8
2A4A:  MOVF   x37,F
2A4C:  BTFSS  FD8.2
2A4E:  BRA    2AE8
2A50:  MOVF   x36,F
2A52:  BTFSS  FD8.2
2A54:  BRA    2AE8
2A56:  MOVF   x35,F
2A58:  BTFSS  FD8.2
2A5A:  BRA    2AE8
2A5C:  MOVF   x34,W
2A5E:  SUBLW  B3
2A60:  BNC   2AE8
2A62:  MOVF   x37,F
2A64:  BNZ   2A74
2A66:  MOVF   x36,F
2A68:  BNZ   2A74
2A6A:  MOVF   x35,F
2A6C:  BNZ   2A74
2A6E:  MOVF   x34,W
2A70:  SUBLW  64
2A72:  BC    2AE8
2A74:  MOVF   x3B,F
2A76:  BNZ   2AE8
2A78:  MOVF   x3A,F
2A7A:  BNZ   2AE8
2A7C:  MOVF   x39,F
2A7E:  BNZ   2AE8
2A80:  MOVF   x38,W
2A82:  SUBLW  B3
2A84:  BNC   2AE8
2A86:  MOVF   x3B,F
2A88:  BNZ   2A98
2A8A:  MOVF   x3A,F
2A8C:  BNZ   2A98
2A8E:  MOVF   x39,F
2A90:  BNZ   2A98
2A92:  MOVF   x38,W
2A94:  SUBLW  64
2A96:  BC    2AE8
2A98:  MOVF   x3F,F
2A9A:  BNZ   2AE8
2A9C:  MOVF   x3E,F
2A9E:  BNZ   2AE8
2AA0:  MOVF   x3D,F
2AA2:  BNZ   2AE8
2AA4:  MOVF   x3C,W
2AA6:  SUBLW  B3
2AA8:  BNC   2AE8
2AAA:  MOVF   x3F,F
2AAC:  BNZ   2ABC
2AAE:  MOVF   x3E,F
2AB0:  BNZ   2ABC
2AB2:  MOVF   x3D,F
2AB4:  BNZ   2ABC
2AB6:  MOVF   x3C,W
2AB8:  SUBLW  64
2ABA:  BC    2AE8
2ABC:  MOVF   x43,F
2ABE:  BNZ   2AE8
2AC0:  MOVF   x42,F
2AC2:  BNZ   2AE8
2AC4:  MOVF   x41,F
2AC6:  BNZ   2AE8
2AC8:  MOVF   x40,W
2ACA:  SUBLW  B3
2ACC:  BNC   2AE8
2ACE:  MOVF   x43,F
2AD0:  BNZ   2AE0
2AD2:  MOVF   x42,F
2AD4:  BNZ   2AE0
2AD6:  MOVF   x41,F
2AD8:  BNZ   2AE0
2ADA:  MOVF   x40,W
2ADC:  SUBLW  64
2ADE:  BC    2AE8
2AE0:  MOVLW  04
2AE2:  MOVWF  01
2AE4:  BRA    2AEC
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2AE6:  BRA    2AEC
2AE8:  MOVLW  FF
2AEA:  MOVWF  01
.................... } 
2AEC:  MOVLB  0
2AEE:  GOTO   3338 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
2AF2:  MOVLB  8
2AF4:  CLRF   x37
2AF6:  CLRF   x36
2AF8:  CLRF   x35
2AFA:  CLRF   x34
2AFC:  CLRF   x3B
2AFE:  CLRF   x3A
2B00:  CLRF   x39
2B02:  CLRF   x38
2B04:  CLRF   x3F
2B06:  CLRF   x3E
2B08:  CLRF   x3D
2B0A:  CLRF   x3C
2B0C:  CLRF   x43
2B0E:  CLRF   x42
2B10:  CLRF   x41
2B12:  CLRF   x40
2B14:  CLRF   x47
2B16:  CLRF   x46
2B18:  CLRF   x45
2B1A:  CLRF   x44
2B1C:  CLRF   x4B
2B1E:  CLRF   x4A
2B20:  CLRF   x49
2B22:  CLRF   x48
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2B24:  CLRF   x33
2B26:  CLRF   x32
2B28:  MOVF   x33,W
2B2A:  SUBLW  01
2B2C:  BNC   2BCC
2B2E:  BNZ   2B36
2B30:  MOVF   x32,W
2B32:  SUBLW  F3
2B34:  BNC   2BCC
....................    { 
....................       col_0=read_col(0)+col_0; 
2B36:  CLRF   x4C
2B38:  MOVLB  0
2B3A:  CALL   2264
2B3E:  MOVF   01,W
2B40:  MOVLB  8
2B42:  ADDWF  x34,F
2B44:  MOVLW  00
2B46:  ADDWFC x35,F
2B48:  ADDWFC x36,F
2B4A:  ADDWFC x37,F
....................       col_1=read_col(1)+col_1; 
2B4C:  MOVLW  01
2B4E:  MOVWF  x4C
2B50:  MOVLB  0
2B52:  CALL   2264
2B56:  MOVF   01,W
2B58:  MOVLB  8
2B5A:  ADDWF  x38,F
2B5C:  MOVLW  00
2B5E:  ADDWFC x39,F
2B60:  ADDWFC x3A,F
2B62:  ADDWFC x3B,F
....................       col_2=read_col(2)+col_2; 
2B64:  MOVLW  02
2B66:  MOVWF  x4C
2B68:  MOVLB  0
2B6A:  CALL   2264
2B6E:  MOVF   01,W
2B70:  MOVLB  8
2B72:  ADDWF  x3C,F
2B74:  MOVLW  00
2B76:  ADDWFC x3D,F
2B78:  ADDWFC x3E,F
2B7A:  ADDWFC x3F,F
....................       col_3=read_col(3)+col_3; 
2B7C:  MOVLW  03
2B7E:  MOVWF  x4C
2B80:  MOVLB  0
2B82:  CALL   2264
2B86:  MOVF   01,W
2B88:  MOVLB  8
2B8A:  ADDWF  x40,F
2B8C:  MOVLW  00
2B8E:  ADDWFC x41,F
2B90:  ADDWFC x42,F
2B92:  ADDWFC x43,F
....................       col_4=read_col(4)+col_4; 
2B94:  MOVLW  04
2B96:  MOVWF  x4C
2B98:  MOVLB  0
2B9A:  CALL   2264
2B9E:  MOVF   01,W
2BA0:  MOVLB  8
2BA2:  ADDWF  x44,F
2BA4:  MOVLW  00
2BA6:  ADDWFC x45,F
2BA8:  ADDWFC x46,F
2BAA:  ADDWFC x47,F
....................       col_5=read_col(5)+col_5; 
2BAC:  MOVLW  05
2BAE:  MOVWF  x4C
2BB0:  MOVLB  0
2BB2:  CALL   2264
2BB6:  MOVF   01,W
2BB8:  MOVLB  8
2BBA:  ADDWF  x48,F
2BBC:  MOVLW  00
2BBE:  ADDWFC x49,F
2BC0:  ADDWFC x4A,F
2BC2:  ADDWFC x4B,F
....................    } 
2BC4:  INCF   x32,F
2BC6:  BTFSC  FD8.2
2BC8:  INCF   x33,F
2BCA:  BRA    2B28
....................    col_0=col_0/500; 
2BCC:  BCF    FD8.1
2BCE:  MOVFF  837,85B
2BD2:  MOVFF  836,85A
2BD6:  MOVFF  835,859
2BDA:  MOVFF  834,858
2BDE:  CLRF   x5F
2BE0:  CLRF   x5E
2BE2:  MOVLW  01
2BE4:  MOVWF  x5D
2BE6:  MOVLW  F4
2BE8:  MOVWF  x5C
2BEA:  MOVLB  0
2BEC:  CALL   2372
2BF0:  MOVFF  03,837
2BF4:  MOVFF  02,836
2BF8:  MOVFF  01,835
2BFC:  MOVFF  00,834
....................    col_1=col_1/500; 
2C00:  BCF    FD8.1
2C02:  MOVFF  83B,85B
2C06:  MOVFF  83A,85A
2C0A:  MOVFF  839,859
2C0E:  MOVFF  838,858
2C12:  MOVLB  8
2C14:  CLRF   x5F
2C16:  CLRF   x5E
2C18:  MOVLW  01
2C1A:  MOVWF  x5D
2C1C:  MOVLW  F4
2C1E:  MOVWF  x5C
2C20:  MOVLB  0
2C22:  CALL   2372
2C26:  MOVFF  03,83B
2C2A:  MOVFF  02,83A
2C2E:  MOVFF  01,839
2C32:  MOVFF  00,838
....................    col_2=col_2/500; 
2C36:  BCF    FD8.1
2C38:  MOVFF  83F,85B
2C3C:  MOVFF  83E,85A
2C40:  MOVFF  83D,859
2C44:  MOVFF  83C,858
2C48:  MOVLB  8
2C4A:  CLRF   x5F
2C4C:  CLRF   x5E
2C4E:  MOVLW  01
2C50:  MOVWF  x5D
2C52:  MOVLW  F4
2C54:  MOVWF  x5C
2C56:  MOVLB  0
2C58:  CALL   2372
2C5C:  MOVFF  03,83F
2C60:  MOVFF  02,83E
2C64:  MOVFF  01,83D
2C68:  MOVFF  00,83C
....................    col_3=col_3/500; 
2C6C:  BCF    FD8.1
2C6E:  MOVFF  843,85B
2C72:  MOVFF  842,85A
2C76:  MOVFF  841,859
2C7A:  MOVFF  840,858
2C7E:  MOVLB  8
2C80:  CLRF   x5F
2C82:  CLRF   x5E
2C84:  MOVLW  01
2C86:  MOVWF  x5D
2C88:  MOVLW  F4
2C8A:  MOVWF  x5C
2C8C:  MOVLB  0
2C8E:  CALL   2372
2C92:  MOVFF  03,843
2C96:  MOVFF  02,842
2C9A:  MOVFF  01,841
2C9E:  MOVFF  00,840
....................    col_4=col_4/500; 
2CA2:  BCF    FD8.1
2CA4:  MOVFF  847,85B
2CA8:  MOVFF  846,85A
2CAC:  MOVFF  845,859
2CB0:  MOVFF  844,858
2CB4:  MOVLB  8
2CB6:  CLRF   x5F
2CB8:  CLRF   x5E
2CBA:  MOVLW  01
2CBC:  MOVWF  x5D
2CBE:  MOVLW  F4
2CC0:  MOVWF  x5C
2CC2:  MOVLB  0
2CC4:  CALL   2372
2CC8:  MOVFF  03,847
2CCC:  MOVFF  02,846
2CD0:  MOVFF  01,845
2CD4:  MOVFF  00,844
....................    col_5=col_5/500; 
2CD8:  BCF    FD8.1
2CDA:  MOVFF  84B,85B
2CDE:  MOVFF  84A,85A
2CE2:  MOVFF  849,859
2CE6:  MOVFF  848,858
2CEA:  MOVLB  8
2CEC:  CLRF   x5F
2CEE:  CLRF   x5E
2CF0:  MOVLW  01
2CF2:  MOVWF  x5D
2CF4:  MOVLW  F4
2CF6:  MOVWF  x5C
2CF8:  MOVLB  0
2CFA:  CALL   2372
2CFE:  MOVFF  03,84B
2D02:  MOVFF  02,84A
2D06:  MOVFF  01,849
2D0A:  MOVFF  00,848
....................    if(keydebug_en) 
2D0E:  MOVLB  1
2D10:  MOVF   x4C,F
2D12:  BTFSC  FD8.2
2D14:  BRA    2EDE
....................    { 
....................       fprintf(COM2,"\r\n");      
2D16:  MOVLW  0D
2D18:  MOVLB  8
2D1A:  MOVWF  x58
2D1C:  MOVLB  0
2D1E:  CALL   069C
2D22:  MOVLW  0A
2D24:  MOVLB  8
2D26:  MOVWF  x58
2D28:  MOVLB  0
2D2A:  CALL   069C
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2D2E:  MOVLW  38
2D30:  MOVWF  FF6
2D32:  MOVLW  05
2D34:  MOVWF  FF7
2D36:  MOVLW  07
2D38:  MOVLB  8
2D3A:  MOVWF  x4C
2D3C:  MOVLB  0
2D3E:  CALL   165A
2D42:  MOVLW  41
2D44:  MOVWF  FE9
2D46:  MOVFF  837,84F
2D4A:  MOVFF  836,84E
2D4E:  MOVFF  835,84D
2D52:  MOVFF  834,84C
2D56:  CALL   2406
2D5A:  MOVLW  0D
2D5C:  MOVLB  8
2D5E:  MOVWF  x58
2D60:  MOVLB  0
2D62:  CALL   069C
2D66:  MOVLW  0A
2D68:  MOVLB  8
2D6A:  MOVWF  x58
2D6C:  MOVLB  0
2D6E:  CALL   069C
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2D72:  MOVLW  46
2D74:  MOVWF  FF6
2D76:  MOVLW  05
2D78:  MOVWF  FF7
2D7A:  MOVLW  07
2D7C:  MOVLB  8
2D7E:  MOVWF  x4C
2D80:  MOVLB  0
2D82:  CALL   165A
2D86:  MOVLW  41
2D88:  MOVWF  FE9
2D8A:  MOVFF  83B,84F
2D8E:  MOVFF  83A,84E
2D92:  MOVFF  839,84D
2D96:  MOVFF  838,84C
2D9A:  CALL   2406
2D9E:  MOVLW  0D
2DA0:  MOVLB  8
2DA2:  MOVWF  x58
2DA4:  MOVLB  0
2DA6:  CALL   069C
2DAA:  MOVLW  0A
2DAC:  MOVLB  8
2DAE:  MOVWF  x58
2DB0:  MOVLB  0
2DB2:  CALL   069C
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2DB6:  MOVLW  54
2DB8:  MOVWF  FF6
2DBA:  MOVLW  05
2DBC:  MOVWF  FF7
2DBE:  MOVLW  07
2DC0:  MOVLB  8
2DC2:  MOVWF  x4C
2DC4:  MOVLB  0
2DC6:  CALL   165A
2DCA:  MOVLW  41
2DCC:  MOVWF  FE9
2DCE:  MOVFF  83F,84F
2DD2:  MOVFF  83E,84E
2DD6:  MOVFF  83D,84D
2DDA:  MOVFF  83C,84C
2DDE:  CALL   2406
2DE2:  MOVLW  0D
2DE4:  MOVLB  8
2DE6:  MOVWF  x58
2DE8:  MOVLB  0
2DEA:  CALL   069C
2DEE:  MOVLW  0A
2DF0:  MOVLB  8
2DF2:  MOVWF  x58
2DF4:  MOVLB  0
2DF6:  CALL   069C
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2DFA:  MOVLW  62
2DFC:  MOVWF  FF6
2DFE:  MOVLW  05
2E00:  MOVWF  FF7
2E02:  MOVLW  07
2E04:  MOVLB  8
2E06:  MOVWF  x4C
2E08:  MOVLB  0
2E0A:  CALL   165A
2E0E:  MOVLW  41
2E10:  MOVWF  FE9
2E12:  MOVFF  843,84F
2E16:  MOVFF  842,84E
2E1A:  MOVFF  841,84D
2E1E:  MOVFF  840,84C
2E22:  CALL   2406
2E26:  MOVLW  0D
2E28:  MOVLB  8
2E2A:  MOVWF  x58
2E2C:  MOVLB  0
2E2E:  CALL   069C
2E32:  MOVLW  0A
2E34:  MOVLB  8
2E36:  MOVWF  x58
2E38:  MOVLB  0
2E3A:  CALL   069C
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2E3E:  MOVLW  70
2E40:  MOVWF  FF6
2E42:  MOVLW  05
2E44:  MOVWF  FF7
2E46:  MOVLW  07
2E48:  MOVLB  8
2E4A:  MOVWF  x4C
2E4C:  MOVLB  0
2E4E:  CALL   165A
2E52:  MOVLW  41
2E54:  MOVWF  FE9
2E56:  MOVFF  847,84F
2E5A:  MOVFF  846,84E
2E5E:  MOVFF  845,84D
2E62:  MOVFF  844,84C
2E66:  CALL   2406
2E6A:  MOVLW  0D
2E6C:  MOVLB  8
2E6E:  MOVWF  x58
2E70:  MOVLB  0
2E72:  CALL   069C
2E76:  MOVLW  0A
2E78:  MOVLB  8
2E7A:  MOVWF  x58
2E7C:  MOVLB  0
2E7E:  CALL   069C
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2E82:  MOVLW  7E
2E84:  MOVWF  FF6
2E86:  MOVLW  05
2E88:  MOVWF  FF7
2E8A:  MOVLW  07
2E8C:  MOVLB  8
2E8E:  MOVWF  x4C
2E90:  MOVLB  0
2E92:  CALL   165A
2E96:  MOVLW  41
2E98:  MOVWF  FE9
2E9A:  MOVFF  84B,84F
2E9E:  MOVFF  84A,84E
2EA2:  MOVFF  849,84D
2EA6:  MOVFF  848,84C
2EAA:  CALL   2406
2EAE:  MOVLW  0D
2EB0:  MOVLB  8
2EB2:  MOVWF  x58
2EB4:  MOVLB  0
2EB6:  CALL   069C
2EBA:  MOVLW  0A
2EBC:  MOVLB  8
2EBE:  MOVWF  x58
2EC0:  MOVLB  0
2EC2:  CALL   069C
....................       fprintf(COM2,"\r\n"); 
2EC6:  MOVLW  0D
2EC8:  MOVLB  8
2ECA:  MOVWF  x58
2ECC:  MOVLB  0
2ECE:  CALL   069C
2ED2:  MOVLW  0A
2ED4:  MOVLB  8
2ED6:  MOVWF  x58
2ED8:  MOVLB  0
2EDA:  CALL   069C
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2EDE:  MOVLB  8
2EE0:  MOVF   x37,F
2EE2:  BNZ   2EF2
2EE4:  MOVF   x36,F
2EE6:  BNZ   2EF2
2EE8:  MOVF   x35,F
2EEA:  BNZ   2EF2
2EEC:  MOVF   x34,W
2EEE:  SUBLW  05
2EF0:  BC    2F64
2EF2:  MOVF   x37,F
2EF4:  BNZ   2F64
2EF6:  MOVF   x36,F
2EF8:  BNZ   2F64
2EFA:  MOVF   x35,F
2EFC:  BNZ   2F64
2EFE:  MOVF   x34,W
2F00:  SUBLW  3B
2F02:  BNC   2F64
2F04:  MOVF   x3B,F
2F06:  BNZ   2F16
2F08:  MOVF   x3A,F
2F0A:  BNZ   2F16
2F0C:  MOVF   x39,F
2F0E:  BNZ   2F16
2F10:  MOVF   x38,W
2F12:  SUBLW  64
2F14:  BC    2F64
2F16:  MOVF   x3F,F
2F18:  BNZ   2F28
2F1A:  MOVF   x3E,F
2F1C:  BNZ   2F28
2F1E:  MOVF   x3D,F
2F20:  BNZ   2F28
2F22:  MOVF   x3C,W
2F24:  SUBLW  64
2F26:  BC    2F64
2F28:  MOVF   x43,F
2F2A:  BNZ   2F3A
2F2C:  MOVF   x42,F
2F2E:  BNZ   2F3A
2F30:  MOVF   x41,F
2F32:  BNZ   2F3A
2F34:  MOVF   x40,W
2F36:  SUBLW  64
2F38:  BC    2F64
2F3A:  MOVF   x47,F
2F3C:  BNZ   2F4C
2F3E:  MOVF   x46,F
2F40:  BNZ   2F4C
2F42:  MOVF   x45,F
2F44:  BNZ   2F4C
2F46:  MOVF   x44,W
2F48:  SUBLW  64
2F4A:  BC    2F64
2F4C:  MOVF   x4B,F
2F4E:  BNZ   2F5E
2F50:  MOVF   x4A,F
2F52:  BNZ   2F5E
2F54:  MOVF   x49,F
2F56:  BNZ   2F5E
2F58:  MOVF   x48,W
2F5A:  SUBLW  64
2F5C:  BC    2F64
2F5E:  MOVLW  00
2F60:  MOVWF  01
2F62:  BRA    32DC
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2F64:  MOVF   x3B,F
2F66:  BNZ   2F76
2F68:  MOVF   x3A,F
2F6A:  BNZ   2F76
2F6C:  MOVF   x39,F
2F6E:  BNZ   2F76
2F70:  MOVF   x38,W
2F72:  SUBLW  05
2F74:  BC    2FE8
2F76:  MOVF   x3B,F
2F78:  BNZ   2FE8
2F7A:  MOVF   x3A,F
2F7C:  BNZ   2FE8
2F7E:  MOVF   x39,F
2F80:  BNZ   2FE8
2F82:  MOVF   x38,W
2F84:  SUBLW  3B
2F86:  BNC   2FE8
2F88:  MOVF   x37,F
2F8A:  BNZ   2F9A
2F8C:  MOVF   x36,F
2F8E:  BNZ   2F9A
2F90:  MOVF   x35,F
2F92:  BNZ   2F9A
2F94:  MOVF   x34,W
2F96:  SUBLW  64
2F98:  BC    2FE8
2F9A:  MOVF   x3F,F
2F9C:  BNZ   2FAC
2F9E:  MOVF   x3E,F
2FA0:  BNZ   2FAC
2FA2:  MOVF   x3D,F
2FA4:  BNZ   2FAC
2FA6:  MOVF   x3C,W
2FA8:  SUBLW  64
2FAA:  BC    2FE8
2FAC:  MOVF   x43,F
2FAE:  BNZ   2FBE
2FB0:  MOVF   x42,F
2FB2:  BNZ   2FBE
2FB4:  MOVF   x41,F
2FB6:  BNZ   2FBE
2FB8:  MOVF   x40,W
2FBA:  SUBLW  64
2FBC:  BC    2FE8
2FBE:  MOVF   x47,F
2FC0:  BNZ   2FD0
2FC2:  MOVF   x46,F
2FC4:  BNZ   2FD0
2FC6:  MOVF   x45,F
2FC8:  BNZ   2FD0
2FCA:  MOVF   x44,W
2FCC:  SUBLW  64
2FCE:  BC    2FE8
2FD0:  MOVF   x4B,F
2FD2:  BNZ   2FE2
2FD4:  MOVF   x4A,F
2FD6:  BNZ   2FE2
2FD8:  MOVF   x49,F
2FDA:  BNZ   2FE2
2FDC:  MOVF   x48,W
2FDE:  SUBLW  64
2FE0:  BC    2FE8
2FE2:  MOVLW  01
2FE4:  MOVWF  01
2FE6:  BRA    32DC
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2FE8:  MOVF   x3F,F
2FEA:  BNZ   2FFA
2FEC:  MOVF   x3E,F
2FEE:  BNZ   2FFA
2FF0:  MOVF   x3D,F
2FF2:  BNZ   2FFA
2FF4:  MOVF   x3C,W
2FF6:  SUBLW  05
2FF8:  BC    306C
2FFA:  MOVF   x3F,F
2FFC:  BNZ   306C
2FFE:  MOVF   x3E,F
3000:  BNZ   306C
3002:  MOVF   x3D,F
3004:  BNZ   306C
3006:  MOVF   x3C,W
3008:  SUBLW  3B
300A:  BNC   306C
300C:  MOVF   x3B,F
300E:  BNZ   301E
3010:  MOVF   x3A,F
3012:  BNZ   301E
3014:  MOVF   x39,F
3016:  BNZ   301E
3018:  MOVF   x38,W
301A:  SUBLW  64
301C:  BC    306C
301E:  MOVF   x37,F
3020:  BNZ   3030
3022:  MOVF   x36,F
3024:  BNZ   3030
3026:  MOVF   x35,F
3028:  BNZ   3030
302A:  MOVF   x34,W
302C:  SUBLW  64
302E:  BC    306C
3030:  MOVF   x43,F
3032:  BNZ   3042
3034:  MOVF   x42,F
3036:  BNZ   3042
3038:  MOVF   x41,F
303A:  BNZ   3042
303C:  MOVF   x40,W
303E:  SUBLW  64
3040:  BC    306C
3042:  MOVF   x47,F
3044:  BNZ   3054
3046:  MOVF   x46,F
3048:  BNZ   3054
304A:  MOVF   x45,F
304C:  BNZ   3054
304E:  MOVF   x44,W
3050:  SUBLW  64
3052:  BC    306C
3054:  MOVF   x4B,F
3056:  BNZ   3066
3058:  MOVF   x4A,F
305A:  BNZ   3066
305C:  MOVF   x49,F
305E:  BNZ   3066
3060:  MOVF   x48,W
3062:  SUBLW  64
3064:  BC    306C
3066:  MOVLW  02
3068:  MOVWF  01
306A:  BRA    32DC
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
306C:  MOVF   x43,F
306E:  BNZ   307E
3070:  MOVF   x42,F
3072:  BNZ   307E
3074:  MOVF   x41,F
3076:  BNZ   307E
3078:  MOVF   x40,W
307A:  SUBLW  05
307C:  BC    30F0
307E:  MOVF   x43,F
3080:  BNZ   30F0
3082:  MOVF   x42,F
3084:  BNZ   30F0
3086:  MOVF   x41,F
3088:  BNZ   30F0
308A:  MOVF   x40,W
308C:  SUBLW  3B
308E:  BNC   30F0
3090:  MOVF   x3B,F
3092:  BNZ   30A2
3094:  MOVF   x3A,F
3096:  BNZ   30A2
3098:  MOVF   x39,F
309A:  BNZ   30A2
309C:  MOVF   x38,W
309E:  SUBLW  64
30A0:  BC    30F0
30A2:  MOVF   x3F,F
30A4:  BNZ   30B4
30A6:  MOVF   x3E,F
30A8:  BNZ   30B4
30AA:  MOVF   x3D,F
30AC:  BNZ   30B4
30AE:  MOVF   x3C,W
30B0:  SUBLW  64
30B2:  BC    30F0
30B4:  MOVF   x37,F
30B6:  BNZ   30C6
30B8:  MOVF   x36,F
30BA:  BNZ   30C6
30BC:  MOVF   x35,F
30BE:  BNZ   30C6
30C0:  MOVF   x34,W
30C2:  SUBLW  64
30C4:  BC    30F0
30C6:  MOVF   x47,F
30C8:  BNZ   30D8
30CA:  MOVF   x46,F
30CC:  BNZ   30D8
30CE:  MOVF   x45,F
30D0:  BNZ   30D8
30D2:  MOVF   x44,W
30D4:  SUBLW  64
30D6:  BC    30F0
30D8:  MOVF   x4B,F
30DA:  BNZ   30EA
30DC:  MOVF   x4A,F
30DE:  BNZ   30EA
30E0:  MOVF   x49,F
30E2:  BNZ   30EA
30E4:  MOVF   x48,W
30E6:  SUBLW  64
30E8:  BC    30F0
30EA:  MOVLW  03
30EC:  MOVWF  01
30EE:  BRA    32DC
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
30F0:  MOVF   x47,F
30F2:  BNZ   3102
30F4:  MOVF   x46,F
30F6:  BNZ   3102
30F8:  MOVF   x45,F
30FA:  BNZ   3102
30FC:  MOVF   x44,W
30FE:  SUBLW  05
3100:  BC    3174
3102:  MOVF   x47,F
3104:  BNZ   3174
3106:  MOVF   x46,F
3108:  BNZ   3174
310A:  MOVF   x45,F
310C:  BNZ   3174
310E:  MOVF   x44,W
3110:  SUBLW  3B
3112:  BNC   3174
3114:  MOVF   x3B,F
3116:  BNZ   3126
3118:  MOVF   x3A,F
311A:  BNZ   3126
311C:  MOVF   x39,F
311E:  BNZ   3126
3120:  MOVF   x38,W
3122:  SUBLW  64
3124:  BC    3174
3126:  MOVF   x3F,F
3128:  BNZ   3138
312A:  MOVF   x3E,F
312C:  BNZ   3138
312E:  MOVF   x3D,F
3130:  BNZ   3138
3132:  MOVF   x3C,W
3134:  SUBLW  64
3136:  BC    3174
3138:  MOVF   x43,F
313A:  BNZ   314A
313C:  MOVF   x42,F
313E:  BNZ   314A
3140:  MOVF   x41,F
3142:  BNZ   314A
3144:  MOVF   x40,W
3146:  SUBLW  64
3148:  BC    3174
314A:  MOVF   x37,F
314C:  BNZ   315C
314E:  MOVF   x36,F
3150:  BNZ   315C
3152:  MOVF   x35,F
3154:  BNZ   315C
3156:  MOVF   x34,W
3158:  SUBLW  64
315A:  BC    3174
315C:  MOVF   x4B,F
315E:  BNZ   316E
3160:  MOVF   x4A,F
3162:  BNZ   316E
3164:  MOVF   x49,F
3166:  BNZ   316E
3168:  MOVF   x48,W
316A:  SUBLW  64
316C:  BC    3174
316E:  MOVLW  04
3170:  MOVWF  01
3172:  BRA    32DC
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
3174:  MOVF   x4B,F
3176:  BNZ   3186
3178:  MOVF   x4A,F
317A:  BNZ   3186
317C:  MOVF   x49,F
317E:  BNZ   3186
3180:  MOVF   x48,W
3182:  SUBLW  05
3184:  BC    31F8
3186:  MOVF   x4B,F
3188:  BNZ   31F8
318A:  MOVF   x4A,F
318C:  BNZ   31F8
318E:  MOVF   x49,F
3190:  BNZ   31F8
3192:  MOVF   x48,W
3194:  SUBLW  3B
3196:  BNC   31F8
3198:  MOVF   x3B,F
319A:  BNZ   31AA
319C:  MOVF   x3A,F
319E:  BNZ   31AA
31A0:  MOVF   x39,F
31A2:  BNZ   31AA
31A4:  MOVF   x38,W
31A6:  SUBLW  64
31A8:  BC    31F8
31AA:  MOVF   x3F,F
31AC:  BNZ   31BC
31AE:  MOVF   x3E,F
31B0:  BNZ   31BC
31B2:  MOVF   x3D,F
31B4:  BNZ   31BC
31B6:  MOVF   x3C,W
31B8:  SUBLW  64
31BA:  BC    31F8
31BC:  MOVF   x43,F
31BE:  BNZ   31CE
31C0:  MOVF   x42,F
31C2:  BNZ   31CE
31C4:  MOVF   x41,F
31C6:  BNZ   31CE
31C8:  MOVF   x40,W
31CA:  SUBLW  64
31CC:  BC    31F8
31CE:  MOVF   x47,F
31D0:  BNZ   31E0
31D2:  MOVF   x46,F
31D4:  BNZ   31E0
31D6:  MOVF   x45,F
31D8:  BNZ   31E0
31DA:  MOVF   x44,W
31DC:  SUBLW  64
31DE:  BC    31F8
31E0:  MOVF   x37,F
31E2:  BNZ   31F2
31E4:  MOVF   x36,F
31E6:  BNZ   31F2
31E8:  MOVF   x35,F
31EA:  BNZ   31F2
31EC:  MOVF   x34,W
31EE:  SUBLW  64
31F0:  BC    31F8
31F2:  MOVLW  05
31F4:  MOVWF  01
31F6:  BRA    32DC
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
31F8:  MOVF   x4B,F
31FA:  BNZ   320C
31FC:  MOVF   x4A,F
31FE:  BNZ   320C
3200:  MOVF   x49,F
3202:  BNZ   320C
3204:  MOVF   x48,W
3206:  SUBLW  C8
3208:  BTFSC  FD8.0
320A:  BRA    32D8
320C:  MOVF   x37,F
320E:  BTFSS  FD8.2
3210:  BRA    32D8
3212:  MOVF   x36,F
3214:  BTFSS  FD8.2
3216:  BRA    32D8
3218:  MOVF   x35,F
321A:  BTFSS  FD8.2
321C:  BRA    32D8
321E:  MOVF   x34,W
3220:  SUBLW  B3
3222:  BTFSS  FD8.0
3224:  BRA    32D8
3226:  MOVF   x37,F
3228:  BNZ   323A
322A:  MOVF   x36,F
322C:  BNZ   323A
322E:  MOVF   x35,F
3230:  BNZ   323A
3232:  MOVF   x34,W
3234:  SUBLW  64
3236:  BTFSC  FD8.0
3238:  BRA    32D8
323A:  MOVF   x3B,F
323C:  BTFSS  FD8.2
323E:  BRA    32D8
3240:  MOVF   x3A,F
3242:  BTFSS  FD8.2
3244:  BRA    32D8
3246:  MOVF   x39,F
3248:  BTFSS  FD8.2
324A:  BRA    32D8
324C:  MOVF   x38,W
324E:  SUBLW  B3
3250:  BNC   32D8
3252:  MOVF   x3B,F
3254:  BNZ   3264
3256:  MOVF   x3A,F
3258:  BNZ   3264
325A:  MOVF   x39,F
325C:  BNZ   3264
325E:  MOVF   x38,W
3260:  SUBLW  64
3262:  BC    32D8
3264:  MOVF   x3F,F
3266:  BNZ   32D8
3268:  MOVF   x3E,F
326A:  BNZ   32D8
326C:  MOVF   x3D,F
326E:  BNZ   32D8
3270:  MOVF   x3C,W
3272:  SUBLW  B3
3274:  BNC   32D8
3276:  MOVF   x3F,F
3278:  BNZ   3288
327A:  MOVF   x3E,F
327C:  BNZ   3288
327E:  MOVF   x3D,F
3280:  BNZ   3288
3282:  MOVF   x3C,W
3284:  SUBLW  64
3286:  BC    32D8
3288:  MOVF   x43,F
328A:  BNZ   32D8
328C:  MOVF   x42,F
328E:  BNZ   32D8
3290:  MOVF   x41,F
3292:  BNZ   32D8
3294:  MOVF   x40,W
3296:  SUBLW  B3
3298:  BNC   32D8
329A:  MOVF   x43,F
329C:  BNZ   32AC
329E:  MOVF   x42,F
32A0:  BNZ   32AC
32A2:  MOVF   x41,F
32A4:  BNZ   32AC
32A6:  MOVF   x40,W
32A8:  SUBLW  64
32AA:  BC    32D8
32AC:  MOVF   x47,F
32AE:  BNZ   32D8
32B0:  MOVF   x46,F
32B2:  BNZ   32D8
32B4:  MOVF   x45,F
32B6:  BNZ   32D8
32B8:  MOVF   x44,W
32BA:  SUBLW  B3
32BC:  BNC   32D8
32BE:  MOVF   x47,F
32C0:  BNZ   32D0
32C2:  MOVF   x46,F
32C4:  BNZ   32D0
32C6:  MOVF   x45,F
32C8:  BNZ   32D0
32CA:  MOVF   x44,W
32CC:  SUBLW  64
32CE:  BC    32D8
32D0:  MOVLW  05
32D2:  MOVWF  01
32D4:  BRA    32DC
....................    else return 0xff; 
32D6:  BRA    32DC
32D8:  MOVLW  FF
32DA:  MOVWF  01
.................... } 
32DC:  MOVLB  0
32DE:  GOTO   3344 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
32E2:  MOVLW  20
32E4:  MOVLB  8
32E6:  MOVWF  x30
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
32E8:  BSF    F93.4
32EA:  BTFSS  F81.4
32EC:  BRA    3300
32EE:  BSF    F93.5
32F0:  BTFSS  F81.5
32F2:  BRA    3300
32F4:  BSF    F93.6
32F6:  BTFSS  F81.6
32F8:  BRA    3300
32FA:  BSF    F93.7
32FC:  BTFSC  F81.7
32FE:  BRA    346A
....................     { 
....................        if(input(ROW0)==0) 
3300:  BSF    F93.4
3302:  BTFSC  F81.4
3304:  BRA    330A
....................          row=0; 
3306:  CLRF   x31
....................        else if(input(ROW1)==0) 
3308:  BRA    332C
330A:  BSF    F93.5
330C:  BTFSC  F81.5
330E:  BRA    3316
....................          row=1; 
3310:  MOVLW  01
3312:  MOVWF  x31
....................        else if(input(ROW2)==0) 
3314:  BRA    332C
3316:  BSF    F93.6
3318:  BTFSC  F81.6
331A:  BRA    3322
....................          row=2; 
331C:  MOVLW  02
331E:  MOVWF  x31
....................        else if(input(ROW3)==0) 
3320:  BRA    332C
3322:  BSF    F93.7
3324:  BTFSC  F81.7
3326:  BRA    332C
....................          row=3;      
3328:  MOVLW  03
332A:  MOVWF  x31
....................        if(type_KB==0)col=check_col(); 
332C:  MOVLB  1
332E:  MOVF   x54,F
3330:  BNZ   333E
3332:  MOVLB  0
3334:  GOTO   24C6
3338:  MOVFF  01,82F
....................          else col=new_check_col(); 
333C:  BRA    3348
333E:  MOVLB  0
3340:  GOTO   2AF2
3344:  MOVFF  01,82F
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
3348:  MOVLB  8
334A:  INCFSZ x2F,W
334C:  BRA    3350
334E:  BRA    343A
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
3350:  MOVLB  1
3352:  MOVF   x54,F
3354:  BNZ   337C
3356:  MOVLB  8
3358:  MOVF   x31,W
335A:  MULLW  05
335C:  MOVF   FF3,W
335E:  CLRF   x33
3360:  MOVWF  x32
3362:  CLRF   03
3364:  MOVF   x2F,W
3366:  ADDWF  x32,W
3368:  MOVWF  01
336A:  MOVF   x33,W
336C:  ADDWFC 03,F
336E:  MOVF   01,W
3370:  MOVLB  0
3372:  CALL   030A
3376:  MOVFF  FE8,830
....................            else kchar =newKEYS[row][col]; 
337A:  BRA    33A0
337C:  MOVLB  8
337E:  MOVF   x31,W
3380:  MULLW  06
3382:  MOVF   FF3,W
3384:  CLRF   x33
3386:  MOVWF  x32
3388:  CLRF   03
338A:  MOVF   x2F,W
338C:  ADDWF  x32,W
338E:  MOVWF  01
3390:  MOVF   x33,W
3392:  ADDWFC 03,F
3394:  MOVF   01,W
3396:  MOVLB  0
3398:  CALL   032E
339C:  MOVFF  FE8,830
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
33A0:  MOVLB  1
33A2:  MOVF   x4C,F
33A4:  BNZ   342C
....................             { 
....................               charac_timeout=0; 
33A6:  MOVLB  0
33A8:  CLRF   xFC
33AA:  CLRF   xFB
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
33AC:  MOVLB  1
33AE:  MOVF   x4F,W
33B0:  SUBLW  0B
33B2:  BNC   33C8
33B4:  MOVF   x4F,W
33B6:  INCF   x4F,F
33B8:  CLRF   03
33BA:  ADDLW  55
33BC:  MOVWF  FE9
33BE:  MOVLW  01
33C0:  ADDWFC 03,W
33C2:  MOVWF  FEA
33C4:  MOVFF  830,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
33C8:  MOVLW  8C
33CA:  MOVWF  FF6
33CC:  MOVLW  05
33CE:  MOVWF  FF7
33D0:  MOVLW  09
33D2:  MOVLB  8
33D4:  MOVWF  x4C
33D6:  MOVLB  0
33D8:  CALL   165A
33DC:  MOVFF  14F,838
33E0:  MOVLW  18
33E2:  MOVLB  8
33E4:  MOVWF  x39
33E6:  MOVLB  0
33E8:  CALL   176E
33EC:  MOVLW  5D
33EE:  MOVLB  8
33F0:  MOVWF  x58
33F2:  MOVLB  0
33F4:  CALL   069C
33F8:  MOVLW  20
33FA:  MOVLB  8
33FC:  MOVWF  x58
33FE:  MOVLB  0
3400:  CALL   069C
3404:  MOVFF  830,858
3408:  CALL   069C
340C:  MOVLW  0D
340E:  MOVLB  8
3410:  MOVWF  x58
3412:  MOVLB  0
3414:  CALL   069C
3418:  MOVLW  0A
341A:  MOVLB  8
341C:  MOVWF  x58
341E:  MOVLB  0
3420:  CALL   069C
....................                count_checking=0; 
3424:  MOVLB  1
3426:  CLRF   x07
3428:  CLRF   x06
....................             } 
....................                else fputc(kchar,COM2); 
342A:  BRA    3438
342C:  MOVFF  830,858
3430:  MOVLB  0
3432:  CALL   069C
3436:  MOVLB  1
3438:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
343A:  BSF    F93.4
343C:  BTFSS  F81.4
343E:  BRA    343A
3440:  BSF    F93.5
3442:  BTFSS  F81.5
3444:  BRA    343A
3446:  BSF    F93.6
3448:  BTFSS  F81.6
344A:  BRA    343A
344C:  BSF    F93.7
344E:  BTFSS  F81.7
3450:  BRA    343A
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3452:  BSF    F93.4
3454:  BTFSS  F81.4
3456:  BRA    3452
3458:  BSF    F93.5
345A:  BTFSS  F81.5
345C:  BRA    3452
345E:  BSF    F93.6
3460:  BTFSS  F81.6
3462:  BRA    3452
3464:  BSF    F93.7
3466:  BTFSS  F81.7
3468:  BRA    3452
....................     } 
....................   set_tris_a(0xff);     
346A:  MOVLW  FF
346C:  MOVWF  F92
....................   return(kchar); 
346E:  MOVFF  830,01
.................... }//*/ 
3472:  MOVLB  0
3474:  RETURN 0
.................... //============================================ 
.................... //=========================================================== 
.................... #if 0 
.................... void write_kb_i2ceeprom(void) 
.................... { 
....................       unsigned long adr; 
....................       unsigned int i; 
....................       unsigned int crc; 
....................       char rec[34]; 
....................       char retval; 
....................  
....................       RTC_get_time();                                 /* Lecture de l'heure actuelle */ 
....................  
....................       rec[0]=33;                                    /* Prochaine chaine dans 33 cars. */ 
....................       rec[1]=32;                                    /* Nombre de bytes de la chaine */ 
....................       rec[2]=(unsigned char)((heure_actuelle.annee)-2000);   /* Année en byte */ 
....................       rec[3]=heure_actuelle.mois;                        /* Mois en byte */ 
....................       rec[4]=heure_actuelle.jour;                        /* Jour en byte */ 
....................       rec[5]=heure_actuelle.heure;                     /* Heure en byte */ 
....................       rec[6]=heure_actuelle.minute;                     /* Minute en byte */ 
....................       rec[7]=heure_actuelle.seconde;                     /* Seconde en byte */ 
....................  
....................       rec[8]=0x01;                                 /* Type Clavier */ 
....................  
....................       for(i=0;i<KB_char_cnt && i<12;i++)   /* Copie du nombre de byte dans le tampon de clavier */ 
....................          rec[9+i]=KB_buf[i]; 
....................  
....................       i=i+9;                  /* Ajout des 8 bytes pour l'entête + 1 byte pour le pointeur  */ 
....................     
....................       while(i<33)               /* Mettre des 0 comme "padding" */ 
....................       { 
....................          rec[i]=0x00; 
....................          i++; 
....................       } 
....................  
....................       crc=crcccitt(0, &rec[1], 30);   /* Calcul du CRC 16 (CCITT) de la chaine */ 
....................  
....................       rec[31]=(unsigned char)(crc & 0x00FF); 
....................       rec[32]=(unsigned char)((crc & 0xFF00)>>8); 
....................  
....................       rec[33]=0xFF;            /* Terminaison de la liste par 0xFF */ 
....................  
....................       /** Encryption de la chaine */ 
....................       rijndael('c', (unsigned char *)&rec[1], (unsigned char *)&crypto_key[0]); 
....................       rijndael('c', (unsigned char *)&rec[17], (unsigned char *)&crypto_key[16]); 
....................  
....................       read_eeptr(&adr);         /* Lecture de l'adresse de fin de liste */ 
....................  
....................       retval=I2CEEPROM_write(adr,34,rec);   /* Écriture de la chaine */ 
....................  
....................       if(retval!=0) 
....................          write_eeptr(adr+33);         /* Ajuster le pointeur d'ajout de chaine dans la liste  */ 
....................  
.................... } 
.................... #endif 
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 rec[16]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
4BFA:  MOVF   27,F
4BFC:  BTFSS  FD8.2
4BFE:  BRA    4E34
4C00:  MOVF   26,W
4C02:  SUBLW  01
4C04:  BTFSS  FD8.0
4C06:  BRA    4E34
4C08:  BNZ   4C1C
4C0A:  MOVF   25,W
4C0C:  SUBLW  FF
4C0E:  BTFSS  FD8.0
4C10:  BRA    4E34
4C12:  BNZ   4C1C
4C14:  MOVF   24,W
4C16:  SUBLW  FE
4C18:  BTFSS  FD8.0
4C1A:  BRA    4E34
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
4C1C:  MOVLB  1
4C1E:  MOVF   x55,F
4C20:  BNZ   4C28
4C22:  MOVF   x4F,F
4C24:  BTFSC  FD8.2
4C26:  BRA    4D9A
....................       {    
....................          for(i=0;i<key_numbyte;i++) 
4C28:  MOVLB  7
4C2A:  CLRF   xC1
4C2C:  MOVF   xC1,W
4C2E:  SUBLW  0B
4C30:  BNC   4C90
....................          { 
....................             temp=key_data[i]; 
4C32:  CLRF   03
4C34:  MOVF   xC1,W
4C36:  ADDLW  55
4C38:  MOVWF  FE9
4C3A:  MOVLW  01
4C3C:  ADDWFC 03,W
4C3E:  MOVWF  FEA
4C40:  CLRF   xC3
4C42:  MOVFF  FEF,7C2
4C46:  CLRF   19
4C48:  BTFSC  FF2.7
4C4A:  BSF    19.7
4C4C:  BCF    FF2.7
....................             fputc(temp,COM2); 
4C4E:  MOVFF  7C2,858
4C52:  MOVLB  0
4C54:  CALL   069C
4C58:  BTFSC  19.7
4C5A:  BSF    FF2.7
....................             rec[i]=key_data[i]; 
4C5C:  CLRF   03
4C5E:  MOVLB  7
4C60:  MOVF   xC1,W
4C62:  ADDLW  C5
4C64:  MOVWF  01
4C66:  MOVLW  07
4C68:  ADDWFC 03,F
4C6A:  MOVFF  03,7D6
4C6E:  CLRF   03
4C70:  MOVF   xC1,W
4C72:  ADDLW  55
4C74:  MOVWF  FE9
4C76:  MOVLW  01
4C78:  ADDWFC 03,W
4C7A:  MOVWF  FEA
4C7C:  MOVFF  FEF,7D7
4C80:  MOVFF  7D6,FEA
4C84:  MOVFF  01,FE9
4C88:  MOVFF  7D7,FEF
....................          } 
4C8C:  INCF   xC1,F
4C8E:  BRA    4C2C
....................          rec[key_numbyte] = 0; 
4C90:  CLRF   xD1
....................          rec[key_numbyte+1] = 0;          
4C92:  CLRF   xD2
....................          rec[key_numbyte+2] = 0;          
4C94:  CLRF   xD3
....................          rec[key_numbyte+3] = 0; 
4C96:  CLRF   xD4
4C98:  CLRF   19
4C9A:  BTFSC  FF2.7
4C9C:  BSF    19.7
4C9E:  BCF    FF2.7
....................     #if 0 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"test_key:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"\n\rdatain:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2," %x",rec[i]); 
....................          fprintf(COM2,"\n\r"); 
....................     #endif 
....................          //rijndael('c', (unsigned char *)&rec[0], (unsigned char *)&crypto_key[0]); 
....................          //aes_enc_dec((unsigned int8 *)&rec[0], (unsigned int8 *)&crypto_key[0],1); 
....................          //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................           
....................          /* get the pointer of keyboard data */ 
....................          temp=get_countcard(); 
4CA0:  MOVLB  0
4CA2:  CALL   3622
4CA6:  BTFSC  19.7
4CA8:  BSF    FF2.7
4CAA:  MOVFF  02,7C3
4CAE:  MOVFF  01,7C2
....................          ptr_card_key=(int32)(((temp)*16)+EEPROM_KEY_ST); 
4CB2:  MOVLB  7
4CB4:  RLCF   xC2,W
4CB6:  MOVWF  xD5
4CB8:  RLCF   xC3,W
4CBA:  MOVWF  xD6
4CBC:  RLCF   xD5,F
4CBE:  RLCF   xD6,F
4CC0:  RLCF   xD5,F
4CC2:  RLCF   xD6,F
4CC4:  RLCF   xD5,F
4CC6:  RLCF   xD6,F
4CC8:  MOVLW  F0
4CCA:  ANDWF  xD5,F
4CCC:  MOVLW  0E
4CCE:  ADDWF  xD5,F
4CD0:  MOVLW  C3
4CD2:  ADDWFC xD6,F
4CD4:  MOVLW  01
4CD6:  MOVWF  xD7
4CD8:  BCF    FD8.2
4CDA:  BTFSC  FD8.0
4CDC:  INCF   xD7,F
4CDE:  CLRF   xD8
4CE0:  MOVLW  01
4CE2:  ADDWF  xD5,W
4CE4:  MOVWF  00
4CE6:  MOVLW  00
4CE8:  ADDWFC xD6,W
4CEA:  MOVWF  01
4CEC:  MOVLW  00
4CEE:  ADDWFC xD7,W
4CF0:  MOVWF  02
4CF2:  MOVLW  00
4CF4:  ADDWFC xD8,W
4CF6:  MOVWF  27
4CF8:  MOVFF  02,26
4CFC:  MOVFF  01,25
4D00:  MOVFF  00,24
....................           
....................          for(i=0;i<16;i++) fprintf(COM2,"%x",rec[i]); 
4D04:  CLRF   xC1
4D06:  MOVF   xC1,W
4D08:  SUBLW  0F
4D0A:  BNC   4D30
4D0C:  CLRF   03
4D0E:  MOVF   xC1,W
4D10:  ADDLW  C5
4D12:  MOVWF  FE9
4D14:  MOVLW  07
4D16:  ADDWFC 03,W
4D18:  MOVWF  FEA
4D1A:  MOVFF  FEF,7D5
4D1E:  MOVFF  7D5,7D6
4D22:  MOVLW  57
4D24:  MOVWF  xD7
4D26:  MOVLB  0
4D28:  RCALL  4B98
4D2A:  MOVLB  7
4D2C:  INCF   xC1,F
4D2E:  BRA    4D06
....................          retval = EEPROM_write(ptr_card_key,16,rec);   /* Écriture de la chaine */ 
4D30:  MOVFF  27,80F
4D34:  MOVFF  26,80E
4D38:  MOVFF  25,80D
4D3C:  MOVFF  24,80C
4D40:  MOVLB  8
4D42:  CLRF   x13
4D44:  CLRF   x12
4D46:  CLRF   x11
4D48:  MOVLW  10
4D4A:  MOVWF  x10
4D4C:  MOVLW  07
4D4E:  MOVWF  x15
4D50:  MOVLW  C5
4D52:  MOVWF  x14
4D54:  MOVLB  0
4D56:  RCALL  4702
4D58:  MOVFF  01,7C4
....................          if(retval!=0) 
4D5C:  MOVLB  7
4D5E:  MOVF   xC4,F
4D60:  BZ    4D98
....................          { 
....................             ptr_card_key+=16; 
4D62:  MOVLW  10
4D64:  ADDWF  24,F
4D66:  MOVLW  00
4D68:  ADDWFC 25,F
4D6A:  ADDWFC 26,F
4D6C:  ADDWFC 27,F
4D6E:  CLRF   19
4D70:  BTFSC  FF2.7
4D72:  BSF    19.7
4D74:  BCF    FF2.7
....................             save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
4D76:  MOVFF  27,835
4D7A:  MOVFF  26,834
4D7E:  MOVFF  25,833
4D82:  MOVFF  24,832
4D86:  MOVLW  1E
4D88:  MOVLB  8
4D8A:  MOVWF  x36
4D8C:  MOVLB  0
4D8E:  CALL   3BA4
4D92:  BTFSC  19.7
4D94:  BSF    FF2.7
4D96:  MOVLB  7
4D98:  MOVLB  1
....................          }          
....................       } 
....................       key_count_ms=0; 
4D9A:  CLRF   x4F
4D9C:  CLRF   19
4D9E:  BTFSC  FF2.7
4DA0:  BSF    19.7
4DA2:  BCF    FF2.7
....................       del_buf(key_numbyte,key_data); 
4DA4:  MOVLW  0C
4DA6:  MOVLB  8
4DA8:  MOVWF  x3E
4DAA:  MOVLW  01
4DAC:  MOVWF  x40
4DAE:  MOVLW  55
4DB0:  MOVWF  x3F
4DB2:  MOVLB  0
4DB4:  CALL   369C
4DB8:  BTFSC  19.7
4DBA:  BSF    FF2.7
4DBC:  CLRF   19
4DBE:  BTFSC  FF2.7
4DC0:  BSF    19.7
4DC2:  BCF    FF2.7
....................       fprintf(COM2,"\r\n"); 
4DC4:  MOVLW  0D
4DC6:  MOVLB  8
4DC8:  MOVWF  x58
4DCA:  MOVLB  0
4DCC:  CALL   069C
4DD0:  BTFSC  19.7
4DD2:  BSF    FF2.7
4DD4:  CLRF   19
4DD6:  BTFSC  FF2.7
4DD8:  BSF    19.7
4DDA:  BCF    FF2.7
4DDC:  MOVLW  0A
4DDE:  MOVLB  8
4DE0:  MOVWF  x58
4DE2:  MOVLB  0
4DE4:  CALL   069C
4DE8:  BTFSC  19.7
4DEA:  BSF    FF2.7
....................       fprintf(COM2,"Done PIN"); 
4DEC:  MOVLW  9E
4DEE:  MOVWF  FF6
4DF0:  MOVLW  05
4DF2:  MOVWF  FF7
4DF4:  CLRF   19
4DF6:  BTFSC  FF2.7
4DF8:  BSF    19.7
4DFA:  BCF    FF2.7
4DFC:  CALL   06E2
4E00:  BTFSC  19.7
4E02:  BSF    FF2.7
4E04:  CLRF   19
4E06:  BTFSC  FF2.7
4E08:  BSF    19.7
4E0A:  BCF    FF2.7
....................       fprintf(COM2,"\r\n"); 
4E0C:  MOVLW  0D
4E0E:  MOVLB  8
4E10:  MOVWF  x58
4E12:  MOVLB  0
4E14:  CALL   069C
4E18:  BTFSC  19.7
4E1A:  BSF    FF2.7
4E1C:  CLRF   19
4E1E:  BTFSC  FF2.7
4E20:  BSF    19.7
4E22:  BCF    FF2.7
4E24:  MOVLW  0A
4E26:  MOVLB  8
4E28:  MOVWF  x58
4E2A:  MOVLB  0
4E2C:  CALL   069C
4E30:  BTFSC  19.7
4E32:  BSF    FF2.7
....................    } 
.................... } 
4E34:  GOTO   7F20 (RETURN)
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
4054:  MOVF   27,F
4056:  BTFSS  FD8.2
4058:  BRA    41CE
405A:  MOVF   26,W
405C:  SUBLW  01
405E:  BTFSS  FD8.0
4060:  BRA    41CE
4062:  BNZ   4076
4064:  MOVF   25,W
4066:  SUBLW  FF
4068:  BTFSS  FD8.0
406A:  BRA    41CE
406C:  BNZ   4076
406E:  MOVF   24,W
4070:  SUBLW  FE
4072:  BTFSS  FD8.0
4074:  BRA    41CE
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
4076:  MOVLB  1
4078:  MOVF   x55,F
407A:  BNZ   4082
407C:  MOVF   x4F,F
407E:  BTFSC  FD8.2
4080:  BRA    417C
....................       { 
....................          temp=get_countcard(); 
4082:  MOVLB  0
4084:  CALL   3622
4088:  MOVFF  02,831
408C:  MOVFF  01,830
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
4090:  MOVFF  831,835
4094:  MOVFF  830,834
4098:  MOVLB  8
409A:  CLRF   x37
409C:  MOVLW  0C
409E:  MOVWF  x36
40A0:  MOVLB  0
40A2:  CALL   367A
40A6:  MOVFF  02,833
40AA:  MOVFF  01,832
40AE:  MOVLW  0E
40B0:  MOVLB  8
40B2:  ADDWF  x32,F
40B4:  MOVLW  C3
40B6:  ADDWFC x33,F
40B8:  MOVLW  01
40BA:  MOVWF  x34
40BC:  BCF    FD8.2
40BE:  BTFSC  FD8.0
40C0:  INCF   x34,F
40C2:  CLRF   x35
40C4:  MOVLW  01
40C6:  ADDWF  x32,W
40C8:  MOVWF  00
40CA:  MOVLW  00
40CC:  ADDWFC x33,W
40CE:  MOVWF  01
40D0:  MOVLW  00
40D2:  ADDWFC x34,W
40D4:  MOVWF  02
40D6:  MOVLW  00
40D8:  ADDWFC x35,W
40DA:  MOVWF  27
40DC:  MOVFF  02,26
40E0:  MOVFF  01,25
40E4:  MOVFF  00,24
....................          for(i=0;i<key_numbyte-5;i++) 
40E8:  CLRF   x2F
40EA:  MOVF   x2F,W
40EC:  SUBLW  06
40EE:  BNC   414E
....................          { 
....................             temp=key_data[i]; 
40F0:  CLRF   03
40F2:  MOVF   x2F,W
40F4:  ADDLW  55
40F6:  MOVWF  FE9
40F8:  MOVLW  01
40FA:  ADDWFC 03,W
40FC:  MOVWF  FEA
40FE:  CLRF   x31
4100:  MOVFF  FEF,830
....................             write_ext_eeprom((long int)ptr_card_key++,temp); 
4104:  MOVFF  27,03
4108:  MOVFF  26,02
410C:  MOVFF  25,01
4110:  MOVFF  24,00
4114:  MOVLW  01
4116:  ADDWF  24,F
4118:  BTFSC  FD8.0
411A:  INCF   25,F
411C:  BTFSC  FD8.2
411E:  INCF   26,F
4120:  BTFSC  FD8.2
4122:  INCF   27,F
4124:  MOVFF  01,833
4128:  MOVFF  00,832
412C:  CLRF   x43
412E:  CLRF   x42
4130:  MOVFF  01,841
4134:  MOVFF  00,840
4138:  MOVFF  830,844
413C:  MOVLB  0
413E:  RCALL  3AA6
....................             //delay_us(100); 
....................             fputc(temp,COM2); 
4140:  MOVFF  830,858
4144:  CALL   069C
....................          } 
4148:  MOVLB  8
414A:  INCF   x2F,F
414C:  BRA    40EA
....................          /*fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<key_numbyte;i++) 
....................           { 
....................             fprintf(COM2,"read key=%c\n\r",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          write_ext_eeprom((long int)ptr_card_key,0); 
414E:  CLRF   x43
4150:  CLRF   x42
4152:  MOVFF  25,841
4156:  MOVFF  24,840
415A:  CLRF   x44
415C:  MOVLB  0
415E:  RCALL  3AA6
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
4160:  MOVFF  27,835
4164:  MOVFF  26,834
4168:  MOVFF  25,833
416C:  MOVFF  24,832
4170:  MOVLW  1E
4172:  MOVLB  8
4174:  MOVWF  x36
4176:  MOVLB  0
4178:  RCALL  3BA4
417A:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
417C:  CLRF   x4F
....................       del_buf(key_numbyte,key_data); 
417E:  MOVLW  0C
4180:  MOVLB  8
4182:  MOVWF  x3E
4184:  MOVLW  01
4186:  MOVWF  x40
4188:  MOVLW  55
418A:  MOVWF  x3F
418C:  MOVLB  0
418E:  CALL   369C
....................       fprintf(COM2,"\r\n"); 
4192:  MOVLW  0D
4194:  MOVLB  8
4196:  MOVWF  x58
4198:  MOVLB  0
419A:  CALL   069C
419E:  MOVLW  0A
41A0:  MOVLB  8
41A2:  MOVWF  x58
41A4:  MOVLB  0
41A6:  CALL   069C
....................       fprintf(COM2,"Done PIN"); 
41AA:  MOVLW  A8
41AC:  MOVWF  FF6
41AE:  MOVLW  05
41B0:  MOVWF  FF7
41B2:  CALL   06E2
....................       fprintf(COM2,"\r\n"); 
41B6:  MOVLW  0D
41B8:  MOVLB  8
41BA:  MOVWF  x58
41BC:  MOVLB  0
41BE:  CALL   069C
41C2:  MOVLW  0A
41C4:  MOVLB  8
41C6:  MOVWF  x58
41C8:  MOVLB  0
41CA:  CALL   069C
....................    } 
.................... } 
41CE:  GOTO   4492 (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
5AFE:  MOVLB  7
5B00:  CLRF   xFE
5B02:  CLRF   xFD
5B04:  CLRF   xFF
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
5B06:  MOVF   xFE,F
5B08:  BTFSS  FD8.2
5B0A:  BRA    5C2E
5B0C:  MOVF   xF8,W
5B0E:  SUBWF  xFD,W
5B10:  BTFSC  FD8.0
5B12:  BRA    5C2E
5B14:  MOVF   xFF,F
5B16:  BTFSS  FD8.2
5B18:  BRA    5C2E
....................       c = fgetc(COM2);//getc(); 
5B1A:  MOVLB  0
5B1C:  RCALL  5AB0
5B1E:  MOVFF  01,7FB
....................       switch(c) 
....................       { 
5B22:  MOVLB  7
5B24:  MOVF   xFB,W
5B26:  XORLW  7F
5B28:  MOVLB  0
5B2A:  BZ    5B32
5B2C:  XORLW  72
5B2E:  BZ    5B80
5B30:  BRA    5BBE
....................          case 0x7f:    
....................             if(nbcar>0)   
5B32:  MOVLB  7
5B34:  MOVF   xFD,F
5B36:  BNZ   5B3C
5B38:  MOVF   xFE,F
5B3A:  BZ    5B66
5B3C:  CLRF   19
5B3E:  BTFSC  FF2.7
5B40:  BSF    19.7
5B42:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
5B44:  MOVLW  7F
5B46:  MOVLB  8
5B48:  MOVWF  x58
5B4A:  MOVLB  0
5B4C:  CALL   069C
5B50:  BTFSC  19.7
5B52:  BSF    FF2.7
....................                nbcar--; 
5B54:  MOVLB  7
5B56:  MOVF   xFD,W
5B58:  BTFSC  FD8.2
5B5A:  DECF   xFE,F
5B5C:  DECF   xFD,F
....................                fgetc(COM2);//getc(); 
5B5E:  MOVLB  0
5B60:  RCALL  5AB0
....................             } 
....................             else fputc(0x07,COM2);    
5B62:  BRA    5B7E
5B64:  MOVLB  7
5B66:  CLRF   19
5B68:  BTFSC  FF2.7
5B6A:  BSF    19.7
5B6C:  BCF    FF2.7
5B6E:  MOVLW  07
5B70:  MOVLB  8
5B72:  MOVWF  x58
5B74:  MOVLB  0
5B76:  CALL   069C
5B7A:  BTFSC  19.7
5B7C:  BSF    FF2.7
....................          break;  
5B7E:  BRA    5C2A
....................          case 0x0D:   
....................                keydebug_en=0; 
5B80:  MOVLB  1
5B82:  CLRF   x4C
....................                set_tris_a(0xff); 
5B84:  MOVLW  FF
5B86:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
5B88:  MOVFF  7FD,7FC
5B8C:  MOVLB  7
5B8E:  MOVF   xF8,W
5B90:  SUBWF  xFC,W
5B92:  BC    5BA8
....................                { 
....................                  chaine[i]=0; 
5B94:  CLRF   03
5B96:  MOVF   xFC,W
5B98:  ADDWF  xF9,W
5B9A:  MOVWF  FE9
5B9C:  MOVF   xFA,W
5B9E:  ADDWFC 03,W
5BA0:  MOVWF  FEA
5BA2:  CLRF   FEF
....................                } 
5BA4:  INCF   xFC,F
5BA6:  BRA    5B8E
....................                if(nbcar==0)return(FAUX); 
5BA8:  MOVF   xFD,F
5BAA:  BNZ   5BB6
5BAC:  MOVF   xFE,F
5BAE:  BNZ   5BB6
5BB0:  MOVLW  00
5BB2:  MOVWF  01
5BB4:  BRA    5C32
....................                fini=VRAI; 
5BB6:  MOVLW  01
5BB8:  MOVWF  xFF
....................          break; 
5BBA:  MOVLB  0
5BBC:  BRA    5C2A
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
5BBE:  MOVLB  7
5BC0:  MOVF   xFB,W
5BC2:  SUBLW  1F
5BC4:  BC    5C2C
5BC6:  MOVF   xFB,W
5BC8:  SUBLW  7E
5BCA:  BNC   5C2C
5BCC:  MOVLW  01
5BCE:  SUBWF  xF8,W
5BD0:  MOVF   xFE,F
5BD2:  BNZ   5C2C
5BD4:  SUBWF  xFD,W
5BD6:  BC    5C2C
....................             { 
....................                chaine[nbcar]=c; 
5BD8:  MOVF   xF9,W
5BDA:  ADDWF  xFD,W
5BDC:  MOVWF  FE9
5BDE:  MOVF   xFA,W
5BE0:  ADDWFC xFE,W
5BE2:  MOVWF  FEA
5BE4:  MOVFF  7FB,FEF
....................                nbcar++; 
5BE8:  INCF   xFD,F
5BEA:  BTFSC  FD8.2
5BEC:  INCF   xFE,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
5BEE:  DECFSZ xF7,W
5BF0:  BRA    5C0C
5BF2:  CLRF   19
5BF4:  BTFSC  FF2.7
5BF6:  BSF    19.7
5BF8:  BCF    FF2.7
5BFA:  MOVFF  7FB,858
5BFE:  MOVLB  0
5C00:  CALL   069C
5C04:  BTFSC  19.7
5C06:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
5C08:  BRA    5C2A
5C0A:  MOVLB  7
5C0C:  MOVF   xF7,W
5C0E:  SUBLW  02
5C10:  BNZ   5C2C
5C12:  CLRF   19
5C14:  BTFSC  FF2.7
5C16:  BSF    19.7
5C18:  BCF    FF2.7
5C1A:  MOVLW  2A
5C1C:  MOVLB  8
5C1E:  MOVWF  x58
5C20:  MOVLB  0
5C22:  CALL   069C
5C26:  BTFSC  19.7
5C28:  BSF    FF2.7
5C2A:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
5C2C:  BRA    5B06
....................    return(nbcar); 
5C2E:  MOVFF  7FD,01
.................... } 
5C32:  MOVLB  0
5C34:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
5C36:  MOVFF  7F8,7FC
5C3A:  MOVFF  7F7,7FB
5C3E:  MOVFF  7FA,7FE
5C42:  MOVFF  7F9,7FD
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
5C46:  MOVFF  7FC,03
5C4A:  MOVLB  7
5C4C:  MOVFF  7FB,FE9
5C50:  MOVFF  7FC,FEA
5C54:  MOVF   FEF,F
5C56:  BZ    5C9E
5C58:  MOVFF  7FE,03
5C5C:  MOVFF  7FD,FE9
5C60:  MOVFF  7FE,FEA
5C64:  MOVF   FEF,F
5C66:  BZ    5C9E
....................       if(*aa!=*bb) 
5C68:  MOVFF  7FB,FE9
5C6C:  MOVFF  7FC,FEA
5C70:  MOVFF  FEF,7FF
5C74:  MOVFF  7FE,03
5C78:  MOVFF  7FD,FE9
5C7C:  MOVFF  7FE,FEA
5C80:  MOVF   FEF,W
5C82:  SUBWF  xFF,W
5C84:  BZ    5C8C
....................          return(1); 
5C86:  MOVLW  01
5C88:  MOVWF  01
5C8A:  BRA    5CCA
....................       aa++; 
5C8C:  INCF   xFB,F
5C8E:  BTFSC  FD8.2
5C90:  INCF   xFC,F
....................       bb++; 
5C92:  INCF   xFD,F
5C94:  BTFSC  FD8.2
5C96:  INCF   xFE,F
....................    } 
5C98:  MOVLB  0
5C9A:  BRA    5C46
5C9C:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
5C9E:  MOVFF  7FC,03
5CA2:  MOVFF  7FB,FE9
5CA6:  MOVFF  7FC,FEA
5CAA:  MOVFF  FEF,7FF
5CAE:  MOVFF  7FE,03
5CB2:  MOVFF  7FD,FE9
5CB6:  MOVFF  7FE,FEA
5CBA:  MOVF   FEF,W
5CBC:  SUBWF  xFF,W
5CBE:  BZ    5CC6
5CC0:  MOVLW  01
5CC2:  MOVWF  01
5CC4:  BRA    5CCA
....................    return(0); 
5CC6:  MOVLW  00
5CC8:  MOVWF  01
.................... } 
5CCA:  MOVLB  0
5CCC:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
6204:  MOVLB  7
6206:  CLRF   xF9
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
6208:  MOVFF  7F8,03
620C:  MOVF   xF7,W
620E:  INCF   xF7,F
6210:  BTFSC  FD8.2
6212:  INCF   xF8,F
6214:  MOVWF  FE9
6216:  MOVFF  03,FEA
621A:  MOVFF  FEF,7FB
621E:  MOVF   xFB,F
6220:  BZ    6244
....................         if (c >= '0' && c <= '9') 
6222:  MOVF   xFB,W
6224:  SUBLW  2F
6226:  BC    6236
6228:  MOVF   xFB,W
622A:  SUBLW  39
622C:  BNC   6236
....................             digit = (unsigned int) (c - '0'); 
622E:  MOVLW  30
6230:  SUBWF  xFB,W
6232:  MOVWF  xFA
....................         else 
6234:  BRA    6238
....................             break; 
6236:  BRA    6244
....................  
....................         val = (val * 10) + digit; 
6238:  MOVF   xF9,W
623A:  MULLW  0A
623C:  MOVF   FF3,W
623E:  ADDWF  xFA,W
6240:  MOVWF  xF9
....................     } 
6242:  BRA    6208
....................  
....................     return val; 
6244:  CLRF   03
6246:  MOVFF  7F9,01
624A:  MOVFF  03,02
.................... } 
624E:  MOVLB  0
6250:  RETURN 0
....................  
.................... int8 receiver_state=0,booting_done=0; 
.................... int16 over_byte=0; 
.................... //#include <GSM.c>  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
0702:  MOVLB  8
0704:  CLRF   x68
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
0706:  CLRF   x69
0708:  BTFSC  x60.0
070A:  BSF    x69.7
070C:  SWAPF  x61,W
070E:  MOVWF  00
0710:  RLCF   00,F
0712:  RLCF   00,F
0714:  MOVLW  C0
0716:  ANDWF  00,F
0718:  MOVF   00,W
071A:  IORWF  x69,F
071C:  SWAPF  x62,W
071E:  MOVWF  00
0720:  RLCF   00,F
0722:  MOVLW  E0
0724:  ANDWF  00,F
0726:  MOVF   00,W
0728:  IORWF  x69,F
072A:  SWAPF  x63,W
072C:  MOVWF  00
072E:  MOVLW  F0
0730:  ANDWF  00,F
0732:  MOVF   00,W
0734:  IORWF  x69,F
0736:  RLCF   x64,W
0738:  MOVWF  00
073A:  RLCF   00,F
073C:  RLCF   00,F
073E:  MOVLW  F8
0740:  ANDWF  00,F
0742:  MOVF   00,W
0744:  IORWF  x69,F
0746:  RLCF   x65,W
0748:  MOVWF  00
074A:  RLCF   00,F
074C:  MOVLW  FC
074E:  ANDWF  00,F
0750:  MOVF   00,W
0752:  IORWF  x69,F
0754:  BCF    FD8.0
0756:  RLCF   x66,W
0758:  IORWF  x69,F
075A:  MOVF   x67,W
075C:  IORWF  x69,W
075E:  MOVWF  x68
....................    return temp; 
0760:  MOVFF  868,01
.................... } 
0764:  MOVLB  0
0766:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0768:  MOVLB  8
076A:  CLRF   x50
....................    int8 temp=0; 
....................    if(direct==0) 
076C:  MOVF   x4B,F
076E:  BNZ   0844
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
0770:  MOVF   x4E,W
0772:  ADDWF  x4C,W
0774:  MOVWF  FE9
0776:  MOVF   x4F,W
0778:  ADDWFC x4D,W
077A:  MOVWF  FEA
077C:  MOVFF  FEF,851
0780:  MOVLW  01
0782:  ADDWF  x4C,W
0784:  MOVWF  x52
0786:  MOVLW  00
0788:  ADDWFC x4D,W
078A:  MOVWF  x53
078C:  MOVF   x4E,W
078E:  ADDWF  x52,W
0790:  MOVWF  FE9
0792:  MOVF   x4F,W
0794:  ADDWFC x53,W
0796:  MOVWF  FEA
0798:  MOVF   FEF,W
079A:  XORWF  x51,F
079C:  MOVLW  02
079E:  ADDWF  x4C,W
07A0:  MOVWF  x54
07A2:  MOVLW  00
07A4:  ADDWFC x4D,W
07A6:  MOVWF  x55
07A8:  MOVF   x4E,W
07AA:  ADDWF  x54,W
07AC:  MOVWF  FE9
07AE:  MOVF   x4F,W
07B0:  ADDWFC x55,W
07B2:  MOVWF  FEA
07B4:  MOVF   FEF,W
07B6:  XORWF  x51,F
07B8:  MOVLW  03
07BA:  ADDWF  x4C,W
07BC:  MOVWF  x56
07BE:  MOVLW  00
07C0:  ADDWFC x4D,W
07C2:  MOVWF  x57
07C4:  MOVF   x4E,W
07C6:  ADDWF  x56,W
07C8:  MOVWF  FE9
07CA:  MOVF   x4F,W
07CC:  ADDWFC x57,W
07CE:  MOVWF  FEA
07D0:  MOVF   FEF,W
07D2:  XORWF  x51,F
07D4:  MOVLW  04
07D6:  ADDWF  x4C,W
07D8:  MOVWF  x58
07DA:  MOVLW  00
07DC:  ADDWFC x4D,W
07DE:  MOVWF  x59
07E0:  MOVF   x4E,W
07E2:  ADDWF  x58,W
07E4:  MOVWF  FE9
07E6:  MOVF   x4F,W
07E8:  ADDWFC x59,W
07EA:  MOVWF  FEA
07EC:  MOVF   FEF,W
07EE:  XORWF  x51,F
07F0:  MOVLW  05
07F2:  ADDWF  x4C,W
07F4:  MOVWF  x5A
07F6:  MOVLW  00
07F8:  ADDWFC x4D,W
07FA:  MOVWF  x5B
07FC:  MOVF   x4E,W
07FE:  ADDWF  x5A,W
0800:  MOVWF  FE9
0802:  MOVF   x4F,W
0804:  ADDWFC x5B,W
0806:  MOVWF  FEA
0808:  MOVF   FEF,W
080A:  XORWF  x51,W
080C:  BZ    0812
080E:  MOVLW  00
0810:  BRA    0814
0812:  MOVLW  01
0814:  MOVWF  x50
....................       if(temp==datain[offset+6]) return 1; 
0816:  MOVLW  06
0818:  ADDWF  x4C,W
081A:  MOVWF  x51
081C:  MOVLW  00
081E:  ADDWFC x4D,W
0820:  MOVWF  x52
0822:  MOVF   x4E,W
0824:  ADDWF  x51,W
0826:  MOVWF  FE9
0828:  MOVF   x4F,W
082A:  ADDWFC x52,W
082C:  MOVWF  FEA
082E:  MOVF   FEF,W
0830:  SUBWF  x50,W
0832:  BNZ   083C
0834:  MOVLW  01
0836:  MOVWF  01
0838:  BRA    0914
....................          else return 0; 
083A:  BRA    0842
083C:  MOVLW  00
083E:  MOVWF  01
0840:  BRA    0914
....................    } 
....................       else  
0842:  BRA    0914
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
0844:  MOVF   x4E,W
0846:  ADDWF  x4C,W
0848:  MOVWF  FE9
084A:  MOVF   x4F,W
084C:  ADDWFC x4D,W
084E:  MOVWF  FEA
0850:  MOVFF  FEF,851
0854:  MOVLW  01
0856:  SUBWF  x4C,W
0858:  MOVWF  x52
085A:  MOVLW  00
085C:  SUBWFB x4D,W
085E:  MOVWF  x53
0860:  MOVF   x4E,W
0862:  ADDWF  x52,W
0864:  MOVWF  FE9
0866:  MOVF   x4F,W
0868:  ADDWFC x53,W
086A:  MOVWF  FEA
086C:  MOVF   FEF,W
086E:  XORWF  x51,F
0870:  MOVLW  02
0872:  SUBWF  x4C,W
0874:  MOVWF  x54
0876:  MOVLW  00
0878:  SUBWFB x4D,W
087A:  MOVWF  x55
087C:  MOVF   x4E,W
087E:  ADDWF  x54,W
0880:  MOVWF  FE9
0882:  MOVF   x4F,W
0884:  ADDWFC x55,W
0886:  MOVWF  FEA
0888:  MOVF   FEF,W
088A:  XORWF  x51,F
088C:  MOVLW  03
088E:  SUBWF  x4C,W
0890:  MOVWF  x56
0892:  MOVLW  00
0894:  SUBWFB x4D,W
0896:  MOVWF  x57
0898:  MOVF   x4E,W
089A:  ADDWF  x56,W
089C:  MOVWF  FE9
089E:  MOVF   x4F,W
08A0:  ADDWFC x57,W
08A2:  MOVWF  FEA
08A4:  MOVF   FEF,W
08A6:  XORWF  x51,F
08A8:  MOVLW  04
08AA:  SUBWF  x4C,W
08AC:  MOVWF  x58
08AE:  MOVLW  00
08B0:  SUBWFB x4D,W
08B2:  MOVWF  x59
08B4:  MOVF   x4E,W
08B6:  ADDWF  x58,W
08B8:  MOVWF  FE9
08BA:  MOVF   x4F,W
08BC:  ADDWFC x59,W
08BE:  MOVWF  FEA
08C0:  MOVF   FEF,W
08C2:  XORWF  x51,F
08C4:  MOVLW  05
08C6:  SUBWF  x4C,W
08C8:  MOVWF  x5A
08CA:  MOVLW  00
08CC:  SUBWFB x4D,W
08CE:  MOVWF  x5B
08D0:  MOVF   x4E,W
08D2:  ADDWF  x5A,W
08D4:  MOVWF  FE9
08D6:  MOVF   x4F,W
08D8:  ADDWFC x5B,W
08DA:  MOVWF  FEA
08DC:  MOVF   FEF,W
08DE:  XORWF  x51,W
08E0:  BZ    08E6
08E2:  MOVLW  00
08E4:  BRA    08E8
08E6:  MOVLW  01
08E8:  MOVWF  x50
....................          if(temp==datain[offset-6]) return 1; 
08EA:  MOVLW  06
08EC:  SUBWF  x4C,W
08EE:  MOVWF  x51
08F0:  MOVLW  00
08F2:  SUBWFB x4D,W
08F4:  MOVWF  x52
08F6:  MOVF   x4E,W
08F8:  ADDWF  x51,W
08FA:  MOVWF  FE9
08FC:  MOVF   x4F,W
08FE:  ADDWFC x52,W
0900:  MOVWF  FEA
0902:  MOVF   FEF,W
0904:  SUBWF  x50,W
0906:  BNZ   0910
0908:  MOVLW  01
090A:  MOVWF  01
090C:  BRA    0914
....................             else return 0;          
090E:  BRA    0914
0910:  MOVLW  00
0912:  MOVWF  01
....................       } 
.................... } 
0914:  MOVLB  0
0916:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
0918:  MOVLB  8
091A:  CLRF   x50
....................    int8 temp=0; 
....................    if(direct==0) 
091C:  MOVF   x4B,F
091E:  BNZ   09BC
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
0920:  MOVF   x4E,W
0922:  ADDWF  x4C,W
0924:  MOVWF  FE9
0926:  MOVF   x4F,W
0928:  ADDWFC x4D,W
092A:  MOVWF  FEA
092C:  MOVFF  FEF,851
0930:  MOVLW  01
0932:  ADDWF  x4C,W
0934:  MOVWF  x52
0936:  MOVLW  00
0938:  ADDWFC x4D,W
093A:  MOVWF  x53
093C:  MOVF   x4E,W
093E:  ADDWF  x52,W
0940:  MOVWF  FE9
0942:  MOVF   x4F,W
0944:  ADDWFC x53,W
0946:  MOVWF  FEA
0948:  MOVF   FEF,W
094A:  XORWF  x51,F
094C:  MOVLW  02
094E:  ADDWF  x4C,W
0950:  MOVWF  x54
0952:  MOVLW  00
0954:  ADDWFC x4D,W
0956:  MOVWF  x55
0958:  MOVF   x4E,W
095A:  ADDWF  x54,W
095C:  MOVWF  FE9
095E:  MOVF   x4F,W
0960:  ADDWFC x55,W
0962:  MOVWF  FEA
0964:  MOVF   FEF,W
0966:  XORWF  x51,F
0968:  MOVLW  03
096A:  ADDWF  x4C,W
096C:  MOVWF  x56
096E:  MOVLW  00
0970:  ADDWFC x4D,W
0972:  MOVWF  x57
0974:  MOVF   x4E,W
0976:  ADDWF  x56,W
0978:  MOVWF  FE9
097A:  MOVF   x4F,W
097C:  ADDWFC x57,W
097E:  MOVWF  FEA
0980:  MOVF   FEF,W
0982:  XORWF  x51,W
0984:  BZ    098A
0986:  MOVLW  00
0988:  BRA    098C
098A:  MOVLW  01
098C:  MOVWF  x50
....................       if(temp==datain[offset+4]) return 1; 
098E:  MOVLW  04
0990:  ADDWF  x4C,W
0992:  MOVWF  x51
0994:  MOVLW  00
0996:  ADDWFC x4D,W
0998:  MOVWF  x52
099A:  MOVF   x4E,W
099C:  ADDWF  x51,W
099E:  MOVWF  FE9
09A0:  MOVF   x4F,W
09A2:  ADDWFC x52,W
09A4:  MOVWF  FEA
09A6:  MOVF   FEF,W
09A8:  SUBWF  x50,W
09AA:  BNZ   09B4
09AC:  MOVLW  01
09AE:  MOVWF  01
09B0:  BRA    0A54
....................          else return 0; 
09B2:  BRA    09BA
09B4:  MOVLW  00
09B6:  MOVWF  01
09B8:  BRA    0A54
....................    } 
....................    else 
09BA:  BRA    0A54
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
09BC:  MOVF   x4E,W
09BE:  ADDWF  x4C,W
09C0:  MOVWF  FE9
09C2:  MOVF   x4F,W
09C4:  ADDWFC x4D,W
09C6:  MOVWF  FEA
09C8:  MOVFF  FEF,851
09CC:  MOVLW  01
09CE:  SUBWF  x4C,W
09D0:  MOVWF  x52
09D2:  MOVLW  00
09D4:  SUBWFB x4D,W
09D6:  MOVWF  x53
09D8:  MOVF   x4E,W
09DA:  ADDWF  x52,W
09DC:  MOVWF  FE9
09DE:  MOVF   x4F,W
09E0:  ADDWFC x53,W
09E2:  MOVWF  FEA
09E4:  MOVF   FEF,W
09E6:  XORWF  x51,F
09E8:  MOVLW  02
09EA:  SUBWF  x4C,W
09EC:  MOVWF  x54
09EE:  MOVLW  00
09F0:  SUBWFB x4D,W
09F2:  MOVWF  x55
09F4:  MOVF   x4E,W
09F6:  ADDWF  x54,W
09F8:  MOVWF  FE9
09FA:  MOVF   x4F,W
09FC:  ADDWFC x55,W
09FE:  MOVWF  FEA
0A00:  MOVF   FEF,W
0A02:  XORWF  x51,F
0A04:  MOVLW  03
0A06:  SUBWF  x4C,W
0A08:  MOVWF  x56
0A0A:  MOVLW  00
0A0C:  SUBWFB x4D,W
0A0E:  MOVWF  x57
0A10:  MOVF   x4E,W
0A12:  ADDWF  x56,W
0A14:  MOVWF  FE9
0A16:  MOVF   x4F,W
0A18:  ADDWFC x57,W
0A1A:  MOVWF  FEA
0A1C:  MOVF   FEF,W
0A1E:  XORWF  x51,W
0A20:  BZ    0A26
0A22:  MOVLW  00
0A24:  BRA    0A28
0A26:  MOVLW  01
0A28:  MOVWF  x50
....................       if(temp==datain[offset-4]) return 1; 
0A2A:  MOVLW  04
0A2C:  SUBWF  x4C,W
0A2E:  MOVWF  x51
0A30:  MOVLW  00
0A32:  SUBWFB x4D,W
0A34:  MOVWF  x52
0A36:  MOVF   x4E,W
0A38:  ADDWF  x51,W
0A3A:  MOVWF  FE9
0A3C:  MOVF   x4F,W
0A3E:  ADDWFC x52,W
0A40:  MOVWF  FEA
0A42:  MOVF   FEF,W
0A44:  SUBWF  x50,W
0A46:  BNZ   0A50
0A48:  MOVLW  01
0A4A:  MOVWF  01
0A4C:  BRA    0A54
....................          else return 0;                
0A4E:  BRA    0A54
0A50:  MOVLW  00
0A52:  MOVWF  01
....................    } 
.................... } 
0A54:  MOVLB  0
0A56:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0A58:  MOVLB  8
0A5A:  CLRF   x47
0A5C:  CLRF   x48
0A5E:  CLRF   x49
0A60:  CLRF   x4A
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0A62:  CLRF   x44
0A64:  CLRF   x43
0A66:  RRCF   x40,W
0A68:  MOVWF  03
0A6A:  RRCF   x3F,W
0A6C:  MOVWF  02
0A6E:  RRCF   03,F
0A70:  RRCF   02,F
0A72:  MOVLW  3F
0A74:  ANDWF  03,F
0A76:  MOVFF  02,01
0A7A:  MOVF   x44,W
0A7C:  SUBWF  03,W
0A7E:  BTFSS  FD8.0
0A80:  BRA    1040
0A82:  BNZ   0A8C
0A84:  MOVF   01,W
0A86:  SUBWF  x43,W
0A88:  BTFSC  FD8.0
0A8A:  BRA    1040
....................    { 
....................       if(track==0) 
0A8C:  MOVF   x3E,F
0A8E:  BTFSS  FD8.2
0A90:  BRA    0DC6
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0A92:  MOVLW  06
0A94:  ADDWF  x43,W
0A96:  MOVWF  x4B
0A98:  MOVLW  00
0A9A:  ADDWFC x44,W
0A9C:  MOVWF  x4C
0A9E:  MOVF   x41,W
0AA0:  ADDWF  x4B,W
0AA2:  MOVWF  FE9
0AA4:  MOVF   x42,W
0AA6:  ADDWFC x4C,W
0AA8:  MOVWF  FEA
0AAA:  MOVFF  FEF,84D
0AAE:  MOVLW  05
0AB0:  ADDWF  x43,W
0AB2:  MOVWF  x4E
0AB4:  MOVLW  00
0AB6:  ADDWFC x44,W
0AB8:  MOVWF  x4F
0ABA:  MOVF   x41,W
0ABC:  ADDWF  x4E,W
0ABE:  MOVWF  FE9
0AC0:  MOVF   x42,W
0AC2:  ADDWFC x4F,W
0AC4:  MOVWF  FEA
0AC6:  MOVFF  FEF,850
0ACA:  MOVLW  04
0ACC:  ADDWF  x43,W
0ACE:  MOVWF  x51
0AD0:  MOVLW  00
0AD2:  ADDWFC x44,W
0AD4:  MOVWF  x52
0AD6:  MOVF   x41,W
0AD8:  ADDWF  x51,W
0ADA:  MOVWF  FE9
0ADC:  MOVF   x42,W
0ADE:  ADDWFC x52,W
0AE0:  MOVWF  FEA
0AE2:  MOVFF  FEF,853
0AE6:  MOVLW  03
0AE8:  ADDWF  x43,W
0AEA:  MOVWF  x54
0AEC:  MOVLW  00
0AEE:  ADDWFC x44,W
0AF0:  MOVWF  x55
0AF2:  MOVF   x41,W
0AF4:  ADDWF  x54,W
0AF6:  MOVWF  FE9
0AF8:  MOVF   x42,W
0AFA:  ADDWFC x55,W
0AFC:  MOVWF  FEA
0AFE:  MOVFF  FEF,856
0B02:  MOVLW  02
0B04:  ADDWF  x43,W
0B06:  MOVWF  x57
0B08:  MOVLW  00
0B0A:  ADDWFC x44,W
0B0C:  MOVWF  x58
0B0E:  MOVF   x41,W
0B10:  ADDWF  x57,W
0B12:  MOVWF  FE9
0B14:  MOVF   x42,W
0B16:  ADDWFC x58,W
0B18:  MOVWF  FEA
0B1A:  MOVFF  FEF,859
0B1E:  MOVLW  01
0B20:  ADDWF  x43,W
0B22:  MOVWF  x5A
0B24:  MOVLW  00
0B26:  ADDWFC x44,W
0B28:  MOVWF  x5B
0B2A:  MOVF   x41,W
0B2C:  ADDWF  x5A,W
0B2E:  MOVWF  FE9
0B30:  MOVF   x42,W
0B32:  ADDWFC x5B,W
0B34:  MOVWF  FEA
0B36:  MOVFF  FEF,85C
0B3A:  MOVF   x41,W
0B3C:  ADDWF  x43,W
0B3E:  MOVWF  FE9
0B40:  MOVF   x42,W
0B42:  ADDWFC x44,W
0B44:  MOVWF  FEA
0B46:  MOVFF  FEF,85D
0B4A:  CLRF   x60
0B4C:  MOVFF  84D,861
0B50:  MOVFF  850,862
0B54:  MOVFF  853,863
0B58:  MOVFF  856,864
0B5C:  MOVFF  859,865
0B60:  MOVFF  85C,866
0B64:  MOVFF  85D,867
0B68:  MOVLB  0
0B6A:  RCALL  0702
0B6C:  MOVFF  01,847
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0B70:  MOVLW  0D
0B72:  MOVLB  8
0B74:  ADDWF  x43,W
0B76:  MOVWF  x4B
0B78:  MOVLW  00
0B7A:  ADDWFC x44,W
0B7C:  MOVWF  x4C
0B7E:  MOVF   x41,W
0B80:  ADDWF  x4B,W
0B82:  MOVWF  FE9
0B84:  MOVF   x42,W
0B86:  ADDWFC x4C,W
0B88:  MOVWF  FEA
0B8A:  MOVFF  FEF,84D
0B8E:  MOVLW  0C
0B90:  ADDWF  x43,W
0B92:  MOVWF  x4E
0B94:  MOVLW  00
0B96:  ADDWFC x44,W
0B98:  MOVWF  x4F
0B9A:  MOVF   x41,W
0B9C:  ADDWF  x4E,W
0B9E:  MOVWF  FE9
0BA0:  MOVF   x42,W
0BA2:  ADDWFC x4F,W
0BA4:  MOVWF  FEA
0BA6:  MOVFF  FEF,850
0BAA:  MOVLW  0B
0BAC:  ADDWF  x43,W
0BAE:  MOVWF  x51
0BB0:  MOVLW  00
0BB2:  ADDWFC x44,W
0BB4:  MOVWF  x52
0BB6:  MOVF   x41,W
0BB8:  ADDWF  x51,W
0BBA:  MOVWF  FE9
0BBC:  MOVF   x42,W
0BBE:  ADDWFC x52,W
0BC0:  MOVWF  FEA
0BC2:  MOVFF  FEF,853
0BC6:  MOVLW  0A
0BC8:  ADDWF  x43,W
0BCA:  MOVWF  x54
0BCC:  MOVLW  00
0BCE:  ADDWFC x44,W
0BD0:  MOVWF  x55
0BD2:  MOVF   x41,W
0BD4:  ADDWF  x54,W
0BD6:  MOVWF  FE9
0BD8:  MOVF   x42,W
0BDA:  ADDWFC x55,W
0BDC:  MOVWF  FEA
0BDE:  MOVFF  FEF,856
0BE2:  MOVLW  09
0BE4:  ADDWF  x43,W
0BE6:  MOVWF  x57
0BE8:  MOVLW  00
0BEA:  ADDWFC x44,W
0BEC:  MOVWF  x58
0BEE:  MOVF   x41,W
0BF0:  ADDWF  x57,W
0BF2:  MOVWF  FE9
0BF4:  MOVF   x42,W
0BF6:  ADDWFC x58,W
0BF8:  MOVWF  FEA
0BFA:  MOVFF  FEF,859
0BFE:  MOVLW  08
0C00:  ADDWF  x43,W
0C02:  MOVWF  x5A
0C04:  MOVLW  00
0C06:  ADDWFC x44,W
0C08:  MOVWF  x5B
0C0A:  MOVF   x41,W
0C0C:  ADDWF  x5A,W
0C0E:  MOVWF  FE9
0C10:  MOVF   x42,W
0C12:  ADDWFC x5B,W
0C14:  MOVWF  FEA
0C16:  MOVFF  FEF,85C
0C1A:  MOVLW  07
0C1C:  ADDWF  x43,W
0C1E:  MOVWF  x5D
0C20:  MOVLW  00
0C22:  ADDWFC x44,W
0C24:  MOVWF  x5E
0C26:  MOVF   x41,W
0C28:  ADDWF  x5D,W
0C2A:  MOVWF  FE9
0C2C:  MOVF   x42,W
0C2E:  ADDWFC x5E,W
0C30:  MOVWF  FEA
0C32:  MOVFF  FEF,85F
0C36:  CLRF   x60
0C38:  MOVFF  84D,861
0C3C:  MOVFF  850,862
0C40:  MOVFF  853,863
0C44:  MOVFF  856,864
0C48:  MOVFF  859,865
0C4C:  MOVFF  85C,866
0C50:  MOVFF  85F,867
0C54:  MOVLB  0
0C56:  RCALL  0702
0C58:  MOVFF  01,848
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0C5C:  MOVLB  8
0C5E:  MOVF   x47,W
0C60:  SUBLW  45
0C62:  BTFSS  FD8.2
0C64:  BRA    0DC4
0C66:  MOVF   x48,W
0C68:  SUBLW  7C
0C6A:  BTFSC  FD8.2
0C6C:  BRA    0DC4
0C6E:  MOVF   x48,W
0C70:  SUBLW  3E
0C72:  BTFSC  FD8.2
0C74:  BRA    0DC4
0C76:  MOVF   x48,W
0C78:  SUBLW  1F
0C7A:  BTFSC  FD8.2
0C7C:  BRA    0DC4
....................          { 
....................             j=i; 
0C7E:  MOVFF  844,846
0C82:  MOVFF  843,845
....................             CRC=1; 
0C86:  MOVLW  01
0C88:  MOVWF  x4A
....................             temp2=temp; 
0C8A:  MOVFF  847,849
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0C8E:  MOVF   x49,W
0C90:  SUBLW  1F
0C92:  BTFSC  FD8.2
0C94:  BRA    0DAE
0C96:  MOVF   x46,W
0C98:  SUBLW  03
0C9A:  BTFSS  FD8.0
0C9C:  BRA    0DAE
0C9E:  BNZ   0CA8
0CA0:  MOVF   x45,W
0CA2:  SUBLW  E7
0CA4:  BTFSS  FD8.0
0CA6:  BRA    0DAE
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0CA8:  CLRF   x4B
0CAA:  MOVFF  846,84D
0CAE:  MOVFF  845,84C
0CB2:  MOVFF  842,84F
0CB6:  MOVFF  841,84E
0CBA:  MOVLB  0
0CBC:  RCALL  0768
0CBE:  MOVF   01,W
0CC0:  MOVLB  8
0CC2:  ANDWF  x4A,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0CC4:  MOVLW  06
0CC6:  ADDWF  x45,W
0CC8:  MOVWF  x4B
0CCA:  MOVLW  00
0CCC:  ADDWFC x46,W
0CCE:  MOVWF  x4C
0CD0:  MOVF   x41,W
0CD2:  ADDWF  x4B,W
0CD4:  MOVWF  FE9
0CD6:  MOVF   x42,W
0CD8:  ADDWFC x4C,W
0CDA:  MOVWF  FEA
0CDC:  MOVFF  FEF,84D
0CE0:  MOVLW  05
0CE2:  ADDWF  x45,W
0CE4:  MOVWF  x4E
0CE6:  MOVLW  00
0CE8:  ADDWFC x46,W
0CEA:  MOVWF  x4F
0CEC:  MOVF   x41,W
0CEE:  ADDWF  x4E,W
0CF0:  MOVWF  FE9
0CF2:  MOVF   x42,W
0CF4:  ADDWFC x4F,W
0CF6:  MOVWF  FEA
0CF8:  MOVFF  FEF,850
0CFC:  MOVLW  04
0CFE:  ADDWF  x45,W
0D00:  MOVWF  x51
0D02:  MOVLW  00
0D04:  ADDWFC x46,W
0D06:  MOVWF  x52
0D08:  MOVF   x41,W
0D0A:  ADDWF  x51,W
0D0C:  MOVWF  FE9
0D0E:  MOVF   x42,W
0D10:  ADDWFC x52,W
0D12:  MOVWF  FEA
0D14:  MOVFF  FEF,853
0D18:  MOVLW  03
0D1A:  ADDWF  x45,W
0D1C:  MOVWF  x54
0D1E:  MOVLW  00
0D20:  ADDWFC x46,W
0D22:  MOVWF  x55
0D24:  MOVF   x41,W
0D26:  ADDWF  x54,W
0D28:  MOVWF  FE9
0D2A:  MOVF   x42,W
0D2C:  ADDWFC x55,W
0D2E:  MOVWF  FEA
0D30:  MOVFF  FEF,856
0D34:  MOVLW  02
0D36:  ADDWF  x45,W
0D38:  MOVWF  x57
0D3A:  MOVLW  00
0D3C:  ADDWFC x46,W
0D3E:  MOVWF  x58
0D40:  MOVF   x41,W
0D42:  ADDWF  x57,W
0D44:  MOVWF  FE9
0D46:  MOVF   x42,W
0D48:  ADDWFC x58,W
0D4A:  MOVWF  FEA
0D4C:  MOVFF  FEF,859
0D50:  MOVLW  01
0D52:  ADDWF  x45,W
0D54:  MOVWF  x5A
0D56:  MOVLW  00
0D58:  ADDWFC x46,W
0D5A:  MOVWF  x5B
0D5C:  MOVF   x41,W
0D5E:  ADDWF  x5A,W
0D60:  MOVWF  FE9
0D62:  MOVF   x42,W
0D64:  ADDWFC x5B,W
0D66:  MOVWF  FEA
0D68:  MOVFF  FEF,85C
0D6C:  MOVF   x41,W
0D6E:  ADDWF  x45,W
0D70:  MOVWF  FE9
0D72:  MOVF   x42,W
0D74:  ADDWFC x46,W
0D76:  MOVWF  FEA
0D78:  MOVFF  FEF,85D
0D7C:  CLRF   x60
0D7E:  MOVFF  84D,861
0D82:  MOVFF  850,862
0D86:  MOVFF  853,863
0D8A:  MOVFF  856,864
0D8E:  MOVFF  859,865
0D92:  MOVFF  85C,866
0D96:  MOVFF  85D,867
0D9A:  MOVLB  0
0D9C:  RCALL  0702
0D9E:  MOVFF  01,849
....................                j=j+7; 
0DA2:  MOVLW  07
0DA4:  MOVLB  8
0DA6:  ADDWF  x45,F
0DA8:  MOVLW  00
0DAA:  ADDWFC x46,F
....................             } 
0DAC:  BRA    0C8E
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0DAE:  DECFSZ x4A,W
0DB0:  BRA    0DC4
....................             { 
....................                dir=0; 
0DB2:  MOVLB  6
0DB4:  CLRF   xCC
....................                return i; 
0DB6:  MOVLB  8
0DB8:  MOVFF  843,01
0DBC:  MOVFF  844,02
0DC0:  GOTO   1656
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0DC4:  BRA    1038
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0DC6:  MOVLW  04
0DC8:  ADDWF  x43,W
0DCA:  MOVWF  x4B
0DCC:  MOVLW  00
0DCE:  ADDWFC x44,W
0DD0:  MOVWF  x4C
0DD2:  MOVF   x41,W
0DD4:  ADDWF  x4B,W
0DD6:  MOVWF  FE9
0DD8:  MOVF   x42,W
0DDA:  ADDWFC x4C,W
0DDC:  MOVWF  FEA
0DDE:  MOVFF  FEF,84D
0DE2:  MOVLW  03
0DE4:  ADDWF  x43,W
0DE6:  MOVWF  x4E
0DE8:  MOVLW  00
0DEA:  ADDWFC x44,W
0DEC:  MOVWF  x4F
0DEE:  MOVF   x41,W
0DF0:  ADDWF  x4E,W
0DF2:  MOVWF  FE9
0DF4:  MOVF   x42,W
0DF6:  ADDWFC x4F,W
0DF8:  MOVWF  FEA
0DFA:  MOVFF  FEF,850
0DFE:  MOVLW  02
0E00:  ADDWF  x43,W
0E02:  MOVWF  x51
0E04:  MOVLW  00
0E06:  ADDWFC x44,W
0E08:  MOVWF  x52
0E0A:  MOVF   x41,W
0E0C:  ADDWF  x51,W
0E0E:  MOVWF  FE9
0E10:  MOVF   x42,W
0E12:  ADDWFC x52,W
0E14:  MOVWF  FEA
0E16:  MOVFF  FEF,853
0E1A:  MOVLW  01
0E1C:  ADDWF  x43,W
0E1E:  MOVWF  x54
0E20:  MOVLW  00
0E22:  ADDWFC x44,W
0E24:  MOVWF  x55
0E26:  MOVF   x41,W
0E28:  ADDWF  x54,W
0E2A:  MOVWF  FE9
0E2C:  MOVF   x42,W
0E2E:  ADDWFC x55,W
0E30:  MOVWF  FEA
0E32:  MOVFF  FEF,856
0E36:  MOVF   x41,W
0E38:  ADDWF  x43,W
0E3A:  MOVWF  FE9
0E3C:  MOVF   x42,W
0E3E:  ADDWFC x44,W
0E40:  MOVWF  FEA
0E42:  MOVFF  FEF,857
0E46:  CLRF   x60
0E48:  CLRF   x61
0E4A:  CLRF   x62
0E4C:  MOVFF  84D,863
0E50:  MOVFF  850,864
0E54:  MOVFF  853,865
0E58:  MOVFF  856,866
0E5C:  MOVFF  857,867
0E60:  MOVLB  0
0E62:  RCALL  0702
0E64:  MOVFF  01,847
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0E68:  MOVLW  09
0E6A:  MOVLB  8
0E6C:  ADDWF  x43,W
0E6E:  MOVWF  x4B
0E70:  MOVLW  00
0E72:  ADDWFC x44,W
0E74:  MOVWF  x4C
0E76:  MOVF   x41,W
0E78:  ADDWF  x4B,W
0E7A:  MOVWF  FE9
0E7C:  MOVF   x42,W
0E7E:  ADDWFC x4C,W
0E80:  MOVWF  FEA
0E82:  MOVFF  FEF,84D
0E86:  MOVLW  08
0E88:  ADDWF  x43,W
0E8A:  MOVWF  x4E
0E8C:  MOVLW  00
0E8E:  ADDWFC x44,W
0E90:  MOVWF  x4F
0E92:  MOVF   x41,W
0E94:  ADDWF  x4E,W
0E96:  MOVWF  FE9
0E98:  MOVF   x42,W
0E9A:  ADDWFC x4F,W
0E9C:  MOVWF  FEA
0E9E:  MOVFF  FEF,850
0EA2:  MOVLW  07
0EA4:  ADDWF  x43,W
0EA6:  MOVWF  x51
0EA8:  MOVLW  00
0EAA:  ADDWFC x44,W
0EAC:  MOVWF  x52
0EAE:  MOVF   x41,W
0EB0:  ADDWF  x51,W
0EB2:  MOVWF  FE9
0EB4:  MOVF   x42,W
0EB6:  ADDWFC x52,W
0EB8:  MOVWF  FEA
0EBA:  MOVFF  FEF,853
0EBE:  MOVLW  06
0EC0:  ADDWF  x43,W
0EC2:  MOVWF  x54
0EC4:  MOVLW  00
0EC6:  ADDWFC x44,W
0EC8:  MOVWF  x55
0ECA:  MOVF   x41,W
0ECC:  ADDWF  x54,W
0ECE:  MOVWF  FE9
0ED0:  MOVF   x42,W
0ED2:  ADDWFC x55,W
0ED4:  MOVWF  FEA
0ED6:  MOVFF  FEF,856
0EDA:  MOVLW  05
0EDC:  ADDWF  x43,W
0EDE:  MOVWF  x57
0EE0:  MOVLW  00
0EE2:  ADDWFC x44,W
0EE4:  MOVWF  x58
0EE6:  MOVF   x41,W
0EE8:  ADDWF  x57,W
0EEA:  MOVWF  FE9
0EEC:  MOVF   x42,W
0EEE:  ADDWFC x58,W
0EF0:  MOVWF  FEA
0EF2:  MOVFF  FEF,859
0EF6:  CLRF   x60
0EF8:  CLRF   x61
0EFA:  CLRF   x62
0EFC:  MOVFF  84D,863
0F00:  MOVFF  850,864
0F04:  MOVFF  853,865
0F08:  MOVFF  856,866
0F0C:  MOVFF  859,867
0F10:  MOVLB  0
0F12:  CALL   0702
0F16:  MOVFF  01,848
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0F1A:  MOVLB  8
0F1C:  MOVF   x47,W
0F1E:  SUBLW  0B
0F20:  BTFSS  FD8.2
0F22:  BRA    1038
0F24:  MOVF   x48,W
0F26:  SUBLW  1F
0F28:  BTFSC  FD8.2
0F2A:  BRA    1038
0F2C:  MOVF   x48,W
0F2E:  SUBLW  0F
0F30:  BTFSC  FD8.2
0F32:  BRA    1038
....................             { 
....................                j=i; 
0F34:  MOVFF  844,846
0F38:  MOVFF  843,845
....................                CRC=1; 
0F3C:  MOVLW  01
0F3E:  MOVWF  x4A
....................                temp2=temp; 
0F40:  MOVFF  847,849
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0F44:  MOVF   x49,W
0F46:  SUBLW  1F
0F48:  BZ    1024
0F4A:  MOVF   x46,W
0F4C:  SUBLW  01
0F4E:  BNC   1024
0F50:  BNZ   0F58
0F52:  MOVF   x45,W
0F54:  SUBLW  F3
0F56:  BNC   1024
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0F58:  CLRF   x4B
0F5A:  MOVFF  846,84D
0F5E:  MOVFF  845,84C
0F62:  MOVFF  842,84F
0F66:  MOVFF  841,84E
0F6A:  MOVLB  0
0F6C:  RCALL  0918
0F6E:  MOVF   01,W
0F70:  MOVLB  8
0F72:  ANDWF  x4A,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0F74:  MOVLW  04
0F76:  ADDWF  x45,W
0F78:  MOVWF  x4B
0F7A:  MOVLW  00
0F7C:  ADDWFC x46,W
0F7E:  MOVWF  x4C
0F80:  MOVF   x41,W
0F82:  ADDWF  x4B,W
0F84:  MOVWF  FE9
0F86:  MOVF   x42,W
0F88:  ADDWFC x4C,W
0F8A:  MOVWF  FEA
0F8C:  MOVFF  FEF,84D
0F90:  MOVLW  03
0F92:  ADDWF  x45,W
0F94:  MOVWF  x4E
0F96:  MOVLW  00
0F98:  ADDWFC x46,W
0F9A:  MOVWF  x4F
0F9C:  MOVF   x41,W
0F9E:  ADDWF  x4E,W
0FA0:  MOVWF  FE9
0FA2:  MOVF   x42,W
0FA4:  ADDWFC x4F,W
0FA6:  MOVWF  FEA
0FA8:  MOVFF  FEF,850
0FAC:  MOVLW  02
0FAE:  ADDWF  x45,W
0FB0:  MOVWF  x51
0FB2:  MOVLW  00
0FB4:  ADDWFC x46,W
0FB6:  MOVWF  x52
0FB8:  MOVF   x41,W
0FBA:  ADDWF  x51,W
0FBC:  MOVWF  FE9
0FBE:  MOVF   x42,W
0FC0:  ADDWFC x52,W
0FC2:  MOVWF  FEA
0FC4:  MOVFF  FEF,853
0FC8:  MOVLW  01
0FCA:  ADDWF  x45,W
0FCC:  MOVWF  x54
0FCE:  MOVLW  00
0FD0:  ADDWFC x46,W
0FD2:  MOVWF  x55
0FD4:  MOVF   x41,W
0FD6:  ADDWF  x54,W
0FD8:  MOVWF  FE9
0FDA:  MOVF   x42,W
0FDC:  ADDWFC x55,W
0FDE:  MOVWF  FEA
0FE0:  MOVFF  FEF,856
0FE4:  MOVF   x41,W
0FE6:  ADDWF  x45,W
0FE8:  MOVWF  FE9
0FEA:  MOVF   x42,W
0FEC:  ADDWFC x46,W
0FEE:  MOVWF  FEA
0FF0:  MOVFF  FEF,857
0FF4:  CLRF   x60
0FF6:  CLRF   x61
0FF8:  CLRF   x62
0FFA:  MOVFF  84D,863
0FFE:  MOVFF  850,864
1002:  MOVFF  853,865
1006:  MOVFF  856,866
100A:  MOVFF  857,867
100E:  MOVLB  0
1010:  CALL   0702
1014:  MOVFF  01,849
....................                   j=j+5; 
1018:  MOVLW  05
101A:  MOVLB  8
101C:  ADDWF  x45,F
101E:  MOVLW  00
1020:  ADDWFC x46,F
....................                } 
1022:  BRA    0F44
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
1024:  DECFSZ x4A,W
1026:  BRA    1038
....................                { 
....................                   dir=0; 
1028:  MOVLB  6
102A:  CLRF   xCC
....................                   return i; 
102C:  MOVLB  8
102E:  MOVFF  843,01
1032:  MOVFF  844,02
1036:  BRA    1656
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
1038:  INCF   x43,F
103A:  BTFSC  FD8.2
103C:  INCF   x44,F
103E:  BRA    0A66
....................    for(i=end_point;i>end_point/4;i--) 
1040:  MOVFF  840,844
1044:  MOVFF  83F,843
1048:  RRCF   x40,W
104A:  MOVWF  03
104C:  RRCF   x3F,W
104E:  MOVWF  02
1050:  RRCF   03,F
1052:  RRCF   02,F
1054:  MOVLW  3F
1056:  ANDWF  03,F
1058:  MOVFF  02,01
105C:  MOVF   03,W
105E:  SUBWF  x44,W
1060:  BTFSS  FD8.0
1062:  BRA    1650
1064:  BNZ   106E
1066:  MOVF   x43,W
1068:  SUBWF  01,W
106A:  BTFSC  FD8.0
106C:  BRA    1650
....................    { 
....................       if(track==0) 
106E:  MOVF   x3E,F
1070:  BTFSS  FD8.2
1072:  BRA    13C6
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1074:  MOVLW  06
1076:  SUBWF  x43,W
1078:  MOVWF  x4B
107A:  MOVLW  00
107C:  SUBWFB x44,W
107E:  MOVWF  x4C
1080:  MOVF   x41,W
1082:  ADDWF  x4B,W
1084:  MOVWF  FE9
1086:  MOVF   x42,W
1088:  ADDWFC x4C,W
108A:  MOVWF  FEA
108C:  MOVFF  FEF,84D
1090:  MOVLW  05
1092:  SUBWF  x43,W
1094:  MOVWF  x4E
1096:  MOVLW  00
1098:  SUBWFB x44,W
109A:  MOVWF  x4F
109C:  MOVF   x41,W
109E:  ADDWF  x4E,W
10A0:  MOVWF  FE9
10A2:  MOVF   x42,W
10A4:  ADDWFC x4F,W
10A6:  MOVWF  FEA
10A8:  MOVFF  FEF,850
10AC:  MOVLW  04
10AE:  SUBWF  x43,W
10B0:  MOVWF  x51
10B2:  MOVLW  00
10B4:  SUBWFB x44,W
10B6:  MOVWF  x52
10B8:  MOVF   x41,W
10BA:  ADDWF  x51,W
10BC:  MOVWF  FE9
10BE:  MOVF   x42,W
10C0:  ADDWFC x52,W
10C2:  MOVWF  FEA
10C4:  MOVFF  FEF,853
10C8:  MOVLW  03
10CA:  SUBWF  x43,W
10CC:  MOVWF  x54
10CE:  MOVLW  00
10D0:  SUBWFB x44,W
10D2:  MOVWF  x55
10D4:  MOVF   x41,W
10D6:  ADDWF  x54,W
10D8:  MOVWF  FE9
10DA:  MOVF   x42,W
10DC:  ADDWFC x55,W
10DE:  MOVWF  FEA
10E0:  MOVFF  FEF,856
10E4:  MOVLW  02
10E6:  SUBWF  x43,W
10E8:  MOVWF  x57
10EA:  MOVLW  00
10EC:  SUBWFB x44,W
10EE:  MOVWF  x58
10F0:  MOVF   x41,W
10F2:  ADDWF  x57,W
10F4:  MOVWF  FE9
10F6:  MOVF   x42,W
10F8:  ADDWFC x58,W
10FA:  MOVWF  FEA
10FC:  MOVFF  FEF,859
1100:  MOVLW  01
1102:  SUBWF  x43,W
1104:  MOVWF  x5A
1106:  MOVLW  00
1108:  SUBWFB x44,W
110A:  MOVWF  x5B
110C:  MOVF   x41,W
110E:  ADDWF  x5A,W
1110:  MOVWF  FE9
1112:  MOVF   x42,W
1114:  ADDWFC x5B,W
1116:  MOVWF  FEA
1118:  MOVFF  FEF,85C
111C:  MOVF   x41,W
111E:  ADDWF  x43,W
1120:  MOVWF  FE9
1122:  MOVF   x42,W
1124:  ADDWFC x44,W
1126:  MOVWF  FEA
1128:  MOVFF  FEF,85D
112C:  CLRF   x60
112E:  MOVFF  84D,861
1132:  MOVFF  850,862
1136:  MOVFF  853,863
113A:  MOVFF  856,864
113E:  MOVFF  859,865
1142:  MOVFF  85C,866
1146:  MOVFF  85D,867
114A:  MOVLB  0
114C:  CALL   0702
1150:  MOVFF  01,847
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
1154:  MOVLW  0D
1156:  MOVLB  8
1158:  SUBWF  x43,W
115A:  MOVWF  x4B
115C:  MOVLW  00
115E:  SUBWFB x44,W
1160:  MOVWF  x4C
1162:  MOVF   x41,W
1164:  ADDWF  x4B,W
1166:  MOVWF  FE9
1168:  MOVF   x42,W
116A:  ADDWFC x4C,W
116C:  MOVWF  FEA
116E:  MOVFF  FEF,84D
1172:  MOVLW  0C
1174:  SUBWF  x43,W
1176:  MOVWF  x4E
1178:  MOVLW  00
117A:  SUBWFB x44,W
117C:  MOVWF  x4F
117E:  MOVF   x41,W
1180:  ADDWF  x4E,W
1182:  MOVWF  FE9
1184:  MOVF   x42,W
1186:  ADDWFC x4F,W
1188:  MOVWF  FEA
118A:  MOVFF  FEF,850
118E:  MOVLW  0B
1190:  SUBWF  x43,W
1192:  MOVWF  x51
1194:  MOVLW  00
1196:  SUBWFB x44,W
1198:  MOVWF  x52
119A:  MOVF   x41,W
119C:  ADDWF  x51,W
119E:  MOVWF  FE9
11A0:  MOVF   x42,W
11A2:  ADDWFC x52,W
11A4:  MOVWF  FEA
11A6:  MOVFF  FEF,853
11AA:  MOVLW  0A
11AC:  SUBWF  x43,W
11AE:  MOVWF  x54
11B0:  MOVLW  00
11B2:  SUBWFB x44,W
11B4:  MOVWF  x55
11B6:  MOVF   x41,W
11B8:  ADDWF  x54,W
11BA:  MOVWF  FE9
11BC:  MOVF   x42,W
11BE:  ADDWFC x55,W
11C0:  MOVWF  FEA
11C2:  MOVFF  FEF,856
11C6:  MOVLW  09
11C8:  SUBWF  x43,W
11CA:  MOVWF  x57
11CC:  MOVLW  00
11CE:  SUBWFB x44,W
11D0:  MOVWF  x58
11D2:  MOVF   x41,W
11D4:  ADDWF  x57,W
11D6:  MOVWF  FE9
11D8:  MOVF   x42,W
11DA:  ADDWFC x58,W
11DC:  MOVWF  FEA
11DE:  MOVFF  FEF,859
11E2:  MOVLW  08
11E4:  SUBWF  x43,W
11E6:  MOVWF  x5A
11E8:  MOVLW  00
11EA:  SUBWFB x44,W
11EC:  MOVWF  x5B
11EE:  MOVF   x41,W
11F0:  ADDWF  x5A,W
11F2:  MOVWF  FE9
11F4:  MOVF   x42,W
11F6:  ADDWFC x5B,W
11F8:  MOVWF  FEA
11FA:  MOVFF  FEF,85C
11FE:  MOVLW  07
1200:  SUBWF  x43,W
1202:  MOVWF  x5D
1204:  MOVLW  00
1206:  SUBWFB x44,W
1208:  MOVWF  x5E
120A:  MOVF   x41,W
120C:  ADDWF  x5D,W
120E:  MOVWF  FE9
1210:  MOVF   x42,W
1212:  ADDWFC x5E,W
1214:  MOVWF  FEA
1216:  MOVFF  FEF,85F
121A:  CLRF   x60
121C:  MOVFF  84D,861
1220:  MOVFF  850,862
1224:  MOVFF  853,863
1228:  MOVFF  856,864
122C:  MOVFF  859,865
1230:  MOVFF  85C,866
1234:  MOVFF  85F,867
1238:  MOVLB  0
123A:  CALL   0702
123E:  MOVFF  01,848
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
1242:  MOVLB  8
1244:  MOVF   x47,W
1246:  SUBLW  45
1248:  BTFSS  FD8.2
124A:  BRA    13C4
124C:  MOVF   x48,W
124E:  SUBLW  7C
1250:  BTFSC  FD8.2
1252:  BRA    13C4
1254:  MOVF   x48,W
1256:  SUBLW  3E
1258:  BTFSC  FD8.2
125A:  BRA    13C4
125C:  MOVF   x48,W
125E:  SUBLW  1F
1260:  BTFSC  FD8.2
1262:  BRA    13C4
1264:  MOVF   x48,W
1266:  SUBLW  0F
1268:  BTFSC  FD8.2
126A:  BRA    13C4
126C:  MOVF   x48,W
126E:  SUBLW  78
1270:  BTFSC  FD8.2
1272:  BRA    13C4
....................          { 
....................             j=i; 
1274:  MOVFF  844,846
1278:  MOVFF  843,845
....................             CRC=1; 
127C:  MOVLW  01
127E:  MOVWF  x4A
....................             temp2=temp; 
1280:  MOVFF  847,849
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
1284:  MOVF   x49,W
1286:  SUBLW  1F
1288:  BTFSC  FD8.2
128A:  BRA    13A4
128C:  MOVF   x46,F
128E:  BNZ   1298
1290:  MOVF   x45,W
1292:  SUBLW  01
1294:  BTFSC  FD8.0
1296:  BRA    13A4
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1298:  MOVLW  01
129A:  MOVWF  x4B
129C:  MOVFF  846,84D
12A0:  MOVFF  845,84C
12A4:  MOVFF  842,84F
12A8:  MOVFF  841,84E
12AC:  MOVLB  0
12AE:  CALL   0768
12B2:  MOVF   01,W
12B4:  MOVLB  8
12B6:  ANDWF  x4A,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
12B8:  MOVLW  06
12BA:  SUBWF  x45,W
12BC:  MOVWF  x4B
12BE:  MOVLW  00
12C0:  SUBWFB x46,W
12C2:  MOVWF  x4C
12C4:  MOVF   x41,W
12C6:  ADDWF  x4B,W
12C8:  MOVWF  FE9
12CA:  MOVF   x42,W
12CC:  ADDWFC x4C,W
12CE:  MOVWF  FEA
12D0:  MOVFF  FEF,84D
12D4:  MOVLW  05
12D6:  SUBWF  x45,W
12D8:  MOVWF  x4E
12DA:  MOVLW  00
12DC:  SUBWFB x46,W
12DE:  MOVWF  x4F
12E0:  MOVF   x41,W
12E2:  ADDWF  x4E,W
12E4:  MOVWF  FE9
12E6:  MOVF   x42,W
12E8:  ADDWFC x4F,W
12EA:  MOVWF  FEA
12EC:  MOVFF  FEF,850
12F0:  MOVLW  04
12F2:  SUBWF  x45,W
12F4:  MOVWF  x51
12F6:  MOVLW  00
12F8:  SUBWFB x46,W
12FA:  MOVWF  x52
12FC:  MOVF   x41,W
12FE:  ADDWF  x51,W
1300:  MOVWF  FE9
1302:  MOVF   x42,W
1304:  ADDWFC x52,W
1306:  MOVWF  FEA
1308:  MOVFF  FEF,853
130C:  MOVLW  03
130E:  SUBWF  x45,W
1310:  MOVWF  x54
1312:  MOVLW  00
1314:  SUBWFB x46,W
1316:  MOVWF  x55
1318:  MOVF   x41,W
131A:  ADDWF  x54,W
131C:  MOVWF  FE9
131E:  MOVF   x42,W
1320:  ADDWFC x55,W
1322:  MOVWF  FEA
1324:  MOVFF  FEF,856
1328:  MOVLW  02
132A:  SUBWF  x45,W
132C:  MOVWF  x57
132E:  MOVLW  00
1330:  SUBWFB x46,W
1332:  MOVWF  x58
1334:  MOVF   x41,W
1336:  ADDWF  x57,W
1338:  MOVWF  FE9
133A:  MOVF   x42,W
133C:  ADDWFC x58,W
133E:  MOVWF  FEA
1340:  MOVFF  FEF,859
1344:  MOVLW  01
1346:  SUBWF  x45,W
1348:  MOVWF  x5A
134A:  MOVLW  00
134C:  SUBWFB x46,W
134E:  MOVWF  x5B
1350:  MOVF   x41,W
1352:  ADDWF  x5A,W
1354:  MOVWF  FE9
1356:  MOVF   x42,W
1358:  ADDWFC x5B,W
135A:  MOVWF  FEA
135C:  MOVFF  FEF,85C
1360:  MOVF   x41,W
1362:  ADDWF  x45,W
1364:  MOVWF  FE9
1366:  MOVF   x42,W
1368:  ADDWFC x46,W
136A:  MOVWF  FEA
136C:  MOVFF  FEF,85D
1370:  CLRF   x60
1372:  MOVFF  84D,861
1376:  MOVFF  850,862
137A:  MOVFF  853,863
137E:  MOVFF  856,864
1382:  MOVFF  859,865
1386:  MOVFF  85C,866
138A:  MOVFF  85D,867
138E:  MOVLB  0
1390:  CALL   0702
1394:  MOVFF  01,849
....................                j=j-7;             
1398:  MOVLW  07
139A:  MOVLB  8
139C:  SUBWF  x45,F
139E:  MOVLW  00
13A0:  SUBWFB x46,F
....................              } 
13A2:  BRA    1284
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
13A4:  DECFSZ x4A,W
13A6:  BRA    13BC
....................             { 
....................                dir=1; 
13A8:  MOVLW  01
13AA:  MOVLB  6
13AC:  MOVWF  xCC
....................                return i; 
13AE:  MOVLB  8
13B0:  MOVFF  843,01
13B4:  MOVFF  844,02
13B8:  BRA    1656
....................             } 
....................             else return 0; 
13BA:  BRA    13C4
13BC:  MOVLW  00
13BE:  MOVWF  01
13C0:  MOVWF  02
13C2:  BRA    1656
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
13C4:  BRA    1646
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
13C6:  MOVLW  04
13C8:  SUBWF  x43,W
13CA:  MOVWF  x4B
13CC:  MOVLW  00
13CE:  SUBWFB x44,W
13D0:  MOVWF  x4C
13D2:  MOVF   x41,W
13D4:  ADDWF  x4B,W
13D6:  MOVWF  FE9
13D8:  MOVF   x42,W
13DA:  ADDWFC x4C,W
13DC:  MOVWF  FEA
13DE:  MOVFF  FEF,84D
13E2:  MOVLW  03
13E4:  SUBWF  x43,W
13E6:  MOVWF  x4E
13E8:  MOVLW  00
13EA:  SUBWFB x44,W
13EC:  MOVWF  x4F
13EE:  MOVF   x41,W
13F0:  ADDWF  x4E,W
13F2:  MOVWF  FE9
13F4:  MOVF   x42,W
13F6:  ADDWFC x4F,W
13F8:  MOVWF  FEA
13FA:  MOVFF  FEF,850
13FE:  MOVLW  02
1400:  SUBWF  x43,W
1402:  MOVWF  x51
1404:  MOVLW  00
1406:  SUBWFB x44,W
1408:  MOVWF  x52
140A:  MOVF   x41,W
140C:  ADDWF  x51,W
140E:  MOVWF  FE9
1410:  MOVF   x42,W
1412:  ADDWFC x52,W
1414:  MOVWF  FEA
1416:  MOVFF  FEF,853
141A:  MOVLW  01
141C:  SUBWF  x43,W
141E:  MOVWF  x54
1420:  MOVLW  00
1422:  SUBWFB x44,W
1424:  MOVWF  x55
1426:  MOVF   x41,W
1428:  ADDWF  x54,W
142A:  MOVWF  FE9
142C:  MOVF   x42,W
142E:  ADDWFC x55,W
1430:  MOVWF  FEA
1432:  MOVFF  FEF,856
1436:  MOVF   x41,W
1438:  ADDWF  x43,W
143A:  MOVWF  FE9
143C:  MOVF   x42,W
143E:  ADDWFC x44,W
1440:  MOVWF  FEA
1442:  MOVFF  FEF,857
1446:  CLRF   x60
1448:  CLRF   x61
144A:  CLRF   x62
144C:  MOVFF  84D,863
1450:  MOVFF  850,864
1454:  MOVFF  853,865
1458:  MOVFF  856,866
145C:  MOVFF  857,867
1460:  MOVLB  0
1462:  CALL   0702
1466:  MOVFF  01,847
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
146A:  MOVLW  09
146C:  MOVLB  8
146E:  SUBWF  x43,W
1470:  MOVWF  x4B
1472:  MOVLW  00
1474:  SUBWFB x44,W
1476:  MOVWF  x4C
1478:  MOVF   x41,W
147A:  ADDWF  x4B,W
147C:  MOVWF  FE9
147E:  MOVF   x42,W
1480:  ADDWFC x4C,W
1482:  MOVWF  FEA
1484:  MOVFF  FEF,84D
1488:  MOVLW  08
148A:  SUBWF  x43,W
148C:  MOVWF  x4E
148E:  MOVLW  00
1490:  SUBWFB x44,W
1492:  MOVWF  x4F
1494:  MOVF   x41,W
1496:  ADDWF  x4E,W
1498:  MOVWF  FE9
149A:  MOVF   x42,W
149C:  ADDWFC x4F,W
149E:  MOVWF  FEA
14A0:  MOVFF  FEF,850
14A4:  MOVLW  07
14A6:  SUBWF  x43,W
14A8:  MOVWF  x51
14AA:  MOVLW  00
14AC:  SUBWFB x44,W
14AE:  MOVWF  x52
14B0:  MOVF   x41,W
14B2:  ADDWF  x51,W
14B4:  MOVWF  FE9
14B6:  MOVF   x42,W
14B8:  ADDWFC x52,W
14BA:  MOVWF  FEA
14BC:  MOVFF  FEF,853
14C0:  MOVLW  06
14C2:  SUBWF  x43,W
14C4:  MOVWF  x54
14C6:  MOVLW  00
14C8:  SUBWFB x44,W
14CA:  MOVWF  x55
14CC:  MOVF   x41,W
14CE:  ADDWF  x54,W
14D0:  MOVWF  FE9
14D2:  MOVF   x42,W
14D4:  ADDWFC x55,W
14D6:  MOVWF  FEA
14D8:  MOVFF  FEF,856
14DC:  MOVLW  05
14DE:  SUBWF  x43,W
14E0:  MOVWF  x57
14E2:  MOVLW  00
14E4:  SUBWFB x44,W
14E6:  MOVWF  x58
14E8:  MOVF   x41,W
14EA:  ADDWF  x57,W
14EC:  MOVWF  FE9
14EE:  MOVF   x42,W
14F0:  ADDWFC x58,W
14F2:  MOVWF  FEA
14F4:  MOVFF  FEF,859
14F8:  CLRF   x60
14FA:  CLRF   x61
14FC:  CLRF   x62
14FE:  MOVFF  84D,863
1502:  MOVFF  850,864
1506:  MOVFF  853,865
150A:  MOVFF  856,866
150E:  MOVFF  859,867
1512:  MOVLB  0
1514:  CALL   0702
1518:  MOVFF  01,848
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
151C:  MOVLB  8
151E:  MOVF   x47,W
1520:  SUBLW  0B
1522:  BTFSS  FD8.2
1524:  BRA    1646
1526:  MOVF   x48,W
1528:  SUBLW  1F
152A:  BTFSC  FD8.2
152C:  BRA    1646
152E:  MOVF   x48,W
1530:  SUBLW  0F
1532:  BTFSC  FD8.2
1534:  BRA    1646
....................             { 
....................                j=i; 
1536:  MOVFF  844,846
153A:  MOVFF  843,845
....................                CRC=1; 
153E:  MOVLW  01
1540:  MOVWF  x4A
....................                temp2=temp; 
1542:  MOVFF  847,849
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
1546:  MOVF   x49,W
1548:  SUBLW  1F
154A:  BZ    1626
154C:  MOVF   x46,F
154E:  BNZ   1556
1550:  MOVF   x45,W
1552:  SUBLW  01
1554:  BC    1626
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1556:  MOVLW  01
1558:  MOVWF  x4B
155A:  MOVFF  846,84D
155E:  MOVFF  845,84C
1562:  MOVFF  842,84F
1566:  MOVFF  841,84E
156A:  MOVLB  0
156C:  CALL   0918
1570:  MOVF   01,W
1572:  MOVLB  8
1574:  ANDWF  x4A,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1576:  MOVLW  04
1578:  SUBWF  x45,W
157A:  MOVWF  x4B
157C:  MOVLW  00
157E:  SUBWFB x46,W
1580:  MOVWF  x4C
1582:  MOVF   x41,W
1584:  ADDWF  x4B,W
1586:  MOVWF  FE9
1588:  MOVF   x42,W
158A:  ADDWFC x4C,W
158C:  MOVWF  FEA
158E:  MOVFF  FEF,84D
1592:  MOVLW  03
1594:  SUBWF  x45,W
1596:  MOVWF  x4E
1598:  MOVLW  00
159A:  SUBWFB x46,W
159C:  MOVWF  x4F
159E:  MOVF   x41,W
15A0:  ADDWF  x4E,W
15A2:  MOVWF  FE9
15A4:  MOVF   x42,W
15A6:  ADDWFC x4F,W
15A8:  MOVWF  FEA
15AA:  MOVFF  FEF,850
15AE:  MOVLW  02
15B0:  SUBWF  x45,W
15B2:  MOVWF  x51
15B4:  MOVLW  00
15B6:  SUBWFB x46,W
15B8:  MOVWF  x52
15BA:  MOVF   x41,W
15BC:  ADDWF  x51,W
15BE:  MOVWF  FE9
15C0:  MOVF   x42,W
15C2:  ADDWFC x52,W
15C4:  MOVWF  FEA
15C6:  MOVFF  FEF,853
15CA:  MOVLW  01
15CC:  SUBWF  x45,W
15CE:  MOVWF  x54
15D0:  MOVLW  00
15D2:  SUBWFB x46,W
15D4:  MOVWF  x55
15D6:  MOVF   x41,W
15D8:  ADDWF  x54,W
15DA:  MOVWF  FE9
15DC:  MOVF   x42,W
15DE:  ADDWFC x55,W
15E0:  MOVWF  FEA
15E2:  MOVFF  FEF,856
15E6:  MOVF   x41,W
15E8:  ADDWF  x45,W
15EA:  MOVWF  FE9
15EC:  MOVF   x42,W
15EE:  ADDWFC x46,W
15F0:  MOVWF  FEA
15F2:  MOVFF  FEF,857
15F6:  CLRF   x60
15F8:  CLRF   x61
15FA:  CLRF   x62
15FC:  MOVFF  84D,863
1600:  MOVFF  850,864
1604:  MOVFF  853,865
1608:  MOVFF  856,866
160C:  MOVFF  857,867
1610:  MOVLB  0
1612:  CALL   0702
1616:  MOVFF  01,849
....................                   j=j-5; 
161A:  MOVLW  05
161C:  MOVLB  8
161E:  SUBWF  x45,F
1620:  MOVLW  00
1622:  SUBWFB x46,F
....................                } 
1624:  BRA    1546
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
1626:  DECFSZ x4A,W
1628:  BRA    163E
....................                { 
....................                   dir=1; 
162A:  MOVLW  01
162C:  MOVLB  6
162E:  MOVWF  xCC
....................                   return i; 
1630:  MOVLB  8
1632:  MOVFF  843,01
1636:  MOVFF  844,02
163A:  BRA    1656
....................                } 
....................                   else return 0; 
163C:  BRA    1646
163E:  MOVLW  00
1640:  MOVWF  01
1642:  MOVWF  02
1644:  BRA    1656
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
1646:  MOVF   x43,W
1648:  BTFSC  FD8.2
164A:  DECF   x44,F
164C:  DECF   x43,F
164E:  BRA    1048
....................    return 0; 
1650:  MOVLW  00
1652:  MOVWF  01
1654:  MOVWF  02
.................... } 
1656:  MOVLB  0
1658:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
36BE:  MOVLB  8
36C0:  CLRF   x3D
36C2:  MOVLW  01
36C4:  MOVWF  x3C
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
36C6:  MOVFF  832,83E
36CA:  MOVFF  834,840
36CE:  MOVFF  833,83F
36D2:  MOVFF  836,842
36D6:  MOVFF  835,841
36DA:  MOVLB  0
36DC:  CALL   0A58
36E0:  MOVFF  02,83D
36E4:  MOVFF  01,83C
....................    if(temp==0) return 0; 
36E8:  MOVLB  8
36EA:  MOVF   x3C,F
36EC:  BNZ   36F8
36EE:  MOVF   x3D,F
36F0:  BNZ   36F8
36F2:  MOVLW  00
36F4:  MOVWF  01
36F6:  BRA    3AA2
....................    j=temp; 
36F8:  MOVFF  83D,83B
36FC:  MOVFF  83C,83A
....................    if(dir==0) 
3700:  MOVLB  6
3702:  MOVF   xCC,F
3704:  BTFSS  FD8.2
3706:  BRA    38C2
....................    { 
....................       if(track==0) 
3708:  MOVLB  8
370A:  MOVF   x32,F
370C:  BTFSS  FD8.2
370E:  BRA    3806
....................       { 
....................             for(i=0;i<79;i++) 
3710:  CLRF   x39
3712:  MOVF   x39,W
3714:  SUBLW  4E
3716:  BNC   3804
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3718:  CLRF   03
371A:  MOVF   x39,W
371C:  ADDWF  x37,W
371E:  MOVWF  01
3720:  MOVF   x38,W
3722:  ADDWFC 03,F
3724:  MOVFF  01,83E
3728:  MOVFF  03,83F
372C:  MOVLW  05
372E:  ADDWF  x3A,W
3730:  MOVWF  x40
3732:  MOVLW  00
3734:  ADDWFC x3B,W
3736:  MOVWF  x41
3738:  MOVF   x35,W
373A:  ADDWF  x40,W
373C:  MOVWF  FE9
373E:  MOVF   x36,W
3740:  ADDWFC x41,W
3742:  MOVWF  FEA
3744:  MOVFF  FEF,842
3748:  MOVLW  04
374A:  ADDWF  x3A,W
374C:  MOVWF  x43
374E:  MOVLW  00
3750:  ADDWFC x3B,W
3752:  MOVWF  x44
3754:  MOVF   x35,W
3756:  ADDWF  x43,W
3758:  MOVWF  FE9
375A:  MOVF   x36,W
375C:  ADDWFC x44,W
375E:  MOVWF  FEA
3760:  MOVFF  FEF,845
3764:  MOVLW  03
3766:  ADDWF  x3A,W
3768:  MOVWF  x46
376A:  MOVLW  00
376C:  ADDWFC x3B,W
376E:  MOVWF  x47
3770:  MOVF   x35,W
3772:  ADDWF  x46,W
3774:  MOVWF  FE9
3776:  MOVF   x36,W
3778:  ADDWFC x47,W
377A:  MOVWF  FEA
377C:  MOVFF  FEF,848
3780:  MOVLW  02
3782:  ADDWF  x3A,W
3784:  MOVWF  x49
3786:  MOVLW  00
3788:  ADDWFC x3B,W
378A:  MOVWF  x4A
378C:  MOVF   x35,W
378E:  ADDWF  x49,W
3790:  MOVWF  FE9
3792:  MOVF   x36,W
3794:  ADDWFC x4A,W
3796:  MOVWF  FEA
3798:  MOVFF  FEF,84B
379C:  MOVLW  01
379E:  ADDWF  x3A,W
37A0:  MOVWF  x4C
37A2:  MOVLW  00
37A4:  ADDWFC x3B,W
37A6:  MOVWF  x4D
37A8:  MOVF   x35,W
37AA:  ADDWF  x4C,W
37AC:  MOVWF  FE9
37AE:  MOVF   x36,W
37B0:  ADDWFC x4D,W
37B2:  MOVWF  FEA
37B4:  MOVFF  FEF,84E
37B8:  MOVF   x35,W
37BA:  ADDWF  x3A,W
37BC:  MOVWF  FE9
37BE:  MOVF   x36,W
37C0:  ADDWFC x3B,W
37C2:  MOVWF  FEA
37C4:  MOVFF  FEF,84F
37C8:  CLRF   x60
37CA:  CLRF   x61
37CC:  MOVFF  842,862
37D0:  MOVFF  845,863
37D4:  MOVFF  848,864
37D8:  MOVFF  84B,865
37DC:  MOVFF  84E,866
37E0:  MOVFF  84F,867
37E4:  MOVLB  0
37E6:  CALL   0702
37EA:  MOVFF  83F,FEA
37EE:  MOVFF  83E,FE9
37F2:  MOVFF  01,FEF
....................                j=j+7; 
37F6:  MOVLW  07
37F8:  MOVLB  8
37FA:  ADDWF  x3A,F
37FC:  MOVLW  00
37FE:  ADDWFC x3B,F
....................             } 
3800:  INCF   x39,F
3802:  BRA    3712
....................       } 
....................          else  
3804:  BRA    38BE
....................          { 
....................             for(i=0;i<40;i++) 
3806:  CLRF   x39
3808:  MOVF   x39,W
380A:  SUBLW  27
380C:  BNC   38BE
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
380E:  CLRF   03
3810:  MOVF   x39,W
3812:  ADDWF  x37,W
3814:  MOVWF  01
3816:  MOVF   x38,W
3818:  ADDWFC 03,F
381A:  MOVFF  01,83E
381E:  MOVFF  03,83F
3822:  MOVLW  03
3824:  ADDWF  x3A,W
3826:  MOVWF  x40
3828:  MOVLW  00
382A:  ADDWFC x3B,W
382C:  MOVWF  x41
382E:  MOVF   x35,W
3830:  ADDWF  x40,W
3832:  MOVWF  FE9
3834:  MOVF   x36,W
3836:  ADDWFC x41,W
3838:  MOVWF  FEA
383A:  MOVFF  FEF,842
383E:  MOVLW  02
3840:  ADDWF  x3A,W
3842:  MOVWF  x43
3844:  MOVLW  00
3846:  ADDWFC x3B,W
3848:  MOVWF  x44
384A:  MOVF   x35,W
384C:  ADDWF  x43,W
384E:  MOVWF  FE9
3850:  MOVF   x36,W
3852:  ADDWFC x44,W
3854:  MOVWF  FEA
3856:  MOVFF  FEF,845
385A:  MOVLW  01
385C:  ADDWF  x3A,W
385E:  MOVWF  x46
3860:  MOVLW  00
3862:  ADDWFC x3B,W
3864:  MOVWF  x47
3866:  MOVF   x35,W
3868:  ADDWF  x46,W
386A:  MOVWF  FE9
386C:  MOVF   x36,W
386E:  ADDWFC x47,W
3870:  MOVWF  FEA
3872:  MOVFF  FEF,848
3876:  MOVF   x35,W
3878:  ADDWF  x3A,W
387A:  MOVWF  FE9
387C:  MOVF   x36,W
387E:  ADDWFC x3B,W
3880:  MOVWF  FEA
3882:  MOVFF  FEF,849
3886:  CLRF   x60
3888:  CLRF   x61
388A:  CLRF   x62
388C:  CLRF   x63
388E:  MOVFF  842,864
3892:  MOVFF  845,865
3896:  MOVFF  848,866
389A:  MOVFF  849,867
389E:  MOVLB  0
38A0:  CALL   0702
38A4:  MOVFF  83F,FEA
38A8:  MOVFF  83E,FE9
38AC:  MOVFF  01,FEF
....................                j=j+5; 
38B0:  MOVLW  05
38B2:  MOVLB  8
38B4:  ADDWF  x3A,F
38B6:  MOVLW  00
38B8:  ADDWFC x3B,F
....................             }          
38BA:  INCF   x39,F
38BC:  BRA    3808
....................          } 
....................    } 
....................       else  
38BE:  BRA    3A78
38C0:  MOVLB  6
....................       { 
....................          if(track==0) 
38C2:  MOVLB  8
38C4:  MOVF   x32,F
38C6:  BTFSS  FD8.2
38C8:  BRA    39C0
....................          { 
....................             for(i=0;i<79;i++) 
38CA:  CLRF   x39
38CC:  MOVF   x39,W
38CE:  SUBLW  4E
38D0:  BNC   39BE
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
38D2:  CLRF   03
38D4:  MOVF   x39,W
38D6:  ADDWF  x37,W
38D8:  MOVWF  01
38DA:  MOVF   x38,W
38DC:  ADDWFC 03,F
38DE:  MOVFF  01,83E
38E2:  MOVFF  03,83F
38E6:  MOVLW  05
38E8:  SUBWF  x3A,W
38EA:  MOVWF  x40
38EC:  MOVLW  00
38EE:  SUBWFB x3B,W
38F0:  MOVWF  x41
38F2:  MOVF   x35,W
38F4:  ADDWF  x40,W
38F6:  MOVWF  FE9
38F8:  MOVF   x36,W
38FA:  ADDWFC x41,W
38FC:  MOVWF  FEA
38FE:  MOVFF  FEF,842
3902:  MOVLW  04
3904:  SUBWF  x3A,W
3906:  MOVWF  x43
3908:  MOVLW  00
390A:  SUBWFB x3B,W
390C:  MOVWF  x44
390E:  MOVF   x35,W
3910:  ADDWF  x43,W
3912:  MOVWF  FE9
3914:  MOVF   x36,W
3916:  ADDWFC x44,W
3918:  MOVWF  FEA
391A:  MOVFF  FEF,845
391E:  MOVLW  03
3920:  SUBWF  x3A,W
3922:  MOVWF  x46
3924:  MOVLW  00
3926:  SUBWFB x3B,W
3928:  MOVWF  x47
392A:  MOVF   x35,W
392C:  ADDWF  x46,W
392E:  MOVWF  FE9
3930:  MOVF   x36,W
3932:  ADDWFC x47,W
3934:  MOVWF  FEA
3936:  MOVFF  FEF,848
393A:  MOVLW  02
393C:  SUBWF  x3A,W
393E:  MOVWF  x49
3940:  MOVLW  00
3942:  SUBWFB x3B,W
3944:  MOVWF  x4A
3946:  MOVF   x35,W
3948:  ADDWF  x49,W
394A:  MOVWF  FE9
394C:  MOVF   x36,W
394E:  ADDWFC x4A,W
3950:  MOVWF  FEA
3952:  MOVFF  FEF,84B
3956:  MOVLW  01
3958:  SUBWF  x3A,W
395A:  MOVWF  x4C
395C:  MOVLW  00
395E:  SUBWFB x3B,W
3960:  MOVWF  x4D
3962:  MOVF   x35,W
3964:  ADDWF  x4C,W
3966:  MOVWF  FE9
3968:  MOVF   x36,W
396A:  ADDWFC x4D,W
396C:  MOVWF  FEA
396E:  MOVFF  FEF,84E
3972:  MOVF   x35,W
3974:  ADDWF  x3A,W
3976:  MOVWF  FE9
3978:  MOVF   x36,W
397A:  ADDWFC x3B,W
397C:  MOVWF  FEA
397E:  MOVFF  FEF,84F
3982:  CLRF   x60
3984:  CLRF   x61
3986:  MOVFF  842,862
398A:  MOVFF  845,863
398E:  MOVFF  848,864
3992:  MOVFF  84B,865
3996:  MOVFF  84E,866
399A:  MOVFF  84F,867
399E:  MOVLB  0
39A0:  CALL   0702
39A4:  MOVFF  83F,FEA
39A8:  MOVFF  83E,FE9
39AC:  MOVFF  01,FEF
....................                j=j-7; 
39B0:  MOVLW  07
39B2:  MOVLB  8
39B4:  SUBWF  x3A,F
39B6:  MOVLW  00
39B8:  SUBWFB x3B,F
....................             } 
39BA:  INCF   x39,F
39BC:  BRA    38CC
....................          } 
....................             else 
39BE:  BRA    3A78
....................             { 
....................                for(i=0;i<40;i++) 
39C0:  CLRF   x39
39C2:  MOVF   x39,W
39C4:  SUBLW  27
39C6:  BNC   3A78
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
39C8:  CLRF   03
39CA:  MOVF   x39,W
39CC:  ADDWF  x37,W
39CE:  MOVWF  01
39D0:  MOVF   x38,W
39D2:  ADDWFC 03,F
39D4:  MOVFF  01,83E
39D8:  MOVFF  03,83F
39DC:  MOVLW  03
39DE:  SUBWF  x3A,W
39E0:  MOVWF  x40
39E2:  MOVLW  00
39E4:  SUBWFB x3B,W
39E6:  MOVWF  x41
39E8:  MOVF   x35,W
39EA:  ADDWF  x40,W
39EC:  MOVWF  FE9
39EE:  MOVF   x36,W
39F0:  ADDWFC x41,W
39F2:  MOVWF  FEA
39F4:  MOVFF  FEF,842
39F8:  MOVLW  02
39FA:  SUBWF  x3A,W
39FC:  MOVWF  x43
39FE:  MOVLW  00
3A00:  SUBWFB x3B,W
3A02:  MOVWF  x44
3A04:  MOVF   x35,W
3A06:  ADDWF  x43,W
3A08:  MOVWF  FE9
3A0A:  MOVF   x36,W
3A0C:  ADDWFC x44,W
3A0E:  MOVWF  FEA
3A10:  MOVFF  FEF,845
3A14:  MOVLW  01
3A16:  SUBWF  x3A,W
3A18:  MOVWF  x46
3A1A:  MOVLW  00
3A1C:  SUBWFB x3B,W
3A1E:  MOVWF  x47
3A20:  MOVF   x35,W
3A22:  ADDWF  x46,W
3A24:  MOVWF  FE9
3A26:  MOVF   x36,W
3A28:  ADDWFC x47,W
3A2A:  MOVWF  FEA
3A2C:  MOVFF  FEF,848
3A30:  MOVF   x35,W
3A32:  ADDWF  x3A,W
3A34:  MOVWF  FE9
3A36:  MOVF   x36,W
3A38:  ADDWFC x3B,W
3A3A:  MOVWF  FEA
3A3C:  MOVFF  FEF,849
3A40:  CLRF   x60
3A42:  CLRF   x61
3A44:  CLRF   x62
3A46:  CLRF   x63
3A48:  MOVFF  842,864
3A4C:  MOVFF  845,865
3A50:  MOVFF  848,866
3A54:  MOVFF  849,867
3A58:  MOVLB  0
3A5A:  CALL   0702
3A5E:  MOVFF  83F,FEA
3A62:  MOVFF  83E,FE9
3A66:  MOVFF  01,FEF
....................                   j=j-5; 
3A6A:  MOVLW  05
3A6C:  MOVLB  8
3A6E:  SUBWF  x3A,F
3A70:  MOVLW  00
3A72:  SUBWFB x3B,F
....................                }             
3A74:  INCF   x39,F
3A76:  BRA    39C2
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3A78:  MOVF   x32,F
3A7A:  BNZ   3A90
3A7C:  MOVLW  52
3A7E:  MOVWF  x3E
3A80:  MOVFF  836,840
3A84:  MOVFF  835,83F
3A88:  MOVLB  0
3A8A:  RCALL  369C
....................          else del_buf(numbyteofbuffer2,datin); 
3A8C:  BRA    3AA0
3A8E:  MOVLB  8
3A90:  MOVLW  2C
3A92:  MOVWF  x3E
3A94:  MOVFF  836,840
3A98:  MOVFF  835,83F
3A9C:  MOVLB  0
3A9E:  RCALL  369C
3AA0:  MOVLB  8
.................... } 
3AA2:  MOVLB  0
3AA4:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1832:  MOVLW  B2
1834:  MOVWF  FF6
1836:  MOVLW  05
1838:  MOVWF  FF7
183A:  CALL   06E2
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
183E:  MOVLB  8
1840:  CLRF   x36
1842:  CLRF   x35
1844:  MOVF   x36,W
1846:  SUBLW  03
1848:  BNC   1878
184A:  BNZ   1852
184C:  MOVF   x35,W
184E:  SUBLW  51
1850:  BNC   1878
1852:  MOVLW  4A
1854:  ADDWF  x35,W
1856:  MOVWF  FE9
1858:  MOVLW  02
185A:  ADDWFC x36,W
185C:  MOVWF  FEA
185E:  MOVFF  FEF,837
1862:  MOVFF  837,838
1866:  MOVLW  18
1868:  MOVWF  x39
186A:  MOVLB  0
186C:  RCALL  176E
186E:  MOVLB  8
1870:  INCF   x35,F
1872:  BTFSC  FD8.2
1874:  INCF   x36,F
1876:  BRA    1844
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1878:  MOVLW  C8
187A:  MOVWF  FF6
187C:  MOVLW  05
187E:  MOVWF  FF7
1880:  MOVLB  0
1882:  CALL   06E2
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1886:  MOVLB  8
1888:  CLRF   x36
188A:  CLRF   x35
188C:  MOVF   x36,W
188E:  SUBLW  01
1890:  BNC   18C0
1892:  BNZ   189A
1894:  MOVF   x35,W
1896:  SUBLW  2B
1898:  BNC   18C0
189A:  MOVLW  9C
189C:  ADDWF  x35,W
189E:  MOVWF  FE9
18A0:  MOVLW  05
18A2:  ADDWFC x36,W
18A4:  MOVWF  FEA
18A6:  MOVFF  FEF,837
18AA:  MOVFF  837,838
18AE:  MOVLW  18
18B0:  MOVWF  x39
18B2:  MOVLB  0
18B4:  RCALL  176E
18B6:  MOVLB  8
18B8:  INCF   x35,F
18BA:  BTFSC  FD8.2
18BC:  INCF   x36,F
18BE:  BRA    188C
.................... } 
18C0:  MOVLB  0
18C2:  GOTO   1B58 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3C32:  MOVLW  01
3C34:  MOVLB  6
3C36:  MOVWF  xDC
....................    //rtc_get_date(date,mon,year,day); 
....................    //rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3C38:  MOVLB  0
3C3A:  RCALL  3622
3C3C:  MOVFF  02,833
3C40:  MOVFF  01,832
3C44:  MOVFF  02,835
3C48:  MOVFF  01,834
3C4C:  MOVLB  8
3C4E:  CLRF   x37
3C50:  MOVLW  7C
3C52:  MOVWF  x36
3C54:  MOVLB  0
3C56:  RCALL  367A
3C58:  MOVFF  01,832
3C5C:  MOVLW  96
3C5E:  MOVLB  8
3C60:  ADDWF  01,W
3C62:  MOVWF  01
3C64:  MOVLW  00
3C66:  ADDWFC 02,W
3C68:  MOVFF  01,20
3C6C:  MOVWF  21
3C6E:  CLRF   22
3C70:  CLRF   23
....................    if(datinbuf==0)  
3C72:  MOVLB  6
3C74:  MOVF   xD9,F
3C76:  BNZ   3C98
....................    { 
....................       countbit_T1=0; 
3C78:  CLRF   xCE
3C7A:  CLRF   xCD
....................       countbit_T2=0; 
3C7C:  CLRF   xD0
3C7E:  CLRF   xCF
....................       bug_countbit_T1=0; 
3C80:  CLRF   xD2
3C82:  CLRF   xD1
....................       bug_countbit_T2=0; 
3C84:  CLRF   xD4
3C86:  CLRF   xD3
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3C88:  MOVF   xDD,F
3C8A:  BNZ   3C94
3C8C:  MOVLB  0
3C8E:  SETF   xFC
3C90:  SETF   xFB
3C92:  MOVLB  6
....................       saving_flag=0; 
3C94:  CLRF   xDC
....................       return; 
3C96:  BRA    4034
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3C98:  MOVLW  DE
3C9A:  MOVWF  FF6
3C9C:  MOVLW  05
3C9E:  MOVWF  FF7
3CA0:  MOVLB  0
3CA2:  CALL   06E2
....................    key_timeout=0; 
3CA6:  MOVLB  1
3CA8:  CLRF   x4A
3CAA:  CLRF   x49
....................    //key_count=0; 
....................    enable_getpin=1; 
3CAC:  MOVLW  01
3CAE:  MOVWF  x4D
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3CB0:  MOVFF  6CE,831
3CB4:  MOVFF  6CD,830
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3CB8:  MOVLB  8
3CBA:  CLRF   x32
3CBC:  MOVFF  831,834
3CC0:  MOVFF  830,833
3CC4:  MOVLW  02
3CC6:  MOVWF  x36
3CC8:  MOVLW  4A
3CCA:  MOVWF  x35
3CCC:  MOVLW  01
3CCE:  MOVWF  x38
3CD0:  MOVLW  D3
3CD2:  MOVWF  x37
3CD4:  MOVLB  0
3CD6:  RCALL  36BE
....................    countbit_T1=0; 
3CD8:  MOVLB  6
3CDA:  CLRF   xCE
3CDC:  CLRF   xCD
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3CDE:  MOVFF  6D0,831
3CE2:  MOVFF  6CF,830
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3CE6:  MOVLW  01
3CE8:  MOVLB  8
3CEA:  MOVWF  x32
3CEC:  MOVFF  831,834
3CF0:  MOVFF  830,833
3CF4:  MOVLW  05
3CF6:  MOVWF  x36
3CF8:  MOVLW  9C
3CFA:  MOVWF  x35
3CFC:  MOVLW  02
3CFE:  MOVWF  x38
3D00:  MOVLW  22
3D02:  MOVWF  x37
3D04:  MOVLB  0
3D06:  RCALL  36BE
....................    countbit_T2=0; 
3D08:  MOVLB  6
3D0A:  CLRF   xD0
3D0C:  CLRF   xCF
....................    saving_flag=0; 
3D0E:  CLRF   xDC
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3D10:  MOVLW  20
3D12:  MOVLB  1
3D14:  ADDWF  xD3,W
3D16:  MOVLB  8
3D18:  MOVWF  x2F
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
3D1A:  MOVF   23,F
3D1C:  BTFSS  FD8.2
3D1E:  BRA    4032
3D20:  MOVF   22,W
3D22:  SUBLW  01
3D24:  BTFSS  FD8.0
3D26:  BRA    4032
3D28:  BNZ   3D3C
3D2A:  MOVF   21,W
3D2C:  SUBLW  C3
3D2E:  BTFSS  FD8.0
3D30:  BRA    4032
3D32:  BNZ   3D3C
3D34:  MOVF   20,W
3D36:  SUBLW  0D
3D38:  BTFSS  FD8.0
3D3A:  BRA    4032
3D3C:  MOVF   x2F,W
3D3E:  SUBLW  25
3D40:  BTFSS  FD8.2
3D42:  BRA    4032
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3D44:  MOVFF  23,03
3D48:  MOVFF  22,02
3D4C:  MOVFF  21,01
3D50:  MOVFF  20,00
3D54:  MOVLW  01
3D56:  ADDWF  20,F
3D58:  BTFSC  FD8.0
3D5A:  INCF   21,F
3D5C:  BTFSC  FD8.2
3D5E:  INCF   22,F
3D60:  BTFSC  FD8.2
3D62:  INCF   23,F
3D64:  MOVFF  01,833
3D68:  MOVFF  00,832
3D6C:  CLRF   x43
3D6E:  CLRF   x42
3D70:  MOVFF  01,841
3D74:  MOVFF  00,840
3D78:  MOVFF  100,844
3D7C:  MOVLB  0
3D7E:  RCALL  3AA6
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3D80:  MOVFF  23,03
3D84:  MOVFF  22,02
3D88:  MOVFF  21,01
3D8C:  MOVFF  20,00
3D90:  MOVLW  01
3D92:  ADDWF  20,F
3D94:  BTFSC  FD8.0
3D96:  INCF   21,F
3D98:  BTFSC  FD8.2
3D9A:  INCF   22,F
3D9C:  BTFSC  FD8.2
3D9E:  INCF   23,F
3DA0:  MOVFF  01,833
3DA4:  MOVFF  00,832
3DA8:  MOVLB  8
3DAA:  CLRF   x43
3DAC:  CLRF   x42
3DAE:  MOVFF  01,841
3DB2:  MOVFF  00,840
3DB6:  MOVFF  FF,844
3DBA:  MOVLB  0
3DBC:  RCALL  3AA6
....................          write_ext_eeprom((long int)ptr_card++,h); 
3DBE:  MOVFF  23,03
3DC2:  MOVFF  22,02
3DC6:  MOVFF  21,01
3DCA:  MOVFF  20,00
3DCE:  MOVLW  01
3DD0:  ADDWF  20,F
3DD2:  BTFSC  FD8.0
3DD4:  INCF   21,F
3DD6:  BTFSC  FD8.2
3DD8:  INCF   22,F
3DDA:  BTFSC  FD8.2
3DDC:  INCF   23,F
3DDE:  MOVFF  01,833
3DE2:  MOVFF  00,832
3DE6:  MOVLB  8
3DE8:  CLRF   x43
3DEA:  CLRF   x42
3DEC:  MOVFF  01,841
3DF0:  MOVFF  00,840
3DF4:  MOVFF  101,844
3DF8:  MOVLB  0
3DFA:  RCALL  3AA6
....................          write_ext_eeprom((long int)ptr_card++,min); 
3DFC:  MOVFF  23,03
3E00:  MOVFF  22,02
3E04:  MOVFF  21,01
3E08:  MOVFF  20,00
3E0C:  MOVLW  01
3E0E:  ADDWF  20,F
3E10:  BTFSC  FD8.0
3E12:  INCF   21,F
3E14:  BTFSC  FD8.2
3E16:  INCF   22,F
3E18:  BTFSC  FD8.2
3E1A:  INCF   23,F
3E1C:  MOVFF  01,833
3E20:  MOVFF  00,832
3E24:  MOVLB  8
3E26:  CLRF   x43
3E28:  CLRF   x42
3E2A:  MOVFF  01,841
3E2E:  MOVFF  00,840
3E32:  MOVFF  102,844
3E36:  MOVLB  0
3E38:  RCALL  3AA6
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3E3A:  MOVFF  23,03
3E3E:  MOVFF  22,02
3E42:  MOVFF  21,01
3E46:  MOVFF  20,00
3E4A:  MOVLW  01
3E4C:  ADDWF  20,F
3E4E:  BTFSC  FD8.0
3E50:  INCF   21,F
3E52:  BTFSC  FD8.2
3E54:  INCF   22,F
3E56:  BTFSC  FD8.2
3E58:  INCF   23,F
3E5A:  MOVFF  01,833
3E5E:  MOVFF  00,832
3E62:  MOVLB  8
3E64:  CLRF   x43
3E66:  CLRF   x42
3E68:  MOVFF  01,841
3E6C:  MOVFF  00,840
3E70:  MOVFF  103,844
3E74:  MOVLB  0
3E76:  RCALL  3AA6
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3E78:  MOVLB  6
3E7A:  CLRF   xD8
3E7C:  CLRF   xD7
3E7E:  MOVF   xD8,F
3E80:  BNZ   3EE2
3E82:  MOVF   xD7,W
3E84:  SUBLW  4E
3E86:  BNC   3EE2
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3E88:  MOVFF  23,03
3E8C:  MOVFF  22,02
3E90:  MOVFF  21,01
3E94:  MOVFF  20,00
3E98:  MOVLW  01
3E9A:  ADDWF  20,F
3E9C:  BTFSC  FD8.0
3E9E:  INCF   21,F
3EA0:  BTFSC  FD8.2
3EA2:  INCF   22,F
3EA4:  BTFSC  FD8.2
3EA6:  INCF   23,F
3EA8:  MOVFF  01,833
3EAC:  MOVFF  00,832
3EB0:  MOVLW  D3
3EB2:  ADDWF  xD7,W
3EB4:  MOVWF  FE9
3EB6:  MOVLW  01
3EB8:  ADDWFC xD8,W
3EBA:  MOVWF  FEA
3EBC:  MOVF   FEF,W
3EBE:  ANDLW  3F
3EC0:  ADDLW  20
3EC2:  MOVLB  8
3EC4:  MOVWF  x34
3EC6:  CLRF   x43
3EC8:  CLRF   x42
3ECA:  MOVFF  01,841
3ECE:  MOVFF  00,840
3ED2:  MOVWF  x44
3ED4:  MOVLB  0
3ED6:  RCALL  3AA6
....................              
....................          } 
3ED8:  MOVLB  6
3EDA:  INCF   xD7,F
3EDC:  BTFSC  FD8.2
3EDE:  INCF   xD8,F
3EE0:  BRA    3E7E
....................          del_buf(numbyteoftrack1,Track1); 
3EE2:  MOVLW  4F
3EE4:  MOVLB  8
3EE6:  MOVWF  x3E
3EE8:  MOVLW  01
3EEA:  MOVWF  x40
3EEC:  MOVLW  D3
3EEE:  MOVWF  x3F
3EF0:  MOVLB  0
3EF2:  CALL   369C
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3EF6:  MOVLB  6
3EF8:  CLRF   xD8
3EFA:  CLRF   xD7
3EFC:  MOVF   xD8,F
3EFE:  BNZ   3F60
3F00:  MOVF   xD7,W
3F02:  SUBLW  27
3F04:  BNC   3F60
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3F06:  MOVFF  23,03
3F0A:  MOVFF  22,02
3F0E:  MOVFF  21,01
3F12:  MOVFF  20,00
3F16:  MOVLW  01
3F18:  ADDWF  20,F
3F1A:  BTFSC  FD8.0
3F1C:  INCF   21,F
3F1E:  BTFSC  FD8.2
3F20:  INCF   22,F
3F22:  BTFSC  FD8.2
3F24:  INCF   23,F
3F26:  MOVFF  01,833
3F2A:  MOVFF  00,832
3F2E:  MOVLW  22
3F30:  ADDWF  xD7,W
3F32:  MOVWF  FE9
3F34:  MOVLW  02
3F36:  ADDWFC xD8,W
3F38:  MOVWF  FEA
3F3A:  MOVF   FEF,W
3F3C:  ANDLW  0F
3F3E:  ADDLW  30
3F40:  MOVLB  8
3F42:  MOVWF  x34
3F44:  CLRF   x43
3F46:  CLRF   x42
3F48:  MOVFF  01,841
3F4C:  MOVFF  00,840
3F50:  MOVWF  x44
3F52:  MOVLB  0
3F54:  RCALL  3AA6
....................          }  
3F56:  MOVLB  6
3F58:  INCF   xD7,F
3F5A:  BTFSC  FD8.2
3F5C:  INCF   xD8,F
3F5E:  BRA    3EFC
....................          del_buf(numbyteoftrack2,Track2); 
3F60:  MOVLW  28
3F62:  MOVLB  8
3F64:  MOVWF  x3E
3F66:  MOVLW  02
3F68:  MOVWF  x40
3F6A:  MOVLW  22
3F6C:  MOVWF  x3F
3F6E:  MOVLB  0
3F70:  CALL   369C
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
3F74:  MOVLW  0D
3F76:  MOVLB  8
3F78:  MOVWF  x58
3F7A:  MOVLB  0
3F7C:  CALL   069C
3F80:  MOVLW  0A
3F82:  MOVLB  8
3F84:  MOVWF  x58
3F86:  MOVLB  0
3F88:  CALL   069C
....................       fprintf(COM2,"Done"); 
3F8C:  MOVLW  F4
3F8E:  MOVWF  FF6
3F90:  MOVLW  05
3F92:  MOVWF  FF7
3F94:  CALL   06E2
....................       if(KP_mode) 
3F98:  MOVLB  1
3F9A:  MOVF   x50,F
3F9C:  BZ    3FB4
....................       { 
....................          printf("\n\rKey release\n\r"); 
3F9E:  MOVLW  FA
3FA0:  MOVWF  FF6
3FA2:  MOVLW  05
3FA4:  MOVWF  FF7
3FA6:  MOVLB  0
3FA8:  CALL   06E2
....................          keyprss_off; 
3FAC:  BCF    F92.7
3FAE:  BCF    F89.7
....................          kp_st=0; 
3FB0:  MOVLB  1
3FB2:  CLRF   x51
....................       }   
....................       count_kp=0xffff; 
3FB4:  SETF   x53
3FB6:  SETF   x52
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
3FB8:  MOVLW  0D
3FBA:  MOVLB  8
3FBC:  MOVWF  x58
3FBE:  MOVLB  0
3FC0:  CALL   069C
3FC4:  MOVLW  0A
3FC6:  MOVLB  8
3FC8:  MOVWF  x58
3FCA:  MOVLB  0
3FCC:  CALL   069C
....................       fprintf(COM2,"Waiting for PIN number"); 
3FD0:  MOVLW  0A
3FD2:  MOVWF  FF6
3FD4:  MOVLW  06
3FD6:  MOVWF  FF7
3FD8:  CALL   06E2
....................       count_checking=0; 
3FDC:  MOVLB  1
3FDE:  CLRF   x07
3FE0:  CLRF   x06
....................       fprintf(COM2,"\r\n"); 
3FE2:  MOVLW  0D
3FE4:  MOVLB  8
3FE6:  MOVWF  x58
3FE8:  MOVLB  0
3FEA:  CALL   069C
3FEE:  MOVLW  0A
3FF0:  MOVLB  8
3FF2:  MOVWF  x58
3FF4:  MOVLB  0
3FF6:  CALL   069C
....................       charac_timeout=0; 
3FFA:  CLRF   xFC
3FFC:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3FFE:  MOVFF  23,835
4002:  MOVFF  22,834
4006:  MOVFF  21,833
400A:  MOVFF  20,832
400E:  MOVLW  19
4010:  MOVLB  8
4012:  MOVWF  x36
4014:  MOVLB  0
4016:  RCALL  3BA4
....................       datinbuf=0; 
4018:  MOVLB  6
401A:  CLRF   xD9
....................       saving_flag=0; 
401C:  CLRF   xDC
....................       data_avai=1; 
401E:  MOVLW  01
4020:  MOVWF  xDD
....................       enable_getpin=1; 
4022:  MOVLB  1
4024:  MOVWF  x4D
....................       charac_timeout=0; 
4026:  MOVLB  0
4028:  CLRF   xFC
402A:  CLRF   xFB
....................       key_count_ms=0; 
402C:  MOVLB  1
402E:  CLRF   x4F
4030:  MOVLB  8
4032:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
4034:  MOVLB  0
4036:  GOTO   43C2 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
18EE:  MOVLW  01
18F0:  MOVLB  8
18F2:  MOVWF  x2C
18F4:  MOVWF  x2D
18F6:  MOVWF  x2E
18F8:  MOVWF  x2F
18FA:  CLRF   x30
18FC:  MOVWF  x31
18FE:  MOVWF  x32
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1900:  MOVLB  6
1902:  CLRF   xD6
1904:  CLRF   xD5
....................    mcr_timeout=0; 
1906:  CLRF   xCB
1908:  CLRF   xCA
190A:  CLRF   xC9
190C:  CLRF   xC8
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
190E:  MOVF   xD6,W
1910:  SUBLW  FD
1912:  BNC   1930
1914:  BNZ   191C
1916:  MOVF   xD5,W
1918:  SUBLW  E7
191A:  BNC   1930
191C:  BSF    F93.1
191E:  BTFSS  F81.1
1920:  BRA    1930
1922:  BSF    F94.5
1924:  BTFSS  F82.5
1926:  BRA    1930
....................       card_timeout++; 
1928:  INCF   xD5,F
192A:  BTFSC  FD8.2
192C:  INCF   xD6,F
....................    } 
192E:  BRA    190E
....................    card_timeout=0; 
1930:  CLRF   xD6
1932:  CLRF   xD5
....................    buffertrack1[bug_countbit_T1++]=0; 
1934:  MOVFF  6D2,03
1938:  MOVF   xD1,W
193A:  INCF   xD1,F
193C:  BTFSC  FD8.2
193E:  INCF   xD2,F
1940:  MOVLB  8
1942:  MOVWF  x35
1944:  MOVLW  4A
1946:  ADDWF  x35,W
1948:  MOVWF  FE9
194A:  MOVLW  02
194C:  ADDWFC 03,W
194E:  MOVWF  FEA
1950:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1952:  MOVLB  6
1954:  MOVFF  6D2,03
1958:  MOVF   xD1,W
195A:  INCF   xD1,F
195C:  BTFSC  FD8.2
195E:  INCF   xD2,F
1960:  MOVLB  8
1962:  MOVWF  x35
1964:  MOVLW  4A
1966:  ADDWF  x35,W
1968:  MOVWF  FE9
196A:  MOVLW  02
196C:  ADDWFC 03,W
196E:  MOVWF  FEA
1970:  MOVLW  01
1972:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1974:  MOVLB  6
1976:  MOVFF  6D4,03
197A:  MOVF   xD3,W
197C:  INCF   xD3,F
197E:  BTFSC  FD8.2
1980:  INCF   xD4,F
1982:  MOVLB  8
1984:  MOVWF  x35
1986:  MOVLW  9C
1988:  ADDWF  x35,W
198A:  MOVWF  FE9
198C:  MOVLW  05
198E:  ADDWFC 03,W
1990:  MOVWF  FEA
1992:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1994:  MOVLB  6
1996:  MOVFF  6D4,03
199A:  MOVF   xD3,W
199C:  INCF   xD3,F
199E:  BTFSC  FD8.2
19A0:  INCF   xD4,F
19A2:  MOVLB  8
19A4:  MOVWF  x35
19A6:  MOVLW  9C
19A8:  ADDWF  x35,W
19AA:  MOVWF  FE9
19AC:  MOVLW  05
19AE:  ADDWFC 03,W
19B0:  MOVWF  FEA
19B2:  MOVLW  01
19B4:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
19B6:  MOVLB  6
19B8:  MOVF   xD2,W
19BA:  SUBLW  03
19BC:  BTFSS  FD8.0
19BE:  BRA    1A9E
19C0:  BNZ   19CA
19C2:  MOVF   xD1,W
19C4:  SUBLW  51
19C6:  BTFSS  FD8.0
19C8:  BRA    1A9E
19CA:  MOVF   xD4,W
19CC:  SUBLW  01
19CE:  BTFSS  FD8.0
19D0:  BRA    1A9E
19D2:  BNZ   19DA
19D4:  MOVF   xD3,W
19D6:  SUBLW  2B
19D8:  BNC   1A9E
19DA:  MOVF   xD6,W
19DC:  SUBLW  FF
19DE:  BNC   1A9E
19E0:  BNZ   19E8
19E2:  MOVF   xD5,W
19E4:  SUBLW  DB
19E6:  BNC   1A9E
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
19E8:  MOVF   xDF,F
19EA:  BZ    19F4
....................          { 
....................             bug_countbit_T1=0; 
19EC:  CLRF   xD2
19EE:  CLRF   xD1
....................             bug_countbit_T2=0; 
19F0:  CLRF   xD4
19F2:  CLRF   xD3
....................          } 
....................          card_timeout++; 
19F4:  INCF   xD5,F
19F6:  BTFSC  FD8.2
19F8:  INCF   xD6,F
....................          mcr_timeout=0; 
19FA:  CLRF   xCB
19FC:  CLRF   xCA
19FE:  CLRF   xC9
1A00:  CLRF   xC8
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1A02:  BSF    F93.2
1A04:  MOVLB  8
1A06:  CLRF   x2C
1A08:  BTFSC  F81.2
1A0A:  INCF   x2C,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1A0C:  MOVF   x2C,F
1A0E:  BNZ   1A4C
1A10:  DECFSZ x2D,W
1A12:  BRA    1A4C
....................          { 
....................             ST1_old = 0; 
1A14:  CLRF   x2D
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1A16:  MOVLW  4A
1A18:  MOVLB  6
1A1A:  ADDWF  xD1,W
1A1C:  MOVWF  FE9
1A1E:  MOVLW  02
1A20:  ADDWFC xD2,W
1A22:  MOVWF  FEA
1A24:  BSF    F93.1
1A26:  MOVLW  00
1A28:  BTFSS  F81.1
1A2A:  MOVLW  01
1A2C:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1A2E:  MOVLW  9C
1A30:  ADDWF  xD3,W
1A32:  MOVWF  FE9
1A34:  MOVLW  05
1A36:  ADDWFC xD4,W
1A38:  MOVWF  FEA
1A3A:  MOVFF  830,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1A3E:  INCF   xD1,F
1A40:  BTFSC  FD8.2
1A42:  INCF   xD2,F
....................             card_timeout=0; 
1A44:  CLRF   xD6
1A46:  CLRF   xD5
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A48:  BRA    1A56
1A4A:  MOVLB  8
1A4C:  DECFSZ x2C,W
1A4E:  BRA    1A54
1A50:  MOVLW  01
1A52:  MOVWF  x2D
1A54:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A56:  BSF    F93.3
1A58:  MOVLB  8
1A5A:  CLRF   x2E
1A5C:  BTFSC  F81.3
1A5E:  INCF   x2E,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A60:  MOVF   x2E,F
1A62:  BNZ   1A82
1A64:  DECFSZ x2F,W
1A66:  BRA    1A82
....................          { 
....................             ST2_old = 0; 
1A68:  CLRF   x2F
....................             Bit_t2 = !input(MCR_DATA2); 
1A6A:  BSF    F94.5
1A6C:  CLRF   x30
1A6E:  BTFSS  F82.5
1A70:  INCF   x30,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A72:  MOVLB  6
1A74:  INCF   xD3,F
1A76:  BTFSC  FD8.2
1A78:  INCF   xD4,F
....................             card_timeout=0; 
1A7A:  CLRF   xD6
1A7C:  CLRF   xD5
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A7E:  BRA    1A8C
1A80:  MOVLB  8
1A82:  DECFSZ x2E,W
1A84:  BRA    1A8A
1A86:  MOVLW  01
1A88:  MOVWF  x2F
1A8A:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1A8C:  BSF    F93.0
1A8E:  BTFSS  F81.0
1A90:  BRA    1A9C
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1A92:  CLRF   xDF
....................             card_timeout=65500; 
1A94:  SETF   xD6
1A96:  MOVLW  DC
1A98:  MOVWF  xD5
....................             break;            
1A9A:  BRA    1A9E
....................          } 
....................       } 
1A9C:  BRA    19B8
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1A9E:  CLRF   xD6
1AA0:  CLRF   xD5
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1AA2:  MOVLB  8
1AA4:  CLRF   x3E
1AA6:  MOVFF  6D2,840
1AAA:  MOVFF  6D1,83F
1AAE:  MOVLW  02
1AB0:  MOVWF  x42
1AB2:  MOVLW  4A
1AB4:  MOVWF  x41
1AB6:  MOVLB  0
1AB8:  CALL   0A58
1ABC:  MOVFF  01,831
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1AC0:  MOVLW  01
1AC2:  MOVLB  8
1AC4:  MOVWF  x3E
1AC6:  MOVFF  6D4,840
1ACA:  MOVFF  6D3,83F
1ACE:  MOVLW  05
1AD0:  MOVWF  x42
1AD2:  MOVLW  9C
1AD4:  MOVWF  x41
1AD6:  MOVLB  0
1AD8:  CALL   0A58
1ADC:  MOVFF  01,832
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1AE0:  MOVLB  6
1AE2:  DECFSZ xDA,W
1AE4:  BRA    1B86
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1AE6:  MOVLW  22
1AE8:  MOVWF  FF6
1AEA:  MOVLW  06
1AEC:  MOVWF  FF7
1AEE:  MOVLW  0E
1AF0:  MOVLB  8
1AF2:  MOVWF  x4C
1AF4:  MOVLB  0
1AF6:  RCALL  165A
1AF8:  MOVLW  10
1AFA:  MOVWF  FE9
1AFC:  MOVFF  6D2,836
1B00:  MOVFF  6D1,835
1B04:  RCALL  1684
1B06:  MOVLW  0D
1B08:  MOVLB  8
1B0A:  MOVWF  x58
1B0C:  MOVLB  0
1B0E:  CALL   069C
1B12:  MOVLW  0A
1B14:  MOVLB  8
1B16:  MOVWF  x58
1B18:  MOVLB  0
1B1A:  CALL   069C
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1B1E:  MOVLW  36
1B20:  MOVWF  FF6
1B22:  MOVLW  06
1B24:  MOVWF  FF7
1B26:  MOVLW  0E
1B28:  MOVLB  8
1B2A:  MOVWF  x4C
1B2C:  MOVLB  0
1B2E:  RCALL  165A
1B30:  MOVLW  10
1B32:  MOVWF  FE9
1B34:  MOVFF  6D4,836
1B38:  MOVFF  6D3,835
1B3C:  RCALL  1684
1B3E:  MOVLW  0D
1B40:  MOVLB  8
1B42:  MOVWF  x58
1B44:  MOVLB  0
1B46:  CALL   069C
1B4A:  MOVLW  0A
1B4C:  MOVLB  8
1B4E:  MOVWF  x58
1B50:  MOVLB  0
1B52:  CALL   069C
....................          debug_reader();       
1B56:  BRA    1832
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B58:  MOVLB  8
1B5A:  MOVF   x31,F
1B5C:  BNZ   1B6E
1B5E:  MOVLW  4A
1B60:  MOVWF  FF6
1B62:  MOVLW  06
1B64:  MOVWF  FF7
1B66:  MOVLB  0
1B68:  CALL   06E2
1B6C:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B6E:  MOVF   x32,F
1B70:  BNZ   1B82
1B72:  MOVLW  60
1B74:  MOVWF  FF6
1B76:  MOVLW  06
1B78:  MOVWF  FF7
1B7A:  MOVLB  0
1B7C:  CALL   06E2
1B80:  MOVLB  8
....................       } 
....................          else 
1B82:  BRA    1B92
1B84:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B86:  MOVLW  0F
1B88:  MOVLB  8
1B8A:  MOVWF  x35
1B8C:  MOVLB  0
1B8E:  RCALL  18C6
1B90:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1B92:  MOVF   x31,F
1B94:  BZ    1B9A
1B96:  MOVF   x32,F
1B98:  BNZ   1BBA
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1B9A:  MOVLB  6
1B9C:  CLRF   xD4
1B9E:  CLRF   xD3
....................          bug_countbit_T1=0; 
1BA0:  CLRF   xD2
1BA2:  CLRF   xD1
....................          reading_fg=0; 
1BA4:  CLRF   xDE
....................          count_reading_error++; 
1BA6:  INCF   xDF,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1BA8:  CLRF   xCB
1BAA:  CLRF   xCA
1BAC:  CLRF   xC9
1BAE:  CLRF   xC8
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1BB0:  MOVLW  00
1BB2:  MOVWF  01
1BB4:  BRA    1BF2
....................       } 
....................          else  
1BB6:  BRA    1BEE
1BB8:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1BBA:  MOVLW  01
1BBC:  MOVLB  6
1BBE:  MOVWF  xD9
....................             reading_fg=1; 
1BC0:  MOVWF  xDE
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1BC2:  MOVFF  6D4,6D0
1BC6:  MOVFF  6D3,6CF
....................             countbit_T1=bug_countbit_T1; 
1BCA:  MOVFF  6D2,6CE
1BCE:  MOVFF  6D1,6CD
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1BD2:  CLRF   xD2
1BD4:  CLRF   xD1
....................             bug_countbit_T2=0;  
1BD6:  CLRF   xD4
1BD8:  CLRF   xD3
....................             mcr_timeout=0; 
1BDA:  CLRF   xCB
1BDC:  CLRF   xCA
1BDE:  CLRF   xC9
1BE0:  CLRF   xC8
....................             charac_timeout=0; 
1BE2:  MOVLB  0
1BE4:  CLRF   xFC
1BE6:  CLRF   xFB
....................             return 1; 
1BE8:  MOVWF  01
1BEA:  MOVLB  6
1BEC:  BRA    1BF2
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1BEE:  MOVLW  00
1BF0:  MOVWF  01
.................... } 
1BF2:  MOVLB  0
1BF4:  GOTO   1C60 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
1BF8:  MOVLW  02
1BFA:  MOVLB  8
1BFC:  MOVWF  x2C
1BFE:  MOVLW  FA
1C00:  MOVWF  x2D
1C02:  MOVLB  0
1C04:  GOTO   0676
1C08:  MOVLB  8
1C0A:  DECFSZ x2C,F
1C0C:  BRA    1BFE
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
1C0E:  MOVLB  6
1C10:  DECFSZ xDC,W
1C12:  BRA    1C16
1C14:  BRA    1C72
....................       if((KP_mode)&&(enable_getpin==0)&&(booting==1)) 
1C16:  MOVLB  1
1C18:  MOVF   x50,F
1C1A:  BZ    1C5C
1C1C:  MOVF   x4D,F
1C1E:  BNZ   1C5C
1C20:  DECFSZ x05,W
1C22:  BRA    1C5C
....................       { 
....................          if(kp_st==1) 
1C24:  DECFSZ x51,W
1C26:  BRA    1C40
....................          { 
....................             printf("\n\rKey release.\n\r"); 
1C28:  MOVLW  7A
1C2A:  MOVWF  FF6
1C2C:  MOVLW  1C
1C2E:  MOVWF  FF7
1C30:  MOVLB  0
1C32:  CALL   06E2
....................             keyprss_off; 
1C36:  BCF    F92.7
1C38:  BCF    F89.7
....................             kp_st=0; 
1C3A:  MOVLB  1
1C3C:  CLRF   x51
....................          } 
....................          else 
1C3E:  BRA    1C5C
....................          { 
....................             printf("\n\rKey press.\n\r"); 
1C40:  MOVLW  8C
1C42:  MOVWF  FF6
1C44:  MOVLW  1C
1C46:  MOVWF  FF7
1C48:  MOVLB  0
1C4A:  CALL   06E2
....................             keyprss_on; 
1C4E:  BCF    F92.7
1C50:  BSF    F89.7
....................             kp_st=1;  
1C52:  MOVLW  01
1C54:  MOVLB  1
1C56:  MOVWF  x51
....................             count_kp=0; 
1C58:  CLRF   x53
1C5A:  CLRF   x52
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1C5C:  MOVLB  0
1C5E:  BRA    18EE
1C60:  MOVFF  01,6DB
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1C64:  MOVLB  6
1C66:  CLRF   xCB
1C68:  CLRF   xCA
1C6A:  CLRF   xC9
1C6C:  CLRF   xC8
....................       card_timeout=0; 
1C6E:  CLRF   xD6
1C70:  CLRF   xD5
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1C72:  BCF    FF0.0
1C74:  MOVLB  0
1C76:  GOTO   006C
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
60A2:  CLRF   19
60A4:  BTFSC  FF2.7
60A6:  BSF    19.7
60A8:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
60AA:  MOVLB  8
60AC:  CLRF   x43
60AE:  CLRF   x42
60B0:  CLRF   x41
60B2:  MOVLW  94
60B4:  MOVWF  x40
60B6:  MOVLW  03
60B8:  MOVWF  x44
60BA:  MOVLB  0
60BC:  CALL   3AA6
60C0:  BTFSC  19.7
60C2:  BSF    FF2.7
60C4:  CLRF   19
60C6:  BTFSC  FF2.7
60C8:  BSF    19.7
60CA:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
60CC:  MOVLB  8
60CE:  CLRF   x43
60D0:  CLRF   x42
60D2:  CLRF   x41
60D4:  MOVLW  91
60D6:  MOVWF  x40
60D8:  MOVLW  01
60DA:  MOVWF  x44
60DC:  MOVLB  0
60DE:  CALL   3AA6
60E2:  BTFSC  19.7
60E4:  BSF    FF2.7
60E6:  CLRF   19
60E8:  BTFSC  FF2.7
60EA:  BSF    19.7
60EC:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
60EE:  MOVLB  8
60F0:  CLRF   x3B
60F2:  CLRF   x3A
60F4:  CLRF   x39
60F6:  MOVLW  91
60F8:  MOVWF  x38
60FA:  MOVLB  0
60FC:  CALL   3556
6100:  BTFSC  19.7
6102:  BSF    FF2.7
6104:  MOVFF  01,6E6
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
....................    #endif 
....................     
.................... } 
6108:  GOTO   6A50 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
63E8:  MOVLW  06
63EA:  MOVWF  FEA
63EC:  MOVLW  EB
63EE:  MOVWF  FE9
63F0:  CALL   4B66
63F4:  CLRF   19
63F6:  BTFSC  FF2.7
63F8:  BSF    19.7
63FA:  BCF    FF2.7
63FC:  MOVLW  3E
63FE:  MOVLB  8
6400:  MOVWF  x58
6402:  MOVLB  0
6404:  CALL   069C
6408:  BTFSC  19.7
640A:  BSF    FF2.7
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
640C:  MOVLW  01
640E:  MOVLB  7
6410:  MOVWF  xF7
6412:  MOVLW  14
6414:  MOVWF  xF8
6416:  MOVLW  01
6418:  MOVWF  xFA
641A:  MOVLW  69
641C:  MOVWF  xF9
641E:  MOVLB  0
6420:  CALL   5AFE
6424:  CLRF   19
6426:  BTFSC  FF2.7
6428:  BSF    19.7
642A:  BCF    FF2.7
....................       printf("\n\r"); 
642C:  MOVLW  0A
642E:  MOVLB  8
6430:  MOVWF  x58
6432:  MOVLB  0
6434:  CALL   069C
6438:  BTFSC  19.7
643A:  BSF    FF2.7
643C:  CLRF   19
643E:  BTFSC  FF2.7
6440:  BSF    19.7
6442:  BCF    FF2.7
6444:  MOVLW  0D
6446:  MOVLB  8
6448:  MOVWF  x58
644A:  MOVLB  0
644C:  CALL   069C
6450:  BTFSC  19.7
6452:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
6454:  CLRF   FEA
6456:  MOVLW  41
6458:  MOVWF  FE9
645A:  MOVLW  00
645C:  CALL   0356
6460:  TBLRD*-
6462:  TBLRD*+
6464:  MOVF   FF5,W
6466:  MOVWF  FEE
6468:  IORLW  00
646A:  BNZ   6462
....................       index=0; 
646C:  MOVLB  7
646E:  CLRF   xC1
....................       ee_dat=0; 
6470:  MOVLB  6
6472:  CLRF   xE1
....................       count_card=1; 
6474:  CLRF   xE3
6476:  MOVLW  01
6478:  MOVWF  xE2
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
647A:  MOVLB  7
647C:  MOVWF  xF8
647E:  MOVLW  69
6480:  MOVWF  xF7
6482:  CLRF   xFA
6484:  MOVLW  41
6486:  MOVWF  xF9
6488:  MOVLB  0
648A:  CALL   5C36
648E:  MOVF   01,F
6490:  BTFSS  FD8.2
6492:  BRA    687A
....................       { 
....................          unsigned long adr=0; 
6494:  MOVLB  7
6496:  CLRF   xF6
6498:  CLRF   xF5
....................          //unsigned int count=0; 
....................          rec[0]=0; 
649A:  MOVLB  0
649C:  CLRF   x7D
649E:  CLRF   19
64A0:  BTFSC  FF2.7
64A2:  BSF    19.7
64A4:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
64A6:  CALL   3622
64AA:  BTFSC  19.7
64AC:  BSF    FF2.7
64AE:  MOVFF  02,6E5
64B2:  MOVFF  01,6E4
64B6:  CLRF   19
64B8:  BTFSC  FF2.7
64BA:  BSF    19.7
64BC:  BCF    FF2.7
....................          adr=count_card*numdata; 
64BE:  MOVFF  6E3,835
64C2:  MOVFF  6E2,834
64C6:  MOVLB  8
64C8:  CLRF   x37
64CA:  MOVLW  7C
64CC:  MOVWF  x36
64CE:  MOVLB  0
64D0:  CALL   367A
64D4:  BTFSC  19.7
64D6:  BSF    FF2.7
64D8:  MOVFF  02,7F6
64DC:  MOVFF  01,7F5
....................          addr_key=EEPROM_KEY_ST; 
64E0:  MOVLB  6
64E2:  CLRF   xEA
64E4:  MOVLW  01
64E6:  MOVWF  xE9
64E8:  MOVLW  C3
64EA:  MOVWF  xE8
64EC:  MOVLW  0F
64EE:  MOVWF  xE7
....................          while(count_card<=count_card_tg) 
....................          { 
64F0:  MOVF   xE3,W
64F2:  SUBWF  xE5,W
64F4:  BTFSS  FD8.0
64F6:  BRA    6878
64F8:  BNZ   6502
64FA:  MOVF   xE2,W
64FC:  SUBWF  xE4,W
64FE:  BTFSS  FD8.0
6500:  BRA    6878
6502:  CLRF   19
6504:  BTFSC  FF2.7
6506:  BSF    19.7
6508:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
650A:  MOVFF  6E3,835
650E:  MOVFF  6E2,834
6512:  MOVLB  8
6514:  CLRF   x37
6516:  MOVLW  7C
6518:  MOVWF  x36
651A:  MOVLB  0
651C:  CALL   367A
6520:  BTFSC  19.7
6522:  BSF    FF2.7
6524:  MOVLW  96
6526:  MOVLB  7
6528:  ADDWF  01,W
652A:  MOVWF  xF5
652C:  MOVLW  00
652E:  ADDWFC 02,W
6530:  MOVWF  xF6
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
6532:  MOVLW  7C
6534:  SUBWF  xF5,W
6536:  MOVWF  xF7
6538:  MOVLW  00
653A:  SUBWFB xF6,W
653C:  MOVWF  xF8
653E:  MOVWF  xFA
6540:  MOVFF  7F7,7F9
6544:  CLRF   xFC
6546:  MOVLW  7C
6548:  MOVWF  xFB
654A:  CLRF   xFE
654C:  MOVLW  7D
654E:  MOVWF  xFD
6550:  MOVLB  0
6552:  GOTO   5CCE
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
6556:  MOVLW  10
6558:  MOVWF  FE9
655A:  CLRF   19
655C:  BTFSC  FF2.7
655E:  BSF    19.7
6560:  BCF    FF2.7
6562:  MOVFF  6E3,830
6566:  MOVFF  6E2,82F
656A:  CALL   4214
656E:  BTFSC  19.7
6570:  BSF    FF2.7
6572:  CLRF   19
6574:  BTFSC  FF2.7
6576:  BSF    19.7
6578:  BCF    FF2.7
657A:  MOVLW  29
657C:  MOVLB  8
657E:  MOVWF  x58
6580:  MOVLB  0
6582:  CALL   069C
6586:  BTFSC  19.7
6588:  BSF    FF2.7
658A:  MOVFF  7D,7F7
658E:  MOVLW  01
6590:  MOVLB  7
6592:  MOVWF  xF8
6594:  MOVLB  0
6596:  CALL   5D5C
659A:  CLRF   19
659C:  BTFSC  FF2.7
659E:  BSF    19.7
65A0:  BCF    FF2.7
65A2:  MOVLW  2F
65A4:  MOVLB  8
65A6:  MOVWF  x58
65A8:  MOVLB  0
65AA:  CALL   069C
65AE:  BTFSC  19.7
65B0:  BSF    FF2.7
65B2:  MOVFF  7E,7F7
65B6:  MOVLW  01
65B8:  MOVLB  7
65BA:  MOVWF  xF8
65BC:  MOVLB  0
65BE:  CALL   5D5C
65C2:  CLRF   19
65C4:  BTFSC  FF2.7
65C6:  BSF    19.7
65C8:  BCF    FF2.7
65CA:  MOVLW  20
65CC:  MOVLB  8
65CE:  MOVWF  x58
65D0:  MOVLB  0
65D2:  CALL   069C
65D6:  BTFSC  19.7
65D8:  BSF    FF2.7
65DA:  MOVFF  7F,7F7
65DE:  MOVLW  01
65E0:  MOVLB  7
65E2:  MOVWF  xF8
65E4:  MOVLB  0
65E6:  CALL   5D5C
65EA:  CLRF   19
65EC:  BTFSC  FF2.7
65EE:  BSF    19.7
65F0:  BCF    FF2.7
65F2:  MOVLW  3A
65F4:  MOVLB  8
65F6:  MOVWF  x58
65F8:  MOVLB  0
65FA:  CALL   069C
65FE:  BTFSC  19.7
6600:  BSF    FF2.7
6602:  MOVFF  80,7F7
6606:  MOVLW  01
6608:  MOVLB  7
660A:  MOVWF  xF8
660C:  MOVLB  0
660E:  CALL   5D5C
6612:  CLRF   19
6614:  BTFSC  FF2.7
6616:  BSF    19.7
6618:  BCF    FF2.7
661A:  MOVLW  3A
661C:  MOVLB  8
661E:  MOVWF  x58
6620:  MOVLB  0
6622:  CALL   069C
6626:  BTFSC  19.7
6628:  BSF    FF2.7
662A:  MOVFF  81,7F7
662E:  MOVLW  01
6630:  MOVLB  7
6632:  MOVWF  xF8
6634:  MOVLB  0
6636:  CALL   5D5C
....................             ee_dat=0; 
663A:  MOVLB  6
663C:  CLRF   xE1
....................             index=0; 
663E:  MOVLB  7
6640:  CLRF   xC1
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
6642:  MOVLW  C0
6644:  MOVWF  FF6
6646:  MOVLW  1C
6648:  MOVWF  FF7
664A:  CLRF   19
664C:  BTFSC  FF2.7
664E:  BSF    19.7
6650:  BCF    FF2.7
6652:  MOVLB  0
6654:  CALL   06E2
6658:  BTFSC  19.7
665A:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
665C:  MOVLB  7
665E:  MOVF   xC1,W
6660:  SUBLW  4E
6662:  BNC   66C0
6664:  MOVLB  6
6666:  MOVF   xE1,W
6668:  SUBLW  3F
666A:  BTFSS  FD8.2
666C:  BRA    6672
666E:  MOVLB  7
6670:  BRA    66C0
....................                ee_dat = rec[index+5]; 
6672:  MOVLW  05
6674:  MOVLB  7
6676:  ADDWF  xC1,W
6678:  CLRF   03
667A:  ADDLW  7D
667C:  MOVWF  FE9
667E:  MOVLW  00
6680:  ADDWFC 03,W
6682:  MOVWF  FEA
6684:  MOVFF  FEF,6E1
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
6688:  MOVLB  6
668A:  MOVF   xE1,W
668C:  SUBLW  1F
668E:  BC    66AC
6690:  MOVF   xE1,W
6692:  SUBLW  7E
6694:  BNC   66AC
6696:  CLRF   19
6698:  BTFSC  FF2.7
669A:  BSF    19.7
669C:  BCF    FF2.7
669E:  MOVFF  6E1,858
66A2:  MOVLB  0
66A4:  CALL   069C
66A8:  BTFSC  19.7
66AA:  BSF    FF2.7
....................                index++; 
66AC:  MOVLB  7
66AE:  INCF   xC1,F
....................                if(ee_dat==0)break; 
66B0:  MOVLB  6
66B2:  MOVF   xE1,F
66B4:  BNZ   66BA
66B6:  MOVLB  7
66B8:  BRA    66C0
....................             } 
66BA:  MOVLB  0
66BC:  BRA    665C
66BE:  MOVLB  7
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
66C0:  MOVLW  D2
66C2:  MOVWF  FF6
66C4:  MOVLW  1C
66C6:  MOVWF  FF7
66C8:  CLRF   19
66CA:  BTFSC  FF2.7
66CC:  BSF    19.7
66CE:  BCF    FF2.7
66D0:  MOVLB  0
66D2:  CALL   06E2
66D6:  BTFSC  19.7
66D8:  BSF    FF2.7
....................             index=0; 
66DA:  MOVLB  7
66DC:  CLRF   xC1
....................             ee_dat=0; 
66DE:  MOVLB  6
66E0:  CLRF   xE1
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
66E2:  MOVLB  7
66E4:  MOVF   xC1,W
66E6:  SUBLW  27
66E8:  BNC   6748
66EA:  MOVLB  6
66EC:  MOVF   xE1,W
66EE:  SUBLW  3F
66F0:  BTFSS  FD8.2
66F2:  BRA    66F8
66F4:  MOVLB  7
66F6:  BRA    6748
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
66F8:  MOVLW  05
66FA:  MOVLB  7
66FC:  ADDWF  xC1,W
66FE:  ADDLW  4F
6700:  CLRF   03
6702:  ADDLW  7D
6704:  MOVWF  FE9
6706:  MOVLW  00
6708:  ADDWFC 03,W
670A:  MOVWF  FEA
670C:  MOVFF  FEF,6E1
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
6710:  MOVLB  6
6712:  MOVF   xE1,W
6714:  SUBLW  1F
6716:  BC    6734
6718:  MOVF   xE1,W
671A:  SUBLW  7E
671C:  BNC   6734
671E:  CLRF   19
6720:  BTFSC  FF2.7
6722:  BSF    19.7
6724:  BCF    FF2.7
6726:  MOVFF  6E1,858
672A:  MOVLB  0
672C:  CALL   069C
6730:  BTFSC  19.7
6732:  BSF    FF2.7
....................                index++; 
6734:  MOVLB  7
6736:  INCF   xC1,F
....................                if(ee_dat==0)break; 
6738:  MOVLB  6
673A:  MOVF   xE1,F
673C:  BNZ   6744
673E:  MOVLB  7
6740:  BRA    6748
6742:  MOVLB  6
....................             } 
6744:  BRA    66E2
6746:  MOVLB  7
....................             index=0; 
6748:  CLRF   xC1
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
674A:  MOVLW  E4
674C:  MOVWF  FF6
674E:  MOVLW  1C
6750:  MOVWF  FF7
6752:  CLRF   19
6754:  BTFSC  FF2.7
6756:  BSF    19.7
6758:  BCF    FF2.7
675A:  MOVLB  0
675C:  CALL   06E2
6760:  BTFSC  19.7
6762:  BSF    FF2.7
....................             //fprintf(COM2,"addr_key =%lu \n\r",addr_key);  
....................             //fprintf(COM2," ptr_card_key=%lu \n\r",ptr_card_key);  
....................             if(ptr_card_key>addr_key) 
6764:  MOVLB  6
6766:  MOVF   xEA,W
6768:  SUBWF  27,W
676A:  BTFSS  FD8.0
676C:  BRA    6870
676E:  BNZ   678C
6770:  MOVF   xE9,W
6772:  SUBWF  26,W
6774:  BTFSS  FD8.0
6776:  BRA    6870
6778:  BNZ   678C
677A:  MOVF   xE8,W
677C:  SUBWF  25,W
677E:  BTFSS  FD8.0
6780:  BRA    6870
6782:  BNZ   678C
6784:  MOVF   24,W
6786:  SUBWF  xE7,W
6788:  BTFSC  FD8.0
678A:  BRA    6870
....................             { 
....................                i=0; 
678C:  MOVLB  7
678E:  CLRF   xC2
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
6790:  MOVF   xC2,W
6792:  MOVLB  6
6794:  ADDWF  xE7,W
6796:  MOVLB  7
6798:  MOVWF  xF7
679A:  MOVLW  00
679C:  MOVLB  6
679E:  ADDWFC xE8,W
67A0:  MOVLB  7
67A2:  MOVWF  xF8
67A4:  MOVLW  00
67A6:  MOVLB  6
67A8:  ADDWFC xE9,W
67AA:  MOVLB  7
67AC:  MOVWF  xF9
67AE:  MOVLW  00
67B0:  MOVLB  6
67B2:  ADDWFC xEA,W
67B4:  MOVLB  7
67B6:  MOVWF  xFA
67B8:  CLRF   19
67BA:  BTFSC  FF2.7
67BC:  BSF    19.7
67BE:  BCF    FF2.7
67C0:  MOVFF  FE8,83B
67C4:  MOVFF  7F9,83A
67C8:  MOVFF  7F8,839
67CC:  MOVFF  7F7,838
67D0:  MOVLB  0
67D2:  CALL   3556
67D6:  BTFSC  19.7
67D8:  BSF    FF2.7
67DA:  MOVFF  01,6E1
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
67DE:  MOVLB  6
67E0:  MOVF   xE1,W
67E2:  SUBLW  2F
67E4:  BC    67EC
67E6:  MOVF   xE1,W
67E8:  SUBLW  39
67EA:  BC    6804
67EC:  MOVF   xE1,W
67EE:  SUBLW  23
67F0:  BZ    6804
67F2:  MOVF   xE1,W
67F4:  SUBLW  2A
67F6:  BZ    6804
67F8:  MOVF   xE1,W
67FA:  SUBLW  40
67FC:  BC    681A
67FE:  MOVF   xE1,W
6800:  SUBLW  5A
6802:  BNC   681A
6804:  CLRF   19
6806:  BTFSC  FF2.7
6808:  BSF    19.7
680A:  BCF    FF2.7
....................                      fputc(ee_dat,COM2); 
680C:  MOVFF  6E1,858
6810:  MOVLB  0
6812:  CALL   069C
6816:  BTFSC  19.7
6818:  BSF    FF2.7
....................                   i++; 
681A:  MOVLB  7
681C:  INCF   xC2,F
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
681E:  MOVF   xC2,W
6820:  SUBLW  0B
6822:  BNC   6830
6824:  MOVLB  6
6826:  MOVF   xE1,F
6828:  BTFSC  FD8.2
682A:  BRA    6830
682C:  MOVLB  7
682E:  BRA    6790
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+key_numbyte; 
6830:  MOVLW  0C
6832:  MOVLB  6
6834:  ADDWF  xE7,F
6836:  MOVLW  00
6838:  ADDWFC xE8,F
683A:  ADDWFC xE9,F
683C:  ADDWFC xEA,F
683E:  CLRF   19
6840:  BTFSC  FF2.7
6842:  BSF    19.7
6844:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
6846:  MOVLW  0A
6848:  MOVLB  8
684A:  MOVWF  x58
684C:  MOVLB  0
684E:  CALL   069C
6852:  BTFSC  19.7
6854:  BSF    FF2.7
6856:  CLRF   19
6858:  BTFSC  FF2.7
685A:  BSF    19.7
685C:  BCF    FF2.7
685E:  MOVLW  0D
6860:  MOVLB  8
6862:  MOVWF  x58
6864:  MOVLB  0
6866:  CALL   069C
686A:  BTFSC  19.7
686C:  BSF    FF2.7
686E:  MOVLB  6
....................             } 
....................             count_card++; 
6870:  INCF   xE2,F
6872:  BTFSC  FD8.2
6874:  INCF   xE3,F
....................          } 
6876:  BRA    64F0
6878:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
687A:  CLRF   FEA
687C:  MOVLW  41
687E:  MOVWF  FE9
6880:  MOVLW  00
6882:  CALL   0368
6886:  TBLRD*-
6888:  TBLRD*+
688A:  MOVF   FF5,W
688C:  MOVWF  FEE
688E:  IORLW  00
6890:  BNZ   6888
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6892:  MOVLW  01
6894:  MOVLB  7
6896:  MOVWF  xF8
6898:  MOVLW  69
689A:  MOVWF  xF7
689C:  CLRF   xFA
689E:  MOVLW  41
68A0:  MOVWF  xF9
68A2:  MOVLB  0
68A4:  CALL   5C36
68A8:  MOVF   01,F
68AA:  BNZ   68E0
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
68AC:  MOVLW  F4
68AE:  MOVWF  FF6
68B0:  MOVLW  1C
68B2:  MOVWF  FF7
68B4:  CLRF   19
68B6:  BTFSC  FF2.7
68B8:  BSF    19.7
68BA:  BCF    FF2.7
68BC:  CALL   06E2
68C0:  BTFSC  19.7
68C2:  BSF    FF2.7
....................          format_eepromext(); 
68C4:  GOTO   5E76
....................          fprintf(COM2," exit\n\r");  
68C8:  MOVLW  02
68CA:  MOVWF  FF6
68CC:  MOVLW  1D
68CE:  MOVWF  FF7
68D0:  CLRF   19
68D2:  BTFSC  FF2.7
68D4:  BSF    19.7
68D6:  BCF    FF2.7
68D8:  CALL   06E2
68DC:  BTFSC  19.7
68DE:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
68E0:  CLRF   FEA
68E2:  MOVLW  41
68E4:  MOVWF  FE9
68E6:  MOVLW  00
68E8:  CALL   037A
68EC:  TBLRD*-
68EE:  TBLRD*+
68F0:  MOVF   FF5,W
68F2:  MOVWF  FEE
68F4:  IORLW  00
68F6:  BNZ   68EE
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
68F8:  MOVLW  01
68FA:  MOVLB  7
68FC:  MOVWF  xF8
68FE:  MOVLW  69
6900:  MOVWF  xF7
6902:  CLRF   xFA
6904:  MOVLW  41
6906:  MOVWF  xF9
6908:  MOVLB  0
690A:  CALL   5C36
690E:  MOVF   01,F
6910:  BNZ   6946
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6912:  MOVLW  0A
6914:  MOVWF  FF6
6916:  MOVLW  1D
6918:  MOVWF  FF7
691A:  CLRF   19
691C:  BTFSC  FF2.7
691E:  BSF    19.7
6920:  BCF    FF2.7
6922:  CALL   06E2
6926:  BTFSC  19.7
6928:  BSF    FF2.7
....................          ease_eeprom(); 
692A:  GOTO   5FDC
....................          fprintf(COM2," exit\n\r");  
692E:  MOVLW  18
6930:  MOVWF  FF6
6932:  MOVLW  1D
6934:  MOVWF  FF7
6936:  CLRF   19
6938:  BTFSC  FF2.7
693A:  BSF    19.7
693C:  BCF    FF2.7
693E:  CALL   06E2
6942:  BTFSC  19.7
6944:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6946:  CLRF   FEA
6948:  MOVLW  41
694A:  MOVWF  FE9
694C:  MOVLW  00
694E:  CALL   0390
6952:  TBLRD*-
6954:  TBLRD*+
6956:  MOVF   FF5,W
6958:  MOVWF  FEE
695A:  IORLW  00
695C:  BNZ   6954
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
695E:  MOVLW  01
6960:  MOVLB  7
6962:  MOVWF  xF8
6964:  MOVLW  69
6966:  MOVWF  xF7
6968:  CLRF   xFA
696A:  MOVLW  41
696C:  MOVWF  xF9
696E:  MOVLB  0
6970:  CALL   5C36
6974:  MOVF   01,F
6976:  BNZ   69B0
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
6978:  MOVLW  20
697A:  MOVWF  FF6
697C:  MOVLW  1D
697E:  MOVWF  FF7
6980:  CLRF   19
6982:  BTFSC  FF2.7
6984:  BSF    19.7
6986:  BCF    FF2.7
6988:  CALL   06E2
698C:  BTFSC  19.7
698E:  BSF    FF2.7
....................          reset_password(); 
6990:  GOTO   6060
....................          init_password(); 
6994:  CALL   479E
....................          fprintf(COM2," exit\n\r");  
6998:  MOVLW  36
699A:  MOVWF  FF6
699C:  MOVLW  1D
699E:  MOVWF  FF7
69A0:  CLRF   19
69A2:  BTFSC  FF2.7
69A4:  BSF    19.7
69A6:  BCF    FF2.7
69A8:  CALL   06E2
69AC:  BTFSC  19.7
69AE:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
69B0:  CLRF   FEA
69B2:  MOVLW  41
69B4:  MOVWF  FE9
69B6:  MOVLW  00
69B8:  CALL   03A6
69BC:  TBLRD*-
69BE:  TBLRD*+
69C0:  MOVF   FF5,W
69C2:  MOVWF  FEE
69C4:  IORLW  00
69C6:  BNZ   69BE
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
69C8:  MOVLW  01
69CA:  MOVLB  7
69CC:  MOVWF  xF8
69CE:  MOVLW  69
69D0:  MOVWF  xF7
69D2:  CLRF   xFA
69D4:  MOVLW  41
69D6:  MOVWF  xF9
69D8:  MOVLB  0
69DA:  CALL   5C36
69DE:  MOVF   01,F
69E0:  BNZ   6A02
....................       { 
....................          keydebug_en=1; 
69E2:  MOVLW  01
69E4:  MOVLB  1
69E6:  MOVWF  x4C
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
69E8:  MOVLW  3E
69EA:  MOVWF  FF6
69EC:  MOVLW  1D
69EE:  MOVWF  FF7
69F0:  CLRF   19
69F2:  BTFSC  FF2.7
69F4:  BSF    19.7
69F6:  BCF    FF2.7
69F8:  MOVLB  0
69FA:  CALL   06E2
69FE:  BTFSC  19.7
6A00:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
6A02:  CLRF   FEA
6A04:  MOVLW  41
6A06:  MOVWF  FE9
6A08:  MOVLW  00
6A0A:  CALL   03BC
6A0E:  TBLRD*-
6A10:  TBLRD*+
6A12:  MOVF   FF5,W
6A14:  MOVWF  FEE
6A16:  IORLW  00
6A18:  BNZ   6A10
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6A1A:  MOVLW  01
6A1C:  MOVLB  7
6A1E:  MOVWF  xF8
6A20:  MOVLW  69
6A22:  MOVWF  xF7
6A24:  CLRF   xFA
6A26:  MOVLW  41
6A28:  MOVWF  xF9
6A2A:  MOVLB  0
6A2C:  CALL   5C36
6A30:  MOVF   01,F
6A32:  BNZ   6A50
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6A34:  MOVLW  52
6A36:  MOVWF  FF6
6A38:  MOVLW  1D
6A3A:  MOVWF  FF7
6A3C:  CLRF   19
6A3E:  BTFSC  FF2.7
6A40:  BSF    19.7
6A42:  BCF    FF2.7
6A44:  CALL   06E2
6A48:  BTFSC  19.7
6A4A:  BSF    FF2.7
....................          rstfact(); 
6A4C:  GOTO   60A2
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
6A50:  CLRF   FEA
6A52:  MOVLW  41
6A54:  MOVWF  FE9
6A56:  MOVLW  00
6A58:  CALL   03D4
6A5C:  TBLRD*-
6A5E:  TBLRD*+
6A60:  MOVF   FF5,W
6A62:  MOVWF  FEE
6A64:  IORLW  00
6A66:  BNZ   6A5E
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6A68:  MOVLW  01
6A6A:  MOVLB  7
6A6C:  MOVWF  xF8
6A6E:  MOVLW  69
6A70:  MOVWF  xF7
6A72:  CLRF   xFA
6A74:  MOVLW  41
6A76:  MOVWF  xF9
6A78:  MOVLB  0
6A7A:  CALL   5C36
6A7E:  MOVF   01,F
6A80:  BNZ   6AA8
....................       { 
....................          mode=LOGOFF; 
6A82:  MOVLB  6
6A84:  CLRF   xE0
....................          keydebug_en=0; 
6A86:  MOVLB  1
6A88:  CLRF   x4C
....................          set_tris_a(0xff); 
6A8A:  MOVLW  FF
6A8C:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
6A8E:  MOVLW  62
6A90:  MOVWF  FF6
6A92:  MOVLW  1D
6A94:  MOVWF  FF7
6A96:  CLRF   19
6A98:  BTFSC  FF2.7
6A9A:  BSF    19.7
6A9C:  BCF    FF2.7
6A9E:  MOVLB  0
6AA0:  CALL   06E2
6AA4:  BTFSC  19.7
6AA6:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
6AA8:  CLRF   FEA
6AAA:  MOVLW  41
6AAC:  MOVWF  FE9
6AAE:  MOVLW  00
6AB0:  CALL   03E6
6AB4:  TBLRD*-
6AB6:  TBLRD*+
6AB8:  MOVF   FF5,W
6ABA:  MOVWF  FEE
6ABC:  IORLW  00
6ABE:  BNZ   6AB6
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6AC0:  MOVLW  01
6AC2:  MOVLB  7
6AC4:  MOVWF  xF8
6AC6:  MOVLW  69
6AC8:  MOVWF  xF7
6ACA:  CLRF   xFA
6ACC:  MOVLW  41
6ACE:  MOVWF  xF9
6AD0:  MOVLB  0
6AD2:  CALL   5C36
6AD6:  MOVF   01,F
6AD8:  BNZ   6B46
....................       { 
....................          fprintf(COM2,"New console name>"); 
6ADA:  MOVLW  6A
6ADC:  MOVWF  FF6
6ADE:  MOVLW  1D
6AE0:  MOVWF  FF7
6AE2:  CLRF   19
6AE4:  BTFSC  FF2.7
6AE6:  BSF    19.7
6AE8:  BCF    FF2.7
6AEA:  CALL   06E2
6AEE:  BTFSC  19.7
6AF0:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,16, console); 
6AF2:  MOVLW  01
6AF4:  MOVLB  7
6AF6:  MOVWF  xF7
6AF8:  MOVLW  10
6AFA:  MOVWF  xF8
6AFC:  MOVLW  06
6AFE:  MOVWF  xFA
6B00:  MOVLW  EB
6B02:  MOVWF  xF9
6B04:  MOVLB  0
6B06:  CALL   5AFE
....................          EEPROM_write(strobe_nameconsole,16,console); 
6B0A:  MOVLB  8
6B0C:  CLRF   x0F
6B0E:  CLRF   x0E
6B10:  CLRF   x0D
6B12:  MOVLW  66
6B14:  MOVWF  x0C
6B16:  CLRF   x13
6B18:  CLRF   x12
6B1A:  CLRF   x11
6B1C:  MOVLW  10
6B1E:  MOVWF  x10
6B20:  MOVLW  06
6B22:  MOVWF  x15
6B24:  MOVLW  EB
6B26:  MOVWF  x14
6B28:  MOVLB  0
6B2A:  CALL   4702
....................          fprintf(COM2," OK\n\r"); 
6B2E:  MOVLW  7C
6B30:  MOVWF  FF6
6B32:  MOVLW  1D
6B34:  MOVWF  FF7
6B36:  CLRF   19
6B38:  BTFSC  FF2.7
6B3A:  BSF    19.7
6B3C:  BCF    FF2.7
6B3E:  CALL   06E2
6B42:  BTFSC  19.7
6B44:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
6B46:  CLRF   FEA
6B48:  MOVLW  41
6B4A:  MOVWF  FE9
6B4C:  MOVLW  00
6B4E:  CALL   03F8
6B52:  TBLRD*-
6B54:  TBLRD*+
6B56:  MOVF   FF5,W
6B58:  MOVWF  FEE
6B5A:  IORLW  00
6B5C:  BNZ   6B54
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6B5E:  MOVLW  01
6B60:  MOVLB  7
6B62:  MOVWF  xF8
6B64:  MOVLW  69
6B66:  MOVWF  xF7
6B68:  CLRF   xFA
6B6A:  MOVLW  41
6B6C:  MOVWF  xF9
6B6E:  MOVLB  0
6B70:  CALL   5C36
6B74:  MOVF   01,F
6B76:  BTFSS  FD8.2
6B78:  BRA    6DDE
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
*
6C44:  MOVLB  8
6C46:  CLRF   x3B
6C48:  CLRF   x3A
6C4A:  CLRF   x39
6C4C:  MOVLW  91
6C4E:  MOVWF  x38
6C50:  MOVLB  0
6C52:  CALL   3556
6C56:  BTFSC  19.7
6C58:  BSF    FF2.7
6C5A:  MOVFF  01,6E6
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6C5E:  MOVLB  6
6C60:  MOVF   xE6,F
6C62:  BNZ   6C82
6C64:  MOVLW  82
6C66:  MOVWF  FF6
6C68:  MOVLW  1D
6C6A:  MOVWF  FF7
6C6C:  CLRF   19
6C6E:  BTFSC  FF2.7
6C70:  BSF    19.7
6C72:  BCF    FF2.7
6C74:  MOVLB  0
6C76:  CALL   06E2
6C7A:  BTFSC  19.7
6C7C:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6C7E:  BRA    6C9C
6C80:  MOVLB  6
6C82:  MOVLW  86
6C84:  MOVWF  FF6
6C86:  MOVLW  1D
6C88:  MOVWF  FF7
6C8A:  CLRF   19
6C8C:  BTFSC  FF2.7
6C8E:  BSF    19.7
6C90:  BCF    FF2.7
6C92:  MOVLB  0
6C94:  CALL   06E2
6C98:  BTFSC  19.7
6C9A:  BSF    FF2.7
6C9C:  CLRF   19
6C9E:  BTFSC  FF2.7
6CA0:  BSF    19.7
6CA2:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
6CA4:  MOVLB  8
6CA6:  CLRF   x3B
6CA8:  CLRF   x3A
6CAA:  CLRF   x39
6CAC:  MOVLW  94
6CAE:  MOVWF  x38
6CB0:  MOVLB  0
6CB2:  CALL   3556
6CB6:  BTFSC  19.7
6CB8:  BSF    FF2.7
6CBA:  MOVFF  01,161
6CBE:  CLRF   19
6CC0:  BTFSC  FF2.7
6CC2:  BSF    19.7
6CC4:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
6CC6:  MOVLW  5B
6CC8:  MOVLB  8
6CCA:  MOVWF  x58
6CCC:  MOVLB  0
6CCE:  CALL   069C
6CD2:  BTFSC  19.7
6CD4:  BSF    FF2.7
6CD6:  MOVFF  161,7F7
6CDA:  MOVLW  1B
6CDC:  MOVLB  7
6CDE:  MOVWF  xF8
6CE0:  MOVLB  0
6CE2:  GOTO   613E
6CE6:  CLRF   19
6CE8:  BTFSC  FF2.7
6CEA:  BSF    19.7
6CEC:  BCF    FF2.7
6CEE:  MOVLW  5D
6CF0:  MOVLB  8
6CF2:  MOVWF  x58
6CF4:  MOVLB  0
6CF6:  CALL   069C
6CFA:  BTFSC  19.7
6CFC:  BSF    FF2.7
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
6CFE:  MOVFF  100,7F7
6D02:  MOVLW  01
6D04:  MOVLB  7
6D06:  MOVWF  xF8
6D08:  MOVLB  0
6D0A:  CALL   5D5C
6D0E:  CLRF   19
6D10:  BTFSC  FF2.7
6D12:  BSF    19.7
6D14:  BCF    FF2.7
6D16:  MOVLW  2F
6D18:  MOVLB  8
6D1A:  MOVWF  x58
6D1C:  MOVLB  0
6D1E:  CALL   069C
6D22:  BTFSC  19.7
6D24:  BSF    FF2.7
6D26:  MOVFF  FF,7F7
6D2A:  MOVLW  01
6D2C:  MOVLB  7
6D2E:  MOVWF  xF8
6D30:  MOVLB  0
6D32:  CALL   5D5C
6D36:  CLRF   19
6D38:  BTFSC  FF2.7
6D3A:  BSF    19.7
6D3C:  BCF    FF2.7
6D3E:  MOVLW  20
6D40:  MOVLB  8
6D42:  MOVWF  x58
6D44:  MOVLB  0
6D46:  CALL   069C
6D4A:  BTFSC  19.7
6D4C:  BSF    FF2.7
6D4E:  MOVFF  101,7F7
6D52:  MOVLW  01
6D54:  MOVLB  7
6D56:  MOVWF  xF8
6D58:  MOVLB  0
6D5A:  CALL   5D5C
6D5E:  CLRF   19
6D60:  BTFSC  FF2.7
6D62:  BSF    19.7
6D64:  BCF    FF2.7
6D66:  MOVLW  3A
6D68:  MOVLB  8
6D6A:  MOVWF  x58
6D6C:  MOVLB  0
6D6E:  CALL   069C
6D72:  BTFSC  19.7
6D74:  BSF    FF2.7
6D76:  MOVFF  102,7F7
6D7A:  MOVLW  01
6D7C:  MOVLB  7
6D7E:  MOVWF  xF8
6D80:  MOVLB  0
6D82:  CALL   5D5C
6D86:  CLRF   19
6D88:  BTFSC  FF2.7
6D8A:  BSF    19.7
6D8C:  BCF    FF2.7
6D8E:  MOVLW  3A
6D90:  MOVLB  8
6D92:  MOVWF  x58
6D94:  MOVLB  0
6D96:  CALL   069C
6D9A:  BTFSC  19.7
6D9C:  BSF    FF2.7
6D9E:  MOVFF  103,7F7
6DA2:  MOVLW  01
6DA4:  MOVLB  7
6DA6:  MOVWF  xF8
6DA8:  MOVLB  0
6DAA:  CALL   5D5C
6DAE:  CLRF   19
6DB0:  BTFSC  FF2.7
6DB2:  BSF    19.7
6DB4:  BCF    FF2.7
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
6DB6:  MOVLW  0A
6DB8:  MOVLB  8
6DBA:  MOVWF  x58
6DBC:  MOVLB  0
6DBE:  CALL   069C
6DC2:  BTFSC  19.7
6DC4:  BSF    FF2.7
6DC6:  CLRF   19
6DC8:  BTFSC  FF2.7
6DCA:  BSF    19.7
6DCC:  BCF    FF2.7
6DCE:  MOVLW  0D
6DD0:  MOVLB  8
6DD2:  MOVWF  x58
6DD4:  MOVLB  0
6DD6:  CALL   069C
6DDA:  BTFSC  19.7
6DDC:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
6DDE:  CLRF   FEA
6DE0:  MOVLW  41
6DE2:  MOVWF  FE9
6DE4:  MOVLW  00
6DE6:  CALL   040A
6DEA:  TBLRD*-
6DEC:  TBLRD*+
6DEE:  MOVF   FF5,W
6DF0:  MOVWF  FEE
6DF2:  IORLW  00
6DF4:  BNZ   6DEC
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
6DF6:  MOVLW  01
6DF8:  MOVLB  7
6DFA:  MOVWF  xF8
6DFC:  MOVLW  69
6DFE:  MOVWF  xF7
6E00:  CLRF   xFA
6E02:  MOVLW  41
6E04:  MOVWF  xF9
6E06:  MOVLB  0
6E08:  CALL   5C36
6E0C:  MOVF   01,F
6E0E:  BTFSS  FD8.2
6E10:  BRA    703A
....................       { 
....................          fprintf(COM2,"Year>"); 
6E12:  MOVLW  8A
6E14:  MOVWF  FF6
6E16:  MOVLW  1D
6E18:  MOVWF  FF7
6E1A:  CLRF   19
6E1C:  BTFSC  FF2.7
6E1E:  BSF    19.7
6E20:  BCF    FF2.7
6E22:  CALL   06E2
6E26:  BTFSC  19.7
6E28:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6E2A:  MOVLW  01
6E2C:  MOVLB  7
6E2E:  MOVWF  xF7
6E30:  MOVLW  03
6E32:  MOVWF  xF8
6E34:  MOVLW  07
6E36:  MOVWF  xFA
6E38:  MOVLW  C3
6E3A:  MOVWF  xF9
6E3C:  MOVLB  0
6E3E:  CALL   5AFE
....................          year=(unsigned int8)strtoi(temp); 
6E42:  MOVLW  07
6E44:  MOVLB  7
6E46:  MOVWF  xF8
6E48:  MOVLW  C3
6E4A:  MOVWF  xF7
6E4C:  MOVLB  0
6E4E:  CALL   6204
6E52:  MOVFF  01,FE
....................          fprintf(COM2,"Month>"); 
6E56:  MOVLW  90
6E58:  MOVWF  FF6
6E5A:  MOVLW  1D
6E5C:  MOVWF  FF7
6E5E:  CLRF   19
6E60:  BTFSC  FF2.7
6E62:  BSF    19.7
6E64:  BCF    FF2.7
6E66:  CALL   06E2
6E6A:  BTFSC  19.7
6E6C:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6E6E:  MOVLW  01
6E70:  MOVLB  7
6E72:  MOVWF  xF7
6E74:  MOVLW  03
6E76:  MOVWF  xF8
6E78:  MOVLW  07
6E7A:  MOVWF  xFA
6E7C:  MOVLW  C3
6E7E:  MOVWF  xF9
6E80:  MOVLB  0
6E82:  CALL   5AFE
....................          mon=(unsigned int8)strtoi(temp); 
6E86:  MOVLW  07
6E88:  MOVLB  7
6E8A:  MOVWF  xF8
6E8C:  MOVLW  C3
6E8E:  MOVWF  xF7
6E90:  MOVLB  0
6E92:  CALL   6204
6E96:  MOVFF  01,FF
....................          fprintf(COM2,"Date>"); 
6E9A:  MOVLW  98
6E9C:  MOVWF  FF6
6E9E:  MOVLW  1D
6EA0:  MOVWF  FF7
6EA2:  CLRF   19
6EA4:  BTFSC  FF2.7
6EA6:  BSF    19.7
6EA8:  BCF    FF2.7
6EAA:  CALL   06E2
6EAE:  BTFSC  19.7
6EB0:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6EB2:  MOVLW  01
6EB4:  MOVLB  7
6EB6:  MOVWF  xF7
6EB8:  MOVLW  03
6EBA:  MOVWF  xF8
6EBC:  MOVLW  07
6EBE:  MOVWF  xFA
6EC0:  MOVLW  C3
6EC2:  MOVWF  xF9
6EC4:  MOVLB  0
6EC6:  CALL   5AFE
....................          date = (unsigned int8)strtoi(temp); 
6ECA:  MOVLW  07
6ECC:  MOVLB  7
6ECE:  MOVWF  xF8
6ED0:  MOVLW  C3
6ED2:  MOVWF  xF7
6ED4:  MOVLB  0
6ED6:  CALL   6204
6EDA:  MOVFF  01,100
....................          fprintf(COM2,"Day>"); 
6EDE:  MOVLW  9E
6EE0:  MOVWF  FF6
6EE2:  MOVLW  1D
6EE4:  MOVWF  FF7
6EE6:  CLRF   19
6EE8:  BTFSC  FF2.7
6EEA:  BSF    19.7
6EEC:  BCF    FF2.7
6EEE:  CALL   06E2
6EF2:  BTFSC  19.7
6EF4:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6EF6:  MOVLW  01
6EF8:  MOVLB  7
6EFA:  MOVWF  xF7
6EFC:  MOVLW  03
6EFE:  MOVWF  xF8
6F00:  MOVLW  07
6F02:  MOVWF  xFA
6F04:  MOVLW  C3
6F06:  MOVWF  xF9
6F08:  MOVLB  0
6F0A:  CALL   5AFE
....................          day = (unsigned int8)strtoi(temp); 
6F0E:  MOVLW  07
6F10:  MOVLB  7
6F12:  MOVWF  xF8
6F14:  MOVLW  C3
6F16:  MOVWF  xF7
6F18:  MOVLB  0
6F1A:  CALL   6204
6F1E:  MOVFF  01,FD
....................          fprintf(COM2,"Hour>"); 
6F22:  MOVLW  A4
6F24:  MOVWF  FF6
6F26:  MOVLW  1D
6F28:  MOVWF  FF7
6F2A:  CLRF   19
6F2C:  BTFSC  FF2.7
6F2E:  BSF    19.7
6F30:  BCF    FF2.7
6F32:  CALL   06E2
6F36:  BTFSC  19.7
6F38:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6F3A:  MOVLW  01
6F3C:  MOVLB  7
6F3E:  MOVWF  xF7
6F40:  MOVLW  03
6F42:  MOVWF  xF8
6F44:  MOVLW  07
6F46:  MOVWF  xFA
6F48:  MOVLW  C3
6F4A:  MOVWF  xF9
6F4C:  MOVLB  0
6F4E:  CALL   5AFE
....................          h = (unsigned int8)strtoi(temp); 
6F52:  MOVLW  07
6F54:  MOVLB  7
6F56:  MOVWF  xF8
6F58:  MOVLW  C3
6F5A:  MOVWF  xF7
6F5C:  MOVLB  0
6F5E:  CALL   6204
6F62:  MOVFF  01,101
....................          fprintf(COM2,"Minutes>"); 
6F66:  MOVLW  AA
6F68:  MOVWF  FF6
6F6A:  MOVLW  1D
6F6C:  MOVWF  FF7
6F6E:  CLRF   19
6F70:  BTFSC  FF2.7
6F72:  BSF    19.7
6F74:  BCF    FF2.7
6F76:  CALL   06E2
6F7A:  BTFSC  19.7
6F7C:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6F7E:  MOVLW  01
6F80:  MOVLB  7
6F82:  MOVWF  xF7
6F84:  MOVLW  03
6F86:  MOVWF  xF8
6F88:  MOVLW  07
6F8A:  MOVWF  xFA
6F8C:  MOVLW  C3
6F8E:  MOVWF  xF9
6F90:  MOVLB  0
6F92:  CALL   5AFE
....................          min = (unsigned int8)strtoi(temp);                   
6F96:  MOVLW  07
6F98:  MOVLB  7
6F9A:  MOVWF  xF8
6F9C:  MOVLW  C3
6F9E:  MOVWF  xF7
6FA0:  MOVLB  0
6FA2:  CALL   6204
6FA6:  MOVFF  01,102
....................          fprintf(COM2,"Seconds>"); 
6FAA:  MOVLW  B4
6FAC:  MOVWF  FF6
6FAE:  MOVLW  1D
6FB0:  MOVWF  FF7
6FB2:  CLRF   19
6FB4:  BTFSC  FF2.7
6FB6:  BSF    19.7
6FB8:  BCF    FF2.7
6FBA:  CALL   06E2
6FBE:  BTFSC  19.7
6FC0:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6FC2:  MOVLW  01
6FC4:  MOVLB  7
6FC6:  MOVWF  xF7
6FC8:  MOVLW  03
6FCA:  MOVWF  xF8
6FCC:  MOVLW  07
6FCE:  MOVWF  xFA
6FD0:  MOVLW  C3
6FD2:  MOVWF  xF9
6FD4:  MOVLB  0
6FD6:  CALL   5AFE
....................          sec = (unsigned int8)strtoi(temp);                   
6FDA:  MOVLW  07
6FDC:  MOVLB  7
6FDE:  MOVWF  xF8
6FE0:  MOVLW  C3
6FE2:  MOVWF  xF7
6FE4:  MOVLB  0
6FE6:  CALL   6204
6FEA:  MOVFF  01,103
6FEE:  CLRF   19
6FF0:  BTFSC  FF2.7
6FF2:  BSF    19.7
6FF4:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
6FF6:  MOVLW  0A
6FF8:  MOVLB  8
6FFA:  MOVWF  x58
6FFC:  MOVLB  0
6FFE:  CALL   069C
7002:  BTFSC  19.7
7004:  BSF    FF2.7
7006:  CLRF   19
7008:  BTFSC  FF2.7
700A:  BSF    19.7
700C:  BCF    FF2.7
700E:  MOVLW  0D
7010:  MOVLB  8
7012:  MOVWF  x58
7014:  MOVLB  0
7016:  CALL   069C
701A:  BTFSC  19.7
701C:  BSF    FF2.7
....................          rtc_set_datetime(date,mon,year,day,h,min); 
701E:  MOVFF  100,7F7
7022:  MOVFF  FF,7F8
7026:  MOVFF  FE,7F9
702A:  MOVFF  FD,7FA
702E:  MOVFF  101,7FB
7032:  MOVFF  102,7FC
7036:  GOTO   633E
....................       } 
....................       strcpy(buffer2,"MS"); 
703A:  CLRF   FEA
703C:  MOVLW  41
703E:  MOVWF  FE9
7040:  MOVLW  00
7042:  CALL   041E
7046:  TBLRD*-
7048:  TBLRD*+
704A:  MOVF   FF5,W
704C:  MOVWF  FEE
704E:  IORLW  00
7050:  BNZ   7048
....................       if(!stringcomp(buffer_uart,buffer2)) 
7052:  MOVLW  01
7054:  MOVLB  7
7056:  MOVWF  xF8
7058:  MOVLW  69
705A:  MOVWF  xF7
705C:  CLRF   xFA
705E:  MOVLW  41
7060:  MOVWF  xF9
7062:  MOVLB  0
7064:  CALL   5C36
7068:  MOVF   01,F
706A:  BTFSS  FD8.2
706C:  BRA    7180
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
706E:  MOVLW  BE
7070:  MOVWF  FF6
7072:  MOVLW  1D
7074:  MOVWF  FF7
7076:  CLRF   19
7078:  BTFSC  FF2.7
707A:  BSF    19.7
707C:  BCF    FF2.7
707E:  CALL   06E2
7082:  BTFSC  19.7
7084:  BSF    FF2.7
7086:  CLRF   19
7088:  BTFSC  FF2.7
708A:  BSF    19.7
708C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
708E:  MOVLW  0A
7090:  MOVLB  8
7092:  MOVWF  x58
7094:  MOVLB  0
7096:  CALL   069C
709A:  BTFSC  19.7
709C:  BSF    FF2.7
709E:  CLRF   19
70A0:  BTFSC  FF2.7
70A2:  BSF    19.7
70A4:  BCF    FF2.7
70A6:  MOVLW  0D
70A8:  MOVLB  8
70AA:  MOVWF  x58
70AC:  MOVLB  0
70AE:  CALL   069C
70B2:  BTFSC  19.7
70B4:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
70B6:  MOVLW  DE
70B8:  MOVWF  FF6
70BA:  MOVLW  1D
70BC:  MOVWF  FF7
70BE:  CLRF   19
70C0:  BTFSC  FF2.7
70C2:  BSF    19.7
70C4:  BCF    FF2.7
70C6:  CALL   06E2
70CA:  BTFSC  19.7
70CC:  BSF    FF2.7
70CE:  CLRF   19
70D0:  BTFSC  FF2.7
70D2:  BSF    19.7
70D4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
70D6:  MOVLW  0A
70D8:  MOVLB  8
70DA:  MOVWF  x58
70DC:  MOVLB  0
70DE:  CALL   069C
70E2:  BTFSC  19.7
70E4:  BSF    FF2.7
70E6:  CLRF   19
70E8:  BTFSC  FF2.7
70EA:  BSF    19.7
70EC:  BCF    FF2.7
70EE:  MOVLW  0D
70F0:  MOVLB  8
70F2:  MOVWF  x58
70F4:  MOVLB  0
70F6:  CALL   069C
70FA:  BTFSC  19.7
70FC:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
70FE:  MOVLW  01
7100:  MOVLB  7
7102:  MOVWF  xF7
7104:  MOVLW  03
7106:  MOVWF  xF8
7108:  MOVLW  07
710A:  MOVWF  xFA
710C:  MOVLW  C3
710E:  MOVWF  xF9
7110:  MOVLB  0
7112:  CALL   5AFE
....................           mode_sl = (unsigned int8)strtoi(temp); 
7116:  MOVLW  07
7118:  MOVLB  7
711A:  MOVWF  xF8
711C:  MOVLW  C3
711E:  MOVWF  xF7
7120:  MOVLB  0
7122:  CALL   6204
7126:  MOVFF  01,6E6
712A:  CLRF   19
712C:  BTFSC  FF2.7
712E:  BSF    19.7
7130:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
7132:  MOVLB  8
7134:  CLRF   x43
7136:  CLRF   x42
7138:  CLRF   x41
713A:  MOVLW  91
713C:  MOVWF  x40
713E:  MOVFF  6E6,844
7142:  MOVLB  0
7144:  CALL   3AA6
7148:  BTFSC  19.7
714A:  BSF    FF2.7
....................           set_tris_a(0xff); 
714C:  MOVLW  FF
714E:  MOVWF  F92
7150:  CLRF   19
7152:  BTFSC  FF2.7
7154:  BSF    19.7
7156:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7158:  MOVLW  0A
715A:  MOVLB  8
715C:  MOVWF  x58
715E:  MOVLB  0
7160:  CALL   069C
7164:  BTFSC  19.7
7166:  BSF    FF2.7
7168:  CLRF   19
716A:  BTFSC  FF2.7
716C:  BSF    19.7
716E:  BCF    FF2.7
7170:  MOVLW  0D
7172:  MOVLB  8
7174:  MOVWF  x58
7176:  MOVLB  0
7178:  CALL   069C
717C:  BTFSC  19.7
717E:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"KP"); 
7180:  CLRF   FEA
7182:  MOVLW  41
7184:  MOVWF  FE9
7186:  MOVLW  00
7188:  CALL   0432
718C:  TBLRD*-
718E:  TBLRD*+
7190:  MOVF   FF5,W
7192:  MOVWF  FEE
7194:  IORLW  00
7196:  BNZ   718E
....................       if(!stringcomp(buffer_uart,buffer2)) 
7198:  MOVLW  01
719A:  MOVLB  7
719C:  MOVWF  xF8
719E:  MOVLW  69
71A0:  MOVWF  xF7
71A2:  CLRF   xFA
71A4:  MOVLW  41
71A6:  MOVWF  xF9
71A8:  MOVLB  0
71AA:  CALL   5C36
71AE:  MOVF   01,F
71B0:  BTFSS  FD8.2
71B2:  BRA    72C2
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
71B4:  MOVLW  FE
71B6:  MOVWF  FF6
71B8:  MOVLW  1D
71BA:  MOVWF  FF7
71BC:  CLRF   19
71BE:  BTFSC  FF2.7
71C0:  BSF    19.7
71C2:  BCF    FF2.7
71C4:  CALL   06E2
71C8:  BTFSC  19.7
71CA:  BSF    FF2.7
71CC:  CLRF   19
71CE:  BTFSC  FF2.7
71D0:  BSF    19.7
71D2:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
71D4:  MOVLW  0A
71D6:  MOVLB  8
71D8:  MOVWF  x58
71DA:  MOVLB  0
71DC:  CALL   069C
71E0:  BTFSC  19.7
71E2:  BSF    FF2.7
71E4:  CLRF   19
71E6:  BTFSC  FF2.7
71E8:  BSF    19.7
71EA:  BCF    FF2.7
71EC:  MOVLW  0D
71EE:  MOVLB  8
71F0:  MOVWF  x58
71F2:  MOVLB  0
71F4:  CALL   069C
71F8:  BTFSC  19.7
71FA:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
71FC:  MOVLW  1C
71FE:  MOVWF  FF6
7200:  MOVLW  1E
7202:  MOVWF  FF7
7204:  CLRF   19
7206:  BTFSC  FF2.7
7208:  BSF    19.7
720A:  BCF    FF2.7
720C:  CALL   06E2
7210:  BTFSC  19.7
7212:  BSF    FF2.7
7214:  CLRF   19
7216:  BTFSC  FF2.7
7218:  BSF    19.7
721A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
721C:  MOVLW  0A
721E:  MOVLB  8
7220:  MOVWF  x58
7222:  MOVLB  0
7224:  CALL   069C
7228:  BTFSC  19.7
722A:  BSF    FF2.7
722C:  CLRF   19
722E:  BTFSC  FF2.7
7230:  BSF    19.7
7232:  BCF    FF2.7
7234:  MOVLW  0D
7236:  MOVLB  8
7238:  MOVWF  x58
723A:  MOVLB  0
723C:  CALL   069C
7240:  BTFSC  19.7
7242:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7244:  MOVLW  01
7246:  MOVLB  7
7248:  MOVWF  xF7
724A:  MOVLW  03
724C:  MOVWF  xF8
724E:  MOVLW  07
7250:  MOVWF  xFA
7252:  MOVLW  C3
7254:  MOVWF  xF9
7256:  MOVLB  0
7258:  CALL   5AFE
....................           KP_mode = (unsigned int8)strtoi(temp); 
725C:  MOVLW  07
725E:  MOVLB  7
7260:  MOVWF  xF8
7262:  MOVLW  C3
7264:  MOVWF  xF7
7266:  MOVLB  0
7268:  CALL   6204
726C:  MOVFF  01,150
7270:  CLRF   19
7272:  BTFSC  FF2.7
7274:  BSF    19.7
7276:  BCF    FF2.7
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
7278:  MOVLB  8
727A:  CLRF   x43
727C:  CLRF   x42
727E:  CLRF   x41
7280:  MOVLW  7F
7282:  MOVWF  x40
7284:  MOVFF  150,844
7288:  MOVLB  0
728A:  CALL   3AA6
728E:  BTFSC  19.7
7290:  BSF    FF2.7
7292:  CLRF   19
7294:  BTFSC  FF2.7
7296:  BSF    19.7
7298:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
729A:  MOVLW  0A
729C:  MOVLB  8
729E:  MOVWF  x58
72A0:  MOVLB  0
72A2:  CALL   069C
72A6:  BTFSC  19.7
72A8:  BSF    FF2.7
72AA:  CLRF   19
72AC:  BTFSC  FF2.7
72AE:  BSF    19.7
72B0:  BCF    FF2.7
72B2:  MOVLW  0D
72B4:  MOVLB  8
72B6:  MOVWF  x58
72B8:  MOVLB  0
72BA:  CALL   069C
72BE:  BTFSC  19.7
72C0:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"tran time"); 
72C2:  CLRF   FEA
72C4:  MOVLW  41
72C6:  MOVWF  FE9
72C8:  MOVLW  00
72CA:  CALL   0446
72CE:  TBLRD*-
72D0:  TBLRD*+
72D2:  MOVF   FF5,W
72D4:  MOVWF  FEE
72D6:  IORLW  00
72D8:  BNZ   72D0
....................       if(!stringcomp(buffer_uart,buffer2)) 
72DA:  MOVLW  01
72DC:  MOVLB  7
72DE:  MOVWF  xF8
72E0:  MOVLW  69
72E2:  MOVWF  xF7
72E4:  CLRF   xFA
72E6:  MOVLW  41
72E8:  MOVWF  xF9
72EA:  MOVLB  0
72EC:  CALL   5C36
72F0:  MOVF   01,F
72F2:  BNZ   73BA
....................       { 
....................           fprintf(COM2,"Input Number"); 
72F4:  MOVLW  3A
72F6:  MOVWF  FF6
72F8:  MOVLW  1E
72FA:  MOVWF  FF7
72FC:  CLRF   19
72FE:  BTFSC  FF2.7
7300:  BSF    19.7
7302:  BCF    FF2.7
7304:  CALL   06E2
7308:  BTFSC  19.7
730A:  BSF    FF2.7
730C:  CLRF   19
730E:  BTFSC  FF2.7
7310:  BSF    19.7
7312:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7314:  MOVLW  0A
7316:  MOVLB  8
7318:  MOVWF  x58
731A:  MOVLB  0
731C:  CALL   069C
7320:  BTFSC  19.7
7322:  BSF    FF2.7
7324:  CLRF   19
7326:  BTFSC  FF2.7
7328:  BSF    19.7
732A:  BCF    FF2.7
732C:  MOVLW  0D
732E:  MOVLB  8
7330:  MOVWF  x58
7332:  MOVLB  0
7334:  CALL   069C
7338:  BTFSC  19.7
733A:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
733C:  MOVLW  01
733E:  MOVLB  7
7340:  MOVWF  xF7
7342:  MOVLW  03
7344:  MOVWF  xF8
7346:  MOVLW  07
7348:  MOVWF  xFA
734A:  MOVLW  C3
734C:  MOVWF  xF9
734E:  MOVLB  0
7350:  CALL   5AFE
....................           delaycharaction = (unsigned int8)strtoi(temp); 
7354:  MOVLW  07
7356:  MOVLB  7
7358:  MOVWF  xF8
735A:  MOVLW  C3
735C:  MOVWF  xF7
735E:  MOVLB  0
7360:  CALL   6204
7364:  MOVFF  01,161
7368:  CLRF   19
736A:  BTFSC  FF2.7
736C:  BSF    19.7
736E:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
7370:  MOVLB  8
7372:  CLRF   x43
7374:  CLRF   x42
7376:  CLRF   x41
7378:  MOVLW  94
737A:  MOVWF  x40
737C:  MOVFF  161,844
7380:  MOVLB  0
7382:  CALL   3AA6
7386:  BTFSC  19.7
7388:  BSF    FF2.7
738A:  CLRF   19
738C:  BTFSC  FF2.7
738E:  BSF    19.7
7390:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7392:  MOVLW  0A
7394:  MOVLB  8
7396:  MOVWF  x58
7398:  MOVLB  0
739A:  CALL   069C
739E:  BTFSC  19.7
73A0:  BSF    FF2.7
73A2:  CLRF   19
73A4:  BTFSC  FF2.7
73A6:  BSF    19.7
73A8:  BCF    FF2.7
73AA:  MOVLW  0D
73AC:  MOVLB  8
73AE:  MOVWF  x58
73B0:  MOVLB  0
73B2:  CALL   069C
73B6:  BTFSC  19.7
73B8:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
73BA:  CLRF   FEA
73BC:  MOVLW  41
73BE:  MOVWF  FE9
73C0:  MOVLW  00
73C2:  CALL   0460
73C6:  TBLRD*-
73C8:  TBLRD*+
73CA:  MOVF   FF5,W
73CC:  MOVWF  FEE
73CE:  IORLW  00
73D0:  BNZ   73C8
....................       if(!stringcomp(buffer_uart,buffer2)) 
73D2:  MOVLW  01
73D4:  MOVLB  7
73D6:  MOVWF  xF8
73D8:  MOVLW  69
73DA:  MOVWF  xF7
73DC:  CLRF   xFA
73DE:  MOVLW  41
73E0:  MOVWF  xF9
73E2:  MOVLB  0
73E4:  CALL   5C36
73E8:  MOVF   01,F
73EA:  BTFSS  FD8.2
73EC:  BRA    74FC
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
73EE:  MOVLW  48
73F0:  MOVWF  FF6
73F2:  MOVLW  1E
73F4:  MOVWF  FF7
73F6:  CLRF   19
73F8:  BTFSC  FF2.7
73FA:  BSF    19.7
73FC:  BCF    FF2.7
73FE:  CALL   06E2
7402:  BTFSC  19.7
7404:  BSF    FF2.7
7406:  CLRF   19
7408:  BTFSC  FF2.7
740A:  BSF    19.7
740C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
740E:  MOVLW  0A
7410:  MOVLB  8
7412:  MOVWF  x58
7414:  MOVLB  0
7416:  CALL   069C
741A:  BTFSC  19.7
741C:  BSF    FF2.7
741E:  CLRF   19
7420:  BTFSC  FF2.7
7422:  BSF    19.7
7424:  BCF    FF2.7
7426:  MOVLW  0D
7428:  MOVLB  8
742A:  MOVWF  x58
742C:  MOVLB  0
742E:  CALL   069C
7432:  BTFSC  19.7
7434:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
7436:  MOVLW  6E
7438:  MOVWF  FF6
743A:  MOVLW  1E
743C:  MOVWF  FF7
743E:  CLRF   19
7440:  BTFSC  FF2.7
7442:  BSF    19.7
7444:  BCF    FF2.7
7446:  CALL   06E2
744A:  BTFSC  19.7
744C:  BSF    FF2.7
744E:  CLRF   19
7450:  BTFSC  FF2.7
7452:  BSF    19.7
7454:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7456:  MOVLW  0A
7458:  MOVLB  8
745A:  MOVWF  x58
745C:  MOVLB  0
745E:  CALL   069C
7462:  BTFSC  19.7
7464:  BSF    FF2.7
7466:  CLRF   19
7468:  BTFSC  FF2.7
746A:  BSF    19.7
746C:  BCF    FF2.7
746E:  MOVLW  0D
7470:  MOVLB  8
7472:  MOVWF  x58
7474:  MOVLB  0
7476:  CALL   069C
747A:  BTFSC  19.7
747C:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
747E:  MOVLW  01
7480:  MOVLB  7
7482:  MOVWF  xF7
7484:  MOVLW  03
7486:  MOVWF  xF8
7488:  MOVLW  07
748A:  MOVWF  xFA
748C:  MOVLW  C3
748E:  MOVWF  xF9
7490:  MOVLB  0
7492:  CALL   5AFE
....................           type_KB=(unsigned int8)strtoi(temp); 
7496:  MOVLW  07
7498:  MOVLB  7
749A:  MOVWF  xF8
749C:  MOVLW  C3
749E:  MOVWF  xF7
74A0:  MOVLB  0
74A2:  CALL   6204
74A6:  MOVFF  01,154
74AA:  CLRF   19
74AC:  BTFSC  FF2.7
74AE:  BSF    19.7
74B0:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
74B2:  MOVLB  8
74B4:  CLRF   x43
74B6:  CLRF   x42
74B8:  CLRF   x41
74BA:  MOVLW  7E
74BC:  MOVWF  x40
74BE:  MOVFF  154,844
74C2:  MOVLB  0
74C4:  CALL   3AA6
74C8:  BTFSC  19.7
74CA:  BSF    FF2.7
74CC:  CLRF   19
74CE:  BTFSC  FF2.7
74D0:  BSF    19.7
74D2:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
74D4:  MOVLW  0A
74D6:  MOVLB  8
74D8:  MOVWF  x58
74DA:  MOVLB  0
74DC:  CALL   069C
74E0:  BTFSC  19.7
74E2:  BSF    FF2.7
74E4:  CLRF   19
74E6:  BTFSC  FF2.7
74E8:  BSF    19.7
74EA:  BCF    FF2.7
74EC:  MOVLW  0D
74EE:  MOVLB  8
74F0:  MOVWF  x58
74F2:  MOVLB  0
74F4:  CALL   069C
74F8:  BTFSC  19.7
74FA:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
74FC:  CLRF   FEA
74FE:  MOVLW  41
7500:  MOVWF  FE9
7502:  MOVLW  00
7504:  CALL   0476
7508:  TBLRD*-
750A:  TBLRD*+
750C:  MOVF   FF5,W
750E:  MOVWF  FEE
7510:  IORLW  00
7512:  BNZ   750A
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7514:  MOVLW  01
7516:  MOVLB  7
7518:  MOVWF  xF8
751A:  MOVLW  69
751C:  MOVWF  xF7
751E:  CLRF   xFA
7520:  MOVLW  41
7522:  MOVWF  xF9
7524:  MOVLB  0
7526:  CALL   5C36
752A:  MOVF   01,F
752C:  BTFSS  FD8.2
752E:  BRA    7716
....................       { 
....................          printf("h-> Help\n\r"); 
7530:  MOVLW  94
7532:  MOVWF  FF6
7534:  MOVLW  1E
7536:  MOVWF  FF7
7538:  CLRF   19
753A:  BTFSC  FF2.7
753C:  BSF    19.7
753E:  BCF    FF2.7
7540:  CALL   06E2
7544:  BTFSC  19.7
7546:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
7548:  MOVLW  A0
754A:  MOVWF  FF6
754C:  MOVLW  1E
754E:  MOVWF  FF7
7550:  CLRF   19
7552:  BTFSC  FF2.7
7554:  BSF    19.7
7556:  BCF    FF2.7
7558:  CALL   06E2
755C:  BTFSC  19.7
755E:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
7560:  MOVLW  B2
7562:  MOVWF  FF6
7564:  MOVLW  1E
7566:  MOVWF  FF7
7568:  CLRF   19
756A:  BTFSC  FF2.7
756C:  BSF    19.7
756E:  BCF    FF2.7
7570:  CALL   06E2
7574:  BTFSC  19.7
7576:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
7578:  MOVLW  C4
757A:  MOVWF  FF6
757C:  MOVLW  1E
757E:  MOVWF  FF7
7580:  CLRF   19
7582:  BTFSC  FF2.7
7584:  BSF    19.7
7586:  BCF    FF2.7
7588:  CALL   06E2
758C:  BTFSC  19.7
758E:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
7590:  MOVLW  E4
7592:  MOVWF  FF6
7594:  MOVLW  1E
7596:  MOVWF  FF7
7598:  CLRF   19
759A:  BTFSC  FF2.7
759C:  BSF    19.7
759E:  BCF    FF2.7
75A0:  CALL   06E2
75A4:  BTFSC  19.7
75A6:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
75A8:  MOVLW  00
75AA:  MOVWF  FF6
75AC:  MOVLW  1F
75AE:  MOVWF  FF7
75B0:  CLRF   19
75B2:  BTFSC  FF2.7
75B4:  BSF    19.7
75B6:  BCF    FF2.7
75B8:  CALL   06E2
75BC:  BTFSC  19.7
75BE:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
75C0:  MOVLW  0E
75C2:  MOVWF  FF6
75C4:  MOVLW  1F
75C6:  MOVWF  FF7
75C8:  CLRF   19
75CA:  BTFSC  FF2.7
75CC:  BSF    19.7
75CE:  BCF    FF2.7
75D0:  CALL   06E2
75D4:  BTFSC  19.7
75D6:  BSF    FF2.7
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
75D8:  MOVLW  1A
75DA:  MOVWF  FF6
75DC:  MOVLW  1F
75DE:  MOVWF  FF7
75E0:  CLRF   19
75E2:  BTFSC  FF2.7
75E4:  BSF    19.7
75E6:  BCF    FF2.7
75E8:  CALL   06E2
75EC:  BTFSC  19.7
75EE:  BSF    FF2.7
75F0:  CLRF   19
75F2:  BTFSC  FF2.7
75F4:  BSF    19.7
75F6:  BCF    FF2.7
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
75F8:  MOVLB  8
75FA:  CLRF   x3B
75FC:  CLRF   x3A
75FE:  CLRF   x39
7600:  MOVLW  7F
7602:  MOVWF  x38
7604:  MOVLB  0
7606:  CALL   3556
760A:  BTFSC  19.7
760C:  BSF    FF2.7
760E:  MOVFF  01,150
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
7612:  MOVLB  1
7614:  MOVF   x50,F
7616:  BZ    7636
7618:  MOVLW  46
761A:  MOVWF  FF6
761C:  MOVLW  1F
761E:  MOVWF  FF7
7620:  CLRF   19
7622:  BTFSC  FF2.7
7624:  BSF    19.7
7626:  BCF    FF2.7
7628:  MOVLB  0
762A:  CALL   06E2
762E:  BTFSC  19.7
7630:  BSF    FF2.7
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
7632:  BRA    7650
7634:  MOVLB  1
7636:  MOVLW  68
7638:  MOVWF  FF6
763A:  MOVLW  1F
763C:  MOVWF  FF7
763E:  CLRF   19
7640:  BTFSC  FF2.7
7642:  BSF    19.7
7644:  BCF    FF2.7
7646:  MOVLB  0
7648:  CALL   06E2
764C:  BTFSC  19.7
764E:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
7650:  MOVLW  8C
7652:  MOVWF  FF6
7654:  MOVLW  1F
7656:  MOVWF  FF7
7658:  CLRF   19
765A:  BTFSC  FF2.7
765C:  BSF    19.7
765E:  BCF    FF2.7
7660:  CALL   06E2
7664:  BTFSC  19.7
7666:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
7668:  MOVLW  B4
766A:  MOVWF  FF6
766C:  MOVLW  1F
766E:  MOVWF  FF7
7670:  CLRF   19
7672:  BTFSC  FF2.7
7674:  BSF    19.7
7676:  BCF    FF2.7
7678:  CALL   06E2
767C:  BTFSC  19.7
767E:  BSF    FF2.7
7680:  CLRF   19
7682:  BTFSC  FF2.7
7684:  BSF    19.7
7686:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
7688:  MOVLB  8
768A:  CLRF   x3B
768C:  CLRF   x3A
768E:  CLRF   x39
7690:  MOVLW  7E
7692:  MOVWF  x38
7694:  MOVLB  0
7696:  CALL   3556
769A:  BTFSC  19.7
769C:  BSF    FF2.7
769E:  MOVFF  01,7F7
76A2:  MOVLW  D0
76A4:  MOVWF  FF6
76A6:  MOVLW  1F
76A8:  MOVWF  FF7
76AA:  CLRF   19
76AC:  BTFSC  FF2.7
76AE:  BSF    19.7
76B0:  BCF    FF2.7
76B2:  MOVLW  06
76B4:  MOVLB  8
76B6:  MOVWF  x4C
76B8:  MOVLB  0
76BA:  CALL   165A
76BE:  BTFSC  19.7
76C0:  BSF    FF2.7
76C2:  CLRF   19
76C4:  BTFSC  FF2.7
76C6:  BSF    19.7
76C8:  BCF    FF2.7
76CA:  MOVFF  7F7,838
76CE:  MOVLW  18
76D0:  MOVLB  8
76D2:  MOVWF  x39
76D4:  MOVLB  0
76D6:  CALL   176E
76DA:  BTFSC  19.7
76DC:  BSF    FF2.7
76DE:  MOVLW  D8
76E0:  MOVWF  FF6
76E2:  MOVLW  1F
76E4:  MOVWF  FF7
76E6:  CLRF   19
76E8:  BTFSC  FF2.7
76EA:  BSF    19.7
76EC:  BCF    FF2.7
76EE:  MOVLW  1D
76F0:  MOVLB  8
76F2:  MOVWF  x4C
76F4:  MOVLB  0
76F6:  CALL   165A
76FA:  BTFSC  19.7
76FC:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
76FE:  MOVLW  F6
7700:  MOVWF  FF6
7702:  MOVLW  1F
7704:  MOVWF  FF7
7706:  CLRF   19
7708:  BTFSC  FF2.7
770A:  BSF    19.7
770C:  BCF    FF2.7
770E:  CALL   06E2
7712:  BTFSC  19.7
7714:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
7716:  CLRF   FEA
7718:  MOVLW  41
771A:  MOVWF  FE9
771C:  MOVLW  00
771E:  CALL   0488
7722:  TBLRD*-
7724:  TBLRD*+
7726:  MOVF   FF5,W
7728:  MOVWF  FEE
772A:  IORLW  00
772C:  BNZ   7724
....................       if(!stringcomp(buffer_uart,buffer2))  
772E:  MOVLW  01
7730:  MOVLB  7
7732:  MOVWF  xF8
7734:  MOVLW  69
7736:  MOVWF  xF7
7738:  CLRF   xFA
773A:  MOVLW  41
773C:  MOVWF  xF9
773E:  MOVLB  0
7740:  CALL   5C36
7744:  MOVF   01,F
7746:  BTFSS  FD8.2
7748:  BRA    7894
....................       { 
....................          fprintf(COM2,"old password:"); 
774A:  MOVLW  10
774C:  MOVWF  FF6
774E:  MOVLW  20
7750:  MOVWF  FF7
7752:  CLRF   19
7754:  BTFSC  FF2.7
7756:  BSF    19.7
7758:  BCF    FF2.7
775A:  CALL   06E2
775E:  BTFSC  19.7
7760:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
7762:  MOVLB  7
7764:  CLRF   xFA
7766:  CLRF   xF9
7768:  CLRF   xF8
776A:  CLRF   xF7
776C:  CLRF   xFE
776E:  CLRF   xFD
7770:  CLRF   xFC
7772:  MOVLW  14
7774:  MOVWF  xFB
7776:  MOVLB  8
7778:  CLRF   x00
777A:  MOVLW  55
777C:  MOVLB  7
777E:  MOVWF  xFF
7780:  MOVLB  0
7782:  CALL   463A
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
7786:  MOVLW  02
7788:  MOVLB  7
778A:  MOVWF  xF7
778C:  MOVLW  14
778E:  MOVWF  xF8
7790:  CLRF   xFA
7792:  MOVLW  69
7794:  MOVWF  xF9
7796:  MOVLB  0
7798:  CALL   5AFE
....................          if(!stringcomp(entpassword,password)) 
779C:  MOVLB  7
779E:  CLRF   xF8
77A0:  MOVLW  69
77A2:  MOVWF  xF7
77A4:  CLRF   xFA
77A6:  MOVLW  55
77A8:  MOVWF  xF9
77AA:  MOVLB  0
77AC:  CALL   5C36
77B0:  MOVF   01,F
77B2:  BNZ   787C
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
77B4:  MOVLW  1E
77B6:  MOVWF  FF6
77B8:  MOVLW  20
77BA:  MOVWF  FF7
77BC:  CLRF   19
77BE:  BTFSC  FF2.7
77C0:  BSF    19.7
77C2:  BCF    FF2.7
77C4:  CALL   06E2
77C8:  BTFSC  19.7
77CA:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
77CC:  MOVLW  02
77CE:  MOVLB  7
77D0:  MOVWF  xF7
77D2:  MOVLW  14
77D4:  MOVWF  xF8
77D6:  CLRF   xFA
77D8:  MOVLW  69
77DA:  MOVWF  xF9
77DC:  MOVLB  0
77DE:  CALL   5AFE
....................             fprintf(COM2,"\n\ragain:"); 
77E2:  MOVLW  26
77E4:  MOVWF  FF6
77E6:  MOVLW  20
77E8:  MOVWF  FF7
77EA:  CLRF   19
77EC:  BTFSC  FF2.7
77EE:  BSF    19.7
77F0:  BCF    FF2.7
77F2:  CALL   06E2
77F6:  BTFSC  19.7
77F8:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
77FA:  MOVLW  02
77FC:  MOVLB  7
77FE:  MOVWF  xF7
7800:  MOVLW  14
7802:  MOVWF  xF8
7804:  CLRF   xFA
7806:  MOVLW  55
7808:  MOVWF  xF9
780A:  MOVLB  0
780C:  CALL   5AFE
....................             if(!stringcomp(entpassword,password)) 
7810:  MOVLB  7
7812:  CLRF   xF8
7814:  MOVLW  69
7816:  MOVWF  xF7
7818:  CLRF   xFA
781A:  MOVLW  55
781C:  MOVWF  xF9
781E:  MOVLB  0
7820:  CALL   5C36
7824:  MOVF   01,F
7826:  BNZ   7862
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
7828:  MOVLB  8
782A:  CLRF   x0F
782C:  CLRF   x0E
782E:  CLRF   x0D
7830:  CLRF   x0C
7832:  CLRF   x13
7834:  CLRF   x12
7836:  CLRF   x11
7838:  MOVLW  14
783A:  MOVWF  x10
783C:  CLRF   x15
783E:  MOVLW  55
7840:  MOVWF  x14
7842:  MOVLB  0
7844:  CALL   4702
....................                fprintf(COM2,"\n\rOK\n\r");    
7848:  MOVLW  30
784A:  MOVWF  FF6
784C:  MOVLW  20
784E:  MOVWF  FF7
7850:  CLRF   19
7852:  BTFSC  FF2.7
7854:  BSF    19.7
7856:  BCF    FF2.7
7858:  CALL   06E2
785C:  BTFSC  19.7
785E:  BSF    FF2.7
....................             } 
....................                else 
7860:  BRA    787A
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
7862:  MOVLW  38
7864:  MOVWF  FF6
7866:  MOVLW  20
7868:  MOVWF  FF7
786A:  CLRF   19
786C:  BTFSC  FF2.7
786E:  BSF    19.7
7870:  BCF    FF2.7
7872:  CALL   06E2
7876:  BTFSC  19.7
7878:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
787A:  BRA    7894
....................             { 
....................                fprintf(COM2," X\n\r"); 
787C:  MOVLW  40
787E:  MOVWF  FF6
7880:  MOVLW  20
7882:  MOVWF  FF7
7884:  CLRF   19
7886:  BTFSC  FF2.7
7888:  BSF    19.7
788A:  BCF    FF2.7
788C:  CALL   06E2
7890:  BTFSC  19.7
7892:  BSF    FF2.7
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
7894:  CLRF   FEA
7896:  MOVLW  41
7898:  MOVWF  FE9
789A:  MOVLW  00
789C:  CALL   04A2
78A0:  TBLRD*-
78A2:  TBLRD*+
78A4:  MOVF   FF5,W
78A6:  MOVWF  FEE
78A8:  IORLW  00
78AA:  BNZ   78A2
....................       if(!stringcomp(buffer_uart,buffer2)) 
78AC:  MOVLW  01
78AE:  MOVLB  7
78B0:  MOVWF  xF8
78B2:  MOVLW  69
78B4:  MOVWF  xF7
78B6:  CLRF   xFA
78B8:  MOVLW  41
78BA:  MOVWF  xF9
78BC:  MOVLB  0
78BE:  CALL   5C36
78C2:  MOVF   01,F
78C4:  BTFSS  FD8.2
78C6:  BRA    79D6
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
78C8:  MOVLW  46
78CA:  MOVWF  FF6
78CC:  MOVLW  20
78CE:  MOVWF  FF7
78D0:  CLRF   19
78D2:  BTFSC  FF2.7
78D4:  BSF    19.7
78D6:  BCF    FF2.7
78D8:  CALL   06E2
78DC:  BTFSC  19.7
78DE:  BSF    FF2.7
78E0:  CLRF   19
78E2:  BTFSC  FF2.7
78E4:  BSF    19.7
78E6:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
78E8:  MOVLW  0A
78EA:  MOVLB  8
78EC:  MOVWF  x58
78EE:  MOVLB  0
78F0:  CALL   069C
78F4:  BTFSC  19.7
78F6:  BSF    FF2.7
78F8:  CLRF   19
78FA:  BTFSC  FF2.7
78FC:  BSF    19.7
78FE:  BCF    FF2.7
7900:  MOVLW  0D
7902:  MOVLB  8
7904:  MOVWF  x58
7906:  MOVLB  0
7908:  CALL   069C
790C:  BTFSC  19.7
790E:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
7910:  MOVLW  66
7912:  MOVWF  FF6
7914:  MOVLW  20
7916:  MOVWF  FF7
7918:  CLRF   19
791A:  BTFSC  FF2.7
791C:  BSF    19.7
791E:  BCF    FF2.7
7920:  CALL   06E2
7924:  BTFSC  19.7
7926:  BSF    FF2.7
7928:  CLRF   19
792A:  BTFSC  FF2.7
792C:  BSF    19.7
792E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7930:  MOVLW  0A
7932:  MOVLB  8
7934:  MOVWF  x58
7936:  MOVLB  0
7938:  CALL   069C
793C:  BTFSC  19.7
793E:  BSF    FF2.7
7940:  CLRF   19
7942:  BTFSC  FF2.7
7944:  BSF    19.7
7946:  BCF    FF2.7
7948:  MOVLW  0D
794A:  MOVLB  8
794C:  MOVWF  x58
794E:  MOVLB  0
7950:  CALL   069C
7954:  BTFSC  19.7
7956:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7958:  MOVLW  01
795A:  MOVLB  7
795C:  MOVWF  xF7
795E:  MOVLW  03
7960:  MOVWF  xF8
7962:  MOVLW  07
7964:  MOVWF  xFA
7966:  MOVLW  C3
7968:  MOVWF  xF9
796A:  MOVLB  0
796C:  CALL   5AFE
....................           debugmode = (unsigned int8)strtoi(temp); 
7970:  MOVLW  07
7972:  MOVLB  7
7974:  MOVWF  xF8
7976:  MOVLW  C3
7978:  MOVWF  xF7
797A:  MOVLB  0
797C:  CALL   6204
7980:  MOVFF  01,6DA
7984:  CLRF   19
7986:  BTFSC  FF2.7
7988:  BSF    19.7
798A:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
798C:  MOVLB  8
798E:  CLRF   x43
7990:  CLRF   x42
7992:  CLRF   x41
7994:  MOVLW  92
7996:  MOVWF  x40
7998:  MOVFF  6DA,844
799C:  MOVLB  0
799E:  CALL   3AA6
79A2:  BTFSC  19.7
79A4:  BSF    FF2.7
79A6:  CLRF   19
79A8:  BTFSC  FF2.7
79AA:  BSF    19.7
79AC:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
79AE:  MOVLW  0A
79B0:  MOVLB  8
79B2:  MOVWF  x58
79B4:  MOVLB  0
79B6:  CALL   069C
79BA:  BTFSC  19.7
79BC:  BSF    FF2.7
79BE:  CLRF   19
79C0:  BTFSC  FF2.7
79C2:  BSF    19.7
79C4:  BCF    FF2.7
79C6:  MOVLW  0D
79C8:  MOVLB  8
79CA:  MOVWF  x58
79CC:  MOVLB  0
79CE:  CALL   069C
79D2:  BTFSC  19.7
79D4:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
79D6:  GOTO   824C (RETURN)
.................... //=============================================== 
....................  
....................  
.................... //========================= 
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
430A:  MOVLB  1
430C:  MOVF   x50,F
430E:  BZ    434A
....................    { 
....................       if(count_kp<500)count_kp++; 
4310:  MOVF   x53,W
4312:  SUBLW  01
4314:  BNC   4324
4316:  BNZ   431E
4318:  MOVF   x52,W
431A:  SUBLW  F3
431C:  BNC   4324
431E:  INCF   x52,F
4320:  BTFSC  FD8.2
4322:  INCF   x53,F
....................       if(count_kp==500) 
4324:  MOVF   x52,W
4326:  SUBLW  F4
4328:  BNZ   434A
432A:  DECFSZ x53,W
432C:  BRA    434A
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
432E:  MOVLW  12
4330:  MOVWF  FF6
4332:  MOVLW  45
4334:  MOVWF  FF7
4336:  MOVLB  0
4338:  CALL   06E2
....................             keyprss_off; 
433C:  BCF    F92.7
433E:  BCF    F89.7
....................             kp_st=0;     
4340:  MOVLB  1
4342:  CLRF   x51
....................             count_kp++; 
4344:  INCF   x52,F
4346:  BTFSC  FD8.2
4348:  INCF   x53,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
434A:  DECFSZ x4C,W
434C:  BRA    4368
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
434E:  MOVLB  6
4350:  MOVF   xE6,F
4352:  BNZ   435C
4354:  MOVLB  0
4356:  CALL   2086
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
435A:  BRA    4366
435C:  MOVLB  0
435E:  CALL   32E2
4362:  MOVFF  01,82E
4366:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
4368:  DECFSZ x4D,W
436A:  BRA    4384
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
436C:  MOVLB  6
436E:  MOVF   xE6,F
4370:  BNZ   437A
4372:  MOVLB  0
4374:  CALL   2086
....................          else temp=kbd_getc_slv(); 
4378:  BRA    4384
437A:  MOVLB  0
437C:  CALL   32E2
4380:  MOVFF  01,82E
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
4384:  MOVLB  6
4386:  MOVF   xCB,F
4388:  BNZ   43A8
438A:  MOVF   xCA,F
438C:  BNZ   43A8
438E:  MOVF   xC9,F
4390:  BNZ   43A8
4392:  MOVF   xC8,W
4394:  SUBLW  04
4396:  BNC   43A8
4398:  MOVLW  01
439A:  ADDWF  xC8,F
439C:  BTFSC  FD8.0
439E:  INCF   xC9,F
43A0:  BTFSC  FD8.2
43A2:  INCF   xCA,F
43A4:  BTFSC  FD8.2
43A6:  INCF   xCB,F
....................   if(mcr_timeout==5) 
43A8:  MOVF   xC8,W
43AA:  SUBLW  05
43AC:  BNZ   4402
43AE:  MOVF   xC9,F
43B0:  BNZ   4402
43B2:  MOVF   xCA,F
43B4:  BNZ   4402
43B6:  MOVF   xCB,F
43B8:  BNZ   4402
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
43BA:  DECFSZ xDE,W
43BC:  BRA    43C4
43BE:  MOVLB  0
43C0:  BRA    3C32
43C2:  MOVLB  6
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
43C4:  MOVLW  02
43C6:  MOVWF  FEA
43C8:  MOVLW  4A
43CA:  MOVWF  FE9
43CC:  CLRF   00
43CE:  MOVLW  03
43D0:  MOVWF  02
43D2:  MOVLW  52
43D4:  MOVWF  01
43D6:  MOVLB  0
43D8:  RCALL  403A
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
43DA:  MOVLW  05
43DC:  MOVWF  FEA
43DE:  MOVLW  9C
43E0:  MOVWF  FE9
43E2:  CLRF   00
43E4:  MOVLW  01
43E6:  MOVWF  02
43E8:  MOVLW  2C
43EA:  MOVWF  01
43EC:  RCALL  403A
....................       //debug_card(); 
....................       count_reading_error=0; 
43EE:  MOVLB  6
43F0:  CLRF   xDF
....................       mcr_timeout++;   
43F2:  MOVLW  01
43F4:  ADDWF  xC8,F
43F6:  BTFSC  FD8.0
43F8:  INCF   xC9,F
43FA:  BTFSC  FD8.2
43FC:  INCF   xCA,F
43FE:  BTFSC  FD8.2
4400:  INCF   xCB,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
4402:  MOVLB  8
4404:  CLRF   x3B
4406:  CLRF   x3A
4408:  CLRF   x39
440A:  MOVLW  94
440C:  MOVWF  x38
440E:  MOVLB  0
4410:  CALL   3556
4414:  MOVFF  01,161
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
4418:  MOVLW  02
441A:  MOVLB  8
441C:  MOVWF  x35
441E:  MOVLW  BC
4420:  MOVWF  x34
4422:  CLRF   x37
4424:  MOVFF  161,836
4428:  MOVLB  0
442A:  CALL   367A
442E:  MOVFF  02,03
4432:  MOVF   xFC,W
4434:  SUBWF  02,W
4436:  BNC   4446
4438:  BNZ   4440
443A:  MOVF   01,W
443C:  SUBWF  xFB,W
443E:  BC    4446
4440:  INCF   xFB,F
4442:  BTFSC  FD8.2
4444:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
4446:  MOVLW  02
4448:  MOVLB  8
444A:  MOVWF  x35
444C:  MOVLW  BC
444E:  MOVWF  x34
4450:  CLRF   x37
4452:  MOVFF  161,836
4456:  MOVLB  0
4458:  CALL   367A
445C:  MOVFF  02,03
4460:  MOVF   01,W
4462:  SUBWF  xFB,W
4464:  BNZ   450C
4466:  MOVF   03,W
4468:  SUBWF  xFC,W
446A:  BNZ   450C
....................   { 
....................       charac_timeout++; 
446C:  INCF   xFB,F
446E:  BTFSC  FD8.2
4470:  INCF   xFC,F
....................       buf=get_countcard(); 
4472:  CALL   3622
4476:  MOVFF  02,82D
447A:  MOVFF  01,82C
....................       if(buf<countcards) 
447E:  MOVLB  8
4480:  MOVF   x2D,W
4482:  SUBLW  03
4484:  BNC   44AC
4486:  BNZ   448E
4488:  MOVF   x2C,W
448A:  SUBLW  A1
448C:  BNC   44AC
....................       { 
....................          save_key_new(); 
448E:  MOVLB  0
4490:  BRA    4054
....................          buf=buf+1; 
4492:  MOVLW  01
4494:  MOVLB  8
4496:  ADDWF  x2C,F
4498:  MOVLW  00
449A:  ADDWFC x2D,F
....................          save_coutcard(buf); 
449C:  MOVFF  82D,830
44A0:  MOVFF  82C,82F
44A4:  MOVLB  0
44A6:  RCALL  41D2
....................       } 
....................          else 
44A8:  BRA    44BC
44AA:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
44AC:  MOVLW  22
44AE:  MOVWF  FF6
44B0:  MOVLW  45
44B2:  MOVWF  FF7
44B4:  MOVLB  0
44B6:  CALL   06E2
....................             return; 
44BA:  BRA    450C
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
44BC:  MOVLW  32
44BE:  MOVWF  FF6
44C0:  MOVLW  45
44C2:  MOVWF  FF7
44C4:  CALL   06E2
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
44C8:  MOVLW  42
44CA:  MOVWF  FF6
44CC:  MOVLW  45
44CE:  MOVWF  FF7
44D0:  MOVLW  14
44D2:  MOVLB  8
44D4:  MOVWF  x4C
44D6:  MOVLB  0
44D8:  CALL   165A
44DC:  MOVLW  10
44DE:  MOVWF  FE9
44E0:  MOVFF  82D,830
44E4:  MOVFF  82C,82F
44E8:  RCALL  4214
44EA:  MOVLW  59
44EC:  MOVWF  FF6
44EE:  MOVLW  45
44F0:  MOVWF  FF7
44F2:  MOVLW  03
44F4:  MOVLB  8
44F6:  MOVWF  x4C
44F8:  MOVLB  0
44FA:  CALL   165A
....................       data_avai=0; 
44FE:  MOVLB  6
4500:  CLRF   xDD
....................       enable_getpin=0; 
4502:  MOVLB  1
4504:  CLRF   x4D
....................       //dis_getpin; 
....................       output_low(LED); 
4506:  BCF    F92.6
4508:  BCF    F89.6
450A:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
450C:  BCF    FF2.2
450E:  GOTO   006C
.................... void main() 
.................... {  
*
79DA:  CLRF   FF8
79DC:  BCF    FD0.7
79DE:  BSF    07.7
79E0:  CLRF   FEA
79E2:  CLRF   FE9
79E4:  BCF    F94.0
79E6:  BSF    F8B.0
79E8:  CLRF   23
79EA:  CLRF   22
79EC:  CLRF   21
79EE:  MOVLW  96
79F0:  MOVWF  20
79F2:  CLRF   27
79F4:  MOVLW  01
79F6:  MOVWF  26
79F8:  MOVLW  C3
79FA:  MOVWF  25
79FC:  MOVLW  0F
79FE:  MOVWF  24
7A00:  CLRF   xFA
7A02:  CLRF   xF9
7A04:  SETF   xFC
7A06:  SETF   xFB
7A08:  MOVLW  0E
7A0A:  MOVWF  xFE
7A0C:  MOVLW  01
7A0E:  MOVWF  xFF
7A10:  MOVLB  1
7A12:  MOVWF  x00
7A14:  CLRF   x01
7A16:  CLRF   x02
7A18:  CLRF   x03
7A1A:  CLRF   x04
7A1C:  CLRF   x05
7A1E:  CLRF   x07
7A20:  MOVLW  0A
7A22:  MOVWF  x06
7A24:  MOVLW  03
7A26:  MOVWF  x4A
7A28:  MOVLW  E8
7A2A:  MOVWF  x49
7A2C:  CLRF   x4B
7A2E:  CLRF   x4C
7A30:  CLRF   x4D
7A32:  MOVLW  64
7A34:  MOVWF  x4E
7A36:  CLRF   x4F
7A38:  CLRF   x50
7A3A:  CLRF   x51
7A3C:  CLRF   x53
7A3E:  CLRF   x52
7A40:  CLRF   x54
7A42:  CLRF   x61
7A44:  CLRF   x66
7A46:  CLRF   xCD
7A48:  CLRF   xCE
7A4A:  CLRF   xCF
7A4C:  CLRF   xD0
7A4E:  CLRF   xD2
7A50:  CLRF   xD1
7A52:  MOVLB  6
7A54:  CLRF   xCB
7A56:  CLRF   xCA
7A58:  CLRF   xC9
7A5A:  CLRF   xC8
7A5C:  CLRF   xCC
7A5E:  CLRF   xCE
7A60:  CLRF   xCD
7A62:  CLRF   xD0
7A64:  CLRF   xCF
7A66:  CLRF   xD2
7A68:  CLRF   xD1
7A6A:  CLRF   xD4
7A6C:  CLRF   xD3
7A6E:  MOVLW  FD
7A70:  MOVWF  xD6
7A72:  MOVLW  E8
7A74:  MOVWF  xD5
7A76:  CLRF   xD8
7A78:  CLRF   xD7
7A7A:  CLRF   xD9
7A7C:  CLRF   xDA
7A7E:  CLRF   xDB
7A80:  CLRF   xDC
7A82:  CLRF   xDD
7A84:  CLRF   xDE
7A86:  CLRF   xDF
7A88:  CLRF   xE0
7A8A:  CLRF   xE1
7A8C:  CLRF   xE3
7A8E:  MOVLW  01
7A90:  MOVWF  xE2
7A92:  CLRF   xE5
7A94:  CLRF   xE4
7A96:  CLRF   xE6
7A98:  CLRF   xEA
7A9A:  CLRF   xE9
7A9C:  CLRF   xE8
7A9E:  CLRF   xE7
7AA0:  MOVLW  FF
7AA2:  MOVLB  F
7AA4:  MOVWF  x48
7AA6:  BCF    FC2.6
7AA8:  BCF    FC2.7
7AAA:  MOVF   x49,W
7AAC:  ANDLW  E0
7AAE:  IORLW  1F
7AB0:  MOVWF  x49
7AB2:  CLRF   FD2
7AB4:  CLRF   FD1
7AB6:  CLRF   1A
7AB8:  CLRF   1B
7ABA:  MOVLW  E8
7ABC:  MOVLB  1
7ABE:  MOVWF  x29
7AC0:  MOVLW  E9
7AC2:  MOVWF  x2A
7AC4:  MOVLW  EA
7AC6:  MOVWF  x2B
7AC8:  MOVLW  EB
7ACA:  MOVWF  x2C
7ACC:  MOVLW  ED
7ACE:  MOVWF  x2D
7AD0:  MOVLW  EE
7AD2:  MOVWF  x2E
7AD4:  MOVLW  EF
7AD6:  MOVWF  x2F
7AD8:  MOVLW  F0
7ADA:  MOVWF  x30
7ADC:  MOVLW  F2
7ADE:  MOVWF  x31
7AE0:  MOVLW  F3
7AE2:  MOVWF  x32
7AE4:  MOVLW  F4
7AE6:  MOVWF  x33
7AE8:  MOVLW  F5
7AEA:  MOVWF  x34
7AEC:  MOVLW  F7
7AEE:  MOVWF  x35
7AF0:  MOVLW  F8
7AF2:  MOVWF  x36
7AF4:  MOVLW  F9
7AF6:  MOVWF  x37
7AF8:  MOVLW  FA
7AFA:  MOVWF  x38
7AFC:  MOVLW  67
7AFE:  MOVWF  x39
7B00:  MOVLW  43
7B02:  MOVWF  x3A
7B04:  MOVLW  C3
7B06:  MOVWF  x3B
7B08:  MOVLW  D1
7B0A:  MOVWF  x3C
7B0C:  MOVLW  51
7B0E:  MOVWF  x3D
7B10:  MOVLW  9A
7B12:  MOVWF  x3E
7B14:  MOVLW  B4
7B16:  MOVWF  x3F
7B18:  MOVLW  F2
7B1A:  MOVWF  x40
7B1C:  MOVLW  CD
7B1E:  MOVWF  x41
7B20:  MOVLW  9A
7B22:  MOVWF  x42
7B24:  MOVLW  78
7B26:  MOVWF  x43
7B28:  MOVLW  AB
7B2A:  MOVWF  x44
7B2C:  MOVLW  09
7B2E:  MOVWF  x45
7B30:  MOVLW  A5
7B32:  MOVWF  x46
7B34:  MOVLW  11
7B36:  MOVWF  x47
7B38:  MOVLW  BD
7B3A:  MOVWF  x48
7B3C:  CLRF   x62
7B3E:  BCF    x63.0
7B40:  CLRF   x64
7B42:  CLRF   x65
7B44:  CLRF   x67
7B46:  BCF    x63.1
7B48:  CLRF   x68
7B4A:  MOVLB  6
7B4C:  CLRF   xFB
7B4E:  CLRF   xFC
7B50:  CLRF   xFD
7B52:  CLRF   xFE
7B54:  CLRF   xFF
7B56:  MOVLB  7
7B58:  CLRF   x00
7B5A:  CLRF   x01
7B5C:  CLRF   x02
7B5E:  CLRF   x03
7B60:  CLRF   x04
7B62:  CLRF   x07
7B64:  CLRF   x09
7B66:  CLRF   x08
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................     RPINR1=5; 
7B68:  MOVLW  05
7B6A:  MOVLB  E
7B6C:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
7B6E:  MOVLB  0
7B70:  SETF   xFC
7B72:  SETF   xFB
....................    key_timeout=0xffff; 
7B74:  MOVLB  1
7B76:  SETF   x4A
7B78:  SETF   x49
....................    setup_oscillator(OSC_32MHZ); 
7B7A:  MOVLW  70
7B7C:  MOVWF  FD3
7B7E:  MOVLW  40
7B80:  MOVWF  F9B
7B82:  MOVF   FD3,W
....................    keyprss_off; 
7B84:  BCF    F92.7
7B86:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
7B88:  BCF    FF2.6
7B8A:  BCF    FF2.7
7B8C:  BTFSC  FF2.7
7B8E:  BRA    7B8A
....................    init_ext_eeprom(); 
7B90:  MOVLB  0
7B92:  GOTO   4630
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
7B96:  MOVLW  04
7B98:  MOVLB  7
7B9A:  MOVWF  xC1
7B9C:  CLRF   19
7B9E:  BTFSC  FF2.7
7BA0:  BSF    19.7
7BA2:  BCF    FF2.7
7BA4:  MOVLW  FA
7BA6:  MOVLB  8
7BA8:  MOVWF  x35
7BAA:  MOVLB  0
7BAC:  CALL   18C6
7BB0:  BTFSC  19.7
7BB2:  BSF    FF2.7
7BB4:  MOVLB  7
7BB6:  DECFSZ xC1,F
7BB8:  BRA    7B9C
....................    init_password(); 
7BBA:  MOVLB  0
7BBC:  CALL   479E
7BC0:  CLRF   19
7BC2:  BTFSC  FF2.7
7BC4:  BSF    19.7
7BC6:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
7BC8:  MOVLB  8
7BCA:  CLRF   x3B
7BCC:  CLRF   x3A
7BCE:  CLRF   x39
7BD0:  MOVLW  7F
7BD2:  MOVWF  x38
7BD4:  MOVLB  0
7BD6:  CALL   3556
7BDA:  BTFSC  19.7
7BDC:  BSF    FF2.7
7BDE:  MOVFF  01,150
....................    //===================================== 
....................    rtc_init(); 
7BE2:  GOTO   4906
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
7BE6:  MOVLW  19
7BE8:  MOVLB  7
7BEA:  MOVWF  xC1
7BEC:  MOVLB  0
7BEE:  CALL   4A10
7BF2:  MOVFF  03,23
7BF6:  MOVFF  02,22
7BFA:  MOVFF  01,21
7BFE:  MOVFF  00,20
....................    printf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
7C02:  CLRF   FEA
7C04:  MOVLW  01
7C06:  MOVWF  FE9
7C08:  CALL   4B66
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
7C0C:  MOVLW  1E
7C0E:  MOVLB  7
7C10:  MOVWF  xC1
7C12:  MOVLB  0
7C14:  CALL   4A10
7C18:  MOVFF  03,27
7C1C:  MOVFF  02,26
7C20:  MOVFF  01,25
7C24:  MOVFF  00,24
....................    fprintf(COM2,"booting\n\r"); 
7C28:  MOVLW  5E
7C2A:  MOVWF  FF6
7C2C:  MOVLW  45
7C2E:  MOVWF  FF7
7C30:  CLRF   19
7C32:  BTFSC  FF2.7
7C34:  BSF    19.7
7C36:  BCF    FF2.7
7C38:  CALL   06E2
7C3C:  BTFSC  19.7
7C3E:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
7C40:  MOVLW  68
7C42:  MOVWF  FF6
7C44:  MOVLW  45
7C46:  MOVWF  FF7
7C48:  CLRF   19
7C4A:  BTFSC  FF2.7
7C4C:  BSF    19.7
7C4E:  BCF    FF2.7
7C50:  MOVLW  12
7C52:  MOVLB  8
7C54:  MOVWF  x4C
7C56:  MOVLB  0
7C58:  CALL   165A
7C5C:  BTFSC  19.7
7C5E:  BSF    FF2.7
7C60:  MOVLW  41
7C62:  MOVWF  FE9
7C64:  CLRF   19
7C66:  BTFSC  FF2.7
7C68:  BSF    19.7
7C6A:  BCF    FF2.7
7C6C:  MOVFF  27,84F
7C70:  MOVFF  26,84E
7C74:  MOVFF  25,84D
7C78:  MOVFF  24,84C
7C7C:  CALL   2406
7C80:  BTFSC  19.7
7C82:  BSF    FF2.7
7C84:  CLRF   19
7C86:  BTFSC  FF2.7
7C88:  BSF    19.7
7C8A:  BCF    FF2.7
7C8C:  MOVLW  0A
7C8E:  MOVLB  8
7C90:  MOVWF  x58
7C92:  MOVLB  0
7C94:  CALL   069C
7C98:  BTFSC  19.7
7C9A:  BSF    FF2.7
7C9C:  CLRF   19
7C9E:  BTFSC  FF2.7
7CA0:  BSF    19.7
7CA2:  BCF    FF2.7
7CA4:  MOVLW  0D
7CA6:  MOVLB  8
7CA8:  MOVWF  x58
7CAA:  MOVLB  0
7CAC:  CALL   069C
7CB0:  BTFSC  19.7
7CB2:  BSF    FF2.7
7CB4:  CLRF   19
7CB6:  BTFSC  FF2.7
7CB8:  BSF    19.7
7CBA:  BCF    FF2.7
....................    countcard=get_countcard(); 
7CBC:  CALL   3622
7CC0:  BTFSC  19.7
7CC2:  BSF    FF2.7
7CC4:  MOVFF  02,FA
7CC8:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
7CCC:  SETF   xFC
7CCE:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
7CD0:  MOVLW  C7
7CD2:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
7CD4:  MOVLW  37
7CD6:  MOVWF  FCD
7CD8:  CLRF   F9A
7CDA:  CLRF   19
7CDC:  BTFSC  FF2.7
7CDE:  BSF    19.7
7CE0:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
7CE2:  MOVLB  8
7CE4:  CLRF   x3B
7CE6:  CLRF   x3A
7CE8:  CLRF   x39
7CEA:  MOVLW  94
7CEC:  MOVWF  x38
7CEE:  MOVLB  0
7CF0:  CALL   3556
7CF4:  BTFSC  19.7
7CF6:  BSF    FF2.7
7CF8:  MOVFF  01,161
....................    if(delaycharaction==0)delaycharaction=1; 
7CFC:  MOVLB  1
7CFE:  MOVF   x61,F
7D00:  BNZ   7D06
7D02:  MOVLW  01
7D04:  MOVWF  x61
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
7D06:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
7D08:  BSF    FF0.3
7D0A:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
7D0C:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
7D0E:  MOVLW  C0
7D10:  IORWF  FF2,F
....................   
....................    mcr_timeout=10000; 
7D12:  MOVLB  6
7D14:  CLRF   xCB
7D16:  CLRF   xCA
7D18:  MOVLW  27
7D1A:  MOVWF  xC9
7D1C:  MOVLW  10
7D1E:  MOVWF  xC8
7D20:  CLRF   19
7D22:  BTFSC  FF2.7
7D24:  BSF    19.7
7D26:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
7D28:  MOVLB  8
7D2A:  CLRF   x3B
7D2C:  CLRF   x3A
7D2E:  CLRF   x39
7D30:  MOVLW  91
7D32:  MOVWF  x38
7D34:  MOVLB  0
7D36:  CALL   3556
7D3A:  BTFSC  19.7
7D3C:  BSF    FF2.7
7D3E:  MOVFF  01,6E6
7D42:  CLRF   19
7D44:  BTFSC  FF2.7
7D46:  BSF    19.7
7D48:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
7D4A:  MOVLB  8
7D4C:  CLRF   x3B
7D4E:  CLRF   x3A
7D50:  CLRF   x39
7D52:  MOVLW  92
7D54:  MOVWF  x38
7D56:  MOVLB  0
7D58:  CALL   3556
7D5C:  BTFSC  19.7
7D5E:  BSF    FF2.7
7D60:  MOVFF  01,6DA
....................     key_timeout=1000; 
7D64:  MOVLW  03
7D66:  MOVLB  1
7D68:  MOVWF  x4A
7D6A:  MOVLW  E8
7D6C:  MOVWF  x49
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
7D6E:  MOVLB  0
7D70:  SETF   xFC
7D72:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    booting_done=1; 
7D74:  MOVLW  01
7D76:  MOVLB  1
7D78:  MOVWF  xD0
....................    booting=1; 
7D7A:  MOVWF  x05
....................    charac_timeout=0xffffffff; 
7D7C:  MOVLB  0
7D7E:  SETF   xFC
7D80:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
7D82:  MOVLB  7
7D84:  CLRF   xFA
7D86:  CLRF   xF9
7D88:  CLRF   xF8
7D8A:  MOVLW  66
7D8C:  MOVWF  xF7
7D8E:  CLRF   xFE
7D90:  CLRF   xFD
7D92:  CLRF   xFC
7D94:  MOVLW  10
7D96:  MOVWF  xFB
7D98:  MOVLW  06
7D9A:  MOVLB  8
7D9C:  MOVWF  x00
7D9E:  MOVLW  EB
7DA0:  MOVLB  7
7DA2:  MOVWF  xFF
7DA4:  MOVLB  0
7DA6:  CALL   463A
....................    set_tris_a(0xff);  
7DAA:  MOVLW  FF
7DAC:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
7DAE:  MOVLW  E0
7DB0:  MOVLB  F
7DB2:  MOVWF  x48
7DB4:  BCF    FC2.6
7DB6:  BCF    FC2.7
7DB8:  MOVF   x49,W
7DBA:  ANDLW  E0
7DBC:  IORLW  1F
7DBE:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
7DC0:  MOVF   FC1,W
7DC2:  ANDLW  C0
7DC4:  IORLW  03
7DC6:  MOVWF  FC1
7DC8:  BCF    FC1.7
7DCA:  BSF    FC2.0
7DCC:  BSF    FC1.6
7DCE:  BSF    FC2.1
7DD0:  BTFSC  FC2.1
7DD2:  BRA    7DD0
7DD4:  BCF    FC1.6
7DD6:  CLRF   19
7DD8:  BTFSC  FF2.7
7DDA:  BSF    19.7
7DDC:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
7DDE:  MOVLB  8
7DE0:  CLRF   x3B
7DE2:  CLRF   x3A
7DE4:  CLRF   x39
7DE6:  MOVLW  7F
7DE8:  MOVWF  x38
7DEA:  MOVLB  0
7DEC:  CALL   3556
7DF0:  BTFSC  19.7
7DF2:  BSF    FF2.7
7DF4:  MOVFF  01,150
7DF8:  CLRF   19
7DFA:  BTFSC  FF2.7
7DFC:  BSF    19.7
7DFE:  BCF    FF2.7
....................    type_KB=read_ext_eeprom(kindofKB); 
7E00:  MOVLB  8
7E02:  CLRF   x3B
7E04:  CLRF   x3A
7E06:  CLRF   x39
7E08:  MOVLW  7E
7E0A:  MOVWF  x38
7E0C:  MOVLB  0
7E0E:  CALL   3556
7E12:  BTFSC  19.7
7E14:  BSF    FF2.7
7E16:  MOVFF  01,154
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
7E1A:  MOVLB  1
7E1C:  MOVF   x54,F
7E1E:  BZ    7E3E
7E20:  MOVLW  80
7E22:  MOVWF  FF6
7E24:  MOVLW  45
7E26:  MOVWF  FF7
7E28:  CLRF   19
7E2A:  BTFSC  FF2.7
7E2C:  BSF    19.7
7E2E:  BCF    FF2.7
7E30:  MOVLB  0
7E32:  CALL   06E2
7E36:  BTFSC  19.7
7E38:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
7E3A:  BRA    7E58
7E3C:  MOVLB  1
7E3E:  MOVLW  94
7E40:  MOVWF  FF6
7E42:  MOVLW  45
7E44:  MOVWF  FF7
7E46:  CLRF   19
7E48:  BTFSC  FF2.7
7E4A:  BSF    19.7
7E4C:  BCF    FF2.7
7E4E:  MOVLB  0
7E50:  CALL   06E2
7E54:  BTFSC  19.7
7E56:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
7E58:  MOVLB  6
7E5A:  MOVF   xE6,F
7E5C:  BNZ   7E7C
7E5E:  MOVLW  A8
7E60:  MOVWF  FF6
7E62:  MOVLW  45
7E64:  MOVWF  FF7
7E66:  CLRF   19
7E68:  BTFSC  FF2.7
7E6A:  BSF    19.7
7E6C:  BCF    FF2.7
7E6E:  MOVLB  0
7E70:  CALL   06E2
7E74:  BTFSC  19.7
7E76:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
7E78:  BRA    7E96
7E7A:  MOVLB  6
7E7C:  MOVLW  C2
7E7E:  MOVWF  FF6
7E80:  MOVLW  45
7E82:  MOVWF  FF7
7E84:  CLRF   19
7E86:  BTFSC  FF2.7
7E88:  BSF    19.7
7E8A:  BCF    FF2.7
7E8C:  MOVLB  0
7E8E:  CALL   06E2
7E92:  BTFSC  19.7
7E94:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
7E96:  MOVLW  01
7E98:  MOVWF  FEA
7E9A:  MOVLW  55
7E9C:  MOVWF  FE9
7E9E:  CLRF   00
7EA0:  CLRF   02
7EA2:  MOVLW  0C
7EA4:  MOVWF  01
7EA6:  CALL   403A
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
7EAA:  MOVLB  7
7EAC:  CLRF   x05
7EAE:  MOVF   x05,W
7EB0:  SUBLW  13
7EB2:  BNC   7EC8
....................    { 
....................       password[i] = 0; 
7EB4:  CLRF   03
7EB6:  MOVF   x05,W
7EB8:  ADDLW  55
7EBA:  MOVWF  FE9
7EBC:  MOVLW  00
7EBE:  ADDWFC 03,W
7EC0:  MOVWF  FEA
7EC2:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 1 
7EC4:  INCF   x05,F
7EC6:  BRA    7EAE
....................    disable_interrupts(GLOBAL); 
7EC8:  BCF    FF2.6
7ECA:  BCF    FF2.7
7ECC:  BTFSC  FF2.7
7ECE:  BRA    7ECA
7ED0:  CLRF   19
7ED2:  BTFSC  FF2.7
7ED4:  BSF    19.7
7ED6:  BCF    FF2.7
....................    save_coutcard(0); 
7ED8:  MOVLB  8
7EDA:  CLRF   x30
7EDC:  CLRF   x2F
7EDE:  MOVLB  0
7EE0:  CALL   41D2
7EE4:  BTFSC  19.7
7EE6:  BSF    FF2.7
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
7EE8:  MOVLW  01
7EEA:  MOVWF  FEA
7EEC:  MOVLW  55
7EEE:  MOVWF  FE9
7EF0:  MOVLW  00
7EF2:  CALL   04B8
7EF6:  TBLRD*-
7EF8:  TBLRD*+
7EFA:  MOVF   FF5,W
7EFC:  MOVWF  FEE
7EFE:  IORLW  00
7F00:  BNZ   7EF8
....................    strcpy(crypto_key,"0123456789ABCDEF"); 
7F02:  MOVLW  01
7F04:  MOVWF  FEA
7F06:  MOVLW  08
7F08:  MOVWF  FE9
7F0A:  MOVLW  00
7F0C:  CALL   04D0
7F10:  TBLRD*-
7F12:  TBLRD*+
7F14:  MOVF   FF5,W
7F16:  MOVWF  FEE
7F18:  IORLW  00
7F1A:  BNZ   7F12
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    save_key_encrypt(); 
7F1C:  GOTO   4BFA
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
7F20:  MOVLB  7
7F22:  CLRF   xFA
7F24:  MOVLW  01
7F26:  MOVWF  xF9
7F28:  MOVLW  C3
7F2A:  MOVWF  xF8
7F2C:  MOVLW  0F
7F2E:  MOVWF  xF7
7F30:  CLRF   xFE
7F32:  CLRF   xFD
7F34:  CLRF   xFC
7F36:  MOVLW  10
7F38:  MOVWF  xFB
7F3A:  MOVLW  07
7F3C:  MOVLB  8
7F3E:  MOVWF  x00
7F40:  MOVLW  8F
7F42:  MOVLB  7
7F44:  MOVWF  xFF
7F46:  MOVLB  0
7F48:  CALL   463A
....................     
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
7F4C:  MOVLW  0C
7F4E:  MOVLB  7
7F50:  MOVWF  xC1
7F52:  CLRF   19
7F54:  BTFSC  FF2.7
7F56:  BSF    19.7
7F58:  BCF    FF2.7
7F5A:  MOVLW  FA
7F5C:  MOVLB  8
7F5E:  MOVWF  x35
7F60:  MOVLB  0
7F62:  CALL   18C6
7F66:  BTFSC  19.7
7F68:  BSF    FF2.7
7F6A:  MOVLB  7
7F6C:  DECFSZ xC1,F
7F6E:  BRA    7F52
7F70:  CLRF   19
7F72:  BTFSC  FF2.7
7F74:  BSF    19.7
7F76:  BCF    FF2.7
....................    fprintf(COM2,"\n\r"); 
7F78:  MOVLW  0A
7F7A:  MOVLB  8
7F7C:  MOVWF  x58
7F7E:  MOVLB  0
7F80:  CALL   069C
7F84:  BTFSC  19.7
7F86:  BSF    FF2.7
7F88:  CLRF   19
7F8A:  BTFSC  FF2.7
7F8C:  BSF    19.7
7F8E:  BCF    FF2.7
7F90:  MOVLW  0D
7F92:  MOVLB  8
7F94:  MOVWF  x58
7F96:  MOVLB  0
7F98:  CALL   069C
7F9C:  BTFSC  19.7
7F9E:  BSF    FF2.7
....................    fprintf(COM2,"test_data in:\n\r"); 
7FA0:  MOVLW  DA
7FA2:  MOVWF  FF6
7FA4:  MOVLW  45
7FA6:  MOVWF  FF7
7FA8:  CLRF   19
7FAA:  BTFSC  FF2.7
7FAC:  BSF    19.7
7FAE:  BCF    FF2.7
7FB0:  CALL   06E2
7FB4:  BTFSC  19.7
7FB6:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",test_data[i]); 
7FB8:  MOVLB  7
7FBA:  CLRF   x05
7FBC:  MOVF   x05,W
7FBE:  SUBLW  0F
7FC0:  BNC   7FE8
7FC2:  CLRF   03
7FC4:  MOVF   x05,W
7FC6:  ADDLW  39
7FC8:  MOVWF  FE9
7FCA:  MOVLW  01
7FCC:  ADDWFC 03,W
7FCE:  MOVWF  FEA
7FD0:  MOVFF  FEF,7C1
7FD4:  MOVFF  7C1,7D6
7FD8:  MOVLW  57
7FDA:  MOVWF  xD7
7FDC:  MOVLB  0
7FDE:  CALL   4B98
7FE2:  MOVLB  7
7FE4:  INCF   x05,F
7FE6:  BRA    7FBC
7FE8:  CLRF   19
7FEA:  BTFSC  FF2.7
7FEC:  BSF    19.7
7FEE:  BCF    FF2.7
....................    fprintf(COM2,"\n\r"); 
7FF0:  MOVLW  0A
7FF2:  MOVLB  8
7FF4:  MOVWF  x58
7FF6:  MOVLB  0
7FF8:  CALL   069C
7FFC:  BTFSC  19.7
7FFE:  BSF    FF2.7
8000:  CLRF   19
8002:  BTFSC  FF2.7
8004:  BSF    19.7
8006:  BCF    FF2.7
8008:  MOVLW  0D
800A:  MOVLB  8
800C:  MOVWF  x58
800E:  MOVLB  0
8010:  CALL   069C
8014:  BTFSC  19.7
8016:  BSF    FF2.7
....................    fprintf(COM2,"test_key in:\n\r"); 
8018:  MOVLW  EA
801A:  MOVWF  FF6
801C:  MOVLW  45
801E:  MOVWF  FF7
8020:  CLRF   19
8022:  BTFSC  FF2.7
8024:  BSF    19.7
8026:  BCF    FF2.7
8028:  CALL   06E2
802C:  BTFSC  19.7
802E:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
8030:  MOVLB  7
8032:  CLRF   x05
8034:  MOVF   x05,W
8036:  SUBLW  0F
8038:  BNC   8060
803A:  CLRF   03
803C:  MOVF   x05,W
803E:  ADDLW  29
8040:  MOVWF  FE9
8042:  MOVLW  01
8044:  ADDWFC 03,W
8046:  MOVWF  FEA
8048:  MOVFF  FEF,7C1
804C:  MOVFF  7C1,7D6
8050:  MOVLW  57
8052:  MOVWF  xD7
8054:  MOVLB  0
8056:  CALL   4B98
805A:  MOVLB  7
805C:  INCF   x05,F
805E:  BRA    8034
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    //aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],0); 
....................    aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
8060:  MOVLW  01
8062:  MOVWF  xC2
8064:  MOVLW  39
8066:  MOVWF  xC1
8068:  MOVLW  01
806A:  MOVWF  xC4
806C:  MOVLW  29
806E:  MOVWF  xC3
8070:  MOVLW  01
8072:  MOVWF  xC5
8074:  MOVLB  0
8076:  GOTO   4E58
807A:  CLRF   19
807C:  BTFSC  FF2.7
807E:  BSF    19.7
8080:  BCF    FF2.7
....................    fprintf(COM2,"\n\r"); 
8082:  MOVLW  0A
8084:  MOVLB  8
8086:  MOVWF  x58
8088:  MOVLB  0
808A:  CALL   069C
808E:  BTFSC  19.7
8090:  BSF    FF2.7
8092:  CLRF   19
8094:  BTFSC  FF2.7
8096:  BSF    19.7
8098:  BCF    FF2.7
809A:  MOVLW  0D
809C:  MOVLB  8
809E:  MOVWF  x58
80A0:  MOVLB  0
80A2:  CALL   069C
80A6:  BTFSC  19.7
80A8:  BSF    FF2.7
....................     fprintf(COM2,"\n\rdecrypted:\n\r"); 
80AA:  MOVLW  FA
80AC:  MOVWF  FF6
80AE:  MOVLW  45
80B0:  MOVWF  FF7
80B2:  CLRF   19
80B4:  BTFSC  FF2.7
80B6:  BSF    19.7
80B8:  BCF    FF2.7
80BA:  CALL   06E2
80BE:  BTFSC  19.7
80C0:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",test_data[i]); 
80C2:  MOVLB  7
80C4:  CLRF   x05
80C6:  MOVF   x05,W
80C8:  SUBLW  0F
80CA:  BNC   80F2
80CC:  CLRF   03
80CE:  MOVF   x05,W
80D0:  ADDLW  39
80D2:  MOVWF  FE9
80D4:  MOVLW  01
80D6:  ADDWFC 03,W
80D8:  MOVWF  FEA
80DA:  MOVFF  FEF,7C1
80DE:  MOVFF  7C1,7D6
80E2:  MOVLW  57
80E4:  MOVWF  xD7
80E6:  MOVLB  0
80E8:  CALL   4B98
80EC:  MOVLB  7
80EE:  INCF   x05,F
80F0:  BRA    80C6
80F2:  CLRF   19
80F4:  BTFSC  FF2.7
80F6:  BSF    19.7
80F8:  BCF    FF2.7
....................    fprintf(COM2,"\n\r"); 
80FA:  MOVLW  0A
80FC:  MOVLB  8
80FE:  MOVWF  x58
8100:  MOVLB  0
8102:  CALL   069C
8106:  BTFSC  19.7
8108:  BSF    FF2.7
810A:  CLRF   19
810C:  BTFSC  FF2.7
810E:  BSF    19.7
8110:  BCF    FF2.7
8112:  MOVLW  0D
8114:  MOVLB  8
8116:  MOVWF  x58
8118:  MOVLB  0
811A:  CALL   069C
811E:  BTFSC  19.7
8120:  BSF    FF2.7
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
8122:  MOVLW  0A
8124:  MOVWF  FF6
8126:  MOVLW  46
8128:  MOVWF  FF7
812A:  CLRF   19
812C:  BTFSC  FF2.7
812E:  BSF    19.7
8130:  BCF    FF2.7
8132:  CALL   06E2
8136:  BTFSC  19.7
8138:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
813A:  MOVLB  7
813C:  CLRF   x05
813E:  MOVF   x05,W
8140:  SUBLW  0F
8142:  BNC   816A
8144:  CLRF   03
8146:  MOVF   x05,W
8148:  ADDLW  29
814A:  MOVWF  FE9
814C:  MOVLW  01
814E:  ADDWFC 03,W
8150:  MOVWF  FEA
8152:  MOVFF  FEF,7C1
8156:  MOVFF  7C1,7D6
815A:  MOVLW  57
815C:  MOVWF  xD7
815E:  MOVLB  0
8160:  CALL   4B98
8164:  MOVLB  7
8166:  INCF   x05,F
8168:  BRA    813E
....................    while(1); 
816A:  BRA    816A
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
816C:  CLRF   xFA
816E:  CLRF   xF9
8170:  CLRF   xF8
8172:  CLRF   xF7
8174:  CLRF   xFE
8176:  CLRF   xFD
8178:  CLRF   xFC
817A:  MOVLW  14
817C:  MOVWF  xFB
817E:  MOVLB  8
8180:  CLRF   x00
8182:  MOVLW  55
8184:  MOVLB  7
8186:  MOVWF  xFF
8188:  MOVLB  0
818A:  CALL   463A
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
818E:  MOVLB  6
8190:  MOVF   xE0,F
8192:  BNZ   8242
....................       { 
....................          fprintf(COM2,"password:"); 
8194:  MOVLW  1A
8196:  MOVWF  FF6
8198:  MOVLW  46
819A:  MOVWF  FF7
819C:  CLRF   19
819E:  BTFSC  FF2.7
81A0:  BSF    19.7
81A2:  BCF    FF2.7
81A4:  MOVLB  0
81A6:  CALL   06E2
81AA:  BTFSC  19.7
81AC:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
81AE:  MOVLW  02
81B0:  MOVLB  7
81B2:  MOVWF  xF7
81B4:  MOVLW  14
81B6:  MOVWF  xF8
81B8:  MOVLW  01
81BA:  MOVWF  xFA
81BC:  MOVLW  69
81BE:  MOVWF  xF9
81C0:  MOVLB  0
81C2:  CALL   5AFE
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
81C6:  MOVLB  7
81C8:  CLRF   xFA
81CA:  CLRF   xF9
81CC:  CLRF   xF8
81CE:  CLRF   xF7
81D0:  CLRF   xFE
81D2:  CLRF   xFD
81D4:  CLRF   xFC
81D6:  MOVLW  14
81D8:  MOVWF  xFB
81DA:  MOVLB  8
81DC:  CLRF   x00
81DE:  MOVLW  55
81E0:  MOVLB  7
81E2:  MOVWF  xFF
81E4:  MOVLB  0
81E6:  CALL   463A
....................          if(!stringcomp(buffer_uart,password)) 
81EA:  MOVLW  01
81EC:  MOVLB  7
81EE:  MOVWF  xF8
81F0:  MOVLW  69
81F2:  MOVWF  xF7
81F4:  CLRF   xFA
81F6:  MOVLW  55
81F8:  MOVWF  xF9
81FA:  MOVLB  0
81FC:  CALL   5C36
8200:  MOVF   01,F
8202:  BNZ   8226
....................          { 
....................             mode=LOGON; 
8204:  MOVLW  01
8206:  MOVLB  6
8208:  MOVWF  xE0
....................             fprintf(COM2," OK\n\r"); 
820A:  MOVLW  24
820C:  MOVWF  FF6
820E:  MOVLW  46
8210:  MOVWF  FF7
8212:  CLRF   19
8214:  BTFSC  FF2.7
8216:  BSF    19.7
8218:  BCF    FF2.7
821A:  MOVLB  0
821C:  CALL   06E2
8220:  BTFSC  19.7
8222:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
8224:  BRA    823E
8226:  MOVLW  2A
8228:  MOVWF  FF6
822A:  MOVLW  46
822C:  MOVWF  FF7
822E:  CLRF   19
8230:  BTFSC  FF2.7
8232:  BSF    19.7
8234:  BCF    FF2.7
8236:  CALL   06E2
823A:  BTFSC  19.7
823C:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
823E:  BRA    824C
8240:  MOVLB  6
8242:  DECFSZ xE0,W
8244:  BRA    824E
8246:  MOVLB  0
8248:  GOTO   63E8
824C:  MOVLB  6
....................    } 
824E:  BRA    8190
.................... } 
8250:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

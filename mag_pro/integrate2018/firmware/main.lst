CCS PCH C Compiler, Version 4.140, 33034               21-Jul-18 23:31

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   31250 bytes (48%)
                           Largest free fragment is 34274
               RAM used:   1978 (52%) at main() level
                           2145 (57%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   71F6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   4154
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1BB0
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
064A:  MOVLW  02
064C:  MOVLB  8
064E:  SUBWF  x24,F
0650:  BNC   066A
0652:  MOVLW  08
0654:  MOVWF  FEA
0656:  MOVLW  24
0658:  MOVWF  FE9
065A:  MOVF   FEF,W
065C:  BZ    066A
065E:  BRA    0666
0660:  BRA    0662
0662:  BRA    0664
0664:  NOP   
0666:  DECFSZ FEF,F
0668:  BRA    0660
066A:  MOVLB  0
066C:  GOTO   1BC0 (RETURN)
*
188A:  MOVLW  08
188C:  MOVWF  FEA
188E:  MOVLW  2C
1890:  MOVWF  FE9
1892:  MOVF   FEF,W
1894:  BZ    18B0
1896:  MOVLW  0A
1898:  MOVWF  01
189A:  CLRF   00
189C:  DECFSZ 00,F
189E:  BRA    189C
18A0:  DECFSZ 01,F
18A2:  BRA    189A
18A4:  MOVLW  5F
18A6:  MOVWF  00
18A8:  DECFSZ 00,F
18AA:  BRA    18A8
18AC:  DECFSZ FEF,F
18AE:  BRA    1896
18B0:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
15C8:  BCF    F94.0
15CA:  BCF    F8B.0
15CC:  MOVLW  08
15CE:  MOVWF  01
15D0:  BRA    15D2
15D2:  NOP   
15D4:  BSF    01.7
15D6:  BRA    15F8
15D8:  BCF    01.7
15DA:  MOVLB  8
15DC:  RRCF   x4F,F
15DE:  MOVLB  0
15E0:  BTFSC  FD8.0
15E2:  BSF    F8B.0
15E4:  BTFSS  FD8.0
15E6:  BCF    F8B.0
15E8:  BSF    01.6
15EA:  BRA    15F8
15EC:  BCF    01.6
15EE:  DECFSZ 01,F
15F0:  BRA    15DA
15F2:  BRA    15F4
15F4:  NOP   
15F6:  BSF    F8B.0
15F8:  MOVLW  10
15FA:  MOVWF  FE9
15FC:  DECFSZ FE9,F
15FE:  BRA    15FC
1600:  BRA    1602
1602:  NOP   
1604:  BTFSC  01.7
1606:  BRA    15D8
1608:  BTFSC  01.6
160A:  BRA    15EC
160C:  RETURN 0
*
571C:  BSF    F94.1
571E:  BTFSC  F82.1
5720:  BRA    571E
5722:  MOVLW  08
5724:  MOVWF  00
5726:  MOVLB  7
5728:  CLRF   xF7
572A:  BSF    00.7
572C:  BRA    574E
572E:  BCF    00.7
5730:  BRA    574E
5732:  MOVFF  7F7,02
5736:  BCF    FD8.0
5738:  BTFSC  F82.1
573A:  BSF    FD8.0
573C:  RRCF   02,F
573E:  BSF    00.6
5740:  BRA    574E
5742:  BCF    00.6
5744:  DECFSZ 00,F
5746:  BRA    5736
5748:  MOVFF  02,01
574C:  BRA    5766
574E:  MOVLW  10
5750:  BTFSC  00.7
5752:  MOVLW  04
5754:  MOVWF  01
5756:  DECFSZ 01,F
5758:  BRA    5756
575A:  BRA    575C
575C:  BTFSC  00.7
575E:  BRA    572E
5760:  BTFSC  00.6
5762:  BRA    5742
5764:  BRA    5736
5766:  MOVLB  0
5768:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
32E8:  MOVLW  08
32EA:  MOVWF  01
32EC:  MOVLW  0A
32EE:  MOVWF  00
32F0:  DECFSZ 00,F
32F2:  BRA    32F0
32F4:  BCF    F8B.3
32F6:  BCF    F94.3
32F8:  MOVLW  0B
32FA:  MOVWF  00
32FC:  DECFSZ 00,F
32FE:  BRA    32FC
3300:  MOVLB  8
3302:  RLCF   x43,F
3304:  BCF    F8B.4
3306:  BTFSC  FD8.0
3308:  BSF    F94.4
330A:  BTFSS  FD8.0
330C:  BCF    F94.4
330E:  BSF    F94.3
3310:  BTFSS  F82.3
3312:  BRA    3310
3314:  DECFSZ 01,F
3316:  BRA    331A
3318:  BRA    331E
331A:  MOVLB  0
331C:  BRA    32EC
331E:  MOVLW  0A
3320:  MOVWF  00
3322:  DECFSZ 00,F
3324:  BRA    3322
3326:  BCF    F8B.3
3328:  BCF    F94.3
332A:  NOP   
332C:  BSF    F94.4
332E:  MOVLW  0B
3330:  MOVWF  00
3332:  DECFSZ 00,F
3334:  BRA    3332
3336:  MOVLW  0B
3338:  MOVWF  00
333A:  DECFSZ 00,F
333C:  BRA    333A
333E:  BSF    F94.3
3340:  BTFSS  F82.3
3342:  BRA    3340
3344:  CLRF   01
3346:  MOVLW  0B
3348:  MOVWF  00
334A:  DECFSZ 00,F
334C:  BRA    334A
334E:  BTFSC  F82.4
3350:  BSF    01.0
3352:  BCF    F8B.3
3354:  BCF    F94.3
3356:  BCF    F8B.4
3358:  BCF    F94.4
335A:  MOVLB  0
335C:  RETURN 0
335E:  MOVLW  08
3360:  MOVLB  8
3362:  MOVWF  x36
3364:  MOVFF  00,837
3368:  BSF    F94.4
336A:  MOVLW  0B
336C:  MOVWF  00
336E:  DECFSZ 00,F
3370:  BRA    336E
3372:  BSF    F94.3
3374:  BTFSS  F82.3
3376:  BRA    3374
3378:  BTFSC  F82.4
337A:  BSF    FD8.0
337C:  BTFSS  F82.4
337E:  BCF    FD8.0
3380:  RLCF   01,F
3382:  MOVLW  0A
3384:  MOVWF  00
3386:  DECFSZ 00,F
3388:  BRA    3386
338A:  BCF    F94.3
338C:  BCF    F8B.3
338E:  DECFSZ x36,F
3390:  BRA    3368
3392:  BSF    F94.4
3394:  MOVLW  0B
3396:  MOVWF  00
3398:  DECFSZ 00,F
339A:  BRA    3398
339C:  BCF    F8B.4
339E:  MOVF   x37,W
33A0:  BTFSS  FD8.2
33A2:  BCF    F94.4
33A4:  NOP   
33A6:  BSF    F94.3
33A8:  BTFSS  F82.3
33AA:  BRA    33A8
33AC:  MOVLW  0A
33AE:  MOVWF  00
33B0:  DECFSZ 00,F
33B2:  BRA    33B0
33B4:  BCF    F8B.3
33B6:  BCF    F94.3
33B8:  MOVLW  0B
33BA:  MOVWF  00
33BC:  DECFSZ 00,F
33BE:  BRA    33BC
33C0:  BCF    F8B.4
33C2:  BCF    F94.4
33C4:  MOVLB  0
33C6:  RETURN 0
....................  
.................... #define ptr_start                       150 
.................... #define EEPROM_SIZE_endofkey            131071 
.................... #define EEPROM_SIZE_stofkey             115470 
.................... #define EEPROM_KEY_ST                   EEPROM_SIZE_stofkey+1 
.................... //=============================== 
....................  
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
442C:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
442E:  BSF    F94.4
....................    port_b_pullups(0xff); 
4430:  BCF    FF1.7
.................... } 
4432:  GOTO   7388 (RETURN)
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3918:  MOVLB  8
391A:  MOVF   x3A,F
391C:  BNZ   3924
391E:  MOVF   x39,W
3920:  SUBLW  00
3922:  BC    392A
3924:  MOVLW  A8
3926:  MOVWF  x3D
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3928:  BRA    392E
392A:  MOVLW  A0
392C:  MOVWF  x3D
....................  
....................    i2c_start(); 
392E:  BSF    F94.4
3930:  MOVLW  0A
3932:  MOVWF  00
3934:  DECFSZ 00,F
3936:  BRA    3934
3938:  BSF    F94.3
393A:  MOVLW  0B
393C:  MOVWF  00
393E:  DECFSZ 00,F
3940:  BRA    393E
3942:  BCF    F8B.4
3944:  BCF    F94.4
3946:  MOVLW  0A
3948:  MOVWF  00
394A:  DECFSZ 00,F
394C:  BRA    394A
394E:  BCF    F8B.3
3950:  BCF    F94.3
....................    i2c_write(command); 
3952:  MOVFF  83D,843
3956:  MOVLB  0
3958:  RCALL  32E8
....................    i2c_write(address>>8); 
395A:  MOVFF  838,83F
395E:  MOVFF  839,840
3962:  MOVFF  83A,841
3966:  MOVLB  8
3968:  CLRF   x42
396A:  MOVFF  838,843
396E:  MOVLB  0
3970:  RCALL  32E8
....................    i2c_write(address); 
3972:  MOVFF  837,843
3976:  RCALL  32E8
....................    i2c_write(data); 
3978:  MOVFF  83B,843
397C:  RCALL  32E8
....................  
....................    i2c_stop(); 
397E:  BCF    F94.4
3980:  NOP   
3982:  BSF    F94.3
3984:  BTFSS  F82.3
3986:  BRA    3984
3988:  MOVLW  0A
398A:  MOVWF  00
398C:  DECFSZ 00,F
398E:  BRA    398C
3990:  BRA    3992
3992:  NOP   
3994:  BSF    F94.4
3996:  MOVLW  0A
3998:  MOVWF  00
399A:  DECFSZ 00,F
399C:  BRA    399A
....................    i2c_start(); 
399E:  BSF    F94.4
39A0:  MOVLW  0A
39A2:  MOVWF  00
39A4:  DECFSZ 00,F
39A6:  BRA    39A4
39A8:  BSF    F94.3
39AA:  MOVLW  0B
39AC:  MOVWF  00
39AE:  DECFSZ 00,F
39B0:  BRA    39AE
39B2:  BCF    F8B.4
39B4:  BCF    F94.4
39B6:  MOVLW  0A
39B8:  MOVWF  00
39BA:  DECFSZ 00,F
39BC:  BRA    39BA
39BE:  BCF    F8B.3
39C0:  BCF    F94.3
....................    status=i2c_write(command); 
39C2:  MOVFF  83D,843
39C6:  RCALL  32E8
39C8:  MOVF   01,W
39CA:  MOVLB  8
39CC:  BCF    x3C.0
39CE:  BTFSC  01.0
39D0:  BSF    x3C.0
....................    while(status==1) 
....................    { 
39D2:  BTFSS  x3C.0
39D4:  BRA    3A12
....................       i2c_start(); 
39D6:  BSF    F94.4
39D8:  MOVLW  0A
39DA:  MOVWF  00
39DC:  DECFSZ 00,F
39DE:  BRA    39DC
39E0:  BSF    F94.3
39E2:  MOVLW  0B
39E4:  MOVWF  00
39E6:  DECFSZ 00,F
39E8:  BRA    39E6
39EA:  BTFSS  F82.3
39EC:  BRA    39EA
39EE:  BCF    F8B.4
39F0:  BCF    F94.4
39F2:  MOVLW  0A
39F4:  MOVWF  00
39F6:  DECFSZ 00,F
39F8:  BRA    39F6
39FA:  BCF    F8B.3
39FC:  BCF    F94.3
....................       status=i2c_write(command); 
39FE:  MOVFF  83D,843
3A02:  MOVLB  0
3A04:  RCALL  32E8
3A06:  MOVF   01,W
3A08:  MOVLB  8
3A0A:  BCF    x3C.0
3A0C:  BTFSC  01.0
3A0E:  BSF    x3C.0
....................    } 
3A10:  BRA    39D2
....................    //delay_us(100); 
.................... } 
3A12:  MOVLB  0
3A14:  RETURN 0
....................  
....................  
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
33C8:  MOVLB  8
33CA:  MOVF   x32,F
33CC:  BNZ   33D4
33CE:  MOVF   x31,W
33D0:  SUBLW  00
33D2:  BC    33DA
33D4:  MOVLW  A8
33D6:  MOVWF  x34
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
33D8:  BRA    33DE
33DA:  MOVLW  A0
33DC:  MOVWF  x34
....................  
....................    i2c_start(); 
33DE:  BSF    F94.4
33E0:  MOVLW  0A
33E2:  MOVWF  00
33E4:  DECFSZ 00,F
33E6:  BRA    33E4
33E8:  BSF    F94.3
33EA:  MOVLW  0B
33EC:  MOVWF  00
33EE:  DECFSZ 00,F
33F0:  BRA    33EE
33F2:  BTFSS  F82.3
33F4:  BRA    33F2
33F6:  BCF    F8B.4
33F8:  BCF    F94.4
33FA:  MOVLW  0A
33FC:  MOVWF  00
33FE:  DECFSZ 00,F
3400:  BRA    33FE
3402:  BCF    F8B.3
3404:  BCF    F94.3
....................    i2c_write(command); 
3406:  MOVFF  834,843
340A:  MOVLB  0
340C:  RCALL  32E8
....................    i2c_write(address>>8); 
340E:  MOVFF  830,836
3412:  MOVFF  831,837
3416:  MOVFF  832,838
341A:  MOVLB  8
341C:  CLRF   x39
341E:  MOVFF  830,843
3422:  MOVLB  0
3424:  RCALL  32E8
....................    i2c_write(address); 
3426:  MOVFF  82F,843
342A:  RCALL  32E8
....................    i2c_start(); 
342C:  BSF    F94.4
342E:  MOVLW  0A
3430:  MOVWF  00
3432:  DECFSZ 00,F
3434:  BRA    3432
3436:  BSF    F94.3
3438:  MOVLW  0B
343A:  MOVWF  00
343C:  DECFSZ 00,F
343E:  BRA    343C
3440:  BTFSS  F82.3
3442:  BRA    3440
3444:  BCF    F8B.4
3446:  BCF    F94.4
3448:  MOVLW  0A
344A:  MOVWF  00
344C:  DECFSZ 00,F
344E:  BRA    344C
3450:  BCF    F8B.3
3452:  BCF    F94.3
....................    i2c_write(command+1); 
3454:  MOVLW  01
3456:  MOVLB  8
3458:  ADDWF  x34,W
345A:  MOVWF  x35
345C:  MOVWF  x43
345E:  MOVLB  0
3460:  RCALL  32E8
....................    data=i2c_read(0); 
3462:  CLRF   00
3464:  RCALL  335E
3466:  MOVFF  01,833
....................    i2c_stop(); 
346A:  BCF    F94.4
346C:  NOP   
346E:  BSF    F94.3
3470:  BTFSS  F82.3
3472:  BRA    3470
3474:  MOVLW  0A
3476:  MOVWF  00
3478:  DECFSZ 00,F
347A:  BRA    3478
347C:  BRA    347E
347E:  NOP   
3480:  BSF    F94.4
3482:  MOVLW  0A
3484:  MOVWF  00
3486:  DECFSZ 00,F
3488:  BRA    3486
....................    return(data); 
348A:  MOVLB  8
348C:  MOVFF  833,01
.................... } 
3490:  MOVLB  0
3492:  RETURN 0
....................  
....................  
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE_stofkey) return(0); 
*
593A:  MOVLB  7
593C:  MOVF   xF2,W
593E:  ADDWF  xF0,W
5940:  MOVF   xF3,W
5942:  ADDWFC xF1,W
5944:  MOVWF  xF9
....................    for(i=0;i<len;i++) 
5946:  CLRF   xF7
5948:  CLRF   xF6
594A:  MOVF   xF7,W
594C:  SUBWF  xF3,W
594E:  BNC   59AA
5950:  BNZ   5958
5952:  MOVF   xF2,W
5954:  SUBWF  xF6,W
5956:  BC    59AA
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
5958:  MOVF   xF4,W
595A:  ADDWF  xF6,W
595C:  MOVWF  01
595E:  MOVF   xF5,W
5960:  ADDWFC xF7,W
5962:  MOVWF  03
5964:  MOVFF  01,7F8
5968:  MOVWF  xF9
596A:  MOVF   xF6,W
596C:  ADDWF  xF0,W
596E:  MOVWF  xFA
5970:  MOVF   xF7,W
5972:  ADDWFC xF1,W
5974:  MOVWF  xFB
5976:  CLRF   19
5978:  BTFSC  FF2.7
597A:  BSF    19.7
597C:  BCF    FF2.7
597E:  MOVLB  8
5980:  CLRF   x32
5982:  CLRF   x31
5984:  MOVWF  x30
5986:  MOVFF  7FA,82F
598A:  MOVLB  0
598C:  CALL   33C8
5990:  BTFSC  19.7
5992:  BSF    FF2.7
5994:  MOVFF  7F9,FEA
5998:  MOVFF  7F8,FE9
599C:  MOVFF  01,FEF
....................    } 
59A0:  MOVLB  7
59A2:  INCF   xF6,F
59A4:  BTFSC  FD8.2
59A6:  INCF   xF7,F
59A8:  BRA    594A
....................     
.................... } 
59AA:  MOVLB  0
59AC:  GOTO   5FDC (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr            0 
.................... #define strobe_ptrcard_addr         25     // 4 bytes 
.................... #define strobe_ptrcard_key          30     // 4 bytes 
.................... #define strobe_count_card           36     // 2 bytes 
.................... #define strobe_nameconsole          40     // 16 bytes  
.................... #define strobe_Master_SLV           58     // 1 byte 
.................... #define strobe_debugmode            59     // 1 byte 
.................... #define strobe_delaytime            60     // 1 byte 
.................... #define kindofKB                    61     // 1 byte 
....................  
....................  
.................... #define wide_strobe_nameconsole     16  
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards               930   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
350E:  MOVLB  8
3510:  CLRF   x38
3512:  MOVF   x35,W
3514:  SUBWF  x38,W
3516:  BC    352C
....................    { 
....................       inputdat[i]=0; 
3518:  CLRF   03
351A:  MOVF   x38,W
351C:  ADDWF  x36,W
351E:  MOVWF  FE9
3520:  MOVF   x37,W
3522:  ADDWFC 03,W
3524:  MOVWF  FEA
3526:  CLRF   FEF
....................    } 
3528:  INCF   x38,F
352A:  BRA    3512
.................... } 
352C:  MOVLB  0
352E:  RETURN 0
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
44DC:  MOVLB  8
44DE:  CLRF   x10
44E0:  CLRF   x0F
44E2:  CLRF   x0E
44E4:  CLRF   x0D
44E6:  MOVF   x10,W
44E8:  SUBWF  x0A,W
44EA:  BNC   4570
44EC:  BNZ   4504
44EE:  MOVF   x0F,W
44F0:  SUBWF  x09,W
44F2:  BNC   4570
44F4:  BNZ   4504
44F6:  MOVF   x0E,W
44F8:  SUBWF  x08,W
44FA:  BNC   4570
44FC:  BNZ   4504
44FE:  MOVF   x07,W
4500:  SUBWF  x0D,W
4502:  BC    4570
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4504:  MOVF   x0D,W
4506:  ADDWF  x03,W
4508:  MOVWF  x11
450A:  MOVF   x0E,W
450C:  ADDWFC x04,W
450E:  MOVWF  x12
4510:  MOVF   x0F,W
4512:  ADDWFC x05,W
4514:  MOVWF  x13
4516:  MOVF   x10,W
4518:  ADDWFC x06,W
451A:  MOVWF  x14
451C:  MOVF   x0B,W
451E:  ADDWF  x0D,W
4520:  MOVWF  FE9
4522:  MOVF   x0C,W
4524:  ADDWFC x0E,W
4526:  MOVWF  FEA
4528:  MOVFF  FEF,815
452C:  CLRF   19
452E:  BTFSC  FF2.7
4530:  BSF    19.7
4532:  BCF    FF2.7
4534:  MOVFF  814,83A
4538:  MOVFF  813,839
453C:  MOVFF  812,838
4540:  MOVFF  811,837
4544:  MOVFF  815,83B
4548:  MOVLB  0
454A:  CALL   3918
454E:  BTFSC  19.7
4550:  BSF    FF2.7
....................       delay_us(10); 
4552:  MOVLW  1A
4554:  MOVWF  00
4556:  DECFSZ 00,F
4558:  BRA    4556
455A:  NOP   
....................    } 
455C:  MOVLW  01
455E:  MOVLB  8
4560:  ADDWF  x0D,F
4562:  BTFSC  FD8.0
4564:  INCF   x0E,F
4566:  BTFSC  FD8.2
4568:  INCF   x0F,F
456A:  BTFSC  FD8.2
456C:  INCF   x10,F
456E:  BRA    44E6
....................    return 1; 
4570:  MOVLW  01
4572:  MOVWF  01
.................... } 
4574:  MOVLB  0
4576:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4436:  MOVLB  7
4438:  CLRF   xFB
443A:  CLRF   xFA
443C:  CLRF   xF9
443E:  CLRF   xF8
4440:  MOVF   xFB,W
4442:  SUBWF  xF5,W
4444:  BNC   44D8
4446:  BNZ   445E
4448:  MOVF   xFA,W
444A:  SUBWF  xF4,W
444C:  BNC   44D8
444E:  BNZ   445E
4450:  MOVF   xF9,W
4452:  SUBWF  xF3,W
4454:  BNC   44D8
4456:  BNZ   445E
4458:  MOVF   xF2,W
445A:  SUBWF  xF8,W
445C:  BC    44D8
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
445E:  MOVF   xF6,W
4460:  ADDWF  xF8,W
4462:  MOVWF  01
4464:  MOVF   xF7,W
4466:  ADDWFC xF9,W
4468:  MOVWF  03
446A:  MOVFF  01,7FC
446E:  MOVWF  xFD
4470:  MOVF   xF8,W
4472:  ADDWF  xEE,W
4474:  MOVWF  xFE
4476:  MOVF   xF9,W
4478:  ADDWFC xEF,W
447A:  MOVWF  xFF
447C:  MOVF   xFA,W
447E:  ADDWFC xF0,W
4480:  MOVLB  8
4482:  MOVWF  x00
4484:  MOVLB  7
4486:  MOVF   xFB,W
4488:  ADDWFC xF1,W
448A:  MOVLB  8
448C:  MOVWF  x01
448E:  CLRF   19
4490:  BTFSC  FF2.7
4492:  BSF    19.7
4494:  BCF    FF2.7
4496:  MOVWF  x32
4498:  MOVFF  800,831
449C:  MOVFF  7FF,830
44A0:  MOVFF  7FE,82F
44A4:  MOVLB  0
44A6:  CALL   33C8
44AA:  BTFSC  19.7
44AC:  BSF    FF2.7
44AE:  MOVFF  7FD,FEA
44B2:  MOVFF  7FC,FE9
44B6:  MOVFF  01,FEF
....................       delay_us(10); 
44BA:  MOVLW  1A
44BC:  MOVWF  00
44BE:  DECFSZ 00,F
44C0:  BRA    44BE
44C2:  NOP   
....................    } 
44C4:  MOVLW  01
44C6:  MOVLB  7
44C8:  ADDWF  xF8,F
44CA:  BTFSC  FD8.0
44CC:  INCF   xF9,F
44CE:  BTFSC  FD8.2
44D0:  INCF   xFA,F
44D2:  BTFSC  FD8.2
44D4:  INCF   xFB,F
44D6:  BRA    4440
.................... } 
44D8:  MOVLB  0
44DA:  RETURN 0
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
4608:  MOVLB  7
460A:  CLRF   xBC
460C:  CLRF   xBB
460E:  CLRF   xBA
4610:  CLRF   xB9
4612:  CLRF   xC0
4614:  CLRF   xBF
4616:  CLRF   xBE
4618:  CLRF   xBD
461A:  CLRF   xC4
461C:  CLRF   xC3
461E:  CLRF   xC2
4620:  CLRF   xC1
4622:  CLRF   xC8
4624:  CLRF   xC7
4626:  CLRF   xC6
4628:  CLRF   xC5
462A:  CLRF   xCC
462C:  CLRF   xCB
462E:  CLRF   xCA
4630:  CLRF   xC9
4632:  CLRF   19
4634:  BTFSC  FF2.7
4636:  BSF    19.7
4638:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
463A:  MOVLB  8
463C:  CLRF   x32
463E:  CLRF   x31
4640:  CLRF   x30
4642:  MOVFF  7B8,82F
4646:  MOVLB  0
4648:  CALL   33C8
464C:  BTFSC  19.7
464E:  BSF    FF2.7
4650:  MOVLB  7
4652:  MOVFF  01,7BD
4656:  CLRF   xBE
4658:  CLRF   xBF
465A:  CLRF   xC0
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
465C:  MOVLW  01
465E:  ADDWF  xB8,W
4660:  MOVWF  xCD
4662:  CLRF   19
4664:  BTFSC  FF2.7
4666:  BSF    19.7
4668:  BCF    FF2.7
466A:  MOVLB  8
466C:  CLRF   x32
466E:  CLRF   x31
4670:  CLRF   x30
4672:  MOVWF  x2F
4674:  MOVLB  0
4676:  CALL   33C8
467A:  BTFSC  19.7
467C:  BSF    FF2.7
467E:  MOVLB  7
4680:  CLRF   xC4
4682:  CLRF   xC3
4684:  CLRF   xC2
4686:  MOVFF  01,7C1
....................    temp2<<=8; 
468A:  MOVFF  7C3,7C4
468E:  MOVFF  7C2,7C3
4692:  MOVFF  7C1,7C2
4696:  CLRF   xC1
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
4698:  MOVLW  02
469A:  ADDWF  xB8,W
469C:  MOVWF  xCD
469E:  CLRF   19
46A0:  BTFSC  FF2.7
46A2:  BSF    19.7
46A4:  BCF    FF2.7
46A6:  MOVLB  8
46A8:  CLRF   x32
46AA:  CLRF   x31
46AC:  CLRF   x30
46AE:  MOVWF  x2F
46B0:  MOVLB  0
46B2:  CALL   33C8
46B6:  BTFSC  19.7
46B8:  BSF    FF2.7
46BA:  MOVLB  7
46BC:  CLRF   xC8
46BE:  CLRF   xC7
46C0:  CLRF   xC6
46C2:  MOVFF  01,7C5
....................    temp3<<=16; 
46C6:  MOVFF  7C6,7C8
46CA:  MOVFF  7C5,7C7
46CE:  CLRF   xC5
46D0:  CLRF   xC6
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
46D2:  MOVLW  03
46D4:  ADDWF  xB8,W
46D6:  MOVWF  xCD
46D8:  CLRF   19
46DA:  BTFSC  FF2.7
46DC:  BSF    19.7
46DE:  BCF    FF2.7
46E0:  MOVLB  8
46E2:  CLRF   x32
46E4:  CLRF   x31
46E6:  CLRF   x30
46E8:  MOVWF  x2F
46EA:  MOVLB  0
46EC:  CALL   33C8
46F0:  BTFSC  19.7
46F2:  BSF    FF2.7
46F4:  MOVLB  7
46F6:  CLRF   xCC
46F8:  CLRF   xCB
46FA:  CLRF   xCA
46FC:  MOVFF  01,7C9
....................    temp4<<=24; 
4700:  MOVFF  7C9,7CC
4704:  CLRF   xC9
4706:  CLRF   xCA
4708:  CLRF   xCB
....................    buffer = temp4|temp3|temp2|temp1; 
470A:  MOVF   xC9,W
470C:  IORWF  xC5,W
470E:  MOVWF  xCD
4710:  MOVF   xCA,W
4712:  IORWF  xC6,W
4714:  MOVWF  xCE
4716:  MOVF   xCB,W
4718:  IORWF  xC7,W
471A:  MOVWF  xCF
471C:  MOVF   xCC,W
471E:  IORWF  xC8,W
4720:  MOVWF  xD0
4722:  MOVF   xC1,W
4724:  IORWF  xCD,F
4726:  MOVF   xC2,W
4728:  IORWF  xCE,F
472A:  MOVF   xC3,W
472C:  IORWF  xCF,F
472E:  MOVF   xC4,W
4730:  IORWF  xD0,F
4732:  MOVF   xCD,W
4734:  IORWF  xBD,W
4736:  MOVWF  xB9
4738:  MOVF   xCE,W
473A:  IORWF  xBE,W
473C:  MOVWF  xBA
473E:  MOVF   xCF,W
4740:  IORWF  xBF,W
4742:  MOVWF  xBB
4744:  MOVF   xD0,W
4746:  IORWF  xC0,W
4748:  MOVWF  xBC
....................    return(buffer); 
474A:  MOVFF  7B9,00
474E:  MOVFF  7BA,01
4752:  MOVFF  7BB,02
4756:  MOVFF  7BC,03
.................... } 
475A:  MOVLB  0
475C:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3A16:  MOVLB  8
3A18:  CLRF   x31
3A1A:  CLRF   x30
3A1C:  CLRF   x2F
3A1E:  CLRF   x2E
3A20:  CLRF   x32
3A22:  CLRF   x33
3A24:  CLRF   x34
3A26:  CLRF   x35
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3A28:  MOVFF  82C,831
3A2C:  MOVFF  82B,830
3A30:  MOVFF  82A,82F
3A34:  MOVFF  829,82E
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3A38:  MOVFF  82E,832
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3A3C:  MOVFF  82F,833
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3A40:  MOVFF  830,834
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3A44:  MOVFF  831,835
....................    write_ext_eeprom((addr+0),temp1); 
3A48:  CLRF   x3A
3A4A:  CLRF   x39
3A4C:  CLRF   x38
3A4E:  MOVFF  82D,837
3A52:  MOVFF  832,83B
3A56:  MOVLB  0
3A58:  RCALL  3918
....................    write_ext_eeprom((addr+1),temp2); 
3A5A:  MOVLW  01
3A5C:  MOVLB  8
3A5E:  ADDWF  x2D,W
3A60:  MOVWF  x36
3A62:  CLRF   x3A
3A64:  CLRF   x39
3A66:  CLRF   x38
3A68:  MOVWF  x37
3A6A:  MOVFF  833,83B
3A6E:  MOVLB  0
3A70:  RCALL  3918
....................    write_ext_eeprom((addr+2),temp3); 
3A72:  MOVLW  02
3A74:  MOVLB  8
3A76:  ADDWF  x2D,W
3A78:  MOVWF  x36
3A7A:  CLRF   x3A
3A7C:  CLRF   x39
3A7E:  CLRF   x38
3A80:  MOVWF  x37
3A82:  MOVFF  834,83B
3A86:  MOVLB  0
3A88:  RCALL  3918
....................    write_ext_eeprom((addr+3),temp4); 
3A8A:  MOVLW  03
3A8C:  MOVLB  8
3A8E:  ADDWF  x2D,W
3A90:  MOVWF  x36
3A92:  CLRF   x3A
3A94:  CLRF   x39
3A96:  CLRF   x38
3A98:  MOVWF  x37
3A9A:  MOVFF  835,83B
3A9E:  MOVLB  0
3AA0:  RCALL  3918
.................... } 
3AA2:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
401C:  MOVLB  8
401E:  CLRF   x29
4020:  CLRF   x28
4022:  CLRF   x2A
4024:  CLRF   x2B
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
4026:  MOVFF  827,829
402A:  MOVFF  826,828
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
402E:  MOVFF  828,82A
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
4032:  MOVF   x29,W
4034:  MOVWF  x2B
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
4036:  CLRF   x3A
4038:  CLRF   x39
403A:  CLRF   x38
403C:  MOVLW  24
403E:  MOVWF  x37
4040:  MOVFF  82A,83B
4044:  MOVLB  0
4046:  RCALL  3918
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
4048:  MOVLB  8
404A:  CLRF   x3A
404C:  CLRF   x39
404E:  CLRF   x38
4050:  MOVLW  25
4052:  MOVWF  x37
4054:  MOVFF  82B,83B
4058:  MOVLB  0
405A:  RCALL  3918
.................... } 
405C:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
3494:  MOVLB  8
3496:  CLRF   x2A
3498:  CLRF   x29
349A:  CLRF   x2C
349C:  CLRF   x2B
349E:  CLRF   x2E
34A0:  CLRF   x2D
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
34A2:  CLRF   x32
34A4:  CLRF   x31
34A6:  CLRF   x30
34A8:  MOVLW  24
34AA:  MOVWF  x2F
34AC:  MOVLB  0
34AE:  RCALL  33C8
34B0:  MOVLB  8
34B2:  MOVFF  01,82B
34B6:  CLRF   x2C
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
34B8:  CLRF   x32
34BA:  CLRF   x31
34BC:  CLRF   x30
34BE:  MOVLW  25
34C0:  MOVWF  x2F
34C2:  MOVLB  0
34C4:  RCALL  33C8
34C6:  MOVLB  8
34C8:  CLRF   x2E
34CA:  MOVFF  01,82D
....................    temp2<<=8; 
34CE:  MOVFF  82D,82E
34D2:  CLRF   x2D
....................    buffer = temp2|temp1; 
34D4:  MOVF   x2D,W
34D6:  IORWF  x2B,W
34D8:  MOVWF  x29
34DA:  MOVF   x2E,W
34DC:  IORWF  x2C,W
34DE:  MOVWF  x2A
....................    return(buffer); 
34E0:  MOVFF  829,01
34E4:  MOVFF  82A,02
.................... } 
34E8:  MOVLB  0
34EA:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................  
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
5ACA:  MOVLB  7
5ACC:  CLRF   xF1
5ACE:  MOVLW  01
5AD0:  MOVWF  xF0
5AD2:  MOVLW  C3
5AD4:  MOVWF  xEF
5AD6:  MOVLW  0F
5AD8:  MOVWF  xEE
5ADA:  MOVF   xF1,W
5ADC:  SUBWF  27,W
5ADE:  BNC   5B32
5AE0:  BNZ   5AF8
5AE2:  MOVF   xF0,W
5AE4:  SUBWF  26,W
5AE6:  BNC   5B32
5AE8:  BNZ   5AF8
5AEA:  MOVF   xEF,W
5AEC:  SUBWF  25,W
5AEE:  BNC   5B32
5AF0:  BNZ   5AF8
5AF2:  MOVF   24,W
5AF4:  SUBWF  xEE,W
5AF6:  BC    5B32
5AF8:  CLRF   19
5AFA:  BTFSC  FF2.7
5AFC:  BSF    19.7
5AFE:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5B00:  MOVFF  7F1,83A
5B04:  MOVFF  7F0,839
5B08:  MOVFF  7EF,838
5B0C:  MOVFF  7EE,837
5B10:  MOVLB  8
5B12:  CLRF   x3B
5B14:  MOVLB  0
5B16:  CALL   3918
5B1A:  BTFSC  19.7
5B1C:  BSF    FF2.7
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    } 
5B1E:  MOVLW  01
5B20:  MOVLB  7
5B22:  ADDWF  xEE,F
5B24:  BTFSC  FD8.0
5B26:  INCF   xEF,F
5B28:  BTFSC  FD8.2
5B2A:  INCF   xF0,F
5B2C:  BTFSC  FD8.2
5B2E:  INCF   xF1,F
5B30:  BRA    5ADA
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=ptr_start;i<ptr_card;i++) 
5B32:  CLRF   xF1
5B34:  CLRF   xF0
5B36:  CLRF   xEF
5B38:  MOVLW  96
5B3A:  MOVWF  xEE
5B3C:  MOVF   xF1,W
5B3E:  SUBWF  23,W
5B40:  BNC   5B94
5B42:  BNZ   5B5A
5B44:  MOVF   xF0,W
5B46:  SUBWF  22,W
5B48:  BNC   5B94
5B4A:  BNZ   5B5A
5B4C:  MOVF   xEF,W
5B4E:  SUBWF  21,W
5B50:  BNC   5B94
5B52:  BNZ   5B5A
5B54:  MOVF   20,W
5B56:  SUBWF  xEE,W
5B58:  BC    5B94
5B5A:  CLRF   19
5B5C:  BTFSC  FF2.7
5B5E:  BSF    19.7
5B60:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5B62:  MOVFF  7F1,83A
5B66:  MOVFF  7F0,839
5B6A:  MOVFF  7EF,838
5B6E:  MOVFF  7EE,837
5B72:  MOVLB  8
5B74:  CLRF   x3B
5B76:  MOVLB  0
5B78:  CALL   3918
5B7C:  BTFSC  19.7
5B7E:  BSF    FF2.7
....................    } 
5B80:  MOVLW  01
5B82:  MOVLB  7
5B84:  ADDWF  xEE,F
5B86:  BTFSC  FD8.0
5B88:  INCF   xEF,F
5B8A:  BTFSC  FD8.2
5B8C:  INCF   xF0,F
5B8E:  BTFSC  FD8.2
5B90:  INCF   xF1,F
5B92:  BRA    5B3C
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
5B94:  CLRF   23
5B96:  CLRF   22
5B98:  CLRF   21
5B9A:  MOVLW  96
5B9C:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5B9E:  CLRF   27
5BA0:  MOVLW  01
5BA2:  MOVWF  26
5BA4:  MOVLW  C3
5BA6:  MOVWF  25
5BA8:  MOVLW  0F
5BAA:  MOVWF  24
5BAC:  CLRF   19
5BAE:  BTFSC  FF2.7
5BB0:  BSF    19.7
5BB2:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5BB4:  MOVFF  23,82C
5BB8:  MOVFF  22,82B
5BBC:  MOVFF  21,82A
5BC0:  MOVFF  20,829
5BC4:  MOVLW  19
5BC6:  MOVLB  8
5BC8:  MOVWF  x2D
5BCA:  MOVLB  0
5BCC:  CALL   3A16
5BD0:  BTFSC  19.7
5BD2:  BSF    FF2.7
5BD4:  CLRF   19
5BD6:  BTFSC  FF2.7
5BD8:  BSF    19.7
5BDA:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5BDC:  MOVFF  27,82C
5BE0:  MOVFF  26,82B
5BE4:  MOVFF  25,82A
5BE8:  MOVFF  24,829
5BEC:  MOVLW  1E
5BEE:  MOVLB  8
5BF0:  MOVWF  x2D
5BF2:  MOVLB  0
5BF4:  CALL   3A16
5BF8:  BTFSC  19.7
5BFA:  BSF    FF2.7
5BFC:  CLRF   19
5BFE:  BTFSC  FF2.7
5C00:  BSF    19.7
5C02:  BCF    FF2.7
....................    save_coutcard(0); 
5C04:  MOVLB  8
5C06:  CLRF   x27
5C08:  CLRF   x26
5C0A:  MOVLB  0
5C0C:  CALL   401C
5C10:  BTFSC  19.7
5C12:  BSF    FF2.7
5C14:  CLRF   19
5C16:  BTFSC  FF2.7
5C18:  BSF    19.7
5C1A:  BCF    FF2.7
....................    countcard=get_countcard(); 
5C1C:  CALL   3494
5C20:  BTFSC  19.7
5C22:  BSF    FF2.7
5C24:  MOVFF  02,FA
5C28:  MOVFF  01,F9
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
5C2C:  GOTO   6384 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    ptr_card=ptr_start; 
5C30:  CLRF   23
5C32:  CLRF   22
5C34:  CLRF   21
5C36:  MOVLW  96
5C38:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5C3A:  CLRF   27
5C3C:  MOVLW  01
5C3E:  MOVWF  26
5C40:  MOVLW  C3
5C42:  MOVWF  25
5C44:  MOVLW  0F
5C46:  MOVWF  24
5C48:  CLRF   19
5C4A:  BTFSC  FF2.7
5C4C:  BSF    19.7
5C4E:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5C50:  MOVFF  23,82C
5C54:  MOVFF  22,82B
5C58:  MOVFF  21,82A
5C5C:  MOVFF  20,829
5C60:  MOVLW  19
5C62:  MOVLB  8
5C64:  MOVWF  x2D
5C66:  MOVLB  0
5C68:  CALL   3A16
5C6C:  BTFSC  19.7
5C6E:  BSF    FF2.7
5C70:  CLRF   19
5C72:  BTFSC  FF2.7
5C74:  BSF    19.7
5C76:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5C78:  MOVFF  27,82C
5C7C:  MOVFF  26,82B
5C80:  MOVFF  25,82A
5C84:  MOVFF  24,829
5C88:  MOVLW  1E
5C8A:  MOVLB  8
5C8C:  MOVWF  x2D
5C8E:  MOVLB  0
5C90:  CALL   3A16
5C94:  BTFSC  19.7
5C96:  BSF    FF2.7
5C98:  CLRF   19
5C9A:  BTFSC  FF2.7
5C9C:  BSF    19.7
5C9E:  BCF    FF2.7
....................    save_coutcard(0); 
5CA0:  MOVLB  8
5CA2:  CLRF   x27
5CA4:  CLRF   x26
5CA6:  MOVLB  0
5CA8:  CALL   401C
5CAC:  BTFSC  19.7
5CAE:  BSF    FF2.7
.................... } 
5CB0:  GOTO   63E8 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
4578:  MOVLB  7
457A:  CLRF   xF1
457C:  CLRF   xF0
457E:  CLRF   xEF
4580:  CLRF   xEE
4582:  CLRF   xF5
4584:  CLRF   xF4
4586:  CLRF   xF3
4588:  MOVLW  14
458A:  MOVWF  xF2
458C:  CLRF   xF7
458E:  MOVLW  55
4590:  MOVWF  xF6
4592:  MOVLB  0
4594:  RCALL  4436
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
4596:  INCFSZ 55,W
4598:  BRA    4606
459A:  INCFSZ 56,W
459C:  BRA    4606
459E:  INCFSZ x64,W
45A0:  BRA    4606
....................       { 
....................          memset(buffer1,0,20); 
45A2:  CLRF   FEA
45A4:  MOVLW  2D
45A6:  MOVWF  FE9
45A8:  CLRF   00
45AA:  CLRF   02
45AC:  MOVLW  14
45AE:  MOVWF  01
45B0:  RCALL  3E82
....................          strcpy(buffer1,"admin"); 
45B2:  CLRF   FEA
45B4:  MOVLW  2D
45B6:  MOVWF  FE9
45B8:  MOVLW  00
45BA:  CALL   00BA
45BE:  TBLRD*-
45C0:  TBLRD*+
45C2:  MOVF   FF5,W
45C4:  MOVWF  FEE
45C6:  IORLW  00
45C8:  BNZ   45C0
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
45CA:  MOVLB  8
45CC:  CLRF   x06
45CE:  CLRF   x05
45D0:  CLRF   x04
45D2:  CLRF   x03
45D4:  CLRF   x0A
45D6:  CLRF   x09
45D8:  CLRF   x08
45DA:  MOVLW  14
45DC:  MOVWF  x07
45DE:  CLRF   x0C
45E0:  MOVLW  2D
45E2:  MOVWF  x0B
45E4:  MOVLB  0
45E6:  RCALL  44DC
....................          EEPROM_read(strobe_pass_addr,20,password); 
45E8:  MOVLB  7
45EA:  CLRF   xF1
45EC:  CLRF   xF0
45EE:  CLRF   xEF
45F0:  CLRF   xEE
45F2:  CLRF   xF5
45F4:  CLRF   xF4
45F6:  CLRF   xF3
45F8:  MOVLW  14
45FA:  MOVWF  xF2
45FC:  CLRF   xF7
45FE:  MOVLW  55
4600:  MOVWF  xF6
4602:  MOVLB  0
4604:  RCALL  4436
....................       } 
.................... } 
4606:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
5CB4:  MOVLB  8
5CB6:  CLRF   x02
5CB8:  MOVF   x02,W
5CBA:  SUBLW  13
5CBC:  BNC   5CD2
5CBE:  CLRF   03
5CC0:  MOVF   x02,W
5CC2:  ADDLW  EE
5CC4:  MOVWF  FE9
5CC6:  MOVLW  07
5CC8:  ADDWFC 03,W
5CCA:  MOVWF  FEA
5CCC:  SETF   FEF
5CCE:  INCF   x02,F
5CD0:  BRA    5CB8
....................    EEPROM_write(strobe_pass_addr,20,buf); 
5CD2:  CLRF   x06
5CD4:  CLRF   x05
5CD6:  CLRF   x04
5CD8:  CLRF   x03
5CDA:  CLRF   x0A
5CDC:  CLRF   x09
5CDE:  CLRF   x08
5CE0:  MOVLW  14
5CE2:  MOVWF  x07
5CE4:  MOVLW  07
5CE6:  MOVWF  x0C
5CE8:  MOVLW  EE
5CEA:  MOVWF  x0B
5CEC:  MOVLB  0
5CEE:  CALL   44DC
.................... } 
5CF2:  GOTO   644C (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
.................... #define CRYPTO_KEY_SIZE   32 
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int16 galois_mul2(unsigned int16 value) 
.................... { 
....................   signed int16 temp; 
....................   // cast to signed value 
....................   temp = (signed char) value; 
*
4790:  CLRF   03
4792:  MOVLB  7
4794:  MOVF   xD9,W
4796:  BTFSC  FE8.7
4798:  DECF   03,F
479A:  MOVWF  xDB
479C:  MOVFF  03,7DC
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
47A0:  RRCF   xDC,W
47A2:  MOVWF  03
47A4:  RRCF   xDB,W
47A6:  MOVWF  02
47A8:  RRCF   03,F
47AA:  RRCF   02,F
47AC:  RRCF   03,F
47AE:  RRCF   02,F
47B0:  RRCF   03,F
47B2:  RRCF   02,F
47B4:  RRCF   03,F
47B6:  RRCF   02,F
47B8:  RRCF   03,F
47BA:  RRCF   02,F
47BC:  RRCF   03,F
47BE:  RRCF   02,F
47C0:  MOVLW  01
47C2:  ANDWF  03,F
47C4:  MOVFF  02,7DB
47C8:  MOVFF  03,7DC
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
47CC:  MOVLW  1B
47CE:  ANDWF  xDB,F
47D0:  CLRF   xDC
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
47D2:  BCF    FD8.0
47D4:  RLCF   xD9,W
47D6:  MOVWF  xDD
47D8:  RLCF   xDA,W
47DA:  MOVWF  xDE
47DC:  MOVF   xDD,W
47DE:  XORWF  xDB,W
47E0:  MOVWF  00
47E2:  MOVF   xDE,W
47E4:  XORWF  xDC,W
47E6:  MOVWF  03
47E8:  MOVFF  00,01
47EC:  MOVWF  02
.................... } 
47EE:  MOVLB  0
47F0:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................     unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................  
....................   // In case of decryption 
....................   if (dir != 0)  
47F2:  MOVLB  7
47F4:  MOVF   xD0,F
47F6:  BTFSC  FD8.2
47F8:  BRA    49C4
....................   { 
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
47FA:  CLRF   xD5
47FC:  MOVF   xD5,W
47FE:  SUBLW  09
4800:  BTFSS  FD8.0
4802:  BRA    497A
....................       //key schedule 
....................       key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[round]); 
4804:  MOVFF  7CE,01
4808:  MOVFF  7CF,03
480C:  MOVFF  7CE,7D7
4810:  MOVFF  7CF,7D8
4814:  MOVLW  0D
4816:  ADDWF  xCE,W
4818:  MOVWF  FE9
481A:  MOVLW  00
481C:  ADDWFC xCF,W
481E:  MOVWF  FEA
4820:  CLRF   03
4822:  MOVF   FEF,W
4824:  MOVLB  0
4826:  CALL   00D0
482A:  MOVLB  7
482C:  MOVWF  xD9
482E:  MOVFF  7CE,FE9
4832:  MOVFF  7CF,FEA
4836:  MOVF   FEF,W
4838:  XORWF  xD9,F
483A:  CLRF   03
483C:  MOVF   xD5,W
483E:  MOVLB  0
4840:  CALL   02F0
4844:  MOVWF  01
4846:  MOVLB  7
4848:  MOVF   xD9,W
484A:  XORWF  01,W
484C:  MOVFF  7D8,FEA
4850:  MOVFF  7D7,FE9
4854:  MOVWF  FEF
....................       key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4856:  MOVLW  01
4858:  ADDWF  xCE,W
485A:  MOVWF  01
485C:  MOVLW  00
485E:  ADDWFC xCF,W
4860:  MOVWF  03
4862:  MOVFF  01,7D7
4866:  MOVWF  xD8
4868:  MOVLW  0E
486A:  ADDWF  xCE,W
486C:  MOVWF  FE9
486E:  MOVLW  00
4870:  ADDWFC xCF,W
4872:  MOVWF  FEA
4874:  CLRF   03
4876:  MOVF   FEF,W
4878:  MOVLB  0
487A:  CALL   00D0
487E:  MOVLB  7
4880:  MOVWF  xD9
4882:  MOVLW  01
4884:  ADDWF  xCE,W
4886:  MOVWF  FE9
4888:  MOVLW  00
488A:  ADDWFC xCF,W
488C:  MOVWF  FEA
488E:  MOVF   FEF,W
4890:  XORWF  xD9,W
4892:  MOVFF  7D8,FEA
4896:  MOVFF  7D7,FE9
489A:  MOVWF  FEF
....................       key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
489C:  MOVLW  02
489E:  ADDWF  xCE,W
48A0:  MOVWF  01
48A2:  MOVLW  00
48A4:  ADDWFC xCF,W
48A6:  MOVWF  03
48A8:  MOVFF  01,7D7
48AC:  MOVWF  xD8
48AE:  MOVLW  0F
48B0:  ADDWF  xCE,W
48B2:  MOVWF  FE9
48B4:  MOVLW  00
48B6:  ADDWFC xCF,W
48B8:  MOVWF  FEA
48BA:  CLRF   03
48BC:  MOVF   FEF,W
48BE:  MOVLB  0
48C0:  CALL   00D0
48C4:  MOVLB  7
48C6:  MOVWF  xD9
48C8:  MOVLW  02
48CA:  ADDWF  xCE,W
48CC:  MOVWF  FE9
48CE:  MOVLW  00
48D0:  ADDWFC xCF,W
48D2:  MOVWF  FEA
48D4:  MOVF   FEF,W
48D6:  XORWF  xD9,W
48D8:  MOVFF  7D8,FEA
48DC:  MOVFF  7D7,FE9
48E0:  MOVWF  FEF
....................       key[3] = (unsigned int8)(sbox[key[12]]^key[3]); 
48E2:  MOVLW  03
48E4:  ADDWF  xCE,W
48E6:  MOVWF  01
48E8:  MOVLW  00
48EA:  ADDWFC xCF,W
48EC:  MOVWF  03
48EE:  MOVFF  01,7D7
48F2:  MOVWF  xD8
48F4:  MOVLW  0C
48F6:  ADDWF  xCE,W
48F8:  MOVWF  FE9
48FA:  MOVLW  00
48FC:  ADDWFC xCF,W
48FE:  MOVWF  FEA
4900:  CLRF   03
4902:  MOVF   FEF,W
4904:  MOVLB  0
4906:  CALL   00D0
490A:  MOVLB  7
490C:  MOVWF  xD9
490E:  MOVLW  03
4910:  ADDWF  xCE,W
4912:  MOVWF  FE9
4914:  MOVLW  00
4916:  ADDWFC xCF,W
4918:  MOVWF  FEA
491A:  MOVF   FEF,W
491C:  XORWF  xD9,W
491E:  MOVFF  7D8,FEA
4922:  MOVFF  7D7,FE9
4926:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4928:  MOVLW  04
492A:  MOVWF  xD6
492C:  MOVF   xD6,W
492E:  SUBLW  0F
4930:  BNC   4976
....................         key[i] = key[i] ^ key[i-4]; 
4932:  CLRF   03
4934:  MOVF   xD6,W
4936:  ADDWF  xCE,W
4938:  MOVWF  01
493A:  MOVF   xCF,W
493C:  ADDWFC 03,F
493E:  MOVFF  03,7D8
4942:  CLRF   03
4944:  MOVF   xD6,W
4946:  ADDWF  xCE,W
4948:  MOVWF  FE9
494A:  MOVF   xCF,W
494C:  ADDWFC 03,W
494E:  MOVWF  FEA
4950:  MOVFF  FEF,7D9
4954:  MOVLW  04
4956:  SUBWF  xD6,W
4958:  CLRF   03
495A:  ADDWF  xCE,W
495C:  MOVWF  FE9
495E:  MOVF   xCF,W
4960:  ADDWFC 03,W
4962:  MOVWF  FEA
4964:  MOVF   FEF,W
4966:  XORWF  xD9,W
4968:  MOVFF  7D8,FEA
496C:  MOVFF  01,FE9
4970:  MOVWF  FEF
....................       } 
4972:  INCF   xD6,F
4974:  BRA    492C
....................     } 
4976:  INCF   xD5,F
4978:  BRA    47FC
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++) 
497A:  CLRF   xD6
497C:  MOVF   xD6,W
497E:  SUBLW  0F
4980:  BNC   49C4
....................     { 
....................       state[i]=state[i] ^ key[i]; 
4982:  CLRF   03
4984:  MOVF   xD6,W
4986:  ADDWF  xCC,W
4988:  MOVWF  01
498A:  MOVF   xCD,W
498C:  ADDWFC 03,F
498E:  MOVFF  03,7D8
4992:  CLRF   03
4994:  MOVF   xD6,W
4996:  ADDWF  xCC,W
4998:  MOVWF  FE9
499A:  MOVF   xCD,W
499C:  ADDWFC 03,W
499E:  MOVWF  FEA
49A0:  MOVFF  FEF,7D9
49A4:  CLRF   03
49A6:  MOVF   xD6,W
49A8:  ADDWF  xCE,W
49AA:  MOVWF  FE9
49AC:  MOVF   xCF,W
49AE:  ADDWFC 03,W
49B0:  MOVWF  FEA
49B2:  MOVF   FEF,W
49B4:  XORWF  xD9,W
49B6:  MOVFF  7D8,FEA
49BA:  MOVFF  01,FE9
49BE:  MOVWF  FEF
....................     } 
49C0:  INCF   xD6,F
49C2:  BRA    497C
....................   } 
....................   // main loop 
....................   for (round = 0; round < 10; round++) 
49C4:  CLRF   xD5
49C6:  MOVF   xD5,W
49C8:  SUBLW  09
49CA:  BTFSS  FD8.0
49CC:  GOTO   5414
....................   { 
....................     if (dir != 0) 
49D0:  MOVF   xD0,F
49D2:  BTFSC  FD8.2
49D4:  BRA    4B4E
....................     { 
....................           //Inverse key schedule 
....................           for (i=15; i>3; --i)  
49D6:  MOVLW  0F
49D8:  MOVWF  xD6
49DA:  MOVF   xD6,W
49DC:  SUBLW  03
49DE:  BC    4A24
....................           { 
....................             key[i] = key[i] ^ key[i-4]; 
49E0:  CLRF   03
49E2:  MOVF   xD6,W
49E4:  ADDWF  xCE,W
49E6:  MOVWF  01
49E8:  MOVF   xCF,W
49EA:  ADDWFC 03,F
49EC:  MOVFF  03,7D8
49F0:  CLRF   03
49F2:  MOVF   xD6,W
49F4:  ADDWF  xCE,W
49F6:  MOVWF  FE9
49F8:  MOVF   xCF,W
49FA:  ADDWFC 03,W
49FC:  MOVWF  FEA
49FE:  MOVFF  FEF,7D9
4A02:  MOVLW  04
4A04:  SUBWF  xD6,W
4A06:  CLRF   03
4A08:  ADDWF  xCE,W
4A0A:  MOVWF  FE9
4A0C:  MOVF   xCF,W
4A0E:  ADDWFC 03,W
4A10:  MOVWF  FEA
4A12:  MOVF   FEF,W
4A14:  XORWF  xD9,W
4A16:  MOVFF  7D8,FEA
4A1A:  MOVFF  01,FE9
4A1E:  MOVWF  FEF
....................           }   
4A20:  DECF   xD6,F
4A22:  BRA    49DA
....................           key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[9-round]); 
4A24:  MOVFF  7CE,01
4A28:  MOVFF  7CF,03
4A2C:  MOVFF  7CE,7D7
4A30:  MOVFF  7CF,7D8
4A34:  MOVLW  0D
4A36:  ADDWF  xCE,W
4A38:  MOVWF  FE9
4A3A:  MOVLW  00
4A3C:  ADDWFC xCF,W
4A3E:  MOVWF  FEA
4A40:  CLRF   03
4A42:  MOVF   FEF,W
4A44:  MOVLB  0
4A46:  CALL   00D0
4A4A:  MOVLB  7
4A4C:  MOVWF  xD9
4A4E:  MOVFF  7CE,FE9
4A52:  MOVFF  7CF,FEA
4A56:  MOVF   FEF,W
4A58:  XORWF  xD9,F
4A5A:  MOVLW  09
4A5C:  BSF    FD8.0
4A5E:  SUBFWB xD5,W
4A60:  CLRF   03
4A62:  MOVLB  0
4A64:  CALL   02F0
4A68:  MOVWF  01
4A6A:  MOVLB  7
4A6C:  MOVF   xD9,W
4A6E:  XORWF  01,W
4A70:  MOVFF  7D8,FEA
4A74:  MOVFF  7D7,FE9
4A78:  MOVWF  FEF
....................           key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4A7A:  MOVLW  01
4A7C:  ADDWF  xCE,W
4A7E:  MOVWF  01
4A80:  MOVLW  00
4A82:  ADDWFC xCF,W
4A84:  MOVWF  03
4A86:  MOVFF  01,7D7
4A8A:  MOVWF  xD8
4A8C:  MOVLW  0E
4A8E:  ADDWF  xCE,W
4A90:  MOVWF  FE9
4A92:  MOVLW  00
4A94:  ADDWFC xCF,W
4A96:  MOVWF  FEA
4A98:  CLRF   03
4A9A:  MOVF   FEF,W
4A9C:  MOVLB  0
4A9E:  CALL   00D0
4AA2:  MOVLB  7
4AA4:  MOVWF  xD9
4AA6:  MOVLW  01
4AA8:  ADDWF  xCE,W
4AAA:  MOVWF  FE9
4AAC:  MOVLW  00
4AAE:  ADDWFC xCF,W
4AB0:  MOVWF  FEA
4AB2:  MOVF   FEF,W
4AB4:  XORWF  xD9,W
4AB6:  MOVFF  7D8,FEA
4ABA:  MOVFF  7D7,FE9
4ABE:  MOVWF  FEF
....................           key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
4AC0:  MOVLW  02
4AC2:  ADDWF  xCE,W
4AC4:  MOVWF  01
4AC6:  MOVLW  00
4AC8:  ADDWFC xCF,W
4ACA:  MOVWF  03
4ACC:  MOVFF  01,7D7
4AD0:  MOVWF  xD8
4AD2:  MOVLW  0F
4AD4:  ADDWF  xCE,W
4AD6:  MOVWF  FE9
4AD8:  MOVLW  00
4ADA:  ADDWFC xCF,W
4ADC:  MOVWF  FEA
4ADE:  CLRF   03
4AE0:  MOVF   FEF,W
4AE2:  MOVLB  0
4AE4:  CALL   00D0
4AE8:  MOVLB  7
4AEA:  MOVWF  xD9
4AEC:  MOVLW  02
4AEE:  ADDWF  xCE,W
4AF0:  MOVWF  FE9
4AF2:  MOVLW  00
4AF4:  ADDWFC xCF,W
4AF6:  MOVWF  FEA
4AF8:  MOVF   FEF,W
4AFA:  XORWF  xD9,W
4AFC:  MOVFF  7D8,FEA
4B00:  MOVFF  7D7,FE9
4B04:  MOVWF  FEF
....................           key[3] = (unsigned int8)(sbox[key[12]]^key[3]);  
4B06:  MOVLW  03
4B08:  ADDWF  xCE,W
4B0A:  MOVWF  01
4B0C:  MOVLW  00
4B0E:  ADDWFC xCF,W
4B10:  MOVWF  03
4B12:  MOVFF  01,7D7
4B16:  MOVWF  xD8
4B18:  MOVLW  0C
4B1A:  ADDWF  xCE,W
4B1C:  MOVWF  FE9
4B1E:  MOVLW  00
4B20:  ADDWFC xCF,W
4B22:  MOVWF  FEA
4B24:  CLRF   03
4B26:  MOVF   FEF,W
4B28:  MOVLB  0
4B2A:  CALL   00D0
4B2E:  MOVLB  7
4B30:  MOVWF  xD9
4B32:  MOVLW  03
4B34:  ADDWF  xCE,W
4B36:  MOVWF  FE9
4B38:  MOVLW  00
4B3A:  ADDWFC xCF,W
4B3C:  MOVWF  FEA
4B3E:  MOVF   FEF,W
4B40:  XORWF  xD9,W
4B42:  MOVFF  7D8,FEA
4B46:  MOVFF  7D7,FE9
4B4A:  MOVWF  FEF
....................     }  
....................     else  
4B4C:  BRA    4D66
....................     { 
....................         for (i = 0; i <16; i++) 
4B4E:  CLRF   xD6
4B50:  MOVF   xD6,W
4B52:  SUBLW  0F
4B54:  BNC   4BA6
....................         { 
....................             // with shiftrow i+5 mod 16 
....................             state[i]=sbox[state[i] ^ key[i]]; 
4B56:  CLRF   03
4B58:  MOVF   xD6,W
4B5A:  ADDWF  xCC,W
4B5C:  MOVWF  01
4B5E:  MOVF   xCD,W
4B60:  ADDWFC 03,F
4B62:  MOVFF  01,7D7
4B66:  MOVFF  03,7D8
4B6A:  CLRF   03
4B6C:  MOVF   xD6,W
4B6E:  ADDWF  xCC,W
4B70:  MOVWF  FE9
4B72:  MOVF   xCD,W
4B74:  ADDWFC 03,W
4B76:  MOVWF  FEA
4B78:  MOVFF  FEF,7D9
4B7C:  CLRF   03
4B7E:  MOVF   xD6,W
4B80:  ADDWF  xCE,W
4B82:  MOVWF  FE9
4B84:  MOVF   xCF,W
4B86:  ADDWFC 03,W
4B88:  MOVWF  FEA
4B8A:  MOVF   FEF,W
4B8C:  XORWF  xD9,W
4B8E:  CLRF   03
4B90:  MOVLB  0
4B92:  CALL   00D0
4B96:  MOVFF  7D8,FEA
4B9A:  MOVFF  7D7,FE9
4B9E:  MOVWF  FEF
....................         } 
4BA0:  MOVLB  7
4BA2:  INCF   xD6,F
4BA4:  BRA    4B50
....................         //shift rows 
....................         buf1 = state[1]; 
4BA6:  MOVLW  01
4BA8:  ADDWF  xCC,W
4BAA:  MOVWF  FE9
4BAC:  MOVLW  00
4BAE:  ADDWFC xCD,W
4BB0:  MOVWF  FEA
4BB2:  MOVFF  FEF,7D1
....................         state[1] = state[5]; 
4BB6:  MOVLW  01
4BB8:  ADDWF  xCC,W
4BBA:  MOVWF  01
4BBC:  MOVLW  00
4BBE:  ADDWFC xCD,W
4BC0:  MOVWF  03
4BC2:  MOVLW  05
4BC4:  ADDWF  xCC,W
4BC6:  MOVWF  FE9
4BC8:  MOVLW  00
4BCA:  ADDWFC xCD,W
4BCC:  MOVWF  FEA
4BCE:  MOVFF  FEF,7D9
4BD2:  MOVFF  03,FEA
4BD6:  MOVFF  01,FE9
4BDA:  MOVFF  7D9,FEF
....................         state[5] = state[9]; 
4BDE:  MOVLW  05
4BE0:  ADDWF  xCC,W
4BE2:  MOVWF  01
4BE4:  MOVLW  00
4BE6:  ADDWFC xCD,W
4BE8:  MOVWF  03
4BEA:  MOVLW  09
4BEC:  ADDWF  xCC,W
4BEE:  MOVWF  FE9
4BF0:  MOVLW  00
4BF2:  ADDWFC xCD,W
4BF4:  MOVWF  FEA
4BF6:  MOVFF  FEF,7D9
4BFA:  MOVFF  03,FEA
4BFE:  MOVFF  01,FE9
4C02:  MOVFF  7D9,FEF
....................         state[9] = state[13]; 
4C06:  MOVLW  09
4C08:  ADDWF  xCC,W
4C0A:  MOVWF  01
4C0C:  MOVLW  00
4C0E:  ADDWFC xCD,W
4C10:  MOVWF  03
4C12:  MOVLW  0D
4C14:  ADDWF  xCC,W
4C16:  MOVWF  FE9
4C18:  MOVLW  00
4C1A:  ADDWFC xCD,W
4C1C:  MOVWF  FEA
4C1E:  MOVFF  FEF,7D9
4C22:  MOVFF  03,FEA
4C26:  MOVFF  01,FE9
4C2A:  MOVFF  7D9,FEF
....................         state[13] = buf1; 
4C2E:  MOVLW  0D
4C30:  ADDWF  xCC,W
4C32:  MOVWF  FE9
4C34:  MOVLW  00
4C36:  ADDWFC xCD,W
4C38:  MOVWF  FEA
4C3A:  MOVFF  7D1,FEF
....................      
....................         buf1 = state[2]; 
4C3E:  MOVLW  02
4C40:  ADDWF  xCC,W
4C42:  MOVWF  FE9
4C44:  MOVLW  00
4C46:  ADDWFC xCD,W
4C48:  MOVWF  FEA
4C4A:  MOVFF  FEF,7D1
....................         buf2 = state[6]; 
4C4E:  MOVLW  06
4C50:  ADDWF  xCC,W
4C52:  MOVWF  FE9
4C54:  MOVLW  00
4C56:  ADDWFC xCD,W
4C58:  MOVWF  FEA
4C5A:  MOVFF  FEF,7D2
....................         state[2] = state[10]; 
4C5E:  MOVLW  02
4C60:  ADDWF  xCC,W
4C62:  MOVWF  01
4C64:  MOVLW  00
4C66:  ADDWFC xCD,W
4C68:  MOVWF  03
4C6A:  MOVLW  0A
4C6C:  ADDWF  xCC,W
4C6E:  MOVWF  FE9
4C70:  MOVLW  00
4C72:  ADDWFC xCD,W
4C74:  MOVWF  FEA
4C76:  MOVFF  FEF,7D9
4C7A:  MOVFF  03,FEA
4C7E:  MOVFF  01,FE9
4C82:  MOVFF  7D9,FEF
....................         state[6] = state[14]; 
4C86:  MOVLW  06
4C88:  ADDWF  xCC,W
4C8A:  MOVWF  01
4C8C:  MOVLW  00
4C8E:  ADDWFC xCD,W
4C90:  MOVWF  03
4C92:  MOVLW  0E
4C94:  ADDWF  xCC,W
4C96:  MOVWF  FE9
4C98:  MOVLW  00
4C9A:  ADDWFC xCD,W
4C9C:  MOVWF  FEA
4C9E:  MOVFF  FEF,7D9
4CA2:  MOVFF  03,FEA
4CA6:  MOVFF  01,FE9
4CAA:  MOVFF  7D9,FEF
....................         state[10] = buf1; 
4CAE:  MOVLW  0A
4CB0:  ADDWF  xCC,W
4CB2:  MOVWF  FE9
4CB4:  MOVLW  00
4CB6:  ADDWFC xCD,W
4CB8:  MOVWF  FEA
4CBA:  MOVFF  7D1,FEF
....................         state[14] = buf2; 
4CBE:  MOVLW  0E
4CC0:  ADDWF  xCC,W
4CC2:  MOVWF  FE9
4CC4:  MOVLW  00
4CC6:  ADDWFC xCD,W
4CC8:  MOVWF  FEA
4CCA:  MOVFF  7D2,FEF
....................      
....................         buf1 = state[15]; 
4CCE:  MOVLW  0F
4CD0:  ADDWF  xCC,W
4CD2:  MOVWF  FE9
4CD4:  MOVLW  00
4CD6:  ADDWFC xCD,W
4CD8:  MOVWF  FEA
4CDA:  MOVFF  FEF,7D1
....................         state[15] = state[11]; 
4CDE:  MOVLW  0F
4CE0:  ADDWF  xCC,W
4CE2:  MOVWF  01
4CE4:  MOVLW  00
4CE6:  ADDWFC xCD,W
4CE8:  MOVWF  03
4CEA:  MOVLW  0B
4CEC:  ADDWF  xCC,W
4CEE:  MOVWF  FE9
4CF0:  MOVLW  00
4CF2:  ADDWFC xCD,W
4CF4:  MOVWF  FEA
4CF6:  MOVFF  FEF,7D9
4CFA:  MOVFF  03,FEA
4CFE:  MOVFF  01,FE9
4D02:  MOVFF  7D9,FEF
....................         state[11] = state[7]; 
4D06:  MOVLW  0B
4D08:  ADDWF  xCC,W
4D0A:  MOVWF  01
4D0C:  MOVLW  00
4D0E:  ADDWFC xCD,W
4D10:  MOVWF  03
4D12:  MOVLW  07
4D14:  ADDWF  xCC,W
4D16:  MOVWF  FE9
4D18:  MOVLW  00
4D1A:  ADDWFC xCD,W
4D1C:  MOVWF  FEA
4D1E:  MOVFF  FEF,7D9
4D22:  MOVFF  03,FEA
4D26:  MOVFF  01,FE9
4D2A:  MOVFF  7D9,FEF
....................         state[7] = state[3]; 
4D2E:  MOVLW  07
4D30:  ADDWF  xCC,W
4D32:  MOVWF  01
4D34:  MOVLW  00
4D36:  ADDWFC xCD,W
4D38:  MOVWF  03
4D3A:  MOVLW  03
4D3C:  ADDWF  xCC,W
4D3E:  MOVWF  FE9
4D40:  MOVLW  00
4D42:  ADDWFC xCD,W
4D44:  MOVWF  FEA
4D46:  MOVFF  FEF,7D9
4D4A:  MOVFF  03,FEA
4D4E:  MOVFF  01,FE9
4D52:  MOVFF  7D9,FEF
....................         state[3] = buf1; 
4D56:  MOVLW  03
4D58:  ADDWF  xCC,W
4D5A:  MOVWF  FE9
4D5C:  MOVLW  00
4D5E:  ADDWFC xCD,W
4D60:  MOVWF  FEA
4D62:  MOVFF  7D1,FEF
....................     } 
....................      
....................     //mixcol - inv mix 
....................     if (((round > 0) && (dir != 0)) || ((round < 9) && (dir == 0)))  
4D66:  MOVF   xD5,F
4D68:  BZ    4D6E
4D6A:  MOVF   xD0,F
4D6C:  BNZ   4D7C
4D6E:  MOVF   xD5,W
4D70:  SUBLW  08
4D72:  BTFSS  FD8.0
4D74:  BRA    507C
4D76:  MOVF   xD0,F
4D78:  BTFSS  FD8.2
4D7A:  BRA    507C
....................     { 
....................           for (i=0; i <4; i++) 
4D7C:  CLRF   xD6
4D7E:  MOVF   xD6,W
4D80:  SUBLW  03
4D82:  BTFSS  FD8.0
4D84:  BRA    507C
....................           { 
....................                 buf4 = (unsigned int8)(i << 2); 
4D86:  RLCF   xD6,W
4D88:  MOVWF  xD4
4D8A:  RLCF   xD4,F
4D8C:  MOVLW  FC
4D8E:  ANDWF  xD4,F
....................                 if (dir != 0) 
4D90:  MOVF   xD0,F
4D92:  BZ    4E7C
....................                 { 
....................                       // precompute for decryption 
....................                       buf1 = galois_mul2(galois_mul2((unsigned int8)(state[buf4]^state[buf4+2]))); 
4D94:  CLRF   03
4D96:  MOVF   xD4,W
4D98:  ADDWF  xCC,W
4D9A:  MOVWF  FE9
4D9C:  MOVF   xCD,W
4D9E:  ADDWFC 03,W
4DA0:  MOVWF  FEA
4DA2:  MOVFF  FEF,7D7
4DA6:  MOVLW  02
4DA8:  ADDWF  xD4,W
4DAA:  CLRF   03
4DAC:  ADDWF  xCC,W
4DAE:  MOVWF  FE9
4DB0:  MOVF   xCD,W
4DB2:  ADDWFC 03,W
4DB4:  MOVWF  FEA
4DB6:  MOVF   FEF,W
4DB8:  XORWF  xD7,F
4DBA:  CLRF   xDA
4DBC:  MOVFF  7D7,7D9
4DC0:  MOVLB  0
4DC2:  RCALL  4790
4DC4:  MOVFF  02,7D8
4DC8:  MOVFF  01,7D7
4DCC:  MOVFF  02,7DA
4DD0:  MOVFF  01,7D9
4DD4:  RCALL  4790
4DD6:  MOVFF  01,7D1
....................                       buf2 = galois_mul2(galois_mul2((unsigned int8)(state[buf4+1]^state[buf4+3]))); 
4DDA:  MOVLW  01
4DDC:  MOVLB  7
4DDE:  ADDWF  xD4,W
4DE0:  CLRF   03
4DE2:  ADDWF  xCC,W
4DE4:  MOVWF  FE9
4DE6:  MOVF   xCD,W
4DE8:  ADDWFC 03,W
4DEA:  MOVWF  FEA
4DEC:  MOVFF  FEF,7D7
4DF0:  MOVLW  03
4DF2:  ADDWF  xD4,W
4DF4:  CLRF   03
4DF6:  ADDWF  xCC,W
4DF8:  MOVWF  FE9
4DFA:  MOVF   xCD,W
4DFC:  ADDWFC 03,W
4DFE:  MOVWF  FEA
4E00:  MOVF   FEF,W
4E02:  XORWF  xD7,F
4E04:  CLRF   xDA
4E06:  MOVFF  7D7,7D9
4E0A:  MOVLB  0
4E0C:  RCALL  4790
4E0E:  MOVFF  02,7D8
4E12:  MOVFF  01,7D7
4E16:  MOVFF  02,7DA
4E1A:  MOVFF  01,7D9
4E1E:  RCALL  4790
4E20:  MOVFF  01,7D2
....................                       state[buf4] ^= buf1;  
4E24:  CLRF   03
4E26:  MOVLB  7
4E28:  MOVF   xD4,W
4E2A:  ADDWF  xCC,W
4E2C:  MOVWF  FE9
4E2E:  MOVF   xCD,W
4E30:  ADDWFC 03,W
4E32:  MOVWF  FEA
4E34:  MOVF   FEF,W
4E36:  XORWF  xD1,W
4E38:  MOVWF  FEF
....................                       state[buf4+1] ^= buf2;  
4E3A:  MOVLW  01
4E3C:  ADDWF  xD4,W
4E3E:  CLRF   03
4E40:  ADDWF  xCC,W
4E42:  MOVWF  FE9
4E44:  MOVF   xCD,W
4E46:  ADDWFC 03,W
4E48:  MOVWF  FEA
4E4A:  MOVF   FEF,W
4E4C:  XORWF  xD2,W
4E4E:  MOVWF  FEF
....................                       state[buf4+2] ^= buf1;  
4E50:  MOVLW  02
4E52:  ADDWF  xD4,W
4E54:  CLRF   03
4E56:  ADDWF  xCC,W
4E58:  MOVWF  FE9
4E5A:  MOVF   xCD,W
4E5C:  ADDWFC 03,W
4E5E:  MOVWF  FEA
4E60:  MOVF   FEF,W
4E62:  XORWF  xD1,W
4E64:  MOVWF  FEF
....................                       state[buf4+3] ^= buf2;  
4E66:  MOVLW  03
4E68:  ADDWF  xD4,W
4E6A:  CLRF   03
4E6C:  ADDWF  xCC,W
4E6E:  MOVWF  FE9
4E70:  MOVF   xCD,W
4E72:  ADDWFC 03,W
4E74:  MOVWF  FEA
4E76:  MOVF   FEF,W
4E78:  XORWF  xD2,W
4E7A:  MOVWF  FEF
....................                 } 
....................                 // in all cases 
....................                 buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
4E7C:  CLRF   03
4E7E:  MOVF   xD4,W
4E80:  ADDWF  xCC,W
4E82:  MOVWF  FE9
4E84:  MOVF   xCD,W
4E86:  ADDWFC 03,W
4E88:  MOVWF  FEA
4E8A:  MOVFF  FEF,7D7
4E8E:  MOVLW  01
4E90:  ADDWF  xD4,W
4E92:  CLRF   03
4E94:  ADDWF  xCC,W
4E96:  MOVWF  FE9
4E98:  MOVF   xCD,W
4E9A:  ADDWFC 03,W
4E9C:  MOVWF  FEA
4E9E:  MOVF   FEF,W
4EA0:  XORWF  xD7,F
4EA2:  MOVLW  02
4EA4:  ADDWF  xD4,W
4EA6:  CLRF   03
4EA8:  ADDWF  xCC,W
4EAA:  MOVWF  FE9
4EAC:  MOVF   xCD,W
4EAE:  ADDWFC 03,W
4EB0:  MOVWF  FEA
4EB2:  MOVF   FEF,W
4EB4:  XORWF  xD7,F
4EB6:  MOVLW  03
4EB8:  ADDWF  xD4,W
4EBA:  CLRF   03
4EBC:  ADDWF  xCC,W
4EBE:  MOVWF  FE9
4EC0:  MOVF   xCD,W
4EC2:  ADDWFC 03,W
4EC4:  MOVWF  FEA
4EC6:  MOVF   FEF,W
4EC8:  XORWF  xD7,W
4ECA:  MOVWF  xD1
....................                 buf2 = state[buf4]; 
4ECC:  CLRF   03
4ECE:  MOVF   xD4,W
4ED0:  ADDWF  xCC,W
4ED2:  MOVWF  FE9
4ED4:  MOVF   xCD,W
4ED6:  ADDWFC 03,W
4ED8:  MOVWF  FEA
4EDA:  MOVFF  FEF,7D2
....................                 buf3 = state[buf4]^state[buf4+1];  
4EDE:  CLRF   03
4EE0:  MOVF   xD4,W
4EE2:  ADDWF  xCC,W
4EE4:  MOVWF  FE9
4EE6:  MOVF   xCD,W
4EE8:  ADDWFC 03,W
4EEA:  MOVWF  FEA
4EEC:  MOVFF  FEF,7D7
4EF0:  MOVLW  01
4EF2:  ADDWF  xD4,W
4EF4:  CLRF   03
4EF6:  ADDWF  xCC,W
4EF8:  MOVWF  FE9
4EFA:  MOVF   xCD,W
4EFC:  ADDWFC 03,W
4EFE:  MOVWF  FEA
4F00:  MOVF   FEF,W
4F02:  XORWF  xD7,W
4F04:  MOVWF  xD3
....................                 buf3=galois_mul2(buf3);  
4F06:  CLRF   xDA
4F08:  MOVFF  7D3,7D9
4F0C:  MOVLB  0
4F0E:  RCALL  4790
4F10:  MOVFF  01,7D3
....................                 state[buf4] = state[buf4] ^ buf3 ^ buf1; 
4F14:  CLRF   03
4F16:  MOVLB  7
4F18:  MOVF   xD4,W
4F1A:  ADDWF  xCC,W
4F1C:  MOVWF  01
4F1E:  MOVF   xCD,W
4F20:  ADDWFC 03,F
4F22:  MOVFF  03,7D8
4F26:  CLRF   03
4F28:  MOVF   xD4,W
4F2A:  ADDWF  xCC,W
4F2C:  MOVWF  FE9
4F2E:  MOVF   xCD,W
4F30:  ADDWFC 03,W
4F32:  MOVWF  FEA
4F34:  MOVF   FEF,W
4F36:  XORWF  xD3,W
4F38:  XORWF  xD1,W
4F3A:  MOVFF  7D8,FEA
4F3E:  MOVFF  01,FE9
4F42:  MOVWF  FEF
....................                 buf3 = state[buf4+1]^state[buf4+2];  
4F44:  MOVLW  01
4F46:  ADDWF  xD4,W
4F48:  CLRF   03
4F4A:  ADDWF  xCC,W
4F4C:  MOVWF  FE9
4F4E:  MOVF   xCD,W
4F50:  ADDWFC 03,W
4F52:  MOVWF  FEA
4F54:  MOVFF  FEF,7D7
4F58:  MOVLW  02
4F5A:  ADDWF  xD4,W
4F5C:  CLRF   03
4F5E:  ADDWF  xCC,W
4F60:  MOVWF  FE9
4F62:  MOVF   xCD,W
4F64:  ADDWFC 03,W
4F66:  MOVWF  FEA
4F68:  MOVF   FEF,W
4F6A:  XORWF  xD7,W
4F6C:  MOVWF  xD3
....................                 buf3=galois_mul2(buf3);  
4F6E:  CLRF   xDA
4F70:  MOVFF  7D3,7D9
4F74:  MOVLB  0
4F76:  RCALL  4790
4F78:  MOVFF  01,7D3
....................                 state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
4F7C:  MOVLW  01
4F7E:  MOVLB  7
4F80:  ADDWF  xD4,W
4F82:  CLRF   03
4F84:  ADDWF  xCC,W
4F86:  MOVWF  01
4F88:  MOVF   xCD,W
4F8A:  ADDWFC 03,F
4F8C:  MOVFF  03,7D8
4F90:  MOVLW  01
4F92:  ADDWF  xD4,W
4F94:  CLRF   03
4F96:  ADDWF  xCC,W
4F98:  MOVWF  FE9
4F9A:  MOVF   xCD,W
4F9C:  ADDWFC 03,W
4F9E:  MOVWF  FEA
4FA0:  MOVF   FEF,W
4FA2:  XORWF  xD3,W
4FA4:  XORWF  xD1,W
4FA6:  MOVFF  7D8,FEA
4FAA:  MOVFF  01,FE9
4FAE:  MOVWF  FEF
....................                 buf3 = state[buf4+2]^state[buf4+3];  
4FB0:  MOVLW  02
4FB2:  ADDWF  xD4,W
4FB4:  CLRF   03
4FB6:  ADDWF  xCC,W
4FB8:  MOVWF  FE9
4FBA:  MOVF   xCD,W
4FBC:  ADDWFC 03,W
4FBE:  MOVWF  FEA
4FC0:  MOVFF  FEF,7D7
4FC4:  MOVLW  03
4FC6:  ADDWF  xD4,W
4FC8:  CLRF   03
4FCA:  ADDWF  xCC,W
4FCC:  MOVWF  FE9
4FCE:  MOVF   xCD,W
4FD0:  ADDWFC 03,W
4FD2:  MOVWF  FEA
4FD4:  MOVF   FEF,W
4FD6:  XORWF  xD7,W
4FD8:  MOVWF  xD3
....................                 buf3=galois_mul2(buf3);  
4FDA:  CLRF   xDA
4FDC:  MOVFF  7D3,7D9
4FE0:  MOVLB  0
4FE2:  CALL   4790
4FE6:  MOVFF  01,7D3
....................                 state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
4FEA:  MOVLW  02
4FEC:  MOVLB  7
4FEE:  ADDWF  xD4,W
4FF0:  CLRF   03
4FF2:  ADDWF  xCC,W
4FF4:  MOVWF  01
4FF6:  MOVF   xCD,W
4FF8:  ADDWFC 03,F
4FFA:  MOVFF  03,7D8
4FFE:  MOVLW  02
5000:  ADDWF  xD4,W
5002:  CLRF   03
5004:  ADDWF  xCC,W
5006:  MOVWF  FE9
5008:  MOVF   xCD,W
500A:  ADDWFC 03,W
500C:  MOVWF  FEA
500E:  MOVF   FEF,W
5010:  XORWF  xD3,W
5012:  XORWF  xD1,W
5014:  MOVFF  7D8,FEA
5018:  MOVFF  01,FE9
501C:  MOVWF  FEF
....................                 buf3 = state[buf4+3]^buf2;      
501E:  MOVLW  03
5020:  ADDWF  xD4,W
5022:  CLRF   03
5024:  ADDWF  xCC,W
5026:  MOVWF  FE9
5028:  MOVF   xCD,W
502A:  ADDWFC 03,W
502C:  MOVWF  FEA
502E:  MOVF   FEF,W
5030:  XORWF  xD2,W
5032:  MOVWF  xD3
....................                 buf3=galois_mul2(buf3);  
5034:  CLRF   xDA
5036:  MOVFF  7D3,7D9
503A:  MOVLB  0
503C:  CALL   4790
5040:  MOVFF  01,7D3
....................                 state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1;  
5044:  MOVLW  03
5046:  MOVLB  7
5048:  ADDWF  xD4,W
504A:  CLRF   03
504C:  ADDWF  xCC,W
504E:  MOVWF  01
5050:  MOVF   xCD,W
5052:  ADDWFC 03,F
5054:  MOVFF  03,7D8
5058:  MOVLW  03
505A:  ADDWF  xD4,W
505C:  CLRF   03
505E:  ADDWF  xCC,W
5060:  MOVWF  FE9
5062:  MOVF   xCD,W
5064:  ADDWFC 03,W
5066:  MOVWF  FEA
5068:  MOVF   FEF,W
506A:  XORWF  xD3,W
506C:  XORWF  xD1,W
506E:  MOVFF  7D8,FEA
5072:  MOVFF  01,FE9
5076:  MOVWF  FEF
....................           } 
5078:  INCF   xD6,F
507A:  BRA    4D7E
....................     } 
....................      
....................     if (dir != 0)  
507C:  MOVF   xD0,F
507E:  BTFSC  FD8.2
5080:  BRA    529C
....................     { 
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
5082:  MOVLW  0D
5084:  ADDWF  xCC,W
5086:  MOVWF  FE9
5088:  MOVLW  00
508A:  ADDWFC xCD,W
508C:  MOVWF  FEA
508E:  MOVFF  FEF,7D1
....................       state[13] = state[9]; 
5092:  MOVLW  0D
5094:  ADDWF  xCC,W
5096:  MOVWF  01
5098:  MOVLW  00
509A:  ADDWFC xCD,W
509C:  MOVWF  03
509E:  MOVLW  09
50A0:  ADDWF  xCC,W
50A2:  MOVWF  FE9
50A4:  MOVLW  00
50A6:  ADDWFC xCD,W
50A8:  MOVWF  FEA
50AA:  MOVFF  FEF,7D9
50AE:  MOVFF  03,FEA
50B2:  MOVFF  01,FE9
50B6:  MOVFF  7D9,FEF
....................       state[9] = state[5]; 
50BA:  MOVLW  09
50BC:  ADDWF  xCC,W
50BE:  MOVWF  01
50C0:  MOVLW  00
50C2:  ADDWFC xCD,W
50C4:  MOVWF  03
50C6:  MOVLW  05
50C8:  ADDWF  xCC,W
50CA:  MOVWF  FE9
50CC:  MOVLW  00
50CE:  ADDWFC xCD,W
50D0:  MOVWF  FEA
50D2:  MOVFF  FEF,7D9
50D6:  MOVFF  03,FEA
50DA:  MOVFF  01,FE9
50DE:  MOVFF  7D9,FEF
....................       state[5] = state[1]; 
50E2:  MOVLW  05
50E4:  ADDWF  xCC,W
50E6:  MOVWF  01
50E8:  MOVLW  00
50EA:  ADDWFC xCD,W
50EC:  MOVWF  03
50EE:  MOVLW  01
50F0:  ADDWF  xCC,W
50F2:  MOVWF  FE9
50F4:  MOVLW  00
50F6:  ADDWFC xCD,W
50F8:  MOVWF  FEA
50FA:  MOVFF  FEF,7D9
50FE:  MOVFF  03,FEA
5102:  MOVFF  01,FE9
5106:  MOVFF  7D9,FEF
....................       state[1] = buf1; 
510A:  MOVLW  01
510C:  ADDWF  xCC,W
510E:  MOVWF  FE9
5110:  MOVLW  00
5112:  ADDWFC xCD,W
5114:  MOVWF  FEA
5116:  MOVFF  7D1,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
511A:  MOVLW  0A
511C:  ADDWF  xCC,W
511E:  MOVWF  FE9
5120:  MOVLW  00
5122:  ADDWFC xCD,W
5124:  MOVWF  FEA
5126:  MOVFF  FEF,7D1
....................       buf2 = state[14]; 
512A:  MOVLW  0E
512C:  ADDWF  xCC,W
512E:  MOVWF  FE9
5130:  MOVLW  00
5132:  ADDWFC xCD,W
5134:  MOVWF  FEA
5136:  MOVFF  FEF,7D2
....................       state[10] = state[2]; 
513A:  MOVLW  0A
513C:  ADDWF  xCC,W
513E:  MOVWF  01
5140:  MOVLW  00
5142:  ADDWFC xCD,W
5144:  MOVWF  03
5146:  MOVLW  02
5148:  ADDWF  xCC,W
514A:  MOVWF  FE9
514C:  MOVLW  00
514E:  ADDWFC xCD,W
5150:  MOVWF  FEA
5152:  MOVFF  FEF,7D9
5156:  MOVFF  03,FEA
515A:  MOVFF  01,FE9
515E:  MOVFF  7D9,FEF
....................       state[14] = state[6]; 
5162:  MOVLW  0E
5164:  ADDWF  xCC,W
5166:  MOVWF  01
5168:  MOVLW  00
516A:  ADDWFC xCD,W
516C:  MOVWF  03
516E:  MOVLW  06
5170:  ADDWF  xCC,W
5172:  MOVWF  FE9
5174:  MOVLW  00
5176:  ADDWFC xCD,W
5178:  MOVWF  FEA
517A:  MOVFF  FEF,7D9
517E:  MOVFF  03,FEA
5182:  MOVFF  01,FE9
5186:  MOVFF  7D9,FEF
....................       state[2] = buf1; 
518A:  MOVLW  02
518C:  ADDWF  xCC,W
518E:  MOVWF  FE9
5190:  MOVLW  00
5192:  ADDWFC xCD,W
5194:  MOVWF  FEA
5196:  MOVFF  7D1,FEF
....................       state[6] = buf2; 
519A:  MOVLW  06
519C:  ADDWF  xCC,W
519E:  MOVWF  FE9
51A0:  MOVLW  00
51A2:  ADDWFC xCD,W
51A4:  MOVWF  FEA
51A6:  MOVFF  7D2,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
51AA:  MOVLW  03
51AC:  ADDWF  xCC,W
51AE:  MOVWF  FE9
51B0:  MOVLW  00
51B2:  ADDWFC xCD,W
51B4:  MOVWF  FEA
51B6:  MOVFF  FEF,7D1
....................       state[3] = state[7]; 
51BA:  MOVLW  03
51BC:  ADDWF  xCC,W
51BE:  MOVWF  01
51C0:  MOVLW  00
51C2:  ADDWFC xCD,W
51C4:  MOVWF  03
51C6:  MOVLW  07
51C8:  ADDWF  xCC,W
51CA:  MOVWF  FE9
51CC:  MOVLW  00
51CE:  ADDWFC xCD,W
51D0:  MOVWF  FEA
51D2:  MOVFF  FEF,7D9
51D6:  MOVFF  03,FEA
51DA:  MOVFF  01,FE9
51DE:  MOVFF  7D9,FEF
....................       state[7] = state[11]; 
51E2:  MOVLW  07
51E4:  ADDWF  xCC,W
51E6:  MOVWF  01
51E8:  MOVLW  00
51EA:  ADDWFC xCD,W
51EC:  MOVWF  03
51EE:  MOVLW  0B
51F0:  ADDWF  xCC,W
51F2:  MOVWF  FE9
51F4:  MOVLW  00
51F6:  ADDWFC xCD,W
51F8:  MOVWF  FEA
51FA:  MOVFF  FEF,7D9
51FE:  MOVFF  03,FEA
5202:  MOVFF  01,FE9
5206:  MOVFF  7D9,FEF
....................       state[11] = state[15]; 
520A:  MOVLW  0B
520C:  ADDWF  xCC,W
520E:  MOVWF  01
5210:  MOVLW  00
5212:  ADDWFC xCD,W
5214:  MOVWF  03
5216:  MOVLW  0F
5218:  ADDWF  xCC,W
521A:  MOVWF  FE9
521C:  MOVLW  00
521E:  ADDWFC xCD,W
5220:  MOVWF  FEA
5222:  MOVFF  FEF,7D9
5226:  MOVFF  03,FEA
522A:  MOVFF  01,FE9
522E:  MOVFF  7D9,FEF
....................       state[15] = buf1;          
5232:  MOVLW  0F
5234:  ADDWF  xCC,W
5236:  MOVWF  FE9
5238:  MOVLW  00
523A:  ADDWFC xCD,W
523C:  MOVWF  FEA
523E:  MOVFF  7D1,FEF
....................             
....................       for (i = 0; i <16; i++){ 
5242:  CLRF   xD6
5244:  MOVF   xD6,W
5246:  SUBLW  0F
5248:  BNC   529A
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
524A:  CLRF   03
524C:  MOVF   xD6,W
524E:  ADDWF  xCC,W
5250:  MOVWF  01
5252:  MOVF   xCD,W
5254:  ADDWFC 03,F
5256:  MOVFF  01,7D7
525A:  MOVFF  03,7D8
525E:  CLRF   03
5260:  MOVF   xD6,W
5262:  ADDWF  xCC,W
5264:  MOVWF  FE9
5266:  MOVF   xCD,W
5268:  ADDWFC 03,W
526A:  MOVWF  FEA
526C:  CLRF   03
526E:  MOVF   FEF,W
5270:  MOVLB  0
5272:  CALL   01E0
5276:  MOVLB  7
5278:  MOVWF  xD9
527A:  CLRF   03
527C:  MOVF   xD6,W
527E:  ADDWF  xCE,W
5280:  MOVWF  FE9
5282:  MOVF   xCF,W
5284:  ADDWFC 03,W
5286:  MOVWF  FEA
5288:  MOVF   FEF,W
528A:  XORWF  xD9,W
528C:  MOVFF  7D8,FEA
5290:  MOVFF  7D7,FE9
5294:  MOVWF  FEF
....................       }  
5296:  INCF   xD6,F
5298:  BRA    5244
....................     }  
....................     else  
529A:  BRA    540E
....................     { 
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
529C:  MOVFF  7CE,01
52A0:  MOVFF  7CF,03
52A4:  MOVFF  7CE,7D7
52A8:  MOVFF  7CF,7D8
52AC:  MOVLW  0D
52AE:  ADDWF  xCE,W
52B0:  MOVWF  FE9
52B2:  MOVLW  00
52B4:  ADDWFC xCF,W
52B6:  MOVWF  FEA
52B8:  CLRF   03
52BA:  MOVF   FEF,W
52BC:  MOVLB  0
52BE:  CALL   00D0
52C2:  MOVLB  7
52C4:  MOVWF  xD9
52C6:  MOVFF  7CE,FE9
52CA:  MOVFF  7CF,FEA
52CE:  MOVF   FEF,W
52D0:  XORWF  xD9,F
52D2:  CLRF   03
52D4:  MOVF   xD5,W
52D6:  MOVLB  0
52D8:  CALL   02F0
52DC:  MOVWF  01
52DE:  MOVLB  7
52E0:  MOVF   xD9,W
52E2:  XORWF  01,W
52E4:  MOVFF  7D8,FEA
52E8:  MOVFF  7D7,FE9
52EC:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
52EE:  MOVLW  01
52F0:  ADDWF  xCE,W
52F2:  MOVWF  01
52F4:  MOVLW  00
52F6:  ADDWFC xCF,W
52F8:  MOVWF  03
52FA:  MOVFF  01,7D7
52FE:  MOVWF  xD8
5300:  MOVLW  0E
5302:  ADDWF  xCE,W
5304:  MOVWF  FE9
5306:  MOVLW  00
5308:  ADDWFC xCF,W
530A:  MOVWF  FEA
530C:  CLRF   03
530E:  MOVF   FEF,W
5310:  MOVLB  0
5312:  CALL   00D0
5316:  MOVLB  7
5318:  MOVWF  xD9
531A:  MOVLW  01
531C:  ADDWF  xCE,W
531E:  MOVWF  FE9
5320:  MOVLW  00
5322:  ADDWFC xCF,W
5324:  MOVWF  FEA
5326:  MOVF   FEF,W
5328:  XORWF  xD9,W
532A:  MOVFF  7D8,FEA
532E:  MOVFF  7D7,FE9
5332:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
5334:  MOVLW  02
5336:  ADDWF  xCE,W
5338:  MOVWF  01
533A:  MOVLW  00
533C:  ADDWFC xCF,W
533E:  MOVWF  03
5340:  MOVFF  01,7D7
5344:  MOVWF  xD8
5346:  MOVLW  0F
5348:  ADDWF  xCE,W
534A:  MOVWF  FE9
534C:  MOVLW  00
534E:  ADDWFC xCF,W
5350:  MOVWF  FEA
5352:  CLRF   03
5354:  MOVF   FEF,W
5356:  MOVLB  0
5358:  CALL   00D0
535C:  MOVLB  7
535E:  MOVWF  xD9
5360:  MOVLW  02
5362:  ADDWF  xCE,W
5364:  MOVWF  FE9
5366:  MOVLW  00
5368:  ADDWFC xCF,W
536A:  MOVWF  FEA
536C:  MOVF   FEF,W
536E:  XORWF  xD9,W
5370:  MOVFF  7D8,FEA
5374:  MOVFF  7D7,FE9
5378:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
537A:  MOVLW  03
537C:  ADDWF  xCE,W
537E:  MOVWF  01
5380:  MOVLW  00
5382:  ADDWFC xCF,W
5384:  MOVWF  03
5386:  MOVFF  01,7D7
538A:  MOVWF  xD8
538C:  MOVLW  0C
538E:  ADDWF  xCE,W
5390:  MOVWF  FE9
5392:  MOVLW  00
5394:  ADDWFC xCF,W
5396:  MOVWF  FEA
5398:  CLRF   03
539A:  MOVF   FEF,W
539C:  MOVLB  0
539E:  CALL   00D0
53A2:  MOVLB  7
53A4:  MOVWF  xD9
53A6:  MOVLW  03
53A8:  ADDWF  xCE,W
53AA:  MOVWF  FE9
53AC:  MOVLW  00
53AE:  ADDWFC xCF,W
53B0:  MOVWF  FEA
53B2:  MOVF   FEF,W
53B4:  XORWF  xD9,W
53B6:  MOVFF  7D8,FEA
53BA:  MOVFF  7D7,FE9
53BE:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
53C0:  MOVLW  04
53C2:  MOVWF  xD6
53C4:  MOVF   xD6,W
53C6:  SUBLW  0F
53C8:  BNC   540E
....................         key[i] = key[i] ^ key[i-4]; 
53CA:  CLRF   03
53CC:  MOVF   xD6,W
53CE:  ADDWF  xCE,W
53D0:  MOVWF  01
53D2:  MOVF   xCF,W
53D4:  ADDWFC 03,F
53D6:  MOVFF  03,7D8
53DA:  CLRF   03
53DC:  MOVF   xD6,W
53DE:  ADDWF  xCE,W
53E0:  MOVWF  FE9
53E2:  MOVF   xCF,W
53E4:  ADDWFC 03,W
53E6:  MOVWF  FEA
53E8:  MOVFF  FEF,7D9
53EC:  MOVLW  04
53EE:  SUBWF  xD6,W
53F0:  CLRF   03
53F2:  ADDWF  xCE,W
53F4:  MOVWF  FE9
53F6:  MOVF   xCF,W
53F8:  ADDWFC 03,W
53FA:  MOVWF  FEA
53FC:  MOVF   FEF,W
53FE:  XORWF  xD9,W
5400:  MOVFF  7D8,FEA
5404:  MOVFF  01,FE9
5408:  MOVWF  FEF
....................       } 
540A:  INCF   xD6,F
540C:  BRA    53C4
....................     } 
....................   } 
540E:  INCF   xD5,F
5410:  GOTO   49C6
....................   if (dir == 0)  
5414:  MOVF   xD0,F
5416:  BNZ   5462
....................   { 
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
5418:  CLRF   xD6
541A:  MOVF   xD6,W
541C:  SUBLW  0F
541E:  BNC   5462
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
5420:  CLRF   03
5422:  MOVF   xD6,W
5424:  ADDWF  xCC,W
5426:  MOVWF  01
5428:  MOVF   xCD,W
542A:  ADDWFC 03,F
542C:  MOVFF  03,7D8
5430:  CLRF   03
5432:  MOVF   xD6,W
5434:  ADDWF  xCC,W
5436:  MOVWF  FE9
5438:  MOVF   xCD,W
543A:  ADDWFC 03,W
543C:  MOVWF  FEA
543E:  MOVFF  FEF,7D9
5442:  CLRF   03
5444:  MOVF   xD6,W
5446:  ADDWF  xCE,W
5448:  MOVWF  FE9
544A:  MOVF   xCF,W
544C:  ADDWFC 03,W
544E:  MOVWF  FEA
5450:  MOVF   FEF,W
5452:  XORWF  xD9,W
5454:  MOVFF  7D8,FEA
5458:  MOVFF  01,FE9
545C:  MOVWF  FEF
....................     } // enf for 
545E:  INCF   xD6,F
5460:  BRA    541A
....................   } // end if (!dir) 
.................... } // end function 
5462:  MOVLB  0
5464:  RETURN 0
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                  
....................  
.................... #define     wideofkeystore      16 
.................... #define     key_numbyte         wideofkeystore-4 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 kp_st=0; 
.................... int8 type_KB=0; 
....................  
.................... int8 key_data[wideofkeystore]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1F04:  MOVLB  1
1F06:  INCF   x56,F
1F08:  MOVF   x56,W
1F0A:  SUBLW  01
1F0C:  BTFSC  FD8.0
1F0E:  BRA    20B0
....................        switch (col) { 
1F10:  MOVF   x59,W
1F12:  ADDLW  FB
1F14:  BC    1F98
1F16:  ADDLW  05
1F18:  MOVLB  0
1F1A:  GOTO   20BA
....................          case 0   :  
....................                     output_low(COL0); 
1F1E:  BCF    F92.5
1F20:  BCF    F89.5
....................                     output_high(COL1); 
1F22:  BCF    F92.3
1F24:  BSF    F89.3
....................                     output_high(COL2); 
1F26:  BCF    F92.2
1F28:  BSF    F89.2
....................                     output_high(COL3); 
1F2A:  BCF    F92.1
1F2C:  BSF    F89.1
....................                     output_high(COL4); 
1F2E:  BCF    F92.0
1F30:  BSF    F89.0
....................                     break; 
1F32:  MOVLB  1
1F34:  BRA    1F98
....................          case 1   :  
....................                     output_low(COL1); 
1F36:  BCF    F92.3
1F38:  BCF    F89.3
....................                     output_high(COL0); 
1F3A:  BCF    F92.5
1F3C:  BSF    F89.5
....................                     output_high(COL2); 
1F3E:  BCF    F92.2
1F40:  BSF    F89.2
....................                     output_high(COL3); 
1F42:  BCF    F92.1
1F44:  BSF    F89.1
....................                     output_high(COL4); 
1F46:  BCF    F92.0
1F48:  BSF    F89.0
....................                     break; 
1F4A:  MOVLB  1
1F4C:  BRA    1F98
....................          case 2   :  
....................                     output_low(COL2); 
1F4E:  BCF    F92.2
1F50:  BCF    F89.2
....................                     output_high(COL1); 
1F52:  BCF    F92.3
1F54:  BSF    F89.3
....................                     output_high(COL0); 
1F56:  BCF    F92.5
1F58:  BSF    F89.5
....................                     output_high(COL3); 
1F5A:  BCF    F92.1
1F5C:  BSF    F89.1
....................                     output_high(COL4); 
1F5E:  BCF    F92.0
1F60:  BSF    F89.0
....................                     break; 
1F62:  MOVLB  1
1F64:  BRA    1F98
....................          case 3   :  
....................                     output_low(COL3); 
1F66:  BCF    F92.1
1F68:  BCF    F89.1
....................                     output_high(COL1); 
1F6A:  BCF    F92.3
1F6C:  BSF    F89.3
....................                     output_high(COL2); 
1F6E:  BCF    F92.2
1F70:  BSF    F89.2
....................                     output_high(COL0); 
1F72:  BCF    F92.5
1F74:  BSF    F89.5
....................                     output_high(COL4); 
1F76:  BCF    F92.0
1F78:  BSF    F89.0
....................                     break; 
1F7A:  MOVLB  1
1F7C:  BRA    1F98
....................          case 4   :  
....................                     output_low(COL4); 
1F7E:  BCF    F92.0
1F80:  BCF    F89.0
....................                     output_high(COL1); 
1F82:  BCF    F92.3
1F84:  BSF    F89.3
....................                     output_high(COL2); 
1F86:  BCF    F92.2
1F88:  BSF    F89.2
....................                     output_high(COL3); 
1F8A:  BCF    F92.1
1F8C:  BSF    F89.1
....................                     output_high(COL0); 
1F8E:  BCF    F92.5
1F90:  BSF    F89.5
....................                     break; 
1F92:  MOVLB  1
1F94:  BRA    1F98
1F96:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
1F98:  BTFSS  x57.0
1F9A:  BRA    2016
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
1F9C:  BSF    F93.4
1F9E:  MOVLW  00
1FA0:  BTFSC  F81.4
1FA2:  MOVLW  01
1FA4:  MOVLB  8
1FA6:  MOVWF  x28
1FA8:  BSF    F93.5
1FAA:  MOVLW  00
1FAC:  BTFSC  F81.5
1FAE:  MOVLW  01
1FB0:  ANDWF  x28,F
1FB2:  BSF    F93.6
1FB4:  MOVLW  00
1FB6:  BTFSC  F81.6
1FB8:  MOVLW  01
1FBA:  ANDWF  x28,F
1FBC:  BSF    F93.7
1FBE:  MOVLW  00
1FC0:  BTFSC  F81.7
1FC2:  MOVLW  01
1FC4:  ANDWF  x28,W
1FC6:  BZ    2012
....................          { 
....................             kchar=last_key; 
1FC8:  MOVFF  158,826
....................             if(keydebug_en==0) 
1FCC:  MOVLB  1
1FCE:  MOVF   x3F,F
1FD0:  BNZ   2000
....................             { 
....................               //count_timer0=0; 
....................               charac_timeout=0; 
1FD2:  MOVLB  0
1FD4:  CLRF   xFC
1FD6:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
1FD8:  MOVLB  1
1FDA:  MOVF   x42,W
1FDC:  SUBLW  0B
1FDE:  BNC   1FF4
1FE0:  MOVF   x42,W
1FE2:  INCF   x42,F
1FE4:  CLRF   03
1FE6:  ADDLW  45
1FE8:  MOVWF  FE9
1FEA:  MOVLW  01
1FEC:  ADDWFC 03,W
1FEE:  MOVWF  FEA
1FF0:  MOVFF  826,FEF
....................                fputc(kchar,COM2); 
1FF4:  MOVFF  826,84F
1FF8:  MOVLB  0
1FFA:  CALL   15C8
....................             } 
....................                else fputc(kchar,COM2); 
1FFE:  BRA    200A
2000:  MOVFF  826,84F
2004:  MOVLB  0
2006:  CALL   15C8
....................            kbd_down=FALSE; 
200A:  MOVLB  1
200C:  BCF    x57.0
....................            last_key=0; 
200E:  CLRF   x58
2010:  MOVLB  8
....................          } 
....................        } else 
2012:  BRA    20AC
2014:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
2016:  BSF    F93.4
2018:  MOVLW  00
201A:  BTFSC  F81.4
201C:  MOVLW  01
201E:  MOVLB  8
2020:  MOVWF  x28
2022:  BSF    F93.5
2024:  MOVLW  00
2026:  BTFSC  F81.5
2028:  MOVLW  01
202A:  ANDWF  x28,F
202C:  BSF    F93.6
202E:  MOVLW  00
2030:  BTFSC  F81.6
2032:  MOVLW  01
2034:  ANDWF  x28,F
2036:  BSF    F93.7
2038:  MOVLW  00
203A:  BTFSC  F81.7
203C:  MOVLW  01
203E:  ANDWF  x28,W
2040:  BNZ   20A0
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
2042:  BSF    F93.4
2044:  BTFSC  F81.4
2046:  BRA    204C
....................                   row=0; 
2048:  CLRF   x27
....................                 else if(input(ROW1)==0) 
204A:  BRA    206E
204C:  BSF    F93.5
204E:  BTFSC  F81.5
2050:  BRA    2058
....................                   row=1; 
2052:  MOVLW  01
2054:  MOVWF  x27
....................                 else if(input(ROW2)==0) 
2056:  BRA    206E
2058:  BSF    F93.6
205A:  BTFSC  F81.6
205C:  BRA    2064
....................                   row=2; 
205E:  MOVLW  02
2060:  MOVWF  x27
....................                 else if(input(ROW3)==0) 
2062:  BRA    206E
2064:  BSF    F93.7
2066:  BTFSC  F81.7
2068:  BRA    206E
....................                   row=3; 
206A:  MOVLW  03
206C:  MOVWF  x27
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
206E:  MOVF   x27,W
2070:  MULLW  05
2072:  MOVF   FF3,W
2074:  CLRF   x29
2076:  MOVWF  x28
2078:  CLRF   03
207A:  MOVLB  1
207C:  MOVF   x59,W
207E:  MOVLB  8
2080:  ADDWF  x28,W
2082:  MOVWF  01
2084:  MOVF   x29,W
2086:  ADDWFC 03,F
2088:  MOVF   01,W
208A:  MOVLB  0
208C:  CALL   030A
2090:  MOVFF  FE8,158
....................                 kbd_down = TRUE; 
2094:  MOVLB  1
2096:  BSF    x57.0
....................                 set_tris_a(0xff); 
2098:  MOVLW  FF
209A:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
209C:  BRA    20AC
209E:  MOVLB  8
....................                { 
....................                   ++col; 
20A0:  MOVLB  1
20A2:  INCF   x59,F
....................                   if(col==5) col=0; 
20A4:  MOVF   x59,W
20A6:  SUBLW  05
20A8:  BTFSC  FD8.2
20AA:  CLRF   x59
....................                } 
....................          } 
....................       kbd_call_count=0; 
20AC:  MOVLB  1
20AE:  CLRF   x56
....................    } 
....................   return(kchar); 
20B0:  MOVLB  8
20B2:  MOVFF  826,01
.................... } 
20B6:  MOVLB  0
20B8:  RETURN 0
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
20DE:  MOVLW  E0
20E0:  MOVLB  F
20E2:  MOVWF  x48
20E4:  BCF    FC2.6
20E6:  BCF    FC2.7
20E8:  MOVF   x49,W
20EA:  ANDLW  E0
20EC:  IORLW  17
20EE:  MOVWF  x49
....................    switch(col) 
....................    { 
20F0:  MOVLB  8
20F2:  MOVF   x43,W
20F4:  ADDLW  FA
20F6:  BC    21C2
20F8:  ADDLW  06
20FA:  MOVLB  0
20FC:  GOTO   21C6
....................       case 0: 
....................         set_adc_channel(4); 
2100:  MOVLW  10
2102:  MOVWF  01
2104:  MOVF   FC2,W
2106:  ANDLW  C3
2108:  IORWF  01,W
210A:  MOVWF  FC2
....................         adc=read_adc(); 
210C:  BSF    FC2.1
210E:  BTFSC  FC2.1
2110:  BRA    210E
2112:  MOVFF  FC4,844
....................         return adc; 
2116:  MOVLB  8
2118:  MOVFF  844,01
211C:  BRA    21C2
....................       break; 
211E:  BRA    21C2
....................       case 1: 
....................         set_adc_channel(3); 
2120:  MOVLW  0C
2122:  MOVWF  01
2124:  MOVF   FC2,W
2126:  ANDLW  C3
2128:  IORWF  01,W
212A:  MOVWF  FC2
....................         adc=read_adc(); 
212C:  BSF    FC2.1
212E:  BTFSC  FC2.1
2130:  BRA    212E
2132:  MOVFF  FC4,844
....................         return adc; 
2136:  MOVLB  8
2138:  MOVFF  844,01
213C:  BRA    21C2
....................       break; 
213E:  BRA    21C2
....................       case 2: 
....................         set_adc_channel(2); 
2140:  MOVLW  08
2142:  MOVWF  01
2144:  MOVF   FC2,W
2146:  ANDLW  C3
2148:  IORWF  01,W
214A:  MOVWF  FC2
....................         adc=read_adc(); 
214C:  BSF    FC2.1
214E:  BTFSC  FC2.1
2150:  BRA    214E
2152:  MOVFF  FC4,844
....................         return adc; 
2156:  MOVLB  8
2158:  MOVFF  844,01
215C:  BRA    21C2
....................       break; 
215E:  BRA    21C2
....................       case 3: 
....................         set_adc_channel(1); 
2160:  MOVLW  04
2162:  MOVWF  01
2164:  MOVF   FC2,W
2166:  ANDLW  C3
2168:  IORWF  01,W
216A:  MOVWF  FC2
....................         adc=read_adc(); 
216C:  BSF    FC2.1
216E:  BTFSC  FC2.1
2170:  BRA    216E
2172:  MOVFF  FC4,844
....................         return adc; 
2176:  MOVLB  8
2178:  MOVFF  844,01
217C:  BRA    21C2
....................       break; 
217E:  BRA    21C2
....................       case 4: 
....................         set_adc_channel(0); 
2180:  MOVLW  00
2182:  MOVWF  01
2184:  MOVF   FC2,W
2186:  ANDLW  C3
2188:  IORWF  01,W
218A:  MOVWF  FC2
....................         adc=read_adc(); 
218C:  BSF    FC2.1
218E:  BTFSC  FC2.1
2190:  BRA    218E
2192:  MOVFF  FC4,844
....................         return adc; 
2196:  MOVLB  8
2198:  MOVFF  844,01
219C:  BRA    21C2
....................       break;      
219E:  BRA    21C2
....................       case 5: 
....................         set_adc_channel(11); 
21A0:  MOVLW  2C
21A2:  MOVWF  01
21A4:  MOVF   FC2,W
21A6:  ANDLW  C3
21A8:  IORWF  01,W
21AA:  MOVWF  FC2
....................         adc=read_adc(); 
21AC:  BSF    FC2.1
21AE:  BTFSC  FC2.1
21B0:  BRA    21AE
21B2:  MOVFF  FC4,844
....................         return adc; 
21B6:  MOVLB  8
21B8:  MOVFF  844,01
21BC:  BRA    21C2
....................       break;      
21BE:  BRA    21C2
21C0:  MOVLB  8
....................    } 
.................... } 
21C2:  MOVLB  0
21C4:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
2340:  MOVLB  8
2342:  CLRF   x2E
2344:  CLRF   x2D
2346:  CLRF   x2C
2348:  CLRF   x2B
234A:  CLRF   x32
234C:  CLRF   x31
234E:  CLRF   x30
2350:  CLRF   x2F
2352:  CLRF   x36
2354:  CLRF   x35
2356:  CLRF   x34
2358:  CLRF   x33
235A:  CLRF   x3A
235C:  CLRF   x39
235E:  CLRF   x38
2360:  CLRF   x37
2362:  CLRF   x3E
2364:  CLRF   x3D
2366:  CLRF   x3C
2368:  CLRF   x3B
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
236A:  CLRF   x2A
236C:  CLRF   x29
236E:  MOVF   x2A,W
2370:  SUBLW  01
2372:  BNC   23F0
2374:  BNZ   237C
2376:  MOVF   x29,W
2378:  SUBLW  F3
237A:  BNC   23F0
....................    { 
....................       col_0=read_col(0)+col_0; 
237C:  CLRF   x43
237E:  MOVLB  0
2380:  RCALL  20DE
2382:  MOVF   01,W
2384:  MOVLB  8
2386:  ADDWF  x2B,F
2388:  MOVLW  00
238A:  ADDWFC x2C,F
238C:  ADDWFC x2D,F
238E:  ADDWFC x2E,F
....................       col_1=read_col(1)+col_1; 
2390:  MOVLW  01
2392:  MOVWF  x43
2394:  MOVLB  0
2396:  RCALL  20DE
2398:  MOVF   01,W
239A:  MOVLB  8
239C:  ADDWF  x2F,F
239E:  MOVLW  00
23A0:  ADDWFC x30,F
23A2:  ADDWFC x31,F
23A4:  ADDWFC x32,F
....................       col_2=read_col(2)+col_2; 
23A6:  MOVLW  02
23A8:  MOVWF  x43
23AA:  MOVLB  0
23AC:  RCALL  20DE
23AE:  MOVF   01,W
23B0:  MOVLB  8
23B2:  ADDWF  x33,F
23B4:  MOVLW  00
23B6:  ADDWFC x34,F
23B8:  ADDWFC x35,F
23BA:  ADDWFC x36,F
....................       col_3=read_col(3)+col_3; 
23BC:  MOVLW  03
23BE:  MOVWF  x43
23C0:  MOVLB  0
23C2:  RCALL  20DE
23C4:  MOVF   01,W
23C6:  MOVLB  8
23C8:  ADDWF  x37,F
23CA:  MOVLW  00
23CC:  ADDWFC x38,F
23CE:  ADDWFC x39,F
23D0:  ADDWFC x3A,F
....................       col_4=read_col(4)+col_4; 
23D2:  MOVLW  04
23D4:  MOVWF  x43
23D6:  MOVLB  0
23D8:  RCALL  20DE
23DA:  MOVF   01,W
23DC:  MOVLB  8
23DE:  ADDWF  x3B,F
23E0:  MOVLW  00
23E2:  ADDWFC x3C,F
23E4:  ADDWFC x3D,F
23E6:  ADDWFC x3E,F
....................    } 
23E8:  INCF   x29,F
23EA:  BTFSC  FD8.2
23EC:  INCF   x2A,F
23EE:  BRA    236E
....................    col_0=col_0/500; 
23F0:  BCF    FD8.1
23F2:  MOVFF  82E,852
23F6:  MOVFF  82D,851
23FA:  MOVFF  82C,850
23FE:  MOVFF  82B,84F
2402:  CLRF   x56
2404:  CLRF   x55
2406:  MOVLW  01
2408:  MOVWF  x54
240A:  MOVLW  F4
240C:  MOVWF  x53
240E:  MOVLB  0
2410:  RCALL  21EC
2412:  MOVFF  03,82E
2416:  MOVFF  02,82D
241A:  MOVFF  01,82C
241E:  MOVFF  00,82B
....................    col_1=col_1/500; 
2422:  BCF    FD8.1
2424:  MOVFF  832,852
2428:  MOVFF  831,851
242C:  MOVFF  830,850
2430:  MOVFF  82F,84F
2434:  MOVLB  8
2436:  CLRF   x56
2438:  CLRF   x55
243A:  MOVLW  01
243C:  MOVWF  x54
243E:  MOVLW  F4
2440:  MOVWF  x53
2442:  MOVLB  0
2444:  RCALL  21EC
2446:  MOVFF  03,832
244A:  MOVFF  02,831
244E:  MOVFF  01,830
2452:  MOVFF  00,82F
....................    col_2=col_2/500; 
2456:  BCF    FD8.1
2458:  MOVFF  836,852
245C:  MOVFF  835,851
2460:  MOVFF  834,850
2464:  MOVFF  833,84F
2468:  MOVLB  8
246A:  CLRF   x56
246C:  CLRF   x55
246E:  MOVLW  01
2470:  MOVWF  x54
2472:  MOVLW  F4
2474:  MOVWF  x53
2476:  MOVLB  0
2478:  RCALL  21EC
247A:  MOVFF  03,836
247E:  MOVFF  02,835
2482:  MOVFF  01,834
2486:  MOVFF  00,833
....................    col_3=col_3/500; 
248A:  BCF    FD8.1
248C:  MOVFF  83A,852
2490:  MOVFF  839,851
2494:  MOVFF  838,850
2498:  MOVFF  837,84F
249C:  MOVLB  8
249E:  CLRF   x56
24A0:  CLRF   x55
24A2:  MOVLW  01
24A4:  MOVWF  x54
24A6:  MOVLW  F4
24A8:  MOVWF  x53
24AA:  MOVLB  0
24AC:  RCALL  21EC
24AE:  MOVFF  03,83A
24B2:  MOVFF  02,839
24B6:  MOVFF  01,838
24BA:  MOVFF  00,837
....................    col_4=col_4/500; 
24BE:  BCF    FD8.1
24C0:  MOVFF  83E,852
24C4:  MOVFF  83D,851
24C8:  MOVFF  83C,850
24CC:  MOVFF  83B,84F
24D0:  MOVLB  8
24D2:  CLRF   x56
24D4:  CLRF   x55
24D6:  MOVLW  01
24D8:  MOVWF  x54
24DA:  MOVLW  F4
24DC:  MOVWF  x53
24DE:  MOVLB  0
24E0:  RCALL  21EC
24E2:  MOVFF  03,83E
24E6:  MOVFF  02,83D
24EA:  MOVFF  01,83C
24EE:  MOVFF  00,83B
....................    if(keydebug_en) 
24F2:  MOVLB  1
24F4:  MOVF   x3F,F
24F6:  BTFSC  FD8.2
24F8:  BRA    2674
....................    { 
....................       fprintf(COM2,"\r\n");      
24FA:  MOVLW  0D
24FC:  MOVLB  8
24FE:  MOVWF  x4F
2500:  MOVLB  0
2502:  CALL   15C8
2506:  MOVLW  0A
2508:  MOVLB  8
250A:  MOVWF  x4F
250C:  MOVLB  0
250E:  CALL   15C8
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2512:  MOVLW  D6
2514:  MOVWF  FF6
2516:  MOVLW  04
2518:  MOVWF  FF7
251A:  MOVLW  07
251C:  MOVLB  8
251E:  MOVWF  x43
2520:  MOVLB  0
2522:  CALL   160E
2526:  MOVLW  41
2528:  MOVWF  FE9
252A:  MOVFF  82E,846
252E:  MOVFF  82D,845
2532:  MOVFF  82C,844
2536:  MOVFF  82B,843
253A:  RCALL  2280
253C:  MOVLW  0D
253E:  MOVLB  8
2540:  MOVWF  x4F
2542:  MOVLB  0
2544:  CALL   15C8
2548:  MOVLW  0A
254A:  MOVLB  8
254C:  MOVWF  x4F
254E:  MOVLB  0
2550:  CALL   15C8
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2554:  MOVLW  E4
2556:  MOVWF  FF6
2558:  MOVLW  04
255A:  MOVWF  FF7
255C:  MOVLW  07
255E:  MOVLB  8
2560:  MOVWF  x43
2562:  MOVLB  0
2564:  CALL   160E
2568:  MOVLW  41
256A:  MOVWF  FE9
256C:  MOVFF  832,846
2570:  MOVFF  831,845
2574:  MOVFF  830,844
2578:  MOVFF  82F,843
257C:  RCALL  2280
257E:  MOVLW  0D
2580:  MOVLB  8
2582:  MOVWF  x4F
2584:  MOVLB  0
2586:  CALL   15C8
258A:  MOVLW  0A
258C:  MOVLB  8
258E:  MOVWF  x4F
2590:  MOVLB  0
2592:  CALL   15C8
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2596:  MOVLW  F2
2598:  MOVWF  FF6
259A:  MOVLW  04
259C:  MOVWF  FF7
259E:  MOVLW  07
25A0:  MOVLB  8
25A2:  MOVWF  x43
25A4:  MOVLB  0
25A6:  CALL   160E
25AA:  MOVLW  41
25AC:  MOVWF  FE9
25AE:  MOVFF  836,846
25B2:  MOVFF  835,845
25B6:  MOVFF  834,844
25BA:  MOVFF  833,843
25BE:  RCALL  2280
25C0:  MOVLW  0D
25C2:  MOVLB  8
25C4:  MOVWF  x4F
25C6:  MOVLB  0
25C8:  CALL   15C8
25CC:  MOVLW  0A
25CE:  MOVLB  8
25D0:  MOVWF  x4F
25D2:  MOVLB  0
25D4:  CALL   15C8
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
25D8:  MOVLW  00
25DA:  MOVWF  FF6
25DC:  MOVLW  05
25DE:  MOVWF  FF7
25E0:  MOVLW  07
25E2:  MOVLB  8
25E4:  MOVWF  x43
25E6:  MOVLB  0
25E8:  CALL   160E
25EC:  MOVLW  41
25EE:  MOVWF  FE9
25F0:  MOVFF  83A,846
25F4:  MOVFF  839,845
25F8:  MOVFF  838,844
25FC:  MOVFF  837,843
2600:  RCALL  2280
2602:  MOVLW  0D
2604:  MOVLB  8
2606:  MOVWF  x4F
2608:  MOVLB  0
260A:  CALL   15C8
260E:  MOVLW  0A
2610:  MOVLB  8
2612:  MOVWF  x4F
2614:  MOVLB  0
2616:  CALL   15C8
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
261A:  MOVLW  0E
261C:  MOVWF  FF6
261E:  MOVLW  05
2620:  MOVWF  FF7
2622:  MOVLW  07
2624:  MOVLB  8
2626:  MOVWF  x43
2628:  MOVLB  0
262A:  CALL   160E
262E:  MOVLW  41
2630:  MOVWF  FE9
2632:  MOVFF  83E,846
2636:  MOVFF  83D,845
263A:  MOVFF  83C,844
263E:  MOVFF  83B,843
2642:  RCALL  2280
2644:  MOVLW  0D
2646:  MOVLB  8
2648:  MOVWF  x4F
264A:  MOVLB  0
264C:  CALL   15C8
2650:  MOVLW  0A
2652:  MOVLB  8
2654:  MOVWF  x4F
2656:  MOVLB  0
2658:  CALL   15C8
....................       fprintf(COM2,"\r\n"); 
265C:  MOVLW  0D
265E:  MOVLB  8
2660:  MOVWF  x4F
2662:  MOVLB  0
2664:  CALL   15C8
2668:  MOVLW  0A
266A:  MOVLB  8
266C:  MOVWF  x4F
266E:  MOVLB  0
2670:  CALL   15C8
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
2674:  MOVLB  8
2676:  MOVF   x2E,F
2678:  BNZ   2688
267A:  MOVF   x2D,F
267C:  BNZ   2688
267E:  MOVF   x2C,F
2680:  BNZ   2688
2682:  MOVF   x2B,W
2684:  SUBLW  05
2686:  BC    26E8
2688:  MOVF   x2E,F
268A:  BNZ   26E8
268C:  MOVF   x2D,F
268E:  BNZ   26E8
2690:  MOVF   x2C,F
2692:  BNZ   26E8
2694:  MOVF   x2B,W
2696:  SUBLW  3B
2698:  BNC   26E8
269A:  MOVF   x32,F
269C:  BNZ   26AC
269E:  MOVF   x31,F
26A0:  BNZ   26AC
26A2:  MOVF   x30,F
26A4:  BNZ   26AC
26A6:  MOVF   x2F,W
26A8:  SUBLW  64
26AA:  BC    26E8
26AC:  MOVF   x36,F
26AE:  BNZ   26BE
26B0:  MOVF   x35,F
26B2:  BNZ   26BE
26B4:  MOVF   x34,F
26B6:  BNZ   26BE
26B8:  MOVF   x33,W
26BA:  SUBLW  64
26BC:  BC    26E8
26BE:  MOVF   x3A,F
26C0:  BNZ   26D0
26C2:  MOVF   x39,F
26C4:  BNZ   26D0
26C6:  MOVF   x38,F
26C8:  BNZ   26D0
26CA:  MOVF   x37,W
26CC:  SUBLW  64
26CE:  BC    26E8
26D0:  MOVF   x3E,F
26D2:  BNZ   26E2
26D4:  MOVF   x3D,F
26D6:  BNZ   26E2
26D8:  MOVF   x3C,F
26DA:  BNZ   26E2
26DC:  MOVF   x3B,W
26DE:  SUBLW  64
26E0:  BC    26E8
26E2:  MOVLW  00
26E4:  MOVWF  01
26E6:  BRA    2966
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
26E8:  MOVF   x32,F
26EA:  BNZ   26FA
26EC:  MOVF   x31,F
26EE:  BNZ   26FA
26F0:  MOVF   x30,F
26F2:  BNZ   26FA
26F4:  MOVF   x2F,W
26F6:  SUBLW  05
26F8:  BC    275A
26FA:  MOVF   x32,F
26FC:  BNZ   275A
26FE:  MOVF   x31,F
2700:  BNZ   275A
2702:  MOVF   x30,F
2704:  BNZ   275A
2706:  MOVF   x2F,W
2708:  SUBLW  3B
270A:  BNC   275A
270C:  MOVF   x2E,F
270E:  BNZ   271E
2710:  MOVF   x2D,F
2712:  BNZ   271E
2714:  MOVF   x2C,F
2716:  BNZ   271E
2718:  MOVF   x2B,W
271A:  SUBLW  64
271C:  BC    275A
271E:  MOVF   x36,F
2720:  BNZ   2730
2722:  MOVF   x35,F
2724:  BNZ   2730
2726:  MOVF   x34,F
2728:  BNZ   2730
272A:  MOVF   x33,W
272C:  SUBLW  64
272E:  BC    275A
2730:  MOVF   x3A,F
2732:  BNZ   2742
2734:  MOVF   x39,F
2736:  BNZ   2742
2738:  MOVF   x38,F
273A:  BNZ   2742
273C:  MOVF   x37,W
273E:  SUBLW  64
2740:  BC    275A
2742:  MOVF   x3E,F
2744:  BNZ   2754
2746:  MOVF   x3D,F
2748:  BNZ   2754
274A:  MOVF   x3C,F
274C:  BNZ   2754
274E:  MOVF   x3B,W
2750:  SUBLW  64
2752:  BC    275A
2754:  MOVLW  01
2756:  MOVWF  01
2758:  BRA    2966
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
275A:  MOVF   x36,F
275C:  BNZ   276C
275E:  MOVF   x35,F
2760:  BNZ   276C
2762:  MOVF   x34,F
2764:  BNZ   276C
2766:  MOVF   x33,W
2768:  SUBLW  05
276A:  BC    27CC
276C:  MOVF   x36,F
276E:  BNZ   27CC
2770:  MOVF   x35,F
2772:  BNZ   27CC
2774:  MOVF   x34,F
2776:  BNZ   27CC
2778:  MOVF   x33,W
277A:  SUBLW  3B
277C:  BNC   27CC
277E:  MOVF   x32,F
2780:  BNZ   2790
2782:  MOVF   x31,F
2784:  BNZ   2790
2786:  MOVF   x30,F
2788:  BNZ   2790
278A:  MOVF   x2F,W
278C:  SUBLW  64
278E:  BC    27CC
2790:  MOVF   x2E,F
2792:  BNZ   27A2
2794:  MOVF   x2D,F
2796:  BNZ   27A2
2798:  MOVF   x2C,F
279A:  BNZ   27A2
279C:  MOVF   x2B,W
279E:  SUBLW  64
27A0:  BC    27CC
27A2:  MOVF   x3A,F
27A4:  BNZ   27B4
27A6:  MOVF   x39,F
27A8:  BNZ   27B4
27AA:  MOVF   x38,F
27AC:  BNZ   27B4
27AE:  MOVF   x37,W
27B0:  SUBLW  64
27B2:  BC    27CC
27B4:  MOVF   x3E,F
27B6:  BNZ   27C6
27B8:  MOVF   x3D,F
27BA:  BNZ   27C6
27BC:  MOVF   x3C,F
27BE:  BNZ   27C6
27C0:  MOVF   x3B,W
27C2:  SUBLW  64
27C4:  BC    27CC
27C6:  MOVLW  02
27C8:  MOVWF  01
27CA:  BRA    2966
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
27CC:  MOVF   x3A,F
27CE:  BNZ   27DE
27D0:  MOVF   x39,F
27D2:  BNZ   27DE
27D4:  MOVF   x38,F
27D6:  BNZ   27DE
27D8:  MOVF   x37,W
27DA:  SUBLW  05
27DC:  BC    283E
27DE:  MOVF   x3A,F
27E0:  BNZ   283E
27E2:  MOVF   x39,F
27E4:  BNZ   283E
27E6:  MOVF   x38,F
27E8:  BNZ   283E
27EA:  MOVF   x37,W
27EC:  SUBLW  3B
27EE:  BNC   283E
27F0:  MOVF   x32,F
27F2:  BNZ   2802
27F4:  MOVF   x31,F
27F6:  BNZ   2802
27F8:  MOVF   x30,F
27FA:  BNZ   2802
27FC:  MOVF   x2F,W
27FE:  SUBLW  64
2800:  BC    283E
2802:  MOVF   x36,F
2804:  BNZ   2814
2806:  MOVF   x35,F
2808:  BNZ   2814
280A:  MOVF   x34,F
280C:  BNZ   2814
280E:  MOVF   x33,W
2810:  SUBLW  64
2812:  BC    283E
2814:  MOVF   x2E,F
2816:  BNZ   2826
2818:  MOVF   x2D,F
281A:  BNZ   2826
281C:  MOVF   x2C,F
281E:  BNZ   2826
2820:  MOVF   x2B,W
2822:  SUBLW  64
2824:  BC    283E
2826:  MOVF   x3E,F
2828:  BNZ   2838
282A:  MOVF   x3D,F
282C:  BNZ   2838
282E:  MOVF   x3C,F
2830:  BNZ   2838
2832:  MOVF   x3B,W
2834:  SUBLW  64
2836:  BC    283E
2838:  MOVLW  03
283A:  MOVWF  01
283C:  BRA    2966
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
283E:  MOVF   x3E,F
2840:  BNZ   2850
2842:  MOVF   x3D,F
2844:  BNZ   2850
2846:  MOVF   x3C,F
2848:  BNZ   2850
284A:  MOVF   x3B,W
284C:  SUBLW  05
284E:  BC    28B0
2850:  MOVF   x3E,F
2852:  BNZ   28B0
2854:  MOVF   x3D,F
2856:  BNZ   28B0
2858:  MOVF   x3C,F
285A:  BNZ   28B0
285C:  MOVF   x3B,W
285E:  SUBLW  3B
2860:  BNC   28B0
2862:  MOVF   x32,F
2864:  BNZ   2874
2866:  MOVF   x31,F
2868:  BNZ   2874
286A:  MOVF   x30,F
286C:  BNZ   2874
286E:  MOVF   x2F,W
2870:  SUBLW  64
2872:  BC    28B0
2874:  MOVF   x36,F
2876:  BNZ   2886
2878:  MOVF   x35,F
287A:  BNZ   2886
287C:  MOVF   x34,F
287E:  BNZ   2886
2880:  MOVF   x33,W
2882:  SUBLW  64
2884:  BC    28B0
2886:  MOVF   x3A,F
2888:  BNZ   2898
288A:  MOVF   x39,F
288C:  BNZ   2898
288E:  MOVF   x38,F
2890:  BNZ   2898
2892:  MOVF   x37,W
2894:  SUBLW  64
2896:  BC    28B0
2898:  MOVF   x2E,F
289A:  BNZ   28AA
289C:  MOVF   x2D,F
289E:  BNZ   28AA
28A0:  MOVF   x2C,F
28A2:  BNZ   28AA
28A4:  MOVF   x2B,W
28A6:  SUBLW  64
28A8:  BC    28B0
28AA:  MOVLW  04
28AC:  MOVWF  01
28AE:  BRA    2966
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
28B0:  MOVF   x3E,F
28B2:  BNZ   28C4
28B4:  MOVF   x3D,F
28B6:  BNZ   28C4
28B8:  MOVF   x3C,F
28BA:  BNZ   28C4
28BC:  MOVF   x3B,W
28BE:  SUBLW  C8
28C0:  BTFSC  FD8.0
28C2:  BRA    2962
28C4:  MOVF   x2E,F
28C6:  BTFSS  FD8.2
28C8:  BRA    2962
28CA:  MOVF   x2D,F
28CC:  BTFSS  FD8.2
28CE:  BRA    2962
28D0:  MOVF   x2C,F
28D2:  BTFSS  FD8.2
28D4:  BRA    2962
28D6:  MOVF   x2B,W
28D8:  SUBLW  B3
28DA:  BNC   2962
28DC:  MOVF   x2E,F
28DE:  BNZ   28EE
28E0:  MOVF   x2D,F
28E2:  BNZ   28EE
28E4:  MOVF   x2C,F
28E6:  BNZ   28EE
28E8:  MOVF   x2B,W
28EA:  SUBLW  64
28EC:  BC    2962
28EE:  MOVF   x32,F
28F0:  BNZ   2962
28F2:  MOVF   x31,F
28F4:  BNZ   2962
28F6:  MOVF   x30,F
28F8:  BNZ   2962
28FA:  MOVF   x2F,W
28FC:  SUBLW  B3
28FE:  BNC   2962
2900:  MOVF   x32,F
2902:  BNZ   2912
2904:  MOVF   x31,F
2906:  BNZ   2912
2908:  MOVF   x30,F
290A:  BNZ   2912
290C:  MOVF   x2F,W
290E:  SUBLW  64
2910:  BC    2962
2912:  MOVF   x36,F
2914:  BNZ   2962
2916:  MOVF   x35,F
2918:  BNZ   2962
291A:  MOVF   x34,F
291C:  BNZ   2962
291E:  MOVF   x33,W
2920:  SUBLW  B3
2922:  BNC   2962
2924:  MOVF   x36,F
2926:  BNZ   2936
2928:  MOVF   x35,F
292A:  BNZ   2936
292C:  MOVF   x34,F
292E:  BNZ   2936
2930:  MOVF   x33,W
2932:  SUBLW  64
2934:  BC    2962
2936:  MOVF   x3A,F
2938:  BNZ   2962
293A:  MOVF   x39,F
293C:  BNZ   2962
293E:  MOVF   x38,F
2940:  BNZ   2962
2942:  MOVF   x37,W
2944:  SUBLW  B3
2946:  BNC   2962
2948:  MOVF   x3A,F
294A:  BNZ   295A
294C:  MOVF   x39,F
294E:  BNZ   295A
2950:  MOVF   x38,F
2952:  BNZ   295A
2954:  MOVF   x37,W
2956:  SUBLW  64
2958:  BC    2962
295A:  MOVLW  04
295C:  MOVWF  01
295E:  BRA    2966
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2960:  BRA    2966
2962:  MOVLW  FF
2964:  MOVWF  01
.................... } 
2966:  MOVLB  0
2968:  GOTO   31B2 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
296C:  MOVLB  8
296E:  CLRF   x2E
2970:  CLRF   x2D
2972:  CLRF   x2C
2974:  CLRF   x2B
2976:  CLRF   x32
2978:  CLRF   x31
297A:  CLRF   x30
297C:  CLRF   x2F
297E:  CLRF   x36
2980:  CLRF   x35
2982:  CLRF   x34
2984:  CLRF   x33
2986:  CLRF   x3A
2988:  CLRF   x39
298A:  CLRF   x38
298C:  CLRF   x37
298E:  CLRF   x3E
2990:  CLRF   x3D
2992:  CLRF   x3C
2994:  CLRF   x3B
2996:  CLRF   x42
2998:  CLRF   x41
299A:  CLRF   x40
299C:  CLRF   x3F
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
299E:  CLRF   x2A
29A0:  CLRF   x29
29A2:  MOVF   x2A,W
29A4:  SUBLW  01
29A6:  BNC   2A46
29A8:  BNZ   29B0
29AA:  MOVF   x29,W
29AC:  SUBLW  F3
29AE:  BNC   2A46
....................    { 
....................       col_0=read_col(0)+col_0; 
29B0:  CLRF   x43
29B2:  MOVLB  0
29B4:  CALL   20DE
29B8:  MOVF   01,W
29BA:  MOVLB  8
29BC:  ADDWF  x2B,F
29BE:  MOVLW  00
29C0:  ADDWFC x2C,F
29C2:  ADDWFC x2D,F
29C4:  ADDWFC x2E,F
....................       col_1=read_col(1)+col_1; 
29C6:  MOVLW  01
29C8:  MOVWF  x43
29CA:  MOVLB  0
29CC:  CALL   20DE
29D0:  MOVF   01,W
29D2:  MOVLB  8
29D4:  ADDWF  x2F,F
29D6:  MOVLW  00
29D8:  ADDWFC x30,F
29DA:  ADDWFC x31,F
29DC:  ADDWFC x32,F
....................       col_2=read_col(2)+col_2; 
29DE:  MOVLW  02
29E0:  MOVWF  x43
29E2:  MOVLB  0
29E4:  CALL   20DE
29E8:  MOVF   01,W
29EA:  MOVLB  8
29EC:  ADDWF  x33,F
29EE:  MOVLW  00
29F0:  ADDWFC x34,F
29F2:  ADDWFC x35,F
29F4:  ADDWFC x36,F
....................       col_3=read_col(3)+col_3; 
29F6:  MOVLW  03
29F8:  MOVWF  x43
29FA:  MOVLB  0
29FC:  CALL   20DE
2A00:  MOVF   01,W
2A02:  MOVLB  8
2A04:  ADDWF  x37,F
2A06:  MOVLW  00
2A08:  ADDWFC x38,F
2A0A:  ADDWFC x39,F
2A0C:  ADDWFC x3A,F
....................       col_4=read_col(4)+col_4; 
2A0E:  MOVLW  04
2A10:  MOVWF  x43
2A12:  MOVLB  0
2A14:  CALL   20DE
2A18:  MOVF   01,W
2A1A:  MOVLB  8
2A1C:  ADDWF  x3B,F
2A1E:  MOVLW  00
2A20:  ADDWFC x3C,F
2A22:  ADDWFC x3D,F
2A24:  ADDWFC x3E,F
....................       col_5=read_col(5)+col_5; 
2A26:  MOVLW  05
2A28:  MOVWF  x43
2A2A:  MOVLB  0
2A2C:  CALL   20DE
2A30:  MOVF   01,W
2A32:  MOVLB  8
2A34:  ADDWF  x3F,F
2A36:  MOVLW  00
2A38:  ADDWFC x40,F
2A3A:  ADDWFC x41,F
2A3C:  ADDWFC x42,F
....................    } 
2A3E:  INCF   x29,F
2A40:  BTFSC  FD8.2
2A42:  INCF   x2A,F
2A44:  BRA    29A2
....................    col_0=col_0/500; 
2A46:  BCF    FD8.1
2A48:  MOVFF  82E,852
2A4C:  MOVFF  82D,851
2A50:  MOVFF  82C,850
2A54:  MOVFF  82B,84F
2A58:  CLRF   x56
2A5A:  CLRF   x55
2A5C:  MOVLW  01
2A5E:  MOVWF  x54
2A60:  MOVLW  F4
2A62:  MOVWF  x53
2A64:  MOVLB  0
2A66:  CALL   21EC
2A6A:  MOVFF  03,82E
2A6E:  MOVFF  02,82D
2A72:  MOVFF  01,82C
2A76:  MOVFF  00,82B
....................    col_1=col_1/500; 
2A7A:  BCF    FD8.1
2A7C:  MOVFF  832,852
2A80:  MOVFF  831,851
2A84:  MOVFF  830,850
2A88:  MOVFF  82F,84F
2A8C:  MOVLB  8
2A8E:  CLRF   x56
2A90:  CLRF   x55
2A92:  MOVLW  01
2A94:  MOVWF  x54
2A96:  MOVLW  F4
2A98:  MOVWF  x53
2A9A:  MOVLB  0
2A9C:  CALL   21EC
2AA0:  MOVFF  03,832
2AA4:  MOVFF  02,831
2AA8:  MOVFF  01,830
2AAC:  MOVFF  00,82F
....................    col_2=col_2/500; 
2AB0:  BCF    FD8.1
2AB2:  MOVFF  836,852
2AB6:  MOVFF  835,851
2ABA:  MOVFF  834,850
2ABE:  MOVFF  833,84F
2AC2:  MOVLB  8
2AC4:  CLRF   x56
2AC6:  CLRF   x55
2AC8:  MOVLW  01
2ACA:  MOVWF  x54
2ACC:  MOVLW  F4
2ACE:  MOVWF  x53
2AD0:  MOVLB  0
2AD2:  CALL   21EC
2AD6:  MOVFF  03,836
2ADA:  MOVFF  02,835
2ADE:  MOVFF  01,834
2AE2:  MOVFF  00,833
....................    col_3=col_3/500; 
2AE6:  BCF    FD8.1
2AE8:  MOVFF  83A,852
2AEC:  MOVFF  839,851
2AF0:  MOVFF  838,850
2AF4:  MOVFF  837,84F
2AF8:  MOVLB  8
2AFA:  CLRF   x56
2AFC:  CLRF   x55
2AFE:  MOVLW  01
2B00:  MOVWF  x54
2B02:  MOVLW  F4
2B04:  MOVWF  x53
2B06:  MOVLB  0
2B08:  CALL   21EC
2B0C:  MOVFF  03,83A
2B10:  MOVFF  02,839
2B14:  MOVFF  01,838
2B18:  MOVFF  00,837
....................    col_4=col_4/500; 
2B1C:  BCF    FD8.1
2B1E:  MOVFF  83E,852
2B22:  MOVFF  83D,851
2B26:  MOVFF  83C,850
2B2A:  MOVFF  83B,84F
2B2E:  MOVLB  8
2B30:  CLRF   x56
2B32:  CLRF   x55
2B34:  MOVLW  01
2B36:  MOVWF  x54
2B38:  MOVLW  F4
2B3A:  MOVWF  x53
2B3C:  MOVLB  0
2B3E:  CALL   21EC
2B42:  MOVFF  03,83E
2B46:  MOVFF  02,83D
2B4A:  MOVFF  01,83C
2B4E:  MOVFF  00,83B
....................    col_5=col_5/500; 
2B52:  BCF    FD8.1
2B54:  MOVFF  842,852
2B58:  MOVFF  841,851
2B5C:  MOVFF  840,850
2B60:  MOVFF  83F,84F
2B64:  MOVLB  8
2B66:  CLRF   x56
2B68:  CLRF   x55
2B6A:  MOVLW  01
2B6C:  MOVWF  x54
2B6E:  MOVLW  F4
2B70:  MOVWF  x53
2B72:  MOVLB  0
2B74:  CALL   21EC
2B78:  MOVFF  03,842
2B7C:  MOVFF  02,841
2B80:  MOVFF  01,840
2B84:  MOVFF  00,83F
....................    if(keydebug_en) 
2B88:  MOVLB  1
2B8A:  MOVF   x3F,F
2B8C:  BTFSC  FD8.2
2B8E:  BRA    2D58
....................    { 
....................       fprintf(COM2,"\r\n");      
2B90:  MOVLW  0D
2B92:  MOVLB  8
2B94:  MOVWF  x4F
2B96:  MOVLB  0
2B98:  CALL   15C8
2B9C:  MOVLW  0A
2B9E:  MOVLB  8
2BA0:  MOVWF  x4F
2BA2:  MOVLB  0
2BA4:  CALL   15C8
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2BA8:  MOVLW  1C
2BAA:  MOVWF  FF6
2BAC:  MOVLW  05
2BAE:  MOVWF  FF7
2BB0:  MOVLW  07
2BB2:  MOVLB  8
2BB4:  MOVWF  x43
2BB6:  MOVLB  0
2BB8:  CALL   160E
2BBC:  MOVLW  41
2BBE:  MOVWF  FE9
2BC0:  MOVFF  82E,846
2BC4:  MOVFF  82D,845
2BC8:  MOVFF  82C,844
2BCC:  MOVFF  82B,843
2BD0:  CALL   2280
2BD4:  MOVLW  0D
2BD6:  MOVLB  8
2BD8:  MOVWF  x4F
2BDA:  MOVLB  0
2BDC:  CALL   15C8
2BE0:  MOVLW  0A
2BE2:  MOVLB  8
2BE4:  MOVWF  x4F
2BE6:  MOVLB  0
2BE8:  CALL   15C8
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2BEC:  MOVLW  2A
2BEE:  MOVWF  FF6
2BF0:  MOVLW  05
2BF2:  MOVWF  FF7
2BF4:  MOVLW  07
2BF6:  MOVLB  8
2BF8:  MOVWF  x43
2BFA:  MOVLB  0
2BFC:  CALL   160E
2C00:  MOVLW  41
2C02:  MOVWF  FE9
2C04:  MOVFF  832,846
2C08:  MOVFF  831,845
2C0C:  MOVFF  830,844
2C10:  MOVFF  82F,843
2C14:  CALL   2280
2C18:  MOVLW  0D
2C1A:  MOVLB  8
2C1C:  MOVWF  x4F
2C1E:  MOVLB  0
2C20:  CALL   15C8
2C24:  MOVLW  0A
2C26:  MOVLB  8
2C28:  MOVWF  x4F
2C2A:  MOVLB  0
2C2C:  CALL   15C8
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2C30:  MOVLW  38
2C32:  MOVWF  FF6
2C34:  MOVLW  05
2C36:  MOVWF  FF7
2C38:  MOVLW  07
2C3A:  MOVLB  8
2C3C:  MOVWF  x43
2C3E:  MOVLB  0
2C40:  CALL   160E
2C44:  MOVLW  41
2C46:  MOVWF  FE9
2C48:  MOVFF  836,846
2C4C:  MOVFF  835,845
2C50:  MOVFF  834,844
2C54:  MOVFF  833,843
2C58:  CALL   2280
2C5C:  MOVLW  0D
2C5E:  MOVLB  8
2C60:  MOVWF  x4F
2C62:  MOVLB  0
2C64:  CALL   15C8
2C68:  MOVLW  0A
2C6A:  MOVLB  8
2C6C:  MOVWF  x4F
2C6E:  MOVLB  0
2C70:  CALL   15C8
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2C74:  MOVLW  46
2C76:  MOVWF  FF6
2C78:  MOVLW  05
2C7A:  MOVWF  FF7
2C7C:  MOVLW  07
2C7E:  MOVLB  8
2C80:  MOVWF  x43
2C82:  MOVLB  0
2C84:  CALL   160E
2C88:  MOVLW  41
2C8A:  MOVWF  FE9
2C8C:  MOVFF  83A,846
2C90:  MOVFF  839,845
2C94:  MOVFF  838,844
2C98:  MOVFF  837,843
2C9C:  CALL   2280
2CA0:  MOVLW  0D
2CA2:  MOVLB  8
2CA4:  MOVWF  x4F
2CA6:  MOVLB  0
2CA8:  CALL   15C8
2CAC:  MOVLW  0A
2CAE:  MOVLB  8
2CB0:  MOVWF  x4F
2CB2:  MOVLB  0
2CB4:  CALL   15C8
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2CB8:  MOVLW  54
2CBA:  MOVWF  FF6
2CBC:  MOVLW  05
2CBE:  MOVWF  FF7
2CC0:  MOVLW  07
2CC2:  MOVLB  8
2CC4:  MOVWF  x43
2CC6:  MOVLB  0
2CC8:  CALL   160E
2CCC:  MOVLW  41
2CCE:  MOVWF  FE9
2CD0:  MOVFF  83E,846
2CD4:  MOVFF  83D,845
2CD8:  MOVFF  83C,844
2CDC:  MOVFF  83B,843
2CE0:  CALL   2280
2CE4:  MOVLW  0D
2CE6:  MOVLB  8
2CE8:  MOVWF  x4F
2CEA:  MOVLB  0
2CEC:  CALL   15C8
2CF0:  MOVLW  0A
2CF2:  MOVLB  8
2CF4:  MOVWF  x4F
2CF6:  MOVLB  0
2CF8:  CALL   15C8
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2CFC:  MOVLW  62
2CFE:  MOVWF  FF6
2D00:  MOVLW  05
2D02:  MOVWF  FF7
2D04:  MOVLW  07
2D06:  MOVLB  8
2D08:  MOVWF  x43
2D0A:  MOVLB  0
2D0C:  CALL   160E
2D10:  MOVLW  41
2D12:  MOVWF  FE9
2D14:  MOVFF  842,846
2D18:  MOVFF  841,845
2D1C:  MOVFF  840,844
2D20:  MOVFF  83F,843
2D24:  CALL   2280
2D28:  MOVLW  0D
2D2A:  MOVLB  8
2D2C:  MOVWF  x4F
2D2E:  MOVLB  0
2D30:  CALL   15C8
2D34:  MOVLW  0A
2D36:  MOVLB  8
2D38:  MOVWF  x4F
2D3A:  MOVLB  0
2D3C:  CALL   15C8
....................       fprintf(COM2,"\r\n"); 
2D40:  MOVLW  0D
2D42:  MOVLB  8
2D44:  MOVWF  x4F
2D46:  MOVLB  0
2D48:  CALL   15C8
2D4C:  MOVLW  0A
2D4E:  MOVLB  8
2D50:  MOVWF  x4F
2D52:  MOVLB  0
2D54:  CALL   15C8
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2D58:  MOVLB  8
2D5A:  MOVF   x2E,F
2D5C:  BNZ   2D6C
2D5E:  MOVF   x2D,F
2D60:  BNZ   2D6C
2D62:  MOVF   x2C,F
2D64:  BNZ   2D6C
2D66:  MOVF   x2B,W
2D68:  SUBLW  05
2D6A:  BC    2DDE
2D6C:  MOVF   x2E,F
2D6E:  BNZ   2DDE
2D70:  MOVF   x2D,F
2D72:  BNZ   2DDE
2D74:  MOVF   x2C,F
2D76:  BNZ   2DDE
2D78:  MOVF   x2B,W
2D7A:  SUBLW  3B
2D7C:  BNC   2DDE
2D7E:  MOVF   x32,F
2D80:  BNZ   2D90
2D82:  MOVF   x31,F
2D84:  BNZ   2D90
2D86:  MOVF   x30,F
2D88:  BNZ   2D90
2D8A:  MOVF   x2F,W
2D8C:  SUBLW  64
2D8E:  BC    2DDE
2D90:  MOVF   x36,F
2D92:  BNZ   2DA2
2D94:  MOVF   x35,F
2D96:  BNZ   2DA2
2D98:  MOVF   x34,F
2D9A:  BNZ   2DA2
2D9C:  MOVF   x33,W
2D9E:  SUBLW  64
2DA0:  BC    2DDE
2DA2:  MOVF   x3A,F
2DA4:  BNZ   2DB4
2DA6:  MOVF   x39,F
2DA8:  BNZ   2DB4
2DAA:  MOVF   x38,F
2DAC:  BNZ   2DB4
2DAE:  MOVF   x37,W
2DB0:  SUBLW  64
2DB2:  BC    2DDE
2DB4:  MOVF   x3E,F
2DB6:  BNZ   2DC6
2DB8:  MOVF   x3D,F
2DBA:  BNZ   2DC6
2DBC:  MOVF   x3C,F
2DBE:  BNZ   2DC6
2DC0:  MOVF   x3B,W
2DC2:  SUBLW  64
2DC4:  BC    2DDE
2DC6:  MOVF   x42,F
2DC8:  BNZ   2DD8
2DCA:  MOVF   x41,F
2DCC:  BNZ   2DD8
2DCE:  MOVF   x40,F
2DD0:  BNZ   2DD8
2DD2:  MOVF   x3F,W
2DD4:  SUBLW  64
2DD6:  BC    2DDE
2DD8:  MOVLW  00
2DDA:  MOVWF  01
2DDC:  BRA    3156
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2DDE:  MOVF   x32,F
2DE0:  BNZ   2DF0
2DE2:  MOVF   x31,F
2DE4:  BNZ   2DF0
2DE6:  MOVF   x30,F
2DE8:  BNZ   2DF0
2DEA:  MOVF   x2F,W
2DEC:  SUBLW  05
2DEE:  BC    2E62
2DF0:  MOVF   x32,F
2DF2:  BNZ   2E62
2DF4:  MOVF   x31,F
2DF6:  BNZ   2E62
2DF8:  MOVF   x30,F
2DFA:  BNZ   2E62
2DFC:  MOVF   x2F,W
2DFE:  SUBLW  3B
2E00:  BNC   2E62
2E02:  MOVF   x2E,F
2E04:  BNZ   2E14
2E06:  MOVF   x2D,F
2E08:  BNZ   2E14
2E0A:  MOVF   x2C,F
2E0C:  BNZ   2E14
2E0E:  MOVF   x2B,W
2E10:  SUBLW  64
2E12:  BC    2E62
2E14:  MOVF   x36,F
2E16:  BNZ   2E26
2E18:  MOVF   x35,F
2E1A:  BNZ   2E26
2E1C:  MOVF   x34,F
2E1E:  BNZ   2E26
2E20:  MOVF   x33,W
2E22:  SUBLW  64
2E24:  BC    2E62
2E26:  MOVF   x3A,F
2E28:  BNZ   2E38
2E2A:  MOVF   x39,F
2E2C:  BNZ   2E38
2E2E:  MOVF   x38,F
2E30:  BNZ   2E38
2E32:  MOVF   x37,W
2E34:  SUBLW  64
2E36:  BC    2E62
2E38:  MOVF   x3E,F
2E3A:  BNZ   2E4A
2E3C:  MOVF   x3D,F
2E3E:  BNZ   2E4A
2E40:  MOVF   x3C,F
2E42:  BNZ   2E4A
2E44:  MOVF   x3B,W
2E46:  SUBLW  64
2E48:  BC    2E62
2E4A:  MOVF   x42,F
2E4C:  BNZ   2E5C
2E4E:  MOVF   x41,F
2E50:  BNZ   2E5C
2E52:  MOVF   x40,F
2E54:  BNZ   2E5C
2E56:  MOVF   x3F,W
2E58:  SUBLW  64
2E5A:  BC    2E62
2E5C:  MOVLW  01
2E5E:  MOVWF  01
2E60:  BRA    3156
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2E62:  MOVF   x36,F
2E64:  BNZ   2E74
2E66:  MOVF   x35,F
2E68:  BNZ   2E74
2E6A:  MOVF   x34,F
2E6C:  BNZ   2E74
2E6E:  MOVF   x33,W
2E70:  SUBLW  05
2E72:  BC    2EE6
2E74:  MOVF   x36,F
2E76:  BNZ   2EE6
2E78:  MOVF   x35,F
2E7A:  BNZ   2EE6
2E7C:  MOVF   x34,F
2E7E:  BNZ   2EE6
2E80:  MOVF   x33,W
2E82:  SUBLW  3B
2E84:  BNC   2EE6
2E86:  MOVF   x32,F
2E88:  BNZ   2E98
2E8A:  MOVF   x31,F
2E8C:  BNZ   2E98
2E8E:  MOVF   x30,F
2E90:  BNZ   2E98
2E92:  MOVF   x2F,W
2E94:  SUBLW  64
2E96:  BC    2EE6
2E98:  MOVF   x2E,F
2E9A:  BNZ   2EAA
2E9C:  MOVF   x2D,F
2E9E:  BNZ   2EAA
2EA0:  MOVF   x2C,F
2EA2:  BNZ   2EAA
2EA4:  MOVF   x2B,W
2EA6:  SUBLW  64
2EA8:  BC    2EE6
2EAA:  MOVF   x3A,F
2EAC:  BNZ   2EBC
2EAE:  MOVF   x39,F
2EB0:  BNZ   2EBC
2EB2:  MOVF   x38,F
2EB4:  BNZ   2EBC
2EB6:  MOVF   x37,W
2EB8:  SUBLW  64
2EBA:  BC    2EE6
2EBC:  MOVF   x3E,F
2EBE:  BNZ   2ECE
2EC0:  MOVF   x3D,F
2EC2:  BNZ   2ECE
2EC4:  MOVF   x3C,F
2EC6:  BNZ   2ECE
2EC8:  MOVF   x3B,W
2ECA:  SUBLW  64
2ECC:  BC    2EE6
2ECE:  MOVF   x42,F
2ED0:  BNZ   2EE0
2ED2:  MOVF   x41,F
2ED4:  BNZ   2EE0
2ED6:  MOVF   x40,F
2ED8:  BNZ   2EE0
2EDA:  MOVF   x3F,W
2EDC:  SUBLW  64
2EDE:  BC    2EE6
2EE0:  MOVLW  02
2EE2:  MOVWF  01
2EE4:  BRA    3156
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2EE6:  MOVF   x3A,F
2EE8:  BNZ   2EF8
2EEA:  MOVF   x39,F
2EEC:  BNZ   2EF8
2EEE:  MOVF   x38,F
2EF0:  BNZ   2EF8
2EF2:  MOVF   x37,W
2EF4:  SUBLW  05
2EF6:  BC    2F6A
2EF8:  MOVF   x3A,F
2EFA:  BNZ   2F6A
2EFC:  MOVF   x39,F
2EFE:  BNZ   2F6A
2F00:  MOVF   x38,F
2F02:  BNZ   2F6A
2F04:  MOVF   x37,W
2F06:  SUBLW  3B
2F08:  BNC   2F6A
2F0A:  MOVF   x32,F
2F0C:  BNZ   2F1C
2F0E:  MOVF   x31,F
2F10:  BNZ   2F1C
2F12:  MOVF   x30,F
2F14:  BNZ   2F1C
2F16:  MOVF   x2F,W
2F18:  SUBLW  64
2F1A:  BC    2F6A
2F1C:  MOVF   x36,F
2F1E:  BNZ   2F2E
2F20:  MOVF   x35,F
2F22:  BNZ   2F2E
2F24:  MOVF   x34,F
2F26:  BNZ   2F2E
2F28:  MOVF   x33,W
2F2A:  SUBLW  64
2F2C:  BC    2F6A
2F2E:  MOVF   x2E,F
2F30:  BNZ   2F40
2F32:  MOVF   x2D,F
2F34:  BNZ   2F40
2F36:  MOVF   x2C,F
2F38:  BNZ   2F40
2F3A:  MOVF   x2B,W
2F3C:  SUBLW  64
2F3E:  BC    2F6A
2F40:  MOVF   x3E,F
2F42:  BNZ   2F52
2F44:  MOVF   x3D,F
2F46:  BNZ   2F52
2F48:  MOVF   x3C,F
2F4A:  BNZ   2F52
2F4C:  MOVF   x3B,W
2F4E:  SUBLW  64
2F50:  BC    2F6A
2F52:  MOVF   x42,F
2F54:  BNZ   2F64
2F56:  MOVF   x41,F
2F58:  BNZ   2F64
2F5A:  MOVF   x40,F
2F5C:  BNZ   2F64
2F5E:  MOVF   x3F,W
2F60:  SUBLW  64
2F62:  BC    2F6A
2F64:  MOVLW  03
2F66:  MOVWF  01
2F68:  BRA    3156
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
2F6A:  MOVF   x3E,F
2F6C:  BNZ   2F7C
2F6E:  MOVF   x3D,F
2F70:  BNZ   2F7C
2F72:  MOVF   x3C,F
2F74:  BNZ   2F7C
2F76:  MOVF   x3B,W
2F78:  SUBLW  05
2F7A:  BC    2FEE
2F7C:  MOVF   x3E,F
2F7E:  BNZ   2FEE
2F80:  MOVF   x3D,F
2F82:  BNZ   2FEE
2F84:  MOVF   x3C,F
2F86:  BNZ   2FEE
2F88:  MOVF   x3B,W
2F8A:  SUBLW  3B
2F8C:  BNC   2FEE
2F8E:  MOVF   x32,F
2F90:  BNZ   2FA0
2F92:  MOVF   x31,F
2F94:  BNZ   2FA0
2F96:  MOVF   x30,F
2F98:  BNZ   2FA0
2F9A:  MOVF   x2F,W
2F9C:  SUBLW  64
2F9E:  BC    2FEE
2FA0:  MOVF   x36,F
2FA2:  BNZ   2FB2
2FA4:  MOVF   x35,F
2FA6:  BNZ   2FB2
2FA8:  MOVF   x34,F
2FAA:  BNZ   2FB2
2FAC:  MOVF   x33,W
2FAE:  SUBLW  64
2FB0:  BC    2FEE
2FB2:  MOVF   x3A,F
2FB4:  BNZ   2FC4
2FB6:  MOVF   x39,F
2FB8:  BNZ   2FC4
2FBA:  MOVF   x38,F
2FBC:  BNZ   2FC4
2FBE:  MOVF   x37,W
2FC0:  SUBLW  64
2FC2:  BC    2FEE
2FC4:  MOVF   x2E,F
2FC6:  BNZ   2FD6
2FC8:  MOVF   x2D,F
2FCA:  BNZ   2FD6
2FCC:  MOVF   x2C,F
2FCE:  BNZ   2FD6
2FD0:  MOVF   x2B,W
2FD2:  SUBLW  64
2FD4:  BC    2FEE
2FD6:  MOVF   x42,F
2FD8:  BNZ   2FE8
2FDA:  MOVF   x41,F
2FDC:  BNZ   2FE8
2FDE:  MOVF   x40,F
2FE0:  BNZ   2FE8
2FE2:  MOVF   x3F,W
2FE4:  SUBLW  64
2FE6:  BC    2FEE
2FE8:  MOVLW  04
2FEA:  MOVWF  01
2FEC:  BRA    3156
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
2FEE:  MOVF   x42,F
2FF0:  BNZ   3000
2FF2:  MOVF   x41,F
2FF4:  BNZ   3000
2FF6:  MOVF   x40,F
2FF8:  BNZ   3000
2FFA:  MOVF   x3F,W
2FFC:  SUBLW  05
2FFE:  BC    3072
3000:  MOVF   x42,F
3002:  BNZ   3072
3004:  MOVF   x41,F
3006:  BNZ   3072
3008:  MOVF   x40,F
300A:  BNZ   3072
300C:  MOVF   x3F,W
300E:  SUBLW  3B
3010:  BNC   3072
3012:  MOVF   x32,F
3014:  BNZ   3024
3016:  MOVF   x31,F
3018:  BNZ   3024
301A:  MOVF   x30,F
301C:  BNZ   3024
301E:  MOVF   x2F,W
3020:  SUBLW  64
3022:  BC    3072
3024:  MOVF   x36,F
3026:  BNZ   3036
3028:  MOVF   x35,F
302A:  BNZ   3036
302C:  MOVF   x34,F
302E:  BNZ   3036
3030:  MOVF   x33,W
3032:  SUBLW  64
3034:  BC    3072
3036:  MOVF   x3A,F
3038:  BNZ   3048
303A:  MOVF   x39,F
303C:  BNZ   3048
303E:  MOVF   x38,F
3040:  BNZ   3048
3042:  MOVF   x37,W
3044:  SUBLW  64
3046:  BC    3072
3048:  MOVF   x3E,F
304A:  BNZ   305A
304C:  MOVF   x3D,F
304E:  BNZ   305A
3050:  MOVF   x3C,F
3052:  BNZ   305A
3054:  MOVF   x3B,W
3056:  SUBLW  64
3058:  BC    3072
305A:  MOVF   x2E,F
305C:  BNZ   306C
305E:  MOVF   x2D,F
3060:  BNZ   306C
3062:  MOVF   x2C,F
3064:  BNZ   306C
3066:  MOVF   x2B,W
3068:  SUBLW  64
306A:  BC    3072
306C:  MOVLW  05
306E:  MOVWF  01
3070:  BRA    3156
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
3072:  MOVF   x42,F
3074:  BNZ   3086
3076:  MOVF   x41,F
3078:  BNZ   3086
307A:  MOVF   x40,F
307C:  BNZ   3086
307E:  MOVF   x3F,W
3080:  SUBLW  C8
3082:  BTFSC  FD8.0
3084:  BRA    3152
3086:  MOVF   x2E,F
3088:  BTFSS  FD8.2
308A:  BRA    3152
308C:  MOVF   x2D,F
308E:  BTFSS  FD8.2
3090:  BRA    3152
3092:  MOVF   x2C,F
3094:  BTFSS  FD8.2
3096:  BRA    3152
3098:  MOVF   x2B,W
309A:  SUBLW  B3
309C:  BTFSS  FD8.0
309E:  BRA    3152
30A0:  MOVF   x2E,F
30A2:  BNZ   30B4
30A4:  MOVF   x2D,F
30A6:  BNZ   30B4
30A8:  MOVF   x2C,F
30AA:  BNZ   30B4
30AC:  MOVF   x2B,W
30AE:  SUBLW  64
30B0:  BTFSC  FD8.0
30B2:  BRA    3152
30B4:  MOVF   x32,F
30B6:  BTFSS  FD8.2
30B8:  BRA    3152
30BA:  MOVF   x31,F
30BC:  BTFSS  FD8.2
30BE:  BRA    3152
30C0:  MOVF   x30,F
30C2:  BTFSS  FD8.2
30C4:  BRA    3152
30C6:  MOVF   x2F,W
30C8:  SUBLW  B3
30CA:  BNC   3152
30CC:  MOVF   x32,F
30CE:  BNZ   30DE
30D0:  MOVF   x31,F
30D2:  BNZ   30DE
30D4:  MOVF   x30,F
30D6:  BNZ   30DE
30D8:  MOVF   x2F,W
30DA:  SUBLW  64
30DC:  BC    3152
30DE:  MOVF   x36,F
30E0:  BNZ   3152
30E2:  MOVF   x35,F
30E4:  BNZ   3152
30E6:  MOVF   x34,F
30E8:  BNZ   3152
30EA:  MOVF   x33,W
30EC:  SUBLW  B3
30EE:  BNC   3152
30F0:  MOVF   x36,F
30F2:  BNZ   3102
30F4:  MOVF   x35,F
30F6:  BNZ   3102
30F8:  MOVF   x34,F
30FA:  BNZ   3102
30FC:  MOVF   x33,W
30FE:  SUBLW  64
3100:  BC    3152
3102:  MOVF   x3A,F
3104:  BNZ   3152
3106:  MOVF   x39,F
3108:  BNZ   3152
310A:  MOVF   x38,F
310C:  BNZ   3152
310E:  MOVF   x37,W
3110:  SUBLW  B3
3112:  BNC   3152
3114:  MOVF   x3A,F
3116:  BNZ   3126
3118:  MOVF   x39,F
311A:  BNZ   3126
311C:  MOVF   x38,F
311E:  BNZ   3126
3120:  MOVF   x37,W
3122:  SUBLW  64
3124:  BC    3152
3126:  MOVF   x3E,F
3128:  BNZ   3152
312A:  MOVF   x3D,F
312C:  BNZ   3152
312E:  MOVF   x3C,F
3130:  BNZ   3152
3132:  MOVF   x3B,W
3134:  SUBLW  B3
3136:  BNC   3152
3138:  MOVF   x3E,F
313A:  BNZ   314A
313C:  MOVF   x3D,F
313E:  BNZ   314A
3140:  MOVF   x3C,F
3142:  BNZ   314A
3144:  MOVF   x3B,W
3146:  SUBLW  64
3148:  BC    3152
314A:  MOVLW  05
314C:  MOVWF  01
314E:  BRA    3156
....................    else return 0xff; 
3150:  BRA    3156
3152:  MOVLW  FF
3154:  MOVWF  01
.................... } 
3156:  MOVLB  0
3158:  GOTO   31BE (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
315C:  MOVLW  20
315E:  MOVLB  8
3160:  MOVWF  x27
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
3162:  BSF    F93.4
3164:  BTFSS  F81.4
3166:  BRA    317A
3168:  BSF    F93.5
316A:  BTFSS  F81.5
316C:  BRA    317A
316E:  BSF    F93.6
3170:  BTFSS  F81.6
3172:  BRA    317A
3174:  BSF    F93.7
3176:  BTFSC  F81.7
3178:  BRA    32DC
....................     { 
....................        if(input(ROW0)==0) 
317A:  BSF    F93.4
317C:  BTFSC  F81.4
317E:  BRA    3184
....................          row=0; 
3180:  CLRF   x28
....................        else if(input(ROW1)==0) 
3182:  BRA    31A6
3184:  BSF    F93.5
3186:  BTFSC  F81.5
3188:  BRA    3190
....................          row=1; 
318A:  MOVLW  01
318C:  MOVWF  x28
....................        else if(input(ROW2)==0) 
318E:  BRA    31A6
3190:  BSF    F93.6
3192:  BTFSC  F81.6
3194:  BRA    319C
....................          row=2; 
3196:  MOVLW  02
3198:  MOVWF  x28
....................        else if(input(ROW3)==0) 
319A:  BRA    31A6
319C:  BSF    F93.7
319E:  BTFSC  F81.7
31A0:  BRA    31A6
....................          row=3;      
31A2:  MOVLW  03
31A4:  MOVWF  x28
....................        if(type_KB==0)col=check_col(); 
31A6:  MOVLB  1
31A8:  MOVF   x44,F
31AA:  BNZ   31B8
31AC:  MOVLB  0
31AE:  GOTO   2340
31B2:  MOVFF  01,826
....................          else col=new_check_col(); 
31B6:  BRA    31C2
31B8:  MOVLB  0
31BA:  GOTO   296C
31BE:  MOVFF  01,826
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
31C2:  MOVLB  8
31C4:  INCFSZ x26,W
31C6:  BRA    31CA
31C8:  BRA    32AC
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
31CA:  MOVLB  1
31CC:  MOVF   x44,F
31CE:  BNZ   31F6
31D0:  MOVLB  8
31D2:  MOVF   x28,W
31D4:  MULLW  05
31D6:  MOVF   FF3,W
31D8:  CLRF   x2A
31DA:  MOVWF  x29
31DC:  CLRF   03
31DE:  MOVF   x26,W
31E0:  ADDWF  x29,W
31E2:  MOVWF  01
31E4:  MOVF   x2A,W
31E6:  ADDWFC 03,F
31E8:  MOVF   01,W
31EA:  MOVLB  0
31EC:  CALL   030A
31F0:  MOVFF  FE8,827
....................            else kchar =newKEYS[row][col]; 
31F4:  BRA    321A
31F6:  MOVLB  8
31F8:  MOVF   x28,W
31FA:  MULLW  06
31FC:  MOVF   FF3,W
31FE:  CLRF   x2A
3200:  MOVWF  x29
3202:  CLRF   03
3204:  MOVF   x26,W
3206:  ADDWF  x29,W
3208:  MOVWF  01
320A:  MOVF   x2A,W
320C:  ADDWFC 03,F
320E:  MOVF   01,W
3210:  MOVLB  0
3212:  CALL   032E
3216:  MOVFF  FE8,827
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
321A:  MOVLB  1
321C:  MOVF   x3F,F
321E:  BNZ   32A0
....................             { 
....................               charac_timeout=0; 
3220:  MOVLB  0
3222:  CLRF   xFC
3224:  CLRF   xFB
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
3226:  MOVLB  1
3228:  MOVF   x42,W
322A:  SUBLW  0B
322C:  BNC   3242
322E:  MOVF   x42,W
3230:  INCF   x42,F
3232:  CLRF   03
3234:  ADDLW  45
3236:  MOVWF  FE9
3238:  MOVLW  01
323A:  ADDWFC 03,W
323C:  MOVWF  FEA
323E:  MOVFF  827,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
3242:  MOVLW  70
3244:  MOVWF  FF6
3246:  MOVLW  05
3248:  MOVWF  FF7
324A:  MOVLW  09
324C:  MOVLB  8
324E:  MOVWF  x43
3250:  MOVLB  0
3252:  CALL   160E
3256:  MOVFF  142,82F
325A:  MOVLW  18
325C:  MOVLB  8
325E:  MOVWF  x30
3260:  MOVLB  0
3262:  CALL   173E
3266:  MOVLW  5D
3268:  MOVLB  8
326A:  MOVWF  x4F
326C:  MOVLB  0
326E:  CALL   15C8
3272:  MOVLW  20
3274:  MOVLB  8
3276:  MOVWF  x4F
3278:  MOVLB  0
327A:  CALL   15C8
327E:  MOVFF  827,84F
3282:  CALL   15C8
3286:  MOVLW  0D
3288:  MOVLB  8
328A:  MOVWF  x4F
328C:  MOVLB  0
328E:  CALL   15C8
3292:  MOVLW  0A
3294:  MOVLB  8
3296:  MOVWF  x4F
3298:  MOVLB  0
329A:  CALL   15C8
....................             } 
....................                else fputc(kchar,COM2); 
329E:  BRA    32AA
32A0:  MOVFF  827,84F
32A4:  MOVLB  0
32A6:  CALL   15C8
32AA:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
32AC:  BSF    F93.4
32AE:  BTFSS  F81.4
32B0:  BRA    32AC
32B2:  BSF    F93.5
32B4:  BTFSS  F81.5
32B6:  BRA    32AC
32B8:  BSF    F93.6
32BA:  BTFSS  F81.6
32BC:  BRA    32AC
32BE:  BSF    F93.7
32C0:  BTFSS  F81.7
32C2:  BRA    32AC
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
32C4:  BSF    F93.4
32C6:  BTFSS  F81.4
32C8:  BRA    32C4
32CA:  BSF    F93.5
32CC:  BTFSS  F81.5
32CE:  BRA    32C4
32D0:  BSF    F93.6
32D2:  BTFSS  F81.6
32D4:  BRA    32C4
32D6:  BSF    F93.7
32D8:  BTFSS  F81.7
32DA:  BRA    32C4
....................     } 
....................   set_tris_a(0xff);     
32DC:  MOVLW  FF
32DE:  MOVWF  F92
....................   return(kchar); 
32E0:  MOVFF  827,01
.................... }//*/ 
32E4:  MOVLB  0
32E6:  RETURN 0
....................  
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
3E9C:  MOVF   27,F
3E9E:  BTFSS  FD8.2
3EA0:  BRA    4018
3EA2:  MOVF   26,W
3EA4:  SUBLW  01
3EA6:  BTFSS  FD8.0
3EA8:  BRA    4018
3EAA:  BNZ   3EBE
3EAC:  MOVF   25,W
3EAE:  SUBLW  FF
3EB0:  BTFSS  FD8.0
3EB2:  BRA    4018
3EB4:  BNZ   3EBE
3EB6:  MOVF   24,W
3EB8:  SUBLW  FE
3EBA:  BTFSS  FD8.0
3EBC:  BRA    4018
....................    { 
....................       
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
3EBE:  MOVLB  1
3EC0:  MOVF   x45,F
3EC2:  BNZ   3ECA
3EC4:  MOVF   x42,F
3EC6:  BTFSC  FD8.2
3EC8:  BRA    3FC6
....................       { 
....................          temp=get_countcard(); 
3ECA:  MOVLB  0
3ECC:  CALL   3494
3ED0:  MOVFF  02,828
3ED4:  MOVFF  01,827
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
3ED8:  MOVLB  8
3EDA:  RLCF   x27,W
3EDC:  MOVWF  x29
3EDE:  RLCF   x28,W
3EE0:  MOVWF  x2A
3EE2:  RLCF   x29,F
3EE4:  RLCF   x2A,F
3EE6:  RLCF   x29,F
3EE8:  RLCF   x2A,F
3EEA:  RLCF   x29,F
3EEC:  RLCF   x2A,F
3EEE:  MOVLW  F0
3EF0:  ANDWF  x29,F
3EF2:  MOVLW  04
3EF4:  SUBWF  x29,F
3EF6:  MOVLW  00
3EF8:  SUBWFB x2A,F
3EFA:  MOVLW  0E
3EFC:  ADDWF  x29,F
3EFE:  MOVLW  C3
3F00:  ADDWFC x2A,F
3F02:  MOVLW  01
3F04:  MOVWF  x2B
3F06:  BCF    FD8.2
3F08:  BTFSC  FD8.0
3F0A:  INCF   x2B,F
3F0C:  CLRF   x2C
3F0E:  MOVLW  01
3F10:  ADDWF  x29,W
3F12:  MOVWF  00
3F14:  MOVLW  00
3F16:  ADDWFC x2A,W
3F18:  MOVWF  01
3F1A:  MOVLW  00
3F1C:  ADDWFC x2B,W
3F1E:  MOVWF  02
3F20:  MOVLW  00
3F22:  ADDWFC x2C,W
3F24:  MOVWF  27
3F26:  MOVFF  02,26
3F2A:  MOVFF  01,25
3F2E:  MOVFF  00,24
....................          for(i=0;i<key_numbyte-5;i++) 
3F32:  CLRF   x26
3F34:  MOVF   x26,W
3F36:  SUBLW  06
3F38:  BNC   3F98
....................          { 
....................             temp=key_data[i]; 
3F3A:  CLRF   03
3F3C:  MOVF   x26,W
3F3E:  ADDLW  45
3F40:  MOVWF  FE9
3F42:  MOVLW  01
3F44:  ADDWFC 03,W
3F46:  MOVWF  FEA
3F48:  CLRF   x28
3F4A:  MOVFF  FEF,827
....................             write_ext_eeprom((long int)ptr_card_key++,temp); 
3F4E:  MOVFF  27,03
3F52:  MOVFF  26,02
3F56:  MOVFF  25,01
3F5A:  MOVFF  24,00
3F5E:  MOVLW  01
3F60:  ADDWF  24,F
3F62:  BTFSC  FD8.0
3F64:  INCF   25,F
3F66:  BTFSC  FD8.2
3F68:  INCF   26,F
3F6A:  BTFSC  FD8.2
3F6C:  INCF   27,F
3F6E:  MOVFF  01,82A
3F72:  MOVFF  00,829
3F76:  CLRF   x3A
3F78:  CLRF   x39
3F7A:  MOVFF  01,838
3F7E:  MOVFF  00,837
3F82:  MOVFF  827,83B
3F86:  MOVLB  0
3F88:  RCALL  3918
....................             //delay_us(100); 
....................             fputc(temp,COM2); 
3F8A:  MOVFF  827,84F
3F8E:  CALL   15C8
....................          } 
3F92:  MOVLB  8
3F94:  INCF   x26,F
3F96:  BRA    3F34
....................          /*fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<key_numbyte;i++) 
....................           { 
....................             fprintf(COM2,"read key=%c\n\r",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          write_ext_eeprom((long int)ptr_card_key,0); 
3F98:  CLRF   x3A
3F9A:  CLRF   x39
3F9C:  MOVFF  25,838
3FA0:  MOVFF  24,837
3FA4:  CLRF   x3B
3FA6:  MOVLB  0
3FA8:  RCALL  3918
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
3FAA:  MOVFF  27,82C
3FAE:  MOVFF  26,82B
3FB2:  MOVFF  25,82A
3FB6:  MOVFF  24,829
3FBA:  MOVLW  1E
3FBC:  MOVLB  8
3FBE:  MOVWF  x2D
3FC0:  MOVLB  0
3FC2:  RCALL  3A16
3FC4:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
3FC6:  CLRF   x42
....................       del_buf(key_numbyte,key_data); 
3FC8:  MOVLW  0C
3FCA:  MOVLB  8
3FCC:  MOVWF  x35
3FCE:  MOVLW  01
3FD0:  MOVWF  x37
3FD2:  MOVLW  45
3FD4:  MOVWF  x36
3FD6:  MOVLB  0
3FD8:  CALL   350E
....................       fprintf(COM2,"\r\n"); 
3FDC:  MOVLW  0D
3FDE:  MOVLB  8
3FE0:  MOVWF  x4F
3FE2:  MOVLB  0
3FE4:  CALL   15C8
3FE8:  MOVLW  0A
3FEA:  MOVLB  8
3FEC:  MOVWF  x4F
3FEE:  MOVLB  0
3FF0:  CALL   15C8
....................       fprintf(COM2,"Done PIN"); 
3FF4:  MOVLW  82
3FF6:  MOVWF  FF6
3FF8:  MOVLW  05
3FFA:  MOVWF  FF7
3FFC:  CALL   16F2
....................       fprintf(COM2,"\r\n"); 
4000:  MOVLW  0D
4002:  MOVLB  8
4004:  MOVWF  x4F
4006:  MOVLB  0
4008:  CALL   15C8
400C:  MOVLW  0A
400E:  MOVLB  8
4010:  MOVWF  x4F
4012:  MOVLB  0
4014:  CALL   15C8
....................    } 
.................... } 
4018:  GOTO   429E (RETURN)
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 rec[wideofkeystore]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
54C8:  MOVF   27,F
54CA:  BTFSS  FD8.2
54CC:  BRA    5718
54CE:  MOVF   26,W
54D0:  SUBLW  01
54D2:  BTFSS  FD8.0
54D4:  BRA    5718
54D6:  BNZ   54EA
54D8:  MOVF   25,W
54DA:  SUBLW  FF
54DC:  BTFSS  FD8.0
54DE:  BRA    5718
54E0:  BNZ   54EA
54E2:  MOVF   24,W
54E4:  SUBLW  FE
54E6:  BTFSS  FD8.0
54E8:  BRA    5718
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
54EA:  MOVLB  1
54EC:  MOVF   x45,F
54EE:  BNZ   54F6
54F0:  MOVF   x42,F
54F2:  BTFSC  FD8.2
54F4:  BRA    567E
....................       {    
....................          for(i=0;i<key_numbyte;i++) 
54F6:  MOVLB  7
54F8:  CLRF   xB8
54FA:  MOVF   xB8,W
54FC:  SUBLW  0B
54FE:  BNC   555E
....................          { 
....................             temp=key_data[i]; 
5500:  CLRF   03
5502:  MOVF   xB8,W
5504:  ADDLW  45
5506:  MOVWF  FE9
5508:  MOVLW  01
550A:  ADDWFC 03,W
550C:  MOVWF  FEA
550E:  CLRF   xBA
5510:  MOVFF  FEF,7B9
5514:  CLRF   19
5516:  BTFSC  FF2.7
5518:  BSF    19.7
551A:  BCF    FF2.7
....................             fputc(temp,COM2); 
551C:  MOVFF  7B9,84F
5520:  MOVLB  0
5522:  CALL   15C8
5526:  BTFSC  19.7
5528:  BSF    FF2.7
....................             rec[i]=key_data[i]; 
552A:  CLRF   03
552C:  MOVLB  7
552E:  MOVF   xB8,W
5530:  ADDLW  BC
5532:  MOVWF  01
5534:  MOVLW  07
5536:  ADDWFC 03,F
5538:  MOVFF  03,7CD
553C:  CLRF   03
553E:  MOVF   xB8,W
5540:  ADDLW  45
5542:  MOVWF  FE9
5544:  MOVLW  01
5546:  ADDWFC 03,W
5548:  MOVWF  FEA
554A:  MOVFF  FEF,7CE
554E:  MOVFF  7CD,FEA
5552:  MOVFF  01,FE9
5556:  MOVFF  7CE,FEF
....................          } 
555A:  INCF   xB8,F
555C:  BRA    54FA
....................          rec[key_numbyte] = 0; 
555E:  CLRF   xC8
....................          rec[key_numbyte+1] = 0;          
5560:  CLRF   xC9
....................          rec[key_numbyte+2] = 0;          
5562:  CLRF   xCA
....................          rec[key_numbyte+3] = 0; 
5564:  CLRF   xCB
....................     #if 0 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"test_key:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"\n\rdatain:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2," %x",rec[i]); 
....................          fprintf(COM2,"\n\r"); 
....................     #endif 
....................          //rijndael('c', (unsigned char *)&rec[0], (unsigned char *)&crypto_key[0]); 
....................          aes_enc_dec((unsigned int8 *)&rec[0], (unsigned int8 *)&crypto_key[0],0); 
5566:  MOVLW  07
5568:  MOVWF  xCD
556A:  MOVLW  BC
556C:  MOVWF  xCC
556E:  CLRF   xCF
5570:  MOVLW  FD
5572:  MOVWF  xCE
5574:  CLRF   xD0
5576:  MOVLB  0
5578:  CALL   47F2
557C:  CLRF   19
557E:  BTFSC  FF2.7
5580:  BSF    19.7
5582:  BCF    FF2.7
....................          //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................           
....................          /* get the pointer of keyboard data */ 
....................          temp=get_countcard(); 
5584:  CALL   3494
5588:  BTFSC  19.7
558A:  BSF    FF2.7
558C:  MOVFF  02,7BA
5590:  MOVFF  01,7B9
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
5594:  MOVLB  7
5596:  RLCF   xB9,W
5598:  MOVWF  xCC
559A:  RLCF   xBA,W
559C:  MOVWF  xCD
559E:  RLCF   xCC,F
55A0:  RLCF   xCD,F
55A2:  RLCF   xCC,F
55A4:  RLCF   xCD,F
55A6:  RLCF   xCC,F
55A8:  RLCF   xCD,F
55AA:  MOVLW  F0
55AC:  ANDWF  xCC,F
55AE:  MOVLW  0E
55B0:  ADDWF  xCC,F
55B2:  MOVLW  C3
55B4:  ADDWFC xCD,F
55B6:  MOVLW  01
55B8:  MOVWF  xCE
55BA:  BCF    FD8.2
55BC:  BTFSC  FD8.0
55BE:  INCF   xCE,F
55C0:  CLRF   xCF
55C2:  MOVLW  01
55C4:  ADDWF  xCC,W
55C6:  MOVWF  00
55C8:  MOVLW  00
55CA:  ADDWFC xCD,W
55CC:  MOVWF  01
55CE:  MOVLW  00
55D0:  ADDWFC xCE,W
55D2:  MOVWF  02
55D4:  MOVLW  00
55D6:  ADDWFC xCF,W
55D8:  MOVWF  27
55DA:  MOVFF  02,26
55DE:  MOVFF  01,25
55E2:  MOVFF  00,24
....................           
....................          for(i=0;i<wideofkeystore;i++) fprintf(COM2,"%x",rec[i]); 
55E6:  CLRF   xB8
55E8:  MOVF   xB8,W
55EA:  SUBLW  0F
55EC:  BNC   5612
55EE:  CLRF   03
55F0:  MOVF   xB8,W
55F2:  ADDLW  BC
55F4:  MOVWF  FE9
55F6:  MOVLW  07
55F8:  ADDWFC 03,W
55FA:  MOVWF  FEA
55FC:  MOVFF  FEF,7CC
5600:  MOVFF  7CC,7CD
5604:  MOVLW  57
5606:  MOVWF  xCE
5608:  MOVLB  0
560A:  RCALL  5466
560C:  MOVLB  7
560E:  INCF   xB8,F
5610:  BRA    55E8
....................          retval = EEPROM_write(ptr_card_key,wideofkeystore,rec);   /* criture de la chaine */ 
5612:  MOVFF  27,806
5616:  MOVFF  26,805
561A:  MOVFF  25,804
561E:  MOVFF  24,803
5622:  MOVLB  8
5624:  CLRF   x0A
5626:  CLRF   x09
5628:  CLRF   x08
562A:  MOVLW  10
562C:  MOVWF  x07
562E:  MOVLW  07
5630:  MOVWF  x0C
5632:  MOVLW  BC
5634:  MOVWF  x0B
5636:  MOVLB  0
5638:  CALL   44DC
563C:  MOVFF  01,7BB
....................          if(retval!=0) 
5640:  MOVLB  7
5642:  MOVF   xBB,F
5644:  BZ    567C
....................          { 
....................             ptr_card_key+=wideofkeystore; 
5646:  MOVLW  10
5648:  ADDWF  24,F
564A:  MOVLW  00
564C:  ADDWFC 25,F
564E:  ADDWFC 26,F
5650:  ADDWFC 27,F
5652:  CLRF   19
5654:  BTFSC  FF2.7
5656:  BSF    19.7
5658:  BCF    FF2.7
....................             save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
565A:  MOVFF  27,82C
565E:  MOVFF  26,82B
5662:  MOVFF  25,82A
5666:  MOVFF  24,829
566A:  MOVLW  1E
566C:  MOVLB  8
566E:  MOVWF  x2D
5670:  MOVLB  0
5672:  CALL   3A16
5676:  BTFSC  19.7
5678:  BSF    FF2.7
567A:  MOVLB  7
567C:  MOVLB  1
....................          }          
....................       } 
....................       key_count_ms=0; 
567E:  CLRF   x42
5680:  CLRF   19
5682:  BTFSC  FF2.7
5684:  BSF    19.7
5686:  BCF    FF2.7
....................       del_buf(key_numbyte,key_data); 
5688:  MOVLW  0C
568A:  MOVLB  8
568C:  MOVWF  x35
568E:  MOVLW  01
5690:  MOVWF  x37
5692:  MOVLW  45
5694:  MOVWF  x36
5696:  MOVLB  0
5698:  CALL   350E
569C:  BTFSC  19.7
569E:  BSF    FF2.7
56A0:  CLRF   19
56A2:  BTFSC  FF2.7
56A4:  BSF    19.7
56A6:  BCF    FF2.7
....................       fprintf(COM2,"\r\n"); 
56A8:  MOVLW  0D
56AA:  MOVLB  8
56AC:  MOVWF  x4F
56AE:  MOVLB  0
56B0:  CALL   15C8
56B4:  BTFSC  19.7
56B6:  BSF    FF2.7
56B8:  CLRF   19
56BA:  BTFSC  FF2.7
56BC:  BSF    19.7
56BE:  BCF    FF2.7
56C0:  MOVLW  0A
56C2:  MOVLB  8
56C4:  MOVWF  x4F
56C6:  MOVLB  0
56C8:  CALL   15C8
56CC:  BTFSC  19.7
56CE:  BSF    FF2.7
....................       fprintf(COM2,"Done PIN"); 
56D0:  MOVLW  8C
56D2:  MOVWF  FF6
56D4:  MOVLW  05
56D6:  MOVWF  FF7
56D8:  CLRF   19
56DA:  BTFSC  FF2.7
56DC:  BSF    19.7
56DE:  BCF    FF2.7
56E0:  CALL   16F2
56E4:  BTFSC  19.7
56E6:  BSF    FF2.7
56E8:  CLRF   19
56EA:  BTFSC  FF2.7
56EC:  BSF    19.7
56EE:  BCF    FF2.7
....................       fprintf(COM2,"\r\n"); 
56F0:  MOVLW  0D
56F2:  MOVLB  8
56F4:  MOVWF  x4F
56F6:  MOVLB  0
56F8:  CALL   15C8
56FC:  BTFSC  19.7
56FE:  BSF    FF2.7
5700:  CLRF   19
5702:  BTFSC  FF2.7
5704:  BSF    19.7
5706:  BCF    FF2.7
5708:  MOVLW  0A
570A:  MOVLB  8
570C:  MOVWF  x4F
570E:  MOVLB  0
5710:  CALL   15C8
5714:  BTFSC  19.7
5716:  BSF    FF2.7
....................    } 
.................... } 
5718:  GOTO   76BC (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
576A:  MOVLB  7
576C:  CLRF   xF5
576E:  CLRF   xF4
5770:  CLRF   xF6
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
5772:  MOVF   xF5,F
5774:  BTFSS  FD8.2
5776:  BRA    589A
5778:  MOVF   xEF,W
577A:  SUBWF  xF4,W
577C:  BTFSC  FD8.0
577E:  BRA    589A
5780:  MOVF   xF6,F
5782:  BTFSS  FD8.2
5784:  BRA    589A
....................       c = fgetc(COM2);//getc(); 
5786:  MOVLB  0
5788:  RCALL  571C
578A:  MOVFF  01,7F2
....................       switch(c) 
....................       { 
578E:  MOVLB  7
5790:  MOVF   xF2,W
5792:  XORLW  7F
5794:  MOVLB  0
5796:  BZ    579E
5798:  XORLW  72
579A:  BZ    57EC
579C:  BRA    582A
....................          case 0x7f:    
....................             if(nbcar>0)   
579E:  MOVLB  7
57A0:  MOVF   xF4,F
57A2:  BNZ   57A8
57A4:  MOVF   xF5,F
57A6:  BZ    57D2
57A8:  CLRF   19
57AA:  BTFSC  FF2.7
57AC:  BSF    19.7
57AE:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
57B0:  MOVLW  7F
57B2:  MOVLB  8
57B4:  MOVWF  x4F
57B6:  MOVLB  0
57B8:  CALL   15C8
57BC:  BTFSC  19.7
57BE:  BSF    FF2.7
....................                nbcar--; 
57C0:  MOVLB  7
57C2:  MOVF   xF4,W
57C4:  BTFSC  FD8.2
57C6:  DECF   xF5,F
57C8:  DECF   xF4,F
....................                fgetc(COM2);//getc(); 
57CA:  MOVLB  0
57CC:  RCALL  571C
....................             } 
....................             else fputc(0x07,COM2);    
57CE:  BRA    57EA
57D0:  MOVLB  7
57D2:  CLRF   19
57D4:  BTFSC  FF2.7
57D6:  BSF    19.7
57D8:  BCF    FF2.7
57DA:  MOVLW  07
57DC:  MOVLB  8
57DE:  MOVWF  x4F
57E0:  MOVLB  0
57E2:  CALL   15C8
57E6:  BTFSC  19.7
57E8:  BSF    FF2.7
....................          break;  
57EA:  BRA    5896
....................          case 0x0D:   
....................                keydebug_en=0; 
57EC:  MOVLB  1
57EE:  CLRF   x3F
....................                set_tris_a(0xff); 
57F0:  MOVLW  FF
57F2:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
57F4:  MOVFF  7F4,7F3
57F8:  MOVLB  7
57FA:  MOVF   xEF,W
57FC:  SUBWF  xF3,W
57FE:  BC    5814
....................                { 
....................                  chaine[i]=0; 
5800:  CLRF   03
5802:  MOVF   xF3,W
5804:  ADDWF  xF0,W
5806:  MOVWF  FE9
5808:  MOVF   xF1,W
580A:  ADDWFC 03,W
580C:  MOVWF  FEA
580E:  CLRF   FEF
....................                } 
5810:  INCF   xF3,F
5812:  BRA    57FA
....................                if(nbcar==0)return(FAUX); 
5814:  MOVF   xF4,F
5816:  BNZ   5822
5818:  MOVF   xF5,F
581A:  BNZ   5822
581C:  MOVLW  00
581E:  MOVWF  01
5820:  BRA    589E
....................                fini=VRAI; 
5822:  MOVLW  01
5824:  MOVWF  xF6
....................          break; 
5826:  MOVLB  0
5828:  BRA    5896
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
582A:  MOVLB  7
582C:  MOVF   xF2,W
582E:  SUBLW  1F
5830:  BC    5898
5832:  MOVF   xF2,W
5834:  SUBLW  7E
5836:  BNC   5898
5838:  MOVLW  01
583A:  SUBWF  xEF,W
583C:  MOVF   xF5,F
583E:  BNZ   5898
5840:  SUBWF  xF4,W
5842:  BC    5898
....................             { 
....................                chaine[nbcar]=c; 
5844:  MOVF   xF0,W
5846:  ADDWF  xF4,W
5848:  MOVWF  FE9
584A:  MOVF   xF1,W
584C:  ADDWFC xF5,W
584E:  MOVWF  FEA
5850:  MOVFF  7F2,FEF
....................                nbcar++; 
5854:  INCF   xF4,F
5856:  BTFSC  FD8.2
5858:  INCF   xF5,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
585A:  DECFSZ xEE,W
585C:  BRA    5878
585E:  CLRF   19
5860:  BTFSC  FF2.7
5862:  BSF    19.7
5864:  BCF    FF2.7
5866:  MOVFF  7F2,84F
586A:  MOVLB  0
586C:  CALL   15C8
5870:  BTFSC  19.7
5872:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
5874:  BRA    5896
5876:  MOVLB  7
5878:  MOVF   xEE,W
587A:  SUBLW  02
587C:  BNZ   5898
587E:  CLRF   19
5880:  BTFSC  FF2.7
5882:  BSF    19.7
5884:  BCF    FF2.7
5886:  MOVLW  2A
5888:  MOVLB  8
588A:  MOVWF  x4F
588C:  MOVLB  0
588E:  CALL   15C8
5892:  BTFSC  19.7
5894:  BSF    FF2.7
5896:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
5898:  BRA    5772
....................    return(nbcar); 
589A:  MOVFF  7F4,01
.................... } 
589E:  MOVLB  0
58A0:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
58A2:  MOVFF  7EF,7F3
58A6:  MOVFF  7EE,7F2
58AA:  MOVFF  7F1,7F5
58AE:  MOVFF  7F0,7F4
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
58B2:  MOVFF  7F3,03
58B6:  MOVLB  7
58B8:  MOVFF  7F2,FE9
58BC:  MOVFF  7F3,FEA
58C0:  MOVF   FEF,F
58C2:  BZ    590A
58C4:  MOVFF  7F5,03
58C8:  MOVFF  7F4,FE9
58CC:  MOVFF  7F5,FEA
58D0:  MOVF   FEF,F
58D2:  BZ    590A
....................       if(*aa!=*bb) 
58D4:  MOVFF  7F2,FE9
58D8:  MOVFF  7F3,FEA
58DC:  MOVFF  FEF,7F6
58E0:  MOVFF  7F5,03
58E4:  MOVFF  7F4,FE9
58E8:  MOVFF  7F5,FEA
58EC:  MOVF   FEF,W
58EE:  SUBWF  xF6,W
58F0:  BZ    58F8
....................          return(1); 
58F2:  MOVLW  01
58F4:  MOVWF  01
58F6:  BRA    5936
....................       aa++; 
58F8:  INCF   xF2,F
58FA:  BTFSC  FD8.2
58FC:  INCF   xF3,F
....................       bb++; 
58FE:  INCF   xF4,F
5900:  BTFSC  FD8.2
5902:  INCF   xF5,F
....................    } 
5904:  MOVLB  0
5906:  BRA    58B2
5908:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
590A:  MOVFF  7F3,03
590E:  MOVFF  7F2,FE9
5912:  MOVFF  7F3,FEA
5916:  MOVFF  FEF,7F6
591A:  MOVFF  7F5,03
591E:  MOVFF  7F4,FE9
5922:  MOVFF  7F5,FEA
5926:  MOVF   FEF,W
5928:  SUBWF  xF6,W
592A:  BZ    5932
592C:  MOVLW  01
592E:  MOVWF  01
5930:  BRA    5936
....................    return(0); 
5932:  MOVLW  00
5934:  MOVWF  01
.................... } 
5936:  MOVLB  0
5938:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
5E26:  MOVLB  7
5E28:  CLRF   xF0
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
5E2A:  MOVFF  7EF,03
5E2E:  MOVF   xEE,W
5E30:  INCF   xEE,F
5E32:  BTFSC  FD8.2
5E34:  INCF   xEF,F
5E36:  MOVWF  FE9
5E38:  MOVFF  03,FEA
5E3C:  MOVFF  FEF,7F2
5E40:  MOVF   xF2,F
5E42:  BZ    5E66
....................         if (c >= '0' && c <= '9') 
5E44:  MOVF   xF2,W
5E46:  SUBLW  2F
5E48:  BC    5E58
5E4A:  MOVF   xF2,W
5E4C:  SUBLW  39
5E4E:  BNC   5E58
....................             digit = (unsigned int) (c - '0'); 
5E50:  MOVLW  30
5E52:  SUBWF  xF2,W
5E54:  MOVWF  xF1
....................         else 
5E56:  BRA    5E5A
....................             break; 
5E58:  BRA    5E66
....................  
....................         val = (val * 10) + digit; 
5E5A:  MOVF   xF0,W
5E5C:  MULLW  0A
5E5E:  MOVF   FF3,W
5E60:  ADDWF  xF1,W
5E62:  MOVWF  xF0
....................     } 
5E64:  BRA    5E2A
....................  
....................     return val; 
5E66:  CLRF   03
5E68:  MOVFF  7F0,01
5E6C:  MOVFF  03,02
.................... } 
5E70:  MOVLB  0
5E72:  RETURN 0
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
0670:  MOVLB  8
0672:  CLRF   x5F
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
0674:  CLRF   x60
0676:  BTFSC  x57.0
0678:  BSF    x60.7
067A:  SWAPF  x58,W
067C:  MOVWF  00
067E:  RLCF   00,F
0680:  RLCF   00,F
0682:  MOVLW  C0
0684:  ANDWF  00,F
0686:  MOVF   00,W
0688:  IORWF  x60,F
068A:  SWAPF  x59,W
068C:  MOVWF  00
068E:  RLCF   00,F
0690:  MOVLW  E0
0692:  ANDWF  00,F
0694:  MOVF   00,W
0696:  IORWF  x60,F
0698:  SWAPF  x5A,W
069A:  MOVWF  00
069C:  MOVLW  F0
069E:  ANDWF  00,F
06A0:  MOVF   00,W
06A2:  IORWF  x60,F
06A4:  RLCF   x5B,W
06A6:  MOVWF  00
06A8:  RLCF   00,F
06AA:  RLCF   00,F
06AC:  MOVLW  F8
06AE:  ANDWF  00,F
06B0:  MOVF   00,W
06B2:  IORWF  x60,F
06B4:  RLCF   x5C,W
06B6:  MOVWF  00
06B8:  RLCF   00,F
06BA:  MOVLW  FC
06BC:  ANDWF  00,F
06BE:  MOVF   00,W
06C0:  IORWF  x60,F
06C2:  BCF    FD8.0
06C4:  RLCF   x5D,W
06C6:  IORWF  x60,F
06C8:  MOVF   x5E,W
06CA:  IORWF  x60,W
06CC:  MOVWF  x5F
....................    return temp; 
06CE:  MOVFF  85F,01
.................... } 
06D2:  MOVLB  0
06D4:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
06D6:  MOVLB  8
06D8:  CLRF   x47
....................    int8 temp=0; 
....................    if(direct==0) 
06DA:  MOVF   x42,F
06DC:  BNZ   07B2
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
06DE:  MOVF   x45,W
06E0:  ADDWF  x43,W
06E2:  MOVWF  FE9
06E4:  MOVF   x46,W
06E6:  ADDWFC x44,W
06E8:  MOVWF  FEA
06EA:  MOVFF  FEF,848
06EE:  MOVLW  01
06F0:  ADDWF  x43,W
06F2:  MOVWF  x49
06F4:  MOVLW  00
06F6:  ADDWFC x44,W
06F8:  MOVWF  x4A
06FA:  MOVF   x45,W
06FC:  ADDWF  x49,W
06FE:  MOVWF  FE9
0700:  MOVF   x46,W
0702:  ADDWFC x4A,W
0704:  MOVWF  FEA
0706:  MOVF   FEF,W
0708:  XORWF  x48,F
070A:  MOVLW  02
070C:  ADDWF  x43,W
070E:  MOVWF  x4B
0710:  MOVLW  00
0712:  ADDWFC x44,W
0714:  MOVWF  x4C
0716:  MOVF   x45,W
0718:  ADDWF  x4B,W
071A:  MOVWF  FE9
071C:  MOVF   x46,W
071E:  ADDWFC x4C,W
0720:  MOVWF  FEA
0722:  MOVF   FEF,W
0724:  XORWF  x48,F
0726:  MOVLW  03
0728:  ADDWF  x43,W
072A:  MOVWF  x4D
072C:  MOVLW  00
072E:  ADDWFC x44,W
0730:  MOVWF  x4E
0732:  MOVF   x45,W
0734:  ADDWF  x4D,W
0736:  MOVWF  FE9
0738:  MOVF   x46,W
073A:  ADDWFC x4E,W
073C:  MOVWF  FEA
073E:  MOVF   FEF,W
0740:  XORWF  x48,F
0742:  MOVLW  04
0744:  ADDWF  x43,W
0746:  MOVWF  x4F
0748:  MOVLW  00
074A:  ADDWFC x44,W
074C:  MOVWF  x50
074E:  MOVF   x45,W
0750:  ADDWF  x4F,W
0752:  MOVWF  FE9
0754:  MOVF   x46,W
0756:  ADDWFC x50,W
0758:  MOVWF  FEA
075A:  MOVF   FEF,W
075C:  XORWF  x48,F
075E:  MOVLW  05
0760:  ADDWF  x43,W
0762:  MOVWF  x51
0764:  MOVLW  00
0766:  ADDWFC x44,W
0768:  MOVWF  x52
076A:  MOVF   x45,W
076C:  ADDWF  x51,W
076E:  MOVWF  FE9
0770:  MOVF   x46,W
0772:  ADDWFC x52,W
0774:  MOVWF  FEA
0776:  MOVF   FEF,W
0778:  XORWF  x48,W
077A:  BZ    0780
077C:  MOVLW  00
077E:  BRA    0782
0780:  MOVLW  01
0782:  MOVWF  x47
....................       if(temp==datain[offset+6]) return 1; 
0784:  MOVLW  06
0786:  ADDWF  x43,W
0788:  MOVWF  x48
078A:  MOVLW  00
078C:  ADDWFC x44,W
078E:  MOVWF  x49
0790:  MOVF   x45,W
0792:  ADDWF  x48,W
0794:  MOVWF  FE9
0796:  MOVF   x46,W
0798:  ADDWFC x49,W
079A:  MOVWF  FEA
079C:  MOVF   FEF,W
079E:  SUBWF  x47,W
07A0:  BNZ   07AA
07A2:  MOVLW  01
07A4:  MOVWF  01
07A6:  BRA    0882
....................          else return 0; 
07A8:  BRA    07B0
07AA:  MOVLW  00
07AC:  MOVWF  01
07AE:  BRA    0882
....................    } 
....................       else  
07B0:  BRA    0882
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
07B2:  MOVF   x45,W
07B4:  ADDWF  x43,W
07B6:  MOVWF  FE9
07B8:  MOVF   x46,W
07BA:  ADDWFC x44,W
07BC:  MOVWF  FEA
07BE:  MOVFF  FEF,848
07C2:  MOVLW  01
07C4:  SUBWF  x43,W
07C6:  MOVWF  x49
07C8:  MOVLW  00
07CA:  SUBWFB x44,W
07CC:  MOVWF  x4A
07CE:  MOVF   x45,W
07D0:  ADDWF  x49,W
07D2:  MOVWF  FE9
07D4:  MOVF   x46,W
07D6:  ADDWFC x4A,W
07D8:  MOVWF  FEA
07DA:  MOVF   FEF,W
07DC:  XORWF  x48,F
07DE:  MOVLW  02
07E0:  SUBWF  x43,W
07E2:  MOVWF  x4B
07E4:  MOVLW  00
07E6:  SUBWFB x44,W
07E8:  MOVWF  x4C
07EA:  MOVF   x45,W
07EC:  ADDWF  x4B,W
07EE:  MOVWF  FE9
07F0:  MOVF   x46,W
07F2:  ADDWFC x4C,W
07F4:  MOVWF  FEA
07F6:  MOVF   FEF,W
07F8:  XORWF  x48,F
07FA:  MOVLW  03
07FC:  SUBWF  x43,W
07FE:  MOVWF  x4D
0800:  MOVLW  00
0802:  SUBWFB x44,W
0804:  MOVWF  x4E
0806:  MOVF   x45,W
0808:  ADDWF  x4D,W
080A:  MOVWF  FE9
080C:  MOVF   x46,W
080E:  ADDWFC x4E,W
0810:  MOVWF  FEA
0812:  MOVF   FEF,W
0814:  XORWF  x48,F
0816:  MOVLW  04
0818:  SUBWF  x43,W
081A:  MOVWF  x4F
081C:  MOVLW  00
081E:  SUBWFB x44,W
0820:  MOVWF  x50
0822:  MOVF   x45,W
0824:  ADDWF  x4F,W
0826:  MOVWF  FE9
0828:  MOVF   x46,W
082A:  ADDWFC x50,W
082C:  MOVWF  FEA
082E:  MOVF   FEF,W
0830:  XORWF  x48,F
0832:  MOVLW  05
0834:  SUBWF  x43,W
0836:  MOVWF  x51
0838:  MOVLW  00
083A:  SUBWFB x44,W
083C:  MOVWF  x52
083E:  MOVF   x45,W
0840:  ADDWF  x51,W
0842:  MOVWF  FE9
0844:  MOVF   x46,W
0846:  ADDWFC x52,W
0848:  MOVWF  FEA
084A:  MOVF   FEF,W
084C:  XORWF  x48,W
084E:  BZ    0854
0850:  MOVLW  00
0852:  BRA    0856
0854:  MOVLW  01
0856:  MOVWF  x47
....................          if(temp==datain[offset-6]) return 1; 
0858:  MOVLW  06
085A:  SUBWF  x43,W
085C:  MOVWF  x48
085E:  MOVLW  00
0860:  SUBWFB x44,W
0862:  MOVWF  x49
0864:  MOVF   x45,W
0866:  ADDWF  x48,W
0868:  MOVWF  FE9
086A:  MOVF   x46,W
086C:  ADDWFC x49,W
086E:  MOVWF  FEA
0870:  MOVF   FEF,W
0872:  SUBWF  x47,W
0874:  BNZ   087E
0876:  MOVLW  01
0878:  MOVWF  01
087A:  BRA    0882
....................             else return 0;          
087C:  BRA    0882
087E:  MOVLW  00
0880:  MOVWF  01
....................       } 
.................... } 
0882:  MOVLB  0
0884:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
0886:  MOVLB  8
0888:  CLRF   x47
....................    int8 temp=0; 
....................    if(direct==0) 
088A:  MOVF   x42,F
088C:  BNZ   092A
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
088E:  MOVF   x45,W
0890:  ADDWF  x43,W
0892:  MOVWF  FE9
0894:  MOVF   x46,W
0896:  ADDWFC x44,W
0898:  MOVWF  FEA
089A:  MOVFF  FEF,848
089E:  MOVLW  01
08A0:  ADDWF  x43,W
08A2:  MOVWF  x49
08A4:  MOVLW  00
08A6:  ADDWFC x44,W
08A8:  MOVWF  x4A
08AA:  MOVF   x45,W
08AC:  ADDWF  x49,W
08AE:  MOVWF  FE9
08B0:  MOVF   x46,W
08B2:  ADDWFC x4A,W
08B4:  MOVWF  FEA
08B6:  MOVF   FEF,W
08B8:  XORWF  x48,F
08BA:  MOVLW  02
08BC:  ADDWF  x43,W
08BE:  MOVWF  x4B
08C0:  MOVLW  00
08C2:  ADDWFC x44,W
08C4:  MOVWF  x4C
08C6:  MOVF   x45,W
08C8:  ADDWF  x4B,W
08CA:  MOVWF  FE9
08CC:  MOVF   x46,W
08CE:  ADDWFC x4C,W
08D0:  MOVWF  FEA
08D2:  MOVF   FEF,W
08D4:  XORWF  x48,F
08D6:  MOVLW  03
08D8:  ADDWF  x43,W
08DA:  MOVWF  x4D
08DC:  MOVLW  00
08DE:  ADDWFC x44,W
08E0:  MOVWF  x4E
08E2:  MOVF   x45,W
08E4:  ADDWF  x4D,W
08E6:  MOVWF  FE9
08E8:  MOVF   x46,W
08EA:  ADDWFC x4E,W
08EC:  MOVWF  FEA
08EE:  MOVF   FEF,W
08F0:  XORWF  x48,W
08F2:  BZ    08F8
08F4:  MOVLW  00
08F6:  BRA    08FA
08F8:  MOVLW  01
08FA:  MOVWF  x47
....................       if(temp==datain[offset+4]) return 1; 
08FC:  MOVLW  04
08FE:  ADDWF  x43,W
0900:  MOVWF  x48
0902:  MOVLW  00
0904:  ADDWFC x44,W
0906:  MOVWF  x49
0908:  MOVF   x45,W
090A:  ADDWF  x48,W
090C:  MOVWF  FE9
090E:  MOVF   x46,W
0910:  ADDWFC x49,W
0912:  MOVWF  FEA
0914:  MOVF   FEF,W
0916:  SUBWF  x47,W
0918:  BNZ   0922
091A:  MOVLW  01
091C:  MOVWF  01
091E:  BRA    09C2
....................          else return 0; 
0920:  BRA    0928
0922:  MOVLW  00
0924:  MOVWF  01
0926:  BRA    09C2
....................    } 
....................    else 
0928:  BRA    09C2
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
092A:  MOVF   x45,W
092C:  ADDWF  x43,W
092E:  MOVWF  FE9
0930:  MOVF   x46,W
0932:  ADDWFC x44,W
0934:  MOVWF  FEA
0936:  MOVFF  FEF,848
093A:  MOVLW  01
093C:  SUBWF  x43,W
093E:  MOVWF  x49
0940:  MOVLW  00
0942:  SUBWFB x44,W
0944:  MOVWF  x4A
0946:  MOVF   x45,W
0948:  ADDWF  x49,W
094A:  MOVWF  FE9
094C:  MOVF   x46,W
094E:  ADDWFC x4A,W
0950:  MOVWF  FEA
0952:  MOVF   FEF,W
0954:  XORWF  x48,F
0956:  MOVLW  02
0958:  SUBWF  x43,W
095A:  MOVWF  x4B
095C:  MOVLW  00
095E:  SUBWFB x44,W
0960:  MOVWF  x4C
0962:  MOVF   x45,W
0964:  ADDWF  x4B,W
0966:  MOVWF  FE9
0968:  MOVF   x46,W
096A:  ADDWFC x4C,W
096C:  MOVWF  FEA
096E:  MOVF   FEF,W
0970:  XORWF  x48,F
0972:  MOVLW  03
0974:  SUBWF  x43,W
0976:  MOVWF  x4D
0978:  MOVLW  00
097A:  SUBWFB x44,W
097C:  MOVWF  x4E
097E:  MOVF   x45,W
0980:  ADDWF  x4D,W
0982:  MOVWF  FE9
0984:  MOVF   x46,W
0986:  ADDWFC x4E,W
0988:  MOVWF  FEA
098A:  MOVF   FEF,W
098C:  XORWF  x48,W
098E:  BZ    0994
0990:  MOVLW  00
0992:  BRA    0996
0994:  MOVLW  01
0996:  MOVWF  x47
....................       if(temp==datain[offset-4]) return 1; 
0998:  MOVLW  04
099A:  SUBWF  x43,W
099C:  MOVWF  x48
099E:  MOVLW  00
09A0:  SUBWFB x44,W
09A2:  MOVWF  x49
09A4:  MOVF   x45,W
09A6:  ADDWF  x48,W
09A8:  MOVWF  FE9
09AA:  MOVF   x46,W
09AC:  ADDWFC x49,W
09AE:  MOVWF  FEA
09B0:  MOVF   FEF,W
09B2:  SUBWF  x47,W
09B4:  BNZ   09BE
09B6:  MOVLW  01
09B8:  MOVWF  01
09BA:  BRA    09C2
....................          else return 0;                
09BC:  BRA    09C2
09BE:  MOVLW  00
09C0:  MOVWF  01
....................    } 
.................... } 
09C2:  MOVLB  0
09C4:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
09C6:  MOVLB  8
09C8:  CLRF   x3E
09CA:  CLRF   x3F
09CC:  CLRF   x40
09CE:  CLRF   x41
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
09D0:  CLRF   x3B
09D2:  CLRF   x3A
09D4:  RRCF   x37,W
09D6:  MOVWF  03
09D8:  RRCF   x36,W
09DA:  MOVWF  02
09DC:  RRCF   03,F
09DE:  RRCF   02,F
09E0:  MOVLW  3F
09E2:  ANDWF  03,F
09E4:  MOVFF  02,01
09E8:  MOVF   x3B,W
09EA:  SUBWF  03,W
09EC:  BTFSS  FD8.0
09EE:  BRA    0FAE
09F0:  BNZ   09FA
09F2:  MOVF   01,W
09F4:  SUBWF  x3A,W
09F6:  BTFSC  FD8.0
09F8:  BRA    0FAE
....................    { 
....................       if(track==0) 
09FA:  MOVF   x35,F
09FC:  BTFSS  FD8.2
09FE:  BRA    0D34
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0A00:  MOVLW  06
0A02:  ADDWF  x3A,W
0A04:  MOVWF  x42
0A06:  MOVLW  00
0A08:  ADDWFC x3B,W
0A0A:  MOVWF  x43
0A0C:  MOVF   x38,W
0A0E:  ADDWF  x42,W
0A10:  MOVWF  FE9
0A12:  MOVF   x39,W
0A14:  ADDWFC x43,W
0A16:  MOVWF  FEA
0A18:  MOVFF  FEF,844
0A1C:  MOVLW  05
0A1E:  ADDWF  x3A,W
0A20:  MOVWF  x45
0A22:  MOVLW  00
0A24:  ADDWFC x3B,W
0A26:  MOVWF  x46
0A28:  MOVF   x38,W
0A2A:  ADDWF  x45,W
0A2C:  MOVWF  FE9
0A2E:  MOVF   x39,W
0A30:  ADDWFC x46,W
0A32:  MOVWF  FEA
0A34:  MOVFF  FEF,847
0A38:  MOVLW  04
0A3A:  ADDWF  x3A,W
0A3C:  MOVWF  x48
0A3E:  MOVLW  00
0A40:  ADDWFC x3B,W
0A42:  MOVWF  x49
0A44:  MOVF   x38,W
0A46:  ADDWF  x48,W
0A48:  MOVWF  FE9
0A4A:  MOVF   x39,W
0A4C:  ADDWFC x49,W
0A4E:  MOVWF  FEA
0A50:  MOVFF  FEF,84A
0A54:  MOVLW  03
0A56:  ADDWF  x3A,W
0A58:  MOVWF  x4B
0A5A:  MOVLW  00
0A5C:  ADDWFC x3B,W
0A5E:  MOVWF  x4C
0A60:  MOVF   x38,W
0A62:  ADDWF  x4B,W
0A64:  MOVWF  FE9
0A66:  MOVF   x39,W
0A68:  ADDWFC x4C,W
0A6A:  MOVWF  FEA
0A6C:  MOVFF  FEF,84D
0A70:  MOVLW  02
0A72:  ADDWF  x3A,W
0A74:  MOVWF  x4E
0A76:  MOVLW  00
0A78:  ADDWFC x3B,W
0A7A:  MOVWF  x4F
0A7C:  MOVF   x38,W
0A7E:  ADDWF  x4E,W
0A80:  MOVWF  FE9
0A82:  MOVF   x39,W
0A84:  ADDWFC x4F,W
0A86:  MOVWF  FEA
0A88:  MOVFF  FEF,850
0A8C:  MOVLW  01
0A8E:  ADDWF  x3A,W
0A90:  MOVWF  x51
0A92:  MOVLW  00
0A94:  ADDWFC x3B,W
0A96:  MOVWF  x52
0A98:  MOVF   x38,W
0A9A:  ADDWF  x51,W
0A9C:  MOVWF  FE9
0A9E:  MOVF   x39,W
0AA0:  ADDWFC x52,W
0AA2:  MOVWF  FEA
0AA4:  MOVFF  FEF,853
0AA8:  MOVF   x38,W
0AAA:  ADDWF  x3A,W
0AAC:  MOVWF  FE9
0AAE:  MOVF   x39,W
0AB0:  ADDWFC x3B,W
0AB2:  MOVWF  FEA
0AB4:  MOVFF  FEF,854
0AB8:  CLRF   x57
0ABA:  MOVFF  844,858
0ABE:  MOVFF  847,859
0AC2:  MOVFF  84A,85A
0AC6:  MOVFF  84D,85B
0ACA:  MOVFF  850,85C
0ACE:  MOVFF  853,85D
0AD2:  MOVFF  854,85E
0AD6:  MOVLB  0
0AD8:  RCALL  0670
0ADA:  MOVFF  01,83E
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0ADE:  MOVLW  0D
0AE0:  MOVLB  8
0AE2:  ADDWF  x3A,W
0AE4:  MOVWF  x42
0AE6:  MOVLW  00
0AE8:  ADDWFC x3B,W
0AEA:  MOVWF  x43
0AEC:  MOVF   x38,W
0AEE:  ADDWF  x42,W
0AF0:  MOVWF  FE9
0AF2:  MOVF   x39,W
0AF4:  ADDWFC x43,W
0AF6:  MOVWF  FEA
0AF8:  MOVFF  FEF,844
0AFC:  MOVLW  0C
0AFE:  ADDWF  x3A,W
0B00:  MOVWF  x45
0B02:  MOVLW  00
0B04:  ADDWFC x3B,W
0B06:  MOVWF  x46
0B08:  MOVF   x38,W
0B0A:  ADDWF  x45,W
0B0C:  MOVWF  FE9
0B0E:  MOVF   x39,W
0B10:  ADDWFC x46,W
0B12:  MOVWF  FEA
0B14:  MOVFF  FEF,847
0B18:  MOVLW  0B
0B1A:  ADDWF  x3A,W
0B1C:  MOVWF  x48
0B1E:  MOVLW  00
0B20:  ADDWFC x3B,W
0B22:  MOVWF  x49
0B24:  MOVF   x38,W
0B26:  ADDWF  x48,W
0B28:  MOVWF  FE9
0B2A:  MOVF   x39,W
0B2C:  ADDWFC x49,W
0B2E:  MOVWF  FEA
0B30:  MOVFF  FEF,84A
0B34:  MOVLW  0A
0B36:  ADDWF  x3A,W
0B38:  MOVWF  x4B
0B3A:  MOVLW  00
0B3C:  ADDWFC x3B,W
0B3E:  MOVWF  x4C
0B40:  MOVF   x38,W
0B42:  ADDWF  x4B,W
0B44:  MOVWF  FE9
0B46:  MOVF   x39,W
0B48:  ADDWFC x4C,W
0B4A:  MOVWF  FEA
0B4C:  MOVFF  FEF,84D
0B50:  MOVLW  09
0B52:  ADDWF  x3A,W
0B54:  MOVWF  x4E
0B56:  MOVLW  00
0B58:  ADDWFC x3B,W
0B5A:  MOVWF  x4F
0B5C:  MOVF   x38,W
0B5E:  ADDWF  x4E,W
0B60:  MOVWF  FE9
0B62:  MOVF   x39,W
0B64:  ADDWFC x4F,W
0B66:  MOVWF  FEA
0B68:  MOVFF  FEF,850
0B6C:  MOVLW  08
0B6E:  ADDWF  x3A,W
0B70:  MOVWF  x51
0B72:  MOVLW  00
0B74:  ADDWFC x3B,W
0B76:  MOVWF  x52
0B78:  MOVF   x38,W
0B7A:  ADDWF  x51,W
0B7C:  MOVWF  FE9
0B7E:  MOVF   x39,W
0B80:  ADDWFC x52,W
0B82:  MOVWF  FEA
0B84:  MOVFF  FEF,853
0B88:  MOVLW  07
0B8A:  ADDWF  x3A,W
0B8C:  MOVWF  x54
0B8E:  MOVLW  00
0B90:  ADDWFC x3B,W
0B92:  MOVWF  x55
0B94:  MOVF   x38,W
0B96:  ADDWF  x54,W
0B98:  MOVWF  FE9
0B9A:  MOVF   x39,W
0B9C:  ADDWFC x55,W
0B9E:  MOVWF  FEA
0BA0:  MOVFF  FEF,856
0BA4:  CLRF   x57
0BA6:  MOVFF  844,858
0BAA:  MOVFF  847,859
0BAE:  MOVFF  84A,85A
0BB2:  MOVFF  84D,85B
0BB6:  MOVFF  850,85C
0BBA:  MOVFF  853,85D
0BBE:  MOVFF  856,85E
0BC2:  MOVLB  0
0BC4:  RCALL  0670
0BC6:  MOVFF  01,83F
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0BCA:  MOVLB  8
0BCC:  MOVF   x3E,W
0BCE:  SUBLW  45
0BD0:  BTFSS  FD8.2
0BD2:  BRA    0D32
0BD4:  MOVF   x3F,W
0BD6:  SUBLW  7C
0BD8:  BTFSC  FD8.2
0BDA:  BRA    0D32
0BDC:  MOVF   x3F,W
0BDE:  SUBLW  3E
0BE0:  BTFSC  FD8.2
0BE2:  BRA    0D32
0BE4:  MOVF   x3F,W
0BE6:  SUBLW  1F
0BE8:  BTFSC  FD8.2
0BEA:  BRA    0D32
....................          { 
....................             j=i; 
0BEC:  MOVFF  83B,83D
0BF0:  MOVFF  83A,83C
....................             CRC=1; 
0BF4:  MOVLW  01
0BF6:  MOVWF  x41
....................             temp2=temp; 
0BF8:  MOVFF  83E,840
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0BFC:  MOVF   x40,W
0BFE:  SUBLW  1F
0C00:  BTFSC  FD8.2
0C02:  BRA    0D1C
0C04:  MOVF   x3D,W
0C06:  SUBLW  03
0C08:  BTFSS  FD8.0
0C0A:  BRA    0D1C
0C0C:  BNZ   0C16
0C0E:  MOVF   x3C,W
0C10:  SUBLW  E7
0C12:  BTFSS  FD8.0
0C14:  BRA    0D1C
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C16:  CLRF   x42
0C18:  MOVFF  83D,844
0C1C:  MOVFF  83C,843
0C20:  MOVFF  839,846
0C24:  MOVFF  838,845
0C28:  MOVLB  0
0C2A:  RCALL  06D6
0C2C:  MOVF   01,W
0C2E:  MOVLB  8
0C30:  ANDWF  x41,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C32:  MOVLW  06
0C34:  ADDWF  x3C,W
0C36:  MOVWF  x42
0C38:  MOVLW  00
0C3A:  ADDWFC x3D,W
0C3C:  MOVWF  x43
0C3E:  MOVF   x38,W
0C40:  ADDWF  x42,W
0C42:  MOVWF  FE9
0C44:  MOVF   x39,W
0C46:  ADDWFC x43,W
0C48:  MOVWF  FEA
0C4A:  MOVFF  FEF,844
0C4E:  MOVLW  05
0C50:  ADDWF  x3C,W
0C52:  MOVWF  x45
0C54:  MOVLW  00
0C56:  ADDWFC x3D,W
0C58:  MOVWF  x46
0C5A:  MOVF   x38,W
0C5C:  ADDWF  x45,W
0C5E:  MOVWF  FE9
0C60:  MOVF   x39,W
0C62:  ADDWFC x46,W
0C64:  MOVWF  FEA
0C66:  MOVFF  FEF,847
0C6A:  MOVLW  04
0C6C:  ADDWF  x3C,W
0C6E:  MOVWF  x48
0C70:  MOVLW  00
0C72:  ADDWFC x3D,W
0C74:  MOVWF  x49
0C76:  MOVF   x38,W
0C78:  ADDWF  x48,W
0C7A:  MOVWF  FE9
0C7C:  MOVF   x39,W
0C7E:  ADDWFC x49,W
0C80:  MOVWF  FEA
0C82:  MOVFF  FEF,84A
0C86:  MOVLW  03
0C88:  ADDWF  x3C,W
0C8A:  MOVWF  x4B
0C8C:  MOVLW  00
0C8E:  ADDWFC x3D,W
0C90:  MOVWF  x4C
0C92:  MOVF   x38,W
0C94:  ADDWF  x4B,W
0C96:  MOVWF  FE9
0C98:  MOVF   x39,W
0C9A:  ADDWFC x4C,W
0C9C:  MOVWF  FEA
0C9E:  MOVFF  FEF,84D
0CA2:  MOVLW  02
0CA4:  ADDWF  x3C,W
0CA6:  MOVWF  x4E
0CA8:  MOVLW  00
0CAA:  ADDWFC x3D,W
0CAC:  MOVWF  x4F
0CAE:  MOVF   x38,W
0CB0:  ADDWF  x4E,W
0CB2:  MOVWF  FE9
0CB4:  MOVF   x39,W
0CB6:  ADDWFC x4F,W
0CB8:  MOVWF  FEA
0CBA:  MOVFF  FEF,850
0CBE:  MOVLW  01
0CC0:  ADDWF  x3C,W
0CC2:  MOVWF  x51
0CC4:  MOVLW  00
0CC6:  ADDWFC x3D,W
0CC8:  MOVWF  x52
0CCA:  MOVF   x38,W
0CCC:  ADDWF  x51,W
0CCE:  MOVWF  FE9
0CD0:  MOVF   x39,W
0CD2:  ADDWFC x52,W
0CD4:  MOVWF  FEA
0CD6:  MOVFF  FEF,853
0CDA:  MOVF   x38,W
0CDC:  ADDWF  x3C,W
0CDE:  MOVWF  FE9
0CE0:  MOVF   x39,W
0CE2:  ADDWFC x3D,W
0CE4:  MOVWF  FEA
0CE6:  MOVFF  FEF,854
0CEA:  CLRF   x57
0CEC:  MOVFF  844,858
0CF0:  MOVFF  847,859
0CF4:  MOVFF  84A,85A
0CF8:  MOVFF  84D,85B
0CFC:  MOVFF  850,85C
0D00:  MOVFF  853,85D
0D04:  MOVFF  854,85E
0D08:  MOVLB  0
0D0A:  RCALL  0670
0D0C:  MOVFF  01,840
....................                j=j+7; 
0D10:  MOVLW  07
0D12:  MOVLB  8
0D14:  ADDWF  x3C,F
0D16:  MOVLW  00
0D18:  ADDWFC x3D,F
....................             } 
0D1A:  BRA    0BFC
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D1C:  DECFSZ x41,W
0D1E:  BRA    0D32
....................             { 
....................                dir=0; 
0D20:  MOVLB  6
0D22:  CLRF   xC3
....................                return i; 
0D24:  MOVLB  8
0D26:  MOVFF  83A,01
0D2A:  MOVFF  83B,02
0D2E:  GOTO   15C4
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0D32:  BRA    0FA6
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0D34:  MOVLW  04
0D36:  ADDWF  x3A,W
0D38:  MOVWF  x42
0D3A:  MOVLW  00
0D3C:  ADDWFC x3B,W
0D3E:  MOVWF  x43
0D40:  MOVF   x38,W
0D42:  ADDWF  x42,W
0D44:  MOVWF  FE9
0D46:  MOVF   x39,W
0D48:  ADDWFC x43,W
0D4A:  MOVWF  FEA
0D4C:  MOVFF  FEF,844
0D50:  MOVLW  03
0D52:  ADDWF  x3A,W
0D54:  MOVWF  x45
0D56:  MOVLW  00
0D58:  ADDWFC x3B,W
0D5A:  MOVWF  x46
0D5C:  MOVF   x38,W
0D5E:  ADDWF  x45,W
0D60:  MOVWF  FE9
0D62:  MOVF   x39,W
0D64:  ADDWFC x46,W
0D66:  MOVWF  FEA
0D68:  MOVFF  FEF,847
0D6C:  MOVLW  02
0D6E:  ADDWF  x3A,W
0D70:  MOVWF  x48
0D72:  MOVLW  00
0D74:  ADDWFC x3B,W
0D76:  MOVWF  x49
0D78:  MOVF   x38,W
0D7A:  ADDWF  x48,W
0D7C:  MOVWF  FE9
0D7E:  MOVF   x39,W
0D80:  ADDWFC x49,W
0D82:  MOVWF  FEA
0D84:  MOVFF  FEF,84A
0D88:  MOVLW  01
0D8A:  ADDWF  x3A,W
0D8C:  MOVWF  x4B
0D8E:  MOVLW  00
0D90:  ADDWFC x3B,W
0D92:  MOVWF  x4C
0D94:  MOVF   x38,W
0D96:  ADDWF  x4B,W
0D98:  MOVWF  FE9
0D9A:  MOVF   x39,W
0D9C:  ADDWFC x4C,W
0D9E:  MOVWF  FEA
0DA0:  MOVFF  FEF,84D
0DA4:  MOVF   x38,W
0DA6:  ADDWF  x3A,W
0DA8:  MOVWF  FE9
0DAA:  MOVF   x39,W
0DAC:  ADDWFC x3B,W
0DAE:  MOVWF  FEA
0DB0:  MOVFF  FEF,84E
0DB4:  CLRF   x57
0DB6:  CLRF   x58
0DB8:  CLRF   x59
0DBA:  MOVFF  844,85A
0DBE:  MOVFF  847,85B
0DC2:  MOVFF  84A,85C
0DC6:  MOVFF  84D,85D
0DCA:  MOVFF  84E,85E
0DCE:  MOVLB  0
0DD0:  RCALL  0670
0DD2:  MOVFF  01,83E
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0DD6:  MOVLW  09
0DD8:  MOVLB  8
0DDA:  ADDWF  x3A,W
0DDC:  MOVWF  x42
0DDE:  MOVLW  00
0DE0:  ADDWFC x3B,W
0DE2:  MOVWF  x43
0DE4:  MOVF   x38,W
0DE6:  ADDWF  x42,W
0DE8:  MOVWF  FE9
0DEA:  MOVF   x39,W
0DEC:  ADDWFC x43,W
0DEE:  MOVWF  FEA
0DF0:  MOVFF  FEF,844
0DF4:  MOVLW  08
0DF6:  ADDWF  x3A,W
0DF8:  MOVWF  x45
0DFA:  MOVLW  00
0DFC:  ADDWFC x3B,W
0DFE:  MOVWF  x46
0E00:  MOVF   x38,W
0E02:  ADDWF  x45,W
0E04:  MOVWF  FE9
0E06:  MOVF   x39,W
0E08:  ADDWFC x46,W
0E0A:  MOVWF  FEA
0E0C:  MOVFF  FEF,847
0E10:  MOVLW  07
0E12:  ADDWF  x3A,W
0E14:  MOVWF  x48
0E16:  MOVLW  00
0E18:  ADDWFC x3B,W
0E1A:  MOVWF  x49
0E1C:  MOVF   x38,W
0E1E:  ADDWF  x48,W
0E20:  MOVWF  FE9
0E22:  MOVF   x39,W
0E24:  ADDWFC x49,W
0E26:  MOVWF  FEA
0E28:  MOVFF  FEF,84A
0E2C:  MOVLW  06
0E2E:  ADDWF  x3A,W
0E30:  MOVWF  x4B
0E32:  MOVLW  00
0E34:  ADDWFC x3B,W
0E36:  MOVWF  x4C
0E38:  MOVF   x38,W
0E3A:  ADDWF  x4B,W
0E3C:  MOVWF  FE9
0E3E:  MOVF   x39,W
0E40:  ADDWFC x4C,W
0E42:  MOVWF  FEA
0E44:  MOVFF  FEF,84D
0E48:  MOVLW  05
0E4A:  ADDWF  x3A,W
0E4C:  MOVWF  x4E
0E4E:  MOVLW  00
0E50:  ADDWFC x3B,W
0E52:  MOVWF  x4F
0E54:  MOVF   x38,W
0E56:  ADDWF  x4E,W
0E58:  MOVWF  FE9
0E5A:  MOVF   x39,W
0E5C:  ADDWFC x4F,W
0E5E:  MOVWF  FEA
0E60:  MOVFF  FEF,850
0E64:  CLRF   x57
0E66:  CLRF   x58
0E68:  CLRF   x59
0E6A:  MOVFF  844,85A
0E6E:  MOVFF  847,85B
0E72:  MOVFF  84A,85C
0E76:  MOVFF  84D,85D
0E7A:  MOVFF  850,85E
0E7E:  MOVLB  0
0E80:  CALL   0670
0E84:  MOVFF  01,83F
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0E88:  MOVLB  8
0E8A:  MOVF   x3E,W
0E8C:  SUBLW  0B
0E8E:  BTFSS  FD8.2
0E90:  BRA    0FA6
0E92:  MOVF   x3F,W
0E94:  SUBLW  1F
0E96:  BTFSC  FD8.2
0E98:  BRA    0FA6
0E9A:  MOVF   x3F,W
0E9C:  SUBLW  0F
0E9E:  BTFSC  FD8.2
0EA0:  BRA    0FA6
....................             { 
....................                j=i; 
0EA2:  MOVFF  83B,83D
0EA6:  MOVFF  83A,83C
....................                CRC=1; 
0EAA:  MOVLW  01
0EAC:  MOVWF  x41
....................                temp2=temp; 
0EAE:  MOVFF  83E,840
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0EB2:  MOVF   x40,W
0EB4:  SUBLW  1F
0EB6:  BZ    0F92
0EB8:  MOVF   x3D,W
0EBA:  SUBLW  01
0EBC:  BNC   0F92
0EBE:  BNZ   0EC6
0EC0:  MOVF   x3C,W
0EC2:  SUBLW  F3
0EC4:  BNC   0F92
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0EC6:  CLRF   x42
0EC8:  MOVFF  83D,844
0ECC:  MOVFF  83C,843
0ED0:  MOVFF  839,846
0ED4:  MOVFF  838,845
0ED8:  MOVLB  0
0EDA:  RCALL  0886
0EDC:  MOVF   01,W
0EDE:  MOVLB  8
0EE0:  ANDWF  x41,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0EE2:  MOVLW  04
0EE4:  ADDWF  x3C,W
0EE6:  MOVWF  x42
0EE8:  MOVLW  00
0EEA:  ADDWFC x3D,W
0EEC:  MOVWF  x43
0EEE:  MOVF   x38,W
0EF0:  ADDWF  x42,W
0EF2:  MOVWF  FE9
0EF4:  MOVF   x39,W
0EF6:  ADDWFC x43,W
0EF8:  MOVWF  FEA
0EFA:  MOVFF  FEF,844
0EFE:  MOVLW  03
0F00:  ADDWF  x3C,W
0F02:  MOVWF  x45
0F04:  MOVLW  00
0F06:  ADDWFC x3D,W
0F08:  MOVWF  x46
0F0A:  MOVF   x38,W
0F0C:  ADDWF  x45,W
0F0E:  MOVWF  FE9
0F10:  MOVF   x39,W
0F12:  ADDWFC x46,W
0F14:  MOVWF  FEA
0F16:  MOVFF  FEF,847
0F1A:  MOVLW  02
0F1C:  ADDWF  x3C,W
0F1E:  MOVWF  x48
0F20:  MOVLW  00
0F22:  ADDWFC x3D,W
0F24:  MOVWF  x49
0F26:  MOVF   x38,W
0F28:  ADDWF  x48,W
0F2A:  MOVWF  FE9
0F2C:  MOVF   x39,W
0F2E:  ADDWFC x49,W
0F30:  MOVWF  FEA
0F32:  MOVFF  FEF,84A
0F36:  MOVLW  01
0F38:  ADDWF  x3C,W
0F3A:  MOVWF  x4B
0F3C:  MOVLW  00
0F3E:  ADDWFC x3D,W
0F40:  MOVWF  x4C
0F42:  MOVF   x38,W
0F44:  ADDWF  x4B,W
0F46:  MOVWF  FE9
0F48:  MOVF   x39,W
0F4A:  ADDWFC x4C,W
0F4C:  MOVWF  FEA
0F4E:  MOVFF  FEF,84D
0F52:  MOVF   x38,W
0F54:  ADDWF  x3C,W
0F56:  MOVWF  FE9
0F58:  MOVF   x39,W
0F5A:  ADDWFC x3D,W
0F5C:  MOVWF  FEA
0F5E:  MOVFF  FEF,84E
0F62:  CLRF   x57
0F64:  CLRF   x58
0F66:  CLRF   x59
0F68:  MOVFF  844,85A
0F6C:  MOVFF  847,85B
0F70:  MOVFF  84A,85C
0F74:  MOVFF  84D,85D
0F78:  MOVFF  84E,85E
0F7C:  MOVLB  0
0F7E:  CALL   0670
0F82:  MOVFF  01,840
....................                   j=j+5; 
0F86:  MOVLW  05
0F88:  MOVLB  8
0F8A:  ADDWF  x3C,F
0F8C:  MOVLW  00
0F8E:  ADDWFC x3D,F
....................                } 
0F90:  BRA    0EB2
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0F92:  DECFSZ x41,W
0F94:  BRA    0FA6
....................                { 
....................                   dir=0; 
0F96:  MOVLB  6
0F98:  CLRF   xC3
....................                   return i; 
0F9A:  MOVLB  8
0F9C:  MOVFF  83A,01
0FA0:  MOVFF  83B,02
0FA4:  BRA    15C4
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0FA6:  INCF   x3A,F
0FA8:  BTFSC  FD8.2
0FAA:  INCF   x3B,F
0FAC:  BRA    09D4
....................    for(i=end_point;i>end_point/4;i--) 
0FAE:  MOVFF  837,83B
0FB2:  MOVFF  836,83A
0FB6:  RRCF   x37,W
0FB8:  MOVWF  03
0FBA:  RRCF   x36,W
0FBC:  MOVWF  02
0FBE:  RRCF   03,F
0FC0:  RRCF   02,F
0FC2:  MOVLW  3F
0FC4:  ANDWF  03,F
0FC6:  MOVFF  02,01
0FCA:  MOVF   03,W
0FCC:  SUBWF  x3B,W
0FCE:  BTFSS  FD8.0
0FD0:  BRA    15BE
0FD2:  BNZ   0FDC
0FD4:  MOVF   x3A,W
0FD6:  SUBWF  01,W
0FD8:  BTFSC  FD8.0
0FDA:  BRA    15BE
....................    { 
....................       if(track==0) 
0FDC:  MOVF   x35,F
0FDE:  BTFSS  FD8.2
0FE0:  BRA    1334
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
0FE2:  MOVLW  06
0FE4:  SUBWF  x3A,W
0FE6:  MOVWF  x42
0FE8:  MOVLW  00
0FEA:  SUBWFB x3B,W
0FEC:  MOVWF  x43
0FEE:  MOVF   x38,W
0FF0:  ADDWF  x42,W
0FF2:  MOVWF  FE9
0FF4:  MOVF   x39,W
0FF6:  ADDWFC x43,W
0FF8:  MOVWF  FEA
0FFA:  MOVFF  FEF,844
0FFE:  MOVLW  05
1000:  SUBWF  x3A,W
1002:  MOVWF  x45
1004:  MOVLW  00
1006:  SUBWFB x3B,W
1008:  MOVWF  x46
100A:  MOVF   x38,W
100C:  ADDWF  x45,W
100E:  MOVWF  FE9
1010:  MOVF   x39,W
1012:  ADDWFC x46,W
1014:  MOVWF  FEA
1016:  MOVFF  FEF,847
101A:  MOVLW  04
101C:  SUBWF  x3A,W
101E:  MOVWF  x48
1020:  MOVLW  00
1022:  SUBWFB x3B,W
1024:  MOVWF  x49
1026:  MOVF   x38,W
1028:  ADDWF  x48,W
102A:  MOVWF  FE9
102C:  MOVF   x39,W
102E:  ADDWFC x49,W
1030:  MOVWF  FEA
1032:  MOVFF  FEF,84A
1036:  MOVLW  03
1038:  SUBWF  x3A,W
103A:  MOVWF  x4B
103C:  MOVLW  00
103E:  SUBWFB x3B,W
1040:  MOVWF  x4C
1042:  MOVF   x38,W
1044:  ADDWF  x4B,W
1046:  MOVWF  FE9
1048:  MOVF   x39,W
104A:  ADDWFC x4C,W
104C:  MOVWF  FEA
104E:  MOVFF  FEF,84D
1052:  MOVLW  02
1054:  SUBWF  x3A,W
1056:  MOVWF  x4E
1058:  MOVLW  00
105A:  SUBWFB x3B,W
105C:  MOVWF  x4F
105E:  MOVF   x38,W
1060:  ADDWF  x4E,W
1062:  MOVWF  FE9
1064:  MOVF   x39,W
1066:  ADDWFC x4F,W
1068:  MOVWF  FEA
106A:  MOVFF  FEF,850
106E:  MOVLW  01
1070:  SUBWF  x3A,W
1072:  MOVWF  x51
1074:  MOVLW  00
1076:  SUBWFB x3B,W
1078:  MOVWF  x52
107A:  MOVF   x38,W
107C:  ADDWF  x51,W
107E:  MOVWF  FE9
1080:  MOVF   x39,W
1082:  ADDWFC x52,W
1084:  MOVWF  FEA
1086:  MOVFF  FEF,853
108A:  MOVF   x38,W
108C:  ADDWF  x3A,W
108E:  MOVWF  FE9
1090:  MOVF   x39,W
1092:  ADDWFC x3B,W
1094:  MOVWF  FEA
1096:  MOVFF  FEF,854
109A:  CLRF   x57
109C:  MOVFF  844,858
10A0:  MOVFF  847,859
10A4:  MOVFF  84A,85A
10A8:  MOVFF  84D,85B
10AC:  MOVFF  850,85C
10B0:  MOVFF  853,85D
10B4:  MOVFF  854,85E
10B8:  MOVLB  0
10BA:  CALL   0670
10BE:  MOVFF  01,83E
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
10C2:  MOVLW  0D
10C4:  MOVLB  8
10C6:  SUBWF  x3A,W
10C8:  MOVWF  x42
10CA:  MOVLW  00
10CC:  SUBWFB x3B,W
10CE:  MOVWF  x43
10D0:  MOVF   x38,W
10D2:  ADDWF  x42,W
10D4:  MOVWF  FE9
10D6:  MOVF   x39,W
10D8:  ADDWFC x43,W
10DA:  MOVWF  FEA
10DC:  MOVFF  FEF,844
10E0:  MOVLW  0C
10E2:  SUBWF  x3A,W
10E4:  MOVWF  x45
10E6:  MOVLW  00
10E8:  SUBWFB x3B,W
10EA:  MOVWF  x46
10EC:  MOVF   x38,W
10EE:  ADDWF  x45,W
10F0:  MOVWF  FE9
10F2:  MOVF   x39,W
10F4:  ADDWFC x46,W
10F6:  MOVWF  FEA
10F8:  MOVFF  FEF,847
10FC:  MOVLW  0B
10FE:  SUBWF  x3A,W
1100:  MOVWF  x48
1102:  MOVLW  00
1104:  SUBWFB x3B,W
1106:  MOVWF  x49
1108:  MOVF   x38,W
110A:  ADDWF  x48,W
110C:  MOVWF  FE9
110E:  MOVF   x39,W
1110:  ADDWFC x49,W
1112:  MOVWF  FEA
1114:  MOVFF  FEF,84A
1118:  MOVLW  0A
111A:  SUBWF  x3A,W
111C:  MOVWF  x4B
111E:  MOVLW  00
1120:  SUBWFB x3B,W
1122:  MOVWF  x4C
1124:  MOVF   x38,W
1126:  ADDWF  x4B,W
1128:  MOVWF  FE9
112A:  MOVF   x39,W
112C:  ADDWFC x4C,W
112E:  MOVWF  FEA
1130:  MOVFF  FEF,84D
1134:  MOVLW  09
1136:  SUBWF  x3A,W
1138:  MOVWF  x4E
113A:  MOVLW  00
113C:  SUBWFB x3B,W
113E:  MOVWF  x4F
1140:  MOVF   x38,W
1142:  ADDWF  x4E,W
1144:  MOVWF  FE9
1146:  MOVF   x39,W
1148:  ADDWFC x4F,W
114A:  MOVWF  FEA
114C:  MOVFF  FEF,850
1150:  MOVLW  08
1152:  SUBWF  x3A,W
1154:  MOVWF  x51
1156:  MOVLW  00
1158:  SUBWFB x3B,W
115A:  MOVWF  x52
115C:  MOVF   x38,W
115E:  ADDWF  x51,W
1160:  MOVWF  FE9
1162:  MOVF   x39,W
1164:  ADDWFC x52,W
1166:  MOVWF  FEA
1168:  MOVFF  FEF,853
116C:  MOVLW  07
116E:  SUBWF  x3A,W
1170:  MOVWF  x54
1172:  MOVLW  00
1174:  SUBWFB x3B,W
1176:  MOVWF  x55
1178:  MOVF   x38,W
117A:  ADDWF  x54,W
117C:  MOVWF  FE9
117E:  MOVF   x39,W
1180:  ADDWFC x55,W
1182:  MOVWF  FEA
1184:  MOVFF  FEF,856
1188:  CLRF   x57
118A:  MOVFF  844,858
118E:  MOVFF  847,859
1192:  MOVFF  84A,85A
1196:  MOVFF  84D,85B
119A:  MOVFF  850,85C
119E:  MOVFF  853,85D
11A2:  MOVFF  856,85E
11A6:  MOVLB  0
11A8:  CALL   0670
11AC:  MOVFF  01,83F
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
11B0:  MOVLB  8
11B2:  MOVF   x3E,W
11B4:  SUBLW  45
11B6:  BTFSS  FD8.2
11B8:  BRA    1332
11BA:  MOVF   x3F,W
11BC:  SUBLW  7C
11BE:  BTFSC  FD8.2
11C0:  BRA    1332
11C2:  MOVF   x3F,W
11C4:  SUBLW  3E
11C6:  BTFSC  FD8.2
11C8:  BRA    1332
11CA:  MOVF   x3F,W
11CC:  SUBLW  1F
11CE:  BTFSC  FD8.2
11D0:  BRA    1332
11D2:  MOVF   x3F,W
11D4:  SUBLW  0F
11D6:  BTFSC  FD8.2
11D8:  BRA    1332
11DA:  MOVF   x3F,W
11DC:  SUBLW  78
11DE:  BTFSC  FD8.2
11E0:  BRA    1332
....................          { 
....................             j=i; 
11E2:  MOVFF  83B,83D
11E6:  MOVFF  83A,83C
....................             CRC=1; 
11EA:  MOVLW  01
11EC:  MOVWF  x41
....................             temp2=temp; 
11EE:  MOVFF  83E,840
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
11F2:  MOVF   x40,W
11F4:  SUBLW  1F
11F6:  BTFSC  FD8.2
11F8:  BRA    1312
11FA:  MOVF   x3D,F
11FC:  BNZ   1206
11FE:  MOVF   x3C,W
1200:  SUBLW  01
1202:  BTFSC  FD8.0
1204:  BRA    1312
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1206:  MOVLW  01
1208:  MOVWF  x42
120A:  MOVFF  83D,844
120E:  MOVFF  83C,843
1212:  MOVFF  839,846
1216:  MOVFF  838,845
121A:  MOVLB  0
121C:  CALL   06D6
1220:  MOVF   01,W
1222:  MOVLB  8
1224:  ANDWF  x41,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1226:  MOVLW  06
1228:  SUBWF  x3C,W
122A:  MOVWF  x42
122C:  MOVLW  00
122E:  SUBWFB x3D,W
1230:  MOVWF  x43
1232:  MOVF   x38,W
1234:  ADDWF  x42,W
1236:  MOVWF  FE9
1238:  MOVF   x39,W
123A:  ADDWFC x43,W
123C:  MOVWF  FEA
123E:  MOVFF  FEF,844
1242:  MOVLW  05
1244:  SUBWF  x3C,W
1246:  MOVWF  x45
1248:  MOVLW  00
124A:  SUBWFB x3D,W
124C:  MOVWF  x46
124E:  MOVF   x38,W
1250:  ADDWF  x45,W
1252:  MOVWF  FE9
1254:  MOVF   x39,W
1256:  ADDWFC x46,W
1258:  MOVWF  FEA
125A:  MOVFF  FEF,847
125E:  MOVLW  04
1260:  SUBWF  x3C,W
1262:  MOVWF  x48
1264:  MOVLW  00
1266:  SUBWFB x3D,W
1268:  MOVWF  x49
126A:  MOVF   x38,W
126C:  ADDWF  x48,W
126E:  MOVWF  FE9
1270:  MOVF   x39,W
1272:  ADDWFC x49,W
1274:  MOVWF  FEA
1276:  MOVFF  FEF,84A
127A:  MOVLW  03
127C:  SUBWF  x3C,W
127E:  MOVWF  x4B
1280:  MOVLW  00
1282:  SUBWFB x3D,W
1284:  MOVWF  x4C
1286:  MOVF   x38,W
1288:  ADDWF  x4B,W
128A:  MOVWF  FE9
128C:  MOVF   x39,W
128E:  ADDWFC x4C,W
1290:  MOVWF  FEA
1292:  MOVFF  FEF,84D
1296:  MOVLW  02
1298:  SUBWF  x3C,W
129A:  MOVWF  x4E
129C:  MOVLW  00
129E:  SUBWFB x3D,W
12A0:  MOVWF  x4F
12A2:  MOVF   x38,W
12A4:  ADDWF  x4E,W
12A6:  MOVWF  FE9
12A8:  MOVF   x39,W
12AA:  ADDWFC x4F,W
12AC:  MOVWF  FEA
12AE:  MOVFF  FEF,850
12B2:  MOVLW  01
12B4:  SUBWF  x3C,W
12B6:  MOVWF  x51
12B8:  MOVLW  00
12BA:  SUBWFB x3D,W
12BC:  MOVWF  x52
12BE:  MOVF   x38,W
12C0:  ADDWF  x51,W
12C2:  MOVWF  FE9
12C4:  MOVF   x39,W
12C6:  ADDWFC x52,W
12C8:  MOVWF  FEA
12CA:  MOVFF  FEF,853
12CE:  MOVF   x38,W
12D0:  ADDWF  x3C,W
12D2:  MOVWF  FE9
12D4:  MOVF   x39,W
12D6:  ADDWFC x3D,W
12D8:  MOVWF  FEA
12DA:  MOVFF  FEF,854
12DE:  CLRF   x57
12E0:  MOVFF  844,858
12E4:  MOVFF  847,859
12E8:  MOVFF  84A,85A
12EC:  MOVFF  84D,85B
12F0:  MOVFF  850,85C
12F4:  MOVFF  853,85D
12F8:  MOVFF  854,85E
12FC:  MOVLB  0
12FE:  CALL   0670
1302:  MOVFF  01,840
....................                j=j-7;             
1306:  MOVLW  07
1308:  MOVLB  8
130A:  SUBWF  x3C,F
130C:  MOVLW  00
130E:  SUBWFB x3D,F
....................              } 
1310:  BRA    11F2
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
1312:  DECFSZ x41,W
1314:  BRA    132A
....................             { 
....................                dir=1; 
1316:  MOVLW  01
1318:  MOVLB  6
131A:  MOVWF  xC3
....................                return i; 
131C:  MOVLB  8
131E:  MOVFF  83A,01
1322:  MOVFF  83B,02
1326:  BRA    15C4
....................             } 
....................             else return 0; 
1328:  BRA    1332
132A:  MOVLW  00
132C:  MOVWF  01
132E:  MOVWF  02
1330:  BRA    15C4
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
1332:  BRA    15B4
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1334:  MOVLW  04
1336:  SUBWF  x3A,W
1338:  MOVWF  x42
133A:  MOVLW  00
133C:  SUBWFB x3B,W
133E:  MOVWF  x43
1340:  MOVF   x38,W
1342:  ADDWF  x42,W
1344:  MOVWF  FE9
1346:  MOVF   x39,W
1348:  ADDWFC x43,W
134A:  MOVWF  FEA
134C:  MOVFF  FEF,844
1350:  MOVLW  03
1352:  SUBWF  x3A,W
1354:  MOVWF  x45
1356:  MOVLW  00
1358:  SUBWFB x3B,W
135A:  MOVWF  x46
135C:  MOVF   x38,W
135E:  ADDWF  x45,W
1360:  MOVWF  FE9
1362:  MOVF   x39,W
1364:  ADDWFC x46,W
1366:  MOVWF  FEA
1368:  MOVFF  FEF,847
136C:  MOVLW  02
136E:  SUBWF  x3A,W
1370:  MOVWF  x48
1372:  MOVLW  00
1374:  SUBWFB x3B,W
1376:  MOVWF  x49
1378:  MOVF   x38,W
137A:  ADDWF  x48,W
137C:  MOVWF  FE9
137E:  MOVF   x39,W
1380:  ADDWFC x49,W
1382:  MOVWF  FEA
1384:  MOVFF  FEF,84A
1388:  MOVLW  01
138A:  SUBWF  x3A,W
138C:  MOVWF  x4B
138E:  MOVLW  00
1390:  SUBWFB x3B,W
1392:  MOVWF  x4C
1394:  MOVF   x38,W
1396:  ADDWF  x4B,W
1398:  MOVWF  FE9
139A:  MOVF   x39,W
139C:  ADDWFC x4C,W
139E:  MOVWF  FEA
13A0:  MOVFF  FEF,84D
13A4:  MOVF   x38,W
13A6:  ADDWF  x3A,W
13A8:  MOVWF  FE9
13AA:  MOVF   x39,W
13AC:  ADDWFC x3B,W
13AE:  MOVWF  FEA
13B0:  MOVFF  FEF,84E
13B4:  CLRF   x57
13B6:  CLRF   x58
13B8:  CLRF   x59
13BA:  MOVFF  844,85A
13BE:  MOVFF  847,85B
13C2:  MOVFF  84A,85C
13C6:  MOVFF  84D,85D
13CA:  MOVFF  84E,85E
13CE:  MOVLB  0
13D0:  CALL   0670
13D4:  MOVFF  01,83E
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
13D8:  MOVLW  09
13DA:  MOVLB  8
13DC:  SUBWF  x3A,W
13DE:  MOVWF  x42
13E0:  MOVLW  00
13E2:  SUBWFB x3B,W
13E4:  MOVWF  x43
13E6:  MOVF   x38,W
13E8:  ADDWF  x42,W
13EA:  MOVWF  FE9
13EC:  MOVF   x39,W
13EE:  ADDWFC x43,W
13F0:  MOVWF  FEA
13F2:  MOVFF  FEF,844
13F6:  MOVLW  08
13F8:  SUBWF  x3A,W
13FA:  MOVWF  x45
13FC:  MOVLW  00
13FE:  SUBWFB x3B,W
1400:  MOVWF  x46
1402:  MOVF   x38,W
1404:  ADDWF  x45,W
1406:  MOVWF  FE9
1408:  MOVF   x39,W
140A:  ADDWFC x46,W
140C:  MOVWF  FEA
140E:  MOVFF  FEF,847
1412:  MOVLW  07
1414:  SUBWF  x3A,W
1416:  MOVWF  x48
1418:  MOVLW  00
141A:  SUBWFB x3B,W
141C:  MOVWF  x49
141E:  MOVF   x38,W
1420:  ADDWF  x48,W
1422:  MOVWF  FE9
1424:  MOVF   x39,W
1426:  ADDWFC x49,W
1428:  MOVWF  FEA
142A:  MOVFF  FEF,84A
142E:  MOVLW  06
1430:  SUBWF  x3A,W
1432:  MOVWF  x4B
1434:  MOVLW  00
1436:  SUBWFB x3B,W
1438:  MOVWF  x4C
143A:  MOVF   x38,W
143C:  ADDWF  x4B,W
143E:  MOVWF  FE9
1440:  MOVF   x39,W
1442:  ADDWFC x4C,W
1444:  MOVWF  FEA
1446:  MOVFF  FEF,84D
144A:  MOVLW  05
144C:  SUBWF  x3A,W
144E:  MOVWF  x4E
1450:  MOVLW  00
1452:  SUBWFB x3B,W
1454:  MOVWF  x4F
1456:  MOVF   x38,W
1458:  ADDWF  x4E,W
145A:  MOVWF  FE9
145C:  MOVF   x39,W
145E:  ADDWFC x4F,W
1460:  MOVWF  FEA
1462:  MOVFF  FEF,850
1466:  CLRF   x57
1468:  CLRF   x58
146A:  CLRF   x59
146C:  MOVFF  844,85A
1470:  MOVFF  847,85B
1474:  MOVFF  84A,85C
1478:  MOVFF  84D,85D
147C:  MOVFF  850,85E
1480:  MOVLB  0
1482:  CALL   0670
1486:  MOVFF  01,83F
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
148A:  MOVLB  8
148C:  MOVF   x3E,W
148E:  SUBLW  0B
1490:  BTFSS  FD8.2
1492:  BRA    15B4
1494:  MOVF   x3F,W
1496:  SUBLW  1F
1498:  BTFSC  FD8.2
149A:  BRA    15B4
149C:  MOVF   x3F,W
149E:  SUBLW  0F
14A0:  BTFSC  FD8.2
14A2:  BRA    15B4
....................             { 
....................                j=i; 
14A4:  MOVFF  83B,83D
14A8:  MOVFF  83A,83C
....................                CRC=1; 
14AC:  MOVLW  01
14AE:  MOVWF  x41
....................                temp2=temp; 
14B0:  MOVFF  83E,840
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
14B4:  MOVF   x40,W
14B6:  SUBLW  1F
14B8:  BZ    1594
14BA:  MOVF   x3D,F
14BC:  BNZ   14C4
14BE:  MOVF   x3C,W
14C0:  SUBLW  01
14C2:  BC    1594
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
14C4:  MOVLW  01
14C6:  MOVWF  x42
14C8:  MOVFF  83D,844
14CC:  MOVFF  83C,843
14D0:  MOVFF  839,846
14D4:  MOVFF  838,845
14D8:  MOVLB  0
14DA:  CALL   0886
14DE:  MOVF   01,W
14E0:  MOVLB  8
14E2:  ANDWF  x41,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
14E4:  MOVLW  04
14E6:  SUBWF  x3C,W
14E8:  MOVWF  x42
14EA:  MOVLW  00
14EC:  SUBWFB x3D,W
14EE:  MOVWF  x43
14F0:  MOVF   x38,W
14F2:  ADDWF  x42,W
14F4:  MOVWF  FE9
14F6:  MOVF   x39,W
14F8:  ADDWFC x43,W
14FA:  MOVWF  FEA
14FC:  MOVFF  FEF,844
1500:  MOVLW  03
1502:  SUBWF  x3C,W
1504:  MOVWF  x45
1506:  MOVLW  00
1508:  SUBWFB x3D,W
150A:  MOVWF  x46
150C:  MOVF   x38,W
150E:  ADDWF  x45,W
1510:  MOVWF  FE9
1512:  MOVF   x39,W
1514:  ADDWFC x46,W
1516:  MOVWF  FEA
1518:  MOVFF  FEF,847
151C:  MOVLW  02
151E:  SUBWF  x3C,W
1520:  MOVWF  x48
1522:  MOVLW  00
1524:  SUBWFB x3D,W
1526:  MOVWF  x49
1528:  MOVF   x38,W
152A:  ADDWF  x48,W
152C:  MOVWF  FE9
152E:  MOVF   x39,W
1530:  ADDWFC x49,W
1532:  MOVWF  FEA
1534:  MOVFF  FEF,84A
1538:  MOVLW  01
153A:  SUBWF  x3C,W
153C:  MOVWF  x4B
153E:  MOVLW  00
1540:  SUBWFB x3D,W
1542:  MOVWF  x4C
1544:  MOVF   x38,W
1546:  ADDWF  x4B,W
1548:  MOVWF  FE9
154A:  MOVF   x39,W
154C:  ADDWFC x4C,W
154E:  MOVWF  FEA
1550:  MOVFF  FEF,84D
1554:  MOVF   x38,W
1556:  ADDWF  x3C,W
1558:  MOVWF  FE9
155A:  MOVF   x39,W
155C:  ADDWFC x3D,W
155E:  MOVWF  FEA
1560:  MOVFF  FEF,84E
1564:  CLRF   x57
1566:  CLRF   x58
1568:  CLRF   x59
156A:  MOVFF  844,85A
156E:  MOVFF  847,85B
1572:  MOVFF  84A,85C
1576:  MOVFF  84D,85D
157A:  MOVFF  84E,85E
157E:  MOVLB  0
1580:  CALL   0670
1584:  MOVFF  01,840
....................                   j=j-5; 
1588:  MOVLW  05
158A:  MOVLB  8
158C:  SUBWF  x3C,F
158E:  MOVLW  00
1590:  SUBWFB x3D,F
....................                } 
1592:  BRA    14B4
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
1594:  DECFSZ x41,W
1596:  BRA    15AC
....................                { 
....................                   dir=1; 
1598:  MOVLW  01
159A:  MOVLB  6
159C:  MOVWF  xC3
....................                   return i; 
159E:  MOVLB  8
15A0:  MOVFF  83A,01
15A4:  MOVFF  83B,02
15A8:  BRA    15C4
....................                } 
....................                   else return 0; 
15AA:  BRA    15B4
15AC:  MOVLW  00
15AE:  MOVWF  01
15B0:  MOVWF  02
15B2:  BRA    15C4
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
15B4:  MOVF   x3A,W
15B6:  BTFSC  FD8.2
15B8:  DECF   x3B,F
15BA:  DECF   x3A,F
15BC:  BRA    0FB6
....................    return 0; 
15BE:  MOVLW  00
15C0:  MOVWF  01
15C2:  MOVWF  02
.................... } 
15C4:  MOVLB  0
15C6:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
3530:  MOVLB  8
3532:  CLRF   x34
3534:  MOVLW  01
3536:  MOVWF  x33
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3538:  MOVFF  829,835
353C:  MOVFF  82B,837
3540:  MOVFF  82A,836
3544:  MOVFF  82D,839
3548:  MOVFF  82C,838
354C:  MOVLB  0
354E:  CALL   09C6
3552:  MOVFF  02,834
3556:  MOVFF  01,833
....................    if(temp==0) return 0; 
355A:  MOVLB  8
355C:  MOVF   x33,F
355E:  BNZ   356A
3560:  MOVF   x34,F
3562:  BNZ   356A
3564:  MOVLW  00
3566:  MOVWF  01
3568:  BRA    3914
....................    j=temp; 
356A:  MOVFF  834,832
356E:  MOVFF  833,831
....................    if(dir==0) 
3572:  MOVLB  6
3574:  MOVF   xC3,F
3576:  BTFSS  FD8.2
3578:  BRA    3734
....................    { 
....................       if(track==0) 
357A:  MOVLB  8
357C:  MOVF   x29,F
357E:  BTFSS  FD8.2
3580:  BRA    3678
....................       { 
....................             for(i=0;i<79;i++) 
3582:  CLRF   x30
3584:  MOVF   x30,W
3586:  SUBLW  4E
3588:  BNC   3676
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
358A:  CLRF   03
358C:  MOVF   x30,W
358E:  ADDWF  x2E,W
3590:  MOVWF  01
3592:  MOVF   x2F,W
3594:  ADDWFC 03,F
3596:  MOVFF  01,835
359A:  MOVFF  03,836
359E:  MOVLW  05
35A0:  ADDWF  x31,W
35A2:  MOVWF  x37
35A4:  MOVLW  00
35A6:  ADDWFC x32,W
35A8:  MOVWF  x38
35AA:  MOVF   x2C,W
35AC:  ADDWF  x37,W
35AE:  MOVWF  FE9
35B0:  MOVF   x2D,W
35B2:  ADDWFC x38,W
35B4:  MOVWF  FEA
35B6:  MOVFF  FEF,839
35BA:  MOVLW  04
35BC:  ADDWF  x31,W
35BE:  MOVWF  x3A
35C0:  MOVLW  00
35C2:  ADDWFC x32,W
35C4:  MOVWF  x3B
35C6:  MOVF   x2C,W
35C8:  ADDWF  x3A,W
35CA:  MOVWF  FE9
35CC:  MOVF   x2D,W
35CE:  ADDWFC x3B,W
35D0:  MOVWF  FEA
35D2:  MOVFF  FEF,83C
35D6:  MOVLW  03
35D8:  ADDWF  x31,W
35DA:  MOVWF  x3D
35DC:  MOVLW  00
35DE:  ADDWFC x32,W
35E0:  MOVWF  x3E
35E2:  MOVF   x2C,W
35E4:  ADDWF  x3D,W
35E6:  MOVWF  FE9
35E8:  MOVF   x2D,W
35EA:  ADDWFC x3E,W
35EC:  MOVWF  FEA
35EE:  MOVFF  FEF,83F
35F2:  MOVLW  02
35F4:  ADDWF  x31,W
35F6:  MOVWF  x40
35F8:  MOVLW  00
35FA:  ADDWFC x32,W
35FC:  MOVWF  x41
35FE:  MOVF   x2C,W
3600:  ADDWF  x40,W
3602:  MOVWF  FE9
3604:  MOVF   x2D,W
3606:  ADDWFC x41,W
3608:  MOVWF  FEA
360A:  MOVFF  FEF,842
360E:  MOVLW  01
3610:  ADDWF  x31,W
3612:  MOVWF  x43
3614:  MOVLW  00
3616:  ADDWFC x32,W
3618:  MOVWF  x44
361A:  MOVF   x2C,W
361C:  ADDWF  x43,W
361E:  MOVWF  FE9
3620:  MOVF   x2D,W
3622:  ADDWFC x44,W
3624:  MOVWF  FEA
3626:  MOVFF  FEF,845
362A:  MOVF   x2C,W
362C:  ADDWF  x31,W
362E:  MOVWF  FE9
3630:  MOVF   x2D,W
3632:  ADDWFC x32,W
3634:  MOVWF  FEA
3636:  MOVFF  FEF,846
363A:  CLRF   x57
363C:  CLRF   x58
363E:  MOVFF  839,859
3642:  MOVFF  83C,85A
3646:  MOVFF  83F,85B
364A:  MOVFF  842,85C
364E:  MOVFF  845,85D
3652:  MOVFF  846,85E
3656:  MOVLB  0
3658:  CALL   0670
365C:  MOVFF  836,FEA
3660:  MOVFF  835,FE9
3664:  MOVFF  01,FEF
....................                j=j+7; 
3668:  MOVLW  07
366A:  MOVLB  8
366C:  ADDWF  x31,F
366E:  MOVLW  00
3670:  ADDWFC x32,F
....................             } 
3672:  INCF   x30,F
3674:  BRA    3584
....................       } 
....................          else  
3676:  BRA    3730
....................          { 
....................             for(i=0;i<40;i++) 
3678:  CLRF   x30
367A:  MOVF   x30,W
367C:  SUBLW  27
367E:  BNC   3730
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3680:  CLRF   03
3682:  MOVF   x30,W
3684:  ADDWF  x2E,W
3686:  MOVWF  01
3688:  MOVF   x2F,W
368A:  ADDWFC 03,F
368C:  MOVFF  01,835
3690:  MOVFF  03,836
3694:  MOVLW  03
3696:  ADDWF  x31,W
3698:  MOVWF  x37
369A:  MOVLW  00
369C:  ADDWFC x32,W
369E:  MOVWF  x38
36A0:  MOVF   x2C,W
36A2:  ADDWF  x37,W
36A4:  MOVWF  FE9
36A6:  MOVF   x2D,W
36A8:  ADDWFC x38,W
36AA:  MOVWF  FEA
36AC:  MOVFF  FEF,839
36B0:  MOVLW  02
36B2:  ADDWF  x31,W
36B4:  MOVWF  x3A
36B6:  MOVLW  00
36B8:  ADDWFC x32,W
36BA:  MOVWF  x3B
36BC:  MOVF   x2C,W
36BE:  ADDWF  x3A,W
36C0:  MOVWF  FE9
36C2:  MOVF   x2D,W
36C4:  ADDWFC x3B,W
36C6:  MOVWF  FEA
36C8:  MOVFF  FEF,83C
36CC:  MOVLW  01
36CE:  ADDWF  x31,W
36D0:  MOVWF  x3D
36D2:  MOVLW  00
36D4:  ADDWFC x32,W
36D6:  MOVWF  x3E
36D8:  MOVF   x2C,W
36DA:  ADDWF  x3D,W
36DC:  MOVWF  FE9
36DE:  MOVF   x2D,W
36E0:  ADDWFC x3E,W
36E2:  MOVWF  FEA
36E4:  MOVFF  FEF,83F
36E8:  MOVF   x2C,W
36EA:  ADDWF  x31,W
36EC:  MOVWF  FE9
36EE:  MOVF   x2D,W
36F0:  ADDWFC x32,W
36F2:  MOVWF  FEA
36F4:  MOVFF  FEF,840
36F8:  CLRF   x57
36FA:  CLRF   x58
36FC:  CLRF   x59
36FE:  CLRF   x5A
3700:  MOVFF  839,85B
3704:  MOVFF  83C,85C
3708:  MOVFF  83F,85D
370C:  MOVFF  840,85E
3710:  MOVLB  0
3712:  CALL   0670
3716:  MOVFF  836,FEA
371A:  MOVFF  835,FE9
371E:  MOVFF  01,FEF
....................                j=j+5; 
3722:  MOVLW  05
3724:  MOVLB  8
3726:  ADDWF  x31,F
3728:  MOVLW  00
372A:  ADDWFC x32,F
....................             }          
372C:  INCF   x30,F
372E:  BRA    367A
....................          } 
....................    } 
....................       else  
3730:  BRA    38EA
3732:  MOVLB  6
....................       { 
....................          if(track==0) 
3734:  MOVLB  8
3736:  MOVF   x29,F
3738:  BTFSS  FD8.2
373A:  BRA    3832
....................          { 
....................             for(i=0;i<79;i++) 
373C:  CLRF   x30
373E:  MOVF   x30,W
3740:  SUBLW  4E
3742:  BNC   3830
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3744:  CLRF   03
3746:  MOVF   x30,W
3748:  ADDWF  x2E,W
374A:  MOVWF  01
374C:  MOVF   x2F,W
374E:  ADDWFC 03,F
3750:  MOVFF  01,835
3754:  MOVFF  03,836
3758:  MOVLW  05
375A:  SUBWF  x31,W
375C:  MOVWF  x37
375E:  MOVLW  00
3760:  SUBWFB x32,W
3762:  MOVWF  x38
3764:  MOVF   x2C,W
3766:  ADDWF  x37,W
3768:  MOVWF  FE9
376A:  MOVF   x2D,W
376C:  ADDWFC x38,W
376E:  MOVWF  FEA
3770:  MOVFF  FEF,839
3774:  MOVLW  04
3776:  SUBWF  x31,W
3778:  MOVWF  x3A
377A:  MOVLW  00
377C:  SUBWFB x32,W
377E:  MOVWF  x3B
3780:  MOVF   x2C,W
3782:  ADDWF  x3A,W
3784:  MOVWF  FE9
3786:  MOVF   x2D,W
3788:  ADDWFC x3B,W
378A:  MOVWF  FEA
378C:  MOVFF  FEF,83C
3790:  MOVLW  03
3792:  SUBWF  x31,W
3794:  MOVWF  x3D
3796:  MOVLW  00
3798:  SUBWFB x32,W
379A:  MOVWF  x3E
379C:  MOVF   x2C,W
379E:  ADDWF  x3D,W
37A0:  MOVWF  FE9
37A2:  MOVF   x2D,W
37A4:  ADDWFC x3E,W
37A6:  MOVWF  FEA
37A8:  MOVFF  FEF,83F
37AC:  MOVLW  02
37AE:  SUBWF  x31,W
37B0:  MOVWF  x40
37B2:  MOVLW  00
37B4:  SUBWFB x32,W
37B6:  MOVWF  x41
37B8:  MOVF   x2C,W
37BA:  ADDWF  x40,W
37BC:  MOVWF  FE9
37BE:  MOVF   x2D,W
37C0:  ADDWFC x41,W
37C2:  MOVWF  FEA
37C4:  MOVFF  FEF,842
37C8:  MOVLW  01
37CA:  SUBWF  x31,W
37CC:  MOVWF  x43
37CE:  MOVLW  00
37D0:  SUBWFB x32,W
37D2:  MOVWF  x44
37D4:  MOVF   x2C,W
37D6:  ADDWF  x43,W
37D8:  MOVWF  FE9
37DA:  MOVF   x2D,W
37DC:  ADDWFC x44,W
37DE:  MOVWF  FEA
37E0:  MOVFF  FEF,845
37E4:  MOVF   x2C,W
37E6:  ADDWF  x31,W
37E8:  MOVWF  FE9
37EA:  MOVF   x2D,W
37EC:  ADDWFC x32,W
37EE:  MOVWF  FEA
37F0:  MOVFF  FEF,846
37F4:  CLRF   x57
37F6:  CLRF   x58
37F8:  MOVFF  839,859
37FC:  MOVFF  83C,85A
3800:  MOVFF  83F,85B
3804:  MOVFF  842,85C
3808:  MOVFF  845,85D
380C:  MOVFF  846,85E
3810:  MOVLB  0
3812:  CALL   0670
3816:  MOVFF  836,FEA
381A:  MOVFF  835,FE9
381E:  MOVFF  01,FEF
....................                j=j-7; 
3822:  MOVLW  07
3824:  MOVLB  8
3826:  SUBWF  x31,F
3828:  MOVLW  00
382A:  SUBWFB x32,F
....................             } 
382C:  INCF   x30,F
382E:  BRA    373E
....................          } 
....................             else 
3830:  BRA    38EA
....................             { 
....................                for(i=0;i<40;i++) 
3832:  CLRF   x30
3834:  MOVF   x30,W
3836:  SUBLW  27
3838:  BNC   38EA
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
383A:  CLRF   03
383C:  MOVF   x30,W
383E:  ADDWF  x2E,W
3840:  MOVWF  01
3842:  MOVF   x2F,W
3844:  ADDWFC 03,F
3846:  MOVFF  01,835
384A:  MOVFF  03,836
384E:  MOVLW  03
3850:  SUBWF  x31,W
3852:  MOVWF  x37
3854:  MOVLW  00
3856:  SUBWFB x32,W
3858:  MOVWF  x38
385A:  MOVF   x2C,W
385C:  ADDWF  x37,W
385E:  MOVWF  FE9
3860:  MOVF   x2D,W
3862:  ADDWFC x38,W
3864:  MOVWF  FEA
3866:  MOVFF  FEF,839
386A:  MOVLW  02
386C:  SUBWF  x31,W
386E:  MOVWF  x3A
3870:  MOVLW  00
3872:  SUBWFB x32,W
3874:  MOVWF  x3B
3876:  MOVF   x2C,W
3878:  ADDWF  x3A,W
387A:  MOVWF  FE9
387C:  MOVF   x2D,W
387E:  ADDWFC x3B,W
3880:  MOVWF  FEA
3882:  MOVFF  FEF,83C
3886:  MOVLW  01
3888:  SUBWF  x31,W
388A:  MOVWF  x3D
388C:  MOVLW  00
388E:  SUBWFB x32,W
3890:  MOVWF  x3E
3892:  MOVF   x2C,W
3894:  ADDWF  x3D,W
3896:  MOVWF  FE9
3898:  MOVF   x2D,W
389A:  ADDWFC x3E,W
389C:  MOVWF  FEA
389E:  MOVFF  FEF,83F
38A2:  MOVF   x2C,W
38A4:  ADDWF  x31,W
38A6:  MOVWF  FE9
38A8:  MOVF   x2D,W
38AA:  ADDWFC x32,W
38AC:  MOVWF  FEA
38AE:  MOVFF  FEF,840
38B2:  CLRF   x57
38B4:  CLRF   x58
38B6:  CLRF   x59
38B8:  CLRF   x5A
38BA:  MOVFF  839,85B
38BE:  MOVFF  83C,85C
38C2:  MOVFF  83F,85D
38C6:  MOVFF  840,85E
38CA:  MOVLB  0
38CC:  CALL   0670
38D0:  MOVFF  836,FEA
38D4:  MOVFF  835,FE9
38D8:  MOVFF  01,FEF
....................                   j=j-5; 
38DC:  MOVLW  05
38DE:  MOVLB  8
38E0:  SUBWF  x31,F
38E2:  MOVLW  00
38E4:  SUBWFB x32,F
....................                }             
38E6:  INCF   x30,F
38E8:  BRA    3834
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
38EA:  MOVF   x29,F
38EC:  BNZ   3902
38EE:  MOVLW  52
38F0:  MOVWF  x35
38F2:  MOVFF  82D,837
38F6:  MOVFF  82C,836
38FA:  MOVLB  0
38FC:  RCALL  350E
....................          else del_buf(numbyteofbuffer2,datin); 
38FE:  BRA    3912
3900:  MOVLB  8
3902:  MOVLW  2C
3904:  MOVWF  x35
3906:  MOVFF  82D,837
390A:  MOVFF  82C,836
390E:  MOVLB  0
3910:  RCALL  350E
3912:  MOVLB  8
.................... } 
3914:  MOVLB  0
3916:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
17FA:  MOVLW  96
17FC:  MOVWF  FF6
17FE:  MOVLW  05
1800:  MOVWF  FF7
1802:  RCALL  16F2
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1804:  MOVLB  8
1806:  CLRF   x2D
1808:  CLRF   x2C
180A:  MOVF   x2D,W
180C:  SUBLW  03
180E:  BNC   183E
1810:  BNZ   1818
1812:  MOVF   x2C,W
1814:  SUBLW  51
1816:  BNC   183E
1818:  MOVLW  41
181A:  ADDWF  x2C,W
181C:  MOVWF  FE9
181E:  MOVLW  02
1820:  ADDWFC x2D,W
1822:  MOVWF  FEA
1824:  MOVFF  FEF,82E
1828:  MOVFF  82E,82F
182C:  MOVLW  18
182E:  MOVWF  x30
1830:  MOVLB  0
1832:  RCALL  173E
1834:  MOVLB  8
1836:  INCF   x2C,F
1838:  BTFSC  FD8.2
183A:  INCF   x2D,F
183C:  BRA    180A
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
183E:  MOVLW  AC
1840:  MOVWF  FF6
1842:  MOVLW  05
1844:  MOVWF  FF7
1846:  MOVLB  0
1848:  RCALL  16F2
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
184A:  MOVLB  8
184C:  CLRF   x2D
184E:  CLRF   x2C
1850:  MOVF   x2D,W
1852:  SUBLW  01
1854:  BNC   1884
1856:  BNZ   185E
1858:  MOVF   x2C,W
185A:  SUBLW  2B
185C:  BNC   1884
185E:  MOVLW  93
1860:  ADDWF  x2C,W
1862:  MOVWF  FE9
1864:  MOVLW  05
1866:  ADDWFC x2D,W
1868:  MOVWF  FEA
186A:  MOVFF  FEF,82E
186E:  MOVFF  82E,82F
1872:  MOVLW  18
1874:  MOVWF  x30
1876:  MOVLB  0
1878:  RCALL  173E
187A:  MOVLB  8
187C:  INCF   x2C,F
187E:  BTFSC  FD8.2
1880:  INCF   x2D,F
1882:  BRA    1850
.................... } 
1884:  MOVLB  0
1886:  GOTO   1B14 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3AA4:  MOVLW  01
3AA6:  MOVLB  6
3AA8:  MOVWF  xD3
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3AAA:  MOVLB  0
3AAC:  RCALL  3494
3AAE:  MOVFF  02,82A
3AB2:  MOVFF  01,829
3AB6:  MOVFF  02,82C
3ABA:  MOVFF  01,82B
3ABE:  MOVLB  8
3AC0:  CLRF   x2E
3AC2:  MOVLW  7C
3AC4:  MOVWF  x2D
3AC6:  MOVLB  0
3AC8:  RCALL  34EC
3ACA:  MOVFF  01,829
3ACE:  MOVLW  96
3AD0:  MOVLB  8
3AD2:  ADDWF  01,W
3AD4:  MOVWF  01
3AD6:  MOVLW  00
3AD8:  ADDWFC 02,W
3ADA:  MOVFF  01,20
3ADE:  MOVWF  21
3AE0:  CLRF   22
3AE2:  CLRF   23
....................    if(datinbuf==0)  
3AE4:  MOVLB  6
3AE6:  MOVF   xD0,F
3AE8:  BNZ   3B0A
....................    { 
....................       countbit_T1=0; 
3AEA:  CLRF   xC5
3AEC:  CLRF   xC4
....................       countbit_T2=0; 
3AEE:  CLRF   xC7
3AF0:  CLRF   xC6
....................       bug_countbit_T1=0; 
3AF2:  CLRF   xC9
3AF4:  CLRF   xC8
....................       bug_countbit_T2=0; 
3AF6:  CLRF   xCB
3AF8:  CLRF   xCA
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3AFA:  MOVF   xD4,F
3AFC:  BNZ   3B06
3AFE:  MOVLB  0
3B00:  SETF   xFC
3B02:  SETF   xFB
3B04:  MOVLB  6
....................       saving_flag=0; 
3B06:  CLRF   xD3
....................       return; 
3B08:  BRA    3E7C
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3B0A:  MOVLW  C2
3B0C:  MOVWF  FF6
3B0E:  MOVLW  05
3B10:  MOVWF  FF7
3B12:  MOVLB  0
3B14:  CALL   16F2
....................    //key_count=0; 
....................    enable_getpin=1; 
3B18:  MOVLW  01
3B1A:  MOVLB  1
3B1C:  MOVWF  x40
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3B1E:  MOVFF  6C5,828
3B22:  MOVFF  6C4,827
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3B26:  MOVLB  8
3B28:  CLRF   x29
3B2A:  MOVFF  828,82B
3B2E:  MOVFF  827,82A
3B32:  MOVLW  02
3B34:  MOVWF  x2D
3B36:  MOVLW  41
3B38:  MOVWF  x2C
3B3A:  MOVLW  01
3B3C:  MOVWF  x2F
3B3E:  MOVLW  CA
3B40:  MOVWF  x2E
3B42:  MOVLB  0
3B44:  RCALL  3530
....................    countbit_T1=0; 
3B46:  MOVLB  6
3B48:  CLRF   xC5
3B4A:  CLRF   xC4
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3B4C:  MOVFF  6C7,828
3B50:  MOVFF  6C6,827
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3B54:  MOVLW  01
3B56:  MOVLB  8
3B58:  MOVWF  x29
3B5A:  MOVFF  828,82B
3B5E:  MOVFF  827,82A
3B62:  MOVLW  05
3B64:  MOVWF  x2D
3B66:  MOVLW  93
3B68:  MOVWF  x2C
3B6A:  MOVLW  02
3B6C:  MOVWF  x2F
3B6E:  MOVLW  19
3B70:  MOVWF  x2E
3B72:  MOVLB  0
3B74:  RCALL  3530
....................    countbit_T2=0; 
3B76:  MOVLB  6
3B78:  CLRF   xC7
3B7A:  CLRF   xC6
....................    saving_flag=0; 
3B7C:  CLRF   xD3
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3B7E:  MOVLW  20
3B80:  MOVLB  1
3B82:  ADDWF  xCA,W
3B84:  MOVLB  8
3B86:  MOVWF  x26
....................    if((ptr_card<EEPROM_SIZE_stofkey)&&(temp=='%')) 
3B88:  MOVF   23,F
3B8A:  BTFSS  FD8.2
3B8C:  BRA    3E7A
3B8E:  MOVF   22,W
3B90:  SUBLW  01
3B92:  BTFSS  FD8.0
3B94:  BRA    3E7A
3B96:  BNZ   3BAA
3B98:  MOVF   21,W
3B9A:  SUBLW  C3
3B9C:  BTFSS  FD8.0
3B9E:  BRA    3E7A
3BA0:  BNZ   3BAA
3BA2:  MOVF   20,W
3BA4:  SUBLW  0D
3BA6:  BTFSS  FD8.0
3BA8:  BRA    3E7A
3BAA:  MOVF   x26,W
3BAC:  SUBLW  25
3BAE:  BTFSS  FD8.2
3BB0:  BRA    3E7A
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3BB2:  MOVFF  23,03
3BB6:  MOVFF  22,02
3BBA:  MOVFF  21,01
3BBE:  MOVFF  20,00
3BC2:  MOVLW  01
3BC4:  ADDWF  20,F
3BC6:  BTFSC  FD8.0
3BC8:  INCF   21,F
3BCA:  BTFSC  FD8.2
3BCC:  INCF   22,F
3BCE:  BTFSC  FD8.2
3BD0:  INCF   23,F
3BD2:  MOVFF  01,82A
3BD6:  MOVFF  00,829
3BDA:  CLRF   x3A
3BDC:  CLRF   x39
3BDE:  MOVFF  01,838
3BE2:  MOVFF  00,837
3BE6:  MOVFF  1C6,83B
3BEA:  MOVLB  0
3BEC:  RCALL  3918
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3BEE:  MOVFF  23,03
3BF2:  MOVFF  22,02
3BF6:  MOVFF  21,01
3BFA:  MOVFF  20,00
3BFE:  MOVLW  01
3C00:  ADDWF  20,F
3C02:  BTFSC  FD8.0
3C04:  INCF   21,F
3C06:  BTFSC  FD8.2
3C08:  INCF   22,F
3C0A:  BTFSC  FD8.2
3C0C:  INCF   23,F
3C0E:  MOVFF  01,82A
3C12:  MOVFF  00,829
3C16:  MOVLB  8
3C18:  CLRF   x3A
3C1A:  CLRF   x39
3C1C:  MOVFF  01,838
3C20:  MOVFF  00,837
3C24:  MOVFF  1C5,83B
3C28:  MOVLB  0
3C2A:  RCALL  3918
....................          write_ext_eeprom((long int)ptr_card++,h); 
3C2C:  MOVFF  23,03
3C30:  MOVFF  22,02
3C34:  MOVFF  21,01
3C38:  MOVFF  20,00
3C3C:  MOVLW  01
3C3E:  ADDWF  20,F
3C40:  BTFSC  FD8.0
3C42:  INCF   21,F
3C44:  BTFSC  FD8.2
3C46:  INCF   22,F
3C48:  BTFSC  FD8.2
3C4A:  INCF   23,F
3C4C:  MOVFF  01,82A
3C50:  MOVFF  00,829
3C54:  MOVLB  8
3C56:  CLRF   x3A
3C58:  CLRF   x39
3C5A:  MOVFF  01,838
3C5E:  MOVFF  00,837
3C62:  MOVFF  1C7,83B
3C66:  MOVLB  0
3C68:  RCALL  3918
....................          write_ext_eeprom((long int)ptr_card++,min); 
3C6A:  MOVFF  23,03
3C6E:  MOVFF  22,02
3C72:  MOVFF  21,01
3C76:  MOVFF  20,00
3C7A:  MOVLW  01
3C7C:  ADDWF  20,F
3C7E:  BTFSC  FD8.0
3C80:  INCF   21,F
3C82:  BTFSC  FD8.2
3C84:  INCF   22,F
3C86:  BTFSC  FD8.2
3C88:  INCF   23,F
3C8A:  MOVFF  01,82A
3C8E:  MOVFF  00,829
3C92:  MOVLB  8
3C94:  CLRF   x3A
3C96:  CLRF   x39
3C98:  MOVFF  01,838
3C9C:  MOVFF  00,837
3CA0:  MOVFF  1C8,83B
3CA4:  MOVLB  0
3CA6:  RCALL  3918
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3CA8:  MOVFF  23,03
3CAC:  MOVFF  22,02
3CB0:  MOVFF  21,01
3CB4:  MOVFF  20,00
3CB8:  MOVLW  01
3CBA:  ADDWF  20,F
3CBC:  BTFSC  FD8.0
3CBE:  INCF   21,F
3CC0:  BTFSC  FD8.2
3CC2:  INCF   22,F
3CC4:  BTFSC  FD8.2
3CC6:  INCF   23,F
3CC8:  MOVFF  01,82A
3CCC:  MOVFF  00,829
3CD0:  MOVLB  8
3CD2:  CLRF   x3A
3CD4:  CLRF   x39
3CD6:  MOVFF  01,838
3CDA:  MOVFF  00,837
3CDE:  MOVFF  1C9,83B
3CE2:  MOVLB  0
3CE4:  RCALL  3918
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3CE6:  MOVLB  6
3CE8:  CLRF   xCF
3CEA:  CLRF   xCE
3CEC:  MOVF   xCF,F
3CEE:  BNZ   3D50
3CF0:  MOVF   xCE,W
3CF2:  SUBLW  4E
3CF4:  BNC   3D50
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3CF6:  MOVFF  23,03
3CFA:  MOVFF  22,02
3CFE:  MOVFF  21,01
3D02:  MOVFF  20,00
3D06:  MOVLW  01
3D08:  ADDWF  20,F
3D0A:  BTFSC  FD8.0
3D0C:  INCF   21,F
3D0E:  BTFSC  FD8.2
3D10:  INCF   22,F
3D12:  BTFSC  FD8.2
3D14:  INCF   23,F
3D16:  MOVFF  01,82A
3D1A:  MOVFF  00,829
3D1E:  MOVLW  CA
3D20:  ADDWF  xCE,W
3D22:  MOVWF  FE9
3D24:  MOVLW  01
3D26:  ADDWFC xCF,W
3D28:  MOVWF  FEA
3D2A:  MOVF   FEF,W
3D2C:  ANDLW  3F
3D2E:  ADDLW  20
3D30:  MOVLB  8
3D32:  MOVWF  x2B
3D34:  CLRF   x3A
3D36:  CLRF   x39
3D38:  MOVFF  01,838
3D3C:  MOVFF  00,837
3D40:  MOVWF  x3B
3D42:  MOVLB  0
3D44:  RCALL  3918
....................              
....................          } 
3D46:  MOVLB  6
3D48:  INCF   xCE,F
3D4A:  BTFSC  FD8.2
3D4C:  INCF   xCF,F
3D4E:  BRA    3CEC
....................          del_buf(numbyteoftrack1,Track1); 
3D50:  MOVLW  4F
3D52:  MOVLB  8
3D54:  MOVWF  x35
3D56:  MOVLW  01
3D58:  MOVWF  x37
3D5A:  MOVLW  CA
3D5C:  MOVWF  x36
3D5E:  MOVLB  0
3D60:  CALL   350E
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3D64:  MOVLB  6
3D66:  CLRF   xCF
3D68:  CLRF   xCE
3D6A:  MOVF   xCF,F
3D6C:  BNZ   3DCE
3D6E:  MOVF   xCE,W
3D70:  SUBLW  27
3D72:  BNC   3DCE
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3D74:  MOVFF  23,03
3D78:  MOVFF  22,02
3D7C:  MOVFF  21,01
3D80:  MOVFF  20,00
3D84:  MOVLW  01
3D86:  ADDWF  20,F
3D88:  BTFSC  FD8.0
3D8A:  INCF   21,F
3D8C:  BTFSC  FD8.2
3D8E:  INCF   22,F
3D90:  BTFSC  FD8.2
3D92:  INCF   23,F
3D94:  MOVFF  01,82A
3D98:  MOVFF  00,829
3D9C:  MOVLW  19
3D9E:  ADDWF  xCE,W
3DA0:  MOVWF  FE9
3DA2:  MOVLW  02
3DA4:  ADDWFC xCF,W
3DA6:  MOVWF  FEA
3DA8:  MOVF   FEF,W
3DAA:  ANDLW  0F
3DAC:  ADDLW  30
3DAE:  MOVLB  8
3DB0:  MOVWF  x2B
3DB2:  CLRF   x3A
3DB4:  CLRF   x39
3DB6:  MOVFF  01,838
3DBA:  MOVFF  00,837
3DBE:  MOVWF  x3B
3DC0:  MOVLB  0
3DC2:  RCALL  3918
....................          }  
3DC4:  MOVLB  6
3DC6:  INCF   xCE,F
3DC8:  BTFSC  FD8.2
3DCA:  INCF   xCF,F
3DCC:  BRA    3D6A
....................          del_buf(numbyteoftrack2,Track2); 
3DCE:  MOVLW  28
3DD0:  MOVLB  8
3DD2:  MOVWF  x35
3DD4:  MOVLW  02
3DD6:  MOVWF  x37
3DD8:  MOVLW  19
3DDA:  MOVWF  x36
3DDC:  MOVLB  0
3DDE:  CALL   350E
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
3DE2:  MOVLW  0D
3DE4:  MOVLB  8
3DE6:  MOVWF  x4F
3DE8:  MOVLB  0
3DEA:  CALL   15C8
3DEE:  MOVLW  0A
3DF0:  MOVLB  8
3DF2:  MOVWF  x4F
3DF4:  MOVLB  0
3DF6:  CALL   15C8
....................       fprintf(COM2,"Done"); 
3DFA:  MOVLW  D8
3DFC:  MOVWF  FF6
3DFE:  MOVLW  05
3E00:  MOVWF  FF7
3E02:  CALL   16F2
....................          
....................       fprintf(COM2,"\r\n"); 
3E06:  MOVLW  0D
3E08:  MOVLB  8
3E0A:  MOVWF  x4F
3E0C:  MOVLB  0
3E0E:  CALL   15C8
3E12:  MOVLW  0A
3E14:  MOVLB  8
3E16:  MOVWF  x4F
3E18:  MOVLB  0
3E1A:  CALL   15C8
....................       fprintf(COM2,"Waiting for PIN number"); 
3E1E:  MOVLW  DE
3E20:  MOVWF  FF6
3E22:  MOVLW  05
3E24:  MOVWF  FF7
3E26:  CALL   16F2
....................       fprintf(COM2,"\r\n"); 
3E2A:  MOVLW  0D
3E2C:  MOVLB  8
3E2E:  MOVWF  x4F
3E30:  MOVLB  0
3E32:  CALL   15C8
3E36:  MOVLW  0A
3E38:  MOVLB  8
3E3A:  MOVWF  x4F
3E3C:  MOVLB  0
3E3E:  CALL   15C8
....................       charac_timeout=0; 
3E42:  CLRF   xFC
3E44:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3E46:  MOVFF  23,82C
3E4A:  MOVFF  22,82B
3E4E:  MOVFF  21,82A
3E52:  MOVFF  20,829
3E56:  MOVLW  19
3E58:  MOVLB  8
3E5A:  MOVWF  x2D
3E5C:  MOVLB  0
3E5E:  RCALL  3A16
....................       datinbuf=0; 
3E60:  MOVLB  6
3E62:  CLRF   xD0
....................       saving_flag=0; 
3E64:  CLRF   xD3
....................       data_avai=1; 
3E66:  MOVLW  01
3E68:  MOVWF  xD4
....................       enable_getpin=1; 
3E6A:  MOVLB  1
3E6C:  MOVWF  x40
....................       charac_timeout=0; 
3E6E:  MOVLB  0
3E70:  CLRF   xFC
3E72:  CLRF   xFB
....................       key_count_ms=0; 
3E74:  MOVLB  1
3E76:  CLRF   x42
3E78:  MOVLB  8
3E7A:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3E7C:  MOVLB  0
3E7E:  GOTO   41CE (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
18B2:  MOVLW  01
18B4:  MOVLB  8
18B6:  MOVWF  x23
18B8:  MOVWF  x24
18BA:  MOVWF  x25
18BC:  MOVWF  x26
18BE:  CLRF   x27
18C0:  MOVWF  x28
18C2:  MOVWF  x29
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
18C4:  MOVLB  6
18C6:  CLRF   xCD
18C8:  CLRF   xCC
....................    mcr_timeout=0; 
18CA:  CLRF   xC2
18CC:  CLRF   xC1
18CE:  CLRF   xC0
18D0:  CLRF   xBF
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
18D2:  MOVF   xCD,W
18D4:  SUBLW  FD
18D6:  BNC   18F4
18D8:  BNZ   18E0
18DA:  MOVF   xCC,W
18DC:  SUBLW  E7
18DE:  BNC   18F4
18E0:  BSF    F93.1
18E2:  BTFSS  F81.1
18E4:  BRA    18F4
18E6:  BSF    F94.5
18E8:  BTFSS  F82.5
18EA:  BRA    18F4
....................       card_timeout++; 
18EC:  INCF   xCC,F
18EE:  BTFSC  FD8.2
18F0:  INCF   xCD,F
....................    } 
18F2:  BRA    18D2
....................    card_timeout=0; 
18F4:  CLRF   xCD
18F6:  CLRF   xCC
....................    buffertrack1[bug_countbit_T1++]=0; 
18F8:  MOVFF  6C9,03
18FC:  MOVF   xC8,W
18FE:  INCF   xC8,F
1900:  BTFSC  FD8.2
1902:  INCF   xC9,F
1904:  MOVLB  8
1906:  MOVWF  x2C
1908:  MOVLW  41
190A:  ADDWF  x2C,W
190C:  MOVWF  FE9
190E:  MOVLW  02
1910:  ADDWFC 03,W
1912:  MOVWF  FEA
1914:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1916:  MOVLB  6
1918:  MOVFF  6C9,03
191C:  MOVF   xC8,W
191E:  INCF   xC8,F
1920:  BTFSC  FD8.2
1922:  INCF   xC9,F
1924:  MOVLB  8
1926:  MOVWF  x2C
1928:  MOVLW  41
192A:  ADDWF  x2C,W
192C:  MOVWF  FE9
192E:  MOVLW  02
1930:  ADDWFC 03,W
1932:  MOVWF  FEA
1934:  MOVLW  01
1936:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1938:  MOVLB  6
193A:  MOVFF  6CB,03
193E:  MOVF   xCA,W
1940:  INCF   xCA,F
1942:  BTFSC  FD8.2
1944:  INCF   xCB,F
1946:  MOVLB  8
1948:  MOVWF  x2C
194A:  MOVLW  93
194C:  ADDWF  x2C,W
194E:  MOVWF  FE9
1950:  MOVLW  05
1952:  ADDWFC 03,W
1954:  MOVWF  FEA
1956:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1958:  MOVLB  6
195A:  MOVFF  6CB,03
195E:  MOVF   xCA,W
1960:  INCF   xCA,F
1962:  BTFSC  FD8.2
1964:  INCF   xCB,F
1966:  MOVLB  8
1968:  MOVWF  x2C
196A:  MOVLW  93
196C:  ADDWF  x2C,W
196E:  MOVWF  FE9
1970:  MOVLW  05
1972:  ADDWFC 03,W
1974:  MOVWF  FEA
1976:  MOVLW  01
1978:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
197A:  MOVLB  6
197C:  MOVF   xC9,W
197E:  SUBLW  03
1980:  BTFSS  FD8.0
1982:  BRA    1A62
1984:  BNZ   198E
1986:  MOVF   xC8,W
1988:  SUBLW  51
198A:  BTFSS  FD8.0
198C:  BRA    1A62
198E:  MOVF   xCB,W
1990:  SUBLW  01
1992:  BTFSS  FD8.0
1994:  BRA    1A62
1996:  BNZ   199E
1998:  MOVF   xCA,W
199A:  SUBLW  2B
199C:  BNC   1A62
199E:  MOVF   xCD,W
19A0:  SUBLW  FF
19A2:  BNC   1A62
19A4:  BNZ   19AC
19A6:  MOVF   xCC,W
19A8:  SUBLW  DB
19AA:  BNC   1A62
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
19AC:  MOVF   xD6,F
19AE:  BZ    19B8
....................          { 
....................             bug_countbit_T1=0; 
19B0:  CLRF   xC9
19B2:  CLRF   xC8
....................             bug_countbit_T2=0; 
19B4:  CLRF   xCB
19B6:  CLRF   xCA
....................          } 
....................          card_timeout++; 
19B8:  INCF   xCC,F
19BA:  BTFSC  FD8.2
19BC:  INCF   xCD,F
....................          mcr_timeout=0; 
19BE:  CLRF   xC2
19C0:  CLRF   xC1
19C2:  CLRF   xC0
19C4:  CLRF   xBF
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
19C6:  BSF    F93.2
19C8:  MOVLB  8
19CA:  CLRF   x23
19CC:  BTFSC  F81.2
19CE:  INCF   x23,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
19D0:  MOVF   x23,F
19D2:  BNZ   1A10
19D4:  DECFSZ x24,W
19D6:  BRA    1A10
....................          { 
....................             ST1_old = 0; 
19D8:  CLRF   x24
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
19DA:  MOVLW  41
19DC:  MOVLB  6
19DE:  ADDWF  xC8,W
19E0:  MOVWF  FE9
19E2:  MOVLW  02
19E4:  ADDWFC xC9,W
19E6:  MOVWF  FEA
19E8:  BSF    F93.1
19EA:  MOVLW  00
19EC:  BTFSS  F81.1
19EE:  MOVLW  01
19F0:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
19F2:  MOVLW  93
19F4:  ADDWF  xCA,W
19F6:  MOVWF  FE9
19F8:  MOVLW  05
19FA:  ADDWFC xCB,W
19FC:  MOVWF  FEA
19FE:  MOVFF  827,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1A02:  INCF   xC8,F
1A04:  BTFSC  FD8.2
1A06:  INCF   xC9,F
....................             card_timeout=0; 
1A08:  CLRF   xCD
1A0A:  CLRF   xCC
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A0C:  BRA    1A1A
1A0E:  MOVLB  8
1A10:  DECFSZ x23,W
1A12:  BRA    1A18
1A14:  MOVLW  01
1A16:  MOVWF  x24
1A18:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A1A:  BSF    F93.3
1A1C:  MOVLB  8
1A1E:  CLRF   x25
1A20:  BTFSC  F81.3
1A22:  INCF   x25,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A24:  MOVF   x25,F
1A26:  BNZ   1A46
1A28:  DECFSZ x26,W
1A2A:  BRA    1A46
....................          { 
....................             ST2_old = 0; 
1A2C:  CLRF   x26
....................             Bit_t2 = !input(MCR_DATA2); 
1A2E:  BSF    F94.5
1A30:  CLRF   x27
1A32:  BTFSS  F82.5
1A34:  INCF   x27,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A36:  MOVLB  6
1A38:  INCF   xCA,F
1A3A:  BTFSC  FD8.2
1A3C:  INCF   xCB,F
....................             card_timeout=0; 
1A3E:  CLRF   xCD
1A40:  CLRF   xCC
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A42:  BRA    1A50
1A44:  MOVLB  8
1A46:  DECFSZ x25,W
1A48:  BRA    1A4E
1A4A:  MOVLW  01
1A4C:  MOVWF  x26
1A4E:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1A50:  BSF    F93.0
1A52:  BTFSS  F81.0
1A54:  BRA    1A60
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1A56:  CLRF   xD6
....................             card_timeout=65500; 
1A58:  SETF   xCD
1A5A:  MOVLW  DC
1A5C:  MOVWF  xCC
....................             break;            
1A5E:  BRA    1A62
....................          } 
....................       } 
1A60:  BRA    197C
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1A62:  CLRF   xCD
1A64:  CLRF   xCC
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1A66:  MOVLB  8
1A68:  CLRF   x35
1A6A:  MOVFF  6C9,837
1A6E:  MOVFF  6C8,836
1A72:  MOVLW  02
1A74:  MOVWF  x39
1A76:  MOVLW  41
1A78:  MOVWF  x38
1A7A:  MOVLB  0
1A7C:  CALL   09C6
1A80:  MOVFF  01,828
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1A84:  MOVLW  01
1A86:  MOVLB  8
1A88:  MOVWF  x35
1A8A:  MOVFF  6CB,837
1A8E:  MOVFF  6CA,836
1A92:  MOVLW  05
1A94:  MOVWF  x39
1A96:  MOVLW  93
1A98:  MOVWF  x38
1A9A:  MOVLB  0
1A9C:  CALL   09C6
1AA0:  MOVFF  01,829
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1AA4:  MOVLB  6
1AA6:  DECFSZ xD1,W
1AA8:  BRA    1B3E
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1AAA:  MOVLW  F6
1AAC:  MOVWF  FF6
1AAE:  MOVLW  05
1AB0:  MOVWF  FF7
1AB2:  MOVLW  0E
1AB4:  MOVLB  8
1AB6:  MOVWF  x43
1AB8:  MOVLB  0
1ABA:  RCALL  160E
1ABC:  MOVLW  10
1ABE:  MOVWF  FE9
1AC0:  MOVFF  6C9,82D
1AC4:  MOVFF  6C8,82C
1AC8:  RCALL  1636
1ACA:  MOVLW  0D
1ACC:  MOVLB  8
1ACE:  MOVWF  x4F
1AD0:  MOVLB  0
1AD2:  RCALL  15C8
1AD4:  MOVLW  0A
1AD6:  MOVLB  8
1AD8:  MOVWF  x4F
1ADA:  MOVLB  0
1ADC:  RCALL  15C8
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1ADE:  MOVLW  0A
1AE0:  MOVWF  FF6
1AE2:  MOVLW  06
1AE4:  MOVWF  FF7
1AE6:  MOVLW  0E
1AE8:  MOVLB  8
1AEA:  MOVWF  x43
1AEC:  MOVLB  0
1AEE:  RCALL  160E
1AF0:  MOVLW  10
1AF2:  MOVWF  FE9
1AF4:  MOVFF  6CB,82D
1AF8:  MOVFF  6CA,82C
1AFC:  RCALL  1636
1AFE:  MOVLW  0D
1B00:  MOVLB  8
1B02:  MOVWF  x4F
1B04:  MOVLB  0
1B06:  RCALL  15C8
1B08:  MOVLW  0A
1B0A:  MOVLB  8
1B0C:  MOVWF  x4F
1B0E:  MOVLB  0
1B10:  RCALL  15C8
....................          debug_reader();       
1B12:  BRA    17FA
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B14:  MOVLB  8
1B16:  MOVF   x28,F
1B18:  BNZ   1B28
1B1A:  MOVLW  1E
1B1C:  MOVWF  FF6
1B1E:  MOVLW  06
1B20:  MOVWF  FF7
1B22:  MOVLB  0
1B24:  RCALL  16F2
1B26:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B28:  MOVF   x29,F
1B2A:  BNZ   1B3A
1B2C:  MOVLW  34
1B2E:  MOVWF  FF6
1B30:  MOVLW  06
1B32:  MOVWF  FF7
1B34:  MOVLB  0
1B36:  RCALL  16F2
1B38:  MOVLB  8
....................       } 
....................          else 
1B3A:  BRA    1B4A
1B3C:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B3E:  MOVLW  0F
1B40:  MOVLB  8
1B42:  MOVWF  x2C
1B44:  MOVLB  0
1B46:  RCALL  188A
1B48:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1B4A:  MOVF   x28,F
1B4C:  BZ    1B52
1B4E:  MOVF   x29,F
1B50:  BNZ   1B72
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1B52:  MOVLB  6
1B54:  CLRF   xCB
1B56:  CLRF   xCA
....................          bug_countbit_T1=0; 
1B58:  CLRF   xC9
1B5A:  CLRF   xC8
....................          reading_fg=0; 
1B5C:  CLRF   xD5
....................          count_reading_error++; 
1B5E:  INCF   xD6,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1B60:  CLRF   xC2
1B62:  CLRF   xC1
1B64:  CLRF   xC0
1B66:  CLRF   xBF
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1B68:  MOVLW  00
1B6A:  MOVWF  01
1B6C:  BRA    1BAA
....................       } 
....................          else  
1B6E:  BRA    1BA6
1B70:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1B72:  MOVLW  01
1B74:  MOVLB  6
1B76:  MOVWF  xD0
....................             reading_fg=1; 
1B78:  MOVWF  xD5
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1B7A:  MOVFF  6CB,6C7
1B7E:  MOVFF  6CA,6C6
....................             countbit_T1=bug_countbit_T1; 
1B82:  MOVFF  6C9,6C5
1B86:  MOVFF  6C8,6C4
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1B8A:  CLRF   xC9
1B8C:  CLRF   xC8
....................             bug_countbit_T2=0;  
1B8E:  CLRF   xCB
1B90:  CLRF   xCA
....................             mcr_timeout=0; 
1B92:  CLRF   xC2
1B94:  CLRF   xC1
1B96:  CLRF   xC0
1B98:  CLRF   xBF
....................             charac_timeout=0; 
1B9A:  MOVLB  0
1B9C:  CLRF   xFC
1B9E:  CLRF   xFB
....................             return 1; 
1BA0:  MOVWF  01
1BA2:  MOVLB  6
1BA4:  BRA    1BAA
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1BA6:  MOVLW  00
1BA8:  MOVWF  01
.................... } 
1BAA:  MOVLB  0
1BAC:  GOTO   1BD2 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       delay_us(500); 
1BB0:  MOVLW  02
1BB2:  MOVLB  8
1BB4:  MOVWF  x23
1BB6:  MOVLW  FA
1BB8:  MOVWF  x24
1BBA:  MOVLB  0
1BBC:  GOTO   064A
1BC0:  MOVLB  8
1BC2:  DECFSZ x23,F
1BC4:  BRA    1BB6
....................       if(saving_flag==1) return;      
1BC6:  MOVLB  6
1BC8:  DECFSZ xD3,W
1BCA:  BRA    1BCE
1BCC:  BRA    1BE4
....................       cardread_st=mcr_read(); 
1BCE:  MOVLB  0
1BD0:  BRA    18B2
1BD2:  MOVFF  01,6D2
....................       mcr_timeout=0; 
1BD6:  MOVLB  6
1BD8:  CLRF   xC2
1BDA:  CLRF   xC1
1BDC:  CLRF   xC0
1BDE:  CLRF   xBF
....................       card_timeout=0;      
1BE0:  CLRF   xCD
1BE2:  CLRF   xCC
.................... } 
.................... //==================================== 
.................... #if 0 
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... #endif 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
1BE4:  BCF    FF0.0
1BE6:  MOVLB  0
1BE8:  GOTO   006C
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
5CF6:  CLRF   19
5CF8:  BTFSC  FF2.7
5CFA:  BSF    19.7
5CFC:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
5CFE:  MOVLB  8
5D00:  CLRF   x3A
5D02:  CLRF   x39
5D04:  CLRF   x38
5D06:  MOVLW  3C
5D08:  MOVWF  x37
5D0A:  MOVLW  03
5D0C:  MOVWF  x3B
5D0E:  MOVLB  0
5D10:  CALL   3918
5D14:  BTFSC  19.7
5D16:  BSF    FF2.7
5D18:  CLRF   19
5D1A:  BTFSC  FF2.7
5D1C:  BSF    19.7
5D1E:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
5D20:  MOVLB  8
5D22:  CLRF   x3A
5D24:  CLRF   x39
5D26:  CLRF   x38
5D28:  MOVLW  3A
5D2A:  MOVWF  x37
5D2C:  MOVLW  01
5D2E:  MOVWF  x3B
5D30:  MOVLB  0
5D32:  CALL   3918
5D36:  BTFSC  19.7
5D38:  BSF    FF2.7
5D3A:  CLRF   19
5D3C:  BTFSC  FF2.7
5D3E:  BSF    19.7
5D40:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV);  
5D42:  MOVLB  8
5D44:  CLRF   x32
5D46:  CLRF   x31
5D48:  CLRF   x30
5D4A:  MOVLW  3A
5D4C:  MOVWF  x2F
5D4E:  MOVLB  0
5D50:  CALL   33C8
5D54:  BTFSC  19.7
5D56:  BSF    FF2.7
5D58:  MOVFF  01,6DD
.................... } 
5D5C:  GOTO   6508 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
5E74:  MOVLW  06
5E76:  MOVWF  FEA
5E78:  MOVLW  E2
5E7A:  MOVWF  FE9
5E7C:  CALL   475E
5E80:  CLRF   19
5E82:  BTFSC  FF2.7
5E84:  BSF    19.7
5E86:  BCF    FF2.7
5E88:  MOVLW  3E
5E8A:  MOVLB  8
5E8C:  MOVWF  x4F
5E8E:  MOVLB  0
5E90:  CALL   15C8
5E94:  BTFSC  19.7
5E96:  BSF    FF2.7
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
5E98:  MOVLW  01
5E9A:  MOVLB  7
5E9C:  MOVWF  xEE
5E9E:  MOVLW  14
5EA0:  MOVWF  xEF
5EA2:  MOVLW  01
5EA4:  MOVWF  xF1
5EA6:  MOVLW  5D
5EA8:  MOVWF  xF0
5EAA:  MOVLB  0
5EAC:  RCALL  576A
5EAE:  CLRF   19
5EB0:  BTFSC  FF2.7
5EB2:  BSF    19.7
5EB4:  BCF    FF2.7
....................       printf("\n\r"); 
5EB6:  MOVLW  0A
5EB8:  MOVLB  8
5EBA:  MOVWF  x4F
5EBC:  MOVLB  0
5EBE:  CALL   15C8
5EC2:  BTFSC  19.7
5EC4:  BSF    FF2.7
5EC6:  CLRF   19
5EC8:  BTFSC  FF2.7
5ECA:  BSF    19.7
5ECC:  BCF    FF2.7
5ECE:  MOVLW  0D
5ED0:  MOVLB  8
5ED2:  MOVWF  x4F
5ED4:  MOVLB  0
5ED6:  CALL   15C8
5EDA:  BTFSC  19.7
5EDC:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
5EDE:  CLRF   FEA
5EE0:  MOVLW  41
5EE2:  MOVWF  FE9
5EE4:  MOVLW  00
5EE6:  CALL   0356
5EEA:  TBLRD*-
5EEC:  TBLRD*+
5EEE:  MOVF   FF5,W
5EF0:  MOVWF  FEE
5EF2:  IORLW  00
5EF4:  BNZ   5EEC
....................       index=0; 
5EF6:  MOVLB  7
5EF8:  CLRF   xB8
....................       ee_dat=0; 
5EFA:  MOVLB  6
5EFC:  CLRF   xD8
....................       count_card=1; 
5EFE:  CLRF   xDA
5F00:  MOVLW  01
5F02:  MOVWF  xD9
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
5F04:  MOVLB  7
5F06:  MOVWF  xEF
5F08:  MOVLW  5D
5F0A:  MOVWF  xEE
5F0C:  CLRF   xF1
5F0E:  MOVLW  41
5F10:  MOVWF  xF0
5F12:  MOVLB  0
5F14:  RCALL  58A2
5F16:  MOVF   01,F
5F18:  BTFSS  FD8.2
5F1A:  BRA    6336
....................       { 
....................          unsigned long adr=0; 
5F1C:  MOVLB  7
5F1E:  CLRF   xED
5F20:  CLRF   xEC
....................          //unsigned int count=0; 
....................          rec[0]=0; 
5F22:  MOVLB  0
5F24:  CLRF   x7D
5F26:  CLRF   19
5F28:  BTFSC  FF2.7
5F2A:  BSF    19.7
5F2C:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
5F2E:  CALL   3494
5F32:  BTFSC  19.7
5F34:  BSF    FF2.7
5F36:  MOVFF  02,6DC
5F3A:  MOVFF  01,6DB
5F3E:  CLRF   19
5F40:  BTFSC  FF2.7
5F42:  BSF    19.7
5F44:  BCF    FF2.7
....................          adr=count_card*numdata; 
5F46:  MOVFF  6DA,82C
5F4A:  MOVFF  6D9,82B
5F4E:  MOVLB  8
5F50:  CLRF   x2E
5F52:  MOVLW  7C
5F54:  MOVWF  x2D
5F56:  MOVLB  0
5F58:  CALL   34EC
5F5C:  BTFSC  19.7
5F5E:  BSF    FF2.7
5F60:  MOVFF  02,7ED
5F64:  MOVFF  01,7EC
....................          addr_key=EEPROM_KEY_ST; 
5F68:  MOVLB  6
5F6A:  CLRF   xE1
5F6C:  MOVLW  01
5F6E:  MOVWF  xE0
5F70:  MOVLW  C3
5F72:  MOVWF  xDF
5F74:  MOVLW  0F
5F76:  MOVWF  xDE
....................          while(count_card<=count_card_tg) 
....................          { 
5F78:  MOVF   xDA,W
5F7A:  SUBWF  xDC,W
5F7C:  BTFSS  FD8.0
5F7E:  BRA    6334
5F80:  BNZ   5F8A
5F82:  MOVF   xD9,W
5F84:  SUBWF  xDB,W
5F86:  BTFSS  FD8.0
5F88:  BRA    6334
5F8A:  CLRF   19
5F8C:  BTFSC  FF2.7
5F8E:  BSF    19.7
5F90:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
5F92:  MOVFF  6DA,82C
5F96:  MOVFF  6D9,82B
5F9A:  MOVLB  8
5F9C:  CLRF   x2E
5F9E:  MOVLW  7C
5FA0:  MOVWF  x2D
5FA2:  MOVLB  0
5FA4:  CALL   34EC
5FA8:  BTFSC  19.7
5FAA:  BSF    FF2.7
5FAC:  MOVLW  96
5FAE:  MOVLB  7
5FB0:  ADDWF  01,W
5FB2:  MOVWF  xEC
5FB4:  MOVLW  00
5FB6:  ADDWFC 02,W
5FB8:  MOVWF  xED
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
5FBA:  MOVLW  7C
5FBC:  SUBWF  xEC,W
5FBE:  MOVWF  xEE
5FC0:  MOVLW  00
5FC2:  SUBWFB xED,W
5FC4:  MOVWF  xEF
5FC6:  MOVWF  xF1
5FC8:  MOVFF  7EE,7F0
5FCC:  CLRF   xF3
5FCE:  MOVLW  7C
5FD0:  MOVWF  xF2
5FD2:  CLRF   xF5
5FD4:  MOVLW  7D
5FD6:  MOVWF  xF4
5FD8:  MOVLB  0
5FDA:  BRA    593A
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
5FDC:  MOVLW  10
5FDE:  MOVWF  FE9
5FE0:  CLRF   19
5FE2:  BTFSC  FF2.7
5FE4:  BSF    19.7
5FE6:  BCF    FF2.7
5FE8:  MOVFF  6DA,827
5FEC:  MOVFF  6D9,826
5FF0:  CALL   405E
5FF4:  BTFSC  19.7
5FF6:  BSF    FF2.7
5FF8:  CLRF   19
5FFA:  BTFSC  FF2.7
5FFC:  BSF    19.7
5FFE:  BCF    FF2.7
6000:  MOVLW  29
6002:  MOVLB  8
6004:  MOVWF  x4F
6006:  MOVLB  0
6008:  CALL   15C8
600C:  BTFSC  19.7
600E:  BSF    FF2.7
6010:  MOVFF  7D,7EE
6014:  MOVLW  01
6016:  MOVLB  7
6018:  MOVWF  xEF
601A:  MOVLB  0
601C:  RCALL  59B0
601E:  CLRF   19
6020:  BTFSC  FF2.7
6022:  BSF    19.7
6024:  BCF    FF2.7
6026:  MOVLW  2F
6028:  MOVLB  8
602A:  MOVWF  x4F
602C:  MOVLB  0
602E:  CALL   15C8
6032:  BTFSC  19.7
6034:  BSF    FF2.7
6036:  MOVFF  7E,7EE
603A:  MOVLW  01
603C:  MOVLB  7
603E:  MOVWF  xEF
6040:  MOVLB  0
6042:  RCALL  59B0
6044:  CLRF   19
6046:  BTFSC  FF2.7
6048:  BSF    19.7
604A:  BCF    FF2.7
604C:  MOVLW  20
604E:  MOVLB  8
6050:  MOVWF  x4F
6052:  MOVLB  0
6054:  CALL   15C8
6058:  BTFSC  19.7
605A:  BSF    FF2.7
605C:  MOVFF  7F,7EE
6060:  MOVLW  01
6062:  MOVLB  7
6064:  MOVWF  xEF
6066:  MOVLB  0
6068:  RCALL  59B0
606A:  CLRF   19
606C:  BTFSC  FF2.7
606E:  BSF    19.7
6070:  BCF    FF2.7
6072:  MOVLW  3A
6074:  MOVLB  8
6076:  MOVWF  x4F
6078:  MOVLB  0
607A:  CALL   15C8
607E:  BTFSC  19.7
6080:  BSF    FF2.7
6082:  MOVFF  80,7EE
6086:  MOVLW  01
6088:  MOVLB  7
608A:  MOVWF  xEF
608C:  MOVLB  0
608E:  RCALL  59B0
6090:  CLRF   19
6092:  BTFSC  FF2.7
6094:  BSF    19.7
6096:  BCF    FF2.7
6098:  MOVLW  3A
609A:  MOVLB  8
609C:  MOVWF  x4F
609E:  MOVLB  0
60A0:  CALL   15C8
60A4:  BTFSC  19.7
60A6:  BSF    FF2.7
60A8:  MOVFF  81,7EE
60AC:  MOVLW  01
60AE:  MOVLB  7
60B0:  MOVWF  xEF
60B2:  MOVLB  0
60B4:  RCALL  59B0
....................             ee_dat=0; 
60B6:  MOVLB  6
60B8:  CLRF   xD8
....................             index=0; 
60BA:  MOVLB  7
60BC:  CLRF   xB8
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
60BE:  MOVLW  EC
60C0:  MOVWF  FF6
60C2:  MOVLW  1B
60C4:  MOVWF  FF7
60C6:  CLRF   19
60C8:  BTFSC  FF2.7
60CA:  BSF    19.7
60CC:  BCF    FF2.7
60CE:  MOVLB  0
60D0:  CALL   16F2
60D4:  BTFSC  19.7
60D6:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
60D8:  MOVLB  7
60DA:  MOVF   xB8,W
60DC:  SUBLW  4E
60DE:  BNC   613C
60E0:  MOVLB  6
60E2:  MOVF   xD8,W
60E4:  SUBLW  3F
60E6:  BTFSS  FD8.2
60E8:  BRA    60EE
60EA:  MOVLB  7
60EC:  BRA    613C
....................                ee_dat = rec[index+5]; 
60EE:  MOVLW  05
60F0:  MOVLB  7
60F2:  ADDWF  xB8,W
60F4:  CLRF   03
60F6:  ADDLW  7D
60F8:  MOVWF  FE9
60FA:  MOVLW  00
60FC:  ADDWFC 03,W
60FE:  MOVWF  FEA
6100:  MOVFF  FEF,6D8
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
6104:  MOVLB  6
6106:  MOVF   xD8,W
6108:  SUBLW  1F
610A:  BC    6128
610C:  MOVF   xD8,W
610E:  SUBLW  7E
6110:  BNC   6128
6112:  CLRF   19
6114:  BTFSC  FF2.7
6116:  BSF    19.7
6118:  BCF    FF2.7
611A:  MOVFF  6D8,84F
611E:  MOVLB  0
6120:  CALL   15C8
6124:  BTFSC  19.7
6126:  BSF    FF2.7
....................                index++; 
6128:  MOVLB  7
612A:  INCF   xB8,F
....................                if(ee_dat==0)break; 
612C:  MOVLB  6
612E:  MOVF   xD8,F
6130:  BNZ   6136
6132:  MOVLB  7
6134:  BRA    613C
....................             } 
6136:  MOVLB  0
6138:  BRA    60D8
613A:  MOVLB  7
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
613C:  MOVLW  FE
613E:  MOVWF  FF6
6140:  MOVLW  1B
6142:  MOVWF  FF7
6144:  CLRF   19
6146:  BTFSC  FF2.7
6148:  BSF    19.7
614A:  BCF    FF2.7
614C:  MOVLB  0
614E:  CALL   16F2
6152:  BTFSC  19.7
6154:  BSF    FF2.7
....................             index=0; 
6156:  MOVLB  7
6158:  CLRF   xB8
....................             ee_dat=0; 
615A:  MOVLB  6
615C:  CLRF   xD8
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
615E:  MOVLB  7
6160:  MOVF   xB8,W
6162:  SUBLW  27
6164:  BNC   61C4
6166:  MOVLB  6
6168:  MOVF   xD8,W
616A:  SUBLW  3F
616C:  BTFSS  FD8.2
616E:  BRA    6174
6170:  MOVLB  7
6172:  BRA    61C4
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
6174:  MOVLW  05
6176:  MOVLB  7
6178:  ADDWF  xB8,W
617A:  ADDLW  4F
617C:  CLRF   03
617E:  ADDLW  7D
6180:  MOVWF  FE9
6182:  MOVLW  00
6184:  ADDWFC 03,W
6186:  MOVWF  FEA
6188:  MOVFF  FEF,6D8
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
618C:  MOVLB  6
618E:  MOVF   xD8,W
6190:  SUBLW  1F
6192:  BC    61B0
6194:  MOVF   xD8,W
6196:  SUBLW  7E
6198:  BNC   61B0
619A:  CLRF   19
619C:  BTFSC  FF2.7
619E:  BSF    19.7
61A0:  BCF    FF2.7
61A2:  MOVFF  6D8,84F
61A6:  MOVLB  0
61A8:  CALL   15C8
61AC:  BTFSC  19.7
61AE:  BSF    FF2.7
....................                index++; 
61B0:  MOVLB  7
61B2:  INCF   xB8,F
....................                if(ee_dat==0)break; 
61B4:  MOVLB  6
61B6:  MOVF   xD8,F
61B8:  BNZ   61C0
61BA:  MOVLB  7
61BC:  BRA    61C4
61BE:  MOVLB  6
....................             } 
61C0:  BRA    615E
61C2:  MOVLB  7
....................             index=0; 
61C4:  CLRF   xB8
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
61C6:  MOVLW  10
61C8:  MOVWF  FF6
61CA:  MOVLW  1C
61CC:  MOVWF  FF7
61CE:  CLRF   19
61D0:  BTFSC  FF2.7
61D2:  BSF    19.7
61D4:  BCF    FF2.7
61D6:  MOVLB  0
61D8:  CALL   16F2
61DC:  BTFSC  19.7
61DE:  BSF    FF2.7
....................             //fprintf(COM2,"addr_key =%lu \n\r",addr_key);  
....................             //fprintf(COM2," ptr_card_key=%lu \n\r",ptr_card_key);  
....................             if(ptr_card_key>addr_key) 
61E0:  MOVLB  6
61E2:  MOVF   xE1,W
61E4:  SUBWF  27,W
61E6:  BTFSS  FD8.0
61E8:  BRA    632C
61EA:  BNZ   6208
61EC:  MOVF   xE0,W
61EE:  SUBWF  26,W
61F0:  BTFSS  FD8.0
61F2:  BRA    632C
61F4:  BNZ   6208
61F6:  MOVF   xDF,W
61F8:  SUBWF  25,W
61FA:  BTFSS  FD8.0
61FC:  BRA    632C
61FE:  BNZ   6208
6200:  MOVF   24,W
6202:  SUBWF  xDE,W
6204:  BTFSC  FD8.0
6206:  BRA    632C
....................             { 
....................                i=0; 
6208:  MOVLB  7
620A:  CLRF   xB9
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
620C:  MOVF   xB9,W
620E:  MOVLB  6
6210:  ADDWF  xDE,W
6212:  MOVLB  7
6214:  MOVWF  xEE
6216:  MOVLW  00
6218:  MOVLB  6
621A:  ADDWFC xDF,W
621C:  MOVLB  7
621E:  MOVWF  xEF
6220:  MOVLW  00
6222:  MOVLB  6
6224:  ADDWFC xE0,W
6226:  MOVLB  7
6228:  MOVWF  xF0
622A:  MOVLW  00
622C:  MOVLB  6
622E:  ADDWFC xE1,W
6230:  MOVLB  7
6232:  MOVWF  xF1
6234:  CLRF   19
6236:  BTFSC  FF2.7
6238:  BSF    19.7
623A:  BCF    FF2.7
623C:  MOVFF  FE8,832
6240:  MOVFF  7F0,831
6244:  MOVFF  7EF,830
6248:  MOVFF  7EE,82F
624C:  MOVLB  0
624E:  CALL   33C8
6252:  BTFSC  19.7
6254:  BSF    FF2.7
6256:  MOVFF  01,6D8
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
625A:  MOVLB  6
625C:  MOVF   xD8,W
625E:  SUBLW  2F
6260:  BC    6268
6262:  MOVF   xD8,W
6264:  SUBLW  39
6266:  BC    6280
6268:  MOVF   xD8,W
626A:  SUBLW  23
626C:  BZ    6280
626E:  MOVF   xD8,W
6270:  SUBLW  2A
6272:  BZ    6280
6274:  MOVF   xD8,W
6276:  SUBLW  40
6278:  BC    6296
627A:  MOVF   xD8,W
627C:  SUBLW  5A
627E:  BNC   6296
6280:  CLRF   19
6282:  BTFSC  FF2.7
6284:  BSF    19.7
6286:  BCF    FF2.7
....................                      fputc(ee_dat,COM2); 
6288:  MOVFF  6D8,84F
628C:  MOVLB  0
628E:  CALL   15C8
6292:  BTFSC  19.7
6294:  BSF    FF2.7
....................                   i++; 
6296:  MOVLB  7
6298:  INCF   xB9,F
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
629A:  MOVF   xB9,W
629C:  SUBLW  0B
629E:  BNC   62AC
62A0:  MOVLB  6
62A2:  MOVF   xD8,F
62A4:  BTFSC  FD8.2
62A6:  BRA    62AC
62A8:  MOVLB  7
62AA:  BRA    620C
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+key_numbyte; 
62AC:  MOVLW  10
62AE:  MOVLB  6
62B0:  ADDWF  xDE,W
62B2:  MOVLB  7
62B4:  MOVWF  xEE
62B6:  MOVLW  00
62B8:  MOVLB  6
62BA:  ADDWFC xDF,W
62BC:  MOVLB  7
62BE:  MOVWF  xEF
62C0:  MOVLW  00
62C2:  MOVLB  6
62C4:  ADDWFC xE0,W
62C6:  MOVLB  7
62C8:  MOVWF  xF0
62CA:  MOVLW  00
62CC:  MOVLB  6
62CE:  ADDWFC xE1,W
62D0:  MOVLB  7
62D2:  MOVWF  xF1
62D4:  MOVLW  04
62D6:  SUBWF  xEE,W
62D8:  MOVLB  6
62DA:  MOVWF  xDE
62DC:  MOVLW  00
62DE:  MOVLB  7
62E0:  SUBWFB xEF,W
62E2:  MOVLB  6
62E4:  MOVWF  xDF
62E6:  MOVLW  00
62E8:  MOVLB  7
62EA:  SUBWFB xF0,W
62EC:  MOVLB  6
62EE:  MOVWF  xE0
62F0:  MOVLW  00
62F2:  MOVLB  7
62F4:  SUBWFB xF1,W
62F6:  MOVLB  6
62F8:  MOVWF  xE1
62FA:  CLRF   19
62FC:  BTFSC  FF2.7
62FE:  BSF    19.7
6300:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
6302:  MOVLW  0A
6304:  MOVLB  8
6306:  MOVWF  x4F
6308:  MOVLB  0
630A:  CALL   15C8
630E:  BTFSC  19.7
6310:  BSF    FF2.7
6312:  CLRF   19
6314:  BTFSC  FF2.7
6316:  BSF    19.7
6318:  BCF    FF2.7
631A:  MOVLW  0D
631C:  MOVLB  8
631E:  MOVWF  x4F
6320:  MOVLB  0
6322:  CALL   15C8
6326:  BTFSC  19.7
6328:  BSF    FF2.7
632A:  MOVLB  6
....................             } 
....................             count_card++; 
632C:  INCF   xD9,F
632E:  BTFSC  FD8.2
6330:  INCF   xDA,F
....................          } 
6332:  BRA    5F78
6334:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
6336:  CLRF   FEA
6338:  MOVLW  41
633A:  MOVWF  FE9
633C:  MOVLW  00
633E:  CALL   0368
6342:  TBLRD*-
6344:  TBLRD*+
6346:  MOVF   FF5,W
6348:  MOVWF  FEE
634A:  IORLW  00
634C:  BNZ   6344
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
634E:  MOVLW  01
6350:  MOVLB  7
6352:  MOVWF  xEF
6354:  MOVLW  5D
6356:  MOVWF  xEE
6358:  CLRF   xF1
635A:  MOVLW  41
635C:  MOVWF  xF0
635E:  MOVLB  0
6360:  CALL   58A2
6364:  MOVF   01,F
6366:  BNZ   639C
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6368:  MOVLW  20
636A:  MOVWF  FF6
636C:  MOVLW  1C
636E:  MOVWF  FF7
6370:  CLRF   19
6372:  BTFSC  FF2.7
6374:  BSF    19.7
6376:  BCF    FF2.7
6378:  CALL   16F2
637C:  BTFSC  19.7
637E:  BSF    FF2.7
....................          format_eepromext(); 
6380:  GOTO   5ACA
....................          fprintf(COM2," exit\n\r");  
6384:  MOVLW  2E
6386:  MOVWF  FF6
6388:  MOVLW  1C
638A:  MOVWF  FF7
638C:  CLRF   19
638E:  BTFSC  FF2.7
6390:  BSF    19.7
6392:  BCF    FF2.7
6394:  CALL   16F2
6398:  BTFSC  19.7
639A:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
639C:  CLRF   FEA
639E:  MOVLW  41
63A0:  MOVWF  FE9
63A2:  MOVLW  00
63A4:  CALL   037A
63A8:  TBLRD*-
63AA:  TBLRD*+
63AC:  MOVF   FF5,W
63AE:  MOVWF  FEE
63B0:  IORLW  00
63B2:  BNZ   63AA
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
63B4:  MOVLW  01
63B6:  MOVLB  7
63B8:  MOVWF  xEF
63BA:  MOVLW  5D
63BC:  MOVWF  xEE
63BE:  CLRF   xF1
63C0:  MOVLW  41
63C2:  MOVWF  xF0
63C4:  MOVLB  0
63C6:  CALL   58A2
63CA:  MOVF   01,F
63CC:  BNZ   6400
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
63CE:  MOVLW  36
63D0:  MOVWF  FF6
63D2:  MOVLW  1C
63D4:  MOVWF  FF7
63D6:  CLRF   19
63D8:  BTFSC  FF2.7
63DA:  BSF    19.7
63DC:  BCF    FF2.7
63DE:  CALL   16F2
63E2:  BTFSC  19.7
63E4:  BSF    FF2.7
....................          ease_eeprom(); 
63E6:  BRA    5C30
....................          fprintf(COM2," exit\n\r");  
63E8:  MOVLW  44
63EA:  MOVWF  FF6
63EC:  MOVLW  1C
63EE:  MOVWF  FF7
63F0:  CLRF   19
63F2:  BTFSC  FF2.7
63F4:  BSF    19.7
63F6:  BCF    FF2.7
63F8:  CALL   16F2
63FC:  BTFSC  19.7
63FE:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6400:  CLRF   FEA
6402:  MOVLW  41
6404:  MOVWF  FE9
6406:  MOVLW  00
6408:  CALL   0390
640C:  TBLRD*-
640E:  TBLRD*+
6410:  MOVF   FF5,W
6412:  MOVWF  FEE
6414:  IORLW  00
6416:  BNZ   640E
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6418:  MOVLW  01
641A:  MOVLB  7
641C:  MOVWF  xEF
641E:  MOVLW  5D
6420:  MOVWF  xEE
6422:  CLRF   xF1
6424:  MOVLW  41
6426:  MOVWF  xF0
6428:  MOVLB  0
642A:  CALL   58A2
642E:  MOVF   01,F
6430:  BNZ   6468
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
6432:  MOVLW  4C
6434:  MOVWF  FF6
6436:  MOVLW  1C
6438:  MOVWF  FF7
643A:  CLRF   19
643C:  BTFSC  FF2.7
643E:  BSF    19.7
6440:  BCF    FF2.7
6442:  CALL   16F2
6446:  BTFSC  19.7
6448:  BSF    FF2.7
....................          reset_password(); 
644A:  BRA    5CB4
....................          init_password(); 
644C:  CALL   4578
....................          fprintf(COM2," exit\n\r");  
6450:  MOVLW  62
6452:  MOVWF  FF6
6454:  MOVLW  1C
6456:  MOVWF  FF7
6458:  CLRF   19
645A:  BTFSC  FF2.7
645C:  BSF    19.7
645E:  BCF    FF2.7
6460:  CALL   16F2
6464:  BTFSC  19.7
6466:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
6468:  CLRF   FEA
646A:  MOVLW  41
646C:  MOVWF  FE9
646E:  MOVLW  00
6470:  CALL   03A6
6474:  TBLRD*-
6476:  TBLRD*+
6478:  MOVF   FF5,W
647A:  MOVWF  FEE
647C:  IORLW  00
647E:  BNZ   6476
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6480:  MOVLW  01
6482:  MOVLB  7
6484:  MOVWF  xEF
6486:  MOVLW  5D
6488:  MOVWF  xEE
648A:  CLRF   xF1
648C:  MOVLW  41
648E:  MOVWF  xF0
6490:  MOVLB  0
6492:  CALL   58A2
6496:  MOVF   01,F
6498:  BNZ   64BA
....................       { 
....................          keydebug_en=1; 
649A:  MOVLW  01
649C:  MOVLB  1
649E:  MOVWF  x3F
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
64A0:  MOVLW  6A
64A2:  MOVWF  FF6
64A4:  MOVLW  1C
64A6:  MOVWF  FF7
64A8:  CLRF   19
64AA:  BTFSC  FF2.7
64AC:  BSF    19.7
64AE:  BCF    FF2.7
64B0:  MOVLB  0
64B2:  CALL   16F2
64B6:  BTFSC  19.7
64B8:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
64BA:  CLRF   FEA
64BC:  MOVLW  41
64BE:  MOVWF  FE9
64C0:  MOVLW  00
64C2:  CALL   03BC
64C6:  TBLRD*-
64C8:  TBLRD*+
64CA:  MOVF   FF5,W
64CC:  MOVWF  FEE
64CE:  IORLW  00
64D0:  BNZ   64C8
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
64D2:  MOVLW  01
64D4:  MOVLB  7
64D6:  MOVWF  xEF
64D8:  MOVLW  5D
64DA:  MOVWF  xEE
64DC:  CLRF   xF1
64DE:  MOVLW  41
64E0:  MOVWF  xF0
64E2:  MOVLB  0
64E4:  CALL   58A2
64E8:  MOVF   01,F
64EA:  BNZ   6508
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
64EC:  MOVLW  7E
64EE:  MOVWF  FF6
64F0:  MOVLW  1C
64F2:  MOVWF  FF7
64F4:  CLRF   19
64F6:  BTFSC  FF2.7
64F8:  BSF    19.7
64FA:  BCF    FF2.7
64FC:  CALL   16F2
6500:  BTFSC  19.7
6502:  BSF    FF2.7
....................          rstfact(); 
6504:  GOTO   5CF6
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
6508:  CLRF   FEA
650A:  MOVLW  41
650C:  MOVWF  FE9
650E:  MOVLW  00
6510:  CALL   03D4
6514:  TBLRD*-
6516:  TBLRD*+
6518:  MOVF   FF5,W
651A:  MOVWF  FEE
651C:  IORLW  00
651E:  BNZ   6516
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6520:  MOVLW  01
6522:  MOVLB  7
6524:  MOVWF  xEF
6526:  MOVLW  5D
6528:  MOVWF  xEE
652A:  CLRF   xF1
652C:  MOVLW  41
652E:  MOVWF  xF0
6530:  MOVLB  0
6532:  CALL   58A2
6536:  MOVF   01,F
6538:  BNZ   6560
....................       { 
....................          mode=LOGOFF; 
653A:  MOVLB  6
653C:  CLRF   xD7
....................          keydebug_en=0; 
653E:  MOVLB  1
6540:  CLRF   x3F
....................          set_tris_a(0xff); 
6542:  MOVLW  FF
6544:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
6546:  MOVLW  8E
6548:  MOVWF  FF6
654A:  MOVLW  1C
654C:  MOVWF  FF7
654E:  CLRF   19
6550:  BTFSC  FF2.7
6552:  BSF    19.7
6554:  BCF    FF2.7
6556:  MOVLB  0
6558:  CALL   16F2
655C:  BTFSC  19.7
655E:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
6560:  CLRF   FEA
6562:  MOVLW  41
6564:  MOVWF  FE9
6566:  MOVLW  00
6568:  CALL   03E6
656C:  TBLRD*-
656E:  TBLRD*+
6570:  MOVF   FF5,W
6572:  MOVWF  FEE
6574:  IORLW  00
6576:  BNZ   656E
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6578:  MOVLW  01
657A:  MOVLB  7
657C:  MOVWF  xEF
657E:  MOVLW  5D
6580:  MOVWF  xEE
6582:  CLRF   xF1
6584:  MOVLW  41
6586:  MOVWF  xF0
6588:  MOVLB  0
658A:  CALL   58A2
658E:  MOVF   01,F
6590:  BNZ   65FE
....................       { 
....................          fprintf(COM2,"New console name>"); 
6592:  MOVLW  96
6594:  MOVWF  FF6
6596:  MOVLW  1C
6598:  MOVWF  FF7
659A:  CLRF   19
659C:  BTFSC  FF2.7
659E:  BSF    19.7
65A0:  BCF    FF2.7
65A2:  CALL   16F2
65A6:  BTFSC  19.7
65A8:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,wide_strobe_nameconsole, console); 
65AA:  MOVLW  01
65AC:  MOVLB  7
65AE:  MOVWF  xEE
65B0:  MOVLW  10
65B2:  MOVWF  xEF
65B4:  MOVLW  06
65B6:  MOVWF  xF1
65B8:  MOVLW  E2
65BA:  MOVWF  xF0
65BC:  MOVLB  0
65BE:  CALL   576A
....................          EEPROM_write(strobe_nameconsole,wide_strobe_nameconsole,console); 
65C2:  MOVLB  8
65C4:  CLRF   x06
65C6:  CLRF   x05
65C8:  CLRF   x04
65CA:  MOVLW  28
65CC:  MOVWF  x03
65CE:  CLRF   x0A
65D0:  CLRF   x09
65D2:  CLRF   x08
65D4:  MOVLW  10
65D6:  MOVWF  x07
65D8:  MOVLW  06
65DA:  MOVWF  x0C
65DC:  MOVLW  E2
65DE:  MOVWF  x0B
65E0:  MOVLB  0
65E2:  CALL   44DC
....................          fprintf(COM2," OK\n\r"); 
65E6:  MOVLW  A8
65E8:  MOVWF  FF6
65EA:  MOVLW  1C
65EC:  MOVWF  FF7
65EE:  CLRF   19
65F0:  BTFSC  FF2.7
65F2:  BSF    19.7
65F4:  BCF    FF2.7
65F6:  CALL   16F2
65FA:  BTFSC  19.7
65FC:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
65FE:  CLRF   FEA
6600:  MOVLW  41
6602:  MOVWF  FE9
6604:  MOVLW  00
6606:  CALL   03F8
660A:  TBLRD*-
660C:  TBLRD*+
660E:  MOVF   FF5,W
6610:  MOVWF  FEE
6612:  IORLW  00
6614:  BNZ   660C
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6616:  MOVLW  01
6618:  MOVLB  7
661A:  MOVWF  xEF
661C:  MOVLW  5D
661E:  MOVWF  xEE
6620:  CLRF   xF1
6622:  MOVLW  41
6624:  MOVWF  xF0
6626:  MOVLB  0
6628:  CALL   58A2
662C:  MOVF   01,F
662E:  BTFSS  FD8.2
6630:  BRA    67D4
6632:  CLRF   19
6634:  BTFSC  FF2.7
6636:  BSF    19.7
6638:  BCF    FF2.7
....................       { 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
663A:  MOVLB  8
663C:  CLRF   x32
663E:  CLRF   x31
6640:  CLRF   x30
6642:  MOVLW  3A
6644:  MOVWF  x2F
6646:  MOVLB  0
6648:  CALL   33C8
664C:  BTFSC  19.7
664E:  BSF    FF2.7
6650:  MOVFF  01,6DD
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6654:  MOVLB  6
6656:  MOVF   xDD,F
6658:  BNZ   6678
665A:  MOVLW  AE
665C:  MOVWF  FF6
665E:  MOVLW  1C
6660:  MOVWF  FF7
6662:  CLRF   19
6664:  BTFSC  FF2.7
6666:  BSF    19.7
6668:  BCF    FF2.7
666A:  MOVLB  0
666C:  CALL   16F2
6670:  BTFSC  19.7
6672:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6674:  BRA    6692
6676:  MOVLB  6
6678:  MOVLW  B2
667A:  MOVWF  FF6
667C:  MOVLW  1C
667E:  MOVWF  FF7
6680:  CLRF   19
6682:  BTFSC  FF2.7
6684:  BSF    19.7
6686:  BCF    FF2.7
6688:  MOVLB  0
668A:  CALL   16F2
668E:  BTFSC  19.7
6690:  BSF    FF2.7
6692:  CLRF   19
6694:  BTFSC  FF2.7
6696:  BSF    19.7
6698:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
669A:  MOVLB  8
669C:  CLRF   x32
669E:  CLRF   x31
66A0:  CLRF   x30
66A2:  MOVLW  3C
66A4:  MOVWF  x2F
66A6:  MOVLB  0
66A8:  CALL   33C8
66AC:  BTFSC  19.7
66AE:  BSF    FF2.7
66B0:  MOVFF  01,155
66B4:  CLRF   19
66B6:  BTFSC  FF2.7
66B8:  BSF    19.7
66BA:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
66BC:  MOVLW  5B
66BE:  MOVLB  8
66C0:  MOVWF  x4F
66C2:  MOVLB  0
66C4:  CALL   15C8
66C8:  BTFSC  19.7
66CA:  BSF    FF2.7
66CC:  MOVFF  155,7EE
66D0:  MOVLW  1B
66D2:  MOVLB  7
66D4:  MOVWF  xEF
66D6:  MOVLB  0
66D8:  GOTO   5D60
66DC:  CLRF   19
66DE:  BTFSC  FF2.7
66E0:  BSF    19.7
66E2:  BCF    FF2.7
66E4:  MOVLW  5D
66E6:  MOVLB  8
66E8:  MOVWF  x4F
66EA:  MOVLB  0
66EC:  CALL   15C8
66F0:  BTFSC  19.7
66F2:  BSF    FF2.7
....................           
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
66F4:  MOVFF  1C6,7EE
66F8:  MOVLW  01
66FA:  MOVLB  7
66FC:  MOVWF  xEF
66FE:  MOVLB  0
6700:  CALL   59B0
6704:  CLRF   19
6706:  BTFSC  FF2.7
6708:  BSF    19.7
670A:  BCF    FF2.7
670C:  MOVLW  2F
670E:  MOVLB  8
6710:  MOVWF  x4F
6712:  MOVLB  0
6714:  CALL   15C8
6718:  BTFSC  19.7
671A:  BSF    FF2.7
671C:  MOVFF  1C5,7EE
6720:  MOVLW  01
6722:  MOVLB  7
6724:  MOVWF  xEF
6726:  MOVLB  0
6728:  CALL   59B0
672C:  CLRF   19
672E:  BTFSC  FF2.7
6730:  BSF    19.7
6732:  BCF    FF2.7
6734:  MOVLW  20
6736:  MOVLB  8
6738:  MOVWF  x4F
673A:  MOVLB  0
673C:  CALL   15C8
6740:  BTFSC  19.7
6742:  BSF    FF2.7
6744:  MOVFF  1C7,7EE
6748:  MOVLW  01
674A:  MOVLB  7
674C:  MOVWF  xEF
674E:  MOVLB  0
6750:  CALL   59B0
6754:  CLRF   19
6756:  BTFSC  FF2.7
6758:  BSF    19.7
675A:  BCF    FF2.7
675C:  MOVLW  3A
675E:  MOVLB  8
6760:  MOVWF  x4F
6762:  MOVLB  0
6764:  CALL   15C8
6768:  BTFSC  19.7
676A:  BSF    FF2.7
676C:  MOVFF  1C8,7EE
6770:  MOVLW  01
6772:  MOVLB  7
6774:  MOVWF  xEF
6776:  MOVLB  0
6778:  CALL   59B0
677C:  CLRF   19
677E:  BTFSC  FF2.7
6780:  BSF    19.7
6782:  BCF    FF2.7
6784:  MOVLW  3A
6786:  MOVLB  8
6788:  MOVWF  x4F
678A:  MOVLB  0
678C:  CALL   15C8
6790:  BTFSC  19.7
6792:  BSF    FF2.7
6794:  MOVFF  1C9,7EE
6798:  MOVLW  01
679A:  MOVLB  7
679C:  MOVWF  xEF
679E:  MOVLB  0
67A0:  CALL   59B0
67A4:  CLRF   19
67A6:  BTFSC  FF2.7
67A8:  BSF    19.7
67AA:  BCF    FF2.7
....................           
....................          fprintf(COM2,"\n\r"); 
67AC:  MOVLW  0A
67AE:  MOVLB  8
67B0:  MOVWF  x4F
67B2:  MOVLB  0
67B4:  CALL   15C8
67B8:  BTFSC  19.7
67BA:  BSF    FF2.7
67BC:  CLRF   19
67BE:  BTFSC  FF2.7
67C0:  BSF    19.7
67C2:  BCF    FF2.7
67C4:  MOVLW  0D
67C6:  MOVLB  8
67C8:  MOVWF  x4F
67CA:  MOVLB  0
67CC:  CALL   15C8
67D0:  BTFSC  19.7
67D2:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
67D4:  CLRF   FEA
67D6:  MOVLW  41
67D8:  MOVWF  FE9
67DA:  MOVLW  00
67DC:  CALL   040A
67E0:  TBLRD*-
67E2:  TBLRD*+
67E4:  MOVF   FF5,W
67E6:  MOVWF  FEE
67E8:  IORLW  00
67EA:  BNZ   67E2
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
67EC:  MOVLW  01
67EE:  MOVLB  7
67F0:  MOVWF  xEF
67F2:  MOVLW  5D
67F4:  MOVWF  xEE
67F6:  CLRF   xF1
67F8:  MOVLW  41
67FA:  MOVWF  xF0
67FC:  MOVLB  0
67FE:  CALL   58A2
6802:  MOVF   01,F
6804:  BTFSS  FD8.2
6806:  BRA    6A14
....................       { 
....................          fprintf(COM2,"Year>"); 
6808:  MOVLW  B6
680A:  MOVWF  FF6
680C:  MOVLW  1C
680E:  MOVWF  FF7
6810:  CLRF   19
6812:  BTFSC  FF2.7
6814:  BSF    19.7
6816:  BCF    FF2.7
6818:  CALL   16F2
681C:  BTFSC  19.7
681E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6820:  MOVLW  01
6822:  MOVLB  7
6824:  MOVWF  xEE
6826:  MOVLW  03
6828:  MOVWF  xEF
682A:  MOVLW  07
682C:  MOVWF  xF1
682E:  MOVLW  BA
6830:  MOVWF  xF0
6832:  MOVLB  0
6834:  CALL   576A
....................          year=(unsigned int8)strtoi(temp); 
6838:  MOVLW  07
683A:  MOVLB  7
683C:  MOVWF  xEF
683E:  MOVLW  BA
6840:  MOVWF  xEE
6842:  MOVLB  0
6844:  CALL   5E26
6848:  MOVFF  01,1C4
....................          fprintf(COM2,"Month>"); 
684C:  MOVLW  BC
684E:  MOVWF  FF6
6850:  MOVLW  1C
6852:  MOVWF  FF7
6854:  CLRF   19
6856:  BTFSC  FF2.7
6858:  BSF    19.7
685A:  BCF    FF2.7
685C:  CALL   16F2
6860:  BTFSC  19.7
6862:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6864:  MOVLW  01
6866:  MOVLB  7
6868:  MOVWF  xEE
686A:  MOVLW  03
686C:  MOVWF  xEF
686E:  MOVLW  07
6870:  MOVWF  xF1
6872:  MOVLW  BA
6874:  MOVWF  xF0
6876:  MOVLB  0
6878:  CALL   576A
....................          mon=(unsigned int8)strtoi(temp); 
687C:  MOVLW  07
687E:  MOVLB  7
6880:  MOVWF  xEF
6882:  MOVLW  BA
6884:  MOVWF  xEE
6886:  MOVLB  0
6888:  CALL   5E26
688C:  MOVFF  01,1C5
....................          fprintf(COM2,"Date>"); 
6890:  MOVLW  C4
6892:  MOVWF  FF6
6894:  MOVLW  1C
6896:  MOVWF  FF7
6898:  CLRF   19
689A:  BTFSC  FF2.7
689C:  BSF    19.7
689E:  BCF    FF2.7
68A0:  CALL   16F2
68A4:  BTFSC  19.7
68A6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
68A8:  MOVLW  01
68AA:  MOVLB  7
68AC:  MOVWF  xEE
68AE:  MOVLW  03
68B0:  MOVWF  xEF
68B2:  MOVLW  07
68B4:  MOVWF  xF1
68B6:  MOVLW  BA
68B8:  MOVWF  xF0
68BA:  MOVLB  0
68BC:  CALL   576A
....................          date = (unsigned int8)strtoi(temp); 
68C0:  MOVLW  07
68C2:  MOVLB  7
68C4:  MOVWF  xEF
68C6:  MOVLW  BA
68C8:  MOVWF  xEE
68CA:  MOVLB  0
68CC:  CALL   5E26
68D0:  MOVFF  01,1C6
....................          fprintf(COM2,"Day>"); 
68D4:  MOVLW  CA
68D6:  MOVWF  FF6
68D8:  MOVLW  1C
68DA:  MOVWF  FF7
68DC:  CLRF   19
68DE:  BTFSC  FF2.7
68E0:  BSF    19.7
68E2:  BCF    FF2.7
68E4:  CALL   16F2
68E8:  BTFSC  19.7
68EA:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
68EC:  MOVLW  01
68EE:  MOVLB  7
68F0:  MOVWF  xEE
68F2:  MOVLW  03
68F4:  MOVWF  xEF
68F6:  MOVLW  07
68F8:  MOVWF  xF1
68FA:  MOVLW  BA
68FC:  MOVWF  xF0
68FE:  MOVLB  0
6900:  CALL   576A
....................          day = (unsigned int8)strtoi(temp); 
6904:  MOVLW  07
6906:  MOVLB  7
6908:  MOVWF  xEF
690A:  MOVLW  BA
690C:  MOVWF  xEE
690E:  MOVLB  0
6910:  CALL   5E26
6914:  MOVFF  01,1C3
....................          fprintf(COM2,"Hour>"); 
6918:  MOVLW  D0
691A:  MOVWF  FF6
691C:  MOVLW  1C
691E:  MOVWF  FF7
6920:  CLRF   19
6922:  BTFSC  FF2.7
6924:  BSF    19.7
6926:  BCF    FF2.7
6928:  CALL   16F2
692C:  BTFSC  19.7
692E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6930:  MOVLW  01
6932:  MOVLB  7
6934:  MOVWF  xEE
6936:  MOVLW  03
6938:  MOVWF  xEF
693A:  MOVLW  07
693C:  MOVWF  xF1
693E:  MOVLW  BA
6940:  MOVWF  xF0
6942:  MOVLB  0
6944:  CALL   576A
....................          h = (unsigned int8)strtoi(temp); 
6948:  MOVLW  07
694A:  MOVLB  7
694C:  MOVWF  xEF
694E:  MOVLW  BA
6950:  MOVWF  xEE
6952:  MOVLB  0
6954:  CALL   5E26
6958:  MOVFF  01,1C7
....................          fprintf(COM2,"Minutes>"); 
695C:  MOVLW  D6
695E:  MOVWF  FF6
6960:  MOVLW  1C
6962:  MOVWF  FF7
6964:  CLRF   19
6966:  BTFSC  FF2.7
6968:  BSF    19.7
696A:  BCF    FF2.7
696C:  CALL   16F2
6970:  BTFSC  19.7
6972:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6974:  MOVLW  01
6976:  MOVLB  7
6978:  MOVWF  xEE
697A:  MOVLW  03
697C:  MOVWF  xEF
697E:  MOVLW  07
6980:  MOVWF  xF1
6982:  MOVLW  BA
6984:  MOVWF  xF0
6986:  MOVLB  0
6988:  CALL   576A
....................          min = (unsigned int8)strtoi(temp);                   
698C:  MOVLW  07
698E:  MOVLB  7
6990:  MOVWF  xEF
6992:  MOVLW  BA
6994:  MOVWF  xEE
6996:  MOVLB  0
6998:  CALL   5E26
699C:  MOVFF  01,1C8
....................          fprintf(COM2,"Seconds>"); 
69A0:  MOVLW  E0
69A2:  MOVWF  FF6
69A4:  MOVLW  1C
69A6:  MOVWF  FF7
69A8:  CLRF   19
69AA:  BTFSC  FF2.7
69AC:  BSF    19.7
69AE:  BCF    FF2.7
69B0:  CALL   16F2
69B4:  BTFSC  19.7
69B6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
69B8:  MOVLW  01
69BA:  MOVLB  7
69BC:  MOVWF  xEE
69BE:  MOVLW  03
69C0:  MOVWF  xEF
69C2:  MOVLW  07
69C4:  MOVWF  xF1
69C6:  MOVLW  BA
69C8:  MOVWF  xF0
69CA:  MOVLB  0
69CC:  CALL   576A
....................          sec = (unsigned int8)strtoi(temp);                   
69D0:  MOVLW  07
69D2:  MOVLB  7
69D4:  MOVWF  xEF
69D6:  MOVLW  BA
69D8:  MOVWF  xEE
69DA:  MOVLB  0
69DC:  CALL   5E26
69E0:  MOVFF  01,1C9
69E4:  CLRF   19
69E6:  BTFSC  FF2.7
69E8:  BSF    19.7
69EA:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
69EC:  MOVLW  0A
69EE:  MOVLB  8
69F0:  MOVWF  x4F
69F2:  MOVLB  0
69F4:  CALL   15C8
69F8:  BTFSC  19.7
69FA:  BSF    FF2.7
69FC:  CLRF   19
69FE:  BTFSC  FF2.7
6A00:  BSF    19.7
6A02:  BCF    FF2.7
6A04:  MOVLW  0D
6A06:  MOVLB  8
6A08:  MOVWF  x4F
6A0A:  MOVLB  0
6A0C:  CALL   15C8
6A10:  BTFSC  19.7
6A12:  BSF    FF2.7
....................          /* rtc_set_datetime(date,mon,year,day,h,min); */ 
....................       } 
....................       strcpy(buffer2,"MS"); 
6A14:  CLRF   FEA
6A16:  MOVLW  41
6A18:  MOVWF  FE9
6A1A:  MOVLW  00
6A1C:  CALL   041E
6A20:  TBLRD*-
6A22:  TBLRD*+
6A24:  MOVF   FF5,W
6A26:  MOVWF  FEE
6A28:  IORLW  00
6A2A:  BNZ   6A22
....................       if(!stringcomp(buffer_uart,buffer2)) 
6A2C:  MOVLW  01
6A2E:  MOVLB  7
6A30:  MOVWF  xEF
6A32:  MOVLW  5D
6A34:  MOVWF  xEE
6A36:  CLRF   xF1
6A38:  MOVLW  41
6A3A:  MOVWF  xF0
6A3C:  MOVLB  0
6A3E:  CALL   58A2
6A42:  MOVF   01,F
6A44:  BTFSS  FD8.2
6A46:  BRA    6B5A
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
6A48:  MOVLW  EA
6A4A:  MOVWF  FF6
6A4C:  MOVLW  1C
6A4E:  MOVWF  FF7
6A50:  CLRF   19
6A52:  BTFSC  FF2.7
6A54:  BSF    19.7
6A56:  BCF    FF2.7
6A58:  CALL   16F2
6A5C:  BTFSC  19.7
6A5E:  BSF    FF2.7
6A60:  CLRF   19
6A62:  BTFSC  FF2.7
6A64:  BSF    19.7
6A66:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6A68:  MOVLW  0A
6A6A:  MOVLB  8
6A6C:  MOVWF  x4F
6A6E:  MOVLB  0
6A70:  CALL   15C8
6A74:  BTFSC  19.7
6A76:  BSF    FF2.7
6A78:  CLRF   19
6A7A:  BTFSC  FF2.7
6A7C:  BSF    19.7
6A7E:  BCF    FF2.7
6A80:  MOVLW  0D
6A82:  MOVLB  8
6A84:  MOVWF  x4F
6A86:  MOVLB  0
6A88:  CALL   15C8
6A8C:  BTFSC  19.7
6A8E:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
6A90:  MOVLW  0A
6A92:  MOVWF  FF6
6A94:  MOVLW  1D
6A96:  MOVWF  FF7
6A98:  CLRF   19
6A9A:  BTFSC  FF2.7
6A9C:  BSF    19.7
6A9E:  BCF    FF2.7
6AA0:  CALL   16F2
6AA4:  BTFSC  19.7
6AA6:  BSF    FF2.7
6AA8:  CLRF   19
6AAA:  BTFSC  FF2.7
6AAC:  BSF    19.7
6AAE:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6AB0:  MOVLW  0A
6AB2:  MOVLB  8
6AB4:  MOVWF  x4F
6AB6:  MOVLB  0
6AB8:  CALL   15C8
6ABC:  BTFSC  19.7
6ABE:  BSF    FF2.7
6AC0:  CLRF   19
6AC2:  BTFSC  FF2.7
6AC4:  BSF    19.7
6AC6:  BCF    FF2.7
6AC8:  MOVLW  0D
6ACA:  MOVLB  8
6ACC:  MOVWF  x4F
6ACE:  MOVLB  0
6AD0:  CALL   15C8
6AD4:  BTFSC  19.7
6AD6:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6AD8:  MOVLW  01
6ADA:  MOVLB  7
6ADC:  MOVWF  xEE
6ADE:  MOVLW  03
6AE0:  MOVWF  xEF
6AE2:  MOVLW  07
6AE4:  MOVWF  xF1
6AE6:  MOVLW  BA
6AE8:  MOVWF  xF0
6AEA:  MOVLB  0
6AEC:  CALL   576A
....................           mode_sl = (unsigned int8)strtoi(temp); 
6AF0:  MOVLW  07
6AF2:  MOVLB  7
6AF4:  MOVWF  xEF
6AF6:  MOVLW  BA
6AF8:  MOVWF  xEE
6AFA:  MOVLB  0
6AFC:  CALL   5E26
6B00:  MOVFF  01,6DD
6B04:  CLRF   19
6B06:  BTFSC  FF2.7
6B08:  BSF    19.7
6B0A:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
6B0C:  MOVLB  8
6B0E:  CLRF   x3A
6B10:  CLRF   x39
6B12:  CLRF   x38
6B14:  MOVLW  3A
6B16:  MOVWF  x37
6B18:  MOVFF  6DD,83B
6B1C:  MOVLB  0
6B1E:  CALL   3918
6B22:  BTFSC  19.7
6B24:  BSF    FF2.7
....................           set_tris_a(0xff); 
6B26:  MOVLW  FF
6B28:  MOVWF  F92
6B2A:  CLRF   19
6B2C:  BTFSC  FF2.7
6B2E:  BSF    19.7
6B30:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6B32:  MOVLW  0A
6B34:  MOVLB  8
6B36:  MOVWF  x4F
6B38:  MOVLB  0
6B3A:  CALL   15C8
6B3E:  BTFSC  19.7
6B40:  BSF    FF2.7
6B42:  CLRF   19
6B44:  BTFSC  FF2.7
6B46:  BSF    19.7
6B48:  BCF    FF2.7
6B4A:  MOVLW  0D
6B4C:  MOVLB  8
6B4E:  MOVWF  x4F
6B50:  MOVLB  0
6B52:  CALL   15C8
6B56:  BTFSC  19.7
6B58:  BSF    FF2.7
....................       } 
....................       
....................       strcpy(buffer2,"tran time"); 
6B5A:  CLRF   FEA
6B5C:  MOVLW  41
6B5E:  MOVWF  FE9
6B60:  MOVLW  00
6B62:  CALL   0432
6B66:  TBLRD*-
6B68:  TBLRD*+
6B6A:  MOVF   FF5,W
6B6C:  MOVWF  FEE
6B6E:  IORLW  00
6B70:  BNZ   6B68
....................       if(!stringcomp(buffer_uart,buffer2)) 
6B72:  MOVLW  01
6B74:  MOVLB  7
6B76:  MOVWF  xEF
6B78:  MOVLW  5D
6B7A:  MOVWF  xEE
6B7C:  CLRF   xF1
6B7E:  MOVLW  41
6B80:  MOVWF  xF0
6B82:  MOVLB  0
6B84:  CALL   58A2
6B88:  MOVF   01,F
6B8A:  BNZ   6C52
....................       { 
....................           fprintf(COM2,"Input Number"); 
6B8C:  MOVLW  2A
6B8E:  MOVWF  FF6
6B90:  MOVLW  1D
6B92:  MOVWF  FF7
6B94:  CLRF   19
6B96:  BTFSC  FF2.7
6B98:  BSF    19.7
6B9A:  BCF    FF2.7
6B9C:  CALL   16F2
6BA0:  BTFSC  19.7
6BA2:  BSF    FF2.7
6BA4:  CLRF   19
6BA6:  BTFSC  FF2.7
6BA8:  BSF    19.7
6BAA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6BAC:  MOVLW  0A
6BAE:  MOVLB  8
6BB0:  MOVWF  x4F
6BB2:  MOVLB  0
6BB4:  CALL   15C8
6BB8:  BTFSC  19.7
6BBA:  BSF    FF2.7
6BBC:  CLRF   19
6BBE:  BTFSC  FF2.7
6BC0:  BSF    19.7
6BC2:  BCF    FF2.7
6BC4:  MOVLW  0D
6BC6:  MOVLB  8
6BC8:  MOVWF  x4F
6BCA:  MOVLB  0
6BCC:  CALL   15C8
6BD0:  BTFSC  19.7
6BD2:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6BD4:  MOVLW  01
6BD6:  MOVLB  7
6BD8:  MOVWF  xEE
6BDA:  MOVLW  03
6BDC:  MOVWF  xEF
6BDE:  MOVLW  07
6BE0:  MOVWF  xF1
6BE2:  MOVLW  BA
6BE4:  MOVWF  xF0
6BE6:  MOVLB  0
6BE8:  CALL   576A
....................           delaycharaction = (unsigned int8)strtoi(temp); 
6BEC:  MOVLW  07
6BEE:  MOVLB  7
6BF0:  MOVWF  xEF
6BF2:  MOVLW  BA
6BF4:  MOVWF  xEE
6BF6:  MOVLB  0
6BF8:  CALL   5E26
6BFC:  MOVFF  01,155
6C00:  CLRF   19
6C02:  BTFSC  FF2.7
6C04:  BSF    19.7
6C06:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
6C08:  MOVLB  8
6C0A:  CLRF   x3A
6C0C:  CLRF   x39
6C0E:  CLRF   x38
6C10:  MOVLW  3C
6C12:  MOVWF  x37
6C14:  MOVFF  155,83B
6C18:  MOVLB  0
6C1A:  CALL   3918
6C1E:  BTFSC  19.7
6C20:  BSF    FF2.7
6C22:  CLRF   19
6C24:  BTFSC  FF2.7
6C26:  BSF    19.7
6C28:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6C2A:  MOVLW  0A
6C2C:  MOVLB  8
6C2E:  MOVWF  x4F
6C30:  MOVLB  0
6C32:  CALL   15C8
6C36:  BTFSC  19.7
6C38:  BSF    FF2.7
6C3A:  CLRF   19
6C3C:  BTFSC  FF2.7
6C3E:  BSF    19.7
6C40:  BCF    FF2.7
6C42:  MOVLW  0D
6C44:  MOVLB  8
6C46:  MOVWF  x4F
6C48:  MOVLB  0
6C4A:  CALL   15C8
6C4E:  BTFSC  19.7
6C50:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
6C52:  CLRF   FEA
6C54:  MOVLW  41
6C56:  MOVWF  FE9
6C58:  MOVLW  00
6C5A:  CALL   044C
6C5E:  TBLRD*-
6C60:  TBLRD*+
6C62:  MOVF   FF5,W
6C64:  MOVWF  FEE
6C66:  IORLW  00
6C68:  BNZ   6C60
....................       if(!stringcomp(buffer_uart,buffer2)) 
6C6A:  MOVLW  01
6C6C:  MOVLB  7
6C6E:  MOVWF  xEF
6C70:  MOVLW  5D
6C72:  MOVWF  xEE
6C74:  CLRF   xF1
6C76:  MOVLW  41
6C78:  MOVWF  xF0
6C7A:  MOVLB  0
6C7C:  CALL   58A2
6C80:  MOVF   01,F
6C82:  BTFSS  FD8.2
6C84:  BRA    6D94
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
6C86:  MOVLW  38
6C88:  MOVWF  FF6
6C8A:  MOVLW  1D
6C8C:  MOVWF  FF7
6C8E:  CLRF   19
6C90:  BTFSC  FF2.7
6C92:  BSF    19.7
6C94:  BCF    FF2.7
6C96:  CALL   16F2
6C9A:  BTFSC  19.7
6C9C:  BSF    FF2.7
6C9E:  CLRF   19
6CA0:  BTFSC  FF2.7
6CA2:  BSF    19.7
6CA4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6CA6:  MOVLW  0A
6CA8:  MOVLB  8
6CAA:  MOVWF  x4F
6CAC:  MOVLB  0
6CAE:  CALL   15C8
6CB2:  BTFSC  19.7
6CB4:  BSF    FF2.7
6CB6:  CLRF   19
6CB8:  BTFSC  FF2.7
6CBA:  BSF    19.7
6CBC:  BCF    FF2.7
6CBE:  MOVLW  0D
6CC0:  MOVLB  8
6CC2:  MOVWF  x4F
6CC4:  MOVLB  0
6CC6:  CALL   15C8
6CCA:  BTFSC  19.7
6CCC:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
6CCE:  MOVLW  5E
6CD0:  MOVWF  FF6
6CD2:  MOVLW  1D
6CD4:  MOVWF  FF7
6CD6:  CLRF   19
6CD8:  BTFSC  FF2.7
6CDA:  BSF    19.7
6CDC:  BCF    FF2.7
6CDE:  CALL   16F2
6CE2:  BTFSC  19.7
6CE4:  BSF    FF2.7
6CE6:  CLRF   19
6CE8:  BTFSC  FF2.7
6CEA:  BSF    19.7
6CEC:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6CEE:  MOVLW  0A
6CF0:  MOVLB  8
6CF2:  MOVWF  x4F
6CF4:  MOVLB  0
6CF6:  CALL   15C8
6CFA:  BTFSC  19.7
6CFC:  BSF    FF2.7
6CFE:  CLRF   19
6D00:  BTFSC  FF2.7
6D02:  BSF    19.7
6D04:  BCF    FF2.7
6D06:  MOVLW  0D
6D08:  MOVLB  8
6D0A:  MOVWF  x4F
6D0C:  MOVLB  0
6D0E:  CALL   15C8
6D12:  BTFSC  19.7
6D14:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6D16:  MOVLW  01
6D18:  MOVLB  7
6D1A:  MOVWF  xEE
6D1C:  MOVLW  03
6D1E:  MOVWF  xEF
6D20:  MOVLW  07
6D22:  MOVWF  xF1
6D24:  MOVLW  BA
6D26:  MOVWF  xF0
6D28:  MOVLB  0
6D2A:  CALL   576A
....................           type_KB=(unsigned int8)strtoi(temp); 
6D2E:  MOVLW  07
6D30:  MOVLB  7
6D32:  MOVWF  xEF
6D34:  MOVLW  BA
6D36:  MOVWF  xEE
6D38:  MOVLB  0
6D3A:  CALL   5E26
6D3E:  MOVFF  01,144
6D42:  CLRF   19
6D44:  BTFSC  FF2.7
6D46:  BSF    19.7
6D48:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
6D4A:  MOVLB  8
6D4C:  CLRF   x3A
6D4E:  CLRF   x39
6D50:  CLRF   x38
6D52:  MOVLW  3D
6D54:  MOVWF  x37
6D56:  MOVFF  144,83B
6D5A:  MOVLB  0
6D5C:  CALL   3918
6D60:  BTFSC  19.7
6D62:  BSF    FF2.7
6D64:  CLRF   19
6D66:  BTFSC  FF2.7
6D68:  BSF    19.7
6D6A:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
6D6C:  MOVLW  0A
6D6E:  MOVLB  8
6D70:  MOVWF  x4F
6D72:  MOVLB  0
6D74:  CALL   15C8
6D78:  BTFSC  19.7
6D7A:  BSF    FF2.7
6D7C:  CLRF   19
6D7E:  BTFSC  FF2.7
6D80:  BSF    19.7
6D82:  BCF    FF2.7
6D84:  MOVLW  0D
6D86:  MOVLB  8
6D88:  MOVWF  x4F
6D8A:  MOVLB  0
6D8C:  CALL   15C8
6D90:  BTFSC  19.7
6D92:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
6D94:  CLRF   FEA
6D96:  MOVLW  41
6D98:  MOVWF  FE9
6D9A:  MOVLW  00
6D9C:  CALL   0462
6DA0:  TBLRD*-
6DA2:  TBLRD*+
6DA4:  MOVF   FF5,W
6DA6:  MOVWF  FEE
6DA8:  IORLW  00
6DAA:  BNZ   6DA2
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
6DAC:  MOVLW  01
6DAE:  MOVLB  7
6DB0:  MOVWF  xEF
6DB2:  MOVLW  5D
6DB4:  MOVWF  xEE
6DB6:  CLRF   xF1
6DB8:  MOVLW  41
6DBA:  MOVWF  xF0
6DBC:  MOVLB  0
6DBE:  CALL   58A2
6DC2:  MOVF   01,F
6DC4:  BTFSS  FD8.2
6DC6:  BRA    6F36
....................       { 
....................          printf("h-> Help\n\r"); 
6DC8:  MOVLW  84
6DCA:  MOVWF  FF6
6DCC:  MOVLW  1D
6DCE:  MOVWF  FF7
6DD0:  CLRF   19
6DD2:  BTFSC  FF2.7
6DD4:  BSF    19.7
6DD6:  BCF    FF2.7
6DD8:  CALL   16F2
6DDC:  BTFSC  19.7
6DDE:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
6DE0:  MOVLW  90
6DE2:  MOVWF  FF6
6DE4:  MOVLW  1D
6DE6:  MOVWF  FF7
6DE8:  CLRF   19
6DEA:  BTFSC  FF2.7
6DEC:  BSF    19.7
6DEE:  BCF    FF2.7
6DF0:  CALL   16F2
6DF4:  BTFSC  19.7
6DF6:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
6DF8:  MOVLW  A2
6DFA:  MOVWF  FF6
6DFC:  MOVLW  1D
6DFE:  MOVWF  FF7
6E00:  CLRF   19
6E02:  BTFSC  FF2.7
6E04:  BSF    19.7
6E06:  BCF    FF2.7
6E08:  CALL   16F2
6E0C:  BTFSC  19.7
6E0E:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
6E10:  MOVLW  B4
6E12:  MOVWF  FF6
6E14:  MOVLW  1D
6E16:  MOVWF  FF7
6E18:  CLRF   19
6E1A:  BTFSC  FF2.7
6E1C:  BSF    19.7
6E1E:  BCF    FF2.7
6E20:  CALL   16F2
6E24:  BTFSC  19.7
6E26:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
6E28:  MOVLW  D4
6E2A:  MOVWF  FF6
6E2C:  MOVLW  1D
6E2E:  MOVWF  FF7
6E30:  CLRF   19
6E32:  BTFSC  FF2.7
6E34:  BSF    19.7
6E36:  BCF    FF2.7
6E38:  CALL   16F2
6E3C:  BTFSC  19.7
6E3E:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
6E40:  MOVLW  F0
6E42:  MOVWF  FF6
6E44:  MOVLW  1D
6E46:  MOVWF  FF7
6E48:  CLRF   19
6E4A:  BTFSC  FF2.7
6E4C:  BSF    19.7
6E4E:  BCF    FF2.7
6E50:  CALL   16F2
6E54:  BTFSC  19.7
6E56:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
6E58:  MOVLW  FE
6E5A:  MOVWF  FF6
6E5C:  MOVLW  1D
6E5E:  MOVWF  FF7
6E60:  CLRF   19
6E62:  BTFSC  FF2.7
6E64:  BSF    19.7
6E66:  BCF    FF2.7
6E68:  CALL   16F2
6E6C:  BTFSC  19.7
6E6E:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
6E70:  MOVLW  0A
6E72:  MOVWF  FF6
6E74:  MOVLW  1E
6E76:  MOVWF  FF7
6E78:  CLRF   19
6E7A:  BTFSC  FF2.7
6E7C:  BSF    19.7
6E7E:  BCF    FF2.7
6E80:  CALL   16F2
6E84:  BTFSC  19.7
6E86:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
6E88:  MOVLW  32
6E8A:  MOVWF  FF6
6E8C:  MOVLW  1E
6E8E:  MOVWF  FF7
6E90:  CLRF   19
6E92:  BTFSC  FF2.7
6E94:  BSF    19.7
6E96:  BCF    FF2.7
6E98:  CALL   16F2
6E9C:  BTFSC  19.7
6E9E:  BSF    FF2.7
6EA0:  CLRF   19
6EA2:  BTFSC  FF2.7
6EA4:  BSF    19.7
6EA6:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
6EA8:  MOVLB  8
6EAA:  CLRF   x32
6EAC:  CLRF   x31
6EAE:  CLRF   x30
6EB0:  MOVLW  3D
6EB2:  MOVWF  x2F
6EB4:  MOVLB  0
6EB6:  CALL   33C8
6EBA:  BTFSC  19.7
6EBC:  BSF    FF2.7
6EBE:  MOVFF  01,7EE
6EC2:  MOVLW  4E
6EC4:  MOVWF  FF6
6EC6:  MOVLW  1E
6EC8:  MOVWF  FF7
6ECA:  CLRF   19
6ECC:  BTFSC  FF2.7
6ECE:  BSF    19.7
6ED0:  BCF    FF2.7
6ED2:  MOVLW  06
6ED4:  MOVLB  8
6ED6:  MOVWF  x43
6ED8:  MOVLB  0
6EDA:  CALL   160E
6EDE:  BTFSC  19.7
6EE0:  BSF    FF2.7
6EE2:  CLRF   19
6EE4:  BTFSC  FF2.7
6EE6:  BSF    19.7
6EE8:  BCF    FF2.7
6EEA:  MOVFF  7EE,82F
6EEE:  MOVLW  18
6EF0:  MOVLB  8
6EF2:  MOVWF  x30
6EF4:  MOVLB  0
6EF6:  CALL   173E
6EFA:  BTFSC  19.7
6EFC:  BSF    FF2.7
6EFE:  MOVLW  56
6F00:  MOVWF  FF6
6F02:  MOVLW  1E
6F04:  MOVWF  FF7
6F06:  CLRF   19
6F08:  BTFSC  FF2.7
6F0A:  BSF    19.7
6F0C:  BCF    FF2.7
6F0E:  MOVLW  1D
6F10:  MOVLB  8
6F12:  MOVWF  x43
6F14:  MOVLB  0
6F16:  CALL   160E
6F1A:  BTFSC  19.7
6F1C:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
6F1E:  MOVLW  74
6F20:  MOVWF  FF6
6F22:  MOVLW  1E
6F24:  MOVWF  FF7
6F26:  CLRF   19
6F28:  BTFSC  FF2.7
6F2A:  BSF    19.7
6F2C:  BCF    FF2.7
6F2E:  CALL   16F2
6F32:  BTFSC  19.7
6F34:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
6F36:  CLRF   FEA
6F38:  MOVLW  41
6F3A:  MOVWF  FE9
6F3C:  MOVLW  00
6F3E:  CALL   0474
6F42:  TBLRD*-
6F44:  TBLRD*+
6F46:  MOVF   FF5,W
6F48:  MOVWF  FEE
6F4A:  IORLW  00
6F4C:  BNZ   6F44
....................       if(!stringcomp(buffer_uart,buffer2))  
6F4E:  MOVLW  01
6F50:  MOVLB  7
6F52:  MOVWF  xEF
6F54:  MOVLW  5D
6F56:  MOVWF  xEE
6F58:  CLRF   xF1
6F5A:  MOVLW  41
6F5C:  MOVWF  xF0
6F5E:  MOVLB  0
6F60:  CALL   58A2
6F64:  MOVF   01,F
6F66:  BTFSS  FD8.2
6F68:  BRA    70B0
....................       { 
....................          fprintf(COM2,"old password:"); 
6F6A:  MOVLW  8E
6F6C:  MOVWF  FF6
6F6E:  MOVLW  1E
6F70:  MOVWF  FF7
6F72:  CLRF   19
6F74:  BTFSC  FF2.7
6F76:  BSF    19.7
6F78:  BCF    FF2.7
6F7A:  CALL   16F2
6F7E:  BTFSC  19.7
6F80:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
6F82:  MOVLB  7
6F84:  CLRF   xF1
6F86:  CLRF   xF0
6F88:  CLRF   xEF
6F8A:  CLRF   xEE
6F8C:  CLRF   xF5
6F8E:  CLRF   xF4
6F90:  CLRF   xF3
6F92:  MOVLW  14
6F94:  MOVWF  xF2
6F96:  CLRF   xF7
6F98:  MOVLW  55
6F9A:  MOVWF  xF6
6F9C:  MOVLB  0
6F9E:  CALL   4436
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
6FA2:  MOVLW  02
6FA4:  MOVLB  7
6FA6:  MOVWF  xEE
6FA8:  MOVLW  14
6FAA:  MOVWF  xEF
6FAC:  CLRF   xF1
6FAE:  MOVLW  69
6FB0:  MOVWF  xF0
6FB2:  MOVLB  0
6FB4:  CALL   576A
....................          if(!stringcomp(entpassword,password)) 
6FB8:  MOVLB  7
6FBA:  CLRF   xEF
6FBC:  MOVLW  69
6FBE:  MOVWF  xEE
6FC0:  CLRF   xF1
6FC2:  MOVLW  55
6FC4:  MOVWF  xF0
6FC6:  MOVLB  0
6FC8:  CALL   58A2
6FCC:  MOVF   01,F
6FCE:  BNZ   7098
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
6FD0:  MOVLW  9C
6FD2:  MOVWF  FF6
6FD4:  MOVLW  1E
6FD6:  MOVWF  FF7
6FD8:  CLRF   19
6FDA:  BTFSC  FF2.7
6FDC:  BSF    19.7
6FDE:  BCF    FF2.7
6FE0:  CALL   16F2
6FE4:  BTFSC  19.7
6FE6:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
6FE8:  MOVLW  02
6FEA:  MOVLB  7
6FEC:  MOVWF  xEE
6FEE:  MOVLW  14
6FF0:  MOVWF  xEF
6FF2:  CLRF   xF1
6FF4:  MOVLW  69
6FF6:  MOVWF  xF0
6FF8:  MOVLB  0
6FFA:  CALL   576A
....................             fprintf(COM2,"\n\ragain:"); 
6FFE:  MOVLW  A4
7000:  MOVWF  FF6
7002:  MOVLW  1E
7004:  MOVWF  FF7
7006:  CLRF   19
7008:  BTFSC  FF2.7
700A:  BSF    19.7
700C:  BCF    FF2.7
700E:  CALL   16F2
7012:  BTFSC  19.7
7014:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
7016:  MOVLW  02
7018:  MOVLB  7
701A:  MOVWF  xEE
701C:  MOVLW  14
701E:  MOVWF  xEF
7020:  CLRF   xF1
7022:  MOVLW  55
7024:  MOVWF  xF0
7026:  MOVLB  0
7028:  CALL   576A
....................             if(!stringcomp(entpassword,password)) 
702C:  MOVLB  7
702E:  CLRF   xEF
7030:  MOVLW  69
7032:  MOVWF  xEE
7034:  CLRF   xF1
7036:  MOVLW  55
7038:  MOVWF  xF0
703A:  MOVLB  0
703C:  CALL   58A2
7040:  MOVF   01,F
7042:  BNZ   707E
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
7044:  MOVLB  8
7046:  CLRF   x06
7048:  CLRF   x05
704A:  CLRF   x04
704C:  CLRF   x03
704E:  CLRF   x0A
7050:  CLRF   x09
7052:  CLRF   x08
7054:  MOVLW  14
7056:  MOVWF  x07
7058:  CLRF   x0C
705A:  MOVLW  55
705C:  MOVWF  x0B
705E:  MOVLB  0
7060:  CALL   44DC
....................                fprintf(COM2,"\n\rOK\n\r");    
7064:  MOVLW  AE
7066:  MOVWF  FF6
7068:  MOVLW  1E
706A:  MOVWF  FF7
706C:  CLRF   19
706E:  BTFSC  FF2.7
7070:  BSF    19.7
7072:  BCF    FF2.7
7074:  CALL   16F2
7078:  BTFSC  19.7
707A:  BSF    FF2.7
....................             } 
....................                else 
707C:  BRA    7096
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
707E:  MOVLW  B6
7080:  MOVWF  FF6
7082:  MOVLW  1E
7084:  MOVWF  FF7
7086:  CLRF   19
7088:  BTFSC  FF2.7
708A:  BSF    19.7
708C:  BCF    FF2.7
708E:  CALL   16F2
7092:  BTFSC  19.7
7094:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
7096:  BRA    70B0
....................             { 
....................                fprintf(COM2," X\n\r"); 
7098:  MOVLW  BE
709A:  MOVWF  FF6
709C:  MOVLW  1E
709E:  MOVWF  FF7
70A0:  CLRF   19
70A2:  BTFSC  FF2.7
70A4:  BSF    19.7
70A6:  BCF    FF2.7
70A8:  CALL   16F2
70AC:  BTFSC  19.7
70AE:  BSF    FF2.7
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
70B0:  CLRF   FEA
70B2:  MOVLW  41
70B4:  MOVWF  FE9
70B6:  MOVLW  00
70B8:  CALL   048E
70BC:  TBLRD*-
70BE:  TBLRD*+
70C0:  MOVF   FF5,W
70C2:  MOVWF  FEE
70C4:  IORLW  00
70C6:  BNZ   70BE
....................       if(!stringcomp(buffer_uart,buffer2)) 
70C8:  MOVLW  01
70CA:  MOVLB  7
70CC:  MOVWF  xEF
70CE:  MOVLW  5D
70D0:  MOVWF  xEE
70D2:  CLRF   xF1
70D4:  MOVLW  41
70D6:  MOVWF  xF0
70D8:  MOVLB  0
70DA:  CALL   58A2
70DE:  MOVF   01,F
70E0:  BTFSS  FD8.2
70E2:  BRA    71F2
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
70E4:  MOVLW  C4
70E6:  MOVWF  FF6
70E8:  MOVLW  1E
70EA:  MOVWF  FF7
70EC:  CLRF   19
70EE:  BTFSC  FF2.7
70F0:  BSF    19.7
70F2:  BCF    FF2.7
70F4:  CALL   16F2
70F8:  BTFSC  19.7
70FA:  BSF    FF2.7
70FC:  CLRF   19
70FE:  BTFSC  FF2.7
7100:  BSF    19.7
7102:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7104:  MOVLW  0A
7106:  MOVLB  8
7108:  MOVWF  x4F
710A:  MOVLB  0
710C:  CALL   15C8
7110:  BTFSC  19.7
7112:  BSF    FF2.7
7114:  CLRF   19
7116:  BTFSC  FF2.7
7118:  BSF    19.7
711A:  BCF    FF2.7
711C:  MOVLW  0D
711E:  MOVLB  8
7120:  MOVWF  x4F
7122:  MOVLB  0
7124:  CALL   15C8
7128:  BTFSC  19.7
712A:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
712C:  MOVLW  E4
712E:  MOVWF  FF6
7130:  MOVLW  1E
7132:  MOVWF  FF7
7134:  CLRF   19
7136:  BTFSC  FF2.7
7138:  BSF    19.7
713A:  BCF    FF2.7
713C:  CALL   16F2
7140:  BTFSC  19.7
7142:  BSF    FF2.7
7144:  CLRF   19
7146:  BTFSC  FF2.7
7148:  BSF    19.7
714A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
714C:  MOVLW  0A
714E:  MOVLB  8
7150:  MOVWF  x4F
7152:  MOVLB  0
7154:  CALL   15C8
7158:  BTFSC  19.7
715A:  BSF    FF2.7
715C:  CLRF   19
715E:  BTFSC  FF2.7
7160:  BSF    19.7
7162:  BCF    FF2.7
7164:  MOVLW  0D
7166:  MOVLB  8
7168:  MOVWF  x4F
716A:  MOVLB  0
716C:  CALL   15C8
7170:  BTFSC  19.7
7172:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7174:  MOVLW  01
7176:  MOVLB  7
7178:  MOVWF  xEE
717A:  MOVLW  03
717C:  MOVWF  xEF
717E:  MOVLW  07
7180:  MOVWF  xF1
7182:  MOVLW  BA
7184:  MOVWF  xF0
7186:  MOVLB  0
7188:  CALL   576A
....................           debugmode = (unsigned int8)strtoi(temp); 
718C:  MOVLW  07
718E:  MOVLB  7
7190:  MOVWF  xEF
7192:  MOVLW  BA
7194:  MOVWF  xEE
7196:  MOVLB  0
7198:  CALL   5E26
719C:  MOVFF  01,6D1
71A0:  CLRF   19
71A2:  BTFSC  FF2.7
71A4:  BSF    19.7
71A6:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
71A8:  MOVLB  8
71AA:  CLRF   x3A
71AC:  CLRF   x39
71AE:  CLRF   x38
71B0:  MOVLW  3B
71B2:  MOVWF  x37
71B4:  MOVFF  6D1,83B
71B8:  MOVLB  0
71BA:  CALL   3918
71BE:  BTFSC  19.7
71C0:  BSF    FF2.7
71C2:  CLRF   19
71C4:  BTFSC  FF2.7
71C6:  BSF    19.7
71C8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
71CA:  MOVLW  0A
71CC:  MOVLB  8
71CE:  MOVWF  x4F
71D0:  MOVLB  0
71D2:  CALL   15C8
71D6:  BTFSC  19.7
71D8:  BSF    FF2.7
71DA:  CLRF   19
71DC:  BTFSC  FF2.7
71DE:  BSF    19.7
71E0:  BCF    FF2.7
71E2:  MOVLW  0D
71E4:  MOVLB  8
71E6:  MOVWF  x4F
71E8:  MOVLB  0
71EA:  CALL   15C8
71EE:  BTFSC  19.7
71F0:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
71F2:  GOTO   7A10 (RETURN)
.................... //=============================================== 
....................  
....................  
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    if(keydebug_en==1) 
*
4154:  MOVLB  1
4156:  DECFSZ x3F,W
4158:  BRA    4174
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
415A:  MOVLB  6
415C:  MOVF   xDD,F
415E:  BNZ   4168
4160:  MOVLB  0
4162:  CALL   1F04
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
4166:  BRA    4172
4168:  MOVLB  0
416A:  CALL   315C
416E:  MOVFF  01,825
4172:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
4174:  DECFSZ x40,W
4176:  BRA    4190
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
4178:  MOVLB  6
417A:  MOVF   xDD,F
417C:  BNZ   4186
417E:  MOVLB  0
4180:  CALL   1F04
....................          else temp=kbd_getc_slv(); 
4184:  BRA    4190
4186:  MOVLB  0
4188:  CALL   315C
418C:  MOVFF  01,825
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
4190:  MOVLB  6
4192:  MOVF   xC2,F
4194:  BNZ   41B4
4196:  MOVF   xC1,F
4198:  BNZ   41B4
419A:  MOVF   xC0,F
419C:  BNZ   41B4
419E:  MOVF   xBF,W
41A0:  SUBLW  04
41A2:  BNC   41B4
41A4:  MOVLW  01
41A6:  ADDWF  xBF,F
41A8:  BTFSC  FD8.0
41AA:  INCF   xC0,F
41AC:  BTFSC  FD8.2
41AE:  INCF   xC1,F
41B0:  BTFSC  FD8.2
41B2:  INCF   xC2,F
....................   if(mcr_timeout==5) 
41B4:  MOVF   xBF,W
41B6:  SUBLW  05
41B8:  BNZ   420E
41BA:  MOVF   xC0,F
41BC:  BNZ   420E
41BE:  MOVF   xC1,F
41C0:  BNZ   420E
41C2:  MOVF   xC2,F
41C4:  BNZ   420E
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
41C6:  DECFSZ xD5,W
41C8:  BRA    41D0
41CA:  MOVLB  0
41CC:  BRA    3AA4
41CE:  MOVLB  6
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
41D0:  MOVLW  02
41D2:  MOVWF  FEA
41D4:  MOVLW  41
41D6:  MOVWF  FE9
41D8:  CLRF   00
41DA:  MOVLW  03
41DC:  MOVWF  02
41DE:  MOVLW  52
41E0:  MOVWF  01
41E2:  MOVLB  0
41E4:  RCALL  3E82
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
41E6:  MOVLW  05
41E8:  MOVWF  FEA
41EA:  MOVLW  93
41EC:  MOVWF  FE9
41EE:  CLRF   00
41F0:  MOVLW  01
41F2:  MOVWF  02
41F4:  MOVLW  2C
41F6:  MOVWF  01
41F8:  RCALL  3E82
....................       //debug_card(); 
....................       count_reading_error=0; 
41FA:  MOVLB  6
41FC:  CLRF   xD6
....................       mcr_timeout++;   
41FE:  MOVLW  01
4200:  ADDWF  xBF,F
4202:  BTFSC  FD8.0
4204:  INCF   xC0,F
4206:  BTFSC  FD8.2
4208:  INCF   xC1,F
420A:  BTFSC  FD8.2
420C:  INCF   xC2,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
420E:  MOVLB  8
4210:  CLRF   x32
4212:  CLRF   x31
4214:  CLRF   x30
4216:  MOVLW  3C
4218:  MOVWF  x2F
421A:  MOVLB  0
421C:  CALL   33C8
4220:  MOVFF  01,155
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
4224:  MOVLW  02
4226:  MOVLB  8
4228:  MOVWF  x2C
422A:  MOVLW  BC
422C:  MOVWF  x2B
422E:  CLRF   x2E
4230:  MOVFF  155,82D
4234:  MOVLB  0
4236:  CALL   34EC
423A:  MOVFF  02,03
423E:  MOVF   xFC,W
4240:  SUBWF  02,W
4242:  BNC   4252
4244:  BNZ   424C
4246:  MOVF   01,W
4248:  SUBWF  xFB,W
424A:  BC    4252
424C:  INCF   xFB,F
424E:  BTFSC  FD8.2
4250:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
4252:  MOVLW  02
4254:  MOVLB  8
4256:  MOVWF  x2C
4258:  MOVLW  BC
425A:  MOVWF  x2B
425C:  CLRF   x2E
425E:  MOVFF  155,82D
4262:  MOVLB  0
4264:  CALL   34EC
4268:  MOVFF  02,03
426C:  MOVF   01,W
426E:  SUBWF  xFB,W
4270:  BNZ   4318
4272:  MOVF   03,W
4274:  SUBWF  xFC,W
4276:  BNZ   4318
....................   { 
....................       charac_timeout++; 
4278:  INCF   xFB,F
427A:  BTFSC  FD8.2
427C:  INCF   xFC,F
....................       buf=get_countcard(); 
427E:  CALL   3494
4282:  MOVFF  02,824
4286:  MOVFF  01,823
....................       if(buf<countcards) 
428A:  MOVLB  8
428C:  MOVF   x24,W
428E:  SUBLW  03
4290:  BNC   42B8
4292:  BNZ   429A
4294:  MOVF   x23,W
4296:  SUBLW  A1
4298:  BNC   42B8
....................       { 
....................          save_key_new(); 
429A:  MOVLB  0
429C:  BRA    3E9C
....................          buf=buf+1; 
429E:  MOVLW  01
42A0:  MOVLB  8
42A2:  ADDWF  x23,F
42A4:  MOVLW  00
42A6:  ADDWFC x24,F
....................          save_coutcard(buf); 
42A8:  MOVFF  824,827
42AC:  MOVFF  823,826
42B0:  MOVLB  0
42B2:  RCALL  401C
....................       } 
....................          else 
42B4:  BRA    42C8
42B6:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
42B8:  MOVLW  1E
42BA:  MOVWF  FF6
42BC:  MOVLW  43
42BE:  MOVWF  FF7
42C0:  MOVLB  0
42C2:  CALL   16F2
....................             return; 
42C6:  BRA    4318
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
42C8:  MOVLW  2E
42CA:  MOVWF  FF6
42CC:  MOVLW  43
42CE:  MOVWF  FF7
42D0:  CALL   16F2
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
42D4:  MOVLW  3E
42D6:  MOVWF  FF6
42D8:  MOVLW  43
42DA:  MOVWF  FF7
42DC:  MOVLW  14
42DE:  MOVLB  8
42E0:  MOVWF  x43
42E2:  MOVLB  0
42E4:  CALL   160E
42E8:  MOVLW  10
42EA:  MOVWF  FE9
42EC:  MOVFF  824,827
42F0:  MOVFF  823,826
42F4:  RCALL  405E
42F6:  MOVLW  55
42F8:  MOVWF  FF6
42FA:  MOVLW  43
42FC:  MOVWF  FF7
42FE:  MOVLW  03
4300:  MOVLB  8
4302:  MOVWF  x43
4304:  MOVLB  0
4306:  CALL   160E
....................       data_avai=0; 
430A:  MOVLB  6
430C:  CLRF   xD4
....................       enable_getpin=0; 
430E:  MOVLB  1
4310:  CLRF   x40
....................       //dis_getpin; 
....................       output_low(LED); 
4312:  BCF    F92.6
4314:  BCF    F89.6
4316:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
4318:  BCF    FF2.2
431A:  GOTO   006C
.................... void main() 
.................... {  
*
71F6:  CLRF   FF8
71F8:  BCF    FD0.7
71FA:  BSF    07.7
71FC:  CLRF   FEA
71FE:  CLRF   FE9
7200:  BCF    F94.0
7202:  BSF    F8B.0
7204:  CLRF   23
7206:  CLRF   22
7208:  CLRF   21
720A:  MOVLW  96
720C:  MOVWF  20
720E:  CLRF   27
7210:  MOVLW  01
7212:  MOVWF  26
7214:  MOVLW  C3
7216:  MOVWF  25
7218:  MOVLW  0F
721A:  MOVWF  24
721C:  CLRF   xFA
721E:  CLRF   xF9
7220:  SETF   xFC
7222:  SETF   xFB
7224:  MOVLB  1
7226:  CLRF   x3E
7228:  CLRF   x3F
722A:  CLRF   x40
722C:  MOVLW  64
722E:  MOVWF  x41
7230:  CLRF   x42
7232:  CLRF   x43
7234:  CLRF   x44
7236:  CLRF   x55
7238:  CLRF   x5A
723A:  CLRF   xC1
723C:  CLRF   xC2
723E:  MOVLW  0E
7240:  MOVWF  xC4
7242:  MOVLW  01
7244:  MOVWF  xC5
7246:  MOVWF  xC6
7248:  CLRF   xC7
724A:  CLRF   xC8
724C:  CLRF   xC9
724E:  MOVLB  6
7250:  CLRF   xC2
7252:  CLRF   xC1
7254:  CLRF   xC0
7256:  CLRF   xBF
7258:  CLRF   xC3
725A:  CLRF   xC5
725C:  CLRF   xC4
725E:  CLRF   xC7
7260:  CLRF   xC6
7262:  CLRF   xC9
7264:  CLRF   xC8
7266:  CLRF   xCB
7268:  CLRF   xCA
726A:  MOVLW  FD
726C:  MOVWF  xCD
726E:  MOVLW  E8
7270:  MOVWF  xCC
7272:  CLRF   xCF
7274:  CLRF   xCE
7276:  CLRF   xD0
7278:  CLRF   xD1
727A:  CLRF   xD2
727C:  CLRF   xD3
727E:  CLRF   xD4
7280:  CLRF   xD5
7282:  CLRF   xD6
7284:  CLRF   xD7
7286:  CLRF   xD8
7288:  CLRF   xDA
728A:  MOVLW  01
728C:  MOVWF  xD9
728E:  CLRF   xDC
7290:  CLRF   xDB
7292:  CLRF   xDD
7294:  CLRF   xE1
7296:  CLRF   xE0
7298:  CLRF   xDF
729A:  CLRF   xDE
729C:  MOVLW  FF
729E:  MOVLB  F
72A0:  MOVWF  x48
72A2:  BCF    FC2.6
72A4:  BCF    FC2.7
72A6:  MOVF   x49,W
72A8:  ANDLW  E0
72AA:  IORLW  1F
72AC:  MOVWF  x49
72AE:  CLRF   FD2
72B0:  CLRF   FD1
72B2:  CLRF   1A
72B4:  CLRF   1B
72B6:  MOVLW  E8
72B8:  MOVLB  1
72BA:  MOVWF  x1E
72BC:  MOVLW  E9
72BE:  MOVWF  x1F
72C0:  MOVLW  EA
72C2:  MOVWF  x20
72C4:  MOVLW  EB
72C6:  MOVWF  x21
72C8:  MOVLW  ED
72CA:  MOVWF  x22
72CC:  MOVLW  EE
72CE:  MOVWF  x23
72D0:  MOVLW  EF
72D2:  MOVWF  x24
72D4:  MOVLW  F0
72D6:  MOVWF  x25
72D8:  MOVLW  F2
72DA:  MOVWF  x26
72DC:  MOVLW  F3
72DE:  MOVWF  x27
72E0:  MOVLW  F4
72E2:  MOVWF  x28
72E4:  MOVLW  F5
72E6:  MOVWF  x29
72E8:  MOVLW  F7
72EA:  MOVWF  x2A
72EC:  MOVLW  F8
72EE:  MOVWF  x2B
72F0:  MOVLW  F9
72F2:  MOVWF  x2C
72F4:  MOVLW  FA
72F6:  MOVWF  x2D
72F8:  MOVLW  67
72FA:  MOVWF  x2E
72FC:  MOVLW  43
72FE:  MOVWF  x2F
7300:  MOVLW  C3
7302:  MOVWF  x30
7304:  MOVLW  D1
7306:  MOVWF  x31
7308:  MOVLW  51
730A:  MOVWF  x32
730C:  MOVLW  9A
730E:  MOVWF  x33
7310:  MOVLW  B4
7312:  MOVWF  x34
7314:  MOVLW  F2
7316:  MOVWF  x35
7318:  MOVLW  CD
731A:  MOVWF  x36
731C:  MOVLW  9A
731E:  MOVWF  x37
7320:  MOVLW  78
7322:  MOVWF  x38
7324:  MOVLW  AB
7326:  MOVWF  x39
7328:  MOVLW  09
732A:  MOVWF  x3A
732C:  MOVLW  A5
732E:  MOVWF  x3B
7330:  MOVLW  11
7332:  MOVWF  x3C
7334:  MOVLW  BD
7336:  MOVWF  x3D
7338:  CLRF   x56
733A:  BCF    x57.0
733C:  CLRF   x58
733E:  CLRF   x59
7340:  CLRF   x5B
7342:  BCF    x57.1
7344:  CLRF   x5C
7346:  MOVLB  6
7348:  CLRF   xF2
734A:  CLRF   xF3
734C:  CLRF   xF4
734E:  CLRF   xF5
7350:  CLRF   xF6
7352:  CLRF   xF7
7354:  CLRF   xF8
7356:  CLRF   xF9
7358:  CLRF   xFA
735A:  CLRF   xFB
735C:  CLRF   xFE
735E:  MOVLB  7
7360:  CLRF   x00
7362:  MOVLB  6
7364:  CLRF   xFF
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    RPINR1=5; 
7366:  MOVLW  05
7368:  MOVLB  E
736A:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
736C:  MOVLB  0
736E:  SETF   xFC
7370:  SETF   xFB
....................    setup_oscillator(OSC_32MHZ); 
7372:  MOVLW  70
7374:  MOVWF  FD3
7376:  MOVLW  40
7378:  MOVWF  F9B
737A:  MOVF   FD3,W
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
737C:  BCF    FF2.6
737E:  BCF    FF2.7
7380:  BTFSC  FF2.7
7382:  BRA    737E
....................    init_ext_eeprom(); 
7384:  GOTO   442C
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif   
....................    //===================================== 
....................    delay_ms(1000); 
7388:  MOVLW  04
738A:  MOVLB  7
738C:  MOVWF  xB8
738E:  CLRF   19
7390:  BTFSC  FF2.7
7392:  BSF    19.7
7394:  BCF    FF2.7
7396:  MOVLW  FA
7398:  MOVLB  8
739A:  MOVWF  x2C
739C:  MOVLB  0
739E:  CALL   188A
73A2:  BTFSC  19.7
73A4:  BSF    FF2.7
73A6:  MOVLB  7
73A8:  DECFSZ xB8,F
73AA:  BRA    738E
....................    init_password(); 
73AC:  MOVLB  0
73AE:  CALL   4578
....................    //===================================== 
....................     
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
73B2:  MOVLW  19
73B4:  MOVLB  7
73B6:  MOVWF  xB8
73B8:  MOVLB  0
73BA:  CALL   4608
73BE:  MOVFF  03,23
73C2:  MOVFF  02,22
73C6:  MOVFF  01,21
73CA:  MOVFF  00,20
....................    printf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
73CE:  CLRF   FEA
73D0:  MOVLW  01
73D2:  MOVWF  FE9
73D4:  CALL   475E
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
73D8:  MOVLW  1E
73DA:  MOVLB  7
73DC:  MOVWF  xB8
73DE:  MOVLB  0
73E0:  CALL   4608
73E4:  MOVFF  03,27
73E8:  MOVFF  02,26
73EC:  MOVFF  01,25
73F0:  MOVFF  00,24
....................    fprintf(COM2,"booting\n\r"); 
73F4:  MOVLW  5A
73F6:  MOVWF  FF6
73F8:  MOVLW  43
73FA:  MOVWF  FF7
73FC:  CLRF   19
73FE:  BTFSC  FF2.7
7400:  BSF    19.7
7402:  BCF    FF2.7
7404:  CALL   16F2
7408:  BTFSC  19.7
740A:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
740C:  MOVLW  64
740E:  MOVWF  FF6
7410:  MOVLW  43
7412:  MOVWF  FF7
7414:  CLRF   19
7416:  BTFSC  FF2.7
7418:  BSF    19.7
741A:  BCF    FF2.7
741C:  MOVLW  12
741E:  MOVLB  8
7420:  MOVWF  x43
7422:  MOVLB  0
7424:  CALL   160E
7428:  BTFSC  19.7
742A:  BSF    FF2.7
742C:  MOVLW  41
742E:  MOVWF  FE9
7430:  CLRF   19
7432:  BTFSC  FF2.7
7434:  BSF    19.7
7436:  BCF    FF2.7
7438:  MOVFF  27,846
743C:  MOVFF  26,845
7440:  MOVFF  25,844
7444:  MOVFF  24,843
7448:  CALL   2280
744C:  BTFSC  19.7
744E:  BSF    FF2.7
7450:  CLRF   19
7452:  BTFSC  FF2.7
7454:  BSF    19.7
7456:  BCF    FF2.7
7458:  MOVLW  0A
745A:  MOVLB  8
745C:  MOVWF  x4F
745E:  MOVLB  0
7460:  CALL   15C8
7464:  BTFSC  19.7
7466:  BSF    FF2.7
7468:  CLRF   19
746A:  BTFSC  FF2.7
746C:  BSF    19.7
746E:  BCF    FF2.7
7470:  MOVLW  0D
7472:  MOVLB  8
7474:  MOVWF  x4F
7476:  MOVLB  0
7478:  CALL   15C8
747C:  BTFSC  19.7
747E:  BSF    FF2.7
7480:  CLRF   19
7482:  BTFSC  FF2.7
7484:  BSF    19.7
7486:  BCF    FF2.7
....................    countcard=get_countcard(); 
7488:  CALL   3494
748C:  BTFSC  19.7
748E:  BSF    FF2.7
7490:  MOVFF  02,FA
7494:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
7498:  SETF   xFC
749A:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
749C:  MOVLW  C7
749E:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
74A0:  MOVLW  37
74A2:  MOVWF  FCD
74A4:  CLRF   F9A
74A6:  CLRF   19
74A8:  BTFSC  FF2.7
74AA:  BSF    19.7
74AC:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
74AE:  MOVLB  8
74B0:  CLRF   x32
74B2:  CLRF   x31
74B4:  CLRF   x30
74B6:  MOVLW  3C
74B8:  MOVWF  x2F
74BA:  MOVLB  0
74BC:  CALL   33C8
74C0:  BTFSC  19.7
74C2:  BSF    FF2.7
74C4:  MOVFF  01,155
....................    if(delaycharaction==0)delaycharaction=1; 
74C8:  MOVLB  1
74CA:  MOVF   x55,F
74CC:  BNZ   74D2
74CE:  MOVLW  01
74D0:  MOVWF  x55
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
74D2:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
74D4:  BSF    FF0.3
74D6:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
74D8:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
74DA:  MOVLW  C0
74DC:  IORWF  FF2,F
....................   
....................     mcr_timeout=10000; 
74DE:  MOVLB  6
74E0:  CLRF   xC2
74E2:  CLRF   xC1
74E4:  MOVLW  27
74E6:  MOVWF  xC0
74E8:  MOVLW  10
74EA:  MOVWF  xBF
74EC:  CLRF   19
74EE:  BTFSC  FF2.7
74F0:  BSF    19.7
74F2:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
74F4:  MOVLB  8
74F6:  CLRF   x32
74F8:  CLRF   x31
74FA:  CLRF   x30
74FC:  MOVLW  3A
74FE:  MOVWF  x2F
7500:  MOVLB  0
7502:  CALL   33C8
7506:  BTFSC  19.7
7508:  BSF    FF2.7
750A:  MOVFF  01,6DD
750E:  CLRF   19
7510:  BTFSC  FF2.7
7512:  BSF    19.7
7514:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
7516:  MOVLB  8
7518:  CLRF   x32
751A:  CLRF   x31
751C:  CLRF   x30
751E:  MOVLW  3B
7520:  MOVWF  x2F
7522:  MOVLB  0
7524:  CALL   33C8
7528:  BTFSC  19.7
752A:  BSF    FF2.7
752C:  MOVFF  01,6D1
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
7530:  SETF   xFC
7532:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,wide_strobe_nameconsole,console); 
7534:  MOVLB  7
7536:  CLRF   xF1
7538:  CLRF   xF0
753A:  CLRF   xEF
753C:  MOVLW  28
753E:  MOVWF  xEE
7540:  CLRF   xF5
7542:  CLRF   xF4
7544:  CLRF   xF3
7546:  MOVLW  10
7548:  MOVWF  xF2
754A:  MOVLW  06
754C:  MOVWF  xF7
754E:  MOVLW  E2
7550:  MOVWF  xF6
7552:  MOVLB  0
7554:  CALL   4436
....................    set_tris_a(0xff);  
7558:  MOVLW  FF
755A:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
755C:  MOVLW  E0
755E:  MOVLB  F
7560:  MOVWF  x48
7562:  BCF    FC2.6
7564:  BCF    FC2.7
7566:  MOVF   x49,W
7568:  ANDLW  E0
756A:  IORLW  1F
756C:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
756E:  MOVF   FC1,W
7570:  ANDLW  C0
7572:  IORLW  03
7574:  MOVWF  FC1
7576:  BCF    FC1.7
7578:  BSF    FC2.0
757A:  BSF    FC1.6
757C:  BSF    FC2.1
757E:  BTFSC  FC2.1
7580:  BRA    757E
7582:  BCF    FC1.6
7584:  CLRF   19
7586:  BTFSC  FF2.7
7588:  BSF    19.7
758A:  BCF    FF2.7
....................     
....................    type_KB=read_ext_eeprom(kindofKB); 
758C:  MOVLB  8
758E:  CLRF   x32
7590:  CLRF   x31
7592:  CLRF   x30
7594:  MOVLW  3D
7596:  MOVWF  x2F
7598:  MOVLB  0
759A:  CALL   33C8
759E:  BTFSC  19.7
75A0:  BSF    FF2.7
75A2:  MOVFF  01,144
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
75A6:  MOVLB  1
75A8:  MOVF   x44,F
75AA:  BZ    75CA
75AC:  MOVLW  7C
75AE:  MOVWF  FF6
75B0:  MOVLW  43
75B2:  MOVWF  FF7
75B4:  CLRF   19
75B6:  BTFSC  FF2.7
75B8:  BSF    19.7
75BA:  BCF    FF2.7
75BC:  MOVLB  0
75BE:  CALL   16F2
75C2:  BTFSC  19.7
75C4:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
75C6:  BRA    75E4
75C8:  MOVLB  1
75CA:  MOVLW  90
75CC:  MOVWF  FF6
75CE:  MOVLW  43
75D0:  MOVWF  FF7
75D2:  CLRF   19
75D4:  BTFSC  FF2.7
75D6:  BSF    19.7
75D8:  BCF    FF2.7
75DA:  MOVLB  0
75DC:  CALL   16F2
75E0:  BTFSC  19.7
75E2:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
75E4:  MOVLB  6
75E6:  MOVF   xDD,F
75E8:  BNZ   7608
75EA:  MOVLW  A4
75EC:  MOVWF  FF6
75EE:  MOVLW  43
75F0:  MOVWF  FF7
75F2:  CLRF   19
75F4:  BTFSC  FF2.7
75F6:  BSF    19.7
75F8:  BCF    FF2.7
75FA:  MOVLB  0
75FC:  CALL   16F2
7600:  BTFSC  19.7
7602:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
7604:  BRA    7622
7606:  MOVLB  6
7608:  MOVLW  BE
760A:  MOVWF  FF6
760C:  MOVLW  43
760E:  MOVWF  FF7
7610:  CLRF   19
7612:  BTFSC  FF2.7
7614:  BSF    19.7
7616:  BCF    FF2.7
7618:  MOVLB  0
761A:  CALL   16F2
761E:  BTFSC  19.7
7620:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
7622:  MOVLW  01
7624:  MOVWF  FEA
7626:  MOVLW  45
7628:  MOVWF  FE9
762A:  CLRF   00
762C:  CLRF   02
762E:  MOVLW  10
7630:  MOVWF  01
7632:  CALL   3E82
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
7636:  MOVLB  6
7638:  CLRF   xFC
763A:  MOVF   xFC,W
763C:  SUBLW  13
763E:  BNC   7654
....................    { 
....................       password[i] = 0; 
7640:  CLRF   03
7642:  MOVF   xFC,W
7644:  ADDLW  55
7646:  MOVWF  FE9
7648:  MOVLW  00
764A:  ADDWFC 03,W
764C:  MOVWF  FEA
764E:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 1 
7650:  INCF   xFC,F
7652:  BRA    763A
....................    disable_interrupts(GLOBAL); 
7654:  BCF    FF2.6
7656:  BCF    FF2.7
7658:  BTFSC  FF2.7
765A:  BRA    7656
765C:  CLRF   19
765E:  BTFSC  FF2.7
7660:  BSF    19.7
7662:  BCF    FF2.7
....................    save_coutcard(0); 
7664:  MOVLB  8
7666:  CLRF   x27
7668:  CLRF   x26
766A:  MOVLB  0
766C:  CALL   401C
7670:  BTFSC  19.7
7672:  BSF    FF2.7
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
7674:  MOVLW  01
7676:  MOVWF  FEA
7678:  MOVLW  45
767A:  MOVWF  FE9
767C:  MOVLW  00
767E:  CALL   04A4
7682:  TBLRD*-
7684:  TBLRD*+
7686:  MOVF   FF5,W
7688:  MOVWF  FEE
768A:  IORLW  00
768C:  BNZ   7684
....................    memset(crypto_key,0,sizeof(crypto_key));  
768E:  CLRF   FEA
7690:  MOVLW  FD
7692:  MOVWF  FE9
7694:  CLRF   00
7696:  CLRF   02
7698:  MOVLW  21
769A:  MOVWF  01
769C:  CALL   3E82
....................    strcpy(crypto_key,"quang102"); 
76A0:  CLRF   FEA
76A2:  MOVLW  FD
76A4:  MOVWF  FE9
76A6:  MOVLW  00
76A8:  CALL   04BC
76AC:  TBLRD*-
76AE:  TBLRD*+
76B0:  MOVF   FF5,W
76B2:  MOVWF  FEE
76B4:  IORLW  00
76B6:  BNZ   76AE
....................     
....................    save_key_encrypt(); 
76B8:  GOTO   54C8
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
76BC:  MOVLB  7
76BE:  CLRF   xF1
76C0:  MOVLW  01
76C2:  MOVWF  xF0
76C4:  MOVLW  C3
76C6:  MOVWF  xEF
76C8:  MOVLW  0F
76CA:  MOVWF  xEE
76CC:  CLRF   xF5
76CE:  CLRF   xF4
76D0:  CLRF   xF3
76D2:  MOVLW  10
76D4:  MOVWF  xF2
76D6:  MOVLW  07
76D8:  MOVWF  xF7
76DA:  MOVLW  86
76DC:  MOVWF  xF6
76DE:  MOVLB  0
76E0:  CALL   4436
....................    memset(crypto_key,0,sizeof(crypto_key));  
76E4:  CLRF   FEA
76E6:  MOVLW  FD
76E8:  MOVWF  FE9
76EA:  CLRF   00
76EC:  CLRF   02
76EE:  MOVLW  21
76F0:  MOVWF  01
76F2:  CALL   3E82
....................    strcpy(crypto_key,"quang102"); 
76F6:  CLRF   FEA
76F8:  MOVLW  FD
76FA:  MOVWF  FE9
76FC:  MOVLW  00
76FE:  CALL   04BC
7702:  TBLRD*-
7704:  TBLRD*+
7706:  MOVF   FF5,W
7708:  MOVWF  FEE
770A:  IORLW  00
770C:  BNZ   7704
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
770E:  MOVLW  0C
7710:  MOVLB  7
7712:  MOVWF  xB8
7714:  CLRF   19
7716:  BTFSC  FF2.7
7718:  BSF    19.7
771A:  BCF    FF2.7
771C:  MOVLW  FA
771E:  MOVLB  8
7720:  MOVWF  x2C
7722:  MOVLB  0
7724:  CALL   188A
7728:  BTFSC  19.7
772A:  BSF    FF2.7
772C:  MOVLB  7
772E:  DECFSZ xB8,F
7730:  BRA    7714
7732:  CLRF   19
7734:  BTFSC  FF2.7
7736:  BSF    19.7
7738:  BCF    FF2.7
....................     
....................    fprintf(COM2,"\n\r"); 
773A:  MOVLW  0A
773C:  MOVLB  8
773E:  MOVWF  x4F
7740:  MOVLB  0
7742:  CALL   15C8
7746:  BTFSC  19.7
7748:  BSF    FF2.7
774A:  CLRF   19
774C:  BTFSC  FF2.7
774E:  BSF    19.7
7750:  BCF    FF2.7
7752:  MOVLW  0D
7754:  MOVLB  8
7756:  MOVWF  x4F
7758:  MOVLB  0
775A:  CALL   15C8
775E:  BTFSC  19.7
7760:  BSF    FF2.7
....................    fprintf(COM2,"test_data in:\n\r"); 
7762:  MOVLW  D6
7764:  MOVWF  FF6
7766:  MOVLW  43
7768:  MOVWF  FF7
776A:  CLRF   19
776C:  BTFSC  FF2.7
776E:  BSF    19.7
7770:  BCF    FF2.7
7772:  CALL   16F2
7776:  BTFSC  19.7
7778:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
777A:  MOVLB  6
777C:  CLRF   xFC
777E:  MOVF   xFC,W
7780:  SUBLW  0F
7782:  BNC   77AC
7784:  CLRF   03
7786:  MOVF   xFC,W
7788:  ADDLW  86
778A:  MOVWF  FE9
778C:  MOVLW  07
778E:  ADDWFC 03,W
7790:  MOVWF  FEA
7792:  MOVFF  FEF,7B8
7796:  MOVFF  7B8,7CD
779A:  MOVLW  57
779C:  MOVLB  7
779E:  MOVWF  xCE
77A0:  MOVLB  0
77A2:  CALL   5466
77A6:  MOVLB  6
77A8:  INCF   xFC,F
77AA:  BRA    777E
77AC:  CLRF   19
77AE:  BTFSC  FF2.7
77B0:  BSF    19.7
77B2:  BCF    FF2.7
....................    fprintf(COM2,"\n\r"); 
77B4:  MOVLW  0A
77B6:  MOVLB  8
77B8:  MOVWF  x4F
77BA:  MOVLB  0
77BC:  CALL   15C8
77C0:  BTFSC  19.7
77C2:  BSF    FF2.7
77C4:  CLRF   19
77C6:  BTFSC  FF2.7
77C8:  BSF    19.7
77CA:  BCF    FF2.7
77CC:  MOVLW  0D
77CE:  MOVLB  8
77D0:  MOVWF  x4F
77D2:  MOVLB  0
77D4:  CALL   15C8
77D8:  BTFSC  19.7
77DA:  BSF    FF2.7
....................    fprintf(COM2,"test_key in:\n\r"); 
77DC:  MOVLW  E6
77DE:  MOVWF  FF6
77E0:  MOVLW  43
77E2:  MOVWF  FF7
77E4:  CLRF   19
77E6:  BTFSC  FF2.7
77E8:  BSF    19.7
77EA:  BCF    FF2.7
77EC:  CALL   16F2
77F0:  BTFSC  19.7
77F2:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
77F4:  MOVLB  6
77F6:  CLRF   xFC
77F8:  MOVF   xFC,W
77FA:  SUBLW  0F
77FC:  BNC   7826
77FE:  CLRF   03
7800:  MOVF   xFC,W
7802:  ADDLW  FD
7804:  MOVWF  FE9
7806:  MOVLW  00
7808:  ADDWFC 03,W
780A:  MOVWF  FEA
780C:  MOVFF  FEF,7B8
7810:  MOVFF  7B8,7CD
7814:  MOVLW  57
7816:  MOVLB  7
7818:  MOVWF  xCE
781A:  MOVLB  0
781C:  CALL   5466
7820:  MOVLB  6
7822:  INCF   xFC,F
7824:  BRA    77F8
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],1); 
7826:  MOVLW  07
7828:  MOVLB  7
782A:  MOVWF  xCD
782C:  MOVLW  86
782E:  MOVWF  xCC
7830:  CLRF   xCF
7832:  MOVLW  FD
7834:  MOVWF  xCE
7836:  MOVLW  01
7838:  MOVWF  xD0
783A:  MOVLB  0
783C:  CALL   47F2
7840:  CLRF   19
7842:  BTFSC  FF2.7
7844:  BSF    19.7
7846:  BCF    FF2.7
....................    //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................    fprintf(COM2,"\n\r"); 
7848:  MOVLW  0A
784A:  MOVLB  8
784C:  MOVWF  x4F
784E:  MOVLB  0
7850:  CALL   15C8
7854:  BTFSC  19.7
7856:  BSF    FF2.7
7858:  CLRF   19
785A:  BTFSC  FF2.7
785C:  BSF    19.7
785E:  BCF    FF2.7
7860:  MOVLW  0D
7862:  MOVLB  8
7864:  MOVWF  x4F
7866:  MOVLB  0
7868:  CALL   15C8
786C:  BTFSC  19.7
786E:  BSF    FF2.7
....................    fprintf(COM2,"\n\rdecrypted:\n\r"); 
7870:  MOVLW  F6
7872:  MOVWF  FF6
7874:  MOVLW  43
7876:  MOVWF  FF7
7878:  CLRF   19
787A:  BTFSC  FF2.7
787C:  BSF    19.7
787E:  BCF    FF2.7
7880:  CALL   16F2
7884:  BTFSC  19.7
7886:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
7888:  MOVLB  6
788A:  CLRF   xFC
788C:  MOVF   xFC,W
788E:  SUBLW  0F
7890:  BNC   78BA
7892:  CLRF   03
7894:  MOVF   xFC,W
7896:  ADDLW  86
7898:  MOVWF  FE9
789A:  MOVLW  07
789C:  ADDWFC 03,W
789E:  MOVWF  FEA
78A0:  MOVFF  FEF,7B8
78A4:  MOVFF  7B8,7CD
78A8:  MOVLW  57
78AA:  MOVLB  7
78AC:  MOVWF  xCE
78AE:  MOVLB  0
78B0:  CALL   5466
78B4:  MOVLB  6
78B6:  INCF   xFC,F
78B8:  BRA    788C
78BA:  CLRF   19
78BC:  BTFSC  FF2.7
78BE:  BSF    19.7
78C0:  BCF    FF2.7
....................    fprintf(COM2,"\n\r"); 
78C2:  MOVLW  0A
78C4:  MOVLB  8
78C6:  MOVWF  x4F
78C8:  MOVLB  0
78CA:  CALL   15C8
78CE:  BTFSC  19.7
78D0:  BSF    FF2.7
78D2:  CLRF   19
78D4:  BTFSC  FF2.7
78D6:  BSF    19.7
78D8:  BCF    FF2.7
78DA:  MOVLW  0D
78DC:  MOVLB  8
78DE:  MOVWF  x4F
78E0:  MOVLB  0
78E2:  CALL   15C8
78E6:  BTFSC  19.7
78E8:  BSF    FF2.7
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
78EA:  MOVLW  06
78EC:  MOVWF  FF6
78EE:  MOVLW  44
78F0:  MOVWF  FF7
78F2:  CLRF   19
78F4:  BTFSC  FF2.7
78F6:  BSF    19.7
78F8:  BCF    FF2.7
78FA:  CALL   16F2
78FE:  BTFSC  19.7
7900:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
7902:  MOVLB  6
7904:  CLRF   xFC
7906:  MOVF   xFC,W
7908:  SUBLW  0F
790A:  BNC   7934
790C:  CLRF   03
790E:  MOVF   xFC,W
7910:  ADDLW  FD
7912:  MOVWF  FE9
7914:  MOVLW  00
7916:  ADDWFC 03,W
7918:  MOVWF  FEA
791A:  MOVFF  FEF,7B8
791E:  MOVFF  7B8,7CD
7922:  MOVLW  57
7924:  MOVLB  7
7926:  MOVWF  xCE
7928:  MOVLB  0
792A:  CALL   5466
792E:  MOVLB  6
7930:  INCF   xFC,F
7932:  BRA    7906
....................    while(1); 
7934:  BRA    7934
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
7936:  MOVLB  7
7938:  CLRF   xF1
793A:  CLRF   xF0
793C:  CLRF   xEF
793E:  CLRF   xEE
7940:  CLRF   xF5
7942:  CLRF   xF4
7944:  CLRF   xF3
7946:  MOVLW  14
7948:  MOVWF  xF2
794A:  CLRF   xF7
794C:  MOVLW  55
794E:  MOVWF  xF6
7950:  MOVLB  0
7952:  CALL   4436
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
7956:  MOVLB  6
7958:  MOVF   xD7,F
795A:  BNZ   7A06
....................       { 
....................          fprintf(COM2,"password:"); 
795C:  MOVLW  16
795E:  MOVWF  FF6
7960:  MOVLW  44
7962:  MOVWF  FF7
7964:  CLRF   19
7966:  BTFSC  FF2.7
7968:  BSF    19.7
796A:  BCF    FF2.7
796C:  MOVLB  0
796E:  CALL   16F2
7972:  BTFSC  19.7
7974:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
7976:  MOVLW  02
7978:  MOVLB  7
797A:  MOVWF  xEE
797C:  MOVLW  14
797E:  MOVWF  xEF
7980:  MOVLW  01
7982:  MOVWF  xF1
7984:  MOVLW  5D
7986:  MOVWF  xF0
7988:  MOVLB  0
798A:  CALL   576A
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
798E:  MOVLB  7
7990:  CLRF   xF1
7992:  CLRF   xF0
7994:  CLRF   xEF
7996:  CLRF   xEE
7998:  CLRF   xF5
799A:  CLRF   xF4
799C:  CLRF   xF3
799E:  MOVLW  14
79A0:  MOVWF  xF2
79A2:  CLRF   xF7
79A4:  MOVLW  55
79A6:  MOVWF  xF6
79A8:  MOVLB  0
79AA:  CALL   4436
....................          if(!stringcomp(buffer_uart,password)) 
79AE:  MOVLW  01
79B0:  MOVLB  7
79B2:  MOVWF  xEF
79B4:  MOVLW  5D
79B6:  MOVWF  xEE
79B8:  CLRF   xF1
79BA:  MOVLW  55
79BC:  MOVWF  xF0
79BE:  MOVLB  0
79C0:  CALL   58A2
79C4:  MOVF   01,F
79C6:  BNZ   79EA
....................          { 
....................             mode=LOGON; 
79C8:  MOVLW  01
79CA:  MOVLB  6
79CC:  MOVWF  xD7
....................             fprintf(COM2," OK\n\r"); 
79CE:  MOVLW  20
79D0:  MOVWF  FF6
79D2:  MOVLW  44
79D4:  MOVWF  FF7
79D6:  CLRF   19
79D8:  BTFSC  FF2.7
79DA:  BSF    19.7
79DC:  BCF    FF2.7
79DE:  MOVLB  0
79E0:  CALL   16F2
79E4:  BTFSC  19.7
79E6:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
79E8:  BRA    7A02
79EA:  MOVLW  26
79EC:  MOVWF  FF6
79EE:  MOVLW  44
79F0:  MOVWF  FF7
79F2:  CLRF   19
79F4:  BTFSC  FF2.7
79F6:  BSF    19.7
79F8:  BCF    FF2.7
79FA:  CALL   16F2
79FE:  BTFSC  19.7
7A00:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
7A02:  BRA    7A10
7A04:  MOVLB  6
7A06:  DECFSZ xD7,W
7A08:  BRA    7A12
7A0A:  MOVLB  0
7A0C:  GOTO   5E74
7A10:  MOVLB  6
....................    } 
7A12:  BRA    7958
.................... } 
7A14:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

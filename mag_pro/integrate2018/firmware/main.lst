CCS PCH C Compiler, Version 4.140, 33034               25-Jul-18 22:16

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   33506 bytes (51%)
                           Largest free fragment is 32018
               RAM used:   1983 (53%) at main() level
                           2369 (63%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   7CE8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   5A0C
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1BEE
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0686:  MOVLW  02
0688:  MOVLB  8
068A:  SUBWF  x4E,F
068C:  BNC   06A6
068E:  MOVLW  08
0690:  MOVWF  FEA
0692:  MOVLW  4E
0694:  MOVWF  FE9
0696:  MOVF   FEF,W
0698:  BZ    06A6
069A:  BRA    06A2
069C:  BRA    069E
069E:  BRA    06A0
06A0:  NOP   
06A2:  DECFSZ FEF,F
06A4:  BRA    069C
06A6:  MOVLB  0
06A8:  GOTO   1BFE (RETURN)
*
18C6:  MOVLW  08
18C8:  MOVWF  FEA
18CA:  MOVLW  56
18CC:  MOVWF  FE9
18CE:  MOVF   FEF,W
18D0:  BZ    18EC
18D2:  MOVLW  0A
18D4:  MOVWF  01
18D6:  CLRF   00
18D8:  DECFSZ 00,F
18DA:  BRA    18D8
18DC:  DECFSZ 01,F
18DE:  BRA    18D6
18E0:  MOVLW  5F
18E2:  MOVWF  00
18E4:  DECFSZ 00,F
18E6:  BRA    18E4
18E8:  DECFSZ FEF,F
18EA:  BRA    18D2
18EC:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
1604:  BCF    F94.0
1606:  BCF    F8B.0
1608:  MOVLW  08
160A:  MOVWF  01
160C:  BRA    160E
160E:  NOP   
1610:  BSF    01.7
1612:  BRA    1634
1614:  BCF    01.7
1616:  MOVLB  9
1618:  RRCF   x0C,F
161A:  MOVLB  0
161C:  BTFSC  FD8.0
161E:  BSF    F8B.0
1620:  BTFSS  FD8.0
1622:  BCF    F8B.0
1624:  BSF    01.6
1626:  BRA    1634
1628:  BCF    01.6
162A:  DECFSZ 01,F
162C:  BRA    1616
162E:  BRA    1630
1630:  NOP   
1632:  BSF    F8B.0
1634:  MOVLW  10
1636:  MOVWF  FE9
1638:  DECFSZ FE9,F
163A:  BRA    1638
163C:  BRA    163E
163E:  NOP   
1640:  BTFSC  01.7
1642:  BRA    1614
1644:  BTFSC  01.6
1646:  BRA    1628
1648:  RETURN 0
*
5F64:  BSF    F94.1
5F66:  BTFSC  F82.1
5F68:  BRA    5F66
5F6A:  MOVLW  08
5F6C:  MOVWF  00
5F6E:  MOVLB  7
5F70:  CLRF   xFC
5F72:  BSF    00.7
5F74:  BRA    5F96
5F76:  BCF    00.7
5F78:  BRA    5F96
5F7A:  MOVFF  7FC,02
5F7E:  BCF    FD8.0
5F80:  BTFSC  F82.1
5F82:  BSF    FD8.0
5F84:  RRCF   02,F
5F86:  BSF    00.6
5F88:  BRA    5F96
5F8A:  BCF    00.6
5F8C:  DECFSZ 00,F
5F8E:  BRA    5F7E
5F90:  MOVFF  02,01
5F94:  BRA    5FAE
5F96:  MOVLW  10
5F98:  BTFSC  00.7
5F9A:  MOVLW  04
5F9C:  MOVWF  01
5F9E:  DECFSZ 01,F
5FA0:  BRA    5F9E
5FA2:  BRA    5FA4
5FA4:  BTFSC  00.7
5FA6:  BRA    5F76
5FA8:  BTFSC  00.6
5FAA:  BRA    5F8A
5FAC:  BRA    5F7E
5FAE:  MOVLB  0
5FB0:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3370:  MOVLW  08
3372:  MOVWF  01
3374:  MOVLW  0A
3376:  MOVWF  00
3378:  DECFSZ 00,F
337A:  BRA    3378
337C:  BCF    F8B.3
337E:  BCF    F94.3
3380:  MOVLW  0B
3382:  MOVWF  00
3384:  DECFSZ 00,F
3386:  BRA    3384
3388:  MOVLB  9
338A:  RLCF   x23,F
338C:  BCF    F8B.4
338E:  BTFSC  FD8.0
3390:  BSF    F94.4
3392:  BTFSS  FD8.0
3394:  BCF    F94.4
3396:  BSF    F94.3
3398:  BTFSS  F82.3
339A:  BRA    3398
339C:  DECFSZ 01,F
339E:  BRA    33A2
33A0:  BRA    33A6
33A2:  MOVLB  0
33A4:  BRA    3374
33A6:  MOVLW  0A
33A8:  MOVWF  00
33AA:  DECFSZ 00,F
33AC:  BRA    33AA
33AE:  BCF    F8B.3
33B0:  BCF    F94.3
33B2:  NOP   
33B4:  BSF    F94.4
33B6:  MOVLW  0B
33B8:  MOVWF  00
33BA:  DECFSZ 00,F
33BC:  BRA    33BA
33BE:  MOVLW  0B
33C0:  MOVWF  00
33C2:  DECFSZ 00,F
33C4:  BRA    33C2
33C6:  BSF    F94.3
33C8:  BTFSS  F82.3
33CA:  BRA    33C8
33CC:  CLRF   01
33CE:  MOVLW  0B
33D0:  MOVWF  00
33D2:  DECFSZ 00,F
33D4:  BRA    33D2
33D6:  BTFSC  F82.4
33D8:  BSF    01.0
33DA:  BCF    F8B.3
33DC:  BCF    F94.3
33DE:  BCF    F8B.4
33E0:  BCF    F94.4
33E2:  MOVLB  0
33E4:  RETURN 0
33E6:  MOVLW  08
33E8:  MOVLB  9
33EA:  MOVWF  x1F
33EC:  MOVFF  00,920
33F0:  BSF    F94.4
33F2:  MOVLW  0B
33F4:  MOVWF  00
33F6:  DECFSZ 00,F
33F8:  BRA    33F6
33FA:  BSF    F94.3
33FC:  BTFSS  F82.3
33FE:  BRA    33FC
3400:  BTFSC  F82.4
3402:  BSF    FD8.0
3404:  BTFSS  F82.4
3406:  BCF    FD8.0
3408:  RLCF   01,F
340A:  MOVLW  0A
340C:  MOVWF  00
340E:  DECFSZ 00,F
3410:  BRA    340E
3412:  BCF    F94.3
3414:  BCF    F8B.3
3416:  DECFSZ x1F,F
3418:  BRA    33F0
341A:  BSF    F94.4
341C:  MOVLW  0B
341E:  MOVWF  00
3420:  DECFSZ 00,F
3422:  BRA    3420
3424:  BCF    F8B.4
3426:  MOVF   x20,W
3428:  BTFSS  FD8.2
342A:  BCF    F94.4
342C:  NOP   
342E:  BSF    F94.3
3430:  BTFSS  F82.3
3432:  BRA    3430
3434:  MOVLW  0A
3436:  MOVWF  00
3438:  DECFSZ 00,F
343A:  BRA    3438
343C:  BCF    F8B.3
343E:  BCF    F94.3
3440:  MOVLW  0B
3442:  MOVWF  00
3444:  DECFSZ 00,F
3446:  BRA    3444
3448:  BCF    F8B.4
344A:  BCF    F94.4
344C:  MOVLB  0
344E:  RETURN 0
....................  
.................... #define ptr_start                       150 
.................... #define EEPROM_SIZE_endofkey            131071 
.................... #define EEPROM_SIZE_stofkey             115470 
.................... #define EEPROM_KEY_ST                   EEPROM_SIZE_stofkey+1 
.................... //=============================== 
....................  
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5D16:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
5D18:  BSF    F94.4
....................    port_b_pullups(0xff); 
5D1A:  BCF    FF1.7
.................... } 
5D1C:  GOTO   7E80 (RETURN)
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3A6C:  MOVLB  9
3A6E:  MOVF   x16,F
3A70:  BNZ   3A78
3A72:  MOVF   x15,W
3A74:  SUBLW  00
3A76:  BC    3A7E
3A78:  MOVLW  A8
3A7A:  MOVWF  x19
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3A7C:  BRA    3A82
3A7E:  MOVLW  A0
3A80:  MOVWF  x19
....................  
....................    i2c_start(); 
3A82:  BSF    F94.4
3A84:  MOVLW  0A
3A86:  MOVWF  00
3A88:  DECFSZ 00,F
3A8A:  BRA    3A88
3A8C:  BSF    F94.3
3A8E:  MOVLW  0B
3A90:  MOVWF  00
3A92:  DECFSZ 00,F
3A94:  BRA    3A92
3A96:  BCF    F8B.4
3A98:  BCF    F94.4
3A9A:  MOVLW  0A
3A9C:  MOVWF  00
3A9E:  DECFSZ 00,F
3AA0:  BRA    3A9E
3AA2:  BCF    F8B.3
3AA4:  BCF    F94.3
....................    i2c_write(command); 
3AA6:  MOVFF  919,923
3AAA:  MOVLB  0
3AAC:  RCALL  3370
....................    i2c_write(address>>8); 
3AAE:  MOVFF  914,91B
3AB2:  MOVFF  915,91C
3AB6:  MOVFF  916,91D
3ABA:  MOVLB  9
3ABC:  CLRF   x1E
3ABE:  MOVFF  914,923
3AC2:  MOVLB  0
3AC4:  RCALL  3370
....................    i2c_write(address); 
3AC6:  MOVFF  913,923
3ACA:  RCALL  3370
....................    i2c_write(data); 
3ACC:  MOVFF  917,923
3AD0:  RCALL  3370
....................  
....................    i2c_stop(); 
3AD2:  BCF    F94.4
3AD4:  NOP   
3AD6:  BSF    F94.3
3AD8:  BTFSS  F82.3
3ADA:  BRA    3AD8
3ADC:  MOVLW  0A
3ADE:  MOVWF  00
3AE0:  DECFSZ 00,F
3AE2:  BRA    3AE0
3AE4:  BRA    3AE6
3AE6:  NOP   
3AE8:  BSF    F94.4
3AEA:  MOVLW  0A
3AEC:  MOVWF  00
3AEE:  DECFSZ 00,F
3AF0:  BRA    3AEE
....................    i2c_start(); 
3AF2:  BSF    F94.4
3AF4:  MOVLW  0A
3AF6:  MOVWF  00
3AF8:  DECFSZ 00,F
3AFA:  BRA    3AF8
3AFC:  BSF    F94.3
3AFE:  MOVLW  0B
3B00:  MOVWF  00
3B02:  DECFSZ 00,F
3B04:  BRA    3B02
3B06:  BCF    F8B.4
3B08:  BCF    F94.4
3B0A:  MOVLW  0A
3B0C:  MOVWF  00
3B0E:  DECFSZ 00,F
3B10:  BRA    3B0E
3B12:  BCF    F8B.3
3B14:  BCF    F94.3
....................    status=i2c_write(command); 
3B16:  MOVFF  919,923
3B1A:  RCALL  3370
3B1C:  MOVF   01,W
3B1E:  MOVLB  9
3B20:  BCF    x18.0
3B22:  BTFSC  01.0
3B24:  BSF    x18.0
....................    while(status==1) 
....................    { 
3B26:  BTFSS  x18.0
3B28:  BRA    3B66
....................       i2c_start(); 
3B2A:  BSF    F94.4
3B2C:  MOVLW  0A
3B2E:  MOVWF  00
3B30:  DECFSZ 00,F
3B32:  BRA    3B30
3B34:  BSF    F94.3
3B36:  MOVLW  0B
3B38:  MOVWF  00
3B3A:  DECFSZ 00,F
3B3C:  BRA    3B3A
3B3E:  BTFSS  F82.3
3B40:  BRA    3B3E
3B42:  BCF    F8B.4
3B44:  BCF    F94.4
3B46:  MOVLW  0A
3B48:  MOVWF  00
3B4A:  DECFSZ 00,F
3B4C:  BRA    3B4A
3B4E:  BCF    F8B.3
3B50:  BCF    F94.3
....................       status=i2c_write(command); 
3B52:  MOVFF  919,923
3B56:  MOVLB  0
3B58:  RCALL  3370
3B5A:  MOVF   01,W
3B5C:  MOVLB  9
3B5E:  BCF    x18.0
3B60:  BTFSC  01.0
3B62:  BSF    x18.0
....................    } 
3B64:  BRA    3B26
....................    //delay_us(100); 
.................... } 
3B66:  MOVLB  0
3B68:  RETURN 0
....................  
....................  
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3450:  MOVLB  9
3452:  MOVF   x1B,F
3454:  BNZ   345C
3456:  MOVF   x1A,W
3458:  SUBLW  00
345A:  BC    3462
345C:  MOVLW  A8
345E:  MOVWF  x1D
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3460:  BRA    3466
3462:  MOVLW  A0
3464:  MOVWF  x1D
....................  
....................    i2c_start(); 
3466:  BSF    F94.4
3468:  MOVLW  0A
346A:  MOVWF  00
346C:  DECFSZ 00,F
346E:  BRA    346C
3470:  BSF    F94.3
3472:  MOVLW  0B
3474:  MOVWF  00
3476:  DECFSZ 00,F
3478:  BRA    3476
347A:  BTFSS  F82.3
347C:  BRA    347A
347E:  BCF    F8B.4
3480:  BCF    F94.4
3482:  MOVLW  0A
3484:  MOVWF  00
3486:  DECFSZ 00,F
3488:  BRA    3486
348A:  BCF    F8B.3
348C:  BCF    F94.3
....................    i2c_write(command); 
348E:  MOVFF  91D,923
3492:  MOVLB  0
3494:  RCALL  3370
....................    i2c_write(address>>8); 
3496:  MOVFF  919,91F
349A:  MOVFF  91A,920
349E:  MOVFF  91B,921
34A2:  MOVLB  9
34A4:  CLRF   x22
34A6:  MOVFF  919,923
34AA:  MOVLB  0
34AC:  RCALL  3370
....................    i2c_write(address); 
34AE:  MOVFF  918,923
34B2:  RCALL  3370
....................    i2c_start(); 
34B4:  BSF    F94.4
34B6:  MOVLW  0A
34B8:  MOVWF  00
34BA:  DECFSZ 00,F
34BC:  BRA    34BA
34BE:  BSF    F94.3
34C0:  MOVLW  0B
34C2:  MOVWF  00
34C4:  DECFSZ 00,F
34C6:  BRA    34C4
34C8:  BTFSS  F82.3
34CA:  BRA    34C8
34CC:  BCF    F8B.4
34CE:  BCF    F94.4
34D0:  MOVLW  0A
34D2:  MOVWF  00
34D4:  DECFSZ 00,F
34D6:  BRA    34D4
34D8:  BCF    F8B.3
34DA:  BCF    F94.3
....................    i2c_write(command+1); 
34DC:  MOVLW  01
34DE:  MOVLB  9
34E0:  ADDWF  x1D,W
34E2:  MOVWF  x1E
34E4:  MOVWF  x23
34E6:  MOVLB  0
34E8:  RCALL  3370
....................    data=i2c_read(0); 
34EA:  CLRF   00
34EC:  RCALL  33E6
34EE:  MOVFF  01,91C
....................    i2c_stop(); 
34F2:  BCF    F94.4
34F4:  NOP   
34F6:  BSF    F94.3
34F8:  BTFSS  F82.3
34FA:  BRA    34F8
34FC:  MOVLW  0A
34FE:  MOVWF  00
3500:  DECFSZ 00,F
3502:  BRA    3500
3504:  BRA    3506
3506:  NOP   
3508:  BSF    F94.4
350A:  MOVLW  0A
350C:  MOVWF  00
350E:  DECFSZ 00,F
3510:  BRA    350E
....................    return(data); 
3512:  MOVLB  9
3514:  MOVFF  91C,01
.................... } 
3518:  MOVLB  0
351A:  RETURN 0
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr            0 
.................... #define strobe_ptrcard_addr         25     // 4 bytes 
.................... #define strobe_ptrcard_key          30     // 4 bytes 
.................... #define strobe_count_card           36     // 2 bytes 
.................... #define strobe_nameconsole          40     // 16 bytes  
.................... #define strobe_Master_SLV           58     // 1 byte 
.................... #define strobe_debugmode            59     // 1 byte 
.................... #define strobe_delaytime            60     // 1 byte 
.................... #define kindofKB                    61     // 1 byte 
.................... #define crypto_en                   62     // 1 byte 
.................... #define strobe_crypto_key           63     // 32 byte 
....................  
....................  
.................... #define wide_strobe_nameconsole     16  
.................... //============================================================== 
.................... #define numdata                  124    // 5+79+40=124 
.................... #define numdataofonecard         128    //  
.................... #define countcards               930    //43590/124 
....................  
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdataofonecard]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... #if 0 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... } 
.................... #endif 
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4EF6:  MOVLB  9
4EF8:  CLRF   x0D
4EFA:  CLRF   x0C
4EFC:  CLRF   x0B
4EFE:  CLRF   x0A
4F00:  MOVF   x0D,W
4F02:  SUBWF  x07,W
4F04:  BNC   4F7E
4F06:  BNZ   4F1E
4F08:  MOVF   x0C,W
4F0A:  SUBWF  x06,W
4F0C:  BNC   4F7E
4F0E:  BNZ   4F1E
4F10:  MOVF   x0B,W
4F12:  SUBWF  x05,W
4F14:  BNC   4F7E
4F16:  BNZ   4F1E
4F18:  MOVF   x04,W
4F1A:  SUBWF  x0A,W
4F1C:  BC    4F7E
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4F1E:  MOVF   x0A,W
4F20:  ADDWF  x00,W
4F22:  MOVWF  x0E
4F24:  MOVF   x0B,W
4F26:  ADDWFC x01,W
4F28:  MOVWF  x0F
4F2A:  MOVF   x0C,W
4F2C:  ADDWFC x02,W
4F2E:  MOVWF  x10
4F30:  MOVF   x0D,W
4F32:  ADDWFC x03,W
4F34:  MOVWF  x11
4F36:  MOVF   x08,W
4F38:  ADDWF  x0A,W
4F3A:  MOVWF  FE9
4F3C:  MOVF   x09,W
4F3E:  ADDWFC x0B,W
4F40:  MOVWF  FEA
4F42:  MOVFF  FEF,912
4F46:  MOVFF  911,916
4F4A:  MOVFF  910,915
4F4E:  MOVFF  90F,914
4F52:  MOVFF  90E,913
4F56:  MOVFF  912,917
4F5A:  MOVLB  0
4F5C:  CALL   3A6C
....................       delay_us(10); 
4F60:  MOVLW  1A
4F62:  MOVWF  00
4F64:  DECFSZ 00,F
4F66:  BRA    4F64
4F68:  NOP   
....................    } 
4F6A:  MOVLW  01
4F6C:  MOVLB  9
4F6E:  ADDWF  x0A,F
4F70:  BTFSC  FD8.0
4F72:  INCF   x0B,F
4F74:  BTFSC  FD8.2
4F76:  INCF   x0C,F
4F78:  BTFSC  FD8.2
4F7A:  INCF   x0D,F
4F7C:  BRA    4F00
....................    return 1; 
4F7E:  MOVLW  01
4F80:  MOVWF  01
.................... } 
4F82:  MOVLB  0
4F84:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len,unsigned int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4004:  MOVLB  9
4006:  CLRF   x11
4008:  CLRF   x10
400A:  CLRF   x0F
400C:  CLRF   x0E
400E:  MOVF   x11,W
4010:  SUBWF  x0B,W
4012:  BNC   4094
4014:  BNZ   402C
4016:  MOVF   x10,W
4018:  SUBWF  x0A,W
401A:  BNC   4094
401C:  BNZ   402C
401E:  MOVF   x0F,W
4020:  SUBWF  x09,W
4022:  BNC   4094
4024:  BNZ   402C
4026:  MOVF   x08,W
4028:  SUBWF  x0E,W
402A:  BC    4094
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
402C:  MOVF   x0C,W
402E:  ADDWF  x0E,W
4030:  MOVWF  01
4032:  MOVF   x0D,W
4034:  ADDWFC x0F,W
4036:  MOVWF  03
4038:  MOVFF  01,912
403C:  MOVWF  x13
403E:  MOVF   x0E,W
4040:  ADDWF  x04,W
4042:  MOVWF  x14
4044:  MOVF   x0F,W
4046:  ADDWFC x05,W
4048:  MOVWF  x15
404A:  MOVF   x10,W
404C:  ADDWFC x06,W
404E:  MOVWF  x16
4050:  MOVF   x11,W
4052:  ADDWFC x07,W
4054:  MOVWF  x17
4056:  MOVWF  x1B
4058:  MOVFF  916,91A
405C:  MOVFF  915,919
4060:  MOVFF  914,918
4064:  MOVLB  0
4066:  CALL   3450
406A:  MOVFF  913,FEA
406E:  MOVFF  912,FE9
4072:  MOVFF  01,FEF
....................       delay_us(10); 
4076:  MOVLW  1A
4078:  MOVWF  00
407A:  DECFSZ 00,F
407C:  BRA    407A
407E:  NOP   
....................    } 
4080:  MOVLW  01
4082:  MOVLB  9
4084:  ADDWF  x0E,F
4086:  BTFSC  FD8.0
4088:  INCF   x0F,F
408A:  BTFSC  FD8.2
408C:  INCF   x10,F
408E:  BTFSC  FD8.2
4090:  INCF   x11,F
4092:  BRA    400E
.................... } 
4094:  MOVLB  0
4096:  RETURN 0
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
5DDC:  MOVLB  7
5DDE:  CLRF   xC1
5DE0:  CLRF   xC0
5DE2:  CLRF   xBF
5DE4:  CLRF   xBE
5DE6:  CLRF   xC5
5DE8:  CLRF   xC4
5DEA:  CLRF   xC3
5DEC:  CLRF   xC2
5DEE:  CLRF   xC9
5DF0:  CLRF   xC8
5DF2:  CLRF   xC7
5DF4:  CLRF   xC6
5DF6:  CLRF   xCD
5DF8:  CLRF   xCC
5DFA:  CLRF   xCB
5DFC:  CLRF   xCA
5DFE:  CLRF   xD1
5E00:  CLRF   xD0
5E02:  CLRF   xCF
5E04:  CLRF   xCE
5E06:  CLRF   19
5E08:  BTFSC  FF2.7
5E0A:  BSF    19.7
5E0C:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
5E0E:  MOVLB  9
5E10:  CLRF   x1B
5E12:  CLRF   x1A
5E14:  CLRF   x19
5E16:  MOVFF  7BD,918
5E1A:  MOVLB  0
5E1C:  CALL   3450
5E20:  BTFSC  19.7
5E22:  BSF    FF2.7
5E24:  MOVLB  7
5E26:  MOVFF  01,7C2
5E2A:  CLRF   xC3
5E2C:  CLRF   xC4
5E2E:  CLRF   xC5
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
5E30:  MOVLW  01
5E32:  ADDWF  xBD,W
5E34:  MOVWF  xD2
5E36:  CLRF   19
5E38:  BTFSC  FF2.7
5E3A:  BSF    19.7
5E3C:  BCF    FF2.7
5E3E:  MOVLB  9
5E40:  CLRF   x1B
5E42:  CLRF   x1A
5E44:  CLRF   x19
5E46:  MOVWF  x18
5E48:  MOVLB  0
5E4A:  CALL   3450
5E4E:  BTFSC  19.7
5E50:  BSF    FF2.7
5E52:  MOVLB  7
5E54:  CLRF   xC9
5E56:  CLRF   xC8
5E58:  CLRF   xC7
5E5A:  MOVFF  01,7C6
....................    temp2<<=8; 
5E5E:  MOVFF  7C8,7C9
5E62:  MOVFF  7C7,7C8
5E66:  MOVFF  7C6,7C7
5E6A:  CLRF   xC6
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
5E6C:  MOVLW  02
5E6E:  ADDWF  xBD,W
5E70:  MOVWF  xD2
5E72:  CLRF   19
5E74:  BTFSC  FF2.7
5E76:  BSF    19.7
5E78:  BCF    FF2.7
5E7A:  MOVLB  9
5E7C:  CLRF   x1B
5E7E:  CLRF   x1A
5E80:  CLRF   x19
5E82:  MOVWF  x18
5E84:  MOVLB  0
5E86:  CALL   3450
5E8A:  BTFSC  19.7
5E8C:  BSF    FF2.7
5E8E:  MOVLB  7
5E90:  CLRF   xCD
5E92:  CLRF   xCC
5E94:  CLRF   xCB
5E96:  MOVFF  01,7CA
....................    temp3<<=16; 
5E9A:  MOVFF  7CB,7CD
5E9E:  MOVFF  7CA,7CC
5EA2:  CLRF   xCA
5EA4:  CLRF   xCB
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
5EA6:  MOVLW  03
5EA8:  ADDWF  xBD,W
5EAA:  MOVWF  xD2
5EAC:  CLRF   19
5EAE:  BTFSC  FF2.7
5EB0:  BSF    19.7
5EB2:  BCF    FF2.7
5EB4:  MOVLB  9
5EB6:  CLRF   x1B
5EB8:  CLRF   x1A
5EBA:  CLRF   x19
5EBC:  MOVWF  x18
5EBE:  MOVLB  0
5EC0:  CALL   3450
5EC4:  BTFSC  19.7
5EC6:  BSF    FF2.7
5EC8:  MOVLB  7
5ECA:  CLRF   xD1
5ECC:  CLRF   xD0
5ECE:  CLRF   xCF
5ED0:  MOVFF  01,7CE
....................    temp4<<=24; 
5ED4:  MOVFF  7CE,7D1
5ED8:  CLRF   xCE
5EDA:  CLRF   xCF
5EDC:  CLRF   xD0
....................    buffer = temp4|temp3|temp2|temp1; 
5EDE:  MOVF   xCE,W
5EE0:  IORWF  xCA,W
5EE2:  MOVWF  xD2
5EE4:  MOVF   xCF,W
5EE6:  IORWF  xCB,W
5EE8:  MOVWF  xD3
5EEA:  MOVF   xD0,W
5EEC:  IORWF  xCC,W
5EEE:  MOVWF  xD4
5EF0:  MOVF   xD1,W
5EF2:  IORWF  xCD,W
5EF4:  MOVWF  xD5
5EF6:  MOVF   xC6,W
5EF8:  IORWF  xD2,F
5EFA:  MOVF   xC7,W
5EFC:  IORWF  xD3,F
5EFE:  MOVF   xC8,W
5F00:  IORWF  xD4,F
5F02:  MOVF   xC9,W
5F04:  IORWF  xD5,F
5F06:  MOVF   xD2,W
5F08:  IORWF  xC2,W
5F0A:  MOVWF  xBE
5F0C:  MOVF   xD3,W
5F0E:  IORWF  xC3,W
5F10:  MOVWF  xBF
5F12:  MOVF   xD4,W
5F14:  IORWF  xC4,W
5F16:  MOVWF  xC0
5F18:  MOVF   xD5,W
5F1A:  IORWF  xC5,W
5F1C:  MOVWF  xC1
....................    return(buffer); 
5F1E:  MOVFF  7BE,00
5F22:  MOVFF  7BF,01
5F26:  MOVFF  7C0,02
5F2A:  MOVFF  7C1,03
.................... } 
5F2E:  MOVLB  0
5F30:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3B6A:  MOVLB  8
3B6C:  CLRF   xFF
3B6E:  CLRF   xFE
3B70:  CLRF   xFD
3B72:  CLRF   xFC
3B74:  MOVLB  9
3B76:  CLRF   x00
3B78:  CLRF   x01
3B7A:  CLRF   x02
3B7C:  CLRF   x03
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3B7E:  MOVFF  8FA,8FF
3B82:  MOVFF  8F9,8FE
3B86:  MOVFF  8F8,8FD
3B8A:  MOVFF  8F7,8FC
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3B8E:  MOVFF  8FC,900
3B92:  MOVLB  9
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3B94:  MOVFF  8FD,901
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3B98:  MOVFF  8FE,902
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3B9C:  MOVFF  8FF,903
....................    write_ext_eeprom((addr+0),temp1); 
3BA0:  CLRF   x16
3BA2:  CLRF   x15
3BA4:  CLRF   x14
3BA6:  MOVFF  8FB,913
3BAA:  MOVFF  900,917
3BAE:  MOVLB  0
3BB0:  RCALL  3A6C
....................    write_ext_eeprom((addr+1),temp2); 
3BB2:  MOVLW  01
3BB4:  MOVLB  8
3BB6:  ADDWF  xFB,W
3BB8:  MOVLB  9
3BBA:  MOVWF  x04
3BBC:  CLRF   x16
3BBE:  CLRF   x15
3BC0:  CLRF   x14
3BC2:  MOVWF  x13
3BC4:  MOVFF  901,917
3BC8:  MOVLB  0
3BCA:  RCALL  3A6C
....................    write_ext_eeprom((addr+2),temp3); 
3BCC:  MOVLW  02
3BCE:  MOVLB  8
3BD0:  ADDWF  xFB,W
3BD2:  MOVLB  9
3BD4:  MOVWF  x04
3BD6:  CLRF   x16
3BD8:  CLRF   x15
3BDA:  CLRF   x14
3BDC:  MOVWF  x13
3BDE:  MOVFF  902,917
3BE2:  MOVLB  0
3BE4:  RCALL  3A6C
....................    write_ext_eeprom((addr+3),temp4); 
3BE6:  MOVLW  03
3BE8:  MOVLB  8
3BEA:  ADDWF  xFB,W
3BEC:  MOVLB  9
3BEE:  MOVWF  x04
3BF0:  CLRF   x16
3BF2:  CLRF   x15
3BF4:  CLRF   x14
3BF6:  MOVWF  x13
3BF8:  MOVFF  903,917
3BFC:  MOVLB  0
3BFE:  RCALL  3A6C
.................... } 
3C00:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
58CE:  MOVLB  8
58D0:  CLRF   x53
58D2:  CLRF   x52
58D4:  CLRF   x54
58D6:  CLRF   x55
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
58D8:  MOVFF  851,853
58DC:  MOVFF  850,852
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
58E0:  MOVFF  852,854
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
58E4:  MOVF   x53,W
58E6:  MOVWF  x55
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
58E8:  MOVLB  9
58EA:  CLRF   x16
58EC:  CLRF   x15
58EE:  CLRF   x14
58F0:  MOVLW  24
58F2:  MOVWF  x13
58F4:  MOVFF  854,917
58F8:  MOVLB  0
58FA:  CALL   3A6C
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
58FE:  MOVLB  9
5900:  CLRF   x16
5902:  CLRF   x15
5904:  CLRF   x14
5906:  MOVLW  25
5908:  MOVWF  x13
590A:  MOVFF  855,917
590E:  MOVLB  0
5910:  CALL   3A6C
.................... } 
5914:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
351C:  MOVLB  8
351E:  CLRF   xF8
3520:  CLRF   xF7
3522:  CLRF   xFA
3524:  CLRF   xF9
3526:  CLRF   xFC
3528:  CLRF   xFB
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
352A:  MOVLB  9
352C:  CLRF   x1B
352E:  CLRF   x1A
3530:  CLRF   x19
3532:  MOVLW  24
3534:  MOVWF  x18
3536:  MOVLB  0
3538:  RCALL  3450
353A:  MOVLB  8
353C:  MOVFF  01,8F9
3540:  CLRF   xFA
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3542:  MOVLB  9
3544:  CLRF   x1B
3546:  CLRF   x1A
3548:  CLRF   x19
354A:  MOVLW  25
354C:  MOVWF  x18
354E:  MOVLB  0
3550:  RCALL  3450
3552:  MOVLB  8
3554:  CLRF   xFC
3556:  MOVFF  01,8FB
....................    temp2<<=8; 
355A:  MOVFF  8FB,8FC
355E:  CLRF   xFB
....................    buffer = temp2|temp1; 
3560:  MOVF   xFB,W
3562:  IORWF  xF9,W
3564:  MOVWF  xF7
3566:  MOVF   xFC,W
3568:  IORWF  xFA,W
356A:  MOVWF  xF8
....................    return(buffer); 
356C:  MOVFF  8F7,01
3570:  MOVFF  8F8,02
.................... } 
3574:  MOVLB  0
3576:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................    /*for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    }*/ 
....................    //fprintf(COM2," ptr_card=%lu\n\r",ptr_card); 
....................    /*for(i=ptr_start;i<ptr_card;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
*
68BA:  CLRF   23
68BC:  CLRF   22
68BE:  CLRF   21
68C0:  MOVLW  96
68C2:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
68C4:  CLRF   27
68C6:  MOVLW  01
68C8:  MOVWF  26
68CA:  MOVLW  C3
68CC:  MOVWF  25
68CE:  MOVLW  0F
68D0:  MOVWF  24
68D2:  CLRF   19
68D4:  BTFSC  FF2.7
68D6:  BSF    19.7
68D8:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
68DA:  MOVFF  23,8FA
68DE:  MOVFF  22,8F9
68E2:  MOVFF  21,8F8
68E6:  MOVFF  20,8F7
68EA:  MOVLW  19
68EC:  MOVLB  8
68EE:  MOVWF  xFB
68F0:  MOVLB  0
68F2:  CALL   3B6A
68F6:  BTFSC  19.7
68F8:  BSF    FF2.7
68FA:  CLRF   19
68FC:  BTFSC  FF2.7
68FE:  BSF    19.7
6900:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
6902:  MOVFF  27,8FA
6906:  MOVFF  26,8F9
690A:  MOVFF  25,8F8
690E:  MOVFF  24,8F7
6912:  MOVLW  1E
6914:  MOVLB  8
6916:  MOVWF  xFB
6918:  MOVLB  0
691A:  CALL   3B6A
691E:  BTFSC  19.7
6920:  BSF    FF2.7
6922:  CLRF   19
6924:  BTFSC  FF2.7
6926:  BSF    19.7
6928:  BCF    FF2.7
....................    save_coutcard(0); 
692A:  MOVLB  8
692C:  CLRF   x51
692E:  CLRF   x50
6930:  MOVLB  0
6932:  CALL   58CE
6936:  BTFSC  19.7
6938:  BSF    FF2.7
693A:  CLRF   19
693C:  BTFSC  FF2.7
693E:  BSF    19.7
6940:  BCF    FF2.7
....................    countcard=get_countcard(); 
6942:  CALL   351C
6946:  BTFSC  19.7
6948:  BSF    FF2.7
694A:  MOVFF  02,FE
694E:  MOVFF  01,FD
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
6952:  GOTO   6CB2 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    ptr_card=ptr_start; 
6956:  CLRF   23
6958:  CLRF   22
695A:  CLRF   21
695C:  MOVLW  96
695E:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
6960:  CLRF   27
6962:  MOVLW  01
6964:  MOVWF  26
6966:  MOVLW  C3
6968:  MOVWF  25
696A:  MOVLW  0F
696C:  MOVWF  24
696E:  CLRF   19
6970:  BTFSC  FF2.7
6972:  BSF    19.7
6974:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
6976:  MOVFF  23,8FA
697A:  MOVFF  22,8F9
697E:  MOVFF  21,8F8
6982:  MOVFF  20,8F7
6986:  MOVLW  19
6988:  MOVLB  8
698A:  MOVWF  xFB
698C:  MOVLB  0
698E:  CALL   3B6A
6992:  BTFSC  19.7
6994:  BSF    FF2.7
6996:  CLRF   19
6998:  BTFSC  FF2.7
699A:  BSF    19.7
699C:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
699E:  MOVFF  27,8FA
69A2:  MOVFF  26,8F9
69A6:  MOVFF  25,8F8
69AA:  MOVFF  24,8F7
69AE:  MOVLW  1E
69B0:  MOVLB  8
69B2:  MOVWF  xFB
69B4:  MOVLB  0
69B6:  CALL   3B6A
69BA:  BTFSC  19.7
69BC:  BSF    FF2.7
69BE:  CLRF   19
69C0:  BTFSC  FF2.7
69C2:  BSF    19.7
69C4:  BCF    FF2.7
....................    save_coutcard(0); 
69C6:  MOVLB  8
69C8:  CLRF   x51
69CA:  CLRF   x50
69CC:  MOVLB  0
69CE:  CALL   58CE
69D2:  BTFSC  19.7
69D4:  BSF    FF2.7
.................... } 
69D6:  GOTO   6D16 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
*
5D20:  CLRF   19
5D22:  BTFSC  FF2.7
5D24:  BSF    19.7
5D26:  BCF    FF2.7
....................       EEPROM_read(strobe_pass_addr,20,password); 
5D28:  MOVLB  9
5D2A:  CLRF   x07
5D2C:  CLRF   x06
5D2E:  CLRF   x05
5D30:  CLRF   x04
5D32:  CLRF   x0B
5D34:  CLRF   x0A
5D36:  CLRF   x09
5D38:  MOVLW  14
5D3A:  MOVWF  x08
5D3C:  CLRF   x0D
5D3E:  MOVLW  55
5D40:  MOVWF  x0C
5D42:  MOVLB  0
5D44:  CALL   4004
5D48:  BTFSC  19.7
5D4A:  BSF    FF2.7
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5D4C:  INCFSZ 55,W
5D4E:  BRA    5DDA
5D50:  INCFSZ 56,W
5D52:  BRA    5DDA
5D54:  INCFSZ x64,W
5D56:  BRA    5DDA
....................       { 
....................          memset(buffer1,0,20); 
5D58:  CLRF   FEA
5D5A:  MOVLW  2D
5D5C:  MOVWF  FE9
5D5E:  CLRF   00
5D60:  CLRF   02
5D62:  MOVLW  14
5D64:  MOVWF  01
5D66:  CALL   359A
....................          strcpy(buffer1,"admin"); 
5D6A:  CLRF   FEA
5D6C:  MOVLW  2D
5D6E:  MOVWF  FE9
5D70:  MOVLW  00
5D72:  CALL   00BA
5D76:  TBLRD*-
5D78:  TBLRD*+
5D7A:  MOVF   FF5,W
5D7C:  MOVWF  FEE
5D7E:  IORLW  00
5D80:  BNZ   5D78
5D82:  CLRF   19
5D84:  BTFSC  FF2.7
5D86:  BSF    19.7
5D88:  BCF    FF2.7
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
5D8A:  MOVLB  9
5D8C:  CLRF   x03
5D8E:  CLRF   x02
5D90:  CLRF   x01
5D92:  CLRF   x00
5D94:  CLRF   x07
5D96:  CLRF   x06
5D98:  CLRF   x05
5D9A:  MOVLW  14
5D9C:  MOVWF  x04
5D9E:  CLRF   x09
5DA0:  MOVLW  2D
5DA2:  MOVWF  x08
5DA4:  MOVLB  0
5DA6:  CALL   4EF6
5DAA:  BTFSC  19.7
5DAC:  BSF    FF2.7
5DAE:  CLRF   19
5DB0:  BTFSC  FF2.7
5DB2:  BSF    19.7
5DB4:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
5DB6:  MOVLB  9
5DB8:  CLRF   x07
5DBA:  CLRF   x06
5DBC:  CLRF   x05
5DBE:  CLRF   x04
5DC0:  CLRF   x0B
5DC2:  CLRF   x0A
5DC4:  CLRF   x09
5DC6:  MOVLW  14
5DC8:  MOVWF  x08
5DCA:  CLRF   x0D
5DCC:  MOVLW  55
5DCE:  MOVWF  x0C
5DD0:  MOVLB  0
5DD2:  CALL   4004
5DD6:  BTFSC  19.7
5DD8:  BSF    FF2.7
....................       } 
.................... } 
5DDA:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
69DA:  MOVLB  8
69DC:  CLRF   x07
69DE:  MOVF   x07,W
69E0:  SUBLW  13
69E2:  BNC   69F8
69E4:  CLRF   03
69E6:  MOVF   x07,W
69E8:  ADDLW  F3
69EA:  MOVWF  FE9
69EC:  MOVLW  07
69EE:  ADDWFC 03,W
69F0:  MOVWF  FEA
69F2:  SETF   FEF
69F4:  INCF   x07,F
69F6:  BRA    69DE
69F8:  CLRF   19
69FA:  BTFSC  FF2.7
69FC:  BSF    19.7
69FE:  BCF    FF2.7
....................    EEPROM_write(strobe_pass_addr,20,buf); 
6A00:  MOVLB  9
6A02:  CLRF   x03
6A04:  CLRF   x02
6A06:  CLRF   x01
6A08:  CLRF   x00
6A0A:  CLRF   x07
6A0C:  CLRF   x06
6A0E:  CLRF   x05
6A10:  MOVLW  14
6A12:  MOVWF  x04
6A14:  MOVLW  07
6A16:  MOVWF  x09
6A18:  MOVLW  F3
6A1A:  MOVWF  x08
6A1C:  MOVLB  0
6A1E:  CALL   4EF6
6A22:  BTFSC  19.7
6A24:  BSF    FF2.7
.................... } 
6A26:  GOTO   6D7A (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
....................  
.................... #define CRYPTO_KEY_SIZE   32 
....................  
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 cryption_enable=0; 
....................  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int16 galois_mul2(unsigned int16 value) 
.................... { 
....................   signed int16 temp; 
....................   // cast to signed value 
....................   temp = (signed char) value; 
*
4098:  CLRF   03
409A:  MOVLB  9
409C:  MOVF   x0D,W
409E:  BTFSC  FE8.7
40A0:  DECF   03,F
40A2:  MOVWF  x0F
40A4:  MOVFF  03,910
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
40A8:  RRCF   x10,W
40AA:  MOVWF  03
40AC:  RRCF   x0F,W
40AE:  MOVWF  02
40B0:  RRCF   03,F
40B2:  RRCF   02,F
40B4:  RRCF   03,F
40B6:  RRCF   02,F
40B8:  RRCF   03,F
40BA:  RRCF   02,F
40BC:  RRCF   03,F
40BE:  RRCF   02,F
40C0:  RRCF   03,F
40C2:  RRCF   02,F
40C4:  RRCF   03,F
40C6:  RRCF   02,F
40C8:  MOVLW  01
40CA:  ANDWF  03,F
40CC:  MOVFF  02,90F
40D0:  MOVFF  03,910
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
40D4:  MOVLW  1B
40D6:  ANDWF  x0F,F
40D8:  CLRF   x10
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
40DA:  BCF    FD8.0
40DC:  RLCF   x0D,W
40DE:  MOVWF  x11
40E0:  RLCF   x0E,W
40E2:  MOVWF  x12
40E4:  MOVF   x11,W
40E6:  XORWF  x0F,W
40E8:  MOVWF  00
40EA:  MOVF   x12,W
40EC:  XORWF  x10,W
40EE:  MOVWF  03
40F0:  MOVFF  00,01
40F4:  MOVWF  02
.................... } 
40F6:  MOVLB  0
40F8:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................     unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................  
....................   // In case of decryption 
....................   if (dir != 0)  
40FA:  MOVLB  8
40FC:  MOVF   xFB,F
40FE:  BTFSC  FD8.2
4100:  BRA    430A
....................   { 
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
4102:  MOVLB  9
4104:  CLRF   x00
4106:  MOVF   x00,W
4108:  SUBLW  09
410A:  BTFSS  FD8.0
410C:  BRA    42B4
....................       //key schedule 
....................       key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[round]); 
410E:  MOVFF  8F9,01
4112:  MOVFF  8FA,03
4116:  MOVFF  8F9,902
411A:  MOVFF  8FA,903
411E:  MOVLW  0D
4120:  MOVLB  8
4122:  ADDWF  xF9,W
4124:  MOVWF  FE9
4126:  MOVLW  00
4128:  ADDWFC xFA,W
412A:  MOVWF  FEA
412C:  CLRF   03
412E:  MOVF   FEF,W
4130:  MOVLB  0
4132:  CALL   00D0
4136:  MOVLB  9
4138:  MOVWF  x04
413A:  MOVLB  8
413C:  MOVFF  8F9,FE9
4140:  MOVFF  8FA,FEA
4144:  MOVF   FEF,W
4146:  MOVLB  9
4148:  XORWF  x04,F
414A:  CLRF   03
414C:  MOVF   x00,W
414E:  MOVLB  0
4150:  CALL   02F0
4154:  MOVWF  01
4156:  MOVLB  9
4158:  MOVF   x04,W
415A:  XORWF  01,W
415C:  MOVFF  903,FEA
4160:  MOVFF  902,FE9
4164:  MOVWF  FEF
....................       key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4166:  MOVLW  01
4168:  MOVLB  8
416A:  ADDWF  xF9,W
416C:  MOVWF  01
416E:  MOVLW  00
4170:  ADDWFC xFA,W
4172:  MOVWF  03
4174:  MOVFF  01,902
4178:  MOVLB  9
417A:  MOVWF  x03
417C:  MOVLW  0E
417E:  MOVLB  8
4180:  ADDWF  xF9,W
4182:  MOVWF  FE9
4184:  MOVLW  00
4186:  ADDWFC xFA,W
4188:  MOVWF  FEA
418A:  CLRF   03
418C:  MOVF   FEF,W
418E:  MOVLB  0
4190:  CALL   00D0
4194:  MOVLB  9
4196:  MOVWF  x04
4198:  MOVLW  01
419A:  MOVLB  8
419C:  ADDWF  xF9,W
419E:  MOVWF  FE9
41A0:  MOVLW  00
41A2:  ADDWFC xFA,W
41A4:  MOVWF  FEA
41A6:  MOVF   FEF,W
41A8:  MOVLB  9
41AA:  XORWF  x04,W
41AC:  MOVFF  903,FEA
41B0:  MOVFF  902,FE9
41B4:  MOVWF  FEF
....................       key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
41B6:  MOVLW  02
41B8:  MOVLB  8
41BA:  ADDWF  xF9,W
41BC:  MOVWF  01
41BE:  MOVLW  00
41C0:  ADDWFC xFA,W
41C2:  MOVWF  03
41C4:  MOVFF  01,902
41C8:  MOVLB  9
41CA:  MOVWF  x03
41CC:  MOVLW  0F
41CE:  MOVLB  8
41D0:  ADDWF  xF9,W
41D2:  MOVWF  FE9
41D4:  MOVLW  00
41D6:  ADDWFC xFA,W
41D8:  MOVWF  FEA
41DA:  CLRF   03
41DC:  MOVF   FEF,W
41DE:  MOVLB  0
41E0:  CALL   00D0
41E4:  MOVLB  9
41E6:  MOVWF  x04
41E8:  MOVLW  02
41EA:  MOVLB  8
41EC:  ADDWF  xF9,W
41EE:  MOVWF  FE9
41F0:  MOVLW  00
41F2:  ADDWFC xFA,W
41F4:  MOVWF  FEA
41F6:  MOVF   FEF,W
41F8:  MOVLB  9
41FA:  XORWF  x04,W
41FC:  MOVFF  903,FEA
4200:  MOVFF  902,FE9
4204:  MOVWF  FEF
....................       key[3] = (unsigned int8)(sbox[key[12]]^key[3]); 
4206:  MOVLW  03
4208:  MOVLB  8
420A:  ADDWF  xF9,W
420C:  MOVWF  01
420E:  MOVLW  00
4210:  ADDWFC xFA,W
4212:  MOVWF  03
4214:  MOVFF  01,902
4218:  MOVLB  9
421A:  MOVWF  x03
421C:  MOVLW  0C
421E:  MOVLB  8
4220:  ADDWF  xF9,W
4222:  MOVWF  FE9
4224:  MOVLW  00
4226:  ADDWFC xFA,W
4228:  MOVWF  FEA
422A:  CLRF   03
422C:  MOVF   FEF,W
422E:  MOVLB  0
4230:  CALL   00D0
4234:  MOVLB  9
4236:  MOVWF  x04
4238:  MOVLW  03
423A:  MOVLB  8
423C:  ADDWF  xF9,W
423E:  MOVWF  FE9
4240:  MOVLW  00
4242:  ADDWFC xFA,W
4244:  MOVWF  FEA
4246:  MOVF   FEF,W
4248:  MOVLB  9
424A:  XORWF  x04,W
424C:  MOVFF  903,FEA
4250:  MOVFF  902,FE9
4254:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4256:  MOVLW  04
4258:  MOVWF  x01
425A:  MOVF   x01,W
425C:  SUBLW  0F
425E:  BNC   42B0
....................         key[i] = key[i] ^ key[i-4]; 
4260:  CLRF   03
4262:  MOVF   x01,W
4264:  MOVLB  8
4266:  ADDWF  xF9,W
4268:  MOVWF  01
426A:  MOVF   xFA,W
426C:  ADDWFC 03,F
426E:  MOVLB  9
4270:  MOVFF  03,903
4274:  CLRF   03
4276:  MOVF   x01,W
4278:  MOVLB  8
427A:  ADDWF  xF9,W
427C:  MOVWF  FE9
427E:  MOVF   xFA,W
4280:  ADDWFC 03,W
4282:  MOVWF  FEA
4284:  MOVFF  FEF,904
4288:  MOVLW  04
428A:  MOVLB  9
428C:  SUBWF  x01,W
428E:  CLRF   03
4290:  MOVLB  8
4292:  ADDWF  xF9,W
4294:  MOVWF  FE9
4296:  MOVF   xFA,W
4298:  ADDWFC 03,W
429A:  MOVWF  FEA
429C:  MOVF   FEF,W
429E:  MOVLB  9
42A0:  XORWF  x04,W
42A2:  MOVFF  903,FEA
42A6:  MOVFF  01,FE9
42AA:  MOVWF  FEF
....................       } 
42AC:  INCF   x01,F
42AE:  BRA    425A
....................     } 
42B0:  INCF   x00,F
42B2:  BRA    4106
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++) 
42B4:  CLRF   x01
42B6:  MOVF   x01,W
42B8:  SUBLW  0F
42BA:  BNC   430A
....................     { 
....................       state[i]=state[i] ^ key[i]; 
42BC:  CLRF   03
42BE:  MOVF   x01,W
42C0:  MOVLB  8
42C2:  ADDWF  xF7,W
42C4:  MOVWF  01
42C6:  MOVF   xF8,W
42C8:  ADDWFC 03,F
42CA:  MOVLB  9
42CC:  MOVFF  03,903
42D0:  CLRF   03
42D2:  MOVF   x01,W
42D4:  MOVLB  8
42D6:  ADDWF  xF7,W
42D8:  MOVWF  FE9
42DA:  MOVF   xF8,W
42DC:  ADDWFC 03,W
42DE:  MOVWF  FEA
42E0:  MOVFF  FEF,904
42E4:  CLRF   03
42E6:  MOVLB  9
42E8:  MOVF   x01,W
42EA:  MOVLB  8
42EC:  ADDWF  xF9,W
42EE:  MOVWF  FE9
42F0:  MOVF   xFA,W
42F2:  ADDWFC 03,W
42F4:  MOVWF  FEA
42F6:  MOVF   FEF,W
42F8:  MOVLB  9
42FA:  XORWF  x04,W
42FC:  MOVFF  903,FEA
4300:  MOVFF  01,FE9
4304:  MOVWF  FEF
....................     } 
4306:  INCF   x01,F
4308:  BRA    42B6
....................   } 
....................   // main loop 
....................   for (round = 0; round < 10; round++) 
430A:  MOVLB  9
430C:  CLRF   x00
430E:  MOVF   x00,W
4310:  SUBLW  09
4312:  BTFSS  FD8.0
4314:  GOTO   4E92
....................   { 
....................     if (dir != 0) 
4318:  MOVLB  8
431A:  MOVF   xFB,F
431C:  BTFSC  FD8.2
431E:  BRA    44CC
....................     { 
....................           //Inverse key schedule 
....................           for (i=15; i>3; --i)  
4320:  MOVLW  0F
4322:  MOVLB  9
4324:  MOVWF  x01
4326:  MOVF   x01,W
4328:  SUBLW  03
432A:  BC    437C
....................           { 
....................             key[i] = key[i] ^ key[i-4]; 
432C:  CLRF   03
432E:  MOVF   x01,W
4330:  MOVLB  8
4332:  ADDWF  xF9,W
4334:  MOVWF  01
4336:  MOVF   xFA,W
4338:  ADDWFC 03,F
433A:  MOVLB  9
433C:  MOVFF  03,903
4340:  CLRF   03
4342:  MOVF   x01,W
4344:  MOVLB  8
4346:  ADDWF  xF9,W
4348:  MOVWF  FE9
434A:  MOVF   xFA,W
434C:  ADDWFC 03,W
434E:  MOVWF  FEA
4350:  MOVFF  FEF,904
4354:  MOVLW  04
4356:  MOVLB  9
4358:  SUBWF  x01,W
435A:  CLRF   03
435C:  MOVLB  8
435E:  ADDWF  xF9,W
4360:  MOVWF  FE9
4362:  MOVF   xFA,W
4364:  ADDWFC 03,W
4366:  MOVWF  FEA
4368:  MOVF   FEF,W
436A:  MOVLB  9
436C:  XORWF  x04,W
436E:  MOVFF  903,FEA
4372:  MOVFF  01,FE9
4376:  MOVWF  FEF
....................           }   
4378:  DECF   x01,F
437A:  BRA    4326
....................           key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[9-round]); 
437C:  MOVFF  8F9,01
4380:  MOVFF  8FA,03
4384:  MOVFF  8F9,902
4388:  MOVFF  8FA,903
438C:  MOVLW  0D
438E:  MOVLB  8
4390:  ADDWF  xF9,W
4392:  MOVWF  FE9
4394:  MOVLW  00
4396:  ADDWFC xFA,W
4398:  MOVWF  FEA
439A:  CLRF   03
439C:  MOVF   FEF,W
439E:  MOVLB  0
43A0:  CALL   00D0
43A4:  MOVLB  9
43A6:  MOVWF  x04
43A8:  MOVLB  8
43AA:  MOVFF  8F9,FE9
43AE:  MOVFF  8FA,FEA
43B2:  MOVF   FEF,W
43B4:  MOVLB  9
43B6:  XORWF  x04,F
43B8:  MOVLW  09
43BA:  BSF    FD8.0
43BC:  SUBFWB x00,W
43BE:  CLRF   03
43C0:  MOVLB  0
43C2:  CALL   02F0
43C6:  MOVWF  01
43C8:  MOVLB  9
43CA:  MOVF   x04,W
43CC:  XORWF  01,W
43CE:  MOVFF  903,FEA
43D2:  MOVFF  902,FE9
43D6:  MOVWF  FEF
....................           key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
43D8:  MOVLW  01
43DA:  MOVLB  8
43DC:  ADDWF  xF9,W
43DE:  MOVWF  01
43E0:  MOVLW  00
43E2:  ADDWFC xFA,W
43E4:  MOVWF  03
43E6:  MOVFF  01,902
43EA:  MOVLB  9
43EC:  MOVWF  x03
43EE:  MOVLW  0E
43F0:  MOVLB  8
43F2:  ADDWF  xF9,W
43F4:  MOVWF  FE9
43F6:  MOVLW  00
43F8:  ADDWFC xFA,W
43FA:  MOVWF  FEA
43FC:  CLRF   03
43FE:  MOVF   FEF,W
4400:  MOVLB  0
4402:  CALL   00D0
4406:  MOVLB  9
4408:  MOVWF  x04
440A:  MOVLW  01
440C:  MOVLB  8
440E:  ADDWF  xF9,W
4410:  MOVWF  FE9
4412:  MOVLW  00
4414:  ADDWFC xFA,W
4416:  MOVWF  FEA
4418:  MOVF   FEF,W
441A:  MOVLB  9
441C:  XORWF  x04,W
441E:  MOVFF  903,FEA
4422:  MOVFF  902,FE9
4426:  MOVWF  FEF
....................           key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
4428:  MOVLW  02
442A:  MOVLB  8
442C:  ADDWF  xF9,W
442E:  MOVWF  01
4430:  MOVLW  00
4432:  ADDWFC xFA,W
4434:  MOVWF  03
4436:  MOVFF  01,902
443A:  MOVLB  9
443C:  MOVWF  x03
443E:  MOVLW  0F
4440:  MOVLB  8
4442:  ADDWF  xF9,W
4444:  MOVWF  FE9
4446:  MOVLW  00
4448:  ADDWFC xFA,W
444A:  MOVWF  FEA
444C:  CLRF   03
444E:  MOVF   FEF,W
4450:  MOVLB  0
4452:  CALL   00D0
4456:  MOVLB  9
4458:  MOVWF  x04
445A:  MOVLW  02
445C:  MOVLB  8
445E:  ADDWF  xF9,W
4460:  MOVWF  FE9
4462:  MOVLW  00
4464:  ADDWFC xFA,W
4466:  MOVWF  FEA
4468:  MOVF   FEF,W
446A:  MOVLB  9
446C:  XORWF  x04,W
446E:  MOVFF  903,FEA
4472:  MOVFF  902,FE9
4476:  MOVWF  FEF
....................           key[3] = (unsigned int8)(sbox[key[12]]^key[3]);  
4478:  MOVLW  03
447A:  MOVLB  8
447C:  ADDWF  xF9,W
447E:  MOVWF  01
4480:  MOVLW  00
4482:  ADDWFC xFA,W
4484:  MOVWF  03
4486:  MOVFF  01,902
448A:  MOVLB  9
448C:  MOVWF  x03
448E:  MOVLW  0C
4490:  MOVLB  8
4492:  ADDWF  xF9,W
4494:  MOVWF  FE9
4496:  MOVLW  00
4498:  ADDWFC xFA,W
449A:  MOVWF  FEA
449C:  CLRF   03
449E:  MOVF   FEF,W
44A0:  MOVLB  0
44A2:  CALL   00D0
44A6:  MOVLB  9
44A8:  MOVWF  x04
44AA:  MOVLW  03
44AC:  MOVLB  8
44AE:  ADDWF  xF9,W
44B0:  MOVWF  FE9
44B2:  MOVLW  00
44B4:  ADDWFC xFA,W
44B6:  MOVWF  FEA
44B8:  MOVF   FEF,W
44BA:  MOVLB  9
44BC:  XORWF  x04,W
44BE:  MOVFF  903,FEA
44C2:  MOVFF  902,FE9
44C6:  MOVWF  FEF
....................     }  
....................     else  
44C8:  BRA    4726
44CA:  MOVLB  8
....................     { 
....................         for (i = 0; i <16; i++) 
44CC:  MOVLB  9
44CE:  CLRF   x01
44D0:  MOVF   x01,W
44D2:  SUBLW  0F
44D4:  BNC   4532
....................         { 
....................             // with shiftrow i+5 mod 16 
....................             state[i]=sbox[state[i] ^ key[i]]; 
44D6:  CLRF   03
44D8:  MOVF   x01,W
44DA:  MOVLB  8
44DC:  ADDWF  xF7,W
44DE:  MOVWF  01
44E0:  MOVF   xF8,W
44E2:  ADDWFC 03,F
44E4:  MOVFF  01,902
44E8:  MOVLB  9
44EA:  MOVFF  03,903
44EE:  CLRF   03
44F0:  MOVF   x01,W
44F2:  MOVLB  8
44F4:  ADDWF  xF7,W
44F6:  MOVWF  FE9
44F8:  MOVF   xF8,W
44FA:  ADDWFC 03,W
44FC:  MOVWF  FEA
44FE:  MOVFF  FEF,904
4502:  CLRF   03
4504:  MOVLB  9
4506:  MOVF   x01,W
4508:  MOVLB  8
450A:  ADDWF  xF9,W
450C:  MOVWF  FE9
450E:  MOVF   xFA,W
4510:  ADDWFC 03,W
4512:  MOVWF  FEA
4514:  MOVF   FEF,W
4516:  MOVLB  9
4518:  XORWF  x04,W
451A:  CLRF   03
451C:  MOVLB  0
451E:  CALL   00D0
4522:  MOVFF  903,FEA
4526:  MOVFF  902,FE9
452A:  MOVWF  FEF
....................         } 
452C:  MOVLB  9
452E:  INCF   x01,F
4530:  BRA    44D0
....................         //shift rows 
....................         buf1 = state[1]; 
4532:  MOVLW  01
4534:  MOVLB  8
4536:  ADDWF  xF7,W
4538:  MOVWF  FE9
453A:  MOVLW  00
453C:  ADDWFC xF8,W
453E:  MOVWF  FEA
4540:  MOVFF  FEF,8FC
....................         state[1] = state[5]; 
4544:  MOVLW  01
4546:  ADDWF  xF7,W
4548:  MOVWF  01
454A:  MOVLW  00
454C:  ADDWFC xF8,W
454E:  MOVWF  03
4550:  MOVLW  05
4552:  MOVLB  8
4554:  ADDWF  xF7,W
4556:  MOVWF  FE9
4558:  MOVLW  00
455A:  ADDWFC xF8,W
455C:  MOVWF  FEA
455E:  MOVFF  FEF,904
4562:  MOVLB  9
4564:  MOVFF  03,FEA
4568:  MOVFF  01,FE9
456C:  MOVFF  904,FEF
....................         state[5] = state[9]; 
4570:  MOVLW  05
4572:  MOVLB  8
4574:  ADDWF  xF7,W
4576:  MOVWF  01
4578:  MOVLW  00
457A:  ADDWFC xF8,W
457C:  MOVWF  03
457E:  MOVLW  09
4580:  MOVLB  8
4582:  ADDWF  xF7,W
4584:  MOVWF  FE9
4586:  MOVLW  00
4588:  ADDWFC xF8,W
458A:  MOVWF  FEA
458C:  MOVFF  FEF,904
4590:  MOVLB  9
4592:  MOVFF  03,FEA
4596:  MOVFF  01,FE9
459A:  MOVFF  904,FEF
....................         state[9] = state[13]; 
459E:  MOVLW  09
45A0:  MOVLB  8
45A2:  ADDWF  xF7,W
45A4:  MOVWF  01
45A6:  MOVLW  00
45A8:  ADDWFC xF8,W
45AA:  MOVWF  03
45AC:  MOVLW  0D
45AE:  MOVLB  8
45B0:  ADDWF  xF7,W
45B2:  MOVWF  FE9
45B4:  MOVLW  00
45B6:  ADDWFC xF8,W
45B8:  MOVWF  FEA
45BA:  MOVFF  FEF,904
45BE:  MOVLB  9
45C0:  MOVFF  03,FEA
45C4:  MOVFF  01,FE9
45C8:  MOVFF  904,FEF
....................         state[13] = buf1; 
45CC:  MOVLW  0D
45CE:  MOVLB  8
45D0:  ADDWF  xF7,W
45D2:  MOVWF  FE9
45D4:  MOVLW  00
45D6:  ADDWFC xF8,W
45D8:  MOVWF  FEA
45DA:  MOVFF  8FC,FEF
....................      
....................         buf1 = state[2]; 
45DE:  MOVLW  02
45E0:  ADDWF  xF7,W
45E2:  MOVWF  FE9
45E4:  MOVLW  00
45E6:  ADDWFC xF8,W
45E8:  MOVWF  FEA
45EA:  MOVFF  FEF,8FC
....................         buf2 = state[6]; 
45EE:  MOVLW  06
45F0:  ADDWF  xF7,W
45F2:  MOVWF  FE9
45F4:  MOVLW  00
45F6:  ADDWFC xF8,W
45F8:  MOVWF  FEA
45FA:  MOVFF  FEF,8FD
....................         state[2] = state[10]; 
45FE:  MOVLW  02
4600:  ADDWF  xF7,W
4602:  MOVWF  01
4604:  MOVLW  00
4606:  ADDWFC xF8,W
4608:  MOVWF  03
460A:  MOVLW  0A
460C:  MOVLB  8
460E:  ADDWF  xF7,W
4610:  MOVWF  FE9
4612:  MOVLW  00
4614:  ADDWFC xF8,W
4616:  MOVWF  FEA
4618:  MOVFF  FEF,904
461C:  MOVLB  9
461E:  MOVFF  03,FEA
4622:  MOVFF  01,FE9
4626:  MOVFF  904,FEF
....................         state[6] = state[14]; 
462A:  MOVLW  06
462C:  MOVLB  8
462E:  ADDWF  xF7,W
4630:  MOVWF  01
4632:  MOVLW  00
4634:  ADDWFC xF8,W
4636:  MOVWF  03
4638:  MOVLW  0E
463A:  MOVLB  8
463C:  ADDWF  xF7,W
463E:  MOVWF  FE9
4640:  MOVLW  00
4642:  ADDWFC xF8,W
4644:  MOVWF  FEA
4646:  MOVFF  FEF,904
464A:  MOVLB  9
464C:  MOVFF  03,FEA
4650:  MOVFF  01,FE9
4654:  MOVFF  904,FEF
....................         state[10] = buf1; 
4658:  MOVLW  0A
465A:  MOVLB  8
465C:  ADDWF  xF7,W
465E:  MOVWF  FE9
4660:  MOVLW  00
4662:  ADDWFC xF8,W
4664:  MOVWF  FEA
4666:  MOVFF  8FC,FEF
....................         state[14] = buf2; 
466A:  MOVLW  0E
466C:  ADDWF  xF7,W
466E:  MOVWF  FE9
4670:  MOVLW  00
4672:  ADDWFC xF8,W
4674:  MOVWF  FEA
4676:  MOVFF  8FD,FEF
....................      
....................         buf1 = state[15]; 
467A:  MOVLW  0F
467C:  ADDWF  xF7,W
467E:  MOVWF  FE9
4680:  MOVLW  00
4682:  ADDWFC xF8,W
4684:  MOVWF  FEA
4686:  MOVFF  FEF,8FC
....................         state[15] = state[11]; 
468A:  MOVLW  0F
468C:  ADDWF  xF7,W
468E:  MOVWF  01
4690:  MOVLW  00
4692:  ADDWFC xF8,W
4694:  MOVWF  03
4696:  MOVLW  0B
4698:  MOVLB  8
469A:  ADDWF  xF7,W
469C:  MOVWF  FE9
469E:  MOVLW  00
46A0:  ADDWFC xF8,W
46A2:  MOVWF  FEA
46A4:  MOVFF  FEF,904
46A8:  MOVLB  9
46AA:  MOVFF  03,FEA
46AE:  MOVFF  01,FE9
46B2:  MOVFF  904,FEF
....................         state[11] = state[7]; 
46B6:  MOVLW  0B
46B8:  MOVLB  8
46BA:  ADDWF  xF7,W
46BC:  MOVWF  01
46BE:  MOVLW  00
46C0:  ADDWFC xF8,W
46C2:  MOVWF  03
46C4:  MOVLW  07
46C6:  MOVLB  8
46C8:  ADDWF  xF7,W
46CA:  MOVWF  FE9
46CC:  MOVLW  00
46CE:  ADDWFC xF8,W
46D0:  MOVWF  FEA
46D2:  MOVFF  FEF,904
46D6:  MOVLB  9
46D8:  MOVFF  03,FEA
46DC:  MOVFF  01,FE9
46E0:  MOVFF  904,FEF
....................         state[7] = state[3]; 
46E4:  MOVLW  07
46E6:  MOVLB  8
46E8:  ADDWF  xF7,W
46EA:  MOVWF  01
46EC:  MOVLW  00
46EE:  ADDWFC xF8,W
46F0:  MOVWF  03
46F2:  MOVLW  03
46F4:  MOVLB  8
46F6:  ADDWF  xF7,W
46F8:  MOVWF  FE9
46FA:  MOVLW  00
46FC:  ADDWFC xF8,W
46FE:  MOVWF  FEA
4700:  MOVFF  FEF,904
4704:  MOVLB  9
4706:  MOVFF  03,FEA
470A:  MOVFF  01,FE9
470E:  MOVFF  904,FEF
....................         state[3] = buf1; 
4712:  MOVLW  03
4714:  MOVLB  8
4716:  ADDWF  xF7,W
4718:  MOVWF  FE9
471A:  MOVLW  00
471C:  ADDWFC xF8,W
471E:  MOVWF  FEA
4720:  MOVFF  8FC,FEF
4724:  MOVLB  9
....................     } 
....................      
....................     //mixcol - inv mix 
....................     if (((round > 0) && (dir != 0)) || ((round < 9) && (dir == 0)))  
4726:  MOVF   x00,F
4728:  BZ    4732
472A:  MOVLB  8
472C:  MOVF   xFB,F
472E:  BNZ   4746
4730:  MOVLB  9
4732:  MOVF   x00,W
4734:  SUBLW  08
4736:  BTFSS  FD8.0
4738:  BRA    4A8A
473A:  MOVLB  8
473C:  MOVF   xFB,F
473E:  BTFSC  FD8.2
4740:  BRA    4746
4742:  MOVLB  9
4744:  BRA    4A8A
....................     { 
....................           for (i=0; i <4; i++) 
4746:  MOVLB  9
4748:  CLRF   x01
474A:  MOVF   x01,W
474C:  SUBLW  03
474E:  BTFSS  FD8.0
4750:  BRA    4A8A
....................           { 
....................                 buf4 = (unsigned int8)(i << 2); 
4752:  RLCF   x01,W
4754:  MOVLB  8
4756:  MOVWF  xFF
4758:  RLCF   xFF,F
475A:  MOVLW  FC
475C:  ANDWF  xFF,F
....................                 if (dir != 0) 
475E:  MOVF   xFB,F
4760:  BZ    484E
....................                 { 
....................                       // precompute for decryption 
....................                       buf1 = galois_mul2(galois_mul2((unsigned int8)(state[buf4]^state[buf4+2]))); 
4762:  CLRF   03
4764:  MOVF   xFF,W
4766:  ADDWF  xF7,W
4768:  MOVWF  FE9
476A:  MOVF   xF8,W
476C:  ADDWFC 03,W
476E:  MOVWF  FEA
4770:  MOVFF  FEF,902
4774:  MOVLW  02
4776:  ADDWF  xFF,W
4778:  CLRF   03
477A:  ADDWF  xF7,W
477C:  MOVWF  FE9
477E:  MOVF   xF8,W
4780:  ADDWFC 03,W
4782:  MOVWF  FEA
4784:  MOVF   FEF,W
4786:  MOVLB  9
4788:  XORWF  x02,F
478A:  CLRF   x0E
478C:  MOVFF  902,90D
4790:  MOVLB  0
4792:  RCALL  4098
4794:  MOVFF  02,903
4798:  MOVFF  01,902
479C:  MOVFF  02,90E
47A0:  MOVFF  01,90D
47A4:  RCALL  4098
47A6:  MOVFF  01,8FC
....................                       buf2 = galois_mul2(galois_mul2((unsigned int8)(state[buf4+1]^state[buf4+3]))); 
47AA:  MOVLW  01
47AC:  MOVLB  8
47AE:  ADDWF  xFF,W
47B0:  CLRF   03
47B2:  ADDWF  xF7,W
47B4:  MOVWF  FE9
47B6:  MOVF   xF8,W
47B8:  ADDWFC 03,W
47BA:  MOVWF  FEA
47BC:  MOVFF  FEF,902
47C0:  MOVLW  03
47C2:  ADDWF  xFF,W
47C4:  CLRF   03
47C6:  ADDWF  xF7,W
47C8:  MOVWF  FE9
47CA:  MOVF   xF8,W
47CC:  ADDWFC 03,W
47CE:  MOVWF  FEA
47D0:  MOVF   FEF,W
47D2:  MOVLB  9
47D4:  XORWF  x02,F
47D6:  CLRF   x0E
47D8:  MOVFF  902,90D
47DC:  MOVLB  0
47DE:  RCALL  4098
47E0:  MOVFF  02,903
47E4:  MOVFF  01,902
47E8:  MOVFF  02,90E
47EC:  MOVFF  01,90D
47F0:  RCALL  4098
47F2:  MOVFF  01,8FD
....................                       state[buf4] ^= buf1;  
47F6:  CLRF   03
47F8:  MOVLB  8
47FA:  MOVF   xFF,W
47FC:  ADDWF  xF7,W
47FE:  MOVWF  FE9
4800:  MOVF   xF8,W
4802:  ADDWFC 03,W
4804:  MOVWF  FEA
4806:  MOVF   FEF,W
4808:  XORWF  xFC,W
480A:  MOVWF  FEF
....................                       state[buf4+1] ^= buf2;  
480C:  MOVLW  01
480E:  ADDWF  xFF,W
4810:  CLRF   03
4812:  ADDWF  xF7,W
4814:  MOVWF  FE9
4816:  MOVF   xF8,W
4818:  ADDWFC 03,W
481A:  MOVWF  FEA
481C:  MOVF   FEF,W
481E:  XORWF  xFD,W
4820:  MOVWF  FEF
....................                       state[buf4+2] ^= buf1;  
4822:  MOVLW  02
4824:  ADDWF  xFF,W
4826:  CLRF   03
4828:  ADDWF  xF7,W
482A:  MOVWF  FE9
482C:  MOVF   xF8,W
482E:  ADDWFC 03,W
4830:  MOVWF  FEA
4832:  MOVF   FEF,W
4834:  XORWF  xFC,W
4836:  MOVWF  FEF
....................                       state[buf4+3] ^= buf2;  
4838:  MOVLW  03
483A:  ADDWF  xFF,W
483C:  CLRF   03
483E:  ADDWF  xF7,W
4840:  MOVWF  FE9
4842:  MOVF   xF8,W
4844:  ADDWFC 03,W
4846:  MOVWF  FEA
4848:  MOVF   FEF,W
484A:  XORWF  xFD,W
484C:  MOVWF  FEF
....................                 } 
....................                 // in all cases 
....................                 buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
484E:  CLRF   03
4850:  MOVF   xFF,W
4852:  ADDWF  xF7,W
4854:  MOVWF  FE9
4856:  MOVF   xF8,W
4858:  ADDWFC 03,W
485A:  MOVWF  FEA
485C:  MOVFF  FEF,902
4860:  MOVLW  01
4862:  ADDWF  xFF,W
4864:  CLRF   03
4866:  ADDWF  xF7,W
4868:  MOVWF  FE9
486A:  MOVF   xF8,W
486C:  ADDWFC 03,W
486E:  MOVWF  FEA
4870:  MOVF   FEF,W
4872:  MOVLB  9
4874:  XORWF  x02,F
4876:  MOVLW  02
4878:  MOVLB  8
487A:  ADDWF  xFF,W
487C:  CLRF   03
487E:  ADDWF  xF7,W
4880:  MOVWF  FE9
4882:  MOVF   xF8,W
4884:  ADDWFC 03,W
4886:  MOVWF  FEA
4888:  MOVF   FEF,W
488A:  MOVLB  9
488C:  XORWF  x02,F
488E:  MOVLW  03
4890:  MOVLB  8
4892:  ADDWF  xFF,W
4894:  CLRF   03
4896:  ADDWF  xF7,W
4898:  MOVWF  FE9
489A:  MOVF   xF8,W
489C:  ADDWFC 03,W
489E:  MOVWF  FEA
48A0:  MOVF   FEF,W
48A2:  MOVLB  9
48A4:  XORWF  x02,W
48A6:  MOVLB  8
48A8:  MOVWF  xFC
....................                 buf2 = state[buf4]; 
48AA:  CLRF   03
48AC:  MOVF   xFF,W
48AE:  ADDWF  xF7,W
48B0:  MOVWF  FE9
48B2:  MOVF   xF8,W
48B4:  ADDWFC 03,W
48B6:  MOVWF  FEA
48B8:  MOVFF  FEF,8FD
....................                 buf3 = state[buf4]^state[buf4+1];  
48BC:  CLRF   03
48BE:  MOVF   xFF,W
48C0:  ADDWF  xF7,W
48C2:  MOVWF  FE9
48C4:  MOVF   xF8,W
48C6:  ADDWFC 03,W
48C8:  MOVWF  FEA
48CA:  MOVFF  FEF,902
48CE:  MOVLW  01
48D0:  ADDWF  xFF,W
48D2:  CLRF   03
48D4:  ADDWF  xF7,W
48D6:  MOVWF  FE9
48D8:  MOVF   xF8,W
48DA:  ADDWFC 03,W
48DC:  MOVWF  FEA
48DE:  MOVF   FEF,W
48E0:  MOVLB  9
48E2:  XORWF  x02,W
48E4:  MOVLB  8
48E6:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
48E8:  MOVLB  9
48EA:  CLRF   x0E
48EC:  MOVFF  8FE,90D
48F0:  MOVLB  0
48F2:  CALL   4098
48F6:  MOVFF  01,8FE
....................                 state[buf4] = state[buf4] ^ buf3 ^ buf1; 
48FA:  CLRF   03
48FC:  MOVLB  8
48FE:  MOVF   xFF,W
4900:  ADDWF  xF7,W
4902:  MOVWF  01
4904:  MOVF   xF8,W
4906:  ADDWFC 03,F
4908:  MOVLB  9
490A:  MOVFF  03,903
490E:  CLRF   03
4910:  MOVLB  8
4912:  MOVF   xFF,W
4914:  ADDWF  xF7,W
4916:  MOVWF  FE9
4918:  MOVF   xF8,W
491A:  ADDWFC 03,W
491C:  MOVWF  FEA
491E:  MOVF   FEF,W
4920:  XORWF  xFE,W
4922:  XORWF  xFC,W
4924:  MOVLB  9
4926:  MOVFF  903,FEA
492A:  MOVFF  01,FE9
492E:  MOVWF  FEF
....................                 buf3 = state[buf4+1]^state[buf4+2];  
4930:  MOVLW  01
4932:  MOVLB  8
4934:  ADDWF  xFF,W
4936:  CLRF   03
4938:  ADDWF  xF7,W
493A:  MOVWF  FE9
493C:  MOVF   xF8,W
493E:  ADDWFC 03,W
4940:  MOVWF  FEA
4942:  MOVFF  FEF,902
4946:  MOVLW  02
4948:  ADDWF  xFF,W
494A:  CLRF   03
494C:  ADDWF  xF7,W
494E:  MOVWF  FE9
4950:  MOVF   xF8,W
4952:  ADDWFC 03,W
4954:  MOVWF  FEA
4956:  MOVF   FEF,W
4958:  MOVLB  9
495A:  XORWF  x02,W
495C:  MOVLB  8
495E:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
4960:  MOVLB  9
4962:  CLRF   x0E
4964:  MOVFF  8FE,90D
4968:  MOVLB  0
496A:  CALL   4098
496E:  MOVFF  01,8FE
....................                 state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
4972:  MOVLW  01
4974:  MOVLB  8
4976:  ADDWF  xFF,W
4978:  CLRF   03
497A:  ADDWF  xF7,W
497C:  MOVWF  01
497E:  MOVF   xF8,W
4980:  ADDWFC 03,F
4982:  MOVFF  03,903
4986:  MOVLW  01
4988:  MOVLB  8
498A:  ADDWF  xFF,W
498C:  CLRF   03
498E:  ADDWF  xF7,W
4990:  MOVWF  FE9
4992:  MOVF   xF8,W
4994:  ADDWFC 03,W
4996:  MOVWF  FEA
4998:  MOVF   FEF,W
499A:  XORWF  xFE,W
499C:  XORWF  xFC,W
499E:  MOVLB  9
49A0:  MOVFF  903,FEA
49A4:  MOVFF  01,FE9
49A8:  MOVWF  FEF
....................                 buf3 = state[buf4+2]^state[buf4+3];  
49AA:  MOVLW  02
49AC:  MOVLB  8
49AE:  ADDWF  xFF,W
49B0:  CLRF   03
49B2:  ADDWF  xF7,W
49B4:  MOVWF  FE9
49B6:  MOVF   xF8,W
49B8:  ADDWFC 03,W
49BA:  MOVWF  FEA
49BC:  MOVFF  FEF,902
49C0:  MOVLW  03
49C2:  ADDWF  xFF,W
49C4:  CLRF   03
49C6:  ADDWF  xF7,W
49C8:  MOVWF  FE9
49CA:  MOVF   xF8,W
49CC:  ADDWFC 03,W
49CE:  MOVWF  FEA
49D0:  MOVF   FEF,W
49D2:  MOVLB  9
49D4:  XORWF  x02,W
49D6:  MOVLB  8
49D8:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
49DA:  MOVLB  9
49DC:  CLRF   x0E
49DE:  MOVFF  8FE,90D
49E2:  MOVLB  0
49E4:  CALL   4098
49E8:  MOVFF  01,8FE
....................                 state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
49EC:  MOVLW  02
49EE:  MOVLB  8
49F0:  ADDWF  xFF,W
49F2:  CLRF   03
49F4:  ADDWF  xF7,W
49F6:  MOVWF  01
49F8:  MOVF   xF8,W
49FA:  ADDWFC 03,F
49FC:  MOVFF  03,903
4A00:  MOVLW  02
4A02:  MOVLB  8
4A04:  ADDWF  xFF,W
4A06:  CLRF   03
4A08:  ADDWF  xF7,W
4A0A:  MOVWF  FE9
4A0C:  MOVF   xF8,W
4A0E:  ADDWFC 03,W
4A10:  MOVWF  FEA
4A12:  MOVF   FEF,W
4A14:  XORWF  xFE,W
4A16:  XORWF  xFC,W
4A18:  MOVLB  9
4A1A:  MOVFF  903,FEA
4A1E:  MOVFF  01,FE9
4A22:  MOVWF  FEF
....................                 buf3 = state[buf4+3]^buf2;      
4A24:  MOVLW  03
4A26:  MOVLB  8
4A28:  ADDWF  xFF,W
4A2A:  CLRF   03
4A2C:  ADDWF  xF7,W
4A2E:  MOVWF  FE9
4A30:  MOVF   xF8,W
4A32:  ADDWFC 03,W
4A34:  MOVWF  FEA
4A36:  MOVF   FEF,W
4A38:  XORWF  xFD,W
4A3A:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
4A3C:  MOVLB  9
4A3E:  CLRF   x0E
4A40:  MOVFF  8FE,90D
4A44:  MOVLB  0
4A46:  CALL   4098
4A4A:  MOVFF  01,8FE
....................                 state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1;  
4A4E:  MOVLW  03
4A50:  MOVLB  8
4A52:  ADDWF  xFF,W
4A54:  CLRF   03
4A56:  ADDWF  xF7,W
4A58:  MOVWF  01
4A5A:  MOVF   xF8,W
4A5C:  ADDWFC 03,F
4A5E:  MOVFF  03,903
4A62:  MOVLW  03
4A64:  MOVLB  8
4A66:  ADDWF  xFF,W
4A68:  CLRF   03
4A6A:  ADDWF  xF7,W
4A6C:  MOVWF  FE9
4A6E:  MOVF   xF8,W
4A70:  ADDWFC 03,W
4A72:  MOVWF  FEA
4A74:  MOVF   FEF,W
4A76:  XORWF  xFE,W
4A78:  XORWF  xFC,W
4A7A:  MOVLB  9
4A7C:  MOVFF  903,FEA
4A80:  MOVFF  01,FE9
4A84:  MOVWF  FEF
....................           } 
4A86:  INCF   x01,F
4A88:  BRA    474A
....................     } 
....................      
....................     if (dir != 0)  
4A8A:  MOVLB  8
4A8C:  MOVF   xFB,F
4A8E:  BTFSC  FD8.2
4A90:  BRA    4CEA
....................     { 
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
4A92:  MOVLW  0D
4A94:  ADDWF  xF7,W
4A96:  MOVWF  FE9
4A98:  MOVLW  00
4A9A:  ADDWFC xF8,W
4A9C:  MOVWF  FEA
4A9E:  MOVFF  FEF,8FC
....................       state[13] = state[9]; 
4AA2:  MOVLW  0D
4AA4:  ADDWF  xF7,W
4AA6:  MOVWF  01
4AA8:  MOVLW  00
4AAA:  ADDWFC xF8,W
4AAC:  MOVWF  03
4AAE:  MOVLW  09
4AB0:  MOVLB  8
4AB2:  ADDWF  xF7,W
4AB4:  MOVWF  FE9
4AB6:  MOVLW  00
4AB8:  ADDWFC xF8,W
4ABA:  MOVWF  FEA
4ABC:  MOVFF  FEF,904
4AC0:  MOVLB  9
4AC2:  MOVFF  03,FEA
4AC6:  MOVFF  01,FE9
4ACA:  MOVFF  904,FEF
....................       state[9] = state[5]; 
4ACE:  MOVLW  09
4AD0:  MOVLB  8
4AD2:  ADDWF  xF7,W
4AD4:  MOVWF  01
4AD6:  MOVLW  00
4AD8:  ADDWFC xF8,W
4ADA:  MOVWF  03
4ADC:  MOVLW  05
4ADE:  MOVLB  8
4AE0:  ADDWF  xF7,W
4AE2:  MOVWF  FE9
4AE4:  MOVLW  00
4AE6:  ADDWFC xF8,W
4AE8:  MOVWF  FEA
4AEA:  MOVFF  FEF,904
4AEE:  MOVLB  9
4AF0:  MOVFF  03,FEA
4AF4:  MOVFF  01,FE9
4AF8:  MOVFF  904,FEF
....................       state[5] = state[1]; 
4AFC:  MOVLW  05
4AFE:  MOVLB  8
4B00:  ADDWF  xF7,W
4B02:  MOVWF  01
4B04:  MOVLW  00
4B06:  ADDWFC xF8,W
4B08:  MOVWF  03
4B0A:  MOVLW  01
4B0C:  MOVLB  8
4B0E:  ADDWF  xF7,W
4B10:  MOVWF  FE9
4B12:  MOVLW  00
4B14:  ADDWFC xF8,W
4B16:  MOVWF  FEA
4B18:  MOVFF  FEF,904
4B1C:  MOVLB  9
4B1E:  MOVFF  03,FEA
4B22:  MOVFF  01,FE9
4B26:  MOVFF  904,FEF
....................       state[1] = buf1; 
4B2A:  MOVLW  01
4B2C:  MOVLB  8
4B2E:  ADDWF  xF7,W
4B30:  MOVWF  FE9
4B32:  MOVLW  00
4B34:  ADDWFC xF8,W
4B36:  MOVWF  FEA
4B38:  MOVFF  8FC,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
4B3C:  MOVLW  0A
4B3E:  ADDWF  xF7,W
4B40:  MOVWF  FE9
4B42:  MOVLW  00
4B44:  ADDWFC xF8,W
4B46:  MOVWF  FEA
4B48:  MOVFF  FEF,8FC
....................       buf2 = state[14]; 
4B4C:  MOVLW  0E
4B4E:  ADDWF  xF7,W
4B50:  MOVWF  FE9
4B52:  MOVLW  00
4B54:  ADDWFC xF8,W
4B56:  MOVWF  FEA
4B58:  MOVFF  FEF,8FD
....................       state[10] = state[2]; 
4B5C:  MOVLW  0A
4B5E:  ADDWF  xF7,W
4B60:  MOVWF  01
4B62:  MOVLW  00
4B64:  ADDWFC xF8,W
4B66:  MOVWF  03
4B68:  MOVLW  02
4B6A:  MOVLB  8
4B6C:  ADDWF  xF7,W
4B6E:  MOVWF  FE9
4B70:  MOVLW  00
4B72:  ADDWFC xF8,W
4B74:  MOVWF  FEA
4B76:  MOVFF  FEF,904
4B7A:  MOVLB  9
4B7C:  MOVFF  03,FEA
4B80:  MOVFF  01,FE9
4B84:  MOVFF  904,FEF
....................       state[14] = state[6]; 
4B88:  MOVLW  0E
4B8A:  MOVLB  8
4B8C:  ADDWF  xF7,W
4B8E:  MOVWF  01
4B90:  MOVLW  00
4B92:  ADDWFC xF8,W
4B94:  MOVWF  03
4B96:  MOVLW  06
4B98:  MOVLB  8
4B9A:  ADDWF  xF7,W
4B9C:  MOVWF  FE9
4B9E:  MOVLW  00
4BA0:  ADDWFC xF8,W
4BA2:  MOVWF  FEA
4BA4:  MOVFF  FEF,904
4BA8:  MOVLB  9
4BAA:  MOVFF  03,FEA
4BAE:  MOVFF  01,FE9
4BB2:  MOVFF  904,FEF
....................       state[2] = buf1; 
4BB6:  MOVLW  02
4BB8:  MOVLB  8
4BBA:  ADDWF  xF7,W
4BBC:  MOVWF  FE9
4BBE:  MOVLW  00
4BC0:  ADDWFC xF8,W
4BC2:  MOVWF  FEA
4BC4:  MOVFF  8FC,FEF
....................       state[6] = buf2; 
4BC8:  MOVLW  06
4BCA:  ADDWF  xF7,W
4BCC:  MOVWF  FE9
4BCE:  MOVLW  00
4BD0:  ADDWFC xF8,W
4BD2:  MOVWF  FEA
4BD4:  MOVFF  8FD,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
4BD8:  MOVLW  03
4BDA:  ADDWF  xF7,W
4BDC:  MOVWF  FE9
4BDE:  MOVLW  00
4BE0:  ADDWFC xF8,W
4BE2:  MOVWF  FEA
4BE4:  MOVFF  FEF,8FC
....................       state[3] = state[7]; 
4BE8:  MOVLW  03
4BEA:  ADDWF  xF7,W
4BEC:  MOVWF  01
4BEE:  MOVLW  00
4BF0:  ADDWFC xF8,W
4BF2:  MOVWF  03
4BF4:  MOVLW  07
4BF6:  MOVLB  8
4BF8:  ADDWF  xF7,W
4BFA:  MOVWF  FE9
4BFC:  MOVLW  00
4BFE:  ADDWFC xF8,W
4C00:  MOVWF  FEA
4C02:  MOVFF  FEF,904
4C06:  MOVLB  9
4C08:  MOVFF  03,FEA
4C0C:  MOVFF  01,FE9
4C10:  MOVFF  904,FEF
....................       state[7] = state[11]; 
4C14:  MOVLW  07
4C16:  MOVLB  8
4C18:  ADDWF  xF7,W
4C1A:  MOVWF  01
4C1C:  MOVLW  00
4C1E:  ADDWFC xF8,W
4C20:  MOVWF  03
4C22:  MOVLW  0B
4C24:  MOVLB  8
4C26:  ADDWF  xF7,W
4C28:  MOVWF  FE9
4C2A:  MOVLW  00
4C2C:  ADDWFC xF8,W
4C2E:  MOVWF  FEA
4C30:  MOVFF  FEF,904
4C34:  MOVLB  9
4C36:  MOVFF  03,FEA
4C3A:  MOVFF  01,FE9
4C3E:  MOVFF  904,FEF
....................       state[11] = state[15]; 
4C42:  MOVLW  0B
4C44:  MOVLB  8
4C46:  ADDWF  xF7,W
4C48:  MOVWF  01
4C4A:  MOVLW  00
4C4C:  ADDWFC xF8,W
4C4E:  MOVWF  03
4C50:  MOVLW  0F
4C52:  MOVLB  8
4C54:  ADDWF  xF7,W
4C56:  MOVWF  FE9
4C58:  MOVLW  00
4C5A:  ADDWFC xF8,W
4C5C:  MOVWF  FEA
4C5E:  MOVFF  FEF,904
4C62:  MOVLB  9
4C64:  MOVFF  03,FEA
4C68:  MOVFF  01,FE9
4C6C:  MOVFF  904,FEF
....................       state[15] = buf1;          
4C70:  MOVLW  0F
4C72:  MOVLB  8
4C74:  ADDWF  xF7,W
4C76:  MOVWF  FE9
4C78:  MOVLW  00
4C7A:  ADDWFC xF8,W
4C7C:  MOVWF  FEA
4C7E:  MOVFF  8FC,FEF
....................             
....................       for (i = 0; i <16; i++){ 
4C82:  MOVLB  9
4C84:  CLRF   x01
4C86:  MOVF   x01,W
4C88:  SUBLW  0F
4C8A:  BNC   4CE6
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
4C8C:  CLRF   03
4C8E:  MOVF   x01,W
4C90:  MOVLB  8
4C92:  ADDWF  xF7,W
4C94:  MOVWF  01
4C96:  MOVF   xF8,W
4C98:  ADDWFC 03,F
4C9A:  MOVFF  01,902
4C9E:  MOVLB  9
4CA0:  MOVFF  03,903
4CA4:  CLRF   03
4CA6:  MOVF   x01,W
4CA8:  MOVLB  8
4CAA:  ADDWF  xF7,W
4CAC:  MOVWF  FE9
4CAE:  MOVF   xF8,W
4CB0:  ADDWFC 03,W
4CB2:  MOVWF  FEA
4CB4:  CLRF   03
4CB6:  MOVF   FEF,W
4CB8:  MOVLB  0
4CBA:  CALL   01E0
4CBE:  MOVLB  9
4CC0:  MOVWF  x04
4CC2:  CLRF   03
4CC4:  MOVF   x01,W
4CC6:  MOVLB  8
4CC8:  ADDWF  xF9,W
4CCA:  MOVWF  FE9
4CCC:  MOVF   xFA,W
4CCE:  ADDWFC 03,W
4CD0:  MOVWF  FEA
4CD2:  MOVF   FEF,W
4CD4:  MOVLB  9
4CD6:  XORWF  x04,W
4CD8:  MOVFF  903,FEA
4CDC:  MOVFF  902,FE9
4CE0:  MOVWF  FEF
....................       }  
4CE2:  INCF   x01,F
4CE4:  BRA    4C86
....................     }  
....................     else  
4CE6:  BRA    4E8C
4CE8:  MOVLB  8
....................     { 
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
4CEA:  MOVFF  8F9,01
4CEE:  MOVFF  8FA,03
4CF2:  MOVFF  8F9,902
4CF6:  MOVFF  8FA,903
4CFA:  MOVLW  0D
4CFC:  MOVLB  8
4CFE:  ADDWF  xF9,W
4D00:  MOVWF  FE9
4D02:  MOVLW  00
4D04:  ADDWFC xFA,W
4D06:  MOVWF  FEA
4D08:  CLRF   03
4D0A:  MOVF   FEF,W
4D0C:  MOVLB  0
4D0E:  CALL   00D0
4D12:  MOVLB  9
4D14:  MOVWF  x04
4D16:  MOVLB  8
4D18:  MOVFF  8F9,FE9
4D1C:  MOVFF  8FA,FEA
4D20:  MOVF   FEF,W
4D22:  MOVLB  9
4D24:  XORWF  x04,F
4D26:  CLRF   03
4D28:  MOVF   x00,W
4D2A:  MOVLB  0
4D2C:  CALL   02F0
4D30:  MOVWF  01
4D32:  MOVLB  9
4D34:  MOVF   x04,W
4D36:  XORWF  01,W
4D38:  MOVFF  903,FEA
4D3C:  MOVFF  902,FE9
4D40:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
4D42:  MOVLW  01
4D44:  MOVLB  8
4D46:  ADDWF  xF9,W
4D48:  MOVWF  01
4D4A:  MOVLW  00
4D4C:  ADDWFC xFA,W
4D4E:  MOVWF  03
4D50:  MOVFF  01,902
4D54:  MOVLB  9
4D56:  MOVWF  x03
4D58:  MOVLW  0E
4D5A:  MOVLB  8
4D5C:  ADDWF  xF9,W
4D5E:  MOVWF  FE9
4D60:  MOVLW  00
4D62:  ADDWFC xFA,W
4D64:  MOVWF  FEA
4D66:  CLRF   03
4D68:  MOVF   FEF,W
4D6A:  MOVLB  0
4D6C:  CALL   00D0
4D70:  MOVLB  9
4D72:  MOVWF  x04
4D74:  MOVLW  01
4D76:  MOVLB  8
4D78:  ADDWF  xF9,W
4D7A:  MOVWF  FE9
4D7C:  MOVLW  00
4D7E:  ADDWFC xFA,W
4D80:  MOVWF  FEA
4D82:  MOVF   FEF,W
4D84:  MOVLB  9
4D86:  XORWF  x04,W
4D88:  MOVFF  903,FEA
4D8C:  MOVFF  902,FE9
4D90:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
4D92:  MOVLW  02
4D94:  MOVLB  8
4D96:  ADDWF  xF9,W
4D98:  MOVWF  01
4D9A:  MOVLW  00
4D9C:  ADDWFC xFA,W
4D9E:  MOVWF  03
4DA0:  MOVFF  01,902
4DA4:  MOVLB  9
4DA6:  MOVWF  x03
4DA8:  MOVLW  0F
4DAA:  MOVLB  8
4DAC:  ADDWF  xF9,W
4DAE:  MOVWF  FE9
4DB0:  MOVLW  00
4DB2:  ADDWFC xFA,W
4DB4:  MOVWF  FEA
4DB6:  CLRF   03
4DB8:  MOVF   FEF,W
4DBA:  MOVLB  0
4DBC:  CALL   00D0
4DC0:  MOVLB  9
4DC2:  MOVWF  x04
4DC4:  MOVLW  02
4DC6:  MOVLB  8
4DC8:  ADDWF  xF9,W
4DCA:  MOVWF  FE9
4DCC:  MOVLW  00
4DCE:  ADDWFC xFA,W
4DD0:  MOVWF  FEA
4DD2:  MOVF   FEF,W
4DD4:  MOVLB  9
4DD6:  XORWF  x04,W
4DD8:  MOVFF  903,FEA
4DDC:  MOVFF  902,FE9
4DE0:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
4DE2:  MOVLW  03
4DE4:  MOVLB  8
4DE6:  ADDWF  xF9,W
4DE8:  MOVWF  01
4DEA:  MOVLW  00
4DEC:  ADDWFC xFA,W
4DEE:  MOVWF  03
4DF0:  MOVFF  01,902
4DF4:  MOVLB  9
4DF6:  MOVWF  x03
4DF8:  MOVLW  0C
4DFA:  MOVLB  8
4DFC:  ADDWF  xF9,W
4DFE:  MOVWF  FE9
4E00:  MOVLW  00
4E02:  ADDWFC xFA,W
4E04:  MOVWF  FEA
4E06:  CLRF   03
4E08:  MOVF   FEF,W
4E0A:  MOVLB  0
4E0C:  CALL   00D0
4E10:  MOVLB  9
4E12:  MOVWF  x04
4E14:  MOVLW  03
4E16:  MOVLB  8
4E18:  ADDWF  xF9,W
4E1A:  MOVWF  FE9
4E1C:  MOVLW  00
4E1E:  ADDWFC xFA,W
4E20:  MOVWF  FEA
4E22:  MOVF   FEF,W
4E24:  MOVLB  9
4E26:  XORWF  x04,W
4E28:  MOVFF  903,FEA
4E2C:  MOVFF  902,FE9
4E30:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4E32:  MOVLW  04
4E34:  MOVWF  x01
4E36:  MOVF   x01,W
4E38:  SUBLW  0F
4E3A:  BNC   4E8C
....................         key[i] = key[i] ^ key[i-4]; 
4E3C:  CLRF   03
4E3E:  MOVF   x01,W
4E40:  MOVLB  8
4E42:  ADDWF  xF9,W
4E44:  MOVWF  01
4E46:  MOVF   xFA,W
4E48:  ADDWFC 03,F
4E4A:  MOVLB  9
4E4C:  MOVFF  03,903
4E50:  CLRF   03
4E52:  MOVF   x01,W
4E54:  MOVLB  8
4E56:  ADDWF  xF9,W
4E58:  MOVWF  FE9
4E5A:  MOVF   xFA,W
4E5C:  ADDWFC 03,W
4E5E:  MOVWF  FEA
4E60:  MOVFF  FEF,904
4E64:  MOVLW  04
4E66:  MOVLB  9
4E68:  SUBWF  x01,W
4E6A:  CLRF   03
4E6C:  MOVLB  8
4E6E:  ADDWF  xF9,W
4E70:  MOVWF  FE9
4E72:  MOVF   xFA,W
4E74:  ADDWFC 03,W
4E76:  MOVWF  FEA
4E78:  MOVF   FEF,W
4E7A:  MOVLB  9
4E7C:  XORWF  x04,W
4E7E:  MOVFF  903,FEA
4E82:  MOVFF  01,FE9
4E86:  MOVWF  FEF
....................       } 
4E88:  INCF   x01,F
4E8A:  BRA    4E36
....................     } 
....................   } 
4E8C:  INCF   x00,F
4E8E:  GOTO   430E
....................   if (dir == 0)  
4E92:  MOVLB  8
4E94:  MOVF   xFB,F
4E96:  BNZ   4EF2
....................   { 
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
4E98:  MOVLB  9
4E9A:  CLRF   x01
4E9C:  MOVF   x01,W
4E9E:  SUBLW  0F
4EA0:  BNC   4EF0
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
4EA2:  CLRF   03
4EA4:  MOVF   x01,W
4EA6:  MOVLB  8
4EA8:  ADDWF  xF7,W
4EAA:  MOVWF  01
4EAC:  MOVF   xF8,W
4EAE:  ADDWFC 03,F
4EB0:  MOVLB  9
4EB2:  MOVFF  03,903
4EB6:  CLRF   03
4EB8:  MOVF   x01,W
4EBA:  MOVLB  8
4EBC:  ADDWF  xF7,W
4EBE:  MOVWF  FE9
4EC0:  MOVF   xF8,W
4EC2:  ADDWFC 03,W
4EC4:  MOVWF  FEA
4EC6:  MOVFF  FEF,904
4ECA:  CLRF   03
4ECC:  MOVLB  9
4ECE:  MOVF   x01,W
4ED0:  MOVLB  8
4ED2:  ADDWF  xF9,W
4ED4:  MOVWF  FE9
4ED6:  MOVF   xFA,W
4ED8:  ADDWFC 03,W
4EDA:  MOVWF  FEA
4EDC:  MOVF   FEF,W
4EDE:  MOVLB  9
4EE0:  XORWF  x04,W
4EE2:  MOVFF  903,FEA
4EE6:  MOVFF  01,FE9
4EEA:  MOVWF  FEF
....................     } // enf for 
4EEC:  INCF   x01,F
4EEE:  BRA    4E9C
4EF0:  MOVLB  8
....................   } // end if (!dir) 
.................... } // end function 
4EF2:  MOVLB  0
4EF4:  RETURN 0
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                  
....................  
.................... #define     wideofkeystore      16 
.................... #define     key_numbyte         wideofkeystore-4 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 kp_st=0; 
.................... int8 type_KB=0; 
....................  
.................... int8 key_data[wideofkeystore]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1F7C:  MOVLB  1
1F7E:  INCF   x5B,F
1F80:  MOVF   x5B,W
1F82:  SUBLW  01
1F84:  BTFSC  FD8.0
1F86:  BRA    212A
....................        switch (col) { 
1F88:  MOVF   x5E,W
1F8A:  ADDLW  FB
1F8C:  BC    2010
1F8E:  ADDLW  05
1F90:  MOVLB  0
1F92:  GOTO   2134
....................          case 0   :  
....................                     output_low(COL0); 
1F96:  BCF    F92.5
1F98:  BCF    F89.5
....................                     output_high(COL1); 
1F9A:  BCF    F92.3
1F9C:  BSF    F89.3
....................                     output_high(COL2); 
1F9E:  BCF    F92.2
1FA0:  BSF    F89.2
....................                     output_high(COL3); 
1FA2:  BCF    F92.1
1FA4:  BSF    F89.1
....................                     output_high(COL4); 
1FA6:  BCF    F92.0
1FA8:  BSF    F89.0
....................                     break; 
1FAA:  MOVLB  1
1FAC:  BRA    2010
....................          case 1   :  
....................                     output_low(COL1); 
1FAE:  BCF    F92.3
1FB0:  BCF    F89.3
....................                     output_high(COL0); 
1FB2:  BCF    F92.5
1FB4:  BSF    F89.5
....................                     output_high(COL2); 
1FB6:  BCF    F92.2
1FB8:  BSF    F89.2
....................                     output_high(COL3); 
1FBA:  BCF    F92.1
1FBC:  BSF    F89.1
....................                     output_high(COL4); 
1FBE:  BCF    F92.0
1FC0:  BSF    F89.0
....................                     break; 
1FC2:  MOVLB  1
1FC4:  BRA    2010
....................          case 2   :  
....................                     output_low(COL2); 
1FC6:  BCF    F92.2
1FC8:  BCF    F89.2
....................                     output_high(COL1); 
1FCA:  BCF    F92.3
1FCC:  BSF    F89.3
....................                     output_high(COL0); 
1FCE:  BCF    F92.5
1FD0:  BSF    F89.5
....................                     output_high(COL3); 
1FD2:  BCF    F92.1
1FD4:  BSF    F89.1
....................                     output_high(COL4); 
1FD6:  BCF    F92.0
1FD8:  BSF    F89.0
....................                     break; 
1FDA:  MOVLB  1
1FDC:  BRA    2010
....................          case 3   :  
....................                     output_low(COL3); 
1FDE:  BCF    F92.1
1FE0:  BCF    F89.1
....................                     output_high(COL1); 
1FE2:  BCF    F92.3
1FE4:  BSF    F89.3
....................                     output_high(COL2); 
1FE6:  BCF    F92.2
1FE8:  BSF    F89.2
....................                     output_high(COL0); 
1FEA:  BCF    F92.5
1FEC:  BSF    F89.5
....................                     output_high(COL4); 
1FEE:  BCF    F92.0
1FF0:  BSF    F89.0
....................                     break; 
1FF2:  MOVLB  1
1FF4:  BRA    2010
....................          case 4   :  
....................                     output_low(COL4); 
1FF6:  BCF    F92.0
1FF8:  BCF    F89.0
....................                     output_high(COL1); 
1FFA:  BCF    F92.3
1FFC:  BSF    F89.3
....................                     output_high(COL2); 
1FFE:  BCF    F92.2
2000:  BSF    F89.2
....................                     output_high(COL3); 
2002:  BCF    F92.1
2004:  BSF    F89.1
....................                     output_high(COL0); 
2006:  BCF    F92.5
2008:  BSF    F89.5
....................                     break; 
200A:  MOVLB  1
200C:  BRA    2010
200E:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2010:  BTFSS  x5C.0
2012:  BRA    2090
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2014:  BSF    F93.4
2016:  MOVLW  00
2018:  BTFSC  F81.4
201A:  MOVLW  01
201C:  MOVLB  8
201E:  MOVWF  x52
2020:  BSF    F93.5
2022:  MOVLW  00
2024:  BTFSC  F81.5
2026:  MOVLW  01
2028:  ANDWF  x52,F
202A:  BSF    F93.6
202C:  MOVLW  00
202E:  BTFSC  F81.6
2030:  MOVLW  01
2032:  ANDWF  x52,F
2034:  BSF    F93.7
2036:  MOVLW  00
2038:  BTFSC  F81.7
203A:  MOVLW  01
203C:  ANDWF  x52,W
203E:  BZ    208C
....................          { 
....................             kchar=last_key; 
2040:  MOVFF  15D,850
....................             if(keydebug_en==0) 
2044:  MOVLB  1
2046:  MOVF   x44,F
2048:  BNZ   207A
....................             { 
....................                 //count_timer0=0; 
....................                 charac_timeout=0; 
204A:  CLRF   x00
204C:  MOVLB  0
204E:  CLRF   xFF
....................                 if(key_count_ms<wideofkeystore) 
2050:  MOVLB  1
2052:  MOVF   x47,W
2054:  SUBLW  0F
2056:  BNC   2078
....................                 { 
....................                     key_data[key_count_ms++]=kchar; 
2058:  MOVF   x47,W
205A:  INCF   x47,F
205C:  CLRF   03
205E:  ADDLW  4A
2060:  MOVWF  FE9
2062:  MOVLW  01
2064:  ADDWFC 03,W
2066:  MOVWF  FEA
2068:  MOVFF  850,FEF
....................                     fputc(kchar,COM2); 
206C:  MOVFF  850,90C
2070:  MOVLB  0
2072:  CALL   1604
2076:  MOVLB  1
....................                 } 
....................             } 
....................                else fputc(kchar,COM2); 
2078:  BRA    2086
207A:  MOVFF  850,90C
207E:  MOVLB  0
2080:  CALL   1604
2084:  MOVLB  1
....................            kbd_down=FALSE; 
2086:  BCF    x5C.0
....................            last_key=0; 
2088:  CLRF   x5D
208A:  MOVLB  8
....................          } 
....................        } else 
208C:  BRA    2126
208E:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
2090:  BSF    F93.4
2092:  MOVLW  00
2094:  BTFSC  F81.4
2096:  MOVLW  01
2098:  MOVLB  8
209A:  MOVWF  x52
209C:  BSF    F93.5
209E:  MOVLW  00
20A0:  BTFSC  F81.5
20A2:  MOVLW  01
20A4:  ANDWF  x52,F
20A6:  BSF    F93.6
20A8:  MOVLW  00
20AA:  BTFSC  F81.6
20AC:  MOVLW  01
20AE:  ANDWF  x52,F
20B0:  BSF    F93.7
20B2:  MOVLW  00
20B4:  BTFSC  F81.7
20B6:  MOVLW  01
20B8:  ANDWF  x52,W
20BA:  BNZ   211A
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
20BC:  BSF    F93.4
20BE:  BTFSC  F81.4
20C0:  BRA    20C6
....................                   row=0; 
20C2:  CLRF   x51
....................                 else if(input(ROW1)==0) 
20C4:  BRA    20E8
20C6:  BSF    F93.5
20C8:  BTFSC  F81.5
20CA:  BRA    20D2
....................                   row=1; 
20CC:  MOVLW  01
20CE:  MOVWF  x51
....................                 else if(input(ROW2)==0) 
20D0:  BRA    20E8
20D2:  BSF    F93.6
20D4:  BTFSC  F81.6
20D6:  BRA    20DE
....................                   row=2; 
20D8:  MOVLW  02
20DA:  MOVWF  x51
....................                 else if(input(ROW3)==0) 
20DC:  BRA    20E8
20DE:  BSF    F93.7
20E0:  BTFSC  F81.7
20E2:  BRA    20E8
....................                   row=3; 
20E4:  MOVLW  03
20E6:  MOVWF  x51
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
20E8:  MOVF   x51,W
20EA:  MULLW  05
20EC:  MOVF   FF3,W
20EE:  CLRF   x53
20F0:  MOVWF  x52
20F2:  CLRF   03
20F4:  MOVLB  1
20F6:  MOVF   x5E,W
20F8:  MOVLB  8
20FA:  ADDWF  x52,W
20FC:  MOVWF  01
20FE:  MOVF   x53,W
2100:  ADDWFC 03,F
2102:  MOVF   01,W
2104:  MOVLB  0
2106:  CALL   030A
210A:  MOVFF  FE8,15D
....................                 kbd_down = TRUE; 
210E:  MOVLB  1
2110:  BSF    x5C.0
....................                 set_tris_a(0xff); 
2112:  MOVLW  FF
2114:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2116:  BRA    2126
2118:  MOVLB  8
....................                { 
....................                   ++col; 
211A:  MOVLB  1
211C:  INCF   x5E,F
....................                   if(col==5) col=0; 
211E:  MOVF   x5E,W
2120:  SUBLW  05
2122:  BTFSC  FD8.2
2124:  CLRF   x5E
....................                } 
....................          } 
....................       kbd_call_count=0; 
2126:  MOVLB  1
2128:  CLRF   x5B
....................    } 
....................   return(kchar); 
212A:  MOVLB  8
212C:  MOVFF  850,01
.................... } 
2130:  MOVLB  0
2132:  RETURN 0
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2158:  MOVLW  E0
215A:  MOVLB  F
215C:  MOVWF  x48
215E:  BCF    FC2.6
2160:  BCF    FC2.7
2162:  MOVF   x49,W
2164:  ANDLW  E0
2166:  IORLW  17
2168:  MOVWF  x49
....................    switch(col) 
....................    { 
216A:  MOVLB  8
216C:  MOVF   x6D,W
216E:  ADDLW  FA
2170:  BC    223C
2172:  ADDLW  06
2174:  MOVLB  0
2176:  GOTO   2240
....................       case 0: 
....................         set_adc_channel(4); 
217A:  MOVLW  10
217C:  MOVWF  01
217E:  MOVF   FC2,W
2180:  ANDLW  C3
2182:  IORWF  01,W
2184:  MOVWF  FC2
....................         adc=read_adc(); 
2186:  BSF    FC2.1
2188:  BTFSC  FC2.1
218A:  BRA    2188
218C:  MOVFF  FC4,86E
....................         return adc; 
2190:  MOVLB  8
2192:  MOVFF  86E,01
2196:  BRA    223C
....................       break; 
2198:  BRA    223C
....................       case 1: 
....................         set_adc_channel(3); 
219A:  MOVLW  0C
219C:  MOVWF  01
219E:  MOVF   FC2,W
21A0:  ANDLW  C3
21A2:  IORWF  01,W
21A4:  MOVWF  FC2
....................         adc=read_adc(); 
21A6:  BSF    FC2.1
21A8:  BTFSC  FC2.1
21AA:  BRA    21A8
21AC:  MOVFF  FC4,86E
....................         return adc; 
21B0:  MOVLB  8
21B2:  MOVFF  86E,01
21B6:  BRA    223C
....................       break; 
21B8:  BRA    223C
....................       case 2: 
....................         set_adc_channel(2); 
21BA:  MOVLW  08
21BC:  MOVWF  01
21BE:  MOVF   FC2,W
21C0:  ANDLW  C3
21C2:  IORWF  01,W
21C4:  MOVWF  FC2
....................         adc=read_adc(); 
21C6:  BSF    FC2.1
21C8:  BTFSC  FC2.1
21CA:  BRA    21C8
21CC:  MOVFF  FC4,86E
....................         return adc; 
21D0:  MOVLB  8
21D2:  MOVFF  86E,01
21D6:  BRA    223C
....................       break; 
21D8:  BRA    223C
....................       case 3: 
....................         set_adc_channel(1); 
21DA:  MOVLW  04
21DC:  MOVWF  01
21DE:  MOVF   FC2,W
21E0:  ANDLW  C3
21E2:  IORWF  01,W
21E4:  MOVWF  FC2
....................         adc=read_adc(); 
21E6:  BSF    FC2.1
21E8:  BTFSC  FC2.1
21EA:  BRA    21E8
21EC:  MOVFF  FC4,86E
....................         return adc; 
21F0:  MOVLB  8
21F2:  MOVFF  86E,01
21F6:  BRA    223C
....................       break; 
21F8:  BRA    223C
....................       case 4: 
....................         set_adc_channel(0); 
21FA:  MOVLW  00
21FC:  MOVWF  01
21FE:  MOVF   FC2,W
2200:  ANDLW  C3
2202:  IORWF  01,W
2204:  MOVWF  FC2
....................         adc=read_adc(); 
2206:  BSF    FC2.1
2208:  BTFSC  FC2.1
220A:  BRA    2208
220C:  MOVFF  FC4,86E
....................         return adc; 
2210:  MOVLB  8
2212:  MOVFF  86E,01
2216:  BRA    223C
....................       break;      
2218:  BRA    223C
....................       case 5: 
....................         set_adc_channel(11); 
221A:  MOVLW  2C
221C:  MOVWF  01
221E:  MOVF   FC2,W
2220:  ANDLW  C3
2222:  IORWF  01,W
2224:  MOVWF  FC2
....................         adc=read_adc(); 
2226:  BSF    FC2.1
2228:  BTFSC  FC2.1
222A:  BRA    2228
222C:  MOVFF  FC4,86E
....................         return adc; 
2230:  MOVLB  8
2232:  MOVFF  86E,01
2236:  BRA    223C
....................       break;      
2238:  BRA    223C
223A:  MOVLB  8
....................    } 
.................... } 
223C:  MOVLB  0
223E:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
23C0:  MOVLB  8
23C2:  CLRF   x58
23C4:  CLRF   x57
23C6:  CLRF   x56
23C8:  CLRF   x55
23CA:  CLRF   x5C
23CC:  CLRF   x5B
23CE:  CLRF   x5A
23D0:  CLRF   x59
23D2:  CLRF   x60
23D4:  CLRF   x5F
23D6:  CLRF   x5E
23D8:  CLRF   x5D
23DA:  CLRF   x64
23DC:  CLRF   x63
23DE:  CLRF   x62
23E0:  CLRF   x61
23E2:  CLRF   x68
23E4:  CLRF   x67
23E6:  CLRF   x66
23E8:  CLRF   x65
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
23EA:  CLRF   x54
23EC:  CLRF   x53
23EE:  MOVF   x54,W
23F0:  SUBLW  01
23F2:  BNC   2470
23F4:  BNZ   23FC
23F6:  MOVF   x53,W
23F8:  SUBLW  F3
23FA:  BNC   2470
....................    { 
....................       col_0=read_col(0)+col_0; 
23FC:  CLRF   x6D
23FE:  MOVLB  0
2400:  RCALL  2158
2402:  MOVF   01,W
2404:  MOVLB  8
2406:  ADDWF  x55,F
2408:  MOVLW  00
240A:  ADDWFC x56,F
240C:  ADDWFC x57,F
240E:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2410:  MOVLW  01
2412:  MOVWF  x6D
2414:  MOVLB  0
2416:  RCALL  2158
2418:  MOVF   01,W
241A:  MOVLB  8
241C:  ADDWF  x59,F
241E:  MOVLW  00
2420:  ADDWFC x5A,F
2422:  ADDWFC x5B,F
2424:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
2426:  MOVLW  02
2428:  MOVWF  x6D
242A:  MOVLB  0
242C:  RCALL  2158
242E:  MOVF   01,W
2430:  MOVLB  8
2432:  ADDWF  x5D,F
2434:  MOVLW  00
2436:  ADDWFC x5E,F
2438:  ADDWFC x5F,F
243A:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
243C:  MOVLW  03
243E:  MOVWF  x6D
2440:  MOVLB  0
2442:  RCALL  2158
2444:  MOVF   01,W
2446:  MOVLB  8
2448:  ADDWF  x61,F
244A:  MOVLW  00
244C:  ADDWFC x62,F
244E:  ADDWFC x63,F
2450:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
2452:  MOVLW  04
2454:  MOVWF  x6D
2456:  MOVLB  0
2458:  RCALL  2158
245A:  MOVF   01,W
245C:  MOVLB  8
245E:  ADDWF  x65,F
2460:  MOVLW  00
2462:  ADDWFC x66,F
2464:  ADDWFC x67,F
2466:  ADDWFC x68,F
....................    } 
2468:  INCF   x53,F
246A:  BTFSC  FD8.2
246C:  INCF   x54,F
246E:  BRA    23EE
....................    col_0=col_0/500; 
2470:  BCF    FD8.1
2472:  MOVFF  858,90F
2476:  MOVFF  857,90E
247A:  MOVFF  856,90D
247E:  MOVFF  855,90C
2482:  MOVLB  9
2484:  CLRF   x13
2486:  CLRF   x12
2488:  MOVLW  01
248A:  MOVWF  x11
248C:  MOVLW  F4
248E:  MOVWF  x10
2490:  MOVLB  0
2492:  RCALL  2266
2494:  MOVFF  03,858
2498:  MOVFF  02,857
249C:  MOVFF  01,856
24A0:  MOVFF  00,855
....................    col_1=col_1/500; 
24A4:  BCF    FD8.1
24A6:  MOVFF  85C,90F
24AA:  MOVFF  85B,90E
24AE:  MOVFF  85A,90D
24B2:  MOVFF  859,90C
24B6:  MOVLB  9
24B8:  CLRF   x13
24BA:  CLRF   x12
24BC:  MOVLW  01
24BE:  MOVWF  x11
24C0:  MOVLW  F4
24C2:  MOVWF  x10
24C4:  MOVLB  0
24C6:  RCALL  2266
24C8:  MOVFF  03,85C
24CC:  MOVFF  02,85B
24D0:  MOVFF  01,85A
24D4:  MOVFF  00,859
....................    col_2=col_2/500; 
24D8:  BCF    FD8.1
24DA:  MOVFF  860,90F
24DE:  MOVFF  85F,90E
24E2:  MOVFF  85E,90D
24E6:  MOVFF  85D,90C
24EA:  MOVLB  9
24EC:  CLRF   x13
24EE:  CLRF   x12
24F0:  MOVLW  01
24F2:  MOVWF  x11
24F4:  MOVLW  F4
24F6:  MOVWF  x10
24F8:  MOVLB  0
24FA:  RCALL  2266
24FC:  MOVFF  03,860
2500:  MOVFF  02,85F
2504:  MOVFF  01,85E
2508:  MOVFF  00,85D
....................    col_3=col_3/500; 
250C:  BCF    FD8.1
250E:  MOVFF  864,90F
2512:  MOVFF  863,90E
2516:  MOVFF  862,90D
251A:  MOVFF  861,90C
251E:  MOVLB  9
2520:  CLRF   x13
2522:  CLRF   x12
2524:  MOVLW  01
2526:  MOVWF  x11
2528:  MOVLW  F4
252A:  MOVWF  x10
252C:  MOVLB  0
252E:  RCALL  2266
2530:  MOVFF  03,864
2534:  MOVFF  02,863
2538:  MOVFF  01,862
253C:  MOVFF  00,861
....................    col_4=col_4/500; 
2540:  BCF    FD8.1
2542:  MOVFF  868,90F
2546:  MOVFF  867,90E
254A:  MOVFF  866,90D
254E:  MOVFF  865,90C
2552:  MOVLB  9
2554:  CLRF   x13
2556:  CLRF   x12
2558:  MOVLW  01
255A:  MOVWF  x11
255C:  MOVLW  F4
255E:  MOVWF  x10
2560:  MOVLB  0
2562:  RCALL  2266
2564:  MOVFF  03,868
2568:  MOVFF  02,867
256C:  MOVFF  01,866
2570:  MOVFF  00,865
....................    if(keydebug_en) 
2574:  MOVLB  1
2576:  MOVF   x44,F
2578:  BTFSC  FD8.2
257A:  BRA    26F6
....................    { 
....................       fprintf(COM2,"\r\n");      
257C:  MOVLW  0D
257E:  MOVLB  9
2580:  MOVWF  x0C
2582:  MOVLB  0
2584:  CALL   1604
2588:  MOVLW  0A
258A:  MOVLB  9
258C:  MOVWF  x0C
258E:  MOVLB  0
2590:  CALL   1604
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2594:  MOVLW  BC
2596:  MOVWF  FF6
2598:  MOVLW  04
259A:  MOVWF  FF7
259C:  MOVLW  07
259E:  MOVLB  8
25A0:  MOVWF  xF7
25A2:  MOVLB  0
25A4:  CALL   164A
25A8:  MOVLW  41
25AA:  MOVWF  FE9
25AC:  MOVFF  858,8FA
25B0:  MOVFF  857,8F9
25B4:  MOVFF  856,8F8
25B8:  MOVFF  855,8F7
25BC:  RCALL  22FA
25BE:  MOVLW  0D
25C0:  MOVLB  9
25C2:  MOVWF  x0C
25C4:  MOVLB  0
25C6:  CALL   1604
25CA:  MOVLW  0A
25CC:  MOVLB  9
25CE:  MOVWF  x0C
25D0:  MOVLB  0
25D2:  CALL   1604
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
25D6:  MOVLW  CA
25D8:  MOVWF  FF6
25DA:  MOVLW  04
25DC:  MOVWF  FF7
25DE:  MOVLW  07
25E0:  MOVLB  8
25E2:  MOVWF  xF7
25E4:  MOVLB  0
25E6:  CALL   164A
25EA:  MOVLW  41
25EC:  MOVWF  FE9
25EE:  MOVFF  85C,8FA
25F2:  MOVFF  85B,8F9
25F6:  MOVFF  85A,8F8
25FA:  MOVFF  859,8F7
25FE:  RCALL  22FA
2600:  MOVLW  0D
2602:  MOVLB  9
2604:  MOVWF  x0C
2606:  MOVLB  0
2608:  CALL   1604
260C:  MOVLW  0A
260E:  MOVLB  9
2610:  MOVWF  x0C
2612:  MOVLB  0
2614:  CALL   1604
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2618:  MOVLW  D8
261A:  MOVWF  FF6
261C:  MOVLW  04
261E:  MOVWF  FF7
2620:  MOVLW  07
2622:  MOVLB  8
2624:  MOVWF  xF7
2626:  MOVLB  0
2628:  CALL   164A
262C:  MOVLW  41
262E:  MOVWF  FE9
2630:  MOVFF  860,8FA
2634:  MOVFF  85F,8F9
2638:  MOVFF  85E,8F8
263C:  MOVFF  85D,8F7
2640:  RCALL  22FA
2642:  MOVLW  0D
2644:  MOVLB  9
2646:  MOVWF  x0C
2648:  MOVLB  0
264A:  CALL   1604
264E:  MOVLW  0A
2650:  MOVLB  9
2652:  MOVWF  x0C
2654:  MOVLB  0
2656:  CALL   1604
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
265A:  MOVLW  E6
265C:  MOVWF  FF6
265E:  MOVLW  04
2660:  MOVWF  FF7
2662:  MOVLW  07
2664:  MOVLB  8
2666:  MOVWF  xF7
2668:  MOVLB  0
266A:  CALL   164A
266E:  MOVLW  41
2670:  MOVWF  FE9
2672:  MOVFF  864,8FA
2676:  MOVFF  863,8F9
267A:  MOVFF  862,8F8
267E:  MOVFF  861,8F7
2682:  RCALL  22FA
2684:  MOVLW  0D
2686:  MOVLB  9
2688:  MOVWF  x0C
268A:  MOVLB  0
268C:  CALL   1604
2690:  MOVLW  0A
2692:  MOVLB  9
2694:  MOVWF  x0C
2696:  MOVLB  0
2698:  CALL   1604
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
269C:  MOVLW  F4
269E:  MOVWF  FF6
26A0:  MOVLW  04
26A2:  MOVWF  FF7
26A4:  MOVLW  07
26A6:  MOVLB  8
26A8:  MOVWF  xF7
26AA:  MOVLB  0
26AC:  CALL   164A
26B0:  MOVLW  41
26B2:  MOVWF  FE9
26B4:  MOVFF  868,8FA
26B8:  MOVFF  867,8F9
26BC:  MOVFF  866,8F8
26C0:  MOVFF  865,8F7
26C4:  RCALL  22FA
26C6:  MOVLW  0D
26C8:  MOVLB  9
26CA:  MOVWF  x0C
26CC:  MOVLB  0
26CE:  CALL   1604
26D2:  MOVLW  0A
26D4:  MOVLB  9
26D6:  MOVWF  x0C
26D8:  MOVLB  0
26DA:  CALL   1604
....................       fprintf(COM2,"\r\n"); 
26DE:  MOVLW  0D
26E0:  MOVLB  9
26E2:  MOVWF  x0C
26E4:  MOVLB  0
26E6:  CALL   1604
26EA:  MOVLW  0A
26EC:  MOVLB  9
26EE:  MOVWF  x0C
26F0:  MOVLB  0
26F2:  CALL   1604
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
26F6:  MOVLB  8
26F8:  MOVF   x58,F
26FA:  BNZ   270A
26FC:  MOVF   x57,F
26FE:  BNZ   270A
2700:  MOVF   x56,F
2702:  BNZ   270A
2704:  MOVF   x55,W
2706:  SUBLW  05
2708:  BC    276A
270A:  MOVF   x58,F
270C:  BNZ   276A
270E:  MOVF   x57,F
2710:  BNZ   276A
2712:  MOVF   x56,F
2714:  BNZ   276A
2716:  MOVF   x55,W
2718:  SUBLW  3B
271A:  BNC   276A
271C:  MOVF   x5C,F
271E:  BNZ   272E
2720:  MOVF   x5B,F
2722:  BNZ   272E
2724:  MOVF   x5A,F
2726:  BNZ   272E
2728:  MOVF   x59,W
272A:  SUBLW  64
272C:  BC    276A
272E:  MOVF   x60,F
2730:  BNZ   2740
2732:  MOVF   x5F,F
2734:  BNZ   2740
2736:  MOVF   x5E,F
2738:  BNZ   2740
273A:  MOVF   x5D,W
273C:  SUBLW  64
273E:  BC    276A
2740:  MOVF   x64,F
2742:  BNZ   2752
2744:  MOVF   x63,F
2746:  BNZ   2752
2748:  MOVF   x62,F
274A:  BNZ   2752
274C:  MOVF   x61,W
274E:  SUBLW  64
2750:  BC    276A
2752:  MOVF   x68,F
2754:  BNZ   2764
2756:  MOVF   x67,F
2758:  BNZ   2764
275A:  MOVF   x66,F
275C:  BNZ   2764
275E:  MOVF   x65,W
2760:  SUBLW  64
2762:  BC    276A
2764:  MOVLW  00
2766:  MOVWF  01
2768:  BRA    29E8
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
276A:  MOVF   x5C,F
276C:  BNZ   277C
276E:  MOVF   x5B,F
2770:  BNZ   277C
2772:  MOVF   x5A,F
2774:  BNZ   277C
2776:  MOVF   x59,W
2778:  SUBLW  05
277A:  BC    27DC
277C:  MOVF   x5C,F
277E:  BNZ   27DC
2780:  MOVF   x5B,F
2782:  BNZ   27DC
2784:  MOVF   x5A,F
2786:  BNZ   27DC
2788:  MOVF   x59,W
278A:  SUBLW  3B
278C:  BNC   27DC
278E:  MOVF   x58,F
2790:  BNZ   27A0
2792:  MOVF   x57,F
2794:  BNZ   27A0
2796:  MOVF   x56,F
2798:  BNZ   27A0
279A:  MOVF   x55,W
279C:  SUBLW  64
279E:  BC    27DC
27A0:  MOVF   x60,F
27A2:  BNZ   27B2
27A4:  MOVF   x5F,F
27A6:  BNZ   27B2
27A8:  MOVF   x5E,F
27AA:  BNZ   27B2
27AC:  MOVF   x5D,W
27AE:  SUBLW  64
27B0:  BC    27DC
27B2:  MOVF   x64,F
27B4:  BNZ   27C4
27B6:  MOVF   x63,F
27B8:  BNZ   27C4
27BA:  MOVF   x62,F
27BC:  BNZ   27C4
27BE:  MOVF   x61,W
27C0:  SUBLW  64
27C2:  BC    27DC
27C4:  MOVF   x68,F
27C6:  BNZ   27D6
27C8:  MOVF   x67,F
27CA:  BNZ   27D6
27CC:  MOVF   x66,F
27CE:  BNZ   27D6
27D0:  MOVF   x65,W
27D2:  SUBLW  64
27D4:  BC    27DC
27D6:  MOVLW  01
27D8:  MOVWF  01
27DA:  BRA    29E8
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
27DC:  MOVF   x60,F
27DE:  BNZ   27EE
27E0:  MOVF   x5F,F
27E2:  BNZ   27EE
27E4:  MOVF   x5E,F
27E6:  BNZ   27EE
27E8:  MOVF   x5D,W
27EA:  SUBLW  05
27EC:  BC    284E
27EE:  MOVF   x60,F
27F0:  BNZ   284E
27F2:  MOVF   x5F,F
27F4:  BNZ   284E
27F6:  MOVF   x5E,F
27F8:  BNZ   284E
27FA:  MOVF   x5D,W
27FC:  SUBLW  3B
27FE:  BNC   284E
2800:  MOVF   x5C,F
2802:  BNZ   2812
2804:  MOVF   x5B,F
2806:  BNZ   2812
2808:  MOVF   x5A,F
280A:  BNZ   2812
280C:  MOVF   x59,W
280E:  SUBLW  64
2810:  BC    284E
2812:  MOVF   x58,F
2814:  BNZ   2824
2816:  MOVF   x57,F
2818:  BNZ   2824
281A:  MOVF   x56,F
281C:  BNZ   2824
281E:  MOVF   x55,W
2820:  SUBLW  64
2822:  BC    284E
2824:  MOVF   x64,F
2826:  BNZ   2836
2828:  MOVF   x63,F
282A:  BNZ   2836
282C:  MOVF   x62,F
282E:  BNZ   2836
2830:  MOVF   x61,W
2832:  SUBLW  64
2834:  BC    284E
2836:  MOVF   x68,F
2838:  BNZ   2848
283A:  MOVF   x67,F
283C:  BNZ   2848
283E:  MOVF   x66,F
2840:  BNZ   2848
2842:  MOVF   x65,W
2844:  SUBLW  64
2846:  BC    284E
2848:  MOVLW  02
284A:  MOVWF  01
284C:  BRA    29E8
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
284E:  MOVF   x64,F
2850:  BNZ   2860
2852:  MOVF   x63,F
2854:  BNZ   2860
2856:  MOVF   x62,F
2858:  BNZ   2860
285A:  MOVF   x61,W
285C:  SUBLW  05
285E:  BC    28C0
2860:  MOVF   x64,F
2862:  BNZ   28C0
2864:  MOVF   x63,F
2866:  BNZ   28C0
2868:  MOVF   x62,F
286A:  BNZ   28C0
286C:  MOVF   x61,W
286E:  SUBLW  3B
2870:  BNC   28C0
2872:  MOVF   x5C,F
2874:  BNZ   2884
2876:  MOVF   x5B,F
2878:  BNZ   2884
287A:  MOVF   x5A,F
287C:  BNZ   2884
287E:  MOVF   x59,W
2880:  SUBLW  64
2882:  BC    28C0
2884:  MOVF   x60,F
2886:  BNZ   2896
2888:  MOVF   x5F,F
288A:  BNZ   2896
288C:  MOVF   x5E,F
288E:  BNZ   2896
2890:  MOVF   x5D,W
2892:  SUBLW  64
2894:  BC    28C0
2896:  MOVF   x58,F
2898:  BNZ   28A8
289A:  MOVF   x57,F
289C:  BNZ   28A8
289E:  MOVF   x56,F
28A0:  BNZ   28A8
28A2:  MOVF   x55,W
28A4:  SUBLW  64
28A6:  BC    28C0
28A8:  MOVF   x68,F
28AA:  BNZ   28BA
28AC:  MOVF   x67,F
28AE:  BNZ   28BA
28B0:  MOVF   x66,F
28B2:  BNZ   28BA
28B4:  MOVF   x65,W
28B6:  SUBLW  64
28B8:  BC    28C0
28BA:  MOVLW  03
28BC:  MOVWF  01
28BE:  BRA    29E8
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
28C0:  MOVF   x68,F
28C2:  BNZ   28D2
28C4:  MOVF   x67,F
28C6:  BNZ   28D2
28C8:  MOVF   x66,F
28CA:  BNZ   28D2
28CC:  MOVF   x65,W
28CE:  SUBLW  05
28D0:  BC    2932
28D2:  MOVF   x68,F
28D4:  BNZ   2932
28D6:  MOVF   x67,F
28D8:  BNZ   2932
28DA:  MOVF   x66,F
28DC:  BNZ   2932
28DE:  MOVF   x65,W
28E0:  SUBLW  3B
28E2:  BNC   2932
28E4:  MOVF   x5C,F
28E6:  BNZ   28F6
28E8:  MOVF   x5B,F
28EA:  BNZ   28F6
28EC:  MOVF   x5A,F
28EE:  BNZ   28F6
28F0:  MOVF   x59,W
28F2:  SUBLW  64
28F4:  BC    2932
28F6:  MOVF   x60,F
28F8:  BNZ   2908
28FA:  MOVF   x5F,F
28FC:  BNZ   2908
28FE:  MOVF   x5E,F
2900:  BNZ   2908
2902:  MOVF   x5D,W
2904:  SUBLW  64
2906:  BC    2932
2908:  MOVF   x64,F
290A:  BNZ   291A
290C:  MOVF   x63,F
290E:  BNZ   291A
2910:  MOVF   x62,F
2912:  BNZ   291A
2914:  MOVF   x61,W
2916:  SUBLW  64
2918:  BC    2932
291A:  MOVF   x58,F
291C:  BNZ   292C
291E:  MOVF   x57,F
2920:  BNZ   292C
2922:  MOVF   x56,F
2924:  BNZ   292C
2926:  MOVF   x55,W
2928:  SUBLW  64
292A:  BC    2932
292C:  MOVLW  04
292E:  MOVWF  01
2930:  BRA    29E8
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2932:  MOVF   x68,F
2934:  BNZ   2946
2936:  MOVF   x67,F
2938:  BNZ   2946
293A:  MOVF   x66,F
293C:  BNZ   2946
293E:  MOVF   x65,W
2940:  SUBLW  C8
2942:  BTFSC  FD8.0
2944:  BRA    29E4
2946:  MOVF   x58,F
2948:  BTFSS  FD8.2
294A:  BRA    29E4
294C:  MOVF   x57,F
294E:  BTFSS  FD8.2
2950:  BRA    29E4
2952:  MOVF   x56,F
2954:  BTFSS  FD8.2
2956:  BRA    29E4
2958:  MOVF   x55,W
295A:  SUBLW  B3
295C:  BNC   29E4
295E:  MOVF   x58,F
2960:  BNZ   2970
2962:  MOVF   x57,F
2964:  BNZ   2970
2966:  MOVF   x56,F
2968:  BNZ   2970
296A:  MOVF   x55,W
296C:  SUBLW  64
296E:  BC    29E4
2970:  MOVF   x5C,F
2972:  BNZ   29E4
2974:  MOVF   x5B,F
2976:  BNZ   29E4
2978:  MOVF   x5A,F
297A:  BNZ   29E4
297C:  MOVF   x59,W
297E:  SUBLW  B3
2980:  BNC   29E4
2982:  MOVF   x5C,F
2984:  BNZ   2994
2986:  MOVF   x5B,F
2988:  BNZ   2994
298A:  MOVF   x5A,F
298C:  BNZ   2994
298E:  MOVF   x59,W
2990:  SUBLW  64
2992:  BC    29E4
2994:  MOVF   x60,F
2996:  BNZ   29E4
2998:  MOVF   x5F,F
299A:  BNZ   29E4
299C:  MOVF   x5E,F
299E:  BNZ   29E4
29A0:  MOVF   x5D,W
29A2:  SUBLW  B3
29A4:  BNC   29E4
29A6:  MOVF   x60,F
29A8:  BNZ   29B8
29AA:  MOVF   x5F,F
29AC:  BNZ   29B8
29AE:  MOVF   x5E,F
29B0:  BNZ   29B8
29B2:  MOVF   x5D,W
29B4:  SUBLW  64
29B6:  BC    29E4
29B8:  MOVF   x64,F
29BA:  BNZ   29E4
29BC:  MOVF   x63,F
29BE:  BNZ   29E4
29C0:  MOVF   x62,F
29C2:  BNZ   29E4
29C4:  MOVF   x61,W
29C6:  SUBLW  B3
29C8:  BNC   29E4
29CA:  MOVF   x64,F
29CC:  BNZ   29DC
29CE:  MOVF   x63,F
29D0:  BNZ   29DC
29D2:  MOVF   x62,F
29D4:  BNZ   29DC
29D6:  MOVF   x61,W
29D8:  SUBLW  64
29DA:  BC    29E4
29DC:  MOVLW  04
29DE:  MOVWF  01
29E0:  BRA    29E8
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
29E2:  BRA    29E8
29E4:  MOVLW  FF
29E6:  MOVWF  01
.................... } 
29E8:  MOVLB  0
29EA:  GOTO   3236 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
29EE:  MOVLB  8
29F0:  CLRF   x58
29F2:  CLRF   x57
29F4:  CLRF   x56
29F6:  CLRF   x55
29F8:  CLRF   x5C
29FA:  CLRF   x5B
29FC:  CLRF   x5A
29FE:  CLRF   x59
2A00:  CLRF   x60
2A02:  CLRF   x5F
2A04:  CLRF   x5E
2A06:  CLRF   x5D
2A08:  CLRF   x64
2A0A:  CLRF   x63
2A0C:  CLRF   x62
2A0E:  CLRF   x61
2A10:  CLRF   x68
2A12:  CLRF   x67
2A14:  CLRF   x66
2A16:  CLRF   x65
2A18:  CLRF   x6C
2A1A:  CLRF   x6B
2A1C:  CLRF   x6A
2A1E:  CLRF   x69
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2A20:  CLRF   x54
2A22:  CLRF   x53
2A24:  MOVF   x54,W
2A26:  SUBLW  01
2A28:  BNC   2AC8
2A2A:  BNZ   2A32
2A2C:  MOVF   x53,W
2A2E:  SUBLW  F3
2A30:  BNC   2AC8
....................    { 
....................       col_0=read_col(0)+col_0; 
2A32:  CLRF   x6D
2A34:  MOVLB  0
2A36:  CALL   2158
2A3A:  MOVF   01,W
2A3C:  MOVLB  8
2A3E:  ADDWF  x55,F
2A40:  MOVLW  00
2A42:  ADDWFC x56,F
2A44:  ADDWFC x57,F
2A46:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2A48:  MOVLW  01
2A4A:  MOVWF  x6D
2A4C:  MOVLB  0
2A4E:  CALL   2158
2A52:  MOVF   01,W
2A54:  MOVLB  8
2A56:  ADDWF  x59,F
2A58:  MOVLW  00
2A5A:  ADDWFC x5A,F
2A5C:  ADDWFC x5B,F
2A5E:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
2A60:  MOVLW  02
2A62:  MOVWF  x6D
2A64:  MOVLB  0
2A66:  CALL   2158
2A6A:  MOVF   01,W
2A6C:  MOVLB  8
2A6E:  ADDWF  x5D,F
2A70:  MOVLW  00
2A72:  ADDWFC x5E,F
2A74:  ADDWFC x5F,F
2A76:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
2A78:  MOVLW  03
2A7A:  MOVWF  x6D
2A7C:  MOVLB  0
2A7E:  CALL   2158
2A82:  MOVF   01,W
2A84:  MOVLB  8
2A86:  ADDWF  x61,F
2A88:  MOVLW  00
2A8A:  ADDWFC x62,F
2A8C:  ADDWFC x63,F
2A8E:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
2A90:  MOVLW  04
2A92:  MOVWF  x6D
2A94:  MOVLB  0
2A96:  CALL   2158
2A9A:  MOVF   01,W
2A9C:  MOVLB  8
2A9E:  ADDWF  x65,F
2AA0:  MOVLW  00
2AA2:  ADDWFC x66,F
2AA4:  ADDWFC x67,F
2AA6:  ADDWFC x68,F
....................       col_5=read_col(5)+col_5; 
2AA8:  MOVLW  05
2AAA:  MOVWF  x6D
2AAC:  MOVLB  0
2AAE:  CALL   2158
2AB2:  MOVF   01,W
2AB4:  MOVLB  8
2AB6:  ADDWF  x69,F
2AB8:  MOVLW  00
2ABA:  ADDWFC x6A,F
2ABC:  ADDWFC x6B,F
2ABE:  ADDWFC x6C,F
....................    } 
2AC0:  INCF   x53,F
2AC2:  BTFSC  FD8.2
2AC4:  INCF   x54,F
2AC6:  BRA    2A24
....................    col_0=col_0/500; 
2AC8:  BCF    FD8.1
2ACA:  MOVFF  858,90F
2ACE:  MOVFF  857,90E
2AD2:  MOVFF  856,90D
2AD6:  MOVFF  855,90C
2ADA:  MOVLB  9
2ADC:  CLRF   x13
2ADE:  CLRF   x12
2AE0:  MOVLW  01
2AE2:  MOVWF  x11
2AE4:  MOVLW  F4
2AE6:  MOVWF  x10
2AE8:  MOVLB  0
2AEA:  CALL   2266
2AEE:  MOVFF  03,858
2AF2:  MOVFF  02,857
2AF6:  MOVFF  01,856
2AFA:  MOVFF  00,855
....................    col_1=col_1/500; 
2AFE:  BCF    FD8.1
2B00:  MOVFF  85C,90F
2B04:  MOVFF  85B,90E
2B08:  MOVFF  85A,90D
2B0C:  MOVFF  859,90C
2B10:  MOVLB  9
2B12:  CLRF   x13
2B14:  CLRF   x12
2B16:  MOVLW  01
2B18:  MOVWF  x11
2B1A:  MOVLW  F4
2B1C:  MOVWF  x10
2B1E:  MOVLB  0
2B20:  CALL   2266
2B24:  MOVFF  03,85C
2B28:  MOVFF  02,85B
2B2C:  MOVFF  01,85A
2B30:  MOVFF  00,859
....................    col_2=col_2/500; 
2B34:  BCF    FD8.1
2B36:  MOVFF  860,90F
2B3A:  MOVFF  85F,90E
2B3E:  MOVFF  85E,90D
2B42:  MOVFF  85D,90C
2B46:  MOVLB  9
2B48:  CLRF   x13
2B4A:  CLRF   x12
2B4C:  MOVLW  01
2B4E:  MOVWF  x11
2B50:  MOVLW  F4
2B52:  MOVWF  x10
2B54:  MOVLB  0
2B56:  CALL   2266
2B5A:  MOVFF  03,860
2B5E:  MOVFF  02,85F
2B62:  MOVFF  01,85E
2B66:  MOVFF  00,85D
....................    col_3=col_3/500; 
2B6A:  BCF    FD8.1
2B6C:  MOVFF  864,90F
2B70:  MOVFF  863,90E
2B74:  MOVFF  862,90D
2B78:  MOVFF  861,90C
2B7C:  MOVLB  9
2B7E:  CLRF   x13
2B80:  CLRF   x12
2B82:  MOVLW  01
2B84:  MOVWF  x11
2B86:  MOVLW  F4
2B88:  MOVWF  x10
2B8A:  MOVLB  0
2B8C:  CALL   2266
2B90:  MOVFF  03,864
2B94:  MOVFF  02,863
2B98:  MOVFF  01,862
2B9C:  MOVFF  00,861
....................    col_4=col_4/500; 
2BA0:  BCF    FD8.1
2BA2:  MOVFF  868,90F
2BA6:  MOVFF  867,90E
2BAA:  MOVFF  866,90D
2BAE:  MOVFF  865,90C
2BB2:  MOVLB  9
2BB4:  CLRF   x13
2BB6:  CLRF   x12
2BB8:  MOVLW  01
2BBA:  MOVWF  x11
2BBC:  MOVLW  F4
2BBE:  MOVWF  x10
2BC0:  MOVLB  0
2BC2:  CALL   2266
2BC6:  MOVFF  03,868
2BCA:  MOVFF  02,867
2BCE:  MOVFF  01,866
2BD2:  MOVFF  00,865
....................    col_5=col_5/500; 
2BD6:  BCF    FD8.1
2BD8:  MOVFF  86C,90F
2BDC:  MOVFF  86B,90E
2BE0:  MOVFF  86A,90D
2BE4:  MOVFF  869,90C
2BE8:  MOVLB  9
2BEA:  CLRF   x13
2BEC:  CLRF   x12
2BEE:  MOVLW  01
2BF0:  MOVWF  x11
2BF2:  MOVLW  F4
2BF4:  MOVWF  x10
2BF6:  MOVLB  0
2BF8:  CALL   2266
2BFC:  MOVFF  03,86C
2C00:  MOVFF  02,86B
2C04:  MOVFF  01,86A
2C08:  MOVFF  00,869
....................    if(keydebug_en) 
2C0C:  MOVLB  1
2C0E:  MOVF   x44,F
2C10:  BTFSC  FD8.2
2C12:  BRA    2DDC
....................    { 
....................       fprintf(COM2,"\r\n");      
2C14:  MOVLW  0D
2C16:  MOVLB  9
2C18:  MOVWF  x0C
2C1A:  MOVLB  0
2C1C:  CALL   1604
2C20:  MOVLW  0A
2C22:  MOVLB  9
2C24:  MOVWF  x0C
2C26:  MOVLB  0
2C28:  CALL   1604
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2C2C:  MOVLW  02
2C2E:  MOVWF  FF6
2C30:  MOVLW  05
2C32:  MOVWF  FF7
2C34:  MOVLW  07
2C36:  MOVLB  8
2C38:  MOVWF  xF7
2C3A:  MOVLB  0
2C3C:  CALL   164A
2C40:  MOVLW  41
2C42:  MOVWF  FE9
2C44:  MOVFF  858,8FA
2C48:  MOVFF  857,8F9
2C4C:  MOVFF  856,8F8
2C50:  MOVFF  855,8F7
2C54:  CALL   22FA
2C58:  MOVLW  0D
2C5A:  MOVLB  9
2C5C:  MOVWF  x0C
2C5E:  MOVLB  0
2C60:  CALL   1604
2C64:  MOVLW  0A
2C66:  MOVLB  9
2C68:  MOVWF  x0C
2C6A:  MOVLB  0
2C6C:  CALL   1604
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2C70:  MOVLW  10
2C72:  MOVWF  FF6
2C74:  MOVLW  05
2C76:  MOVWF  FF7
2C78:  MOVLW  07
2C7A:  MOVLB  8
2C7C:  MOVWF  xF7
2C7E:  MOVLB  0
2C80:  CALL   164A
2C84:  MOVLW  41
2C86:  MOVWF  FE9
2C88:  MOVFF  85C,8FA
2C8C:  MOVFF  85B,8F9
2C90:  MOVFF  85A,8F8
2C94:  MOVFF  859,8F7
2C98:  CALL   22FA
2C9C:  MOVLW  0D
2C9E:  MOVLB  9
2CA0:  MOVWF  x0C
2CA2:  MOVLB  0
2CA4:  CALL   1604
2CA8:  MOVLW  0A
2CAA:  MOVLB  9
2CAC:  MOVWF  x0C
2CAE:  MOVLB  0
2CB0:  CALL   1604
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2CB4:  MOVLW  1E
2CB6:  MOVWF  FF6
2CB8:  MOVLW  05
2CBA:  MOVWF  FF7
2CBC:  MOVLW  07
2CBE:  MOVLB  8
2CC0:  MOVWF  xF7
2CC2:  MOVLB  0
2CC4:  CALL   164A
2CC8:  MOVLW  41
2CCA:  MOVWF  FE9
2CCC:  MOVFF  860,8FA
2CD0:  MOVFF  85F,8F9
2CD4:  MOVFF  85E,8F8
2CD8:  MOVFF  85D,8F7
2CDC:  CALL   22FA
2CE0:  MOVLW  0D
2CE2:  MOVLB  9
2CE4:  MOVWF  x0C
2CE6:  MOVLB  0
2CE8:  CALL   1604
2CEC:  MOVLW  0A
2CEE:  MOVLB  9
2CF0:  MOVWF  x0C
2CF2:  MOVLB  0
2CF4:  CALL   1604
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2CF8:  MOVLW  2C
2CFA:  MOVWF  FF6
2CFC:  MOVLW  05
2CFE:  MOVWF  FF7
2D00:  MOVLW  07
2D02:  MOVLB  8
2D04:  MOVWF  xF7
2D06:  MOVLB  0
2D08:  CALL   164A
2D0C:  MOVLW  41
2D0E:  MOVWF  FE9
2D10:  MOVFF  864,8FA
2D14:  MOVFF  863,8F9
2D18:  MOVFF  862,8F8
2D1C:  MOVFF  861,8F7
2D20:  CALL   22FA
2D24:  MOVLW  0D
2D26:  MOVLB  9
2D28:  MOVWF  x0C
2D2A:  MOVLB  0
2D2C:  CALL   1604
2D30:  MOVLW  0A
2D32:  MOVLB  9
2D34:  MOVWF  x0C
2D36:  MOVLB  0
2D38:  CALL   1604
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2D3C:  MOVLW  3A
2D3E:  MOVWF  FF6
2D40:  MOVLW  05
2D42:  MOVWF  FF7
2D44:  MOVLW  07
2D46:  MOVLB  8
2D48:  MOVWF  xF7
2D4A:  MOVLB  0
2D4C:  CALL   164A
2D50:  MOVLW  41
2D52:  MOVWF  FE9
2D54:  MOVFF  868,8FA
2D58:  MOVFF  867,8F9
2D5C:  MOVFF  866,8F8
2D60:  MOVFF  865,8F7
2D64:  CALL   22FA
2D68:  MOVLW  0D
2D6A:  MOVLB  9
2D6C:  MOVWF  x0C
2D6E:  MOVLB  0
2D70:  CALL   1604
2D74:  MOVLW  0A
2D76:  MOVLB  9
2D78:  MOVWF  x0C
2D7A:  MOVLB  0
2D7C:  CALL   1604
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2D80:  MOVLW  48
2D82:  MOVWF  FF6
2D84:  MOVLW  05
2D86:  MOVWF  FF7
2D88:  MOVLW  07
2D8A:  MOVLB  8
2D8C:  MOVWF  xF7
2D8E:  MOVLB  0
2D90:  CALL   164A
2D94:  MOVLW  41
2D96:  MOVWF  FE9
2D98:  MOVFF  86C,8FA
2D9C:  MOVFF  86B,8F9
2DA0:  MOVFF  86A,8F8
2DA4:  MOVFF  869,8F7
2DA8:  CALL   22FA
2DAC:  MOVLW  0D
2DAE:  MOVLB  9
2DB0:  MOVWF  x0C
2DB2:  MOVLB  0
2DB4:  CALL   1604
2DB8:  MOVLW  0A
2DBA:  MOVLB  9
2DBC:  MOVWF  x0C
2DBE:  MOVLB  0
2DC0:  CALL   1604
....................       fprintf(COM2,"\r\n"); 
2DC4:  MOVLW  0D
2DC6:  MOVLB  9
2DC8:  MOVWF  x0C
2DCA:  MOVLB  0
2DCC:  CALL   1604
2DD0:  MOVLW  0A
2DD2:  MOVLB  9
2DD4:  MOVWF  x0C
2DD6:  MOVLB  0
2DD8:  CALL   1604
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2DDC:  MOVLB  8
2DDE:  MOVF   x58,F
2DE0:  BNZ   2DF0
2DE2:  MOVF   x57,F
2DE4:  BNZ   2DF0
2DE6:  MOVF   x56,F
2DE8:  BNZ   2DF0
2DEA:  MOVF   x55,W
2DEC:  SUBLW  05
2DEE:  BC    2E62
2DF0:  MOVF   x58,F
2DF2:  BNZ   2E62
2DF4:  MOVF   x57,F
2DF6:  BNZ   2E62
2DF8:  MOVF   x56,F
2DFA:  BNZ   2E62
2DFC:  MOVF   x55,W
2DFE:  SUBLW  3B
2E00:  BNC   2E62
2E02:  MOVF   x5C,F
2E04:  BNZ   2E14
2E06:  MOVF   x5B,F
2E08:  BNZ   2E14
2E0A:  MOVF   x5A,F
2E0C:  BNZ   2E14
2E0E:  MOVF   x59,W
2E10:  SUBLW  64
2E12:  BC    2E62
2E14:  MOVF   x60,F
2E16:  BNZ   2E26
2E18:  MOVF   x5F,F
2E1A:  BNZ   2E26
2E1C:  MOVF   x5E,F
2E1E:  BNZ   2E26
2E20:  MOVF   x5D,W
2E22:  SUBLW  64
2E24:  BC    2E62
2E26:  MOVF   x64,F
2E28:  BNZ   2E38
2E2A:  MOVF   x63,F
2E2C:  BNZ   2E38
2E2E:  MOVF   x62,F
2E30:  BNZ   2E38
2E32:  MOVF   x61,W
2E34:  SUBLW  64
2E36:  BC    2E62
2E38:  MOVF   x68,F
2E3A:  BNZ   2E4A
2E3C:  MOVF   x67,F
2E3E:  BNZ   2E4A
2E40:  MOVF   x66,F
2E42:  BNZ   2E4A
2E44:  MOVF   x65,W
2E46:  SUBLW  64
2E48:  BC    2E62
2E4A:  MOVF   x6C,F
2E4C:  BNZ   2E5C
2E4E:  MOVF   x6B,F
2E50:  BNZ   2E5C
2E52:  MOVF   x6A,F
2E54:  BNZ   2E5C
2E56:  MOVF   x69,W
2E58:  SUBLW  64
2E5A:  BC    2E62
2E5C:  MOVLW  00
2E5E:  MOVWF  01
2E60:  BRA    31DA
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2E62:  MOVF   x5C,F
2E64:  BNZ   2E74
2E66:  MOVF   x5B,F
2E68:  BNZ   2E74
2E6A:  MOVF   x5A,F
2E6C:  BNZ   2E74
2E6E:  MOVF   x59,W
2E70:  SUBLW  05
2E72:  BC    2EE6
2E74:  MOVF   x5C,F
2E76:  BNZ   2EE6
2E78:  MOVF   x5B,F
2E7A:  BNZ   2EE6
2E7C:  MOVF   x5A,F
2E7E:  BNZ   2EE6
2E80:  MOVF   x59,W
2E82:  SUBLW  3B
2E84:  BNC   2EE6
2E86:  MOVF   x58,F
2E88:  BNZ   2E98
2E8A:  MOVF   x57,F
2E8C:  BNZ   2E98
2E8E:  MOVF   x56,F
2E90:  BNZ   2E98
2E92:  MOVF   x55,W
2E94:  SUBLW  64
2E96:  BC    2EE6
2E98:  MOVF   x60,F
2E9A:  BNZ   2EAA
2E9C:  MOVF   x5F,F
2E9E:  BNZ   2EAA
2EA0:  MOVF   x5E,F
2EA2:  BNZ   2EAA
2EA4:  MOVF   x5D,W
2EA6:  SUBLW  64
2EA8:  BC    2EE6
2EAA:  MOVF   x64,F
2EAC:  BNZ   2EBC
2EAE:  MOVF   x63,F
2EB0:  BNZ   2EBC
2EB2:  MOVF   x62,F
2EB4:  BNZ   2EBC
2EB6:  MOVF   x61,W
2EB8:  SUBLW  64
2EBA:  BC    2EE6
2EBC:  MOVF   x68,F
2EBE:  BNZ   2ECE
2EC0:  MOVF   x67,F
2EC2:  BNZ   2ECE
2EC4:  MOVF   x66,F
2EC6:  BNZ   2ECE
2EC8:  MOVF   x65,W
2ECA:  SUBLW  64
2ECC:  BC    2EE6
2ECE:  MOVF   x6C,F
2ED0:  BNZ   2EE0
2ED2:  MOVF   x6B,F
2ED4:  BNZ   2EE0
2ED6:  MOVF   x6A,F
2ED8:  BNZ   2EE0
2EDA:  MOVF   x69,W
2EDC:  SUBLW  64
2EDE:  BC    2EE6
2EE0:  MOVLW  01
2EE2:  MOVWF  01
2EE4:  BRA    31DA
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2EE6:  MOVF   x60,F
2EE8:  BNZ   2EF8
2EEA:  MOVF   x5F,F
2EEC:  BNZ   2EF8
2EEE:  MOVF   x5E,F
2EF0:  BNZ   2EF8
2EF2:  MOVF   x5D,W
2EF4:  SUBLW  05
2EF6:  BC    2F6A
2EF8:  MOVF   x60,F
2EFA:  BNZ   2F6A
2EFC:  MOVF   x5F,F
2EFE:  BNZ   2F6A
2F00:  MOVF   x5E,F
2F02:  BNZ   2F6A
2F04:  MOVF   x5D,W
2F06:  SUBLW  3B
2F08:  BNC   2F6A
2F0A:  MOVF   x5C,F
2F0C:  BNZ   2F1C
2F0E:  MOVF   x5B,F
2F10:  BNZ   2F1C
2F12:  MOVF   x5A,F
2F14:  BNZ   2F1C
2F16:  MOVF   x59,W
2F18:  SUBLW  64
2F1A:  BC    2F6A
2F1C:  MOVF   x58,F
2F1E:  BNZ   2F2E
2F20:  MOVF   x57,F
2F22:  BNZ   2F2E
2F24:  MOVF   x56,F
2F26:  BNZ   2F2E
2F28:  MOVF   x55,W
2F2A:  SUBLW  64
2F2C:  BC    2F6A
2F2E:  MOVF   x64,F
2F30:  BNZ   2F40
2F32:  MOVF   x63,F
2F34:  BNZ   2F40
2F36:  MOVF   x62,F
2F38:  BNZ   2F40
2F3A:  MOVF   x61,W
2F3C:  SUBLW  64
2F3E:  BC    2F6A
2F40:  MOVF   x68,F
2F42:  BNZ   2F52
2F44:  MOVF   x67,F
2F46:  BNZ   2F52
2F48:  MOVF   x66,F
2F4A:  BNZ   2F52
2F4C:  MOVF   x65,W
2F4E:  SUBLW  64
2F50:  BC    2F6A
2F52:  MOVF   x6C,F
2F54:  BNZ   2F64
2F56:  MOVF   x6B,F
2F58:  BNZ   2F64
2F5A:  MOVF   x6A,F
2F5C:  BNZ   2F64
2F5E:  MOVF   x69,W
2F60:  SUBLW  64
2F62:  BC    2F6A
2F64:  MOVLW  02
2F66:  MOVWF  01
2F68:  BRA    31DA
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2F6A:  MOVF   x64,F
2F6C:  BNZ   2F7C
2F6E:  MOVF   x63,F
2F70:  BNZ   2F7C
2F72:  MOVF   x62,F
2F74:  BNZ   2F7C
2F76:  MOVF   x61,W
2F78:  SUBLW  05
2F7A:  BC    2FEE
2F7C:  MOVF   x64,F
2F7E:  BNZ   2FEE
2F80:  MOVF   x63,F
2F82:  BNZ   2FEE
2F84:  MOVF   x62,F
2F86:  BNZ   2FEE
2F88:  MOVF   x61,W
2F8A:  SUBLW  3B
2F8C:  BNC   2FEE
2F8E:  MOVF   x5C,F
2F90:  BNZ   2FA0
2F92:  MOVF   x5B,F
2F94:  BNZ   2FA0
2F96:  MOVF   x5A,F
2F98:  BNZ   2FA0
2F9A:  MOVF   x59,W
2F9C:  SUBLW  64
2F9E:  BC    2FEE
2FA0:  MOVF   x60,F
2FA2:  BNZ   2FB2
2FA4:  MOVF   x5F,F
2FA6:  BNZ   2FB2
2FA8:  MOVF   x5E,F
2FAA:  BNZ   2FB2
2FAC:  MOVF   x5D,W
2FAE:  SUBLW  64
2FB0:  BC    2FEE
2FB2:  MOVF   x58,F
2FB4:  BNZ   2FC4
2FB6:  MOVF   x57,F
2FB8:  BNZ   2FC4
2FBA:  MOVF   x56,F
2FBC:  BNZ   2FC4
2FBE:  MOVF   x55,W
2FC0:  SUBLW  64
2FC2:  BC    2FEE
2FC4:  MOVF   x68,F
2FC6:  BNZ   2FD6
2FC8:  MOVF   x67,F
2FCA:  BNZ   2FD6
2FCC:  MOVF   x66,F
2FCE:  BNZ   2FD6
2FD0:  MOVF   x65,W
2FD2:  SUBLW  64
2FD4:  BC    2FEE
2FD6:  MOVF   x6C,F
2FD8:  BNZ   2FE8
2FDA:  MOVF   x6B,F
2FDC:  BNZ   2FE8
2FDE:  MOVF   x6A,F
2FE0:  BNZ   2FE8
2FE2:  MOVF   x69,W
2FE4:  SUBLW  64
2FE6:  BC    2FEE
2FE8:  MOVLW  03
2FEA:  MOVWF  01
2FEC:  BRA    31DA
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
2FEE:  MOVF   x68,F
2FF0:  BNZ   3000
2FF2:  MOVF   x67,F
2FF4:  BNZ   3000
2FF6:  MOVF   x66,F
2FF8:  BNZ   3000
2FFA:  MOVF   x65,W
2FFC:  SUBLW  05
2FFE:  BC    3072
3000:  MOVF   x68,F
3002:  BNZ   3072
3004:  MOVF   x67,F
3006:  BNZ   3072
3008:  MOVF   x66,F
300A:  BNZ   3072
300C:  MOVF   x65,W
300E:  SUBLW  3B
3010:  BNC   3072
3012:  MOVF   x5C,F
3014:  BNZ   3024
3016:  MOVF   x5B,F
3018:  BNZ   3024
301A:  MOVF   x5A,F
301C:  BNZ   3024
301E:  MOVF   x59,W
3020:  SUBLW  64
3022:  BC    3072
3024:  MOVF   x60,F
3026:  BNZ   3036
3028:  MOVF   x5F,F
302A:  BNZ   3036
302C:  MOVF   x5E,F
302E:  BNZ   3036
3030:  MOVF   x5D,W
3032:  SUBLW  64
3034:  BC    3072
3036:  MOVF   x64,F
3038:  BNZ   3048
303A:  MOVF   x63,F
303C:  BNZ   3048
303E:  MOVF   x62,F
3040:  BNZ   3048
3042:  MOVF   x61,W
3044:  SUBLW  64
3046:  BC    3072
3048:  MOVF   x58,F
304A:  BNZ   305A
304C:  MOVF   x57,F
304E:  BNZ   305A
3050:  MOVF   x56,F
3052:  BNZ   305A
3054:  MOVF   x55,W
3056:  SUBLW  64
3058:  BC    3072
305A:  MOVF   x6C,F
305C:  BNZ   306C
305E:  MOVF   x6B,F
3060:  BNZ   306C
3062:  MOVF   x6A,F
3064:  BNZ   306C
3066:  MOVF   x69,W
3068:  SUBLW  64
306A:  BC    3072
306C:  MOVLW  04
306E:  MOVWF  01
3070:  BRA    31DA
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
3072:  MOVF   x6C,F
3074:  BNZ   3084
3076:  MOVF   x6B,F
3078:  BNZ   3084
307A:  MOVF   x6A,F
307C:  BNZ   3084
307E:  MOVF   x69,W
3080:  SUBLW  05
3082:  BC    30F6
3084:  MOVF   x6C,F
3086:  BNZ   30F6
3088:  MOVF   x6B,F
308A:  BNZ   30F6
308C:  MOVF   x6A,F
308E:  BNZ   30F6
3090:  MOVF   x69,W
3092:  SUBLW  3B
3094:  BNC   30F6
3096:  MOVF   x5C,F
3098:  BNZ   30A8
309A:  MOVF   x5B,F
309C:  BNZ   30A8
309E:  MOVF   x5A,F
30A0:  BNZ   30A8
30A2:  MOVF   x59,W
30A4:  SUBLW  64
30A6:  BC    30F6
30A8:  MOVF   x60,F
30AA:  BNZ   30BA
30AC:  MOVF   x5F,F
30AE:  BNZ   30BA
30B0:  MOVF   x5E,F
30B2:  BNZ   30BA
30B4:  MOVF   x5D,W
30B6:  SUBLW  64
30B8:  BC    30F6
30BA:  MOVF   x64,F
30BC:  BNZ   30CC
30BE:  MOVF   x63,F
30C0:  BNZ   30CC
30C2:  MOVF   x62,F
30C4:  BNZ   30CC
30C6:  MOVF   x61,W
30C8:  SUBLW  64
30CA:  BC    30F6
30CC:  MOVF   x68,F
30CE:  BNZ   30DE
30D0:  MOVF   x67,F
30D2:  BNZ   30DE
30D4:  MOVF   x66,F
30D6:  BNZ   30DE
30D8:  MOVF   x65,W
30DA:  SUBLW  64
30DC:  BC    30F6
30DE:  MOVF   x58,F
30E0:  BNZ   30F0
30E2:  MOVF   x57,F
30E4:  BNZ   30F0
30E6:  MOVF   x56,F
30E8:  BNZ   30F0
30EA:  MOVF   x55,W
30EC:  SUBLW  64
30EE:  BC    30F6
30F0:  MOVLW  05
30F2:  MOVWF  01
30F4:  BRA    31DA
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
30F6:  MOVF   x6C,F
30F8:  BNZ   310A
30FA:  MOVF   x6B,F
30FC:  BNZ   310A
30FE:  MOVF   x6A,F
3100:  BNZ   310A
3102:  MOVF   x69,W
3104:  SUBLW  C8
3106:  BTFSC  FD8.0
3108:  BRA    31D6
310A:  MOVF   x58,F
310C:  BTFSS  FD8.2
310E:  BRA    31D6
3110:  MOVF   x57,F
3112:  BTFSS  FD8.2
3114:  BRA    31D6
3116:  MOVF   x56,F
3118:  BTFSS  FD8.2
311A:  BRA    31D6
311C:  MOVF   x55,W
311E:  SUBLW  B3
3120:  BTFSS  FD8.0
3122:  BRA    31D6
3124:  MOVF   x58,F
3126:  BNZ   3138
3128:  MOVF   x57,F
312A:  BNZ   3138
312C:  MOVF   x56,F
312E:  BNZ   3138
3130:  MOVF   x55,W
3132:  SUBLW  64
3134:  BTFSC  FD8.0
3136:  BRA    31D6
3138:  MOVF   x5C,F
313A:  BTFSS  FD8.2
313C:  BRA    31D6
313E:  MOVF   x5B,F
3140:  BTFSS  FD8.2
3142:  BRA    31D6
3144:  MOVF   x5A,F
3146:  BTFSS  FD8.2
3148:  BRA    31D6
314A:  MOVF   x59,W
314C:  SUBLW  B3
314E:  BNC   31D6
3150:  MOVF   x5C,F
3152:  BNZ   3162
3154:  MOVF   x5B,F
3156:  BNZ   3162
3158:  MOVF   x5A,F
315A:  BNZ   3162
315C:  MOVF   x59,W
315E:  SUBLW  64
3160:  BC    31D6
3162:  MOVF   x60,F
3164:  BNZ   31D6
3166:  MOVF   x5F,F
3168:  BNZ   31D6
316A:  MOVF   x5E,F
316C:  BNZ   31D6
316E:  MOVF   x5D,W
3170:  SUBLW  B3
3172:  BNC   31D6
3174:  MOVF   x60,F
3176:  BNZ   3186
3178:  MOVF   x5F,F
317A:  BNZ   3186
317C:  MOVF   x5E,F
317E:  BNZ   3186
3180:  MOVF   x5D,W
3182:  SUBLW  64
3184:  BC    31D6
3186:  MOVF   x64,F
3188:  BNZ   31D6
318A:  MOVF   x63,F
318C:  BNZ   31D6
318E:  MOVF   x62,F
3190:  BNZ   31D6
3192:  MOVF   x61,W
3194:  SUBLW  B3
3196:  BNC   31D6
3198:  MOVF   x64,F
319A:  BNZ   31AA
319C:  MOVF   x63,F
319E:  BNZ   31AA
31A0:  MOVF   x62,F
31A2:  BNZ   31AA
31A4:  MOVF   x61,W
31A6:  SUBLW  64
31A8:  BC    31D6
31AA:  MOVF   x68,F
31AC:  BNZ   31D6
31AE:  MOVF   x67,F
31B0:  BNZ   31D6
31B2:  MOVF   x66,F
31B4:  BNZ   31D6
31B6:  MOVF   x65,W
31B8:  SUBLW  B3
31BA:  BNC   31D6
31BC:  MOVF   x68,F
31BE:  BNZ   31CE
31C0:  MOVF   x67,F
31C2:  BNZ   31CE
31C4:  MOVF   x66,F
31C6:  BNZ   31CE
31C8:  MOVF   x65,W
31CA:  SUBLW  64
31CC:  BC    31D6
31CE:  MOVLW  05
31D0:  MOVWF  01
31D2:  BRA    31DA
....................    else return 0xff; 
31D4:  BRA    31DA
31D6:  MOVLW  FF
31D8:  MOVWF  01
.................... } 
31DA:  MOVLB  0
31DC:  GOTO   3242 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
31E0:  MOVLW  20
31E2:  MOVLB  8
31E4:  MOVWF  x51
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
31E6:  BSF    F93.4
31E8:  BTFSS  F81.4
31EA:  BRA    31FE
31EC:  BSF    F93.5
31EE:  BTFSS  F81.5
31F0:  BRA    31FE
31F2:  BSF    F93.6
31F4:  BTFSS  F81.6
31F6:  BRA    31FE
31F8:  BSF    F93.7
31FA:  BTFSC  F81.7
31FC:  BRA    3364
....................     { 
....................        if(input(ROW0)==0) 
31FE:  BSF    F93.4
3200:  BTFSC  F81.4
3202:  BRA    3208
....................          row=0; 
3204:  CLRF   x52
....................        else if(input(ROW1)==0) 
3206:  BRA    322A
3208:  BSF    F93.5
320A:  BTFSC  F81.5
320C:  BRA    3214
....................          row=1; 
320E:  MOVLW  01
3210:  MOVWF  x52
....................        else if(input(ROW2)==0) 
3212:  BRA    322A
3214:  BSF    F93.6
3216:  BTFSC  F81.6
3218:  BRA    3220
....................          row=2; 
321A:  MOVLW  02
321C:  MOVWF  x52
....................        else if(input(ROW3)==0) 
321E:  BRA    322A
3220:  BSF    F93.7
3222:  BTFSC  F81.7
3224:  BRA    322A
....................          row=3;      
3226:  MOVLW  03
3228:  MOVWF  x52
....................        if(type_KB==0)col=check_col(); 
322A:  MOVLB  1
322C:  MOVF   x49,F
322E:  BNZ   323C
3230:  MOVLB  0
3232:  GOTO   23C0
3236:  MOVFF  01,850
....................          else col=new_check_col(); 
323A:  BRA    3246
323C:  MOVLB  0
323E:  GOTO   29EE
3242:  MOVFF  01,850
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
3246:  MOVLB  8
3248:  INCFSZ x50,W
324A:  BRA    324E
324C:  BRA    3334
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
324E:  MOVLB  1
3250:  MOVF   x49,F
3252:  BNZ   327A
3254:  MOVLB  8
3256:  MOVF   x52,W
3258:  MULLW  05
325A:  MOVF   FF3,W
325C:  CLRF   x54
325E:  MOVWF  x53
3260:  CLRF   03
3262:  MOVF   x50,W
3264:  ADDWF  x53,W
3266:  MOVWF  01
3268:  MOVF   x54,W
326A:  ADDWFC 03,F
326C:  MOVF   01,W
326E:  MOVLB  0
3270:  CALL   030A
3274:  MOVFF  FE8,851
....................            else kchar =newKEYS[row][col]; 
3278:  BRA    329E
327A:  MOVLB  8
327C:  MOVF   x52,W
327E:  MULLW  06
3280:  MOVF   FF3,W
3282:  CLRF   x54
3284:  MOVWF  x53
3286:  CLRF   03
3288:  MOVF   x50,W
328A:  ADDWF  x53,W
328C:  MOVWF  01
328E:  MOVF   x54,W
3290:  ADDWFC 03,F
3292:  MOVF   01,W
3294:  MOVLB  0
3296:  CALL   032E
329A:  MOVFF  FE8,851
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
329E:  MOVLB  1
32A0:  MOVF   x44,F
32A2:  BNZ   3326
....................             { 
....................               charac_timeout=0; 
32A4:  CLRF   x00
32A6:  MOVLB  0
32A8:  CLRF   xFF
....................                if(key_count_ms<wideofkeystore) 
32AA:  MOVLB  1
32AC:  MOVF   x47,W
32AE:  SUBLW  0F
32B0:  BNC   3324
....................                { 
....................                    key_data[key_count_ms++]=kchar; 
32B2:  MOVF   x47,W
32B4:  INCF   x47,F
32B6:  CLRF   03
32B8:  ADDLW  4A
32BA:  MOVWF  FE9
32BC:  MOVLW  01
32BE:  ADDWFC 03,W
32C0:  MOVWF  FEA
32C2:  MOVFF  851,FEF
....................                    fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
32C6:  MOVLW  56
32C8:  MOVWF  FF6
32CA:  MOVLW  05
32CC:  MOVWF  FF7
32CE:  MOVLW  09
32D0:  MOVLB  8
32D2:  MOVWF  xF7
32D4:  MOVLB  0
32D6:  CALL   164A
32DA:  MOVFF  147,859
32DE:  MOVLW  18
32E0:  MOVLB  8
32E2:  MOVWF  x5A
32E4:  MOVLB  0
32E6:  CALL   177A
32EA:  MOVLW  5D
32EC:  MOVLB  9
32EE:  MOVWF  x0C
32F0:  MOVLB  0
32F2:  CALL   1604
32F6:  MOVLW  20
32F8:  MOVLB  9
32FA:  MOVWF  x0C
32FC:  MOVLB  0
32FE:  CALL   1604
3302:  MOVFF  851,90C
3306:  CALL   1604
330A:  MOVLW  0D
330C:  MOVLB  9
330E:  MOVWF  x0C
3310:  MOVLB  0
3312:  CALL   1604
3316:  MOVLW  0A
3318:  MOVLB  9
331A:  MOVWF  x0C
331C:  MOVLB  0
331E:  CALL   1604
3322:  MOVLB  1
....................                } 
....................             } 
....................                else fputc(kchar,COM2); 
3324:  BRA    3332
3326:  MOVFF  851,90C
332A:  MOVLB  0
332C:  CALL   1604
3330:  MOVLB  1
3332:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3334:  BSF    F93.4
3336:  BTFSS  F81.4
3338:  BRA    3334
333A:  BSF    F93.5
333C:  BTFSS  F81.5
333E:  BRA    3334
3340:  BSF    F93.6
3342:  BTFSS  F81.6
3344:  BRA    3334
3346:  BSF    F93.7
3348:  BTFSS  F81.7
334A:  BRA    3334
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
334C:  BSF    F93.4
334E:  BTFSS  F81.4
3350:  BRA    334C
3352:  BSF    F93.5
3354:  BTFSS  F81.5
3356:  BRA    334C
3358:  BSF    F93.6
335A:  BTFSS  F81.6
335C:  BRA    334C
335E:  BSF    F93.7
3360:  BTFSS  F81.7
3362:  BRA    334C
....................     } 
....................   set_tris_a(0xff);     
3364:  MOVLW  FF
3366:  MOVWF  F92
....................   return(kchar); 
3368:  MOVFF  851,01
.................... }//*/ 
336C:  MOVLB  0
336E:  RETURN 0
....................  
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int8 i,tempdata; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
54A2:  MOVF   27,F
54A4:  BTFSS  FD8.2
54A6:  BRA    5660
54A8:  MOVF   26,W
54AA:  SUBLW  01
54AC:  BTFSS  FD8.0
54AE:  BRA    5660
54B0:  BNZ   54C4
54B2:  MOVF   25,W
54B4:  SUBLW  FF
54B6:  BTFSS  FD8.0
54B8:  BRA    5660
54BA:  BNZ   54C4
54BC:  MOVF   24,W
54BE:  SUBLW  FE
54C0:  BTFSS  FD8.0
54C2:  BRA    5660
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
54C4:  MOVLB  1
54C6:  MOVF   x4A,F
54C8:  BNZ   54D0
54CA:  MOVF   x47,F
54CC:  BTFSC  FD8.2
54CE:  BRA    560C
....................       { 
....................          temp=get_countcard(); 
54D0:  MOVLB  0
54D2:  CALL   351C
54D6:  MOVFF  02,853
54DA:  MOVFF  01,852
....................          //fprintf(COM2," get_countcard=%lu\n\r",temp); 
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
54DE:  MOVLB  8
54E0:  RLCF   x52,W
54E2:  MOVWF  x54
54E4:  RLCF   x53,W
54E6:  MOVWF  x55
54E8:  RLCF   x54,F
54EA:  RLCF   x55,F
54EC:  RLCF   x54,F
54EE:  RLCF   x55,F
54F0:  RLCF   x54,F
54F2:  RLCF   x55,F
54F4:  MOVLW  F0
54F6:  ANDWF  x54,F
54F8:  MOVLW  0E
54FA:  ADDWF  x54,F
54FC:  MOVLW  C3
54FE:  ADDWFC x55,F
5500:  MOVLW  01
5502:  MOVWF  x56
5504:  BCF    FD8.2
5506:  BTFSC  FD8.0
5508:  INCF   x56,F
550A:  CLRF   x57
550C:  MOVLW  01
550E:  ADDWF  x54,W
5510:  MOVWF  00
5512:  MOVLW  00
5514:  ADDWFC x55,W
5516:  MOVWF  01
5518:  MOVLW  00
551A:  ADDWFC x56,W
551C:  MOVWF  02
551E:  MOVLW  00
5520:  ADDWFC x57,W
5522:  MOVWF  27
5524:  MOVFF  02,26
5528:  MOVFF  01,25
552C:  MOVFF  00,24
....................          //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<wideofkeystore;i++) 
5530:  CLRF   x50
5532:  MOVF   x50,W
5534:  SUBLW  0F
5536:  BNC   557E
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
5538:  MOVF   x50,W
553A:  ADDWF  24,W
553C:  MOVWF  00
553E:  MOVLW  00
5540:  ADDWFC 25,W
5542:  MOVWF  01
5544:  MOVLW  00
5546:  ADDWFC 26,W
5548:  MOVWF  02
554A:  MOVLW  00
554C:  ADDWFC 27,W
554E:  MOVWF  03
5550:  MOVWF  x57
5552:  MOVFF  02,856
5556:  MOVFF  01,855
555A:  MOVFF  00,854
555E:  MOVFF  FE8,916
5562:  MOVFF  02,915
5566:  MOVFF  01,914
556A:  MOVFF  00,913
556E:  MOVLB  9
5570:  CLRF   x17
5572:  MOVLB  0
5574:  CALL   3A6C
....................          } 
5578:  MOVLB  8
557A:  INCF   x50,F
557C:  BRA    5532
....................          for(i=0;i<wideofkeystore;i++) 
557E:  CLRF   x50
5580:  MOVF   x50,W
5582:  SUBLW  0F
5584:  BNC   55F0
....................          { 
....................             tempdata=key_data[i]; 
5586:  CLRF   03
5588:  MOVF   x50,W
558A:  ADDLW  4A
558C:  MOVWF  FE9
558E:  MOVLW  01
5590:  ADDWFC 03,W
5592:  MOVWF  FEA
5594:  MOVFF  FEF,851
....................             write_ext_eeprom((int32)ptr_card_key++,tempdata); 
5598:  MOVFF  27,03
559C:  MOVFF  26,02
55A0:  MOVFF  25,01
55A4:  MOVFF  24,00
55A8:  MOVLW  01
55AA:  ADDWF  24,F
55AC:  BTFSC  FD8.0
55AE:  INCF   25,F
55B0:  BTFSC  FD8.2
55B2:  INCF   26,F
55B4:  BTFSC  FD8.2
55B6:  INCF   27,F
55B8:  MOVFF  03,857
55BC:  MOVFF  02,856
55C0:  MOVFF  01,855
55C4:  MOVFF  00,854
55C8:  MOVFF  03,916
55CC:  MOVFF  02,915
55D0:  MOVFF  01,914
55D4:  MOVFF  00,913
55D8:  MOVFF  851,917
55DC:  MOVLB  0
55DE:  CALL   3A6C
....................             //delay_us(100); 
....................             fprintf(COM2,"%c",tempdata); 
55E2:  MOVFF  851,90C
55E6:  CALL   1604
....................          } 
55EA:  MOVLB  8
55EC:  INCF   x50,F
55EE:  BRA    5580
....................           //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................           /*fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<wideofkeystore;i++) 
....................           { 
....................             fprintf(COM2,"%c",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
55F0:  MOVFF  27,8FA
55F4:  MOVFF  26,8F9
55F8:  MOVFF  25,8F8
55FC:  MOVFF  24,8F7
5600:  MOVLW  1E
5602:  MOVWF  xFB
5604:  MOVLB  0
5606:  CALL   3B6A
560A:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
560C:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
560E:  MOVLW  01
5610:  MOVWF  FEA
5612:  MOVLW  4A
5614:  MOVWF  FE9
5616:  CLRF   00
5618:  CLRF   02
561A:  MOVLW  10
561C:  MOVWF  01
561E:  MOVLB  0
5620:  CALL   359A
....................       fprintf(COM2,"\r\n"); 
5624:  MOVLW  0D
5626:  MOVLB  9
5628:  MOVWF  x0C
562A:  MOVLB  0
562C:  CALL   1604
5630:  MOVLW  0A
5632:  MOVLB  9
5634:  MOVWF  x0C
5636:  MOVLB  0
5638:  CALL   1604
....................       fprintf(COM2,"Done save_key_new"); 
563C:  MOVLW  68
563E:  MOVWF  FF6
5640:  MOVLW  05
5642:  MOVWF  FF7
5644:  CALL   172E
....................       fprintf(COM2,"\r\n"); 
5648:  MOVLW  0D
564A:  MOVLB  9
564C:  MOVWF  x0C
564E:  MOVLB  0
5650:  CALL   1604
5654:  MOVLW  0A
5656:  MOVLB  9
5658:  MOVWF  x0C
565A:  MOVLB  0
565C:  CALL   1604
....................    } 
.................... } 
5660:  GOTO   5B96 (RETURN)
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 recEn[wideofkeystore]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
5664:  MOVF   27,F
5666:  BTFSS  FD8.2
5668:  BRA    58CA
566A:  MOVF   26,W
566C:  SUBLW  01
566E:  BTFSS  FD8.0
5670:  BRA    58CA
5672:  BNZ   5686
5674:  MOVF   25,W
5676:  SUBLW  FF
5678:  BTFSS  FD8.0
567A:  BRA    58CA
567C:  BNZ   5686
567E:  MOVF   24,W
5680:  SUBLW  FE
5682:  BTFSS  FD8.0
5684:  BRA    58CA
....................    {   
....................      for(i=0;i<key_numbyte;i++) 
5686:  MOVLB  8
5688:  CLRF   x50
568A:  MOVF   x50,W
568C:  SUBLW  0B
568E:  BNC   56E2
....................      { 
....................         temp=key_data[i]; 
5690:  CLRF   03
5692:  MOVF   x50,W
5694:  ADDLW  4A
5696:  MOVWF  FE9
5698:  MOVLW  01
569A:  ADDWFC 03,W
569C:  MOVWF  FEA
569E:  CLRF   x52
56A0:  MOVFF  FEF,851
....................         fputc(temp,COM2); 
56A4:  MOVFF  851,90C
56A8:  MOVLB  0
56AA:  CALL   1604
....................         recEn[i]=key_data[i]; 
56AE:  CLRF   03
56B0:  MOVLB  8
56B2:  MOVF   x50,W
56B4:  ADDLW  54
56B6:  MOVWF  01
56B8:  MOVLW  08
56BA:  ADDWFC 03,F
56BC:  MOVFF  03,865
56C0:  CLRF   03
56C2:  MOVF   x50,W
56C4:  ADDLW  4A
56C6:  MOVWF  FE9
56C8:  MOVLW  01
56CA:  ADDWFC 03,W
56CC:  MOVWF  FEA
56CE:  MOVFF  FEF,866
56D2:  MOVFF  865,FEA
56D6:  MOVFF  01,FE9
56DA:  MOVFF  866,FEF
....................      } 
56DE:  INCF   x50,F
56E0:  BRA    568A
....................      recEn[key_numbyte] = 0; 
56E2:  CLRF   x60
....................      recEn[key_numbyte+1] = 0;          
56E4:  CLRF   x61
....................      recEn[key_numbyte+2] = 0;          
56E6:  CLRF   x62
....................      recEn[key_numbyte+3] = 0; 
56E8:  CLRF   x63
.................... #if 0 
....................      fprintf(COM2,"\n\r"); 
....................      fprintf(COM2,"test_key:\n\r"); 
....................      for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................      fprintf(COM2,"\n\r"); 
....................      fprintf(COM2,"\n\rdatain:\n\r"); 
....................      for(i=0;i<16;i++) fprintf(COM2," %x",recEn[i]); 
....................      fprintf(COM2,"\n\r"); 
.................... #endif 
....................      EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
56EA:  MOVLB  9
56EC:  CLRF   x07
56EE:  CLRF   x06
56F0:  CLRF   x05
56F2:  MOVLW  3F
56F4:  MOVWF  x04
56F6:  CLRF   x0B
56F8:  CLRF   x0A
56FA:  CLRF   x09
56FC:  MOVLW  20
56FE:  MOVWF  x08
5700:  MOVLW  01
5702:  MOVWF  x0D
5704:  MOVWF  x0C
5706:  MOVLB  0
5708:  CALL   4004
....................      aes_enc_dec((unsigned int8 *)&recEn[0], (unsigned int8 *)&crypto_key[0],0); 
570C:  MOVLW  08
570E:  MOVLB  8
5710:  MOVWF  xF8
5712:  MOVLW  54
5714:  MOVWF  xF7
5716:  MOVLW  01
5718:  MOVWF  xFA
571A:  MOVWF  xF9
571C:  CLRF   xFB
571E:  MOVLB  0
5720:  CALL   40FA
....................      //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................       
....................      /* get the pointer of keyboard data */ 
....................      temp=get_countcard(); 
5724:  CALL   351C
5728:  MOVFF  02,852
572C:  MOVFF  01,851
....................      ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
5730:  MOVLB  8
5732:  RLCF   x51,W
5734:  MOVWF  x64
5736:  RLCF   x52,W
5738:  MOVWF  x65
573A:  RLCF   x64,F
573C:  RLCF   x65,F
573E:  RLCF   x64,F
5740:  RLCF   x65,F
5742:  RLCF   x64,F
5744:  RLCF   x65,F
5746:  MOVLW  F0
5748:  ANDWF  x64,F
574A:  MOVLW  0E
574C:  ADDWF  x64,F
574E:  MOVLW  C3
5750:  ADDWFC x65,F
5752:  MOVLW  01
5754:  MOVWF  x66
5756:  BCF    FD8.2
5758:  BTFSC  FD8.0
575A:  INCF   x66,F
575C:  CLRF   x67
575E:  MOVLW  01
5760:  ADDWF  x64,W
5762:  MOVWF  00
5764:  MOVLW  00
5766:  ADDWFC x65,W
5768:  MOVWF  01
576A:  MOVLW  00
576C:  ADDWFC x66,W
576E:  MOVWF  02
5770:  MOVLW  00
5772:  ADDWFC x67,W
5774:  MOVWF  27
5776:  MOVFF  02,26
577A:  MOVFF  01,25
577E:  MOVFF  00,24
....................      /* delete the old data of key store area  */ 
....................      //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................      for(i=0;i<wideofkeystore;i++) 
5782:  CLRF   x50
5784:  MOVF   x50,W
5786:  SUBLW  0F
5788:  BNC   57D0
....................      { 
....................         write_ext_eeprom((int32)(ptr_card_key+i),0); 
578A:  MOVF   x50,W
578C:  ADDWF  24,W
578E:  MOVWF  00
5790:  MOVLW  00
5792:  ADDWFC 25,W
5794:  MOVWF  01
5796:  MOVLW  00
5798:  ADDWFC 26,W
579A:  MOVWF  02
579C:  MOVLW  00
579E:  ADDWFC 27,W
57A0:  MOVWF  03
57A2:  MOVWF  x67
57A4:  MOVFF  02,866
57A8:  MOVFF  01,865
57AC:  MOVFF  00,864
57B0:  MOVFF  FE8,916
57B4:  MOVFF  02,915
57B8:  MOVFF  01,914
57BC:  MOVFF  00,913
57C0:  MOVLB  9
57C2:  CLRF   x17
57C4:  MOVLB  0
57C6:  CALL   3A6C
....................      } 
57CA:  MOVLB  8
57CC:  INCF   x50,F
57CE:  BRA    5784
....................      fprintf(COM2,"\n\r"); 
57D0:  MOVLW  0A
57D2:  MOVLB  9
57D4:  MOVWF  x0C
57D6:  MOVLB  0
57D8:  CALL   1604
57DC:  MOVLW  0D
57DE:  MOVLB  9
57E0:  MOVWF  x0C
57E2:  MOVLB  0
57E4:  CALL   1604
....................      for(i=0;i<wideofkeystore;i++) fprintf(COM2,"%x",recEn[i]); 
57E8:  MOVLB  8
57EA:  CLRF   x50
57EC:  MOVF   x50,W
57EE:  SUBLW  0F
57F0:  BNC   581A
57F2:  CLRF   03
57F4:  MOVF   x50,W
57F6:  ADDLW  54
57F8:  MOVWF  FE9
57FA:  MOVLW  08
57FC:  ADDWFC 03,W
57FE:  MOVWF  FEA
5800:  MOVFF  FEF,864
5804:  MOVFF  864,901
5808:  MOVLW  57
580A:  MOVLB  9
580C:  MOVWF  x02
580E:  MOVLB  0
5810:  CALL   4F86
5814:  MOVLB  8
5816:  INCF   x50,F
5818:  BRA    57EC
....................      retval = EEPROM_write(ptr_card_key,wideofkeystore,recEn);  
581A:  MOVFF  27,903
581E:  MOVFF  26,902
5822:  MOVFF  25,901
5826:  MOVFF  24,900
582A:  MOVLB  9
582C:  CLRF   x07
582E:  CLRF   x06
5830:  CLRF   x05
5832:  MOVLW  10
5834:  MOVWF  x04
5836:  MOVLW  08
5838:  MOVWF  x09
583A:  MOVLW  54
583C:  MOVWF  x08
583E:  MOVLB  0
5840:  CALL   4EF6
5844:  MOVFF  01,853
....................      if(retval!=0) 
5848:  MOVLB  8
584A:  MOVF   x53,F
584C:  BZ    5874
....................      { 
....................         ptr_card_key+=wideofkeystore; 
584E:  MOVLW  10
5850:  ADDWF  24,F
5852:  MOVLW  00
5854:  ADDWFC 25,F
5856:  ADDWFC 26,F
5858:  ADDWFC 27,F
....................         save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
585A:  MOVFF  27,8FA
585E:  MOVFF  26,8F9
5862:  MOVFF  25,8F8
5866:  MOVFF  24,8F7
586A:  MOVLW  1E
586C:  MOVWF  xFB
586E:  MOVLB  0
5870:  CALL   3B6A
....................      }          
....................       key_count_ms=0; 
5874:  MOVLB  1
5876:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
5878:  MOVLW  01
587A:  MOVWF  FEA
587C:  MOVLW  4A
587E:  MOVWF  FE9
5880:  CLRF   00
5882:  CLRF   02
5884:  MOVLW  10
5886:  MOVWF  01
5888:  MOVLB  0
588A:  CALL   359A
....................       fprintf(COM2,"\r\n"); 
588E:  MOVLW  0D
5890:  MOVLB  9
5892:  MOVWF  x0C
5894:  MOVLB  0
5896:  CALL   1604
589A:  MOVLW  0A
589C:  MOVLB  9
589E:  MOVWF  x0C
58A0:  MOVLB  0
58A2:  CALL   1604
....................       fprintf(COM2,"Done Encrypted PIN"); 
58A6:  MOVLW  7A
58A8:  MOVWF  FF6
58AA:  MOVLW  05
58AC:  MOVWF  FF7
58AE:  CALL   172E
....................       fprintf(COM2,"\r\n"); 
58B2:  MOVLW  0D
58B4:  MOVLB  9
58B6:  MOVWF  x0C
58B8:  MOVLB  0
58BA:  CALL   1604
58BE:  MOVLW  0A
58C0:  MOVLB  9
58C2:  MOVWF  x0C
58C4:  MOVLB  0
58C6:  CALL   1604
....................    } 
.................... } 
58CA:  GOTO   5B9E (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
5FB2:  MOVLB  7
5FB4:  CLRF   xFA
5FB6:  CLRF   xF9
5FB8:  CLRF   xFB
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
5FBA:  MOVF   xFA,F
5FBC:  BTFSS  FD8.2
5FBE:  BRA    60E2
5FC0:  MOVF   xF4,W
5FC2:  SUBWF  xF9,W
5FC4:  BTFSC  FD8.0
5FC6:  BRA    60E2
5FC8:  MOVF   xFB,F
5FCA:  BTFSS  FD8.2
5FCC:  BRA    60E2
....................       c = fgetc(COM2);//getc(); 
5FCE:  MOVLB  0
5FD0:  RCALL  5F64
5FD2:  MOVFF  01,7F7
....................       switch(c) 
....................       { 
5FD6:  MOVLB  7
5FD8:  MOVF   xF7,W
5FDA:  XORLW  7F
5FDC:  MOVLB  0
5FDE:  BZ    5FE6
5FE0:  XORLW  72
5FE2:  BZ    6034
5FE4:  BRA    6072
....................          case 0x7f:    
....................             if(nbcar>0)   
5FE6:  MOVLB  7
5FE8:  MOVF   xF9,F
5FEA:  BNZ   5FF0
5FEC:  MOVF   xFA,F
5FEE:  BZ    601A
5FF0:  CLRF   19
5FF2:  BTFSC  FF2.7
5FF4:  BSF    19.7
5FF6:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
5FF8:  MOVLW  7F
5FFA:  MOVLB  9
5FFC:  MOVWF  x0C
5FFE:  MOVLB  0
6000:  CALL   1604
6004:  BTFSC  19.7
6006:  BSF    FF2.7
....................                nbcar--; 
6008:  MOVLB  7
600A:  MOVF   xF9,W
600C:  BTFSC  FD8.2
600E:  DECF   xFA,F
6010:  DECF   xF9,F
....................                fgetc(COM2);//getc(); 
6012:  MOVLB  0
6014:  RCALL  5F64
....................             } 
....................             else fputc(0x07,COM2);    
6016:  BRA    6032
6018:  MOVLB  7
601A:  CLRF   19
601C:  BTFSC  FF2.7
601E:  BSF    19.7
6020:  BCF    FF2.7
6022:  MOVLW  07
6024:  MOVLB  9
6026:  MOVWF  x0C
6028:  MOVLB  0
602A:  CALL   1604
602E:  BTFSC  19.7
6030:  BSF    FF2.7
....................          break;  
6032:  BRA    60DE
....................          case 0x0D:   
....................                keydebug_en=0; 
6034:  MOVLB  1
6036:  CLRF   x44
....................                set_tris_a(0xff); 
6038:  MOVLW  FF
603A:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
603C:  MOVFF  7F9,7F8
6040:  MOVLB  7
6042:  MOVF   xF4,W
6044:  SUBWF  xF8,W
6046:  BC    605C
....................                { 
....................                  chaine[i]=0; 
6048:  CLRF   03
604A:  MOVF   xF8,W
604C:  ADDWF  xF5,W
604E:  MOVWF  FE9
6050:  MOVF   xF6,W
6052:  ADDWFC 03,W
6054:  MOVWF  FEA
6056:  CLRF   FEF
....................                } 
6058:  INCF   xF8,F
605A:  BRA    6042
....................                if(nbcar==0)return(FAUX); 
605C:  MOVF   xF9,F
605E:  BNZ   606A
6060:  MOVF   xFA,F
6062:  BNZ   606A
6064:  MOVLW  00
6066:  MOVWF  01
6068:  BRA    60E6
....................                fini=VRAI; 
606A:  MOVLW  01
606C:  MOVWF  xFB
....................          break; 
606E:  MOVLB  0
6070:  BRA    60DE
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
6072:  MOVLB  7
6074:  MOVF   xF7,W
6076:  SUBLW  1F
6078:  BC    60E0
607A:  MOVF   xF7,W
607C:  SUBLW  7E
607E:  BNC   60E0
6080:  MOVLW  01
6082:  SUBWF  xF4,W
6084:  MOVF   xFA,F
6086:  BNZ   60E0
6088:  SUBWF  xF9,W
608A:  BC    60E0
....................             { 
....................                chaine[nbcar]=c; 
608C:  MOVF   xF5,W
608E:  ADDWF  xF9,W
6090:  MOVWF  FE9
6092:  MOVF   xF6,W
6094:  ADDWFC xFA,W
6096:  MOVWF  FEA
6098:  MOVFF  7F7,FEF
....................                nbcar++; 
609C:  INCF   xF9,F
609E:  BTFSC  FD8.2
60A0:  INCF   xFA,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
60A2:  DECFSZ xF3,W
60A4:  BRA    60C0
60A6:  CLRF   19
60A8:  BTFSC  FF2.7
60AA:  BSF    19.7
60AC:  BCF    FF2.7
60AE:  MOVFF  7F7,90C
60B2:  MOVLB  0
60B4:  CALL   1604
60B8:  BTFSC  19.7
60BA:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
60BC:  BRA    60DE
60BE:  MOVLB  7
60C0:  MOVF   xF3,W
60C2:  SUBLW  02
60C4:  BNZ   60E0
60C6:  CLRF   19
60C8:  BTFSC  FF2.7
60CA:  BSF    19.7
60CC:  BCF    FF2.7
60CE:  MOVLW  2A
60D0:  MOVLB  9
60D2:  MOVWF  x0C
60D4:  MOVLB  0
60D6:  CALL   1604
60DA:  BTFSC  19.7
60DC:  BSF    FF2.7
60DE:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
60E0:  BRA    5FBA
....................    return(nbcar); 
60E2:  MOVFF  7F9,01
.................... } 
60E6:  MOVLB  0
60E8:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
60EA:  MOVFF  7F4,7F8
60EE:  MOVFF  7F3,7F7
60F2:  MOVFF  7F6,7FA
60F6:  MOVFF  7F5,7F9
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
60FA:  MOVFF  7F8,03
60FE:  MOVLB  7
6100:  MOVFF  7F7,FE9
6104:  MOVFF  7F8,FEA
6108:  MOVF   FEF,F
610A:  BZ    6152
610C:  MOVFF  7FA,03
6110:  MOVFF  7F9,FE9
6114:  MOVFF  7FA,FEA
6118:  MOVF   FEF,F
611A:  BZ    6152
....................       if(*aa!=*bb) 
611C:  MOVFF  7F7,FE9
6120:  MOVFF  7F8,FEA
6124:  MOVFF  FEF,7FB
6128:  MOVFF  7FA,03
612C:  MOVFF  7F9,FE9
6130:  MOVFF  7FA,FEA
6134:  MOVF   FEF,W
6136:  SUBWF  xFB,W
6138:  BZ    6140
....................          return(1); 
613A:  MOVLW  01
613C:  MOVWF  01
613E:  BRA    617E
....................       aa++; 
6140:  INCF   xF7,F
6142:  BTFSC  FD8.2
6144:  INCF   xF8,F
....................       bb++; 
6146:  INCF   xF9,F
6148:  BTFSC  FD8.2
614A:  INCF   xFA,F
....................    } 
614C:  MOVLB  0
614E:  BRA    60FA
6150:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
6152:  MOVFF  7F8,03
6156:  MOVFF  7F7,FE9
615A:  MOVFF  7F8,FEA
615E:  MOVFF  FEF,7FB
6162:  MOVFF  7FA,03
6166:  MOVFF  7F9,FE9
616A:  MOVFF  7FA,FEA
616E:  MOVF   FEF,W
6170:  SUBWF  xFB,W
6172:  BZ    617A
6174:  MOVLW  01
6176:  MOVWF  01
6178:  BRA    617E
....................    return(0); 
617A:  MOVLW  00
617C:  MOVWF  01
.................... } 
617E:  MOVLB  0
6180:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
6B5A:  MOVLB  7
6B5C:  CLRF   xF5
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
6B5E:  MOVFF  7F4,03
6B62:  MOVF   xF3,W
6B64:  INCF   xF3,F
6B66:  BTFSC  FD8.2
6B68:  INCF   xF4,F
6B6A:  MOVWF  FE9
6B6C:  MOVFF  03,FEA
6B70:  MOVFF  FEF,7F7
6B74:  MOVF   xF7,F
6B76:  BZ    6B9A
....................         if (c >= '0' && c <= '9') 
6B78:  MOVF   xF7,W
6B7A:  SUBLW  2F
6B7C:  BC    6B8C
6B7E:  MOVF   xF7,W
6B80:  SUBLW  39
6B82:  BNC   6B8C
....................             digit = (unsigned int) (c - '0'); 
6B84:  MOVLW  30
6B86:  SUBWF  xF7,W
6B88:  MOVWF  xF6
....................         else 
6B8A:  BRA    6B8E
....................             break; 
6B8C:  BRA    6B9A
....................  
....................         val = (val * 10) + digit; 
6B8E:  MOVF   xF5,W
6B90:  MULLW  0A
6B92:  MOVF   FF3,W
6B94:  ADDWF  xF6,W
6B96:  MOVWF  xF5
....................     } 
6B98:  BRA    6B5E
....................  
....................     return val; 
6B9A:  CLRF   03
6B9C:  MOVFF  7F5,01
6BA0:  MOVFF  03,02
.................... } 
6BA4:  MOVLB  0
6BA6:  RETURN 0
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
06AC:  MOVLB  9
06AE:  CLRF   x3F
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
06B0:  CLRF   x40
06B2:  BTFSC  x37.0
06B4:  BSF    x40.7
06B6:  SWAPF  x38,W
06B8:  MOVWF  00
06BA:  RLCF   00,F
06BC:  RLCF   00,F
06BE:  MOVLW  C0
06C0:  ANDWF  00,F
06C2:  MOVF   00,W
06C4:  IORWF  x40,F
06C6:  SWAPF  x39,W
06C8:  MOVWF  00
06CA:  RLCF   00,F
06CC:  MOVLW  E0
06CE:  ANDWF  00,F
06D0:  MOVF   00,W
06D2:  IORWF  x40,F
06D4:  SWAPF  x3A,W
06D6:  MOVWF  00
06D8:  MOVLW  F0
06DA:  ANDWF  00,F
06DC:  MOVF   00,W
06DE:  IORWF  x40,F
06E0:  RLCF   x3B,W
06E2:  MOVWF  00
06E4:  RLCF   00,F
06E6:  RLCF   00,F
06E8:  MOVLW  F8
06EA:  ANDWF  00,F
06EC:  MOVF   00,W
06EE:  IORWF  x40,F
06F0:  RLCF   x3C,W
06F2:  MOVWF  00
06F4:  RLCF   00,F
06F6:  MOVLW  FC
06F8:  ANDWF  00,F
06FA:  MOVF   00,W
06FC:  IORWF  x40,F
06FE:  BCF    FD8.0
0700:  RLCF   x3D,W
0702:  IORWF  x40,F
0704:  MOVF   x3E,W
0706:  IORWF  x40,W
0708:  MOVWF  x3F
....................    return temp; 
070A:  MOVFF  93F,01
.................... } 
070E:  MOVLB  0
0710:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0712:  MOVLB  9
0714:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
0716:  MOVF   x22,F
0718:  BNZ   07EE
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
071A:  MOVF   x25,W
071C:  ADDWF  x23,W
071E:  MOVWF  FE9
0720:  MOVF   x26,W
0722:  ADDWFC x24,W
0724:  MOVWF  FEA
0726:  MOVFF  FEF,928
072A:  MOVLW  01
072C:  ADDWF  x23,W
072E:  MOVWF  x29
0730:  MOVLW  00
0732:  ADDWFC x24,W
0734:  MOVWF  x2A
0736:  MOVF   x25,W
0738:  ADDWF  x29,W
073A:  MOVWF  FE9
073C:  MOVF   x26,W
073E:  ADDWFC x2A,W
0740:  MOVWF  FEA
0742:  MOVF   FEF,W
0744:  XORWF  x28,F
0746:  MOVLW  02
0748:  ADDWF  x23,W
074A:  MOVWF  x2B
074C:  MOVLW  00
074E:  ADDWFC x24,W
0750:  MOVWF  x2C
0752:  MOVF   x25,W
0754:  ADDWF  x2B,W
0756:  MOVWF  FE9
0758:  MOVF   x26,W
075A:  ADDWFC x2C,W
075C:  MOVWF  FEA
075E:  MOVF   FEF,W
0760:  XORWF  x28,F
0762:  MOVLW  03
0764:  ADDWF  x23,W
0766:  MOVWF  x2D
0768:  MOVLW  00
076A:  ADDWFC x24,W
076C:  MOVWF  x2E
076E:  MOVF   x25,W
0770:  ADDWF  x2D,W
0772:  MOVWF  FE9
0774:  MOVF   x26,W
0776:  ADDWFC x2E,W
0778:  MOVWF  FEA
077A:  MOVF   FEF,W
077C:  XORWF  x28,F
077E:  MOVLW  04
0780:  ADDWF  x23,W
0782:  MOVWF  x2F
0784:  MOVLW  00
0786:  ADDWFC x24,W
0788:  MOVWF  x30
078A:  MOVF   x25,W
078C:  ADDWF  x2F,W
078E:  MOVWF  FE9
0790:  MOVF   x26,W
0792:  ADDWFC x30,W
0794:  MOVWF  FEA
0796:  MOVF   FEF,W
0798:  XORWF  x28,F
079A:  MOVLW  05
079C:  ADDWF  x23,W
079E:  MOVWF  x31
07A0:  MOVLW  00
07A2:  ADDWFC x24,W
07A4:  MOVWF  x32
07A6:  MOVF   x25,W
07A8:  ADDWF  x31,W
07AA:  MOVWF  FE9
07AC:  MOVF   x26,W
07AE:  ADDWFC x32,W
07B0:  MOVWF  FEA
07B2:  MOVF   FEF,W
07B4:  XORWF  x28,W
07B6:  BZ    07BC
07B8:  MOVLW  00
07BA:  BRA    07BE
07BC:  MOVLW  01
07BE:  MOVWF  x27
....................       if(temp==datain[offset+6]) return 1; 
07C0:  MOVLW  06
07C2:  ADDWF  x23,W
07C4:  MOVWF  x28
07C6:  MOVLW  00
07C8:  ADDWFC x24,W
07CA:  MOVWF  x29
07CC:  MOVF   x25,W
07CE:  ADDWF  x28,W
07D0:  MOVWF  FE9
07D2:  MOVF   x26,W
07D4:  ADDWFC x29,W
07D6:  MOVWF  FEA
07D8:  MOVF   FEF,W
07DA:  SUBWF  x27,W
07DC:  BNZ   07E6
07DE:  MOVLW  01
07E0:  MOVWF  01
07E2:  BRA    08BE
....................          else return 0; 
07E4:  BRA    07EC
07E6:  MOVLW  00
07E8:  MOVWF  01
07EA:  BRA    08BE
....................    } 
....................       else  
07EC:  BRA    08BE
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
07EE:  MOVF   x25,W
07F0:  ADDWF  x23,W
07F2:  MOVWF  FE9
07F4:  MOVF   x26,W
07F6:  ADDWFC x24,W
07F8:  MOVWF  FEA
07FA:  MOVFF  FEF,928
07FE:  MOVLW  01
0800:  SUBWF  x23,W
0802:  MOVWF  x29
0804:  MOVLW  00
0806:  SUBWFB x24,W
0808:  MOVWF  x2A
080A:  MOVF   x25,W
080C:  ADDWF  x29,W
080E:  MOVWF  FE9
0810:  MOVF   x26,W
0812:  ADDWFC x2A,W
0814:  MOVWF  FEA
0816:  MOVF   FEF,W
0818:  XORWF  x28,F
081A:  MOVLW  02
081C:  SUBWF  x23,W
081E:  MOVWF  x2B
0820:  MOVLW  00
0822:  SUBWFB x24,W
0824:  MOVWF  x2C
0826:  MOVF   x25,W
0828:  ADDWF  x2B,W
082A:  MOVWF  FE9
082C:  MOVF   x26,W
082E:  ADDWFC x2C,W
0830:  MOVWF  FEA
0832:  MOVF   FEF,W
0834:  XORWF  x28,F
0836:  MOVLW  03
0838:  SUBWF  x23,W
083A:  MOVWF  x2D
083C:  MOVLW  00
083E:  SUBWFB x24,W
0840:  MOVWF  x2E
0842:  MOVF   x25,W
0844:  ADDWF  x2D,W
0846:  MOVWF  FE9
0848:  MOVF   x26,W
084A:  ADDWFC x2E,W
084C:  MOVWF  FEA
084E:  MOVF   FEF,W
0850:  XORWF  x28,F
0852:  MOVLW  04
0854:  SUBWF  x23,W
0856:  MOVWF  x2F
0858:  MOVLW  00
085A:  SUBWFB x24,W
085C:  MOVWF  x30
085E:  MOVF   x25,W
0860:  ADDWF  x2F,W
0862:  MOVWF  FE9
0864:  MOVF   x26,W
0866:  ADDWFC x30,W
0868:  MOVWF  FEA
086A:  MOVF   FEF,W
086C:  XORWF  x28,F
086E:  MOVLW  05
0870:  SUBWF  x23,W
0872:  MOVWF  x31
0874:  MOVLW  00
0876:  SUBWFB x24,W
0878:  MOVWF  x32
087A:  MOVF   x25,W
087C:  ADDWF  x31,W
087E:  MOVWF  FE9
0880:  MOVF   x26,W
0882:  ADDWFC x32,W
0884:  MOVWF  FEA
0886:  MOVF   FEF,W
0888:  XORWF  x28,W
088A:  BZ    0890
088C:  MOVLW  00
088E:  BRA    0892
0890:  MOVLW  01
0892:  MOVWF  x27
....................          if(temp==datain[offset-6]) return 1; 
0894:  MOVLW  06
0896:  SUBWF  x23,W
0898:  MOVWF  x28
089A:  MOVLW  00
089C:  SUBWFB x24,W
089E:  MOVWF  x29
08A0:  MOVF   x25,W
08A2:  ADDWF  x28,W
08A4:  MOVWF  FE9
08A6:  MOVF   x26,W
08A8:  ADDWFC x29,W
08AA:  MOVWF  FEA
08AC:  MOVF   FEF,W
08AE:  SUBWF  x27,W
08B0:  BNZ   08BA
08B2:  MOVLW  01
08B4:  MOVWF  01
08B6:  BRA    08BE
....................             else return 0;          
08B8:  BRA    08BE
08BA:  MOVLW  00
08BC:  MOVWF  01
....................       } 
.................... } 
08BE:  MOVLB  0
08C0:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
08C2:  MOVLB  9
08C4:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
08C6:  MOVF   x22,F
08C8:  BNZ   0966
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
08CA:  MOVF   x25,W
08CC:  ADDWF  x23,W
08CE:  MOVWF  FE9
08D0:  MOVF   x26,W
08D2:  ADDWFC x24,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEF,928
08DA:  MOVLW  01
08DC:  ADDWF  x23,W
08DE:  MOVWF  x29
08E0:  MOVLW  00
08E2:  ADDWFC x24,W
08E4:  MOVWF  x2A
08E6:  MOVF   x25,W
08E8:  ADDWF  x29,W
08EA:  MOVWF  FE9
08EC:  MOVF   x26,W
08EE:  ADDWFC x2A,W
08F0:  MOVWF  FEA
08F2:  MOVF   FEF,W
08F4:  XORWF  x28,F
08F6:  MOVLW  02
08F8:  ADDWF  x23,W
08FA:  MOVWF  x2B
08FC:  MOVLW  00
08FE:  ADDWFC x24,W
0900:  MOVWF  x2C
0902:  MOVF   x25,W
0904:  ADDWF  x2B,W
0906:  MOVWF  FE9
0908:  MOVF   x26,W
090A:  ADDWFC x2C,W
090C:  MOVWF  FEA
090E:  MOVF   FEF,W
0910:  XORWF  x28,F
0912:  MOVLW  03
0914:  ADDWF  x23,W
0916:  MOVWF  x2D
0918:  MOVLW  00
091A:  ADDWFC x24,W
091C:  MOVWF  x2E
091E:  MOVF   x25,W
0920:  ADDWF  x2D,W
0922:  MOVWF  FE9
0924:  MOVF   x26,W
0926:  ADDWFC x2E,W
0928:  MOVWF  FEA
092A:  MOVF   FEF,W
092C:  XORWF  x28,W
092E:  BZ    0934
0930:  MOVLW  00
0932:  BRA    0936
0934:  MOVLW  01
0936:  MOVWF  x27
....................       if(temp==datain[offset+4]) return 1; 
0938:  MOVLW  04
093A:  ADDWF  x23,W
093C:  MOVWF  x28
093E:  MOVLW  00
0940:  ADDWFC x24,W
0942:  MOVWF  x29
0944:  MOVF   x25,W
0946:  ADDWF  x28,W
0948:  MOVWF  FE9
094A:  MOVF   x26,W
094C:  ADDWFC x29,W
094E:  MOVWF  FEA
0950:  MOVF   FEF,W
0952:  SUBWF  x27,W
0954:  BNZ   095E
0956:  MOVLW  01
0958:  MOVWF  01
095A:  BRA    09FE
....................          else return 0; 
095C:  BRA    0964
095E:  MOVLW  00
0960:  MOVWF  01
0962:  BRA    09FE
....................    } 
....................    else 
0964:  BRA    09FE
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0966:  MOVF   x25,W
0968:  ADDWF  x23,W
096A:  MOVWF  FE9
096C:  MOVF   x26,W
096E:  ADDWFC x24,W
0970:  MOVWF  FEA
0972:  MOVFF  FEF,928
0976:  MOVLW  01
0978:  SUBWF  x23,W
097A:  MOVWF  x29
097C:  MOVLW  00
097E:  SUBWFB x24,W
0980:  MOVWF  x2A
0982:  MOVF   x25,W
0984:  ADDWF  x29,W
0986:  MOVWF  FE9
0988:  MOVF   x26,W
098A:  ADDWFC x2A,W
098C:  MOVWF  FEA
098E:  MOVF   FEF,W
0990:  XORWF  x28,F
0992:  MOVLW  02
0994:  SUBWF  x23,W
0996:  MOVWF  x2B
0998:  MOVLW  00
099A:  SUBWFB x24,W
099C:  MOVWF  x2C
099E:  MOVF   x25,W
09A0:  ADDWF  x2B,W
09A2:  MOVWF  FE9
09A4:  MOVF   x26,W
09A6:  ADDWFC x2C,W
09A8:  MOVWF  FEA
09AA:  MOVF   FEF,W
09AC:  XORWF  x28,F
09AE:  MOVLW  03
09B0:  SUBWF  x23,W
09B2:  MOVWF  x2D
09B4:  MOVLW  00
09B6:  SUBWFB x24,W
09B8:  MOVWF  x2E
09BA:  MOVF   x25,W
09BC:  ADDWF  x2D,W
09BE:  MOVWF  FE9
09C0:  MOVF   x26,W
09C2:  ADDWFC x2E,W
09C4:  MOVWF  FEA
09C6:  MOVF   FEF,W
09C8:  XORWF  x28,W
09CA:  BZ    09D0
09CC:  MOVLW  00
09CE:  BRA    09D2
09D0:  MOVLW  01
09D2:  MOVWF  x27
....................       if(temp==datain[offset-4]) return 1; 
09D4:  MOVLW  04
09D6:  SUBWF  x23,W
09D8:  MOVWF  x28
09DA:  MOVLW  00
09DC:  SUBWFB x24,W
09DE:  MOVWF  x29
09E0:  MOVF   x25,W
09E2:  ADDWF  x28,W
09E4:  MOVWF  FE9
09E6:  MOVF   x26,W
09E8:  ADDWFC x29,W
09EA:  MOVWF  FEA
09EC:  MOVF   FEF,W
09EE:  SUBWF  x27,W
09F0:  BNZ   09FA
09F2:  MOVLW  01
09F4:  MOVWF  01
09F6:  BRA    09FE
....................          else return 0;                
09F8:  BRA    09FE
09FA:  MOVLW  00
09FC:  MOVWF  01
....................    } 
.................... } 
09FE:  MOVLB  0
0A00:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0A02:  MOVLB  9
0A04:  CLRF   x1E
0A06:  CLRF   x1F
0A08:  CLRF   x20
0A0A:  CLRF   x21
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0A0C:  CLRF   x1B
0A0E:  CLRF   x1A
0A10:  RRCF   x17,W
0A12:  MOVWF  03
0A14:  RRCF   x16,W
0A16:  MOVWF  02
0A18:  RRCF   03,F
0A1A:  RRCF   02,F
0A1C:  MOVLW  3F
0A1E:  ANDWF  03,F
0A20:  MOVFF  02,01
0A24:  MOVF   x1B,W
0A26:  SUBWF  03,W
0A28:  BTFSS  FD8.0
0A2A:  BRA    0FEA
0A2C:  BNZ   0A36
0A2E:  MOVF   01,W
0A30:  SUBWF  x1A,W
0A32:  BTFSC  FD8.0
0A34:  BRA    0FEA
....................    { 
....................       if(track==0) 
0A36:  MOVF   x15,F
0A38:  BTFSS  FD8.2
0A3A:  BRA    0D70
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0A3C:  MOVLW  06
0A3E:  ADDWF  x1A,W
0A40:  MOVWF  x22
0A42:  MOVLW  00
0A44:  ADDWFC x1B,W
0A46:  MOVWF  x23
0A48:  MOVF   x18,W
0A4A:  ADDWF  x22,W
0A4C:  MOVWF  FE9
0A4E:  MOVF   x19,W
0A50:  ADDWFC x23,W
0A52:  MOVWF  FEA
0A54:  MOVFF  FEF,924
0A58:  MOVLW  05
0A5A:  ADDWF  x1A,W
0A5C:  MOVWF  x25
0A5E:  MOVLW  00
0A60:  ADDWFC x1B,W
0A62:  MOVWF  x26
0A64:  MOVF   x18,W
0A66:  ADDWF  x25,W
0A68:  MOVWF  FE9
0A6A:  MOVF   x19,W
0A6C:  ADDWFC x26,W
0A6E:  MOVWF  FEA
0A70:  MOVFF  FEF,927
0A74:  MOVLW  04
0A76:  ADDWF  x1A,W
0A78:  MOVWF  x28
0A7A:  MOVLW  00
0A7C:  ADDWFC x1B,W
0A7E:  MOVWF  x29
0A80:  MOVF   x18,W
0A82:  ADDWF  x28,W
0A84:  MOVWF  FE9
0A86:  MOVF   x19,W
0A88:  ADDWFC x29,W
0A8A:  MOVWF  FEA
0A8C:  MOVFF  FEF,92A
0A90:  MOVLW  03
0A92:  ADDWF  x1A,W
0A94:  MOVWF  x2B
0A96:  MOVLW  00
0A98:  ADDWFC x1B,W
0A9A:  MOVWF  x2C
0A9C:  MOVF   x18,W
0A9E:  ADDWF  x2B,W
0AA0:  MOVWF  FE9
0AA2:  MOVF   x19,W
0AA4:  ADDWFC x2C,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEF,92D
0AAC:  MOVLW  02
0AAE:  ADDWF  x1A,W
0AB0:  MOVWF  x2E
0AB2:  MOVLW  00
0AB4:  ADDWFC x1B,W
0AB6:  MOVWF  x2F
0AB8:  MOVF   x18,W
0ABA:  ADDWF  x2E,W
0ABC:  MOVWF  FE9
0ABE:  MOVF   x19,W
0AC0:  ADDWFC x2F,W
0AC2:  MOVWF  FEA
0AC4:  MOVFF  FEF,930
0AC8:  MOVLW  01
0ACA:  ADDWF  x1A,W
0ACC:  MOVWF  x31
0ACE:  MOVLW  00
0AD0:  ADDWFC x1B,W
0AD2:  MOVWF  x32
0AD4:  MOVF   x18,W
0AD6:  ADDWF  x31,W
0AD8:  MOVWF  FE9
0ADA:  MOVF   x19,W
0ADC:  ADDWFC x32,W
0ADE:  MOVWF  FEA
0AE0:  MOVFF  FEF,933
0AE4:  MOVF   x18,W
0AE6:  ADDWF  x1A,W
0AE8:  MOVWF  FE9
0AEA:  MOVF   x19,W
0AEC:  ADDWFC x1B,W
0AEE:  MOVWF  FEA
0AF0:  MOVFF  FEF,934
0AF4:  CLRF   x37
0AF6:  MOVFF  924,938
0AFA:  MOVFF  927,939
0AFE:  MOVFF  92A,93A
0B02:  MOVFF  92D,93B
0B06:  MOVFF  930,93C
0B0A:  MOVFF  933,93D
0B0E:  MOVFF  934,93E
0B12:  MOVLB  0
0B14:  RCALL  06AC
0B16:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0B1A:  MOVLW  0D
0B1C:  MOVLB  9
0B1E:  ADDWF  x1A,W
0B20:  MOVWF  x22
0B22:  MOVLW  00
0B24:  ADDWFC x1B,W
0B26:  MOVWF  x23
0B28:  MOVF   x18,W
0B2A:  ADDWF  x22,W
0B2C:  MOVWF  FE9
0B2E:  MOVF   x19,W
0B30:  ADDWFC x23,W
0B32:  MOVWF  FEA
0B34:  MOVFF  FEF,924
0B38:  MOVLW  0C
0B3A:  ADDWF  x1A,W
0B3C:  MOVWF  x25
0B3E:  MOVLW  00
0B40:  ADDWFC x1B,W
0B42:  MOVWF  x26
0B44:  MOVF   x18,W
0B46:  ADDWF  x25,W
0B48:  MOVWF  FE9
0B4A:  MOVF   x19,W
0B4C:  ADDWFC x26,W
0B4E:  MOVWF  FEA
0B50:  MOVFF  FEF,927
0B54:  MOVLW  0B
0B56:  ADDWF  x1A,W
0B58:  MOVWF  x28
0B5A:  MOVLW  00
0B5C:  ADDWFC x1B,W
0B5E:  MOVWF  x29
0B60:  MOVF   x18,W
0B62:  ADDWF  x28,W
0B64:  MOVWF  FE9
0B66:  MOVF   x19,W
0B68:  ADDWFC x29,W
0B6A:  MOVWF  FEA
0B6C:  MOVFF  FEF,92A
0B70:  MOVLW  0A
0B72:  ADDWF  x1A,W
0B74:  MOVWF  x2B
0B76:  MOVLW  00
0B78:  ADDWFC x1B,W
0B7A:  MOVWF  x2C
0B7C:  MOVF   x18,W
0B7E:  ADDWF  x2B,W
0B80:  MOVWF  FE9
0B82:  MOVF   x19,W
0B84:  ADDWFC x2C,W
0B86:  MOVWF  FEA
0B88:  MOVFF  FEF,92D
0B8C:  MOVLW  09
0B8E:  ADDWF  x1A,W
0B90:  MOVWF  x2E
0B92:  MOVLW  00
0B94:  ADDWFC x1B,W
0B96:  MOVWF  x2F
0B98:  MOVF   x18,W
0B9A:  ADDWF  x2E,W
0B9C:  MOVWF  FE9
0B9E:  MOVF   x19,W
0BA0:  ADDWFC x2F,W
0BA2:  MOVWF  FEA
0BA4:  MOVFF  FEF,930
0BA8:  MOVLW  08
0BAA:  ADDWF  x1A,W
0BAC:  MOVWF  x31
0BAE:  MOVLW  00
0BB0:  ADDWFC x1B,W
0BB2:  MOVWF  x32
0BB4:  MOVF   x18,W
0BB6:  ADDWF  x31,W
0BB8:  MOVWF  FE9
0BBA:  MOVF   x19,W
0BBC:  ADDWFC x32,W
0BBE:  MOVWF  FEA
0BC0:  MOVFF  FEF,933
0BC4:  MOVLW  07
0BC6:  ADDWF  x1A,W
0BC8:  MOVWF  x34
0BCA:  MOVLW  00
0BCC:  ADDWFC x1B,W
0BCE:  MOVWF  x35
0BD0:  MOVF   x18,W
0BD2:  ADDWF  x34,W
0BD4:  MOVWF  FE9
0BD6:  MOVF   x19,W
0BD8:  ADDWFC x35,W
0BDA:  MOVWF  FEA
0BDC:  MOVFF  FEF,936
0BE0:  CLRF   x37
0BE2:  MOVFF  924,938
0BE6:  MOVFF  927,939
0BEA:  MOVFF  92A,93A
0BEE:  MOVFF  92D,93B
0BF2:  MOVFF  930,93C
0BF6:  MOVFF  933,93D
0BFA:  MOVFF  936,93E
0BFE:  MOVLB  0
0C00:  RCALL  06AC
0C02:  MOVFF  01,91F
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0C06:  MOVLB  9
0C08:  MOVF   x1E,W
0C0A:  SUBLW  45
0C0C:  BTFSS  FD8.2
0C0E:  BRA    0D6E
0C10:  MOVF   x1F,W
0C12:  SUBLW  7C
0C14:  BTFSC  FD8.2
0C16:  BRA    0D6E
0C18:  MOVF   x1F,W
0C1A:  SUBLW  3E
0C1C:  BTFSC  FD8.2
0C1E:  BRA    0D6E
0C20:  MOVF   x1F,W
0C22:  SUBLW  1F
0C24:  BTFSC  FD8.2
0C26:  BRA    0D6E
....................          { 
....................             j=i; 
0C28:  MOVFF  91B,91D
0C2C:  MOVFF  91A,91C
....................             CRC=1; 
0C30:  MOVLW  01
0C32:  MOVWF  x21
....................             temp2=temp; 
0C34:  MOVFF  91E,920
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0C38:  MOVF   x20,W
0C3A:  SUBLW  1F
0C3C:  BTFSC  FD8.2
0C3E:  BRA    0D58
0C40:  MOVF   x1D,W
0C42:  SUBLW  03
0C44:  BTFSS  FD8.0
0C46:  BRA    0D58
0C48:  BNZ   0C52
0C4A:  MOVF   x1C,W
0C4C:  SUBLW  E7
0C4E:  BTFSS  FD8.0
0C50:  BRA    0D58
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C52:  CLRF   x22
0C54:  MOVFF  91D,924
0C58:  MOVFF  91C,923
0C5C:  MOVFF  919,926
0C60:  MOVFF  918,925
0C64:  MOVLB  0
0C66:  RCALL  0712
0C68:  MOVF   01,W
0C6A:  MOVLB  9
0C6C:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C6E:  MOVLW  06
0C70:  ADDWF  x1C,W
0C72:  MOVWF  x22
0C74:  MOVLW  00
0C76:  ADDWFC x1D,W
0C78:  MOVWF  x23
0C7A:  MOVF   x18,W
0C7C:  ADDWF  x22,W
0C7E:  MOVWF  FE9
0C80:  MOVF   x19,W
0C82:  ADDWFC x23,W
0C84:  MOVWF  FEA
0C86:  MOVFF  FEF,924
0C8A:  MOVLW  05
0C8C:  ADDWF  x1C,W
0C8E:  MOVWF  x25
0C90:  MOVLW  00
0C92:  ADDWFC x1D,W
0C94:  MOVWF  x26
0C96:  MOVF   x18,W
0C98:  ADDWF  x25,W
0C9A:  MOVWF  FE9
0C9C:  MOVF   x19,W
0C9E:  ADDWFC x26,W
0CA0:  MOVWF  FEA
0CA2:  MOVFF  FEF,927
0CA6:  MOVLW  04
0CA8:  ADDWF  x1C,W
0CAA:  MOVWF  x28
0CAC:  MOVLW  00
0CAE:  ADDWFC x1D,W
0CB0:  MOVWF  x29
0CB2:  MOVF   x18,W
0CB4:  ADDWF  x28,W
0CB6:  MOVWF  FE9
0CB8:  MOVF   x19,W
0CBA:  ADDWFC x29,W
0CBC:  MOVWF  FEA
0CBE:  MOVFF  FEF,92A
0CC2:  MOVLW  03
0CC4:  ADDWF  x1C,W
0CC6:  MOVWF  x2B
0CC8:  MOVLW  00
0CCA:  ADDWFC x1D,W
0CCC:  MOVWF  x2C
0CCE:  MOVF   x18,W
0CD0:  ADDWF  x2B,W
0CD2:  MOVWF  FE9
0CD4:  MOVF   x19,W
0CD6:  ADDWFC x2C,W
0CD8:  MOVWF  FEA
0CDA:  MOVFF  FEF,92D
0CDE:  MOVLW  02
0CE0:  ADDWF  x1C,W
0CE2:  MOVWF  x2E
0CE4:  MOVLW  00
0CE6:  ADDWFC x1D,W
0CE8:  MOVWF  x2F
0CEA:  MOVF   x18,W
0CEC:  ADDWF  x2E,W
0CEE:  MOVWF  FE9
0CF0:  MOVF   x19,W
0CF2:  ADDWFC x2F,W
0CF4:  MOVWF  FEA
0CF6:  MOVFF  FEF,930
0CFA:  MOVLW  01
0CFC:  ADDWF  x1C,W
0CFE:  MOVWF  x31
0D00:  MOVLW  00
0D02:  ADDWFC x1D,W
0D04:  MOVWF  x32
0D06:  MOVF   x18,W
0D08:  ADDWF  x31,W
0D0A:  MOVWF  FE9
0D0C:  MOVF   x19,W
0D0E:  ADDWFC x32,W
0D10:  MOVWF  FEA
0D12:  MOVFF  FEF,933
0D16:  MOVF   x18,W
0D18:  ADDWF  x1C,W
0D1A:  MOVWF  FE9
0D1C:  MOVF   x19,W
0D1E:  ADDWFC x1D,W
0D20:  MOVWF  FEA
0D22:  MOVFF  FEF,934
0D26:  CLRF   x37
0D28:  MOVFF  924,938
0D2C:  MOVFF  927,939
0D30:  MOVFF  92A,93A
0D34:  MOVFF  92D,93B
0D38:  MOVFF  930,93C
0D3C:  MOVFF  933,93D
0D40:  MOVFF  934,93E
0D44:  MOVLB  0
0D46:  RCALL  06AC
0D48:  MOVFF  01,920
....................                j=j+7; 
0D4C:  MOVLW  07
0D4E:  MOVLB  9
0D50:  ADDWF  x1C,F
0D52:  MOVLW  00
0D54:  ADDWFC x1D,F
....................             } 
0D56:  BRA    0C38
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D58:  DECFSZ x21,W
0D5A:  BRA    0D6E
....................             { 
....................                dir=0; 
0D5C:  MOVLB  6
0D5E:  CLRF   xC8
....................                return i; 
0D60:  MOVLB  9
0D62:  MOVFF  91A,01
0D66:  MOVFF  91B,02
0D6A:  GOTO   1600
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0D6E:  BRA    0FE2
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0D70:  MOVLW  04
0D72:  ADDWF  x1A,W
0D74:  MOVWF  x22
0D76:  MOVLW  00
0D78:  ADDWFC x1B,W
0D7A:  MOVWF  x23
0D7C:  MOVF   x18,W
0D7E:  ADDWF  x22,W
0D80:  MOVWF  FE9
0D82:  MOVF   x19,W
0D84:  ADDWFC x23,W
0D86:  MOVWF  FEA
0D88:  MOVFF  FEF,924
0D8C:  MOVLW  03
0D8E:  ADDWF  x1A,W
0D90:  MOVWF  x25
0D92:  MOVLW  00
0D94:  ADDWFC x1B,W
0D96:  MOVWF  x26
0D98:  MOVF   x18,W
0D9A:  ADDWF  x25,W
0D9C:  MOVWF  FE9
0D9E:  MOVF   x19,W
0DA0:  ADDWFC x26,W
0DA2:  MOVWF  FEA
0DA4:  MOVFF  FEF,927
0DA8:  MOVLW  02
0DAA:  ADDWF  x1A,W
0DAC:  MOVWF  x28
0DAE:  MOVLW  00
0DB0:  ADDWFC x1B,W
0DB2:  MOVWF  x29
0DB4:  MOVF   x18,W
0DB6:  ADDWF  x28,W
0DB8:  MOVWF  FE9
0DBA:  MOVF   x19,W
0DBC:  ADDWFC x29,W
0DBE:  MOVWF  FEA
0DC0:  MOVFF  FEF,92A
0DC4:  MOVLW  01
0DC6:  ADDWF  x1A,W
0DC8:  MOVWF  x2B
0DCA:  MOVLW  00
0DCC:  ADDWFC x1B,W
0DCE:  MOVWF  x2C
0DD0:  MOVF   x18,W
0DD2:  ADDWF  x2B,W
0DD4:  MOVWF  FE9
0DD6:  MOVF   x19,W
0DD8:  ADDWFC x2C,W
0DDA:  MOVWF  FEA
0DDC:  MOVFF  FEF,92D
0DE0:  MOVF   x18,W
0DE2:  ADDWF  x1A,W
0DE4:  MOVWF  FE9
0DE6:  MOVF   x19,W
0DE8:  ADDWFC x1B,W
0DEA:  MOVWF  FEA
0DEC:  MOVFF  FEF,92E
0DF0:  CLRF   x37
0DF2:  CLRF   x38
0DF4:  CLRF   x39
0DF6:  MOVFF  924,93A
0DFA:  MOVFF  927,93B
0DFE:  MOVFF  92A,93C
0E02:  MOVFF  92D,93D
0E06:  MOVFF  92E,93E
0E0A:  MOVLB  0
0E0C:  RCALL  06AC
0E0E:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0E12:  MOVLW  09
0E14:  MOVLB  9
0E16:  ADDWF  x1A,W
0E18:  MOVWF  x22
0E1A:  MOVLW  00
0E1C:  ADDWFC x1B,W
0E1E:  MOVWF  x23
0E20:  MOVF   x18,W
0E22:  ADDWF  x22,W
0E24:  MOVWF  FE9
0E26:  MOVF   x19,W
0E28:  ADDWFC x23,W
0E2A:  MOVWF  FEA
0E2C:  MOVFF  FEF,924
0E30:  MOVLW  08
0E32:  ADDWF  x1A,W
0E34:  MOVWF  x25
0E36:  MOVLW  00
0E38:  ADDWFC x1B,W
0E3A:  MOVWF  x26
0E3C:  MOVF   x18,W
0E3E:  ADDWF  x25,W
0E40:  MOVWF  FE9
0E42:  MOVF   x19,W
0E44:  ADDWFC x26,W
0E46:  MOVWF  FEA
0E48:  MOVFF  FEF,927
0E4C:  MOVLW  07
0E4E:  ADDWF  x1A,W
0E50:  MOVWF  x28
0E52:  MOVLW  00
0E54:  ADDWFC x1B,W
0E56:  MOVWF  x29
0E58:  MOVF   x18,W
0E5A:  ADDWF  x28,W
0E5C:  MOVWF  FE9
0E5E:  MOVF   x19,W
0E60:  ADDWFC x29,W
0E62:  MOVWF  FEA
0E64:  MOVFF  FEF,92A
0E68:  MOVLW  06
0E6A:  ADDWF  x1A,W
0E6C:  MOVWF  x2B
0E6E:  MOVLW  00
0E70:  ADDWFC x1B,W
0E72:  MOVWF  x2C
0E74:  MOVF   x18,W
0E76:  ADDWF  x2B,W
0E78:  MOVWF  FE9
0E7A:  MOVF   x19,W
0E7C:  ADDWFC x2C,W
0E7E:  MOVWF  FEA
0E80:  MOVFF  FEF,92D
0E84:  MOVLW  05
0E86:  ADDWF  x1A,W
0E88:  MOVWF  x2E
0E8A:  MOVLW  00
0E8C:  ADDWFC x1B,W
0E8E:  MOVWF  x2F
0E90:  MOVF   x18,W
0E92:  ADDWF  x2E,W
0E94:  MOVWF  FE9
0E96:  MOVF   x19,W
0E98:  ADDWFC x2F,W
0E9A:  MOVWF  FEA
0E9C:  MOVFF  FEF,930
0EA0:  CLRF   x37
0EA2:  CLRF   x38
0EA4:  CLRF   x39
0EA6:  MOVFF  924,93A
0EAA:  MOVFF  927,93B
0EAE:  MOVFF  92A,93C
0EB2:  MOVFF  92D,93D
0EB6:  MOVFF  930,93E
0EBA:  MOVLB  0
0EBC:  CALL   06AC
0EC0:  MOVFF  01,91F
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0EC4:  MOVLB  9
0EC6:  MOVF   x1E,W
0EC8:  SUBLW  0B
0ECA:  BTFSS  FD8.2
0ECC:  BRA    0FE2
0ECE:  MOVF   x1F,W
0ED0:  SUBLW  1F
0ED2:  BTFSC  FD8.2
0ED4:  BRA    0FE2
0ED6:  MOVF   x1F,W
0ED8:  SUBLW  0F
0EDA:  BTFSC  FD8.2
0EDC:  BRA    0FE2
....................             { 
....................                j=i; 
0EDE:  MOVFF  91B,91D
0EE2:  MOVFF  91A,91C
....................                CRC=1; 
0EE6:  MOVLW  01
0EE8:  MOVWF  x21
....................                temp2=temp; 
0EEA:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0EEE:  MOVF   x20,W
0EF0:  SUBLW  1F
0EF2:  BZ    0FCE
0EF4:  MOVF   x1D,W
0EF6:  SUBLW  01
0EF8:  BNC   0FCE
0EFA:  BNZ   0F02
0EFC:  MOVF   x1C,W
0EFE:  SUBLW  F3
0F00:  BNC   0FCE
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0F02:  CLRF   x22
0F04:  MOVFF  91D,924
0F08:  MOVFF  91C,923
0F0C:  MOVFF  919,926
0F10:  MOVFF  918,925
0F14:  MOVLB  0
0F16:  RCALL  08C2
0F18:  MOVF   01,W
0F1A:  MOVLB  9
0F1C:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0F1E:  MOVLW  04
0F20:  ADDWF  x1C,W
0F22:  MOVWF  x22
0F24:  MOVLW  00
0F26:  ADDWFC x1D,W
0F28:  MOVWF  x23
0F2A:  MOVF   x18,W
0F2C:  ADDWF  x22,W
0F2E:  MOVWF  FE9
0F30:  MOVF   x19,W
0F32:  ADDWFC x23,W
0F34:  MOVWF  FEA
0F36:  MOVFF  FEF,924
0F3A:  MOVLW  03
0F3C:  ADDWF  x1C,W
0F3E:  MOVWF  x25
0F40:  MOVLW  00
0F42:  ADDWFC x1D,W
0F44:  MOVWF  x26
0F46:  MOVF   x18,W
0F48:  ADDWF  x25,W
0F4A:  MOVWF  FE9
0F4C:  MOVF   x19,W
0F4E:  ADDWFC x26,W
0F50:  MOVWF  FEA
0F52:  MOVFF  FEF,927
0F56:  MOVLW  02
0F58:  ADDWF  x1C,W
0F5A:  MOVWF  x28
0F5C:  MOVLW  00
0F5E:  ADDWFC x1D,W
0F60:  MOVWF  x29
0F62:  MOVF   x18,W
0F64:  ADDWF  x28,W
0F66:  MOVWF  FE9
0F68:  MOVF   x19,W
0F6A:  ADDWFC x29,W
0F6C:  MOVWF  FEA
0F6E:  MOVFF  FEF,92A
0F72:  MOVLW  01
0F74:  ADDWF  x1C,W
0F76:  MOVWF  x2B
0F78:  MOVLW  00
0F7A:  ADDWFC x1D,W
0F7C:  MOVWF  x2C
0F7E:  MOVF   x18,W
0F80:  ADDWF  x2B,W
0F82:  MOVWF  FE9
0F84:  MOVF   x19,W
0F86:  ADDWFC x2C,W
0F88:  MOVWF  FEA
0F8A:  MOVFF  FEF,92D
0F8E:  MOVF   x18,W
0F90:  ADDWF  x1C,W
0F92:  MOVWF  FE9
0F94:  MOVF   x19,W
0F96:  ADDWFC x1D,W
0F98:  MOVWF  FEA
0F9A:  MOVFF  FEF,92E
0F9E:  CLRF   x37
0FA0:  CLRF   x38
0FA2:  CLRF   x39
0FA4:  MOVFF  924,93A
0FA8:  MOVFF  927,93B
0FAC:  MOVFF  92A,93C
0FB0:  MOVFF  92D,93D
0FB4:  MOVFF  92E,93E
0FB8:  MOVLB  0
0FBA:  CALL   06AC
0FBE:  MOVFF  01,920
....................                   j=j+5; 
0FC2:  MOVLW  05
0FC4:  MOVLB  9
0FC6:  ADDWF  x1C,F
0FC8:  MOVLW  00
0FCA:  ADDWFC x1D,F
....................                } 
0FCC:  BRA    0EEE
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0FCE:  DECFSZ x21,W
0FD0:  BRA    0FE2
....................                { 
....................                   dir=0; 
0FD2:  MOVLB  6
0FD4:  CLRF   xC8
....................                   return i; 
0FD6:  MOVLB  9
0FD8:  MOVFF  91A,01
0FDC:  MOVFF  91B,02
0FE0:  BRA    1600
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0FE2:  INCF   x1A,F
0FE4:  BTFSC  FD8.2
0FE6:  INCF   x1B,F
0FE8:  BRA    0A10
....................    for(i=end_point;i>end_point/4;i--) 
0FEA:  MOVFF  917,91B
0FEE:  MOVFF  916,91A
0FF2:  RRCF   x17,W
0FF4:  MOVWF  03
0FF6:  RRCF   x16,W
0FF8:  MOVWF  02
0FFA:  RRCF   03,F
0FFC:  RRCF   02,F
0FFE:  MOVLW  3F
1000:  ANDWF  03,F
1002:  MOVFF  02,01
1006:  MOVF   03,W
1008:  SUBWF  x1B,W
100A:  BTFSS  FD8.0
100C:  BRA    15FA
100E:  BNZ   1018
1010:  MOVF   x1A,W
1012:  SUBWF  01,W
1014:  BTFSC  FD8.0
1016:  BRA    15FA
....................    { 
....................       if(track==0) 
1018:  MOVF   x15,F
101A:  BTFSS  FD8.2
101C:  BRA    1370
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
101E:  MOVLW  06
1020:  SUBWF  x1A,W
1022:  MOVWF  x22
1024:  MOVLW  00
1026:  SUBWFB x1B,W
1028:  MOVWF  x23
102A:  MOVF   x18,W
102C:  ADDWF  x22,W
102E:  MOVWF  FE9
1030:  MOVF   x19,W
1032:  ADDWFC x23,W
1034:  MOVWF  FEA
1036:  MOVFF  FEF,924
103A:  MOVLW  05
103C:  SUBWF  x1A,W
103E:  MOVWF  x25
1040:  MOVLW  00
1042:  SUBWFB x1B,W
1044:  MOVWF  x26
1046:  MOVF   x18,W
1048:  ADDWF  x25,W
104A:  MOVWF  FE9
104C:  MOVF   x19,W
104E:  ADDWFC x26,W
1050:  MOVWF  FEA
1052:  MOVFF  FEF,927
1056:  MOVLW  04
1058:  SUBWF  x1A,W
105A:  MOVWF  x28
105C:  MOVLW  00
105E:  SUBWFB x1B,W
1060:  MOVWF  x29
1062:  MOVF   x18,W
1064:  ADDWF  x28,W
1066:  MOVWF  FE9
1068:  MOVF   x19,W
106A:  ADDWFC x29,W
106C:  MOVWF  FEA
106E:  MOVFF  FEF,92A
1072:  MOVLW  03
1074:  SUBWF  x1A,W
1076:  MOVWF  x2B
1078:  MOVLW  00
107A:  SUBWFB x1B,W
107C:  MOVWF  x2C
107E:  MOVF   x18,W
1080:  ADDWF  x2B,W
1082:  MOVWF  FE9
1084:  MOVF   x19,W
1086:  ADDWFC x2C,W
1088:  MOVWF  FEA
108A:  MOVFF  FEF,92D
108E:  MOVLW  02
1090:  SUBWF  x1A,W
1092:  MOVWF  x2E
1094:  MOVLW  00
1096:  SUBWFB x1B,W
1098:  MOVWF  x2F
109A:  MOVF   x18,W
109C:  ADDWF  x2E,W
109E:  MOVWF  FE9
10A0:  MOVF   x19,W
10A2:  ADDWFC x2F,W
10A4:  MOVWF  FEA
10A6:  MOVFF  FEF,930
10AA:  MOVLW  01
10AC:  SUBWF  x1A,W
10AE:  MOVWF  x31
10B0:  MOVLW  00
10B2:  SUBWFB x1B,W
10B4:  MOVWF  x32
10B6:  MOVF   x18,W
10B8:  ADDWF  x31,W
10BA:  MOVWF  FE9
10BC:  MOVF   x19,W
10BE:  ADDWFC x32,W
10C0:  MOVWF  FEA
10C2:  MOVFF  FEF,933
10C6:  MOVF   x18,W
10C8:  ADDWF  x1A,W
10CA:  MOVWF  FE9
10CC:  MOVF   x19,W
10CE:  ADDWFC x1B,W
10D0:  MOVWF  FEA
10D2:  MOVFF  FEF,934
10D6:  CLRF   x37
10D8:  MOVFF  924,938
10DC:  MOVFF  927,939
10E0:  MOVFF  92A,93A
10E4:  MOVFF  92D,93B
10E8:  MOVFF  930,93C
10EC:  MOVFF  933,93D
10F0:  MOVFF  934,93E
10F4:  MOVLB  0
10F6:  CALL   06AC
10FA:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
10FE:  MOVLW  0D
1100:  MOVLB  9
1102:  SUBWF  x1A,W
1104:  MOVWF  x22
1106:  MOVLW  00
1108:  SUBWFB x1B,W
110A:  MOVWF  x23
110C:  MOVF   x18,W
110E:  ADDWF  x22,W
1110:  MOVWF  FE9
1112:  MOVF   x19,W
1114:  ADDWFC x23,W
1116:  MOVWF  FEA
1118:  MOVFF  FEF,924
111C:  MOVLW  0C
111E:  SUBWF  x1A,W
1120:  MOVWF  x25
1122:  MOVLW  00
1124:  SUBWFB x1B,W
1126:  MOVWF  x26
1128:  MOVF   x18,W
112A:  ADDWF  x25,W
112C:  MOVWF  FE9
112E:  MOVF   x19,W
1130:  ADDWFC x26,W
1132:  MOVWF  FEA
1134:  MOVFF  FEF,927
1138:  MOVLW  0B
113A:  SUBWF  x1A,W
113C:  MOVWF  x28
113E:  MOVLW  00
1140:  SUBWFB x1B,W
1142:  MOVWF  x29
1144:  MOVF   x18,W
1146:  ADDWF  x28,W
1148:  MOVWF  FE9
114A:  MOVF   x19,W
114C:  ADDWFC x29,W
114E:  MOVWF  FEA
1150:  MOVFF  FEF,92A
1154:  MOVLW  0A
1156:  SUBWF  x1A,W
1158:  MOVWF  x2B
115A:  MOVLW  00
115C:  SUBWFB x1B,W
115E:  MOVWF  x2C
1160:  MOVF   x18,W
1162:  ADDWF  x2B,W
1164:  MOVWF  FE9
1166:  MOVF   x19,W
1168:  ADDWFC x2C,W
116A:  MOVWF  FEA
116C:  MOVFF  FEF,92D
1170:  MOVLW  09
1172:  SUBWF  x1A,W
1174:  MOVWF  x2E
1176:  MOVLW  00
1178:  SUBWFB x1B,W
117A:  MOVWF  x2F
117C:  MOVF   x18,W
117E:  ADDWF  x2E,W
1180:  MOVWF  FE9
1182:  MOVF   x19,W
1184:  ADDWFC x2F,W
1186:  MOVWF  FEA
1188:  MOVFF  FEF,930
118C:  MOVLW  08
118E:  SUBWF  x1A,W
1190:  MOVWF  x31
1192:  MOVLW  00
1194:  SUBWFB x1B,W
1196:  MOVWF  x32
1198:  MOVF   x18,W
119A:  ADDWF  x31,W
119C:  MOVWF  FE9
119E:  MOVF   x19,W
11A0:  ADDWFC x32,W
11A2:  MOVWF  FEA
11A4:  MOVFF  FEF,933
11A8:  MOVLW  07
11AA:  SUBWF  x1A,W
11AC:  MOVWF  x34
11AE:  MOVLW  00
11B0:  SUBWFB x1B,W
11B2:  MOVWF  x35
11B4:  MOVF   x18,W
11B6:  ADDWF  x34,W
11B8:  MOVWF  FE9
11BA:  MOVF   x19,W
11BC:  ADDWFC x35,W
11BE:  MOVWF  FEA
11C0:  MOVFF  FEF,936
11C4:  CLRF   x37
11C6:  MOVFF  924,938
11CA:  MOVFF  927,939
11CE:  MOVFF  92A,93A
11D2:  MOVFF  92D,93B
11D6:  MOVFF  930,93C
11DA:  MOVFF  933,93D
11DE:  MOVFF  936,93E
11E2:  MOVLB  0
11E4:  CALL   06AC
11E8:  MOVFF  01,91F
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
11EC:  MOVLB  9
11EE:  MOVF   x1E,W
11F0:  SUBLW  45
11F2:  BTFSS  FD8.2
11F4:  BRA    136E
11F6:  MOVF   x1F,W
11F8:  SUBLW  7C
11FA:  BTFSC  FD8.2
11FC:  BRA    136E
11FE:  MOVF   x1F,W
1200:  SUBLW  3E
1202:  BTFSC  FD8.2
1204:  BRA    136E
1206:  MOVF   x1F,W
1208:  SUBLW  1F
120A:  BTFSC  FD8.2
120C:  BRA    136E
120E:  MOVF   x1F,W
1210:  SUBLW  0F
1212:  BTFSC  FD8.2
1214:  BRA    136E
1216:  MOVF   x1F,W
1218:  SUBLW  78
121A:  BTFSC  FD8.2
121C:  BRA    136E
....................          { 
....................             j=i; 
121E:  MOVFF  91B,91D
1222:  MOVFF  91A,91C
....................             CRC=1; 
1226:  MOVLW  01
1228:  MOVWF  x21
....................             temp2=temp; 
122A:  MOVFF  91E,920
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
122E:  MOVF   x20,W
1230:  SUBLW  1F
1232:  BTFSC  FD8.2
1234:  BRA    134E
1236:  MOVF   x1D,F
1238:  BNZ   1242
123A:  MOVF   x1C,W
123C:  SUBLW  01
123E:  BTFSC  FD8.0
1240:  BRA    134E
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1242:  MOVLW  01
1244:  MOVWF  x22
1246:  MOVFF  91D,924
124A:  MOVFF  91C,923
124E:  MOVFF  919,926
1252:  MOVFF  918,925
1256:  MOVLB  0
1258:  CALL   0712
125C:  MOVF   01,W
125E:  MOVLB  9
1260:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1262:  MOVLW  06
1264:  SUBWF  x1C,W
1266:  MOVWF  x22
1268:  MOVLW  00
126A:  SUBWFB x1D,W
126C:  MOVWF  x23
126E:  MOVF   x18,W
1270:  ADDWF  x22,W
1272:  MOVWF  FE9
1274:  MOVF   x19,W
1276:  ADDWFC x23,W
1278:  MOVWF  FEA
127A:  MOVFF  FEF,924
127E:  MOVLW  05
1280:  SUBWF  x1C,W
1282:  MOVWF  x25
1284:  MOVLW  00
1286:  SUBWFB x1D,W
1288:  MOVWF  x26
128A:  MOVF   x18,W
128C:  ADDWF  x25,W
128E:  MOVWF  FE9
1290:  MOVF   x19,W
1292:  ADDWFC x26,W
1294:  MOVWF  FEA
1296:  MOVFF  FEF,927
129A:  MOVLW  04
129C:  SUBWF  x1C,W
129E:  MOVWF  x28
12A0:  MOVLW  00
12A2:  SUBWFB x1D,W
12A4:  MOVWF  x29
12A6:  MOVF   x18,W
12A8:  ADDWF  x28,W
12AA:  MOVWF  FE9
12AC:  MOVF   x19,W
12AE:  ADDWFC x29,W
12B0:  MOVWF  FEA
12B2:  MOVFF  FEF,92A
12B6:  MOVLW  03
12B8:  SUBWF  x1C,W
12BA:  MOVWF  x2B
12BC:  MOVLW  00
12BE:  SUBWFB x1D,W
12C0:  MOVWF  x2C
12C2:  MOVF   x18,W
12C4:  ADDWF  x2B,W
12C6:  MOVWF  FE9
12C8:  MOVF   x19,W
12CA:  ADDWFC x2C,W
12CC:  MOVWF  FEA
12CE:  MOVFF  FEF,92D
12D2:  MOVLW  02
12D4:  SUBWF  x1C,W
12D6:  MOVWF  x2E
12D8:  MOVLW  00
12DA:  SUBWFB x1D,W
12DC:  MOVWF  x2F
12DE:  MOVF   x18,W
12E0:  ADDWF  x2E,W
12E2:  MOVWF  FE9
12E4:  MOVF   x19,W
12E6:  ADDWFC x2F,W
12E8:  MOVWF  FEA
12EA:  MOVFF  FEF,930
12EE:  MOVLW  01
12F0:  SUBWF  x1C,W
12F2:  MOVWF  x31
12F4:  MOVLW  00
12F6:  SUBWFB x1D,W
12F8:  MOVWF  x32
12FA:  MOVF   x18,W
12FC:  ADDWF  x31,W
12FE:  MOVWF  FE9
1300:  MOVF   x19,W
1302:  ADDWFC x32,W
1304:  MOVWF  FEA
1306:  MOVFF  FEF,933
130A:  MOVF   x18,W
130C:  ADDWF  x1C,W
130E:  MOVWF  FE9
1310:  MOVF   x19,W
1312:  ADDWFC x1D,W
1314:  MOVWF  FEA
1316:  MOVFF  FEF,934
131A:  CLRF   x37
131C:  MOVFF  924,938
1320:  MOVFF  927,939
1324:  MOVFF  92A,93A
1328:  MOVFF  92D,93B
132C:  MOVFF  930,93C
1330:  MOVFF  933,93D
1334:  MOVFF  934,93E
1338:  MOVLB  0
133A:  CALL   06AC
133E:  MOVFF  01,920
....................                j=j-7;             
1342:  MOVLW  07
1344:  MOVLB  9
1346:  SUBWF  x1C,F
1348:  MOVLW  00
134A:  SUBWFB x1D,F
....................              } 
134C:  BRA    122E
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
134E:  DECFSZ x21,W
1350:  BRA    1366
....................             { 
....................                dir=1; 
1352:  MOVLW  01
1354:  MOVLB  6
1356:  MOVWF  xC8
....................                return i; 
1358:  MOVLB  9
135A:  MOVFF  91A,01
135E:  MOVFF  91B,02
1362:  BRA    1600
....................             } 
....................             else return 0; 
1364:  BRA    136E
1366:  MOVLW  00
1368:  MOVWF  01
136A:  MOVWF  02
136C:  BRA    1600
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
136E:  BRA    15F0
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1370:  MOVLW  04
1372:  SUBWF  x1A,W
1374:  MOVWF  x22
1376:  MOVLW  00
1378:  SUBWFB x1B,W
137A:  MOVWF  x23
137C:  MOVF   x18,W
137E:  ADDWF  x22,W
1380:  MOVWF  FE9
1382:  MOVF   x19,W
1384:  ADDWFC x23,W
1386:  MOVWF  FEA
1388:  MOVFF  FEF,924
138C:  MOVLW  03
138E:  SUBWF  x1A,W
1390:  MOVWF  x25
1392:  MOVLW  00
1394:  SUBWFB x1B,W
1396:  MOVWF  x26
1398:  MOVF   x18,W
139A:  ADDWF  x25,W
139C:  MOVWF  FE9
139E:  MOVF   x19,W
13A0:  ADDWFC x26,W
13A2:  MOVWF  FEA
13A4:  MOVFF  FEF,927
13A8:  MOVLW  02
13AA:  SUBWF  x1A,W
13AC:  MOVWF  x28
13AE:  MOVLW  00
13B0:  SUBWFB x1B,W
13B2:  MOVWF  x29
13B4:  MOVF   x18,W
13B6:  ADDWF  x28,W
13B8:  MOVWF  FE9
13BA:  MOVF   x19,W
13BC:  ADDWFC x29,W
13BE:  MOVWF  FEA
13C0:  MOVFF  FEF,92A
13C4:  MOVLW  01
13C6:  SUBWF  x1A,W
13C8:  MOVWF  x2B
13CA:  MOVLW  00
13CC:  SUBWFB x1B,W
13CE:  MOVWF  x2C
13D0:  MOVF   x18,W
13D2:  ADDWF  x2B,W
13D4:  MOVWF  FE9
13D6:  MOVF   x19,W
13D8:  ADDWFC x2C,W
13DA:  MOVWF  FEA
13DC:  MOVFF  FEF,92D
13E0:  MOVF   x18,W
13E2:  ADDWF  x1A,W
13E4:  MOVWF  FE9
13E6:  MOVF   x19,W
13E8:  ADDWFC x1B,W
13EA:  MOVWF  FEA
13EC:  MOVFF  FEF,92E
13F0:  CLRF   x37
13F2:  CLRF   x38
13F4:  CLRF   x39
13F6:  MOVFF  924,93A
13FA:  MOVFF  927,93B
13FE:  MOVFF  92A,93C
1402:  MOVFF  92D,93D
1406:  MOVFF  92E,93E
140A:  MOVLB  0
140C:  CALL   06AC
1410:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1414:  MOVLW  09
1416:  MOVLB  9
1418:  SUBWF  x1A,W
141A:  MOVWF  x22
141C:  MOVLW  00
141E:  SUBWFB x1B,W
1420:  MOVWF  x23
1422:  MOVF   x18,W
1424:  ADDWF  x22,W
1426:  MOVWF  FE9
1428:  MOVF   x19,W
142A:  ADDWFC x23,W
142C:  MOVWF  FEA
142E:  MOVFF  FEF,924
1432:  MOVLW  08
1434:  SUBWF  x1A,W
1436:  MOVWF  x25
1438:  MOVLW  00
143A:  SUBWFB x1B,W
143C:  MOVWF  x26
143E:  MOVF   x18,W
1440:  ADDWF  x25,W
1442:  MOVWF  FE9
1444:  MOVF   x19,W
1446:  ADDWFC x26,W
1448:  MOVWF  FEA
144A:  MOVFF  FEF,927
144E:  MOVLW  07
1450:  SUBWF  x1A,W
1452:  MOVWF  x28
1454:  MOVLW  00
1456:  SUBWFB x1B,W
1458:  MOVWF  x29
145A:  MOVF   x18,W
145C:  ADDWF  x28,W
145E:  MOVWF  FE9
1460:  MOVF   x19,W
1462:  ADDWFC x29,W
1464:  MOVWF  FEA
1466:  MOVFF  FEF,92A
146A:  MOVLW  06
146C:  SUBWF  x1A,W
146E:  MOVWF  x2B
1470:  MOVLW  00
1472:  SUBWFB x1B,W
1474:  MOVWF  x2C
1476:  MOVF   x18,W
1478:  ADDWF  x2B,W
147A:  MOVWF  FE9
147C:  MOVF   x19,W
147E:  ADDWFC x2C,W
1480:  MOVWF  FEA
1482:  MOVFF  FEF,92D
1486:  MOVLW  05
1488:  SUBWF  x1A,W
148A:  MOVWF  x2E
148C:  MOVLW  00
148E:  SUBWFB x1B,W
1490:  MOVWF  x2F
1492:  MOVF   x18,W
1494:  ADDWF  x2E,W
1496:  MOVWF  FE9
1498:  MOVF   x19,W
149A:  ADDWFC x2F,W
149C:  MOVWF  FEA
149E:  MOVFF  FEF,930
14A2:  CLRF   x37
14A4:  CLRF   x38
14A6:  CLRF   x39
14A8:  MOVFF  924,93A
14AC:  MOVFF  927,93B
14B0:  MOVFF  92A,93C
14B4:  MOVFF  92D,93D
14B8:  MOVFF  930,93E
14BC:  MOVLB  0
14BE:  CALL   06AC
14C2:  MOVFF  01,91F
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
14C6:  MOVLB  9
14C8:  MOVF   x1E,W
14CA:  SUBLW  0B
14CC:  BTFSS  FD8.2
14CE:  BRA    15F0
14D0:  MOVF   x1F,W
14D2:  SUBLW  1F
14D4:  BTFSC  FD8.2
14D6:  BRA    15F0
14D8:  MOVF   x1F,W
14DA:  SUBLW  0F
14DC:  BTFSC  FD8.2
14DE:  BRA    15F0
....................             { 
....................                j=i; 
14E0:  MOVFF  91B,91D
14E4:  MOVFF  91A,91C
....................                CRC=1; 
14E8:  MOVLW  01
14EA:  MOVWF  x21
....................                temp2=temp; 
14EC:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
14F0:  MOVF   x20,W
14F2:  SUBLW  1F
14F4:  BZ    15D0
14F6:  MOVF   x1D,F
14F8:  BNZ   1500
14FA:  MOVF   x1C,W
14FC:  SUBLW  01
14FE:  BC    15D0
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1500:  MOVLW  01
1502:  MOVWF  x22
1504:  MOVFF  91D,924
1508:  MOVFF  91C,923
150C:  MOVFF  919,926
1510:  MOVFF  918,925
1514:  MOVLB  0
1516:  CALL   08C2
151A:  MOVF   01,W
151C:  MOVLB  9
151E:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1520:  MOVLW  04
1522:  SUBWF  x1C,W
1524:  MOVWF  x22
1526:  MOVLW  00
1528:  SUBWFB x1D,W
152A:  MOVWF  x23
152C:  MOVF   x18,W
152E:  ADDWF  x22,W
1530:  MOVWF  FE9
1532:  MOVF   x19,W
1534:  ADDWFC x23,W
1536:  MOVWF  FEA
1538:  MOVFF  FEF,924
153C:  MOVLW  03
153E:  SUBWF  x1C,W
1540:  MOVWF  x25
1542:  MOVLW  00
1544:  SUBWFB x1D,W
1546:  MOVWF  x26
1548:  MOVF   x18,W
154A:  ADDWF  x25,W
154C:  MOVWF  FE9
154E:  MOVF   x19,W
1550:  ADDWFC x26,W
1552:  MOVWF  FEA
1554:  MOVFF  FEF,927
1558:  MOVLW  02
155A:  SUBWF  x1C,W
155C:  MOVWF  x28
155E:  MOVLW  00
1560:  SUBWFB x1D,W
1562:  MOVWF  x29
1564:  MOVF   x18,W
1566:  ADDWF  x28,W
1568:  MOVWF  FE9
156A:  MOVF   x19,W
156C:  ADDWFC x29,W
156E:  MOVWF  FEA
1570:  MOVFF  FEF,92A
1574:  MOVLW  01
1576:  SUBWF  x1C,W
1578:  MOVWF  x2B
157A:  MOVLW  00
157C:  SUBWFB x1D,W
157E:  MOVWF  x2C
1580:  MOVF   x18,W
1582:  ADDWF  x2B,W
1584:  MOVWF  FE9
1586:  MOVF   x19,W
1588:  ADDWFC x2C,W
158A:  MOVWF  FEA
158C:  MOVFF  FEF,92D
1590:  MOVF   x18,W
1592:  ADDWF  x1C,W
1594:  MOVWF  FE9
1596:  MOVF   x19,W
1598:  ADDWFC x1D,W
159A:  MOVWF  FEA
159C:  MOVFF  FEF,92E
15A0:  CLRF   x37
15A2:  CLRF   x38
15A4:  CLRF   x39
15A6:  MOVFF  924,93A
15AA:  MOVFF  927,93B
15AE:  MOVFF  92A,93C
15B2:  MOVFF  92D,93D
15B6:  MOVFF  92E,93E
15BA:  MOVLB  0
15BC:  CALL   06AC
15C0:  MOVFF  01,920
....................                   j=j-5; 
15C4:  MOVLW  05
15C6:  MOVLB  9
15C8:  SUBWF  x1C,F
15CA:  MOVLW  00
15CC:  SUBWFB x1D,F
....................                } 
15CE:  BRA    14F0
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
15D0:  DECFSZ x21,W
15D2:  BRA    15E8
....................                { 
....................                   dir=1; 
15D4:  MOVLW  01
15D6:  MOVLB  6
15D8:  MOVWF  xC8
....................                   return i; 
15DA:  MOVLB  9
15DC:  MOVFF  91A,01
15E0:  MOVFF  91B,02
15E4:  BRA    1600
....................                } 
....................                   else return 0; 
15E6:  BRA    15F0
15E8:  MOVLW  00
15EA:  MOVWF  01
15EC:  MOVWF  02
15EE:  BRA    1600
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
15F0:  MOVF   x1A,W
15F2:  BTFSC  FD8.2
15F4:  DECF   x1B,F
15F6:  DECF   x1A,F
15F8:  BRA    0FF2
....................    return 0; 
15FA:  MOVLW  00
15FC:  MOVWF  01
15FE:  MOVWF  02
.................... } 
1600:  MOVLB  0
1602:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
35B4:  MOVLB  9
35B6:  CLRF   x02
35B8:  MOVLW  01
35BA:  MOVWF  x01
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
35BC:  MOVFF  8F7,915
35C0:  MOVFF  8F9,917
35C4:  MOVFF  8F8,916
35C8:  MOVFF  8FB,919
35CC:  MOVFF  8FA,918
35D0:  MOVLB  0
35D2:  CALL   0A02
35D6:  MOVFF  02,902
35DA:  MOVFF  01,901
....................    if(temp==0) return 0; 
35DE:  MOVLB  9
35E0:  MOVF   x01,F
35E2:  BNZ   35EE
35E4:  MOVF   x02,F
35E6:  BNZ   35EE
35E8:  MOVLW  00
35EA:  MOVWF  01
35EC:  BRA    3A68
....................    j=temp; 
35EE:  MOVFF  902,900
35F2:  MOVFF  901,8FF
....................    if(dir==0) 
35F6:  MOVLB  6
35F8:  MOVF   xC8,F
35FA:  BTFSS  FD8.2
35FC:  BRA    382A
....................    { 
....................       if(track==0) 
35FE:  MOVLB  8
3600:  MOVF   xF7,F
3602:  BTFSS  FD8.2
3604:  BRA    3742
....................       { 
....................             for(i=0;i<79;i++) 
3606:  CLRF   xFE
3608:  MOVF   xFE,W
360A:  SUBLW  4E
360C:  BTFSS  FD8.0
360E:  BRA    3740
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3610:  CLRF   03
3612:  MOVF   xFE,W
3614:  ADDWF  xFC,W
3616:  MOVWF  01
3618:  MOVF   xFD,W
361A:  ADDWFC 03,F
361C:  MOVFF  01,903
3620:  MOVFF  03,904
3624:  MOVLW  05
3626:  MOVLB  8
3628:  ADDWF  xFF,W
362A:  MOVLB  9
362C:  MOVWF  x05
362E:  MOVLW  00
3630:  ADDWFC x00,W
3632:  MOVWF  x06
3634:  MOVLB  8
3636:  MOVF   xFA,W
3638:  MOVLB  9
363A:  ADDWF  x05,W
363C:  MOVWF  FE9
363E:  MOVLB  8
3640:  MOVF   xFB,W
3642:  MOVLB  9
3644:  ADDWFC x06,W
3646:  MOVWF  FEA
3648:  MOVFF  FEF,907
364C:  MOVLW  04
364E:  MOVLB  8
3650:  ADDWF  xFF,W
3652:  MOVLB  9
3654:  MOVWF  x08
3656:  MOVLW  00
3658:  ADDWFC x00,W
365A:  MOVWF  x09
365C:  MOVLB  8
365E:  MOVF   xFA,W
3660:  MOVLB  9
3662:  ADDWF  x08,W
3664:  MOVWF  FE9
3666:  MOVLB  8
3668:  MOVF   xFB,W
366A:  MOVLB  9
366C:  ADDWFC x09,W
366E:  MOVWF  FEA
3670:  MOVFF  FEF,90A
3674:  MOVLW  03
3676:  MOVLB  8
3678:  ADDWF  xFF,W
367A:  MOVLB  9
367C:  MOVWF  x0B
367E:  MOVLW  00
3680:  ADDWFC x00,W
3682:  MOVWF  x0C
3684:  MOVLB  8
3686:  MOVF   xFA,W
3688:  MOVLB  9
368A:  ADDWF  x0B,W
368C:  MOVWF  FE9
368E:  MOVLB  8
3690:  MOVF   xFB,W
3692:  MOVLB  9
3694:  ADDWFC x0C,W
3696:  MOVWF  FEA
3698:  MOVFF  FEF,90D
369C:  MOVLW  02
369E:  MOVLB  8
36A0:  ADDWF  xFF,W
36A2:  MOVLB  9
36A4:  MOVWF  x0E
36A6:  MOVLW  00
36A8:  ADDWFC x00,W
36AA:  MOVWF  x0F
36AC:  MOVLB  8
36AE:  MOVF   xFA,W
36B0:  MOVLB  9
36B2:  ADDWF  x0E,W
36B4:  MOVWF  FE9
36B6:  MOVLB  8
36B8:  MOVF   xFB,W
36BA:  MOVLB  9
36BC:  ADDWFC x0F,W
36BE:  MOVWF  FEA
36C0:  MOVFF  FEF,910
36C4:  MOVLW  01
36C6:  MOVLB  8
36C8:  ADDWF  xFF,W
36CA:  MOVLB  9
36CC:  MOVWF  x11
36CE:  MOVLW  00
36D0:  ADDWFC x00,W
36D2:  MOVWF  x12
36D4:  MOVLB  8
36D6:  MOVF   xFA,W
36D8:  MOVLB  9
36DA:  ADDWF  x11,W
36DC:  MOVWF  FE9
36DE:  MOVLB  8
36E0:  MOVF   xFB,W
36E2:  MOVLB  9
36E4:  ADDWFC x12,W
36E6:  MOVWF  FEA
36E8:  MOVFF  FEF,913
36EC:  MOVLB  8
36EE:  MOVF   xFA,W
36F0:  ADDWF  xFF,W
36F2:  MOVWF  FE9
36F4:  MOVF   xFB,W
36F6:  MOVLB  9
36F8:  ADDWFC x00,W
36FA:  MOVWF  FEA
36FC:  MOVFF  FEF,914
3700:  CLRF   x37
3702:  CLRF   x38
3704:  MOVFF  907,939
3708:  MOVFF  90A,93A
370C:  MOVFF  90D,93B
3710:  MOVFF  910,93C
3714:  MOVFF  913,93D
3718:  MOVFF  914,93E
371C:  MOVLB  0
371E:  CALL   06AC
3722:  MOVFF  904,FEA
3726:  MOVFF  903,FE9
372A:  MOVFF  01,FEF
....................                j=j+7; 
372E:  MOVLW  07
3730:  MOVLB  8
3732:  ADDWF  xFF,F
3734:  MOVLW  00
3736:  MOVLB  9
3738:  ADDWFC x00,F
....................             } 
373A:  MOVLB  8
373C:  INCF   xFE,F
373E:  BRA    3608
....................       } 
....................          else  
3740:  BRA    3826
....................          { 
....................             for(i=0;i<40;i++) 
3742:  CLRF   xFE
3744:  MOVF   xFE,W
3746:  SUBLW  27
3748:  BNC   3826
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
374A:  CLRF   03
374C:  MOVF   xFE,W
374E:  ADDWF  xFC,W
3750:  MOVWF  01
3752:  MOVF   xFD,W
3754:  ADDWFC 03,F
3756:  MOVFF  01,903
375A:  MOVFF  03,904
375E:  MOVLW  03
3760:  MOVLB  8
3762:  ADDWF  xFF,W
3764:  MOVLB  9
3766:  MOVWF  x05
3768:  MOVLW  00
376A:  ADDWFC x00,W
376C:  MOVWF  x06
376E:  MOVLB  8
3770:  MOVF   xFA,W
3772:  MOVLB  9
3774:  ADDWF  x05,W
3776:  MOVWF  FE9
3778:  MOVLB  8
377A:  MOVF   xFB,W
377C:  MOVLB  9
377E:  ADDWFC x06,W
3780:  MOVWF  FEA
3782:  MOVFF  FEF,907
3786:  MOVLW  02
3788:  MOVLB  8
378A:  ADDWF  xFF,W
378C:  MOVLB  9
378E:  MOVWF  x08
3790:  MOVLW  00
3792:  ADDWFC x00,W
3794:  MOVWF  x09
3796:  MOVLB  8
3798:  MOVF   xFA,W
379A:  MOVLB  9
379C:  ADDWF  x08,W
379E:  MOVWF  FE9
37A0:  MOVLB  8
37A2:  MOVF   xFB,W
37A4:  MOVLB  9
37A6:  ADDWFC x09,W
37A8:  MOVWF  FEA
37AA:  MOVFF  FEF,90A
37AE:  MOVLW  01
37B0:  MOVLB  8
37B2:  ADDWF  xFF,W
37B4:  MOVLB  9
37B6:  MOVWF  x0B
37B8:  MOVLW  00
37BA:  ADDWFC x00,W
37BC:  MOVWF  x0C
37BE:  MOVLB  8
37C0:  MOVF   xFA,W
37C2:  MOVLB  9
37C4:  ADDWF  x0B,W
37C6:  MOVWF  FE9
37C8:  MOVLB  8
37CA:  MOVF   xFB,W
37CC:  MOVLB  9
37CE:  ADDWFC x0C,W
37D0:  MOVWF  FEA
37D2:  MOVFF  FEF,90D
37D6:  MOVLB  8
37D8:  MOVF   xFA,W
37DA:  ADDWF  xFF,W
37DC:  MOVWF  FE9
37DE:  MOVF   xFB,W
37E0:  MOVLB  9
37E2:  ADDWFC x00,W
37E4:  MOVWF  FEA
37E6:  MOVFF  FEF,90E
37EA:  CLRF   x37
37EC:  CLRF   x38
37EE:  CLRF   x39
37F0:  CLRF   x3A
37F2:  MOVFF  907,93B
37F6:  MOVFF  90A,93C
37FA:  MOVFF  90D,93D
37FE:  MOVFF  90E,93E
3802:  MOVLB  0
3804:  CALL   06AC
3808:  MOVFF  904,FEA
380C:  MOVFF  903,FE9
3810:  MOVFF  01,FEF
....................                j=j+5; 
3814:  MOVLW  05
3816:  MOVLB  8
3818:  ADDWF  xFF,F
381A:  MOVLW  00
381C:  MOVLB  9
381E:  ADDWFC x00,F
....................             }          
3820:  MOVLB  8
3822:  INCF   xFE,F
3824:  BRA    3744
....................          } 
....................    } 
....................       else  
3826:  BRA    3A52
3828:  MOVLB  6
....................       { 
....................          if(track==0) 
382A:  MOVLB  8
382C:  MOVF   xF7,F
382E:  BTFSS  FD8.2
3830:  BRA    396E
....................          { 
....................             for(i=0;i<79;i++) 
3832:  CLRF   xFE
3834:  MOVF   xFE,W
3836:  SUBLW  4E
3838:  BTFSS  FD8.0
383A:  BRA    396C
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
383C:  CLRF   03
383E:  MOVF   xFE,W
3840:  ADDWF  xFC,W
3842:  MOVWF  01
3844:  MOVF   xFD,W
3846:  ADDWFC 03,F
3848:  MOVFF  01,903
384C:  MOVFF  03,904
3850:  MOVLW  05
3852:  MOVLB  8
3854:  SUBWF  xFF,W
3856:  MOVLB  9
3858:  MOVWF  x05
385A:  MOVLW  00
385C:  SUBWFB x00,W
385E:  MOVWF  x06
3860:  MOVLB  8
3862:  MOVF   xFA,W
3864:  MOVLB  9
3866:  ADDWF  x05,W
3868:  MOVWF  FE9
386A:  MOVLB  8
386C:  MOVF   xFB,W
386E:  MOVLB  9
3870:  ADDWFC x06,W
3872:  MOVWF  FEA
3874:  MOVFF  FEF,907
3878:  MOVLW  04
387A:  MOVLB  8
387C:  SUBWF  xFF,W
387E:  MOVLB  9
3880:  MOVWF  x08
3882:  MOVLW  00
3884:  SUBWFB x00,W
3886:  MOVWF  x09
3888:  MOVLB  8
388A:  MOVF   xFA,W
388C:  MOVLB  9
388E:  ADDWF  x08,W
3890:  MOVWF  FE9
3892:  MOVLB  8
3894:  MOVF   xFB,W
3896:  MOVLB  9
3898:  ADDWFC x09,W
389A:  MOVWF  FEA
389C:  MOVFF  FEF,90A
38A0:  MOVLW  03
38A2:  MOVLB  8
38A4:  SUBWF  xFF,W
38A6:  MOVLB  9
38A8:  MOVWF  x0B
38AA:  MOVLW  00
38AC:  SUBWFB x00,W
38AE:  MOVWF  x0C
38B0:  MOVLB  8
38B2:  MOVF   xFA,W
38B4:  MOVLB  9
38B6:  ADDWF  x0B,W
38B8:  MOVWF  FE9
38BA:  MOVLB  8
38BC:  MOVF   xFB,W
38BE:  MOVLB  9
38C0:  ADDWFC x0C,W
38C2:  MOVWF  FEA
38C4:  MOVFF  FEF,90D
38C8:  MOVLW  02
38CA:  MOVLB  8
38CC:  SUBWF  xFF,W
38CE:  MOVLB  9
38D0:  MOVWF  x0E
38D2:  MOVLW  00
38D4:  SUBWFB x00,W
38D6:  MOVWF  x0F
38D8:  MOVLB  8
38DA:  MOVF   xFA,W
38DC:  MOVLB  9
38DE:  ADDWF  x0E,W
38E0:  MOVWF  FE9
38E2:  MOVLB  8
38E4:  MOVF   xFB,W
38E6:  MOVLB  9
38E8:  ADDWFC x0F,W
38EA:  MOVWF  FEA
38EC:  MOVFF  FEF,910
38F0:  MOVLW  01
38F2:  MOVLB  8
38F4:  SUBWF  xFF,W
38F6:  MOVLB  9
38F8:  MOVWF  x11
38FA:  MOVLW  00
38FC:  SUBWFB x00,W
38FE:  MOVWF  x12
3900:  MOVLB  8
3902:  MOVF   xFA,W
3904:  MOVLB  9
3906:  ADDWF  x11,W
3908:  MOVWF  FE9
390A:  MOVLB  8
390C:  MOVF   xFB,W
390E:  MOVLB  9
3910:  ADDWFC x12,W
3912:  MOVWF  FEA
3914:  MOVFF  FEF,913
3918:  MOVLB  8
391A:  MOVF   xFA,W
391C:  ADDWF  xFF,W
391E:  MOVWF  FE9
3920:  MOVF   xFB,W
3922:  MOVLB  9
3924:  ADDWFC x00,W
3926:  MOVWF  FEA
3928:  MOVFF  FEF,914
392C:  CLRF   x37
392E:  CLRF   x38
3930:  MOVFF  907,939
3934:  MOVFF  90A,93A
3938:  MOVFF  90D,93B
393C:  MOVFF  910,93C
3940:  MOVFF  913,93D
3944:  MOVFF  914,93E
3948:  MOVLB  0
394A:  CALL   06AC
394E:  MOVFF  904,FEA
3952:  MOVFF  903,FE9
3956:  MOVFF  01,FEF
....................                j=j-7; 
395A:  MOVLW  07
395C:  MOVLB  8
395E:  SUBWF  xFF,F
3960:  MOVLW  00
3962:  MOVLB  9
3964:  SUBWFB x00,F
....................             } 
3966:  MOVLB  8
3968:  INCF   xFE,F
396A:  BRA    3834
....................          } 
....................             else 
396C:  BRA    3A52
....................             { 
....................                for(i=0;i<40;i++) 
396E:  CLRF   xFE
3970:  MOVF   xFE,W
3972:  SUBLW  27
3974:  BNC   3A52
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3976:  CLRF   03
3978:  MOVF   xFE,W
397A:  ADDWF  xFC,W
397C:  MOVWF  01
397E:  MOVF   xFD,W
3980:  ADDWFC 03,F
3982:  MOVFF  01,903
3986:  MOVFF  03,904
398A:  MOVLW  03
398C:  MOVLB  8
398E:  SUBWF  xFF,W
3990:  MOVLB  9
3992:  MOVWF  x05
3994:  MOVLW  00
3996:  SUBWFB x00,W
3998:  MOVWF  x06
399A:  MOVLB  8
399C:  MOVF   xFA,W
399E:  MOVLB  9
39A0:  ADDWF  x05,W
39A2:  MOVWF  FE9
39A4:  MOVLB  8
39A6:  MOVF   xFB,W
39A8:  MOVLB  9
39AA:  ADDWFC x06,W
39AC:  MOVWF  FEA
39AE:  MOVFF  FEF,907
39B2:  MOVLW  02
39B4:  MOVLB  8
39B6:  SUBWF  xFF,W
39B8:  MOVLB  9
39BA:  MOVWF  x08
39BC:  MOVLW  00
39BE:  SUBWFB x00,W
39C0:  MOVWF  x09
39C2:  MOVLB  8
39C4:  MOVF   xFA,W
39C6:  MOVLB  9
39C8:  ADDWF  x08,W
39CA:  MOVWF  FE9
39CC:  MOVLB  8
39CE:  MOVF   xFB,W
39D0:  MOVLB  9
39D2:  ADDWFC x09,W
39D4:  MOVWF  FEA
39D6:  MOVFF  FEF,90A
39DA:  MOVLW  01
39DC:  MOVLB  8
39DE:  SUBWF  xFF,W
39E0:  MOVLB  9
39E2:  MOVWF  x0B
39E4:  MOVLW  00
39E6:  SUBWFB x00,W
39E8:  MOVWF  x0C
39EA:  MOVLB  8
39EC:  MOVF   xFA,W
39EE:  MOVLB  9
39F0:  ADDWF  x0B,W
39F2:  MOVWF  FE9
39F4:  MOVLB  8
39F6:  MOVF   xFB,W
39F8:  MOVLB  9
39FA:  ADDWFC x0C,W
39FC:  MOVWF  FEA
39FE:  MOVFF  FEF,90D
3A02:  MOVLB  8
3A04:  MOVF   xFA,W
3A06:  ADDWF  xFF,W
3A08:  MOVWF  FE9
3A0A:  MOVF   xFB,W
3A0C:  MOVLB  9
3A0E:  ADDWFC x00,W
3A10:  MOVWF  FEA
3A12:  MOVFF  FEF,90E
3A16:  CLRF   x37
3A18:  CLRF   x38
3A1A:  CLRF   x39
3A1C:  CLRF   x3A
3A1E:  MOVFF  907,93B
3A22:  MOVFF  90A,93C
3A26:  MOVFF  90D,93D
3A2A:  MOVFF  90E,93E
3A2E:  MOVLB  0
3A30:  CALL   06AC
3A34:  MOVFF  904,FEA
3A38:  MOVFF  903,FE9
3A3C:  MOVFF  01,FEF
....................                   j=j-5; 
3A40:  MOVLW  05
3A42:  MOVLB  8
3A44:  SUBWF  xFF,F
3A46:  MOVLW  00
3A48:  MOVLB  9
3A4A:  SUBWFB x00,F
....................                }             
3A4C:  MOVLB  8
3A4E:  INCF   xFE,F
3A50:  BRA    3970
....................             } 
....................       } 
....................       memset(datin,0,sizeof(datin)); 
3A52:  MOVFF  8FB,FEA
3A56:  MOVFF  8FA,FE9
3A5A:  CLRF   00
3A5C:  CLRF   02
3A5E:  MOVLW  02
3A60:  MOVWF  01
3A62:  MOVLB  0
3A64:  RCALL  359A
3A66:  MOVLB  9
.................... } 
3A68:  MOVLB  0
3A6A:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1836:  MOVLW  8E
1838:  MOVWF  FF6
183A:  MOVLW  05
183C:  MOVWF  FF7
183E:  RCALL  172E
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1840:  MOVLB  8
1842:  CLRF   x57
1844:  CLRF   x56
1846:  MOVF   x57,W
1848:  SUBLW  03
184A:  BNC   187A
184C:  BNZ   1854
184E:  MOVF   x56,W
1850:  SUBLW  51
1852:  BNC   187A
1854:  MOVLW  46
1856:  ADDWF  x56,W
1858:  MOVWF  FE9
185A:  MOVLW  02
185C:  ADDWFC x57,W
185E:  MOVWF  FEA
1860:  MOVFF  FEF,858
1864:  MOVFF  858,859
1868:  MOVLW  18
186A:  MOVWF  x5A
186C:  MOVLB  0
186E:  RCALL  177A
1870:  MOVLB  8
1872:  INCF   x56,F
1874:  BTFSC  FD8.2
1876:  INCF   x57,F
1878:  BRA    1846
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
187A:  MOVLW  A4
187C:  MOVWF  FF6
187E:  MOVLW  05
1880:  MOVWF  FF7
1882:  MOVLB  0
1884:  RCALL  172E
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1886:  MOVLB  8
1888:  CLRF   x57
188A:  CLRF   x56
188C:  MOVF   x57,W
188E:  SUBLW  01
1890:  BNC   18C0
1892:  BNZ   189A
1894:  MOVF   x56,W
1896:  SUBLW  2B
1898:  BNC   18C0
189A:  MOVLW  98
189C:  ADDWF  x56,W
189E:  MOVWF  FE9
18A0:  MOVLW  05
18A2:  ADDWFC x57,W
18A4:  MOVWF  FEA
18A6:  MOVFF  FEF,858
18AA:  MOVFF  858,859
18AE:  MOVLW  18
18B0:  MOVWF  x5A
18B2:  MOVLB  0
18B4:  RCALL  177A
18B6:  MOVLB  8
18B8:  INCF   x56,F
18BA:  BTFSC  FD8.2
18BC:  INCF   x57,F
18BE:  BRA    188C
.................... } 
18C0:  MOVLB  0
18C2:  GOTO   1B50 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3C02:  MOVLW  01
3C04:  MOVLB  6
3C06:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3C08:  MOVLB  0
3C0A:  RCALL  351C
3C0C:  MOVFF  02,854
3C10:  MOVFF  01,853
3C14:  MOVFF  02,856
3C18:  MOVFF  01,855
3C1C:  MOVLB  8
3C1E:  CLRF   x58
3C20:  MOVLW  7C
3C22:  MOVWF  x57
3C24:  MOVLB  0
3C26:  RCALL  3578
3C28:  MOVFF  01,853
3C2C:  MOVLW  96
3C2E:  MOVLB  8
3C30:  ADDWF  01,W
3C32:  MOVWF  01
3C34:  MOVLW  00
3C36:  ADDWFC 02,W
3C38:  MOVFF  01,20
3C3C:  MOVWF  21
3C3E:  CLRF   22
3C40:  CLRF   23
....................    if(datinbuf==0)  
3C42:  MOVLB  6
3C44:  MOVF   xD5,F
3C46:  BNZ   3C6A
....................    { 
....................       countbit_T1=0; 
3C48:  CLRF   xCA
3C4A:  CLRF   xC9
....................       countbit_T2=0; 
3C4C:  CLRF   xCC
3C4E:  CLRF   xCB
....................       bug_countbit_T1=0; 
3C50:  CLRF   xCE
3C52:  CLRF   xCD
....................       bug_countbit_T2=0; 
3C54:  CLRF   xD0
3C56:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3C58:  MOVF   xD9,F
3C5A:  BNZ   3C66
3C5C:  MOVLB  1
3C5E:  SETF   x00
3C60:  MOVLB  0
3C62:  SETF   xFF
3C64:  MOVLB  6
....................       saving_flag=0; 
3C66:  CLRF   xD8
....................       return; 
3C68:  BRA    3FFE
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3C6A:  MOVLW  BA
3C6C:  MOVWF  FF6
3C6E:  MOVLW  05
3C70:  MOVWF  FF7
3C72:  MOVLB  0
3C74:  CALL   172E
....................    //key_count=0; 
....................    enable_getpin=1; 
3C78:  MOVLW  01
3C7A:  MOVLB  1
3C7C:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3C7E:  MOVFF  6CA,852
3C82:  MOVFF  6C9,851
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3C86:  MOVLB  8
3C88:  CLRF   xF7
3C8A:  MOVFF  852,8F9
3C8E:  MOVFF  851,8F8
3C92:  MOVLW  02
3C94:  MOVWF  xFB
3C96:  MOVLW  46
3C98:  MOVWF  xFA
3C9A:  MOVLW  01
3C9C:  MOVWF  xFD
3C9E:  MOVLW  CF
3CA0:  MOVWF  xFC
3CA2:  MOVLB  0
3CA4:  RCALL  35B4
....................    countbit_T1=0; 
3CA6:  MOVLB  6
3CA8:  CLRF   xCA
3CAA:  CLRF   xC9
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3CAC:  MOVFF  6CC,852
3CB0:  MOVFF  6CB,851
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3CB4:  MOVLW  01
3CB6:  MOVLB  8
3CB8:  MOVWF  xF7
3CBA:  MOVFF  852,8F9
3CBE:  MOVFF  851,8F8
3CC2:  MOVLW  05
3CC4:  MOVWF  xFB
3CC6:  MOVLW  98
3CC8:  MOVWF  xFA
3CCA:  MOVLW  02
3CCC:  MOVWF  xFD
3CCE:  MOVLW  1E
3CD0:  MOVWF  xFC
3CD2:  MOVLB  0
3CD4:  RCALL  35B4
....................    countbit_T2=0; 
3CD6:  MOVLB  6
3CD8:  CLRF   xCC
3CDA:  CLRF   xCB
....................    saving_flag=0; 
3CDC:  CLRF   xD8
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3CDE:  MOVLW  20
3CE0:  MOVLB  1
3CE2:  ADDWF  xCF,W
3CE4:  MOVLB  8
3CE6:  MOVWF  x50
....................    if((ptr_card<EEPROM_SIZE_stofkey)&&(temp=='%')) 
3CE8:  MOVF   23,F
3CEA:  BTFSS  FD8.2
3CEC:  BRA    3FFC
3CEE:  MOVF   22,W
3CF0:  SUBLW  01
3CF2:  BTFSS  FD8.0
3CF4:  BRA    3FFC
3CF6:  BNZ   3D0A
3CF8:  MOVF   21,W
3CFA:  SUBLW  C3
3CFC:  BTFSS  FD8.0
3CFE:  BRA    3FFC
3D00:  BNZ   3D0A
3D02:  MOVF   20,W
3D04:  SUBLW  0D
3D06:  BTFSS  FD8.0
3D08:  BRA    3FFC
3D0A:  MOVF   x50,W
3D0C:  SUBLW  25
3D0E:  BTFSS  FD8.2
3D10:  BRA    3FFC
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3D12:  MOVFF  23,03
3D16:  MOVFF  22,02
3D1A:  MOVFF  21,01
3D1E:  MOVFF  20,00
3D22:  MOVLW  01
3D24:  ADDWF  20,F
3D26:  BTFSC  FD8.0
3D28:  INCF   21,F
3D2A:  BTFSC  FD8.2
3D2C:  INCF   22,F
3D2E:  BTFSC  FD8.2
3D30:  INCF   23,F
3D32:  MOVFF  01,854
3D36:  MOVFF  00,853
3D3A:  MOVLB  9
3D3C:  CLRF   x16
3D3E:  CLRF   x15
3D40:  MOVFF  01,914
3D44:  MOVFF  00,913
3D48:  MOVFF  1CB,917
3D4C:  MOVLB  0
3D4E:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3D50:  MOVFF  23,03
3D54:  MOVFF  22,02
3D58:  MOVFF  21,01
3D5C:  MOVFF  20,00
3D60:  MOVLW  01
3D62:  ADDWF  20,F
3D64:  BTFSC  FD8.0
3D66:  INCF   21,F
3D68:  BTFSC  FD8.2
3D6A:  INCF   22,F
3D6C:  BTFSC  FD8.2
3D6E:  INCF   23,F
3D70:  MOVFF  01,854
3D74:  MOVFF  00,853
3D78:  MOVLB  9
3D7A:  CLRF   x16
3D7C:  CLRF   x15
3D7E:  MOVFF  01,914
3D82:  MOVFF  00,913
3D86:  MOVFF  1CA,917
3D8A:  MOVLB  0
3D8C:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,h); 
3D8E:  MOVFF  23,03
3D92:  MOVFF  22,02
3D96:  MOVFF  21,01
3D9A:  MOVFF  20,00
3D9E:  MOVLW  01
3DA0:  ADDWF  20,F
3DA2:  BTFSC  FD8.0
3DA4:  INCF   21,F
3DA6:  BTFSC  FD8.2
3DA8:  INCF   22,F
3DAA:  BTFSC  FD8.2
3DAC:  INCF   23,F
3DAE:  MOVFF  01,854
3DB2:  MOVFF  00,853
3DB6:  MOVLB  9
3DB8:  CLRF   x16
3DBA:  CLRF   x15
3DBC:  MOVFF  01,914
3DC0:  MOVFF  00,913
3DC4:  MOVFF  1CC,917
3DC8:  MOVLB  0
3DCA:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,min); 
3DCC:  MOVFF  23,03
3DD0:  MOVFF  22,02
3DD4:  MOVFF  21,01
3DD8:  MOVFF  20,00
3DDC:  MOVLW  01
3DDE:  ADDWF  20,F
3DE0:  BTFSC  FD8.0
3DE2:  INCF   21,F
3DE4:  BTFSC  FD8.2
3DE6:  INCF   22,F
3DE8:  BTFSC  FD8.2
3DEA:  INCF   23,F
3DEC:  MOVFF  01,854
3DF0:  MOVFF  00,853
3DF4:  MOVLB  9
3DF6:  CLRF   x16
3DF8:  CLRF   x15
3DFA:  MOVFF  01,914
3DFE:  MOVFF  00,913
3E02:  MOVFF  1CD,917
3E06:  MOVLB  0
3E08:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3E0A:  MOVFF  23,03
3E0E:  MOVFF  22,02
3E12:  MOVFF  21,01
3E16:  MOVFF  20,00
3E1A:  MOVLW  01
3E1C:  ADDWF  20,F
3E1E:  BTFSC  FD8.0
3E20:  INCF   21,F
3E22:  BTFSC  FD8.2
3E24:  INCF   22,F
3E26:  BTFSC  FD8.2
3E28:  INCF   23,F
3E2A:  MOVFF  01,854
3E2E:  MOVFF  00,853
3E32:  MOVLB  9
3E34:  CLRF   x16
3E36:  CLRF   x15
3E38:  MOVFF  01,914
3E3C:  MOVFF  00,913
3E40:  MOVFF  1CE,917
3E44:  MOVLB  0
3E46:  RCALL  3A6C
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3E48:  MOVLB  6
3E4A:  CLRF   xD4
3E4C:  CLRF   xD3
3E4E:  MOVF   xD4,F
3E50:  BNZ   3EB4
3E52:  MOVF   xD3,W
3E54:  SUBLW  4E
3E56:  BNC   3EB4
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3E58:  MOVFF  23,03
3E5C:  MOVFF  22,02
3E60:  MOVFF  21,01
3E64:  MOVFF  20,00
3E68:  MOVLW  01
3E6A:  ADDWF  20,F
3E6C:  BTFSC  FD8.0
3E6E:  INCF   21,F
3E70:  BTFSC  FD8.2
3E72:  INCF   22,F
3E74:  BTFSC  FD8.2
3E76:  INCF   23,F
3E78:  MOVFF  01,854
3E7C:  MOVFF  00,853
3E80:  MOVLW  CF
3E82:  ADDWF  xD3,W
3E84:  MOVWF  FE9
3E86:  MOVLW  01
3E88:  ADDWFC xD4,W
3E8A:  MOVWF  FEA
3E8C:  MOVF   FEF,W
3E8E:  ANDLW  3F
3E90:  ADDLW  20
3E92:  MOVLB  8
3E94:  MOVWF  x55
3E96:  MOVLB  9
3E98:  CLRF   x16
3E9A:  CLRF   x15
3E9C:  MOVFF  01,914
3EA0:  MOVFF  00,913
3EA4:  MOVWF  x17
3EA6:  MOVLB  0
3EA8:  RCALL  3A6C
....................              
....................          } 
3EAA:  MOVLB  6
3EAC:  INCF   xD3,F
3EAE:  BTFSC  FD8.2
3EB0:  INCF   xD4,F
3EB2:  BRA    3E4E
....................          memset(Track1,0,sizeof(Track1)); 
3EB4:  MOVLW  01
3EB6:  MOVWF  FEA
3EB8:  MOVLW  CF
3EBA:  MOVWF  FE9
3EBC:  CLRF   00
3EBE:  CLRF   02
3EC0:  MOVLW  4F
3EC2:  MOVWF  01
3EC4:  MOVLB  0
3EC6:  CALL   359A
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3ECA:  MOVLB  6
3ECC:  CLRF   xD4
3ECE:  CLRF   xD3
3ED0:  MOVF   xD4,F
3ED2:  BNZ   3F36
3ED4:  MOVF   xD3,W
3ED6:  SUBLW  27
3ED8:  BNC   3F36
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3EDA:  MOVFF  23,03
3EDE:  MOVFF  22,02
3EE2:  MOVFF  21,01
3EE6:  MOVFF  20,00
3EEA:  MOVLW  01
3EEC:  ADDWF  20,F
3EEE:  BTFSC  FD8.0
3EF0:  INCF   21,F
3EF2:  BTFSC  FD8.2
3EF4:  INCF   22,F
3EF6:  BTFSC  FD8.2
3EF8:  INCF   23,F
3EFA:  MOVFF  01,854
3EFE:  MOVFF  00,853
3F02:  MOVLW  1E
3F04:  ADDWF  xD3,W
3F06:  MOVWF  FE9
3F08:  MOVLW  02
3F0A:  ADDWFC xD4,W
3F0C:  MOVWF  FEA
3F0E:  MOVF   FEF,W
3F10:  ANDLW  0F
3F12:  ADDLW  30
3F14:  MOVLB  8
3F16:  MOVWF  x55
3F18:  MOVLB  9
3F1A:  CLRF   x16
3F1C:  CLRF   x15
3F1E:  MOVFF  01,914
3F22:  MOVFF  00,913
3F26:  MOVWF  x17
3F28:  MOVLB  0
3F2A:  RCALL  3A6C
....................          }  
3F2C:  MOVLB  6
3F2E:  INCF   xD3,F
3F30:  BTFSC  FD8.2
3F32:  INCF   xD4,F
3F34:  BRA    3ED0
....................          memset(Track2,0,sizeof(Track2)); 
3F36:  MOVLW  02
3F38:  MOVWF  FEA
3F3A:  MOVLW  1E
3F3C:  MOVWF  FE9
3F3E:  CLRF   00
3F40:  CLRF   02
3F42:  MOVLW  28
3F44:  MOVWF  01
3F46:  MOVLB  0
3F48:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
3F4C:  MOVLW  0D
3F4E:  MOVLB  9
3F50:  MOVWF  x0C
3F52:  MOVLB  0
3F54:  CALL   1604
3F58:  MOVLW  0A
3F5A:  MOVLB  9
3F5C:  MOVWF  x0C
3F5E:  MOVLB  0
3F60:  CALL   1604
....................         fprintf(COM2,"Done"); 
3F64:  MOVLW  D0
3F66:  MOVWF  FF6
3F68:  MOVLW  05
3F6A:  MOVWF  FF7
3F6C:  CALL   172E
....................              
....................         fprintf(COM2,"\r\n"); 
3F70:  MOVLW  0D
3F72:  MOVLB  9
3F74:  MOVWF  x0C
3F76:  MOVLB  0
3F78:  CALL   1604
3F7C:  MOVLW  0A
3F7E:  MOVLB  9
3F80:  MOVWF  x0C
3F82:  MOVLB  0
3F84:  CALL   1604
....................         fprintf(COM2,"Waiting for PIN number"); 
3F88:  MOVLW  D6
3F8A:  MOVWF  FF6
3F8C:  MOVLW  05
3F8E:  MOVWF  FF7
3F90:  CALL   172E
....................         memset(key_data,0,sizeof(key_data));  
3F94:  MOVLW  01
3F96:  MOVWF  FEA
3F98:  MOVLW  4A
3F9A:  MOVWF  FE9
3F9C:  CLRF   00
3F9E:  CLRF   02
3FA0:  MOVLW  10
3FA2:  MOVWF  01
3FA4:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
3FA8:  MOVLW  0D
3FAA:  MOVLB  9
3FAC:  MOVWF  x0C
3FAE:  MOVLB  0
3FB0:  CALL   1604
3FB4:  MOVLW  0A
3FB6:  MOVLB  9
3FB8:  MOVWF  x0C
3FBA:  MOVLB  0
3FBC:  CALL   1604
....................         charac_timeout=0; 
3FC0:  MOVLB  1
3FC2:  CLRF   x00
3FC4:  MOVLB  0
3FC6:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3FC8:  MOVFF  23,8FA
3FCC:  MOVFF  22,8F9
3FD0:  MOVFF  21,8F8
3FD4:  MOVFF  20,8F7
3FD8:  MOVLW  19
3FDA:  MOVLB  8
3FDC:  MOVWF  xFB
3FDE:  MOVLB  0
3FE0:  RCALL  3B6A
....................       datinbuf=0; 
3FE2:  MOVLB  6
3FE4:  CLRF   xD5
....................       saving_flag=0; 
3FE6:  CLRF   xD8
....................       data_avai=1; 
3FE8:  MOVLW  01
3FEA:  MOVWF  xD9
....................       enable_getpin=1; 
3FEC:  MOVLB  1
3FEE:  MOVWF  x45
....................       charac_timeout=0; 
3FF0:  CLRF   x00
3FF2:  MOVLB  0
3FF4:  CLRF   xFF
....................       key_count_ms=0; 
3FF6:  MOVLB  1
3FF8:  CLRF   x47
3FFA:  MOVLB  8
3FFC:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3FFE:  MOVLB  0
4000:  GOTO   5A8E (RETURN)
.................... //========================= 
.................... void saving_card_encrypt() 
.................... { 
*
4FD0:  MOVLB  8
4FD2:  CLRF   x54
....................    int8 temp,i,j,u; 
....................    int8 countbyte=0; 
....................    int16 tempcount; 
....................    int8 carddata[numdataofonecard]; 
....................    int8 encryptblock[16]; 
....................    int8 tempkey[16]; 
....................    saving_flag=1; 
4FD4:  MOVLW  01
4FD6:  MOVLB  6
4FD8:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdataofonecard)+ptr_start); 
4FDA:  MOVLB  0
4FDC:  CALL   351C
4FE0:  MOVFF  02,8F8
4FE4:  MOVFF  01,8F7
4FE8:  MOVLB  8
4FEA:  RLCF   xF7,F
4FEC:  RLCF   xF8,F
4FEE:  RLCF   xF7,F
4FF0:  RLCF   xF8,F
4FF2:  RLCF   xF7,F
4FF4:  RLCF   xF8,F
4FF6:  RLCF   xF7,F
4FF8:  RLCF   xF8,F
4FFA:  RLCF   xF7,F
4FFC:  RLCF   xF8,F
4FFE:  RLCF   xF7,F
5000:  RLCF   xF8,F
5002:  RLCF   xF7,F
5004:  RLCF   xF8,F
5006:  MOVLW  80
5008:  ANDWF  xF7,F
500A:  MOVLW  96
500C:  ADDWF  xF7,W
500E:  MOVWF  01
5010:  MOVLW  00
5012:  ADDWFC xF8,W
5014:  MOVFF  01,20
5018:  MOVWF  21
501A:  CLRF   22
501C:  CLRF   23
....................    if(datinbuf==0)  
501E:  MOVLB  6
5020:  MOVF   xD5,F
5022:  BNZ   5046
....................    { 
....................       countbit_T1=0; 
5024:  CLRF   xCA
5026:  CLRF   xC9
....................       countbit_T2=0; 
5028:  CLRF   xCC
502A:  CLRF   xCB
....................       bug_countbit_T1=0; 
502C:  CLRF   xCE
502E:  CLRF   xCD
....................       bug_countbit_T2=0; 
5030:  CLRF   xD0
5032:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
5034:  MOVF   xD9,F
5036:  BNZ   5042
5038:  MOVLB  1
503A:  SETF   x00
503C:  MOVLB  0
503E:  SETF   xFF
5040:  MOVLB  6
....................       saving_flag=0; 
5042:  CLRF   xD8
....................       return; 
5044:  BRA    549C
....................    }//*/ 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
5046:  MOVLW  EE
5048:  MOVWF  FF6
504A:  MOVLW  05
504C:  MOVWF  FF7
504E:  MOVLB  0
5050:  CALL   172E
....................    //key_count=0; 
....................    enable_getpin=1; 
5054:  MOVLW  01
5056:  MOVLB  1
5058:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
505A:  MOVFF  6CA,856
505E:  MOVFF  6C9,855
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
5062:  MOVLB  8
5064:  CLRF   xF7
5066:  MOVFF  856,8F9
506A:  MOVFF  855,8F8
506E:  MOVLW  02
5070:  MOVWF  xFB
5072:  MOVLW  46
5074:  MOVWF  xFA
5076:  MOVLW  01
5078:  MOVWF  xFD
507A:  MOVLW  CF
507C:  MOVWF  xFC
507E:  MOVLB  0
5080:  CALL   35B4
....................    countbit_T1=0; 
5084:  MOVLB  6
5086:  CLRF   xCA
5088:  CLRF   xC9
....................    tempcount=countbit_T2;    
508A:  MOVFF  6CC,856
508E:  MOVFF  6CB,855
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
5092:  MOVLW  01
5094:  MOVLB  8
5096:  MOVWF  xF7
5098:  MOVFF  856,8F9
509C:  MOVFF  855,8F8
50A0:  MOVLW  05
50A2:  MOVWF  xFB
50A4:  MOVLW  98
50A6:  MOVWF  xFA
50A8:  MOVLW  02
50AA:  MOVWF  xFD
50AC:  MOVLW  1E
50AE:  MOVWF  xFC
50B0:  MOVLB  0
50B2:  CALL   35B4
....................    countbit_T2=0; 
50B6:  MOVLB  6
50B8:  CLRF   xCC
50BA:  CLRF   xCB
....................    saving_flag=0; 
50BC:  CLRF   xD8
....................    temp=Track1[0]+0x20; 
50BE:  MOVLW  20
50C0:  MOVLB  1
50C2:  ADDWF  xCF,W
50C4:  MOVLB  8
50C6:  MOVWF  x50
....................    if((ptr_card<EEPROM_SIZE_stofkey)) 
50C8:  MOVF   23,F
50CA:  BTFSS  FD8.2
50CC:  BRA    549A
50CE:  MOVF   22,W
50D0:  SUBLW  01
50D2:  BTFSS  FD8.0
50D4:  BRA    549A
50D6:  BNZ   50EA
50D8:  MOVF   21,W
50DA:  SUBLW  C3
50DC:  BTFSS  FD8.0
50DE:  BRA    549A
50E0:  BNZ   50EA
50E2:  MOVF   20,W
50E4:  SUBLW  0D
50E6:  BTFSS  FD8.0
50E8:  BRA    549A
....................    { 
....................          countbyte = 0; 
50EA:  CLRF   x54
....................          carddata[countbyte++]=date;    
50EC:  MOVF   x54,W
50EE:  INCF   x54,F
50F0:  CLRF   03
50F2:  ADDLW  57
50F4:  MOVWF  FE9
50F6:  MOVLW  08
50F8:  ADDWFC 03,W
50FA:  MOVWF  FEA
50FC:  MOVFF  1CB,FEF
....................          carddata[countbyte++]=mon;    
5100:  MOVF   x54,W
5102:  INCF   x54,F
5104:  CLRF   03
5106:  ADDLW  57
5108:  MOVWF  FE9
510A:  MOVLW  08
510C:  ADDWFC 03,W
510E:  MOVWF  FEA
5110:  MOVFF  1CA,FEF
....................          carddata[countbyte++]=h;    
5114:  MOVF   x54,W
5116:  INCF   x54,F
5118:  CLRF   03
511A:  ADDLW  57
511C:  MOVWF  FE9
511E:  MOVLW  08
5120:  ADDWFC 03,W
5122:  MOVWF  FEA
5124:  MOVFF  1CC,FEF
....................          carddata[countbyte++]=min;    
5128:  MOVF   x54,W
512A:  INCF   x54,F
512C:  CLRF   03
512E:  ADDLW  57
5130:  MOVWF  FE9
5132:  MOVLW  08
5134:  ADDWFC 03,W
5136:  MOVWF  FEA
5138:  MOVFF  1CD,FEF
....................          carddata[countbyte++]=sec; 
513C:  MOVF   x54,W
513E:  INCF   x54,F
5140:  CLRF   03
5142:  ADDLW  57
5144:  MOVWF  FE9
5146:  MOVLW  08
5148:  ADDWFC 03,W
514A:  MOVWF  FEA
514C:  MOVFF  1CE,FEF
....................          carddata[countbyte++]=0xff;             
5150:  MOVF   x54,W
5152:  INCF   x54,F
5154:  CLRF   03
5156:  ADDLW  57
5158:  MOVWF  FE9
515A:  MOVLW  08
515C:  ADDWFC 03,W
515E:  MOVWF  FEA
5160:  SETF   FEF
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
5162:  MOVLB  6
5164:  CLRF   xD4
5166:  CLRF   xD3
5168:  MOVF   xD4,F
516A:  BNZ   51AC
516C:  MOVF   xD3,W
516E:  SUBLW  4E
5170:  BNC   51AC
....................          { 
....................             carddata[countbyte++] = (INT8)((Track1[countbit]&0b00111111)+0x20);       
5172:  MOVLB  8
5174:  MOVF   x54,W
5176:  INCF   x54,F
5178:  CLRF   03
517A:  ADDLW  57
517C:  MOVWF  01
517E:  MOVLW  08
5180:  ADDWFC 03,F
5182:  MOVLW  CF
5184:  MOVLB  6
5186:  ADDWF  xD3,W
5188:  MOVWF  FE9
518A:  MOVLW  01
518C:  ADDWFC xD4,W
518E:  MOVWF  FEA
5190:  MOVF   FEF,W
5192:  ANDLW  3F
5194:  ADDLW  20
5196:  MOVLB  8
5198:  MOVFF  03,FEA
519C:  MOVFF  01,FE9
51A0:  MOVWF  FEF
....................          } 
51A2:  MOVLB  6
51A4:  INCF   xD3,F
51A6:  BTFSC  FD8.2
51A8:  INCF   xD4,F
51AA:  BRA    5168
....................          memset(Track1,0,sizeof(Track1)); 
51AC:  MOVLW  01
51AE:  MOVWF  FEA
51B0:  MOVLW  CF
51B2:  MOVWF  FE9
51B4:  CLRF   00
51B6:  CLRF   02
51B8:  MOVLW  4F
51BA:  MOVWF  01
51BC:  MOVLB  0
51BE:  CALL   359A
....................          carddata[countbyte++]=0xfe; 
51C2:  MOVLB  8
51C4:  MOVF   x54,W
51C6:  INCF   x54,F
51C8:  CLRF   03
51CA:  ADDLW  57
51CC:  MOVWF  FE9
51CE:  MOVLW  08
51D0:  ADDWFC 03,W
51D2:  MOVWF  FEA
51D4:  MOVLW  FE
51D6:  MOVWF  FEF
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
51D8:  MOVLB  6
51DA:  CLRF   xD4
51DC:  CLRF   xD3
51DE:  MOVF   xD4,F
51E0:  BNZ   5222
51E2:  MOVF   xD3,W
51E4:  SUBLW  27
51E6:  BNC   5222
....................          { 
....................             carddata[countbyte++] = (INT8)((Track2[countbit]&0b00001111)+0x30);            
51E8:  MOVLB  8
51EA:  MOVF   x54,W
51EC:  INCF   x54,F
51EE:  CLRF   03
51F0:  ADDLW  57
51F2:  MOVWF  01
51F4:  MOVLW  08
51F6:  ADDWFC 03,F
51F8:  MOVLW  1E
51FA:  MOVLB  6
51FC:  ADDWF  xD3,W
51FE:  MOVWF  FE9
5200:  MOVLW  02
5202:  ADDWFC xD4,W
5204:  MOVWF  FEA
5206:  MOVF   FEF,W
5208:  ANDLW  0F
520A:  ADDLW  30
520C:  MOVLB  8
520E:  MOVFF  03,FEA
5212:  MOVFF  01,FE9
5216:  MOVWF  FEF
....................          }  
5218:  MOVLB  6
521A:  INCF   xD3,F
521C:  BTFSC  FD8.2
521E:  INCF   xD4,F
5220:  BRA    51DE
....................          for(i=countbyte;i<numdataofonecard;i++) 
5222:  MOVFF  854,851
5226:  MOVLB  8
5228:  MOVF   x51,W
522A:  SUBLW  7F
522C:  BNC   5242
....................          { 
....................              carddata[i] = 0; 
522E:  CLRF   03
5230:  MOVF   x51,W
5232:  ADDLW  57
5234:  MOVWF  FE9
5236:  MOVLW  08
5238:  ADDWFC 03,W
523A:  MOVWF  FEA
523C:  CLRF   FEF
....................          } 
523E:  INCF   x51,F
5240:  BRA    5228
....................          carddata[numdataofonecard-1]=0xfc; 
5242:  MOVLW  FC
5244:  MOVWF  xD6
....................          for(i=0;i<8;i++) 
5246:  CLRF   x51
5248:  MOVF   x51,W
524A:  SUBLW  07
524C:  BNC   5302
....................          { 
....................              for(j=0;j<16;j++) 
524E:  CLRF   x52
5250:  MOVF   x52,W
5252:  SUBLW  0F
5254:  BNC   528E
....................              { 
....................                 encryptblock[j] = carddata[i*16+j]; 
5256:  CLRF   03
5258:  MOVF   x52,W
525A:  ADDLW  D7
525C:  MOVWF  01
525E:  MOVLW  08
5260:  ADDWFC 03,F
5262:  MOVFF  03,8F8
5266:  MOVF   x51,W
5268:  MULLW  10
526A:  MOVF   FF3,W
526C:  ADDWF  x52,W
526E:  CLRF   03
5270:  ADDLW  57
5272:  MOVWF  FE9
5274:  MOVLW  08
5276:  ADDWFC 03,W
5278:  MOVWF  FEA
527A:  MOVFF  FEF,8F9
527E:  MOVFF  8F8,FEA
5282:  MOVFF  01,FE9
5286:  MOVFF  8F9,FEF
....................              } 
528A:  INCF   x52,F
528C:  BRA    5250
....................              EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
528E:  MOVLB  9
5290:  CLRF   x07
5292:  CLRF   x06
5294:  CLRF   x05
5296:  MOVLW  3F
5298:  MOVWF  x04
529A:  CLRF   x0B
529C:  CLRF   x0A
529E:  CLRF   x09
52A0:  MOVLW  20
52A2:  MOVWF  x08
52A4:  MOVLW  01
52A6:  MOVWF  x0D
52A8:  MOVWF  x0C
52AA:  MOVLB  0
52AC:  CALL   4004
....................              aes_enc_dec((unsigned int8 *)&encryptblock[0], (unsigned int8 *)&crypto_key[0],0); 
52B0:  MOVLW  08
52B2:  MOVLB  8
52B4:  MOVWF  xF8
52B6:  MOVLW  D7
52B8:  MOVWF  xF7
52BA:  MOVLW  01
52BC:  MOVWF  xFA
52BE:  MOVWF  xF9
52C0:  CLRF   xFB
52C2:  MOVLB  0
52C4:  CALL   40FA
....................              /*for(u=0;u<16;u++) 
....................              { 
....................                 encryptblock[u];  
....................                 fprintf(COM2,"%x",encryptblock[u]); 
....................              }*/ 
....................              EEPROM_write(ptr_card,16,encryptblock); 
52C8:  MOVFF  23,903
52CC:  MOVFF  22,902
52D0:  MOVFF  21,901
52D4:  MOVFF  20,900
52D8:  MOVLB  9
52DA:  CLRF   x07
52DC:  CLRF   x06
52DE:  CLRF   x05
52E0:  MOVLW  10
52E2:  MOVWF  x04
52E4:  MOVLW  08
52E6:  MOVWF  x09
52E8:  MOVLW  D7
52EA:  MOVWF  x08
52EC:  MOVLB  0
52EE:  RCALL  4EF6
....................              ptr_card=ptr_card+16; 
52F0:  MOVLW  10
52F2:  ADDWF  20,F
52F4:  MOVLW  00
52F6:  ADDWFC 21,F
52F8:  ADDWFC 22,F
52FA:  ADDWFC 23,F
....................          } 
52FC:  MOVLB  8
52FE:  INCF   x51,F
5300:  BRA    5248
....................          fprintf(COM2,"\r\n"); 
5302:  MOVLW  0D
5304:  MOVLB  9
5306:  MOVWF  x0C
5308:  MOVLB  0
530A:  CALL   1604
530E:  MOVLW  0A
5310:  MOVLB  9
5312:  MOVWF  x0C
5314:  MOVLB  0
5316:  CALL   1604
....................          fprintf(COM2,"card data: %lu",ptr_card); 
531A:  MOVLW  04
531C:  MOVWF  FF6
531E:  MOVLW  06
5320:  MOVWF  FF7
5322:  MOVLW  0B
5324:  MOVLB  8
5326:  MOVWF  xF7
5328:  MOVLB  0
532A:  CALL   164A
532E:  MOVLW  41
5330:  MOVWF  FE9
5332:  MOVFF  23,8FA
5336:  MOVFF  22,8F9
533A:  MOVFF  21,8F8
533E:  MOVFF  20,8F7
5342:  CALL   22FA
....................          fprintf(COM2,"\r\n"); 
5346:  MOVLW  0D
5348:  MOVLB  9
534A:  MOVWF  x0C
534C:  MOVLB  0
534E:  CALL   1604
5352:  MOVLW  0A
5354:  MOVLB  9
5356:  MOVWF  x0C
5358:  MOVLB  0
535A:  CALL   1604
....................          EEPROM_read(ptr_card-128,128,&carddata); 
535E:  MOVLW  80
5360:  SUBWF  20,W
5362:  MOVLB  8
5364:  MOVWF  xF7
5366:  MOVLW  00
5368:  SUBWFB 21,W
536A:  MOVWF  xF8
536C:  MOVLW  00
536E:  SUBWFB 22,W
5370:  MOVWF  xF9
5372:  MOVLW  00
5374:  SUBWFB 23,W
5376:  MOVWF  xFA
5378:  MOVFF  FE8,907
537C:  MOVFF  8F9,906
5380:  MOVFF  8F8,905
5384:  MOVFF  8F7,904
5388:  MOVLB  9
538A:  CLRF   x0B
538C:  CLRF   x0A
538E:  CLRF   x09
5390:  MOVLW  80
5392:  MOVWF  x08
5394:  MOVLW  08
5396:  MOVWF  x0D
5398:  MOVLW  57
539A:  MOVWF  x0C
539C:  MOVLB  0
539E:  CALL   4004
....................          for(i=0;i<numdataofonecard;i++) 
53A2:  MOVLB  8
53A4:  CLRF   x51
53A6:  MOVF   x51,W
53A8:  SUBLW  7F
53AA:  BNC   53D2
....................          { 
....................              fprintf(COM2,"%x",carddata[i]); 
53AC:  CLRF   03
53AE:  MOVF   x51,W
53B0:  ADDLW  57
53B2:  MOVWF  FE9
53B4:  MOVLW  08
53B6:  ADDWFC 03,W
53B8:  MOVWF  FEA
53BA:  MOVFF  FEF,8F7
53BE:  MOVFF  8F7,901
53C2:  MOVLW  57
53C4:  MOVLB  9
53C6:  MOVWF  x02
53C8:  MOVLB  0
53CA:  RCALL  4F86
....................          } 
53CC:  MOVLB  8
53CE:  INCF   x51,F
53D0:  BRA    53A6
....................          memset(Track2,0,sizeof(Track2)); 
53D2:  MOVLW  02
53D4:  MOVWF  FEA
53D6:  MOVLW  1E
53D8:  MOVWF  FE9
53DA:  CLRF   00
53DC:  CLRF   02
53DE:  MOVLW  28
53E0:  MOVWF  01
53E2:  MOVLB  0
53E4:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
53E8:  MOVLW  0D
53EA:  MOVLB  9
53EC:  MOVWF  x0C
53EE:  MOVLB  0
53F0:  CALL   1604
53F4:  MOVLW  0A
53F6:  MOVLB  9
53F8:  MOVWF  x0C
53FA:  MOVLB  0
53FC:  CALL   1604
....................         fprintf(COM2,"Done"); 
5400:  MOVLW  14
5402:  MOVWF  FF6
5404:  MOVLW  06
5406:  MOVWF  FF7
5408:  CALL   172E
....................              
....................         fprintf(COM2,"\r\n"); 
540C:  MOVLW  0D
540E:  MOVLB  9
5410:  MOVWF  x0C
5412:  MOVLB  0
5414:  CALL   1604
5418:  MOVLW  0A
541A:  MOVLB  9
541C:  MOVWF  x0C
541E:  MOVLB  0
5420:  CALL   1604
....................         fprintf(COM2,"Waiting for PIN number"); 
5424:  MOVLW  1A
5426:  MOVWF  FF6
5428:  MOVLW  06
542A:  MOVWF  FF7
542C:  CALL   172E
....................         memset(key_data,0,sizeof(key_data));  
5430:  MOVLW  01
5432:  MOVWF  FEA
5434:  MOVLW  4A
5436:  MOVWF  FE9
5438:  CLRF   00
543A:  CLRF   02
543C:  MOVLW  10
543E:  MOVWF  01
5440:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
5444:  MOVLW  0D
5446:  MOVLB  9
5448:  MOVWF  x0C
544A:  MOVLB  0
544C:  CALL   1604
5450:  MOVLW  0A
5452:  MOVLB  9
5454:  MOVWF  x0C
5456:  MOVLB  0
5458:  CALL   1604
....................         charac_timeout=0; 
545C:  MOVLB  1
545E:  CLRF   x00
5460:  MOVLB  0
5462:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       //ptr_card = ptr_card+numdataofonecard; 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5464:  MOVFF  23,8FA
5468:  MOVFF  22,8F9
546C:  MOVFF  21,8F8
5470:  MOVFF  20,8F7
5474:  MOVLW  19
5476:  MOVLB  8
5478:  MOVWF  xFB
547A:  MOVLB  0
547C:  CALL   3B6A
....................       datinbuf=0; 
5480:  MOVLB  6
5482:  CLRF   xD5
....................       saving_flag=0; 
5484:  CLRF   xD8
....................       data_avai=1; 
5486:  MOVLW  01
5488:  MOVWF  xD9
....................       enable_getpin=1; 
548A:  MOVLB  1
548C:  MOVWF  x45
....................       charac_timeout=0; 
548E:  CLRF   x00
5490:  MOVLB  0
5492:  CLRF   xFF
....................       key_count_ms=0; 
5494:  MOVLB  1
5496:  CLRF   x47
5498:  MOVLB  8
549A:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
549C:  MOVLB  0
549E:  GOTO   5A98 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
18EE:  MOVLW  01
18F0:  MOVLB  8
18F2:  MOVWF  x4D
18F4:  MOVWF  x4E
18F6:  MOVWF  x4F
18F8:  MOVWF  x50
18FA:  CLRF   x51
18FC:  MOVWF  x52
18FE:  MOVWF  x53
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1900:  MOVLB  6
1902:  CLRF   xD2
1904:  CLRF   xD1
....................    mcr_timeout=0; 
1906:  CLRF   xC7
1908:  CLRF   xC6
190A:  CLRF   xC5
190C:  CLRF   xC4
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
190E:  MOVF   xD2,W
1910:  SUBLW  FD
1912:  BNC   1930
1914:  BNZ   191C
1916:  MOVF   xD1,W
1918:  SUBLW  E7
191A:  BNC   1930
191C:  BSF    F93.1
191E:  BTFSS  F81.1
1920:  BRA    1930
1922:  BSF    F94.5
1924:  BTFSS  F82.5
1926:  BRA    1930
....................       card_timeout++; 
1928:  INCF   xD1,F
192A:  BTFSC  FD8.2
192C:  INCF   xD2,F
....................    } 
192E:  BRA    190E
....................    card_timeout=0; 
1930:  CLRF   xD2
1932:  CLRF   xD1
....................    buffertrack1[bug_countbit_T1++]=0; 
1934:  MOVFF  6CE,03
1938:  MOVF   xCD,W
193A:  INCF   xCD,F
193C:  BTFSC  FD8.2
193E:  INCF   xCE,F
1940:  MOVLB  8
1942:  MOVWF  x56
1944:  MOVLW  46
1946:  ADDWF  x56,W
1948:  MOVWF  FE9
194A:  MOVLW  02
194C:  ADDWFC 03,W
194E:  MOVWF  FEA
1950:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1952:  MOVLB  6
1954:  MOVFF  6CE,03
1958:  MOVF   xCD,W
195A:  INCF   xCD,F
195C:  BTFSC  FD8.2
195E:  INCF   xCE,F
1960:  MOVLB  8
1962:  MOVWF  x56
1964:  MOVLW  46
1966:  ADDWF  x56,W
1968:  MOVWF  FE9
196A:  MOVLW  02
196C:  ADDWFC 03,W
196E:  MOVWF  FEA
1970:  MOVLW  01
1972:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1974:  MOVLB  6
1976:  MOVFF  6D0,03
197A:  MOVF   xCF,W
197C:  INCF   xCF,F
197E:  BTFSC  FD8.2
1980:  INCF   xD0,F
1982:  MOVLB  8
1984:  MOVWF  x56
1986:  MOVLW  98
1988:  ADDWF  x56,W
198A:  MOVWF  FE9
198C:  MOVLW  05
198E:  ADDWFC 03,W
1990:  MOVWF  FEA
1992:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1994:  MOVLB  6
1996:  MOVFF  6D0,03
199A:  MOVF   xCF,W
199C:  INCF   xCF,F
199E:  BTFSC  FD8.2
19A0:  INCF   xD0,F
19A2:  MOVLB  8
19A4:  MOVWF  x56
19A6:  MOVLW  98
19A8:  ADDWF  x56,W
19AA:  MOVWF  FE9
19AC:  MOVLW  05
19AE:  ADDWFC 03,W
19B0:  MOVWF  FEA
19B2:  MOVLW  01
19B4:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
19B6:  MOVLB  6
19B8:  MOVF   xCE,W
19BA:  SUBLW  03
19BC:  BTFSS  FD8.0
19BE:  BRA    1A9E
19C0:  BNZ   19CA
19C2:  MOVF   xCD,W
19C4:  SUBLW  51
19C6:  BTFSS  FD8.0
19C8:  BRA    1A9E
19CA:  MOVF   xD0,W
19CC:  SUBLW  01
19CE:  BTFSS  FD8.0
19D0:  BRA    1A9E
19D2:  BNZ   19DA
19D4:  MOVF   xCF,W
19D6:  SUBLW  2B
19D8:  BNC   1A9E
19DA:  MOVF   xD2,W
19DC:  SUBLW  FF
19DE:  BNC   1A9E
19E0:  BNZ   19E8
19E2:  MOVF   xD1,W
19E4:  SUBLW  DB
19E6:  BNC   1A9E
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
19E8:  MOVF   xDB,F
19EA:  BZ    19F4
....................          { 
....................             bug_countbit_T1=0; 
19EC:  CLRF   xCE
19EE:  CLRF   xCD
....................             bug_countbit_T2=0; 
19F0:  CLRF   xD0
19F2:  CLRF   xCF
....................          } 
....................          card_timeout++; 
19F4:  INCF   xD1,F
19F6:  BTFSC  FD8.2
19F8:  INCF   xD2,F
....................          mcr_timeout=0; 
19FA:  CLRF   xC7
19FC:  CLRF   xC6
19FE:  CLRF   xC5
1A00:  CLRF   xC4
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1A02:  BSF    F93.2
1A04:  MOVLB  8
1A06:  CLRF   x4D
1A08:  BTFSC  F81.2
1A0A:  INCF   x4D,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1A0C:  MOVF   x4D,F
1A0E:  BNZ   1A4C
1A10:  DECFSZ x4E,W
1A12:  BRA    1A4C
....................          { 
....................             ST1_old = 0; 
1A14:  CLRF   x4E
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1A16:  MOVLW  46
1A18:  MOVLB  6
1A1A:  ADDWF  xCD,W
1A1C:  MOVWF  FE9
1A1E:  MOVLW  02
1A20:  ADDWFC xCE,W
1A22:  MOVWF  FEA
1A24:  BSF    F93.1
1A26:  MOVLW  00
1A28:  BTFSS  F81.1
1A2A:  MOVLW  01
1A2C:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1A2E:  MOVLW  98
1A30:  ADDWF  xCF,W
1A32:  MOVWF  FE9
1A34:  MOVLW  05
1A36:  ADDWFC xD0,W
1A38:  MOVWF  FEA
1A3A:  MOVFF  851,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1A3E:  INCF   xCD,F
1A40:  BTFSC  FD8.2
1A42:  INCF   xCE,F
....................             card_timeout=0; 
1A44:  CLRF   xD2
1A46:  CLRF   xD1
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A48:  BRA    1A56
1A4A:  MOVLB  8
1A4C:  DECFSZ x4D,W
1A4E:  BRA    1A54
1A50:  MOVLW  01
1A52:  MOVWF  x4E
1A54:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A56:  BSF    F93.3
1A58:  MOVLB  8
1A5A:  CLRF   x4F
1A5C:  BTFSC  F81.3
1A5E:  INCF   x4F,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A60:  MOVF   x4F,F
1A62:  BNZ   1A82
1A64:  DECFSZ x50,W
1A66:  BRA    1A82
....................          { 
....................             ST2_old = 0; 
1A68:  CLRF   x50
....................             Bit_t2 = !input(MCR_DATA2); 
1A6A:  BSF    F94.5
1A6C:  CLRF   x51
1A6E:  BTFSS  F82.5
1A70:  INCF   x51,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A72:  MOVLB  6
1A74:  INCF   xCF,F
1A76:  BTFSC  FD8.2
1A78:  INCF   xD0,F
....................             card_timeout=0; 
1A7A:  CLRF   xD2
1A7C:  CLRF   xD1
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A7E:  BRA    1A8C
1A80:  MOVLB  8
1A82:  DECFSZ x4F,W
1A84:  BRA    1A8A
1A86:  MOVLW  01
1A88:  MOVWF  x50
1A8A:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1A8C:  BSF    F93.0
1A8E:  BTFSS  F81.0
1A90:  BRA    1A9C
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1A92:  CLRF   xDB
....................             card_timeout=65500; 
1A94:  SETF   xD2
1A96:  MOVLW  DC
1A98:  MOVWF  xD1
....................             break;            
1A9A:  BRA    1A9E
....................          } 
....................       } 
1A9C:  BRA    19B8
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1A9E:  CLRF   xD2
1AA0:  CLRF   xD1
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1AA2:  MOVLB  9
1AA4:  CLRF   x15
1AA6:  MOVFF  6CE,917
1AAA:  MOVFF  6CD,916
1AAE:  MOVLW  02
1AB0:  MOVWF  x19
1AB2:  MOVLW  46
1AB4:  MOVWF  x18
1AB6:  MOVLB  0
1AB8:  CALL   0A02
1ABC:  MOVFF  01,852
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1AC0:  MOVLW  01
1AC2:  MOVLB  9
1AC4:  MOVWF  x15
1AC6:  MOVFF  6D0,917
1ACA:  MOVFF  6CF,916
1ACE:  MOVLW  05
1AD0:  MOVWF  x19
1AD2:  MOVLW  98
1AD4:  MOVWF  x18
1AD6:  MOVLB  0
1AD8:  CALL   0A02
1ADC:  MOVFF  01,853
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1AE0:  MOVLB  6
1AE2:  DECFSZ xD6,W
1AE4:  BRA    1B7A
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1AE6:  MOVLW  32
1AE8:  MOVWF  FF6
1AEA:  MOVLW  06
1AEC:  MOVWF  FF7
1AEE:  MOVLW  0E
1AF0:  MOVLB  8
1AF2:  MOVWF  xF7
1AF4:  MOVLB  0
1AF6:  RCALL  164A
1AF8:  MOVLW  10
1AFA:  MOVWF  FE9
1AFC:  MOVFF  6CE,857
1B00:  MOVFF  6CD,856
1B04:  RCALL  1672
1B06:  MOVLW  0D
1B08:  MOVLB  9
1B0A:  MOVWF  x0C
1B0C:  MOVLB  0
1B0E:  RCALL  1604
1B10:  MOVLW  0A
1B12:  MOVLB  9
1B14:  MOVWF  x0C
1B16:  MOVLB  0
1B18:  RCALL  1604
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1B1A:  MOVLW  46
1B1C:  MOVWF  FF6
1B1E:  MOVLW  06
1B20:  MOVWF  FF7
1B22:  MOVLW  0E
1B24:  MOVLB  8
1B26:  MOVWF  xF7
1B28:  MOVLB  0
1B2A:  RCALL  164A
1B2C:  MOVLW  10
1B2E:  MOVWF  FE9
1B30:  MOVFF  6D0,857
1B34:  MOVFF  6CF,856
1B38:  RCALL  1672
1B3A:  MOVLW  0D
1B3C:  MOVLB  9
1B3E:  MOVWF  x0C
1B40:  MOVLB  0
1B42:  RCALL  1604
1B44:  MOVLW  0A
1B46:  MOVLB  9
1B48:  MOVWF  x0C
1B4A:  MOVLB  0
1B4C:  RCALL  1604
....................          debug_reader();       
1B4E:  BRA    1836
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B50:  MOVLB  8
1B52:  MOVF   x52,F
1B54:  BNZ   1B64
1B56:  MOVLW  5A
1B58:  MOVWF  FF6
1B5A:  MOVLW  06
1B5C:  MOVWF  FF7
1B5E:  MOVLB  0
1B60:  RCALL  172E
1B62:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B64:  MOVF   x53,F
1B66:  BNZ   1B76
1B68:  MOVLW  70
1B6A:  MOVWF  FF6
1B6C:  MOVLW  06
1B6E:  MOVWF  FF7
1B70:  MOVLB  0
1B72:  RCALL  172E
1B74:  MOVLB  8
....................       } 
....................          else 
1B76:  BRA    1B86
1B78:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B7A:  MOVLW  0F
1B7C:  MOVLB  8
1B7E:  MOVWF  x56
1B80:  MOVLB  0
1B82:  RCALL  18C6
1B84:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1B86:  MOVF   x52,F
1B88:  BZ    1B8E
1B8A:  MOVF   x53,F
1B8C:  BNZ   1BAE
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1B8E:  MOVLB  6
1B90:  CLRF   xD0
1B92:  CLRF   xCF
....................          bug_countbit_T1=0; 
1B94:  CLRF   xCE
1B96:  CLRF   xCD
....................          reading_fg=0; 
1B98:  CLRF   xDA
....................          count_reading_error++; 
1B9A:  INCF   xDB,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1B9C:  CLRF   xC7
1B9E:  CLRF   xC6
1BA0:  CLRF   xC5
1BA2:  CLRF   xC4
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1BA4:  MOVLW  00
1BA6:  MOVWF  01
1BA8:  BRA    1BE8
....................       } 
....................          else  
1BAA:  BRA    1BE4
1BAC:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1BAE:  MOVLW  01
1BB0:  MOVLB  6
1BB2:  MOVWF  xD5
....................             reading_fg=1; 
1BB4:  MOVWF  xDA
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1BB6:  MOVFF  6D0,6CC
1BBA:  MOVFF  6CF,6CB
....................             countbit_T1=bug_countbit_T1; 
1BBE:  MOVFF  6CE,6CA
1BC2:  MOVFF  6CD,6C9
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1BC6:  CLRF   xCE
1BC8:  CLRF   xCD
....................             bug_countbit_T2=0;  
1BCA:  CLRF   xD0
1BCC:  CLRF   xCF
....................             mcr_timeout=0; 
1BCE:  CLRF   xC7
1BD0:  CLRF   xC6
1BD2:  CLRF   xC5
1BD4:  CLRF   xC4
....................             charac_timeout=0; 
1BD6:  MOVLB  1
1BD8:  CLRF   x00
1BDA:  MOVLB  0
1BDC:  CLRF   xFF
....................             return 1; 
1BDE:  MOVWF  01
1BE0:  MOVLB  6
1BE2:  BRA    1BE8
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1BE4:  MOVLW  00
1BE6:  MOVWF  01
.................... } 
1BE8:  MOVLB  0
1BEA:  GOTO   1C10 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       delay_us(500); 
1BEE:  MOVLW  02
1BF0:  MOVLB  8
1BF2:  MOVWF  x4D
1BF4:  MOVLW  FA
1BF6:  MOVWF  x4E
1BF8:  MOVLB  0
1BFA:  GOTO   0686
1BFE:  MOVLB  8
1C00:  DECFSZ x4D,F
1C02:  BRA    1BF4
....................       if(saving_flag==1) return;      
1C04:  MOVLB  6
1C06:  DECFSZ xD8,W
1C08:  BRA    1C0C
1C0A:  BRA    1C22
....................       cardread_st=mcr_read(); 
1C0C:  MOVLB  0
1C0E:  BRA    18EE
1C10:  MOVFF  01,6D7
....................       mcr_timeout=0; 
1C14:  MOVLB  6
1C16:  CLRF   xC7
1C18:  CLRF   xC6
1C1A:  CLRF   xC5
1C1C:  CLRF   xC4
....................       card_timeout=0;      
1C1E:  CLRF   xD2
1C20:  CLRF   xD1
.................... } 
.................... //==================================== 
.................... #if 0 
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... #endif 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
1C22:  BCF    FF0.0
1C24:  MOVLB  0
1C26:  GOTO   006C
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
6A2A:  CLRF   19
6A2C:  BTFSC  FF2.7
6A2E:  BSF    19.7
6A30:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
6A32:  MOVLB  9
6A34:  CLRF   x16
6A36:  CLRF   x15
6A38:  CLRF   x14
6A3A:  MOVLW  3C
6A3C:  MOVWF  x13
6A3E:  MOVLW  03
6A40:  MOVWF  x17
6A42:  MOVLB  0
6A44:  CALL   3A6C
6A48:  BTFSC  19.7
6A4A:  BSF    FF2.7
6A4C:  CLRF   19
6A4E:  BTFSC  FF2.7
6A50:  BSF    19.7
6A52:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
6A54:  MOVLB  9
6A56:  CLRF   x16
6A58:  CLRF   x15
6A5A:  CLRF   x14
6A5C:  MOVLW  3A
6A5E:  MOVWF  x13
6A60:  MOVLW  01
6A62:  MOVWF  x17
6A64:  MOVLB  0
6A66:  CALL   3A6C
6A6A:  BTFSC  19.7
6A6C:  BSF    FF2.7
6A6E:  CLRF   19
6A70:  BTFSC  FF2.7
6A72:  BSF    19.7
6A74:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV);  
6A76:  MOVLB  9
6A78:  CLRF   x1B
6A7A:  CLRF   x1A
6A7C:  CLRF   x19
6A7E:  MOVLW  3A
6A80:  MOVWF  x18
6A82:  MOVLB  0
6A84:  CALL   3450
6A88:  BTFSC  19.7
6A8A:  BSF    FF2.7
6A8C:  MOVFF  01,6E2
.................... } 
6A90:  GOTO   6E34 (RETURN)
.................... //================================ 
.................... void downloaddataregular() 
.................... { 
*
6298:  MOVLB  7
629A:  CLRF   xF6
629C:  CLRF   xF5
....................     int8 index,i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 temp[50]; 
....................     rec[0]=0; 
629E:  MOVLB  0
62A0:  CLRF   x7D
62A2:  CLRF   19
62A4:  BTFSC  FF2.7
62A6:  BSF    19.7
62A8:  BCF    FF2.7
....................     count_card_tg=get_countcard(); 
62AA:  CALL   351C
62AE:  BTFSC  19.7
62B0:  BSF    FF2.7
62B2:  MOVFF  02,6E1
62B6:  MOVFF  01,6E0
62BA:  CLRF   19
62BC:  BTFSC  FF2.7
62BE:  BSF    19.7
62C0:  BCF    FF2.7
....................     adr=count_card*numdata; 
62C2:  MOVFF  6DF,856
62C6:  MOVFF  6DE,855
62CA:  MOVLB  8
62CC:  CLRF   x58
62CE:  MOVLW  7C
62D0:  MOVWF  x57
62D2:  MOVLB  0
62D4:  CALL   3578
62D8:  BTFSC  19.7
62DA:  BSF    FF2.7
62DC:  MOVFF  02,7F6
62E0:  MOVFF  01,7F5
....................     addr_key=EEPROM_KEY_ST; 
62E4:  MOVLB  6
62E6:  CLRF   xE6
62E8:  MOVLW  01
62EA:  MOVWF  xE5
62EC:  MOVLW  C3
62EE:  MOVWF  xE4
62F0:  MOVLW  0F
62F2:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
62F4:  MOVF   xDF,W
62F6:  SUBWF  xE1,W
62F8:  BTFSS  FD8.0
62FA:  BRA    6694
62FC:  BNZ   6306
62FE:  MOVF   xDE,W
6300:  SUBWF  xE0,W
6302:  BTFSS  FD8.0
6304:  BRA    6694
6306:  CLRF   19
6308:  BTFSC  FF2.7
630A:  BSF    19.7
630C:  BCF    FF2.7
....................         adr=count_card*numdata+ptr_start; 
630E:  MOVFF  6DF,856
6312:  MOVFF  6DE,855
6316:  MOVLB  8
6318:  CLRF   x58
631A:  MOVLW  7C
631C:  MOVWF  x57
631E:  MOVLB  0
6320:  CALL   3578
6324:  BTFSC  19.7
6326:  BSF    FF2.7
6328:  MOVLW  96
632A:  MOVLB  8
632C:  ADDWF  01,W
632E:  MOVLB  7
6330:  MOVWF  xF5
6332:  MOVLW  00
6334:  MOVLB  8
6336:  ADDWFC 02,W
6338:  MOVLB  7
633A:  MOVWF  xF6
....................         EEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
633C:  MOVLW  7C
633E:  SUBWF  xF5,W
6340:  MOVLB  8
6342:  MOVWF  x2B
6344:  MOVLW  00
6346:  MOVLB  7
6348:  SUBWFB xF6,W
634A:  MOVLB  8
634C:  MOVWF  x2C
634E:  CLRF   19
6350:  BTFSC  FF2.7
6352:  BSF    19.7
6354:  BCF    FF2.7
6356:  MOVLB  9
6358:  CLRF   x07
635A:  CLRF   x06
635C:  MOVWF  x05
635E:  MOVFF  82B,904
6362:  CLRF   x0B
6364:  CLRF   x0A
6366:  CLRF   x09
6368:  MOVLW  7C
636A:  MOVWF  x08
636C:  CLRF   x0D
636E:  MOVLW  7D
6370:  MOVWF  x0C
6372:  MOVLB  0
6374:  CALL   4004
6378:  BTFSC  19.7
637A:  BSF    FF2.7
....................         fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
637C:  MOVLW  10
637E:  MOVWF  FE9
6380:  CLRF   19
6382:  BTFSC  FF2.7
6384:  BSF    19.7
6386:  BCF    FF2.7
6388:  MOVFF  6DF,851
638C:  MOVFF  6DE,850
6390:  CALL   5916
6394:  BTFSC  19.7
6396:  BSF    FF2.7
6398:  CLRF   19
639A:  BTFSC  FF2.7
639C:  BSF    19.7
639E:  BCF    FF2.7
63A0:  MOVLW  29
63A2:  MOVLB  9
63A4:  MOVWF  x0C
63A6:  MOVLB  0
63A8:  CALL   1604
63AC:  BTFSC  19.7
63AE:  BSF    FF2.7
63B0:  MOVFF  7D,82B
63B4:  MOVLW  01
63B6:  MOVLB  8
63B8:  MOVWF  x2C
63BA:  MOVLB  0
63BC:  RCALL  6182
63BE:  CLRF   19
63C0:  BTFSC  FF2.7
63C2:  BSF    19.7
63C4:  BCF    FF2.7
63C6:  MOVLW  2F
63C8:  MOVLB  9
63CA:  MOVWF  x0C
63CC:  MOVLB  0
63CE:  CALL   1604
63D2:  BTFSC  19.7
63D4:  BSF    FF2.7
63D6:  MOVFF  7E,82B
63DA:  MOVLW  01
63DC:  MOVLB  8
63DE:  MOVWF  x2C
63E0:  MOVLB  0
63E2:  RCALL  6182
63E4:  CLRF   19
63E6:  BTFSC  FF2.7
63E8:  BSF    19.7
63EA:  BCF    FF2.7
63EC:  MOVLW  20
63EE:  MOVLB  9
63F0:  MOVWF  x0C
63F2:  MOVLB  0
63F4:  CALL   1604
63F8:  BTFSC  19.7
63FA:  BSF    FF2.7
63FC:  MOVFF  7F,82B
6400:  MOVLW  01
6402:  MOVLB  8
6404:  MOVWF  x2C
6406:  MOVLB  0
6408:  RCALL  6182
640A:  CLRF   19
640C:  BTFSC  FF2.7
640E:  BSF    19.7
6410:  BCF    FF2.7
6412:  MOVLW  3A
6414:  MOVLB  9
6416:  MOVWF  x0C
6418:  MOVLB  0
641A:  CALL   1604
641E:  BTFSC  19.7
6420:  BSF    FF2.7
6422:  MOVFF  80,82B
6426:  MOVLW  01
6428:  MOVLB  8
642A:  MOVWF  x2C
642C:  MOVLB  0
642E:  RCALL  6182
6430:  CLRF   19
6432:  BTFSC  FF2.7
6434:  BSF    19.7
6436:  BCF    FF2.7
6438:  MOVLW  3A
643A:  MOVLB  9
643C:  MOVWF  x0C
643E:  MOVLB  0
6440:  CALL   1604
6444:  BTFSC  19.7
6446:  BSF    FF2.7
6448:  MOVFF  81,82B
644C:  MOVLW  01
644E:  MOVLB  8
6450:  MOVWF  x2C
6452:  MOVLB  0
6454:  RCALL  6182
....................         ee_dat=0; 
6456:  MOVLB  6
6458:  CLRF   xDD
....................         index=0; 
645A:  MOVLB  7
645C:  CLRF   xF3
....................         fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
645E:  MOVLW  2A
6460:  MOVWF  FF6
6462:  MOVLW  1C
6464:  MOVWF  FF7
6466:  CLRF   19
6468:  BTFSC  FF2.7
646A:  BSF    19.7
646C:  BCF    FF2.7
646E:  MOVLB  0
6470:  CALL   172E
6474:  BTFSC  19.7
6476:  BSF    FF2.7
....................         while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................         { 
6478:  MOVLB  7
647A:  MOVF   xF3,W
647C:  SUBLW  4E
647E:  BNC   64DC
6480:  MOVLB  6
6482:  MOVF   xDD,W
6484:  SUBLW  3F
6486:  BTFSS  FD8.2
6488:  BRA    648E
648A:  MOVLB  7
648C:  BRA    64DC
....................            ee_dat = rec[index+5]; 
648E:  MOVLW  05
6490:  MOVLB  7
6492:  ADDWF  xF3,W
6494:  CLRF   03
6496:  ADDLW  7D
6498:  MOVWF  FE9
649A:  MOVLW  00
649C:  ADDWFC 03,W
649E:  MOVWF  FEA
64A0:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
64A4:  MOVLB  6
64A6:  MOVF   xDD,W
64A8:  SUBLW  1F
64AA:  BC    64C8
64AC:  MOVF   xDD,W
64AE:  SUBLW  7E
64B0:  BNC   64C8
64B2:  CLRF   19
64B4:  BTFSC  FF2.7
64B6:  BSF    19.7
64B8:  BCF    FF2.7
64BA:  MOVFF  6DD,90C
64BE:  MOVLB  0
64C0:  CALL   1604
64C4:  BTFSC  19.7
64C6:  BSF    FF2.7
....................            index++; 
64C8:  MOVLB  7
64CA:  INCF   xF3,F
....................            if(ee_dat==0)break; 
64CC:  MOVLB  6
64CE:  MOVF   xDD,F
64D0:  BNZ   64D6
64D2:  MOVLB  7
64D4:  BRA    64DC
....................         } 
64D6:  MOVLB  0
64D8:  BRA    6478
64DA:  MOVLB  7
....................         fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
64DC:  MOVLW  3C
64DE:  MOVWF  FF6
64E0:  MOVLW  1C
64E2:  MOVWF  FF7
64E4:  CLRF   19
64E6:  BTFSC  FF2.7
64E8:  BSF    19.7
64EA:  BCF    FF2.7
64EC:  MOVLB  0
64EE:  CALL   172E
64F2:  BTFSC  19.7
64F4:  BSF    FF2.7
....................         index=0; 
64F6:  MOVLB  7
64F8:  CLRF   xF3
....................         ee_dat=0; 
64FA:  MOVLB  6
64FC:  CLRF   xDD
....................         while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................         { 
64FE:  MOVLB  7
6500:  MOVF   xF3,W
6502:  SUBLW  27
6504:  BNC   6564
6506:  MOVLB  6
6508:  MOVF   xDD,W
650A:  SUBLW  3F
650C:  BTFSS  FD8.2
650E:  BRA    6514
6510:  MOVLB  7
6512:  BRA    6564
....................            ee_dat = rec[index+5+numbyteoftrack1]; 
6514:  MOVLW  05
6516:  MOVLB  7
6518:  ADDWF  xF3,W
651A:  ADDLW  4F
651C:  CLRF   03
651E:  ADDLW  7D
6520:  MOVWF  FE9
6522:  MOVLW  00
6524:  ADDWFC 03,W
6526:  MOVWF  FEA
6528:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
652C:  MOVLB  6
652E:  MOVF   xDD,W
6530:  SUBLW  1F
6532:  BC    6550
6534:  MOVF   xDD,W
6536:  SUBLW  7E
6538:  BNC   6550
653A:  CLRF   19
653C:  BTFSC  FF2.7
653E:  BSF    19.7
6540:  BCF    FF2.7
6542:  MOVFF  6DD,90C
6546:  MOVLB  0
6548:  CALL   1604
654C:  BTFSC  19.7
654E:  BSF    FF2.7
....................            index++; 
6550:  MOVLB  7
6552:  INCF   xF3,F
....................            if(ee_dat==0)break; 
6554:  MOVLB  6
6556:  MOVF   xDD,F
6558:  BNZ   6560
655A:  MOVLB  7
655C:  BRA    6564
655E:  MOVLB  6
....................         } 
6560:  BRA    64FE
6562:  MOVLB  7
....................         index=0; 
6564:  CLRF   xF3
....................  
....................         fprintf(COM2,"\r\nPIN Number:\r\n"); 
6566:  MOVLW  4E
6568:  MOVWF  FF6
656A:  MOVLW  1C
656C:  MOVWF  FF7
656E:  CLRF   19
6570:  BTFSC  FF2.7
6572:  BSF    19.7
6574:  BCF    FF2.7
6576:  MOVLB  0
6578:  CALL   172E
657C:  BTFSC  19.7
657E:  BSF    FF2.7
....................  
....................         if((ptr_card_key>addr_key)) //&& 
6580:  MOVLB  6
6582:  MOVF   xE6,W
6584:  SUBWF  27,W
6586:  BTFSS  FD8.0
6588:  BRA    668C
658A:  BNZ   65A8
658C:  MOVF   xE5,W
658E:  SUBWF  26,W
6590:  BTFSS  FD8.0
6592:  BRA    668C
6594:  BNZ   65A8
6596:  MOVF   xE4,W
6598:  SUBWF  25,W
659A:  BTFSS  FD8.0
659C:  BRA    668C
659E:  BNZ   65A8
65A0:  MOVF   24,W
65A2:  SUBWF  xE3,W
65A4:  BTFSC  FD8.0
65A6:  BRA    668C
....................         { 
....................            i=0; 
65A8:  MOVLB  7
65AA:  CLRF   xF4
....................            do 
....................            { 
....................               ee_dat=read_ext_eeprom(i+addr_key); 
65AC:  MOVF   xF4,W
65AE:  MOVLB  6
65B0:  ADDWF  xE3,W
65B2:  MOVLB  8
65B4:  MOVWF  x2B
65B6:  MOVLW  00
65B8:  MOVLB  6
65BA:  ADDWFC xE4,W
65BC:  MOVLB  8
65BE:  MOVWF  x2C
65C0:  MOVLW  00
65C2:  MOVLB  6
65C4:  ADDWFC xE5,W
65C6:  MOVLB  8
65C8:  MOVWF  x2D
65CA:  MOVLW  00
65CC:  MOVLB  6
65CE:  ADDWFC xE6,W
65D0:  MOVLB  8
65D2:  MOVWF  x2E
65D4:  CLRF   19
65D6:  BTFSC  FF2.7
65D8:  BSF    19.7
65DA:  BCF    FF2.7
65DC:  MOVFF  FE8,91B
65E0:  MOVFF  82D,91A
65E4:  MOVFF  82C,919
65E8:  MOVFF  82B,918
65EC:  MOVLB  0
65EE:  CALL   3450
65F2:  BTFSC  19.7
65F4:  BSF    FF2.7
65F6:  MOVFF  01,6DD
....................               if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
65FA:  MOVLB  6
65FC:  MOVF   xDD,W
65FE:  SUBLW  2F
6600:  BC    6608
6602:  MOVF   xDD,W
6604:  SUBLW  39
6606:  BC    6620
6608:  MOVF   xDD,W
660A:  SUBLW  23
660C:  BZ    6620
660E:  MOVF   xDD,W
6610:  SUBLW  2A
6612:  BZ    6620
6614:  MOVF   xDD,W
6616:  SUBLW  40
6618:  BC    6636
661A:  MOVF   xDD,W
661C:  SUBLW  5A
661E:  BNC   6636
6620:  CLRF   19
6622:  BTFSC  FF2.7
6624:  BSF    19.7
6626:  BCF    FF2.7
....................               { 
....................                  fprintf(COM2,"%c",ee_dat); 
6628:  MOVFF  6DD,90C
662C:  MOVLB  0
662E:  CALL   1604
6632:  BTFSC  19.7
6634:  BSF    FF2.7
....................               } 
....................               i++; 
6636:  MOVLB  7
6638:  INCF   xF4,F
....................            } 
....................            while((i<wideofkeystore)&&(ee_dat!=0)); 
663A:  MOVF   xF4,W
663C:  SUBLW  0F
663E:  BNC   664C
6640:  MOVLB  6
6642:  MOVF   xDD,F
6644:  BTFSC  FD8.2
6646:  BRA    664C
6648:  MOVLB  7
664A:  BRA    65AC
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
664C:  MOVLW  10
664E:  MOVLB  6
6650:  ADDWF  xE3,F
6652:  MOVLW  00
6654:  ADDWFC xE4,F
6656:  ADDWFC xE5,F
6658:  ADDWFC xE6,F
665A:  CLRF   19
665C:  BTFSC  FF2.7
665E:  BSF    19.7
6660:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
6662:  MOVLW  0A
6664:  MOVLB  9
6666:  MOVWF  x0C
6668:  MOVLB  0
666A:  CALL   1604
666E:  BTFSC  19.7
6670:  BSF    FF2.7
6672:  CLRF   19
6674:  BTFSC  FF2.7
6676:  BSF    19.7
6678:  BCF    FF2.7
667A:  MOVLW  0D
667C:  MOVLB  9
667E:  MOVWF  x0C
6680:  MOVLB  0
6682:  CALL   1604
6686:  BTFSC  19.7
6688:  BSF    FF2.7
668A:  MOVLB  6
....................         } 
....................         count_card++; 
668C:  INCF   xDE,F
668E:  BTFSC  FD8.2
6690:  INCF   xDF,F
....................     }  
6692:  BRA    62F4
.................... } 
6694:  MOVLB  0
6696:  GOTO   6C66 (RETURN)
.................... //================================ 
.................... void downloaddataEncrypt() 
.................... { 
669A:  MOVLB  7
669C:  CLRF   xF5
669E:  CLRF   xF4
66A0:  CLRF   19
66A2:  BTFSC  FF2.7
66A4:  BSF    19.7
66A6:  BCF    FF2.7
....................     int8 i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 keydatatemp[16]; 
....................     count_card_tg=get_countcard(); 
66A8:  MOVLB  0
66AA:  CALL   351C
66AE:  BTFSC  19.7
66B0:  BSF    FF2.7
66B2:  MOVFF  02,6E1
66B6:  MOVFF  01,6E0
....................     adr=count_card*numdataofonecard; 
66BA:  MOVLB  6
66BC:  RLCF   xDE,W
66BE:  MOVLB  7
66C0:  MOVWF  xF4
66C2:  MOVLB  6
66C4:  RLCF   xDF,W
66C6:  MOVLB  7
66C8:  MOVWF  xF5
66CA:  RLCF   xF4,F
66CC:  RLCF   xF5,F
66CE:  RLCF   xF4,F
66D0:  RLCF   xF5,F
66D2:  RLCF   xF4,F
66D4:  RLCF   xF5,F
66D6:  RLCF   xF4,F
66D8:  RLCF   xF5,F
66DA:  RLCF   xF4,F
66DC:  RLCF   xF5,F
66DE:  RLCF   xF4,F
66E0:  RLCF   xF5,F
66E2:  MOVLW  80
66E4:  ANDWF  xF4,F
....................     addr_key=EEPROM_KEY_ST; 
66E6:  MOVLB  6
66E8:  CLRF   xE6
66EA:  MOVLW  01
66EC:  MOVWF  xE5
66EE:  MOVLW  C3
66F0:  MOVWF  xE4
66F2:  MOVLW  0F
66F4:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
66F6:  MOVF   xDF,W
66F8:  SUBWF  xE1,W
66FA:  BTFSS  FD8.0
66FC:  BRA    68B4
66FE:  BNZ   6708
6700:  MOVF   xDE,W
6702:  SUBWF  xE0,W
6704:  BTFSS  FD8.0
6706:  BRA    68B4
....................         adr=count_card*numdataofonecard+ptr_start; 
6708:  RLCF   xDE,W
670A:  MOVLB  8
670C:  MOVWF  x08
670E:  MOVLB  6
6710:  RLCF   xDF,W
6712:  MOVLB  8
6714:  MOVWF  x09
6716:  RLCF   x08,F
6718:  RLCF   x09,F
671A:  RLCF   x08,F
671C:  RLCF   x09,F
671E:  RLCF   x08,F
6720:  RLCF   x09,F
6722:  RLCF   x08,F
6724:  RLCF   x09,F
6726:  RLCF   x08,F
6728:  RLCF   x09,F
672A:  RLCF   x08,F
672C:  RLCF   x09,F
672E:  MOVLW  80
6730:  ANDWF  x08,F
6732:  MOVLW  96
6734:  ADDWF  x08,W
6736:  MOVLB  7
6738:  MOVWF  xF4
673A:  MOVLW  00
673C:  MOVLB  8
673E:  ADDWFC x09,W
6740:  MOVLB  7
6742:  MOVWF  xF5
....................         memset(rec,0,sizeof(rec)); 
6744:  CLRF   FEA
6746:  MOVLW  7D
6748:  MOVWF  FE9
674A:  CLRF   00
674C:  CLRF   02
674E:  MOVLW  80
6750:  MOVWF  01
6752:  MOVLB  0
6754:  CALL   359A
....................         EEPROM_read((unsigned int16)(adr-numdataofonecard),numdataofonecard,rec); 
6758:  MOVLW  80
675A:  MOVLB  7
675C:  SUBWF  xF4,W
675E:  MOVLB  8
6760:  MOVWF  x08
6762:  MOVLW  00
6764:  MOVLB  7
6766:  SUBWFB xF5,W
6768:  MOVLB  8
676A:  MOVWF  x09
676C:  CLRF   19
676E:  BTFSC  FF2.7
6770:  BSF    19.7
6772:  BCF    FF2.7
6774:  MOVLB  9
6776:  CLRF   x07
6778:  CLRF   x06
677A:  MOVWF  x05
677C:  MOVFF  808,904
6780:  CLRF   x0B
6782:  CLRF   x0A
6784:  CLRF   x09
6786:  MOVLW  80
6788:  MOVWF  x08
678A:  CLRF   x0D
678C:  MOVLW  7D
678E:  MOVWF  x0C
6790:  MOVLB  0
6792:  CALL   4004
6796:  BTFSC  19.7
6798:  BSF    FF2.7
....................         for(i=0;i<numdataofonecard;i++) 
679A:  MOVLB  7
679C:  CLRF   xF3
679E:  MOVF   xF3,W
67A0:  SUBLW  7F
67A2:  BNC   67D8
....................         { 
....................            fprintf(COM2,"%x",rec[i]);  
67A4:  CLRF   03
67A6:  MOVF   xF3,W
67A8:  ADDLW  7D
67AA:  MOVWF  FE9
67AC:  MOVLW  00
67AE:  ADDWFC 03,W
67B0:  MOVWF  FEA
67B2:  MOVFF  FEF,808
67B6:  CLRF   19
67B8:  BTFSC  FF2.7
67BA:  BSF    19.7
67BC:  BCF    FF2.7
67BE:  MOVFF  808,901
67C2:  MOVLW  57
67C4:  MOVLB  9
67C6:  MOVWF  x02
67C8:  MOVLB  0
67CA:  CALL   4F86
67CE:  BTFSC  19.7
67D0:  BSF    FF2.7
....................         } 
67D2:  MOVLB  7
67D4:  INCF   xF3,F
67D6:  BRA    679E
....................  
....................         if((ptr_card_key>addr_key)) 
67D8:  MOVLB  6
67DA:  MOVF   xE6,W
67DC:  SUBWF  27,W
67DE:  BNC   68AC
67E0:  BNZ   67F8
67E2:  MOVF   xE5,W
67E4:  SUBWF  26,W
67E6:  BNC   68AC
67E8:  BNZ   67F8
67EA:  MOVF   xE4,W
67EC:  SUBWF  25,W
67EE:  BNC   68AC
67F0:  BNZ   67F8
67F2:  MOVF   24,W
67F4:  SUBWF  xE3,W
67F6:  BC    68AC
67F8:  CLRF   19
67FA:  BTFSC  FF2.7
67FC:  BSF    19.7
67FE:  BCF    FF2.7
....................         { 
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            EEPROM_read(addr_key,wideofkeystore,keydatatemp); 
6800:  MOVFF  6E6,907
6804:  MOVFF  6E5,906
6808:  MOVFF  6E4,905
680C:  MOVFF  6E3,904
6810:  MOVLB  9
6812:  CLRF   x0B
6814:  CLRF   x0A
6816:  CLRF   x09
6818:  MOVLW  10
681A:  MOVWF  x08
681C:  MOVLW  07
681E:  MOVWF  x0D
6820:  MOVLW  F8
6822:  MOVWF  x0C
6824:  MOVLB  0
6826:  CALL   4004
682A:  BTFSC  19.7
682C:  BSF    FF2.7
....................            for(i=0;i<wideofkeystore;i++) 
682E:  MOVLB  7
6830:  CLRF   xF3
6832:  MOVF   xF3,W
6834:  SUBLW  0F
6836:  BNC   686C
....................            { 
....................                fprintf(COM2,"%x",keydatatemp[i]); 
6838:  CLRF   03
683A:  MOVF   xF3,W
683C:  ADDLW  F8
683E:  MOVWF  FE9
6840:  MOVLW  07
6842:  ADDWFC 03,W
6844:  MOVWF  FEA
6846:  MOVFF  FEF,808
684A:  CLRF   19
684C:  BTFSC  FF2.7
684E:  BSF    19.7
6850:  BCF    FF2.7
6852:  MOVFF  808,901
6856:  MOVLW  57
6858:  MOVLB  9
685A:  MOVWF  x02
685C:  MOVLB  0
685E:  CALL   4F86
6862:  BTFSC  19.7
6864:  BSF    FF2.7
....................            } 
6866:  MOVLB  7
6868:  INCF   xF3,F
686A:  BRA    6832
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
686C:  MOVLW  10
686E:  MOVLB  6
6870:  ADDWF  xE3,F
6872:  MOVLW  00
6874:  ADDWFC xE4,F
6876:  ADDWFC xE5,F
6878:  ADDWFC xE6,F
687A:  CLRF   19
687C:  BTFSC  FF2.7
687E:  BSF    19.7
6880:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
6882:  MOVLW  0A
6884:  MOVLB  9
6886:  MOVWF  x0C
6888:  MOVLB  0
688A:  CALL   1604
688E:  BTFSC  19.7
6890:  BSF    FF2.7
6892:  CLRF   19
6894:  BTFSC  FF2.7
6896:  BSF    19.7
6898:  BCF    FF2.7
689A:  MOVLW  0D
689C:  MOVLB  9
689E:  MOVWF  x0C
68A0:  MOVLB  0
68A2:  CALL   1604
68A6:  BTFSC  19.7
68A8:  BSF    FF2.7
68AA:  MOVLB  6
....................         } 
....................         count_card++; 
68AC:  INCF   xDE,F
68AE:  BTFSC  FD8.2
68B0:  INCF   xDF,F
....................     }  
68B2:  BRA    66F6
.................... } 
68B4:  MOVLB  0
68B6:  GOTO   6C66 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int16 countchar; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
6BA8:  MOVLW  06
6BAA:  MOVWF  FEA
6BAC:  MOVLW  E7
6BAE:  MOVWF  FE9
6BB0:  CALL   5F32
6BB4:  CLRF   19
6BB6:  BTFSC  FF2.7
6BB8:  BSF    19.7
6BBA:  BCF    FF2.7
6BBC:  MOVLW  3E
6BBE:  MOVLB  9
6BC0:  MOVWF  x0C
6BC2:  MOVLB  0
6BC4:  CALL   1604
6BC8:  BTFSC  19.7
6BCA:  BSF    FF2.7
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
6BCC:  MOVLW  01
6BCE:  MOVLB  7
6BD0:  MOVWF  xF3
6BD2:  MOVLW  14
6BD4:  MOVWF  xF4
6BD6:  MOVLW  01
6BD8:  MOVWF  xF6
6BDA:  MOVLW  62
6BDC:  MOVWF  xF5
6BDE:  MOVLB  0
6BE0:  CALL   5FB2
6BE4:  CLRF   19
6BE6:  BTFSC  FF2.7
6BE8:  BSF    19.7
6BEA:  BCF    FF2.7
....................       printf("\n\r"); 
6BEC:  MOVLW  0A
6BEE:  MOVLB  9
6BF0:  MOVWF  x0C
6BF2:  MOVLB  0
6BF4:  CALL   1604
6BF8:  BTFSC  19.7
6BFA:  BSF    FF2.7
6BFC:  CLRF   19
6BFE:  BTFSC  FF2.7
6C00:  BSF    19.7
6C02:  BCF    FF2.7
6C04:  MOVLW  0D
6C06:  MOVLB  9
6C08:  MOVWF  x0C
6C0A:  MOVLB  0
6C0C:  CALL   1604
6C10:  BTFSC  19.7
6C12:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
6C14:  CLRF   FEA
6C16:  MOVLW  41
6C18:  MOVWF  FE9
6C1A:  MOVLW  00
6C1C:  CALL   0356
6C20:  TBLRD*-
6C22:  TBLRD*+
6C24:  MOVF   FF5,W
6C26:  MOVWF  FEE
6C28:  IORLW  00
6C2A:  BNZ   6C22
....................       index=0; 
6C2C:  MOVLB  7
6C2E:  CLRF   xBD
....................       ee_dat=0; 
6C30:  MOVLB  6
6C32:  CLRF   xDD
....................       count_card=1; 
6C34:  CLRF   xDF
6C36:  MOVLW  01
6C38:  MOVWF  xDE
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6C3A:  MOVLB  7
6C3C:  MOVWF  xF4
6C3E:  MOVLW  62
6C40:  MOVWF  xF3
6C42:  CLRF   xF6
6C44:  MOVLW  41
6C46:  MOVWF  xF5
6C48:  MOVLB  0
6C4A:  CALL   60EA
6C4E:  MOVF   01,F
6C50:  BNZ   6C66
....................       { 
....................          if(cryption_enable==0) downloaddataregular(); 
6C52:  MOVLB  1
6C54:  MOVF   x22,F
6C56:  BNZ   6C62
6C58:  MOVLB  0
6C5A:  GOTO   6298
....................          else downloaddataEncrypt(); 
6C5E:  MOVLB  0
6C60:  BRA    6C66
6C62:  MOVLB  0
6C64:  BRA    669A
....................       }  
....................       strcpy(buffer2,"f"); 
6C66:  CLRF   FEA
6C68:  MOVLW  41
6C6A:  MOVWF  FE9
6C6C:  MOVLW  00
6C6E:  CALL   0368
6C72:  TBLRD*-
6C74:  TBLRD*+
6C76:  MOVF   FF5,W
6C78:  MOVWF  FEE
6C7A:  IORLW  00
6C7C:  BNZ   6C74
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6C7E:  MOVLW  01
6C80:  MOVLB  7
6C82:  MOVWF  xF4
6C84:  MOVLW  62
6C86:  MOVWF  xF3
6C88:  CLRF   xF6
6C8A:  MOVLW  41
6C8C:  MOVWF  xF5
6C8E:  MOVLB  0
6C90:  CALL   60EA
6C94:  MOVF   01,F
6C96:  BNZ   6CCA
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6C98:  MOVLW  5E
6C9A:  MOVWF  FF6
6C9C:  MOVLW  1C
6C9E:  MOVWF  FF7
6CA0:  CLRF   19
6CA2:  BTFSC  FF2.7
6CA4:  BSF    19.7
6CA6:  BCF    FF2.7
6CA8:  CALL   172E
6CAC:  BTFSC  19.7
6CAE:  BSF    FF2.7
....................          format_eepromext(); 
6CB0:  BRA    68BA
....................          fprintf(COM2," exit\n\r");  
6CB2:  MOVLW  6C
6CB4:  MOVWF  FF6
6CB6:  MOVLW  1C
6CB8:  MOVWF  FF7
6CBA:  CLRF   19
6CBC:  BTFSC  FF2.7
6CBE:  BSF    19.7
6CC0:  BCF    FF2.7
6CC2:  CALL   172E
6CC6:  BTFSC  19.7
6CC8:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
6CCA:  CLRF   FEA
6CCC:  MOVLW  41
6CCE:  MOVWF  FE9
6CD0:  MOVLW  00
6CD2:  CALL   037A
6CD6:  TBLRD*-
6CD8:  TBLRD*+
6CDA:  MOVF   FF5,W
6CDC:  MOVWF  FEE
6CDE:  IORLW  00
6CE0:  BNZ   6CD8
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6CE2:  MOVLW  01
6CE4:  MOVLB  7
6CE6:  MOVWF  xF4
6CE8:  MOVLW  62
6CEA:  MOVWF  xF3
6CEC:  CLRF   xF6
6CEE:  MOVLW  41
6CF0:  MOVWF  xF5
6CF2:  MOVLB  0
6CF4:  CALL   60EA
6CF8:  MOVF   01,F
6CFA:  BNZ   6D2E
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6CFC:  MOVLW  74
6CFE:  MOVWF  FF6
6D00:  MOVLW  1C
6D02:  MOVWF  FF7
6D04:  CLRF   19
6D06:  BTFSC  FF2.7
6D08:  BSF    19.7
6D0A:  BCF    FF2.7
6D0C:  CALL   172E
6D10:  BTFSC  19.7
6D12:  BSF    FF2.7
....................          ease_eeprom(); 
6D14:  BRA    6956
....................          fprintf(COM2," exit\n\r");  
6D16:  MOVLW  82
6D18:  MOVWF  FF6
6D1A:  MOVLW  1C
6D1C:  MOVWF  FF7
6D1E:  CLRF   19
6D20:  BTFSC  FF2.7
6D22:  BSF    19.7
6D24:  BCF    FF2.7
6D26:  CALL   172E
6D2A:  BTFSC  19.7
6D2C:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6D2E:  CLRF   FEA
6D30:  MOVLW  41
6D32:  MOVWF  FE9
6D34:  MOVLW  00
6D36:  CALL   0390
6D3A:  TBLRD*-
6D3C:  TBLRD*+
6D3E:  MOVF   FF5,W
6D40:  MOVWF  FEE
6D42:  IORLW  00
6D44:  BNZ   6D3C
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6D46:  MOVLW  01
6D48:  MOVLB  7
6D4A:  MOVWF  xF4
6D4C:  MOVLW  62
6D4E:  MOVWF  xF3
6D50:  CLRF   xF6
6D52:  MOVLW  41
6D54:  MOVWF  xF5
6D56:  MOVLB  0
6D58:  CALL   60EA
6D5C:  MOVF   01,F
6D5E:  BNZ   6D96
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
6D60:  MOVLW  8A
6D62:  MOVWF  FF6
6D64:  MOVLW  1C
6D66:  MOVWF  FF7
6D68:  CLRF   19
6D6A:  BTFSC  FF2.7
6D6C:  BSF    19.7
6D6E:  BCF    FF2.7
6D70:  CALL   172E
6D74:  BTFSC  19.7
6D76:  BSF    FF2.7
....................          reset_password(); 
6D78:  BRA    69DA
....................          init_password(); 
6D7A:  CALL   5D20
....................          fprintf(COM2," exit\n\r");  
6D7E:  MOVLW  A0
6D80:  MOVWF  FF6
6D82:  MOVLW  1C
6D84:  MOVWF  FF7
6D86:  CLRF   19
6D88:  BTFSC  FF2.7
6D8A:  BSF    19.7
6D8C:  BCF    FF2.7
6D8E:  CALL   172E
6D92:  BTFSC  19.7
6D94:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
6D96:  CLRF   FEA
6D98:  MOVLW  41
6D9A:  MOVWF  FE9
6D9C:  MOVLW  00
6D9E:  CALL   03A6
6DA2:  TBLRD*-
6DA4:  TBLRD*+
6DA6:  MOVF   FF5,W
6DA8:  MOVWF  FEE
6DAA:  IORLW  00
6DAC:  BNZ   6DA4
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6DAE:  MOVLW  01
6DB0:  MOVLB  7
6DB2:  MOVWF  xF4
6DB4:  MOVLW  62
6DB6:  MOVWF  xF3
6DB8:  CLRF   xF6
6DBA:  MOVLW  41
6DBC:  MOVWF  xF5
6DBE:  MOVLB  0
6DC0:  CALL   60EA
6DC4:  MOVF   01,F
6DC6:  BNZ   6DE8
....................       { 
....................          keydebug_en=1; 
6DC8:  MOVLW  01
6DCA:  MOVLB  1
6DCC:  MOVWF  x44
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
6DCE:  MOVLW  A8
6DD0:  MOVWF  FF6
6DD2:  MOVLW  1C
6DD4:  MOVWF  FF7
6DD6:  CLRF   19
6DD8:  BTFSC  FF2.7
6DDA:  BSF    19.7
6DDC:  BCF    FF2.7
6DDE:  MOVLB  0
6DE0:  CALL   172E
6DE4:  BTFSC  19.7
6DE6:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
6DE8:  CLRF   FEA
6DEA:  MOVLW  41
6DEC:  MOVWF  FE9
6DEE:  MOVLW  00
6DF0:  CALL   03BC
6DF4:  TBLRD*-
6DF6:  TBLRD*+
6DF8:  MOVF   FF5,W
6DFA:  MOVWF  FEE
6DFC:  IORLW  00
6DFE:  BNZ   6DF6
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6E00:  MOVLW  01
6E02:  MOVLB  7
6E04:  MOVWF  xF4
6E06:  MOVLW  62
6E08:  MOVWF  xF3
6E0A:  CLRF   xF6
6E0C:  MOVLW  41
6E0E:  MOVWF  xF5
6E10:  MOVLB  0
6E12:  CALL   60EA
6E16:  MOVF   01,F
6E18:  BNZ   6E34
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6E1A:  MOVLW  BC
6E1C:  MOVWF  FF6
6E1E:  MOVLW  1C
6E20:  MOVWF  FF7
6E22:  CLRF   19
6E24:  BTFSC  FF2.7
6E26:  BSF    19.7
6E28:  BCF    FF2.7
6E2A:  CALL   172E
6E2E:  BTFSC  19.7
6E30:  BSF    FF2.7
....................          rstfact(); 
6E32:  BRA    6A2A
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
6E34:  CLRF   FEA
6E36:  MOVLW  41
6E38:  MOVWF  FE9
6E3A:  MOVLW  00
6E3C:  CALL   03D4
6E40:  TBLRD*-
6E42:  TBLRD*+
6E44:  MOVF   FF5,W
6E46:  MOVWF  FEE
6E48:  IORLW  00
6E4A:  BNZ   6E42
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6E4C:  MOVLW  01
6E4E:  MOVLB  7
6E50:  MOVWF  xF4
6E52:  MOVLW  62
6E54:  MOVWF  xF3
6E56:  CLRF   xF6
6E58:  MOVLW  41
6E5A:  MOVWF  xF5
6E5C:  MOVLB  0
6E5E:  CALL   60EA
6E62:  MOVF   01,F
6E64:  BNZ   6E8C
....................       { 
....................          mode=LOGOFF; 
6E66:  MOVLB  6
6E68:  CLRF   xDC
....................          keydebug_en=0; 
6E6A:  MOVLB  1
6E6C:  CLRF   x44
....................          set_tris_a(0xff); 
6E6E:  MOVLW  FF
6E70:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
6E72:  MOVLW  CC
6E74:  MOVWF  FF6
6E76:  MOVLW  1C
6E78:  MOVWF  FF7
6E7A:  CLRF   19
6E7C:  BTFSC  FF2.7
6E7E:  BSF    19.7
6E80:  BCF    FF2.7
6E82:  MOVLB  0
6E84:  CALL   172E
6E88:  BTFSC  19.7
6E8A:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
6E8C:  CLRF   FEA
6E8E:  MOVLW  41
6E90:  MOVWF  FE9
6E92:  MOVLW  00
6E94:  CALL   03E6
6E98:  TBLRD*-
6E9A:  TBLRD*+
6E9C:  MOVF   FF5,W
6E9E:  MOVWF  FEE
6EA0:  IORLW  00
6EA2:  BNZ   6E9A
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6EA4:  MOVLW  01
6EA6:  MOVLB  7
6EA8:  MOVWF  xF4
6EAA:  MOVLW  62
6EAC:  MOVWF  xF3
6EAE:  CLRF   xF6
6EB0:  MOVLW  41
6EB2:  MOVWF  xF5
6EB4:  MOVLB  0
6EB6:  CALL   60EA
6EBA:  MOVF   01,F
6EBC:  BNZ   6F36
....................       { 
....................          fprintf(COM2,"New console name>"); 
6EBE:  MOVLW  D4
6EC0:  MOVWF  FF6
6EC2:  MOVLW  1C
6EC4:  MOVWF  FF7
6EC6:  CLRF   19
6EC8:  BTFSC  FF2.7
6ECA:  BSF    19.7
6ECC:  BCF    FF2.7
6ECE:  CALL   172E
6ED2:  BTFSC  19.7
6ED4:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,wide_strobe_nameconsole, console); 
6ED6:  MOVLW  01
6ED8:  MOVLB  7
6EDA:  MOVWF  xF3
6EDC:  MOVLW  10
6EDE:  MOVWF  xF4
6EE0:  MOVLW  06
6EE2:  MOVWF  xF6
6EE4:  MOVLW  E7
6EE6:  MOVWF  xF5
6EE8:  MOVLB  0
6EEA:  CALL   5FB2
6EEE:  CLRF   19
6EF0:  BTFSC  FF2.7
6EF2:  BSF    19.7
6EF4:  BCF    FF2.7
....................          EEPROM_write(strobe_nameconsole,wide_strobe_nameconsole,console); 
6EF6:  MOVLB  9
6EF8:  CLRF   x03
6EFA:  CLRF   x02
6EFC:  CLRF   x01
6EFE:  MOVLW  28
6F00:  MOVWF  x00
6F02:  CLRF   x07
6F04:  CLRF   x06
6F06:  CLRF   x05
6F08:  MOVLW  10
6F0A:  MOVWF  x04
6F0C:  MOVLW  06
6F0E:  MOVWF  x09
6F10:  MOVLW  E7
6F12:  MOVWF  x08
6F14:  MOVLB  0
6F16:  CALL   4EF6
6F1A:  BTFSC  19.7
6F1C:  BSF    FF2.7
....................          fprintf(COM2," OK\n\r"); 
6F1E:  MOVLW  E6
6F20:  MOVWF  FF6
6F22:  MOVLW  1C
6F24:  MOVWF  FF7
6F26:  CLRF   19
6F28:  BTFSC  FF2.7
6F2A:  BSF    19.7
6F2C:  BCF    FF2.7
6F2E:  CALL   172E
6F32:  BTFSC  19.7
6F34:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
6F36:  CLRF   FEA
6F38:  MOVLW  41
6F3A:  MOVWF  FE9
6F3C:  MOVLW  00
6F3E:  CALL   03F8
6F42:  TBLRD*-
6F44:  TBLRD*+
6F46:  MOVF   FF5,W
6F48:  MOVWF  FEE
6F4A:  IORLW  00
6F4C:  BNZ   6F44
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6F4E:  MOVLW  01
6F50:  MOVLB  7
6F52:  MOVWF  xF4
6F54:  MOVLW  62
6F56:  MOVWF  xF3
6F58:  CLRF   xF6
6F5A:  MOVLW  41
6F5C:  MOVWF  xF5
6F5E:  MOVLB  0
6F60:  CALL   60EA
6F64:  MOVF   01,F
6F66:  BTFSS  FD8.2
6F68:  BRA    710A
6F6A:  CLRF   19
6F6C:  BTFSC  FF2.7
6F6E:  BSF    19.7
6F70:  BCF    FF2.7
....................       { 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6F72:  MOVLB  9
6F74:  CLRF   x1B
6F76:  CLRF   x1A
6F78:  CLRF   x19
6F7A:  MOVLW  3A
6F7C:  MOVWF  x18
6F7E:  MOVLB  0
6F80:  CALL   3450
6F84:  BTFSC  19.7
6F86:  BSF    FF2.7
6F88:  MOVFF  01,6E2
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6F8C:  MOVLB  6
6F8E:  MOVF   xE2,F
6F90:  BNZ   6FB0
6F92:  MOVLW  EC
6F94:  MOVWF  FF6
6F96:  MOVLW  1C
6F98:  MOVWF  FF7
6F9A:  CLRF   19
6F9C:  BTFSC  FF2.7
6F9E:  BSF    19.7
6FA0:  BCF    FF2.7
6FA2:  MOVLB  0
6FA4:  CALL   172E
6FA8:  BTFSC  19.7
6FAA:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6FAC:  BRA    6FCA
6FAE:  MOVLB  6
6FB0:  MOVLW  F0
6FB2:  MOVWF  FF6
6FB4:  MOVLW  1C
6FB6:  MOVWF  FF7
6FB8:  CLRF   19
6FBA:  BTFSC  FF2.7
6FBC:  BSF    19.7
6FBE:  BCF    FF2.7
6FC0:  MOVLB  0
6FC2:  CALL   172E
6FC6:  BTFSC  19.7
6FC8:  BSF    FF2.7
6FCA:  CLRF   19
6FCC:  BTFSC  FF2.7
6FCE:  BSF    19.7
6FD0:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
6FD2:  MOVLB  9
6FD4:  CLRF   x1B
6FD6:  CLRF   x1A
6FD8:  CLRF   x19
6FDA:  MOVLW  3C
6FDC:  MOVWF  x18
6FDE:  MOVLB  0
6FE0:  CALL   3450
6FE4:  BTFSC  19.7
6FE6:  BSF    FF2.7
6FE8:  MOVFF  01,15A
6FEC:  CLRF   19
6FEE:  BTFSC  FF2.7
6FF0:  BSF    19.7
6FF2:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
6FF4:  MOVLW  5B
6FF6:  MOVLB  9
6FF8:  MOVWF  x0C
6FFA:  MOVLB  0
6FFC:  CALL   1604
7000:  BTFSC  19.7
7002:  BSF    FF2.7
7004:  MOVFF  15A,7F3
7008:  MOVLW  1B
700A:  MOVLB  7
700C:  MOVWF  xF4
700E:  MOVLB  0
7010:  BRA    6A94
7012:  CLRF   19
7014:  BTFSC  FF2.7
7016:  BSF    19.7
7018:  BCF    FF2.7
701A:  MOVLW  5D
701C:  MOVLB  9
701E:  MOVWF  x0C
7020:  MOVLB  0
7022:  CALL   1604
7026:  BTFSC  19.7
7028:  BSF    FF2.7
....................           
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
702A:  MOVFF  1CB,82B
702E:  MOVLW  01
7030:  MOVLB  8
7032:  MOVWF  x2C
7034:  MOVLB  0
7036:  CALL   6182
703A:  CLRF   19
703C:  BTFSC  FF2.7
703E:  BSF    19.7
7040:  BCF    FF2.7
7042:  MOVLW  2F
7044:  MOVLB  9
7046:  MOVWF  x0C
7048:  MOVLB  0
704A:  CALL   1604
704E:  BTFSC  19.7
7050:  BSF    FF2.7
7052:  MOVFF  1CA,82B
7056:  MOVLW  01
7058:  MOVLB  8
705A:  MOVWF  x2C
705C:  MOVLB  0
705E:  CALL   6182
7062:  CLRF   19
7064:  BTFSC  FF2.7
7066:  BSF    19.7
7068:  BCF    FF2.7
706A:  MOVLW  20
706C:  MOVLB  9
706E:  MOVWF  x0C
7070:  MOVLB  0
7072:  CALL   1604
7076:  BTFSC  19.7
7078:  BSF    FF2.7
707A:  MOVFF  1CC,82B
707E:  MOVLW  01
7080:  MOVLB  8
7082:  MOVWF  x2C
7084:  MOVLB  0
7086:  CALL   6182
708A:  CLRF   19
708C:  BTFSC  FF2.7
708E:  BSF    19.7
7090:  BCF    FF2.7
7092:  MOVLW  3A
7094:  MOVLB  9
7096:  MOVWF  x0C
7098:  MOVLB  0
709A:  CALL   1604
709E:  BTFSC  19.7
70A0:  BSF    FF2.7
70A2:  MOVFF  1CD,82B
70A6:  MOVLW  01
70A8:  MOVLB  8
70AA:  MOVWF  x2C
70AC:  MOVLB  0
70AE:  CALL   6182
70B2:  CLRF   19
70B4:  BTFSC  FF2.7
70B6:  BSF    19.7
70B8:  BCF    FF2.7
70BA:  MOVLW  3A
70BC:  MOVLB  9
70BE:  MOVWF  x0C
70C0:  MOVLB  0
70C2:  CALL   1604
70C6:  BTFSC  19.7
70C8:  BSF    FF2.7
70CA:  MOVFF  1CE,82B
70CE:  MOVLW  01
70D0:  MOVLB  8
70D2:  MOVWF  x2C
70D4:  MOVLB  0
70D6:  CALL   6182
70DA:  CLRF   19
70DC:  BTFSC  FF2.7
70DE:  BSF    19.7
70E0:  BCF    FF2.7
....................           
....................          fprintf(COM2,"\n\r"); 
70E2:  MOVLW  0A
70E4:  MOVLB  9
70E6:  MOVWF  x0C
70E8:  MOVLB  0
70EA:  CALL   1604
70EE:  BTFSC  19.7
70F0:  BSF    FF2.7
70F2:  CLRF   19
70F4:  BTFSC  FF2.7
70F6:  BSF    19.7
70F8:  BCF    FF2.7
70FA:  MOVLW  0D
70FC:  MOVLB  9
70FE:  MOVWF  x0C
7100:  MOVLB  0
7102:  CALL   1604
7106:  BTFSC  19.7
7108:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
710A:  CLRF   FEA
710C:  MOVLW  41
710E:  MOVWF  FE9
7110:  MOVLW  00
7112:  CALL   040A
7116:  TBLRD*-
7118:  TBLRD*+
711A:  MOVF   FF5,W
711C:  MOVWF  FEE
711E:  IORLW  00
7120:  BNZ   7118
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7122:  MOVLW  01
7124:  MOVLB  7
7126:  MOVWF  xF4
7128:  MOVLW  62
712A:  MOVWF  xF3
712C:  CLRF   xF6
712E:  MOVLW  41
7130:  MOVWF  xF5
7132:  MOVLB  0
7134:  CALL   60EA
7138:  MOVF   01,F
713A:  BTFSS  FD8.2
713C:  BRA    733C
....................       { 
....................          fprintf(COM2,"Year>"); 
713E:  MOVLW  F4
7140:  MOVWF  FF6
7142:  MOVLW  1C
7144:  MOVWF  FF7
7146:  CLRF   19
7148:  BTFSC  FF2.7
714A:  BSF    19.7
714C:  BCF    FF2.7
714E:  CALL   172E
7152:  BTFSC  19.7
7154:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7156:  MOVLW  01
7158:  MOVLB  7
715A:  MOVWF  xF3
715C:  MOVLW  03
715E:  MOVWF  xF4
7160:  MOVLW  07
7162:  MOVWF  xF6
7164:  MOVLW  C1
7166:  MOVWF  xF5
7168:  MOVLB  0
716A:  CALL   5FB2
....................          year=(unsigned int8)strtoi(temp); 
716E:  MOVLW  07
7170:  MOVLB  7
7172:  MOVWF  xF4
7174:  MOVLW  C1
7176:  MOVWF  xF3
7178:  MOVLB  0
717A:  RCALL  6B5A
717C:  MOVFF  01,1C9
....................          fprintf(COM2,"Month>"); 
7180:  MOVLW  FA
7182:  MOVWF  FF6
7184:  MOVLW  1C
7186:  MOVWF  FF7
7188:  CLRF   19
718A:  BTFSC  FF2.7
718C:  BSF    19.7
718E:  BCF    FF2.7
7190:  CALL   172E
7194:  BTFSC  19.7
7196:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7198:  MOVLW  01
719A:  MOVLB  7
719C:  MOVWF  xF3
719E:  MOVLW  03
71A0:  MOVWF  xF4
71A2:  MOVLW  07
71A4:  MOVWF  xF6
71A6:  MOVLW  C1
71A8:  MOVWF  xF5
71AA:  MOVLB  0
71AC:  CALL   5FB2
....................          mon=(unsigned int8)strtoi(temp); 
71B0:  MOVLW  07
71B2:  MOVLB  7
71B4:  MOVWF  xF4
71B6:  MOVLW  C1
71B8:  MOVWF  xF3
71BA:  MOVLB  0
71BC:  RCALL  6B5A
71BE:  MOVFF  01,1CA
....................          fprintf(COM2,"Date>"); 
71C2:  MOVLW  02
71C4:  MOVWF  FF6
71C6:  MOVLW  1D
71C8:  MOVWF  FF7
71CA:  CLRF   19
71CC:  BTFSC  FF2.7
71CE:  BSF    19.7
71D0:  BCF    FF2.7
71D2:  CALL   172E
71D6:  BTFSC  19.7
71D8:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
71DA:  MOVLW  01
71DC:  MOVLB  7
71DE:  MOVWF  xF3
71E0:  MOVLW  03
71E2:  MOVWF  xF4
71E4:  MOVLW  07
71E6:  MOVWF  xF6
71E8:  MOVLW  C1
71EA:  MOVWF  xF5
71EC:  MOVLB  0
71EE:  CALL   5FB2
....................          date = (unsigned int8)strtoi(temp); 
71F2:  MOVLW  07
71F4:  MOVLB  7
71F6:  MOVWF  xF4
71F8:  MOVLW  C1
71FA:  MOVWF  xF3
71FC:  MOVLB  0
71FE:  RCALL  6B5A
7200:  MOVFF  01,1CB
....................          fprintf(COM2,"Day>"); 
7204:  MOVLW  08
7206:  MOVWF  FF6
7208:  MOVLW  1D
720A:  MOVWF  FF7
720C:  CLRF   19
720E:  BTFSC  FF2.7
7210:  BSF    19.7
7212:  BCF    FF2.7
7214:  CALL   172E
7218:  BTFSC  19.7
721A:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
721C:  MOVLW  01
721E:  MOVLB  7
7220:  MOVWF  xF3
7222:  MOVLW  03
7224:  MOVWF  xF4
7226:  MOVLW  07
7228:  MOVWF  xF6
722A:  MOVLW  C1
722C:  MOVWF  xF5
722E:  MOVLB  0
7230:  CALL   5FB2
....................          day = (unsigned int8)strtoi(temp); 
7234:  MOVLW  07
7236:  MOVLB  7
7238:  MOVWF  xF4
723A:  MOVLW  C1
723C:  MOVWF  xF3
723E:  MOVLB  0
7240:  RCALL  6B5A
7242:  MOVFF  01,1C8
....................          fprintf(COM2,"Hour>"); 
7246:  MOVLW  0E
7248:  MOVWF  FF6
724A:  MOVLW  1D
724C:  MOVWF  FF7
724E:  CLRF   19
7250:  BTFSC  FF2.7
7252:  BSF    19.7
7254:  BCF    FF2.7
7256:  CALL   172E
725A:  BTFSC  19.7
725C:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
725E:  MOVLW  01
7260:  MOVLB  7
7262:  MOVWF  xF3
7264:  MOVLW  03
7266:  MOVWF  xF4
7268:  MOVLW  07
726A:  MOVWF  xF6
726C:  MOVLW  C1
726E:  MOVWF  xF5
7270:  MOVLB  0
7272:  CALL   5FB2
....................          h = (unsigned int8)strtoi(temp); 
7276:  MOVLW  07
7278:  MOVLB  7
727A:  MOVWF  xF4
727C:  MOVLW  C1
727E:  MOVWF  xF3
7280:  MOVLB  0
7282:  RCALL  6B5A
7284:  MOVFF  01,1CC
....................          fprintf(COM2,"Minutes>"); 
7288:  MOVLW  14
728A:  MOVWF  FF6
728C:  MOVLW  1D
728E:  MOVWF  FF7
7290:  CLRF   19
7292:  BTFSC  FF2.7
7294:  BSF    19.7
7296:  BCF    FF2.7
7298:  CALL   172E
729C:  BTFSC  19.7
729E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
72A0:  MOVLW  01
72A2:  MOVLB  7
72A4:  MOVWF  xF3
72A6:  MOVLW  03
72A8:  MOVWF  xF4
72AA:  MOVLW  07
72AC:  MOVWF  xF6
72AE:  MOVLW  C1
72B0:  MOVWF  xF5
72B2:  MOVLB  0
72B4:  CALL   5FB2
....................          min = (unsigned int8)strtoi(temp);                   
72B8:  MOVLW  07
72BA:  MOVLB  7
72BC:  MOVWF  xF4
72BE:  MOVLW  C1
72C0:  MOVWF  xF3
72C2:  MOVLB  0
72C4:  RCALL  6B5A
72C6:  MOVFF  01,1CD
....................          fprintf(COM2,"Seconds>"); 
72CA:  MOVLW  1E
72CC:  MOVWF  FF6
72CE:  MOVLW  1D
72D0:  MOVWF  FF7
72D2:  CLRF   19
72D4:  BTFSC  FF2.7
72D6:  BSF    19.7
72D8:  BCF    FF2.7
72DA:  CALL   172E
72DE:  BTFSC  19.7
72E0:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
72E2:  MOVLW  01
72E4:  MOVLB  7
72E6:  MOVWF  xF3
72E8:  MOVLW  03
72EA:  MOVWF  xF4
72EC:  MOVLW  07
72EE:  MOVWF  xF6
72F0:  MOVLW  C1
72F2:  MOVWF  xF5
72F4:  MOVLB  0
72F6:  CALL   5FB2
....................          sec = (unsigned int8)strtoi(temp);                   
72FA:  MOVLW  07
72FC:  MOVLB  7
72FE:  MOVWF  xF4
7300:  MOVLW  C1
7302:  MOVWF  xF3
7304:  MOVLB  0
7306:  RCALL  6B5A
7308:  MOVFF  01,1CE
730C:  CLRF   19
730E:  BTFSC  FF2.7
7310:  BSF    19.7
7312:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
7314:  MOVLW  0A
7316:  MOVLB  9
7318:  MOVWF  x0C
731A:  MOVLB  0
731C:  CALL   1604
7320:  BTFSC  19.7
7322:  BSF    FF2.7
7324:  CLRF   19
7326:  BTFSC  FF2.7
7328:  BSF    19.7
732A:  BCF    FF2.7
732C:  MOVLW  0D
732E:  MOVLB  9
7330:  MOVWF  x0C
7332:  MOVLB  0
7334:  CALL   1604
7338:  BTFSC  19.7
733A:  BSF    FF2.7
....................          /* rtc_set_datetime(date,mon,year,day,h,min); */ 
....................       } 
....................       strcpy(buffer2,"MS"); 
733C:  CLRF   FEA
733E:  MOVLW  41
7340:  MOVWF  FE9
7342:  MOVLW  00
7344:  CALL   041E
7348:  TBLRD*-
734A:  TBLRD*+
734C:  MOVF   FF5,W
734E:  MOVWF  FEE
7350:  IORLW  00
7352:  BNZ   734A
....................       if(!stringcomp(buffer_uart,buffer2)) 
7354:  MOVLW  01
7356:  MOVLB  7
7358:  MOVWF  xF4
735A:  MOVLW  62
735C:  MOVWF  xF3
735E:  CLRF   xF6
7360:  MOVLW  41
7362:  MOVWF  xF5
7364:  MOVLB  0
7366:  CALL   60EA
736A:  MOVF   01,F
736C:  BTFSS  FD8.2
736E:  BRA    7482
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
7370:  MOVLW  28
7372:  MOVWF  FF6
7374:  MOVLW  1D
7376:  MOVWF  FF7
7378:  CLRF   19
737A:  BTFSC  FF2.7
737C:  BSF    19.7
737E:  BCF    FF2.7
7380:  CALL   172E
7384:  BTFSC  19.7
7386:  BSF    FF2.7
7388:  CLRF   19
738A:  BTFSC  FF2.7
738C:  BSF    19.7
738E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7390:  MOVLW  0A
7392:  MOVLB  9
7394:  MOVWF  x0C
7396:  MOVLB  0
7398:  CALL   1604
739C:  BTFSC  19.7
739E:  BSF    FF2.7
73A0:  CLRF   19
73A2:  BTFSC  FF2.7
73A4:  BSF    19.7
73A6:  BCF    FF2.7
73A8:  MOVLW  0D
73AA:  MOVLB  9
73AC:  MOVWF  x0C
73AE:  MOVLB  0
73B0:  CALL   1604
73B4:  BTFSC  19.7
73B6:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
73B8:  MOVLW  48
73BA:  MOVWF  FF6
73BC:  MOVLW  1D
73BE:  MOVWF  FF7
73C0:  CLRF   19
73C2:  BTFSC  FF2.7
73C4:  BSF    19.7
73C6:  BCF    FF2.7
73C8:  CALL   172E
73CC:  BTFSC  19.7
73CE:  BSF    FF2.7
73D0:  CLRF   19
73D2:  BTFSC  FF2.7
73D4:  BSF    19.7
73D6:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
73D8:  MOVLW  0A
73DA:  MOVLB  9
73DC:  MOVWF  x0C
73DE:  MOVLB  0
73E0:  CALL   1604
73E4:  BTFSC  19.7
73E6:  BSF    FF2.7
73E8:  CLRF   19
73EA:  BTFSC  FF2.7
73EC:  BSF    19.7
73EE:  BCF    FF2.7
73F0:  MOVLW  0D
73F2:  MOVLB  9
73F4:  MOVWF  x0C
73F6:  MOVLB  0
73F8:  CALL   1604
73FC:  BTFSC  19.7
73FE:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7400:  MOVLW  01
7402:  MOVLB  7
7404:  MOVWF  xF3
7406:  MOVLW  03
7408:  MOVWF  xF4
740A:  MOVLW  07
740C:  MOVWF  xF6
740E:  MOVLW  C1
7410:  MOVWF  xF5
7412:  MOVLB  0
7414:  CALL   5FB2
....................           mode_sl = (unsigned int8)strtoi(temp); 
7418:  MOVLW  07
741A:  MOVLB  7
741C:  MOVWF  xF4
741E:  MOVLW  C1
7420:  MOVWF  xF3
7422:  MOVLB  0
7424:  CALL   6B5A
7428:  MOVFF  01,6E2
742C:  CLRF   19
742E:  BTFSC  FF2.7
7430:  BSF    19.7
7432:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
7434:  MOVLB  9
7436:  CLRF   x16
7438:  CLRF   x15
743A:  CLRF   x14
743C:  MOVLW  3A
743E:  MOVWF  x13
7440:  MOVFF  6E2,917
7444:  MOVLB  0
7446:  CALL   3A6C
744A:  BTFSC  19.7
744C:  BSF    FF2.7
....................           set_tris_a(0xff); 
744E:  MOVLW  FF
7450:  MOVWF  F92
7452:  CLRF   19
7454:  BTFSC  FF2.7
7456:  BSF    19.7
7458:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
745A:  MOVLW  0A
745C:  MOVLB  9
745E:  MOVWF  x0C
7460:  MOVLB  0
7462:  CALL   1604
7466:  BTFSC  19.7
7468:  BSF    FF2.7
746A:  CLRF   19
746C:  BTFSC  FF2.7
746E:  BSF    19.7
7470:  BCF    FF2.7
7472:  MOVLW  0D
7474:  MOVLB  9
7476:  MOVWF  x0C
7478:  MOVLB  0
747A:  CALL   1604
747E:  BTFSC  19.7
7480:  BSF    FF2.7
....................       } 
....................       
....................       strcpy(buffer2,"tran time"); 
7482:  CLRF   FEA
7484:  MOVLW  41
7486:  MOVWF  FE9
7488:  MOVLW  00
748A:  CALL   0432
748E:  TBLRD*-
7490:  TBLRD*+
7492:  MOVF   FF5,W
7494:  MOVWF  FEE
7496:  IORLW  00
7498:  BNZ   7490
....................       if(!stringcomp(buffer_uart,buffer2)) 
749A:  MOVLW  01
749C:  MOVLB  7
749E:  MOVWF  xF4
74A0:  MOVLW  62
74A2:  MOVWF  xF3
74A4:  CLRF   xF6
74A6:  MOVLW  41
74A8:  MOVWF  xF5
74AA:  MOVLB  0
74AC:  CALL   60EA
74B0:  MOVF   01,F
74B2:  BNZ   757A
....................       { 
....................           fprintf(COM2,"Input Number"); 
74B4:  MOVLW  68
74B6:  MOVWF  FF6
74B8:  MOVLW  1D
74BA:  MOVWF  FF7
74BC:  CLRF   19
74BE:  BTFSC  FF2.7
74C0:  BSF    19.7
74C2:  BCF    FF2.7
74C4:  CALL   172E
74C8:  BTFSC  19.7
74CA:  BSF    FF2.7
74CC:  CLRF   19
74CE:  BTFSC  FF2.7
74D0:  BSF    19.7
74D2:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
74D4:  MOVLW  0A
74D6:  MOVLB  9
74D8:  MOVWF  x0C
74DA:  MOVLB  0
74DC:  CALL   1604
74E0:  BTFSC  19.7
74E2:  BSF    FF2.7
74E4:  CLRF   19
74E6:  BTFSC  FF2.7
74E8:  BSF    19.7
74EA:  BCF    FF2.7
74EC:  MOVLW  0D
74EE:  MOVLB  9
74F0:  MOVWF  x0C
74F2:  MOVLB  0
74F4:  CALL   1604
74F8:  BTFSC  19.7
74FA:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
74FC:  MOVLW  01
74FE:  MOVLB  7
7500:  MOVWF  xF3
7502:  MOVLW  03
7504:  MOVWF  xF4
7506:  MOVLW  07
7508:  MOVWF  xF6
750A:  MOVLW  C1
750C:  MOVWF  xF5
750E:  MOVLB  0
7510:  CALL   5FB2
....................           delaycharaction = (unsigned int8)strtoi(temp); 
7514:  MOVLW  07
7516:  MOVLB  7
7518:  MOVWF  xF4
751A:  MOVLW  C1
751C:  MOVWF  xF3
751E:  MOVLB  0
7520:  CALL   6B5A
7524:  MOVFF  01,15A
7528:  CLRF   19
752A:  BTFSC  FF2.7
752C:  BSF    19.7
752E:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
7530:  MOVLB  9
7532:  CLRF   x16
7534:  CLRF   x15
7536:  CLRF   x14
7538:  MOVLW  3C
753A:  MOVWF  x13
753C:  MOVFF  15A,917
7540:  MOVLB  0
7542:  CALL   3A6C
7546:  BTFSC  19.7
7548:  BSF    FF2.7
754A:  CLRF   19
754C:  BTFSC  FF2.7
754E:  BSF    19.7
7550:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7552:  MOVLW  0A
7554:  MOVLB  9
7556:  MOVWF  x0C
7558:  MOVLB  0
755A:  CALL   1604
755E:  BTFSC  19.7
7560:  BSF    FF2.7
7562:  CLRF   19
7564:  BTFSC  FF2.7
7566:  BSF    19.7
7568:  BCF    FF2.7
756A:  MOVLW  0D
756C:  MOVLB  9
756E:  MOVWF  x0C
7570:  MOVLB  0
7572:  CALL   1604
7576:  BTFSC  19.7
7578:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
757A:  CLRF   FEA
757C:  MOVLW  41
757E:  MOVWF  FE9
7580:  MOVLW  00
7582:  CALL   044C
7586:  TBLRD*-
7588:  TBLRD*+
758A:  MOVF   FF5,W
758C:  MOVWF  FEE
758E:  IORLW  00
7590:  BNZ   7588
....................       if(!stringcomp(buffer_uart,buffer2)) 
7592:  MOVLW  01
7594:  MOVLB  7
7596:  MOVWF  xF4
7598:  MOVLW  62
759A:  MOVWF  xF3
759C:  CLRF   xF6
759E:  MOVLW  41
75A0:  MOVWF  xF5
75A2:  MOVLB  0
75A4:  CALL   60EA
75A8:  MOVF   01,F
75AA:  BTFSS  FD8.2
75AC:  BRA    76BC
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
75AE:  MOVLW  76
75B0:  MOVWF  FF6
75B2:  MOVLW  1D
75B4:  MOVWF  FF7
75B6:  CLRF   19
75B8:  BTFSC  FF2.7
75BA:  BSF    19.7
75BC:  BCF    FF2.7
75BE:  CALL   172E
75C2:  BTFSC  19.7
75C4:  BSF    FF2.7
75C6:  CLRF   19
75C8:  BTFSC  FF2.7
75CA:  BSF    19.7
75CC:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
75CE:  MOVLW  0A
75D0:  MOVLB  9
75D2:  MOVWF  x0C
75D4:  MOVLB  0
75D6:  CALL   1604
75DA:  BTFSC  19.7
75DC:  BSF    FF2.7
75DE:  CLRF   19
75E0:  BTFSC  FF2.7
75E2:  BSF    19.7
75E4:  BCF    FF2.7
75E6:  MOVLW  0D
75E8:  MOVLB  9
75EA:  MOVWF  x0C
75EC:  MOVLB  0
75EE:  CALL   1604
75F2:  BTFSC  19.7
75F4:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
75F6:  MOVLW  9C
75F8:  MOVWF  FF6
75FA:  MOVLW  1D
75FC:  MOVWF  FF7
75FE:  CLRF   19
7600:  BTFSC  FF2.7
7602:  BSF    19.7
7604:  BCF    FF2.7
7606:  CALL   172E
760A:  BTFSC  19.7
760C:  BSF    FF2.7
760E:  CLRF   19
7610:  BTFSC  FF2.7
7612:  BSF    19.7
7614:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7616:  MOVLW  0A
7618:  MOVLB  9
761A:  MOVWF  x0C
761C:  MOVLB  0
761E:  CALL   1604
7622:  BTFSC  19.7
7624:  BSF    FF2.7
7626:  CLRF   19
7628:  BTFSC  FF2.7
762A:  BSF    19.7
762C:  BCF    FF2.7
762E:  MOVLW  0D
7630:  MOVLB  9
7632:  MOVWF  x0C
7634:  MOVLB  0
7636:  CALL   1604
763A:  BTFSC  19.7
763C:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
763E:  MOVLW  01
7640:  MOVLB  7
7642:  MOVWF  xF3
7644:  MOVLW  03
7646:  MOVWF  xF4
7648:  MOVLW  07
764A:  MOVWF  xF6
764C:  MOVLW  C1
764E:  MOVWF  xF5
7650:  MOVLB  0
7652:  CALL   5FB2
....................           type_KB=(unsigned int8)strtoi(temp); 
7656:  MOVLW  07
7658:  MOVLB  7
765A:  MOVWF  xF4
765C:  MOVLW  C1
765E:  MOVWF  xF3
7660:  MOVLB  0
7662:  CALL   6B5A
7666:  MOVFF  01,149
766A:  CLRF   19
766C:  BTFSC  FF2.7
766E:  BSF    19.7
7670:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
7672:  MOVLB  9
7674:  CLRF   x16
7676:  CLRF   x15
7678:  CLRF   x14
767A:  MOVLW  3D
767C:  MOVWF  x13
767E:  MOVFF  149,917
7682:  MOVLB  0
7684:  CALL   3A6C
7688:  BTFSC  19.7
768A:  BSF    FF2.7
768C:  CLRF   19
768E:  BTFSC  FF2.7
7690:  BSF    19.7
7692:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
7694:  MOVLW  0A
7696:  MOVLB  9
7698:  MOVWF  x0C
769A:  MOVLB  0
769C:  CALL   1604
76A0:  BTFSC  19.7
76A2:  BSF    FF2.7
76A4:  CLRF   19
76A6:  BTFSC  FF2.7
76A8:  BSF    19.7
76AA:  BCF    FF2.7
76AC:  MOVLW  0D
76AE:  MOVLB  9
76B0:  MOVWF  x0C
76B2:  MOVLB  0
76B4:  CALL   1604
76B8:  BTFSC  19.7
76BA:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       strcpy(buffer2,"h"); 
76BC:  CLRF   FEA
76BE:  MOVLW  41
76C0:  MOVWF  FE9
76C2:  MOVLW  00
76C4:  CALL   0462
76C8:  TBLRD*-
76CA:  TBLRD*+
76CC:  MOVF   FF5,W
76CE:  MOVWF  FEE
76D0:  IORLW  00
76D2:  BNZ   76CA
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
76D4:  MOVLW  01
76D6:  MOVLB  7
76D8:  MOVWF  xF4
76DA:  MOVLW  62
76DC:  MOVWF  xF3
76DE:  CLRF   xF6
76E0:  MOVLW  41
76E2:  MOVWF  xF5
76E4:  MOVLB  0
76E6:  CALL   60EA
76EA:  MOVF   01,F
76EC:  BTFSS  FD8.2
76EE:  BRA    785E
....................       { 
....................          printf("h-> Help\n\r"); 
76F0:  MOVLW  C2
76F2:  MOVWF  FF6
76F4:  MOVLW  1D
76F6:  MOVWF  FF7
76F8:  CLRF   19
76FA:  BTFSC  FF2.7
76FC:  BSF    19.7
76FE:  BCF    FF2.7
7700:  CALL   172E
7704:  BTFSC  19.7
7706:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
7708:  MOVLW  CE
770A:  MOVWF  FF6
770C:  MOVLW  1D
770E:  MOVWF  FF7
7710:  CLRF   19
7712:  BTFSC  FF2.7
7714:  BSF    19.7
7716:  BCF    FF2.7
7718:  CALL   172E
771C:  BTFSC  19.7
771E:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
7720:  MOVLW  E0
7722:  MOVWF  FF6
7724:  MOVLW  1D
7726:  MOVWF  FF7
7728:  CLRF   19
772A:  BTFSC  FF2.7
772C:  BSF    19.7
772E:  BCF    FF2.7
7730:  CALL   172E
7734:  BTFSC  19.7
7736:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
7738:  MOVLW  F2
773A:  MOVWF  FF6
773C:  MOVLW  1D
773E:  MOVWF  FF7
7740:  CLRF   19
7742:  BTFSC  FF2.7
7744:  BSF    19.7
7746:  BCF    FF2.7
7748:  CALL   172E
774C:  BTFSC  19.7
774E:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
7750:  MOVLW  12
7752:  MOVWF  FF6
7754:  MOVLW  1E
7756:  MOVWF  FF7
7758:  CLRF   19
775A:  BTFSC  FF2.7
775C:  BSF    19.7
775E:  BCF    FF2.7
7760:  CALL   172E
7764:  BTFSC  19.7
7766:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
7768:  MOVLW  2E
776A:  MOVWF  FF6
776C:  MOVLW  1E
776E:  MOVWF  FF7
7770:  CLRF   19
7772:  BTFSC  FF2.7
7774:  BSF    19.7
7776:  BCF    FF2.7
7778:  CALL   172E
777C:  BTFSC  19.7
777E:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
7780:  MOVLW  3C
7782:  MOVWF  FF6
7784:  MOVLW  1E
7786:  MOVWF  FF7
7788:  CLRF   19
778A:  BTFSC  FF2.7
778C:  BSF    19.7
778E:  BCF    FF2.7
7790:  CALL   172E
7794:  BTFSC  19.7
7796:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
7798:  MOVLW  48
779A:  MOVWF  FF6
779C:  MOVLW  1E
779E:  MOVWF  FF7
77A0:  CLRF   19
77A2:  BTFSC  FF2.7
77A4:  BSF    19.7
77A6:  BCF    FF2.7
77A8:  CALL   172E
77AC:  BTFSC  19.7
77AE:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
77B0:  MOVLW  70
77B2:  MOVWF  FF6
77B4:  MOVLW  1E
77B6:  MOVWF  FF7
77B8:  CLRF   19
77BA:  BTFSC  FF2.7
77BC:  BSF    19.7
77BE:  BCF    FF2.7
77C0:  CALL   172E
77C4:  BTFSC  19.7
77C6:  BSF    FF2.7
77C8:  CLRF   19
77CA:  BTFSC  FF2.7
77CC:  BSF    19.7
77CE:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
77D0:  MOVLB  9
77D2:  CLRF   x1B
77D4:  CLRF   x1A
77D6:  CLRF   x19
77D8:  MOVLW  3D
77DA:  MOVWF  x18
77DC:  MOVLB  0
77DE:  CALL   3450
77E2:  BTFSC  19.7
77E4:  BSF    FF2.7
77E6:  MOVFF  01,7F3
77EA:  MOVLW  8C
77EC:  MOVWF  FF6
77EE:  MOVLW  1E
77F0:  MOVWF  FF7
77F2:  CLRF   19
77F4:  BTFSC  FF2.7
77F6:  BSF    19.7
77F8:  BCF    FF2.7
77FA:  MOVLW  06
77FC:  MOVLB  8
77FE:  MOVWF  xF7
7800:  MOVLB  0
7802:  CALL   164A
7806:  BTFSC  19.7
7808:  BSF    FF2.7
780A:  CLRF   19
780C:  BTFSC  FF2.7
780E:  BSF    19.7
7810:  BCF    FF2.7
7812:  MOVFF  7F3,859
7816:  MOVLW  18
7818:  MOVLB  8
781A:  MOVWF  x5A
781C:  MOVLB  0
781E:  CALL   177A
7822:  BTFSC  19.7
7824:  BSF    FF2.7
7826:  MOVLW  94
7828:  MOVWF  FF6
782A:  MOVLW  1E
782C:  MOVWF  FF7
782E:  CLRF   19
7830:  BTFSC  FF2.7
7832:  BSF    19.7
7834:  BCF    FF2.7
7836:  MOVLW  1D
7838:  MOVLB  8
783A:  MOVWF  xF7
783C:  MOVLB  0
783E:  CALL   164A
7842:  BTFSC  19.7
7844:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
7846:  MOVLW  B2
7848:  MOVWF  FF6
784A:  MOVLW  1E
784C:  MOVWF  FF7
784E:  CLRF   19
7850:  BTFSC  FF2.7
7852:  BSF    19.7
7854:  BCF    FF2.7
7856:  CALL   172E
785A:  BTFSC  19.7
785C:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................       } 
....................       strcpy(buffer2,"password"); 
785E:  CLRF   FEA
7860:  MOVLW  41
7862:  MOVWF  FE9
7864:  MOVLW  00
7866:  CALL   0474
786A:  TBLRD*-
786C:  TBLRD*+
786E:  MOVF   FF5,W
7870:  MOVWF  FEE
7872:  IORLW  00
7874:  BNZ   786C
....................       if(!stringcomp(buffer_uart,buffer2))  
7876:  MOVLW  01
7878:  MOVLB  7
787A:  MOVWF  xF4
787C:  MOVLW  62
787E:  MOVWF  xF3
7880:  CLRF   xF6
7882:  MOVLW  41
7884:  MOVWF  xF5
7886:  MOVLB  0
7888:  CALL   60EA
788C:  MOVF   01,F
788E:  BTFSS  FD8.2
7890:  BRA    79F0
....................       { 
....................          fprintf(COM2,"old password:"); 
7892:  MOVLW  CC
7894:  MOVWF  FF6
7896:  MOVLW  1E
7898:  MOVWF  FF7
789A:  CLRF   19
789C:  BTFSC  FF2.7
789E:  BSF    19.7
78A0:  BCF    FF2.7
78A2:  CALL   172E
78A6:  BTFSC  19.7
78A8:  BSF    FF2.7
78AA:  CLRF   19
78AC:  BTFSC  FF2.7
78AE:  BSF    19.7
78B0:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
78B2:  MOVLB  9
78B4:  CLRF   x07
78B6:  CLRF   x06
78B8:  CLRF   x05
78BA:  CLRF   x04
78BC:  CLRF   x0B
78BE:  CLRF   x0A
78C0:  CLRF   x09
78C2:  MOVLW  14
78C4:  MOVWF  x08
78C6:  CLRF   x0D
78C8:  MOVLW  55
78CA:  MOVWF  x0C
78CC:  MOVLB  0
78CE:  CALL   4004
78D2:  BTFSC  19.7
78D4:  BSF    FF2.7
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
78D6:  MOVLW  02
78D8:  MOVLB  7
78DA:  MOVWF  xF3
78DC:  MOVLW  14
78DE:  MOVWF  xF4
78E0:  CLRF   xF6
78E2:  MOVLW  69
78E4:  MOVWF  xF5
78E6:  MOVLB  0
78E8:  CALL   5FB2
....................          if(!stringcomp(entpassword,password)) 
78EC:  MOVLB  7
78EE:  CLRF   xF4
78F0:  MOVLW  69
78F2:  MOVWF  xF3
78F4:  CLRF   xF6
78F6:  MOVLW  55
78F8:  MOVWF  xF5
78FA:  MOVLB  0
78FC:  CALL   60EA
7900:  MOVF   01,F
7902:  BNZ   79D8
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
7904:  MOVLW  DA
7906:  MOVWF  FF6
7908:  MOVLW  1E
790A:  MOVWF  FF7
790C:  CLRF   19
790E:  BTFSC  FF2.7
7910:  BSF    19.7
7912:  BCF    FF2.7
7914:  CALL   172E
7918:  BTFSC  19.7
791A:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
791C:  MOVLW  02
791E:  MOVLB  7
7920:  MOVWF  xF3
7922:  MOVLW  14
7924:  MOVWF  xF4
7926:  CLRF   xF6
7928:  MOVLW  69
792A:  MOVWF  xF5
792C:  MOVLB  0
792E:  CALL   5FB2
....................             fprintf(COM2,"\n\ragain:"); 
7932:  MOVLW  E2
7934:  MOVWF  FF6
7936:  MOVLW  1E
7938:  MOVWF  FF7
793A:  CLRF   19
793C:  BTFSC  FF2.7
793E:  BSF    19.7
7940:  BCF    FF2.7
7942:  CALL   172E
7946:  BTFSC  19.7
7948:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
794A:  MOVLW  02
794C:  MOVLB  7
794E:  MOVWF  xF3
7950:  MOVLW  14
7952:  MOVWF  xF4
7954:  CLRF   xF6
7956:  MOVLW  55
7958:  MOVWF  xF5
795A:  MOVLB  0
795C:  CALL   5FB2
....................             if(!stringcomp(entpassword,password)) 
7960:  MOVLB  7
7962:  CLRF   xF4
7964:  MOVLW  69
7966:  MOVWF  xF3
7968:  CLRF   xF6
796A:  MOVLW  55
796C:  MOVWF  xF5
796E:  MOVLB  0
7970:  CALL   60EA
7974:  MOVF   01,F
7976:  BNZ   79BE
7978:  CLRF   19
797A:  BTFSC  FF2.7
797C:  BSF    19.7
797E:  BCF    FF2.7
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
7980:  MOVLB  9
7982:  CLRF   x03
7984:  CLRF   x02
7986:  CLRF   x01
7988:  CLRF   x00
798A:  CLRF   x07
798C:  CLRF   x06
798E:  CLRF   x05
7990:  MOVLW  14
7992:  MOVWF  x04
7994:  CLRF   x09
7996:  MOVLW  55
7998:  MOVWF  x08
799A:  MOVLB  0
799C:  CALL   4EF6
79A0:  BTFSC  19.7
79A2:  BSF    FF2.7
....................                fprintf(COM2,"\n\rOK\n\r");    
79A4:  MOVLW  EC
79A6:  MOVWF  FF6
79A8:  MOVLW  1E
79AA:  MOVWF  FF7
79AC:  CLRF   19
79AE:  BTFSC  FF2.7
79B0:  BSF    19.7
79B2:  BCF    FF2.7
79B4:  CALL   172E
79B8:  BTFSC  19.7
79BA:  BSF    FF2.7
....................             } 
....................                else 
79BC:  BRA    79D6
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
79BE:  MOVLW  F4
79C0:  MOVWF  FF6
79C2:  MOVLW  1E
79C4:  MOVWF  FF7
79C6:  CLRF   19
79C8:  BTFSC  FF2.7
79CA:  BSF    19.7
79CC:  BCF    FF2.7
79CE:  CALL   172E
79D2:  BTFSC  19.7
79D4:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
79D6:  BRA    79F0
....................             { 
....................                fprintf(COM2," X\n\r"); 
79D8:  MOVLW  FC
79DA:  MOVWF  FF6
79DC:  MOVLW  1E
79DE:  MOVWF  FF7
79E0:  CLRF   19
79E2:  BTFSC  FF2.7
79E4:  BSF    19.7
79E6:  BCF    FF2.7
79E8:  CALL   172E
79EC:  BTFSC  19.7
79EE:  BSF    FF2.7
....................             }    
....................       } 
....................         strcpy(buffer2,"crypto"); 
79F0:  CLRF   FEA
79F2:  MOVLW  41
79F4:  MOVWF  FE9
79F6:  MOVLW  00
79F8:  CALL   048E
79FC:  TBLRD*-
79FE:  TBLRD*+
7A00:  MOVF   FF5,W
7A02:  MOVWF  FEE
7A04:  IORLW  00
7A06:  BNZ   79FE
....................         if(!stringcomp(buffer_uart,buffer2))  
7A08:  MOVLW  01
7A0A:  MOVLB  7
7A0C:  MOVWF  xF4
7A0E:  MOVLW  62
7A10:  MOVWF  xF3
7A12:  CLRF   xF6
7A14:  MOVLW  41
7A16:  MOVWF  xF5
7A18:  MOVLB  0
7A1A:  CALL   60EA
7A1E:  MOVF   01,F
7A20:  BTFSS  FD8.2
7A22:  BRA    7BA2
....................         { 
....................             memset(crypto_key,0,sizeof(crypto_key)); 
7A24:  MOVLW  01
7A26:  MOVWF  FEA
7A28:  MOVWF  FE9
7A2A:  CLRF   00
7A2C:  CLRF   02
7A2E:  MOVLW  21
7A30:  MOVWF  01
7A32:  CALL   359A
....................             fprintf(COM2,"New crypto key>"); 
7A36:  MOVLW  02
7A38:  MOVWF  FF6
7A3A:  MOVLW  1F
7A3C:  MOVWF  FF7
7A3E:  CLRF   19
7A40:  BTFSC  FF2.7
7A42:  BSF    19.7
7A44:  BCF    FF2.7
7A46:  CALL   172E
7A4A:  BTFSC  19.7
7A4C:  BSF    FF2.7
....................             countchar = (int16)USART_getstring(EN_ECHO, CRYPTO_KEY_SIZE, crypto_key); 
7A4E:  MOVLW  01
7A50:  MOVLB  7
7A52:  MOVWF  xF3
7A54:  MOVLW  20
7A56:  MOVWF  xF4
7A58:  MOVLW  01
7A5A:  MOVWF  xF6
7A5C:  MOVWF  xF5
7A5E:  MOVLB  0
7A60:  CALL   5FB2
7A64:  MOVLB  7
7A66:  CLRF   xC0
7A68:  MOVFF  01,7BF
7A6C:  CLRF   19
7A6E:  BTFSC  FF2.7
7A70:  BSF    19.7
7A72:  BCF    FF2.7
....................             EEPROM_write(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
7A74:  MOVLB  9
7A76:  CLRF   x03
7A78:  CLRF   x02
7A7A:  CLRF   x01
7A7C:  MOVLW  3F
7A7E:  MOVWF  x00
7A80:  CLRF   x07
7A82:  CLRF   x06
7A84:  CLRF   x05
7A86:  MOVLW  20
7A88:  MOVWF  x04
7A8A:  MOVLW  01
7A8C:  MOVWF  x09
7A8E:  MOVWF  x08
7A90:  MOVLB  0
7A92:  CALL   4EF6
7A96:  BTFSC  19.7
7A98:  BSF    FF2.7
....................              
....................             if(countchar>2) 
7A9A:  MOVLB  7
7A9C:  MOVF   xC0,F
7A9E:  BNZ   7AA6
7AA0:  MOVF   xBF,W
7AA2:  SUBLW  02
7AA4:  BC    7B64
....................             { 
....................                 cryption_enable = 1; 
7AA6:  MOVLW  01
7AA8:  MOVLB  1
7AAA:  MOVWF  x22
7AAC:  CLRF   19
7AAE:  BTFSC  FF2.7
7AB0:  BSF    19.7
7AB2:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable);                    
7AB4:  MOVLB  9
7AB6:  CLRF   x16
7AB8:  CLRF   x15
7ABA:  CLRF   x14
7ABC:  MOVLW  3E
7ABE:  MOVWF  x13
7AC0:  MOVFF  122,917
7AC4:  MOVLB  0
7AC6:  CALL   3A6C
7ACA:  BTFSC  19.7
7ACC:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rNew crypto key: "); 
7ACE:  MOVLW  12
7AD0:  MOVWF  FF6
7AD2:  MOVLW  1F
7AD4:  MOVWF  FF7
7AD6:  CLRF   19
7AD8:  BTFSC  FF2.7
7ADA:  BSF    19.7
7ADC:  BCF    FF2.7
7ADE:  CALL   172E
7AE2:  BTFSC  19.7
7AE4:  BSF    FF2.7
....................                 for(i=0;i<CRYPTO_KEY_SIZE;i++) 
7AE6:  MOVLB  7
7AE8:  CLRF   xBE
7AEA:  MOVF   xBE,W
7AEC:  SUBLW  1F
7AEE:  BNC   7B30
....................                 { 
....................                     fprintf(COM2,"%c",read_ext_eeprom(strobe_crypto_key+i)); 
7AF0:  MOVLW  3F
7AF2:  ADDWF  xBE,W
7AF4:  MOVWF  xF3
7AF6:  CLRF   19
7AF8:  BTFSC  FF2.7
7AFA:  BSF    19.7
7AFC:  BCF    FF2.7
7AFE:  MOVLB  9
7B00:  CLRF   x1B
7B02:  CLRF   x1A
7B04:  CLRF   x19
7B06:  MOVWF  x18
7B08:  MOVLB  0
7B0A:  CALL   3450
7B0E:  BTFSC  19.7
7B10:  BSF    FF2.7
7B12:  MOVFF  01,7F3
7B16:  CLRF   19
7B18:  BTFSC  FF2.7
7B1A:  BSF    19.7
7B1C:  BCF    FF2.7
7B1E:  MOVFF  01,90C
7B22:  CALL   1604
7B26:  BTFSC  19.7
7B28:  BSF    FF2.7
....................                 } 
7B2A:  MOVLB  7
7B2C:  INCF   xBE,F
7B2E:  BRA    7AEA
7B30:  CLRF   19
7B32:  BTFSC  FF2.7
7B34:  BSF    19.7
7B36:  BCF    FF2.7
....................                 fprintf(COM2,"\n\r"); 
7B38:  MOVLW  0A
7B3A:  MOVLB  9
7B3C:  MOVWF  x0C
7B3E:  MOVLB  0
7B40:  CALL   1604
7B44:  BTFSC  19.7
7B46:  BSF    FF2.7
7B48:  CLRF   19
7B4A:  BTFSC  FF2.7
7B4C:  BSF    19.7
7B4E:  BCF    FF2.7
7B50:  MOVLW  0D
7B52:  MOVLB  9
7B54:  MOVWF  x0C
7B56:  MOVLB  0
7B58:  CALL   1604
7B5C:  BTFSC  19.7
7B5E:  BSF    FF2.7
....................             } 
....................             else 
7B60:  BRA    7BA2
7B62:  MOVLB  7
....................             { 
....................                 cryption_enable = 0; 
7B64:  MOVLB  1
7B66:  CLRF   x22
7B68:  CLRF   19
7B6A:  BTFSC  FF2.7
7B6C:  BSF    19.7
7B6E:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable); 
7B70:  MOVLB  9
7B72:  CLRF   x16
7B74:  CLRF   x15
7B76:  CLRF   x14
7B78:  MOVLW  3E
7B7A:  MOVWF  x13
7B7C:  MOVFF  122,917
7B80:  MOVLB  0
7B82:  CALL   3A6C
7B86:  BTFSC  19.7
7B88:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rcrypto is disable\n\r"); 
7B8A:  MOVLW  26
7B8C:  MOVWF  FF6
7B8E:  MOVLW  1F
7B90:  MOVWF  FF7
7B92:  CLRF   19
7B94:  BTFSC  FF2.7
7B96:  BSF    19.7
7B98:  BCF    FF2.7
7B9A:  CALL   172E
7B9E:  BTFSC  19.7
7BA0:  BSF    FF2.7
....................             } 
....................         } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
7BA2:  CLRF   FEA
7BA4:  MOVLW  41
7BA6:  MOVWF  FE9
7BA8:  MOVLW  00
7BAA:  CALL   04A6
7BAE:  TBLRD*-
7BB0:  TBLRD*+
7BB2:  MOVF   FF5,W
7BB4:  MOVWF  FEE
7BB6:  IORLW  00
7BB8:  BNZ   7BB0
....................       if(!stringcomp(buffer_uart,buffer2)) 
7BBA:  MOVLW  01
7BBC:  MOVLB  7
7BBE:  MOVWF  xF4
7BC0:  MOVLW  62
7BC2:  MOVWF  xF3
7BC4:  CLRF   xF6
7BC6:  MOVLW  41
7BC8:  MOVWF  xF5
7BCA:  MOVLB  0
7BCC:  CALL   60EA
7BD0:  MOVF   01,F
7BD2:  BTFSS  FD8.2
7BD4:  BRA    7CE4
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
7BD6:  MOVLW  3C
7BD8:  MOVWF  FF6
7BDA:  MOVLW  1F
7BDC:  MOVWF  FF7
7BDE:  CLRF   19
7BE0:  BTFSC  FF2.7
7BE2:  BSF    19.7
7BE4:  BCF    FF2.7
7BE6:  CALL   172E
7BEA:  BTFSC  19.7
7BEC:  BSF    FF2.7
7BEE:  CLRF   19
7BF0:  BTFSC  FF2.7
7BF2:  BSF    19.7
7BF4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7BF6:  MOVLW  0A
7BF8:  MOVLB  9
7BFA:  MOVWF  x0C
7BFC:  MOVLB  0
7BFE:  CALL   1604
7C02:  BTFSC  19.7
7C04:  BSF    FF2.7
7C06:  CLRF   19
7C08:  BTFSC  FF2.7
7C0A:  BSF    19.7
7C0C:  BCF    FF2.7
7C0E:  MOVLW  0D
7C10:  MOVLB  9
7C12:  MOVWF  x0C
7C14:  MOVLB  0
7C16:  CALL   1604
7C1A:  BTFSC  19.7
7C1C:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
7C1E:  MOVLW  5C
7C20:  MOVWF  FF6
7C22:  MOVLW  1F
7C24:  MOVWF  FF7
7C26:  CLRF   19
7C28:  BTFSC  FF2.7
7C2A:  BSF    19.7
7C2C:  BCF    FF2.7
7C2E:  CALL   172E
7C32:  BTFSC  19.7
7C34:  BSF    FF2.7
7C36:  CLRF   19
7C38:  BTFSC  FF2.7
7C3A:  BSF    19.7
7C3C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7C3E:  MOVLW  0A
7C40:  MOVLB  9
7C42:  MOVWF  x0C
7C44:  MOVLB  0
7C46:  CALL   1604
7C4A:  BTFSC  19.7
7C4C:  BSF    FF2.7
7C4E:  CLRF   19
7C50:  BTFSC  FF2.7
7C52:  BSF    19.7
7C54:  BCF    FF2.7
7C56:  MOVLW  0D
7C58:  MOVLB  9
7C5A:  MOVWF  x0C
7C5C:  MOVLB  0
7C5E:  CALL   1604
7C62:  BTFSC  19.7
7C64:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7C66:  MOVLW  01
7C68:  MOVLB  7
7C6A:  MOVWF  xF3
7C6C:  MOVLW  03
7C6E:  MOVWF  xF4
7C70:  MOVLW  07
7C72:  MOVWF  xF6
7C74:  MOVLW  C1
7C76:  MOVWF  xF5
7C78:  MOVLB  0
7C7A:  CALL   5FB2
....................           debugmode = (unsigned int8)strtoi(temp); 
7C7E:  MOVLW  07
7C80:  MOVLB  7
7C82:  MOVWF  xF4
7C84:  MOVLW  C1
7C86:  MOVWF  xF3
7C88:  MOVLB  0
7C8A:  CALL   6B5A
7C8E:  MOVFF  01,6D6
7C92:  CLRF   19
7C94:  BTFSC  FF2.7
7C96:  BSF    19.7
7C98:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
7C9A:  MOVLB  9
7C9C:  CLRF   x16
7C9E:  CLRF   x15
7CA0:  CLRF   x14
7CA2:  MOVLW  3B
7CA4:  MOVWF  x13
7CA6:  MOVFF  6D6,917
7CAA:  MOVLB  0
7CAC:  CALL   3A6C
7CB0:  BTFSC  19.7
7CB2:  BSF    FF2.7
7CB4:  CLRF   19
7CB6:  BTFSC  FF2.7
7CB8:  BSF    19.7
7CBA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7CBC:  MOVLW  0A
7CBE:  MOVLB  9
7CC0:  MOVWF  x0C
7CC2:  MOVLB  0
7CC4:  CALL   1604
7CC8:  BTFSC  19.7
7CCA:  BSF    FF2.7
7CCC:  CLRF   19
7CCE:  BTFSC  FF2.7
7CD0:  BSF    19.7
7CD2:  BCF    FF2.7
7CD4:  MOVLW  0D
7CD6:  MOVLB  9
7CD8:  MOVWF  x0C
7CDA:  MOVLB  0
7CDC:  CALL   1604
7CE0:  BTFSC  19.7
7CE2:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
7CE4:  GOTO   82E0 (RETURN)
.................... //=============================================== 
....................  
....................  
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    if(keydebug_en==1) 
*
5A0C:  MOVLB  1
5A0E:  DECFSZ x44,W
5A10:  BRA    5A2C
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
5A12:  MOVLB  6
5A14:  MOVF   xE2,F
5A16:  BNZ   5A20
5A18:  MOVLB  0
5A1A:  CALL   1F7C
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
5A1E:  BRA    5A2A
5A20:  MOVLB  0
5A22:  CALL   31E0
5A26:  MOVFF  01,84F
5A2A:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
5A2C:  DECFSZ x45,W
5A2E:  BRA    5A48
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
5A30:  MOVLB  6
5A32:  MOVF   xE2,F
5A34:  BNZ   5A3E
5A36:  MOVLB  0
5A38:  CALL   1F7C
....................          else temp=kbd_getc_slv(); 
5A3C:  BRA    5A48
5A3E:  MOVLB  0
5A40:  CALL   31E0
5A44:  MOVFF  01,84F
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
5A48:  MOVLB  6
5A4A:  MOVF   xC7,F
5A4C:  BNZ   5A6C
5A4E:  MOVF   xC6,F
5A50:  BNZ   5A6C
5A52:  MOVF   xC5,F
5A54:  BNZ   5A6C
5A56:  MOVF   xC4,W
5A58:  SUBLW  04
5A5A:  BNC   5A6C
5A5C:  MOVLW  01
5A5E:  ADDWF  xC4,F
5A60:  BTFSC  FD8.0
5A62:  INCF   xC5,F
5A64:  BTFSC  FD8.2
5A66:  INCF   xC6,F
5A68:  BTFSC  FD8.2
5A6A:  INCF   xC7,F
....................   if(mcr_timeout==5) 
5A6C:  MOVF   xC4,W
5A6E:  SUBLW  05
5A70:  BNZ   5ADC
5A72:  MOVF   xC5,F
5A74:  BNZ   5ADC
5A76:  MOVF   xC6,F
5A78:  BNZ   5ADC
5A7A:  MOVF   xC7,F
5A7C:  BNZ   5ADC
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1) 
5A7E:  DECFSZ xDA,W
5A80:  BRA    5A9A
....................       { 
....................           if(cryption_enable==0)  
5A82:  MOVLB  1
5A84:  MOVF   x22,F
5A86:  BNZ   5A92
....................           { 
....................                 saving_card(); 
5A88:  MOVLB  0
5A8A:  GOTO   3C02
....................           } 
....................           else  
5A8E:  BRA    5A98
5A90:  MOVLB  1
....................           { 
....................                 saving_card_encrypt(); 
5A92:  MOVLB  0
5A94:  GOTO   4FD0
5A98:  MOVLB  6
....................           } 
....................       } 
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
5A9A:  MOVLW  02
5A9C:  MOVWF  FEA
5A9E:  MOVLW  46
5AA0:  MOVWF  FE9
5AA2:  CLRF   00
5AA4:  MOVLW  03
5AA6:  MOVWF  02
5AA8:  MOVLW  52
5AAA:  MOVWF  01
5AAC:  MOVLB  0
5AAE:  CALL   359A
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
5AB2:  MOVLW  05
5AB4:  MOVWF  FEA
5AB6:  MOVLW  98
5AB8:  MOVWF  FE9
5ABA:  CLRF   00
5ABC:  MOVLW  01
5ABE:  MOVWF  02
5AC0:  MOVLW  2C
5AC2:  MOVWF  01
5AC4:  CALL   359A
....................       //debug_card(); 
....................       count_reading_error=0; 
5AC8:  MOVLB  6
5ACA:  CLRF   xDB
....................       mcr_timeout++;   
5ACC:  MOVLW  01
5ACE:  ADDWF  xC4,F
5AD0:  BTFSC  FD8.0
5AD2:  INCF   xC5,F
5AD4:  BTFSC  FD8.2
5AD6:  INCF   xC6,F
5AD8:  BTFSC  FD8.2
5ADA:  INCF   xC7,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
5ADC:  MOVLB  9
5ADE:  CLRF   x1B
5AE0:  CLRF   x1A
5AE2:  CLRF   x19
5AE4:  MOVLW  3C
5AE6:  MOVWF  x18
5AE8:  MOVLB  0
5AEA:  CALL   3450
5AEE:  MOVFF  01,15A
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
5AF2:  MOVLW  02
5AF4:  MOVLB  8
5AF6:  MOVWF  x56
5AF8:  MOVLW  BC
5AFA:  MOVWF  x55
5AFC:  CLRF   x58
5AFE:  MOVFF  15A,857
5B02:  MOVLB  0
5B04:  CALL   3578
5B08:  MOVFF  02,03
5B0C:  MOVF   01,W
5B0E:  MOVLB  1
5B10:  MOVF   x00,W
5B12:  SUBWF  02,W
5B14:  BNC   5B34
5B16:  BNZ   5B26
5B18:  MOVF   01,W
5B1A:  MOVLB  0
5B1C:  SUBWF  xFF,W
5B1E:  BTFSS  FD8.0
5B20:  BRA    5B26
5B22:  MOVLB  1
5B24:  BRA    5B34
5B26:  MOVLB  0
5B28:  INCF   xFF,F
5B2A:  BTFSS  FD8.2
5B2C:  BRA    5B34
5B2E:  MOVLB  1
5B30:  INCF   x00,F
5B32:  MOVLB  0
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
5B34:  MOVLW  02
5B36:  MOVLB  8
5B38:  MOVWF  x56
5B3A:  MOVLW  BC
5B3C:  MOVWF  x55
5B3E:  CLRF   x58
5B40:  MOVFF  15A,857
5B44:  MOVLB  0
5B46:  CALL   3578
5B4A:  MOVFF  02,03
5B4E:  MOVF   01,W
5B50:  SUBWF  xFF,W
5B52:  BNZ   5C18
5B54:  MOVF   03,W
5B56:  MOVLB  1
5B58:  SUBWF  x00,W
5B5A:  BTFSC  FD8.2
5B5C:  BRA    5B62
5B5E:  MOVLB  0
5B60:  BRA    5C18
....................   { 
....................       charac_timeout++; 
5B62:  MOVLB  0
5B64:  INCF   xFF,F
5B66:  BTFSS  FD8.2
5B68:  BRA    5B70
5B6A:  MOVLB  1
5B6C:  INCF   x00,F
5B6E:  MOVLB  0
....................       buf=get_countcard(); 
5B70:  CALL   351C
5B74:  MOVFF  02,84E
5B78:  MOVFF  01,84D
....................       if(buf<countcards) 
5B7C:  MOVLB  8
5B7E:  MOVF   x4E,W
5B80:  SUBLW  03
5B82:  BNC   5BB8
5B84:  BNZ   5B8C
5B86:  MOVF   x4D,W
5B88:  SUBLW  A1
5B8A:  BNC   5BB8
....................       { 
....................          if(cryption_enable==0)  
5B8C:  MOVLB  1
5B8E:  MOVF   x22,F
5B90:  BNZ   5B9A
....................          { 
....................             save_key_new(); 
5B92:  MOVLB  0
5B94:  BRA    54A2
....................          } 
....................          else 
5B96:  BRA    5B9E
5B98:  MOVLB  1
....................          { 
....................             save_key_encrypt(); 
5B9A:  MOVLB  0
5B9C:  BRA    5664
....................          } 
....................          buf=buf+1; 
5B9E:  MOVLW  01
5BA0:  MOVLB  8
5BA2:  ADDWF  x4D,F
5BA4:  MOVLW  00
5BA6:  ADDWFC x4E,F
....................          save_coutcard(buf); 
5BA8:  MOVFF  84E,851
5BAC:  MOVFF  84D,850
5BB0:  MOVLB  0
5BB2:  RCALL  58CE
....................       } 
....................          else 
5BB4:  BRA    5BC8
5BB6:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
5BB8:  MOVLW  1E
5BBA:  MOVWF  FF6
5BBC:  MOVLW  5C
5BBE:  MOVWF  FF7
5BC0:  MOVLB  0
5BC2:  CALL   172E
....................             return; 
5BC6:  BRA    5C18
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
5BC8:  MOVLW  2E
5BCA:  MOVWF  FF6
5BCC:  MOVLW  5C
5BCE:  MOVWF  FF7
5BD0:  CALL   172E
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
5BD4:  MOVLW  3E
5BD6:  MOVWF  FF6
5BD8:  MOVLW  5C
5BDA:  MOVWF  FF7
5BDC:  MOVLW  14
5BDE:  MOVLB  8
5BE0:  MOVWF  xF7
5BE2:  MOVLB  0
5BE4:  CALL   164A
5BE8:  MOVLW  10
5BEA:  MOVWF  FE9
5BEC:  MOVFF  84E,851
5BF0:  MOVFF  84D,850
5BF4:  RCALL  5916
5BF6:  MOVLW  55
5BF8:  MOVWF  FF6
5BFA:  MOVLW  5C
5BFC:  MOVWF  FF7
5BFE:  MOVLW  03
5C00:  MOVLB  8
5C02:  MOVWF  xF7
5C04:  MOVLB  0
5C06:  CALL   164A
....................       data_avai=0; 
5C0A:  MOVLB  6
5C0C:  CLRF   xD9
....................       enable_getpin=0; 
5C0E:  MOVLB  1
5C10:  CLRF   x45
....................       //dis_getpin; 
....................       output_low(LED); 
5C12:  BCF    F92.6
5C14:  BCF    F89.6
5C16:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
5C18:  BCF    FF2.2
5C1A:  GOTO   006C
.................... void main() 
.................... {  
*
7CE8:  CLRF   FF8
7CEA:  BCF    FD0.7
7CEC:  BSF    07.7
7CEE:  CLRF   FEA
7CF0:  CLRF   FE9
7CF2:  BCF    F94.0
7CF4:  BSF    F8B.0
7CF6:  CLRF   23
7CF8:  CLRF   22
7CFA:  CLRF   21
7CFC:  MOVLW  96
7CFE:  MOVWF  20
7D00:  CLRF   27
7D02:  MOVLW  01
7D04:  MOVWF  26
7D06:  MOVLW  C3
7D08:  MOVWF  25
7D0A:  MOVLW  0F
7D0C:  MOVWF  24
7D0E:  CLRF   xFE
7D10:  CLRF   xFD
7D12:  MOVLB  1
7D14:  SETF   x00
7D16:  MOVLB  0
7D18:  SETF   xFF
7D1A:  MOVLB  1
7D1C:  CLRF   x22
7D1E:  CLRF   x43
7D20:  CLRF   x44
7D22:  CLRF   x45
7D24:  MOVLW  64
7D26:  MOVWF  x46
7D28:  CLRF   x47
7D2A:  CLRF   x48
7D2C:  CLRF   x49
7D2E:  CLRF   x5A
7D30:  CLRF   x5F
7D32:  CLRF   xC6
7D34:  CLRF   xC7
7D36:  MOVLW  0E
7D38:  MOVWF  xC9
7D3A:  MOVLW  01
7D3C:  MOVWF  xCA
7D3E:  MOVWF  xCB
7D40:  CLRF   xCC
7D42:  CLRF   xCD
7D44:  CLRF   xCE
7D46:  MOVLB  6
7D48:  CLRF   xC7
7D4A:  CLRF   xC6
7D4C:  CLRF   xC5
7D4E:  CLRF   xC4
7D50:  CLRF   xC8
7D52:  CLRF   xCA
7D54:  CLRF   xC9
7D56:  CLRF   xCC
7D58:  CLRF   xCB
7D5A:  CLRF   xCE
7D5C:  CLRF   xCD
7D5E:  CLRF   xD0
7D60:  CLRF   xCF
7D62:  MOVLW  FD
7D64:  MOVWF  xD2
7D66:  MOVLW  E8
7D68:  MOVWF  xD1
7D6A:  CLRF   xD4
7D6C:  CLRF   xD3
7D6E:  CLRF   xD5
7D70:  CLRF   xD6
7D72:  CLRF   xD7
7D74:  CLRF   xD8
7D76:  CLRF   xD9
7D78:  CLRF   xDA
7D7A:  CLRF   xDB
7D7C:  CLRF   xDC
7D7E:  CLRF   xDD
7D80:  CLRF   xDF
7D82:  MOVLW  01
7D84:  MOVWF  xDE
7D86:  CLRF   xE1
7D88:  CLRF   xE0
7D8A:  CLRF   xE2
7D8C:  CLRF   xE6
7D8E:  CLRF   xE5
7D90:  CLRF   xE4
7D92:  CLRF   xE3
7D94:  MOVLW  FF
7D96:  MOVLB  F
7D98:  MOVWF  x48
7D9A:  BCF    FC2.6
7D9C:  BCF    FC2.7
7D9E:  MOVF   x49,W
7DA0:  ANDLW  E0
7DA2:  IORLW  1F
7DA4:  MOVWF  x49
7DA6:  CLRF   FD2
7DA8:  CLRF   FD1
7DAA:  CLRF   1A
7DAC:  CLRF   1B
7DAE:  MOVLW  E8
7DB0:  MOVLB  1
7DB2:  MOVWF  x23
7DB4:  MOVLW  E9
7DB6:  MOVWF  x24
7DB8:  MOVLW  EA
7DBA:  MOVWF  x25
7DBC:  MOVLW  EB
7DBE:  MOVWF  x26
7DC0:  MOVLW  ED
7DC2:  MOVWF  x27
7DC4:  MOVLW  EE
7DC6:  MOVWF  x28
7DC8:  MOVLW  EF
7DCA:  MOVWF  x29
7DCC:  MOVLW  F0
7DCE:  MOVWF  x2A
7DD0:  MOVLW  F2
7DD2:  MOVWF  x2B
7DD4:  MOVLW  F3
7DD6:  MOVWF  x2C
7DD8:  MOVLW  F4
7DDA:  MOVWF  x2D
7DDC:  MOVLW  F5
7DDE:  MOVWF  x2E
7DE0:  MOVLW  F7
7DE2:  MOVWF  x2F
7DE4:  MOVLW  F8
7DE6:  MOVWF  x30
7DE8:  MOVLW  F9
7DEA:  MOVWF  x31
7DEC:  MOVLW  FA
7DEE:  MOVWF  x32
7DF0:  MOVLW  67
7DF2:  MOVWF  x33
7DF4:  MOVLW  43
7DF6:  MOVWF  x34
7DF8:  MOVLW  C3
7DFA:  MOVWF  x35
7DFC:  MOVLW  D1
7DFE:  MOVWF  x36
7E00:  MOVLW  51
7E02:  MOVWF  x37
7E04:  MOVLW  9A
7E06:  MOVWF  x38
7E08:  MOVLW  B4
7E0A:  MOVWF  x39
7E0C:  MOVLW  F2
7E0E:  MOVWF  x3A
7E10:  MOVLW  CD
7E12:  MOVWF  x3B
7E14:  MOVLW  9A
7E16:  MOVWF  x3C
7E18:  MOVLW  78
7E1A:  MOVWF  x3D
7E1C:  MOVLW  AB
7E1E:  MOVWF  x3E
7E20:  MOVLW  09
7E22:  MOVWF  x3F
7E24:  MOVLW  A5
7E26:  MOVWF  x40
7E28:  MOVLW  11
7E2A:  MOVWF  x41
7E2C:  MOVLW  BD
7E2E:  MOVWF  x42
7E30:  CLRF   x5B
7E32:  BCF    x5C.0
7E34:  CLRF   x5D
7E36:  CLRF   x5E
7E38:  CLRF   x60
7E3A:  BCF    x5C.1
7E3C:  CLRF   x61
7E3E:  MOVLB  6
7E40:  CLRF   xF7
7E42:  CLRF   xF8
7E44:  CLRF   xF9
7E46:  CLRF   xFA
7E48:  CLRF   xFB
7E4A:  CLRF   xFC
7E4C:  CLRF   xFD
7E4E:  CLRF   xFE
7E50:  CLRF   xFF
7E52:  MOVLB  7
7E54:  CLRF   x00
7E56:  CLRF   x03
7E58:  CLRF   x05
7E5A:  CLRF   x04
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    RPINR1=5; 
7E5C:  MOVLW  05
7E5E:  MOVLB  E
7E60:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
7E62:  MOVLB  1
7E64:  SETF   x00
7E66:  MOVLB  0
7E68:  SETF   xFF
....................    setup_oscillator(OSC_32MHZ); 
7E6A:  MOVLW  70
7E6C:  MOVWF  FD3
7E6E:  MOVLW  40
7E70:  MOVWF  F9B
7E72:  MOVF   FD3,W
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
7E74:  BCF    FF2.6
7E76:  BCF    FF2.7
7E78:  BTFSC  FF2.7
7E7A:  BRA    7E76
....................    init_ext_eeprom(); 
7E7C:  GOTO   5D16
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif   
....................    //===================================== 
....................    delay_ms(1000); 
7E80:  MOVLW  04
7E82:  MOVLB  7
7E84:  MOVWF  xBD
7E86:  CLRF   19
7E88:  BTFSC  FF2.7
7E8A:  BSF    19.7
7E8C:  BCF    FF2.7
7E8E:  MOVLW  FA
7E90:  MOVLB  8
7E92:  MOVWF  x56
7E94:  MOVLB  0
7E96:  CALL   18C6
7E9A:  BTFSC  19.7
7E9C:  BSF    FF2.7
7E9E:  MOVLB  7
7EA0:  DECFSZ xBD,F
7EA2:  BRA    7E86
....................    init_password(); 
7EA4:  MOVLB  0
7EA6:  CALL   5D20
....................    //===================================== 
....................     
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
7EAA:  MOVLW  19
7EAC:  MOVLB  7
7EAE:  MOVWF  xBD
7EB0:  MOVLB  0
7EB2:  CALL   5DDC
7EB6:  MOVFF  03,23
7EBA:  MOVFF  02,22
7EBE:  MOVFF  01,21
7EC2:  MOVFF  00,20
....................    printf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
7EC6:  CLRF   FEA
7EC8:  MOVLW  01
7ECA:  MOVWF  FE9
7ECC:  CALL   5F32
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
7ED0:  MOVLW  1E
7ED2:  MOVLB  7
7ED4:  MOVWF  xBD
7ED6:  MOVLB  0
7ED8:  CALL   5DDC
7EDC:  MOVFF  03,27
7EE0:  MOVFF  02,26
7EE4:  MOVFF  01,25
7EE8:  MOVFF  00,24
....................    fprintf(COM2,"booting\n\r"); 
7EEC:  MOVLW  5A
7EEE:  MOVWF  FF6
7EF0:  MOVLW  5C
7EF2:  MOVWF  FF7
7EF4:  CLRF   19
7EF6:  BTFSC  FF2.7
7EF8:  BSF    19.7
7EFA:  BCF    FF2.7
7EFC:  CALL   172E
7F00:  BTFSC  19.7
7F02:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
7F04:  MOVLW  64
7F06:  MOVWF  FF6
7F08:  MOVLW  5C
7F0A:  MOVWF  FF7
7F0C:  CLRF   19
7F0E:  BTFSC  FF2.7
7F10:  BSF    19.7
7F12:  BCF    FF2.7
7F14:  MOVLW  12
7F16:  MOVLB  8
7F18:  MOVWF  xF7
7F1A:  MOVLB  0
7F1C:  CALL   164A
7F20:  BTFSC  19.7
7F22:  BSF    FF2.7
7F24:  MOVLW  41
7F26:  MOVWF  FE9
7F28:  CLRF   19
7F2A:  BTFSC  FF2.7
7F2C:  BSF    19.7
7F2E:  BCF    FF2.7
7F30:  MOVFF  27,8FA
7F34:  MOVFF  26,8F9
7F38:  MOVFF  25,8F8
7F3C:  MOVFF  24,8F7
7F40:  CALL   22FA
7F44:  BTFSC  19.7
7F46:  BSF    FF2.7
7F48:  CLRF   19
7F4A:  BTFSC  FF2.7
7F4C:  BSF    19.7
7F4E:  BCF    FF2.7
7F50:  MOVLW  0A
7F52:  MOVLB  9
7F54:  MOVWF  x0C
7F56:  MOVLB  0
7F58:  CALL   1604
7F5C:  BTFSC  19.7
7F5E:  BSF    FF2.7
7F60:  CLRF   19
7F62:  BTFSC  FF2.7
7F64:  BSF    19.7
7F66:  BCF    FF2.7
7F68:  MOVLW  0D
7F6A:  MOVLB  9
7F6C:  MOVWF  x0C
7F6E:  MOVLB  0
7F70:  CALL   1604
7F74:  BTFSC  19.7
7F76:  BSF    FF2.7
7F78:  CLRF   19
7F7A:  BTFSC  FF2.7
7F7C:  BSF    19.7
7F7E:  BCF    FF2.7
....................    countcard=get_countcard(); 
7F80:  CALL   351C
7F84:  BTFSC  19.7
7F86:  BSF    FF2.7
7F88:  MOVFF  02,FE
7F8C:  MOVFF  01,FD
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
7F90:  MOVLB  1
7F92:  SETF   x00
7F94:  MOVLB  0
7F96:  SETF   xFF
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
7F98:  MOVLW  C7
7F9A:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
7F9C:  MOVLW  37
7F9E:  MOVWF  FCD
7FA0:  CLRF   F9A
7FA2:  CLRF   19
7FA4:  BTFSC  FF2.7
7FA6:  BSF    19.7
7FA8:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
7FAA:  MOVLB  9
7FAC:  CLRF   x1B
7FAE:  CLRF   x1A
7FB0:  CLRF   x19
7FB2:  MOVLW  3C
7FB4:  MOVWF  x18
7FB6:  MOVLB  0
7FB8:  CALL   3450
7FBC:  BTFSC  19.7
7FBE:  BSF    FF2.7
7FC0:  MOVFF  01,15A
....................    if(delaycharaction==0)delaycharaction=1; 
7FC4:  MOVLB  1
7FC6:  MOVF   x5A,F
7FC8:  BNZ   7FCE
7FCA:  MOVLW  01
7FCC:  MOVWF  x5A
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
7FCE:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
7FD0:  BSF    FF0.3
7FD2:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
7FD4:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
7FD6:  MOVLW  C0
7FD8:  IORWF  FF2,F
....................   
....................     mcr_timeout=10000; 
7FDA:  MOVLB  6
7FDC:  CLRF   xC7
7FDE:  CLRF   xC6
7FE0:  MOVLW  27
7FE2:  MOVWF  xC5
7FE4:  MOVLW  10
7FE6:  MOVWF  xC4
7FE8:  CLRF   19
7FEA:  BTFSC  FF2.7
7FEC:  BSF    19.7
7FEE:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
7FF0:  MOVLB  9
7FF2:  CLRF   x1B
7FF4:  CLRF   x1A
7FF6:  CLRF   x19
7FF8:  MOVLW  3A
7FFA:  MOVWF  x18
7FFC:  MOVLB  0
7FFE:  CALL   3450
8002:  BTFSC  19.7
8004:  BSF    FF2.7
8006:  MOVFF  01,6E2
800A:  CLRF   19
800C:  BTFSC  FF2.7
800E:  BSF    19.7
8010:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
8012:  MOVLB  9
8014:  CLRF   x1B
8016:  CLRF   x1A
8018:  CLRF   x19
801A:  MOVLW  3B
801C:  MOVWF  x18
801E:  MOVLB  0
8020:  CALL   3450
8024:  BTFSC  19.7
8026:  BSF    FF2.7
8028:  MOVFF  01,6D6
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
802C:  MOVLB  1
802E:  SETF   x00
8030:  MOVLB  0
8032:  SETF   xFF
8034:  CLRF   19
8036:  BTFSC  FF2.7
8038:  BSF    19.7
803A:  BCF    FF2.7
....................     
....................    EEPROM_read(strobe_nameconsole,wide_strobe_nameconsole,console); 
803C:  MOVLB  9
803E:  CLRF   x07
8040:  CLRF   x06
8042:  CLRF   x05
8044:  MOVLW  28
8046:  MOVWF  x04
8048:  CLRF   x0B
804A:  CLRF   x0A
804C:  CLRF   x09
804E:  MOVLW  10
8050:  MOVWF  x08
8052:  MOVLW  06
8054:  MOVWF  x0D
8056:  MOVLW  E7
8058:  MOVWF  x0C
805A:  MOVLB  0
805C:  CALL   4004
8060:  BTFSC  19.7
8062:  BSF    FF2.7
....................    set_tris_a(0xff);  
8064:  MOVLW  FF
8066:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
8068:  MOVLW  E0
806A:  MOVLB  F
806C:  MOVWF  x48
806E:  BCF    FC2.6
8070:  BCF    FC2.7
8072:  MOVF   x49,W
8074:  ANDLW  E0
8076:  IORLW  1F
8078:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
807A:  MOVF   FC1,W
807C:  ANDLW  C0
807E:  IORLW  03
8080:  MOVWF  FC1
8082:  BCF    FC1.7
8084:  BSF    FC2.0
8086:  BSF    FC1.6
8088:  BSF    FC2.1
808A:  BTFSC  FC2.1
808C:  BRA    808A
808E:  BCF    FC1.6
8090:  CLRF   19
8092:  BTFSC  FF2.7
8094:  BSF    19.7
8096:  BCF    FF2.7
....................     
....................    type_KB=read_ext_eeprom(kindofKB); 
8098:  MOVLB  9
809A:  CLRF   x1B
809C:  CLRF   x1A
809E:  CLRF   x19
80A0:  MOVLW  3D
80A2:  MOVWF  x18
80A4:  MOVLB  0
80A6:  CALL   3450
80AA:  BTFSC  19.7
80AC:  BSF    FF2.7
80AE:  MOVFF  01,149
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
80B2:  MOVLB  1
80B4:  MOVF   x49,F
80B6:  BZ    80D6
80B8:  MOVLW  7C
80BA:  MOVWF  FF6
80BC:  MOVLW  5C
80BE:  MOVWF  FF7
80C0:  CLRF   19
80C2:  BTFSC  FF2.7
80C4:  BSF    19.7
80C6:  BCF    FF2.7
80C8:  MOVLB  0
80CA:  CALL   172E
80CE:  BTFSC  19.7
80D0:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
80D2:  BRA    80F0
80D4:  MOVLB  1
80D6:  MOVLW  90
80D8:  MOVWF  FF6
80DA:  MOVLW  5C
80DC:  MOVWF  FF7
80DE:  CLRF   19
80E0:  BTFSC  FF2.7
80E2:  BSF    19.7
80E4:  BCF    FF2.7
80E6:  MOVLB  0
80E8:  CALL   172E
80EC:  BTFSC  19.7
80EE:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
80F0:  MOVLB  6
80F2:  MOVF   xE2,F
80F4:  BNZ   8114
80F6:  MOVLW  A4
80F8:  MOVWF  FF6
80FA:  MOVLW  5C
80FC:  MOVWF  FF7
80FE:  CLRF   19
8100:  BTFSC  FF2.7
8102:  BSF    19.7
8104:  BCF    FF2.7
8106:  MOVLB  0
8108:  CALL   172E
810C:  BTFSC  19.7
810E:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
8110:  BRA    812E
8112:  MOVLB  6
8114:  MOVLW  BE
8116:  MOVWF  FF6
8118:  MOVLW  5C
811A:  MOVWF  FF7
811C:  CLRF   19
811E:  BTFSC  FF2.7
8120:  BSF    19.7
8122:  BCF    FF2.7
8124:  MOVLB  0
8126:  CALL   172E
812A:  BTFSC  19.7
812C:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
812E:  MOVLW  01
8130:  MOVWF  FEA
8132:  MOVLW  4A
8134:  MOVWF  FE9
8136:  CLRF   00
8138:  CLRF   02
813A:  MOVLW  10
813C:  MOVWF  01
813E:  CALL   359A
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
8142:  MOVLB  7
8144:  CLRF   x01
8146:  MOVF   x01,W
8148:  SUBLW  13
814A:  BNC   8160
....................    { 
....................       password[i] = 0; 
814C:  CLRF   03
814E:  MOVF   x01,W
8150:  ADDLW  55
8152:  MOVWF  FE9
8154:  MOVLW  00
8156:  ADDWFC 03,W
8158:  MOVWF  FEA
815A:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 0 
....................    disable_interrupts(GLOBAL); 
....................    save_coutcard(0); 
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................     
....................    save_key_encrypt(); 
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
....................     
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_data in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_key in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],1); 
....................    //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rdecrypted:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    while(1); 
.................... #endif 
.................... #if 0 
815C:  INCF   x01,F
815E:  BRA    8146
8160:  CLRF   19
8162:  BTFSC  FF2.7
8164:  BSF    19.7
8166:  BCF    FF2.7
....................     fprintf(COM2,"\n\reeprom test\n\r"); 
....................     fprintf(COM2,"\n\reeprom is writing\n\r"); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         //write_ext_eeprom(115535+i,i); 
....................     } 
....................     write_ext_eeprom(EEPROM_KEY_ST,210); 
....................     write_ext_eeprom(EEPROM_SIZE_endofkey,123); 
....................     fprintf(COM2,"\n\r"); 
....................     fprintf(COM2,"eeprom is reading: %u",read_ext_eeprom(EEPROM_KEY_ST)); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         fprintf(COM2," %u",read_ext_eeprom(115535+i)); 
....................     } 
....................     while(1); 
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
8168:  MOVLB  9
816A:  CLRF   x07
816C:  CLRF   x06
816E:  CLRF   x05
8170:  CLRF   x04
8172:  CLRF   x0B
8174:  CLRF   x0A
8176:  CLRF   x09
8178:  MOVLW  14
817A:  MOVWF  x08
817C:  CLRF   x0D
817E:  MOVLW  55
8180:  MOVWF  x0C
8182:  MOVLB  0
8184:  CALL   4004
8188:  BTFSC  19.7
818A:  BSF    FF2.7
818C:  CLRF   19
818E:  BTFSC  FF2.7
8190:  BSF    19.7
8192:  BCF    FF2.7
....................    cryption_enable = read_ext_eeprom(crypto_en); 
8194:  MOVLB  9
8196:  CLRF   x1B
8198:  CLRF   x1A
819A:  CLRF   x19
819C:  MOVLW  3E
819E:  MOVWF  x18
81A0:  MOVLB  0
81A2:  CALL   3450
81A6:  BTFSC  19.7
81A8:  BSF    FF2.7
81AA:  MOVFF  01,122
....................    if(cryption_enable!=0) 
81AE:  MOVLB  1
81B0:  MOVF   x22,F
81B2:  BZ    8200
....................    { 
....................         fprintf(COM2,"\n\crypto is enable\n\r"); 
81B4:  MOVLW  D6
81B6:  MOVWF  FF6
81B8:  MOVLW  5C
81BA:  MOVWF  FF7
81BC:  CLRF   19
81BE:  BTFSC  FF2.7
81C0:  BSF    19.7
81C2:  BCF    FF2.7
81C4:  MOVLB  0
81C6:  CALL   172E
81CA:  BTFSC  19.7
81CC:  BSF    FF2.7
81CE:  CLRF   19
81D0:  BTFSC  FF2.7
81D2:  BSF    19.7
81D4:  BCF    FF2.7
....................         EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key);  
81D6:  MOVLB  9
81D8:  CLRF   x07
81DA:  CLRF   x06
81DC:  CLRF   x05
81DE:  MOVLW  3F
81E0:  MOVWF  x04
81E2:  CLRF   x0B
81E4:  CLRF   x0A
81E6:  CLRF   x09
81E8:  MOVLW  20
81EA:  MOVWF  x08
81EC:  MOVLW  01
81EE:  MOVWF  x0D
81F0:  MOVWF  x0C
81F2:  MOVLB  0
81F4:  CALL   4004
81F8:  BTFSC  19.7
81FA:  BSF    FF2.7
....................    } 
....................    else 
81FC:  BRA    821A
81FE:  MOVLB  1
....................    { 
....................        fprintf(COM2,"\n\crypto is disable\n\r"); 
8200:  MOVLW  EA
8202:  MOVWF  FF6
8204:  MOVLW  5C
8206:  MOVWF  FF7
8208:  CLRF   19
820A:  BTFSC  FF2.7
820C:  BSF    19.7
820E:  BCF    FF2.7
8210:  MOVLB  0
8212:  CALL   172E
8216:  BTFSC  19.7
8218:  BSF    FF2.7
....................    } 
.................... #if 0    
....................    fprintf(COM2,"\n\crypto key:\n\r"); 
....................    for(i=0;i<CRYPTO_KEY_SIZE;i++) 
....................    { 
....................         fprintf(COM2,"%c",crypto_key[i]); 
....................    } 
....................    fprintf(COM2,"\n\r"); 
.................... #endif    
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
821A:  MOVLB  6
821C:  MOVF   xDC,F
821E:  BNZ   82D6
....................       { 
....................          fprintf(COM2,"password:"); 
8220:  MOVLW  00
8222:  MOVWF  FF6
8224:  MOVLW  5D
8226:  MOVWF  FF7
8228:  CLRF   19
822A:  BTFSC  FF2.7
822C:  BSF    19.7
822E:  BCF    FF2.7
8230:  MOVLB  0
8232:  CALL   172E
8236:  BTFSC  19.7
8238:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
823A:  MOVLW  02
823C:  MOVLB  7
823E:  MOVWF  xF3
8240:  MOVLW  14
8242:  MOVWF  xF4
8244:  MOVLW  01
8246:  MOVWF  xF6
8248:  MOVLW  62
824A:  MOVWF  xF5
824C:  MOVLB  0
824E:  CALL   5FB2
8252:  CLRF   19
8254:  BTFSC  FF2.7
8256:  BSF    19.7
8258:  BCF    FF2.7
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
825A:  MOVLB  9
825C:  CLRF   x07
825E:  CLRF   x06
8260:  CLRF   x05
8262:  CLRF   x04
8264:  CLRF   x0B
8266:  CLRF   x0A
8268:  CLRF   x09
826A:  MOVLW  14
826C:  MOVWF  x08
826E:  CLRF   x0D
8270:  MOVLW  55
8272:  MOVWF  x0C
8274:  MOVLB  0
8276:  CALL   4004
827A:  BTFSC  19.7
827C:  BSF    FF2.7
....................          if(!stringcomp(buffer_uart,password)) 
827E:  MOVLW  01
8280:  MOVLB  7
8282:  MOVWF  xF4
8284:  MOVLW  62
8286:  MOVWF  xF3
8288:  CLRF   xF6
828A:  MOVLW  55
828C:  MOVWF  xF5
828E:  MOVLB  0
8290:  CALL   60EA
8294:  MOVF   01,F
8296:  BNZ   82BA
....................          { 
....................             mode=LOGON; 
8298:  MOVLW  01
829A:  MOVLB  6
829C:  MOVWF  xDC
....................             fprintf(COM2," OK\n\r"); 
829E:  MOVLW  0A
82A0:  MOVWF  FF6
82A2:  MOVLW  5D
82A4:  MOVWF  FF7
82A6:  CLRF   19
82A8:  BTFSC  FF2.7
82AA:  BSF    19.7
82AC:  BCF    FF2.7
82AE:  MOVLB  0
82B0:  CALL   172E
82B4:  BTFSC  19.7
82B6:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
82B8:  BRA    82D2
82BA:  MOVLW  10
82BC:  MOVWF  FF6
82BE:  MOVLW  5D
82C0:  MOVWF  FF7
82C2:  CLRF   19
82C4:  BTFSC  FF2.7
82C6:  BSF    19.7
82C8:  BCF    FF2.7
82CA:  CALL   172E
82CE:  BTFSC  19.7
82D0:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
82D2:  BRA    82E0
82D4:  MOVLB  6
82D6:  DECFSZ xDC,W
82D8:  BRA    82E2
82DA:  MOVLB  0
82DC:  GOTO   6BA8
82E0:  MOVLB  6
....................    } 
82E2:  BRA    821C
.................... } 
82E4:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

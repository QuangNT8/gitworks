CCS PCH C Compiler, Version 4.140, 33034               26-Jul-18 22:55

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   33382 bytes (51%)
                           Largest free fragment is 32142
               RAM used:   1983 (53%) at main() level
                           2369 (63%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   7B80
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   5932
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1C0E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
....................  
.................... //#define 24AA1025 
.................... #define 24AA512 
....................  
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
06A2:  MOVLW  02
06A4:  MOVLB  8
06A6:  SUBWF  x4E,F
06A8:  BNC   06C2
06AA:  MOVLW  08
06AC:  MOVWF  FEA
06AE:  MOVLW  4E
06B0:  MOVWF  FE9
06B2:  MOVF   FEF,W
06B4:  BZ    06C2
06B6:  BRA    06BE
06B8:  BRA    06BA
06BA:  BRA    06BC
06BC:  NOP   
06BE:  DECFSZ FEF,F
06C0:  BRA    06B8
06C2:  MOVLB  0
06C4:  GOTO   1C1E (RETURN)
*
18E6:  MOVLW  08
18E8:  MOVWF  FEA
18EA:  MOVLW  56
18EC:  MOVWF  FE9
18EE:  MOVF   FEF,W
18F0:  BZ    190C
18F2:  MOVLW  0A
18F4:  MOVWF  01
18F6:  CLRF   00
18F8:  DECFSZ 00,F
18FA:  BRA    18F8
18FC:  DECFSZ 01,F
18FE:  BRA    18F6
1900:  MOVLW  5F
1902:  MOVWF  00
1904:  DECFSZ 00,F
1906:  BRA    1904
1908:  DECFSZ FEF,F
190A:  BRA    18F2
190C:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
1620:  BCF    F94.0
1622:  BCF    F8B.0
1624:  MOVLW  08
1626:  MOVWF  01
1628:  BRA    162A
162A:  NOP   
162C:  BSF    01.7
162E:  BRA    1650
1630:  BCF    01.7
1632:  MOVLB  9
1634:  RRCF   x0C,F
1636:  MOVLB  0
1638:  BTFSC  FD8.0
163A:  BSF    F8B.0
163C:  BTFSS  FD8.0
163E:  BCF    F8B.0
1640:  BSF    01.6
1642:  BRA    1650
1644:  BCF    01.6
1646:  DECFSZ 01,F
1648:  BRA    1632
164A:  BRA    164C
164C:  NOP   
164E:  BSF    F8B.0
1650:  MOVLW  10
1652:  MOVWF  FE9
1654:  DECFSZ FE9,F
1656:  BRA    1654
1658:  BRA    165A
165A:  NOP   
165C:  BTFSC  01.7
165E:  BRA    1630
1660:  BTFSC  01.6
1662:  BRA    1644
1664:  RETURN 0
*
5E84:  BSF    F94.1
5E86:  BTFSC  F82.1
5E88:  BRA    5E86
5E8A:  MOVLW  08
5E8C:  MOVWF  00
5E8E:  MOVLB  7
5E90:  CLRF   xFC
5E92:  BSF    00.7
5E94:  BRA    5EB6
5E96:  BCF    00.7
5E98:  BRA    5EB6
5E9A:  MOVFF  7FC,02
5E9E:  BCF    FD8.0
5EA0:  BTFSC  F82.1
5EA2:  BSF    FD8.0
5EA4:  RRCF   02,F
5EA6:  BSF    00.6
5EA8:  BRA    5EB6
5EAA:  BCF    00.6
5EAC:  DECFSZ 00,F
5EAE:  BRA    5E9E
5EB0:  MOVFF  02,01
5EB4:  BRA    5ECE
5EB6:  MOVLW  10
5EB8:  BTFSC  00.7
5EBA:  MOVLW  04
5EBC:  MOVWF  01
5EBE:  DECFSZ 01,F
5EC0:  BRA    5EBE
5EC2:  BRA    5EC4
5EC4:  BTFSC  00.7
5EC6:  BRA    5E96
5EC8:  BTFSC  00.6
5ECA:  BRA    5EAA
5ECC:  BRA    5E9E
5ECE:  MOVLB  0
5ED0:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3388:  MOVLW  08
338A:  MOVWF  01
338C:  MOVLW  0A
338E:  MOVWF  00
3390:  DECFSZ 00,F
3392:  BRA    3390
3394:  BCF    F8B.3
3396:  BCF    F94.3
3398:  MOVLW  0B
339A:  MOVWF  00
339C:  DECFSZ 00,F
339E:  BRA    339C
33A0:  MOVLB  9
33A2:  RLCF   x23,F
33A4:  BCF    F8B.4
33A6:  BTFSC  FD8.0
33A8:  BSF    F94.4
33AA:  BTFSS  FD8.0
33AC:  BCF    F94.4
33AE:  BSF    F94.3
33B0:  BTFSS  F82.3
33B2:  BRA    33B0
33B4:  DECFSZ 01,F
33B6:  BRA    33BA
33B8:  BRA    33BE
33BA:  MOVLB  0
33BC:  BRA    338C
33BE:  MOVLW  0A
33C0:  MOVWF  00
33C2:  DECFSZ 00,F
33C4:  BRA    33C2
33C6:  BCF    F8B.3
33C8:  BCF    F94.3
33CA:  NOP   
33CC:  BSF    F94.4
33CE:  MOVLW  0B
33D0:  MOVWF  00
33D2:  DECFSZ 00,F
33D4:  BRA    33D2
33D6:  MOVLW  0B
33D8:  MOVWF  00
33DA:  DECFSZ 00,F
33DC:  BRA    33DA
33DE:  BSF    F94.3
33E0:  BTFSS  F82.3
33E2:  BRA    33E0
33E4:  CLRF   01
33E6:  MOVLW  0B
33E8:  MOVWF  00
33EA:  DECFSZ 00,F
33EC:  BRA    33EA
33EE:  BTFSC  F82.4
33F0:  BSF    01.0
33F2:  BCF    F8B.3
33F4:  BCF    F94.3
33F6:  BCF    F8B.4
33F8:  BCF    F94.4
33FA:  MOVLB  0
33FC:  RETURN 0
33FE:  MOVLW  08
3400:  MOVLB  9
3402:  MOVWF  x1F
3404:  MOVFF  00,920
3408:  BSF    F94.4
340A:  MOVLW  0B
340C:  MOVWF  00
340E:  DECFSZ 00,F
3410:  BRA    340E
3412:  BSF    F94.3
3414:  BTFSS  F82.3
3416:  BRA    3414
3418:  BTFSC  F82.4
341A:  BSF    FD8.0
341C:  BTFSS  F82.4
341E:  BCF    FD8.0
3420:  RLCF   01,F
3422:  MOVLW  0A
3424:  MOVWF  00
3426:  DECFSZ 00,F
3428:  BRA    3426
342A:  BCF    F94.3
342C:  BCF    F8B.3
342E:  DECFSZ x1F,F
3430:  BRA    3408
3432:  BSF    F94.4
3434:  MOVLW  0B
3436:  MOVWF  00
3438:  DECFSZ 00,F
343A:  BRA    3438
343C:  BCF    F8B.4
343E:  MOVF   x20,W
3440:  BTFSS  FD8.2
3442:  BCF    F94.4
3444:  NOP   
3446:  BSF    F94.3
3448:  BTFSS  F82.3
344A:  BRA    3448
344C:  MOVLW  0A
344E:  MOVWF  00
3450:  DECFSZ 00,F
3452:  BRA    3450
3454:  BCF    F8B.3
3456:  BCF    F94.3
3458:  MOVLW  0B
345A:  MOVWF  00
345C:  DECFSZ 00,F
345E:  BRA    345C
3460:  BCF    F8B.4
3462:  BCF    F94.4
3464:  MOVLB  0
3466:  RETURN 0
....................  
.................... #define ptr_start                       150 
.................... #if defined(24AA1025) 
.................... #define EEPROM_SIZE_endofkey            131071 
.................... #define EEPROM_SIZE_stofkey             115470 
.................... #endif 
.................... #if defined(24AA512) 
.................... #define EEPROM_SIZE_endofkey            65535 // 65535 - 57601 = 7934/16= 450 
.................... #define EEPROM_SIZE_stofkey             57600 // 57600/128 = 450 
.................... #endif 
.................... #define EEPROM_KEY_ST                   EEPROM_SIZE_stofkey+1 
.................... //=============================== 
....................  
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5C68:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
5C6A:  BSF    F94.4
....................    port_b_pullups(0xff); 
5C6C:  BCF    FF1.7
.................... } 
5C6E:  GOTO   7D16 (RETURN)
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
*
3A80:  MOVLB  9
3A82:  MOVF   x16,F
3A84:  BNZ   3A8C
3A86:  MOVF   x15,W
3A88:  SUBLW  00
3A8A:  BC    3A92
3A8C:  MOVLW  A2
3A8E:  MOVWF  x19
.................... #endif 
....................    else command=0xa0; 
3A90:  BRA    3A96
3A92:  MOVLW  A0
3A94:  MOVWF  x19
....................  
....................    i2c_start(); 
3A96:  BSF    F94.4
3A98:  MOVLW  0A
3A9A:  MOVWF  00
3A9C:  DECFSZ 00,F
3A9E:  BRA    3A9C
3AA0:  BSF    F94.3
3AA2:  MOVLW  0B
3AA4:  MOVWF  00
3AA6:  DECFSZ 00,F
3AA8:  BRA    3AA6
3AAA:  BCF    F8B.4
3AAC:  BCF    F94.4
3AAE:  MOVLW  0A
3AB0:  MOVWF  00
3AB2:  DECFSZ 00,F
3AB4:  BRA    3AB2
3AB6:  BCF    F8B.3
3AB8:  BCF    F94.3
....................    i2c_write(command); 
3ABA:  MOVFF  919,923
3ABE:  MOVLB  0
3AC0:  RCALL  3388
....................    i2c_write(address>>8); 
3AC2:  MOVFF  914,91B
3AC6:  MOVFF  915,91C
3ACA:  MOVFF  916,91D
3ACE:  MOVLB  9
3AD0:  CLRF   x1E
3AD2:  MOVFF  914,923
3AD6:  MOVLB  0
3AD8:  RCALL  3388
....................    i2c_write(address); 
3ADA:  MOVFF  913,923
3ADE:  RCALL  3388
....................    i2c_write(data); 
3AE0:  MOVFF  917,923
3AE4:  RCALL  3388
....................  
....................    i2c_stop(); 
3AE6:  BCF    F94.4
3AE8:  NOP   
3AEA:  BSF    F94.3
3AEC:  BTFSS  F82.3
3AEE:  BRA    3AEC
3AF0:  MOVLW  0A
3AF2:  MOVWF  00
3AF4:  DECFSZ 00,F
3AF6:  BRA    3AF4
3AF8:  BRA    3AFA
3AFA:  NOP   
3AFC:  BSF    F94.4
3AFE:  MOVLW  0A
3B00:  MOVWF  00
3B02:  DECFSZ 00,F
3B04:  BRA    3B02
....................    i2c_start(); 
3B06:  BSF    F94.4
3B08:  MOVLW  0A
3B0A:  MOVWF  00
3B0C:  DECFSZ 00,F
3B0E:  BRA    3B0C
3B10:  BSF    F94.3
3B12:  MOVLW  0B
3B14:  MOVWF  00
3B16:  DECFSZ 00,F
3B18:  BRA    3B16
3B1A:  BCF    F8B.4
3B1C:  BCF    F94.4
3B1E:  MOVLW  0A
3B20:  MOVWF  00
3B22:  DECFSZ 00,F
3B24:  BRA    3B22
3B26:  BCF    F8B.3
3B28:  BCF    F94.3
....................    status=i2c_write(command); 
3B2A:  MOVFF  919,923
3B2E:  RCALL  3388
3B30:  MOVF   01,W
3B32:  MOVLB  9
3B34:  BCF    x18.0
3B36:  BTFSC  01.0
3B38:  BSF    x18.0
....................    while(status==1) 
....................    { 
3B3A:  BTFSS  x18.0
3B3C:  BRA    3B7A
....................       i2c_start(); 
3B3E:  BSF    F94.4
3B40:  MOVLW  0A
3B42:  MOVWF  00
3B44:  DECFSZ 00,F
3B46:  BRA    3B44
3B48:  BSF    F94.3
3B4A:  MOVLW  0B
3B4C:  MOVWF  00
3B4E:  DECFSZ 00,F
3B50:  BRA    3B4E
3B52:  BTFSS  F82.3
3B54:  BRA    3B52
3B56:  BCF    F8B.4
3B58:  BCF    F94.4
3B5A:  MOVLW  0A
3B5C:  MOVWF  00
3B5E:  DECFSZ 00,F
3B60:  BRA    3B5E
3B62:  BCF    F8B.3
3B64:  BCF    F94.3
....................       status=i2c_write(command); 
3B66:  MOVFF  919,923
3B6A:  MOVLB  0
3B6C:  RCALL  3388
3B6E:  MOVF   01,W
3B70:  MOVLB  9
3B72:  BCF    x18.0
3B74:  BTFSC  01.0
3B76:  BSF    x18.0
....................    } 
3B78:  BRA    3B3A
....................    //delay_us(100); 
.................... } 
3B7A:  MOVLB  0
3B7C:  RETURN 0
....................  
....................  
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
*
3468:  MOVLB  9
346A:  MOVF   x1B,F
346C:  BNZ   3474
346E:  MOVF   x1A,W
3470:  SUBLW  00
3472:  BC    347A
3474:  MOVLW  A2
3476:  MOVWF  x1D
.................... #endif 
....................    else command=0xa0; 
3478:  BRA    347E
347A:  MOVLW  A0
347C:  MOVWF  x1D
....................  
....................    i2c_start(); 
347E:  BSF    F94.4
3480:  MOVLW  0A
3482:  MOVWF  00
3484:  DECFSZ 00,F
3486:  BRA    3484
3488:  BSF    F94.3
348A:  MOVLW  0B
348C:  MOVWF  00
348E:  DECFSZ 00,F
3490:  BRA    348E
3492:  BTFSS  F82.3
3494:  BRA    3492
3496:  BCF    F8B.4
3498:  BCF    F94.4
349A:  MOVLW  0A
349C:  MOVWF  00
349E:  DECFSZ 00,F
34A0:  BRA    349E
34A2:  BCF    F8B.3
34A4:  BCF    F94.3
....................    i2c_write(command); 
34A6:  MOVFF  91D,923
34AA:  MOVLB  0
34AC:  RCALL  3388
....................    i2c_write(address>>8); 
34AE:  MOVFF  919,91F
34B2:  MOVFF  91A,920
34B6:  MOVFF  91B,921
34BA:  MOVLB  9
34BC:  CLRF   x22
34BE:  MOVFF  919,923
34C2:  MOVLB  0
34C4:  RCALL  3388
....................    i2c_write(address); 
34C6:  MOVFF  918,923
34CA:  RCALL  3388
....................    i2c_start(); 
34CC:  BSF    F94.4
34CE:  MOVLW  0A
34D0:  MOVWF  00
34D2:  DECFSZ 00,F
34D4:  BRA    34D2
34D6:  BSF    F94.3
34D8:  MOVLW  0B
34DA:  MOVWF  00
34DC:  DECFSZ 00,F
34DE:  BRA    34DC
34E0:  BTFSS  F82.3
34E2:  BRA    34E0
34E4:  BCF    F8B.4
34E6:  BCF    F94.4
34E8:  MOVLW  0A
34EA:  MOVWF  00
34EC:  DECFSZ 00,F
34EE:  BRA    34EC
34F0:  BCF    F8B.3
34F2:  BCF    F94.3
....................    i2c_write(command+1); 
34F4:  MOVLW  01
34F6:  MOVLB  9
34F8:  ADDWF  x1D,W
34FA:  MOVWF  x1E
34FC:  MOVWF  x23
34FE:  MOVLB  0
3500:  RCALL  3388
....................    data=i2c_read(0); 
3502:  CLRF   00
3504:  RCALL  33FE
3506:  MOVFF  01,91C
....................    i2c_stop(); 
350A:  BCF    F94.4
350C:  NOP   
350E:  BSF    F94.3
3510:  BTFSS  F82.3
3512:  BRA    3510
3514:  MOVLW  0A
3516:  MOVWF  00
3518:  DECFSZ 00,F
351A:  BRA    3518
351C:  BRA    351E
351E:  NOP   
3520:  BSF    F94.4
3522:  MOVLW  0A
3524:  MOVWF  00
3526:  DECFSZ 00,F
3528:  BRA    3526
....................    return(data); 
352A:  MOVLB  9
352C:  MOVFF  91C,01
.................... } 
3530:  MOVLB  0
3532:  RETURN 0
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr            0 
.................... #define strobe_ptrcard_addr         25     // 4 bytes 
.................... #define strobe_ptrcard_key          30     // 4 bytes 
.................... #define strobe_count_card           36     // 2 bytes 
.................... #define strobe_nameconsole          40     // 16 bytes  
.................... #define strobe_Master_SLV           58     // 1 byte 
.................... #define strobe_debugmode            59     // 1 byte 
.................... #define strobe_delaytime            60     // 1 byte 
.................... #define kindofKB                    61     // 1 byte 
.................... #define crypto_en                   62     // 1 byte 
.................... #define strobe_crypto_key           63     // 32 byte 
....................  
....................  
.................... #define wide_strobe_nameconsole     16  
.................... //============================================================== 
.................... #define numdata                  124    // 5+79+40=124 
.................... #define numdataofonecard         128    //  
.................... #define countcards               930    //43590/124 
....................  
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdataofonecard]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... #if 0 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... } 
.................... #endif 
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4DF0:  MOVLB  9
4DF2:  CLRF   x0D
4DF4:  CLRF   x0C
4DF6:  CLRF   x0B
4DF8:  CLRF   x0A
4DFA:  MOVF   x0D,W
4DFC:  SUBWF  x07,W
4DFE:  BNC   4E78
4E00:  BNZ   4E18
4E02:  MOVF   x0C,W
4E04:  SUBWF  x06,W
4E06:  BNC   4E78
4E08:  BNZ   4E18
4E0A:  MOVF   x0B,W
4E0C:  SUBWF  x05,W
4E0E:  BNC   4E78
4E10:  BNZ   4E18
4E12:  MOVF   x04,W
4E14:  SUBWF  x0A,W
4E16:  BC    4E78
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4E18:  MOVF   x0A,W
4E1A:  ADDWF  x00,W
4E1C:  MOVWF  x0E
4E1E:  MOVF   x0B,W
4E20:  ADDWFC x01,W
4E22:  MOVWF  x0F
4E24:  MOVF   x0C,W
4E26:  ADDWFC x02,W
4E28:  MOVWF  x10
4E2A:  MOVF   x0D,W
4E2C:  ADDWFC x03,W
4E2E:  MOVWF  x11
4E30:  MOVF   x08,W
4E32:  ADDWF  x0A,W
4E34:  MOVWF  FE9
4E36:  MOVF   x09,W
4E38:  ADDWFC x0B,W
4E3A:  MOVWF  FEA
4E3C:  MOVFF  FEF,912
4E40:  MOVFF  911,916
4E44:  MOVFF  910,915
4E48:  MOVFF  90F,914
4E4C:  MOVFF  90E,913
4E50:  MOVFF  912,917
4E54:  MOVLB  0
4E56:  CALL   3A80
....................       delay_us(10); 
4E5A:  MOVLW  1A
4E5C:  MOVWF  00
4E5E:  DECFSZ 00,F
4E60:  BRA    4E5E
4E62:  NOP   
....................    } 
4E64:  MOVLW  01
4E66:  MOVLB  9
4E68:  ADDWF  x0A,F
4E6A:  BTFSC  FD8.0
4E6C:  INCF   x0B,F
4E6E:  BTFSC  FD8.2
4E70:  INCF   x0C,F
4E72:  BTFSC  FD8.2
4E74:  INCF   x0D,F
4E76:  BRA    4DFA
....................    return 1; 
4E78:  MOVLW  01
4E7A:  MOVWF  01
.................... } 
4E7C:  MOVLB  0
4E7E:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len,unsigned int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4086:  MOVLB  9
4088:  CLRF   x11
408A:  CLRF   x10
408C:  CLRF   x0F
408E:  CLRF   x0E
4090:  MOVF   x11,W
4092:  SUBWF  x0B,W
4094:  BNC   4116
4096:  BNZ   40AE
4098:  MOVF   x10,W
409A:  SUBWF  x0A,W
409C:  BNC   4116
409E:  BNZ   40AE
40A0:  MOVF   x0F,W
40A2:  SUBWF  x09,W
40A4:  BNC   4116
40A6:  BNZ   40AE
40A8:  MOVF   x08,W
40AA:  SUBWF  x0E,W
40AC:  BC    4116
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
40AE:  MOVF   x0C,W
40B0:  ADDWF  x0E,W
40B2:  MOVWF  01
40B4:  MOVF   x0D,W
40B6:  ADDWFC x0F,W
40B8:  MOVWF  03
40BA:  MOVFF  01,912
40BE:  MOVWF  x13
40C0:  MOVF   x0E,W
40C2:  ADDWF  x04,W
40C4:  MOVWF  x14
40C6:  MOVF   x0F,W
40C8:  ADDWFC x05,W
40CA:  MOVWF  x15
40CC:  MOVF   x10,W
40CE:  ADDWFC x06,W
40D0:  MOVWF  x16
40D2:  MOVF   x11,W
40D4:  ADDWFC x07,W
40D6:  MOVWF  x17
40D8:  MOVWF  x1B
40DA:  MOVFF  916,91A
40DE:  MOVFF  915,919
40E2:  MOVFF  914,918
40E6:  MOVLB  0
40E8:  CALL   3468
40EC:  MOVFF  913,FEA
40F0:  MOVFF  912,FE9
40F4:  MOVFF  01,FEF
....................       delay_us(10); 
40F8:  MOVLW  1A
40FA:  MOVWF  00
40FC:  DECFSZ 00,F
40FE:  BRA    40FC
4100:  NOP   
....................    } 
4102:  MOVLW  01
4104:  MOVLB  9
4106:  ADDWF  x0E,F
4108:  BTFSC  FD8.0
410A:  INCF   x0F,F
410C:  BTFSC  FD8.2
410E:  INCF   x10,F
4110:  BTFSC  FD8.2
4112:  INCF   x11,F
4114:  BRA    4090
.................... } 
4116:  MOVLB  0
4118:  RETURN 0
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
5D2E:  MOVLB  7
5D30:  CLRF   xC1
5D32:  CLRF   xC0
5D34:  CLRF   xBF
5D36:  CLRF   xBE
5D38:  CLRF   xC5
5D3A:  CLRF   xC4
5D3C:  CLRF   xC3
5D3E:  CLRF   xC2
5D40:  CLRF   xC9
5D42:  CLRF   xC8
5D44:  CLRF   xC7
5D46:  CLRF   xC6
5D48:  CLRF   xCD
5D4A:  CLRF   xCC
5D4C:  CLRF   xCB
5D4E:  CLRF   xCA
5D50:  CLRF   xD1
5D52:  CLRF   xD0
5D54:  CLRF   xCF
5D56:  CLRF   xCE
5D58:  CLRF   19
5D5A:  BTFSC  FF2.7
5D5C:  BSF    19.7
5D5E:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
5D60:  MOVLB  9
5D62:  CLRF   x1B
5D64:  CLRF   x1A
5D66:  CLRF   x19
5D68:  MOVFF  7BD,918
5D6C:  MOVLB  0
5D6E:  CALL   3468
5D72:  BTFSC  19.7
5D74:  BSF    FF2.7
5D76:  MOVLB  7
5D78:  MOVFF  01,7C2
5D7C:  CLRF   xC3
5D7E:  CLRF   xC4
5D80:  CLRF   xC5
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
5D82:  MOVLW  01
5D84:  ADDWF  xBD,W
5D86:  MOVWF  xD2
5D88:  CLRF   19
5D8A:  BTFSC  FF2.7
5D8C:  BSF    19.7
5D8E:  BCF    FF2.7
5D90:  MOVLB  9
5D92:  CLRF   x1B
5D94:  CLRF   x1A
5D96:  CLRF   x19
5D98:  MOVWF  x18
5D9A:  MOVLB  0
5D9C:  CALL   3468
5DA0:  BTFSC  19.7
5DA2:  BSF    FF2.7
5DA4:  MOVLB  7
5DA6:  CLRF   xC9
5DA8:  CLRF   xC8
5DAA:  CLRF   xC7
5DAC:  MOVFF  01,7C6
....................    temp2<<=8; 
5DB0:  MOVFF  7C8,7C9
5DB4:  MOVFF  7C7,7C8
5DB8:  MOVFF  7C6,7C7
5DBC:  CLRF   xC6
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
5DBE:  MOVLW  02
5DC0:  ADDWF  xBD,W
5DC2:  MOVWF  xD2
5DC4:  CLRF   19
5DC6:  BTFSC  FF2.7
5DC8:  BSF    19.7
5DCA:  BCF    FF2.7
5DCC:  MOVLB  9
5DCE:  CLRF   x1B
5DD0:  CLRF   x1A
5DD2:  CLRF   x19
5DD4:  MOVWF  x18
5DD6:  MOVLB  0
5DD8:  CALL   3468
5DDC:  BTFSC  19.7
5DDE:  BSF    FF2.7
5DE0:  MOVLB  7
5DE2:  CLRF   xCD
5DE4:  CLRF   xCC
5DE6:  CLRF   xCB
5DE8:  MOVFF  01,7CA
....................    temp3<<=16; 
5DEC:  MOVFF  7CB,7CD
5DF0:  MOVFF  7CA,7CC
5DF4:  CLRF   xCA
5DF6:  CLRF   xCB
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
5DF8:  MOVLW  03
5DFA:  ADDWF  xBD,W
5DFC:  MOVWF  xD2
5DFE:  CLRF   19
5E00:  BTFSC  FF2.7
5E02:  BSF    19.7
5E04:  BCF    FF2.7
5E06:  MOVLB  9
5E08:  CLRF   x1B
5E0A:  CLRF   x1A
5E0C:  CLRF   x19
5E0E:  MOVWF  x18
5E10:  MOVLB  0
5E12:  CALL   3468
5E16:  BTFSC  19.7
5E18:  BSF    FF2.7
5E1A:  MOVLB  7
5E1C:  CLRF   xD1
5E1E:  CLRF   xD0
5E20:  CLRF   xCF
5E22:  MOVFF  01,7CE
....................    temp4<<=24; 
5E26:  MOVFF  7CE,7D1
5E2A:  CLRF   xCE
5E2C:  CLRF   xCF
5E2E:  CLRF   xD0
....................    buffer = temp4|temp3|temp2|temp1; 
5E30:  MOVF   xCE,W
5E32:  IORWF  xCA,W
5E34:  MOVWF  xD2
5E36:  MOVF   xCF,W
5E38:  IORWF  xCB,W
5E3A:  MOVWF  xD3
5E3C:  MOVF   xD0,W
5E3E:  IORWF  xCC,W
5E40:  MOVWF  xD4
5E42:  MOVF   xD1,W
5E44:  IORWF  xCD,W
5E46:  MOVWF  xD5
5E48:  MOVF   xC6,W
5E4A:  IORWF  xD2,F
5E4C:  MOVF   xC7,W
5E4E:  IORWF  xD3,F
5E50:  MOVF   xC8,W
5E52:  IORWF  xD4,F
5E54:  MOVF   xC9,W
5E56:  IORWF  xD5,F
5E58:  MOVF   xD2,W
5E5A:  IORWF  xC2,W
5E5C:  MOVWF  xBE
5E5E:  MOVF   xD3,W
5E60:  IORWF  xC3,W
5E62:  MOVWF  xBF
5E64:  MOVF   xD4,W
5E66:  IORWF  xC4,W
5E68:  MOVWF  xC0
5E6A:  MOVF   xD5,W
5E6C:  IORWF  xC5,W
5E6E:  MOVWF  xC1
....................    return(buffer); 
5E70:  MOVFF  7BE,00
5E74:  MOVFF  7BF,01
5E78:  MOVFF  7C0,02
5E7C:  MOVFF  7C1,03
.................... } 
5E80:  MOVLB  0
5E82:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3B7E:  MOVLB  9
3B80:  CLRF   x08
3B82:  CLRF   x07
3B84:  CLRF   x06
3B86:  CLRF   x05
3B88:  CLRF   x09
3B8A:  CLRF   x0A
3B8C:  CLRF   x0B
3B8E:  CLRF   x0C
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3B90:  MOVFF  903,908
3B94:  MOVFF  902,907
3B98:  MOVFF  901,906
3B9C:  MOVFF  900,905
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3BA0:  MOVFF  905,909
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3BA4:  MOVFF  906,90A
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3BA8:  MOVFF  907,90B
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3BAC:  MOVFF  908,90C
....................    write_ext_eeprom((addr+0),temp1); 
3BB0:  CLRF   x16
3BB2:  CLRF   x15
3BB4:  CLRF   x14
3BB6:  MOVFF  904,913
3BBA:  MOVFF  909,917
3BBE:  MOVLB  0
3BC0:  RCALL  3A80
....................    write_ext_eeprom((addr+1),temp2); 
3BC2:  MOVLW  01
3BC4:  MOVLB  9
3BC6:  ADDWF  x04,W
3BC8:  MOVWF  x0D
3BCA:  CLRF   x16
3BCC:  CLRF   x15
3BCE:  CLRF   x14
3BD0:  MOVWF  x13
3BD2:  MOVFF  90A,917
3BD6:  MOVLB  0
3BD8:  RCALL  3A80
....................    write_ext_eeprom((addr+2),temp3); 
3BDA:  MOVLW  02
3BDC:  MOVLB  9
3BDE:  ADDWF  x04,W
3BE0:  MOVWF  x0D
3BE2:  CLRF   x16
3BE4:  CLRF   x15
3BE6:  CLRF   x14
3BE8:  MOVWF  x13
3BEA:  MOVFF  90B,917
3BEE:  MOVLB  0
3BF0:  RCALL  3A80
....................    write_ext_eeprom((addr+3),temp4); 
3BF2:  MOVLW  03
3BF4:  MOVLB  9
3BF6:  ADDWF  x04,W
3BF8:  MOVWF  x0D
3BFA:  CLRF   x16
3BFC:  CLRF   x15
3BFE:  CLRF   x14
3C00:  MOVWF  x13
3C02:  MOVFF  90C,917
3C06:  MOVLB  0
3C08:  RCALL  3A80
.................... } 
3C0A:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
57F4:  MOVLB  8
57F6:  CLRF   x53
57F8:  CLRF   x52
57FA:  CLRF   x54
57FC:  CLRF   x55
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
57FE:  MOVFF  851,853
5802:  MOVFF  850,852
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
5806:  MOVFF  852,854
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
580A:  MOVF   x53,W
580C:  MOVWF  x55
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
580E:  MOVLB  9
5810:  CLRF   x16
5812:  CLRF   x15
5814:  CLRF   x14
5816:  MOVLW  24
5818:  MOVWF  x13
581A:  MOVFF  854,917
581E:  MOVLB  0
5820:  CALL   3A80
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
5824:  MOVLB  9
5826:  CLRF   x16
5828:  CLRF   x15
582A:  CLRF   x14
582C:  MOVLW  25
582E:  MOVWF  x13
5830:  MOVFF  855,917
5834:  MOVLB  0
5836:  CALL   3A80
.................... } 
583A:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
3534:  MOVLB  9
3536:  CLRF   x01
3538:  CLRF   x00
353A:  CLRF   x03
353C:  CLRF   x02
353E:  CLRF   x05
3540:  CLRF   x04
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
3542:  CLRF   x1B
3544:  CLRF   x1A
3546:  CLRF   x19
3548:  MOVLW  24
354A:  MOVWF  x18
354C:  MOVLB  0
354E:  RCALL  3468
3550:  MOVLB  9
3552:  MOVFF  01,902
3556:  CLRF   x03
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3558:  CLRF   x1B
355A:  CLRF   x1A
355C:  CLRF   x19
355E:  MOVLW  25
3560:  MOVWF  x18
3562:  MOVLB  0
3564:  RCALL  3468
3566:  MOVLB  9
3568:  CLRF   x05
356A:  MOVFF  01,904
....................    temp2<<=8; 
356E:  MOVFF  904,905
3572:  CLRF   x04
....................    buffer = temp2|temp1; 
3574:  MOVF   x04,W
3576:  IORWF  x02,W
3578:  MOVWF  x00
357A:  MOVF   x05,W
357C:  IORWF  x03,W
357E:  MOVWF  x01
....................    return(buffer); 
3580:  MOVFF  900,01
3584:  MOVFF  901,02
.................... } 
3588:  MOVLB  0
358A:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................    /*for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    }*/ 
....................    //fprintf(COM2," ptr_card=%lu\n\r",ptr_card); 
....................    /*for(i=ptr_start;i<ptr_card;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
*
680E:  CLRF   23
6810:  CLRF   22
6812:  CLRF   21
6814:  MOVLW  96
6816:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
6818:  CLRF   27
681A:  CLRF   26
681C:  MOVLW  E1
681E:  MOVWF  25
6820:  MOVLW  01
6822:  MOVWF  24
6824:  CLRF   19
6826:  BTFSC  FF2.7
6828:  BSF    19.7
682A:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
682C:  MOVFF  23,903
6830:  MOVFF  22,902
6834:  MOVFF  21,901
6838:  MOVFF  20,900
683C:  MOVLW  19
683E:  MOVLB  9
6840:  MOVWF  x04
6842:  MOVLB  0
6844:  CALL   3B7E
6848:  BTFSC  19.7
684A:  BSF    FF2.7
684C:  CLRF   19
684E:  BTFSC  FF2.7
6850:  BSF    19.7
6852:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
6854:  MOVFF  27,903
6858:  MOVFF  26,902
685C:  MOVFF  25,901
6860:  MOVFF  24,900
6864:  MOVLW  1E
6866:  MOVLB  9
6868:  MOVWF  x04
686A:  MOVLB  0
686C:  CALL   3B7E
6870:  BTFSC  19.7
6872:  BSF    FF2.7
6874:  CLRF   19
6876:  BTFSC  FF2.7
6878:  BSF    19.7
687A:  BCF    FF2.7
....................    save_coutcard(0); 
687C:  MOVLB  8
687E:  CLRF   x51
6880:  CLRF   x50
6882:  MOVLB  0
6884:  CALL   57F4
6888:  BTFSC  19.7
688A:  BSF    FF2.7
688C:  CLRF   19
688E:  BTFSC  FF2.7
6890:  BSF    19.7
6892:  BCF    FF2.7
....................    countcard=get_countcard(); 
6894:  CALL   3534
6898:  BTFSC  19.7
689A:  BSF    FF2.7
689C:  MOVFF  02,FE
68A0:  MOVFF  01,FD
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
68A4:  GOTO   6B3C (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    ptr_card=ptr_start; 
68A8:  CLRF   23
68AA:  CLRF   22
68AC:  CLRF   21
68AE:  MOVLW  96
68B0:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
68B2:  CLRF   27
68B4:  CLRF   26
68B6:  MOVLW  E1
68B8:  MOVWF  25
68BA:  MOVLW  01
68BC:  MOVWF  24
68BE:  CLRF   19
68C0:  BTFSC  FF2.7
68C2:  BSF    19.7
68C4:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
68C6:  MOVFF  23,903
68CA:  MOVFF  22,902
68CE:  MOVFF  21,901
68D2:  MOVFF  20,900
68D6:  MOVLW  19
68D8:  MOVLB  9
68DA:  MOVWF  x04
68DC:  MOVLB  0
68DE:  CALL   3B7E
68E2:  BTFSC  19.7
68E4:  BSF    FF2.7
68E6:  CLRF   19
68E8:  BTFSC  FF2.7
68EA:  BSF    19.7
68EC:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
68EE:  MOVFF  27,903
68F2:  MOVFF  26,902
68F6:  MOVFF  25,901
68FA:  MOVFF  24,900
68FE:  MOVLW  1E
6900:  MOVLB  9
6902:  MOVWF  x04
6904:  MOVLB  0
6906:  CALL   3B7E
690A:  BTFSC  19.7
690C:  BSF    FF2.7
690E:  CLRF   19
6910:  BTFSC  FF2.7
6912:  BSF    19.7
6914:  BCF    FF2.7
....................    save_coutcard(0); 
6916:  MOVLB  8
6918:  CLRF   x51
691A:  CLRF   x50
691C:  MOVLB  0
691E:  CALL   57F4
6922:  BTFSC  19.7
6924:  BSF    FF2.7
.................... } 
6926:  GOTO   6BA0 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
*
5C72:  CLRF   19
5C74:  BTFSC  FF2.7
5C76:  BSF    19.7
5C78:  BCF    FF2.7
....................       EEPROM_read(strobe_pass_addr,20,password); 
5C7A:  MOVLB  9
5C7C:  CLRF   x07
5C7E:  CLRF   x06
5C80:  CLRF   x05
5C82:  CLRF   x04
5C84:  CLRF   x0B
5C86:  CLRF   x0A
5C88:  CLRF   x09
5C8A:  MOVLW  14
5C8C:  MOVWF  x08
5C8E:  CLRF   x0D
5C90:  MOVLW  55
5C92:  MOVWF  x0C
5C94:  MOVLB  0
5C96:  CALL   4086
5C9A:  BTFSC  19.7
5C9C:  BSF    FF2.7
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5C9E:  INCFSZ 55,W
5CA0:  BRA    5D2C
5CA2:  INCFSZ 56,W
5CA4:  BRA    5D2C
5CA6:  INCFSZ x64,W
5CA8:  BRA    5D2C
....................       { 
....................          memset(buffer1,0,20); 
5CAA:  CLRF   FEA
5CAC:  MOVLW  2D
5CAE:  MOVWF  FE9
5CB0:  CLRF   00
5CB2:  CLRF   02
5CB4:  MOVLW  14
5CB6:  MOVWF  01
5CB8:  CALL   35AE
....................          strcpy(buffer1,"admin"); 
5CBC:  CLRF   FEA
5CBE:  MOVLW  2D
5CC0:  MOVWF  FE9
5CC2:  MOVLW  00
5CC4:  CALL   00BA
5CC8:  TBLRD*-
5CCA:  TBLRD*+
5CCC:  MOVF   FF5,W
5CCE:  MOVWF  FEE
5CD0:  IORLW  00
5CD2:  BNZ   5CCA
5CD4:  CLRF   19
5CD6:  BTFSC  FF2.7
5CD8:  BSF    19.7
5CDA:  BCF    FF2.7
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
5CDC:  MOVLB  9
5CDE:  CLRF   x03
5CE0:  CLRF   x02
5CE2:  CLRF   x01
5CE4:  CLRF   x00
5CE6:  CLRF   x07
5CE8:  CLRF   x06
5CEA:  CLRF   x05
5CEC:  MOVLW  14
5CEE:  MOVWF  x04
5CF0:  CLRF   x09
5CF2:  MOVLW  2D
5CF4:  MOVWF  x08
5CF6:  MOVLB  0
5CF8:  CALL   4DF0
5CFC:  BTFSC  19.7
5CFE:  BSF    FF2.7
5D00:  CLRF   19
5D02:  BTFSC  FF2.7
5D04:  BSF    19.7
5D06:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
5D08:  MOVLB  9
5D0A:  CLRF   x07
5D0C:  CLRF   x06
5D0E:  CLRF   x05
5D10:  CLRF   x04
5D12:  CLRF   x0B
5D14:  CLRF   x0A
5D16:  CLRF   x09
5D18:  MOVLW  14
5D1A:  MOVWF  x08
5D1C:  CLRF   x0D
5D1E:  MOVLW  55
5D20:  MOVWF  x0C
5D22:  MOVLB  0
5D24:  CALL   4086
5D28:  BTFSC  19.7
5D2A:  BSF    FF2.7
....................       } 
.................... } 
5D2C:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
692A:  MOVLB  8
692C:  CLRF   x07
692E:  MOVF   x07,W
6930:  SUBLW  13
6932:  BNC   6948
6934:  CLRF   03
6936:  MOVF   x07,W
6938:  ADDLW  F3
693A:  MOVWF  FE9
693C:  MOVLW  07
693E:  ADDWFC 03,W
6940:  MOVWF  FEA
6942:  SETF   FEF
6944:  INCF   x07,F
6946:  BRA    692E
6948:  CLRF   19
694A:  BTFSC  FF2.7
694C:  BSF    19.7
694E:  BCF    FF2.7
....................    EEPROM_write(strobe_pass_addr,20,buf); 
6950:  MOVLB  9
6952:  CLRF   x03
6954:  CLRF   x02
6956:  CLRF   x01
6958:  CLRF   x00
695A:  CLRF   x07
695C:  CLRF   x06
695E:  CLRF   x05
6960:  MOVLW  14
6962:  MOVWF  x04
6964:  MOVLW  07
6966:  MOVWF  x09
6968:  MOVLW  F3
696A:  MOVWF  x08
696C:  MOVLB  0
696E:  CALL   4DF0
6972:  BTFSC  19.7
6974:  BSF    FF2.7
.................... } 
6976:  GOTO   6C04 (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
....................  
.................... #define CRYPTO_KEY_SIZE   32 
....................  
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 cryption_enable=0; 
....................  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int16 galois_mul2(unsigned int16 value) 
.................... { 
....................   signed int16 temp; 
....................   // cast to signed value 
....................   temp = (signed char) value; 
*
411A:  CLRF   03
411C:  MOVLB  9
411E:  MOVF   x0D,W
4120:  BTFSC  FE8.7
4122:  DECF   03,F
4124:  MOVWF  x0F
4126:  MOVFF  03,910
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
412A:  RRCF   x10,W
412C:  MOVWF  03
412E:  RRCF   x0F,W
4130:  MOVWF  02
4132:  RRCF   03,F
4134:  RRCF   02,F
4136:  RRCF   03,F
4138:  RRCF   02,F
413A:  RRCF   03,F
413C:  RRCF   02,F
413E:  RRCF   03,F
4140:  RRCF   02,F
4142:  RRCF   03,F
4144:  RRCF   02,F
4146:  RRCF   03,F
4148:  RRCF   02,F
414A:  MOVLW  01
414C:  ANDWF  03,F
414E:  MOVFF  02,90F
4152:  MOVFF  03,910
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
4156:  MOVLW  1B
4158:  ANDWF  x0F,F
415A:  CLRF   x10
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
415C:  BCF    FD8.0
415E:  RLCF   x0D,W
4160:  MOVWF  x11
4162:  RLCF   x0E,W
4164:  MOVWF  x12
4166:  MOVF   x11,W
4168:  XORWF  x0F,W
416A:  MOVWF  00
416C:  MOVF   x12,W
416E:  XORWF  x10,W
4170:  MOVWF  03
4172:  MOVFF  00,01
4176:  MOVWF  02
.................... } 
4178:  MOVLB  0
417A:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................     unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................  
....................   // In case of decryption 
....................   if (dir != 0)  
417C:  MOVLB  9
417E:  MOVF   x04,F
4180:  BTFSC  FD8.2
4182:  BRA    434E
....................   { 
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
4184:  CLRF   x09
4186:  MOVF   x09,W
4188:  SUBLW  09
418A:  BTFSS  FD8.0
418C:  BRA    4304
....................       //key schedule 
....................       key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[round]); 
418E:  MOVFF  902,01
4192:  MOVFF  903,03
4196:  MOVFF  902,90B
419A:  MOVFF  903,90C
419E:  MOVLW  0D
41A0:  ADDWF  x02,W
41A2:  MOVWF  FE9
41A4:  MOVLW  00
41A6:  ADDWFC x03,W
41A8:  MOVWF  FEA
41AA:  CLRF   03
41AC:  MOVF   FEF,W
41AE:  MOVLB  0
41B0:  CALL   00D0
41B4:  MOVLB  9
41B6:  MOVWF  x0D
41B8:  MOVFF  902,FE9
41BC:  MOVFF  903,FEA
41C0:  MOVF   FEF,W
41C2:  XORWF  x0D,F
41C4:  CLRF   03
41C6:  MOVF   x09,W
41C8:  MOVLB  0
41CA:  CALL   02F0
41CE:  MOVWF  01
41D0:  MOVLB  9
41D2:  MOVF   x0D,W
41D4:  XORWF  01,W
41D6:  MOVFF  90C,FEA
41DA:  MOVFF  90B,FE9
41DE:  MOVWF  FEF
....................       key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
41E0:  MOVLW  01
41E2:  ADDWF  x02,W
41E4:  MOVWF  01
41E6:  MOVLW  00
41E8:  ADDWFC x03,W
41EA:  MOVWF  03
41EC:  MOVFF  01,90B
41F0:  MOVWF  x0C
41F2:  MOVLW  0E
41F4:  ADDWF  x02,W
41F6:  MOVWF  FE9
41F8:  MOVLW  00
41FA:  ADDWFC x03,W
41FC:  MOVWF  FEA
41FE:  CLRF   03
4200:  MOVF   FEF,W
4202:  MOVLB  0
4204:  CALL   00D0
4208:  MOVLB  9
420A:  MOVWF  x0D
420C:  MOVLW  01
420E:  ADDWF  x02,W
4210:  MOVWF  FE9
4212:  MOVLW  00
4214:  ADDWFC x03,W
4216:  MOVWF  FEA
4218:  MOVF   FEF,W
421A:  XORWF  x0D,W
421C:  MOVFF  90C,FEA
4220:  MOVFF  90B,FE9
4224:  MOVWF  FEF
....................       key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
4226:  MOVLW  02
4228:  ADDWF  x02,W
422A:  MOVWF  01
422C:  MOVLW  00
422E:  ADDWFC x03,W
4230:  MOVWF  03
4232:  MOVFF  01,90B
4236:  MOVWF  x0C
4238:  MOVLW  0F
423A:  ADDWF  x02,W
423C:  MOVWF  FE9
423E:  MOVLW  00
4240:  ADDWFC x03,W
4242:  MOVWF  FEA
4244:  CLRF   03
4246:  MOVF   FEF,W
4248:  MOVLB  0
424A:  CALL   00D0
424E:  MOVLB  9
4250:  MOVWF  x0D
4252:  MOVLW  02
4254:  ADDWF  x02,W
4256:  MOVWF  FE9
4258:  MOVLW  00
425A:  ADDWFC x03,W
425C:  MOVWF  FEA
425E:  MOVF   FEF,W
4260:  XORWF  x0D,W
4262:  MOVFF  90C,FEA
4266:  MOVFF  90B,FE9
426A:  MOVWF  FEF
....................       key[3] = (unsigned int8)(sbox[key[12]]^key[3]); 
426C:  MOVLW  03
426E:  ADDWF  x02,W
4270:  MOVWF  01
4272:  MOVLW  00
4274:  ADDWFC x03,W
4276:  MOVWF  03
4278:  MOVFF  01,90B
427C:  MOVWF  x0C
427E:  MOVLW  0C
4280:  ADDWF  x02,W
4282:  MOVWF  FE9
4284:  MOVLW  00
4286:  ADDWFC x03,W
4288:  MOVWF  FEA
428A:  CLRF   03
428C:  MOVF   FEF,W
428E:  MOVLB  0
4290:  CALL   00D0
4294:  MOVLB  9
4296:  MOVWF  x0D
4298:  MOVLW  03
429A:  ADDWF  x02,W
429C:  MOVWF  FE9
429E:  MOVLW  00
42A0:  ADDWFC x03,W
42A2:  MOVWF  FEA
42A4:  MOVF   FEF,W
42A6:  XORWF  x0D,W
42A8:  MOVFF  90C,FEA
42AC:  MOVFF  90B,FE9
42B0:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
42B2:  MOVLW  04
42B4:  MOVWF  x0A
42B6:  MOVF   x0A,W
42B8:  SUBLW  0F
42BA:  BNC   4300
....................         key[i] = key[i] ^ key[i-4]; 
42BC:  CLRF   03
42BE:  MOVF   x0A,W
42C0:  ADDWF  x02,W
42C2:  MOVWF  01
42C4:  MOVF   x03,W
42C6:  ADDWFC 03,F
42C8:  MOVFF  03,90C
42CC:  CLRF   03
42CE:  MOVF   x0A,W
42D0:  ADDWF  x02,W
42D2:  MOVWF  FE9
42D4:  MOVF   x03,W
42D6:  ADDWFC 03,W
42D8:  MOVWF  FEA
42DA:  MOVFF  FEF,90D
42DE:  MOVLW  04
42E0:  SUBWF  x0A,W
42E2:  CLRF   03
42E4:  ADDWF  x02,W
42E6:  MOVWF  FE9
42E8:  MOVF   x03,W
42EA:  ADDWFC 03,W
42EC:  MOVWF  FEA
42EE:  MOVF   FEF,W
42F0:  XORWF  x0D,W
42F2:  MOVFF  90C,FEA
42F6:  MOVFF  01,FE9
42FA:  MOVWF  FEF
....................       } 
42FC:  INCF   x0A,F
42FE:  BRA    42B6
....................     } 
4300:  INCF   x09,F
4302:  BRA    4186
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++) 
4304:  CLRF   x0A
4306:  MOVF   x0A,W
4308:  SUBLW  0F
430A:  BNC   434E
....................     { 
....................       state[i]=state[i] ^ key[i]; 
430C:  CLRF   03
430E:  MOVF   x0A,W
4310:  ADDWF  x00,W
4312:  MOVWF  01
4314:  MOVF   x01,W
4316:  ADDWFC 03,F
4318:  MOVFF  03,90C
431C:  CLRF   03
431E:  MOVF   x0A,W
4320:  ADDWF  x00,W
4322:  MOVWF  FE9
4324:  MOVF   x01,W
4326:  ADDWFC 03,W
4328:  MOVWF  FEA
432A:  MOVFF  FEF,90D
432E:  CLRF   03
4330:  MOVF   x0A,W
4332:  ADDWF  x02,W
4334:  MOVWF  FE9
4336:  MOVF   x03,W
4338:  ADDWFC 03,W
433A:  MOVWF  FEA
433C:  MOVF   FEF,W
433E:  XORWF  x0D,W
4340:  MOVFF  90C,FEA
4344:  MOVFF  01,FE9
4348:  MOVWF  FEF
....................     } 
434A:  INCF   x0A,F
434C:  BRA    4306
....................   } 
....................   // main loop 
....................   for (round = 0; round < 10; round++) 
434E:  CLRF   x09
4350:  MOVF   x09,W
4352:  SUBLW  09
4354:  BTFSS  FD8.0
4356:  GOTO   4D9E
....................   { 
....................     if (dir != 0) 
435A:  MOVF   x04,F
435C:  BTFSC  FD8.2
435E:  BRA    44D8
....................     { 
....................           //Inverse key schedule 
....................           for (i=15; i>3; --i)  
4360:  MOVLW  0F
4362:  MOVWF  x0A
4364:  MOVF   x0A,W
4366:  SUBLW  03
4368:  BC    43AE
....................           { 
....................             key[i] = key[i] ^ key[i-4]; 
436A:  CLRF   03
436C:  MOVF   x0A,W
436E:  ADDWF  x02,W
4370:  MOVWF  01
4372:  MOVF   x03,W
4374:  ADDWFC 03,F
4376:  MOVFF  03,90C
437A:  CLRF   03
437C:  MOVF   x0A,W
437E:  ADDWF  x02,W
4380:  MOVWF  FE9
4382:  MOVF   x03,W
4384:  ADDWFC 03,W
4386:  MOVWF  FEA
4388:  MOVFF  FEF,90D
438C:  MOVLW  04
438E:  SUBWF  x0A,W
4390:  CLRF   03
4392:  ADDWF  x02,W
4394:  MOVWF  FE9
4396:  MOVF   x03,W
4398:  ADDWFC 03,W
439A:  MOVWF  FEA
439C:  MOVF   FEF,W
439E:  XORWF  x0D,W
43A0:  MOVFF  90C,FEA
43A4:  MOVFF  01,FE9
43A8:  MOVWF  FEF
....................           }   
43AA:  DECF   x0A,F
43AC:  BRA    4364
....................           key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[9-round]); 
43AE:  MOVFF  902,01
43B2:  MOVFF  903,03
43B6:  MOVFF  902,90B
43BA:  MOVFF  903,90C
43BE:  MOVLW  0D
43C0:  ADDWF  x02,W
43C2:  MOVWF  FE9
43C4:  MOVLW  00
43C6:  ADDWFC x03,W
43C8:  MOVWF  FEA
43CA:  CLRF   03
43CC:  MOVF   FEF,W
43CE:  MOVLB  0
43D0:  CALL   00D0
43D4:  MOVLB  9
43D6:  MOVWF  x0D
43D8:  MOVFF  902,FE9
43DC:  MOVFF  903,FEA
43E0:  MOVF   FEF,W
43E2:  XORWF  x0D,F
43E4:  MOVLW  09
43E6:  BSF    FD8.0
43E8:  SUBFWB x09,W
43EA:  CLRF   03
43EC:  MOVLB  0
43EE:  CALL   02F0
43F2:  MOVWF  01
43F4:  MOVLB  9
43F6:  MOVF   x0D,W
43F8:  XORWF  01,W
43FA:  MOVFF  90C,FEA
43FE:  MOVFF  90B,FE9
4402:  MOVWF  FEF
....................           key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4404:  MOVLW  01
4406:  ADDWF  x02,W
4408:  MOVWF  01
440A:  MOVLW  00
440C:  ADDWFC x03,W
440E:  MOVWF  03
4410:  MOVFF  01,90B
4414:  MOVWF  x0C
4416:  MOVLW  0E
4418:  ADDWF  x02,W
441A:  MOVWF  FE9
441C:  MOVLW  00
441E:  ADDWFC x03,W
4420:  MOVWF  FEA
4422:  CLRF   03
4424:  MOVF   FEF,W
4426:  MOVLB  0
4428:  CALL   00D0
442C:  MOVLB  9
442E:  MOVWF  x0D
4430:  MOVLW  01
4432:  ADDWF  x02,W
4434:  MOVWF  FE9
4436:  MOVLW  00
4438:  ADDWFC x03,W
443A:  MOVWF  FEA
443C:  MOVF   FEF,W
443E:  XORWF  x0D,W
4440:  MOVFF  90C,FEA
4444:  MOVFF  90B,FE9
4448:  MOVWF  FEF
....................           key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
444A:  MOVLW  02
444C:  ADDWF  x02,W
444E:  MOVWF  01
4450:  MOVLW  00
4452:  ADDWFC x03,W
4454:  MOVWF  03
4456:  MOVFF  01,90B
445A:  MOVWF  x0C
445C:  MOVLW  0F
445E:  ADDWF  x02,W
4460:  MOVWF  FE9
4462:  MOVLW  00
4464:  ADDWFC x03,W
4466:  MOVWF  FEA
4468:  CLRF   03
446A:  MOVF   FEF,W
446C:  MOVLB  0
446E:  CALL   00D0
4472:  MOVLB  9
4474:  MOVWF  x0D
4476:  MOVLW  02
4478:  ADDWF  x02,W
447A:  MOVWF  FE9
447C:  MOVLW  00
447E:  ADDWFC x03,W
4480:  MOVWF  FEA
4482:  MOVF   FEF,W
4484:  XORWF  x0D,W
4486:  MOVFF  90C,FEA
448A:  MOVFF  90B,FE9
448E:  MOVWF  FEF
....................           key[3] = (unsigned int8)(sbox[key[12]]^key[3]);  
4490:  MOVLW  03
4492:  ADDWF  x02,W
4494:  MOVWF  01
4496:  MOVLW  00
4498:  ADDWFC x03,W
449A:  MOVWF  03
449C:  MOVFF  01,90B
44A0:  MOVWF  x0C
44A2:  MOVLW  0C
44A4:  ADDWF  x02,W
44A6:  MOVWF  FE9
44A8:  MOVLW  00
44AA:  ADDWFC x03,W
44AC:  MOVWF  FEA
44AE:  CLRF   03
44B0:  MOVF   FEF,W
44B2:  MOVLB  0
44B4:  CALL   00D0
44B8:  MOVLB  9
44BA:  MOVWF  x0D
44BC:  MOVLW  03
44BE:  ADDWF  x02,W
44C0:  MOVWF  FE9
44C2:  MOVLW  00
44C4:  ADDWFC x03,W
44C6:  MOVWF  FEA
44C8:  MOVF   FEF,W
44CA:  XORWF  x0D,W
44CC:  MOVFF  90C,FEA
44D0:  MOVFF  90B,FE9
44D4:  MOVWF  FEF
....................     }  
....................     else  
44D6:  BRA    46F0
....................     { 
....................         for (i = 0; i <16; i++) 
44D8:  CLRF   x0A
44DA:  MOVF   x0A,W
44DC:  SUBLW  0F
44DE:  BNC   4530
....................         { 
....................             // with shiftrow i+5 mod 16 
....................             state[i]=sbox[state[i] ^ key[i]]; 
44E0:  CLRF   03
44E2:  MOVF   x0A,W
44E4:  ADDWF  x00,W
44E6:  MOVWF  01
44E8:  MOVF   x01,W
44EA:  ADDWFC 03,F
44EC:  MOVFF  01,90B
44F0:  MOVFF  03,90C
44F4:  CLRF   03
44F6:  MOVF   x0A,W
44F8:  ADDWF  x00,W
44FA:  MOVWF  FE9
44FC:  MOVF   x01,W
44FE:  ADDWFC 03,W
4500:  MOVWF  FEA
4502:  MOVFF  FEF,90D
4506:  CLRF   03
4508:  MOVF   x0A,W
450A:  ADDWF  x02,W
450C:  MOVWF  FE9
450E:  MOVF   x03,W
4510:  ADDWFC 03,W
4512:  MOVWF  FEA
4514:  MOVF   FEF,W
4516:  XORWF  x0D,W
4518:  CLRF   03
451A:  MOVLB  0
451C:  CALL   00D0
4520:  MOVFF  90C,FEA
4524:  MOVFF  90B,FE9
4528:  MOVWF  FEF
....................         } 
452A:  MOVLB  9
452C:  INCF   x0A,F
452E:  BRA    44DA
....................         //shift rows 
....................         buf1 = state[1]; 
4530:  MOVLW  01
4532:  ADDWF  x00,W
4534:  MOVWF  FE9
4536:  MOVLW  00
4538:  ADDWFC x01,W
453A:  MOVWF  FEA
453C:  MOVFF  FEF,905
....................         state[1] = state[5]; 
4540:  MOVLW  01
4542:  ADDWF  x00,W
4544:  MOVWF  01
4546:  MOVLW  00
4548:  ADDWFC x01,W
454A:  MOVWF  03
454C:  MOVLW  05
454E:  ADDWF  x00,W
4550:  MOVWF  FE9
4552:  MOVLW  00
4554:  ADDWFC x01,W
4556:  MOVWF  FEA
4558:  MOVFF  FEF,90D
455C:  MOVFF  03,FEA
4560:  MOVFF  01,FE9
4564:  MOVFF  90D,FEF
....................         state[5] = state[9]; 
4568:  MOVLW  05
456A:  ADDWF  x00,W
456C:  MOVWF  01
456E:  MOVLW  00
4570:  ADDWFC x01,W
4572:  MOVWF  03
4574:  MOVLW  09
4576:  ADDWF  x00,W
4578:  MOVWF  FE9
457A:  MOVLW  00
457C:  ADDWFC x01,W
457E:  MOVWF  FEA
4580:  MOVFF  FEF,90D
4584:  MOVFF  03,FEA
4588:  MOVFF  01,FE9
458C:  MOVFF  90D,FEF
....................         state[9] = state[13]; 
4590:  MOVLW  09
4592:  ADDWF  x00,W
4594:  MOVWF  01
4596:  MOVLW  00
4598:  ADDWFC x01,W
459A:  MOVWF  03
459C:  MOVLW  0D
459E:  ADDWF  x00,W
45A0:  MOVWF  FE9
45A2:  MOVLW  00
45A4:  ADDWFC x01,W
45A6:  MOVWF  FEA
45A8:  MOVFF  FEF,90D
45AC:  MOVFF  03,FEA
45B0:  MOVFF  01,FE9
45B4:  MOVFF  90D,FEF
....................         state[13] = buf1; 
45B8:  MOVLW  0D
45BA:  ADDWF  x00,W
45BC:  MOVWF  FE9
45BE:  MOVLW  00
45C0:  ADDWFC x01,W
45C2:  MOVWF  FEA
45C4:  MOVFF  905,FEF
....................      
....................         buf1 = state[2]; 
45C8:  MOVLW  02
45CA:  ADDWF  x00,W
45CC:  MOVWF  FE9
45CE:  MOVLW  00
45D0:  ADDWFC x01,W
45D2:  MOVWF  FEA
45D4:  MOVFF  FEF,905
....................         buf2 = state[6]; 
45D8:  MOVLW  06
45DA:  ADDWF  x00,W
45DC:  MOVWF  FE9
45DE:  MOVLW  00
45E0:  ADDWFC x01,W
45E2:  MOVWF  FEA
45E4:  MOVFF  FEF,906
....................         state[2] = state[10]; 
45E8:  MOVLW  02
45EA:  ADDWF  x00,W
45EC:  MOVWF  01
45EE:  MOVLW  00
45F0:  ADDWFC x01,W
45F2:  MOVWF  03
45F4:  MOVLW  0A
45F6:  ADDWF  x00,W
45F8:  MOVWF  FE9
45FA:  MOVLW  00
45FC:  ADDWFC x01,W
45FE:  MOVWF  FEA
4600:  MOVFF  FEF,90D
4604:  MOVFF  03,FEA
4608:  MOVFF  01,FE9
460C:  MOVFF  90D,FEF
....................         state[6] = state[14]; 
4610:  MOVLW  06
4612:  ADDWF  x00,W
4614:  MOVWF  01
4616:  MOVLW  00
4618:  ADDWFC x01,W
461A:  MOVWF  03
461C:  MOVLW  0E
461E:  ADDWF  x00,W
4620:  MOVWF  FE9
4622:  MOVLW  00
4624:  ADDWFC x01,W
4626:  MOVWF  FEA
4628:  MOVFF  FEF,90D
462C:  MOVFF  03,FEA
4630:  MOVFF  01,FE9
4634:  MOVFF  90D,FEF
....................         state[10] = buf1; 
4638:  MOVLW  0A
463A:  ADDWF  x00,W
463C:  MOVWF  FE9
463E:  MOVLW  00
4640:  ADDWFC x01,W
4642:  MOVWF  FEA
4644:  MOVFF  905,FEF
....................         state[14] = buf2; 
4648:  MOVLW  0E
464A:  ADDWF  x00,W
464C:  MOVWF  FE9
464E:  MOVLW  00
4650:  ADDWFC x01,W
4652:  MOVWF  FEA
4654:  MOVFF  906,FEF
....................      
....................         buf1 = state[15]; 
4658:  MOVLW  0F
465A:  ADDWF  x00,W
465C:  MOVWF  FE9
465E:  MOVLW  00
4660:  ADDWFC x01,W
4662:  MOVWF  FEA
4664:  MOVFF  FEF,905
....................         state[15] = state[11]; 
4668:  MOVLW  0F
466A:  ADDWF  x00,W
466C:  MOVWF  01
466E:  MOVLW  00
4670:  ADDWFC x01,W
4672:  MOVWF  03
4674:  MOVLW  0B
4676:  ADDWF  x00,W
4678:  MOVWF  FE9
467A:  MOVLW  00
467C:  ADDWFC x01,W
467E:  MOVWF  FEA
4680:  MOVFF  FEF,90D
4684:  MOVFF  03,FEA
4688:  MOVFF  01,FE9
468C:  MOVFF  90D,FEF
....................         state[11] = state[7]; 
4690:  MOVLW  0B
4692:  ADDWF  x00,W
4694:  MOVWF  01
4696:  MOVLW  00
4698:  ADDWFC x01,W
469A:  MOVWF  03
469C:  MOVLW  07
469E:  ADDWF  x00,W
46A0:  MOVWF  FE9
46A2:  MOVLW  00
46A4:  ADDWFC x01,W
46A6:  MOVWF  FEA
46A8:  MOVFF  FEF,90D
46AC:  MOVFF  03,FEA
46B0:  MOVFF  01,FE9
46B4:  MOVFF  90D,FEF
....................         state[7] = state[3]; 
46B8:  MOVLW  07
46BA:  ADDWF  x00,W
46BC:  MOVWF  01
46BE:  MOVLW  00
46C0:  ADDWFC x01,W
46C2:  MOVWF  03
46C4:  MOVLW  03
46C6:  ADDWF  x00,W
46C8:  MOVWF  FE9
46CA:  MOVLW  00
46CC:  ADDWFC x01,W
46CE:  MOVWF  FEA
46D0:  MOVFF  FEF,90D
46D4:  MOVFF  03,FEA
46D8:  MOVFF  01,FE9
46DC:  MOVFF  90D,FEF
....................         state[3] = buf1; 
46E0:  MOVLW  03
46E2:  ADDWF  x00,W
46E4:  MOVWF  FE9
46E6:  MOVLW  00
46E8:  ADDWFC x01,W
46EA:  MOVWF  FEA
46EC:  MOVFF  905,FEF
....................     } 
....................      
....................     //mixcol - inv mix 
....................     if (((round > 0) && (dir != 0)) || ((round < 9) && (dir == 0)))  
46F0:  MOVF   x09,F
46F2:  BZ    46F8
46F4:  MOVF   x04,F
46F6:  BNZ   4706
46F8:  MOVF   x09,W
46FA:  SUBLW  08
46FC:  BTFSS  FD8.0
46FE:  BRA    4A06
4700:  MOVF   x04,F
4702:  BTFSS  FD8.2
4704:  BRA    4A06
....................     { 
....................           for (i=0; i <4; i++) 
4706:  CLRF   x0A
4708:  MOVF   x0A,W
470A:  SUBLW  03
470C:  BTFSS  FD8.0
470E:  BRA    4A06
....................           { 
....................                 buf4 = (unsigned int8)(i << 2); 
4710:  RLCF   x0A,W
4712:  MOVWF  x08
4714:  RLCF   x08,F
4716:  MOVLW  FC
4718:  ANDWF  x08,F
....................                 if (dir != 0) 
471A:  MOVF   x04,F
471C:  BZ    4806
....................                 { 
....................                       // precompute for decryption 
....................                       buf1 = galois_mul2(galois_mul2((unsigned int8)(state[buf4]^state[buf4+2]))); 
471E:  CLRF   03
4720:  MOVF   x08,W
4722:  ADDWF  x00,W
4724:  MOVWF  FE9
4726:  MOVF   x01,W
4728:  ADDWFC 03,W
472A:  MOVWF  FEA
472C:  MOVFF  FEF,90B
4730:  MOVLW  02
4732:  ADDWF  x08,W
4734:  CLRF   03
4736:  ADDWF  x00,W
4738:  MOVWF  FE9
473A:  MOVF   x01,W
473C:  ADDWFC 03,W
473E:  MOVWF  FEA
4740:  MOVF   FEF,W
4742:  XORWF  x0B,F
4744:  CLRF   x0E
4746:  MOVFF  90B,90D
474A:  MOVLB  0
474C:  RCALL  411A
474E:  MOVFF  02,90C
4752:  MOVFF  01,90B
4756:  MOVFF  02,90E
475A:  MOVFF  01,90D
475E:  RCALL  411A
4760:  MOVFF  01,905
....................                       buf2 = galois_mul2(galois_mul2((unsigned int8)(state[buf4+1]^state[buf4+3]))); 
4764:  MOVLW  01
4766:  MOVLB  9
4768:  ADDWF  x08,W
476A:  CLRF   03
476C:  ADDWF  x00,W
476E:  MOVWF  FE9
4770:  MOVF   x01,W
4772:  ADDWFC 03,W
4774:  MOVWF  FEA
4776:  MOVFF  FEF,90B
477A:  MOVLW  03
477C:  ADDWF  x08,W
477E:  CLRF   03
4780:  ADDWF  x00,W
4782:  MOVWF  FE9
4784:  MOVF   x01,W
4786:  ADDWFC 03,W
4788:  MOVWF  FEA
478A:  MOVF   FEF,W
478C:  XORWF  x0B,F
478E:  CLRF   x0E
4790:  MOVFF  90B,90D
4794:  MOVLB  0
4796:  RCALL  411A
4798:  MOVFF  02,90C
479C:  MOVFF  01,90B
47A0:  MOVFF  02,90E
47A4:  MOVFF  01,90D
47A8:  RCALL  411A
47AA:  MOVFF  01,906
....................                       state[buf4] ^= buf1;  
47AE:  CLRF   03
47B0:  MOVLB  9
47B2:  MOVF   x08,W
47B4:  ADDWF  x00,W
47B6:  MOVWF  FE9
47B8:  MOVF   x01,W
47BA:  ADDWFC 03,W
47BC:  MOVWF  FEA
47BE:  MOVF   FEF,W
47C0:  XORWF  x05,W
47C2:  MOVWF  FEF
....................                       state[buf4+1] ^= buf2;  
47C4:  MOVLW  01
47C6:  ADDWF  x08,W
47C8:  CLRF   03
47CA:  ADDWF  x00,W
47CC:  MOVWF  FE9
47CE:  MOVF   x01,W
47D0:  ADDWFC 03,W
47D2:  MOVWF  FEA
47D4:  MOVF   FEF,W
47D6:  XORWF  x06,W
47D8:  MOVWF  FEF
....................                       state[buf4+2] ^= buf1;  
47DA:  MOVLW  02
47DC:  ADDWF  x08,W
47DE:  CLRF   03
47E0:  ADDWF  x00,W
47E2:  MOVWF  FE9
47E4:  MOVF   x01,W
47E6:  ADDWFC 03,W
47E8:  MOVWF  FEA
47EA:  MOVF   FEF,W
47EC:  XORWF  x05,W
47EE:  MOVWF  FEF
....................                       state[buf4+3] ^= buf2;  
47F0:  MOVLW  03
47F2:  ADDWF  x08,W
47F4:  CLRF   03
47F6:  ADDWF  x00,W
47F8:  MOVWF  FE9
47FA:  MOVF   x01,W
47FC:  ADDWFC 03,W
47FE:  MOVWF  FEA
4800:  MOVF   FEF,W
4802:  XORWF  x06,W
4804:  MOVWF  FEF
....................                 } 
....................                 // in all cases 
....................                 buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
4806:  CLRF   03
4808:  MOVF   x08,W
480A:  ADDWF  x00,W
480C:  MOVWF  FE9
480E:  MOVF   x01,W
4810:  ADDWFC 03,W
4812:  MOVWF  FEA
4814:  MOVFF  FEF,90B
4818:  MOVLW  01
481A:  ADDWF  x08,W
481C:  CLRF   03
481E:  ADDWF  x00,W
4820:  MOVWF  FE9
4822:  MOVF   x01,W
4824:  ADDWFC 03,W
4826:  MOVWF  FEA
4828:  MOVF   FEF,W
482A:  XORWF  x0B,F
482C:  MOVLW  02
482E:  ADDWF  x08,W
4830:  CLRF   03
4832:  ADDWF  x00,W
4834:  MOVWF  FE9
4836:  MOVF   x01,W
4838:  ADDWFC 03,W
483A:  MOVWF  FEA
483C:  MOVF   FEF,W
483E:  XORWF  x0B,F
4840:  MOVLW  03
4842:  ADDWF  x08,W
4844:  CLRF   03
4846:  ADDWF  x00,W
4848:  MOVWF  FE9
484A:  MOVF   x01,W
484C:  ADDWFC 03,W
484E:  MOVWF  FEA
4850:  MOVF   FEF,W
4852:  XORWF  x0B,W
4854:  MOVWF  x05
....................                 buf2 = state[buf4]; 
4856:  CLRF   03
4858:  MOVF   x08,W
485A:  ADDWF  x00,W
485C:  MOVWF  FE9
485E:  MOVF   x01,W
4860:  ADDWFC 03,W
4862:  MOVWF  FEA
4864:  MOVFF  FEF,906
....................                 buf3 = state[buf4]^state[buf4+1];  
4868:  CLRF   03
486A:  MOVF   x08,W
486C:  ADDWF  x00,W
486E:  MOVWF  FE9
4870:  MOVF   x01,W
4872:  ADDWFC 03,W
4874:  MOVWF  FEA
4876:  MOVFF  FEF,90B
487A:  MOVLW  01
487C:  ADDWF  x08,W
487E:  CLRF   03
4880:  ADDWF  x00,W
4882:  MOVWF  FE9
4884:  MOVF   x01,W
4886:  ADDWFC 03,W
4888:  MOVWF  FEA
488A:  MOVF   FEF,W
488C:  XORWF  x0B,W
488E:  MOVWF  x07
....................                 buf3=galois_mul2(buf3);  
4890:  CLRF   x0E
4892:  MOVFF  907,90D
4896:  MOVLB  0
4898:  RCALL  411A
489A:  MOVFF  01,907
....................                 state[buf4] = state[buf4] ^ buf3 ^ buf1; 
489E:  CLRF   03
48A0:  MOVLB  9
48A2:  MOVF   x08,W
48A4:  ADDWF  x00,W
48A6:  MOVWF  01
48A8:  MOVF   x01,W
48AA:  ADDWFC 03,F
48AC:  MOVFF  03,90C
48B0:  CLRF   03
48B2:  MOVF   x08,W
48B4:  ADDWF  x00,W
48B6:  MOVWF  FE9
48B8:  MOVF   x01,W
48BA:  ADDWFC 03,W
48BC:  MOVWF  FEA
48BE:  MOVF   FEF,W
48C0:  XORWF  x07,W
48C2:  XORWF  x05,W
48C4:  MOVFF  90C,FEA
48C8:  MOVFF  01,FE9
48CC:  MOVWF  FEF
....................                 buf3 = state[buf4+1]^state[buf4+2];  
48CE:  MOVLW  01
48D0:  ADDWF  x08,W
48D2:  CLRF   03
48D4:  ADDWF  x00,W
48D6:  MOVWF  FE9
48D8:  MOVF   x01,W
48DA:  ADDWFC 03,W
48DC:  MOVWF  FEA
48DE:  MOVFF  FEF,90B
48E2:  MOVLW  02
48E4:  ADDWF  x08,W
48E6:  CLRF   03
48E8:  ADDWF  x00,W
48EA:  MOVWF  FE9
48EC:  MOVF   x01,W
48EE:  ADDWFC 03,W
48F0:  MOVWF  FEA
48F2:  MOVF   FEF,W
48F4:  XORWF  x0B,W
48F6:  MOVWF  x07
....................                 buf3=galois_mul2(buf3);  
48F8:  CLRF   x0E
48FA:  MOVFF  907,90D
48FE:  MOVLB  0
4900:  RCALL  411A
4902:  MOVFF  01,907
....................                 state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
4906:  MOVLW  01
4908:  MOVLB  9
490A:  ADDWF  x08,W
490C:  CLRF   03
490E:  ADDWF  x00,W
4910:  MOVWF  01
4912:  MOVF   x01,W
4914:  ADDWFC 03,F
4916:  MOVFF  03,90C
491A:  MOVLW  01
491C:  ADDWF  x08,W
491E:  CLRF   03
4920:  ADDWF  x00,W
4922:  MOVWF  FE9
4924:  MOVF   x01,W
4926:  ADDWFC 03,W
4928:  MOVWF  FEA
492A:  MOVF   FEF,W
492C:  XORWF  x07,W
492E:  XORWF  x05,W
4930:  MOVFF  90C,FEA
4934:  MOVFF  01,FE9
4938:  MOVWF  FEF
....................                 buf3 = state[buf4+2]^state[buf4+3];  
493A:  MOVLW  02
493C:  ADDWF  x08,W
493E:  CLRF   03
4940:  ADDWF  x00,W
4942:  MOVWF  FE9
4944:  MOVF   x01,W
4946:  ADDWFC 03,W
4948:  MOVWF  FEA
494A:  MOVFF  FEF,90B
494E:  MOVLW  03
4950:  ADDWF  x08,W
4952:  CLRF   03
4954:  ADDWF  x00,W
4956:  MOVWF  FE9
4958:  MOVF   x01,W
495A:  ADDWFC 03,W
495C:  MOVWF  FEA
495E:  MOVF   FEF,W
4960:  XORWF  x0B,W
4962:  MOVWF  x07
....................                 buf3=galois_mul2(buf3);  
4964:  CLRF   x0E
4966:  MOVFF  907,90D
496A:  MOVLB  0
496C:  CALL   411A
4970:  MOVFF  01,907
....................                 state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
4974:  MOVLW  02
4976:  MOVLB  9
4978:  ADDWF  x08,W
497A:  CLRF   03
497C:  ADDWF  x00,W
497E:  MOVWF  01
4980:  MOVF   x01,W
4982:  ADDWFC 03,F
4984:  MOVFF  03,90C
4988:  MOVLW  02
498A:  ADDWF  x08,W
498C:  CLRF   03
498E:  ADDWF  x00,W
4990:  MOVWF  FE9
4992:  MOVF   x01,W
4994:  ADDWFC 03,W
4996:  MOVWF  FEA
4998:  MOVF   FEF,W
499A:  XORWF  x07,W
499C:  XORWF  x05,W
499E:  MOVFF  90C,FEA
49A2:  MOVFF  01,FE9
49A6:  MOVWF  FEF
....................                 buf3 = state[buf4+3]^buf2;      
49A8:  MOVLW  03
49AA:  ADDWF  x08,W
49AC:  CLRF   03
49AE:  ADDWF  x00,W
49B0:  MOVWF  FE9
49B2:  MOVF   x01,W
49B4:  ADDWFC 03,W
49B6:  MOVWF  FEA
49B8:  MOVF   FEF,W
49BA:  XORWF  x06,W
49BC:  MOVWF  x07
....................                 buf3=galois_mul2(buf3);  
49BE:  CLRF   x0E
49C0:  MOVFF  907,90D
49C4:  MOVLB  0
49C6:  CALL   411A
49CA:  MOVFF  01,907
....................                 state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1;  
49CE:  MOVLW  03
49D0:  MOVLB  9
49D2:  ADDWF  x08,W
49D4:  CLRF   03
49D6:  ADDWF  x00,W
49D8:  MOVWF  01
49DA:  MOVF   x01,W
49DC:  ADDWFC 03,F
49DE:  MOVFF  03,90C
49E2:  MOVLW  03
49E4:  ADDWF  x08,W
49E6:  CLRF   03
49E8:  ADDWF  x00,W
49EA:  MOVWF  FE9
49EC:  MOVF   x01,W
49EE:  ADDWFC 03,W
49F0:  MOVWF  FEA
49F2:  MOVF   FEF,W
49F4:  XORWF  x07,W
49F6:  XORWF  x05,W
49F8:  MOVFF  90C,FEA
49FC:  MOVFF  01,FE9
4A00:  MOVWF  FEF
....................           } 
4A02:  INCF   x0A,F
4A04:  BRA    4708
....................     } 
....................      
....................     if (dir != 0)  
4A06:  MOVF   x04,F
4A08:  BTFSC  FD8.2
4A0A:  BRA    4C26
....................     { 
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
4A0C:  MOVLW  0D
4A0E:  ADDWF  x00,W
4A10:  MOVWF  FE9
4A12:  MOVLW  00
4A14:  ADDWFC x01,W
4A16:  MOVWF  FEA
4A18:  MOVFF  FEF,905
....................       state[13] = state[9]; 
4A1C:  MOVLW  0D
4A1E:  ADDWF  x00,W
4A20:  MOVWF  01
4A22:  MOVLW  00
4A24:  ADDWFC x01,W
4A26:  MOVWF  03
4A28:  MOVLW  09
4A2A:  ADDWF  x00,W
4A2C:  MOVWF  FE9
4A2E:  MOVLW  00
4A30:  ADDWFC x01,W
4A32:  MOVWF  FEA
4A34:  MOVFF  FEF,90D
4A38:  MOVFF  03,FEA
4A3C:  MOVFF  01,FE9
4A40:  MOVFF  90D,FEF
....................       state[9] = state[5]; 
4A44:  MOVLW  09
4A46:  ADDWF  x00,W
4A48:  MOVWF  01
4A4A:  MOVLW  00
4A4C:  ADDWFC x01,W
4A4E:  MOVWF  03
4A50:  MOVLW  05
4A52:  ADDWF  x00,W
4A54:  MOVWF  FE9
4A56:  MOVLW  00
4A58:  ADDWFC x01,W
4A5A:  MOVWF  FEA
4A5C:  MOVFF  FEF,90D
4A60:  MOVFF  03,FEA
4A64:  MOVFF  01,FE9
4A68:  MOVFF  90D,FEF
....................       state[5] = state[1]; 
4A6C:  MOVLW  05
4A6E:  ADDWF  x00,W
4A70:  MOVWF  01
4A72:  MOVLW  00
4A74:  ADDWFC x01,W
4A76:  MOVWF  03
4A78:  MOVLW  01
4A7A:  ADDWF  x00,W
4A7C:  MOVWF  FE9
4A7E:  MOVLW  00
4A80:  ADDWFC x01,W
4A82:  MOVWF  FEA
4A84:  MOVFF  FEF,90D
4A88:  MOVFF  03,FEA
4A8C:  MOVFF  01,FE9
4A90:  MOVFF  90D,FEF
....................       state[1] = buf1; 
4A94:  MOVLW  01
4A96:  ADDWF  x00,W
4A98:  MOVWF  FE9
4A9A:  MOVLW  00
4A9C:  ADDWFC x01,W
4A9E:  MOVWF  FEA
4AA0:  MOVFF  905,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
4AA4:  MOVLW  0A
4AA6:  ADDWF  x00,W
4AA8:  MOVWF  FE9
4AAA:  MOVLW  00
4AAC:  ADDWFC x01,W
4AAE:  MOVWF  FEA
4AB0:  MOVFF  FEF,905
....................       buf2 = state[14]; 
4AB4:  MOVLW  0E
4AB6:  ADDWF  x00,W
4AB8:  MOVWF  FE9
4ABA:  MOVLW  00
4ABC:  ADDWFC x01,W
4ABE:  MOVWF  FEA
4AC0:  MOVFF  FEF,906
....................       state[10] = state[2]; 
4AC4:  MOVLW  0A
4AC6:  ADDWF  x00,W
4AC8:  MOVWF  01
4ACA:  MOVLW  00
4ACC:  ADDWFC x01,W
4ACE:  MOVWF  03
4AD0:  MOVLW  02
4AD2:  ADDWF  x00,W
4AD4:  MOVWF  FE9
4AD6:  MOVLW  00
4AD8:  ADDWFC x01,W
4ADA:  MOVWF  FEA
4ADC:  MOVFF  FEF,90D
4AE0:  MOVFF  03,FEA
4AE4:  MOVFF  01,FE9
4AE8:  MOVFF  90D,FEF
....................       state[14] = state[6]; 
4AEC:  MOVLW  0E
4AEE:  ADDWF  x00,W
4AF0:  MOVWF  01
4AF2:  MOVLW  00
4AF4:  ADDWFC x01,W
4AF6:  MOVWF  03
4AF8:  MOVLW  06
4AFA:  ADDWF  x00,W
4AFC:  MOVWF  FE9
4AFE:  MOVLW  00
4B00:  ADDWFC x01,W
4B02:  MOVWF  FEA
4B04:  MOVFF  FEF,90D
4B08:  MOVFF  03,FEA
4B0C:  MOVFF  01,FE9
4B10:  MOVFF  90D,FEF
....................       state[2] = buf1; 
4B14:  MOVLW  02
4B16:  ADDWF  x00,W
4B18:  MOVWF  FE9
4B1A:  MOVLW  00
4B1C:  ADDWFC x01,W
4B1E:  MOVWF  FEA
4B20:  MOVFF  905,FEF
....................       state[6] = buf2; 
4B24:  MOVLW  06
4B26:  ADDWF  x00,W
4B28:  MOVWF  FE9
4B2A:  MOVLW  00
4B2C:  ADDWFC x01,W
4B2E:  MOVWF  FEA
4B30:  MOVFF  906,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
4B34:  MOVLW  03
4B36:  ADDWF  x00,W
4B38:  MOVWF  FE9
4B3A:  MOVLW  00
4B3C:  ADDWFC x01,W
4B3E:  MOVWF  FEA
4B40:  MOVFF  FEF,905
....................       state[3] = state[7]; 
4B44:  MOVLW  03
4B46:  ADDWF  x00,W
4B48:  MOVWF  01
4B4A:  MOVLW  00
4B4C:  ADDWFC x01,W
4B4E:  MOVWF  03
4B50:  MOVLW  07
4B52:  ADDWF  x00,W
4B54:  MOVWF  FE9
4B56:  MOVLW  00
4B58:  ADDWFC x01,W
4B5A:  MOVWF  FEA
4B5C:  MOVFF  FEF,90D
4B60:  MOVFF  03,FEA
4B64:  MOVFF  01,FE9
4B68:  MOVFF  90D,FEF
....................       state[7] = state[11]; 
4B6C:  MOVLW  07
4B6E:  ADDWF  x00,W
4B70:  MOVWF  01
4B72:  MOVLW  00
4B74:  ADDWFC x01,W
4B76:  MOVWF  03
4B78:  MOVLW  0B
4B7A:  ADDWF  x00,W
4B7C:  MOVWF  FE9
4B7E:  MOVLW  00
4B80:  ADDWFC x01,W
4B82:  MOVWF  FEA
4B84:  MOVFF  FEF,90D
4B88:  MOVFF  03,FEA
4B8C:  MOVFF  01,FE9
4B90:  MOVFF  90D,FEF
....................       state[11] = state[15]; 
4B94:  MOVLW  0B
4B96:  ADDWF  x00,W
4B98:  MOVWF  01
4B9A:  MOVLW  00
4B9C:  ADDWFC x01,W
4B9E:  MOVWF  03
4BA0:  MOVLW  0F
4BA2:  ADDWF  x00,W
4BA4:  MOVWF  FE9
4BA6:  MOVLW  00
4BA8:  ADDWFC x01,W
4BAA:  MOVWF  FEA
4BAC:  MOVFF  FEF,90D
4BB0:  MOVFF  03,FEA
4BB4:  MOVFF  01,FE9
4BB8:  MOVFF  90D,FEF
....................       state[15] = buf1;          
4BBC:  MOVLW  0F
4BBE:  ADDWF  x00,W
4BC0:  MOVWF  FE9
4BC2:  MOVLW  00
4BC4:  ADDWFC x01,W
4BC6:  MOVWF  FEA
4BC8:  MOVFF  905,FEF
....................             
....................       for (i = 0; i <16; i++){ 
4BCC:  CLRF   x0A
4BCE:  MOVF   x0A,W
4BD0:  SUBLW  0F
4BD2:  BNC   4C24
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
4BD4:  CLRF   03
4BD6:  MOVF   x0A,W
4BD8:  ADDWF  x00,W
4BDA:  MOVWF  01
4BDC:  MOVF   x01,W
4BDE:  ADDWFC 03,F
4BE0:  MOVFF  01,90B
4BE4:  MOVFF  03,90C
4BE8:  CLRF   03
4BEA:  MOVF   x0A,W
4BEC:  ADDWF  x00,W
4BEE:  MOVWF  FE9
4BF0:  MOVF   x01,W
4BF2:  ADDWFC 03,W
4BF4:  MOVWF  FEA
4BF6:  CLRF   03
4BF8:  MOVF   FEF,W
4BFA:  MOVLB  0
4BFC:  CALL   01E0
4C00:  MOVLB  9
4C02:  MOVWF  x0D
4C04:  CLRF   03
4C06:  MOVF   x0A,W
4C08:  ADDWF  x02,W
4C0A:  MOVWF  FE9
4C0C:  MOVF   x03,W
4C0E:  ADDWFC 03,W
4C10:  MOVWF  FEA
4C12:  MOVF   FEF,W
4C14:  XORWF  x0D,W
4C16:  MOVFF  90C,FEA
4C1A:  MOVFF  90B,FE9
4C1E:  MOVWF  FEF
....................       }  
4C20:  INCF   x0A,F
4C22:  BRA    4BCE
....................     }  
....................     else  
4C24:  BRA    4D98
....................     { 
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
4C26:  MOVFF  902,01
4C2A:  MOVFF  903,03
4C2E:  MOVFF  902,90B
4C32:  MOVFF  903,90C
4C36:  MOVLW  0D
4C38:  ADDWF  x02,W
4C3A:  MOVWF  FE9
4C3C:  MOVLW  00
4C3E:  ADDWFC x03,W
4C40:  MOVWF  FEA
4C42:  CLRF   03
4C44:  MOVF   FEF,W
4C46:  MOVLB  0
4C48:  CALL   00D0
4C4C:  MOVLB  9
4C4E:  MOVWF  x0D
4C50:  MOVFF  902,FE9
4C54:  MOVFF  903,FEA
4C58:  MOVF   FEF,W
4C5A:  XORWF  x0D,F
4C5C:  CLRF   03
4C5E:  MOVF   x09,W
4C60:  MOVLB  0
4C62:  CALL   02F0
4C66:  MOVWF  01
4C68:  MOVLB  9
4C6A:  MOVF   x0D,W
4C6C:  XORWF  01,W
4C6E:  MOVFF  90C,FEA
4C72:  MOVFF  90B,FE9
4C76:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
4C78:  MOVLW  01
4C7A:  ADDWF  x02,W
4C7C:  MOVWF  01
4C7E:  MOVLW  00
4C80:  ADDWFC x03,W
4C82:  MOVWF  03
4C84:  MOVFF  01,90B
4C88:  MOVWF  x0C
4C8A:  MOVLW  0E
4C8C:  ADDWF  x02,W
4C8E:  MOVWF  FE9
4C90:  MOVLW  00
4C92:  ADDWFC x03,W
4C94:  MOVWF  FEA
4C96:  CLRF   03
4C98:  MOVF   FEF,W
4C9A:  MOVLB  0
4C9C:  CALL   00D0
4CA0:  MOVLB  9
4CA2:  MOVWF  x0D
4CA4:  MOVLW  01
4CA6:  ADDWF  x02,W
4CA8:  MOVWF  FE9
4CAA:  MOVLW  00
4CAC:  ADDWFC x03,W
4CAE:  MOVWF  FEA
4CB0:  MOVF   FEF,W
4CB2:  XORWF  x0D,W
4CB4:  MOVFF  90C,FEA
4CB8:  MOVFF  90B,FE9
4CBC:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
4CBE:  MOVLW  02
4CC0:  ADDWF  x02,W
4CC2:  MOVWF  01
4CC4:  MOVLW  00
4CC6:  ADDWFC x03,W
4CC8:  MOVWF  03
4CCA:  MOVFF  01,90B
4CCE:  MOVWF  x0C
4CD0:  MOVLW  0F
4CD2:  ADDWF  x02,W
4CD4:  MOVWF  FE9
4CD6:  MOVLW  00
4CD8:  ADDWFC x03,W
4CDA:  MOVWF  FEA
4CDC:  CLRF   03
4CDE:  MOVF   FEF,W
4CE0:  MOVLB  0
4CE2:  CALL   00D0
4CE6:  MOVLB  9
4CE8:  MOVWF  x0D
4CEA:  MOVLW  02
4CEC:  ADDWF  x02,W
4CEE:  MOVWF  FE9
4CF0:  MOVLW  00
4CF2:  ADDWFC x03,W
4CF4:  MOVWF  FEA
4CF6:  MOVF   FEF,W
4CF8:  XORWF  x0D,W
4CFA:  MOVFF  90C,FEA
4CFE:  MOVFF  90B,FE9
4D02:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
4D04:  MOVLW  03
4D06:  ADDWF  x02,W
4D08:  MOVWF  01
4D0A:  MOVLW  00
4D0C:  ADDWFC x03,W
4D0E:  MOVWF  03
4D10:  MOVFF  01,90B
4D14:  MOVWF  x0C
4D16:  MOVLW  0C
4D18:  ADDWF  x02,W
4D1A:  MOVWF  FE9
4D1C:  MOVLW  00
4D1E:  ADDWFC x03,W
4D20:  MOVWF  FEA
4D22:  CLRF   03
4D24:  MOVF   FEF,W
4D26:  MOVLB  0
4D28:  CALL   00D0
4D2C:  MOVLB  9
4D2E:  MOVWF  x0D
4D30:  MOVLW  03
4D32:  ADDWF  x02,W
4D34:  MOVWF  FE9
4D36:  MOVLW  00
4D38:  ADDWFC x03,W
4D3A:  MOVWF  FEA
4D3C:  MOVF   FEF,W
4D3E:  XORWF  x0D,W
4D40:  MOVFF  90C,FEA
4D44:  MOVFF  90B,FE9
4D48:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4D4A:  MOVLW  04
4D4C:  MOVWF  x0A
4D4E:  MOVF   x0A,W
4D50:  SUBLW  0F
4D52:  BNC   4D98
....................         key[i] = key[i] ^ key[i-4]; 
4D54:  CLRF   03
4D56:  MOVF   x0A,W
4D58:  ADDWF  x02,W
4D5A:  MOVWF  01
4D5C:  MOVF   x03,W
4D5E:  ADDWFC 03,F
4D60:  MOVFF  03,90C
4D64:  CLRF   03
4D66:  MOVF   x0A,W
4D68:  ADDWF  x02,W
4D6A:  MOVWF  FE9
4D6C:  MOVF   x03,W
4D6E:  ADDWFC 03,W
4D70:  MOVWF  FEA
4D72:  MOVFF  FEF,90D
4D76:  MOVLW  04
4D78:  SUBWF  x0A,W
4D7A:  CLRF   03
4D7C:  ADDWF  x02,W
4D7E:  MOVWF  FE9
4D80:  MOVF   x03,W
4D82:  ADDWFC 03,W
4D84:  MOVWF  FEA
4D86:  MOVF   FEF,W
4D88:  XORWF  x0D,W
4D8A:  MOVFF  90C,FEA
4D8E:  MOVFF  01,FE9
4D92:  MOVWF  FEF
....................       } 
4D94:  INCF   x0A,F
4D96:  BRA    4D4E
....................     } 
....................   } 
4D98:  INCF   x09,F
4D9A:  GOTO   4350
....................   if (dir == 0)  
4D9E:  MOVF   x04,F
4DA0:  BNZ   4DEC
....................   { 
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
4DA2:  CLRF   x0A
4DA4:  MOVF   x0A,W
4DA6:  SUBLW  0F
4DA8:  BNC   4DEC
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
4DAA:  CLRF   03
4DAC:  MOVF   x0A,W
4DAE:  ADDWF  x00,W
4DB0:  MOVWF  01
4DB2:  MOVF   x01,W
4DB4:  ADDWFC 03,F
4DB6:  MOVFF  03,90C
4DBA:  CLRF   03
4DBC:  MOVF   x0A,W
4DBE:  ADDWF  x00,W
4DC0:  MOVWF  FE9
4DC2:  MOVF   x01,W
4DC4:  ADDWFC 03,W
4DC6:  MOVWF  FEA
4DC8:  MOVFF  FEF,90D
4DCC:  CLRF   03
4DCE:  MOVF   x0A,W
4DD0:  ADDWF  x02,W
4DD2:  MOVWF  FE9
4DD4:  MOVF   x03,W
4DD6:  ADDWFC 03,W
4DD8:  MOVWF  FEA
4DDA:  MOVF   FEF,W
4DDC:  XORWF  x0D,W
4DDE:  MOVFF  90C,FEA
4DE2:  MOVFF  01,FE9
4DE6:  MOVWF  FEF
....................     } // enf for 
4DE8:  INCF   x0A,F
4DEA:  BRA    4DA4
....................   } // end if (!dir) 
.................... } // end function 
4DEC:  MOVLB  0
4DEE:  RETURN 0
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                  
....................  
.................... #define     wideofkeystore      16 
.................... #define     key_numbyte         wideofkeystore-4 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 kp_st=0; 
.................... int8 type_KB=0; 
....................  
.................... int8 key_data[wideofkeystore]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1F9C:  MOVLB  1
1F9E:  INCF   x5B,F
1FA0:  MOVF   x5B,W
1FA2:  SUBLW  01
1FA4:  BTFSC  FD8.0
1FA6:  BRA    214A
....................        switch (col) { 
1FA8:  MOVF   x5E,W
1FAA:  ADDLW  FB
1FAC:  BC    2030
1FAE:  ADDLW  05
1FB0:  MOVLB  0
1FB2:  GOTO   2154
....................          case 0   :  
....................                     output_low(COL0); 
1FB6:  BCF    F92.5
1FB8:  BCF    F89.5
....................                     output_high(COL1); 
1FBA:  BCF    F92.3
1FBC:  BSF    F89.3
....................                     output_high(COL2); 
1FBE:  BCF    F92.2
1FC0:  BSF    F89.2
....................                     output_high(COL3); 
1FC2:  BCF    F92.1
1FC4:  BSF    F89.1
....................                     output_high(COL4); 
1FC6:  BCF    F92.0
1FC8:  BSF    F89.0
....................                     break; 
1FCA:  MOVLB  1
1FCC:  BRA    2030
....................          case 1   :  
....................                     output_low(COL1); 
1FCE:  BCF    F92.3
1FD0:  BCF    F89.3
....................                     output_high(COL0); 
1FD2:  BCF    F92.5
1FD4:  BSF    F89.5
....................                     output_high(COL2); 
1FD6:  BCF    F92.2
1FD8:  BSF    F89.2
....................                     output_high(COL3); 
1FDA:  BCF    F92.1
1FDC:  BSF    F89.1
....................                     output_high(COL4); 
1FDE:  BCF    F92.0
1FE0:  BSF    F89.0
....................                     break; 
1FE2:  MOVLB  1
1FE4:  BRA    2030
....................          case 2   :  
....................                     output_low(COL2); 
1FE6:  BCF    F92.2
1FE8:  BCF    F89.2
....................                     output_high(COL1); 
1FEA:  BCF    F92.3
1FEC:  BSF    F89.3
....................                     output_high(COL0); 
1FEE:  BCF    F92.5
1FF0:  BSF    F89.5
....................                     output_high(COL3); 
1FF2:  BCF    F92.1
1FF4:  BSF    F89.1
....................                     output_high(COL4); 
1FF6:  BCF    F92.0
1FF8:  BSF    F89.0
....................                     break; 
1FFA:  MOVLB  1
1FFC:  BRA    2030
....................          case 3   :  
....................                     output_low(COL3); 
1FFE:  BCF    F92.1
2000:  BCF    F89.1
....................                     output_high(COL1); 
2002:  BCF    F92.3
2004:  BSF    F89.3
....................                     output_high(COL2); 
2006:  BCF    F92.2
2008:  BSF    F89.2
....................                     output_high(COL0); 
200A:  BCF    F92.5
200C:  BSF    F89.5
....................                     output_high(COL4); 
200E:  BCF    F92.0
2010:  BSF    F89.0
....................                     break; 
2012:  MOVLB  1
2014:  BRA    2030
....................          case 4   :  
....................                     output_low(COL4); 
2016:  BCF    F92.0
2018:  BCF    F89.0
....................                     output_high(COL1); 
201A:  BCF    F92.3
201C:  BSF    F89.3
....................                     output_high(COL2); 
201E:  BCF    F92.2
2020:  BSF    F89.2
....................                     output_high(COL3); 
2022:  BCF    F92.1
2024:  BSF    F89.1
....................                     output_high(COL0); 
2026:  BCF    F92.5
2028:  BSF    F89.5
....................                     break; 
202A:  MOVLB  1
202C:  BRA    2030
202E:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2030:  BTFSS  x5C.0
2032:  BRA    20B0
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2034:  BSF    F93.4
2036:  MOVLW  00
2038:  BTFSC  F81.4
203A:  MOVLW  01
203C:  MOVLB  8
203E:  MOVWF  x52
2040:  BSF    F93.5
2042:  MOVLW  00
2044:  BTFSC  F81.5
2046:  MOVLW  01
2048:  ANDWF  x52,F
204A:  BSF    F93.6
204C:  MOVLW  00
204E:  BTFSC  F81.6
2050:  MOVLW  01
2052:  ANDWF  x52,F
2054:  BSF    F93.7
2056:  MOVLW  00
2058:  BTFSC  F81.7
205A:  MOVLW  01
205C:  ANDWF  x52,W
205E:  BZ    20AC
....................          { 
....................             kchar=last_key; 
2060:  MOVFF  15D,850
....................             if(keydebug_en==0) 
2064:  MOVLB  1
2066:  MOVF   x44,F
2068:  BNZ   209A
....................             { 
....................                 //count_timer0=0; 
....................                 charac_timeout=0; 
206A:  CLRF   x00
206C:  MOVLB  0
206E:  CLRF   xFF
....................                 if(key_count_ms<wideofkeystore) 
2070:  MOVLB  1
2072:  MOVF   x47,W
2074:  SUBLW  0F
2076:  BNC   2098
....................                 { 
....................                     key_data[key_count_ms++]=kchar; 
2078:  MOVF   x47,W
207A:  INCF   x47,F
207C:  CLRF   03
207E:  ADDLW  4A
2080:  MOVWF  FE9
2082:  MOVLW  01
2084:  ADDWFC 03,W
2086:  MOVWF  FEA
2088:  MOVFF  850,FEF
....................                     fputc(kchar,COM2); 
208C:  MOVFF  850,90C
2090:  MOVLB  0
2092:  CALL   1620
2096:  MOVLB  1
....................                 } 
....................             } 
....................                else fputc(kchar,COM2); 
2098:  BRA    20A6
209A:  MOVFF  850,90C
209E:  MOVLB  0
20A0:  CALL   1620
20A4:  MOVLB  1
....................            kbd_down=FALSE; 
20A6:  BCF    x5C.0
....................            last_key=0; 
20A8:  CLRF   x5D
20AA:  MOVLB  8
....................          } 
....................        } else 
20AC:  BRA    2146
20AE:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
20B0:  BSF    F93.4
20B2:  MOVLW  00
20B4:  BTFSC  F81.4
20B6:  MOVLW  01
20B8:  MOVLB  8
20BA:  MOVWF  x52
20BC:  BSF    F93.5
20BE:  MOVLW  00
20C0:  BTFSC  F81.5
20C2:  MOVLW  01
20C4:  ANDWF  x52,F
20C6:  BSF    F93.6
20C8:  MOVLW  00
20CA:  BTFSC  F81.6
20CC:  MOVLW  01
20CE:  ANDWF  x52,F
20D0:  BSF    F93.7
20D2:  MOVLW  00
20D4:  BTFSC  F81.7
20D6:  MOVLW  01
20D8:  ANDWF  x52,W
20DA:  BNZ   213A
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
20DC:  BSF    F93.4
20DE:  BTFSC  F81.4
20E0:  BRA    20E6
....................                   row=0; 
20E2:  CLRF   x51
....................                 else if(input(ROW1)==0) 
20E4:  BRA    2108
20E6:  BSF    F93.5
20E8:  BTFSC  F81.5
20EA:  BRA    20F2
....................                   row=1; 
20EC:  MOVLW  01
20EE:  MOVWF  x51
....................                 else if(input(ROW2)==0) 
20F0:  BRA    2108
20F2:  BSF    F93.6
20F4:  BTFSC  F81.6
20F6:  BRA    20FE
....................                   row=2; 
20F8:  MOVLW  02
20FA:  MOVWF  x51
....................                 else if(input(ROW3)==0) 
20FC:  BRA    2108
20FE:  BSF    F93.7
2100:  BTFSC  F81.7
2102:  BRA    2108
....................                   row=3; 
2104:  MOVLW  03
2106:  MOVWF  x51
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
2108:  MOVF   x51,W
210A:  MULLW  05
210C:  MOVF   FF3,W
210E:  CLRF   x53
2110:  MOVWF  x52
2112:  CLRF   03
2114:  MOVLB  1
2116:  MOVF   x5E,W
2118:  MOVLB  8
211A:  ADDWF  x52,W
211C:  MOVWF  01
211E:  MOVF   x53,W
2120:  ADDWFC 03,F
2122:  MOVF   01,W
2124:  MOVLB  0
2126:  CALL   030A
212A:  MOVFF  FE8,15D
....................                 kbd_down = TRUE; 
212E:  MOVLB  1
2130:  BSF    x5C.0
....................                 set_tris_a(0xff); 
2132:  MOVLW  FF
2134:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2136:  BRA    2146
2138:  MOVLB  8
....................                { 
....................                   ++col; 
213A:  MOVLB  1
213C:  INCF   x5E,F
....................                   if(col==5) col=0; 
213E:  MOVF   x5E,W
2140:  SUBLW  05
2142:  BTFSC  FD8.2
2144:  CLRF   x5E
....................                } 
....................          } 
....................       kbd_call_count=0; 
2146:  MOVLB  1
2148:  CLRF   x5B
....................    } 
....................   return(kchar); 
214A:  MOVLB  8
214C:  MOVFF  850,01
.................... } 
2150:  MOVLB  0
2152:  RETURN 0
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2178:  MOVLW  E0
217A:  MOVLB  F
217C:  MOVWF  x48
217E:  BCF    FC2.6
2180:  BCF    FC2.7
2182:  MOVF   x49,W
2184:  ANDLW  E0
2186:  IORLW  17
2188:  MOVWF  x49
....................    switch(col) 
....................    { 
218A:  MOVLB  8
218C:  MOVF   x6D,W
218E:  ADDLW  FA
2190:  BC    225C
2192:  ADDLW  06
2194:  MOVLB  0
2196:  GOTO   2260
....................       case 0: 
....................         set_adc_channel(4); 
219A:  MOVLW  10
219C:  MOVWF  01
219E:  MOVF   FC2,W
21A0:  ANDLW  C3
21A2:  IORWF  01,W
21A4:  MOVWF  FC2
....................         adc=read_adc(); 
21A6:  BSF    FC2.1
21A8:  BTFSC  FC2.1
21AA:  BRA    21A8
21AC:  MOVFF  FC4,86E
....................         return adc; 
21B0:  MOVLB  8
21B2:  MOVFF  86E,01
21B6:  BRA    225C
....................       break; 
21B8:  BRA    225C
....................       case 1: 
....................         set_adc_channel(3); 
21BA:  MOVLW  0C
21BC:  MOVWF  01
21BE:  MOVF   FC2,W
21C0:  ANDLW  C3
21C2:  IORWF  01,W
21C4:  MOVWF  FC2
....................         adc=read_adc(); 
21C6:  BSF    FC2.1
21C8:  BTFSC  FC2.1
21CA:  BRA    21C8
21CC:  MOVFF  FC4,86E
....................         return adc; 
21D0:  MOVLB  8
21D2:  MOVFF  86E,01
21D6:  BRA    225C
....................       break; 
21D8:  BRA    225C
....................       case 2: 
....................         set_adc_channel(2); 
21DA:  MOVLW  08
21DC:  MOVWF  01
21DE:  MOVF   FC2,W
21E0:  ANDLW  C3
21E2:  IORWF  01,W
21E4:  MOVWF  FC2
....................         adc=read_adc(); 
21E6:  BSF    FC2.1
21E8:  BTFSC  FC2.1
21EA:  BRA    21E8
21EC:  MOVFF  FC4,86E
....................         return adc; 
21F0:  MOVLB  8
21F2:  MOVFF  86E,01
21F6:  BRA    225C
....................       break; 
21F8:  BRA    225C
....................       case 3: 
....................         set_adc_channel(1); 
21FA:  MOVLW  04
21FC:  MOVWF  01
21FE:  MOVF   FC2,W
2200:  ANDLW  C3
2202:  IORWF  01,W
2204:  MOVWF  FC2
....................         adc=read_adc(); 
2206:  BSF    FC2.1
2208:  BTFSC  FC2.1
220A:  BRA    2208
220C:  MOVFF  FC4,86E
....................         return adc; 
2210:  MOVLB  8
2212:  MOVFF  86E,01
2216:  BRA    225C
....................       break; 
2218:  BRA    225C
....................       case 4: 
....................         set_adc_channel(0); 
221A:  MOVLW  00
221C:  MOVWF  01
221E:  MOVF   FC2,W
2220:  ANDLW  C3
2222:  IORWF  01,W
2224:  MOVWF  FC2
....................         adc=read_adc(); 
2226:  BSF    FC2.1
2228:  BTFSC  FC2.1
222A:  BRA    2228
222C:  MOVFF  FC4,86E
....................         return adc; 
2230:  MOVLB  8
2232:  MOVFF  86E,01
2236:  BRA    225C
....................       break;      
2238:  BRA    225C
....................       case 5: 
....................         set_adc_channel(11); 
223A:  MOVLW  2C
223C:  MOVWF  01
223E:  MOVF   FC2,W
2240:  ANDLW  C3
2242:  IORWF  01,W
2244:  MOVWF  FC2
....................         adc=read_adc(); 
2246:  BSF    FC2.1
2248:  BTFSC  FC2.1
224A:  BRA    2248
224C:  MOVFF  FC4,86E
....................         return adc; 
2250:  MOVLB  8
2252:  MOVFF  86E,01
2256:  BRA    225C
....................       break;      
2258:  BRA    225C
225A:  MOVLB  8
....................    } 
.................... } 
225C:  MOVLB  0
225E:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
23D8:  MOVLB  8
23DA:  CLRF   x58
23DC:  CLRF   x57
23DE:  CLRF   x56
23E0:  CLRF   x55
23E2:  CLRF   x5C
23E4:  CLRF   x5B
23E6:  CLRF   x5A
23E8:  CLRF   x59
23EA:  CLRF   x60
23EC:  CLRF   x5F
23EE:  CLRF   x5E
23F0:  CLRF   x5D
23F2:  CLRF   x64
23F4:  CLRF   x63
23F6:  CLRF   x62
23F8:  CLRF   x61
23FA:  CLRF   x68
23FC:  CLRF   x67
23FE:  CLRF   x66
2400:  CLRF   x65
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2402:  CLRF   x54
2404:  CLRF   x53
2406:  MOVF   x54,W
2408:  SUBLW  01
240A:  BNC   2488
240C:  BNZ   2414
240E:  MOVF   x53,W
2410:  SUBLW  F3
2412:  BNC   2488
....................    { 
....................       col_0=read_col(0)+col_0; 
2414:  CLRF   x6D
2416:  MOVLB  0
2418:  RCALL  2178
241A:  MOVF   01,W
241C:  MOVLB  8
241E:  ADDWF  x55,F
2420:  MOVLW  00
2422:  ADDWFC x56,F
2424:  ADDWFC x57,F
2426:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2428:  MOVLW  01
242A:  MOVWF  x6D
242C:  MOVLB  0
242E:  RCALL  2178
2430:  MOVF   01,W
2432:  MOVLB  8
2434:  ADDWF  x59,F
2436:  MOVLW  00
2438:  ADDWFC x5A,F
243A:  ADDWFC x5B,F
243C:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
243E:  MOVLW  02
2440:  MOVWF  x6D
2442:  MOVLB  0
2444:  RCALL  2178
2446:  MOVF   01,W
2448:  MOVLB  8
244A:  ADDWF  x5D,F
244C:  MOVLW  00
244E:  ADDWFC x5E,F
2450:  ADDWFC x5F,F
2452:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
2454:  MOVLW  03
2456:  MOVWF  x6D
2458:  MOVLB  0
245A:  RCALL  2178
245C:  MOVF   01,W
245E:  MOVLB  8
2460:  ADDWF  x61,F
2462:  MOVLW  00
2464:  ADDWFC x62,F
2466:  ADDWFC x63,F
2468:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
246A:  MOVLW  04
246C:  MOVWF  x6D
246E:  MOVLB  0
2470:  RCALL  2178
2472:  MOVF   01,W
2474:  MOVLB  8
2476:  ADDWF  x65,F
2478:  MOVLW  00
247A:  ADDWFC x66,F
247C:  ADDWFC x67,F
247E:  ADDWFC x68,F
....................    } 
2480:  INCF   x53,F
2482:  BTFSC  FD8.2
2484:  INCF   x54,F
2486:  BRA    2406
....................    col_0=col_0/500; 
2488:  BCF    FD8.1
248A:  MOVFF  858,90F
248E:  MOVFF  857,90E
2492:  MOVFF  856,90D
2496:  MOVFF  855,90C
249A:  MOVLB  9
249C:  CLRF   x13
249E:  CLRF   x12
24A0:  MOVLW  01
24A2:  MOVWF  x11
24A4:  MOVLW  F4
24A6:  MOVWF  x10
24A8:  MOVLB  0
24AA:  RCALL  2286
24AC:  MOVFF  03,858
24B0:  MOVFF  02,857
24B4:  MOVFF  01,856
24B8:  MOVFF  00,855
....................    col_1=col_1/500; 
24BC:  BCF    FD8.1
24BE:  MOVFF  85C,90F
24C2:  MOVFF  85B,90E
24C6:  MOVFF  85A,90D
24CA:  MOVFF  859,90C
24CE:  MOVLB  9
24D0:  CLRF   x13
24D2:  CLRF   x12
24D4:  MOVLW  01
24D6:  MOVWF  x11
24D8:  MOVLW  F4
24DA:  MOVWF  x10
24DC:  MOVLB  0
24DE:  RCALL  2286
24E0:  MOVFF  03,85C
24E4:  MOVFF  02,85B
24E8:  MOVFF  01,85A
24EC:  MOVFF  00,859
....................    col_2=col_2/500; 
24F0:  BCF    FD8.1
24F2:  MOVFF  860,90F
24F6:  MOVFF  85F,90E
24FA:  MOVFF  85E,90D
24FE:  MOVFF  85D,90C
2502:  MOVLB  9
2504:  CLRF   x13
2506:  CLRF   x12
2508:  MOVLW  01
250A:  MOVWF  x11
250C:  MOVLW  F4
250E:  MOVWF  x10
2510:  MOVLB  0
2512:  RCALL  2286
2514:  MOVFF  03,860
2518:  MOVFF  02,85F
251C:  MOVFF  01,85E
2520:  MOVFF  00,85D
....................    col_3=col_3/500; 
2524:  BCF    FD8.1
2526:  MOVFF  864,90F
252A:  MOVFF  863,90E
252E:  MOVFF  862,90D
2532:  MOVFF  861,90C
2536:  MOVLB  9
2538:  CLRF   x13
253A:  CLRF   x12
253C:  MOVLW  01
253E:  MOVWF  x11
2540:  MOVLW  F4
2542:  MOVWF  x10
2544:  MOVLB  0
2546:  RCALL  2286
2548:  MOVFF  03,864
254C:  MOVFF  02,863
2550:  MOVFF  01,862
2554:  MOVFF  00,861
....................    col_4=col_4/500; 
2558:  BCF    FD8.1
255A:  MOVFF  868,90F
255E:  MOVFF  867,90E
2562:  MOVFF  866,90D
2566:  MOVFF  865,90C
256A:  MOVLB  9
256C:  CLRF   x13
256E:  CLRF   x12
2570:  MOVLW  01
2572:  MOVWF  x11
2574:  MOVLW  F4
2576:  MOVWF  x10
2578:  MOVLB  0
257A:  RCALL  2286
257C:  MOVFF  03,868
2580:  MOVFF  02,867
2584:  MOVFF  01,866
2588:  MOVFF  00,865
....................    if(keydebug_en) 
258C:  MOVLB  1
258E:  MOVF   x44,F
2590:  BTFSC  FD8.2
2592:  BRA    270E
....................    { 
....................       fprintf(COM2,"\r\n");      
2594:  MOVLW  0D
2596:  MOVLB  9
2598:  MOVWF  x0C
259A:  MOVLB  0
259C:  CALL   1620
25A0:  MOVLW  0A
25A2:  MOVLB  9
25A4:  MOVWF  x0C
25A6:  MOVLB  0
25A8:  CALL   1620
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
25AC:  MOVLW  BC
25AE:  MOVWF  FF6
25B0:  MOVLW  04
25B2:  MOVWF  FF7
25B4:  MOVLW  07
25B6:  MOVLB  9
25B8:  MOVWF  x00
25BA:  MOVLB  0
25BC:  CALL   1666
25C0:  MOVLW  41
25C2:  MOVWF  FE9
25C4:  MOVFF  858,903
25C8:  MOVFF  857,902
25CC:  MOVFF  856,901
25D0:  MOVFF  855,900
25D4:  RCALL  231A
25D6:  MOVLW  0D
25D8:  MOVLB  9
25DA:  MOVWF  x0C
25DC:  MOVLB  0
25DE:  CALL   1620
25E2:  MOVLW  0A
25E4:  MOVLB  9
25E6:  MOVWF  x0C
25E8:  MOVLB  0
25EA:  CALL   1620
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
25EE:  MOVLW  CA
25F0:  MOVWF  FF6
25F2:  MOVLW  04
25F4:  MOVWF  FF7
25F6:  MOVLW  07
25F8:  MOVLB  9
25FA:  MOVWF  x00
25FC:  MOVLB  0
25FE:  CALL   1666
2602:  MOVLW  41
2604:  MOVWF  FE9
2606:  MOVFF  85C,903
260A:  MOVFF  85B,902
260E:  MOVFF  85A,901
2612:  MOVFF  859,900
2616:  RCALL  231A
2618:  MOVLW  0D
261A:  MOVLB  9
261C:  MOVWF  x0C
261E:  MOVLB  0
2620:  CALL   1620
2624:  MOVLW  0A
2626:  MOVLB  9
2628:  MOVWF  x0C
262A:  MOVLB  0
262C:  CALL   1620
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2630:  MOVLW  D8
2632:  MOVWF  FF6
2634:  MOVLW  04
2636:  MOVWF  FF7
2638:  MOVLW  07
263A:  MOVLB  9
263C:  MOVWF  x00
263E:  MOVLB  0
2640:  CALL   1666
2644:  MOVLW  41
2646:  MOVWF  FE9
2648:  MOVFF  860,903
264C:  MOVFF  85F,902
2650:  MOVFF  85E,901
2654:  MOVFF  85D,900
2658:  RCALL  231A
265A:  MOVLW  0D
265C:  MOVLB  9
265E:  MOVWF  x0C
2660:  MOVLB  0
2662:  CALL   1620
2666:  MOVLW  0A
2668:  MOVLB  9
266A:  MOVWF  x0C
266C:  MOVLB  0
266E:  CALL   1620
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2672:  MOVLW  E6
2674:  MOVWF  FF6
2676:  MOVLW  04
2678:  MOVWF  FF7
267A:  MOVLW  07
267C:  MOVLB  9
267E:  MOVWF  x00
2680:  MOVLB  0
2682:  CALL   1666
2686:  MOVLW  41
2688:  MOVWF  FE9
268A:  MOVFF  864,903
268E:  MOVFF  863,902
2692:  MOVFF  862,901
2696:  MOVFF  861,900
269A:  RCALL  231A
269C:  MOVLW  0D
269E:  MOVLB  9
26A0:  MOVWF  x0C
26A2:  MOVLB  0
26A4:  CALL   1620
26A8:  MOVLW  0A
26AA:  MOVLB  9
26AC:  MOVWF  x0C
26AE:  MOVLB  0
26B0:  CALL   1620
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
26B4:  MOVLW  F4
26B6:  MOVWF  FF6
26B8:  MOVLW  04
26BA:  MOVWF  FF7
26BC:  MOVLW  07
26BE:  MOVLB  9
26C0:  MOVWF  x00
26C2:  MOVLB  0
26C4:  CALL   1666
26C8:  MOVLW  41
26CA:  MOVWF  FE9
26CC:  MOVFF  868,903
26D0:  MOVFF  867,902
26D4:  MOVFF  866,901
26D8:  MOVFF  865,900
26DC:  RCALL  231A
26DE:  MOVLW  0D
26E0:  MOVLB  9
26E2:  MOVWF  x0C
26E4:  MOVLB  0
26E6:  CALL   1620
26EA:  MOVLW  0A
26EC:  MOVLB  9
26EE:  MOVWF  x0C
26F0:  MOVLB  0
26F2:  CALL   1620
....................       fprintf(COM2,"\r\n"); 
26F6:  MOVLW  0D
26F8:  MOVLB  9
26FA:  MOVWF  x0C
26FC:  MOVLB  0
26FE:  CALL   1620
2702:  MOVLW  0A
2704:  MOVLB  9
2706:  MOVWF  x0C
2708:  MOVLB  0
270A:  CALL   1620
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
270E:  MOVLB  8
2710:  MOVF   x58,F
2712:  BNZ   2722
2714:  MOVF   x57,F
2716:  BNZ   2722
2718:  MOVF   x56,F
271A:  BNZ   2722
271C:  MOVF   x55,W
271E:  SUBLW  05
2720:  BC    2782
2722:  MOVF   x58,F
2724:  BNZ   2782
2726:  MOVF   x57,F
2728:  BNZ   2782
272A:  MOVF   x56,F
272C:  BNZ   2782
272E:  MOVF   x55,W
2730:  SUBLW  3B
2732:  BNC   2782
2734:  MOVF   x5C,F
2736:  BNZ   2746
2738:  MOVF   x5B,F
273A:  BNZ   2746
273C:  MOVF   x5A,F
273E:  BNZ   2746
2740:  MOVF   x59,W
2742:  SUBLW  64
2744:  BC    2782
2746:  MOVF   x60,F
2748:  BNZ   2758
274A:  MOVF   x5F,F
274C:  BNZ   2758
274E:  MOVF   x5E,F
2750:  BNZ   2758
2752:  MOVF   x5D,W
2754:  SUBLW  64
2756:  BC    2782
2758:  MOVF   x64,F
275A:  BNZ   276A
275C:  MOVF   x63,F
275E:  BNZ   276A
2760:  MOVF   x62,F
2762:  BNZ   276A
2764:  MOVF   x61,W
2766:  SUBLW  64
2768:  BC    2782
276A:  MOVF   x68,F
276C:  BNZ   277C
276E:  MOVF   x67,F
2770:  BNZ   277C
2772:  MOVF   x66,F
2774:  BNZ   277C
2776:  MOVF   x65,W
2778:  SUBLW  64
277A:  BC    2782
277C:  MOVLW  00
277E:  MOVWF  01
2780:  BRA    2A00
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
2782:  MOVF   x5C,F
2784:  BNZ   2794
2786:  MOVF   x5B,F
2788:  BNZ   2794
278A:  MOVF   x5A,F
278C:  BNZ   2794
278E:  MOVF   x59,W
2790:  SUBLW  05
2792:  BC    27F4
2794:  MOVF   x5C,F
2796:  BNZ   27F4
2798:  MOVF   x5B,F
279A:  BNZ   27F4
279C:  MOVF   x5A,F
279E:  BNZ   27F4
27A0:  MOVF   x59,W
27A2:  SUBLW  3B
27A4:  BNC   27F4
27A6:  MOVF   x58,F
27A8:  BNZ   27B8
27AA:  MOVF   x57,F
27AC:  BNZ   27B8
27AE:  MOVF   x56,F
27B0:  BNZ   27B8
27B2:  MOVF   x55,W
27B4:  SUBLW  64
27B6:  BC    27F4
27B8:  MOVF   x60,F
27BA:  BNZ   27CA
27BC:  MOVF   x5F,F
27BE:  BNZ   27CA
27C0:  MOVF   x5E,F
27C2:  BNZ   27CA
27C4:  MOVF   x5D,W
27C6:  SUBLW  64
27C8:  BC    27F4
27CA:  MOVF   x64,F
27CC:  BNZ   27DC
27CE:  MOVF   x63,F
27D0:  BNZ   27DC
27D2:  MOVF   x62,F
27D4:  BNZ   27DC
27D6:  MOVF   x61,W
27D8:  SUBLW  64
27DA:  BC    27F4
27DC:  MOVF   x68,F
27DE:  BNZ   27EE
27E0:  MOVF   x67,F
27E2:  BNZ   27EE
27E4:  MOVF   x66,F
27E6:  BNZ   27EE
27E8:  MOVF   x65,W
27EA:  SUBLW  64
27EC:  BC    27F4
27EE:  MOVLW  01
27F0:  MOVWF  01
27F2:  BRA    2A00
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
27F4:  MOVF   x60,F
27F6:  BNZ   2806
27F8:  MOVF   x5F,F
27FA:  BNZ   2806
27FC:  MOVF   x5E,F
27FE:  BNZ   2806
2800:  MOVF   x5D,W
2802:  SUBLW  05
2804:  BC    2866
2806:  MOVF   x60,F
2808:  BNZ   2866
280A:  MOVF   x5F,F
280C:  BNZ   2866
280E:  MOVF   x5E,F
2810:  BNZ   2866
2812:  MOVF   x5D,W
2814:  SUBLW  3B
2816:  BNC   2866
2818:  MOVF   x5C,F
281A:  BNZ   282A
281C:  MOVF   x5B,F
281E:  BNZ   282A
2820:  MOVF   x5A,F
2822:  BNZ   282A
2824:  MOVF   x59,W
2826:  SUBLW  64
2828:  BC    2866
282A:  MOVF   x58,F
282C:  BNZ   283C
282E:  MOVF   x57,F
2830:  BNZ   283C
2832:  MOVF   x56,F
2834:  BNZ   283C
2836:  MOVF   x55,W
2838:  SUBLW  64
283A:  BC    2866
283C:  MOVF   x64,F
283E:  BNZ   284E
2840:  MOVF   x63,F
2842:  BNZ   284E
2844:  MOVF   x62,F
2846:  BNZ   284E
2848:  MOVF   x61,W
284A:  SUBLW  64
284C:  BC    2866
284E:  MOVF   x68,F
2850:  BNZ   2860
2852:  MOVF   x67,F
2854:  BNZ   2860
2856:  MOVF   x66,F
2858:  BNZ   2860
285A:  MOVF   x65,W
285C:  SUBLW  64
285E:  BC    2866
2860:  MOVLW  02
2862:  MOVWF  01
2864:  BRA    2A00
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2866:  MOVF   x64,F
2868:  BNZ   2878
286A:  MOVF   x63,F
286C:  BNZ   2878
286E:  MOVF   x62,F
2870:  BNZ   2878
2872:  MOVF   x61,W
2874:  SUBLW  05
2876:  BC    28D8
2878:  MOVF   x64,F
287A:  BNZ   28D8
287C:  MOVF   x63,F
287E:  BNZ   28D8
2880:  MOVF   x62,F
2882:  BNZ   28D8
2884:  MOVF   x61,W
2886:  SUBLW  3B
2888:  BNC   28D8
288A:  MOVF   x5C,F
288C:  BNZ   289C
288E:  MOVF   x5B,F
2890:  BNZ   289C
2892:  MOVF   x5A,F
2894:  BNZ   289C
2896:  MOVF   x59,W
2898:  SUBLW  64
289A:  BC    28D8
289C:  MOVF   x60,F
289E:  BNZ   28AE
28A0:  MOVF   x5F,F
28A2:  BNZ   28AE
28A4:  MOVF   x5E,F
28A6:  BNZ   28AE
28A8:  MOVF   x5D,W
28AA:  SUBLW  64
28AC:  BC    28D8
28AE:  MOVF   x58,F
28B0:  BNZ   28C0
28B2:  MOVF   x57,F
28B4:  BNZ   28C0
28B6:  MOVF   x56,F
28B8:  BNZ   28C0
28BA:  MOVF   x55,W
28BC:  SUBLW  64
28BE:  BC    28D8
28C0:  MOVF   x68,F
28C2:  BNZ   28D2
28C4:  MOVF   x67,F
28C6:  BNZ   28D2
28C8:  MOVF   x66,F
28CA:  BNZ   28D2
28CC:  MOVF   x65,W
28CE:  SUBLW  64
28D0:  BC    28D8
28D2:  MOVLW  03
28D4:  MOVWF  01
28D6:  BRA    2A00
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
28D8:  MOVF   x68,F
28DA:  BNZ   28EA
28DC:  MOVF   x67,F
28DE:  BNZ   28EA
28E0:  MOVF   x66,F
28E2:  BNZ   28EA
28E4:  MOVF   x65,W
28E6:  SUBLW  05
28E8:  BC    294A
28EA:  MOVF   x68,F
28EC:  BNZ   294A
28EE:  MOVF   x67,F
28F0:  BNZ   294A
28F2:  MOVF   x66,F
28F4:  BNZ   294A
28F6:  MOVF   x65,W
28F8:  SUBLW  3B
28FA:  BNC   294A
28FC:  MOVF   x5C,F
28FE:  BNZ   290E
2900:  MOVF   x5B,F
2902:  BNZ   290E
2904:  MOVF   x5A,F
2906:  BNZ   290E
2908:  MOVF   x59,W
290A:  SUBLW  64
290C:  BC    294A
290E:  MOVF   x60,F
2910:  BNZ   2920
2912:  MOVF   x5F,F
2914:  BNZ   2920
2916:  MOVF   x5E,F
2918:  BNZ   2920
291A:  MOVF   x5D,W
291C:  SUBLW  64
291E:  BC    294A
2920:  MOVF   x64,F
2922:  BNZ   2932
2924:  MOVF   x63,F
2926:  BNZ   2932
2928:  MOVF   x62,F
292A:  BNZ   2932
292C:  MOVF   x61,W
292E:  SUBLW  64
2930:  BC    294A
2932:  MOVF   x58,F
2934:  BNZ   2944
2936:  MOVF   x57,F
2938:  BNZ   2944
293A:  MOVF   x56,F
293C:  BNZ   2944
293E:  MOVF   x55,W
2940:  SUBLW  64
2942:  BC    294A
2944:  MOVLW  04
2946:  MOVWF  01
2948:  BRA    2A00
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
294A:  MOVF   x68,F
294C:  BNZ   295E
294E:  MOVF   x67,F
2950:  BNZ   295E
2952:  MOVF   x66,F
2954:  BNZ   295E
2956:  MOVF   x65,W
2958:  SUBLW  C8
295A:  BTFSC  FD8.0
295C:  BRA    29FC
295E:  MOVF   x58,F
2960:  BTFSS  FD8.2
2962:  BRA    29FC
2964:  MOVF   x57,F
2966:  BTFSS  FD8.2
2968:  BRA    29FC
296A:  MOVF   x56,F
296C:  BTFSS  FD8.2
296E:  BRA    29FC
2970:  MOVF   x55,W
2972:  SUBLW  B3
2974:  BNC   29FC
2976:  MOVF   x58,F
2978:  BNZ   2988
297A:  MOVF   x57,F
297C:  BNZ   2988
297E:  MOVF   x56,F
2980:  BNZ   2988
2982:  MOVF   x55,W
2984:  SUBLW  64
2986:  BC    29FC
2988:  MOVF   x5C,F
298A:  BNZ   29FC
298C:  MOVF   x5B,F
298E:  BNZ   29FC
2990:  MOVF   x5A,F
2992:  BNZ   29FC
2994:  MOVF   x59,W
2996:  SUBLW  B3
2998:  BNC   29FC
299A:  MOVF   x5C,F
299C:  BNZ   29AC
299E:  MOVF   x5B,F
29A0:  BNZ   29AC
29A2:  MOVF   x5A,F
29A4:  BNZ   29AC
29A6:  MOVF   x59,W
29A8:  SUBLW  64
29AA:  BC    29FC
29AC:  MOVF   x60,F
29AE:  BNZ   29FC
29B0:  MOVF   x5F,F
29B2:  BNZ   29FC
29B4:  MOVF   x5E,F
29B6:  BNZ   29FC
29B8:  MOVF   x5D,W
29BA:  SUBLW  B3
29BC:  BNC   29FC
29BE:  MOVF   x60,F
29C0:  BNZ   29D0
29C2:  MOVF   x5F,F
29C4:  BNZ   29D0
29C6:  MOVF   x5E,F
29C8:  BNZ   29D0
29CA:  MOVF   x5D,W
29CC:  SUBLW  64
29CE:  BC    29FC
29D0:  MOVF   x64,F
29D2:  BNZ   29FC
29D4:  MOVF   x63,F
29D6:  BNZ   29FC
29D8:  MOVF   x62,F
29DA:  BNZ   29FC
29DC:  MOVF   x61,W
29DE:  SUBLW  B3
29E0:  BNC   29FC
29E2:  MOVF   x64,F
29E4:  BNZ   29F4
29E6:  MOVF   x63,F
29E8:  BNZ   29F4
29EA:  MOVF   x62,F
29EC:  BNZ   29F4
29EE:  MOVF   x61,W
29F0:  SUBLW  64
29F2:  BC    29FC
29F4:  MOVLW  04
29F6:  MOVWF  01
29F8:  BRA    2A00
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
29FA:  BRA    2A00
29FC:  MOVLW  FF
29FE:  MOVWF  01
.................... } 
2A00:  MOVLB  0
2A02:  GOTO   324E (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
2A06:  MOVLB  8
2A08:  CLRF   x58
2A0A:  CLRF   x57
2A0C:  CLRF   x56
2A0E:  CLRF   x55
2A10:  CLRF   x5C
2A12:  CLRF   x5B
2A14:  CLRF   x5A
2A16:  CLRF   x59
2A18:  CLRF   x60
2A1A:  CLRF   x5F
2A1C:  CLRF   x5E
2A1E:  CLRF   x5D
2A20:  CLRF   x64
2A22:  CLRF   x63
2A24:  CLRF   x62
2A26:  CLRF   x61
2A28:  CLRF   x68
2A2A:  CLRF   x67
2A2C:  CLRF   x66
2A2E:  CLRF   x65
2A30:  CLRF   x6C
2A32:  CLRF   x6B
2A34:  CLRF   x6A
2A36:  CLRF   x69
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2A38:  CLRF   x54
2A3A:  CLRF   x53
2A3C:  MOVF   x54,W
2A3E:  SUBLW  01
2A40:  BNC   2AE0
2A42:  BNZ   2A4A
2A44:  MOVF   x53,W
2A46:  SUBLW  F3
2A48:  BNC   2AE0
....................    { 
....................       col_0=read_col(0)+col_0; 
2A4A:  CLRF   x6D
2A4C:  MOVLB  0
2A4E:  CALL   2178
2A52:  MOVF   01,W
2A54:  MOVLB  8
2A56:  ADDWF  x55,F
2A58:  MOVLW  00
2A5A:  ADDWFC x56,F
2A5C:  ADDWFC x57,F
2A5E:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2A60:  MOVLW  01
2A62:  MOVWF  x6D
2A64:  MOVLB  0
2A66:  CALL   2178
2A6A:  MOVF   01,W
2A6C:  MOVLB  8
2A6E:  ADDWF  x59,F
2A70:  MOVLW  00
2A72:  ADDWFC x5A,F
2A74:  ADDWFC x5B,F
2A76:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
2A78:  MOVLW  02
2A7A:  MOVWF  x6D
2A7C:  MOVLB  0
2A7E:  CALL   2178
2A82:  MOVF   01,W
2A84:  MOVLB  8
2A86:  ADDWF  x5D,F
2A88:  MOVLW  00
2A8A:  ADDWFC x5E,F
2A8C:  ADDWFC x5F,F
2A8E:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
2A90:  MOVLW  03
2A92:  MOVWF  x6D
2A94:  MOVLB  0
2A96:  CALL   2178
2A9A:  MOVF   01,W
2A9C:  MOVLB  8
2A9E:  ADDWF  x61,F
2AA0:  MOVLW  00
2AA2:  ADDWFC x62,F
2AA4:  ADDWFC x63,F
2AA6:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
2AA8:  MOVLW  04
2AAA:  MOVWF  x6D
2AAC:  MOVLB  0
2AAE:  CALL   2178
2AB2:  MOVF   01,W
2AB4:  MOVLB  8
2AB6:  ADDWF  x65,F
2AB8:  MOVLW  00
2ABA:  ADDWFC x66,F
2ABC:  ADDWFC x67,F
2ABE:  ADDWFC x68,F
....................       col_5=read_col(5)+col_5; 
2AC0:  MOVLW  05
2AC2:  MOVWF  x6D
2AC4:  MOVLB  0
2AC6:  CALL   2178
2ACA:  MOVF   01,W
2ACC:  MOVLB  8
2ACE:  ADDWF  x69,F
2AD0:  MOVLW  00
2AD2:  ADDWFC x6A,F
2AD4:  ADDWFC x6B,F
2AD6:  ADDWFC x6C,F
....................    } 
2AD8:  INCF   x53,F
2ADA:  BTFSC  FD8.2
2ADC:  INCF   x54,F
2ADE:  BRA    2A3C
....................    col_0=col_0/500; 
2AE0:  BCF    FD8.1
2AE2:  MOVFF  858,90F
2AE6:  MOVFF  857,90E
2AEA:  MOVFF  856,90D
2AEE:  MOVFF  855,90C
2AF2:  MOVLB  9
2AF4:  CLRF   x13
2AF6:  CLRF   x12
2AF8:  MOVLW  01
2AFA:  MOVWF  x11
2AFC:  MOVLW  F4
2AFE:  MOVWF  x10
2B00:  MOVLB  0
2B02:  CALL   2286
2B06:  MOVFF  03,858
2B0A:  MOVFF  02,857
2B0E:  MOVFF  01,856
2B12:  MOVFF  00,855
....................    col_1=col_1/500; 
2B16:  BCF    FD8.1
2B18:  MOVFF  85C,90F
2B1C:  MOVFF  85B,90E
2B20:  MOVFF  85A,90D
2B24:  MOVFF  859,90C
2B28:  MOVLB  9
2B2A:  CLRF   x13
2B2C:  CLRF   x12
2B2E:  MOVLW  01
2B30:  MOVWF  x11
2B32:  MOVLW  F4
2B34:  MOVWF  x10
2B36:  MOVLB  0
2B38:  CALL   2286
2B3C:  MOVFF  03,85C
2B40:  MOVFF  02,85B
2B44:  MOVFF  01,85A
2B48:  MOVFF  00,859
....................    col_2=col_2/500; 
2B4C:  BCF    FD8.1
2B4E:  MOVFF  860,90F
2B52:  MOVFF  85F,90E
2B56:  MOVFF  85E,90D
2B5A:  MOVFF  85D,90C
2B5E:  MOVLB  9
2B60:  CLRF   x13
2B62:  CLRF   x12
2B64:  MOVLW  01
2B66:  MOVWF  x11
2B68:  MOVLW  F4
2B6A:  MOVWF  x10
2B6C:  MOVLB  0
2B6E:  CALL   2286
2B72:  MOVFF  03,860
2B76:  MOVFF  02,85F
2B7A:  MOVFF  01,85E
2B7E:  MOVFF  00,85D
....................    col_3=col_3/500; 
2B82:  BCF    FD8.1
2B84:  MOVFF  864,90F
2B88:  MOVFF  863,90E
2B8C:  MOVFF  862,90D
2B90:  MOVFF  861,90C
2B94:  MOVLB  9
2B96:  CLRF   x13
2B98:  CLRF   x12
2B9A:  MOVLW  01
2B9C:  MOVWF  x11
2B9E:  MOVLW  F4
2BA0:  MOVWF  x10
2BA2:  MOVLB  0
2BA4:  CALL   2286
2BA8:  MOVFF  03,864
2BAC:  MOVFF  02,863
2BB0:  MOVFF  01,862
2BB4:  MOVFF  00,861
....................    col_4=col_4/500; 
2BB8:  BCF    FD8.1
2BBA:  MOVFF  868,90F
2BBE:  MOVFF  867,90E
2BC2:  MOVFF  866,90D
2BC6:  MOVFF  865,90C
2BCA:  MOVLB  9
2BCC:  CLRF   x13
2BCE:  CLRF   x12
2BD0:  MOVLW  01
2BD2:  MOVWF  x11
2BD4:  MOVLW  F4
2BD6:  MOVWF  x10
2BD8:  MOVLB  0
2BDA:  CALL   2286
2BDE:  MOVFF  03,868
2BE2:  MOVFF  02,867
2BE6:  MOVFF  01,866
2BEA:  MOVFF  00,865
....................    col_5=col_5/500; 
2BEE:  BCF    FD8.1
2BF0:  MOVFF  86C,90F
2BF4:  MOVFF  86B,90E
2BF8:  MOVFF  86A,90D
2BFC:  MOVFF  869,90C
2C00:  MOVLB  9
2C02:  CLRF   x13
2C04:  CLRF   x12
2C06:  MOVLW  01
2C08:  MOVWF  x11
2C0A:  MOVLW  F4
2C0C:  MOVWF  x10
2C0E:  MOVLB  0
2C10:  CALL   2286
2C14:  MOVFF  03,86C
2C18:  MOVFF  02,86B
2C1C:  MOVFF  01,86A
2C20:  MOVFF  00,869
....................    if(keydebug_en) 
2C24:  MOVLB  1
2C26:  MOVF   x44,F
2C28:  BTFSC  FD8.2
2C2A:  BRA    2DF4
....................    { 
....................       fprintf(COM2,"\r\n");      
2C2C:  MOVLW  0D
2C2E:  MOVLB  9
2C30:  MOVWF  x0C
2C32:  MOVLB  0
2C34:  CALL   1620
2C38:  MOVLW  0A
2C3A:  MOVLB  9
2C3C:  MOVWF  x0C
2C3E:  MOVLB  0
2C40:  CALL   1620
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2C44:  MOVLW  02
2C46:  MOVWF  FF6
2C48:  MOVLW  05
2C4A:  MOVWF  FF7
2C4C:  MOVLW  07
2C4E:  MOVLB  9
2C50:  MOVWF  x00
2C52:  MOVLB  0
2C54:  CALL   1666
2C58:  MOVLW  41
2C5A:  MOVWF  FE9
2C5C:  MOVFF  858,903
2C60:  MOVFF  857,902
2C64:  MOVFF  856,901
2C68:  MOVFF  855,900
2C6C:  CALL   231A
2C70:  MOVLW  0D
2C72:  MOVLB  9
2C74:  MOVWF  x0C
2C76:  MOVLB  0
2C78:  CALL   1620
2C7C:  MOVLW  0A
2C7E:  MOVLB  9
2C80:  MOVWF  x0C
2C82:  MOVLB  0
2C84:  CALL   1620
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2C88:  MOVLW  10
2C8A:  MOVWF  FF6
2C8C:  MOVLW  05
2C8E:  MOVWF  FF7
2C90:  MOVLW  07
2C92:  MOVLB  9
2C94:  MOVWF  x00
2C96:  MOVLB  0
2C98:  CALL   1666
2C9C:  MOVLW  41
2C9E:  MOVWF  FE9
2CA0:  MOVFF  85C,903
2CA4:  MOVFF  85B,902
2CA8:  MOVFF  85A,901
2CAC:  MOVFF  859,900
2CB0:  CALL   231A
2CB4:  MOVLW  0D
2CB6:  MOVLB  9
2CB8:  MOVWF  x0C
2CBA:  MOVLB  0
2CBC:  CALL   1620
2CC0:  MOVLW  0A
2CC2:  MOVLB  9
2CC4:  MOVWF  x0C
2CC6:  MOVLB  0
2CC8:  CALL   1620
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2CCC:  MOVLW  1E
2CCE:  MOVWF  FF6
2CD0:  MOVLW  05
2CD2:  MOVWF  FF7
2CD4:  MOVLW  07
2CD6:  MOVLB  9
2CD8:  MOVWF  x00
2CDA:  MOVLB  0
2CDC:  CALL   1666
2CE0:  MOVLW  41
2CE2:  MOVWF  FE9
2CE4:  MOVFF  860,903
2CE8:  MOVFF  85F,902
2CEC:  MOVFF  85E,901
2CF0:  MOVFF  85D,900
2CF4:  CALL   231A
2CF8:  MOVLW  0D
2CFA:  MOVLB  9
2CFC:  MOVWF  x0C
2CFE:  MOVLB  0
2D00:  CALL   1620
2D04:  MOVLW  0A
2D06:  MOVLB  9
2D08:  MOVWF  x0C
2D0A:  MOVLB  0
2D0C:  CALL   1620
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2D10:  MOVLW  2C
2D12:  MOVWF  FF6
2D14:  MOVLW  05
2D16:  MOVWF  FF7
2D18:  MOVLW  07
2D1A:  MOVLB  9
2D1C:  MOVWF  x00
2D1E:  MOVLB  0
2D20:  CALL   1666
2D24:  MOVLW  41
2D26:  MOVWF  FE9
2D28:  MOVFF  864,903
2D2C:  MOVFF  863,902
2D30:  MOVFF  862,901
2D34:  MOVFF  861,900
2D38:  CALL   231A
2D3C:  MOVLW  0D
2D3E:  MOVLB  9
2D40:  MOVWF  x0C
2D42:  MOVLB  0
2D44:  CALL   1620
2D48:  MOVLW  0A
2D4A:  MOVLB  9
2D4C:  MOVWF  x0C
2D4E:  MOVLB  0
2D50:  CALL   1620
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2D54:  MOVLW  3A
2D56:  MOVWF  FF6
2D58:  MOVLW  05
2D5A:  MOVWF  FF7
2D5C:  MOVLW  07
2D5E:  MOVLB  9
2D60:  MOVWF  x00
2D62:  MOVLB  0
2D64:  CALL   1666
2D68:  MOVLW  41
2D6A:  MOVWF  FE9
2D6C:  MOVFF  868,903
2D70:  MOVFF  867,902
2D74:  MOVFF  866,901
2D78:  MOVFF  865,900
2D7C:  CALL   231A
2D80:  MOVLW  0D
2D82:  MOVLB  9
2D84:  MOVWF  x0C
2D86:  MOVLB  0
2D88:  CALL   1620
2D8C:  MOVLW  0A
2D8E:  MOVLB  9
2D90:  MOVWF  x0C
2D92:  MOVLB  0
2D94:  CALL   1620
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2D98:  MOVLW  48
2D9A:  MOVWF  FF6
2D9C:  MOVLW  05
2D9E:  MOVWF  FF7
2DA0:  MOVLW  07
2DA2:  MOVLB  9
2DA4:  MOVWF  x00
2DA6:  MOVLB  0
2DA8:  CALL   1666
2DAC:  MOVLW  41
2DAE:  MOVWF  FE9
2DB0:  MOVFF  86C,903
2DB4:  MOVFF  86B,902
2DB8:  MOVFF  86A,901
2DBC:  MOVFF  869,900
2DC0:  CALL   231A
2DC4:  MOVLW  0D
2DC6:  MOVLB  9
2DC8:  MOVWF  x0C
2DCA:  MOVLB  0
2DCC:  CALL   1620
2DD0:  MOVLW  0A
2DD2:  MOVLB  9
2DD4:  MOVWF  x0C
2DD6:  MOVLB  0
2DD8:  CALL   1620
....................       fprintf(COM2,"\r\n"); 
2DDC:  MOVLW  0D
2DDE:  MOVLB  9
2DE0:  MOVWF  x0C
2DE2:  MOVLB  0
2DE4:  CALL   1620
2DE8:  MOVLW  0A
2DEA:  MOVLB  9
2DEC:  MOVWF  x0C
2DEE:  MOVLB  0
2DF0:  CALL   1620
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2DF4:  MOVLB  8
2DF6:  MOVF   x58,F
2DF8:  BNZ   2E08
2DFA:  MOVF   x57,F
2DFC:  BNZ   2E08
2DFE:  MOVF   x56,F
2E00:  BNZ   2E08
2E02:  MOVF   x55,W
2E04:  SUBLW  05
2E06:  BC    2E7A
2E08:  MOVF   x58,F
2E0A:  BNZ   2E7A
2E0C:  MOVF   x57,F
2E0E:  BNZ   2E7A
2E10:  MOVF   x56,F
2E12:  BNZ   2E7A
2E14:  MOVF   x55,W
2E16:  SUBLW  3B
2E18:  BNC   2E7A
2E1A:  MOVF   x5C,F
2E1C:  BNZ   2E2C
2E1E:  MOVF   x5B,F
2E20:  BNZ   2E2C
2E22:  MOVF   x5A,F
2E24:  BNZ   2E2C
2E26:  MOVF   x59,W
2E28:  SUBLW  64
2E2A:  BC    2E7A
2E2C:  MOVF   x60,F
2E2E:  BNZ   2E3E
2E30:  MOVF   x5F,F
2E32:  BNZ   2E3E
2E34:  MOVF   x5E,F
2E36:  BNZ   2E3E
2E38:  MOVF   x5D,W
2E3A:  SUBLW  64
2E3C:  BC    2E7A
2E3E:  MOVF   x64,F
2E40:  BNZ   2E50
2E42:  MOVF   x63,F
2E44:  BNZ   2E50
2E46:  MOVF   x62,F
2E48:  BNZ   2E50
2E4A:  MOVF   x61,W
2E4C:  SUBLW  64
2E4E:  BC    2E7A
2E50:  MOVF   x68,F
2E52:  BNZ   2E62
2E54:  MOVF   x67,F
2E56:  BNZ   2E62
2E58:  MOVF   x66,F
2E5A:  BNZ   2E62
2E5C:  MOVF   x65,W
2E5E:  SUBLW  64
2E60:  BC    2E7A
2E62:  MOVF   x6C,F
2E64:  BNZ   2E74
2E66:  MOVF   x6B,F
2E68:  BNZ   2E74
2E6A:  MOVF   x6A,F
2E6C:  BNZ   2E74
2E6E:  MOVF   x69,W
2E70:  SUBLW  64
2E72:  BC    2E7A
2E74:  MOVLW  00
2E76:  MOVWF  01
2E78:  BRA    31F2
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2E7A:  MOVF   x5C,F
2E7C:  BNZ   2E8C
2E7E:  MOVF   x5B,F
2E80:  BNZ   2E8C
2E82:  MOVF   x5A,F
2E84:  BNZ   2E8C
2E86:  MOVF   x59,W
2E88:  SUBLW  05
2E8A:  BC    2EFE
2E8C:  MOVF   x5C,F
2E8E:  BNZ   2EFE
2E90:  MOVF   x5B,F
2E92:  BNZ   2EFE
2E94:  MOVF   x5A,F
2E96:  BNZ   2EFE
2E98:  MOVF   x59,W
2E9A:  SUBLW  3B
2E9C:  BNC   2EFE
2E9E:  MOVF   x58,F
2EA0:  BNZ   2EB0
2EA2:  MOVF   x57,F
2EA4:  BNZ   2EB0
2EA6:  MOVF   x56,F
2EA8:  BNZ   2EB0
2EAA:  MOVF   x55,W
2EAC:  SUBLW  64
2EAE:  BC    2EFE
2EB0:  MOVF   x60,F
2EB2:  BNZ   2EC2
2EB4:  MOVF   x5F,F
2EB6:  BNZ   2EC2
2EB8:  MOVF   x5E,F
2EBA:  BNZ   2EC2
2EBC:  MOVF   x5D,W
2EBE:  SUBLW  64
2EC0:  BC    2EFE
2EC2:  MOVF   x64,F
2EC4:  BNZ   2ED4
2EC6:  MOVF   x63,F
2EC8:  BNZ   2ED4
2ECA:  MOVF   x62,F
2ECC:  BNZ   2ED4
2ECE:  MOVF   x61,W
2ED0:  SUBLW  64
2ED2:  BC    2EFE
2ED4:  MOVF   x68,F
2ED6:  BNZ   2EE6
2ED8:  MOVF   x67,F
2EDA:  BNZ   2EE6
2EDC:  MOVF   x66,F
2EDE:  BNZ   2EE6
2EE0:  MOVF   x65,W
2EE2:  SUBLW  64
2EE4:  BC    2EFE
2EE6:  MOVF   x6C,F
2EE8:  BNZ   2EF8
2EEA:  MOVF   x6B,F
2EEC:  BNZ   2EF8
2EEE:  MOVF   x6A,F
2EF0:  BNZ   2EF8
2EF2:  MOVF   x69,W
2EF4:  SUBLW  64
2EF6:  BC    2EFE
2EF8:  MOVLW  01
2EFA:  MOVWF  01
2EFC:  BRA    31F2
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2EFE:  MOVF   x60,F
2F00:  BNZ   2F10
2F02:  MOVF   x5F,F
2F04:  BNZ   2F10
2F06:  MOVF   x5E,F
2F08:  BNZ   2F10
2F0A:  MOVF   x5D,W
2F0C:  SUBLW  05
2F0E:  BC    2F82
2F10:  MOVF   x60,F
2F12:  BNZ   2F82
2F14:  MOVF   x5F,F
2F16:  BNZ   2F82
2F18:  MOVF   x5E,F
2F1A:  BNZ   2F82
2F1C:  MOVF   x5D,W
2F1E:  SUBLW  3B
2F20:  BNC   2F82
2F22:  MOVF   x5C,F
2F24:  BNZ   2F34
2F26:  MOVF   x5B,F
2F28:  BNZ   2F34
2F2A:  MOVF   x5A,F
2F2C:  BNZ   2F34
2F2E:  MOVF   x59,W
2F30:  SUBLW  64
2F32:  BC    2F82
2F34:  MOVF   x58,F
2F36:  BNZ   2F46
2F38:  MOVF   x57,F
2F3A:  BNZ   2F46
2F3C:  MOVF   x56,F
2F3E:  BNZ   2F46
2F40:  MOVF   x55,W
2F42:  SUBLW  64
2F44:  BC    2F82
2F46:  MOVF   x64,F
2F48:  BNZ   2F58
2F4A:  MOVF   x63,F
2F4C:  BNZ   2F58
2F4E:  MOVF   x62,F
2F50:  BNZ   2F58
2F52:  MOVF   x61,W
2F54:  SUBLW  64
2F56:  BC    2F82
2F58:  MOVF   x68,F
2F5A:  BNZ   2F6A
2F5C:  MOVF   x67,F
2F5E:  BNZ   2F6A
2F60:  MOVF   x66,F
2F62:  BNZ   2F6A
2F64:  MOVF   x65,W
2F66:  SUBLW  64
2F68:  BC    2F82
2F6A:  MOVF   x6C,F
2F6C:  BNZ   2F7C
2F6E:  MOVF   x6B,F
2F70:  BNZ   2F7C
2F72:  MOVF   x6A,F
2F74:  BNZ   2F7C
2F76:  MOVF   x69,W
2F78:  SUBLW  64
2F7A:  BC    2F82
2F7C:  MOVLW  02
2F7E:  MOVWF  01
2F80:  BRA    31F2
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2F82:  MOVF   x64,F
2F84:  BNZ   2F94
2F86:  MOVF   x63,F
2F88:  BNZ   2F94
2F8A:  MOVF   x62,F
2F8C:  BNZ   2F94
2F8E:  MOVF   x61,W
2F90:  SUBLW  05
2F92:  BC    3006
2F94:  MOVF   x64,F
2F96:  BNZ   3006
2F98:  MOVF   x63,F
2F9A:  BNZ   3006
2F9C:  MOVF   x62,F
2F9E:  BNZ   3006
2FA0:  MOVF   x61,W
2FA2:  SUBLW  3B
2FA4:  BNC   3006
2FA6:  MOVF   x5C,F
2FA8:  BNZ   2FB8
2FAA:  MOVF   x5B,F
2FAC:  BNZ   2FB8
2FAE:  MOVF   x5A,F
2FB0:  BNZ   2FB8
2FB2:  MOVF   x59,W
2FB4:  SUBLW  64
2FB6:  BC    3006
2FB8:  MOVF   x60,F
2FBA:  BNZ   2FCA
2FBC:  MOVF   x5F,F
2FBE:  BNZ   2FCA
2FC0:  MOVF   x5E,F
2FC2:  BNZ   2FCA
2FC4:  MOVF   x5D,W
2FC6:  SUBLW  64
2FC8:  BC    3006
2FCA:  MOVF   x58,F
2FCC:  BNZ   2FDC
2FCE:  MOVF   x57,F
2FD0:  BNZ   2FDC
2FD2:  MOVF   x56,F
2FD4:  BNZ   2FDC
2FD6:  MOVF   x55,W
2FD8:  SUBLW  64
2FDA:  BC    3006
2FDC:  MOVF   x68,F
2FDE:  BNZ   2FEE
2FE0:  MOVF   x67,F
2FE2:  BNZ   2FEE
2FE4:  MOVF   x66,F
2FE6:  BNZ   2FEE
2FE8:  MOVF   x65,W
2FEA:  SUBLW  64
2FEC:  BC    3006
2FEE:  MOVF   x6C,F
2FF0:  BNZ   3000
2FF2:  MOVF   x6B,F
2FF4:  BNZ   3000
2FF6:  MOVF   x6A,F
2FF8:  BNZ   3000
2FFA:  MOVF   x69,W
2FFC:  SUBLW  64
2FFE:  BC    3006
3000:  MOVLW  03
3002:  MOVWF  01
3004:  BRA    31F2
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
3006:  MOVF   x68,F
3008:  BNZ   3018
300A:  MOVF   x67,F
300C:  BNZ   3018
300E:  MOVF   x66,F
3010:  BNZ   3018
3012:  MOVF   x65,W
3014:  SUBLW  05
3016:  BC    308A
3018:  MOVF   x68,F
301A:  BNZ   308A
301C:  MOVF   x67,F
301E:  BNZ   308A
3020:  MOVF   x66,F
3022:  BNZ   308A
3024:  MOVF   x65,W
3026:  SUBLW  3B
3028:  BNC   308A
302A:  MOVF   x5C,F
302C:  BNZ   303C
302E:  MOVF   x5B,F
3030:  BNZ   303C
3032:  MOVF   x5A,F
3034:  BNZ   303C
3036:  MOVF   x59,W
3038:  SUBLW  64
303A:  BC    308A
303C:  MOVF   x60,F
303E:  BNZ   304E
3040:  MOVF   x5F,F
3042:  BNZ   304E
3044:  MOVF   x5E,F
3046:  BNZ   304E
3048:  MOVF   x5D,W
304A:  SUBLW  64
304C:  BC    308A
304E:  MOVF   x64,F
3050:  BNZ   3060
3052:  MOVF   x63,F
3054:  BNZ   3060
3056:  MOVF   x62,F
3058:  BNZ   3060
305A:  MOVF   x61,W
305C:  SUBLW  64
305E:  BC    308A
3060:  MOVF   x58,F
3062:  BNZ   3072
3064:  MOVF   x57,F
3066:  BNZ   3072
3068:  MOVF   x56,F
306A:  BNZ   3072
306C:  MOVF   x55,W
306E:  SUBLW  64
3070:  BC    308A
3072:  MOVF   x6C,F
3074:  BNZ   3084
3076:  MOVF   x6B,F
3078:  BNZ   3084
307A:  MOVF   x6A,F
307C:  BNZ   3084
307E:  MOVF   x69,W
3080:  SUBLW  64
3082:  BC    308A
3084:  MOVLW  04
3086:  MOVWF  01
3088:  BRA    31F2
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
308A:  MOVF   x6C,F
308C:  BNZ   309C
308E:  MOVF   x6B,F
3090:  BNZ   309C
3092:  MOVF   x6A,F
3094:  BNZ   309C
3096:  MOVF   x69,W
3098:  SUBLW  05
309A:  BC    310E
309C:  MOVF   x6C,F
309E:  BNZ   310E
30A0:  MOVF   x6B,F
30A2:  BNZ   310E
30A4:  MOVF   x6A,F
30A6:  BNZ   310E
30A8:  MOVF   x69,W
30AA:  SUBLW  3B
30AC:  BNC   310E
30AE:  MOVF   x5C,F
30B0:  BNZ   30C0
30B2:  MOVF   x5B,F
30B4:  BNZ   30C0
30B6:  MOVF   x5A,F
30B8:  BNZ   30C0
30BA:  MOVF   x59,W
30BC:  SUBLW  64
30BE:  BC    310E
30C0:  MOVF   x60,F
30C2:  BNZ   30D2
30C4:  MOVF   x5F,F
30C6:  BNZ   30D2
30C8:  MOVF   x5E,F
30CA:  BNZ   30D2
30CC:  MOVF   x5D,W
30CE:  SUBLW  64
30D0:  BC    310E
30D2:  MOVF   x64,F
30D4:  BNZ   30E4
30D6:  MOVF   x63,F
30D8:  BNZ   30E4
30DA:  MOVF   x62,F
30DC:  BNZ   30E4
30DE:  MOVF   x61,W
30E0:  SUBLW  64
30E2:  BC    310E
30E4:  MOVF   x68,F
30E6:  BNZ   30F6
30E8:  MOVF   x67,F
30EA:  BNZ   30F6
30EC:  MOVF   x66,F
30EE:  BNZ   30F6
30F0:  MOVF   x65,W
30F2:  SUBLW  64
30F4:  BC    310E
30F6:  MOVF   x58,F
30F8:  BNZ   3108
30FA:  MOVF   x57,F
30FC:  BNZ   3108
30FE:  MOVF   x56,F
3100:  BNZ   3108
3102:  MOVF   x55,W
3104:  SUBLW  64
3106:  BC    310E
3108:  MOVLW  05
310A:  MOVWF  01
310C:  BRA    31F2
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
310E:  MOVF   x6C,F
3110:  BNZ   3122
3112:  MOVF   x6B,F
3114:  BNZ   3122
3116:  MOVF   x6A,F
3118:  BNZ   3122
311A:  MOVF   x69,W
311C:  SUBLW  C8
311E:  BTFSC  FD8.0
3120:  BRA    31EE
3122:  MOVF   x58,F
3124:  BTFSS  FD8.2
3126:  BRA    31EE
3128:  MOVF   x57,F
312A:  BTFSS  FD8.2
312C:  BRA    31EE
312E:  MOVF   x56,F
3130:  BTFSS  FD8.2
3132:  BRA    31EE
3134:  MOVF   x55,W
3136:  SUBLW  B3
3138:  BTFSS  FD8.0
313A:  BRA    31EE
313C:  MOVF   x58,F
313E:  BNZ   3150
3140:  MOVF   x57,F
3142:  BNZ   3150
3144:  MOVF   x56,F
3146:  BNZ   3150
3148:  MOVF   x55,W
314A:  SUBLW  64
314C:  BTFSC  FD8.0
314E:  BRA    31EE
3150:  MOVF   x5C,F
3152:  BTFSS  FD8.2
3154:  BRA    31EE
3156:  MOVF   x5B,F
3158:  BTFSS  FD8.2
315A:  BRA    31EE
315C:  MOVF   x5A,F
315E:  BTFSS  FD8.2
3160:  BRA    31EE
3162:  MOVF   x59,W
3164:  SUBLW  B3
3166:  BNC   31EE
3168:  MOVF   x5C,F
316A:  BNZ   317A
316C:  MOVF   x5B,F
316E:  BNZ   317A
3170:  MOVF   x5A,F
3172:  BNZ   317A
3174:  MOVF   x59,W
3176:  SUBLW  64
3178:  BC    31EE
317A:  MOVF   x60,F
317C:  BNZ   31EE
317E:  MOVF   x5F,F
3180:  BNZ   31EE
3182:  MOVF   x5E,F
3184:  BNZ   31EE
3186:  MOVF   x5D,W
3188:  SUBLW  B3
318A:  BNC   31EE
318C:  MOVF   x60,F
318E:  BNZ   319E
3190:  MOVF   x5F,F
3192:  BNZ   319E
3194:  MOVF   x5E,F
3196:  BNZ   319E
3198:  MOVF   x5D,W
319A:  SUBLW  64
319C:  BC    31EE
319E:  MOVF   x64,F
31A0:  BNZ   31EE
31A2:  MOVF   x63,F
31A4:  BNZ   31EE
31A6:  MOVF   x62,F
31A8:  BNZ   31EE
31AA:  MOVF   x61,W
31AC:  SUBLW  B3
31AE:  BNC   31EE
31B0:  MOVF   x64,F
31B2:  BNZ   31C2
31B4:  MOVF   x63,F
31B6:  BNZ   31C2
31B8:  MOVF   x62,F
31BA:  BNZ   31C2
31BC:  MOVF   x61,W
31BE:  SUBLW  64
31C0:  BC    31EE
31C2:  MOVF   x68,F
31C4:  BNZ   31EE
31C6:  MOVF   x67,F
31C8:  BNZ   31EE
31CA:  MOVF   x66,F
31CC:  BNZ   31EE
31CE:  MOVF   x65,W
31D0:  SUBLW  B3
31D2:  BNC   31EE
31D4:  MOVF   x68,F
31D6:  BNZ   31E6
31D8:  MOVF   x67,F
31DA:  BNZ   31E6
31DC:  MOVF   x66,F
31DE:  BNZ   31E6
31E0:  MOVF   x65,W
31E2:  SUBLW  64
31E4:  BC    31EE
31E6:  MOVLW  05
31E8:  MOVWF  01
31EA:  BRA    31F2
....................    else return 0xff; 
31EC:  BRA    31F2
31EE:  MOVLW  FF
31F0:  MOVWF  01
.................... } 
31F2:  MOVLB  0
31F4:  GOTO   325A (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
31F8:  MOVLW  20
31FA:  MOVLB  8
31FC:  MOVWF  x51
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
31FE:  BSF    F93.4
3200:  BTFSS  F81.4
3202:  BRA    3216
3204:  BSF    F93.5
3206:  BTFSS  F81.5
3208:  BRA    3216
320A:  BSF    F93.6
320C:  BTFSS  F81.6
320E:  BRA    3216
3210:  BSF    F93.7
3212:  BTFSC  F81.7
3214:  BRA    337C
....................     { 
....................        if(input(ROW0)==0) 
3216:  BSF    F93.4
3218:  BTFSC  F81.4
321A:  BRA    3220
....................          row=0; 
321C:  CLRF   x52
....................        else if(input(ROW1)==0) 
321E:  BRA    3242
3220:  BSF    F93.5
3222:  BTFSC  F81.5
3224:  BRA    322C
....................          row=1; 
3226:  MOVLW  01
3228:  MOVWF  x52
....................        else if(input(ROW2)==0) 
322A:  BRA    3242
322C:  BSF    F93.6
322E:  BTFSC  F81.6
3230:  BRA    3238
....................          row=2; 
3232:  MOVLW  02
3234:  MOVWF  x52
....................        else if(input(ROW3)==0) 
3236:  BRA    3242
3238:  BSF    F93.7
323A:  BTFSC  F81.7
323C:  BRA    3242
....................          row=3;      
323E:  MOVLW  03
3240:  MOVWF  x52
....................        if(type_KB==0)col=check_col(); 
3242:  MOVLB  1
3244:  MOVF   x49,F
3246:  BNZ   3254
3248:  MOVLB  0
324A:  GOTO   23D8
324E:  MOVFF  01,850
....................          else col=new_check_col(); 
3252:  BRA    325E
3254:  MOVLB  0
3256:  GOTO   2A06
325A:  MOVFF  01,850
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
325E:  MOVLB  8
3260:  INCFSZ x50,W
3262:  BRA    3266
3264:  BRA    334C
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
3266:  MOVLB  1
3268:  MOVF   x49,F
326A:  BNZ   3292
326C:  MOVLB  8
326E:  MOVF   x52,W
3270:  MULLW  05
3272:  MOVF   FF3,W
3274:  CLRF   x54
3276:  MOVWF  x53
3278:  CLRF   03
327A:  MOVF   x50,W
327C:  ADDWF  x53,W
327E:  MOVWF  01
3280:  MOVF   x54,W
3282:  ADDWFC 03,F
3284:  MOVF   01,W
3286:  MOVLB  0
3288:  CALL   030A
328C:  MOVFF  FE8,851
....................            else kchar =newKEYS[row][col]; 
3290:  BRA    32B6
3292:  MOVLB  8
3294:  MOVF   x52,W
3296:  MULLW  06
3298:  MOVF   FF3,W
329A:  CLRF   x54
329C:  MOVWF  x53
329E:  CLRF   03
32A0:  MOVF   x50,W
32A2:  ADDWF  x53,W
32A4:  MOVWF  01
32A6:  MOVF   x54,W
32A8:  ADDWFC 03,F
32AA:  MOVF   01,W
32AC:  MOVLB  0
32AE:  CALL   032E
32B2:  MOVFF  FE8,851
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
32B6:  MOVLB  1
32B8:  MOVF   x44,F
32BA:  BNZ   333E
....................             { 
....................               charac_timeout=0; 
32BC:  CLRF   x00
32BE:  MOVLB  0
32C0:  CLRF   xFF
....................                if(key_count_ms<wideofkeystore) 
32C2:  MOVLB  1
32C4:  MOVF   x47,W
32C6:  SUBLW  0F
32C8:  BNC   333C
....................                { 
....................                    key_data[key_count_ms++]=kchar; 
32CA:  MOVF   x47,W
32CC:  INCF   x47,F
32CE:  CLRF   03
32D0:  ADDLW  4A
32D2:  MOVWF  FE9
32D4:  MOVLW  01
32D6:  ADDWFC 03,W
32D8:  MOVWF  FEA
32DA:  MOVFF  851,FEF
....................                    fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
32DE:  MOVLW  56
32E0:  MOVWF  FF6
32E2:  MOVLW  05
32E4:  MOVWF  FF7
32E6:  MOVLW  09
32E8:  MOVLB  9
32EA:  MOVWF  x00
32EC:  MOVLB  0
32EE:  CALL   1666
32F2:  MOVFF  147,859
32F6:  MOVLW  18
32F8:  MOVLB  8
32FA:  MOVWF  x5A
32FC:  MOVLB  0
32FE:  CALL   1796
3302:  MOVLW  5D
3304:  MOVLB  9
3306:  MOVWF  x0C
3308:  MOVLB  0
330A:  CALL   1620
330E:  MOVLW  20
3310:  MOVLB  9
3312:  MOVWF  x0C
3314:  MOVLB  0
3316:  CALL   1620
331A:  MOVFF  851,90C
331E:  CALL   1620
3322:  MOVLW  0D
3324:  MOVLB  9
3326:  MOVWF  x0C
3328:  MOVLB  0
332A:  CALL   1620
332E:  MOVLW  0A
3330:  MOVLB  9
3332:  MOVWF  x0C
3334:  MOVLB  0
3336:  CALL   1620
333A:  MOVLB  1
....................                } 
....................             } 
....................                else fputc(kchar,COM2); 
333C:  BRA    334A
333E:  MOVFF  851,90C
3342:  MOVLB  0
3344:  CALL   1620
3348:  MOVLB  1
334A:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
334C:  BSF    F93.4
334E:  BTFSS  F81.4
3350:  BRA    334C
3352:  BSF    F93.5
3354:  BTFSS  F81.5
3356:  BRA    334C
3358:  BSF    F93.6
335A:  BTFSS  F81.6
335C:  BRA    334C
335E:  BSF    F93.7
3360:  BTFSS  F81.7
3362:  BRA    334C
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3364:  BSF    F93.4
3366:  BTFSS  F81.4
3368:  BRA    3364
336A:  BSF    F93.5
336C:  BTFSS  F81.5
336E:  BRA    3364
3370:  BSF    F93.6
3372:  BTFSS  F81.6
3374:  BRA    3364
3376:  BSF    F93.7
3378:  BTFSS  F81.7
337A:  BRA    3364
....................     } 
....................   set_tris_a(0xff);     
337C:  MOVLW  FF
337E:  MOVWF  F92
....................   return(kchar); 
3380:  MOVFF  851,01
.................... }//*/ 
3384:  MOVLB  0
3386:  RETURN 0
....................  
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int8 i,tempdata; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
540C:  MOVF   27,F
540E:  BTFSS  FD8.2
5410:  BRA    55A8
5412:  MOVF   26,F
5414:  BTFSS  FD8.2
5416:  BRA    55A8
5418:  MOVF   25,W
541A:  SUBLW  FF
541C:  BTFSS  FD8.0
541E:  BRA    55A8
5420:  BNZ   542A
5422:  MOVF   24,W
5424:  SUBLW  FE
5426:  BTFSS  FD8.0
5428:  BRA    55A8
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
542A:  MOVLB  1
542C:  MOVF   x4A,F
542E:  BNZ   5436
5430:  MOVF   x47,F
5432:  BTFSC  FD8.2
5434:  BRA    5554
....................       { 
....................          temp=get_countcard(); 
5436:  MOVLB  0
5438:  CALL   3534
543C:  MOVFF  02,853
5440:  MOVFF  01,852
....................          //fprintf(COM2," get_countcard=%lu\n\r",temp); 
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
5444:  MOVLB  8
5446:  RLCF   x52,W
5448:  MOVWF  x54
544A:  RLCF   x53,W
544C:  MOVWF  x55
544E:  RLCF   x54,F
5450:  RLCF   x55,F
5452:  RLCF   x54,F
5454:  RLCF   x55,F
5456:  RLCF   x54,F
5458:  RLCF   x55,F
545A:  MOVLW  F0
545C:  ANDWF  x54,F
545E:  MOVLW  E1
5460:  ADDWF  x55,F
5462:  MOVLW  01
5464:  ADDWF  x54,W
5466:  MOVWF  01
5468:  MOVLW  00
546A:  ADDWFC x55,W
546C:  MOVFF  01,24
5470:  MOVWF  25
5472:  CLRF   26
5474:  CLRF   27
....................          //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<wideofkeystore;i++) 
5476:  CLRF   x50
5478:  MOVF   x50,W
547A:  SUBLW  0F
547C:  BNC   54C4
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
547E:  MOVF   x50,W
5480:  ADDWF  24,W
5482:  MOVWF  00
5484:  MOVLW  00
5486:  ADDWFC 25,W
5488:  MOVWF  01
548A:  MOVLW  00
548C:  ADDWFC 26,W
548E:  MOVWF  02
5490:  MOVLW  00
5492:  ADDWFC 27,W
5494:  MOVWF  03
5496:  MOVWF  x57
5498:  MOVFF  02,856
549C:  MOVFF  01,855
54A0:  MOVFF  00,854
54A4:  MOVFF  FE8,916
54A8:  MOVFF  02,915
54AC:  MOVFF  01,914
54B0:  MOVFF  00,913
54B4:  MOVLB  9
54B6:  CLRF   x17
54B8:  MOVLB  0
54BA:  CALL   3A80
....................          } 
54BE:  MOVLB  8
54C0:  INCF   x50,F
54C2:  BRA    5478
....................          for(i=0;i<wideofkeystore;i++) 
54C4:  CLRF   x50
54C6:  MOVF   x50,W
54C8:  SUBLW  0F
54CA:  BNC   5536
....................          { 
....................             tempdata=key_data[i]; 
54CC:  CLRF   03
54CE:  MOVF   x50,W
54D0:  ADDLW  4A
54D2:  MOVWF  FE9
54D4:  MOVLW  01
54D6:  ADDWFC 03,W
54D8:  MOVWF  FEA
54DA:  MOVFF  FEF,851
....................             write_ext_eeprom((int32)ptr_card_key++,tempdata); 
54DE:  MOVFF  27,03
54E2:  MOVFF  26,02
54E6:  MOVFF  25,01
54EA:  MOVFF  24,00
54EE:  MOVLW  01
54F0:  ADDWF  24,F
54F2:  BTFSC  FD8.0
54F4:  INCF   25,F
54F6:  BTFSC  FD8.2
54F8:  INCF   26,F
54FA:  BTFSC  FD8.2
54FC:  INCF   27,F
54FE:  MOVFF  03,857
5502:  MOVFF  02,856
5506:  MOVFF  01,855
550A:  MOVFF  00,854
550E:  MOVFF  03,916
5512:  MOVFF  02,915
5516:  MOVFF  01,914
551A:  MOVFF  00,913
551E:  MOVFF  851,917
5522:  MOVLB  0
5524:  CALL   3A80
....................             //delay_us(100); 
....................             fprintf(COM2,"%c",tempdata); 
5528:  MOVFF  851,90C
552C:  CALL   1620
....................          } 
5530:  MOVLB  8
5532:  INCF   x50,F
5534:  BRA    54C6
....................           //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................           /*fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<wideofkeystore;i++) 
....................           { 
....................             fprintf(COM2,"%c",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5536:  MOVFF  27,903
553A:  MOVFF  26,902
553E:  MOVFF  25,901
5542:  MOVFF  24,900
5546:  MOVLW  1E
5548:  MOVLB  9
554A:  MOVWF  x04
554C:  MOVLB  0
554E:  CALL   3B7E
5552:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
5554:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
5556:  MOVLW  01
5558:  MOVWF  FEA
555A:  MOVLW  4A
555C:  MOVWF  FE9
555E:  CLRF   00
5560:  CLRF   02
5562:  MOVLW  10
5564:  MOVWF  01
5566:  MOVLB  0
5568:  CALL   35AE
....................       fprintf(COM2,"\r\n"); 
556C:  MOVLW  0D
556E:  MOVLB  9
5570:  MOVWF  x0C
5572:  MOVLB  0
5574:  CALL   1620
5578:  MOVLW  0A
557A:  MOVLB  9
557C:  MOVWF  x0C
557E:  MOVLB  0
5580:  CALL   1620
....................       fprintf(COM2,"Done save_key_new"); 
5584:  MOVLW  68
5586:  MOVWF  FF6
5588:  MOVLW  05
558A:  MOVWF  FF7
558C:  CALL   174A
....................       fprintf(COM2,"\r\n"); 
5590:  MOVLW  0D
5592:  MOVLB  9
5594:  MOVWF  x0C
5596:  MOVLB  0
5598:  CALL   1620
559C:  MOVLW  0A
559E:  MOVLB  9
55A0:  MOVWF  x0C
55A2:  MOVLB  0
55A4:  CALL   1620
....................    } 
.................... } 
55A8:  GOTO   5ABC (RETURN)
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 recEn[wideofkeystore]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
55AC:  MOVF   27,F
55AE:  BTFSS  FD8.2
55B0:  BRA    57F0
55B2:  MOVF   26,F
55B4:  BTFSS  FD8.2
55B6:  BRA    57F0
55B8:  MOVF   25,W
55BA:  SUBLW  FF
55BC:  BTFSS  FD8.0
55BE:  BRA    57F0
55C0:  BNZ   55CA
55C2:  MOVF   24,W
55C4:  SUBLW  FE
55C6:  BTFSS  FD8.0
55C8:  BRA    57F0
....................    {   
....................      for(i=0;i<key_numbyte;i++) 
55CA:  MOVLB  8
55CC:  CLRF   x50
55CE:  MOVF   x50,W
55D0:  SUBLW  0B
55D2:  BNC   5626
....................      { 
....................         temp=key_data[i]; 
55D4:  CLRF   03
55D6:  MOVF   x50,W
55D8:  ADDLW  4A
55DA:  MOVWF  FE9
55DC:  MOVLW  01
55DE:  ADDWFC 03,W
55E0:  MOVWF  FEA
55E2:  CLRF   x52
55E4:  MOVFF  FEF,851
....................         fputc(temp,COM2); 
55E8:  MOVFF  851,90C
55EC:  MOVLB  0
55EE:  CALL   1620
....................         recEn[i]=key_data[i]; 
55F2:  CLRF   03
55F4:  MOVLB  8
55F6:  MOVF   x50,W
55F8:  ADDLW  54
55FA:  MOVWF  01
55FC:  MOVLW  08
55FE:  ADDWFC 03,F
5600:  MOVFF  03,865
5604:  CLRF   03
5606:  MOVF   x50,W
5608:  ADDLW  4A
560A:  MOVWF  FE9
560C:  MOVLW  01
560E:  ADDWFC 03,W
5610:  MOVWF  FEA
5612:  MOVFF  FEF,866
5616:  MOVFF  865,FEA
561A:  MOVFF  01,FE9
561E:  MOVFF  866,FEF
....................      } 
5622:  INCF   x50,F
5624:  BRA    55CE
....................      recEn[key_numbyte] = 0; 
5626:  CLRF   x60
....................      recEn[key_numbyte+1] = 0;          
5628:  CLRF   x61
....................      recEn[key_numbyte+2] = 0;          
562A:  CLRF   x62
....................      recEn[key_numbyte+3] = 0; 
562C:  CLRF   x63
.................... #if 0 
....................      fprintf(COM2,"\n\r"); 
....................      fprintf(COM2,"test_key:\n\r"); 
....................      for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................      fprintf(COM2,"\n\r"); 
....................      fprintf(COM2,"\n\rdatain:\n\r"); 
....................      for(i=0;i<16;i++) fprintf(COM2," %x",recEn[i]); 
....................      fprintf(COM2,"\n\r"); 
.................... #endif 
....................      EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
562E:  MOVLB  9
5630:  CLRF   x07
5632:  CLRF   x06
5634:  CLRF   x05
5636:  MOVLW  3F
5638:  MOVWF  x04
563A:  CLRF   x0B
563C:  CLRF   x0A
563E:  CLRF   x09
5640:  MOVLW  20
5642:  MOVWF  x08
5644:  MOVLW  01
5646:  MOVWF  x0D
5648:  MOVWF  x0C
564A:  MOVLB  0
564C:  CALL   4086
....................      aes_enc_dec((unsigned int8 *)&recEn[0], (unsigned int8 *)&crypto_key[0],0); 
5650:  MOVLW  08
5652:  MOVLB  9
5654:  MOVWF  x01
5656:  MOVLW  54
5658:  MOVWF  x00
565A:  MOVLW  01
565C:  MOVWF  x03
565E:  MOVWF  x02
5660:  CLRF   x04
5662:  MOVLB  0
5664:  CALL   417C
....................      //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................       
....................      /* get the pointer of keyboard data */ 
....................      temp=get_countcard(); 
5668:  CALL   3534
566C:  MOVFF  02,852
5670:  MOVFF  01,851
....................      ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
5674:  MOVLB  8
5676:  RLCF   x51,W
5678:  MOVWF  x64
567A:  RLCF   x52,W
567C:  MOVWF  x65
567E:  RLCF   x64,F
5680:  RLCF   x65,F
5682:  RLCF   x64,F
5684:  RLCF   x65,F
5686:  RLCF   x64,F
5688:  RLCF   x65,F
568A:  MOVLW  F0
568C:  ANDWF  x64,F
568E:  MOVLW  E1
5690:  ADDWF  x65,F
5692:  MOVLW  01
5694:  ADDWF  x64,W
5696:  MOVWF  01
5698:  MOVLW  00
569A:  ADDWFC x65,W
569C:  MOVFF  01,24
56A0:  MOVWF  25
56A2:  CLRF   26
56A4:  CLRF   27
....................      /* delete the old data of key store area  */ 
....................      //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................      for(i=0;i<wideofkeystore;i++) 
56A6:  CLRF   x50
56A8:  MOVF   x50,W
56AA:  SUBLW  0F
56AC:  BNC   56F4
....................      { 
....................         write_ext_eeprom((int32)(ptr_card_key+i),0); 
56AE:  MOVF   x50,W
56B0:  ADDWF  24,W
56B2:  MOVWF  00
56B4:  MOVLW  00
56B6:  ADDWFC 25,W
56B8:  MOVWF  01
56BA:  MOVLW  00
56BC:  ADDWFC 26,W
56BE:  MOVWF  02
56C0:  MOVLW  00
56C2:  ADDWFC 27,W
56C4:  MOVWF  03
56C6:  MOVWF  x67
56C8:  MOVFF  02,866
56CC:  MOVFF  01,865
56D0:  MOVFF  00,864
56D4:  MOVFF  FE8,916
56D8:  MOVFF  02,915
56DC:  MOVFF  01,914
56E0:  MOVFF  00,913
56E4:  MOVLB  9
56E6:  CLRF   x17
56E8:  MOVLB  0
56EA:  CALL   3A80
....................      } 
56EE:  MOVLB  8
56F0:  INCF   x50,F
56F2:  BRA    56A8
....................      fprintf(COM2,"\n\r"); 
56F4:  MOVLW  0A
56F6:  MOVLB  9
56F8:  MOVWF  x0C
56FA:  MOVLB  0
56FC:  CALL   1620
5700:  MOVLW  0D
5702:  MOVLB  9
5704:  MOVWF  x0C
5706:  MOVLB  0
5708:  CALL   1620
....................      for(i=0;i<wideofkeystore;i++) fprintf(COM2,"%x",recEn[i]); 
570C:  MOVLB  8
570E:  CLRF   x50
5710:  MOVF   x50,W
5712:  SUBLW  0F
5714:  BNC   573E
5716:  CLRF   03
5718:  MOVF   x50,W
571A:  ADDLW  54
571C:  MOVWF  FE9
571E:  MOVLW  08
5720:  ADDWFC 03,W
5722:  MOVWF  FEA
5724:  MOVFF  FEF,864
5728:  MOVFF  864,901
572C:  MOVLW  57
572E:  MOVLB  9
5730:  MOVWF  x02
5732:  MOVLB  0
5734:  CALL   4E80
5738:  MOVLB  8
573A:  INCF   x50,F
573C:  BRA    5710
....................      retval = EEPROM_write(ptr_card_key,wideofkeystore,recEn);  
573E:  MOVFF  27,903
5742:  MOVFF  26,902
5746:  MOVFF  25,901
574A:  MOVFF  24,900
574E:  MOVLB  9
5750:  CLRF   x07
5752:  CLRF   x06
5754:  CLRF   x05
5756:  MOVLW  10
5758:  MOVWF  x04
575A:  MOVLW  08
575C:  MOVWF  x09
575E:  MOVLW  54
5760:  MOVWF  x08
5762:  MOVLB  0
5764:  CALL   4DF0
5768:  MOVFF  01,853
....................      if(retval!=0) 
576C:  MOVLB  8
576E:  MOVF   x53,F
5770:  BZ    579A
....................      { 
....................         ptr_card_key+=wideofkeystore; 
5772:  MOVLW  10
5774:  ADDWF  24,F
5776:  MOVLW  00
5778:  ADDWFC 25,F
577A:  ADDWFC 26,F
577C:  ADDWFC 27,F
....................         save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
577E:  MOVFF  27,903
5782:  MOVFF  26,902
5786:  MOVFF  25,901
578A:  MOVFF  24,900
578E:  MOVLW  1E
5790:  MOVLB  9
5792:  MOVWF  x04
5794:  MOVLB  0
5796:  CALL   3B7E
....................      }          
....................       key_count_ms=0; 
579A:  MOVLB  1
579C:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
579E:  MOVLW  01
57A0:  MOVWF  FEA
57A2:  MOVLW  4A
57A4:  MOVWF  FE9
57A6:  CLRF   00
57A8:  CLRF   02
57AA:  MOVLW  10
57AC:  MOVWF  01
57AE:  MOVLB  0
57B0:  CALL   35AE
....................       fprintf(COM2,"\r\n"); 
57B4:  MOVLW  0D
57B6:  MOVLB  9
57B8:  MOVWF  x0C
57BA:  MOVLB  0
57BC:  CALL   1620
57C0:  MOVLW  0A
57C2:  MOVLB  9
57C4:  MOVWF  x0C
57C6:  MOVLB  0
57C8:  CALL   1620
....................       fprintf(COM2,"Done Encrypted PIN"); 
57CC:  MOVLW  7A
57CE:  MOVWF  FF6
57D0:  MOVLW  05
57D2:  MOVWF  FF7
57D4:  CALL   174A
....................       fprintf(COM2,"\r\n"); 
57D8:  MOVLW  0D
57DA:  MOVLB  9
57DC:  MOVWF  x0C
57DE:  MOVLB  0
57E0:  CALL   1620
57E4:  MOVLW  0A
57E6:  MOVLB  9
57E8:  MOVWF  x0C
57EA:  MOVLB  0
57EC:  CALL   1620
....................    } 
.................... } 
57F0:  GOTO   5AC4 (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
5ED2:  MOVLB  7
5ED4:  CLRF   xFA
5ED6:  CLRF   xF9
5ED8:  CLRF   xFB
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
5EDA:  MOVF   xFA,F
5EDC:  BTFSS  FD8.2
5EDE:  BRA    6002
5EE0:  MOVF   xF4,W
5EE2:  SUBWF  xF9,W
5EE4:  BTFSC  FD8.0
5EE6:  BRA    6002
5EE8:  MOVF   xFB,F
5EEA:  BTFSS  FD8.2
5EEC:  BRA    6002
....................       c = fgetc(COM2);//getc(); 
5EEE:  MOVLB  0
5EF0:  RCALL  5E84
5EF2:  MOVFF  01,7F7
....................       switch(c) 
....................       { 
5EF6:  MOVLB  7
5EF8:  MOVF   xF7,W
5EFA:  XORLW  7F
5EFC:  MOVLB  0
5EFE:  BZ    5F06
5F00:  XORLW  72
5F02:  BZ    5F54
5F04:  BRA    5F92
....................          case 0x7f:    
....................             if(nbcar>0)   
5F06:  MOVLB  7
5F08:  MOVF   xF9,F
5F0A:  BNZ   5F10
5F0C:  MOVF   xFA,F
5F0E:  BZ    5F3A
5F10:  CLRF   19
5F12:  BTFSC  FF2.7
5F14:  BSF    19.7
5F16:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
5F18:  MOVLW  7F
5F1A:  MOVLB  9
5F1C:  MOVWF  x0C
5F1E:  MOVLB  0
5F20:  CALL   1620
5F24:  BTFSC  19.7
5F26:  BSF    FF2.7
....................                nbcar--; 
5F28:  MOVLB  7
5F2A:  MOVF   xF9,W
5F2C:  BTFSC  FD8.2
5F2E:  DECF   xFA,F
5F30:  DECF   xF9,F
....................                fgetc(COM2);//getc(); 
5F32:  MOVLB  0
5F34:  RCALL  5E84
....................             } 
....................             else fputc(0x07,COM2);    
5F36:  BRA    5F52
5F38:  MOVLB  7
5F3A:  CLRF   19
5F3C:  BTFSC  FF2.7
5F3E:  BSF    19.7
5F40:  BCF    FF2.7
5F42:  MOVLW  07
5F44:  MOVLB  9
5F46:  MOVWF  x0C
5F48:  MOVLB  0
5F4A:  CALL   1620
5F4E:  BTFSC  19.7
5F50:  BSF    FF2.7
....................          break;  
5F52:  BRA    5FFE
....................          case 0x0D:   
....................                keydebug_en=0; 
5F54:  MOVLB  1
5F56:  CLRF   x44
....................                set_tris_a(0xff); 
5F58:  MOVLW  FF
5F5A:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
5F5C:  MOVFF  7F9,7F8
5F60:  MOVLB  7
5F62:  MOVF   xF4,W
5F64:  SUBWF  xF8,W
5F66:  BC    5F7C
....................                { 
....................                  chaine[i]=0; 
5F68:  CLRF   03
5F6A:  MOVF   xF8,W
5F6C:  ADDWF  xF5,W
5F6E:  MOVWF  FE9
5F70:  MOVF   xF6,W
5F72:  ADDWFC 03,W
5F74:  MOVWF  FEA
5F76:  CLRF   FEF
....................                } 
5F78:  INCF   xF8,F
5F7A:  BRA    5F62
....................                if(nbcar==0)return(FAUX); 
5F7C:  MOVF   xF9,F
5F7E:  BNZ   5F8A
5F80:  MOVF   xFA,F
5F82:  BNZ   5F8A
5F84:  MOVLW  00
5F86:  MOVWF  01
5F88:  BRA    6006
....................                fini=VRAI; 
5F8A:  MOVLW  01
5F8C:  MOVWF  xFB
....................          break; 
5F8E:  MOVLB  0
5F90:  BRA    5FFE
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
5F92:  MOVLB  7
5F94:  MOVF   xF7,W
5F96:  SUBLW  1F
5F98:  BC    6000
5F9A:  MOVF   xF7,W
5F9C:  SUBLW  7E
5F9E:  BNC   6000
5FA0:  MOVLW  01
5FA2:  SUBWF  xF4,W
5FA4:  MOVF   xFA,F
5FA6:  BNZ   6000
5FA8:  SUBWF  xF9,W
5FAA:  BC    6000
....................             { 
....................                chaine[nbcar]=c; 
5FAC:  MOVF   xF5,W
5FAE:  ADDWF  xF9,W
5FB0:  MOVWF  FE9
5FB2:  MOVF   xF6,W
5FB4:  ADDWFC xFA,W
5FB6:  MOVWF  FEA
5FB8:  MOVFF  7F7,FEF
....................                nbcar++; 
5FBC:  INCF   xF9,F
5FBE:  BTFSC  FD8.2
5FC0:  INCF   xFA,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
5FC2:  DECFSZ xF3,W
5FC4:  BRA    5FE0
5FC6:  CLRF   19
5FC8:  BTFSC  FF2.7
5FCA:  BSF    19.7
5FCC:  BCF    FF2.7
5FCE:  MOVFF  7F7,90C
5FD2:  MOVLB  0
5FD4:  CALL   1620
5FD8:  BTFSC  19.7
5FDA:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
5FDC:  BRA    5FFE
5FDE:  MOVLB  7
5FE0:  MOVF   xF3,W
5FE2:  SUBLW  02
5FE4:  BNZ   6000
5FE6:  CLRF   19
5FE8:  BTFSC  FF2.7
5FEA:  BSF    19.7
5FEC:  BCF    FF2.7
5FEE:  MOVLW  2A
5FF0:  MOVLB  9
5FF2:  MOVWF  x0C
5FF4:  MOVLB  0
5FF6:  CALL   1620
5FFA:  BTFSC  19.7
5FFC:  BSF    FF2.7
5FFE:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
6000:  BRA    5EDA
....................    return(nbcar); 
6002:  MOVFF  7F9,01
.................... } 
6006:  MOVLB  0
6008:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
600A:  MOVFF  7F4,7F8
600E:  MOVFF  7F3,7F7
6012:  MOVFF  7F6,7FA
6016:  MOVFF  7F5,7F9
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
601A:  MOVFF  7F8,03
601E:  MOVLB  7
6020:  MOVFF  7F7,FE9
6024:  MOVFF  7F8,FEA
6028:  MOVF   FEF,F
602A:  BZ    6072
602C:  MOVFF  7FA,03
6030:  MOVFF  7F9,FE9
6034:  MOVFF  7FA,FEA
6038:  MOVF   FEF,F
603A:  BZ    6072
....................       if(*aa!=*bb) 
603C:  MOVFF  7F7,FE9
6040:  MOVFF  7F8,FEA
6044:  MOVFF  FEF,7FB
6048:  MOVFF  7FA,03
604C:  MOVFF  7F9,FE9
6050:  MOVFF  7FA,FEA
6054:  MOVF   FEF,W
6056:  SUBWF  xFB,W
6058:  BZ    6060
....................          return(1); 
605A:  MOVLW  01
605C:  MOVWF  01
605E:  BRA    609E
....................       aa++; 
6060:  INCF   xF7,F
6062:  BTFSC  FD8.2
6064:  INCF   xF8,F
....................       bb++; 
6066:  INCF   xF9,F
6068:  BTFSC  FD8.2
606A:  INCF   xFA,F
....................    } 
606C:  MOVLB  0
606E:  BRA    601A
6070:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
6072:  MOVFF  7F8,03
6076:  MOVFF  7F7,FE9
607A:  MOVFF  7F8,FEA
607E:  MOVFF  FEF,7FB
6082:  MOVFF  7FA,03
6086:  MOVFF  7F9,FE9
608A:  MOVFF  7FA,FEA
608E:  MOVF   FEF,W
6090:  SUBWF  xFB,W
6092:  BZ    609A
6094:  MOVLW  01
6096:  MOVWF  01
6098:  BRA    609E
....................    return(0); 
609A:  MOVLW  00
609C:  MOVWF  01
.................... } 
609E:  MOVLB  0
60A0:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
69E4:  MOVLB  7
69E6:  CLRF   xF5
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
69E8:  MOVFF  7F4,03
69EC:  MOVF   xF3,W
69EE:  INCF   xF3,F
69F0:  BTFSC  FD8.2
69F2:  INCF   xF4,F
69F4:  MOVWF  FE9
69F6:  MOVFF  03,FEA
69FA:  MOVFF  FEF,7F7
69FE:  MOVF   xF7,F
6A00:  BZ    6A24
....................         if (c >= '0' && c <= '9') 
6A02:  MOVF   xF7,W
6A04:  SUBLW  2F
6A06:  BC    6A16
6A08:  MOVF   xF7,W
6A0A:  SUBLW  39
6A0C:  BNC   6A16
....................             digit = (unsigned int) (c - '0'); 
6A0E:  MOVLW  30
6A10:  SUBWF  xF7,W
6A12:  MOVWF  xF6
....................         else 
6A14:  BRA    6A18
....................             break; 
6A16:  BRA    6A24
....................  
....................         val = (val * 10) + digit; 
6A18:  MOVF   xF5,W
6A1A:  MULLW  0A
6A1C:  MOVF   FF3,W
6A1E:  ADDWF  xF6,W
6A20:  MOVWF  xF5
....................     } 
6A22:  BRA    69E8
....................  
....................     return val; 
6A24:  CLRF   03
6A26:  MOVFF  7F5,01
6A2A:  MOVFF  03,02
.................... } 
6A2E:  MOVLB  0
6A30:  RETURN 0
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
06C8:  MOVLB  9
06CA:  CLRF   x3F
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
06CC:  CLRF   x40
06CE:  BTFSC  x37.0
06D0:  BSF    x40.7
06D2:  SWAPF  x38,W
06D4:  MOVWF  00
06D6:  RLCF   00,F
06D8:  RLCF   00,F
06DA:  MOVLW  C0
06DC:  ANDWF  00,F
06DE:  MOVF   00,W
06E0:  IORWF  x40,F
06E2:  SWAPF  x39,W
06E4:  MOVWF  00
06E6:  RLCF   00,F
06E8:  MOVLW  E0
06EA:  ANDWF  00,F
06EC:  MOVF   00,W
06EE:  IORWF  x40,F
06F0:  SWAPF  x3A,W
06F2:  MOVWF  00
06F4:  MOVLW  F0
06F6:  ANDWF  00,F
06F8:  MOVF   00,W
06FA:  IORWF  x40,F
06FC:  RLCF   x3B,W
06FE:  MOVWF  00
0700:  RLCF   00,F
0702:  RLCF   00,F
0704:  MOVLW  F8
0706:  ANDWF  00,F
0708:  MOVF   00,W
070A:  IORWF  x40,F
070C:  RLCF   x3C,W
070E:  MOVWF  00
0710:  RLCF   00,F
0712:  MOVLW  FC
0714:  ANDWF  00,F
0716:  MOVF   00,W
0718:  IORWF  x40,F
071A:  BCF    FD8.0
071C:  RLCF   x3D,W
071E:  IORWF  x40,F
0720:  MOVF   x3E,W
0722:  IORWF  x40,W
0724:  MOVWF  x3F
....................    return temp; 
0726:  MOVFF  93F,01
.................... } 
072A:  MOVLB  0
072C:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
072E:  MOVLB  9
0730:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
0732:  MOVF   x22,F
0734:  BNZ   080A
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
0736:  MOVF   x25,W
0738:  ADDWF  x23,W
073A:  MOVWF  FE9
073C:  MOVF   x26,W
073E:  ADDWFC x24,W
0740:  MOVWF  FEA
0742:  MOVFF  FEF,928
0746:  MOVLW  01
0748:  ADDWF  x23,W
074A:  MOVWF  x29
074C:  MOVLW  00
074E:  ADDWFC x24,W
0750:  MOVWF  x2A
0752:  MOVF   x25,W
0754:  ADDWF  x29,W
0756:  MOVWF  FE9
0758:  MOVF   x26,W
075A:  ADDWFC x2A,W
075C:  MOVWF  FEA
075E:  MOVF   FEF,W
0760:  XORWF  x28,F
0762:  MOVLW  02
0764:  ADDWF  x23,W
0766:  MOVWF  x2B
0768:  MOVLW  00
076A:  ADDWFC x24,W
076C:  MOVWF  x2C
076E:  MOVF   x25,W
0770:  ADDWF  x2B,W
0772:  MOVWF  FE9
0774:  MOVF   x26,W
0776:  ADDWFC x2C,W
0778:  MOVWF  FEA
077A:  MOVF   FEF,W
077C:  XORWF  x28,F
077E:  MOVLW  03
0780:  ADDWF  x23,W
0782:  MOVWF  x2D
0784:  MOVLW  00
0786:  ADDWFC x24,W
0788:  MOVWF  x2E
078A:  MOVF   x25,W
078C:  ADDWF  x2D,W
078E:  MOVWF  FE9
0790:  MOVF   x26,W
0792:  ADDWFC x2E,W
0794:  MOVWF  FEA
0796:  MOVF   FEF,W
0798:  XORWF  x28,F
079A:  MOVLW  04
079C:  ADDWF  x23,W
079E:  MOVWF  x2F
07A0:  MOVLW  00
07A2:  ADDWFC x24,W
07A4:  MOVWF  x30
07A6:  MOVF   x25,W
07A8:  ADDWF  x2F,W
07AA:  MOVWF  FE9
07AC:  MOVF   x26,W
07AE:  ADDWFC x30,W
07B0:  MOVWF  FEA
07B2:  MOVF   FEF,W
07B4:  XORWF  x28,F
07B6:  MOVLW  05
07B8:  ADDWF  x23,W
07BA:  MOVWF  x31
07BC:  MOVLW  00
07BE:  ADDWFC x24,W
07C0:  MOVWF  x32
07C2:  MOVF   x25,W
07C4:  ADDWF  x31,W
07C6:  MOVWF  FE9
07C8:  MOVF   x26,W
07CA:  ADDWFC x32,W
07CC:  MOVWF  FEA
07CE:  MOVF   FEF,W
07D0:  XORWF  x28,W
07D2:  BZ    07D8
07D4:  MOVLW  00
07D6:  BRA    07DA
07D8:  MOVLW  01
07DA:  MOVWF  x27
....................       if(temp==datain[offset+6]) return 1; 
07DC:  MOVLW  06
07DE:  ADDWF  x23,W
07E0:  MOVWF  x28
07E2:  MOVLW  00
07E4:  ADDWFC x24,W
07E6:  MOVWF  x29
07E8:  MOVF   x25,W
07EA:  ADDWF  x28,W
07EC:  MOVWF  FE9
07EE:  MOVF   x26,W
07F0:  ADDWFC x29,W
07F2:  MOVWF  FEA
07F4:  MOVF   FEF,W
07F6:  SUBWF  x27,W
07F8:  BNZ   0802
07FA:  MOVLW  01
07FC:  MOVWF  01
07FE:  BRA    08DA
....................          else return 0; 
0800:  BRA    0808
0802:  MOVLW  00
0804:  MOVWF  01
0806:  BRA    08DA
....................    } 
....................       else  
0808:  BRA    08DA
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
080A:  MOVF   x25,W
080C:  ADDWF  x23,W
080E:  MOVWF  FE9
0810:  MOVF   x26,W
0812:  ADDWFC x24,W
0814:  MOVWF  FEA
0816:  MOVFF  FEF,928
081A:  MOVLW  01
081C:  SUBWF  x23,W
081E:  MOVWF  x29
0820:  MOVLW  00
0822:  SUBWFB x24,W
0824:  MOVWF  x2A
0826:  MOVF   x25,W
0828:  ADDWF  x29,W
082A:  MOVWF  FE9
082C:  MOVF   x26,W
082E:  ADDWFC x2A,W
0830:  MOVWF  FEA
0832:  MOVF   FEF,W
0834:  XORWF  x28,F
0836:  MOVLW  02
0838:  SUBWF  x23,W
083A:  MOVWF  x2B
083C:  MOVLW  00
083E:  SUBWFB x24,W
0840:  MOVWF  x2C
0842:  MOVF   x25,W
0844:  ADDWF  x2B,W
0846:  MOVWF  FE9
0848:  MOVF   x26,W
084A:  ADDWFC x2C,W
084C:  MOVWF  FEA
084E:  MOVF   FEF,W
0850:  XORWF  x28,F
0852:  MOVLW  03
0854:  SUBWF  x23,W
0856:  MOVWF  x2D
0858:  MOVLW  00
085A:  SUBWFB x24,W
085C:  MOVWF  x2E
085E:  MOVF   x25,W
0860:  ADDWF  x2D,W
0862:  MOVWF  FE9
0864:  MOVF   x26,W
0866:  ADDWFC x2E,W
0868:  MOVWF  FEA
086A:  MOVF   FEF,W
086C:  XORWF  x28,F
086E:  MOVLW  04
0870:  SUBWF  x23,W
0872:  MOVWF  x2F
0874:  MOVLW  00
0876:  SUBWFB x24,W
0878:  MOVWF  x30
087A:  MOVF   x25,W
087C:  ADDWF  x2F,W
087E:  MOVWF  FE9
0880:  MOVF   x26,W
0882:  ADDWFC x30,W
0884:  MOVWF  FEA
0886:  MOVF   FEF,W
0888:  XORWF  x28,F
088A:  MOVLW  05
088C:  SUBWF  x23,W
088E:  MOVWF  x31
0890:  MOVLW  00
0892:  SUBWFB x24,W
0894:  MOVWF  x32
0896:  MOVF   x25,W
0898:  ADDWF  x31,W
089A:  MOVWF  FE9
089C:  MOVF   x26,W
089E:  ADDWFC x32,W
08A0:  MOVWF  FEA
08A2:  MOVF   FEF,W
08A4:  XORWF  x28,W
08A6:  BZ    08AC
08A8:  MOVLW  00
08AA:  BRA    08AE
08AC:  MOVLW  01
08AE:  MOVWF  x27
....................          if(temp==datain[offset-6]) return 1; 
08B0:  MOVLW  06
08B2:  SUBWF  x23,W
08B4:  MOVWF  x28
08B6:  MOVLW  00
08B8:  SUBWFB x24,W
08BA:  MOVWF  x29
08BC:  MOVF   x25,W
08BE:  ADDWF  x28,W
08C0:  MOVWF  FE9
08C2:  MOVF   x26,W
08C4:  ADDWFC x29,W
08C6:  MOVWF  FEA
08C8:  MOVF   FEF,W
08CA:  SUBWF  x27,W
08CC:  BNZ   08D6
08CE:  MOVLW  01
08D0:  MOVWF  01
08D2:  BRA    08DA
....................             else return 0;          
08D4:  BRA    08DA
08D6:  MOVLW  00
08D8:  MOVWF  01
....................       } 
.................... } 
08DA:  MOVLB  0
08DC:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
08DE:  MOVLB  9
08E0:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
08E2:  MOVF   x22,F
08E4:  BNZ   0982
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
08E6:  MOVF   x25,W
08E8:  ADDWF  x23,W
08EA:  MOVWF  FE9
08EC:  MOVF   x26,W
08EE:  ADDWFC x24,W
08F0:  MOVWF  FEA
08F2:  MOVFF  FEF,928
08F6:  MOVLW  01
08F8:  ADDWF  x23,W
08FA:  MOVWF  x29
08FC:  MOVLW  00
08FE:  ADDWFC x24,W
0900:  MOVWF  x2A
0902:  MOVF   x25,W
0904:  ADDWF  x29,W
0906:  MOVWF  FE9
0908:  MOVF   x26,W
090A:  ADDWFC x2A,W
090C:  MOVWF  FEA
090E:  MOVF   FEF,W
0910:  XORWF  x28,F
0912:  MOVLW  02
0914:  ADDWF  x23,W
0916:  MOVWF  x2B
0918:  MOVLW  00
091A:  ADDWFC x24,W
091C:  MOVWF  x2C
091E:  MOVF   x25,W
0920:  ADDWF  x2B,W
0922:  MOVWF  FE9
0924:  MOVF   x26,W
0926:  ADDWFC x2C,W
0928:  MOVWF  FEA
092A:  MOVF   FEF,W
092C:  XORWF  x28,F
092E:  MOVLW  03
0930:  ADDWF  x23,W
0932:  MOVWF  x2D
0934:  MOVLW  00
0936:  ADDWFC x24,W
0938:  MOVWF  x2E
093A:  MOVF   x25,W
093C:  ADDWF  x2D,W
093E:  MOVWF  FE9
0940:  MOVF   x26,W
0942:  ADDWFC x2E,W
0944:  MOVWF  FEA
0946:  MOVF   FEF,W
0948:  XORWF  x28,W
094A:  BZ    0950
094C:  MOVLW  00
094E:  BRA    0952
0950:  MOVLW  01
0952:  MOVWF  x27
....................       if(temp==datain[offset+4]) return 1; 
0954:  MOVLW  04
0956:  ADDWF  x23,W
0958:  MOVWF  x28
095A:  MOVLW  00
095C:  ADDWFC x24,W
095E:  MOVWF  x29
0960:  MOVF   x25,W
0962:  ADDWF  x28,W
0964:  MOVWF  FE9
0966:  MOVF   x26,W
0968:  ADDWFC x29,W
096A:  MOVWF  FEA
096C:  MOVF   FEF,W
096E:  SUBWF  x27,W
0970:  BNZ   097A
0972:  MOVLW  01
0974:  MOVWF  01
0976:  BRA    0A1A
....................          else return 0; 
0978:  BRA    0980
097A:  MOVLW  00
097C:  MOVWF  01
097E:  BRA    0A1A
....................    } 
....................    else 
0980:  BRA    0A1A
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0982:  MOVF   x25,W
0984:  ADDWF  x23,W
0986:  MOVWF  FE9
0988:  MOVF   x26,W
098A:  ADDWFC x24,W
098C:  MOVWF  FEA
098E:  MOVFF  FEF,928
0992:  MOVLW  01
0994:  SUBWF  x23,W
0996:  MOVWF  x29
0998:  MOVLW  00
099A:  SUBWFB x24,W
099C:  MOVWF  x2A
099E:  MOVF   x25,W
09A0:  ADDWF  x29,W
09A2:  MOVWF  FE9
09A4:  MOVF   x26,W
09A6:  ADDWFC x2A,W
09A8:  MOVWF  FEA
09AA:  MOVF   FEF,W
09AC:  XORWF  x28,F
09AE:  MOVLW  02
09B0:  SUBWF  x23,W
09B2:  MOVWF  x2B
09B4:  MOVLW  00
09B6:  SUBWFB x24,W
09B8:  MOVWF  x2C
09BA:  MOVF   x25,W
09BC:  ADDWF  x2B,W
09BE:  MOVWF  FE9
09C0:  MOVF   x26,W
09C2:  ADDWFC x2C,W
09C4:  MOVWF  FEA
09C6:  MOVF   FEF,W
09C8:  XORWF  x28,F
09CA:  MOVLW  03
09CC:  SUBWF  x23,W
09CE:  MOVWF  x2D
09D0:  MOVLW  00
09D2:  SUBWFB x24,W
09D4:  MOVWF  x2E
09D6:  MOVF   x25,W
09D8:  ADDWF  x2D,W
09DA:  MOVWF  FE9
09DC:  MOVF   x26,W
09DE:  ADDWFC x2E,W
09E0:  MOVWF  FEA
09E2:  MOVF   FEF,W
09E4:  XORWF  x28,W
09E6:  BZ    09EC
09E8:  MOVLW  00
09EA:  BRA    09EE
09EC:  MOVLW  01
09EE:  MOVWF  x27
....................       if(temp==datain[offset-4]) return 1; 
09F0:  MOVLW  04
09F2:  SUBWF  x23,W
09F4:  MOVWF  x28
09F6:  MOVLW  00
09F8:  SUBWFB x24,W
09FA:  MOVWF  x29
09FC:  MOVF   x25,W
09FE:  ADDWF  x28,W
0A00:  MOVWF  FE9
0A02:  MOVF   x26,W
0A04:  ADDWFC x29,W
0A06:  MOVWF  FEA
0A08:  MOVF   FEF,W
0A0A:  SUBWF  x27,W
0A0C:  BNZ   0A16
0A0E:  MOVLW  01
0A10:  MOVWF  01
0A12:  BRA    0A1A
....................          else return 0;                
0A14:  BRA    0A1A
0A16:  MOVLW  00
0A18:  MOVWF  01
....................    } 
.................... } 
0A1A:  MOVLB  0
0A1C:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0A1E:  MOVLB  9
0A20:  CLRF   x1E
0A22:  CLRF   x1F
0A24:  CLRF   x20
0A26:  CLRF   x21
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0A28:  CLRF   x1B
0A2A:  CLRF   x1A
0A2C:  RRCF   x17,W
0A2E:  MOVWF  03
0A30:  RRCF   x16,W
0A32:  MOVWF  02
0A34:  RRCF   03,F
0A36:  RRCF   02,F
0A38:  MOVLW  3F
0A3A:  ANDWF  03,F
0A3C:  MOVFF  02,01
0A40:  MOVF   x1B,W
0A42:  SUBWF  03,W
0A44:  BTFSS  FD8.0
0A46:  BRA    1006
0A48:  BNZ   0A52
0A4A:  MOVF   01,W
0A4C:  SUBWF  x1A,W
0A4E:  BTFSC  FD8.0
0A50:  BRA    1006
....................    { 
....................       if(track==0) 
0A52:  MOVF   x15,F
0A54:  BTFSS  FD8.2
0A56:  BRA    0D8C
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0A58:  MOVLW  06
0A5A:  ADDWF  x1A,W
0A5C:  MOVWF  x22
0A5E:  MOVLW  00
0A60:  ADDWFC x1B,W
0A62:  MOVWF  x23
0A64:  MOVF   x18,W
0A66:  ADDWF  x22,W
0A68:  MOVWF  FE9
0A6A:  MOVF   x19,W
0A6C:  ADDWFC x23,W
0A6E:  MOVWF  FEA
0A70:  MOVFF  FEF,924
0A74:  MOVLW  05
0A76:  ADDWF  x1A,W
0A78:  MOVWF  x25
0A7A:  MOVLW  00
0A7C:  ADDWFC x1B,W
0A7E:  MOVWF  x26
0A80:  MOVF   x18,W
0A82:  ADDWF  x25,W
0A84:  MOVWF  FE9
0A86:  MOVF   x19,W
0A88:  ADDWFC x26,W
0A8A:  MOVWF  FEA
0A8C:  MOVFF  FEF,927
0A90:  MOVLW  04
0A92:  ADDWF  x1A,W
0A94:  MOVWF  x28
0A96:  MOVLW  00
0A98:  ADDWFC x1B,W
0A9A:  MOVWF  x29
0A9C:  MOVF   x18,W
0A9E:  ADDWF  x28,W
0AA0:  MOVWF  FE9
0AA2:  MOVF   x19,W
0AA4:  ADDWFC x29,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEF,92A
0AAC:  MOVLW  03
0AAE:  ADDWF  x1A,W
0AB0:  MOVWF  x2B
0AB2:  MOVLW  00
0AB4:  ADDWFC x1B,W
0AB6:  MOVWF  x2C
0AB8:  MOVF   x18,W
0ABA:  ADDWF  x2B,W
0ABC:  MOVWF  FE9
0ABE:  MOVF   x19,W
0AC0:  ADDWFC x2C,W
0AC2:  MOVWF  FEA
0AC4:  MOVFF  FEF,92D
0AC8:  MOVLW  02
0ACA:  ADDWF  x1A,W
0ACC:  MOVWF  x2E
0ACE:  MOVLW  00
0AD0:  ADDWFC x1B,W
0AD2:  MOVWF  x2F
0AD4:  MOVF   x18,W
0AD6:  ADDWF  x2E,W
0AD8:  MOVWF  FE9
0ADA:  MOVF   x19,W
0ADC:  ADDWFC x2F,W
0ADE:  MOVWF  FEA
0AE0:  MOVFF  FEF,930
0AE4:  MOVLW  01
0AE6:  ADDWF  x1A,W
0AE8:  MOVWF  x31
0AEA:  MOVLW  00
0AEC:  ADDWFC x1B,W
0AEE:  MOVWF  x32
0AF0:  MOVF   x18,W
0AF2:  ADDWF  x31,W
0AF4:  MOVWF  FE9
0AF6:  MOVF   x19,W
0AF8:  ADDWFC x32,W
0AFA:  MOVWF  FEA
0AFC:  MOVFF  FEF,933
0B00:  MOVF   x18,W
0B02:  ADDWF  x1A,W
0B04:  MOVWF  FE9
0B06:  MOVF   x19,W
0B08:  ADDWFC x1B,W
0B0A:  MOVWF  FEA
0B0C:  MOVFF  FEF,934
0B10:  CLRF   x37
0B12:  MOVFF  924,938
0B16:  MOVFF  927,939
0B1A:  MOVFF  92A,93A
0B1E:  MOVFF  92D,93B
0B22:  MOVFF  930,93C
0B26:  MOVFF  933,93D
0B2A:  MOVFF  934,93E
0B2E:  MOVLB  0
0B30:  RCALL  06C8
0B32:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0B36:  MOVLW  0D
0B38:  MOVLB  9
0B3A:  ADDWF  x1A,W
0B3C:  MOVWF  x22
0B3E:  MOVLW  00
0B40:  ADDWFC x1B,W
0B42:  MOVWF  x23
0B44:  MOVF   x18,W
0B46:  ADDWF  x22,W
0B48:  MOVWF  FE9
0B4A:  MOVF   x19,W
0B4C:  ADDWFC x23,W
0B4E:  MOVWF  FEA
0B50:  MOVFF  FEF,924
0B54:  MOVLW  0C
0B56:  ADDWF  x1A,W
0B58:  MOVWF  x25
0B5A:  MOVLW  00
0B5C:  ADDWFC x1B,W
0B5E:  MOVWF  x26
0B60:  MOVF   x18,W
0B62:  ADDWF  x25,W
0B64:  MOVWF  FE9
0B66:  MOVF   x19,W
0B68:  ADDWFC x26,W
0B6A:  MOVWF  FEA
0B6C:  MOVFF  FEF,927
0B70:  MOVLW  0B
0B72:  ADDWF  x1A,W
0B74:  MOVWF  x28
0B76:  MOVLW  00
0B78:  ADDWFC x1B,W
0B7A:  MOVWF  x29
0B7C:  MOVF   x18,W
0B7E:  ADDWF  x28,W
0B80:  MOVWF  FE9
0B82:  MOVF   x19,W
0B84:  ADDWFC x29,W
0B86:  MOVWF  FEA
0B88:  MOVFF  FEF,92A
0B8C:  MOVLW  0A
0B8E:  ADDWF  x1A,W
0B90:  MOVWF  x2B
0B92:  MOVLW  00
0B94:  ADDWFC x1B,W
0B96:  MOVWF  x2C
0B98:  MOVF   x18,W
0B9A:  ADDWF  x2B,W
0B9C:  MOVWF  FE9
0B9E:  MOVF   x19,W
0BA0:  ADDWFC x2C,W
0BA2:  MOVWF  FEA
0BA4:  MOVFF  FEF,92D
0BA8:  MOVLW  09
0BAA:  ADDWF  x1A,W
0BAC:  MOVWF  x2E
0BAE:  MOVLW  00
0BB0:  ADDWFC x1B,W
0BB2:  MOVWF  x2F
0BB4:  MOVF   x18,W
0BB6:  ADDWF  x2E,W
0BB8:  MOVWF  FE9
0BBA:  MOVF   x19,W
0BBC:  ADDWFC x2F,W
0BBE:  MOVWF  FEA
0BC0:  MOVFF  FEF,930
0BC4:  MOVLW  08
0BC6:  ADDWF  x1A,W
0BC8:  MOVWF  x31
0BCA:  MOVLW  00
0BCC:  ADDWFC x1B,W
0BCE:  MOVWF  x32
0BD0:  MOVF   x18,W
0BD2:  ADDWF  x31,W
0BD4:  MOVWF  FE9
0BD6:  MOVF   x19,W
0BD8:  ADDWFC x32,W
0BDA:  MOVWF  FEA
0BDC:  MOVFF  FEF,933
0BE0:  MOVLW  07
0BE2:  ADDWF  x1A,W
0BE4:  MOVWF  x34
0BE6:  MOVLW  00
0BE8:  ADDWFC x1B,W
0BEA:  MOVWF  x35
0BEC:  MOVF   x18,W
0BEE:  ADDWF  x34,W
0BF0:  MOVWF  FE9
0BF2:  MOVF   x19,W
0BF4:  ADDWFC x35,W
0BF6:  MOVWF  FEA
0BF8:  MOVFF  FEF,936
0BFC:  CLRF   x37
0BFE:  MOVFF  924,938
0C02:  MOVFF  927,939
0C06:  MOVFF  92A,93A
0C0A:  MOVFF  92D,93B
0C0E:  MOVFF  930,93C
0C12:  MOVFF  933,93D
0C16:  MOVFF  936,93E
0C1A:  MOVLB  0
0C1C:  RCALL  06C8
0C1E:  MOVFF  01,91F
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0C22:  MOVLB  9
0C24:  MOVF   x1E,W
0C26:  SUBLW  45
0C28:  BTFSS  FD8.2
0C2A:  BRA    0D8A
0C2C:  MOVF   x1F,W
0C2E:  SUBLW  7C
0C30:  BTFSC  FD8.2
0C32:  BRA    0D8A
0C34:  MOVF   x1F,W
0C36:  SUBLW  3E
0C38:  BTFSC  FD8.2
0C3A:  BRA    0D8A
0C3C:  MOVF   x1F,W
0C3E:  SUBLW  1F
0C40:  BTFSC  FD8.2
0C42:  BRA    0D8A
....................          { 
....................             j=i; 
0C44:  MOVFF  91B,91D
0C48:  MOVFF  91A,91C
....................             CRC=1; 
0C4C:  MOVLW  01
0C4E:  MOVWF  x21
....................             temp2=temp; 
0C50:  MOVFF  91E,920
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0C54:  MOVF   x20,W
0C56:  SUBLW  1F
0C58:  BTFSC  FD8.2
0C5A:  BRA    0D74
0C5C:  MOVF   x1D,W
0C5E:  SUBLW  03
0C60:  BTFSS  FD8.0
0C62:  BRA    0D74
0C64:  BNZ   0C6E
0C66:  MOVF   x1C,W
0C68:  SUBLW  E7
0C6A:  BTFSS  FD8.0
0C6C:  BRA    0D74
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C6E:  CLRF   x22
0C70:  MOVFF  91D,924
0C74:  MOVFF  91C,923
0C78:  MOVFF  919,926
0C7C:  MOVFF  918,925
0C80:  MOVLB  0
0C82:  RCALL  072E
0C84:  MOVF   01,W
0C86:  MOVLB  9
0C88:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C8A:  MOVLW  06
0C8C:  ADDWF  x1C,W
0C8E:  MOVWF  x22
0C90:  MOVLW  00
0C92:  ADDWFC x1D,W
0C94:  MOVWF  x23
0C96:  MOVF   x18,W
0C98:  ADDWF  x22,W
0C9A:  MOVWF  FE9
0C9C:  MOVF   x19,W
0C9E:  ADDWFC x23,W
0CA0:  MOVWF  FEA
0CA2:  MOVFF  FEF,924
0CA6:  MOVLW  05
0CA8:  ADDWF  x1C,W
0CAA:  MOVWF  x25
0CAC:  MOVLW  00
0CAE:  ADDWFC x1D,W
0CB0:  MOVWF  x26
0CB2:  MOVF   x18,W
0CB4:  ADDWF  x25,W
0CB6:  MOVWF  FE9
0CB8:  MOVF   x19,W
0CBA:  ADDWFC x26,W
0CBC:  MOVWF  FEA
0CBE:  MOVFF  FEF,927
0CC2:  MOVLW  04
0CC4:  ADDWF  x1C,W
0CC6:  MOVWF  x28
0CC8:  MOVLW  00
0CCA:  ADDWFC x1D,W
0CCC:  MOVWF  x29
0CCE:  MOVF   x18,W
0CD0:  ADDWF  x28,W
0CD2:  MOVWF  FE9
0CD4:  MOVF   x19,W
0CD6:  ADDWFC x29,W
0CD8:  MOVWF  FEA
0CDA:  MOVFF  FEF,92A
0CDE:  MOVLW  03
0CE0:  ADDWF  x1C,W
0CE2:  MOVWF  x2B
0CE4:  MOVLW  00
0CE6:  ADDWFC x1D,W
0CE8:  MOVWF  x2C
0CEA:  MOVF   x18,W
0CEC:  ADDWF  x2B,W
0CEE:  MOVWF  FE9
0CF0:  MOVF   x19,W
0CF2:  ADDWFC x2C,W
0CF4:  MOVWF  FEA
0CF6:  MOVFF  FEF,92D
0CFA:  MOVLW  02
0CFC:  ADDWF  x1C,W
0CFE:  MOVWF  x2E
0D00:  MOVLW  00
0D02:  ADDWFC x1D,W
0D04:  MOVWF  x2F
0D06:  MOVF   x18,W
0D08:  ADDWF  x2E,W
0D0A:  MOVWF  FE9
0D0C:  MOVF   x19,W
0D0E:  ADDWFC x2F,W
0D10:  MOVWF  FEA
0D12:  MOVFF  FEF,930
0D16:  MOVLW  01
0D18:  ADDWF  x1C,W
0D1A:  MOVWF  x31
0D1C:  MOVLW  00
0D1E:  ADDWFC x1D,W
0D20:  MOVWF  x32
0D22:  MOVF   x18,W
0D24:  ADDWF  x31,W
0D26:  MOVWF  FE9
0D28:  MOVF   x19,W
0D2A:  ADDWFC x32,W
0D2C:  MOVWF  FEA
0D2E:  MOVFF  FEF,933
0D32:  MOVF   x18,W
0D34:  ADDWF  x1C,W
0D36:  MOVWF  FE9
0D38:  MOVF   x19,W
0D3A:  ADDWFC x1D,W
0D3C:  MOVWF  FEA
0D3E:  MOVFF  FEF,934
0D42:  CLRF   x37
0D44:  MOVFF  924,938
0D48:  MOVFF  927,939
0D4C:  MOVFF  92A,93A
0D50:  MOVFF  92D,93B
0D54:  MOVFF  930,93C
0D58:  MOVFF  933,93D
0D5C:  MOVFF  934,93E
0D60:  MOVLB  0
0D62:  RCALL  06C8
0D64:  MOVFF  01,920
....................                j=j+7; 
0D68:  MOVLW  07
0D6A:  MOVLB  9
0D6C:  ADDWF  x1C,F
0D6E:  MOVLW  00
0D70:  ADDWFC x1D,F
....................             } 
0D72:  BRA    0C54
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D74:  DECFSZ x21,W
0D76:  BRA    0D8A
....................             { 
....................                dir=0; 
0D78:  MOVLB  6
0D7A:  CLRF   xC8
....................                return i; 
0D7C:  MOVLB  9
0D7E:  MOVFF  91A,01
0D82:  MOVFF  91B,02
0D86:  GOTO   161C
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0D8A:  BRA    0FFE
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0D8C:  MOVLW  04
0D8E:  ADDWF  x1A,W
0D90:  MOVWF  x22
0D92:  MOVLW  00
0D94:  ADDWFC x1B,W
0D96:  MOVWF  x23
0D98:  MOVF   x18,W
0D9A:  ADDWF  x22,W
0D9C:  MOVWF  FE9
0D9E:  MOVF   x19,W
0DA0:  ADDWFC x23,W
0DA2:  MOVWF  FEA
0DA4:  MOVFF  FEF,924
0DA8:  MOVLW  03
0DAA:  ADDWF  x1A,W
0DAC:  MOVWF  x25
0DAE:  MOVLW  00
0DB0:  ADDWFC x1B,W
0DB2:  MOVWF  x26
0DB4:  MOVF   x18,W
0DB6:  ADDWF  x25,W
0DB8:  MOVWF  FE9
0DBA:  MOVF   x19,W
0DBC:  ADDWFC x26,W
0DBE:  MOVWF  FEA
0DC0:  MOVFF  FEF,927
0DC4:  MOVLW  02
0DC6:  ADDWF  x1A,W
0DC8:  MOVWF  x28
0DCA:  MOVLW  00
0DCC:  ADDWFC x1B,W
0DCE:  MOVWF  x29
0DD0:  MOVF   x18,W
0DD2:  ADDWF  x28,W
0DD4:  MOVWF  FE9
0DD6:  MOVF   x19,W
0DD8:  ADDWFC x29,W
0DDA:  MOVWF  FEA
0DDC:  MOVFF  FEF,92A
0DE0:  MOVLW  01
0DE2:  ADDWF  x1A,W
0DE4:  MOVWF  x2B
0DE6:  MOVLW  00
0DE8:  ADDWFC x1B,W
0DEA:  MOVWF  x2C
0DEC:  MOVF   x18,W
0DEE:  ADDWF  x2B,W
0DF0:  MOVWF  FE9
0DF2:  MOVF   x19,W
0DF4:  ADDWFC x2C,W
0DF6:  MOVWF  FEA
0DF8:  MOVFF  FEF,92D
0DFC:  MOVF   x18,W
0DFE:  ADDWF  x1A,W
0E00:  MOVWF  FE9
0E02:  MOVF   x19,W
0E04:  ADDWFC x1B,W
0E06:  MOVWF  FEA
0E08:  MOVFF  FEF,92E
0E0C:  CLRF   x37
0E0E:  CLRF   x38
0E10:  CLRF   x39
0E12:  MOVFF  924,93A
0E16:  MOVFF  927,93B
0E1A:  MOVFF  92A,93C
0E1E:  MOVFF  92D,93D
0E22:  MOVFF  92E,93E
0E26:  MOVLB  0
0E28:  RCALL  06C8
0E2A:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0E2E:  MOVLW  09
0E30:  MOVLB  9
0E32:  ADDWF  x1A,W
0E34:  MOVWF  x22
0E36:  MOVLW  00
0E38:  ADDWFC x1B,W
0E3A:  MOVWF  x23
0E3C:  MOVF   x18,W
0E3E:  ADDWF  x22,W
0E40:  MOVWF  FE9
0E42:  MOVF   x19,W
0E44:  ADDWFC x23,W
0E46:  MOVWF  FEA
0E48:  MOVFF  FEF,924
0E4C:  MOVLW  08
0E4E:  ADDWF  x1A,W
0E50:  MOVWF  x25
0E52:  MOVLW  00
0E54:  ADDWFC x1B,W
0E56:  MOVWF  x26
0E58:  MOVF   x18,W
0E5A:  ADDWF  x25,W
0E5C:  MOVWF  FE9
0E5E:  MOVF   x19,W
0E60:  ADDWFC x26,W
0E62:  MOVWF  FEA
0E64:  MOVFF  FEF,927
0E68:  MOVLW  07
0E6A:  ADDWF  x1A,W
0E6C:  MOVWF  x28
0E6E:  MOVLW  00
0E70:  ADDWFC x1B,W
0E72:  MOVWF  x29
0E74:  MOVF   x18,W
0E76:  ADDWF  x28,W
0E78:  MOVWF  FE9
0E7A:  MOVF   x19,W
0E7C:  ADDWFC x29,W
0E7E:  MOVWF  FEA
0E80:  MOVFF  FEF,92A
0E84:  MOVLW  06
0E86:  ADDWF  x1A,W
0E88:  MOVWF  x2B
0E8A:  MOVLW  00
0E8C:  ADDWFC x1B,W
0E8E:  MOVWF  x2C
0E90:  MOVF   x18,W
0E92:  ADDWF  x2B,W
0E94:  MOVWF  FE9
0E96:  MOVF   x19,W
0E98:  ADDWFC x2C,W
0E9A:  MOVWF  FEA
0E9C:  MOVFF  FEF,92D
0EA0:  MOVLW  05
0EA2:  ADDWF  x1A,W
0EA4:  MOVWF  x2E
0EA6:  MOVLW  00
0EA8:  ADDWFC x1B,W
0EAA:  MOVWF  x2F
0EAC:  MOVF   x18,W
0EAE:  ADDWF  x2E,W
0EB0:  MOVWF  FE9
0EB2:  MOVF   x19,W
0EB4:  ADDWFC x2F,W
0EB6:  MOVWF  FEA
0EB8:  MOVFF  FEF,930
0EBC:  CLRF   x37
0EBE:  CLRF   x38
0EC0:  CLRF   x39
0EC2:  MOVFF  924,93A
0EC6:  MOVFF  927,93B
0ECA:  MOVFF  92A,93C
0ECE:  MOVFF  92D,93D
0ED2:  MOVFF  930,93E
0ED6:  MOVLB  0
0ED8:  CALL   06C8
0EDC:  MOVFF  01,91F
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0EE0:  MOVLB  9
0EE2:  MOVF   x1E,W
0EE4:  SUBLW  0B
0EE6:  BTFSS  FD8.2
0EE8:  BRA    0FFE
0EEA:  MOVF   x1F,W
0EEC:  SUBLW  1F
0EEE:  BTFSC  FD8.2
0EF0:  BRA    0FFE
0EF2:  MOVF   x1F,W
0EF4:  SUBLW  0F
0EF6:  BTFSC  FD8.2
0EF8:  BRA    0FFE
....................             { 
....................                j=i; 
0EFA:  MOVFF  91B,91D
0EFE:  MOVFF  91A,91C
....................                CRC=1; 
0F02:  MOVLW  01
0F04:  MOVWF  x21
....................                temp2=temp; 
0F06:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0F0A:  MOVF   x20,W
0F0C:  SUBLW  1F
0F0E:  BZ    0FEA
0F10:  MOVF   x1D,W
0F12:  SUBLW  01
0F14:  BNC   0FEA
0F16:  BNZ   0F1E
0F18:  MOVF   x1C,W
0F1A:  SUBLW  F3
0F1C:  BNC   0FEA
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0F1E:  CLRF   x22
0F20:  MOVFF  91D,924
0F24:  MOVFF  91C,923
0F28:  MOVFF  919,926
0F2C:  MOVFF  918,925
0F30:  MOVLB  0
0F32:  RCALL  08DE
0F34:  MOVF   01,W
0F36:  MOVLB  9
0F38:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0F3A:  MOVLW  04
0F3C:  ADDWF  x1C,W
0F3E:  MOVWF  x22
0F40:  MOVLW  00
0F42:  ADDWFC x1D,W
0F44:  MOVWF  x23
0F46:  MOVF   x18,W
0F48:  ADDWF  x22,W
0F4A:  MOVWF  FE9
0F4C:  MOVF   x19,W
0F4E:  ADDWFC x23,W
0F50:  MOVWF  FEA
0F52:  MOVFF  FEF,924
0F56:  MOVLW  03
0F58:  ADDWF  x1C,W
0F5A:  MOVWF  x25
0F5C:  MOVLW  00
0F5E:  ADDWFC x1D,W
0F60:  MOVWF  x26
0F62:  MOVF   x18,W
0F64:  ADDWF  x25,W
0F66:  MOVWF  FE9
0F68:  MOVF   x19,W
0F6A:  ADDWFC x26,W
0F6C:  MOVWF  FEA
0F6E:  MOVFF  FEF,927
0F72:  MOVLW  02
0F74:  ADDWF  x1C,W
0F76:  MOVWF  x28
0F78:  MOVLW  00
0F7A:  ADDWFC x1D,W
0F7C:  MOVWF  x29
0F7E:  MOVF   x18,W
0F80:  ADDWF  x28,W
0F82:  MOVWF  FE9
0F84:  MOVF   x19,W
0F86:  ADDWFC x29,W
0F88:  MOVWF  FEA
0F8A:  MOVFF  FEF,92A
0F8E:  MOVLW  01
0F90:  ADDWF  x1C,W
0F92:  MOVWF  x2B
0F94:  MOVLW  00
0F96:  ADDWFC x1D,W
0F98:  MOVWF  x2C
0F9A:  MOVF   x18,W
0F9C:  ADDWF  x2B,W
0F9E:  MOVWF  FE9
0FA0:  MOVF   x19,W
0FA2:  ADDWFC x2C,W
0FA4:  MOVWF  FEA
0FA6:  MOVFF  FEF,92D
0FAA:  MOVF   x18,W
0FAC:  ADDWF  x1C,W
0FAE:  MOVWF  FE9
0FB0:  MOVF   x19,W
0FB2:  ADDWFC x1D,W
0FB4:  MOVWF  FEA
0FB6:  MOVFF  FEF,92E
0FBA:  CLRF   x37
0FBC:  CLRF   x38
0FBE:  CLRF   x39
0FC0:  MOVFF  924,93A
0FC4:  MOVFF  927,93B
0FC8:  MOVFF  92A,93C
0FCC:  MOVFF  92D,93D
0FD0:  MOVFF  92E,93E
0FD4:  MOVLB  0
0FD6:  CALL   06C8
0FDA:  MOVFF  01,920
....................                   j=j+5; 
0FDE:  MOVLW  05
0FE0:  MOVLB  9
0FE2:  ADDWF  x1C,F
0FE4:  MOVLW  00
0FE6:  ADDWFC x1D,F
....................                } 
0FE8:  BRA    0F0A
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0FEA:  DECFSZ x21,W
0FEC:  BRA    0FFE
....................                { 
....................                   dir=0; 
0FEE:  MOVLB  6
0FF0:  CLRF   xC8
....................                   return i; 
0FF2:  MOVLB  9
0FF4:  MOVFF  91A,01
0FF8:  MOVFF  91B,02
0FFC:  BRA    161C
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0FFE:  INCF   x1A,F
1000:  BTFSC  FD8.2
1002:  INCF   x1B,F
1004:  BRA    0A2C
....................    for(i=end_point;i>end_point/4;i--) 
1006:  MOVFF  917,91B
100A:  MOVFF  916,91A
100E:  RRCF   x17,W
1010:  MOVWF  03
1012:  RRCF   x16,W
1014:  MOVWF  02
1016:  RRCF   03,F
1018:  RRCF   02,F
101A:  MOVLW  3F
101C:  ANDWF  03,F
101E:  MOVFF  02,01
1022:  MOVF   03,W
1024:  SUBWF  x1B,W
1026:  BTFSS  FD8.0
1028:  BRA    1616
102A:  BNZ   1034
102C:  MOVF   x1A,W
102E:  SUBWF  01,W
1030:  BTFSC  FD8.0
1032:  BRA    1616
....................    { 
....................       if(track==0) 
1034:  MOVF   x15,F
1036:  BTFSS  FD8.2
1038:  BRA    138C
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
103A:  MOVLW  06
103C:  SUBWF  x1A,W
103E:  MOVWF  x22
1040:  MOVLW  00
1042:  SUBWFB x1B,W
1044:  MOVWF  x23
1046:  MOVF   x18,W
1048:  ADDWF  x22,W
104A:  MOVWF  FE9
104C:  MOVF   x19,W
104E:  ADDWFC x23,W
1050:  MOVWF  FEA
1052:  MOVFF  FEF,924
1056:  MOVLW  05
1058:  SUBWF  x1A,W
105A:  MOVWF  x25
105C:  MOVLW  00
105E:  SUBWFB x1B,W
1060:  MOVWF  x26
1062:  MOVF   x18,W
1064:  ADDWF  x25,W
1066:  MOVWF  FE9
1068:  MOVF   x19,W
106A:  ADDWFC x26,W
106C:  MOVWF  FEA
106E:  MOVFF  FEF,927
1072:  MOVLW  04
1074:  SUBWF  x1A,W
1076:  MOVWF  x28
1078:  MOVLW  00
107A:  SUBWFB x1B,W
107C:  MOVWF  x29
107E:  MOVF   x18,W
1080:  ADDWF  x28,W
1082:  MOVWF  FE9
1084:  MOVF   x19,W
1086:  ADDWFC x29,W
1088:  MOVWF  FEA
108A:  MOVFF  FEF,92A
108E:  MOVLW  03
1090:  SUBWF  x1A,W
1092:  MOVWF  x2B
1094:  MOVLW  00
1096:  SUBWFB x1B,W
1098:  MOVWF  x2C
109A:  MOVF   x18,W
109C:  ADDWF  x2B,W
109E:  MOVWF  FE9
10A0:  MOVF   x19,W
10A2:  ADDWFC x2C,W
10A4:  MOVWF  FEA
10A6:  MOVFF  FEF,92D
10AA:  MOVLW  02
10AC:  SUBWF  x1A,W
10AE:  MOVWF  x2E
10B0:  MOVLW  00
10B2:  SUBWFB x1B,W
10B4:  MOVWF  x2F
10B6:  MOVF   x18,W
10B8:  ADDWF  x2E,W
10BA:  MOVWF  FE9
10BC:  MOVF   x19,W
10BE:  ADDWFC x2F,W
10C0:  MOVWF  FEA
10C2:  MOVFF  FEF,930
10C6:  MOVLW  01
10C8:  SUBWF  x1A,W
10CA:  MOVWF  x31
10CC:  MOVLW  00
10CE:  SUBWFB x1B,W
10D0:  MOVWF  x32
10D2:  MOVF   x18,W
10D4:  ADDWF  x31,W
10D6:  MOVWF  FE9
10D8:  MOVF   x19,W
10DA:  ADDWFC x32,W
10DC:  MOVWF  FEA
10DE:  MOVFF  FEF,933
10E2:  MOVF   x18,W
10E4:  ADDWF  x1A,W
10E6:  MOVWF  FE9
10E8:  MOVF   x19,W
10EA:  ADDWFC x1B,W
10EC:  MOVWF  FEA
10EE:  MOVFF  FEF,934
10F2:  CLRF   x37
10F4:  MOVFF  924,938
10F8:  MOVFF  927,939
10FC:  MOVFF  92A,93A
1100:  MOVFF  92D,93B
1104:  MOVFF  930,93C
1108:  MOVFF  933,93D
110C:  MOVFF  934,93E
1110:  MOVLB  0
1112:  CALL   06C8
1116:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
111A:  MOVLW  0D
111C:  MOVLB  9
111E:  SUBWF  x1A,W
1120:  MOVWF  x22
1122:  MOVLW  00
1124:  SUBWFB x1B,W
1126:  MOVWF  x23
1128:  MOVF   x18,W
112A:  ADDWF  x22,W
112C:  MOVWF  FE9
112E:  MOVF   x19,W
1130:  ADDWFC x23,W
1132:  MOVWF  FEA
1134:  MOVFF  FEF,924
1138:  MOVLW  0C
113A:  SUBWF  x1A,W
113C:  MOVWF  x25
113E:  MOVLW  00
1140:  SUBWFB x1B,W
1142:  MOVWF  x26
1144:  MOVF   x18,W
1146:  ADDWF  x25,W
1148:  MOVWF  FE9
114A:  MOVF   x19,W
114C:  ADDWFC x26,W
114E:  MOVWF  FEA
1150:  MOVFF  FEF,927
1154:  MOVLW  0B
1156:  SUBWF  x1A,W
1158:  MOVWF  x28
115A:  MOVLW  00
115C:  SUBWFB x1B,W
115E:  MOVWF  x29
1160:  MOVF   x18,W
1162:  ADDWF  x28,W
1164:  MOVWF  FE9
1166:  MOVF   x19,W
1168:  ADDWFC x29,W
116A:  MOVWF  FEA
116C:  MOVFF  FEF,92A
1170:  MOVLW  0A
1172:  SUBWF  x1A,W
1174:  MOVWF  x2B
1176:  MOVLW  00
1178:  SUBWFB x1B,W
117A:  MOVWF  x2C
117C:  MOVF   x18,W
117E:  ADDWF  x2B,W
1180:  MOVWF  FE9
1182:  MOVF   x19,W
1184:  ADDWFC x2C,W
1186:  MOVWF  FEA
1188:  MOVFF  FEF,92D
118C:  MOVLW  09
118E:  SUBWF  x1A,W
1190:  MOVWF  x2E
1192:  MOVLW  00
1194:  SUBWFB x1B,W
1196:  MOVWF  x2F
1198:  MOVF   x18,W
119A:  ADDWF  x2E,W
119C:  MOVWF  FE9
119E:  MOVF   x19,W
11A0:  ADDWFC x2F,W
11A2:  MOVWF  FEA
11A4:  MOVFF  FEF,930
11A8:  MOVLW  08
11AA:  SUBWF  x1A,W
11AC:  MOVWF  x31
11AE:  MOVLW  00
11B0:  SUBWFB x1B,W
11B2:  MOVWF  x32
11B4:  MOVF   x18,W
11B6:  ADDWF  x31,W
11B8:  MOVWF  FE9
11BA:  MOVF   x19,W
11BC:  ADDWFC x32,W
11BE:  MOVWF  FEA
11C0:  MOVFF  FEF,933
11C4:  MOVLW  07
11C6:  SUBWF  x1A,W
11C8:  MOVWF  x34
11CA:  MOVLW  00
11CC:  SUBWFB x1B,W
11CE:  MOVWF  x35
11D0:  MOVF   x18,W
11D2:  ADDWF  x34,W
11D4:  MOVWF  FE9
11D6:  MOVF   x19,W
11D8:  ADDWFC x35,W
11DA:  MOVWF  FEA
11DC:  MOVFF  FEF,936
11E0:  CLRF   x37
11E2:  MOVFF  924,938
11E6:  MOVFF  927,939
11EA:  MOVFF  92A,93A
11EE:  MOVFF  92D,93B
11F2:  MOVFF  930,93C
11F6:  MOVFF  933,93D
11FA:  MOVFF  936,93E
11FE:  MOVLB  0
1200:  CALL   06C8
1204:  MOVFF  01,91F
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
1208:  MOVLB  9
120A:  MOVF   x1E,W
120C:  SUBLW  45
120E:  BTFSS  FD8.2
1210:  BRA    138A
1212:  MOVF   x1F,W
1214:  SUBLW  7C
1216:  BTFSC  FD8.2
1218:  BRA    138A
121A:  MOVF   x1F,W
121C:  SUBLW  3E
121E:  BTFSC  FD8.2
1220:  BRA    138A
1222:  MOVF   x1F,W
1224:  SUBLW  1F
1226:  BTFSC  FD8.2
1228:  BRA    138A
122A:  MOVF   x1F,W
122C:  SUBLW  0F
122E:  BTFSC  FD8.2
1230:  BRA    138A
1232:  MOVF   x1F,W
1234:  SUBLW  78
1236:  BTFSC  FD8.2
1238:  BRA    138A
....................          { 
....................             j=i; 
123A:  MOVFF  91B,91D
123E:  MOVFF  91A,91C
....................             CRC=1; 
1242:  MOVLW  01
1244:  MOVWF  x21
....................             temp2=temp; 
1246:  MOVFF  91E,920
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
124A:  MOVF   x20,W
124C:  SUBLW  1F
124E:  BTFSC  FD8.2
1250:  BRA    136A
1252:  MOVF   x1D,F
1254:  BNZ   125E
1256:  MOVF   x1C,W
1258:  SUBLW  01
125A:  BTFSC  FD8.0
125C:  BRA    136A
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
125E:  MOVLW  01
1260:  MOVWF  x22
1262:  MOVFF  91D,924
1266:  MOVFF  91C,923
126A:  MOVFF  919,926
126E:  MOVFF  918,925
1272:  MOVLB  0
1274:  CALL   072E
1278:  MOVF   01,W
127A:  MOVLB  9
127C:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
127E:  MOVLW  06
1280:  SUBWF  x1C,W
1282:  MOVWF  x22
1284:  MOVLW  00
1286:  SUBWFB x1D,W
1288:  MOVWF  x23
128A:  MOVF   x18,W
128C:  ADDWF  x22,W
128E:  MOVWF  FE9
1290:  MOVF   x19,W
1292:  ADDWFC x23,W
1294:  MOVWF  FEA
1296:  MOVFF  FEF,924
129A:  MOVLW  05
129C:  SUBWF  x1C,W
129E:  MOVWF  x25
12A0:  MOVLW  00
12A2:  SUBWFB x1D,W
12A4:  MOVWF  x26
12A6:  MOVF   x18,W
12A8:  ADDWF  x25,W
12AA:  MOVWF  FE9
12AC:  MOVF   x19,W
12AE:  ADDWFC x26,W
12B0:  MOVWF  FEA
12B2:  MOVFF  FEF,927
12B6:  MOVLW  04
12B8:  SUBWF  x1C,W
12BA:  MOVWF  x28
12BC:  MOVLW  00
12BE:  SUBWFB x1D,W
12C0:  MOVWF  x29
12C2:  MOVF   x18,W
12C4:  ADDWF  x28,W
12C6:  MOVWF  FE9
12C8:  MOVF   x19,W
12CA:  ADDWFC x29,W
12CC:  MOVWF  FEA
12CE:  MOVFF  FEF,92A
12D2:  MOVLW  03
12D4:  SUBWF  x1C,W
12D6:  MOVWF  x2B
12D8:  MOVLW  00
12DA:  SUBWFB x1D,W
12DC:  MOVWF  x2C
12DE:  MOVF   x18,W
12E0:  ADDWF  x2B,W
12E2:  MOVWF  FE9
12E4:  MOVF   x19,W
12E6:  ADDWFC x2C,W
12E8:  MOVWF  FEA
12EA:  MOVFF  FEF,92D
12EE:  MOVLW  02
12F0:  SUBWF  x1C,W
12F2:  MOVWF  x2E
12F4:  MOVLW  00
12F6:  SUBWFB x1D,W
12F8:  MOVWF  x2F
12FA:  MOVF   x18,W
12FC:  ADDWF  x2E,W
12FE:  MOVWF  FE9
1300:  MOVF   x19,W
1302:  ADDWFC x2F,W
1304:  MOVWF  FEA
1306:  MOVFF  FEF,930
130A:  MOVLW  01
130C:  SUBWF  x1C,W
130E:  MOVWF  x31
1310:  MOVLW  00
1312:  SUBWFB x1D,W
1314:  MOVWF  x32
1316:  MOVF   x18,W
1318:  ADDWF  x31,W
131A:  MOVWF  FE9
131C:  MOVF   x19,W
131E:  ADDWFC x32,W
1320:  MOVWF  FEA
1322:  MOVFF  FEF,933
1326:  MOVF   x18,W
1328:  ADDWF  x1C,W
132A:  MOVWF  FE9
132C:  MOVF   x19,W
132E:  ADDWFC x1D,W
1330:  MOVWF  FEA
1332:  MOVFF  FEF,934
1336:  CLRF   x37
1338:  MOVFF  924,938
133C:  MOVFF  927,939
1340:  MOVFF  92A,93A
1344:  MOVFF  92D,93B
1348:  MOVFF  930,93C
134C:  MOVFF  933,93D
1350:  MOVFF  934,93E
1354:  MOVLB  0
1356:  CALL   06C8
135A:  MOVFF  01,920
....................                j=j-7;             
135E:  MOVLW  07
1360:  MOVLB  9
1362:  SUBWF  x1C,F
1364:  MOVLW  00
1366:  SUBWFB x1D,F
....................              } 
1368:  BRA    124A
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
136A:  DECFSZ x21,W
136C:  BRA    1382
....................             { 
....................                dir=1; 
136E:  MOVLW  01
1370:  MOVLB  6
1372:  MOVWF  xC8
....................                return i; 
1374:  MOVLB  9
1376:  MOVFF  91A,01
137A:  MOVFF  91B,02
137E:  BRA    161C
....................             } 
....................             else return 0; 
1380:  BRA    138A
1382:  MOVLW  00
1384:  MOVWF  01
1386:  MOVWF  02
1388:  BRA    161C
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
138A:  BRA    160C
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
138C:  MOVLW  04
138E:  SUBWF  x1A,W
1390:  MOVWF  x22
1392:  MOVLW  00
1394:  SUBWFB x1B,W
1396:  MOVWF  x23
1398:  MOVF   x18,W
139A:  ADDWF  x22,W
139C:  MOVWF  FE9
139E:  MOVF   x19,W
13A0:  ADDWFC x23,W
13A2:  MOVWF  FEA
13A4:  MOVFF  FEF,924
13A8:  MOVLW  03
13AA:  SUBWF  x1A,W
13AC:  MOVWF  x25
13AE:  MOVLW  00
13B0:  SUBWFB x1B,W
13B2:  MOVWF  x26
13B4:  MOVF   x18,W
13B6:  ADDWF  x25,W
13B8:  MOVWF  FE9
13BA:  MOVF   x19,W
13BC:  ADDWFC x26,W
13BE:  MOVWF  FEA
13C0:  MOVFF  FEF,927
13C4:  MOVLW  02
13C6:  SUBWF  x1A,W
13C8:  MOVWF  x28
13CA:  MOVLW  00
13CC:  SUBWFB x1B,W
13CE:  MOVWF  x29
13D0:  MOVF   x18,W
13D2:  ADDWF  x28,W
13D4:  MOVWF  FE9
13D6:  MOVF   x19,W
13D8:  ADDWFC x29,W
13DA:  MOVWF  FEA
13DC:  MOVFF  FEF,92A
13E0:  MOVLW  01
13E2:  SUBWF  x1A,W
13E4:  MOVWF  x2B
13E6:  MOVLW  00
13E8:  SUBWFB x1B,W
13EA:  MOVWF  x2C
13EC:  MOVF   x18,W
13EE:  ADDWF  x2B,W
13F0:  MOVWF  FE9
13F2:  MOVF   x19,W
13F4:  ADDWFC x2C,W
13F6:  MOVWF  FEA
13F8:  MOVFF  FEF,92D
13FC:  MOVF   x18,W
13FE:  ADDWF  x1A,W
1400:  MOVWF  FE9
1402:  MOVF   x19,W
1404:  ADDWFC x1B,W
1406:  MOVWF  FEA
1408:  MOVFF  FEF,92E
140C:  CLRF   x37
140E:  CLRF   x38
1410:  CLRF   x39
1412:  MOVFF  924,93A
1416:  MOVFF  927,93B
141A:  MOVFF  92A,93C
141E:  MOVFF  92D,93D
1422:  MOVFF  92E,93E
1426:  MOVLB  0
1428:  CALL   06C8
142C:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1430:  MOVLW  09
1432:  MOVLB  9
1434:  SUBWF  x1A,W
1436:  MOVWF  x22
1438:  MOVLW  00
143A:  SUBWFB x1B,W
143C:  MOVWF  x23
143E:  MOVF   x18,W
1440:  ADDWF  x22,W
1442:  MOVWF  FE9
1444:  MOVF   x19,W
1446:  ADDWFC x23,W
1448:  MOVWF  FEA
144A:  MOVFF  FEF,924
144E:  MOVLW  08
1450:  SUBWF  x1A,W
1452:  MOVWF  x25
1454:  MOVLW  00
1456:  SUBWFB x1B,W
1458:  MOVWF  x26
145A:  MOVF   x18,W
145C:  ADDWF  x25,W
145E:  MOVWF  FE9
1460:  MOVF   x19,W
1462:  ADDWFC x26,W
1464:  MOVWF  FEA
1466:  MOVFF  FEF,927
146A:  MOVLW  07
146C:  SUBWF  x1A,W
146E:  MOVWF  x28
1470:  MOVLW  00
1472:  SUBWFB x1B,W
1474:  MOVWF  x29
1476:  MOVF   x18,W
1478:  ADDWF  x28,W
147A:  MOVWF  FE9
147C:  MOVF   x19,W
147E:  ADDWFC x29,W
1480:  MOVWF  FEA
1482:  MOVFF  FEF,92A
1486:  MOVLW  06
1488:  SUBWF  x1A,W
148A:  MOVWF  x2B
148C:  MOVLW  00
148E:  SUBWFB x1B,W
1490:  MOVWF  x2C
1492:  MOVF   x18,W
1494:  ADDWF  x2B,W
1496:  MOVWF  FE9
1498:  MOVF   x19,W
149A:  ADDWFC x2C,W
149C:  MOVWF  FEA
149E:  MOVFF  FEF,92D
14A2:  MOVLW  05
14A4:  SUBWF  x1A,W
14A6:  MOVWF  x2E
14A8:  MOVLW  00
14AA:  SUBWFB x1B,W
14AC:  MOVWF  x2F
14AE:  MOVF   x18,W
14B0:  ADDWF  x2E,W
14B2:  MOVWF  FE9
14B4:  MOVF   x19,W
14B6:  ADDWFC x2F,W
14B8:  MOVWF  FEA
14BA:  MOVFF  FEF,930
14BE:  CLRF   x37
14C0:  CLRF   x38
14C2:  CLRF   x39
14C4:  MOVFF  924,93A
14C8:  MOVFF  927,93B
14CC:  MOVFF  92A,93C
14D0:  MOVFF  92D,93D
14D4:  MOVFF  930,93E
14D8:  MOVLB  0
14DA:  CALL   06C8
14DE:  MOVFF  01,91F
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
14E2:  MOVLB  9
14E4:  MOVF   x1E,W
14E6:  SUBLW  0B
14E8:  BTFSS  FD8.2
14EA:  BRA    160C
14EC:  MOVF   x1F,W
14EE:  SUBLW  1F
14F0:  BTFSC  FD8.2
14F2:  BRA    160C
14F4:  MOVF   x1F,W
14F6:  SUBLW  0F
14F8:  BTFSC  FD8.2
14FA:  BRA    160C
....................             { 
....................                j=i; 
14FC:  MOVFF  91B,91D
1500:  MOVFF  91A,91C
....................                CRC=1; 
1504:  MOVLW  01
1506:  MOVWF  x21
....................                temp2=temp; 
1508:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
150C:  MOVF   x20,W
150E:  SUBLW  1F
1510:  BZ    15EC
1512:  MOVF   x1D,F
1514:  BNZ   151C
1516:  MOVF   x1C,W
1518:  SUBLW  01
151A:  BC    15EC
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
151C:  MOVLW  01
151E:  MOVWF  x22
1520:  MOVFF  91D,924
1524:  MOVFF  91C,923
1528:  MOVFF  919,926
152C:  MOVFF  918,925
1530:  MOVLB  0
1532:  CALL   08DE
1536:  MOVF   01,W
1538:  MOVLB  9
153A:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
153C:  MOVLW  04
153E:  SUBWF  x1C,W
1540:  MOVWF  x22
1542:  MOVLW  00
1544:  SUBWFB x1D,W
1546:  MOVWF  x23
1548:  MOVF   x18,W
154A:  ADDWF  x22,W
154C:  MOVWF  FE9
154E:  MOVF   x19,W
1550:  ADDWFC x23,W
1552:  MOVWF  FEA
1554:  MOVFF  FEF,924
1558:  MOVLW  03
155A:  SUBWF  x1C,W
155C:  MOVWF  x25
155E:  MOVLW  00
1560:  SUBWFB x1D,W
1562:  MOVWF  x26
1564:  MOVF   x18,W
1566:  ADDWF  x25,W
1568:  MOVWF  FE9
156A:  MOVF   x19,W
156C:  ADDWFC x26,W
156E:  MOVWF  FEA
1570:  MOVFF  FEF,927
1574:  MOVLW  02
1576:  SUBWF  x1C,W
1578:  MOVWF  x28
157A:  MOVLW  00
157C:  SUBWFB x1D,W
157E:  MOVWF  x29
1580:  MOVF   x18,W
1582:  ADDWF  x28,W
1584:  MOVWF  FE9
1586:  MOVF   x19,W
1588:  ADDWFC x29,W
158A:  MOVWF  FEA
158C:  MOVFF  FEF,92A
1590:  MOVLW  01
1592:  SUBWF  x1C,W
1594:  MOVWF  x2B
1596:  MOVLW  00
1598:  SUBWFB x1D,W
159A:  MOVWF  x2C
159C:  MOVF   x18,W
159E:  ADDWF  x2B,W
15A0:  MOVWF  FE9
15A2:  MOVF   x19,W
15A4:  ADDWFC x2C,W
15A6:  MOVWF  FEA
15A8:  MOVFF  FEF,92D
15AC:  MOVF   x18,W
15AE:  ADDWF  x1C,W
15B0:  MOVWF  FE9
15B2:  MOVF   x19,W
15B4:  ADDWFC x1D,W
15B6:  MOVWF  FEA
15B8:  MOVFF  FEF,92E
15BC:  CLRF   x37
15BE:  CLRF   x38
15C0:  CLRF   x39
15C2:  MOVFF  924,93A
15C6:  MOVFF  927,93B
15CA:  MOVFF  92A,93C
15CE:  MOVFF  92D,93D
15D2:  MOVFF  92E,93E
15D6:  MOVLB  0
15D8:  CALL   06C8
15DC:  MOVFF  01,920
....................                   j=j-5; 
15E0:  MOVLW  05
15E2:  MOVLB  9
15E4:  SUBWF  x1C,F
15E6:  MOVLW  00
15E8:  SUBWFB x1D,F
....................                } 
15EA:  BRA    150C
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
15EC:  DECFSZ x21,W
15EE:  BRA    1604
....................                { 
....................                   dir=1; 
15F0:  MOVLW  01
15F2:  MOVLB  6
15F4:  MOVWF  xC8
....................                   return i; 
15F6:  MOVLB  9
15F8:  MOVFF  91A,01
15FC:  MOVFF  91B,02
1600:  BRA    161C
....................                } 
....................                   else return 0; 
1602:  BRA    160C
1604:  MOVLW  00
1606:  MOVWF  01
1608:  MOVWF  02
160A:  BRA    161C
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
160C:  MOVF   x1A,W
160E:  BTFSC  FD8.2
1610:  DECF   x1B,F
1612:  DECF   x1A,F
1614:  BRA    100E
....................    return 0; 
1616:  MOVLW  00
1618:  MOVWF  01
161A:  MOVWF  02
.................... } 
161C:  MOVLB  0
161E:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
35C8:  MOVLB  9
35CA:  CLRF   x02
35CC:  MOVLW  01
35CE:  MOVWF  x01
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
35D0:  MOVFF  8F7,915
35D4:  MOVFF  8F9,917
35D8:  MOVFF  8F8,916
35DC:  MOVFF  8FB,919
35E0:  MOVFF  8FA,918
35E4:  MOVLB  0
35E6:  CALL   0A1E
35EA:  MOVFF  02,902
35EE:  MOVFF  01,901
....................    if(temp==0) return 0; 
35F2:  MOVLB  9
35F4:  MOVF   x01,F
35F6:  BNZ   3602
35F8:  MOVF   x02,F
35FA:  BNZ   3602
35FC:  MOVLW  00
35FE:  MOVWF  01
3600:  BRA    3A7C
....................    j=temp; 
3602:  MOVFF  902,900
3606:  MOVFF  901,8FF
....................    if(dir==0) 
360A:  MOVLB  6
360C:  MOVF   xC8,F
360E:  BTFSS  FD8.2
3610:  BRA    383E
....................    { 
....................       if(track==0) 
3612:  MOVLB  8
3614:  MOVF   xF7,F
3616:  BTFSS  FD8.2
3618:  BRA    3756
....................       { 
....................             for(i=0;i<79;i++) 
361A:  CLRF   xFE
361C:  MOVF   xFE,W
361E:  SUBLW  4E
3620:  BTFSS  FD8.0
3622:  BRA    3754
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3624:  CLRF   03
3626:  MOVF   xFE,W
3628:  ADDWF  xFC,W
362A:  MOVWF  01
362C:  MOVF   xFD,W
362E:  ADDWFC 03,F
3630:  MOVFF  01,903
3634:  MOVFF  03,904
3638:  MOVLW  05
363A:  MOVLB  8
363C:  ADDWF  xFF,W
363E:  MOVLB  9
3640:  MOVWF  x05
3642:  MOVLW  00
3644:  ADDWFC x00,W
3646:  MOVWF  x06
3648:  MOVLB  8
364A:  MOVF   xFA,W
364C:  MOVLB  9
364E:  ADDWF  x05,W
3650:  MOVWF  FE9
3652:  MOVLB  8
3654:  MOVF   xFB,W
3656:  MOVLB  9
3658:  ADDWFC x06,W
365A:  MOVWF  FEA
365C:  MOVFF  FEF,907
3660:  MOVLW  04
3662:  MOVLB  8
3664:  ADDWF  xFF,W
3666:  MOVLB  9
3668:  MOVWF  x08
366A:  MOVLW  00
366C:  ADDWFC x00,W
366E:  MOVWF  x09
3670:  MOVLB  8
3672:  MOVF   xFA,W
3674:  MOVLB  9
3676:  ADDWF  x08,W
3678:  MOVWF  FE9
367A:  MOVLB  8
367C:  MOVF   xFB,W
367E:  MOVLB  9
3680:  ADDWFC x09,W
3682:  MOVWF  FEA
3684:  MOVFF  FEF,90A
3688:  MOVLW  03
368A:  MOVLB  8
368C:  ADDWF  xFF,W
368E:  MOVLB  9
3690:  MOVWF  x0B
3692:  MOVLW  00
3694:  ADDWFC x00,W
3696:  MOVWF  x0C
3698:  MOVLB  8
369A:  MOVF   xFA,W
369C:  MOVLB  9
369E:  ADDWF  x0B,W
36A0:  MOVWF  FE9
36A2:  MOVLB  8
36A4:  MOVF   xFB,W
36A6:  MOVLB  9
36A8:  ADDWFC x0C,W
36AA:  MOVWF  FEA
36AC:  MOVFF  FEF,90D
36B0:  MOVLW  02
36B2:  MOVLB  8
36B4:  ADDWF  xFF,W
36B6:  MOVLB  9
36B8:  MOVWF  x0E
36BA:  MOVLW  00
36BC:  ADDWFC x00,W
36BE:  MOVWF  x0F
36C0:  MOVLB  8
36C2:  MOVF   xFA,W
36C4:  MOVLB  9
36C6:  ADDWF  x0E,W
36C8:  MOVWF  FE9
36CA:  MOVLB  8
36CC:  MOVF   xFB,W
36CE:  MOVLB  9
36D0:  ADDWFC x0F,W
36D2:  MOVWF  FEA
36D4:  MOVFF  FEF,910
36D8:  MOVLW  01
36DA:  MOVLB  8
36DC:  ADDWF  xFF,W
36DE:  MOVLB  9
36E0:  MOVWF  x11
36E2:  MOVLW  00
36E4:  ADDWFC x00,W
36E6:  MOVWF  x12
36E8:  MOVLB  8
36EA:  MOVF   xFA,W
36EC:  MOVLB  9
36EE:  ADDWF  x11,W
36F0:  MOVWF  FE9
36F2:  MOVLB  8
36F4:  MOVF   xFB,W
36F6:  MOVLB  9
36F8:  ADDWFC x12,W
36FA:  MOVWF  FEA
36FC:  MOVFF  FEF,913
3700:  MOVLB  8
3702:  MOVF   xFA,W
3704:  ADDWF  xFF,W
3706:  MOVWF  FE9
3708:  MOVF   xFB,W
370A:  MOVLB  9
370C:  ADDWFC x00,W
370E:  MOVWF  FEA
3710:  MOVFF  FEF,914
3714:  CLRF   x37
3716:  CLRF   x38
3718:  MOVFF  907,939
371C:  MOVFF  90A,93A
3720:  MOVFF  90D,93B
3724:  MOVFF  910,93C
3728:  MOVFF  913,93D
372C:  MOVFF  914,93E
3730:  MOVLB  0
3732:  CALL   06C8
3736:  MOVFF  904,FEA
373A:  MOVFF  903,FE9
373E:  MOVFF  01,FEF
....................                j=j+7; 
3742:  MOVLW  07
3744:  MOVLB  8
3746:  ADDWF  xFF,F
3748:  MOVLW  00
374A:  MOVLB  9
374C:  ADDWFC x00,F
....................             } 
374E:  MOVLB  8
3750:  INCF   xFE,F
3752:  BRA    361C
....................       } 
....................          else  
3754:  BRA    383A
....................          { 
....................             for(i=0;i<40;i++) 
3756:  CLRF   xFE
3758:  MOVF   xFE,W
375A:  SUBLW  27
375C:  BNC   383A
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
375E:  CLRF   03
3760:  MOVF   xFE,W
3762:  ADDWF  xFC,W
3764:  MOVWF  01
3766:  MOVF   xFD,W
3768:  ADDWFC 03,F
376A:  MOVFF  01,903
376E:  MOVFF  03,904
3772:  MOVLW  03
3774:  MOVLB  8
3776:  ADDWF  xFF,W
3778:  MOVLB  9
377A:  MOVWF  x05
377C:  MOVLW  00
377E:  ADDWFC x00,W
3780:  MOVWF  x06
3782:  MOVLB  8
3784:  MOVF   xFA,W
3786:  MOVLB  9
3788:  ADDWF  x05,W
378A:  MOVWF  FE9
378C:  MOVLB  8
378E:  MOVF   xFB,W
3790:  MOVLB  9
3792:  ADDWFC x06,W
3794:  MOVWF  FEA
3796:  MOVFF  FEF,907
379A:  MOVLW  02
379C:  MOVLB  8
379E:  ADDWF  xFF,W
37A0:  MOVLB  9
37A2:  MOVWF  x08
37A4:  MOVLW  00
37A6:  ADDWFC x00,W
37A8:  MOVWF  x09
37AA:  MOVLB  8
37AC:  MOVF   xFA,W
37AE:  MOVLB  9
37B0:  ADDWF  x08,W
37B2:  MOVWF  FE9
37B4:  MOVLB  8
37B6:  MOVF   xFB,W
37B8:  MOVLB  9
37BA:  ADDWFC x09,W
37BC:  MOVWF  FEA
37BE:  MOVFF  FEF,90A
37C2:  MOVLW  01
37C4:  MOVLB  8
37C6:  ADDWF  xFF,W
37C8:  MOVLB  9
37CA:  MOVWF  x0B
37CC:  MOVLW  00
37CE:  ADDWFC x00,W
37D0:  MOVWF  x0C
37D2:  MOVLB  8
37D4:  MOVF   xFA,W
37D6:  MOVLB  9
37D8:  ADDWF  x0B,W
37DA:  MOVWF  FE9
37DC:  MOVLB  8
37DE:  MOVF   xFB,W
37E0:  MOVLB  9
37E2:  ADDWFC x0C,W
37E4:  MOVWF  FEA
37E6:  MOVFF  FEF,90D
37EA:  MOVLB  8
37EC:  MOVF   xFA,W
37EE:  ADDWF  xFF,W
37F0:  MOVWF  FE9
37F2:  MOVF   xFB,W
37F4:  MOVLB  9
37F6:  ADDWFC x00,W
37F8:  MOVWF  FEA
37FA:  MOVFF  FEF,90E
37FE:  CLRF   x37
3800:  CLRF   x38
3802:  CLRF   x39
3804:  CLRF   x3A
3806:  MOVFF  907,93B
380A:  MOVFF  90A,93C
380E:  MOVFF  90D,93D
3812:  MOVFF  90E,93E
3816:  MOVLB  0
3818:  CALL   06C8
381C:  MOVFF  904,FEA
3820:  MOVFF  903,FE9
3824:  MOVFF  01,FEF
....................                j=j+5; 
3828:  MOVLW  05
382A:  MOVLB  8
382C:  ADDWF  xFF,F
382E:  MOVLW  00
3830:  MOVLB  9
3832:  ADDWFC x00,F
....................             }          
3834:  MOVLB  8
3836:  INCF   xFE,F
3838:  BRA    3758
....................          } 
....................    } 
....................       else  
383A:  BRA    3A66
383C:  MOVLB  6
....................       { 
....................          if(track==0) 
383E:  MOVLB  8
3840:  MOVF   xF7,F
3842:  BTFSS  FD8.2
3844:  BRA    3982
....................          { 
....................             for(i=0;i<79;i++) 
3846:  CLRF   xFE
3848:  MOVF   xFE,W
384A:  SUBLW  4E
384C:  BTFSS  FD8.0
384E:  BRA    3980
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3850:  CLRF   03
3852:  MOVF   xFE,W
3854:  ADDWF  xFC,W
3856:  MOVWF  01
3858:  MOVF   xFD,W
385A:  ADDWFC 03,F
385C:  MOVFF  01,903
3860:  MOVFF  03,904
3864:  MOVLW  05
3866:  MOVLB  8
3868:  SUBWF  xFF,W
386A:  MOVLB  9
386C:  MOVWF  x05
386E:  MOVLW  00
3870:  SUBWFB x00,W
3872:  MOVWF  x06
3874:  MOVLB  8
3876:  MOVF   xFA,W
3878:  MOVLB  9
387A:  ADDWF  x05,W
387C:  MOVWF  FE9
387E:  MOVLB  8
3880:  MOVF   xFB,W
3882:  MOVLB  9
3884:  ADDWFC x06,W
3886:  MOVWF  FEA
3888:  MOVFF  FEF,907
388C:  MOVLW  04
388E:  MOVLB  8
3890:  SUBWF  xFF,W
3892:  MOVLB  9
3894:  MOVWF  x08
3896:  MOVLW  00
3898:  SUBWFB x00,W
389A:  MOVWF  x09
389C:  MOVLB  8
389E:  MOVF   xFA,W
38A0:  MOVLB  9
38A2:  ADDWF  x08,W
38A4:  MOVWF  FE9
38A6:  MOVLB  8
38A8:  MOVF   xFB,W
38AA:  MOVLB  9
38AC:  ADDWFC x09,W
38AE:  MOVWF  FEA
38B0:  MOVFF  FEF,90A
38B4:  MOVLW  03
38B6:  MOVLB  8
38B8:  SUBWF  xFF,W
38BA:  MOVLB  9
38BC:  MOVWF  x0B
38BE:  MOVLW  00
38C0:  SUBWFB x00,W
38C2:  MOVWF  x0C
38C4:  MOVLB  8
38C6:  MOVF   xFA,W
38C8:  MOVLB  9
38CA:  ADDWF  x0B,W
38CC:  MOVWF  FE9
38CE:  MOVLB  8
38D0:  MOVF   xFB,W
38D2:  MOVLB  9
38D4:  ADDWFC x0C,W
38D6:  MOVWF  FEA
38D8:  MOVFF  FEF,90D
38DC:  MOVLW  02
38DE:  MOVLB  8
38E0:  SUBWF  xFF,W
38E2:  MOVLB  9
38E4:  MOVWF  x0E
38E6:  MOVLW  00
38E8:  SUBWFB x00,W
38EA:  MOVWF  x0F
38EC:  MOVLB  8
38EE:  MOVF   xFA,W
38F0:  MOVLB  9
38F2:  ADDWF  x0E,W
38F4:  MOVWF  FE9
38F6:  MOVLB  8
38F8:  MOVF   xFB,W
38FA:  MOVLB  9
38FC:  ADDWFC x0F,W
38FE:  MOVWF  FEA
3900:  MOVFF  FEF,910
3904:  MOVLW  01
3906:  MOVLB  8
3908:  SUBWF  xFF,W
390A:  MOVLB  9
390C:  MOVWF  x11
390E:  MOVLW  00
3910:  SUBWFB x00,W
3912:  MOVWF  x12
3914:  MOVLB  8
3916:  MOVF   xFA,W
3918:  MOVLB  9
391A:  ADDWF  x11,W
391C:  MOVWF  FE9
391E:  MOVLB  8
3920:  MOVF   xFB,W
3922:  MOVLB  9
3924:  ADDWFC x12,W
3926:  MOVWF  FEA
3928:  MOVFF  FEF,913
392C:  MOVLB  8
392E:  MOVF   xFA,W
3930:  ADDWF  xFF,W
3932:  MOVWF  FE9
3934:  MOVF   xFB,W
3936:  MOVLB  9
3938:  ADDWFC x00,W
393A:  MOVWF  FEA
393C:  MOVFF  FEF,914
3940:  CLRF   x37
3942:  CLRF   x38
3944:  MOVFF  907,939
3948:  MOVFF  90A,93A
394C:  MOVFF  90D,93B
3950:  MOVFF  910,93C
3954:  MOVFF  913,93D
3958:  MOVFF  914,93E
395C:  MOVLB  0
395E:  CALL   06C8
3962:  MOVFF  904,FEA
3966:  MOVFF  903,FE9
396A:  MOVFF  01,FEF
....................                j=j-7; 
396E:  MOVLW  07
3970:  MOVLB  8
3972:  SUBWF  xFF,F
3974:  MOVLW  00
3976:  MOVLB  9
3978:  SUBWFB x00,F
....................             } 
397A:  MOVLB  8
397C:  INCF   xFE,F
397E:  BRA    3848
....................          } 
....................             else 
3980:  BRA    3A66
....................             { 
....................                for(i=0;i<40;i++) 
3982:  CLRF   xFE
3984:  MOVF   xFE,W
3986:  SUBLW  27
3988:  BNC   3A66
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
398A:  CLRF   03
398C:  MOVF   xFE,W
398E:  ADDWF  xFC,W
3990:  MOVWF  01
3992:  MOVF   xFD,W
3994:  ADDWFC 03,F
3996:  MOVFF  01,903
399A:  MOVFF  03,904
399E:  MOVLW  03
39A0:  MOVLB  8
39A2:  SUBWF  xFF,W
39A4:  MOVLB  9
39A6:  MOVWF  x05
39A8:  MOVLW  00
39AA:  SUBWFB x00,W
39AC:  MOVWF  x06
39AE:  MOVLB  8
39B0:  MOVF   xFA,W
39B2:  MOVLB  9
39B4:  ADDWF  x05,W
39B6:  MOVWF  FE9
39B8:  MOVLB  8
39BA:  MOVF   xFB,W
39BC:  MOVLB  9
39BE:  ADDWFC x06,W
39C0:  MOVWF  FEA
39C2:  MOVFF  FEF,907
39C6:  MOVLW  02
39C8:  MOVLB  8
39CA:  SUBWF  xFF,W
39CC:  MOVLB  9
39CE:  MOVWF  x08
39D0:  MOVLW  00
39D2:  SUBWFB x00,W
39D4:  MOVWF  x09
39D6:  MOVLB  8
39D8:  MOVF   xFA,W
39DA:  MOVLB  9
39DC:  ADDWF  x08,W
39DE:  MOVWF  FE9
39E0:  MOVLB  8
39E2:  MOVF   xFB,W
39E4:  MOVLB  9
39E6:  ADDWFC x09,W
39E8:  MOVWF  FEA
39EA:  MOVFF  FEF,90A
39EE:  MOVLW  01
39F0:  MOVLB  8
39F2:  SUBWF  xFF,W
39F4:  MOVLB  9
39F6:  MOVWF  x0B
39F8:  MOVLW  00
39FA:  SUBWFB x00,W
39FC:  MOVWF  x0C
39FE:  MOVLB  8
3A00:  MOVF   xFA,W
3A02:  MOVLB  9
3A04:  ADDWF  x0B,W
3A06:  MOVWF  FE9
3A08:  MOVLB  8
3A0A:  MOVF   xFB,W
3A0C:  MOVLB  9
3A0E:  ADDWFC x0C,W
3A10:  MOVWF  FEA
3A12:  MOVFF  FEF,90D
3A16:  MOVLB  8
3A18:  MOVF   xFA,W
3A1A:  ADDWF  xFF,W
3A1C:  MOVWF  FE9
3A1E:  MOVF   xFB,W
3A20:  MOVLB  9
3A22:  ADDWFC x00,W
3A24:  MOVWF  FEA
3A26:  MOVFF  FEF,90E
3A2A:  CLRF   x37
3A2C:  CLRF   x38
3A2E:  CLRF   x39
3A30:  CLRF   x3A
3A32:  MOVFF  907,93B
3A36:  MOVFF  90A,93C
3A3A:  MOVFF  90D,93D
3A3E:  MOVFF  90E,93E
3A42:  MOVLB  0
3A44:  CALL   06C8
3A48:  MOVFF  904,FEA
3A4C:  MOVFF  903,FE9
3A50:  MOVFF  01,FEF
....................                   j=j-5; 
3A54:  MOVLW  05
3A56:  MOVLB  8
3A58:  SUBWF  xFF,F
3A5A:  MOVLW  00
3A5C:  MOVLB  9
3A5E:  SUBWFB x00,F
....................                }             
3A60:  MOVLB  8
3A62:  INCF   xFE,F
3A64:  BRA    3984
....................             } 
....................       } 
....................       memset(datin,0,sizeof(datin)); 
3A66:  MOVFF  8FB,FEA
3A6A:  MOVFF  8FA,FE9
3A6E:  CLRF   00
3A70:  CLRF   02
3A72:  MOVLW  02
3A74:  MOVWF  01
3A76:  MOVLB  0
3A78:  RCALL  35AE
3A7A:  MOVLB  9
.................... } 
3A7C:  MOVLB  0
3A7E:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1856:  MOVLW  8E
1858:  MOVWF  FF6
185A:  MOVLW  05
185C:  MOVWF  FF7
185E:  RCALL  174A
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1860:  MOVLB  8
1862:  CLRF   x57
1864:  CLRF   x56
1866:  MOVF   x57,W
1868:  SUBLW  03
186A:  BNC   189A
186C:  BNZ   1874
186E:  MOVF   x56,W
1870:  SUBLW  51
1872:  BNC   189A
1874:  MOVLW  46
1876:  ADDWF  x56,W
1878:  MOVWF  FE9
187A:  MOVLW  02
187C:  ADDWFC x57,W
187E:  MOVWF  FEA
1880:  MOVFF  FEF,858
1884:  MOVFF  858,859
1888:  MOVLW  18
188A:  MOVWF  x5A
188C:  MOVLB  0
188E:  RCALL  1796
1890:  MOVLB  8
1892:  INCF   x56,F
1894:  BTFSC  FD8.2
1896:  INCF   x57,F
1898:  BRA    1866
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
189A:  MOVLW  A4
189C:  MOVWF  FF6
189E:  MOVLW  05
18A0:  MOVWF  FF7
18A2:  MOVLB  0
18A4:  RCALL  174A
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
18A6:  MOVLB  8
18A8:  CLRF   x57
18AA:  CLRF   x56
18AC:  MOVF   x57,W
18AE:  SUBLW  01
18B0:  BNC   18E0
18B2:  BNZ   18BA
18B4:  MOVF   x56,W
18B6:  SUBLW  2B
18B8:  BNC   18E0
18BA:  MOVLW  98
18BC:  ADDWF  x56,W
18BE:  MOVWF  FE9
18C0:  MOVLW  05
18C2:  ADDWFC x57,W
18C4:  MOVWF  FEA
18C6:  MOVFF  FEF,858
18CA:  MOVFF  858,859
18CE:  MOVLW  18
18D0:  MOVWF  x5A
18D2:  MOVLB  0
18D4:  RCALL  1796
18D6:  MOVLB  8
18D8:  INCF   x56,F
18DA:  BTFSC  FD8.2
18DC:  INCF   x57,F
18DE:  BRA    18AC
.................... } 
18E0:  MOVLB  0
18E2:  GOTO   1B70 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3C0C:  MOVLW  01
3C0E:  MOVLB  6
3C10:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3C12:  MOVLB  0
3C14:  RCALL  3534
3C16:  MOVFF  02,854
3C1A:  MOVFF  01,853
3C1E:  MOVFF  02,856
3C22:  MOVFF  01,855
3C26:  MOVLB  8
3C28:  CLRF   x58
3C2A:  MOVLW  7C
3C2C:  MOVWF  x57
3C2E:  MOVLB  0
3C30:  RCALL  358C
3C32:  MOVFF  01,853
3C36:  MOVLW  96
3C38:  MOVLB  8
3C3A:  ADDWF  01,W
3C3C:  MOVWF  01
3C3E:  MOVLW  00
3C40:  ADDWFC 02,W
3C42:  MOVFF  01,20
3C46:  MOVWF  21
3C48:  CLRF   22
3C4A:  CLRF   23
....................    if(datinbuf==0)  
3C4C:  MOVLB  6
3C4E:  MOVF   xD5,F
3C50:  BNZ   3C74
....................    { 
....................       countbit_T1=0; 
3C52:  CLRF   xCA
3C54:  CLRF   xC9
....................       countbit_T2=0; 
3C56:  CLRF   xCC
3C58:  CLRF   xCB
....................       bug_countbit_T1=0; 
3C5A:  CLRF   xCE
3C5C:  CLRF   xCD
....................       bug_countbit_T2=0; 
3C5E:  CLRF   xD0
3C60:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3C62:  MOVF   xD9,F
3C64:  BNZ   3C70
3C66:  MOVLB  1
3C68:  SETF   x00
3C6A:  MOVLB  0
3C6C:  SETF   xFF
3C6E:  MOVLB  6
....................       saving_flag=0; 
3C70:  CLRF   xD8
....................       return; 
3C72:  BRA    3FFA
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3C74:  MOVLW  BA
3C76:  MOVWF  FF6
3C78:  MOVLW  05
3C7A:  MOVWF  FF7
3C7C:  MOVLB  0
3C7E:  CALL   174A
....................    //key_count=0; 
....................    enable_getpin=1; 
3C82:  MOVLW  01
3C84:  MOVLB  1
3C86:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3C88:  MOVFF  6CA,852
3C8C:  MOVFF  6C9,851
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3C90:  MOVLB  8
3C92:  CLRF   xF7
3C94:  MOVFF  852,8F9
3C98:  MOVFF  851,8F8
3C9C:  MOVLW  02
3C9E:  MOVWF  xFB
3CA0:  MOVLW  46
3CA2:  MOVWF  xFA
3CA4:  MOVLW  01
3CA6:  MOVWF  xFD
3CA8:  MOVLW  CF
3CAA:  MOVWF  xFC
3CAC:  MOVLB  0
3CAE:  RCALL  35C8
....................    countbit_T1=0; 
3CB0:  MOVLB  6
3CB2:  CLRF   xCA
3CB4:  CLRF   xC9
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3CB6:  MOVFF  6CC,852
3CBA:  MOVFF  6CB,851
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3CBE:  MOVLW  01
3CC0:  MOVLB  8
3CC2:  MOVWF  xF7
3CC4:  MOVFF  852,8F9
3CC8:  MOVFF  851,8F8
3CCC:  MOVLW  05
3CCE:  MOVWF  xFB
3CD0:  MOVLW  98
3CD2:  MOVWF  xFA
3CD4:  MOVLW  02
3CD6:  MOVWF  xFD
3CD8:  MOVLW  1E
3CDA:  MOVWF  xFC
3CDC:  MOVLB  0
3CDE:  RCALL  35C8
....................    countbit_T2=0; 
3CE0:  MOVLB  6
3CE2:  CLRF   xCC
3CE4:  CLRF   xCB
....................    saving_flag=0; 
3CE6:  CLRF   xD8
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3CE8:  MOVLW  20
3CEA:  MOVLB  1
3CEC:  ADDWF  xCF,W
3CEE:  MOVLB  8
3CF0:  MOVWF  x50
....................    if((ptr_card<EEPROM_SIZE_stofkey)&&(temp=='%')) 
3CF2:  MOVF   23,F
3CF4:  BTFSS  FD8.2
3CF6:  BRA    3FF8
3CF8:  MOVF   22,F
3CFA:  BTFSS  FD8.2
3CFC:  BRA    3FF8
3CFE:  MOVF   21,W
3D00:  SUBLW  E0
3D02:  BTFSS  FD8.0
3D04:  BRA    3FF8
3D06:  MOVF   x50,W
3D08:  SUBLW  25
3D0A:  BTFSS  FD8.2
3D0C:  BRA    3FF8
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3D0E:  MOVFF  23,03
3D12:  MOVFF  22,02
3D16:  MOVFF  21,01
3D1A:  MOVFF  20,00
3D1E:  MOVLW  01
3D20:  ADDWF  20,F
3D22:  BTFSC  FD8.0
3D24:  INCF   21,F
3D26:  BTFSC  FD8.2
3D28:  INCF   22,F
3D2A:  BTFSC  FD8.2
3D2C:  INCF   23,F
3D2E:  MOVFF  01,854
3D32:  MOVFF  00,853
3D36:  MOVLB  9
3D38:  CLRF   x16
3D3A:  CLRF   x15
3D3C:  MOVFF  01,914
3D40:  MOVFF  00,913
3D44:  MOVFF  1CB,917
3D48:  MOVLB  0
3D4A:  RCALL  3A80
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3D4C:  MOVFF  23,03
3D50:  MOVFF  22,02
3D54:  MOVFF  21,01
3D58:  MOVFF  20,00
3D5C:  MOVLW  01
3D5E:  ADDWF  20,F
3D60:  BTFSC  FD8.0
3D62:  INCF   21,F
3D64:  BTFSC  FD8.2
3D66:  INCF   22,F
3D68:  BTFSC  FD8.2
3D6A:  INCF   23,F
3D6C:  MOVFF  01,854
3D70:  MOVFF  00,853
3D74:  MOVLB  9
3D76:  CLRF   x16
3D78:  CLRF   x15
3D7A:  MOVFF  01,914
3D7E:  MOVFF  00,913
3D82:  MOVFF  1CA,917
3D86:  MOVLB  0
3D88:  RCALL  3A80
....................          write_ext_eeprom((long int)ptr_card++,h); 
3D8A:  MOVFF  23,03
3D8E:  MOVFF  22,02
3D92:  MOVFF  21,01
3D96:  MOVFF  20,00
3D9A:  MOVLW  01
3D9C:  ADDWF  20,F
3D9E:  BTFSC  FD8.0
3DA0:  INCF   21,F
3DA2:  BTFSC  FD8.2
3DA4:  INCF   22,F
3DA6:  BTFSC  FD8.2
3DA8:  INCF   23,F
3DAA:  MOVFF  01,854
3DAE:  MOVFF  00,853
3DB2:  MOVLB  9
3DB4:  CLRF   x16
3DB6:  CLRF   x15
3DB8:  MOVFF  01,914
3DBC:  MOVFF  00,913
3DC0:  MOVFF  1CC,917
3DC4:  MOVLB  0
3DC6:  RCALL  3A80
....................          write_ext_eeprom((long int)ptr_card++,min); 
3DC8:  MOVFF  23,03
3DCC:  MOVFF  22,02
3DD0:  MOVFF  21,01
3DD4:  MOVFF  20,00
3DD8:  MOVLW  01
3DDA:  ADDWF  20,F
3DDC:  BTFSC  FD8.0
3DDE:  INCF   21,F
3DE0:  BTFSC  FD8.2
3DE2:  INCF   22,F
3DE4:  BTFSC  FD8.2
3DE6:  INCF   23,F
3DE8:  MOVFF  01,854
3DEC:  MOVFF  00,853
3DF0:  MOVLB  9
3DF2:  CLRF   x16
3DF4:  CLRF   x15
3DF6:  MOVFF  01,914
3DFA:  MOVFF  00,913
3DFE:  MOVFF  1CD,917
3E02:  MOVLB  0
3E04:  RCALL  3A80
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3E06:  MOVFF  23,03
3E0A:  MOVFF  22,02
3E0E:  MOVFF  21,01
3E12:  MOVFF  20,00
3E16:  MOVLW  01
3E18:  ADDWF  20,F
3E1A:  BTFSC  FD8.0
3E1C:  INCF   21,F
3E1E:  BTFSC  FD8.2
3E20:  INCF   22,F
3E22:  BTFSC  FD8.2
3E24:  INCF   23,F
3E26:  MOVFF  01,854
3E2A:  MOVFF  00,853
3E2E:  MOVLB  9
3E30:  CLRF   x16
3E32:  CLRF   x15
3E34:  MOVFF  01,914
3E38:  MOVFF  00,913
3E3C:  MOVFF  1CE,917
3E40:  MOVLB  0
3E42:  RCALL  3A80
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3E44:  MOVLB  6
3E46:  CLRF   xD4
3E48:  CLRF   xD3
3E4A:  MOVF   xD4,F
3E4C:  BNZ   3EB0
3E4E:  MOVF   xD3,W
3E50:  SUBLW  4E
3E52:  BNC   3EB0
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3E54:  MOVFF  23,03
3E58:  MOVFF  22,02
3E5C:  MOVFF  21,01
3E60:  MOVFF  20,00
3E64:  MOVLW  01
3E66:  ADDWF  20,F
3E68:  BTFSC  FD8.0
3E6A:  INCF   21,F
3E6C:  BTFSC  FD8.2
3E6E:  INCF   22,F
3E70:  BTFSC  FD8.2
3E72:  INCF   23,F
3E74:  MOVFF  01,854
3E78:  MOVFF  00,853
3E7C:  MOVLW  CF
3E7E:  ADDWF  xD3,W
3E80:  MOVWF  FE9
3E82:  MOVLW  01
3E84:  ADDWFC xD4,W
3E86:  MOVWF  FEA
3E88:  MOVF   FEF,W
3E8A:  ANDLW  3F
3E8C:  ADDLW  20
3E8E:  MOVLB  8
3E90:  MOVWF  x55
3E92:  MOVLB  9
3E94:  CLRF   x16
3E96:  CLRF   x15
3E98:  MOVFF  01,914
3E9C:  MOVFF  00,913
3EA0:  MOVWF  x17
3EA2:  MOVLB  0
3EA4:  RCALL  3A80
....................              
....................          } 
3EA6:  MOVLB  6
3EA8:  INCF   xD3,F
3EAA:  BTFSC  FD8.2
3EAC:  INCF   xD4,F
3EAE:  BRA    3E4A
....................          memset(Track1,0,sizeof(Track1)); 
3EB0:  MOVLW  01
3EB2:  MOVWF  FEA
3EB4:  MOVLW  CF
3EB6:  MOVWF  FE9
3EB8:  CLRF   00
3EBA:  CLRF   02
3EBC:  MOVLW  4F
3EBE:  MOVWF  01
3EC0:  MOVLB  0
3EC2:  CALL   35AE
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3EC6:  MOVLB  6
3EC8:  CLRF   xD4
3ECA:  CLRF   xD3
3ECC:  MOVF   xD4,F
3ECE:  BNZ   3F32
3ED0:  MOVF   xD3,W
3ED2:  SUBLW  27
3ED4:  BNC   3F32
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3ED6:  MOVFF  23,03
3EDA:  MOVFF  22,02
3EDE:  MOVFF  21,01
3EE2:  MOVFF  20,00
3EE6:  MOVLW  01
3EE8:  ADDWF  20,F
3EEA:  BTFSC  FD8.0
3EEC:  INCF   21,F
3EEE:  BTFSC  FD8.2
3EF0:  INCF   22,F
3EF2:  BTFSC  FD8.2
3EF4:  INCF   23,F
3EF6:  MOVFF  01,854
3EFA:  MOVFF  00,853
3EFE:  MOVLW  1E
3F00:  ADDWF  xD3,W
3F02:  MOVWF  FE9
3F04:  MOVLW  02
3F06:  ADDWFC xD4,W
3F08:  MOVWF  FEA
3F0A:  MOVF   FEF,W
3F0C:  ANDLW  0F
3F0E:  ADDLW  30
3F10:  MOVLB  8
3F12:  MOVWF  x55
3F14:  MOVLB  9
3F16:  CLRF   x16
3F18:  CLRF   x15
3F1A:  MOVFF  01,914
3F1E:  MOVFF  00,913
3F22:  MOVWF  x17
3F24:  MOVLB  0
3F26:  RCALL  3A80
....................          }  
3F28:  MOVLB  6
3F2A:  INCF   xD3,F
3F2C:  BTFSC  FD8.2
3F2E:  INCF   xD4,F
3F30:  BRA    3ECC
....................          memset(Track2,0,sizeof(Track2)); 
3F32:  MOVLW  02
3F34:  MOVWF  FEA
3F36:  MOVLW  1E
3F38:  MOVWF  FE9
3F3A:  CLRF   00
3F3C:  CLRF   02
3F3E:  MOVLW  28
3F40:  MOVWF  01
3F42:  MOVLB  0
3F44:  CALL   35AE
....................         fprintf(COM2,"\r\n"); 
3F48:  MOVLW  0D
3F4A:  MOVLB  9
3F4C:  MOVWF  x0C
3F4E:  MOVLB  0
3F50:  CALL   1620
3F54:  MOVLW  0A
3F56:  MOVLB  9
3F58:  MOVWF  x0C
3F5A:  MOVLB  0
3F5C:  CALL   1620
....................         fprintf(COM2,"Done"); 
3F60:  MOVLW  D0
3F62:  MOVWF  FF6
3F64:  MOVLW  05
3F66:  MOVWF  FF7
3F68:  CALL   174A
....................              
....................         fprintf(COM2,"\r\n"); 
3F6C:  MOVLW  0D
3F6E:  MOVLB  9
3F70:  MOVWF  x0C
3F72:  MOVLB  0
3F74:  CALL   1620
3F78:  MOVLW  0A
3F7A:  MOVLB  9
3F7C:  MOVWF  x0C
3F7E:  MOVLB  0
3F80:  CALL   1620
....................         fprintf(COM2,"Waiting for PIN number"); 
3F84:  MOVLW  D6
3F86:  MOVWF  FF6
3F88:  MOVLW  05
3F8A:  MOVWF  FF7
3F8C:  CALL   174A
....................         memset(key_data,0,sizeof(key_data));  
3F90:  MOVLW  01
3F92:  MOVWF  FEA
3F94:  MOVLW  4A
3F96:  MOVWF  FE9
3F98:  CLRF   00
3F9A:  CLRF   02
3F9C:  MOVLW  10
3F9E:  MOVWF  01
3FA0:  CALL   35AE
....................         fprintf(COM2,"\r\n"); 
3FA4:  MOVLW  0D
3FA6:  MOVLB  9
3FA8:  MOVWF  x0C
3FAA:  MOVLB  0
3FAC:  CALL   1620
3FB0:  MOVLW  0A
3FB2:  MOVLB  9
3FB4:  MOVWF  x0C
3FB6:  MOVLB  0
3FB8:  CALL   1620
....................         charac_timeout=0; 
3FBC:  MOVLB  1
3FBE:  CLRF   x00
3FC0:  MOVLB  0
3FC2:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3FC4:  MOVFF  23,903
3FC8:  MOVFF  22,902
3FCC:  MOVFF  21,901
3FD0:  MOVFF  20,900
3FD4:  MOVLW  19
3FD6:  MOVLB  9
3FD8:  MOVWF  x04
3FDA:  MOVLB  0
3FDC:  RCALL  3B7E
....................       datinbuf=0; 
3FDE:  MOVLB  6
3FE0:  CLRF   xD5
....................       saving_flag=0; 
3FE2:  CLRF   xD8
....................       data_avai=1; 
3FE4:  MOVLW  01
3FE6:  MOVWF  xD9
....................       enable_getpin=1; 
3FE8:  MOVLB  1
3FEA:  MOVWF  x45
....................       charac_timeout=0; 
3FEC:  CLRF   x00
3FEE:  MOVLB  0
3FF0:  CLRF   xFF
....................       key_count_ms=0; 
3FF2:  MOVLB  1
3FF4:  CLRF   x47
3FF6:  MOVLB  8
3FF8:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3FFA:  MOVLB  0
3FFC:  GOTO   59B4 (RETURN)
.................... //========================= 
.................... void saving_card_encrypt() 
.................... { 
*
4ECA:  MOVLB  8
4ECC:  CLRF   x54
....................    int8 temp,i,j,u; 
....................    int8 countbyte=0; 
....................    int16 tempcount; 
....................    int8 carddata[numdataofonecard]; 
....................    int8 encryptblock[16]; 
....................    int8 tempkey[16]; 
....................    saving_flag=1; 
4ECE:  MOVLW  01
4ED0:  MOVLB  6
4ED2:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdataofonecard)+ptr_start); 
4ED4:  MOVLB  0
4ED6:  CALL   3534
4EDA:  MOVFF  02,8F8
4EDE:  MOVFF  01,8F7
4EE2:  MOVLB  8
4EE4:  RLCF   xF7,F
4EE6:  RLCF   xF8,F
4EE8:  RLCF   xF7,F
4EEA:  RLCF   xF8,F
4EEC:  RLCF   xF7,F
4EEE:  RLCF   xF8,F
4EF0:  RLCF   xF7,F
4EF2:  RLCF   xF8,F
4EF4:  RLCF   xF7,F
4EF6:  RLCF   xF8,F
4EF8:  RLCF   xF7,F
4EFA:  RLCF   xF8,F
4EFC:  RLCF   xF7,F
4EFE:  RLCF   xF8,F
4F00:  MOVLW  80
4F02:  ANDWF  xF7,F
4F04:  MOVLW  96
4F06:  ADDWF  xF7,W
4F08:  MOVWF  01
4F0A:  MOVLW  00
4F0C:  ADDWFC xF8,W
4F0E:  MOVFF  01,20
4F12:  MOVWF  21
4F14:  CLRF   22
4F16:  CLRF   23
....................    if(datinbuf==0)  
4F18:  MOVLB  6
4F1A:  MOVF   xD5,F
4F1C:  BNZ   4F40
....................    { 
....................       countbit_T1=0; 
4F1E:  CLRF   xCA
4F20:  CLRF   xC9
....................       countbit_T2=0; 
4F22:  CLRF   xCC
4F24:  CLRF   xCB
....................       bug_countbit_T1=0; 
4F26:  CLRF   xCE
4F28:  CLRF   xCD
....................       bug_countbit_T2=0; 
4F2A:  CLRF   xD0
4F2C:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
4F2E:  MOVF   xD9,F
4F30:  BNZ   4F3C
4F32:  MOVLB  1
4F34:  SETF   x00
4F36:  MOVLB  0
4F38:  SETF   xFF
4F3A:  MOVLB  6
....................       saving_flag=0; 
4F3C:  CLRF   xD8
....................       return; 
4F3E:  BRA    5406
....................    }//*/ 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
4F40:  MOVLW  EE
4F42:  MOVWF  FF6
4F44:  MOVLW  05
4F46:  MOVWF  FF7
4F48:  MOVLB  0
4F4A:  CALL   174A
....................    //key_count=0; 
....................    enable_getpin=1; 
4F4E:  MOVLW  01
4F50:  MOVLB  1
4F52:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
4F54:  MOVFF  6CA,856
4F58:  MOVFF  6C9,855
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
4F5C:  MOVLB  8
4F5E:  CLRF   xF7
4F60:  MOVFF  856,8F9
4F64:  MOVFF  855,8F8
4F68:  MOVLW  02
4F6A:  MOVWF  xFB
4F6C:  MOVLW  46
4F6E:  MOVWF  xFA
4F70:  MOVLW  01
4F72:  MOVWF  xFD
4F74:  MOVLW  CF
4F76:  MOVWF  xFC
4F78:  MOVLB  0
4F7A:  CALL   35C8
....................    countbit_T1=0; 
4F7E:  MOVLB  6
4F80:  CLRF   xCA
4F82:  CLRF   xC9
....................    tempcount=countbit_T2;    
4F84:  MOVFF  6CC,856
4F88:  MOVFF  6CB,855
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
4F8C:  MOVLW  01
4F8E:  MOVLB  8
4F90:  MOVWF  xF7
4F92:  MOVFF  856,8F9
4F96:  MOVFF  855,8F8
4F9A:  MOVLW  05
4F9C:  MOVWF  xFB
4F9E:  MOVLW  98
4FA0:  MOVWF  xFA
4FA2:  MOVLW  02
4FA4:  MOVWF  xFD
4FA6:  MOVLW  1E
4FA8:  MOVWF  xFC
4FAA:  MOVLB  0
4FAC:  CALL   35C8
....................    countbit_T2=0; 
4FB0:  MOVLB  6
4FB2:  CLRF   xCC
4FB4:  CLRF   xCB
....................    saving_flag=0; 
4FB6:  CLRF   xD8
....................    temp=Track1[0]+0x20; 
4FB8:  MOVLW  20
4FBA:  MOVLB  1
4FBC:  ADDWF  xCF,W
4FBE:  MOVLB  8
4FC0:  MOVWF  x50
....................    memset(carddata,0,sizeof(carddata));  
4FC2:  MOVLW  08
4FC4:  MOVWF  FEA
4FC6:  MOVLW  57
4FC8:  MOVWF  FE9
4FCA:  CLRF   00
4FCC:  CLRF   02
4FCE:  MOVLW  80
4FD0:  MOVWF  01
4FD2:  MOVLB  0
4FD4:  CALL   35AE
....................    if((ptr_card<EEPROM_SIZE_stofkey)) 
4FD8:  MOVF   23,F
4FDA:  BTFSS  FD8.2
4FDC:  BRA    5404
4FDE:  MOVF   22,F
4FE0:  BTFSS  FD8.2
4FE2:  BRA    5404
4FE4:  MOVF   21,W
4FE6:  SUBLW  E0
4FE8:  BTFSS  FD8.0
4FEA:  BRA    5404
....................    { 
....................          countbyte = 0; 
4FEC:  MOVLB  8
4FEE:  CLRF   x54
....................          carddata[countbyte++]=date;    
4FF0:  MOVF   x54,W
4FF2:  INCF   x54,F
4FF4:  CLRF   03
4FF6:  ADDLW  57
4FF8:  MOVWF  FE9
4FFA:  MOVLW  08
4FFC:  ADDWFC 03,W
4FFE:  MOVWF  FEA
5000:  MOVFF  1CB,FEF
....................          carddata[countbyte++]=mon;    
5004:  MOVF   x54,W
5006:  INCF   x54,F
5008:  CLRF   03
500A:  ADDLW  57
500C:  MOVWF  FE9
500E:  MOVLW  08
5010:  ADDWFC 03,W
5012:  MOVWF  FEA
5014:  MOVFF  1CA,FEF
....................          carddata[countbyte++]=h;    
5018:  MOVF   x54,W
501A:  INCF   x54,F
501C:  CLRF   03
501E:  ADDLW  57
5020:  MOVWF  FE9
5022:  MOVLW  08
5024:  ADDWFC 03,W
5026:  MOVWF  FEA
5028:  MOVFF  1CC,FEF
....................          carddata[countbyte++]=min;    
502C:  MOVF   x54,W
502E:  INCF   x54,F
5030:  CLRF   03
5032:  ADDLW  57
5034:  MOVWF  FE9
5036:  MOVLW  08
5038:  ADDWFC 03,W
503A:  MOVWF  FEA
503C:  MOVFF  1CD,FEF
....................          carddata[countbyte++]=sec; 
5040:  MOVF   x54,W
5042:  INCF   x54,F
5044:  CLRF   03
5046:  ADDLW  57
5048:  MOVWF  FE9
504A:  MOVLW  08
504C:  ADDWFC 03,W
504E:  MOVWF  FEA
5050:  MOVFF  1CE,FEF
....................          carddata[countbyte++]=0xff;             
5054:  MOVF   x54,W
5056:  INCF   x54,F
5058:  CLRF   03
505A:  ADDLW  57
505C:  MOVWF  FE9
505E:  MOVLW  08
5060:  ADDWFC 03,W
5062:  MOVWF  FEA
5064:  SETF   FEF
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
5066:  MOVLB  6
5068:  CLRF   xD4
506A:  CLRF   xD3
506C:  MOVF   xD4,F
506E:  BNZ   50BA
5070:  MOVF   xD3,W
5072:  SUBLW  4E
5074:  BNC   50BA
....................          { 
....................             temp = (INT8)((Track1[countbit]&0b00111111)+0x20); 
5076:  MOVLW  CF
5078:  ADDWF  xD3,W
507A:  MOVWF  FE9
507C:  MOVLW  01
507E:  ADDWFC xD4,W
5080:  MOVWF  FEA
5082:  MOVF   FEF,W
5084:  ANDLW  3F
5086:  ADDLW  20
5088:  MOVLB  8
508A:  MOVWF  x50
....................             carddata[countbyte++] = temp; 
508C:  MOVF   x54,W
508E:  INCF   x54,F
5090:  CLRF   03
5092:  ADDLW  57
5094:  MOVWF  FE9
5096:  MOVLW  08
5098:  ADDWFC 03,W
509A:  MOVWF  FEA
509C:  MOVFF  850,FEF
....................             if(temp=='?') 
50A0:  MOVF   x50,W
50A2:  SUBLW  3F
50A4:  BNZ   50B0
....................             { 
....................                countbit = numbyteoftrack1; 
50A6:  MOVLB  6
50A8:  CLRF   xD4
50AA:  MOVLW  4F
50AC:  MOVWF  xD3
50AE:  MOVLB  8
....................             }      
....................          } 
50B0:  MOVLB  6
50B2:  INCF   xD3,F
50B4:  BTFSC  FD8.2
50B6:  INCF   xD4,F
50B8:  BRA    506C
....................          countbyte = numbyteoftrack1+6; 
50BA:  MOVLW  55
50BC:  MOVLB  8
50BE:  MOVWF  x54
....................          fprintf(COM2,"countbyte: %u",countbyte); 
50C0:  MOVLW  04
50C2:  MOVWF  FF6
50C4:  MOVLW  06
50C6:  MOVWF  FF7
50C8:  MOVLW  0B
50CA:  MOVLB  9
50CC:  MOVWF  x00
50CE:  MOVLB  0
50D0:  CALL   1666
50D4:  MOVFF  854,900
50D8:  MOVLW  1B
50DA:  MOVLB  9
50DC:  MOVWF  x01
50DE:  MOVLB  0
50E0:  CALL   4000
....................          memset(Track1,0,sizeof(Track1)); 
50E4:  MOVLW  01
50E6:  MOVWF  FEA
50E8:  MOVLW  CF
50EA:  MOVWF  FE9
50EC:  CLRF   00
50EE:  CLRF   02
50F0:  MOVLW  4F
50F2:  MOVWF  01
50F4:  CALL   35AE
....................          carddata[countbyte++]=0xfe; 
50F8:  MOVLB  8
50FA:  MOVF   x54,W
50FC:  INCF   x54,F
50FE:  CLRF   03
5100:  ADDLW  57
5102:  MOVWF  FE9
5104:  MOVLW  08
5106:  ADDWFC 03,W
5108:  MOVWF  FEA
510A:  MOVLW  FE
510C:  MOVWF  FEF
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
510E:  MOVLB  6
5110:  CLRF   xD4
5112:  CLRF   xD3
5114:  MOVF   xD4,F
5116:  BNZ   5162
5118:  MOVF   xD3,W
511A:  SUBLW  27
511C:  BNC   5162
....................          { 
....................             temp = (INT8)((Track2[countbit]&0b00001111)+0x30); 
511E:  MOVLW  1E
5120:  ADDWF  xD3,W
5122:  MOVWF  FE9
5124:  MOVLW  02
5126:  ADDWFC xD4,W
5128:  MOVWF  FEA
512A:  MOVF   FEF,W
512C:  ANDLW  0F
512E:  ADDLW  30
5130:  MOVLB  8
5132:  MOVWF  x50
....................             carddata[countbyte++] = temp; 
5134:  MOVF   x54,W
5136:  INCF   x54,F
5138:  CLRF   03
513A:  ADDLW  57
513C:  MOVWF  FE9
513E:  MOVLW  08
5140:  ADDWFC 03,W
5142:  MOVWF  FEA
5144:  MOVFF  850,FEF
....................             if(temp=='?') 
5148:  MOVF   x50,W
514A:  SUBLW  3F
514C:  BNZ   5158
....................             { 
....................                countbit = numbyteoftrack2; 
514E:  MOVLB  6
5150:  CLRF   xD4
5152:  MOVLW  28
5154:  MOVWF  xD3
5156:  MOVLB  8
....................             } 
....................          } 
5158:  MOVLB  6
515A:  INCF   xD3,F
515C:  BTFSC  FD8.2
515E:  INCF   xD4,F
5160:  BRA    5114
....................          countbyte = numbyteoftrack1+numbyteoftrack2+7;          
5162:  MOVLW  7E
5164:  MOVLB  8
5166:  MOVWF  x54
....................          fprintf(COM2,"countbyte: %u",countbyte); 
5168:  MOVLW  12
516A:  MOVWF  FF6
516C:  MOVLW  06
516E:  MOVWF  FF7
5170:  MOVLW  0B
5172:  MOVLB  9
5174:  MOVWF  x00
5176:  MOVLB  0
5178:  CALL   1666
517C:  MOVFF  854,900
5180:  MOVLW  1B
5182:  MOVLB  9
5184:  MOVWF  x01
5186:  MOVLB  0
5188:  CALL   4000
....................          for(i=countbyte;i<numdataofonecard;i++) 
518C:  MOVFF  854,851
5190:  MOVLB  8
5192:  MOVF   x51,W
5194:  SUBLW  7F
5196:  BNC   51AC
....................          { 
....................              carddata[i] = 0; 
5198:  CLRF   03
519A:  MOVF   x51,W
519C:  ADDLW  57
519E:  MOVWF  FE9
51A0:  MOVLW  08
51A2:  ADDWFC 03,W
51A4:  MOVWF  FEA
51A6:  CLRF   FEF
....................          } 
51A8:  INCF   x51,F
51AA:  BRA    5192
....................          carddata[numdataofonecard-1]=0xfc; 
51AC:  MOVLW  FC
51AE:  MOVWF  xD6
....................          for(i=0;i<8;i++) 
51B0:  CLRF   x51
51B2:  MOVF   x51,W
51B4:  SUBLW  07
51B6:  BNC   526C
....................          { 
....................              for(j=0;j<16;j++) 
51B8:  CLRF   x52
51BA:  MOVF   x52,W
51BC:  SUBLW  0F
51BE:  BNC   51F8
....................              { 
....................                 encryptblock[j] = carddata[i*16+j]; 
51C0:  CLRF   03
51C2:  MOVF   x52,W
51C4:  ADDLW  D7
51C6:  MOVWF  01
51C8:  MOVLW  08
51CA:  ADDWFC 03,F
51CC:  MOVFF  03,8F8
51D0:  MOVF   x51,W
51D2:  MULLW  10
51D4:  MOVF   FF3,W
51D6:  ADDWF  x52,W
51D8:  CLRF   03
51DA:  ADDLW  57
51DC:  MOVWF  FE9
51DE:  MOVLW  08
51E0:  ADDWFC 03,W
51E2:  MOVWF  FEA
51E4:  MOVFF  FEF,8F9
51E8:  MOVFF  8F8,FEA
51EC:  MOVFF  01,FE9
51F0:  MOVFF  8F9,FEF
....................              } 
51F4:  INCF   x52,F
51F6:  BRA    51BA
....................              EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
51F8:  MOVLB  9
51FA:  CLRF   x07
51FC:  CLRF   x06
51FE:  CLRF   x05
5200:  MOVLW  3F
5202:  MOVWF  x04
5204:  CLRF   x0B
5206:  CLRF   x0A
5208:  CLRF   x09
520A:  MOVLW  20
520C:  MOVWF  x08
520E:  MOVLW  01
5210:  MOVWF  x0D
5212:  MOVWF  x0C
5214:  MOVLB  0
5216:  CALL   4086
....................              aes_enc_dec((unsigned int8 *)&encryptblock[0], (unsigned int8 *)&crypto_key[0],0); 
521A:  MOVLW  08
521C:  MOVLB  9
521E:  MOVWF  x01
5220:  MOVLW  D7
5222:  MOVWF  x00
5224:  MOVLW  01
5226:  MOVWF  x03
5228:  MOVWF  x02
522A:  CLRF   x04
522C:  MOVLB  0
522E:  CALL   417C
....................              /*for(u=0;u<16;u++) 
....................              { 
....................                 encryptblock[u];  
....................                 fprintf(COM2,"%x",encryptblock[u]); 
....................              }*/ 
....................              EEPROM_write(ptr_card,16,encryptblock); 
5232:  MOVFF  23,903
5236:  MOVFF  22,902
523A:  MOVFF  21,901
523E:  MOVFF  20,900
5242:  MOVLB  9
5244:  CLRF   x07
5246:  CLRF   x06
5248:  CLRF   x05
524A:  MOVLW  10
524C:  MOVWF  x04
524E:  MOVLW  08
5250:  MOVWF  x09
5252:  MOVLW  D7
5254:  MOVWF  x08
5256:  MOVLB  0
5258:  RCALL  4DF0
....................              ptr_card=ptr_card+16; 
525A:  MOVLW  10
525C:  ADDWF  20,F
525E:  MOVLW  00
5260:  ADDWFC 21,F
5262:  ADDWFC 22,F
5264:  ADDWFC 23,F
....................          } 
5266:  MOVLB  8
5268:  INCF   x51,F
526A:  BRA    51B2
....................          fprintf(COM2,"\r\n"); 
526C:  MOVLW  0D
526E:  MOVLB  9
5270:  MOVWF  x0C
5272:  MOVLB  0
5274:  CALL   1620
5278:  MOVLW  0A
527A:  MOVLB  9
527C:  MOVWF  x0C
527E:  MOVLB  0
5280:  CALL   1620
....................          fprintf(COM2,"card data: %lu",ptr_card); 
5284:  MOVLW  20
5286:  MOVWF  FF6
5288:  MOVLW  06
528A:  MOVWF  FF7
528C:  MOVLW  0B
528E:  MOVLB  9
5290:  MOVWF  x00
5292:  MOVLB  0
5294:  CALL   1666
5298:  MOVLW  41
529A:  MOVWF  FE9
529C:  MOVFF  23,903
52A0:  MOVFF  22,902
52A4:  MOVFF  21,901
52A8:  MOVFF  20,900
52AC:  CALL   231A
....................          fprintf(COM2,"\r\n"); 
52B0:  MOVLW  0D
52B2:  MOVLB  9
52B4:  MOVWF  x0C
52B6:  MOVLB  0
52B8:  CALL   1620
52BC:  MOVLW  0A
52BE:  MOVLB  9
52C0:  MOVWF  x0C
52C2:  MOVLB  0
52C4:  CALL   1620
....................          EEPROM_read(ptr_card-128,128,&carddata); 
52C8:  MOVLW  80
52CA:  SUBWF  20,W
52CC:  MOVLB  8
52CE:  MOVWF  xF7
52D0:  MOVLW  00
52D2:  SUBWFB 21,W
52D4:  MOVWF  xF8
52D6:  MOVLW  00
52D8:  SUBWFB 22,W
52DA:  MOVWF  xF9
52DC:  MOVLW  00
52DE:  SUBWFB 23,W
52E0:  MOVWF  xFA
52E2:  MOVFF  FE8,907
52E6:  MOVFF  8F9,906
52EA:  MOVFF  8F8,905
52EE:  MOVFF  8F7,904
52F2:  MOVLB  9
52F4:  CLRF   x0B
52F6:  CLRF   x0A
52F8:  CLRF   x09
52FA:  MOVLW  80
52FC:  MOVWF  x08
52FE:  MOVLW  08
5300:  MOVWF  x0D
5302:  MOVLW  57
5304:  MOVWF  x0C
5306:  MOVLB  0
5308:  CALL   4086
....................          for(i=0;i<numdataofonecard;i++) 
530C:  MOVLB  8
530E:  CLRF   x51
5310:  MOVF   x51,W
5312:  SUBLW  7F
5314:  BNC   533C
....................          { 
....................              fprintf(COM2,"%x",carddata[i]); 
5316:  CLRF   03
5318:  MOVF   x51,W
531A:  ADDLW  57
531C:  MOVWF  FE9
531E:  MOVLW  08
5320:  ADDWFC 03,W
5322:  MOVWF  FEA
5324:  MOVFF  FEF,8F7
5328:  MOVFF  8F7,901
532C:  MOVLW  57
532E:  MOVLB  9
5330:  MOVWF  x02
5332:  MOVLB  0
5334:  RCALL  4E80
....................          } 
5336:  MOVLB  8
5338:  INCF   x51,F
533A:  BRA    5310
....................          memset(Track2,0,sizeof(Track2)); 
533C:  MOVLW  02
533E:  MOVWF  FEA
5340:  MOVLW  1E
5342:  MOVWF  FE9
5344:  CLRF   00
5346:  CLRF   02
5348:  MOVLW  28
534A:  MOVWF  01
534C:  MOVLB  0
534E:  CALL   35AE
....................         fprintf(COM2,"\r\n"); 
5352:  MOVLW  0D
5354:  MOVLB  9
5356:  MOVWF  x0C
5358:  MOVLB  0
535A:  CALL   1620
535E:  MOVLW  0A
5360:  MOVLB  9
5362:  MOVWF  x0C
5364:  MOVLB  0
5366:  CALL   1620
....................         fprintf(COM2,"Done"); 
536A:  MOVLW  30
536C:  MOVWF  FF6
536E:  MOVLW  06
5370:  MOVWF  FF7
5372:  CALL   174A
....................              
....................         fprintf(COM2,"\r\n"); 
5376:  MOVLW  0D
5378:  MOVLB  9
537A:  MOVWF  x0C
537C:  MOVLB  0
537E:  CALL   1620
5382:  MOVLW  0A
5384:  MOVLB  9
5386:  MOVWF  x0C
5388:  MOVLB  0
538A:  CALL   1620
....................         fprintf(COM2,"Waiting for PIN number"); 
538E:  MOVLW  36
5390:  MOVWF  FF6
5392:  MOVLW  06
5394:  MOVWF  FF7
5396:  CALL   174A
....................         memset(key_data,0,sizeof(key_data));  
539A:  MOVLW  01
539C:  MOVWF  FEA
539E:  MOVLW  4A
53A0:  MOVWF  FE9
53A2:  CLRF   00
53A4:  CLRF   02
53A6:  MOVLW  10
53A8:  MOVWF  01
53AA:  CALL   35AE
....................         fprintf(COM2,"\r\n"); 
53AE:  MOVLW  0D
53B0:  MOVLB  9
53B2:  MOVWF  x0C
53B4:  MOVLB  0
53B6:  CALL   1620
53BA:  MOVLW  0A
53BC:  MOVLB  9
53BE:  MOVWF  x0C
53C0:  MOVLB  0
53C2:  CALL   1620
....................         charac_timeout=0; 
53C6:  MOVLB  1
53C8:  CLRF   x00
53CA:  MOVLB  0
53CC:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       //ptr_card = ptr_card+numdataofonecard; 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
53CE:  MOVFF  23,903
53D2:  MOVFF  22,902
53D6:  MOVFF  21,901
53DA:  MOVFF  20,900
53DE:  MOVLW  19
53E0:  MOVLB  9
53E2:  MOVWF  x04
53E4:  MOVLB  0
53E6:  CALL   3B7E
....................       datinbuf=0; 
53EA:  MOVLB  6
53EC:  CLRF   xD5
....................       saving_flag=0; 
53EE:  CLRF   xD8
....................       data_avai=1; 
53F0:  MOVLW  01
53F2:  MOVWF  xD9
....................       enable_getpin=1; 
53F4:  MOVLB  1
53F6:  MOVWF  x45
....................       charac_timeout=0; 
53F8:  CLRF   x00
53FA:  MOVLB  0
53FC:  CLRF   xFF
....................       key_count_ms=0; 
53FE:  MOVLB  1
5400:  CLRF   x47
5402:  MOVLB  0
5404:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
5406:  MOVLB  0
5408:  GOTO   59BE (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
190E:  MOVLW  01
1910:  MOVLB  8
1912:  MOVWF  x4D
1914:  MOVWF  x4E
1916:  MOVWF  x4F
1918:  MOVWF  x50
191A:  CLRF   x51
191C:  MOVWF  x52
191E:  MOVWF  x53
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1920:  MOVLB  6
1922:  CLRF   xD2
1924:  CLRF   xD1
....................    mcr_timeout=0; 
1926:  CLRF   xC7
1928:  CLRF   xC6
192A:  CLRF   xC5
192C:  CLRF   xC4
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
192E:  MOVF   xD2,W
1930:  SUBLW  FD
1932:  BNC   1950
1934:  BNZ   193C
1936:  MOVF   xD1,W
1938:  SUBLW  E7
193A:  BNC   1950
193C:  BSF    F93.1
193E:  BTFSS  F81.1
1940:  BRA    1950
1942:  BSF    F94.5
1944:  BTFSS  F82.5
1946:  BRA    1950
....................       card_timeout++; 
1948:  INCF   xD1,F
194A:  BTFSC  FD8.2
194C:  INCF   xD2,F
....................    } 
194E:  BRA    192E
....................    card_timeout=0; 
1950:  CLRF   xD2
1952:  CLRF   xD1
....................    buffertrack1[bug_countbit_T1++]=0; 
1954:  MOVFF  6CE,03
1958:  MOVF   xCD,W
195A:  INCF   xCD,F
195C:  BTFSC  FD8.2
195E:  INCF   xCE,F
1960:  MOVLB  8
1962:  MOVWF  x56
1964:  MOVLW  46
1966:  ADDWF  x56,W
1968:  MOVWF  FE9
196A:  MOVLW  02
196C:  ADDWFC 03,W
196E:  MOVWF  FEA
1970:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1972:  MOVLB  6
1974:  MOVFF  6CE,03
1978:  MOVF   xCD,W
197A:  INCF   xCD,F
197C:  BTFSC  FD8.2
197E:  INCF   xCE,F
1980:  MOVLB  8
1982:  MOVWF  x56
1984:  MOVLW  46
1986:  ADDWF  x56,W
1988:  MOVWF  FE9
198A:  MOVLW  02
198C:  ADDWFC 03,W
198E:  MOVWF  FEA
1990:  MOVLW  01
1992:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1994:  MOVLB  6
1996:  MOVFF  6D0,03
199A:  MOVF   xCF,W
199C:  INCF   xCF,F
199E:  BTFSC  FD8.2
19A0:  INCF   xD0,F
19A2:  MOVLB  8
19A4:  MOVWF  x56
19A6:  MOVLW  98
19A8:  ADDWF  x56,W
19AA:  MOVWF  FE9
19AC:  MOVLW  05
19AE:  ADDWFC 03,W
19B0:  MOVWF  FEA
19B2:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
19B4:  MOVLB  6
19B6:  MOVFF  6D0,03
19BA:  MOVF   xCF,W
19BC:  INCF   xCF,F
19BE:  BTFSC  FD8.2
19C0:  INCF   xD0,F
19C2:  MOVLB  8
19C4:  MOVWF  x56
19C6:  MOVLW  98
19C8:  ADDWF  x56,W
19CA:  MOVWF  FE9
19CC:  MOVLW  05
19CE:  ADDWFC 03,W
19D0:  MOVWF  FEA
19D2:  MOVLW  01
19D4:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
19D6:  MOVLB  6
19D8:  MOVF   xCE,W
19DA:  SUBLW  03
19DC:  BTFSS  FD8.0
19DE:  BRA    1ABE
19E0:  BNZ   19EA
19E2:  MOVF   xCD,W
19E4:  SUBLW  51
19E6:  BTFSS  FD8.0
19E8:  BRA    1ABE
19EA:  MOVF   xD0,W
19EC:  SUBLW  01
19EE:  BTFSS  FD8.0
19F0:  BRA    1ABE
19F2:  BNZ   19FA
19F4:  MOVF   xCF,W
19F6:  SUBLW  2B
19F8:  BNC   1ABE
19FA:  MOVF   xD2,W
19FC:  SUBLW  FF
19FE:  BNC   1ABE
1A00:  BNZ   1A08
1A02:  MOVF   xD1,W
1A04:  SUBLW  DB
1A06:  BNC   1ABE
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
1A08:  MOVF   xDB,F
1A0A:  BZ    1A14
....................          { 
....................             bug_countbit_T1=0; 
1A0C:  CLRF   xCE
1A0E:  CLRF   xCD
....................             bug_countbit_T2=0; 
1A10:  CLRF   xD0
1A12:  CLRF   xCF
....................          } 
....................          card_timeout++; 
1A14:  INCF   xD1,F
1A16:  BTFSC  FD8.2
1A18:  INCF   xD2,F
....................          mcr_timeout=0; 
1A1A:  CLRF   xC7
1A1C:  CLRF   xC6
1A1E:  CLRF   xC5
1A20:  CLRF   xC4
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1A22:  BSF    F93.2
1A24:  MOVLB  8
1A26:  CLRF   x4D
1A28:  BTFSC  F81.2
1A2A:  INCF   x4D,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1A2C:  MOVF   x4D,F
1A2E:  BNZ   1A6C
1A30:  DECFSZ x4E,W
1A32:  BRA    1A6C
....................          { 
....................             ST1_old = 0; 
1A34:  CLRF   x4E
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1A36:  MOVLW  46
1A38:  MOVLB  6
1A3A:  ADDWF  xCD,W
1A3C:  MOVWF  FE9
1A3E:  MOVLW  02
1A40:  ADDWFC xCE,W
1A42:  MOVWF  FEA
1A44:  BSF    F93.1
1A46:  MOVLW  00
1A48:  BTFSS  F81.1
1A4A:  MOVLW  01
1A4C:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1A4E:  MOVLW  98
1A50:  ADDWF  xCF,W
1A52:  MOVWF  FE9
1A54:  MOVLW  05
1A56:  ADDWFC xD0,W
1A58:  MOVWF  FEA
1A5A:  MOVFF  851,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1A5E:  INCF   xCD,F
1A60:  BTFSC  FD8.2
1A62:  INCF   xCE,F
....................             card_timeout=0; 
1A64:  CLRF   xD2
1A66:  CLRF   xD1
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A68:  BRA    1A76
1A6A:  MOVLB  8
1A6C:  DECFSZ x4D,W
1A6E:  BRA    1A74
1A70:  MOVLW  01
1A72:  MOVWF  x4E
1A74:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A76:  BSF    F93.3
1A78:  MOVLB  8
1A7A:  CLRF   x4F
1A7C:  BTFSC  F81.3
1A7E:  INCF   x4F,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A80:  MOVF   x4F,F
1A82:  BNZ   1AA2
1A84:  DECFSZ x50,W
1A86:  BRA    1AA2
....................          { 
....................             ST2_old = 0; 
1A88:  CLRF   x50
....................             Bit_t2 = !input(MCR_DATA2); 
1A8A:  BSF    F94.5
1A8C:  CLRF   x51
1A8E:  BTFSS  F82.5
1A90:  INCF   x51,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A92:  MOVLB  6
1A94:  INCF   xCF,F
1A96:  BTFSC  FD8.2
1A98:  INCF   xD0,F
....................             card_timeout=0; 
1A9A:  CLRF   xD2
1A9C:  CLRF   xD1
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A9E:  BRA    1AAC
1AA0:  MOVLB  8
1AA2:  DECFSZ x4F,W
1AA4:  BRA    1AAA
1AA6:  MOVLW  01
1AA8:  MOVWF  x50
1AAA:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1AAC:  BSF    F93.0
1AAE:  BTFSS  F81.0
1AB0:  BRA    1ABC
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1AB2:  CLRF   xDB
....................             card_timeout=65500; 
1AB4:  SETF   xD2
1AB6:  MOVLW  DC
1AB8:  MOVWF  xD1
....................             break;            
1ABA:  BRA    1ABE
....................          } 
....................       } 
1ABC:  BRA    19D8
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1ABE:  CLRF   xD2
1AC0:  CLRF   xD1
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1AC2:  MOVLB  9
1AC4:  CLRF   x15
1AC6:  MOVFF  6CE,917
1ACA:  MOVFF  6CD,916
1ACE:  MOVLW  02
1AD0:  MOVWF  x19
1AD2:  MOVLW  46
1AD4:  MOVWF  x18
1AD6:  MOVLB  0
1AD8:  CALL   0A1E
1ADC:  MOVFF  01,852
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1AE0:  MOVLW  01
1AE2:  MOVLB  9
1AE4:  MOVWF  x15
1AE6:  MOVFF  6D0,917
1AEA:  MOVFF  6CF,916
1AEE:  MOVLW  05
1AF0:  MOVWF  x19
1AF2:  MOVLW  98
1AF4:  MOVWF  x18
1AF6:  MOVLB  0
1AF8:  CALL   0A1E
1AFC:  MOVFF  01,853
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1B00:  MOVLB  6
1B02:  DECFSZ xD6,W
1B04:  BRA    1B9A
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1B06:  MOVLW  4E
1B08:  MOVWF  FF6
1B0A:  MOVLW  06
1B0C:  MOVWF  FF7
1B0E:  MOVLW  0E
1B10:  MOVLB  9
1B12:  MOVWF  x00
1B14:  MOVLB  0
1B16:  RCALL  1666
1B18:  MOVLW  10
1B1A:  MOVWF  FE9
1B1C:  MOVFF  6CE,857
1B20:  MOVFF  6CD,856
1B24:  RCALL  168E
1B26:  MOVLW  0D
1B28:  MOVLB  9
1B2A:  MOVWF  x0C
1B2C:  MOVLB  0
1B2E:  RCALL  1620
1B30:  MOVLW  0A
1B32:  MOVLB  9
1B34:  MOVWF  x0C
1B36:  MOVLB  0
1B38:  RCALL  1620
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1B3A:  MOVLW  62
1B3C:  MOVWF  FF6
1B3E:  MOVLW  06
1B40:  MOVWF  FF7
1B42:  MOVLW  0E
1B44:  MOVLB  9
1B46:  MOVWF  x00
1B48:  MOVLB  0
1B4A:  RCALL  1666
1B4C:  MOVLW  10
1B4E:  MOVWF  FE9
1B50:  MOVFF  6D0,857
1B54:  MOVFF  6CF,856
1B58:  RCALL  168E
1B5A:  MOVLW  0D
1B5C:  MOVLB  9
1B5E:  MOVWF  x0C
1B60:  MOVLB  0
1B62:  RCALL  1620
1B64:  MOVLW  0A
1B66:  MOVLB  9
1B68:  MOVWF  x0C
1B6A:  MOVLB  0
1B6C:  RCALL  1620
....................          debug_reader();       
1B6E:  BRA    1856
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B70:  MOVLB  8
1B72:  MOVF   x52,F
1B74:  BNZ   1B84
1B76:  MOVLW  76
1B78:  MOVWF  FF6
1B7A:  MOVLW  06
1B7C:  MOVWF  FF7
1B7E:  MOVLB  0
1B80:  RCALL  174A
1B82:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B84:  MOVF   x53,F
1B86:  BNZ   1B96
1B88:  MOVLW  8C
1B8A:  MOVWF  FF6
1B8C:  MOVLW  06
1B8E:  MOVWF  FF7
1B90:  MOVLB  0
1B92:  RCALL  174A
1B94:  MOVLB  8
....................       } 
....................          else 
1B96:  BRA    1BA6
1B98:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B9A:  MOVLW  0F
1B9C:  MOVLB  8
1B9E:  MOVWF  x56
1BA0:  MOVLB  0
1BA2:  RCALL  18E6
1BA4:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1BA6:  MOVF   x52,F
1BA8:  BZ    1BAE
1BAA:  MOVF   x53,F
1BAC:  BNZ   1BCE
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1BAE:  MOVLB  6
1BB0:  CLRF   xD0
1BB2:  CLRF   xCF
....................          bug_countbit_T1=0; 
1BB4:  CLRF   xCE
1BB6:  CLRF   xCD
....................          reading_fg=0; 
1BB8:  CLRF   xDA
....................          count_reading_error++; 
1BBA:  INCF   xDB,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1BBC:  CLRF   xC7
1BBE:  CLRF   xC6
1BC0:  CLRF   xC5
1BC2:  CLRF   xC4
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1BC4:  MOVLW  00
1BC6:  MOVWF  01
1BC8:  BRA    1C08
....................       } 
....................          else  
1BCA:  BRA    1C04
1BCC:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1BCE:  MOVLW  01
1BD0:  MOVLB  6
1BD2:  MOVWF  xD5
....................             reading_fg=1; 
1BD4:  MOVWF  xDA
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1BD6:  MOVFF  6D0,6CC
1BDA:  MOVFF  6CF,6CB
....................             countbit_T1=bug_countbit_T1; 
1BDE:  MOVFF  6CE,6CA
1BE2:  MOVFF  6CD,6C9
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1BE6:  CLRF   xCE
1BE8:  CLRF   xCD
....................             bug_countbit_T2=0;  
1BEA:  CLRF   xD0
1BEC:  CLRF   xCF
....................             mcr_timeout=0; 
1BEE:  CLRF   xC7
1BF0:  CLRF   xC6
1BF2:  CLRF   xC5
1BF4:  CLRF   xC4
....................             charac_timeout=0; 
1BF6:  MOVLB  1
1BF8:  CLRF   x00
1BFA:  MOVLB  0
1BFC:  CLRF   xFF
....................             return 1; 
1BFE:  MOVWF  01
1C00:  MOVLB  6
1C02:  BRA    1C08
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1C04:  MOVLW  00
1C06:  MOVWF  01
.................... } 
1C08:  MOVLB  0
1C0A:  GOTO   1C30 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       delay_us(500); 
1C0E:  MOVLW  02
1C10:  MOVLB  8
1C12:  MOVWF  x4D
1C14:  MOVLW  FA
1C16:  MOVWF  x4E
1C18:  MOVLB  0
1C1A:  GOTO   06A2
1C1E:  MOVLB  8
1C20:  DECFSZ x4D,F
1C22:  BRA    1C14
....................       if(saving_flag==1) return;      
1C24:  MOVLB  6
1C26:  DECFSZ xD8,W
1C28:  BRA    1C2C
1C2A:  BRA    1C42
....................       cardread_st=mcr_read(); 
1C2C:  MOVLB  0
1C2E:  BRA    190E
1C30:  MOVFF  01,6D7
....................       mcr_timeout=0; 
1C34:  MOVLB  6
1C36:  CLRF   xC7
1C38:  CLRF   xC6
1C3A:  CLRF   xC5
1C3C:  CLRF   xC4
....................       card_timeout=0;      
1C3E:  CLRF   xD2
1C40:  CLRF   xD1
.................... } 
.................... //==================================== 
.................... #if 0 
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... #endif 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
1C42:  BCF    FF0.0
1C44:  MOVLB  0
1C46:  GOTO   006C
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
697A:  CLRF   19
697C:  BTFSC  FF2.7
697E:  BSF    19.7
6980:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
6982:  MOVLB  9
6984:  CLRF   x16
6986:  CLRF   x15
6988:  CLRF   x14
698A:  MOVLW  3C
698C:  MOVWF  x13
698E:  MOVLW  03
6990:  MOVWF  x17
6992:  MOVLB  0
6994:  CALL   3A80
6998:  BTFSC  19.7
699A:  BSF    FF2.7
699C:  CLRF   19
699E:  BTFSC  FF2.7
69A0:  BSF    19.7
69A2:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
69A4:  MOVLB  9
69A6:  CLRF   x16
69A8:  CLRF   x15
69AA:  CLRF   x14
69AC:  MOVLW  3A
69AE:  MOVWF  x13
69B0:  MOVLW  01
69B2:  MOVWF  x17
69B4:  MOVLB  0
69B6:  CALL   3A80
69BA:  BTFSC  19.7
69BC:  BSF    FF2.7
69BE:  CLRF   19
69C0:  BTFSC  FF2.7
69C2:  BSF    19.7
69C4:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV);  
69C6:  MOVLB  9
69C8:  CLRF   x1B
69CA:  CLRF   x1A
69CC:  CLRF   x19
69CE:  MOVLW  3A
69D0:  MOVWF  x18
69D2:  MOVLB  0
69D4:  CALL   3468
69D8:  BTFSC  19.7
69DA:  BSF    FF2.7
69DC:  MOVFF  01,6E2
.................... } 
69E0:  GOTO   6CBE (RETURN)
.................... //================================ 
.................... void downloaddataregular() 
.................... { 
*
61F0:  MOVLB  7
61F2:  CLRF   xF6
61F4:  CLRF   xF5
....................     int8 index,i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 temp[50]; 
....................     rec[0]=0; 
61F6:  MOVLB  0
61F8:  CLRF   x7D
61FA:  CLRF   19
61FC:  BTFSC  FF2.7
61FE:  BSF    19.7
6200:  BCF    FF2.7
....................     count_card_tg=get_countcard(); 
6202:  CALL   3534
6206:  BTFSC  19.7
6208:  BSF    FF2.7
620A:  MOVFF  02,6E1
620E:  MOVFF  01,6E0
6212:  CLRF   19
6214:  BTFSC  FF2.7
6216:  BSF    19.7
6218:  BCF    FF2.7
....................     adr=count_card*numdata; 
621A:  MOVFF  6DF,856
621E:  MOVFF  6DE,855
6222:  MOVLB  8
6224:  CLRF   x58
6226:  MOVLW  7C
6228:  MOVWF  x57
622A:  MOVLB  0
622C:  CALL   358C
6230:  BTFSC  19.7
6232:  BSF    FF2.7
6234:  MOVFF  02,7F6
6238:  MOVFF  01,7F5
....................     addr_key=EEPROM_KEY_ST; 
623C:  MOVLB  6
623E:  CLRF   xE6
6240:  CLRF   xE5
6242:  MOVLW  E1
6244:  MOVWF  xE4
6246:  MOVLW  01
6248:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
624A:  MOVF   xDF,W
624C:  SUBWF  xE1,W
624E:  BTFSS  FD8.0
6250:  BRA    65EA
6252:  BNZ   625C
6254:  MOVF   xDE,W
6256:  SUBWF  xE0,W
6258:  BTFSS  FD8.0
625A:  BRA    65EA
625C:  CLRF   19
625E:  BTFSC  FF2.7
6260:  BSF    19.7
6262:  BCF    FF2.7
....................         adr=count_card*numdata+ptr_start; 
6264:  MOVFF  6DF,856
6268:  MOVFF  6DE,855
626C:  MOVLB  8
626E:  CLRF   x58
6270:  MOVLW  7C
6272:  MOVWF  x57
6274:  MOVLB  0
6276:  CALL   358C
627A:  BTFSC  19.7
627C:  BSF    FF2.7
627E:  MOVLW  96
6280:  MOVLB  8
6282:  ADDWF  01,W
6284:  MOVLB  7
6286:  MOVWF  xF5
6288:  MOVLW  00
628A:  MOVLB  8
628C:  ADDWFC 02,W
628E:  MOVLB  7
6290:  MOVWF  xF6
....................         EEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
6292:  MOVLW  7C
6294:  SUBWF  xF5,W
6296:  MOVLB  8
6298:  MOVWF  x2B
629A:  MOVLW  00
629C:  MOVLB  7
629E:  SUBWFB xF6,W
62A0:  MOVLB  8
62A2:  MOVWF  x2C
62A4:  CLRF   19
62A6:  BTFSC  FF2.7
62A8:  BSF    19.7
62AA:  BCF    FF2.7
62AC:  MOVLB  9
62AE:  CLRF   x07
62B0:  CLRF   x06
62B2:  MOVWF  x05
62B4:  MOVFF  82B,904
62B8:  CLRF   x0B
62BA:  CLRF   x0A
62BC:  CLRF   x09
62BE:  MOVLW  7C
62C0:  MOVWF  x08
62C2:  CLRF   x0D
62C4:  MOVLW  7D
62C6:  MOVWF  x0C
62C8:  MOVLB  0
62CA:  CALL   4086
62CE:  BTFSC  19.7
62D0:  BSF    FF2.7
....................         fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
62D2:  MOVLW  10
62D4:  MOVWF  FE9
62D6:  CLRF   19
62D8:  BTFSC  FF2.7
62DA:  BSF    19.7
62DC:  BCF    FF2.7
62DE:  MOVFF  6DF,851
62E2:  MOVFF  6DE,850
62E6:  CALL   583C
62EA:  BTFSC  19.7
62EC:  BSF    FF2.7
62EE:  CLRF   19
62F0:  BTFSC  FF2.7
62F2:  BSF    19.7
62F4:  BCF    FF2.7
62F6:  MOVLW  29
62F8:  MOVLB  9
62FA:  MOVWF  x0C
62FC:  MOVLB  0
62FE:  CALL   1620
6302:  BTFSC  19.7
6304:  BSF    FF2.7
6306:  MOVFF  7D,82B
630A:  MOVLW  01
630C:  MOVLB  8
630E:  MOVWF  x2C
6310:  MOVLB  0
6312:  RCALL  60D6
6314:  CLRF   19
6316:  BTFSC  FF2.7
6318:  BSF    19.7
631A:  BCF    FF2.7
631C:  MOVLW  2F
631E:  MOVLB  9
6320:  MOVWF  x0C
6322:  MOVLB  0
6324:  CALL   1620
6328:  BTFSC  19.7
632A:  BSF    FF2.7
632C:  MOVFF  7E,82B
6330:  MOVLW  01
6332:  MOVLB  8
6334:  MOVWF  x2C
6336:  MOVLB  0
6338:  RCALL  60D6
633A:  CLRF   19
633C:  BTFSC  FF2.7
633E:  BSF    19.7
6340:  BCF    FF2.7
6342:  MOVLW  20
6344:  MOVLB  9
6346:  MOVWF  x0C
6348:  MOVLB  0
634A:  CALL   1620
634E:  BTFSC  19.7
6350:  BSF    FF2.7
6352:  MOVFF  7F,82B
6356:  MOVLW  01
6358:  MOVLB  8
635A:  MOVWF  x2C
635C:  MOVLB  0
635E:  RCALL  60D6
6360:  CLRF   19
6362:  BTFSC  FF2.7
6364:  BSF    19.7
6366:  BCF    FF2.7
6368:  MOVLW  3A
636A:  MOVLB  9
636C:  MOVWF  x0C
636E:  MOVLB  0
6370:  CALL   1620
6374:  BTFSC  19.7
6376:  BSF    FF2.7
6378:  MOVFF  80,82B
637C:  MOVLW  01
637E:  MOVLB  8
6380:  MOVWF  x2C
6382:  MOVLB  0
6384:  RCALL  60D6
6386:  CLRF   19
6388:  BTFSC  FF2.7
638A:  BSF    19.7
638C:  BCF    FF2.7
638E:  MOVLW  3A
6390:  MOVLB  9
6392:  MOVWF  x0C
6394:  MOVLB  0
6396:  CALL   1620
639A:  BTFSC  19.7
639C:  BSF    FF2.7
639E:  MOVFF  81,82B
63A2:  MOVLW  01
63A4:  MOVLB  8
63A6:  MOVWF  x2C
63A8:  MOVLB  0
63AA:  RCALL  60D6
....................         ee_dat=0; 
63AC:  MOVLB  6
63AE:  CLRF   xDD
....................         index=0; 
63B0:  MOVLB  7
63B2:  CLRF   xF3
....................         fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
63B4:  MOVLW  4A
63B6:  MOVWF  FF6
63B8:  MOVLW  1C
63BA:  MOVWF  FF7
63BC:  CLRF   19
63BE:  BTFSC  FF2.7
63C0:  BSF    19.7
63C2:  BCF    FF2.7
63C4:  MOVLB  0
63C6:  CALL   174A
63CA:  BTFSC  19.7
63CC:  BSF    FF2.7
....................         while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................         { 
63CE:  MOVLB  7
63D0:  MOVF   xF3,W
63D2:  SUBLW  4E
63D4:  BNC   6432
63D6:  MOVLB  6
63D8:  MOVF   xDD,W
63DA:  SUBLW  3F
63DC:  BTFSS  FD8.2
63DE:  BRA    63E4
63E0:  MOVLB  7
63E2:  BRA    6432
....................            ee_dat = rec[index+5]; 
63E4:  MOVLW  05
63E6:  MOVLB  7
63E8:  ADDWF  xF3,W
63EA:  CLRF   03
63EC:  ADDLW  7D
63EE:  MOVWF  FE9
63F0:  MOVLW  00
63F2:  ADDWFC 03,W
63F4:  MOVWF  FEA
63F6:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
63FA:  MOVLB  6
63FC:  MOVF   xDD,W
63FE:  SUBLW  1F
6400:  BC    641E
6402:  MOVF   xDD,W
6404:  SUBLW  7E
6406:  BNC   641E
6408:  CLRF   19
640A:  BTFSC  FF2.7
640C:  BSF    19.7
640E:  BCF    FF2.7
6410:  MOVFF  6DD,90C
6414:  MOVLB  0
6416:  CALL   1620
641A:  BTFSC  19.7
641C:  BSF    FF2.7
....................            index++; 
641E:  MOVLB  7
6420:  INCF   xF3,F
....................            if(ee_dat==0)break; 
6422:  MOVLB  6
6424:  MOVF   xDD,F
6426:  BNZ   642C
6428:  MOVLB  7
642A:  BRA    6432
....................         } 
642C:  MOVLB  0
642E:  BRA    63CE
6430:  MOVLB  7
....................         fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
6432:  MOVLW  5C
6434:  MOVWF  FF6
6436:  MOVLW  1C
6438:  MOVWF  FF7
643A:  CLRF   19
643C:  BTFSC  FF2.7
643E:  BSF    19.7
6440:  BCF    FF2.7
6442:  MOVLB  0
6444:  CALL   174A
6448:  BTFSC  19.7
644A:  BSF    FF2.7
....................         index=0; 
644C:  MOVLB  7
644E:  CLRF   xF3
....................         ee_dat=0; 
6450:  MOVLB  6
6452:  CLRF   xDD
....................         while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................         { 
6454:  MOVLB  7
6456:  MOVF   xF3,W
6458:  SUBLW  27
645A:  BNC   64BA
645C:  MOVLB  6
645E:  MOVF   xDD,W
6460:  SUBLW  3F
6462:  BTFSS  FD8.2
6464:  BRA    646A
6466:  MOVLB  7
6468:  BRA    64BA
....................            ee_dat = rec[index+5+numbyteoftrack1]; 
646A:  MOVLW  05
646C:  MOVLB  7
646E:  ADDWF  xF3,W
6470:  ADDLW  4F
6472:  CLRF   03
6474:  ADDLW  7D
6476:  MOVWF  FE9
6478:  MOVLW  00
647A:  ADDWFC 03,W
647C:  MOVWF  FEA
647E:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
6482:  MOVLB  6
6484:  MOVF   xDD,W
6486:  SUBLW  1F
6488:  BC    64A6
648A:  MOVF   xDD,W
648C:  SUBLW  7E
648E:  BNC   64A6
6490:  CLRF   19
6492:  BTFSC  FF2.7
6494:  BSF    19.7
6496:  BCF    FF2.7
6498:  MOVFF  6DD,90C
649C:  MOVLB  0
649E:  CALL   1620
64A2:  BTFSC  19.7
64A4:  BSF    FF2.7
....................            index++; 
64A6:  MOVLB  7
64A8:  INCF   xF3,F
....................            if(ee_dat==0)break; 
64AA:  MOVLB  6
64AC:  MOVF   xDD,F
64AE:  BNZ   64B6
64B0:  MOVLB  7
64B2:  BRA    64BA
64B4:  MOVLB  6
....................         } 
64B6:  BRA    6454
64B8:  MOVLB  7
....................         index=0; 
64BA:  CLRF   xF3
....................  
....................         fprintf(COM2,"\r\nPIN Number:\r\n"); 
64BC:  MOVLW  6E
64BE:  MOVWF  FF6
64C0:  MOVLW  1C
64C2:  MOVWF  FF7
64C4:  CLRF   19
64C6:  BTFSC  FF2.7
64C8:  BSF    19.7
64CA:  BCF    FF2.7
64CC:  MOVLB  0
64CE:  CALL   174A
64D2:  BTFSC  19.7
64D4:  BSF    FF2.7
....................  
....................         if((ptr_card_key>addr_key)) //&& 
64D6:  MOVLB  6
64D8:  MOVF   xE6,W
64DA:  SUBWF  27,W
64DC:  BTFSS  FD8.0
64DE:  BRA    65E2
64E0:  BNZ   64FE
64E2:  MOVF   xE5,W
64E4:  SUBWF  26,W
64E6:  BTFSS  FD8.0
64E8:  BRA    65E2
64EA:  BNZ   64FE
64EC:  MOVF   xE4,W
64EE:  SUBWF  25,W
64F0:  BTFSS  FD8.0
64F2:  BRA    65E2
64F4:  BNZ   64FE
64F6:  MOVF   24,W
64F8:  SUBWF  xE3,W
64FA:  BTFSC  FD8.0
64FC:  BRA    65E2
....................         { 
....................            i=0; 
64FE:  MOVLB  7
6500:  CLRF   xF4
....................            do 
....................            { 
....................               ee_dat=read_ext_eeprom(i+addr_key); 
6502:  MOVF   xF4,W
6504:  MOVLB  6
6506:  ADDWF  xE3,W
6508:  MOVLB  8
650A:  MOVWF  x2B
650C:  MOVLW  00
650E:  MOVLB  6
6510:  ADDWFC xE4,W
6512:  MOVLB  8
6514:  MOVWF  x2C
6516:  MOVLW  00
6518:  MOVLB  6
651A:  ADDWFC xE5,W
651C:  MOVLB  8
651E:  MOVWF  x2D
6520:  MOVLW  00
6522:  MOVLB  6
6524:  ADDWFC xE6,W
6526:  MOVLB  8
6528:  MOVWF  x2E
652A:  CLRF   19
652C:  BTFSC  FF2.7
652E:  BSF    19.7
6530:  BCF    FF2.7
6532:  MOVFF  FE8,91B
6536:  MOVFF  82D,91A
653A:  MOVFF  82C,919
653E:  MOVFF  82B,918
6542:  MOVLB  0
6544:  CALL   3468
6548:  BTFSC  19.7
654A:  BSF    FF2.7
654C:  MOVFF  01,6DD
....................               if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
6550:  MOVLB  6
6552:  MOVF   xDD,W
6554:  SUBLW  2F
6556:  BC    655E
6558:  MOVF   xDD,W
655A:  SUBLW  39
655C:  BC    6576
655E:  MOVF   xDD,W
6560:  SUBLW  23
6562:  BZ    6576
6564:  MOVF   xDD,W
6566:  SUBLW  2A
6568:  BZ    6576
656A:  MOVF   xDD,W
656C:  SUBLW  40
656E:  BC    658C
6570:  MOVF   xDD,W
6572:  SUBLW  5A
6574:  BNC   658C
6576:  CLRF   19
6578:  BTFSC  FF2.7
657A:  BSF    19.7
657C:  BCF    FF2.7
....................               { 
....................                  fprintf(COM2,"%c",ee_dat); 
657E:  MOVFF  6DD,90C
6582:  MOVLB  0
6584:  CALL   1620
6588:  BTFSC  19.7
658A:  BSF    FF2.7
....................               } 
....................               i++; 
658C:  MOVLB  7
658E:  INCF   xF4,F
....................            } 
....................            while((i<wideofkeystore)&&(ee_dat!=0)); 
6590:  MOVF   xF4,W
6592:  SUBLW  0F
6594:  BNC   65A2
6596:  MOVLB  6
6598:  MOVF   xDD,F
659A:  BTFSC  FD8.2
659C:  BRA    65A2
659E:  MOVLB  7
65A0:  BRA    6502
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
65A2:  MOVLW  10
65A4:  MOVLB  6
65A6:  ADDWF  xE3,F
65A8:  MOVLW  00
65AA:  ADDWFC xE4,F
65AC:  ADDWFC xE5,F
65AE:  ADDWFC xE6,F
65B0:  CLRF   19
65B2:  BTFSC  FF2.7
65B4:  BSF    19.7
65B6:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
65B8:  MOVLW  0A
65BA:  MOVLB  9
65BC:  MOVWF  x0C
65BE:  MOVLB  0
65C0:  CALL   1620
65C4:  BTFSC  19.7
65C6:  BSF    FF2.7
65C8:  CLRF   19
65CA:  BTFSC  FF2.7
65CC:  BSF    19.7
65CE:  BCF    FF2.7
65D0:  MOVLW  0D
65D2:  MOVLB  9
65D4:  MOVWF  x0C
65D6:  MOVLB  0
65D8:  CALL   1620
65DC:  BTFSC  19.7
65DE:  BSF    FF2.7
65E0:  MOVLB  6
....................         } 
....................         count_card++; 
65E2:  INCF   xDE,F
65E4:  BTFSC  FD8.2
65E6:  INCF   xDF,F
....................     }  
65E8:  BRA    624A
.................... } 
65EA:  MOVLB  0
65EC:  GOTO   6AF0 (RETURN)
.................... //================================ 
.................... void downloaddataEncrypt() 
.................... { 
65F0:  MOVLB  7
65F2:  CLRF   xF5
65F4:  CLRF   xF4
65F6:  CLRF   19
65F8:  BTFSC  FF2.7
65FA:  BSF    19.7
65FC:  BCF    FF2.7
....................     int8 i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 keydatatemp[16]; 
....................     count_card_tg=get_countcard(); 
65FE:  MOVLB  0
6600:  CALL   3534
6604:  BTFSC  19.7
6606:  BSF    FF2.7
6608:  MOVFF  02,6E1
660C:  MOVFF  01,6E0
....................     adr=count_card*numdataofonecard; 
6610:  MOVLB  6
6612:  RLCF   xDE,W
6614:  MOVLB  7
6616:  MOVWF  xF4
6618:  MOVLB  6
661A:  RLCF   xDF,W
661C:  MOVLB  7
661E:  MOVWF  xF5
6620:  RLCF   xF4,F
6622:  RLCF   xF5,F
6624:  RLCF   xF4,F
6626:  RLCF   xF5,F
6628:  RLCF   xF4,F
662A:  RLCF   xF5,F
662C:  RLCF   xF4,F
662E:  RLCF   xF5,F
6630:  RLCF   xF4,F
6632:  RLCF   xF5,F
6634:  RLCF   xF4,F
6636:  RLCF   xF5,F
6638:  MOVLW  80
663A:  ANDWF  xF4,F
....................     addr_key=EEPROM_KEY_ST; 
663C:  MOVLB  6
663E:  CLRF   xE6
6640:  CLRF   xE5
6642:  MOVLW  E1
6644:  MOVWF  xE4
6646:  MOVLW  01
6648:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
664A:  MOVF   xDF,W
664C:  SUBWF  xE1,W
664E:  BTFSS  FD8.0
6650:  BRA    6808
6652:  BNZ   665C
6654:  MOVF   xDE,W
6656:  SUBWF  xE0,W
6658:  BTFSS  FD8.0
665A:  BRA    6808
....................         adr=count_card*numdataofonecard+ptr_start; 
665C:  RLCF   xDE,W
665E:  MOVLB  8
6660:  MOVWF  x08
6662:  MOVLB  6
6664:  RLCF   xDF,W
6666:  MOVLB  8
6668:  MOVWF  x09
666A:  RLCF   x08,F
666C:  RLCF   x09,F
666E:  RLCF   x08,F
6670:  RLCF   x09,F
6672:  RLCF   x08,F
6674:  RLCF   x09,F
6676:  RLCF   x08,F
6678:  RLCF   x09,F
667A:  RLCF   x08,F
667C:  RLCF   x09,F
667E:  RLCF   x08,F
6680:  RLCF   x09,F
6682:  MOVLW  80
6684:  ANDWF  x08,F
6686:  MOVLW  96
6688:  ADDWF  x08,W
668A:  MOVLB  7
668C:  MOVWF  xF4
668E:  MOVLW  00
6690:  MOVLB  8
6692:  ADDWFC x09,W
6694:  MOVLB  7
6696:  MOVWF  xF5
....................         memset(rec,0,sizeof(rec)); 
6698:  CLRF   FEA
669A:  MOVLW  7D
669C:  MOVWF  FE9
669E:  CLRF   00
66A0:  CLRF   02
66A2:  MOVLW  80
66A4:  MOVWF  01
66A6:  MOVLB  0
66A8:  CALL   35AE
....................         EEPROM_read((unsigned int16)(adr-numdataofonecard),numdataofonecard,rec); 
66AC:  MOVLW  80
66AE:  MOVLB  7
66B0:  SUBWF  xF4,W
66B2:  MOVLB  8
66B4:  MOVWF  x08
66B6:  MOVLW  00
66B8:  MOVLB  7
66BA:  SUBWFB xF5,W
66BC:  MOVLB  8
66BE:  MOVWF  x09
66C0:  CLRF   19
66C2:  BTFSC  FF2.7
66C4:  BSF    19.7
66C6:  BCF    FF2.7
66C8:  MOVLB  9
66CA:  CLRF   x07
66CC:  CLRF   x06
66CE:  MOVWF  x05
66D0:  MOVFF  808,904
66D4:  CLRF   x0B
66D6:  CLRF   x0A
66D8:  CLRF   x09
66DA:  MOVLW  80
66DC:  MOVWF  x08
66DE:  CLRF   x0D
66E0:  MOVLW  7D
66E2:  MOVWF  x0C
66E4:  MOVLB  0
66E6:  CALL   4086
66EA:  BTFSC  19.7
66EC:  BSF    FF2.7
....................         for(i=0;i<numdataofonecard;i++) 
66EE:  MOVLB  7
66F0:  CLRF   xF3
66F2:  MOVF   xF3,W
66F4:  SUBLW  7F
66F6:  BNC   672C
....................         { 
....................            fprintf(COM2,"%x",rec[i]);  
66F8:  CLRF   03
66FA:  MOVF   xF3,W
66FC:  ADDLW  7D
66FE:  MOVWF  FE9
6700:  MOVLW  00
6702:  ADDWFC 03,W
6704:  MOVWF  FEA
6706:  MOVFF  FEF,808
670A:  CLRF   19
670C:  BTFSC  FF2.7
670E:  BSF    19.7
6710:  BCF    FF2.7
6712:  MOVFF  808,901
6716:  MOVLW  57
6718:  MOVLB  9
671A:  MOVWF  x02
671C:  MOVLB  0
671E:  CALL   4E80
6722:  BTFSC  19.7
6724:  BSF    FF2.7
....................         } 
6726:  MOVLB  7
6728:  INCF   xF3,F
672A:  BRA    66F2
....................  
....................         if((ptr_card_key>addr_key)) 
672C:  MOVLB  6
672E:  MOVF   xE6,W
6730:  SUBWF  27,W
6732:  BNC   6800
6734:  BNZ   674C
6736:  MOVF   xE5,W
6738:  SUBWF  26,W
673A:  BNC   6800
673C:  BNZ   674C
673E:  MOVF   xE4,W
6740:  SUBWF  25,W
6742:  BNC   6800
6744:  BNZ   674C
6746:  MOVF   24,W
6748:  SUBWF  xE3,W
674A:  BC    6800
674C:  CLRF   19
674E:  BTFSC  FF2.7
6750:  BSF    19.7
6752:  BCF    FF2.7
....................         { 
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            EEPROM_read(addr_key,wideofkeystore,keydatatemp); 
6754:  MOVFF  6E6,907
6758:  MOVFF  6E5,906
675C:  MOVFF  6E4,905
6760:  MOVFF  6E3,904
6764:  MOVLB  9
6766:  CLRF   x0B
6768:  CLRF   x0A
676A:  CLRF   x09
676C:  MOVLW  10
676E:  MOVWF  x08
6770:  MOVLW  07
6772:  MOVWF  x0D
6774:  MOVLW  F8
6776:  MOVWF  x0C
6778:  MOVLB  0
677A:  CALL   4086
677E:  BTFSC  19.7
6780:  BSF    FF2.7
....................            for(i=0;i<wideofkeystore;i++) 
6782:  MOVLB  7
6784:  CLRF   xF3
6786:  MOVF   xF3,W
6788:  SUBLW  0F
678A:  BNC   67C0
....................            { 
....................                fprintf(COM2,"%x",keydatatemp[i]); 
678C:  CLRF   03
678E:  MOVF   xF3,W
6790:  ADDLW  F8
6792:  MOVWF  FE9
6794:  MOVLW  07
6796:  ADDWFC 03,W
6798:  MOVWF  FEA
679A:  MOVFF  FEF,808
679E:  CLRF   19
67A0:  BTFSC  FF2.7
67A2:  BSF    19.7
67A4:  BCF    FF2.7
67A6:  MOVFF  808,901
67AA:  MOVLW  57
67AC:  MOVLB  9
67AE:  MOVWF  x02
67B0:  MOVLB  0
67B2:  CALL   4E80
67B6:  BTFSC  19.7
67B8:  BSF    FF2.7
....................            } 
67BA:  MOVLB  7
67BC:  INCF   xF3,F
67BE:  BRA    6786
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
67C0:  MOVLW  10
67C2:  MOVLB  6
67C4:  ADDWF  xE3,F
67C6:  MOVLW  00
67C8:  ADDWFC xE4,F
67CA:  ADDWFC xE5,F
67CC:  ADDWFC xE6,F
67CE:  CLRF   19
67D0:  BTFSC  FF2.7
67D2:  BSF    19.7
67D4:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
67D6:  MOVLW  0A
67D8:  MOVLB  9
67DA:  MOVWF  x0C
67DC:  MOVLB  0
67DE:  CALL   1620
67E2:  BTFSC  19.7
67E4:  BSF    FF2.7
67E6:  CLRF   19
67E8:  BTFSC  FF2.7
67EA:  BSF    19.7
67EC:  BCF    FF2.7
67EE:  MOVLW  0D
67F0:  MOVLB  9
67F2:  MOVWF  x0C
67F4:  MOVLB  0
67F6:  CALL   1620
67FA:  BTFSC  19.7
67FC:  BSF    FF2.7
67FE:  MOVLB  6
....................         } 
....................         count_card++; 
6800:  INCF   xDE,F
6802:  BTFSC  FD8.2
6804:  INCF   xDF,F
....................     }  
6806:  BRA    664A
.................... } 
6808:  MOVLB  0
680A:  GOTO   6AF0 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int16 countchar; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
6A32:  MOVLW  06
6A34:  MOVWF  FEA
6A36:  MOVLW  E7
6A38:  MOVWF  FE9
6A3A:  GOTO   60A2
6A3E:  CLRF   19
6A40:  BTFSC  FF2.7
6A42:  BSF    19.7
6A44:  BCF    FF2.7
6A46:  MOVLW  3E
6A48:  MOVLB  9
6A4A:  MOVWF  x0C
6A4C:  MOVLB  0
6A4E:  CALL   1620
6A52:  BTFSC  19.7
6A54:  BSF    FF2.7
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
6A56:  MOVLW  01
6A58:  MOVLB  7
6A5A:  MOVWF  xF3
6A5C:  MOVLW  14
6A5E:  MOVWF  xF4
6A60:  MOVLW  01
6A62:  MOVWF  xF6
6A64:  MOVLW  62
6A66:  MOVWF  xF5
6A68:  MOVLB  0
6A6A:  CALL   5ED2
6A6E:  CLRF   19
6A70:  BTFSC  FF2.7
6A72:  BSF    19.7
6A74:  BCF    FF2.7
....................       printf("\n\r"); 
6A76:  MOVLW  0A
6A78:  MOVLB  9
6A7A:  MOVWF  x0C
6A7C:  MOVLB  0
6A7E:  CALL   1620
6A82:  BTFSC  19.7
6A84:  BSF    FF2.7
6A86:  CLRF   19
6A88:  BTFSC  FF2.7
6A8A:  BSF    19.7
6A8C:  BCF    FF2.7
6A8E:  MOVLW  0D
6A90:  MOVLB  9
6A92:  MOVWF  x0C
6A94:  MOVLB  0
6A96:  CALL   1620
6A9A:  BTFSC  19.7
6A9C:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
6A9E:  CLRF   FEA
6AA0:  MOVLW  41
6AA2:  MOVWF  FE9
6AA4:  MOVLW  00
6AA6:  CALL   0356
6AAA:  TBLRD*-
6AAC:  TBLRD*+
6AAE:  MOVF   FF5,W
6AB0:  MOVWF  FEE
6AB2:  IORLW  00
6AB4:  BNZ   6AAC
....................       index=0; 
6AB6:  MOVLB  7
6AB8:  CLRF   xBD
....................       ee_dat=0; 
6ABA:  MOVLB  6
6ABC:  CLRF   xDD
....................       count_card=1; 
6ABE:  CLRF   xDF
6AC0:  MOVLW  01
6AC2:  MOVWF  xDE
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6AC4:  MOVLB  7
6AC6:  MOVWF  xF4
6AC8:  MOVLW  62
6ACA:  MOVWF  xF3
6ACC:  CLRF   xF6
6ACE:  MOVLW  41
6AD0:  MOVWF  xF5
6AD2:  MOVLB  0
6AD4:  CALL   600A
6AD8:  MOVF   01,F
6ADA:  BNZ   6AF0
....................       { 
....................          if(cryption_enable==0) downloaddataregular(); 
6ADC:  MOVLB  1
6ADE:  MOVF   x22,F
6AE0:  BNZ   6AEC
6AE2:  MOVLB  0
6AE4:  GOTO   61F0
....................          else downloaddataEncrypt(); 
6AE8:  MOVLB  0
6AEA:  BRA    6AF0
6AEC:  MOVLB  0
6AEE:  BRA    65F0
....................       }  
....................       strcpy(buffer2,"f"); 
6AF0:  CLRF   FEA
6AF2:  MOVLW  41
6AF4:  MOVWF  FE9
6AF6:  MOVLW  00
6AF8:  CALL   0368
6AFC:  TBLRD*-
6AFE:  TBLRD*+
6B00:  MOVF   FF5,W
6B02:  MOVWF  FEE
6B04:  IORLW  00
6B06:  BNZ   6AFE
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6B08:  MOVLW  01
6B0A:  MOVLB  7
6B0C:  MOVWF  xF4
6B0E:  MOVLW  62
6B10:  MOVWF  xF3
6B12:  CLRF   xF6
6B14:  MOVLW  41
6B16:  MOVWF  xF5
6B18:  MOVLB  0
6B1A:  CALL   600A
6B1E:  MOVF   01,F
6B20:  BNZ   6B54
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6B22:  MOVLW  7E
6B24:  MOVWF  FF6
6B26:  MOVLW  1C
6B28:  MOVWF  FF7
6B2A:  CLRF   19
6B2C:  BTFSC  FF2.7
6B2E:  BSF    19.7
6B30:  BCF    FF2.7
6B32:  CALL   174A
6B36:  BTFSC  19.7
6B38:  BSF    FF2.7
....................          format_eepromext(); 
6B3A:  BRA    680E
....................          fprintf(COM2," exit\n\r");  
6B3C:  MOVLW  8C
6B3E:  MOVWF  FF6
6B40:  MOVLW  1C
6B42:  MOVWF  FF7
6B44:  CLRF   19
6B46:  BTFSC  FF2.7
6B48:  BSF    19.7
6B4A:  BCF    FF2.7
6B4C:  CALL   174A
6B50:  BTFSC  19.7
6B52:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
6B54:  CLRF   FEA
6B56:  MOVLW  41
6B58:  MOVWF  FE9
6B5A:  MOVLW  00
6B5C:  CALL   037A
6B60:  TBLRD*-
6B62:  TBLRD*+
6B64:  MOVF   FF5,W
6B66:  MOVWF  FEE
6B68:  IORLW  00
6B6A:  BNZ   6B62
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6B6C:  MOVLW  01
6B6E:  MOVLB  7
6B70:  MOVWF  xF4
6B72:  MOVLW  62
6B74:  MOVWF  xF3
6B76:  CLRF   xF6
6B78:  MOVLW  41
6B7A:  MOVWF  xF5
6B7C:  MOVLB  0
6B7E:  CALL   600A
6B82:  MOVF   01,F
6B84:  BNZ   6BB8
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6B86:  MOVLW  94
6B88:  MOVWF  FF6
6B8A:  MOVLW  1C
6B8C:  MOVWF  FF7
6B8E:  CLRF   19
6B90:  BTFSC  FF2.7
6B92:  BSF    19.7
6B94:  BCF    FF2.7
6B96:  CALL   174A
6B9A:  BTFSC  19.7
6B9C:  BSF    FF2.7
....................          ease_eeprom(); 
6B9E:  BRA    68A8
....................          fprintf(COM2," exit\n\r");  
6BA0:  MOVLW  A2
6BA2:  MOVWF  FF6
6BA4:  MOVLW  1C
6BA6:  MOVWF  FF7
6BA8:  CLRF   19
6BAA:  BTFSC  FF2.7
6BAC:  BSF    19.7
6BAE:  BCF    FF2.7
6BB0:  CALL   174A
6BB4:  BTFSC  19.7
6BB6:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6BB8:  CLRF   FEA
6BBA:  MOVLW  41
6BBC:  MOVWF  FE9
6BBE:  MOVLW  00
6BC0:  CALL   0390
6BC4:  TBLRD*-
6BC6:  TBLRD*+
6BC8:  MOVF   FF5,W
6BCA:  MOVWF  FEE
6BCC:  IORLW  00
6BCE:  BNZ   6BC6
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6BD0:  MOVLW  01
6BD2:  MOVLB  7
6BD4:  MOVWF  xF4
6BD6:  MOVLW  62
6BD8:  MOVWF  xF3
6BDA:  CLRF   xF6
6BDC:  MOVLW  41
6BDE:  MOVWF  xF5
6BE0:  MOVLB  0
6BE2:  CALL   600A
6BE6:  MOVF   01,F
6BE8:  BNZ   6C20
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
6BEA:  MOVLW  AA
6BEC:  MOVWF  FF6
6BEE:  MOVLW  1C
6BF0:  MOVWF  FF7
6BF2:  CLRF   19
6BF4:  BTFSC  FF2.7
6BF6:  BSF    19.7
6BF8:  BCF    FF2.7
6BFA:  CALL   174A
6BFE:  BTFSC  19.7
6C00:  BSF    FF2.7
....................          reset_password(); 
6C02:  BRA    692A
....................          init_password(); 
6C04:  CALL   5C72
....................          fprintf(COM2," exit\n\r");  
6C08:  MOVLW  C0
6C0A:  MOVWF  FF6
6C0C:  MOVLW  1C
6C0E:  MOVWF  FF7
6C10:  CLRF   19
6C12:  BTFSC  FF2.7
6C14:  BSF    19.7
6C16:  BCF    FF2.7
6C18:  CALL   174A
6C1C:  BTFSC  19.7
6C1E:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
6C20:  CLRF   FEA
6C22:  MOVLW  41
6C24:  MOVWF  FE9
6C26:  MOVLW  00
6C28:  CALL   03A6
6C2C:  TBLRD*-
6C2E:  TBLRD*+
6C30:  MOVF   FF5,W
6C32:  MOVWF  FEE
6C34:  IORLW  00
6C36:  BNZ   6C2E
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6C38:  MOVLW  01
6C3A:  MOVLB  7
6C3C:  MOVWF  xF4
6C3E:  MOVLW  62
6C40:  MOVWF  xF3
6C42:  CLRF   xF6
6C44:  MOVLW  41
6C46:  MOVWF  xF5
6C48:  MOVLB  0
6C4A:  CALL   600A
6C4E:  MOVF   01,F
6C50:  BNZ   6C72
....................       { 
....................          keydebug_en=1; 
6C52:  MOVLW  01
6C54:  MOVLB  1
6C56:  MOVWF  x44
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
6C58:  MOVLW  C8
6C5A:  MOVWF  FF6
6C5C:  MOVLW  1C
6C5E:  MOVWF  FF7
6C60:  CLRF   19
6C62:  BTFSC  FF2.7
6C64:  BSF    19.7
6C66:  BCF    FF2.7
6C68:  MOVLB  0
6C6A:  CALL   174A
6C6E:  BTFSC  19.7
6C70:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
6C72:  CLRF   FEA
6C74:  MOVLW  41
6C76:  MOVWF  FE9
6C78:  MOVLW  00
6C7A:  CALL   03BC
6C7E:  TBLRD*-
6C80:  TBLRD*+
6C82:  MOVF   FF5,W
6C84:  MOVWF  FEE
6C86:  IORLW  00
6C88:  BNZ   6C80
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6C8A:  MOVLW  01
6C8C:  MOVLB  7
6C8E:  MOVWF  xF4
6C90:  MOVLW  62
6C92:  MOVWF  xF3
6C94:  CLRF   xF6
6C96:  MOVLW  41
6C98:  MOVWF  xF5
6C9A:  MOVLB  0
6C9C:  CALL   600A
6CA0:  MOVF   01,F
6CA2:  BNZ   6CBE
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6CA4:  MOVLW  DC
6CA6:  MOVWF  FF6
6CA8:  MOVLW  1C
6CAA:  MOVWF  FF7
6CAC:  CLRF   19
6CAE:  BTFSC  FF2.7
6CB0:  BSF    19.7
6CB2:  BCF    FF2.7
6CB4:  CALL   174A
6CB8:  BTFSC  19.7
6CBA:  BSF    FF2.7
....................          rstfact(); 
6CBC:  BRA    697A
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
6CBE:  CLRF   FEA
6CC0:  MOVLW  41
6CC2:  MOVWF  FE9
6CC4:  MOVLW  00
6CC6:  CALL   03D4
6CCA:  TBLRD*-
6CCC:  TBLRD*+
6CCE:  MOVF   FF5,W
6CD0:  MOVWF  FEE
6CD2:  IORLW  00
6CD4:  BNZ   6CCC
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6CD6:  MOVLW  01
6CD8:  MOVLB  7
6CDA:  MOVWF  xF4
6CDC:  MOVLW  62
6CDE:  MOVWF  xF3
6CE0:  CLRF   xF6
6CE2:  MOVLW  41
6CE4:  MOVWF  xF5
6CE6:  MOVLB  0
6CE8:  CALL   600A
6CEC:  MOVF   01,F
6CEE:  BNZ   6D16
....................       { 
....................          mode=LOGOFF; 
6CF0:  MOVLB  6
6CF2:  CLRF   xDC
....................          keydebug_en=0; 
6CF4:  MOVLB  1
6CF6:  CLRF   x44
....................          set_tris_a(0xff); 
6CF8:  MOVLW  FF
6CFA:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
6CFC:  MOVLW  EC
6CFE:  MOVWF  FF6
6D00:  MOVLW  1C
6D02:  MOVWF  FF7
6D04:  CLRF   19
6D06:  BTFSC  FF2.7
6D08:  BSF    19.7
6D0A:  BCF    FF2.7
6D0C:  MOVLB  0
6D0E:  CALL   174A
6D12:  BTFSC  19.7
6D14:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
6D16:  CLRF   FEA
6D18:  MOVLW  41
6D1A:  MOVWF  FE9
6D1C:  MOVLW  00
6D1E:  CALL   03E6
6D22:  TBLRD*-
6D24:  TBLRD*+
6D26:  MOVF   FF5,W
6D28:  MOVWF  FEE
6D2A:  IORLW  00
6D2C:  BNZ   6D24
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6D2E:  MOVLW  01
6D30:  MOVLB  7
6D32:  MOVWF  xF4
6D34:  MOVLW  62
6D36:  MOVWF  xF3
6D38:  CLRF   xF6
6D3A:  MOVLW  41
6D3C:  MOVWF  xF5
6D3E:  MOVLB  0
6D40:  CALL   600A
6D44:  MOVF   01,F
6D46:  BNZ   6DC0
....................       { 
....................          fprintf(COM2,"New console name>"); 
6D48:  MOVLW  F4
6D4A:  MOVWF  FF6
6D4C:  MOVLW  1C
6D4E:  MOVWF  FF7
6D50:  CLRF   19
6D52:  BTFSC  FF2.7
6D54:  BSF    19.7
6D56:  BCF    FF2.7
6D58:  CALL   174A
6D5C:  BTFSC  19.7
6D5E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,wide_strobe_nameconsole, console); 
6D60:  MOVLW  01
6D62:  MOVLB  7
6D64:  MOVWF  xF3
6D66:  MOVLW  10
6D68:  MOVWF  xF4
6D6A:  MOVLW  06
6D6C:  MOVWF  xF6
6D6E:  MOVLW  E7
6D70:  MOVWF  xF5
6D72:  MOVLB  0
6D74:  CALL   5ED2
6D78:  CLRF   19
6D7A:  BTFSC  FF2.7
6D7C:  BSF    19.7
6D7E:  BCF    FF2.7
....................          EEPROM_write(strobe_nameconsole,wide_strobe_nameconsole,console); 
6D80:  MOVLB  9
6D82:  CLRF   x03
6D84:  CLRF   x02
6D86:  CLRF   x01
6D88:  MOVLW  28
6D8A:  MOVWF  x00
6D8C:  CLRF   x07
6D8E:  CLRF   x06
6D90:  CLRF   x05
6D92:  MOVLW  10
6D94:  MOVWF  x04
6D96:  MOVLW  06
6D98:  MOVWF  x09
6D9A:  MOVLW  E7
6D9C:  MOVWF  x08
6D9E:  MOVLB  0
6DA0:  CALL   4DF0
6DA4:  BTFSC  19.7
6DA6:  BSF    FF2.7
....................          fprintf(COM2," OK\n\r"); 
6DA8:  MOVLW  06
6DAA:  MOVWF  FF6
6DAC:  MOVLW  1D
6DAE:  MOVWF  FF7
6DB0:  CLRF   19
6DB2:  BTFSC  FF2.7
6DB4:  BSF    19.7
6DB6:  BCF    FF2.7
6DB8:  CALL   174A
6DBC:  BTFSC  19.7
6DBE:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
6DC0:  CLRF   FEA
6DC2:  MOVLW  41
6DC4:  MOVWF  FE9
6DC6:  MOVLW  00
6DC8:  CALL   03F8
6DCC:  TBLRD*-
6DCE:  TBLRD*+
6DD0:  MOVF   FF5,W
6DD2:  MOVWF  FEE
6DD4:  IORLW  00
6DD6:  BNZ   6DCE
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6DD8:  MOVLW  01
6DDA:  MOVLB  7
6DDC:  MOVWF  xF4
6DDE:  MOVLW  62
6DE0:  MOVWF  xF3
6DE2:  CLRF   xF6
6DE4:  MOVLW  41
6DE6:  MOVWF  xF5
6DE8:  MOVLB  0
6DEA:  CALL   600A
6DEE:  MOVF   01,F
6DF0:  BTFSS  FD8.2
6DF2:  BRA    6FA2
6DF4:  CLRF   19
6DF6:  BTFSC  FF2.7
6DF8:  BSF    19.7
6DFA:  BCF    FF2.7
....................       { 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6DFC:  MOVLB  9
6DFE:  CLRF   x1B
6E00:  CLRF   x1A
6E02:  CLRF   x19
6E04:  MOVLW  3A
6E06:  MOVWF  x18
6E08:  MOVLB  0
6E0A:  CALL   3468
6E0E:  BTFSC  19.7
6E10:  BSF    FF2.7
6E12:  MOVFF  01,6E2
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6E16:  MOVLB  6
6E18:  MOVF   xE2,F
6E1A:  BNZ   6E3A
6E1C:  MOVLW  0C
6E1E:  MOVWF  FF6
6E20:  MOVLW  1D
6E22:  MOVWF  FF7
6E24:  CLRF   19
6E26:  BTFSC  FF2.7
6E28:  BSF    19.7
6E2A:  BCF    FF2.7
6E2C:  MOVLB  0
6E2E:  CALL   174A
6E32:  BTFSC  19.7
6E34:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6E36:  BRA    6E54
6E38:  MOVLB  6
6E3A:  MOVLW  10
6E3C:  MOVWF  FF6
6E3E:  MOVLW  1D
6E40:  MOVWF  FF7
6E42:  CLRF   19
6E44:  BTFSC  FF2.7
6E46:  BSF    19.7
6E48:  BCF    FF2.7
6E4A:  MOVLB  0
6E4C:  CALL   174A
6E50:  BTFSC  19.7
6E52:  BSF    FF2.7
6E54:  CLRF   19
6E56:  BTFSC  FF2.7
6E58:  BSF    19.7
6E5A:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
6E5C:  MOVLB  9
6E5E:  CLRF   x1B
6E60:  CLRF   x1A
6E62:  CLRF   x19
6E64:  MOVLW  3C
6E66:  MOVWF  x18
6E68:  MOVLB  0
6E6A:  CALL   3468
6E6E:  BTFSC  19.7
6E70:  BSF    FF2.7
6E72:  MOVFF  01,15A
6E76:  CLRF   19
6E78:  BTFSC  FF2.7
6E7A:  BSF    19.7
6E7C:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
6E7E:  MOVLW  5B
6E80:  MOVLB  9
6E82:  MOVWF  x0C
6E84:  MOVLB  0
6E86:  CALL   1620
6E8A:  BTFSC  19.7
6E8C:  BSF    FF2.7
6E8E:  CLRF   19
6E90:  BTFSC  FF2.7
6E92:  BSF    19.7
6E94:  BCF    FF2.7
6E96:  MOVFF  15A,900
6E9A:  MOVLW  1B
6E9C:  MOVLB  9
6E9E:  MOVWF  x01
6EA0:  MOVLB  0
6EA2:  CALL   4000
6EA6:  BTFSC  19.7
6EA8:  BSF    FF2.7
6EAA:  CLRF   19
6EAC:  BTFSC  FF2.7
6EAE:  BSF    19.7
6EB0:  BCF    FF2.7
6EB2:  MOVLW  5D
6EB4:  MOVLB  9
6EB6:  MOVWF  x0C
6EB8:  MOVLB  0
6EBA:  CALL   1620
6EBE:  BTFSC  19.7
6EC0:  BSF    FF2.7
....................           
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
6EC2:  MOVFF  1CB,82B
6EC6:  MOVLW  01
6EC8:  MOVLB  8
6ECA:  MOVWF  x2C
6ECC:  MOVLB  0
6ECE:  CALL   60D6
6ED2:  CLRF   19
6ED4:  BTFSC  FF2.7
6ED6:  BSF    19.7
6ED8:  BCF    FF2.7
6EDA:  MOVLW  2F
6EDC:  MOVLB  9
6EDE:  MOVWF  x0C
6EE0:  MOVLB  0
6EE2:  CALL   1620
6EE6:  BTFSC  19.7
6EE8:  BSF    FF2.7
6EEA:  MOVFF  1CA,82B
6EEE:  MOVLW  01
6EF0:  MOVLB  8
6EF2:  MOVWF  x2C
6EF4:  MOVLB  0
6EF6:  CALL   60D6
6EFA:  CLRF   19
6EFC:  BTFSC  FF2.7
6EFE:  BSF    19.7
6F00:  BCF    FF2.7
6F02:  MOVLW  20
6F04:  MOVLB  9
6F06:  MOVWF  x0C
6F08:  MOVLB  0
6F0A:  CALL   1620
6F0E:  BTFSC  19.7
6F10:  BSF    FF2.7
6F12:  MOVFF  1CC,82B
6F16:  MOVLW  01
6F18:  MOVLB  8
6F1A:  MOVWF  x2C
6F1C:  MOVLB  0
6F1E:  CALL   60D6
6F22:  CLRF   19
6F24:  BTFSC  FF2.7
6F26:  BSF    19.7
6F28:  BCF    FF2.7
6F2A:  MOVLW  3A
6F2C:  MOVLB  9
6F2E:  MOVWF  x0C
6F30:  MOVLB  0
6F32:  CALL   1620
6F36:  BTFSC  19.7
6F38:  BSF    FF2.7
6F3A:  MOVFF  1CD,82B
6F3E:  MOVLW  01
6F40:  MOVLB  8
6F42:  MOVWF  x2C
6F44:  MOVLB  0
6F46:  CALL   60D6
6F4A:  CLRF   19
6F4C:  BTFSC  FF2.7
6F4E:  BSF    19.7
6F50:  BCF    FF2.7
6F52:  MOVLW  3A
6F54:  MOVLB  9
6F56:  MOVWF  x0C
6F58:  MOVLB  0
6F5A:  CALL   1620
6F5E:  BTFSC  19.7
6F60:  BSF    FF2.7
6F62:  MOVFF  1CE,82B
6F66:  MOVLW  01
6F68:  MOVLB  8
6F6A:  MOVWF  x2C
6F6C:  MOVLB  0
6F6E:  CALL   60D6
6F72:  CLRF   19
6F74:  BTFSC  FF2.7
6F76:  BSF    19.7
6F78:  BCF    FF2.7
....................           
....................          fprintf(COM2,"\n\r"); 
6F7A:  MOVLW  0A
6F7C:  MOVLB  9
6F7E:  MOVWF  x0C
6F80:  MOVLB  0
6F82:  CALL   1620
6F86:  BTFSC  19.7
6F88:  BSF    FF2.7
6F8A:  CLRF   19
6F8C:  BTFSC  FF2.7
6F8E:  BSF    19.7
6F90:  BCF    FF2.7
6F92:  MOVLW  0D
6F94:  MOVLB  9
6F96:  MOVWF  x0C
6F98:  MOVLB  0
6F9A:  CALL   1620
6F9E:  BTFSC  19.7
6FA0:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
6FA2:  CLRF   FEA
6FA4:  MOVLW  41
6FA6:  MOVWF  FE9
6FA8:  MOVLW  00
6FAA:  CALL   040A
6FAE:  TBLRD*-
6FB0:  TBLRD*+
6FB2:  MOVF   FF5,W
6FB4:  MOVWF  FEE
6FB6:  IORLW  00
6FB8:  BNZ   6FB0
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
6FBA:  MOVLW  01
6FBC:  MOVLB  7
6FBE:  MOVWF  xF4
6FC0:  MOVLW  62
6FC2:  MOVWF  xF3
6FC4:  CLRF   xF6
6FC6:  MOVLW  41
6FC8:  MOVWF  xF5
6FCA:  MOVLB  0
6FCC:  CALL   600A
6FD0:  MOVF   01,F
6FD2:  BTFSS  FD8.2
6FD4:  BRA    71D4
....................       { 
....................          fprintf(COM2,"Year>"); 
6FD6:  MOVLW  14
6FD8:  MOVWF  FF6
6FDA:  MOVLW  1D
6FDC:  MOVWF  FF7
6FDE:  CLRF   19
6FE0:  BTFSC  FF2.7
6FE2:  BSF    19.7
6FE4:  BCF    FF2.7
6FE6:  CALL   174A
6FEA:  BTFSC  19.7
6FEC:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6FEE:  MOVLW  01
6FF0:  MOVLB  7
6FF2:  MOVWF  xF3
6FF4:  MOVLW  03
6FF6:  MOVWF  xF4
6FF8:  MOVLW  07
6FFA:  MOVWF  xF6
6FFC:  MOVLW  C1
6FFE:  MOVWF  xF5
7000:  MOVLB  0
7002:  CALL   5ED2
....................          year=(unsigned int8)strtoi(temp); 
7006:  MOVLW  07
7008:  MOVLB  7
700A:  MOVWF  xF4
700C:  MOVLW  C1
700E:  MOVWF  xF3
7010:  MOVLB  0
7012:  RCALL  69E4
7014:  MOVFF  01,1C9
....................          fprintf(COM2,"Month>"); 
7018:  MOVLW  1A
701A:  MOVWF  FF6
701C:  MOVLW  1D
701E:  MOVWF  FF7
7020:  CLRF   19
7022:  BTFSC  FF2.7
7024:  BSF    19.7
7026:  BCF    FF2.7
7028:  CALL   174A
702C:  BTFSC  19.7
702E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7030:  MOVLW  01
7032:  MOVLB  7
7034:  MOVWF  xF3
7036:  MOVLW  03
7038:  MOVWF  xF4
703A:  MOVLW  07
703C:  MOVWF  xF6
703E:  MOVLW  C1
7040:  MOVWF  xF5
7042:  MOVLB  0
7044:  CALL   5ED2
....................          mon=(unsigned int8)strtoi(temp); 
7048:  MOVLW  07
704A:  MOVLB  7
704C:  MOVWF  xF4
704E:  MOVLW  C1
7050:  MOVWF  xF3
7052:  MOVLB  0
7054:  RCALL  69E4
7056:  MOVFF  01,1CA
....................          fprintf(COM2,"Date>"); 
705A:  MOVLW  22
705C:  MOVWF  FF6
705E:  MOVLW  1D
7060:  MOVWF  FF7
7062:  CLRF   19
7064:  BTFSC  FF2.7
7066:  BSF    19.7
7068:  BCF    FF2.7
706A:  CALL   174A
706E:  BTFSC  19.7
7070:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7072:  MOVLW  01
7074:  MOVLB  7
7076:  MOVWF  xF3
7078:  MOVLW  03
707A:  MOVWF  xF4
707C:  MOVLW  07
707E:  MOVWF  xF6
7080:  MOVLW  C1
7082:  MOVWF  xF5
7084:  MOVLB  0
7086:  CALL   5ED2
....................          date = (unsigned int8)strtoi(temp); 
708A:  MOVLW  07
708C:  MOVLB  7
708E:  MOVWF  xF4
7090:  MOVLW  C1
7092:  MOVWF  xF3
7094:  MOVLB  0
7096:  RCALL  69E4
7098:  MOVFF  01,1CB
....................          fprintf(COM2,"Day>"); 
709C:  MOVLW  28
709E:  MOVWF  FF6
70A0:  MOVLW  1D
70A2:  MOVWF  FF7
70A4:  CLRF   19
70A6:  BTFSC  FF2.7
70A8:  BSF    19.7
70AA:  BCF    FF2.7
70AC:  CALL   174A
70B0:  BTFSC  19.7
70B2:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
70B4:  MOVLW  01
70B6:  MOVLB  7
70B8:  MOVWF  xF3
70BA:  MOVLW  03
70BC:  MOVWF  xF4
70BE:  MOVLW  07
70C0:  MOVWF  xF6
70C2:  MOVLW  C1
70C4:  MOVWF  xF5
70C6:  MOVLB  0
70C8:  CALL   5ED2
....................          day = (unsigned int8)strtoi(temp); 
70CC:  MOVLW  07
70CE:  MOVLB  7
70D0:  MOVWF  xF4
70D2:  MOVLW  C1
70D4:  MOVWF  xF3
70D6:  MOVLB  0
70D8:  RCALL  69E4
70DA:  MOVFF  01,1C8
....................          fprintf(COM2,"Hour>"); 
70DE:  MOVLW  2E
70E0:  MOVWF  FF6
70E2:  MOVLW  1D
70E4:  MOVWF  FF7
70E6:  CLRF   19
70E8:  BTFSC  FF2.7
70EA:  BSF    19.7
70EC:  BCF    FF2.7
70EE:  CALL   174A
70F2:  BTFSC  19.7
70F4:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
70F6:  MOVLW  01
70F8:  MOVLB  7
70FA:  MOVWF  xF3
70FC:  MOVLW  03
70FE:  MOVWF  xF4
7100:  MOVLW  07
7102:  MOVWF  xF6
7104:  MOVLW  C1
7106:  MOVWF  xF5
7108:  MOVLB  0
710A:  CALL   5ED2
....................          h = (unsigned int8)strtoi(temp); 
710E:  MOVLW  07
7110:  MOVLB  7
7112:  MOVWF  xF4
7114:  MOVLW  C1
7116:  MOVWF  xF3
7118:  MOVLB  0
711A:  RCALL  69E4
711C:  MOVFF  01,1CC
....................          fprintf(COM2,"Minutes>"); 
7120:  MOVLW  34
7122:  MOVWF  FF6
7124:  MOVLW  1D
7126:  MOVWF  FF7
7128:  CLRF   19
712A:  BTFSC  FF2.7
712C:  BSF    19.7
712E:  BCF    FF2.7
7130:  CALL   174A
7134:  BTFSC  19.7
7136:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7138:  MOVLW  01
713A:  MOVLB  7
713C:  MOVWF  xF3
713E:  MOVLW  03
7140:  MOVWF  xF4
7142:  MOVLW  07
7144:  MOVWF  xF6
7146:  MOVLW  C1
7148:  MOVWF  xF5
714A:  MOVLB  0
714C:  CALL   5ED2
....................          min = (unsigned int8)strtoi(temp);                   
7150:  MOVLW  07
7152:  MOVLB  7
7154:  MOVWF  xF4
7156:  MOVLW  C1
7158:  MOVWF  xF3
715A:  MOVLB  0
715C:  RCALL  69E4
715E:  MOVFF  01,1CD
....................          fprintf(COM2,"Seconds>"); 
7162:  MOVLW  3E
7164:  MOVWF  FF6
7166:  MOVLW  1D
7168:  MOVWF  FF7
716A:  CLRF   19
716C:  BTFSC  FF2.7
716E:  BSF    19.7
7170:  BCF    FF2.7
7172:  CALL   174A
7176:  BTFSC  19.7
7178:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
717A:  MOVLW  01
717C:  MOVLB  7
717E:  MOVWF  xF3
7180:  MOVLW  03
7182:  MOVWF  xF4
7184:  MOVLW  07
7186:  MOVWF  xF6
7188:  MOVLW  C1
718A:  MOVWF  xF5
718C:  MOVLB  0
718E:  CALL   5ED2
....................          sec = (unsigned int8)strtoi(temp);                   
7192:  MOVLW  07
7194:  MOVLB  7
7196:  MOVWF  xF4
7198:  MOVLW  C1
719A:  MOVWF  xF3
719C:  MOVLB  0
719E:  RCALL  69E4
71A0:  MOVFF  01,1CE
71A4:  CLRF   19
71A6:  BTFSC  FF2.7
71A8:  BSF    19.7
71AA:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
71AC:  MOVLW  0A
71AE:  MOVLB  9
71B0:  MOVWF  x0C
71B2:  MOVLB  0
71B4:  CALL   1620
71B8:  BTFSC  19.7
71BA:  BSF    FF2.7
71BC:  CLRF   19
71BE:  BTFSC  FF2.7
71C0:  BSF    19.7
71C2:  BCF    FF2.7
71C4:  MOVLW  0D
71C6:  MOVLB  9
71C8:  MOVWF  x0C
71CA:  MOVLB  0
71CC:  CALL   1620
71D0:  BTFSC  19.7
71D2:  BSF    FF2.7
....................          /* rtc_set_datetime(date,mon,year,day,h,min); */ 
....................       } 
....................       strcpy(buffer2,"MS"); 
71D4:  CLRF   FEA
71D6:  MOVLW  41
71D8:  MOVWF  FE9
71DA:  MOVLW  00
71DC:  CALL   041E
71E0:  TBLRD*-
71E2:  TBLRD*+
71E4:  MOVF   FF5,W
71E6:  MOVWF  FEE
71E8:  IORLW  00
71EA:  BNZ   71E2
....................       if(!stringcomp(buffer_uart,buffer2)) 
71EC:  MOVLW  01
71EE:  MOVLB  7
71F0:  MOVWF  xF4
71F2:  MOVLW  62
71F4:  MOVWF  xF3
71F6:  CLRF   xF6
71F8:  MOVLW  41
71FA:  MOVWF  xF5
71FC:  MOVLB  0
71FE:  CALL   600A
7202:  MOVF   01,F
7204:  BTFSS  FD8.2
7206:  BRA    731A
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
7208:  MOVLW  48
720A:  MOVWF  FF6
720C:  MOVLW  1D
720E:  MOVWF  FF7
7210:  CLRF   19
7212:  BTFSC  FF2.7
7214:  BSF    19.7
7216:  BCF    FF2.7
7218:  CALL   174A
721C:  BTFSC  19.7
721E:  BSF    FF2.7
7220:  CLRF   19
7222:  BTFSC  FF2.7
7224:  BSF    19.7
7226:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7228:  MOVLW  0A
722A:  MOVLB  9
722C:  MOVWF  x0C
722E:  MOVLB  0
7230:  CALL   1620
7234:  BTFSC  19.7
7236:  BSF    FF2.7
7238:  CLRF   19
723A:  BTFSC  FF2.7
723C:  BSF    19.7
723E:  BCF    FF2.7
7240:  MOVLW  0D
7242:  MOVLB  9
7244:  MOVWF  x0C
7246:  MOVLB  0
7248:  CALL   1620
724C:  BTFSC  19.7
724E:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
7250:  MOVLW  68
7252:  MOVWF  FF6
7254:  MOVLW  1D
7256:  MOVWF  FF7
7258:  CLRF   19
725A:  BTFSC  FF2.7
725C:  BSF    19.7
725E:  BCF    FF2.7
7260:  CALL   174A
7264:  BTFSC  19.7
7266:  BSF    FF2.7
7268:  CLRF   19
726A:  BTFSC  FF2.7
726C:  BSF    19.7
726E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7270:  MOVLW  0A
7272:  MOVLB  9
7274:  MOVWF  x0C
7276:  MOVLB  0
7278:  CALL   1620
727C:  BTFSC  19.7
727E:  BSF    FF2.7
7280:  CLRF   19
7282:  BTFSC  FF2.7
7284:  BSF    19.7
7286:  BCF    FF2.7
7288:  MOVLW  0D
728A:  MOVLB  9
728C:  MOVWF  x0C
728E:  MOVLB  0
7290:  CALL   1620
7294:  BTFSC  19.7
7296:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7298:  MOVLW  01
729A:  MOVLB  7
729C:  MOVWF  xF3
729E:  MOVLW  03
72A0:  MOVWF  xF4
72A2:  MOVLW  07
72A4:  MOVWF  xF6
72A6:  MOVLW  C1
72A8:  MOVWF  xF5
72AA:  MOVLB  0
72AC:  CALL   5ED2
....................           mode_sl = (unsigned int8)strtoi(temp); 
72B0:  MOVLW  07
72B2:  MOVLB  7
72B4:  MOVWF  xF4
72B6:  MOVLW  C1
72B8:  MOVWF  xF3
72BA:  MOVLB  0
72BC:  CALL   69E4
72C0:  MOVFF  01,6E2
72C4:  CLRF   19
72C6:  BTFSC  FF2.7
72C8:  BSF    19.7
72CA:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
72CC:  MOVLB  9
72CE:  CLRF   x16
72D0:  CLRF   x15
72D2:  CLRF   x14
72D4:  MOVLW  3A
72D6:  MOVWF  x13
72D8:  MOVFF  6E2,917
72DC:  MOVLB  0
72DE:  CALL   3A80
72E2:  BTFSC  19.7
72E4:  BSF    FF2.7
....................           set_tris_a(0xff); 
72E6:  MOVLW  FF
72E8:  MOVWF  F92
72EA:  CLRF   19
72EC:  BTFSC  FF2.7
72EE:  BSF    19.7
72F0:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
72F2:  MOVLW  0A
72F4:  MOVLB  9
72F6:  MOVWF  x0C
72F8:  MOVLB  0
72FA:  CALL   1620
72FE:  BTFSC  19.7
7300:  BSF    FF2.7
7302:  CLRF   19
7304:  BTFSC  FF2.7
7306:  BSF    19.7
7308:  BCF    FF2.7
730A:  MOVLW  0D
730C:  MOVLB  9
730E:  MOVWF  x0C
7310:  MOVLB  0
7312:  CALL   1620
7316:  BTFSC  19.7
7318:  BSF    FF2.7
....................       } 
....................       
....................       strcpy(buffer2,"tran time"); 
731A:  CLRF   FEA
731C:  MOVLW  41
731E:  MOVWF  FE9
7320:  MOVLW  00
7322:  CALL   0432
7326:  TBLRD*-
7328:  TBLRD*+
732A:  MOVF   FF5,W
732C:  MOVWF  FEE
732E:  IORLW  00
7330:  BNZ   7328
....................       if(!stringcomp(buffer_uart,buffer2)) 
7332:  MOVLW  01
7334:  MOVLB  7
7336:  MOVWF  xF4
7338:  MOVLW  62
733A:  MOVWF  xF3
733C:  CLRF   xF6
733E:  MOVLW  41
7340:  MOVWF  xF5
7342:  MOVLB  0
7344:  CALL   600A
7348:  MOVF   01,F
734A:  BNZ   7412
....................       { 
....................           fprintf(COM2,"Input Number"); 
734C:  MOVLW  88
734E:  MOVWF  FF6
7350:  MOVLW  1D
7352:  MOVWF  FF7
7354:  CLRF   19
7356:  BTFSC  FF2.7
7358:  BSF    19.7
735A:  BCF    FF2.7
735C:  CALL   174A
7360:  BTFSC  19.7
7362:  BSF    FF2.7
7364:  CLRF   19
7366:  BTFSC  FF2.7
7368:  BSF    19.7
736A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
736C:  MOVLW  0A
736E:  MOVLB  9
7370:  MOVWF  x0C
7372:  MOVLB  0
7374:  CALL   1620
7378:  BTFSC  19.7
737A:  BSF    FF2.7
737C:  CLRF   19
737E:  BTFSC  FF2.7
7380:  BSF    19.7
7382:  BCF    FF2.7
7384:  MOVLW  0D
7386:  MOVLB  9
7388:  MOVWF  x0C
738A:  MOVLB  0
738C:  CALL   1620
7390:  BTFSC  19.7
7392:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7394:  MOVLW  01
7396:  MOVLB  7
7398:  MOVWF  xF3
739A:  MOVLW  03
739C:  MOVWF  xF4
739E:  MOVLW  07
73A0:  MOVWF  xF6
73A2:  MOVLW  C1
73A4:  MOVWF  xF5
73A6:  MOVLB  0
73A8:  CALL   5ED2
....................           delaycharaction = (unsigned int8)strtoi(temp); 
73AC:  MOVLW  07
73AE:  MOVLB  7
73B0:  MOVWF  xF4
73B2:  MOVLW  C1
73B4:  MOVWF  xF3
73B6:  MOVLB  0
73B8:  CALL   69E4
73BC:  MOVFF  01,15A
73C0:  CLRF   19
73C2:  BTFSC  FF2.7
73C4:  BSF    19.7
73C6:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
73C8:  MOVLB  9
73CA:  CLRF   x16
73CC:  CLRF   x15
73CE:  CLRF   x14
73D0:  MOVLW  3C
73D2:  MOVWF  x13
73D4:  MOVFF  15A,917
73D8:  MOVLB  0
73DA:  CALL   3A80
73DE:  BTFSC  19.7
73E0:  BSF    FF2.7
73E2:  CLRF   19
73E4:  BTFSC  FF2.7
73E6:  BSF    19.7
73E8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
73EA:  MOVLW  0A
73EC:  MOVLB  9
73EE:  MOVWF  x0C
73F0:  MOVLB  0
73F2:  CALL   1620
73F6:  BTFSC  19.7
73F8:  BSF    FF2.7
73FA:  CLRF   19
73FC:  BTFSC  FF2.7
73FE:  BSF    19.7
7400:  BCF    FF2.7
7402:  MOVLW  0D
7404:  MOVLB  9
7406:  MOVWF  x0C
7408:  MOVLB  0
740A:  CALL   1620
740E:  BTFSC  19.7
7410:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
7412:  CLRF   FEA
7414:  MOVLW  41
7416:  MOVWF  FE9
7418:  MOVLW  00
741A:  CALL   044C
741E:  TBLRD*-
7420:  TBLRD*+
7422:  MOVF   FF5,W
7424:  MOVWF  FEE
7426:  IORLW  00
7428:  BNZ   7420
....................       if(!stringcomp(buffer_uart,buffer2)) 
742A:  MOVLW  01
742C:  MOVLB  7
742E:  MOVWF  xF4
7430:  MOVLW  62
7432:  MOVWF  xF3
7434:  CLRF   xF6
7436:  MOVLW  41
7438:  MOVWF  xF5
743A:  MOVLB  0
743C:  CALL   600A
7440:  MOVF   01,F
7442:  BTFSS  FD8.2
7444:  BRA    7554
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
7446:  MOVLW  96
7448:  MOVWF  FF6
744A:  MOVLW  1D
744C:  MOVWF  FF7
744E:  CLRF   19
7450:  BTFSC  FF2.7
7452:  BSF    19.7
7454:  BCF    FF2.7
7456:  CALL   174A
745A:  BTFSC  19.7
745C:  BSF    FF2.7
745E:  CLRF   19
7460:  BTFSC  FF2.7
7462:  BSF    19.7
7464:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7466:  MOVLW  0A
7468:  MOVLB  9
746A:  MOVWF  x0C
746C:  MOVLB  0
746E:  CALL   1620
7472:  BTFSC  19.7
7474:  BSF    FF2.7
7476:  CLRF   19
7478:  BTFSC  FF2.7
747A:  BSF    19.7
747C:  BCF    FF2.7
747E:  MOVLW  0D
7480:  MOVLB  9
7482:  MOVWF  x0C
7484:  MOVLB  0
7486:  CALL   1620
748A:  BTFSC  19.7
748C:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
748E:  MOVLW  BC
7490:  MOVWF  FF6
7492:  MOVLW  1D
7494:  MOVWF  FF7
7496:  CLRF   19
7498:  BTFSC  FF2.7
749A:  BSF    19.7
749C:  BCF    FF2.7
749E:  CALL   174A
74A2:  BTFSC  19.7
74A4:  BSF    FF2.7
74A6:  CLRF   19
74A8:  BTFSC  FF2.7
74AA:  BSF    19.7
74AC:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
74AE:  MOVLW  0A
74B0:  MOVLB  9
74B2:  MOVWF  x0C
74B4:  MOVLB  0
74B6:  CALL   1620
74BA:  BTFSC  19.7
74BC:  BSF    FF2.7
74BE:  CLRF   19
74C0:  BTFSC  FF2.7
74C2:  BSF    19.7
74C4:  BCF    FF2.7
74C6:  MOVLW  0D
74C8:  MOVLB  9
74CA:  MOVWF  x0C
74CC:  MOVLB  0
74CE:  CALL   1620
74D2:  BTFSC  19.7
74D4:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
74D6:  MOVLW  01
74D8:  MOVLB  7
74DA:  MOVWF  xF3
74DC:  MOVLW  03
74DE:  MOVWF  xF4
74E0:  MOVLW  07
74E2:  MOVWF  xF6
74E4:  MOVLW  C1
74E6:  MOVWF  xF5
74E8:  MOVLB  0
74EA:  CALL   5ED2
....................           type_KB=(unsigned int8)strtoi(temp); 
74EE:  MOVLW  07
74F0:  MOVLB  7
74F2:  MOVWF  xF4
74F4:  MOVLW  C1
74F6:  MOVWF  xF3
74F8:  MOVLB  0
74FA:  CALL   69E4
74FE:  MOVFF  01,149
7502:  CLRF   19
7504:  BTFSC  FF2.7
7506:  BSF    19.7
7508:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
750A:  MOVLB  9
750C:  CLRF   x16
750E:  CLRF   x15
7510:  CLRF   x14
7512:  MOVLW  3D
7514:  MOVWF  x13
7516:  MOVFF  149,917
751A:  MOVLB  0
751C:  CALL   3A80
7520:  BTFSC  19.7
7522:  BSF    FF2.7
7524:  CLRF   19
7526:  BTFSC  FF2.7
7528:  BSF    19.7
752A:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
752C:  MOVLW  0A
752E:  MOVLB  9
7530:  MOVWF  x0C
7532:  MOVLB  0
7534:  CALL   1620
7538:  BTFSC  19.7
753A:  BSF    FF2.7
753C:  CLRF   19
753E:  BTFSC  FF2.7
7540:  BSF    19.7
7542:  BCF    FF2.7
7544:  MOVLW  0D
7546:  MOVLB  9
7548:  MOVWF  x0C
754A:  MOVLB  0
754C:  CALL   1620
7550:  BTFSC  19.7
7552:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       strcpy(buffer2,"h"); 
7554:  CLRF   FEA
7556:  MOVLW  41
7558:  MOVWF  FE9
755A:  MOVLW  00
755C:  CALL   0462
7560:  TBLRD*-
7562:  TBLRD*+
7564:  MOVF   FF5,W
7566:  MOVWF  FEE
7568:  IORLW  00
756A:  BNZ   7562
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
756C:  MOVLW  01
756E:  MOVLB  7
7570:  MOVWF  xF4
7572:  MOVLW  62
7574:  MOVWF  xF3
7576:  CLRF   xF6
7578:  MOVLW  41
757A:  MOVWF  xF5
757C:  MOVLB  0
757E:  CALL   600A
7582:  MOVF   01,F
7584:  BTFSS  FD8.2
7586:  BRA    76F6
....................       { 
....................          printf("h-> Help\n\r"); 
7588:  MOVLW  E2
758A:  MOVWF  FF6
758C:  MOVLW  1D
758E:  MOVWF  FF7
7590:  CLRF   19
7592:  BTFSC  FF2.7
7594:  BSF    19.7
7596:  BCF    FF2.7
7598:  CALL   174A
759C:  BTFSC  19.7
759E:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
75A0:  MOVLW  EE
75A2:  MOVWF  FF6
75A4:  MOVLW  1D
75A6:  MOVWF  FF7
75A8:  CLRF   19
75AA:  BTFSC  FF2.7
75AC:  BSF    19.7
75AE:  BCF    FF2.7
75B0:  CALL   174A
75B4:  BTFSC  19.7
75B6:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
75B8:  MOVLW  00
75BA:  MOVWF  FF6
75BC:  MOVLW  1E
75BE:  MOVWF  FF7
75C0:  CLRF   19
75C2:  BTFSC  FF2.7
75C4:  BSF    19.7
75C6:  BCF    FF2.7
75C8:  CALL   174A
75CC:  BTFSC  19.7
75CE:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
75D0:  MOVLW  12
75D2:  MOVWF  FF6
75D4:  MOVLW  1E
75D6:  MOVWF  FF7
75D8:  CLRF   19
75DA:  BTFSC  FF2.7
75DC:  BSF    19.7
75DE:  BCF    FF2.7
75E0:  CALL   174A
75E4:  BTFSC  19.7
75E6:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
75E8:  MOVLW  32
75EA:  MOVWF  FF6
75EC:  MOVLW  1E
75EE:  MOVWF  FF7
75F0:  CLRF   19
75F2:  BTFSC  FF2.7
75F4:  BSF    19.7
75F6:  BCF    FF2.7
75F8:  CALL   174A
75FC:  BTFSC  19.7
75FE:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
7600:  MOVLW  4E
7602:  MOVWF  FF6
7604:  MOVLW  1E
7606:  MOVWF  FF7
7608:  CLRF   19
760A:  BTFSC  FF2.7
760C:  BSF    19.7
760E:  BCF    FF2.7
7610:  CALL   174A
7614:  BTFSC  19.7
7616:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
7618:  MOVLW  5C
761A:  MOVWF  FF6
761C:  MOVLW  1E
761E:  MOVWF  FF7
7620:  CLRF   19
7622:  BTFSC  FF2.7
7624:  BSF    19.7
7626:  BCF    FF2.7
7628:  CALL   174A
762C:  BTFSC  19.7
762E:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
7630:  MOVLW  68
7632:  MOVWF  FF6
7634:  MOVLW  1E
7636:  MOVWF  FF7
7638:  CLRF   19
763A:  BTFSC  FF2.7
763C:  BSF    19.7
763E:  BCF    FF2.7
7640:  CALL   174A
7644:  BTFSC  19.7
7646:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
7648:  MOVLW  90
764A:  MOVWF  FF6
764C:  MOVLW  1E
764E:  MOVWF  FF7
7650:  CLRF   19
7652:  BTFSC  FF2.7
7654:  BSF    19.7
7656:  BCF    FF2.7
7658:  CALL   174A
765C:  BTFSC  19.7
765E:  BSF    FF2.7
7660:  CLRF   19
7662:  BTFSC  FF2.7
7664:  BSF    19.7
7666:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
7668:  MOVLB  9
766A:  CLRF   x1B
766C:  CLRF   x1A
766E:  CLRF   x19
7670:  MOVLW  3D
7672:  MOVWF  x18
7674:  MOVLB  0
7676:  CALL   3468
767A:  BTFSC  19.7
767C:  BSF    FF2.7
767E:  MOVFF  01,7F3
7682:  MOVLW  AC
7684:  MOVWF  FF6
7686:  MOVLW  1E
7688:  MOVWF  FF7
768A:  CLRF   19
768C:  BTFSC  FF2.7
768E:  BSF    19.7
7690:  BCF    FF2.7
7692:  MOVLW  06
7694:  MOVLB  9
7696:  MOVWF  x00
7698:  MOVLB  0
769A:  CALL   1666
769E:  BTFSC  19.7
76A0:  BSF    FF2.7
76A2:  CLRF   19
76A4:  BTFSC  FF2.7
76A6:  BSF    19.7
76A8:  BCF    FF2.7
76AA:  MOVFF  7F3,859
76AE:  MOVLW  18
76B0:  MOVLB  8
76B2:  MOVWF  x5A
76B4:  MOVLB  0
76B6:  CALL   1796
76BA:  BTFSC  19.7
76BC:  BSF    FF2.7
76BE:  MOVLW  B4
76C0:  MOVWF  FF6
76C2:  MOVLW  1E
76C4:  MOVWF  FF7
76C6:  CLRF   19
76C8:  BTFSC  FF2.7
76CA:  BSF    19.7
76CC:  BCF    FF2.7
76CE:  MOVLW  1D
76D0:  MOVLB  9
76D2:  MOVWF  x00
76D4:  MOVLB  0
76D6:  CALL   1666
76DA:  BTFSC  19.7
76DC:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
76DE:  MOVLW  D2
76E0:  MOVWF  FF6
76E2:  MOVLW  1E
76E4:  MOVWF  FF7
76E6:  CLRF   19
76E8:  BTFSC  FF2.7
76EA:  BSF    19.7
76EC:  BCF    FF2.7
76EE:  CALL   174A
76F2:  BTFSC  19.7
76F4:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................       } 
....................       strcpy(buffer2,"password"); 
76F6:  CLRF   FEA
76F8:  MOVLW  41
76FA:  MOVWF  FE9
76FC:  MOVLW  00
76FE:  CALL   0474
7702:  TBLRD*-
7704:  TBLRD*+
7706:  MOVF   FF5,W
7708:  MOVWF  FEE
770A:  IORLW  00
770C:  BNZ   7704
....................       if(!stringcomp(buffer_uart,buffer2))  
770E:  MOVLW  01
7710:  MOVLB  7
7712:  MOVWF  xF4
7714:  MOVLW  62
7716:  MOVWF  xF3
7718:  CLRF   xF6
771A:  MOVLW  41
771C:  MOVWF  xF5
771E:  MOVLB  0
7720:  CALL   600A
7724:  MOVF   01,F
7726:  BTFSS  FD8.2
7728:  BRA    7888
....................       { 
....................          fprintf(COM2,"old password:"); 
772A:  MOVLW  EC
772C:  MOVWF  FF6
772E:  MOVLW  1E
7730:  MOVWF  FF7
7732:  CLRF   19
7734:  BTFSC  FF2.7
7736:  BSF    19.7
7738:  BCF    FF2.7
773A:  CALL   174A
773E:  BTFSC  19.7
7740:  BSF    FF2.7
7742:  CLRF   19
7744:  BTFSC  FF2.7
7746:  BSF    19.7
7748:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
774A:  MOVLB  9
774C:  CLRF   x07
774E:  CLRF   x06
7750:  CLRF   x05
7752:  CLRF   x04
7754:  CLRF   x0B
7756:  CLRF   x0A
7758:  CLRF   x09
775A:  MOVLW  14
775C:  MOVWF  x08
775E:  CLRF   x0D
7760:  MOVLW  55
7762:  MOVWF  x0C
7764:  MOVLB  0
7766:  CALL   4086
776A:  BTFSC  19.7
776C:  BSF    FF2.7
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
776E:  MOVLW  02
7770:  MOVLB  7
7772:  MOVWF  xF3
7774:  MOVLW  14
7776:  MOVWF  xF4
7778:  CLRF   xF6
777A:  MOVLW  69
777C:  MOVWF  xF5
777E:  MOVLB  0
7780:  CALL   5ED2
....................          if(!stringcomp(entpassword,password)) 
7784:  MOVLB  7
7786:  CLRF   xF4
7788:  MOVLW  69
778A:  MOVWF  xF3
778C:  CLRF   xF6
778E:  MOVLW  55
7790:  MOVWF  xF5
7792:  MOVLB  0
7794:  CALL   600A
7798:  MOVF   01,F
779A:  BNZ   7870
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
779C:  MOVLW  FA
779E:  MOVWF  FF6
77A0:  MOVLW  1E
77A2:  MOVWF  FF7
77A4:  CLRF   19
77A6:  BTFSC  FF2.7
77A8:  BSF    19.7
77AA:  BCF    FF2.7
77AC:  CALL   174A
77B0:  BTFSC  19.7
77B2:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
77B4:  MOVLW  02
77B6:  MOVLB  7
77B8:  MOVWF  xF3
77BA:  MOVLW  14
77BC:  MOVWF  xF4
77BE:  CLRF   xF6
77C0:  MOVLW  69
77C2:  MOVWF  xF5
77C4:  MOVLB  0
77C6:  CALL   5ED2
....................             fprintf(COM2,"\n\ragain:"); 
77CA:  MOVLW  02
77CC:  MOVWF  FF6
77CE:  MOVLW  1F
77D0:  MOVWF  FF7
77D2:  CLRF   19
77D4:  BTFSC  FF2.7
77D6:  BSF    19.7
77D8:  BCF    FF2.7
77DA:  CALL   174A
77DE:  BTFSC  19.7
77E0:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
77E2:  MOVLW  02
77E4:  MOVLB  7
77E6:  MOVWF  xF3
77E8:  MOVLW  14
77EA:  MOVWF  xF4
77EC:  CLRF   xF6
77EE:  MOVLW  55
77F0:  MOVWF  xF5
77F2:  MOVLB  0
77F4:  CALL   5ED2
....................             if(!stringcomp(entpassword,password)) 
77F8:  MOVLB  7
77FA:  CLRF   xF4
77FC:  MOVLW  69
77FE:  MOVWF  xF3
7800:  CLRF   xF6
7802:  MOVLW  55
7804:  MOVWF  xF5
7806:  MOVLB  0
7808:  CALL   600A
780C:  MOVF   01,F
780E:  BNZ   7856
7810:  CLRF   19
7812:  BTFSC  FF2.7
7814:  BSF    19.7
7816:  BCF    FF2.7
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
7818:  MOVLB  9
781A:  CLRF   x03
781C:  CLRF   x02
781E:  CLRF   x01
7820:  CLRF   x00
7822:  CLRF   x07
7824:  CLRF   x06
7826:  CLRF   x05
7828:  MOVLW  14
782A:  MOVWF  x04
782C:  CLRF   x09
782E:  MOVLW  55
7830:  MOVWF  x08
7832:  MOVLB  0
7834:  CALL   4DF0
7838:  BTFSC  19.7
783A:  BSF    FF2.7
....................                fprintf(COM2,"\n\rOK\n\r");    
783C:  MOVLW  0C
783E:  MOVWF  FF6
7840:  MOVLW  1F
7842:  MOVWF  FF7
7844:  CLRF   19
7846:  BTFSC  FF2.7
7848:  BSF    19.7
784A:  BCF    FF2.7
784C:  CALL   174A
7850:  BTFSC  19.7
7852:  BSF    FF2.7
....................             } 
....................                else 
7854:  BRA    786E
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
7856:  MOVLW  14
7858:  MOVWF  FF6
785A:  MOVLW  1F
785C:  MOVWF  FF7
785E:  CLRF   19
7860:  BTFSC  FF2.7
7862:  BSF    19.7
7864:  BCF    FF2.7
7866:  CALL   174A
786A:  BTFSC  19.7
786C:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
786E:  BRA    7888
....................             { 
....................                fprintf(COM2," X\n\r"); 
7870:  MOVLW  1C
7872:  MOVWF  FF6
7874:  MOVLW  1F
7876:  MOVWF  FF7
7878:  CLRF   19
787A:  BTFSC  FF2.7
787C:  BSF    19.7
787E:  BCF    FF2.7
7880:  CALL   174A
7884:  BTFSC  19.7
7886:  BSF    FF2.7
....................             }    
....................       } 
....................         strcpy(buffer2,"crypto"); 
7888:  CLRF   FEA
788A:  MOVLW  41
788C:  MOVWF  FE9
788E:  MOVLW  00
7890:  CALL   048E
7894:  TBLRD*-
7896:  TBLRD*+
7898:  MOVF   FF5,W
789A:  MOVWF  FEE
789C:  IORLW  00
789E:  BNZ   7896
....................         if(!stringcomp(buffer_uart,buffer2))  
78A0:  MOVLW  01
78A2:  MOVLB  7
78A4:  MOVWF  xF4
78A6:  MOVLW  62
78A8:  MOVWF  xF3
78AA:  CLRF   xF6
78AC:  MOVLW  41
78AE:  MOVWF  xF5
78B0:  MOVLB  0
78B2:  CALL   600A
78B6:  MOVF   01,F
78B8:  BTFSS  FD8.2
78BA:  BRA    7A3A
....................         { 
....................             memset(crypto_key,0,sizeof(crypto_key)); 
78BC:  MOVLW  01
78BE:  MOVWF  FEA
78C0:  MOVWF  FE9
78C2:  CLRF   00
78C4:  CLRF   02
78C6:  MOVLW  21
78C8:  MOVWF  01
78CA:  CALL   35AE
....................             fprintf(COM2,"New crypto key>"); 
78CE:  MOVLW  22
78D0:  MOVWF  FF6
78D2:  MOVLW  1F
78D4:  MOVWF  FF7
78D6:  CLRF   19
78D8:  BTFSC  FF2.7
78DA:  BSF    19.7
78DC:  BCF    FF2.7
78DE:  CALL   174A
78E2:  BTFSC  19.7
78E4:  BSF    FF2.7
....................             countchar = (int16)USART_getstring(EN_ECHO, CRYPTO_KEY_SIZE, crypto_key); 
78E6:  MOVLW  01
78E8:  MOVLB  7
78EA:  MOVWF  xF3
78EC:  MOVLW  20
78EE:  MOVWF  xF4
78F0:  MOVLW  01
78F2:  MOVWF  xF6
78F4:  MOVWF  xF5
78F6:  MOVLB  0
78F8:  CALL   5ED2
78FC:  MOVLB  7
78FE:  CLRF   xC0
7900:  MOVFF  01,7BF
7904:  CLRF   19
7906:  BTFSC  FF2.7
7908:  BSF    19.7
790A:  BCF    FF2.7
....................             EEPROM_write(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
790C:  MOVLB  9
790E:  CLRF   x03
7910:  CLRF   x02
7912:  CLRF   x01
7914:  MOVLW  3F
7916:  MOVWF  x00
7918:  CLRF   x07
791A:  CLRF   x06
791C:  CLRF   x05
791E:  MOVLW  20
7920:  MOVWF  x04
7922:  MOVLW  01
7924:  MOVWF  x09
7926:  MOVWF  x08
7928:  MOVLB  0
792A:  CALL   4DF0
792E:  BTFSC  19.7
7930:  BSF    FF2.7
....................              
....................             if(countchar>2) 
7932:  MOVLB  7
7934:  MOVF   xC0,F
7936:  BNZ   793E
7938:  MOVF   xBF,W
793A:  SUBLW  02
793C:  BC    79FC
....................             { 
....................                 cryption_enable = 1; 
793E:  MOVLW  01
7940:  MOVLB  1
7942:  MOVWF  x22
7944:  CLRF   19
7946:  BTFSC  FF2.7
7948:  BSF    19.7
794A:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable);                    
794C:  MOVLB  9
794E:  CLRF   x16
7950:  CLRF   x15
7952:  CLRF   x14
7954:  MOVLW  3E
7956:  MOVWF  x13
7958:  MOVFF  122,917
795C:  MOVLB  0
795E:  CALL   3A80
7962:  BTFSC  19.7
7964:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rNew crypto key: "); 
7966:  MOVLW  32
7968:  MOVWF  FF6
796A:  MOVLW  1F
796C:  MOVWF  FF7
796E:  CLRF   19
7970:  BTFSC  FF2.7
7972:  BSF    19.7
7974:  BCF    FF2.7
7976:  CALL   174A
797A:  BTFSC  19.7
797C:  BSF    FF2.7
....................                 for(i=0;i<CRYPTO_KEY_SIZE;i++) 
797E:  MOVLB  7
7980:  CLRF   xBE
7982:  MOVF   xBE,W
7984:  SUBLW  1F
7986:  BNC   79C8
....................                 { 
....................                     fprintf(COM2,"%c",read_ext_eeprom(strobe_crypto_key+i)); 
7988:  MOVLW  3F
798A:  ADDWF  xBE,W
798C:  MOVWF  xF3
798E:  CLRF   19
7990:  BTFSC  FF2.7
7992:  BSF    19.7
7994:  BCF    FF2.7
7996:  MOVLB  9
7998:  CLRF   x1B
799A:  CLRF   x1A
799C:  CLRF   x19
799E:  MOVWF  x18
79A0:  MOVLB  0
79A2:  CALL   3468
79A6:  BTFSC  19.7
79A8:  BSF    FF2.7
79AA:  MOVFF  01,7F3
79AE:  CLRF   19
79B0:  BTFSC  FF2.7
79B2:  BSF    19.7
79B4:  BCF    FF2.7
79B6:  MOVFF  01,90C
79BA:  CALL   1620
79BE:  BTFSC  19.7
79C0:  BSF    FF2.7
....................                 } 
79C2:  MOVLB  7
79C4:  INCF   xBE,F
79C6:  BRA    7982
79C8:  CLRF   19
79CA:  BTFSC  FF2.7
79CC:  BSF    19.7
79CE:  BCF    FF2.7
....................                 fprintf(COM2,"\n\r"); 
79D0:  MOVLW  0A
79D2:  MOVLB  9
79D4:  MOVWF  x0C
79D6:  MOVLB  0
79D8:  CALL   1620
79DC:  BTFSC  19.7
79DE:  BSF    FF2.7
79E0:  CLRF   19
79E2:  BTFSC  FF2.7
79E4:  BSF    19.7
79E6:  BCF    FF2.7
79E8:  MOVLW  0D
79EA:  MOVLB  9
79EC:  MOVWF  x0C
79EE:  MOVLB  0
79F0:  CALL   1620
79F4:  BTFSC  19.7
79F6:  BSF    FF2.7
....................             } 
....................             else 
79F8:  BRA    7A3A
79FA:  MOVLB  7
....................             { 
....................                 cryption_enable = 0; 
79FC:  MOVLB  1
79FE:  CLRF   x22
7A00:  CLRF   19
7A02:  BTFSC  FF2.7
7A04:  BSF    19.7
7A06:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable); 
7A08:  MOVLB  9
7A0A:  CLRF   x16
7A0C:  CLRF   x15
7A0E:  CLRF   x14
7A10:  MOVLW  3E
7A12:  MOVWF  x13
7A14:  MOVFF  122,917
7A18:  MOVLB  0
7A1A:  CALL   3A80
7A1E:  BTFSC  19.7
7A20:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rcrypto is disable\n\r"); 
7A22:  MOVLW  46
7A24:  MOVWF  FF6
7A26:  MOVLW  1F
7A28:  MOVWF  FF7
7A2A:  CLRF   19
7A2C:  BTFSC  FF2.7
7A2E:  BSF    19.7
7A30:  BCF    FF2.7
7A32:  CALL   174A
7A36:  BTFSC  19.7
7A38:  BSF    FF2.7
....................             } 
....................         } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
7A3A:  CLRF   FEA
7A3C:  MOVLW  41
7A3E:  MOVWF  FE9
7A40:  MOVLW  00
7A42:  CALL   04A6
7A46:  TBLRD*-
7A48:  TBLRD*+
7A4A:  MOVF   FF5,W
7A4C:  MOVWF  FEE
7A4E:  IORLW  00
7A50:  BNZ   7A48
....................       if(!stringcomp(buffer_uart,buffer2)) 
7A52:  MOVLW  01
7A54:  MOVLB  7
7A56:  MOVWF  xF4
7A58:  MOVLW  62
7A5A:  MOVWF  xF3
7A5C:  CLRF   xF6
7A5E:  MOVLW  41
7A60:  MOVWF  xF5
7A62:  MOVLB  0
7A64:  CALL   600A
7A68:  MOVF   01,F
7A6A:  BTFSS  FD8.2
7A6C:  BRA    7B7C
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
7A6E:  MOVLW  5C
7A70:  MOVWF  FF6
7A72:  MOVLW  1F
7A74:  MOVWF  FF7
7A76:  CLRF   19
7A78:  BTFSC  FF2.7
7A7A:  BSF    19.7
7A7C:  BCF    FF2.7
7A7E:  CALL   174A
7A82:  BTFSC  19.7
7A84:  BSF    FF2.7
7A86:  CLRF   19
7A88:  BTFSC  FF2.7
7A8A:  BSF    19.7
7A8C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7A8E:  MOVLW  0A
7A90:  MOVLB  9
7A92:  MOVWF  x0C
7A94:  MOVLB  0
7A96:  CALL   1620
7A9A:  BTFSC  19.7
7A9C:  BSF    FF2.7
7A9E:  CLRF   19
7AA0:  BTFSC  FF2.7
7AA2:  BSF    19.7
7AA4:  BCF    FF2.7
7AA6:  MOVLW  0D
7AA8:  MOVLB  9
7AAA:  MOVWF  x0C
7AAC:  MOVLB  0
7AAE:  CALL   1620
7AB2:  BTFSC  19.7
7AB4:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
7AB6:  MOVLW  7C
7AB8:  MOVWF  FF6
7ABA:  MOVLW  1F
7ABC:  MOVWF  FF7
7ABE:  CLRF   19
7AC0:  BTFSC  FF2.7
7AC2:  BSF    19.7
7AC4:  BCF    FF2.7
7AC6:  CALL   174A
7ACA:  BTFSC  19.7
7ACC:  BSF    FF2.7
7ACE:  CLRF   19
7AD0:  BTFSC  FF2.7
7AD2:  BSF    19.7
7AD4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7AD6:  MOVLW  0A
7AD8:  MOVLB  9
7ADA:  MOVWF  x0C
7ADC:  MOVLB  0
7ADE:  CALL   1620
7AE2:  BTFSC  19.7
7AE4:  BSF    FF2.7
7AE6:  CLRF   19
7AE8:  BTFSC  FF2.7
7AEA:  BSF    19.7
7AEC:  BCF    FF2.7
7AEE:  MOVLW  0D
7AF0:  MOVLB  9
7AF2:  MOVWF  x0C
7AF4:  MOVLB  0
7AF6:  CALL   1620
7AFA:  BTFSC  19.7
7AFC:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7AFE:  MOVLW  01
7B00:  MOVLB  7
7B02:  MOVWF  xF3
7B04:  MOVLW  03
7B06:  MOVWF  xF4
7B08:  MOVLW  07
7B0A:  MOVWF  xF6
7B0C:  MOVLW  C1
7B0E:  MOVWF  xF5
7B10:  MOVLB  0
7B12:  CALL   5ED2
....................           debugmode = (unsigned int8)strtoi(temp); 
7B16:  MOVLW  07
7B18:  MOVLB  7
7B1A:  MOVWF  xF4
7B1C:  MOVLW  C1
7B1E:  MOVWF  xF3
7B20:  MOVLB  0
7B22:  CALL   69E4
7B26:  MOVFF  01,6D6
7B2A:  CLRF   19
7B2C:  BTFSC  FF2.7
7B2E:  BSF    19.7
7B30:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
7B32:  MOVLB  9
7B34:  CLRF   x16
7B36:  CLRF   x15
7B38:  CLRF   x14
7B3A:  MOVLW  3B
7B3C:  MOVWF  x13
7B3E:  MOVFF  6D6,917
7B42:  MOVLB  0
7B44:  CALL   3A80
7B48:  BTFSC  19.7
7B4A:  BSF    FF2.7
7B4C:  CLRF   19
7B4E:  BTFSC  FF2.7
7B50:  BSF    19.7
7B52:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7B54:  MOVLW  0A
7B56:  MOVLB  9
7B58:  MOVWF  x0C
7B5A:  MOVLB  0
7B5C:  CALL   1620
7B60:  BTFSC  19.7
7B62:  BSF    FF2.7
7B64:  CLRF   19
7B66:  BTFSC  FF2.7
7B68:  BSF    19.7
7B6A:  BCF    FF2.7
7B6C:  MOVLW  0D
7B6E:  MOVLB  9
7B70:  MOVWF  x0C
7B72:  MOVLB  0
7B74:  CALL   1620
7B78:  BTFSC  19.7
7B7A:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
7B7C:  GOTO   8264 (RETURN)
.................... //=============================================== 
....................  
....................  
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    if(keydebug_en==1) 
*
5932:  MOVLB  1
5934:  DECFSZ x44,W
5936:  BRA    5952
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
5938:  MOVLB  6
593A:  MOVF   xE2,F
593C:  BNZ   5946
593E:  MOVLB  0
5940:  CALL   1F9C
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
5944:  BRA    5950
5946:  MOVLB  0
5948:  CALL   31F8
594C:  MOVFF  01,84F
5950:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
5952:  DECFSZ x45,W
5954:  BRA    596E
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
5956:  MOVLB  6
5958:  MOVF   xE2,F
595A:  BNZ   5964
595C:  MOVLB  0
595E:  CALL   1F9C
....................          else temp=kbd_getc_slv(); 
5962:  BRA    596E
5964:  MOVLB  0
5966:  CALL   31F8
596A:  MOVFF  01,84F
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
596E:  MOVLB  6
5970:  MOVF   xC7,F
5972:  BNZ   5992
5974:  MOVF   xC6,F
5976:  BNZ   5992
5978:  MOVF   xC5,F
597A:  BNZ   5992
597C:  MOVF   xC4,W
597E:  SUBLW  04
5980:  BNC   5992
5982:  MOVLW  01
5984:  ADDWF  xC4,F
5986:  BTFSC  FD8.0
5988:  INCF   xC5,F
598A:  BTFSC  FD8.2
598C:  INCF   xC6,F
598E:  BTFSC  FD8.2
5990:  INCF   xC7,F
....................   if(mcr_timeout==5) 
5992:  MOVF   xC4,W
5994:  SUBLW  05
5996:  BNZ   5A02
5998:  MOVF   xC5,F
599A:  BNZ   5A02
599C:  MOVF   xC6,F
599E:  BNZ   5A02
59A0:  MOVF   xC7,F
59A2:  BNZ   5A02
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1) 
59A4:  DECFSZ xDA,W
59A6:  BRA    59C0
....................       { 
....................           if(cryption_enable==0)  
59A8:  MOVLB  1
59AA:  MOVF   x22,F
59AC:  BNZ   59B8
....................           { 
....................                 saving_card(); 
59AE:  MOVLB  0
59B0:  GOTO   3C0C
....................           } 
....................           else  
59B4:  BRA    59BE
59B6:  MOVLB  1
....................           { 
....................                 saving_card_encrypt(); 
59B8:  MOVLB  0
59BA:  GOTO   4ECA
59BE:  MOVLB  6
....................           } 
....................       } 
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
59C0:  MOVLW  02
59C2:  MOVWF  FEA
59C4:  MOVLW  46
59C6:  MOVWF  FE9
59C8:  CLRF   00
59CA:  MOVLW  03
59CC:  MOVWF  02
59CE:  MOVLW  52
59D0:  MOVWF  01
59D2:  MOVLB  0
59D4:  CALL   35AE
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
59D8:  MOVLW  05
59DA:  MOVWF  FEA
59DC:  MOVLW  98
59DE:  MOVWF  FE9
59E0:  CLRF   00
59E2:  MOVLW  01
59E4:  MOVWF  02
59E6:  MOVLW  2C
59E8:  MOVWF  01
59EA:  CALL   35AE
....................       //debug_card(); 
....................       count_reading_error=0; 
59EE:  MOVLB  6
59F0:  CLRF   xDB
....................       mcr_timeout++;   
59F2:  MOVLW  01
59F4:  ADDWF  xC4,F
59F6:  BTFSC  FD8.0
59F8:  INCF   xC5,F
59FA:  BTFSC  FD8.2
59FC:  INCF   xC6,F
59FE:  BTFSC  FD8.2
5A00:  INCF   xC7,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
5A02:  MOVLB  9
5A04:  CLRF   x1B
5A06:  CLRF   x1A
5A08:  CLRF   x19
5A0A:  MOVLW  3C
5A0C:  MOVWF  x18
5A0E:  MOVLB  0
5A10:  CALL   3468
5A14:  MOVFF  01,15A
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
5A18:  MOVLW  02
5A1A:  MOVLB  8
5A1C:  MOVWF  x56
5A1E:  MOVLW  BC
5A20:  MOVWF  x55
5A22:  CLRF   x58
5A24:  MOVFF  15A,857
5A28:  MOVLB  0
5A2A:  CALL   358C
5A2E:  MOVFF  02,03
5A32:  MOVF   01,W
5A34:  MOVLB  1
5A36:  MOVF   x00,W
5A38:  SUBWF  02,W
5A3A:  BNC   5A5A
5A3C:  BNZ   5A4C
5A3E:  MOVF   01,W
5A40:  MOVLB  0
5A42:  SUBWF  xFF,W
5A44:  BTFSS  FD8.0
5A46:  BRA    5A4C
5A48:  MOVLB  1
5A4A:  BRA    5A5A
5A4C:  MOVLB  0
5A4E:  INCF   xFF,F
5A50:  BTFSS  FD8.2
5A52:  BRA    5A5A
5A54:  MOVLB  1
5A56:  INCF   x00,F
5A58:  MOVLB  0
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
5A5A:  MOVLW  02
5A5C:  MOVLB  8
5A5E:  MOVWF  x56
5A60:  MOVLW  BC
5A62:  MOVWF  x55
5A64:  CLRF   x58
5A66:  MOVFF  15A,857
5A6A:  MOVLB  0
5A6C:  CALL   358C
5A70:  MOVFF  02,03
5A74:  MOVF   01,W
5A76:  SUBWF  xFF,W
5A78:  BNZ   5B3E
5A7A:  MOVF   03,W
5A7C:  MOVLB  1
5A7E:  SUBWF  x00,W
5A80:  BTFSC  FD8.2
5A82:  BRA    5A88
5A84:  MOVLB  0
5A86:  BRA    5B3E
....................   { 
....................       charac_timeout++; 
5A88:  MOVLB  0
5A8A:  INCF   xFF,F
5A8C:  BTFSS  FD8.2
5A8E:  BRA    5A96
5A90:  MOVLB  1
5A92:  INCF   x00,F
5A94:  MOVLB  0
....................       buf=get_countcard(); 
5A96:  CALL   3534
5A9A:  MOVFF  02,84E
5A9E:  MOVFF  01,84D
....................       if(buf<countcards) 
5AA2:  MOVLB  8
5AA4:  MOVF   x4E,W
5AA6:  SUBLW  03
5AA8:  BNC   5ADE
5AAA:  BNZ   5AB2
5AAC:  MOVF   x4D,W
5AAE:  SUBLW  A1
5AB0:  BNC   5ADE
....................       { 
....................          if(cryption_enable==0)  
5AB2:  MOVLB  1
5AB4:  MOVF   x22,F
5AB6:  BNZ   5AC0
....................          { 
....................             save_key_new(); 
5AB8:  MOVLB  0
5ABA:  BRA    540C
....................          } 
....................          else 
5ABC:  BRA    5AC4
5ABE:  MOVLB  1
....................          { 
....................             save_key_encrypt(); 
5AC0:  MOVLB  0
5AC2:  BRA    55AC
....................          } 
....................          buf=buf+1; 
5AC4:  MOVLW  01
5AC6:  MOVLB  8
5AC8:  ADDWF  x4D,F
5ACA:  MOVLW  00
5ACC:  ADDWFC x4E,F
....................          save_coutcard(buf); 
5ACE:  MOVFF  84E,851
5AD2:  MOVFF  84D,850
5AD6:  MOVLB  0
5AD8:  RCALL  57F4
....................       } 
....................          else 
5ADA:  BRA    5AEE
5ADC:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
5ADE:  MOVLW  44
5AE0:  MOVWF  FF6
5AE2:  MOVLW  5B
5AE4:  MOVWF  FF7
5AE6:  MOVLB  0
5AE8:  CALL   174A
....................             return; 
5AEC:  BRA    5B3E
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
5AEE:  MOVLW  54
5AF0:  MOVWF  FF6
5AF2:  MOVLW  5B
5AF4:  MOVWF  FF7
5AF6:  CALL   174A
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
5AFA:  MOVLW  64
5AFC:  MOVWF  FF6
5AFE:  MOVLW  5B
5B00:  MOVWF  FF7
5B02:  MOVLW  14
5B04:  MOVLB  9
5B06:  MOVWF  x00
5B08:  MOVLB  0
5B0A:  CALL   1666
5B0E:  MOVLW  10
5B10:  MOVWF  FE9
5B12:  MOVFF  84E,851
5B16:  MOVFF  84D,850
5B1A:  RCALL  583C
5B1C:  MOVLW  7B
5B1E:  MOVWF  FF6
5B20:  MOVLW  5B
5B22:  MOVWF  FF7
5B24:  MOVLW  03
5B26:  MOVLB  9
5B28:  MOVWF  x00
5B2A:  MOVLB  0
5B2C:  CALL   1666
....................       data_avai=0; 
5B30:  MOVLB  6
5B32:  CLRF   xD9
....................       enable_getpin=0; 
5B34:  MOVLB  1
5B36:  CLRF   x45
....................       //dis_getpin; 
....................       output_low(LED); 
5B38:  BCF    F92.6
5B3A:  BCF    F89.6
5B3C:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
5B3E:  BCF    FF2.2
5B40:  GOTO   006C
.................... void main() 
.................... {  
*
7B80:  CLRF   FF8
7B82:  BCF    FD0.7
7B84:  BSF    07.7
7B86:  CLRF   FEA
7B88:  CLRF   FE9
7B8A:  BCF    F94.0
7B8C:  BSF    F8B.0
7B8E:  CLRF   23
7B90:  CLRF   22
7B92:  CLRF   21
7B94:  MOVLW  96
7B96:  MOVWF  20
7B98:  CLRF   27
7B9A:  CLRF   26
7B9C:  MOVLW  E1
7B9E:  MOVWF  25
7BA0:  MOVLW  01
7BA2:  MOVWF  24
7BA4:  CLRF   xFE
7BA6:  CLRF   xFD
7BA8:  MOVLB  1
7BAA:  SETF   x00
7BAC:  MOVLB  0
7BAE:  SETF   xFF
7BB0:  MOVLB  1
7BB2:  CLRF   x22
7BB4:  CLRF   x43
7BB6:  CLRF   x44
7BB8:  CLRF   x45
7BBA:  MOVLW  64
7BBC:  MOVWF  x46
7BBE:  CLRF   x47
7BC0:  CLRF   x48
7BC2:  CLRF   x49
7BC4:  CLRF   x5A
7BC6:  CLRF   x5F
7BC8:  CLRF   xC6
7BCA:  CLRF   xC7
7BCC:  MOVLW  0E
7BCE:  MOVWF  xC9
7BD0:  MOVLW  01
7BD2:  MOVWF  xCA
7BD4:  MOVWF  xCB
7BD6:  CLRF   xCC
7BD8:  CLRF   xCD
7BDA:  CLRF   xCE
7BDC:  MOVLB  6
7BDE:  CLRF   xC7
7BE0:  CLRF   xC6
7BE2:  CLRF   xC5
7BE4:  CLRF   xC4
7BE6:  CLRF   xC8
7BE8:  CLRF   xCA
7BEA:  CLRF   xC9
7BEC:  CLRF   xCC
7BEE:  CLRF   xCB
7BF0:  CLRF   xCE
7BF2:  CLRF   xCD
7BF4:  CLRF   xD0
7BF6:  CLRF   xCF
7BF8:  MOVLW  FD
7BFA:  MOVWF  xD2
7BFC:  MOVLW  E8
7BFE:  MOVWF  xD1
7C00:  CLRF   xD4
7C02:  CLRF   xD3
7C04:  CLRF   xD5
7C06:  CLRF   xD6
7C08:  CLRF   xD7
7C0A:  CLRF   xD8
7C0C:  CLRF   xD9
7C0E:  CLRF   xDA
7C10:  CLRF   xDB
7C12:  CLRF   xDC
7C14:  CLRF   xDD
7C16:  CLRF   xDF
7C18:  MOVLW  01
7C1A:  MOVWF  xDE
7C1C:  CLRF   xE1
7C1E:  CLRF   xE0
7C20:  CLRF   xE2
7C22:  CLRF   xE6
7C24:  CLRF   xE5
7C26:  CLRF   xE4
7C28:  CLRF   xE3
7C2A:  MOVLW  FF
7C2C:  MOVLB  F
7C2E:  MOVWF  x48
7C30:  BCF    FC2.6
7C32:  BCF    FC2.7
7C34:  MOVF   x49,W
7C36:  ANDLW  E0
7C38:  IORLW  1F
7C3A:  MOVWF  x49
7C3C:  CLRF   FD2
7C3E:  CLRF   FD1
7C40:  CLRF   1A
7C42:  CLRF   1B
7C44:  MOVLW  E8
7C46:  MOVLB  1
7C48:  MOVWF  x23
7C4A:  MOVLW  E9
7C4C:  MOVWF  x24
7C4E:  MOVLW  EA
7C50:  MOVWF  x25
7C52:  MOVLW  EB
7C54:  MOVWF  x26
7C56:  MOVLW  ED
7C58:  MOVWF  x27
7C5A:  MOVLW  EE
7C5C:  MOVWF  x28
7C5E:  MOVLW  EF
7C60:  MOVWF  x29
7C62:  MOVLW  F0
7C64:  MOVWF  x2A
7C66:  MOVLW  F2
7C68:  MOVWF  x2B
7C6A:  MOVLW  F3
7C6C:  MOVWF  x2C
7C6E:  MOVLW  F4
7C70:  MOVWF  x2D
7C72:  MOVLW  F5
7C74:  MOVWF  x2E
7C76:  MOVLW  F7
7C78:  MOVWF  x2F
7C7A:  MOVLW  F8
7C7C:  MOVWF  x30
7C7E:  MOVLW  F9
7C80:  MOVWF  x31
7C82:  MOVLW  FA
7C84:  MOVWF  x32
7C86:  MOVLW  67
7C88:  MOVWF  x33
7C8A:  MOVLW  43
7C8C:  MOVWF  x34
7C8E:  MOVLW  C3
7C90:  MOVWF  x35
7C92:  MOVLW  D1
7C94:  MOVWF  x36
7C96:  MOVLW  51
7C98:  MOVWF  x37
7C9A:  MOVLW  9A
7C9C:  MOVWF  x38
7C9E:  MOVLW  B4
7CA0:  MOVWF  x39
7CA2:  MOVLW  F2
7CA4:  MOVWF  x3A
7CA6:  MOVLW  CD
7CA8:  MOVWF  x3B
7CAA:  MOVLW  9A
7CAC:  MOVWF  x3C
7CAE:  MOVLW  78
7CB0:  MOVWF  x3D
7CB2:  MOVLW  AB
7CB4:  MOVWF  x3E
7CB6:  MOVLW  09
7CB8:  MOVWF  x3F
7CBA:  MOVLW  A5
7CBC:  MOVWF  x40
7CBE:  MOVLW  11
7CC0:  MOVWF  x41
7CC2:  MOVLW  BD
7CC4:  MOVWF  x42
7CC6:  CLRF   x5B
7CC8:  BCF    x5C.0
7CCA:  CLRF   x5D
7CCC:  CLRF   x5E
7CCE:  CLRF   x60
7CD0:  BCF    x5C.1
7CD2:  CLRF   x61
7CD4:  MOVLB  6
7CD6:  CLRF   xF7
7CD8:  CLRF   xF8
7CDA:  CLRF   xF9
7CDC:  CLRF   xFA
7CDE:  CLRF   xFB
7CE0:  CLRF   xFC
7CE2:  CLRF   xFD
7CE4:  CLRF   xFE
7CE6:  CLRF   xFF
7CE8:  MOVLB  7
7CEA:  CLRF   x00
7CEC:  CLRF   x03
7CEE:  CLRF   x05
7CF0:  CLRF   x04
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    RPINR1=5; 
7CF2:  MOVLW  05
7CF4:  MOVLB  E
7CF6:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
7CF8:  MOVLB  1
7CFA:  SETF   x00
7CFC:  MOVLB  0
7CFE:  SETF   xFF
....................    setup_oscillator(OSC_32MHZ); 
7D00:  MOVLW  70
7D02:  MOVWF  FD3
7D04:  MOVLW  40
7D06:  MOVWF  F9B
7D08:  MOVF   FD3,W
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
7D0A:  BCF    FF2.6
7D0C:  BCF    FF2.7
7D0E:  BTFSC  FF2.7
7D10:  BRA    7D0C
....................    init_ext_eeprom(); 
7D12:  GOTO   5C68
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif   
....................    //===================================== 
....................    delay_ms(1000); 
7D16:  MOVLW  04
7D18:  MOVLB  7
7D1A:  MOVWF  xBD
7D1C:  CLRF   19
7D1E:  BTFSC  FF2.7
7D20:  BSF    19.7
7D22:  BCF    FF2.7
7D24:  MOVLW  FA
7D26:  MOVLB  8
7D28:  MOVWF  x56
7D2A:  MOVLB  0
7D2C:  CALL   18E6
7D30:  BTFSC  19.7
7D32:  BSF    FF2.7
7D34:  MOVLB  7
7D36:  DECFSZ xBD,F
7D38:  BRA    7D1C
....................    init_password(); 
7D3A:  MOVLB  0
7D3C:  CALL   5C72
....................    //===================================== 
....................    fprintf(COM2,"\n\rbooting\n\r"); 
7D40:  MOVLW  80
7D42:  MOVWF  FF6
7D44:  MOVLW  5B
7D46:  MOVWF  FF7
7D48:  CLRF   19
7D4A:  BTFSC  FF2.7
7D4C:  BSF    19.7
7D4E:  BCF    FF2.7
7D50:  CALL   174A
7D54:  BTFSC  19.7
7D56:  BSF    FF2.7
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
7D58:  MOVLW  19
7D5A:  MOVLB  7
7D5C:  MOVWF  xBD
7D5E:  MOVLB  0
7D60:  CALL   5D2E
7D64:  MOVFF  03,23
7D68:  MOVFF  02,22
7D6C:  MOVFF  01,21
7D70:  MOVFF  00,20
....................    fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
7D74:  MOVLW  8C
7D76:  MOVWF  FF6
7D78:  MOVLW  5B
7D7A:  MOVWF  FF7
7D7C:  CLRF   19
7D7E:  BTFSC  FF2.7
7D80:  BSF    19.7
7D82:  BCF    FF2.7
7D84:  MOVLW  0E
7D86:  MOVLB  9
7D88:  MOVWF  x00
7D8A:  MOVLB  0
7D8C:  CALL   1666
7D90:  BTFSC  19.7
7D92:  BSF    FF2.7
7D94:  MOVLW  41
7D96:  MOVWF  FE9
7D98:  CLRF   19
7D9A:  BTFSC  FF2.7
7D9C:  BSF    19.7
7D9E:  BCF    FF2.7
7DA0:  MOVFF  23,903
7DA4:  MOVFF  22,902
7DA8:  MOVFF  21,901
7DAC:  MOVFF  20,900
7DB0:  CALL   231A
7DB4:  BTFSC  19.7
7DB6:  BSF    FF2.7
7DB8:  CLRF   19
7DBA:  BTFSC  FF2.7
7DBC:  BSF    19.7
7DBE:  BCF    FF2.7
7DC0:  MOVLW  0A
7DC2:  MOVLB  9
7DC4:  MOVWF  x0C
7DC6:  MOVLB  0
7DC8:  CALL   1620
7DCC:  BTFSC  19.7
7DCE:  BSF    FF2.7
7DD0:  CLRF   19
7DD2:  BTFSC  FF2.7
7DD4:  BSF    19.7
7DD6:  BCF    FF2.7
7DD8:  MOVLW  0D
7DDA:  MOVLB  9
7DDC:  MOVWF  x0C
7DDE:  MOVLB  0
7DE0:  CALL   1620
7DE4:  BTFSC  19.7
7DE6:  BSF    FF2.7
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
7DE8:  MOVLW  1E
7DEA:  MOVLB  7
7DEC:  MOVWF  xBD
7DEE:  MOVLB  0
7DF0:  CALL   5D2E
7DF4:  MOVFF  03,27
7DF8:  MOVFF  02,26
7DFC:  MOVFF  01,25
7E00:  MOVFF  00,24
....................    fprintf(COM2,"max address: 0x%lx\n\r", EEPROM_SIZE_endofkey); 
7E04:  MOVLW  A0
7E06:  MOVWF  FF6
7E08:  MOVLW  5B
7E0A:  MOVWF  FF7
7E0C:  CLRF   19
7E0E:  BTFSC  FF2.7
7E10:  BSF    19.7
7E12:  BCF    FF2.7
7E14:  MOVLW  0F
7E16:  MOVLB  9
7E18:  MOVWF  x00
7E1A:  MOVLB  0
7E1C:  CALL   1666
7E20:  BTFSC  19.7
7E22:  BSF    FF2.7
7E24:  CLRF   19
7E26:  BTFSC  FF2.7
7E28:  BSF    19.7
7E2A:  BCF    FF2.7
7E2C:  MOVLB  9
7E2E:  SETF   x01
7E30:  MOVLW  57
7E32:  MOVWF  x02
7E34:  MOVLB  0
7E36:  CALL   4E80
7E3A:  BTFSC  19.7
7E3C:  BSF    FF2.7
7E3E:  CLRF   19
7E40:  BTFSC  FF2.7
7E42:  BSF    19.7
7E44:  BCF    FF2.7
7E46:  MOVLB  9
7E48:  SETF   x01
7E4A:  MOVLW  57
7E4C:  MOVWF  x02
7E4E:  MOVLB  0
7E50:  CALL   4E80
7E54:  BTFSC  19.7
7E56:  BSF    FF2.7
7E58:  CLRF   19
7E5A:  BTFSC  FF2.7
7E5C:  BSF    19.7
7E5E:  BCF    FF2.7
7E60:  MOVLW  0A
7E62:  MOVLB  9
7E64:  MOVWF  x0C
7E66:  MOVLB  0
7E68:  CALL   1620
7E6C:  BTFSC  19.7
7E6E:  BSF    FF2.7
7E70:  CLRF   19
7E72:  BTFSC  FF2.7
7E74:  BSF    19.7
7E76:  BCF    FF2.7
7E78:  MOVLW  0D
7E7A:  MOVLB  9
7E7C:  MOVWF  x0C
7E7E:  MOVLB  0
7E80:  CALL   1620
7E84:  BTFSC  19.7
7E86:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
7E88:  MOVLW  B6
7E8A:  MOVWF  FF6
7E8C:  MOVLW  5B
7E8E:  MOVWF  FF7
7E90:  CLRF   19
7E92:  BTFSC  FF2.7
7E94:  BSF    19.7
7E96:  BCF    FF2.7
7E98:  MOVLW  12
7E9A:  MOVLB  9
7E9C:  MOVWF  x00
7E9E:  MOVLB  0
7EA0:  CALL   1666
7EA4:  BTFSC  19.7
7EA6:  BSF    FF2.7
7EA8:  MOVLW  41
7EAA:  MOVWF  FE9
7EAC:  CLRF   19
7EAE:  BTFSC  FF2.7
7EB0:  BSF    19.7
7EB2:  BCF    FF2.7
7EB4:  MOVFF  27,903
7EB8:  MOVFF  26,902
7EBC:  MOVFF  25,901
7EC0:  MOVFF  24,900
7EC4:  CALL   231A
7EC8:  BTFSC  19.7
7ECA:  BSF    FF2.7
7ECC:  CLRF   19
7ECE:  BTFSC  FF2.7
7ED0:  BSF    19.7
7ED2:  BCF    FF2.7
7ED4:  MOVLW  0A
7ED6:  MOVLB  9
7ED8:  MOVWF  x0C
7EDA:  MOVLB  0
7EDC:  CALL   1620
7EE0:  BTFSC  19.7
7EE2:  BSF    FF2.7
7EE4:  CLRF   19
7EE6:  BTFSC  FF2.7
7EE8:  BSF    19.7
7EEA:  BCF    FF2.7
7EEC:  MOVLW  0D
7EEE:  MOVLB  9
7EF0:  MOVWF  x0C
7EF2:  MOVLB  0
7EF4:  CALL   1620
7EF8:  BTFSC  19.7
7EFA:  BSF    FF2.7
7EFC:  CLRF   19
7EFE:  BTFSC  FF2.7
7F00:  BSF    19.7
7F02:  BCF    FF2.7
....................    countcard=get_countcard(); 
7F04:  CALL   3534
7F08:  BTFSC  19.7
7F0A:  BSF    FF2.7
7F0C:  MOVFF  02,FE
7F10:  MOVFF  01,FD
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
7F14:  MOVLB  1
7F16:  SETF   x00
7F18:  MOVLB  0
7F1A:  SETF   xFF
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
7F1C:  MOVLW  C7
7F1E:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
7F20:  MOVLW  37
7F22:  MOVWF  FCD
7F24:  CLRF   F9A
7F26:  CLRF   19
7F28:  BTFSC  FF2.7
7F2A:  BSF    19.7
7F2C:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
7F2E:  MOVLB  9
7F30:  CLRF   x1B
7F32:  CLRF   x1A
7F34:  CLRF   x19
7F36:  MOVLW  3C
7F38:  MOVWF  x18
7F3A:  MOVLB  0
7F3C:  CALL   3468
7F40:  BTFSC  19.7
7F42:  BSF    FF2.7
7F44:  MOVFF  01,15A
....................    if(delaycharaction==0)delaycharaction=1; 
7F48:  MOVLB  1
7F4A:  MOVF   x5A,F
7F4C:  BNZ   7F52
7F4E:  MOVLW  01
7F50:  MOVWF  x5A
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
7F52:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
7F54:  BSF    FF0.3
7F56:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
7F58:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
7F5A:  MOVLW  C0
7F5C:  IORWF  FF2,F
....................   
....................     mcr_timeout=10000; 
7F5E:  MOVLB  6
7F60:  CLRF   xC7
7F62:  CLRF   xC6
7F64:  MOVLW  27
7F66:  MOVWF  xC5
7F68:  MOVLW  10
7F6A:  MOVWF  xC4
7F6C:  CLRF   19
7F6E:  BTFSC  FF2.7
7F70:  BSF    19.7
7F72:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
7F74:  MOVLB  9
7F76:  CLRF   x1B
7F78:  CLRF   x1A
7F7A:  CLRF   x19
7F7C:  MOVLW  3A
7F7E:  MOVWF  x18
7F80:  MOVLB  0
7F82:  CALL   3468
7F86:  BTFSC  19.7
7F88:  BSF    FF2.7
7F8A:  MOVFF  01,6E2
7F8E:  CLRF   19
7F90:  BTFSC  FF2.7
7F92:  BSF    19.7
7F94:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
7F96:  MOVLB  9
7F98:  CLRF   x1B
7F9A:  CLRF   x1A
7F9C:  CLRF   x19
7F9E:  MOVLW  3B
7FA0:  MOVWF  x18
7FA2:  MOVLB  0
7FA4:  CALL   3468
7FA8:  BTFSC  19.7
7FAA:  BSF    FF2.7
7FAC:  MOVFF  01,6D6
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
7FB0:  MOVLB  1
7FB2:  SETF   x00
7FB4:  MOVLB  0
7FB6:  SETF   xFF
7FB8:  CLRF   19
7FBA:  BTFSC  FF2.7
7FBC:  BSF    19.7
7FBE:  BCF    FF2.7
....................     
....................    EEPROM_read(strobe_nameconsole,wide_strobe_nameconsole,console); 
7FC0:  MOVLB  9
7FC2:  CLRF   x07
7FC4:  CLRF   x06
7FC6:  CLRF   x05
7FC8:  MOVLW  28
7FCA:  MOVWF  x04
7FCC:  CLRF   x0B
7FCE:  CLRF   x0A
7FD0:  CLRF   x09
7FD2:  MOVLW  10
7FD4:  MOVWF  x08
7FD6:  MOVLW  06
7FD8:  MOVWF  x0D
7FDA:  MOVLW  E7
7FDC:  MOVWF  x0C
7FDE:  MOVLB  0
7FE0:  CALL   4086
7FE4:  BTFSC  19.7
7FE6:  BSF    FF2.7
....................    set_tris_a(0xff);  
7FE8:  MOVLW  FF
7FEA:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
7FEC:  MOVLW  E0
7FEE:  MOVLB  F
7FF0:  MOVWF  x48
7FF2:  BCF    FC2.6
7FF4:  BCF    FC2.7
7FF6:  MOVF   x49,W
7FF8:  ANDLW  E0
7FFA:  IORLW  1F
7FFC:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
7FFE:  MOVF   FC1,W
8000:  ANDLW  C0
8002:  IORLW  03
8004:  MOVWF  FC1
8006:  BCF    FC1.7
8008:  BSF    FC2.0
800A:  BSF    FC1.6
800C:  BSF    FC2.1
800E:  BTFSC  FC2.1
8010:  BRA    800E
8012:  BCF    FC1.6
8014:  CLRF   19
8016:  BTFSC  FF2.7
8018:  BSF    19.7
801A:  BCF    FF2.7
....................     
....................    type_KB=read_ext_eeprom(kindofKB); 
801C:  MOVLB  9
801E:  CLRF   x1B
8020:  CLRF   x1A
8022:  CLRF   x19
8024:  MOVLW  3D
8026:  MOVWF  x18
8028:  MOVLB  0
802A:  CALL   3468
802E:  BTFSC  19.7
8030:  BSF    FF2.7
8032:  MOVFF  01,149
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
8036:  MOVLB  1
8038:  MOVF   x49,F
803A:  BZ    805A
803C:  MOVLW  CE
803E:  MOVWF  FF6
8040:  MOVLW  5B
8042:  MOVWF  FF7
8044:  CLRF   19
8046:  BTFSC  FF2.7
8048:  BSF    19.7
804A:  BCF    FF2.7
804C:  MOVLB  0
804E:  CALL   174A
8052:  BTFSC  19.7
8054:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
8056:  BRA    8074
8058:  MOVLB  1
805A:  MOVLW  E2
805C:  MOVWF  FF6
805E:  MOVLW  5B
8060:  MOVWF  FF7
8062:  CLRF   19
8064:  BTFSC  FF2.7
8066:  BSF    19.7
8068:  BCF    FF2.7
806A:  MOVLB  0
806C:  CALL   174A
8070:  BTFSC  19.7
8072:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
8074:  MOVLB  6
8076:  MOVF   xE2,F
8078:  BNZ   8098
807A:  MOVLW  F6
807C:  MOVWF  FF6
807E:  MOVLW  5B
8080:  MOVWF  FF7
8082:  CLRF   19
8084:  BTFSC  FF2.7
8086:  BSF    19.7
8088:  BCF    FF2.7
808A:  MOVLB  0
808C:  CALL   174A
8090:  BTFSC  19.7
8092:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
8094:  BRA    80B2
8096:  MOVLB  6
8098:  MOVLW  10
809A:  MOVWF  FF6
809C:  MOVLW  5C
809E:  MOVWF  FF7
80A0:  CLRF   19
80A2:  BTFSC  FF2.7
80A4:  BSF    19.7
80A6:  BCF    FF2.7
80A8:  MOVLB  0
80AA:  CALL   174A
80AE:  BTFSC  19.7
80B0:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
80B2:  MOVLW  01
80B4:  MOVWF  FEA
80B6:  MOVLW  4A
80B8:  MOVWF  FE9
80BA:  CLRF   00
80BC:  CLRF   02
80BE:  MOVLW  10
80C0:  MOVWF  01
80C2:  CALL   35AE
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
80C6:  MOVLB  7
80C8:  CLRF   x01
80CA:  MOVF   x01,W
80CC:  SUBLW  13
80CE:  BNC   80E4
....................    { 
....................       password[i] = 0; 
80D0:  CLRF   03
80D2:  MOVF   x01,W
80D4:  ADDLW  55
80D6:  MOVWF  FE9
80D8:  MOVLW  00
80DA:  ADDWFC 03,W
80DC:  MOVWF  FEA
80DE:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 0 
....................    disable_interrupts(GLOBAL); 
....................    save_coutcard(0); 
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................     
....................    save_key_encrypt(); 
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
....................     
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_data in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_key in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],1); 
....................    //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rdecrypted:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    while(1); 
.................... #endif 
.................... #if 0 
80E0:  INCF   x01,F
80E2:  BRA    80CA
80E4:  CLRF   19
80E6:  BTFSC  FF2.7
80E8:  BSF    19.7
80EA:  BCF    FF2.7
....................     fprintf(COM2,"\n\reeprom test\n\r"); 
....................     fprintf(COM2,"\n\reeprom is writing\n\r"); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         //write_ext_eeprom(115535+i,i); 
....................     } 
....................     write_ext_eeprom(EEPROM_KEY_ST,210); 
....................     write_ext_eeprom(EEPROM_SIZE_endofkey,123); 
....................     fprintf(COM2,"\n\r"); 
....................     fprintf(COM2,"eeprom is reading: %u",read_ext_eeprom(EEPROM_KEY_ST)); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         fprintf(COM2," %u",read_ext_eeprom(115535+i)); 
....................     } 
....................     while(1); 
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
80EC:  MOVLB  9
80EE:  CLRF   x07
80F0:  CLRF   x06
80F2:  CLRF   x05
80F4:  CLRF   x04
80F6:  CLRF   x0B
80F8:  CLRF   x0A
80FA:  CLRF   x09
80FC:  MOVLW  14
80FE:  MOVWF  x08
8100:  CLRF   x0D
8102:  MOVLW  55
8104:  MOVWF  x0C
8106:  MOVLB  0
8108:  CALL   4086
810C:  BTFSC  19.7
810E:  BSF    FF2.7
8110:  CLRF   19
8112:  BTFSC  FF2.7
8114:  BSF    19.7
8116:  BCF    FF2.7
....................    cryption_enable = read_ext_eeprom(crypto_en); 
8118:  MOVLB  9
811A:  CLRF   x1B
811C:  CLRF   x1A
811E:  CLRF   x19
8120:  MOVLW  3E
8122:  MOVWF  x18
8124:  MOVLB  0
8126:  CALL   3468
812A:  BTFSC  19.7
812C:  BSF    FF2.7
812E:  MOVFF  01,122
....................    if(cryption_enable!=0) 
8132:  MOVLB  1
8134:  MOVF   x22,F
8136:  BZ    8184
....................    { 
....................         fprintf(COM2,"\n\crypto is enable\n\r"); 
8138:  MOVLW  28
813A:  MOVWF  FF6
813C:  MOVLW  5C
813E:  MOVWF  FF7
8140:  CLRF   19
8142:  BTFSC  FF2.7
8144:  BSF    19.7
8146:  BCF    FF2.7
8148:  MOVLB  0
814A:  CALL   174A
814E:  BTFSC  19.7
8150:  BSF    FF2.7
8152:  CLRF   19
8154:  BTFSC  FF2.7
8156:  BSF    19.7
8158:  BCF    FF2.7
....................         EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key);  
815A:  MOVLB  9
815C:  CLRF   x07
815E:  CLRF   x06
8160:  CLRF   x05
8162:  MOVLW  3F
8164:  MOVWF  x04
8166:  CLRF   x0B
8168:  CLRF   x0A
816A:  CLRF   x09
816C:  MOVLW  20
816E:  MOVWF  x08
8170:  MOVLW  01
8172:  MOVWF  x0D
8174:  MOVWF  x0C
8176:  MOVLB  0
8178:  CALL   4086
817C:  BTFSC  19.7
817E:  BSF    FF2.7
....................    } 
....................    else 
8180:  BRA    819E
8182:  MOVLB  1
....................    { 
....................        fprintf(COM2,"\n\crypto is disable\n\r"); 
8184:  MOVLW  3C
8186:  MOVWF  FF6
8188:  MOVLW  5C
818A:  MOVWF  FF7
818C:  CLRF   19
818E:  BTFSC  FF2.7
8190:  BSF    19.7
8192:  BCF    FF2.7
8194:  MOVLB  0
8196:  CALL   174A
819A:  BTFSC  19.7
819C:  BSF    FF2.7
....................    } 
.................... #if 0    
....................    fprintf(COM2,"\n\crypto key:\n\r"); 
....................    for(i=0;i<CRYPTO_KEY_SIZE;i++) 
....................    { 
....................         fprintf(COM2,"%c",crypto_key[i]); 
....................    } 
....................    fprintf(COM2,"\n\r"); 
.................... #endif    
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
819E:  MOVLB  6
81A0:  MOVF   xDC,F
81A2:  BNZ   825A
....................       { 
....................          fprintf(COM2,"password:"); 
81A4:  MOVLW  52
81A6:  MOVWF  FF6
81A8:  MOVLW  5C
81AA:  MOVWF  FF7
81AC:  CLRF   19
81AE:  BTFSC  FF2.7
81B0:  BSF    19.7
81B2:  BCF    FF2.7
81B4:  MOVLB  0
81B6:  CALL   174A
81BA:  BTFSC  19.7
81BC:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
81BE:  MOVLW  02
81C0:  MOVLB  7
81C2:  MOVWF  xF3
81C4:  MOVLW  14
81C6:  MOVWF  xF4
81C8:  MOVLW  01
81CA:  MOVWF  xF6
81CC:  MOVLW  62
81CE:  MOVWF  xF5
81D0:  MOVLB  0
81D2:  CALL   5ED2
81D6:  CLRF   19
81D8:  BTFSC  FF2.7
81DA:  BSF    19.7
81DC:  BCF    FF2.7
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
81DE:  MOVLB  9
81E0:  CLRF   x07
81E2:  CLRF   x06
81E4:  CLRF   x05
81E6:  CLRF   x04
81E8:  CLRF   x0B
81EA:  CLRF   x0A
81EC:  CLRF   x09
81EE:  MOVLW  14
81F0:  MOVWF  x08
81F2:  CLRF   x0D
81F4:  MOVLW  55
81F6:  MOVWF  x0C
81F8:  MOVLB  0
81FA:  CALL   4086
81FE:  BTFSC  19.7
8200:  BSF    FF2.7
....................          if(!stringcomp(buffer_uart,password)) 
8202:  MOVLW  01
8204:  MOVLB  7
8206:  MOVWF  xF4
8208:  MOVLW  62
820A:  MOVWF  xF3
820C:  CLRF   xF6
820E:  MOVLW  55
8210:  MOVWF  xF5
8212:  MOVLB  0
8214:  CALL   600A
8218:  MOVF   01,F
821A:  BNZ   823E
....................          { 
....................             mode=LOGON; 
821C:  MOVLW  01
821E:  MOVLB  6
8220:  MOVWF  xDC
....................             fprintf(COM2," OK\n\r"); 
8222:  MOVLW  5C
8224:  MOVWF  FF6
8226:  MOVLW  5C
8228:  MOVWF  FF7
822A:  CLRF   19
822C:  BTFSC  FF2.7
822E:  BSF    19.7
8230:  BCF    FF2.7
8232:  MOVLB  0
8234:  CALL   174A
8238:  BTFSC  19.7
823A:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
823C:  BRA    8256
823E:  MOVLW  62
8240:  MOVWF  FF6
8242:  MOVLW  5C
8244:  MOVWF  FF7
8246:  CLRF   19
8248:  BTFSC  FF2.7
824A:  BSF    19.7
824C:  BCF    FF2.7
824E:  CALL   174A
8252:  BTFSC  19.7
8254:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
8256:  BRA    8264
8258:  MOVLB  6
825A:  DECFSZ xDC,W
825C:  BRA    8266
825E:  MOVLB  0
8260:  GOTO   6A32
8264:  MOVLB  6
....................    } 
8266:  BRA    81A0
.................... } 
8268:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

CCS PCH C Compiler, Version 4.140, 8863               20-Jul-18 16:53

               Filename:   E:\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   35932 bytes (55%)
                           Largest free fragment is 29592
               RAM used:   1955 (52%) at main() level
                           2298 (61%) worst case
               Stack:     11 worst case (6 in main + 5 for interrupts)

*
0000:  GOTO   8512
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   40C6
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   19B8
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0436:  MOVLW  02
0438:  MOVLB  8
043A:  SUBWF  xBD,F
043C:  BNC   0456
043E:  MOVLW  08
0440:  MOVWF  FEA
0442:  MOVLW  BD
0444:  MOVWF  FE9
0446:  MOVF   FEF,W
0448:  BZ    0456
044A:  BRA    0452
044C:  BRA    044E
044E:  BRA    0450
0450:  NOP   
0452:  DECFSZ FEF,F
0454:  BRA    044C
0456:  MOVLB  0
0458:  GOTO   19C8 (RETURN)
*
1686:  MOVLW  08
1688:  MOVWF  FEA
168A:  MOVLW  C5
168C:  MOVWF  FE9
168E:  MOVF   FEF,W
1690:  BZ    16AC
1692:  MOVLW  0A
1694:  MOVWF  01
1696:  CLRF   00
1698:  DECFSZ 00,F
169A:  BRA    1698
169C:  DECFSZ 01,F
169E:  BRA    1696
16A0:  MOVLW  5F
16A2:  MOVWF  00
16A4:  DECFSZ 00,F
16A6:  BRA    16A4
16A8:  DECFSZ FEF,F
16AA:  BRA    1692
16AC:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
045C:  BCF    F94.0
045E:  BCF    F8B.0
0460:  MOVLW  08
0462:  MOVWF  01
0464:  BRA    0466
0466:  NOP   
0468:  BSF    01.7
046A:  BRA    048C
046C:  BCF    01.7
046E:  MOVLB  8
0470:  RRCF   xE8,F
0472:  MOVLB  0
0474:  BTFSC  FD8.0
0476:  BSF    F8B.0
0478:  BTFSS  FD8.0
047A:  BCF    F8B.0
047C:  BSF    01.6
047E:  BRA    048C
0480:  BCF    01.6
0482:  DECFSZ 01,F
0484:  BRA    046E
0486:  BRA    0488
0488:  NOP   
048A:  BSF    F8B.0
048C:  MOVLW  10
048E:  MOVWF  FE9
0490:  DECFSZ FE9,F
0492:  BRA    0490
0494:  BRA    0496
0496:  NOP   
0498:  BTFSC  01.7
049A:  BRA    046C
049C:  BTFSC  01.6
049E:  BRA    0480
04A0:  RETURN 0
*
6604:  BSF    F94.1
6606:  BTFSC  F82.1
6608:  BRA    6606
660A:  MOVLW  08
660C:  MOVWF  00
660E:  MOVLB  7
6610:  CLRF   xE0
6612:  BSF    00.7
6614:  BRA    6636
6616:  BCF    00.7
6618:  BRA    6636
661A:  MOVFF  7E0,02
661E:  BCF    FD8.0
6620:  BTFSC  F82.1
6622:  BSF    FD8.0
6624:  RRCF   02,F
6626:  BSF    00.6
6628:  BRA    6636
662A:  BCF    00.6
662C:  DECFSZ 00,F
662E:  BRA    661E
6630:  MOVFF  02,01
6634:  BRA    664E
6636:  MOVLW  10
6638:  BTFSC  00.7
663A:  MOVLW  04
663C:  MOVWF  01
663E:  DECFSZ 01,F
6640:  BRA    663E
6642:  BRA    6644
6644:  BTFSC  00.7
6646:  BRA    6616
6648:  BTFSC  00.6
664A:  BRA    662A
664C:  BRA    661E
664E:  MOVLB  0
6650:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3236:  MOVLW  08
3238:  MOVWF  01
323A:  MOVLW  0A
323C:  MOVWF  00
323E:  DECFSZ 00,F
3240:  BRA    323E
3242:  BCF    F8B.3
3244:  BCF    F94.3
3246:  MOVLW  0B
3248:  MOVWF  00
324A:  DECFSZ 00,F
324C:  BRA    324A
324E:  MOVLB  8
3250:  RLCF   xDC,F
3252:  BCF    F8B.4
3254:  BTFSC  FD8.0
3256:  BSF    F94.4
3258:  BTFSS  FD8.0
325A:  BCF    F94.4
325C:  BSF    F94.3
325E:  BTFSS  F82.3
3260:  BRA    325E
3262:  DECFSZ 01,F
3264:  BRA    3268
3266:  BRA    326C
3268:  MOVLB  0
326A:  BRA    323A
326C:  MOVLW  0A
326E:  MOVWF  00
3270:  DECFSZ 00,F
3272:  BRA    3270
3274:  BCF    F8B.3
3276:  BCF    F94.3
3278:  NOP   
327A:  BSF    F94.4
327C:  MOVLW  0B
327E:  MOVWF  00
3280:  DECFSZ 00,F
3282:  BRA    3280
3284:  MOVLW  0B
3286:  MOVWF  00
3288:  DECFSZ 00,F
328A:  BRA    3288
328C:  BSF    F94.3
328E:  BTFSS  F82.3
3290:  BRA    328E
3292:  CLRF   01
3294:  MOVLW  0B
3296:  MOVWF  00
3298:  DECFSZ 00,F
329A:  BRA    3298
329C:  BTFSC  F82.4
329E:  BSF    01.0
32A0:  BCF    F8B.3
32A2:  BCF    F94.3
32A4:  BCF    F8B.4
32A6:  BCF    F94.4
32A8:  MOVLB  0
32AA:  RETURN 0
32AC:  MOVLW  08
32AE:  MOVLB  8
32B0:  MOVWF  xCF
32B2:  MOVFF  00,8D0
32B6:  BSF    F94.4
32B8:  MOVLW  0B
32BA:  MOVWF  00
32BC:  DECFSZ 00,F
32BE:  BRA    32BC
32C0:  BSF    F94.3
32C2:  BTFSS  F82.3
32C4:  BRA    32C2
32C6:  BTFSC  F82.4
32C8:  BSF    FD8.0
32CA:  BTFSS  F82.4
32CC:  BCF    FD8.0
32CE:  RLCF   01,F
32D0:  MOVLW  0A
32D2:  MOVWF  00
32D4:  DECFSZ 00,F
32D6:  BRA    32D4
32D8:  BCF    F94.3
32DA:  BCF    F8B.3
32DC:  DECFSZ xCF,F
32DE:  BRA    32B6
32E0:  BSF    F94.4
32E2:  MOVLW  0B
32E4:  MOVWF  00
32E6:  DECFSZ 00,F
32E8:  BRA    32E6
32EA:  BCF    F8B.4
32EC:  MOVF   xD0,W
32EE:  BTFSS  FD8.2
32F0:  BCF    F94.4
32F2:  NOP   
32F4:  BSF    F94.3
32F6:  BTFSS  F82.3
32F8:  BRA    32F6
32FA:  MOVLW  0A
32FC:  MOVWF  00
32FE:  DECFSZ 00,F
3300:  BRA    32FE
3302:  BCF    F8B.3
3304:  BCF    F94.3
3306:  MOVLW  0B
3308:  MOVWF  00
330A:  DECFSZ 00,F
330C:  BRA    330A
330E:  BCF    F8B.4
3310:  BCF    F94.4
3312:  MOVLB  0
3314:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE_key    131071 
.................... #define EEPROM_SIZE        115470 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
43AC:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
43AE:  BSF    F94.4
....................    port_b_pullups(0xff); 
43B0:  BCF    FF1.7
.................... } 
43B2:  GOTO   864C (RETURN)
.................... /* 
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
....................    if(address<0xffff)i2c_write(0xa0); 
....................       else if(address>=0xffff) i2c_write(0xa2); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
....................    i2c_start(); 
....................    status=i2c_write(0xa0); 
....................    while(status==1) 
....................    { 
....................       i2c_start(); 
....................       status=i2c_write(0xa0); 
....................    } 
....................    i2c_stop(); 
.................... } 
.................... */ 
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3866:  MOVLB  8
3868:  MOVF   xD3,F
386A:  BNZ   3872
386C:  MOVF   xD2,W
386E:  SUBLW  00
3870:  BC    3878
3872:  MOVLW  A8
3874:  MOVWF  xD6
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3876:  BRA    387C
3878:  MOVLW  A0
387A:  MOVWF  xD6
....................  
....................    i2c_start(); 
387C:  BSF    F94.4
387E:  MOVLW  0A
3880:  MOVWF  00
3882:  DECFSZ 00,F
3884:  BRA    3882
3886:  BSF    F94.3
3888:  MOVLW  0B
388A:  MOVWF  00
388C:  DECFSZ 00,F
388E:  BRA    388C
3890:  BCF    F8B.4
3892:  BCF    F94.4
3894:  MOVLW  0A
3896:  MOVWF  00
3898:  DECFSZ 00,F
389A:  BRA    3898
389C:  BCF    F8B.3
389E:  BCF    F94.3
....................    i2c_write(command); 
38A0:  MOVFF  8D6,8DC
38A4:  MOVLB  0
38A6:  RCALL  3236
....................    i2c_write(address>>8); 
38A8:  MOVFF  8D1,8D8
38AC:  MOVFF  8D2,8D9
38B0:  MOVFF  8D3,8DA
38B4:  MOVLB  8
38B6:  CLRF   xDB
38B8:  MOVFF  8D1,8DC
38BC:  MOVLB  0
38BE:  RCALL  3236
....................    i2c_write(address); 
38C0:  MOVFF  8D0,8DC
38C4:  RCALL  3236
....................    i2c_write(data); 
38C6:  MOVFF  8D4,8DC
38CA:  RCALL  3236
....................  
....................    i2c_stop(); 
38CC:  BCF    F94.4
38CE:  NOP   
38D0:  BSF    F94.3
38D2:  BTFSS  F82.3
38D4:  BRA    38D2
38D6:  MOVLW  0A
38D8:  MOVWF  00
38DA:  DECFSZ 00,F
38DC:  BRA    38DA
38DE:  BRA    38E0
38E0:  NOP   
38E2:  BSF    F94.4
38E4:  MOVLW  0A
38E6:  MOVWF  00
38E8:  DECFSZ 00,F
38EA:  BRA    38E8
....................    i2c_start(); 
38EC:  BSF    F94.4
38EE:  MOVLW  0A
38F0:  MOVWF  00
38F2:  DECFSZ 00,F
38F4:  BRA    38F2
38F6:  BSF    F94.3
38F8:  MOVLW  0B
38FA:  MOVWF  00
38FC:  DECFSZ 00,F
38FE:  BRA    38FC
3900:  BCF    F8B.4
3902:  BCF    F94.4
3904:  MOVLW  0A
3906:  MOVWF  00
3908:  DECFSZ 00,F
390A:  BRA    3908
390C:  BCF    F8B.3
390E:  BCF    F94.3
....................    status=i2c_write(command); 
3910:  MOVFF  8D6,8DC
3914:  RCALL  3236
3916:  MOVF   01,W
3918:  MOVLB  8
391A:  BCF    xD5.0
391C:  BTFSC  01.0
391E:  BSF    xD5.0
....................    while(status==1) 
....................    { 
3920:  BTFSS  xD5.0
3922:  BRA    3960
....................       i2c_start(); 
3924:  BSF    F94.4
3926:  MOVLW  0A
3928:  MOVWF  00
392A:  DECFSZ 00,F
392C:  BRA    392A
392E:  BSF    F94.3
3930:  MOVLW  0B
3932:  MOVWF  00
3934:  DECFSZ 00,F
3936:  BRA    3934
3938:  BTFSS  F82.3
393A:  BRA    3938
393C:  BCF    F8B.4
393E:  BCF    F94.4
3940:  MOVLW  0A
3942:  MOVWF  00
3944:  DECFSZ 00,F
3946:  BRA    3944
3948:  BCF    F8B.3
394A:  BCF    F94.3
....................       status=i2c_write(command); 
394C:  MOVFF  8D6,8DC
3950:  MOVLB  0
3952:  RCALL  3236
3954:  MOVF   01,W
3956:  MOVLB  8
3958:  BCF    xD5.0
395A:  BTFSC  01.0
395C:  BSF    xD5.0
....................    } 
395E:  BRA    3920
....................    //delay_us(100); 
.................... } 
3960:  MOVLB  0
3962:  RETURN 0
....................  
.................... /* 
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(0xa1); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    return(data); 
.................... } 
.................... */ 
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3316:  MOVLB  8
3318:  MOVF   xCB,F
331A:  BNZ   3322
331C:  MOVF   xCA,W
331E:  SUBLW  00
3320:  BC    3328
3322:  MOVLW  A8
3324:  MOVWF  xCD
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3326:  BRA    332C
3328:  MOVLW  A0
332A:  MOVWF  xCD
....................  
....................    i2c_start(); 
332C:  BSF    F94.4
332E:  MOVLW  0A
3330:  MOVWF  00
3332:  DECFSZ 00,F
3334:  BRA    3332
3336:  BSF    F94.3
3338:  MOVLW  0B
333A:  MOVWF  00
333C:  DECFSZ 00,F
333E:  BRA    333C
3340:  BTFSS  F82.3
3342:  BRA    3340
3344:  BCF    F8B.4
3346:  BCF    F94.4
3348:  MOVLW  0A
334A:  MOVWF  00
334C:  DECFSZ 00,F
334E:  BRA    334C
3350:  BCF    F8B.3
3352:  BCF    F94.3
....................    i2c_write(command); 
3354:  MOVFF  8CD,8DC
3358:  MOVLB  0
335A:  RCALL  3236
....................    i2c_write(address>>8); 
335C:  MOVFF  8C9,8CF
3360:  MOVFF  8CA,8D0
3364:  MOVFF  8CB,8D1
3368:  MOVLB  8
336A:  CLRF   xD2
336C:  MOVFF  8C9,8DC
3370:  MOVLB  0
3372:  RCALL  3236
....................    i2c_write(address); 
3374:  MOVFF  8C8,8DC
3378:  RCALL  3236
....................    i2c_start(); 
337A:  BSF    F94.4
337C:  MOVLW  0A
337E:  MOVWF  00
3380:  DECFSZ 00,F
3382:  BRA    3380
3384:  BSF    F94.3
3386:  MOVLW  0B
3388:  MOVWF  00
338A:  DECFSZ 00,F
338C:  BRA    338A
338E:  BTFSS  F82.3
3390:  BRA    338E
3392:  BCF    F8B.4
3394:  BCF    F94.4
3396:  MOVLW  0A
3398:  MOVWF  00
339A:  DECFSZ 00,F
339C:  BRA    339A
339E:  BCF    F8B.3
33A0:  BCF    F94.3
....................    i2c_write(command+1); 
33A2:  MOVLW  01
33A4:  MOVLB  8
33A6:  ADDWF  xCD,W
33A8:  MOVWF  xCE
33AA:  MOVWF  xDC
33AC:  MOVLB  0
33AE:  RCALL  3236
....................    data=i2c_read(0); 
33B0:  CLRF   00
33B2:  RCALL  32AC
33B4:  MOVFF  01,8CC
....................    i2c_stop(); 
33B8:  BCF    F94.4
33BA:  NOP   
33BC:  BSF    F94.3
33BE:  BTFSS  F82.3
33C0:  BRA    33BE
33C2:  MOVLW  0A
33C4:  MOVWF  00
33C6:  DECFSZ 00,F
33C8:  BRA    33C6
33CA:  BRA    33CC
33CC:  NOP   
33CE:  BSF    F94.4
33D0:  MOVLW  0A
33D2:  MOVWF  00
33D4:  DECFSZ 00,F
33D6:  BRA    33D4
....................    return(data); 
33D8:  MOVLB  8
33DA:  MOVFF  8CC,01
.................... } 
33DE:  MOVLB  0
33E0:  RETURN 0
....................  
....................  
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
6822:  MOVLB  7
6824:  MOVF   xDB,W
6826:  ADDWF  xD9,W
6828:  MOVF   xDC,W
682A:  ADDWFC xDA,W
682C:  MOVWF  xE2
....................    for(i=0;i<len;i++) 
682E:  CLRF   xE0
6830:  CLRF   xDF
6832:  MOVF   xE0,W
6834:  SUBWF  xDC,W
6836:  BNC   6892
6838:  BNZ   6840
683A:  MOVF   xDB,W
683C:  SUBWF  xDF,W
683E:  BC    6892
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
6840:  MOVF   xDD,W
6842:  ADDWF  xDF,W
6844:  MOVWF  01
6846:  MOVF   xDE,W
6848:  ADDWFC xE0,W
684A:  MOVWF  03
684C:  MOVFF  01,7E1
6850:  MOVWF  xE2
6852:  MOVF   xDF,W
6854:  ADDWF  xD9,W
6856:  MOVWF  xE3
6858:  MOVF   xE0,W
685A:  ADDWFC xDA,W
685C:  MOVWF  xE4
685E:  CLRF   19
6860:  BTFSC  FF2.7
6862:  BSF    19.7
6864:  BCF    FF2.7
6866:  MOVLB  8
6868:  CLRF   xCB
686A:  CLRF   xCA
686C:  MOVWF  xC9
686E:  MOVFF  7E3,8C8
6872:  MOVLB  0
6874:  CALL   3316
6878:  BTFSC  19.7
687A:  BSF    FF2.7
687C:  MOVFF  7E2,FEA
6880:  MOVFF  7E1,FE9
6884:  MOVFF  01,FEF
....................    } 
6888:  MOVLB  7
688A:  INCF   xDF,F
688C:  BTFSC  FD8.2
688E:  INCF   xE0,F
6890:  BRA    6832
....................     
.................... } 
6892:  MOVLB  0
6894:  GOTO   7092 (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_mobile_num0        65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_two_number        149 
.................... #define kindofKB                 126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards               930   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
345C:  MOVLB  8
345E:  CLRF   xD1
3460:  MOVF   xCE,W
3462:  SUBWF  xD1,W
3464:  BC    347A
....................    { 
....................       inputdat[i]=0; 
3466:  CLRF   03
3468:  MOVF   xD1,W
346A:  ADDWF  xCF,W
346C:  MOVWF  FE9
346E:  MOVF   xD0,W
3470:  ADDWFC 03,W
3472:  MOVWF  FEA
3474:  CLRF   FEF
....................    } 
3476:  INCF   xD1,F
3478:  BRA    3460
.................... } 
347A:  MOVLB  0
347C:  RETURN 0
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4458:  MOVLB  7
445A:  CLRF   xF9
445C:  CLRF   xF8
445E:  CLRF   xF7
4460:  CLRF   xF6
4462:  MOVF   xF9,W
4464:  SUBWF  xF3,W
4466:  BNC   44EC
4468:  BNZ   4480
446A:  MOVF   xF8,W
446C:  SUBWF  xF2,W
446E:  BNC   44EC
4470:  BNZ   4480
4472:  MOVF   xF7,W
4474:  SUBWF  xF1,W
4476:  BNC   44EC
4478:  BNZ   4480
447A:  MOVF   xF0,W
447C:  SUBWF  xF6,W
447E:  BC    44EC
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4480:  MOVF   xF6,W
4482:  ADDWF  xEC,W
4484:  MOVWF  xFA
4486:  MOVF   xF7,W
4488:  ADDWFC xED,W
448A:  MOVWF  xFB
448C:  MOVF   xF8,W
448E:  ADDWFC xEE,W
4490:  MOVWF  xFC
4492:  MOVF   xF9,W
4494:  ADDWFC xEF,W
4496:  MOVWF  xFD
4498:  MOVF   xF4,W
449A:  ADDWF  xF6,W
449C:  MOVWF  FE9
449E:  MOVF   xF5,W
44A0:  ADDWFC xF7,W
44A2:  MOVWF  FEA
44A4:  MOVFF  FEF,7FE
44A8:  CLRF   19
44AA:  BTFSC  FF2.7
44AC:  BSF    19.7
44AE:  BCF    FF2.7
44B0:  MOVFF  7FD,8D3
44B4:  MOVFF  7FC,8D2
44B8:  MOVFF  7FB,8D1
44BC:  MOVFF  7FA,8D0
44C0:  MOVFF  7FE,8D4
44C4:  MOVLB  0
44C6:  CALL   3866
44CA:  BTFSC  19.7
44CC:  BSF    FF2.7
....................       delay_us(10); 
44CE:  MOVLW  1A
44D0:  MOVWF  00
44D2:  DECFSZ 00,F
44D4:  BRA    44D2
44D6:  NOP   
....................    } 
44D8:  MOVLW  01
44DA:  MOVLB  7
44DC:  ADDWF  xF6,F
44DE:  BTFSC  FD8.0
44E0:  INCF   xF7,F
44E2:  BTFSC  FD8.2
44E4:  INCF   xF8,F
44E6:  BTFSC  FD8.2
44E8:  INCF   xF9,F
44EA:  BRA    4462
....................    return 1; 
44EC:  MOVLW  01
44EE:  MOVWF  01
.................... } 
44F0:  MOVLB  0
44F2:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
43B6:  MOVLB  7
43B8:  CLRF   xE4
43BA:  CLRF   xE3
43BC:  CLRF   xE2
43BE:  CLRF   xE1
43C0:  MOVF   xE4,W
43C2:  SUBWF  xDE,W
43C4:  BNC   4454
43C6:  BNZ   43DE
43C8:  MOVF   xE3,W
43CA:  SUBWF  xDD,W
43CC:  BNC   4454
43CE:  BNZ   43DE
43D0:  MOVF   xE2,W
43D2:  SUBWF  xDC,W
43D4:  BNC   4454
43D6:  BNZ   43DE
43D8:  MOVF   xDB,W
43DA:  SUBWF  xE1,W
43DC:  BC    4454
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
43DE:  MOVF   xDF,W
43E0:  ADDWF  xE1,W
43E2:  MOVWF  01
43E4:  MOVF   xE0,W
43E6:  ADDWFC xE2,W
43E8:  MOVWF  03
43EA:  MOVFF  01,7E5
43EE:  MOVWF  xE6
43F0:  MOVF   xE1,W
43F2:  ADDWF  xD7,W
43F4:  MOVWF  xE7
43F6:  MOVF   xE2,W
43F8:  ADDWFC xD8,W
43FA:  MOVWF  xE8
43FC:  MOVF   xE3,W
43FE:  ADDWFC xD9,W
4400:  MOVWF  xE9
4402:  MOVF   xE4,W
4404:  ADDWFC xDA,W
4406:  MOVWF  xEA
4408:  CLRF   19
440A:  BTFSC  FF2.7
440C:  BSF    19.7
440E:  BCF    FF2.7
4410:  MOVFF  FE8,8CB
4414:  MOVFF  7E9,8CA
4418:  MOVFF  7E8,8C9
441C:  MOVFF  7E7,8C8
4420:  MOVLB  0
4422:  CALL   3316
4426:  BTFSC  19.7
4428:  BSF    FF2.7
442A:  MOVFF  7E6,FEA
442E:  MOVFF  7E5,FE9
4432:  MOVFF  01,FEF
....................       delay_us(10); 
4436:  MOVLW  1A
4438:  MOVWF  00
443A:  DECFSZ 00,F
443C:  BRA    443A
443E:  NOP   
....................    } 
4440:  MOVLW  01
4442:  MOVLB  7
4444:  ADDWF  xE1,F
4446:  BTFSC  FD8.0
4448:  INCF   xE2,F
444A:  BTFSC  FD8.2
444C:  INCF   xE3,F
444E:  BTFSC  FD8.2
4450:  INCF   xE4,F
4452:  BRA    43C0
.................... } 
4454:  MOVLB  0
4456:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
475E:  MOVLB  7
4760:  CLRF   xA5
4762:  CLRF   xA4
4764:  CLRF   xA3
4766:  CLRF   xA2
4768:  CLRF   xA9
476A:  CLRF   xA8
476C:  CLRF   xA7
476E:  CLRF   xA6
4770:  CLRF   xAD
4772:  CLRF   xAC
4774:  CLRF   xAB
4776:  CLRF   xAA
4778:  CLRF   xB1
477A:  CLRF   xB0
477C:  CLRF   xAF
477E:  CLRF   xAE
4780:  CLRF   xB5
4782:  CLRF   xB4
4784:  CLRF   xB3
4786:  CLRF   xB2
4788:  CLRF   19
478A:  BTFSC  FF2.7
478C:  BSF    19.7
478E:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
4790:  MOVLB  8
4792:  CLRF   xCB
4794:  CLRF   xCA
4796:  CLRF   xC9
4798:  MOVFF  7A1,8C8
479C:  MOVLB  0
479E:  CALL   3316
47A2:  BTFSC  19.7
47A4:  BSF    FF2.7
47A6:  MOVLB  7
47A8:  MOVFF  01,7A6
47AC:  CLRF   xA7
47AE:  CLRF   xA8
47B0:  CLRF   xA9
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
47B2:  MOVLW  01
47B4:  ADDWF  xA1,W
47B6:  MOVWF  xB6
47B8:  CLRF   19
47BA:  BTFSC  FF2.7
47BC:  BSF    19.7
47BE:  BCF    FF2.7
47C0:  MOVLB  8
47C2:  CLRF   xCB
47C4:  CLRF   xCA
47C6:  CLRF   xC9
47C8:  MOVWF  xC8
47CA:  MOVLB  0
47CC:  CALL   3316
47D0:  BTFSC  19.7
47D2:  BSF    FF2.7
47D4:  MOVLB  7
47D6:  CLRF   xAD
47D8:  CLRF   xAC
47DA:  CLRF   xAB
47DC:  MOVFF  01,7AA
....................    temp2<<=8; 
47E0:  MOVFF  7AC,7AD
47E4:  MOVFF  7AB,7AC
47E8:  MOVFF  7AA,7AB
47EC:  CLRF   xAA
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
47EE:  MOVLW  02
47F0:  ADDWF  xA1,W
47F2:  MOVWF  xB6
47F4:  CLRF   19
47F6:  BTFSC  FF2.7
47F8:  BSF    19.7
47FA:  BCF    FF2.7
47FC:  MOVLB  8
47FE:  CLRF   xCB
4800:  CLRF   xCA
4802:  CLRF   xC9
4804:  MOVWF  xC8
4806:  MOVLB  0
4808:  CALL   3316
480C:  BTFSC  19.7
480E:  BSF    FF2.7
4810:  MOVLB  7
4812:  CLRF   xB1
4814:  CLRF   xB0
4816:  CLRF   xAF
4818:  MOVFF  01,7AE
....................    temp3<<=16; 
481C:  MOVFF  7AF,7B1
4820:  MOVFF  7AE,7B0
4824:  CLRF   xAE
4826:  CLRF   xAF
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
4828:  MOVLW  03
482A:  ADDWF  xA1,W
482C:  MOVWF  xB6
482E:  CLRF   19
4830:  BTFSC  FF2.7
4832:  BSF    19.7
4834:  BCF    FF2.7
4836:  MOVLB  8
4838:  CLRF   xCB
483A:  CLRF   xCA
483C:  CLRF   xC9
483E:  MOVWF  xC8
4840:  MOVLB  0
4842:  CALL   3316
4846:  BTFSC  19.7
4848:  BSF    FF2.7
484A:  MOVLB  7
484C:  CLRF   xB5
484E:  CLRF   xB4
4850:  CLRF   xB3
4852:  MOVFF  01,7B2
....................    temp4<<=24; 
4856:  MOVFF  7B2,7B5
485A:  CLRF   xB2
485C:  CLRF   xB3
485E:  CLRF   xB4
....................    buffer = temp4|temp3|temp2|temp1; 
4860:  MOVF   xB2,W
4862:  IORWF  xAE,W
4864:  MOVWF  xB6
4866:  MOVF   xB3,W
4868:  IORWF  xAF,W
486A:  MOVWF  xB7
486C:  MOVF   xB4,W
486E:  IORWF  xB0,W
4870:  MOVWF  xB8
4872:  MOVF   xB5,W
4874:  IORWF  xB1,W
4876:  MOVWF  xB9
4878:  MOVF   xAA,W
487A:  IORWF  xB6,F
487C:  MOVF   xAB,W
487E:  IORWF  xB7,F
4880:  MOVF   xAC,W
4882:  IORWF  xB8,F
4884:  MOVF   xAD,W
4886:  IORWF  xB9,F
4888:  MOVF   xB6,W
488A:  IORWF  xA6,W
488C:  MOVWF  xA2
488E:  MOVF   xB7,W
4890:  IORWF  xA7,W
4892:  MOVWF  xA3
4894:  MOVF   xB8,W
4896:  IORWF  xA8,W
4898:  MOVWF  xA4
489A:  MOVF   xB9,W
489C:  IORWF  xA9,W
489E:  MOVWF  xA5
....................    return(buffer); 
48A0:  MOVFF  7A2,00
48A4:  MOVFF  7A3,01
48A8:  MOVFF  7A4,02
48AC:  MOVFF  7A5,03
.................... } 
48B0:  MOVLB  0
48B2:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3964:  MOVLB  8
3966:  CLRF   xCA
3968:  CLRF   xC9
396A:  CLRF   xC8
396C:  CLRF   xC7
396E:  CLRF   xCB
3970:  CLRF   xCC
3972:  CLRF   xCD
3974:  CLRF   xCE
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3976:  MOVFF  8C5,8CA
397A:  MOVFF  8C4,8C9
397E:  MOVFF  8C3,8C8
3982:  MOVFF  8C2,8C7
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3986:  MOVFF  8C7,8CB
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
398A:  MOVFF  8C8,8CC
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
398E:  MOVFF  8C9,8CD
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3992:  MOVFF  8CA,8CE
....................    write_ext_eeprom((addr+0),temp1); 
3996:  CLRF   xD3
3998:  CLRF   xD2
399A:  CLRF   xD1
399C:  MOVFF  8C6,8D0
39A0:  MOVFF  8CB,8D4
39A4:  MOVLB  0
39A6:  RCALL  3866
....................    write_ext_eeprom((addr+1),temp2); 
39A8:  MOVLW  01
39AA:  MOVLB  8
39AC:  ADDWF  xC6,W
39AE:  MOVWF  xCF
39B0:  CLRF   xD3
39B2:  CLRF   xD2
39B4:  CLRF   xD1
39B6:  MOVWF  xD0
39B8:  MOVFF  8CC,8D4
39BC:  MOVLB  0
39BE:  RCALL  3866
....................    write_ext_eeprom((addr+2),temp3); 
39C0:  MOVLW  02
39C2:  MOVLB  8
39C4:  ADDWF  xC6,W
39C6:  MOVWF  xCF
39C8:  CLRF   xD3
39CA:  CLRF   xD2
39CC:  CLRF   xD1
39CE:  MOVWF  xD0
39D0:  MOVFF  8CD,8D4
39D4:  MOVLB  0
39D6:  RCALL  3866
....................    write_ext_eeprom((addr+3),temp4); 
39D8:  MOVLW  03
39DA:  MOVLB  8
39DC:  ADDWF  xC6,W
39DE:  MOVWF  xCF
39E0:  CLRF   xD3
39E2:  CLRF   xD2
39E4:  CLRF   xD1
39E6:  MOVWF  xD0
39E8:  MOVFF  8CE,8D4
39EC:  MOVLB  0
39EE:  RCALL  3866
.................... } 
39F0:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
3F8E:  MOVLB  8
3F90:  CLRF   xC2
3F92:  CLRF   xC1
3F94:  CLRF   xC3
3F96:  CLRF   xC4
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
3F98:  MOVFF  8C0,8C2
3F9C:  MOVFF  8BF,8C1
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3FA0:  MOVFF  8C1,8C3
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3FA4:  MOVF   xC2,W
3FA6:  MOVWF  xC4
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
3FA8:  CLRF   xD3
3FAA:  CLRF   xD2
3FAC:  CLRF   xD1
3FAE:  MOVLW  28
3FB0:  MOVWF  xD0
3FB2:  MOVFF  8C3,8D4
3FB6:  MOVLB  0
3FB8:  RCALL  3866
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
3FBA:  MOVLB  8
3FBC:  CLRF   xD3
3FBE:  CLRF   xD2
3FC0:  CLRF   xD1
3FC2:  MOVLW  29
3FC4:  MOVWF  xD0
3FC6:  MOVFF  8C4,8D4
3FCA:  MOVLB  0
3FCC:  RCALL  3866
.................... } 
3FCE:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
33E2:  MOVLB  8
33E4:  CLRF   xC3
33E6:  CLRF   xC2
33E8:  CLRF   xC5
33EA:  CLRF   xC4
33EC:  CLRF   xC7
33EE:  CLRF   xC6
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
33F0:  CLRF   xCB
33F2:  CLRF   xCA
33F4:  CLRF   xC9
33F6:  MOVLW  28
33F8:  MOVWF  xC8
33FA:  MOVLB  0
33FC:  RCALL  3316
33FE:  MOVLB  8
3400:  MOVFF  01,8C4
3404:  CLRF   xC5
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3406:  CLRF   xCB
3408:  CLRF   xCA
340A:  CLRF   xC9
340C:  MOVLW  29
340E:  MOVWF  xC8
3410:  MOVLB  0
3412:  RCALL  3316
3414:  MOVLB  8
3416:  CLRF   xC7
3418:  MOVFF  01,8C6
....................    temp2<<=8; 
341C:  MOVFF  8C6,8C7
3420:  CLRF   xC6
....................    buffer = temp2|temp1; 
3422:  MOVF   xC6,W
3424:  IORWF  xC4,W
3426:  MOVWF  xC2
3428:  MOVF   xC7,W
342A:  IORWF  xC5,W
342C:  MOVWF  xC3
....................    return(buffer); 
342E:  MOVFF  8C2,01
3432:  MOVFF  8C3,02
.................... } 
3436:  MOVLB  0
3438:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2,"EEPROM_KEY_ST=%lu\n\r",EEPROM_KEY_ST); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
69B2:  MOVLB  7
69B4:  CLRF   xDA
69B6:  MOVLW  01
69B8:  MOVWF  xD9
69BA:  MOVLW  C3
69BC:  MOVWF  xD8
69BE:  MOVLW  0F
69C0:  MOVWF  xD7
69C2:  MOVF   xDA,W
69C4:  SUBWF  27,W
69C6:  BNC   6A1A
69C8:  BNZ   69E0
69CA:  MOVF   xD9,W
69CC:  SUBWF  26,W
69CE:  BNC   6A1A
69D0:  BNZ   69E0
69D2:  MOVF   xD8,W
69D4:  SUBWF  25,W
69D6:  BNC   6A1A
69D8:  BNZ   69E0
69DA:  MOVF   24,W
69DC:  SUBWF  xD7,W
69DE:  BC    6A1A
69E0:  CLRF   19
69E2:  BTFSC  FF2.7
69E4:  BSF    19.7
69E6:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
69E8:  MOVFF  7DA,8D3
69EC:  MOVFF  7D9,8D2
69F0:  MOVFF  7D8,8D1
69F4:  MOVFF  7D7,8D0
69F8:  MOVLB  8
69FA:  CLRF   xD4
69FC:  MOVLB  0
69FE:  CALL   3866
6A02:  BTFSC  19.7
6A04:  BSF    FF2.7
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    } 
6A06:  MOVLW  01
6A08:  MOVLB  7
6A0A:  ADDWF  xD7,F
6A0C:  BTFSC  FD8.0
6A0E:  INCF   xD8,F
6A10:  BTFSC  FD8.2
6A12:  INCF   xD9,F
6A14:  BTFSC  FD8.2
6A16:  INCF   xDA,F
6A18:  BRA    69C2
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=ptr_start;i<ptr_card;i++) 
6A1A:  CLRF   xDA
6A1C:  CLRF   xD9
6A1E:  CLRF   xD8
6A20:  MOVLW  96
6A22:  MOVWF  xD7
6A24:  MOVF   xDA,W
6A26:  SUBWF  23,W
6A28:  BNC   6A7C
6A2A:  BNZ   6A42
6A2C:  MOVF   xD9,W
6A2E:  SUBWF  22,W
6A30:  BNC   6A7C
6A32:  BNZ   6A42
6A34:  MOVF   xD8,W
6A36:  SUBWF  21,W
6A38:  BNC   6A7C
6A3A:  BNZ   6A42
6A3C:  MOVF   20,W
6A3E:  SUBWF  xD7,W
6A40:  BC    6A7C
6A42:  CLRF   19
6A44:  BTFSC  FF2.7
6A46:  BSF    19.7
6A48:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
6A4A:  MOVFF  7DA,8D3
6A4E:  MOVFF  7D9,8D2
6A52:  MOVFF  7D8,8D1
6A56:  MOVFF  7D7,8D0
6A5A:  MOVLB  8
6A5C:  CLRF   xD4
6A5E:  MOVLB  0
6A60:  CALL   3866
6A64:  BTFSC  19.7
6A66:  BSF    FF2.7
....................    } 
6A68:  MOVLW  01
6A6A:  MOVLB  7
6A6C:  ADDWF  xD7,F
6A6E:  BTFSC  FD8.0
6A70:  INCF   xD8,F
6A72:  BTFSC  FD8.2
6A74:  INCF   xD9,F
6A76:  BTFSC  FD8.2
6A78:  INCF   xDA,F
6A7A:  BRA    6A24
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
6A7C:  CLRF   23
6A7E:  CLRF   22
6A80:  CLRF   21
6A82:  MOVLW  96
6A84:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
6A86:  CLRF   27
6A88:  MOVLW  01
6A8A:  MOVWF  26
6A8C:  MOVLW  C3
6A8E:  MOVWF  25
6A90:  MOVLW  0F
6A92:  MOVWF  24
6A94:  CLRF   19
6A96:  BTFSC  FF2.7
6A98:  BSF    19.7
6A9A:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
6A9C:  MOVFF  23,8C5
6AA0:  MOVFF  22,8C4
6AA4:  MOVFF  21,8C3
6AA8:  MOVFF  20,8C2
6AAC:  MOVLW  19
6AAE:  MOVLB  8
6AB0:  MOVWF  xC6
6AB2:  MOVLB  0
6AB4:  CALL   3964
6AB8:  BTFSC  19.7
6ABA:  BSF    FF2.7
6ABC:  CLRF   19
6ABE:  BTFSC  FF2.7
6AC0:  BSF    19.7
6AC2:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
6AC4:  MOVFF  27,8C5
6AC8:  MOVFF  26,8C4
6ACC:  MOVFF  25,8C3
6AD0:  MOVFF  24,8C2
6AD4:  MOVLW  1E
6AD6:  MOVLB  8
6AD8:  MOVWF  xC6
6ADA:  MOVLB  0
6ADC:  CALL   3964
6AE0:  BTFSC  19.7
6AE2:  BSF    FF2.7
6AE4:  CLRF   19
6AE6:  BTFSC  FF2.7
6AE8:  BSF    19.7
6AEA:  BCF    FF2.7
....................    save_coutcard(0); 
6AEC:  MOVLB  8
6AEE:  CLRF   xC0
6AF0:  CLRF   xBF
6AF2:  MOVLB  0
6AF4:  CALL   3F8E
6AF8:  BTFSC  19.7
6AFA:  BSF    FF2.7
6AFC:  CLRF   19
6AFE:  BTFSC  FF2.7
6B00:  BSF    19.7
6B02:  BCF    FF2.7
....................    countcard=get_countcard(); 
6B04:  CALL   33E2
6B08:  BTFSC  19.7
6B0A:  BSF    FF2.7
6B0C:  MOVFF  02,FA
6B10:  MOVFF  01,F9
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
6B14:  GOTO   7404 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    /*for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    ptr_card=ptr_start; 
6B18:  CLRF   23
6B1A:  CLRF   22
6B1C:  CLRF   21
6B1E:  MOVLW  96
6B20:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
6B22:  CLRF   27
6B24:  MOVLW  01
6B26:  MOVWF  26
6B28:  MOVLW  C3
6B2A:  MOVWF  25
6B2C:  MOVLW  0F
6B2E:  MOVWF  24
6B30:  CLRF   19
6B32:  BTFSC  FF2.7
6B34:  BSF    19.7
6B36:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
6B38:  MOVFF  23,8C5
6B3C:  MOVFF  22,8C4
6B40:  MOVFF  21,8C3
6B44:  MOVFF  20,8C2
6B48:  MOVLW  19
6B4A:  MOVLB  8
6B4C:  MOVWF  xC6
6B4E:  MOVLB  0
6B50:  CALL   3964
6B54:  BTFSC  19.7
6B56:  BSF    FF2.7
6B58:  CLRF   19
6B5A:  BTFSC  FF2.7
6B5C:  BSF    19.7
6B5E:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
6B60:  MOVFF  27,8C5
6B64:  MOVFF  26,8C4
6B68:  MOVFF  25,8C3
6B6C:  MOVFF  24,8C2
6B70:  MOVLW  1E
6B72:  MOVLB  8
6B74:  MOVWF  xC6
6B76:  MOVLB  0
6B78:  CALL   3964
6B7C:  BTFSC  19.7
6B7E:  BSF    FF2.7
6B80:  CLRF   19
6B82:  BTFSC  FF2.7
6B84:  BSF    19.7
6B86:  BCF    FF2.7
....................    save_coutcard(0); 
6B88:  MOVLB  8
6B8A:  CLRF   xC0
6B8C:  CLRF   xBF
6B8E:  MOVLB  0
6B90:  CALL   3F8E
6B94:  BTFSC  19.7
6B96:  BSF    FF2.7
.................... } 
6B98:  GOTO   746A (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
44F4:  MOVLB  7
44F6:  CLRF   xDA
44F8:  CLRF   xD9
44FA:  CLRF   xD8
44FC:  CLRF   xD7
44FE:  CLRF   xDE
4500:  CLRF   xDD
4502:  CLRF   xDC
4504:  MOVLW  14
4506:  MOVWF  xDB
4508:  CLRF   xE0
450A:  MOVLW  55
450C:  MOVWF  xDF
450E:  MOVLB  0
4510:  RCALL  43B6
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
4512:  INCFSZ 55,W
4514:  BRA    4582
4516:  INCFSZ 56,W
4518:  BRA    4582
451A:  INCFSZ x64,W
451C:  BRA    4582
....................       { 
....................          memset(buffer1,0,20); 
451E:  CLRF   FEA
4520:  MOVLW  2D
4522:  MOVWF  FE9
4524:  CLRF   00
4526:  CLRF   02
4528:  MOVLW  14
452A:  MOVWF  01
452C:  RCALL  3DF6
....................          strcpy(buffer1,"admin"); 
452E:  CLRF   FEA
4530:  MOVLW  2D
4532:  MOVWF  FE9
4534:  MOVLW  00
4536:  CALL   00BA
453A:  TBLRD*-
453C:  TBLRD*+
453E:  MOVF   FF5,W
4540:  MOVWF  FEE
4542:  IORLW  00
4544:  BNZ   453C
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
4546:  MOVLB  7
4548:  CLRF   xEF
454A:  CLRF   xEE
454C:  CLRF   xED
454E:  CLRF   xEC
4550:  CLRF   xF3
4552:  CLRF   xF2
4554:  CLRF   xF1
4556:  MOVLW  14
4558:  MOVWF  xF0
455A:  CLRF   xF5
455C:  MOVLW  2D
455E:  MOVWF  xF4
4560:  MOVLB  0
4562:  RCALL  4458
....................          EEPROM_read(strobe_pass_addr,20,password); 
4564:  MOVLB  7
4566:  CLRF   xDA
4568:  CLRF   xD9
456A:  CLRF   xD8
456C:  CLRF   xD7
456E:  CLRF   xDE
4570:  CLRF   xDD
4572:  CLRF   xDC
4574:  MOVLW  14
4576:  MOVWF  xDB
4578:  CLRF   xE0
457A:  MOVLW  55
457C:  MOVWF  xDF
457E:  MOVLB  0
4580:  RCALL  43B6
....................       } 
.................... } 
4582:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
6B9C:  MOVLB  7
6B9E:  CLRF   xEB
6BA0:  MOVF   xEB,W
6BA2:  SUBLW  13
6BA4:  BNC   6BBA
6BA6:  CLRF   03
6BA8:  MOVF   xEB,W
6BAA:  ADDLW  D7
6BAC:  MOVWF  FE9
6BAE:  MOVLW  07
6BB0:  ADDWFC 03,W
6BB2:  MOVWF  FEA
6BB4:  SETF   FEF
6BB6:  INCF   xEB,F
6BB8:  BRA    6BA0
....................    EEPROM_write(strobe_pass_addr,20,buf); 
6BBA:  CLRF   xEF
6BBC:  CLRF   xEE
6BBE:  CLRF   xED
6BC0:  CLRF   xEC
6BC2:  CLRF   xF3
6BC4:  CLRF   xF2
6BC6:  CLRF   xF1
6BC8:  MOVLW  14
6BCA:  MOVWF  xF0
6BCC:  MOVLW  07
6BCE:  MOVWF  xF5
6BD0:  MOVLW  D7
6BD2:  MOVWF  xF4
6BD4:  MOVLB  0
6BD6:  CALL   4458
.................... } 
6BDA:  GOTO   74D0 (RETURN)
.................... //============================================ 
.................... void reset_2nd_number() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0; 
....................    EEPROM_write(strobe_mobile_num0,20,buf); 
.................... } 
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
4584:  BSF    F94.4
4586:  MOVLW  0A
4588:  MOVWF  00
458A:  DECFSZ 00,F
458C:  BRA    458A
458E:  BSF    F94.3
4590:  MOVLW  0B
4592:  MOVWF  00
4594:  DECFSZ 00,F
4596:  BRA    4594
4598:  BCF    F8B.4
459A:  BCF    F94.4
459C:  MOVLW  0A
459E:  MOVWF  00
45A0:  DECFSZ 00,F
45A2:  BRA    45A0
45A4:  BCF    F8B.3
45A6:  BCF    F94.3
45A8:  CLRF   19
45AA:  BTFSC  FF2.7
45AC:  BSF    19.7
45AE:  BCF    FF2.7
....................    i2c_write(0xD0); 
45B0:  MOVLW  D0
45B2:  MOVLB  8
45B4:  MOVWF  xDC
45B6:  MOVLB  0
45B8:  CALL   3236
45BC:  BTFSC  19.7
45BE:  BSF    FF2.7
45C0:  CLRF   19
45C2:  BTFSC  FF2.7
45C4:  BSF    19.7
45C6:  BCF    FF2.7
....................    i2c_write(address); 
45C8:  MOVFF  7DB,8DC
45CC:  CALL   3236
45D0:  BTFSC  19.7
45D2:  BSF    FF2.7
....................    i2c_start(); 
45D4:  BSF    F94.4
45D6:  MOVLW  0A
45D8:  MOVWF  00
45DA:  DECFSZ 00,F
45DC:  BRA    45DA
45DE:  BSF    F94.3
45E0:  MOVLW  0B
45E2:  MOVWF  00
45E4:  DECFSZ 00,F
45E6:  BRA    45E4
45E8:  BTFSS  F82.3
45EA:  BRA    45E8
45EC:  BCF    F8B.4
45EE:  BCF    F94.4
45F0:  MOVLW  0A
45F2:  MOVWF  00
45F4:  DECFSZ 00,F
45F6:  BRA    45F4
45F8:  BCF    F8B.3
45FA:  BCF    F94.3
45FC:  CLRF   19
45FE:  BTFSC  FF2.7
4600:  BSF    19.7
4602:  BCF    FF2.7
....................    i2c_write(0xD1); 
4604:  MOVLW  D1
4606:  MOVLB  8
4608:  MOVWF  xDC
460A:  MOVLB  0
460C:  CALL   3236
4610:  BTFSC  19.7
4612:  BSF    FF2.7
....................    result = i2c_read(0); 
4614:  CLRF   00
4616:  CLRF   19
4618:  BTFSC  FF2.7
461A:  BSF    19.7
461C:  BCF    FF2.7
461E:  CALL   32AC
4622:  BTFSC  19.7
4624:  BSF    FF2.7
4626:  MOVFF  01,7DC
....................    i2c_stop(); 
462A:  BCF    F94.4
462C:  NOP   
462E:  BSF    F94.3
4630:  BTFSS  F82.3
4632:  BRA    4630
4634:  MOVLW  0A
4636:  MOVWF  00
4638:  DECFSZ 00,F
463A:  BRA    4638
463C:  BRA    463E
463E:  NOP   
4640:  BSF    F94.4
4642:  MOVLW  0A
4644:  MOVWF  00
4646:  DECFSZ 00,F
4648:  BRA    4646
....................     
....................    return(result); 
464A:  MOVLB  7
464C:  MOVFF  7DC,01
.................... } 
4650:  MOVLB  0
4652:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
6D8E:  BSF    F94.4
6D90:  MOVLW  0A
6D92:  MOVWF  00
6D94:  DECFSZ 00,F
6D96:  BRA    6D94
6D98:  BSF    F94.3
6D9A:  MOVLW  0B
6D9C:  MOVWF  00
6D9E:  DECFSZ 00,F
6DA0:  BRA    6D9E
6DA2:  BCF    F8B.4
6DA4:  BCF    F94.4
6DA6:  MOVLW  0A
6DA8:  MOVWF  00
6DAA:  DECFSZ 00,F
6DAC:  BRA    6DAA
6DAE:  BCF    F8B.3
6DB0:  BCF    F94.3
....................    delay_us(10); 
6DB2:  MOVLW  1A
6DB4:  MOVWF  00
6DB6:  DECFSZ 00,F
6DB8:  BRA    6DB6
6DBA:  NOP   
6DBC:  CLRF   19
6DBE:  BTFSC  FF2.7
6DC0:  BSF    19.7
6DC2:  BCF    FF2.7
....................    i2c_write(0xD0); 
6DC4:  MOVLW  D0
6DC6:  MOVLB  8
6DC8:  MOVWF  xDC
6DCA:  MOVLB  0
6DCC:  CALL   3236
6DD0:  BTFSC  19.7
6DD2:  BSF    FF2.7
....................    delay_us(10); 
6DD4:  MOVLW  1A
6DD6:  MOVWF  00
6DD8:  DECFSZ 00,F
6DDA:  BRA    6DD8
6DDC:  NOP   
6DDE:  CLRF   19
6DE0:  BTFSC  FF2.7
6DE2:  BSF    19.7
6DE4:  BCF    FF2.7
....................    i2c_write(address); 
6DE6:  MOVFF  7DE,8DC
6DEA:  CALL   3236
6DEE:  BTFSC  19.7
6DF0:  BSF    FF2.7
....................    delay_us(10); 
6DF2:  MOVLW  1A
6DF4:  MOVWF  00
6DF6:  DECFSZ 00,F
6DF8:  BRA    6DF6
6DFA:  NOP   
6DFC:  CLRF   19
6DFE:  BTFSC  FF2.7
6E00:  BSF    19.7
6E02:  BCF    FF2.7
....................    i2c_write(data); 
6E04:  MOVFF  7DF,8DC
6E08:  CALL   3236
6E0C:  BTFSC  19.7
6E0E:  BSF    FF2.7
....................    i2c_stop(); 
6E10:  BCF    F94.4
6E12:  NOP   
6E14:  BSF    F94.3
6E16:  BTFSS  F82.3
6E18:  BRA    6E16
6E1A:  MOVLW  0A
6E1C:  MOVWF  00
6E1E:  DECFSZ 00,F
6E20:  BRA    6E1E
6E22:  BRA    6E24
6E24:  NOP   
6E26:  BSF    F94.4
6E28:  MOVLW  0A
6E2A:  MOVWF  00
6E2C:  DECFSZ 00,F
6E2E:  BRA    6E2C
....................    delay_us(10); 
6E30:  MOVLW  1A
6E32:  MOVWF  00
6E34:  DECFSZ 00,F
6E36:  BRA    6E34
6E38:  NOP   
.................... } 
6E3A:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
*
4654:  MOVLB  7
4656:  CLRF   xDB
4658:  MOVLB  0
465A:  RCALL  4584
465C:  MOVFF  01,7A1
....................     
....................    data &= 0x7F; 
4660:  MOVLB  7
4662:  BCF    xA1.7
....................     
....................    i2c_start(); 
4664:  BSF    F94.4
4666:  MOVLW  0A
4668:  MOVWF  00
466A:  DECFSZ 00,F
466C:  BRA    466A
466E:  BSF    F94.3
4670:  MOVLW  0B
4672:  MOVWF  00
4674:  DECFSZ 00,F
4676:  BRA    4674
4678:  BCF    F8B.4
467A:  BCF    F94.4
467C:  MOVLW  0A
467E:  MOVWF  00
4680:  DECFSZ 00,F
4682:  BRA    4680
4684:  BCF    F8B.3
4686:  BCF    F94.3
4688:  CLRF   19
468A:  BTFSC  FF2.7
468C:  BSF    19.7
468E:  BCF    FF2.7
....................    i2c_write(0xD0); 
4690:  MOVLW  D0
4692:  MOVLB  8
4694:  MOVWF  xDC
4696:  MOVLB  0
4698:  CALL   3236
469C:  BTFSC  19.7
469E:  BSF    FF2.7
46A0:  CLRF   19
46A2:  BTFSC  FF2.7
46A4:  BSF    19.7
46A6:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
46A8:  MOVLB  8
46AA:  CLRF   xDC
46AC:  MOVLB  0
46AE:  CALL   3236
46B2:  BTFSC  19.7
46B4:  BSF    FF2.7
46B6:  CLRF   19
46B8:  BTFSC  FF2.7
46BA:  BSF    19.7
46BC:  BCF    FF2.7
....................    i2c_write(data); 
46BE:  MOVFF  7A1,8DC
46C2:  CALL   3236
46C6:  BTFSC  19.7
46C8:  BSF    FF2.7
....................    i2c_start(); 
46CA:  BSF    F94.4
46CC:  MOVLW  0A
46CE:  MOVWF  00
46D0:  DECFSZ 00,F
46D2:  BRA    46D0
46D4:  BSF    F94.3
46D6:  MOVLW  0B
46D8:  MOVWF  00
46DA:  DECFSZ 00,F
46DC:  BRA    46DA
46DE:  BTFSS  F82.3
46E0:  BRA    46DE
46E2:  BCF    F8B.4
46E4:  BCF    F94.4
46E6:  MOVLW  0A
46E8:  MOVWF  00
46EA:  DECFSZ 00,F
46EC:  BRA    46EA
46EE:  BCF    F8B.3
46F0:  BCF    F94.3
46F2:  CLRF   19
46F4:  BTFSC  FF2.7
46F6:  BSF    19.7
46F8:  BCF    FF2.7
....................    i2c_write(0xD0); 
46FA:  MOVLW  D0
46FC:  MOVLB  8
46FE:  MOVWF  xDC
4700:  MOVLB  0
4702:  CALL   3236
4706:  BTFSC  19.7
4708:  BSF    FF2.7
470A:  CLRF   19
470C:  BTFSC  FF2.7
470E:  BSF    19.7
4710:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
4712:  MOVLW  07
4714:  MOVLB  8
4716:  MOVWF  xDC
4718:  MOVLB  0
471A:  CALL   3236
471E:  BTFSC  19.7
4720:  BSF    FF2.7
4722:  CLRF   19
4724:  BTFSC  FF2.7
4726:  BSF    19.7
4728:  BCF    FF2.7
....................    i2c_write(0x80); 
472A:  MOVLW  80
472C:  MOVLB  8
472E:  MOVWF  xDC
4730:  MOVLB  0
4732:  CALL   3236
4736:  BTFSC  19.7
4738:  BSF    FF2.7
....................    i2c_stop(); 
473A:  BCF    F94.4
473C:  NOP   
473E:  BSF    F94.3
4740:  BTFSS  F82.3
4742:  BRA    4740
4744:  MOVLW  0A
4746:  MOVWF  00
4748:  DECFSZ 00,F
474A:  BRA    4748
474C:  BRA    474E
474E:  NOP   
4750:  BSF    F94.4
4752:  MOVLW  0A
4754:  MOVWF  00
4756:  DECFSZ 00,F
4758:  BRA    4756
.................... } 
475A:  GOTO   869C (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
6E3C:  CLRF   19
6E3E:  BTFSC  FF2.7
6E40:  BSF    19.7
6E42:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
6E44:  MOVFF  7DD,8CE
6E48:  MOVLW  0A
6E4A:  MOVLB  8
6E4C:  MOVWF  xCF
6E4E:  MOVLB  0
6E50:  CALL   1502
6E54:  BTFSC  19.7
6E56:  BSF    FF2.7
6E58:  MOVFF  01,7DE
....................    nibl=data-(nibh*10); 
6E5C:  MOVLB  7
6E5E:  MOVF   xDE,W
6E60:  MULLW  0A
6E62:  MOVF   FF3,W
6E64:  SUBWF  xDD,W
6E66:  MOVWF  xDF
....................  
....................    return((nibh<<4)|nibl); 
6E68:  SWAPF  xDE,W
6E6A:  MOVWF  00
6E6C:  MOVLW  F0
6E6E:  ANDWF  00,F
6E70:  MOVF   00,W
6E72:  IORWF  xDF,W
6E74:  MOVWF  01
.................... } 
6E76:  MOVLB  0
6E78:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
6C48:  MOVFF  7DC,7DD
....................    data=(i>>4)*10; 
6C4C:  MOVLB  7
6C4E:  SWAPF  xDD,W
6C50:  MOVWF  00
6C52:  MOVLW  0F
6C54:  ANDWF  00,F
6C56:  MOVF   00,W
6C58:  MULLW  0A
6C5A:  MOVFF  FF3,7DC
....................    data=data+(i<<4>>4); 
6C5E:  SWAPF  xDD,W
6C60:  MOVWF  00
6C62:  MOVLW  F0
6C64:  ANDWF  00,F
6C66:  MOVF   00,W
6C68:  SWAPF  00,F
6C6A:  MOVLW  0F
6C6C:  ANDWF  00,F
6C6E:  MOVF   00,W
6C70:  ADDWF  xDC,F
....................  
....................    return data; 
6C72:  MOVFF  7DC,01
.................... } 
6C76:  MOVLB  0
6C78:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
6E7A:  MOVLB  7
6E7C:  CLRF   xDE
6E7E:  CLRF   xDF
6E80:  MOVLB  0
6E82:  RCALL  6D8E
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
6E84:  MOVFF  7DC,7DD
6E88:  RCALL  6E3C
6E8A:  MOVFF  01,7DD
6E8E:  MOVLW  01
6E90:  MOVLB  7
6E92:  MOVWF  xDE
6E94:  MOVFF  01,7DF
6E98:  MOVLB  0
6E9A:  RCALL  6D8E
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
6E9C:  MOVFF  7DB,7DD
6EA0:  RCALL  6E3C
6EA2:  MOVFF  01,7DD
6EA6:  MOVLW  02
6EA8:  MOVLB  7
6EAA:  MOVWF  xDE
6EAC:  MOVFF  01,7DF
6EB0:  MOVLB  0
6EB2:  RCALL  6D8E
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
6EB4:  MOVFF  7DA,7DD
6EB8:  RCALL  6E3C
6EBA:  MOVFF  01,7DD
6EBE:  MOVLW  03
6EC0:  MOVLB  7
6EC2:  MOVWF  xDE
6EC4:  MOVFF  01,7DF
6EC8:  MOVLB  0
6ECA:  RCALL  6D8E
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
6ECC:  MOVFF  7D7,7DD
6ED0:  RCALL  6E3C
6ED2:  MOVFF  01,7DD
6ED6:  MOVLW  04
6ED8:  MOVLB  7
6EDA:  MOVWF  xDE
6EDC:  MOVFF  01,7DF
6EE0:  MOVLB  0
6EE2:  RCALL  6D8E
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
6EE4:  MOVFF  7D8,7DD
6EE8:  RCALL  6E3C
6EEA:  MOVFF  01,7DD
6EEE:  MOVLW  05
6EF0:  MOVLB  7
6EF2:  MOVWF  xDE
6EF4:  MOVFF  01,7DF
6EF8:  MOVLB  0
6EFA:  RCALL  6D8E
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
6EFC:  MOVFF  7D9,7DD
6F00:  RCALL  6E3C
6F02:  MOVFF  01,7DD
6F06:  MOVLW  06
6F08:  MOVLB  7
6F0A:  MOVWF  xDE
6F0C:  MOVFF  01,7DF
6F10:  MOVLB  0
6F12:  RCALL  6D8E
....................    write_DS1307(DS1307_CONTROL,0);    
6F14:  MOVLW  07
6F16:  MOVLB  7
6F18:  MOVWF  xDE
6F1A:  CLRF   xDF
6F1C:  MOVLB  0
6F1E:  RCALL  6D8E
.................... } 
6F20:  GOTO   7B76 (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
76B6:  MOVLW  04
76B8:  MOVLB  7
76BA:  MOVWF  xDB
76BC:  MOVLB  0
76BE:  CALL   4584
76C2:  MOVFF  01,7D7
76C6:  MOVFF  01,7DC
76CA:  CALL   6C48
76CE:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
76D2:  MOVLW  05
76D4:  MOVLB  7
76D6:  MOVWF  xDB
76D8:  MOVLB  0
76DA:  CALL   4584
76DE:  MOVFF  01,7D7
76E2:  MOVFF  01,7DC
76E6:  CALL   6C48
76EA:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
76EE:  MOVLW  06
76F0:  MOVLB  7
76F2:  MOVWF  xDB
76F4:  MOVLB  0
76F6:  CALL   4584
76FA:  MOVFF  01,7D7
76FE:  MOVFF  01,7DC
7702:  CALL   6C48
7706:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
770A:  MOVLW  03
770C:  MOVLB  7
770E:  MOVWF  xDB
7710:  MOVLB  0
7712:  CALL   4584
7716:  MOVFF  01,7D7
771A:  MOVFF  01,7DC
771E:  CALL   6C48
7722:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
7726:  MOVLW  02
7728:  MOVLB  7
772A:  MOVWF  xDB
772C:  MOVLB  0
772E:  CALL   4584
7732:  MOVFF  01,7D7
7736:  MOVFF  01,7DC
773A:  CALL   6C48
773E:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
7742:  MOVLW  01
7744:  MOVLB  7
7746:  MOVWF  xDB
7748:  MOVLB  0
774A:  CALL   4584
774E:  MOVFF  01,7D7
7752:  MOVFF  01,7DC
7756:  CALL   6C48
775A:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
775E:  MOVLB  7
7760:  CLRF   xDB
7762:  MOVLB  0
7764:  CALL   4584
7768:  MOVFF  01,7D7
776C:  MOVFF  01,7DC
7770:  CALL   6C48
7774:  MOVFF  01,103
7778:  CLRF   19
777A:  BTFSC  FF2.7
777C:  BSF    19.7
777E:  BCF    FF2.7
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0,booting=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... int16 count_checking=10; 
.................... #include <scan_key.c> 
....................  
.................... #include <aes.c> 
.................... /************************************************************************************************************* 
.................... *    Titre:         Module d'encryption AES 
.................... *    Fichier:       aes.c 
.................... *    Date:          07/02/2007 
.................... *************************************************************************************************************/ 
....................  
.................... /************************************************************************************************************* 
....................    Dfinition des constantes 
.................... *************************************************************************************************************/ 
.................... #define CRYPTO_KEY_SIZE   32 
....................  
.................... /************************************************************************************************************* 
....................    Dfinition des variables globales 
.................... *************************************************************************************************************/ 
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1]; 
.................... /************************************************************************************************************** 
....................  ** @file    aes.c 
....................  ** @brief   Module d'encryption AES 
....................  **************************************************************************************************************/                                           
....................  
.................... /************************************************************************************************************* 
....................     Fonction :      rcon  
....................     Description :   Calcule la constante de round, renvoie, pour i valeur d'entree, la valeur 2 ** (i - 1). 
....................     Paramtres:    Round 
....................     Valeur retour:   Constante de round 
.................... **************************************************************************************************************/ 
.................... /** @brief   Calcule la constante de round, renvoie, pour i valeur d'entree, la valeur 2 ** (i - 1). 
.................... **************************************************************************************************************/ 
.................... unsigned int8 rcon(int i) 
.................... { 
*
4948:  MOVLW  01
494A:  MOVLB  8
494C:  MOVWF  xBB
....................    int p; 
....................    unsigned int8 j=1; 
....................  
....................    for (p = 0; p < i - 1; p++) 
494E:  CLRF   xBA
4950:  MOVLW  01
4952:  SUBWF  xB9,W
4954:  SUBWF  xBA,W
4956:  BC    4960
....................       j = j*2; 
4958:  BCF    FD8.0
495A:  RLCF   xBB,F
495C:  INCF   xBA,F
495E:  BRA    4950
....................    return j; 
4960:  MOVFF  8BB,01
.................... } 
4964:  MOVLB  0
4966:  RETURN 0
....................  
.................... /************************************************************************************************************* 
....................     Fonction :      sub_s_box  
....................     Description :   Effectue le produit matriciel de l'octet c passe en parametre avec la matrice de la s_box: 
....................            
....................                 [1 0 0 0 1 1 1 1] 
....................                 [1 1 0 0 0 1 1 1] 
....................                 [1 1 1 0 0 0 1 1] 
....................                 [1 1 1 1 0 0 0 1] 
....................                 [1 1 1 1 1 0 0 0] 
....................                 [0 1 1 1 1 1 0 0] 
....................                 [0 0 1 1 1 1 1 0] 
....................                 [0 0 0 1 1 1 1 1] 
....................     Paramtres:     
....................     Valeur retour:    
.................... **************************************************************************************************************/ 
.................... /** @brief   Effectue le produit matriciel de l'octet c passe en parametre avec la matrice de la s_box. 
.................... **************************************************************************************************************/ 
.................... unsigned int8 sub_s_box(unsigned int8 c, unsigned int8 cmd) 
.................... { 
4968:  MOVLB  8
496A:  CLRF   x9F
....................    int i,nb_1 = 0; 
....................    unsigned int8 s_box[8]; 
....................    unsigned int8 temp[8]; 
....................    unsigned int8 r[8]; 
....................  
....................    if (cmd == 'c') 
496C:  MOVF   x9D,W
496E:  SUBLW  63
4970:  BNZ   4994
....................    { 
....................       s_box[0] = 143;   //matrice de la s_box (une case du tableau correspond a une ligne de la matrice) 
4972:  MOVLW  8F
4974:  MOVWF  xA0
....................       s_box[1] = 199; 
4976:  MOVLW  C7
4978:  MOVWF  xA1
....................       s_box[2] = 227; 
497A:  MOVLW  E3
497C:  MOVWF  xA2
....................       s_box[3] = 241; 
497E:  MOVLW  F1
4980:  MOVWF  xA3
....................       s_box[4] = 248; 
4982:  MOVLW  F8
4984:  MOVWF  xA4
....................       s_box[5] = 124; 
4986:  MOVLW  7C
4988:  MOVWF  xA5
....................       s_box[6] = 62; 
498A:  MOVLW  3E
498C:  MOVWF  xA6
....................       s_box[7] = 31; 
498E:  MOVLW  1F
4990:  MOVWF  xA7
....................    } 
....................    else 
4992:  BRA    49B4
....................    { 
....................       s_box[0] = 37;   //matrice inverse de la s_box (decryptage) 
4994:  MOVLW  25
4996:  MOVWF  xA0
....................       s_box[1] = 146; 
4998:  MOVLW  92
499A:  MOVWF  xA1
....................       s_box[2] = 73; 
499C:  MOVLW  49
499E:  MOVWF  xA2
....................       s_box[3] = 164; 
49A0:  MOVLW  A4
49A2:  MOVWF  xA3
....................       s_box[4] = 82; 
49A4:  MOVLW  52
49A6:  MOVWF  xA4
....................       s_box[5] = 41; 
49A8:  MOVLW  29
49AA:  MOVWF  xA5
....................       s_box[6] = 148; 
49AC:  MOVLW  94
49AE:  MOVWF  xA6
....................       s_box[7] = 74; 
49B0:  MOVLW  4A
49B2:  MOVWF  xA7
....................    } 
....................  
....................    for (i = 0; i < 8; i++)  
49B4:  CLRF   x9E
49B6:  MOVF   x9E,W
49B8:  SUBLW  07
49BA:  BNC   49EC
....................       temp[i] = s_box[i] & c; //ET bit a bit 
49BC:  CLRF   03
49BE:  MOVF   x9E,W
49C0:  ADDLW  A8
49C2:  MOVWF  01
49C4:  MOVLW  08
49C6:  ADDWFC 03,F
49C8:  MOVFF  03,8B9
49CC:  CLRF   03
49CE:  MOVF   x9E,W
49D0:  ADDLW  A0
49D2:  MOVWF  FE9
49D4:  MOVLW  08
49D6:  ADDWFC 03,W
49D8:  MOVWF  FEA
49DA:  MOVF   FEF,W
49DC:  ANDWF  x9C,W
49DE:  MOVFF  8B9,FEA
49E2:  MOVFF  01,FE9
49E6:  MOVWF  FEF
49E8:  INCF   x9E,F
49EA:  BRA    49B6
....................  
....................    for (i = 0; i < 8; i++) 
49EC:  CLRF   x9E
49EE:  MOVF   x9E,W
49F0:  SUBLW  07
49F2:  BNC   4A5E
....................    { 
....................       nb_1=0; 
49F4:  CLRF   x9F
....................       do 
....................       { 
....................          if (temp[i] % 2 != 0) 
49F6:  CLRF   03
49F8:  MOVF   x9E,W
49FA:  ADDLW  A8
49FC:  MOVWF  FE9
49FE:  MOVLW  08
4A00:  ADDWFC 03,W
4A02:  MOVWF  FEA
4A04:  MOVF   FEF,W
4A06:  ANDLW  01
4A08:  BZ    4A20
....................          { 
....................             temp[i] -= 1; 
4A0A:  CLRF   03
4A0C:  MOVF   x9E,W
4A0E:  ADDLW  A8
4A10:  MOVWF  FE9
4A12:  MOVLW  08
4A14:  ADDWFC 03,W
4A16:  MOVWF  FEA
4A18:  MOVLW  01
4A1A:  SUBWF  FEF,W
4A1C:  MOVWF  FEF
....................             nb_1++; //calcul du nombre de '1' dans le code binaire de temp[i] 
4A1E:  INCF   x9F,F
....................          } 
....................  
....................          temp[i] /= 2; 
4A20:  CLRF   03
4A22:  MOVF   x9E,W
4A24:  ADDLW  A8
4A26:  MOVWF  FE9
4A28:  MOVLW  08
4A2A:  ADDWFC 03,W
4A2C:  MOVWF  FEA
4A2E:  BCF    FD8.0
4A30:  RRCF   FEF,W
4A32:  MOVWF  FEF
....................       } while (temp[i]>0); 
4A34:  CLRF   03
4A36:  MOVF   x9E,W
4A38:  ADDLW  A8
4A3A:  MOVWF  FE9
4A3C:  MOVLW  08
4A3E:  ADDWFC 03,W
4A40:  MOVWF  FEA
4A42:  MOVF   FEF,F
4A44:  BNZ   49F6
....................  
....................       r[i] = nb_1 % 2; 
4A46:  CLRF   03
4A48:  MOVF   x9E,W
4A4A:  ADDLW  B0
4A4C:  MOVWF  FE9
4A4E:  MOVLW  08
4A50:  ADDWFC 03,W
4A52:  MOVWF  FEA
4A54:  MOVF   x9F,W
4A56:  ANDLW  01
4A58:  MOVWF  FEF
....................    } 
4A5A:  INCF   x9E,F
4A5C:  BRA    49EE
....................  
....................    //generation du rsultat de la multiplication matricielle 
....................    return (r[0]*rcon(8) + r[1]*rcon(7) + r[2]*rcon(6) + r[3]*rcon(5) + r[4]*rcon(4) + r[5]*rcon(3) + r[6]*rcon(2) + r[7]*rcon(1)); 
4A5E:  MOVLW  08
4A60:  MOVWF  xB9
4A62:  MOVLB  0
4A64:  RCALL  4948
4A66:  MOVLB  8
4A68:  MOVF   xB0,W
4A6A:  MULWF  01
4A6C:  MOVFF  FF3,8B8
4A70:  MOVLW  07
4A72:  MOVWF  xB9
4A74:  MOVLB  0
4A76:  RCALL  4948
4A78:  MOVLB  8
4A7A:  MOVF   xB1,W
4A7C:  MULWF  01
4A7E:  MOVF   FF3,W
4A80:  ADDWF  xB8,F
4A82:  MOVLW  06
4A84:  MOVWF  xB9
4A86:  MOVLB  0
4A88:  RCALL  4948
4A8A:  MOVLB  8
4A8C:  MOVF   xB2,W
4A8E:  MULWF  01
4A90:  MOVF   FF3,W
4A92:  ADDWF  xB8,F
4A94:  MOVLW  05
4A96:  MOVWF  xB9
4A98:  MOVLB  0
4A9A:  RCALL  4948
4A9C:  MOVLB  8
4A9E:  MOVF   xB3,W
4AA0:  MULWF  01
4AA2:  MOVF   FF3,W
4AA4:  ADDWF  xB8,F
4AA6:  MOVLW  04
4AA8:  MOVWF  xB9
4AAA:  MOVLB  0
4AAC:  RCALL  4948
4AAE:  MOVLB  8
4AB0:  MOVF   xB4,W
4AB2:  MULWF  01
4AB4:  MOVF   FF3,W
4AB6:  ADDWF  xB8,F
4AB8:  MOVLW  03
4ABA:  MOVWF  xB9
4ABC:  MOVLB  0
4ABE:  RCALL  4948
4AC0:  MOVLB  8
4AC2:  MOVF   xB5,W
4AC4:  MULWF  01
4AC6:  MOVF   FF3,W
4AC8:  ADDWF  xB8,F
4ACA:  MOVLW  02
4ACC:  MOVWF  xB9
4ACE:  MOVLB  0
4AD0:  RCALL  4948
4AD2:  MOVLB  8
4AD4:  MOVF   xB6,W
4AD6:  MULWF  01
4AD8:  MOVF   FF3,W
4ADA:  ADDWF  xB8,F
4ADC:  MOVLW  01
4ADE:  MOVWF  xB9
4AE0:  MOVLB  0
4AE2:  RCALL  4948
4AE4:  MOVLB  8
4AE6:  MOVF   xB7,W
4AE8:  MULWF  01
4AEA:  MOVF   FF3,W
4AEC:  ADDWF  xB8,W
4AEE:  MOVWF  01
.................... } 
4AF0:  MOVLB  0
4AF2:  RETURN 0
....................  
.................... /************************************************************************************************************* 
....................     Fonction :      multi  
....................     Description :   Effectue la multiplication bijective des deux caractres passs en paramtre. 
....................     Paramtres:     
....................     Valeur retour:    
.................... **************************************************************************************************************/ 
.................... /** @brief   Effectue la multiplication bijective des deux caractres passs en paramtre. 
.................... **************************************************************************************************************/ 
.................... unsigned int8 multi(int8 a, int8 b) 
.................... { 
*
50DE:  CLRF   xB2
....................    int bb[4] = {0,0,0,0}, p = 0, intemp; 
*
50D4:  MOVLB  8
50D6:  CLRF   xAE
50D8:  CLRF   xAF
50DA:  CLRF   xB0
50DC:  CLRF   xB1
....................    unsigned int8 temp[4]; 
....................    temp[0] = b; 
*
50E0:  MOVFF  8AD,8B4
....................     
....................    /* Ici on rcupre les 4 bits de poids faible de b. 
....................    En fait, l'octet le plus lev (si on le regarde comme une valeur dcimale)  
....................    que l'on passe dans b est 14 (cf. fonction mix_column) */ 
....................     
....................    do 
....................    { 
....................       if (temp[0] % 2 != 0)  
50E4:  MOVF   xB4,W
50E6:  ANDLW  01
50E8:  BZ    5100
....................       { 
....................          temp[0] -= 1; 
50EA:  MOVLW  01
50EC:  SUBWF  xB4,F
....................          bb[p] = 1; 
50EE:  CLRF   03
50F0:  MOVF   xB2,W
50F2:  ADDLW  AE
50F4:  MOVWF  FE9
50F6:  MOVLW  08
50F8:  ADDWFC 03,W
50FA:  MOVWF  FEA
50FC:  MOVLW  01
50FE:  MOVWF  FEF
....................       } 
....................  
....................       p++; 
5100:  INCF   xB2,F
....................       temp[0] /= 2; 
5102:  BCF    FD8.0
5104:  RRCF   xB4,F
....................    } while (temp[0] > 0); 
5106:  MOVF   xB4,F
5108:  BNZ   50E4
....................  
....................    temp[0] = a; 
510A:  MOVFF  8AC,8B4
....................    temp[1] = a; 
510E:  MOVFF  8AC,8B5
....................  
....................    /* on calcule les 4 multiples succssifs de a */ 
....................    for(p = 1; p < 4; p++)    
5112:  MOVLW  01
5114:  MOVWF  xB2
5116:  MOVF   xB2,W
5118:  SUBLW  03
511A:  BNC   517C
....................    { 
....................       intemp = temp[p] * 2; 
511C:  CLRF   03
511E:  MOVF   xB2,W
5120:  ADDLW  B4
5122:  MOVWF  FE9
5124:  MOVLW  08
5126:  ADDWFC 03,W
5128:  MOVWF  FEA
512A:  BCF    FD8.0
512C:  RLCF   FEF,W
512E:  MOVWF  xB3
....................       if (intemp > 255) temp[p] = (intemp - 256) ^ 27; 
....................       else temp[p] = intemp; 
5130:  CLRF   03
5132:  MOVF   xB2,W
5134:  ADDLW  B4
5136:  MOVWF  FE9
5138:  MOVLW  08
513A:  ADDWFC 03,W
513C:  MOVWF  FEA
513E:  MOVFF  8B3,FEF
....................       if (p < 3) temp[p + 1] = temp[p]; 
5142:  MOVF   xB2,W
5144:  SUBLW  02
5146:  BNC   5178
5148:  MOVLW  01
514A:  ADDWF  xB2,W
514C:  CLRF   03
514E:  ADDLW  B4
5150:  MOVWF  01
5152:  MOVLW  08
5154:  ADDWFC 03,F
5156:  MOVFF  03,8B9
515A:  CLRF   03
515C:  MOVF   xB2,W
515E:  ADDLW  B4
5160:  MOVWF  FE9
5162:  MOVLW  08
5164:  ADDWFC 03,W
5166:  MOVWF  FEA
5168:  MOVFF  FEF,8BA
516C:  MOVFF  8B9,FEA
5170:  MOVFF  01,FE9
5174:  MOVFF  8BA,FEF
....................    } 
5178:  INCF   xB2,F
517A:  BRA    5116
....................  
....................    /* on met  0 les cases de temp correspondant aux 0 du code binaire de b */ 
....................    for(p = 0; p < 4; p++) 
517C:  CLRF   xB2
517E:  MOVF   xB2,W
5180:  SUBLW  03
5182:  BNC   51AA
....................    { 
....................       if (bb[p] == 0) temp[p] = 0; 
5184:  CLRF   03
5186:  MOVF   xB2,W
5188:  ADDLW  AE
518A:  MOVWF  FE9
518C:  MOVLW  08
518E:  ADDWFC 03,W
5190:  MOVWF  FEA
5192:  MOVF   FEF,F
5194:  BNZ   51A6
5196:  CLRF   03
5198:  MOVF   xB2,W
519A:  ADDLW  B4
519C:  MOVWF  FE9
519E:  MOVLW  08
51A0:  ADDWFC 03,W
51A2:  MOVWF  FEA
51A4:  CLRF   FEF
....................    } 
51A6:  INCF   xB2,F
51A8:  BRA    517E
....................     
....................    /* on somme (OU EXCLUSIF) les cases de temp pour gnrer le rsultat de la multiplication */ 
....................    return temp[0] ^ temp[1] ^ temp[2] ^ temp[3]; 
51AA:  MOVF   xB4,W
51AC:  XORWF  xB5,W
51AE:  XORWF  xB6,W
51B0:  XORWF  xB7,W
51B2:  MOVWF  01
.................... } 
51B4:  MOVLB  0
51B6:  RETURN 0
....................  
.................... /************************************************************************************************************* 
....................     Fonction :      expand_key 
....................     Description :   Effectue l'expansion de la cl.  
....................     Paramtres:    key, la cl du chiffreur et w, la cl rsultante - expanded key 
....................     Valeur retour:    
.................... **************************************************************************************************************/ 
.................... /** @brief   Effectue l'expansion de la cl.  
.................... **************************************************************************************************************/ 
.................... int expand_key(unsigned int8 key[4*4], unsigned int8 w[4*4*11]) 
.................... { 
*
4AF4:  MOVLB  8
4AF6:  CLRF   x94
....................    int i,j; 
....................    unsigned int8 temp=0; 
....................  
....................    for(i = 0; i < 16; i++) 
4AF8:  CLRF   x92
4AFA:  MOVF   x92,W
4AFC:  SUBLW  0F
4AFE:  BNC   4B32
....................       w[i] = key[i]; 
4B00:  CLRF   03
4B02:  MOVF   x92,W
4B04:  ADDWF  x90,W
4B06:  MOVWF  01
4B08:  MOVF   x91,W
4B0A:  ADDWFC 03,F
4B0C:  MOVFF  03,896
4B10:  CLRF   03
4B12:  MOVF   x92,W
4B14:  ADDWF  x8E,W
4B16:  MOVWF  FE9
4B18:  MOVF   x8F,W
4B1A:  ADDWFC 03,W
4B1C:  MOVWF  FEA
4B1E:  MOVFF  FEF,897
4B22:  MOVFF  896,FEA
4B26:  MOVFF  01,FE9
4B2A:  MOVFF  897,FEF
4B2E:  INCF   x92,F
4B30:  BRA    4AFA
....................  
....................    for(i = 16; i < 4*4*11; i++) 
4B32:  MOVLW  10
4B34:  MOVWF  x92
4B36:  MOVF   x92,W
4B38:  SUBLW  AF
4B3A:  BNC   4BDA
....................    { 
....................       if (i % 16 < 4) 
4B3C:  MOVF   x92,W
4B3E:  ANDLW  0F
4B40:  SUBLW  03
4B42:  BNC   4BA8
....................       { 
....................          j = i % 4; 
4B44:  MOVF   x92,W
4B46:  ANDLW  03
4B48:  MOVWF  x93
....................          if (j == 3) temp = w[i - 7]; 
4B4A:  MOVF   x93,W
4B4C:  SUBLW  03
4B4E:  BNZ   4B66
4B50:  MOVLW  07
4B52:  SUBWF  x92,W
4B54:  CLRF   03
4B56:  ADDWF  x90,W
4B58:  MOVWF  FE9
4B5A:  MOVF   x91,W
4B5C:  ADDWFC 03,W
4B5E:  MOVWF  FEA
4B60:  MOVFF  FEF,894
....................          else temp = w[i - 3]; 
4B64:  BRA    4B7A
4B66:  MOVLW  03
4B68:  SUBWF  x92,W
4B6A:  CLRF   03
4B6C:  ADDWF  x90,W
4B6E:  MOVWF  FE9
4B70:  MOVF   x91,W
4B72:  ADDWFC 03,W
4B74:  MOVWF  FEA
4B76:  MOVFF  FEF,894
....................          temp = sub_s_box(temp, 'c'); 
4B7A:  MOVFF  894,89C
4B7E:  MOVLW  63
4B80:  MOVWF  x9D
4B82:  MOVLB  0
4B84:  RCALL  4968
4B86:  MOVFF  01,894
....................          if (i % 16 == 0) temp = temp ^ rcon(i/16); 
4B8A:  MOVLB  8
4B8C:  MOVF   x92,W
4B8E:  ANDLW  0F
4B90:  BNZ   4BA8
4B92:  SWAPF  x92,W
4B94:  MOVWF  x95
4B96:  MOVLW  0F
4B98:  ANDWF  x95,F
4B9A:  MOVFF  895,8B9
4B9E:  MOVLB  0
4BA0:  RCALL  4948
4BA2:  MOVF   01,W
4BA4:  MOVLB  8
4BA6:  XORWF  x94,F
....................       } 
....................       w[i] = w[i - 16] ^ temp; 
4BA8:  CLRF   03
4BAA:  MOVF   x92,W
4BAC:  ADDWF  x90,W
4BAE:  MOVWF  01
4BB0:  MOVF   x91,W
4BB2:  ADDWFC 03,F
4BB4:  MOVFF  03,896
4BB8:  MOVLW  10
4BBA:  SUBWF  x92,W
4BBC:  CLRF   03
4BBE:  ADDWF  x90,W
4BC0:  MOVWF  FE9
4BC2:  MOVF   x91,W
4BC4:  ADDWFC 03,W
4BC6:  MOVWF  FEA
4BC8:  MOVF   FEF,W
4BCA:  XORWF  x94,W
4BCC:  MOVFF  896,FEA
4BD0:  MOVFF  01,FE9
4BD4:  MOVWF  FEF
....................    } 
4BD6:  INCF   x92,F
4BD8:  BRA    4B36
....................  
....................    return 0; 
4BDA:  MOVLW  00
4BDC:  MOVWF  01
.................... } 
4BDE:  MOVLB  0
4BE0:  GOTO   6196 (RETURN)
....................  
.................... /************************************************************************************************************* 
....................     Fonction :      select_key 
....................     Description :   Applique simplement une partie de la expanded_key (du tableau du meme nom) a un round.  
....................     Paramtres:     
....................     Valeur retour:    
.................... **************************************************************************************************************/ 
.................... /** @brief   Applique simplement une partie de la expanded_key (du tableau du meme nom) a un round. 
.................... **************************************************************************************************************/ 
.................... int select_key(unsigned int8 expanded_key[4*4*11], unsigned int8 round_key[4][4], int round) 
.................... { 
....................    int i,j; 
....................  
....................    for(i = 0; i < 4; i++) 
4BE4:  MOVLB  8
4BE6:  CLRF   x91
4BE8:  MOVF   x91,W
4BEA:  SUBLW  03
4BEC:  BNC   4C50
....................    { 
....................       for(j = 0; j < 4; j++) 
4BEE:  CLRF   x92
4BF0:  MOVF   x92,W
4BF2:  SUBLW  03
4BF4:  BNC   4C4C
....................       { 
....................          round_key[j][i] = expanded_key[(round * 16) + (4 * i) + j]; 
4BF6:  MOVF   x92,W
4BF8:  MULLW  04
4BFA:  MOVF   FF3,W
4BFC:  CLRF   x94
4BFE:  MOVWF  x93
4C00:  CLRF   03
4C02:  MOVF   x91,W
4C04:  ADDWF  x93,W
4C06:  MOVWF  01
4C08:  MOVF   x94,W
4C0A:  ADDWFC 03,F
4C0C:  MOVF   01,W
4C0E:  ADDWF  x8E,W
4C10:  MOVWF  01
4C12:  MOVF   x8F,W
4C14:  ADDWFC 03,F
4C16:  MOVFF  03,894
4C1A:  MOVF   x90,W
4C1C:  MULLW  10
4C1E:  MOVFF  FF3,895
4C22:  MOVF   x91,W
4C24:  MULLW  04
4C26:  MOVF   FF3,W
4C28:  ADDWF  x95,W
4C2A:  ADDWF  x92,W
4C2C:  CLRF   03
4C2E:  ADDWF  x8C,W
4C30:  MOVWF  FE9
4C32:  MOVF   x8D,W
4C34:  ADDWFC 03,W
4C36:  MOVWF  FEA
4C38:  MOVFF  FEF,895
4C3C:  MOVFF  894,FEA
4C40:  MOVFF  01,FE9
4C44:  MOVFF  895,FEF
....................       } 
4C48:  INCF   x92,F
4C4A:  BRA    4BF0
....................    } 
4C4C:  INCF   x91,F
4C4E:  BRA    4BE8
....................  
....................    return 0; 
4C50:  MOVLW  00
4C52:  MOVWF  01
.................... } 
4C54:  MOVLB  0
4C56:  GOTO   61D0 (RETURN)
....................     
.................... /************************************************************************************************************* 
....................     Fonction :      byte_sub 
....................     Description :   Effectue l'opration byte_sub. 
....................     Paramtres:     
....................     Valeur retour:    
.................... **************************************************************************************************************/ 
.................... /** @brief   Effectue l'opration byte_sub. 
.................... **************************************************************************************************************/ 
.................... int byte_sub(unsigned int8 state[4][4], unsigned int8 cmd) 
.................... { 
....................    int i,j; 
....................  
....................    for (i = 0; i < 4; i++) 
4C5A:  MOVLB  8
4C5C:  CLRF   x97
4C5E:  MOVF   x97,W
4C60:  SUBLW  03
4C62:  BNC   4D38
....................    { 
....................       for (j = 0; j < 4; j++) 
4C64:  CLRF   x98
4C66:  MOVF   x98,W
4C68:  SUBLW  03
4C6A:  BNC   4D34
....................       { 
....................          if(cmd == 'd') state[i][j] ^= 198; //ajout du vecteur constant (dcryptage) 
4C6C:  MOVF   x96,W
4C6E:  SUBLW  64
4C70:  BNZ   4C9A
4C72:  MOVF   x97,W
4C74:  MULLW  04
4C76:  MOVF   FF3,W
4C78:  CLRF   x9A
4C7A:  MOVWF  x99
4C7C:  CLRF   03
4C7E:  MOVF   x98,W
4C80:  ADDWF  x99,W
4C82:  MOVWF  01
4C84:  MOVF   x9A,W
4C86:  ADDWFC 03,F
4C88:  MOVF   01,W
4C8A:  ADDWF  x94,W
4C8C:  MOVWF  FE9
4C8E:  MOVF   x95,W
4C90:  ADDWFC 03,W
4C92:  MOVWF  FEA
4C94:  MOVF   FEF,W
4C96:  XORLW  C6
4C98:  MOVWF  FEF
....................          state[i][j] = sub_s_box(state[i][j], cmd); 
4C9A:  MOVF   x97,W
4C9C:  MULLW  04
4C9E:  MOVF   FF3,W
4CA0:  CLRF   x9A
4CA2:  MOVWF  x99
4CA4:  CLRF   03
4CA6:  MOVF   x98,W
4CA8:  ADDWF  x99,W
4CAA:  MOVWF  01
4CAC:  MOVF   x9A,W
4CAE:  ADDWFC 03,F
4CB0:  MOVF   01,W
4CB2:  ADDWF  x94,W
4CB4:  MOVWF  01
4CB6:  MOVF   x95,W
4CB8:  ADDWFC 03,F
4CBA:  MOVFF  01,899
4CBE:  MOVFF  03,89A
4CC2:  MOVF   x97,W
4CC4:  MULLW  04
4CC6:  MOVF   FF3,W
4CC8:  CLRF   x9C
4CCA:  MOVWF  x9B
4CCC:  CLRF   03
4CCE:  MOVF   x98,W
4CD0:  ADDWF  x9B,W
4CD2:  MOVWF  01
4CD4:  MOVF   x9C,W
4CD6:  ADDWFC 03,F
4CD8:  MOVF   01,W
4CDA:  ADDWF  x94,W
4CDC:  MOVWF  FE9
4CDE:  MOVF   x95,W
4CE0:  ADDWFC 03,W
4CE2:  MOVWF  FEA
4CE4:  MOVFF  FEF,89B
4CE8:  MOVFF  89B,89C
4CEC:  MOVFF  896,89D
4CF0:  MOVLB  0
4CF2:  RCALL  4968
4CF4:  MOVFF  89A,FEA
4CF8:  MOVFF  899,FE9
4CFC:  MOVFF  01,FEF
....................          if(cmd == 'c') state[i][j] ^= 198; //ajout du vecteur constant (cryptage) 
4D00:  MOVLB  8
4D02:  MOVF   x96,W
4D04:  SUBLW  63
4D06:  BNZ   4D30
4D08:  MOVF   x97,W
4D0A:  MULLW  04
4D0C:  MOVF   FF3,W
4D0E:  CLRF   x9A
4D10:  MOVWF  x99
4D12:  CLRF   03
4D14:  MOVF   x98,W
4D16:  ADDWF  x99,W
4D18:  MOVWF  01
4D1A:  MOVF   x9A,W
4D1C:  ADDWFC 03,F
4D1E:  MOVF   01,W
4D20:  ADDWF  x94,W
4D22:  MOVWF  FE9
4D24:  MOVF   x95,W
4D26:  ADDWFC 03,W
4D28:  MOVWF  FEA
4D2A:  MOVF   FEF,W
4D2C:  XORLW  C6
4D2E:  MOVWF  FEF
....................       } 
4D30:  INCF   x98,F
4D32:  BRA    4C66
....................    } 
4D34:  INCF   x97,F
4D36:  BRA    4C5E
....................  
....................    return 0; 
4D38:  MOVLW  00
4D3A:  MOVWF  01
.................... } 
4D3C:  MOVLB  0
4D3E:  RETURN 0
....................  
.................... /************************************************************************************************************* 
....................     Fonction :      shift_row 
....................     Description :   Effectue l'opration shift_row. 
....................     Paramtres:     
....................     Valeur retour:    
.................... **************************************************************************************************************/ 
.................... /** @brief   Effectue l'opration shift_row. 
.................... **************************************************************************************************************/ 
.................... int shift_row(unsigned int8 state[4][4], unsigned int8 cmd) 
.................... { 
....................    unsigned int8 temp; 
....................  
....................    if (cmd == 'c') //cryptage 
4D40:  MOVLB  8
4D42:  MOVF   x96,W
4D44:  SUBLW  63
4D46:  BTFSS  FD8.2
4D48:  BRA    4F0C
....................    { 
....................       temp = state[1][0]; 
4D4A:  MOVLW  04
4D4C:  ADDWF  x94,W
4D4E:  MOVWF  FE9
4D50:  MOVLW  00
4D52:  ADDWFC x95,W
4D54:  MOVWF  FEA
4D56:  MOVFF  FEF,897
....................       state[1][0] = state[1][1]; 
4D5A:  MOVLW  04
4D5C:  ADDWF  x94,W
4D5E:  MOVWF  01
4D60:  MOVLW  00
4D62:  ADDWFC x95,W
4D64:  MOVWF  03
4D66:  MOVLW  05
4D68:  ADDWF  x94,W
4D6A:  MOVWF  FE9
4D6C:  MOVLW  00
4D6E:  ADDWFC x95,W
4D70:  MOVWF  FEA
4D72:  MOVFF  FEF,89A
4D76:  MOVFF  03,FEA
4D7A:  MOVFF  01,FE9
4D7E:  MOVFF  89A,FEF
....................       state[1][1] = state[1][2]; 
4D82:  MOVLW  05
4D84:  ADDWF  x94,W
4D86:  MOVWF  01
4D88:  MOVLW  00
4D8A:  ADDWFC x95,W
4D8C:  MOVWF  03
4D8E:  MOVLW  06
4D90:  ADDWF  x94,W
4D92:  MOVWF  FE9
4D94:  MOVLW  00
4D96:  ADDWFC x95,W
4D98:  MOVWF  FEA
4D9A:  MOVFF  FEF,89A
4D9E:  MOVFF  03,FEA
4DA2:  MOVFF  01,FE9
4DA6:  MOVFF  89A,FEF
....................       state[1][2] = state[1][3]; 
4DAA:  MOVLW  06
4DAC:  ADDWF  x94,W
4DAE:  MOVWF  01
4DB0:  MOVLW  00
4DB2:  ADDWFC x95,W
4DB4:  MOVWF  03
4DB6:  MOVLW  07
4DB8:  ADDWF  x94,W
4DBA:  MOVWF  FE9
4DBC:  MOVLW  00
4DBE:  ADDWFC x95,W
4DC0:  MOVWF  FEA
4DC2:  MOVFF  FEF,89A
4DC6:  MOVFF  03,FEA
4DCA:  MOVFF  01,FE9
4DCE:  MOVFF  89A,FEF
....................       state[1][3] = temp; 
4DD2:  MOVLW  07
4DD4:  ADDWF  x94,W
4DD6:  MOVWF  FE9
4DD8:  MOVLW  00
4DDA:  ADDWFC x95,W
4DDC:  MOVWF  FEA
4DDE:  MOVFF  897,FEF
....................  
....................       temp = state[2][0]; 
4DE2:  MOVLW  08
4DE4:  ADDWF  x94,W
4DE6:  MOVWF  FE9
4DE8:  MOVLW  00
4DEA:  ADDWFC x95,W
4DEC:  MOVWF  FEA
4DEE:  MOVFF  FEF,897
....................       state[2][0] = state[2][2]; 
4DF2:  MOVLW  08
4DF4:  ADDWF  x94,W
4DF6:  MOVWF  01
4DF8:  MOVLW  00
4DFA:  ADDWFC x95,W
4DFC:  MOVWF  03
4DFE:  MOVLW  0A
4E00:  ADDWF  x94,W
4E02:  MOVWF  FE9
4E04:  MOVLW  00
4E06:  ADDWFC x95,W
4E08:  MOVWF  FEA
4E0A:  MOVFF  FEF,89A
4E0E:  MOVFF  03,FEA
4E12:  MOVFF  01,FE9
4E16:  MOVFF  89A,FEF
....................       state[2][2] = temp; 
4E1A:  MOVLW  0A
4E1C:  ADDWF  x94,W
4E1E:  MOVWF  FE9
4E20:  MOVLW  00
4E22:  ADDWFC x95,W
4E24:  MOVWF  FEA
4E26:  MOVFF  897,FEF
....................       temp = state[2][1]; 
4E2A:  MOVLW  09
4E2C:  ADDWF  x94,W
4E2E:  MOVWF  FE9
4E30:  MOVLW  00
4E32:  ADDWFC x95,W
4E34:  MOVWF  FEA
4E36:  MOVFF  FEF,897
....................       state[2][1] = state[2][3]; 
4E3A:  MOVLW  09
4E3C:  ADDWF  x94,W
4E3E:  MOVWF  01
4E40:  MOVLW  00
4E42:  ADDWFC x95,W
4E44:  MOVWF  03
4E46:  MOVLW  0B
4E48:  ADDWF  x94,W
4E4A:  MOVWF  FE9
4E4C:  MOVLW  00
4E4E:  ADDWFC x95,W
4E50:  MOVWF  FEA
4E52:  MOVFF  FEF,89A
4E56:  MOVFF  03,FEA
4E5A:  MOVFF  01,FE9
4E5E:  MOVFF  89A,FEF
....................       state[2][3] = temp; 
4E62:  MOVLW  0B
4E64:  ADDWF  x94,W
4E66:  MOVWF  FE9
4E68:  MOVLW  00
4E6A:  ADDWFC x95,W
4E6C:  MOVWF  FEA
4E6E:  MOVFF  897,FEF
....................  
....................       temp = state[3][3]; 
4E72:  MOVLW  0F
4E74:  ADDWF  x94,W
4E76:  MOVWF  FE9
4E78:  MOVLW  00
4E7A:  ADDWFC x95,W
4E7C:  MOVWF  FEA
4E7E:  MOVFF  FEF,897
....................       state[3][3] = state[3][2]; 
4E82:  MOVLW  0F
4E84:  ADDWF  x94,W
4E86:  MOVWF  01
4E88:  MOVLW  00
4E8A:  ADDWFC x95,W
4E8C:  MOVWF  03
4E8E:  MOVLW  0E
4E90:  ADDWF  x94,W
4E92:  MOVWF  FE9
4E94:  MOVLW  00
4E96:  ADDWFC x95,W
4E98:  MOVWF  FEA
4E9A:  MOVFF  FEF,89A
4E9E:  MOVFF  03,FEA
4EA2:  MOVFF  01,FE9
4EA6:  MOVFF  89A,FEF
....................       state[3][2] = state[3][1]; 
4EAA:  MOVLW  0E
4EAC:  ADDWF  x94,W
4EAE:  MOVWF  01
4EB0:  MOVLW  00
4EB2:  ADDWFC x95,W
4EB4:  MOVWF  03
4EB6:  MOVLW  0D
4EB8:  ADDWF  x94,W
4EBA:  MOVWF  FE9
4EBC:  MOVLW  00
4EBE:  ADDWFC x95,W
4EC0:  MOVWF  FEA
4EC2:  MOVFF  FEF,89A
4EC6:  MOVFF  03,FEA
4ECA:  MOVFF  01,FE9
4ECE:  MOVFF  89A,FEF
....................       state[3][1] = state[3][0]; 
4ED2:  MOVLW  0D
4ED4:  ADDWF  x94,W
4ED6:  MOVWF  01
4ED8:  MOVLW  00
4EDA:  ADDWFC x95,W
4EDC:  MOVWF  03
4EDE:  MOVLW  0C
4EE0:  ADDWF  x94,W
4EE2:  MOVWF  FE9
4EE4:  MOVLW  00
4EE6:  ADDWFC x95,W
4EE8:  MOVWF  FEA
4EEA:  MOVFF  FEF,89A
4EEE:  MOVFF  03,FEA
4EF2:  MOVFF  01,FE9
4EF6:  MOVFF  89A,FEF
....................       state[3][0] = temp; 
4EFA:  MOVLW  0C
4EFC:  ADDWF  x94,W
4EFE:  MOVWF  FE9
4F00:  MOVLW  00
4F02:  ADDWFC x95,W
4F04:  MOVWF  FEA
4F06:  MOVFF  897,FEF
....................    } 
....................        
....................    else //dcryptage 
4F0A:  BRA    50CC
....................    { 
....................       temp = state[1][3]; 
4F0C:  MOVLW  07
4F0E:  ADDWF  x94,W
4F10:  MOVWF  FE9
4F12:  MOVLW  00
4F14:  ADDWFC x95,W
4F16:  MOVWF  FEA
4F18:  MOVFF  FEF,897
....................       state[1][3] = state[1][2]; 
4F1C:  MOVLW  07
4F1E:  ADDWF  x94,W
4F20:  MOVWF  01
4F22:  MOVLW  00
4F24:  ADDWFC x95,W
4F26:  MOVWF  03
4F28:  MOVLW  06
4F2A:  ADDWF  x94,W
4F2C:  MOVWF  FE9
4F2E:  MOVLW  00
4F30:  ADDWFC x95,W
4F32:  MOVWF  FEA
4F34:  MOVFF  FEF,89A
4F38:  MOVFF  03,FEA
4F3C:  MOVFF  01,FE9
4F40:  MOVFF  89A,FEF
....................       state[1][2] = state[1][1]; 
4F44:  MOVLW  06
4F46:  ADDWF  x94,W
4F48:  MOVWF  01
4F4A:  MOVLW  00
4F4C:  ADDWFC x95,W
4F4E:  MOVWF  03
4F50:  MOVLW  05
4F52:  ADDWF  x94,W
4F54:  MOVWF  FE9
4F56:  MOVLW  00
4F58:  ADDWFC x95,W
4F5A:  MOVWF  FEA
4F5C:  MOVFF  FEF,89A
4F60:  MOVFF  03,FEA
4F64:  MOVFF  01,FE9
4F68:  MOVFF  89A,FEF
....................       state[1][1] = state[1][0]; 
4F6C:  MOVLW  05
4F6E:  ADDWF  x94,W
4F70:  MOVWF  01
4F72:  MOVLW  00
4F74:  ADDWFC x95,W
4F76:  MOVWF  03
4F78:  MOVLW  04
4F7A:  ADDWF  x94,W
4F7C:  MOVWF  FE9
4F7E:  MOVLW  00
4F80:  ADDWFC x95,W
4F82:  MOVWF  FEA
4F84:  MOVFF  FEF,89A
4F88:  MOVFF  03,FEA
4F8C:  MOVFF  01,FE9
4F90:  MOVFF  89A,FEF
....................       state[1][0] = temp; 
4F94:  MOVLW  04
4F96:  ADDWF  x94,W
4F98:  MOVWF  FE9
4F9A:  MOVLW  00
4F9C:  ADDWFC x95,W
4F9E:  MOVWF  FEA
4FA0:  MOVFF  897,FEF
....................  
....................       temp = state[2][0]; 
4FA4:  MOVLW  08
4FA6:  ADDWF  x94,W
4FA8:  MOVWF  FE9
4FAA:  MOVLW  00
4FAC:  ADDWFC x95,W
4FAE:  MOVWF  FEA
4FB0:  MOVFF  FEF,897
....................       state[2][0] = state[2][2]; 
4FB4:  MOVLW  08
4FB6:  ADDWF  x94,W
4FB8:  MOVWF  01
4FBA:  MOVLW  00
4FBC:  ADDWFC x95,W
4FBE:  MOVWF  03
4FC0:  MOVLW  0A
4FC2:  ADDWF  x94,W
4FC4:  MOVWF  FE9
4FC6:  MOVLW  00
4FC8:  ADDWFC x95,W
4FCA:  MOVWF  FEA
4FCC:  MOVFF  FEF,89A
4FD0:  MOVFF  03,FEA
4FD4:  MOVFF  01,FE9
4FD8:  MOVFF  89A,FEF
....................       state[2][2] = temp; 
4FDC:  MOVLW  0A
4FDE:  ADDWF  x94,W
4FE0:  MOVWF  FE9
4FE2:  MOVLW  00
4FE4:  ADDWFC x95,W
4FE6:  MOVWF  FEA
4FE8:  MOVFF  897,FEF
....................       temp = state[2][1]; 
4FEC:  MOVLW  09
4FEE:  ADDWF  x94,W
4FF0:  MOVWF  FE9
4FF2:  MOVLW  00
4FF4:  ADDWFC x95,W
4FF6:  MOVWF  FEA
4FF8:  MOVFF  FEF,897
....................       state[2][1] = state[2][3]; 
4FFC:  MOVLW  09
4FFE:  ADDWF  x94,W
5000:  MOVWF  01
5002:  MOVLW  00
5004:  ADDWFC x95,W
5006:  MOVWF  03
5008:  MOVLW  0B
500A:  ADDWF  x94,W
500C:  MOVWF  FE9
500E:  MOVLW  00
5010:  ADDWFC x95,W
5012:  MOVWF  FEA
5014:  MOVFF  FEF,89A
5018:  MOVFF  03,FEA
501C:  MOVFF  01,FE9
5020:  MOVFF  89A,FEF
....................       state[2][3] = temp; 
5024:  MOVLW  0B
5026:  ADDWF  x94,W
5028:  MOVWF  FE9
502A:  MOVLW  00
502C:  ADDWFC x95,W
502E:  MOVWF  FEA
5030:  MOVFF  897,FEF
....................  
....................       temp = state[3][0]; 
5034:  MOVLW  0C
5036:  ADDWF  x94,W
5038:  MOVWF  FE9
503A:  MOVLW  00
503C:  ADDWFC x95,W
503E:  MOVWF  FEA
5040:  MOVFF  FEF,897
....................       state[3][0] = state[3][1]; 
5044:  MOVLW  0C
5046:  ADDWF  x94,W
5048:  MOVWF  01
504A:  MOVLW  00
504C:  ADDWFC x95,W
504E:  MOVWF  03
5050:  MOVLW  0D
5052:  ADDWF  x94,W
5054:  MOVWF  FE9
5056:  MOVLW  00
5058:  ADDWFC x95,W
505A:  MOVWF  FEA
505C:  MOVFF  FEF,89A
5060:  MOVFF  03,FEA
5064:  MOVFF  01,FE9
5068:  MOVFF  89A,FEF
....................       state[3][1] = state[3][2]; 
506C:  MOVLW  0D
506E:  ADDWF  x94,W
5070:  MOVWF  01
5072:  MOVLW  00
5074:  ADDWFC x95,W
5076:  MOVWF  03
5078:  MOVLW  0E
507A:  ADDWF  x94,W
507C:  MOVWF  FE9
507E:  MOVLW  00
5080:  ADDWFC x95,W
5082:  MOVWF  FEA
5084:  MOVFF  FEF,89A
5088:  MOVFF  03,FEA
508C:  MOVFF  01,FE9
5090:  MOVFF  89A,FEF
....................       state[3][2] = state[3][3]; 
5094:  MOVLW  0E
5096:  ADDWF  x94,W
5098:  MOVWF  01
509A:  MOVLW  00
509C:  ADDWFC x95,W
509E:  MOVWF  03
50A0:  MOVLW  0F
50A2:  ADDWF  x94,W
50A4:  MOVWF  FE9
50A6:  MOVLW  00
50A8:  ADDWFC x95,W
50AA:  MOVWF  FEA
50AC:  MOVFF  FEF,89A
50B0:  MOVFF  03,FEA
50B4:  MOVFF  01,FE9
50B8:  MOVFF  89A,FEF
....................       state[3][3] = temp; 
50BC:  MOVLW  0F
50BE:  ADDWF  x94,W
50C0:  MOVWF  FE9
50C2:  MOVLW  00
50C4:  ADDWFC x95,W
50C6:  MOVWF  FEA
50C8:  MOVFF  897,FEF
....................    } 
....................  
....................    return 0; 
50CC:  MOVLW  00
50CE:  MOVWF  01
.................... } 
50D0:  MOVLB  0
50D2:  RETURN 0
....................  
.................... /************************************************************************************************************* 
....................     Fonction :      mix_column 
....................     Description :   Effectue l'opration mix_column. 
....................     Paramtres:     
....................     Valeur retour:    
.................... **************************************************************************************************************/ 
.................... /** @brief   Effectue l'opration mix_column. 
.................... **************************************************************************************************************/ 
.................... int mix_column(unsigned int8 state[4][4], unsigned int8 cmd) 
.................... { 
....................    int i,j; 
....................    unsigned int8 temp[4][4]; 
....................  
....................    for (i = 0; i < 4; i++) 
*
51B8:  MOVLB  8
51BA:  CLRF   x97
51BC:  MOVF   x97,W
51BE:  SUBLW  03
51C0:  BNC   522C
....................    { 
....................       for (j = 0; j < 4; j++) temp[i][j] = state[i][j]; 
51C2:  CLRF   x98
51C4:  MOVF   x98,W
51C6:  SUBLW  03
51C8:  BNC   5228
51CA:  MOVF   x97,W
51CC:  MULLW  04
51CE:  MOVF   FF3,W
51D0:  CLRF   xAA
51D2:  MOVWF  xA9
51D4:  CLRF   03
51D6:  MOVF   x98,W
51D8:  ADDWF  xA9,W
51DA:  MOVWF  01
51DC:  MOVF   xAA,W
51DE:  ADDWFC 03,F
51E0:  MOVF   01,W
51E2:  ADDLW  99
51E4:  MOVWF  01
51E6:  MOVLW  08
51E8:  ADDWFC 03,F
51EA:  MOVFF  01,8A9
51EE:  MOVFF  03,8AA
51F2:  MOVF   x97,W
51F4:  MULLW  04
51F6:  MOVF   FF3,W
51F8:  CLRF   xAC
51FA:  MOVWF  xAB
51FC:  CLRF   03
51FE:  MOVF   x98,W
5200:  ADDWF  xAB,W
5202:  MOVWF  01
5204:  MOVF   xAC,W
5206:  ADDWFC 03,F
5208:  MOVF   01,W
520A:  ADDWF  x94,W
520C:  MOVWF  FE9
520E:  MOVF   x95,W
5210:  ADDWFC 03,W
5212:  MOVWF  FEA
5214:  MOVFF  FEF,8AB
5218:  MOVFF  8AA,FEA
521C:  MOVFF  8A9,FE9
5220:  MOVFF  8AB,FEF
5224:  INCF   x98,F
5226:  BRA    51C4
....................    } 
5228:  INCF   x97,F
522A:  BRA    51BC
....................  
....................    if (cmd == 'c') //cryptage 
522C:  MOVF   x96,W
522E:  SUBLW  63
5230:  BTFSS  FD8.2
5232:  BRA    5874
....................    { 
....................       state[0][0] = multi(temp[0][0],2) ^ multi(temp[1][0],3) ^ multi(temp[2][0],1) ^ multi(temp[3][0],1); 
5234:  MOVFF  894,01
5238:  MOVFF  895,03
523C:  MOVFF  894,8A9
5240:  MOVFF  895,8AA
5244:  MOVFF  899,8AC
5248:  MOVLW  02
524A:  MOVWF  xAD
524C:  MOVLB  0
524E:  RCALL  50D4
5250:  MOVFF  01,8AB
5254:  MOVFF  89D,8AC
5258:  MOVLW  03
525A:  MOVLB  8
525C:  MOVWF  xAD
525E:  MOVLB  0
5260:  RCALL  50D4
5262:  MOVF   01,W
5264:  MOVLB  8
5266:  XORWF  xAB,F
5268:  MOVFF  8A1,8AC
526C:  MOVLW  01
526E:  MOVWF  xAD
5270:  MOVLB  0
5272:  RCALL  50D4
5274:  MOVF   01,W
5276:  MOVLB  8
5278:  XORWF  xAB,F
527A:  MOVFF  8A5,8AC
527E:  MOVLW  01
5280:  MOVWF  xAD
5282:  MOVLB  0
5284:  RCALL  50D4
5286:  MOVLB  8
5288:  MOVF   xAB,W
528A:  XORWF  01,W
528C:  MOVFF  8AA,FEA
5290:  MOVFF  8A9,FE9
5294:  MOVWF  FEF
....................       state[1][0] = multi(temp[0][0],1) ^ multi(temp[1][0],2) ^ multi(temp[2][0],3) ^ multi(temp[3][0],1); 
5296:  MOVLW  04
5298:  ADDWF  x94,W
529A:  MOVWF  01
529C:  MOVLW  00
529E:  ADDWFC x95,W
52A0:  MOVWF  03
52A2:  MOVFF  01,8A9
52A6:  MOVWF  xAA
52A8:  MOVFF  899,8AC
52AC:  MOVLW  01
52AE:  MOVWF  xAD
52B0:  MOVLB  0
52B2:  RCALL  50D4
52B4:  MOVFF  01,8AB
52B8:  MOVFF  89D,8AC
52BC:  MOVLW  02
52BE:  MOVLB  8
52C0:  MOVWF  xAD
52C2:  MOVLB  0
52C4:  RCALL  50D4
52C6:  MOVF   01,W
52C8:  MOVLB  8
52CA:  XORWF  xAB,F
52CC:  MOVFF  8A1,8AC
52D0:  MOVLW  03
52D2:  MOVWF  xAD
52D4:  MOVLB  0
52D6:  RCALL  50D4
52D8:  MOVF   01,W
52DA:  MOVLB  8
52DC:  XORWF  xAB,F
52DE:  MOVFF  8A5,8AC
52E2:  MOVLW  01
52E4:  MOVWF  xAD
52E6:  MOVLB  0
52E8:  RCALL  50D4
52EA:  MOVLB  8
52EC:  MOVF   xAB,W
52EE:  XORWF  01,W
52F0:  MOVFF  8AA,FEA
52F4:  MOVFF  8A9,FE9
52F8:  MOVWF  FEF
....................       state[2][0] = multi(temp[0][0],1) ^ multi(temp[1][0],1) ^ multi(temp[2][0],2) ^ multi(temp[3][0],3); 
52FA:  MOVLW  08
52FC:  ADDWF  x94,W
52FE:  MOVWF  01
5300:  MOVLW  00
5302:  ADDWFC x95,W
5304:  MOVWF  03
5306:  MOVFF  01,8A9
530A:  MOVWF  xAA
530C:  MOVFF  899,8AC
5310:  MOVLW  01
5312:  MOVWF  xAD
5314:  MOVLB  0
5316:  RCALL  50D4
5318:  MOVFF  01,8AB
531C:  MOVFF  89D,8AC
5320:  MOVLW  01
5322:  MOVLB  8
5324:  MOVWF  xAD
5326:  MOVLB  0
5328:  RCALL  50D4
532A:  MOVF   01,W
532C:  MOVLB  8
532E:  XORWF  xAB,F
5330:  MOVFF  8A1,8AC
5334:  MOVLW  02
5336:  MOVWF  xAD
5338:  MOVLB  0
533A:  RCALL  50D4
533C:  MOVF   01,W
533E:  MOVLB  8
5340:  XORWF  xAB,F
5342:  MOVFF  8A5,8AC
5346:  MOVLW  03
5348:  MOVWF  xAD
534A:  MOVLB  0
534C:  RCALL  50D4
534E:  MOVLB  8
5350:  MOVF   xAB,W
5352:  XORWF  01,W
5354:  MOVFF  8AA,FEA
5358:  MOVFF  8A9,FE9
535C:  MOVWF  FEF
....................       state[3][0] = multi(temp[0][0],3) ^ multi(temp[1][0],1) ^ multi(temp[2][0],1) ^ multi(temp[3][0],2); 
535E:  MOVLW  0C
5360:  ADDWF  x94,W
5362:  MOVWF  01
5364:  MOVLW  00
5366:  ADDWFC x95,W
5368:  MOVWF  03
536A:  MOVFF  01,8A9
536E:  MOVWF  xAA
5370:  MOVFF  899,8AC
5374:  MOVLW  03
5376:  MOVWF  xAD
5378:  MOVLB  0
537A:  RCALL  50D4
537C:  MOVFF  01,8AB
5380:  MOVFF  89D,8AC
5384:  MOVLW  01
5386:  MOVLB  8
5388:  MOVWF  xAD
538A:  MOVLB  0
538C:  RCALL  50D4
538E:  MOVF   01,W
5390:  MOVLB  8
5392:  XORWF  xAB,F
5394:  MOVFF  8A1,8AC
5398:  MOVLW  01
539A:  MOVWF  xAD
539C:  MOVLB  0
539E:  RCALL  50D4
53A0:  MOVF   01,W
53A2:  MOVLB  8
53A4:  XORWF  xAB,F
53A6:  MOVFF  8A5,8AC
53AA:  MOVLW  02
53AC:  MOVWF  xAD
53AE:  MOVLB  0
53B0:  RCALL  50D4
53B2:  MOVLB  8
53B4:  MOVF   xAB,W
53B6:  XORWF  01,W
53B8:  MOVFF  8AA,FEA
53BC:  MOVFF  8A9,FE9
53C0:  MOVWF  FEF
....................  
....................       state[0][1] = multi(temp[0][1],2) ^ multi(temp[1][1],3) ^ multi(temp[2][1],1) ^ multi(temp[3][1],1); 
53C2:  MOVLW  01
53C4:  ADDWF  x94,W
53C6:  MOVWF  01
53C8:  MOVLW  00
53CA:  ADDWFC x95,W
53CC:  MOVWF  03
53CE:  MOVFF  01,8A9
53D2:  MOVWF  xAA
53D4:  MOVFF  89A,8AC
53D8:  MOVLW  02
53DA:  MOVWF  xAD
53DC:  MOVLB  0
53DE:  RCALL  50D4
53E0:  MOVFF  01,8AB
53E4:  MOVFF  89E,8AC
53E8:  MOVLW  03
53EA:  MOVLB  8
53EC:  MOVWF  xAD
53EE:  MOVLB  0
53F0:  RCALL  50D4
53F2:  MOVF   01,W
53F4:  MOVLB  8
53F6:  XORWF  xAB,F
53F8:  MOVFF  8A2,8AC
53FC:  MOVLW  01
53FE:  MOVWF  xAD
5400:  MOVLB  0
5402:  RCALL  50D4
5404:  MOVF   01,W
5406:  MOVLB  8
5408:  XORWF  xAB,F
540A:  MOVFF  8A6,8AC
540E:  MOVLW  01
5410:  MOVWF  xAD
5412:  MOVLB  0
5414:  RCALL  50D4
5416:  MOVLB  8
5418:  MOVF   xAB,W
541A:  XORWF  01,W
541C:  MOVFF  8AA,FEA
5420:  MOVFF  8A9,FE9
5424:  MOVWF  FEF
....................       state[1][1] = multi(temp[0][1],1) ^ multi(temp[1][1],2) ^ multi(temp[2][1],3) ^ multi(temp[3][1],1); 
5426:  MOVLW  05
5428:  ADDWF  x94,W
542A:  MOVWF  01
542C:  MOVLW  00
542E:  ADDWFC x95,W
5430:  MOVWF  03
5432:  MOVFF  01,8A9
5436:  MOVWF  xAA
5438:  MOVFF  89A,8AC
543C:  MOVLW  01
543E:  MOVWF  xAD
5440:  MOVLB  0
5442:  RCALL  50D4
5444:  MOVFF  01,8AB
5448:  MOVFF  89E,8AC
544C:  MOVLW  02
544E:  MOVLB  8
5450:  MOVWF  xAD
5452:  MOVLB  0
5454:  RCALL  50D4
5456:  MOVF   01,W
5458:  MOVLB  8
545A:  XORWF  xAB,F
545C:  MOVFF  8A2,8AC
5460:  MOVLW  03
5462:  MOVWF  xAD
5464:  MOVLB  0
5466:  RCALL  50D4
5468:  MOVF   01,W
546A:  MOVLB  8
546C:  XORWF  xAB,F
546E:  MOVFF  8A6,8AC
5472:  MOVLW  01
5474:  MOVWF  xAD
5476:  MOVLB  0
5478:  RCALL  50D4
547A:  MOVLB  8
547C:  MOVF   xAB,W
547E:  XORWF  01,W
5480:  MOVFF  8AA,FEA
5484:  MOVFF  8A9,FE9
5488:  MOVWF  FEF
....................       state[2][1] = multi(temp[0][1],1) ^ multi(temp[1][1],1) ^ multi(temp[2][1],2) ^ multi(temp[3][1],3); 
548A:  MOVLW  09
548C:  ADDWF  x94,W
548E:  MOVWF  01
5490:  MOVLW  00
5492:  ADDWFC x95,W
5494:  MOVWF  03
5496:  MOVFF  01,8A9
549A:  MOVWF  xAA
549C:  MOVFF  89A,8AC
54A0:  MOVLW  01
54A2:  MOVWF  xAD
54A4:  MOVLB  0
54A6:  RCALL  50D4
54A8:  MOVFF  01,8AB
54AC:  MOVFF  89E,8AC
54B0:  MOVLW  01
54B2:  MOVLB  8
54B4:  MOVWF  xAD
54B6:  MOVLB  0
54B8:  RCALL  50D4
54BA:  MOVF   01,W
54BC:  MOVLB  8
54BE:  XORWF  xAB,F
54C0:  MOVFF  8A2,8AC
54C4:  MOVLW  02
54C6:  MOVWF  xAD
54C8:  MOVLB  0
54CA:  RCALL  50D4
54CC:  MOVF   01,W
54CE:  MOVLB  8
54D0:  XORWF  xAB,F
54D2:  MOVFF  8A6,8AC
54D6:  MOVLW  03
54D8:  MOVWF  xAD
54DA:  MOVLB  0
54DC:  RCALL  50D4
54DE:  MOVLB  8
54E0:  MOVF   xAB,W
54E2:  XORWF  01,W
54E4:  MOVFF  8AA,FEA
54E8:  MOVFF  8A9,FE9
54EC:  MOVWF  FEF
....................       state[3][1] = multi(temp[0][1],3) ^ multi(temp[1][1],1) ^ multi(temp[2][1],1) ^ multi(temp[3][1],2); 
54EE:  MOVLW  0D
54F0:  ADDWF  x94,W
54F2:  MOVWF  01
54F4:  MOVLW  00
54F6:  ADDWFC x95,W
54F8:  MOVWF  03
54FA:  MOVFF  01,8A9
54FE:  MOVWF  xAA
5500:  MOVFF  89A,8AC
5504:  MOVLW  03
5506:  MOVWF  xAD
5508:  MOVLB  0
550A:  RCALL  50D4
550C:  MOVFF  01,8AB
5510:  MOVFF  89E,8AC
5514:  MOVLW  01
5516:  MOVLB  8
5518:  MOVWF  xAD
551A:  MOVLB  0
551C:  RCALL  50D4
551E:  MOVF   01,W
5520:  MOVLB  8
5522:  XORWF  xAB,F
5524:  MOVFF  8A2,8AC
5528:  MOVLW  01
552A:  MOVWF  xAD
552C:  MOVLB  0
552E:  RCALL  50D4
5530:  MOVF   01,W
5532:  MOVLB  8
5534:  XORWF  xAB,F
5536:  MOVFF  8A6,8AC
553A:  MOVLW  02
553C:  MOVWF  xAD
553E:  MOVLB  0
5540:  RCALL  50D4
5542:  MOVLB  8
5544:  MOVF   xAB,W
5546:  XORWF  01,W
5548:  MOVFF  8AA,FEA
554C:  MOVFF  8A9,FE9
5550:  MOVWF  FEF
....................  
....................       state[0][2] = multi(temp[0][2],2) ^ multi(temp[1][2],3) ^ multi(temp[2][2],1) ^ multi(temp[3][2],1); 
5552:  MOVLW  02
5554:  ADDWF  x94,W
5556:  MOVWF  01
5558:  MOVLW  00
555A:  ADDWFC x95,W
555C:  MOVWF  03
555E:  MOVFF  01,8A9
5562:  MOVWF  xAA
5564:  MOVFF  89B,8AC
5568:  MOVLW  02
556A:  MOVWF  xAD
556C:  MOVLB  0
556E:  RCALL  50D4
5570:  MOVFF  01,8AB
5574:  MOVFF  89F,8AC
5578:  MOVLW  03
557A:  MOVLB  8
557C:  MOVWF  xAD
557E:  MOVLB  0
5580:  RCALL  50D4
5582:  MOVF   01,W
5584:  MOVLB  8
5586:  XORWF  xAB,F
5588:  MOVFF  8A3,8AC
558C:  MOVLW  01
558E:  MOVWF  xAD
5590:  MOVLB  0
5592:  RCALL  50D4
5594:  MOVF   01,W
5596:  MOVLB  8
5598:  XORWF  xAB,F
559A:  MOVFF  8A7,8AC
559E:  MOVLW  01
55A0:  MOVWF  xAD
55A2:  MOVLB  0
55A4:  RCALL  50D4
55A6:  MOVLB  8
55A8:  MOVF   xAB,W
55AA:  XORWF  01,W
55AC:  MOVFF  8AA,FEA
55B0:  MOVFF  8A9,FE9
55B4:  MOVWF  FEF
....................       state[1][2] = multi(temp[0][2],1) ^ multi(temp[1][2],2) ^ multi(temp[2][2],3) ^ multi(temp[3][2],1); 
55B6:  MOVLW  06
55B8:  ADDWF  x94,W
55BA:  MOVWF  01
55BC:  MOVLW  00
55BE:  ADDWFC x95,W
55C0:  MOVWF  03
55C2:  MOVFF  01,8A9
55C6:  MOVWF  xAA
55C8:  MOVFF  89B,8AC
55CC:  MOVLW  01
55CE:  MOVWF  xAD
55D0:  MOVLB  0
55D2:  RCALL  50D4
55D4:  MOVFF  01,8AB
55D8:  MOVFF  89F,8AC
55DC:  MOVLW  02
55DE:  MOVLB  8
55E0:  MOVWF  xAD
55E2:  MOVLB  0
55E4:  RCALL  50D4
55E6:  MOVF   01,W
55E8:  MOVLB  8
55EA:  XORWF  xAB,F
55EC:  MOVFF  8A3,8AC
55F0:  MOVLW  03
55F2:  MOVWF  xAD
55F4:  MOVLB  0
55F6:  RCALL  50D4
55F8:  MOVF   01,W
55FA:  MOVLB  8
55FC:  XORWF  xAB,F
55FE:  MOVFF  8A7,8AC
5602:  MOVLW  01
5604:  MOVWF  xAD
5606:  MOVLB  0
5608:  RCALL  50D4
560A:  MOVLB  8
560C:  MOVF   xAB,W
560E:  XORWF  01,W
5610:  MOVFF  8AA,FEA
5614:  MOVFF  8A9,FE9
5618:  MOVWF  FEF
....................       state[2][2] = multi(temp[0][2],1) ^ multi(temp[1][2],1) ^ multi(temp[2][2],2) ^ multi(temp[3][2],3); 
561A:  MOVLW  0A
561C:  ADDWF  x94,W
561E:  MOVWF  01
5620:  MOVLW  00
5622:  ADDWFC x95,W
5624:  MOVWF  03
5626:  MOVFF  01,8A9
562A:  MOVWF  xAA
562C:  MOVFF  89B,8AC
5630:  MOVLW  01
5632:  MOVWF  xAD
5634:  MOVLB  0
5636:  RCALL  50D4
5638:  MOVFF  01,8AB
563C:  MOVFF  89F,8AC
5640:  MOVLW  01
5642:  MOVLB  8
5644:  MOVWF  xAD
5646:  MOVLB  0
5648:  RCALL  50D4
564A:  MOVF   01,W
564C:  MOVLB  8
564E:  XORWF  xAB,F
5650:  MOVFF  8A3,8AC
5654:  MOVLW  02
5656:  MOVWF  xAD
5658:  MOVLB  0
565A:  RCALL  50D4
565C:  MOVF   01,W
565E:  MOVLB  8
5660:  XORWF  xAB,F
5662:  MOVFF  8A7,8AC
5666:  MOVLW  03
5668:  MOVWF  xAD
566A:  MOVLB  0
566C:  RCALL  50D4
566E:  MOVLB  8
5670:  MOVF   xAB,W
5672:  XORWF  01,W
5674:  MOVFF  8AA,FEA
5678:  MOVFF  8A9,FE9
567C:  MOVWF  FEF
....................       state[3][2] = multi(temp[0][2],3) ^ multi(temp[1][2],1) ^ multi(temp[2][2],1) ^ multi(temp[3][2],2); 
567E:  MOVLW  0E
5680:  ADDWF  x94,W
5682:  MOVWF  01
5684:  MOVLW  00
5686:  ADDWFC x95,W
5688:  MOVWF  03
568A:  MOVFF  01,8A9
568E:  MOVWF  xAA
5690:  MOVFF  89B,8AC
5694:  MOVLW  03
5696:  MOVWF  xAD
5698:  MOVLB  0
569A:  RCALL  50D4
569C:  MOVFF  01,8AB
56A0:  MOVFF  89F,8AC
56A4:  MOVLW  01
56A6:  MOVLB  8
56A8:  MOVWF  xAD
56AA:  MOVLB  0
56AC:  RCALL  50D4
56AE:  MOVF   01,W
56B0:  MOVLB  8
56B2:  XORWF  xAB,F
56B4:  MOVFF  8A3,8AC
56B8:  MOVLW  01
56BA:  MOVWF  xAD
56BC:  MOVLB  0
56BE:  RCALL  50D4
56C0:  MOVF   01,W
56C2:  MOVLB  8
56C4:  XORWF  xAB,F
56C6:  MOVFF  8A7,8AC
56CA:  MOVLW  02
56CC:  MOVWF  xAD
56CE:  MOVLB  0
56D0:  RCALL  50D4
56D2:  MOVLB  8
56D4:  MOVF   xAB,W
56D6:  XORWF  01,W
56D8:  MOVFF  8AA,FEA
56DC:  MOVFF  8A9,FE9
56E0:  MOVWF  FEF
....................  
....................       state[0][3] = multi(temp[0][3],2) ^ multi(temp[1][3],3) ^ multi(temp[2][3],1) ^ multi(temp[3][3],1); 
56E2:  MOVLW  03
56E4:  ADDWF  x94,W
56E6:  MOVWF  01
56E8:  MOVLW  00
56EA:  ADDWFC x95,W
56EC:  MOVWF  03
56EE:  MOVFF  01,8A9
56F2:  MOVWF  xAA
56F4:  MOVFF  89C,8AC
56F8:  MOVLW  02
56FA:  MOVWF  xAD
56FC:  MOVLB  0
56FE:  RCALL  50D4
5700:  MOVFF  01,8AB
5704:  MOVFF  8A0,8AC
5708:  MOVLW  03
570A:  MOVLB  8
570C:  MOVWF  xAD
570E:  MOVLB  0
5710:  RCALL  50D4
5712:  MOVF   01,W
5714:  MOVLB  8
5716:  XORWF  xAB,F
5718:  MOVFF  8A4,8AC
571C:  MOVLW  01
571E:  MOVWF  xAD
5720:  MOVLB  0
5722:  RCALL  50D4
5724:  MOVF   01,W
5726:  MOVLB  8
5728:  XORWF  xAB,F
572A:  MOVFF  8A8,8AC
572E:  MOVLW  01
5730:  MOVWF  xAD
5732:  MOVLB  0
5734:  RCALL  50D4
5736:  MOVLB  8
5738:  MOVF   xAB,W
573A:  XORWF  01,W
573C:  MOVFF  8AA,FEA
5740:  MOVFF  8A9,FE9
5744:  MOVWF  FEF
....................       state[1][3] = multi(temp[0][3],1) ^ multi(temp[1][3],2) ^ multi(temp[2][3],3) ^ multi(temp[3][3],1); 
5746:  MOVLW  07
5748:  ADDWF  x94,W
574A:  MOVWF  01
574C:  MOVLW  00
574E:  ADDWFC x95,W
5750:  MOVWF  03
5752:  MOVFF  01,8A9
5756:  MOVWF  xAA
5758:  MOVFF  89C,8AC
575C:  MOVLW  01
575E:  MOVWF  xAD
5760:  MOVLB  0
5762:  RCALL  50D4
5764:  MOVFF  01,8AB
5768:  MOVFF  8A0,8AC
576C:  MOVLW  02
576E:  MOVLB  8
5770:  MOVWF  xAD
5772:  MOVLB  0
5774:  RCALL  50D4
5776:  MOVF   01,W
5778:  MOVLB  8
577A:  XORWF  xAB,F
577C:  MOVFF  8A4,8AC
5780:  MOVLW  03
5782:  MOVWF  xAD
5784:  MOVLB  0
5786:  RCALL  50D4
5788:  MOVF   01,W
578A:  MOVLB  8
578C:  XORWF  xAB,F
578E:  MOVFF  8A8,8AC
5792:  MOVLW  01
5794:  MOVWF  xAD
5796:  MOVLB  0
5798:  RCALL  50D4
579A:  MOVLB  8
579C:  MOVF   xAB,W
579E:  XORWF  01,W
57A0:  MOVFF  8AA,FEA
57A4:  MOVFF  8A9,FE9
57A8:  MOVWF  FEF
....................       state[2][3] = multi(temp[0][3],1) ^ multi(temp[1][3],1) ^ multi(temp[2][3],2) ^ multi(temp[3][3],3); 
57AA:  MOVLW  0B
57AC:  ADDWF  x94,W
57AE:  MOVWF  01
57B0:  MOVLW  00
57B2:  ADDWFC x95,W
57B4:  MOVWF  03
57B6:  MOVFF  01,8A9
57BA:  MOVWF  xAA
57BC:  MOVFF  89C,8AC
57C0:  MOVLW  01
57C2:  MOVWF  xAD
57C4:  MOVLB  0
57C6:  RCALL  50D4
57C8:  MOVFF  01,8AB
57CC:  MOVFF  8A0,8AC
57D0:  MOVLW  01
57D2:  MOVLB  8
57D4:  MOVWF  xAD
57D6:  MOVLB  0
57D8:  RCALL  50D4
57DA:  MOVF   01,W
57DC:  MOVLB  8
57DE:  XORWF  xAB,F
57E0:  MOVFF  8A4,8AC
57E4:  MOVLW  02
57E6:  MOVWF  xAD
57E8:  MOVLB  0
57EA:  RCALL  50D4
57EC:  MOVF   01,W
57EE:  MOVLB  8
57F0:  XORWF  xAB,F
57F2:  MOVFF  8A8,8AC
57F6:  MOVLW  03
57F8:  MOVWF  xAD
57FA:  MOVLB  0
57FC:  RCALL  50D4
57FE:  MOVLB  8
5800:  MOVF   xAB,W
5802:  XORWF  01,W
5804:  MOVFF  8AA,FEA
5808:  MOVFF  8A9,FE9
580C:  MOVWF  FEF
....................       state[3][3] = multi(temp[0][3],3) ^ multi(temp[1][3],1) ^ multi(temp[2][3],1) ^ multi(temp[3][3],2); 
580E:  MOVLW  0F
5810:  ADDWF  x94,W
5812:  MOVWF  01
5814:  MOVLW  00
5816:  ADDWFC x95,W
5818:  MOVWF  03
581A:  MOVFF  01,8A9
581E:  MOVWF  xAA
5820:  MOVFF  89C,8AC
5824:  MOVLW  03
5826:  MOVWF  xAD
5828:  MOVLB  0
582A:  RCALL  50D4
582C:  MOVFF  01,8AB
5830:  MOVFF  8A0,8AC
5834:  MOVLW  01
5836:  MOVLB  8
5838:  MOVWF  xAD
583A:  MOVLB  0
583C:  RCALL  50D4
583E:  MOVF   01,W
5840:  MOVLB  8
5842:  XORWF  xAB,F
5844:  MOVFF  8A4,8AC
5848:  MOVLW  01
584A:  MOVWF  xAD
584C:  MOVLB  0
584E:  RCALL  50D4
5850:  MOVF   01,W
5852:  MOVLB  8
5854:  XORWF  xAB,F
5856:  MOVFF  8A8,8AC
585A:  MOVLW  02
585C:  MOVWF  xAD
585E:  MOVLB  0
5860:  RCALL  50D4
5862:  MOVLB  8
5864:  MOVF   xAB,W
5866:  XORWF  01,W
5868:  MOVFF  8AA,FEA
586C:  MOVFF  8A9,FE9
5870:  MOVWF  FEF
....................    } 
....................        
....................    else //dcryptage 
5872:  BRA    5F2A
....................    { 
....................       state[0][0] = multi(temp[0][0],14) ^ multi(temp[1][0],11) ^ multi(temp[2][0],13) ^ multi(temp[3][0],9); 
5874:  MOVFF  894,01
5878:  MOVFF  895,03
587C:  MOVFF  894,8A9
5880:  MOVFF  895,8AA
5884:  MOVFF  899,8AC
5888:  MOVLW  0E
588A:  MOVWF  xAD
588C:  MOVLB  0
588E:  RCALL  50D4
5890:  MOVFF  01,8AB
5894:  MOVFF  89D,8AC
5898:  MOVLW  0B
589A:  MOVLB  8
589C:  MOVWF  xAD
589E:  MOVLB  0
58A0:  RCALL  50D4
58A2:  MOVF   01,W
58A4:  MOVLB  8
58A6:  XORWF  xAB,F
58A8:  MOVFF  8A1,8AC
58AC:  MOVLW  0D
58AE:  MOVWF  xAD
58B0:  MOVLB  0
58B2:  RCALL  50D4
58B4:  MOVF   01,W
58B6:  MOVLB  8
58B8:  XORWF  xAB,F
58BA:  MOVFF  8A5,8AC
58BE:  MOVLW  09
58C0:  MOVWF  xAD
58C2:  MOVLB  0
58C4:  RCALL  50D4
58C6:  MOVLB  8
58C8:  MOVF   xAB,W
58CA:  XORWF  01,W
58CC:  MOVFF  8AA,FEA
58D0:  MOVFF  8A9,FE9
58D4:  MOVWF  FEF
....................       state[1][0] = multi(temp[0][0],9) ^ multi(temp[1][0],14) ^ multi(temp[2][0],11) ^ multi(temp[3][0],13); 
58D6:  MOVLW  04
58D8:  ADDWF  x94,W
58DA:  MOVWF  01
58DC:  MOVLW  00
58DE:  ADDWFC x95,W
58E0:  MOVWF  03
58E2:  MOVFF  01,8A9
58E6:  MOVWF  xAA
58E8:  MOVFF  899,8AC
58EC:  MOVLW  09
58EE:  MOVWF  xAD
58F0:  MOVLB  0
58F2:  CALL   50D4
58F6:  MOVFF  01,8AB
58FA:  MOVFF  89D,8AC
58FE:  MOVLW  0E
5900:  MOVLB  8
5902:  MOVWF  xAD
5904:  MOVLB  0
5906:  CALL   50D4
590A:  MOVF   01,W
590C:  MOVLB  8
590E:  XORWF  xAB,F
5910:  MOVFF  8A1,8AC
5914:  MOVLW  0B
5916:  MOVWF  xAD
5918:  MOVLB  0
591A:  CALL   50D4
591E:  MOVF   01,W
5920:  MOVLB  8
5922:  XORWF  xAB,F
5924:  MOVFF  8A5,8AC
5928:  MOVLW  0D
592A:  MOVWF  xAD
592C:  MOVLB  0
592E:  CALL   50D4
5932:  MOVLB  8
5934:  MOVF   xAB,W
5936:  XORWF  01,W
5938:  MOVFF  8AA,FEA
593C:  MOVFF  8A9,FE9
5940:  MOVWF  FEF
....................       state[2][0] = multi(temp[0][0],13) ^ multi(temp[1][0],9) ^ multi(temp[2][0],14) ^ multi(temp[3][0],11); 
5942:  MOVLW  08
5944:  ADDWF  x94,W
5946:  MOVWF  01
5948:  MOVLW  00
594A:  ADDWFC x95,W
594C:  MOVWF  03
594E:  MOVFF  01,8A9
5952:  MOVWF  xAA
5954:  MOVFF  899,8AC
5958:  MOVLW  0D
595A:  MOVWF  xAD
595C:  MOVLB  0
595E:  CALL   50D4
5962:  MOVFF  01,8AB
5966:  MOVFF  89D,8AC
596A:  MOVLW  09
596C:  MOVLB  8
596E:  MOVWF  xAD
5970:  MOVLB  0
5972:  CALL   50D4
5976:  MOVF   01,W
5978:  MOVLB  8
597A:  XORWF  xAB,F
597C:  MOVFF  8A1,8AC
5980:  MOVLW  0E
5982:  MOVWF  xAD
5984:  MOVLB  0
5986:  CALL   50D4
598A:  MOVF   01,W
598C:  MOVLB  8
598E:  XORWF  xAB,F
5990:  MOVFF  8A5,8AC
5994:  MOVLW  0B
5996:  MOVWF  xAD
5998:  MOVLB  0
599A:  CALL   50D4
599E:  MOVLB  8
59A0:  MOVF   xAB,W
59A2:  XORWF  01,W
59A4:  MOVFF  8AA,FEA
59A8:  MOVFF  8A9,FE9
59AC:  MOVWF  FEF
....................       state[3][0] = multi(temp[0][0],11) ^ multi(temp[1][0],13) ^ multi(temp[2][0],9) ^ multi(temp[3][0],14); 
59AE:  MOVLW  0C
59B0:  ADDWF  x94,W
59B2:  MOVWF  01
59B4:  MOVLW  00
59B6:  ADDWFC x95,W
59B8:  MOVWF  03
59BA:  MOVFF  01,8A9
59BE:  MOVWF  xAA
59C0:  MOVFF  899,8AC
59C4:  MOVLW  0B
59C6:  MOVWF  xAD
59C8:  MOVLB  0
59CA:  CALL   50D4
59CE:  MOVFF  01,8AB
59D2:  MOVFF  89D,8AC
59D6:  MOVLW  0D
59D8:  MOVLB  8
59DA:  MOVWF  xAD
59DC:  MOVLB  0
59DE:  CALL   50D4
59E2:  MOVF   01,W
59E4:  MOVLB  8
59E6:  XORWF  xAB,F
59E8:  MOVFF  8A1,8AC
59EC:  MOVLW  09
59EE:  MOVWF  xAD
59F0:  MOVLB  0
59F2:  CALL   50D4
59F6:  MOVF   01,W
59F8:  MOVLB  8
59FA:  XORWF  xAB,F
59FC:  MOVFF  8A5,8AC
5A00:  MOVLW  0E
5A02:  MOVWF  xAD
5A04:  MOVLB  0
5A06:  CALL   50D4
5A0A:  MOVLB  8
5A0C:  MOVF   xAB,W
5A0E:  XORWF  01,W
5A10:  MOVFF  8AA,FEA
5A14:  MOVFF  8A9,FE9
5A18:  MOVWF  FEF
....................  
....................       state[0][1] = multi(temp[0][1],14) ^ multi(temp[1][1],11) ^ multi(temp[2][1],13) ^ multi(temp[3][1],9); 
5A1A:  MOVLW  01
5A1C:  ADDWF  x94,W
5A1E:  MOVWF  01
5A20:  MOVLW  00
5A22:  ADDWFC x95,W
5A24:  MOVWF  03
5A26:  MOVFF  01,8A9
5A2A:  MOVWF  xAA
5A2C:  MOVFF  89A,8AC
5A30:  MOVLW  0E
5A32:  MOVWF  xAD
5A34:  MOVLB  0
5A36:  CALL   50D4
5A3A:  MOVFF  01,8AB
5A3E:  MOVFF  89E,8AC
5A42:  MOVLW  0B
5A44:  MOVLB  8
5A46:  MOVWF  xAD
5A48:  MOVLB  0
5A4A:  CALL   50D4
5A4E:  MOVF   01,W
5A50:  MOVLB  8
5A52:  XORWF  xAB,F
5A54:  MOVFF  8A2,8AC
5A58:  MOVLW  0D
5A5A:  MOVWF  xAD
5A5C:  MOVLB  0
5A5E:  CALL   50D4
5A62:  MOVF   01,W
5A64:  MOVLB  8
5A66:  XORWF  xAB,F
5A68:  MOVFF  8A6,8AC
5A6C:  MOVLW  09
5A6E:  MOVWF  xAD
5A70:  MOVLB  0
5A72:  CALL   50D4
5A76:  MOVLB  8
5A78:  MOVF   xAB,W
5A7A:  XORWF  01,W
5A7C:  MOVFF  8AA,FEA
5A80:  MOVFF  8A9,FE9
5A84:  MOVWF  FEF
....................       state[1][1] = multi(temp[0][1],9) ^ multi(temp[1][1],14) ^ multi(temp[2][1],11) ^ multi(temp[3][1],13); 
5A86:  MOVLW  05
5A88:  ADDWF  x94,W
5A8A:  MOVWF  01
5A8C:  MOVLW  00
5A8E:  ADDWFC x95,W
5A90:  MOVWF  03
5A92:  MOVFF  01,8A9
5A96:  MOVWF  xAA
5A98:  MOVFF  89A,8AC
5A9C:  MOVLW  09
5A9E:  MOVWF  xAD
5AA0:  MOVLB  0
5AA2:  CALL   50D4
5AA6:  MOVFF  01,8AB
5AAA:  MOVFF  89E,8AC
5AAE:  MOVLW  0E
5AB0:  MOVLB  8
5AB2:  MOVWF  xAD
5AB4:  MOVLB  0
5AB6:  CALL   50D4
5ABA:  MOVF   01,W
5ABC:  MOVLB  8
5ABE:  XORWF  xAB,F
5AC0:  MOVFF  8A2,8AC
5AC4:  MOVLW  0B
5AC6:  MOVWF  xAD
5AC8:  MOVLB  0
5ACA:  CALL   50D4
5ACE:  MOVF   01,W
5AD0:  MOVLB  8
5AD2:  XORWF  xAB,F
5AD4:  MOVFF  8A6,8AC
5AD8:  MOVLW  0D
5ADA:  MOVWF  xAD
5ADC:  MOVLB  0
5ADE:  CALL   50D4
5AE2:  MOVLB  8
5AE4:  MOVF   xAB,W
5AE6:  XORWF  01,W
5AE8:  MOVFF  8AA,FEA
5AEC:  MOVFF  8A9,FE9
5AF0:  MOVWF  FEF
....................       state[2][1] = multi(temp[0][1],13) ^ multi(temp[1][1],9) ^ multi(temp[2][1],14) ^ multi(temp[3][1],11); 
5AF2:  MOVLW  09
5AF4:  ADDWF  x94,W
5AF6:  MOVWF  01
5AF8:  MOVLW  00
5AFA:  ADDWFC x95,W
5AFC:  MOVWF  03
5AFE:  MOVFF  01,8A9
5B02:  MOVWF  xAA
5B04:  MOVFF  89A,8AC
5B08:  MOVLW  0D
5B0A:  MOVWF  xAD
5B0C:  MOVLB  0
5B0E:  CALL   50D4
5B12:  MOVFF  01,8AB
5B16:  MOVFF  89E,8AC
5B1A:  MOVLW  09
5B1C:  MOVLB  8
5B1E:  MOVWF  xAD
5B20:  MOVLB  0
5B22:  CALL   50D4
5B26:  MOVF   01,W
5B28:  MOVLB  8
5B2A:  XORWF  xAB,F
5B2C:  MOVFF  8A2,8AC
5B30:  MOVLW  0E
5B32:  MOVWF  xAD
5B34:  MOVLB  0
5B36:  CALL   50D4
5B3A:  MOVF   01,W
5B3C:  MOVLB  8
5B3E:  XORWF  xAB,F
5B40:  MOVFF  8A6,8AC
5B44:  MOVLW  0B
5B46:  MOVWF  xAD
5B48:  MOVLB  0
5B4A:  CALL   50D4
5B4E:  MOVLB  8
5B50:  MOVF   xAB,W
5B52:  XORWF  01,W
5B54:  MOVFF  8AA,FEA
5B58:  MOVFF  8A9,FE9
5B5C:  MOVWF  FEF
....................       state[3][1] = multi(temp[0][1],11) ^ multi(temp[1][1],13) ^ multi(temp[2][1],9) ^ multi(temp[3][1],14); 
5B5E:  MOVLW  0D
5B60:  ADDWF  x94,W
5B62:  MOVWF  01
5B64:  MOVLW  00
5B66:  ADDWFC x95,W
5B68:  MOVWF  03
5B6A:  MOVFF  01,8A9
5B6E:  MOVWF  xAA
5B70:  MOVFF  89A,8AC
5B74:  MOVLW  0B
5B76:  MOVWF  xAD
5B78:  MOVLB  0
5B7A:  CALL   50D4
5B7E:  MOVFF  01,8AB
5B82:  MOVFF  89E,8AC
5B86:  MOVLW  0D
5B88:  MOVLB  8
5B8A:  MOVWF  xAD
5B8C:  MOVLB  0
5B8E:  CALL   50D4
5B92:  MOVF   01,W
5B94:  MOVLB  8
5B96:  XORWF  xAB,F
5B98:  MOVFF  8A2,8AC
5B9C:  MOVLW  09
5B9E:  MOVWF  xAD
5BA0:  MOVLB  0
5BA2:  CALL   50D4
5BA6:  MOVF   01,W
5BA8:  MOVLB  8
5BAA:  XORWF  xAB,F
5BAC:  MOVFF  8A6,8AC
5BB0:  MOVLW  0E
5BB2:  MOVWF  xAD
5BB4:  MOVLB  0
5BB6:  CALL   50D4
5BBA:  MOVLB  8
5BBC:  MOVF   xAB,W
5BBE:  XORWF  01,W
5BC0:  MOVFF  8AA,FEA
5BC4:  MOVFF  8A9,FE9
5BC8:  MOVWF  FEF
....................  
....................       state[0][2] = multi(temp[0][2],14) ^ multi(temp[1][2],11) ^ multi(temp[2][2],13) ^ multi(temp[3][2],9); 
5BCA:  MOVLW  02
5BCC:  ADDWF  x94,W
5BCE:  MOVWF  01
5BD0:  MOVLW  00
5BD2:  ADDWFC x95,W
5BD4:  MOVWF  03
5BD6:  MOVFF  01,8A9
5BDA:  MOVWF  xAA
5BDC:  MOVFF  89B,8AC
5BE0:  MOVLW  0E
5BE2:  MOVWF  xAD
5BE4:  MOVLB  0
5BE6:  CALL   50D4
5BEA:  MOVFF  01,8AB
5BEE:  MOVFF  89F,8AC
5BF2:  MOVLW  0B
5BF4:  MOVLB  8
5BF6:  MOVWF  xAD
5BF8:  MOVLB  0
5BFA:  CALL   50D4
5BFE:  MOVF   01,W
5C00:  MOVLB  8
5C02:  XORWF  xAB,F
5C04:  MOVFF  8A3,8AC
5C08:  MOVLW  0D
5C0A:  MOVWF  xAD
5C0C:  MOVLB  0
5C0E:  CALL   50D4
5C12:  MOVF   01,W
5C14:  MOVLB  8
5C16:  XORWF  xAB,F
5C18:  MOVFF  8A7,8AC
5C1C:  MOVLW  09
5C1E:  MOVWF  xAD
5C20:  MOVLB  0
5C22:  CALL   50D4
5C26:  MOVLB  8
5C28:  MOVF   xAB,W
5C2A:  XORWF  01,W
5C2C:  MOVFF  8AA,FEA
5C30:  MOVFF  8A9,FE9
5C34:  MOVWF  FEF
....................       state[1][2] = multi(temp[0][2],9) ^ multi(temp[1][2],14) ^ multi(temp[2][2],11) ^ multi(temp[3][2],13); 
5C36:  MOVLW  06
5C38:  ADDWF  x94,W
5C3A:  MOVWF  01
5C3C:  MOVLW  00
5C3E:  ADDWFC x95,W
5C40:  MOVWF  03
5C42:  MOVFF  01,8A9
5C46:  MOVWF  xAA
5C48:  MOVFF  89B,8AC
5C4C:  MOVLW  09
5C4E:  MOVWF  xAD
5C50:  MOVLB  0
5C52:  CALL   50D4
5C56:  MOVFF  01,8AB
5C5A:  MOVFF  89F,8AC
5C5E:  MOVLW  0E
5C60:  MOVLB  8
5C62:  MOVWF  xAD
5C64:  MOVLB  0
5C66:  CALL   50D4
5C6A:  MOVF   01,W
5C6C:  MOVLB  8
5C6E:  XORWF  xAB,F
5C70:  MOVFF  8A3,8AC
5C74:  MOVLW  0B
5C76:  MOVWF  xAD
5C78:  MOVLB  0
5C7A:  CALL   50D4
5C7E:  MOVF   01,W
5C80:  MOVLB  8
5C82:  XORWF  xAB,F
5C84:  MOVFF  8A7,8AC
5C88:  MOVLW  0D
5C8A:  MOVWF  xAD
5C8C:  MOVLB  0
5C8E:  CALL   50D4
5C92:  MOVLB  8
5C94:  MOVF   xAB,W
5C96:  XORWF  01,W
5C98:  MOVFF  8AA,FEA
5C9C:  MOVFF  8A9,FE9
5CA0:  MOVWF  FEF
....................       state[2][2] = multi(temp[0][2],13) ^ multi(temp[1][2],9) ^ multi(temp[2][2],14) ^ multi(temp[3][2],11); 
5CA2:  MOVLW  0A
5CA4:  ADDWF  x94,W
5CA6:  MOVWF  01
5CA8:  MOVLW  00
5CAA:  ADDWFC x95,W
5CAC:  MOVWF  03
5CAE:  MOVFF  01,8A9
5CB2:  MOVWF  xAA
5CB4:  MOVFF  89B,8AC
5CB8:  MOVLW  0D
5CBA:  MOVWF  xAD
5CBC:  MOVLB  0
5CBE:  CALL   50D4
5CC2:  MOVFF  01,8AB
5CC6:  MOVFF  89F,8AC
5CCA:  MOVLW  09
5CCC:  MOVLB  8
5CCE:  MOVWF  xAD
5CD0:  MOVLB  0
5CD2:  CALL   50D4
5CD6:  MOVF   01,W
5CD8:  MOVLB  8
5CDA:  XORWF  xAB,F
5CDC:  MOVFF  8A3,8AC
5CE0:  MOVLW  0E
5CE2:  MOVWF  xAD
5CE4:  MOVLB  0
5CE6:  CALL   50D4
5CEA:  MOVF   01,W
5CEC:  MOVLB  8
5CEE:  XORWF  xAB,F
5CF0:  MOVFF  8A7,8AC
5CF4:  MOVLW  0B
5CF6:  MOVWF  xAD
5CF8:  MOVLB  0
5CFA:  CALL   50D4
5CFE:  MOVLB  8
5D00:  MOVF   xAB,W
5D02:  XORWF  01,W
5D04:  MOVFF  8AA,FEA
5D08:  MOVFF  8A9,FE9
5D0C:  MOVWF  FEF
....................       state[3][2] = multi(temp[0][2],11) ^ multi(temp[1][2],13) ^ multi(temp[2][2],9) ^ multi(temp[3][2],14); 
5D0E:  MOVLW  0E
5D10:  ADDWF  x94,W
5D12:  MOVWF  01
5D14:  MOVLW  00
5D16:  ADDWFC x95,W
5D18:  MOVWF  03
5D1A:  MOVFF  01,8A9
5D1E:  MOVWF  xAA
5D20:  MOVFF  89B,8AC
5D24:  MOVLW  0B
5D26:  MOVWF  xAD
5D28:  MOVLB  0
5D2A:  CALL   50D4
5D2E:  MOVFF  01,8AB
5D32:  MOVFF  89F,8AC
5D36:  MOVLW  0D
5D38:  MOVLB  8
5D3A:  MOVWF  xAD
5D3C:  MOVLB  0
5D3E:  CALL   50D4
5D42:  MOVF   01,W
5D44:  MOVLB  8
5D46:  XORWF  xAB,F
5D48:  MOVFF  8A3,8AC
5D4C:  MOVLW  09
5D4E:  MOVWF  xAD
5D50:  MOVLB  0
5D52:  CALL   50D4
5D56:  MOVF   01,W
5D58:  MOVLB  8
5D5A:  XORWF  xAB,F
5D5C:  MOVFF  8A7,8AC
5D60:  MOVLW  0E
5D62:  MOVWF  xAD
5D64:  MOVLB  0
5D66:  CALL   50D4
5D6A:  MOVLB  8
5D6C:  MOVF   xAB,W
5D6E:  XORWF  01,W
5D70:  MOVFF  8AA,FEA
5D74:  MOVFF  8A9,FE9
5D78:  MOVWF  FEF
....................  
....................       state[0][3] = multi(temp[0][3],14) ^ multi(temp[1][3],11) ^ multi(temp[2][3],13) ^ multi(temp[3][3],9); 
5D7A:  MOVLW  03
5D7C:  ADDWF  x94,W
5D7E:  MOVWF  01
5D80:  MOVLW  00
5D82:  ADDWFC x95,W
5D84:  MOVWF  03
5D86:  MOVFF  01,8A9
5D8A:  MOVWF  xAA
5D8C:  MOVFF  89C,8AC
5D90:  MOVLW  0E
5D92:  MOVWF  xAD
5D94:  MOVLB  0
5D96:  CALL   50D4
5D9A:  MOVFF  01,8AB
5D9E:  MOVFF  8A0,8AC
5DA2:  MOVLW  0B
5DA4:  MOVLB  8
5DA6:  MOVWF  xAD
5DA8:  MOVLB  0
5DAA:  CALL   50D4
5DAE:  MOVF   01,W
5DB0:  MOVLB  8
5DB2:  XORWF  xAB,F
5DB4:  MOVFF  8A4,8AC
5DB8:  MOVLW  0D
5DBA:  MOVWF  xAD
5DBC:  MOVLB  0
5DBE:  CALL   50D4
5DC2:  MOVF   01,W
5DC4:  MOVLB  8
5DC6:  XORWF  xAB,F
5DC8:  MOVFF  8A8,8AC
5DCC:  MOVLW  09
5DCE:  MOVWF  xAD
5DD0:  MOVLB  0
5DD2:  CALL   50D4
5DD6:  MOVLB  8
5DD8:  MOVF   xAB,W
5DDA:  XORWF  01,W
5DDC:  MOVFF  8AA,FEA
5DE0:  MOVFF  8A9,FE9
5DE4:  MOVWF  FEF
....................       state[1][3] = multi(temp[0][3],9) ^ multi(temp[1][3],14) ^ multi(temp[2][3],11) ^ multi(temp[3][3],13); 
5DE6:  MOVLW  07
5DE8:  ADDWF  x94,W
5DEA:  MOVWF  01
5DEC:  MOVLW  00
5DEE:  ADDWFC x95,W
5DF0:  MOVWF  03
5DF2:  MOVFF  01,8A9
5DF6:  MOVWF  xAA
5DF8:  MOVFF  89C,8AC
5DFC:  MOVLW  09
5DFE:  MOVWF  xAD
5E00:  MOVLB  0
5E02:  CALL   50D4
5E06:  MOVFF  01,8AB
5E0A:  MOVFF  8A0,8AC
5E0E:  MOVLW  0E
5E10:  MOVLB  8
5E12:  MOVWF  xAD
5E14:  MOVLB  0
5E16:  CALL   50D4
5E1A:  MOVF   01,W
5E1C:  MOVLB  8
5E1E:  XORWF  xAB,F
5E20:  MOVFF  8A4,8AC
5E24:  MOVLW  0B
5E26:  MOVWF  xAD
5E28:  MOVLB  0
5E2A:  CALL   50D4
5E2E:  MOVF   01,W
5E30:  MOVLB  8
5E32:  XORWF  xAB,F
5E34:  MOVFF  8A8,8AC
5E38:  MOVLW  0D
5E3A:  MOVWF  xAD
5E3C:  MOVLB  0
5E3E:  CALL   50D4
5E42:  MOVLB  8
5E44:  MOVF   xAB,W
5E46:  XORWF  01,W
5E48:  MOVFF  8AA,FEA
5E4C:  MOVFF  8A9,FE9
5E50:  MOVWF  FEF
....................       state[2][3] = multi(temp[0][3],13) ^ multi(temp[1][3],9) ^ multi(temp[2][3],14) ^ multi(temp[3][3],11); 
5E52:  MOVLW  0B
5E54:  ADDWF  x94,W
5E56:  MOVWF  01
5E58:  MOVLW  00
5E5A:  ADDWFC x95,W
5E5C:  MOVWF  03
5E5E:  MOVFF  01,8A9
5E62:  MOVWF  xAA
5E64:  MOVFF  89C,8AC
5E68:  MOVLW  0D
5E6A:  MOVWF  xAD
5E6C:  MOVLB  0
5E6E:  CALL   50D4
5E72:  MOVFF  01,8AB
5E76:  MOVFF  8A0,8AC
5E7A:  MOVLW  09
5E7C:  MOVLB  8
5E7E:  MOVWF  xAD
5E80:  MOVLB  0
5E82:  CALL   50D4
5E86:  MOVF   01,W
5E88:  MOVLB  8
5E8A:  XORWF  xAB,F
5E8C:  MOVFF  8A4,8AC
5E90:  MOVLW  0E
5E92:  MOVWF  xAD
5E94:  MOVLB  0
5E96:  CALL   50D4
5E9A:  MOVF   01,W
5E9C:  MOVLB  8
5E9E:  XORWF  xAB,F
5EA0:  MOVFF  8A8,8AC
5EA4:  MOVLW  0B
5EA6:  MOVWF  xAD
5EA8:  MOVLB  0
5EAA:  CALL   50D4
5EAE:  MOVLB  8
5EB0:  MOVF   xAB,W
5EB2:  XORWF  01,W
5EB4:  MOVFF  8AA,FEA
5EB8:  MOVFF  8A9,FE9
5EBC:  MOVWF  FEF
....................       state[3][3] = multi(temp[0][3],11) ^ multi(temp[1][3],13) ^ multi(temp[2][3],9) ^ multi(temp[3][3],14); 
5EBE:  MOVLW  0F
5EC0:  ADDWF  x94,W
5EC2:  MOVWF  01
5EC4:  MOVLW  00
5EC6:  ADDWFC x95,W
5EC8:  MOVWF  03
5ECA:  MOVFF  01,8A9
5ECE:  MOVWF  xAA
5ED0:  MOVFF  89C,8AC
5ED4:  MOVLW  0B
5ED6:  MOVWF  xAD
5ED8:  MOVLB  0
5EDA:  CALL   50D4
5EDE:  MOVFF  01,8AB
5EE2:  MOVFF  8A0,8AC
5EE6:  MOVLW  0D
5EE8:  MOVLB  8
5EEA:  MOVWF  xAD
5EEC:  MOVLB  0
5EEE:  CALL   50D4
5EF2:  MOVF   01,W
5EF4:  MOVLB  8
5EF6:  XORWF  xAB,F
5EF8:  MOVFF  8A4,8AC
5EFC:  MOVLW  09
5EFE:  MOVWF  xAD
5F00:  MOVLB  0
5F02:  CALL   50D4
5F06:  MOVF   01,W
5F08:  MOVLB  8
5F0A:  XORWF  xAB,F
5F0C:  MOVFF  8A8,8AC
5F10:  MOVLW  0E
5F12:  MOVWF  xAD
5F14:  MOVLB  0
5F16:  CALL   50D4
5F1A:  MOVLB  8
5F1C:  MOVF   xAB,W
5F1E:  XORWF  01,W
5F20:  MOVFF  8AA,FEA
5F24:  MOVFF  8A9,FE9
5F28:  MOVWF  FEF
....................    } 
....................    return 0; 
5F2A:  MOVLW  00
5F2C:  MOVWF  01
.................... } 
5F2E:  MOVLB  0
5F30:  RETURN 0
....................  
.................... /************************************************************************************************************* 
....................     Fonction :      add_round_key 
....................     Description :   Effectue l'opration add_round_key. 
....................     Paramtres:     
....................     Valeur retour:    
.................... **************************************************************************************************************/ 
.................... /** @brief   Effectue l'opration add_round_key. 
.................... **************************************************************************************************************/ 
.................... int add_round_key(unsigned int8 state[4][4], unsigned int8 round_key[4][4]) 
.................... { 
....................    int i,j; 
....................  
....................    for(i = 0; i < 4; i++) 
5F32:  MOVLB  8
5F34:  CLRF   x9A
5F36:  MOVF   x9A,W
5F38:  SUBLW  03
5F3A:  BNC   5FB0
....................    { 
....................       for(j = 0; j < 4; j++) 
5F3C:  CLRF   x9B
5F3E:  MOVF   x9B,W
5F40:  SUBLW  03
5F42:  BNC   5FAC
....................       { 
....................          state[i][j] ^= round_key[i][j]; 
5F44:  MOVF   x9A,W
5F46:  MULLW  04
5F48:  MOVF   FF3,W
5F4A:  CLRF   x9D
5F4C:  MOVWF  x9C
5F4E:  CLRF   03
5F50:  MOVF   x9B,W
5F52:  ADDWF  x9C,W
5F54:  MOVWF  01
5F56:  MOVF   x9D,W
5F58:  ADDWFC 03,F
5F5A:  MOVF   01,W
5F5C:  ADDWF  x96,W
5F5E:  MOVWF  01
5F60:  MOVF   x97,W
5F62:  ADDWFC 03,F
5F64:  MOVFF  01,89C
5F68:  MOVFF  03,89D
5F6C:  MOVFF  03,FEA
5F70:  MOVFF  01,FE9
5F74:  MOVFF  FEF,89E
5F78:  MOVF   x9A,W
5F7A:  MULLW  04
5F7C:  MOVF   FF3,W
5F7E:  CLRF   xA0
5F80:  MOVWF  x9F
5F82:  CLRF   03
5F84:  MOVF   x9B,W
5F86:  ADDWF  x9F,W
5F88:  MOVWF  01
5F8A:  MOVF   xA0,W
5F8C:  ADDWFC 03,F
5F8E:  MOVF   01,W
5F90:  ADDWF  x98,W
5F92:  MOVWF  FE9
5F94:  MOVF   x99,W
5F96:  ADDWFC 03,W
5F98:  MOVWF  FEA
5F9A:  MOVF   FEF,W
5F9C:  XORWF  x9E,W
5F9E:  MOVFF  89D,FEA
5FA2:  MOVFF  89C,FE9
5FA6:  MOVWF  FEF
....................       } 
5FA8:  INCF   x9B,F
5FAA:  BRA    5F3E
....................    } 
5FAC:  INCF   x9A,F
5FAE:  BRA    5F36
....................  
....................    return 0; 
5FB0:  MOVLW  00
5FB2:  MOVWF  01
.................... } 
5FB4:  MOVLB  0
5FB6:  RETURN 0
....................  
.................... /************************************************************************************************************* 
....................     Fonction :      aes_round 
....................     Description :   Effectue un round comprenant les 4 oprations.  
....................                 (Sauf le dernier qui ne contient pas mix_column). 
....................     Paramtres:     
....................     Valeur retour:    
.................... **************************************************************************************************************/ 
.................... /** @brief   Effectue un round comprenant les 4 oprations. 
.................... **************************************************************************************************************/ 
.................... int aes_round(unsigned int8 state[4][4], unsigned int8 round_key[4][4], int round, unsigned int8 cmd) 
.................... { 
....................    if (cmd == 'c') 
5FB8:  MOVLB  8
5FBA:  MOVF   x91,W
5FBC:  SUBLW  63
5FBE:  BNZ   605E
....................    { 
....................       byte_sub(state, cmd); 
5FC0:  MOVFF  88C,01
5FC4:  MOVFF  88D,03
5FC8:  MOVFF  88C,892
5FCC:  MOVFF  88D,893
5FD0:  MOVFF  88D,895
5FD4:  MOVFF  88C,894
5FD8:  MOVFF  891,896
5FDC:  MOVLB  0
5FDE:  CALL   4C5A
....................       shift_row(state, cmd); 
5FE2:  MOVFF  88C,01
5FE6:  MOVFF  88D,03
5FEA:  MOVFF  88C,892
5FEE:  MOVFF  88D,893
5FF2:  MOVFF  88D,895
5FF6:  MOVFF  88C,894
5FFA:  MOVFF  891,896
5FFE:  MOVLB  0
6000:  CALL   4D40
....................       if (round != 9) mix_column(state, cmd); 
6004:  MOVLB  8
6006:  MOVF   x90,W
6008:  SUBLW  09
600A:  BZ    602E
600C:  MOVFF  88C,01
6010:  MOVFF  88D,03
6014:  MOVFF  88C,892
6018:  MOVFF  88D,893
601C:  MOVFF  88D,895
6020:  MOVFF  88C,894
6024:  MOVFF  891,896
6028:  MOVLB  0
602A:  CALL   51B8
....................       add_round_key(state, round_key); 
602E:  MOVFF  88C,892
6032:  MOVFF  88D,893
6036:  MOVFF  88E,01
603A:  MOVFF  88F,03
603E:  MOVFF  88E,894
6042:  MOVFF  88F,895
6046:  MOVFF  88D,897
604A:  MOVFF  88C,896
604E:  MOVFF  88F,899
6052:  MOVFF  88E,898
6056:  MOVLB  0
6058:  RCALL  5F32
....................    } 
....................    else 
605A:  BRA    60F8
605C:  MOVLB  8
....................    { 
....................       add_round_key(state, round_key); 
605E:  MOVFF  88C,892
6062:  MOVFF  88D,893
6066:  MOVFF  88E,01
606A:  MOVFF  88F,03
606E:  MOVFF  88E,894
6072:  MOVFF  88F,895
6076:  MOVFF  88D,897
607A:  MOVFF  88C,896
607E:  MOVFF  88F,899
6082:  MOVFF  88E,898
6086:  MOVLB  0
6088:  RCALL  5F32
....................       if (round != 9) mix_column(state, cmd); 
608A:  MOVLB  8
608C:  MOVF   x90,W
608E:  SUBLW  09
6090:  BZ    60B4
6092:  MOVFF  88C,01
6096:  MOVFF  88D,03
609A:  MOVFF  88C,892
609E:  MOVFF  88D,893
60A2:  MOVFF  88D,895
60A6:  MOVFF  88C,894
60AA:  MOVFF  891,896
60AE:  MOVLB  0
60B0:  CALL   51B8
....................       shift_row(state, cmd); 
60B4:  MOVFF  88C,01
60B8:  MOVFF  88D,03
60BC:  MOVFF  88C,892
60C0:  MOVFF  88D,893
60C4:  MOVFF  88D,895
60C8:  MOVFF  88C,894
60CC:  MOVFF  891,896
60D0:  MOVLB  0
60D2:  CALL   4D40
....................       byte_sub(state, cmd); 
60D6:  MOVFF  88C,01
60DA:  MOVFF  88D,03
60DE:  MOVFF  88C,892
60E2:  MOVFF  88D,893
60E6:  MOVFF  88D,895
60EA:  MOVFF  88C,894
60EE:  MOVFF  891,896
60F2:  MOVLB  0
60F4:  CALL   4C5A
....................    } 
....................  
....................    return 0; 
60F8:  MOVLW  00
60FA:  MOVWF  01
.................... } 
60FC:  GOTO   61EE (RETURN)
....................  
.................... /************************************************************************************************************* 
....................     Fonction :      rijndael 
....................     Description :   Effectue le cryptage ou le dcryptage. 
....................     Paramtres:    cmd (commande), data (bloc de donnes de 16 bytes), cl (cipher_key) 
....................     Valeur retour:    
.................... **************************************************************************************************************/ 
.................... /** @brief   Effectue le cryptage ou le dcryptage. 
.................... **************************************************************************************************************/ 
.................... int rijndael(unsigned int8 cmd, unsigned int8 data[16], unsigned int8 cipher_key[16]) 
.................... { 
....................    int8 i, j; 
....................    unsigned int8 state[4][4]; 
....................    unsigned int8 expanded_key[11*16]; 
....................    unsigned int8 round_key[4][4]; 
....................  
....................    for(i = 0; i < 4; i++) 
6100:  MOVLB  7
6102:  CLRF   xBA
6104:  MOVF   xBA,W
6106:  SUBLW  03
6108:  BNC   616E
....................    { 
....................       for(j = 0; j < 4; j++) 
610A:  CLRF   xBB
610C:  MOVF   xBB,W
610E:  SUBLW  03
6110:  BNC   616A
....................       { 
....................          state[i][j] = data[i * 4 + j]; 
6112:  MOVF   xBA,W
6114:  MULLW  04
6116:  MOVF   FF3,W
6118:  MOVLB  8
611A:  CLRF   x8D
611C:  MOVWF  x8C
611E:  CLRF   03
6120:  MOVLB  7
6122:  MOVF   xBB,W
6124:  MOVLB  8
6126:  ADDWF  x8C,W
6128:  MOVWF  01
612A:  MOVF   x8D,W
612C:  ADDWFC 03,F
612E:  MOVF   01,W
6130:  ADDLW  BC
6132:  MOVWF  01
6134:  MOVLW  07
6136:  ADDWFC 03,F
6138:  MOVFF  03,88D
613C:  MOVLB  7
613E:  MOVF   xBA,W
6140:  MULLW  04
6142:  MOVF   FF3,W
6144:  ADDWF  xBB,W
6146:  CLRF   03
6148:  ADDWF  xB6,W
614A:  MOVWF  FE9
614C:  MOVF   xB7,W
614E:  ADDWFC 03,W
6150:  MOVWF  FEA
6152:  MOVFF  FEF,88E
6156:  MOVLB  8
6158:  MOVFF  88D,FEA
615C:  MOVFF  01,FE9
6160:  MOVFF  88E,FEF
....................       } 
6164:  MOVLB  7
6166:  INCF   xBB,F
6168:  BRA    610C
....................    } 
616A:  INCF   xBA,F
616C:  BRA    6104
....................  
....................    expand_key(cipher_key, expanded_key); 
616E:  MOVFF  7B8,01
6172:  MOVFF  7B9,03
6176:  MOVFF  7B8,88C
617A:  MOVLB  8
617C:  MOVFF  7B9,88D
6180:  MOVFF  7B9,88F
6184:  MOVFF  7B8,88E
6188:  MOVLW  07
618A:  MOVWF  x91
618C:  MOVLW  CC
618E:  MOVWF  x90
6190:  MOVLB  0
6192:  GOTO   4AF4
....................     
....................    for(i = 0; i < 10; i++) 
6196:  MOVLB  7
6198:  CLRF   xBA
619A:  MOVF   xBA,W
619C:  SUBLW  09
619E:  BNC   61F4
....................    { 
....................       if (cmd == 'd') j = 9 - i; 
61A0:  MOVF   xB5,W
61A2:  SUBLW  64
61A4:  BNZ   61B0
61A6:  MOVLW  09
61A8:  BSF    FD8.0
61AA:  SUBFWB xBA,W
61AC:  MOVWF  xBB
....................       else j = i; 
61AE:  BRA    61B4
61B0:  MOVFF  7BA,7BB
....................  
....................       select_key(expanded_key, round_key, j); 
61B4:  MOVLW  07
61B6:  MOVLB  8
61B8:  MOVWF  x8D
61BA:  MOVLW  CC
61BC:  MOVWF  x8C
61BE:  MOVLW  08
61C0:  MOVWF  x8F
61C2:  MOVLW  7C
61C4:  MOVWF  x8E
61C6:  MOVFF  7BB,890
61CA:  MOVLB  0
61CC:  GOTO   4BE4
....................       aes_round(state, round_key, j, cmd); 
61D0:  MOVLW  07
61D2:  MOVLB  8
61D4:  MOVWF  x8D
61D6:  MOVLW  BC
61D8:  MOVWF  x8C
61DA:  MOVLW  08
61DC:  MOVWF  x8F
61DE:  MOVLW  7C
61E0:  MOVWF  x8E
61E2:  MOVFF  7BB,890
61E6:  MOVFF  7B5,891
61EA:  MOVLB  0
61EC:  BRA    5FB8
....................    } 
61EE:  MOVLB  7
61F0:  INCF   xBA,F
61F2:  BRA    619A
....................  
....................    for(i = 0; i < 4; i++) 
61F4:  CLRF   xBA
61F6:  MOVF   xBA,W
61F8:  SUBLW  03
61FA:  BNC   6262
....................    { 
....................       for(j = 0; j < 4; j++) 
61FC:  CLRF   xBB
61FE:  MOVF   xBB,W
6200:  SUBLW  03
6202:  BNC   625E
....................       { 
....................          data[i * 4 + j] = state[i][j]; 
6204:  MOVF   xBA,W
6206:  MULLW  04
6208:  MOVF   FF3,W
620A:  ADDWF  xBB,W
620C:  CLRF   03
620E:  ADDWF  xB6,W
6210:  MOVWF  01
6212:  MOVF   xB7,W
6214:  ADDWFC 03,F
6216:  MOVFF  01,88C
621A:  MOVFF  03,88D
621E:  MOVLB  7
6220:  MOVF   xBA,W
6222:  MULLW  04
6224:  MOVF   FF3,W
6226:  MOVLB  8
6228:  CLRF   x8F
622A:  MOVWF  x8E
622C:  CLRF   03
622E:  MOVLB  7
6230:  MOVF   xBB,W
6232:  MOVLB  8
6234:  ADDWF  x8E,W
6236:  MOVWF  01
6238:  MOVF   x8F,W
623A:  ADDWFC 03,F
623C:  MOVF   01,W
623E:  ADDLW  BC
6240:  MOVWF  FE9
6242:  MOVLW  07
6244:  ADDWFC 03,W
6246:  MOVWF  FEA
6248:  MOVFF  FEF,88E
624C:  MOVFF  88D,FEA
6250:  MOVFF  88C,FE9
6254:  MOVFF  88E,FEF
....................       } 
6258:  MOVLB  7
625A:  INCF   xBB,F
625C:  BRA    61FE
....................    } 
625E:  INCF   xBA,F
6260:  BRA    61F6
....................     
....................    return 0; 
6262:  MOVLW  00
6264:  MOVWF  01
.................... } 
6266:  MOVLB  0
6268:  RETURN 0
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... int8 type_KB=0; 
.................... #define key_numbyte  12 
....................  
.................... int8 key_data[key_numbyte]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1E46:  MOVLB  1
1E48:  INCF   x42,F
1E4A:  MOVF   x42,W
1E4C:  SUBLW  01
1E4E:  BTFSC  FD8.0
1E50:  BRA    1FF6
....................        switch (col) { 
1E52:  MOVF   x45,W
1E54:  ADDLW  FB
1E56:  BC    1EDA
1E58:  ADDLW  05
1E5A:  MOVLB  0
1E5C:  GOTO   2000
....................          case 0   :  
....................                     output_low(COL0); 
1E60:  BCF    F92.5
1E62:  BCF    F89.5
....................                     output_high(COL1); 
1E64:  BCF    F92.3
1E66:  BSF    F89.3
....................                     output_high(COL2); 
1E68:  BCF    F92.2
1E6A:  BSF    F89.2
....................                     output_high(COL3); 
1E6C:  BCF    F92.1
1E6E:  BSF    F89.1
....................                     output_high(COL4); 
1E70:  BCF    F92.0
1E72:  BSF    F89.0
....................                     break; 
1E74:  MOVLB  1
1E76:  BRA    1EDA
....................          case 1   :  
....................                     output_low(COL1); 
1E78:  BCF    F92.3
1E7A:  BCF    F89.3
....................                     output_high(COL0); 
1E7C:  BCF    F92.5
1E7E:  BSF    F89.5
....................                     output_high(COL2); 
1E80:  BCF    F92.2
1E82:  BSF    F89.2
....................                     output_high(COL3); 
1E84:  BCF    F92.1
1E86:  BSF    F89.1
....................                     output_high(COL4); 
1E88:  BCF    F92.0
1E8A:  BSF    F89.0
....................                     break; 
1E8C:  MOVLB  1
1E8E:  BRA    1EDA
....................          case 2   :  
....................                     output_low(COL2); 
1E90:  BCF    F92.2
1E92:  BCF    F89.2
....................                     output_high(COL1); 
1E94:  BCF    F92.3
1E96:  BSF    F89.3
....................                     output_high(COL0); 
1E98:  BCF    F92.5
1E9A:  BSF    F89.5
....................                     output_high(COL3); 
1E9C:  BCF    F92.1
1E9E:  BSF    F89.1
....................                     output_high(COL4); 
1EA0:  BCF    F92.0
1EA2:  BSF    F89.0
....................                     break; 
1EA4:  MOVLB  1
1EA6:  BRA    1EDA
....................          case 3   :  
....................                     output_low(COL3); 
1EA8:  BCF    F92.1
1EAA:  BCF    F89.1
....................                     output_high(COL1); 
1EAC:  BCF    F92.3
1EAE:  BSF    F89.3
....................                     output_high(COL2); 
1EB0:  BCF    F92.2
1EB2:  BSF    F89.2
....................                     output_high(COL0); 
1EB4:  BCF    F92.5
1EB6:  BSF    F89.5
....................                     output_high(COL4); 
1EB8:  BCF    F92.0
1EBA:  BSF    F89.0
....................                     break; 
1EBC:  MOVLB  1
1EBE:  BRA    1EDA
....................          case 4   :  
....................                     output_low(COL4); 
1EC0:  BCF    F92.0
1EC2:  BCF    F89.0
....................                     output_high(COL1); 
1EC4:  BCF    F92.3
1EC6:  BSF    F89.3
....................                     output_high(COL2); 
1EC8:  BCF    F92.2
1ECA:  BSF    F89.2
....................                     output_high(COL3); 
1ECC:  BCF    F92.1
1ECE:  BSF    F89.1
....................                     output_high(COL0); 
1ED0:  BCF    F92.5
1ED2:  BSF    F89.5
....................                     break; 
1ED4:  MOVLB  1
1ED6:  BRA    1EDA
1ED8:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
1EDA:  BTFSS  x43.0
1EDC:  BRA    1F5C
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
1EDE:  BSF    F93.4
1EE0:  MOVLW  00
1EE2:  BTFSC  F81.4
1EE4:  MOVLW  01
1EE6:  MOVLB  8
1EE8:  MOVWF  xC1
1EEA:  BSF    F93.5
1EEC:  MOVLW  00
1EEE:  BTFSC  F81.5
1EF0:  MOVLW  01
1EF2:  ANDWF  xC1,F
1EF4:  BSF    F93.6
1EF6:  MOVLW  00
1EF8:  BTFSC  F81.6
1EFA:  MOVLW  01
1EFC:  ANDWF  xC1,F
1EFE:  BSF    F93.7
1F00:  MOVLW  00
1F02:  BTFSC  F81.7
1F04:  MOVLW  01
1F06:  ANDWF  xC1,W
1F08:  BZ    1F58
....................          { 
....................             kchar=last_key; 
1F0A:  MOVFF  144,8BF
....................             if(keydebug_en==0) 
1F0E:  MOVLB  1
1F10:  MOVF   x2C,F
1F12:  BNZ   1F46
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
1F14:  CLRF   x2A
1F16:  CLRF   x29
....................               charac_timeout=0; 
1F18:  MOVLB  0
1F1A:  CLRF   xFC
1F1C:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
1F1E:  MOVLB  1
1F20:  MOVF   x2F,W
1F22:  SUBLW  0B
1F24:  BNC   1F3A
1F26:  MOVF   x2F,W
1F28:  INCF   x2F,F
1F2A:  CLRF   03
1F2C:  ADDLW  35
1F2E:  MOVWF  FE9
1F30:  MOVLW  01
1F32:  ADDWFC 03,W
1F34:  MOVWF  FEA
1F36:  MOVFF  8BF,FEF
....................                fputc(kchar,COM2); 
1F3A:  MOVFF  8BF,8E8
1F3E:  MOVLB  0
1F40:  CALL   045C
....................             } 
....................                else fputc(kchar,COM2); 
1F44:  BRA    1F50
1F46:  MOVFF  8BF,8E8
1F4A:  MOVLB  0
1F4C:  CALL   045C
....................            kbd_down=FALSE; 
1F50:  MOVLB  1
1F52:  BCF    x43.0
....................            last_key=0; 
1F54:  CLRF   x44
1F56:  MOVLB  8
....................          } 
....................        } else 
1F58:  BRA    1FF2
1F5A:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
1F5C:  BSF    F93.4
1F5E:  MOVLW  00
1F60:  BTFSC  F81.4
1F62:  MOVLW  01
1F64:  MOVLB  8
1F66:  MOVWF  xC1
1F68:  BSF    F93.5
1F6A:  MOVLW  00
1F6C:  BTFSC  F81.5
1F6E:  MOVLW  01
1F70:  ANDWF  xC1,F
1F72:  BSF    F93.6
1F74:  MOVLW  00
1F76:  BTFSC  F81.6
1F78:  MOVLW  01
1F7A:  ANDWF  xC1,F
1F7C:  BSF    F93.7
1F7E:  MOVLW  00
1F80:  BTFSC  F81.7
1F82:  MOVLW  01
1F84:  ANDWF  xC1,W
1F86:  BNZ   1FE6
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
1F88:  BSF    F93.4
1F8A:  BTFSC  F81.4
1F8C:  BRA    1F92
....................                   row=0; 
1F8E:  CLRF   xC0
....................                 else if(input(ROW1)==0) 
1F90:  BRA    1FB4
1F92:  BSF    F93.5
1F94:  BTFSC  F81.5
1F96:  BRA    1F9E
....................                   row=1; 
1F98:  MOVLW  01
1F9A:  MOVWF  xC0
....................                 else if(input(ROW2)==0) 
1F9C:  BRA    1FB4
1F9E:  BSF    F93.6
1FA0:  BTFSC  F81.6
1FA2:  BRA    1FAA
....................                   row=2; 
1FA4:  MOVLW  02
1FA6:  MOVWF  xC0
....................                 else if(input(ROW3)==0) 
1FA8:  BRA    1FB4
1FAA:  BSF    F93.7
1FAC:  BTFSC  F81.7
1FAE:  BRA    1FB4
....................                   row=3; 
1FB0:  MOVLW  03
1FB2:  MOVWF  xC0
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
1FB4:  MOVF   xC0,W
1FB6:  MULLW  05
1FB8:  MOVF   FF3,W
1FBA:  CLRF   xC2
1FBC:  MOVWF  xC1
1FBE:  CLRF   03
1FC0:  MOVLB  1
1FC2:  MOVF   x45,W
1FC4:  MOVLB  8
1FC6:  ADDWF  xC1,W
1FC8:  MOVWF  01
1FCA:  MOVF   xC2,W
1FCC:  ADDWFC 03,F
1FCE:  MOVF   01,W
1FD0:  MOVLB  0
1FD2:  CALL   00D0
1FD6:  MOVFF  FE8,144
....................                 kbd_down = TRUE; 
1FDA:  MOVLB  1
1FDC:  BSF    x43.0
....................                 set_tris_a(0xff); 
1FDE:  MOVLW  FF
1FE0:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
1FE2:  BRA    1FF2
1FE4:  MOVLB  8
....................                { 
....................                   ++col; 
1FE6:  MOVLB  1
1FE8:  INCF   x45,F
....................                   if(col==5) col=0; 
1FEA:  MOVF   x45,W
1FEC:  SUBLW  05
1FEE:  BTFSC  FD8.2
1FF0:  CLRF   x45
....................                } 
....................          } 
....................       kbd_call_count=0; 
1FF2:  MOVLB  1
1FF4:  CLRF   x42
....................    } 
....................   return(kchar); 
1FF6:  MOVLB  8
1FF8:  MOVFF  8BF,01
.................... } 
1FFC:  MOVLB  0
1FFE:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2024:  MOVLW  E0
2026:  MOVLB  F
2028:  MOVWF  x48
202A:  BCF    FC2.6
202C:  BCF    FC2.7
202E:  MOVF   x49,W
2030:  ANDLW  E0
2032:  IORLW  17
2034:  MOVWF  x49
....................    switch(col) 
....................    { 
2036:  MOVLB  8
2038:  MOVF   xDC,W
203A:  ADDLW  FA
203C:  BC    2108
203E:  ADDLW  06
2040:  MOVLB  0
2042:  GOTO   210C
....................       case 0: 
....................         set_adc_channel(4); 
2046:  MOVLW  10
2048:  MOVWF  01
204A:  MOVF   FC2,W
204C:  ANDLW  C3
204E:  IORWF  01,W
2050:  MOVWF  FC2
....................         adc=read_adc(); 
2052:  BSF    FC2.1
2054:  BTFSC  FC2.1
2056:  BRA    2054
2058:  MOVFF  FC4,8DD
....................         return adc; 
205C:  MOVLB  8
205E:  MOVFF  8DD,01
2062:  BRA    2108
....................       break; 
2064:  BRA    2108
....................       case 1: 
....................         set_adc_channel(3); 
2066:  MOVLW  0C
2068:  MOVWF  01
206A:  MOVF   FC2,W
206C:  ANDLW  C3
206E:  IORWF  01,W
2070:  MOVWF  FC2
....................         adc=read_adc(); 
2072:  BSF    FC2.1
2074:  BTFSC  FC2.1
2076:  BRA    2074
2078:  MOVFF  FC4,8DD
....................         return adc; 
207C:  MOVLB  8
207E:  MOVFF  8DD,01
2082:  BRA    2108
....................       break; 
2084:  BRA    2108
....................       case 2: 
....................         set_adc_channel(2); 
2086:  MOVLW  08
2088:  MOVWF  01
208A:  MOVF   FC2,W
208C:  ANDLW  C3
208E:  IORWF  01,W
2090:  MOVWF  FC2
....................         adc=read_adc(); 
2092:  BSF    FC2.1
2094:  BTFSC  FC2.1
2096:  BRA    2094
2098:  MOVFF  FC4,8DD
....................         return adc; 
209C:  MOVLB  8
209E:  MOVFF  8DD,01
20A2:  BRA    2108
....................       break; 
20A4:  BRA    2108
....................       case 3: 
....................         set_adc_channel(1); 
20A6:  MOVLW  04
20A8:  MOVWF  01
20AA:  MOVF   FC2,W
20AC:  ANDLW  C3
20AE:  IORWF  01,W
20B0:  MOVWF  FC2
....................         adc=read_adc(); 
20B2:  BSF    FC2.1
20B4:  BTFSC  FC2.1
20B6:  BRA    20B4
20B8:  MOVFF  FC4,8DD
....................         return adc; 
20BC:  MOVLB  8
20BE:  MOVFF  8DD,01
20C2:  BRA    2108
....................       break; 
20C4:  BRA    2108
....................       case 4: 
....................         set_adc_channel(0); 
20C6:  MOVLW  00
20C8:  MOVWF  01
20CA:  MOVF   FC2,W
20CC:  ANDLW  C3
20CE:  IORWF  01,W
20D0:  MOVWF  FC2
....................         adc=read_adc(); 
20D2:  BSF    FC2.1
20D4:  BTFSC  FC2.1
20D6:  BRA    20D4
20D8:  MOVFF  FC4,8DD
....................         return adc; 
20DC:  MOVLB  8
20DE:  MOVFF  8DD,01
20E2:  BRA    2108
....................       break;      
20E4:  BRA    2108
....................       case 5: 
....................         set_adc_channel(11); 
20E6:  MOVLW  2C
20E8:  MOVWF  01
20EA:  MOVF   FC2,W
20EC:  ANDLW  C3
20EE:  IORWF  01,W
20F0:  MOVWF  FC2
....................         adc=read_adc(); 
20F2:  BSF    FC2.1
20F4:  BTFSC  FC2.1
20F6:  BRA    20F4
20F8:  MOVFF  FC4,8DD
....................         return adc; 
20FC:  MOVLB  8
20FE:  MOVFF  8DD,01
2102:  BRA    2108
....................       break;      
2104:  BRA    2108
2106:  MOVLB  8
....................    } 
.................... } 
2108:  MOVLB  0
210A:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
2286:  MOVLB  8
2288:  CLRF   xC7
228A:  CLRF   xC6
228C:  CLRF   xC5
228E:  CLRF   xC4
2290:  CLRF   xCB
2292:  CLRF   xCA
2294:  CLRF   xC9
2296:  CLRF   xC8
2298:  CLRF   xCF
229A:  CLRF   xCE
229C:  CLRF   xCD
229E:  CLRF   xCC
22A0:  CLRF   xD3
22A2:  CLRF   xD2
22A4:  CLRF   xD1
22A6:  CLRF   xD0
22A8:  CLRF   xD7
22AA:  CLRF   xD6
22AC:  CLRF   xD5
22AE:  CLRF   xD4
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
22B0:  CLRF   xC3
22B2:  CLRF   xC2
22B4:  MOVF   xC3,W
22B6:  SUBLW  01
22B8:  BNC   2336
22BA:  BNZ   22C2
22BC:  MOVF   xC2,W
22BE:  SUBLW  F3
22C0:  BNC   2336
....................    { 
....................       col_0=read_col(0)+col_0; 
22C2:  CLRF   xDC
22C4:  MOVLB  0
22C6:  RCALL  2024
22C8:  MOVF   01,W
22CA:  MOVLB  8
22CC:  ADDWF  xC4,F
22CE:  MOVLW  00
22D0:  ADDWFC xC5,F
22D2:  ADDWFC xC6,F
22D4:  ADDWFC xC7,F
....................       col_1=read_col(1)+col_1; 
22D6:  MOVLW  01
22D8:  MOVWF  xDC
22DA:  MOVLB  0
22DC:  RCALL  2024
22DE:  MOVF   01,W
22E0:  MOVLB  8
22E2:  ADDWF  xC8,F
22E4:  MOVLW  00
22E6:  ADDWFC xC9,F
22E8:  ADDWFC xCA,F
22EA:  ADDWFC xCB,F
....................       col_2=read_col(2)+col_2; 
22EC:  MOVLW  02
22EE:  MOVWF  xDC
22F0:  MOVLB  0
22F2:  RCALL  2024
22F4:  MOVF   01,W
22F6:  MOVLB  8
22F8:  ADDWF  xCC,F
22FA:  MOVLW  00
22FC:  ADDWFC xCD,F
22FE:  ADDWFC xCE,F
2300:  ADDWFC xCF,F
....................       col_3=read_col(3)+col_3; 
2302:  MOVLW  03
2304:  MOVWF  xDC
2306:  MOVLB  0
2308:  RCALL  2024
230A:  MOVF   01,W
230C:  MOVLB  8
230E:  ADDWF  xD0,F
2310:  MOVLW  00
2312:  ADDWFC xD1,F
2314:  ADDWFC xD2,F
2316:  ADDWFC xD3,F
....................       col_4=read_col(4)+col_4; 
2318:  MOVLW  04
231A:  MOVWF  xDC
231C:  MOVLB  0
231E:  RCALL  2024
2320:  MOVF   01,W
2322:  MOVLB  8
2324:  ADDWF  xD4,F
2326:  MOVLW  00
2328:  ADDWFC xD5,F
232A:  ADDWFC xD6,F
232C:  ADDWFC xD7,F
....................    } 
232E:  INCF   xC2,F
2330:  BTFSC  FD8.2
2332:  INCF   xC3,F
2334:  BRA    22B4
....................    col_0=col_0/500; 
2336:  BCF    FD8.1
2338:  MOVFF  8C7,8EB
233C:  MOVFF  8C6,8EA
2340:  MOVFF  8C5,8E9
2344:  MOVFF  8C4,8E8
2348:  CLRF   xEF
234A:  CLRF   xEE
234C:  MOVLW  01
234E:  MOVWF  xED
2350:  MOVLW  F4
2352:  MOVWF  xEC
2354:  MOVLB  0
2356:  RCALL  2132
2358:  MOVFF  03,8C7
235C:  MOVFF  02,8C6
2360:  MOVFF  01,8C5
2364:  MOVFF  00,8C4
....................    col_1=col_1/500; 
2368:  BCF    FD8.1
236A:  MOVFF  8CB,8EB
236E:  MOVFF  8CA,8EA
2372:  MOVFF  8C9,8E9
2376:  MOVFF  8C8,8E8
237A:  MOVLB  8
237C:  CLRF   xEF
237E:  CLRF   xEE
2380:  MOVLW  01
2382:  MOVWF  xED
2384:  MOVLW  F4
2386:  MOVWF  xEC
2388:  MOVLB  0
238A:  RCALL  2132
238C:  MOVFF  03,8CB
2390:  MOVFF  02,8CA
2394:  MOVFF  01,8C9
2398:  MOVFF  00,8C8
....................    col_2=col_2/500; 
239C:  BCF    FD8.1
239E:  MOVFF  8CF,8EB
23A2:  MOVFF  8CE,8EA
23A6:  MOVFF  8CD,8E9
23AA:  MOVFF  8CC,8E8
23AE:  MOVLB  8
23B0:  CLRF   xEF
23B2:  CLRF   xEE
23B4:  MOVLW  01
23B6:  MOVWF  xED
23B8:  MOVLW  F4
23BA:  MOVWF  xEC
23BC:  MOVLB  0
23BE:  RCALL  2132
23C0:  MOVFF  03,8CF
23C4:  MOVFF  02,8CE
23C8:  MOVFF  01,8CD
23CC:  MOVFF  00,8CC
....................    col_3=col_3/500; 
23D0:  BCF    FD8.1
23D2:  MOVFF  8D3,8EB
23D6:  MOVFF  8D2,8EA
23DA:  MOVFF  8D1,8E9
23DE:  MOVFF  8D0,8E8
23E2:  MOVLB  8
23E4:  CLRF   xEF
23E6:  CLRF   xEE
23E8:  MOVLW  01
23EA:  MOVWF  xED
23EC:  MOVLW  F4
23EE:  MOVWF  xEC
23F0:  MOVLB  0
23F2:  RCALL  2132
23F4:  MOVFF  03,8D3
23F8:  MOVFF  02,8D2
23FC:  MOVFF  01,8D1
2400:  MOVFF  00,8D0
....................    col_4=col_4/500; 
2404:  BCF    FD8.1
2406:  MOVFF  8D7,8EB
240A:  MOVFF  8D6,8EA
240E:  MOVFF  8D5,8E9
2412:  MOVFF  8D4,8E8
2416:  MOVLB  8
2418:  CLRF   xEF
241A:  CLRF   xEE
241C:  MOVLW  01
241E:  MOVWF  xED
2420:  MOVLW  F4
2422:  MOVWF  xEC
2424:  MOVLB  0
2426:  RCALL  2132
2428:  MOVFF  03,8D7
242C:  MOVFF  02,8D6
2430:  MOVFF  01,8D5
2434:  MOVFF  00,8D4
....................    if(keydebug_en) 
2438:  MOVLB  1
243A:  MOVF   x2C,F
243C:  BTFSC  FD8.2
243E:  BRA    25BA
....................    { 
....................       fprintf(COM2,"\r\n");      
2440:  MOVLW  0D
2442:  MOVLB  8
2444:  MOVWF  xE8
2446:  MOVLB  0
2448:  CALL   045C
244C:  MOVLW  0A
244E:  MOVLB  8
2450:  MOVWF  xE8
2452:  MOVLB  0
2454:  CALL   045C
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2458:  MOVLW  B2
245A:  MOVWF  FF6
245C:  MOVLW  02
245E:  MOVWF  FF7
2460:  MOVLW  07
2462:  MOVLB  8
2464:  MOVWF  xDC
2466:  MOVLB  0
2468:  CALL   141A
246C:  MOVLW  41
246E:  MOVWF  FE9
2470:  MOVFF  8C7,8DF
2474:  MOVFF  8C6,8DE
2478:  MOVFF  8C5,8DD
247C:  MOVFF  8C4,8DC
2480:  RCALL  21C6
2482:  MOVLW  0D
2484:  MOVLB  8
2486:  MOVWF  xE8
2488:  MOVLB  0
248A:  CALL   045C
248E:  MOVLW  0A
2490:  MOVLB  8
2492:  MOVWF  xE8
2494:  MOVLB  0
2496:  CALL   045C
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
249A:  MOVLW  C0
249C:  MOVWF  FF6
249E:  MOVLW  02
24A0:  MOVWF  FF7
24A2:  MOVLW  07
24A4:  MOVLB  8
24A6:  MOVWF  xDC
24A8:  MOVLB  0
24AA:  CALL   141A
24AE:  MOVLW  41
24B0:  MOVWF  FE9
24B2:  MOVFF  8CB,8DF
24B6:  MOVFF  8CA,8DE
24BA:  MOVFF  8C9,8DD
24BE:  MOVFF  8C8,8DC
24C2:  RCALL  21C6
24C4:  MOVLW  0D
24C6:  MOVLB  8
24C8:  MOVWF  xE8
24CA:  MOVLB  0
24CC:  CALL   045C
24D0:  MOVLW  0A
24D2:  MOVLB  8
24D4:  MOVWF  xE8
24D6:  MOVLB  0
24D8:  CALL   045C
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
24DC:  MOVLW  CE
24DE:  MOVWF  FF6
24E0:  MOVLW  02
24E2:  MOVWF  FF7
24E4:  MOVLW  07
24E6:  MOVLB  8
24E8:  MOVWF  xDC
24EA:  MOVLB  0
24EC:  CALL   141A
24F0:  MOVLW  41
24F2:  MOVWF  FE9
24F4:  MOVFF  8CF,8DF
24F8:  MOVFF  8CE,8DE
24FC:  MOVFF  8CD,8DD
2500:  MOVFF  8CC,8DC
2504:  RCALL  21C6
2506:  MOVLW  0D
2508:  MOVLB  8
250A:  MOVWF  xE8
250C:  MOVLB  0
250E:  CALL   045C
2512:  MOVLW  0A
2514:  MOVLB  8
2516:  MOVWF  xE8
2518:  MOVLB  0
251A:  CALL   045C
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
251E:  MOVLW  DC
2520:  MOVWF  FF6
2522:  MOVLW  02
2524:  MOVWF  FF7
2526:  MOVLW  07
2528:  MOVLB  8
252A:  MOVWF  xDC
252C:  MOVLB  0
252E:  CALL   141A
2532:  MOVLW  41
2534:  MOVWF  FE9
2536:  MOVFF  8D3,8DF
253A:  MOVFF  8D2,8DE
253E:  MOVFF  8D1,8DD
2542:  MOVFF  8D0,8DC
2546:  RCALL  21C6
2548:  MOVLW  0D
254A:  MOVLB  8
254C:  MOVWF  xE8
254E:  MOVLB  0
2550:  CALL   045C
2554:  MOVLW  0A
2556:  MOVLB  8
2558:  MOVWF  xE8
255A:  MOVLB  0
255C:  CALL   045C
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2560:  MOVLW  EA
2562:  MOVWF  FF6
2564:  MOVLW  02
2566:  MOVWF  FF7
2568:  MOVLW  07
256A:  MOVLB  8
256C:  MOVWF  xDC
256E:  MOVLB  0
2570:  CALL   141A
2574:  MOVLW  41
2576:  MOVWF  FE9
2578:  MOVFF  8D7,8DF
257C:  MOVFF  8D6,8DE
2580:  MOVFF  8D5,8DD
2584:  MOVFF  8D4,8DC
2588:  RCALL  21C6
258A:  MOVLW  0D
258C:  MOVLB  8
258E:  MOVWF  xE8
2590:  MOVLB  0
2592:  CALL   045C
2596:  MOVLW  0A
2598:  MOVLB  8
259A:  MOVWF  xE8
259C:  MOVLB  0
259E:  CALL   045C
....................       fprintf(COM2,"\r\n"); 
25A2:  MOVLW  0D
25A4:  MOVLB  8
25A6:  MOVWF  xE8
25A8:  MOVLB  0
25AA:  CALL   045C
25AE:  MOVLW  0A
25B0:  MOVLB  8
25B2:  MOVWF  xE8
25B4:  MOVLB  0
25B6:  CALL   045C
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
25BA:  MOVLB  8
25BC:  MOVF   xC7,F
25BE:  BNZ   25CE
25C0:  MOVF   xC6,F
25C2:  BNZ   25CE
25C4:  MOVF   xC5,F
25C6:  BNZ   25CE
25C8:  MOVF   xC4,W
25CA:  SUBLW  05
25CC:  BC    262E
25CE:  MOVF   xC7,F
25D0:  BNZ   262E
25D2:  MOVF   xC6,F
25D4:  BNZ   262E
25D6:  MOVF   xC5,F
25D8:  BNZ   262E
25DA:  MOVF   xC4,W
25DC:  SUBLW  3B
25DE:  BNC   262E
25E0:  MOVF   xCB,F
25E2:  BNZ   25F2
25E4:  MOVF   xCA,F
25E6:  BNZ   25F2
25E8:  MOVF   xC9,F
25EA:  BNZ   25F2
25EC:  MOVF   xC8,W
25EE:  SUBLW  64
25F0:  BC    262E
25F2:  MOVF   xCF,F
25F4:  BNZ   2604
25F6:  MOVF   xCE,F
25F8:  BNZ   2604
25FA:  MOVF   xCD,F
25FC:  BNZ   2604
25FE:  MOVF   xCC,W
2600:  SUBLW  64
2602:  BC    262E
2604:  MOVF   xD3,F
2606:  BNZ   2616
2608:  MOVF   xD2,F
260A:  BNZ   2616
260C:  MOVF   xD1,F
260E:  BNZ   2616
2610:  MOVF   xD0,W
2612:  SUBLW  64
2614:  BC    262E
2616:  MOVF   xD7,F
2618:  BNZ   2628
261A:  MOVF   xD6,F
261C:  BNZ   2628
261E:  MOVF   xD5,F
2620:  BNZ   2628
2622:  MOVF   xD4,W
2624:  SUBLW  64
2626:  BC    262E
2628:  MOVLW  00
262A:  MOVWF  01
262C:  BRA    28AC
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
262E:  MOVF   xCB,F
2630:  BNZ   2640
2632:  MOVF   xCA,F
2634:  BNZ   2640
2636:  MOVF   xC9,F
2638:  BNZ   2640
263A:  MOVF   xC8,W
263C:  SUBLW  05
263E:  BC    26A0
2640:  MOVF   xCB,F
2642:  BNZ   26A0
2644:  MOVF   xCA,F
2646:  BNZ   26A0
2648:  MOVF   xC9,F
264A:  BNZ   26A0
264C:  MOVF   xC8,W
264E:  SUBLW  3B
2650:  BNC   26A0
2652:  MOVF   xC7,F
2654:  BNZ   2664
2656:  MOVF   xC6,F
2658:  BNZ   2664
265A:  MOVF   xC5,F
265C:  BNZ   2664
265E:  MOVF   xC4,W
2660:  SUBLW  64
2662:  BC    26A0
2664:  MOVF   xCF,F
2666:  BNZ   2676
2668:  MOVF   xCE,F
266A:  BNZ   2676
266C:  MOVF   xCD,F
266E:  BNZ   2676
2670:  MOVF   xCC,W
2672:  SUBLW  64
2674:  BC    26A0
2676:  MOVF   xD3,F
2678:  BNZ   2688
267A:  MOVF   xD2,F
267C:  BNZ   2688
267E:  MOVF   xD1,F
2680:  BNZ   2688
2682:  MOVF   xD0,W
2684:  SUBLW  64
2686:  BC    26A0
2688:  MOVF   xD7,F
268A:  BNZ   269A
268C:  MOVF   xD6,F
268E:  BNZ   269A
2690:  MOVF   xD5,F
2692:  BNZ   269A
2694:  MOVF   xD4,W
2696:  SUBLW  64
2698:  BC    26A0
269A:  MOVLW  01
269C:  MOVWF  01
269E:  BRA    28AC
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
26A0:  MOVF   xCF,F
26A2:  BNZ   26B2
26A4:  MOVF   xCE,F
26A6:  BNZ   26B2
26A8:  MOVF   xCD,F
26AA:  BNZ   26B2
26AC:  MOVF   xCC,W
26AE:  SUBLW  05
26B0:  BC    2712
26B2:  MOVF   xCF,F
26B4:  BNZ   2712
26B6:  MOVF   xCE,F
26B8:  BNZ   2712
26BA:  MOVF   xCD,F
26BC:  BNZ   2712
26BE:  MOVF   xCC,W
26C0:  SUBLW  3B
26C2:  BNC   2712
26C4:  MOVF   xCB,F
26C6:  BNZ   26D6
26C8:  MOVF   xCA,F
26CA:  BNZ   26D6
26CC:  MOVF   xC9,F
26CE:  BNZ   26D6
26D0:  MOVF   xC8,W
26D2:  SUBLW  64
26D4:  BC    2712
26D6:  MOVF   xC7,F
26D8:  BNZ   26E8
26DA:  MOVF   xC6,F
26DC:  BNZ   26E8
26DE:  MOVF   xC5,F
26E0:  BNZ   26E8
26E2:  MOVF   xC4,W
26E4:  SUBLW  64
26E6:  BC    2712
26E8:  MOVF   xD3,F
26EA:  BNZ   26FA
26EC:  MOVF   xD2,F
26EE:  BNZ   26FA
26F0:  MOVF   xD1,F
26F2:  BNZ   26FA
26F4:  MOVF   xD0,W
26F6:  SUBLW  64
26F8:  BC    2712
26FA:  MOVF   xD7,F
26FC:  BNZ   270C
26FE:  MOVF   xD6,F
2700:  BNZ   270C
2702:  MOVF   xD5,F
2704:  BNZ   270C
2706:  MOVF   xD4,W
2708:  SUBLW  64
270A:  BC    2712
270C:  MOVLW  02
270E:  MOVWF  01
2710:  BRA    28AC
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2712:  MOVF   xD3,F
2714:  BNZ   2724
2716:  MOVF   xD2,F
2718:  BNZ   2724
271A:  MOVF   xD1,F
271C:  BNZ   2724
271E:  MOVF   xD0,W
2720:  SUBLW  05
2722:  BC    2784
2724:  MOVF   xD3,F
2726:  BNZ   2784
2728:  MOVF   xD2,F
272A:  BNZ   2784
272C:  MOVF   xD1,F
272E:  BNZ   2784
2730:  MOVF   xD0,W
2732:  SUBLW  3B
2734:  BNC   2784
2736:  MOVF   xCB,F
2738:  BNZ   2748
273A:  MOVF   xCA,F
273C:  BNZ   2748
273E:  MOVF   xC9,F
2740:  BNZ   2748
2742:  MOVF   xC8,W
2744:  SUBLW  64
2746:  BC    2784
2748:  MOVF   xCF,F
274A:  BNZ   275A
274C:  MOVF   xCE,F
274E:  BNZ   275A
2750:  MOVF   xCD,F
2752:  BNZ   275A
2754:  MOVF   xCC,W
2756:  SUBLW  64
2758:  BC    2784
275A:  MOVF   xC7,F
275C:  BNZ   276C
275E:  MOVF   xC6,F
2760:  BNZ   276C
2762:  MOVF   xC5,F
2764:  BNZ   276C
2766:  MOVF   xC4,W
2768:  SUBLW  64
276A:  BC    2784
276C:  MOVF   xD7,F
276E:  BNZ   277E
2770:  MOVF   xD6,F
2772:  BNZ   277E
2774:  MOVF   xD5,F
2776:  BNZ   277E
2778:  MOVF   xD4,W
277A:  SUBLW  64
277C:  BC    2784
277E:  MOVLW  03
2780:  MOVWF  01
2782:  BRA    28AC
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2784:  MOVF   xD7,F
2786:  BNZ   2796
2788:  MOVF   xD6,F
278A:  BNZ   2796
278C:  MOVF   xD5,F
278E:  BNZ   2796
2790:  MOVF   xD4,W
2792:  SUBLW  05
2794:  BC    27F6
2796:  MOVF   xD7,F
2798:  BNZ   27F6
279A:  MOVF   xD6,F
279C:  BNZ   27F6
279E:  MOVF   xD5,F
27A0:  BNZ   27F6
27A2:  MOVF   xD4,W
27A4:  SUBLW  3B
27A6:  BNC   27F6
27A8:  MOVF   xCB,F
27AA:  BNZ   27BA
27AC:  MOVF   xCA,F
27AE:  BNZ   27BA
27B0:  MOVF   xC9,F
27B2:  BNZ   27BA
27B4:  MOVF   xC8,W
27B6:  SUBLW  64
27B8:  BC    27F6
27BA:  MOVF   xCF,F
27BC:  BNZ   27CC
27BE:  MOVF   xCE,F
27C0:  BNZ   27CC
27C2:  MOVF   xCD,F
27C4:  BNZ   27CC
27C6:  MOVF   xCC,W
27C8:  SUBLW  64
27CA:  BC    27F6
27CC:  MOVF   xD3,F
27CE:  BNZ   27DE
27D0:  MOVF   xD2,F
27D2:  BNZ   27DE
27D4:  MOVF   xD1,F
27D6:  BNZ   27DE
27D8:  MOVF   xD0,W
27DA:  SUBLW  64
27DC:  BC    27F6
27DE:  MOVF   xC7,F
27E0:  BNZ   27F0
27E2:  MOVF   xC6,F
27E4:  BNZ   27F0
27E6:  MOVF   xC5,F
27E8:  BNZ   27F0
27EA:  MOVF   xC4,W
27EC:  SUBLW  64
27EE:  BC    27F6
27F0:  MOVLW  04
27F2:  MOVWF  01
27F4:  BRA    28AC
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
27F6:  MOVF   xD7,F
27F8:  BNZ   280A
27FA:  MOVF   xD6,F
27FC:  BNZ   280A
27FE:  MOVF   xD5,F
2800:  BNZ   280A
2802:  MOVF   xD4,W
2804:  SUBLW  C8
2806:  BTFSC  FD8.0
2808:  BRA    28A8
280A:  MOVF   xC7,F
280C:  BTFSS  FD8.2
280E:  BRA    28A8
2810:  MOVF   xC6,F
2812:  BTFSS  FD8.2
2814:  BRA    28A8
2816:  MOVF   xC5,F
2818:  BTFSS  FD8.2
281A:  BRA    28A8
281C:  MOVF   xC4,W
281E:  SUBLW  B3
2820:  BNC   28A8
2822:  MOVF   xC7,F
2824:  BNZ   2834
2826:  MOVF   xC6,F
2828:  BNZ   2834
282A:  MOVF   xC5,F
282C:  BNZ   2834
282E:  MOVF   xC4,W
2830:  SUBLW  64
2832:  BC    28A8
2834:  MOVF   xCB,F
2836:  BNZ   28A8
2838:  MOVF   xCA,F
283A:  BNZ   28A8
283C:  MOVF   xC9,F
283E:  BNZ   28A8
2840:  MOVF   xC8,W
2842:  SUBLW  B3
2844:  BNC   28A8
2846:  MOVF   xCB,F
2848:  BNZ   2858
284A:  MOVF   xCA,F
284C:  BNZ   2858
284E:  MOVF   xC9,F
2850:  BNZ   2858
2852:  MOVF   xC8,W
2854:  SUBLW  64
2856:  BC    28A8
2858:  MOVF   xCF,F
285A:  BNZ   28A8
285C:  MOVF   xCE,F
285E:  BNZ   28A8
2860:  MOVF   xCD,F
2862:  BNZ   28A8
2864:  MOVF   xCC,W
2866:  SUBLW  B3
2868:  BNC   28A8
286A:  MOVF   xCF,F
286C:  BNZ   287C
286E:  MOVF   xCE,F
2870:  BNZ   287C
2872:  MOVF   xCD,F
2874:  BNZ   287C
2876:  MOVF   xCC,W
2878:  SUBLW  64
287A:  BC    28A8
287C:  MOVF   xD3,F
287E:  BNZ   28A8
2880:  MOVF   xD2,F
2882:  BNZ   28A8
2884:  MOVF   xD1,F
2886:  BNZ   28A8
2888:  MOVF   xD0,W
288A:  SUBLW  B3
288C:  BNC   28A8
288E:  MOVF   xD3,F
2890:  BNZ   28A0
2892:  MOVF   xD2,F
2894:  BNZ   28A0
2896:  MOVF   xD1,F
2898:  BNZ   28A0
289A:  MOVF   xD0,W
289C:  SUBLW  64
289E:  BC    28A8
28A0:  MOVLW  04
28A2:  MOVWF  01
28A4:  BRA    28AC
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
28A6:  BRA    28AC
28A8:  MOVLW  FF
28AA:  MOVWF  01
.................... } 
28AC:  MOVLB  0
28AE:  GOTO   30F8 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
28B2:  MOVLB  8
28B4:  CLRF   xC7
28B6:  CLRF   xC6
28B8:  CLRF   xC5
28BA:  CLRF   xC4
28BC:  CLRF   xCB
28BE:  CLRF   xCA
28C0:  CLRF   xC9
28C2:  CLRF   xC8
28C4:  CLRF   xCF
28C6:  CLRF   xCE
28C8:  CLRF   xCD
28CA:  CLRF   xCC
28CC:  CLRF   xD3
28CE:  CLRF   xD2
28D0:  CLRF   xD1
28D2:  CLRF   xD0
28D4:  CLRF   xD7
28D6:  CLRF   xD6
28D8:  CLRF   xD5
28DA:  CLRF   xD4
28DC:  CLRF   xDB
28DE:  CLRF   xDA
28E0:  CLRF   xD9
28E2:  CLRF   xD8
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
28E4:  CLRF   xC3
28E6:  CLRF   xC2
28E8:  MOVF   xC3,W
28EA:  SUBLW  01
28EC:  BNC   298C
28EE:  BNZ   28F6
28F0:  MOVF   xC2,W
28F2:  SUBLW  F3
28F4:  BNC   298C
....................    { 
....................       col_0=read_col(0)+col_0; 
28F6:  CLRF   xDC
28F8:  MOVLB  0
28FA:  CALL   2024
28FE:  MOVF   01,W
2900:  MOVLB  8
2902:  ADDWF  xC4,F
2904:  MOVLW  00
2906:  ADDWFC xC5,F
2908:  ADDWFC xC6,F
290A:  ADDWFC xC7,F
....................       col_1=read_col(1)+col_1; 
290C:  MOVLW  01
290E:  MOVWF  xDC
2910:  MOVLB  0
2912:  CALL   2024
2916:  MOVF   01,W
2918:  MOVLB  8
291A:  ADDWF  xC8,F
291C:  MOVLW  00
291E:  ADDWFC xC9,F
2920:  ADDWFC xCA,F
2922:  ADDWFC xCB,F
....................       col_2=read_col(2)+col_2; 
2924:  MOVLW  02
2926:  MOVWF  xDC
2928:  MOVLB  0
292A:  CALL   2024
292E:  MOVF   01,W
2930:  MOVLB  8
2932:  ADDWF  xCC,F
2934:  MOVLW  00
2936:  ADDWFC xCD,F
2938:  ADDWFC xCE,F
293A:  ADDWFC xCF,F
....................       col_3=read_col(3)+col_3; 
293C:  MOVLW  03
293E:  MOVWF  xDC
2940:  MOVLB  0
2942:  CALL   2024
2946:  MOVF   01,W
2948:  MOVLB  8
294A:  ADDWF  xD0,F
294C:  MOVLW  00
294E:  ADDWFC xD1,F
2950:  ADDWFC xD2,F
2952:  ADDWFC xD3,F
....................       col_4=read_col(4)+col_4; 
2954:  MOVLW  04
2956:  MOVWF  xDC
2958:  MOVLB  0
295A:  CALL   2024
295E:  MOVF   01,W
2960:  MOVLB  8
2962:  ADDWF  xD4,F
2964:  MOVLW  00
2966:  ADDWFC xD5,F
2968:  ADDWFC xD6,F
296A:  ADDWFC xD7,F
....................       col_5=read_col(5)+col_5; 
296C:  MOVLW  05
296E:  MOVWF  xDC
2970:  MOVLB  0
2972:  CALL   2024
2976:  MOVF   01,W
2978:  MOVLB  8
297A:  ADDWF  xD8,F
297C:  MOVLW  00
297E:  ADDWFC xD9,F
2980:  ADDWFC xDA,F
2982:  ADDWFC xDB,F
....................    } 
2984:  INCF   xC2,F
2986:  BTFSC  FD8.2
2988:  INCF   xC3,F
298A:  BRA    28E8
....................    col_0=col_0/500; 
298C:  BCF    FD8.1
298E:  MOVFF  8C7,8EB
2992:  MOVFF  8C6,8EA
2996:  MOVFF  8C5,8E9
299A:  MOVFF  8C4,8E8
299E:  CLRF   xEF
29A0:  CLRF   xEE
29A2:  MOVLW  01
29A4:  MOVWF  xED
29A6:  MOVLW  F4
29A8:  MOVWF  xEC
29AA:  MOVLB  0
29AC:  CALL   2132
29B0:  MOVFF  03,8C7
29B4:  MOVFF  02,8C6
29B8:  MOVFF  01,8C5
29BC:  MOVFF  00,8C4
....................    col_1=col_1/500; 
29C0:  BCF    FD8.1
29C2:  MOVFF  8CB,8EB
29C6:  MOVFF  8CA,8EA
29CA:  MOVFF  8C9,8E9
29CE:  MOVFF  8C8,8E8
29D2:  MOVLB  8
29D4:  CLRF   xEF
29D6:  CLRF   xEE
29D8:  MOVLW  01
29DA:  MOVWF  xED
29DC:  MOVLW  F4
29DE:  MOVWF  xEC
29E0:  MOVLB  0
29E2:  CALL   2132
29E6:  MOVFF  03,8CB
29EA:  MOVFF  02,8CA
29EE:  MOVFF  01,8C9
29F2:  MOVFF  00,8C8
....................    col_2=col_2/500; 
29F6:  BCF    FD8.1
29F8:  MOVFF  8CF,8EB
29FC:  MOVFF  8CE,8EA
2A00:  MOVFF  8CD,8E9
2A04:  MOVFF  8CC,8E8
2A08:  MOVLB  8
2A0A:  CLRF   xEF
2A0C:  CLRF   xEE
2A0E:  MOVLW  01
2A10:  MOVWF  xED
2A12:  MOVLW  F4
2A14:  MOVWF  xEC
2A16:  MOVLB  0
2A18:  CALL   2132
2A1C:  MOVFF  03,8CF
2A20:  MOVFF  02,8CE
2A24:  MOVFF  01,8CD
2A28:  MOVFF  00,8CC
....................    col_3=col_3/500; 
2A2C:  BCF    FD8.1
2A2E:  MOVFF  8D3,8EB
2A32:  MOVFF  8D2,8EA
2A36:  MOVFF  8D1,8E9
2A3A:  MOVFF  8D0,8E8
2A3E:  MOVLB  8
2A40:  CLRF   xEF
2A42:  CLRF   xEE
2A44:  MOVLW  01
2A46:  MOVWF  xED
2A48:  MOVLW  F4
2A4A:  MOVWF  xEC
2A4C:  MOVLB  0
2A4E:  CALL   2132
2A52:  MOVFF  03,8D3
2A56:  MOVFF  02,8D2
2A5A:  MOVFF  01,8D1
2A5E:  MOVFF  00,8D0
....................    col_4=col_4/500; 
2A62:  BCF    FD8.1
2A64:  MOVFF  8D7,8EB
2A68:  MOVFF  8D6,8EA
2A6C:  MOVFF  8D5,8E9
2A70:  MOVFF  8D4,8E8
2A74:  MOVLB  8
2A76:  CLRF   xEF
2A78:  CLRF   xEE
2A7A:  MOVLW  01
2A7C:  MOVWF  xED
2A7E:  MOVLW  F4
2A80:  MOVWF  xEC
2A82:  MOVLB  0
2A84:  CALL   2132
2A88:  MOVFF  03,8D7
2A8C:  MOVFF  02,8D6
2A90:  MOVFF  01,8D5
2A94:  MOVFF  00,8D4
....................    col_5=col_5/500; 
2A98:  BCF    FD8.1
2A9A:  MOVFF  8DB,8EB
2A9E:  MOVFF  8DA,8EA
2AA2:  MOVFF  8D9,8E9
2AA6:  MOVFF  8D8,8E8
2AAA:  MOVLB  8
2AAC:  CLRF   xEF
2AAE:  CLRF   xEE
2AB0:  MOVLW  01
2AB2:  MOVWF  xED
2AB4:  MOVLW  F4
2AB6:  MOVWF  xEC
2AB8:  MOVLB  0
2ABA:  CALL   2132
2ABE:  MOVFF  03,8DB
2AC2:  MOVFF  02,8DA
2AC6:  MOVFF  01,8D9
2ACA:  MOVFF  00,8D8
....................    if(keydebug_en) 
2ACE:  MOVLB  1
2AD0:  MOVF   x2C,F
2AD2:  BTFSC  FD8.2
2AD4:  BRA    2C9E
....................    { 
....................       fprintf(COM2,"\r\n");      
2AD6:  MOVLW  0D
2AD8:  MOVLB  8
2ADA:  MOVWF  xE8
2ADC:  MOVLB  0
2ADE:  CALL   045C
2AE2:  MOVLW  0A
2AE4:  MOVLB  8
2AE6:  MOVWF  xE8
2AE8:  MOVLB  0
2AEA:  CALL   045C
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2AEE:  MOVLW  F8
2AF0:  MOVWF  FF6
2AF2:  MOVLW  02
2AF4:  MOVWF  FF7
2AF6:  MOVLW  07
2AF8:  MOVLB  8
2AFA:  MOVWF  xDC
2AFC:  MOVLB  0
2AFE:  CALL   141A
2B02:  MOVLW  41
2B04:  MOVWF  FE9
2B06:  MOVFF  8C7,8DF
2B0A:  MOVFF  8C6,8DE
2B0E:  MOVFF  8C5,8DD
2B12:  MOVFF  8C4,8DC
2B16:  CALL   21C6
2B1A:  MOVLW  0D
2B1C:  MOVLB  8
2B1E:  MOVWF  xE8
2B20:  MOVLB  0
2B22:  CALL   045C
2B26:  MOVLW  0A
2B28:  MOVLB  8
2B2A:  MOVWF  xE8
2B2C:  MOVLB  0
2B2E:  CALL   045C
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2B32:  MOVLW  06
2B34:  MOVWF  FF6
2B36:  MOVLW  03
2B38:  MOVWF  FF7
2B3A:  MOVLW  07
2B3C:  MOVLB  8
2B3E:  MOVWF  xDC
2B40:  MOVLB  0
2B42:  CALL   141A
2B46:  MOVLW  41
2B48:  MOVWF  FE9
2B4A:  MOVFF  8CB,8DF
2B4E:  MOVFF  8CA,8DE
2B52:  MOVFF  8C9,8DD
2B56:  MOVFF  8C8,8DC
2B5A:  CALL   21C6
2B5E:  MOVLW  0D
2B60:  MOVLB  8
2B62:  MOVWF  xE8
2B64:  MOVLB  0
2B66:  CALL   045C
2B6A:  MOVLW  0A
2B6C:  MOVLB  8
2B6E:  MOVWF  xE8
2B70:  MOVLB  0
2B72:  CALL   045C
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2B76:  MOVLW  14
2B78:  MOVWF  FF6
2B7A:  MOVLW  03
2B7C:  MOVWF  FF7
2B7E:  MOVLW  07
2B80:  MOVLB  8
2B82:  MOVWF  xDC
2B84:  MOVLB  0
2B86:  CALL   141A
2B8A:  MOVLW  41
2B8C:  MOVWF  FE9
2B8E:  MOVFF  8CF,8DF
2B92:  MOVFF  8CE,8DE
2B96:  MOVFF  8CD,8DD
2B9A:  MOVFF  8CC,8DC
2B9E:  CALL   21C6
2BA2:  MOVLW  0D
2BA4:  MOVLB  8
2BA6:  MOVWF  xE8
2BA8:  MOVLB  0
2BAA:  CALL   045C
2BAE:  MOVLW  0A
2BB0:  MOVLB  8
2BB2:  MOVWF  xE8
2BB4:  MOVLB  0
2BB6:  CALL   045C
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2BBA:  MOVLW  22
2BBC:  MOVWF  FF6
2BBE:  MOVLW  03
2BC0:  MOVWF  FF7
2BC2:  MOVLW  07
2BC4:  MOVLB  8
2BC6:  MOVWF  xDC
2BC8:  MOVLB  0
2BCA:  CALL   141A
2BCE:  MOVLW  41
2BD0:  MOVWF  FE9
2BD2:  MOVFF  8D3,8DF
2BD6:  MOVFF  8D2,8DE
2BDA:  MOVFF  8D1,8DD
2BDE:  MOVFF  8D0,8DC
2BE2:  CALL   21C6
2BE6:  MOVLW  0D
2BE8:  MOVLB  8
2BEA:  MOVWF  xE8
2BEC:  MOVLB  0
2BEE:  CALL   045C
2BF2:  MOVLW  0A
2BF4:  MOVLB  8
2BF6:  MOVWF  xE8
2BF8:  MOVLB  0
2BFA:  CALL   045C
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2BFE:  MOVLW  30
2C00:  MOVWF  FF6
2C02:  MOVLW  03
2C04:  MOVWF  FF7
2C06:  MOVLW  07
2C08:  MOVLB  8
2C0A:  MOVWF  xDC
2C0C:  MOVLB  0
2C0E:  CALL   141A
2C12:  MOVLW  41
2C14:  MOVWF  FE9
2C16:  MOVFF  8D7,8DF
2C1A:  MOVFF  8D6,8DE
2C1E:  MOVFF  8D5,8DD
2C22:  MOVFF  8D4,8DC
2C26:  CALL   21C6
2C2A:  MOVLW  0D
2C2C:  MOVLB  8
2C2E:  MOVWF  xE8
2C30:  MOVLB  0
2C32:  CALL   045C
2C36:  MOVLW  0A
2C38:  MOVLB  8
2C3A:  MOVWF  xE8
2C3C:  MOVLB  0
2C3E:  CALL   045C
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2C42:  MOVLW  3E
2C44:  MOVWF  FF6
2C46:  MOVLW  03
2C48:  MOVWF  FF7
2C4A:  MOVLW  07
2C4C:  MOVLB  8
2C4E:  MOVWF  xDC
2C50:  MOVLB  0
2C52:  CALL   141A
2C56:  MOVLW  41
2C58:  MOVWF  FE9
2C5A:  MOVFF  8DB,8DF
2C5E:  MOVFF  8DA,8DE
2C62:  MOVFF  8D9,8DD
2C66:  MOVFF  8D8,8DC
2C6A:  CALL   21C6
2C6E:  MOVLW  0D
2C70:  MOVLB  8
2C72:  MOVWF  xE8
2C74:  MOVLB  0
2C76:  CALL   045C
2C7A:  MOVLW  0A
2C7C:  MOVLB  8
2C7E:  MOVWF  xE8
2C80:  MOVLB  0
2C82:  CALL   045C
....................       fprintf(COM2,"\r\n"); 
2C86:  MOVLW  0D
2C88:  MOVLB  8
2C8A:  MOVWF  xE8
2C8C:  MOVLB  0
2C8E:  CALL   045C
2C92:  MOVLW  0A
2C94:  MOVLB  8
2C96:  MOVWF  xE8
2C98:  MOVLB  0
2C9A:  CALL   045C
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2C9E:  MOVLB  8
2CA0:  MOVF   xC7,F
2CA2:  BNZ   2CB2
2CA4:  MOVF   xC6,F
2CA6:  BNZ   2CB2
2CA8:  MOVF   xC5,F
2CAA:  BNZ   2CB2
2CAC:  MOVF   xC4,W
2CAE:  SUBLW  05
2CB0:  BC    2D24
2CB2:  MOVF   xC7,F
2CB4:  BNZ   2D24
2CB6:  MOVF   xC6,F
2CB8:  BNZ   2D24
2CBA:  MOVF   xC5,F
2CBC:  BNZ   2D24
2CBE:  MOVF   xC4,W
2CC0:  SUBLW  3B
2CC2:  BNC   2D24
2CC4:  MOVF   xCB,F
2CC6:  BNZ   2CD6
2CC8:  MOVF   xCA,F
2CCA:  BNZ   2CD6
2CCC:  MOVF   xC9,F
2CCE:  BNZ   2CD6
2CD0:  MOVF   xC8,W
2CD2:  SUBLW  64
2CD4:  BC    2D24
2CD6:  MOVF   xCF,F
2CD8:  BNZ   2CE8
2CDA:  MOVF   xCE,F
2CDC:  BNZ   2CE8
2CDE:  MOVF   xCD,F
2CE0:  BNZ   2CE8
2CE2:  MOVF   xCC,W
2CE4:  SUBLW  64
2CE6:  BC    2D24
2CE8:  MOVF   xD3,F
2CEA:  BNZ   2CFA
2CEC:  MOVF   xD2,F
2CEE:  BNZ   2CFA
2CF0:  MOVF   xD1,F
2CF2:  BNZ   2CFA
2CF4:  MOVF   xD0,W
2CF6:  SUBLW  64
2CF8:  BC    2D24
2CFA:  MOVF   xD7,F
2CFC:  BNZ   2D0C
2CFE:  MOVF   xD6,F
2D00:  BNZ   2D0C
2D02:  MOVF   xD5,F
2D04:  BNZ   2D0C
2D06:  MOVF   xD4,W
2D08:  SUBLW  64
2D0A:  BC    2D24
2D0C:  MOVF   xDB,F
2D0E:  BNZ   2D1E
2D10:  MOVF   xDA,F
2D12:  BNZ   2D1E
2D14:  MOVF   xD9,F
2D16:  BNZ   2D1E
2D18:  MOVF   xD8,W
2D1A:  SUBLW  64
2D1C:  BC    2D24
2D1E:  MOVLW  00
2D20:  MOVWF  01
2D22:  BRA    309C
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2D24:  MOVF   xCB,F
2D26:  BNZ   2D36
2D28:  MOVF   xCA,F
2D2A:  BNZ   2D36
2D2C:  MOVF   xC9,F
2D2E:  BNZ   2D36
2D30:  MOVF   xC8,W
2D32:  SUBLW  05
2D34:  BC    2DA8
2D36:  MOVF   xCB,F
2D38:  BNZ   2DA8
2D3A:  MOVF   xCA,F
2D3C:  BNZ   2DA8
2D3E:  MOVF   xC9,F
2D40:  BNZ   2DA8
2D42:  MOVF   xC8,W
2D44:  SUBLW  3B
2D46:  BNC   2DA8
2D48:  MOVF   xC7,F
2D4A:  BNZ   2D5A
2D4C:  MOVF   xC6,F
2D4E:  BNZ   2D5A
2D50:  MOVF   xC5,F
2D52:  BNZ   2D5A
2D54:  MOVF   xC4,W
2D56:  SUBLW  64
2D58:  BC    2DA8
2D5A:  MOVF   xCF,F
2D5C:  BNZ   2D6C
2D5E:  MOVF   xCE,F
2D60:  BNZ   2D6C
2D62:  MOVF   xCD,F
2D64:  BNZ   2D6C
2D66:  MOVF   xCC,W
2D68:  SUBLW  64
2D6A:  BC    2DA8
2D6C:  MOVF   xD3,F
2D6E:  BNZ   2D7E
2D70:  MOVF   xD2,F
2D72:  BNZ   2D7E
2D74:  MOVF   xD1,F
2D76:  BNZ   2D7E
2D78:  MOVF   xD0,W
2D7A:  SUBLW  64
2D7C:  BC    2DA8
2D7E:  MOVF   xD7,F
2D80:  BNZ   2D90
2D82:  MOVF   xD6,F
2D84:  BNZ   2D90
2D86:  MOVF   xD5,F
2D88:  BNZ   2D90
2D8A:  MOVF   xD4,W
2D8C:  SUBLW  64
2D8E:  BC    2DA8
2D90:  MOVF   xDB,F
2D92:  BNZ   2DA2
2D94:  MOVF   xDA,F
2D96:  BNZ   2DA2
2D98:  MOVF   xD9,F
2D9A:  BNZ   2DA2
2D9C:  MOVF   xD8,W
2D9E:  SUBLW  64
2DA0:  BC    2DA8
2DA2:  MOVLW  01
2DA4:  MOVWF  01
2DA6:  BRA    309C
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2DA8:  MOVF   xCF,F
2DAA:  BNZ   2DBA
2DAC:  MOVF   xCE,F
2DAE:  BNZ   2DBA
2DB0:  MOVF   xCD,F
2DB2:  BNZ   2DBA
2DB4:  MOVF   xCC,W
2DB6:  SUBLW  05
2DB8:  BC    2E2C
2DBA:  MOVF   xCF,F
2DBC:  BNZ   2E2C
2DBE:  MOVF   xCE,F
2DC0:  BNZ   2E2C
2DC2:  MOVF   xCD,F
2DC4:  BNZ   2E2C
2DC6:  MOVF   xCC,W
2DC8:  SUBLW  3B
2DCA:  BNC   2E2C
2DCC:  MOVF   xCB,F
2DCE:  BNZ   2DDE
2DD0:  MOVF   xCA,F
2DD2:  BNZ   2DDE
2DD4:  MOVF   xC9,F
2DD6:  BNZ   2DDE
2DD8:  MOVF   xC8,W
2DDA:  SUBLW  64
2DDC:  BC    2E2C
2DDE:  MOVF   xC7,F
2DE0:  BNZ   2DF0
2DE2:  MOVF   xC6,F
2DE4:  BNZ   2DF0
2DE6:  MOVF   xC5,F
2DE8:  BNZ   2DF0
2DEA:  MOVF   xC4,W
2DEC:  SUBLW  64
2DEE:  BC    2E2C
2DF0:  MOVF   xD3,F
2DF2:  BNZ   2E02
2DF4:  MOVF   xD2,F
2DF6:  BNZ   2E02
2DF8:  MOVF   xD1,F
2DFA:  BNZ   2E02
2DFC:  MOVF   xD0,W
2DFE:  SUBLW  64
2E00:  BC    2E2C
2E02:  MOVF   xD7,F
2E04:  BNZ   2E14
2E06:  MOVF   xD6,F
2E08:  BNZ   2E14
2E0A:  MOVF   xD5,F
2E0C:  BNZ   2E14
2E0E:  MOVF   xD4,W
2E10:  SUBLW  64
2E12:  BC    2E2C
2E14:  MOVF   xDB,F
2E16:  BNZ   2E26
2E18:  MOVF   xDA,F
2E1A:  BNZ   2E26
2E1C:  MOVF   xD9,F
2E1E:  BNZ   2E26
2E20:  MOVF   xD8,W
2E22:  SUBLW  64
2E24:  BC    2E2C
2E26:  MOVLW  02
2E28:  MOVWF  01
2E2A:  BRA    309C
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2E2C:  MOVF   xD3,F
2E2E:  BNZ   2E3E
2E30:  MOVF   xD2,F
2E32:  BNZ   2E3E
2E34:  MOVF   xD1,F
2E36:  BNZ   2E3E
2E38:  MOVF   xD0,W
2E3A:  SUBLW  05
2E3C:  BC    2EB0
2E3E:  MOVF   xD3,F
2E40:  BNZ   2EB0
2E42:  MOVF   xD2,F
2E44:  BNZ   2EB0
2E46:  MOVF   xD1,F
2E48:  BNZ   2EB0
2E4A:  MOVF   xD0,W
2E4C:  SUBLW  3B
2E4E:  BNC   2EB0
2E50:  MOVF   xCB,F
2E52:  BNZ   2E62
2E54:  MOVF   xCA,F
2E56:  BNZ   2E62
2E58:  MOVF   xC9,F
2E5A:  BNZ   2E62
2E5C:  MOVF   xC8,W
2E5E:  SUBLW  64
2E60:  BC    2EB0
2E62:  MOVF   xCF,F
2E64:  BNZ   2E74
2E66:  MOVF   xCE,F
2E68:  BNZ   2E74
2E6A:  MOVF   xCD,F
2E6C:  BNZ   2E74
2E6E:  MOVF   xCC,W
2E70:  SUBLW  64
2E72:  BC    2EB0
2E74:  MOVF   xC7,F
2E76:  BNZ   2E86
2E78:  MOVF   xC6,F
2E7A:  BNZ   2E86
2E7C:  MOVF   xC5,F
2E7E:  BNZ   2E86
2E80:  MOVF   xC4,W
2E82:  SUBLW  64
2E84:  BC    2EB0
2E86:  MOVF   xD7,F
2E88:  BNZ   2E98
2E8A:  MOVF   xD6,F
2E8C:  BNZ   2E98
2E8E:  MOVF   xD5,F
2E90:  BNZ   2E98
2E92:  MOVF   xD4,W
2E94:  SUBLW  64
2E96:  BC    2EB0
2E98:  MOVF   xDB,F
2E9A:  BNZ   2EAA
2E9C:  MOVF   xDA,F
2E9E:  BNZ   2EAA
2EA0:  MOVF   xD9,F
2EA2:  BNZ   2EAA
2EA4:  MOVF   xD8,W
2EA6:  SUBLW  64
2EA8:  BC    2EB0
2EAA:  MOVLW  03
2EAC:  MOVWF  01
2EAE:  BRA    309C
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
2EB0:  MOVF   xD7,F
2EB2:  BNZ   2EC2
2EB4:  MOVF   xD6,F
2EB6:  BNZ   2EC2
2EB8:  MOVF   xD5,F
2EBA:  BNZ   2EC2
2EBC:  MOVF   xD4,W
2EBE:  SUBLW  05
2EC0:  BC    2F34
2EC2:  MOVF   xD7,F
2EC4:  BNZ   2F34
2EC6:  MOVF   xD6,F
2EC8:  BNZ   2F34
2ECA:  MOVF   xD5,F
2ECC:  BNZ   2F34
2ECE:  MOVF   xD4,W
2ED0:  SUBLW  3B
2ED2:  BNC   2F34
2ED4:  MOVF   xCB,F
2ED6:  BNZ   2EE6
2ED8:  MOVF   xCA,F
2EDA:  BNZ   2EE6
2EDC:  MOVF   xC9,F
2EDE:  BNZ   2EE6
2EE0:  MOVF   xC8,W
2EE2:  SUBLW  64
2EE4:  BC    2F34
2EE6:  MOVF   xCF,F
2EE8:  BNZ   2EF8
2EEA:  MOVF   xCE,F
2EEC:  BNZ   2EF8
2EEE:  MOVF   xCD,F
2EF0:  BNZ   2EF8
2EF2:  MOVF   xCC,W
2EF4:  SUBLW  64
2EF6:  BC    2F34
2EF8:  MOVF   xD3,F
2EFA:  BNZ   2F0A
2EFC:  MOVF   xD2,F
2EFE:  BNZ   2F0A
2F00:  MOVF   xD1,F
2F02:  BNZ   2F0A
2F04:  MOVF   xD0,W
2F06:  SUBLW  64
2F08:  BC    2F34
2F0A:  MOVF   xC7,F
2F0C:  BNZ   2F1C
2F0E:  MOVF   xC6,F
2F10:  BNZ   2F1C
2F12:  MOVF   xC5,F
2F14:  BNZ   2F1C
2F16:  MOVF   xC4,W
2F18:  SUBLW  64
2F1A:  BC    2F34
2F1C:  MOVF   xDB,F
2F1E:  BNZ   2F2E
2F20:  MOVF   xDA,F
2F22:  BNZ   2F2E
2F24:  MOVF   xD9,F
2F26:  BNZ   2F2E
2F28:  MOVF   xD8,W
2F2A:  SUBLW  64
2F2C:  BC    2F34
2F2E:  MOVLW  04
2F30:  MOVWF  01
2F32:  BRA    309C
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
2F34:  MOVF   xDB,F
2F36:  BNZ   2F46
2F38:  MOVF   xDA,F
2F3A:  BNZ   2F46
2F3C:  MOVF   xD9,F
2F3E:  BNZ   2F46
2F40:  MOVF   xD8,W
2F42:  SUBLW  05
2F44:  BC    2FB8
2F46:  MOVF   xDB,F
2F48:  BNZ   2FB8
2F4A:  MOVF   xDA,F
2F4C:  BNZ   2FB8
2F4E:  MOVF   xD9,F
2F50:  BNZ   2FB8
2F52:  MOVF   xD8,W
2F54:  SUBLW  3B
2F56:  BNC   2FB8
2F58:  MOVF   xCB,F
2F5A:  BNZ   2F6A
2F5C:  MOVF   xCA,F
2F5E:  BNZ   2F6A
2F60:  MOVF   xC9,F
2F62:  BNZ   2F6A
2F64:  MOVF   xC8,W
2F66:  SUBLW  64
2F68:  BC    2FB8
2F6A:  MOVF   xCF,F
2F6C:  BNZ   2F7C
2F6E:  MOVF   xCE,F
2F70:  BNZ   2F7C
2F72:  MOVF   xCD,F
2F74:  BNZ   2F7C
2F76:  MOVF   xCC,W
2F78:  SUBLW  64
2F7A:  BC    2FB8
2F7C:  MOVF   xD3,F
2F7E:  BNZ   2F8E
2F80:  MOVF   xD2,F
2F82:  BNZ   2F8E
2F84:  MOVF   xD1,F
2F86:  BNZ   2F8E
2F88:  MOVF   xD0,W
2F8A:  SUBLW  64
2F8C:  BC    2FB8
2F8E:  MOVF   xD7,F
2F90:  BNZ   2FA0
2F92:  MOVF   xD6,F
2F94:  BNZ   2FA0
2F96:  MOVF   xD5,F
2F98:  BNZ   2FA0
2F9A:  MOVF   xD4,W
2F9C:  SUBLW  64
2F9E:  BC    2FB8
2FA0:  MOVF   xC7,F
2FA2:  BNZ   2FB2
2FA4:  MOVF   xC6,F
2FA6:  BNZ   2FB2
2FA8:  MOVF   xC5,F
2FAA:  BNZ   2FB2
2FAC:  MOVF   xC4,W
2FAE:  SUBLW  64
2FB0:  BC    2FB8
2FB2:  MOVLW  05
2FB4:  MOVWF  01
2FB6:  BRA    309C
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
2FB8:  MOVF   xDB,F
2FBA:  BNZ   2FCC
2FBC:  MOVF   xDA,F
2FBE:  BNZ   2FCC
2FC0:  MOVF   xD9,F
2FC2:  BNZ   2FCC
2FC4:  MOVF   xD8,W
2FC6:  SUBLW  C8
2FC8:  BTFSC  FD8.0
2FCA:  BRA    3098
2FCC:  MOVF   xC7,F
2FCE:  BTFSS  FD8.2
2FD0:  BRA    3098
2FD2:  MOVF   xC6,F
2FD4:  BTFSS  FD8.2
2FD6:  BRA    3098
2FD8:  MOVF   xC5,F
2FDA:  BTFSS  FD8.2
2FDC:  BRA    3098
2FDE:  MOVF   xC4,W
2FE0:  SUBLW  B3
2FE2:  BTFSS  FD8.0
2FE4:  BRA    3098
2FE6:  MOVF   xC7,F
2FE8:  BNZ   2FFA
2FEA:  MOVF   xC6,F
2FEC:  BNZ   2FFA
2FEE:  MOVF   xC5,F
2FF0:  BNZ   2FFA
2FF2:  MOVF   xC4,W
2FF4:  SUBLW  64
2FF6:  BTFSC  FD8.0
2FF8:  BRA    3098
2FFA:  MOVF   xCB,F
2FFC:  BTFSS  FD8.2
2FFE:  BRA    3098
3000:  MOVF   xCA,F
3002:  BTFSS  FD8.2
3004:  BRA    3098
3006:  MOVF   xC9,F
3008:  BTFSS  FD8.2
300A:  BRA    3098
300C:  MOVF   xC8,W
300E:  SUBLW  B3
3010:  BNC   3098
3012:  MOVF   xCB,F
3014:  BNZ   3024
3016:  MOVF   xCA,F
3018:  BNZ   3024
301A:  MOVF   xC9,F
301C:  BNZ   3024
301E:  MOVF   xC8,W
3020:  SUBLW  64
3022:  BC    3098
3024:  MOVF   xCF,F
3026:  BNZ   3098
3028:  MOVF   xCE,F
302A:  BNZ   3098
302C:  MOVF   xCD,F
302E:  BNZ   3098
3030:  MOVF   xCC,W
3032:  SUBLW  B3
3034:  BNC   3098
3036:  MOVF   xCF,F
3038:  BNZ   3048
303A:  MOVF   xCE,F
303C:  BNZ   3048
303E:  MOVF   xCD,F
3040:  BNZ   3048
3042:  MOVF   xCC,W
3044:  SUBLW  64
3046:  BC    3098
3048:  MOVF   xD3,F
304A:  BNZ   3098
304C:  MOVF   xD2,F
304E:  BNZ   3098
3050:  MOVF   xD1,F
3052:  BNZ   3098
3054:  MOVF   xD0,W
3056:  SUBLW  B3
3058:  BNC   3098
305A:  MOVF   xD3,F
305C:  BNZ   306C
305E:  MOVF   xD2,F
3060:  BNZ   306C
3062:  MOVF   xD1,F
3064:  BNZ   306C
3066:  MOVF   xD0,W
3068:  SUBLW  64
306A:  BC    3098
306C:  MOVF   xD7,F
306E:  BNZ   3098
3070:  MOVF   xD6,F
3072:  BNZ   3098
3074:  MOVF   xD5,F
3076:  BNZ   3098
3078:  MOVF   xD4,W
307A:  SUBLW  B3
307C:  BNC   3098
307E:  MOVF   xD7,F
3080:  BNZ   3090
3082:  MOVF   xD6,F
3084:  BNZ   3090
3086:  MOVF   xD5,F
3088:  BNZ   3090
308A:  MOVF   xD4,W
308C:  SUBLW  64
308E:  BC    3098
3090:  MOVLW  05
3092:  MOVWF  01
3094:  BRA    309C
....................    else return 0xff; 
3096:  BRA    309C
3098:  MOVLW  FF
309A:  MOVWF  01
.................... } 
309C:  MOVLB  0
309E:  GOTO   3104 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
30A2:  MOVLW  20
30A4:  MOVLB  8
30A6:  MOVWF  xC0
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
30A8:  BSF    F93.4
30AA:  BTFSS  F81.4
30AC:  BRA    30C0
30AE:  BSF    F93.5
30B0:  BTFSS  F81.5
30B2:  BRA    30C0
30B4:  BSF    F93.6
30B6:  BTFSS  F81.6
30B8:  BRA    30C0
30BA:  BSF    F93.7
30BC:  BTFSC  F81.7
30BE:  BRA    322A
....................     { 
....................        if(input(ROW0)==0) 
30C0:  BSF    F93.4
30C2:  BTFSC  F81.4
30C4:  BRA    30CA
....................          row=0; 
30C6:  CLRF   xC1
....................        else if(input(ROW1)==0) 
30C8:  BRA    30EC
30CA:  BSF    F93.5
30CC:  BTFSC  F81.5
30CE:  BRA    30D6
....................          row=1; 
30D0:  MOVLW  01
30D2:  MOVWF  xC1
....................        else if(input(ROW2)==0) 
30D4:  BRA    30EC
30D6:  BSF    F93.6
30D8:  BTFSC  F81.6
30DA:  BRA    30E2
....................          row=2; 
30DC:  MOVLW  02
30DE:  MOVWF  xC1
....................        else if(input(ROW3)==0) 
30E0:  BRA    30EC
30E2:  BSF    F93.7
30E4:  BTFSC  F81.7
30E6:  BRA    30EC
....................          row=3;      
30E8:  MOVLW  03
30EA:  MOVWF  xC1
....................        if(type_KB==0)col=check_col(); 
30EC:  MOVLB  1
30EE:  MOVF   x34,F
30F0:  BNZ   30FE
30F2:  MOVLB  0
30F4:  GOTO   2286
30F8:  MOVFF  01,8BF
....................          else col=new_check_col(); 
30FC:  BRA    3108
30FE:  MOVLB  0
3100:  GOTO   28B2
3104:  MOVFF  01,8BF
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
3108:  MOVLB  8
310A:  INCFSZ xBF,W
310C:  BRA    3110
310E:  BRA    31FA
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
3110:  MOVLB  1
3112:  MOVF   x34,F
3114:  BNZ   313C
3116:  MOVLB  8
3118:  MOVF   xC1,W
311A:  MULLW  05
311C:  MOVF   FF3,W
311E:  CLRF   xC3
3120:  MOVWF  xC2
3122:  CLRF   03
3124:  MOVF   xBF,W
3126:  ADDWF  xC2,W
3128:  MOVWF  01
312A:  MOVF   xC3,W
312C:  ADDWFC 03,F
312E:  MOVF   01,W
3130:  MOVLB  0
3132:  CALL   00D0
3136:  MOVFF  FE8,8C0
....................            else kchar =newKEYS[row][col]; 
313A:  BRA    3160
313C:  MOVLB  8
313E:  MOVF   xC1,W
3140:  MULLW  06
3142:  MOVF   FF3,W
3144:  CLRF   xC3
3146:  MOVWF  xC2
3148:  CLRF   03
314A:  MOVF   xBF,W
314C:  ADDWF  xC2,W
314E:  MOVWF  01
3150:  MOVF   xC3,W
3152:  ADDWFC 03,F
3154:  MOVF   01,W
3156:  MOVLB  0
3158:  CALL   00F4
315C:  MOVFF  FE8,8C0
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
3160:  MOVLB  1
3162:  MOVF   x2C,F
3164:  BNZ   31EC
....................             { 
....................               charac_timeout=0; 
3166:  MOVLB  0
3168:  CLRF   xFC
316A:  CLRF   xFB
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
316C:  MOVLB  1
316E:  MOVF   x2F,W
3170:  SUBLW  0B
3172:  BNC   3188
3174:  MOVF   x2F,W
3176:  INCF   x2F,F
3178:  CLRF   03
317A:  ADDLW  35
317C:  MOVWF  FE9
317E:  MOVLW  01
3180:  ADDWFC 03,W
3182:  MOVWF  FEA
3184:  MOVFF  8C0,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
3188:  MOVLW  4C
318A:  MOVWF  FF6
318C:  MOVLW  03
318E:  MOVWF  FF7
3190:  MOVLW  09
3192:  MOVLB  8
3194:  MOVWF  xDC
3196:  MOVLB  0
3198:  CALL   141A
319C:  MOVFF  12F,8C8
31A0:  MOVLW  18
31A2:  MOVLB  8
31A4:  MOVWF  xC9
31A6:  MOVLB  0
31A8:  CALL   152E
31AC:  MOVLW  5D
31AE:  MOVLB  8
31B0:  MOVWF  xE8
31B2:  MOVLB  0
31B4:  CALL   045C
31B8:  MOVLW  20
31BA:  MOVLB  8
31BC:  MOVWF  xE8
31BE:  MOVLB  0
31C0:  CALL   045C
31C4:  MOVFF  8C0,8E8
31C8:  CALL   045C
31CC:  MOVLW  0D
31CE:  MOVLB  8
31D0:  MOVWF  xE8
31D2:  MOVLB  0
31D4:  CALL   045C
31D8:  MOVLW  0A
31DA:  MOVLB  8
31DC:  MOVWF  xE8
31DE:  MOVLB  0
31E0:  CALL   045C
....................                count_checking=0; 
31E4:  MOVLB  1
31E6:  CLRF   x07
31E8:  CLRF   x06
....................             } 
....................                else fputc(kchar,COM2); 
31EA:  BRA    31F8
31EC:  MOVFF  8C0,8E8
31F0:  MOVLB  0
31F2:  CALL   045C
31F6:  MOVLB  1
31F8:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
31FA:  BSF    F93.4
31FC:  BTFSS  F81.4
31FE:  BRA    31FA
3200:  BSF    F93.5
3202:  BTFSS  F81.5
3204:  BRA    31FA
3206:  BSF    F93.6
3208:  BTFSS  F81.6
320A:  BRA    31FA
320C:  BSF    F93.7
320E:  BTFSS  F81.7
3210:  BRA    31FA
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3212:  BSF    F93.4
3214:  BTFSS  F81.4
3216:  BRA    3212
3218:  BSF    F93.5
321A:  BTFSS  F81.5
321C:  BRA    3212
321E:  BSF    F93.6
3220:  BTFSS  F81.6
3222:  BRA    3212
3224:  BSF    F93.7
3226:  BTFSS  F81.7
3228:  BRA    3212
....................     } 
....................   set_tris_a(0xff);     
322A:  MOVLW  FF
322C:  MOVWF  F92
....................   return(kchar); 
322E:  MOVFF  8C0,01
.................... }//*/ 
3232:  MOVLB  0
3234:  RETURN 0
.................... //============================================ 
.................... //=========================================================== 
.................... #if 0 
.................... void write_kb_i2ceeprom(void) 
.................... { 
....................       unsigned long adr; 
....................       unsigned int i; 
....................       unsigned int crc; 
....................       char rec[34]; 
....................       char retval; 
....................  
....................       RTC_get_time();                                 /* Lecture de l'heure actuelle */ 
....................  
....................       rec[0]=33;                                    /* Prochaine chaine dans 33 cars. */ 
....................       rec[1]=32;                                    /* Nombre de bytes de la chaine */ 
....................       rec[2]=(unsigned char)((heure_actuelle.annee)-2000);   /* Anne en byte */ 
....................       rec[3]=heure_actuelle.mois;                        /* Mois en byte */ 
....................       rec[4]=heure_actuelle.jour;                        /* Jour en byte */ 
....................       rec[5]=heure_actuelle.heure;                     /* Heure en byte */ 
....................       rec[6]=heure_actuelle.minute;                     /* Minute en byte */ 
....................       rec[7]=heure_actuelle.seconde;                     /* Seconde en byte */ 
....................  
....................       rec[8]=0x01;                                 /* Type Clavier */ 
....................  
....................       for(i=0;i<KB_char_cnt && i<12;i++)   /* Copie du nombre de byte dans le tampon de clavier */ 
....................          rec[9+i]=KB_buf[i]; 
....................  
....................       i=i+9;                  /* Ajout des 8 bytes pour l'entte + 1 byte pour le pointeur  */ 
....................     
....................       while(i<33)               /* Mettre des 0 comme "padding" */ 
....................       { 
....................          rec[i]=0x00; 
....................          i++; 
....................       } 
....................  
....................       crc=crcccitt(0, &rec[1], 30);   /* Calcul du CRC 16 (CCITT) de la chaine */ 
....................  
....................       rec[31]=(unsigned char)(crc & 0x00FF); 
....................       rec[32]=(unsigned char)((crc & 0xFF00)>>8); 
....................  
....................       rec[33]=0xFF;            /* Terminaison de la liste par 0xFF */ 
....................  
....................       /** Encryption de la chaine */ 
....................       rijndael('c', (unsigned char *)&rec[1], (unsigned char *)&crypto_key[0]); 
....................       rijndael('c', (unsigned char *)&rec[17], (unsigned char *)&crypto_key[16]); 
....................  
....................       read_eeptr(&adr);         /* Lecture de l'adresse de fin de liste */ 
....................  
....................       retval=I2CEEPROM_write(adr,34,rec);   /* criture de la chaine */ 
....................  
....................       if(retval!=0) 
....................          write_eeptr(adr+33);         /* Ajuster le pointeur d'ajout de chaine dans la liste  */ 
....................  
.................... } 
.................... #endif 
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 rec[16]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
626A:  MOVF   27,F
626C:  BTFSS  FD8.2
626E:  BRA    6600
6270:  MOVF   26,W
6272:  SUBLW  01
6274:  BTFSS  FD8.0
6276:  BRA    6600
6278:  BNZ   628C
627A:  MOVF   25,W
627C:  SUBLW  FF
627E:  BTFSS  FD8.0
6280:  BRA    6600
6282:  BNZ   628C
6284:  MOVF   24,W
6286:  SUBLW  FE
6288:  BTFSS  FD8.0
628A:  BRA    6600
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
628C:  MOVLB  1
628E:  MOVF   x35,F
6290:  BNZ   6298
6292:  MOVF   x2F,F
6294:  BTFSC  FD8.2
6296:  BRA    6566
....................       {    
....................          for(i=0;i<key_numbyte;i++) 
6298:  MOVLB  7
629A:  CLRF   xA1
629C:  MOVF   xA1,W
629E:  SUBLW  0B
62A0:  BNC   6300
....................          { 
....................             temp=key_data[i]; 
62A2:  CLRF   03
62A4:  MOVF   xA1,W
62A6:  ADDLW  35
62A8:  MOVWF  FE9
62AA:  MOVLW  01
62AC:  ADDWFC 03,W
62AE:  MOVWF  FEA
62B0:  CLRF   xA3
62B2:  MOVFF  FEF,7A2
62B6:  CLRF   19
62B8:  BTFSC  FF2.7
62BA:  BSF    19.7
62BC:  BCF    FF2.7
....................             fputc(temp,COM2); 
62BE:  MOVFF  7A2,8E8
62C2:  MOVLB  0
62C4:  CALL   045C
62C8:  BTFSC  19.7
62CA:  BSF    FF2.7
....................             rec[i]=key_data[i]; 
62CC:  CLRF   03
62CE:  MOVLB  7
62D0:  MOVF   xA1,W
62D2:  ADDLW  A5
62D4:  MOVWF  01
62D6:  MOVLW  07
62D8:  ADDWFC 03,F
62DA:  MOVFF  03,7B6
62DE:  CLRF   03
62E0:  MOVF   xA1,W
62E2:  ADDLW  35
62E4:  MOVWF  FE9
62E6:  MOVLW  01
62E8:  ADDWFC 03,W
62EA:  MOVWF  FEA
62EC:  MOVFF  FEF,7B7
62F0:  MOVFF  7B6,FEA
62F4:  MOVFF  01,FE9
62F8:  MOVFF  7B7,FEF
....................          } 
62FC:  INCF   xA1,F
62FE:  BRA    629C
....................          rec[key_numbyte] = 0; 
6300:  CLRF   xB1
....................          rec[key_numbyte+1] = 0;          
6302:  CLRF   xB2
....................          rec[key_numbyte+2] = 0;          
6304:  CLRF   xB3
....................          rec[key_numbyte+3] = 0; 
6306:  CLRF   xB4
6308:  CLRF   19
630A:  BTFSC  FF2.7
630C:  BSF    19.7
630E:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
6310:  MOVLW  0A
6312:  MOVLB  8
6314:  MOVWF  xE8
6316:  MOVLB  0
6318:  CALL   045C
631C:  BTFSC  19.7
631E:  BSF    FF2.7
6320:  CLRF   19
6322:  BTFSC  FF2.7
6324:  BSF    19.7
6326:  BCF    FF2.7
6328:  MOVLW  0D
632A:  MOVLB  8
632C:  MOVWF  xE8
632E:  MOVLB  0
6330:  CALL   045C
6334:  BTFSC  19.7
6336:  BSF    FF2.7
....................          for(i=0;i<10;i++) fprintf(COM2," %c",crypto_key[i]); 
6338:  MOVLB  7
633A:  CLRF   xA1
633C:  MOVF   xA1,W
633E:  SUBLW  09
6340:  BNC   6386
6342:  CLRF   03
6344:  MOVF   xA1,W
6346:  ADDLW  08
6348:  MOVWF  FE9
634A:  MOVLW  01
634C:  ADDWFC 03,W
634E:  MOVWF  FEA
6350:  MOVFF  FEF,7B5
6354:  CLRF   19
6356:  BTFSC  FF2.7
6358:  BSF    19.7
635A:  BCF    FF2.7
635C:  MOVLW  20
635E:  MOVLB  8
6360:  MOVWF  xE8
6362:  MOVLB  0
6364:  CALL   045C
6368:  BTFSC  19.7
636A:  BSF    FF2.7
636C:  CLRF   19
636E:  BTFSC  FF2.7
6370:  BSF    19.7
6372:  BCF    FF2.7
6374:  MOVFF  7B5,8E8
6378:  CALL   045C
637C:  BTFSC  19.7
637E:  BSF    FF2.7
6380:  MOVLB  7
6382:  INCF   xA1,F
6384:  BRA    633C
6386:  CLRF   19
6388:  BTFSC  FF2.7
638A:  BSF    19.7
638C:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
638E:  MOVLW  0A
6390:  MOVLB  8
6392:  MOVWF  xE8
6394:  MOVLB  0
6396:  CALL   045C
639A:  BTFSC  19.7
639C:  BSF    FF2.7
639E:  CLRF   19
63A0:  BTFSC  FF2.7
63A2:  BSF    19.7
63A4:  BCF    FF2.7
63A6:  MOVLW  0D
63A8:  MOVLB  8
63AA:  MOVWF  xE8
63AC:  MOVLB  0
63AE:  CALL   045C
63B2:  BTFSC  19.7
63B4:  BSF    FF2.7
....................          for(i=0;i<16;i++) fprintf(COM2," %x",rec[i]); 
63B6:  MOVLB  7
63B8:  CLRF   xA1
63BA:  MOVF   xA1,W
63BC:  SUBLW  0F
63BE:  BNC   6400
63C0:  CLRF   03
63C2:  MOVF   xA1,W
63C4:  ADDLW  A5
63C6:  MOVWF  FE9
63C8:  MOVLW  07
63CA:  ADDWFC 03,W
63CC:  MOVWF  FEA
63CE:  MOVFF  FEF,7B5
63D2:  CLRF   19
63D4:  BTFSC  FF2.7
63D6:  BSF    19.7
63D8:  BCF    FF2.7
63DA:  MOVLW  20
63DC:  MOVLB  8
63DE:  MOVWF  xE8
63E0:  MOVLB  0
63E2:  CALL   045C
63E6:  BTFSC  19.7
63E8:  BSF    FF2.7
63EA:  MOVFF  7B5,7B6
63EE:  MOVLW  57
63F0:  MOVLB  7
63F2:  MOVWF  xB7
63F4:  MOVLB  0
63F6:  CALL   48E6
63FA:  MOVLB  7
63FC:  INCF   xA1,F
63FE:  BRA    63BA
6400:  CLRF   19
6402:  BTFSC  FF2.7
6404:  BSF    19.7
6406:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
6408:  MOVLW  0A
640A:  MOVLB  8
640C:  MOVWF  xE8
640E:  MOVLB  0
6410:  CALL   045C
6414:  BTFSC  19.7
6416:  BSF    FF2.7
6418:  CLRF   19
641A:  BTFSC  FF2.7
641C:  BSF    19.7
641E:  BCF    FF2.7
6420:  MOVLW  0D
6422:  MOVLB  8
6424:  MOVWF  xE8
6426:  MOVLB  0
6428:  CALL   045C
642C:  BTFSC  19.7
642E:  BSF    FF2.7
....................         
....................          rijndael('c', (unsigned char *)&rec[0], (unsigned char *)&crypto_key[0]); 
6430:  MOVLW  63
6432:  MOVLB  7
6434:  MOVWF  xB5
6436:  MOVLW  07
6438:  MOVWF  xB7
643A:  MOVLW  A5
643C:  MOVWF  xB6
643E:  MOVLW  01
6440:  MOVWF  xB9
6442:  MOVLW  08
6444:  MOVWF  xB8
6446:  MOVLB  0
6448:  RCALL  6100
644A:  CLRF   19
644C:  BTFSC  FF2.7
644E:  BSF    19.7
6450:  BCF    FF2.7
....................           
....................          /* get the pointer of keyboard data */ 
....................          temp=get_countcard(); 
6452:  CALL   33E2
6456:  BTFSC  19.7
6458:  BSF    FF2.7
645A:  MOVFF  02,7A3
645E:  MOVFF  01,7A2
....................          ptr_card_key=(int32)(((temp)*16)+EEPROM_KEY_ST); 
6462:  MOVLB  7
6464:  RLCF   xA2,W
6466:  MOVWF  xB5
6468:  RLCF   xA3,W
646A:  MOVWF  xB6
646C:  RLCF   xB5,F
646E:  RLCF   xB6,F
6470:  RLCF   xB5,F
6472:  RLCF   xB6,F
6474:  RLCF   xB5,F
6476:  RLCF   xB6,F
6478:  MOVLW  F0
647A:  ANDWF  xB5,F
647C:  MOVLW  0E
647E:  ADDWF  xB5,F
6480:  MOVLW  C3
6482:  ADDWFC xB6,F
6484:  MOVLW  01
6486:  MOVWF  xB7
6488:  BCF    FD8.2
648A:  BTFSC  FD8.0
648C:  INCF   xB7,F
648E:  CLRF   xB8
6490:  MOVLW  01
6492:  ADDWF  xB5,W
6494:  MOVWF  00
6496:  MOVLW  00
6498:  ADDWFC xB6,W
649A:  MOVWF  01
649C:  MOVLW  00
649E:  ADDWFC xB7,W
64A0:  MOVWF  02
64A2:  MOVLW  00
64A4:  ADDWFC xB8,W
64A6:  MOVWF  27
64A8:  MOVFF  02,26
64AC:  MOVFF  01,25
64B0:  MOVFF  00,24
....................           
....................          for(i=0;i<16;i++) fprintf(COM2," %x",rec[i]); 
64B4:  CLRF   xA1
64B6:  MOVF   xA1,W
64B8:  SUBLW  0F
64BA:  BNC   64FC
64BC:  CLRF   03
64BE:  MOVF   xA1,W
64C0:  ADDLW  A5
64C2:  MOVWF  FE9
64C4:  MOVLW  07
64C6:  ADDWFC 03,W
64C8:  MOVWF  FEA
64CA:  MOVFF  FEF,7B5
64CE:  CLRF   19
64D0:  BTFSC  FF2.7
64D2:  BSF    19.7
64D4:  BCF    FF2.7
64D6:  MOVLW  20
64D8:  MOVLB  8
64DA:  MOVWF  xE8
64DC:  MOVLB  0
64DE:  CALL   045C
64E2:  BTFSC  19.7
64E4:  BSF    FF2.7
64E6:  MOVFF  7B5,7B6
64EA:  MOVLW  57
64EC:  MOVLB  7
64EE:  MOVWF  xB7
64F0:  MOVLB  0
64F2:  CALL   48E6
64F6:  MOVLB  7
64F8:  INCF   xA1,F
64FA:  BRA    64B6
....................          retval = EEPROM_write(ptr_card_key,16,rec);   /* criture de la chaine */ 
64FC:  MOVFF  27,7EF
6500:  MOVFF  26,7EE
6504:  MOVFF  25,7ED
6508:  MOVFF  24,7EC
650C:  CLRF   xF3
650E:  CLRF   xF2
6510:  CLRF   xF1
6512:  MOVLW  10
6514:  MOVWF  xF0
6516:  MOVLW  07
6518:  MOVWF  xF5
651A:  MOVLW  A5
651C:  MOVWF  xF4
651E:  MOVLB  0
6520:  CALL   4458
6524:  MOVFF  01,7A4
....................          if(retval!=0) 
6528:  MOVLB  7
652A:  MOVF   xA4,F
652C:  BZ    6564
....................          { 
....................             ptr_card_key+=16; 
652E:  MOVLW  10
6530:  ADDWF  24,F
6532:  MOVLW  00
6534:  ADDWFC 25,F
6536:  ADDWFC 26,F
6538:  ADDWFC 27,F
653A:  CLRF   19
653C:  BTFSC  FF2.7
653E:  BSF    19.7
6540:  BCF    FF2.7
....................             save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
6542:  MOVFF  27,8C5
6546:  MOVFF  26,8C4
654A:  MOVFF  25,8C3
654E:  MOVFF  24,8C2
6552:  MOVLW  1E
6554:  MOVLB  8
6556:  MOVWF  xC6
6558:  MOVLB  0
655A:  CALL   3964
655E:  BTFSC  19.7
6560:  BSF    FF2.7
6562:  MOVLB  7
6564:  MOVLB  1
....................          }          
....................       } 
....................       key_count_ms=0; 
6566:  CLRF   x2F
6568:  CLRF   19
656A:  BTFSC  FF2.7
656C:  BSF    19.7
656E:  BCF    FF2.7
....................       del_buf(key_numbyte,key_data); 
6570:  MOVLW  0C
6572:  MOVLB  8
6574:  MOVWF  xCE
6576:  MOVLW  01
6578:  MOVWF  xD0
657A:  MOVLW  35
657C:  MOVWF  xCF
657E:  MOVLB  0
6580:  CALL   345C
6584:  BTFSC  19.7
6586:  BSF    FF2.7
6588:  CLRF   19
658A:  BTFSC  FF2.7
658C:  BSF    19.7
658E:  BCF    FF2.7
....................       fprintf(COM2,"\r\n"); 
6590:  MOVLW  0D
6592:  MOVLB  8
6594:  MOVWF  xE8
6596:  MOVLB  0
6598:  CALL   045C
659C:  BTFSC  19.7
659E:  BSF    FF2.7
65A0:  CLRF   19
65A2:  BTFSC  FF2.7
65A4:  BSF    19.7
65A6:  BCF    FF2.7
65A8:  MOVLW  0A
65AA:  MOVLB  8
65AC:  MOVWF  xE8
65AE:  MOVLB  0
65B0:  CALL   045C
65B4:  BTFSC  19.7
65B6:  BSF    FF2.7
....................       fprintf(COM2,"Done PIN"); 
65B8:  MOVLW  5E
65BA:  MOVWF  FF6
65BC:  MOVLW  03
65BE:  MOVWF  FF7
65C0:  CLRF   19
65C2:  BTFSC  FF2.7
65C4:  BSF    19.7
65C6:  BCF    FF2.7
65C8:  CALL   04A2
65CC:  BTFSC  19.7
65CE:  BSF    FF2.7
65D0:  CLRF   19
65D2:  BTFSC  FF2.7
65D4:  BSF    19.7
65D6:  BCF    FF2.7
....................       fprintf(COM2,"\r\n"); 
65D8:  MOVLW  0D
65DA:  MOVLB  8
65DC:  MOVWF  xE8
65DE:  MOVLB  0
65E0:  CALL   045C
65E4:  BTFSC  19.7
65E6:  BSF    FF2.7
65E8:  CLRF   19
65EA:  BTFSC  FF2.7
65EC:  BSF    19.7
65EE:  BCF    FF2.7
65F0:  MOVLW  0A
65F2:  MOVLB  8
65F4:  MOVWF  xE8
65F6:  MOVLB  0
65F8:  CALL   045C
65FC:  BTFSC  19.7
65FE:  BSF    FF2.7
....................    } 
.................... } 
6600:  GOTO   89D2 (RETURN)
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
3E10:  MOVF   27,F
3E12:  BTFSS  FD8.2
3E14:  BRA    3F8A
3E16:  MOVF   26,W
3E18:  SUBLW  01
3E1A:  BTFSS  FD8.0
3E1C:  BRA    3F8A
3E1E:  BNZ   3E32
3E20:  MOVF   25,W
3E22:  SUBLW  FF
3E24:  BTFSS  FD8.0
3E26:  BRA    3F8A
3E28:  BNZ   3E32
3E2A:  MOVF   24,W
3E2C:  SUBLW  FE
3E2E:  BTFSS  FD8.0
3E30:  BRA    3F8A
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
3E32:  MOVLB  1
3E34:  MOVF   x35,F
3E36:  BNZ   3E3E
3E38:  MOVF   x2F,F
3E3A:  BTFSC  FD8.2
3E3C:  BRA    3F38
....................       { 
....................          temp=get_countcard(); 
3E3E:  MOVLB  0
3E40:  CALL   33E2
3E44:  MOVFF  02,8C1
3E48:  MOVFF  01,8C0
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
3E4C:  MOVFF  8C1,8C5
3E50:  MOVFF  8C0,8C4
3E54:  MOVLB  8
3E56:  CLRF   xC7
3E58:  MOVLW  0C
3E5A:  MOVWF  xC6
3E5C:  MOVLB  0
3E5E:  CALL   343A
3E62:  MOVFF  02,8C3
3E66:  MOVFF  01,8C2
3E6A:  MOVLW  0E
3E6C:  MOVLB  8
3E6E:  ADDWF  xC2,F
3E70:  MOVLW  C3
3E72:  ADDWFC xC3,F
3E74:  MOVLW  01
3E76:  MOVWF  xC4
3E78:  BCF    FD8.2
3E7A:  BTFSC  FD8.0
3E7C:  INCF   xC4,F
3E7E:  CLRF   xC5
3E80:  MOVLW  01
3E82:  ADDWF  xC2,W
3E84:  MOVWF  00
3E86:  MOVLW  00
3E88:  ADDWFC xC3,W
3E8A:  MOVWF  01
3E8C:  MOVLW  00
3E8E:  ADDWFC xC4,W
3E90:  MOVWF  02
3E92:  MOVLW  00
3E94:  ADDWFC xC5,W
3E96:  MOVWF  27
3E98:  MOVFF  02,26
3E9C:  MOVFF  01,25
3EA0:  MOVFF  00,24
....................          for(i=0;i<key_numbyte-5;i++) 
3EA4:  CLRF   xBF
3EA6:  MOVF   xBF,W
3EA8:  SUBLW  06
3EAA:  BNC   3F0A
....................          { 
....................             temp=key_data[i]; 
3EAC:  CLRF   03
3EAE:  MOVF   xBF,W
3EB0:  ADDLW  35
3EB2:  MOVWF  FE9
3EB4:  MOVLW  01
3EB6:  ADDWFC 03,W
3EB8:  MOVWF  FEA
3EBA:  CLRF   xC1
3EBC:  MOVFF  FEF,8C0
....................             write_ext_eeprom((long int)ptr_card_key++,temp); 
3EC0:  MOVFF  27,03
3EC4:  MOVFF  26,02
3EC8:  MOVFF  25,01
3ECC:  MOVFF  24,00
3ED0:  MOVLW  01
3ED2:  ADDWF  24,F
3ED4:  BTFSC  FD8.0
3ED6:  INCF   25,F
3ED8:  BTFSC  FD8.2
3EDA:  INCF   26,F
3EDC:  BTFSC  FD8.2
3EDE:  INCF   27,F
3EE0:  MOVFF  01,8C3
3EE4:  MOVFF  00,8C2
3EE8:  CLRF   xD3
3EEA:  CLRF   xD2
3EEC:  MOVFF  01,8D1
3EF0:  MOVFF  00,8D0
3EF4:  MOVFF  8C0,8D4
3EF8:  MOVLB  0
3EFA:  RCALL  3866
....................             //delay_us(100); 
....................             fputc(temp,COM2); 
3EFC:  MOVFF  8C0,8E8
3F00:  CALL   045C
....................          } 
3F04:  MOVLB  8
3F06:  INCF   xBF,F
3F08:  BRA    3EA6
....................          /*fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<key_numbyte;i++) 
....................           { 
....................             fprintf(COM2,"read key=%c\n\r",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          write_ext_eeprom((long int)ptr_card_key,0); 
3F0A:  CLRF   xD3
3F0C:  CLRF   xD2
3F0E:  MOVFF  25,8D1
3F12:  MOVFF  24,8D0
3F16:  CLRF   xD4
3F18:  MOVLB  0
3F1A:  RCALL  3866
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
3F1C:  MOVFF  27,8C5
3F20:  MOVFF  26,8C4
3F24:  MOVFF  25,8C3
3F28:  MOVFF  24,8C2
3F2C:  MOVLW  1E
3F2E:  MOVLB  8
3F30:  MOVWF  xC6
3F32:  MOVLB  0
3F34:  RCALL  3964
3F36:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
3F38:  CLRF   x2F
....................       del_buf(key_numbyte,key_data); 
3F3A:  MOVLW  0C
3F3C:  MOVLB  8
3F3E:  MOVWF  xCE
3F40:  MOVLW  01
3F42:  MOVWF  xD0
3F44:  MOVLW  35
3F46:  MOVWF  xCF
3F48:  MOVLB  0
3F4A:  CALL   345C
....................       fprintf(COM2,"\r\n"); 
3F4E:  MOVLW  0D
3F50:  MOVLB  8
3F52:  MOVWF  xE8
3F54:  MOVLB  0
3F56:  CALL   045C
3F5A:  MOVLW  0A
3F5C:  MOVLB  8
3F5E:  MOVWF  xE8
3F60:  MOVLB  0
3F62:  CALL   045C
....................       fprintf(COM2,"Done PIN"); 
3F66:  MOVLW  68
3F68:  MOVWF  FF6
3F6A:  MOVLW  03
3F6C:  MOVWF  FF7
3F6E:  CALL   04A2
....................       fprintf(COM2,"\r\n"); 
3F72:  MOVLW  0D
3F74:  MOVLB  8
3F76:  MOVWF  xE8
3F78:  MOVLB  0
3F7A:  CALL   045C
3F7E:  MOVLW  0A
3F80:  MOVLB  8
3F82:  MOVWF  xE8
3F84:  MOVLB  0
3F86:  CALL   045C
....................    } 
.................... } 
3F8A:  GOTO   424E (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
6652:  MOVLB  7
6654:  CLRF   xDE
6656:  CLRF   xDD
6658:  CLRF   xDF
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
665A:  MOVF   xDE,F
665C:  BTFSS  FD8.2
665E:  BRA    6782
6660:  MOVF   xD8,W
6662:  SUBWF  xDD,W
6664:  BTFSC  FD8.0
6666:  BRA    6782
6668:  MOVF   xDF,F
666A:  BTFSS  FD8.2
666C:  BRA    6782
....................       c = fgetc(COM2);//getc(); 
666E:  MOVLB  0
6670:  RCALL  6604
6672:  MOVFF  01,7DB
....................       switch(c) 
....................       { 
6676:  MOVLB  7
6678:  MOVF   xDB,W
667A:  XORLW  7F
667C:  MOVLB  0
667E:  BZ    6686
6680:  XORLW  72
6682:  BZ    66D4
6684:  BRA    6712
....................          case 0x7f:    
....................             if(nbcar>0)   
6686:  MOVLB  7
6688:  MOVF   xDD,F
668A:  BNZ   6690
668C:  MOVF   xDE,F
668E:  BZ    66BA
6690:  CLRF   19
6692:  BTFSC  FF2.7
6694:  BSF    19.7
6696:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
6698:  MOVLW  7F
669A:  MOVLB  8
669C:  MOVWF  xE8
669E:  MOVLB  0
66A0:  CALL   045C
66A4:  BTFSC  19.7
66A6:  BSF    FF2.7
....................                nbcar--; 
66A8:  MOVLB  7
66AA:  MOVF   xDD,W
66AC:  BTFSC  FD8.2
66AE:  DECF   xDE,F
66B0:  DECF   xDD,F
....................                fgetc(COM2);//getc(); 
66B2:  MOVLB  0
66B4:  RCALL  6604
....................             } 
....................             else fputc(0x07,COM2);    
66B6:  BRA    66D2
66B8:  MOVLB  7
66BA:  CLRF   19
66BC:  BTFSC  FF2.7
66BE:  BSF    19.7
66C0:  BCF    FF2.7
66C2:  MOVLW  07
66C4:  MOVLB  8
66C6:  MOVWF  xE8
66C8:  MOVLB  0
66CA:  CALL   045C
66CE:  BTFSC  19.7
66D0:  BSF    FF2.7
....................          break;  
66D2:  BRA    677E
....................          case 0x0D:   
....................                keydebug_en=0; 
66D4:  MOVLB  1
66D6:  CLRF   x2C
....................                set_tris_a(0xff); 
66D8:  MOVLW  FF
66DA:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
66DC:  MOVFF  7DD,7DC
66E0:  MOVLB  7
66E2:  MOVF   xD8,W
66E4:  SUBWF  xDC,W
66E6:  BC    66FC
....................                { 
....................                  chaine[i]=0; 
66E8:  CLRF   03
66EA:  MOVF   xDC,W
66EC:  ADDWF  xD9,W
66EE:  MOVWF  FE9
66F0:  MOVF   xDA,W
66F2:  ADDWFC 03,W
66F4:  MOVWF  FEA
66F6:  CLRF   FEF
....................                } 
66F8:  INCF   xDC,F
66FA:  BRA    66E2
....................                if(nbcar==0)return(FAUX); 
66FC:  MOVF   xDD,F
66FE:  BNZ   670A
6700:  MOVF   xDE,F
6702:  BNZ   670A
6704:  MOVLW  00
6706:  MOVWF  01
6708:  BRA    6786
....................                fini=VRAI; 
670A:  MOVLW  01
670C:  MOVWF  xDF
....................          break; 
670E:  MOVLB  0
6710:  BRA    677E
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
6712:  MOVLB  7
6714:  MOVF   xDB,W
6716:  SUBLW  1F
6718:  BC    6780
671A:  MOVF   xDB,W
671C:  SUBLW  7E
671E:  BNC   6780
6720:  MOVLW  01
6722:  SUBWF  xD8,W
6724:  MOVF   xDE,F
6726:  BNZ   6780
6728:  SUBWF  xDD,W
672A:  BC    6780
....................             { 
....................                chaine[nbcar]=c; 
672C:  MOVF   xD9,W
672E:  ADDWF  xDD,W
6730:  MOVWF  FE9
6732:  MOVF   xDA,W
6734:  ADDWFC xDE,W
6736:  MOVWF  FEA
6738:  MOVFF  7DB,FEF
....................                nbcar++; 
673C:  INCF   xDD,F
673E:  BTFSC  FD8.2
6740:  INCF   xDE,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
6742:  DECFSZ xD7,W
6744:  BRA    6760
6746:  CLRF   19
6748:  BTFSC  FF2.7
674A:  BSF    19.7
674C:  BCF    FF2.7
674E:  MOVFF  7DB,8E8
6752:  MOVLB  0
6754:  CALL   045C
6758:  BTFSC  19.7
675A:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
675C:  BRA    677E
675E:  MOVLB  7
6760:  MOVF   xD7,W
6762:  SUBLW  02
6764:  BNZ   6780
6766:  CLRF   19
6768:  BTFSC  FF2.7
676A:  BSF    19.7
676C:  BCF    FF2.7
676E:  MOVLW  2A
6770:  MOVLB  8
6772:  MOVWF  xE8
6774:  MOVLB  0
6776:  CALL   045C
677A:  BTFSC  19.7
677C:  BSF    FF2.7
677E:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
6780:  BRA    665A
....................    return(nbcar); 
6782:  MOVFF  7DD,01
.................... } 
6786:  MOVLB  0
6788:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
678A:  MOVFF  7D8,7DC
678E:  MOVFF  7D7,7DB
6792:  MOVFF  7DA,7DE
6796:  MOVFF  7D9,7DD
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
679A:  MOVFF  7DC,03
679E:  MOVLB  7
67A0:  MOVFF  7DB,FE9
67A4:  MOVFF  7DC,FEA
67A8:  MOVF   FEF,F
67AA:  BZ    67F2
67AC:  MOVFF  7DE,03
67B0:  MOVFF  7DD,FE9
67B4:  MOVFF  7DE,FEA
67B8:  MOVF   FEF,F
67BA:  BZ    67F2
....................       if(*aa!=*bb) 
67BC:  MOVFF  7DB,FE9
67C0:  MOVFF  7DC,FEA
67C4:  MOVFF  FEF,7DF
67C8:  MOVFF  7DE,03
67CC:  MOVFF  7DD,FE9
67D0:  MOVFF  7DE,FEA
67D4:  MOVF   FEF,W
67D6:  SUBWF  xDF,W
67D8:  BZ    67E0
....................          return(1); 
67DA:  MOVLW  01
67DC:  MOVWF  01
67DE:  BRA    681E
....................       aa++; 
67E0:  INCF   xDB,F
67E2:  BTFSC  FD8.2
67E4:  INCF   xDC,F
....................       bb++; 
67E6:  INCF   xDD,F
67E8:  BTFSC  FD8.2
67EA:  INCF   xDE,F
....................    } 
67EC:  MOVLB  0
67EE:  BRA    679A
67F0:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
67F2:  MOVFF  7DC,03
67F6:  MOVFF  7DB,FE9
67FA:  MOVFF  7DC,FEA
67FE:  MOVFF  FEF,7DF
6802:  MOVFF  7DE,03
6806:  MOVFF  7DD,FE9
680A:  MOVFF  7DE,FEA
680E:  MOVF   FEF,W
6810:  SUBWF  xDF,W
6812:  BZ    681A
6814:  MOVLW  01
6816:  MOVWF  01
6818:  BRA    681E
....................    return(0); 
681A:  MOVLW  00
681C:  MOVWF  01
.................... } 
681E:  MOVLB  0
6820:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
6D40:  MOVLB  7
6D42:  CLRF   xD9
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
6D44:  MOVFF  7D8,03
6D48:  MOVF   xD7,W
6D4A:  INCF   xD7,F
6D4C:  BTFSC  FD8.2
6D4E:  INCF   xD8,F
6D50:  MOVWF  FE9
6D52:  MOVFF  03,FEA
6D56:  MOVFF  FEF,7DB
6D5A:  MOVF   xDB,F
6D5C:  BZ    6D80
....................         if (c >= '0' && c <= '9') 
6D5E:  MOVF   xDB,W
6D60:  SUBLW  2F
6D62:  BC    6D72
6D64:  MOVF   xDB,W
6D66:  SUBLW  39
6D68:  BNC   6D72
....................             digit = (unsigned int) (c - '0'); 
6D6A:  MOVLW  30
6D6C:  SUBWF  xDB,W
6D6E:  MOVWF  xDA
....................         else 
6D70:  BRA    6D74
....................             break; 
6D72:  BRA    6D80
....................  
....................         val = (val * 10) + digit; 
6D74:  MOVF   xD9,W
6D76:  MULLW  0A
6D78:  MOVF   FF3,W
6D7A:  ADDWF  xDA,W
6D7C:  MOVWF  xD9
....................     } 
6D7E:  BRA    6D44
....................  
....................     return val; 
6D80:  CLRF   03
6D82:  MOVFF  7D9,01
6D86:  MOVFF  03,02
.................... } 
6D8A:  MOVLB  0
6D8C:  RETURN 0
....................  
.................... int8 receiver_state=0,booting_done=0; 
.................... int16 over_byte=0; 
.................... //#include <GSM.c>  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
04C2:  MOVLB  8
04C4:  CLRF   xF8
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
04C6:  CLRF   xF9
04C8:  BTFSC  xF0.0
04CA:  BSF    xF9.7
04CC:  SWAPF  xF1,W
04CE:  MOVWF  00
04D0:  RLCF   00,F
04D2:  RLCF   00,F
04D4:  MOVLW  C0
04D6:  ANDWF  00,F
04D8:  MOVF   00,W
04DA:  IORWF  xF9,F
04DC:  SWAPF  xF2,W
04DE:  MOVWF  00
04E0:  RLCF   00,F
04E2:  MOVLW  E0
04E4:  ANDWF  00,F
04E6:  MOVF   00,W
04E8:  IORWF  xF9,F
04EA:  SWAPF  xF3,W
04EC:  MOVWF  00
04EE:  MOVLW  F0
04F0:  ANDWF  00,F
04F2:  MOVF   00,W
04F4:  IORWF  xF9,F
04F6:  RLCF   xF4,W
04F8:  MOVWF  00
04FA:  RLCF   00,F
04FC:  RLCF   00,F
04FE:  MOVLW  F8
0500:  ANDWF  00,F
0502:  MOVF   00,W
0504:  IORWF  xF9,F
0506:  RLCF   xF5,W
0508:  MOVWF  00
050A:  RLCF   00,F
050C:  MOVLW  FC
050E:  ANDWF  00,F
0510:  MOVF   00,W
0512:  IORWF  xF9,F
0514:  BCF    FD8.0
0516:  RLCF   xF6,W
0518:  IORWF  xF9,F
051A:  MOVF   xF7,W
051C:  IORWF  xF9,W
051E:  MOVWF  xF8
....................    return temp; 
0520:  MOVFF  8F8,01
.................... } 
0524:  MOVLB  0
0526:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0528:  MOVLB  8
052A:  CLRF   xE0
....................    int8 temp=0; 
....................    if(direct==0) 
052C:  MOVF   xDB,F
052E:  BNZ   0604
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
0530:  MOVF   xDE,W
0532:  ADDWF  xDC,W
0534:  MOVWF  FE9
0536:  MOVF   xDF,W
0538:  ADDWFC xDD,W
053A:  MOVWF  FEA
053C:  MOVFF  FEF,8E1
0540:  MOVLW  01
0542:  ADDWF  xDC,W
0544:  MOVWF  xE2
0546:  MOVLW  00
0548:  ADDWFC xDD,W
054A:  MOVWF  xE3
054C:  MOVF   xDE,W
054E:  ADDWF  xE2,W
0550:  MOVWF  FE9
0552:  MOVF   xDF,W
0554:  ADDWFC xE3,W
0556:  MOVWF  FEA
0558:  MOVF   FEF,W
055A:  XORWF  xE1,F
055C:  MOVLW  02
055E:  ADDWF  xDC,W
0560:  MOVWF  xE4
0562:  MOVLW  00
0564:  ADDWFC xDD,W
0566:  MOVWF  xE5
0568:  MOVF   xDE,W
056A:  ADDWF  xE4,W
056C:  MOVWF  FE9
056E:  MOVF   xDF,W
0570:  ADDWFC xE5,W
0572:  MOVWF  FEA
0574:  MOVF   FEF,W
0576:  XORWF  xE1,F
0578:  MOVLW  03
057A:  ADDWF  xDC,W
057C:  MOVWF  xE6
057E:  MOVLW  00
0580:  ADDWFC xDD,W
0582:  MOVWF  xE7
0584:  MOVF   xDE,W
0586:  ADDWF  xE6,W
0588:  MOVWF  FE9
058A:  MOVF   xDF,W
058C:  ADDWFC xE7,W
058E:  MOVWF  FEA
0590:  MOVF   FEF,W
0592:  XORWF  xE1,F
0594:  MOVLW  04
0596:  ADDWF  xDC,W
0598:  MOVWF  xE8
059A:  MOVLW  00
059C:  ADDWFC xDD,W
059E:  MOVWF  xE9
05A0:  MOVF   xDE,W
05A2:  ADDWF  xE8,W
05A4:  MOVWF  FE9
05A6:  MOVF   xDF,W
05A8:  ADDWFC xE9,W
05AA:  MOVWF  FEA
05AC:  MOVF   FEF,W
05AE:  XORWF  xE1,F
05B0:  MOVLW  05
05B2:  ADDWF  xDC,W
05B4:  MOVWF  xEA
05B6:  MOVLW  00
05B8:  ADDWFC xDD,W
05BA:  MOVWF  xEB
05BC:  MOVF   xDE,W
05BE:  ADDWF  xEA,W
05C0:  MOVWF  FE9
05C2:  MOVF   xDF,W
05C4:  ADDWFC xEB,W
05C6:  MOVWF  FEA
05C8:  MOVF   FEF,W
05CA:  XORWF  xE1,W
05CC:  BZ    05D2
05CE:  MOVLW  00
05D0:  BRA    05D4
05D2:  MOVLW  01
05D4:  MOVWF  xE0
....................       if(temp==datain[offset+6]) return 1; 
05D6:  MOVLW  06
05D8:  ADDWF  xDC,W
05DA:  MOVWF  xE1
05DC:  MOVLW  00
05DE:  ADDWFC xDD,W
05E0:  MOVWF  xE2
05E2:  MOVF   xDE,W
05E4:  ADDWF  xE1,W
05E6:  MOVWF  FE9
05E8:  MOVF   xDF,W
05EA:  ADDWFC xE2,W
05EC:  MOVWF  FEA
05EE:  MOVF   FEF,W
05F0:  SUBWF  xE0,W
05F2:  BNZ   05FC
05F4:  MOVLW  01
05F6:  MOVWF  01
05F8:  BRA    06D4
....................          else return 0; 
05FA:  BRA    0602
05FC:  MOVLW  00
05FE:  MOVWF  01
0600:  BRA    06D4
....................    } 
....................       else  
0602:  BRA    06D4
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
0604:  MOVF   xDE,W
0606:  ADDWF  xDC,W
0608:  MOVWF  FE9
060A:  MOVF   xDF,W
060C:  ADDWFC xDD,W
060E:  MOVWF  FEA
0610:  MOVFF  FEF,8E1
0614:  MOVLW  01
0616:  SUBWF  xDC,W
0618:  MOVWF  xE2
061A:  MOVLW  00
061C:  SUBWFB xDD,W
061E:  MOVWF  xE3
0620:  MOVF   xDE,W
0622:  ADDWF  xE2,W
0624:  MOVWF  FE9
0626:  MOVF   xDF,W
0628:  ADDWFC xE3,W
062A:  MOVWF  FEA
062C:  MOVF   FEF,W
062E:  XORWF  xE1,F
0630:  MOVLW  02
0632:  SUBWF  xDC,W
0634:  MOVWF  xE4
0636:  MOVLW  00
0638:  SUBWFB xDD,W
063A:  MOVWF  xE5
063C:  MOVF   xDE,W
063E:  ADDWF  xE4,W
0640:  MOVWF  FE9
0642:  MOVF   xDF,W
0644:  ADDWFC xE5,W
0646:  MOVWF  FEA
0648:  MOVF   FEF,W
064A:  XORWF  xE1,F
064C:  MOVLW  03
064E:  SUBWF  xDC,W
0650:  MOVWF  xE6
0652:  MOVLW  00
0654:  SUBWFB xDD,W
0656:  MOVWF  xE7
0658:  MOVF   xDE,W
065A:  ADDWF  xE6,W
065C:  MOVWF  FE9
065E:  MOVF   xDF,W
0660:  ADDWFC xE7,W
0662:  MOVWF  FEA
0664:  MOVF   FEF,W
0666:  XORWF  xE1,F
0668:  MOVLW  04
066A:  SUBWF  xDC,W
066C:  MOVWF  xE8
066E:  MOVLW  00
0670:  SUBWFB xDD,W
0672:  MOVWF  xE9
0674:  MOVF   xDE,W
0676:  ADDWF  xE8,W
0678:  MOVWF  FE9
067A:  MOVF   xDF,W
067C:  ADDWFC xE9,W
067E:  MOVWF  FEA
0680:  MOVF   FEF,W
0682:  XORWF  xE1,F
0684:  MOVLW  05
0686:  SUBWF  xDC,W
0688:  MOVWF  xEA
068A:  MOVLW  00
068C:  SUBWFB xDD,W
068E:  MOVWF  xEB
0690:  MOVF   xDE,W
0692:  ADDWF  xEA,W
0694:  MOVWF  FE9
0696:  MOVF   xDF,W
0698:  ADDWFC xEB,W
069A:  MOVWF  FEA
069C:  MOVF   FEF,W
069E:  XORWF  xE1,W
06A0:  BZ    06A6
06A2:  MOVLW  00
06A4:  BRA    06A8
06A6:  MOVLW  01
06A8:  MOVWF  xE0
....................          if(temp==datain[offset-6]) return 1; 
06AA:  MOVLW  06
06AC:  SUBWF  xDC,W
06AE:  MOVWF  xE1
06B0:  MOVLW  00
06B2:  SUBWFB xDD,W
06B4:  MOVWF  xE2
06B6:  MOVF   xDE,W
06B8:  ADDWF  xE1,W
06BA:  MOVWF  FE9
06BC:  MOVF   xDF,W
06BE:  ADDWFC xE2,W
06C0:  MOVWF  FEA
06C2:  MOVF   FEF,W
06C4:  SUBWF  xE0,W
06C6:  BNZ   06D0
06C8:  MOVLW  01
06CA:  MOVWF  01
06CC:  BRA    06D4
....................             else return 0;          
06CE:  BRA    06D4
06D0:  MOVLW  00
06D2:  MOVWF  01
....................       } 
.................... } 
06D4:  MOVLB  0
06D6:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
06D8:  MOVLB  8
06DA:  CLRF   xE0
....................    int8 temp=0; 
....................    if(direct==0) 
06DC:  MOVF   xDB,F
06DE:  BNZ   077C
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
06E0:  MOVF   xDE,W
06E2:  ADDWF  xDC,W
06E4:  MOVWF  FE9
06E6:  MOVF   xDF,W
06E8:  ADDWFC xDD,W
06EA:  MOVWF  FEA
06EC:  MOVFF  FEF,8E1
06F0:  MOVLW  01
06F2:  ADDWF  xDC,W
06F4:  MOVWF  xE2
06F6:  MOVLW  00
06F8:  ADDWFC xDD,W
06FA:  MOVWF  xE3
06FC:  MOVF   xDE,W
06FE:  ADDWF  xE2,W
0700:  MOVWF  FE9
0702:  MOVF   xDF,W
0704:  ADDWFC xE3,W
0706:  MOVWF  FEA
0708:  MOVF   FEF,W
070A:  XORWF  xE1,F
070C:  MOVLW  02
070E:  ADDWF  xDC,W
0710:  MOVWF  xE4
0712:  MOVLW  00
0714:  ADDWFC xDD,W
0716:  MOVWF  xE5
0718:  MOVF   xDE,W
071A:  ADDWF  xE4,W
071C:  MOVWF  FE9
071E:  MOVF   xDF,W
0720:  ADDWFC xE5,W
0722:  MOVWF  FEA
0724:  MOVF   FEF,W
0726:  XORWF  xE1,F
0728:  MOVLW  03
072A:  ADDWF  xDC,W
072C:  MOVWF  xE6
072E:  MOVLW  00
0730:  ADDWFC xDD,W
0732:  MOVWF  xE7
0734:  MOVF   xDE,W
0736:  ADDWF  xE6,W
0738:  MOVWF  FE9
073A:  MOVF   xDF,W
073C:  ADDWFC xE7,W
073E:  MOVWF  FEA
0740:  MOVF   FEF,W
0742:  XORWF  xE1,W
0744:  BZ    074A
0746:  MOVLW  00
0748:  BRA    074C
074A:  MOVLW  01
074C:  MOVWF  xE0
....................       if(temp==datain[offset+4]) return 1; 
074E:  MOVLW  04
0750:  ADDWF  xDC,W
0752:  MOVWF  xE1
0754:  MOVLW  00
0756:  ADDWFC xDD,W
0758:  MOVWF  xE2
075A:  MOVF   xDE,W
075C:  ADDWF  xE1,W
075E:  MOVWF  FE9
0760:  MOVF   xDF,W
0762:  ADDWFC xE2,W
0764:  MOVWF  FEA
0766:  MOVF   FEF,W
0768:  SUBWF  xE0,W
076A:  BNZ   0774
076C:  MOVLW  01
076E:  MOVWF  01
0770:  BRA    0814
....................          else return 0; 
0772:  BRA    077A
0774:  MOVLW  00
0776:  MOVWF  01
0778:  BRA    0814
....................    } 
....................    else 
077A:  BRA    0814
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
077C:  MOVF   xDE,W
077E:  ADDWF  xDC,W
0780:  MOVWF  FE9
0782:  MOVF   xDF,W
0784:  ADDWFC xDD,W
0786:  MOVWF  FEA
0788:  MOVFF  FEF,8E1
078C:  MOVLW  01
078E:  SUBWF  xDC,W
0790:  MOVWF  xE2
0792:  MOVLW  00
0794:  SUBWFB xDD,W
0796:  MOVWF  xE3
0798:  MOVF   xDE,W
079A:  ADDWF  xE2,W
079C:  MOVWF  FE9
079E:  MOVF   xDF,W
07A0:  ADDWFC xE3,W
07A2:  MOVWF  FEA
07A4:  MOVF   FEF,W
07A6:  XORWF  xE1,F
07A8:  MOVLW  02
07AA:  SUBWF  xDC,W
07AC:  MOVWF  xE4
07AE:  MOVLW  00
07B0:  SUBWFB xDD,W
07B2:  MOVWF  xE5
07B4:  MOVF   xDE,W
07B6:  ADDWF  xE4,W
07B8:  MOVWF  FE9
07BA:  MOVF   xDF,W
07BC:  ADDWFC xE5,W
07BE:  MOVWF  FEA
07C0:  MOVF   FEF,W
07C2:  XORWF  xE1,F
07C4:  MOVLW  03
07C6:  SUBWF  xDC,W
07C8:  MOVWF  xE6
07CA:  MOVLW  00
07CC:  SUBWFB xDD,W
07CE:  MOVWF  xE7
07D0:  MOVF   xDE,W
07D2:  ADDWF  xE6,W
07D4:  MOVWF  FE9
07D6:  MOVF   xDF,W
07D8:  ADDWFC xE7,W
07DA:  MOVWF  FEA
07DC:  MOVF   FEF,W
07DE:  XORWF  xE1,W
07E0:  BZ    07E6
07E2:  MOVLW  00
07E4:  BRA    07E8
07E6:  MOVLW  01
07E8:  MOVWF  xE0
....................       if(temp==datain[offset-4]) return 1; 
07EA:  MOVLW  04
07EC:  SUBWF  xDC,W
07EE:  MOVWF  xE1
07F0:  MOVLW  00
07F2:  SUBWFB xDD,W
07F4:  MOVWF  xE2
07F6:  MOVF   xDE,W
07F8:  ADDWF  xE1,W
07FA:  MOVWF  FE9
07FC:  MOVF   xDF,W
07FE:  ADDWFC xE2,W
0800:  MOVWF  FEA
0802:  MOVF   FEF,W
0804:  SUBWF  xE0,W
0806:  BNZ   0810
0808:  MOVLW  01
080A:  MOVWF  01
080C:  BRA    0814
....................          else return 0;                
080E:  BRA    0814
0810:  MOVLW  00
0812:  MOVWF  01
....................    } 
.................... } 
0814:  MOVLB  0
0816:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0818:  MOVLB  8
081A:  CLRF   xD7
081C:  CLRF   xD8
081E:  CLRF   xD9
0820:  CLRF   xDA
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0822:  CLRF   xD4
0824:  CLRF   xD3
0826:  RRCF   xD0,W
0828:  MOVWF  03
082A:  RRCF   xCF,W
082C:  MOVWF  02
082E:  RRCF   03,F
0830:  RRCF   02,F
0832:  MOVLW  3F
0834:  ANDWF  03,F
0836:  MOVFF  02,01
083A:  MOVF   xD4,W
083C:  SUBWF  03,W
083E:  BTFSS  FD8.0
0840:  BRA    0E00
0842:  BNZ   084C
0844:  MOVF   01,W
0846:  SUBWF  xD3,W
0848:  BTFSC  FD8.0
084A:  BRA    0E00
....................    { 
....................       if(track==0) 
084C:  MOVF   xCE,F
084E:  BTFSS  FD8.2
0850:  BRA    0B86
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0852:  MOVLW  06
0854:  ADDWF  xD3,W
0856:  MOVWF  xDB
0858:  MOVLW  00
085A:  ADDWFC xD4,W
085C:  MOVWF  xDC
085E:  MOVF   xD1,W
0860:  ADDWF  xDB,W
0862:  MOVWF  FE9
0864:  MOVF   xD2,W
0866:  ADDWFC xDC,W
0868:  MOVWF  FEA
086A:  MOVFF  FEF,8DD
086E:  MOVLW  05
0870:  ADDWF  xD3,W
0872:  MOVWF  xDE
0874:  MOVLW  00
0876:  ADDWFC xD4,W
0878:  MOVWF  xDF
087A:  MOVF   xD1,W
087C:  ADDWF  xDE,W
087E:  MOVWF  FE9
0880:  MOVF   xD2,W
0882:  ADDWFC xDF,W
0884:  MOVWF  FEA
0886:  MOVFF  FEF,8E0
088A:  MOVLW  04
088C:  ADDWF  xD3,W
088E:  MOVWF  xE1
0890:  MOVLW  00
0892:  ADDWFC xD4,W
0894:  MOVWF  xE2
0896:  MOVF   xD1,W
0898:  ADDWF  xE1,W
089A:  MOVWF  FE9
089C:  MOVF   xD2,W
089E:  ADDWFC xE2,W
08A0:  MOVWF  FEA
08A2:  MOVFF  FEF,8E3
08A6:  MOVLW  03
08A8:  ADDWF  xD3,W
08AA:  MOVWF  xE4
08AC:  MOVLW  00
08AE:  ADDWFC xD4,W
08B0:  MOVWF  xE5
08B2:  MOVF   xD1,W
08B4:  ADDWF  xE4,W
08B6:  MOVWF  FE9
08B8:  MOVF   xD2,W
08BA:  ADDWFC xE5,W
08BC:  MOVWF  FEA
08BE:  MOVFF  FEF,8E6
08C2:  MOVLW  02
08C4:  ADDWF  xD3,W
08C6:  MOVWF  xE7
08C8:  MOVLW  00
08CA:  ADDWFC xD4,W
08CC:  MOVWF  xE8
08CE:  MOVF   xD1,W
08D0:  ADDWF  xE7,W
08D2:  MOVWF  FE9
08D4:  MOVF   xD2,W
08D6:  ADDWFC xE8,W
08D8:  MOVWF  FEA
08DA:  MOVFF  FEF,8E9
08DE:  MOVLW  01
08E0:  ADDWF  xD3,W
08E2:  MOVWF  xEA
08E4:  MOVLW  00
08E6:  ADDWFC xD4,W
08E8:  MOVWF  xEB
08EA:  MOVF   xD1,W
08EC:  ADDWF  xEA,W
08EE:  MOVWF  FE9
08F0:  MOVF   xD2,W
08F2:  ADDWFC xEB,W
08F4:  MOVWF  FEA
08F6:  MOVFF  FEF,8EC
08FA:  MOVF   xD1,W
08FC:  ADDWF  xD3,W
08FE:  MOVWF  FE9
0900:  MOVF   xD2,W
0902:  ADDWFC xD4,W
0904:  MOVWF  FEA
0906:  MOVFF  FEF,8ED
090A:  CLRF   xF0
090C:  MOVFF  8DD,8F1
0910:  MOVFF  8E0,8F2
0914:  MOVFF  8E3,8F3
0918:  MOVFF  8E6,8F4
091C:  MOVFF  8E9,8F5
0920:  MOVFF  8EC,8F6
0924:  MOVFF  8ED,8F7
0928:  MOVLB  0
092A:  RCALL  04C2
092C:  MOVFF  01,8D7
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0930:  MOVLW  0D
0932:  MOVLB  8
0934:  ADDWF  xD3,W
0936:  MOVWF  xDB
0938:  MOVLW  00
093A:  ADDWFC xD4,W
093C:  MOVWF  xDC
093E:  MOVF   xD1,W
0940:  ADDWF  xDB,W
0942:  MOVWF  FE9
0944:  MOVF   xD2,W
0946:  ADDWFC xDC,W
0948:  MOVWF  FEA
094A:  MOVFF  FEF,8DD
094E:  MOVLW  0C
0950:  ADDWF  xD3,W
0952:  MOVWF  xDE
0954:  MOVLW  00
0956:  ADDWFC xD4,W
0958:  MOVWF  xDF
095A:  MOVF   xD1,W
095C:  ADDWF  xDE,W
095E:  MOVWF  FE9
0960:  MOVF   xD2,W
0962:  ADDWFC xDF,W
0964:  MOVWF  FEA
0966:  MOVFF  FEF,8E0
096A:  MOVLW  0B
096C:  ADDWF  xD3,W
096E:  MOVWF  xE1
0970:  MOVLW  00
0972:  ADDWFC xD4,W
0974:  MOVWF  xE2
0976:  MOVF   xD1,W
0978:  ADDWF  xE1,W
097A:  MOVWF  FE9
097C:  MOVF   xD2,W
097E:  ADDWFC xE2,W
0980:  MOVWF  FEA
0982:  MOVFF  FEF,8E3
0986:  MOVLW  0A
0988:  ADDWF  xD3,W
098A:  MOVWF  xE4
098C:  MOVLW  00
098E:  ADDWFC xD4,W
0990:  MOVWF  xE5
0992:  MOVF   xD1,W
0994:  ADDWF  xE4,W
0996:  MOVWF  FE9
0998:  MOVF   xD2,W
099A:  ADDWFC xE5,W
099C:  MOVWF  FEA
099E:  MOVFF  FEF,8E6
09A2:  MOVLW  09
09A4:  ADDWF  xD3,W
09A6:  MOVWF  xE7
09A8:  MOVLW  00
09AA:  ADDWFC xD4,W
09AC:  MOVWF  xE8
09AE:  MOVF   xD1,W
09B0:  ADDWF  xE7,W
09B2:  MOVWF  FE9
09B4:  MOVF   xD2,W
09B6:  ADDWFC xE8,W
09B8:  MOVWF  FEA
09BA:  MOVFF  FEF,8E9
09BE:  MOVLW  08
09C0:  ADDWF  xD3,W
09C2:  MOVWF  xEA
09C4:  MOVLW  00
09C6:  ADDWFC xD4,W
09C8:  MOVWF  xEB
09CA:  MOVF   xD1,W
09CC:  ADDWF  xEA,W
09CE:  MOVWF  FE9
09D0:  MOVF   xD2,W
09D2:  ADDWFC xEB,W
09D4:  MOVWF  FEA
09D6:  MOVFF  FEF,8EC
09DA:  MOVLW  07
09DC:  ADDWF  xD3,W
09DE:  MOVWF  xED
09E0:  MOVLW  00
09E2:  ADDWFC xD4,W
09E4:  MOVWF  xEE
09E6:  MOVF   xD1,W
09E8:  ADDWF  xED,W
09EA:  MOVWF  FE9
09EC:  MOVF   xD2,W
09EE:  ADDWFC xEE,W
09F0:  MOVWF  FEA
09F2:  MOVFF  FEF,8EF
09F6:  CLRF   xF0
09F8:  MOVFF  8DD,8F1
09FC:  MOVFF  8E0,8F2
0A00:  MOVFF  8E3,8F3
0A04:  MOVFF  8E6,8F4
0A08:  MOVFF  8E9,8F5
0A0C:  MOVFF  8EC,8F6
0A10:  MOVFF  8EF,8F7
0A14:  MOVLB  0
0A16:  RCALL  04C2
0A18:  MOVFF  01,8D8
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0A1C:  MOVLB  8
0A1E:  MOVF   xD7,W
0A20:  SUBLW  45
0A22:  BTFSS  FD8.2
0A24:  BRA    0B84
0A26:  MOVF   xD8,W
0A28:  SUBLW  7C
0A2A:  BTFSC  FD8.2
0A2C:  BRA    0B84
0A2E:  MOVF   xD8,W
0A30:  SUBLW  3E
0A32:  BTFSC  FD8.2
0A34:  BRA    0B84
0A36:  MOVF   xD8,W
0A38:  SUBLW  1F
0A3A:  BTFSC  FD8.2
0A3C:  BRA    0B84
....................          { 
....................             j=i; 
0A3E:  MOVFF  8D4,8D6
0A42:  MOVFF  8D3,8D5
....................             CRC=1; 
0A46:  MOVLW  01
0A48:  MOVWF  xDA
....................             temp2=temp; 
0A4A:  MOVFF  8D7,8D9
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0A4E:  MOVF   xD9,W
0A50:  SUBLW  1F
0A52:  BTFSC  FD8.2
0A54:  BRA    0B6E
0A56:  MOVF   xD6,W
0A58:  SUBLW  03
0A5A:  BTFSS  FD8.0
0A5C:  BRA    0B6E
0A5E:  BNZ   0A68
0A60:  MOVF   xD5,W
0A62:  SUBLW  E7
0A64:  BTFSS  FD8.0
0A66:  BRA    0B6E
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0A68:  CLRF   xDB
0A6A:  MOVFF  8D6,8DD
0A6E:  MOVFF  8D5,8DC
0A72:  MOVFF  8D2,8DF
0A76:  MOVFF  8D1,8DE
0A7A:  MOVLB  0
0A7C:  RCALL  0528
0A7E:  MOVF   01,W
0A80:  MOVLB  8
0A82:  ANDWF  xDA,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0A84:  MOVLW  06
0A86:  ADDWF  xD5,W
0A88:  MOVWF  xDB
0A8A:  MOVLW  00
0A8C:  ADDWFC xD6,W
0A8E:  MOVWF  xDC
0A90:  MOVF   xD1,W
0A92:  ADDWF  xDB,W
0A94:  MOVWF  FE9
0A96:  MOVF   xD2,W
0A98:  ADDWFC xDC,W
0A9A:  MOVWF  FEA
0A9C:  MOVFF  FEF,8DD
0AA0:  MOVLW  05
0AA2:  ADDWF  xD5,W
0AA4:  MOVWF  xDE
0AA6:  MOVLW  00
0AA8:  ADDWFC xD6,W
0AAA:  MOVWF  xDF
0AAC:  MOVF   xD1,W
0AAE:  ADDWF  xDE,W
0AB0:  MOVWF  FE9
0AB2:  MOVF   xD2,W
0AB4:  ADDWFC xDF,W
0AB6:  MOVWF  FEA
0AB8:  MOVFF  FEF,8E0
0ABC:  MOVLW  04
0ABE:  ADDWF  xD5,W
0AC0:  MOVWF  xE1
0AC2:  MOVLW  00
0AC4:  ADDWFC xD6,W
0AC6:  MOVWF  xE2
0AC8:  MOVF   xD1,W
0ACA:  ADDWF  xE1,W
0ACC:  MOVWF  FE9
0ACE:  MOVF   xD2,W
0AD0:  ADDWFC xE2,W
0AD2:  MOVWF  FEA
0AD4:  MOVFF  FEF,8E3
0AD8:  MOVLW  03
0ADA:  ADDWF  xD5,W
0ADC:  MOVWF  xE4
0ADE:  MOVLW  00
0AE0:  ADDWFC xD6,W
0AE2:  MOVWF  xE5
0AE4:  MOVF   xD1,W
0AE6:  ADDWF  xE4,W
0AE8:  MOVWF  FE9
0AEA:  MOVF   xD2,W
0AEC:  ADDWFC xE5,W
0AEE:  MOVWF  FEA
0AF0:  MOVFF  FEF,8E6
0AF4:  MOVLW  02
0AF6:  ADDWF  xD5,W
0AF8:  MOVWF  xE7
0AFA:  MOVLW  00
0AFC:  ADDWFC xD6,W
0AFE:  MOVWF  xE8
0B00:  MOVF   xD1,W
0B02:  ADDWF  xE7,W
0B04:  MOVWF  FE9
0B06:  MOVF   xD2,W
0B08:  ADDWFC xE8,W
0B0A:  MOVWF  FEA
0B0C:  MOVFF  FEF,8E9
0B10:  MOVLW  01
0B12:  ADDWF  xD5,W
0B14:  MOVWF  xEA
0B16:  MOVLW  00
0B18:  ADDWFC xD6,W
0B1A:  MOVWF  xEB
0B1C:  MOVF   xD1,W
0B1E:  ADDWF  xEA,W
0B20:  MOVWF  FE9
0B22:  MOVF   xD2,W
0B24:  ADDWFC xEB,W
0B26:  MOVWF  FEA
0B28:  MOVFF  FEF,8EC
0B2C:  MOVF   xD1,W
0B2E:  ADDWF  xD5,W
0B30:  MOVWF  FE9
0B32:  MOVF   xD2,W
0B34:  ADDWFC xD6,W
0B36:  MOVWF  FEA
0B38:  MOVFF  FEF,8ED
0B3C:  CLRF   xF0
0B3E:  MOVFF  8DD,8F1
0B42:  MOVFF  8E0,8F2
0B46:  MOVFF  8E3,8F3
0B4A:  MOVFF  8E6,8F4
0B4E:  MOVFF  8E9,8F5
0B52:  MOVFF  8EC,8F6
0B56:  MOVFF  8ED,8F7
0B5A:  MOVLB  0
0B5C:  RCALL  04C2
0B5E:  MOVFF  01,8D9
....................                j=j+7; 
0B62:  MOVLW  07
0B64:  MOVLB  8
0B66:  ADDWF  xD5,F
0B68:  MOVLW  00
0B6A:  ADDWFC xD6,F
....................             } 
0B6C:  BRA    0A4E
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0B6E:  DECFSZ xDA,W
0B70:  BRA    0B84
....................             { 
....................                dir=0; 
0B72:  MOVLB  6
0B74:  CLRF   xAC
....................                return i; 
0B76:  MOVLB  8
0B78:  MOVFF  8D3,01
0B7C:  MOVFF  8D4,02
0B80:  GOTO   1416
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0B84:  BRA    0DF8
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0B86:  MOVLW  04
0B88:  ADDWF  xD3,W
0B8A:  MOVWF  xDB
0B8C:  MOVLW  00
0B8E:  ADDWFC xD4,W
0B90:  MOVWF  xDC
0B92:  MOVF   xD1,W
0B94:  ADDWF  xDB,W
0B96:  MOVWF  FE9
0B98:  MOVF   xD2,W
0B9A:  ADDWFC xDC,W
0B9C:  MOVWF  FEA
0B9E:  MOVFF  FEF,8DD
0BA2:  MOVLW  03
0BA4:  ADDWF  xD3,W
0BA6:  MOVWF  xDE
0BA8:  MOVLW  00
0BAA:  ADDWFC xD4,W
0BAC:  MOVWF  xDF
0BAE:  MOVF   xD1,W
0BB0:  ADDWF  xDE,W
0BB2:  MOVWF  FE9
0BB4:  MOVF   xD2,W
0BB6:  ADDWFC xDF,W
0BB8:  MOVWF  FEA
0BBA:  MOVFF  FEF,8E0
0BBE:  MOVLW  02
0BC0:  ADDWF  xD3,W
0BC2:  MOVWF  xE1
0BC4:  MOVLW  00
0BC6:  ADDWFC xD4,W
0BC8:  MOVWF  xE2
0BCA:  MOVF   xD1,W
0BCC:  ADDWF  xE1,W
0BCE:  MOVWF  FE9
0BD0:  MOVF   xD2,W
0BD2:  ADDWFC xE2,W
0BD4:  MOVWF  FEA
0BD6:  MOVFF  FEF,8E3
0BDA:  MOVLW  01
0BDC:  ADDWF  xD3,W
0BDE:  MOVWF  xE4
0BE0:  MOVLW  00
0BE2:  ADDWFC xD4,W
0BE4:  MOVWF  xE5
0BE6:  MOVF   xD1,W
0BE8:  ADDWF  xE4,W
0BEA:  MOVWF  FE9
0BEC:  MOVF   xD2,W
0BEE:  ADDWFC xE5,W
0BF0:  MOVWF  FEA
0BF2:  MOVFF  FEF,8E6
0BF6:  MOVF   xD1,W
0BF8:  ADDWF  xD3,W
0BFA:  MOVWF  FE9
0BFC:  MOVF   xD2,W
0BFE:  ADDWFC xD4,W
0C00:  MOVWF  FEA
0C02:  MOVFF  FEF,8E7
0C06:  CLRF   xF0
0C08:  CLRF   xF1
0C0A:  CLRF   xF2
0C0C:  MOVFF  8DD,8F3
0C10:  MOVFF  8E0,8F4
0C14:  MOVFF  8E3,8F5
0C18:  MOVFF  8E6,8F6
0C1C:  MOVFF  8E7,8F7
0C20:  MOVLB  0
0C22:  RCALL  04C2
0C24:  MOVFF  01,8D7
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0C28:  MOVLW  09
0C2A:  MOVLB  8
0C2C:  ADDWF  xD3,W
0C2E:  MOVWF  xDB
0C30:  MOVLW  00
0C32:  ADDWFC xD4,W
0C34:  MOVWF  xDC
0C36:  MOVF   xD1,W
0C38:  ADDWF  xDB,W
0C3A:  MOVWF  FE9
0C3C:  MOVF   xD2,W
0C3E:  ADDWFC xDC,W
0C40:  MOVWF  FEA
0C42:  MOVFF  FEF,8DD
0C46:  MOVLW  08
0C48:  ADDWF  xD3,W
0C4A:  MOVWF  xDE
0C4C:  MOVLW  00
0C4E:  ADDWFC xD4,W
0C50:  MOVWF  xDF
0C52:  MOVF   xD1,W
0C54:  ADDWF  xDE,W
0C56:  MOVWF  FE9
0C58:  MOVF   xD2,W
0C5A:  ADDWFC xDF,W
0C5C:  MOVWF  FEA
0C5E:  MOVFF  FEF,8E0
0C62:  MOVLW  07
0C64:  ADDWF  xD3,W
0C66:  MOVWF  xE1
0C68:  MOVLW  00
0C6A:  ADDWFC xD4,W
0C6C:  MOVWF  xE2
0C6E:  MOVF   xD1,W
0C70:  ADDWF  xE1,W
0C72:  MOVWF  FE9
0C74:  MOVF   xD2,W
0C76:  ADDWFC xE2,W
0C78:  MOVWF  FEA
0C7A:  MOVFF  FEF,8E3
0C7E:  MOVLW  06
0C80:  ADDWF  xD3,W
0C82:  MOVWF  xE4
0C84:  MOVLW  00
0C86:  ADDWFC xD4,W
0C88:  MOVWF  xE5
0C8A:  MOVF   xD1,W
0C8C:  ADDWF  xE4,W
0C8E:  MOVWF  FE9
0C90:  MOVF   xD2,W
0C92:  ADDWFC xE5,W
0C94:  MOVWF  FEA
0C96:  MOVFF  FEF,8E6
0C9A:  MOVLW  05
0C9C:  ADDWF  xD3,W
0C9E:  MOVWF  xE7
0CA0:  MOVLW  00
0CA2:  ADDWFC xD4,W
0CA4:  MOVWF  xE8
0CA6:  MOVF   xD1,W
0CA8:  ADDWF  xE7,W
0CAA:  MOVWF  FE9
0CAC:  MOVF   xD2,W
0CAE:  ADDWFC xE8,W
0CB0:  MOVWF  FEA
0CB2:  MOVFF  FEF,8E9
0CB6:  CLRF   xF0
0CB8:  CLRF   xF1
0CBA:  CLRF   xF2
0CBC:  MOVFF  8DD,8F3
0CC0:  MOVFF  8E0,8F4
0CC4:  MOVFF  8E3,8F5
0CC8:  MOVFF  8E6,8F6
0CCC:  MOVFF  8E9,8F7
0CD0:  MOVLB  0
0CD2:  CALL   04C2
0CD6:  MOVFF  01,8D8
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0CDA:  MOVLB  8
0CDC:  MOVF   xD7,W
0CDE:  SUBLW  0B
0CE0:  BTFSS  FD8.2
0CE2:  BRA    0DF8
0CE4:  MOVF   xD8,W
0CE6:  SUBLW  1F
0CE8:  BTFSC  FD8.2
0CEA:  BRA    0DF8
0CEC:  MOVF   xD8,W
0CEE:  SUBLW  0F
0CF0:  BTFSC  FD8.2
0CF2:  BRA    0DF8
....................             { 
....................                j=i; 
0CF4:  MOVFF  8D4,8D6
0CF8:  MOVFF  8D3,8D5
....................                CRC=1; 
0CFC:  MOVLW  01
0CFE:  MOVWF  xDA
....................                temp2=temp; 
0D00:  MOVFF  8D7,8D9
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0D04:  MOVF   xD9,W
0D06:  SUBLW  1F
0D08:  BZ    0DE4
0D0A:  MOVF   xD6,W
0D0C:  SUBLW  01
0D0E:  BNC   0DE4
0D10:  BNZ   0D18
0D12:  MOVF   xD5,W
0D14:  SUBLW  F3
0D16:  BNC   0DE4
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0D18:  CLRF   xDB
0D1A:  MOVFF  8D6,8DD
0D1E:  MOVFF  8D5,8DC
0D22:  MOVFF  8D2,8DF
0D26:  MOVFF  8D1,8DE
0D2A:  MOVLB  0
0D2C:  RCALL  06D8
0D2E:  MOVF   01,W
0D30:  MOVLB  8
0D32:  ANDWF  xDA,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0D34:  MOVLW  04
0D36:  ADDWF  xD5,W
0D38:  MOVWF  xDB
0D3A:  MOVLW  00
0D3C:  ADDWFC xD6,W
0D3E:  MOVWF  xDC
0D40:  MOVF   xD1,W
0D42:  ADDWF  xDB,W
0D44:  MOVWF  FE9
0D46:  MOVF   xD2,W
0D48:  ADDWFC xDC,W
0D4A:  MOVWF  FEA
0D4C:  MOVFF  FEF,8DD
0D50:  MOVLW  03
0D52:  ADDWF  xD5,W
0D54:  MOVWF  xDE
0D56:  MOVLW  00
0D58:  ADDWFC xD6,W
0D5A:  MOVWF  xDF
0D5C:  MOVF   xD1,W
0D5E:  ADDWF  xDE,W
0D60:  MOVWF  FE9
0D62:  MOVF   xD2,W
0D64:  ADDWFC xDF,W
0D66:  MOVWF  FEA
0D68:  MOVFF  FEF,8E0
0D6C:  MOVLW  02
0D6E:  ADDWF  xD5,W
0D70:  MOVWF  xE1
0D72:  MOVLW  00
0D74:  ADDWFC xD6,W
0D76:  MOVWF  xE2
0D78:  MOVF   xD1,W
0D7A:  ADDWF  xE1,W
0D7C:  MOVWF  FE9
0D7E:  MOVF   xD2,W
0D80:  ADDWFC xE2,W
0D82:  MOVWF  FEA
0D84:  MOVFF  FEF,8E3
0D88:  MOVLW  01
0D8A:  ADDWF  xD5,W
0D8C:  MOVWF  xE4
0D8E:  MOVLW  00
0D90:  ADDWFC xD6,W
0D92:  MOVWF  xE5
0D94:  MOVF   xD1,W
0D96:  ADDWF  xE4,W
0D98:  MOVWF  FE9
0D9A:  MOVF   xD2,W
0D9C:  ADDWFC xE5,W
0D9E:  MOVWF  FEA
0DA0:  MOVFF  FEF,8E6
0DA4:  MOVF   xD1,W
0DA6:  ADDWF  xD5,W
0DA8:  MOVWF  FE9
0DAA:  MOVF   xD2,W
0DAC:  ADDWFC xD6,W
0DAE:  MOVWF  FEA
0DB0:  MOVFF  FEF,8E7
0DB4:  CLRF   xF0
0DB6:  CLRF   xF1
0DB8:  CLRF   xF2
0DBA:  MOVFF  8DD,8F3
0DBE:  MOVFF  8E0,8F4
0DC2:  MOVFF  8E3,8F5
0DC6:  MOVFF  8E6,8F6
0DCA:  MOVFF  8E7,8F7
0DCE:  MOVLB  0
0DD0:  CALL   04C2
0DD4:  MOVFF  01,8D9
....................                   j=j+5; 
0DD8:  MOVLW  05
0DDA:  MOVLB  8
0DDC:  ADDWF  xD5,F
0DDE:  MOVLW  00
0DE0:  ADDWFC xD6,F
....................                } 
0DE2:  BRA    0D04
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0DE4:  DECFSZ xDA,W
0DE6:  BRA    0DF8
....................                { 
....................                   dir=0; 
0DE8:  MOVLB  6
0DEA:  CLRF   xAC
....................                   return i; 
0DEC:  MOVLB  8
0DEE:  MOVFF  8D3,01
0DF2:  MOVFF  8D4,02
0DF6:  BRA    1416
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0DF8:  INCF   xD3,F
0DFA:  BTFSC  FD8.2
0DFC:  INCF   xD4,F
0DFE:  BRA    0826
....................    for(i=end_point;i>end_point/4;i--) 
0E00:  MOVFF  8D0,8D4
0E04:  MOVFF  8CF,8D3
0E08:  RRCF   xD0,W
0E0A:  MOVWF  03
0E0C:  RRCF   xCF,W
0E0E:  MOVWF  02
0E10:  RRCF   03,F
0E12:  RRCF   02,F
0E14:  MOVLW  3F
0E16:  ANDWF  03,F
0E18:  MOVFF  02,01
0E1C:  MOVF   03,W
0E1E:  SUBWF  xD4,W
0E20:  BTFSS  FD8.0
0E22:  BRA    1410
0E24:  BNZ   0E2E
0E26:  MOVF   xD3,W
0E28:  SUBWF  01,W
0E2A:  BTFSC  FD8.0
0E2C:  BRA    1410
....................    { 
....................       if(track==0) 
0E2E:  MOVF   xCE,F
0E30:  BTFSS  FD8.2
0E32:  BRA    1186
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
0E34:  MOVLW  06
0E36:  SUBWF  xD3,W
0E38:  MOVWF  xDB
0E3A:  MOVLW  00
0E3C:  SUBWFB xD4,W
0E3E:  MOVWF  xDC
0E40:  MOVF   xD1,W
0E42:  ADDWF  xDB,W
0E44:  MOVWF  FE9
0E46:  MOVF   xD2,W
0E48:  ADDWFC xDC,W
0E4A:  MOVWF  FEA
0E4C:  MOVFF  FEF,8DD
0E50:  MOVLW  05
0E52:  SUBWF  xD3,W
0E54:  MOVWF  xDE
0E56:  MOVLW  00
0E58:  SUBWFB xD4,W
0E5A:  MOVWF  xDF
0E5C:  MOVF   xD1,W
0E5E:  ADDWF  xDE,W
0E60:  MOVWF  FE9
0E62:  MOVF   xD2,W
0E64:  ADDWFC xDF,W
0E66:  MOVWF  FEA
0E68:  MOVFF  FEF,8E0
0E6C:  MOVLW  04
0E6E:  SUBWF  xD3,W
0E70:  MOVWF  xE1
0E72:  MOVLW  00
0E74:  SUBWFB xD4,W
0E76:  MOVWF  xE2
0E78:  MOVF   xD1,W
0E7A:  ADDWF  xE1,W
0E7C:  MOVWF  FE9
0E7E:  MOVF   xD2,W
0E80:  ADDWFC xE2,W
0E82:  MOVWF  FEA
0E84:  MOVFF  FEF,8E3
0E88:  MOVLW  03
0E8A:  SUBWF  xD3,W
0E8C:  MOVWF  xE4
0E8E:  MOVLW  00
0E90:  SUBWFB xD4,W
0E92:  MOVWF  xE5
0E94:  MOVF   xD1,W
0E96:  ADDWF  xE4,W
0E98:  MOVWF  FE9
0E9A:  MOVF   xD2,W
0E9C:  ADDWFC xE5,W
0E9E:  MOVWF  FEA
0EA0:  MOVFF  FEF,8E6
0EA4:  MOVLW  02
0EA6:  SUBWF  xD3,W
0EA8:  MOVWF  xE7
0EAA:  MOVLW  00
0EAC:  SUBWFB xD4,W
0EAE:  MOVWF  xE8
0EB0:  MOVF   xD1,W
0EB2:  ADDWF  xE7,W
0EB4:  MOVWF  FE9
0EB6:  MOVF   xD2,W
0EB8:  ADDWFC xE8,W
0EBA:  MOVWF  FEA
0EBC:  MOVFF  FEF,8E9
0EC0:  MOVLW  01
0EC2:  SUBWF  xD3,W
0EC4:  MOVWF  xEA
0EC6:  MOVLW  00
0EC8:  SUBWFB xD4,W
0ECA:  MOVWF  xEB
0ECC:  MOVF   xD1,W
0ECE:  ADDWF  xEA,W
0ED0:  MOVWF  FE9
0ED2:  MOVF   xD2,W
0ED4:  ADDWFC xEB,W
0ED6:  MOVWF  FEA
0ED8:  MOVFF  FEF,8EC
0EDC:  MOVF   xD1,W
0EDE:  ADDWF  xD3,W
0EE0:  MOVWF  FE9
0EE2:  MOVF   xD2,W
0EE4:  ADDWFC xD4,W
0EE6:  MOVWF  FEA
0EE8:  MOVFF  FEF,8ED
0EEC:  CLRF   xF0
0EEE:  MOVFF  8DD,8F1
0EF2:  MOVFF  8E0,8F2
0EF6:  MOVFF  8E3,8F3
0EFA:  MOVFF  8E6,8F4
0EFE:  MOVFF  8E9,8F5
0F02:  MOVFF  8EC,8F6
0F06:  MOVFF  8ED,8F7
0F0A:  MOVLB  0
0F0C:  CALL   04C2
0F10:  MOVFF  01,8D7
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
0F14:  MOVLW  0D
0F16:  MOVLB  8
0F18:  SUBWF  xD3,W
0F1A:  MOVWF  xDB
0F1C:  MOVLW  00
0F1E:  SUBWFB xD4,W
0F20:  MOVWF  xDC
0F22:  MOVF   xD1,W
0F24:  ADDWF  xDB,W
0F26:  MOVWF  FE9
0F28:  MOVF   xD2,W
0F2A:  ADDWFC xDC,W
0F2C:  MOVWF  FEA
0F2E:  MOVFF  FEF,8DD
0F32:  MOVLW  0C
0F34:  SUBWF  xD3,W
0F36:  MOVWF  xDE
0F38:  MOVLW  00
0F3A:  SUBWFB xD4,W
0F3C:  MOVWF  xDF
0F3E:  MOVF   xD1,W
0F40:  ADDWF  xDE,W
0F42:  MOVWF  FE9
0F44:  MOVF   xD2,W
0F46:  ADDWFC xDF,W
0F48:  MOVWF  FEA
0F4A:  MOVFF  FEF,8E0
0F4E:  MOVLW  0B
0F50:  SUBWF  xD3,W
0F52:  MOVWF  xE1
0F54:  MOVLW  00
0F56:  SUBWFB xD4,W
0F58:  MOVWF  xE2
0F5A:  MOVF   xD1,W
0F5C:  ADDWF  xE1,W
0F5E:  MOVWF  FE9
0F60:  MOVF   xD2,W
0F62:  ADDWFC xE2,W
0F64:  MOVWF  FEA
0F66:  MOVFF  FEF,8E3
0F6A:  MOVLW  0A
0F6C:  SUBWF  xD3,W
0F6E:  MOVWF  xE4
0F70:  MOVLW  00
0F72:  SUBWFB xD4,W
0F74:  MOVWF  xE5
0F76:  MOVF   xD1,W
0F78:  ADDWF  xE4,W
0F7A:  MOVWF  FE9
0F7C:  MOVF   xD2,W
0F7E:  ADDWFC xE5,W
0F80:  MOVWF  FEA
0F82:  MOVFF  FEF,8E6
0F86:  MOVLW  09
0F88:  SUBWF  xD3,W
0F8A:  MOVWF  xE7
0F8C:  MOVLW  00
0F8E:  SUBWFB xD4,W
0F90:  MOVWF  xE8
0F92:  MOVF   xD1,W
0F94:  ADDWF  xE7,W
0F96:  MOVWF  FE9
0F98:  MOVF   xD2,W
0F9A:  ADDWFC xE8,W
0F9C:  MOVWF  FEA
0F9E:  MOVFF  FEF,8E9
0FA2:  MOVLW  08
0FA4:  SUBWF  xD3,W
0FA6:  MOVWF  xEA
0FA8:  MOVLW  00
0FAA:  SUBWFB xD4,W
0FAC:  MOVWF  xEB
0FAE:  MOVF   xD1,W
0FB0:  ADDWF  xEA,W
0FB2:  MOVWF  FE9
0FB4:  MOVF   xD2,W
0FB6:  ADDWFC xEB,W
0FB8:  MOVWF  FEA
0FBA:  MOVFF  FEF,8EC
0FBE:  MOVLW  07
0FC0:  SUBWF  xD3,W
0FC2:  MOVWF  xED
0FC4:  MOVLW  00
0FC6:  SUBWFB xD4,W
0FC8:  MOVWF  xEE
0FCA:  MOVF   xD1,W
0FCC:  ADDWF  xED,W
0FCE:  MOVWF  FE9
0FD0:  MOVF   xD2,W
0FD2:  ADDWFC xEE,W
0FD4:  MOVWF  FEA
0FD6:  MOVFF  FEF,8EF
0FDA:  CLRF   xF0
0FDC:  MOVFF  8DD,8F1
0FE0:  MOVFF  8E0,8F2
0FE4:  MOVFF  8E3,8F3
0FE8:  MOVFF  8E6,8F4
0FEC:  MOVFF  8E9,8F5
0FF0:  MOVFF  8EC,8F6
0FF4:  MOVFF  8EF,8F7
0FF8:  MOVLB  0
0FFA:  CALL   04C2
0FFE:  MOVFF  01,8D8
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
1002:  MOVLB  8
1004:  MOVF   xD7,W
1006:  SUBLW  45
1008:  BTFSS  FD8.2
100A:  BRA    1184
100C:  MOVF   xD8,W
100E:  SUBLW  7C
1010:  BTFSC  FD8.2
1012:  BRA    1184
1014:  MOVF   xD8,W
1016:  SUBLW  3E
1018:  BTFSC  FD8.2
101A:  BRA    1184
101C:  MOVF   xD8,W
101E:  SUBLW  1F
1020:  BTFSC  FD8.2
1022:  BRA    1184
1024:  MOVF   xD8,W
1026:  SUBLW  0F
1028:  BTFSC  FD8.2
102A:  BRA    1184
102C:  MOVF   xD8,W
102E:  SUBLW  78
1030:  BTFSC  FD8.2
1032:  BRA    1184
....................          { 
....................             j=i; 
1034:  MOVFF  8D4,8D6
1038:  MOVFF  8D3,8D5
....................             CRC=1; 
103C:  MOVLW  01
103E:  MOVWF  xDA
....................             temp2=temp; 
1040:  MOVFF  8D7,8D9
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
1044:  MOVF   xD9,W
1046:  SUBLW  1F
1048:  BTFSC  FD8.2
104A:  BRA    1164
104C:  MOVF   xD6,F
104E:  BNZ   1058
1050:  MOVF   xD5,W
1052:  SUBLW  01
1054:  BTFSC  FD8.0
1056:  BRA    1164
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1058:  MOVLW  01
105A:  MOVWF  xDB
105C:  MOVFF  8D6,8DD
1060:  MOVFF  8D5,8DC
1064:  MOVFF  8D2,8DF
1068:  MOVFF  8D1,8DE
106C:  MOVLB  0
106E:  CALL   0528
1072:  MOVF   01,W
1074:  MOVLB  8
1076:  ANDWF  xDA,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1078:  MOVLW  06
107A:  SUBWF  xD5,W
107C:  MOVWF  xDB
107E:  MOVLW  00
1080:  SUBWFB xD6,W
1082:  MOVWF  xDC
1084:  MOVF   xD1,W
1086:  ADDWF  xDB,W
1088:  MOVWF  FE9
108A:  MOVF   xD2,W
108C:  ADDWFC xDC,W
108E:  MOVWF  FEA
1090:  MOVFF  FEF,8DD
1094:  MOVLW  05
1096:  SUBWF  xD5,W
1098:  MOVWF  xDE
109A:  MOVLW  00
109C:  SUBWFB xD6,W
109E:  MOVWF  xDF
10A0:  MOVF   xD1,W
10A2:  ADDWF  xDE,W
10A4:  MOVWF  FE9
10A6:  MOVF   xD2,W
10A8:  ADDWFC xDF,W
10AA:  MOVWF  FEA
10AC:  MOVFF  FEF,8E0
10B0:  MOVLW  04
10B2:  SUBWF  xD5,W
10B4:  MOVWF  xE1
10B6:  MOVLW  00
10B8:  SUBWFB xD6,W
10BA:  MOVWF  xE2
10BC:  MOVF   xD1,W
10BE:  ADDWF  xE1,W
10C0:  MOVWF  FE9
10C2:  MOVF   xD2,W
10C4:  ADDWFC xE2,W
10C6:  MOVWF  FEA
10C8:  MOVFF  FEF,8E3
10CC:  MOVLW  03
10CE:  SUBWF  xD5,W
10D0:  MOVWF  xE4
10D2:  MOVLW  00
10D4:  SUBWFB xD6,W
10D6:  MOVWF  xE5
10D8:  MOVF   xD1,W
10DA:  ADDWF  xE4,W
10DC:  MOVWF  FE9
10DE:  MOVF   xD2,W
10E0:  ADDWFC xE5,W
10E2:  MOVWF  FEA
10E4:  MOVFF  FEF,8E6
10E8:  MOVLW  02
10EA:  SUBWF  xD5,W
10EC:  MOVWF  xE7
10EE:  MOVLW  00
10F0:  SUBWFB xD6,W
10F2:  MOVWF  xE8
10F4:  MOVF   xD1,W
10F6:  ADDWF  xE7,W
10F8:  MOVWF  FE9
10FA:  MOVF   xD2,W
10FC:  ADDWFC xE8,W
10FE:  MOVWF  FEA
1100:  MOVFF  FEF,8E9
1104:  MOVLW  01
1106:  SUBWF  xD5,W
1108:  MOVWF  xEA
110A:  MOVLW  00
110C:  SUBWFB xD6,W
110E:  MOVWF  xEB
1110:  MOVF   xD1,W
1112:  ADDWF  xEA,W
1114:  MOVWF  FE9
1116:  MOVF   xD2,W
1118:  ADDWFC xEB,W
111A:  MOVWF  FEA
111C:  MOVFF  FEF,8EC
1120:  MOVF   xD1,W
1122:  ADDWF  xD5,W
1124:  MOVWF  FE9
1126:  MOVF   xD2,W
1128:  ADDWFC xD6,W
112A:  MOVWF  FEA
112C:  MOVFF  FEF,8ED
1130:  CLRF   xF0
1132:  MOVFF  8DD,8F1
1136:  MOVFF  8E0,8F2
113A:  MOVFF  8E3,8F3
113E:  MOVFF  8E6,8F4
1142:  MOVFF  8E9,8F5
1146:  MOVFF  8EC,8F6
114A:  MOVFF  8ED,8F7
114E:  MOVLB  0
1150:  CALL   04C2
1154:  MOVFF  01,8D9
....................                j=j-7;             
1158:  MOVLW  07
115A:  MOVLB  8
115C:  SUBWF  xD5,F
115E:  MOVLW  00
1160:  SUBWFB xD6,F
....................              } 
1162:  BRA    1044
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
1164:  DECFSZ xDA,W
1166:  BRA    117C
....................             { 
....................                dir=1; 
1168:  MOVLW  01
116A:  MOVLB  6
116C:  MOVWF  xAC
....................                return i; 
116E:  MOVLB  8
1170:  MOVFF  8D3,01
1174:  MOVFF  8D4,02
1178:  BRA    1416
....................             } 
....................             else return 0; 
117A:  BRA    1184
117C:  MOVLW  00
117E:  MOVWF  01
1180:  MOVWF  02
1182:  BRA    1416
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
1184:  BRA    1406
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1186:  MOVLW  04
1188:  SUBWF  xD3,W
118A:  MOVWF  xDB
118C:  MOVLW  00
118E:  SUBWFB xD4,W
1190:  MOVWF  xDC
1192:  MOVF   xD1,W
1194:  ADDWF  xDB,W
1196:  MOVWF  FE9
1198:  MOVF   xD2,W
119A:  ADDWFC xDC,W
119C:  MOVWF  FEA
119E:  MOVFF  FEF,8DD
11A2:  MOVLW  03
11A4:  SUBWF  xD3,W
11A6:  MOVWF  xDE
11A8:  MOVLW  00
11AA:  SUBWFB xD4,W
11AC:  MOVWF  xDF
11AE:  MOVF   xD1,W
11B0:  ADDWF  xDE,W
11B2:  MOVWF  FE9
11B4:  MOVF   xD2,W
11B6:  ADDWFC xDF,W
11B8:  MOVWF  FEA
11BA:  MOVFF  FEF,8E0
11BE:  MOVLW  02
11C0:  SUBWF  xD3,W
11C2:  MOVWF  xE1
11C4:  MOVLW  00
11C6:  SUBWFB xD4,W
11C8:  MOVWF  xE2
11CA:  MOVF   xD1,W
11CC:  ADDWF  xE1,W
11CE:  MOVWF  FE9
11D0:  MOVF   xD2,W
11D2:  ADDWFC xE2,W
11D4:  MOVWF  FEA
11D6:  MOVFF  FEF,8E3
11DA:  MOVLW  01
11DC:  SUBWF  xD3,W
11DE:  MOVWF  xE4
11E0:  MOVLW  00
11E2:  SUBWFB xD4,W
11E4:  MOVWF  xE5
11E6:  MOVF   xD1,W
11E8:  ADDWF  xE4,W
11EA:  MOVWF  FE9
11EC:  MOVF   xD2,W
11EE:  ADDWFC xE5,W
11F0:  MOVWF  FEA
11F2:  MOVFF  FEF,8E6
11F6:  MOVF   xD1,W
11F8:  ADDWF  xD3,W
11FA:  MOVWF  FE9
11FC:  MOVF   xD2,W
11FE:  ADDWFC xD4,W
1200:  MOVWF  FEA
1202:  MOVFF  FEF,8E7
1206:  CLRF   xF0
1208:  CLRF   xF1
120A:  CLRF   xF2
120C:  MOVFF  8DD,8F3
1210:  MOVFF  8E0,8F4
1214:  MOVFF  8E3,8F5
1218:  MOVFF  8E6,8F6
121C:  MOVFF  8E7,8F7
1220:  MOVLB  0
1222:  CALL   04C2
1226:  MOVFF  01,8D7
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
122A:  MOVLW  09
122C:  MOVLB  8
122E:  SUBWF  xD3,W
1230:  MOVWF  xDB
1232:  MOVLW  00
1234:  SUBWFB xD4,W
1236:  MOVWF  xDC
1238:  MOVF   xD1,W
123A:  ADDWF  xDB,W
123C:  MOVWF  FE9
123E:  MOVF   xD2,W
1240:  ADDWFC xDC,W
1242:  MOVWF  FEA
1244:  MOVFF  FEF,8DD
1248:  MOVLW  08
124A:  SUBWF  xD3,W
124C:  MOVWF  xDE
124E:  MOVLW  00
1250:  SUBWFB xD4,W
1252:  MOVWF  xDF
1254:  MOVF   xD1,W
1256:  ADDWF  xDE,W
1258:  MOVWF  FE9
125A:  MOVF   xD2,W
125C:  ADDWFC xDF,W
125E:  MOVWF  FEA
1260:  MOVFF  FEF,8E0
1264:  MOVLW  07
1266:  SUBWF  xD3,W
1268:  MOVWF  xE1
126A:  MOVLW  00
126C:  SUBWFB xD4,W
126E:  MOVWF  xE2
1270:  MOVF   xD1,W
1272:  ADDWF  xE1,W
1274:  MOVWF  FE9
1276:  MOVF   xD2,W
1278:  ADDWFC xE2,W
127A:  MOVWF  FEA
127C:  MOVFF  FEF,8E3
1280:  MOVLW  06
1282:  SUBWF  xD3,W
1284:  MOVWF  xE4
1286:  MOVLW  00
1288:  SUBWFB xD4,W
128A:  MOVWF  xE5
128C:  MOVF   xD1,W
128E:  ADDWF  xE4,W
1290:  MOVWF  FE9
1292:  MOVF   xD2,W
1294:  ADDWFC xE5,W
1296:  MOVWF  FEA
1298:  MOVFF  FEF,8E6
129C:  MOVLW  05
129E:  SUBWF  xD3,W
12A0:  MOVWF  xE7
12A2:  MOVLW  00
12A4:  SUBWFB xD4,W
12A6:  MOVWF  xE8
12A8:  MOVF   xD1,W
12AA:  ADDWF  xE7,W
12AC:  MOVWF  FE9
12AE:  MOVF   xD2,W
12B0:  ADDWFC xE8,W
12B2:  MOVWF  FEA
12B4:  MOVFF  FEF,8E9
12B8:  CLRF   xF0
12BA:  CLRF   xF1
12BC:  CLRF   xF2
12BE:  MOVFF  8DD,8F3
12C2:  MOVFF  8E0,8F4
12C6:  MOVFF  8E3,8F5
12CA:  MOVFF  8E6,8F6
12CE:  MOVFF  8E9,8F7
12D2:  MOVLB  0
12D4:  CALL   04C2
12D8:  MOVFF  01,8D8
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
12DC:  MOVLB  8
12DE:  MOVF   xD7,W
12E0:  SUBLW  0B
12E2:  BTFSS  FD8.2
12E4:  BRA    1406
12E6:  MOVF   xD8,W
12E8:  SUBLW  1F
12EA:  BTFSC  FD8.2
12EC:  BRA    1406
12EE:  MOVF   xD8,W
12F0:  SUBLW  0F
12F2:  BTFSC  FD8.2
12F4:  BRA    1406
....................             { 
....................                j=i; 
12F6:  MOVFF  8D4,8D6
12FA:  MOVFF  8D3,8D5
....................                CRC=1; 
12FE:  MOVLW  01
1300:  MOVWF  xDA
....................                temp2=temp; 
1302:  MOVFF  8D7,8D9
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
1306:  MOVF   xD9,W
1308:  SUBLW  1F
130A:  BZ    13E6
130C:  MOVF   xD6,F
130E:  BNZ   1316
1310:  MOVF   xD5,W
1312:  SUBLW  01
1314:  BC    13E6
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1316:  MOVLW  01
1318:  MOVWF  xDB
131A:  MOVFF  8D6,8DD
131E:  MOVFF  8D5,8DC
1322:  MOVFF  8D2,8DF
1326:  MOVFF  8D1,8DE
132A:  MOVLB  0
132C:  CALL   06D8
1330:  MOVF   01,W
1332:  MOVLB  8
1334:  ANDWF  xDA,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1336:  MOVLW  04
1338:  SUBWF  xD5,W
133A:  MOVWF  xDB
133C:  MOVLW  00
133E:  SUBWFB xD6,W
1340:  MOVWF  xDC
1342:  MOVF   xD1,W
1344:  ADDWF  xDB,W
1346:  MOVWF  FE9
1348:  MOVF   xD2,W
134A:  ADDWFC xDC,W
134C:  MOVWF  FEA
134E:  MOVFF  FEF,8DD
1352:  MOVLW  03
1354:  SUBWF  xD5,W
1356:  MOVWF  xDE
1358:  MOVLW  00
135A:  SUBWFB xD6,W
135C:  MOVWF  xDF
135E:  MOVF   xD1,W
1360:  ADDWF  xDE,W
1362:  MOVWF  FE9
1364:  MOVF   xD2,W
1366:  ADDWFC xDF,W
1368:  MOVWF  FEA
136A:  MOVFF  FEF,8E0
136E:  MOVLW  02
1370:  SUBWF  xD5,W
1372:  MOVWF  xE1
1374:  MOVLW  00
1376:  SUBWFB xD6,W
1378:  MOVWF  xE2
137A:  MOVF   xD1,W
137C:  ADDWF  xE1,W
137E:  MOVWF  FE9
1380:  MOVF   xD2,W
1382:  ADDWFC xE2,W
1384:  MOVWF  FEA
1386:  MOVFF  FEF,8E3
138A:  MOVLW  01
138C:  SUBWF  xD5,W
138E:  MOVWF  xE4
1390:  MOVLW  00
1392:  SUBWFB xD6,W
1394:  MOVWF  xE5
1396:  MOVF   xD1,W
1398:  ADDWF  xE4,W
139A:  MOVWF  FE9
139C:  MOVF   xD2,W
139E:  ADDWFC xE5,W
13A0:  MOVWF  FEA
13A2:  MOVFF  FEF,8E6
13A6:  MOVF   xD1,W
13A8:  ADDWF  xD5,W
13AA:  MOVWF  FE9
13AC:  MOVF   xD2,W
13AE:  ADDWFC xD6,W
13B0:  MOVWF  FEA
13B2:  MOVFF  FEF,8E7
13B6:  CLRF   xF0
13B8:  CLRF   xF1
13BA:  CLRF   xF2
13BC:  MOVFF  8DD,8F3
13C0:  MOVFF  8E0,8F4
13C4:  MOVFF  8E3,8F5
13C8:  MOVFF  8E6,8F6
13CC:  MOVFF  8E7,8F7
13D0:  MOVLB  0
13D2:  CALL   04C2
13D6:  MOVFF  01,8D9
....................                   j=j-5; 
13DA:  MOVLW  05
13DC:  MOVLB  8
13DE:  SUBWF  xD5,F
13E0:  MOVLW  00
13E2:  SUBWFB xD6,F
....................                } 
13E4:  BRA    1306
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
13E6:  DECFSZ xDA,W
13E8:  BRA    13FE
....................                { 
....................                   dir=1; 
13EA:  MOVLW  01
13EC:  MOVLB  6
13EE:  MOVWF  xAC
....................                   return i; 
13F0:  MOVLB  8
13F2:  MOVFF  8D3,01
13F6:  MOVFF  8D4,02
13FA:  BRA    1416
....................                } 
....................                   else return 0; 
13FC:  BRA    1406
13FE:  MOVLW  00
1400:  MOVWF  01
1402:  MOVWF  02
1404:  BRA    1416
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
1406:  MOVF   xD3,W
1408:  BTFSC  FD8.2
140A:  DECF   xD4,F
140C:  DECF   xD3,F
140E:  BRA    0E08
....................    return 0; 
1410:  MOVLW  00
1412:  MOVWF  01
1414:  MOVWF  02
.................... } 
1416:  MOVLB  0
1418:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
347E:  MOVLB  8
3480:  CLRF   xCD
3482:  MOVLW  01
3484:  MOVWF  xCC
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3486:  MOVFF  8C2,8CE
348A:  MOVFF  8C4,8D0
348E:  MOVFF  8C3,8CF
3492:  MOVFF  8C6,8D2
3496:  MOVFF  8C5,8D1
349A:  MOVLB  0
349C:  CALL   0818
34A0:  MOVFF  02,8CD
34A4:  MOVFF  01,8CC
....................    if(temp==0) return 0; 
34A8:  MOVLB  8
34AA:  MOVF   xCC,F
34AC:  BNZ   34B8
34AE:  MOVF   xCD,F
34B0:  BNZ   34B8
34B2:  MOVLW  00
34B4:  MOVWF  01
34B6:  BRA    3862
....................    j=temp; 
34B8:  MOVFF  8CD,8CB
34BC:  MOVFF  8CC,8CA
....................    if(dir==0) 
34C0:  MOVLB  6
34C2:  MOVF   xAC,F
34C4:  BTFSS  FD8.2
34C6:  BRA    3682
....................    { 
....................       if(track==0) 
34C8:  MOVLB  8
34CA:  MOVF   xC2,F
34CC:  BTFSS  FD8.2
34CE:  BRA    35C6
....................       { 
....................             for(i=0;i<79;i++) 
34D0:  CLRF   xC9
34D2:  MOVF   xC9,W
34D4:  SUBLW  4E
34D6:  BNC   35C4
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
34D8:  CLRF   03
34DA:  MOVF   xC9,W
34DC:  ADDWF  xC7,W
34DE:  MOVWF  01
34E0:  MOVF   xC8,W
34E2:  ADDWFC 03,F
34E4:  MOVFF  01,8CE
34E8:  MOVFF  03,8CF
34EC:  MOVLW  05
34EE:  ADDWF  xCA,W
34F0:  MOVWF  xD0
34F2:  MOVLW  00
34F4:  ADDWFC xCB,W
34F6:  MOVWF  xD1
34F8:  MOVF   xC5,W
34FA:  ADDWF  xD0,W
34FC:  MOVWF  FE9
34FE:  MOVF   xC6,W
3500:  ADDWFC xD1,W
3502:  MOVWF  FEA
3504:  MOVFF  FEF,8D2
3508:  MOVLW  04
350A:  ADDWF  xCA,W
350C:  MOVWF  xD3
350E:  MOVLW  00
3510:  ADDWFC xCB,W
3512:  MOVWF  xD4
3514:  MOVF   xC5,W
3516:  ADDWF  xD3,W
3518:  MOVWF  FE9
351A:  MOVF   xC6,W
351C:  ADDWFC xD4,W
351E:  MOVWF  FEA
3520:  MOVFF  FEF,8D5
3524:  MOVLW  03
3526:  ADDWF  xCA,W
3528:  MOVWF  xD6
352A:  MOVLW  00
352C:  ADDWFC xCB,W
352E:  MOVWF  xD7
3530:  MOVF   xC5,W
3532:  ADDWF  xD6,W
3534:  MOVWF  FE9
3536:  MOVF   xC6,W
3538:  ADDWFC xD7,W
353A:  MOVWF  FEA
353C:  MOVFF  FEF,8D8
3540:  MOVLW  02
3542:  ADDWF  xCA,W
3544:  MOVWF  xD9
3546:  MOVLW  00
3548:  ADDWFC xCB,W
354A:  MOVWF  xDA
354C:  MOVF   xC5,W
354E:  ADDWF  xD9,W
3550:  MOVWF  FE9
3552:  MOVF   xC6,W
3554:  ADDWFC xDA,W
3556:  MOVWF  FEA
3558:  MOVFF  FEF,8DB
355C:  MOVLW  01
355E:  ADDWF  xCA,W
3560:  MOVWF  xDC
3562:  MOVLW  00
3564:  ADDWFC xCB,W
3566:  MOVWF  xDD
3568:  MOVF   xC5,W
356A:  ADDWF  xDC,W
356C:  MOVWF  FE9
356E:  MOVF   xC6,W
3570:  ADDWFC xDD,W
3572:  MOVWF  FEA
3574:  MOVFF  FEF,8DE
3578:  MOVF   xC5,W
357A:  ADDWF  xCA,W
357C:  MOVWF  FE9
357E:  MOVF   xC6,W
3580:  ADDWFC xCB,W
3582:  MOVWF  FEA
3584:  MOVFF  FEF,8DF
3588:  CLRF   xF0
358A:  CLRF   xF1
358C:  MOVFF  8D2,8F2
3590:  MOVFF  8D5,8F3
3594:  MOVFF  8D8,8F4
3598:  MOVFF  8DB,8F5
359C:  MOVFF  8DE,8F6
35A0:  MOVFF  8DF,8F7
35A4:  MOVLB  0
35A6:  CALL   04C2
35AA:  MOVFF  8CF,FEA
35AE:  MOVFF  8CE,FE9
35B2:  MOVFF  01,FEF
....................                j=j+7; 
35B6:  MOVLW  07
35B8:  MOVLB  8
35BA:  ADDWF  xCA,F
35BC:  MOVLW  00
35BE:  ADDWFC xCB,F
....................             } 
35C0:  INCF   xC9,F
35C2:  BRA    34D2
....................       } 
....................          else  
35C4:  BRA    367E
....................          { 
....................             for(i=0;i<40;i++) 
35C6:  CLRF   xC9
35C8:  MOVF   xC9,W
35CA:  SUBLW  27
35CC:  BNC   367E
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
35CE:  CLRF   03
35D0:  MOVF   xC9,W
35D2:  ADDWF  xC7,W
35D4:  MOVWF  01
35D6:  MOVF   xC8,W
35D8:  ADDWFC 03,F
35DA:  MOVFF  01,8CE
35DE:  MOVFF  03,8CF
35E2:  MOVLW  03
35E4:  ADDWF  xCA,W
35E6:  MOVWF  xD0
35E8:  MOVLW  00
35EA:  ADDWFC xCB,W
35EC:  MOVWF  xD1
35EE:  MOVF   xC5,W
35F0:  ADDWF  xD0,W
35F2:  MOVWF  FE9
35F4:  MOVF   xC6,W
35F6:  ADDWFC xD1,W
35F8:  MOVWF  FEA
35FA:  MOVFF  FEF,8D2
35FE:  MOVLW  02
3600:  ADDWF  xCA,W
3602:  MOVWF  xD3
3604:  MOVLW  00
3606:  ADDWFC xCB,W
3608:  MOVWF  xD4
360A:  MOVF   xC5,W
360C:  ADDWF  xD3,W
360E:  MOVWF  FE9
3610:  MOVF   xC6,W
3612:  ADDWFC xD4,W
3614:  MOVWF  FEA
3616:  MOVFF  FEF,8D5
361A:  MOVLW  01
361C:  ADDWF  xCA,W
361E:  MOVWF  xD6
3620:  MOVLW  00
3622:  ADDWFC xCB,W
3624:  MOVWF  xD7
3626:  MOVF   xC5,W
3628:  ADDWF  xD6,W
362A:  MOVWF  FE9
362C:  MOVF   xC6,W
362E:  ADDWFC xD7,W
3630:  MOVWF  FEA
3632:  MOVFF  FEF,8D8
3636:  MOVF   xC5,W
3638:  ADDWF  xCA,W
363A:  MOVWF  FE9
363C:  MOVF   xC6,W
363E:  ADDWFC xCB,W
3640:  MOVWF  FEA
3642:  MOVFF  FEF,8D9
3646:  CLRF   xF0
3648:  CLRF   xF1
364A:  CLRF   xF2
364C:  CLRF   xF3
364E:  MOVFF  8D2,8F4
3652:  MOVFF  8D5,8F5
3656:  MOVFF  8D8,8F6
365A:  MOVFF  8D9,8F7
365E:  MOVLB  0
3660:  CALL   04C2
3664:  MOVFF  8CF,FEA
3668:  MOVFF  8CE,FE9
366C:  MOVFF  01,FEF
....................                j=j+5; 
3670:  MOVLW  05
3672:  MOVLB  8
3674:  ADDWF  xCA,F
3676:  MOVLW  00
3678:  ADDWFC xCB,F
....................             }          
367A:  INCF   xC9,F
367C:  BRA    35C8
....................          } 
....................    } 
....................       else  
367E:  BRA    3838
3680:  MOVLB  6
....................       { 
....................          if(track==0) 
3682:  MOVLB  8
3684:  MOVF   xC2,F
3686:  BTFSS  FD8.2
3688:  BRA    3780
....................          { 
....................             for(i=0;i<79;i++) 
368A:  CLRF   xC9
368C:  MOVF   xC9,W
368E:  SUBLW  4E
3690:  BNC   377E
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3692:  CLRF   03
3694:  MOVF   xC9,W
3696:  ADDWF  xC7,W
3698:  MOVWF  01
369A:  MOVF   xC8,W
369C:  ADDWFC 03,F
369E:  MOVFF  01,8CE
36A2:  MOVFF  03,8CF
36A6:  MOVLW  05
36A8:  SUBWF  xCA,W
36AA:  MOVWF  xD0
36AC:  MOVLW  00
36AE:  SUBWFB xCB,W
36B0:  MOVWF  xD1
36B2:  MOVF   xC5,W
36B4:  ADDWF  xD0,W
36B6:  MOVWF  FE9
36B8:  MOVF   xC6,W
36BA:  ADDWFC xD1,W
36BC:  MOVWF  FEA
36BE:  MOVFF  FEF,8D2
36C2:  MOVLW  04
36C4:  SUBWF  xCA,W
36C6:  MOVWF  xD3
36C8:  MOVLW  00
36CA:  SUBWFB xCB,W
36CC:  MOVWF  xD4
36CE:  MOVF   xC5,W
36D0:  ADDWF  xD3,W
36D2:  MOVWF  FE9
36D4:  MOVF   xC6,W
36D6:  ADDWFC xD4,W
36D8:  MOVWF  FEA
36DA:  MOVFF  FEF,8D5
36DE:  MOVLW  03
36E0:  SUBWF  xCA,W
36E2:  MOVWF  xD6
36E4:  MOVLW  00
36E6:  SUBWFB xCB,W
36E8:  MOVWF  xD7
36EA:  MOVF   xC5,W
36EC:  ADDWF  xD6,W
36EE:  MOVWF  FE9
36F0:  MOVF   xC6,W
36F2:  ADDWFC xD7,W
36F4:  MOVWF  FEA
36F6:  MOVFF  FEF,8D8
36FA:  MOVLW  02
36FC:  SUBWF  xCA,W
36FE:  MOVWF  xD9
3700:  MOVLW  00
3702:  SUBWFB xCB,W
3704:  MOVWF  xDA
3706:  MOVF   xC5,W
3708:  ADDWF  xD9,W
370A:  MOVWF  FE9
370C:  MOVF   xC6,W
370E:  ADDWFC xDA,W
3710:  MOVWF  FEA
3712:  MOVFF  FEF,8DB
3716:  MOVLW  01
3718:  SUBWF  xCA,W
371A:  MOVWF  xDC
371C:  MOVLW  00
371E:  SUBWFB xCB,W
3720:  MOVWF  xDD
3722:  MOVF   xC5,W
3724:  ADDWF  xDC,W
3726:  MOVWF  FE9
3728:  MOVF   xC6,W
372A:  ADDWFC xDD,W
372C:  MOVWF  FEA
372E:  MOVFF  FEF,8DE
3732:  MOVF   xC5,W
3734:  ADDWF  xCA,W
3736:  MOVWF  FE9
3738:  MOVF   xC6,W
373A:  ADDWFC xCB,W
373C:  MOVWF  FEA
373E:  MOVFF  FEF,8DF
3742:  CLRF   xF0
3744:  CLRF   xF1
3746:  MOVFF  8D2,8F2
374A:  MOVFF  8D5,8F3
374E:  MOVFF  8D8,8F4
3752:  MOVFF  8DB,8F5
3756:  MOVFF  8DE,8F6
375A:  MOVFF  8DF,8F7
375E:  MOVLB  0
3760:  CALL   04C2
3764:  MOVFF  8CF,FEA
3768:  MOVFF  8CE,FE9
376C:  MOVFF  01,FEF
....................                j=j-7; 
3770:  MOVLW  07
3772:  MOVLB  8
3774:  SUBWF  xCA,F
3776:  MOVLW  00
3778:  SUBWFB xCB,F
....................             } 
377A:  INCF   xC9,F
377C:  BRA    368C
....................          } 
....................             else 
377E:  BRA    3838
....................             { 
....................                for(i=0;i<40;i++) 
3780:  CLRF   xC9
3782:  MOVF   xC9,W
3784:  SUBLW  27
3786:  BNC   3838
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3788:  CLRF   03
378A:  MOVF   xC9,W
378C:  ADDWF  xC7,W
378E:  MOVWF  01
3790:  MOVF   xC8,W
3792:  ADDWFC 03,F
3794:  MOVFF  01,8CE
3798:  MOVFF  03,8CF
379C:  MOVLW  03
379E:  SUBWF  xCA,W
37A0:  MOVWF  xD0
37A2:  MOVLW  00
37A4:  SUBWFB xCB,W
37A6:  MOVWF  xD1
37A8:  MOVF   xC5,W
37AA:  ADDWF  xD0,W
37AC:  MOVWF  FE9
37AE:  MOVF   xC6,W
37B0:  ADDWFC xD1,W
37B2:  MOVWF  FEA
37B4:  MOVFF  FEF,8D2
37B8:  MOVLW  02
37BA:  SUBWF  xCA,W
37BC:  MOVWF  xD3
37BE:  MOVLW  00
37C0:  SUBWFB xCB,W
37C2:  MOVWF  xD4
37C4:  MOVF   xC5,W
37C6:  ADDWF  xD3,W
37C8:  MOVWF  FE9
37CA:  MOVF   xC6,W
37CC:  ADDWFC xD4,W
37CE:  MOVWF  FEA
37D0:  MOVFF  FEF,8D5
37D4:  MOVLW  01
37D6:  SUBWF  xCA,W
37D8:  MOVWF  xD6
37DA:  MOVLW  00
37DC:  SUBWFB xCB,W
37DE:  MOVWF  xD7
37E0:  MOVF   xC5,W
37E2:  ADDWF  xD6,W
37E4:  MOVWF  FE9
37E6:  MOVF   xC6,W
37E8:  ADDWFC xD7,W
37EA:  MOVWF  FEA
37EC:  MOVFF  FEF,8D8
37F0:  MOVF   xC5,W
37F2:  ADDWF  xCA,W
37F4:  MOVWF  FE9
37F6:  MOVF   xC6,W
37F8:  ADDWFC xCB,W
37FA:  MOVWF  FEA
37FC:  MOVFF  FEF,8D9
3800:  CLRF   xF0
3802:  CLRF   xF1
3804:  CLRF   xF2
3806:  CLRF   xF3
3808:  MOVFF  8D2,8F4
380C:  MOVFF  8D5,8F5
3810:  MOVFF  8D8,8F6
3814:  MOVFF  8D9,8F7
3818:  MOVLB  0
381A:  CALL   04C2
381E:  MOVFF  8CF,FEA
3822:  MOVFF  8CE,FE9
3826:  MOVFF  01,FEF
....................                   j=j-5; 
382A:  MOVLW  05
382C:  MOVLB  8
382E:  SUBWF  xCA,F
3830:  MOVLW  00
3832:  SUBWFB xCB,F
....................                }             
3834:  INCF   xC9,F
3836:  BRA    3782
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3838:  MOVF   xC2,F
383A:  BNZ   3850
383C:  MOVLW  52
383E:  MOVWF  xCE
3840:  MOVFF  8C6,8D0
3844:  MOVFF  8C5,8CF
3848:  MOVLB  0
384A:  RCALL  345C
....................          else del_buf(numbyteofbuffer2,datin); 
384C:  BRA    3860
384E:  MOVLB  8
3850:  MOVLW  2C
3852:  MOVWF  xCE
3854:  MOVFF  8C6,8D0
3858:  MOVFF  8C5,8CF
385C:  MOVLB  0
385E:  RCALL  345C
3860:  MOVLB  8
.................... } 
3862:  MOVLB  0
3864:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
15F2:  MOVLW  72
15F4:  MOVWF  FF6
15F6:  MOVLW  03
15F8:  MOVWF  FF7
15FA:  CALL   04A2
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
15FE:  MOVLB  8
1600:  CLRF   xC6
1602:  CLRF   xC5
1604:  MOVF   xC6,W
1606:  SUBLW  03
1608:  BNC   1638
160A:  BNZ   1612
160C:  MOVF   xC5,W
160E:  SUBLW  51
1610:  BNC   1638
1612:  MOVLW  2A
1614:  ADDWF  xC5,W
1616:  MOVWF  FE9
1618:  MOVLW  02
161A:  ADDWFC xC6,W
161C:  MOVWF  FEA
161E:  MOVFF  FEF,8C7
1622:  MOVFF  8C7,8C8
1626:  MOVLW  18
1628:  MOVWF  xC9
162A:  MOVLB  0
162C:  RCALL  152E
162E:  MOVLB  8
1630:  INCF   xC5,F
1632:  BTFSC  FD8.2
1634:  INCF   xC6,F
1636:  BRA    1604
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1638:  MOVLW  88
163A:  MOVWF  FF6
163C:  MOVLW  03
163E:  MOVWF  FF7
1640:  MOVLB  0
1642:  CALL   04A2
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1646:  MOVLB  8
1648:  CLRF   xC6
164A:  CLRF   xC5
164C:  MOVF   xC6,W
164E:  SUBLW  01
1650:  BNC   1680
1652:  BNZ   165A
1654:  MOVF   xC5,W
1656:  SUBLW  2B
1658:  BNC   1680
165A:  MOVLW  7C
165C:  ADDWF  xC5,W
165E:  MOVWF  FE9
1660:  MOVLW  05
1662:  ADDWFC xC6,W
1664:  MOVWF  FEA
1666:  MOVFF  FEF,8C7
166A:  MOVFF  8C7,8C8
166E:  MOVLW  18
1670:  MOVWF  xC9
1672:  MOVLB  0
1674:  RCALL  152E
1676:  MOVLB  8
1678:  INCF   xC5,F
167A:  BTFSC  FD8.2
167C:  INCF   xC6,F
167E:  BRA    164C
.................... } 
1680:  MOVLB  0
1682:  GOTO   1918 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
39F2:  MOVLW  01
39F4:  MOVLB  6
39F6:  MOVWF  xBC
....................    //rtc_get_date(date,mon,year,day); 
....................    //rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
39F8:  MOVLB  0
39FA:  RCALL  33E2
39FC:  MOVFF  02,8C3
3A00:  MOVFF  01,8C2
3A04:  MOVFF  02,8C5
3A08:  MOVFF  01,8C4
3A0C:  MOVLB  8
3A0E:  CLRF   xC7
3A10:  MOVLW  7C
3A12:  MOVWF  xC6
3A14:  MOVLB  0
3A16:  RCALL  343A
3A18:  MOVFF  01,8C2
3A1C:  MOVLW  96
3A1E:  MOVLB  8
3A20:  ADDWF  01,W
3A22:  MOVWF  01
3A24:  MOVLW  00
3A26:  ADDWFC 02,W
3A28:  MOVFF  01,20
3A2C:  MOVWF  21
3A2E:  CLRF   22
3A30:  CLRF   23
....................    if(datinbuf==0)  
3A32:  MOVLB  6
3A34:  MOVF   xB9,F
3A36:  BNZ   3A58
....................    { 
....................       countbit_T1=0; 
3A38:  CLRF   xAE
3A3A:  CLRF   xAD
....................       countbit_T2=0; 
3A3C:  CLRF   xB0
3A3E:  CLRF   xAF
....................       bug_countbit_T1=0; 
3A40:  CLRF   xB2
3A42:  CLRF   xB1
....................       bug_countbit_T2=0; 
3A44:  CLRF   xB4
3A46:  CLRF   xB3
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3A48:  MOVF   xBD,F
3A4A:  BNZ   3A54
3A4C:  MOVLB  0
3A4E:  SETF   xFC
3A50:  SETF   xFB
3A52:  MOVLB  6
....................       saving_flag=0; 
3A54:  CLRF   xBC
....................       return; 
3A56:  BRA    3DF0
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3A58:  MOVLW  9E
3A5A:  MOVWF  FF6
3A5C:  MOVLW  03
3A5E:  MOVWF  FF7
3A60:  MOVLB  0
3A62:  CALL   04A2
....................    key_timeout=0; 
3A66:  MOVLB  1
3A68:  CLRF   x2A
3A6A:  CLRF   x29
....................    //key_count=0; 
....................    enable_getpin=1; 
3A6C:  MOVLW  01
3A6E:  MOVWF  x2D
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3A70:  MOVFF  6AE,8C1
3A74:  MOVFF  6AD,8C0
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3A78:  MOVLB  8
3A7A:  CLRF   xC2
3A7C:  MOVFF  8C1,8C4
3A80:  MOVFF  8C0,8C3
3A84:  MOVLW  02
3A86:  MOVWF  xC6
3A88:  MOVLW  2A
3A8A:  MOVWF  xC5
3A8C:  MOVLW  01
3A8E:  MOVWF  xC8
3A90:  MOVLW  B3
3A92:  MOVWF  xC7
3A94:  MOVLB  0
3A96:  RCALL  347E
....................    countbit_T1=0; 
3A98:  MOVLB  6
3A9A:  CLRF   xAE
3A9C:  CLRF   xAD
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3A9E:  MOVFF  6B0,8C1
3AA2:  MOVFF  6AF,8C0
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3AA6:  MOVLW  01
3AA8:  MOVLB  8
3AAA:  MOVWF  xC2
3AAC:  MOVFF  8C1,8C4
3AB0:  MOVFF  8C0,8C3
3AB4:  MOVLW  05
3AB6:  MOVWF  xC6
3AB8:  MOVLW  7C
3ABA:  MOVWF  xC5
3ABC:  MOVLW  02
3ABE:  MOVWF  xC8
3AC0:  MOVWF  xC7
3AC2:  MOVLB  0
3AC4:  RCALL  347E
....................    countbit_T2=0; 
3AC6:  MOVLB  6
3AC8:  CLRF   xB0
3ACA:  CLRF   xAF
....................    saving_flag=0; 
3ACC:  CLRF   xBC
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3ACE:  MOVLW  20
3AD0:  MOVLB  1
3AD2:  ADDWF  xB3,W
3AD4:  MOVLB  8
3AD6:  MOVWF  xBF
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
3AD8:  MOVF   23,F
3ADA:  BTFSS  FD8.2
3ADC:  BRA    3DEE
3ADE:  MOVF   22,W
3AE0:  SUBLW  01
3AE2:  BTFSS  FD8.0
3AE4:  BRA    3DEE
3AE6:  BNZ   3AFA
3AE8:  MOVF   21,W
3AEA:  SUBLW  C3
3AEC:  BTFSS  FD8.0
3AEE:  BRA    3DEE
3AF0:  BNZ   3AFA
3AF2:  MOVF   20,W
3AF4:  SUBLW  0D
3AF6:  BTFSS  FD8.0
3AF8:  BRA    3DEE
3AFA:  MOVF   xBF,W
3AFC:  SUBLW  25
3AFE:  BTFSS  FD8.2
3B00:  BRA    3DEE
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3B02:  MOVFF  23,03
3B06:  MOVFF  22,02
3B0A:  MOVFF  21,01
3B0E:  MOVFF  20,00
3B12:  MOVLW  01
3B14:  ADDWF  20,F
3B16:  BTFSC  FD8.0
3B18:  INCF   21,F
3B1A:  BTFSC  FD8.2
3B1C:  INCF   22,F
3B1E:  BTFSC  FD8.2
3B20:  INCF   23,F
3B22:  MOVFF  01,8C3
3B26:  MOVFF  00,8C2
3B2A:  CLRF   xD3
3B2C:  CLRF   xD2
3B2E:  MOVFF  01,8D1
3B32:  MOVFF  00,8D0
3B36:  MOVFF  100,8D4
3B3A:  MOVLB  0
3B3C:  RCALL  3866
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3B3E:  MOVFF  23,03
3B42:  MOVFF  22,02
3B46:  MOVFF  21,01
3B4A:  MOVFF  20,00
3B4E:  MOVLW  01
3B50:  ADDWF  20,F
3B52:  BTFSC  FD8.0
3B54:  INCF   21,F
3B56:  BTFSC  FD8.2
3B58:  INCF   22,F
3B5A:  BTFSC  FD8.2
3B5C:  INCF   23,F
3B5E:  MOVFF  01,8C3
3B62:  MOVFF  00,8C2
3B66:  MOVLB  8
3B68:  CLRF   xD3
3B6A:  CLRF   xD2
3B6C:  MOVFF  01,8D1
3B70:  MOVFF  00,8D0
3B74:  MOVFF  FF,8D4
3B78:  MOVLB  0
3B7A:  RCALL  3866
....................          write_ext_eeprom((long int)ptr_card++,h); 
3B7C:  MOVFF  23,03
3B80:  MOVFF  22,02
3B84:  MOVFF  21,01
3B88:  MOVFF  20,00
3B8C:  MOVLW  01
3B8E:  ADDWF  20,F
3B90:  BTFSC  FD8.0
3B92:  INCF   21,F
3B94:  BTFSC  FD8.2
3B96:  INCF   22,F
3B98:  BTFSC  FD8.2
3B9A:  INCF   23,F
3B9C:  MOVFF  01,8C3
3BA0:  MOVFF  00,8C2
3BA4:  MOVLB  8
3BA6:  CLRF   xD3
3BA8:  CLRF   xD2
3BAA:  MOVFF  01,8D1
3BAE:  MOVFF  00,8D0
3BB2:  MOVFF  101,8D4
3BB6:  MOVLB  0
3BB8:  RCALL  3866
....................          write_ext_eeprom((long int)ptr_card++,min); 
3BBA:  MOVFF  23,03
3BBE:  MOVFF  22,02
3BC2:  MOVFF  21,01
3BC6:  MOVFF  20,00
3BCA:  MOVLW  01
3BCC:  ADDWF  20,F
3BCE:  BTFSC  FD8.0
3BD0:  INCF   21,F
3BD2:  BTFSC  FD8.2
3BD4:  INCF   22,F
3BD6:  BTFSC  FD8.2
3BD8:  INCF   23,F
3BDA:  MOVFF  01,8C3
3BDE:  MOVFF  00,8C2
3BE2:  MOVLB  8
3BE4:  CLRF   xD3
3BE6:  CLRF   xD2
3BE8:  MOVFF  01,8D1
3BEC:  MOVFF  00,8D0
3BF0:  MOVFF  102,8D4
3BF4:  MOVLB  0
3BF6:  RCALL  3866
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3BF8:  MOVFF  23,03
3BFC:  MOVFF  22,02
3C00:  MOVFF  21,01
3C04:  MOVFF  20,00
3C08:  MOVLW  01
3C0A:  ADDWF  20,F
3C0C:  BTFSC  FD8.0
3C0E:  INCF   21,F
3C10:  BTFSC  FD8.2
3C12:  INCF   22,F
3C14:  BTFSC  FD8.2
3C16:  INCF   23,F
3C18:  MOVFF  01,8C3
3C1C:  MOVFF  00,8C2
3C20:  MOVLB  8
3C22:  CLRF   xD3
3C24:  CLRF   xD2
3C26:  MOVFF  01,8D1
3C2A:  MOVFF  00,8D0
3C2E:  MOVFF  103,8D4
3C32:  MOVLB  0
3C34:  RCALL  3866
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3C36:  MOVLB  6
3C38:  CLRF   xB8
3C3A:  CLRF   xB7
3C3C:  MOVF   xB8,F
3C3E:  BNZ   3CA0
3C40:  MOVF   xB7,W
3C42:  SUBLW  4E
3C44:  BNC   3CA0
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3C46:  MOVFF  23,03
3C4A:  MOVFF  22,02
3C4E:  MOVFF  21,01
3C52:  MOVFF  20,00
3C56:  MOVLW  01
3C58:  ADDWF  20,F
3C5A:  BTFSC  FD8.0
3C5C:  INCF   21,F
3C5E:  BTFSC  FD8.2
3C60:  INCF   22,F
3C62:  BTFSC  FD8.2
3C64:  INCF   23,F
3C66:  MOVFF  01,8C3
3C6A:  MOVFF  00,8C2
3C6E:  MOVLW  B3
3C70:  ADDWF  xB7,W
3C72:  MOVWF  FE9
3C74:  MOVLW  01
3C76:  ADDWFC xB8,W
3C78:  MOVWF  FEA
3C7A:  MOVF   FEF,W
3C7C:  ANDLW  3F
3C7E:  ADDLW  20
3C80:  MOVLB  8
3C82:  MOVWF  xC4
3C84:  CLRF   xD3
3C86:  CLRF   xD2
3C88:  MOVFF  01,8D1
3C8C:  MOVFF  00,8D0
3C90:  MOVWF  xD4
3C92:  MOVLB  0
3C94:  RCALL  3866
....................              
....................          } 
3C96:  MOVLB  6
3C98:  INCF   xB7,F
3C9A:  BTFSC  FD8.2
3C9C:  INCF   xB8,F
3C9E:  BRA    3C3C
....................          del_buf(numbyteoftrack1,Track1); 
3CA0:  MOVLW  4F
3CA2:  MOVLB  8
3CA4:  MOVWF  xCE
3CA6:  MOVLW  01
3CA8:  MOVWF  xD0
3CAA:  MOVLW  B3
3CAC:  MOVWF  xCF
3CAE:  MOVLB  0
3CB0:  CALL   345C
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3CB4:  MOVLB  6
3CB6:  CLRF   xB8
3CB8:  CLRF   xB7
3CBA:  MOVF   xB8,F
3CBC:  BNZ   3D1E
3CBE:  MOVF   xB7,W
3CC0:  SUBLW  27
3CC2:  BNC   3D1E
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3CC4:  MOVFF  23,03
3CC8:  MOVFF  22,02
3CCC:  MOVFF  21,01
3CD0:  MOVFF  20,00
3CD4:  MOVLW  01
3CD6:  ADDWF  20,F
3CD8:  BTFSC  FD8.0
3CDA:  INCF   21,F
3CDC:  BTFSC  FD8.2
3CDE:  INCF   22,F
3CE0:  BTFSC  FD8.2
3CE2:  INCF   23,F
3CE4:  MOVFF  01,8C3
3CE8:  MOVFF  00,8C2
3CEC:  MOVLW  02
3CEE:  ADDWF  xB7,W
3CF0:  MOVWF  FE9
3CF2:  MOVLW  02
3CF4:  ADDWFC xB8,W
3CF6:  MOVWF  FEA
3CF8:  MOVF   FEF,W
3CFA:  ANDLW  0F
3CFC:  ADDLW  30
3CFE:  MOVLB  8
3D00:  MOVWF  xC4
3D02:  CLRF   xD3
3D04:  CLRF   xD2
3D06:  MOVFF  01,8D1
3D0A:  MOVFF  00,8D0
3D0E:  MOVWF  xD4
3D10:  MOVLB  0
3D12:  RCALL  3866
....................          }  
3D14:  MOVLB  6
3D16:  INCF   xB7,F
3D18:  BTFSC  FD8.2
3D1A:  INCF   xB8,F
3D1C:  BRA    3CBA
....................          del_buf(numbyteoftrack2,Track2); 
3D1E:  MOVLW  28
3D20:  MOVLB  8
3D22:  MOVWF  xCE
3D24:  MOVLW  02
3D26:  MOVWF  xD0
3D28:  MOVWF  xCF
3D2A:  MOVLB  0
3D2C:  CALL   345C
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
3D30:  MOVLW  0D
3D32:  MOVLB  8
3D34:  MOVWF  xE8
3D36:  MOVLB  0
3D38:  CALL   045C
3D3C:  MOVLW  0A
3D3E:  MOVLB  8
3D40:  MOVWF  xE8
3D42:  MOVLB  0
3D44:  CALL   045C
....................       fprintf(COM2,"Done"); 
3D48:  MOVLW  B4
3D4A:  MOVWF  FF6
3D4C:  MOVLW  03
3D4E:  MOVWF  FF7
3D50:  CALL   04A2
....................       if(KP_mode) 
3D54:  MOVLB  1
3D56:  MOVF   x30,F
3D58:  BZ    3D70
....................       { 
....................          printf("\n\rKey release\n\r"); 
3D5A:  MOVLW  BA
3D5C:  MOVWF  FF6
3D5E:  MOVLW  03
3D60:  MOVWF  FF7
3D62:  MOVLB  0
3D64:  CALL   04A2
....................          keyprss_off; 
3D68:  BCF    F92.7
3D6A:  BCF    F89.7
....................          kp_st=0; 
3D6C:  MOVLB  1
3D6E:  CLRF   x31
....................       }   
....................       count_kp=0xffff; 
3D70:  SETF   x33
3D72:  SETF   x32
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
3D74:  MOVLW  0D
3D76:  MOVLB  8
3D78:  MOVWF  xE8
3D7A:  MOVLB  0
3D7C:  CALL   045C
3D80:  MOVLW  0A
3D82:  MOVLB  8
3D84:  MOVWF  xE8
3D86:  MOVLB  0
3D88:  CALL   045C
....................       fprintf(COM2,"Waiting for PIN number"); 
3D8C:  MOVLW  CA
3D8E:  MOVWF  FF6
3D90:  MOVLW  03
3D92:  MOVWF  FF7
3D94:  CALL   04A2
....................       count_checking=0; 
3D98:  MOVLB  1
3D9A:  CLRF   x07
3D9C:  CLRF   x06
....................       fprintf(COM2,"\r\n"); 
3D9E:  MOVLW  0D
3DA0:  MOVLB  8
3DA2:  MOVWF  xE8
3DA4:  MOVLB  0
3DA6:  CALL   045C
3DAA:  MOVLW  0A
3DAC:  MOVLB  8
3DAE:  MOVWF  xE8
3DB0:  MOVLB  0
3DB2:  CALL   045C
....................       charac_timeout=0; 
3DB6:  CLRF   xFC
3DB8:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3DBA:  MOVFF  23,8C5
3DBE:  MOVFF  22,8C4
3DC2:  MOVFF  21,8C3
3DC6:  MOVFF  20,8C2
3DCA:  MOVLW  19
3DCC:  MOVLB  8
3DCE:  MOVWF  xC6
3DD0:  MOVLB  0
3DD2:  RCALL  3964
....................       datinbuf=0; 
3DD4:  MOVLB  6
3DD6:  CLRF   xB9
....................       saving_flag=0; 
3DD8:  CLRF   xBC
....................       data_avai=1; 
3DDA:  MOVLW  01
3DDC:  MOVWF  xBD
....................       enable_getpin=1; 
3DDE:  MOVLB  1
3DE0:  MOVWF  x2D
....................       charac_timeout=0; 
3DE2:  MOVLB  0
3DE4:  CLRF   xFC
3DE6:  CLRF   xFB
....................       key_count_ms=0; 
3DE8:  MOVLB  1
3DEA:  CLRF   x2F
3DEC:  MOVLB  8
3DEE:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3DF0:  MOVLB  0
3DF2:  GOTO   417E (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
16AE:  MOVLW  01
16B0:  MOVLB  8
16B2:  MOVWF  xBC
16B4:  MOVWF  xBD
16B6:  MOVWF  xBE
16B8:  MOVWF  xBF
16BA:  CLRF   xC0
16BC:  MOVWF  xC1
16BE:  MOVWF  xC2
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
16C0:  MOVLB  6
16C2:  CLRF   xB6
16C4:  CLRF   xB5
....................    mcr_timeout=0; 
16C6:  CLRF   xAB
16C8:  CLRF   xAA
16CA:  CLRF   xA9
16CC:  CLRF   xA8
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
16CE:  MOVF   xB6,W
16D0:  SUBLW  FD
16D2:  BNC   16F0
16D4:  BNZ   16DC
16D6:  MOVF   xB5,W
16D8:  SUBLW  E7
16DA:  BNC   16F0
16DC:  BSF    F93.1
16DE:  BTFSS  F81.1
16E0:  BRA    16F0
16E2:  BSF    F94.5
16E4:  BTFSS  F82.5
16E6:  BRA    16F0
....................       card_timeout++; 
16E8:  INCF   xB5,F
16EA:  BTFSC  FD8.2
16EC:  INCF   xB6,F
....................    } 
16EE:  BRA    16CE
....................    card_timeout=0; 
16F0:  CLRF   xB6
16F2:  CLRF   xB5
....................    buffertrack1[bug_countbit_T1++]=0; 
16F4:  MOVFF  6B2,03
16F8:  MOVF   xB1,W
16FA:  INCF   xB1,F
16FC:  BTFSC  FD8.2
16FE:  INCF   xB2,F
1700:  MOVLB  8
1702:  MOVWF  xC5
1704:  MOVLW  2A
1706:  ADDWF  xC5,W
1708:  MOVWF  FE9
170A:  MOVLW  02
170C:  ADDWFC 03,W
170E:  MOVWF  FEA
1710:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1712:  MOVLB  6
1714:  MOVFF  6B2,03
1718:  MOVF   xB1,W
171A:  INCF   xB1,F
171C:  BTFSC  FD8.2
171E:  INCF   xB2,F
1720:  MOVLB  8
1722:  MOVWF  xC5
1724:  MOVLW  2A
1726:  ADDWF  xC5,W
1728:  MOVWF  FE9
172A:  MOVLW  02
172C:  ADDWFC 03,W
172E:  MOVWF  FEA
1730:  MOVLW  01
1732:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1734:  MOVLB  6
1736:  MOVFF  6B4,03
173A:  MOVF   xB3,W
173C:  INCF   xB3,F
173E:  BTFSC  FD8.2
1740:  INCF   xB4,F
1742:  MOVLB  8
1744:  MOVWF  xC5
1746:  MOVLW  7C
1748:  ADDWF  xC5,W
174A:  MOVWF  FE9
174C:  MOVLW  05
174E:  ADDWFC 03,W
1750:  MOVWF  FEA
1752:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1754:  MOVLB  6
1756:  MOVFF  6B4,03
175A:  MOVF   xB3,W
175C:  INCF   xB3,F
175E:  BTFSC  FD8.2
1760:  INCF   xB4,F
1762:  MOVLB  8
1764:  MOVWF  xC5
1766:  MOVLW  7C
1768:  ADDWF  xC5,W
176A:  MOVWF  FE9
176C:  MOVLW  05
176E:  ADDWFC 03,W
1770:  MOVWF  FEA
1772:  MOVLW  01
1774:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1776:  MOVLB  6
1778:  MOVF   xB2,W
177A:  SUBLW  03
177C:  BTFSS  FD8.0
177E:  BRA    185E
1780:  BNZ   178A
1782:  MOVF   xB1,W
1784:  SUBLW  51
1786:  BTFSS  FD8.0
1788:  BRA    185E
178A:  MOVF   xB4,W
178C:  SUBLW  01
178E:  BTFSS  FD8.0
1790:  BRA    185E
1792:  BNZ   179A
1794:  MOVF   xB3,W
1796:  SUBLW  2B
1798:  BNC   185E
179A:  MOVF   xB6,W
179C:  SUBLW  FF
179E:  BNC   185E
17A0:  BNZ   17A8
17A2:  MOVF   xB5,W
17A4:  SUBLW  DB
17A6:  BNC   185E
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
17A8:  MOVF   xBF,F
17AA:  BZ    17B4
....................          { 
....................             bug_countbit_T1=0; 
17AC:  CLRF   xB2
17AE:  CLRF   xB1
....................             bug_countbit_T2=0; 
17B0:  CLRF   xB4
17B2:  CLRF   xB3
....................          } 
....................          card_timeout++; 
17B4:  INCF   xB5,F
17B6:  BTFSC  FD8.2
17B8:  INCF   xB6,F
....................          mcr_timeout=0; 
17BA:  CLRF   xAB
17BC:  CLRF   xAA
17BE:  CLRF   xA9
17C0:  CLRF   xA8
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
17C2:  BSF    F93.2
17C4:  MOVLB  8
17C6:  CLRF   xBC
17C8:  BTFSC  F81.2
17CA:  INCF   xBC,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
17CC:  MOVF   xBC,F
17CE:  BNZ   180C
17D0:  DECFSZ xBD,W
17D2:  BRA    180C
....................          { 
....................             ST1_old = 0; 
17D4:  CLRF   xBD
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
17D6:  MOVLW  2A
17D8:  MOVLB  6
17DA:  ADDWF  xB1,W
17DC:  MOVWF  FE9
17DE:  MOVLW  02
17E0:  ADDWFC xB2,W
17E2:  MOVWF  FEA
17E4:  BSF    F93.1
17E6:  MOVLW  00
17E8:  BTFSS  F81.1
17EA:  MOVLW  01
17EC:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
17EE:  MOVLW  7C
17F0:  ADDWF  xB3,W
17F2:  MOVWF  FE9
17F4:  MOVLW  05
17F6:  ADDWFC xB4,W
17F8:  MOVWF  FEA
17FA:  MOVFF  8C0,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
17FE:  INCF   xB1,F
1800:  BTFSC  FD8.2
1802:  INCF   xB2,F
....................             card_timeout=0; 
1804:  CLRF   xB6
1806:  CLRF   xB5
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1808:  BRA    1816
180A:  MOVLB  8
180C:  DECFSZ xBC,W
180E:  BRA    1814
1810:  MOVLW  01
1812:  MOVWF  xBD
1814:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1816:  BSF    F93.3
1818:  MOVLB  8
181A:  CLRF   xBE
181C:  BTFSC  F81.3
181E:  INCF   xBE,F
....................          if(ST2 == 0 && ST2_old == 1) 
1820:  MOVF   xBE,F
1822:  BNZ   1842
1824:  DECFSZ xBF,W
1826:  BRA    1842
....................          { 
....................             ST2_old = 0; 
1828:  CLRF   xBF
....................             Bit_t2 = !input(MCR_DATA2); 
182A:  BSF    F94.5
182C:  CLRF   xC0
182E:  BTFSS  F82.5
1830:  INCF   xC0,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1832:  MOVLB  6
1834:  INCF   xB3,F
1836:  BTFSC  FD8.2
1838:  INCF   xB4,F
....................             card_timeout=0; 
183A:  CLRF   xB6
183C:  CLRF   xB5
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
183E:  BRA    184C
1840:  MOVLB  8
1842:  DECFSZ xBE,W
1844:  BRA    184A
1846:  MOVLW  01
1848:  MOVWF  xBF
184A:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
184C:  BSF    F93.0
184E:  BTFSS  F81.0
1850:  BRA    185C
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1852:  CLRF   xBF
....................             card_timeout=65500; 
1854:  SETF   xB6
1856:  MOVLW  DC
1858:  MOVWF  xB5
....................             break;            
185A:  BRA    185E
....................          } 
....................       } 
185C:  BRA    1778
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
185E:  CLRF   xB6
1860:  CLRF   xB5
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1862:  MOVLB  8
1864:  CLRF   xCE
1866:  MOVFF  6B2,8D0
186A:  MOVFF  6B1,8CF
186E:  MOVLW  02
1870:  MOVWF  xD2
1872:  MOVLW  2A
1874:  MOVWF  xD1
1876:  MOVLB  0
1878:  CALL   0818
187C:  MOVFF  01,8C1
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1880:  MOVLW  01
1882:  MOVLB  8
1884:  MOVWF  xCE
1886:  MOVFF  6B4,8D0
188A:  MOVFF  6B3,8CF
188E:  MOVLW  05
1890:  MOVWF  xD2
1892:  MOVLW  7C
1894:  MOVWF  xD1
1896:  MOVLB  0
1898:  CALL   0818
189C:  MOVFF  01,8C2
....................       //#if defined(debug) 
....................       if(debugmode==1) 
18A0:  MOVLB  6
18A2:  DECFSZ xBA,W
18A4:  BRA    1946
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
18A6:  MOVLW  E2
18A8:  MOVWF  FF6
18AA:  MOVLW  03
18AC:  MOVWF  FF7
18AE:  MOVLW  0E
18B0:  MOVLB  8
18B2:  MOVWF  xDC
18B4:  MOVLB  0
18B6:  RCALL  141A
18B8:  MOVLW  10
18BA:  MOVWF  FE9
18BC:  MOVFF  6B2,8C6
18C0:  MOVFF  6B1,8C5
18C4:  RCALL  1444
18C6:  MOVLW  0D
18C8:  MOVLB  8
18CA:  MOVWF  xE8
18CC:  MOVLB  0
18CE:  CALL   045C
18D2:  MOVLW  0A
18D4:  MOVLB  8
18D6:  MOVWF  xE8
18D8:  MOVLB  0
18DA:  CALL   045C
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
18DE:  MOVLW  F6
18E0:  MOVWF  FF6
18E2:  MOVLW  03
18E4:  MOVWF  FF7
18E6:  MOVLW  0E
18E8:  MOVLB  8
18EA:  MOVWF  xDC
18EC:  MOVLB  0
18EE:  RCALL  141A
18F0:  MOVLW  10
18F2:  MOVWF  FE9
18F4:  MOVFF  6B4,8C6
18F8:  MOVFF  6B3,8C5
18FC:  RCALL  1444
18FE:  MOVLW  0D
1900:  MOVLB  8
1902:  MOVWF  xE8
1904:  MOVLB  0
1906:  CALL   045C
190A:  MOVLW  0A
190C:  MOVLB  8
190E:  MOVWF  xE8
1910:  MOVLB  0
1912:  CALL   045C
....................          debug_reader();       
1916:  BRA    15F2
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1918:  MOVLB  8
191A:  MOVF   xC1,F
191C:  BNZ   192E
191E:  MOVLW  0A
1920:  MOVWF  FF6
1922:  MOVLW  04
1924:  MOVWF  FF7
1926:  MOVLB  0
1928:  CALL   04A2
192C:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
192E:  MOVF   xC2,F
1930:  BNZ   1942
1932:  MOVLW  20
1934:  MOVWF  FF6
1936:  MOVLW  04
1938:  MOVWF  FF7
193A:  MOVLB  0
193C:  CALL   04A2
1940:  MOVLB  8
....................       } 
....................          else 
1942:  BRA    1952
1944:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1946:  MOVLW  0F
1948:  MOVLB  8
194A:  MOVWF  xC5
194C:  MOVLB  0
194E:  RCALL  1686
1950:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1952:  MOVF   xC1,F
1954:  BZ    195A
1956:  MOVF   xC2,F
1958:  BNZ   197A
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
195A:  MOVLB  6
195C:  CLRF   xB4
195E:  CLRF   xB3
....................          bug_countbit_T1=0; 
1960:  CLRF   xB2
1962:  CLRF   xB1
....................          reading_fg=0; 
1964:  CLRF   xBE
....................          count_reading_error++; 
1966:  INCF   xBF,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1968:  CLRF   xAB
196A:  CLRF   xAA
196C:  CLRF   xA9
196E:  CLRF   xA8
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1970:  MOVLW  00
1972:  MOVWF  01
1974:  BRA    19B2
....................       } 
....................          else  
1976:  BRA    19AE
1978:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
197A:  MOVLW  01
197C:  MOVLB  6
197E:  MOVWF  xB9
....................             reading_fg=1; 
1980:  MOVWF  xBE
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1982:  MOVFF  6B4,6B0
1986:  MOVFF  6B3,6AF
....................             countbit_T1=bug_countbit_T1; 
198A:  MOVFF  6B2,6AE
198E:  MOVFF  6B1,6AD
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1992:  CLRF   xB2
1994:  CLRF   xB1
....................             bug_countbit_T2=0;  
1996:  CLRF   xB4
1998:  CLRF   xB3
....................             mcr_timeout=0; 
199A:  CLRF   xAB
199C:  CLRF   xAA
199E:  CLRF   xA9
19A0:  CLRF   xA8
....................             charac_timeout=0; 
19A2:  MOVLB  0
19A4:  CLRF   xFC
19A6:  CLRF   xFB
....................             return 1; 
19A8:  MOVWF  01
19AA:  MOVLB  6
19AC:  BRA    19B2
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
19AE:  MOVLW  00
19B0:  MOVWF  01
.................... } 
19B2:  MOVLB  0
19B4:  GOTO   1A20 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
19B8:  MOVLW  02
19BA:  MOVLB  8
19BC:  MOVWF  xBC
19BE:  MOVLW  FA
19C0:  MOVWF  xBD
19C2:  MOVLB  0
19C4:  GOTO   0436
19C8:  MOVLB  8
19CA:  DECFSZ xBC,F
19CC:  BRA    19BE
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
19CE:  MOVLB  6
19D0:  DECFSZ xBC,W
19D2:  BRA    19D6
19D4:  BRA    1A32
....................       if((KP_mode)&&(enable_getpin==0)&&(booting==1)) 
19D6:  MOVLB  1
19D8:  MOVF   x30,F
19DA:  BZ    1A1C
19DC:  MOVF   x2D,F
19DE:  BNZ   1A1C
19E0:  DECFSZ x05,W
19E2:  BRA    1A1C
....................       { 
....................          if(kp_st==1) 
19E4:  DECFSZ x31,W
19E6:  BRA    1A00
....................          { 
....................             printf("\n\rKey release.\n\r"); 
19E8:  MOVLW  3A
19EA:  MOVWF  FF6
19EC:  MOVLW  1A
19EE:  MOVWF  FF7
19F0:  MOVLB  0
19F2:  CALL   04A2
....................             keyprss_off; 
19F6:  BCF    F92.7
19F8:  BCF    F89.7
....................             kp_st=0; 
19FA:  MOVLB  1
19FC:  CLRF   x31
....................          } 
....................          else 
19FE:  BRA    1A1C
....................          { 
....................             printf("\n\rKey press.\n\r"); 
1A00:  MOVLW  4C
1A02:  MOVWF  FF6
1A04:  MOVLW  1A
1A06:  MOVWF  FF7
1A08:  MOVLB  0
1A0A:  CALL   04A2
....................             keyprss_on; 
1A0E:  BCF    F92.7
1A10:  BSF    F89.7
....................             kp_st=1;  
1A12:  MOVLW  01
1A14:  MOVLB  1
1A16:  MOVWF  x31
....................             count_kp=0; 
1A18:  CLRF   x33
1A1A:  CLRF   x32
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1A1C:  MOVLB  0
1A1E:  BRA    16AE
1A20:  MOVFF  01,6BB
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1A24:  MOVLB  6
1A26:  CLRF   xAB
1A28:  CLRF   xAA
1A2A:  CLRF   xA9
1A2C:  CLRF   xA8
....................       card_timeout=0; 
1A2E:  CLRF   xB6
1A30:  CLRF   xB5
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1A32:  BCF    FF0.0
1A34:  MOVLB  0
1A36:  GOTO   006C
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
6BDE:  CLRF   19
6BE0:  BTFSC  FF2.7
6BE2:  BSF    19.7
6BE4:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
6BE6:  MOVLB  8
6BE8:  CLRF   xD3
6BEA:  CLRF   xD2
6BEC:  CLRF   xD1
6BEE:  MOVLW  94
6BF0:  MOVWF  xD0
6BF2:  MOVLW  03
6BF4:  MOVWF  xD4
6BF6:  MOVLB  0
6BF8:  CALL   3866
6BFC:  BTFSC  19.7
6BFE:  BSF    FF2.7
6C00:  CLRF   19
6C02:  BTFSC  FF2.7
6C04:  BSF    19.7
6C06:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
6C08:  MOVLB  8
6C0A:  CLRF   xD3
6C0C:  CLRF   xD2
6C0E:  CLRF   xD1
6C10:  MOVLW  91
6C12:  MOVWF  xD0
6C14:  MOVLW  01
6C16:  MOVWF  xD4
6C18:  MOVLB  0
6C1A:  CALL   3866
6C1E:  BTFSC  19.7
6C20:  BSF    FF2.7
6C22:  CLRF   19
6C24:  BTFSC  FF2.7
6C26:  BSF    19.7
6C28:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6C2A:  MOVLB  8
6C2C:  CLRF   xCB
6C2E:  CLRF   xCA
6C30:  CLRF   xC9
6C32:  MOVLW  91
6C34:  MOVWF  xC8
6C36:  MOVLB  0
6C38:  CALL   3316
6C3C:  BTFSC  19.7
6C3E:  BSF    FF2.7
6C40:  MOVFF  01,6C6
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
....................    #endif 
....................     
.................... } 
6C44:  GOTO   758C (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
6F24:  MOVLW  06
6F26:  MOVWF  FEA
6F28:  MOVLW  CB
6F2A:  MOVWF  FE9
6F2C:  CALL   48B4
6F30:  CLRF   19
6F32:  BTFSC  FF2.7
6F34:  BSF    19.7
6F36:  BCF    FF2.7
6F38:  MOVLW  3E
6F3A:  MOVLB  8
6F3C:  MOVWF  xE8
6F3E:  MOVLB  0
6F40:  CALL   045C
6F44:  BTFSC  19.7
6F46:  BSF    FF2.7
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
6F48:  MOVLW  01
6F4A:  MOVLB  7
6F4C:  MOVWF  xD7
6F4E:  MOVLW  14
6F50:  MOVWF  xD8
6F52:  MOVLW  01
6F54:  MOVWF  xDA
6F56:  MOVLW  49
6F58:  MOVWF  xD9
6F5A:  MOVLB  0
6F5C:  CALL   6652
6F60:  CLRF   19
6F62:  BTFSC  FF2.7
6F64:  BSF    19.7
6F66:  BCF    FF2.7
....................       printf("\n\r"); 
6F68:  MOVLW  0A
6F6A:  MOVLB  8
6F6C:  MOVWF  xE8
6F6E:  MOVLB  0
6F70:  CALL   045C
6F74:  BTFSC  19.7
6F76:  BSF    FF2.7
6F78:  CLRF   19
6F7A:  BTFSC  FF2.7
6F7C:  BSF    19.7
6F7E:  BCF    FF2.7
6F80:  MOVLW  0D
6F82:  MOVLB  8
6F84:  MOVWF  xE8
6F86:  MOVLB  0
6F88:  CALL   045C
6F8C:  BTFSC  19.7
6F8E:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
6F90:  CLRF   FEA
6F92:  MOVLW  41
6F94:  MOVWF  FE9
6F96:  MOVLW  00
6F98:  CALL   011C
6F9C:  TBLRD*-
6F9E:  TBLRD*+
6FA0:  MOVF   FF5,W
6FA2:  MOVWF  FEE
6FA4:  IORLW  00
6FA6:  BNZ   6F9E
....................       index=0; 
6FA8:  MOVLB  7
6FAA:  CLRF   xA1
....................       ee_dat=0; 
6FAC:  MOVLB  6
6FAE:  CLRF   xC1
....................       count_card=1; 
6FB0:  CLRF   xC3
6FB2:  MOVLW  01
6FB4:  MOVWF  xC2
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6FB6:  MOVLB  7
6FB8:  MOVWF  xD8
6FBA:  MOVLW  49
6FBC:  MOVWF  xD7
6FBE:  CLRF   xDA
6FC0:  MOVLW  41
6FC2:  MOVWF  xD9
6FC4:  MOVLB  0
6FC6:  CALL   678A
6FCA:  MOVF   01,F
6FCC:  BTFSS  FD8.2
6FCE:  BRA    73B6
....................       { 
....................          unsigned long adr=0; 
6FD0:  MOVLB  7
6FD2:  CLRF   xD6
6FD4:  CLRF   xD5
....................          //unsigned int count=0; 
....................          rec[0]=0; 
6FD6:  MOVLB  0
6FD8:  CLRF   x7D
6FDA:  CLRF   19
6FDC:  BTFSC  FF2.7
6FDE:  BSF    19.7
6FE0:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
6FE2:  CALL   33E2
6FE6:  BTFSC  19.7
6FE8:  BSF    FF2.7
6FEA:  MOVFF  02,6C5
6FEE:  MOVFF  01,6C4
6FF2:  CLRF   19
6FF4:  BTFSC  FF2.7
6FF6:  BSF    19.7
6FF8:  BCF    FF2.7
....................          adr=count_card*numdata; 
6FFA:  MOVFF  6C3,8C5
6FFE:  MOVFF  6C2,8C4
7002:  MOVLB  8
7004:  CLRF   xC7
7006:  MOVLW  7C
7008:  MOVWF  xC6
700A:  MOVLB  0
700C:  CALL   343A
7010:  BTFSC  19.7
7012:  BSF    FF2.7
7014:  MOVFF  02,7D6
7018:  MOVFF  01,7D5
....................          addr_key=EEPROM_KEY_ST; 
701C:  MOVLB  6
701E:  CLRF   xCA
7020:  MOVLW  01
7022:  MOVWF  xC9
7024:  MOVLW  C3
7026:  MOVWF  xC8
7028:  MOVLW  0F
702A:  MOVWF  xC7
....................          while(count_card<=count_card_tg) 
....................          { 
702C:  MOVF   xC3,W
702E:  SUBWF  xC5,W
7030:  BTFSS  FD8.0
7032:  BRA    73B4
7034:  BNZ   703E
7036:  MOVF   xC2,W
7038:  SUBWF  xC4,W
703A:  BTFSS  FD8.0
703C:  BRA    73B4
703E:  CLRF   19
7040:  BTFSC  FF2.7
7042:  BSF    19.7
7044:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
7046:  MOVFF  6C3,8C5
704A:  MOVFF  6C2,8C4
704E:  MOVLB  8
7050:  CLRF   xC7
7052:  MOVLW  7C
7054:  MOVWF  xC6
7056:  MOVLB  0
7058:  CALL   343A
705C:  BTFSC  19.7
705E:  BSF    FF2.7
7060:  MOVLW  96
7062:  MOVLB  7
7064:  ADDWF  01,W
7066:  MOVWF  xD5
7068:  MOVLW  00
706A:  ADDWFC 02,W
706C:  MOVWF  xD6
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
706E:  MOVLW  7C
7070:  SUBWF  xD5,W
7072:  MOVWF  xD7
7074:  MOVLW  00
7076:  SUBWFB xD6,W
7078:  MOVWF  xD8
707A:  MOVWF  xDA
707C:  MOVFF  7D7,7D9
7080:  CLRF   xDC
7082:  MOVLW  7C
7084:  MOVWF  xDB
7086:  CLRF   xDE
7088:  MOVLW  7D
708A:  MOVWF  xDD
708C:  MOVLB  0
708E:  GOTO   6822
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
7092:  MOVLW  10
7094:  MOVWF  FE9
7096:  CLRF   19
7098:  BTFSC  FF2.7
709A:  BSF    19.7
709C:  BCF    FF2.7
709E:  MOVFF  6C3,8C0
70A2:  MOVFF  6C2,8BF
70A6:  CALL   3FD0
70AA:  BTFSC  19.7
70AC:  BSF    FF2.7
70AE:  CLRF   19
70B0:  BTFSC  FF2.7
70B2:  BSF    19.7
70B4:  BCF    FF2.7
70B6:  MOVLW  29
70B8:  MOVLB  8
70BA:  MOVWF  xE8
70BC:  MOVLB  0
70BE:  CALL   045C
70C2:  BTFSC  19.7
70C4:  BSF    FF2.7
70C6:  MOVFF  7D,7D7
70CA:  MOVLW  01
70CC:  MOVLB  7
70CE:  MOVWF  xD8
70D0:  MOVLB  0
70D2:  CALL   6898
70D6:  CLRF   19
70D8:  BTFSC  FF2.7
70DA:  BSF    19.7
70DC:  BCF    FF2.7
70DE:  MOVLW  2F
70E0:  MOVLB  8
70E2:  MOVWF  xE8
70E4:  MOVLB  0
70E6:  CALL   045C
70EA:  BTFSC  19.7
70EC:  BSF    FF2.7
70EE:  MOVFF  7E,7D7
70F2:  MOVLW  01
70F4:  MOVLB  7
70F6:  MOVWF  xD8
70F8:  MOVLB  0
70FA:  CALL   6898
70FE:  CLRF   19
7100:  BTFSC  FF2.7
7102:  BSF    19.7
7104:  BCF    FF2.7
7106:  MOVLW  20
7108:  MOVLB  8
710A:  MOVWF  xE8
710C:  MOVLB  0
710E:  CALL   045C
7112:  BTFSC  19.7
7114:  BSF    FF2.7
7116:  MOVFF  7F,7D7
711A:  MOVLW  01
711C:  MOVLB  7
711E:  MOVWF  xD8
7120:  MOVLB  0
7122:  CALL   6898
7126:  CLRF   19
7128:  BTFSC  FF2.7
712A:  BSF    19.7
712C:  BCF    FF2.7
712E:  MOVLW  3A
7130:  MOVLB  8
7132:  MOVWF  xE8
7134:  MOVLB  0
7136:  CALL   045C
713A:  BTFSC  19.7
713C:  BSF    FF2.7
713E:  MOVFF  80,7D7
7142:  MOVLW  01
7144:  MOVLB  7
7146:  MOVWF  xD8
7148:  MOVLB  0
714A:  CALL   6898
714E:  CLRF   19
7150:  BTFSC  FF2.7
7152:  BSF    19.7
7154:  BCF    FF2.7
7156:  MOVLW  3A
7158:  MOVLB  8
715A:  MOVWF  xE8
715C:  MOVLB  0
715E:  CALL   045C
7162:  BTFSC  19.7
7164:  BSF    FF2.7
7166:  MOVFF  81,7D7
716A:  MOVLW  01
716C:  MOVLB  7
716E:  MOVWF  xD8
7170:  MOVLB  0
7172:  CALL   6898
....................             ee_dat=0; 
7176:  MOVLB  6
7178:  CLRF   xC1
....................             index=0; 
717A:  MOVLB  7
717C:  CLRF   xA1
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
717E:  MOVLW  80
7180:  MOVWF  FF6
7182:  MOVLW  1A
7184:  MOVWF  FF7
7186:  CLRF   19
7188:  BTFSC  FF2.7
718A:  BSF    19.7
718C:  BCF    FF2.7
718E:  MOVLB  0
7190:  CALL   04A2
7194:  BTFSC  19.7
7196:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
7198:  MOVLB  7
719A:  MOVF   xA1,W
719C:  SUBLW  4E
719E:  BNC   71FC
71A0:  MOVLB  6
71A2:  MOVF   xC1,W
71A4:  SUBLW  3F
71A6:  BTFSS  FD8.2
71A8:  BRA    71AE
71AA:  MOVLB  7
71AC:  BRA    71FC
....................                ee_dat = rec[index+5]; 
71AE:  MOVLW  05
71B0:  MOVLB  7
71B2:  ADDWF  xA1,W
71B4:  CLRF   03
71B6:  ADDLW  7D
71B8:  MOVWF  FE9
71BA:  MOVLW  00
71BC:  ADDWFC 03,W
71BE:  MOVWF  FEA
71C0:  MOVFF  FEF,6C1
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
71C4:  MOVLB  6
71C6:  MOVF   xC1,W
71C8:  SUBLW  1F
71CA:  BC    71E8
71CC:  MOVF   xC1,W
71CE:  SUBLW  7E
71D0:  BNC   71E8
71D2:  CLRF   19
71D4:  BTFSC  FF2.7
71D6:  BSF    19.7
71D8:  BCF    FF2.7
71DA:  MOVFF  6C1,8E8
71DE:  MOVLB  0
71E0:  CALL   045C
71E4:  BTFSC  19.7
71E6:  BSF    FF2.7
....................                index++; 
71E8:  MOVLB  7
71EA:  INCF   xA1,F
....................                if(ee_dat==0)break; 
71EC:  MOVLB  6
71EE:  MOVF   xC1,F
71F0:  BNZ   71F6
71F2:  MOVLB  7
71F4:  BRA    71FC
....................             } 
71F6:  MOVLB  0
71F8:  BRA    7198
71FA:  MOVLB  7
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
71FC:  MOVLW  92
71FE:  MOVWF  FF6
7200:  MOVLW  1A
7202:  MOVWF  FF7
7204:  CLRF   19
7206:  BTFSC  FF2.7
7208:  BSF    19.7
720A:  BCF    FF2.7
720C:  MOVLB  0
720E:  CALL   04A2
7212:  BTFSC  19.7
7214:  BSF    FF2.7
....................             index=0; 
7216:  MOVLB  7
7218:  CLRF   xA1
....................             ee_dat=0; 
721A:  MOVLB  6
721C:  CLRF   xC1
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
721E:  MOVLB  7
7220:  MOVF   xA1,W
7222:  SUBLW  27
7224:  BNC   7284
7226:  MOVLB  6
7228:  MOVF   xC1,W
722A:  SUBLW  3F
722C:  BTFSS  FD8.2
722E:  BRA    7234
7230:  MOVLB  7
7232:  BRA    7284
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
7234:  MOVLW  05
7236:  MOVLB  7
7238:  ADDWF  xA1,W
723A:  ADDLW  4F
723C:  CLRF   03
723E:  ADDLW  7D
7240:  MOVWF  FE9
7242:  MOVLW  00
7244:  ADDWFC 03,W
7246:  MOVWF  FEA
7248:  MOVFF  FEF,6C1
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
724C:  MOVLB  6
724E:  MOVF   xC1,W
7250:  SUBLW  1F
7252:  BC    7270
7254:  MOVF   xC1,W
7256:  SUBLW  7E
7258:  BNC   7270
725A:  CLRF   19
725C:  BTFSC  FF2.7
725E:  BSF    19.7
7260:  BCF    FF2.7
7262:  MOVFF  6C1,8E8
7266:  MOVLB  0
7268:  CALL   045C
726C:  BTFSC  19.7
726E:  BSF    FF2.7
....................                index++; 
7270:  MOVLB  7
7272:  INCF   xA1,F
....................                if(ee_dat==0)break; 
7274:  MOVLB  6
7276:  MOVF   xC1,F
7278:  BNZ   7280
727A:  MOVLB  7
727C:  BRA    7284
727E:  MOVLB  6
....................             } 
7280:  BRA    721E
7282:  MOVLB  7
....................             index=0; 
7284:  CLRF   xA1
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
7286:  MOVLW  A4
7288:  MOVWF  FF6
728A:  MOVLW  1A
728C:  MOVWF  FF7
728E:  CLRF   19
7290:  BTFSC  FF2.7
7292:  BSF    19.7
7294:  BCF    FF2.7
7296:  MOVLB  0
7298:  CALL   04A2
729C:  BTFSC  19.7
729E:  BSF    FF2.7
....................             //fprintf(COM2,"addr_key =%lu \n\r",addr_key);  
....................             //fprintf(COM2," ptr_card_key=%lu \n\r",ptr_card_key);  
....................             if(ptr_card_key>addr_key) 
72A0:  MOVLB  6
72A2:  MOVF   xCA,W
72A4:  SUBWF  27,W
72A6:  BTFSS  FD8.0
72A8:  BRA    73AC
72AA:  BNZ   72C8
72AC:  MOVF   xC9,W
72AE:  SUBWF  26,W
72B0:  BTFSS  FD8.0
72B2:  BRA    73AC
72B4:  BNZ   72C8
72B6:  MOVF   xC8,W
72B8:  SUBWF  25,W
72BA:  BTFSS  FD8.0
72BC:  BRA    73AC
72BE:  BNZ   72C8
72C0:  MOVF   24,W
72C2:  SUBWF  xC7,W
72C4:  BTFSC  FD8.0
72C6:  BRA    73AC
....................             { 
....................                i=0; 
72C8:  MOVLB  7
72CA:  CLRF   xA2
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
72CC:  MOVF   xA2,W
72CE:  MOVLB  6
72D0:  ADDWF  xC7,W
72D2:  MOVLB  7
72D4:  MOVWF  xD7
72D6:  MOVLW  00
72D8:  MOVLB  6
72DA:  ADDWFC xC8,W
72DC:  MOVLB  7
72DE:  MOVWF  xD8
72E0:  MOVLW  00
72E2:  MOVLB  6
72E4:  ADDWFC xC9,W
72E6:  MOVLB  7
72E8:  MOVWF  xD9
72EA:  MOVLW  00
72EC:  MOVLB  6
72EE:  ADDWFC xCA,W
72F0:  MOVLB  7
72F2:  MOVWF  xDA
72F4:  CLRF   19
72F6:  BTFSC  FF2.7
72F8:  BSF    19.7
72FA:  BCF    FF2.7
72FC:  MOVFF  FE8,8CB
7300:  MOVFF  7D9,8CA
7304:  MOVFF  7D8,8C9
7308:  MOVFF  7D7,8C8
730C:  MOVLB  0
730E:  CALL   3316
7312:  BTFSC  19.7
7314:  BSF    FF2.7
7316:  MOVFF  01,6C1
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
731A:  MOVLB  6
731C:  MOVF   xC1,W
731E:  SUBLW  2F
7320:  BC    7328
7322:  MOVF   xC1,W
7324:  SUBLW  39
7326:  BC    7340
7328:  MOVF   xC1,W
732A:  SUBLW  23
732C:  BZ    7340
732E:  MOVF   xC1,W
7330:  SUBLW  2A
7332:  BZ    7340
7334:  MOVF   xC1,W
7336:  SUBLW  40
7338:  BC    7356
733A:  MOVF   xC1,W
733C:  SUBLW  5A
733E:  BNC   7356
7340:  CLRF   19
7342:  BTFSC  FF2.7
7344:  BSF    19.7
7346:  BCF    FF2.7
....................                      fputc(ee_dat,COM2); 
7348:  MOVFF  6C1,8E8
734C:  MOVLB  0
734E:  CALL   045C
7352:  BTFSC  19.7
7354:  BSF    FF2.7
....................                   i++; 
7356:  MOVLB  7
7358:  INCF   xA2,F
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
735A:  MOVF   xA2,W
735C:  SUBLW  0B
735E:  BNC   736C
7360:  MOVLB  6
7362:  MOVF   xC1,F
7364:  BTFSC  FD8.2
7366:  BRA    736C
7368:  MOVLB  7
736A:  BRA    72CC
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+key_numbyte; 
736C:  MOVLW  0C
736E:  MOVLB  6
7370:  ADDWF  xC7,F
7372:  MOVLW  00
7374:  ADDWFC xC8,F
7376:  ADDWFC xC9,F
7378:  ADDWFC xCA,F
737A:  CLRF   19
737C:  BTFSC  FF2.7
737E:  BSF    19.7
7380:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
7382:  MOVLW  0A
7384:  MOVLB  8
7386:  MOVWF  xE8
7388:  MOVLB  0
738A:  CALL   045C
738E:  BTFSC  19.7
7390:  BSF    FF2.7
7392:  CLRF   19
7394:  BTFSC  FF2.7
7396:  BSF    19.7
7398:  BCF    FF2.7
739A:  MOVLW  0D
739C:  MOVLB  8
739E:  MOVWF  xE8
73A0:  MOVLB  0
73A2:  CALL   045C
73A6:  BTFSC  19.7
73A8:  BSF    FF2.7
73AA:  MOVLB  6
....................             } 
....................             count_card++; 
73AC:  INCF   xC2,F
73AE:  BTFSC  FD8.2
73B0:  INCF   xC3,F
....................          } 
73B2:  BRA    702C
73B4:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
73B6:  CLRF   FEA
73B8:  MOVLW  41
73BA:  MOVWF  FE9
73BC:  MOVLW  00
73BE:  CALL   012E
73C2:  TBLRD*-
73C4:  TBLRD*+
73C6:  MOVF   FF5,W
73C8:  MOVWF  FEE
73CA:  IORLW  00
73CC:  BNZ   73C4
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
73CE:  MOVLW  01
73D0:  MOVLB  7
73D2:  MOVWF  xD8
73D4:  MOVLW  49
73D6:  MOVWF  xD7
73D8:  CLRF   xDA
73DA:  MOVLW  41
73DC:  MOVWF  xD9
73DE:  MOVLB  0
73E0:  CALL   678A
73E4:  MOVF   01,F
73E6:  BNZ   741C
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
73E8:  MOVLW  B4
73EA:  MOVWF  FF6
73EC:  MOVLW  1A
73EE:  MOVWF  FF7
73F0:  CLRF   19
73F2:  BTFSC  FF2.7
73F4:  BSF    19.7
73F6:  BCF    FF2.7
73F8:  CALL   04A2
73FC:  BTFSC  19.7
73FE:  BSF    FF2.7
....................          format_eepromext(); 
7400:  GOTO   69B2
....................          fprintf(COM2," exit\n\r");  
7404:  MOVLW  C2
7406:  MOVWF  FF6
7408:  MOVLW  1A
740A:  MOVWF  FF7
740C:  CLRF   19
740E:  BTFSC  FF2.7
7410:  BSF    19.7
7412:  BCF    FF2.7
7414:  CALL   04A2
7418:  BTFSC  19.7
741A:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
741C:  CLRF   FEA
741E:  MOVLW  41
7420:  MOVWF  FE9
7422:  MOVLW  00
7424:  CALL   0140
7428:  TBLRD*-
742A:  TBLRD*+
742C:  MOVF   FF5,W
742E:  MOVWF  FEE
7430:  IORLW  00
7432:  BNZ   742A
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
7434:  MOVLW  01
7436:  MOVLB  7
7438:  MOVWF  xD8
743A:  MOVLW  49
743C:  MOVWF  xD7
743E:  CLRF   xDA
7440:  MOVLW  41
7442:  MOVWF  xD9
7444:  MOVLB  0
7446:  CALL   678A
744A:  MOVF   01,F
744C:  BNZ   7482
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
744E:  MOVLW  CA
7450:  MOVWF  FF6
7452:  MOVLW  1A
7454:  MOVWF  FF7
7456:  CLRF   19
7458:  BTFSC  FF2.7
745A:  BSF    19.7
745C:  BCF    FF2.7
745E:  CALL   04A2
7462:  BTFSC  19.7
7464:  BSF    FF2.7
....................          ease_eeprom(); 
7466:  GOTO   6B18
....................          fprintf(COM2," exit\n\r");  
746A:  MOVLW  D8
746C:  MOVWF  FF6
746E:  MOVLW  1A
7470:  MOVWF  FF7
7472:  CLRF   19
7474:  BTFSC  FF2.7
7476:  BSF    19.7
7478:  BCF    FF2.7
747A:  CALL   04A2
747E:  BTFSC  19.7
7480:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
7482:  CLRF   FEA
7484:  MOVLW  41
7486:  MOVWF  FE9
7488:  MOVLW  00
748A:  CALL   0156
748E:  TBLRD*-
7490:  TBLRD*+
7492:  MOVF   FF5,W
7494:  MOVWF  FEE
7496:  IORLW  00
7498:  BNZ   7490
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
749A:  MOVLW  01
749C:  MOVLB  7
749E:  MOVWF  xD8
74A0:  MOVLW  49
74A2:  MOVWF  xD7
74A4:  CLRF   xDA
74A6:  MOVLW  41
74A8:  MOVWF  xD9
74AA:  MOVLB  0
74AC:  CALL   678A
74B0:  MOVF   01,F
74B2:  BNZ   74EC
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
74B4:  MOVLW  E0
74B6:  MOVWF  FF6
74B8:  MOVLW  1A
74BA:  MOVWF  FF7
74BC:  CLRF   19
74BE:  BTFSC  FF2.7
74C0:  BSF    19.7
74C2:  BCF    FF2.7
74C4:  CALL   04A2
74C8:  BTFSC  19.7
74CA:  BSF    FF2.7
....................          reset_password(); 
74CC:  GOTO   6B9C
....................          init_password(); 
74D0:  CALL   44F4
....................          fprintf(COM2," exit\n\r");  
74D4:  MOVLW  F6
74D6:  MOVWF  FF6
74D8:  MOVLW  1A
74DA:  MOVWF  FF7
74DC:  CLRF   19
74DE:  BTFSC  FF2.7
74E0:  BSF    19.7
74E2:  BCF    FF2.7
74E4:  CALL   04A2
74E8:  BTFSC  19.7
74EA:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
74EC:  CLRF   FEA
74EE:  MOVLW  41
74F0:  MOVWF  FE9
74F2:  MOVLW  00
74F4:  CALL   016C
74F8:  TBLRD*-
74FA:  TBLRD*+
74FC:  MOVF   FF5,W
74FE:  MOVWF  FEE
7500:  IORLW  00
7502:  BNZ   74FA
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
7504:  MOVLW  01
7506:  MOVLB  7
7508:  MOVWF  xD8
750A:  MOVLW  49
750C:  MOVWF  xD7
750E:  CLRF   xDA
7510:  MOVLW  41
7512:  MOVWF  xD9
7514:  MOVLB  0
7516:  CALL   678A
751A:  MOVF   01,F
751C:  BNZ   753E
....................       { 
....................          keydebug_en=1; 
751E:  MOVLW  01
7520:  MOVLB  1
7522:  MOVWF  x2C
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
7524:  MOVLW  FE
7526:  MOVWF  FF6
7528:  MOVLW  1A
752A:  MOVWF  FF7
752C:  CLRF   19
752E:  BTFSC  FF2.7
7530:  BSF    19.7
7532:  BCF    FF2.7
7534:  MOVLB  0
7536:  CALL   04A2
753A:  BTFSC  19.7
753C:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
753E:  CLRF   FEA
7540:  MOVLW  41
7542:  MOVWF  FE9
7544:  MOVLW  00
7546:  CALL   0182
754A:  TBLRD*-
754C:  TBLRD*+
754E:  MOVF   FF5,W
7550:  MOVWF  FEE
7552:  IORLW  00
7554:  BNZ   754C
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
7556:  MOVLW  01
7558:  MOVLB  7
755A:  MOVWF  xD8
755C:  MOVLW  49
755E:  MOVWF  xD7
7560:  CLRF   xDA
7562:  MOVLW  41
7564:  MOVWF  xD9
7566:  MOVLB  0
7568:  CALL   678A
756C:  MOVF   01,F
756E:  BNZ   758C
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
7570:  MOVLW  12
7572:  MOVWF  FF6
7574:  MOVLW  1B
7576:  MOVWF  FF7
7578:  CLRF   19
757A:  BTFSC  FF2.7
757C:  BSF    19.7
757E:  BCF    FF2.7
7580:  CALL   04A2
7584:  BTFSC  19.7
7586:  BSF    FF2.7
....................          rstfact(); 
7588:  GOTO   6BDE
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
758C:  CLRF   FEA
758E:  MOVLW  41
7590:  MOVWF  FE9
7592:  MOVLW  00
7594:  CALL   019A
7598:  TBLRD*-
759A:  TBLRD*+
759C:  MOVF   FF5,W
759E:  MOVWF  FEE
75A0:  IORLW  00
75A2:  BNZ   759A
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
75A4:  MOVLW  01
75A6:  MOVLB  7
75A8:  MOVWF  xD8
75AA:  MOVLW  49
75AC:  MOVWF  xD7
75AE:  CLRF   xDA
75B0:  MOVLW  41
75B2:  MOVWF  xD9
75B4:  MOVLB  0
75B6:  CALL   678A
75BA:  MOVF   01,F
75BC:  BNZ   75E4
....................       { 
....................          mode=LOGOFF; 
75BE:  MOVLB  6
75C0:  CLRF   xC0
....................          keydebug_en=0; 
75C2:  MOVLB  1
75C4:  CLRF   x2C
....................          set_tris_a(0xff); 
75C6:  MOVLW  FF
75C8:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
75CA:  MOVLW  22
75CC:  MOVWF  FF6
75CE:  MOVLW  1B
75D0:  MOVWF  FF7
75D2:  CLRF   19
75D4:  BTFSC  FF2.7
75D6:  BSF    19.7
75D8:  BCF    FF2.7
75DA:  MOVLB  0
75DC:  CALL   04A2
75E0:  BTFSC  19.7
75E2:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
75E4:  CLRF   FEA
75E6:  MOVLW  41
75E8:  MOVWF  FE9
75EA:  MOVLW  00
75EC:  CALL   01AC
75F0:  TBLRD*-
75F2:  TBLRD*+
75F4:  MOVF   FF5,W
75F6:  MOVWF  FEE
75F8:  IORLW  00
75FA:  BNZ   75F2
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
75FC:  MOVLW  01
75FE:  MOVLB  7
7600:  MOVWF  xD8
7602:  MOVLW  49
7604:  MOVWF  xD7
7606:  CLRF   xDA
7608:  MOVLW  41
760A:  MOVWF  xD9
760C:  MOVLB  0
760E:  CALL   678A
7612:  MOVF   01,F
7614:  BNZ   7682
....................       { 
....................          fprintf(COM2,"New console name>"); 
7616:  MOVLW  2A
7618:  MOVWF  FF6
761A:  MOVLW  1B
761C:  MOVWF  FF7
761E:  CLRF   19
7620:  BTFSC  FF2.7
7622:  BSF    19.7
7624:  BCF    FF2.7
7626:  CALL   04A2
762A:  BTFSC  19.7
762C:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,16, console); 
762E:  MOVLW  01
7630:  MOVLB  7
7632:  MOVWF  xD7
7634:  MOVLW  10
7636:  MOVWF  xD8
7638:  MOVLW  06
763A:  MOVWF  xDA
763C:  MOVLW  CB
763E:  MOVWF  xD9
7640:  MOVLB  0
7642:  CALL   6652
....................          EEPROM_write(strobe_nameconsole,16,console); 
7646:  MOVLB  7
7648:  CLRF   xEF
764A:  CLRF   xEE
764C:  CLRF   xED
764E:  MOVLW  66
7650:  MOVWF  xEC
7652:  CLRF   xF3
7654:  CLRF   xF2
7656:  CLRF   xF1
7658:  MOVLW  10
765A:  MOVWF  xF0
765C:  MOVLW  06
765E:  MOVWF  xF5
7660:  MOVLW  CB
7662:  MOVWF  xF4
7664:  MOVLB  0
7666:  CALL   4458
....................          fprintf(COM2," OK\n\r"); 
766A:  MOVLW  3C
766C:  MOVWF  FF6
766E:  MOVLW  1B
7670:  MOVWF  FF7
7672:  CLRF   19
7674:  BTFSC  FF2.7
7676:  BSF    19.7
7678:  BCF    FF2.7
767A:  CALL   04A2
767E:  BTFSC  19.7
7680:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
7682:  CLRF   FEA
7684:  MOVLW  41
7686:  MOVWF  FE9
7688:  MOVLW  00
768A:  CALL   01BE
768E:  TBLRD*-
7690:  TBLRD*+
7692:  MOVF   FF5,W
7694:  MOVWF  FEE
7696:  IORLW  00
7698:  BNZ   7690
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
769A:  MOVLW  01
769C:  MOVLB  7
769E:  MOVWF  xD8
76A0:  MOVLW  49
76A2:  MOVWF  xD7
76A4:  CLRF   xDA
76A6:  MOVLW  41
76A8:  MOVWF  xD9
76AA:  MOVLB  0
76AC:  CALL   678A
76B0:  MOVF   01,F
76B2:  BTFSS  FD8.2
76B4:  BRA    791A
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
*
7780:  MOVLB  8
7782:  CLRF   xCB
7784:  CLRF   xCA
7786:  CLRF   xC9
7788:  MOVLW  91
778A:  MOVWF  xC8
778C:  MOVLB  0
778E:  CALL   3316
7792:  BTFSC  19.7
7794:  BSF    FF2.7
7796:  MOVFF  01,6C6
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
779A:  MOVLB  6
779C:  MOVF   xC6,F
779E:  BNZ   77BE
77A0:  MOVLW  42
77A2:  MOVWF  FF6
77A4:  MOVLW  1B
77A6:  MOVWF  FF7
77A8:  CLRF   19
77AA:  BTFSC  FF2.7
77AC:  BSF    19.7
77AE:  BCF    FF2.7
77B0:  MOVLB  0
77B2:  CALL   04A2
77B6:  BTFSC  19.7
77B8:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
77BA:  BRA    77D8
77BC:  MOVLB  6
77BE:  MOVLW  46
77C0:  MOVWF  FF6
77C2:  MOVLW  1B
77C4:  MOVWF  FF7
77C6:  CLRF   19
77C8:  BTFSC  FF2.7
77CA:  BSF    19.7
77CC:  BCF    FF2.7
77CE:  MOVLB  0
77D0:  CALL   04A2
77D4:  BTFSC  19.7
77D6:  BSF    FF2.7
77D8:  CLRF   19
77DA:  BTFSC  FF2.7
77DC:  BSF    19.7
77DE:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
77E0:  MOVLB  8
77E2:  CLRF   xCB
77E4:  CLRF   xCA
77E6:  CLRF   xC9
77E8:  MOVLW  94
77EA:  MOVWF  xC8
77EC:  MOVLB  0
77EE:  CALL   3316
77F2:  BTFSC  19.7
77F4:  BSF    FF2.7
77F6:  MOVFF  01,141
77FA:  CLRF   19
77FC:  BTFSC  FF2.7
77FE:  BSF    19.7
7800:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
7802:  MOVLW  5B
7804:  MOVLB  8
7806:  MOVWF  xE8
7808:  MOVLB  0
780A:  CALL   045C
780E:  BTFSC  19.7
7810:  BSF    FF2.7
7812:  MOVFF  141,7D7
7816:  MOVLW  1B
7818:  MOVLB  7
781A:  MOVWF  xD8
781C:  MOVLB  0
781E:  GOTO   6C7A
7822:  CLRF   19
7824:  BTFSC  FF2.7
7826:  BSF    19.7
7828:  BCF    FF2.7
782A:  MOVLW  5D
782C:  MOVLB  8
782E:  MOVWF  xE8
7830:  MOVLB  0
7832:  CALL   045C
7836:  BTFSC  19.7
7838:  BSF    FF2.7
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
783A:  MOVFF  100,7D7
783E:  MOVLW  01
7840:  MOVLB  7
7842:  MOVWF  xD8
7844:  MOVLB  0
7846:  CALL   6898
784A:  CLRF   19
784C:  BTFSC  FF2.7
784E:  BSF    19.7
7850:  BCF    FF2.7
7852:  MOVLW  2F
7854:  MOVLB  8
7856:  MOVWF  xE8
7858:  MOVLB  0
785A:  CALL   045C
785E:  BTFSC  19.7
7860:  BSF    FF2.7
7862:  MOVFF  FF,7D7
7866:  MOVLW  01
7868:  MOVLB  7
786A:  MOVWF  xD8
786C:  MOVLB  0
786E:  CALL   6898
7872:  CLRF   19
7874:  BTFSC  FF2.7
7876:  BSF    19.7
7878:  BCF    FF2.7
787A:  MOVLW  20
787C:  MOVLB  8
787E:  MOVWF  xE8
7880:  MOVLB  0
7882:  CALL   045C
7886:  BTFSC  19.7
7888:  BSF    FF2.7
788A:  MOVFF  101,7D7
788E:  MOVLW  01
7890:  MOVLB  7
7892:  MOVWF  xD8
7894:  MOVLB  0
7896:  CALL   6898
789A:  CLRF   19
789C:  BTFSC  FF2.7
789E:  BSF    19.7
78A0:  BCF    FF2.7
78A2:  MOVLW  3A
78A4:  MOVLB  8
78A6:  MOVWF  xE8
78A8:  MOVLB  0
78AA:  CALL   045C
78AE:  BTFSC  19.7
78B0:  BSF    FF2.7
78B2:  MOVFF  102,7D7
78B6:  MOVLW  01
78B8:  MOVLB  7
78BA:  MOVWF  xD8
78BC:  MOVLB  0
78BE:  CALL   6898
78C2:  CLRF   19
78C4:  BTFSC  FF2.7
78C6:  BSF    19.7
78C8:  BCF    FF2.7
78CA:  MOVLW  3A
78CC:  MOVLB  8
78CE:  MOVWF  xE8
78D0:  MOVLB  0
78D2:  CALL   045C
78D6:  BTFSC  19.7
78D8:  BSF    FF2.7
78DA:  MOVFF  103,7D7
78DE:  MOVLW  01
78E0:  MOVLB  7
78E2:  MOVWF  xD8
78E4:  MOVLB  0
78E6:  CALL   6898
78EA:  CLRF   19
78EC:  BTFSC  FF2.7
78EE:  BSF    19.7
78F0:  BCF    FF2.7
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
78F2:  MOVLW  0A
78F4:  MOVLB  8
78F6:  MOVWF  xE8
78F8:  MOVLB  0
78FA:  CALL   045C
78FE:  BTFSC  19.7
7900:  BSF    FF2.7
7902:  CLRF   19
7904:  BTFSC  FF2.7
7906:  BSF    19.7
7908:  BCF    FF2.7
790A:  MOVLW  0D
790C:  MOVLB  8
790E:  MOVWF  xE8
7910:  MOVLB  0
7912:  CALL   045C
7916:  BTFSC  19.7
7918:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
791A:  CLRF   FEA
791C:  MOVLW  41
791E:  MOVWF  FE9
7920:  MOVLW  00
7922:  CALL   01D0
7926:  TBLRD*-
7928:  TBLRD*+
792A:  MOVF   FF5,W
792C:  MOVWF  FEE
792E:  IORLW  00
7930:  BNZ   7928
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7932:  MOVLW  01
7934:  MOVLB  7
7936:  MOVWF  xD8
7938:  MOVLW  49
793A:  MOVWF  xD7
793C:  CLRF   xDA
793E:  MOVLW  41
7940:  MOVWF  xD9
7942:  MOVLB  0
7944:  CALL   678A
7948:  MOVF   01,F
794A:  BTFSS  FD8.2
794C:  BRA    7B76
....................       { 
....................          fprintf(COM2,"Year>"); 
794E:  MOVLW  4A
7950:  MOVWF  FF6
7952:  MOVLW  1B
7954:  MOVWF  FF7
7956:  CLRF   19
7958:  BTFSC  FF2.7
795A:  BSF    19.7
795C:  BCF    FF2.7
795E:  CALL   04A2
7962:  BTFSC  19.7
7964:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7966:  MOVLW  01
7968:  MOVLB  7
796A:  MOVWF  xD7
796C:  MOVLW  03
796E:  MOVWF  xD8
7970:  MOVLW  07
7972:  MOVWF  xDA
7974:  MOVLW  A3
7976:  MOVWF  xD9
7978:  MOVLB  0
797A:  CALL   6652
....................          year=(unsigned int8)strtoi(temp); 
797E:  MOVLW  07
7980:  MOVLB  7
7982:  MOVWF  xD8
7984:  MOVLW  A3
7986:  MOVWF  xD7
7988:  MOVLB  0
798A:  CALL   6D40
798E:  MOVFF  01,FE
....................          fprintf(COM2,"Month>"); 
7992:  MOVLW  50
7994:  MOVWF  FF6
7996:  MOVLW  1B
7998:  MOVWF  FF7
799A:  CLRF   19
799C:  BTFSC  FF2.7
799E:  BSF    19.7
79A0:  BCF    FF2.7
79A2:  CALL   04A2
79A6:  BTFSC  19.7
79A8:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
79AA:  MOVLW  01
79AC:  MOVLB  7
79AE:  MOVWF  xD7
79B0:  MOVLW  03
79B2:  MOVWF  xD8
79B4:  MOVLW  07
79B6:  MOVWF  xDA
79B8:  MOVLW  A3
79BA:  MOVWF  xD9
79BC:  MOVLB  0
79BE:  CALL   6652
....................          mon=(unsigned int8)strtoi(temp); 
79C2:  MOVLW  07
79C4:  MOVLB  7
79C6:  MOVWF  xD8
79C8:  MOVLW  A3
79CA:  MOVWF  xD7
79CC:  MOVLB  0
79CE:  CALL   6D40
79D2:  MOVFF  01,FF
....................          fprintf(COM2,"Date>"); 
79D6:  MOVLW  58
79D8:  MOVWF  FF6
79DA:  MOVLW  1B
79DC:  MOVWF  FF7
79DE:  CLRF   19
79E0:  BTFSC  FF2.7
79E2:  BSF    19.7
79E4:  BCF    FF2.7
79E6:  CALL   04A2
79EA:  BTFSC  19.7
79EC:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
79EE:  MOVLW  01
79F0:  MOVLB  7
79F2:  MOVWF  xD7
79F4:  MOVLW  03
79F6:  MOVWF  xD8
79F8:  MOVLW  07
79FA:  MOVWF  xDA
79FC:  MOVLW  A3
79FE:  MOVWF  xD9
7A00:  MOVLB  0
7A02:  CALL   6652
....................          date = (unsigned int8)strtoi(temp); 
7A06:  MOVLW  07
7A08:  MOVLB  7
7A0A:  MOVWF  xD8
7A0C:  MOVLW  A3
7A0E:  MOVWF  xD7
7A10:  MOVLB  0
7A12:  CALL   6D40
7A16:  MOVFF  01,100
....................          fprintf(COM2,"Day>"); 
7A1A:  MOVLW  5E
7A1C:  MOVWF  FF6
7A1E:  MOVLW  1B
7A20:  MOVWF  FF7
7A22:  CLRF   19
7A24:  BTFSC  FF2.7
7A26:  BSF    19.7
7A28:  BCF    FF2.7
7A2A:  CALL   04A2
7A2E:  BTFSC  19.7
7A30:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7A32:  MOVLW  01
7A34:  MOVLB  7
7A36:  MOVWF  xD7
7A38:  MOVLW  03
7A3A:  MOVWF  xD8
7A3C:  MOVLW  07
7A3E:  MOVWF  xDA
7A40:  MOVLW  A3
7A42:  MOVWF  xD9
7A44:  MOVLB  0
7A46:  CALL   6652
....................          day = (unsigned int8)strtoi(temp); 
7A4A:  MOVLW  07
7A4C:  MOVLB  7
7A4E:  MOVWF  xD8
7A50:  MOVLW  A3
7A52:  MOVWF  xD7
7A54:  MOVLB  0
7A56:  CALL   6D40
7A5A:  MOVFF  01,FD
....................          fprintf(COM2,"Hour>"); 
7A5E:  MOVLW  64
7A60:  MOVWF  FF6
7A62:  MOVLW  1B
7A64:  MOVWF  FF7
7A66:  CLRF   19
7A68:  BTFSC  FF2.7
7A6A:  BSF    19.7
7A6C:  BCF    FF2.7
7A6E:  CALL   04A2
7A72:  BTFSC  19.7
7A74:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7A76:  MOVLW  01
7A78:  MOVLB  7
7A7A:  MOVWF  xD7
7A7C:  MOVLW  03
7A7E:  MOVWF  xD8
7A80:  MOVLW  07
7A82:  MOVWF  xDA
7A84:  MOVLW  A3
7A86:  MOVWF  xD9
7A88:  MOVLB  0
7A8A:  CALL   6652
....................          h = (unsigned int8)strtoi(temp); 
7A8E:  MOVLW  07
7A90:  MOVLB  7
7A92:  MOVWF  xD8
7A94:  MOVLW  A3
7A96:  MOVWF  xD7
7A98:  MOVLB  0
7A9A:  CALL   6D40
7A9E:  MOVFF  01,101
....................          fprintf(COM2,"Minutes>"); 
7AA2:  MOVLW  6A
7AA4:  MOVWF  FF6
7AA6:  MOVLW  1B
7AA8:  MOVWF  FF7
7AAA:  CLRF   19
7AAC:  BTFSC  FF2.7
7AAE:  BSF    19.7
7AB0:  BCF    FF2.7
7AB2:  CALL   04A2
7AB6:  BTFSC  19.7
7AB8:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7ABA:  MOVLW  01
7ABC:  MOVLB  7
7ABE:  MOVWF  xD7
7AC0:  MOVLW  03
7AC2:  MOVWF  xD8
7AC4:  MOVLW  07
7AC6:  MOVWF  xDA
7AC8:  MOVLW  A3
7ACA:  MOVWF  xD9
7ACC:  MOVLB  0
7ACE:  CALL   6652
....................          min = (unsigned int8)strtoi(temp);                   
7AD2:  MOVLW  07
7AD4:  MOVLB  7
7AD6:  MOVWF  xD8
7AD8:  MOVLW  A3
7ADA:  MOVWF  xD7
7ADC:  MOVLB  0
7ADE:  CALL   6D40
7AE2:  MOVFF  01,102
....................          fprintf(COM2,"Seconds>"); 
7AE6:  MOVLW  74
7AE8:  MOVWF  FF6
7AEA:  MOVLW  1B
7AEC:  MOVWF  FF7
7AEE:  CLRF   19
7AF0:  BTFSC  FF2.7
7AF2:  BSF    19.7
7AF4:  BCF    FF2.7
7AF6:  CALL   04A2
7AFA:  BTFSC  19.7
7AFC:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7AFE:  MOVLW  01
7B00:  MOVLB  7
7B02:  MOVWF  xD7
7B04:  MOVLW  03
7B06:  MOVWF  xD8
7B08:  MOVLW  07
7B0A:  MOVWF  xDA
7B0C:  MOVLW  A3
7B0E:  MOVWF  xD9
7B10:  MOVLB  0
7B12:  CALL   6652
....................          sec = (unsigned int8)strtoi(temp);                   
7B16:  MOVLW  07
7B18:  MOVLB  7
7B1A:  MOVWF  xD8
7B1C:  MOVLW  A3
7B1E:  MOVWF  xD7
7B20:  MOVLB  0
7B22:  CALL   6D40
7B26:  MOVFF  01,103
7B2A:  CLRF   19
7B2C:  BTFSC  FF2.7
7B2E:  BSF    19.7
7B30:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
7B32:  MOVLW  0A
7B34:  MOVLB  8
7B36:  MOVWF  xE8
7B38:  MOVLB  0
7B3A:  CALL   045C
7B3E:  BTFSC  19.7
7B40:  BSF    FF2.7
7B42:  CLRF   19
7B44:  BTFSC  FF2.7
7B46:  BSF    19.7
7B48:  BCF    FF2.7
7B4A:  MOVLW  0D
7B4C:  MOVLB  8
7B4E:  MOVWF  xE8
7B50:  MOVLB  0
7B52:  CALL   045C
7B56:  BTFSC  19.7
7B58:  BSF    FF2.7
....................          rtc_set_datetime(date,mon,year,day,h,min); 
7B5A:  MOVFF  100,7D7
7B5E:  MOVFF  FF,7D8
7B62:  MOVFF  FE,7D9
7B66:  MOVFF  FD,7DA
7B6A:  MOVFF  101,7DB
7B6E:  MOVFF  102,7DC
7B72:  GOTO   6E7A
....................       } 
....................       strcpy(buffer2,"MS"); 
7B76:  CLRF   FEA
7B78:  MOVLW  41
7B7A:  MOVWF  FE9
7B7C:  MOVLW  00
7B7E:  CALL   01E4
7B82:  TBLRD*-
7B84:  TBLRD*+
7B86:  MOVF   FF5,W
7B88:  MOVWF  FEE
7B8A:  IORLW  00
7B8C:  BNZ   7B84
....................       if(!stringcomp(buffer_uart,buffer2)) 
7B8E:  MOVLW  01
7B90:  MOVLB  7
7B92:  MOVWF  xD8
7B94:  MOVLW  49
7B96:  MOVWF  xD7
7B98:  CLRF   xDA
7B9A:  MOVLW  41
7B9C:  MOVWF  xD9
7B9E:  MOVLB  0
7BA0:  CALL   678A
7BA4:  MOVF   01,F
7BA6:  BTFSS  FD8.2
7BA8:  BRA    7CBC
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
7BAA:  MOVLW  7E
7BAC:  MOVWF  FF6
7BAE:  MOVLW  1B
7BB0:  MOVWF  FF7
7BB2:  CLRF   19
7BB4:  BTFSC  FF2.7
7BB6:  BSF    19.7
7BB8:  BCF    FF2.7
7BBA:  CALL   04A2
7BBE:  BTFSC  19.7
7BC0:  BSF    FF2.7
7BC2:  CLRF   19
7BC4:  BTFSC  FF2.7
7BC6:  BSF    19.7
7BC8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7BCA:  MOVLW  0A
7BCC:  MOVLB  8
7BCE:  MOVWF  xE8
7BD0:  MOVLB  0
7BD2:  CALL   045C
7BD6:  BTFSC  19.7
7BD8:  BSF    FF2.7
7BDA:  CLRF   19
7BDC:  BTFSC  FF2.7
7BDE:  BSF    19.7
7BE0:  BCF    FF2.7
7BE2:  MOVLW  0D
7BE4:  MOVLB  8
7BE6:  MOVWF  xE8
7BE8:  MOVLB  0
7BEA:  CALL   045C
7BEE:  BTFSC  19.7
7BF0:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
7BF2:  MOVLW  9E
7BF4:  MOVWF  FF6
7BF6:  MOVLW  1B
7BF8:  MOVWF  FF7
7BFA:  CLRF   19
7BFC:  BTFSC  FF2.7
7BFE:  BSF    19.7
7C00:  BCF    FF2.7
7C02:  CALL   04A2
7C06:  BTFSC  19.7
7C08:  BSF    FF2.7
7C0A:  CLRF   19
7C0C:  BTFSC  FF2.7
7C0E:  BSF    19.7
7C10:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7C12:  MOVLW  0A
7C14:  MOVLB  8
7C16:  MOVWF  xE8
7C18:  MOVLB  0
7C1A:  CALL   045C
7C1E:  BTFSC  19.7
7C20:  BSF    FF2.7
7C22:  CLRF   19
7C24:  BTFSC  FF2.7
7C26:  BSF    19.7
7C28:  BCF    FF2.7
7C2A:  MOVLW  0D
7C2C:  MOVLB  8
7C2E:  MOVWF  xE8
7C30:  MOVLB  0
7C32:  CALL   045C
7C36:  BTFSC  19.7
7C38:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7C3A:  MOVLW  01
7C3C:  MOVLB  7
7C3E:  MOVWF  xD7
7C40:  MOVLW  03
7C42:  MOVWF  xD8
7C44:  MOVLW  07
7C46:  MOVWF  xDA
7C48:  MOVLW  A3
7C4A:  MOVWF  xD9
7C4C:  MOVLB  0
7C4E:  CALL   6652
....................           mode_sl = (unsigned int8)strtoi(temp); 
7C52:  MOVLW  07
7C54:  MOVLB  7
7C56:  MOVWF  xD8
7C58:  MOVLW  A3
7C5A:  MOVWF  xD7
7C5C:  MOVLB  0
7C5E:  CALL   6D40
7C62:  MOVFF  01,6C6
7C66:  CLRF   19
7C68:  BTFSC  FF2.7
7C6A:  BSF    19.7
7C6C:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
7C6E:  MOVLB  8
7C70:  CLRF   xD3
7C72:  CLRF   xD2
7C74:  CLRF   xD1
7C76:  MOVLW  91
7C78:  MOVWF  xD0
7C7A:  MOVFF  6C6,8D4
7C7E:  MOVLB  0
7C80:  CALL   3866
7C84:  BTFSC  19.7
7C86:  BSF    FF2.7
....................           set_tris_a(0xff); 
7C88:  MOVLW  FF
7C8A:  MOVWF  F92
7C8C:  CLRF   19
7C8E:  BTFSC  FF2.7
7C90:  BSF    19.7
7C92:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7C94:  MOVLW  0A
7C96:  MOVLB  8
7C98:  MOVWF  xE8
7C9A:  MOVLB  0
7C9C:  CALL   045C
7CA0:  BTFSC  19.7
7CA2:  BSF    FF2.7
7CA4:  CLRF   19
7CA6:  BTFSC  FF2.7
7CA8:  BSF    19.7
7CAA:  BCF    FF2.7
7CAC:  MOVLW  0D
7CAE:  MOVLB  8
7CB0:  MOVWF  xE8
7CB2:  MOVLB  0
7CB4:  CALL   045C
7CB8:  BTFSC  19.7
7CBA:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"KP"); 
7CBC:  CLRF   FEA
7CBE:  MOVLW  41
7CC0:  MOVWF  FE9
7CC2:  MOVLW  00
7CC4:  CALL   01F8
7CC8:  TBLRD*-
7CCA:  TBLRD*+
7CCC:  MOVF   FF5,W
7CCE:  MOVWF  FEE
7CD0:  IORLW  00
7CD2:  BNZ   7CCA
....................       if(!stringcomp(buffer_uart,buffer2)) 
7CD4:  MOVLW  01
7CD6:  MOVLB  7
7CD8:  MOVWF  xD8
7CDA:  MOVLW  49
7CDC:  MOVWF  xD7
7CDE:  CLRF   xDA
7CE0:  MOVLW  41
7CE2:  MOVWF  xD9
7CE4:  MOVLB  0
7CE6:  CALL   678A
7CEA:  MOVF   01,F
7CEC:  BTFSS  FD8.2
7CEE:  BRA    7DFE
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
7CF0:  MOVLW  BE
7CF2:  MOVWF  FF6
7CF4:  MOVLW  1B
7CF6:  MOVWF  FF7
7CF8:  CLRF   19
7CFA:  BTFSC  FF2.7
7CFC:  BSF    19.7
7CFE:  BCF    FF2.7
7D00:  CALL   04A2
7D04:  BTFSC  19.7
7D06:  BSF    FF2.7
7D08:  CLRF   19
7D0A:  BTFSC  FF2.7
7D0C:  BSF    19.7
7D0E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7D10:  MOVLW  0A
7D12:  MOVLB  8
7D14:  MOVWF  xE8
7D16:  MOVLB  0
7D18:  CALL   045C
7D1C:  BTFSC  19.7
7D1E:  BSF    FF2.7
7D20:  CLRF   19
7D22:  BTFSC  FF2.7
7D24:  BSF    19.7
7D26:  BCF    FF2.7
7D28:  MOVLW  0D
7D2A:  MOVLB  8
7D2C:  MOVWF  xE8
7D2E:  MOVLB  0
7D30:  CALL   045C
7D34:  BTFSC  19.7
7D36:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
7D38:  MOVLW  DC
7D3A:  MOVWF  FF6
7D3C:  MOVLW  1B
7D3E:  MOVWF  FF7
7D40:  CLRF   19
7D42:  BTFSC  FF2.7
7D44:  BSF    19.7
7D46:  BCF    FF2.7
7D48:  CALL   04A2
7D4C:  BTFSC  19.7
7D4E:  BSF    FF2.7
7D50:  CLRF   19
7D52:  BTFSC  FF2.7
7D54:  BSF    19.7
7D56:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7D58:  MOVLW  0A
7D5A:  MOVLB  8
7D5C:  MOVWF  xE8
7D5E:  MOVLB  0
7D60:  CALL   045C
7D64:  BTFSC  19.7
7D66:  BSF    FF2.7
7D68:  CLRF   19
7D6A:  BTFSC  FF2.7
7D6C:  BSF    19.7
7D6E:  BCF    FF2.7
7D70:  MOVLW  0D
7D72:  MOVLB  8
7D74:  MOVWF  xE8
7D76:  MOVLB  0
7D78:  CALL   045C
7D7C:  BTFSC  19.7
7D7E:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7D80:  MOVLW  01
7D82:  MOVLB  7
7D84:  MOVWF  xD7
7D86:  MOVLW  03
7D88:  MOVWF  xD8
7D8A:  MOVLW  07
7D8C:  MOVWF  xDA
7D8E:  MOVLW  A3
7D90:  MOVWF  xD9
7D92:  MOVLB  0
7D94:  CALL   6652
....................           KP_mode = (unsigned int8)strtoi(temp); 
7D98:  MOVLW  07
7D9A:  MOVLB  7
7D9C:  MOVWF  xD8
7D9E:  MOVLW  A3
7DA0:  MOVWF  xD7
7DA2:  MOVLB  0
7DA4:  CALL   6D40
7DA8:  MOVFF  01,130
7DAC:  CLRF   19
7DAE:  BTFSC  FF2.7
7DB0:  BSF    19.7
7DB2:  BCF    FF2.7
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
7DB4:  MOVLB  8
7DB6:  CLRF   xD3
7DB8:  CLRF   xD2
7DBA:  CLRF   xD1
7DBC:  MOVLW  7F
7DBE:  MOVWF  xD0
7DC0:  MOVFF  130,8D4
7DC4:  MOVLB  0
7DC6:  CALL   3866
7DCA:  BTFSC  19.7
7DCC:  BSF    FF2.7
7DCE:  CLRF   19
7DD0:  BTFSC  FF2.7
7DD2:  BSF    19.7
7DD4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7DD6:  MOVLW  0A
7DD8:  MOVLB  8
7DDA:  MOVWF  xE8
7DDC:  MOVLB  0
7DDE:  CALL   045C
7DE2:  BTFSC  19.7
7DE4:  BSF    FF2.7
7DE6:  CLRF   19
7DE8:  BTFSC  FF2.7
7DEA:  BSF    19.7
7DEC:  BCF    FF2.7
7DEE:  MOVLW  0D
7DF0:  MOVLB  8
7DF2:  MOVWF  xE8
7DF4:  MOVLB  0
7DF6:  CALL   045C
7DFA:  BTFSC  19.7
7DFC:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"tran time"); 
7DFE:  CLRF   FEA
7E00:  MOVLW  41
7E02:  MOVWF  FE9
7E04:  MOVLW  00
7E06:  CALL   020C
7E0A:  TBLRD*-
7E0C:  TBLRD*+
7E0E:  MOVF   FF5,W
7E10:  MOVWF  FEE
7E12:  IORLW  00
7E14:  BNZ   7E0C
....................       if(!stringcomp(buffer_uart,buffer2)) 
7E16:  MOVLW  01
7E18:  MOVLB  7
7E1A:  MOVWF  xD8
7E1C:  MOVLW  49
7E1E:  MOVWF  xD7
7E20:  CLRF   xDA
7E22:  MOVLW  41
7E24:  MOVWF  xD9
7E26:  MOVLB  0
7E28:  CALL   678A
7E2C:  MOVF   01,F
7E2E:  BNZ   7EF6
....................       { 
....................           fprintf(COM2,"Input Number"); 
7E30:  MOVLW  FA
7E32:  MOVWF  FF6
7E34:  MOVLW  1B
7E36:  MOVWF  FF7
7E38:  CLRF   19
7E3A:  BTFSC  FF2.7
7E3C:  BSF    19.7
7E3E:  BCF    FF2.7
7E40:  CALL   04A2
7E44:  BTFSC  19.7
7E46:  BSF    FF2.7
7E48:  CLRF   19
7E4A:  BTFSC  FF2.7
7E4C:  BSF    19.7
7E4E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7E50:  MOVLW  0A
7E52:  MOVLB  8
7E54:  MOVWF  xE8
7E56:  MOVLB  0
7E58:  CALL   045C
7E5C:  BTFSC  19.7
7E5E:  BSF    FF2.7
7E60:  CLRF   19
7E62:  BTFSC  FF2.7
7E64:  BSF    19.7
7E66:  BCF    FF2.7
7E68:  MOVLW  0D
7E6A:  MOVLB  8
7E6C:  MOVWF  xE8
7E6E:  MOVLB  0
7E70:  CALL   045C
7E74:  BTFSC  19.7
7E76:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7E78:  MOVLW  01
7E7A:  MOVLB  7
7E7C:  MOVWF  xD7
7E7E:  MOVLW  03
7E80:  MOVWF  xD8
7E82:  MOVLW  07
7E84:  MOVWF  xDA
7E86:  MOVLW  A3
7E88:  MOVWF  xD9
7E8A:  MOVLB  0
7E8C:  CALL   6652
....................           delaycharaction = (unsigned int8)strtoi(temp); 
7E90:  MOVLW  07
7E92:  MOVLB  7
7E94:  MOVWF  xD8
7E96:  MOVLW  A3
7E98:  MOVWF  xD7
7E9A:  MOVLB  0
7E9C:  CALL   6D40
7EA0:  MOVFF  01,141
7EA4:  CLRF   19
7EA6:  BTFSC  FF2.7
7EA8:  BSF    19.7
7EAA:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
7EAC:  MOVLB  8
7EAE:  CLRF   xD3
7EB0:  CLRF   xD2
7EB2:  CLRF   xD1
7EB4:  MOVLW  94
7EB6:  MOVWF  xD0
7EB8:  MOVFF  141,8D4
7EBC:  MOVLB  0
7EBE:  CALL   3866
7EC2:  BTFSC  19.7
7EC4:  BSF    FF2.7
7EC6:  CLRF   19
7EC8:  BTFSC  FF2.7
7ECA:  BSF    19.7
7ECC:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7ECE:  MOVLW  0A
7ED0:  MOVLB  8
7ED2:  MOVWF  xE8
7ED4:  MOVLB  0
7ED6:  CALL   045C
7EDA:  BTFSC  19.7
7EDC:  BSF    FF2.7
7EDE:  CLRF   19
7EE0:  BTFSC  FF2.7
7EE2:  BSF    19.7
7EE4:  BCF    FF2.7
7EE6:  MOVLW  0D
7EE8:  MOVLB  8
7EEA:  MOVWF  xE8
7EEC:  MOVLB  0
7EEE:  CALL   045C
7EF2:  BTFSC  19.7
7EF4:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
7EF6:  CLRF   FEA
7EF8:  MOVLW  41
7EFA:  MOVWF  FE9
7EFC:  MOVLW  00
7EFE:  CALL   0226
7F02:  TBLRD*-
7F04:  TBLRD*+
7F06:  MOVF   FF5,W
7F08:  MOVWF  FEE
7F0A:  IORLW  00
7F0C:  BNZ   7F04
....................       if(!stringcomp(buffer_uart,buffer2)) 
7F0E:  MOVLW  01
7F10:  MOVLB  7
7F12:  MOVWF  xD8
7F14:  MOVLW  49
7F16:  MOVWF  xD7
7F18:  CLRF   xDA
7F1A:  MOVLW  41
7F1C:  MOVWF  xD9
7F1E:  MOVLB  0
7F20:  CALL   678A
7F24:  MOVF   01,F
7F26:  BTFSS  FD8.2
7F28:  BRA    8038
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
7F2A:  MOVLW  08
7F2C:  MOVWF  FF6
7F2E:  MOVLW  1C
7F30:  MOVWF  FF7
7F32:  CLRF   19
7F34:  BTFSC  FF2.7
7F36:  BSF    19.7
7F38:  BCF    FF2.7
7F3A:  CALL   04A2
7F3E:  BTFSC  19.7
7F40:  BSF    FF2.7
7F42:  CLRF   19
7F44:  BTFSC  FF2.7
7F46:  BSF    19.7
7F48:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7F4A:  MOVLW  0A
7F4C:  MOVLB  8
7F4E:  MOVWF  xE8
7F50:  MOVLB  0
7F52:  CALL   045C
7F56:  BTFSC  19.7
7F58:  BSF    FF2.7
7F5A:  CLRF   19
7F5C:  BTFSC  FF2.7
7F5E:  BSF    19.7
7F60:  BCF    FF2.7
7F62:  MOVLW  0D
7F64:  MOVLB  8
7F66:  MOVWF  xE8
7F68:  MOVLB  0
7F6A:  CALL   045C
7F6E:  BTFSC  19.7
7F70:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
7F72:  MOVLW  2E
7F74:  MOVWF  FF6
7F76:  MOVLW  1C
7F78:  MOVWF  FF7
7F7A:  CLRF   19
7F7C:  BTFSC  FF2.7
7F7E:  BSF    19.7
7F80:  BCF    FF2.7
7F82:  CALL   04A2
7F86:  BTFSC  19.7
7F88:  BSF    FF2.7
7F8A:  CLRF   19
7F8C:  BTFSC  FF2.7
7F8E:  BSF    19.7
7F90:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7F92:  MOVLW  0A
7F94:  MOVLB  8
7F96:  MOVWF  xE8
7F98:  MOVLB  0
7F9A:  CALL   045C
7F9E:  BTFSC  19.7
7FA0:  BSF    FF2.7
7FA2:  CLRF   19
7FA4:  BTFSC  FF2.7
7FA6:  BSF    19.7
7FA8:  BCF    FF2.7
7FAA:  MOVLW  0D
7FAC:  MOVLB  8
7FAE:  MOVWF  xE8
7FB0:  MOVLB  0
7FB2:  CALL   045C
7FB6:  BTFSC  19.7
7FB8:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7FBA:  MOVLW  01
7FBC:  MOVLB  7
7FBE:  MOVWF  xD7
7FC0:  MOVLW  03
7FC2:  MOVWF  xD8
7FC4:  MOVLW  07
7FC6:  MOVWF  xDA
7FC8:  MOVLW  A3
7FCA:  MOVWF  xD9
7FCC:  MOVLB  0
7FCE:  CALL   6652
....................           type_KB=(unsigned int8)strtoi(temp); 
7FD2:  MOVLW  07
7FD4:  MOVLB  7
7FD6:  MOVWF  xD8
7FD8:  MOVLW  A3
7FDA:  MOVWF  xD7
7FDC:  MOVLB  0
7FDE:  CALL   6D40
7FE2:  MOVFF  01,134
7FE6:  CLRF   19
7FE8:  BTFSC  FF2.7
7FEA:  BSF    19.7
7FEC:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
7FEE:  MOVLB  8
7FF0:  CLRF   xD3
7FF2:  CLRF   xD2
7FF4:  CLRF   xD1
7FF6:  MOVLW  7E
7FF8:  MOVWF  xD0
7FFA:  MOVFF  134,8D4
7FFE:  MOVLB  0
8000:  CALL   3866
8004:  BTFSC  19.7
8006:  BSF    FF2.7
8008:  CLRF   19
800A:  BTFSC  FF2.7
800C:  BSF    19.7
800E:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
8010:  MOVLW  0A
8012:  MOVLB  8
8014:  MOVWF  xE8
8016:  MOVLB  0
8018:  CALL   045C
801C:  BTFSC  19.7
801E:  BSF    FF2.7
8020:  CLRF   19
8022:  BTFSC  FF2.7
8024:  BSF    19.7
8026:  BCF    FF2.7
8028:  MOVLW  0D
802A:  MOVLB  8
802C:  MOVWF  xE8
802E:  MOVLB  0
8030:  CALL   045C
8034:  BTFSC  19.7
8036:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
8038:  CLRF   FEA
803A:  MOVLW  41
803C:  MOVWF  FE9
803E:  MOVLW  00
8040:  CALL   023C
8044:  TBLRD*-
8046:  TBLRD*+
8048:  MOVF   FF5,W
804A:  MOVWF  FEE
804C:  IORLW  00
804E:  BNZ   8046
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
8050:  MOVLW  01
8052:  MOVLB  7
8054:  MOVWF  xD8
8056:  MOVLW  49
8058:  MOVWF  xD7
805A:  CLRF   xDA
805C:  MOVLW  41
805E:  MOVWF  xD9
8060:  MOVLB  0
8062:  CALL   678A
8066:  MOVF   01,F
8068:  BTFSS  FD8.2
806A:  BRA    8252
....................       { 
....................          printf("h-> Help\n\r"); 
806C:  MOVLW  54
806E:  MOVWF  FF6
8070:  MOVLW  1C
8072:  MOVWF  FF7
8074:  CLRF   19
8076:  BTFSC  FF2.7
8078:  BSF    19.7
807A:  BCF    FF2.7
807C:  CALL   04A2
8080:  BTFSC  19.7
8082:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
8084:  MOVLW  60
8086:  MOVWF  FF6
8088:  MOVLW  1C
808A:  MOVWF  FF7
808C:  CLRF   19
808E:  BTFSC  FF2.7
8090:  BSF    19.7
8092:  BCF    FF2.7
8094:  CALL   04A2
8098:  BTFSC  19.7
809A:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
809C:  MOVLW  72
809E:  MOVWF  FF6
80A0:  MOVLW  1C
80A2:  MOVWF  FF7
80A4:  CLRF   19
80A6:  BTFSC  FF2.7
80A8:  BSF    19.7
80AA:  BCF    FF2.7
80AC:  CALL   04A2
80B0:  BTFSC  19.7
80B2:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
80B4:  MOVLW  84
80B6:  MOVWF  FF6
80B8:  MOVLW  1C
80BA:  MOVWF  FF7
80BC:  CLRF   19
80BE:  BTFSC  FF2.7
80C0:  BSF    19.7
80C2:  BCF    FF2.7
80C4:  CALL   04A2
80C8:  BTFSC  19.7
80CA:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
80CC:  MOVLW  A4
80CE:  MOVWF  FF6
80D0:  MOVLW  1C
80D2:  MOVWF  FF7
80D4:  CLRF   19
80D6:  BTFSC  FF2.7
80D8:  BSF    19.7
80DA:  BCF    FF2.7
80DC:  CALL   04A2
80E0:  BTFSC  19.7
80E2:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
80E4:  MOVLW  C0
80E6:  MOVWF  FF6
80E8:  MOVLW  1C
80EA:  MOVWF  FF7
80EC:  CLRF   19
80EE:  BTFSC  FF2.7
80F0:  BSF    19.7
80F2:  BCF    FF2.7
80F4:  CALL   04A2
80F8:  BTFSC  19.7
80FA:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
80FC:  MOVLW  CE
80FE:  MOVWF  FF6
8100:  MOVLW  1C
8102:  MOVWF  FF7
8104:  CLRF   19
8106:  BTFSC  FF2.7
8108:  BSF    19.7
810A:  BCF    FF2.7
810C:  CALL   04A2
8110:  BTFSC  19.7
8112:  BSF    FF2.7
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
8114:  MOVLW  DA
8116:  MOVWF  FF6
8118:  MOVLW  1C
811A:  MOVWF  FF7
811C:  CLRF   19
811E:  BTFSC  FF2.7
8120:  BSF    19.7
8122:  BCF    FF2.7
8124:  CALL   04A2
8128:  BTFSC  19.7
812A:  BSF    FF2.7
812C:  CLRF   19
812E:  BTFSC  FF2.7
8130:  BSF    19.7
8132:  BCF    FF2.7
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
8134:  MOVLB  8
8136:  CLRF   xCB
8138:  CLRF   xCA
813A:  CLRF   xC9
813C:  MOVLW  7F
813E:  MOVWF  xC8
8140:  MOVLB  0
8142:  CALL   3316
8146:  BTFSC  19.7
8148:  BSF    FF2.7
814A:  MOVFF  01,130
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
814E:  MOVLB  1
8150:  MOVF   x30,F
8152:  BZ    8172
8154:  MOVLW  06
8156:  MOVWF  FF6
8158:  MOVLW  1D
815A:  MOVWF  FF7
815C:  CLRF   19
815E:  BTFSC  FF2.7
8160:  BSF    19.7
8162:  BCF    FF2.7
8164:  MOVLB  0
8166:  CALL   04A2
816A:  BTFSC  19.7
816C:  BSF    FF2.7
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
816E:  BRA    818C
8170:  MOVLB  1
8172:  MOVLW  28
8174:  MOVWF  FF6
8176:  MOVLW  1D
8178:  MOVWF  FF7
817A:  CLRF   19
817C:  BTFSC  FF2.7
817E:  BSF    19.7
8180:  BCF    FF2.7
8182:  MOVLB  0
8184:  CALL   04A2
8188:  BTFSC  19.7
818A:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
818C:  MOVLW  4C
818E:  MOVWF  FF6
8190:  MOVLW  1D
8192:  MOVWF  FF7
8194:  CLRF   19
8196:  BTFSC  FF2.7
8198:  BSF    19.7
819A:  BCF    FF2.7
819C:  CALL   04A2
81A0:  BTFSC  19.7
81A2:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
81A4:  MOVLW  74
81A6:  MOVWF  FF6
81A8:  MOVLW  1D
81AA:  MOVWF  FF7
81AC:  CLRF   19
81AE:  BTFSC  FF2.7
81B0:  BSF    19.7
81B2:  BCF    FF2.7
81B4:  CALL   04A2
81B8:  BTFSC  19.7
81BA:  BSF    FF2.7
81BC:  CLRF   19
81BE:  BTFSC  FF2.7
81C0:  BSF    19.7
81C2:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
81C4:  MOVLB  8
81C6:  CLRF   xCB
81C8:  CLRF   xCA
81CA:  CLRF   xC9
81CC:  MOVLW  7E
81CE:  MOVWF  xC8
81D0:  MOVLB  0
81D2:  CALL   3316
81D6:  BTFSC  19.7
81D8:  BSF    FF2.7
81DA:  MOVFF  01,7D7
81DE:  MOVLW  90
81E0:  MOVWF  FF6
81E2:  MOVLW  1D
81E4:  MOVWF  FF7
81E6:  CLRF   19
81E8:  BTFSC  FF2.7
81EA:  BSF    19.7
81EC:  BCF    FF2.7
81EE:  MOVLW  06
81F0:  MOVLB  8
81F2:  MOVWF  xDC
81F4:  MOVLB  0
81F6:  CALL   141A
81FA:  BTFSC  19.7
81FC:  BSF    FF2.7
81FE:  CLRF   19
8200:  BTFSC  FF2.7
8202:  BSF    19.7
8204:  BCF    FF2.7
8206:  MOVFF  7D7,8C8
820A:  MOVLW  18
820C:  MOVLB  8
820E:  MOVWF  xC9
8210:  MOVLB  0
8212:  CALL   152E
8216:  BTFSC  19.7
8218:  BSF    FF2.7
821A:  MOVLW  98
821C:  MOVWF  FF6
821E:  MOVLW  1D
8220:  MOVWF  FF7
8222:  CLRF   19
8224:  BTFSC  FF2.7
8226:  BSF    19.7
8228:  BCF    FF2.7
822A:  MOVLW  1D
822C:  MOVLB  8
822E:  MOVWF  xDC
8230:  MOVLB  0
8232:  CALL   141A
8236:  BTFSC  19.7
8238:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
823A:  MOVLW  B6
823C:  MOVWF  FF6
823E:  MOVLW  1D
8240:  MOVWF  FF7
8242:  CLRF   19
8244:  BTFSC  FF2.7
8246:  BSF    19.7
8248:  BCF    FF2.7
824A:  CALL   04A2
824E:  BTFSC  19.7
8250:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
8252:  CLRF   FEA
8254:  MOVLW  41
8256:  MOVWF  FE9
8258:  MOVLW  00
825A:  CALL   024E
825E:  TBLRD*-
8260:  TBLRD*+
8262:  MOVF   FF5,W
8264:  MOVWF  FEE
8266:  IORLW  00
8268:  BNZ   8260
....................       if(!stringcomp(buffer_uart,buffer2))  
826A:  MOVLW  01
826C:  MOVLB  7
826E:  MOVWF  xD8
8270:  MOVLW  49
8272:  MOVWF  xD7
8274:  CLRF   xDA
8276:  MOVLW  41
8278:  MOVWF  xD9
827A:  MOVLB  0
827C:  CALL   678A
8280:  MOVF   01,F
8282:  BTFSS  FD8.2
8284:  BRA    83CC
....................       { 
....................          fprintf(COM2,"old password:"); 
8286:  MOVLW  D0
8288:  MOVWF  FF6
828A:  MOVLW  1D
828C:  MOVWF  FF7
828E:  CLRF   19
8290:  BTFSC  FF2.7
8292:  BSF    19.7
8294:  BCF    FF2.7
8296:  CALL   04A2
829A:  BTFSC  19.7
829C:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
829E:  MOVLB  7
82A0:  CLRF   xDA
82A2:  CLRF   xD9
82A4:  CLRF   xD8
82A6:  CLRF   xD7
82A8:  CLRF   xDE
82AA:  CLRF   xDD
82AC:  CLRF   xDC
82AE:  MOVLW  14
82B0:  MOVWF  xDB
82B2:  CLRF   xE0
82B4:  MOVLW  55
82B6:  MOVWF  xDF
82B8:  MOVLB  0
82BA:  CALL   43B6
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
82BE:  MOVLW  02
82C0:  MOVLB  7
82C2:  MOVWF  xD7
82C4:  MOVLW  14
82C6:  MOVWF  xD8
82C8:  CLRF   xDA
82CA:  MOVLW  69
82CC:  MOVWF  xD9
82CE:  MOVLB  0
82D0:  CALL   6652
....................          if(!stringcomp(entpassword,password)) 
82D4:  MOVLB  7
82D6:  CLRF   xD8
82D8:  MOVLW  69
82DA:  MOVWF  xD7
82DC:  CLRF   xDA
82DE:  MOVLW  55
82E0:  MOVWF  xD9
82E2:  MOVLB  0
82E4:  CALL   678A
82E8:  MOVF   01,F
82EA:  BNZ   83B4
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
82EC:  MOVLW  DE
82EE:  MOVWF  FF6
82F0:  MOVLW  1D
82F2:  MOVWF  FF7
82F4:  CLRF   19
82F6:  BTFSC  FF2.7
82F8:  BSF    19.7
82FA:  BCF    FF2.7
82FC:  CALL   04A2
8300:  BTFSC  19.7
8302:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
8304:  MOVLW  02
8306:  MOVLB  7
8308:  MOVWF  xD7
830A:  MOVLW  14
830C:  MOVWF  xD8
830E:  CLRF   xDA
8310:  MOVLW  69
8312:  MOVWF  xD9
8314:  MOVLB  0
8316:  CALL   6652
....................             fprintf(COM2,"\n\ragain:"); 
831A:  MOVLW  E6
831C:  MOVWF  FF6
831E:  MOVLW  1D
8320:  MOVWF  FF7
8322:  CLRF   19
8324:  BTFSC  FF2.7
8326:  BSF    19.7
8328:  BCF    FF2.7
832A:  CALL   04A2
832E:  BTFSC  19.7
8330:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
8332:  MOVLW  02
8334:  MOVLB  7
8336:  MOVWF  xD7
8338:  MOVLW  14
833A:  MOVWF  xD8
833C:  CLRF   xDA
833E:  MOVLW  55
8340:  MOVWF  xD9
8342:  MOVLB  0
8344:  CALL   6652
....................             if(!stringcomp(entpassword,password)) 
8348:  MOVLB  7
834A:  CLRF   xD8
834C:  MOVLW  69
834E:  MOVWF  xD7
8350:  CLRF   xDA
8352:  MOVLW  55
8354:  MOVWF  xD9
8356:  MOVLB  0
8358:  CALL   678A
835C:  MOVF   01,F
835E:  BNZ   839A
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
8360:  MOVLB  7
8362:  CLRF   xEF
8364:  CLRF   xEE
8366:  CLRF   xED
8368:  CLRF   xEC
836A:  CLRF   xF3
836C:  CLRF   xF2
836E:  CLRF   xF1
8370:  MOVLW  14
8372:  MOVWF  xF0
8374:  CLRF   xF5
8376:  MOVLW  55
8378:  MOVWF  xF4
837A:  MOVLB  0
837C:  CALL   4458
....................                fprintf(COM2,"\n\rOK\n\r");    
8380:  MOVLW  F0
8382:  MOVWF  FF6
8384:  MOVLW  1D
8386:  MOVWF  FF7
8388:  CLRF   19
838A:  BTFSC  FF2.7
838C:  BSF    19.7
838E:  BCF    FF2.7
8390:  CALL   04A2
8394:  BTFSC  19.7
8396:  BSF    FF2.7
....................             } 
....................                else 
8398:  BRA    83B2
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
839A:  MOVLW  F8
839C:  MOVWF  FF6
839E:  MOVLW  1D
83A0:  MOVWF  FF7
83A2:  CLRF   19
83A4:  BTFSC  FF2.7
83A6:  BSF    19.7
83A8:  BCF    FF2.7
83AA:  CALL   04A2
83AE:  BTFSC  19.7
83B0:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
83B2:  BRA    83CC
....................             { 
....................                fprintf(COM2," X\n\r"); 
83B4:  MOVLW  00
83B6:  MOVWF  FF6
83B8:  MOVLW  1E
83BA:  MOVWF  FF7
83BC:  CLRF   19
83BE:  BTFSC  FF2.7
83C0:  BSF    19.7
83C2:  BCF    FF2.7
83C4:  CALL   04A2
83C8:  BTFSC  19.7
83CA:  BSF    FF2.7
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
83CC:  CLRF   FEA
83CE:  MOVLW  41
83D0:  MOVWF  FE9
83D2:  MOVLW  00
83D4:  CALL   0268
83D8:  TBLRD*-
83DA:  TBLRD*+
83DC:  MOVF   FF5,W
83DE:  MOVWF  FEE
83E0:  IORLW  00
83E2:  BNZ   83DA
....................       if(!stringcomp(buffer_uart,buffer2)) 
83E4:  MOVLW  01
83E6:  MOVLB  7
83E8:  MOVWF  xD8
83EA:  MOVLW  49
83EC:  MOVWF  xD7
83EE:  CLRF   xDA
83F0:  MOVLW  41
83F2:  MOVWF  xD9
83F4:  MOVLB  0
83F6:  CALL   678A
83FA:  MOVF   01,F
83FC:  BTFSS  FD8.2
83FE:  BRA    850E
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
8400:  MOVLW  06
8402:  MOVWF  FF6
8404:  MOVLW  1E
8406:  MOVWF  FF7
8408:  CLRF   19
840A:  BTFSC  FF2.7
840C:  BSF    19.7
840E:  BCF    FF2.7
8410:  CALL   04A2
8414:  BTFSC  19.7
8416:  BSF    FF2.7
8418:  CLRF   19
841A:  BTFSC  FF2.7
841C:  BSF    19.7
841E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
8420:  MOVLW  0A
8422:  MOVLB  8
8424:  MOVWF  xE8
8426:  MOVLB  0
8428:  CALL   045C
842C:  BTFSC  19.7
842E:  BSF    FF2.7
8430:  CLRF   19
8432:  BTFSC  FF2.7
8434:  BSF    19.7
8436:  BCF    FF2.7
8438:  MOVLW  0D
843A:  MOVLB  8
843C:  MOVWF  xE8
843E:  MOVLB  0
8440:  CALL   045C
8444:  BTFSC  19.7
8446:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
8448:  MOVLW  26
844A:  MOVWF  FF6
844C:  MOVLW  1E
844E:  MOVWF  FF7
8450:  CLRF   19
8452:  BTFSC  FF2.7
8454:  BSF    19.7
8456:  BCF    FF2.7
8458:  CALL   04A2
845C:  BTFSC  19.7
845E:  BSF    FF2.7
8460:  CLRF   19
8462:  BTFSC  FF2.7
8464:  BSF    19.7
8466:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
8468:  MOVLW  0A
846A:  MOVLB  8
846C:  MOVWF  xE8
846E:  MOVLB  0
8470:  CALL   045C
8474:  BTFSC  19.7
8476:  BSF    FF2.7
8478:  CLRF   19
847A:  BTFSC  FF2.7
847C:  BSF    19.7
847E:  BCF    FF2.7
8480:  MOVLW  0D
8482:  MOVLB  8
8484:  MOVWF  xE8
8486:  MOVLB  0
8488:  CALL   045C
848C:  BTFSC  19.7
848E:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
8490:  MOVLW  01
8492:  MOVLB  7
8494:  MOVWF  xD7
8496:  MOVLW  03
8498:  MOVWF  xD8
849A:  MOVLW  07
849C:  MOVWF  xDA
849E:  MOVLW  A3
84A0:  MOVWF  xD9
84A2:  MOVLB  0
84A4:  CALL   6652
....................           debugmode = (unsigned int8)strtoi(temp); 
84A8:  MOVLW  07
84AA:  MOVLB  7
84AC:  MOVWF  xD8
84AE:  MOVLW  A3
84B0:  MOVWF  xD7
84B2:  MOVLB  0
84B4:  CALL   6D40
84B8:  MOVFF  01,6BA
84BC:  CLRF   19
84BE:  BTFSC  FF2.7
84C0:  BSF    19.7
84C2:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
84C4:  MOVLB  8
84C6:  CLRF   xD3
84C8:  CLRF   xD2
84CA:  CLRF   xD1
84CC:  MOVLW  92
84CE:  MOVWF  xD0
84D0:  MOVFF  6BA,8D4
84D4:  MOVLB  0
84D6:  CALL   3866
84DA:  BTFSC  19.7
84DC:  BSF    FF2.7
84DE:  CLRF   19
84E0:  BTFSC  FF2.7
84E2:  BSF    19.7
84E4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
84E6:  MOVLW  0A
84E8:  MOVLB  8
84EA:  MOVWF  xE8
84EC:  MOVLB  0
84EE:  CALL   045C
84F2:  BTFSC  19.7
84F4:  BSF    FF2.7
84F6:  CLRF   19
84F8:  BTFSC  FF2.7
84FA:  BSF    19.7
84FC:  BCF    FF2.7
84FE:  MOVLW  0D
8500:  MOVLB  8
8502:  MOVWF  xE8
8504:  MOVLB  0
8506:  CALL   045C
850A:  BTFSC  19.7
850C:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
850E:  GOTO   8C5A (RETURN)
.................... //=============================================== 
....................  
....................  
.................... //========================= 
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
40C6:  MOVLB  1
40C8:  MOVF   x30,F
40CA:  BZ    4106
....................    { 
....................       if(count_kp<500)count_kp++; 
40CC:  MOVF   x33,W
40CE:  SUBLW  01
40D0:  BNC   40E0
40D2:  BNZ   40DA
40D4:  MOVF   x32,W
40D6:  SUBLW  F3
40D8:  BNC   40E0
40DA:  INCF   x32,F
40DC:  BTFSC  FD8.2
40DE:  INCF   x33,F
....................       if(count_kp==500) 
40E0:  MOVF   x32,W
40E2:  SUBLW  F4
40E4:  BNZ   4106
40E6:  DECFSZ x33,W
40E8:  BRA    4106
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
40EA:  MOVLW  CE
40EC:  MOVWF  FF6
40EE:  MOVLW  42
40F0:  MOVWF  FF7
40F2:  MOVLB  0
40F4:  CALL   04A2
....................             keyprss_off; 
40F8:  BCF    F92.7
40FA:  BCF    F89.7
....................             kp_st=0;     
40FC:  MOVLB  1
40FE:  CLRF   x31
....................             count_kp++; 
4100:  INCF   x32,F
4102:  BTFSC  FD8.2
4104:  INCF   x33,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
4106:  DECFSZ x2C,W
4108:  BRA    4124
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
410A:  MOVLB  6
410C:  MOVF   xC6,F
410E:  BNZ   4118
4110:  MOVLB  0
4112:  CALL   1E46
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
4116:  BRA    4122
4118:  MOVLB  0
411A:  CALL   30A2
411E:  MOVFF  01,8BE
4122:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
4124:  DECFSZ x2D,W
4126:  BRA    4140
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
4128:  MOVLB  6
412A:  MOVF   xC6,F
412C:  BNZ   4136
412E:  MOVLB  0
4130:  CALL   1E46
....................          else temp=kbd_getc_slv(); 
4134:  BRA    4140
4136:  MOVLB  0
4138:  CALL   30A2
413C:  MOVFF  01,8BE
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
4140:  MOVLB  6
4142:  MOVF   xAB,F
4144:  BNZ   4164
4146:  MOVF   xAA,F
4148:  BNZ   4164
414A:  MOVF   xA9,F
414C:  BNZ   4164
414E:  MOVF   xA8,W
4150:  SUBLW  04
4152:  BNC   4164
4154:  MOVLW  01
4156:  ADDWF  xA8,F
4158:  BTFSC  FD8.0
415A:  INCF   xA9,F
415C:  BTFSC  FD8.2
415E:  INCF   xAA,F
4160:  BTFSC  FD8.2
4162:  INCF   xAB,F
....................   if(mcr_timeout==5) 
4164:  MOVF   xA8,W
4166:  SUBLW  05
4168:  BNZ   41BE
416A:  MOVF   xA9,F
416C:  BNZ   41BE
416E:  MOVF   xAA,F
4170:  BNZ   41BE
4172:  MOVF   xAB,F
4174:  BNZ   41BE
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
4176:  DECFSZ xBE,W
4178:  BRA    4180
417A:  MOVLB  0
417C:  BRA    39F2
417E:  MOVLB  6
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
4180:  MOVLW  02
4182:  MOVWF  FEA
4184:  MOVLW  2A
4186:  MOVWF  FE9
4188:  CLRF   00
418A:  MOVLW  03
418C:  MOVWF  02
418E:  MOVLW  52
4190:  MOVWF  01
4192:  MOVLB  0
4194:  RCALL  3DF6
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
4196:  MOVLW  05
4198:  MOVWF  FEA
419A:  MOVLW  7C
419C:  MOVWF  FE9
419E:  CLRF   00
41A0:  MOVLW  01
41A2:  MOVWF  02
41A4:  MOVLW  2C
41A6:  MOVWF  01
41A8:  RCALL  3DF6
....................       //debug_card(); 
....................       count_reading_error=0; 
41AA:  MOVLB  6
41AC:  CLRF   xBF
....................       mcr_timeout++;   
41AE:  MOVLW  01
41B0:  ADDWF  xA8,F
41B2:  BTFSC  FD8.0
41B4:  INCF   xA9,F
41B6:  BTFSC  FD8.2
41B8:  INCF   xAA,F
41BA:  BTFSC  FD8.2
41BC:  INCF   xAB,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
41BE:  MOVLB  8
41C0:  CLRF   xCB
41C2:  CLRF   xCA
41C4:  CLRF   xC9
41C6:  MOVLW  94
41C8:  MOVWF  xC8
41CA:  MOVLB  0
41CC:  CALL   3316
41D0:  MOVFF  01,141
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
41D4:  MOVLW  02
41D6:  MOVLB  8
41D8:  MOVWF  xC5
41DA:  MOVLW  BC
41DC:  MOVWF  xC4
41DE:  CLRF   xC7
41E0:  MOVFF  141,8C6
41E4:  MOVLB  0
41E6:  CALL   343A
41EA:  MOVFF  02,03
41EE:  MOVF   xFC,W
41F0:  SUBWF  02,W
41F2:  BNC   4202
41F4:  BNZ   41FC
41F6:  MOVF   01,W
41F8:  SUBWF  xFB,W
41FA:  BC    4202
41FC:  INCF   xFB,F
41FE:  BTFSC  FD8.2
4200:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
4202:  MOVLW  02
4204:  MOVLB  8
4206:  MOVWF  xC5
4208:  MOVLW  BC
420A:  MOVWF  xC4
420C:  CLRF   xC7
420E:  MOVFF  141,8C6
4212:  MOVLB  0
4214:  CALL   343A
4218:  MOVFF  02,03
421C:  MOVF   01,W
421E:  SUBWF  xFB,W
4220:  BNZ   42C8
4222:  MOVF   03,W
4224:  SUBWF  xFC,W
4226:  BNZ   42C8
....................   { 
....................       charac_timeout++; 
4228:  INCF   xFB,F
422A:  BTFSC  FD8.2
422C:  INCF   xFC,F
....................       buf=get_countcard(); 
422E:  CALL   33E2
4232:  MOVFF  02,8BD
4236:  MOVFF  01,8BC
....................       if(buf<countcards) 
423A:  MOVLB  8
423C:  MOVF   xBD,W
423E:  SUBLW  03
4240:  BNC   4268
4242:  BNZ   424A
4244:  MOVF   xBC,W
4246:  SUBLW  A1
4248:  BNC   4268
....................       { 
....................          save_key_new(); 
424A:  MOVLB  0
424C:  BRA    3E10
....................          buf=buf+1; 
424E:  MOVLW  01
4250:  MOVLB  8
4252:  ADDWF  xBC,F
4254:  MOVLW  00
4256:  ADDWFC xBD,F
....................          save_coutcard(buf); 
4258:  MOVFF  8BD,8C0
425C:  MOVFF  8BC,8BF
4260:  MOVLB  0
4262:  RCALL  3F8E
....................       } 
....................          else 
4264:  BRA    4278
4266:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
4268:  MOVLW  DE
426A:  MOVWF  FF6
426C:  MOVLW  42
426E:  MOVWF  FF7
4270:  MOVLB  0
4272:  CALL   04A2
....................             return; 
4276:  BRA    42C8
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
4278:  MOVLW  EE
427A:  MOVWF  FF6
427C:  MOVLW  42
427E:  MOVWF  FF7
4280:  CALL   04A2
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
4284:  MOVLW  FE
4286:  MOVWF  FF6
4288:  MOVLW  42
428A:  MOVWF  FF7
428C:  MOVLW  14
428E:  MOVLB  8
4290:  MOVWF  xDC
4292:  MOVLB  0
4294:  CALL   141A
4298:  MOVLW  10
429A:  MOVWF  FE9
429C:  MOVFF  8BD,8C0
42A0:  MOVFF  8BC,8BF
42A4:  RCALL  3FD0
42A6:  MOVLW  15
42A8:  MOVWF  FF6
42AA:  MOVLW  43
42AC:  MOVWF  FF7
42AE:  MOVLW  03
42B0:  MOVLB  8
42B2:  MOVWF  xDC
42B4:  MOVLB  0
42B6:  CALL   141A
....................       data_avai=0; 
42BA:  MOVLB  6
42BC:  CLRF   xBD
....................       enable_getpin=0; 
42BE:  MOVLB  1
42C0:  CLRF   x2D
....................       //dis_getpin; 
....................       output_low(LED); 
42C2:  BCF    F92.6
42C4:  BCF    F89.6
42C6:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
42C8:  BCF    FF2.2
42CA:  GOTO   006C
.................... void main() 
.................... {  
*
8512:  CLRF   FF8
8514:  BCF    FD0.7
8516:  BSF    07.7
8518:  CLRF   FEA
851A:  CLRF   FE9
851C:  BCF    F94.0
851E:  BSF    F8B.0
8520:  CLRF   23
8522:  CLRF   22
8524:  CLRF   21
8526:  MOVLW  96
8528:  MOVWF  20
852A:  CLRF   27
852C:  MOVLW  01
852E:  MOVWF  26
8530:  MOVLW  C3
8532:  MOVWF  25
8534:  MOVLW  0F
8536:  MOVWF  24
8538:  CLRF   xFA
853A:  CLRF   xF9
853C:  SETF   xFC
853E:  SETF   xFB
8540:  MOVLW  0E
8542:  MOVWF  xFE
8544:  MOVLW  01
8546:  MOVWF  xFF
8548:  MOVLB  1
854A:  MOVWF  x00
854C:  CLRF   x01
854E:  CLRF   x02
8550:  CLRF   x03
8552:  CLRF   x04
8554:  CLRF   x05
8556:  CLRF   x07
8558:  MOVLW  0A
855A:  MOVWF  x06
855C:  MOVLW  03
855E:  MOVWF  x2A
8560:  MOVLW  E8
8562:  MOVWF  x29
8564:  CLRF   x2B
8566:  CLRF   x2C
8568:  CLRF   x2D
856A:  MOVLW  64
856C:  MOVWF  x2E
856E:  CLRF   x2F
8570:  CLRF   x30
8572:  CLRF   x31
8574:  CLRF   x33
8576:  CLRF   x32
8578:  CLRF   x34
857A:  CLRF   x41
857C:  CLRF   x46
857E:  CLRF   xAD
8580:  CLRF   xAE
8582:  CLRF   xAF
8584:  CLRF   xB0
8586:  CLRF   xB2
8588:  CLRF   xB1
858A:  MOVLB  6
858C:  CLRF   xAB
858E:  CLRF   xAA
8590:  CLRF   xA9
8592:  CLRF   xA8
8594:  CLRF   xAC
8596:  CLRF   xAE
8598:  CLRF   xAD
859A:  CLRF   xB0
859C:  CLRF   xAF
859E:  CLRF   xB2
85A0:  CLRF   xB1
85A2:  CLRF   xB4
85A4:  CLRF   xB3
85A6:  MOVLW  FD
85A8:  MOVWF  xB6
85AA:  MOVLW  E8
85AC:  MOVWF  xB5
85AE:  CLRF   xB8
85B0:  CLRF   xB7
85B2:  CLRF   xB9
85B4:  CLRF   xBA
85B6:  CLRF   xBB
85B8:  CLRF   xBC
85BA:  CLRF   xBD
85BC:  CLRF   xBE
85BE:  CLRF   xBF
85C0:  CLRF   xC0
85C2:  CLRF   xC1
85C4:  CLRF   xC3
85C6:  MOVLW  01
85C8:  MOVWF  xC2
85CA:  CLRF   xC5
85CC:  CLRF   xC4
85CE:  CLRF   xC6
85D0:  CLRF   xCA
85D2:  CLRF   xC9
85D4:  CLRF   xC8
85D6:  CLRF   xC7
85D8:  MOVLW  FF
85DA:  MOVLB  F
85DC:  MOVWF  x48
85DE:  BCF    FC2.6
85E0:  BCF    FC2.7
85E2:  MOVF   x49,W
85E4:  ANDLW  E0
85E6:  IORLW  1F
85E8:  MOVWF  x49
85EA:  CLRF   FD2
85EC:  CLRF   FD1
85EE:  CLRF   1A
85F0:  CLRF   1B
85F2:  MOVLB  1
85F4:  CLRF   x42
85F6:  BCF    x43.0
85F8:  CLRF   x44
85FA:  CLRF   x45
85FC:  CLRF   x47
85FE:  BCF    x43.1
8600:  CLRF   x48
8602:  MOVLB  6
8604:  CLRF   xDB
8606:  CLRF   xDC
8608:  CLRF   xDD
860A:  CLRF   xDE
860C:  CLRF   xDF
860E:  CLRF   xE0
8610:  CLRF   xE1
8612:  CLRF   xE2
8614:  CLRF   xE3
8616:  CLRF   xE4
8618:  CLRF   xE7
861A:  CLRF   xE9
861C:  CLRF   xE8
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................     RPINR1=5; 
861E:  MOVLW  05
8620:  MOVLB  E
8622:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
8624:  MOVLB  0
8626:  SETF   xFC
8628:  SETF   xFB
....................    key_timeout=0xffff; 
862A:  MOVLB  1
862C:  SETF   x2A
862E:  SETF   x29
....................    setup_oscillator(OSC_32MHZ); 
8630:  MOVLW  70
8632:  MOVWF  FD3
8634:  MOVLW  40
8636:  MOVWF  F9B
8638:  MOVF   FD3,W
....................    keyprss_off; 
863A:  BCF    F92.7
863C:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
863E:  BCF    FF2.6
8640:  BCF    FF2.7
8642:  BTFSC  FF2.7
8644:  BRA    8640
....................    init_ext_eeprom(); 
8646:  MOVLB  0
8648:  GOTO   43AC
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
864C:  MOVLW  04
864E:  MOVLB  7
8650:  MOVWF  xA1
8652:  CLRF   19
8654:  BTFSC  FF2.7
8656:  BSF    19.7
8658:  BCF    FF2.7
865A:  MOVLW  FA
865C:  MOVLB  8
865E:  MOVWF  xC5
8660:  MOVLB  0
8662:  CALL   1686
8666:  BTFSC  19.7
8668:  BSF    FF2.7
866A:  MOVLB  7
866C:  DECFSZ xA1,F
866E:  BRA    8652
....................    init_password(); 
8670:  MOVLB  0
8672:  CALL   44F4
8676:  CLRF   19
8678:  BTFSC  FF2.7
867A:  BSF    19.7
867C:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
867E:  MOVLB  8
8680:  CLRF   xCB
8682:  CLRF   xCA
8684:  CLRF   xC9
8686:  MOVLW  7F
8688:  MOVWF  xC8
868A:  MOVLB  0
868C:  CALL   3316
8690:  BTFSC  19.7
8692:  BSF    FF2.7
8694:  MOVFF  01,130
....................    //===================================== 
....................    rtc_init(); 
8698:  GOTO   4654
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
869C:  MOVLW  19
869E:  MOVLB  7
86A0:  MOVWF  xA1
86A2:  MOVLB  0
86A4:  CALL   475E
86A8:  MOVFF  03,23
86AC:  MOVFF  02,22
86B0:  MOVFF  01,21
86B4:  MOVFF  00,20
....................    printf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
86B8:  CLRF   FEA
86BA:  MOVLW  01
86BC:  MOVWF  FE9
86BE:  CALL   48B4
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
86C2:  MOVLW  1E
86C4:  MOVLB  7
86C6:  MOVWF  xA1
86C8:  MOVLB  0
86CA:  CALL   475E
86CE:  MOVFF  03,27
86D2:  MOVFF  02,26
86D6:  MOVFF  01,25
86DA:  MOVFF  00,24
....................    fprintf(COM2,"booting\n\r"); 
86DE:  MOVLW  1A
86E0:  MOVWF  FF6
86E2:  MOVLW  43
86E4:  MOVWF  FF7
86E6:  CLRF   19
86E8:  BTFSC  FF2.7
86EA:  BSF    19.7
86EC:  BCF    FF2.7
86EE:  CALL   04A2
86F2:  BTFSC  19.7
86F4:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
86F6:  MOVLW  24
86F8:  MOVWF  FF6
86FA:  MOVLW  43
86FC:  MOVWF  FF7
86FE:  CLRF   19
8700:  BTFSC  FF2.7
8702:  BSF    19.7
8704:  BCF    FF2.7
8706:  MOVLW  12
8708:  MOVLB  8
870A:  MOVWF  xDC
870C:  MOVLB  0
870E:  CALL   141A
8712:  BTFSC  19.7
8714:  BSF    FF2.7
8716:  MOVLW  41
8718:  MOVWF  FE9
871A:  CLRF   19
871C:  BTFSC  FF2.7
871E:  BSF    19.7
8720:  BCF    FF2.7
8722:  MOVFF  27,8DF
8726:  MOVFF  26,8DE
872A:  MOVFF  25,8DD
872E:  MOVFF  24,8DC
8732:  CALL   21C6
8736:  BTFSC  19.7
8738:  BSF    FF2.7
873A:  CLRF   19
873C:  BTFSC  FF2.7
873E:  BSF    19.7
8740:  BCF    FF2.7
8742:  MOVLW  0A
8744:  MOVLB  8
8746:  MOVWF  xE8
8748:  MOVLB  0
874A:  CALL   045C
874E:  BTFSC  19.7
8750:  BSF    FF2.7
8752:  CLRF   19
8754:  BTFSC  FF2.7
8756:  BSF    19.7
8758:  BCF    FF2.7
875A:  MOVLW  0D
875C:  MOVLB  8
875E:  MOVWF  xE8
8760:  MOVLB  0
8762:  CALL   045C
8766:  BTFSC  19.7
8768:  BSF    FF2.7
876A:  CLRF   19
876C:  BTFSC  FF2.7
876E:  BSF    19.7
8770:  BCF    FF2.7
....................    countcard=get_countcard(); 
8772:  CALL   33E2
8776:  BTFSC  19.7
8778:  BSF    FF2.7
877A:  MOVFF  02,FA
877E:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
8782:  SETF   xFC
8784:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
8786:  MOVLW  C7
8788:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
878A:  MOVLW  37
878C:  MOVWF  FCD
878E:  CLRF   F9A
8790:  CLRF   19
8792:  BTFSC  FF2.7
8794:  BSF    19.7
8796:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
8798:  MOVLB  8
879A:  CLRF   xCB
879C:  CLRF   xCA
879E:  CLRF   xC9
87A0:  MOVLW  94
87A2:  MOVWF  xC8
87A4:  MOVLB  0
87A6:  CALL   3316
87AA:  BTFSC  19.7
87AC:  BSF    FF2.7
87AE:  MOVFF  01,141
....................    if(delaycharaction==0)delaycharaction=1; 
87B2:  MOVLB  1
87B4:  MOVF   x41,F
87B6:  BNZ   87BC
87B8:  MOVLW  01
87BA:  MOVWF  x41
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
87BC:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
87BE:  BSF    FF0.3
87C0:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
87C2:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
87C4:  MOVLW  C0
87C6:  IORWF  FF2,F
....................   
....................    mcr_timeout=10000; 
87C8:  MOVLB  6
87CA:  CLRF   xAB
87CC:  CLRF   xAA
87CE:  MOVLW  27
87D0:  MOVWF  xA9
87D2:  MOVLW  10
87D4:  MOVWF  xA8
87D6:  CLRF   19
87D8:  BTFSC  FF2.7
87DA:  BSF    19.7
87DC:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
87DE:  MOVLB  8
87E0:  CLRF   xCB
87E2:  CLRF   xCA
87E4:  CLRF   xC9
87E6:  MOVLW  91
87E8:  MOVWF  xC8
87EA:  MOVLB  0
87EC:  CALL   3316
87F0:  BTFSC  19.7
87F2:  BSF    FF2.7
87F4:  MOVFF  01,6C6
87F8:  CLRF   19
87FA:  BTFSC  FF2.7
87FC:  BSF    19.7
87FE:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
8800:  MOVLB  8
8802:  CLRF   xCB
8804:  CLRF   xCA
8806:  CLRF   xC9
8808:  MOVLW  92
880A:  MOVWF  xC8
880C:  MOVLB  0
880E:  CALL   3316
8812:  BTFSC  19.7
8814:  BSF    FF2.7
8816:  MOVFF  01,6BA
....................     key_timeout=1000; 
881A:  MOVLW  03
881C:  MOVLB  1
881E:  MOVWF  x2A
8820:  MOVLW  E8
8822:  MOVWF  x29
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
8824:  MOVLB  0
8826:  SETF   xFC
8828:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    booting_done=1; 
882A:  MOVLW  01
882C:  MOVLB  1
882E:  MOVWF  xB0
....................    booting=1; 
8830:  MOVWF  x05
....................    charac_timeout=0xffffffff; 
8832:  MOVLB  0
8834:  SETF   xFC
8836:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
8838:  MOVLB  7
883A:  CLRF   xDA
883C:  CLRF   xD9
883E:  CLRF   xD8
8840:  MOVLW  66
8842:  MOVWF  xD7
8844:  CLRF   xDE
8846:  CLRF   xDD
8848:  CLRF   xDC
884A:  MOVLW  10
884C:  MOVWF  xDB
884E:  MOVLW  06
8850:  MOVWF  xE0
8852:  MOVLW  CB
8854:  MOVWF  xDF
8856:  MOVLB  0
8858:  CALL   43B6
....................    set_tris_a(0xff);  
885C:  MOVLW  FF
885E:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
8860:  MOVLW  E0
8862:  MOVLB  F
8864:  MOVWF  x48
8866:  BCF    FC2.6
8868:  BCF    FC2.7
886A:  MOVF   x49,W
886C:  ANDLW  E0
886E:  IORLW  1F
8870:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
8872:  MOVF   FC1,W
8874:  ANDLW  C0
8876:  IORLW  03
8878:  MOVWF  FC1
887A:  BCF    FC1.7
887C:  BSF    FC2.0
887E:  BSF    FC1.6
8880:  BSF    FC2.1
8882:  BTFSC  FC2.1
8884:  BRA    8882
8886:  BCF    FC1.6
8888:  CLRF   19
888A:  BTFSC  FF2.7
888C:  BSF    19.7
888E:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
8890:  MOVLB  8
8892:  CLRF   xCB
8894:  CLRF   xCA
8896:  CLRF   xC9
8898:  MOVLW  7F
889A:  MOVWF  xC8
889C:  MOVLB  0
889E:  CALL   3316
88A2:  BTFSC  19.7
88A4:  BSF    FF2.7
88A6:  MOVFF  01,130
88AA:  CLRF   19
88AC:  BTFSC  FF2.7
88AE:  BSF    19.7
88B0:  BCF    FF2.7
....................    type_KB=read_ext_eeprom(kindofKB); 
88B2:  MOVLB  8
88B4:  CLRF   xCB
88B6:  CLRF   xCA
88B8:  CLRF   xC9
88BA:  MOVLW  7E
88BC:  MOVWF  xC8
88BE:  MOVLB  0
88C0:  CALL   3316
88C4:  BTFSC  19.7
88C6:  BSF    FF2.7
88C8:  MOVFF  01,134
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
88CC:  MOVLB  1
88CE:  MOVF   x34,F
88D0:  BZ    88F0
88D2:  MOVLW  3C
88D4:  MOVWF  FF6
88D6:  MOVLW  43
88D8:  MOVWF  FF7
88DA:  CLRF   19
88DC:  BTFSC  FF2.7
88DE:  BSF    19.7
88E0:  BCF    FF2.7
88E2:  MOVLB  0
88E4:  CALL   04A2
88E8:  BTFSC  19.7
88EA:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
88EC:  BRA    890A
88EE:  MOVLB  1
88F0:  MOVLW  50
88F2:  MOVWF  FF6
88F4:  MOVLW  43
88F6:  MOVWF  FF7
88F8:  CLRF   19
88FA:  BTFSC  FF2.7
88FC:  BSF    19.7
88FE:  BCF    FF2.7
8900:  MOVLB  0
8902:  CALL   04A2
8906:  BTFSC  19.7
8908:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
890A:  MOVLB  6
890C:  MOVF   xC6,F
890E:  BNZ   892E
8910:  MOVLW  64
8912:  MOVWF  FF6
8914:  MOVLW  43
8916:  MOVWF  FF7
8918:  CLRF   19
891A:  BTFSC  FF2.7
891C:  BSF    19.7
891E:  BCF    FF2.7
8920:  MOVLB  0
8922:  CALL   04A2
8926:  BTFSC  19.7
8928:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
892A:  BRA    8948
892C:  MOVLB  6
892E:  MOVLW  7E
8930:  MOVWF  FF6
8932:  MOVLW  43
8934:  MOVWF  FF7
8936:  CLRF   19
8938:  BTFSC  FF2.7
893A:  BSF    19.7
893C:  BCF    FF2.7
893E:  MOVLB  0
8940:  CALL   04A2
8944:  BTFSC  19.7
8946:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
8948:  MOVLW  01
894A:  MOVWF  FEA
894C:  MOVLW  35
894E:  MOVWF  FE9
8950:  CLRF   00
8952:  CLRF   02
8954:  MOVLW  0C
8956:  MOVWF  01
8958:  CALL   3DF6
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
895C:  MOVLB  6
895E:  CLRF   xE5
8960:  MOVF   xE5,W
8962:  SUBLW  13
8964:  BNC   897A
....................    { 
....................       password[i] = 0; 
8966:  CLRF   03
8968:  MOVF   xE5,W
896A:  ADDLW  55
896C:  MOVWF  FE9
896E:  MOVLW  00
8970:  ADDWFC 03,W
8972:  MOVWF  FEA
8974:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 1 
8976:  INCF   xE5,F
8978:  BRA    8960
....................    disable_interrupts(GLOBAL); 
897A:  BCF    FF2.6
897C:  BCF    FF2.7
897E:  BTFSC  FF2.7
8980:  BRA    897C
8982:  CLRF   19
8984:  BTFSC  FF2.7
8986:  BSF    19.7
8988:  BCF    FF2.7
....................    save_coutcard(0); 
898A:  MOVLB  8
898C:  CLRF   xC0
898E:  CLRF   xBF
8990:  MOVLB  0
8992:  CALL   3F8E
8996:  BTFSC  19.7
8998:  BSF    FF2.7
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
899A:  MOVLW  01
899C:  MOVWF  FEA
899E:  MOVLW  35
89A0:  MOVWF  FE9
89A2:  MOVLW  00
89A4:  CALL   027E
89A8:  TBLRD*-
89AA:  TBLRD*+
89AC:  MOVF   FF5,W
89AE:  MOVWF  FEE
89B0:  IORLW  00
89B2:  BNZ   89AA
....................    strcpy(crypto_key,"@quang1021"); 
89B4:  MOVLW  01
89B6:  MOVWF  FEA
89B8:  MOVLW  08
89BA:  MOVWF  FE9
89BC:  MOVLW  00
89BE:  CALL   0296
89C2:  TBLRD*-
89C4:  TBLRD*+
89C6:  MOVF   FF5,W
89C8:  MOVWF  FEE
89CA:  IORLW  00
89CC:  BNZ   89C4
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................    save_key_encrypt(); 
89CE:  GOTO   626A
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
89D2:  MOVLB  7
89D4:  CLRF   xDA
89D6:  MOVLW  01
89D8:  MOVWF  xD9
89DA:  MOVLW  C3
89DC:  MOVWF  xD8
89DE:  MOVLW  0F
89E0:  MOVWF  xD7
89E2:  CLRF   xDE
89E4:  CLRF   xDD
89E6:  CLRF   xDC
89E8:  MOVLW  10
89EA:  MOVWF  xDB
89EC:  MOVLW  07
89EE:  MOVWF  xE0
89F0:  MOVLW  6F
89F2:  MOVWF  xDF
89F4:  MOVLB  0
89F6:  CALL   43B6
....................    for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
89FA:  MOVLB  6
89FC:  CLRF   xE5
89FE:  MOVF   xE5,W
8A00:  SUBLW  0F
8A02:  BNC   8A44
8A04:  CLRF   03
8A06:  MOVF   xE5,W
8A08:  ADDLW  6F
8A0A:  MOVWF  FE9
8A0C:  MOVLW  07
8A0E:  ADDWFC 03,W
8A10:  MOVWF  FEA
8A12:  MOVFF  FEF,7A1
8A16:  CLRF   19
8A18:  BTFSC  FF2.7
8A1A:  BSF    19.7
8A1C:  BCF    FF2.7
8A1E:  MOVLW  20
8A20:  MOVLB  8
8A22:  MOVWF  xE8
8A24:  MOVLB  0
8A26:  CALL   045C
8A2A:  BTFSC  19.7
8A2C:  BSF    FF2.7
8A2E:  MOVFF  7A1,7B6
8A32:  MOVLW  57
8A34:  MOVLB  7
8A36:  MOVWF  xB7
8A38:  MOVLB  0
8A3A:  CALL   48E6
8A3E:  MOVLB  6
8A40:  INCF   xE5,F
8A42:  BRA    89FE
....................    delay_ms(3000); 
8A44:  MOVLW  0C
8A46:  MOVLB  7
8A48:  MOVWF  xA1
8A4A:  CLRF   19
8A4C:  BTFSC  FF2.7
8A4E:  BSF    19.7
8A50:  BCF    FF2.7
8A52:  MOVLW  FA
8A54:  MOVLB  8
8A56:  MOVWF  xC5
8A58:  MOVLB  0
8A5A:  CALL   1686
8A5E:  BTFSC  19.7
8A60:  BSF    FF2.7
8A62:  MOVLB  7
8A64:  DECFSZ xA1,F
8A66:  BRA    8A4A
....................     
....................    //strcpy(crypto_key,"@quang102"); 
....................    rijndael('d', (unsigned int8 *)&buftemp2[0], (unsigned int8 *)&crypto_key[0]); 
8A68:  MOVLW  64
8A6A:  MOVWF  xB5
8A6C:  MOVLW  07
8A6E:  MOVWF  xB7
8A70:  MOVLW  6F
8A72:  MOVWF  xB6
8A74:  MOVLW  01
8A76:  MOVWF  xB9
8A78:  MOVLW  08
8A7A:  MOVWF  xB8
8A7C:  MOVLB  0
8A7E:  CALL   6100
8A82:  CLRF   19
8A84:  BTFSC  FF2.7
8A86:  BSF    19.7
8A88:  BCF    FF2.7
....................    fprintf(COM2,"\n\r"); 
8A8A:  MOVLW  0A
8A8C:  MOVLB  8
8A8E:  MOVWF  xE8
8A90:  MOVLB  0
8A92:  CALL   045C
8A96:  BTFSC  19.7
8A98:  BSF    FF2.7
8A9A:  CLRF   19
8A9C:  BTFSC  FF2.7
8A9E:  BSF    19.7
8AA0:  BCF    FF2.7
8AA2:  MOVLW  0D
8AA4:  MOVLB  8
8AA6:  MOVWF  xE8
8AA8:  MOVLB  0
8AAA:  CALL   045C
8AAE:  BTFSC  19.7
8AB0:  BSF    FF2.7
....................    for(i=0;i<10;i++) fprintf(COM2," %c",crypto_key[i]); 
8AB2:  MOVLB  6
8AB4:  CLRF   xE5
8AB6:  MOVF   xE5,W
8AB8:  SUBLW  09
8ABA:  BNC   8B00
8ABC:  CLRF   03
8ABE:  MOVF   xE5,W
8AC0:  ADDLW  08
8AC2:  MOVWF  FE9
8AC4:  MOVLW  01
8AC6:  ADDWFC 03,W
8AC8:  MOVWF  FEA
8ACA:  MOVFF  FEF,7A1
8ACE:  CLRF   19
8AD0:  BTFSC  FF2.7
8AD2:  BSF    19.7
8AD4:  BCF    FF2.7
8AD6:  MOVLW  20
8AD8:  MOVLB  8
8ADA:  MOVWF  xE8
8ADC:  MOVLB  0
8ADE:  CALL   045C
8AE2:  BTFSC  19.7
8AE4:  BSF    FF2.7
8AE6:  CLRF   19
8AE8:  BTFSC  FF2.7
8AEA:  BSF    19.7
8AEC:  BCF    FF2.7
8AEE:  MOVFF  7A1,8E8
8AF2:  CALL   045C
8AF6:  BTFSC  19.7
8AF8:  BSF    FF2.7
8AFA:  MOVLB  6
8AFC:  INCF   xE5,F
8AFE:  BRA    8AB6
8B00:  CLRF   19
8B02:  BTFSC  FF2.7
8B04:  BSF    19.7
8B06:  BCF    FF2.7
....................    fprintf(COM2,"\n\r"); 
8B08:  MOVLW  0A
8B0A:  MOVLB  8
8B0C:  MOVWF  xE8
8B0E:  MOVLB  0
8B10:  CALL   045C
8B14:  BTFSC  19.7
8B16:  BSF    FF2.7
8B18:  CLRF   19
8B1A:  BTFSC  FF2.7
8B1C:  BSF    19.7
8B1E:  BCF    FF2.7
8B20:  MOVLW  0D
8B22:  MOVLB  8
8B24:  MOVWF  xE8
8B26:  MOVLB  0
8B28:  CALL   045C
8B2C:  BTFSC  19.7
8B2E:  BSF    FF2.7
....................    for(i=0;i<16;i++) fprintf(COM2," %c",buftemp2[i]); 
8B30:  MOVLB  6
8B32:  CLRF   xE5
8B34:  MOVF   xE5,W
8B36:  SUBLW  0F
8B38:  BNC   8B7E
8B3A:  CLRF   03
8B3C:  MOVF   xE5,W
8B3E:  ADDLW  6F
8B40:  MOVWF  FE9
8B42:  MOVLW  07
8B44:  ADDWFC 03,W
8B46:  MOVWF  FEA
8B48:  MOVFF  FEF,7A1
8B4C:  CLRF   19
8B4E:  BTFSC  FF2.7
8B50:  BSF    19.7
8B52:  BCF    FF2.7
8B54:  MOVLW  20
8B56:  MOVLB  8
8B58:  MOVWF  xE8
8B5A:  MOVLB  0
8B5C:  CALL   045C
8B60:  BTFSC  19.7
8B62:  BSF    FF2.7
8B64:  CLRF   19
8B66:  BTFSC  FF2.7
8B68:  BSF    19.7
8B6A:  BCF    FF2.7
8B6C:  MOVFF  7A1,8E8
8B70:  CALL   045C
8B74:  BTFSC  19.7
8B76:  BSF    FF2.7
8B78:  MOVLB  6
8B7A:  INCF   xE5,F
8B7C:  BRA    8B34
....................    while(1); 
8B7E:  BRA    8B7E
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
8B80:  MOVLB  7
8B82:  CLRF   xDA
8B84:  CLRF   xD9
8B86:  CLRF   xD8
8B88:  CLRF   xD7
8B8A:  CLRF   xDE
8B8C:  CLRF   xDD
8B8E:  CLRF   xDC
8B90:  MOVLW  14
8B92:  MOVWF  xDB
8B94:  CLRF   xE0
8B96:  MOVLW  55
8B98:  MOVWF  xDF
8B9A:  MOVLB  0
8B9C:  CALL   43B6
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
8BA0:  MOVLB  6
8BA2:  MOVF   xC0,F
8BA4:  BNZ   8C50
....................       { 
....................          fprintf(COM2,"password:"); 
8BA6:  MOVLW  96
8BA8:  MOVWF  FF6
8BAA:  MOVLW  43
8BAC:  MOVWF  FF7
8BAE:  CLRF   19
8BB0:  BTFSC  FF2.7
8BB2:  BSF    19.7
8BB4:  BCF    FF2.7
8BB6:  MOVLB  0
8BB8:  CALL   04A2
8BBC:  BTFSC  19.7
8BBE:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
8BC0:  MOVLW  02
8BC2:  MOVLB  7
8BC4:  MOVWF  xD7
8BC6:  MOVLW  14
8BC8:  MOVWF  xD8
8BCA:  MOVLW  01
8BCC:  MOVWF  xDA
8BCE:  MOVLW  49
8BD0:  MOVWF  xD9
8BD2:  MOVLB  0
8BD4:  CALL   6652
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
8BD8:  MOVLB  7
8BDA:  CLRF   xDA
8BDC:  CLRF   xD9
8BDE:  CLRF   xD8
8BE0:  CLRF   xD7
8BE2:  CLRF   xDE
8BE4:  CLRF   xDD
8BE6:  CLRF   xDC
8BE8:  MOVLW  14
8BEA:  MOVWF  xDB
8BEC:  CLRF   xE0
8BEE:  MOVLW  55
8BF0:  MOVWF  xDF
8BF2:  MOVLB  0
8BF4:  CALL   43B6
....................          if(!stringcomp(buffer_uart,password)) 
8BF8:  MOVLW  01
8BFA:  MOVLB  7
8BFC:  MOVWF  xD8
8BFE:  MOVLW  49
8C00:  MOVWF  xD7
8C02:  CLRF   xDA
8C04:  MOVLW  55
8C06:  MOVWF  xD9
8C08:  MOVLB  0
8C0A:  CALL   678A
8C0E:  MOVF   01,F
8C10:  BNZ   8C34
....................          { 
....................             mode=LOGON; 
8C12:  MOVLW  01
8C14:  MOVLB  6
8C16:  MOVWF  xC0
....................             fprintf(COM2," OK\n\r"); 
8C18:  MOVLW  A0
8C1A:  MOVWF  FF6
8C1C:  MOVLW  43
8C1E:  MOVWF  FF7
8C20:  CLRF   19
8C22:  BTFSC  FF2.7
8C24:  BSF    19.7
8C26:  BCF    FF2.7
8C28:  MOVLB  0
8C2A:  CALL   04A2
8C2E:  BTFSC  19.7
8C30:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
8C32:  BRA    8C4C
8C34:  MOVLW  A6
8C36:  MOVWF  FF6
8C38:  MOVLW  43
8C3A:  MOVWF  FF7
8C3C:  CLRF   19
8C3E:  BTFSC  FF2.7
8C40:  BSF    19.7
8C42:  BCF    FF2.7
8C44:  CALL   04A2
8C48:  BTFSC  19.7
8C4A:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
8C4C:  BRA    8C5A
8C4E:  MOVLB  6
8C50:  DECFSZ xC0,W
8C52:  BRA    8C5C
8C54:  MOVLB  0
8C56:  GOTO   6F24
8C5A:  MOVLB  6
....................    } 
8C5C:  BRA    8BA2
.................... } 
8C5E:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

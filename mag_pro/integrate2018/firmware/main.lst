CCS PCH C Compiler, Version 4.140, 33034               24-Jul-18 20:32

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   33520 bytes (51%)
                           Largest free fragment is 32004
               RAM used:   1983 (53%) at main() level
                           2369 (63%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   7CF6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   5A1A
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1BEE
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0686:  MOVLW  02
0688:  MOVLB  8
068A:  SUBWF  x4E,F
068C:  BNC   06A6
068E:  MOVLW  08
0690:  MOVWF  FEA
0692:  MOVLW  4E
0694:  MOVWF  FE9
0696:  MOVF   FEF,W
0698:  BZ    06A6
069A:  BRA    06A2
069C:  BRA    069E
069E:  BRA    06A0
06A0:  NOP   
06A2:  DECFSZ FEF,F
06A4:  BRA    069C
06A6:  MOVLB  0
06A8:  GOTO   1BFE (RETURN)
*
18C6:  MOVLW  08
18C8:  MOVWF  FEA
18CA:  MOVLW  56
18CC:  MOVWF  FE9
18CE:  MOVF   FEF,W
18D0:  BZ    18EC
18D2:  MOVLW  0A
18D4:  MOVWF  01
18D6:  CLRF   00
18D8:  DECFSZ 00,F
18DA:  BRA    18D8
18DC:  DECFSZ 01,F
18DE:  BRA    18D6
18E0:  MOVLW  5F
18E2:  MOVWF  00
18E4:  DECFSZ 00,F
18E6:  BRA    18E4
18E8:  DECFSZ FEF,F
18EA:  BRA    18D2
18EC:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
1604:  BCF    F94.0
1606:  BCF    F8B.0
1608:  MOVLW  08
160A:  MOVWF  01
160C:  BRA    160E
160E:  NOP   
1610:  BSF    01.7
1612:  BRA    1634
1614:  BCF    01.7
1616:  MOVLB  9
1618:  RRCF   x0C,F
161A:  MOVLB  0
161C:  BTFSC  FD8.0
161E:  BSF    F8B.0
1620:  BTFSS  FD8.0
1622:  BCF    F8B.0
1624:  BSF    01.6
1626:  BRA    1634
1628:  BCF    01.6
162A:  DECFSZ 01,F
162C:  BRA    1616
162E:  BRA    1630
1630:  NOP   
1632:  BSF    F8B.0
1634:  MOVLW  10
1636:  MOVWF  FE9
1638:  DECFSZ FE9,F
163A:  BRA    1638
163C:  BRA    163E
163E:  NOP   
1640:  BTFSC  01.7
1642:  BRA    1614
1644:  BTFSC  01.6
1646:  BRA    1628
1648:  RETURN 0
*
5F72:  BSF    F94.1
5F74:  BTFSC  F82.1
5F76:  BRA    5F74
5F78:  MOVLW  08
5F7A:  MOVWF  00
5F7C:  MOVLB  7
5F7E:  CLRF   xFC
5F80:  BSF    00.7
5F82:  BRA    5FA4
5F84:  BCF    00.7
5F86:  BRA    5FA4
5F88:  MOVFF  7FC,02
5F8C:  BCF    FD8.0
5F8E:  BTFSC  F82.1
5F90:  BSF    FD8.0
5F92:  RRCF   02,F
5F94:  BSF    00.6
5F96:  BRA    5FA4
5F98:  BCF    00.6
5F9A:  DECFSZ 00,F
5F9C:  BRA    5F8C
5F9E:  MOVFF  02,01
5FA2:  BRA    5FBC
5FA4:  MOVLW  10
5FA6:  BTFSC  00.7
5FA8:  MOVLW  04
5FAA:  MOVWF  01
5FAC:  DECFSZ 01,F
5FAE:  BRA    5FAC
5FB0:  BRA    5FB2
5FB2:  BTFSC  00.7
5FB4:  BRA    5F84
5FB6:  BTFSC  00.6
5FB8:  BRA    5F98
5FBA:  BRA    5F8C
5FBC:  MOVLB  0
5FBE:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3370:  MOVLW  08
3372:  MOVWF  01
3374:  MOVLW  0A
3376:  MOVWF  00
3378:  DECFSZ 00,F
337A:  BRA    3378
337C:  BCF    F8B.3
337E:  BCF    F94.3
3380:  MOVLW  0B
3382:  MOVWF  00
3384:  DECFSZ 00,F
3386:  BRA    3384
3388:  MOVLB  9
338A:  RLCF   x23,F
338C:  BCF    F8B.4
338E:  BTFSC  FD8.0
3390:  BSF    F94.4
3392:  BTFSS  FD8.0
3394:  BCF    F94.4
3396:  BSF    F94.3
3398:  BTFSS  F82.3
339A:  BRA    3398
339C:  DECFSZ 01,F
339E:  BRA    33A2
33A0:  BRA    33A6
33A2:  MOVLB  0
33A4:  BRA    3374
33A6:  MOVLW  0A
33A8:  MOVWF  00
33AA:  DECFSZ 00,F
33AC:  BRA    33AA
33AE:  BCF    F8B.3
33B0:  BCF    F94.3
33B2:  NOP   
33B4:  BSF    F94.4
33B6:  MOVLW  0B
33B8:  MOVWF  00
33BA:  DECFSZ 00,F
33BC:  BRA    33BA
33BE:  MOVLW  0B
33C0:  MOVWF  00
33C2:  DECFSZ 00,F
33C4:  BRA    33C2
33C6:  BSF    F94.3
33C8:  BTFSS  F82.3
33CA:  BRA    33C8
33CC:  CLRF   01
33CE:  MOVLW  0B
33D0:  MOVWF  00
33D2:  DECFSZ 00,F
33D4:  BRA    33D2
33D6:  BTFSC  F82.4
33D8:  BSF    01.0
33DA:  BCF    F8B.3
33DC:  BCF    F94.3
33DE:  BCF    F8B.4
33E0:  BCF    F94.4
33E2:  MOVLB  0
33E4:  RETURN 0
33E6:  MOVLW  08
33E8:  MOVLB  9
33EA:  MOVWF  x1F
33EC:  MOVFF  00,920
33F0:  BSF    F94.4
33F2:  MOVLW  0B
33F4:  MOVWF  00
33F6:  DECFSZ 00,F
33F8:  BRA    33F6
33FA:  BSF    F94.3
33FC:  BTFSS  F82.3
33FE:  BRA    33FC
3400:  BTFSC  F82.4
3402:  BSF    FD8.0
3404:  BTFSS  F82.4
3406:  BCF    FD8.0
3408:  RLCF   01,F
340A:  MOVLW  0A
340C:  MOVWF  00
340E:  DECFSZ 00,F
3410:  BRA    340E
3412:  BCF    F94.3
3414:  BCF    F8B.3
3416:  DECFSZ x1F,F
3418:  BRA    33F0
341A:  BSF    F94.4
341C:  MOVLW  0B
341E:  MOVWF  00
3420:  DECFSZ 00,F
3422:  BRA    3420
3424:  BCF    F8B.4
3426:  MOVF   x20,W
3428:  BTFSS  FD8.2
342A:  BCF    F94.4
342C:  NOP   
342E:  BSF    F94.3
3430:  BTFSS  F82.3
3432:  BRA    3430
3434:  MOVLW  0A
3436:  MOVWF  00
3438:  DECFSZ 00,F
343A:  BRA    3438
343C:  BCF    F8B.3
343E:  BCF    F94.3
3440:  MOVLW  0B
3442:  MOVWF  00
3444:  DECFSZ 00,F
3446:  BRA    3444
3448:  BCF    F8B.4
344A:  BCF    F94.4
344C:  MOVLB  0
344E:  RETURN 0
....................  
.................... #define ptr_start                       150 
.................... #define EEPROM_SIZE_endofkey            131071 
.................... #define EEPROM_SIZE_stofkey             115470 
.................... #define EEPROM_KEY_ST                   EEPROM_SIZE_stofkey+1 
.................... //=============================== 
....................  
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5D24:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
5D26:  BSF    F94.4
....................    port_b_pullups(0xff); 
5D28:  BCF    FF1.7
.................... } 
5D2A:  GOTO   7E8E (RETURN)
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3A6C:  MOVLB  9
3A6E:  MOVF   x16,F
3A70:  BNZ   3A78
3A72:  MOVF   x15,W
3A74:  SUBLW  00
3A76:  BC    3A7E
3A78:  MOVLW  A8
3A7A:  MOVWF  x19
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3A7C:  BRA    3A82
3A7E:  MOVLW  A0
3A80:  MOVWF  x19
....................  
....................    i2c_start(); 
3A82:  BSF    F94.4
3A84:  MOVLW  0A
3A86:  MOVWF  00
3A88:  DECFSZ 00,F
3A8A:  BRA    3A88
3A8C:  BSF    F94.3
3A8E:  MOVLW  0B
3A90:  MOVWF  00
3A92:  DECFSZ 00,F
3A94:  BRA    3A92
3A96:  BCF    F8B.4
3A98:  BCF    F94.4
3A9A:  MOVLW  0A
3A9C:  MOVWF  00
3A9E:  DECFSZ 00,F
3AA0:  BRA    3A9E
3AA2:  BCF    F8B.3
3AA4:  BCF    F94.3
....................    i2c_write(command); 
3AA6:  MOVFF  919,923
3AAA:  MOVLB  0
3AAC:  RCALL  3370
....................    i2c_write(address>>8); 
3AAE:  MOVFF  914,91B
3AB2:  MOVFF  915,91C
3AB6:  MOVFF  916,91D
3ABA:  MOVLB  9
3ABC:  CLRF   x1E
3ABE:  MOVFF  914,923
3AC2:  MOVLB  0
3AC4:  RCALL  3370
....................    i2c_write(address); 
3AC6:  MOVFF  913,923
3ACA:  RCALL  3370
....................    i2c_write(data); 
3ACC:  MOVFF  917,923
3AD0:  RCALL  3370
....................  
....................    i2c_stop(); 
3AD2:  BCF    F94.4
3AD4:  NOP   
3AD6:  BSF    F94.3
3AD8:  BTFSS  F82.3
3ADA:  BRA    3AD8
3ADC:  MOVLW  0A
3ADE:  MOVWF  00
3AE0:  DECFSZ 00,F
3AE2:  BRA    3AE0
3AE4:  BRA    3AE6
3AE6:  NOP   
3AE8:  BSF    F94.4
3AEA:  MOVLW  0A
3AEC:  MOVWF  00
3AEE:  DECFSZ 00,F
3AF0:  BRA    3AEE
....................    i2c_start(); 
3AF2:  BSF    F94.4
3AF4:  MOVLW  0A
3AF6:  MOVWF  00
3AF8:  DECFSZ 00,F
3AFA:  BRA    3AF8
3AFC:  BSF    F94.3
3AFE:  MOVLW  0B
3B00:  MOVWF  00
3B02:  DECFSZ 00,F
3B04:  BRA    3B02
3B06:  BCF    F8B.4
3B08:  BCF    F94.4
3B0A:  MOVLW  0A
3B0C:  MOVWF  00
3B0E:  DECFSZ 00,F
3B10:  BRA    3B0E
3B12:  BCF    F8B.3
3B14:  BCF    F94.3
....................    status=i2c_write(command); 
3B16:  MOVFF  919,923
3B1A:  RCALL  3370
3B1C:  MOVF   01,W
3B1E:  MOVLB  9
3B20:  BCF    x18.0
3B22:  BTFSC  01.0
3B24:  BSF    x18.0
....................    while(status==1) 
....................    { 
3B26:  BTFSS  x18.0
3B28:  BRA    3B66
....................       i2c_start(); 
3B2A:  BSF    F94.4
3B2C:  MOVLW  0A
3B2E:  MOVWF  00
3B30:  DECFSZ 00,F
3B32:  BRA    3B30
3B34:  BSF    F94.3
3B36:  MOVLW  0B
3B38:  MOVWF  00
3B3A:  DECFSZ 00,F
3B3C:  BRA    3B3A
3B3E:  BTFSS  F82.3
3B40:  BRA    3B3E
3B42:  BCF    F8B.4
3B44:  BCF    F94.4
3B46:  MOVLW  0A
3B48:  MOVWF  00
3B4A:  DECFSZ 00,F
3B4C:  BRA    3B4A
3B4E:  BCF    F8B.3
3B50:  BCF    F94.3
....................       status=i2c_write(command); 
3B52:  MOVFF  919,923
3B56:  MOVLB  0
3B58:  RCALL  3370
3B5A:  MOVF   01,W
3B5C:  MOVLB  9
3B5E:  BCF    x18.0
3B60:  BTFSC  01.0
3B62:  BSF    x18.0
....................    } 
3B64:  BRA    3B26
....................    //delay_us(100); 
.................... } 
3B66:  MOVLB  0
3B68:  RETURN 0
....................  
....................  
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3450:  MOVLB  9
3452:  MOVF   x1B,F
3454:  BNZ   345C
3456:  MOVF   x1A,W
3458:  SUBLW  00
345A:  BC    3462
345C:  MOVLW  A8
345E:  MOVWF  x1D
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3460:  BRA    3466
3462:  MOVLW  A0
3464:  MOVWF  x1D
....................  
....................    i2c_start(); 
3466:  BSF    F94.4
3468:  MOVLW  0A
346A:  MOVWF  00
346C:  DECFSZ 00,F
346E:  BRA    346C
3470:  BSF    F94.3
3472:  MOVLW  0B
3474:  MOVWF  00
3476:  DECFSZ 00,F
3478:  BRA    3476
347A:  BTFSS  F82.3
347C:  BRA    347A
347E:  BCF    F8B.4
3480:  BCF    F94.4
3482:  MOVLW  0A
3484:  MOVWF  00
3486:  DECFSZ 00,F
3488:  BRA    3486
348A:  BCF    F8B.3
348C:  BCF    F94.3
....................    i2c_write(command); 
348E:  MOVFF  91D,923
3492:  MOVLB  0
3494:  RCALL  3370
....................    i2c_write(address>>8); 
3496:  MOVFF  919,91F
349A:  MOVFF  91A,920
349E:  MOVFF  91B,921
34A2:  MOVLB  9
34A4:  CLRF   x22
34A6:  MOVFF  919,923
34AA:  MOVLB  0
34AC:  RCALL  3370
....................    i2c_write(address); 
34AE:  MOVFF  918,923
34B2:  RCALL  3370
....................    i2c_start(); 
34B4:  BSF    F94.4
34B6:  MOVLW  0A
34B8:  MOVWF  00
34BA:  DECFSZ 00,F
34BC:  BRA    34BA
34BE:  BSF    F94.3
34C0:  MOVLW  0B
34C2:  MOVWF  00
34C4:  DECFSZ 00,F
34C6:  BRA    34C4
34C8:  BTFSS  F82.3
34CA:  BRA    34C8
34CC:  BCF    F8B.4
34CE:  BCF    F94.4
34D0:  MOVLW  0A
34D2:  MOVWF  00
34D4:  DECFSZ 00,F
34D6:  BRA    34D4
34D8:  BCF    F8B.3
34DA:  BCF    F94.3
....................    i2c_write(command+1); 
34DC:  MOVLW  01
34DE:  MOVLB  9
34E0:  ADDWF  x1D,W
34E2:  MOVWF  x1E
34E4:  MOVWF  x23
34E6:  MOVLB  0
34E8:  RCALL  3370
....................    data=i2c_read(0); 
34EA:  CLRF   00
34EC:  RCALL  33E6
34EE:  MOVFF  01,91C
....................    i2c_stop(); 
34F2:  BCF    F94.4
34F4:  NOP   
34F6:  BSF    F94.3
34F8:  BTFSS  F82.3
34FA:  BRA    34F8
34FC:  MOVLW  0A
34FE:  MOVWF  00
3500:  DECFSZ 00,F
3502:  BRA    3500
3504:  BRA    3506
3506:  NOP   
3508:  BSF    F94.4
350A:  MOVLW  0A
350C:  MOVWF  00
350E:  DECFSZ 00,F
3510:  BRA    350E
....................    return(data); 
3512:  MOVLB  9
3514:  MOVFF  91C,01
.................... } 
3518:  MOVLB  0
351A:  RETURN 0
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr            0 
.................... #define strobe_ptrcard_addr         25     // 4 bytes 
.................... #define strobe_ptrcard_key          30     // 4 bytes 
.................... #define strobe_count_card           36     // 2 bytes 
.................... #define strobe_nameconsole          40     // 16 bytes  
.................... #define strobe_Master_SLV           58     // 1 byte 
.................... #define strobe_debugmode            59     // 1 byte 
.................... #define strobe_delaytime            60     // 1 byte 
.................... #define kindofKB                    61     // 1 byte 
.................... #define crypto_en                   62     // 1 byte 
.................... #define strobe_crypto_key           63     // 32 byte 
....................  
....................  
.................... #define wide_strobe_nameconsole     16  
.................... //============================================================== 
.................... #define numdata                  124    // 5+79+40=124 
.................... #define numdataofonecard         128    //  
.................... #define countcards               930    //43590/124 
....................  
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdataofonecard]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... #if 0 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... } 
.................... #endif 
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4EF6:  MOVLB  9
4EF8:  CLRF   x0D
4EFA:  CLRF   x0C
4EFC:  CLRF   x0B
4EFE:  CLRF   x0A
4F00:  MOVF   x0D,W
4F02:  SUBWF  x07,W
4F04:  BNC   4F7E
4F06:  BNZ   4F1E
4F08:  MOVF   x0C,W
4F0A:  SUBWF  x06,W
4F0C:  BNC   4F7E
4F0E:  BNZ   4F1E
4F10:  MOVF   x0B,W
4F12:  SUBWF  x05,W
4F14:  BNC   4F7E
4F16:  BNZ   4F1E
4F18:  MOVF   x04,W
4F1A:  SUBWF  x0A,W
4F1C:  BC    4F7E
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4F1E:  MOVF   x0A,W
4F20:  ADDWF  x00,W
4F22:  MOVWF  x0E
4F24:  MOVF   x0B,W
4F26:  ADDWFC x01,W
4F28:  MOVWF  x0F
4F2A:  MOVF   x0C,W
4F2C:  ADDWFC x02,W
4F2E:  MOVWF  x10
4F30:  MOVF   x0D,W
4F32:  ADDWFC x03,W
4F34:  MOVWF  x11
4F36:  MOVF   x08,W
4F38:  ADDWF  x0A,W
4F3A:  MOVWF  FE9
4F3C:  MOVF   x09,W
4F3E:  ADDWFC x0B,W
4F40:  MOVWF  FEA
4F42:  MOVFF  FEF,912
4F46:  MOVFF  911,916
4F4A:  MOVFF  910,915
4F4E:  MOVFF  90F,914
4F52:  MOVFF  90E,913
4F56:  MOVFF  912,917
4F5A:  MOVLB  0
4F5C:  CALL   3A6C
....................       delay_us(10); 
4F60:  MOVLW  1A
4F62:  MOVWF  00
4F64:  DECFSZ 00,F
4F66:  BRA    4F64
4F68:  NOP   
....................    } 
4F6A:  MOVLW  01
4F6C:  MOVLB  9
4F6E:  ADDWF  x0A,F
4F70:  BTFSC  FD8.0
4F72:  INCF   x0B,F
4F74:  BTFSC  FD8.2
4F76:  INCF   x0C,F
4F78:  BTFSC  FD8.2
4F7A:  INCF   x0D,F
4F7C:  BRA    4F00
....................    return 1; 
4F7E:  MOVLW  01
4F80:  MOVWF  01
.................... } 
4F82:  MOVLB  0
4F84:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len,unsigned int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4004:  MOVLB  9
4006:  CLRF   x11
4008:  CLRF   x10
400A:  CLRF   x0F
400C:  CLRF   x0E
400E:  MOVF   x11,W
4010:  SUBWF  x0B,W
4012:  BNC   4094
4014:  BNZ   402C
4016:  MOVF   x10,W
4018:  SUBWF  x0A,W
401A:  BNC   4094
401C:  BNZ   402C
401E:  MOVF   x0F,W
4020:  SUBWF  x09,W
4022:  BNC   4094
4024:  BNZ   402C
4026:  MOVF   x08,W
4028:  SUBWF  x0E,W
402A:  BC    4094
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
402C:  MOVF   x0C,W
402E:  ADDWF  x0E,W
4030:  MOVWF  01
4032:  MOVF   x0D,W
4034:  ADDWFC x0F,W
4036:  MOVWF  03
4038:  MOVFF  01,912
403C:  MOVWF  x13
403E:  MOVF   x0E,W
4040:  ADDWF  x04,W
4042:  MOVWF  x14
4044:  MOVF   x0F,W
4046:  ADDWFC x05,W
4048:  MOVWF  x15
404A:  MOVF   x10,W
404C:  ADDWFC x06,W
404E:  MOVWF  x16
4050:  MOVF   x11,W
4052:  ADDWFC x07,W
4054:  MOVWF  x17
4056:  MOVWF  x1B
4058:  MOVFF  916,91A
405C:  MOVFF  915,919
4060:  MOVFF  914,918
4064:  MOVLB  0
4066:  CALL   3450
406A:  MOVFF  913,FEA
406E:  MOVFF  912,FE9
4072:  MOVFF  01,FEF
....................       delay_us(10); 
4076:  MOVLW  1A
4078:  MOVWF  00
407A:  DECFSZ 00,F
407C:  BRA    407A
407E:  NOP   
....................    } 
4080:  MOVLW  01
4082:  MOVLB  9
4084:  ADDWF  x0E,F
4086:  BTFSC  FD8.0
4088:  INCF   x0F,F
408A:  BTFSC  FD8.2
408C:  INCF   x10,F
408E:  BTFSC  FD8.2
4090:  INCF   x11,F
4092:  BRA    400E
.................... } 
4094:  MOVLB  0
4096:  RETURN 0
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
5DEA:  MOVLB  7
5DEC:  CLRF   xC1
5DEE:  CLRF   xC0
5DF0:  CLRF   xBF
5DF2:  CLRF   xBE
5DF4:  CLRF   xC5
5DF6:  CLRF   xC4
5DF8:  CLRF   xC3
5DFA:  CLRF   xC2
5DFC:  CLRF   xC9
5DFE:  CLRF   xC8
5E00:  CLRF   xC7
5E02:  CLRF   xC6
5E04:  CLRF   xCD
5E06:  CLRF   xCC
5E08:  CLRF   xCB
5E0A:  CLRF   xCA
5E0C:  CLRF   xD1
5E0E:  CLRF   xD0
5E10:  CLRF   xCF
5E12:  CLRF   xCE
5E14:  CLRF   19
5E16:  BTFSC  FF2.7
5E18:  BSF    19.7
5E1A:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
5E1C:  MOVLB  9
5E1E:  CLRF   x1B
5E20:  CLRF   x1A
5E22:  CLRF   x19
5E24:  MOVFF  7BD,918
5E28:  MOVLB  0
5E2A:  CALL   3450
5E2E:  BTFSC  19.7
5E30:  BSF    FF2.7
5E32:  MOVLB  7
5E34:  MOVFF  01,7C2
5E38:  CLRF   xC3
5E3A:  CLRF   xC4
5E3C:  CLRF   xC5
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
5E3E:  MOVLW  01
5E40:  ADDWF  xBD,W
5E42:  MOVWF  xD2
5E44:  CLRF   19
5E46:  BTFSC  FF2.7
5E48:  BSF    19.7
5E4A:  BCF    FF2.7
5E4C:  MOVLB  9
5E4E:  CLRF   x1B
5E50:  CLRF   x1A
5E52:  CLRF   x19
5E54:  MOVWF  x18
5E56:  MOVLB  0
5E58:  CALL   3450
5E5C:  BTFSC  19.7
5E5E:  BSF    FF2.7
5E60:  MOVLB  7
5E62:  CLRF   xC9
5E64:  CLRF   xC8
5E66:  CLRF   xC7
5E68:  MOVFF  01,7C6
....................    temp2<<=8; 
5E6C:  MOVFF  7C8,7C9
5E70:  MOVFF  7C7,7C8
5E74:  MOVFF  7C6,7C7
5E78:  CLRF   xC6
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
5E7A:  MOVLW  02
5E7C:  ADDWF  xBD,W
5E7E:  MOVWF  xD2
5E80:  CLRF   19
5E82:  BTFSC  FF2.7
5E84:  BSF    19.7
5E86:  BCF    FF2.7
5E88:  MOVLB  9
5E8A:  CLRF   x1B
5E8C:  CLRF   x1A
5E8E:  CLRF   x19
5E90:  MOVWF  x18
5E92:  MOVLB  0
5E94:  CALL   3450
5E98:  BTFSC  19.7
5E9A:  BSF    FF2.7
5E9C:  MOVLB  7
5E9E:  CLRF   xCD
5EA0:  CLRF   xCC
5EA2:  CLRF   xCB
5EA4:  MOVFF  01,7CA
....................    temp3<<=16; 
5EA8:  MOVFF  7CB,7CD
5EAC:  MOVFF  7CA,7CC
5EB0:  CLRF   xCA
5EB2:  CLRF   xCB
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
5EB4:  MOVLW  03
5EB6:  ADDWF  xBD,W
5EB8:  MOVWF  xD2
5EBA:  CLRF   19
5EBC:  BTFSC  FF2.7
5EBE:  BSF    19.7
5EC0:  BCF    FF2.7
5EC2:  MOVLB  9
5EC4:  CLRF   x1B
5EC6:  CLRF   x1A
5EC8:  CLRF   x19
5ECA:  MOVWF  x18
5ECC:  MOVLB  0
5ECE:  CALL   3450
5ED2:  BTFSC  19.7
5ED4:  BSF    FF2.7
5ED6:  MOVLB  7
5ED8:  CLRF   xD1
5EDA:  CLRF   xD0
5EDC:  CLRF   xCF
5EDE:  MOVFF  01,7CE
....................    temp4<<=24; 
5EE2:  MOVFF  7CE,7D1
5EE6:  CLRF   xCE
5EE8:  CLRF   xCF
5EEA:  CLRF   xD0
....................    buffer = temp4|temp3|temp2|temp1; 
5EEC:  MOVF   xCE,W
5EEE:  IORWF  xCA,W
5EF0:  MOVWF  xD2
5EF2:  MOVF   xCF,W
5EF4:  IORWF  xCB,W
5EF6:  MOVWF  xD3
5EF8:  MOVF   xD0,W
5EFA:  IORWF  xCC,W
5EFC:  MOVWF  xD4
5EFE:  MOVF   xD1,W
5F00:  IORWF  xCD,W
5F02:  MOVWF  xD5
5F04:  MOVF   xC6,W
5F06:  IORWF  xD2,F
5F08:  MOVF   xC7,W
5F0A:  IORWF  xD3,F
5F0C:  MOVF   xC8,W
5F0E:  IORWF  xD4,F
5F10:  MOVF   xC9,W
5F12:  IORWF  xD5,F
5F14:  MOVF   xD2,W
5F16:  IORWF  xC2,W
5F18:  MOVWF  xBE
5F1A:  MOVF   xD3,W
5F1C:  IORWF  xC3,W
5F1E:  MOVWF  xBF
5F20:  MOVF   xD4,W
5F22:  IORWF  xC4,W
5F24:  MOVWF  xC0
5F26:  MOVF   xD5,W
5F28:  IORWF  xC5,W
5F2A:  MOVWF  xC1
....................    return(buffer); 
5F2C:  MOVFF  7BE,00
5F30:  MOVFF  7BF,01
5F34:  MOVFF  7C0,02
5F38:  MOVFF  7C1,03
.................... } 
5F3C:  MOVLB  0
5F3E:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3B6A:  MOVLB  8
3B6C:  CLRF   xFF
3B6E:  CLRF   xFE
3B70:  CLRF   xFD
3B72:  CLRF   xFC
3B74:  MOVLB  9
3B76:  CLRF   x00
3B78:  CLRF   x01
3B7A:  CLRF   x02
3B7C:  CLRF   x03
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3B7E:  MOVFF  8FA,8FF
3B82:  MOVFF  8F9,8FE
3B86:  MOVFF  8F8,8FD
3B8A:  MOVFF  8F7,8FC
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3B8E:  MOVFF  8FC,900
3B92:  MOVLB  9
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3B94:  MOVFF  8FD,901
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3B98:  MOVFF  8FE,902
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3B9C:  MOVFF  8FF,903
....................    write_ext_eeprom((addr+0),temp1); 
3BA0:  CLRF   x16
3BA2:  CLRF   x15
3BA4:  CLRF   x14
3BA6:  MOVFF  8FB,913
3BAA:  MOVFF  900,917
3BAE:  MOVLB  0
3BB0:  RCALL  3A6C
....................    write_ext_eeprom((addr+1),temp2); 
3BB2:  MOVLW  01
3BB4:  MOVLB  8
3BB6:  ADDWF  xFB,W
3BB8:  MOVLB  9
3BBA:  MOVWF  x04
3BBC:  CLRF   x16
3BBE:  CLRF   x15
3BC0:  CLRF   x14
3BC2:  MOVWF  x13
3BC4:  MOVFF  901,917
3BC8:  MOVLB  0
3BCA:  RCALL  3A6C
....................    write_ext_eeprom((addr+2),temp3); 
3BCC:  MOVLW  02
3BCE:  MOVLB  8
3BD0:  ADDWF  xFB,W
3BD2:  MOVLB  9
3BD4:  MOVWF  x04
3BD6:  CLRF   x16
3BD8:  CLRF   x15
3BDA:  CLRF   x14
3BDC:  MOVWF  x13
3BDE:  MOVFF  902,917
3BE2:  MOVLB  0
3BE4:  RCALL  3A6C
....................    write_ext_eeprom((addr+3),temp4); 
3BE6:  MOVLW  03
3BE8:  MOVLB  8
3BEA:  ADDWF  xFB,W
3BEC:  MOVLB  9
3BEE:  MOVWF  x04
3BF0:  CLRF   x16
3BF2:  CLRF   x15
3BF4:  CLRF   x14
3BF6:  MOVWF  x13
3BF8:  MOVFF  903,917
3BFC:  MOVLB  0
3BFE:  RCALL  3A6C
.................... } 
3C00:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
58DC:  MOVLB  8
58DE:  CLRF   x53
58E0:  CLRF   x52
58E2:  CLRF   x54
58E4:  CLRF   x55
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
58E6:  MOVFF  851,853
58EA:  MOVFF  850,852
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
58EE:  MOVFF  852,854
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
58F2:  MOVF   x53,W
58F4:  MOVWF  x55
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
58F6:  MOVLB  9
58F8:  CLRF   x16
58FA:  CLRF   x15
58FC:  CLRF   x14
58FE:  MOVLW  24
5900:  MOVWF  x13
5902:  MOVFF  854,917
5906:  MOVLB  0
5908:  CALL   3A6C
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
590C:  MOVLB  9
590E:  CLRF   x16
5910:  CLRF   x15
5912:  CLRF   x14
5914:  MOVLW  25
5916:  MOVWF  x13
5918:  MOVFF  855,917
591C:  MOVLB  0
591E:  CALL   3A6C
.................... } 
5922:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
351C:  MOVLB  8
351E:  CLRF   xF8
3520:  CLRF   xF7
3522:  CLRF   xFA
3524:  CLRF   xF9
3526:  CLRF   xFC
3528:  CLRF   xFB
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
352A:  MOVLB  9
352C:  CLRF   x1B
352E:  CLRF   x1A
3530:  CLRF   x19
3532:  MOVLW  24
3534:  MOVWF  x18
3536:  MOVLB  0
3538:  RCALL  3450
353A:  MOVLB  8
353C:  MOVFF  01,8F9
3540:  CLRF   xFA
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3542:  MOVLB  9
3544:  CLRF   x1B
3546:  CLRF   x1A
3548:  CLRF   x19
354A:  MOVLW  25
354C:  MOVWF  x18
354E:  MOVLB  0
3550:  RCALL  3450
3552:  MOVLB  8
3554:  CLRF   xFC
3556:  MOVFF  01,8FB
....................    temp2<<=8; 
355A:  MOVFF  8FB,8FC
355E:  CLRF   xFB
....................    buffer = temp2|temp1; 
3560:  MOVF   xFB,W
3562:  IORWF  xF9,W
3564:  MOVWF  xF7
3566:  MOVF   xFC,W
3568:  IORWF  xFA,W
356A:  MOVWF  xF8
....................    return(buffer); 
356C:  MOVFF  8F7,01
3570:  MOVFF  8F8,02
.................... } 
3574:  MOVLB  0
3576:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................    /*for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    }*/ 
....................    //fprintf(COM2," ptr_card=%lu\n\r",ptr_card); 
....................    /*for(i=ptr_start;i<ptr_card;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
*
68C8:  CLRF   23
68CA:  CLRF   22
68CC:  CLRF   21
68CE:  MOVLW  96
68D0:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
68D2:  CLRF   27
68D4:  MOVLW  01
68D6:  MOVWF  26
68D8:  MOVLW  C3
68DA:  MOVWF  25
68DC:  MOVLW  0F
68DE:  MOVWF  24
68E0:  CLRF   19
68E2:  BTFSC  FF2.7
68E4:  BSF    19.7
68E6:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
68E8:  MOVFF  23,8FA
68EC:  MOVFF  22,8F9
68F0:  MOVFF  21,8F8
68F4:  MOVFF  20,8F7
68F8:  MOVLW  19
68FA:  MOVLB  8
68FC:  MOVWF  xFB
68FE:  MOVLB  0
6900:  CALL   3B6A
6904:  BTFSC  19.7
6906:  BSF    FF2.7
6908:  CLRF   19
690A:  BTFSC  FF2.7
690C:  BSF    19.7
690E:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
6910:  MOVFF  27,8FA
6914:  MOVFF  26,8F9
6918:  MOVFF  25,8F8
691C:  MOVFF  24,8F7
6920:  MOVLW  1E
6922:  MOVLB  8
6924:  MOVWF  xFB
6926:  MOVLB  0
6928:  CALL   3B6A
692C:  BTFSC  19.7
692E:  BSF    FF2.7
6930:  CLRF   19
6932:  BTFSC  FF2.7
6934:  BSF    19.7
6936:  BCF    FF2.7
....................    save_coutcard(0); 
6938:  MOVLB  8
693A:  CLRF   x51
693C:  CLRF   x50
693E:  MOVLB  0
6940:  CALL   58DC
6944:  BTFSC  19.7
6946:  BSF    FF2.7
6948:  CLRF   19
694A:  BTFSC  FF2.7
694C:  BSF    19.7
694E:  BCF    FF2.7
....................    countcard=get_countcard(); 
6950:  CALL   351C
6954:  BTFSC  19.7
6956:  BSF    FF2.7
6958:  MOVFF  02,FE
695C:  MOVFF  01,FD
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
6960:  GOTO   6CC0 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    ptr_card=ptr_start; 
6964:  CLRF   23
6966:  CLRF   22
6968:  CLRF   21
696A:  MOVLW  96
696C:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
696E:  CLRF   27
6970:  MOVLW  01
6972:  MOVWF  26
6974:  MOVLW  C3
6976:  MOVWF  25
6978:  MOVLW  0F
697A:  MOVWF  24
697C:  CLRF   19
697E:  BTFSC  FF2.7
6980:  BSF    19.7
6982:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
6984:  MOVFF  23,8FA
6988:  MOVFF  22,8F9
698C:  MOVFF  21,8F8
6990:  MOVFF  20,8F7
6994:  MOVLW  19
6996:  MOVLB  8
6998:  MOVWF  xFB
699A:  MOVLB  0
699C:  CALL   3B6A
69A0:  BTFSC  19.7
69A2:  BSF    FF2.7
69A4:  CLRF   19
69A6:  BTFSC  FF2.7
69A8:  BSF    19.7
69AA:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
69AC:  MOVFF  27,8FA
69B0:  MOVFF  26,8F9
69B4:  MOVFF  25,8F8
69B8:  MOVFF  24,8F7
69BC:  MOVLW  1E
69BE:  MOVLB  8
69C0:  MOVWF  xFB
69C2:  MOVLB  0
69C4:  CALL   3B6A
69C8:  BTFSC  19.7
69CA:  BSF    FF2.7
69CC:  CLRF   19
69CE:  BTFSC  FF2.7
69D0:  BSF    19.7
69D2:  BCF    FF2.7
....................    save_coutcard(0); 
69D4:  MOVLB  8
69D6:  CLRF   x51
69D8:  CLRF   x50
69DA:  MOVLB  0
69DC:  CALL   58DC
69E0:  BTFSC  19.7
69E2:  BSF    FF2.7
.................... } 
69E4:  GOTO   6D24 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
*
5D2E:  CLRF   19
5D30:  BTFSC  FF2.7
5D32:  BSF    19.7
5D34:  BCF    FF2.7
....................       EEPROM_read(strobe_pass_addr,20,password); 
5D36:  MOVLB  9
5D38:  CLRF   x07
5D3A:  CLRF   x06
5D3C:  CLRF   x05
5D3E:  CLRF   x04
5D40:  CLRF   x0B
5D42:  CLRF   x0A
5D44:  CLRF   x09
5D46:  MOVLW  14
5D48:  MOVWF  x08
5D4A:  CLRF   x0D
5D4C:  MOVLW  55
5D4E:  MOVWF  x0C
5D50:  MOVLB  0
5D52:  CALL   4004
5D56:  BTFSC  19.7
5D58:  BSF    FF2.7
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5D5A:  INCFSZ 55,W
5D5C:  BRA    5DE8
5D5E:  INCFSZ 56,W
5D60:  BRA    5DE8
5D62:  INCFSZ x64,W
5D64:  BRA    5DE8
....................       { 
....................          memset(buffer1,0,20); 
5D66:  CLRF   FEA
5D68:  MOVLW  2D
5D6A:  MOVWF  FE9
5D6C:  CLRF   00
5D6E:  CLRF   02
5D70:  MOVLW  14
5D72:  MOVWF  01
5D74:  CALL   359A
....................          strcpy(buffer1,"admin"); 
5D78:  CLRF   FEA
5D7A:  MOVLW  2D
5D7C:  MOVWF  FE9
5D7E:  MOVLW  00
5D80:  CALL   00BA
5D84:  TBLRD*-
5D86:  TBLRD*+
5D88:  MOVF   FF5,W
5D8A:  MOVWF  FEE
5D8C:  IORLW  00
5D8E:  BNZ   5D86
5D90:  CLRF   19
5D92:  BTFSC  FF2.7
5D94:  BSF    19.7
5D96:  BCF    FF2.7
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
5D98:  MOVLB  9
5D9A:  CLRF   x03
5D9C:  CLRF   x02
5D9E:  CLRF   x01
5DA0:  CLRF   x00
5DA2:  CLRF   x07
5DA4:  CLRF   x06
5DA6:  CLRF   x05
5DA8:  MOVLW  14
5DAA:  MOVWF  x04
5DAC:  CLRF   x09
5DAE:  MOVLW  2D
5DB0:  MOVWF  x08
5DB2:  MOVLB  0
5DB4:  CALL   4EF6
5DB8:  BTFSC  19.7
5DBA:  BSF    FF2.7
5DBC:  CLRF   19
5DBE:  BTFSC  FF2.7
5DC0:  BSF    19.7
5DC2:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
5DC4:  MOVLB  9
5DC6:  CLRF   x07
5DC8:  CLRF   x06
5DCA:  CLRF   x05
5DCC:  CLRF   x04
5DCE:  CLRF   x0B
5DD0:  CLRF   x0A
5DD2:  CLRF   x09
5DD4:  MOVLW  14
5DD6:  MOVWF  x08
5DD8:  CLRF   x0D
5DDA:  MOVLW  55
5DDC:  MOVWF  x0C
5DDE:  MOVLB  0
5DE0:  CALL   4004
5DE4:  BTFSC  19.7
5DE6:  BSF    FF2.7
....................       } 
.................... } 
5DE8:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
69E8:  MOVLB  8
69EA:  CLRF   x07
69EC:  MOVF   x07,W
69EE:  SUBLW  13
69F0:  BNC   6A06
69F2:  CLRF   03
69F4:  MOVF   x07,W
69F6:  ADDLW  F3
69F8:  MOVWF  FE9
69FA:  MOVLW  07
69FC:  ADDWFC 03,W
69FE:  MOVWF  FEA
6A00:  SETF   FEF
6A02:  INCF   x07,F
6A04:  BRA    69EC
6A06:  CLRF   19
6A08:  BTFSC  FF2.7
6A0A:  BSF    19.7
6A0C:  BCF    FF2.7
....................    EEPROM_write(strobe_pass_addr,20,buf); 
6A0E:  MOVLB  9
6A10:  CLRF   x03
6A12:  CLRF   x02
6A14:  CLRF   x01
6A16:  CLRF   x00
6A18:  CLRF   x07
6A1A:  CLRF   x06
6A1C:  CLRF   x05
6A1E:  MOVLW  14
6A20:  MOVWF  x04
6A22:  MOVLW  07
6A24:  MOVWF  x09
6A26:  MOVLW  F3
6A28:  MOVWF  x08
6A2A:  MOVLB  0
6A2C:  CALL   4EF6
6A30:  BTFSC  19.7
6A32:  BSF    FF2.7
.................... } 
6A34:  GOTO   6D88 (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
....................  
.................... #define CRYPTO_KEY_SIZE   32 
....................  
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 cryption_enable=0; 
....................  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int16 galois_mul2(unsigned int16 value) 
.................... { 
....................   signed int16 temp; 
....................   // cast to signed value 
....................   temp = (signed char) value; 
*
4098:  CLRF   03
409A:  MOVLB  9
409C:  MOVF   x0D,W
409E:  BTFSC  FE8.7
40A0:  DECF   03,F
40A2:  MOVWF  x0F
40A4:  MOVFF  03,910
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
40A8:  RRCF   x10,W
40AA:  MOVWF  03
40AC:  RRCF   x0F,W
40AE:  MOVWF  02
40B0:  RRCF   03,F
40B2:  RRCF   02,F
40B4:  RRCF   03,F
40B6:  RRCF   02,F
40B8:  RRCF   03,F
40BA:  RRCF   02,F
40BC:  RRCF   03,F
40BE:  RRCF   02,F
40C0:  RRCF   03,F
40C2:  RRCF   02,F
40C4:  RRCF   03,F
40C6:  RRCF   02,F
40C8:  MOVLW  01
40CA:  ANDWF  03,F
40CC:  MOVFF  02,90F
40D0:  MOVFF  03,910
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
40D4:  MOVLW  1B
40D6:  ANDWF  x0F,F
40D8:  CLRF   x10
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
40DA:  BCF    FD8.0
40DC:  RLCF   x0D,W
40DE:  MOVWF  x11
40E0:  RLCF   x0E,W
40E2:  MOVWF  x12
40E4:  MOVF   x11,W
40E6:  XORWF  x0F,W
40E8:  MOVWF  00
40EA:  MOVF   x12,W
40EC:  XORWF  x10,W
40EE:  MOVWF  03
40F0:  MOVFF  00,01
40F4:  MOVWF  02
.................... } 
40F6:  MOVLB  0
40F8:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................     unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................  
....................   // In case of decryption 
....................   if (dir != 0)  
40FA:  MOVLB  8
40FC:  MOVF   xFB,F
40FE:  BTFSC  FD8.2
4100:  BRA    430A
....................   { 
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
4102:  MOVLB  9
4104:  CLRF   x00
4106:  MOVF   x00,W
4108:  SUBLW  09
410A:  BTFSS  FD8.0
410C:  BRA    42B4
....................       //key schedule 
....................       key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[round]); 
410E:  MOVFF  8F9,01
4112:  MOVFF  8FA,03
4116:  MOVFF  8F9,902
411A:  MOVFF  8FA,903
411E:  MOVLW  0D
4120:  MOVLB  8
4122:  ADDWF  xF9,W
4124:  MOVWF  FE9
4126:  MOVLW  00
4128:  ADDWFC xFA,W
412A:  MOVWF  FEA
412C:  CLRF   03
412E:  MOVF   FEF,W
4130:  MOVLB  0
4132:  CALL   00D0
4136:  MOVLB  9
4138:  MOVWF  x04
413A:  MOVLB  8
413C:  MOVFF  8F9,FE9
4140:  MOVFF  8FA,FEA
4144:  MOVF   FEF,W
4146:  MOVLB  9
4148:  XORWF  x04,F
414A:  CLRF   03
414C:  MOVF   x00,W
414E:  MOVLB  0
4150:  CALL   02F0
4154:  MOVWF  01
4156:  MOVLB  9
4158:  MOVF   x04,W
415A:  XORWF  01,W
415C:  MOVFF  903,FEA
4160:  MOVFF  902,FE9
4164:  MOVWF  FEF
....................       key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4166:  MOVLW  01
4168:  MOVLB  8
416A:  ADDWF  xF9,W
416C:  MOVWF  01
416E:  MOVLW  00
4170:  ADDWFC xFA,W
4172:  MOVWF  03
4174:  MOVFF  01,902
4178:  MOVLB  9
417A:  MOVWF  x03
417C:  MOVLW  0E
417E:  MOVLB  8
4180:  ADDWF  xF9,W
4182:  MOVWF  FE9
4184:  MOVLW  00
4186:  ADDWFC xFA,W
4188:  MOVWF  FEA
418A:  CLRF   03
418C:  MOVF   FEF,W
418E:  MOVLB  0
4190:  CALL   00D0
4194:  MOVLB  9
4196:  MOVWF  x04
4198:  MOVLW  01
419A:  MOVLB  8
419C:  ADDWF  xF9,W
419E:  MOVWF  FE9
41A0:  MOVLW  00
41A2:  ADDWFC xFA,W
41A4:  MOVWF  FEA
41A6:  MOVF   FEF,W
41A8:  MOVLB  9
41AA:  XORWF  x04,W
41AC:  MOVFF  903,FEA
41B0:  MOVFF  902,FE9
41B4:  MOVWF  FEF
....................       key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
41B6:  MOVLW  02
41B8:  MOVLB  8
41BA:  ADDWF  xF9,W
41BC:  MOVWF  01
41BE:  MOVLW  00
41C0:  ADDWFC xFA,W
41C2:  MOVWF  03
41C4:  MOVFF  01,902
41C8:  MOVLB  9
41CA:  MOVWF  x03
41CC:  MOVLW  0F
41CE:  MOVLB  8
41D0:  ADDWF  xF9,W
41D2:  MOVWF  FE9
41D4:  MOVLW  00
41D6:  ADDWFC xFA,W
41D8:  MOVWF  FEA
41DA:  CLRF   03
41DC:  MOVF   FEF,W
41DE:  MOVLB  0
41E0:  CALL   00D0
41E4:  MOVLB  9
41E6:  MOVWF  x04
41E8:  MOVLW  02
41EA:  MOVLB  8
41EC:  ADDWF  xF9,W
41EE:  MOVWF  FE9
41F0:  MOVLW  00
41F2:  ADDWFC xFA,W
41F4:  MOVWF  FEA
41F6:  MOVF   FEF,W
41F8:  MOVLB  9
41FA:  XORWF  x04,W
41FC:  MOVFF  903,FEA
4200:  MOVFF  902,FE9
4204:  MOVWF  FEF
....................       key[3] = (unsigned int8)(sbox[key[12]]^key[3]); 
4206:  MOVLW  03
4208:  MOVLB  8
420A:  ADDWF  xF9,W
420C:  MOVWF  01
420E:  MOVLW  00
4210:  ADDWFC xFA,W
4212:  MOVWF  03
4214:  MOVFF  01,902
4218:  MOVLB  9
421A:  MOVWF  x03
421C:  MOVLW  0C
421E:  MOVLB  8
4220:  ADDWF  xF9,W
4222:  MOVWF  FE9
4224:  MOVLW  00
4226:  ADDWFC xFA,W
4228:  MOVWF  FEA
422A:  CLRF   03
422C:  MOVF   FEF,W
422E:  MOVLB  0
4230:  CALL   00D0
4234:  MOVLB  9
4236:  MOVWF  x04
4238:  MOVLW  03
423A:  MOVLB  8
423C:  ADDWF  xF9,W
423E:  MOVWF  FE9
4240:  MOVLW  00
4242:  ADDWFC xFA,W
4244:  MOVWF  FEA
4246:  MOVF   FEF,W
4248:  MOVLB  9
424A:  XORWF  x04,W
424C:  MOVFF  903,FEA
4250:  MOVFF  902,FE9
4254:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4256:  MOVLW  04
4258:  MOVWF  x01
425A:  MOVF   x01,W
425C:  SUBLW  0F
425E:  BNC   42B0
....................         key[i] = key[i] ^ key[i-4]; 
4260:  CLRF   03
4262:  MOVF   x01,W
4264:  MOVLB  8
4266:  ADDWF  xF9,W
4268:  MOVWF  01
426A:  MOVF   xFA,W
426C:  ADDWFC 03,F
426E:  MOVLB  9
4270:  MOVFF  03,903
4274:  CLRF   03
4276:  MOVF   x01,W
4278:  MOVLB  8
427A:  ADDWF  xF9,W
427C:  MOVWF  FE9
427E:  MOVF   xFA,W
4280:  ADDWFC 03,W
4282:  MOVWF  FEA
4284:  MOVFF  FEF,904
4288:  MOVLW  04
428A:  MOVLB  9
428C:  SUBWF  x01,W
428E:  CLRF   03
4290:  MOVLB  8
4292:  ADDWF  xF9,W
4294:  MOVWF  FE9
4296:  MOVF   xFA,W
4298:  ADDWFC 03,W
429A:  MOVWF  FEA
429C:  MOVF   FEF,W
429E:  MOVLB  9
42A0:  XORWF  x04,W
42A2:  MOVFF  903,FEA
42A6:  MOVFF  01,FE9
42AA:  MOVWF  FEF
....................       } 
42AC:  INCF   x01,F
42AE:  BRA    425A
....................     } 
42B0:  INCF   x00,F
42B2:  BRA    4106
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++) 
42B4:  CLRF   x01
42B6:  MOVF   x01,W
42B8:  SUBLW  0F
42BA:  BNC   430A
....................     { 
....................       state[i]=state[i] ^ key[i]; 
42BC:  CLRF   03
42BE:  MOVF   x01,W
42C0:  MOVLB  8
42C2:  ADDWF  xF7,W
42C4:  MOVWF  01
42C6:  MOVF   xF8,W
42C8:  ADDWFC 03,F
42CA:  MOVLB  9
42CC:  MOVFF  03,903
42D0:  CLRF   03
42D2:  MOVF   x01,W
42D4:  MOVLB  8
42D6:  ADDWF  xF7,W
42D8:  MOVWF  FE9
42DA:  MOVF   xF8,W
42DC:  ADDWFC 03,W
42DE:  MOVWF  FEA
42E0:  MOVFF  FEF,904
42E4:  CLRF   03
42E6:  MOVLB  9
42E8:  MOVF   x01,W
42EA:  MOVLB  8
42EC:  ADDWF  xF9,W
42EE:  MOVWF  FE9
42F0:  MOVF   xFA,W
42F2:  ADDWFC 03,W
42F4:  MOVWF  FEA
42F6:  MOVF   FEF,W
42F8:  MOVLB  9
42FA:  XORWF  x04,W
42FC:  MOVFF  903,FEA
4300:  MOVFF  01,FE9
4304:  MOVWF  FEF
....................     } 
4306:  INCF   x01,F
4308:  BRA    42B6
....................   } 
....................   // main loop 
....................   for (round = 0; round < 10; round++) 
430A:  MOVLB  9
430C:  CLRF   x00
430E:  MOVF   x00,W
4310:  SUBLW  09
4312:  BTFSS  FD8.0
4314:  GOTO   4E92
....................   { 
....................     if (dir != 0) 
4318:  MOVLB  8
431A:  MOVF   xFB,F
431C:  BTFSC  FD8.2
431E:  BRA    44CC
....................     { 
....................           //Inverse key schedule 
....................           for (i=15; i>3; --i)  
4320:  MOVLW  0F
4322:  MOVLB  9
4324:  MOVWF  x01
4326:  MOVF   x01,W
4328:  SUBLW  03
432A:  BC    437C
....................           { 
....................             key[i] = key[i] ^ key[i-4]; 
432C:  CLRF   03
432E:  MOVF   x01,W
4330:  MOVLB  8
4332:  ADDWF  xF9,W
4334:  MOVWF  01
4336:  MOVF   xFA,W
4338:  ADDWFC 03,F
433A:  MOVLB  9
433C:  MOVFF  03,903
4340:  CLRF   03
4342:  MOVF   x01,W
4344:  MOVLB  8
4346:  ADDWF  xF9,W
4348:  MOVWF  FE9
434A:  MOVF   xFA,W
434C:  ADDWFC 03,W
434E:  MOVWF  FEA
4350:  MOVFF  FEF,904
4354:  MOVLW  04
4356:  MOVLB  9
4358:  SUBWF  x01,W
435A:  CLRF   03
435C:  MOVLB  8
435E:  ADDWF  xF9,W
4360:  MOVWF  FE9
4362:  MOVF   xFA,W
4364:  ADDWFC 03,W
4366:  MOVWF  FEA
4368:  MOVF   FEF,W
436A:  MOVLB  9
436C:  XORWF  x04,W
436E:  MOVFF  903,FEA
4372:  MOVFF  01,FE9
4376:  MOVWF  FEF
....................           }   
4378:  DECF   x01,F
437A:  BRA    4326
....................           key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[9-round]); 
437C:  MOVFF  8F9,01
4380:  MOVFF  8FA,03
4384:  MOVFF  8F9,902
4388:  MOVFF  8FA,903
438C:  MOVLW  0D
438E:  MOVLB  8
4390:  ADDWF  xF9,W
4392:  MOVWF  FE9
4394:  MOVLW  00
4396:  ADDWFC xFA,W
4398:  MOVWF  FEA
439A:  CLRF   03
439C:  MOVF   FEF,W
439E:  MOVLB  0
43A0:  CALL   00D0
43A4:  MOVLB  9
43A6:  MOVWF  x04
43A8:  MOVLB  8
43AA:  MOVFF  8F9,FE9
43AE:  MOVFF  8FA,FEA
43B2:  MOVF   FEF,W
43B4:  MOVLB  9
43B6:  XORWF  x04,F
43B8:  MOVLW  09
43BA:  BSF    FD8.0
43BC:  SUBFWB x00,W
43BE:  CLRF   03
43C0:  MOVLB  0
43C2:  CALL   02F0
43C6:  MOVWF  01
43C8:  MOVLB  9
43CA:  MOVF   x04,W
43CC:  XORWF  01,W
43CE:  MOVFF  903,FEA
43D2:  MOVFF  902,FE9
43D6:  MOVWF  FEF
....................           key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
43D8:  MOVLW  01
43DA:  MOVLB  8
43DC:  ADDWF  xF9,W
43DE:  MOVWF  01
43E0:  MOVLW  00
43E2:  ADDWFC xFA,W
43E4:  MOVWF  03
43E6:  MOVFF  01,902
43EA:  MOVLB  9
43EC:  MOVWF  x03
43EE:  MOVLW  0E
43F0:  MOVLB  8
43F2:  ADDWF  xF9,W
43F4:  MOVWF  FE9
43F6:  MOVLW  00
43F8:  ADDWFC xFA,W
43FA:  MOVWF  FEA
43FC:  CLRF   03
43FE:  MOVF   FEF,W
4400:  MOVLB  0
4402:  CALL   00D0
4406:  MOVLB  9
4408:  MOVWF  x04
440A:  MOVLW  01
440C:  MOVLB  8
440E:  ADDWF  xF9,W
4410:  MOVWF  FE9
4412:  MOVLW  00
4414:  ADDWFC xFA,W
4416:  MOVWF  FEA
4418:  MOVF   FEF,W
441A:  MOVLB  9
441C:  XORWF  x04,W
441E:  MOVFF  903,FEA
4422:  MOVFF  902,FE9
4426:  MOVWF  FEF
....................           key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
4428:  MOVLW  02
442A:  MOVLB  8
442C:  ADDWF  xF9,W
442E:  MOVWF  01
4430:  MOVLW  00
4432:  ADDWFC xFA,W
4434:  MOVWF  03
4436:  MOVFF  01,902
443A:  MOVLB  9
443C:  MOVWF  x03
443E:  MOVLW  0F
4440:  MOVLB  8
4442:  ADDWF  xF9,W
4444:  MOVWF  FE9
4446:  MOVLW  00
4448:  ADDWFC xFA,W
444A:  MOVWF  FEA
444C:  CLRF   03
444E:  MOVF   FEF,W
4450:  MOVLB  0
4452:  CALL   00D0
4456:  MOVLB  9
4458:  MOVWF  x04
445A:  MOVLW  02
445C:  MOVLB  8
445E:  ADDWF  xF9,W
4460:  MOVWF  FE9
4462:  MOVLW  00
4464:  ADDWFC xFA,W
4466:  MOVWF  FEA
4468:  MOVF   FEF,W
446A:  MOVLB  9
446C:  XORWF  x04,W
446E:  MOVFF  903,FEA
4472:  MOVFF  902,FE9
4476:  MOVWF  FEF
....................           key[3] = (unsigned int8)(sbox[key[12]]^key[3]);  
4478:  MOVLW  03
447A:  MOVLB  8
447C:  ADDWF  xF9,W
447E:  MOVWF  01
4480:  MOVLW  00
4482:  ADDWFC xFA,W
4484:  MOVWF  03
4486:  MOVFF  01,902
448A:  MOVLB  9
448C:  MOVWF  x03
448E:  MOVLW  0C
4490:  MOVLB  8
4492:  ADDWF  xF9,W
4494:  MOVWF  FE9
4496:  MOVLW  00
4498:  ADDWFC xFA,W
449A:  MOVWF  FEA
449C:  CLRF   03
449E:  MOVF   FEF,W
44A0:  MOVLB  0
44A2:  CALL   00D0
44A6:  MOVLB  9
44A8:  MOVWF  x04
44AA:  MOVLW  03
44AC:  MOVLB  8
44AE:  ADDWF  xF9,W
44B0:  MOVWF  FE9
44B2:  MOVLW  00
44B4:  ADDWFC xFA,W
44B6:  MOVWF  FEA
44B8:  MOVF   FEF,W
44BA:  MOVLB  9
44BC:  XORWF  x04,W
44BE:  MOVFF  903,FEA
44C2:  MOVFF  902,FE9
44C6:  MOVWF  FEF
....................     }  
....................     else  
44C8:  BRA    4726
44CA:  MOVLB  8
....................     { 
....................         for (i = 0; i <16; i++) 
44CC:  MOVLB  9
44CE:  CLRF   x01
44D0:  MOVF   x01,W
44D2:  SUBLW  0F
44D4:  BNC   4532
....................         { 
....................             // with shiftrow i+5 mod 16 
....................             state[i]=sbox[state[i] ^ key[i]]; 
44D6:  CLRF   03
44D8:  MOVF   x01,W
44DA:  MOVLB  8
44DC:  ADDWF  xF7,W
44DE:  MOVWF  01
44E0:  MOVF   xF8,W
44E2:  ADDWFC 03,F
44E4:  MOVFF  01,902
44E8:  MOVLB  9
44EA:  MOVFF  03,903
44EE:  CLRF   03
44F0:  MOVF   x01,W
44F2:  MOVLB  8
44F4:  ADDWF  xF7,W
44F6:  MOVWF  FE9
44F8:  MOVF   xF8,W
44FA:  ADDWFC 03,W
44FC:  MOVWF  FEA
44FE:  MOVFF  FEF,904
4502:  CLRF   03
4504:  MOVLB  9
4506:  MOVF   x01,W
4508:  MOVLB  8
450A:  ADDWF  xF9,W
450C:  MOVWF  FE9
450E:  MOVF   xFA,W
4510:  ADDWFC 03,W
4512:  MOVWF  FEA
4514:  MOVF   FEF,W
4516:  MOVLB  9
4518:  XORWF  x04,W
451A:  CLRF   03
451C:  MOVLB  0
451E:  CALL   00D0
4522:  MOVFF  903,FEA
4526:  MOVFF  902,FE9
452A:  MOVWF  FEF
....................         } 
452C:  MOVLB  9
452E:  INCF   x01,F
4530:  BRA    44D0
....................         //shift rows 
....................         buf1 = state[1]; 
4532:  MOVLW  01
4534:  MOVLB  8
4536:  ADDWF  xF7,W
4538:  MOVWF  FE9
453A:  MOVLW  00
453C:  ADDWFC xF8,W
453E:  MOVWF  FEA
4540:  MOVFF  FEF,8FC
....................         state[1] = state[5]; 
4544:  MOVLW  01
4546:  ADDWF  xF7,W
4548:  MOVWF  01
454A:  MOVLW  00
454C:  ADDWFC xF8,W
454E:  MOVWF  03
4550:  MOVLW  05
4552:  MOVLB  8
4554:  ADDWF  xF7,W
4556:  MOVWF  FE9
4558:  MOVLW  00
455A:  ADDWFC xF8,W
455C:  MOVWF  FEA
455E:  MOVFF  FEF,904
4562:  MOVLB  9
4564:  MOVFF  03,FEA
4568:  MOVFF  01,FE9
456C:  MOVFF  904,FEF
....................         state[5] = state[9]; 
4570:  MOVLW  05
4572:  MOVLB  8
4574:  ADDWF  xF7,W
4576:  MOVWF  01
4578:  MOVLW  00
457A:  ADDWFC xF8,W
457C:  MOVWF  03
457E:  MOVLW  09
4580:  MOVLB  8
4582:  ADDWF  xF7,W
4584:  MOVWF  FE9
4586:  MOVLW  00
4588:  ADDWFC xF8,W
458A:  MOVWF  FEA
458C:  MOVFF  FEF,904
4590:  MOVLB  9
4592:  MOVFF  03,FEA
4596:  MOVFF  01,FE9
459A:  MOVFF  904,FEF
....................         state[9] = state[13]; 
459E:  MOVLW  09
45A0:  MOVLB  8
45A2:  ADDWF  xF7,W
45A4:  MOVWF  01
45A6:  MOVLW  00
45A8:  ADDWFC xF8,W
45AA:  MOVWF  03
45AC:  MOVLW  0D
45AE:  MOVLB  8
45B0:  ADDWF  xF7,W
45B2:  MOVWF  FE9
45B4:  MOVLW  00
45B6:  ADDWFC xF8,W
45B8:  MOVWF  FEA
45BA:  MOVFF  FEF,904
45BE:  MOVLB  9
45C0:  MOVFF  03,FEA
45C4:  MOVFF  01,FE9
45C8:  MOVFF  904,FEF
....................         state[13] = buf1; 
45CC:  MOVLW  0D
45CE:  MOVLB  8
45D0:  ADDWF  xF7,W
45D2:  MOVWF  FE9
45D4:  MOVLW  00
45D6:  ADDWFC xF8,W
45D8:  MOVWF  FEA
45DA:  MOVFF  8FC,FEF
....................      
....................         buf1 = state[2]; 
45DE:  MOVLW  02
45E0:  ADDWF  xF7,W
45E2:  MOVWF  FE9
45E4:  MOVLW  00
45E6:  ADDWFC xF8,W
45E8:  MOVWF  FEA
45EA:  MOVFF  FEF,8FC
....................         buf2 = state[6]; 
45EE:  MOVLW  06
45F0:  ADDWF  xF7,W
45F2:  MOVWF  FE9
45F4:  MOVLW  00
45F6:  ADDWFC xF8,W
45F8:  MOVWF  FEA
45FA:  MOVFF  FEF,8FD
....................         state[2] = state[10]; 
45FE:  MOVLW  02
4600:  ADDWF  xF7,W
4602:  MOVWF  01
4604:  MOVLW  00
4606:  ADDWFC xF8,W
4608:  MOVWF  03
460A:  MOVLW  0A
460C:  MOVLB  8
460E:  ADDWF  xF7,W
4610:  MOVWF  FE9
4612:  MOVLW  00
4614:  ADDWFC xF8,W
4616:  MOVWF  FEA
4618:  MOVFF  FEF,904
461C:  MOVLB  9
461E:  MOVFF  03,FEA
4622:  MOVFF  01,FE9
4626:  MOVFF  904,FEF
....................         state[6] = state[14]; 
462A:  MOVLW  06
462C:  MOVLB  8
462E:  ADDWF  xF7,W
4630:  MOVWF  01
4632:  MOVLW  00
4634:  ADDWFC xF8,W
4636:  MOVWF  03
4638:  MOVLW  0E
463A:  MOVLB  8
463C:  ADDWF  xF7,W
463E:  MOVWF  FE9
4640:  MOVLW  00
4642:  ADDWFC xF8,W
4644:  MOVWF  FEA
4646:  MOVFF  FEF,904
464A:  MOVLB  9
464C:  MOVFF  03,FEA
4650:  MOVFF  01,FE9
4654:  MOVFF  904,FEF
....................         state[10] = buf1; 
4658:  MOVLW  0A
465A:  MOVLB  8
465C:  ADDWF  xF7,W
465E:  MOVWF  FE9
4660:  MOVLW  00
4662:  ADDWFC xF8,W
4664:  MOVWF  FEA
4666:  MOVFF  8FC,FEF
....................         state[14] = buf2; 
466A:  MOVLW  0E
466C:  ADDWF  xF7,W
466E:  MOVWF  FE9
4670:  MOVLW  00
4672:  ADDWFC xF8,W
4674:  MOVWF  FEA
4676:  MOVFF  8FD,FEF
....................      
....................         buf1 = state[15]; 
467A:  MOVLW  0F
467C:  ADDWF  xF7,W
467E:  MOVWF  FE9
4680:  MOVLW  00
4682:  ADDWFC xF8,W
4684:  MOVWF  FEA
4686:  MOVFF  FEF,8FC
....................         state[15] = state[11]; 
468A:  MOVLW  0F
468C:  ADDWF  xF7,W
468E:  MOVWF  01
4690:  MOVLW  00
4692:  ADDWFC xF8,W
4694:  MOVWF  03
4696:  MOVLW  0B
4698:  MOVLB  8
469A:  ADDWF  xF7,W
469C:  MOVWF  FE9
469E:  MOVLW  00
46A0:  ADDWFC xF8,W
46A2:  MOVWF  FEA
46A4:  MOVFF  FEF,904
46A8:  MOVLB  9
46AA:  MOVFF  03,FEA
46AE:  MOVFF  01,FE9
46B2:  MOVFF  904,FEF
....................         state[11] = state[7]; 
46B6:  MOVLW  0B
46B8:  MOVLB  8
46BA:  ADDWF  xF7,W
46BC:  MOVWF  01
46BE:  MOVLW  00
46C0:  ADDWFC xF8,W
46C2:  MOVWF  03
46C4:  MOVLW  07
46C6:  MOVLB  8
46C8:  ADDWF  xF7,W
46CA:  MOVWF  FE9
46CC:  MOVLW  00
46CE:  ADDWFC xF8,W
46D0:  MOVWF  FEA
46D2:  MOVFF  FEF,904
46D6:  MOVLB  9
46D8:  MOVFF  03,FEA
46DC:  MOVFF  01,FE9
46E0:  MOVFF  904,FEF
....................         state[7] = state[3]; 
46E4:  MOVLW  07
46E6:  MOVLB  8
46E8:  ADDWF  xF7,W
46EA:  MOVWF  01
46EC:  MOVLW  00
46EE:  ADDWFC xF8,W
46F0:  MOVWF  03
46F2:  MOVLW  03
46F4:  MOVLB  8
46F6:  ADDWF  xF7,W
46F8:  MOVWF  FE9
46FA:  MOVLW  00
46FC:  ADDWFC xF8,W
46FE:  MOVWF  FEA
4700:  MOVFF  FEF,904
4704:  MOVLB  9
4706:  MOVFF  03,FEA
470A:  MOVFF  01,FE9
470E:  MOVFF  904,FEF
....................         state[3] = buf1; 
4712:  MOVLW  03
4714:  MOVLB  8
4716:  ADDWF  xF7,W
4718:  MOVWF  FE9
471A:  MOVLW  00
471C:  ADDWFC xF8,W
471E:  MOVWF  FEA
4720:  MOVFF  8FC,FEF
4724:  MOVLB  9
....................     } 
....................      
....................     //mixcol - inv mix 
....................     if (((round > 0) && (dir != 0)) || ((round < 9) && (dir == 0)))  
4726:  MOVF   x00,F
4728:  BZ    4732
472A:  MOVLB  8
472C:  MOVF   xFB,F
472E:  BNZ   4746
4730:  MOVLB  9
4732:  MOVF   x00,W
4734:  SUBLW  08
4736:  BTFSS  FD8.0
4738:  BRA    4A8A
473A:  MOVLB  8
473C:  MOVF   xFB,F
473E:  BTFSC  FD8.2
4740:  BRA    4746
4742:  MOVLB  9
4744:  BRA    4A8A
....................     { 
....................           for (i=0; i <4; i++) 
4746:  MOVLB  9
4748:  CLRF   x01
474A:  MOVF   x01,W
474C:  SUBLW  03
474E:  BTFSS  FD8.0
4750:  BRA    4A8A
....................           { 
....................                 buf4 = (unsigned int8)(i << 2); 
4752:  RLCF   x01,W
4754:  MOVLB  8
4756:  MOVWF  xFF
4758:  RLCF   xFF,F
475A:  MOVLW  FC
475C:  ANDWF  xFF,F
....................                 if (dir != 0) 
475E:  MOVF   xFB,F
4760:  BZ    484E
....................                 { 
....................                       // precompute for decryption 
....................                       buf1 = galois_mul2(galois_mul2((unsigned int8)(state[buf4]^state[buf4+2]))); 
4762:  CLRF   03
4764:  MOVF   xFF,W
4766:  ADDWF  xF7,W
4768:  MOVWF  FE9
476A:  MOVF   xF8,W
476C:  ADDWFC 03,W
476E:  MOVWF  FEA
4770:  MOVFF  FEF,902
4774:  MOVLW  02
4776:  ADDWF  xFF,W
4778:  CLRF   03
477A:  ADDWF  xF7,W
477C:  MOVWF  FE9
477E:  MOVF   xF8,W
4780:  ADDWFC 03,W
4782:  MOVWF  FEA
4784:  MOVF   FEF,W
4786:  MOVLB  9
4788:  XORWF  x02,F
478A:  CLRF   x0E
478C:  MOVFF  902,90D
4790:  MOVLB  0
4792:  RCALL  4098
4794:  MOVFF  02,903
4798:  MOVFF  01,902
479C:  MOVFF  02,90E
47A0:  MOVFF  01,90D
47A4:  RCALL  4098
47A6:  MOVFF  01,8FC
....................                       buf2 = galois_mul2(galois_mul2((unsigned int8)(state[buf4+1]^state[buf4+3]))); 
47AA:  MOVLW  01
47AC:  MOVLB  8
47AE:  ADDWF  xFF,W
47B0:  CLRF   03
47B2:  ADDWF  xF7,W
47B4:  MOVWF  FE9
47B6:  MOVF   xF8,W
47B8:  ADDWFC 03,W
47BA:  MOVWF  FEA
47BC:  MOVFF  FEF,902
47C0:  MOVLW  03
47C2:  ADDWF  xFF,W
47C4:  CLRF   03
47C6:  ADDWF  xF7,W
47C8:  MOVWF  FE9
47CA:  MOVF   xF8,W
47CC:  ADDWFC 03,W
47CE:  MOVWF  FEA
47D0:  MOVF   FEF,W
47D2:  MOVLB  9
47D4:  XORWF  x02,F
47D6:  CLRF   x0E
47D8:  MOVFF  902,90D
47DC:  MOVLB  0
47DE:  RCALL  4098
47E0:  MOVFF  02,903
47E4:  MOVFF  01,902
47E8:  MOVFF  02,90E
47EC:  MOVFF  01,90D
47F0:  RCALL  4098
47F2:  MOVFF  01,8FD
....................                       state[buf4] ^= buf1;  
47F6:  CLRF   03
47F8:  MOVLB  8
47FA:  MOVF   xFF,W
47FC:  ADDWF  xF7,W
47FE:  MOVWF  FE9
4800:  MOVF   xF8,W
4802:  ADDWFC 03,W
4804:  MOVWF  FEA
4806:  MOVF   FEF,W
4808:  XORWF  xFC,W
480A:  MOVWF  FEF
....................                       state[buf4+1] ^= buf2;  
480C:  MOVLW  01
480E:  ADDWF  xFF,W
4810:  CLRF   03
4812:  ADDWF  xF7,W
4814:  MOVWF  FE9
4816:  MOVF   xF8,W
4818:  ADDWFC 03,W
481A:  MOVWF  FEA
481C:  MOVF   FEF,W
481E:  XORWF  xFD,W
4820:  MOVWF  FEF
....................                       state[buf4+2] ^= buf1;  
4822:  MOVLW  02
4824:  ADDWF  xFF,W
4826:  CLRF   03
4828:  ADDWF  xF7,W
482A:  MOVWF  FE9
482C:  MOVF   xF8,W
482E:  ADDWFC 03,W
4830:  MOVWF  FEA
4832:  MOVF   FEF,W
4834:  XORWF  xFC,W
4836:  MOVWF  FEF
....................                       state[buf4+3] ^= buf2;  
4838:  MOVLW  03
483A:  ADDWF  xFF,W
483C:  CLRF   03
483E:  ADDWF  xF7,W
4840:  MOVWF  FE9
4842:  MOVF   xF8,W
4844:  ADDWFC 03,W
4846:  MOVWF  FEA
4848:  MOVF   FEF,W
484A:  XORWF  xFD,W
484C:  MOVWF  FEF
....................                 } 
....................                 // in all cases 
....................                 buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
484E:  CLRF   03
4850:  MOVF   xFF,W
4852:  ADDWF  xF7,W
4854:  MOVWF  FE9
4856:  MOVF   xF8,W
4858:  ADDWFC 03,W
485A:  MOVWF  FEA
485C:  MOVFF  FEF,902
4860:  MOVLW  01
4862:  ADDWF  xFF,W
4864:  CLRF   03
4866:  ADDWF  xF7,W
4868:  MOVWF  FE9
486A:  MOVF   xF8,W
486C:  ADDWFC 03,W
486E:  MOVWF  FEA
4870:  MOVF   FEF,W
4872:  MOVLB  9
4874:  XORWF  x02,F
4876:  MOVLW  02
4878:  MOVLB  8
487A:  ADDWF  xFF,W
487C:  CLRF   03
487E:  ADDWF  xF7,W
4880:  MOVWF  FE9
4882:  MOVF   xF8,W
4884:  ADDWFC 03,W
4886:  MOVWF  FEA
4888:  MOVF   FEF,W
488A:  MOVLB  9
488C:  XORWF  x02,F
488E:  MOVLW  03
4890:  MOVLB  8
4892:  ADDWF  xFF,W
4894:  CLRF   03
4896:  ADDWF  xF7,W
4898:  MOVWF  FE9
489A:  MOVF   xF8,W
489C:  ADDWFC 03,W
489E:  MOVWF  FEA
48A0:  MOVF   FEF,W
48A2:  MOVLB  9
48A4:  XORWF  x02,W
48A6:  MOVLB  8
48A8:  MOVWF  xFC
....................                 buf2 = state[buf4]; 
48AA:  CLRF   03
48AC:  MOVF   xFF,W
48AE:  ADDWF  xF7,W
48B0:  MOVWF  FE9
48B2:  MOVF   xF8,W
48B4:  ADDWFC 03,W
48B6:  MOVWF  FEA
48B8:  MOVFF  FEF,8FD
....................                 buf3 = state[buf4]^state[buf4+1];  
48BC:  CLRF   03
48BE:  MOVF   xFF,W
48C0:  ADDWF  xF7,W
48C2:  MOVWF  FE9
48C4:  MOVF   xF8,W
48C6:  ADDWFC 03,W
48C8:  MOVWF  FEA
48CA:  MOVFF  FEF,902
48CE:  MOVLW  01
48D0:  ADDWF  xFF,W
48D2:  CLRF   03
48D4:  ADDWF  xF7,W
48D6:  MOVWF  FE9
48D8:  MOVF   xF8,W
48DA:  ADDWFC 03,W
48DC:  MOVWF  FEA
48DE:  MOVF   FEF,W
48E0:  MOVLB  9
48E2:  XORWF  x02,W
48E4:  MOVLB  8
48E6:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
48E8:  MOVLB  9
48EA:  CLRF   x0E
48EC:  MOVFF  8FE,90D
48F0:  MOVLB  0
48F2:  CALL   4098
48F6:  MOVFF  01,8FE
....................                 state[buf4] = state[buf4] ^ buf3 ^ buf1; 
48FA:  CLRF   03
48FC:  MOVLB  8
48FE:  MOVF   xFF,W
4900:  ADDWF  xF7,W
4902:  MOVWF  01
4904:  MOVF   xF8,W
4906:  ADDWFC 03,F
4908:  MOVLB  9
490A:  MOVFF  03,903
490E:  CLRF   03
4910:  MOVLB  8
4912:  MOVF   xFF,W
4914:  ADDWF  xF7,W
4916:  MOVWF  FE9
4918:  MOVF   xF8,W
491A:  ADDWFC 03,W
491C:  MOVWF  FEA
491E:  MOVF   FEF,W
4920:  XORWF  xFE,W
4922:  XORWF  xFC,W
4924:  MOVLB  9
4926:  MOVFF  903,FEA
492A:  MOVFF  01,FE9
492E:  MOVWF  FEF
....................                 buf3 = state[buf4+1]^state[buf4+2];  
4930:  MOVLW  01
4932:  MOVLB  8
4934:  ADDWF  xFF,W
4936:  CLRF   03
4938:  ADDWF  xF7,W
493A:  MOVWF  FE9
493C:  MOVF   xF8,W
493E:  ADDWFC 03,W
4940:  MOVWF  FEA
4942:  MOVFF  FEF,902
4946:  MOVLW  02
4948:  ADDWF  xFF,W
494A:  CLRF   03
494C:  ADDWF  xF7,W
494E:  MOVWF  FE9
4950:  MOVF   xF8,W
4952:  ADDWFC 03,W
4954:  MOVWF  FEA
4956:  MOVF   FEF,W
4958:  MOVLB  9
495A:  XORWF  x02,W
495C:  MOVLB  8
495E:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
4960:  MOVLB  9
4962:  CLRF   x0E
4964:  MOVFF  8FE,90D
4968:  MOVLB  0
496A:  CALL   4098
496E:  MOVFF  01,8FE
....................                 state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
4972:  MOVLW  01
4974:  MOVLB  8
4976:  ADDWF  xFF,W
4978:  CLRF   03
497A:  ADDWF  xF7,W
497C:  MOVWF  01
497E:  MOVF   xF8,W
4980:  ADDWFC 03,F
4982:  MOVFF  03,903
4986:  MOVLW  01
4988:  MOVLB  8
498A:  ADDWF  xFF,W
498C:  CLRF   03
498E:  ADDWF  xF7,W
4990:  MOVWF  FE9
4992:  MOVF   xF8,W
4994:  ADDWFC 03,W
4996:  MOVWF  FEA
4998:  MOVF   FEF,W
499A:  XORWF  xFE,W
499C:  XORWF  xFC,W
499E:  MOVLB  9
49A0:  MOVFF  903,FEA
49A4:  MOVFF  01,FE9
49A8:  MOVWF  FEF
....................                 buf3 = state[buf4+2]^state[buf4+3];  
49AA:  MOVLW  02
49AC:  MOVLB  8
49AE:  ADDWF  xFF,W
49B0:  CLRF   03
49B2:  ADDWF  xF7,W
49B4:  MOVWF  FE9
49B6:  MOVF   xF8,W
49B8:  ADDWFC 03,W
49BA:  MOVWF  FEA
49BC:  MOVFF  FEF,902
49C0:  MOVLW  03
49C2:  ADDWF  xFF,W
49C4:  CLRF   03
49C6:  ADDWF  xF7,W
49C8:  MOVWF  FE9
49CA:  MOVF   xF8,W
49CC:  ADDWFC 03,W
49CE:  MOVWF  FEA
49D0:  MOVF   FEF,W
49D2:  MOVLB  9
49D4:  XORWF  x02,W
49D6:  MOVLB  8
49D8:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
49DA:  MOVLB  9
49DC:  CLRF   x0E
49DE:  MOVFF  8FE,90D
49E2:  MOVLB  0
49E4:  CALL   4098
49E8:  MOVFF  01,8FE
....................                 state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
49EC:  MOVLW  02
49EE:  MOVLB  8
49F0:  ADDWF  xFF,W
49F2:  CLRF   03
49F4:  ADDWF  xF7,W
49F6:  MOVWF  01
49F8:  MOVF   xF8,W
49FA:  ADDWFC 03,F
49FC:  MOVFF  03,903
4A00:  MOVLW  02
4A02:  MOVLB  8
4A04:  ADDWF  xFF,W
4A06:  CLRF   03
4A08:  ADDWF  xF7,W
4A0A:  MOVWF  FE9
4A0C:  MOVF   xF8,W
4A0E:  ADDWFC 03,W
4A10:  MOVWF  FEA
4A12:  MOVF   FEF,W
4A14:  XORWF  xFE,W
4A16:  XORWF  xFC,W
4A18:  MOVLB  9
4A1A:  MOVFF  903,FEA
4A1E:  MOVFF  01,FE9
4A22:  MOVWF  FEF
....................                 buf3 = state[buf4+3]^buf2;      
4A24:  MOVLW  03
4A26:  MOVLB  8
4A28:  ADDWF  xFF,W
4A2A:  CLRF   03
4A2C:  ADDWF  xF7,W
4A2E:  MOVWF  FE9
4A30:  MOVF   xF8,W
4A32:  ADDWFC 03,W
4A34:  MOVWF  FEA
4A36:  MOVF   FEF,W
4A38:  XORWF  xFD,W
4A3A:  MOVWF  xFE
....................                 buf3=galois_mul2(buf3);  
4A3C:  MOVLB  9
4A3E:  CLRF   x0E
4A40:  MOVFF  8FE,90D
4A44:  MOVLB  0
4A46:  CALL   4098
4A4A:  MOVFF  01,8FE
....................                 state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1;  
4A4E:  MOVLW  03
4A50:  MOVLB  8
4A52:  ADDWF  xFF,W
4A54:  CLRF   03
4A56:  ADDWF  xF7,W
4A58:  MOVWF  01
4A5A:  MOVF   xF8,W
4A5C:  ADDWFC 03,F
4A5E:  MOVFF  03,903
4A62:  MOVLW  03
4A64:  MOVLB  8
4A66:  ADDWF  xFF,W
4A68:  CLRF   03
4A6A:  ADDWF  xF7,W
4A6C:  MOVWF  FE9
4A6E:  MOVF   xF8,W
4A70:  ADDWFC 03,W
4A72:  MOVWF  FEA
4A74:  MOVF   FEF,W
4A76:  XORWF  xFE,W
4A78:  XORWF  xFC,W
4A7A:  MOVLB  9
4A7C:  MOVFF  903,FEA
4A80:  MOVFF  01,FE9
4A84:  MOVWF  FEF
....................           } 
4A86:  INCF   x01,F
4A88:  BRA    474A
....................     } 
....................      
....................     if (dir != 0)  
4A8A:  MOVLB  8
4A8C:  MOVF   xFB,F
4A8E:  BTFSC  FD8.2
4A90:  BRA    4CEA
....................     { 
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
4A92:  MOVLW  0D
4A94:  ADDWF  xF7,W
4A96:  MOVWF  FE9
4A98:  MOVLW  00
4A9A:  ADDWFC xF8,W
4A9C:  MOVWF  FEA
4A9E:  MOVFF  FEF,8FC
....................       state[13] = state[9]; 
4AA2:  MOVLW  0D
4AA4:  ADDWF  xF7,W
4AA6:  MOVWF  01
4AA8:  MOVLW  00
4AAA:  ADDWFC xF8,W
4AAC:  MOVWF  03
4AAE:  MOVLW  09
4AB0:  MOVLB  8
4AB2:  ADDWF  xF7,W
4AB4:  MOVWF  FE9
4AB6:  MOVLW  00
4AB8:  ADDWFC xF8,W
4ABA:  MOVWF  FEA
4ABC:  MOVFF  FEF,904
4AC0:  MOVLB  9
4AC2:  MOVFF  03,FEA
4AC6:  MOVFF  01,FE9
4ACA:  MOVFF  904,FEF
....................       state[9] = state[5]; 
4ACE:  MOVLW  09
4AD0:  MOVLB  8
4AD2:  ADDWF  xF7,W
4AD4:  MOVWF  01
4AD6:  MOVLW  00
4AD8:  ADDWFC xF8,W
4ADA:  MOVWF  03
4ADC:  MOVLW  05
4ADE:  MOVLB  8
4AE0:  ADDWF  xF7,W
4AE2:  MOVWF  FE9
4AE4:  MOVLW  00
4AE6:  ADDWFC xF8,W
4AE8:  MOVWF  FEA
4AEA:  MOVFF  FEF,904
4AEE:  MOVLB  9
4AF0:  MOVFF  03,FEA
4AF4:  MOVFF  01,FE9
4AF8:  MOVFF  904,FEF
....................       state[5] = state[1]; 
4AFC:  MOVLW  05
4AFE:  MOVLB  8
4B00:  ADDWF  xF7,W
4B02:  MOVWF  01
4B04:  MOVLW  00
4B06:  ADDWFC xF8,W
4B08:  MOVWF  03
4B0A:  MOVLW  01
4B0C:  MOVLB  8
4B0E:  ADDWF  xF7,W
4B10:  MOVWF  FE9
4B12:  MOVLW  00
4B14:  ADDWFC xF8,W
4B16:  MOVWF  FEA
4B18:  MOVFF  FEF,904
4B1C:  MOVLB  9
4B1E:  MOVFF  03,FEA
4B22:  MOVFF  01,FE9
4B26:  MOVFF  904,FEF
....................       state[1] = buf1; 
4B2A:  MOVLW  01
4B2C:  MOVLB  8
4B2E:  ADDWF  xF7,W
4B30:  MOVWF  FE9
4B32:  MOVLW  00
4B34:  ADDWFC xF8,W
4B36:  MOVWF  FEA
4B38:  MOVFF  8FC,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
4B3C:  MOVLW  0A
4B3E:  ADDWF  xF7,W
4B40:  MOVWF  FE9
4B42:  MOVLW  00
4B44:  ADDWFC xF8,W
4B46:  MOVWF  FEA
4B48:  MOVFF  FEF,8FC
....................       buf2 = state[14]; 
4B4C:  MOVLW  0E
4B4E:  ADDWF  xF7,W
4B50:  MOVWF  FE9
4B52:  MOVLW  00
4B54:  ADDWFC xF8,W
4B56:  MOVWF  FEA
4B58:  MOVFF  FEF,8FD
....................       state[10] = state[2]; 
4B5C:  MOVLW  0A
4B5E:  ADDWF  xF7,W
4B60:  MOVWF  01
4B62:  MOVLW  00
4B64:  ADDWFC xF8,W
4B66:  MOVWF  03
4B68:  MOVLW  02
4B6A:  MOVLB  8
4B6C:  ADDWF  xF7,W
4B6E:  MOVWF  FE9
4B70:  MOVLW  00
4B72:  ADDWFC xF8,W
4B74:  MOVWF  FEA
4B76:  MOVFF  FEF,904
4B7A:  MOVLB  9
4B7C:  MOVFF  03,FEA
4B80:  MOVFF  01,FE9
4B84:  MOVFF  904,FEF
....................       state[14] = state[6]; 
4B88:  MOVLW  0E
4B8A:  MOVLB  8
4B8C:  ADDWF  xF7,W
4B8E:  MOVWF  01
4B90:  MOVLW  00
4B92:  ADDWFC xF8,W
4B94:  MOVWF  03
4B96:  MOVLW  06
4B98:  MOVLB  8
4B9A:  ADDWF  xF7,W
4B9C:  MOVWF  FE9
4B9E:  MOVLW  00
4BA0:  ADDWFC xF8,W
4BA2:  MOVWF  FEA
4BA4:  MOVFF  FEF,904
4BA8:  MOVLB  9
4BAA:  MOVFF  03,FEA
4BAE:  MOVFF  01,FE9
4BB2:  MOVFF  904,FEF
....................       state[2] = buf1; 
4BB6:  MOVLW  02
4BB8:  MOVLB  8
4BBA:  ADDWF  xF7,W
4BBC:  MOVWF  FE9
4BBE:  MOVLW  00
4BC0:  ADDWFC xF8,W
4BC2:  MOVWF  FEA
4BC4:  MOVFF  8FC,FEF
....................       state[6] = buf2; 
4BC8:  MOVLW  06
4BCA:  ADDWF  xF7,W
4BCC:  MOVWF  FE9
4BCE:  MOVLW  00
4BD0:  ADDWFC xF8,W
4BD2:  MOVWF  FEA
4BD4:  MOVFF  8FD,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
4BD8:  MOVLW  03
4BDA:  ADDWF  xF7,W
4BDC:  MOVWF  FE9
4BDE:  MOVLW  00
4BE0:  ADDWFC xF8,W
4BE2:  MOVWF  FEA
4BE4:  MOVFF  FEF,8FC
....................       state[3] = state[7]; 
4BE8:  MOVLW  03
4BEA:  ADDWF  xF7,W
4BEC:  MOVWF  01
4BEE:  MOVLW  00
4BF0:  ADDWFC xF8,W
4BF2:  MOVWF  03
4BF4:  MOVLW  07
4BF6:  MOVLB  8
4BF8:  ADDWF  xF7,W
4BFA:  MOVWF  FE9
4BFC:  MOVLW  00
4BFE:  ADDWFC xF8,W
4C00:  MOVWF  FEA
4C02:  MOVFF  FEF,904
4C06:  MOVLB  9
4C08:  MOVFF  03,FEA
4C0C:  MOVFF  01,FE9
4C10:  MOVFF  904,FEF
....................       state[7] = state[11]; 
4C14:  MOVLW  07
4C16:  MOVLB  8
4C18:  ADDWF  xF7,W
4C1A:  MOVWF  01
4C1C:  MOVLW  00
4C1E:  ADDWFC xF8,W
4C20:  MOVWF  03
4C22:  MOVLW  0B
4C24:  MOVLB  8
4C26:  ADDWF  xF7,W
4C28:  MOVWF  FE9
4C2A:  MOVLW  00
4C2C:  ADDWFC xF8,W
4C2E:  MOVWF  FEA
4C30:  MOVFF  FEF,904
4C34:  MOVLB  9
4C36:  MOVFF  03,FEA
4C3A:  MOVFF  01,FE9
4C3E:  MOVFF  904,FEF
....................       state[11] = state[15]; 
4C42:  MOVLW  0B
4C44:  MOVLB  8
4C46:  ADDWF  xF7,W
4C48:  MOVWF  01
4C4A:  MOVLW  00
4C4C:  ADDWFC xF8,W
4C4E:  MOVWF  03
4C50:  MOVLW  0F
4C52:  MOVLB  8
4C54:  ADDWF  xF7,W
4C56:  MOVWF  FE9
4C58:  MOVLW  00
4C5A:  ADDWFC xF8,W
4C5C:  MOVWF  FEA
4C5E:  MOVFF  FEF,904
4C62:  MOVLB  9
4C64:  MOVFF  03,FEA
4C68:  MOVFF  01,FE9
4C6C:  MOVFF  904,FEF
....................       state[15] = buf1;          
4C70:  MOVLW  0F
4C72:  MOVLB  8
4C74:  ADDWF  xF7,W
4C76:  MOVWF  FE9
4C78:  MOVLW  00
4C7A:  ADDWFC xF8,W
4C7C:  MOVWF  FEA
4C7E:  MOVFF  8FC,FEF
....................             
....................       for (i = 0; i <16; i++){ 
4C82:  MOVLB  9
4C84:  CLRF   x01
4C86:  MOVF   x01,W
4C88:  SUBLW  0F
4C8A:  BNC   4CE6
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
4C8C:  CLRF   03
4C8E:  MOVF   x01,W
4C90:  MOVLB  8
4C92:  ADDWF  xF7,W
4C94:  MOVWF  01
4C96:  MOVF   xF8,W
4C98:  ADDWFC 03,F
4C9A:  MOVFF  01,902
4C9E:  MOVLB  9
4CA0:  MOVFF  03,903
4CA4:  CLRF   03
4CA6:  MOVF   x01,W
4CA8:  MOVLB  8
4CAA:  ADDWF  xF7,W
4CAC:  MOVWF  FE9
4CAE:  MOVF   xF8,W
4CB0:  ADDWFC 03,W
4CB2:  MOVWF  FEA
4CB4:  CLRF   03
4CB6:  MOVF   FEF,W
4CB8:  MOVLB  0
4CBA:  CALL   01E0
4CBE:  MOVLB  9
4CC0:  MOVWF  x04
4CC2:  CLRF   03
4CC4:  MOVF   x01,W
4CC6:  MOVLB  8
4CC8:  ADDWF  xF9,W
4CCA:  MOVWF  FE9
4CCC:  MOVF   xFA,W
4CCE:  ADDWFC 03,W
4CD0:  MOVWF  FEA
4CD2:  MOVF   FEF,W
4CD4:  MOVLB  9
4CD6:  XORWF  x04,W
4CD8:  MOVFF  903,FEA
4CDC:  MOVFF  902,FE9
4CE0:  MOVWF  FEF
....................       }  
4CE2:  INCF   x01,F
4CE4:  BRA    4C86
....................     }  
....................     else  
4CE6:  BRA    4E8C
4CE8:  MOVLB  8
....................     { 
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
4CEA:  MOVFF  8F9,01
4CEE:  MOVFF  8FA,03
4CF2:  MOVFF  8F9,902
4CF6:  MOVFF  8FA,903
4CFA:  MOVLW  0D
4CFC:  MOVLB  8
4CFE:  ADDWF  xF9,W
4D00:  MOVWF  FE9
4D02:  MOVLW  00
4D04:  ADDWFC xFA,W
4D06:  MOVWF  FEA
4D08:  CLRF   03
4D0A:  MOVF   FEF,W
4D0C:  MOVLB  0
4D0E:  CALL   00D0
4D12:  MOVLB  9
4D14:  MOVWF  x04
4D16:  MOVLB  8
4D18:  MOVFF  8F9,FE9
4D1C:  MOVFF  8FA,FEA
4D20:  MOVF   FEF,W
4D22:  MOVLB  9
4D24:  XORWF  x04,F
4D26:  CLRF   03
4D28:  MOVF   x00,W
4D2A:  MOVLB  0
4D2C:  CALL   02F0
4D30:  MOVWF  01
4D32:  MOVLB  9
4D34:  MOVF   x04,W
4D36:  XORWF  01,W
4D38:  MOVFF  903,FEA
4D3C:  MOVFF  902,FE9
4D40:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
4D42:  MOVLW  01
4D44:  MOVLB  8
4D46:  ADDWF  xF9,W
4D48:  MOVWF  01
4D4A:  MOVLW  00
4D4C:  ADDWFC xFA,W
4D4E:  MOVWF  03
4D50:  MOVFF  01,902
4D54:  MOVLB  9
4D56:  MOVWF  x03
4D58:  MOVLW  0E
4D5A:  MOVLB  8
4D5C:  ADDWF  xF9,W
4D5E:  MOVWF  FE9
4D60:  MOVLW  00
4D62:  ADDWFC xFA,W
4D64:  MOVWF  FEA
4D66:  CLRF   03
4D68:  MOVF   FEF,W
4D6A:  MOVLB  0
4D6C:  CALL   00D0
4D70:  MOVLB  9
4D72:  MOVWF  x04
4D74:  MOVLW  01
4D76:  MOVLB  8
4D78:  ADDWF  xF9,W
4D7A:  MOVWF  FE9
4D7C:  MOVLW  00
4D7E:  ADDWFC xFA,W
4D80:  MOVWF  FEA
4D82:  MOVF   FEF,W
4D84:  MOVLB  9
4D86:  XORWF  x04,W
4D88:  MOVFF  903,FEA
4D8C:  MOVFF  902,FE9
4D90:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
4D92:  MOVLW  02
4D94:  MOVLB  8
4D96:  ADDWF  xF9,W
4D98:  MOVWF  01
4D9A:  MOVLW  00
4D9C:  ADDWFC xFA,W
4D9E:  MOVWF  03
4DA0:  MOVFF  01,902
4DA4:  MOVLB  9
4DA6:  MOVWF  x03
4DA8:  MOVLW  0F
4DAA:  MOVLB  8
4DAC:  ADDWF  xF9,W
4DAE:  MOVWF  FE9
4DB0:  MOVLW  00
4DB2:  ADDWFC xFA,W
4DB4:  MOVWF  FEA
4DB6:  CLRF   03
4DB8:  MOVF   FEF,W
4DBA:  MOVLB  0
4DBC:  CALL   00D0
4DC0:  MOVLB  9
4DC2:  MOVWF  x04
4DC4:  MOVLW  02
4DC6:  MOVLB  8
4DC8:  ADDWF  xF9,W
4DCA:  MOVWF  FE9
4DCC:  MOVLW  00
4DCE:  ADDWFC xFA,W
4DD0:  MOVWF  FEA
4DD2:  MOVF   FEF,W
4DD4:  MOVLB  9
4DD6:  XORWF  x04,W
4DD8:  MOVFF  903,FEA
4DDC:  MOVFF  902,FE9
4DE0:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
4DE2:  MOVLW  03
4DE4:  MOVLB  8
4DE6:  ADDWF  xF9,W
4DE8:  MOVWF  01
4DEA:  MOVLW  00
4DEC:  ADDWFC xFA,W
4DEE:  MOVWF  03
4DF0:  MOVFF  01,902
4DF4:  MOVLB  9
4DF6:  MOVWF  x03
4DF8:  MOVLW  0C
4DFA:  MOVLB  8
4DFC:  ADDWF  xF9,W
4DFE:  MOVWF  FE9
4E00:  MOVLW  00
4E02:  ADDWFC xFA,W
4E04:  MOVWF  FEA
4E06:  CLRF   03
4E08:  MOVF   FEF,W
4E0A:  MOVLB  0
4E0C:  CALL   00D0
4E10:  MOVLB  9
4E12:  MOVWF  x04
4E14:  MOVLW  03
4E16:  MOVLB  8
4E18:  ADDWF  xF9,W
4E1A:  MOVWF  FE9
4E1C:  MOVLW  00
4E1E:  ADDWFC xFA,W
4E20:  MOVWF  FEA
4E22:  MOVF   FEF,W
4E24:  MOVLB  9
4E26:  XORWF  x04,W
4E28:  MOVFF  903,FEA
4E2C:  MOVFF  902,FE9
4E30:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4E32:  MOVLW  04
4E34:  MOVWF  x01
4E36:  MOVF   x01,W
4E38:  SUBLW  0F
4E3A:  BNC   4E8C
....................         key[i] = key[i] ^ key[i-4]; 
4E3C:  CLRF   03
4E3E:  MOVF   x01,W
4E40:  MOVLB  8
4E42:  ADDWF  xF9,W
4E44:  MOVWF  01
4E46:  MOVF   xFA,W
4E48:  ADDWFC 03,F
4E4A:  MOVLB  9
4E4C:  MOVFF  03,903
4E50:  CLRF   03
4E52:  MOVF   x01,W
4E54:  MOVLB  8
4E56:  ADDWF  xF9,W
4E58:  MOVWF  FE9
4E5A:  MOVF   xFA,W
4E5C:  ADDWFC 03,W
4E5E:  MOVWF  FEA
4E60:  MOVFF  FEF,904
4E64:  MOVLW  04
4E66:  MOVLB  9
4E68:  SUBWF  x01,W
4E6A:  CLRF   03
4E6C:  MOVLB  8
4E6E:  ADDWF  xF9,W
4E70:  MOVWF  FE9
4E72:  MOVF   xFA,W
4E74:  ADDWFC 03,W
4E76:  MOVWF  FEA
4E78:  MOVF   FEF,W
4E7A:  MOVLB  9
4E7C:  XORWF  x04,W
4E7E:  MOVFF  903,FEA
4E82:  MOVFF  01,FE9
4E86:  MOVWF  FEF
....................       } 
4E88:  INCF   x01,F
4E8A:  BRA    4E36
....................     } 
....................   } 
4E8C:  INCF   x00,F
4E8E:  GOTO   430E
....................   if (dir == 0)  
4E92:  MOVLB  8
4E94:  MOVF   xFB,F
4E96:  BNZ   4EF2
....................   { 
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
4E98:  MOVLB  9
4E9A:  CLRF   x01
4E9C:  MOVF   x01,W
4E9E:  SUBLW  0F
4EA0:  BNC   4EF0
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
4EA2:  CLRF   03
4EA4:  MOVF   x01,W
4EA6:  MOVLB  8
4EA8:  ADDWF  xF7,W
4EAA:  MOVWF  01
4EAC:  MOVF   xF8,W
4EAE:  ADDWFC 03,F
4EB0:  MOVLB  9
4EB2:  MOVFF  03,903
4EB6:  CLRF   03
4EB8:  MOVF   x01,W
4EBA:  MOVLB  8
4EBC:  ADDWF  xF7,W
4EBE:  MOVWF  FE9
4EC0:  MOVF   xF8,W
4EC2:  ADDWFC 03,W
4EC4:  MOVWF  FEA
4EC6:  MOVFF  FEF,904
4ECA:  CLRF   03
4ECC:  MOVLB  9
4ECE:  MOVF   x01,W
4ED0:  MOVLB  8
4ED2:  ADDWF  xF9,W
4ED4:  MOVWF  FE9
4ED6:  MOVF   xFA,W
4ED8:  ADDWFC 03,W
4EDA:  MOVWF  FEA
4EDC:  MOVF   FEF,W
4EDE:  MOVLB  9
4EE0:  XORWF  x04,W
4EE2:  MOVFF  903,FEA
4EE6:  MOVFF  01,FE9
4EEA:  MOVWF  FEF
....................     } // enf for 
4EEC:  INCF   x01,F
4EEE:  BRA    4E9C
4EF0:  MOVLB  8
....................   } // end if (!dir) 
.................... } // end function 
4EF2:  MOVLB  0
4EF4:  RETURN 0
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                  
....................  
.................... #define     wideofkeystore      16 
.................... #define     key_numbyte         wideofkeystore-4 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 kp_st=0; 
.................... int8 type_KB=0; 
....................  
.................... int8 key_data[wideofkeystore]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1F7C:  MOVLB  1
1F7E:  INCF   x5B,F
1F80:  MOVF   x5B,W
1F82:  SUBLW  01
1F84:  BTFSC  FD8.0
1F86:  BRA    212A
....................        switch (col) { 
1F88:  MOVF   x5E,W
1F8A:  ADDLW  FB
1F8C:  BC    2010
1F8E:  ADDLW  05
1F90:  MOVLB  0
1F92:  GOTO   2134
....................          case 0   :  
....................                     output_low(COL0); 
1F96:  BCF    F92.5
1F98:  BCF    F89.5
....................                     output_high(COL1); 
1F9A:  BCF    F92.3
1F9C:  BSF    F89.3
....................                     output_high(COL2); 
1F9E:  BCF    F92.2
1FA0:  BSF    F89.2
....................                     output_high(COL3); 
1FA2:  BCF    F92.1
1FA4:  BSF    F89.1
....................                     output_high(COL4); 
1FA6:  BCF    F92.0
1FA8:  BSF    F89.0
....................                     break; 
1FAA:  MOVLB  1
1FAC:  BRA    2010
....................          case 1   :  
....................                     output_low(COL1); 
1FAE:  BCF    F92.3
1FB0:  BCF    F89.3
....................                     output_high(COL0); 
1FB2:  BCF    F92.5
1FB4:  BSF    F89.5
....................                     output_high(COL2); 
1FB6:  BCF    F92.2
1FB8:  BSF    F89.2
....................                     output_high(COL3); 
1FBA:  BCF    F92.1
1FBC:  BSF    F89.1
....................                     output_high(COL4); 
1FBE:  BCF    F92.0
1FC0:  BSF    F89.0
....................                     break; 
1FC2:  MOVLB  1
1FC4:  BRA    2010
....................          case 2   :  
....................                     output_low(COL2); 
1FC6:  BCF    F92.2
1FC8:  BCF    F89.2
....................                     output_high(COL1); 
1FCA:  BCF    F92.3
1FCC:  BSF    F89.3
....................                     output_high(COL0); 
1FCE:  BCF    F92.5
1FD0:  BSF    F89.5
....................                     output_high(COL3); 
1FD2:  BCF    F92.1
1FD4:  BSF    F89.1
....................                     output_high(COL4); 
1FD6:  BCF    F92.0
1FD8:  BSF    F89.0
....................                     break; 
1FDA:  MOVLB  1
1FDC:  BRA    2010
....................          case 3   :  
....................                     output_low(COL3); 
1FDE:  BCF    F92.1
1FE0:  BCF    F89.1
....................                     output_high(COL1); 
1FE2:  BCF    F92.3
1FE4:  BSF    F89.3
....................                     output_high(COL2); 
1FE6:  BCF    F92.2
1FE8:  BSF    F89.2
....................                     output_high(COL0); 
1FEA:  BCF    F92.5
1FEC:  BSF    F89.5
....................                     output_high(COL4); 
1FEE:  BCF    F92.0
1FF0:  BSF    F89.0
....................                     break; 
1FF2:  MOVLB  1
1FF4:  BRA    2010
....................          case 4   :  
....................                     output_low(COL4); 
1FF6:  BCF    F92.0
1FF8:  BCF    F89.0
....................                     output_high(COL1); 
1FFA:  BCF    F92.3
1FFC:  BSF    F89.3
....................                     output_high(COL2); 
1FFE:  BCF    F92.2
2000:  BSF    F89.2
....................                     output_high(COL3); 
2002:  BCF    F92.1
2004:  BSF    F89.1
....................                     output_high(COL0); 
2006:  BCF    F92.5
2008:  BSF    F89.5
....................                     break; 
200A:  MOVLB  1
200C:  BRA    2010
200E:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2010:  BTFSS  x5C.0
2012:  BRA    2090
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2014:  BSF    F93.4
2016:  MOVLW  00
2018:  BTFSC  F81.4
201A:  MOVLW  01
201C:  MOVLB  8
201E:  MOVWF  x52
2020:  BSF    F93.5
2022:  MOVLW  00
2024:  BTFSC  F81.5
2026:  MOVLW  01
2028:  ANDWF  x52,F
202A:  BSF    F93.6
202C:  MOVLW  00
202E:  BTFSC  F81.6
2030:  MOVLW  01
2032:  ANDWF  x52,F
2034:  BSF    F93.7
2036:  MOVLW  00
2038:  BTFSC  F81.7
203A:  MOVLW  01
203C:  ANDWF  x52,W
203E:  BZ    208C
....................          { 
....................             kchar=last_key; 
2040:  MOVFF  15D,850
....................             if(keydebug_en==0) 
2044:  MOVLB  1
2046:  MOVF   x44,F
2048:  BNZ   207A
....................             { 
....................                 //count_timer0=0; 
....................                 charac_timeout=0; 
204A:  CLRF   x00
204C:  MOVLB  0
204E:  CLRF   xFF
....................                 if(key_count_ms<wideofkeystore) 
2050:  MOVLB  1
2052:  MOVF   x47,W
2054:  SUBLW  0F
2056:  BNC   2078
....................                 { 
....................                     key_data[key_count_ms++]=kchar; 
2058:  MOVF   x47,W
205A:  INCF   x47,F
205C:  CLRF   03
205E:  ADDLW  4A
2060:  MOVWF  FE9
2062:  MOVLW  01
2064:  ADDWFC 03,W
2066:  MOVWF  FEA
2068:  MOVFF  850,FEF
....................                     fputc(kchar,COM2); 
206C:  MOVFF  850,90C
2070:  MOVLB  0
2072:  CALL   1604
2076:  MOVLB  1
....................                 } 
....................             } 
....................                else fputc(kchar,COM2); 
2078:  BRA    2086
207A:  MOVFF  850,90C
207E:  MOVLB  0
2080:  CALL   1604
2084:  MOVLB  1
....................            kbd_down=FALSE; 
2086:  BCF    x5C.0
....................            last_key=0; 
2088:  CLRF   x5D
208A:  MOVLB  8
....................          } 
....................        } else 
208C:  BRA    2126
208E:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
2090:  BSF    F93.4
2092:  MOVLW  00
2094:  BTFSC  F81.4
2096:  MOVLW  01
2098:  MOVLB  8
209A:  MOVWF  x52
209C:  BSF    F93.5
209E:  MOVLW  00
20A0:  BTFSC  F81.5
20A2:  MOVLW  01
20A4:  ANDWF  x52,F
20A6:  BSF    F93.6
20A8:  MOVLW  00
20AA:  BTFSC  F81.6
20AC:  MOVLW  01
20AE:  ANDWF  x52,F
20B0:  BSF    F93.7
20B2:  MOVLW  00
20B4:  BTFSC  F81.7
20B6:  MOVLW  01
20B8:  ANDWF  x52,W
20BA:  BNZ   211A
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
20BC:  BSF    F93.4
20BE:  BTFSC  F81.4
20C0:  BRA    20C6
....................                   row=0; 
20C2:  CLRF   x51
....................                 else if(input(ROW1)==0) 
20C4:  BRA    20E8
20C6:  BSF    F93.5
20C8:  BTFSC  F81.5
20CA:  BRA    20D2
....................                   row=1; 
20CC:  MOVLW  01
20CE:  MOVWF  x51
....................                 else if(input(ROW2)==0) 
20D0:  BRA    20E8
20D2:  BSF    F93.6
20D4:  BTFSC  F81.6
20D6:  BRA    20DE
....................                   row=2; 
20D8:  MOVLW  02
20DA:  MOVWF  x51
....................                 else if(input(ROW3)==0) 
20DC:  BRA    20E8
20DE:  BSF    F93.7
20E0:  BTFSC  F81.7
20E2:  BRA    20E8
....................                   row=3; 
20E4:  MOVLW  03
20E6:  MOVWF  x51
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
20E8:  MOVF   x51,W
20EA:  MULLW  05
20EC:  MOVF   FF3,W
20EE:  CLRF   x53
20F0:  MOVWF  x52
20F2:  CLRF   03
20F4:  MOVLB  1
20F6:  MOVF   x5E,W
20F8:  MOVLB  8
20FA:  ADDWF  x52,W
20FC:  MOVWF  01
20FE:  MOVF   x53,W
2100:  ADDWFC 03,F
2102:  MOVF   01,W
2104:  MOVLB  0
2106:  CALL   030A
210A:  MOVFF  FE8,15D
....................                 kbd_down = TRUE; 
210E:  MOVLB  1
2110:  BSF    x5C.0
....................                 set_tris_a(0xff); 
2112:  MOVLW  FF
2114:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2116:  BRA    2126
2118:  MOVLB  8
....................                { 
....................                   ++col; 
211A:  MOVLB  1
211C:  INCF   x5E,F
....................                   if(col==5) col=0; 
211E:  MOVF   x5E,W
2120:  SUBLW  05
2122:  BTFSC  FD8.2
2124:  CLRF   x5E
....................                } 
....................          } 
....................       kbd_call_count=0; 
2126:  MOVLB  1
2128:  CLRF   x5B
....................    } 
....................   return(kchar); 
212A:  MOVLB  8
212C:  MOVFF  850,01
.................... } 
2130:  MOVLB  0
2132:  RETURN 0
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2158:  MOVLW  E0
215A:  MOVLB  F
215C:  MOVWF  x48
215E:  BCF    FC2.6
2160:  BCF    FC2.7
2162:  MOVF   x49,W
2164:  ANDLW  E0
2166:  IORLW  17
2168:  MOVWF  x49
....................    switch(col) 
....................    { 
216A:  MOVLB  8
216C:  MOVF   x6D,W
216E:  ADDLW  FA
2170:  BC    223C
2172:  ADDLW  06
2174:  MOVLB  0
2176:  GOTO   2240
....................       case 0: 
....................         set_adc_channel(4); 
217A:  MOVLW  10
217C:  MOVWF  01
217E:  MOVF   FC2,W
2180:  ANDLW  C3
2182:  IORWF  01,W
2184:  MOVWF  FC2
....................         adc=read_adc(); 
2186:  BSF    FC2.1
2188:  BTFSC  FC2.1
218A:  BRA    2188
218C:  MOVFF  FC4,86E
....................         return adc; 
2190:  MOVLB  8
2192:  MOVFF  86E,01
2196:  BRA    223C
....................       break; 
2198:  BRA    223C
....................       case 1: 
....................         set_adc_channel(3); 
219A:  MOVLW  0C
219C:  MOVWF  01
219E:  MOVF   FC2,W
21A0:  ANDLW  C3
21A2:  IORWF  01,W
21A4:  MOVWF  FC2
....................         adc=read_adc(); 
21A6:  BSF    FC2.1
21A8:  BTFSC  FC2.1
21AA:  BRA    21A8
21AC:  MOVFF  FC4,86E
....................         return adc; 
21B0:  MOVLB  8
21B2:  MOVFF  86E,01
21B6:  BRA    223C
....................       break; 
21B8:  BRA    223C
....................       case 2: 
....................         set_adc_channel(2); 
21BA:  MOVLW  08
21BC:  MOVWF  01
21BE:  MOVF   FC2,W
21C0:  ANDLW  C3
21C2:  IORWF  01,W
21C4:  MOVWF  FC2
....................         adc=read_adc(); 
21C6:  BSF    FC2.1
21C8:  BTFSC  FC2.1
21CA:  BRA    21C8
21CC:  MOVFF  FC4,86E
....................         return adc; 
21D0:  MOVLB  8
21D2:  MOVFF  86E,01
21D6:  BRA    223C
....................       break; 
21D8:  BRA    223C
....................       case 3: 
....................         set_adc_channel(1); 
21DA:  MOVLW  04
21DC:  MOVWF  01
21DE:  MOVF   FC2,W
21E0:  ANDLW  C3
21E2:  IORWF  01,W
21E4:  MOVWF  FC2
....................         adc=read_adc(); 
21E6:  BSF    FC2.1
21E8:  BTFSC  FC2.1
21EA:  BRA    21E8
21EC:  MOVFF  FC4,86E
....................         return adc; 
21F0:  MOVLB  8
21F2:  MOVFF  86E,01
21F6:  BRA    223C
....................       break; 
21F8:  BRA    223C
....................       case 4: 
....................         set_adc_channel(0); 
21FA:  MOVLW  00
21FC:  MOVWF  01
21FE:  MOVF   FC2,W
2200:  ANDLW  C3
2202:  IORWF  01,W
2204:  MOVWF  FC2
....................         adc=read_adc(); 
2206:  BSF    FC2.1
2208:  BTFSC  FC2.1
220A:  BRA    2208
220C:  MOVFF  FC4,86E
....................         return adc; 
2210:  MOVLB  8
2212:  MOVFF  86E,01
2216:  BRA    223C
....................       break;      
2218:  BRA    223C
....................       case 5: 
....................         set_adc_channel(11); 
221A:  MOVLW  2C
221C:  MOVWF  01
221E:  MOVF   FC2,W
2220:  ANDLW  C3
2222:  IORWF  01,W
2224:  MOVWF  FC2
....................         adc=read_adc(); 
2226:  BSF    FC2.1
2228:  BTFSC  FC2.1
222A:  BRA    2228
222C:  MOVFF  FC4,86E
....................         return adc; 
2230:  MOVLB  8
2232:  MOVFF  86E,01
2236:  BRA    223C
....................       break;      
2238:  BRA    223C
223A:  MOVLB  8
....................    } 
.................... } 
223C:  MOVLB  0
223E:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
23C0:  MOVLB  8
23C2:  CLRF   x58
23C4:  CLRF   x57
23C6:  CLRF   x56
23C8:  CLRF   x55
23CA:  CLRF   x5C
23CC:  CLRF   x5B
23CE:  CLRF   x5A
23D0:  CLRF   x59
23D2:  CLRF   x60
23D4:  CLRF   x5F
23D6:  CLRF   x5E
23D8:  CLRF   x5D
23DA:  CLRF   x64
23DC:  CLRF   x63
23DE:  CLRF   x62
23E0:  CLRF   x61
23E2:  CLRF   x68
23E4:  CLRF   x67
23E6:  CLRF   x66
23E8:  CLRF   x65
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
23EA:  CLRF   x54
23EC:  CLRF   x53
23EE:  MOVF   x54,W
23F0:  SUBLW  01
23F2:  BNC   2470
23F4:  BNZ   23FC
23F6:  MOVF   x53,W
23F8:  SUBLW  F3
23FA:  BNC   2470
....................    { 
....................       col_0=read_col(0)+col_0; 
23FC:  CLRF   x6D
23FE:  MOVLB  0
2400:  RCALL  2158
2402:  MOVF   01,W
2404:  MOVLB  8
2406:  ADDWF  x55,F
2408:  MOVLW  00
240A:  ADDWFC x56,F
240C:  ADDWFC x57,F
240E:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2410:  MOVLW  01
2412:  MOVWF  x6D
2414:  MOVLB  0
2416:  RCALL  2158
2418:  MOVF   01,W
241A:  MOVLB  8
241C:  ADDWF  x59,F
241E:  MOVLW  00
2420:  ADDWFC x5A,F
2422:  ADDWFC x5B,F
2424:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
2426:  MOVLW  02
2428:  MOVWF  x6D
242A:  MOVLB  0
242C:  RCALL  2158
242E:  MOVF   01,W
2430:  MOVLB  8
2432:  ADDWF  x5D,F
2434:  MOVLW  00
2436:  ADDWFC x5E,F
2438:  ADDWFC x5F,F
243A:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
243C:  MOVLW  03
243E:  MOVWF  x6D
2440:  MOVLB  0
2442:  RCALL  2158
2444:  MOVF   01,W
2446:  MOVLB  8
2448:  ADDWF  x61,F
244A:  MOVLW  00
244C:  ADDWFC x62,F
244E:  ADDWFC x63,F
2450:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
2452:  MOVLW  04
2454:  MOVWF  x6D
2456:  MOVLB  0
2458:  RCALL  2158
245A:  MOVF   01,W
245C:  MOVLB  8
245E:  ADDWF  x65,F
2460:  MOVLW  00
2462:  ADDWFC x66,F
2464:  ADDWFC x67,F
2466:  ADDWFC x68,F
....................    } 
2468:  INCF   x53,F
246A:  BTFSC  FD8.2
246C:  INCF   x54,F
246E:  BRA    23EE
....................    col_0=col_0/500; 
2470:  BCF    FD8.1
2472:  MOVFF  858,90F
2476:  MOVFF  857,90E
247A:  MOVFF  856,90D
247E:  MOVFF  855,90C
2482:  MOVLB  9
2484:  CLRF   x13
2486:  CLRF   x12
2488:  MOVLW  01
248A:  MOVWF  x11
248C:  MOVLW  F4
248E:  MOVWF  x10
2490:  MOVLB  0
2492:  RCALL  2266
2494:  MOVFF  03,858
2498:  MOVFF  02,857
249C:  MOVFF  01,856
24A0:  MOVFF  00,855
....................    col_1=col_1/500; 
24A4:  BCF    FD8.1
24A6:  MOVFF  85C,90F
24AA:  MOVFF  85B,90E
24AE:  MOVFF  85A,90D
24B2:  MOVFF  859,90C
24B6:  MOVLB  9
24B8:  CLRF   x13
24BA:  CLRF   x12
24BC:  MOVLW  01
24BE:  MOVWF  x11
24C0:  MOVLW  F4
24C2:  MOVWF  x10
24C4:  MOVLB  0
24C6:  RCALL  2266
24C8:  MOVFF  03,85C
24CC:  MOVFF  02,85B
24D0:  MOVFF  01,85A
24D4:  MOVFF  00,859
....................    col_2=col_2/500; 
24D8:  BCF    FD8.1
24DA:  MOVFF  860,90F
24DE:  MOVFF  85F,90E
24E2:  MOVFF  85E,90D
24E6:  MOVFF  85D,90C
24EA:  MOVLB  9
24EC:  CLRF   x13
24EE:  CLRF   x12
24F0:  MOVLW  01
24F2:  MOVWF  x11
24F4:  MOVLW  F4
24F6:  MOVWF  x10
24F8:  MOVLB  0
24FA:  RCALL  2266
24FC:  MOVFF  03,860
2500:  MOVFF  02,85F
2504:  MOVFF  01,85E
2508:  MOVFF  00,85D
....................    col_3=col_3/500; 
250C:  BCF    FD8.1
250E:  MOVFF  864,90F
2512:  MOVFF  863,90E
2516:  MOVFF  862,90D
251A:  MOVFF  861,90C
251E:  MOVLB  9
2520:  CLRF   x13
2522:  CLRF   x12
2524:  MOVLW  01
2526:  MOVWF  x11
2528:  MOVLW  F4
252A:  MOVWF  x10
252C:  MOVLB  0
252E:  RCALL  2266
2530:  MOVFF  03,864
2534:  MOVFF  02,863
2538:  MOVFF  01,862
253C:  MOVFF  00,861
....................    col_4=col_4/500; 
2540:  BCF    FD8.1
2542:  MOVFF  868,90F
2546:  MOVFF  867,90E
254A:  MOVFF  866,90D
254E:  MOVFF  865,90C
2552:  MOVLB  9
2554:  CLRF   x13
2556:  CLRF   x12
2558:  MOVLW  01
255A:  MOVWF  x11
255C:  MOVLW  F4
255E:  MOVWF  x10
2560:  MOVLB  0
2562:  RCALL  2266
2564:  MOVFF  03,868
2568:  MOVFF  02,867
256C:  MOVFF  01,866
2570:  MOVFF  00,865
....................    if(keydebug_en) 
2574:  MOVLB  1
2576:  MOVF   x44,F
2578:  BTFSC  FD8.2
257A:  BRA    26F6
....................    { 
....................       fprintf(COM2,"\r\n");      
257C:  MOVLW  0D
257E:  MOVLB  9
2580:  MOVWF  x0C
2582:  MOVLB  0
2584:  CALL   1604
2588:  MOVLW  0A
258A:  MOVLB  9
258C:  MOVWF  x0C
258E:  MOVLB  0
2590:  CALL   1604
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2594:  MOVLW  BC
2596:  MOVWF  FF6
2598:  MOVLW  04
259A:  MOVWF  FF7
259C:  MOVLW  07
259E:  MOVLB  8
25A0:  MOVWF  xF7
25A2:  MOVLB  0
25A4:  CALL   164A
25A8:  MOVLW  41
25AA:  MOVWF  FE9
25AC:  MOVFF  858,8FA
25B0:  MOVFF  857,8F9
25B4:  MOVFF  856,8F8
25B8:  MOVFF  855,8F7
25BC:  RCALL  22FA
25BE:  MOVLW  0D
25C0:  MOVLB  9
25C2:  MOVWF  x0C
25C4:  MOVLB  0
25C6:  CALL   1604
25CA:  MOVLW  0A
25CC:  MOVLB  9
25CE:  MOVWF  x0C
25D0:  MOVLB  0
25D2:  CALL   1604
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
25D6:  MOVLW  CA
25D8:  MOVWF  FF6
25DA:  MOVLW  04
25DC:  MOVWF  FF7
25DE:  MOVLW  07
25E0:  MOVLB  8
25E2:  MOVWF  xF7
25E4:  MOVLB  0
25E6:  CALL   164A
25EA:  MOVLW  41
25EC:  MOVWF  FE9
25EE:  MOVFF  85C,8FA
25F2:  MOVFF  85B,8F9
25F6:  MOVFF  85A,8F8
25FA:  MOVFF  859,8F7
25FE:  RCALL  22FA
2600:  MOVLW  0D
2602:  MOVLB  9
2604:  MOVWF  x0C
2606:  MOVLB  0
2608:  CALL   1604
260C:  MOVLW  0A
260E:  MOVLB  9
2610:  MOVWF  x0C
2612:  MOVLB  0
2614:  CALL   1604
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2618:  MOVLW  D8
261A:  MOVWF  FF6
261C:  MOVLW  04
261E:  MOVWF  FF7
2620:  MOVLW  07
2622:  MOVLB  8
2624:  MOVWF  xF7
2626:  MOVLB  0
2628:  CALL   164A
262C:  MOVLW  41
262E:  MOVWF  FE9
2630:  MOVFF  860,8FA
2634:  MOVFF  85F,8F9
2638:  MOVFF  85E,8F8
263C:  MOVFF  85D,8F7
2640:  RCALL  22FA
2642:  MOVLW  0D
2644:  MOVLB  9
2646:  MOVWF  x0C
2648:  MOVLB  0
264A:  CALL   1604
264E:  MOVLW  0A
2650:  MOVLB  9
2652:  MOVWF  x0C
2654:  MOVLB  0
2656:  CALL   1604
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
265A:  MOVLW  E6
265C:  MOVWF  FF6
265E:  MOVLW  04
2660:  MOVWF  FF7
2662:  MOVLW  07
2664:  MOVLB  8
2666:  MOVWF  xF7
2668:  MOVLB  0
266A:  CALL   164A
266E:  MOVLW  41
2670:  MOVWF  FE9
2672:  MOVFF  864,8FA
2676:  MOVFF  863,8F9
267A:  MOVFF  862,8F8
267E:  MOVFF  861,8F7
2682:  RCALL  22FA
2684:  MOVLW  0D
2686:  MOVLB  9
2688:  MOVWF  x0C
268A:  MOVLB  0
268C:  CALL   1604
2690:  MOVLW  0A
2692:  MOVLB  9
2694:  MOVWF  x0C
2696:  MOVLB  0
2698:  CALL   1604
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
269C:  MOVLW  F4
269E:  MOVWF  FF6
26A0:  MOVLW  04
26A2:  MOVWF  FF7
26A4:  MOVLW  07
26A6:  MOVLB  8
26A8:  MOVWF  xF7
26AA:  MOVLB  0
26AC:  CALL   164A
26B0:  MOVLW  41
26B2:  MOVWF  FE9
26B4:  MOVFF  868,8FA
26B8:  MOVFF  867,8F9
26BC:  MOVFF  866,8F8
26C0:  MOVFF  865,8F7
26C4:  RCALL  22FA
26C6:  MOVLW  0D
26C8:  MOVLB  9
26CA:  MOVWF  x0C
26CC:  MOVLB  0
26CE:  CALL   1604
26D2:  MOVLW  0A
26D4:  MOVLB  9
26D6:  MOVWF  x0C
26D8:  MOVLB  0
26DA:  CALL   1604
....................       fprintf(COM2,"\r\n"); 
26DE:  MOVLW  0D
26E0:  MOVLB  9
26E2:  MOVWF  x0C
26E4:  MOVLB  0
26E6:  CALL   1604
26EA:  MOVLW  0A
26EC:  MOVLB  9
26EE:  MOVWF  x0C
26F0:  MOVLB  0
26F2:  CALL   1604
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
26F6:  MOVLB  8
26F8:  MOVF   x58,F
26FA:  BNZ   270A
26FC:  MOVF   x57,F
26FE:  BNZ   270A
2700:  MOVF   x56,F
2702:  BNZ   270A
2704:  MOVF   x55,W
2706:  SUBLW  05
2708:  BC    276A
270A:  MOVF   x58,F
270C:  BNZ   276A
270E:  MOVF   x57,F
2710:  BNZ   276A
2712:  MOVF   x56,F
2714:  BNZ   276A
2716:  MOVF   x55,W
2718:  SUBLW  3B
271A:  BNC   276A
271C:  MOVF   x5C,F
271E:  BNZ   272E
2720:  MOVF   x5B,F
2722:  BNZ   272E
2724:  MOVF   x5A,F
2726:  BNZ   272E
2728:  MOVF   x59,W
272A:  SUBLW  64
272C:  BC    276A
272E:  MOVF   x60,F
2730:  BNZ   2740
2732:  MOVF   x5F,F
2734:  BNZ   2740
2736:  MOVF   x5E,F
2738:  BNZ   2740
273A:  MOVF   x5D,W
273C:  SUBLW  64
273E:  BC    276A
2740:  MOVF   x64,F
2742:  BNZ   2752
2744:  MOVF   x63,F
2746:  BNZ   2752
2748:  MOVF   x62,F
274A:  BNZ   2752
274C:  MOVF   x61,W
274E:  SUBLW  64
2750:  BC    276A
2752:  MOVF   x68,F
2754:  BNZ   2764
2756:  MOVF   x67,F
2758:  BNZ   2764
275A:  MOVF   x66,F
275C:  BNZ   2764
275E:  MOVF   x65,W
2760:  SUBLW  64
2762:  BC    276A
2764:  MOVLW  00
2766:  MOVWF  01
2768:  BRA    29E8
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
276A:  MOVF   x5C,F
276C:  BNZ   277C
276E:  MOVF   x5B,F
2770:  BNZ   277C
2772:  MOVF   x5A,F
2774:  BNZ   277C
2776:  MOVF   x59,W
2778:  SUBLW  05
277A:  BC    27DC
277C:  MOVF   x5C,F
277E:  BNZ   27DC
2780:  MOVF   x5B,F
2782:  BNZ   27DC
2784:  MOVF   x5A,F
2786:  BNZ   27DC
2788:  MOVF   x59,W
278A:  SUBLW  3B
278C:  BNC   27DC
278E:  MOVF   x58,F
2790:  BNZ   27A0
2792:  MOVF   x57,F
2794:  BNZ   27A0
2796:  MOVF   x56,F
2798:  BNZ   27A0
279A:  MOVF   x55,W
279C:  SUBLW  64
279E:  BC    27DC
27A0:  MOVF   x60,F
27A2:  BNZ   27B2
27A4:  MOVF   x5F,F
27A6:  BNZ   27B2
27A8:  MOVF   x5E,F
27AA:  BNZ   27B2
27AC:  MOVF   x5D,W
27AE:  SUBLW  64
27B0:  BC    27DC
27B2:  MOVF   x64,F
27B4:  BNZ   27C4
27B6:  MOVF   x63,F
27B8:  BNZ   27C4
27BA:  MOVF   x62,F
27BC:  BNZ   27C4
27BE:  MOVF   x61,W
27C0:  SUBLW  64
27C2:  BC    27DC
27C4:  MOVF   x68,F
27C6:  BNZ   27D6
27C8:  MOVF   x67,F
27CA:  BNZ   27D6
27CC:  MOVF   x66,F
27CE:  BNZ   27D6
27D0:  MOVF   x65,W
27D2:  SUBLW  64
27D4:  BC    27DC
27D6:  MOVLW  01
27D8:  MOVWF  01
27DA:  BRA    29E8
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
27DC:  MOVF   x60,F
27DE:  BNZ   27EE
27E0:  MOVF   x5F,F
27E2:  BNZ   27EE
27E4:  MOVF   x5E,F
27E6:  BNZ   27EE
27E8:  MOVF   x5D,W
27EA:  SUBLW  05
27EC:  BC    284E
27EE:  MOVF   x60,F
27F0:  BNZ   284E
27F2:  MOVF   x5F,F
27F4:  BNZ   284E
27F6:  MOVF   x5E,F
27F8:  BNZ   284E
27FA:  MOVF   x5D,W
27FC:  SUBLW  3B
27FE:  BNC   284E
2800:  MOVF   x5C,F
2802:  BNZ   2812
2804:  MOVF   x5B,F
2806:  BNZ   2812
2808:  MOVF   x5A,F
280A:  BNZ   2812
280C:  MOVF   x59,W
280E:  SUBLW  64
2810:  BC    284E
2812:  MOVF   x58,F
2814:  BNZ   2824
2816:  MOVF   x57,F
2818:  BNZ   2824
281A:  MOVF   x56,F
281C:  BNZ   2824
281E:  MOVF   x55,W
2820:  SUBLW  64
2822:  BC    284E
2824:  MOVF   x64,F
2826:  BNZ   2836
2828:  MOVF   x63,F
282A:  BNZ   2836
282C:  MOVF   x62,F
282E:  BNZ   2836
2830:  MOVF   x61,W
2832:  SUBLW  64
2834:  BC    284E
2836:  MOVF   x68,F
2838:  BNZ   2848
283A:  MOVF   x67,F
283C:  BNZ   2848
283E:  MOVF   x66,F
2840:  BNZ   2848
2842:  MOVF   x65,W
2844:  SUBLW  64
2846:  BC    284E
2848:  MOVLW  02
284A:  MOVWF  01
284C:  BRA    29E8
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
284E:  MOVF   x64,F
2850:  BNZ   2860
2852:  MOVF   x63,F
2854:  BNZ   2860
2856:  MOVF   x62,F
2858:  BNZ   2860
285A:  MOVF   x61,W
285C:  SUBLW  05
285E:  BC    28C0
2860:  MOVF   x64,F
2862:  BNZ   28C0
2864:  MOVF   x63,F
2866:  BNZ   28C0
2868:  MOVF   x62,F
286A:  BNZ   28C0
286C:  MOVF   x61,W
286E:  SUBLW  3B
2870:  BNC   28C0
2872:  MOVF   x5C,F
2874:  BNZ   2884
2876:  MOVF   x5B,F
2878:  BNZ   2884
287A:  MOVF   x5A,F
287C:  BNZ   2884
287E:  MOVF   x59,W
2880:  SUBLW  64
2882:  BC    28C0
2884:  MOVF   x60,F
2886:  BNZ   2896
2888:  MOVF   x5F,F
288A:  BNZ   2896
288C:  MOVF   x5E,F
288E:  BNZ   2896
2890:  MOVF   x5D,W
2892:  SUBLW  64
2894:  BC    28C0
2896:  MOVF   x58,F
2898:  BNZ   28A8
289A:  MOVF   x57,F
289C:  BNZ   28A8
289E:  MOVF   x56,F
28A0:  BNZ   28A8
28A2:  MOVF   x55,W
28A4:  SUBLW  64
28A6:  BC    28C0
28A8:  MOVF   x68,F
28AA:  BNZ   28BA
28AC:  MOVF   x67,F
28AE:  BNZ   28BA
28B0:  MOVF   x66,F
28B2:  BNZ   28BA
28B4:  MOVF   x65,W
28B6:  SUBLW  64
28B8:  BC    28C0
28BA:  MOVLW  03
28BC:  MOVWF  01
28BE:  BRA    29E8
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
28C0:  MOVF   x68,F
28C2:  BNZ   28D2
28C4:  MOVF   x67,F
28C6:  BNZ   28D2
28C8:  MOVF   x66,F
28CA:  BNZ   28D2
28CC:  MOVF   x65,W
28CE:  SUBLW  05
28D0:  BC    2932
28D2:  MOVF   x68,F
28D4:  BNZ   2932
28D6:  MOVF   x67,F
28D8:  BNZ   2932
28DA:  MOVF   x66,F
28DC:  BNZ   2932
28DE:  MOVF   x65,W
28E0:  SUBLW  3B
28E2:  BNC   2932
28E4:  MOVF   x5C,F
28E6:  BNZ   28F6
28E8:  MOVF   x5B,F
28EA:  BNZ   28F6
28EC:  MOVF   x5A,F
28EE:  BNZ   28F6
28F0:  MOVF   x59,W
28F2:  SUBLW  64
28F4:  BC    2932
28F6:  MOVF   x60,F
28F8:  BNZ   2908
28FA:  MOVF   x5F,F
28FC:  BNZ   2908
28FE:  MOVF   x5E,F
2900:  BNZ   2908
2902:  MOVF   x5D,W
2904:  SUBLW  64
2906:  BC    2932
2908:  MOVF   x64,F
290A:  BNZ   291A
290C:  MOVF   x63,F
290E:  BNZ   291A
2910:  MOVF   x62,F
2912:  BNZ   291A
2914:  MOVF   x61,W
2916:  SUBLW  64
2918:  BC    2932
291A:  MOVF   x58,F
291C:  BNZ   292C
291E:  MOVF   x57,F
2920:  BNZ   292C
2922:  MOVF   x56,F
2924:  BNZ   292C
2926:  MOVF   x55,W
2928:  SUBLW  64
292A:  BC    2932
292C:  MOVLW  04
292E:  MOVWF  01
2930:  BRA    29E8
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2932:  MOVF   x68,F
2934:  BNZ   2946
2936:  MOVF   x67,F
2938:  BNZ   2946
293A:  MOVF   x66,F
293C:  BNZ   2946
293E:  MOVF   x65,W
2940:  SUBLW  C8
2942:  BTFSC  FD8.0
2944:  BRA    29E4
2946:  MOVF   x58,F
2948:  BTFSS  FD8.2
294A:  BRA    29E4
294C:  MOVF   x57,F
294E:  BTFSS  FD8.2
2950:  BRA    29E4
2952:  MOVF   x56,F
2954:  BTFSS  FD8.2
2956:  BRA    29E4
2958:  MOVF   x55,W
295A:  SUBLW  B3
295C:  BNC   29E4
295E:  MOVF   x58,F
2960:  BNZ   2970
2962:  MOVF   x57,F
2964:  BNZ   2970
2966:  MOVF   x56,F
2968:  BNZ   2970
296A:  MOVF   x55,W
296C:  SUBLW  64
296E:  BC    29E4
2970:  MOVF   x5C,F
2972:  BNZ   29E4
2974:  MOVF   x5B,F
2976:  BNZ   29E4
2978:  MOVF   x5A,F
297A:  BNZ   29E4
297C:  MOVF   x59,W
297E:  SUBLW  B3
2980:  BNC   29E4
2982:  MOVF   x5C,F
2984:  BNZ   2994
2986:  MOVF   x5B,F
2988:  BNZ   2994
298A:  MOVF   x5A,F
298C:  BNZ   2994
298E:  MOVF   x59,W
2990:  SUBLW  64
2992:  BC    29E4
2994:  MOVF   x60,F
2996:  BNZ   29E4
2998:  MOVF   x5F,F
299A:  BNZ   29E4
299C:  MOVF   x5E,F
299E:  BNZ   29E4
29A0:  MOVF   x5D,W
29A2:  SUBLW  B3
29A4:  BNC   29E4
29A6:  MOVF   x60,F
29A8:  BNZ   29B8
29AA:  MOVF   x5F,F
29AC:  BNZ   29B8
29AE:  MOVF   x5E,F
29B0:  BNZ   29B8
29B2:  MOVF   x5D,W
29B4:  SUBLW  64
29B6:  BC    29E4
29B8:  MOVF   x64,F
29BA:  BNZ   29E4
29BC:  MOVF   x63,F
29BE:  BNZ   29E4
29C0:  MOVF   x62,F
29C2:  BNZ   29E4
29C4:  MOVF   x61,W
29C6:  SUBLW  B3
29C8:  BNC   29E4
29CA:  MOVF   x64,F
29CC:  BNZ   29DC
29CE:  MOVF   x63,F
29D0:  BNZ   29DC
29D2:  MOVF   x62,F
29D4:  BNZ   29DC
29D6:  MOVF   x61,W
29D8:  SUBLW  64
29DA:  BC    29E4
29DC:  MOVLW  04
29DE:  MOVWF  01
29E0:  BRA    29E8
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
29E2:  BRA    29E8
29E4:  MOVLW  FF
29E6:  MOVWF  01
.................... } 
29E8:  MOVLB  0
29EA:  GOTO   3236 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
29EE:  MOVLB  8
29F0:  CLRF   x58
29F2:  CLRF   x57
29F4:  CLRF   x56
29F6:  CLRF   x55
29F8:  CLRF   x5C
29FA:  CLRF   x5B
29FC:  CLRF   x5A
29FE:  CLRF   x59
2A00:  CLRF   x60
2A02:  CLRF   x5F
2A04:  CLRF   x5E
2A06:  CLRF   x5D
2A08:  CLRF   x64
2A0A:  CLRF   x63
2A0C:  CLRF   x62
2A0E:  CLRF   x61
2A10:  CLRF   x68
2A12:  CLRF   x67
2A14:  CLRF   x66
2A16:  CLRF   x65
2A18:  CLRF   x6C
2A1A:  CLRF   x6B
2A1C:  CLRF   x6A
2A1E:  CLRF   x69
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2A20:  CLRF   x54
2A22:  CLRF   x53
2A24:  MOVF   x54,W
2A26:  SUBLW  01
2A28:  BNC   2AC8
2A2A:  BNZ   2A32
2A2C:  MOVF   x53,W
2A2E:  SUBLW  F3
2A30:  BNC   2AC8
....................    { 
....................       col_0=read_col(0)+col_0; 
2A32:  CLRF   x6D
2A34:  MOVLB  0
2A36:  CALL   2158
2A3A:  MOVF   01,W
2A3C:  MOVLB  8
2A3E:  ADDWF  x55,F
2A40:  MOVLW  00
2A42:  ADDWFC x56,F
2A44:  ADDWFC x57,F
2A46:  ADDWFC x58,F
....................       col_1=read_col(1)+col_1; 
2A48:  MOVLW  01
2A4A:  MOVWF  x6D
2A4C:  MOVLB  0
2A4E:  CALL   2158
2A52:  MOVF   01,W
2A54:  MOVLB  8
2A56:  ADDWF  x59,F
2A58:  MOVLW  00
2A5A:  ADDWFC x5A,F
2A5C:  ADDWFC x5B,F
2A5E:  ADDWFC x5C,F
....................       col_2=read_col(2)+col_2; 
2A60:  MOVLW  02
2A62:  MOVWF  x6D
2A64:  MOVLB  0
2A66:  CALL   2158
2A6A:  MOVF   01,W
2A6C:  MOVLB  8
2A6E:  ADDWF  x5D,F
2A70:  MOVLW  00
2A72:  ADDWFC x5E,F
2A74:  ADDWFC x5F,F
2A76:  ADDWFC x60,F
....................       col_3=read_col(3)+col_3; 
2A78:  MOVLW  03
2A7A:  MOVWF  x6D
2A7C:  MOVLB  0
2A7E:  CALL   2158
2A82:  MOVF   01,W
2A84:  MOVLB  8
2A86:  ADDWF  x61,F
2A88:  MOVLW  00
2A8A:  ADDWFC x62,F
2A8C:  ADDWFC x63,F
2A8E:  ADDWFC x64,F
....................       col_4=read_col(4)+col_4; 
2A90:  MOVLW  04
2A92:  MOVWF  x6D
2A94:  MOVLB  0
2A96:  CALL   2158
2A9A:  MOVF   01,W
2A9C:  MOVLB  8
2A9E:  ADDWF  x65,F
2AA0:  MOVLW  00
2AA2:  ADDWFC x66,F
2AA4:  ADDWFC x67,F
2AA6:  ADDWFC x68,F
....................       col_5=read_col(5)+col_5; 
2AA8:  MOVLW  05
2AAA:  MOVWF  x6D
2AAC:  MOVLB  0
2AAE:  CALL   2158
2AB2:  MOVF   01,W
2AB4:  MOVLB  8
2AB6:  ADDWF  x69,F
2AB8:  MOVLW  00
2ABA:  ADDWFC x6A,F
2ABC:  ADDWFC x6B,F
2ABE:  ADDWFC x6C,F
....................    } 
2AC0:  INCF   x53,F
2AC2:  BTFSC  FD8.2
2AC4:  INCF   x54,F
2AC6:  BRA    2A24
....................    col_0=col_0/500; 
2AC8:  BCF    FD8.1
2ACA:  MOVFF  858,90F
2ACE:  MOVFF  857,90E
2AD2:  MOVFF  856,90D
2AD6:  MOVFF  855,90C
2ADA:  MOVLB  9
2ADC:  CLRF   x13
2ADE:  CLRF   x12
2AE0:  MOVLW  01
2AE2:  MOVWF  x11
2AE4:  MOVLW  F4
2AE6:  MOVWF  x10
2AE8:  MOVLB  0
2AEA:  CALL   2266
2AEE:  MOVFF  03,858
2AF2:  MOVFF  02,857
2AF6:  MOVFF  01,856
2AFA:  MOVFF  00,855
....................    col_1=col_1/500; 
2AFE:  BCF    FD8.1
2B00:  MOVFF  85C,90F
2B04:  MOVFF  85B,90E
2B08:  MOVFF  85A,90D
2B0C:  MOVFF  859,90C
2B10:  MOVLB  9
2B12:  CLRF   x13
2B14:  CLRF   x12
2B16:  MOVLW  01
2B18:  MOVWF  x11
2B1A:  MOVLW  F4
2B1C:  MOVWF  x10
2B1E:  MOVLB  0
2B20:  CALL   2266
2B24:  MOVFF  03,85C
2B28:  MOVFF  02,85B
2B2C:  MOVFF  01,85A
2B30:  MOVFF  00,859
....................    col_2=col_2/500; 
2B34:  BCF    FD8.1
2B36:  MOVFF  860,90F
2B3A:  MOVFF  85F,90E
2B3E:  MOVFF  85E,90D
2B42:  MOVFF  85D,90C
2B46:  MOVLB  9
2B48:  CLRF   x13
2B4A:  CLRF   x12
2B4C:  MOVLW  01
2B4E:  MOVWF  x11
2B50:  MOVLW  F4
2B52:  MOVWF  x10
2B54:  MOVLB  0
2B56:  CALL   2266
2B5A:  MOVFF  03,860
2B5E:  MOVFF  02,85F
2B62:  MOVFF  01,85E
2B66:  MOVFF  00,85D
....................    col_3=col_3/500; 
2B6A:  BCF    FD8.1
2B6C:  MOVFF  864,90F
2B70:  MOVFF  863,90E
2B74:  MOVFF  862,90D
2B78:  MOVFF  861,90C
2B7C:  MOVLB  9
2B7E:  CLRF   x13
2B80:  CLRF   x12
2B82:  MOVLW  01
2B84:  MOVWF  x11
2B86:  MOVLW  F4
2B88:  MOVWF  x10
2B8A:  MOVLB  0
2B8C:  CALL   2266
2B90:  MOVFF  03,864
2B94:  MOVFF  02,863
2B98:  MOVFF  01,862
2B9C:  MOVFF  00,861
....................    col_4=col_4/500; 
2BA0:  BCF    FD8.1
2BA2:  MOVFF  868,90F
2BA6:  MOVFF  867,90E
2BAA:  MOVFF  866,90D
2BAE:  MOVFF  865,90C
2BB2:  MOVLB  9
2BB4:  CLRF   x13
2BB6:  CLRF   x12
2BB8:  MOVLW  01
2BBA:  MOVWF  x11
2BBC:  MOVLW  F4
2BBE:  MOVWF  x10
2BC0:  MOVLB  0
2BC2:  CALL   2266
2BC6:  MOVFF  03,868
2BCA:  MOVFF  02,867
2BCE:  MOVFF  01,866
2BD2:  MOVFF  00,865
....................    col_5=col_5/500; 
2BD6:  BCF    FD8.1
2BD8:  MOVFF  86C,90F
2BDC:  MOVFF  86B,90E
2BE0:  MOVFF  86A,90D
2BE4:  MOVFF  869,90C
2BE8:  MOVLB  9
2BEA:  CLRF   x13
2BEC:  CLRF   x12
2BEE:  MOVLW  01
2BF0:  MOVWF  x11
2BF2:  MOVLW  F4
2BF4:  MOVWF  x10
2BF6:  MOVLB  0
2BF8:  CALL   2266
2BFC:  MOVFF  03,86C
2C00:  MOVFF  02,86B
2C04:  MOVFF  01,86A
2C08:  MOVFF  00,869
....................    if(keydebug_en) 
2C0C:  MOVLB  1
2C0E:  MOVF   x44,F
2C10:  BTFSC  FD8.2
2C12:  BRA    2DDC
....................    { 
....................       fprintf(COM2,"\r\n");      
2C14:  MOVLW  0D
2C16:  MOVLB  9
2C18:  MOVWF  x0C
2C1A:  MOVLB  0
2C1C:  CALL   1604
2C20:  MOVLW  0A
2C22:  MOVLB  9
2C24:  MOVWF  x0C
2C26:  MOVLB  0
2C28:  CALL   1604
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2C2C:  MOVLW  02
2C2E:  MOVWF  FF6
2C30:  MOVLW  05
2C32:  MOVWF  FF7
2C34:  MOVLW  07
2C36:  MOVLB  8
2C38:  MOVWF  xF7
2C3A:  MOVLB  0
2C3C:  CALL   164A
2C40:  MOVLW  41
2C42:  MOVWF  FE9
2C44:  MOVFF  858,8FA
2C48:  MOVFF  857,8F9
2C4C:  MOVFF  856,8F8
2C50:  MOVFF  855,8F7
2C54:  CALL   22FA
2C58:  MOVLW  0D
2C5A:  MOVLB  9
2C5C:  MOVWF  x0C
2C5E:  MOVLB  0
2C60:  CALL   1604
2C64:  MOVLW  0A
2C66:  MOVLB  9
2C68:  MOVWF  x0C
2C6A:  MOVLB  0
2C6C:  CALL   1604
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2C70:  MOVLW  10
2C72:  MOVWF  FF6
2C74:  MOVLW  05
2C76:  MOVWF  FF7
2C78:  MOVLW  07
2C7A:  MOVLB  8
2C7C:  MOVWF  xF7
2C7E:  MOVLB  0
2C80:  CALL   164A
2C84:  MOVLW  41
2C86:  MOVWF  FE9
2C88:  MOVFF  85C,8FA
2C8C:  MOVFF  85B,8F9
2C90:  MOVFF  85A,8F8
2C94:  MOVFF  859,8F7
2C98:  CALL   22FA
2C9C:  MOVLW  0D
2C9E:  MOVLB  9
2CA0:  MOVWF  x0C
2CA2:  MOVLB  0
2CA4:  CALL   1604
2CA8:  MOVLW  0A
2CAA:  MOVLB  9
2CAC:  MOVWF  x0C
2CAE:  MOVLB  0
2CB0:  CALL   1604
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2CB4:  MOVLW  1E
2CB6:  MOVWF  FF6
2CB8:  MOVLW  05
2CBA:  MOVWF  FF7
2CBC:  MOVLW  07
2CBE:  MOVLB  8
2CC0:  MOVWF  xF7
2CC2:  MOVLB  0
2CC4:  CALL   164A
2CC8:  MOVLW  41
2CCA:  MOVWF  FE9
2CCC:  MOVFF  860,8FA
2CD0:  MOVFF  85F,8F9
2CD4:  MOVFF  85E,8F8
2CD8:  MOVFF  85D,8F7
2CDC:  CALL   22FA
2CE0:  MOVLW  0D
2CE2:  MOVLB  9
2CE4:  MOVWF  x0C
2CE6:  MOVLB  0
2CE8:  CALL   1604
2CEC:  MOVLW  0A
2CEE:  MOVLB  9
2CF0:  MOVWF  x0C
2CF2:  MOVLB  0
2CF4:  CALL   1604
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2CF8:  MOVLW  2C
2CFA:  MOVWF  FF6
2CFC:  MOVLW  05
2CFE:  MOVWF  FF7
2D00:  MOVLW  07
2D02:  MOVLB  8
2D04:  MOVWF  xF7
2D06:  MOVLB  0
2D08:  CALL   164A
2D0C:  MOVLW  41
2D0E:  MOVWF  FE9
2D10:  MOVFF  864,8FA
2D14:  MOVFF  863,8F9
2D18:  MOVFF  862,8F8
2D1C:  MOVFF  861,8F7
2D20:  CALL   22FA
2D24:  MOVLW  0D
2D26:  MOVLB  9
2D28:  MOVWF  x0C
2D2A:  MOVLB  0
2D2C:  CALL   1604
2D30:  MOVLW  0A
2D32:  MOVLB  9
2D34:  MOVWF  x0C
2D36:  MOVLB  0
2D38:  CALL   1604
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2D3C:  MOVLW  3A
2D3E:  MOVWF  FF6
2D40:  MOVLW  05
2D42:  MOVWF  FF7
2D44:  MOVLW  07
2D46:  MOVLB  8
2D48:  MOVWF  xF7
2D4A:  MOVLB  0
2D4C:  CALL   164A
2D50:  MOVLW  41
2D52:  MOVWF  FE9
2D54:  MOVFF  868,8FA
2D58:  MOVFF  867,8F9
2D5C:  MOVFF  866,8F8
2D60:  MOVFF  865,8F7
2D64:  CALL   22FA
2D68:  MOVLW  0D
2D6A:  MOVLB  9
2D6C:  MOVWF  x0C
2D6E:  MOVLB  0
2D70:  CALL   1604
2D74:  MOVLW  0A
2D76:  MOVLB  9
2D78:  MOVWF  x0C
2D7A:  MOVLB  0
2D7C:  CALL   1604
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2D80:  MOVLW  48
2D82:  MOVWF  FF6
2D84:  MOVLW  05
2D86:  MOVWF  FF7
2D88:  MOVLW  07
2D8A:  MOVLB  8
2D8C:  MOVWF  xF7
2D8E:  MOVLB  0
2D90:  CALL   164A
2D94:  MOVLW  41
2D96:  MOVWF  FE9
2D98:  MOVFF  86C,8FA
2D9C:  MOVFF  86B,8F9
2DA0:  MOVFF  86A,8F8
2DA4:  MOVFF  869,8F7
2DA8:  CALL   22FA
2DAC:  MOVLW  0D
2DAE:  MOVLB  9
2DB0:  MOVWF  x0C
2DB2:  MOVLB  0
2DB4:  CALL   1604
2DB8:  MOVLW  0A
2DBA:  MOVLB  9
2DBC:  MOVWF  x0C
2DBE:  MOVLB  0
2DC0:  CALL   1604
....................       fprintf(COM2,"\r\n"); 
2DC4:  MOVLW  0D
2DC6:  MOVLB  9
2DC8:  MOVWF  x0C
2DCA:  MOVLB  0
2DCC:  CALL   1604
2DD0:  MOVLW  0A
2DD2:  MOVLB  9
2DD4:  MOVWF  x0C
2DD6:  MOVLB  0
2DD8:  CALL   1604
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2DDC:  MOVLB  8
2DDE:  MOVF   x58,F
2DE0:  BNZ   2DF0
2DE2:  MOVF   x57,F
2DE4:  BNZ   2DF0
2DE6:  MOVF   x56,F
2DE8:  BNZ   2DF0
2DEA:  MOVF   x55,W
2DEC:  SUBLW  05
2DEE:  BC    2E62
2DF0:  MOVF   x58,F
2DF2:  BNZ   2E62
2DF4:  MOVF   x57,F
2DF6:  BNZ   2E62
2DF8:  MOVF   x56,F
2DFA:  BNZ   2E62
2DFC:  MOVF   x55,W
2DFE:  SUBLW  3B
2E00:  BNC   2E62
2E02:  MOVF   x5C,F
2E04:  BNZ   2E14
2E06:  MOVF   x5B,F
2E08:  BNZ   2E14
2E0A:  MOVF   x5A,F
2E0C:  BNZ   2E14
2E0E:  MOVF   x59,W
2E10:  SUBLW  64
2E12:  BC    2E62
2E14:  MOVF   x60,F
2E16:  BNZ   2E26
2E18:  MOVF   x5F,F
2E1A:  BNZ   2E26
2E1C:  MOVF   x5E,F
2E1E:  BNZ   2E26
2E20:  MOVF   x5D,W
2E22:  SUBLW  64
2E24:  BC    2E62
2E26:  MOVF   x64,F
2E28:  BNZ   2E38
2E2A:  MOVF   x63,F
2E2C:  BNZ   2E38
2E2E:  MOVF   x62,F
2E30:  BNZ   2E38
2E32:  MOVF   x61,W
2E34:  SUBLW  64
2E36:  BC    2E62
2E38:  MOVF   x68,F
2E3A:  BNZ   2E4A
2E3C:  MOVF   x67,F
2E3E:  BNZ   2E4A
2E40:  MOVF   x66,F
2E42:  BNZ   2E4A
2E44:  MOVF   x65,W
2E46:  SUBLW  64
2E48:  BC    2E62
2E4A:  MOVF   x6C,F
2E4C:  BNZ   2E5C
2E4E:  MOVF   x6B,F
2E50:  BNZ   2E5C
2E52:  MOVF   x6A,F
2E54:  BNZ   2E5C
2E56:  MOVF   x69,W
2E58:  SUBLW  64
2E5A:  BC    2E62
2E5C:  MOVLW  00
2E5E:  MOVWF  01
2E60:  BRA    31DA
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2E62:  MOVF   x5C,F
2E64:  BNZ   2E74
2E66:  MOVF   x5B,F
2E68:  BNZ   2E74
2E6A:  MOVF   x5A,F
2E6C:  BNZ   2E74
2E6E:  MOVF   x59,W
2E70:  SUBLW  05
2E72:  BC    2EE6
2E74:  MOVF   x5C,F
2E76:  BNZ   2EE6
2E78:  MOVF   x5B,F
2E7A:  BNZ   2EE6
2E7C:  MOVF   x5A,F
2E7E:  BNZ   2EE6
2E80:  MOVF   x59,W
2E82:  SUBLW  3B
2E84:  BNC   2EE6
2E86:  MOVF   x58,F
2E88:  BNZ   2E98
2E8A:  MOVF   x57,F
2E8C:  BNZ   2E98
2E8E:  MOVF   x56,F
2E90:  BNZ   2E98
2E92:  MOVF   x55,W
2E94:  SUBLW  64
2E96:  BC    2EE6
2E98:  MOVF   x60,F
2E9A:  BNZ   2EAA
2E9C:  MOVF   x5F,F
2E9E:  BNZ   2EAA
2EA0:  MOVF   x5E,F
2EA2:  BNZ   2EAA
2EA4:  MOVF   x5D,W
2EA6:  SUBLW  64
2EA8:  BC    2EE6
2EAA:  MOVF   x64,F
2EAC:  BNZ   2EBC
2EAE:  MOVF   x63,F
2EB0:  BNZ   2EBC
2EB2:  MOVF   x62,F
2EB4:  BNZ   2EBC
2EB6:  MOVF   x61,W
2EB8:  SUBLW  64
2EBA:  BC    2EE6
2EBC:  MOVF   x68,F
2EBE:  BNZ   2ECE
2EC0:  MOVF   x67,F
2EC2:  BNZ   2ECE
2EC4:  MOVF   x66,F
2EC6:  BNZ   2ECE
2EC8:  MOVF   x65,W
2ECA:  SUBLW  64
2ECC:  BC    2EE6
2ECE:  MOVF   x6C,F
2ED0:  BNZ   2EE0
2ED2:  MOVF   x6B,F
2ED4:  BNZ   2EE0
2ED6:  MOVF   x6A,F
2ED8:  BNZ   2EE0
2EDA:  MOVF   x69,W
2EDC:  SUBLW  64
2EDE:  BC    2EE6
2EE0:  MOVLW  01
2EE2:  MOVWF  01
2EE4:  BRA    31DA
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2EE6:  MOVF   x60,F
2EE8:  BNZ   2EF8
2EEA:  MOVF   x5F,F
2EEC:  BNZ   2EF8
2EEE:  MOVF   x5E,F
2EF0:  BNZ   2EF8
2EF2:  MOVF   x5D,W
2EF4:  SUBLW  05
2EF6:  BC    2F6A
2EF8:  MOVF   x60,F
2EFA:  BNZ   2F6A
2EFC:  MOVF   x5F,F
2EFE:  BNZ   2F6A
2F00:  MOVF   x5E,F
2F02:  BNZ   2F6A
2F04:  MOVF   x5D,W
2F06:  SUBLW  3B
2F08:  BNC   2F6A
2F0A:  MOVF   x5C,F
2F0C:  BNZ   2F1C
2F0E:  MOVF   x5B,F
2F10:  BNZ   2F1C
2F12:  MOVF   x5A,F
2F14:  BNZ   2F1C
2F16:  MOVF   x59,W
2F18:  SUBLW  64
2F1A:  BC    2F6A
2F1C:  MOVF   x58,F
2F1E:  BNZ   2F2E
2F20:  MOVF   x57,F
2F22:  BNZ   2F2E
2F24:  MOVF   x56,F
2F26:  BNZ   2F2E
2F28:  MOVF   x55,W
2F2A:  SUBLW  64
2F2C:  BC    2F6A
2F2E:  MOVF   x64,F
2F30:  BNZ   2F40
2F32:  MOVF   x63,F
2F34:  BNZ   2F40
2F36:  MOVF   x62,F
2F38:  BNZ   2F40
2F3A:  MOVF   x61,W
2F3C:  SUBLW  64
2F3E:  BC    2F6A
2F40:  MOVF   x68,F
2F42:  BNZ   2F52
2F44:  MOVF   x67,F
2F46:  BNZ   2F52
2F48:  MOVF   x66,F
2F4A:  BNZ   2F52
2F4C:  MOVF   x65,W
2F4E:  SUBLW  64
2F50:  BC    2F6A
2F52:  MOVF   x6C,F
2F54:  BNZ   2F64
2F56:  MOVF   x6B,F
2F58:  BNZ   2F64
2F5A:  MOVF   x6A,F
2F5C:  BNZ   2F64
2F5E:  MOVF   x69,W
2F60:  SUBLW  64
2F62:  BC    2F6A
2F64:  MOVLW  02
2F66:  MOVWF  01
2F68:  BRA    31DA
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2F6A:  MOVF   x64,F
2F6C:  BNZ   2F7C
2F6E:  MOVF   x63,F
2F70:  BNZ   2F7C
2F72:  MOVF   x62,F
2F74:  BNZ   2F7C
2F76:  MOVF   x61,W
2F78:  SUBLW  05
2F7A:  BC    2FEE
2F7C:  MOVF   x64,F
2F7E:  BNZ   2FEE
2F80:  MOVF   x63,F
2F82:  BNZ   2FEE
2F84:  MOVF   x62,F
2F86:  BNZ   2FEE
2F88:  MOVF   x61,W
2F8A:  SUBLW  3B
2F8C:  BNC   2FEE
2F8E:  MOVF   x5C,F
2F90:  BNZ   2FA0
2F92:  MOVF   x5B,F
2F94:  BNZ   2FA0
2F96:  MOVF   x5A,F
2F98:  BNZ   2FA0
2F9A:  MOVF   x59,W
2F9C:  SUBLW  64
2F9E:  BC    2FEE
2FA0:  MOVF   x60,F
2FA2:  BNZ   2FB2
2FA4:  MOVF   x5F,F
2FA6:  BNZ   2FB2
2FA8:  MOVF   x5E,F
2FAA:  BNZ   2FB2
2FAC:  MOVF   x5D,W
2FAE:  SUBLW  64
2FB0:  BC    2FEE
2FB2:  MOVF   x58,F
2FB4:  BNZ   2FC4
2FB6:  MOVF   x57,F
2FB8:  BNZ   2FC4
2FBA:  MOVF   x56,F
2FBC:  BNZ   2FC4
2FBE:  MOVF   x55,W
2FC0:  SUBLW  64
2FC2:  BC    2FEE
2FC4:  MOVF   x68,F
2FC6:  BNZ   2FD6
2FC8:  MOVF   x67,F
2FCA:  BNZ   2FD6
2FCC:  MOVF   x66,F
2FCE:  BNZ   2FD6
2FD0:  MOVF   x65,W
2FD2:  SUBLW  64
2FD4:  BC    2FEE
2FD6:  MOVF   x6C,F
2FD8:  BNZ   2FE8
2FDA:  MOVF   x6B,F
2FDC:  BNZ   2FE8
2FDE:  MOVF   x6A,F
2FE0:  BNZ   2FE8
2FE2:  MOVF   x69,W
2FE4:  SUBLW  64
2FE6:  BC    2FEE
2FE8:  MOVLW  03
2FEA:  MOVWF  01
2FEC:  BRA    31DA
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
2FEE:  MOVF   x68,F
2FF0:  BNZ   3000
2FF2:  MOVF   x67,F
2FF4:  BNZ   3000
2FF6:  MOVF   x66,F
2FF8:  BNZ   3000
2FFA:  MOVF   x65,W
2FFC:  SUBLW  05
2FFE:  BC    3072
3000:  MOVF   x68,F
3002:  BNZ   3072
3004:  MOVF   x67,F
3006:  BNZ   3072
3008:  MOVF   x66,F
300A:  BNZ   3072
300C:  MOVF   x65,W
300E:  SUBLW  3B
3010:  BNC   3072
3012:  MOVF   x5C,F
3014:  BNZ   3024
3016:  MOVF   x5B,F
3018:  BNZ   3024
301A:  MOVF   x5A,F
301C:  BNZ   3024
301E:  MOVF   x59,W
3020:  SUBLW  64
3022:  BC    3072
3024:  MOVF   x60,F
3026:  BNZ   3036
3028:  MOVF   x5F,F
302A:  BNZ   3036
302C:  MOVF   x5E,F
302E:  BNZ   3036
3030:  MOVF   x5D,W
3032:  SUBLW  64
3034:  BC    3072
3036:  MOVF   x64,F
3038:  BNZ   3048
303A:  MOVF   x63,F
303C:  BNZ   3048
303E:  MOVF   x62,F
3040:  BNZ   3048
3042:  MOVF   x61,W
3044:  SUBLW  64
3046:  BC    3072
3048:  MOVF   x58,F
304A:  BNZ   305A
304C:  MOVF   x57,F
304E:  BNZ   305A
3050:  MOVF   x56,F
3052:  BNZ   305A
3054:  MOVF   x55,W
3056:  SUBLW  64
3058:  BC    3072
305A:  MOVF   x6C,F
305C:  BNZ   306C
305E:  MOVF   x6B,F
3060:  BNZ   306C
3062:  MOVF   x6A,F
3064:  BNZ   306C
3066:  MOVF   x69,W
3068:  SUBLW  64
306A:  BC    3072
306C:  MOVLW  04
306E:  MOVWF  01
3070:  BRA    31DA
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
3072:  MOVF   x6C,F
3074:  BNZ   3084
3076:  MOVF   x6B,F
3078:  BNZ   3084
307A:  MOVF   x6A,F
307C:  BNZ   3084
307E:  MOVF   x69,W
3080:  SUBLW  05
3082:  BC    30F6
3084:  MOVF   x6C,F
3086:  BNZ   30F6
3088:  MOVF   x6B,F
308A:  BNZ   30F6
308C:  MOVF   x6A,F
308E:  BNZ   30F6
3090:  MOVF   x69,W
3092:  SUBLW  3B
3094:  BNC   30F6
3096:  MOVF   x5C,F
3098:  BNZ   30A8
309A:  MOVF   x5B,F
309C:  BNZ   30A8
309E:  MOVF   x5A,F
30A0:  BNZ   30A8
30A2:  MOVF   x59,W
30A4:  SUBLW  64
30A6:  BC    30F6
30A8:  MOVF   x60,F
30AA:  BNZ   30BA
30AC:  MOVF   x5F,F
30AE:  BNZ   30BA
30B0:  MOVF   x5E,F
30B2:  BNZ   30BA
30B4:  MOVF   x5D,W
30B6:  SUBLW  64
30B8:  BC    30F6
30BA:  MOVF   x64,F
30BC:  BNZ   30CC
30BE:  MOVF   x63,F
30C0:  BNZ   30CC
30C2:  MOVF   x62,F
30C4:  BNZ   30CC
30C6:  MOVF   x61,W
30C8:  SUBLW  64
30CA:  BC    30F6
30CC:  MOVF   x68,F
30CE:  BNZ   30DE
30D0:  MOVF   x67,F
30D2:  BNZ   30DE
30D4:  MOVF   x66,F
30D6:  BNZ   30DE
30D8:  MOVF   x65,W
30DA:  SUBLW  64
30DC:  BC    30F6
30DE:  MOVF   x58,F
30E0:  BNZ   30F0
30E2:  MOVF   x57,F
30E4:  BNZ   30F0
30E6:  MOVF   x56,F
30E8:  BNZ   30F0
30EA:  MOVF   x55,W
30EC:  SUBLW  64
30EE:  BC    30F6
30F0:  MOVLW  05
30F2:  MOVWF  01
30F4:  BRA    31DA
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
30F6:  MOVF   x6C,F
30F8:  BNZ   310A
30FA:  MOVF   x6B,F
30FC:  BNZ   310A
30FE:  MOVF   x6A,F
3100:  BNZ   310A
3102:  MOVF   x69,W
3104:  SUBLW  C8
3106:  BTFSC  FD8.0
3108:  BRA    31D6
310A:  MOVF   x58,F
310C:  BTFSS  FD8.2
310E:  BRA    31D6
3110:  MOVF   x57,F
3112:  BTFSS  FD8.2
3114:  BRA    31D6
3116:  MOVF   x56,F
3118:  BTFSS  FD8.2
311A:  BRA    31D6
311C:  MOVF   x55,W
311E:  SUBLW  B3
3120:  BTFSS  FD8.0
3122:  BRA    31D6
3124:  MOVF   x58,F
3126:  BNZ   3138
3128:  MOVF   x57,F
312A:  BNZ   3138
312C:  MOVF   x56,F
312E:  BNZ   3138
3130:  MOVF   x55,W
3132:  SUBLW  64
3134:  BTFSC  FD8.0
3136:  BRA    31D6
3138:  MOVF   x5C,F
313A:  BTFSS  FD8.2
313C:  BRA    31D6
313E:  MOVF   x5B,F
3140:  BTFSS  FD8.2
3142:  BRA    31D6
3144:  MOVF   x5A,F
3146:  BTFSS  FD8.2
3148:  BRA    31D6
314A:  MOVF   x59,W
314C:  SUBLW  B3
314E:  BNC   31D6
3150:  MOVF   x5C,F
3152:  BNZ   3162
3154:  MOVF   x5B,F
3156:  BNZ   3162
3158:  MOVF   x5A,F
315A:  BNZ   3162
315C:  MOVF   x59,W
315E:  SUBLW  64
3160:  BC    31D6
3162:  MOVF   x60,F
3164:  BNZ   31D6
3166:  MOVF   x5F,F
3168:  BNZ   31D6
316A:  MOVF   x5E,F
316C:  BNZ   31D6
316E:  MOVF   x5D,W
3170:  SUBLW  B3
3172:  BNC   31D6
3174:  MOVF   x60,F
3176:  BNZ   3186
3178:  MOVF   x5F,F
317A:  BNZ   3186
317C:  MOVF   x5E,F
317E:  BNZ   3186
3180:  MOVF   x5D,W
3182:  SUBLW  64
3184:  BC    31D6
3186:  MOVF   x64,F
3188:  BNZ   31D6
318A:  MOVF   x63,F
318C:  BNZ   31D6
318E:  MOVF   x62,F
3190:  BNZ   31D6
3192:  MOVF   x61,W
3194:  SUBLW  B3
3196:  BNC   31D6
3198:  MOVF   x64,F
319A:  BNZ   31AA
319C:  MOVF   x63,F
319E:  BNZ   31AA
31A0:  MOVF   x62,F
31A2:  BNZ   31AA
31A4:  MOVF   x61,W
31A6:  SUBLW  64
31A8:  BC    31D6
31AA:  MOVF   x68,F
31AC:  BNZ   31D6
31AE:  MOVF   x67,F
31B0:  BNZ   31D6
31B2:  MOVF   x66,F
31B4:  BNZ   31D6
31B6:  MOVF   x65,W
31B8:  SUBLW  B3
31BA:  BNC   31D6
31BC:  MOVF   x68,F
31BE:  BNZ   31CE
31C0:  MOVF   x67,F
31C2:  BNZ   31CE
31C4:  MOVF   x66,F
31C6:  BNZ   31CE
31C8:  MOVF   x65,W
31CA:  SUBLW  64
31CC:  BC    31D6
31CE:  MOVLW  05
31D0:  MOVWF  01
31D2:  BRA    31DA
....................    else return 0xff; 
31D4:  BRA    31DA
31D6:  MOVLW  FF
31D8:  MOVWF  01
.................... } 
31DA:  MOVLB  0
31DC:  GOTO   3242 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
31E0:  MOVLW  20
31E2:  MOVLB  8
31E4:  MOVWF  x51
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
31E6:  BSF    F93.4
31E8:  BTFSS  F81.4
31EA:  BRA    31FE
31EC:  BSF    F93.5
31EE:  BTFSS  F81.5
31F0:  BRA    31FE
31F2:  BSF    F93.6
31F4:  BTFSS  F81.6
31F6:  BRA    31FE
31F8:  BSF    F93.7
31FA:  BTFSC  F81.7
31FC:  BRA    3364
....................     { 
....................        if(input(ROW0)==0) 
31FE:  BSF    F93.4
3200:  BTFSC  F81.4
3202:  BRA    3208
....................          row=0; 
3204:  CLRF   x52
....................        else if(input(ROW1)==0) 
3206:  BRA    322A
3208:  BSF    F93.5
320A:  BTFSC  F81.5
320C:  BRA    3214
....................          row=1; 
320E:  MOVLW  01
3210:  MOVWF  x52
....................        else if(input(ROW2)==0) 
3212:  BRA    322A
3214:  BSF    F93.6
3216:  BTFSC  F81.6
3218:  BRA    3220
....................          row=2; 
321A:  MOVLW  02
321C:  MOVWF  x52
....................        else if(input(ROW3)==0) 
321E:  BRA    322A
3220:  BSF    F93.7
3222:  BTFSC  F81.7
3224:  BRA    322A
....................          row=3;      
3226:  MOVLW  03
3228:  MOVWF  x52
....................        if(type_KB==0)col=check_col(); 
322A:  MOVLB  1
322C:  MOVF   x49,F
322E:  BNZ   323C
3230:  MOVLB  0
3232:  GOTO   23C0
3236:  MOVFF  01,850
....................          else col=new_check_col(); 
323A:  BRA    3246
323C:  MOVLB  0
323E:  GOTO   29EE
3242:  MOVFF  01,850
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
3246:  MOVLB  8
3248:  INCFSZ x50,W
324A:  BRA    324E
324C:  BRA    3334
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
324E:  MOVLB  1
3250:  MOVF   x49,F
3252:  BNZ   327A
3254:  MOVLB  8
3256:  MOVF   x52,W
3258:  MULLW  05
325A:  MOVF   FF3,W
325C:  CLRF   x54
325E:  MOVWF  x53
3260:  CLRF   03
3262:  MOVF   x50,W
3264:  ADDWF  x53,W
3266:  MOVWF  01
3268:  MOVF   x54,W
326A:  ADDWFC 03,F
326C:  MOVF   01,W
326E:  MOVLB  0
3270:  CALL   030A
3274:  MOVFF  FE8,851
....................            else kchar =newKEYS[row][col]; 
3278:  BRA    329E
327A:  MOVLB  8
327C:  MOVF   x52,W
327E:  MULLW  06
3280:  MOVF   FF3,W
3282:  CLRF   x54
3284:  MOVWF  x53
3286:  CLRF   03
3288:  MOVF   x50,W
328A:  ADDWF  x53,W
328C:  MOVWF  01
328E:  MOVF   x54,W
3290:  ADDWFC 03,F
3292:  MOVF   01,W
3294:  MOVLB  0
3296:  CALL   032E
329A:  MOVFF  FE8,851
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
329E:  MOVLB  1
32A0:  MOVF   x44,F
32A2:  BNZ   3326
....................             { 
....................               charac_timeout=0; 
32A4:  CLRF   x00
32A6:  MOVLB  0
32A8:  CLRF   xFF
....................                if(key_count_ms<wideofkeystore) 
32AA:  MOVLB  1
32AC:  MOVF   x47,W
32AE:  SUBLW  0F
32B0:  BNC   3324
....................                { 
....................                    key_data[key_count_ms++]=kchar; 
32B2:  MOVF   x47,W
32B4:  INCF   x47,F
32B6:  CLRF   03
32B8:  ADDLW  4A
32BA:  MOVWF  FE9
32BC:  MOVLW  01
32BE:  ADDWFC 03,W
32C0:  MOVWF  FEA
32C2:  MOVFF  851,FEF
....................                    fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
32C6:  MOVLW  56
32C8:  MOVWF  FF6
32CA:  MOVLW  05
32CC:  MOVWF  FF7
32CE:  MOVLW  09
32D0:  MOVLB  8
32D2:  MOVWF  xF7
32D4:  MOVLB  0
32D6:  CALL   164A
32DA:  MOVFF  147,859
32DE:  MOVLW  18
32E0:  MOVLB  8
32E2:  MOVWF  x5A
32E4:  MOVLB  0
32E6:  CALL   177A
32EA:  MOVLW  5D
32EC:  MOVLB  9
32EE:  MOVWF  x0C
32F0:  MOVLB  0
32F2:  CALL   1604
32F6:  MOVLW  20
32F8:  MOVLB  9
32FA:  MOVWF  x0C
32FC:  MOVLB  0
32FE:  CALL   1604
3302:  MOVFF  851,90C
3306:  CALL   1604
330A:  MOVLW  0D
330C:  MOVLB  9
330E:  MOVWF  x0C
3310:  MOVLB  0
3312:  CALL   1604
3316:  MOVLW  0A
3318:  MOVLB  9
331A:  MOVWF  x0C
331C:  MOVLB  0
331E:  CALL   1604
3322:  MOVLB  1
....................                } 
....................             } 
....................                else fputc(kchar,COM2); 
3324:  BRA    3332
3326:  MOVFF  851,90C
332A:  MOVLB  0
332C:  CALL   1604
3330:  MOVLB  1
3332:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3334:  BSF    F93.4
3336:  BTFSS  F81.4
3338:  BRA    3334
333A:  BSF    F93.5
333C:  BTFSS  F81.5
333E:  BRA    3334
3340:  BSF    F93.6
3342:  BTFSS  F81.6
3344:  BRA    3334
3346:  BSF    F93.7
3348:  BTFSS  F81.7
334A:  BRA    3334
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
334C:  BSF    F93.4
334E:  BTFSS  F81.4
3350:  BRA    334C
3352:  BSF    F93.5
3354:  BTFSS  F81.5
3356:  BRA    334C
3358:  BSF    F93.6
335A:  BTFSS  F81.6
335C:  BRA    334C
335E:  BSF    F93.7
3360:  BTFSS  F81.7
3362:  BRA    334C
....................     } 
....................   set_tris_a(0xff);     
3364:  MOVLW  FF
3366:  MOVWF  F92
....................   return(kchar); 
3368:  MOVFF  851,01
.................... }//*/ 
336C:  MOVLB  0
336E:  RETURN 0
....................  
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int8 i,tempdata; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
54A2:  MOVF   27,F
54A4:  BTFSS  FD8.2
54A6:  BRA    5660
54A8:  MOVF   26,W
54AA:  SUBLW  01
54AC:  BTFSS  FD8.0
54AE:  BRA    5660
54B0:  BNZ   54C4
54B2:  MOVF   25,W
54B4:  SUBLW  FF
54B6:  BTFSS  FD8.0
54B8:  BRA    5660
54BA:  BNZ   54C4
54BC:  MOVF   24,W
54BE:  SUBLW  FE
54C0:  BTFSS  FD8.0
54C2:  BRA    5660
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
54C4:  MOVLB  1
54C6:  MOVF   x4A,F
54C8:  BNZ   54D0
54CA:  MOVF   x47,F
54CC:  BTFSC  FD8.2
54CE:  BRA    560C
....................       { 
....................          temp=get_countcard(); 
54D0:  MOVLB  0
54D2:  CALL   351C
54D6:  MOVFF  02,853
54DA:  MOVFF  01,852
....................          //fprintf(COM2," get_countcard=%lu\n\r",temp); 
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
54DE:  MOVLB  8
54E0:  RLCF   x52,W
54E2:  MOVWF  x54
54E4:  RLCF   x53,W
54E6:  MOVWF  x55
54E8:  RLCF   x54,F
54EA:  RLCF   x55,F
54EC:  RLCF   x54,F
54EE:  RLCF   x55,F
54F0:  RLCF   x54,F
54F2:  RLCF   x55,F
54F4:  MOVLW  F0
54F6:  ANDWF  x54,F
54F8:  MOVLW  0E
54FA:  ADDWF  x54,F
54FC:  MOVLW  C3
54FE:  ADDWFC x55,F
5500:  MOVLW  01
5502:  MOVWF  x56
5504:  BCF    FD8.2
5506:  BTFSC  FD8.0
5508:  INCF   x56,F
550A:  CLRF   x57
550C:  MOVLW  01
550E:  ADDWF  x54,W
5510:  MOVWF  00
5512:  MOVLW  00
5514:  ADDWFC x55,W
5516:  MOVWF  01
5518:  MOVLW  00
551A:  ADDWFC x56,W
551C:  MOVWF  02
551E:  MOVLW  00
5520:  ADDWFC x57,W
5522:  MOVWF  27
5524:  MOVFF  02,26
5528:  MOVFF  01,25
552C:  MOVFF  00,24
....................          //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<wideofkeystore;i++) 
5530:  CLRF   x50
5532:  MOVF   x50,W
5534:  SUBLW  0F
5536:  BNC   557E
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
5538:  MOVF   x50,W
553A:  ADDWF  24,W
553C:  MOVWF  00
553E:  MOVLW  00
5540:  ADDWFC 25,W
5542:  MOVWF  01
5544:  MOVLW  00
5546:  ADDWFC 26,W
5548:  MOVWF  02
554A:  MOVLW  00
554C:  ADDWFC 27,W
554E:  MOVWF  03
5550:  MOVWF  x57
5552:  MOVFF  02,856
5556:  MOVFF  01,855
555A:  MOVFF  00,854
555E:  MOVFF  FE8,916
5562:  MOVFF  02,915
5566:  MOVFF  01,914
556A:  MOVFF  00,913
556E:  MOVLB  9
5570:  CLRF   x17
5572:  MOVLB  0
5574:  CALL   3A6C
....................          } 
5578:  MOVLB  8
557A:  INCF   x50,F
557C:  BRA    5532
....................          for(i=0;i<wideofkeystore;i++) 
557E:  CLRF   x50
5580:  MOVF   x50,W
5582:  SUBLW  0F
5584:  BNC   55F0
....................          { 
....................             tempdata=key_data[i]; 
5586:  CLRF   03
5588:  MOVF   x50,W
558A:  ADDLW  4A
558C:  MOVWF  FE9
558E:  MOVLW  01
5590:  ADDWFC 03,W
5592:  MOVWF  FEA
5594:  MOVFF  FEF,851
....................             write_ext_eeprom((int32)ptr_card_key++,tempdata); 
5598:  MOVFF  27,03
559C:  MOVFF  26,02
55A0:  MOVFF  25,01
55A4:  MOVFF  24,00
55A8:  MOVLW  01
55AA:  ADDWF  24,F
55AC:  BTFSC  FD8.0
55AE:  INCF   25,F
55B0:  BTFSC  FD8.2
55B2:  INCF   26,F
55B4:  BTFSC  FD8.2
55B6:  INCF   27,F
55B8:  MOVFF  03,857
55BC:  MOVFF  02,856
55C0:  MOVFF  01,855
55C4:  MOVFF  00,854
55C8:  MOVFF  03,916
55CC:  MOVFF  02,915
55D0:  MOVFF  01,914
55D4:  MOVFF  00,913
55D8:  MOVFF  851,917
55DC:  MOVLB  0
55DE:  CALL   3A6C
....................             //delay_us(100); 
....................             fprintf(COM2,"%c",tempdata); 
55E2:  MOVFF  851,90C
55E6:  CALL   1604
....................          } 
55EA:  MOVLB  8
55EC:  INCF   x50,F
55EE:  BRA    5580
....................           //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................           /*fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<wideofkeystore;i++) 
....................           { 
....................             fprintf(COM2,"%c",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
55F0:  MOVFF  27,8FA
55F4:  MOVFF  26,8F9
55F8:  MOVFF  25,8F8
55FC:  MOVFF  24,8F7
5600:  MOVLW  1E
5602:  MOVWF  xFB
5604:  MOVLB  0
5606:  CALL   3B6A
560A:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
560C:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
560E:  MOVLW  01
5610:  MOVWF  FEA
5612:  MOVLW  4A
5614:  MOVWF  FE9
5616:  CLRF   00
5618:  CLRF   02
561A:  MOVLW  10
561C:  MOVWF  01
561E:  MOVLB  0
5620:  CALL   359A
....................       fprintf(COM2,"\r\n"); 
5624:  MOVLW  0D
5626:  MOVLB  9
5628:  MOVWF  x0C
562A:  MOVLB  0
562C:  CALL   1604
5630:  MOVLW  0A
5632:  MOVLB  9
5634:  MOVWF  x0C
5636:  MOVLB  0
5638:  CALL   1604
....................       fprintf(COM2,"Done save_key_new"); 
563C:  MOVLW  68
563E:  MOVWF  FF6
5640:  MOVLW  05
5642:  MOVWF  FF7
5644:  CALL   172E
....................       fprintf(COM2,"\r\n"); 
5648:  MOVLW  0D
564A:  MOVLB  9
564C:  MOVWF  x0C
564E:  MOVLB  0
5650:  CALL   1604
5654:  MOVLW  0A
5656:  MOVLB  9
5658:  MOVWF  x0C
565A:  MOVLB  0
565C:  CALL   1604
....................    } 
.................... } 
5660:  GOTO   5BA4 (RETURN)
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 recEn[wideofkeystore]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
5664:  MOVF   27,F
5666:  BTFSS  FD8.2
5668:  BRA    58D8
566A:  MOVF   26,W
566C:  SUBLW  01
566E:  BTFSS  FD8.0
5670:  BRA    58D8
5672:  BNZ   5686
5674:  MOVF   25,W
5676:  SUBLW  FF
5678:  BTFSS  FD8.0
567A:  BRA    58D8
567C:  BNZ   5686
567E:  MOVF   24,W
5680:  SUBLW  FE
5682:  BTFSS  FD8.0
5684:  BRA    58D8
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
5686:  MOVLB  1
5688:  MOVF   x4A,F
568A:  BNZ   5692
568C:  MOVF   x47,F
568E:  BTFSC  FD8.2
5690:  BRA    5884
....................       {    
....................          for(i=0;i<key_numbyte;i++) 
5692:  MOVLB  8
5694:  CLRF   x50
5696:  MOVF   x50,W
5698:  SUBLW  0B
569A:  BNC   56EE
....................          { 
....................             temp=key_data[i]; 
569C:  CLRF   03
569E:  MOVF   x50,W
56A0:  ADDLW  4A
56A2:  MOVWF  FE9
56A4:  MOVLW  01
56A6:  ADDWFC 03,W
56A8:  MOVWF  FEA
56AA:  CLRF   x52
56AC:  MOVFF  FEF,851
....................             fputc(temp,COM2); 
56B0:  MOVFF  851,90C
56B4:  MOVLB  0
56B6:  CALL   1604
....................             recEn[i]=key_data[i]; 
56BA:  CLRF   03
56BC:  MOVLB  8
56BE:  MOVF   x50,W
56C0:  ADDLW  54
56C2:  MOVWF  01
56C4:  MOVLW  08
56C6:  ADDWFC 03,F
56C8:  MOVFF  03,865
56CC:  CLRF   03
56CE:  MOVF   x50,W
56D0:  ADDLW  4A
56D2:  MOVWF  FE9
56D4:  MOVLW  01
56D6:  ADDWFC 03,W
56D8:  MOVWF  FEA
56DA:  MOVFF  FEF,866
56DE:  MOVFF  865,FEA
56E2:  MOVFF  01,FE9
56E6:  MOVFF  866,FEF
....................          } 
56EA:  INCF   x50,F
56EC:  BRA    5696
....................          recEn[key_numbyte] = 0; 
56EE:  CLRF   x60
....................          recEn[key_numbyte+1] = 0;          
56F0:  CLRF   x61
....................          recEn[key_numbyte+2] = 0;          
56F2:  CLRF   x62
....................          recEn[key_numbyte+3] = 0; 
56F4:  CLRF   x63
....................     #if 0 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"test_key:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"\n\rdatain:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2," %x",recEn[i]); 
....................          fprintf(COM2,"\n\r"); 
....................     #endif 
....................          EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
56F6:  MOVLB  9
56F8:  CLRF   x07
56FA:  CLRF   x06
56FC:  CLRF   x05
56FE:  MOVLW  3F
5700:  MOVWF  x04
5702:  CLRF   x0B
5704:  CLRF   x0A
5706:  CLRF   x09
5708:  MOVLW  20
570A:  MOVWF  x08
570C:  MOVLW  01
570E:  MOVWF  x0D
5710:  MOVWF  x0C
5712:  MOVLB  0
5714:  CALL   4004
....................          aes_enc_dec((unsigned int8 *)&recEn[0], (unsigned int8 *)&crypto_key[0],0); 
5718:  MOVLW  08
571A:  MOVLB  8
571C:  MOVWF  xF8
571E:  MOVLW  54
5720:  MOVWF  xF7
5722:  MOVLW  01
5724:  MOVWF  xFA
5726:  MOVWF  xF9
5728:  CLRF   xFB
572A:  MOVLB  0
572C:  CALL   40FA
....................          //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................           
....................          /* get the pointer of keyboard data */ 
....................          temp=get_countcard(); 
5730:  CALL   351C
5734:  MOVFF  02,852
5738:  MOVFF  01,851
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
573C:  MOVLB  8
573E:  RLCF   x51,W
5740:  MOVWF  x64
5742:  RLCF   x52,W
5744:  MOVWF  x65
5746:  RLCF   x64,F
5748:  RLCF   x65,F
574A:  RLCF   x64,F
574C:  RLCF   x65,F
574E:  RLCF   x64,F
5750:  RLCF   x65,F
5752:  MOVLW  F0
5754:  ANDWF  x64,F
5756:  MOVLW  0E
5758:  ADDWF  x64,F
575A:  MOVLW  C3
575C:  ADDWFC x65,F
575E:  MOVLW  01
5760:  MOVWF  x66
5762:  BCF    FD8.2
5764:  BTFSC  FD8.0
5766:  INCF   x66,F
5768:  CLRF   x67
576A:  MOVLW  01
576C:  ADDWF  x64,W
576E:  MOVWF  00
5770:  MOVLW  00
5772:  ADDWFC x65,W
5774:  MOVWF  01
5776:  MOVLW  00
5778:  ADDWFC x66,W
577A:  MOVWF  02
577C:  MOVLW  00
577E:  ADDWFC x67,W
5780:  MOVWF  27
5782:  MOVFF  02,26
5786:  MOVFF  01,25
578A:  MOVFF  00,24
....................          /* delete the old data of key store area  */ 
....................          //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<wideofkeystore;i++) 
578E:  CLRF   x50
5790:  MOVF   x50,W
5792:  SUBLW  0F
5794:  BNC   57DC
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
5796:  MOVF   x50,W
5798:  ADDWF  24,W
579A:  MOVWF  00
579C:  MOVLW  00
579E:  ADDWFC 25,W
57A0:  MOVWF  01
57A2:  MOVLW  00
57A4:  ADDWFC 26,W
57A6:  MOVWF  02
57A8:  MOVLW  00
57AA:  ADDWFC 27,W
57AC:  MOVWF  03
57AE:  MOVWF  x67
57B0:  MOVFF  02,866
57B4:  MOVFF  01,865
57B8:  MOVFF  00,864
57BC:  MOVFF  FE8,916
57C0:  MOVFF  02,915
57C4:  MOVFF  01,914
57C8:  MOVFF  00,913
57CC:  MOVLB  9
57CE:  CLRF   x17
57D0:  MOVLB  0
57D2:  CALL   3A6C
....................          } 
57D6:  MOVLB  8
57D8:  INCF   x50,F
57DA:  BRA    5790
....................          fprintf(COM2,"\n\r"); 
57DC:  MOVLW  0A
57DE:  MOVLB  9
57E0:  MOVWF  x0C
57E2:  MOVLB  0
57E4:  CALL   1604
57E8:  MOVLW  0D
57EA:  MOVLB  9
57EC:  MOVWF  x0C
57EE:  MOVLB  0
57F0:  CALL   1604
....................          for(i=0;i<wideofkeystore;i++) fprintf(COM2,"%x",recEn[i]); 
57F4:  MOVLB  8
57F6:  CLRF   x50
57F8:  MOVF   x50,W
57FA:  SUBLW  0F
57FC:  BNC   5826
57FE:  CLRF   03
5800:  MOVF   x50,W
5802:  ADDLW  54
5804:  MOVWF  FE9
5806:  MOVLW  08
5808:  ADDWFC 03,W
580A:  MOVWF  FEA
580C:  MOVFF  FEF,864
5810:  MOVFF  864,901
5814:  MOVLW  57
5816:  MOVLB  9
5818:  MOVWF  x02
581A:  MOVLB  0
581C:  CALL   4F86
5820:  MOVLB  8
5822:  INCF   x50,F
5824:  BRA    57F8
....................          retval = EEPROM_write(ptr_card_key,wideofkeystore,recEn);  
5826:  MOVFF  27,903
582A:  MOVFF  26,902
582E:  MOVFF  25,901
5832:  MOVFF  24,900
5836:  MOVLB  9
5838:  CLRF   x07
583A:  CLRF   x06
583C:  CLRF   x05
583E:  MOVLW  10
5840:  MOVWF  x04
5842:  MOVLW  08
5844:  MOVWF  x09
5846:  MOVLW  54
5848:  MOVWF  x08
584A:  MOVLB  0
584C:  CALL   4EF6
5850:  MOVFF  01,853
....................          if(retval!=0) 
5854:  MOVLB  8
5856:  MOVF   x53,F
5858:  BZ    5882
....................          { 
....................             ptr_card_key+=wideofkeystore; 
585A:  MOVLW  10
585C:  ADDWF  24,F
585E:  MOVLW  00
5860:  ADDWFC 25,F
5862:  ADDWFC 26,F
5864:  ADDWFC 27,F
....................             save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5866:  MOVFF  27,8FA
586A:  MOVFF  26,8F9
586E:  MOVFF  25,8F8
5872:  MOVFF  24,8F7
5876:  MOVLW  1E
5878:  MOVWF  xFB
587A:  MOVLB  0
587C:  CALL   3B6A
5880:  MOVLB  8
5882:  MOVLB  1
....................          }          
....................       } 
....................       key_count_ms=0; 
5884:  CLRF   x47
....................       memset(key_data,0,sizeof(key_data));  
5886:  MOVLW  01
5888:  MOVWF  FEA
588A:  MOVLW  4A
588C:  MOVWF  FE9
588E:  CLRF   00
5890:  CLRF   02
5892:  MOVLW  10
5894:  MOVWF  01
5896:  MOVLB  0
5898:  CALL   359A
....................       fprintf(COM2,"\r\n"); 
589C:  MOVLW  0D
589E:  MOVLB  9
58A0:  MOVWF  x0C
58A2:  MOVLB  0
58A4:  CALL   1604
58A8:  MOVLW  0A
58AA:  MOVLB  9
58AC:  MOVWF  x0C
58AE:  MOVLB  0
58B0:  CALL   1604
....................       fprintf(COM2,"Done Encrypted PIN"); 
58B4:  MOVLW  7A
58B6:  MOVWF  FF6
58B8:  MOVLW  05
58BA:  MOVWF  FF7
58BC:  CALL   172E
....................       fprintf(COM2,"\r\n"); 
58C0:  MOVLW  0D
58C2:  MOVLB  9
58C4:  MOVWF  x0C
58C6:  MOVLB  0
58C8:  CALL   1604
58CC:  MOVLW  0A
58CE:  MOVLB  9
58D0:  MOVWF  x0C
58D2:  MOVLB  0
58D4:  CALL   1604
....................    } 
.................... } 
58D8:  GOTO   5BAC (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
5FC0:  MOVLB  7
5FC2:  CLRF   xFA
5FC4:  CLRF   xF9
5FC6:  CLRF   xFB
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
5FC8:  MOVF   xFA,F
5FCA:  BTFSS  FD8.2
5FCC:  BRA    60F0
5FCE:  MOVF   xF4,W
5FD0:  SUBWF  xF9,W
5FD2:  BTFSC  FD8.0
5FD4:  BRA    60F0
5FD6:  MOVF   xFB,F
5FD8:  BTFSS  FD8.2
5FDA:  BRA    60F0
....................       c = fgetc(COM2);//getc(); 
5FDC:  MOVLB  0
5FDE:  RCALL  5F72
5FE0:  MOVFF  01,7F7
....................       switch(c) 
....................       { 
5FE4:  MOVLB  7
5FE6:  MOVF   xF7,W
5FE8:  XORLW  7F
5FEA:  MOVLB  0
5FEC:  BZ    5FF4
5FEE:  XORLW  72
5FF0:  BZ    6042
5FF2:  BRA    6080
....................          case 0x7f:    
....................             if(nbcar>0)   
5FF4:  MOVLB  7
5FF6:  MOVF   xF9,F
5FF8:  BNZ   5FFE
5FFA:  MOVF   xFA,F
5FFC:  BZ    6028
5FFE:  CLRF   19
6000:  BTFSC  FF2.7
6002:  BSF    19.7
6004:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
6006:  MOVLW  7F
6008:  MOVLB  9
600A:  MOVWF  x0C
600C:  MOVLB  0
600E:  CALL   1604
6012:  BTFSC  19.7
6014:  BSF    FF2.7
....................                nbcar--; 
6016:  MOVLB  7
6018:  MOVF   xF9,W
601A:  BTFSC  FD8.2
601C:  DECF   xFA,F
601E:  DECF   xF9,F
....................                fgetc(COM2);//getc(); 
6020:  MOVLB  0
6022:  RCALL  5F72
....................             } 
....................             else fputc(0x07,COM2);    
6024:  BRA    6040
6026:  MOVLB  7
6028:  CLRF   19
602A:  BTFSC  FF2.7
602C:  BSF    19.7
602E:  BCF    FF2.7
6030:  MOVLW  07
6032:  MOVLB  9
6034:  MOVWF  x0C
6036:  MOVLB  0
6038:  CALL   1604
603C:  BTFSC  19.7
603E:  BSF    FF2.7
....................          break;  
6040:  BRA    60EC
....................          case 0x0D:   
....................                keydebug_en=0; 
6042:  MOVLB  1
6044:  CLRF   x44
....................                set_tris_a(0xff); 
6046:  MOVLW  FF
6048:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
604A:  MOVFF  7F9,7F8
604E:  MOVLB  7
6050:  MOVF   xF4,W
6052:  SUBWF  xF8,W
6054:  BC    606A
....................                { 
....................                  chaine[i]=0; 
6056:  CLRF   03
6058:  MOVF   xF8,W
605A:  ADDWF  xF5,W
605C:  MOVWF  FE9
605E:  MOVF   xF6,W
6060:  ADDWFC 03,W
6062:  MOVWF  FEA
6064:  CLRF   FEF
....................                } 
6066:  INCF   xF8,F
6068:  BRA    6050
....................                if(nbcar==0)return(FAUX); 
606A:  MOVF   xF9,F
606C:  BNZ   6078
606E:  MOVF   xFA,F
6070:  BNZ   6078
6072:  MOVLW  00
6074:  MOVWF  01
6076:  BRA    60F4
....................                fini=VRAI; 
6078:  MOVLW  01
607A:  MOVWF  xFB
....................          break; 
607C:  MOVLB  0
607E:  BRA    60EC
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
6080:  MOVLB  7
6082:  MOVF   xF7,W
6084:  SUBLW  1F
6086:  BC    60EE
6088:  MOVF   xF7,W
608A:  SUBLW  7E
608C:  BNC   60EE
608E:  MOVLW  01
6090:  SUBWF  xF4,W
6092:  MOVF   xFA,F
6094:  BNZ   60EE
6096:  SUBWF  xF9,W
6098:  BC    60EE
....................             { 
....................                chaine[nbcar]=c; 
609A:  MOVF   xF5,W
609C:  ADDWF  xF9,W
609E:  MOVWF  FE9
60A0:  MOVF   xF6,W
60A2:  ADDWFC xFA,W
60A4:  MOVWF  FEA
60A6:  MOVFF  7F7,FEF
....................                nbcar++; 
60AA:  INCF   xF9,F
60AC:  BTFSC  FD8.2
60AE:  INCF   xFA,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
60B0:  DECFSZ xF3,W
60B2:  BRA    60CE
60B4:  CLRF   19
60B6:  BTFSC  FF2.7
60B8:  BSF    19.7
60BA:  BCF    FF2.7
60BC:  MOVFF  7F7,90C
60C0:  MOVLB  0
60C2:  CALL   1604
60C6:  BTFSC  19.7
60C8:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
60CA:  BRA    60EC
60CC:  MOVLB  7
60CE:  MOVF   xF3,W
60D0:  SUBLW  02
60D2:  BNZ   60EE
60D4:  CLRF   19
60D6:  BTFSC  FF2.7
60D8:  BSF    19.7
60DA:  BCF    FF2.7
60DC:  MOVLW  2A
60DE:  MOVLB  9
60E0:  MOVWF  x0C
60E2:  MOVLB  0
60E4:  CALL   1604
60E8:  BTFSC  19.7
60EA:  BSF    FF2.7
60EC:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
60EE:  BRA    5FC8
....................    return(nbcar); 
60F0:  MOVFF  7F9,01
.................... } 
60F4:  MOVLB  0
60F6:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
60F8:  MOVFF  7F4,7F8
60FC:  MOVFF  7F3,7F7
6100:  MOVFF  7F6,7FA
6104:  MOVFF  7F5,7F9
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
6108:  MOVFF  7F8,03
610C:  MOVLB  7
610E:  MOVFF  7F7,FE9
6112:  MOVFF  7F8,FEA
6116:  MOVF   FEF,F
6118:  BZ    6160
611A:  MOVFF  7FA,03
611E:  MOVFF  7F9,FE9
6122:  MOVFF  7FA,FEA
6126:  MOVF   FEF,F
6128:  BZ    6160
....................       if(*aa!=*bb) 
612A:  MOVFF  7F7,FE9
612E:  MOVFF  7F8,FEA
6132:  MOVFF  FEF,7FB
6136:  MOVFF  7FA,03
613A:  MOVFF  7F9,FE9
613E:  MOVFF  7FA,FEA
6142:  MOVF   FEF,W
6144:  SUBWF  xFB,W
6146:  BZ    614E
....................          return(1); 
6148:  MOVLW  01
614A:  MOVWF  01
614C:  BRA    618C
....................       aa++; 
614E:  INCF   xF7,F
6150:  BTFSC  FD8.2
6152:  INCF   xF8,F
....................       bb++; 
6154:  INCF   xF9,F
6156:  BTFSC  FD8.2
6158:  INCF   xFA,F
....................    } 
615A:  MOVLB  0
615C:  BRA    6108
615E:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
6160:  MOVFF  7F8,03
6164:  MOVFF  7F7,FE9
6168:  MOVFF  7F8,FEA
616C:  MOVFF  FEF,7FB
6170:  MOVFF  7FA,03
6174:  MOVFF  7F9,FE9
6178:  MOVFF  7FA,FEA
617C:  MOVF   FEF,W
617E:  SUBWF  xFB,W
6180:  BZ    6188
6182:  MOVLW  01
6184:  MOVWF  01
6186:  BRA    618C
....................    return(0); 
6188:  MOVLW  00
618A:  MOVWF  01
.................... } 
618C:  MOVLB  0
618E:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
6B68:  MOVLB  7
6B6A:  CLRF   xF5
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
6B6C:  MOVFF  7F4,03
6B70:  MOVF   xF3,W
6B72:  INCF   xF3,F
6B74:  BTFSC  FD8.2
6B76:  INCF   xF4,F
6B78:  MOVWF  FE9
6B7A:  MOVFF  03,FEA
6B7E:  MOVFF  FEF,7F7
6B82:  MOVF   xF7,F
6B84:  BZ    6BA8
....................         if (c >= '0' && c <= '9') 
6B86:  MOVF   xF7,W
6B88:  SUBLW  2F
6B8A:  BC    6B9A
6B8C:  MOVF   xF7,W
6B8E:  SUBLW  39
6B90:  BNC   6B9A
....................             digit = (unsigned int) (c - '0'); 
6B92:  MOVLW  30
6B94:  SUBWF  xF7,W
6B96:  MOVWF  xF6
....................         else 
6B98:  BRA    6B9C
....................             break; 
6B9A:  BRA    6BA8
....................  
....................         val = (val * 10) + digit; 
6B9C:  MOVF   xF5,W
6B9E:  MULLW  0A
6BA0:  MOVF   FF3,W
6BA2:  ADDWF  xF6,W
6BA4:  MOVWF  xF5
....................     } 
6BA6:  BRA    6B6C
....................  
....................     return val; 
6BA8:  CLRF   03
6BAA:  MOVFF  7F5,01
6BAE:  MOVFF  03,02
.................... } 
6BB2:  MOVLB  0
6BB4:  RETURN 0
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
06AC:  MOVLB  9
06AE:  CLRF   x3F
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
06B0:  CLRF   x40
06B2:  BTFSC  x37.0
06B4:  BSF    x40.7
06B6:  SWAPF  x38,W
06B8:  MOVWF  00
06BA:  RLCF   00,F
06BC:  RLCF   00,F
06BE:  MOVLW  C0
06C0:  ANDWF  00,F
06C2:  MOVF   00,W
06C4:  IORWF  x40,F
06C6:  SWAPF  x39,W
06C8:  MOVWF  00
06CA:  RLCF   00,F
06CC:  MOVLW  E0
06CE:  ANDWF  00,F
06D0:  MOVF   00,W
06D2:  IORWF  x40,F
06D4:  SWAPF  x3A,W
06D6:  MOVWF  00
06D8:  MOVLW  F0
06DA:  ANDWF  00,F
06DC:  MOVF   00,W
06DE:  IORWF  x40,F
06E0:  RLCF   x3B,W
06E2:  MOVWF  00
06E4:  RLCF   00,F
06E6:  RLCF   00,F
06E8:  MOVLW  F8
06EA:  ANDWF  00,F
06EC:  MOVF   00,W
06EE:  IORWF  x40,F
06F0:  RLCF   x3C,W
06F2:  MOVWF  00
06F4:  RLCF   00,F
06F6:  MOVLW  FC
06F8:  ANDWF  00,F
06FA:  MOVF   00,W
06FC:  IORWF  x40,F
06FE:  BCF    FD8.0
0700:  RLCF   x3D,W
0702:  IORWF  x40,F
0704:  MOVF   x3E,W
0706:  IORWF  x40,W
0708:  MOVWF  x3F
....................    return temp; 
070A:  MOVFF  93F,01
.................... } 
070E:  MOVLB  0
0710:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0712:  MOVLB  9
0714:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
0716:  MOVF   x22,F
0718:  BNZ   07EE
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
071A:  MOVF   x25,W
071C:  ADDWF  x23,W
071E:  MOVWF  FE9
0720:  MOVF   x26,W
0722:  ADDWFC x24,W
0724:  MOVWF  FEA
0726:  MOVFF  FEF,928
072A:  MOVLW  01
072C:  ADDWF  x23,W
072E:  MOVWF  x29
0730:  MOVLW  00
0732:  ADDWFC x24,W
0734:  MOVWF  x2A
0736:  MOVF   x25,W
0738:  ADDWF  x29,W
073A:  MOVWF  FE9
073C:  MOVF   x26,W
073E:  ADDWFC x2A,W
0740:  MOVWF  FEA
0742:  MOVF   FEF,W
0744:  XORWF  x28,F
0746:  MOVLW  02
0748:  ADDWF  x23,W
074A:  MOVWF  x2B
074C:  MOVLW  00
074E:  ADDWFC x24,W
0750:  MOVWF  x2C
0752:  MOVF   x25,W
0754:  ADDWF  x2B,W
0756:  MOVWF  FE9
0758:  MOVF   x26,W
075A:  ADDWFC x2C,W
075C:  MOVWF  FEA
075E:  MOVF   FEF,W
0760:  XORWF  x28,F
0762:  MOVLW  03
0764:  ADDWF  x23,W
0766:  MOVWF  x2D
0768:  MOVLW  00
076A:  ADDWFC x24,W
076C:  MOVWF  x2E
076E:  MOVF   x25,W
0770:  ADDWF  x2D,W
0772:  MOVWF  FE9
0774:  MOVF   x26,W
0776:  ADDWFC x2E,W
0778:  MOVWF  FEA
077A:  MOVF   FEF,W
077C:  XORWF  x28,F
077E:  MOVLW  04
0780:  ADDWF  x23,W
0782:  MOVWF  x2F
0784:  MOVLW  00
0786:  ADDWFC x24,W
0788:  MOVWF  x30
078A:  MOVF   x25,W
078C:  ADDWF  x2F,W
078E:  MOVWF  FE9
0790:  MOVF   x26,W
0792:  ADDWFC x30,W
0794:  MOVWF  FEA
0796:  MOVF   FEF,W
0798:  XORWF  x28,F
079A:  MOVLW  05
079C:  ADDWF  x23,W
079E:  MOVWF  x31
07A0:  MOVLW  00
07A2:  ADDWFC x24,W
07A4:  MOVWF  x32
07A6:  MOVF   x25,W
07A8:  ADDWF  x31,W
07AA:  MOVWF  FE9
07AC:  MOVF   x26,W
07AE:  ADDWFC x32,W
07B0:  MOVWF  FEA
07B2:  MOVF   FEF,W
07B4:  XORWF  x28,W
07B6:  BZ    07BC
07B8:  MOVLW  00
07BA:  BRA    07BE
07BC:  MOVLW  01
07BE:  MOVWF  x27
....................       if(temp==datain[offset+6]) return 1; 
07C0:  MOVLW  06
07C2:  ADDWF  x23,W
07C4:  MOVWF  x28
07C6:  MOVLW  00
07C8:  ADDWFC x24,W
07CA:  MOVWF  x29
07CC:  MOVF   x25,W
07CE:  ADDWF  x28,W
07D0:  MOVWF  FE9
07D2:  MOVF   x26,W
07D4:  ADDWFC x29,W
07D6:  MOVWF  FEA
07D8:  MOVF   FEF,W
07DA:  SUBWF  x27,W
07DC:  BNZ   07E6
07DE:  MOVLW  01
07E0:  MOVWF  01
07E2:  BRA    08BE
....................          else return 0; 
07E4:  BRA    07EC
07E6:  MOVLW  00
07E8:  MOVWF  01
07EA:  BRA    08BE
....................    } 
....................       else  
07EC:  BRA    08BE
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
07EE:  MOVF   x25,W
07F0:  ADDWF  x23,W
07F2:  MOVWF  FE9
07F4:  MOVF   x26,W
07F6:  ADDWFC x24,W
07F8:  MOVWF  FEA
07FA:  MOVFF  FEF,928
07FE:  MOVLW  01
0800:  SUBWF  x23,W
0802:  MOVWF  x29
0804:  MOVLW  00
0806:  SUBWFB x24,W
0808:  MOVWF  x2A
080A:  MOVF   x25,W
080C:  ADDWF  x29,W
080E:  MOVWF  FE9
0810:  MOVF   x26,W
0812:  ADDWFC x2A,W
0814:  MOVWF  FEA
0816:  MOVF   FEF,W
0818:  XORWF  x28,F
081A:  MOVLW  02
081C:  SUBWF  x23,W
081E:  MOVWF  x2B
0820:  MOVLW  00
0822:  SUBWFB x24,W
0824:  MOVWF  x2C
0826:  MOVF   x25,W
0828:  ADDWF  x2B,W
082A:  MOVWF  FE9
082C:  MOVF   x26,W
082E:  ADDWFC x2C,W
0830:  MOVWF  FEA
0832:  MOVF   FEF,W
0834:  XORWF  x28,F
0836:  MOVLW  03
0838:  SUBWF  x23,W
083A:  MOVWF  x2D
083C:  MOVLW  00
083E:  SUBWFB x24,W
0840:  MOVWF  x2E
0842:  MOVF   x25,W
0844:  ADDWF  x2D,W
0846:  MOVWF  FE9
0848:  MOVF   x26,W
084A:  ADDWFC x2E,W
084C:  MOVWF  FEA
084E:  MOVF   FEF,W
0850:  XORWF  x28,F
0852:  MOVLW  04
0854:  SUBWF  x23,W
0856:  MOVWF  x2F
0858:  MOVLW  00
085A:  SUBWFB x24,W
085C:  MOVWF  x30
085E:  MOVF   x25,W
0860:  ADDWF  x2F,W
0862:  MOVWF  FE9
0864:  MOVF   x26,W
0866:  ADDWFC x30,W
0868:  MOVWF  FEA
086A:  MOVF   FEF,W
086C:  XORWF  x28,F
086E:  MOVLW  05
0870:  SUBWF  x23,W
0872:  MOVWF  x31
0874:  MOVLW  00
0876:  SUBWFB x24,W
0878:  MOVWF  x32
087A:  MOVF   x25,W
087C:  ADDWF  x31,W
087E:  MOVWF  FE9
0880:  MOVF   x26,W
0882:  ADDWFC x32,W
0884:  MOVWF  FEA
0886:  MOVF   FEF,W
0888:  XORWF  x28,W
088A:  BZ    0890
088C:  MOVLW  00
088E:  BRA    0892
0890:  MOVLW  01
0892:  MOVWF  x27
....................          if(temp==datain[offset-6]) return 1; 
0894:  MOVLW  06
0896:  SUBWF  x23,W
0898:  MOVWF  x28
089A:  MOVLW  00
089C:  SUBWFB x24,W
089E:  MOVWF  x29
08A0:  MOVF   x25,W
08A2:  ADDWF  x28,W
08A4:  MOVWF  FE9
08A6:  MOVF   x26,W
08A8:  ADDWFC x29,W
08AA:  MOVWF  FEA
08AC:  MOVF   FEF,W
08AE:  SUBWF  x27,W
08B0:  BNZ   08BA
08B2:  MOVLW  01
08B4:  MOVWF  01
08B6:  BRA    08BE
....................             else return 0;          
08B8:  BRA    08BE
08BA:  MOVLW  00
08BC:  MOVWF  01
....................       } 
.................... } 
08BE:  MOVLB  0
08C0:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
08C2:  MOVLB  9
08C4:  CLRF   x27
....................    int8 temp=0; 
....................    if(direct==0) 
08C6:  MOVF   x22,F
08C8:  BNZ   0966
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
08CA:  MOVF   x25,W
08CC:  ADDWF  x23,W
08CE:  MOVWF  FE9
08D0:  MOVF   x26,W
08D2:  ADDWFC x24,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEF,928
08DA:  MOVLW  01
08DC:  ADDWF  x23,W
08DE:  MOVWF  x29
08E0:  MOVLW  00
08E2:  ADDWFC x24,W
08E4:  MOVWF  x2A
08E6:  MOVF   x25,W
08E8:  ADDWF  x29,W
08EA:  MOVWF  FE9
08EC:  MOVF   x26,W
08EE:  ADDWFC x2A,W
08F0:  MOVWF  FEA
08F2:  MOVF   FEF,W
08F4:  XORWF  x28,F
08F6:  MOVLW  02
08F8:  ADDWF  x23,W
08FA:  MOVWF  x2B
08FC:  MOVLW  00
08FE:  ADDWFC x24,W
0900:  MOVWF  x2C
0902:  MOVF   x25,W
0904:  ADDWF  x2B,W
0906:  MOVWF  FE9
0908:  MOVF   x26,W
090A:  ADDWFC x2C,W
090C:  MOVWF  FEA
090E:  MOVF   FEF,W
0910:  XORWF  x28,F
0912:  MOVLW  03
0914:  ADDWF  x23,W
0916:  MOVWF  x2D
0918:  MOVLW  00
091A:  ADDWFC x24,W
091C:  MOVWF  x2E
091E:  MOVF   x25,W
0920:  ADDWF  x2D,W
0922:  MOVWF  FE9
0924:  MOVF   x26,W
0926:  ADDWFC x2E,W
0928:  MOVWF  FEA
092A:  MOVF   FEF,W
092C:  XORWF  x28,W
092E:  BZ    0934
0930:  MOVLW  00
0932:  BRA    0936
0934:  MOVLW  01
0936:  MOVWF  x27
....................       if(temp==datain[offset+4]) return 1; 
0938:  MOVLW  04
093A:  ADDWF  x23,W
093C:  MOVWF  x28
093E:  MOVLW  00
0940:  ADDWFC x24,W
0942:  MOVWF  x29
0944:  MOVF   x25,W
0946:  ADDWF  x28,W
0948:  MOVWF  FE9
094A:  MOVF   x26,W
094C:  ADDWFC x29,W
094E:  MOVWF  FEA
0950:  MOVF   FEF,W
0952:  SUBWF  x27,W
0954:  BNZ   095E
0956:  MOVLW  01
0958:  MOVWF  01
095A:  BRA    09FE
....................          else return 0; 
095C:  BRA    0964
095E:  MOVLW  00
0960:  MOVWF  01
0962:  BRA    09FE
....................    } 
....................    else 
0964:  BRA    09FE
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0966:  MOVF   x25,W
0968:  ADDWF  x23,W
096A:  MOVWF  FE9
096C:  MOVF   x26,W
096E:  ADDWFC x24,W
0970:  MOVWF  FEA
0972:  MOVFF  FEF,928
0976:  MOVLW  01
0978:  SUBWF  x23,W
097A:  MOVWF  x29
097C:  MOVLW  00
097E:  SUBWFB x24,W
0980:  MOVWF  x2A
0982:  MOVF   x25,W
0984:  ADDWF  x29,W
0986:  MOVWF  FE9
0988:  MOVF   x26,W
098A:  ADDWFC x2A,W
098C:  MOVWF  FEA
098E:  MOVF   FEF,W
0990:  XORWF  x28,F
0992:  MOVLW  02
0994:  SUBWF  x23,W
0996:  MOVWF  x2B
0998:  MOVLW  00
099A:  SUBWFB x24,W
099C:  MOVWF  x2C
099E:  MOVF   x25,W
09A0:  ADDWF  x2B,W
09A2:  MOVWF  FE9
09A4:  MOVF   x26,W
09A6:  ADDWFC x2C,W
09A8:  MOVWF  FEA
09AA:  MOVF   FEF,W
09AC:  XORWF  x28,F
09AE:  MOVLW  03
09B0:  SUBWF  x23,W
09B2:  MOVWF  x2D
09B4:  MOVLW  00
09B6:  SUBWFB x24,W
09B8:  MOVWF  x2E
09BA:  MOVF   x25,W
09BC:  ADDWF  x2D,W
09BE:  MOVWF  FE9
09C0:  MOVF   x26,W
09C2:  ADDWFC x2E,W
09C4:  MOVWF  FEA
09C6:  MOVF   FEF,W
09C8:  XORWF  x28,W
09CA:  BZ    09D0
09CC:  MOVLW  00
09CE:  BRA    09D2
09D0:  MOVLW  01
09D2:  MOVWF  x27
....................       if(temp==datain[offset-4]) return 1; 
09D4:  MOVLW  04
09D6:  SUBWF  x23,W
09D8:  MOVWF  x28
09DA:  MOVLW  00
09DC:  SUBWFB x24,W
09DE:  MOVWF  x29
09E0:  MOVF   x25,W
09E2:  ADDWF  x28,W
09E4:  MOVWF  FE9
09E6:  MOVF   x26,W
09E8:  ADDWFC x29,W
09EA:  MOVWF  FEA
09EC:  MOVF   FEF,W
09EE:  SUBWF  x27,W
09F0:  BNZ   09FA
09F2:  MOVLW  01
09F4:  MOVWF  01
09F6:  BRA    09FE
....................          else return 0;                
09F8:  BRA    09FE
09FA:  MOVLW  00
09FC:  MOVWF  01
....................    } 
.................... } 
09FE:  MOVLB  0
0A00:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0A02:  MOVLB  9
0A04:  CLRF   x1E
0A06:  CLRF   x1F
0A08:  CLRF   x20
0A0A:  CLRF   x21
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0A0C:  CLRF   x1B
0A0E:  CLRF   x1A
0A10:  RRCF   x17,W
0A12:  MOVWF  03
0A14:  RRCF   x16,W
0A16:  MOVWF  02
0A18:  RRCF   03,F
0A1A:  RRCF   02,F
0A1C:  MOVLW  3F
0A1E:  ANDWF  03,F
0A20:  MOVFF  02,01
0A24:  MOVF   x1B,W
0A26:  SUBWF  03,W
0A28:  BTFSS  FD8.0
0A2A:  BRA    0FEA
0A2C:  BNZ   0A36
0A2E:  MOVF   01,W
0A30:  SUBWF  x1A,W
0A32:  BTFSC  FD8.0
0A34:  BRA    0FEA
....................    { 
....................       if(track==0) 
0A36:  MOVF   x15,F
0A38:  BTFSS  FD8.2
0A3A:  BRA    0D70
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0A3C:  MOVLW  06
0A3E:  ADDWF  x1A,W
0A40:  MOVWF  x22
0A42:  MOVLW  00
0A44:  ADDWFC x1B,W
0A46:  MOVWF  x23
0A48:  MOVF   x18,W
0A4A:  ADDWF  x22,W
0A4C:  MOVWF  FE9
0A4E:  MOVF   x19,W
0A50:  ADDWFC x23,W
0A52:  MOVWF  FEA
0A54:  MOVFF  FEF,924
0A58:  MOVLW  05
0A5A:  ADDWF  x1A,W
0A5C:  MOVWF  x25
0A5E:  MOVLW  00
0A60:  ADDWFC x1B,W
0A62:  MOVWF  x26
0A64:  MOVF   x18,W
0A66:  ADDWF  x25,W
0A68:  MOVWF  FE9
0A6A:  MOVF   x19,W
0A6C:  ADDWFC x26,W
0A6E:  MOVWF  FEA
0A70:  MOVFF  FEF,927
0A74:  MOVLW  04
0A76:  ADDWF  x1A,W
0A78:  MOVWF  x28
0A7A:  MOVLW  00
0A7C:  ADDWFC x1B,W
0A7E:  MOVWF  x29
0A80:  MOVF   x18,W
0A82:  ADDWF  x28,W
0A84:  MOVWF  FE9
0A86:  MOVF   x19,W
0A88:  ADDWFC x29,W
0A8A:  MOVWF  FEA
0A8C:  MOVFF  FEF,92A
0A90:  MOVLW  03
0A92:  ADDWF  x1A,W
0A94:  MOVWF  x2B
0A96:  MOVLW  00
0A98:  ADDWFC x1B,W
0A9A:  MOVWF  x2C
0A9C:  MOVF   x18,W
0A9E:  ADDWF  x2B,W
0AA0:  MOVWF  FE9
0AA2:  MOVF   x19,W
0AA4:  ADDWFC x2C,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEF,92D
0AAC:  MOVLW  02
0AAE:  ADDWF  x1A,W
0AB0:  MOVWF  x2E
0AB2:  MOVLW  00
0AB4:  ADDWFC x1B,W
0AB6:  MOVWF  x2F
0AB8:  MOVF   x18,W
0ABA:  ADDWF  x2E,W
0ABC:  MOVWF  FE9
0ABE:  MOVF   x19,W
0AC0:  ADDWFC x2F,W
0AC2:  MOVWF  FEA
0AC4:  MOVFF  FEF,930
0AC8:  MOVLW  01
0ACA:  ADDWF  x1A,W
0ACC:  MOVWF  x31
0ACE:  MOVLW  00
0AD0:  ADDWFC x1B,W
0AD2:  MOVWF  x32
0AD4:  MOVF   x18,W
0AD6:  ADDWF  x31,W
0AD8:  MOVWF  FE9
0ADA:  MOVF   x19,W
0ADC:  ADDWFC x32,W
0ADE:  MOVWF  FEA
0AE0:  MOVFF  FEF,933
0AE4:  MOVF   x18,W
0AE6:  ADDWF  x1A,W
0AE8:  MOVWF  FE9
0AEA:  MOVF   x19,W
0AEC:  ADDWFC x1B,W
0AEE:  MOVWF  FEA
0AF0:  MOVFF  FEF,934
0AF4:  CLRF   x37
0AF6:  MOVFF  924,938
0AFA:  MOVFF  927,939
0AFE:  MOVFF  92A,93A
0B02:  MOVFF  92D,93B
0B06:  MOVFF  930,93C
0B0A:  MOVFF  933,93D
0B0E:  MOVFF  934,93E
0B12:  MOVLB  0
0B14:  RCALL  06AC
0B16:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0B1A:  MOVLW  0D
0B1C:  MOVLB  9
0B1E:  ADDWF  x1A,W
0B20:  MOVWF  x22
0B22:  MOVLW  00
0B24:  ADDWFC x1B,W
0B26:  MOVWF  x23
0B28:  MOVF   x18,W
0B2A:  ADDWF  x22,W
0B2C:  MOVWF  FE9
0B2E:  MOVF   x19,W
0B30:  ADDWFC x23,W
0B32:  MOVWF  FEA
0B34:  MOVFF  FEF,924
0B38:  MOVLW  0C
0B3A:  ADDWF  x1A,W
0B3C:  MOVWF  x25
0B3E:  MOVLW  00
0B40:  ADDWFC x1B,W
0B42:  MOVWF  x26
0B44:  MOVF   x18,W
0B46:  ADDWF  x25,W
0B48:  MOVWF  FE9
0B4A:  MOVF   x19,W
0B4C:  ADDWFC x26,W
0B4E:  MOVWF  FEA
0B50:  MOVFF  FEF,927
0B54:  MOVLW  0B
0B56:  ADDWF  x1A,W
0B58:  MOVWF  x28
0B5A:  MOVLW  00
0B5C:  ADDWFC x1B,W
0B5E:  MOVWF  x29
0B60:  MOVF   x18,W
0B62:  ADDWF  x28,W
0B64:  MOVWF  FE9
0B66:  MOVF   x19,W
0B68:  ADDWFC x29,W
0B6A:  MOVWF  FEA
0B6C:  MOVFF  FEF,92A
0B70:  MOVLW  0A
0B72:  ADDWF  x1A,W
0B74:  MOVWF  x2B
0B76:  MOVLW  00
0B78:  ADDWFC x1B,W
0B7A:  MOVWF  x2C
0B7C:  MOVF   x18,W
0B7E:  ADDWF  x2B,W
0B80:  MOVWF  FE9
0B82:  MOVF   x19,W
0B84:  ADDWFC x2C,W
0B86:  MOVWF  FEA
0B88:  MOVFF  FEF,92D
0B8C:  MOVLW  09
0B8E:  ADDWF  x1A,W
0B90:  MOVWF  x2E
0B92:  MOVLW  00
0B94:  ADDWFC x1B,W
0B96:  MOVWF  x2F
0B98:  MOVF   x18,W
0B9A:  ADDWF  x2E,W
0B9C:  MOVWF  FE9
0B9E:  MOVF   x19,W
0BA0:  ADDWFC x2F,W
0BA2:  MOVWF  FEA
0BA4:  MOVFF  FEF,930
0BA8:  MOVLW  08
0BAA:  ADDWF  x1A,W
0BAC:  MOVWF  x31
0BAE:  MOVLW  00
0BB0:  ADDWFC x1B,W
0BB2:  MOVWF  x32
0BB4:  MOVF   x18,W
0BB6:  ADDWF  x31,W
0BB8:  MOVWF  FE9
0BBA:  MOVF   x19,W
0BBC:  ADDWFC x32,W
0BBE:  MOVWF  FEA
0BC0:  MOVFF  FEF,933
0BC4:  MOVLW  07
0BC6:  ADDWF  x1A,W
0BC8:  MOVWF  x34
0BCA:  MOVLW  00
0BCC:  ADDWFC x1B,W
0BCE:  MOVWF  x35
0BD0:  MOVF   x18,W
0BD2:  ADDWF  x34,W
0BD4:  MOVWF  FE9
0BD6:  MOVF   x19,W
0BD8:  ADDWFC x35,W
0BDA:  MOVWF  FEA
0BDC:  MOVFF  FEF,936
0BE0:  CLRF   x37
0BE2:  MOVFF  924,938
0BE6:  MOVFF  927,939
0BEA:  MOVFF  92A,93A
0BEE:  MOVFF  92D,93B
0BF2:  MOVFF  930,93C
0BF6:  MOVFF  933,93D
0BFA:  MOVFF  936,93E
0BFE:  MOVLB  0
0C00:  RCALL  06AC
0C02:  MOVFF  01,91F
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0C06:  MOVLB  9
0C08:  MOVF   x1E,W
0C0A:  SUBLW  45
0C0C:  BTFSS  FD8.2
0C0E:  BRA    0D6E
0C10:  MOVF   x1F,W
0C12:  SUBLW  7C
0C14:  BTFSC  FD8.2
0C16:  BRA    0D6E
0C18:  MOVF   x1F,W
0C1A:  SUBLW  3E
0C1C:  BTFSC  FD8.2
0C1E:  BRA    0D6E
0C20:  MOVF   x1F,W
0C22:  SUBLW  1F
0C24:  BTFSC  FD8.2
0C26:  BRA    0D6E
....................          { 
....................             j=i; 
0C28:  MOVFF  91B,91D
0C2C:  MOVFF  91A,91C
....................             CRC=1; 
0C30:  MOVLW  01
0C32:  MOVWF  x21
....................             temp2=temp; 
0C34:  MOVFF  91E,920
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0C38:  MOVF   x20,W
0C3A:  SUBLW  1F
0C3C:  BTFSC  FD8.2
0C3E:  BRA    0D58
0C40:  MOVF   x1D,W
0C42:  SUBLW  03
0C44:  BTFSS  FD8.0
0C46:  BRA    0D58
0C48:  BNZ   0C52
0C4A:  MOVF   x1C,W
0C4C:  SUBLW  E7
0C4E:  BTFSS  FD8.0
0C50:  BRA    0D58
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C52:  CLRF   x22
0C54:  MOVFF  91D,924
0C58:  MOVFF  91C,923
0C5C:  MOVFF  919,926
0C60:  MOVFF  918,925
0C64:  MOVLB  0
0C66:  RCALL  0712
0C68:  MOVF   01,W
0C6A:  MOVLB  9
0C6C:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C6E:  MOVLW  06
0C70:  ADDWF  x1C,W
0C72:  MOVWF  x22
0C74:  MOVLW  00
0C76:  ADDWFC x1D,W
0C78:  MOVWF  x23
0C7A:  MOVF   x18,W
0C7C:  ADDWF  x22,W
0C7E:  MOVWF  FE9
0C80:  MOVF   x19,W
0C82:  ADDWFC x23,W
0C84:  MOVWF  FEA
0C86:  MOVFF  FEF,924
0C8A:  MOVLW  05
0C8C:  ADDWF  x1C,W
0C8E:  MOVWF  x25
0C90:  MOVLW  00
0C92:  ADDWFC x1D,W
0C94:  MOVWF  x26
0C96:  MOVF   x18,W
0C98:  ADDWF  x25,W
0C9A:  MOVWF  FE9
0C9C:  MOVF   x19,W
0C9E:  ADDWFC x26,W
0CA0:  MOVWF  FEA
0CA2:  MOVFF  FEF,927
0CA6:  MOVLW  04
0CA8:  ADDWF  x1C,W
0CAA:  MOVWF  x28
0CAC:  MOVLW  00
0CAE:  ADDWFC x1D,W
0CB0:  MOVWF  x29
0CB2:  MOVF   x18,W
0CB4:  ADDWF  x28,W
0CB6:  MOVWF  FE9
0CB8:  MOVF   x19,W
0CBA:  ADDWFC x29,W
0CBC:  MOVWF  FEA
0CBE:  MOVFF  FEF,92A
0CC2:  MOVLW  03
0CC4:  ADDWF  x1C,W
0CC6:  MOVWF  x2B
0CC8:  MOVLW  00
0CCA:  ADDWFC x1D,W
0CCC:  MOVWF  x2C
0CCE:  MOVF   x18,W
0CD0:  ADDWF  x2B,W
0CD2:  MOVWF  FE9
0CD4:  MOVF   x19,W
0CD6:  ADDWFC x2C,W
0CD8:  MOVWF  FEA
0CDA:  MOVFF  FEF,92D
0CDE:  MOVLW  02
0CE0:  ADDWF  x1C,W
0CE2:  MOVWF  x2E
0CE4:  MOVLW  00
0CE6:  ADDWFC x1D,W
0CE8:  MOVWF  x2F
0CEA:  MOVF   x18,W
0CEC:  ADDWF  x2E,W
0CEE:  MOVWF  FE9
0CF0:  MOVF   x19,W
0CF2:  ADDWFC x2F,W
0CF4:  MOVWF  FEA
0CF6:  MOVFF  FEF,930
0CFA:  MOVLW  01
0CFC:  ADDWF  x1C,W
0CFE:  MOVWF  x31
0D00:  MOVLW  00
0D02:  ADDWFC x1D,W
0D04:  MOVWF  x32
0D06:  MOVF   x18,W
0D08:  ADDWF  x31,W
0D0A:  MOVWF  FE9
0D0C:  MOVF   x19,W
0D0E:  ADDWFC x32,W
0D10:  MOVWF  FEA
0D12:  MOVFF  FEF,933
0D16:  MOVF   x18,W
0D18:  ADDWF  x1C,W
0D1A:  MOVWF  FE9
0D1C:  MOVF   x19,W
0D1E:  ADDWFC x1D,W
0D20:  MOVWF  FEA
0D22:  MOVFF  FEF,934
0D26:  CLRF   x37
0D28:  MOVFF  924,938
0D2C:  MOVFF  927,939
0D30:  MOVFF  92A,93A
0D34:  MOVFF  92D,93B
0D38:  MOVFF  930,93C
0D3C:  MOVFF  933,93D
0D40:  MOVFF  934,93E
0D44:  MOVLB  0
0D46:  RCALL  06AC
0D48:  MOVFF  01,920
....................                j=j+7; 
0D4C:  MOVLW  07
0D4E:  MOVLB  9
0D50:  ADDWF  x1C,F
0D52:  MOVLW  00
0D54:  ADDWFC x1D,F
....................             } 
0D56:  BRA    0C38
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D58:  DECFSZ x21,W
0D5A:  BRA    0D6E
....................             { 
....................                dir=0; 
0D5C:  MOVLB  6
0D5E:  CLRF   xC8
....................                return i; 
0D60:  MOVLB  9
0D62:  MOVFF  91A,01
0D66:  MOVFF  91B,02
0D6A:  GOTO   1600
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0D6E:  BRA    0FE2
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0D70:  MOVLW  04
0D72:  ADDWF  x1A,W
0D74:  MOVWF  x22
0D76:  MOVLW  00
0D78:  ADDWFC x1B,W
0D7A:  MOVWF  x23
0D7C:  MOVF   x18,W
0D7E:  ADDWF  x22,W
0D80:  MOVWF  FE9
0D82:  MOVF   x19,W
0D84:  ADDWFC x23,W
0D86:  MOVWF  FEA
0D88:  MOVFF  FEF,924
0D8C:  MOVLW  03
0D8E:  ADDWF  x1A,W
0D90:  MOVWF  x25
0D92:  MOVLW  00
0D94:  ADDWFC x1B,W
0D96:  MOVWF  x26
0D98:  MOVF   x18,W
0D9A:  ADDWF  x25,W
0D9C:  MOVWF  FE9
0D9E:  MOVF   x19,W
0DA0:  ADDWFC x26,W
0DA2:  MOVWF  FEA
0DA4:  MOVFF  FEF,927
0DA8:  MOVLW  02
0DAA:  ADDWF  x1A,W
0DAC:  MOVWF  x28
0DAE:  MOVLW  00
0DB0:  ADDWFC x1B,W
0DB2:  MOVWF  x29
0DB4:  MOVF   x18,W
0DB6:  ADDWF  x28,W
0DB8:  MOVWF  FE9
0DBA:  MOVF   x19,W
0DBC:  ADDWFC x29,W
0DBE:  MOVWF  FEA
0DC0:  MOVFF  FEF,92A
0DC4:  MOVLW  01
0DC6:  ADDWF  x1A,W
0DC8:  MOVWF  x2B
0DCA:  MOVLW  00
0DCC:  ADDWFC x1B,W
0DCE:  MOVWF  x2C
0DD0:  MOVF   x18,W
0DD2:  ADDWF  x2B,W
0DD4:  MOVWF  FE9
0DD6:  MOVF   x19,W
0DD8:  ADDWFC x2C,W
0DDA:  MOVWF  FEA
0DDC:  MOVFF  FEF,92D
0DE0:  MOVF   x18,W
0DE2:  ADDWF  x1A,W
0DE4:  MOVWF  FE9
0DE6:  MOVF   x19,W
0DE8:  ADDWFC x1B,W
0DEA:  MOVWF  FEA
0DEC:  MOVFF  FEF,92E
0DF0:  CLRF   x37
0DF2:  CLRF   x38
0DF4:  CLRF   x39
0DF6:  MOVFF  924,93A
0DFA:  MOVFF  927,93B
0DFE:  MOVFF  92A,93C
0E02:  MOVFF  92D,93D
0E06:  MOVFF  92E,93E
0E0A:  MOVLB  0
0E0C:  RCALL  06AC
0E0E:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0E12:  MOVLW  09
0E14:  MOVLB  9
0E16:  ADDWF  x1A,W
0E18:  MOVWF  x22
0E1A:  MOVLW  00
0E1C:  ADDWFC x1B,W
0E1E:  MOVWF  x23
0E20:  MOVF   x18,W
0E22:  ADDWF  x22,W
0E24:  MOVWF  FE9
0E26:  MOVF   x19,W
0E28:  ADDWFC x23,W
0E2A:  MOVWF  FEA
0E2C:  MOVFF  FEF,924
0E30:  MOVLW  08
0E32:  ADDWF  x1A,W
0E34:  MOVWF  x25
0E36:  MOVLW  00
0E38:  ADDWFC x1B,W
0E3A:  MOVWF  x26
0E3C:  MOVF   x18,W
0E3E:  ADDWF  x25,W
0E40:  MOVWF  FE9
0E42:  MOVF   x19,W
0E44:  ADDWFC x26,W
0E46:  MOVWF  FEA
0E48:  MOVFF  FEF,927
0E4C:  MOVLW  07
0E4E:  ADDWF  x1A,W
0E50:  MOVWF  x28
0E52:  MOVLW  00
0E54:  ADDWFC x1B,W
0E56:  MOVWF  x29
0E58:  MOVF   x18,W
0E5A:  ADDWF  x28,W
0E5C:  MOVWF  FE9
0E5E:  MOVF   x19,W
0E60:  ADDWFC x29,W
0E62:  MOVWF  FEA
0E64:  MOVFF  FEF,92A
0E68:  MOVLW  06
0E6A:  ADDWF  x1A,W
0E6C:  MOVWF  x2B
0E6E:  MOVLW  00
0E70:  ADDWFC x1B,W
0E72:  MOVWF  x2C
0E74:  MOVF   x18,W
0E76:  ADDWF  x2B,W
0E78:  MOVWF  FE9
0E7A:  MOVF   x19,W
0E7C:  ADDWFC x2C,W
0E7E:  MOVWF  FEA
0E80:  MOVFF  FEF,92D
0E84:  MOVLW  05
0E86:  ADDWF  x1A,W
0E88:  MOVWF  x2E
0E8A:  MOVLW  00
0E8C:  ADDWFC x1B,W
0E8E:  MOVWF  x2F
0E90:  MOVF   x18,W
0E92:  ADDWF  x2E,W
0E94:  MOVWF  FE9
0E96:  MOVF   x19,W
0E98:  ADDWFC x2F,W
0E9A:  MOVWF  FEA
0E9C:  MOVFF  FEF,930
0EA0:  CLRF   x37
0EA2:  CLRF   x38
0EA4:  CLRF   x39
0EA6:  MOVFF  924,93A
0EAA:  MOVFF  927,93B
0EAE:  MOVFF  92A,93C
0EB2:  MOVFF  92D,93D
0EB6:  MOVFF  930,93E
0EBA:  MOVLB  0
0EBC:  CALL   06AC
0EC0:  MOVFF  01,91F
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0EC4:  MOVLB  9
0EC6:  MOVF   x1E,W
0EC8:  SUBLW  0B
0ECA:  BTFSS  FD8.2
0ECC:  BRA    0FE2
0ECE:  MOVF   x1F,W
0ED0:  SUBLW  1F
0ED2:  BTFSC  FD8.2
0ED4:  BRA    0FE2
0ED6:  MOVF   x1F,W
0ED8:  SUBLW  0F
0EDA:  BTFSC  FD8.2
0EDC:  BRA    0FE2
....................             { 
....................                j=i; 
0EDE:  MOVFF  91B,91D
0EE2:  MOVFF  91A,91C
....................                CRC=1; 
0EE6:  MOVLW  01
0EE8:  MOVWF  x21
....................                temp2=temp; 
0EEA:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0EEE:  MOVF   x20,W
0EF0:  SUBLW  1F
0EF2:  BZ    0FCE
0EF4:  MOVF   x1D,W
0EF6:  SUBLW  01
0EF8:  BNC   0FCE
0EFA:  BNZ   0F02
0EFC:  MOVF   x1C,W
0EFE:  SUBLW  F3
0F00:  BNC   0FCE
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0F02:  CLRF   x22
0F04:  MOVFF  91D,924
0F08:  MOVFF  91C,923
0F0C:  MOVFF  919,926
0F10:  MOVFF  918,925
0F14:  MOVLB  0
0F16:  RCALL  08C2
0F18:  MOVF   01,W
0F1A:  MOVLB  9
0F1C:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0F1E:  MOVLW  04
0F20:  ADDWF  x1C,W
0F22:  MOVWF  x22
0F24:  MOVLW  00
0F26:  ADDWFC x1D,W
0F28:  MOVWF  x23
0F2A:  MOVF   x18,W
0F2C:  ADDWF  x22,W
0F2E:  MOVWF  FE9
0F30:  MOVF   x19,W
0F32:  ADDWFC x23,W
0F34:  MOVWF  FEA
0F36:  MOVFF  FEF,924
0F3A:  MOVLW  03
0F3C:  ADDWF  x1C,W
0F3E:  MOVWF  x25
0F40:  MOVLW  00
0F42:  ADDWFC x1D,W
0F44:  MOVWF  x26
0F46:  MOVF   x18,W
0F48:  ADDWF  x25,W
0F4A:  MOVWF  FE9
0F4C:  MOVF   x19,W
0F4E:  ADDWFC x26,W
0F50:  MOVWF  FEA
0F52:  MOVFF  FEF,927
0F56:  MOVLW  02
0F58:  ADDWF  x1C,W
0F5A:  MOVWF  x28
0F5C:  MOVLW  00
0F5E:  ADDWFC x1D,W
0F60:  MOVWF  x29
0F62:  MOVF   x18,W
0F64:  ADDWF  x28,W
0F66:  MOVWF  FE9
0F68:  MOVF   x19,W
0F6A:  ADDWFC x29,W
0F6C:  MOVWF  FEA
0F6E:  MOVFF  FEF,92A
0F72:  MOVLW  01
0F74:  ADDWF  x1C,W
0F76:  MOVWF  x2B
0F78:  MOVLW  00
0F7A:  ADDWFC x1D,W
0F7C:  MOVWF  x2C
0F7E:  MOVF   x18,W
0F80:  ADDWF  x2B,W
0F82:  MOVWF  FE9
0F84:  MOVF   x19,W
0F86:  ADDWFC x2C,W
0F88:  MOVWF  FEA
0F8A:  MOVFF  FEF,92D
0F8E:  MOVF   x18,W
0F90:  ADDWF  x1C,W
0F92:  MOVWF  FE9
0F94:  MOVF   x19,W
0F96:  ADDWFC x1D,W
0F98:  MOVWF  FEA
0F9A:  MOVFF  FEF,92E
0F9E:  CLRF   x37
0FA0:  CLRF   x38
0FA2:  CLRF   x39
0FA4:  MOVFF  924,93A
0FA8:  MOVFF  927,93B
0FAC:  MOVFF  92A,93C
0FB0:  MOVFF  92D,93D
0FB4:  MOVFF  92E,93E
0FB8:  MOVLB  0
0FBA:  CALL   06AC
0FBE:  MOVFF  01,920
....................                   j=j+5; 
0FC2:  MOVLW  05
0FC4:  MOVLB  9
0FC6:  ADDWF  x1C,F
0FC8:  MOVLW  00
0FCA:  ADDWFC x1D,F
....................                } 
0FCC:  BRA    0EEE
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0FCE:  DECFSZ x21,W
0FD0:  BRA    0FE2
....................                { 
....................                   dir=0; 
0FD2:  MOVLB  6
0FD4:  CLRF   xC8
....................                   return i; 
0FD6:  MOVLB  9
0FD8:  MOVFF  91A,01
0FDC:  MOVFF  91B,02
0FE0:  BRA    1600
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0FE2:  INCF   x1A,F
0FE4:  BTFSC  FD8.2
0FE6:  INCF   x1B,F
0FE8:  BRA    0A10
....................    for(i=end_point;i>end_point/4;i--) 
0FEA:  MOVFF  917,91B
0FEE:  MOVFF  916,91A
0FF2:  RRCF   x17,W
0FF4:  MOVWF  03
0FF6:  RRCF   x16,W
0FF8:  MOVWF  02
0FFA:  RRCF   03,F
0FFC:  RRCF   02,F
0FFE:  MOVLW  3F
1000:  ANDWF  03,F
1002:  MOVFF  02,01
1006:  MOVF   03,W
1008:  SUBWF  x1B,W
100A:  BTFSS  FD8.0
100C:  BRA    15FA
100E:  BNZ   1018
1010:  MOVF   x1A,W
1012:  SUBWF  01,W
1014:  BTFSC  FD8.0
1016:  BRA    15FA
....................    { 
....................       if(track==0) 
1018:  MOVF   x15,F
101A:  BTFSS  FD8.2
101C:  BRA    1370
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
101E:  MOVLW  06
1020:  SUBWF  x1A,W
1022:  MOVWF  x22
1024:  MOVLW  00
1026:  SUBWFB x1B,W
1028:  MOVWF  x23
102A:  MOVF   x18,W
102C:  ADDWF  x22,W
102E:  MOVWF  FE9
1030:  MOVF   x19,W
1032:  ADDWFC x23,W
1034:  MOVWF  FEA
1036:  MOVFF  FEF,924
103A:  MOVLW  05
103C:  SUBWF  x1A,W
103E:  MOVWF  x25
1040:  MOVLW  00
1042:  SUBWFB x1B,W
1044:  MOVWF  x26
1046:  MOVF   x18,W
1048:  ADDWF  x25,W
104A:  MOVWF  FE9
104C:  MOVF   x19,W
104E:  ADDWFC x26,W
1050:  MOVWF  FEA
1052:  MOVFF  FEF,927
1056:  MOVLW  04
1058:  SUBWF  x1A,W
105A:  MOVWF  x28
105C:  MOVLW  00
105E:  SUBWFB x1B,W
1060:  MOVWF  x29
1062:  MOVF   x18,W
1064:  ADDWF  x28,W
1066:  MOVWF  FE9
1068:  MOVF   x19,W
106A:  ADDWFC x29,W
106C:  MOVWF  FEA
106E:  MOVFF  FEF,92A
1072:  MOVLW  03
1074:  SUBWF  x1A,W
1076:  MOVWF  x2B
1078:  MOVLW  00
107A:  SUBWFB x1B,W
107C:  MOVWF  x2C
107E:  MOVF   x18,W
1080:  ADDWF  x2B,W
1082:  MOVWF  FE9
1084:  MOVF   x19,W
1086:  ADDWFC x2C,W
1088:  MOVWF  FEA
108A:  MOVFF  FEF,92D
108E:  MOVLW  02
1090:  SUBWF  x1A,W
1092:  MOVWF  x2E
1094:  MOVLW  00
1096:  SUBWFB x1B,W
1098:  MOVWF  x2F
109A:  MOVF   x18,W
109C:  ADDWF  x2E,W
109E:  MOVWF  FE9
10A0:  MOVF   x19,W
10A2:  ADDWFC x2F,W
10A4:  MOVWF  FEA
10A6:  MOVFF  FEF,930
10AA:  MOVLW  01
10AC:  SUBWF  x1A,W
10AE:  MOVWF  x31
10B0:  MOVLW  00
10B2:  SUBWFB x1B,W
10B4:  MOVWF  x32
10B6:  MOVF   x18,W
10B8:  ADDWF  x31,W
10BA:  MOVWF  FE9
10BC:  MOVF   x19,W
10BE:  ADDWFC x32,W
10C0:  MOVWF  FEA
10C2:  MOVFF  FEF,933
10C6:  MOVF   x18,W
10C8:  ADDWF  x1A,W
10CA:  MOVWF  FE9
10CC:  MOVF   x19,W
10CE:  ADDWFC x1B,W
10D0:  MOVWF  FEA
10D2:  MOVFF  FEF,934
10D6:  CLRF   x37
10D8:  MOVFF  924,938
10DC:  MOVFF  927,939
10E0:  MOVFF  92A,93A
10E4:  MOVFF  92D,93B
10E8:  MOVFF  930,93C
10EC:  MOVFF  933,93D
10F0:  MOVFF  934,93E
10F4:  MOVLB  0
10F6:  CALL   06AC
10FA:  MOVFF  01,91E
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
10FE:  MOVLW  0D
1100:  MOVLB  9
1102:  SUBWF  x1A,W
1104:  MOVWF  x22
1106:  MOVLW  00
1108:  SUBWFB x1B,W
110A:  MOVWF  x23
110C:  MOVF   x18,W
110E:  ADDWF  x22,W
1110:  MOVWF  FE9
1112:  MOVF   x19,W
1114:  ADDWFC x23,W
1116:  MOVWF  FEA
1118:  MOVFF  FEF,924
111C:  MOVLW  0C
111E:  SUBWF  x1A,W
1120:  MOVWF  x25
1122:  MOVLW  00
1124:  SUBWFB x1B,W
1126:  MOVWF  x26
1128:  MOVF   x18,W
112A:  ADDWF  x25,W
112C:  MOVWF  FE9
112E:  MOVF   x19,W
1130:  ADDWFC x26,W
1132:  MOVWF  FEA
1134:  MOVFF  FEF,927
1138:  MOVLW  0B
113A:  SUBWF  x1A,W
113C:  MOVWF  x28
113E:  MOVLW  00
1140:  SUBWFB x1B,W
1142:  MOVWF  x29
1144:  MOVF   x18,W
1146:  ADDWF  x28,W
1148:  MOVWF  FE9
114A:  MOVF   x19,W
114C:  ADDWFC x29,W
114E:  MOVWF  FEA
1150:  MOVFF  FEF,92A
1154:  MOVLW  0A
1156:  SUBWF  x1A,W
1158:  MOVWF  x2B
115A:  MOVLW  00
115C:  SUBWFB x1B,W
115E:  MOVWF  x2C
1160:  MOVF   x18,W
1162:  ADDWF  x2B,W
1164:  MOVWF  FE9
1166:  MOVF   x19,W
1168:  ADDWFC x2C,W
116A:  MOVWF  FEA
116C:  MOVFF  FEF,92D
1170:  MOVLW  09
1172:  SUBWF  x1A,W
1174:  MOVWF  x2E
1176:  MOVLW  00
1178:  SUBWFB x1B,W
117A:  MOVWF  x2F
117C:  MOVF   x18,W
117E:  ADDWF  x2E,W
1180:  MOVWF  FE9
1182:  MOVF   x19,W
1184:  ADDWFC x2F,W
1186:  MOVWF  FEA
1188:  MOVFF  FEF,930
118C:  MOVLW  08
118E:  SUBWF  x1A,W
1190:  MOVWF  x31
1192:  MOVLW  00
1194:  SUBWFB x1B,W
1196:  MOVWF  x32
1198:  MOVF   x18,W
119A:  ADDWF  x31,W
119C:  MOVWF  FE9
119E:  MOVF   x19,W
11A0:  ADDWFC x32,W
11A2:  MOVWF  FEA
11A4:  MOVFF  FEF,933
11A8:  MOVLW  07
11AA:  SUBWF  x1A,W
11AC:  MOVWF  x34
11AE:  MOVLW  00
11B0:  SUBWFB x1B,W
11B2:  MOVWF  x35
11B4:  MOVF   x18,W
11B6:  ADDWF  x34,W
11B8:  MOVWF  FE9
11BA:  MOVF   x19,W
11BC:  ADDWFC x35,W
11BE:  MOVWF  FEA
11C0:  MOVFF  FEF,936
11C4:  CLRF   x37
11C6:  MOVFF  924,938
11CA:  MOVFF  927,939
11CE:  MOVFF  92A,93A
11D2:  MOVFF  92D,93B
11D6:  MOVFF  930,93C
11DA:  MOVFF  933,93D
11DE:  MOVFF  936,93E
11E2:  MOVLB  0
11E4:  CALL   06AC
11E8:  MOVFF  01,91F
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
11EC:  MOVLB  9
11EE:  MOVF   x1E,W
11F0:  SUBLW  45
11F2:  BTFSS  FD8.2
11F4:  BRA    136E
11F6:  MOVF   x1F,W
11F8:  SUBLW  7C
11FA:  BTFSC  FD8.2
11FC:  BRA    136E
11FE:  MOVF   x1F,W
1200:  SUBLW  3E
1202:  BTFSC  FD8.2
1204:  BRA    136E
1206:  MOVF   x1F,W
1208:  SUBLW  1F
120A:  BTFSC  FD8.2
120C:  BRA    136E
120E:  MOVF   x1F,W
1210:  SUBLW  0F
1212:  BTFSC  FD8.2
1214:  BRA    136E
1216:  MOVF   x1F,W
1218:  SUBLW  78
121A:  BTFSC  FD8.2
121C:  BRA    136E
....................          { 
....................             j=i; 
121E:  MOVFF  91B,91D
1222:  MOVFF  91A,91C
....................             CRC=1; 
1226:  MOVLW  01
1228:  MOVWF  x21
....................             temp2=temp; 
122A:  MOVFF  91E,920
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
122E:  MOVF   x20,W
1230:  SUBLW  1F
1232:  BTFSC  FD8.2
1234:  BRA    134E
1236:  MOVF   x1D,F
1238:  BNZ   1242
123A:  MOVF   x1C,W
123C:  SUBLW  01
123E:  BTFSC  FD8.0
1240:  BRA    134E
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1242:  MOVLW  01
1244:  MOVWF  x22
1246:  MOVFF  91D,924
124A:  MOVFF  91C,923
124E:  MOVFF  919,926
1252:  MOVFF  918,925
1256:  MOVLB  0
1258:  CALL   0712
125C:  MOVF   01,W
125E:  MOVLB  9
1260:  ANDWF  x21,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1262:  MOVLW  06
1264:  SUBWF  x1C,W
1266:  MOVWF  x22
1268:  MOVLW  00
126A:  SUBWFB x1D,W
126C:  MOVWF  x23
126E:  MOVF   x18,W
1270:  ADDWF  x22,W
1272:  MOVWF  FE9
1274:  MOVF   x19,W
1276:  ADDWFC x23,W
1278:  MOVWF  FEA
127A:  MOVFF  FEF,924
127E:  MOVLW  05
1280:  SUBWF  x1C,W
1282:  MOVWF  x25
1284:  MOVLW  00
1286:  SUBWFB x1D,W
1288:  MOVWF  x26
128A:  MOVF   x18,W
128C:  ADDWF  x25,W
128E:  MOVWF  FE9
1290:  MOVF   x19,W
1292:  ADDWFC x26,W
1294:  MOVWF  FEA
1296:  MOVFF  FEF,927
129A:  MOVLW  04
129C:  SUBWF  x1C,W
129E:  MOVWF  x28
12A0:  MOVLW  00
12A2:  SUBWFB x1D,W
12A4:  MOVWF  x29
12A6:  MOVF   x18,W
12A8:  ADDWF  x28,W
12AA:  MOVWF  FE9
12AC:  MOVF   x19,W
12AE:  ADDWFC x29,W
12B0:  MOVWF  FEA
12B2:  MOVFF  FEF,92A
12B6:  MOVLW  03
12B8:  SUBWF  x1C,W
12BA:  MOVWF  x2B
12BC:  MOVLW  00
12BE:  SUBWFB x1D,W
12C0:  MOVWF  x2C
12C2:  MOVF   x18,W
12C4:  ADDWF  x2B,W
12C6:  MOVWF  FE9
12C8:  MOVF   x19,W
12CA:  ADDWFC x2C,W
12CC:  MOVWF  FEA
12CE:  MOVFF  FEF,92D
12D2:  MOVLW  02
12D4:  SUBWF  x1C,W
12D6:  MOVWF  x2E
12D8:  MOVLW  00
12DA:  SUBWFB x1D,W
12DC:  MOVWF  x2F
12DE:  MOVF   x18,W
12E0:  ADDWF  x2E,W
12E2:  MOVWF  FE9
12E4:  MOVF   x19,W
12E6:  ADDWFC x2F,W
12E8:  MOVWF  FEA
12EA:  MOVFF  FEF,930
12EE:  MOVLW  01
12F0:  SUBWF  x1C,W
12F2:  MOVWF  x31
12F4:  MOVLW  00
12F6:  SUBWFB x1D,W
12F8:  MOVWF  x32
12FA:  MOVF   x18,W
12FC:  ADDWF  x31,W
12FE:  MOVWF  FE9
1300:  MOVF   x19,W
1302:  ADDWFC x32,W
1304:  MOVWF  FEA
1306:  MOVFF  FEF,933
130A:  MOVF   x18,W
130C:  ADDWF  x1C,W
130E:  MOVWF  FE9
1310:  MOVF   x19,W
1312:  ADDWFC x1D,W
1314:  MOVWF  FEA
1316:  MOVFF  FEF,934
131A:  CLRF   x37
131C:  MOVFF  924,938
1320:  MOVFF  927,939
1324:  MOVFF  92A,93A
1328:  MOVFF  92D,93B
132C:  MOVFF  930,93C
1330:  MOVFF  933,93D
1334:  MOVFF  934,93E
1338:  MOVLB  0
133A:  CALL   06AC
133E:  MOVFF  01,920
....................                j=j-7;             
1342:  MOVLW  07
1344:  MOVLB  9
1346:  SUBWF  x1C,F
1348:  MOVLW  00
134A:  SUBWFB x1D,F
....................              } 
134C:  BRA    122E
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
134E:  DECFSZ x21,W
1350:  BRA    1366
....................             { 
....................                dir=1; 
1352:  MOVLW  01
1354:  MOVLB  6
1356:  MOVWF  xC8
....................                return i; 
1358:  MOVLB  9
135A:  MOVFF  91A,01
135E:  MOVFF  91B,02
1362:  BRA    1600
....................             } 
....................             else return 0; 
1364:  BRA    136E
1366:  MOVLW  00
1368:  MOVWF  01
136A:  MOVWF  02
136C:  BRA    1600
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
136E:  BRA    15F0
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1370:  MOVLW  04
1372:  SUBWF  x1A,W
1374:  MOVWF  x22
1376:  MOVLW  00
1378:  SUBWFB x1B,W
137A:  MOVWF  x23
137C:  MOVF   x18,W
137E:  ADDWF  x22,W
1380:  MOVWF  FE9
1382:  MOVF   x19,W
1384:  ADDWFC x23,W
1386:  MOVWF  FEA
1388:  MOVFF  FEF,924
138C:  MOVLW  03
138E:  SUBWF  x1A,W
1390:  MOVWF  x25
1392:  MOVLW  00
1394:  SUBWFB x1B,W
1396:  MOVWF  x26
1398:  MOVF   x18,W
139A:  ADDWF  x25,W
139C:  MOVWF  FE9
139E:  MOVF   x19,W
13A0:  ADDWFC x26,W
13A2:  MOVWF  FEA
13A4:  MOVFF  FEF,927
13A8:  MOVLW  02
13AA:  SUBWF  x1A,W
13AC:  MOVWF  x28
13AE:  MOVLW  00
13B0:  SUBWFB x1B,W
13B2:  MOVWF  x29
13B4:  MOVF   x18,W
13B6:  ADDWF  x28,W
13B8:  MOVWF  FE9
13BA:  MOVF   x19,W
13BC:  ADDWFC x29,W
13BE:  MOVWF  FEA
13C0:  MOVFF  FEF,92A
13C4:  MOVLW  01
13C6:  SUBWF  x1A,W
13C8:  MOVWF  x2B
13CA:  MOVLW  00
13CC:  SUBWFB x1B,W
13CE:  MOVWF  x2C
13D0:  MOVF   x18,W
13D2:  ADDWF  x2B,W
13D4:  MOVWF  FE9
13D6:  MOVF   x19,W
13D8:  ADDWFC x2C,W
13DA:  MOVWF  FEA
13DC:  MOVFF  FEF,92D
13E0:  MOVF   x18,W
13E2:  ADDWF  x1A,W
13E4:  MOVWF  FE9
13E6:  MOVF   x19,W
13E8:  ADDWFC x1B,W
13EA:  MOVWF  FEA
13EC:  MOVFF  FEF,92E
13F0:  CLRF   x37
13F2:  CLRF   x38
13F4:  CLRF   x39
13F6:  MOVFF  924,93A
13FA:  MOVFF  927,93B
13FE:  MOVFF  92A,93C
1402:  MOVFF  92D,93D
1406:  MOVFF  92E,93E
140A:  MOVLB  0
140C:  CALL   06AC
1410:  MOVFF  01,91E
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1414:  MOVLW  09
1416:  MOVLB  9
1418:  SUBWF  x1A,W
141A:  MOVWF  x22
141C:  MOVLW  00
141E:  SUBWFB x1B,W
1420:  MOVWF  x23
1422:  MOVF   x18,W
1424:  ADDWF  x22,W
1426:  MOVWF  FE9
1428:  MOVF   x19,W
142A:  ADDWFC x23,W
142C:  MOVWF  FEA
142E:  MOVFF  FEF,924
1432:  MOVLW  08
1434:  SUBWF  x1A,W
1436:  MOVWF  x25
1438:  MOVLW  00
143A:  SUBWFB x1B,W
143C:  MOVWF  x26
143E:  MOVF   x18,W
1440:  ADDWF  x25,W
1442:  MOVWF  FE9
1444:  MOVF   x19,W
1446:  ADDWFC x26,W
1448:  MOVWF  FEA
144A:  MOVFF  FEF,927
144E:  MOVLW  07
1450:  SUBWF  x1A,W
1452:  MOVWF  x28
1454:  MOVLW  00
1456:  SUBWFB x1B,W
1458:  MOVWF  x29
145A:  MOVF   x18,W
145C:  ADDWF  x28,W
145E:  MOVWF  FE9
1460:  MOVF   x19,W
1462:  ADDWFC x29,W
1464:  MOVWF  FEA
1466:  MOVFF  FEF,92A
146A:  MOVLW  06
146C:  SUBWF  x1A,W
146E:  MOVWF  x2B
1470:  MOVLW  00
1472:  SUBWFB x1B,W
1474:  MOVWF  x2C
1476:  MOVF   x18,W
1478:  ADDWF  x2B,W
147A:  MOVWF  FE9
147C:  MOVF   x19,W
147E:  ADDWFC x2C,W
1480:  MOVWF  FEA
1482:  MOVFF  FEF,92D
1486:  MOVLW  05
1488:  SUBWF  x1A,W
148A:  MOVWF  x2E
148C:  MOVLW  00
148E:  SUBWFB x1B,W
1490:  MOVWF  x2F
1492:  MOVF   x18,W
1494:  ADDWF  x2E,W
1496:  MOVWF  FE9
1498:  MOVF   x19,W
149A:  ADDWFC x2F,W
149C:  MOVWF  FEA
149E:  MOVFF  FEF,930
14A2:  CLRF   x37
14A4:  CLRF   x38
14A6:  CLRF   x39
14A8:  MOVFF  924,93A
14AC:  MOVFF  927,93B
14B0:  MOVFF  92A,93C
14B4:  MOVFF  92D,93D
14B8:  MOVFF  930,93E
14BC:  MOVLB  0
14BE:  CALL   06AC
14C2:  MOVFF  01,91F
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
14C6:  MOVLB  9
14C8:  MOVF   x1E,W
14CA:  SUBLW  0B
14CC:  BTFSS  FD8.2
14CE:  BRA    15F0
14D0:  MOVF   x1F,W
14D2:  SUBLW  1F
14D4:  BTFSC  FD8.2
14D6:  BRA    15F0
14D8:  MOVF   x1F,W
14DA:  SUBLW  0F
14DC:  BTFSC  FD8.2
14DE:  BRA    15F0
....................             { 
....................                j=i; 
14E0:  MOVFF  91B,91D
14E4:  MOVFF  91A,91C
....................                CRC=1; 
14E8:  MOVLW  01
14EA:  MOVWF  x21
....................                temp2=temp; 
14EC:  MOVFF  91E,920
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
14F0:  MOVF   x20,W
14F2:  SUBLW  1F
14F4:  BZ    15D0
14F6:  MOVF   x1D,F
14F8:  BNZ   1500
14FA:  MOVF   x1C,W
14FC:  SUBLW  01
14FE:  BC    15D0
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1500:  MOVLW  01
1502:  MOVWF  x22
1504:  MOVFF  91D,924
1508:  MOVFF  91C,923
150C:  MOVFF  919,926
1510:  MOVFF  918,925
1514:  MOVLB  0
1516:  CALL   08C2
151A:  MOVF   01,W
151C:  MOVLB  9
151E:  ANDWF  x21,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1520:  MOVLW  04
1522:  SUBWF  x1C,W
1524:  MOVWF  x22
1526:  MOVLW  00
1528:  SUBWFB x1D,W
152A:  MOVWF  x23
152C:  MOVF   x18,W
152E:  ADDWF  x22,W
1530:  MOVWF  FE9
1532:  MOVF   x19,W
1534:  ADDWFC x23,W
1536:  MOVWF  FEA
1538:  MOVFF  FEF,924
153C:  MOVLW  03
153E:  SUBWF  x1C,W
1540:  MOVWF  x25
1542:  MOVLW  00
1544:  SUBWFB x1D,W
1546:  MOVWF  x26
1548:  MOVF   x18,W
154A:  ADDWF  x25,W
154C:  MOVWF  FE9
154E:  MOVF   x19,W
1550:  ADDWFC x26,W
1552:  MOVWF  FEA
1554:  MOVFF  FEF,927
1558:  MOVLW  02
155A:  SUBWF  x1C,W
155C:  MOVWF  x28
155E:  MOVLW  00
1560:  SUBWFB x1D,W
1562:  MOVWF  x29
1564:  MOVF   x18,W
1566:  ADDWF  x28,W
1568:  MOVWF  FE9
156A:  MOVF   x19,W
156C:  ADDWFC x29,W
156E:  MOVWF  FEA
1570:  MOVFF  FEF,92A
1574:  MOVLW  01
1576:  SUBWF  x1C,W
1578:  MOVWF  x2B
157A:  MOVLW  00
157C:  SUBWFB x1D,W
157E:  MOVWF  x2C
1580:  MOVF   x18,W
1582:  ADDWF  x2B,W
1584:  MOVWF  FE9
1586:  MOVF   x19,W
1588:  ADDWFC x2C,W
158A:  MOVWF  FEA
158C:  MOVFF  FEF,92D
1590:  MOVF   x18,W
1592:  ADDWF  x1C,W
1594:  MOVWF  FE9
1596:  MOVF   x19,W
1598:  ADDWFC x1D,W
159A:  MOVWF  FEA
159C:  MOVFF  FEF,92E
15A0:  CLRF   x37
15A2:  CLRF   x38
15A4:  CLRF   x39
15A6:  MOVFF  924,93A
15AA:  MOVFF  927,93B
15AE:  MOVFF  92A,93C
15B2:  MOVFF  92D,93D
15B6:  MOVFF  92E,93E
15BA:  MOVLB  0
15BC:  CALL   06AC
15C0:  MOVFF  01,920
....................                   j=j-5; 
15C4:  MOVLW  05
15C6:  MOVLB  9
15C8:  SUBWF  x1C,F
15CA:  MOVLW  00
15CC:  SUBWFB x1D,F
....................                } 
15CE:  BRA    14F0
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
15D0:  DECFSZ x21,W
15D2:  BRA    15E8
....................                { 
....................                   dir=1; 
15D4:  MOVLW  01
15D6:  MOVLB  6
15D8:  MOVWF  xC8
....................                   return i; 
15DA:  MOVLB  9
15DC:  MOVFF  91A,01
15E0:  MOVFF  91B,02
15E4:  BRA    1600
....................                } 
....................                   else return 0; 
15E6:  BRA    15F0
15E8:  MOVLW  00
15EA:  MOVWF  01
15EC:  MOVWF  02
15EE:  BRA    1600
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
15F0:  MOVF   x1A,W
15F2:  BTFSC  FD8.2
15F4:  DECF   x1B,F
15F6:  DECF   x1A,F
15F8:  BRA    0FF2
....................    return 0; 
15FA:  MOVLW  00
15FC:  MOVWF  01
15FE:  MOVWF  02
.................... } 
1600:  MOVLB  0
1602:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
35B4:  MOVLB  9
35B6:  CLRF   x02
35B8:  MOVLW  01
35BA:  MOVWF  x01
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
35BC:  MOVFF  8F7,915
35C0:  MOVFF  8F9,917
35C4:  MOVFF  8F8,916
35C8:  MOVFF  8FB,919
35CC:  MOVFF  8FA,918
35D0:  MOVLB  0
35D2:  CALL   0A02
35D6:  MOVFF  02,902
35DA:  MOVFF  01,901
....................    if(temp==0) return 0; 
35DE:  MOVLB  9
35E0:  MOVF   x01,F
35E2:  BNZ   35EE
35E4:  MOVF   x02,F
35E6:  BNZ   35EE
35E8:  MOVLW  00
35EA:  MOVWF  01
35EC:  BRA    3A68
....................    j=temp; 
35EE:  MOVFF  902,900
35F2:  MOVFF  901,8FF
....................    if(dir==0) 
35F6:  MOVLB  6
35F8:  MOVF   xC8,F
35FA:  BTFSS  FD8.2
35FC:  BRA    382A
....................    { 
....................       if(track==0) 
35FE:  MOVLB  8
3600:  MOVF   xF7,F
3602:  BTFSS  FD8.2
3604:  BRA    3742
....................       { 
....................             for(i=0;i<79;i++) 
3606:  CLRF   xFE
3608:  MOVF   xFE,W
360A:  SUBLW  4E
360C:  BTFSS  FD8.0
360E:  BRA    3740
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3610:  CLRF   03
3612:  MOVF   xFE,W
3614:  ADDWF  xFC,W
3616:  MOVWF  01
3618:  MOVF   xFD,W
361A:  ADDWFC 03,F
361C:  MOVFF  01,903
3620:  MOVFF  03,904
3624:  MOVLW  05
3626:  MOVLB  8
3628:  ADDWF  xFF,W
362A:  MOVLB  9
362C:  MOVWF  x05
362E:  MOVLW  00
3630:  ADDWFC x00,W
3632:  MOVWF  x06
3634:  MOVLB  8
3636:  MOVF   xFA,W
3638:  MOVLB  9
363A:  ADDWF  x05,W
363C:  MOVWF  FE9
363E:  MOVLB  8
3640:  MOVF   xFB,W
3642:  MOVLB  9
3644:  ADDWFC x06,W
3646:  MOVWF  FEA
3648:  MOVFF  FEF,907
364C:  MOVLW  04
364E:  MOVLB  8
3650:  ADDWF  xFF,W
3652:  MOVLB  9
3654:  MOVWF  x08
3656:  MOVLW  00
3658:  ADDWFC x00,W
365A:  MOVWF  x09
365C:  MOVLB  8
365E:  MOVF   xFA,W
3660:  MOVLB  9
3662:  ADDWF  x08,W
3664:  MOVWF  FE9
3666:  MOVLB  8
3668:  MOVF   xFB,W
366A:  MOVLB  9
366C:  ADDWFC x09,W
366E:  MOVWF  FEA
3670:  MOVFF  FEF,90A
3674:  MOVLW  03
3676:  MOVLB  8
3678:  ADDWF  xFF,W
367A:  MOVLB  9
367C:  MOVWF  x0B
367E:  MOVLW  00
3680:  ADDWFC x00,W
3682:  MOVWF  x0C
3684:  MOVLB  8
3686:  MOVF   xFA,W
3688:  MOVLB  9
368A:  ADDWF  x0B,W
368C:  MOVWF  FE9
368E:  MOVLB  8
3690:  MOVF   xFB,W
3692:  MOVLB  9
3694:  ADDWFC x0C,W
3696:  MOVWF  FEA
3698:  MOVFF  FEF,90D
369C:  MOVLW  02
369E:  MOVLB  8
36A0:  ADDWF  xFF,W
36A2:  MOVLB  9
36A4:  MOVWF  x0E
36A6:  MOVLW  00
36A8:  ADDWFC x00,W
36AA:  MOVWF  x0F
36AC:  MOVLB  8
36AE:  MOVF   xFA,W
36B0:  MOVLB  9
36B2:  ADDWF  x0E,W
36B4:  MOVWF  FE9
36B6:  MOVLB  8
36B8:  MOVF   xFB,W
36BA:  MOVLB  9
36BC:  ADDWFC x0F,W
36BE:  MOVWF  FEA
36C0:  MOVFF  FEF,910
36C4:  MOVLW  01
36C6:  MOVLB  8
36C8:  ADDWF  xFF,W
36CA:  MOVLB  9
36CC:  MOVWF  x11
36CE:  MOVLW  00
36D0:  ADDWFC x00,W
36D2:  MOVWF  x12
36D4:  MOVLB  8
36D6:  MOVF   xFA,W
36D8:  MOVLB  9
36DA:  ADDWF  x11,W
36DC:  MOVWF  FE9
36DE:  MOVLB  8
36E0:  MOVF   xFB,W
36E2:  MOVLB  9
36E4:  ADDWFC x12,W
36E6:  MOVWF  FEA
36E8:  MOVFF  FEF,913
36EC:  MOVLB  8
36EE:  MOVF   xFA,W
36F0:  ADDWF  xFF,W
36F2:  MOVWF  FE9
36F4:  MOVF   xFB,W
36F6:  MOVLB  9
36F8:  ADDWFC x00,W
36FA:  MOVWF  FEA
36FC:  MOVFF  FEF,914
3700:  CLRF   x37
3702:  CLRF   x38
3704:  MOVFF  907,939
3708:  MOVFF  90A,93A
370C:  MOVFF  90D,93B
3710:  MOVFF  910,93C
3714:  MOVFF  913,93D
3718:  MOVFF  914,93E
371C:  MOVLB  0
371E:  CALL   06AC
3722:  MOVFF  904,FEA
3726:  MOVFF  903,FE9
372A:  MOVFF  01,FEF
....................                j=j+7; 
372E:  MOVLW  07
3730:  MOVLB  8
3732:  ADDWF  xFF,F
3734:  MOVLW  00
3736:  MOVLB  9
3738:  ADDWFC x00,F
....................             } 
373A:  MOVLB  8
373C:  INCF   xFE,F
373E:  BRA    3608
....................       } 
....................          else  
3740:  BRA    3826
....................          { 
....................             for(i=0;i<40;i++) 
3742:  CLRF   xFE
3744:  MOVF   xFE,W
3746:  SUBLW  27
3748:  BNC   3826
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
374A:  CLRF   03
374C:  MOVF   xFE,W
374E:  ADDWF  xFC,W
3750:  MOVWF  01
3752:  MOVF   xFD,W
3754:  ADDWFC 03,F
3756:  MOVFF  01,903
375A:  MOVFF  03,904
375E:  MOVLW  03
3760:  MOVLB  8
3762:  ADDWF  xFF,W
3764:  MOVLB  9
3766:  MOVWF  x05
3768:  MOVLW  00
376A:  ADDWFC x00,W
376C:  MOVWF  x06
376E:  MOVLB  8
3770:  MOVF   xFA,W
3772:  MOVLB  9
3774:  ADDWF  x05,W
3776:  MOVWF  FE9
3778:  MOVLB  8
377A:  MOVF   xFB,W
377C:  MOVLB  9
377E:  ADDWFC x06,W
3780:  MOVWF  FEA
3782:  MOVFF  FEF,907
3786:  MOVLW  02
3788:  MOVLB  8
378A:  ADDWF  xFF,W
378C:  MOVLB  9
378E:  MOVWF  x08
3790:  MOVLW  00
3792:  ADDWFC x00,W
3794:  MOVWF  x09
3796:  MOVLB  8
3798:  MOVF   xFA,W
379A:  MOVLB  9
379C:  ADDWF  x08,W
379E:  MOVWF  FE9
37A0:  MOVLB  8
37A2:  MOVF   xFB,W
37A4:  MOVLB  9
37A6:  ADDWFC x09,W
37A8:  MOVWF  FEA
37AA:  MOVFF  FEF,90A
37AE:  MOVLW  01
37B0:  MOVLB  8
37B2:  ADDWF  xFF,W
37B4:  MOVLB  9
37B6:  MOVWF  x0B
37B8:  MOVLW  00
37BA:  ADDWFC x00,W
37BC:  MOVWF  x0C
37BE:  MOVLB  8
37C0:  MOVF   xFA,W
37C2:  MOVLB  9
37C4:  ADDWF  x0B,W
37C6:  MOVWF  FE9
37C8:  MOVLB  8
37CA:  MOVF   xFB,W
37CC:  MOVLB  9
37CE:  ADDWFC x0C,W
37D0:  MOVWF  FEA
37D2:  MOVFF  FEF,90D
37D6:  MOVLB  8
37D8:  MOVF   xFA,W
37DA:  ADDWF  xFF,W
37DC:  MOVWF  FE9
37DE:  MOVF   xFB,W
37E0:  MOVLB  9
37E2:  ADDWFC x00,W
37E4:  MOVWF  FEA
37E6:  MOVFF  FEF,90E
37EA:  CLRF   x37
37EC:  CLRF   x38
37EE:  CLRF   x39
37F0:  CLRF   x3A
37F2:  MOVFF  907,93B
37F6:  MOVFF  90A,93C
37FA:  MOVFF  90D,93D
37FE:  MOVFF  90E,93E
3802:  MOVLB  0
3804:  CALL   06AC
3808:  MOVFF  904,FEA
380C:  MOVFF  903,FE9
3810:  MOVFF  01,FEF
....................                j=j+5; 
3814:  MOVLW  05
3816:  MOVLB  8
3818:  ADDWF  xFF,F
381A:  MOVLW  00
381C:  MOVLB  9
381E:  ADDWFC x00,F
....................             }          
3820:  MOVLB  8
3822:  INCF   xFE,F
3824:  BRA    3744
....................          } 
....................    } 
....................       else  
3826:  BRA    3A52
3828:  MOVLB  6
....................       { 
....................          if(track==0) 
382A:  MOVLB  8
382C:  MOVF   xF7,F
382E:  BTFSS  FD8.2
3830:  BRA    396E
....................          { 
....................             for(i=0;i<79;i++) 
3832:  CLRF   xFE
3834:  MOVF   xFE,W
3836:  SUBLW  4E
3838:  BTFSS  FD8.0
383A:  BRA    396C
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
383C:  CLRF   03
383E:  MOVF   xFE,W
3840:  ADDWF  xFC,W
3842:  MOVWF  01
3844:  MOVF   xFD,W
3846:  ADDWFC 03,F
3848:  MOVFF  01,903
384C:  MOVFF  03,904
3850:  MOVLW  05
3852:  MOVLB  8
3854:  SUBWF  xFF,W
3856:  MOVLB  9
3858:  MOVWF  x05
385A:  MOVLW  00
385C:  SUBWFB x00,W
385E:  MOVWF  x06
3860:  MOVLB  8
3862:  MOVF   xFA,W
3864:  MOVLB  9
3866:  ADDWF  x05,W
3868:  MOVWF  FE9
386A:  MOVLB  8
386C:  MOVF   xFB,W
386E:  MOVLB  9
3870:  ADDWFC x06,W
3872:  MOVWF  FEA
3874:  MOVFF  FEF,907
3878:  MOVLW  04
387A:  MOVLB  8
387C:  SUBWF  xFF,W
387E:  MOVLB  9
3880:  MOVWF  x08
3882:  MOVLW  00
3884:  SUBWFB x00,W
3886:  MOVWF  x09
3888:  MOVLB  8
388A:  MOVF   xFA,W
388C:  MOVLB  9
388E:  ADDWF  x08,W
3890:  MOVWF  FE9
3892:  MOVLB  8
3894:  MOVF   xFB,W
3896:  MOVLB  9
3898:  ADDWFC x09,W
389A:  MOVWF  FEA
389C:  MOVFF  FEF,90A
38A0:  MOVLW  03
38A2:  MOVLB  8
38A4:  SUBWF  xFF,W
38A6:  MOVLB  9
38A8:  MOVWF  x0B
38AA:  MOVLW  00
38AC:  SUBWFB x00,W
38AE:  MOVWF  x0C
38B0:  MOVLB  8
38B2:  MOVF   xFA,W
38B4:  MOVLB  9
38B6:  ADDWF  x0B,W
38B8:  MOVWF  FE9
38BA:  MOVLB  8
38BC:  MOVF   xFB,W
38BE:  MOVLB  9
38C0:  ADDWFC x0C,W
38C2:  MOVWF  FEA
38C4:  MOVFF  FEF,90D
38C8:  MOVLW  02
38CA:  MOVLB  8
38CC:  SUBWF  xFF,W
38CE:  MOVLB  9
38D0:  MOVWF  x0E
38D2:  MOVLW  00
38D4:  SUBWFB x00,W
38D6:  MOVWF  x0F
38D8:  MOVLB  8
38DA:  MOVF   xFA,W
38DC:  MOVLB  9
38DE:  ADDWF  x0E,W
38E0:  MOVWF  FE9
38E2:  MOVLB  8
38E4:  MOVF   xFB,W
38E6:  MOVLB  9
38E8:  ADDWFC x0F,W
38EA:  MOVWF  FEA
38EC:  MOVFF  FEF,910
38F0:  MOVLW  01
38F2:  MOVLB  8
38F4:  SUBWF  xFF,W
38F6:  MOVLB  9
38F8:  MOVWF  x11
38FA:  MOVLW  00
38FC:  SUBWFB x00,W
38FE:  MOVWF  x12
3900:  MOVLB  8
3902:  MOVF   xFA,W
3904:  MOVLB  9
3906:  ADDWF  x11,W
3908:  MOVWF  FE9
390A:  MOVLB  8
390C:  MOVF   xFB,W
390E:  MOVLB  9
3910:  ADDWFC x12,W
3912:  MOVWF  FEA
3914:  MOVFF  FEF,913
3918:  MOVLB  8
391A:  MOVF   xFA,W
391C:  ADDWF  xFF,W
391E:  MOVWF  FE9
3920:  MOVF   xFB,W
3922:  MOVLB  9
3924:  ADDWFC x00,W
3926:  MOVWF  FEA
3928:  MOVFF  FEF,914
392C:  CLRF   x37
392E:  CLRF   x38
3930:  MOVFF  907,939
3934:  MOVFF  90A,93A
3938:  MOVFF  90D,93B
393C:  MOVFF  910,93C
3940:  MOVFF  913,93D
3944:  MOVFF  914,93E
3948:  MOVLB  0
394A:  CALL   06AC
394E:  MOVFF  904,FEA
3952:  MOVFF  903,FE9
3956:  MOVFF  01,FEF
....................                j=j-7; 
395A:  MOVLW  07
395C:  MOVLB  8
395E:  SUBWF  xFF,F
3960:  MOVLW  00
3962:  MOVLB  9
3964:  SUBWFB x00,F
....................             } 
3966:  MOVLB  8
3968:  INCF   xFE,F
396A:  BRA    3834
....................          } 
....................             else 
396C:  BRA    3A52
....................             { 
....................                for(i=0;i<40;i++) 
396E:  CLRF   xFE
3970:  MOVF   xFE,W
3972:  SUBLW  27
3974:  BNC   3A52
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3976:  CLRF   03
3978:  MOVF   xFE,W
397A:  ADDWF  xFC,W
397C:  MOVWF  01
397E:  MOVF   xFD,W
3980:  ADDWFC 03,F
3982:  MOVFF  01,903
3986:  MOVFF  03,904
398A:  MOVLW  03
398C:  MOVLB  8
398E:  SUBWF  xFF,W
3990:  MOVLB  9
3992:  MOVWF  x05
3994:  MOVLW  00
3996:  SUBWFB x00,W
3998:  MOVWF  x06
399A:  MOVLB  8
399C:  MOVF   xFA,W
399E:  MOVLB  9
39A0:  ADDWF  x05,W
39A2:  MOVWF  FE9
39A4:  MOVLB  8
39A6:  MOVF   xFB,W
39A8:  MOVLB  9
39AA:  ADDWFC x06,W
39AC:  MOVWF  FEA
39AE:  MOVFF  FEF,907
39B2:  MOVLW  02
39B4:  MOVLB  8
39B6:  SUBWF  xFF,W
39B8:  MOVLB  9
39BA:  MOVWF  x08
39BC:  MOVLW  00
39BE:  SUBWFB x00,W
39C0:  MOVWF  x09
39C2:  MOVLB  8
39C4:  MOVF   xFA,W
39C6:  MOVLB  9
39C8:  ADDWF  x08,W
39CA:  MOVWF  FE9
39CC:  MOVLB  8
39CE:  MOVF   xFB,W
39D0:  MOVLB  9
39D2:  ADDWFC x09,W
39D4:  MOVWF  FEA
39D6:  MOVFF  FEF,90A
39DA:  MOVLW  01
39DC:  MOVLB  8
39DE:  SUBWF  xFF,W
39E0:  MOVLB  9
39E2:  MOVWF  x0B
39E4:  MOVLW  00
39E6:  SUBWFB x00,W
39E8:  MOVWF  x0C
39EA:  MOVLB  8
39EC:  MOVF   xFA,W
39EE:  MOVLB  9
39F0:  ADDWF  x0B,W
39F2:  MOVWF  FE9
39F4:  MOVLB  8
39F6:  MOVF   xFB,W
39F8:  MOVLB  9
39FA:  ADDWFC x0C,W
39FC:  MOVWF  FEA
39FE:  MOVFF  FEF,90D
3A02:  MOVLB  8
3A04:  MOVF   xFA,W
3A06:  ADDWF  xFF,W
3A08:  MOVWF  FE9
3A0A:  MOVF   xFB,W
3A0C:  MOVLB  9
3A0E:  ADDWFC x00,W
3A10:  MOVWF  FEA
3A12:  MOVFF  FEF,90E
3A16:  CLRF   x37
3A18:  CLRF   x38
3A1A:  CLRF   x39
3A1C:  CLRF   x3A
3A1E:  MOVFF  907,93B
3A22:  MOVFF  90A,93C
3A26:  MOVFF  90D,93D
3A2A:  MOVFF  90E,93E
3A2E:  MOVLB  0
3A30:  CALL   06AC
3A34:  MOVFF  904,FEA
3A38:  MOVFF  903,FE9
3A3C:  MOVFF  01,FEF
....................                   j=j-5; 
3A40:  MOVLW  05
3A42:  MOVLB  8
3A44:  SUBWF  xFF,F
3A46:  MOVLW  00
3A48:  MOVLB  9
3A4A:  SUBWFB x00,F
....................                }             
3A4C:  MOVLB  8
3A4E:  INCF   xFE,F
3A50:  BRA    3970
....................             } 
....................       } 
....................       memset(datin,0,sizeof(datin)); 
3A52:  MOVFF  8FB,FEA
3A56:  MOVFF  8FA,FE9
3A5A:  CLRF   00
3A5C:  CLRF   02
3A5E:  MOVLW  02
3A60:  MOVWF  01
3A62:  MOVLB  0
3A64:  RCALL  359A
3A66:  MOVLB  9
.................... } 
3A68:  MOVLB  0
3A6A:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1836:  MOVLW  8E
1838:  MOVWF  FF6
183A:  MOVLW  05
183C:  MOVWF  FF7
183E:  RCALL  172E
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1840:  MOVLB  8
1842:  CLRF   x57
1844:  CLRF   x56
1846:  MOVF   x57,W
1848:  SUBLW  03
184A:  BNC   187A
184C:  BNZ   1854
184E:  MOVF   x56,W
1850:  SUBLW  51
1852:  BNC   187A
1854:  MOVLW  46
1856:  ADDWF  x56,W
1858:  MOVWF  FE9
185A:  MOVLW  02
185C:  ADDWFC x57,W
185E:  MOVWF  FEA
1860:  MOVFF  FEF,858
1864:  MOVFF  858,859
1868:  MOVLW  18
186A:  MOVWF  x5A
186C:  MOVLB  0
186E:  RCALL  177A
1870:  MOVLB  8
1872:  INCF   x56,F
1874:  BTFSC  FD8.2
1876:  INCF   x57,F
1878:  BRA    1846
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
187A:  MOVLW  A4
187C:  MOVWF  FF6
187E:  MOVLW  05
1880:  MOVWF  FF7
1882:  MOVLB  0
1884:  RCALL  172E
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1886:  MOVLB  8
1888:  CLRF   x57
188A:  CLRF   x56
188C:  MOVF   x57,W
188E:  SUBLW  01
1890:  BNC   18C0
1892:  BNZ   189A
1894:  MOVF   x56,W
1896:  SUBLW  2B
1898:  BNC   18C0
189A:  MOVLW  98
189C:  ADDWF  x56,W
189E:  MOVWF  FE9
18A0:  MOVLW  05
18A2:  ADDWFC x57,W
18A4:  MOVWF  FEA
18A6:  MOVFF  FEF,858
18AA:  MOVFF  858,859
18AE:  MOVLW  18
18B0:  MOVWF  x5A
18B2:  MOVLB  0
18B4:  RCALL  177A
18B6:  MOVLB  8
18B8:  INCF   x56,F
18BA:  BTFSC  FD8.2
18BC:  INCF   x57,F
18BE:  BRA    188C
.................... } 
18C0:  MOVLB  0
18C2:  GOTO   1B50 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3C02:  MOVLW  01
3C04:  MOVLB  6
3C06:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3C08:  MOVLB  0
3C0A:  RCALL  351C
3C0C:  MOVFF  02,854
3C10:  MOVFF  01,853
3C14:  MOVFF  02,856
3C18:  MOVFF  01,855
3C1C:  MOVLB  8
3C1E:  CLRF   x58
3C20:  MOVLW  7C
3C22:  MOVWF  x57
3C24:  MOVLB  0
3C26:  RCALL  3578
3C28:  MOVFF  01,853
3C2C:  MOVLW  96
3C2E:  MOVLB  8
3C30:  ADDWF  01,W
3C32:  MOVWF  01
3C34:  MOVLW  00
3C36:  ADDWFC 02,W
3C38:  MOVFF  01,20
3C3C:  MOVWF  21
3C3E:  CLRF   22
3C40:  CLRF   23
....................    if(datinbuf==0)  
3C42:  MOVLB  6
3C44:  MOVF   xD5,F
3C46:  BNZ   3C6A
....................    { 
....................       countbit_T1=0; 
3C48:  CLRF   xCA
3C4A:  CLRF   xC9
....................       countbit_T2=0; 
3C4C:  CLRF   xCC
3C4E:  CLRF   xCB
....................       bug_countbit_T1=0; 
3C50:  CLRF   xCE
3C52:  CLRF   xCD
....................       bug_countbit_T2=0; 
3C54:  CLRF   xD0
3C56:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3C58:  MOVF   xD9,F
3C5A:  BNZ   3C66
3C5C:  MOVLB  1
3C5E:  SETF   x00
3C60:  MOVLB  0
3C62:  SETF   xFF
3C64:  MOVLB  6
....................       saving_flag=0; 
3C66:  CLRF   xD8
....................       return; 
3C68:  BRA    3FFE
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3C6A:  MOVLW  BA
3C6C:  MOVWF  FF6
3C6E:  MOVLW  05
3C70:  MOVWF  FF7
3C72:  MOVLB  0
3C74:  CALL   172E
....................    //key_count=0; 
....................    enable_getpin=1; 
3C78:  MOVLW  01
3C7A:  MOVLB  1
3C7C:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3C7E:  MOVFF  6CA,852
3C82:  MOVFF  6C9,851
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3C86:  MOVLB  8
3C88:  CLRF   xF7
3C8A:  MOVFF  852,8F9
3C8E:  MOVFF  851,8F8
3C92:  MOVLW  02
3C94:  MOVWF  xFB
3C96:  MOVLW  46
3C98:  MOVWF  xFA
3C9A:  MOVLW  01
3C9C:  MOVWF  xFD
3C9E:  MOVLW  CF
3CA0:  MOVWF  xFC
3CA2:  MOVLB  0
3CA4:  RCALL  35B4
....................    countbit_T1=0; 
3CA6:  MOVLB  6
3CA8:  CLRF   xCA
3CAA:  CLRF   xC9
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3CAC:  MOVFF  6CC,852
3CB0:  MOVFF  6CB,851
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3CB4:  MOVLW  01
3CB6:  MOVLB  8
3CB8:  MOVWF  xF7
3CBA:  MOVFF  852,8F9
3CBE:  MOVFF  851,8F8
3CC2:  MOVLW  05
3CC4:  MOVWF  xFB
3CC6:  MOVLW  98
3CC8:  MOVWF  xFA
3CCA:  MOVLW  02
3CCC:  MOVWF  xFD
3CCE:  MOVLW  1E
3CD0:  MOVWF  xFC
3CD2:  MOVLB  0
3CD4:  RCALL  35B4
....................    countbit_T2=0; 
3CD6:  MOVLB  6
3CD8:  CLRF   xCC
3CDA:  CLRF   xCB
....................    saving_flag=0; 
3CDC:  CLRF   xD8
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3CDE:  MOVLW  20
3CE0:  MOVLB  1
3CE2:  ADDWF  xCF,W
3CE4:  MOVLB  8
3CE6:  MOVWF  x50
....................    if((ptr_card<EEPROM_SIZE_stofkey)&&(temp=='%')) 
3CE8:  MOVF   23,F
3CEA:  BTFSS  FD8.2
3CEC:  BRA    3FFC
3CEE:  MOVF   22,W
3CF0:  SUBLW  01
3CF2:  BTFSS  FD8.0
3CF4:  BRA    3FFC
3CF6:  BNZ   3D0A
3CF8:  MOVF   21,W
3CFA:  SUBLW  C3
3CFC:  BTFSS  FD8.0
3CFE:  BRA    3FFC
3D00:  BNZ   3D0A
3D02:  MOVF   20,W
3D04:  SUBLW  0D
3D06:  BTFSS  FD8.0
3D08:  BRA    3FFC
3D0A:  MOVF   x50,W
3D0C:  SUBLW  25
3D0E:  BTFSS  FD8.2
3D10:  BRA    3FFC
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3D12:  MOVFF  23,03
3D16:  MOVFF  22,02
3D1A:  MOVFF  21,01
3D1E:  MOVFF  20,00
3D22:  MOVLW  01
3D24:  ADDWF  20,F
3D26:  BTFSC  FD8.0
3D28:  INCF   21,F
3D2A:  BTFSC  FD8.2
3D2C:  INCF   22,F
3D2E:  BTFSC  FD8.2
3D30:  INCF   23,F
3D32:  MOVFF  01,854
3D36:  MOVFF  00,853
3D3A:  MOVLB  9
3D3C:  CLRF   x16
3D3E:  CLRF   x15
3D40:  MOVFF  01,914
3D44:  MOVFF  00,913
3D48:  MOVFF  1CB,917
3D4C:  MOVLB  0
3D4E:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3D50:  MOVFF  23,03
3D54:  MOVFF  22,02
3D58:  MOVFF  21,01
3D5C:  MOVFF  20,00
3D60:  MOVLW  01
3D62:  ADDWF  20,F
3D64:  BTFSC  FD8.0
3D66:  INCF   21,F
3D68:  BTFSC  FD8.2
3D6A:  INCF   22,F
3D6C:  BTFSC  FD8.2
3D6E:  INCF   23,F
3D70:  MOVFF  01,854
3D74:  MOVFF  00,853
3D78:  MOVLB  9
3D7A:  CLRF   x16
3D7C:  CLRF   x15
3D7E:  MOVFF  01,914
3D82:  MOVFF  00,913
3D86:  MOVFF  1CA,917
3D8A:  MOVLB  0
3D8C:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,h); 
3D8E:  MOVFF  23,03
3D92:  MOVFF  22,02
3D96:  MOVFF  21,01
3D9A:  MOVFF  20,00
3D9E:  MOVLW  01
3DA0:  ADDWF  20,F
3DA2:  BTFSC  FD8.0
3DA4:  INCF   21,F
3DA6:  BTFSC  FD8.2
3DA8:  INCF   22,F
3DAA:  BTFSC  FD8.2
3DAC:  INCF   23,F
3DAE:  MOVFF  01,854
3DB2:  MOVFF  00,853
3DB6:  MOVLB  9
3DB8:  CLRF   x16
3DBA:  CLRF   x15
3DBC:  MOVFF  01,914
3DC0:  MOVFF  00,913
3DC4:  MOVFF  1CC,917
3DC8:  MOVLB  0
3DCA:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,min); 
3DCC:  MOVFF  23,03
3DD0:  MOVFF  22,02
3DD4:  MOVFF  21,01
3DD8:  MOVFF  20,00
3DDC:  MOVLW  01
3DDE:  ADDWF  20,F
3DE0:  BTFSC  FD8.0
3DE2:  INCF   21,F
3DE4:  BTFSC  FD8.2
3DE6:  INCF   22,F
3DE8:  BTFSC  FD8.2
3DEA:  INCF   23,F
3DEC:  MOVFF  01,854
3DF0:  MOVFF  00,853
3DF4:  MOVLB  9
3DF6:  CLRF   x16
3DF8:  CLRF   x15
3DFA:  MOVFF  01,914
3DFE:  MOVFF  00,913
3E02:  MOVFF  1CD,917
3E06:  MOVLB  0
3E08:  RCALL  3A6C
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3E0A:  MOVFF  23,03
3E0E:  MOVFF  22,02
3E12:  MOVFF  21,01
3E16:  MOVFF  20,00
3E1A:  MOVLW  01
3E1C:  ADDWF  20,F
3E1E:  BTFSC  FD8.0
3E20:  INCF   21,F
3E22:  BTFSC  FD8.2
3E24:  INCF   22,F
3E26:  BTFSC  FD8.2
3E28:  INCF   23,F
3E2A:  MOVFF  01,854
3E2E:  MOVFF  00,853
3E32:  MOVLB  9
3E34:  CLRF   x16
3E36:  CLRF   x15
3E38:  MOVFF  01,914
3E3C:  MOVFF  00,913
3E40:  MOVFF  1CE,917
3E44:  MOVLB  0
3E46:  RCALL  3A6C
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3E48:  MOVLB  6
3E4A:  CLRF   xD4
3E4C:  CLRF   xD3
3E4E:  MOVF   xD4,F
3E50:  BNZ   3EB4
3E52:  MOVF   xD3,W
3E54:  SUBLW  4E
3E56:  BNC   3EB4
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3E58:  MOVFF  23,03
3E5C:  MOVFF  22,02
3E60:  MOVFF  21,01
3E64:  MOVFF  20,00
3E68:  MOVLW  01
3E6A:  ADDWF  20,F
3E6C:  BTFSC  FD8.0
3E6E:  INCF   21,F
3E70:  BTFSC  FD8.2
3E72:  INCF   22,F
3E74:  BTFSC  FD8.2
3E76:  INCF   23,F
3E78:  MOVFF  01,854
3E7C:  MOVFF  00,853
3E80:  MOVLW  CF
3E82:  ADDWF  xD3,W
3E84:  MOVWF  FE9
3E86:  MOVLW  01
3E88:  ADDWFC xD4,W
3E8A:  MOVWF  FEA
3E8C:  MOVF   FEF,W
3E8E:  ANDLW  3F
3E90:  ADDLW  20
3E92:  MOVLB  8
3E94:  MOVWF  x55
3E96:  MOVLB  9
3E98:  CLRF   x16
3E9A:  CLRF   x15
3E9C:  MOVFF  01,914
3EA0:  MOVFF  00,913
3EA4:  MOVWF  x17
3EA6:  MOVLB  0
3EA8:  RCALL  3A6C
....................              
....................          } 
3EAA:  MOVLB  6
3EAC:  INCF   xD3,F
3EAE:  BTFSC  FD8.2
3EB0:  INCF   xD4,F
3EB2:  BRA    3E4E
....................          memset(Track1,0,sizeof(Track1)); 
3EB4:  MOVLW  01
3EB6:  MOVWF  FEA
3EB8:  MOVLW  CF
3EBA:  MOVWF  FE9
3EBC:  CLRF   00
3EBE:  CLRF   02
3EC0:  MOVLW  4F
3EC2:  MOVWF  01
3EC4:  MOVLB  0
3EC6:  CALL   359A
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3ECA:  MOVLB  6
3ECC:  CLRF   xD4
3ECE:  CLRF   xD3
3ED0:  MOVF   xD4,F
3ED2:  BNZ   3F36
3ED4:  MOVF   xD3,W
3ED6:  SUBLW  27
3ED8:  BNC   3F36
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3EDA:  MOVFF  23,03
3EDE:  MOVFF  22,02
3EE2:  MOVFF  21,01
3EE6:  MOVFF  20,00
3EEA:  MOVLW  01
3EEC:  ADDWF  20,F
3EEE:  BTFSC  FD8.0
3EF0:  INCF   21,F
3EF2:  BTFSC  FD8.2
3EF4:  INCF   22,F
3EF6:  BTFSC  FD8.2
3EF8:  INCF   23,F
3EFA:  MOVFF  01,854
3EFE:  MOVFF  00,853
3F02:  MOVLW  1E
3F04:  ADDWF  xD3,W
3F06:  MOVWF  FE9
3F08:  MOVLW  02
3F0A:  ADDWFC xD4,W
3F0C:  MOVWF  FEA
3F0E:  MOVF   FEF,W
3F10:  ANDLW  0F
3F12:  ADDLW  30
3F14:  MOVLB  8
3F16:  MOVWF  x55
3F18:  MOVLB  9
3F1A:  CLRF   x16
3F1C:  CLRF   x15
3F1E:  MOVFF  01,914
3F22:  MOVFF  00,913
3F26:  MOVWF  x17
3F28:  MOVLB  0
3F2A:  RCALL  3A6C
....................          }  
3F2C:  MOVLB  6
3F2E:  INCF   xD3,F
3F30:  BTFSC  FD8.2
3F32:  INCF   xD4,F
3F34:  BRA    3ED0
....................          memset(Track2,0,sizeof(Track2)); 
3F36:  MOVLW  02
3F38:  MOVWF  FEA
3F3A:  MOVLW  1E
3F3C:  MOVWF  FE9
3F3E:  CLRF   00
3F40:  CLRF   02
3F42:  MOVLW  28
3F44:  MOVWF  01
3F46:  MOVLB  0
3F48:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
3F4C:  MOVLW  0D
3F4E:  MOVLB  9
3F50:  MOVWF  x0C
3F52:  MOVLB  0
3F54:  CALL   1604
3F58:  MOVLW  0A
3F5A:  MOVLB  9
3F5C:  MOVWF  x0C
3F5E:  MOVLB  0
3F60:  CALL   1604
....................         fprintf(COM2,"Done"); 
3F64:  MOVLW  D0
3F66:  MOVWF  FF6
3F68:  MOVLW  05
3F6A:  MOVWF  FF7
3F6C:  CALL   172E
....................              
....................         fprintf(COM2,"\r\n"); 
3F70:  MOVLW  0D
3F72:  MOVLB  9
3F74:  MOVWF  x0C
3F76:  MOVLB  0
3F78:  CALL   1604
3F7C:  MOVLW  0A
3F7E:  MOVLB  9
3F80:  MOVWF  x0C
3F82:  MOVLB  0
3F84:  CALL   1604
....................         fprintf(COM2,"Waiting for PIN number"); 
3F88:  MOVLW  D6
3F8A:  MOVWF  FF6
3F8C:  MOVLW  05
3F8E:  MOVWF  FF7
3F90:  CALL   172E
....................         memset(key_data,0,sizeof(key_data));  
3F94:  MOVLW  01
3F96:  MOVWF  FEA
3F98:  MOVLW  4A
3F9A:  MOVWF  FE9
3F9C:  CLRF   00
3F9E:  CLRF   02
3FA0:  MOVLW  10
3FA2:  MOVWF  01
3FA4:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
3FA8:  MOVLW  0D
3FAA:  MOVLB  9
3FAC:  MOVWF  x0C
3FAE:  MOVLB  0
3FB0:  CALL   1604
3FB4:  MOVLW  0A
3FB6:  MOVLB  9
3FB8:  MOVWF  x0C
3FBA:  MOVLB  0
3FBC:  CALL   1604
....................         charac_timeout=0; 
3FC0:  MOVLB  1
3FC2:  CLRF   x00
3FC4:  MOVLB  0
3FC6:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3FC8:  MOVFF  23,8FA
3FCC:  MOVFF  22,8F9
3FD0:  MOVFF  21,8F8
3FD4:  MOVFF  20,8F7
3FD8:  MOVLW  19
3FDA:  MOVLB  8
3FDC:  MOVWF  xFB
3FDE:  MOVLB  0
3FE0:  RCALL  3B6A
....................       datinbuf=0; 
3FE2:  MOVLB  6
3FE4:  CLRF   xD5
....................       saving_flag=0; 
3FE6:  CLRF   xD8
....................       data_avai=1; 
3FE8:  MOVLW  01
3FEA:  MOVWF  xD9
....................       enable_getpin=1; 
3FEC:  MOVLB  1
3FEE:  MOVWF  x45
....................       charac_timeout=0; 
3FF0:  CLRF   x00
3FF2:  MOVLB  0
3FF4:  CLRF   xFF
....................       key_count_ms=0; 
3FF6:  MOVLB  1
3FF8:  CLRF   x47
3FFA:  MOVLB  8
3FFC:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3FFE:  MOVLB  0
4000:  GOTO   5A9C (RETURN)
.................... //========================= 
.................... void saving_card_encrypt() 
.................... { 
*
4FD0:  MOVLB  8
4FD2:  CLRF   x54
....................    int8 temp,i,j,u; 
....................    int8 countbyte=0; 
....................    int16 tempcount; 
....................    int8 carddata[numdataofonecard]; 
....................    int8 encryptblock[16]; 
....................    int8 tempkey[16]; 
....................    saving_flag=1; 
4FD4:  MOVLW  01
4FD6:  MOVLB  6
4FD8:  MOVWF  xD8
....................    ptr_card=(int32)((get_countcard()*numdataofonecard)+ptr_start); 
4FDA:  MOVLB  0
4FDC:  CALL   351C
4FE0:  MOVFF  02,8F8
4FE4:  MOVFF  01,8F7
4FE8:  MOVLB  8
4FEA:  RLCF   xF7,F
4FEC:  RLCF   xF8,F
4FEE:  RLCF   xF7,F
4FF0:  RLCF   xF8,F
4FF2:  RLCF   xF7,F
4FF4:  RLCF   xF8,F
4FF6:  RLCF   xF7,F
4FF8:  RLCF   xF8,F
4FFA:  RLCF   xF7,F
4FFC:  RLCF   xF8,F
4FFE:  RLCF   xF7,F
5000:  RLCF   xF8,F
5002:  RLCF   xF7,F
5004:  RLCF   xF8,F
5006:  MOVLW  80
5008:  ANDWF  xF7,F
500A:  MOVLW  96
500C:  ADDWF  xF7,W
500E:  MOVWF  01
5010:  MOVLW  00
5012:  ADDWFC xF8,W
5014:  MOVFF  01,20
5018:  MOVWF  21
501A:  CLRF   22
501C:  CLRF   23
....................    if(datinbuf==0)  
501E:  MOVLB  6
5020:  MOVF   xD5,F
5022:  BNZ   5046
....................    { 
....................       countbit_T1=0; 
5024:  CLRF   xCA
5026:  CLRF   xC9
....................       countbit_T2=0; 
5028:  CLRF   xCC
502A:  CLRF   xCB
....................       bug_countbit_T1=0; 
502C:  CLRF   xCE
502E:  CLRF   xCD
....................       bug_countbit_T2=0; 
5030:  CLRF   xD0
5032:  CLRF   xCF
....................       if(data_avai==0)charac_timeout=0xffffffff; 
5034:  MOVF   xD9,F
5036:  BNZ   5042
5038:  MOVLB  1
503A:  SETF   x00
503C:  MOVLB  0
503E:  SETF   xFF
5040:  MOVLB  6
....................       saving_flag=0; 
5042:  CLRF   xD8
....................       return; 
5044:  BRA    549C
....................    }//*/ 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
5046:  MOVLW  EE
5048:  MOVWF  FF6
504A:  MOVLW  05
504C:  MOVWF  FF7
504E:  MOVLB  0
5050:  CALL   172E
....................    //key_count=0; 
....................    enable_getpin=1; 
5054:  MOVLW  01
5056:  MOVLB  1
5058:  MOVWF  x45
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
505A:  MOVFF  6CA,856
505E:  MOVFF  6C9,855
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
5062:  MOVLB  8
5064:  CLRF   xF7
5066:  MOVFF  856,8F9
506A:  MOVFF  855,8F8
506E:  MOVLW  02
5070:  MOVWF  xFB
5072:  MOVLW  46
5074:  MOVWF  xFA
5076:  MOVLW  01
5078:  MOVWF  xFD
507A:  MOVLW  CF
507C:  MOVWF  xFC
507E:  MOVLB  0
5080:  CALL   35B4
....................    countbit_T1=0; 
5084:  MOVLB  6
5086:  CLRF   xCA
5088:  CLRF   xC9
....................    tempcount=countbit_T2;    
508A:  MOVFF  6CC,856
508E:  MOVFF  6CB,855
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
5092:  MOVLW  01
5094:  MOVLB  8
5096:  MOVWF  xF7
5098:  MOVFF  856,8F9
509C:  MOVFF  855,8F8
50A0:  MOVLW  05
50A2:  MOVWF  xFB
50A4:  MOVLW  98
50A6:  MOVWF  xFA
50A8:  MOVLW  02
50AA:  MOVWF  xFD
50AC:  MOVLW  1E
50AE:  MOVWF  xFC
50B0:  MOVLB  0
50B2:  CALL   35B4
....................    countbit_T2=0; 
50B6:  MOVLB  6
50B8:  CLRF   xCC
50BA:  CLRF   xCB
....................    saving_flag=0; 
50BC:  CLRF   xD8
....................    temp=Track1[0]+0x20; 
50BE:  MOVLW  20
50C0:  MOVLB  1
50C2:  ADDWF  xCF,W
50C4:  MOVLB  8
50C6:  MOVWF  x50
....................    if((ptr_card<EEPROM_SIZE_stofkey)) 
50C8:  MOVF   23,F
50CA:  BTFSS  FD8.2
50CC:  BRA    549A
50CE:  MOVF   22,W
50D0:  SUBLW  01
50D2:  BTFSS  FD8.0
50D4:  BRA    549A
50D6:  BNZ   50EA
50D8:  MOVF   21,W
50DA:  SUBLW  C3
50DC:  BTFSS  FD8.0
50DE:  BRA    549A
50E0:  BNZ   50EA
50E2:  MOVF   20,W
50E4:  SUBLW  0D
50E6:  BTFSS  FD8.0
50E8:  BRA    549A
....................    { 
....................          countbyte = 0; 
50EA:  CLRF   x54
....................          carddata[countbyte++]=date;    
50EC:  MOVF   x54,W
50EE:  INCF   x54,F
50F0:  CLRF   03
50F2:  ADDLW  57
50F4:  MOVWF  FE9
50F6:  MOVLW  08
50F8:  ADDWFC 03,W
50FA:  MOVWF  FEA
50FC:  MOVFF  1CB,FEF
....................          carddata[countbyte++]=mon;    
5100:  MOVF   x54,W
5102:  INCF   x54,F
5104:  CLRF   03
5106:  ADDLW  57
5108:  MOVWF  FE9
510A:  MOVLW  08
510C:  ADDWFC 03,W
510E:  MOVWF  FEA
5110:  MOVFF  1CA,FEF
....................          carddata[countbyte++]=h;    
5114:  MOVF   x54,W
5116:  INCF   x54,F
5118:  CLRF   03
511A:  ADDLW  57
511C:  MOVWF  FE9
511E:  MOVLW  08
5120:  ADDWFC 03,W
5122:  MOVWF  FEA
5124:  MOVFF  1CC,FEF
....................          carddata[countbyte++]=min;    
5128:  MOVF   x54,W
512A:  INCF   x54,F
512C:  CLRF   03
512E:  ADDLW  57
5130:  MOVWF  FE9
5132:  MOVLW  08
5134:  ADDWFC 03,W
5136:  MOVWF  FEA
5138:  MOVFF  1CD,FEF
....................          carddata[countbyte++]=sec; 
513C:  MOVF   x54,W
513E:  INCF   x54,F
5140:  CLRF   03
5142:  ADDLW  57
5144:  MOVWF  FE9
5146:  MOVLW  08
5148:  ADDWFC 03,W
514A:  MOVWF  FEA
514C:  MOVFF  1CE,FEF
....................          carddata[countbyte++]=0xff;             
5150:  MOVF   x54,W
5152:  INCF   x54,F
5154:  CLRF   03
5156:  ADDLW  57
5158:  MOVWF  FE9
515A:  MOVLW  08
515C:  ADDWFC 03,W
515E:  MOVWF  FEA
5160:  SETF   FEF
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
5162:  MOVLB  6
5164:  CLRF   xD4
5166:  CLRF   xD3
5168:  MOVF   xD4,F
516A:  BNZ   51AC
516C:  MOVF   xD3,W
516E:  SUBLW  4E
5170:  BNC   51AC
....................          { 
....................             carddata[countbyte++] = (INT8)((Track1[countbit]&0b00111111)+0x20);       
5172:  MOVLB  8
5174:  MOVF   x54,W
5176:  INCF   x54,F
5178:  CLRF   03
517A:  ADDLW  57
517C:  MOVWF  01
517E:  MOVLW  08
5180:  ADDWFC 03,F
5182:  MOVLW  CF
5184:  MOVLB  6
5186:  ADDWF  xD3,W
5188:  MOVWF  FE9
518A:  MOVLW  01
518C:  ADDWFC xD4,W
518E:  MOVWF  FEA
5190:  MOVF   FEF,W
5192:  ANDLW  3F
5194:  ADDLW  20
5196:  MOVLB  8
5198:  MOVFF  03,FEA
519C:  MOVFF  01,FE9
51A0:  MOVWF  FEF
....................          } 
51A2:  MOVLB  6
51A4:  INCF   xD3,F
51A6:  BTFSC  FD8.2
51A8:  INCF   xD4,F
51AA:  BRA    5168
....................          memset(Track1,0,sizeof(Track1)); 
51AC:  MOVLW  01
51AE:  MOVWF  FEA
51B0:  MOVLW  CF
51B2:  MOVWF  FE9
51B4:  CLRF   00
51B6:  CLRF   02
51B8:  MOVLW  4F
51BA:  MOVWF  01
51BC:  MOVLB  0
51BE:  CALL   359A
....................          carddata[countbyte++]=0xfe; 
51C2:  MOVLB  8
51C4:  MOVF   x54,W
51C6:  INCF   x54,F
51C8:  CLRF   03
51CA:  ADDLW  57
51CC:  MOVWF  FE9
51CE:  MOVLW  08
51D0:  ADDWFC 03,W
51D2:  MOVWF  FEA
51D4:  MOVLW  FE
51D6:  MOVWF  FEF
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
51D8:  MOVLB  6
51DA:  CLRF   xD4
51DC:  CLRF   xD3
51DE:  MOVF   xD4,F
51E0:  BNZ   5222
51E2:  MOVF   xD3,W
51E4:  SUBLW  27
51E6:  BNC   5222
....................          { 
....................             carddata[countbyte++] = (INT8)((Track2[countbit]&0b00001111)+0x30);            
51E8:  MOVLB  8
51EA:  MOVF   x54,W
51EC:  INCF   x54,F
51EE:  CLRF   03
51F0:  ADDLW  57
51F2:  MOVWF  01
51F4:  MOVLW  08
51F6:  ADDWFC 03,F
51F8:  MOVLW  1E
51FA:  MOVLB  6
51FC:  ADDWF  xD3,W
51FE:  MOVWF  FE9
5200:  MOVLW  02
5202:  ADDWFC xD4,W
5204:  MOVWF  FEA
5206:  MOVF   FEF,W
5208:  ANDLW  0F
520A:  ADDLW  30
520C:  MOVLB  8
520E:  MOVFF  03,FEA
5212:  MOVFF  01,FE9
5216:  MOVWF  FEF
....................          }  
5218:  MOVLB  6
521A:  INCF   xD3,F
521C:  BTFSC  FD8.2
521E:  INCF   xD4,F
5220:  BRA    51DE
....................          for(i=countbyte;i<numdataofonecard;i++) 
5222:  MOVFF  854,851
5226:  MOVLB  8
5228:  MOVF   x51,W
522A:  SUBLW  7F
522C:  BNC   5242
....................          { 
....................              carddata[i] = 0; 
522E:  CLRF   03
5230:  MOVF   x51,W
5232:  ADDLW  57
5234:  MOVWF  FE9
5236:  MOVLW  08
5238:  ADDWFC 03,W
523A:  MOVWF  FEA
523C:  CLRF   FEF
....................          } 
523E:  INCF   x51,F
5240:  BRA    5228
....................          carddata[numdataofonecard-1]=0xfc; 
5242:  MOVLW  FC
5244:  MOVWF  xD6
....................          for(i=0;i<8;i++) 
5246:  CLRF   x51
5248:  MOVF   x51,W
524A:  SUBLW  07
524C:  BNC   5302
....................          { 
....................              for(j=0;j<16;j++) 
524E:  CLRF   x52
5250:  MOVF   x52,W
5252:  SUBLW  0F
5254:  BNC   528E
....................              { 
....................                 encryptblock[j] = carddata[i*16+j]; 
5256:  CLRF   03
5258:  MOVF   x52,W
525A:  ADDLW  D7
525C:  MOVWF  01
525E:  MOVLW  08
5260:  ADDWFC 03,F
5262:  MOVFF  03,8F8
5266:  MOVF   x51,W
5268:  MULLW  10
526A:  MOVF   FF3,W
526C:  ADDWF  x52,W
526E:  CLRF   03
5270:  ADDLW  57
5272:  MOVWF  FE9
5274:  MOVLW  08
5276:  ADDWFC 03,W
5278:  MOVWF  FEA
527A:  MOVFF  FEF,8F9
527E:  MOVFF  8F8,FEA
5282:  MOVFF  01,FE9
5286:  MOVFF  8F9,FEF
....................              } 
528A:  INCF   x52,F
528C:  BRA    5250
....................              EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
528E:  MOVLB  9
5290:  CLRF   x07
5292:  CLRF   x06
5294:  CLRF   x05
5296:  MOVLW  3F
5298:  MOVWF  x04
529A:  CLRF   x0B
529C:  CLRF   x0A
529E:  CLRF   x09
52A0:  MOVLW  20
52A2:  MOVWF  x08
52A4:  MOVLW  01
52A6:  MOVWF  x0D
52A8:  MOVWF  x0C
52AA:  MOVLB  0
52AC:  CALL   4004
....................              aes_enc_dec((unsigned int8 *)&encryptblock[0], (unsigned int8 *)&crypto_key[0],0); 
52B0:  MOVLW  08
52B2:  MOVLB  8
52B4:  MOVWF  xF8
52B6:  MOVLW  D7
52B8:  MOVWF  xF7
52BA:  MOVLW  01
52BC:  MOVWF  xFA
52BE:  MOVWF  xF9
52C0:  CLRF   xFB
52C2:  MOVLB  0
52C4:  CALL   40FA
....................              /*for(u=0;u<16;u++) 
....................              { 
....................                 encryptblock[u];  
....................                 fprintf(COM2,"%x",encryptblock[u]); 
....................              }*/ 
....................              EEPROM_write(ptr_card,16,encryptblock); 
52C8:  MOVFF  23,903
52CC:  MOVFF  22,902
52D0:  MOVFF  21,901
52D4:  MOVFF  20,900
52D8:  MOVLB  9
52DA:  CLRF   x07
52DC:  CLRF   x06
52DE:  CLRF   x05
52E0:  MOVLW  10
52E2:  MOVWF  x04
52E4:  MOVLW  08
52E6:  MOVWF  x09
52E8:  MOVLW  D7
52EA:  MOVWF  x08
52EC:  MOVLB  0
52EE:  RCALL  4EF6
....................              ptr_card=ptr_card+16; 
52F0:  MOVLW  10
52F2:  ADDWF  20,F
52F4:  MOVLW  00
52F6:  ADDWFC 21,F
52F8:  ADDWFC 22,F
52FA:  ADDWFC 23,F
....................          } 
52FC:  MOVLB  8
52FE:  INCF   x51,F
5300:  BRA    5248
....................          fprintf(COM2,"\r\n"); 
5302:  MOVLW  0D
5304:  MOVLB  9
5306:  MOVWF  x0C
5308:  MOVLB  0
530A:  CALL   1604
530E:  MOVLW  0A
5310:  MOVLB  9
5312:  MOVWF  x0C
5314:  MOVLB  0
5316:  CALL   1604
....................          fprintf(COM2,"card data: %lu",ptr_card); 
531A:  MOVLW  04
531C:  MOVWF  FF6
531E:  MOVLW  06
5320:  MOVWF  FF7
5322:  MOVLW  0B
5324:  MOVLB  8
5326:  MOVWF  xF7
5328:  MOVLB  0
532A:  CALL   164A
532E:  MOVLW  41
5330:  MOVWF  FE9
5332:  MOVFF  23,8FA
5336:  MOVFF  22,8F9
533A:  MOVFF  21,8F8
533E:  MOVFF  20,8F7
5342:  CALL   22FA
....................          fprintf(COM2,"\r\n"); 
5346:  MOVLW  0D
5348:  MOVLB  9
534A:  MOVWF  x0C
534C:  MOVLB  0
534E:  CALL   1604
5352:  MOVLW  0A
5354:  MOVLB  9
5356:  MOVWF  x0C
5358:  MOVLB  0
535A:  CALL   1604
....................          EEPROM_read(ptr_card-128,128,&carddata); 
535E:  MOVLW  80
5360:  SUBWF  20,W
5362:  MOVLB  8
5364:  MOVWF  xF7
5366:  MOVLW  00
5368:  SUBWFB 21,W
536A:  MOVWF  xF8
536C:  MOVLW  00
536E:  SUBWFB 22,W
5370:  MOVWF  xF9
5372:  MOVLW  00
5374:  SUBWFB 23,W
5376:  MOVWF  xFA
5378:  MOVFF  FE8,907
537C:  MOVFF  8F9,906
5380:  MOVFF  8F8,905
5384:  MOVFF  8F7,904
5388:  MOVLB  9
538A:  CLRF   x0B
538C:  CLRF   x0A
538E:  CLRF   x09
5390:  MOVLW  80
5392:  MOVWF  x08
5394:  MOVLW  08
5396:  MOVWF  x0D
5398:  MOVLW  57
539A:  MOVWF  x0C
539C:  MOVLB  0
539E:  CALL   4004
....................          for(i=0;i<numdataofonecard;i++) 
53A2:  MOVLB  8
53A4:  CLRF   x51
53A6:  MOVF   x51,W
53A8:  SUBLW  7F
53AA:  BNC   53D2
....................          { 
....................              fprintf(COM2,"%x",carddata[i]); 
53AC:  CLRF   03
53AE:  MOVF   x51,W
53B0:  ADDLW  57
53B2:  MOVWF  FE9
53B4:  MOVLW  08
53B6:  ADDWFC 03,W
53B8:  MOVWF  FEA
53BA:  MOVFF  FEF,8F7
53BE:  MOVFF  8F7,901
53C2:  MOVLW  57
53C4:  MOVLB  9
53C6:  MOVWF  x02
53C8:  MOVLB  0
53CA:  RCALL  4F86
....................          } 
53CC:  MOVLB  8
53CE:  INCF   x51,F
53D0:  BRA    53A6
....................          memset(Track2,0,sizeof(Track2)); 
53D2:  MOVLW  02
53D4:  MOVWF  FEA
53D6:  MOVLW  1E
53D8:  MOVWF  FE9
53DA:  CLRF   00
53DC:  CLRF   02
53DE:  MOVLW  28
53E0:  MOVWF  01
53E2:  MOVLB  0
53E4:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
53E8:  MOVLW  0D
53EA:  MOVLB  9
53EC:  MOVWF  x0C
53EE:  MOVLB  0
53F0:  CALL   1604
53F4:  MOVLW  0A
53F6:  MOVLB  9
53F8:  MOVWF  x0C
53FA:  MOVLB  0
53FC:  CALL   1604
....................         fprintf(COM2,"Done"); 
5400:  MOVLW  14
5402:  MOVWF  FF6
5404:  MOVLW  06
5406:  MOVWF  FF7
5408:  CALL   172E
....................              
....................         fprintf(COM2,"\r\n"); 
540C:  MOVLW  0D
540E:  MOVLB  9
5410:  MOVWF  x0C
5412:  MOVLB  0
5414:  CALL   1604
5418:  MOVLW  0A
541A:  MOVLB  9
541C:  MOVWF  x0C
541E:  MOVLB  0
5420:  CALL   1604
....................         fprintf(COM2,"Waiting for PIN number"); 
5424:  MOVLW  1A
5426:  MOVWF  FF6
5428:  MOVLW  06
542A:  MOVWF  FF7
542C:  CALL   172E
....................         memset(key_data,0,sizeof(key_data));  
5430:  MOVLW  01
5432:  MOVWF  FEA
5434:  MOVLW  4A
5436:  MOVWF  FE9
5438:  CLRF   00
543A:  CLRF   02
543C:  MOVLW  10
543E:  MOVWF  01
5440:  CALL   359A
....................         fprintf(COM2,"\r\n"); 
5444:  MOVLW  0D
5446:  MOVLB  9
5448:  MOVWF  x0C
544A:  MOVLB  0
544C:  CALL   1604
5450:  MOVLW  0A
5452:  MOVLB  9
5454:  MOVWF  x0C
5456:  MOVLB  0
5458:  CALL   1604
....................         charac_timeout=0; 
545C:  MOVLB  1
545E:  CLRF   x00
5460:  MOVLB  0
5462:  CLRF   xFF
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       //ptr_card = ptr_card+numdataofonecard; 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5464:  MOVFF  23,8FA
5468:  MOVFF  22,8F9
546C:  MOVFF  21,8F8
5470:  MOVFF  20,8F7
5474:  MOVLW  19
5476:  MOVLB  8
5478:  MOVWF  xFB
547A:  MOVLB  0
547C:  CALL   3B6A
....................       datinbuf=0; 
5480:  MOVLB  6
5482:  CLRF   xD5
....................       saving_flag=0; 
5484:  CLRF   xD8
....................       data_avai=1; 
5486:  MOVLW  01
5488:  MOVWF  xD9
....................       enable_getpin=1; 
548A:  MOVLB  1
548C:  MOVWF  x45
....................       charac_timeout=0; 
548E:  CLRF   x00
5490:  MOVLB  0
5492:  CLRF   xFF
....................       key_count_ms=0; 
5494:  MOVLB  1
5496:  CLRF   x47
5498:  MOVLB  8
549A:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
549C:  MOVLB  0
549E:  GOTO   5AA6 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
18EE:  MOVLW  01
18F0:  MOVLB  8
18F2:  MOVWF  x4D
18F4:  MOVWF  x4E
18F6:  MOVWF  x4F
18F8:  MOVWF  x50
18FA:  CLRF   x51
18FC:  MOVWF  x52
18FE:  MOVWF  x53
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1900:  MOVLB  6
1902:  CLRF   xD2
1904:  CLRF   xD1
....................    mcr_timeout=0; 
1906:  CLRF   xC7
1908:  CLRF   xC6
190A:  CLRF   xC5
190C:  CLRF   xC4
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
190E:  MOVF   xD2,W
1910:  SUBLW  FD
1912:  BNC   1930
1914:  BNZ   191C
1916:  MOVF   xD1,W
1918:  SUBLW  E7
191A:  BNC   1930
191C:  BSF    F93.1
191E:  BTFSS  F81.1
1920:  BRA    1930
1922:  BSF    F94.5
1924:  BTFSS  F82.5
1926:  BRA    1930
....................       card_timeout++; 
1928:  INCF   xD1,F
192A:  BTFSC  FD8.2
192C:  INCF   xD2,F
....................    } 
192E:  BRA    190E
....................    card_timeout=0; 
1930:  CLRF   xD2
1932:  CLRF   xD1
....................    buffertrack1[bug_countbit_T1++]=0; 
1934:  MOVFF  6CE,03
1938:  MOVF   xCD,W
193A:  INCF   xCD,F
193C:  BTFSC  FD8.2
193E:  INCF   xCE,F
1940:  MOVLB  8
1942:  MOVWF  x56
1944:  MOVLW  46
1946:  ADDWF  x56,W
1948:  MOVWF  FE9
194A:  MOVLW  02
194C:  ADDWFC 03,W
194E:  MOVWF  FEA
1950:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1952:  MOVLB  6
1954:  MOVFF  6CE,03
1958:  MOVF   xCD,W
195A:  INCF   xCD,F
195C:  BTFSC  FD8.2
195E:  INCF   xCE,F
1960:  MOVLB  8
1962:  MOVWF  x56
1964:  MOVLW  46
1966:  ADDWF  x56,W
1968:  MOVWF  FE9
196A:  MOVLW  02
196C:  ADDWFC 03,W
196E:  MOVWF  FEA
1970:  MOVLW  01
1972:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1974:  MOVLB  6
1976:  MOVFF  6D0,03
197A:  MOVF   xCF,W
197C:  INCF   xCF,F
197E:  BTFSC  FD8.2
1980:  INCF   xD0,F
1982:  MOVLB  8
1984:  MOVWF  x56
1986:  MOVLW  98
1988:  ADDWF  x56,W
198A:  MOVWF  FE9
198C:  MOVLW  05
198E:  ADDWFC 03,W
1990:  MOVWF  FEA
1992:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1994:  MOVLB  6
1996:  MOVFF  6D0,03
199A:  MOVF   xCF,W
199C:  INCF   xCF,F
199E:  BTFSC  FD8.2
19A0:  INCF   xD0,F
19A2:  MOVLB  8
19A4:  MOVWF  x56
19A6:  MOVLW  98
19A8:  ADDWF  x56,W
19AA:  MOVWF  FE9
19AC:  MOVLW  05
19AE:  ADDWFC 03,W
19B0:  MOVWF  FEA
19B2:  MOVLW  01
19B4:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
19B6:  MOVLB  6
19B8:  MOVF   xCE,W
19BA:  SUBLW  03
19BC:  BTFSS  FD8.0
19BE:  BRA    1A9E
19C0:  BNZ   19CA
19C2:  MOVF   xCD,W
19C4:  SUBLW  51
19C6:  BTFSS  FD8.0
19C8:  BRA    1A9E
19CA:  MOVF   xD0,W
19CC:  SUBLW  01
19CE:  BTFSS  FD8.0
19D0:  BRA    1A9E
19D2:  BNZ   19DA
19D4:  MOVF   xCF,W
19D6:  SUBLW  2B
19D8:  BNC   1A9E
19DA:  MOVF   xD2,W
19DC:  SUBLW  FF
19DE:  BNC   1A9E
19E0:  BNZ   19E8
19E2:  MOVF   xD1,W
19E4:  SUBLW  DB
19E6:  BNC   1A9E
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
19E8:  MOVF   xDB,F
19EA:  BZ    19F4
....................          { 
....................             bug_countbit_T1=0; 
19EC:  CLRF   xCE
19EE:  CLRF   xCD
....................             bug_countbit_T2=0; 
19F0:  CLRF   xD0
19F2:  CLRF   xCF
....................          } 
....................          card_timeout++; 
19F4:  INCF   xD1,F
19F6:  BTFSC  FD8.2
19F8:  INCF   xD2,F
....................          mcr_timeout=0; 
19FA:  CLRF   xC7
19FC:  CLRF   xC6
19FE:  CLRF   xC5
1A00:  CLRF   xC4
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1A02:  BSF    F93.2
1A04:  MOVLB  8
1A06:  CLRF   x4D
1A08:  BTFSC  F81.2
1A0A:  INCF   x4D,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1A0C:  MOVF   x4D,F
1A0E:  BNZ   1A4C
1A10:  DECFSZ x4E,W
1A12:  BRA    1A4C
....................          { 
....................             ST1_old = 0; 
1A14:  CLRF   x4E
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1A16:  MOVLW  46
1A18:  MOVLB  6
1A1A:  ADDWF  xCD,W
1A1C:  MOVWF  FE9
1A1E:  MOVLW  02
1A20:  ADDWFC xCE,W
1A22:  MOVWF  FEA
1A24:  BSF    F93.1
1A26:  MOVLW  00
1A28:  BTFSS  F81.1
1A2A:  MOVLW  01
1A2C:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1A2E:  MOVLW  98
1A30:  ADDWF  xCF,W
1A32:  MOVWF  FE9
1A34:  MOVLW  05
1A36:  ADDWFC xD0,W
1A38:  MOVWF  FEA
1A3A:  MOVFF  851,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1A3E:  INCF   xCD,F
1A40:  BTFSC  FD8.2
1A42:  INCF   xCE,F
....................             card_timeout=0; 
1A44:  CLRF   xD2
1A46:  CLRF   xD1
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A48:  BRA    1A56
1A4A:  MOVLB  8
1A4C:  DECFSZ x4D,W
1A4E:  BRA    1A54
1A50:  MOVLW  01
1A52:  MOVWF  x4E
1A54:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A56:  BSF    F93.3
1A58:  MOVLB  8
1A5A:  CLRF   x4F
1A5C:  BTFSC  F81.3
1A5E:  INCF   x4F,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A60:  MOVF   x4F,F
1A62:  BNZ   1A82
1A64:  DECFSZ x50,W
1A66:  BRA    1A82
....................          { 
....................             ST2_old = 0; 
1A68:  CLRF   x50
....................             Bit_t2 = !input(MCR_DATA2); 
1A6A:  BSF    F94.5
1A6C:  CLRF   x51
1A6E:  BTFSS  F82.5
1A70:  INCF   x51,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A72:  MOVLB  6
1A74:  INCF   xCF,F
1A76:  BTFSC  FD8.2
1A78:  INCF   xD0,F
....................             card_timeout=0; 
1A7A:  CLRF   xD2
1A7C:  CLRF   xD1
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A7E:  BRA    1A8C
1A80:  MOVLB  8
1A82:  DECFSZ x4F,W
1A84:  BRA    1A8A
1A86:  MOVLW  01
1A88:  MOVWF  x50
1A8A:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1A8C:  BSF    F93.0
1A8E:  BTFSS  F81.0
1A90:  BRA    1A9C
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1A92:  CLRF   xDB
....................             card_timeout=65500; 
1A94:  SETF   xD2
1A96:  MOVLW  DC
1A98:  MOVWF  xD1
....................             break;            
1A9A:  BRA    1A9E
....................          } 
....................       } 
1A9C:  BRA    19B8
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1A9E:  CLRF   xD2
1AA0:  CLRF   xD1
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1AA2:  MOVLB  9
1AA4:  CLRF   x15
1AA6:  MOVFF  6CE,917
1AAA:  MOVFF  6CD,916
1AAE:  MOVLW  02
1AB0:  MOVWF  x19
1AB2:  MOVLW  46
1AB4:  MOVWF  x18
1AB6:  MOVLB  0
1AB8:  CALL   0A02
1ABC:  MOVFF  01,852
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1AC0:  MOVLW  01
1AC2:  MOVLB  9
1AC4:  MOVWF  x15
1AC6:  MOVFF  6D0,917
1ACA:  MOVFF  6CF,916
1ACE:  MOVLW  05
1AD0:  MOVWF  x19
1AD2:  MOVLW  98
1AD4:  MOVWF  x18
1AD6:  MOVLB  0
1AD8:  CALL   0A02
1ADC:  MOVFF  01,853
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1AE0:  MOVLB  6
1AE2:  DECFSZ xD6,W
1AE4:  BRA    1B7A
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1AE6:  MOVLW  32
1AE8:  MOVWF  FF6
1AEA:  MOVLW  06
1AEC:  MOVWF  FF7
1AEE:  MOVLW  0E
1AF0:  MOVLB  8
1AF2:  MOVWF  xF7
1AF4:  MOVLB  0
1AF6:  RCALL  164A
1AF8:  MOVLW  10
1AFA:  MOVWF  FE9
1AFC:  MOVFF  6CE,857
1B00:  MOVFF  6CD,856
1B04:  RCALL  1672
1B06:  MOVLW  0D
1B08:  MOVLB  9
1B0A:  MOVWF  x0C
1B0C:  MOVLB  0
1B0E:  RCALL  1604
1B10:  MOVLW  0A
1B12:  MOVLB  9
1B14:  MOVWF  x0C
1B16:  MOVLB  0
1B18:  RCALL  1604
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1B1A:  MOVLW  46
1B1C:  MOVWF  FF6
1B1E:  MOVLW  06
1B20:  MOVWF  FF7
1B22:  MOVLW  0E
1B24:  MOVLB  8
1B26:  MOVWF  xF7
1B28:  MOVLB  0
1B2A:  RCALL  164A
1B2C:  MOVLW  10
1B2E:  MOVWF  FE9
1B30:  MOVFF  6D0,857
1B34:  MOVFF  6CF,856
1B38:  RCALL  1672
1B3A:  MOVLW  0D
1B3C:  MOVLB  9
1B3E:  MOVWF  x0C
1B40:  MOVLB  0
1B42:  RCALL  1604
1B44:  MOVLW  0A
1B46:  MOVLB  9
1B48:  MOVWF  x0C
1B4A:  MOVLB  0
1B4C:  RCALL  1604
....................          debug_reader();       
1B4E:  BRA    1836
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B50:  MOVLB  8
1B52:  MOVF   x52,F
1B54:  BNZ   1B64
1B56:  MOVLW  5A
1B58:  MOVWF  FF6
1B5A:  MOVLW  06
1B5C:  MOVWF  FF7
1B5E:  MOVLB  0
1B60:  RCALL  172E
1B62:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B64:  MOVF   x53,F
1B66:  BNZ   1B76
1B68:  MOVLW  70
1B6A:  MOVWF  FF6
1B6C:  MOVLW  06
1B6E:  MOVWF  FF7
1B70:  MOVLB  0
1B72:  RCALL  172E
1B74:  MOVLB  8
....................       } 
....................          else 
1B76:  BRA    1B86
1B78:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B7A:  MOVLW  0F
1B7C:  MOVLB  8
1B7E:  MOVWF  x56
1B80:  MOVLB  0
1B82:  RCALL  18C6
1B84:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1B86:  MOVF   x52,F
1B88:  BZ    1B8E
1B8A:  MOVF   x53,F
1B8C:  BNZ   1BAE
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1B8E:  MOVLB  6
1B90:  CLRF   xD0
1B92:  CLRF   xCF
....................          bug_countbit_T1=0; 
1B94:  CLRF   xCE
1B96:  CLRF   xCD
....................          reading_fg=0; 
1B98:  CLRF   xDA
....................          count_reading_error++; 
1B9A:  INCF   xDB,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1B9C:  CLRF   xC7
1B9E:  CLRF   xC6
1BA0:  CLRF   xC5
1BA2:  CLRF   xC4
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1BA4:  MOVLW  00
1BA6:  MOVWF  01
1BA8:  BRA    1BE8
....................       } 
....................          else  
1BAA:  BRA    1BE4
1BAC:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1BAE:  MOVLW  01
1BB0:  MOVLB  6
1BB2:  MOVWF  xD5
....................             reading_fg=1; 
1BB4:  MOVWF  xDA
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1BB6:  MOVFF  6D0,6CC
1BBA:  MOVFF  6CF,6CB
....................             countbit_T1=bug_countbit_T1; 
1BBE:  MOVFF  6CE,6CA
1BC2:  MOVFF  6CD,6C9
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1BC6:  CLRF   xCE
1BC8:  CLRF   xCD
....................             bug_countbit_T2=0;  
1BCA:  CLRF   xD0
1BCC:  CLRF   xCF
....................             mcr_timeout=0; 
1BCE:  CLRF   xC7
1BD0:  CLRF   xC6
1BD2:  CLRF   xC5
1BD4:  CLRF   xC4
....................             charac_timeout=0; 
1BD6:  MOVLB  1
1BD8:  CLRF   x00
1BDA:  MOVLB  0
1BDC:  CLRF   xFF
....................             return 1; 
1BDE:  MOVWF  01
1BE0:  MOVLB  6
1BE2:  BRA    1BE8
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1BE4:  MOVLW  00
1BE6:  MOVWF  01
.................... } 
1BE8:  MOVLB  0
1BEA:  GOTO   1C10 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       delay_us(500); 
1BEE:  MOVLW  02
1BF0:  MOVLB  8
1BF2:  MOVWF  x4D
1BF4:  MOVLW  FA
1BF6:  MOVWF  x4E
1BF8:  MOVLB  0
1BFA:  GOTO   0686
1BFE:  MOVLB  8
1C00:  DECFSZ x4D,F
1C02:  BRA    1BF4
....................       if(saving_flag==1) return;      
1C04:  MOVLB  6
1C06:  DECFSZ xD8,W
1C08:  BRA    1C0C
1C0A:  BRA    1C22
....................       cardread_st=mcr_read(); 
1C0C:  MOVLB  0
1C0E:  BRA    18EE
1C10:  MOVFF  01,6D7
....................       mcr_timeout=0; 
1C14:  MOVLB  6
1C16:  CLRF   xC7
1C18:  CLRF   xC6
1C1A:  CLRF   xC5
1C1C:  CLRF   xC4
....................       card_timeout=0;      
1C1E:  CLRF   xD2
1C20:  CLRF   xD1
.................... } 
.................... //==================================== 
.................... #if 0 
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... #endif 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
1C22:  BCF    FF0.0
1C24:  MOVLB  0
1C26:  GOTO   006C
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
6A38:  CLRF   19
6A3A:  BTFSC  FF2.7
6A3C:  BSF    19.7
6A3E:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
6A40:  MOVLB  9
6A42:  CLRF   x16
6A44:  CLRF   x15
6A46:  CLRF   x14
6A48:  MOVLW  3C
6A4A:  MOVWF  x13
6A4C:  MOVLW  03
6A4E:  MOVWF  x17
6A50:  MOVLB  0
6A52:  CALL   3A6C
6A56:  BTFSC  19.7
6A58:  BSF    FF2.7
6A5A:  CLRF   19
6A5C:  BTFSC  FF2.7
6A5E:  BSF    19.7
6A60:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
6A62:  MOVLB  9
6A64:  CLRF   x16
6A66:  CLRF   x15
6A68:  CLRF   x14
6A6A:  MOVLW  3A
6A6C:  MOVWF  x13
6A6E:  MOVLW  01
6A70:  MOVWF  x17
6A72:  MOVLB  0
6A74:  CALL   3A6C
6A78:  BTFSC  19.7
6A7A:  BSF    FF2.7
6A7C:  CLRF   19
6A7E:  BTFSC  FF2.7
6A80:  BSF    19.7
6A82:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV);  
6A84:  MOVLB  9
6A86:  CLRF   x1B
6A88:  CLRF   x1A
6A8A:  CLRF   x19
6A8C:  MOVLW  3A
6A8E:  MOVWF  x18
6A90:  MOVLB  0
6A92:  CALL   3450
6A96:  BTFSC  19.7
6A98:  BSF    FF2.7
6A9A:  MOVFF  01,6E2
.................... } 
6A9E:  GOTO   6E42 (RETURN)
.................... //================================ 
.................... void downloaddataregular() 
.................... { 
*
62A6:  MOVLB  7
62A8:  CLRF   xF6
62AA:  CLRF   xF5
....................     int8 index,i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 temp[50]; 
....................     rec[0]=0; 
62AC:  MOVLB  0
62AE:  CLRF   x7D
62B0:  CLRF   19
62B2:  BTFSC  FF2.7
62B4:  BSF    19.7
62B6:  BCF    FF2.7
....................     count_card_tg=get_countcard(); 
62B8:  CALL   351C
62BC:  BTFSC  19.7
62BE:  BSF    FF2.7
62C0:  MOVFF  02,6E1
62C4:  MOVFF  01,6E0
62C8:  CLRF   19
62CA:  BTFSC  FF2.7
62CC:  BSF    19.7
62CE:  BCF    FF2.7
....................     adr=count_card*numdata; 
62D0:  MOVFF  6DF,856
62D4:  MOVFF  6DE,855
62D8:  MOVLB  8
62DA:  CLRF   x58
62DC:  MOVLW  7C
62DE:  MOVWF  x57
62E0:  MOVLB  0
62E2:  CALL   3578
62E6:  BTFSC  19.7
62E8:  BSF    FF2.7
62EA:  MOVFF  02,7F6
62EE:  MOVFF  01,7F5
....................     addr_key=EEPROM_KEY_ST; 
62F2:  MOVLB  6
62F4:  CLRF   xE6
62F6:  MOVLW  01
62F8:  MOVWF  xE5
62FA:  MOVLW  C3
62FC:  MOVWF  xE4
62FE:  MOVLW  0F
6300:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
6302:  MOVF   xDF,W
6304:  SUBWF  xE1,W
6306:  BTFSS  FD8.0
6308:  BRA    66A2
630A:  BNZ   6314
630C:  MOVF   xDE,W
630E:  SUBWF  xE0,W
6310:  BTFSS  FD8.0
6312:  BRA    66A2
6314:  CLRF   19
6316:  BTFSC  FF2.7
6318:  BSF    19.7
631A:  BCF    FF2.7
....................         adr=count_card*numdata+ptr_start; 
631C:  MOVFF  6DF,856
6320:  MOVFF  6DE,855
6324:  MOVLB  8
6326:  CLRF   x58
6328:  MOVLW  7C
632A:  MOVWF  x57
632C:  MOVLB  0
632E:  CALL   3578
6332:  BTFSC  19.7
6334:  BSF    FF2.7
6336:  MOVLW  96
6338:  MOVLB  8
633A:  ADDWF  01,W
633C:  MOVLB  7
633E:  MOVWF  xF5
6340:  MOVLW  00
6342:  MOVLB  8
6344:  ADDWFC 02,W
6346:  MOVLB  7
6348:  MOVWF  xF6
....................         EEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
634A:  MOVLW  7C
634C:  SUBWF  xF5,W
634E:  MOVLB  8
6350:  MOVWF  x2B
6352:  MOVLW  00
6354:  MOVLB  7
6356:  SUBWFB xF6,W
6358:  MOVLB  8
635A:  MOVWF  x2C
635C:  CLRF   19
635E:  BTFSC  FF2.7
6360:  BSF    19.7
6362:  BCF    FF2.7
6364:  MOVLB  9
6366:  CLRF   x07
6368:  CLRF   x06
636A:  MOVWF  x05
636C:  MOVFF  82B,904
6370:  CLRF   x0B
6372:  CLRF   x0A
6374:  CLRF   x09
6376:  MOVLW  7C
6378:  MOVWF  x08
637A:  CLRF   x0D
637C:  MOVLW  7D
637E:  MOVWF  x0C
6380:  MOVLB  0
6382:  CALL   4004
6386:  BTFSC  19.7
6388:  BSF    FF2.7
....................         fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
638A:  MOVLW  10
638C:  MOVWF  FE9
638E:  CLRF   19
6390:  BTFSC  FF2.7
6392:  BSF    19.7
6394:  BCF    FF2.7
6396:  MOVFF  6DF,851
639A:  MOVFF  6DE,850
639E:  CALL   5924
63A2:  BTFSC  19.7
63A4:  BSF    FF2.7
63A6:  CLRF   19
63A8:  BTFSC  FF2.7
63AA:  BSF    19.7
63AC:  BCF    FF2.7
63AE:  MOVLW  29
63B0:  MOVLB  9
63B2:  MOVWF  x0C
63B4:  MOVLB  0
63B6:  CALL   1604
63BA:  BTFSC  19.7
63BC:  BSF    FF2.7
63BE:  MOVFF  7D,82B
63C2:  MOVLW  01
63C4:  MOVLB  8
63C6:  MOVWF  x2C
63C8:  MOVLB  0
63CA:  RCALL  6190
63CC:  CLRF   19
63CE:  BTFSC  FF2.7
63D0:  BSF    19.7
63D2:  BCF    FF2.7
63D4:  MOVLW  2F
63D6:  MOVLB  9
63D8:  MOVWF  x0C
63DA:  MOVLB  0
63DC:  CALL   1604
63E0:  BTFSC  19.7
63E2:  BSF    FF2.7
63E4:  MOVFF  7E,82B
63E8:  MOVLW  01
63EA:  MOVLB  8
63EC:  MOVWF  x2C
63EE:  MOVLB  0
63F0:  RCALL  6190
63F2:  CLRF   19
63F4:  BTFSC  FF2.7
63F6:  BSF    19.7
63F8:  BCF    FF2.7
63FA:  MOVLW  20
63FC:  MOVLB  9
63FE:  MOVWF  x0C
6400:  MOVLB  0
6402:  CALL   1604
6406:  BTFSC  19.7
6408:  BSF    FF2.7
640A:  MOVFF  7F,82B
640E:  MOVLW  01
6410:  MOVLB  8
6412:  MOVWF  x2C
6414:  MOVLB  0
6416:  RCALL  6190
6418:  CLRF   19
641A:  BTFSC  FF2.7
641C:  BSF    19.7
641E:  BCF    FF2.7
6420:  MOVLW  3A
6422:  MOVLB  9
6424:  MOVWF  x0C
6426:  MOVLB  0
6428:  CALL   1604
642C:  BTFSC  19.7
642E:  BSF    FF2.7
6430:  MOVFF  80,82B
6434:  MOVLW  01
6436:  MOVLB  8
6438:  MOVWF  x2C
643A:  MOVLB  0
643C:  RCALL  6190
643E:  CLRF   19
6440:  BTFSC  FF2.7
6442:  BSF    19.7
6444:  BCF    FF2.7
6446:  MOVLW  3A
6448:  MOVLB  9
644A:  MOVWF  x0C
644C:  MOVLB  0
644E:  CALL   1604
6452:  BTFSC  19.7
6454:  BSF    FF2.7
6456:  MOVFF  81,82B
645A:  MOVLW  01
645C:  MOVLB  8
645E:  MOVWF  x2C
6460:  MOVLB  0
6462:  RCALL  6190
....................         ee_dat=0; 
6464:  MOVLB  6
6466:  CLRF   xDD
....................         index=0; 
6468:  MOVLB  7
646A:  CLRF   xF3
....................         fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
646C:  MOVLW  2A
646E:  MOVWF  FF6
6470:  MOVLW  1C
6472:  MOVWF  FF7
6474:  CLRF   19
6476:  BTFSC  FF2.7
6478:  BSF    19.7
647A:  BCF    FF2.7
647C:  MOVLB  0
647E:  CALL   172E
6482:  BTFSC  19.7
6484:  BSF    FF2.7
....................         while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................         { 
6486:  MOVLB  7
6488:  MOVF   xF3,W
648A:  SUBLW  4E
648C:  BNC   64EA
648E:  MOVLB  6
6490:  MOVF   xDD,W
6492:  SUBLW  3F
6494:  BTFSS  FD8.2
6496:  BRA    649C
6498:  MOVLB  7
649A:  BRA    64EA
....................            ee_dat = rec[index+5]; 
649C:  MOVLW  05
649E:  MOVLB  7
64A0:  ADDWF  xF3,W
64A2:  CLRF   03
64A4:  ADDLW  7D
64A6:  MOVWF  FE9
64A8:  MOVLW  00
64AA:  ADDWFC 03,W
64AC:  MOVWF  FEA
64AE:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
64B2:  MOVLB  6
64B4:  MOVF   xDD,W
64B6:  SUBLW  1F
64B8:  BC    64D6
64BA:  MOVF   xDD,W
64BC:  SUBLW  7E
64BE:  BNC   64D6
64C0:  CLRF   19
64C2:  BTFSC  FF2.7
64C4:  BSF    19.7
64C6:  BCF    FF2.7
64C8:  MOVFF  6DD,90C
64CC:  MOVLB  0
64CE:  CALL   1604
64D2:  BTFSC  19.7
64D4:  BSF    FF2.7
....................            index++; 
64D6:  MOVLB  7
64D8:  INCF   xF3,F
....................            if(ee_dat==0)break; 
64DA:  MOVLB  6
64DC:  MOVF   xDD,F
64DE:  BNZ   64E4
64E0:  MOVLB  7
64E2:  BRA    64EA
....................         } 
64E4:  MOVLB  0
64E6:  BRA    6486
64E8:  MOVLB  7
....................         fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
64EA:  MOVLW  3C
64EC:  MOVWF  FF6
64EE:  MOVLW  1C
64F0:  MOVWF  FF7
64F2:  CLRF   19
64F4:  BTFSC  FF2.7
64F6:  BSF    19.7
64F8:  BCF    FF2.7
64FA:  MOVLB  0
64FC:  CALL   172E
6500:  BTFSC  19.7
6502:  BSF    FF2.7
....................         index=0; 
6504:  MOVLB  7
6506:  CLRF   xF3
....................         ee_dat=0; 
6508:  MOVLB  6
650A:  CLRF   xDD
....................         while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................         { 
650C:  MOVLB  7
650E:  MOVF   xF3,W
6510:  SUBLW  27
6512:  BNC   6572
6514:  MOVLB  6
6516:  MOVF   xDD,W
6518:  SUBLW  3F
651A:  BTFSS  FD8.2
651C:  BRA    6522
651E:  MOVLB  7
6520:  BRA    6572
....................            ee_dat = rec[index+5+numbyteoftrack1]; 
6522:  MOVLW  05
6524:  MOVLB  7
6526:  ADDWF  xF3,W
6528:  ADDLW  4F
652A:  CLRF   03
652C:  ADDLW  7D
652E:  MOVWF  FE9
6530:  MOVLW  00
6532:  ADDWFC 03,W
6534:  MOVWF  FEA
6536:  MOVFF  FEF,6DD
....................            if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
653A:  MOVLB  6
653C:  MOVF   xDD,W
653E:  SUBLW  1F
6540:  BC    655E
6542:  MOVF   xDD,W
6544:  SUBLW  7E
6546:  BNC   655E
6548:  CLRF   19
654A:  BTFSC  FF2.7
654C:  BSF    19.7
654E:  BCF    FF2.7
6550:  MOVFF  6DD,90C
6554:  MOVLB  0
6556:  CALL   1604
655A:  BTFSC  19.7
655C:  BSF    FF2.7
....................            index++; 
655E:  MOVLB  7
6560:  INCF   xF3,F
....................            if(ee_dat==0)break; 
6562:  MOVLB  6
6564:  MOVF   xDD,F
6566:  BNZ   656E
6568:  MOVLB  7
656A:  BRA    6572
656C:  MOVLB  6
....................         } 
656E:  BRA    650C
6570:  MOVLB  7
....................         index=0; 
6572:  CLRF   xF3
....................  
....................         fprintf(COM2,"\r\nPIN Number:\r\n"); 
6574:  MOVLW  4E
6576:  MOVWF  FF6
6578:  MOVLW  1C
657A:  MOVWF  FF7
657C:  CLRF   19
657E:  BTFSC  FF2.7
6580:  BSF    19.7
6582:  BCF    FF2.7
6584:  MOVLB  0
6586:  CALL   172E
658A:  BTFSC  19.7
658C:  BSF    FF2.7
....................  
....................         if((ptr_card_key>addr_key)) //&& 
658E:  MOVLB  6
6590:  MOVF   xE6,W
6592:  SUBWF  27,W
6594:  BTFSS  FD8.0
6596:  BRA    669A
6598:  BNZ   65B6
659A:  MOVF   xE5,W
659C:  SUBWF  26,W
659E:  BTFSS  FD8.0
65A0:  BRA    669A
65A2:  BNZ   65B6
65A4:  MOVF   xE4,W
65A6:  SUBWF  25,W
65A8:  BTFSS  FD8.0
65AA:  BRA    669A
65AC:  BNZ   65B6
65AE:  MOVF   24,W
65B0:  SUBWF  xE3,W
65B2:  BTFSC  FD8.0
65B4:  BRA    669A
....................         { 
....................            i=0; 
65B6:  MOVLB  7
65B8:  CLRF   xF4
....................            do 
....................            { 
....................               ee_dat=read_ext_eeprom(i+addr_key); 
65BA:  MOVF   xF4,W
65BC:  MOVLB  6
65BE:  ADDWF  xE3,W
65C0:  MOVLB  8
65C2:  MOVWF  x2B
65C4:  MOVLW  00
65C6:  MOVLB  6
65C8:  ADDWFC xE4,W
65CA:  MOVLB  8
65CC:  MOVWF  x2C
65CE:  MOVLW  00
65D0:  MOVLB  6
65D2:  ADDWFC xE5,W
65D4:  MOVLB  8
65D6:  MOVWF  x2D
65D8:  MOVLW  00
65DA:  MOVLB  6
65DC:  ADDWFC xE6,W
65DE:  MOVLB  8
65E0:  MOVWF  x2E
65E2:  CLRF   19
65E4:  BTFSC  FF2.7
65E6:  BSF    19.7
65E8:  BCF    FF2.7
65EA:  MOVFF  FE8,91B
65EE:  MOVFF  82D,91A
65F2:  MOVFF  82C,919
65F6:  MOVFF  82B,918
65FA:  MOVLB  0
65FC:  CALL   3450
6600:  BTFSC  19.7
6602:  BSF    FF2.7
6604:  MOVFF  01,6DD
....................               if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
6608:  MOVLB  6
660A:  MOVF   xDD,W
660C:  SUBLW  2F
660E:  BC    6616
6610:  MOVF   xDD,W
6612:  SUBLW  39
6614:  BC    662E
6616:  MOVF   xDD,W
6618:  SUBLW  23
661A:  BZ    662E
661C:  MOVF   xDD,W
661E:  SUBLW  2A
6620:  BZ    662E
6622:  MOVF   xDD,W
6624:  SUBLW  40
6626:  BC    6644
6628:  MOVF   xDD,W
662A:  SUBLW  5A
662C:  BNC   6644
662E:  CLRF   19
6630:  BTFSC  FF2.7
6632:  BSF    19.7
6634:  BCF    FF2.7
....................               { 
....................                  fprintf(COM2,"%c",ee_dat); 
6636:  MOVFF  6DD,90C
663A:  MOVLB  0
663C:  CALL   1604
6640:  BTFSC  19.7
6642:  BSF    FF2.7
....................               } 
....................               i++; 
6644:  MOVLB  7
6646:  INCF   xF4,F
....................            } 
....................            while((i<wideofkeystore)&&(ee_dat!=0)); 
6648:  MOVF   xF4,W
664A:  SUBLW  0F
664C:  BNC   665A
664E:  MOVLB  6
6650:  MOVF   xDD,F
6652:  BTFSC  FD8.2
6654:  BRA    665A
6656:  MOVLB  7
6658:  BRA    65BA
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
665A:  MOVLW  10
665C:  MOVLB  6
665E:  ADDWF  xE3,F
6660:  MOVLW  00
6662:  ADDWFC xE4,F
6664:  ADDWFC xE5,F
6666:  ADDWFC xE6,F
6668:  CLRF   19
666A:  BTFSC  FF2.7
666C:  BSF    19.7
666E:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
6670:  MOVLW  0A
6672:  MOVLB  9
6674:  MOVWF  x0C
6676:  MOVLB  0
6678:  CALL   1604
667C:  BTFSC  19.7
667E:  BSF    FF2.7
6680:  CLRF   19
6682:  BTFSC  FF2.7
6684:  BSF    19.7
6686:  BCF    FF2.7
6688:  MOVLW  0D
668A:  MOVLB  9
668C:  MOVWF  x0C
668E:  MOVLB  0
6690:  CALL   1604
6694:  BTFSC  19.7
6696:  BSF    FF2.7
6698:  MOVLB  6
....................         } 
....................         count_card++; 
669A:  INCF   xDE,F
669C:  BTFSC  FD8.2
669E:  INCF   xDF,F
....................     }  
66A0:  BRA    6302
.................... } 
66A2:  MOVLB  0
66A4:  GOTO   6C74 (RETURN)
.................... //================================ 
.................... void downloaddataEncrypt() 
.................... { 
66A8:  MOVLB  7
66AA:  CLRF   xF5
66AC:  CLRF   xF4
66AE:  CLRF   19
66B0:  BTFSC  FF2.7
66B2:  BSF    19.7
66B4:  BCF    FF2.7
....................     int8 i; 
....................     unsigned long adr=0; 
....................     int16 countchar; 
....................     int8 keydatatemp[16]; 
....................     count_card_tg=get_countcard(); 
66B6:  MOVLB  0
66B8:  CALL   351C
66BC:  BTFSC  19.7
66BE:  BSF    FF2.7
66C0:  MOVFF  02,6E1
66C4:  MOVFF  01,6E0
....................     adr=count_card*numdataofonecard; 
66C8:  MOVLB  6
66CA:  RLCF   xDE,W
66CC:  MOVLB  7
66CE:  MOVWF  xF4
66D0:  MOVLB  6
66D2:  RLCF   xDF,W
66D4:  MOVLB  7
66D6:  MOVWF  xF5
66D8:  RLCF   xF4,F
66DA:  RLCF   xF5,F
66DC:  RLCF   xF4,F
66DE:  RLCF   xF5,F
66E0:  RLCF   xF4,F
66E2:  RLCF   xF5,F
66E4:  RLCF   xF4,F
66E6:  RLCF   xF5,F
66E8:  RLCF   xF4,F
66EA:  RLCF   xF5,F
66EC:  RLCF   xF4,F
66EE:  RLCF   xF5,F
66F0:  MOVLW  80
66F2:  ANDWF  xF4,F
....................     addr_key=EEPROM_KEY_ST; 
66F4:  MOVLB  6
66F6:  CLRF   xE6
66F8:  MOVLW  01
66FA:  MOVWF  xE5
66FC:  MOVLW  C3
66FE:  MOVWF  xE4
6700:  MOVLW  0F
6702:  MOVWF  xE3
....................     while(count_card<=count_card_tg) 
....................     { 
6704:  MOVF   xDF,W
6706:  SUBWF  xE1,W
6708:  BTFSS  FD8.0
670A:  BRA    68C2
670C:  BNZ   6716
670E:  MOVF   xDE,W
6710:  SUBWF  xE0,W
6712:  BTFSS  FD8.0
6714:  BRA    68C2
....................         adr=count_card*numdataofonecard+ptr_start; 
6716:  RLCF   xDE,W
6718:  MOVLB  8
671A:  MOVWF  x08
671C:  MOVLB  6
671E:  RLCF   xDF,W
6720:  MOVLB  8
6722:  MOVWF  x09
6724:  RLCF   x08,F
6726:  RLCF   x09,F
6728:  RLCF   x08,F
672A:  RLCF   x09,F
672C:  RLCF   x08,F
672E:  RLCF   x09,F
6730:  RLCF   x08,F
6732:  RLCF   x09,F
6734:  RLCF   x08,F
6736:  RLCF   x09,F
6738:  RLCF   x08,F
673A:  RLCF   x09,F
673C:  MOVLW  80
673E:  ANDWF  x08,F
6740:  MOVLW  96
6742:  ADDWF  x08,W
6744:  MOVLB  7
6746:  MOVWF  xF4
6748:  MOVLW  00
674A:  MOVLB  8
674C:  ADDWFC x09,W
674E:  MOVLB  7
6750:  MOVWF  xF5
....................         memset(rec,0,sizeof(rec)); 
6752:  CLRF   FEA
6754:  MOVLW  7D
6756:  MOVWF  FE9
6758:  CLRF   00
675A:  CLRF   02
675C:  MOVLW  80
675E:  MOVWF  01
6760:  MOVLB  0
6762:  CALL   359A
....................         EEPROM_read((unsigned int16)(adr-numdataofonecard),numdataofonecard,rec); 
6766:  MOVLW  80
6768:  MOVLB  7
676A:  SUBWF  xF4,W
676C:  MOVLB  8
676E:  MOVWF  x08
6770:  MOVLW  00
6772:  MOVLB  7
6774:  SUBWFB xF5,W
6776:  MOVLB  8
6778:  MOVWF  x09
677A:  CLRF   19
677C:  BTFSC  FF2.7
677E:  BSF    19.7
6780:  BCF    FF2.7
6782:  MOVLB  9
6784:  CLRF   x07
6786:  CLRF   x06
6788:  MOVWF  x05
678A:  MOVFF  808,904
678E:  CLRF   x0B
6790:  CLRF   x0A
6792:  CLRF   x09
6794:  MOVLW  80
6796:  MOVWF  x08
6798:  CLRF   x0D
679A:  MOVLW  7D
679C:  MOVWF  x0C
679E:  MOVLB  0
67A0:  CALL   4004
67A4:  BTFSC  19.7
67A6:  BSF    FF2.7
....................         for(i=0;i<numdataofonecard;i++) 
67A8:  MOVLB  7
67AA:  CLRF   xF3
67AC:  MOVF   xF3,W
67AE:  SUBLW  7F
67B0:  BNC   67E6
....................         { 
....................            fprintf(COM2,"%x",rec[i]);  
67B2:  CLRF   03
67B4:  MOVF   xF3,W
67B6:  ADDLW  7D
67B8:  MOVWF  FE9
67BA:  MOVLW  00
67BC:  ADDWFC 03,W
67BE:  MOVWF  FEA
67C0:  MOVFF  FEF,808
67C4:  CLRF   19
67C6:  BTFSC  FF2.7
67C8:  BSF    19.7
67CA:  BCF    FF2.7
67CC:  MOVFF  808,901
67D0:  MOVLW  57
67D2:  MOVLB  9
67D4:  MOVWF  x02
67D6:  MOVLB  0
67D8:  CALL   4F86
67DC:  BTFSC  19.7
67DE:  BSF    FF2.7
....................         } 
67E0:  MOVLB  7
67E2:  INCF   xF3,F
67E4:  BRA    67AC
....................  
....................         if((ptr_card_key>addr_key)) 
67E6:  MOVLB  6
67E8:  MOVF   xE6,W
67EA:  SUBWF  27,W
67EC:  BNC   68BA
67EE:  BNZ   6806
67F0:  MOVF   xE5,W
67F2:  SUBWF  26,W
67F4:  BNC   68BA
67F6:  BNZ   6806
67F8:  MOVF   xE4,W
67FA:  SUBWF  25,W
67FC:  BNC   68BA
67FE:  BNZ   6806
6800:  MOVF   24,W
6802:  SUBWF  xE3,W
6804:  BC    68BA
6806:  CLRF   19
6808:  BTFSC  FF2.7
680A:  BSF    19.7
680C:  BCF    FF2.7
....................         { 
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            EEPROM_read(addr_key,wideofkeystore,keydatatemp); 
680E:  MOVFF  6E6,907
6812:  MOVFF  6E5,906
6816:  MOVFF  6E4,905
681A:  MOVFF  6E3,904
681E:  MOVLB  9
6820:  CLRF   x0B
6822:  CLRF   x0A
6824:  CLRF   x09
6826:  MOVLW  10
6828:  MOVWF  x08
682A:  MOVLW  07
682C:  MOVWF  x0D
682E:  MOVLW  F8
6830:  MOVWF  x0C
6832:  MOVLB  0
6834:  CALL   4004
6838:  BTFSC  19.7
683A:  BSF    FF2.7
....................            for(i=0;i<wideofkeystore;i++) 
683C:  MOVLB  7
683E:  CLRF   xF3
6840:  MOVF   xF3,W
6842:  SUBLW  0F
6844:  BNC   687A
....................            { 
....................                fprintf(COM2,"%x",keydatatemp[i]); 
6846:  CLRF   03
6848:  MOVF   xF3,W
684A:  ADDLW  F8
684C:  MOVWF  FE9
684E:  MOVLW  07
6850:  ADDWFC 03,W
6852:  MOVWF  FEA
6854:  MOVFF  FEF,808
6858:  CLRF   19
685A:  BTFSC  FF2.7
685C:  BSF    19.7
685E:  BCF    FF2.7
6860:  MOVFF  808,901
6864:  MOVLW  57
6866:  MOVLB  9
6868:  MOVWF  x02
686A:  MOVLB  0
686C:  CALL   4F86
6870:  BTFSC  19.7
6872:  BSF    FF2.7
....................            } 
6874:  MOVLB  7
6876:  INCF   xF3,F
6878:  BRA    6840
....................            //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................            addr_key=addr_key+wideofkeystore; 
687A:  MOVLW  10
687C:  MOVLB  6
687E:  ADDWF  xE3,F
6880:  MOVLW  00
6882:  ADDWFC xE4,F
6884:  ADDWFC xE5,F
6886:  ADDWFC xE6,F
6888:  CLRF   19
688A:  BTFSC  FF2.7
688C:  BSF    19.7
688E:  BCF    FF2.7
....................            fprintf(COM2,"\n\r"); 
6890:  MOVLW  0A
6892:  MOVLB  9
6894:  MOVWF  x0C
6896:  MOVLB  0
6898:  CALL   1604
689C:  BTFSC  19.7
689E:  BSF    FF2.7
68A0:  CLRF   19
68A2:  BTFSC  FF2.7
68A4:  BSF    19.7
68A6:  BCF    FF2.7
68A8:  MOVLW  0D
68AA:  MOVLB  9
68AC:  MOVWF  x0C
68AE:  MOVLB  0
68B0:  CALL   1604
68B4:  BTFSC  19.7
68B6:  BSF    FF2.7
68B8:  MOVLB  6
....................         } 
....................         count_card++; 
68BA:  INCF   xDE,F
68BC:  BTFSC  FD8.2
68BE:  INCF   xDF,F
....................     }  
68C0:  BRA    6704
.................... } 
68C2:  MOVLB  0
68C4:  GOTO   6C74 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int16 countchar; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
6BB6:  MOVLW  06
6BB8:  MOVWF  FEA
6BBA:  MOVLW  E7
6BBC:  MOVWF  FE9
6BBE:  CALL   5F40
6BC2:  CLRF   19
6BC4:  BTFSC  FF2.7
6BC6:  BSF    19.7
6BC8:  BCF    FF2.7
6BCA:  MOVLW  3E
6BCC:  MOVLB  9
6BCE:  MOVWF  x0C
6BD0:  MOVLB  0
6BD2:  CALL   1604
6BD6:  BTFSC  19.7
6BD8:  BSF    FF2.7
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
6BDA:  MOVLW  01
6BDC:  MOVLB  7
6BDE:  MOVWF  xF3
6BE0:  MOVLW  14
6BE2:  MOVWF  xF4
6BE4:  MOVLW  01
6BE6:  MOVWF  xF6
6BE8:  MOVLW  62
6BEA:  MOVWF  xF5
6BEC:  MOVLB  0
6BEE:  CALL   5FC0
6BF2:  CLRF   19
6BF4:  BTFSC  FF2.7
6BF6:  BSF    19.7
6BF8:  BCF    FF2.7
....................       printf("\n\r"); 
6BFA:  MOVLW  0A
6BFC:  MOVLB  9
6BFE:  MOVWF  x0C
6C00:  MOVLB  0
6C02:  CALL   1604
6C06:  BTFSC  19.7
6C08:  BSF    FF2.7
6C0A:  CLRF   19
6C0C:  BTFSC  FF2.7
6C0E:  BSF    19.7
6C10:  BCF    FF2.7
6C12:  MOVLW  0D
6C14:  MOVLB  9
6C16:  MOVWF  x0C
6C18:  MOVLB  0
6C1A:  CALL   1604
6C1E:  BTFSC  19.7
6C20:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
6C22:  CLRF   FEA
6C24:  MOVLW  41
6C26:  MOVWF  FE9
6C28:  MOVLW  00
6C2A:  CALL   0356
6C2E:  TBLRD*-
6C30:  TBLRD*+
6C32:  MOVF   FF5,W
6C34:  MOVWF  FEE
6C36:  IORLW  00
6C38:  BNZ   6C30
....................       index=0; 
6C3A:  MOVLB  7
6C3C:  CLRF   xBD
....................       ee_dat=0; 
6C3E:  MOVLB  6
6C40:  CLRF   xDD
....................       count_card=1; 
6C42:  CLRF   xDF
6C44:  MOVLW  01
6C46:  MOVWF  xDE
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6C48:  MOVLB  7
6C4A:  MOVWF  xF4
6C4C:  MOVLW  62
6C4E:  MOVWF  xF3
6C50:  CLRF   xF6
6C52:  MOVLW  41
6C54:  MOVWF  xF5
6C56:  MOVLB  0
6C58:  CALL   60F8
6C5C:  MOVF   01,F
6C5E:  BNZ   6C74
....................       { 
....................          if(cryption_enable==0) downloaddataregular(); 
6C60:  MOVLB  1
6C62:  MOVF   x22,F
6C64:  BNZ   6C70
6C66:  MOVLB  0
6C68:  GOTO   62A6
....................          else downloaddataEncrypt(); 
6C6C:  MOVLB  0
6C6E:  BRA    6C74
6C70:  MOVLB  0
6C72:  BRA    66A8
....................       }  
....................       strcpy(buffer2,"f"); 
6C74:  CLRF   FEA
6C76:  MOVLW  41
6C78:  MOVWF  FE9
6C7A:  MOVLW  00
6C7C:  CALL   0368
6C80:  TBLRD*-
6C82:  TBLRD*+
6C84:  MOVF   FF5,W
6C86:  MOVWF  FEE
6C88:  IORLW  00
6C8A:  BNZ   6C82
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6C8C:  MOVLW  01
6C8E:  MOVLB  7
6C90:  MOVWF  xF4
6C92:  MOVLW  62
6C94:  MOVWF  xF3
6C96:  CLRF   xF6
6C98:  MOVLW  41
6C9A:  MOVWF  xF5
6C9C:  MOVLB  0
6C9E:  CALL   60F8
6CA2:  MOVF   01,F
6CA4:  BNZ   6CD8
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6CA6:  MOVLW  5E
6CA8:  MOVWF  FF6
6CAA:  MOVLW  1C
6CAC:  MOVWF  FF7
6CAE:  CLRF   19
6CB0:  BTFSC  FF2.7
6CB2:  BSF    19.7
6CB4:  BCF    FF2.7
6CB6:  CALL   172E
6CBA:  BTFSC  19.7
6CBC:  BSF    FF2.7
....................          format_eepromext(); 
6CBE:  BRA    68C8
....................          fprintf(COM2," exit\n\r");  
6CC0:  MOVLW  6C
6CC2:  MOVWF  FF6
6CC4:  MOVLW  1C
6CC6:  MOVWF  FF7
6CC8:  CLRF   19
6CCA:  BTFSC  FF2.7
6CCC:  BSF    19.7
6CCE:  BCF    FF2.7
6CD0:  CALL   172E
6CD4:  BTFSC  19.7
6CD6:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
6CD8:  CLRF   FEA
6CDA:  MOVLW  41
6CDC:  MOVWF  FE9
6CDE:  MOVLW  00
6CE0:  CALL   037A
6CE4:  TBLRD*-
6CE6:  TBLRD*+
6CE8:  MOVF   FF5,W
6CEA:  MOVWF  FEE
6CEC:  IORLW  00
6CEE:  BNZ   6CE6
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6CF0:  MOVLW  01
6CF2:  MOVLB  7
6CF4:  MOVWF  xF4
6CF6:  MOVLW  62
6CF8:  MOVWF  xF3
6CFA:  CLRF   xF6
6CFC:  MOVLW  41
6CFE:  MOVWF  xF5
6D00:  MOVLB  0
6D02:  CALL   60F8
6D06:  MOVF   01,F
6D08:  BNZ   6D3C
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6D0A:  MOVLW  74
6D0C:  MOVWF  FF6
6D0E:  MOVLW  1C
6D10:  MOVWF  FF7
6D12:  CLRF   19
6D14:  BTFSC  FF2.7
6D16:  BSF    19.7
6D18:  BCF    FF2.7
6D1A:  CALL   172E
6D1E:  BTFSC  19.7
6D20:  BSF    FF2.7
....................          ease_eeprom(); 
6D22:  BRA    6964
....................          fprintf(COM2," exit\n\r");  
6D24:  MOVLW  82
6D26:  MOVWF  FF6
6D28:  MOVLW  1C
6D2A:  MOVWF  FF7
6D2C:  CLRF   19
6D2E:  BTFSC  FF2.7
6D30:  BSF    19.7
6D32:  BCF    FF2.7
6D34:  CALL   172E
6D38:  BTFSC  19.7
6D3A:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6D3C:  CLRF   FEA
6D3E:  MOVLW  41
6D40:  MOVWF  FE9
6D42:  MOVLW  00
6D44:  CALL   0390
6D48:  TBLRD*-
6D4A:  TBLRD*+
6D4C:  MOVF   FF5,W
6D4E:  MOVWF  FEE
6D50:  IORLW  00
6D52:  BNZ   6D4A
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6D54:  MOVLW  01
6D56:  MOVLB  7
6D58:  MOVWF  xF4
6D5A:  MOVLW  62
6D5C:  MOVWF  xF3
6D5E:  CLRF   xF6
6D60:  MOVLW  41
6D62:  MOVWF  xF5
6D64:  MOVLB  0
6D66:  CALL   60F8
6D6A:  MOVF   01,F
6D6C:  BNZ   6DA4
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
6D6E:  MOVLW  8A
6D70:  MOVWF  FF6
6D72:  MOVLW  1C
6D74:  MOVWF  FF7
6D76:  CLRF   19
6D78:  BTFSC  FF2.7
6D7A:  BSF    19.7
6D7C:  BCF    FF2.7
6D7E:  CALL   172E
6D82:  BTFSC  19.7
6D84:  BSF    FF2.7
....................          reset_password(); 
6D86:  BRA    69E8
....................          init_password(); 
6D88:  CALL   5D2E
....................          fprintf(COM2," exit\n\r");  
6D8C:  MOVLW  A0
6D8E:  MOVWF  FF6
6D90:  MOVLW  1C
6D92:  MOVWF  FF7
6D94:  CLRF   19
6D96:  BTFSC  FF2.7
6D98:  BSF    19.7
6D9A:  BCF    FF2.7
6D9C:  CALL   172E
6DA0:  BTFSC  19.7
6DA2:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
6DA4:  CLRF   FEA
6DA6:  MOVLW  41
6DA8:  MOVWF  FE9
6DAA:  MOVLW  00
6DAC:  CALL   03A6
6DB0:  TBLRD*-
6DB2:  TBLRD*+
6DB4:  MOVF   FF5,W
6DB6:  MOVWF  FEE
6DB8:  IORLW  00
6DBA:  BNZ   6DB2
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6DBC:  MOVLW  01
6DBE:  MOVLB  7
6DC0:  MOVWF  xF4
6DC2:  MOVLW  62
6DC4:  MOVWF  xF3
6DC6:  CLRF   xF6
6DC8:  MOVLW  41
6DCA:  MOVWF  xF5
6DCC:  MOVLB  0
6DCE:  CALL   60F8
6DD2:  MOVF   01,F
6DD4:  BNZ   6DF6
....................       { 
....................          keydebug_en=1; 
6DD6:  MOVLW  01
6DD8:  MOVLB  1
6DDA:  MOVWF  x44
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
6DDC:  MOVLW  A8
6DDE:  MOVWF  FF6
6DE0:  MOVLW  1C
6DE2:  MOVWF  FF7
6DE4:  CLRF   19
6DE6:  BTFSC  FF2.7
6DE8:  BSF    19.7
6DEA:  BCF    FF2.7
6DEC:  MOVLB  0
6DEE:  CALL   172E
6DF2:  BTFSC  19.7
6DF4:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
6DF6:  CLRF   FEA
6DF8:  MOVLW  41
6DFA:  MOVWF  FE9
6DFC:  MOVLW  00
6DFE:  CALL   03BC
6E02:  TBLRD*-
6E04:  TBLRD*+
6E06:  MOVF   FF5,W
6E08:  MOVWF  FEE
6E0A:  IORLW  00
6E0C:  BNZ   6E04
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6E0E:  MOVLW  01
6E10:  MOVLB  7
6E12:  MOVWF  xF4
6E14:  MOVLW  62
6E16:  MOVWF  xF3
6E18:  CLRF   xF6
6E1A:  MOVLW  41
6E1C:  MOVWF  xF5
6E1E:  MOVLB  0
6E20:  CALL   60F8
6E24:  MOVF   01,F
6E26:  BNZ   6E42
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6E28:  MOVLW  BC
6E2A:  MOVWF  FF6
6E2C:  MOVLW  1C
6E2E:  MOVWF  FF7
6E30:  CLRF   19
6E32:  BTFSC  FF2.7
6E34:  BSF    19.7
6E36:  BCF    FF2.7
6E38:  CALL   172E
6E3C:  BTFSC  19.7
6E3E:  BSF    FF2.7
....................          rstfact(); 
6E40:  BRA    6A38
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
6E42:  CLRF   FEA
6E44:  MOVLW  41
6E46:  MOVWF  FE9
6E48:  MOVLW  00
6E4A:  CALL   03D4
6E4E:  TBLRD*-
6E50:  TBLRD*+
6E52:  MOVF   FF5,W
6E54:  MOVWF  FEE
6E56:  IORLW  00
6E58:  BNZ   6E50
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6E5A:  MOVLW  01
6E5C:  MOVLB  7
6E5E:  MOVWF  xF4
6E60:  MOVLW  62
6E62:  MOVWF  xF3
6E64:  CLRF   xF6
6E66:  MOVLW  41
6E68:  MOVWF  xF5
6E6A:  MOVLB  0
6E6C:  CALL   60F8
6E70:  MOVF   01,F
6E72:  BNZ   6E9A
....................       { 
....................          mode=LOGOFF; 
6E74:  MOVLB  6
6E76:  CLRF   xDC
....................          keydebug_en=0; 
6E78:  MOVLB  1
6E7A:  CLRF   x44
....................          set_tris_a(0xff); 
6E7C:  MOVLW  FF
6E7E:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
6E80:  MOVLW  CC
6E82:  MOVWF  FF6
6E84:  MOVLW  1C
6E86:  MOVWF  FF7
6E88:  CLRF   19
6E8A:  BTFSC  FF2.7
6E8C:  BSF    19.7
6E8E:  BCF    FF2.7
6E90:  MOVLB  0
6E92:  CALL   172E
6E96:  BTFSC  19.7
6E98:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
6E9A:  CLRF   FEA
6E9C:  MOVLW  41
6E9E:  MOVWF  FE9
6EA0:  MOVLW  00
6EA2:  CALL   03E6
6EA6:  TBLRD*-
6EA8:  TBLRD*+
6EAA:  MOVF   FF5,W
6EAC:  MOVWF  FEE
6EAE:  IORLW  00
6EB0:  BNZ   6EA8
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6EB2:  MOVLW  01
6EB4:  MOVLB  7
6EB6:  MOVWF  xF4
6EB8:  MOVLW  62
6EBA:  MOVWF  xF3
6EBC:  CLRF   xF6
6EBE:  MOVLW  41
6EC0:  MOVWF  xF5
6EC2:  MOVLB  0
6EC4:  CALL   60F8
6EC8:  MOVF   01,F
6ECA:  BNZ   6F44
....................       { 
....................          fprintf(COM2,"New console name>"); 
6ECC:  MOVLW  D4
6ECE:  MOVWF  FF6
6ED0:  MOVLW  1C
6ED2:  MOVWF  FF7
6ED4:  CLRF   19
6ED6:  BTFSC  FF2.7
6ED8:  BSF    19.7
6EDA:  BCF    FF2.7
6EDC:  CALL   172E
6EE0:  BTFSC  19.7
6EE2:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,wide_strobe_nameconsole, console); 
6EE4:  MOVLW  01
6EE6:  MOVLB  7
6EE8:  MOVWF  xF3
6EEA:  MOVLW  10
6EEC:  MOVWF  xF4
6EEE:  MOVLW  06
6EF0:  MOVWF  xF6
6EF2:  MOVLW  E7
6EF4:  MOVWF  xF5
6EF6:  MOVLB  0
6EF8:  CALL   5FC0
6EFC:  CLRF   19
6EFE:  BTFSC  FF2.7
6F00:  BSF    19.7
6F02:  BCF    FF2.7
....................          EEPROM_write(strobe_nameconsole,wide_strobe_nameconsole,console); 
6F04:  MOVLB  9
6F06:  CLRF   x03
6F08:  CLRF   x02
6F0A:  CLRF   x01
6F0C:  MOVLW  28
6F0E:  MOVWF  x00
6F10:  CLRF   x07
6F12:  CLRF   x06
6F14:  CLRF   x05
6F16:  MOVLW  10
6F18:  MOVWF  x04
6F1A:  MOVLW  06
6F1C:  MOVWF  x09
6F1E:  MOVLW  E7
6F20:  MOVWF  x08
6F22:  MOVLB  0
6F24:  CALL   4EF6
6F28:  BTFSC  19.7
6F2A:  BSF    FF2.7
....................          fprintf(COM2," OK\n\r"); 
6F2C:  MOVLW  E6
6F2E:  MOVWF  FF6
6F30:  MOVLW  1C
6F32:  MOVWF  FF7
6F34:  CLRF   19
6F36:  BTFSC  FF2.7
6F38:  BSF    19.7
6F3A:  BCF    FF2.7
6F3C:  CALL   172E
6F40:  BTFSC  19.7
6F42:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
6F44:  CLRF   FEA
6F46:  MOVLW  41
6F48:  MOVWF  FE9
6F4A:  MOVLW  00
6F4C:  CALL   03F8
6F50:  TBLRD*-
6F52:  TBLRD*+
6F54:  MOVF   FF5,W
6F56:  MOVWF  FEE
6F58:  IORLW  00
6F5A:  BNZ   6F52
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6F5C:  MOVLW  01
6F5E:  MOVLB  7
6F60:  MOVWF  xF4
6F62:  MOVLW  62
6F64:  MOVWF  xF3
6F66:  CLRF   xF6
6F68:  MOVLW  41
6F6A:  MOVWF  xF5
6F6C:  MOVLB  0
6F6E:  CALL   60F8
6F72:  MOVF   01,F
6F74:  BTFSS  FD8.2
6F76:  BRA    7118
6F78:  CLRF   19
6F7A:  BTFSC  FF2.7
6F7C:  BSF    19.7
6F7E:  BCF    FF2.7
....................       { 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6F80:  MOVLB  9
6F82:  CLRF   x1B
6F84:  CLRF   x1A
6F86:  CLRF   x19
6F88:  MOVLW  3A
6F8A:  MOVWF  x18
6F8C:  MOVLB  0
6F8E:  CALL   3450
6F92:  BTFSC  19.7
6F94:  BSF    FF2.7
6F96:  MOVFF  01,6E2
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6F9A:  MOVLB  6
6F9C:  MOVF   xE2,F
6F9E:  BNZ   6FBE
6FA0:  MOVLW  EC
6FA2:  MOVWF  FF6
6FA4:  MOVLW  1C
6FA6:  MOVWF  FF7
6FA8:  CLRF   19
6FAA:  BTFSC  FF2.7
6FAC:  BSF    19.7
6FAE:  BCF    FF2.7
6FB0:  MOVLB  0
6FB2:  CALL   172E
6FB6:  BTFSC  19.7
6FB8:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6FBA:  BRA    6FD8
6FBC:  MOVLB  6
6FBE:  MOVLW  F0
6FC0:  MOVWF  FF6
6FC2:  MOVLW  1C
6FC4:  MOVWF  FF7
6FC6:  CLRF   19
6FC8:  BTFSC  FF2.7
6FCA:  BSF    19.7
6FCC:  BCF    FF2.7
6FCE:  MOVLB  0
6FD0:  CALL   172E
6FD4:  BTFSC  19.7
6FD6:  BSF    FF2.7
6FD8:  CLRF   19
6FDA:  BTFSC  FF2.7
6FDC:  BSF    19.7
6FDE:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
6FE0:  MOVLB  9
6FE2:  CLRF   x1B
6FE4:  CLRF   x1A
6FE6:  CLRF   x19
6FE8:  MOVLW  3C
6FEA:  MOVWF  x18
6FEC:  MOVLB  0
6FEE:  CALL   3450
6FF2:  BTFSC  19.7
6FF4:  BSF    FF2.7
6FF6:  MOVFF  01,15A
6FFA:  CLRF   19
6FFC:  BTFSC  FF2.7
6FFE:  BSF    19.7
7000:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
7002:  MOVLW  5B
7004:  MOVLB  9
7006:  MOVWF  x0C
7008:  MOVLB  0
700A:  CALL   1604
700E:  BTFSC  19.7
7010:  BSF    FF2.7
7012:  MOVFF  15A,7F3
7016:  MOVLW  1B
7018:  MOVLB  7
701A:  MOVWF  xF4
701C:  MOVLB  0
701E:  BRA    6AA2
7020:  CLRF   19
7022:  BTFSC  FF2.7
7024:  BSF    19.7
7026:  BCF    FF2.7
7028:  MOVLW  5D
702A:  MOVLB  9
702C:  MOVWF  x0C
702E:  MOVLB  0
7030:  CALL   1604
7034:  BTFSC  19.7
7036:  BSF    FF2.7
....................           
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
7038:  MOVFF  1CB,82B
703C:  MOVLW  01
703E:  MOVLB  8
7040:  MOVWF  x2C
7042:  MOVLB  0
7044:  CALL   6190
7048:  CLRF   19
704A:  BTFSC  FF2.7
704C:  BSF    19.7
704E:  BCF    FF2.7
7050:  MOVLW  2F
7052:  MOVLB  9
7054:  MOVWF  x0C
7056:  MOVLB  0
7058:  CALL   1604
705C:  BTFSC  19.7
705E:  BSF    FF2.7
7060:  MOVFF  1CA,82B
7064:  MOVLW  01
7066:  MOVLB  8
7068:  MOVWF  x2C
706A:  MOVLB  0
706C:  CALL   6190
7070:  CLRF   19
7072:  BTFSC  FF2.7
7074:  BSF    19.7
7076:  BCF    FF2.7
7078:  MOVLW  20
707A:  MOVLB  9
707C:  MOVWF  x0C
707E:  MOVLB  0
7080:  CALL   1604
7084:  BTFSC  19.7
7086:  BSF    FF2.7
7088:  MOVFF  1CC,82B
708C:  MOVLW  01
708E:  MOVLB  8
7090:  MOVWF  x2C
7092:  MOVLB  0
7094:  CALL   6190
7098:  CLRF   19
709A:  BTFSC  FF2.7
709C:  BSF    19.7
709E:  BCF    FF2.7
70A0:  MOVLW  3A
70A2:  MOVLB  9
70A4:  MOVWF  x0C
70A6:  MOVLB  0
70A8:  CALL   1604
70AC:  BTFSC  19.7
70AE:  BSF    FF2.7
70B0:  MOVFF  1CD,82B
70B4:  MOVLW  01
70B6:  MOVLB  8
70B8:  MOVWF  x2C
70BA:  MOVLB  0
70BC:  CALL   6190
70C0:  CLRF   19
70C2:  BTFSC  FF2.7
70C4:  BSF    19.7
70C6:  BCF    FF2.7
70C8:  MOVLW  3A
70CA:  MOVLB  9
70CC:  MOVWF  x0C
70CE:  MOVLB  0
70D0:  CALL   1604
70D4:  BTFSC  19.7
70D6:  BSF    FF2.7
70D8:  MOVFF  1CE,82B
70DC:  MOVLW  01
70DE:  MOVLB  8
70E0:  MOVWF  x2C
70E2:  MOVLB  0
70E4:  CALL   6190
70E8:  CLRF   19
70EA:  BTFSC  FF2.7
70EC:  BSF    19.7
70EE:  BCF    FF2.7
....................           
....................          fprintf(COM2,"\n\r"); 
70F0:  MOVLW  0A
70F2:  MOVLB  9
70F4:  MOVWF  x0C
70F6:  MOVLB  0
70F8:  CALL   1604
70FC:  BTFSC  19.7
70FE:  BSF    FF2.7
7100:  CLRF   19
7102:  BTFSC  FF2.7
7104:  BSF    19.7
7106:  BCF    FF2.7
7108:  MOVLW  0D
710A:  MOVLB  9
710C:  MOVWF  x0C
710E:  MOVLB  0
7110:  CALL   1604
7114:  BTFSC  19.7
7116:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
7118:  CLRF   FEA
711A:  MOVLW  41
711C:  MOVWF  FE9
711E:  MOVLW  00
7120:  CALL   040A
7124:  TBLRD*-
7126:  TBLRD*+
7128:  MOVF   FF5,W
712A:  MOVWF  FEE
712C:  IORLW  00
712E:  BNZ   7126
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7130:  MOVLW  01
7132:  MOVLB  7
7134:  MOVWF  xF4
7136:  MOVLW  62
7138:  MOVWF  xF3
713A:  CLRF   xF6
713C:  MOVLW  41
713E:  MOVWF  xF5
7140:  MOVLB  0
7142:  CALL   60F8
7146:  MOVF   01,F
7148:  BTFSS  FD8.2
714A:  BRA    734A
....................       { 
....................          fprintf(COM2,"Year>"); 
714C:  MOVLW  F4
714E:  MOVWF  FF6
7150:  MOVLW  1C
7152:  MOVWF  FF7
7154:  CLRF   19
7156:  BTFSC  FF2.7
7158:  BSF    19.7
715A:  BCF    FF2.7
715C:  CALL   172E
7160:  BTFSC  19.7
7162:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7164:  MOVLW  01
7166:  MOVLB  7
7168:  MOVWF  xF3
716A:  MOVLW  03
716C:  MOVWF  xF4
716E:  MOVLW  07
7170:  MOVWF  xF6
7172:  MOVLW  C1
7174:  MOVWF  xF5
7176:  MOVLB  0
7178:  CALL   5FC0
....................          year=(unsigned int8)strtoi(temp); 
717C:  MOVLW  07
717E:  MOVLB  7
7180:  MOVWF  xF4
7182:  MOVLW  C1
7184:  MOVWF  xF3
7186:  MOVLB  0
7188:  RCALL  6B68
718A:  MOVFF  01,1C9
....................          fprintf(COM2,"Month>"); 
718E:  MOVLW  FA
7190:  MOVWF  FF6
7192:  MOVLW  1C
7194:  MOVWF  FF7
7196:  CLRF   19
7198:  BTFSC  FF2.7
719A:  BSF    19.7
719C:  BCF    FF2.7
719E:  CALL   172E
71A2:  BTFSC  19.7
71A4:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
71A6:  MOVLW  01
71A8:  MOVLB  7
71AA:  MOVWF  xF3
71AC:  MOVLW  03
71AE:  MOVWF  xF4
71B0:  MOVLW  07
71B2:  MOVWF  xF6
71B4:  MOVLW  C1
71B6:  MOVWF  xF5
71B8:  MOVLB  0
71BA:  CALL   5FC0
....................          mon=(unsigned int8)strtoi(temp); 
71BE:  MOVLW  07
71C0:  MOVLB  7
71C2:  MOVWF  xF4
71C4:  MOVLW  C1
71C6:  MOVWF  xF3
71C8:  MOVLB  0
71CA:  RCALL  6B68
71CC:  MOVFF  01,1CA
....................          fprintf(COM2,"Date>"); 
71D0:  MOVLW  02
71D2:  MOVWF  FF6
71D4:  MOVLW  1D
71D6:  MOVWF  FF7
71D8:  CLRF   19
71DA:  BTFSC  FF2.7
71DC:  BSF    19.7
71DE:  BCF    FF2.7
71E0:  CALL   172E
71E4:  BTFSC  19.7
71E6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
71E8:  MOVLW  01
71EA:  MOVLB  7
71EC:  MOVWF  xF3
71EE:  MOVLW  03
71F0:  MOVWF  xF4
71F2:  MOVLW  07
71F4:  MOVWF  xF6
71F6:  MOVLW  C1
71F8:  MOVWF  xF5
71FA:  MOVLB  0
71FC:  CALL   5FC0
....................          date = (unsigned int8)strtoi(temp); 
7200:  MOVLW  07
7202:  MOVLB  7
7204:  MOVWF  xF4
7206:  MOVLW  C1
7208:  MOVWF  xF3
720A:  MOVLB  0
720C:  RCALL  6B68
720E:  MOVFF  01,1CB
....................          fprintf(COM2,"Day>"); 
7212:  MOVLW  08
7214:  MOVWF  FF6
7216:  MOVLW  1D
7218:  MOVWF  FF7
721A:  CLRF   19
721C:  BTFSC  FF2.7
721E:  BSF    19.7
7220:  BCF    FF2.7
7222:  CALL   172E
7226:  BTFSC  19.7
7228:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
722A:  MOVLW  01
722C:  MOVLB  7
722E:  MOVWF  xF3
7230:  MOVLW  03
7232:  MOVWF  xF4
7234:  MOVLW  07
7236:  MOVWF  xF6
7238:  MOVLW  C1
723A:  MOVWF  xF5
723C:  MOVLB  0
723E:  CALL   5FC0
....................          day = (unsigned int8)strtoi(temp); 
7242:  MOVLW  07
7244:  MOVLB  7
7246:  MOVWF  xF4
7248:  MOVLW  C1
724A:  MOVWF  xF3
724C:  MOVLB  0
724E:  RCALL  6B68
7250:  MOVFF  01,1C8
....................          fprintf(COM2,"Hour>"); 
7254:  MOVLW  0E
7256:  MOVWF  FF6
7258:  MOVLW  1D
725A:  MOVWF  FF7
725C:  CLRF   19
725E:  BTFSC  FF2.7
7260:  BSF    19.7
7262:  BCF    FF2.7
7264:  CALL   172E
7268:  BTFSC  19.7
726A:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
726C:  MOVLW  01
726E:  MOVLB  7
7270:  MOVWF  xF3
7272:  MOVLW  03
7274:  MOVWF  xF4
7276:  MOVLW  07
7278:  MOVWF  xF6
727A:  MOVLW  C1
727C:  MOVWF  xF5
727E:  MOVLB  0
7280:  CALL   5FC0
....................          h = (unsigned int8)strtoi(temp); 
7284:  MOVLW  07
7286:  MOVLB  7
7288:  MOVWF  xF4
728A:  MOVLW  C1
728C:  MOVWF  xF3
728E:  MOVLB  0
7290:  RCALL  6B68
7292:  MOVFF  01,1CC
....................          fprintf(COM2,"Minutes>"); 
7296:  MOVLW  14
7298:  MOVWF  FF6
729A:  MOVLW  1D
729C:  MOVWF  FF7
729E:  CLRF   19
72A0:  BTFSC  FF2.7
72A2:  BSF    19.7
72A4:  BCF    FF2.7
72A6:  CALL   172E
72AA:  BTFSC  19.7
72AC:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
72AE:  MOVLW  01
72B0:  MOVLB  7
72B2:  MOVWF  xF3
72B4:  MOVLW  03
72B6:  MOVWF  xF4
72B8:  MOVLW  07
72BA:  MOVWF  xF6
72BC:  MOVLW  C1
72BE:  MOVWF  xF5
72C0:  MOVLB  0
72C2:  CALL   5FC0
....................          min = (unsigned int8)strtoi(temp);                   
72C6:  MOVLW  07
72C8:  MOVLB  7
72CA:  MOVWF  xF4
72CC:  MOVLW  C1
72CE:  MOVWF  xF3
72D0:  MOVLB  0
72D2:  RCALL  6B68
72D4:  MOVFF  01,1CD
....................          fprintf(COM2,"Seconds>"); 
72D8:  MOVLW  1E
72DA:  MOVWF  FF6
72DC:  MOVLW  1D
72DE:  MOVWF  FF7
72E0:  CLRF   19
72E2:  BTFSC  FF2.7
72E4:  BSF    19.7
72E6:  BCF    FF2.7
72E8:  CALL   172E
72EC:  BTFSC  19.7
72EE:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
72F0:  MOVLW  01
72F2:  MOVLB  7
72F4:  MOVWF  xF3
72F6:  MOVLW  03
72F8:  MOVWF  xF4
72FA:  MOVLW  07
72FC:  MOVWF  xF6
72FE:  MOVLW  C1
7300:  MOVWF  xF5
7302:  MOVLB  0
7304:  CALL   5FC0
....................          sec = (unsigned int8)strtoi(temp);                   
7308:  MOVLW  07
730A:  MOVLB  7
730C:  MOVWF  xF4
730E:  MOVLW  C1
7310:  MOVWF  xF3
7312:  MOVLB  0
7314:  RCALL  6B68
7316:  MOVFF  01,1CE
731A:  CLRF   19
731C:  BTFSC  FF2.7
731E:  BSF    19.7
7320:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
7322:  MOVLW  0A
7324:  MOVLB  9
7326:  MOVWF  x0C
7328:  MOVLB  0
732A:  CALL   1604
732E:  BTFSC  19.7
7330:  BSF    FF2.7
7332:  CLRF   19
7334:  BTFSC  FF2.7
7336:  BSF    19.7
7338:  BCF    FF2.7
733A:  MOVLW  0D
733C:  MOVLB  9
733E:  MOVWF  x0C
7340:  MOVLB  0
7342:  CALL   1604
7346:  BTFSC  19.7
7348:  BSF    FF2.7
....................          /* rtc_set_datetime(date,mon,year,day,h,min); */ 
....................       } 
....................       strcpy(buffer2,"MS"); 
734A:  CLRF   FEA
734C:  MOVLW  41
734E:  MOVWF  FE9
7350:  MOVLW  00
7352:  CALL   041E
7356:  TBLRD*-
7358:  TBLRD*+
735A:  MOVF   FF5,W
735C:  MOVWF  FEE
735E:  IORLW  00
7360:  BNZ   7358
....................       if(!stringcomp(buffer_uart,buffer2)) 
7362:  MOVLW  01
7364:  MOVLB  7
7366:  MOVWF  xF4
7368:  MOVLW  62
736A:  MOVWF  xF3
736C:  CLRF   xF6
736E:  MOVLW  41
7370:  MOVWF  xF5
7372:  MOVLB  0
7374:  CALL   60F8
7378:  MOVF   01,F
737A:  BTFSS  FD8.2
737C:  BRA    7490
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
737E:  MOVLW  28
7380:  MOVWF  FF6
7382:  MOVLW  1D
7384:  MOVWF  FF7
7386:  CLRF   19
7388:  BTFSC  FF2.7
738A:  BSF    19.7
738C:  BCF    FF2.7
738E:  CALL   172E
7392:  BTFSC  19.7
7394:  BSF    FF2.7
7396:  CLRF   19
7398:  BTFSC  FF2.7
739A:  BSF    19.7
739C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
739E:  MOVLW  0A
73A0:  MOVLB  9
73A2:  MOVWF  x0C
73A4:  MOVLB  0
73A6:  CALL   1604
73AA:  BTFSC  19.7
73AC:  BSF    FF2.7
73AE:  CLRF   19
73B0:  BTFSC  FF2.7
73B2:  BSF    19.7
73B4:  BCF    FF2.7
73B6:  MOVLW  0D
73B8:  MOVLB  9
73BA:  MOVWF  x0C
73BC:  MOVLB  0
73BE:  CALL   1604
73C2:  BTFSC  19.7
73C4:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
73C6:  MOVLW  48
73C8:  MOVWF  FF6
73CA:  MOVLW  1D
73CC:  MOVWF  FF7
73CE:  CLRF   19
73D0:  BTFSC  FF2.7
73D2:  BSF    19.7
73D4:  BCF    FF2.7
73D6:  CALL   172E
73DA:  BTFSC  19.7
73DC:  BSF    FF2.7
73DE:  CLRF   19
73E0:  BTFSC  FF2.7
73E2:  BSF    19.7
73E4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
73E6:  MOVLW  0A
73E8:  MOVLB  9
73EA:  MOVWF  x0C
73EC:  MOVLB  0
73EE:  CALL   1604
73F2:  BTFSC  19.7
73F4:  BSF    FF2.7
73F6:  CLRF   19
73F8:  BTFSC  FF2.7
73FA:  BSF    19.7
73FC:  BCF    FF2.7
73FE:  MOVLW  0D
7400:  MOVLB  9
7402:  MOVWF  x0C
7404:  MOVLB  0
7406:  CALL   1604
740A:  BTFSC  19.7
740C:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
740E:  MOVLW  01
7410:  MOVLB  7
7412:  MOVWF  xF3
7414:  MOVLW  03
7416:  MOVWF  xF4
7418:  MOVLW  07
741A:  MOVWF  xF6
741C:  MOVLW  C1
741E:  MOVWF  xF5
7420:  MOVLB  0
7422:  CALL   5FC0
....................           mode_sl = (unsigned int8)strtoi(temp); 
7426:  MOVLW  07
7428:  MOVLB  7
742A:  MOVWF  xF4
742C:  MOVLW  C1
742E:  MOVWF  xF3
7430:  MOVLB  0
7432:  CALL   6B68
7436:  MOVFF  01,6E2
743A:  CLRF   19
743C:  BTFSC  FF2.7
743E:  BSF    19.7
7440:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
7442:  MOVLB  9
7444:  CLRF   x16
7446:  CLRF   x15
7448:  CLRF   x14
744A:  MOVLW  3A
744C:  MOVWF  x13
744E:  MOVFF  6E2,917
7452:  MOVLB  0
7454:  CALL   3A6C
7458:  BTFSC  19.7
745A:  BSF    FF2.7
....................           set_tris_a(0xff); 
745C:  MOVLW  FF
745E:  MOVWF  F92
7460:  CLRF   19
7462:  BTFSC  FF2.7
7464:  BSF    19.7
7466:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7468:  MOVLW  0A
746A:  MOVLB  9
746C:  MOVWF  x0C
746E:  MOVLB  0
7470:  CALL   1604
7474:  BTFSC  19.7
7476:  BSF    FF2.7
7478:  CLRF   19
747A:  BTFSC  FF2.7
747C:  BSF    19.7
747E:  BCF    FF2.7
7480:  MOVLW  0D
7482:  MOVLB  9
7484:  MOVWF  x0C
7486:  MOVLB  0
7488:  CALL   1604
748C:  BTFSC  19.7
748E:  BSF    FF2.7
....................       } 
....................       
....................       strcpy(buffer2,"tran time"); 
7490:  CLRF   FEA
7492:  MOVLW  41
7494:  MOVWF  FE9
7496:  MOVLW  00
7498:  CALL   0432
749C:  TBLRD*-
749E:  TBLRD*+
74A0:  MOVF   FF5,W
74A2:  MOVWF  FEE
74A4:  IORLW  00
74A6:  BNZ   749E
....................       if(!stringcomp(buffer_uart,buffer2)) 
74A8:  MOVLW  01
74AA:  MOVLB  7
74AC:  MOVWF  xF4
74AE:  MOVLW  62
74B0:  MOVWF  xF3
74B2:  CLRF   xF6
74B4:  MOVLW  41
74B6:  MOVWF  xF5
74B8:  MOVLB  0
74BA:  CALL   60F8
74BE:  MOVF   01,F
74C0:  BNZ   7588
....................       { 
....................           fprintf(COM2,"Input Number"); 
74C2:  MOVLW  68
74C4:  MOVWF  FF6
74C6:  MOVLW  1D
74C8:  MOVWF  FF7
74CA:  CLRF   19
74CC:  BTFSC  FF2.7
74CE:  BSF    19.7
74D0:  BCF    FF2.7
74D2:  CALL   172E
74D6:  BTFSC  19.7
74D8:  BSF    FF2.7
74DA:  CLRF   19
74DC:  BTFSC  FF2.7
74DE:  BSF    19.7
74E0:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
74E2:  MOVLW  0A
74E4:  MOVLB  9
74E6:  MOVWF  x0C
74E8:  MOVLB  0
74EA:  CALL   1604
74EE:  BTFSC  19.7
74F0:  BSF    FF2.7
74F2:  CLRF   19
74F4:  BTFSC  FF2.7
74F6:  BSF    19.7
74F8:  BCF    FF2.7
74FA:  MOVLW  0D
74FC:  MOVLB  9
74FE:  MOVWF  x0C
7500:  MOVLB  0
7502:  CALL   1604
7506:  BTFSC  19.7
7508:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
750A:  MOVLW  01
750C:  MOVLB  7
750E:  MOVWF  xF3
7510:  MOVLW  03
7512:  MOVWF  xF4
7514:  MOVLW  07
7516:  MOVWF  xF6
7518:  MOVLW  C1
751A:  MOVWF  xF5
751C:  MOVLB  0
751E:  CALL   5FC0
....................           delaycharaction = (unsigned int8)strtoi(temp); 
7522:  MOVLW  07
7524:  MOVLB  7
7526:  MOVWF  xF4
7528:  MOVLW  C1
752A:  MOVWF  xF3
752C:  MOVLB  0
752E:  CALL   6B68
7532:  MOVFF  01,15A
7536:  CLRF   19
7538:  BTFSC  FF2.7
753A:  BSF    19.7
753C:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
753E:  MOVLB  9
7540:  CLRF   x16
7542:  CLRF   x15
7544:  CLRF   x14
7546:  MOVLW  3C
7548:  MOVWF  x13
754A:  MOVFF  15A,917
754E:  MOVLB  0
7550:  CALL   3A6C
7554:  BTFSC  19.7
7556:  BSF    FF2.7
7558:  CLRF   19
755A:  BTFSC  FF2.7
755C:  BSF    19.7
755E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7560:  MOVLW  0A
7562:  MOVLB  9
7564:  MOVWF  x0C
7566:  MOVLB  0
7568:  CALL   1604
756C:  BTFSC  19.7
756E:  BSF    FF2.7
7570:  CLRF   19
7572:  BTFSC  FF2.7
7574:  BSF    19.7
7576:  BCF    FF2.7
7578:  MOVLW  0D
757A:  MOVLB  9
757C:  MOVWF  x0C
757E:  MOVLB  0
7580:  CALL   1604
7584:  BTFSC  19.7
7586:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
7588:  CLRF   FEA
758A:  MOVLW  41
758C:  MOVWF  FE9
758E:  MOVLW  00
7590:  CALL   044C
7594:  TBLRD*-
7596:  TBLRD*+
7598:  MOVF   FF5,W
759A:  MOVWF  FEE
759C:  IORLW  00
759E:  BNZ   7596
....................       if(!stringcomp(buffer_uart,buffer2)) 
75A0:  MOVLW  01
75A2:  MOVLB  7
75A4:  MOVWF  xF4
75A6:  MOVLW  62
75A8:  MOVWF  xF3
75AA:  CLRF   xF6
75AC:  MOVLW  41
75AE:  MOVWF  xF5
75B0:  MOVLB  0
75B2:  CALL   60F8
75B6:  MOVF   01,F
75B8:  BTFSS  FD8.2
75BA:  BRA    76CA
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
75BC:  MOVLW  76
75BE:  MOVWF  FF6
75C0:  MOVLW  1D
75C2:  MOVWF  FF7
75C4:  CLRF   19
75C6:  BTFSC  FF2.7
75C8:  BSF    19.7
75CA:  BCF    FF2.7
75CC:  CALL   172E
75D0:  BTFSC  19.7
75D2:  BSF    FF2.7
75D4:  CLRF   19
75D6:  BTFSC  FF2.7
75D8:  BSF    19.7
75DA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
75DC:  MOVLW  0A
75DE:  MOVLB  9
75E0:  MOVWF  x0C
75E2:  MOVLB  0
75E4:  CALL   1604
75E8:  BTFSC  19.7
75EA:  BSF    FF2.7
75EC:  CLRF   19
75EE:  BTFSC  FF2.7
75F0:  BSF    19.7
75F2:  BCF    FF2.7
75F4:  MOVLW  0D
75F6:  MOVLB  9
75F8:  MOVWF  x0C
75FA:  MOVLB  0
75FC:  CALL   1604
7600:  BTFSC  19.7
7602:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
7604:  MOVLW  9C
7606:  MOVWF  FF6
7608:  MOVLW  1D
760A:  MOVWF  FF7
760C:  CLRF   19
760E:  BTFSC  FF2.7
7610:  BSF    19.7
7612:  BCF    FF2.7
7614:  CALL   172E
7618:  BTFSC  19.7
761A:  BSF    FF2.7
761C:  CLRF   19
761E:  BTFSC  FF2.7
7620:  BSF    19.7
7622:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7624:  MOVLW  0A
7626:  MOVLB  9
7628:  MOVWF  x0C
762A:  MOVLB  0
762C:  CALL   1604
7630:  BTFSC  19.7
7632:  BSF    FF2.7
7634:  CLRF   19
7636:  BTFSC  FF2.7
7638:  BSF    19.7
763A:  BCF    FF2.7
763C:  MOVLW  0D
763E:  MOVLB  9
7640:  MOVWF  x0C
7642:  MOVLB  0
7644:  CALL   1604
7648:  BTFSC  19.7
764A:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
764C:  MOVLW  01
764E:  MOVLB  7
7650:  MOVWF  xF3
7652:  MOVLW  03
7654:  MOVWF  xF4
7656:  MOVLW  07
7658:  MOVWF  xF6
765A:  MOVLW  C1
765C:  MOVWF  xF5
765E:  MOVLB  0
7660:  CALL   5FC0
....................           type_KB=(unsigned int8)strtoi(temp); 
7664:  MOVLW  07
7666:  MOVLB  7
7668:  MOVWF  xF4
766A:  MOVLW  C1
766C:  MOVWF  xF3
766E:  MOVLB  0
7670:  CALL   6B68
7674:  MOVFF  01,149
7678:  CLRF   19
767A:  BTFSC  FF2.7
767C:  BSF    19.7
767E:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
7680:  MOVLB  9
7682:  CLRF   x16
7684:  CLRF   x15
7686:  CLRF   x14
7688:  MOVLW  3D
768A:  MOVWF  x13
768C:  MOVFF  149,917
7690:  MOVLB  0
7692:  CALL   3A6C
7696:  BTFSC  19.7
7698:  BSF    FF2.7
769A:  CLRF   19
769C:  BTFSC  FF2.7
769E:  BSF    19.7
76A0:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
76A2:  MOVLW  0A
76A4:  MOVLB  9
76A6:  MOVWF  x0C
76A8:  MOVLB  0
76AA:  CALL   1604
76AE:  BTFSC  19.7
76B0:  BSF    FF2.7
76B2:  CLRF   19
76B4:  BTFSC  FF2.7
76B6:  BSF    19.7
76B8:  BCF    FF2.7
76BA:  MOVLW  0D
76BC:  MOVLB  9
76BE:  MOVWF  x0C
76C0:  MOVLB  0
76C2:  CALL   1604
76C6:  BTFSC  19.7
76C8:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       strcpy(buffer2,"h"); 
76CA:  CLRF   FEA
76CC:  MOVLW  41
76CE:  MOVWF  FE9
76D0:  MOVLW  00
76D2:  CALL   0462
76D6:  TBLRD*-
76D8:  TBLRD*+
76DA:  MOVF   FF5,W
76DC:  MOVWF  FEE
76DE:  IORLW  00
76E0:  BNZ   76D8
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
76E2:  MOVLW  01
76E4:  MOVLB  7
76E6:  MOVWF  xF4
76E8:  MOVLW  62
76EA:  MOVWF  xF3
76EC:  CLRF   xF6
76EE:  MOVLW  41
76F0:  MOVWF  xF5
76F2:  MOVLB  0
76F4:  CALL   60F8
76F8:  MOVF   01,F
76FA:  BTFSS  FD8.2
76FC:  BRA    786C
....................       { 
....................          printf("h-> Help\n\r"); 
76FE:  MOVLW  C2
7700:  MOVWF  FF6
7702:  MOVLW  1D
7704:  MOVWF  FF7
7706:  CLRF   19
7708:  BTFSC  FF2.7
770A:  BSF    19.7
770C:  BCF    FF2.7
770E:  CALL   172E
7712:  BTFSC  19.7
7714:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
7716:  MOVLW  CE
7718:  MOVWF  FF6
771A:  MOVLW  1D
771C:  MOVWF  FF7
771E:  CLRF   19
7720:  BTFSC  FF2.7
7722:  BSF    19.7
7724:  BCF    FF2.7
7726:  CALL   172E
772A:  BTFSC  19.7
772C:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
772E:  MOVLW  E0
7730:  MOVWF  FF6
7732:  MOVLW  1D
7734:  MOVWF  FF7
7736:  CLRF   19
7738:  BTFSC  FF2.7
773A:  BSF    19.7
773C:  BCF    FF2.7
773E:  CALL   172E
7742:  BTFSC  19.7
7744:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
7746:  MOVLW  F2
7748:  MOVWF  FF6
774A:  MOVLW  1D
774C:  MOVWF  FF7
774E:  CLRF   19
7750:  BTFSC  FF2.7
7752:  BSF    19.7
7754:  BCF    FF2.7
7756:  CALL   172E
775A:  BTFSC  19.7
775C:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
775E:  MOVLW  12
7760:  MOVWF  FF6
7762:  MOVLW  1E
7764:  MOVWF  FF7
7766:  CLRF   19
7768:  BTFSC  FF2.7
776A:  BSF    19.7
776C:  BCF    FF2.7
776E:  CALL   172E
7772:  BTFSC  19.7
7774:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
7776:  MOVLW  2E
7778:  MOVWF  FF6
777A:  MOVLW  1E
777C:  MOVWF  FF7
777E:  CLRF   19
7780:  BTFSC  FF2.7
7782:  BSF    19.7
7784:  BCF    FF2.7
7786:  CALL   172E
778A:  BTFSC  19.7
778C:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
778E:  MOVLW  3C
7790:  MOVWF  FF6
7792:  MOVLW  1E
7794:  MOVWF  FF7
7796:  CLRF   19
7798:  BTFSC  FF2.7
779A:  BSF    19.7
779C:  BCF    FF2.7
779E:  CALL   172E
77A2:  BTFSC  19.7
77A4:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
77A6:  MOVLW  48
77A8:  MOVWF  FF6
77AA:  MOVLW  1E
77AC:  MOVWF  FF7
77AE:  CLRF   19
77B0:  BTFSC  FF2.7
77B2:  BSF    19.7
77B4:  BCF    FF2.7
77B6:  CALL   172E
77BA:  BTFSC  19.7
77BC:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
77BE:  MOVLW  70
77C0:  MOVWF  FF6
77C2:  MOVLW  1E
77C4:  MOVWF  FF7
77C6:  CLRF   19
77C8:  BTFSC  FF2.7
77CA:  BSF    19.7
77CC:  BCF    FF2.7
77CE:  CALL   172E
77D2:  BTFSC  19.7
77D4:  BSF    FF2.7
77D6:  CLRF   19
77D8:  BTFSC  FF2.7
77DA:  BSF    19.7
77DC:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
77DE:  MOVLB  9
77E0:  CLRF   x1B
77E2:  CLRF   x1A
77E4:  CLRF   x19
77E6:  MOVLW  3D
77E8:  MOVWF  x18
77EA:  MOVLB  0
77EC:  CALL   3450
77F0:  BTFSC  19.7
77F2:  BSF    FF2.7
77F4:  MOVFF  01,7F3
77F8:  MOVLW  8C
77FA:  MOVWF  FF6
77FC:  MOVLW  1E
77FE:  MOVWF  FF7
7800:  CLRF   19
7802:  BTFSC  FF2.7
7804:  BSF    19.7
7806:  BCF    FF2.7
7808:  MOVLW  06
780A:  MOVLB  8
780C:  MOVWF  xF7
780E:  MOVLB  0
7810:  CALL   164A
7814:  BTFSC  19.7
7816:  BSF    FF2.7
7818:  CLRF   19
781A:  BTFSC  FF2.7
781C:  BSF    19.7
781E:  BCF    FF2.7
7820:  MOVFF  7F3,859
7824:  MOVLW  18
7826:  MOVLB  8
7828:  MOVWF  x5A
782A:  MOVLB  0
782C:  CALL   177A
7830:  BTFSC  19.7
7832:  BSF    FF2.7
7834:  MOVLW  94
7836:  MOVWF  FF6
7838:  MOVLW  1E
783A:  MOVWF  FF7
783C:  CLRF   19
783E:  BTFSC  FF2.7
7840:  BSF    19.7
7842:  BCF    FF2.7
7844:  MOVLW  1D
7846:  MOVLB  8
7848:  MOVWF  xF7
784A:  MOVLB  0
784C:  CALL   164A
7850:  BTFSC  19.7
7852:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
7854:  MOVLW  B2
7856:  MOVWF  FF6
7858:  MOVLW  1E
785A:  MOVWF  FF7
785C:  CLRF   19
785E:  BTFSC  FF2.7
7860:  BSF    19.7
7862:  BCF    FF2.7
7864:  CALL   172E
7868:  BTFSC  19.7
786A:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................       } 
....................       strcpy(buffer2,"password"); 
786C:  CLRF   FEA
786E:  MOVLW  41
7870:  MOVWF  FE9
7872:  MOVLW  00
7874:  CALL   0474
7878:  TBLRD*-
787A:  TBLRD*+
787C:  MOVF   FF5,W
787E:  MOVWF  FEE
7880:  IORLW  00
7882:  BNZ   787A
....................       if(!stringcomp(buffer_uart,buffer2))  
7884:  MOVLW  01
7886:  MOVLB  7
7888:  MOVWF  xF4
788A:  MOVLW  62
788C:  MOVWF  xF3
788E:  CLRF   xF6
7890:  MOVLW  41
7892:  MOVWF  xF5
7894:  MOVLB  0
7896:  CALL   60F8
789A:  MOVF   01,F
789C:  BTFSS  FD8.2
789E:  BRA    79FE
....................       { 
....................          fprintf(COM2,"old password:"); 
78A0:  MOVLW  CC
78A2:  MOVWF  FF6
78A4:  MOVLW  1E
78A6:  MOVWF  FF7
78A8:  CLRF   19
78AA:  BTFSC  FF2.7
78AC:  BSF    19.7
78AE:  BCF    FF2.7
78B0:  CALL   172E
78B4:  BTFSC  19.7
78B6:  BSF    FF2.7
78B8:  CLRF   19
78BA:  BTFSC  FF2.7
78BC:  BSF    19.7
78BE:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
78C0:  MOVLB  9
78C2:  CLRF   x07
78C4:  CLRF   x06
78C6:  CLRF   x05
78C8:  CLRF   x04
78CA:  CLRF   x0B
78CC:  CLRF   x0A
78CE:  CLRF   x09
78D0:  MOVLW  14
78D2:  MOVWF  x08
78D4:  CLRF   x0D
78D6:  MOVLW  55
78D8:  MOVWF  x0C
78DA:  MOVLB  0
78DC:  CALL   4004
78E0:  BTFSC  19.7
78E2:  BSF    FF2.7
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
78E4:  MOVLW  02
78E6:  MOVLB  7
78E8:  MOVWF  xF3
78EA:  MOVLW  14
78EC:  MOVWF  xF4
78EE:  CLRF   xF6
78F0:  MOVLW  69
78F2:  MOVWF  xF5
78F4:  MOVLB  0
78F6:  CALL   5FC0
....................          if(!stringcomp(entpassword,password)) 
78FA:  MOVLB  7
78FC:  CLRF   xF4
78FE:  MOVLW  69
7900:  MOVWF  xF3
7902:  CLRF   xF6
7904:  MOVLW  55
7906:  MOVWF  xF5
7908:  MOVLB  0
790A:  CALL   60F8
790E:  MOVF   01,F
7910:  BNZ   79E6
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
7912:  MOVLW  DA
7914:  MOVWF  FF6
7916:  MOVLW  1E
7918:  MOVWF  FF7
791A:  CLRF   19
791C:  BTFSC  FF2.7
791E:  BSF    19.7
7920:  BCF    FF2.7
7922:  CALL   172E
7926:  BTFSC  19.7
7928:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
792A:  MOVLW  02
792C:  MOVLB  7
792E:  MOVWF  xF3
7930:  MOVLW  14
7932:  MOVWF  xF4
7934:  CLRF   xF6
7936:  MOVLW  69
7938:  MOVWF  xF5
793A:  MOVLB  0
793C:  CALL   5FC0
....................             fprintf(COM2,"\n\ragain:"); 
7940:  MOVLW  E2
7942:  MOVWF  FF6
7944:  MOVLW  1E
7946:  MOVWF  FF7
7948:  CLRF   19
794A:  BTFSC  FF2.7
794C:  BSF    19.7
794E:  BCF    FF2.7
7950:  CALL   172E
7954:  BTFSC  19.7
7956:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
7958:  MOVLW  02
795A:  MOVLB  7
795C:  MOVWF  xF3
795E:  MOVLW  14
7960:  MOVWF  xF4
7962:  CLRF   xF6
7964:  MOVLW  55
7966:  MOVWF  xF5
7968:  MOVLB  0
796A:  CALL   5FC0
....................             if(!stringcomp(entpassword,password)) 
796E:  MOVLB  7
7970:  CLRF   xF4
7972:  MOVLW  69
7974:  MOVWF  xF3
7976:  CLRF   xF6
7978:  MOVLW  55
797A:  MOVWF  xF5
797C:  MOVLB  0
797E:  CALL   60F8
7982:  MOVF   01,F
7984:  BNZ   79CC
7986:  CLRF   19
7988:  BTFSC  FF2.7
798A:  BSF    19.7
798C:  BCF    FF2.7
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
798E:  MOVLB  9
7990:  CLRF   x03
7992:  CLRF   x02
7994:  CLRF   x01
7996:  CLRF   x00
7998:  CLRF   x07
799A:  CLRF   x06
799C:  CLRF   x05
799E:  MOVLW  14
79A0:  MOVWF  x04
79A2:  CLRF   x09
79A4:  MOVLW  55
79A6:  MOVWF  x08
79A8:  MOVLB  0
79AA:  CALL   4EF6
79AE:  BTFSC  19.7
79B0:  BSF    FF2.7
....................                fprintf(COM2,"\n\rOK\n\r");    
79B2:  MOVLW  EC
79B4:  MOVWF  FF6
79B6:  MOVLW  1E
79B8:  MOVWF  FF7
79BA:  CLRF   19
79BC:  BTFSC  FF2.7
79BE:  BSF    19.7
79C0:  BCF    FF2.7
79C2:  CALL   172E
79C6:  BTFSC  19.7
79C8:  BSF    FF2.7
....................             } 
....................                else 
79CA:  BRA    79E4
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
79CC:  MOVLW  F4
79CE:  MOVWF  FF6
79D0:  MOVLW  1E
79D2:  MOVWF  FF7
79D4:  CLRF   19
79D6:  BTFSC  FF2.7
79D8:  BSF    19.7
79DA:  BCF    FF2.7
79DC:  CALL   172E
79E0:  BTFSC  19.7
79E2:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
79E4:  BRA    79FE
....................             { 
....................                fprintf(COM2," X\n\r"); 
79E6:  MOVLW  FC
79E8:  MOVWF  FF6
79EA:  MOVLW  1E
79EC:  MOVWF  FF7
79EE:  CLRF   19
79F0:  BTFSC  FF2.7
79F2:  BSF    19.7
79F4:  BCF    FF2.7
79F6:  CALL   172E
79FA:  BTFSC  19.7
79FC:  BSF    FF2.7
....................             }    
....................       } 
....................         strcpy(buffer2,"crypto"); 
79FE:  CLRF   FEA
7A00:  MOVLW  41
7A02:  MOVWF  FE9
7A04:  MOVLW  00
7A06:  CALL   048E
7A0A:  TBLRD*-
7A0C:  TBLRD*+
7A0E:  MOVF   FF5,W
7A10:  MOVWF  FEE
7A12:  IORLW  00
7A14:  BNZ   7A0C
....................         if(!stringcomp(buffer_uart,buffer2))  
7A16:  MOVLW  01
7A18:  MOVLB  7
7A1A:  MOVWF  xF4
7A1C:  MOVLW  62
7A1E:  MOVWF  xF3
7A20:  CLRF   xF6
7A22:  MOVLW  41
7A24:  MOVWF  xF5
7A26:  MOVLB  0
7A28:  CALL   60F8
7A2C:  MOVF   01,F
7A2E:  BTFSS  FD8.2
7A30:  BRA    7BB0
....................         { 
....................             memset(crypto_key,0,sizeof(crypto_key)); 
7A32:  MOVLW  01
7A34:  MOVWF  FEA
7A36:  MOVWF  FE9
7A38:  CLRF   00
7A3A:  CLRF   02
7A3C:  MOVLW  21
7A3E:  MOVWF  01
7A40:  CALL   359A
....................             fprintf(COM2,"New crypto key>"); 
7A44:  MOVLW  02
7A46:  MOVWF  FF6
7A48:  MOVLW  1F
7A4A:  MOVWF  FF7
7A4C:  CLRF   19
7A4E:  BTFSC  FF2.7
7A50:  BSF    19.7
7A52:  BCF    FF2.7
7A54:  CALL   172E
7A58:  BTFSC  19.7
7A5A:  BSF    FF2.7
....................             countchar = (int16)USART_getstring(EN_ECHO, CRYPTO_KEY_SIZE, crypto_key); 
7A5C:  MOVLW  01
7A5E:  MOVLB  7
7A60:  MOVWF  xF3
7A62:  MOVLW  20
7A64:  MOVWF  xF4
7A66:  MOVLW  01
7A68:  MOVWF  xF6
7A6A:  MOVWF  xF5
7A6C:  MOVLB  0
7A6E:  CALL   5FC0
7A72:  MOVLB  7
7A74:  CLRF   xC0
7A76:  MOVFF  01,7BF
7A7A:  CLRF   19
7A7C:  BTFSC  FF2.7
7A7E:  BSF    19.7
7A80:  BCF    FF2.7
....................             EEPROM_write(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
7A82:  MOVLB  9
7A84:  CLRF   x03
7A86:  CLRF   x02
7A88:  CLRF   x01
7A8A:  MOVLW  3F
7A8C:  MOVWF  x00
7A8E:  CLRF   x07
7A90:  CLRF   x06
7A92:  CLRF   x05
7A94:  MOVLW  20
7A96:  MOVWF  x04
7A98:  MOVLW  01
7A9A:  MOVWF  x09
7A9C:  MOVWF  x08
7A9E:  MOVLB  0
7AA0:  CALL   4EF6
7AA4:  BTFSC  19.7
7AA6:  BSF    FF2.7
....................              
....................             if(countchar>2) 
7AA8:  MOVLB  7
7AAA:  MOVF   xC0,F
7AAC:  BNZ   7AB4
7AAE:  MOVF   xBF,W
7AB0:  SUBLW  02
7AB2:  BC    7B72
....................             { 
....................                 cryption_enable = 1; 
7AB4:  MOVLW  01
7AB6:  MOVLB  1
7AB8:  MOVWF  x22
7ABA:  CLRF   19
7ABC:  BTFSC  FF2.7
7ABE:  BSF    19.7
7AC0:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable);                    
7AC2:  MOVLB  9
7AC4:  CLRF   x16
7AC6:  CLRF   x15
7AC8:  CLRF   x14
7ACA:  MOVLW  3E
7ACC:  MOVWF  x13
7ACE:  MOVFF  122,917
7AD2:  MOVLB  0
7AD4:  CALL   3A6C
7AD8:  BTFSC  19.7
7ADA:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rNew crypto key: "); 
7ADC:  MOVLW  12
7ADE:  MOVWF  FF6
7AE0:  MOVLW  1F
7AE2:  MOVWF  FF7
7AE4:  CLRF   19
7AE6:  BTFSC  FF2.7
7AE8:  BSF    19.7
7AEA:  BCF    FF2.7
7AEC:  CALL   172E
7AF0:  BTFSC  19.7
7AF2:  BSF    FF2.7
....................                 for(i=0;i<CRYPTO_KEY_SIZE;i++) 
7AF4:  MOVLB  7
7AF6:  CLRF   xBE
7AF8:  MOVF   xBE,W
7AFA:  SUBLW  1F
7AFC:  BNC   7B3E
....................                 { 
....................                     fprintf(COM2,"%c",read_ext_eeprom(strobe_crypto_key+i)); 
7AFE:  MOVLW  3F
7B00:  ADDWF  xBE,W
7B02:  MOVWF  xF3
7B04:  CLRF   19
7B06:  BTFSC  FF2.7
7B08:  BSF    19.7
7B0A:  BCF    FF2.7
7B0C:  MOVLB  9
7B0E:  CLRF   x1B
7B10:  CLRF   x1A
7B12:  CLRF   x19
7B14:  MOVWF  x18
7B16:  MOVLB  0
7B18:  CALL   3450
7B1C:  BTFSC  19.7
7B1E:  BSF    FF2.7
7B20:  MOVFF  01,7F3
7B24:  CLRF   19
7B26:  BTFSC  FF2.7
7B28:  BSF    19.7
7B2A:  BCF    FF2.7
7B2C:  MOVFF  01,90C
7B30:  CALL   1604
7B34:  BTFSC  19.7
7B36:  BSF    FF2.7
....................                 } 
7B38:  MOVLB  7
7B3A:  INCF   xBE,F
7B3C:  BRA    7AF8
7B3E:  CLRF   19
7B40:  BTFSC  FF2.7
7B42:  BSF    19.7
7B44:  BCF    FF2.7
....................                 fprintf(COM2,"\n\r"); 
7B46:  MOVLW  0A
7B48:  MOVLB  9
7B4A:  MOVWF  x0C
7B4C:  MOVLB  0
7B4E:  CALL   1604
7B52:  BTFSC  19.7
7B54:  BSF    FF2.7
7B56:  CLRF   19
7B58:  BTFSC  FF2.7
7B5A:  BSF    19.7
7B5C:  BCF    FF2.7
7B5E:  MOVLW  0D
7B60:  MOVLB  9
7B62:  MOVWF  x0C
7B64:  MOVLB  0
7B66:  CALL   1604
7B6A:  BTFSC  19.7
7B6C:  BSF    FF2.7
....................             } 
....................             else 
7B6E:  BRA    7BB0
7B70:  MOVLB  7
....................             { 
....................                 cryption_enable = 0; 
7B72:  MOVLB  1
7B74:  CLRF   x22
7B76:  CLRF   19
7B78:  BTFSC  FF2.7
7B7A:  BSF    19.7
7B7C:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable); 
7B7E:  MOVLB  9
7B80:  CLRF   x16
7B82:  CLRF   x15
7B84:  CLRF   x14
7B86:  MOVLW  3E
7B88:  MOVWF  x13
7B8A:  MOVFF  122,917
7B8E:  MOVLB  0
7B90:  CALL   3A6C
7B94:  BTFSC  19.7
7B96:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rcrypto is disable\n\r"); 
7B98:  MOVLW  26
7B9A:  MOVWF  FF6
7B9C:  MOVLW  1F
7B9E:  MOVWF  FF7
7BA0:  CLRF   19
7BA2:  BTFSC  FF2.7
7BA4:  BSF    19.7
7BA6:  BCF    FF2.7
7BA8:  CALL   172E
7BAC:  BTFSC  19.7
7BAE:  BSF    FF2.7
....................             } 
....................         } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
7BB0:  CLRF   FEA
7BB2:  MOVLW  41
7BB4:  MOVWF  FE9
7BB6:  MOVLW  00
7BB8:  CALL   04A6
7BBC:  TBLRD*-
7BBE:  TBLRD*+
7BC0:  MOVF   FF5,W
7BC2:  MOVWF  FEE
7BC4:  IORLW  00
7BC6:  BNZ   7BBE
....................       if(!stringcomp(buffer_uart,buffer2)) 
7BC8:  MOVLW  01
7BCA:  MOVLB  7
7BCC:  MOVWF  xF4
7BCE:  MOVLW  62
7BD0:  MOVWF  xF3
7BD2:  CLRF   xF6
7BD4:  MOVLW  41
7BD6:  MOVWF  xF5
7BD8:  MOVLB  0
7BDA:  CALL   60F8
7BDE:  MOVF   01,F
7BE0:  BTFSS  FD8.2
7BE2:  BRA    7CF2
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
7BE4:  MOVLW  3C
7BE6:  MOVWF  FF6
7BE8:  MOVLW  1F
7BEA:  MOVWF  FF7
7BEC:  CLRF   19
7BEE:  BTFSC  FF2.7
7BF0:  BSF    19.7
7BF2:  BCF    FF2.7
7BF4:  CALL   172E
7BF8:  BTFSC  19.7
7BFA:  BSF    FF2.7
7BFC:  CLRF   19
7BFE:  BTFSC  FF2.7
7C00:  BSF    19.7
7C02:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7C04:  MOVLW  0A
7C06:  MOVLB  9
7C08:  MOVWF  x0C
7C0A:  MOVLB  0
7C0C:  CALL   1604
7C10:  BTFSC  19.7
7C12:  BSF    FF2.7
7C14:  CLRF   19
7C16:  BTFSC  FF2.7
7C18:  BSF    19.7
7C1A:  BCF    FF2.7
7C1C:  MOVLW  0D
7C1E:  MOVLB  9
7C20:  MOVWF  x0C
7C22:  MOVLB  0
7C24:  CALL   1604
7C28:  BTFSC  19.7
7C2A:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
7C2C:  MOVLW  5C
7C2E:  MOVWF  FF6
7C30:  MOVLW  1F
7C32:  MOVWF  FF7
7C34:  CLRF   19
7C36:  BTFSC  FF2.7
7C38:  BSF    19.7
7C3A:  BCF    FF2.7
7C3C:  CALL   172E
7C40:  BTFSC  19.7
7C42:  BSF    FF2.7
7C44:  CLRF   19
7C46:  BTFSC  FF2.7
7C48:  BSF    19.7
7C4A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7C4C:  MOVLW  0A
7C4E:  MOVLB  9
7C50:  MOVWF  x0C
7C52:  MOVLB  0
7C54:  CALL   1604
7C58:  BTFSC  19.7
7C5A:  BSF    FF2.7
7C5C:  CLRF   19
7C5E:  BTFSC  FF2.7
7C60:  BSF    19.7
7C62:  BCF    FF2.7
7C64:  MOVLW  0D
7C66:  MOVLB  9
7C68:  MOVWF  x0C
7C6A:  MOVLB  0
7C6C:  CALL   1604
7C70:  BTFSC  19.7
7C72:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7C74:  MOVLW  01
7C76:  MOVLB  7
7C78:  MOVWF  xF3
7C7A:  MOVLW  03
7C7C:  MOVWF  xF4
7C7E:  MOVLW  07
7C80:  MOVWF  xF6
7C82:  MOVLW  C1
7C84:  MOVWF  xF5
7C86:  MOVLB  0
7C88:  CALL   5FC0
....................           debugmode = (unsigned int8)strtoi(temp); 
7C8C:  MOVLW  07
7C8E:  MOVLB  7
7C90:  MOVWF  xF4
7C92:  MOVLW  C1
7C94:  MOVWF  xF3
7C96:  MOVLB  0
7C98:  CALL   6B68
7C9C:  MOVFF  01,6D6
7CA0:  CLRF   19
7CA2:  BTFSC  FF2.7
7CA4:  BSF    19.7
7CA6:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
7CA8:  MOVLB  9
7CAA:  CLRF   x16
7CAC:  CLRF   x15
7CAE:  CLRF   x14
7CB0:  MOVLW  3B
7CB2:  MOVWF  x13
7CB4:  MOVFF  6D6,917
7CB8:  MOVLB  0
7CBA:  CALL   3A6C
7CBE:  BTFSC  19.7
7CC0:  BSF    FF2.7
7CC2:  CLRF   19
7CC4:  BTFSC  FF2.7
7CC6:  BSF    19.7
7CC8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7CCA:  MOVLW  0A
7CCC:  MOVLB  9
7CCE:  MOVWF  x0C
7CD0:  MOVLB  0
7CD2:  CALL   1604
7CD6:  BTFSC  19.7
7CD8:  BSF    FF2.7
7CDA:  CLRF   19
7CDC:  BTFSC  FF2.7
7CDE:  BSF    19.7
7CE0:  BCF    FF2.7
7CE2:  MOVLW  0D
7CE4:  MOVLB  9
7CE6:  MOVWF  x0C
7CE8:  MOVLB  0
7CEA:  CALL   1604
7CEE:  BTFSC  19.7
7CF0:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
7CF2:  GOTO   82EE (RETURN)
.................... //=============================================== 
....................  
....................  
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    if(keydebug_en==1) 
*
5A1A:  MOVLB  1
5A1C:  DECFSZ x44,W
5A1E:  BRA    5A3A
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
5A20:  MOVLB  6
5A22:  MOVF   xE2,F
5A24:  BNZ   5A2E
5A26:  MOVLB  0
5A28:  CALL   1F7C
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
5A2C:  BRA    5A38
5A2E:  MOVLB  0
5A30:  CALL   31E0
5A34:  MOVFF  01,84F
5A38:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
5A3A:  DECFSZ x45,W
5A3C:  BRA    5A56
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
5A3E:  MOVLB  6
5A40:  MOVF   xE2,F
5A42:  BNZ   5A4C
5A44:  MOVLB  0
5A46:  CALL   1F7C
....................          else temp=kbd_getc_slv(); 
5A4A:  BRA    5A56
5A4C:  MOVLB  0
5A4E:  CALL   31E0
5A52:  MOVFF  01,84F
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
5A56:  MOVLB  6
5A58:  MOVF   xC7,F
5A5A:  BNZ   5A7A
5A5C:  MOVF   xC6,F
5A5E:  BNZ   5A7A
5A60:  MOVF   xC5,F
5A62:  BNZ   5A7A
5A64:  MOVF   xC4,W
5A66:  SUBLW  04
5A68:  BNC   5A7A
5A6A:  MOVLW  01
5A6C:  ADDWF  xC4,F
5A6E:  BTFSC  FD8.0
5A70:  INCF   xC5,F
5A72:  BTFSC  FD8.2
5A74:  INCF   xC6,F
5A76:  BTFSC  FD8.2
5A78:  INCF   xC7,F
....................   if(mcr_timeout==5) 
5A7A:  MOVF   xC4,W
5A7C:  SUBLW  05
5A7E:  BNZ   5AEA
5A80:  MOVF   xC5,F
5A82:  BNZ   5AEA
5A84:  MOVF   xC6,F
5A86:  BNZ   5AEA
5A88:  MOVF   xC7,F
5A8A:  BNZ   5AEA
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1) 
5A8C:  DECFSZ xDA,W
5A8E:  BRA    5AA8
....................       { 
....................           if(cryption_enable==0)  
5A90:  MOVLB  1
5A92:  MOVF   x22,F
5A94:  BNZ   5AA0
....................           { 
....................                 saving_card(); 
5A96:  MOVLB  0
5A98:  GOTO   3C02
....................           } 
....................           else  
5A9C:  BRA    5AA6
5A9E:  MOVLB  1
....................           { 
....................                 saving_card_encrypt(); 
5AA0:  MOVLB  0
5AA2:  GOTO   4FD0
5AA6:  MOVLB  6
....................           } 
....................       } 
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
5AA8:  MOVLW  02
5AAA:  MOVWF  FEA
5AAC:  MOVLW  46
5AAE:  MOVWF  FE9
5AB0:  CLRF   00
5AB2:  MOVLW  03
5AB4:  MOVWF  02
5AB6:  MOVLW  52
5AB8:  MOVWF  01
5ABA:  MOVLB  0
5ABC:  CALL   359A
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
5AC0:  MOVLW  05
5AC2:  MOVWF  FEA
5AC4:  MOVLW  98
5AC6:  MOVWF  FE9
5AC8:  CLRF   00
5ACA:  MOVLW  01
5ACC:  MOVWF  02
5ACE:  MOVLW  2C
5AD0:  MOVWF  01
5AD2:  CALL   359A
....................       //debug_card(); 
....................       count_reading_error=0; 
5AD6:  MOVLB  6
5AD8:  CLRF   xDB
....................       mcr_timeout++;   
5ADA:  MOVLW  01
5ADC:  ADDWF  xC4,F
5ADE:  BTFSC  FD8.0
5AE0:  INCF   xC5,F
5AE2:  BTFSC  FD8.2
5AE4:  INCF   xC6,F
5AE6:  BTFSC  FD8.2
5AE8:  INCF   xC7,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
5AEA:  MOVLB  9
5AEC:  CLRF   x1B
5AEE:  CLRF   x1A
5AF0:  CLRF   x19
5AF2:  MOVLW  3C
5AF4:  MOVWF  x18
5AF6:  MOVLB  0
5AF8:  CALL   3450
5AFC:  MOVFF  01,15A
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
5B00:  MOVLW  02
5B02:  MOVLB  8
5B04:  MOVWF  x56
5B06:  MOVLW  BC
5B08:  MOVWF  x55
5B0A:  CLRF   x58
5B0C:  MOVFF  15A,857
5B10:  MOVLB  0
5B12:  CALL   3578
5B16:  MOVFF  02,03
5B1A:  MOVF   01,W
5B1C:  MOVLB  1
5B1E:  MOVF   x00,W
5B20:  SUBWF  02,W
5B22:  BNC   5B42
5B24:  BNZ   5B34
5B26:  MOVF   01,W
5B28:  MOVLB  0
5B2A:  SUBWF  xFF,W
5B2C:  BTFSS  FD8.0
5B2E:  BRA    5B34
5B30:  MOVLB  1
5B32:  BRA    5B42
5B34:  MOVLB  0
5B36:  INCF   xFF,F
5B38:  BTFSS  FD8.2
5B3A:  BRA    5B42
5B3C:  MOVLB  1
5B3E:  INCF   x00,F
5B40:  MOVLB  0
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
5B42:  MOVLW  02
5B44:  MOVLB  8
5B46:  MOVWF  x56
5B48:  MOVLW  BC
5B4A:  MOVWF  x55
5B4C:  CLRF   x58
5B4E:  MOVFF  15A,857
5B52:  MOVLB  0
5B54:  CALL   3578
5B58:  MOVFF  02,03
5B5C:  MOVF   01,W
5B5E:  SUBWF  xFF,W
5B60:  BNZ   5C26
5B62:  MOVF   03,W
5B64:  MOVLB  1
5B66:  SUBWF  x00,W
5B68:  BTFSC  FD8.2
5B6A:  BRA    5B70
5B6C:  MOVLB  0
5B6E:  BRA    5C26
....................   { 
....................       charac_timeout++; 
5B70:  MOVLB  0
5B72:  INCF   xFF,F
5B74:  BTFSS  FD8.2
5B76:  BRA    5B7E
5B78:  MOVLB  1
5B7A:  INCF   x00,F
5B7C:  MOVLB  0
....................       buf=get_countcard(); 
5B7E:  CALL   351C
5B82:  MOVFF  02,84E
5B86:  MOVFF  01,84D
....................       if(buf<countcards) 
5B8A:  MOVLB  8
5B8C:  MOVF   x4E,W
5B8E:  SUBLW  03
5B90:  BNC   5BC6
5B92:  BNZ   5B9A
5B94:  MOVF   x4D,W
5B96:  SUBLW  A1
5B98:  BNC   5BC6
....................       { 
....................          if(cryption_enable==0)  
5B9A:  MOVLB  1
5B9C:  MOVF   x22,F
5B9E:  BNZ   5BA8
....................          { 
....................             save_key_new(); 
5BA0:  MOVLB  0
5BA2:  BRA    54A2
....................          } 
....................          else 
5BA4:  BRA    5BAC
5BA6:  MOVLB  1
....................          { 
....................             save_key_encrypt(); 
5BA8:  MOVLB  0
5BAA:  BRA    5664
....................          } 
....................          buf=buf+1; 
5BAC:  MOVLW  01
5BAE:  MOVLB  8
5BB0:  ADDWF  x4D,F
5BB2:  MOVLW  00
5BB4:  ADDWFC x4E,F
....................          save_coutcard(buf); 
5BB6:  MOVFF  84E,851
5BBA:  MOVFF  84D,850
5BBE:  MOVLB  0
5BC0:  RCALL  58DC
....................       } 
....................          else 
5BC2:  BRA    5BD6
5BC4:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
5BC6:  MOVLW  2C
5BC8:  MOVWF  FF6
5BCA:  MOVLW  5C
5BCC:  MOVWF  FF7
5BCE:  MOVLB  0
5BD0:  CALL   172E
....................             return; 
5BD4:  BRA    5C26
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
5BD6:  MOVLW  3C
5BD8:  MOVWF  FF6
5BDA:  MOVLW  5C
5BDC:  MOVWF  FF7
5BDE:  CALL   172E
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
5BE2:  MOVLW  4C
5BE4:  MOVWF  FF6
5BE6:  MOVLW  5C
5BE8:  MOVWF  FF7
5BEA:  MOVLW  14
5BEC:  MOVLB  8
5BEE:  MOVWF  xF7
5BF0:  MOVLB  0
5BF2:  CALL   164A
5BF6:  MOVLW  10
5BF8:  MOVWF  FE9
5BFA:  MOVFF  84E,851
5BFE:  MOVFF  84D,850
5C02:  RCALL  5924
5C04:  MOVLW  63
5C06:  MOVWF  FF6
5C08:  MOVLW  5C
5C0A:  MOVWF  FF7
5C0C:  MOVLW  03
5C0E:  MOVLB  8
5C10:  MOVWF  xF7
5C12:  MOVLB  0
5C14:  CALL   164A
....................       data_avai=0; 
5C18:  MOVLB  6
5C1A:  CLRF   xD9
....................       enable_getpin=0; 
5C1C:  MOVLB  1
5C1E:  CLRF   x45
....................       //dis_getpin; 
....................       output_low(LED); 
5C20:  BCF    F92.6
5C22:  BCF    F89.6
5C24:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
5C26:  BCF    FF2.2
5C28:  GOTO   006C
.................... void main() 
.................... {  
*
7CF6:  CLRF   FF8
7CF8:  BCF    FD0.7
7CFA:  BSF    07.7
7CFC:  CLRF   FEA
7CFE:  CLRF   FE9
7D00:  BCF    F94.0
7D02:  BSF    F8B.0
7D04:  CLRF   23
7D06:  CLRF   22
7D08:  CLRF   21
7D0A:  MOVLW  96
7D0C:  MOVWF  20
7D0E:  CLRF   27
7D10:  MOVLW  01
7D12:  MOVWF  26
7D14:  MOVLW  C3
7D16:  MOVWF  25
7D18:  MOVLW  0F
7D1A:  MOVWF  24
7D1C:  CLRF   xFE
7D1E:  CLRF   xFD
7D20:  MOVLB  1
7D22:  SETF   x00
7D24:  MOVLB  0
7D26:  SETF   xFF
7D28:  MOVLB  1
7D2A:  CLRF   x22
7D2C:  CLRF   x43
7D2E:  CLRF   x44
7D30:  CLRF   x45
7D32:  MOVLW  64
7D34:  MOVWF  x46
7D36:  CLRF   x47
7D38:  CLRF   x48
7D3A:  CLRF   x49
7D3C:  CLRF   x5A
7D3E:  CLRF   x5F
7D40:  CLRF   xC6
7D42:  CLRF   xC7
7D44:  MOVLW  0E
7D46:  MOVWF  xC9
7D48:  MOVLW  01
7D4A:  MOVWF  xCA
7D4C:  MOVWF  xCB
7D4E:  CLRF   xCC
7D50:  CLRF   xCD
7D52:  CLRF   xCE
7D54:  MOVLB  6
7D56:  CLRF   xC7
7D58:  CLRF   xC6
7D5A:  CLRF   xC5
7D5C:  CLRF   xC4
7D5E:  CLRF   xC8
7D60:  CLRF   xCA
7D62:  CLRF   xC9
7D64:  CLRF   xCC
7D66:  CLRF   xCB
7D68:  CLRF   xCE
7D6A:  CLRF   xCD
7D6C:  CLRF   xD0
7D6E:  CLRF   xCF
7D70:  MOVLW  FD
7D72:  MOVWF  xD2
7D74:  MOVLW  E8
7D76:  MOVWF  xD1
7D78:  CLRF   xD4
7D7A:  CLRF   xD3
7D7C:  CLRF   xD5
7D7E:  CLRF   xD6
7D80:  CLRF   xD7
7D82:  CLRF   xD8
7D84:  CLRF   xD9
7D86:  CLRF   xDA
7D88:  CLRF   xDB
7D8A:  CLRF   xDC
7D8C:  CLRF   xDD
7D8E:  CLRF   xDF
7D90:  MOVLW  01
7D92:  MOVWF  xDE
7D94:  CLRF   xE1
7D96:  CLRF   xE0
7D98:  CLRF   xE2
7D9A:  CLRF   xE6
7D9C:  CLRF   xE5
7D9E:  CLRF   xE4
7DA0:  CLRF   xE3
7DA2:  MOVLW  FF
7DA4:  MOVLB  F
7DA6:  MOVWF  x48
7DA8:  BCF    FC2.6
7DAA:  BCF    FC2.7
7DAC:  MOVF   x49,W
7DAE:  ANDLW  E0
7DB0:  IORLW  1F
7DB2:  MOVWF  x49
7DB4:  CLRF   FD2
7DB6:  CLRF   FD1
7DB8:  CLRF   1A
7DBA:  CLRF   1B
7DBC:  MOVLW  E8
7DBE:  MOVLB  1
7DC0:  MOVWF  x23
7DC2:  MOVLW  E9
7DC4:  MOVWF  x24
7DC6:  MOVLW  EA
7DC8:  MOVWF  x25
7DCA:  MOVLW  EB
7DCC:  MOVWF  x26
7DCE:  MOVLW  ED
7DD0:  MOVWF  x27
7DD2:  MOVLW  EE
7DD4:  MOVWF  x28
7DD6:  MOVLW  EF
7DD8:  MOVWF  x29
7DDA:  MOVLW  F0
7DDC:  MOVWF  x2A
7DDE:  MOVLW  F2
7DE0:  MOVWF  x2B
7DE2:  MOVLW  F3
7DE4:  MOVWF  x2C
7DE6:  MOVLW  F4
7DE8:  MOVWF  x2D
7DEA:  MOVLW  F5
7DEC:  MOVWF  x2E
7DEE:  MOVLW  F7
7DF0:  MOVWF  x2F
7DF2:  MOVLW  F8
7DF4:  MOVWF  x30
7DF6:  MOVLW  F9
7DF8:  MOVWF  x31
7DFA:  MOVLW  FA
7DFC:  MOVWF  x32
7DFE:  MOVLW  67
7E00:  MOVWF  x33
7E02:  MOVLW  43
7E04:  MOVWF  x34
7E06:  MOVLW  C3
7E08:  MOVWF  x35
7E0A:  MOVLW  D1
7E0C:  MOVWF  x36
7E0E:  MOVLW  51
7E10:  MOVWF  x37
7E12:  MOVLW  9A
7E14:  MOVWF  x38
7E16:  MOVLW  B4
7E18:  MOVWF  x39
7E1A:  MOVLW  F2
7E1C:  MOVWF  x3A
7E1E:  MOVLW  CD
7E20:  MOVWF  x3B
7E22:  MOVLW  9A
7E24:  MOVWF  x3C
7E26:  MOVLW  78
7E28:  MOVWF  x3D
7E2A:  MOVLW  AB
7E2C:  MOVWF  x3E
7E2E:  MOVLW  09
7E30:  MOVWF  x3F
7E32:  MOVLW  A5
7E34:  MOVWF  x40
7E36:  MOVLW  11
7E38:  MOVWF  x41
7E3A:  MOVLW  BD
7E3C:  MOVWF  x42
7E3E:  CLRF   x5B
7E40:  BCF    x5C.0
7E42:  CLRF   x5D
7E44:  CLRF   x5E
7E46:  CLRF   x60
7E48:  BCF    x5C.1
7E4A:  CLRF   x61
7E4C:  MOVLB  6
7E4E:  CLRF   xF7
7E50:  CLRF   xF8
7E52:  CLRF   xF9
7E54:  CLRF   xFA
7E56:  CLRF   xFB
7E58:  CLRF   xFC
7E5A:  CLRF   xFD
7E5C:  CLRF   xFE
7E5E:  CLRF   xFF
7E60:  MOVLB  7
7E62:  CLRF   x00
7E64:  CLRF   x03
7E66:  CLRF   x05
7E68:  CLRF   x04
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    RPINR1=5; 
7E6A:  MOVLW  05
7E6C:  MOVLB  E
7E6E:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
7E70:  MOVLB  1
7E72:  SETF   x00
7E74:  MOVLB  0
7E76:  SETF   xFF
....................    setup_oscillator(OSC_32MHZ); 
7E78:  MOVLW  70
7E7A:  MOVWF  FD3
7E7C:  MOVLW  40
7E7E:  MOVWF  F9B
7E80:  MOVF   FD3,W
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
7E82:  BCF    FF2.6
7E84:  BCF    FF2.7
7E86:  BTFSC  FF2.7
7E88:  BRA    7E84
....................    init_ext_eeprom(); 
7E8A:  GOTO   5D24
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif   
....................    //===================================== 
....................    delay_ms(1000); 
7E8E:  MOVLW  04
7E90:  MOVLB  7
7E92:  MOVWF  xBD
7E94:  CLRF   19
7E96:  BTFSC  FF2.7
7E98:  BSF    19.7
7E9A:  BCF    FF2.7
7E9C:  MOVLW  FA
7E9E:  MOVLB  8
7EA0:  MOVWF  x56
7EA2:  MOVLB  0
7EA4:  CALL   18C6
7EA8:  BTFSC  19.7
7EAA:  BSF    FF2.7
7EAC:  MOVLB  7
7EAE:  DECFSZ xBD,F
7EB0:  BRA    7E94
....................    init_password(); 
7EB2:  MOVLB  0
7EB4:  CALL   5D2E
....................    //===================================== 
....................     
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
7EB8:  MOVLW  19
7EBA:  MOVLB  7
7EBC:  MOVWF  xBD
7EBE:  MOVLB  0
7EC0:  CALL   5DEA
7EC4:  MOVFF  03,23
7EC8:  MOVFF  02,22
7ECC:  MOVFF  01,21
7ED0:  MOVFF  00,20
....................    printf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
7ED4:  CLRF   FEA
7ED6:  MOVLW  01
7ED8:  MOVWF  FE9
7EDA:  CALL   5F40
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
7EDE:  MOVLW  1E
7EE0:  MOVLB  7
7EE2:  MOVWF  xBD
7EE4:  MOVLB  0
7EE6:  CALL   5DEA
7EEA:  MOVFF  03,27
7EEE:  MOVFF  02,26
7EF2:  MOVFF  01,25
7EF6:  MOVFF  00,24
....................    fprintf(COM2,"booting\n\r"); 
7EFA:  MOVLW  68
7EFC:  MOVWF  FF6
7EFE:  MOVLW  5C
7F00:  MOVWF  FF7
7F02:  CLRF   19
7F04:  BTFSC  FF2.7
7F06:  BSF    19.7
7F08:  BCF    FF2.7
7F0A:  CALL   172E
7F0E:  BTFSC  19.7
7F10:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
7F12:  MOVLW  72
7F14:  MOVWF  FF6
7F16:  MOVLW  5C
7F18:  MOVWF  FF7
7F1A:  CLRF   19
7F1C:  BTFSC  FF2.7
7F1E:  BSF    19.7
7F20:  BCF    FF2.7
7F22:  MOVLW  12
7F24:  MOVLB  8
7F26:  MOVWF  xF7
7F28:  MOVLB  0
7F2A:  CALL   164A
7F2E:  BTFSC  19.7
7F30:  BSF    FF2.7
7F32:  MOVLW  41
7F34:  MOVWF  FE9
7F36:  CLRF   19
7F38:  BTFSC  FF2.7
7F3A:  BSF    19.7
7F3C:  BCF    FF2.7
7F3E:  MOVFF  27,8FA
7F42:  MOVFF  26,8F9
7F46:  MOVFF  25,8F8
7F4A:  MOVFF  24,8F7
7F4E:  CALL   22FA
7F52:  BTFSC  19.7
7F54:  BSF    FF2.7
7F56:  CLRF   19
7F58:  BTFSC  FF2.7
7F5A:  BSF    19.7
7F5C:  BCF    FF2.7
7F5E:  MOVLW  0A
7F60:  MOVLB  9
7F62:  MOVWF  x0C
7F64:  MOVLB  0
7F66:  CALL   1604
7F6A:  BTFSC  19.7
7F6C:  BSF    FF2.7
7F6E:  CLRF   19
7F70:  BTFSC  FF2.7
7F72:  BSF    19.7
7F74:  BCF    FF2.7
7F76:  MOVLW  0D
7F78:  MOVLB  9
7F7A:  MOVWF  x0C
7F7C:  MOVLB  0
7F7E:  CALL   1604
7F82:  BTFSC  19.7
7F84:  BSF    FF2.7
7F86:  CLRF   19
7F88:  BTFSC  FF2.7
7F8A:  BSF    19.7
7F8C:  BCF    FF2.7
....................    countcard=get_countcard(); 
7F8E:  CALL   351C
7F92:  BTFSC  19.7
7F94:  BSF    FF2.7
7F96:  MOVFF  02,FE
7F9A:  MOVFF  01,FD
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
7F9E:  MOVLB  1
7FA0:  SETF   x00
7FA2:  MOVLB  0
7FA4:  SETF   xFF
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
7FA6:  MOVLW  C7
7FA8:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
7FAA:  MOVLW  37
7FAC:  MOVWF  FCD
7FAE:  CLRF   F9A
7FB0:  CLRF   19
7FB2:  BTFSC  FF2.7
7FB4:  BSF    19.7
7FB6:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
7FB8:  MOVLB  9
7FBA:  CLRF   x1B
7FBC:  CLRF   x1A
7FBE:  CLRF   x19
7FC0:  MOVLW  3C
7FC2:  MOVWF  x18
7FC4:  MOVLB  0
7FC6:  CALL   3450
7FCA:  BTFSC  19.7
7FCC:  BSF    FF2.7
7FCE:  MOVFF  01,15A
....................    if(delaycharaction==0)delaycharaction=1; 
7FD2:  MOVLB  1
7FD4:  MOVF   x5A,F
7FD6:  BNZ   7FDC
7FD8:  MOVLW  01
7FDA:  MOVWF  x5A
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
7FDC:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
7FDE:  BSF    FF0.3
7FE0:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
7FE2:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
7FE4:  MOVLW  C0
7FE6:  IORWF  FF2,F
....................   
....................     mcr_timeout=10000; 
7FE8:  MOVLB  6
7FEA:  CLRF   xC7
7FEC:  CLRF   xC6
7FEE:  MOVLW  27
7FF0:  MOVWF  xC5
7FF2:  MOVLW  10
7FF4:  MOVWF  xC4
7FF6:  CLRF   19
7FF8:  BTFSC  FF2.7
7FFA:  BSF    19.7
7FFC:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
7FFE:  MOVLB  9
8000:  CLRF   x1B
8002:  CLRF   x1A
8004:  CLRF   x19
8006:  MOVLW  3A
8008:  MOVWF  x18
800A:  MOVLB  0
800C:  CALL   3450
8010:  BTFSC  19.7
8012:  BSF    FF2.7
8014:  MOVFF  01,6E2
8018:  CLRF   19
801A:  BTFSC  FF2.7
801C:  BSF    19.7
801E:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
8020:  MOVLB  9
8022:  CLRF   x1B
8024:  CLRF   x1A
8026:  CLRF   x19
8028:  MOVLW  3B
802A:  MOVWF  x18
802C:  MOVLB  0
802E:  CALL   3450
8032:  BTFSC  19.7
8034:  BSF    FF2.7
8036:  MOVFF  01,6D6
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
803A:  MOVLB  1
803C:  SETF   x00
803E:  MOVLB  0
8040:  SETF   xFF
8042:  CLRF   19
8044:  BTFSC  FF2.7
8046:  BSF    19.7
8048:  BCF    FF2.7
....................     
....................    EEPROM_read(strobe_nameconsole,wide_strobe_nameconsole,console); 
804A:  MOVLB  9
804C:  CLRF   x07
804E:  CLRF   x06
8050:  CLRF   x05
8052:  MOVLW  28
8054:  MOVWF  x04
8056:  CLRF   x0B
8058:  CLRF   x0A
805A:  CLRF   x09
805C:  MOVLW  10
805E:  MOVWF  x08
8060:  MOVLW  06
8062:  MOVWF  x0D
8064:  MOVLW  E7
8066:  MOVWF  x0C
8068:  MOVLB  0
806A:  CALL   4004
806E:  BTFSC  19.7
8070:  BSF    FF2.7
....................    set_tris_a(0xff);  
8072:  MOVLW  FF
8074:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
8076:  MOVLW  E0
8078:  MOVLB  F
807A:  MOVWF  x48
807C:  BCF    FC2.6
807E:  BCF    FC2.7
8080:  MOVF   x49,W
8082:  ANDLW  E0
8084:  IORLW  1F
8086:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
8088:  MOVF   FC1,W
808A:  ANDLW  C0
808C:  IORLW  03
808E:  MOVWF  FC1
8090:  BCF    FC1.7
8092:  BSF    FC2.0
8094:  BSF    FC1.6
8096:  BSF    FC2.1
8098:  BTFSC  FC2.1
809A:  BRA    8098
809C:  BCF    FC1.6
809E:  CLRF   19
80A0:  BTFSC  FF2.7
80A2:  BSF    19.7
80A4:  BCF    FF2.7
....................     
....................    type_KB=read_ext_eeprom(kindofKB); 
80A6:  MOVLB  9
80A8:  CLRF   x1B
80AA:  CLRF   x1A
80AC:  CLRF   x19
80AE:  MOVLW  3D
80B0:  MOVWF  x18
80B2:  MOVLB  0
80B4:  CALL   3450
80B8:  BTFSC  19.7
80BA:  BSF    FF2.7
80BC:  MOVFF  01,149
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
80C0:  MOVLB  1
80C2:  MOVF   x49,F
80C4:  BZ    80E4
80C6:  MOVLW  8A
80C8:  MOVWF  FF6
80CA:  MOVLW  5C
80CC:  MOVWF  FF7
80CE:  CLRF   19
80D0:  BTFSC  FF2.7
80D2:  BSF    19.7
80D4:  BCF    FF2.7
80D6:  MOVLB  0
80D8:  CALL   172E
80DC:  BTFSC  19.7
80DE:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
80E0:  BRA    80FE
80E2:  MOVLB  1
80E4:  MOVLW  9E
80E6:  MOVWF  FF6
80E8:  MOVLW  5C
80EA:  MOVWF  FF7
80EC:  CLRF   19
80EE:  BTFSC  FF2.7
80F0:  BSF    19.7
80F2:  BCF    FF2.7
80F4:  MOVLB  0
80F6:  CALL   172E
80FA:  BTFSC  19.7
80FC:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
80FE:  MOVLB  6
8100:  MOVF   xE2,F
8102:  BNZ   8122
8104:  MOVLW  B2
8106:  MOVWF  FF6
8108:  MOVLW  5C
810A:  MOVWF  FF7
810C:  CLRF   19
810E:  BTFSC  FF2.7
8110:  BSF    19.7
8112:  BCF    FF2.7
8114:  MOVLB  0
8116:  CALL   172E
811A:  BTFSC  19.7
811C:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
811E:  BRA    813C
8120:  MOVLB  6
8122:  MOVLW  CC
8124:  MOVWF  FF6
8126:  MOVLW  5C
8128:  MOVWF  FF7
812A:  CLRF   19
812C:  BTFSC  FF2.7
812E:  BSF    19.7
8130:  BCF    FF2.7
8132:  MOVLB  0
8134:  CALL   172E
8138:  BTFSC  19.7
813A:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
813C:  MOVLW  01
813E:  MOVWF  FEA
8140:  MOVLW  4A
8142:  MOVWF  FE9
8144:  CLRF   00
8146:  CLRF   02
8148:  MOVLW  10
814A:  MOVWF  01
814C:  CALL   359A
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
8150:  MOVLB  7
8152:  CLRF   x01
8154:  MOVF   x01,W
8156:  SUBLW  13
8158:  BNC   816E
....................    { 
....................       password[i] = 0; 
815A:  CLRF   03
815C:  MOVF   x01,W
815E:  ADDLW  55
8160:  MOVWF  FE9
8162:  MOVLW  00
8164:  ADDWFC 03,W
8166:  MOVWF  FEA
8168:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 0 
....................    disable_interrupts(GLOBAL); 
....................    save_coutcard(0); 
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................     
....................    save_key_encrypt(); 
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
....................     
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_data in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_key in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],1); 
....................    //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rdecrypted:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    while(1); 
.................... #endif 
.................... #if 0 
816A:  INCF   x01,F
816C:  BRA    8154
816E:  CLRF   19
8170:  BTFSC  FF2.7
8172:  BSF    19.7
8174:  BCF    FF2.7
....................     fprintf(COM2,"\n\reeprom test\n\r"); 
....................     fprintf(COM2,"\n\reeprom is writing\n\r"); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         //write_ext_eeprom(115535+i,i); 
....................     } 
....................     write_ext_eeprom(EEPROM_KEY_ST,210); 
....................     write_ext_eeprom(EEPROM_SIZE_endofkey,123); 
....................     fprintf(COM2,"\n\r"); 
....................     fprintf(COM2,"eeprom is reading: %u",read_ext_eeprom(EEPROM_KEY_ST)); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         fprintf(COM2," %u",read_ext_eeprom(115535+i)); 
....................     } 
....................     while(1); 
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
8176:  MOVLB  9
8178:  CLRF   x07
817A:  CLRF   x06
817C:  CLRF   x05
817E:  CLRF   x04
8180:  CLRF   x0B
8182:  CLRF   x0A
8184:  CLRF   x09
8186:  MOVLW  14
8188:  MOVWF  x08
818A:  CLRF   x0D
818C:  MOVLW  55
818E:  MOVWF  x0C
8190:  MOVLB  0
8192:  CALL   4004
8196:  BTFSC  19.7
8198:  BSF    FF2.7
819A:  CLRF   19
819C:  BTFSC  FF2.7
819E:  BSF    19.7
81A0:  BCF    FF2.7
....................    cryption_enable = read_ext_eeprom(crypto_en); 
81A2:  MOVLB  9
81A4:  CLRF   x1B
81A6:  CLRF   x1A
81A8:  CLRF   x19
81AA:  MOVLW  3E
81AC:  MOVWF  x18
81AE:  MOVLB  0
81B0:  CALL   3450
81B4:  BTFSC  19.7
81B6:  BSF    FF2.7
81B8:  MOVFF  01,122
....................    if(cryption_enable!=0) 
81BC:  MOVLB  1
81BE:  MOVF   x22,F
81C0:  BZ    820E
....................    { 
....................         fprintf(COM2,"\n\crypto is enable\n\r"); 
81C2:  MOVLW  E4
81C4:  MOVWF  FF6
81C6:  MOVLW  5C
81C8:  MOVWF  FF7
81CA:  CLRF   19
81CC:  BTFSC  FF2.7
81CE:  BSF    19.7
81D0:  BCF    FF2.7
81D2:  MOVLB  0
81D4:  CALL   172E
81D8:  BTFSC  19.7
81DA:  BSF    FF2.7
81DC:  CLRF   19
81DE:  BTFSC  FF2.7
81E0:  BSF    19.7
81E2:  BCF    FF2.7
....................         EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key);  
81E4:  MOVLB  9
81E6:  CLRF   x07
81E8:  CLRF   x06
81EA:  CLRF   x05
81EC:  MOVLW  3F
81EE:  MOVWF  x04
81F0:  CLRF   x0B
81F2:  CLRF   x0A
81F4:  CLRF   x09
81F6:  MOVLW  20
81F8:  MOVWF  x08
81FA:  MOVLW  01
81FC:  MOVWF  x0D
81FE:  MOVWF  x0C
8200:  MOVLB  0
8202:  CALL   4004
8206:  BTFSC  19.7
8208:  BSF    FF2.7
....................    } 
....................    else 
820A:  BRA    8228
820C:  MOVLB  1
....................    { 
....................        fprintf(COM2,"\n\crypto is disable\n\r"); 
820E:  MOVLW  F8
8210:  MOVWF  FF6
8212:  MOVLW  5C
8214:  MOVWF  FF7
8216:  CLRF   19
8218:  BTFSC  FF2.7
821A:  BSF    19.7
821C:  BCF    FF2.7
821E:  MOVLB  0
8220:  CALL   172E
8224:  BTFSC  19.7
8226:  BSF    FF2.7
....................    } 
.................... #if 0    
....................    fprintf(COM2,"\n\crypto key:\n\r"); 
....................    for(i=0;i<CRYPTO_KEY_SIZE;i++) 
....................    { 
....................         fprintf(COM2,"%c",crypto_key[i]); 
....................    } 
....................    fprintf(COM2,"\n\r"); 
.................... #endif    
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
8228:  MOVLB  6
822A:  MOVF   xDC,F
822C:  BNZ   82E4
....................       { 
....................          fprintf(COM2,"password:"); 
822E:  MOVLW  0E
8230:  MOVWF  FF6
8232:  MOVLW  5D
8234:  MOVWF  FF7
8236:  CLRF   19
8238:  BTFSC  FF2.7
823A:  BSF    19.7
823C:  BCF    FF2.7
823E:  MOVLB  0
8240:  CALL   172E
8244:  BTFSC  19.7
8246:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
8248:  MOVLW  02
824A:  MOVLB  7
824C:  MOVWF  xF3
824E:  MOVLW  14
8250:  MOVWF  xF4
8252:  MOVLW  01
8254:  MOVWF  xF6
8256:  MOVLW  62
8258:  MOVWF  xF5
825A:  MOVLB  0
825C:  CALL   5FC0
8260:  CLRF   19
8262:  BTFSC  FF2.7
8264:  BSF    19.7
8266:  BCF    FF2.7
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
8268:  MOVLB  9
826A:  CLRF   x07
826C:  CLRF   x06
826E:  CLRF   x05
8270:  CLRF   x04
8272:  CLRF   x0B
8274:  CLRF   x0A
8276:  CLRF   x09
8278:  MOVLW  14
827A:  MOVWF  x08
827C:  CLRF   x0D
827E:  MOVLW  55
8280:  MOVWF  x0C
8282:  MOVLB  0
8284:  CALL   4004
8288:  BTFSC  19.7
828A:  BSF    FF2.7
....................          if(!stringcomp(buffer_uart,password)) 
828C:  MOVLW  01
828E:  MOVLB  7
8290:  MOVWF  xF4
8292:  MOVLW  62
8294:  MOVWF  xF3
8296:  CLRF   xF6
8298:  MOVLW  55
829A:  MOVWF  xF5
829C:  MOVLB  0
829E:  CALL   60F8
82A2:  MOVF   01,F
82A4:  BNZ   82C8
....................          { 
....................             mode=LOGON; 
82A6:  MOVLW  01
82A8:  MOVLB  6
82AA:  MOVWF  xDC
....................             fprintf(COM2," OK\n\r"); 
82AC:  MOVLW  18
82AE:  MOVWF  FF6
82B0:  MOVLW  5D
82B2:  MOVWF  FF7
82B4:  CLRF   19
82B6:  BTFSC  FF2.7
82B8:  BSF    19.7
82BA:  BCF    FF2.7
82BC:  MOVLB  0
82BE:  CALL   172E
82C2:  BTFSC  19.7
82C4:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
82C6:  BRA    82E0
82C8:  MOVLW  1E
82CA:  MOVWF  FF6
82CC:  MOVLW  5D
82CE:  MOVWF  FF7
82D0:  CLRF   19
82D2:  BTFSC  FF2.7
82D4:  BSF    19.7
82D6:  BCF    FF2.7
82D8:  CALL   172E
82DC:  BTFSC  19.7
82DE:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
82E0:  BRA    82EE
82E2:  MOVLB  6
82E4:  DECFSZ xDC,W
82E6:  BRA    82F0
82E8:  MOVLB  0
82EA:  GOTO   6BB6
82EE:  MOVLB  6
....................    } 
82F0:  BRA    822A
.................... } 
82F2:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

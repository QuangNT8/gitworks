CCS PCH C Compiler, Version 4.140, 33034               18-Jul-18 20:43

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   27614 bytes (42%)
                           Largest free fragment is 37910
               RAM used:   1959 (52%) at main() level
                           2114 (56%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   66E8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   408C
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   198A
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
03FC:  MOVLW  02
03FE:  MOVLB  8
0400:  SUBWF  x05,F
0402:  BNC   041C
0404:  MOVLW  08
0406:  MOVWF  FEA
0408:  MOVLW  05
040A:  MOVWF  FE9
040C:  MOVF   FEF,W
040E:  BZ    041C
0410:  BRA    0418
0412:  BRA    0414
0414:  BRA    0416
0416:  NOP   
0418:  DECFSZ FEF,F
041A:  BRA    0412
041C:  MOVLB  0
041E:  GOTO   199A (RETURN)
*
1658:  MOVLW  08
165A:  MOVWF  FEA
165C:  MOVLW  0D
165E:  MOVWF  FE9
1660:  MOVF   FEF,W
1662:  BZ    167E
1664:  MOVLW  0A
1666:  MOVWF  01
1668:  CLRF   00
166A:  DECFSZ 00,F
166C:  BRA    166A
166E:  DECFSZ 01,F
1670:  BRA    1668
1672:  MOVLW  5F
1674:  MOVWF  00
1676:  DECFSZ 00,F
1678:  BRA    1676
167A:  DECFSZ FEF,F
167C:  BRA    1664
167E:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
0422:  BCF    F94.0
0424:  BCF    F8B.0
0426:  MOVLW  08
0428:  MOVWF  01
042A:  BRA    042C
042C:  NOP   
042E:  BSF    01.7
0430:  BRA    0452
0432:  BCF    01.7
0434:  MOVLB  8
0436:  RRCF   x30,F
0438:  MOVLB  0
043A:  BTFSC  FD8.0
043C:  BSF    F8B.0
043E:  BTFSS  FD8.0
0440:  BCF    F8B.0
0442:  BSF    01.6
0444:  BRA    0452
0446:  BCF    01.6
0448:  DECFSZ 01,F
044A:  BRA    0434
044C:  BRA    044E
044E:  NOP   
0450:  BSF    F8B.0
0452:  MOVLW  01
0454:  MOVWF  00
0456:  CLRF   FE9
0458:  DECFSZ FE9,F
045A:  BRA    0458
045C:  DECFSZ 00,F
045E:  BRA    0456
0460:  MOVLW  0E
0462:  MOVWF  FE9
0464:  DECFSZ FE9,F
0466:  BRA    0464
0468:  NOP   
046A:  BTFSC  01.7
046C:  BRA    0432
046E:  BTFSC  01.6
0470:  BRA    0446
0472:  RETURN 0
*
47CA:  BSF    F94.1
47CC:  BTFSC  F82.1
47CE:  BRA    47CC
47D0:  MOVLW  08
47D2:  MOVWF  00
47D4:  MOVLB  7
47D6:  CLRF   xE4
47D8:  BSF    00.7
47DA:  BRA    47F8
47DC:  BCF    00.7
47DE:  BRA    47F8
47E0:  BCF    FD8.0
47E2:  BTFSC  F82.1
47E4:  BSF    FD8.0
47E6:  RRCF   xE4,F
47E8:  BSF    00.6
47EA:  BRA    47F8
47EC:  BCF    00.6
47EE:  DECFSZ 00,F
47F0:  BRA    47E0
47F2:  MOVFF  7E4,01
47F6:  BRA    4822
47F8:  MOVLW  01
47FA:  MOVWF  FE9
47FC:  MOVLW  00
47FE:  BTFSC  00.7
4800:  MOVLW  55
4802:  MOVWF  01
4804:  DECFSZ 01,F
4806:  BRA    4804
4808:  DECFSZ FE9,F
480A:  BRA    47FC
480C:  MOVLW  0D
480E:  BTFSC  00.7
4810:  MOVLW  03
4812:  MOVWF  01
4814:  DECFSZ 01,F
4816:  BRA    4814
4818:  BTFSC  00.7
481A:  BRA    47DC
481C:  BTFSC  00.6
481E:  BRA    47EC
4820:  BRA    47E0
4822:  MOVLB  0
4824:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3200:  MOVLW  08
3202:  MOVWF  01
3204:  MOVLW  0A
3206:  MOVWF  00
3208:  DECFSZ 00,F
320A:  BRA    3208
320C:  BCF    F8B.3
320E:  BCF    F94.3
3210:  MOVLW  0B
3212:  MOVWF  00
3214:  DECFSZ 00,F
3216:  BRA    3214
3218:  MOVLB  8
321A:  RLCF   x24,F
321C:  BCF    F8B.4
321E:  BTFSC  FD8.0
3220:  BSF    F94.4
3222:  BTFSS  FD8.0
3224:  BCF    F94.4
3226:  BSF    F94.3
3228:  BTFSS  F82.3
322A:  BRA    3228
322C:  DECFSZ 01,F
322E:  BRA    3232
3230:  BRA    3236
3232:  MOVLB  0
3234:  BRA    3204
3236:  MOVLW  0A
3238:  MOVWF  00
323A:  DECFSZ 00,F
323C:  BRA    323A
323E:  BCF    F8B.3
3240:  BCF    F94.3
3242:  NOP   
3244:  BSF    F94.4
3246:  MOVLW  0B
3248:  MOVWF  00
324A:  DECFSZ 00,F
324C:  BRA    324A
324E:  MOVLW  0B
3250:  MOVWF  00
3252:  DECFSZ 00,F
3254:  BRA    3252
3256:  BSF    F94.3
3258:  BTFSS  F82.3
325A:  BRA    3258
325C:  CLRF   01
325E:  MOVLW  0B
3260:  MOVWF  00
3262:  DECFSZ 00,F
3264:  BRA    3262
3266:  BTFSC  F82.4
3268:  BSF    01.0
326A:  BCF    F8B.3
326C:  BCF    F94.3
326E:  BCF    F8B.4
3270:  BCF    F94.4
3272:  MOVLB  0
3274:  RETURN 0
3276:  MOVLW  08
3278:  MOVLB  8
327A:  MOVWF  x17
327C:  MOVFF  00,818
3280:  BSF    F94.4
3282:  MOVLW  0B
3284:  MOVWF  00
3286:  DECFSZ 00,F
3288:  BRA    3286
328A:  BSF    F94.3
328C:  BTFSS  F82.3
328E:  BRA    328C
3290:  BTFSC  F82.4
3292:  BSF    FD8.0
3294:  BTFSS  F82.4
3296:  BCF    FD8.0
3298:  RLCF   01,F
329A:  MOVLW  0A
329C:  MOVWF  00
329E:  DECFSZ 00,F
32A0:  BRA    329E
32A2:  BCF    F94.3
32A4:  BCF    F8B.3
32A6:  DECFSZ x17,F
32A8:  BRA    3280
32AA:  BSF    F94.4
32AC:  MOVLW  0B
32AE:  MOVWF  00
32B0:  DECFSZ 00,F
32B2:  BRA    32B0
32B4:  BCF    F8B.4
32B6:  MOVF   x18,W
32B8:  BTFSS  FD8.2
32BA:  BCF    F94.4
32BC:  NOP   
32BE:  BSF    F94.3
32C0:  BTFSS  F82.3
32C2:  BRA    32C0
32C4:  MOVLW  0A
32C6:  MOVWF  00
32C8:  DECFSZ 00,F
32CA:  BRA    32C8
32CC:  BCF    F8B.3
32CE:  BCF    F94.3
32D0:  MOVLW  0B
32D2:  MOVWF  00
32D4:  DECFSZ 00,F
32D6:  BRA    32D4
32D8:  BCF    F8B.4
32DA:  BCF    F94.4
32DC:  MOVLB  0
32DE:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE_key    131071 
.................... #define EEPROM_SIZE        115470 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
436C:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
436E:  BSF    F94.4
....................    port_b_pullups(0xff); 
4370:  BCF    FF1.7
.................... } 
4372:  GOTO   6820 (RETURN)
.................... /* 
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
....................    if(address<0xffff)i2c_write(0xa0); 
....................       else if(address>=0xffff) i2c_write(0xa2); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
....................    i2c_start(); 
....................    status=i2c_write(0xa0); 
....................    while(status==1) 
....................    { 
....................       i2c_start(); 
....................       status=i2c_write(0xa0); 
....................    } 
....................    i2c_stop(); 
.................... } 
.................... */ 
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3830:  MOVLB  8
3832:  MOVF   x1B,F
3834:  BNZ   383C
3836:  MOVF   x1A,W
3838:  SUBLW  00
383A:  BC    3842
383C:  MOVLW  A8
383E:  MOVWF  x1E
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3840:  BRA    3846
3842:  MOVLW  A0
3844:  MOVWF  x1E
....................  
....................    i2c_start(); 
3846:  BSF    F94.4
3848:  MOVLW  0A
384A:  MOVWF  00
384C:  DECFSZ 00,F
384E:  BRA    384C
3850:  BSF    F94.3
3852:  MOVLW  0B
3854:  MOVWF  00
3856:  DECFSZ 00,F
3858:  BRA    3856
385A:  BCF    F8B.4
385C:  BCF    F94.4
385E:  MOVLW  0A
3860:  MOVWF  00
3862:  DECFSZ 00,F
3864:  BRA    3862
3866:  BCF    F8B.3
3868:  BCF    F94.3
....................    i2c_write(command); 
386A:  MOVFF  81E,824
386E:  MOVLB  0
3870:  RCALL  3200
....................    i2c_write(address>>8); 
3872:  MOVFF  819,820
3876:  MOVFF  81A,821
387A:  MOVFF  81B,822
387E:  MOVLB  8
3880:  CLRF   x23
3882:  MOVFF  819,824
3886:  MOVLB  0
3888:  RCALL  3200
....................    i2c_write(address); 
388A:  MOVFF  818,824
388E:  RCALL  3200
....................    i2c_write(data); 
3890:  MOVFF  81C,824
3894:  RCALL  3200
....................  
....................    i2c_stop(); 
3896:  BCF    F94.4
3898:  NOP   
389A:  BSF    F94.3
389C:  BTFSS  F82.3
389E:  BRA    389C
38A0:  MOVLW  0A
38A2:  MOVWF  00
38A4:  DECFSZ 00,F
38A6:  BRA    38A4
38A8:  BRA    38AA
38AA:  NOP   
38AC:  BSF    F94.4
38AE:  MOVLW  0A
38B0:  MOVWF  00
38B2:  DECFSZ 00,F
38B4:  BRA    38B2
....................    i2c_start(); 
38B6:  BSF    F94.4
38B8:  MOVLW  0A
38BA:  MOVWF  00
38BC:  DECFSZ 00,F
38BE:  BRA    38BC
38C0:  BSF    F94.3
38C2:  MOVLW  0B
38C4:  MOVWF  00
38C6:  DECFSZ 00,F
38C8:  BRA    38C6
38CA:  BCF    F8B.4
38CC:  BCF    F94.4
38CE:  MOVLW  0A
38D0:  MOVWF  00
38D2:  DECFSZ 00,F
38D4:  BRA    38D2
38D6:  BCF    F8B.3
38D8:  BCF    F94.3
....................    status=i2c_write(command); 
38DA:  MOVFF  81E,824
38DE:  RCALL  3200
38E0:  MOVF   01,W
38E2:  MOVLB  8
38E4:  BCF    x1D.0
38E6:  BTFSC  01.0
38E8:  BSF    x1D.0
....................    while(status==1) 
....................    { 
38EA:  BTFSS  x1D.0
38EC:  BRA    392A
....................       i2c_start(); 
38EE:  BSF    F94.4
38F0:  MOVLW  0A
38F2:  MOVWF  00
38F4:  DECFSZ 00,F
38F6:  BRA    38F4
38F8:  BSF    F94.3
38FA:  MOVLW  0B
38FC:  MOVWF  00
38FE:  DECFSZ 00,F
3900:  BRA    38FE
3902:  BTFSS  F82.3
3904:  BRA    3902
3906:  BCF    F8B.4
3908:  BCF    F94.4
390A:  MOVLW  0A
390C:  MOVWF  00
390E:  DECFSZ 00,F
3910:  BRA    390E
3912:  BCF    F8B.3
3914:  BCF    F94.3
....................       status=i2c_write(command); 
3916:  MOVFF  81E,824
391A:  MOVLB  0
391C:  RCALL  3200
391E:  MOVF   01,W
3920:  MOVLB  8
3922:  BCF    x1D.0
3924:  BTFSC  01.0
3926:  BSF    x1D.0
....................    } 
3928:  BRA    38EA
....................    //delay_us(100); 
.................... } 
392A:  MOVLB  0
392C:  RETURN 0
....................  
.................... /* 
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(0xa1); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    return(data); 
.................... } 
.................... */ 
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
32E0:  MOVLB  8
32E2:  MOVF   x13,F
32E4:  BNZ   32EC
32E6:  MOVF   x12,W
32E8:  SUBLW  00
32EA:  BC    32F2
32EC:  MOVLW  A8
32EE:  MOVWF  x15
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
32F0:  BRA    32F6
32F2:  MOVLW  A0
32F4:  MOVWF  x15
....................  
....................    i2c_start(); 
32F6:  BSF    F94.4
32F8:  MOVLW  0A
32FA:  MOVWF  00
32FC:  DECFSZ 00,F
32FE:  BRA    32FC
3300:  BSF    F94.3
3302:  MOVLW  0B
3304:  MOVWF  00
3306:  DECFSZ 00,F
3308:  BRA    3306
330A:  BTFSS  F82.3
330C:  BRA    330A
330E:  BCF    F8B.4
3310:  BCF    F94.4
3312:  MOVLW  0A
3314:  MOVWF  00
3316:  DECFSZ 00,F
3318:  BRA    3316
331A:  BCF    F8B.3
331C:  BCF    F94.3
....................    i2c_write(command); 
331E:  MOVFF  815,824
3322:  MOVLB  0
3324:  RCALL  3200
....................    i2c_write(address>>8); 
3326:  MOVFF  811,817
332A:  MOVFF  812,818
332E:  MOVFF  813,819
3332:  MOVLB  8
3334:  CLRF   x1A
3336:  MOVFF  811,824
333A:  MOVLB  0
333C:  RCALL  3200
....................    i2c_write(address); 
333E:  MOVFF  810,824
3342:  RCALL  3200
....................    i2c_start(); 
3344:  BSF    F94.4
3346:  MOVLW  0A
3348:  MOVWF  00
334A:  DECFSZ 00,F
334C:  BRA    334A
334E:  BSF    F94.3
3350:  MOVLW  0B
3352:  MOVWF  00
3354:  DECFSZ 00,F
3356:  BRA    3354
3358:  BTFSS  F82.3
335A:  BRA    3358
335C:  BCF    F8B.4
335E:  BCF    F94.4
3360:  MOVLW  0A
3362:  MOVWF  00
3364:  DECFSZ 00,F
3366:  BRA    3364
3368:  BCF    F8B.3
336A:  BCF    F94.3
....................    i2c_write(command+1); 
336C:  MOVLW  01
336E:  MOVLB  8
3370:  ADDWF  x15,W
3372:  MOVWF  x16
3374:  MOVWF  x24
3376:  MOVLB  0
3378:  RCALL  3200
....................    data=i2c_read(0); 
337A:  CLRF   00
337C:  RCALL  3276
337E:  MOVFF  01,814
....................    i2c_stop(); 
3382:  BCF    F94.4
3384:  NOP   
3386:  BSF    F94.3
3388:  BTFSS  F82.3
338A:  BRA    3388
338C:  MOVLW  0A
338E:  MOVWF  00
3390:  DECFSZ 00,F
3392:  BRA    3390
3394:  BRA    3396
3396:  NOP   
3398:  BSF    F94.4
339A:  MOVLW  0A
339C:  MOVWF  00
339E:  DECFSZ 00,F
33A0:  BRA    339E
....................    return(data); 
33A2:  MOVLB  8
33A4:  MOVFF  814,01
.................... } 
33A8:  MOVLB  0
33AA:  RETURN 0
....................  
....................  
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
4A2A:  MOVLB  7
4A2C:  MOVF   xDF,W
4A2E:  ADDWF  xDD,W
4A30:  MOVF   xE0,W
4A32:  ADDWFC xDE,W
4A34:  MOVWF  xE6
....................    for(i=0;i<len;i++) 
4A36:  CLRF   xE4
4A38:  CLRF   xE3
4A3A:  MOVF   xE4,W
4A3C:  SUBWF  xE0,W
4A3E:  BNC   4A9A
4A40:  BNZ   4A48
4A42:  MOVF   xDF,W
4A44:  SUBWF  xE3,W
4A46:  BC    4A9A
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
4A48:  MOVF   xE1,W
4A4A:  ADDWF  xE3,W
4A4C:  MOVWF  01
4A4E:  MOVF   xE2,W
4A50:  ADDWFC xE4,W
4A52:  MOVWF  03
4A54:  MOVFF  01,7E5
4A58:  MOVWF  xE6
4A5A:  MOVF   xE3,W
4A5C:  ADDWF  xDD,W
4A5E:  MOVWF  xE7
4A60:  MOVF   xE4,W
4A62:  ADDWFC xDE,W
4A64:  MOVWF  xE8
4A66:  CLRF   19
4A68:  BTFSC  FF2.7
4A6A:  BSF    19.7
4A6C:  BCF    FF2.7
4A6E:  MOVLB  8
4A70:  CLRF   x13
4A72:  CLRF   x12
4A74:  MOVWF  x11
4A76:  MOVFF  7E7,810
4A7A:  MOVLB  0
4A7C:  CALL   32E0
4A80:  BTFSC  19.7
4A82:  BSF    FF2.7
4A84:  MOVFF  7E6,FEA
4A88:  MOVFF  7E5,FE9
4A8C:  MOVFF  01,FEF
....................    } 
4A90:  MOVLB  7
4A92:  INCF   xE3,F
4A94:  BTFSC  FD8.2
4A96:  INCF   xE4,F
4A98:  BRA    4A3A
....................     
.................... } 
4A9A:  MOVLB  0
4A9C:  GOTO   528C (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "aes.h" 
.................... /************************************************************************************************************* 
.................... *    Titre:         Dfinitions du module d'encryption AES. 
.................... *    Fichier:       aes.h 
.................... *    Date:          07/02/2007 
.................... *************************************************************************************************************/ 
....................  
.................... /************************************************************************************************************ 
....................  ** @file aes.h                                                                                             
....................  ** @brief Dfinitions du module d'encryption AES.                                                            
....................  ************************************************************************************************************/ 
....................  
.................... #ifndef __AES_H__ 
.................... #define __AES_H__ 
.................... /************************************************************************************************************* 
.................... 	Dfinition des constantes 
.................... *************************************************************************************************************/ 
.................... #define CRYPTO_KEY_SIZE	32 
....................  
.................... /************************************************************************************************************* 
.................... 	Dfinition des variables globales 
.................... *************************************************************************************************************/ 
.................... char crypto_key[CRYPTO_KEY_SIZE+1]; 
....................  
.................... /************************************************************************************************************* 
.................... 	Dfinition des fonctions 
.................... *************************************************************************************************************/ 
.................... unsigned char rcon(int); 
.................... unsigned char sub_s_box(unsigned char, unsigned char); 
.................... unsigned char multi(char, char); 
.................... int expand_key(unsigned char key[4*4], unsigned char w[4*4*11]); 
.................... int select_key(unsigned char expanded_key[4*4*11], unsigned char round_key[4][4], int round); 
.................... int byte_sub(unsigned char state[4][4], unsigned char cmd); 
.................... int shift_row(unsigned char state[4][4], unsigned char cmd); 
.................... int mix_column(unsigned char state[4][4], unsigned char cmd); 
.................... int add_round_key(unsigned char state[4][4], unsigned char round_key[4][4]); 
.................... int aes_round(unsigned char state[4][4], unsigned char round_key[4][4], int round, unsigned char cmd); 
.................... int rijndael(unsigned char cmd, unsigned char data[16], unsigned char cipher_key[16]); 
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_mobile_num0        65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_two_number        149 
.................... #define kindofKB                 126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards               930   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
3426:  MOVLB  8
3428:  CLRF   x19
342A:  MOVF   x16,W
342C:  SUBWF  x19,W
342E:  BC    3444
....................    { 
....................       inputdat[i]=0; 
3430:  CLRF   03
3432:  MOVF   x19,W
3434:  ADDWF  x17,W
3436:  MOVWF  FE9
3438:  MOVF   x18,W
343A:  ADDWFC 03,W
343C:  MOVWF  FEA
343E:  CLRF   FEF
....................    } 
3440:  INCF   x19,F
3442:  BRA    342A
.................... } 
3444:  MOVLB  0
3446:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_write(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
43D6:  MOVLB  7
43D8:  CLRF   xF4
43DA:  MOVF   xF1,W
43DC:  SUBWF  xF4,W
43DE:  BC    442A
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
43E0:  MOVF   xF4,W
43E2:  ADDWF  xF0,W
43E4:  MOVWF  xF5
43E6:  CLRF   03
43E8:  MOVF   xF4,W
43EA:  ADDWF  xF2,W
43EC:  MOVWF  FE9
43EE:  MOVF   xF3,W
43F0:  ADDWFC 03,W
43F2:  MOVWF  FEA
43F4:  MOVFF  FEF,7F6
43F8:  CLRF   19
43FA:  BTFSC  FF2.7
43FC:  BSF    19.7
43FE:  BCF    FF2.7
4400:  MOVLB  8
4402:  CLRF   x1B
4404:  CLRF   x1A
4406:  CLRF   x19
4408:  MOVFF  7F5,818
440C:  MOVFF  7F6,81C
4410:  MOVLB  0
4412:  CALL   3830
4416:  BTFSC  19.7
4418:  BSF    FF2.7
....................       delay_us(10); 
441A:  MOVLW  1A
441C:  MOVWF  00
441E:  DECFSZ 00,F
4420:  BRA    441E
4422:  NOP   
....................    } 
4424:  MOVLB  7
4426:  INCF   xF4,F
4428:  BRA    43DA
.................... } 
442A:  MOVLB  0
442C:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
4376:  MOVLB  7
4378:  CLRF   xDF
437A:  MOVF   xDC,W
437C:  SUBWF  xDF,W
437E:  BC    43D2
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
4380:  CLRF   03
4382:  MOVF   xDF,W
4384:  ADDWF  xDD,W
4386:  MOVWF  01
4388:  MOVF   xDE,W
438A:  ADDWFC 03,F
438C:  MOVFF  01,7E0
4390:  MOVFF  03,7E1
4394:  MOVF   xDF,W
4396:  ADDWF  xDB,W
4398:  MOVWF  xE2
439A:  CLRF   19
439C:  BTFSC  FF2.7
439E:  BSF    19.7
43A0:  BCF    FF2.7
43A2:  MOVLB  8
43A4:  CLRF   x13
43A6:  CLRF   x12
43A8:  CLRF   x11
43AA:  MOVWF  x10
43AC:  MOVLB  0
43AE:  CALL   32E0
43B2:  BTFSC  19.7
43B4:  BSF    FF2.7
43B6:  MOVFF  7E1,FEA
43BA:  MOVFF  7E0,FE9
43BE:  MOVFF  01,FEF
....................       delay_us(10); 
43C2:  MOVLW  1A
43C4:  MOVWF  00
43C6:  DECFSZ 00,F
43C8:  BRA    43C6
43CA:  NOP   
....................    } 
43CC:  MOVLB  7
43CE:  INCF   xDF,F
43D0:  BRA    437A
.................... } 
43D2:  MOVLB  0
43D4:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
4674:  MOVLB  7
4676:  CLRF   xA9
4678:  CLRF   xA8
467A:  CLRF   xA7
467C:  CLRF   xA6
467E:  CLRF   xAD
4680:  CLRF   xAC
4682:  CLRF   xAB
4684:  CLRF   xAA
4686:  CLRF   xB1
4688:  CLRF   xB0
468A:  CLRF   xAF
468C:  CLRF   xAE
468E:  CLRF   xB5
4690:  CLRF   xB4
4692:  CLRF   xB3
4694:  CLRF   xB2
4696:  CLRF   xB9
4698:  CLRF   xB8
469A:  CLRF   xB7
469C:  CLRF   xB6
469E:  CLRF   19
46A0:  BTFSC  FF2.7
46A2:  BSF    19.7
46A4:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
46A6:  MOVLB  8
46A8:  CLRF   x13
46AA:  CLRF   x12
46AC:  CLRF   x11
46AE:  MOVFF  7A5,810
46B2:  MOVLB  0
46B4:  CALL   32E0
46B8:  BTFSC  19.7
46BA:  BSF    FF2.7
46BC:  MOVLB  7
46BE:  MOVFF  01,7AA
46C2:  CLRF   xAB
46C4:  CLRF   xAC
46C6:  CLRF   xAD
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
46C8:  MOVLW  01
46CA:  ADDWF  xA5,W
46CC:  MOVWF  xBA
46CE:  CLRF   19
46D0:  BTFSC  FF2.7
46D2:  BSF    19.7
46D4:  BCF    FF2.7
46D6:  MOVLB  8
46D8:  CLRF   x13
46DA:  CLRF   x12
46DC:  CLRF   x11
46DE:  MOVWF  x10
46E0:  MOVLB  0
46E2:  CALL   32E0
46E6:  BTFSC  19.7
46E8:  BSF    FF2.7
46EA:  MOVLB  7
46EC:  CLRF   xB1
46EE:  CLRF   xB0
46F0:  CLRF   xAF
46F2:  MOVFF  01,7AE
....................    temp2<<=8; 
46F6:  MOVFF  7B0,7B1
46FA:  MOVFF  7AF,7B0
46FE:  MOVFF  7AE,7AF
4702:  CLRF   xAE
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
4704:  MOVLW  02
4706:  ADDWF  xA5,W
4708:  MOVWF  xBA
470A:  CLRF   19
470C:  BTFSC  FF2.7
470E:  BSF    19.7
4710:  BCF    FF2.7
4712:  MOVLB  8
4714:  CLRF   x13
4716:  CLRF   x12
4718:  CLRF   x11
471A:  MOVWF  x10
471C:  MOVLB  0
471E:  CALL   32E0
4722:  BTFSC  19.7
4724:  BSF    FF2.7
4726:  MOVLB  7
4728:  CLRF   xB5
472A:  CLRF   xB4
472C:  CLRF   xB3
472E:  MOVFF  01,7B2
....................    temp3<<=16; 
4732:  MOVFF  7B3,7B5
4736:  MOVFF  7B2,7B4
473A:  CLRF   xB2
473C:  CLRF   xB3
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
473E:  MOVLW  03
4740:  ADDWF  xA5,W
4742:  MOVWF  xBA
4744:  CLRF   19
4746:  BTFSC  FF2.7
4748:  BSF    19.7
474A:  BCF    FF2.7
474C:  MOVLB  8
474E:  CLRF   x13
4750:  CLRF   x12
4752:  CLRF   x11
4754:  MOVWF  x10
4756:  MOVLB  0
4758:  CALL   32E0
475C:  BTFSC  19.7
475E:  BSF    FF2.7
4760:  MOVLB  7
4762:  CLRF   xB9
4764:  CLRF   xB8
4766:  CLRF   xB7
4768:  MOVFF  01,7B6
....................    temp4<<=24; 
476C:  MOVFF  7B6,7B9
4770:  CLRF   xB6
4772:  CLRF   xB7
4774:  CLRF   xB8
....................    buffer = temp4|temp3|temp2|temp1; 
4776:  MOVF   xB6,W
4778:  IORWF  xB2,W
477A:  MOVWF  xBA
477C:  MOVF   xB7,W
477E:  IORWF  xB3,W
4780:  MOVWF  xBB
4782:  MOVF   xB8,W
4784:  IORWF  xB4,W
4786:  MOVWF  xBC
4788:  MOVF   xB9,W
478A:  IORWF  xB5,W
478C:  MOVWF  xBD
478E:  MOVF   xAE,W
4790:  IORWF  xBA,F
4792:  MOVF   xAF,W
4794:  IORWF  xBB,F
4796:  MOVF   xB0,W
4798:  IORWF  xBC,F
479A:  MOVF   xB1,W
479C:  IORWF  xBD,F
479E:  MOVF   xBA,W
47A0:  IORWF  xAA,W
47A2:  MOVWF  xA6
47A4:  MOVF   xBB,W
47A6:  IORWF  xAB,W
47A8:  MOVWF  xA7
47AA:  MOVF   xBC,W
47AC:  IORWF  xAC,W
47AE:  MOVWF  xA8
47B0:  MOVF   xBD,W
47B2:  IORWF  xAD,W
47B4:  MOVWF  xA9
....................    return(buffer); 
47B6:  MOVFF  7A6,00
47BA:  MOVFF  7A7,01
47BE:  MOVFF  7A8,02
47C2:  MOVFF  7A9,03
.................... } 
47C6:  MOVLB  0
47C8:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
392E:  MOVLB  8
3930:  CLRF   x12
3932:  CLRF   x11
3934:  CLRF   x10
3936:  CLRF   x0F
3938:  CLRF   x13
393A:  CLRF   x14
393C:  CLRF   x15
393E:  CLRF   x16
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3940:  MOVFF  80D,812
3944:  MOVFF  80C,811
3948:  MOVFF  80B,810
394C:  MOVFF  80A,80F
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3950:  MOVFF  80F,813
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3954:  MOVFF  810,814
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3958:  MOVFF  811,815
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
395C:  MOVFF  812,816
....................    write_ext_eeprom((addr+0),temp1); 
3960:  CLRF   x1B
3962:  CLRF   x1A
3964:  CLRF   x19
3966:  MOVFF  80E,818
396A:  MOVFF  813,81C
396E:  MOVLB  0
3970:  RCALL  3830
....................    write_ext_eeprom((addr+1),temp2); 
3972:  MOVLW  01
3974:  MOVLB  8
3976:  ADDWF  x0E,W
3978:  MOVWF  x17
397A:  CLRF   x1B
397C:  CLRF   x1A
397E:  CLRF   x19
3980:  MOVWF  x18
3982:  MOVFF  814,81C
3986:  MOVLB  0
3988:  RCALL  3830
....................    write_ext_eeprom((addr+2),temp3); 
398A:  MOVLW  02
398C:  MOVLB  8
398E:  ADDWF  x0E,W
3990:  MOVWF  x17
3992:  CLRF   x1B
3994:  CLRF   x1A
3996:  CLRF   x19
3998:  MOVWF  x18
399A:  MOVFF  815,81C
399E:  MOVLB  0
39A0:  RCALL  3830
....................    write_ext_eeprom((addr+3),temp4); 
39A2:  MOVLW  03
39A4:  MOVLB  8
39A6:  ADDWF  x0E,W
39A8:  MOVWF  x17
39AA:  CLRF   x1B
39AC:  CLRF   x1A
39AE:  CLRF   x19
39B0:  MOVWF  x18
39B2:  MOVFF  816,81C
39B6:  MOVLB  0
39B8:  RCALL  3830
.................... } 
39BA:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
3F54:  MOVLB  8
3F56:  CLRF   x0A
3F58:  CLRF   x09
3F5A:  CLRF   x0B
3F5C:  CLRF   x0C
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
3F5E:  MOVFF  808,80A
3F62:  MOVFF  807,809
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3F66:  MOVFF  809,80B
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3F6A:  MOVF   x0A,W
3F6C:  MOVWF  x0C
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
3F6E:  CLRF   x1B
3F70:  CLRF   x1A
3F72:  CLRF   x19
3F74:  MOVLW  28
3F76:  MOVWF  x18
3F78:  MOVFF  80B,81C
3F7C:  MOVLB  0
3F7E:  RCALL  3830
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
3F80:  MOVLB  8
3F82:  CLRF   x1B
3F84:  CLRF   x1A
3F86:  CLRF   x19
3F88:  MOVLW  29
3F8A:  MOVWF  x18
3F8C:  MOVFF  80C,81C
3F90:  MOVLB  0
3F92:  RCALL  3830
.................... } 
3F94:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
33AC:  MOVLB  8
33AE:  CLRF   x0B
33B0:  CLRF   x0A
33B2:  CLRF   x0D
33B4:  CLRF   x0C
33B6:  CLRF   x0F
33B8:  CLRF   x0E
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
33BA:  CLRF   x13
33BC:  CLRF   x12
33BE:  CLRF   x11
33C0:  MOVLW  28
33C2:  MOVWF  x10
33C4:  MOVLB  0
33C6:  RCALL  32E0
33C8:  MOVLB  8
33CA:  MOVFF  01,80C
33CE:  CLRF   x0D
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
33D0:  CLRF   x13
33D2:  CLRF   x12
33D4:  CLRF   x11
33D6:  MOVLW  29
33D8:  MOVWF  x10
33DA:  MOVLB  0
33DC:  RCALL  32E0
33DE:  MOVLB  8
33E0:  CLRF   x0F
33E2:  MOVFF  01,80E
....................    temp2<<=8; 
33E6:  MOVFF  80E,80F
33EA:  CLRF   x0E
....................    buffer = temp2|temp1; 
33EC:  MOVF   x0E,W
33EE:  IORWF  x0C,W
33F0:  MOVWF  x0A
33F2:  MOVF   x0F,W
33F4:  IORWF  x0D,W
33F6:  MOVWF  x0B
....................    return(buffer); 
33F8:  MOVFF  80A,01
33FC:  MOVFF  80B,02
.................... } 
3400:  MOVLB  0
3402:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2,"EEPROM_KEY_ST=%lu\n\r",EEPROM_KEY_ST); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
4BBA:  MOVLB  7
4BBC:  CLRF   xDE
4BBE:  MOVLW  01
4BC0:  MOVWF  xDD
4BC2:  MOVLW  C3
4BC4:  MOVWF  xDC
4BC6:  MOVLW  0F
4BC8:  MOVWF  xDB
4BCA:  MOVF   xDE,W
4BCC:  SUBWF  27,W
4BCE:  BNC   4C22
4BD0:  BNZ   4BE8
4BD2:  MOVF   xDD,W
4BD4:  SUBWF  26,W
4BD6:  BNC   4C22
4BD8:  BNZ   4BE8
4BDA:  MOVF   xDC,W
4BDC:  SUBWF  25,W
4BDE:  BNC   4C22
4BE0:  BNZ   4BE8
4BE2:  MOVF   24,W
4BE4:  SUBWF  xDB,W
4BE6:  BC    4C22
4BE8:  CLRF   19
4BEA:  BTFSC  FF2.7
4BEC:  BSF    19.7
4BEE:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
4BF0:  MOVFF  7DE,81B
4BF4:  MOVFF  7DD,81A
4BF8:  MOVFF  7DC,819
4BFC:  MOVFF  7DB,818
4C00:  MOVLB  8
4C02:  CLRF   x1C
4C04:  MOVLB  0
4C06:  CALL   3830
4C0A:  BTFSC  19.7
4C0C:  BSF    FF2.7
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    } 
4C0E:  MOVLW  01
4C10:  MOVLB  7
4C12:  ADDWF  xDB,F
4C14:  BTFSC  FD8.0
4C16:  INCF   xDC,F
4C18:  BTFSC  FD8.2
4C1A:  INCF   xDD,F
4C1C:  BTFSC  FD8.2
4C1E:  INCF   xDE,F
4C20:  BRA    4BCA
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=ptr_start;i<ptr_card;i++) 
4C22:  CLRF   xDE
4C24:  CLRF   xDD
4C26:  CLRF   xDC
4C28:  MOVLW  96
4C2A:  MOVWF  xDB
4C2C:  MOVF   xDE,W
4C2E:  SUBWF  23,W
4C30:  BNC   4C84
4C32:  BNZ   4C4A
4C34:  MOVF   xDD,W
4C36:  SUBWF  22,W
4C38:  BNC   4C84
4C3A:  BNZ   4C4A
4C3C:  MOVF   xDC,W
4C3E:  SUBWF  21,W
4C40:  BNC   4C84
4C42:  BNZ   4C4A
4C44:  MOVF   20,W
4C46:  SUBWF  xDB,W
4C48:  BC    4C84
4C4A:  CLRF   19
4C4C:  BTFSC  FF2.7
4C4E:  BSF    19.7
4C50:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
4C52:  MOVFF  7DE,81B
4C56:  MOVFF  7DD,81A
4C5A:  MOVFF  7DC,819
4C5E:  MOVFF  7DB,818
4C62:  MOVLB  8
4C64:  CLRF   x1C
4C66:  MOVLB  0
4C68:  CALL   3830
4C6C:  BTFSC  19.7
4C6E:  BSF    FF2.7
....................    } 
4C70:  MOVLW  01
4C72:  MOVLB  7
4C74:  ADDWF  xDB,F
4C76:  BTFSC  FD8.0
4C78:  INCF   xDC,F
4C7A:  BTFSC  FD8.2
4C7C:  INCF   xDD,F
4C7E:  BTFSC  FD8.2
4C80:  INCF   xDE,F
4C82:  BRA    4C2C
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
4C84:  CLRF   23
4C86:  CLRF   22
4C88:  CLRF   21
4C8A:  MOVLW  96
4C8C:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
4C8E:  CLRF   27
4C90:  MOVLW  01
4C92:  MOVWF  26
4C94:  MOVLW  C3
4C96:  MOVWF  25
4C98:  MOVLW  0F
4C9A:  MOVWF  24
4C9C:  CLRF   19
4C9E:  BTFSC  FF2.7
4CA0:  BSF    19.7
4CA2:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
4CA4:  MOVFF  23,80D
4CA8:  MOVFF  22,80C
4CAC:  MOVFF  21,80B
4CB0:  MOVFF  20,80A
4CB4:  MOVLW  19
4CB6:  MOVLB  8
4CB8:  MOVWF  x0E
4CBA:  MOVLB  0
4CBC:  CALL   392E
4CC0:  BTFSC  19.7
4CC2:  BSF    FF2.7
4CC4:  CLRF   19
4CC6:  BTFSC  FF2.7
4CC8:  BSF    19.7
4CCA:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
4CCC:  MOVFF  27,80D
4CD0:  MOVFF  26,80C
4CD4:  MOVFF  25,80B
4CD8:  MOVFF  24,80A
4CDC:  MOVLW  1E
4CDE:  MOVLB  8
4CE0:  MOVWF  x0E
4CE2:  MOVLB  0
4CE4:  CALL   392E
4CE8:  BTFSC  19.7
4CEA:  BSF    FF2.7
4CEC:  CLRF   19
4CEE:  BTFSC  FF2.7
4CF0:  BSF    19.7
4CF2:  BCF    FF2.7
....................    save_coutcard(0); 
4CF4:  MOVLB  8
4CF6:  CLRF   x08
4CF8:  CLRF   x07
4CFA:  MOVLB  0
4CFC:  CALL   3F54
4D00:  BTFSC  19.7
4D02:  BSF    FF2.7
4D04:  CLRF   19
4D06:  BTFSC  FF2.7
4D08:  BSF    19.7
4D0A:  BCF    FF2.7
....................    countcard=get_countcard(); 
4D0C:  CALL   33AC
4D10:  BTFSC  19.7
4D12:  BSF    FF2.7
4D14:  MOVFF  02,11B
4D18:  MOVFF  01,11A
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
4D1C:  GOTO   55FE (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    /*for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    ptr_card=ptr_start; 
4D20:  CLRF   23
4D22:  CLRF   22
4D24:  CLRF   21
4D26:  MOVLW  96
4D28:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
4D2A:  CLRF   27
4D2C:  MOVLW  01
4D2E:  MOVWF  26
4D30:  MOVLW  C3
4D32:  MOVWF  25
4D34:  MOVLW  0F
4D36:  MOVWF  24
4D38:  CLRF   19
4D3A:  BTFSC  FF2.7
4D3C:  BSF    19.7
4D3E:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
4D40:  MOVFF  23,80D
4D44:  MOVFF  22,80C
4D48:  MOVFF  21,80B
4D4C:  MOVFF  20,80A
4D50:  MOVLW  19
4D52:  MOVLB  8
4D54:  MOVWF  x0E
4D56:  MOVLB  0
4D58:  CALL   392E
4D5C:  BTFSC  19.7
4D5E:  BSF    FF2.7
4D60:  CLRF   19
4D62:  BTFSC  FF2.7
4D64:  BSF    19.7
4D66:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
4D68:  MOVFF  27,80D
4D6C:  MOVFF  26,80C
4D70:  MOVFF  25,80B
4D74:  MOVFF  24,80A
4D78:  MOVLW  1E
4D7A:  MOVLB  8
4D7C:  MOVWF  x0E
4D7E:  MOVLB  0
4D80:  CALL   392E
4D84:  BTFSC  19.7
4D86:  BSF    FF2.7
4D88:  CLRF   19
4D8A:  BTFSC  FF2.7
4D8C:  BSF    19.7
4D8E:  BCF    FF2.7
....................    save_coutcard(0); 
4D90:  MOVLB  8
4D92:  CLRF   x08
4D94:  CLRF   x07
4D96:  MOVLB  0
4D98:  CALL   3F54
4D9C:  BTFSC  19.7
4D9E:  BSF    FF2.7
.................... } 
4DA0:  GOTO   5664 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
442E:  MOVLB  7
4430:  CLRF   xDB
4432:  MOVLW  14
4434:  MOVWF  xDC
4436:  CLRF   xDE
4438:  MOVLW  76
443A:  MOVWF  xDD
443C:  MOVLB  0
443E:  RCALL  4376
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
4440:  INCFSZ x76,W
4442:  BRA    4498
4444:  INCFSZ x77,W
4446:  BRA    4498
4448:  INCFSZ x85,W
444A:  BRA    4498
....................       { 
....................          memset(buffer1,0,20); 
444C:  CLRF   FEA
444E:  MOVLW  4E
4450:  MOVWF  FE9
4452:  CLRF   00
4454:  CLRF   02
4456:  MOVLW  14
4458:  MOVWF  01
445A:  RCALL  3DC2
....................          strcpy(buffer1,"admin"); 
445C:  CLRF   FEA
445E:  MOVLW  4E
4460:  MOVWF  FE9
4462:  MOVLW  00
4464:  CALL   00BA
4468:  TBLRD*-
446A:  TBLRD*+
446C:  MOVF   FF5,W
446E:  MOVWF  FEE
4470:  IORLW  00
4472:  BNZ   446A
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
4474:  MOVLB  7
4476:  CLRF   xF0
4478:  MOVLW  14
447A:  MOVWF  xF1
447C:  CLRF   xF3
447E:  MOVLW  4E
4480:  MOVWF  xF2
4482:  MOVLB  0
4484:  RCALL  43D6
....................          EEPROM_read(strobe_pass_addr,20,password); 
4486:  MOVLB  7
4488:  CLRF   xDB
448A:  MOVLW  14
448C:  MOVWF  xDC
448E:  CLRF   xDE
4490:  MOVLW  76
4492:  MOVWF  xDD
4494:  MOVLB  0
4496:  RCALL  4376
....................       } 
.................... } 
4498:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
4DA4:  MOVLB  7
4DA6:  CLRF   xEF
4DA8:  MOVF   xEF,W
4DAA:  SUBLW  13
4DAC:  BNC   4DC2
4DAE:  CLRF   03
4DB0:  MOVF   xEF,W
4DB2:  ADDLW  DB
4DB4:  MOVWF  FE9
4DB6:  MOVLW  07
4DB8:  ADDWFC 03,W
4DBA:  MOVWF  FEA
4DBC:  SETF   FEF
4DBE:  INCF   xEF,F
4DC0:  BRA    4DA8
....................    EEPROM_write(strobe_pass_addr,20,buf); 
4DC2:  CLRF   xF0
4DC4:  MOVLW  14
4DC6:  MOVWF  xF1
4DC8:  MOVLW  07
4DCA:  MOVWF  xF3
4DCC:  MOVLW  DB
4DCE:  MOVWF  xF2
4DD0:  MOVLB  0
4DD2:  CALL   43D6
.................... } 
4DD6:  GOTO   56CA (RETURN)
.................... //============================================ 
.................... void reset_2nd_number() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0; 
....................    EEPROM_write(strobe_mobile_num0,20,buf); 
.................... } 
....................  
.................... #include <cryption.C> 
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "aes.h" 
.................... /************************************************************************************************************* 
.................... *    Titre:         Dfinitions du module d'encryption AES. 
.................... *    Fichier:       aes.h 
.................... *    Date:          07/02/2007 
.................... *************************************************************************************************************/ 
....................  
.................... /************************************************************************************************************ 
....................  ** @file aes.h                                                                                             
....................  ** @brief Dfinitions du module d'encryption AES.                                                            
....................  ************************************************************************************************************/ 
....................  
.................... #ifndef __AES_H__ 
.................... #define __AES_H__ 
.................... /************************************************************************************************************* 
.................... 	Dfinition des constantes 
.................... *************************************************************************************************************/ 
.................... #define CRYPTO_KEY_SIZE	32 
....................  
.................... /************************************************************************************************************* 
.................... 	Dfinition des variables globales 
.................... *************************************************************************************************************/ 
.................... char crypto_key[CRYPTO_KEY_SIZE+1]; 
....................  
.................... /************************************************************************************************************* 
.................... 	Dfinition des fonctions 
.................... *************************************************************************************************************/ 
.................... unsigned char rcon(int); 
.................... unsigned char sub_s_box(unsigned char, unsigned char); 
.................... unsigned char multi(char, char); 
.................... int expand_key(unsigned char key[4*4], unsigned char w[4*4*11]); 
.................... int select_key(unsigned char expanded_key[4*4*11], unsigned char round_key[4][4], int round); 
.................... int byte_sub(unsigned char state[4][4], unsigned char cmd); 
.................... int shift_row(unsigned char state[4][4], unsigned char cmd); 
.................... int mix_column(unsigned char state[4][4], unsigned char cmd); 
.................... int add_round_key(unsigned char state[4][4], unsigned char round_key[4][4]); 
.................... int aes_round(unsigned char state[4][4], unsigned char round_key[4][4], int round, unsigned char cmd); 
.................... int rijndael(unsigned char cmd, unsigned char data[16], unsigned char cipher_key[16]); 
....................  
.................... #endif 
....................  
.................... //=========================================================== 
.................... unsigned int crcccitt(unsigned int crc_init, char donnee[], unsigned long int size) 
.................... { 
....................    char index; 
....................     unsigned long int i; 
....................  
....................      for(i = 0; i < size; i++) 
....................       { 
....................           crc_init = (unsigned int)(crc_init ^ (donnee[i] << 8)); 
....................   
....................            for(index = 0; index <= 7; index++) 
....................            { 
....................                if(crc_init & 0x8000) 
....................                    crc_init = (unsigned int)((crc_init << 1) ^ 0x1021); 
....................                else 
....................                    crc_init = (unsigned int)(crc_init << 1); 
....................              } 
....................      } 
....................     return crc_init; 
.................... } 
.................... //=========================================================== 
.................... void write_kb_i2ceeprom(void) 
.................... { 
....................       unsigned long adr; 
....................       unsigned int i; 
....................       unsigned int crc; 
....................       int8 rec[34]; 
....................       int8 retval; 
....................  
....................       rec[0]=33;                                    /* Prochaine chaine dans 33 cars. */ 
....................       rec[1]=32;                                    /* Nombre de bytes de la chaine */ 
....................       rec[2]=0; 
....................       rec[3]=0;                 /* Mois en byte */ 
....................       rec[4]=0;;                        /* Jour en byte */ 
....................       rec[5]=0;                     /* Heure en byte */ 
....................       rec[6]=0;                     /* Minute en byte */ 
....................       rec[7]=0;                     /* Seconde en byte */ 
....................  
....................       rec[8]=0x01;                                 /* Type Clavier */ 
....................  
....................       
....................  
....................       crc=crcccitt(0, &rec[1], 30);   /* Calcul du CRC 16 (CCITT) de la chaine */ 
....................  
....................       rec[31]=(unsigned char)(crc & 0x00FF); 
....................       rec[32]=(unsigned char)((crc & 0xFF00)>>8); 
....................  
....................       rec[33]=0xFF;            /* Terminaison de la liste par 0xFF */ 
....................  
....................       /** Encryption de la chaine */ 
....................       rijndael('c', (unsigned char *)&rec[1], (unsigned char *)&crypto_key[0]); 
....................       rijndael('c', (unsigned char *)&rec[17], (unsigned char *)&crypto_key[16]); 
....................  
....................       //read_eeptr(&adr);         /* Lecture de l'adresse de fin de liste */ 
....................  
....................       EEPROM_write(adr,34,rec);   /* criture de la chaine */ 
.................... } 
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
449A:  BSF    F94.4
449C:  MOVLW  0A
449E:  MOVWF  00
44A0:  DECFSZ 00,F
44A2:  BRA    44A0
44A4:  BSF    F94.3
44A6:  MOVLW  0B
44A8:  MOVWF  00
44AA:  DECFSZ 00,F
44AC:  BRA    44AA
44AE:  BCF    F8B.4
44B0:  BCF    F94.4
44B2:  MOVLW  0A
44B4:  MOVWF  00
44B6:  DECFSZ 00,F
44B8:  BRA    44B6
44BA:  BCF    F8B.3
44BC:  BCF    F94.3
44BE:  CLRF   19
44C0:  BTFSC  FF2.7
44C2:  BSF    19.7
44C4:  BCF    FF2.7
....................    i2c_write(0xD0); 
44C6:  MOVLW  D0
44C8:  MOVLB  8
44CA:  MOVWF  x24
44CC:  MOVLB  0
44CE:  CALL   3200
44D2:  BTFSC  19.7
44D4:  BSF    FF2.7
44D6:  CLRF   19
44D8:  BTFSC  FF2.7
44DA:  BSF    19.7
44DC:  BCF    FF2.7
....................    i2c_write(address); 
44DE:  MOVFF  7DF,824
44E2:  CALL   3200
44E6:  BTFSC  19.7
44E8:  BSF    FF2.7
....................    i2c_start(); 
44EA:  BSF    F94.4
44EC:  MOVLW  0A
44EE:  MOVWF  00
44F0:  DECFSZ 00,F
44F2:  BRA    44F0
44F4:  BSF    F94.3
44F6:  MOVLW  0B
44F8:  MOVWF  00
44FA:  DECFSZ 00,F
44FC:  BRA    44FA
44FE:  BTFSS  F82.3
4500:  BRA    44FE
4502:  BCF    F8B.4
4504:  BCF    F94.4
4506:  MOVLW  0A
4508:  MOVWF  00
450A:  DECFSZ 00,F
450C:  BRA    450A
450E:  BCF    F8B.3
4510:  BCF    F94.3
4512:  CLRF   19
4514:  BTFSC  FF2.7
4516:  BSF    19.7
4518:  BCF    FF2.7
....................    i2c_write(0xD1); 
451A:  MOVLW  D1
451C:  MOVLB  8
451E:  MOVWF  x24
4520:  MOVLB  0
4522:  CALL   3200
4526:  BTFSC  19.7
4528:  BSF    FF2.7
....................    result = i2c_read(0); 
452A:  CLRF   00
452C:  CLRF   19
452E:  BTFSC  FF2.7
4530:  BSF    19.7
4532:  BCF    FF2.7
4534:  CALL   3276
4538:  BTFSC  19.7
453A:  BSF    FF2.7
453C:  MOVFF  01,7E0
....................    i2c_stop(); 
4540:  BCF    F94.4
4542:  NOP   
4544:  BSF    F94.3
4546:  BTFSS  F82.3
4548:  BRA    4546
454A:  MOVLW  0A
454C:  MOVWF  00
454E:  DECFSZ 00,F
4550:  BRA    454E
4552:  BRA    4554
4554:  NOP   
4556:  BSF    F94.4
4558:  MOVLW  0A
455A:  MOVWF  00
455C:  DECFSZ 00,F
455E:  BRA    455C
....................     
....................    return(result); 
4560:  MOVLB  7
4562:  MOVFF  7E0,01
.................... } 
4566:  MOVLB  0
4568:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
4F8A:  BSF    F94.4
4F8C:  MOVLW  0A
4F8E:  MOVWF  00
4F90:  DECFSZ 00,F
4F92:  BRA    4F90
4F94:  BSF    F94.3
4F96:  MOVLW  0B
4F98:  MOVWF  00
4F9A:  DECFSZ 00,F
4F9C:  BRA    4F9A
4F9E:  BCF    F8B.4
4FA0:  BCF    F94.4
4FA2:  MOVLW  0A
4FA4:  MOVWF  00
4FA6:  DECFSZ 00,F
4FA8:  BRA    4FA6
4FAA:  BCF    F8B.3
4FAC:  BCF    F94.3
....................    delay_us(10); 
4FAE:  MOVLW  1A
4FB0:  MOVWF  00
4FB2:  DECFSZ 00,F
4FB4:  BRA    4FB2
4FB6:  NOP   
4FB8:  CLRF   19
4FBA:  BTFSC  FF2.7
4FBC:  BSF    19.7
4FBE:  BCF    FF2.7
....................    i2c_write(0xD0); 
4FC0:  MOVLW  D0
4FC2:  MOVLB  8
4FC4:  MOVWF  x24
4FC6:  MOVLB  0
4FC8:  CALL   3200
4FCC:  BTFSC  19.7
4FCE:  BSF    FF2.7
....................    delay_us(10); 
4FD0:  MOVLW  1A
4FD2:  MOVWF  00
4FD4:  DECFSZ 00,F
4FD6:  BRA    4FD4
4FD8:  NOP   
4FDA:  CLRF   19
4FDC:  BTFSC  FF2.7
4FDE:  BSF    19.7
4FE0:  BCF    FF2.7
....................    i2c_write(address); 
4FE2:  MOVFF  7E2,824
4FE6:  CALL   3200
4FEA:  BTFSC  19.7
4FEC:  BSF    FF2.7
....................    delay_us(10); 
4FEE:  MOVLW  1A
4FF0:  MOVWF  00
4FF2:  DECFSZ 00,F
4FF4:  BRA    4FF2
4FF6:  NOP   
4FF8:  CLRF   19
4FFA:  BTFSC  FF2.7
4FFC:  BSF    19.7
4FFE:  BCF    FF2.7
....................    i2c_write(data); 
5000:  MOVFF  7E3,824
5004:  CALL   3200
5008:  BTFSC  19.7
500A:  BSF    FF2.7
....................    i2c_stop(); 
500C:  BCF    F94.4
500E:  NOP   
5010:  BSF    F94.3
5012:  BTFSS  F82.3
5014:  BRA    5012
5016:  MOVLW  0A
5018:  MOVWF  00
501A:  DECFSZ 00,F
501C:  BRA    501A
501E:  BRA    5020
5020:  NOP   
5022:  BSF    F94.4
5024:  MOVLW  0A
5026:  MOVWF  00
5028:  DECFSZ 00,F
502A:  BRA    5028
....................    delay_us(10); 
502C:  MOVLW  1A
502E:  MOVWF  00
5030:  DECFSZ 00,F
5032:  BRA    5030
5034:  NOP   
.................... } 
5036:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
*
456A:  MOVLB  7
456C:  CLRF   xDF
456E:  MOVLB  0
4570:  RCALL  449A
4572:  MOVFF  01,7A5
....................     
....................    data &= 0x7F; 
4576:  MOVLB  7
4578:  BCF    xA5.7
....................     
....................    i2c_start(); 
457A:  BSF    F94.4
457C:  MOVLW  0A
457E:  MOVWF  00
4580:  DECFSZ 00,F
4582:  BRA    4580
4584:  BSF    F94.3
4586:  MOVLW  0B
4588:  MOVWF  00
458A:  DECFSZ 00,F
458C:  BRA    458A
458E:  BCF    F8B.4
4590:  BCF    F94.4
4592:  MOVLW  0A
4594:  MOVWF  00
4596:  DECFSZ 00,F
4598:  BRA    4596
459A:  BCF    F8B.3
459C:  BCF    F94.3
459E:  CLRF   19
45A0:  BTFSC  FF2.7
45A2:  BSF    19.7
45A4:  BCF    FF2.7
....................    i2c_write(0xD0); 
45A6:  MOVLW  D0
45A8:  MOVLB  8
45AA:  MOVWF  x24
45AC:  MOVLB  0
45AE:  CALL   3200
45B2:  BTFSC  19.7
45B4:  BSF    FF2.7
45B6:  CLRF   19
45B8:  BTFSC  FF2.7
45BA:  BSF    19.7
45BC:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
45BE:  MOVLB  8
45C0:  CLRF   x24
45C2:  MOVLB  0
45C4:  CALL   3200
45C8:  BTFSC  19.7
45CA:  BSF    FF2.7
45CC:  CLRF   19
45CE:  BTFSC  FF2.7
45D0:  BSF    19.7
45D2:  BCF    FF2.7
....................    i2c_write(data); 
45D4:  MOVFF  7A5,824
45D8:  CALL   3200
45DC:  BTFSC  19.7
45DE:  BSF    FF2.7
....................    i2c_start(); 
45E0:  BSF    F94.4
45E2:  MOVLW  0A
45E4:  MOVWF  00
45E6:  DECFSZ 00,F
45E8:  BRA    45E6
45EA:  BSF    F94.3
45EC:  MOVLW  0B
45EE:  MOVWF  00
45F0:  DECFSZ 00,F
45F2:  BRA    45F0
45F4:  BTFSS  F82.3
45F6:  BRA    45F4
45F8:  BCF    F8B.4
45FA:  BCF    F94.4
45FC:  MOVLW  0A
45FE:  MOVWF  00
4600:  DECFSZ 00,F
4602:  BRA    4600
4604:  BCF    F8B.3
4606:  BCF    F94.3
4608:  CLRF   19
460A:  BTFSC  FF2.7
460C:  BSF    19.7
460E:  BCF    FF2.7
....................    i2c_write(0xD0); 
4610:  MOVLW  D0
4612:  MOVLB  8
4614:  MOVWF  x24
4616:  MOVLB  0
4618:  CALL   3200
461C:  BTFSC  19.7
461E:  BSF    FF2.7
4620:  CLRF   19
4622:  BTFSC  FF2.7
4624:  BSF    19.7
4626:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
4628:  MOVLW  07
462A:  MOVLB  8
462C:  MOVWF  x24
462E:  MOVLB  0
4630:  CALL   3200
4634:  BTFSC  19.7
4636:  BSF    FF2.7
4638:  CLRF   19
463A:  BTFSC  FF2.7
463C:  BSF    19.7
463E:  BCF    FF2.7
....................    i2c_write(0x80); 
4640:  MOVLW  80
4642:  MOVLB  8
4644:  MOVWF  x24
4646:  MOVLB  0
4648:  CALL   3200
464C:  BTFSC  19.7
464E:  BSF    FF2.7
....................    i2c_stop(); 
4650:  BCF    F94.4
4652:  NOP   
4654:  BSF    F94.3
4656:  BTFSS  F82.3
4658:  BRA    4656
465A:  MOVLW  0A
465C:  MOVWF  00
465E:  DECFSZ 00,F
4660:  BRA    465E
4662:  BRA    4664
4664:  NOP   
4666:  BSF    F94.4
4668:  MOVLW  0A
466A:  MOVWF  00
466C:  DECFSZ 00,F
466E:  BRA    466C
.................... } 
4670:  GOTO   6884 (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
5038:  CLRF   19
503A:  BTFSC  FF2.7
503C:  BSF    19.7
503E:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
5040:  MOVFF  7E1,816
5044:  MOVLW  0A
5046:  MOVLB  8
5048:  MOVWF  x17
504A:  MOVLB  0
504C:  CALL   14D4
5050:  BTFSC  19.7
5052:  BSF    FF2.7
5054:  MOVFF  01,7E2
....................    nibl=data-(nibh*10); 
5058:  MOVLB  7
505A:  MOVF   xE2,W
505C:  MULLW  0A
505E:  MOVF   FF3,W
5060:  SUBWF  xE1,W
5062:  MOVWF  xE3
....................  
....................    return((nibh<<4)|nibl); 
5064:  SWAPF  xE2,W
5066:  MOVWF  00
5068:  MOVLW  F0
506A:  ANDWF  00,F
506C:  MOVF   00,W
506E:  IORWF  xE3,W
5070:  MOVWF  01
.................... } 
5072:  MOVLB  0
5074:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
4E44:  MOVFF  7E0,7E1
....................    data=(i>>4)*10; 
4E48:  MOVLB  7
4E4A:  SWAPF  xE1,W
4E4C:  MOVWF  00
4E4E:  MOVLW  0F
4E50:  ANDWF  00,F
4E52:  MOVF   00,W
4E54:  MULLW  0A
4E56:  MOVFF  FF3,7E0
....................    data=data+(i<<4>>4); 
4E5A:  SWAPF  xE1,W
4E5C:  MOVWF  00
4E5E:  MOVLW  F0
4E60:  ANDWF  00,F
4E62:  MOVF   00,W
4E64:  SWAPF  00,F
4E66:  MOVLW  0F
4E68:  ANDWF  00,F
4E6A:  MOVF   00,W
4E6C:  ADDWF  xE0,F
....................  
....................    return data; 
4E6E:  MOVFF  7E0,01
.................... } 
4E72:  MOVLB  0
4E74:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
5076:  MOVLB  7
5078:  CLRF   xE2
507A:  CLRF   xE3
507C:  MOVLB  0
507E:  RCALL  4F8A
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
5080:  MOVFF  7E0,7E1
5084:  RCALL  5038
5086:  MOVFF  01,7E1
508A:  MOVLW  01
508C:  MOVLB  7
508E:  MOVWF  xE2
5090:  MOVFF  01,7E3
5094:  MOVLB  0
5096:  RCALL  4F8A
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
5098:  MOVFF  7DF,7E1
509C:  RCALL  5038
509E:  MOVFF  01,7E1
50A2:  MOVLW  02
50A4:  MOVLB  7
50A6:  MOVWF  xE2
50A8:  MOVFF  01,7E3
50AC:  MOVLB  0
50AE:  RCALL  4F8A
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
50B0:  MOVFF  7DE,7E1
50B4:  RCALL  5038
50B6:  MOVFF  01,7E1
50BA:  MOVLW  03
50BC:  MOVLB  7
50BE:  MOVWF  xE2
50C0:  MOVFF  01,7E3
50C4:  MOVLB  0
50C6:  RCALL  4F8A
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
50C8:  MOVFF  7DB,7E1
50CC:  RCALL  5038
50CE:  MOVFF  01,7E1
50D2:  MOVLW  04
50D4:  MOVLB  7
50D6:  MOVWF  xE2
50D8:  MOVFF  01,7E3
50DC:  MOVLB  0
50DE:  RCALL  4F8A
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
50E0:  MOVFF  7DC,7E1
50E4:  RCALL  5038
50E6:  MOVFF  01,7E1
50EA:  MOVLW  05
50EC:  MOVLB  7
50EE:  MOVWF  xE2
50F0:  MOVFF  01,7E3
50F4:  MOVLB  0
50F6:  RCALL  4F8A
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
50F8:  MOVFF  7DD,7E1
50FC:  RCALL  5038
50FE:  MOVFF  01,7E1
5102:  MOVLW  06
5104:  MOVLB  7
5106:  MOVWF  xE2
5108:  MOVFF  01,7E3
510C:  MOVLB  0
510E:  RCALL  4F8A
....................    write_DS1307(DS1307_CONTROL,0);    
5110:  MOVLW  07
5112:  MOVLB  7
5114:  MOVWF  xE2
5116:  CLRF   xE3
5118:  MOVLB  0
511A:  RCALL  4F8A
.................... } 
511C:  GOTO   5D64 (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
58A4:  MOVLW  04
58A6:  MOVLB  7
58A8:  MOVWF  xDF
58AA:  MOVLB  0
58AC:  CALL   449A
58B0:  MOVFF  01,7DB
58B4:  MOVFF  01,7E0
58B8:  CALL   4E44
58BC:  MOVFF  01,121
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
58C0:  MOVLW  05
58C2:  MOVLB  7
58C4:  MOVWF  xDF
58C6:  MOVLB  0
58C8:  CALL   449A
58CC:  MOVFF  01,7DB
58D0:  MOVFF  01,7E0
58D4:  CALL   4E44
58D8:  MOVFF  01,120
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
58DC:  MOVLW  06
58DE:  MOVLB  7
58E0:  MOVWF  xDF
58E2:  MOVLB  0
58E4:  CALL   449A
58E8:  MOVFF  01,7DB
58EC:  MOVFF  01,7E0
58F0:  CALL   4E44
58F4:  MOVFF  01,11F
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
58F8:  MOVLW  03
58FA:  MOVLB  7
58FC:  MOVWF  xDF
58FE:  MOVLB  0
5900:  CALL   449A
5904:  MOVFF  01,7DB
5908:  MOVFF  01,7E0
590C:  CALL   4E44
5910:  MOVFF  01,11E
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
5914:  MOVLW  02
5916:  MOVLB  7
5918:  MOVWF  xDF
591A:  MOVLB  0
591C:  CALL   449A
5920:  MOVFF  01,7DB
5924:  MOVFF  01,7E0
5928:  CALL   4E44
592C:  MOVFF  01,122
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
5930:  MOVLW  01
5932:  MOVLB  7
5934:  MOVWF  xDF
5936:  MOVLB  0
5938:  CALL   449A
593C:  MOVFF  01,7DB
5940:  MOVFF  01,7E0
5944:  CALL   4E44
5948:  MOVFF  01,123
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
594C:  MOVLB  7
594E:  CLRF   xDF
5950:  MOVLB  0
5952:  CALL   449A
5956:  MOVFF  01,7DB
595A:  MOVFF  01,7E0
595E:  CALL   4E44
5962:  MOVFF  01,124
5966:  CLRF   19
5968:  BTFSC  FF2.7
596A:  BSF    19.7
596C:  BCF    FF2.7
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0,booting=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... int16 count_checking=10; 
.................... #include <scan_key.c> 
....................  
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... int8 type_KB=0; 
.................... #define key_numbyte  16 
....................  
.................... int8 key_data[key_numbyte]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1E18:  MOVLB  1
1E1A:  INCF   x46,F
1E1C:  MOVF   x46,W
1E1E:  SUBLW  01
1E20:  BTFSC  FD8.0
1E22:  BRA    1FC4
....................        switch (col) { 
1E24:  MOVF   x49,W
1E26:  ADDLW  FB
1E28:  BC    1EAC
1E2A:  ADDLW  05
1E2C:  MOVLB  0
1E2E:  GOTO   1FCE
....................          case 0   :  
....................                     output_low(COL0); 
1E32:  BCF    F92.5
1E34:  BCF    F89.5
....................                     output_high(COL1); 
1E36:  BCF    F92.3
1E38:  BSF    F89.3
....................                     output_high(COL2); 
1E3A:  BCF    F92.2
1E3C:  BSF    F89.2
....................                     output_high(COL3); 
1E3E:  BCF    F92.1
1E40:  BSF    F89.1
....................                     output_high(COL4); 
1E42:  BCF    F92.0
1E44:  BSF    F89.0
....................                     break; 
1E46:  MOVLB  1
1E48:  BRA    1EAC
....................          case 1   :  
....................                     output_low(COL1); 
1E4A:  BCF    F92.3
1E4C:  BCF    F89.3
....................                     output_high(COL0); 
1E4E:  BCF    F92.5
1E50:  BSF    F89.5
....................                     output_high(COL2); 
1E52:  BCF    F92.2
1E54:  BSF    F89.2
....................                     output_high(COL3); 
1E56:  BCF    F92.1
1E58:  BSF    F89.1
....................                     output_high(COL4); 
1E5A:  BCF    F92.0
1E5C:  BSF    F89.0
....................                     break; 
1E5E:  MOVLB  1
1E60:  BRA    1EAC
....................          case 2   :  
....................                     output_low(COL2); 
1E62:  BCF    F92.2
1E64:  BCF    F89.2
....................                     output_high(COL1); 
1E66:  BCF    F92.3
1E68:  BSF    F89.3
....................                     output_high(COL0); 
1E6A:  BCF    F92.5
1E6C:  BSF    F89.5
....................                     output_high(COL3); 
1E6E:  BCF    F92.1
1E70:  BSF    F89.1
....................                     output_high(COL4); 
1E72:  BCF    F92.0
1E74:  BSF    F89.0
....................                     break; 
1E76:  MOVLB  1
1E78:  BRA    1EAC
....................          case 3   :  
....................                     output_low(COL3); 
1E7A:  BCF    F92.1
1E7C:  BCF    F89.1
....................                     output_high(COL1); 
1E7E:  BCF    F92.3
1E80:  BSF    F89.3
....................                     output_high(COL2); 
1E82:  BCF    F92.2
1E84:  BSF    F89.2
....................                     output_high(COL0); 
1E86:  BCF    F92.5
1E88:  BSF    F89.5
....................                     output_high(COL4); 
1E8A:  BCF    F92.0
1E8C:  BSF    F89.0
....................                     break; 
1E8E:  MOVLB  1
1E90:  BRA    1EAC
....................          case 4   :  
....................                     output_low(COL4); 
1E92:  BCF    F92.0
1E94:  BCF    F89.0
....................                     output_high(COL1); 
1E96:  BCF    F92.3
1E98:  BSF    F89.3
....................                     output_high(COL2); 
1E9A:  BCF    F92.2
1E9C:  BSF    F89.2
....................                     output_high(COL3); 
1E9E:  BCF    F92.1
1EA0:  BSF    F89.1
....................                     output_high(COL0); 
1EA2:  BCF    F92.5
1EA4:  BSF    F89.5
....................                     break; 
1EA6:  MOVLB  1
1EA8:  BRA    1EAC
1EAA:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
1EAC:  BTFSS  x47.0
1EAE:  BRA    1F2A
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
1EB0:  BSF    F93.4
1EB2:  MOVLW  00
1EB4:  BTFSC  F81.4
1EB6:  MOVLW  01
1EB8:  MOVLB  8
1EBA:  MOVWF  x09
1EBC:  BSF    F93.5
1EBE:  MOVLW  00
1EC0:  BTFSC  F81.5
1EC2:  MOVLW  01
1EC4:  ANDWF  x09,F
1EC6:  BSF    F93.6
1EC8:  MOVLW  00
1ECA:  BTFSC  F81.6
1ECC:  MOVLW  01
1ECE:  ANDWF  x09,F
1ED0:  BSF    F93.7
1ED2:  MOVLW  00
1ED4:  BTFSC  F81.7
1ED6:  MOVLW  01
1ED8:  ANDWF  x09,W
1EDA:  BZ    1F26
....................          { 
....................             kchar=last_key; 
1EDC:  MOVFF  148,807
....................             if(keydebug_en==0) 
1EE0:  MOVLB  1
1EE2:  MOVF   x2C,F
1EE4:  BNZ   1F14
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
1EE6:  CLRF   x2A
1EE8:  CLRF   x29
....................               charac_timeout=0; 
1EEA:  CLRF   x1D
1EEC:  CLRF   x1C
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
1EEE:  MOVF   x2F,W
1EF0:  SUBLW  0F
1EF2:  BNC   1F08
1EF4:  MOVF   x2F,W
1EF6:  INCF   x2F,F
1EF8:  CLRF   03
1EFA:  ADDLW  35
1EFC:  MOVWF  FE9
1EFE:  MOVLW  01
1F00:  ADDWFC 03,W
1F02:  MOVWF  FEA
1F04:  MOVFF  807,FEF
....................                fputc(kchar,COM2); 
1F08:  MOVFF  807,830
1F0C:  MOVLB  0
1F0E:  CALL   0422
....................             } 
....................                else fputc(kchar,COM2); 
1F12:  BRA    1F1E
1F14:  MOVFF  807,830
1F18:  MOVLB  0
1F1A:  CALL   0422
....................            kbd_down=FALSE; 
1F1E:  MOVLB  1
1F20:  BCF    x47.0
....................            last_key=0; 
1F22:  CLRF   x48
1F24:  MOVLB  8
....................          } 
....................        } else 
1F26:  BRA    1FC0
1F28:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
1F2A:  BSF    F93.4
1F2C:  MOVLW  00
1F2E:  BTFSC  F81.4
1F30:  MOVLW  01
1F32:  MOVLB  8
1F34:  MOVWF  x09
1F36:  BSF    F93.5
1F38:  MOVLW  00
1F3A:  BTFSC  F81.5
1F3C:  MOVLW  01
1F3E:  ANDWF  x09,F
1F40:  BSF    F93.6
1F42:  MOVLW  00
1F44:  BTFSC  F81.6
1F46:  MOVLW  01
1F48:  ANDWF  x09,F
1F4A:  BSF    F93.7
1F4C:  MOVLW  00
1F4E:  BTFSC  F81.7
1F50:  MOVLW  01
1F52:  ANDWF  x09,W
1F54:  BNZ   1FB4
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
1F56:  BSF    F93.4
1F58:  BTFSC  F81.4
1F5A:  BRA    1F60
....................                   row=0; 
1F5C:  CLRF   x08
....................                 else if(input(ROW1)==0) 
1F5E:  BRA    1F82
1F60:  BSF    F93.5
1F62:  BTFSC  F81.5
1F64:  BRA    1F6C
....................                   row=1; 
1F66:  MOVLW  01
1F68:  MOVWF  x08
....................                 else if(input(ROW2)==0) 
1F6A:  BRA    1F82
1F6C:  BSF    F93.6
1F6E:  BTFSC  F81.6
1F70:  BRA    1F78
....................                   row=2; 
1F72:  MOVLW  02
1F74:  MOVWF  x08
....................                 else if(input(ROW3)==0) 
1F76:  BRA    1F82
1F78:  BSF    F93.7
1F7A:  BTFSC  F81.7
1F7C:  BRA    1F82
....................                   row=3; 
1F7E:  MOVLW  03
1F80:  MOVWF  x08
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
1F82:  MOVF   x08,W
1F84:  MULLW  05
1F86:  MOVF   FF3,W
1F88:  CLRF   x0A
1F8A:  MOVWF  x09
1F8C:  CLRF   03
1F8E:  MOVLB  1
1F90:  MOVF   x49,W
1F92:  MOVLB  8
1F94:  ADDWF  x09,W
1F96:  MOVWF  01
1F98:  MOVF   x0A,W
1F9A:  ADDWFC 03,F
1F9C:  MOVF   01,W
1F9E:  MOVLB  0
1FA0:  CALL   00D0
1FA4:  MOVFF  FE8,148
....................                 kbd_down = TRUE; 
1FA8:  MOVLB  1
1FAA:  BSF    x47.0
....................                 set_tris_a(0xff); 
1FAC:  MOVLW  FF
1FAE:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
1FB0:  BRA    1FC0
1FB2:  MOVLB  8
....................                { 
....................                   ++col; 
1FB4:  MOVLB  1
1FB6:  INCF   x49,F
....................                   if(col==5) col=0; 
1FB8:  MOVF   x49,W
1FBA:  SUBLW  05
1FBC:  BTFSC  FD8.2
1FBE:  CLRF   x49
....................                } 
....................          } 
....................       kbd_call_count=0; 
1FC0:  MOVLB  1
1FC2:  CLRF   x46
....................    } 
....................   return(kchar); 
1FC4:  MOVLB  8
1FC6:  MOVFF  807,01
.................... } 
1FCA:  MOVLB  0
1FCC:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
1FF2:  MOVLW  E0
1FF4:  MOVLB  F
1FF6:  MOVWF  x48
1FF8:  BCF    FC2.6
1FFA:  BCF    FC2.7
1FFC:  MOVF   x49,W
1FFE:  ANDLW  E0
2000:  IORLW  17
2002:  MOVWF  x49
....................    switch(col) 
....................    { 
2004:  MOVLB  8
2006:  MOVF   x24,W
2008:  ADDLW  FA
200A:  BC    20D6
200C:  ADDLW  06
200E:  MOVLB  0
2010:  GOTO   20DA
....................       case 0: 
....................         set_adc_channel(4); 
2014:  MOVLW  10
2016:  MOVWF  01
2018:  MOVF   FC2,W
201A:  ANDLW  C3
201C:  IORWF  01,W
201E:  MOVWF  FC2
....................         adc=read_adc(); 
2020:  BSF    FC2.1
2022:  BTFSC  FC2.1
2024:  BRA    2022
2026:  MOVFF  FC4,825
....................         return adc; 
202A:  MOVLB  8
202C:  MOVFF  825,01
2030:  BRA    20D6
....................       break; 
2032:  BRA    20D6
....................       case 1: 
....................         set_adc_channel(3); 
2034:  MOVLW  0C
2036:  MOVWF  01
2038:  MOVF   FC2,W
203A:  ANDLW  C3
203C:  IORWF  01,W
203E:  MOVWF  FC2
....................         adc=read_adc(); 
2040:  BSF    FC2.1
2042:  BTFSC  FC2.1
2044:  BRA    2042
2046:  MOVFF  FC4,825
....................         return adc; 
204A:  MOVLB  8
204C:  MOVFF  825,01
2050:  BRA    20D6
....................       break; 
2052:  BRA    20D6
....................       case 2: 
....................         set_adc_channel(2); 
2054:  MOVLW  08
2056:  MOVWF  01
2058:  MOVF   FC2,W
205A:  ANDLW  C3
205C:  IORWF  01,W
205E:  MOVWF  FC2
....................         adc=read_adc(); 
2060:  BSF    FC2.1
2062:  BTFSC  FC2.1
2064:  BRA    2062
2066:  MOVFF  FC4,825
....................         return adc; 
206A:  MOVLB  8
206C:  MOVFF  825,01
2070:  BRA    20D6
....................       break; 
2072:  BRA    20D6
....................       case 3: 
....................         set_adc_channel(1); 
2074:  MOVLW  04
2076:  MOVWF  01
2078:  MOVF   FC2,W
207A:  ANDLW  C3
207C:  IORWF  01,W
207E:  MOVWF  FC2
....................         adc=read_adc(); 
2080:  BSF    FC2.1
2082:  BTFSC  FC2.1
2084:  BRA    2082
2086:  MOVFF  FC4,825
....................         return adc; 
208A:  MOVLB  8
208C:  MOVFF  825,01
2090:  BRA    20D6
....................       break; 
2092:  BRA    20D6
....................       case 4: 
....................         set_adc_channel(0); 
2094:  MOVLW  00
2096:  MOVWF  01
2098:  MOVF   FC2,W
209A:  ANDLW  C3
209C:  IORWF  01,W
209E:  MOVWF  FC2
....................         adc=read_adc(); 
20A0:  BSF    FC2.1
20A2:  BTFSC  FC2.1
20A4:  BRA    20A2
20A6:  MOVFF  FC4,825
....................         return adc; 
20AA:  MOVLB  8
20AC:  MOVFF  825,01
20B0:  BRA    20D6
....................       break;      
20B2:  BRA    20D6
....................       case 5: 
....................         set_adc_channel(11); 
20B4:  MOVLW  2C
20B6:  MOVWF  01
20B8:  MOVF   FC2,W
20BA:  ANDLW  C3
20BC:  IORWF  01,W
20BE:  MOVWF  FC2
....................         adc=read_adc(); 
20C0:  BSF    FC2.1
20C2:  BTFSC  FC2.1
20C4:  BRA    20C2
20C6:  MOVFF  FC4,825
....................         return adc; 
20CA:  MOVLB  8
20CC:  MOVFF  825,01
20D0:  BRA    20D6
....................       break;      
20D2:  BRA    20D6
20D4:  MOVLB  8
....................    } 
.................... } 
20D6:  MOVLB  0
20D8:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
2254:  MOVLB  8
2256:  CLRF   x0F
2258:  CLRF   x0E
225A:  CLRF   x0D
225C:  CLRF   x0C
225E:  CLRF   x13
2260:  CLRF   x12
2262:  CLRF   x11
2264:  CLRF   x10
2266:  CLRF   x17
2268:  CLRF   x16
226A:  CLRF   x15
226C:  CLRF   x14
226E:  CLRF   x1B
2270:  CLRF   x1A
2272:  CLRF   x19
2274:  CLRF   x18
2276:  CLRF   x1F
2278:  CLRF   x1E
227A:  CLRF   x1D
227C:  CLRF   x1C
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
227E:  CLRF   x0B
2280:  CLRF   x0A
2282:  MOVF   x0B,W
2284:  SUBLW  01
2286:  BNC   2304
2288:  BNZ   2290
228A:  MOVF   x0A,W
228C:  SUBLW  F3
228E:  BNC   2304
....................    { 
....................       col_0=read_col(0)+col_0; 
2290:  CLRF   x24
2292:  MOVLB  0
2294:  RCALL  1FF2
2296:  MOVF   01,W
2298:  MOVLB  8
229A:  ADDWF  x0C,F
229C:  MOVLW  00
229E:  ADDWFC x0D,F
22A0:  ADDWFC x0E,F
22A2:  ADDWFC x0F,F
....................       col_1=read_col(1)+col_1; 
22A4:  MOVLW  01
22A6:  MOVWF  x24
22A8:  MOVLB  0
22AA:  RCALL  1FF2
22AC:  MOVF   01,W
22AE:  MOVLB  8
22B0:  ADDWF  x10,F
22B2:  MOVLW  00
22B4:  ADDWFC x11,F
22B6:  ADDWFC x12,F
22B8:  ADDWFC x13,F
....................       col_2=read_col(2)+col_2; 
22BA:  MOVLW  02
22BC:  MOVWF  x24
22BE:  MOVLB  0
22C0:  RCALL  1FF2
22C2:  MOVF   01,W
22C4:  MOVLB  8
22C6:  ADDWF  x14,F
22C8:  MOVLW  00
22CA:  ADDWFC x15,F
22CC:  ADDWFC x16,F
22CE:  ADDWFC x17,F
....................       col_3=read_col(3)+col_3; 
22D0:  MOVLW  03
22D2:  MOVWF  x24
22D4:  MOVLB  0
22D6:  RCALL  1FF2
22D8:  MOVF   01,W
22DA:  MOVLB  8
22DC:  ADDWF  x18,F
22DE:  MOVLW  00
22E0:  ADDWFC x19,F
22E2:  ADDWFC x1A,F
22E4:  ADDWFC x1B,F
....................       col_4=read_col(4)+col_4; 
22E6:  MOVLW  04
22E8:  MOVWF  x24
22EA:  MOVLB  0
22EC:  RCALL  1FF2
22EE:  MOVF   01,W
22F0:  MOVLB  8
22F2:  ADDWF  x1C,F
22F4:  MOVLW  00
22F6:  ADDWFC x1D,F
22F8:  ADDWFC x1E,F
22FA:  ADDWFC x1F,F
....................    } 
22FC:  INCF   x0A,F
22FE:  BTFSC  FD8.2
2300:  INCF   x0B,F
2302:  BRA    2282
....................    col_0=col_0/500; 
2304:  BCF    FD8.1
2306:  MOVFF  80F,833
230A:  MOVFF  80E,832
230E:  MOVFF  80D,831
2312:  MOVFF  80C,830
2316:  CLRF   x37
2318:  CLRF   x36
231A:  MOVLW  01
231C:  MOVWF  x35
231E:  MOVLW  F4
2320:  MOVWF  x34
2322:  MOVLB  0
2324:  RCALL  2100
2326:  MOVFF  03,80F
232A:  MOVFF  02,80E
232E:  MOVFF  01,80D
2332:  MOVFF  00,80C
....................    col_1=col_1/500; 
2336:  BCF    FD8.1
2338:  MOVFF  813,833
233C:  MOVFF  812,832
2340:  MOVFF  811,831
2344:  MOVFF  810,830
2348:  MOVLB  8
234A:  CLRF   x37
234C:  CLRF   x36
234E:  MOVLW  01
2350:  MOVWF  x35
2352:  MOVLW  F4
2354:  MOVWF  x34
2356:  MOVLB  0
2358:  RCALL  2100
235A:  MOVFF  03,813
235E:  MOVFF  02,812
2362:  MOVFF  01,811
2366:  MOVFF  00,810
....................    col_2=col_2/500; 
236A:  BCF    FD8.1
236C:  MOVFF  817,833
2370:  MOVFF  816,832
2374:  MOVFF  815,831
2378:  MOVFF  814,830
237C:  MOVLB  8
237E:  CLRF   x37
2380:  CLRF   x36
2382:  MOVLW  01
2384:  MOVWF  x35
2386:  MOVLW  F4
2388:  MOVWF  x34
238A:  MOVLB  0
238C:  RCALL  2100
238E:  MOVFF  03,817
2392:  MOVFF  02,816
2396:  MOVFF  01,815
239A:  MOVFF  00,814
....................    col_3=col_3/500; 
239E:  BCF    FD8.1
23A0:  MOVFF  81B,833
23A4:  MOVFF  81A,832
23A8:  MOVFF  819,831
23AC:  MOVFF  818,830
23B0:  MOVLB  8
23B2:  CLRF   x37
23B4:  CLRF   x36
23B6:  MOVLW  01
23B8:  MOVWF  x35
23BA:  MOVLW  F4
23BC:  MOVWF  x34
23BE:  MOVLB  0
23C0:  RCALL  2100
23C2:  MOVFF  03,81B
23C6:  MOVFF  02,81A
23CA:  MOVFF  01,819
23CE:  MOVFF  00,818
....................    col_4=col_4/500; 
23D2:  BCF    FD8.1
23D4:  MOVFF  81F,833
23D8:  MOVFF  81E,832
23DC:  MOVFF  81D,831
23E0:  MOVFF  81C,830
23E4:  MOVLB  8
23E6:  CLRF   x37
23E8:  CLRF   x36
23EA:  MOVLW  01
23EC:  MOVWF  x35
23EE:  MOVLW  F4
23F0:  MOVWF  x34
23F2:  MOVLB  0
23F4:  RCALL  2100
23F6:  MOVFF  03,81F
23FA:  MOVFF  02,81E
23FE:  MOVFF  01,81D
2402:  MOVFF  00,81C
....................    if(keydebug_en) 
2406:  MOVLB  1
2408:  MOVF   x2C,F
240A:  BTFSC  FD8.2
240C:  BRA    2588
....................    { 
....................       fprintf(COM2,"\r\n");      
240E:  MOVLW  0D
2410:  MOVLB  8
2412:  MOVWF  x30
2414:  MOVLB  0
2416:  CALL   0422
241A:  MOVLW  0A
241C:  MOVLB  8
241E:  MOVWF  x30
2420:  MOVLB  0
2422:  CALL   0422
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2426:  MOVLW  7E
2428:  MOVWF  FF6
242A:  MOVLW  02
242C:  MOVWF  FF7
242E:  MOVLW  07
2430:  MOVLB  8
2432:  MOVWF  x24
2434:  MOVLB  0
2436:  CALL   13EC
243A:  MOVLW  41
243C:  MOVWF  FE9
243E:  MOVFF  80F,827
2442:  MOVFF  80E,826
2446:  MOVFF  80D,825
244A:  MOVFF  80C,824
244E:  RCALL  2194
2450:  MOVLW  0D
2452:  MOVLB  8
2454:  MOVWF  x30
2456:  MOVLB  0
2458:  CALL   0422
245C:  MOVLW  0A
245E:  MOVLB  8
2460:  MOVWF  x30
2462:  MOVLB  0
2464:  CALL   0422
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2468:  MOVLW  8C
246A:  MOVWF  FF6
246C:  MOVLW  02
246E:  MOVWF  FF7
2470:  MOVLW  07
2472:  MOVLB  8
2474:  MOVWF  x24
2476:  MOVLB  0
2478:  CALL   13EC
247C:  MOVLW  41
247E:  MOVWF  FE9
2480:  MOVFF  813,827
2484:  MOVFF  812,826
2488:  MOVFF  811,825
248C:  MOVFF  810,824
2490:  RCALL  2194
2492:  MOVLW  0D
2494:  MOVLB  8
2496:  MOVWF  x30
2498:  MOVLB  0
249A:  CALL   0422
249E:  MOVLW  0A
24A0:  MOVLB  8
24A2:  MOVWF  x30
24A4:  MOVLB  0
24A6:  CALL   0422
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
24AA:  MOVLW  9A
24AC:  MOVWF  FF6
24AE:  MOVLW  02
24B0:  MOVWF  FF7
24B2:  MOVLW  07
24B4:  MOVLB  8
24B6:  MOVWF  x24
24B8:  MOVLB  0
24BA:  CALL   13EC
24BE:  MOVLW  41
24C0:  MOVWF  FE9
24C2:  MOVFF  817,827
24C6:  MOVFF  816,826
24CA:  MOVFF  815,825
24CE:  MOVFF  814,824
24D2:  RCALL  2194
24D4:  MOVLW  0D
24D6:  MOVLB  8
24D8:  MOVWF  x30
24DA:  MOVLB  0
24DC:  CALL   0422
24E0:  MOVLW  0A
24E2:  MOVLB  8
24E4:  MOVWF  x30
24E6:  MOVLB  0
24E8:  CALL   0422
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
24EC:  MOVLW  A8
24EE:  MOVWF  FF6
24F0:  MOVLW  02
24F2:  MOVWF  FF7
24F4:  MOVLW  07
24F6:  MOVLB  8
24F8:  MOVWF  x24
24FA:  MOVLB  0
24FC:  CALL   13EC
2500:  MOVLW  41
2502:  MOVWF  FE9
2504:  MOVFF  81B,827
2508:  MOVFF  81A,826
250C:  MOVFF  819,825
2510:  MOVFF  818,824
2514:  RCALL  2194
2516:  MOVLW  0D
2518:  MOVLB  8
251A:  MOVWF  x30
251C:  MOVLB  0
251E:  CALL   0422
2522:  MOVLW  0A
2524:  MOVLB  8
2526:  MOVWF  x30
2528:  MOVLB  0
252A:  CALL   0422
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
252E:  MOVLW  B6
2530:  MOVWF  FF6
2532:  MOVLW  02
2534:  MOVWF  FF7
2536:  MOVLW  07
2538:  MOVLB  8
253A:  MOVWF  x24
253C:  MOVLB  0
253E:  CALL   13EC
2542:  MOVLW  41
2544:  MOVWF  FE9
2546:  MOVFF  81F,827
254A:  MOVFF  81E,826
254E:  MOVFF  81D,825
2552:  MOVFF  81C,824
2556:  RCALL  2194
2558:  MOVLW  0D
255A:  MOVLB  8
255C:  MOVWF  x30
255E:  MOVLB  0
2560:  CALL   0422
2564:  MOVLW  0A
2566:  MOVLB  8
2568:  MOVWF  x30
256A:  MOVLB  0
256C:  CALL   0422
....................       fprintf(COM2,"\r\n"); 
2570:  MOVLW  0D
2572:  MOVLB  8
2574:  MOVWF  x30
2576:  MOVLB  0
2578:  CALL   0422
257C:  MOVLW  0A
257E:  MOVLB  8
2580:  MOVWF  x30
2582:  MOVLB  0
2584:  CALL   0422
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
2588:  MOVLB  8
258A:  MOVF   x0F,F
258C:  BNZ   259C
258E:  MOVF   x0E,F
2590:  BNZ   259C
2592:  MOVF   x0D,F
2594:  BNZ   259C
2596:  MOVF   x0C,W
2598:  SUBLW  05
259A:  BC    25FC
259C:  MOVF   x0F,F
259E:  BNZ   25FC
25A0:  MOVF   x0E,F
25A2:  BNZ   25FC
25A4:  MOVF   x0D,F
25A6:  BNZ   25FC
25A8:  MOVF   x0C,W
25AA:  SUBLW  3B
25AC:  BNC   25FC
25AE:  MOVF   x13,F
25B0:  BNZ   25C0
25B2:  MOVF   x12,F
25B4:  BNZ   25C0
25B6:  MOVF   x11,F
25B8:  BNZ   25C0
25BA:  MOVF   x10,W
25BC:  SUBLW  64
25BE:  BC    25FC
25C0:  MOVF   x17,F
25C2:  BNZ   25D2
25C4:  MOVF   x16,F
25C6:  BNZ   25D2
25C8:  MOVF   x15,F
25CA:  BNZ   25D2
25CC:  MOVF   x14,W
25CE:  SUBLW  64
25D0:  BC    25FC
25D2:  MOVF   x1B,F
25D4:  BNZ   25E4
25D6:  MOVF   x1A,F
25D8:  BNZ   25E4
25DA:  MOVF   x19,F
25DC:  BNZ   25E4
25DE:  MOVF   x18,W
25E0:  SUBLW  64
25E2:  BC    25FC
25E4:  MOVF   x1F,F
25E6:  BNZ   25F6
25E8:  MOVF   x1E,F
25EA:  BNZ   25F6
25EC:  MOVF   x1D,F
25EE:  BNZ   25F6
25F0:  MOVF   x1C,W
25F2:  SUBLW  64
25F4:  BC    25FC
25F6:  MOVLW  00
25F8:  MOVWF  01
25FA:  BRA    287A
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
25FC:  MOVF   x13,F
25FE:  BNZ   260E
2600:  MOVF   x12,F
2602:  BNZ   260E
2604:  MOVF   x11,F
2606:  BNZ   260E
2608:  MOVF   x10,W
260A:  SUBLW  05
260C:  BC    266E
260E:  MOVF   x13,F
2610:  BNZ   266E
2612:  MOVF   x12,F
2614:  BNZ   266E
2616:  MOVF   x11,F
2618:  BNZ   266E
261A:  MOVF   x10,W
261C:  SUBLW  3B
261E:  BNC   266E
2620:  MOVF   x0F,F
2622:  BNZ   2632
2624:  MOVF   x0E,F
2626:  BNZ   2632
2628:  MOVF   x0D,F
262A:  BNZ   2632
262C:  MOVF   x0C,W
262E:  SUBLW  64
2630:  BC    266E
2632:  MOVF   x17,F
2634:  BNZ   2644
2636:  MOVF   x16,F
2638:  BNZ   2644
263A:  MOVF   x15,F
263C:  BNZ   2644
263E:  MOVF   x14,W
2640:  SUBLW  64
2642:  BC    266E
2644:  MOVF   x1B,F
2646:  BNZ   2656
2648:  MOVF   x1A,F
264A:  BNZ   2656
264C:  MOVF   x19,F
264E:  BNZ   2656
2650:  MOVF   x18,W
2652:  SUBLW  64
2654:  BC    266E
2656:  MOVF   x1F,F
2658:  BNZ   2668
265A:  MOVF   x1E,F
265C:  BNZ   2668
265E:  MOVF   x1D,F
2660:  BNZ   2668
2662:  MOVF   x1C,W
2664:  SUBLW  64
2666:  BC    266E
2668:  MOVLW  01
266A:  MOVWF  01
266C:  BRA    287A
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
266E:  MOVF   x17,F
2670:  BNZ   2680
2672:  MOVF   x16,F
2674:  BNZ   2680
2676:  MOVF   x15,F
2678:  BNZ   2680
267A:  MOVF   x14,W
267C:  SUBLW  05
267E:  BC    26E0
2680:  MOVF   x17,F
2682:  BNZ   26E0
2684:  MOVF   x16,F
2686:  BNZ   26E0
2688:  MOVF   x15,F
268A:  BNZ   26E0
268C:  MOVF   x14,W
268E:  SUBLW  3B
2690:  BNC   26E0
2692:  MOVF   x13,F
2694:  BNZ   26A4
2696:  MOVF   x12,F
2698:  BNZ   26A4
269A:  MOVF   x11,F
269C:  BNZ   26A4
269E:  MOVF   x10,W
26A0:  SUBLW  64
26A2:  BC    26E0
26A4:  MOVF   x0F,F
26A6:  BNZ   26B6
26A8:  MOVF   x0E,F
26AA:  BNZ   26B6
26AC:  MOVF   x0D,F
26AE:  BNZ   26B6
26B0:  MOVF   x0C,W
26B2:  SUBLW  64
26B4:  BC    26E0
26B6:  MOVF   x1B,F
26B8:  BNZ   26C8
26BA:  MOVF   x1A,F
26BC:  BNZ   26C8
26BE:  MOVF   x19,F
26C0:  BNZ   26C8
26C2:  MOVF   x18,W
26C4:  SUBLW  64
26C6:  BC    26E0
26C8:  MOVF   x1F,F
26CA:  BNZ   26DA
26CC:  MOVF   x1E,F
26CE:  BNZ   26DA
26D0:  MOVF   x1D,F
26D2:  BNZ   26DA
26D4:  MOVF   x1C,W
26D6:  SUBLW  64
26D8:  BC    26E0
26DA:  MOVLW  02
26DC:  MOVWF  01
26DE:  BRA    287A
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
26E0:  MOVF   x1B,F
26E2:  BNZ   26F2
26E4:  MOVF   x1A,F
26E6:  BNZ   26F2
26E8:  MOVF   x19,F
26EA:  BNZ   26F2
26EC:  MOVF   x18,W
26EE:  SUBLW  05
26F0:  BC    2752
26F2:  MOVF   x1B,F
26F4:  BNZ   2752
26F6:  MOVF   x1A,F
26F8:  BNZ   2752
26FA:  MOVF   x19,F
26FC:  BNZ   2752
26FE:  MOVF   x18,W
2700:  SUBLW  3B
2702:  BNC   2752
2704:  MOVF   x13,F
2706:  BNZ   2716
2708:  MOVF   x12,F
270A:  BNZ   2716
270C:  MOVF   x11,F
270E:  BNZ   2716
2710:  MOVF   x10,W
2712:  SUBLW  64
2714:  BC    2752
2716:  MOVF   x17,F
2718:  BNZ   2728
271A:  MOVF   x16,F
271C:  BNZ   2728
271E:  MOVF   x15,F
2720:  BNZ   2728
2722:  MOVF   x14,W
2724:  SUBLW  64
2726:  BC    2752
2728:  MOVF   x0F,F
272A:  BNZ   273A
272C:  MOVF   x0E,F
272E:  BNZ   273A
2730:  MOVF   x0D,F
2732:  BNZ   273A
2734:  MOVF   x0C,W
2736:  SUBLW  64
2738:  BC    2752
273A:  MOVF   x1F,F
273C:  BNZ   274C
273E:  MOVF   x1E,F
2740:  BNZ   274C
2742:  MOVF   x1D,F
2744:  BNZ   274C
2746:  MOVF   x1C,W
2748:  SUBLW  64
274A:  BC    2752
274C:  MOVLW  03
274E:  MOVWF  01
2750:  BRA    287A
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2752:  MOVF   x1F,F
2754:  BNZ   2764
2756:  MOVF   x1E,F
2758:  BNZ   2764
275A:  MOVF   x1D,F
275C:  BNZ   2764
275E:  MOVF   x1C,W
2760:  SUBLW  05
2762:  BC    27C4
2764:  MOVF   x1F,F
2766:  BNZ   27C4
2768:  MOVF   x1E,F
276A:  BNZ   27C4
276C:  MOVF   x1D,F
276E:  BNZ   27C4
2770:  MOVF   x1C,W
2772:  SUBLW  3B
2774:  BNC   27C4
2776:  MOVF   x13,F
2778:  BNZ   2788
277A:  MOVF   x12,F
277C:  BNZ   2788
277E:  MOVF   x11,F
2780:  BNZ   2788
2782:  MOVF   x10,W
2784:  SUBLW  64
2786:  BC    27C4
2788:  MOVF   x17,F
278A:  BNZ   279A
278C:  MOVF   x16,F
278E:  BNZ   279A
2790:  MOVF   x15,F
2792:  BNZ   279A
2794:  MOVF   x14,W
2796:  SUBLW  64
2798:  BC    27C4
279A:  MOVF   x1B,F
279C:  BNZ   27AC
279E:  MOVF   x1A,F
27A0:  BNZ   27AC
27A2:  MOVF   x19,F
27A4:  BNZ   27AC
27A6:  MOVF   x18,W
27A8:  SUBLW  64
27AA:  BC    27C4
27AC:  MOVF   x0F,F
27AE:  BNZ   27BE
27B0:  MOVF   x0E,F
27B2:  BNZ   27BE
27B4:  MOVF   x0D,F
27B6:  BNZ   27BE
27B8:  MOVF   x0C,W
27BA:  SUBLW  64
27BC:  BC    27C4
27BE:  MOVLW  04
27C0:  MOVWF  01
27C2:  BRA    287A
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
27C4:  MOVF   x1F,F
27C6:  BNZ   27D8
27C8:  MOVF   x1E,F
27CA:  BNZ   27D8
27CC:  MOVF   x1D,F
27CE:  BNZ   27D8
27D0:  MOVF   x1C,W
27D2:  SUBLW  C8
27D4:  BTFSC  FD8.0
27D6:  BRA    2876
27D8:  MOVF   x0F,F
27DA:  BTFSS  FD8.2
27DC:  BRA    2876
27DE:  MOVF   x0E,F
27E0:  BTFSS  FD8.2
27E2:  BRA    2876
27E4:  MOVF   x0D,F
27E6:  BTFSS  FD8.2
27E8:  BRA    2876
27EA:  MOVF   x0C,W
27EC:  SUBLW  B3
27EE:  BNC   2876
27F0:  MOVF   x0F,F
27F2:  BNZ   2802
27F4:  MOVF   x0E,F
27F6:  BNZ   2802
27F8:  MOVF   x0D,F
27FA:  BNZ   2802
27FC:  MOVF   x0C,W
27FE:  SUBLW  64
2800:  BC    2876
2802:  MOVF   x13,F
2804:  BNZ   2876
2806:  MOVF   x12,F
2808:  BNZ   2876
280A:  MOVF   x11,F
280C:  BNZ   2876
280E:  MOVF   x10,W
2810:  SUBLW  B3
2812:  BNC   2876
2814:  MOVF   x13,F
2816:  BNZ   2826
2818:  MOVF   x12,F
281A:  BNZ   2826
281C:  MOVF   x11,F
281E:  BNZ   2826
2820:  MOVF   x10,W
2822:  SUBLW  64
2824:  BC    2876
2826:  MOVF   x17,F
2828:  BNZ   2876
282A:  MOVF   x16,F
282C:  BNZ   2876
282E:  MOVF   x15,F
2830:  BNZ   2876
2832:  MOVF   x14,W
2834:  SUBLW  B3
2836:  BNC   2876
2838:  MOVF   x17,F
283A:  BNZ   284A
283C:  MOVF   x16,F
283E:  BNZ   284A
2840:  MOVF   x15,F
2842:  BNZ   284A
2844:  MOVF   x14,W
2846:  SUBLW  64
2848:  BC    2876
284A:  MOVF   x1B,F
284C:  BNZ   2876
284E:  MOVF   x1A,F
2850:  BNZ   2876
2852:  MOVF   x19,F
2854:  BNZ   2876
2856:  MOVF   x18,W
2858:  SUBLW  B3
285A:  BNC   2876
285C:  MOVF   x1B,F
285E:  BNZ   286E
2860:  MOVF   x1A,F
2862:  BNZ   286E
2864:  MOVF   x19,F
2866:  BNZ   286E
2868:  MOVF   x18,W
286A:  SUBLW  64
286C:  BC    2876
286E:  MOVLW  04
2870:  MOVWF  01
2872:  BRA    287A
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2874:  BRA    287A
2876:  MOVLW  FF
2878:  MOVWF  01
.................... } 
287A:  MOVLB  0
287C:  GOTO   30C6 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
2880:  MOVLB  8
2882:  CLRF   x0F
2884:  CLRF   x0E
2886:  CLRF   x0D
2888:  CLRF   x0C
288A:  CLRF   x13
288C:  CLRF   x12
288E:  CLRF   x11
2890:  CLRF   x10
2892:  CLRF   x17
2894:  CLRF   x16
2896:  CLRF   x15
2898:  CLRF   x14
289A:  CLRF   x1B
289C:  CLRF   x1A
289E:  CLRF   x19
28A0:  CLRF   x18
28A2:  CLRF   x1F
28A4:  CLRF   x1E
28A6:  CLRF   x1D
28A8:  CLRF   x1C
28AA:  CLRF   x23
28AC:  CLRF   x22
28AE:  CLRF   x21
28B0:  CLRF   x20
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
28B2:  CLRF   x0B
28B4:  CLRF   x0A
28B6:  MOVF   x0B,W
28B8:  SUBLW  01
28BA:  BNC   295A
28BC:  BNZ   28C4
28BE:  MOVF   x0A,W
28C0:  SUBLW  F3
28C2:  BNC   295A
....................    { 
....................       col_0=read_col(0)+col_0; 
28C4:  CLRF   x24
28C6:  MOVLB  0
28C8:  CALL   1FF2
28CC:  MOVF   01,W
28CE:  MOVLB  8
28D0:  ADDWF  x0C,F
28D2:  MOVLW  00
28D4:  ADDWFC x0D,F
28D6:  ADDWFC x0E,F
28D8:  ADDWFC x0F,F
....................       col_1=read_col(1)+col_1; 
28DA:  MOVLW  01
28DC:  MOVWF  x24
28DE:  MOVLB  0
28E0:  CALL   1FF2
28E4:  MOVF   01,W
28E6:  MOVLB  8
28E8:  ADDWF  x10,F
28EA:  MOVLW  00
28EC:  ADDWFC x11,F
28EE:  ADDWFC x12,F
28F0:  ADDWFC x13,F
....................       col_2=read_col(2)+col_2; 
28F2:  MOVLW  02
28F4:  MOVWF  x24
28F6:  MOVLB  0
28F8:  CALL   1FF2
28FC:  MOVF   01,W
28FE:  MOVLB  8
2900:  ADDWF  x14,F
2902:  MOVLW  00
2904:  ADDWFC x15,F
2906:  ADDWFC x16,F
2908:  ADDWFC x17,F
....................       col_3=read_col(3)+col_3; 
290A:  MOVLW  03
290C:  MOVWF  x24
290E:  MOVLB  0
2910:  CALL   1FF2
2914:  MOVF   01,W
2916:  MOVLB  8
2918:  ADDWF  x18,F
291A:  MOVLW  00
291C:  ADDWFC x19,F
291E:  ADDWFC x1A,F
2920:  ADDWFC x1B,F
....................       col_4=read_col(4)+col_4; 
2922:  MOVLW  04
2924:  MOVWF  x24
2926:  MOVLB  0
2928:  CALL   1FF2
292C:  MOVF   01,W
292E:  MOVLB  8
2930:  ADDWF  x1C,F
2932:  MOVLW  00
2934:  ADDWFC x1D,F
2936:  ADDWFC x1E,F
2938:  ADDWFC x1F,F
....................       col_5=read_col(5)+col_5; 
293A:  MOVLW  05
293C:  MOVWF  x24
293E:  MOVLB  0
2940:  CALL   1FF2
2944:  MOVF   01,W
2946:  MOVLB  8
2948:  ADDWF  x20,F
294A:  MOVLW  00
294C:  ADDWFC x21,F
294E:  ADDWFC x22,F
2950:  ADDWFC x23,F
....................    } 
2952:  INCF   x0A,F
2954:  BTFSC  FD8.2
2956:  INCF   x0B,F
2958:  BRA    28B6
....................    col_0=col_0/500; 
295A:  BCF    FD8.1
295C:  MOVFF  80F,833
2960:  MOVFF  80E,832
2964:  MOVFF  80D,831
2968:  MOVFF  80C,830
296C:  CLRF   x37
296E:  CLRF   x36
2970:  MOVLW  01
2972:  MOVWF  x35
2974:  MOVLW  F4
2976:  MOVWF  x34
2978:  MOVLB  0
297A:  CALL   2100
297E:  MOVFF  03,80F
2982:  MOVFF  02,80E
2986:  MOVFF  01,80D
298A:  MOVFF  00,80C
....................    col_1=col_1/500; 
298E:  BCF    FD8.1
2990:  MOVFF  813,833
2994:  MOVFF  812,832
2998:  MOVFF  811,831
299C:  MOVFF  810,830
29A0:  MOVLB  8
29A2:  CLRF   x37
29A4:  CLRF   x36
29A6:  MOVLW  01
29A8:  MOVWF  x35
29AA:  MOVLW  F4
29AC:  MOVWF  x34
29AE:  MOVLB  0
29B0:  CALL   2100
29B4:  MOVFF  03,813
29B8:  MOVFF  02,812
29BC:  MOVFF  01,811
29C0:  MOVFF  00,810
....................    col_2=col_2/500; 
29C4:  BCF    FD8.1
29C6:  MOVFF  817,833
29CA:  MOVFF  816,832
29CE:  MOVFF  815,831
29D2:  MOVFF  814,830
29D6:  MOVLB  8
29D8:  CLRF   x37
29DA:  CLRF   x36
29DC:  MOVLW  01
29DE:  MOVWF  x35
29E0:  MOVLW  F4
29E2:  MOVWF  x34
29E4:  MOVLB  0
29E6:  CALL   2100
29EA:  MOVFF  03,817
29EE:  MOVFF  02,816
29F2:  MOVFF  01,815
29F6:  MOVFF  00,814
....................    col_3=col_3/500; 
29FA:  BCF    FD8.1
29FC:  MOVFF  81B,833
2A00:  MOVFF  81A,832
2A04:  MOVFF  819,831
2A08:  MOVFF  818,830
2A0C:  MOVLB  8
2A0E:  CLRF   x37
2A10:  CLRF   x36
2A12:  MOVLW  01
2A14:  MOVWF  x35
2A16:  MOVLW  F4
2A18:  MOVWF  x34
2A1A:  MOVLB  0
2A1C:  CALL   2100
2A20:  MOVFF  03,81B
2A24:  MOVFF  02,81A
2A28:  MOVFF  01,819
2A2C:  MOVFF  00,818
....................    col_4=col_4/500; 
2A30:  BCF    FD8.1
2A32:  MOVFF  81F,833
2A36:  MOVFF  81E,832
2A3A:  MOVFF  81D,831
2A3E:  MOVFF  81C,830
2A42:  MOVLB  8
2A44:  CLRF   x37
2A46:  CLRF   x36
2A48:  MOVLW  01
2A4A:  MOVWF  x35
2A4C:  MOVLW  F4
2A4E:  MOVWF  x34
2A50:  MOVLB  0
2A52:  CALL   2100
2A56:  MOVFF  03,81F
2A5A:  MOVFF  02,81E
2A5E:  MOVFF  01,81D
2A62:  MOVFF  00,81C
....................    col_5=col_5/500; 
2A66:  BCF    FD8.1
2A68:  MOVFF  823,833
2A6C:  MOVFF  822,832
2A70:  MOVFF  821,831
2A74:  MOVFF  820,830
2A78:  MOVLB  8
2A7A:  CLRF   x37
2A7C:  CLRF   x36
2A7E:  MOVLW  01
2A80:  MOVWF  x35
2A82:  MOVLW  F4
2A84:  MOVWF  x34
2A86:  MOVLB  0
2A88:  CALL   2100
2A8C:  MOVFF  03,823
2A90:  MOVFF  02,822
2A94:  MOVFF  01,821
2A98:  MOVFF  00,820
....................    if(keydebug_en) 
2A9C:  MOVLB  1
2A9E:  MOVF   x2C,F
2AA0:  BTFSC  FD8.2
2AA2:  BRA    2C6C
....................    { 
....................       fprintf(COM2,"\r\n");      
2AA4:  MOVLW  0D
2AA6:  MOVLB  8
2AA8:  MOVWF  x30
2AAA:  MOVLB  0
2AAC:  CALL   0422
2AB0:  MOVLW  0A
2AB2:  MOVLB  8
2AB4:  MOVWF  x30
2AB6:  MOVLB  0
2AB8:  CALL   0422
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2ABC:  MOVLW  C4
2ABE:  MOVWF  FF6
2AC0:  MOVLW  02
2AC2:  MOVWF  FF7
2AC4:  MOVLW  07
2AC6:  MOVLB  8
2AC8:  MOVWF  x24
2ACA:  MOVLB  0
2ACC:  CALL   13EC
2AD0:  MOVLW  41
2AD2:  MOVWF  FE9
2AD4:  MOVFF  80F,827
2AD8:  MOVFF  80E,826
2ADC:  MOVFF  80D,825
2AE0:  MOVFF  80C,824
2AE4:  CALL   2194
2AE8:  MOVLW  0D
2AEA:  MOVLB  8
2AEC:  MOVWF  x30
2AEE:  MOVLB  0
2AF0:  CALL   0422
2AF4:  MOVLW  0A
2AF6:  MOVLB  8
2AF8:  MOVWF  x30
2AFA:  MOVLB  0
2AFC:  CALL   0422
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2B00:  MOVLW  D2
2B02:  MOVWF  FF6
2B04:  MOVLW  02
2B06:  MOVWF  FF7
2B08:  MOVLW  07
2B0A:  MOVLB  8
2B0C:  MOVWF  x24
2B0E:  MOVLB  0
2B10:  CALL   13EC
2B14:  MOVLW  41
2B16:  MOVWF  FE9
2B18:  MOVFF  813,827
2B1C:  MOVFF  812,826
2B20:  MOVFF  811,825
2B24:  MOVFF  810,824
2B28:  CALL   2194
2B2C:  MOVLW  0D
2B2E:  MOVLB  8
2B30:  MOVWF  x30
2B32:  MOVLB  0
2B34:  CALL   0422
2B38:  MOVLW  0A
2B3A:  MOVLB  8
2B3C:  MOVWF  x30
2B3E:  MOVLB  0
2B40:  CALL   0422
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2B44:  MOVLW  E0
2B46:  MOVWF  FF6
2B48:  MOVLW  02
2B4A:  MOVWF  FF7
2B4C:  MOVLW  07
2B4E:  MOVLB  8
2B50:  MOVWF  x24
2B52:  MOVLB  0
2B54:  CALL   13EC
2B58:  MOVLW  41
2B5A:  MOVWF  FE9
2B5C:  MOVFF  817,827
2B60:  MOVFF  816,826
2B64:  MOVFF  815,825
2B68:  MOVFF  814,824
2B6C:  CALL   2194
2B70:  MOVLW  0D
2B72:  MOVLB  8
2B74:  MOVWF  x30
2B76:  MOVLB  0
2B78:  CALL   0422
2B7C:  MOVLW  0A
2B7E:  MOVLB  8
2B80:  MOVWF  x30
2B82:  MOVLB  0
2B84:  CALL   0422
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2B88:  MOVLW  EE
2B8A:  MOVWF  FF6
2B8C:  MOVLW  02
2B8E:  MOVWF  FF7
2B90:  MOVLW  07
2B92:  MOVLB  8
2B94:  MOVWF  x24
2B96:  MOVLB  0
2B98:  CALL   13EC
2B9C:  MOVLW  41
2B9E:  MOVWF  FE9
2BA0:  MOVFF  81B,827
2BA4:  MOVFF  81A,826
2BA8:  MOVFF  819,825
2BAC:  MOVFF  818,824
2BB0:  CALL   2194
2BB4:  MOVLW  0D
2BB6:  MOVLB  8
2BB8:  MOVWF  x30
2BBA:  MOVLB  0
2BBC:  CALL   0422
2BC0:  MOVLW  0A
2BC2:  MOVLB  8
2BC4:  MOVWF  x30
2BC6:  MOVLB  0
2BC8:  CALL   0422
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2BCC:  MOVLW  FC
2BCE:  MOVWF  FF6
2BD0:  MOVLW  02
2BD2:  MOVWF  FF7
2BD4:  MOVLW  07
2BD6:  MOVLB  8
2BD8:  MOVWF  x24
2BDA:  MOVLB  0
2BDC:  CALL   13EC
2BE0:  MOVLW  41
2BE2:  MOVWF  FE9
2BE4:  MOVFF  81F,827
2BE8:  MOVFF  81E,826
2BEC:  MOVFF  81D,825
2BF0:  MOVFF  81C,824
2BF4:  CALL   2194
2BF8:  MOVLW  0D
2BFA:  MOVLB  8
2BFC:  MOVWF  x30
2BFE:  MOVLB  0
2C00:  CALL   0422
2C04:  MOVLW  0A
2C06:  MOVLB  8
2C08:  MOVWF  x30
2C0A:  MOVLB  0
2C0C:  CALL   0422
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2C10:  MOVLW  0A
2C12:  MOVWF  FF6
2C14:  MOVLW  03
2C16:  MOVWF  FF7
2C18:  MOVLW  07
2C1A:  MOVLB  8
2C1C:  MOVWF  x24
2C1E:  MOVLB  0
2C20:  CALL   13EC
2C24:  MOVLW  41
2C26:  MOVWF  FE9
2C28:  MOVFF  823,827
2C2C:  MOVFF  822,826
2C30:  MOVFF  821,825
2C34:  MOVFF  820,824
2C38:  CALL   2194
2C3C:  MOVLW  0D
2C3E:  MOVLB  8
2C40:  MOVWF  x30
2C42:  MOVLB  0
2C44:  CALL   0422
2C48:  MOVLW  0A
2C4A:  MOVLB  8
2C4C:  MOVWF  x30
2C4E:  MOVLB  0
2C50:  CALL   0422
....................       fprintf(COM2,"\r\n"); 
2C54:  MOVLW  0D
2C56:  MOVLB  8
2C58:  MOVWF  x30
2C5A:  MOVLB  0
2C5C:  CALL   0422
2C60:  MOVLW  0A
2C62:  MOVLB  8
2C64:  MOVWF  x30
2C66:  MOVLB  0
2C68:  CALL   0422
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2C6C:  MOVLB  8
2C6E:  MOVF   x0F,F
2C70:  BNZ   2C80
2C72:  MOVF   x0E,F
2C74:  BNZ   2C80
2C76:  MOVF   x0D,F
2C78:  BNZ   2C80
2C7A:  MOVF   x0C,W
2C7C:  SUBLW  05
2C7E:  BC    2CF2
2C80:  MOVF   x0F,F
2C82:  BNZ   2CF2
2C84:  MOVF   x0E,F
2C86:  BNZ   2CF2
2C88:  MOVF   x0D,F
2C8A:  BNZ   2CF2
2C8C:  MOVF   x0C,W
2C8E:  SUBLW  3B
2C90:  BNC   2CF2
2C92:  MOVF   x13,F
2C94:  BNZ   2CA4
2C96:  MOVF   x12,F
2C98:  BNZ   2CA4
2C9A:  MOVF   x11,F
2C9C:  BNZ   2CA4
2C9E:  MOVF   x10,W
2CA0:  SUBLW  64
2CA2:  BC    2CF2
2CA4:  MOVF   x17,F
2CA6:  BNZ   2CB6
2CA8:  MOVF   x16,F
2CAA:  BNZ   2CB6
2CAC:  MOVF   x15,F
2CAE:  BNZ   2CB6
2CB0:  MOVF   x14,W
2CB2:  SUBLW  64
2CB4:  BC    2CF2
2CB6:  MOVF   x1B,F
2CB8:  BNZ   2CC8
2CBA:  MOVF   x1A,F
2CBC:  BNZ   2CC8
2CBE:  MOVF   x19,F
2CC0:  BNZ   2CC8
2CC2:  MOVF   x18,W
2CC4:  SUBLW  64
2CC6:  BC    2CF2
2CC8:  MOVF   x1F,F
2CCA:  BNZ   2CDA
2CCC:  MOVF   x1E,F
2CCE:  BNZ   2CDA
2CD0:  MOVF   x1D,F
2CD2:  BNZ   2CDA
2CD4:  MOVF   x1C,W
2CD6:  SUBLW  64
2CD8:  BC    2CF2
2CDA:  MOVF   x23,F
2CDC:  BNZ   2CEC
2CDE:  MOVF   x22,F
2CE0:  BNZ   2CEC
2CE2:  MOVF   x21,F
2CE4:  BNZ   2CEC
2CE6:  MOVF   x20,W
2CE8:  SUBLW  64
2CEA:  BC    2CF2
2CEC:  MOVLW  00
2CEE:  MOVWF  01
2CF0:  BRA    306A
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2CF2:  MOVF   x13,F
2CF4:  BNZ   2D04
2CF6:  MOVF   x12,F
2CF8:  BNZ   2D04
2CFA:  MOVF   x11,F
2CFC:  BNZ   2D04
2CFE:  MOVF   x10,W
2D00:  SUBLW  05
2D02:  BC    2D76
2D04:  MOVF   x13,F
2D06:  BNZ   2D76
2D08:  MOVF   x12,F
2D0A:  BNZ   2D76
2D0C:  MOVF   x11,F
2D0E:  BNZ   2D76
2D10:  MOVF   x10,W
2D12:  SUBLW  3B
2D14:  BNC   2D76
2D16:  MOVF   x0F,F
2D18:  BNZ   2D28
2D1A:  MOVF   x0E,F
2D1C:  BNZ   2D28
2D1E:  MOVF   x0D,F
2D20:  BNZ   2D28
2D22:  MOVF   x0C,W
2D24:  SUBLW  64
2D26:  BC    2D76
2D28:  MOVF   x17,F
2D2A:  BNZ   2D3A
2D2C:  MOVF   x16,F
2D2E:  BNZ   2D3A
2D30:  MOVF   x15,F
2D32:  BNZ   2D3A
2D34:  MOVF   x14,W
2D36:  SUBLW  64
2D38:  BC    2D76
2D3A:  MOVF   x1B,F
2D3C:  BNZ   2D4C
2D3E:  MOVF   x1A,F
2D40:  BNZ   2D4C
2D42:  MOVF   x19,F
2D44:  BNZ   2D4C
2D46:  MOVF   x18,W
2D48:  SUBLW  64
2D4A:  BC    2D76
2D4C:  MOVF   x1F,F
2D4E:  BNZ   2D5E
2D50:  MOVF   x1E,F
2D52:  BNZ   2D5E
2D54:  MOVF   x1D,F
2D56:  BNZ   2D5E
2D58:  MOVF   x1C,W
2D5A:  SUBLW  64
2D5C:  BC    2D76
2D5E:  MOVF   x23,F
2D60:  BNZ   2D70
2D62:  MOVF   x22,F
2D64:  BNZ   2D70
2D66:  MOVF   x21,F
2D68:  BNZ   2D70
2D6A:  MOVF   x20,W
2D6C:  SUBLW  64
2D6E:  BC    2D76
2D70:  MOVLW  01
2D72:  MOVWF  01
2D74:  BRA    306A
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2D76:  MOVF   x17,F
2D78:  BNZ   2D88
2D7A:  MOVF   x16,F
2D7C:  BNZ   2D88
2D7E:  MOVF   x15,F
2D80:  BNZ   2D88
2D82:  MOVF   x14,W
2D84:  SUBLW  05
2D86:  BC    2DFA
2D88:  MOVF   x17,F
2D8A:  BNZ   2DFA
2D8C:  MOVF   x16,F
2D8E:  BNZ   2DFA
2D90:  MOVF   x15,F
2D92:  BNZ   2DFA
2D94:  MOVF   x14,W
2D96:  SUBLW  3B
2D98:  BNC   2DFA
2D9A:  MOVF   x13,F
2D9C:  BNZ   2DAC
2D9E:  MOVF   x12,F
2DA0:  BNZ   2DAC
2DA2:  MOVF   x11,F
2DA4:  BNZ   2DAC
2DA6:  MOVF   x10,W
2DA8:  SUBLW  64
2DAA:  BC    2DFA
2DAC:  MOVF   x0F,F
2DAE:  BNZ   2DBE
2DB0:  MOVF   x0E,F
2DB2:  BNZ   2DBE
2DB4:  MOVF   x0D,F
2DB6:  BNZ   2DBE
2DB8:  MOVF   x0C,W
2DBA:  SUBLW  64
2DBC:  BC    2DFA
2DBE:  MOVF   x1B,F
2DC0:  BNZ   2DD0
2DC2:  MOVF   x1A,F
2DC4:  BNZ   2DD0
2DC6:  MOVF   x19,F
2DC8:  BNZ   2DD0
2DCA:  MOVF   x18,W
2DCC:  SUBLW  64
2DCE:  BC    2DFA
2DD0:  MOVF   x1F,F
2DD2:  BNZ   2DE2
2DD4:  MOVF   x1E,F
2DD6:  BNZ   2DE2
2DD8:  MOVF   x1D,F
2DDA:  BNZ   2DE2
2DDC:  MOVF   x1C,W
2DDE:  SUBLW  64
2DE0:  BC    2DFA
2DE2:  MOVF   x23,F
2DE4:  BNZ   2DF4
2DE6:  MOVF   x22,F
2DE8:  BNZ   2DF4
2DEA:  MOVF   x21,F
2DEC:  BNZ   2DF4
2DEE:  MOVF   x20,W
2DF0:  SUBLW  64
2DF2:  BC    2DFA
2DF4:  MOVLW  02
2DF6:  MOVWF  01
2DF8:  BRA    306A
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2DFA:  MOVF   x1B,F
2DFC:  BNZ   2E0C
2DFE:  MOVF   x1A,F
2E00:  BNZ   2E0C
2E02:  MOVF   x19,F
2E04:  BNZ   2E0C
2E06:  MOVF   x18,W
2E08:  SUBLW  05
2E0A:  BC    2E7E
2E0C:  MOVF   x1B,F
2E0E:  BNZ   2E7E
2E10:  MOVF   x1A,F
2E12:  BNZ   2E7E
2E14:  MOVF   x19,F
2E16:  BNZ   2E7E
2E18:  MOVF   x18,W
2E1A:  SUBLW  3B
2E1C:  BNC   2E7E
2E1E:  MOVF   x13,F
2E20:  BNZ   2E30
2E22:  MOVF   x12,F
2E24:  BNZ   2E30
2E26:  MOVF   x11,F
2E28:  BNZ   2E30
2E2A:  MOVF   x10,W
2E2C:  SUBLW  64
2E2E:  BC    2E7E
2E30:  MOVF   x17,F
2E32:  BNZ   2E42
2E34:  MOVF   x16,F
2E36:  BNZ   2E42
2E38:  MOVF   x15,F
2E3A:  BNZ   2E42
2E3C:  MOVF   x14,W
2E3E:  SUBLW  64
2E40:  BC    2E7E
2E42:  MOVF   x0F,F
2E44:  BNZ   2E54
2E46:  MOVF   x0E,F
2E48:  BNZ   2E54
2E4A:  MOVF   x0D,F
2E4C:  BNZ   2E54
2E4E:  MOVF   x0C,W
2E50:  SUBLW  64
2E52:  BC    2E7E
2E54:  MOVF   x1F,F
2E56:  BNZ   2E66
2E58:  MOVF   x1E,F
2E5A:  BNZ   2E66
2E5C:  MOVF   x1D,F
2E5E:  BNZ   2E66
2E60:  MOVF   x1C,W
2E62:  SUBLW  64
2E64:  BC    2E7E
2E66:  MOVF   x23,F
2E68:  BNZ   2E78
2E6A:  MOVF   x22,F
2E6C:  BNZ   2E78
2E6E:  MOVF   x21,F
2E70:  BNZ   2E78
2E72:  MOVF   x20,W
2E74:  SUBLW  64
2E76:  BC    2E7E
2E78:  MOVLW  03
2E7A:  MOVWF  01
2E7C:  BRA    306A
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
2E7E:  MOVF   x1F,F
2E80:  BNZ   2E90
2E82:  MOVF   x1E,F
2E84:  BNZ   2E90
2E86:  MOVF   x1D,F
2E88:  BNZ   2E90
2E8A:  MOVF   x1C,W
2E8C:  SUBLW  05
2E8E:  BC    2F02
2E90:  MOVF   x1F,F
2E92:  BNZ   2F02
2E94:  MOVF   x1E,F
2E96:  BNZ   2F02
2E98:  MOVF   x1D,F
2E9A:  BNZ   2F02
2E9C:  MOVF   x1C,W
2E9E:  SUBLW  3B
2EA0:  BNC   2F02
2EA2:  MOVF   x13,F
2EA4:  BNZ   2EB4
2EA6:  MOVF   x12,F
2EA8:  BNZ   2EB4
2EAA:  MOVF   x11,F
2EAC:  BNZ   2EB4
2EAE:  MOVF   x10,W
2EB0:  SUBLW  64
2EB2:  BC    2F02
2EB4:  MOVF   x17,F
2EB6:  BNZ   2EC6
2EB8:  MOVF   x16,F
2EBA:  BNZ   2EC6
2EBC:  MOVF   x15,F
2EBE:  BNZ   2EC6
2EC0:  MOVF   x14,W
2EC2:  SUBLW  64
2EC4:  BC    2F02
2EC6:  MOVF   x1B,F
2EC8:  BNZ   2ED8
2ECA:  MOVF   x1A,F
2ECC:  BNZ   2ED8
2ECE:  MOVF   x19,F
2ED0:  BNZ   2ED8
2ED2:  MOVF   x18,W
2ED4:  SUBLW  64
2ED6:  BC    2F02
2ED8:  MOVF   x0F,F
2EDA:  BNZ   2EEA
2EDC:  MOVF   x0E,F
2EDE:  BNZ   2EEA
2EE0:  MOVF   x0D,F
2EE2:  BNZ   2EEA
2EE4:  MOVF   x0C,W
2EE6:  SUBLW  64
2EE8:  BC    2F02
2EEA:  MOVF   x23,F
2EEC:  BNZ   2EFC
2EEE:  MOVF   x22,F
2EF0:  BNZ   2EFC
2EF2:  MOVF   x21,F
2EF4:  BNZ   2EFC
2EF6:  MOVF   x20,W
2EF8:  SUBLW  64
2EFA:  BC    2F02
2EFC:  MOVLW  04
2EFE:  MOVWF  01
2F00:  BRA    306A
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
2F02:  MOVF   x23,F
2F04:  BNZ   2F14
2F06:  MOVF   x22,F
2F08:  BNZ   2F14
2F0A:  MOVF   x21,F
2F0C:  BNZ   2F14
2F0E:  MOVF   x20,W
2F10:  SUBLW  05
2F12:  BC    2F86
2F14:  MOVF   x23,F
2F16:  BNZ   2F86
2F18:  MOVF   x22,F
2F1A:  BNZ   2F86
2F1C:  MOVF   x21,F
2F1E:  BNZ   2F86
2F20:  MOVF   x20,W
2F22:  SUBLW  3B
2F24:  BNC   2F86
2F26:  MOVF   x13,F
2F28:  BNZ   2F38
2F2A:  MOVF   x12,F
2F2C:  BNZ   2F38
2F2E:  MOVF   x11,F
2F30:  BNZ   2F38
2F32:  MOVF   x10,W
2F34:  SUBLW  64
2F36:  BC    2F86
2F38:  MOVF   x17,F
2F3A:  BNZ   2F4A
2F3C:  MOVF   x16,F
2F3E:  BNZ   2F4A
2F40:  MOVF   x15,F
2F42:  BNZ   2F4A
2F44:  MOVF   x14,W
2F46:  SUBLW  64
2F48:  BC    2F86
2F4A:  MOVF   x1B,F
2F4C:  BNZ   2F5C
2F4E:  MOVF   x1A,F
2F50:  BNZ   2F5C
2F52:  MOVF   x19,F
2F54:  BNZ   2F5C
2F56:  MOVF   x18,W
2F58:  SUBLW  64
2F5A:  BC    2F86
2F5C:  MOVF   x1F,F
2F5E:  BNZ   2F6E
2F60:  MOVF   x1E,F
2F62:  BNZ   2F6E
2F64:  MOVF   x1D,F
2F66:  BNZ   2F6E
2F68:  MOVF   x1C,W
2F6A:  SUBLW  64
2F6C:  BC    2F86
2F6E:  MOVF   x0F,F
2F70:  BNZ   2F80
2F72:  MOVF   x0E,F
2F74:  BNZ   2F80
2F76:  MOVF   x0D,F
2F78:  BNZ   2F80
2F7A:  MOVF   x0C,W
2F7C:  SUBLW  64
2F7E:  BC    2F86
2F80:  MOVLW  05
2F82:  MOVWF  01
2F84:  BRA    306A
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
2F86:  MOVF   x23,F
2F88:  BNZ   2F9A
2F8A:  MOVF   x22,F
2F8C:  BNZ   2F9A
2F8E:  MOVF   x21,F
2F90:  BNZ   2F9A
2F92:  MOVF   x20,W
2F94:  SUBLW  C8
2F96:  BTFSC  FD8.0
2F98:  BRA    3066
2F9A:  MOVF   x0F,F
2F9C:  BTFSS  FD8.2
2F9E:  BRA    3066
2FA0:  MOVF   x0E,F
2FA2:  BTFSS  FD8.2
2FA4:  BRA    3066
2FA6:  MOVF   x0D,F
2FA8:  BTFSS  FD8.2
2FAA:  BRA    3066
2FAC:  MOVF   x0C,W
2FAE:  SUBLW  B3
2FB0:  BTFSS  FD8.0
2FB2:  BRA    3066
2FB4:  MOVF   x0F,F
2FB6:  BNZ   2FC8
2FB8:  MOVF   x0E,F
2FBA:  BNZ   2FC8
2FBC:  MOVF   x0D,F
2FBE:  BNZ   2FC8
2FC0:  MOVF   x0C,W
2FC2:  SUBLW  64
2FC4:  BTFSC  FD8.0
2FC6:  BRA    3066
2FC8:  MOVF   x13,F
2FCA:  BTFSS  FD8.2
2FCC:  BRA    3066
2FCE:  MOVF   x12,F
2FD0:  BTFSS  FD8.2
2FD2:  BRA    3066
2FD4:  MOVF   x11,F
2FD6:  BTFSS  FD8.2
2FD8:  BRA    3066
2FDA:  MOVF   x10,W
2FDC:  SUBLW  B3
2FDE:  BNC   3066
2FE0:  MOVF   x13,F
2FE2:  BNZ   2FF2
2FE4:  MOVF   x12,F
2FE6:  BNZ   2FF2
2FE8:  MOVF   x11,F
2FEA:  BNZ   2FF2
2FEC:  MOVF   x10,W
2FEE:  SUBLW  64
2FF0:  BC    3066
2FF2:  MOVF   x17,F
2FF4:  BNZ   3066
2FF6:  MOVF   x16,F
2FF8:  BNZ   3066
2FFA:  MOVF   x15,F
2FFC:  BNZ   3066
2FFE:  MOVF   x14,W
3000:  SUBLW  B3
3002:  BNC   3066
3004:  MOVF   x17,F
3006:  BNZ   3016
3008:  MOVF   x16,F
300A:  BNZ   3016
300C:  MOVF   x15,F
300E:  BNZ   3016
3010:  MOVF   x14,W
3012:  SUBLW  64
3014:  BC    3066
3016:  MOVF   x1B,F
3018:  BNZ   3066
301A:  MOVF   x1A,F
301C:  BNZ   3066
301E:  MOVF   x19,F
3020:  BNZ   3066
3022:  MOVF   x18,W
3024:  SUBLW  B3
3026:  BNC   3066
3028:  MOVF   x1B,F
302A:  BNZ   303A
302C:  MOVF   x1A,F
302E:  BNZ   303A
3030:  MOVF   x19,F
3032:  BNZ   303A
3034:  MOVF   x18,W
3036:  SUBLW  64
3038:  BC    3066
303A:  MOVF   x1F,F
303C:  BNZ   3066
303E:  MOVF   x1E,F
3040:  BNZ   3066
3042:  MOVF   x1D,F
3044:  BNZ   3066
3046:  MOVF   x1C,W
3048:  SUBLW  B3
304A:  BNC   3066
304C:  MOVF   x1F,F
304E:  BNZ   305E
3050:  MOVF   x1E,F
3052:  BNZ   305E
3054:  MOVF   x1D,F
3056:  BNZ   305E
3058:  MOVF   x1C,W
305A:  SUBLW  64
305C:  BC    3066
305E:  MOVLW  05
3060:  MOVWF  01
3062:  BRA    306A
....................    else return 0xff; 
3064:  BRA    306A
3066:  MOVLW  FF
3068:  MOVWF  01
.................... } 
306A:  MOVLB  0
306C:  GOTO   30D2 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
3070:  MOVLW  20
3072:  MOVLB  8
3074:  MOVWF  x08
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
3076:  BSF    F93.4
3078:  BTFSS  F81.4
307A:  BRA    308E
307C:  BSF    F93.5
307E:  BTFSS  F81.5
3080:  BRA    308E
3082:  BSF    F93.6
3084:  BTFSS  F81.6
3086:  BRA    308E
3088:  BSF    F93.7
308A:  BTFSC  F81.7
308C:  BRA    31F4
....................     { 
....................        if(input(ROW0)==0) 
308E:  BSF    F93.4
3090:  BTFSC  F81.4
3092:  BRA    3098
....................          row=0; 
3094:  CLRF   x09
....................        else if(input(ROW1)==0) 
3096:  BRA    30BA
3098:  BSF    F93.5
309A:  BTFSC  F81.5
309C:  BRA    30A4
....................          row=1; 
309E:  MOVLW  01
30A0:  MOVWF  x09
....................        else if(input(ROW2)==0) 
30A2:  BRA    30BA
30A4:  BSF    F93.6
30A6:  BTFSC  F81.6
30A8:  BRA    30B0
....................          row=2; 
30AA:  MOVLW  02
30AC:  MOVWF  x09
....................        else if(input(ROW3)==0) 
30AE:  BRA    30BA
30B0:  BSF    F93.7
30B2:  BTFSC  F81.7
30B4:  BRA    30BA
....................          row=3;      
30B6:  MOVLW  03
30B8:  MOVWF  x09
....................        if(type_KB==0)col=check_col(); 
30BA:  MOVLB  1
30BC:  MOVF   x34,F
30BE:  BNZ   30CC
30C0:  MOVLB  0
30C2:  GOTO   2254
30C6:  MOVFF  01,807
....................          else col=new_check_col(); 
30CA:  BRA    30D6
30CC:  MOVLB  0
30CE:  GOTO   2880
30D2:  MOVFF  01,807
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
30D6:  MOVLB  8
30D8:  INCFSZ x07,W
30DA:  BRA    30DE
30DC:  BRA    31C4
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
30DE:  MOVLB  1
30E0:  MOVF   x34,F
30E2:  BNZ   310A
30E4:  MOVLB  8
30E6:  MOVF   x09,W
30E8:  MULLW  05
30EA:  MOVF   FF3,W
30EC:  CLRF   x0B
30EE:  MOVWF  x0A
30F0:  CLRF   03
30F2:  MOVF   x07,W
30F4:  ADDWF  x0A,W
30F6:  MOVWF  01
30F8:  MOVF   x0B,W
30FA:  ADDWFC 03,F
30FC:  MOVF   01,W
30FE:  MOVLB  0
3100:  CALL   00D0
3104:  MOVFF  FE8,808
....................            else kchar =newKEYS[row][col]; 
3108:  BRA    312E
310A:  MOVLB  8
310C:  MOVF   x09,W
310E:  MULLW  06
3110:  MOVF   FF3,W
3112:  CLRF   x0B
3114:  MOVWF  x0A
3116:  CLRF   03
3118:  MOVF   x07,W
311A:  ADDWF  x0A,W
311C:  MOVWF  01
311E:  MOVF   x0B,W
3120:  ADDWFC 03,F
3122:  MOVF   01,W
3124:  MOVLB  0
3126:  CALL   00F4
312A:  MOVFF  FE8,808
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
312E:  MOVLB  1
3130:  MOVF   x2C,F
3132:  BNZ   31B6
....................             { 
....................               charac_timeout=0; 
3134:  CLRF   x1D
3136:  CLRF   x1C
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
3138:  MOVF   x2F,W
313A:  SUBLW  0F
313C:  BNC   3152
313E:  MOVF   x2F,W
3140:  INCF   x2F,F
3142:  CLRF   03
3144:  ADDLW  35
3146:  MOVWF  FE9
3148:  MOVLW  01
314A:  ADDWFC 03,W
314C:  MOVWF  FEA
314E:  MOVFF  808,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
3152:  MOVLW  18
3154:  MOVWF  FF6
3156:  MOVLW  03
3158:  MOVWF  FF7
315A:  MOVLW  09
315C:  MOVLB  8
315E:  MOVWF  x24
3160:  MOVLB  0
3162:  CALL   13EC
3166:  MOVFF  12F,810
316A:  MOVLW  18
316C:  MOVLB  8
316E:  MOVWF  x11
3170:  MOVLB  0
3172:  CALL   1500
3176:  MOVLW  5D
3178:  MOVLB  8
317A:  MOVWF  x30
317C:  MOVLB  0
317E:  CALL   0422
3182:  MOVLW  20
3184:  MOVLB  8
3186:  MOVWF  x30
3188:  MOVLB  0
318A:  CALL   0422
318E:  MOVFF  808,830
3192:  CALL   0422
3196:  MOVLW  0D
3198:  MOVLB  8
319A:  MOVWF  x30
319C:  MOVLB  0
319E:  CALL   0422
31A2:  MOVLW  0A
31A4:  MOVLB  8
31A6:  MOVWF  x30
31A8:  MOVLB  0
31AA:  CALL   0422
....................                count_checking=0; 
31AE:  MOVLB  1
31B0:  CLRF   x28
31B2:  CLRF   x27
....................             } 
....................                else fputc(kchar,COM2); 
31B4:  BRA    31C2
31B6:  MOVFF  808,830
31BA:  MOVLB  0
31BC:  CALL   0422
31C0:  MOVLB  1
31C2:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
31C4:  BSF    F93.4
31C6:  BTFSS  F81.4
31C8:  BRA    31C4
31CA:  BSF    F93.5
31CC:  BTFSS  F81.5
31CE:  BRA    31C4
31D0:  BSF    F93.6
31D2:  BTFSS  F81.6
31D4:  BRA    31C4
31D6:  BSF    F93.7
31D8:  BTFSS  F81.7
31DA:  BRA    31C4
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
31DC:  BSF    F93.4
31DE:  BTFSS  F81.4
31E0:  BRA    31DC
31E2:  BSF    F93.5
31E4:  BTFSS  F81.5
31E6:  BRA    31DC
31E8:  BSF    F93.6
31EA:  BTFSS  F81.6
31EC:  BRA    31DC
31EE:  BSF    F93.7
31F0:  BTFSS  F81.7
31F2:  BRA    31DC
....................     } 
....................   set_tris_a(0xff);     
31F4:  MOVLW  FF
31F6:  MOVWF  F92
....................   return(kchar); 
31F8:  MOVFF  808,01
.................... }//*/ 
31FC:  MOVLB  0
31FE:  RETURN 0
.................... //============================================ 
....................  
.................... //=========================== 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
3DDC:  MOVF   27,F
3DDE:  BTFSS  FD8.2
3DE0:  BRA    3F50
3DE2:  MOVF   26,W
3DE4:  SUBLW  01
3DE6:  BTFSS  FD8.0
3DE8:  BRA    3F50
3DEA:  BNZ   3DFE
3DEC:  MOVF   25,W
3DEE:  SUBLW  FF
3DF0:  BTFSS  FD8.0
3DF2:  BRA    3F50
3DF4:  BNZ   3DFE
3DF6:  MOVF   24,W
3DF8:  SUBLW  FE
3DFA:  BTFSS  FD8.0
3DFC:  BRA    3F50
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
3DFE:  MOVLB  1
3E00:  MOVF   x35,F
3E02:  BNZ   3E0A
3E04:  MOVF   x2F,F
3E06:  BTFSC  FD8.2
3E08:  BRA    3EFE
....................       { 
....................          temp=get_countcard(); 
3E0A:  MOVLB  0
3E0C:  CALL   33AC
3E10:  MOVFF  02,809
3E14:  MOVFF  01,808
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
3E18:  MOVLB  8
3E1A:  RLCF   x08,W
3E1C:  MOVWF  x0A
3E1E:  RLCF   x09,W
3E20:  MOVWF  x0B
3E22:  RLCF   x0A,F
3E24:  RLCF   x0B,F
3E26:  RLCF   x0A,F
3E28:  RLCF   x0B,F
3E2A:  RLCF   x0A,F
3E2C:  RLCF   x0B,F
3E2E:  MOVLW  F0
3E30:  ANDWF  x0A,F
3E32:  MOVLW  0E
3E34:  ADDWF  x0A,F
3E36:  MOVLW  C3
3E38:  ADDWFC x0B,F
3E3A:  MOVLW  01
3E3C:  MOVWF  x0C
3E3E:  BCF    FD8.2
3E40:  BTFSC  FD8.0
3E42:  INCF   x0C,F
3E44:  CLRF   x0D
3E46:  MOVLW  01
3E48:  ADDWF  x0A,W
3E4A:  MOVWF  00
3E4C:  MOVLW  00
3E4E:  ADDWFC x0B,W
3E50:  MOVWF  01
3E52:  MOVLW  00
3E54:  ADDWFC x0C,W
3E56:  MOVWF  02
3E58:  MOVLW  00
3E5A:  ADDWFC x0D,W
3E5C:  MOVWF  27
3E5E:  MOVFF  02,26
3E62:  MOVFF  01,25
3E66:  MOVFF  00,24
....................          for(i=0;i<key_numbyte-5;i++) 
3E6A:  CLRF   x07
3E6C:  MOVF   x07,W
3E6E:  SUBLW  0A
3E70:  BNC   3ED0
....................          { 
....................             temp=key_data[i]; 
3E72:  CLRF   03
3E74:  MOVF   x07,W
3E76:  ADDLW  35
3E78:  MOVWF  FE9
3E7A:  MOVLW  01
3E7C:  ADDWFC 03,W
3E7E:  MOVWF  FEA
3E80:  CLRF   x09
3E82:  MOVFF  FEF,808
....................             write_ext_eeprom((long int)ptr_card_key++,temp); 
3E86:  MOVFF  27,03
3E8A:  MOVFF  26,02
3E8E:  MOVFF  25,01
3E92:  MOVFF  24,00
3E96:  MOVLW  01
3E98:  ADDWF  24,F
3E9A:  BTFSC  FD8.0
3E9C:  INCF   25,F
3E9E:  BTFSC  FD8.2
3EA0:  INCF   26,F
3EA2:  BTFSC  FD8.2
3EA4:  INCF   27,F
3EA6:  MOVFF  01,80B
3EAA:  MOVFF  00,80A
3EAE:  CLRF   x1B
3EB0:  CLRF   x1A
3EB2:  MOVFF  01,819
3EB6:  MOVFF  00,818
3EBA:  MOVFF  808,81C
3EBE:  MOVLB  0
3EC0:  RCALL  3830
....................             //delay_us(100); 
....................             fputc(temp,COM2); 
3EC2:  MOVFF  808,830
3EC6:  CALL   0422
....................          } 
3ECA:  MOVLB  8
3ECC:  INCF   x07,F
3ECE:  BRA    3E6C
....................          /*fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<key_numbyte;i++) 
....................           { 
....................             fprintf(COM2,"read key=%c\n\r",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          write_ext_eeprom((long int)ptr_card_key,0); 
3ED0:  CLRF   x1B
3ED2:  CLRF   x1A
3ED4:  MOVFF  25,819
3ED8:  MOVFF  24,818
3EDC:  CLRF   x1C
3EDE:  MOVLB  0
3EE0:  RCALL  3830
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
3EE2:  MOVFF  27,80D
3EE6:  MOVFF  26,80C
3EEA:  MOVFF  25,80B
3EEE:  MOVFF  24,80A
3EF2:  MOVLW  1E
3EF4:  MOVLB  8
3EF6:  MOVWF  x0E
3EF8:  MOVLB  0
3EFA:  RCALL  392E
3EFC:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
3EFE:  CLRF   x2F
....................       del_buf(key_numbyte,key_data); 
3F00:  MOVLW  10
3F02:  MOVLB  8
3F04:  MOVWF  x16
3F06:  MOVLW  01
3F08:  MOVWF  x18
3F0A:  MOVLW  35
3F0C:  MOVWF  x17
3F0E:  MOVLB  0
3F10:  CALL   3426
....................       fprintf(COM2,"\r\n"); 
3F14:  MOVLW  0D
3F16:  MOVLB  8
3F18:  MOVWF  x30
3F1A:  MOVLB  0
3F1C:  CALL   0422
3F20:  MOVLW  0A
3F22:  MOVLB  8
3F24:  MOVWF  x30
3F26:  MOVLB  0
3F28:  CALL   0422
....................       fprintf(COM2,"Done PIN"); 
3F2C:  MOVLW  2A
3F2E:  MOVWF  FF6
3F30:  MOVLW  03
3F32:  MOVWF  FF7
3F34:  CALL   0474
....................       fprintf(COM2,"\r\n"); 
3F38:  MOVLW  0D
3F3A:  MOVLB  8
3F3C:  MOVWF  x30
3F3E:  MOVLB  0
3F40:  CALL   0422
3F44:  MOVLW  0A
3F46:  MOVLB  8
3F48:  MOVWF  x30
3F4A:  MOVLB  0
3F4C:  CALL   0422
....................    } 
.................... } 
3F50:  GOTO   421C (RETURN)
.................... //=========================================== 
.................... void key_press() 
.................... { 
....................    int8 col; 
....................    int32 KB_count_timeout=0; 
....................    fprintf(COM2,"\r\n"); 
....................    fprintf(COM2,"Key"); 
....................    //fprintf(COM2,"\r\n"); 
....................    KB_count_timeout=0; 
....................    while(1) 
....................    { 
....................       
....................       if(KB_count_timeout<150000)KB_count_timeout++; 
....................       if(KB_count_timeout==150000) 
....................       { 
....................          KB_count_timeout++; 
....................           
....................          break;             
....................       }   
....................    } 
.................... } 
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
4826:  MOVLB  7
4828:  CLRF   xE2
482A:  CLRF   xE1
482C:  CLRF   xE3
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
482E:  MOVF   xE2,F
4830:  BTFSS  FD8.2
4832:  BRA    4956
4834:  MOVF   xDC,W
4836:  SUBWF  xE1,W
4838:  BTFSC  FD8.0
483A:  BRA    4956
483C:  MOVF   xE3,F
483E:  BTFSS  FD8.2
4840:  BRA    4956
....................       c = fgetc(COM2);//getc(); 
4842:  MOVLB  0
4844:  RCALL  47CA
4846:  MOVFF  01,7DF
....................       switch(c) 
....................       { 
484A:  MOVLB  7
484C:  MOVF   xDF,W
484E:  XORLW  7F
4850:  MOVLB  0
4852:  BZ    485A
4854:  XORLW  72
4856:  BZ    48A8
4858:  BRA    48E6
....................          case 0x7f:    
....................             if(nbcar>0)   
485A:  MOVLB  7
485C:  MOVF   xE1,F
485E:  BNZ   4864
4860:  MOVF   xE2,F
4862:  BZ    488E
4864:  CLRF   19
4866:  BTFSC  FF2.7
4868:  BSF    19.7
486A:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
486C:  MOVLW  7F
486E:  MOVLB  8
4870:  MOVWF  x30
4872:  MOVLB  0
4874:  CALL   0422
4878:  BTFSC  19.7
487A:  BSF    FF2.7
....................                nbcar--; 
487C:  MOVLB  7
487E:  MOVF   xE1,W
4880:  BTFSC  FD8.2
4882:  DECF   xE2,F
4884:  DECF   xE1,F
....................                fgetc(COM2);//getc(); 
4886:  MOVLB  0
4888:  RCALL  47CA
....................             } 
....................             else fputc(0x07,COM2);    
488A:  BRA    48A6
488C:  MOVLB  7
488E:  CLRF   19
4890:  BTFSC  FF2.7
4892:  BSF    19.7
4894:  BCF    FF2.7
4896:  MOVLW  07
4898:  MOVLB  8
489A:  MOVWF  x30
489C:  MOVLB  0
489E:  CALL   0422
48A2:  BTFSC  19.7
48A4:  BSF    FF2.7
....................          break;  
48A6:  BRA    4952
....................          case 0x0D:   
....................                keydebug_en=0; 
48A8:  MOVLB  1
48AA:  CLRF   x2C
....................                set_tris_a(0xff); 
48AC:  MOVLW  FF
48AE:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
48B0:  MOVFF  7E1,7E0
48B4:  MOVLB  7
48B6:  MOVF   xDC,W
48B8:  SUBWF  xE0,W
48BA:  BC    48D0
....................                { 
....................                  chaine[i]=0; 
48BC:  CLRF   03
48BE:  MOVF   xE0,W
48C0:  ADDWF  xDD,W
48C2:  MOVWF  FE9
48C4:  MOVF   xDE,W
48C6:  ADDWFC 03,W
48C8:  MOVWF  FEA
48CA:  CLRF   FEF
....................                } 
48CC:  INCF   xE0,F
48CE:  BRA    48B6
....................                if(nbcar==0)return(FAUX); 
48D0:  MOVF   xE1,F
48D2:  BNZ   48DE
48D4:  MOVF   xE2,F
48D6:  BNZ   48DE
48D8:  MOVLW  00
48DA:  MOVWF  01
48DC:  BRA    495A
....................                fini=VRAI; 
48DE:  MOVLW  01
48E0:  MOVWF  xE3
....................          break; 
48E2:  MOVLB  0
48E4:  BRA    4952
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
48E6:  MOVLB  7
48E8:  MOVF   xDF,W
48EA:  SUBLW  1F
48EC:  BC    4954
48EE:  MOVF   xDF,W
48F0:  SUBLW  7E
48F2:  BNC   4954
48F4:  MOVLW  01
48F6:  SUBWF  xDC,W
48F8:  MOVF   xE2,F
48FA:  BNZ   4954
48FC:  SUBWF  xE1,W
48FE:  BC    4954
....................             { 
....................                chaine[nbcar]=c; 
4900:  MOVF   xDD,W
4902:  ADDWF  xE1,W
4904:  MOVWF  FE9
4906:  MOVF   xDE,W
4908:  ADDWFC xE2,W
490A:  MOVWF  FEA
490C:  MOVFF  7DF,FEF
....................                nbcar++; 
4910:  INCF   xE1,F
4912:  BTFSC  FD8.2
4914:  INCF   xE2,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
4916:  DECFSZ xDB,W
4918:  BRA    4934
491A:  CLRF   19
491C:  BTFSC  FF2.7
491E:  BSF    19.7
4920:  BCF    FF2.7
4922:  MOVFF  7DF,830
4926:  MOVLB  0
4928:  CALL   0422
492C:  BTFSC  19.7
492E:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
4930:  BRA    4952
4932:  MOVLB  7
4934:  MOVF   xDB,W
4936:  SUBLW  02
4938:  BNZ   4954
493A:  CLRF   19
493C:  BTFSC  FF2.7
493E:  BSF    19.7
4940:  BCF    FF2.7
4942:  MOVLW  2A
4944:  MOVLB  8
4946:  MOVWF  x30
4948:  MOVLB  0
494A:  CALL   0422
494E:  BTFSC  19.7
4950:  BSF    FF2.7
4952:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
4954:  BRA    482E
....................    return(nbcar); 
4956:  MOVFF  7E1,01
.................... } 
495A:  MOVLB  0
495C:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
495E:  MOVFF  7DC,7E0
4962:  MOVFF  7DB,7DF
4966:  MOVFF  7DE,7E2
496A:  MOVFF  7DD,7E1
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
496E:  MOVFF  7E0,03
4972:  MOVLB  7
4974:  MOVFF  7DF,FE9
4978:  MOVFF  7E0,FEA
497C:  MOVF   FEF,F
497E:  BZ    49C6
4980:  MOVFF  7E2,03
4984:  MOVFF  7E1,FE9
4988:  MOVFF  7E2,FEA
498C:  MOVF   FEF,F
498E:  BZ    49C6
....................       if(*aa!=*bb) 
4990:  MOVFF  7DF,FE9
4994:  MOVFF  7E0,FEA
4998:  MOVFF  FEF,7E3
499C:  MOVFF  7E2,03
49A0:  MOVFF  7E1,FE9
49A4:  MOVFF  7E2,FEA
49A8:  MOVF   FEF,W
49AA:  SUBWF  xE3,W
49AC:  BZ    49B4
....................          return(1); 
49AE:  MOVLW  01
49B0:  MOVWF  01
49B2:  BRA    49F2
....................       aa++; 
49B4:  INCF   xDF,F
49B6:  BTFSC  FD8.2
49B8:  INCF   xE0,F
....................       bb++; 
49BA:  INCF   xE1,F
49BC:  BTFSC  FD8.2
49BE:  INCF   xE2,F
....................    } 
49C0:  MOVLB  0
49C2:  BRA    496E
49C4:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
49C6:  MOVFF  7E0,03
49CA:  MOVFF  7DF,FE9
49CE:  MOVFF  7E0,FEA
49D2:  MOVFF  FEF,7E3
49D6:  MOVFF  7E2,03
49DA:  MOVFF  7E1,FE9
49DE:  MOVFF  7E2,FEA
49E2:  MOVF   FEF,W
49E4:  SUBWF  xE3,W
49E6:  BZ    49EE
49E8:  MOVLW  01
49EA:  MOVWF  01
49EC:  BRA    49F2
....................    return(0); 
49EE:  MOVLW  00
49F0:  MOVWF  01
.................... } 
49F2:  MOVLB  0
49F4:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
4F3C:  MOVLB  7
4F3E:  CLRF   xDD
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
4F40:  MOVFF  7DC,03
4F44:  MOVF   xDB,W
4F46:  INCF   xDB,F
4F48:  BTFSC  FD8.2
4F4A:  INCF   xDC,F
4F4C:  MOVWF  FE9
4F4E:  MOVFF  03,FEA
4F52:  MOVFF  FEF,7DF
4F56:  MOVF   xDF,F
4F58:  BZ    4F7C
....................         if (c >= '0' && c <= '9') 
4F5A:  MOVF   xDF,W
4F5C:  SUBLW  2F
4F5E:  BC    4F6E
4F60:  MOVF   xDF,W
4F62:  SUBLW  39
4F64:  BNC   4F6E
....................             digit = (unsigned int) (c - '0'); 
4F66:  MOVLW  30
4F68:  SUBWF  xDF,W
4F6A:  MOVWF  xDE
....................         else 
4F6C:  BRA    4F70
....................             break; 
4F6E:  BRA    4F7C
....................  
....................         val = (val * 10) + digit; 
4F70:  MOVF   xDD,W
4F72:  MULLW  0A
4F74:  MOVF   FF3,W
4F76:  ADDWF  xDE,W
4F78:  MOVWF  xDD
....................     } 
4F7A:  BRA    4F40
....................  
....................     return val; 
4F7C:  CLRF   03
4F7E:  MOVFF  7DD,01
4F82:  MOVFF  03,02
.................... } 
4F86:  MOVLB  0
4F88:  RETURN 0
....................  
.................... int8 receiver_state=0,booting_done=0; 
.................... int16 over_byte=0; 
.................... //#include <GSM.c>  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
0494:  MOVLB  8
0496:  CLRF   x40
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
0498:  CLRF   x41
049A:  BTFSC  x38.0
049C:  BSF    x41.7
049E:  SWAPF  x39,W
04A0:  MOVWF  00
04A2:  RLCF   00,F
04A4:  RLCF   00,F
04A6:  MOVLW  C0
04A8:  ANDWF  00,F
04AA:  MOVF   00,W
04AC:  IORWF  x41,F
04AE:  SWAPF  x3A,W
04B0:  MOVWF  00
04B2:  RLCF   00,F
04B4:  MOVLW  E0
04B6:  ANDWF  00,F
04B8:  MOVF   00,W
04BA:  IORWF  x41,F
04BC:  SWAPF  x3B,W
04BE:  MOVWF  00
04C0:  MOVLW  F0
04C2:  ANDWF  00,F
04C4:  MOVF   00,W
04C6:  IORWF  x41,F
04C8:  RLCF   x3C,W
04CA:  MOVWF  00
04CC:  RLCF   00,F
04CE:  RLCF   00,F
04D0:  MOVLW  F8
04D2:  ANDWF  00,F
04D4:  MOVF   00,W
04D6:  IORWF  x41,F
04D8:  RLCF   x3D,W
04DA:  MOVWF  00
04DC:  RLCF   00,F
04DE:  MOVLW  FC
04E0:  ANDWF  00,F
04E2:  MOVF   00,W
04E4:  IORWF  x41,F
04E6:  BCF    FD8.0
04E8:  RLCF   x3E,W
04EA:  IORWF  x41,F
04EC:  MOVF   x3F,W
04EE:  IORWF  x41,W
04F0:  MOVWF  x40
....................    return temp; 
04F2:  MOVFF  840,01
.................... } 
04F6:  MOVLB  0
04F8:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
04FA:  MOVLB  8
04FC:  CLRF   x28
....................    int8 temp=0; 
....................    if(direct==0) 
04FE:  MOVF   x23,F
0500:  BNZ   05D6
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
0502:  MOVF   x26,W
0504:  ADDWF  x24,W
0506:  MOVWF  FE9
0508:  MOVF   x27,W
050A:  ADDWFC x25,W
050C:  MOVWF  FEA
050E:  MOVFF  FEF,829
0512:  MOVLW  01
0514:  ADDWF  x24,W
0516:  MOVWF  x2A
0518:  MOVLW  00
051A:  ADDWFC x25,W
051C:  MOVWF  x2B
051E:  MOVF   x26,W
0520:  ADDWF  x2A,W
0522:  MOVWF  FE9
0524:  MOVF   x27,W
0526:  ADDWFC x2B,W
0528:  MOVWF  FEA
052A:  MOVF   FEF,W
052C:  XORWF  x29,F
052E:  MOVLW  02
0530:  ADDWF  x24,W
0532:  MOVWF  x2C
0534:  MOVLW  00
0536:  ADDWFC x25,W
0538:  MOVWF  x2D
053A:  MOVF   x26,W
053C:  ADDWF  x2C,W
053E:  MOVWF  FE9
0540:  MOVF   x27,W
0542:  ADDWFC x2D,W
0544:  MOVWF  FEA
0546:  MOVF   FEF,W
0548:  XORWF  x29,F
054A:  MOVLW  03
054C:  ADDWF  x24,W
054E:  MOVWF  x2E
0550:  MOVLW  00
0552:  ADDWFC x25,W
0554:  MOVWF  x2F
0556:  MOVF   x26,W
0558:  ADDWF  x2E,W
055A:  MOVWF  FE9
055C:  MOVF   x27,W
055E:  ADDWFC x2F,W
0560:  MOVWF  FEA
0562:  MOVF   FEF,W
0564:  XORWF  x29,F
0566:  MOVLW  04
0568:  ADDWF  x24,W
056A:  MOVWF  x30
056C:  MOVLW  00
056E:  ADDWFC x25,W
0570:  MOVWF  x31
0572:  MOVF   x26,W
0574:  ADDWF  x30,W
0576:  MOVWF  FE9
0578:  MOVF   x27,W
057A:  ADDWFC x31,W
057C:  MOVWF  FEA
057E:  MOVF   FEF,W
0580:  XORWF  x29,F
0582:  MOVLW  05
0584:  ADDWF  x24,W
0586:  MOVWF  x32
0588:  MOVLW  00
058A:  ADDWFC x25,W
058C:  MOVWF  x33
058E:  MOVF   x26,W
0590:  ADDWF  x32,W
0592:  MOVWF  FE9
0594:  MOVF   x27,W
0596:  ADDWFC x33,W
0598:  MOVWF  FEA
059A:  MOVF   FEF,W
059C:  XORWF  x29,W
059E:  BZ    05A4
05A0:  MOVLW  00
05A2:  BRA    05A6
05A4:  MOVLW  01
05A6:  MOVWF  x28
....................       if(temp==datain[offset+6]) return 1; 
05A8:  MOVLW  06
05AA:  ADDWF  x24,W
05AC:  MOVWF  x29
05AE:  MOVLW  00
05B0:  ADDWFC x25,W
05B2:  MOVWF  x2A
05B4:  MOVF   x26,W
05B6:  ADDWF  x29,W
05B8:  MOVWF  FE9
05BA:  MOVF   x27,W
05BC:  ADDWFC x2A,W
05BE:  MOVWF  FEA
05C0:  MOVF   FEF,W
05C2:  SUBWF  x28,W
05C4:  BNZ   05CE
05C6:  MOVLW  01
05C8:  MOVWF  01
05CA:  BRA    06A6
....................          else return 0; 
05CC:  BRA    05D4
05CE:  MOVLW  00
05D0:  MOVWF  01
05D2:  BRA    06A6
....................    } 
....................       else  
05D4:  BRA    06A6
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
05D6:  MOVF   x26,W
05D8:  ADDWF  x24,W
05DA:  MOVWF  FE9
05DC:  MOVF   x27,W
05DE:  ADDWFC x25,W
05E0:  MOVWF  FEA
05E2:  MOVFF  FEF,829
05E6:  MOVLW  01
05E8:  SUBWF  x24,W
05EA:  MOVWF  x2A
05EC:  MOVLW  00
05EE:  SUBWFB x25,W
05F0:  MOVWF  x2B
05F2:  MOVF   x26,W
05F4:  ADDWF  x2A,W
05F6:  MOVWF  FE9
05F8:  MOVF   x27,W
05FA:  ADDWFC x2B,W
05FC:  MOVWF  FEA
05FE:  MOVF   FEF,W
0600:  XORWF  x29,F
0602:  MOVLW  02
0604:  SUBWF  x24,W
0606:  MOVWF  x2C
0608:  MOVLW  00
060A:  SUBWFB x25,W
060C:  MOVWF  x2D
060E:  MOVF   x26,W
0610:  ADDWF  x2C,W
0612:  MOVWF  FE9
0614:  MOVF   x27,W
0616:  ADDWFC x2D,W
0618:  MOVWF  FEA
061A:  MOVF   FEF,W
061C:  XORWF  x29,F
061E:  MOVLW  03
0620:  SUBWF  x24,W
0622:  MOVWF  x2E
0624:  MOVLW  00
0626:  SUBWFB x25,W
0628:  MOVWF  x2F
062A:  MOVF   x26,W
062C:  ADDWF  x2E,W
062E:  MOVWF  FE9
0630:  MOVF   x27,W
0632:  ADDWFC x2F,W
0634:  MOVWF  FEA
0636:  MOVF   FEF,W
0638:  XORWF  x29,F
063A:  MOVLW  04
063C:  SUBWF  x24,W
063E:  MOVWF  x30
0640:  MOVLW  00
0642:  SUBWFB x25,W
0644:  MOVWF  x31
0646:  MOVF   x26,W
0648:  ADDWF  x30,W
064A:  MOVWF  FE9
064C:  MOVF   x27,W
064E:  ADDWFC x31,W
0650:  MOVWF  FEA
0652:  MOVF   FEF,W
0654:  XORWF  x29,F
0656:  MOVLW  05
0658:  SUBWF  x24,W
065A:  MOVWF  x32
065C:  MOVLW  00
065E:  SUBWFB x25,W
0660:  MOVWF  x33
0662:  MOVF   x26,W
0664:  ADDWF  x32,W
0666:  MOVWF  FE9
0668:  MOVF   x27,W
066A:  ADDWFC x33,W
066C:  MOVWF  FEA
066E:  MOVF   FEF,W
0670:  XORWF  x29,W
0672:  BZ    0678
0674:  MOVLW  00
0676:  BRA    067A
0678:  MOVLW  01
067A:  MOVWF  x28
....................          if(temp==datain[offset-6]) return 1; 
067C:  MOVLW  06
067E:  SUBWF  x24,W
0680:  MOVWF  x29
0682:  MOVLW  00
0684:  SUBWFB x25,W
0686:  MOVWF  x2A
0688:  MOVF   x26,W
068A:  ADDWF  x29,W
068C:  MOVWF  FE9
068E:  MOVF   x27,W
0690:  ADDWFC x2A,W
0692:  MOVWF  FEA
0694:  MOVF   FEF,W
0696:  SUBWF  x28,W
0698:  BNZ   06A2
069A:  MOVLW  01
069C:  MOVWF  01
069E:  BRA    06A6
....................             else return 0;          
06A0:  BRA    06A6
06A2:  MOVLW  00
06A4:  MOVWF  01
....................       } 
.................... } 
06A6:  MOVLB  0
06A8:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
06AA:  MOVLB  8
06AC:  CLRF   x28
....................    int8 temp=0; 
....................    if(direct==0) 
06AE:  MOVF   x23,F
06B0:  BNZ   074E
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
06B2:  MOVF   x26,W
06B4:  ADDWF  x24,W
06B6:  MOVWF  FE9
06B8:  MOVF   x27,W
06BA:  ADDWFC x25,W
06BC:  MOVWF  FEA
06BE:  MOVFF  FEF,829
06C2:  MOVLW  01
06C4:  ADDWF  x24,W
06C6:  MOVWF  x2A
06C8:  MOVLW  00
06CA:  ADDWFC x25,W
06CC:  MOVWF  x2B
06CE:  MOVF   x26,W
06D0:  ADDWF  x2A,W
06D2:  MOVWF  FE9
06D4:  MOVF   x27,W
06D6:  ADDWFC x2B,W
06D8:  MOVWF  FEA
06DA:  MOVF   FEF,W
06DC:  XORWF  x29,F
06DE:  MOVLW  02
06E0:  ADDWF  x24,W
06E2:  MOVWF  x2C
06E4:  MOVLW  00
06E6:  ADDWFC x25,W
06E8:  MOVWF  x2D
06EA:  MOVF   x26,W
06EC:  ADDWF  x2C,W
06EE:  MOVWF  FE9
06F0:  MOVF   x27,W
06F2:  ADDWFC x2D,W
06F4:  MOVWF  FEA
06F6:  MOVF   FEF,W
06F8:  XORWF  x29,F
06FA:  MOVLW  03
06FC:  ADDWF  x24,W
06FE:  MOVWF  x2E
0700:  MOVLW  00
0702:  ADDWFC x25,W
0704:  MOVWF  x2F
0706:  MOVF   x26,W
0708:  ADDWF  x2E,W
070A:  MOVWF  FE9
070C:  MOVF   x27,W
070E:  ADDWFC x2F,W
0710:  MOVWF  FEA
0712:  MOVF   FEF,W
0714:  XORWF  x29,W
0716:  BZ    071C
0718:  MOVLW  00
071A:  BRA    071E
071C:  MOVLW  01
071E:  MOVWF  x28
....................       if(temp==datain[offset+4]) return 1; 
0720:  MOVLW  04
0722:  ADDWF  x24,W
0724:  MOVWF  x29
0726:  MOVLW  00
0728:  ADDWFC x25,W
072A:  MOVWF  x2A
072C:  MOVF   x26,W
072E:  ADDWF  x29,W
0730:  MOVWF  FE9
0732:  MOVF   x27,W
0734:  ADDWFC x2A,W
0736:  MOVWF  FEA
0738:  MOVF   FEF,W
073A:  SUBWF  x28,W
073C:  BNZ   0746
073E:  MOVLW  01
0740:  MOVWF  01
0742:  BRA    07E6
....................          else return 0; 
0744:  BRA    074C
0746:  MOVLW  00
0748:  MOVWF  01
074A:  BRA    07E6
....................    } 
....................    else 
074C:  BRA    07E6
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
074E:  MOVF   x26,W
0750:  ADDWF  x24,W
0752:  MOVWF  FE9
0754:  MOVF   x27,W
0756:  ADDWFC x25,W
0758:  MOVWF  FEA
075A:  MOVFF  FEF,829
075E:  MOVLW  01
0760:  SUBWF  x24,W
0762:  MOVWF  x2A
0764:  MOVLW  00
0766:  SUBWFB x25,W
0768:  MOVWF  x2B
076A:  MOVF   x26,W
076C:  ADDWF  x2A,W
076E:  MOVWF  FE9
0770:  MOVF   x27,W
0772:  ADDWFC x2B,W
0774:  MOVWF  FEA
0776:  MOVF   FEF,W
0778:  XORWF  x29,F
077A:  MOVLW  02
077C:  SUBWF  x24,W
077E:  MOVWF  x2C
0780:  MOVLW  00
0782:  SUBWFB x25,W
0784:  MOVWF  x2D
0786:  MOVF   x26,W
0788:  ADDWF  x2C,W
078A:  MOVWF  FE9
078C:  MOVF   x27,W
078E:  ADDWFC x2D,W
0790:  MOVWF  FEA
0792:  MOVF   FEF,W
0794:  XORWF  x29,F
0796:  MOVLW  03
0798:  SUBWF  x24,W
079A:  MOVWF  x2E
079C:  MOVLW  00
079E:  SUBWFB x25,W
07A0:  MOVWF  x2F
07A2:  MOVF   x26,W
07A4:  ADDWF  x2E,W
07A6:  MOVWF  FE9
07A8:  MOVF   x27,W
07AA:  ADDWFC x2F,W
07AC:  MOVWF  FEA
07AE:  MOVF   FEF,W
07B0:  XORWF  x29,W
07B2:  BZ    07B8
07B4:  MOVLW  00
07B6:  BRA    07BA
07B8:  MOVLW  01
07BA:  MOVWF  x28
....................       if(temp==datain[offset-4]) return 1; 
07BC:  MOVLW  04
07BE:  SUBWF  x24,W
07C0:  MOVWF  x29
07C2:  MOVLW  00
07C4:  SUBWFB x25,W
07C6:  MOVWF  x2A
07C8:  MOVF   x26,W
07CA:  ADDWF  x29,W
07CC:  MOVWF  FE9
07CE:  MOVF   x27,W
07D0:  ADDWFC x2A,W
07D2:  MOVWF  FEA
07D4:  MOVF   FEF,W
07D6:  SUBWF  x28,W
07D8:  BNZ   07E2
07DA:  MOVLW  01
07DC:  MOVWF  01
07DE:  BRA    07E6
....................          else return 0;                
07E0:  BRA    07E6
07E2:  MOVLW  00
07E4:  MOVWF  01
....................    } 
.................... } 
07E6:  MOVLB  0
07E8:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
07EA:  MOVLB  8
07EC:  CLRF   x1F
07EE:  CLRF   x20
07F0:  CLRF   x21
07F2:  CLRF   x22
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
07F4:  CLRF   x1C
07F6:  CLRF   x1B
07F8:  RRCF   x18,W
07FA:  MOVWF  03
07FC:  RRCF   x17,W
07FE:  MOVWF  02
0800:  RRCF   03,F
0802:  RRCF   02,F
0804:  MOVLW  3F
0806:  ANDWF  03,F
0808:  MOVFF  02,01
080C:  MOVF   x1C,W
080E:  SUBWF  03,W
0810:  BTFSS  FD8.0
0812:  BRA    0DD2
0814:  BNZ   081E
0816:  MOVF   01,W
0818:  SUBWF  x1B,W
081A:  BTFSC  FD8.0
081C:  BRA    0DD2
....................    { 
....................       if(track==0) 
081E:  MOVF   x16,F
0820:  BTFSS  FD8.2
0822:  BRA    0B58
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0824:  MOVLW  06
0826:  ADDWF  x1B,W
0828:  MOVWF  x23
082A:  MOVLW  00
082C:  ADDWFC x1C,W
082E:  MOVWF  x24
0830:  MOVF   x19,W
0832:  ADDWF  x23,W
0834:  MOVWF  FE9
0836:  MOVF   x1A,W
0838:  ADDWFC x24,W
083A:  MOVWF  FEA
083C:  MOVFF  FEF,825
0840:  MOVLW  05
0842:  ADDWF  x1B,W
0844:  MOVWF  x26
0846:  MOVLW  00
0848:  ADDWFC x1C,W
084A:  MOVWF  x27
084C:  MOVF   x19,W
084E:  ADDWF  x26,W
0850:  MOVWF  FE9
0852:  MOVF   x1A,W
0854:  ADDWFC x27,W
0856:  MOVWF  FEA
0858:  MOVFF  FEF,828
085C:  MOVLW  04
085E:  ADDWF  x1B,W
0860:  MOVWF  x29
0862:  MOVLW  00
0864:  ADDWFC x1C,W
0866:  MOVWF  x2A
0868:  MOVF   x19,W
086A:  ADDWF  x29,W
086C:  MOVWF  FE9
086E:  MOVF   x1A,W
0870:  ADDWFC x2A,W
0872:  MOVWF  FEA
0874:  MOVFF  FEF,82B
0878:  MOVLW  03
087A:  ADDWF  x1B,W
087C:  MOVWF  x2C
087E:  MOVLW  00
0880:  ADDWFC x1C,W
0882:  MOVWF  x2D
0884:  MOVF   x19,W
0886:  ADDWF  x2C,W
0888:  MOVWF  FE9
088A:  MOVF   x1A,W
088C:  ADDWFC x2D,W
088E:  MOVWF  FEA
0890:  MOVFF  FEF,82E
0894:  MOVLW  02
0896:  ADDWF  x1B,W
0898:  MOVWF  x2F
089A:  MOVLW  00
089C:  ADDWFC x1C,W
089E:  MOVWF  x30
08A0:  MOVF   x19,W
08A2:  ADDWF  x2F,W
08A4:  MOVWF  FE9
08A6:  MOVF   x1A,W
08A8:  ADDWFC x30,W
08AA:  MOVWF  FEA
08AC:  MOVFF  FEF,831
08B0:  MOVLW  01
08B2:  ADDWF  x1B,W
08B4:  MOVWF  x32
08B6:  MOVLW  00
08B8:  ADDWFC x1C,W
08BA:  MOVWF  x33
08BC:  MOVF   x19,W
08BE:  ADDWF  x32,W
08C0:  MOVWF  FE9
08C2:  MOVF   x1A,W
08C4:  ADDWFC x33,W
08C6:  MOVWF  FEA
08C8:  MOVFF  FEF,834
08CC:  MOVF   x19,W
08CE:  ADDWF  x1B,W
08D0:  MOVWF  FE9
08D2:  MOVF   x1A,W
08D4:  ADDWFC x1C,W
08D6:  MOVWF  FEA
08D8:  MOVFF  FEF,835
08DC:  CLRF   x38
08DE:  MOVFF  825,839
08E2:  MOVFF  828,83A
08E6:  MOVFF  82B,83B
08EA:  MOVFF  82E,83C
08EE:  MOVFF  831,83D
08F2:  MOVFF  834,83E
08F6:  MOVFF  835,83F
08FA:  MOVLB  0
08FC:  RCALL  0494
08FE:  MOVFF  01,81F
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0902:  MOVLW  0D
0904:  MOVLB  8
0906:  ADDWF  x1B,W
0908:  MOVWF  x23
090A:  MOVLW  00
090C:  ADDWFC x1C,W
090E:  MOVWF  x24
0910:  MOVF   x19,W
0912:  ADDWF  x23,W
0914:  MOVWF  FE9
0916:  MOVF   x1A,W
0918:  ADDWFC x24,W
091A:  MOVWF  FEA
091C:  MOVFF  FEF,825
0920:  MOVLW  0C
0922:  ADDWF  x1B,W
0924:  MOVWF  x26
0926:  MOVLW  00
0928:  ADDWFC x1C,W
092A:  MOVWF  x27
092C:  MOVF   x19,W
092E:  ADDWF  x26,W
0930:  MOVWF  FE9
0932:  MOVF   x1A,W
0934:  ADDWFC x27,W
0936:  MOVWF  FEA
0938:  MOVFF  FEF,828
093C:  MOVLW  0B
093E:  ADDWF  x1B,W
0940:  MOVWF  x29
0942:  MOVLW  00
0944:  ADDWFC x1C,W
0946:  MOVWF  x2A
0948:  MOVF   x19,W
094A:  ADDWF  x29,W
094C:  MOVWF  FE9
094E:  MOVF   x1A,W
0950:  ADDWFC x2A,W
0952:  MOVWF  FEA
0954:  MOVFF  FEF,82B
0958:  MOVLW  0A
095A:  ADDWF  x1B,W
095C:  MOVWF  x2C
095E:  MOVLW  00
0960:  ADDWFC x1C,W
0962:  MOVWF  x2D
0964:  MOVF   x19,W
0966:  ADDWF  x2C,W
0968:  MOVWF  FE9
096A:  MOVF   x1A,W
096C:  ADDWFC x2D,W
096E:  MOVWF  FEA
0970:  MOVFF  FEF,82E
0974:  MOVLW  09
0976:  ADDWF  x1B,W
0978:  MOVWF  x2F
097A:  MOVLW  00
097C:  ADDWFC x1C,W
097E:  MOVWF  x30
0980:  MOVF   x19,W
0982:  ADDWF  x2F,W
0984:  MOVWF  FE9
0986:  MOVF   x1A,W
0988:  ADDWFC x30,W
098A:  MOVWF  FEA
098C:  MOVFF  FEF,831
0990:  MOVLW  08
0992:  ADDWF  x1B,W
0994:  MOVWF  x32
0996:  MOVLW  00
0998:  ADDWFC x1C,W
099A:  MOVWF  x33
099C:  MOVF   x19,W
099E:  ADDWF  x32,W
09A0:  MOVWF  FE9
09A2:  MOVF   x1A,W
09A4:  ADDWFC x33,W
09A6:  MOVWF  FEA
09A8:  MOVFF  FEF,834
09AC:  MOVLW  07
09AE:  ADDWF  x1B,W
09B0:  MOVWF  x35
09B2:  MOVLW  00
09B4:  ADDWFC x1C,W
09B6:  MOVWF  x36
09B8:  MOVF   x19,W
09BA:  ADDWF  x35,W
09BC:  MOVWF  FE9
09BE:  MOVF   x1A,W
09C0:  ADDWFC x36,W
09C2:  MOVWF  FEA
09C4:  MOVFF  FEF,837
09C8:  CLRF   x38
09CA:  MOVFF  825,839
09CE:  MOVFF  828,83A
09D2:  MOVFF  82B,83B
09D6:  MOVFF  82E,83C
09DA:  MOVFF  831,83D
09DE:  MOVFF  834,83E
09E2:  MOVFF  837,83F
09E6:  MOVLB  0
09E8:  RCALL  0494
09EA:  MOVFF  01,820
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
09EE:  MOVLB  8
09F0:  MOVF   x1F,W
09F2:  SUBLW  45
09F4:  BTFSS  FD8.2
09F6:  BRA    0B56
09F8:  MOVF   x20,W
09FA:  SUBLW  7C
09FC:  BTFSC  FD8.2
09FE:  BRA    0B56
0A00:  MOVF   x20,W
0A02:  SUBLW  3E
0A04:  BTFSC  FD8.2
0A06:  BRA    0B56
0A08:  MOVF   x20,W
0A0A:  SUBLW  1F
0A0C:  BTFSC  FD8.2
0A0E:  BRA    0B56
....................          { 
....................             j=i; 
0A10:  MOVFF  81C,81E
0A14:  MOVFF  81B,81D
....................             CRC=1; 
0A18:  MOVLW  01
0A1A:  MOVWF  x22
....................             temp2=temp; 
0A1C:  MOVFF  81F,821
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0A20:  MOVF   x21,W
0A22:  SUBLW  1F
0A24:  BTFSC  FD8.2
0A26:  BRA    0B40
0A28:  MOVF   x1E,W
0A2A:  SUBLW  03
0A2C:  BTFSS  FD8.0
0A2E:  BRA    0B40
0A30:  BNZ   0A3A
0A32:  MOVF   x1D,W
0A34:  SUBLW  E7
0A36:  BTFSS  FD8.0
0A38:  BRA    0B40
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0A3A:  CLRF   x23
0A3C:  MOVFF  81E,825
0A40:  MOVFF  81D,824
0A44:  MOVFF  81A,827
0A48:  MOVFF  819,826
0A4C:  MOVLB  0
0A4E:  RCALL  04FA
0A50:  MOVF   01,W
0A52:  MOVLB  8
0A54:  ANDWF  x22,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0A56:  MOVLW  06
0A58:  ADDWF  x1D,W
0A5A:  MOVWF  x23
0A5C:  MOVLW  00
0A5E:  ADDWFC x1E,W
0A60:  MOVWF  x24
0A62:  MOVF   x19,W
0A64:  ADDWF  x23,W
0A66:  MOVWF  FE9
0A68:  MOVF   x1A,W
0A6A:  ADDWFC x24,W
0A6C:  MOVWF  FEA
0A6E:  MOVFF  FEF,825
0A72:  MOVLW  05
0A74:  ADDWF  x1D,W
0A76:  MOVWF  x26
0A78:  MOVLW  00
0A7A:  ADDWFC x1E,W
0A7C:  MOVWF  x27
0A7E:  MOVF   x19,W
0A80:  ADDWF  x26,W
0A82:  MOVWF  FE9
0A84:  MOVF   x1A,W
0A86:  ADDWFC x27,W
0A88:  MOVWF  FEA
0A8A:  MOVFF  FEF,828
0A8E:  MOVLW  04
0A90:  ADDWF  x1D,W
0A92:  MOVWF  x29
0A94:  MOVLW  00
0A96:  ADDWFC x1E,W
0A98:  MOVWF  x2A
0A9A:  MOVF   x19,W
0A9C:  ADDWF  x29,W
0A9E:  MOVWF  FE9
0AA0:  MOVF   x1A,W
0AA2:  ADDWFC x2A,W
0AA4:  MOVWF  FEA
0AA6:  MOVFF  FEF,82B
0AAA:  MOVLW  03
0AAC:  ADDWF  x1D,W
0AAE:  MOVWF  x2C
0AB0:  MOVLW  00
0AB2:  ADDWFC x1E,W
0AB4:  MOVWF  x2D
0AB6:  MOVF   x19,W
0AB8:  ADDWF  x2C,W
0ABA:  MOVWF  FE9
0ABC:  MOVF   x1A,W
0ABE:  ADDWFC x2D,W
0AC0:  MOVWF  FEA
0AC2:  MOVFF  FEF,82E
0AC6:  MOVLW  02
0AC8:  ADDWF  x1D,W
0ACA:  MOVWF  x2F
0ACC:  MOVLW  00
0ACE:  ADDWFC x1E,W
0AD0:  MOVWF  x30
0AD2:  MOVF   x19,W
0AD4:  ADDWF  x2F,W
0AD6:  MOVWF  FE9
0AD8:  MOVF   x1A,W
0ADA:  ADDWFC x30,W
0ADC:  MOVWF  FEA
0ADE:  MOVFF  FEF,831
0AE2:  MOVLW  01
0AE4:  ADDWF  x1D,W
0AE6:  MOVWF  x32
0AE8:  MOVLW  00
0AEA:  ADDWFC x1E,W
0AEC:  MOVWF  x33
0AEE:  MOVF   x19,W
0AF0:  ADDWF  x32,W
0AF2:  MOVWF  FE9
0AF4:  MOVF   x1A,W
0AF6:  ADDWFC x33,W
0AF8:  MOVWF  FEA
0AFA:  MOVFF  FEF,834
0AFE:  MOVF   x19,W
0B00:  ADDWF  x1D,W
0B02:  MOVWF  FE9
0B04:  MOVF   x1A,W
0B06:  ADDWFC x1E,W
0B08:  MOVWF  FEA
0B0A:  MOVFF  FEF,835
0B0E:  CLRF   x38
0B10:  MOVFF  825,839
0B14:  MOVFF  828,83A
0B18:  MOVFF  82B,83B
0B1C:  MOVFF  82E,83C
0B20:  MOVFF  831,83D
0B24:  MOVFF  834,83E
0B28:  MOVFF  835,83F
0B2C:  MOVLB  0
0B2E:  RCALL  0494
0B30:  MOVFF  01,821
....................                j=j+7; 
0B34:  MOVLW  07
0B36:  MOVLB  8
0B38:  ADDWF  x1D,F
0B3A:  MOVLW  00
0B3C:  ADDWFC x1E,F
....................             } 
0B3E:  BRA    0A20
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0B40:  DECFSZ x22,W
0B42:  BRA    0B56
....................             { 
....................                dir=0; 
0B44:  MOVLB  6
0B46:  CLRF   xB0
....................                return i; 
0B48:  MOVLB  8
0B4A:  MOVFF  81B,01
0B4E:  MOVFF  81C,02
0B52:  GOTO   13E8
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0B56:  BRA    0DCA
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0B58:  MOVLW  04
0B5A:  ADDWF  x1B,W
0B5C:  MOVWF  x23
0B5E:  MOVLW  00
0B60:  ADDWFC x1C,W
0B62:  MOVWF  x24
0B64:  MOVF   x19,W
0B66:  ADDWF  x23,W
0B68:  MOVWF  FE9
0B6A:  MOVF   x1A,W
0B6C:  ADDWFC x24,W
0B6E:  MOVWF  FEA
0B70:  MOVFF  FEF,825
0B74:  MOVLW  03
0B76:  ADDWF  x1B,W
0B78:  MOVWF  x26
0B7A:  MOVLW  00
0B7C:  ADDWFC x1C,W
0B7E:  MOVWF  x27
0B80:  MOVF   x19,W
0B82:  ADDWF  x26,W
0B84:  MOVWF  FE9
0B86:  MOVF   x1A,W
0B88:  ADDWFC x27,W
0B8A:  MOVWF  FEA
0B8C:  MOVFF  FEF,828
0B90:  MOVLW  02
0B92:  ADDWF  x1B,W
0B94:  MOVWF  x29
0B96:  MOVLW  00
0B98:  ADDWFC x1C,W
0B9A:  MOVWF  x2A
0B9C:  MOVF   x19,W
0B9E:  ADDWF  x29,W
0BA0:  MOVWF  FE9
0BA2:  MOVF   x1A,W
0BA4:  ADDWFC x2A,W
0BA6:  MOVWF  FEA
0BA8:  MOVFF  FEF,82B
0BAC:  MOVLW  01
0BAE:  ADDWF  x1B,W
0BB0:  MOVWF  x2C
0BB2:  MOVLW  00
0BB4:  ADDWFC x1C,W
0BB6:  MOVWF  x2D
0BB8:  MOVF   x19,W
0BBA:  ADDWF  x2C,W
0BBC:  MOVWF  FE9
0BBE:  MOVF   x1A,W
0BC0:  ADDWFC x2D,W
0BC2:  MOVWF  FEA
0BC4:  MOVFF  FEF,82E
0BC8:  MOVF   x19,W
0BCA:  ADDWF  x1B,W
0BCC:  MOVWF  FE9
0BCE:  MOVF   x1A,W
0BD0:  ADDWFC x1C,W
0BD2:  MOVWF  FEA
0BD4:  MOVFF  FEF,82F
0BD8:  CLRF   x38
0BDA:  CLRF   x39
0BDC:  CLRF   x3A
0BDE:  MOVFF  825,83B
0BE2:  MOVFF  828,83C
0BE6:  MOVFF  82B,83D
0BEA:  MOVFF  82E,83E
0BEE:  MOVFF  82F,83F
0BF2:  MOVLB  0
0BF4:  RCALL  0494
0BF6:  MOVFF  01,81F
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0BFA:  MOVLW  09
0BFC:  MOVLB  8
0BFE:  ADDWF  x1B,W
0C00:  MOVWF  x23
0C02:  MOVLW  00
0C04:  ADDWFC x1C,W
0C06:  MOVWF  x24
0C08:  MOVF   x19,W
0C0A:  ADDWF  x23,W
0C0C:  MOVWF  FE9
0C0E:  MOVF   x1A,W
0C10:  ADDWFC x24,W
0C12:  MOVWF  FEA
0C14:  MOVFF  FEF,825
0C18:  MOVLW  08
0C1A:  ADDWF  x1B,W
0C1C:  MOVWF  x26
0C1E:  MOVLW  00
0C20:  ADDWFC x1C,W
0C22:  MOVWF  x27
0C24:  MOVF   x19,W
0C26:  ADDWF  x26,W
0C28:  MOVWF  FE9
0C2A:  MOVF   x1A,W
0C2C:  ADDWFC x27,W
0C2E:  MOVWF  FEA
0C30:  MOVFF  FEF,828
0C34:  MOVLW  07
0C36:  ADDWF  x1B,W
0C38:  MOVWF  x29
0C3A:  MOVLW  00
0C3C:  ADDWFC x1C,W
0C3E:  MOVWF  x2A
0C40:  MOVF   x19,W
0C42:  ADDWF  x29,W
0C44:  MOVWF  FE9
0C46:  MOVF   x1A,W
0C48:  ADDWFC x2A,W
0C4A:  MOVWF  FEA
0C4C:  MOVFF  FEF,82B
0C50:  MOVLW  06
0C52:  ADDWF  x1B,W
0C54:  MOVWF  x2C
0C56:  MOVLW  00
0C58:  ADDWFC x1C,W
0C5A:  MOVWF  x2D
0C5C:  MOVF   x19,W
0C5E:  ADDWF  x2C,W
0C60:  MOVWF  FE9
0C62:  MOVF   x1A,W
0C64:  ADDWFC x2D,W
0C66:  MOVWF  FEA
0C68:  MOVFF  FEF,82E
0C6C:  MOVLW  05
0C6E:  ADDWF  x1B,W
0C70:  MOVWF  x2F
0C72:  MOVLW  00
0C74:  ADDWFC x1C,W
0C76:  MOVWF  x30
0C78:  MOVF   x19,W
0C7A:  ADDWF  x2F,W
0C7C:  MOVWF  FE9
0C7E:  MOVF   x1A,W
0C80:  ADDWFC x30,W
0C82:  MOVWF  FEA
0C84:  MOVFF  FEF,831
0C88:  CLRF   x38
0C8A:  CLRF   x39
0C8C:  CLRF   x3A
0C8E:  MOVFF  825,83B
0C92:  MOVFF  828,83C
0C96:  MOVFF  82B,83D
0C9A:  MOVFF  82E,83E
0C9E:  MOVFF  831,83F
0CA2:  MOVLB  0
0CA4:  CALL   0494
0CA8:  MOVFF  01,820
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0CAC:  MOVLB  8
0CAE:  MOVF   x1F,W
0CB0:  SUBLW  0B
0CB2:  BTFSS  FD8.2
0CB4:  BRA    0DCA
0CB6:  MOVF   x20,W
0CB8:  SUBLW  1F
0CBA:  BTFSC  FD8.2
0CBC:  BRA    0DCA
0CBE:  MOVF   x20,W
0CC0:  SUBLW  0F
0CC2:  BTFSC  FD8.2
0CC4:  BRA    0DCA
....................             { 
....................                j=i; 
0CC6:  MOVFF  81C,81E
0CCA:  MOVFF  81B,81D
....................                CRC=1; 
0CCE:  MOVLW  01
0CD0:  MOVWF  x22
....................                temp2=temp; 
0CD2:  MOVFF  81F,821
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0CD6:  MOVF   x21,W
0CD8:  SUBLW  1F
0CDA:  BZ    0DB6
0CDC:  MOVF   x1E,W
0CDE:  SUBLW  01
0CE0:  BNC   0DB6
0CE2:  BNZ   0CEA
0CE4:  MOVF   x1D,W
0CE6:  SUBLW  F3
0CE8:  BNC   0DB6
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0CEA:  CLRF   x23
0CEC:  MOVFF  81E,825
0CF0:  MOVFF  81D,824
0CF4:  MOVFF  81A,827
0CF8:  MOVFF  819,826
0CFC:  MOVLB  0
0CFE:  RCALL  06AA
0D00:  MOVF   01,W
0D02:  MOVLB  8
0D04:  ANDWF  x22,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0D06:  MOVLW  04
0D08:  ADDWF  x1D,W
0D0A:  MOVWF  x23
0D0C:  MOVLW  00
0D0E:  ADDWFC x1E,W
0D10:  MOVWF  x24
0D12:  MOVF   x19,W
0D14:  ADDWF  x23,W
0D16:  MOVWF  FE9
0D18:  MOVF   x1A,W
0D1A:  ADDWFC x24,W
0D1C:  MOVWF  FEA
0D1E:  MOVFF  FEF,825
0D22:  MOVLW  03
0D24:  ADDWF  x1D,W
0D26:  MOVWF  x26
0D28:  MOVLW  00
0D2A:  ADDWFC x1E,W
0D2C:  MOVWF  x27
0D2E:  MOVF   x19,W
0D30:  ADDWF  x26,W
0D32:  MOVWF  FE9
0D34:  MOVF   x1A,W
0D36:  ADDWFC x27,W
0D38:  MOVWF  FEA
0D3A:  MOVFF  FEF,828
0D3E:  MOVLW  02
0D40:  ADDWF  x1D,W
0D42:  MOVWF  x29
0D44:  MOVLW  00
0D46:  ADDWFC x1E,W
0D48:  MOVWF  x2A
0D4A:  MOVF   x19,W
0D4C:  ADDWF  x29,W
0D4E:  MOVWF  FE9
0D50:  MOVF   x1A,W
0D52:  ADDWFC x2A,W
0D54:  MOVWF  FEA
0D56:  MOVFF  FEF,82B
0D5A:  MOVLW  01
0D5C:  ADDWF  x1D,W
0D5E:  MOVWF  x2C
0D60:  MOVLW  00
0D62:  ADDWFC x1E,W
0D64:  MOVWF  x2D
0D66:  MOVF   x19,W
0D68:  ADDWF  x2C,W
0D6A:  MOVWF  FE9
0D6C:  MOVF   x1A,W
0D6E:  ADDWFC x2D,W
0D70:  MOVWF  FEA
0D72:  MOVFF  FEF,82E
0D76:  MOVF   x19,W
0D78:  ADDWF  x1D,W
0D7A:  MOVWF  FE9
0D7C:  MOVF   x1A,W
0D7E:  ADDWFC x1E,W
0D80:  MOVWF  FEA
0D82:  MOVFF  FEF,82F
0D86:  CLRF   x38
0D88:  CLRF   x39
0D8A:  CLRF   x3A
0D8C:  MOVFF  825,83B
0D90:  MOVFF  828,83C
0D94:  MOVFF  82B,83D
0D98:  MOVFF  82E,83E
0D9C:  MOVFF  82F,83F
0DA0:  MOVLB  0
0DA2:  CALL   0494
0DA6:  MOVFF  01,821
....................                   j=j+5; 
0DAA:  MOVLW  05
0DAC:  MOVLB  8
0DAE:  ADDWF  x1D,F
0DB0:  MOVLW  00
0DB2:  ADDWFC x1E,F
....................                } 
0DB4:  BRA    0CD6
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0DB6:  DECFSZ x22,W
0DB8:  BRA    0DCA
....................                { 
....................                   dir=0; 
0DBA:  MOVLB  6
0DBC:  CLRF   xB0
....................                   return i; 
0DBE:  MOVLB  8
0DC0:  MOVFF  81B,01
0DC4:  MOVFF  81C,02
0DC8:  BRA    13E8
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0DCA:  INCF   x1B,F
0DCC:  BTFSC  FD8.2
0DCE:  INCF   x1C,F
0DD0:  BRA    07F8
....................    for(i=end_point;i>end_point/4;i--) 
0DD2:  MOVFF  818,81C
0DD6:  MOVFF  817,81B
0DDA:  RRCF   x18,W
0DDC:  MOVWF  03
0DDE:  RRCF   x17,W
0DE0:  MOVWF  02
0DE2:  RRCF   03,F
0DE4:  RRCF   02,F
0DE6:  MOVLW  3F
0DE8:  ANDWF  03,F
0DEA:  MOVFF  02,01
0DEE:  MOVF   03,W
0DF0:  SUBWF  x1C,W
0DF2:  BTFSS  FD8.0
0DF4:  BRA    13E2
0DF6:  BNZ   0E00
0DF8:  MOVF   x1B,W
0DFA:  SUBWF  01,W
0DFC:  BTFSC  FD8.0
0DFE:  BRA    13E2
....................    { 
....................       if(track==0) 
0E00:  MOVF   x16,F
0E02:  BTFSS  FD8.2
0E04:  BRA    1158
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
0E06:  MOVLW  06
0E08:  SUBWF  x1B,W
0E0A:  MOVWF  x23
0E0C:  MOVLW  00
0E0E:  SUBWFB x1C,W
0E10:  MOVWF  x24
0E12:  MOVF   x19,W
0E14:  ADDWF  x23,W
0E16:  MOVWF  FE9
0E18:  MOVF   x1A,W
0E1A:  ADDWFC x24,W
0E1C:  MOVWF  FEA
0E1E:  MOVFF  FEF,825
0E22:  MOVLW  05
0E24:  SUBWF  x1B,W
0E26:  MOVWF  x26
0E28:  MOVLW  00
0E2A:  SUBWFB x1C,W
0E2C:  MOVWF  x27
0E2E:  MOVF   x19,W
0E30:  ADDWF  x26,W
0E32:  MOVWF  FE9
0E34:  MOVF   x1A,W
0E36:  ADDWFC x27,W
0E38:  MOVWF  FEA
0E3A:  MOVFF  FEF,828
0E3E:  MOVLW  04
0E40:  SUBWF  x1B,W
0E42:  MOVWF  x29
0E44:  MOVLW  00
0E46:  SUBWFB x1C,W
0E48:  MOVWF  x2A
0E4A:  MOVF   x19,W
0E4C:  ADDWF  x29,W
0E4E:  MOVWF  FE9
0E50:  MOVF   x1A,W
0E52:  ADDWFC x2A,W
0E54:  MOVWF  FEA
0E56:  MOVFF  FEF,82B
0E5A:  MOVLW  03
0E5C:  SUBWF  x1B,W
0E5E:  MOVWF  x2C
0E60:  MOVLW  00
0E62:  SUBWFB x1C,W
0E64:  MOVWF  x2D
0E66:  MOVF   x19,W
0E68:  ADDWF  x2C,W
0E6A:  MOVWF  FE9
0E6C:  MOVF   x1A,W
0E6E:  ADDWFC x2D,W
0E70:  MOVWF  FEA
0E72:  MOVFF  FEF,82E
0E76:  MOVLW  02
0E78:  SUBWF  x1B,W
0E7A:  MOVWF  x2F
0E7C:  MOVLW  00
0E7E:  SUBWFB x1C,W
0E80:  MOVWF  x30
0E82:  MOVF   x19,W
0E84:  ADDWF  x2F,W
0E86:  MOVWF  FE9
0E88:  MOVF   x1A,W
0E8A:  ADDWFC x30,W
0E8C:  MOVWF  FEA
0E8E:  MOVFF  FEF,831
0E92:  MOVLW  01
0E94:  SUBWF  x1B,W
0E96:  MOVWF  x32
0E98:  MOVLW  00
0E9A:  SUBWFB x1C,W
0E9C:  MOVWF  x33
0E9E:  MOVF   x19,W
0EA0:  ADDWF  x32,W
0EA2:  MOVWF  FE9
0EA4:  MOVF   x1A,W
0EA6:  ADDWFC x33,W
0EA8:  MOVWF  FEA
0EAA:  MOVFF  FEF,834
0EAE:  MOVF   x19,W
0EB0:  ADDWF  x1B,W
0EB2:  MOVWF  FE9
0EB4:  MOVF   x1A,W
0EB6:  ADDWFC x1C,W
0EB8:  MOVWF  FEA
0EBA:  MOVFF  FEF,835
0EBE:  CLRF   x38
0EC0:  MOVFF  825,839
0EC4:  MOVFF  828,83A
0EC8:  MOVFF  82B,83B
0ECC:  MOVFF  82E,83C
0ED0:  MOVFF  831,83D
0ED4:  MOVFF  834,83E
0ED8:  MOVFF  835,83F
0EDC:  MOVLB  0
0EDE:  CALL   0494
0EE2:  MOVFF  01,81F
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
0EE6:  MOVLW  0D
0EE8:  MOVLB  8
0EEA:  SUBWF  x1B,W
0EEC:  MOVWF  x23
0EEE:  MOVLW  00
0EF0:  SUBWFB x1C,W
0EF2:  MOVWF  x24
0EF4:  MOVF   x19,W
0EF6:  ADDWF  x23,W
0EF8:  MOVWF  FE9
0EFA:  MOVF   x1A,W
0EFC:  ADDWFC x24,W
0EFE:  MOVWF  FEA
0F00:  MOVFF  FEF,825
0F04:  MOVLW  0C
0F06:  SUBWF  x1B,W
0F08:  MOVWF  x26
0F0A:  MOVLW  00
0F0C:  SUBWFB x1C,W
0F0E:  MOVWF  x27
0F10:  MOVF   x19,W
0F12:  ADDWF  x26,W
0F14:  MOVWF  FE9
0F16:  MOVF   x1A,W
0F18:  ADDWFC x27,W
0F1A:  MOVWF  FEA
0F1C:  MOVFF  FEF,828
0F20:  MOVLW  0B
0F22:  SUBWF  x1B,W
0F24:  MOVWF  x29
0F26:  MOVLW  00
0F28:  SUBWFB x1C,W
0F2A:  MOVWF  x2A
0F2C:  MOVF   x19,W
0F2E:  ADDWF  x29,W
0F30:  MOVWF  FE9
0F32:  MOVF   x1A,W
0F34:  ADDWFC x2A,W
0F36:  MOVWF  FEA
0F38:  MOVFF  FEF,82B
0F3C:  MOVLW  0A
0F3E:  SUBWF  x1B,W
0F40:  MOVWF  x2C
0F42:  MOVLW  00
0F44:  SUBWFB x1C,W
0F46:  MOVWF  x2D
0F48:  MOVF   x19,W
0F4A:  ADDWF  x2C,W
0F4C:  MOVWF  FE9
0F4E:  MOVF   x1A,W
0F50:  ADDWFC x2D,W
0F52:  MOVWF  FEA
0F54:  MOVFF  FEF,82E
0F58:  MOVLW  09
0F5A:  SUBWF  x1B,W
0F5C:  MOVWF  x2F
0F5E:  MOVLW  00
0F60:  SUBWFB x1C,W
0F62:  MOVWF  x30
0F64:  MOVF   x19,W
0F66:  ADDWF  x2F,W
0F68:  MOVWF  FE9
0F6A:  MOVF   x1A,W
0F6C:  ADDWFC x30,W
0F6E:  MOVWF  FEA
0F70:  MOVFF  FEF,831
0F74:  MOVLW  08
0F76:  SUBWF  x1B,W
0F78:  MOVWF  x32
0F7A:  MOVLW  00
0F7C:  SUBWFB x1C,W
0F7E:  MOVWF  x33
0F80:  MOVF   x19,W
0F82:  ADDWF  x32,W
0F84:  MOVWF  FE9
0F86:  MOVF   x1A,W
0F88:  ADDWFC x33,W
0F8A:  MOVWF  FEA
0F8C:  MOVFF  FEF,834
0F90:  MOVLW  07
0F92:  SUBWF  x1B,W
0F94:  MOVWF  x35
0F96:  MOVLW  00
0F98:  SUBWFB x1C,W
0F9A:  MOVWF  x36
0F9C:  MOVF   x19,W
0F9E:  ADDWF  x35,W
0FA0:  MOVWF  FE9
0FA2:  MOVF   x1A,W
0FA4:  ADDWFC x36,W
0FA6:  MOVWF  FEA
0FA8:  MOVFF  FEF,837
0FAC:  CLRF   x38
0FAE:  MOVFF  825,839
0FB2:  MOVFF  828,83A
0FB6:  MOVFF  82B,83B
0FBA:  MOVFF  82E,83C
0FBE:  MOVFF  831,83D
0FC2:  MOVFF  834,83E
0FC6:  MOVFF  837,83F
0FCA:  MOVLB  0
0FCC:  CALL   0494
0FD0:  MOVFF  01,820
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
0FD4:  MOVLB  8
0FD6:  MOVF   x1F,W
0FD8:  SUBLW  45
0FDA:  BTFSS  FD8.2
0FDC:  BRA    1156
0FDE:  MOVF   x20,W
0FE0:  SUBLW  7C
0FE2:  BTFSC  FD8.2
0FE4:  BRA    1156
0FE6:  MOVF   x20,W
0FE8:  SUBLW  3E
0FEA:  BTFSC  FD8.2
0FEC:  BRA    1156
0FEE:  MOVF   x20,W
0FF0:  SUBLW  1F
0FF2:  BTFSC  FD8.2
0FF4:  BRA    1156
0FF6:  MOVF   x20,W
0FF8:  SUBLW  0F
0FFA:  BTFSC  FD8.2
0FFC:  BRA    1156
0FFE:  MOVF   x20,W
1000:  SUBLW  78
1002:  BTFSC  FD8.2
1004:  BRA    1156
....................          { 
....................             j=i; 
1006:  MOVFF  81C,81E
100A:  MOVFF  81B,81D
....................             CRC=1; 
100E:  MOVLW  01
1010:  MOVWF  x22
....................             temp2=temp; 
1012:  MOVFF  81F,821
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
1016:  MOVF   x21,W
1018:  SUBLW  1F
101A:  BTFSC  FD8.2
101C:  BRA    1136
101E:  MOVF   x1E,F
1020:  BNZ   102A
1022:  MOVF   x1D,W
1024:  SUBLW  01
1026:  BTFSC  FD8.0
1028:  BRA    1136
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
102A:  MOVLW  01
102C:  MOVWF  x23
102E:  MOVFF  81E,825
1032:  MOVFF  81D,824
1036:  MOVFF  81A,827
103A:  MOVFF  819,826
103E:  MOVLB  0
1040:  CALL   04FA
1044:  MOVF   01,W
1046:  MOVLB  8
1048:  ANDWF  x22,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
104A:  MOVLW  06
104C:  SUBWF  x1D,W
104E:  MOVWF  x23
1050:  MOVLW  00
1052:  SUBWFB x1E,W
1054:  MOVWF  x24
1056:  MOVF   x19,W
1058:  ADDWF  x23,W
105A:  MOVWF  FE9
105C:  MOVF   x1A,W
105E:  ADDWFC x24,W
1060:  MOVWF  FEA
1062:  MOVFF  FEF,825
1066:  MOVLW  05
1068:  SUBWF  x1D,W
106A:  MOVWF  x26
106C:  MOVLW  00
106E:  SUBWFB x1E,W
1070:  MOVWF  x27
1072:  MOVF   x19,W
1074:  ADDWF  x26,W
1076:  MOVWF  FE9
1078:  MOVF   x1A,W
107A:  ADDWFC x27,W
107C:  MOVWF  FEA
107E:  MOVFF  FEF,828
1082:  MOVLW  04
1084:  SUBWF  x1D,W
1086:  MOVWF  x29
1088:  MOVLW  00
108A:  SUBWFB x1E,W
108C:  MOVWF  x2A
108E:  MOVF   x19,W
1090:  ADDWF  x29,W
1092:  MOVWF  FE9
1094:  MOVF   x1A,W
1096:  ADDWFC x2A,W
1098:  MOVWF  FEA
109A:  MOVFF  FEF,82B
109E:  MOVLW  03
10A0:  SUBWF  x1D,W
10A2:  MOVWF  x2C
10A4:  MOVLW  00
10A6:  SUBWFB x1E,W
10A8:  MOVWF  x2D
10AA:  MOVF   x19,W
10AC:  ADDWF  x2C,W
10AE:  MOVWF  FE9
10B0:  MOVF   x1A,W
10B2:  ADDWFC x2D,W
10B4:  MOVWF  FEA
10B6:  MOVFF  FEF,82E
10BA:  MOVLW  02
10BC:  SUBWF  x1D,W
10BE:  MOVWF  x2F
10C0:  MOVLW  00
10C2:  SUBWFB x1E,W
10C4:  MOVWF  x30
10C6:  MOVF   x19,W
10C8:  ADDWF  x2F,W
10CA:  MOVWF  FE9
10CC:  MOVF   x1A,W
10CE:  ADDWFC x30,W
10D0:  MOVWF  FEA
10D2:  MOVFF  FEF,831
10D6:  MOVLW  01
10D8:  SUBWF  x1D,W
10DA:  MOVWF  x32
10DC:  MOVLW  00
10DE:  SUBWFB x1E,W
10E0:  MOVWF  x33
10E2:  MOVF   x19,W
10E4:  ADDWF  x32,W
10E6:  MOVWF  FE9
10E8:  MOVF   x1A,W
10EA:  ADDWFC x33,W
10EC:  MOVWF  FEA
10EE:  MOVFF  FEF,834
10F2:  MOVF   x19,W
10F4:  ADDWF  x1D,W
10F6:  MOVWF  FE9
10F8:  MOVF   x1A,W
10FA:  ADDWFC x1E,W
10FC:  MOVWF  FEA
10FE:  MOVFF  FEF,835
1102:  CLRF   x38
1104:  MOVFF  825,839
1108:  MOVFF  828,83A
110C:  MOVFF  82B,83B
1110:  MOVFF  82E,83C
1114:  MOVFF  831,83D
1118:  MOVFF  834,83E
111C:  MOVFF  835,83F
1120:  MOVLB  0
1122:  CALL   0494
1126:  MOVFF  01,821
....................                j=j-7;             
112A:  MOVLW  07
112C:  MOVLB  8
112E:  SUBWF  x1D,F
1130:  MOVLW  00
1132:  SUBWFB x1E,F
....................              } 
1134:  BRA    1016
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
1136:  DECFSZ x22,W
1138:  BRA    114E
....................             { 
....................                dir=1; 
113A:  MOVLW  01
113C:  MOVLB  6
113E:  MOVWF  xB0
....................                return i; 
1140:  MOVLB  8
1142:  MOVFF  81B,01
1146:  MOVFF  81C,02
114A:  BRA    13E8
....................             } 
....................             else return 0; 
114C:  BRA    1156
114E:  MOVLW  00
1150:  MOVWF  01
1152:  MOVWF  02
1154:  BRA    13E8
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
1156:  BRA    13D8
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1158:  MOVLW  04
115A:  SUBWF  x1B,W
115C:  MOVWF  x23
115E:  MOVLW  00
1160:  SUBWFB x1C,W
1162:  MOVWF  x24
1164:  MOVF   x19,W
1166:  ADDWF  x23,W
1168:  MOVWF  FE9
116A:  MOVF   x1A,W
116C:  ADDWFC x24,W
116E:  MOVWF  FEA
1170:  MOVFF  FEF,825
1174:  MOVLW  03
1176:  SUBWF  x1B,W
1178:  MOVWF  x26
117A:  MOVLW  00
117C:  SUBWFB x1C,W
117E:  MOVWF  x27
1180:  MOVF   x19,W
1182:  ADDWF  x26,W
1184:  MOVWF  FE9
1186:  MOVF   x1A,W
1188:  ADDWFC x27,W
118A:  MOVWF  FEA
118C:  MOVFF  FEF,828
1190:  MOVLW  02
1192:  SUBWF  x1B,W
1194:  MOVWF  x29
1196:  MOVLW  00
1198:  SUBWFB x1C,W
119A:  MOVWF  x2A
119C:  MOVF   x19,W
119E:  ADDWF  x29,W
11A0:  MOVWF  FE9
11A2:  MOVF   x1A,W
11A4:  ADDWFC x2A,W
11A6:  MOVWF  FEA
11A8:  MOVFF  FEF,82B
11AC:  MOVLW  01
11AE:  SUBWF  x1B,W
11B0:  MOVWF  x2C
11B2:  MOVLW  00
11B4:  SUBWFB x1C,W
11B6:  MOVWF  x2D
11B8:  MOVF   x19,W
11BA:  ADDWF  x2C,W
11BC:  MOVWF  FE9
11BE:  MOVF   x1A,W
11C0:  ADDWFC x2D,W
11C2:  MOVWF  FEA
11C4:  MOVFF  FEF,82E
11C8:  MOVF   x19,W
11CA:  ADDWF  x1B,W
11CC:  MOVWF  FE9
11CE:  MOVF   x1A,W
11D0:  ADDWFC x1C,W
11D2:  MOVWF  FEA
11D4:  MOVFF  FEF,82F
11D8:  CLRF   x38
11DA:  CLRF   x39
11DC:  CLRF   x3A
11DE:  MOVFF  825,83B
11E2:  MOVFF  828,83C
11E6:  MOVFF  82B,83D
11EA:  MOVFF  82E,83E
11EE:  MOVFF  82F,83F
11F2:  MOVLB  0
11F4:  CALL   0494
11F8:  MOVFF  01,81F
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
11FC:  MOVLW  09
11FE:  MOVLB  8
1200:  SUBWF  x1B,W
1202:  MOVWF  x23
1204:  MOVLW  00
1206:  SUBWFB x1C,W
1208:  MOVWF  x24
120A:  MOVF   x19,W
120C:  ADDWF  x23,W
120E:  MOVWF  FE9
1210:  MOVF   x1A,W
1212:  ADDWFC x24,W
1214:  MOVWF  FEA
1216:  MOVFF  FEF,825
121A:  MOVLW  08
121C:  SUBWF  x1B,W
121E:  MOVWF  x26
1220:  MOVLW  00
1222:  SUBWFB x1C,W
1224:  MOVWF  x27
1226:  MOVF   x19,W
1228:  ADDWF  x26,W
122A:  MOVWF  FE9
122C:  MOVF   x1A,W
122E:  ADDWFC x27,W
1230:  MOVWF  FEA
1232:  MOVFF  FEF,828
1236:  MOVLW  07
1238:  SUBWF  x1B,W
123A:  MOVWF  x29
123C:  MOVLW  00
123E:  SUBWFB x1C,W
1240:  MOVWF  x2A
1242:  MOVF   x19,W
1244:  ADDWF  x29,W
1246:  MOVWF  FE9
1248:  MOVF   x1A,W
124A:  ADDWFC x2A,W
124C:  MOVWF  FEA
124E:  MOVFF  FEF,82B
1252:  MOVLW  06
1254:  SUBWF  x1B,W
1256:  MOVWF  x2C
1258:  MOVLW  00
125A:  SUBWFB x1C,W
125C:  MOVWF  x2D
125E:  MOVF   x19,W
1260:  ADDWF  x2C,W
1262:  MOVWF  FE9
1264:  MOVF   x1A,W
1266:  ADDWFC x2D,W
1268:  MOVWF  FEA
126A:  MOVFF  FEF,82E
126E:  MOVLW  05
1270:  SUBWF  x1B,W
1272:  MOVWF  x2F
1274:  MOVLW  00
1276:  SUBWFB x1C,W
1278:  MOVWF  x30
127A:  MOVF   x19,W
127C:  ADDWF  x2F,W
127E:  MOVWF  FE9
1280:  MOVF   x1A,W
1282:  ADDWFC x30,W
1284:  MOVWF  FEA
1286:  MOVFF  FEF,831
128A:  CLRF   x38
128C:  CLRF   x39
128E:  CLRF   x3A
1290:  MOVFF  825,83B
1294:  MOVFF  828,83C
1298:  MOVFF  82B,83D
129C:  MOVFF  82E,83E
12A0:  MOVFF  831,83F
12A4:  MOVLB  0
12A6:  CALL   0494
12AA:  MOVFF  01,820
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
12AE:  MOVLB  8
12B0:  MOVF   x1F,W
12B2:  SUBLW  0B
12B4:  BTFSS  FD8.2
12B6:  BRA    13D8
12B8:  MOVF   x20,W
12BA:  SUBLW  1F
12BC:  BTFSC  FD8.2
12BE:  BRA    13D8
12C0:  MOVF   x20,W
12C2:  SUBLW  0F
12C4:  BTFSC  FD8.2
12C6:  BRA    13D8
....................             { 
....................                j=i; 
12C8:  MOVFF  81C,81E
12CC:  MOVFF  81B,81D
....................                CRC=1; 
12D0:  MOVLW  01
12D2:  MOVWF  x22
....................                temp2=temp; 
12D4:  MOVFF  81F,821
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
12D8:  MOVF   x21,W
12DA:  SUBLW  1F
12DC:  BZ    13B8
12DE:  MOVF   x1E,F
12E0:  BNZ   12E8
12E2:  MOVF   x1D,W
12E4:  SUBLW  01
12E6:  BC    13B8
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
12E8:  MOVLW  01
12EA:  MOVWF  x23
12EC:  MOVFF  81E,825
12F0:  MOVFF  81D,824
12F4:  MOVFF  81A,827
12F8:  MOVFF  819,826
12FC:  MOVLB  0
12FE:  CALL   06AA
1302:  MOVF   01,W
1304:  MOVLB  8
1306:  ANDWF  x22,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1308:  MOVLW  04
130A:  SUBWF  x1D,W
130C:  MOVWF  x23
130E:  MOVLW  00
1310:  SUBWFB x1E,W
1312:  MOVWF  x24
1314:  MOVF   x19,W
1316:  ADDWF  x23,W
1318:  MOVWF  FE9
131A:  MOVF   x1A,W
131C:  ADDWFC x24,W
131E:  MOVWF  FEA
1320:  MOVFF  FEF,825
1324:  MOVLW  03
1326:  SUBWF  x1D,W
1328:  MOVWF  x26
132A:  MOVLW  00
132C:  SUBWFB x1E,W
132E:  MOVWF  x27
1330:  MOVF   x19,W
1332:  ADDWF  x26,W
1334:  MOVWF  FE9
1336:  MOVF   x1A,W
1338:  ADDWFC x27,W
133A:  MOVWF  FEA
133C:  MOVFF  FEF,828
1340:  MOVLW  02
1342:  SUBWF  x1D,W
1344:  MOVWF  x29
1346:  MOVLW  00
1348:  SUBWFB x1E,W
134A:  MOVWF  x2A
134C:  MOVF   x19,W
134E:  ADDWF  x29,W
1350:  MOVWF  FE9
1352:  MOVF   x1A,W
1354:  ADDWFC x2A,W
1356:  MOVWF  FEA
1358:  MOVFF  FEF,82B
135C:  MOVLW  01
135E:  SUBWF  x1D,W
1360:  MOVWF  x2C
1362:  MOVLW  00
1364:  SUBWFB x1E,W
1366:  MOVWF  x2D
1368:  MOVF   x19,W
136A:  ADDWF  x2C,W
136C:  MOVWF  FE9
136E:  MOVF   x1A,W
1370:  ADDWFC x2D,W
1372:  MOVWF  FEA
1374:  MOVFF  FEF,82E
1378:  MOVF   x19,W
137A:  ADDWF  x1D,W
137C:  MOVWF  FE9
137E:  MOVF   x1A,W
1380:  ADDWFC x1E,W
1382:  MOVWF  FEA
1384:  MOVFF  FEF,82F
1388:  CLRF   x38
138A:  CLRF   x39
138C:  CLRF   x3A
138E:  MOVFF  825,83B
1392:  MOVFF  828,83C
1396:  MOVFF  82B,83D
139A:  MOVFF  82E,83E
139E:  MOVFF  82F,83F
13A2:  MOVLB  0
13A4:  CALL   0494
13A8:  MOVFF  01,821
....................                   j=j-5; 
13AC:  MOVLW  05
13AE:  MOVLB  8
13B0:  SUBWF  x1D,F
13B2:  MOVLW  00
13B4:  SUBWFB x1E,F
....................                } 
13B6:  BRA    12D8
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
13B8:  DECFSZ x22,W
13BA:  BRA    13D0
....................                { 
....................                   dir=1; 
13BC:  MOVLW  01
13BE:  MOVLB  6
13C0:  MOVWF  xB0
....................                   return i; 
13C2:  MOVLB  8
13C4:  MOVFF  81B,01
13C8:  MOVFF  81C,02
13CC:  BRA    13E8
....................                } 
....................                   else return 0; 
13CE:  BRA    13D8
13D0:  MOVLW  00
13D2:  MOVWF  01
13D4:  MOVWF  02
13D6:  BRA    13E8
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
13D8:  MOVF   x1B,W
13DA:  BTFSC  FD8.2
13DC:  DECF   x1C,F
13DE:  DECF   x1B,F
13E0:  BRA    0DDA
....................    return 0; 
13E2:  MOVLW  00
13E4:  MOVWF  01
13E6:  MOVWF  02
.................... } 
13E8:  MOVLB  0
13EA:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
3448:  MOVLB  8
344A:  CLRF   x15
344C:  MOVLW  01
344E:  MOVWF  x14
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3450:  MOVFF  80A,816
3454:  MOVFF  80C,818
3458:  MOVFF  80B,817
345C:  MOVFF  80E,81A
3460:  MOVFF  80D,819
3464:  MOVLB  0
3466:  CALL   07EA
346A:  MOVFF  02,815
346E:  MOVFF  01,814
....................    if(temp==0) return 0; 
3472:  MOVLB  8
3474:  MOVF   x14,F
3476:  BNZ   3482
3478:  MOVF   x15,F
347A:  BNZ   3482
347C:  MOVLW  00
347E:  MOVWF  01
3480:  BRA    382C
....................    j=temp; 
3482:  MOVFF  815,813
3486:  MOVFF  814,812
....................    if(dir==0) 
348A:  MOVLB  6
348C:  MOVF   xB0,F
348E:  BTFSS  FD8.2
3490:  BRA    364C
....................    { 
....................       if(track==0) 
3492:  MOVLB  8
3494:  MOVF   x0A,F
3496:  BTFSS  FD8.2
3498:  BRA    3590
....................       { 
....................             for(i=0;i<79;i++) 
349A:  CLRF   x11
349C:  MOVF   x11,W
349E:  SUBLW  4E
34A0:  BNC   358E
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
34A2:  CLRF   03
34A4:  MOVF   x11,W
34A6:  ADDWF  x0F,W
34A8:  MOVWF  01
34AA:  MOVF   x10,W
34AC:  ADDWFC 03,F
34AE:  MOVFF  01,816
34B2:  MOVFF  03,817
34B6:  MOVLW  05
34B8:  ADDWF  x12,W
34BA:  MOVWF  x18
34BC:  MOVLW  00
34BE:  ADDWFC x13,W
34C0:  MOVWF  x19
34C2:  MOVF   x0D,W
34C4:  ADDWF  x18,W
34C6:  MOVWF  FE9
34C8:  MOVF   x0E,W
34CA:  ADDWFC x19,W
34CC:  MOVWF  FEA
34CE:  MOVFF  FEF,81A
34D2:  MOVLW  04
34D4:  ADDWF  x12,W
34D6:  MOVWF  x1B
34D8:  MOVLW  00
34DA:  ADDWFC x13,W
34DC:  MOVWF  x1C
34DE:  MOVF   x0D,W
34E0:  ADDWF  x1B,W
34E2:  MOVWF  FE9
34E4:  MOVF   x0E,W
34E6:  ADDWFC x1C,W
34E8:  MOVWF  FEA
34EA:  MOVFF  FEF,81D
34EE:  MOVLW  03
34F0:  ADDWF  x12,W
34F2:  MOVWF  x1E
34F4:  MOVLW  00
34F6:  ADDWFC x13,W
34F8:  MOVWF  x1F
34FA:  MOVF   x0D,W
34FC:  ADDWF  x1E,W
34FE:  MOVWF  FE9
3500:  MOVF   x0E,W
3502:  ADDWFC x1F,W
3504:  MOVWF  FEA
3506:  MOVFF  FEF,820
350A:  MOVLW  02
350C:  ADDWF  x12,W
350E:  MOVWF  x21
3510:  MOVLW  00
3512:  ADDWFC x13,W
3514:  MOVWF  x22
3516:  MOVF   x0D,W
3518:  ADDWF  x21,W
351A:  MOVWF  FE9
351C:  MOVF   x0E,W
351E:  ADDWFC x22,W
3520:  MOVWF  FEA
3522:  MOVFF  FEF,823
3526:  MOVLW  01
3528:  ADDWF  x12,W
352A:  MOVWF  x24
352C:  MOVLW  00
352E:  ADDWFC x13,W
3530:  MOVWF  x25
3532:  MOVF   x0D,W
3534:  ADDWF  x24,W
3536:  MOVWF  FE9
3538:  MOVF   x0E,W
353A:  ADDWFC x25,W
353C:  MOVWF  FEA
353E:  MOVFF  FEF,826
3542:  MOVF   x0D,W
3544:  ADDWF  x12,W
3546:  MOVWF  FE9
3548:  MOVF   x0E,W
354A:  ADDWFC x13,W
354C:  MOVWF  FEA
354E:  MOVFF  FEF,827
3552:  CLRF   x38
3554:  CLRF   x39
3556:  MOVFF  81A,83A
355A:  MOVFF  81D,83B
355E:  MOVFF  820,83C
3562:  MOVFF  823,83D
3566:  MOVFF  826,83E
356A:  MOVFF  827,83F
356E:  MOVLB  0
3570:  CALL   0494
3574:  MOVFF  817,FEA
3578:  MOVFF  816,FE9
357C:  MOVFF  01,FEF
....................                j=j+7; 
3580:  MOVLW  07
3582:  MOVLB  8
3584:  ADDWF  x12,F
3586:  MOVLW  00
3588:  ADDWFC x13,F
....................             } 
358A:  INCF   x11,F
358C:  BRA    349C
....................       } 
....................          else  
358E:  BRA    3648
....................          { 
....................             for(i=0;i<40;i++) 
3590:  CLRF   x11
3592:  MOVF   x11,W
3594:  SUBLW  27
3596:  BNC   3648
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3598:  CLRF   03
359A:  MOVF   x11,W
359C:  ADDWF  x0F,W
359E:  MOVWF  01
35A0:  MOVF   x10,W
35A2:  ADDWFC 03,F
35A4:  MOVFF  01,816
35A8:  MOVFF  03,817
35AC:  MOVLW  03
35AE:  ADDWF  x12,W
35B0:  MOVWF  x18
35B2:  MOVLW  00
35B4:  ADDWFC x13,W
35B6:  MOVWF  x19
35B8:  MOVF   x0D,W
35BA:  ADDWF  x18,W
35BC:  MOVWF  FE9
35BE:  MOVF   x0E,W
35C0:  ADDWFC x19,W
35C2:  MOVWF  FEA
35C4:  MOVFF  FEF,81A
35C8:  MOVLW  02
35CA:  ADDWF  x12,W
35CC:  MOVWF  x1B
35CE:  MOVLW  00
35D0:  ADDWFC x13,W
35D2:  MOVWF  x1C
35D4:  MOVF   x0D,W
35D6:  ADDWF  x1B,W
35D8:  MOVWF  FE9
35DA:  MOVF   x0E,W
35DC:  ADDWFC x1C,W
35DE:  MOVWF  FEA
35E0:  MOVFF  FEF,81D
35E4:  MOVLW  01
35E6:  ADDWF  x12,W
35E8:  MOVWF  x1E
35EA:  MOVLW  00
35EC:  ADDWFC x13,W
35EE:  MOVWF  x1F
35F0:  MOVF   x0D,W
35F2:  ADDWF  x1E,W
35F4:  MOVWF  FE9
35F6:  MOVF   x0E,W
35F8:  ADDWFC x1F,W
35FA:  MOVWF  FEA
35FC:  MOVFF  FEF,820
3600:  MOVF   x0D,W
3602:  ADDWF  x12,W
3604:  MOVWF  FE9
3606:  MOVF   x0E,W
3608:  ADDWFC x13,W
360A:  MOVWF  FEA
360C:  MOVFF  FEF,821
3610:  CLRF   x38
3612:  CLRF   x39
3614:  CLRF   x3A
3616:  CLRF   x3B
3618:  MOVFF  81A,83C
361C:  MOVFF  81D,83D
3620:  MOVFF  820,83E
3624:  MOVFF  821,83F
3628:  MOVLB  0
362A:  CALL   0494
362E:  MOVFF  817,FEA
3632:  MOVFF  816,FE9
3636:  MOVFF  01,FEF
....................                j=j+5; 
363A:  MOVLW  05
363C:  MOVLB  8
363E:  ADDWF  x12,F
3640:  MOVLW  00
3642:  ADDWFC x13,F
....................             }          
3644:  INCF   x11,F
3646:  BRA    3592
....................          } 
....................    } 
....................       else  
3648:  BRA    3802
364A:  MOVLB  6
....................       { 
....................          if(track==0) 
364C:  MOVLB  8
364E:  MOVF   x0A,F
3650:  BTFSS  FD8.2
3652:  BRA    374A
....................          { 
....................             for(i=0;i<79;i++) 
3654:  CLRF   x11
3656:  MOVF   x11,W
3658:  SUBLW  4E
365A:  BNC   3748
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
365C:  CLRF   03
365E:  MOVF   x11,W
3660:  ADDWF  x0F,W
3662:  MOVWF  01
3664:  MOVF   x10,W
3666:  ADDWFC 03,F
3668:  MOVFF  01,816
366C:  MOVFF  03,817
3670:  MOVLW  05
3672:  SUBWF  x12,W
3674:  MOVWF  x18
3676:  MOVLW  00
3678:  SUBWFB x13,W
367A:  MOVWF  x19
367C:  MOVF   x0D,W
367E:  ADDWF  x18,W
3680:  MOVWF  FE9
3682:  MOVF   x0E,W
3684:  ADDWFC x19,W
3686:  MOVWF  FEA
3688:  MOVFF  FEF,81A
368C:  MOVLW  04
368E:  SUBWF  x12,W
3690:  MOVWF  x1B
3692:  MOVLW  00
3694:  SUBWFB x13,W
3696:  MOVWF  x1C
3698:  MOVF   x0D,W
369A:  ADDWF  x1B,W
369C:  MOVWF  FE9
369E:  MOVF   x0E,W
36A0:  ADDWFC x1C,W
36A2:  MOVWF  FEA
36A4:  MOVFF  FEF,81D
36A8:  MOVLW  03
36AA:  SUBWF  x12,W
36AC:  MOVWF  x1E
36AE:  MOVLW  00
36B0:  SUBWFB x13,W
36B2:  MOVWF  x1F
36B4:  MOVF   x0D,W
36B6:  ADDWF  x1E,W
36B8:  MOVWF  FE9
36BA:  MOVF   x0E,W
36BC:  ADDWFC x1F,W
36BE:  MOVWF  FEA
36C0:  MOVFF  FEF,820
36C4:  MOVLW  02
36C6:  SUBWF  x12,W
36C8:  MOVWF  x21
36CA:  MOVLW  00
36CC:  SUBWFB x13,W
36CE:  MOVWF  x22
36D0:  MOVF   x0D,W
36D2:  ADDWF  x21,W
36D4:  MOVWF  FE9
36D6:  MOVF   x0E,W
36D8:  ADDWFC x22,W
36DA:  MOVWF  FEA
36DC:  MOVFF  FEF,823
36E0:  MOVLW  01
36E2:  SUBWF  x12,W
36E4:  MOVWF  x24
36E6:  MOVLW  00
36E8:  SUBWFB x13,W
36EA:  MOVWF  x25
36EC:  MOVF   x0D,W
36EE:  ADDWF  x24,W
36F0:  MOVWF  FE9
36F2:  MOVF   x0E,W
36F4:  ADDWFC x25,W
36F6:  MOVWF  FEA
36F8:  MOVFF  FEF,826
36FC:  MOVF   x0D,W
36FE:  ADDWF  x12,W
3700:  MOVWF  FE9
3702:  MOVF   x0E,W
3704:  ADDWFC x13,W
3706:  MOVWF  FEA
3708:  MOVFF  FEF,827
370C:  CLRF   x38
370E:  CLRF   x39
3710:  MOVFF  81A,83A
3714:  MOVFF  81D,83B
3718:  MOVFF  820,83C
371C:  MOVFF  823,83D
3720:  MOVFF  826,83E
3724:  MOVFF  827,83F
3728:  MOVLB  0
372A:  CALL   0494
372E:  MOVFF  817,FEA
3732:  MOVFF  816,FE9
3736:  MOVFF  01,FEF
....................                j=j-7; 
373A:  MOVLW  07
373C:  MOVLB  8
373E:  SUBWF  x12,F
3740:  MOVLW  00
3742:  SUBWFB x13,F
....................             } 
3744:  INCF   x11,F
3746:  BRA    3656
....................          } 
....................             else 
3748:  BRA    3802
....................             { 
....................                for(i=0;i<40;i++) 
374A:  CLRF   x11
374C:  MOVF   x11,W
374E:  SUBLW  27
3750:  BNC   3802
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3752:  CLRF   03
3754:  MOVF   x11,W
3756:  ADDWF  x0F,W
3758:  MOVWF  01
375A:  MOVF   x10,W
375C:  ADDWFC 03,F
375E:  MOVFF  01,816
3762:  MOVFF  03,817
3766:  MOVLW  03
3768:  SUBWF  x12,W
376A:  MOVWF  x18
376C:  MOVLW  00
376E:  SUBWFB x13,W
3770:  MOVWF  x19
3772:  MOVF   x0D,W
3774:  ADDWF  x18,W
3776:  MOVWF  FE9
3778:  MOVF   x0E,W
377A:  ADDWFC x19,W
377C:  MOVWF  FEA
377E:  MOVFF  FEF,81A
3782:  MOVLW  02
3784:  SUBWF  x12,W
3786:  MOVWF  x1B
3788:  MOVLW  00
378A:  SUBWFB x13,W
378C:  MOVWF  x1C
378E:  MOVF   x0D,W
3790:  ADDWF  x1B,W
3792:  MOVWF  FE9
3794:  MOVF   x0E,W
3796:  ADDWFC x1C,W
3798:  MOVWF  FEA
379A:  MOVFF  FEF,81D
379E:  MOVLW  01
37A0:  SUBWF  x12,W
37A2:  MOVWF  x1E
37A4:  MOVLW  00
37A6:  SUBWFB x13,W
37A8:  MOVWF  x1F
37AA:  MOVF   x0D,W
37AC:  ADDWF  x1E,W
37AE:  MOVWF  FE9
37B0:  MOVF   x0E,W
37B2:  ADDWFC x1F,W
37B4:  MOVWF  FEA
37B6:  MOVFF  FEF,820
37BA:  MOVF   x0D,W
37BC:  ADDWF  x12,W
37BE:  MOVWF  FE9
37C0:  MOVF   x0E,W
37C2:  ADDWFC x13,W
37C4:  MOVWF  FEA
37C6:  MOVFF  FEF,821
37CA:  CLRF   x38
37CC:  CLRF   x39
37CE:  CLRF   x3A
37D0:  CLRF   x3B
37D2:  MOVFF  81A,83C
37D6:  MOVFF  81D,83D
37DA:  MOVFF  820,83E
37DE:  MOVFF  821,83F
37E2:  MOVLB  0
37E4:  CALL   0494
37E8:  MOVFF  817,FEA
37EC:  MOVFF  816,FE9
37F0:  MOVFF  01,FEF
....................                   j=j-5; 
37F4:  MOVLW  05
37F6:  MOVLB  8
37F8:  SUBWF  x12,F
37FA:  MOVLW  00
37FC:  SUBWFB x13,F
....................                }             
37FE:  INCF   x11,F
3800:  BRA    374C
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3802:  MOVF   x0A,F
3804:  BNZ   381A
3806:  MOVLW  52
3808:  MOVWF  x16
380A:  MOVFF  80E,818
380E:  MOVFF  80D,817
3812:  MOVLB  0
3814:  RCALL  3426
....................          else del_buf(numbyteofbuffer2,datin); 
3816:  BRA    382A
3818:  MOVLB  8
381A:  MOVLW  2C
381C:  MOVWF  x16
381E:  MOVFF  80E,818
3822:  MOVFF  80D,817
3826:  MOVLB  0
3828:  RCALL  3426
382A:  MOVLB  8
.................... } 
382C:  MOVLB  0
382E:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
15C4:  MOVLW  38
15C6:  MOVWF  FF6
15C8:  MOVLW  03
15CA:  MOVWF  FF7
15CC:  CALL   0474
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
15D0:  MOVLB  8
15D2:  CLRF   x0E
15D4:  CLRF   x0D
15D6:  MOVF   x0E,W
15D8:  SUBLW  03
15DA:  BNC   160A
15DC:  BNZ   15E4
15DE:  MOVF   x0D,W
15E0:  SUBLW  51
15E2:  BNC   160A
15E4:  MOVLW  2E
15E6:  ADDWF  x0D,W
15E8:  MOVWF  FE9
15EA:  MOVLW  02
15EC:  ADDWFC x0E,W
15EE:  MOVWF  FEA
15F0:  MOVFF  FEF,80F
15F4:  MOVFF  80F,810
15F8:  MOVLW  18
15FA:  MOVWF  x11
15FC:  MOVLB  0
15FE:  RCALL  1500
1600:  MOVLB  8
1602:  INCF   x0D,F
1604:  BTFSC  FD8.2
1606:  INCF   x0E,F
1608:  BRA    15D6
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
160A:  MOVLW  4E
160C:  MOVWF  FF6
160E:  MOVLW  03
1610:  MOVWF  FF7
1612:  MOVLB  0
1614:  CALL   0474
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1618:  MOVLB  8
161A:  CLRF   x0E
161C:  CLRF   x0D
161E:  MOVF   x0E,W
1620:  SUBLW  01
1622:  BNC   1652
1624:  BNZ   162C
1626:  MOVF   x0D,W
1628:  SUBLW  2B
162A:  BNC   1652
162C:  MOVLW  80
162E:  ADDWF  x0D,W
1630:  MOVWF  FE9
1632:  MOVLW  05
1634:  ADDWFC x0E,W
1636:  MOVWF  FEA
1638:  MOVFF  FEF,80F
163C:  MOVFF  80F,810
1640:  MOVLW  18
1642:  MOVWF  x11
1644:  MOVLB  0
1646:  RCALL  1500
1648:  MOVLB  8
164A:  INCF   x0D,F
164C:  BTFSC  FD8.2
164E:  INCF   x0E,F
1650:  BRA    161E
.................... } 
1652:  MOVLB  0
1654:  GOTO   18EA (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
39BC:  MOVLW  01
39BE:  MOVLB  6
39C0:  MOVWF  xC0
....................    //rtc_get_date(date,mon,year,day); 
....................    //rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
39C2:  MOVLB  0
39C4:  RCALL  33AC
39C6:  MOVFF  02,80B
39CA:  MOVFF  01,80A
39CE:  MOVFF  02,80D
39D2:  MOVFF  01,80C
39D6:  MOVLB  8
39D8:  CLRF   x0F
39DA:  MOVLW  7C
39DC:  MOVWF  x0E
39DE:  MOVLB  0
39E0:  RCALL  3404
39E2:  MOVFF  01,80A
39E6:  MOVLW  96
39E8:  MOVLB  8
39EA:  ADDWF  01,W
39EC:  MOVWF  01
39EE:  MOVLW  00
39F0:  ADDWFC 02,W
39F2:  MOVFF  01,20
39F6:  MOVWF  21
39F8:  CLRF   22
39FA:  CLRF   23
....................    if(datinbuf==0)  
39FC:  MOVLB  6
39FE:  MOVF   xBD,F
3A00:  BNZ   3A22
....................    { 
....................       countbit_T1=0; 
3A02:  CLRF   xB2
3A04:  CLRF   xB1
....................       countbit_T2=0; 
3A06:  CLRF   xB4
3A08:  CLRF   xB3
....................       bug_countbit_T1=0; 
3A0A:  CLRF   xB6
3A0C:  CLRF   xB5
....................       bug_countbit_T2=0; 
3A0E:  CLRF   xB8
3A10:  CLRF   xB7
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3A12:  MOVF   xC1,F
3A14:  BNZ   3A1E
3A16:  MOVLB  1
3A18:  SETF   x1D
3A1A:  SETF   x1C
3A1C:  MOVLB  6
....................       saving_flag=0; 
3A1E:  CLRF   xC0
....................       return; 
3A20:  BRA    3DBC
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3A22:  MOVLW  64
3A24:  MOVWF  FF6
3A26:  MOVLW  03
3A28:  MOVWF  FF7
3A2A:  MOVLB  0
3A2C:  CALL   0474
....................    key_timeout=0; 
3A30:  MOVLB  1
3A32:  CLRF   x2A
3A34:  CLRF   x29
....................    //key_count=0; 
....................    enable_getpin=1; 
3A36:  MOVLW  01
3A38:  MOVWF  x2D
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3A3A:  MOVFF  6B2,809
3A3E:  MOVFF  6B1,808
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3A42:  MOVLB  8
3A44:  CLRF   x0A
3A46:  MOVFF  809,80C
3A4A:  MOVFF  808,80B
3A4E:  MOVLW  02
3A50:  MOVWF  x0E
3A52:  MOVLW  2E
3A54:  MOVWF  x0D
3A56:  MOVLW  01
3A58:  MOVWF  x10
3A5A:  MOVLW  B7
3A5C:  MOVWF  x0F
3A5E:  MOVLB  0
3A60:  RCALL  3448
....................    countbit_T1=0; 
3A62:  MOVLB  6
3A64:  CLRF   xB2
3A66:  CLRF   xB1
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3A68:  MOVFF  6B4,809
3A6C:  MOVFF  6B3,808
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3A70:  MOVLW  01
3A72:  MOVLB  8
3A74:  MOVWF  x0A
3A76:  MOVFF  809,80C
3A7A:  MOVFF  808,80B
3A7E:  MOVLW  05
3A80:  MOVWF  x0E
3A82:  MOVLW  80
3A84:  MOVWF  x0D
3A86:  MOVLW  02
3A88:  MOVWF  x10
3A8A:  MOVLW  06
3A8C:  MOVWF  x0F
3A8E:  MOVLB  0
3A90:  RCALL  3448
....................    countbit_T2=0; 
3A92:  MOVLB  6
3A94:  CLRF   xB4
3A96:  CLRF   xB3
....................    saving_flag=0; 
3A98:  CLRF   xC0
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3A9A:  MOVLW  20
3A9C:  MOVLB  1
3A9E:  ADDWF  xB7,W
3AA0:  MOVLB  8
3AA2:  MOVWF  x07
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
3AA4:  MOVF   23,F
3AA6:  BTFSS  FD8.2
3AA8:  BRA    3DBA
3AAA:  MOVF   22,W
3AAC:  SUBLW  01
3AAE:  BTFSS  FD8.0
3AB0:  BRA    3DBA
3AB2:  BNZ   3AC6
3AB4:  MOVF   21,W
3AB6:  SUBLW  C3
3AB8:  BTFSS  FD8.0
3ABA:  BRA    3DBA
3ABC:  BNZ   3AC6
3ABE:  MOVF   20,W
3AC0:  SUBLW  0D
3AC2:  BTFSS  FD8.0
3AC4:  BRA    3DBA
3AC6:  MOVF   x07,W
3AC8:  SUBLW  25
3ACA:  BTFSS  FD8.2
3ACC:  BRA    3DBA
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3ACE:  MOVFF  23,03
3AD2:  MOVFF  22,02
3AD6:  MOVFF  21,01
3ADA:  MOVFF  20,00
3ADE:  MOVLW  01
3AE0:  ADDWF  20,F
3AE2:  BTFSC  FD8.0
3AE4:  INCF   21,F
3AE6:  BTFSC  FD8.2
3AE8:  INCF   22,F
3AEA:  BTFSC  FD8.2
3AEC:  INCF   23,F
3AEE:  MOVFF  01,80B
3AF2:  MOVFF  00,80A
3AF6:  CLRF   x1B
3AF8:  CLRF   x1A
3AFA:  MOVFF  01,819
3AFE:  MOVFF  00,818
3B02:  MOVFF  121,81C
3B06:  MOVLB  0
3B08:  RCALL  3830
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3B0A:  MOVFF  23,03
3B0E:  MOVFF  22,02
3B12:  MOVFF  21,01
3B16:  MOVFF  20,00
3B1A:  MOVLW  01
3B1C:  ADDWF  20,F
3B1E:  BTFSC  FD8.0
3B20:  INCF   21,F
3B22:  BTFSC  FD8.2
3B24:  INCF   22,F
3B26:  BTFSC  FD8.2
3B28:  INCF   23,F
3B2A:  MOVFF  01,80B
3B2E:  MOVFF  00,80A
3B32:  MOVLB  8
3B34:  CLRF   x1B
3B36:  CLRF   x1A
3B38:  MOVFF  01,819
3B3C:  MOVFF  00,818
3B40:  MOVFF  120,81C
3B44:  MOVLB  0
3B46:  RCALL  3830
....................          write_ext_eeprom((long int)ptr_card++,h); 
3B48:  MOVFF  23,03
3B4C:  MOVFF  22,02
3B50:  MOVFF  21,01
3B54:  MOVFF  20,00
3B58:  MOVLW  01
3B5A:  ADDWF  20,F
3B5C:  BTFSC  FD8.0
3B5E:  INCF   21,F
3B60:  BTFSC  FD8.2
3B62:  INCF   22,F
3B64:  BTFSC  FD8.2
3B66:  INCF   23,F
3B68:  MOVFF  01,80B
3B6C:  MOVFF  00,80A
3B70:  MOVLB  8
3B72:  CLRF   x1B
3B74:  CLRF   x1A
3B76:  MOVFF  01,819
3B7A:  MOVFF  00,818
3B7E:  MOVFF  122,81C
3B82:  MOVLB  0
3B84:  RCALL  3830
....................          write_ext_eeprom((long int)ptr_card++,min); 
3B86:  MOVFF  23,03
3B8A:  MOVFF  22,02
3B8E:  MOVFF  21,01
3B92:  MOVFF  20,00
3B96:  MOVLW  01
3B98:  ADDWF  20,F
3B9A:  BTFSC  FD8.0
3B9C:  INCF   21,F
3B9E:  BTFSC  FD8.2
3BA0:  INCF   22,F
3BA2:  BTFSC  FD8.2
3BA4:  INCF   23,F
3BA6:  MOVFF  01,80B
3BAA:  MOVFF  00,80A
3BAE:  MOVLB  8
3BB0:  CLRF   x1B
3BB2:  CLRF   x1A
3BB4:  MOVFF  01,819
3BB8:  MOVFF  00,818
3BBC:  MOVFF  123,81C
3BC0:  MOVLB  0
3BC2:  RCALL  3830
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3BC4:  MOVFF  23,03
3BC8:  MOVFF  22,02
3BCC:  MOVFF  21,01
3BD0:  MOVFF  20,00
3BD4:  MOVLW  01
3BD6:  ADDWF  20,F
3BD8:  BTFSC  FD8.0
3BDA:  INCF   21,F
3BDC:  BTFSC  FD8.2
3BDE:  INCF   22,F
3BE0:  BTFSC  FD8.2
3BE2:  INCF   23,F
3BE4:  MOVFF  01,80B
3BE8:  MOVFF  00,80A
3BEC:  MOVLB  8
3BEE:  CLRF   x1B
3BF0:  CLRF   x1A
3BF2:  MOVFF  01,819
3BF6:  MOVFF  00,818
3BFA:  MOVFF  124,81C
3BFE:  MOVLB  0
3C00:  RCALL  3830
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3C02:  MOVLB  6
3C04:  CLRF   xBC
3C06:  CLRF   xBB
3C08:  MOVF   xBC,F
3C0A:  BNZ   3C6C
3C0C:  MOVF   xBB,W
3C0E:  SUBLW  4E
3C10:  BNC   3C6C
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3C12:  MOVFF  23,03
3C16:  MOVFF  22,02
3C1A:  MOVFF  21,01
3C1E:  MOVFF  20,00
3C22:  MOVLW  01
3C24:  ADDWF  20,F
3C26:  BTFSC  FD8.0
3C28:  INCF   21,F
3C2A:  BTFSC  FD8.2
3C2C:  INCF   22,F
3C2E:  BTFSC  FD8.2
3C30:  INCF   23,F
3C32:  MOVFF  01,80B
3C36:  MOVFF  00,80A
3C3A:  MOVLW  B7
3C3C:  ADDWF  xBB,W
3C3E:  MOVWF  FE9
3C40:  MOVLW  01
3C42:  ADDWFC xBC,W
3C44:  MOVWF  FEA
3C46:  MOVF   FEF,W
3C48:  ANDLW  3F
3C4A:  ADDLW  20
3C4C:  MOVLB  8
3C4E:  MOVWF  x0C
3C50:  CLRF   x1B
3C52:  CLRF   x1A
3C54:  MOVFF  01,819
3C58:  MOVFF  00,818
3C5C:  MOVWF  x1C
3C5E:  MOVLB  0
3C60:  RCALL  3830
....................              
....................          } 
3C62:  MOVLB  6
3C64:  INCF   xBB,F
3C66:  BTFSC  FD8.2
3C68:  INCF   xBC,F
3C6A:  BRA    3C08
....................          del_buf(numbyteoftrack1,Track1); 
3C6C:  MOVLW  4F
3C6E:  MOVLB  8
3C70:  MOVWF  x16
3C72:  MOVLW  01
3C74:  MOVWF  x18
3C76:  MOVLW  B7
3C78:  MOVWF  x17
3C7A:  MOVLB  0
3C7C:  CALL   3426
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3C80:  MOVLB  6
3C82:  CLRF   xBC
3C84:  CLRF   xBB
3C86:  MOVF   xBC,F
3C88:  BNZ   3CEA
3C8A:  MOVF   xBB,W
3C8C:  SUBLW  27
3C8E:  BNC   3CEA
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3C90:  MOVFF  23,03
3C94:  MOVFF  22,02
3C98:  MOVFF  21,01
3C9C:  MOVFF  20,00
3CA0:  MOVLW  01
3CA2:  ADDWF  20,F
3CA4:  BTFSC  FD8.0
3CA6:  INCF   21,F
3CA8:  BTFSC  FD8.2
3CAA:  INCF   22,F
3CAC:  BTFSC  FD8.2
3CAE:  INCF   23,F
3CB0:  MOVFF  01,80B
3CB4:  MOVFF  00,80A
3CB8:  MOVLW  06
3CBA:  ADDWF  xBB,W
3CBC:  MOVWF  FE9
3CBE:  MOVLW  02
3CC0:  ADDWFC xBC,W
3CC2:  MOVWF  FEA
3CC4:  MOVF   FEF,W
3CC6:  ANDLW  0F
3CC8:  ADDLW  30
3CCA:  MOVLB  8
3CCC:  MOVWF  x0C
3CCE:  CLRF   x1B
3CD0:  CLRF   x1A
3CD2:  MOVFF  01,819
3CD6:  MOVFF  00,818
3CDA:  MOVWF  x1C
3CDC:  MOVLB  0
3CDE:  RCALL  3830
....................          }  
3CE0:  MOVLB  6
3CE2:  INCF   xBB,F
3CE4:  BTFSC  FD8.2
3CE6:  INCF   xBC,F
3CE8:  BRA    3C86
....................          del_buf(numbyteoftrack2,Track2); 
3CEA:  MOVLW  28
3CEC:  MOVLB  8
3CEE:  MOVWF  x16
3CF0:  MOVLW  02
3CF2:  MOVWF  x18
3CF4:  MOVLW  06
3CF6:  MOVWF  x17
3CF8:  MOVLB  0
3CFA:  CALL   3426
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
3CFE:  MOVLW  0D
3D00:  MOVLB  8
3D02:  MOVWF  x30
3D04:  MOVLB  0
3D06:  CALL   0422
3D0A:  MOVLW  0A
3D0C:  MOVLB  8
3D0E:  MOVWF  x30
3D10:  MOVLB  0
3D12:  CALL   0422
....................       fprintf(COM2,"Done"); 
3D16:  MOVLW  7A
3D18:  MOVWF  FF6
3D1A:  MOVLW  03
3D1C:  MOVWF  FF7
3D1E:  CALL   0474
....................       if(KP_mode) 
3D22:  MOVLB  1
3D24:  MOVF   x30,F
3D26:  BZ    3D3E
....................       { 
....................          printf("\n\rKey release\n\r"); 
3D28:  MOVLW  80
3D2A:  MOVWF  FF6
3D2C:  MOVLW  03
3D2E:  MOVWF  FF7
3D30:  MOVLB  0
3D32:  CALL   0474
....................          keyprss_off; 
3D36:  BCF    F92.7
3D38:  BCF    F89.7
....................          kp_st=0; 
3D3A:  MOVLB  1
3D3C:  CLRF   x31
....................       }   
....................       count_kp=0xffff; 
3D3E:  SETF   x33
3D40:  SETF   x32
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
3D42:  MOVLW  0D
3D44:  MOVLB  8
3D46:  MOVWF  x30
3D48:  MOVLB  0
3D4A:  CALL   0422
3D4E:  MOVLW  0A
3D50:  MOVLB  8
3D52:  MOVWF  x30
3D54:  MOVLB  0
3D56:  CALL   0422
....................       fprintf(COM2,"Waiting for PIN number"); 
3D5A:  MOVLW  90
3D5C:  MOVWF  FF6
3D5E:  MOVLW  03
3D60:  MOVWF  FF7
3D62:  CALL   0474
....................       count_checking=0; 
3D66:  MOVLB  1
3D68:  CLRF   x28
3D6A:  CLRF   x27
....................       fprintf(COM2,"\r\n"); 
3D6C:  MOVLW  0D
3D6E:  MOVLB  8
3D70:  MOVWF  x30
3D72:  MOVLB  0
3D74:  CALL   0422
3D78:  MOVLW  0A
3D7A:  MOVLB  8
3D7C:  MOVWF  x30
3D7E:  MOVLB  0
3D80:  CALL   0422
....................       charac_timeout=0; 
3D84:  MOVLB  1
3D86:  CLRF   x1D
3D88:  CLRF   x1C
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3D8A:  MOVFF  23,80D
3D8E:  MOVFF  22,80C
3D92:  MOVFF  21,80B
3D96:  MOVFF  20,80A
3D9A:  MOVLW  19
3D9C:  MOVLB  8
3D9E:  MOVWF  x0E
3DA0:  MOVLB  0
3DA2:  RCALL  392E
....................       datinbuf=0; 
3DA4:  MOVLB  6
3DA6:  CLRF   xBD
....................       saving_flag=0; 
3DA8:  CLRF   xC0
....................       data_avai=1; 
3DAA:  MOVLW  01
3DAC:  MOVWF  xC1
....................       enable_getpin=1; 
3DAE:  MOVLB  1
3DB0:  MOVWF  x2D
....................       charac_timeout=0; 
3DB2:  CLRF   x1D
3DB4:  CLRF   x1C
....................       key_count_ms=0; 
3DB6:  CLRF   x2F
3DB8:  MOVLB  8
3DBA:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3DBC:  MOVLB  0
3DBE:  GOTO   4144 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
1680:  MOVLW  01
1682:  MOVLB  8
1684:  MOVWF  x04
1686:  MOVWF  x05
1688:  MOVWF  x06
168A:  MOVWF  x07
168C:  CLRF   x08
168E:  MOVWF  x09
1690:  MOVWF  x0A
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1692:  MOVLB  6
1694:  CLRF   xBA
1696:  CLRF   xB9
....................    mcr_timeout=0; 
1698:  CLRF   xAF
169A:  CLRF   xAE
169C:  CLRF   xAD
169E:  CLRF   xAC
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
16A0:  MOVF   xBA,W
16A2:  SUBLW  FD
16A4:  BNC   16C2
16A6:  BNZ   16AE
16A8:  MOVF   xB9,W
16AA:  SUBLW  E7
16AC:  BNC   16C2
16AE:  BSF    F93.1
16B0:  BTFSS  F81.1
16B2:  BRA    16C2
16B4:  BSF    F94.5
16B6:  BTFSS  F82.5
16B8:  BRA    16C2
....................       card_timeout++; 
16BA:  INCF   xB9,F
16BC:  BTFSC  FD8.2
16BE:  INCF   xBA,F
....................    } 
16C0:  BRA    16A0
....................    card_timeout=0; 
16C2:  CLRF   xBA
16C4:  CLRF   xB9
....................    buffertrack1[bug_countbit_T1++]=0; 
16C6:  MOVFF  6B6,03
16CA:  MOVF   xB5,W
16CC:  INCF   xB5,F
16CE:  BTFSC  FD8.2
16D0:  INCF   xB6,F
16D2:  MOVLB  8
16D4:  MOVWF  x0D
16D6:  MOVLW  2E
16D8:  ADDWF  x0D,W
16DA:  MOVWF  FE9
16DC:  MOVLW  02
16DE:  ADDWFC 03,W
16E0:  MOVWF  FEA
16E2:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
16E4:  MOVLB  6
16E6:  MOVFF  6B6,03
16EA:  MOVF   xB5,W
16EC:  INCF   xB5,F
16EE:  BTFSC  FD8.2
16F0:  INCF   xB6,F
16F2:  MOVLB  8
16F4:  MOVWF  x0D
16F6:  MOVLW  2E
16F8:  ADDWF  x0D,W
16FA:  MOVWF  FE9
16FC:  MOVLW  02
16FE:  ADDWFC 03,W
1700:  MOVWF  FEA
1702:  MOVLW  01
1704:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1706:  MOVLB  6
1708:  MOVFF  6B8,03
170C:  MOVF   xB7,W
170E:  INCF   xB7,F
1710:  BTFSC  FD8.2
1712:  INCF   xB8,F
1714:  MOVLB  8
1716:  MOVWF  x0D
1718:  MOVLW  80
171A:  ADDWF  x0D,W
171C:  MOVWF  FE9
171E:  MOVLW  05
1720:  ADDWFC 03,W
1722:  MOVWF  FEA
1724:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1726:  MOVLB  6
1728:  MOVFF  6B8,03
172C:  MOVF   xB7,W
172E:  INCF   xB7,F
1730:  BTFSC  FD8.2
1732:  INCF   xB8,F
1734:  MOVLB  8
1736:  MOVWF  x0D
1738:  MOVLW  80
173A:  ADDWF  x0D,W
173C:  MOVWF  FE9
173E:  MOVLW  05
1740:  ADDWFC 03,W
1742:  MOVWF  FEA
1744:  MOVLW  01
1746:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1748:  MOVLB  6
174A:  MOVF   xB6,W
174C:  SUBLW  03
174E:  BTFSS  FD8.0
1750:  BRA    1830
1752:  BNZ   175C
1754:  MOVF   xB5,W
1756:  SUBLW  51
1758:  BTFSS  FD8.0
175A:  BRA    1830
175C:  MOVF   xB8,W
175E:  SUBLW  01
1760:  BTFSS  FD8.0
1762:  BRA    1830
1764:  BNZ   176C
1766:  MOVF   xB7,W
1768:  SUBLW  2B
176A:  BNC   1830
176C:  MOVF   xBA,W
176E:  SUBLW  FF
1770:  BNC   1830
1772:  BNZ   177A
1774:  MOVF   xB9,W
1776:  SUBLW  DB
1778:  BNC   1830
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
177A:  MOVF   xC3,F
177C:  BZ    1786
....................          { 
....................             bug_countbit_T1=0; 
177E:  CLRF   xB6
1780:  CLRF   xB5
....................             bug_countbit_T2=0; 
1782:  CLRF   xB8
1784:  CLRF   xB7
....................          } 
....................          card_timeout++; 
1786:  INCF   xB9,F
1788:  BTFSC  FD8.2
178A:  INCF   xBA,F
....................          mcr_timeout=0; 
178C:  CLRF   xAF
178E:  CLRF   xAE
1790:  CLRF   xAD
1792:  CLRF   xAC
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1794:  BSF    F93.2
1796:  MOVLB  8
1798:  CLRF   x04
179A:  BTFSC  F81.2
179C:  INCF   x04,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
179E:  MOVF   x04,F
17A0:  BNZ   17DE
17A2:  DECFSZ x05,W
17A4:  BRA    17DE
....................          { 
....................             ST1_old = 0; 
17A6:  CLRF   x05
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
17A8:  MOVLW  2E
17AA:  MOVLB  6
17AC:  ADDWF  xB5,W
17AE:  MOVWF  FE9
17B0:  MOVLW  02
17B2:  ADDWFC xB6,W
17B4:  MOVWF  FEA
17B6:  BSF    F93.1
17B8:  MOVLW  00
17BA:  BTFSS  F81.1
17BC:  MOVLW  01
17BE:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
17C0:  MOVLW  80
17C2:  ADDWF  xB7,W
17C4:  MOVWF  FE9
17C6:  MOVLW  05
17C8:  ADDWFC xB8,W
17CA:  MOVWF  FEA
17CC:  MOVFF  808,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
17D0:  INCF   xB5,F
17D2:  BTFSC  FD8.2
17D4:  INCF   xB6,F
....................             card_timeout=0; 
17D6:  CLRF   xBA
17D8:  CLRF   xB9
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
17DA:  BRA    17E8
17DC:  MOVLB  8
17DE:  DECFSZ x04,W
17E0:  BRA    17E6
17E2:  MOVLW  01
17E4:  MOVWF  x05
17E6:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
17E8:  BSF    F93.3
17EA:  MOVLB  8
17EC:  CLRF   x06
17EE:  BTFSC  F81.3
17F0:  INCF   x06,F
....................          if(ST2 == 0 && ST2_old == 1) 
17F2:  MOVF   x06,F
17F4:  BNZ   1814
17F6:  DECFSZ x07,W
17F8:  BRA    1814
....................          { 
....................             ST2_old = 0; 
17FA:  CLRF   x07
....................             Bit_t2 = !input(MCR_DATA2); 
17FC:  BSF    F94.5
17FE:  CLRF   x08
1800:  BTFSS  F82.5
1802:  INCF   x08,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1804:  MOVLB  6
1806:  INCF   xB7,F
1808:  BTFSC  FD8.2
180A:  INCF   xB8,F
....................             card_timeout=0; 
180C:  CLRF   xBA
180E:  CLRF   xB9
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1810:  BRA    181E
1812:  MOVLB  8
1814:  DECFSZ x06,W
1816:  BRA    181C
1818:  MOVLW  01
181A:  MOVWF  x07
181C:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
181E:  BSF    F93.0
1820:  BTFSS  F81.0
1822:  BRA    182E
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1824:  CLRF   xC3
....................             card_timeout=65500; 
1826:  SETF   xBA
1828:  MOVLW  DC
182A:  MOVWF  xB9
....................             break;            
182C:  BRA    1830
....................          } 
....................       } 
182E:  BRA    174A
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1830:  CLRF   xBA
1832:  CLRF   xB9
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1834:  MOVLB  8
1836:  CLRF   x16
1838:  MOVFF  6B6,818
183C:  MOVFF  6B5,817
1840:  MOVLW  02
1842:  MOVWF  x1A
1844:  MOVLW  2E
1846:  MOVWF  x19
1848:  MOVLB  0
184A:  CALL   07EA
184E:  MOVFF  01,809
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1852:  MOVLW  01
1854:  MOVLB  8
1856:  MOVWF  x16
1858:  MOVFF  6B8,818
185C:  MOVFF  6B7,817
1860:  MOVLW  05
1862:  MOVWF  x1A
1864:  MOVLW  80
1866:  MOVWF  x19
1868:  MOVLB  0
186A:  CALL   07EA
186E:  MOVFF  01,80A
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1872:  MOVLB  6
1874:  DECFSZ xBE,W
1876:  BRA    1918
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1878:  MOVLW  A8
187A:  MOVWF  FF6
187C:  MOVLW  03
187E:  MOVWF  FF7
1880:  MOVLW  0E
1882:  MOVLB  8
1884:  MOVWF  x24
1886:  MOVLB  0
1888:  RCALL  13EC
188A:  MOVLW  10
188C:  MOVWF  FE9
188E:  MOVFF  6B6,80E
1892:  MOVFF  6B5,80D
1896:  RCALL  1416
1898:  MOVLW  0D
189A:  MOVLB  8
189C:  MOVWF  x30
189E:  MOVLB  0
18A0:  CALL   0422
18A4:  MOVLW  0A
18A6:  MOVLB  8
18A8:  MOVWF  x30
18AA:  MOVLB  0
18AC:  CALL   0422
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
18B0:  MOVLW  BC
18B2:  MOVWF  FF6
18B4:  MOVLW  03
18B6:  MOVWF  FF7
18B8:  MOVLW  0E
18BA:  MOVLB  8
18BC:  MOVWF  x24
18BE:  MOVLB  0
18C0:  RCALL  13EC
18C2:  MOVLW  10
18C4:  MOVWF  FE9
18C6:  MOVFF  6B8,80E
18CA:  MOVFF  6B7,80D
18CE:  RCALL  1416
18D0:  MOVLW  0D
18D2:  MOVLB  8
18D4:  MOVWF  x30
18D6:  MOVLB  0
18D8:  CALL   0422
18DC:  MOVLW  0A
18DE:  MOVLB  8
18E0:  MOVWF  x30
18E2:  MOVLB  0
18E4:  CALL   0422
....................          debug_reader();       
18E8:  BRA    15C4
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
18EA:  MOVLB  8
18EC:  MOVF   x09,F
18EE:  BNZ   1900
18F0:  MOVLW  D0
18F2:  MOVWF  FF6
18F4:  MOVLW  03
18F6:  MOVWF  FF7
18F8:  MOVLB  0
18FA:  CALL   0474
18FE:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1900:  MOVF   x0A,F
1902:  BNZ   1914
1904:  MOVLW  E6
1906:  MOVWF  FF6
1908:  MOVLW  03
190A:  MOVWF  FF7
190C:  MOVLB  0
190E:  CALL   0474
1912:  MOVLB  8
....................       } 
....................          else 
1914:  BRA    1924
1916:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1918:  MOVLW  0F
191A:  MOVLB  8
191C:  MOVWF  x0D
191E:  MOVLB  0
1920:  RCALL  1658
1922:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1924:  MOVF   x09,F
1926:  BZ    192C
1928:  MOVF   x0A,F
192A:  BNZ   194C
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
192C:  MOVLB  6
192E:  CLRF   xB8
1930:  CLRF   xB7
....................          bug_countbit_T1=0; 
1932:  CLRF   xB6
1934:  CLRF   xB5
....................          reading_fg=0; 
1936:  CLRF   xC2
....................          count_reading_error++; 
1938:  INCF   xC3,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
193A:  CLRF   xAF
193C:  CLRF   xAE
193E:  CLRF   xAD
1940:  CLRF   xAC
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1942:  MOVLW  00
1944:  MOVWF  01
1946:  BRA    1984
....................       } 
....................          else  
1948:  BRA    1980
194A:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
194C:  MOVLW  01
194E:  MOVLB  6
1950:  MOVWF  xBD
....................             reading_fg=1; 
1952:  MOVWF  xC2
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1954:  MOVFF  6B8,6B4
1958:  MOVFF  6B7,6B3
....................             countbit_T1=bug_countbit_T1; 
195C:  MOVFF  6B6,6B2
1960:  MOVFF  6B5,6B1
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1964:  CLRF   xB6
1966:  CLRF   xB5
....................             bug_countbit_T2=0;  
1968:  CLRF   xB8
196A:  CLRF   xB7
....................             mcr_timeout=0; 
196C:  CLRF   xAF
196E:  CLRF   xAE
1970:  CLRF   xAD
1972:  CLRF   xAC
....................             charac_timeout=0; 
1974:  MOVLB  1
1976:  CLRF   x1D
1978:  CLRF   x1C
....................             return 1; 
197A:  MOVWF  01
197C:  MOVLB  6
197E:  BRA    1984
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1980:  MOVLW  00
1982:  MOVWF  01
.................... } 
1984:  MOVLB  0
1986:  GOTO   19F2 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
198A:  MOVLW  02
198C:  MOVLB  8
198E:  MOVWF  x04
1990:  MOVLW  FA
1992:  MOVWF  x05
1994:  MOVLB  0
1996:  GOTO   03FC
199A:  MOVLB  8
199C:  DECFSZ x04,F
199E:  BRA    1990
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
19A0:  MOVLB  6
19A2:  DECFSZ xC0,W
19A4:  BRA    19A8
19A6:  BRA    1A04
....................       if((KP_mode)&&(enable_getpin==0)&&(booting==1)) 
19A8:  MOVLB  1
19AA:  MOVF   x30,F
19AC:  BZ    19EE
19AE:  MOVF   x2D,F
19B0:  BNZ   19EE
19B2:  DECFSZ x26,W
19B4:  BRA    19EE
....................       { 
....................          if(kp_st==1) 
19B6:  DECFSZ x31,W
19B8:  BRA    19D2
....................          { 
....................             printf("\n\rKey release.\n\r"); 
19BA:  MOVLW  0C
19BC:  MOVWF  FF6
19BE:  MOVLW  1A
19C0:  MOVWF  FF7
19C2:  MOVLB  0
19C4:  CALL   0474
....................             keyprss_off; 
19C8:  BCF    F92.7
19CA:  BCF    F89.7
....................             kp_st=0; 
19CC:  MOVLB  1
19CE:  CLRF   x31
....................          } 
....................          else 
19D0:  BRA    19EE
....................          { 
....................             printf("\n\rKey press.\n\r"); 
19D2:  MOVLW  1E
19D4:  MOVWF  FF6
19D6:  MOVLW  1A
19D8:  MOVWF  FF7
19DA:  MOVLB  0
19DC:  CALL   0474
....................             keyprss_on; 
19E0:  BCF    F92.7
19E2:  BSF    F89.7
....................             kp_st=1;  
19E4:  MOVLW  01
19E6:  MOVLB  1
19E8:  MOVWF  x31
....................             count_kp=0; 
19EA:  CLRF   x33
19EC:  CLRF   x32
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
19EE:  MOVLB  0
19F0:  BRA    1680
19F2:  MOVFF  01,6BF
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
19F6:  MOVLB  6
19F8:  CLRF   xAF
19FA:  CLRF   xAE
19FC:  CLRF   xAD
19FE:  CLRF   xAC
....................       card_timeout=0; 
1A00:  CLRF   xBA
1A02:  CLRF   xB9
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1A04:  BCF    FF0.0
1A06:  MOVLB  0
1A08:  GOTO   006C
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
4DDA:  CLRF   19
4DDC:  BTFSC  FF2.7
4DDE:  BSF    19.7
4DE0:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
4DE2:  MOVLB  8
4DE4:  CLRF   x1B
4DE6:  CLRF   x1A
4DE8:  CLRF   x19
4DEA:  MOVLW  94
4DEC:  MOVWF  x18
4DEE:  MOVLW  03
4DF0:  MOVWF  x1C
4DF2:  MOVLB  0
4DF4:  CALL   3830
4DF8:  BTFSC  19.7
4DFA:  BSF    FF2.7
4DFC:  CLRF   19
4DFE:  BTFSC  FF2.7
4E00:  BSF    19.7
4E02:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
4E04:  MOVLB  8
4E06:  CLRF   x1B
4E08:  CLRF   x1A
4E0A:  CLRF   x19
4E0C:  MOVLW  91
4E0E:  MOVWF  x18
4E10:  MOVLW  01
4E12:  MOVWF  x1C
4E14:  MOVLB  0
4E16:  CALL   3830
4E1A:  BTFSC  19.7
4E1C:  BSF    FF2.7
4E1E:  CLRF   19
4E20:  BTFSC  FF2.7
4E22:  BSF    19.7
4E24:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
4E26:  MOVLB  8
4E28:  CLRF   x13
4E2A:  CLRF   x12
4E2C:  CLRF   x11
4E2E:  MOVLW  91
4E30:  MOVWF  x10
4E32:  MOVLB  0
4E34:  CALL   32E0
4E38:  BTFSC  19.7
4E3A:  BSF    FF2.7
4E3C:  MOVFF  01,6CA
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
....................    #endif 
....................     
.................... } 
4E40:  GOTO   5786 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
5120:  MOVLW  06
5122:  MOVWF  FEA
5124:  MOVLW  CF
5126:  MOVWF  FE9
5128:  BRA    49F6
512A:  CLRF   19
512C:  BTFSC  FF2.7
512E:  BSF    19.7
5130:  BCF    FF2.7
5132:  MOVLW  3E
5134:  MOVLB  8
5136:  MOVWF  x30
5138:  MOVLB  0
513A:  CALL   0422
513E:  BTFSC  19.7
5140:  BSF    FF2.7
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
5142:  MOVLW  01
5144:  MOVLB  7
5146:  MOVWF  xDB
5148:  MOVLW  14
514A:  MOVWF  xDC
514C:  MOVLW  01
514E:  MOVWF  xDE
5150:  MOVLW  4D
5152:  MOVWF  xDD
5154:  MOVLB  0
5156:  CALL   4826
515A:  CLRF   19
515C:  BTFSC  FF2.7
515E:  BSF    19.7
5160:  BCF    FF2.7
....................       printf("\n\r"); 
5162:  MOVLW  0A
5164:  MOVLB  8
5166:  MOVWF  x30
5168:  MOVLB  0
516A:  CALL   0422
516E:  BTFSC  19.7
5170:  BSF    FF2.7
5172:  CLRF   19
5174:  BTFSC  FF2.7
5176:  BSF    19.7
5178:  BCF    FF2.7
517A:  MOVLW  0D
517C:  MOVLB  8
517E:  MOVWF  x30
5180:  MOVLB  0
5182:  CALL   0422
5186:  BTFSC  19.7
5188:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
518A:  CLRF   FEA
518C:  MOVLW  62
518E:  MOVWF  FE9
5190:  MOVLW  00
5192:  CALL   011C
5196:  TBLRD*-
5198:  TBLRD*+
519A:  MOVF   FF5,W
519C:  MOVWF  FEE
519E:  IORLW  00
51A0:  BNZ   5198
....................       index=0; 
51A2:  MOVLB  7
51A4:  CLRF   xA5
....................       ee_dat=0; 
51A6:  MOVLB  6
51A8:  CLRF   xC5
....................       count_card=1; 
51AA:  CLRF   xC7
51AC:  MOVLW  01
51AE:  MOVWF  xC6
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
51B0:  MOVLB  7
51B2:  MOVWF  xDC
51B4:  MOVLW  4D
51B6:  MOVWF  xDB
51B8:  CLRF   xDE
51BA:  MOVLW  62
51BC:  MOVWF  xDD
51BE:  MOVLB  0
51C0:  CALL   495E
51C4:  MOVF   01,F
51C6:  BTFSS  FD8.2
51C8:  BRA    55B0
....................       { 
....................          unsigned long adr=0; 
51CA:  MOVLB  7
51CC:  CLRF   xDA
51CE:  CLRF   xD9
....................          //unsigned int count=0; 
....................          rec[0]=0; 
51D0:  MOVLB  0
51D2:  CLRF   x9E
51D4:  CLRF   19
51D6:  BTFSC  FF2.7
51D8:  BSF    19.7
51DA:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
51DC:  CALL   33AC
51E0:  BTFSC  19.7
51E2:  BSF    FF2.7
51E4:  MOVFF  02,6C9
51E8:  MOVFF  01,6C8
51EC:  CLRF   19
51EE:  BTFSC  FF2.7
51F0:  BSF    19.7
51F2:  BCF    FF2.7
....................          adr=count_card*numdata; 
51F4:  MOVFF  6C7,80D
51F8:  MOVFF  6C6,80C
51FC:  MOVLB  8
51FE:  CLRF   x0F
5200:  MOVLW  7C
5202:  MOVWF  x0E
5204:  MOVLB  0
5206:  CALL   3404
520A:  BTFSC  19.7
520C:  BSF    FF2.7
520E:  MOVFF  02,7DA
5212:  MOVFF  01,7D9
....................          addr_key=EEPROM_KEY_ST; 
5216:  MOVLB  6
5218:  CLRF   xCE
521A:  MOVLW  01
521C:  MOVWF  xCD
521E:  MOVLW  C3
5220:  MOVWF  xCC
5222:  MOVLW  0F
5224:  MOVWF  xCB
....................          while(count_card<=count_card_tg) 
....................          { 
5226:  MOVF   xC7,W
5228:  SUBWF  xC9,W
522A:  BTFSS  FD8.0
522C:  BRA    55AE
522E:  BNZ   5238
5230:  MOVF   xC6,W
5232:  SUBWF  xC8,W
5234:  BTFSS  FD8.0
5236:  BRA    55AE
5238:  CLRF   19
523A:  BTFSC  FF2.7
523C:  BSF    19.7
523E:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
5240:  MOVFF  6C7,80D
5244:  MOVFF  6C6,80C
5248:  MOVLB  8
524A:  CLRF   x0F
524C:  MOVLW  7C
524E:  MOVWF  x0E
5250:  MOVLB  0
5252:  CALL   3404
5256:  BTFSC  19.7
5258:  BSF    FF2.7
525A:  MOVLW  96
525C:  MOVLB  7
525E:  ADDWF  01,W
5260:  MOVWF  xD9
5262:  MOVLW  00
5264:  ADDWFC 02,W
5266:  MOVWF  xDA
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
5268:  MOVLW  7C
526A:  SUBWF  xD9,W
526C:  MOVWF  xDB
526E:  MOVLW  00
5270:  SUBWFB xDA,W
5272:  MOVWF  xDC
5274:  MOVWF  xDE
5276:  MOVFF  7DB,7DD
527A:  CLRF   xE0
527C:  MOVLW  7C
527E:  MOVWF  xDF
5280:  CLRF   xE2
5282:  MOVLW  9E
5284:  MOVWF  xE1
5286:  MOVLB  0
5288:  GOTO   4A2A
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
528C:  MOVLW  10
528E:  MOVWF  FE9
5290:  CLRF   19
5292:  BTFSC  FF2.7
5294:  BSF    19.7
5296:  BCF    FF2.7
5298:  MOVFF  6C7,808
529C:  MOVFF  6C6,807
52A0:  CALL   3F96
52A4:  BTFSC  19.7
52A6:  BSF    FF2.7
52A8:  CLRF   19
52AA:  BTFSC  FF2.7
52AC:  BSF    19.7
52AE:  BCF    FF2.7
52B0:  MOVLW  29
52B2:  MOVLB  8
52B4:  MOVWF  x30
52B6:  MOVLB  0
52B8:  CALL   0422
52BC:  BTFSC  19.7
52BE:  BSF    FF2.7
52C0:  MOVFF  9E,7DB
52C4:  MOVLW  01
52C6:  MOVLB  7
52C8:  MOVWF  xDC
52CA:  MOVLB  0
52CC:  CALL   4AA0
52D0:  CLRF   19
52D2:  BTFSC  FF2.7
52D4:  BSF    19.7
52D6:  BCF    FF2.7
52D8:  MOVLW  2F
52DA:  MOVLB  8
52DC:  MOVWF  x30
52DE:  MOVLB  0
52E0:  CALL   0422
52E4:  BTFSC  19.7
52E6:  BSF    FF2.7
52E8:  MOVFF  9F,7DB
52EC:  MOVLW  01
52EE:  MOVLB  7
52F0:  MOVWF  xDC
52F2:  MOVLB  0
52F4:  CALL   4AA0
52F8:  CLRF   19
52FA:  BTFSC  FF2.7
52FC:  BSF    19.7
52FE:  BCF    FF2.7
5300:  MOVLW  20
5302:  MOVLB  8
5304:  MOVWF  x30
5306:  MOVLB  0
5308:  CALL   0422
530C:  BTFSC  19.7
530E:  BSF    FF2.7
5310:  MOVFF  A0,7DB
5314:  MOVLW  01
5316:  MOVLB  7
5318:  MOVWF  xDC
531A:  MOVLB  0
531C:  CALL   4AA0
5320:  CLRF   19
5322:  BTFSC  FF2.7
5324:  BSF    19.7
5326:  BCF    FF2.7
5328:  MOVLW  3A
532A:  MOVLB  8
532C:  MOVWF  x30
532E:  MOVLB  0
5330:  CALL   0422
5334:  BTFSC  19.7
5336:  BSF    FF2.7
5338:  MOVFF  A1,7DB
533C:  MOVLW  01
533E:  MOVLB  7
5340:  MOVWF  xDC
5342:  MOVLB  0
5344:  CALL   4AA0
5348:  CLRF   19
534A:  BTFSC  FF2.7
534C:  BSF    19.7
534E:  BCF    FF2.7
5350:  MOVLW  3A
5352:  MOVLB  8
5354:  MOVWF  x30
5356:  MOVLB  0
5358:  CALL   0422
535C:  BTFSC  19.7
535E:  BSF    FF2.7
5360:  MOVFF  A2,7DB
5364:  MOVLW  01
5366:  MOVLB  7
5368:  MOVWF  xDC
536A:  MOVLB  0
536C:  CALL   4AA0
....................             ee_dat=0; 
5370:  MOVLB  6
5372:  CLRF   xC5
....................             index=0; 
5374:  MOVLB  7
5376:  CLRF   xA5
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
5378:  MOVLW  52
537A:  MOVWF  FF6
537C:  MOVLW  1A
537E:  MOVWF  FF7
5380:  CLRF   19
5382:  BTFSC  FF2.7
5384:  BSF    19.7
5386:  BCF    FF2.7
5388:  MOVLB  0
538A:  CALL   0474
538E:  BTFSC  19.7
5390:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
5392:  MOVLB  7
5394:  MOVF   xA5,W
5396:  SUBLW  4E
5398:  BNC   53F6
539A:  MOVLB  6
539C:  MOVF   xC5,W
539E:  SUBLW  3F
53A0:  BTFSS  FD8.2
53A2:  BRA    53A8
53A4:  MOVLB  7
53A6:  BRA    53F6
....................                ee_dat = rec[index+5]; 
53A8:  MOVLW  05
53AA:  MOVLB  7
53AC:  ADDWF  xA5,W
53AE:  CLRF   03
53B0:  ADDLW  9E
53B2:  MOVWF  FE9
53B4:  MOVLW  00
53B6:  ADDWFC 03,W
53B8:  MOVWF  FEA
53BA:  MOVFF  FEF,6C5
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
53BE:  MOVLB  6
53C0:  MOVF   xC5,W
53C2:  SUBLW  1F
53C4:  BC    53E2
53C6:  MOVF   xC5,W
53C8:  SUBLW  7E
53CA:  BNC   53E2
53CC:  CLRF   19
53CE:  BTFSC  FF2.7
53D0:  BSF    19.7
53D2:  BCF    FF2.7
53D4:  MOVFF  6C5,830
53D8:  MOVLB  0
53DA:  CALL   0422
53DE:  BTFSC  19.7
53E0:  BSF    FF2.7
....................                index++; 
53E2:  MOVLB  7
53E4:  INCF   xA5,F
....................                if(ee_dat==0)break; 
53E6:  MOVLB  6
53E8:  MOVF   xC5,F
53EA:  BNZ   53F0
53EC:  MOVLB  7
53EE:  BRA    53F6
....................             } 
53F0:  MOVLB  0
53F2:  BRA    5392
53F4:  MOVLB  7
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
53F6:  MOVLW  64
53F8:  MOVWF  FF6
53FA:  MOVLW  1A
53FC:  MOVWF  FF7
53FE:  CLRF   19
5400:  BTFSC  FF2.7
5402:  BSF    19.7
5404:  BCF    FF2.7
5406:  MOVLB  0
5408:  CALL   0474
540C:  BTFSC  19.7
540E:  BSF    FF2.7
....................             index=0; 
5410:  MOVLB  7
5412:  CLRF   xA5
....................             ee_dat=0; 
5414:  MOVLB  6
5416:  CLRF   xC5
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
5418:  MOVLB  7
541A:  MOVF   xA5,W
541C:  SUBLW  27
541E:  BNC   547E
5420:  MOVLB  6
5422:  MOVF   xC5,W
5424:  SUBLW  3F
5426:  BTFSS  FD8.2
5428:  BRA    542E
542A:  MOVLB  7
542C:  BRA    547E
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
542E:  MOVLW  05
5430:  MOVLB  7
5432:  ADDWF  xA5,W
5434:  ADDLW  4F
5436:  CLRF   03
5438:  ADDLW  9E
543A:  MOVWF  FE9
543C:  MOVLW  00
543E:  ADDWFC 03,W
5440:  MOVWF  FEA
5442:  MOVFF  FEF,6C5
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
5446:  MOVLB  6
5448:  MOVF   xC5,W
544A:  SUBLW  1F
544C:  BC    546A
544E:  MOVF   xC5,W
5450:  SUBLW  7E
5452:  BNC   546A
5454:  CLRF   19
5456:  BTFSC  FF2.7
5458:  BSF    19.7
545A:  BCF    FF2.7
545C:  MOVFF  6C5,830
5460:  MOVLB  0
5462:  CALL   0422
5466:  BTFSC  19.7
5468:  BSF    FF2.7
....................                index++; 
546A:  MOVLB  7
546C:  INCF   xA5,F
....................                if(ee_dat==0)break; 
546E:  MOVLB  6
5470:  MOVF   xC5,F
5472:  BNZ   547A
5474:  MOVLB  7
5476:  BRA    547E
5478:  MOVLB  6
....................             } 
547A:  BRA    5418
547C:  MOVLB  7
....................             index=0; 
547E:  CLRF   xA5
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
5480:  MOVLW  76
5482:  MOVWF  FF6
5484:  MOVLW  1A
5486:  MOVWF  FF7
5488:  CLRF   19
548A:  BTFSC  FF2.7
548C:  BSF    19.7
548E:  BCF    FF2.7
5490:  MOVLB  0
5492:  CALL   0474
5496:  BTFSC  19.7
5498:  BSF    FF2.7
....................             //fprintf(COM2,"addr_key =%lu \n\r",addr_key);  
....................             //fprintf(COM2," ptr_card_key=%lu \n\r",ptr_card_key);  
....................             if(ptr_card_key>addr_key) 
549A:  MOVLB  6
549C:  MOVF   xCE,W
549E:  SUBWF  27,W
54A0:  BTFSS  FD8.0
54A2:  BRA    55A6
54A4:  BNZ   54C2
54A6:  MOVF   xCD,W
54A8:  SUBWF  26,W
54AA:  BTFSS  FD8.0
54AC:  BRA    55A6
54AE:  BNZ   54C2
54B0:  MOVF   xCC,W
54B2:  SUBWF  25,W
54B4:  BTFSS  FD8.0
54B6:  BRA    55A6
54B8:  BNZ   54C2
54BA:  MOVF   24,W
54BC:  SUBWF  xCB,W
54BE:  BTFSC  FD8.0
54C0:  BRA    55A6
....................             { 
....................                i=0; 
54C2:  MOVLB  7
54C4:  CLRF   xA6
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
54C6:  MOVF   xA6,W
54C8:  MOVLB  6
54CA:  ADDWF  xCB,W
54CC:  MOVLB  7
54CE:  MOVWF  xDB
54D0:  MOVLW  00
54D2:  MOVLB  6
54D4:  ADDWFC xCC,W
54D6:  MOVLB  7
54D8:  MOVWF  xDC
54DA:  MOVLW  00
54DC:  MOVLB  6
54DE:  ADDWFC xCD,W
54E0:  MOVLB  7
54E2:  MOVWF  xDD
54E4:  MOVLW  00
54E6:  MOVLB  6
54E8:  ADDWFC xCE,W
54EA:  MOVLB  7
54EC:  MOVWF  xDE
54EE:  CLRF   19
54F0:  BTFSC  FF2.7
54F2:  BSF    19.7
54F4:  BCF    FF2.7
54F6:  MOVFF  FE8,813
54FA:  MOVFF  7DD,812
54FE:  MOVFF  7DC,811
5502:  MOVFF  7DB,810
5506:  MOVLB  0
5508:  CALL   32E0
550C:  BTFSC  19.7
550E:  BSF    FF2.7
5510:  MOVFF  01,6C5
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
5514:  MOVLB  6
5516:  MOVF   xC5,W
5518:  SUBLW  2F
551A:  BC    5522
551C:  MOVF   xC5,W
551E:  SUBLW  39
5520:  BC    553A
5522:  MOVF   xC5,W
5524:  SUBLW  23
5526:  BZ    553A
5528:  MOVF   xC5,W
552A:  SUBLW  2A
552C:  BZ    553A
552E:  MOVF   xC5,W
5530:  SUBLW  40
5532:  BC    5550
5534:  MOVF   xC5,W
5536:  SUBLW  5A
5538:  BNC   5550
553A:  CLRF   19
553C:  BTFSC  FF2.7
553E:  BSF    19.7
5540:  BCF    FF2.7
....................                      fputc(ee_dat,COM2); 
5542:  MOVFF  6C5,830
5546:  MOVLB  0
5548:  CALL   0422
554C:  BTFSC  19.7
554E:  BSF    FF2.7
....................                   i++; 
5550:  MOVLB  7
5552:  INCF   xA6,F
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
5554:  MOVF   xA6,W
5556:  SUBLW  0F
5558:  BNC   5566
555A:  MOVLB  6
555C:  MOVF   xC5,F
555E:  BTFSC  FD8.2
5560:  BRA    5566
5562:  MOVLB  7
5564:  BRA    54C6
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+key_numbyte; 
5566:  MOVLW  10
5568:  MOVLB  6
556A:  ADDWF  xCB,F
556C:  MOVLW  00
556E:  ADDWFC xCC,F
5570:  ADDWFC xCD,F
5572:  ADDWFC xCE,F
5574:  CLRF   19
5576:  BTFSC  FF2.7
5578:  BSF    19.7
557A:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
557C:  MOVLW  0A
557E:  MOVLB  8
5580:  MOVWF  x30
5582:  MOVLB  0
5584:  CALL   0422
5588:  BTFSC  19.7
558A:  BSF    FF2.7
558C:  CLRF   19
558E:  BTFSC  FF2.7
5590:  BSF    19.7
5592:  BCF    FF2.7
5594:  MOVLW  0D
5596:  MOVLB  8
5598:  MOVWF  x30
559A:  MOVLB  0
559C:  CALL   0422
55A0:  BTFSC  19.7
55A2:  BSF    FF2.7
55A4:  MOVLB  6
....................             } 
....................             count_card++; 
55A6:  INCF   xC6,F
55A8:  BTFSC  FD8.2
55AA:  INCF   xC7,F
....................          } 
55AC:  BRA    5226
55AE:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
55B0:  CLRF   FEA
55B2:  MOVLW  62
55B4:  MOVWF  FE9
55B6:  MOVLW  00
55B8:  CALL   012E
55BC:  TBLRD*-
55BE:  TBLRD*+
55C0:  MOVF   FF5,W
55C2:  MOVWF  FEE
55C4:  IORLW  00
55C6:  BNZ   55BE
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
55C8:  MOVLW  01
55CA:  MOVLB  7
55CC:  MOVWF  xDC
55CE:  MOVLW  4D
55D0:  MOVWF  xDB
55D2:  CLRF   xDE
55D4:  MOVLW  62
55D6:  MOVWF  xDD
55D8:  MOVLB  0
55DA:  CALL   495E
55DE:  MOVF   01,F
55E0:  BNZ   5616
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
55E2:  MOVLW  86
55E4:  MOVWF  FF6
55E6:  MOVLW  1A
55E8:  MOVWF  FF7
55EA:  CLRF   19
55EC:  BTFSC  FF2.7
55EE:  BSF    19.7
55F0:  BCF    FF2.7
55F2:  CALL   0474
55F6:  BTFSC  19.7
55F8:  BSF    FF2.7
....................          format_eepromext(); 
55FA:  GOTO   4BBA
....................          fprintf(COM2," exit\n\r");  
55FE:  MOVLW  94
5600:  MOVWF  FF6
5602:  MOVLW  1A
5604:  MOVWF  FF7
5606:  CLRF   19
5608:  BTFSC  FF2.7
560A:  BSF    19.7
560C:  BCF    FF2.7
560E:  CALL   0474
5612:  BTFSC  19.7
5614:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
5616:  CLRF   FEA
5618:  MOVLW  62
561A:  MOVWF  FE9
561C:  MOVLW  00
561E:  CALL   0140
5622:  TBLRD*-
5624:  TBLRD*+
5626:  MOVF   FF5,W
5628:  MOVWF  FEE
562A:  IORLW  00
562C:  BNZ   5624
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
562E:  MOVLW  01
5630:  MOVLB  7
5632:  MOVWF  xDC
5634:  MOVLW  4D
5636:  MOVWF  xDB
5638:  CLRF   xDE
563A:  MOVLW  62
563C:  MOVWF  xDD
563E:  MOVLB  0
5640:  CALL   495E
5644:  MOVF   01,F
5646:  BNZ   567C
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
5648:  MOVLW  9C
564A:  MOVWF  FF6
564C:  MOVLW  1A
564E:  MOVWF  FF7
5650:  CLRF   19
5652:  BTFSC  FF2.7
5654:  BSF    19.7
5656:  BCF    FF2.7
5658:  CALL   0474
565C:  BTFSC  19.7
565E:  BSF    FF2.7
....................          ease_eeprom(); 
5660:  GOTO   4D20
....................          fprintf(COM2," exit\n\r");  
5664:  MOVLW  AA
5666:  MOVWF  FF6
5668:  MOVLW  1A
566A:  MOVWF  FF7
566C:  CLRF   19
566E:  BTFSC  FF2.7
5670:  BSF    19.7
5672:  BCF    FF2.7
5674:  CALL   0474
5678:  BTFSC  19.7
567A:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
567C:  CLRF   FEA
567E:  MOVLW  62
5680:  MOVWF  FE9
5682:  MOVLW  00
5684:  CALL   0156
5688:  TBLRD*-
568A:  TBLRD*+
568C:  MOVF   FF5,W
568E:  MOVWF  FEE
5690:  IORLW  00
5692:  BNZ   568A
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5694:  MOVLW  01
5696:  MOVLB  7
5698:  MOVWF  xDC
569A:  MOVLW  4D
569C:  MOVWF  xDB
569E:  CLRF   xDE
56A0:  MOVLW  62
56A2:  MOVWF  xDD
56A4:  MOVLB  0
56A6:  CALL   495E
56AA:  MOVF   01,F
56AC:  BNZ   56E6
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
56AE:  MOVLW  B2
56B0:  MOVWF  FF6
56B2:  MOVLW  1A
56B4:  MOVWF  FF7
56B6:  CLRF   19
56B8:  BTFSC  FF2.7
56BA:  BSF    19.7
56BC:  BCF    FF2.7
56BE:  CALL   0474
56C2:  BTFSC  19.7
56C4:  BSF    FF2.7
....................          reset_password(); 
56C6:  GOTO   4DA4
....................          init_password(); 
56CA:  CALL   442E
....................          fprintf(COM2," exit\n\r");  
56CE:  MOVLW  C8
56D0:  MOVWF  FF6
56D2:  MOVLW  1A
56D4:  MOVWF  FF7
56D6:  CLRF   19
56D8:  BTFSC  FF2.7
56DA:  BSF    19.7
56DC:  BCF    FF2.7
56DE:  CALL   0474
56E2:  BTFSC  19.7
56E4:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
56E6:  CLRF   FEA
56E8:  MOVLW  62
56EA:  MOVWF  FE9
56EC:  MOVLW  00
56EE:  CALL   016C
56F2:  TBLRD*-
56F4:  TBLRD*+
56F6:  MOVF   FF5,W
56F8:  MOVWF  FEE
56FA:  IORLW  00
56FC:  BNZ   56F4
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
56FE:  MOVLW  01
5700:  MOVLB  7
5702:  MOVWF  xDC
5704:  MOVLW  4D
5706:  MOVWF  xDB
5708:  CLRF   xDE
570A:  MOVLW  62
570C:  MOVWF  xDD
570E:  MOVLB  0
5710:  CALL   495E
5714:  MOVF   01,F
5716:  BNZ   5738
....................       { 
....................          keydebug_en=1; 
5718:  MOVLW  01
571A:  MOVLB  1
571C:  MOVWF  x2C
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
571E:  MOVLW  D0
5720:  MOVWF  FF6
5722:  MOVLW  1A
5724:  MOVWF  FF7
5726:  CLRF   19
5728:  BTFSC  FF2.7
572A:  BSF    19.7
572C:  BCF    FF2.7
572E:  MOVLB  0
5730:  CALL   0474
5734:  BTFSC  19.7
5736:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
5738:  CLRF   FEA
573A:  MOVLW  62
573C:  MOVWF  FE9
573E:  MOVLW  00
5740:  CALL   0182
5744:  TBLRD*-
5746:  TBLRD*+
5748:  MOVF   FF5,W
574A:  MOVWF  FEE
574C:  IORLW  00
574E:  BNZ   5746
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5750:  MOVLW  01
5752:  MOVLB  7
5754:  MOVWF  xDC
5756:  MOVLW  4D
5758:  MOVWF  xDB
575A:  CLRF   xDE
575C:  MOVLW  62
575E:  MOVWF  xDD
5760:  MOVLB  0
5762:  CALL   495E
5766:  MOVF   01,F
5768:  BNZ   5786
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
576A:  MOVLW  E4
576C:  MOVWF  FF6
576E:  MOVLW  1A
5770:  MOVWF  FF7
5772:  CLRF   19
5774:  BTFSC  FF2.7
5776:  BSF    19.7
5778:  BCF    FF2.7
577A:  CALL   0474
577E:  BTFSC  19.7
5780:  BSF    FF2.7
....................          rstfact(); 
5782:  GOTO   4DDA
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
5786:  CLRF   FEA
5788:  MOVLW  62
578A:  MOVWF  FE9
578C:  MOVLW  00
578E:  CALL   019A
5792:  TBLRD*-
5794:  TBLRD*+
5796:  MOVF   FF5,W
5798:  MOVWF  FEE
579A:  IORLW  00
579C:  BNZ   5794
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
579E:  MOVLW  01
57A0:  MOVLB  7
57A2:  MOVWF  xDC
57A4:  MOVLW  4D
57A6:  MOVWF  xDB
57A8:  CLRF   xDE
57AA:  MOVLW  62
57AC:  MOVWF  xDD
57AE:  MOVLB  0
57B0:  CALL   495E
57B4:  MOVF   01,F
57B6:  BNZ   57DE
....................       { 
....................          mode=LOGOFF; 
57B8:  MOVLB  6
57BA:  CLRF   xC4
....................          keydebug_en=0; 
57BC:  MOVLB  1
57BE:  CLRF   x2C
....................          set_tris_a(0xff); 
57C0:  MOVLW  FF
57C2:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
57C4:  MOVLW  F4
57C6:  MOVWF  FF6
57C8:  MOVLW  1A
57CA:  MOVWF  FF7
57CC:  CLRF   19
57CE:  BTFSC  FF2.7
57D0:  BSF    19.7
57D2:  BCF    FF2.7
57D4:  MOVLB  0
57D6:  CALL   0474
57DA:  BTFSC  19.7
57DC:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
57DE:  CLRF   FEA
57E0:  MOVLW  62
57E2:  MOVWF  FE9
57E4:  MOVLW  00
57E6:  CALL   01AC
57EA:  TBLRD*-
57EC:  TBLRD*+
57EE:  MOVF   FF5,W
57F0:  MOVWF  FEE
57F2:  IORLW  00
57F4:  BNZ   57EC
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
57F6:  MOVLW  01
57F8:  MOVLB  7
57FA:  MOVWF  xDC
57FC:  MOVLW  4D
57FE:  MOVWF  xDB
5800:  CLRF   xDE
5802:  MOVLW  62
5804:  MOVWF  xDD
5806:  MOVLB  0
5808:  CALL   495E
580C:  MOVF   01,F
580E:  BNZ   5870
....................       { 
....................          fprintf(COM2,"New console name>"); 
5810:  MOVLW  FC
5812:  MOVWF  FF6
5814:  MOVLW  1A
5816:  MOVWF  FF7
5818:  CLRF   19
581A:  BTFSC  FF2.7
581C:  BSF    19.7
581E:  BCF    FF2.7
5820:  CALL   0474
5824:  BTFSC  19.7
5826:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,16, console); 
5828:  MOVLW  01
582A:  MOVLB  7
582C:  MOVWF  xDB
582E:  MOVLW  10
5830:  MOVWF  xDC
5832:  MOVLW  06
5834:  MOVWF  xDE
5836:  MOVLW  CF
5838:  MOVWF  xDD
583A:  MOVLB  0
583C:  CALL   4826
....................          EEPROM_write(strobe_nameconsole,16,console); 
5840:  MOVLW  66
5842:  MOVLB  7
5844:  MOVWF  xF0
5846:  MOVLW  10
5848:  MOVWF  xF1
584A:  MOVLW  06
584C:  MOVWF  xF3
584E:  MOVLW  CF
5850:  MOVWF  xF2
5852:  MOVLB  0
5854:  CALL   43D6
....................          fprintf(COM2," OK\n\r"); 
5858:  MOVLW  0E
585A:  MOVWF  FF6
585C:  MOVLW  1B
585E:  MOVWF  FF7
5860:  CLRF   19
5862:  BTFSC  FF2.7
5864:  BSF    19.7
5866:  BCF    FF2.7
5868:  CALL   0474
586C:  BTFSC  19.7
586E:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
5870:  CLRF   FEA
5872:  MOVLW  62
5874:  MOVWF  FE9
5876:  MOVLW  00
5878:  CALL   01BE
587C:  TBLRD*-
587E:  TBLRD*+
5880:  MOVF   FF5,W
5882:  MOVWF  FEE
5884:  IORLW  00
5886:  BNZ   587E
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
5888:  MOVLW  01
588A:  MOVLB  7
588C:  MOVWF  xDC
588E:  MOVLW  4D
5890:  MOVWF  xDB
5892:  CLRF   xDE
5894:  MOVLW  62
5896:  MOVWF  xDD
5898:  MOVLB  0
589A:  CALL   495E
589E:  MOVF   01,F
58A0:  BTFSS  FD8.2
58A2:  BRA    5B08
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
*
596E:  MOVLB  8
5970:  CLRF   x13
5972:  CLRF   x12
5974:  CLRF   x11
5976:  MOVLW  91
5978:  MOVWF  x10
597A:  MOVLB  0
597C:  CALL   32E0
5980:  BTFSC  19.7
5982:  BSF    FF2.7
5984:  MOVFF  01,6CA
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
5988:  MOVLB  6
598A:  MOVF   xCA,F
598C:  BNZ   59AC
598E:  MOVLW  14
5990:  MOVWF  FF6
5992:  MOVLW  1B
5994:  MOVWF  FF7
5996:  CLRF   19
5998:  BTFSC  FF2.7
599A:  BSF    19.7
599C:  BCF    FF2.7
599E:  MOVLB  0
59A0:  CALL   0474
59A4:  BTFSC  19.7
59A6:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
59A8:  BRA    59C6
59AA:  MOVLB  6
59AC:  MOVLW  18
59AE:  MOVWF  FF6
59B0:  MOVLW  1B
59B2:  MOVWF  FF7
59B4:  CLRF   19
59B6:  BTFSC  FF2.7
59B8:  BSF    19.7
59BA:  BCF    FF2.7
59BC:  MOVLB  0
59BE:  CALL   0474
59C2:  BTFSC  19.7
59C4:  BSF    FF2.7
59C6:  CLRF   19
59C8:  BTFSC  FF2.7
59CA:  BSF    19.7
59CC:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
59CE:  MOVLB  8
59D0:  CLRF   x13
59D2:  CLRF   x12
59D4:  CLRF   x11
59D6:  MOVLW  94
59D8:  MOVWF  x10
59DA:  MOVLB  0
59DC:  CALL   32E0
59E0:  BTFSC  19.7
59E2:  BSF    FF2.7
59E4:  MOVFF  01,145
59E8:  CLRF   19
59EA:  BTFSC  FF2.7
59EC:  BSF    19.7
59EE:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
59F0:  MOVLW  5B
59F2:  MOVLB  8
59F4:  MOVWF  x30
59F6:  MOVLB  0
59F8:  CALL   0422
59FC:  BTFSC  19.7
59FE:  BSF    FF2.7
5A00:  MOVFF  145,7DB
5A04:  MOVLW  1B
5A06:  MOVLB  7
5A08:  MOVWF  xDC
5A0A:  MOVLB  0
5A0C:  GOTO   4E76
5A10:  CLRF   19
5A12:  BTFSC  FF2.7
5A14:  BSF    19.7
5A16:  BCF    FF2.7
5A18:  MOVLW  5D
5A1A:  MOVLB  8
5A1C:  MOVWF  x30
5A1E:  MOVLB  0
5A20:  CALL   0422
5A24:  BTFSC  19.7
5A26:  BSF    FF2.7
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
5A28:  MOVFF  121,7DB
5A2C:  MOVLW  01
5A2E:  MOVLB  7
5A30:  MOVWF  xDC
5A32:  MOVLB  0
5A34:  CALL   4AA0
5A38:  CLRF   19
5A3A:  BTFSC  FF2.7
5A3C:  BSF    19.7
5A3E:  BCF    FF2.7
5A40:  MOVLW  2F
5A42:  MOVLB  8
5A44:  MOVWF  x30
5A46:  MOVLB  0
5A48:  CALL   0422
5A4C:  BTFSC  19.7
5A4E:  BSF    FF2.7
5A50:  MOVFF  120,7DB
5A54:  MOVLW  01
5A56:  MOVLB  7
5A58:  MOVWF  xDC
5A5A:  MOVLB  0
5A5C:  CALL   4AA0
5A60:  CLRF   19
5A62:  BTFSC  FF2.7
5A64:  BSF    19.7
5A66:  BCF    FF2.7
5A68:  MOVLW  20
5A6A:  MOVLB  8
5A6C:  MOVWF  x30
5A6E:  MOVLB  0
5A70:  CALL   0422
5A74:  BTFSC  19.7
5A76:  BSF    FF2.7
5A78:  MOVFF  122,7DB
5A7C:  MOVLW  01
5A7E:  MOVLB  7
5A80:  MOVWF  xDC
5A82:  MOVLB  0
5A84:  CALL   4AA0
5A88:  CLRF   19
5A8A:  BTFSC  FF2.7
5A8C:  BSF    19.7
5A8E:  BCF    FF2.7
5A90:  MOVLW  3A
5A92:  MOVLB  8
5A94:  MOVWF  x30
5A96:  MOVLB  0
5A98:  CALL   0422
5A9C:  BTFSC  19.7
5A9E:  BSF    FF2.7
5AA0:  MOVFF  123,7DB
5AA4:  MOVLW  01
5AA6:  MOVLB  7
5AA8:  MOVWF  xDC
5AAA:  MOVLB  0
5AAC:  CALL   4AA0
5AB0:  CLRF   19
5AB2:  BTFSC  FF2.7
5AB4:  BSF    19.7
5AB6:  BCF    FF2.7
5AB8:  MOVLW  3A
5ABA:  MOVLB  8
5ABC:  MOVWF  x30
5ABE:  MOVLB  0
5AC0:  CALL   0422
5AC4:  BTFSC  19.7
5AC6:  BSF    FF2.7
5AC8:  MOVFF  124,7DB
5ACC:  MOVLW  01
5ACE:  MOVLB  7
5AD0:  MOVWF  xDC
5AD2:  MOVLB  0
5AD4:  CALL   4AA0
5AD8:  CLRF   19
5ADA:  BTFSC  FF2.7
5ADC:  BSF    19.7
5ADE:  BCF    FF2.7
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
5AE0:  MOVLW  0A
5AE2:  MOVLB  8
5AE4:  MOVWF  x30
5AE6:  MOVLB  0
5AE8:  CALL   0422
5AEC:  BTFSC  19.7
5AEE:  BSF    FF2.7
5AF0:  CLRF   19
5AF2:  BTFSC  FF2.7
5AF4:  BSF    19.7
5AF6:  BCF    FF2.7
5AF8:  MOVLW  0D
5AFA:  MOVLB  8
5AFC:  MOVWF  x30
5AFE:  MOVLB  0
5B00:  CALL   0422
5B04:  BTFSC  19.7
5B06:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
5B08:  CLRF   FEA
5B0A:  MOVLW  62
5B0C:  MOVWF  FE9
5B0E:  MOVLW  00
5B10:  CALL   01D0
5B14:  TBLRD*-
5B16:  TBLRD*+
5B18:  MOVF   FF5,W
5B1A:  MOVWF  FEE
5B1C:  IORLW  00
5B1E:  BNZ   5B16
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
5B20:  MOVLW  01
5B22:  MOVLB  7
5B24:  MOVWF  xDC
5B26:  MOVLW  4D
5B28:  MOVWF  xDB
5B2A:  CLRF   xDE
5B2C:  MOVLW  62
5B2E:  MOVWF  xDD
5B30:  MOVLB  0
5B32:  CALL   495E
5B36:  MOVF   01,F
5B38:  BTFSS  FD8.2
5B3A:  BRA    5D64
....................       { 
....................          fprintf(COM2,"Year>"); 
5B3C:  MOVLW  1C
5B3E:  MOVWF  FF6
5B40:  MOVLW  1B
5B42:  MOVWF  FF7
5B44:  CLRF   19
5B46:  BTFSC  FF2.7
5B48:  BSF    19.7
5B4A:  BCF    FF2.7
5B4C:  CALL   0474
5B50:  BTFSC  19.7
5B52:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
5B54:  MOVLW  01
5B56:  MOVLB  7
5B58:  MOVWF  xDB
5B5A:  MOVLW  03
5B5C:  MOVWF  xDC
5B5E:  MOVLW  07
5B60:  MOVWF  xDE
5B62:  MOVLW  A7
5B64:  MOVWF  xDD
5B66:  MOVLB  0
5B68:  CALL   4826
....................          year=(unsigned int8)strtoi(temp); 
5B6C:  MOVLW  07
5B6E:  MOVLB  7
5B70:  MOVWF  xDC
5B72:  MOVLW  A7
5B74:  MOVWF  xDB
5B76:  MOVLB  0
5B78:  CALL   4F3C
5B7C:  MOVFF  01,11F
....................          fprintf(COM2,"Month>"); 
5B80:  MOVLW  22
5B82:  MOVWF  FF6
5B84:  MOVLW  1B
5B86:  MOVWF  FF7
5B88:  CLRF   19
5B8A:  BTFSC  FF2.7
5B8C:  BSF    19.7
5B8E:  BCF    FF2.7
5B90:  CALL   0474
5B94:  BTFSC  19.7
5B96:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
5B98:  MOVLW  01
5B9A:  MOVLB  7
5B9C:  MOVWF  xDB
5B9E:  MOVLW  03
5BA0:  MOVWF  xDC
5BA2:  MOVLW  07
5BA4:  MOVWF  xDE
5BA6:  MOVLW  A7
5BA8:  MOVWF  xDD
5BAA:  MOVLB  0
5BAC:  CALL   4826
....................          mon=(unsigned int8)strtoi(temp); 
5BB0:  MOVLW  07
5BB2:  MOVLB  7
5BB4:  MOVWF  xDC
5BB6:  MOVLW  A7
5BB8:  MOVWF  xDB
5BBA:  MOVLB  0
5BBC:  CALL   4F3C
5BC0:  MOVFF  01,120
....................          fprintf(COM2,"Date>"); 
5BC4:  MOVLW  2A
5BC6:  MOVWF  FF6
5BC8:  MOVLW  1B
5BCA:  MOVWF  FF7
5BCC:  CLRF   19
5BCE:  BTFSC  FF2.7
5BD0:  BSF    19.7
5BD2:  BCF    FF2.7
5BD4:  CALL   0474
5BD8:  BTFSC  19.7
5BDA:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
5BDC:  MOVLW  01
5BDE:  MOVLB  7
5BE0:  MOVWF  xDB
5BE2:  MOVLW  03
5BE4:  MOVWF  xDC
5BE6:  MOVLW  07
5BE8:  MOVWF  xDE
5BEA:  MOVLW  A7
5BEC:  MOVWF  xDD
5BEE:  MOVLB  0
5BF0:  CALL   4826
....................          date = (unsigned int8)strtoi(temp); 
5BF4:  MOVLW  07
5BF6:  MOVLB  7
5BF8:  MOVWF  xDC
5BFA:  MOVLW  A7
5BFC:  MOVWF  xDB
5BFE:  MOVLB  0
5C00:  CALL   4F3C
5C04:  MOVFF  01,121
....................          fprintf(COM2,"Day>"); 
5C08:  MOVLW  30
5C0A:  MOVWF  FF6
5C0C:  MOVLW  1B
5C0E:  MOVWF  FF7
5C10:  CLRF   19
5C12:  BTFSC  FF2.7
5C14:  BSF    19.7
5C16:  BCF    FF2.7
5C18:  CALL   0474
5C1C:  BTFSC  19.7
5C1E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
5C20:  MOVLW  01
5C22:  MOVLB  7
5C24:  MOVWF  xDB
5C26:  MOVLW  03
5C28:  MOVWF  xDC
5C2A:  MOVLW  07
5C2C:  MOVWF  xDE
5C2E:  MOVLW  A7
5C30:  MOVWF  xDD
5C32:  MOVLB  0
5C34:  CALL   4826
....................          day = (unsigned int8)strtoi(temp); 
5C38:  MOVLW  07
5C3A:  MOVLB  7
5C3C:  MOVWF  xDC
5C3E:  MOVLW  A7
5C40:  MOVWF  xDB
5C42:  MOVLB  0
5C44:  CALL   4F3C
5C48:  MOVFF  01,11E
....................          fprintf(COM2,"Hour>"); 
5C4C:  MOVLW  36
5C4E:  MOVWF  FF6
5C50:  MOVLW  1B
5C52:  MOVWF  FF7
5C54:  CLRF   19
5C56:  BTFSC  FF2.7
5C58:  BSF    19.7
5C5A:  BCF    FF2.7
5C5C:  CALL   0474
5C60:  BTFSC  19.7
5C62:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
5C64:  MOVLW  01
5C66:  MOVLB  7
5C68:  MOVWF  xDB
5C6A:  MOVLW  03
5C6C:  MOVWF  xDC
5C6E:  MOVLW  07
5C70:  MOVWF  xDE
5C72:  MOVLW  A7
5C74:  MOVWF  xDD
5C76:  MOVLB  0
5C78:  CALL   4826
....................          h = (unsigned int8)strtoi(temp); 
5C7C:  MOVLW  07
5C7E:  MOVLB  7
5C80:  MOVWF  xDC
5C82:  MOVLW  A7
5C84:  MOVWF  xDB
5C86:  MOVLB  0
5C88:  CALL   4F3C
5C8C:  MOVFF  01,122
....................          fprintf(COM2,"Minutes>"); 
5C90:  MOVLW  3C
5C92:  MOVWF  FF6
5C94:  MOVLW  1B
5C96:  MOVWF  FF7
5C98:  CLRF   19
5C9A:  BTFSC  FF2.7
5C9C:  BSF    19.7
5C9E:  BCF    FF2.7
5CA0:  CALL   0474
5CA4:  BTFSC  19.7
5CA6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
5CA8:  MOVLW  01
5CAA:  MOVLB  7
5CAC:  MOVWF  xDB
5CAE:  MOVLW  03
5CB0:  MOVWF  xDC
5CB2:  MOVLW  07
5CB4:  MOVWF  xDE
5CB6:  MOVLW  A7
5CB8:  MOVWF  xDD
5CBA:  MOVLB  0
5CBC:  CALL   4826
....................          min = (unsigned int8)strtoi(temp);                   
5CC0:  MOVLW  07
5CC2:  MOVLB  7
5CC4:  MOVWF  xDC
5CC6:  MOVLW  A7
5CC8:  MOVWF  xDB
5CCA:  MOVLB  0
5CCC:  CALL   4F3C
5CD0:  MOVFF  01,123
....................          fprintf(COM2,"Seconds>"); 
5CD4:  MOVLW  46
5CD6:  MOVWF  FF6
5CD8:  MOVLW  1B
5CDA:  MOVWF  FF7
5CDC:  CLRF   19
5CDE:  BTFSC  FF2.7
5CE0:  BSF    19.7
5CE2:  BCF    FF2.7
5CE4:  CALL   0474
5CE8:  BTFSC  19.7
5CEA:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
5CEC:  MOVLW  01
5CEE:  MOVLB  7
5CF0:  MOVWF  xDB
5CF2:  MOVLW  03
5CF4:  MOVWF  xDC
5CF6:  MOVLW  07
5CF8:  MOVWF  xDE
5CFA:  MOVLW  A7
5CFC:  MOVWF  xDD
5CFE:  MOVLB  0
5D00:  CALL   4826
....................          sec = (unsigned int8)strtoi(temp);                   
5D04:  MOVLW  07
5D06:  MOVLB  7
5D08:  MOVWF  xDC
5D0A:  MOVLW  A7
5D0C:  MOVWF  xDB
5D0E:  MOVLB  0
5D10:  CALL   4F3C
5D14:  MOVFF  01,124
5D18:  CLRF   19
5D1A:  BTFSC  FF2.7
5D1C:  BSF    19.7
5D1E:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
5D20:  MOVLW  0A
5D22:  MOVLB  8
5D24:  MOVWF  x30
5D26:  MOVLB  0
5D28:  CALL   0422
5D2C:  BTFSC  19.7
5D2E:  BSF    FF2.7
5D30:  CLRF   19
5D32:  BTFSC  FF2.7
5D34:  BSF    19.7
5D36:  BCF    FF2.7
5D38:  MOVLW  0D
5D3A:  MOVLB  8
5D3C:  MOVWF  x30
5D3E:  MOVLB  0
5D40:  CALL   0422
5D44:  BTFSC  19.7
5D46:  BSF    FF2.7
....................          rtc_set_datetime(date,mon,year,day,h,min); 
5D48:  MOVFF  121,7DB
5D4C:  MOVFF  120,7DC
5D50:  MOVFF  11F,7DD
5D54:  MOVFF  11E,7DE
5D58:  MOVFF  122,7DF
5D5C:  MOVFF  123,7E0
5D60:  GOTO   5076
....................       } 
....................       strcpy(buffer2,"MS"); 
5D64:  CLRF   FEA
5D66:  MOVLW  62
5D68:  MOVWF  FE9
5D6A:  MOVLW  00
5D6C:  CALL   01E4
5D70:  TBLRD*-
5D72:  TBLRD*+
5D74:  MOVF   FF5,W
5D76:  MOVWF  FEE
5D78:  IORLW  00
5D7A:  BNZ   5D72
....................       if(!stringcomp(buffer_uart,buffer2)) 
5D7C:  MOVLW  01
5D7E:  MOVLB  7
5D80:  MOVWF  xDC
5D82:  MOVLW  4D
5D84:  MOVWF  xDB
5D86:  CLRF   xDE
5D88:  MOVLW  62
5D8A:  MOVWF  xDD
5D8C:  MOVLB  0
5D8E:  CALL   495E
5D92:  MOVF   01,F
5D94:  BTFSS  FD8.2
5D96:  BRA    5EAA
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
5D98:  MOVLW  50
5D9A:  MOVWF  FF6
5D9C:  MOVLW  1B
5D9E:  MOVWF  FF7
5DA0:  CLRF   19
5DA2:  BTFSC  FF2.7
5DA4:  BSF    19.7
5DA6:  BCF    FF2.7
5DA8:  CALL   0474
5DAC:  BTFSC  19.7
5DAE:  BSF    FF2.7
5DB0:  CLRF   19
5DB2:  BTFSC  FF2.7
5DB4:  BSF    19.7
5DB6:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5DB8:  MOVLW  0A
5DBA:  MOVLB  8
5DBC:  MOVWF  x30
5DBE:  MOVLB  0
5DC0:  CALL   0422
5DC4:  BTFSC  19.7
5DC6:  BSF    FF2.7
5DC8:  CLRF   19
5DCA:  BTFSC  FF2.7
5DCC:  BSF    19.7
5DCE:  BCF    FF2.7
5DD0:  MOVLW  0D
5DD2:  MOVLB  8
5DD4:  MOVWF  x30
5DD6:  MOVLB  0
5DD8:  CALL   0422
5DDC:  BTFSC  19.7
5DDE:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
5DE0:  MOVLW  70
5DE2:  MOVWF  FF6
5DE4:  MOVLW  1B
5DE6:  MOVWF  FF7
5DE8:  CLRF   19
5DEA:  BTFSC  FF2.7
5DEC:  BSF    19.7
5DEE:  BCF    FF2.7
5DF0:  CALL   0474
5DF4:  BTFSC  19.7
5DF6:  BSF    FF2.7
5DF8:  CLRF   19
5DFA:  BTFSC  FF2.7
5DFC:  BSF    19.7
5DFE:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5E00:  MOVLW  0A
5E02:  MOVLB  8
5E04:  MOVWF  x30
5E06:  MOVLB  0
5E08:  CALL   0422
5E0C:  BTFSC  19.7
5E0E:  BSF    FF2.7
5E10:  CLRF   19
5E12:  BTFSC  FF2.7
5E14:  BSF    19.7
5E16:  BCF    FF2.7
5E18:  MOVLW  0D
5E1A:  MOVLB  8
5E1C:  MOVWF  x30
5E1E:  MOVLB  0
5E20:  CALL   0422
5E24:  BTFSC  19.7
5E26:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
5E28:  MOVLW  01
5E2A:  MOVLB  7
5E2C:  MOVWF  xDB
5E2E:  MOVLW  03
5E30:  MOVWF  xDC
5E32:  MOVLW  07
5E34:  MOVWF  xDE
5E36:  MOVLW  A7
5E38:  MOVWF  xDD
5E3A:  MOVLB  0
5E3C:  CALL   4826
....................           mode_sl = (unsigned int8)strtoi(temp); 
5E40:  MOVLW  07
5E42:  MOVLB  7
5E44:  MOVWF  xDC
5E46:  MOVLW  A7
5E48:  MOVWF  xDB
5E4A:  MOVLB  0
5E4C:  CALL   4F3C
5E50:  MOVFF  01,6CA
5E54:  CLRF   19
5E56:  BTFSC  FF2.7
5E58:  BSF    19.7
5E5A:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
5E5C:  MOVLB  8
5E5E:  CLRF   x1B
5E60:  CLRF   x1A
5E62:  CLRF   x19
5E64:  MOVLW  91
5E66:  MOVWF  x18
5E68:  MOVFF  6CA,81C
5E6C:  MOVLB  0
5E6E:  CALL   3830
5E72:  BTFSC  19.7
5E74:  BSF    FF2.7
....................           set_tris_a(0xff); 
5E76:  MOVLW  FF
5E78:  MOVWF  F92
5E7A:  CLRF   19
5E7C:  BTFSC  FF2.7
5E7E:  BSF    19.7
5E80:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5E82:  MOVLW  0A
5E84:  MOVLB  8
5E86:  MOVWF  x30
5E88:  MOVLB  0
5E8A:  CALL   0422
5E8E:  BTFSC  19.7
5E90:  BSF    FF2.7
5E92:  CLRF   19
5E94:  BTFSC  FF2.7
5E96:  BSF    19.7
5E98:  BCF    FF2.7
5E9A:  MOVLW  0D
5E9C:  MOVLB  8
5E9E:  MOVWF  x30
5EA0:  MOVLB  0
5EA2:  CALL   0422
5EA6:  BTFSC  19.7
5EA8:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"KP"); 
5EAA:  CLRF   FEA
5EAC:  MOVLW  62
5EAE:  MOVWF  FE9
5EB0:  MOVLW  00
5EB2:  CALL   01F8
5EB6:  TBLRD*-
5EB8:  TBLRD*+
5EBA:  MOVF   FF5,W
5EBC:  MOVWF  FEE
5EBE:  IORLW  00
5EC0:  BNZ   5EB8
....................       if(!stringcomp(buffer_uart,buffer2)) 
5EC2:  MOVLW  01
5EC4:  MOVLB  7
5EC6:  MOVWF  xDC
5EC8:  MOVLW  4D
5ECA:  MOVWF  xDB
5ECC:  CLRF   xDE
5ECE:  MOVLW  62
5ED0:  MOVWF  xDD
5ED2:  MOVLB  0
5ED4:  CALL   495E
5ED8:  MOVF   01,F
5EDA:  BTFSS  FD8.2
5EDC:  BRA    5FEC
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
5EDE:  MOVLW  90
5EE0:  MOVWF  FF6
5EE2:  MOVLW  1B
5EE4:  MOVWF  FF7
5EE6:  CLRF   19
5EE8:  BTFSC  FF2.7
5EEA:  BSF    19.7
5EEC:  BCF    FF2.7
5EEE:  CALL   0474
5EF2:  BTFSC  19.7
5EF4:  BSF    FF2.7
5EF6:  CLRF   19
5EF8:  BTFSC  FF2.7
5EFA:  BSF    19.7
5EFC:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5EFE:  MOVLW  0A
5F00:  MOVLB  8
5F02:  MOVWF  x30
5F04:  MOVLB  0
5F06:  CALL   0422
5F0A:  BTFSC  19.7
5F0C:  BSF    FF2.7
5F0E:  CLRF   19
5F10:  BTFSC  FF2.7
5F12:  BSF    19.7
5F14:  BCF    FF2.7
5F16:  MOVLW  0D
5F18:  MOVLB  8
5F1A:  MOVWF  x30
5F1C:  MOVLB  0
5F1E:  CALL   0422
5F22:  BTFSC  19.7
5F24:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
5F26:  MOVLW  AE
5F28:  MOVWF  FF6
5F2A:  MOVLW  1B
5F2C:  MOVWF  FF7
5F2E:  CLRF   19
5F30:  BTFSC  FF2.7
5F32:  BSF    19.7
5F34:  BCF    FF2.7
5F36:  CALL   0474
5F3A:  BTFSC  19.7
5F3C:  BSF    FF2.7
5F3E:  CLRF   19
5F40:  BTFSC  FF2.7
5F42:  BSF    19.7
5F44:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5F46:  MOVLW  0A
5F48:  MOVLB  8
5F4A:  MOVWF  x30
5F4C:  MOVLB  0
5F4E:  CALL   0422
5F52:  BTFSC  19.7
5F54:  BSF    FF2.7
5F56:  CLRF   19
5F58:  BTFSC  FF2.7
5F5A:  BSF    19.7
5F5C:  BCF    FF2.7
5F5E:  MOVLW  0D
5F60:  MOVLB  8
5F62:  MOVWF  x30
5F64:  MOVLB  0
5F66:  CALL   0422
5F6A:  BTFSC  19.7
5F6C:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
5F6E:  MOVLW  01
5F70:  MOVLB  7
5F72:  MOVWF  xDB
5F74:  MOVLW  03
5F76:  MOVWF  xDC
5F78:  MOVLW  07
5F7A:  MOVWF  xDE
5F7C:  MOVLW  A7
5F7E:  MOVWF  xDD
5F80:  MOVLB  0
5F82:  CALL   4826
....................           KP_mode = (unsigned int8)strtoi(temp); 
5F86:  MOVLW  07
5F88:  MOVLB  7
5F8A:  MOVWF  xDC
5F8C:  MOVLW  A7
5F8E:  MOVWF  xDB
5F90:  MOVLB  0
5F92:  CALL   4F3C
5F96:  MOVFF  01,130
5F9A:  CLRF   19
5F9C:  BTFSC  FF2.7
5F9E:  BSF    19.7
5FA0:  BCF    FF2.7
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
5FA2:  MOVLB  8
5FA4:  CLRF   x1B
5FA6:  CLRF   x1A
5FA8:  CLRF   x19
5FAA:  MOVLW  7F
5FAC:  MOVWF  x18
5FAE:  MOVFF  130,81C
5FB2:  MOVLB  0
5FB4:  CALL   3830
5FB8:  BTFSC  19.7
5FBA:  BSF    FF2.7
5FBC:  CLRF   19
5FBE:  BTFSC  FF2.7
5FC0:  BSF    19.7
5FC2:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5FC4:  MOVLW  0A
5FC6:  MOVLB  8
5FC8:  MOVWF  x30
5FCA:  MOVLB  0
5FCC:  CALL   0422
5FD0:  BTFSC  19.7
5FD2:  BSF    FF2.7
5FD4:  CLRF   19
5FD6:  BTFSC  FF2.7
5FD8:  BSF    19.7
5FDA:  BCF    FF2.7
5FDC:  MOVLW  0D
5FDE:  MOVLB  8
5FE0:  MOVWF  x30
5FE2:  MOVLB  0
5FE4:  CALL   0422
5FE8:  BTFSC  19.7
5FEA:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"tran time"); 
5FEC:  CLRF   FEA
5FEE:  MOVLW  62
5FF0:  MOVWF  FE9
5FF2:  MOVLW  00
5FF4:  CALL   020C
5FF8:  TBLRD*-
5FFA:  TBLRD*+
5FFC:  MOVF   FF5,W
5FFE:  MOVWF  FEE
6000:  IORLW  00
6002:  BNZ   5FFA
....................       if(!stringcomp(buffer_uart,buffer2)) 
6004:  MOVLW  01
6006:  MOVLB  7
6008:  MOVWF  xDC
600A:  MOVLW  4D
600C:  MOVWF  xDB
600E:  CLRF   xDE
6010:  MOVLW  62
6012:  MOVWF  xDD
6014:  MOVLB  0
6016:  CALL   495E
601A:  MOVF   01,F
601C:  BNZ   60E4
....................       { 
....................           fprintf(COM2,"Input Number"); 
601E:  MOVLW  CC
6020:  MOVWF  FF6
6022:  MOVLW  1B
6024:  MOVWF  FF7
6026:  CLRF   19
6028:  BTFSC  FF2.7
602A:  BSF    19.7
602C:  BCF    FF2.7
602E:  CALL   0474
6032:  BTFSC  19.7
6034:  BSF    FF2.7
6036:  CLRF   19
6038:  BTFSC  FF2.7
603A:  BSF    19.7
603C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
603E:  MOVLW  0A
6040:  MOVLB  8
6042:  MOVWF  x30
6044:  MOVLB  0
6046:  CALL   0422
604A:  BTFSC  19.7
604C:  BSF    FF2.7
604E:  CLRF   19
6050:  BTFSC  FF2.7
6052:  BSF    19.7
6054:  BCF    FF2.7
6056:  MOVLW  0D
6058:  MOVLB  8
605A:  MOVWF  x30
605C:  MOVLB  0
605E:  CALL   0422
6062:  BTFSC  19.7
6064:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6066:  MOVLW  01
6068:  MOVLB  7
606A:  MOVWF  xDB
606C:  MOVLW  03
606E:  MOVWF  xDC
6070:  MOVLW  07
6072:  MOVWF  xDE
6074:  MOVLW  A7
6076:  MOVWF  xDD
6078:  MOVLB  0
607A:  CALL   4826
....................           delaycharaction = (unsigned int8)strtoi(temp); 
607E:  MOVLW  07
6080:  MOVLB  7
6082:  MOVWF  xDC
6084:  MOVLW  A7
6086:  MOVWF  xDB
6088:  MOVLB  0
608A:  CALL   4F3C
608E:  MOVFF  01,145
6092:  CLRF   19
6094:  BTFSC  FF2.7
6096:  BSF    19.7
6098:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
609A:  MOVLB  8
609C:  CLRF   x1B
609E:  CLRF   x1A
60A0:  CLRF   x19
60A2:  MOVLW  94
60A4:  MOVWF  x18
60A6:  MOVFF  145,81C
60AA:  MOVLB  0
60AC:  CALL   3830
60B0:  BTFSC  19.7
60B2:  BSF    FF2.7
60B4:  CLRF   19
60B6:  BTFSC  FF2.7
60B8:  BSF    19.7
60BA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
60BC:  MOVLW  0A
60BE:  MOVLB  8
60C0:  MOVWF  x30
60C2:  MOVLB  0
60C4:  CALL   0422
60C8:  BTFSC  19.7
60CA:  BSF    FF2.7
60CC:  CLRF   19
60CE:  BTFSC  FF2.7
60D0:  BSF    19.7
60D2:  BCF    FF2.7
60D4:  MOVLW  0D
60D6:  MOVLB  8
60D8:  MOVWF  x30
60DA:  MOVLB  0
60DC:  CALL   0422
60E0:  BTFSC  19.7
60E2:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
60E4:  CLRF   FEA
60E6:  MOVLW  62
60E8:  MOVWF  FE9
60EA:  MOVLW  00
60EC:  CALL   0226
60F0:  TBLRD*-
60F2:  TBLRD*+
60F4:  MOVF   FF5,W
60F6:  MOVWF  FEE
60F8:  IORLW  00
60FA:  BNZ   60F2
....................       if(!stringcomp(buffer_uart,buffer2)) 
60FC:  MOVLW  01
60FE:  MOVLB  7
6100:  MOVWF  xDC
6102:  MOVLW  4D
6104:  MOVWF  xDB
6106:  CLRF   xDE
6108:  MOVLW  62
610A:  MOVWF  xDD
610C:  MOVLB  0
610E:  CALL   495E
6112:  MOVF   01,F
6114:  BTFSS  FD8.2
6116:  BRA    6226
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
6118:  MOVLW  DA
611A:  MOVWF  FF6
611C:  MOVLW  1B
611E:  MOVWF  FF7
6120:  CLRF   19
6122:  BTFSC  FF2.7
6124:  BSF    19.7
6126:  BCF    FF2.7
6128:  CALL   0474
612C:  BTFSC  19.7
612E:  BSF    FF2.7
6130:  CLRF   19
6132:  BTFSC  FF2.7
6134:  BSF    19.7
6136:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6138:  MOVLW  0A
613A:  MOVLB  8
613C:  MOVWF  x30
613E:  MOVLB  0
6140:  CALL   0422
6144:  BTFSC  19.7
6146:  BSF    FF2.7
6148:  CLRF   19
614A:  BTFSC  FF2.7
614C:  BSF    19.7
614E:  BCF    FF2.7
6150:  MOVLW  0D
6152:  MOVLB  8
6154:  MOVWF  x30
6156:  MOVLB  0
6158:  CALL   0422
615C:  BTFSC  19.7
615E:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
6160:  MOVLW  00
6162:  MOVWF  FF6
6164:  MOVLW  1C
6166:  MOVWF  FF7
6168:  CLRF   19
616A:  BTFSC  FF2.7
616C:  BSF    19.7
616E:  BCF    FF2.7
6170:  CALL   0474
6174:  BTFSC  19.7
6176:  BSF    FF2.7
6178:  CLRF   19
617A:  BTFSC  FF2.7
617C:  BSF    19.7
617E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6180:  MOVLW  0A
6182:  MOVLB  8
6184:  MOVWF  x30
6186:  MOVLB  0
6188:  CALL   0422
618C:  BTFSC  19.7
618E:  BSF    FF2.7
6190:  CLRF   19
6192:  BTFSC  FF2.7
6194:  BSF    19.7
6196:  BCF    FF2.7
6198:  MOVLW  0D
619A:  MOVLB  8
619C:  MOVWF  x30
619E:  MOVLB  0
61A0:  CALL   0422
61A4:  BTFSC  19.7
61A6:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
61A8:  MOVLW  01
61AA:  MOVLB  7
61AC:  MOVWF  xDB
61AE:  MOVLW  03
61B0:  MOVWF  xDC
61B2:  MOVLW  07
61B4:  MOVWF  xDE
61B6:  MOVLW  A7
61B8:  MOVWF  xDD
61BA:  MOVLB  0
61BC:  CALL   4826
....................           type_KB=(unsigned int8)strtoi(temp); 
61C0:  MOVLW  07
61C2:  MOVLB  7
61C4:  MOVWF  xDC
61C6:  MOVLW  A7
61C8:  MOVWF  xDB
61CA:  MOVLB  0
61CC:  CALL   4F3C
61D0:  MOVFF  01,134
61D4:  CLRF   19
61D6:  BTFSC  FF2.7
61D8:  BSF    19.7
61DA:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
61DC:  MOVLB  8
61DE:  CLRF   x1B
61E0:  CLRF   x1A
61E2:  CLRF   x19
61E4:  MOVLW  7E
61E6:  MOVWF  x18
61E8:  MOVFF  134,81C
61EC:  MOVLB  0
61EE:  CALL   3830
61F2:  BTFSC  19.7
61F4:  BSF    FF2.7
61F6:  CLRF   19
61F8:  BTFSC  FF2.7
61FA:  BSF    19.7
61FC:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
61FE:  MOVLW  0A
6200:  MOVLB  8
6202:  MOVWF  x30
6204:  MOVLB  0
6206:  CALL   0422
620A:  BTFSC  19.7
620C:  BSF    FF2.7
620E:  CLRF   19
6210:  BTFSC  FF2.7
6212:  BSF    19.7
6214:  BCF    FF2.7
6216:  MOVLW  0D
6218:  MOVLB  8
621A:  MOVWF  x30
621C:  MOVLB  0
621E:  CALL   0422
6222:  BTFSC  19.7
6224:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
6226:  CLRF   FEA
6228:  MOVLW  62
622A:  MOVWF  FE9
622C:  MOVLW  00
622E:  CALL   023C
6232:  TBLRD*-
6234:  TBLRD*+
6236:  MOVF   FF5,W
6238:  MOVWF  FEE
623A:  IORLW  00
623C:  BNZ   6234
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
623E:  MOVLW  01
6240:  MOVLB  7
6242:  MOVWF  xDC
6244:  MOVLW  4D
6246:  MOVWF  xDB
6248:  CLRF   xDE
624A:  MOVLW  62
624C:  MOVWF  xDD
624E:  MOVLB  0
6250:  CALL   495E
6254:  MOVF   01,F
6256:  BTFSS  FD8.2
6258:  BRA    6440
....................       { 
....................          printf("h-> Help\n\r"); 
625A:  MOVLW  26
625C:  MOVWF  FF6
625E:  MOVLW  1C
6260:  MOVWF  FF7
6262:  CLRF   19
6264:  BTFSC  FF2.7
6266:  BSF    19.7
6268:  BCF    FF2.7
626A:  CALL   0474
626E:  BTFSC  19.7
6270:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
6272:  MOVLW  32
6274:  MOVWF  FF6
6276:  MOVLW  1C
6278:  MOVWF  FF7
627A:  CLRF   19
627C:  BTFSC  FF2.7
627E:  BSF    19.7
6280:  BCF    FF2.7
6282:  CALL   0474
6286:  BTFSC  19.7
6288:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
628A:  MOVLW  44
628C:  MOVWF  FF6
628E:  MOVLW  1C
6290:  MOVWF  FF7
6292:  CLRF   19
6294:  BTFSC  FF2.7
6296:  BSF    19.7
6298:  BCF    FF2.7
629A:  CALL   0474
629E:  BTFSC  19.7
62A0:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
62A2:  MOVLW  56
62A4:  MOVWF  FF6
62A6:  MOVLW  1C
62A8:  MOVWF  FF7
62AA:  CLRF   19
62AC:  BTFSC  FF2.7
62AE:  BSF    19.7
62B0:  BCF    FF2.7
62B2:  CALL   0474
62B6:  BTFSC  19.7
62B8:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
62BA:  MOVLW  76
62BC:  MOVWF  FF6
62BE:  MOVLW  1C
62C0:  MOVWF  FF7
62C2:  CLRF   19
62C4:  BTFSC  FF2.7
62C6:  BSF    19.7
62C8:  BCF    FF2.7
62CA:  CALL   0474
62CE:  BTFSC  19.7
62D0:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
62D2:  MOVLW  92
62D4:  MOVWF  FF6
62D6:  MOVLW  1C
62D8:  MOVWF  FF7
62DA:  CLRF   19
62DC:  BTFSC  FF2.7
62DE:  BSF    19.7
62E0:  BCF    FF2.7
62E2:  CALL   0474
62E6:  BTFSC  19.7
62E8:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
62EA:  MOVLW  A0
62EC:  MOVWF  FF6
62EE:  MOVLW  1C
62F0:  MOVWF  FF7
62F2:  CLRF   19
62F4:  BTFSC  FF2.7
62F6:  BSF    19.7
62F8:  BCF    FF2.7
62FA:  CALL   0474
62FE:  BTFSC  19.7
6300:  BSF    FF2.7
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
6302:  MOVLW  AC
6304:  MOVWF  FF6
6306:  MOVLW  1C
6308:  MOVWF  FF7
630A:  CLRF   19
630C:  BTFSC  FF2.7
630E:  BSF    19.7
6310:  BCF    FF2.7
6312:  CALL   0474
6316:  BTFSC  19.7
6318:  BSF    FF2.7
631A:  CLRF   19
631C:  BTFSC  FF2.7
631E:  BSF    19.7
6320:  BCF    FF2.7
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
6322:  MOVLB  8
6324:  CLRF   x13
6326:  CLRF   x12
6328:  CLRF   x11
632A:  MOVLW  7F
632C:  MOVWF  x10
632E:  MOVLB  0
6330:  CALL   32E0
6334:  BTFSC  19.7
6336:  BSF    FF2.7
6338:  MOVFF  01,130
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
633C:  MOVLB  1
633E:  MOVF   x30,F
6340:  BZ    6360
6342:  MOVLW  D8
6344:  MOVWF  FF6
6346:  MOVLW  1C
6348:  MOVWF  FF7
634A:  CLRF   19
634C:  BTFSC  FF2.7
634E:  BSF    19.7
6350:  BCF    FF2.7
6352:  MOVLB  0
6354:  CALL   0474
6358:  BTFSC  19.7
635A:  BSF    FF2.7
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
635C:  BRA    637A
635E:  MOVLB  1
6360:  MOVLW  FA
6362:  MOVWF  FF6
6364:  MOVLW  1C
6366:  MOVWF  FF7
6368:  CLRF   19
636A:  BTFSC  FF2.7
636C:  BSF    19.7
636E:  BCF    FF2.7
6370:  MOVLB  0
6372:  CALL   0474
6376:  BTFSC  19.7
6378:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
637A:  MOVLW  1E
637C:  MOVWF  FF6
637E:  MOVLW  1D
6380:  MOVWF  FF7
6382:  CLRF   19
6384:  BTFSC  FF2.7
6386:  BSF    19.7
6388:  BCF    FF2.7
638A:  CALL   0474
638E:  BTFSC  19.7
6390:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
6392:  MOVLW  46
6394:  MOVWF  FF6
6396:  MOVLW  1D
6398:  MOVWF  FF7
639A:  CLRF   19
639C:  BTFSC  FF2.7
639E:  BSF    19.7
63A0:  BCF    FF2.7
63A2:  CALL   0474
63A6:  BTFSC  19.7
63A8:  BSF    FF2.7
63AA:  CLRF   19
63AC:  BTFSC  FF2.7
63AE:  BSF    19.7
63B0:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
63B2:  MOVLB  8
63B4:  CLRF   x13
63B6:  CLRF   x12
63B8:  CLRF   x11
63BA:  MOVLW  7E
63BC:  MOVWF  x10
63BE:  MOVLB  0
63C0:  CALL   32E0
63C4:  BTFSC  19.7
63C6:  BSF    FF2.7
63C8:  MOVFF  01,7DB
63CC:  MOVLW  62
63CE:  MOVWF  FF6
63D0:  MOVLW  1D
63D2:  MOVWF  FF7
63D4:  CLRF   19
63D6:  BTFSC  FF2.7
63D8:  BSF    19.7
63DA:  BCF    FF2.7
63DC:  MOVLW  06
63DE:  MOVLB  8
63E0:  MOVWF  x24
63E2:  MOVLB  0
63E4:  CALL   13EC
63E8:  BTFSC  19.7
63EA:  BSF    FF2.7
63EC:  CLRF   19
63EE:  BTFSC  FF2.7
63F0:  BSF    19.7
63F2:  BCF    FF2.7
63F4:  MOVFF  7DB,810
63F8:  MOVLW  18
63FA:  MOVLB  8
63FC:  MOVWF  x11
63FE:  MOVLB  0
6400:  CALL   1500
6404:  BTFSC  19.7
6406:  BSF    FF2.7
6408:  MOVLW  6A
640A:  MOVWF  FF6
640C:  MOVLW  1D
640E:  MOVWF  FF7
6410:  CLRF   19
6412:  BTFSC  FF2.7
6414:  BSF    19.7
6416:  BCF    FF2.7
6418:  MOVLW  1D
641A:  MOVLB  8
641C:  MOVWF  x24
641E:  MOVLB  0
6420:  CALL   13EC
6424:  BTFSC  19.7
6426:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
6428:  MOVLW  88
642A:  MOVWF  FF6
642C:  MOVLW  1D
642E:  MOVWF  FF7
6430:  CLRF   19
6432:  BTFSC  FF2.7
6434:  BSF    19.7
6436:  BCF    FF2.7
6438:  CALL   0474
643C:  BTFSC  19.7
643E:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
6440:  CLRF   FEA
6442:  MOVLW  62
6444:  MOVWF  FE9
6446:  MOVLW  00
6448:  CALL   024E
644C:  TBLRD*-
644E:  TBLRD*+
6450:  MOVF   FF5,W
6452:  MOVWF  FEE
6454:  IORLW  00
6456:  BNZ   644E
....................       if(!stringcomp(buffer_uart,buffer2))  
6458:  MOVLW  01
645A:  MOVLB  7
645C:  MOVWF  xDC
645E:  MOVLW  4D
6460:  MOVWF  xDB
6462:  CLRF   xDE
6464:  MOVLW  62
6466:  MOVWF  xDD
6468:  MOVLB  0
646A:  CALL   495E
646E:  MOVF   01,F
6470:  BTFSS  FD8.2
6472:  BRA    65A2
....................       { 
....................          fprintf(COM2,"old password:"); 
6474:  MOVLW  A2
6476:  MOVWF  FF6
6478:  MOVLW  1D
647A:  MOVWF  FF7
647C:  CLRF   19
647E:  BTFSC  FF2.7
6480:  BSF    19.7
6482:  BCF    FF2.7
6484:  CALL   0474
6488:  BTFSC  19.7
648A:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
648C:  MOVLB  7
648E:  CLRF   xDB
6490:  MOVLW  14
6492:  MOVWF  xDC
6494:  CLRF   xDE
6496:  MOVLW  76
6498:  MOVWF  xDD
649A:  MOVLB  0
649C:  CALL   4376
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
64A0:  MOVLW  02
64A2:  MOVLB  7
64A4:  MOVWF  xDB
64A6:  MOVLW  14
64A8:  MOVWF  xDC
64AA:  CLRF   xDE
64AC:  MOVLW  8A
64AE:  MOVWF  xDD
64B0:  MOVLB  0
64B2:  CALL   4826
....................          if(!stringcomp(entpassword,password)) 
64B6:  MOVLB  7
64B8:  CLRF   xDC
64BA:  MOVLW  8A
64BC:  MOVWF  xDB
64BE:  CLRF   xDE
64C0:  MOVLW  76
64C2:  MOVWF  xDD
64C4:  MOVLB  0
64C6:  CALL   495E
64CA:  MOVF   01,F
64CC:  BNZ   658A
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
64CE:  MOVLW  B0
64D0:  MOVWF  FF6
64D2:  MOVLW  1D
64D4:  MOVWF  FF7
64D6:  CLRF   19
64D8:  BTFSC  FF2.7
64DA:  BSF    19.7
64DC:  BCF    FF2.7
64DE:  CALL   0474
64E2:  BTFSC  19.7
64E4:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
64E6:  MOVLW  02
64E8:  MOVLB  7
64EA:  MOVWF  xDB
64EC:  MOVLW  14
64EE:  MOVWF  xDC
64F0:  CLRF   xDE
64F2:  MOVLW  8A
64F4:  MOVWF  xDD
64F6:  MOVLB  0
64F8:  CALL   4826
....................             fprintf(COM2,"\n\ragain:"); 
64FC:  MOVLW  B8
64FE:  MOVWF  FF6
6500:  MOVLW  1D
6502:  MOVWF  FF7
6504:  CLRF   19
6506:  BTFSC  FF2.7
6508:  BSF    19.7
650A:  BCF    FF2.7
650C:  CALL   0474
6510:  BTFSC  19.7
6512:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
6514:  MOVLW  02
6516:  MOVLB  7
6518:  MOVWF  xDB
651A:  MOVLW  14
651C:  MOVWF  xDC
651E:  CLRF   xDE
6520:  MOVLW  76
6522:  MOVWF  xDD
6524:  MOVLB  0
6526:  CALL   4826
....................             if(!stringcomp(entpassword,password)) 
652A:  MOVLB  7
652C:  CLRF   xDC
652E:  MOVLW  8A
6530:  MOVWF  xDB
6532:  CLRF   xDE
6534:  MOVLW  76
6536:  MOVWF  xDD
6538:  MOVLB  0
653A:  CALL   495E
653E:  MOVF   01,F
6540:  BNZ   6570
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
6542:  MOVLB  7
6544:  CLRF   xF0
6546:  MOVLW  14
6548:  MOVWF  xF1
654A:  CLRF   xF3
654C:  MOVLW  76
654E:  MOVWF  xF2
6550:  MOVLB  0
6552:  CALL   43D6
....................                fprintf(COM2,"\n\rOK\n\r");    
6556:  MOVLW  C2
6558:  MOVWF  FF6
655A:  MOVLW  1D
655C:  MOVWF  FF7
655E:  CLRF   19
6560:  BTFSC  FF2.7
6562:  BSF    19.7
6564:  BCF    FF2.7
6566:  CALL   0474
656A:  BTFSC  19.7
656C:  BSF    FF2.7
....................             } 
....................                else 
656E:  BRA    6588
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
6570:  MOVLW  CA
6572:  MOVWF  FF6
6574:  MOVLW  1D
6576:  MOVWF  FF7
6578:  CLRF   19
657A:  BTFSC  FF2.7
657C:  BSF    19.7
657E:  BCF    FF2.7
6580:  CALL   0474
6584:  BTFSC  19.7
6586:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
6588:  BRA    65A2
....................             { 
....................                fprintf(COM2," X\n\r"); 
658A:  MOVLW  D2
658C:  MOVWF  FF6
658E:  MOVLW  1D
6590:  MOVWF  FF7
6592:  CLRF   19
6594:  BTFSC  FF2.7
6596:  BSF    19.7
6598:  BCF    FF2.7
659A:  CALL   0474
659E:  BTFSC  19.7
65A0:  BSF    FF2.7
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
65A2:  CLRF   FEA
65A4:  MOVLW  62
65A6:  MOVWF  FE9
65A8:  MOVLW  00
65AA:  CALL   0268
65AE:  TBLRD*-
65B0:  TBLRD*+
65B2:  MOVF   FF5,W
65B4:  MOVWF  FEE
65B6:  IORLW  00
65B8:  BNZ   65B0
....................       if(!stringcomp(buffer_uart,buffer2)) 
65BA:  MOVLW  01
65BC:  MOVLB  7
65BE:  MOVWF  xDC
65C0:  MOVLW  4D
65C2:  MOVWF  xDB
65C4:  CLRF   xDE
65C6:  MOVLW  62
65C8:  MOVWF  xDD
65CA:  MOVLB  0
65CC:  CALL   495E
65D0:  MOVF   01,F
65D2:  BTFSS  FD8.2
65D4:  BRA    66E4
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
65D6:  MOVLW  D8
65D8:  MOVWF  FF6
65DA:  MOVLW  1D
65DC:  MOVWF  FF7
65DE:  CLRF   19
65E0:  BTFSC  FF2.7
65E2:  BSF    19.7
65E4:  BCF    FF2.7
65E6:  CALL   0474
65EA:  BTFSC  19.7
65EC:  BSF    FF2.7
65EE:  CLRF   19
65F0:  BTFSC  FF2.7
65F2:  BSF    19.7
65F4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
65F6:  MOVLW  0A
65F8:  MOVLB  8
65FA:  MOVWF  x30
65FC:  MOVLB  0
65FE:  CALL   0422
6602:  BTFSC  19.7
6604:  BSF    FF2.7
6606:  CLRF   19
6608:  BTFSC  FF2.7
660A:  BSF    19.7
660C:  BCF    FF2.7
660E:  MOVLW  0D
6610:  MOVLB  8
6612:  MOVWF  x30
6614:  MOVLB  0
6616:  CALL   0422
661A:  BTFSC  19.7
661C:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
661E:  MOVLW  F8
6620:  MOVWF  FF6
6622:  MOVLW  1D
6624:  MOVWF  FF7
6626:  CLRF   19
6628:  BTFSC  FF2.7
662A:  BSF    19.7
662C:  BCF    FF2.7
662E:  CALL   0474
6632:  BTFSC  19.7
6634:  BSF    FF2.7
6636:  CLRF   19
6638:  BTFSC  FF2.7
663A:  BSF    19.7
663C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
663E:  MOVLW  0A
6640:  MOVLB  8
6642:  MOVWF  x30
6644:  MOVLB  0
6646:  CALL   0422
664A:  BTFSC  19.7
664C:  BSF    FF2.7
664E:  CLRF   19
6650:  BTFSC  FF2.7
6652:  BSF    19.7
6654:  BCF    FF2.7
6656:  MOVLW  0D
6658:  MOVLB  8
665A:  MOVWF  x30
665C:  MOVLB  0
665E:  CALL   0422
6662:  BTFSC  19.7
6664:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6666:  MOVLW  01
6668:  MOVLB  7
666A:  MOVWF  xDB
666C:  MOVLW  03
666E:  MOVWF  xDC
6670:  MOVLW  07
6672:  MOVWF  xDE
6674:  MOVLW  A7
6676:  MOVWF  xDD
6678:  MOVLB  0
667A:  CALL   4826
....................           debugmode = (unsigned int8)strtoi(temp); 
667E:  MOVLW  07
6680:  MOVLB  7
6682:  MOVWF  xDC
6684:  MOVLW  A7
6686:  MOVWF  xDB
6688:  MOVLB  0
668A:  CALL   4F3C
668E:  MOVFF  01,6BE
6692:  CLRF   19
6694:  BTFSC  FF2.7
6696:  BSF    19.7
6698:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
669A:  MOVLB  8
669C:  CLRF   x1B
669E:  CLRF   x1A
66A0:  CLRF   x19
66A2:  MOVLW  92
66A4:  MOVWF  x18
66A6:  MOVFF  6BE,81C
66AA:  MOVLB  0
66AC:  CALL   3830
66B0:  BTFSC  19.7
66B2:  BSF    FF2.7
66B4:  CLRF   19
66B6:  BTFSC  FF2.7
66B8:  BSF    19.7
66BA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
66BC:  MOVLW  0A
66BE:  MOVLB  8
66C0:  MOVWF  x30
66C2:  MOVLB  0
66C4:  CALL   0422
66C8:  BTFSC  19.7
66CA:  BSF    FF2.7
66CC:  CLRF   19
66CE:  BTFSC  FF2.7
66D0:  BSF    19.7
66D2:  BCF    FF2.7
66D4:  MOVLW  0D
66D6:  MOVLB  8
66D8:  MOVWF  x30
66DA:  MOVLB  0
66DC:  CALL   0422
66E0:  BTFSC  19.7
66E2:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
66E4:  GOTO   6BDC (RETURN)
.................... //=============================================== 
....................  
....................  
.................... //========================= 
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
408C:  MOVLB  1
408E:  MOVF   x30,F
4090:  BZ    40CC
....................    { 
....................       if(count_kp<500)count_kp++; 
4092:  MOVF   x33,W
4094:  SUBLW  01
4096:  BNC   40A6
4098:  BNZ   40A0
409A:  MOVF   x32,W
409C:  SUBLW  F3
409E:  BNC   40A6
40A0:  INCF   x32,F
40A2:  BTFSC  FD8.2
40A4:  INCF   x33,F
....................       if(count_kp==500) 
40A6:  MOVF   x32,W
40A8:  SUBLW  F4
40AA:  BNZ   40CC
40AC:  DECFSZ x33,W
40AE:  BRA    40CC
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
40B0:  MOVLW  9C
40B2:  MOVWF  FF6
40B4:  MOVLW  42
40B6:  MOVWF  FF7
40B8:  MOVLB  0
40BA:  CALL   0474
....................             keyprss_off; 
40BE:  BCF    F92.7
40C0:  BCF    F89.7
....................             kp_st=0;     
40C2:  MOVLB  1
40C4:  CLRF   x31
....................             count_kp++; 
40C6:  INCF   x32,F
40C8:  BTFSC  FD8.2
40CA:  INCF   x33,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
40CC:  DECFSZ x2C,W
40CE:  BRA    40EA
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
40D0:  MOVLB  6
40D2:  MOVF   xCA,F
40D4:  BNZ   40DE
40D6:  MOVLB  0
40D8:  CALL   1E18
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
40DC:  BRA    40E8
40DE:  MOVLB  0
40E0:  CALL   3070
40E4:  MOVFF  01,806
40E8:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
40EA:  DECFSZ x2D,W
40EC:  BRA    4106
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
40EE:  MOVLB  6
40F0:  MOVF   xCA,F
40F2:  BNZ   40FC
40F4:  MOVLB  0
40F6:  CALL   1E18
....................          else temp=kbd_getc_slv(); 
40FA:  BRA    4106
40FC:  MOVLB  0
40FE:  CALL   3070
4102:  MOVFF  01,806
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
4106:  MOVLB  6
4108:  MOVF   xAF,F
410A:  BNZ   412A
410C:  MOVF   xAE,F
410E:  BNZ   412A
4110:  MOVF   xAD,F
4112:  BNZ   412A
4114:  MOVF   xAC,W
4116:  SUBLW  04
4118:  BNC   412A
411A:  MOVLW  01
411C:  ADDWF  xAC,F
411E:  BTFSC  FD8.0
4120:  INCF   xAD,F
4122:  BTFSC  FD8.2
4124:  INCF   xAE,F
4126:  BTFSC  FD8.2
4128:  INCF   xAF,F
....................   if(mcr_timeout==5) 
412A:  MOVF   xAC,W
412C:  SUBLW  05
412E:  BNZ   4184
4130:  MOVF   xAD,F
4132:  BNZ   4184
4134:  MOVF   xAE,F
4136:  BNZ   4184
4138:  MOVF   xAF,F
413A:  BNZ   4184
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
413C:  DECFSZ xC2,W
413E:  BRA    4146
4140:  MOVLB  0
4142:  BRA    39BC
4144:  MOVLB  6
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
4146:  MOVLW  02
4148:  MOVWF  FEA
414A:  MOVLW  2E
414C:  MOVWF  FE9
414E:  CLRF   00
4150:  MOVLW  03
4152:  MOVWF  02
4154:  MOVLW  52
4156:  MOVWF  01
4158:  MOVLB  0
415A:  RCALL  3DC2
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
415C:  MOVLW  05
415E:  MOVWF  FEA
4160:  MOVLW  80
4162:  MOVWF  FE9
4164:  CLRF   00
4166:  MOVLW  01
4168:  MOVWF  02
416A:  MOVLW  2C
416C:  MOVWF  01
416E:  RCALL  3DC2
....................       //debug_card(); 
....................       count_reading_error=0; 
4170:  MOVLB  6
4172:  CLRF   xC3
....................       mcr_timeout++;   
4174:  MOVLW  01
4176:  ADDWF  xAC,F
4178:  BTFSC  FD8.0
417A:  INCF   xAD,F
417C:  BTFSC  FD8.2
417E:  INCF   xAE,F
4180:  BTFSC  FD8.2
4182:  INCF   xAF,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
4184:  MOVLB  8
4186:  CLRF   x13
4188:  CLRF   x12
418A:  CLRF   x11
418C:  MOVLW  94
418E:  MOVWF  x10
4190:  MOVLB  0
4192:  CALL   32E0
4196:  MOVFF  01,145
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
419A:  MOVLW  02
419C:  MOVLB  8
419E:  MOVWF  x0D
41A0:  MOVLW  BC
41A2:  MOVWF  x0C
41A4:  CLRF   x0F
41A6:  MOVFF  145,80E
41AA:  MOVLB  0
41AC:  CALL   3404
41B0:  MOVFF  02,03
41B4:  MOVF   01,W
41B6:  MOVLB  1
41B8:  MOVF   x1D,W
41BA:  SUBWF  02,W
41BC:  BNC   41CC
41BE:  BNZ   41C6
41C0:  MOVF   01,W
41C2:  SUBWF  x1C,W
41C4:  BC    41CC
41C6:  INCF   x1C,F
41C8:  BTFSC  FD8.2
41CA:  INCF   x1D,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
41CC:  MOVLW  02
41CE:  MOVLB  8
41D0:  MOVWF  x0D
41D2:  MOVLW  BC
41D4:  MOVWF  x0C
41D6:  CLRF   x0F
41D8:  MOVFF  145,80E
41DC:  MOVLB  0
41DE:  CALL   3404
41E2:  MOVFF  02,03
41E6:  MOVF   01,W
41E8:  MOVLB  1
41EA:  SUBWF  x1C,W
41EC:  BNZ   4294
41EE:  MOVF   03,W
41F0:  SUBWF  x1D,W
41F2:  BNZ   4294
....................   { 
....................       charac_timeout++; 
41F4:  INCF   x1C,F
41F6:  BTFSC  FD8.2
41F8:  INCF   x1D,F
....................       buf=get_countcard(); 
41FA:  MOVLB  0
41FC:  CALL   33AC
4200:  MOVFF  02,805
4204:  MOVFF  01,804
....................       if(buf<countcards) 
4208:  MOVLB  8
420A:  MOVF   x05,W
420C:  SUBLW  03
420E:  BNC   4236
4210:  BNZ   4218
4212:  MOVF   x04,W
4214:  SUBLW  A1
4216:  BNC   4236
....................       { 
....................          save_key_new(); 
4218:  MOVLB  0
421A:  BRA    3DDC
....................          buf=buf+1; 
421C:  MOVLW  01
421E:  MOVLB  8
4220:  ADDWF  x04,F
4222:  MOVLW  00
4224:  ADDWFC x05,F
....................          save_coutcard(buf); 
4226:  MOVFF  805,808
422A:  MOVFF  804,807
422E:  MOVLB  0
4230:  RCALL  3F54
....................       } 
....................          else 
4232:  BRA    4246
4234:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
4236:  MOVLW  AC
4238:  MOVWF  FF6
423A:  MOVLW  42
423C:  MOVWF  FF7
423E:  MOVLB  0
4240:  CALL   0474
....................             return; 
4244:  BRA    4296
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
4246:  MOVLW  BC
4248:  MOVWF  FF6
424A:  MOVLW  42
424C:  MOVWF  FF7
424E:  CALL   0474
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
4252:  MOVLW  CC
4254:  MOVWF  FF6
4256:  MOVLW  42
4258:  MOVWF  FF7
425A:  MOVLW  14
425C:  MOVLB  8
425E:  MOVWF  x24
4260:  MOVLB  0
4262:  CALL   13EC
4266:  MOVLW  10
4268:  MOVWF  FE9
426A:  MOVFF  805,808
426E:  MOVFF  804,807
4272:  RCALL  3F96
4274:  MOVLW  E3
4276:  MOVWF  FF6
4278:  MOVLW  42
427A:  MOVWF  FF7
427C:  MOVLW  03
427E:  MOVLB  8
4280:  MOVWF  x24
4282:  MOVLB  0
4284:  CALL   13EC
....................       data_avai=0; 
4288:  MOVLB  6
428A:  CLRF   xC1
....................       enable_getpin=0; 
428C:  MOVLB  1
428E:  CLRF   x2D
....................       //dis_getpin; 
....................       output_low(LED); 
4290:  BCF    F92.6
4292:  BCF    F89.6
4294:  MOVLB  0
....................   } 
....................   //================================= 
....................   //================================= 
.................... } 
.................... //========================= 
4296:  BCF    FF2.2
4298:  GOTO   006C
.................... void main() 
.................... {  
*
66E8:  CLRF   FF8
66EA:  BCF    FD0.7
66EC:  BSF    07.7
66EE:  CLRF   FEA
66F0:  CLRF   FE9
66F2:  BCF    F94.0
66F4:  BSF    F8B.0
66F6:  CLRF   23
66F8:  CLRF   22
66FA:  CLRF   21
66FC:  MOVLW  96
66FE:  MOVWF  20
6700:  CLRF   27
6702:  MOVLW  01
6704:  MOVWF  26
6706:  MOVLW  C3
6708:  MOVWF  25
670A:  MOVLW  0F
670C:  MOVWF  24
670E:  MOVLB  1
6710:  CLRF   x1B
6712:  CLRF   x1A
6714:  SETF   x1D
6716:  SETF   x1C
6718:  MOVLW  0E
671A:  MOVWF  x1F
671C:  MOVLW  01
671E:  MOVWF  x20
6720:  MOVWF  x21
6722:  CLRF   x22
6724:  CLRF   x23
6726:  CLRF   x24
6728:  CLRF   x25
672A:  CLRF   x26
672C:  CLRF   x28
672E:  MOVLW  0A
6730:  MOVWF  x27
6732:  MOVLW  03
6734:  MOVWF  x2A
6736:  MOVLW  E8
6738:  MOVWF  x29
673A:  CLRF   x2B
673C:  CLRF   x2C
673E:  CLRF   x2D
6740:  MOVLW  64
6742:  MOVWF  x2E
6744:  CLRF   x2F
6746:  CLRF   x30
6748:  CLRF   x31
674A:  CLRF   x33
674C:  CLRF   x32
674E:  CLRF   x34
6750:  CLRF   x45
6752:  CLRF   x4A
6754:  CLRF   xB1
6756:  CLRF   xB2
6758:  CLRF   xB3
675A:  CLRF   xB4
675C:  CLRF   xB6
675E:  CLRF   xB5
6760:  MOVLB  6
6762:  CLRF   xAF
6764:  CLRF   xAE
6766:  CLRF   xAD
6768:  CLRF   xAC
676A:  CLRF   xB0
676C:  CLRF   xB2
676E:  CLRF   xB1
6770:  CLRF   xB4
6772:  CLRF   xB3
6774:  CLRF   xB6
6776:  CLRF   xB5
6778:  CLRF   xB8
677A:  CLRF   xB7
677C:  MOVLW  FD
677E:  MOVWF  xBA
6780:  MOVLW  E8
6782:  MOVWF  xB9
6784:  CLRF   xBC
6786:  CLRF   xBB
6788:  CLRF   xBD
678A:  CLRF   xBE
678C:  CLRF   xBF
678E:  CLRF   xC0
6790:  CLRF   xC1
6792:  CLRF   xC2
6794:  CLRF   xC3
6796:  CLRF   xC4
6798:  CLRF   xC5
679A:  CLRF   xC7
679C:  MOVLW  01
679E:  MOVWF  xC6
67A0:  CLRF   xC9
67A2:  CLRF   xC8
67A4:  CLRF   xCA
67A6:  CLRF   xCE
67A8:  CLRF   xCD
67AA:  CLRF   xCC
67AC:  CLRF   xCB
67AE:  MOVLW  FF
67B0:  MOVLB  F
67B2:  MOVWF  x48
67B4:  BCF    FC2.6
67B6:  BCF    FC2.7
67B8:  MOVF   x49,W
67BA:  ANDLW  E0
67BC:  IORLW  1F
67BE:  MOVWF  x49
67C0:  CLRF   FD2
67C2:  CLRF   FD1
67C4:  CLRF   1A
67C6:  CLRF   1B
67C8:  MOVLB  1
67CA:  CLRF   x46
67CC:  BCF    x47.0
67CE:  CLRF   x48
67D0:  CLRF   x49
67D2:  CLRF   x4B
67D4:  BCF    x47.1
67D6:  CLRF   x4C
67D8:  MOVLB  6
67DA:  CLRF   xDF
67DC:  CLRF   xE0
67DE:  CLRF   xE1
67E0:  CLRF   xE2
67E2:  CLRF   xE3
67E4:  CLRF   xE4
67E6:  CLRF   xE5
67E8:  CLRF   xE6
67EA:  CLRF   xE7
67EC:  CLRF   xE8
67EE:  CLRF   xEB
67F0:  CLRF   xED
67F2:  CLRF   xEC
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................     RPINR1=5; 
67F4:  MOVLW  05
67F6:  MOVLB  E
67F8:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
67FA:  MOVLB  1
67FC:  SETF   x1D
67FE:  SETF   x1C
....................    key_timeout=0xffff; 
6800:  SETF   x2A
6802:  SETF   x29
....................    setup_oscillator(OSC_32MHZ); 
6804:  MOVLW  70
6806:  MOVWF  FD3
6808:  MOVLW  40
680A:  MOVWF  F9B
680C:  MOVF   FD3,W
....................    keyprss_off; 
680E:  BCF    F92.7
6810:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
6812:  BCF    FF2.6
6814:  BCF    FF2.7
6816:  BTFSC  FF2.7
6818:  BRA    6814
....................    init_ext_eeprom(); 
681A:  MOVLB  0
681C:  GOTO   436C
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
6820:  MOVLW  04
6822:  MOVLB  7
6824:  MOVWF  xA5
6826:  CLRF   19
6828:  BTFSC  FF2.7
682A:  BSF    19.7
682C:  BCF    FF2.7
682E:  MOVLW  FA
6830:  MOVLB  8
6832:  MOVWF  x0D
6834:  MOVLB  0
6836:  CALL   1658
683A:  BTFSC  19.7
683C:  BSF    FF2.7
683E:  MOVLB  7
6840:  DECFSZ xA5,F
6842:  BRA    6826
....................    init_password(); 
6844:  MOVLB  0
6846:  CALL   442E
....................    EEPROM_read(strobe_pass_addr,20,password); 
684A:  MOVLB  7
684C:  CLRF   xDB
684E:  MOVLW  14
6850:  MOVWF  xDC
6852:  CLRF   xDE
6854:  MOVLW  76
6856:  MOVWF  xDD
6858:  MOVLB  0
685A:  CALL   4376
685E:  CLRF   19
6860:  BTFSC  FF2.7
6862:  BSF    19.7
6864:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
6866:  MOVLB  8
6868:  CLRF   x13
686A:  CLRF   x12
686C:  CLRF   x11
686E:  MOVLW  7F
6870:  MOVWF  x10
6872:  MOVLB  0
6874:  CALL   32E0
6878:  BTFSC  19.7
687A:  BSF    FF2.7
687C:  MOVFF  01,130
....................    //===================================== 
....................    rtc_init(); 
6880:  GOTO   456A
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
6884:  MOVLW  19
6886:  MOVLB  7
6888:  MOVWF  xA5
688A:  MOVLB  0
688C:  CALL   4674
6890:  MOVFF  03,23
6894:  MOVFF  02,22
6898:  MOVFF  01,21
689C:  MOVFF  00,20
....................     
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
68A0:  MOVLW  1E
68A2:  MOVLB  7
68A4:  MOVWF  xA5
68A6:  MOVLB  0
68A8:  CALL   4674
68AC:  MOVFF  03,27
68B0:  MOVFF  02,26
68B4:  MOVFF  01,25
68B8:  MOVFF  00,24
....................    fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card_key); 
68BC:  MOVLW  E8
68BE:  MOVWF  FF6
68C0:  MOVLW  42
68C2:  MOVWF  FF7
68C4:  CLRF   19
68C6:  BTFSC  FF2.7
68C8:  BSF    19.7
68CA:  BCF    FF2.7
68CC:  MOVLW  0E
68CE:  MOVLB  8
68D0:  MOVWF  x24
68D2:  MOVLB  0
68D4:  CALL   13EC
68D8:  BTFSC  19.7
68DA:  BSF    FF2.7
68DC:  MOVLW  41
68DE:  MOVWF  FE9
68E0:  CLRF   19
68E2:  BTFSC  FF2.7
68E4:  BSF    19.7
68E6:  BCF    FF2.7
68E8:  MOVFF  27,827
68EC:  MOVFF  26,826
68F0:  MOVFF  25,825
68F4:  MOVFF  24,824
68F8:  CALL   2194
68FC:  BTFSC  19.7
68FE:  BSF    FF2.7
6900:  CLRF   19
6902:  BTFSC  FF2.7
6904:  BSF    19.7
6906:  BCF    FF2.7
6908:  MOVLW  0A
690A:  MOVLB  8
690C:  MOVWF  x30
690E:  MOVLB  0
6910:  CALL   0422
6914:  BTFSC  19.7
6916:  BSF    FF2.7
6918:  CLRF   19
691A:  BTFSC  FF2.7
691C:  BSF    19.7
691E:  BCF    FF2.7
6920:  MOVLW  0D
6922:  MOVLB  8
6924:  MOVWF  x30
6926:  MOVLB  0
6928:  CALL   0422
692C:  BTFSC  19.7
692E:  BSF    FF2.7
6930:  CLRF   19
6932:  BTFSC  FF2.7
6934:  BSF    19.7
6936:  BCF    FF2.7
....................    countcard=get_countcard(); 
6938:  CALL   33AC
693C:  BTFSC  19.7
693E:  BSF    FF2.7
6940:  MOVFF  02,11B
6944:  MOVFF  01,11A
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
6948:  MOVLB  1
694A:  SETF   x1D
694C:  SETF   x1C
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
694E:  MOVLW  C7
6950:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
6952:  MOVLW  37
6954:  MOVWF  FCD
6956:  CLRF   F9A
6958:  CLRF   19
695A:  BTFSC  FF2.7
695C:  BSF    19.7
695E:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
6960:  MOVLB  8
6962:  CLRF   x13
6964:  CLRF   x12
6966:  CLRF   x11
6968:  MOVLW  94
696A:  MOVWF  x10
696C:  MOVLB  0
696E:  CALL   32E0
6972:  BTFSC  19.7
6974:  BSF    FF2.7
6976:  MOVFF  01,145
....................    if(delaycharaction==0)delaycharaction=1; 
697A:  MOVLB  1
697C:  MOVF   x45,F
697E:  BNZ   6984
6980:  MOVLW  01
6982:  MOVWF  x45
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
6984:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
6986:  BSF    FF0.3
6988:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
698A:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
698C:  MOVLW  C0
698E:  IORWF  FF2,F
....................   
....................    mcr_timeout=10000; 
6990:  MOVLB  6
6992:  CLRF   xAF
6994:  CLRF   xAE
6996:  MOVLW  27
6998:  MOVWF  xAD
699A:  MOVLW  10
699C:  MOVWF  xAC
699E:  CLRF   19
69A0:  BTFSC  FF2.7
69A2:  BSF    19.7
69A4:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
69A6:  MOVLB  8
69A8:  CLRF   x13
69AA:  CLRF   x12
69AC:  CLRF   x11
69AE:  MOVLW  91
69B0:  MOVWF  x10
69B2:  MOVLB  0
69B4:  CALL   32E0
69B8:  BTFSC  19.7
69BA:  BSF    FF2.7
69BC:  MOVFF  01,6CA
69C0:  CLRF   19
69C2:  BTFSC  FF2.7
69C4:  BSF    19.7
69C6:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
69C8:  MOVLB  8
69CA:  CLRF   x13
69CC:  CLRF   x12
69CE:  CLRF   x11
69D0:  MOVLW  92
69D2:  MOVWF  x10
69D4:  MOVLB  0
69D6:  CALL   32E0
69DA:  BTFSC  19.7
69DC:  BSF    FF2.7
69DE:  MOVFF  01,6BE
....................     key_timeout=1000; 
69E2:  MOVLW  03
69E4:  MOVLB  1
69E6:  MOVWF  x2A
69E8:  MOVLW  E8
69EA:  MOVWF  x29
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
69EC:  SETF   x1D
69EE:  SETF   x1C
....................    //delay_ms(3000); 
....................     
....................    booting_done=1; 
69F0:  MOVLW  01
69F2:  MOVWF  xB4
....................    booting=1; 
69F4:  MOVWF  x26
....................    charac_timeout=0xffffffff; 
69F6:  SETF   x1D
69F8:  SETF   x1C
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
69FA:  MOVLW  66
69FC:  MOVLB  7
69FE:  MOVWF  xDB
6A00:  MOVLW  10
6A02:  MOVWF  xDC
6A04:  MOVLW  06
6A06:  MOVWF  xDE
6A08:  MOVLW  CF
6A0A:  MOVWF  xDD
6A0C:  MOVLB  0
6A0E:  CALL   4376
....................    EEPROM_read(strobe_pass_addr,20,password); 
6A12:  MOVLB  7
6A14:  CLRF   xDB
6A16:  MOVLW  14
6A18:  MOVWF  xDC
6A1A:  CLRF   xDE
6A1C:  MOVLW  76
6A1E:  MOVWF  xDD
6A20:  MOVLB  0
6A22:  CALL   4376
....................    set_tris_a(0xff);  
6A26:  MOVLW  FF
6A28:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
6A2A:  MOVLW  E0
6A2C:  MOVLB  F
6A2E:  MOVWF  x48
6A30:  BCF    FC2.6
6A32:  BCF    FC2.7
6A34:  MOVF   x49,W
6A36:  ANDLW  E0
6A38:  IORLW  1F
6A3A:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
6A3C:  MOVF   FC1,W
6A3E:  ANDLW  C0
6A40:  IORLW  03
6A42:  MOVWF  FC1
6A44:  BCF    FC1.7
6A46:  BSF    FC2.0
6A48:  BSF    FC1.6
6A4A:  BSF    FC2.1
6A4C:  BTFSC  FC2.1
6A4E:  BRA    6A4C
6A50:  BCF    FC1.6
6A52:  CLRF   19
6A54:  BTFSC  FF2.7
6A56:  BSF    19.7
6A58:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
6A5A:  MOVLB  8
6A5C:  CLRF   x13
6A5E:  CLRF   x12
6A60:  CLRF   x11
6A62:  MOVLW  7F
6A64:  MOVWF  x10
6A66:  MOVLB  0
6A68:  CALL   32E0
6A6C:  BTFSC  19.7
6A6E:  BSF    FF2.7
6A70:  MOVFF  01,130
6A74:  CLRF   19
6A76:  BTFSC  FF2.7
6A78:  BSF    19.7
6A7A:  BCF    FF2.7
....................    type_KB=read_ext_eeprom(kindofKB); 
6A7C:  MOVLB  8
6A7E:  CLRF   x13
6A80:  CLRF   x12
6A82:  CLRF   x11
6A84:  MOVLW  7E
6A86:  MOVWF  x10
6A88:  MOVLB  0
6A8A:  CALL   32E0
6A8E:  BTFSC  19.7
6A90:  BSF    FF2.7
6A92:  MOVFF  01,134
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
6A96:  MOVLB  1
6A98:  MOVF   x34,F
6A9A:  BZ    6ABA
6A9C:  MOVLW  FC
6A9E:  MOVWF  FF6
6AA0:  MOVLW  42
6AA2:  MOVWF  FF7
6AA4:  CLRF   19
6AA6:  BTFSC  FF2.7
6AA8:  BSF    19.7
6AAA:  BCF    FF2.7
6AAC:  MOVLB  0
6AAE:  CALL   0474
6AB2:  BTFSC  19.7
6AB4:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
6AB6:  BRA    6AD4
6AB8:  MOVLB  1
6ABA:  MOVLW  10
6ABC:  MOVWF  FF6
6ABE:  MOVLW  43
6AC0:  MOVWF  FF7
6AC2:  CLRF   19
6AC4:  BTFSC  FF2.7
6AC6:  BSF    19.7
6AC8:  BCF    FF2.7
6ACA:  MOVLB  0
6ACC:  CALL   0474
6AD0:  BTFSC  19.7
6AD2:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
6AD4:  MOVLB  6
6AD6:  MOVF   xCA,F
6AD8:  BNZ   6AF8
6ADA:  MOVLW  24
6ADC:  MOVWF  FF6
6ADE:  MOVLW  43
6AE0:  MOVWF  FF7
6AE2:  CLRF   19
6AE4:  BTFSC  FF2.7
6AE6:  BSF    19.7
6AE8:  BCF    FF2.7
6AEA:  MOVLB  0
6AEC:  CALL   0474
6AF0:  BTFSC  19.7
6AF2:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
6AF4:  BRA    6B12
6AF6:  MOVLB  6
6AF8:  MOVLW  3E
6AFA:  MOVWF  FF6
6AFC:  MOVLW  43
6AFE:  MOVWF  FF7
6B00:  CLRF   19
6B02:  BTFSC  FF2.7
6B04:  BSF    19.7
6B06:  BCF    FF2.7
6B08:  MOVLB  0
6B0A:  CALL   0474
6B0E:  BTFSC  19.7
6B10:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
6B12:  MOVLW  01
6B14:  MOVWF  FEA
6B16:  MOVLW  35
6B18:  MOVWF  FE9
6B1A:  CLRF   00
6B1C:  CLRF   02
6B1E:  MOVLW  10
6B20:  MOVWF  01
6B22:  CALL   3DC2
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
6B26:  MOVLB  6
6B28:  CLRF   xE9
6B2A:  MOVF   xE9,W
6B2C:  SUBLW  13
6B2E:  BNC   6B44
....................    { 
....................       password[i] = 0; 
6B30:  CLRF   03
6B32:  MOVF   xE9,W
6B34:  ADDLW  76
6B36:  MOVWF  FE9
6B38:  MOVLW  00
6B3A:  ADDWFC 03,W
6B3C:  MOVWF  FEA
6B3E:  CLRF   FEF
....................    } 
6B40:  INCF   xE9,F
6B42:  BRA    6B2A
.................... #endif    
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
6B44:  MOVF   xC4,F
6B46:  BNZ   6BD2
....................       { 
....................          fprintf(COM2,"password:"); 
6B48:  MOVLW  56
6B4A:  MOVWF  FF6
6B4C:  MOVLW  43
6B4E:  MOVWF  FF7
6B50:  CLRF   19
6B52:  BTFSC  FF2.7
6B54:  BSF    19.7
6B56:  BCF    FF2.7
6B58:  MOVLB  0
6B5A:  CALL   0474
6B5E:  BTFSC  19.7
6B60:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
6B62:  MOVLW  02
6B64:  MOVLB  7
6B66:  MOVWF  xDB
6B68:  MOVLW  14
6B6A:  MOVWF  xDC
6B6C:  MOVLW  01
6B6E:  MOVWF  xDE
6B70:  MOVLW  4D
6B72:  MOVWF  xDD
6B74:  MOVLB  0
6B76:  CALL   4826
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          if(!stringcomp(buffer_uart,password)) 
6B7A:  MOVLW  01
6B7C:  MOVLB  7
6B7E:  MOVWF  xDC
6B80:  MOVLW  4D
6B82:  MOVWF  xDB
6B84:  CLRF   xDE
6B86:  MOVLW  76
6B88:  MOVWF  xDD
6B8A:  MOVLB  0
6B8C:  CALL   495E
6B90:  MOVF   01,F
6B92:  BNZ   6BB6
....................          { 
....................             mode=LOGON; 
6B94:  MOVLW  01
6B96:  MOVLB  6
6B98:  MOVWF  xC4
....................             fprintf(COM2," OK\n\r"); 
6B9A:  MOVLW  60
6B9C:  MOVWF  FF6
6B9E:  MOVLW  43
6BA0:  MOVWF  FF7
6BA2:  CLRF   19
6BA4:  BTFSC  FF2.7
6BA6:  BSF    19.7
6BA8:  BCF    FF2.7
6BAA:  MOVLB  0
6BAC:  CALL   0474
6BB0:  BTFSC  19.7
6BB2:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
6BB4:  BRA    6BCE
6BB6:  MOVLW  66
6BB8:  MOVWF  FF6
6BBA:  MOVLW  43
6BBC:  MOVWF  FF7
6BBE:  CLRF   19
6BC0:  BTFSC  FF2.7
6BC2:  BSF    19.7
6BC4:  BCF    FF2.7
6BC6:  CALL   0474
6BCA:  BTFSC  19.7
6BCC:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
6BCE:  BRA    6BDC
6BD0:  MOVLB  6
6BD2:  DECFSZ xC4,W
6BD4:  BRA    6BDE
6BD6:  MOVLB  0
6BD8:  GOTO   5120
6BDC:  MOVLB  6
....................    } 
6BDE:  BRA    6B44
.................... } 
6BE0:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

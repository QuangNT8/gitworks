CCS PCH C Compiler, Version 4.140, 33034               22-Jul-18 11:50

               Filename:   D:\STM32\workspace\gitworks\mag_pro\integrate2018\firmware\main.lst

               ROM used:   30992 bytes (47%)
                           Largest free fragment is 34532
               RAM used:   1979 (52%) at main() level
                           2148 (57%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   7354
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   51B8
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1BA8
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0642:  MOVLW  02
0644:  MOVLB  8
0646:  SUBWF  x27,F
0648:  BNC   0662
064A:  MOVLW  08
064C:  MOVWF  FEA
064E:  MOVLW  27
0650:  MOVWF  FE9
0652:  MOVF   FEF,W
0654:  BZ    0662
0656:  BRA    065E
0658:  BRA    065A
065A:  BRA    065C
065C:  NOP   
065E:  DECFSZ FEF,F
0660:  BRA    0658
0662:  MOVLB  0
0664:  GOTO   1BB8 (RETURN)
*
1882:  MOVLW  08
1884:  MOVWF  FEA
1886:  MOVLW  2F
1888:  MOVWF  FE9
188A:  MOVF   FEF,W
188C:  BZ    18A8
188E:  MOVLW  0A
1890:  MOVWF  01
1892:  CLRF   00
1894:  DECFSZ 00,F
1896:  BRA    1894
1898:  DECFSZ 01,F
189A:  BRA    1892
189C:  MOVLW  5F
189E:  MOVWF  00
18A0:  DECFSZ 00,F
18A2:  BRA    18A0
18A4:  DECFSZ FEF,F
18A6:  BRA    188E
18A8:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
15C0:  BCF    F94.0
15C2:  BCF    F8B.0
15C4:  MOVLW  08
15C6:  MOVWF  01
15C8:  BRA    15CA
15CA:  NOP   
15CC:  BSF    01.7
15CE:  BRA    15F0
15D0:  BCF    01.7
15D2:  MOVLB  8
15D4:  RRCF   x52,F
15D6:  MOVLB  0
15D8:  BTFSC  FD8.0
15DA:  BSF    F8B.0
15DC:  BTFSS  FD8.0
15DE:  BCF    F8B.0
15E0:  BSF    01.6
15E2:  BRA    15F0
15E4:  BCF    01.6
15E6:  DECFSZ 01,F
15E8:  BRA    15D2
15EA:  BRA    15EC
15EC:  NOP   
15EE:  BSF    F8B.0
15F0:  MOVLW  10
15F2:  MOVWF  FE9
15F4:  DECFSZ FE9,F
15F6:  BRA    15F4
15F8:  BRA    15FA
15FA:  NOP   
15FC:  BTFSC  01.7
15FE:  BRA    15D0
1600:  BTFSC  01.6
1602:  BRA    15E4
1604:  RETURN 0
*
5772:  BSF    F94.1
5774:  BTFSC  F82.1
5776:  BRA    5774
5778:  MOVLW  08
577A:  MOVWF  00
577C:  MOVLB  7
577E:  CLRF   xFA
5780:  BSF    00.7
5782:  BRA    57A4
5784:  BCF    00.7
5786:  BRA    57A4
5788:  MOVFF  7FA,02
578C:  BCF    FD8.0
578E:  BTFSC  F82.1
5790:  BSF    FD8.0
5792:  RRCF   02,F
5794:  BSF    00.6
5796:  BRA    57A4
5798:  BCF    00.6
579A:  DECFSZ 00,F
579C:  BRA    578C
579E:  MOVFF  02,01
57A2:  BRA    57BC
57A4:  MOVLW  10
57A6:  BTFSC  00.7
57A8:  MOVLW  04
57AA:  MOVWF  01
57AC:  DECFSZ 01,F
57AE:  BRA    57AC
57B0:  BRA    57B2
57B2:  BTFSC  00.7
57B4:  BRA    5784
57B6:  BTFSC  00.6
57B8:  BRA    5798
57BA:  BRA    578C
57BC:  MOVLB  0
57BE:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3320:  MOVLW  08
3322:  MOVWF  01
3324:  MOVLW  0A
3326:  MOVWF  00
3328:  DECFSZ 00,F
332A:  BRA    3328
332C:  BCF    F8B.3
332E:  BCF    F94.3
3330:  MOVLW  0B
3332:  MOVWF  00
3334:  DECFSZ 00,F
3336:  BRA    3334
3338:  MOVLB  8
333A:  RLCF   x5C,F
333C:  BCF    F8B.4
333E:  BTFSC  FD8.0
3340:  BSF    F94.4
3342:  BTFSS  FD8.0
3344:  BCF    F94.4
3346:  BSF    F94.3
3348:  BTFSS  F82.3
334A:  BRA    3348
334C:  DECFSZ 01,F
334E:  BRA    3352
3350:  BRA    3356
3352:  MOVLB  0
3354:  BRA    3324
3356:  MOVLW  0A
3358:  MOVWF  00
335A:  DECFSZ 00,F
335C:  BRA    335A
335E:  BCF    F8B.3
3360:  BCF    F94.3
3362:  NOP   
3364:  BSF    F94.4
3366:  MOVLW  0B
3368:  MOVWF  00
336A:  DECFSZ 00,F
336C:  BRA    336A
336E:  MOVLW  0B
3370:  MOVWF  00
3372:  DECFSZ 00,F
3374:  BRA    3372
3376:  BSF    F94.3
3378:  BTFSS  F82.3
337A:  BRA    3378
337C:  CLRF   01
337E:  MOVLW  0B
3380:  MOVWF  00
3382:  DECFSZ 00,F
3384:  BRA    3382
3386:  BTFSC  F82.4
3388:  BSF    01.0
338A:  BCF    F8B.3
338C:  BCF    F94.3
338E:  BCF    F8B.4
3390:  BCF    F94.4
3392:  MOVLB  0
3394:  RETURN 0
3396:  MOVLW  08
3398:  MOVLB  8
339A:  MOVWF  x4A
339C:  MOVFF  00,84B
33A0:  BSF    F94.4
33A2:  MOVLW  0B
33A4:  MOVWF  00
33A6:  DECFSZ 00,F
33A8:  BRA    33A6
33AA:  BSF    F94.3
33AC:  BTFSS  F82.3
33AE:  BRA    33AC
33B0:  BTFSC  F82.4
33B2:  BSF    FD8.0
33B4:  BTFSS  F82.4
33B6:  BCF    FD8.0
33B8:  RLCF   01,F
33BA:  MOVLW  0A
33BC:  MOVWF  00
33BE:  DECFSZ 00,F
33C0:  BRA    33BE
33C2:  BCF    F94.3
33C4:  BCF    F8B.3
33C6:  DECFSZ x4A,F
33C8:  BRA    33A0
33CA:  BSF    F94.4
33CC:  MOVLW  0B
33CE:  MOVWF  00
33D0:  DECFSZ 00,F
33D2:  BRA    33D0
33D4:  BCF    F8B.4
33D6:  MOVF   x4B,W
33D8:  BTFSS  FD8.2
33DA:  BCF    F94.4
33DC:  NOP   
33DE:  BSF    F94.3
33E0:  BTFSS  F82.3
33E2:  BRA    33E0
33E4:  MOVLW  0A
33E6:  MOVWF  00
33E8:  DECFSZ 00,F
33EA:  BRA    33E8
33EC:  BCF    F8B.3
33EE:  BCF    F94.3
33F0:  MOVLW  0B
33F2:  MOVWF  00
33F4:  DECFSZ 00,F
33F6:  BRA    33F4
33F8:  BCF    F8B.4
33FA:  BCF    F94.4
33FC:  MOVLB  0
33FE:  RETURN 0
....................  
.................... #define ptr_start                       150 
.................... #define EEPROM_SIZE_endofkey            131071 
.................... #define EEPROM_SIZE_stofkey             115470 
.................... #define EEPROM_KEY_ST                   EEPROM_SIZE_stofkey+1 
.................... //=============================== 
....................  
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5490:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
5492:  BSF    F94.4
....................    port_b_pullups(0xff); 
5494:  BCF    FF1.7
.................... } 
5496:  GOTO   74E6 (RETURN)
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3950:  MOVLB  8
3952:  MOVF   x53,F
3954:  BNZ   395C
3956:  MOVF   x52,W
3958:  SUBLW  00
395A:  BC    3962
395C:  MOVLW  A8
395E:  MOVWF  x56
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3960:  BRA    3966
3962:  MOVLW  A0
3964:  MOVWF  x56
....................  
....................    i2c_start(); 
3966:  BSF    F94.4
3968:  MOVLW  0A
396A:  MOVWF  00
396C:  DECFSZ 00,F
396E:  BRA    396C
3970:  BSF    F94.3
3972:  MOVLW  0B
3974:  MOVWF  00
3976:  DECFSZ 00,F
3978:  BRA    3976
397A:  BCF    F8B.4
397C:  BCF    F94.4
397E:  MOVLW  0A
3980:  MOVWF  00
3982:  DECFSZ 00,F
3984:  BRA    3982
3986:  BCF    F8B.3
3988:  BCF    F94.3
....................    i2c_write(command); 
398A:  MOVFF  856,85C
398E:  MOVLB  0
3990:  RCALL  3320
....................    i2c_write(address>>8); 
3992:  MOVFF  851,858
3996:  MOVFF  852,859
399A:  MOVFF  853,85A
399E:  MOVLB  8
39A0:  CLRF   x5B
39A2:  MOVFF  851,85C
39A6:  MOVLB  0
39A8:  RCALL  3320
....................    i2c_write(address); 
39AA:  MOVFF  850,85C
39AE:  RCALL  3320
....................    i2c_write(data); 
39B0:  MOVFF  854,85C
39B4:  RCALL  3320
....................  
....................    i2c_stop(); 
39B6:  BCF    F94.4
39B8:  NOP   
39BA:  BSF    F94.3
39BC:  BTFSS  F82.3
39BE:  BRA    39BC
39C0:  MOVLW  0A
39C2:  MOVWF  00
39C4:  DECFSZ 00,F
39C6:  BRA    39C4
39C8:  BRA    39CA
39CA:  NOP   
39CC:  BSF    F94.4
39CE:  MOVLW  0A
39D0:  MOVWF  00
39D2:  DECFSZ 00,F
39D4:  BRA    39D2
....................    i2c_start(); 
39D6:  BSF    F94.4
39D8:  MOVLW  0A
39DA:  MOVWF  00
39DC:  DECFSZ 00,F
39DE:  BRA    39DC
39E0:  BSF    F94.3
39E2:  MOVLW  0B
39E4:  MOVWF  00
39E6:  DECFSZ 00,F
39E8:  BRA    39E6
39EA:  BCF    F8B.4
39EC:  BCF    F94.4
39EE:  MOVLW  0A
39F0:  MOVWF  00
39F2:  DECFSZ 00,F
39F4:  BRA    39F2
39F6:  BCF    F8B.3
39F8:  BCF    F94.3
....................    status=i2c_write(command); 
39FA:  MOVFF  856,85C
39FE:  RCALL  3320
3A00:  MOVF   01,W
3A02:  MOVLB  8
3A04:  BCF    x55.0
3A06:  BTFSC  01.0
3A08:  BSF    x55.0
....................    while(status==1) 
....................    { 
3A0A:  BTFSS  x55.0
3A0C:  BRA    3A4A
....................       i2c_start(); 
3A0E:  BSF    F94.4
3A10:  MOVLW  0A
3A12:  MOVWF  00
3A14:  DECFSZ 00,F
3A16:  BRA    3A14
3A18:  BSF    F94.3
3A1A:  MOVLW  0B
3A1C:  MOVWF  00
3A1E:  DECFSZ 00,F
3A20:  BRA    3A1E
3A22:  BTFSS  F82.3
3A24:  BRA    3A22
3A26:  BCF    F8B.4
3A28:  BCF    F94.4
3A2A:  MOVLW  0A
3A2C:  MOVWF  00
3A2E:  DECFSZ 00,F
3A30:  BRA    3A2E
3A32:  BCF    F8B.3
3A34:  BCF    F94.3
....................       status=i2c_write(command); 
3A36:  MOVFF  856,85C
3A3A:  MOVLB  0
3A3C:  RCALL  3320
3A3E:  MOVF   01,W
3A40:  MOVLB  8
3A42:  BCF    x55.0
3A44:  BTFSC  01.0
3A46:  BSF    x55.0
....................    } 
3A48:  BRA    3A0A
....................    //delay_us(100); 
.................... } 
3A4A:  MOVLB  0
3A4C:  RETURN 0
....................  
....................  
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3400:  MOVLB  8
3402:  MOVF   x46,F
3404:  BNZ   340C
3406:  MOVF   x45,W
3408:  SUBLW  00
340A:  BC    3412
340C:  MOVLW  A8
340E:  MOVWF  x48
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3410:  BRA    3416
3412:  MOVLW  A0
3414:  MOVWF  x48
....................  
....................    i2c_start(); 
3416:  BSF    F94.4
3418:  MOVLW  0A
341A:  MOVWF  00
341C:  DECFSZ 00,F
341E:  BRA    341C
3420:  BSF    F94.3
3422:  MOVLW  0B
3424:  MOVWF  00
3426:  DECFSZ 00,F
3428:  BRA    3426
342A:  BTFSS  F82.3
342C:  BRA    342A
342E:  BCF    F8B.4
3430:  BCF    F94.4
3432:  MOVLW  0A
3434:  MOVWF  00
3436:  DECFSZ 00,F
3438:  BRA    3436
343A:  BCF    F8B.3
343C:  BCF    F94.3
....................    i2c_write(command); 
343E:  MOVFF  848,85C
3442:  MOVLB  0
3444:  RCALL  3320
....................    i2c_write(address>>8); 
3446:  MOVFF  844,84A
344A:  MOVFF  845,84B
344E:  MOVFF  846,84C
3452:  MOVLB  8
3454:  CLRF   x4D
3456:  MOVFF  844,85C
345A:  MOVLB  0
345C:  RCALL  3320
....................    i2c_write(address); 
345E:  MOVFF  843,85C
3462:  RCALL  3320
....................    i2c_start(); 
3464:  BSF    F94.4
3466:  MOVLW  0A
3468:  MOVWF  00
346A:  DECFSZ 00,F
346C:  BRA    346A
346E:  BSF    F94.3
3470:  MOVLW  0B
3472:  MOVWF  00
3474:  DECFSZ 00,F
3476:  BRA    3474
3478:  BTFSS  F82.3
347A:  BRA    3478
347C:  BCF    F8B.4
347E:  BCF    F94.4
3480:  MOVLW  0A
3482:  MOVWF  00
3484:  DECFSZ 00,F
3486:  BRA    3484
3488:  BCF    F8B.3
348A:  BCF    F94.3
....................    i2c_write(command+1); 
348C:  MOVLW  01
348E:  MOVLB  8
3490:  ADDWF  x48,W
3492:  MOVWF  x49
3494:  MOVWF  x5C
3496:  MOVLB  0
3498:  RCALL  3320
....................    data=i2c_read(0); 
349A:  CLRF   00
349C:  RCALL  3396
349E:  MOVFF  01,847
....................    i2c_stop(); 
34A2:  BCF    F94.4
34A4:  NOP   
34A6:  BSF    F94.3
34A8:  BTFSS  F82.3
34AA:  BRA    34A8
34AC:  MOVLW  0A
34AE:  MOVWF  00
34B0:  DECFSZ 00,F
34B2:  BRA    34B0
34B4:  BRA    34B6
34B6:  NOP   
34B8:  BSF    F94.4
34BA:  MOVLW  0A
34BC:  MOVWF  00
34BE:  DECFSZ 00,F
34C0:  BRA    34BE
....................    return(data); 
34C2:  MOVLB  8
34C4:  MOVFF  847,01
.................... } 
34C8:  MOVLB  0
34CA:  RETURN 0
....................  
....................  
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE_stofkey) return(0); 
*
5990:  MOVLB  7
5992:  MOVF   xF5,W
5994:  ADDWF  xF3,W
5996:  MOVF   xF6,W
5998:  ADDWFC xF4,W
599A:  MOVWF  xFC
....................    for(i=0;i<len;i++) 
599C:  CLRF   xFA
599E:  CLRF   xF9
59A0:  MOVF   xFA,W
59A2:  SUBWF  xF6,W
59A4:  BNC   5A00
59A6:  BNZ   59AE
59A8:  MOVF   xF5,W
59AA:  SUBWF  xF9,W
59AC:  BC    5A00
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
59AE:  MOVF   xF7,W
59B0:  ADDWF  xF9,W
59B2:  MOVWF  01
59B4:  MOVF   xF8,W
59B6:  ADDWFC xFA,W
59B8:  MOVWF  03
59BA:  MOVFF  01,7FB
59BE:  MOVWF  xFC
59C0:  MOVF   xF9,W
59C2:  ADDWF  xF3,W
59C4:  MOVWF  xFD
59C6:  MOVF   xFA,W
59C8:  ADDWFC xF4,W
59CA:  MOVWF  xFE
59CC:  CLRF   19
59CE:  BTFSC  FF2.7
59D0:  BSF    19.7
59D2:  BCF    FF2.7
59D4:  MOVLB  8
59D6:  CLRF   x46
59D8:  CLRF   x45
59DA:  MOVWF  x44
59DC:  MOVFF  7FD,843
59E0:  MOVLB  0
59E2:  CALL   3400
59E6:  BTFSC  19.7
59E8:  BSF    FF2.7
59EA:  MOVFF  7FC,FEA
59EE:  MOVFF  7FB,FE9
59F2:  MOVFF  01,FEF
....................    } 
59F6:  MOVLB  7
59F8:  INCF   xF9,F
59FA:  BTFSC  FD8.2
59FC:  INCF   xFA,F
59FE:  BRA    59A0
....................     
.................... } 
5A00:  MOVLB  0
5A02:  GOTO   5F72 (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define strobe_pass_addr            0 
.................... #define strobe_ptrcard_addr         25     // 4 bytes 
.................... #define strobe_ptrcard_key          30     // 4 bytes 
.................... #define strobe_count_card           36     // 2 bytes 
.................... #define strobe_nameconsole          40     // 16 bytes  
.................... #define strobe_Master_SLV           58     // 1 byte 
.................... #define strobe_debugmode            59     // 1 byte 
.................... #define strobe_delaytime            60     // 1 byte 
.................... #define kindofKB                    61     // 1 byte 
.................... #define crypto_en                   62     // 1 byte 
.................... #define strobe_crypto_key           63     // 32 byte 
....................  
....................  
.................... #define wide_strobe_nameconsole     16  
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards               930   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
3546:  MOVLB  8
3548:  CLRF   x3B
354A:  MOVF   x38,W
354C:  SUBWF  x3B,W
354E:  BC    3564
....................    { 
....................       inputdat[i]=0; 
3550:  CLRF   03
3552:  MOVF   x3B,W
3554:  ADDWF  x39,W
3556:  MOVWF  FE9
3558:  MOVF   x3A,W
355A:  ADDWFC 03,W
355C:  MOVWF  FEA
355E:  CLRF   FEF
....................    } 
3560:  INCF   x3B,F
3562:  BRA    354A
.................... } 
3564:  MOVLB  0
3566:  RETURN 0
.................... //=============================================================== 
.................... int8 EEPROM_write(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
4DBE:  MOVLB  8
4DC0:  CLRF   x4A
4DC2:  CLRF   x49
4DC4:  CLRF   x48
4DC6:  CLRF   x47
4DC8:  MOVF   x4A,W
4DCA:  SUBWF  x44,W
4DCC:  BNC   4E46
4DCE:  BNZ   4DE6
4DD0:  MOVF   x49,W
4DD2:  SUBWF  x43,W
4DD4:  BNC   4E46
4DD6:  BNZ   4DE6
4DD8:  MOVF   x48,W
4DDA:  SUBWF  x42,W
4DDC:  BNC   4E46
4DDE:  BNZ   4DE6
4DE0:  MOVF   x41,W
4DE2:  SUBWF  x47,W
4DE4:  BC    4E46
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4DE6:  MOVF   x47,W
4DE8:  ADDWF  x3D,W
4DEA:  MOVWF  x4B
4DEC:  MOVF   x48,W
4DEE:  ADDWFC x3E,W
4DF0:  MOVWF  x4C
4DF2:  MOVF   x49,W
4DF4:  ADDWFC x3F,W
4DF6:  MOVWF  x4D
4DF8:  MOVF   x4A,W
4DFA:  ADDWFC x40,W
4DFC:  MOVWF  x4E
4DFE:  MOVF   x45,W
4E00:  ADDWF  x47,W
4E02:  MOVWF  FE9
4E04:  MOVF   x46,W
4E06:  ADDWFC x48,W
4E08:  MOVWF  FEA
4E0A:  MOVFF  FEF,84F
4E0E:  MOVFF  84E,853
4E12:  MOVFF  84D,852
4E16:  MOVFF  84C,851
4E1A:  MOVFF  84B,850
4E1E:  MOVFF  84F,854
4E22:  MOVLB  0
4E24:  CALL   3950
....................       delay_us(10); 
4E28:  MOVLW  1A
4E2A:  MOVWF  00
4E2C:  DECFSZ 00,F
4E2E:  BRA    4E2C
4E30:  NOP   
....................    } 
4E32:  MOVLW  01
4E34:  MOVLB  8
4E36:  ADDWF  x47,F
4E38:  BTFSC  FD8.0
4E3A:  INCF   x48,F
4E3C:  BTFSC  FD8.2
4E3E:  INCF   x49,F
4E40:  BTFSC  FD8.2
4E42:  INCF   x4A,F
4E44:  BRA    4DC8
....................    return 1; 
4E46:  MOVLW  01
4E48:  MOVWF  01
.................... } 
4E4A:  MOVLB  0
4E4C:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int32 adr, unsigned int32 len, int8 *buf) 
.................... { 
....................    unsigned int32 i; 
....................    for(i=0;i<len;i++) 
*
549A:  MOVLB  7
549C:  CLRF   xFE
549E:  CLRF   xFD
54A0:  CLRF   xFC
54A2:  CLRF   xFB
54A4:  MOVF   xFE,W
54A6:  SUBWF  xF8,W
54A8:  BNC   5546
54AA:  BNZ   54C2
54AC:  MOVF   xFD,W
54AE:  SUBWF  xF7,W
54B0:  BNC   5546
54B2:  BNZ   54C2
54B4:  MOVF   xFC,W
54B6:  SUBWF  xF6,W
54B8:  BNC   5546
54BA:  BNZ   54C2
54BC:  MOVF   xF5,W
54BE:  SUBWF  xFB,W
54C0:  BC    5546
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
54C2:  MOVF   xF9,W
54C4:  ADDWF  xFB,W
54C6:  MOVWF  01
54C8:  MOVF   xFA,W
54CA:  ADDWFC xFC,W
54CC:  MOVWF  03
54CE:  MOVFF  01,7FF
54D2:  MOVFF  FE8,800
54D6:  MOVF   xFB,W
54D8:  ADDWF  xF1,W
54DA:  MOVLB  8
54DC:  MOVWF  x01
54DE:  MOVLB  7
54E0:  MOVF   xFC,W
54E2:  ADDWFC xF2,W
54E4:  MOVLB  8
54E6:  MOVWF  x02
54E8:  MOVLB  7
54EA:  MOVF   xFD,W
54EC:  ADDWFC xF3,W
54EE:  MOVLB  8
54F0:  MOVWF  x03
54F2:  MOVLB  7
54F4:  MOVF   xFE,W
54F6:  ADDWFC xF4,W
54F8:  MOVLB  8
54FA:  MOVWF  x04
54FC:  CLRF   19
54FE:  BTFSC  FF2.7
5500:  BSF    19.7
5502:  BCF    FF2.7
5504:  MOVWF  x46
5506:  MOVFF  803,845
550A:  MOVFF  802,844
550E:  MOVFF  801,843
5512:  MOVLB  0
5514:  CALL   3400
5518:  BTFSC  19.7
551A:  BSF    FF2.7
551C:  MOVFF  800,FEA
5520:  MOVFF  7FF,FE9
5524:  MOVFF  01,FEF
....................       delay_us(10); 
5528:  MOVLW  1A
552A:  MOVWF  00
552C:  DECFSZ 00,F
552E:  BRA    552C
5530:  NOP   
....................    } 
5532:  MOVLW  01
5534:  MOVLB  7
5536:  ADDWF  xFB,F
5538:  BTFSC  FD8.0
553A:  INCF   xFC,F
553C:  BTFSC  FD8.2
553E:  INCF   xFD,F
5540:  BTFSC  FD8.2
5542:  INCF   xFE,F
5544:  BRA    54A4
.................... } 
5546:  MOVLB  0
5548:  RETURN 0
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
55EA:  MOVLB  7
55EC:  CLRF   xBD
55EE:  CLRF   xBC
55F0:  CLRF   xBB
55F2:  CLRF   xBA
55F4:  CLRF   xC1
55F6:  CLRF   xC0
55F8:  CLRF   xBF
55FA:  CLRF   xBE
55FC:  CLRF   xC5
55FE:  CLRF   xC4
5600:  CLRF   xC3
5602:  CLRF   xC2
5604:  CLRF   xC9
5606:  CLRF   xC8
5608:  CLRF   xC7
560A:  CLRF   xC6
560C:  CLRF   xCD
560E:  CLRF   xCC
5610:  CLRF   xCB
5612:  CLRF   xCA
5614:  CLRF   19
5616:  BTFSC  FF2.7
5618:  BSF    19.7
561A:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
561C:  MOVLB  8
561E:  CLRF   x46
5620:  CLRF   x45
5622:  CLRF   x44
5624:  MOVFF  7B9,843
5628:  MOVLB  0
562A:  CALL   3400
562E:  BTFSC  19.7
5630:  BSF    FF2.7
5632:  MOVLB  7
5634:  MOVFF  01,7BE
5638:  CLRF   xBF
563A:  CLRF   xC0
563C:  CLRF   xC1
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
563E:  MOVLW  01
5640:  ADDWF  xB9,W
5642:  MOVWF  xCE
5644:  CLRF   19
5646:  BTFSC  FF2.7
5648:  BSF    19.7
564A:  BCF    FF2.7
564C:  MOVLB  8
564E:  CLRF   x46
5650:  CLRF   x45
5652:  CLRF   x44
5654:  MOVWF  x43
5656:  MOVLB  0
5658:  CALL   3400
565C:  BTFSC  19.7
565E:  BSF    FF2.7
5660:  MOVLB  7
5662:  CLRF   xC5
5664:  CLRF   xC4
5666:  CLRF   xC3
5668:  MOVFF  01,7C2
....................    temp2<<=8; 
566C:  MOVFF  7C4,7C5
5670:  MOVFF  7C3,7C4
5674:  MOVFF  7C2,7C3
5678:  CLRF   xC2
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
567A:  MOVLW  02
567C:  ADDWF  xB9,W
567E:  MOVWF  xCE
5680:  CLRF   19
5682:  BTFSC  FF2.7
5684:  BSF    19.7
5686:  BCF    FF2.7
5688:  MOVLB  8
568A:  CLRF   x46
568C:  CLRF   x45
568E:  CLRF   x44
5690:  MOVWF  x43
5692:  MOVLB  0
5694:  CALL   3400
5698:  BTFSC  19.7
569A:  BSF    FF2.7
569C:  MOVLB  7
569E:  CLRF   xC9
56A0:  CLRF   xC8
56A2:  CLRF   xC7
56A4:  MOVFF  01,7C6
....................    temp3<<=16; 
56A8:  MOVFF  7C7,7C9
56AC:  MOVFF  7C6,7C8
56B0:  CLRF   xC6
56B2:  CLRF   xC7
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
56B4:  MOVLW  03
56B6:  ADDWF  xB9,W
56B8:  MOVWF  xCE
56BA:  CLRF   19
56BC:  BTFSC  FF2.7
56BE:  BSF    19.7
56C0:  BCF    FF2.7
56C2:  MOVLB  8
56C4:  CLRF   x46
56C6:  CLRF   x45
56C8:  CLRF   x44
56CA:  MOVWF  x43
56CC:  MOVLB  0
56CE:  CALL   3400
56D2:  BTFSC  19.7
56D4:  BSF    FF2.7
56D6:  MOVLB  7
56D8:  CLRF   xCD
56DA:  CLRF   xCC
56DC:  CLRF   xCB
56DE:  MOVFF  01,7CA
....................    temp4<<=24; 
56E2:  MOVFF  7CA,7CD
56E6:  CLRF   xCA
56E8:  CLRF   xCB
56EA:  CLRF   xCC
....................    buffer = temp4|temp3|temp2|temp1; 
56EC:  MOVF   xCA,W
56EE:  IORWF  xC6,W
56F0:  MOVWF  xCE
56F2:  MOVF   xCB,W
56F4:  IORWF  xC7,W
56F6:  MOVWF  xCF
56F8:  MOVF   xCC,W
56FA:  IORWF  xC8,W
56FC:  MOVWF  xD0
56FE:  MOVF   xCD,W
5700:  IORWF  xC9,W
5702:  MOVWF  xD1
5704:  MOVF   xC2,W
5706:  IORWF  xCE,F
5708:  MOVF   xC3,W
570A:  IORWF  xCF,F
570C:  MOVF   xC4,W
570E:  IORWF  xD0,F
5710:  MOVF   xC5,W
5712:  IORWF  xD1,F
5714:  MOVF   xCE,W
5716:  IORWF  xBE,W
5718:  MOVWF  xBA
571A:  MOVF   xCF,W
571C:  IORWF  xBF,W
571E:  MOVWF  xBB
5720:  MOVF   xD0,W
5722:  IORWF  xC0,W
5724:  MOVWF  xBC
5726:  MOVF   xD1,W
5728:  IORWF  xC1,W
572A:  MOVWF  xBD
....................    return(buffer); 
572C:  MOVFF  7BA,00
5730:  MOVFF  7BB,01
5734:  MOVFF  7BC,02
5738:  MOVFF  7BD,03
.................... } 
573C:  MOVLB  0
573E:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3A68:  MOVLB  8
3A6A:  CLRF   x45
3A6C:  CLRF   x44
3A6E:  CLRF   x43
3A70:  CLRF   x42
3A72:  CLRF   x46
3A74:  CLRF   x47
3A76:  CLRF   x48
3A78:  CLRF   x49
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3A7A:  MOVFF  840,845
3A7E:  MOVFF  83F,844
3A82:  MOVFF  83E,843
3A86:  MOVFF  83D,842
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3A8A:  MOVFF  842,846
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3A8E:  MOVFF  843,847
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3A92:  MOVFF  844,848
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3A96:  MOVFF  845,849
....................    write_ext_eeprom((addr+0),temp1); 
3A9A:  CLRF   x53
3A9C:  CLRF   x52
3A9E:  CLRF   x51
3AA0:  MOVFF  841,850
3AA4:  MOVFF  846,854
3AA8:  MOVLB  0
3AAA:  RCALL  3950
....................    write_ext_eeprom((addr+1),temp2); 
3AAC:  MOVLW  01
3AAE:  MOVLB  8
3AB0:  ADDWF  x41,W
3AB2:  MOVWF  x4A
3AB4:  CLRF   x53
3AB6:  CLRF   x52
3AB8:  CLRF   x51
3ABA:  MOVWF  x50
3ABC:  MOVFF  847,854
3AC0:  MOVLB  0
3AC2:  RCALL  3950
....................    write_ext_eeprom((addr+2),temp3); 
3AC4:  MOVLW  02
3AC6:  MOVLB  8
3AC8:  ADDWF  x41,W
3ACA:  MOVWF  x4A
3ACC:  CLRF   x53
3ACE:  CLRF   x52
3AD0:  CLRF   x51
3AD2:  MOVWF  x50
3AD4:  MOVFF  848,854
3AD8:  MOVLB  0
3ADA:  RCALL  3950
....................    write_ext_eeprom((addr+3),temp4); 
3ADC:  MOVLW  03
3ADE:  MOVLB  8
3AE0:  ADDWF  x41,W
3AE2:  MOVWF  x4A
3AE4:  CLRF   x53
3AE6:  CLRF   x52
3AE8:  CLRF   x51
3AEA:  MOVWF  x50
3AEC:  MOVFF  849,854
3AF0:  MOVLB  0
3AF2:  RCALL  3950
.................... } 
3AF4:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
507C:  MOVLB  8
507E:  CLRF   x2C
5080:  CLRF   x2B
5082:  CLRF   x2D
5084:  CLRF   x2E
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
5086:  MOVFF  82A,82C
508A:  MOVFF  829,82B
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
508E:  MOVFF  82B,82D
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
5092:  MOVF   x2C,W
5094:  MOVWF  x2E
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
5096:  CLRF   x53
5098:  CLRF   x52
509A:  CLRF   x51
509C:  MOVLW  24
509E:  MOVWF  x50
50A0:  MOVFF  82D,854
50A4:  MOVLB  0
50A6:  CALL   3950
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
50AA:  MOVLB  8
50AC:  CLRF   x53
50AE:  CLRF   x52
50B0:  CLRF   x51
50B2:  MOVLW  25
50B4:  MOVWF  x50
50B6:  MOVFF  82E,854
50BA:  MOVLB  0
50BC:  CALL   3950
.................... } 
50C0:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
34CC:  MOVLB  8
34CE:  CLRF   x3E
34D0:  CLRF   x3D
34D2:  CLRF   x40
34D4:  CLRF   x3F
34D6:  CLRF   x42
34D8:  CLRF   x41
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
34DA:  CLRF   x46
34DC:  CLRF   x45
34DE:  CLRF   x44
34E0:  MOVLW  24
34E2:  MOVWF  x43
34E4:  MOVLB  0
34E6:  RCALL  3400
34E8:  MOVLB  8
34EA:  MOVFF  01,83F
34EE:  CLRF   x40
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
34F0:  CLRF   x46
34F2:  CLRF   x45
34F4:  CLRF   x44
34F6:  MOVLW  25
34F8:  MOVWF  x43
34FA:  MOVLB  0
34FC:  RCALL  3400
34FE:  MOVLB  8
3500:  CLRF   x42
3502:  MOVFF  01,841
....................    temp2<<=8; 
3506:  MOVFF  841,842
350A:  CLRF   x41
....................    buffer = temp2|temp1; 
350C:  MOVF   x41,W
350E:  IORWF  x3F,W
3510:  MOVWF  x3D
3512:  MOVF   x42,W
3514:  IORWF  x40,W
3516:  MOVWF  x3E
....................    return(buffer); 
3518:  MOVFF  83D,01
351C:  MOVFF  83E,02
.................... } 
3520:  MOVLB  0
3522:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................    /*for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    }*/ 
....................    //fprintf(COM2," ptr_card=%lu\n\r",ptr_card); 
....................    /*for(i=ptr_start;i<ptr_card;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
*
5B20:  CLRF   23
5B22:  CLRF   22
5B24:  CLRF   21
5B26:  MOVLW  96
5B28:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5B2A:  CLRF   27
5B2C:  MOVLW  01
5B2E:  MOVWF  26
5B30:  MOVLW  C3
5B32:  MOVWF  25
5B34:  MOVLW  0F
5B36:  MOVWF  24
5B38:  CLRF   19
5B3A:  BTFSC  FF2.7
5B3C:  BSF    19.7
5B3E:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5B40:  MOVFF  23,840
5B44:  MOVFF  22,83F
5B48:  MOVFF  21,83E
5B4C:  MOVFF  20,83D
5B50:  MOVLW  19
5B52:  MOVLB  8
5B54:  MOVWF  x41
5B56:  MOVLB  0
5B58:  CALL   3A68
5B5C:  BTFSC  19.7
5B5E:  BSF    FF2.7
5B60:  CLRF   19
5B62:  BTFSC  FF2.7
5B64:  BSF    19.7
5B66:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5B68:  MOVFF  27,840
5B6C:  MOVFF  26,83F
5B70:  MOVFF  25,83E
5B74:  MOVFF  24,83D
5B78:  MOVLW  1E
5B7A:  MOVLB  8
5B7C:  MOVWF  x41
5B7E:  MOVLB  0
5B80:  CALL   3A68
5B84:  BTFSC  19.7
5B86:  BSF    FF2.7
5B88:  CLRF   19
5B8A:  BTFSC  FF2.7
5B8C:  BSF    19.7
5B8E:  BCF    FF2.7
....................    save_coutcard(0); 
5B90:  MOVLB  8
5B92:  CLRF   x2A
5B94:  CLRF   x29
5B96:  MOVLB  0
5B98:  CALL   507C
5B9C:  BTFSC  19.7
5B9E:  BSF    FF2.7
5BA0:  CLRF   19
5BA2:  BTFSC  FF2.7
5BA4:  BSF    19.7
5BA6:  BCF    FF2.7
....................    countcard=get_countcard(); 
5BA8:  CALL   34CC
5BAC:  BTFSC  19.7
5BAE:  BSF    FF2.7
5BB0:  MOVFF  02,FA
5BB4:  MOVFF  01,F9
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
5BB8:  GOTO   6318 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    ptr_card=ptr_start; 
5BBC:  CLRF   23
5BBE:  CLRF   22
5BC0:  CLRF   21
5BC2:  MOVLW  96
5BC4:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5BC6:  CLRF   27
5BC8:  MOVLW  01
5BCA:  MOVWF  26
5BCC:  MOVLW  C3
5BCE:  MOVWF  25
5BD0:  MOVLW  0F
5BD2:  MOVWF  24
5BD4:  CLRF   19
5BD6:  BTFSC  FF2.7
5BD8:  BSF    19.7
5BDA:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5BDC:  MOVFF  23,840
5BE0:  MOVFF  22,83F
5BE4:  MOVFF  21,83E
5BE8:  MOVFF  20,83D
5BEC:  MOVLW  19
5BEE:  MOVLB  8
5BF0:  MOVWF  x41
5BF2:  MOVLB  0
5BF4:  CALL   3A68
5BF8:  BTFSC  19.7
5BFA:  BSF    FF2.7
5BFC:  CLRF   19
5BFE:  BTFSC  FF2.7
5C00:  BSF    19.7
5C02:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5C04:  MOVFF  27,840
5C08:  MOVFF  26,83F
5C0C:  MOVFF  25,83E
5C10:  MOVFF  24,83D
5C14:  MOVLW  1E
5C16:  MOVLB  8
5C18:  MOVWF  x41
5C1A:  MOVLB  0
5C1C:  CALL   3A68
5C20:  BTFSC  19.7
5C22:  BSF    FF2.7
5C24:  CLRF   19
5C26:  BTFSC  FF2.7
5C28:  BSF    19.7
5C2A:  BCF    FF2.7
....................    save_coutcard(0); 
5C2C:  MOVLB  8
5C2E:  CLRF   x2A
5C30:  CLRF   x29
5C32:  MOVLB  0
5C34:  CALL   507C
5C38:  BTFSC  19.7
5C3A:  BSF    FF2.7
.................... } 
5C3C:  GOTO   637C (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
554A:  MOVLB  7
554C:  CLRF   xF4
554E:  CLRF   xF3
5550:  CLRF   xF2
5552:  CLRF   xF1
5554:  CLRF   xF8
5556:  CLRF   xF7
5558:  CLRF   xF6
555A:  MOVLW  14
555C:  MOVWF  xF5
555E:  CLRF   xFA
5560:  MOVLW  55
5562:  MOVWF  xF9
5564:  MOVLB  0
5566:  RCALL  549A
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5568:  INCFSZ 55,W
556A:  BRA    55E8
556C:  INCFSZ 56,W
556E:  BRA    55E8
5570:  INCFSZ x64,W
5572:  BRA    55E8
....................       { 
....................          memset(buffer1,0,20); 
5574:  CLRF   FEA
5576:  MOVLW  2D
5578:  MOVWF  FE9
557A:  CLRF   00
557C:  CLRF   02
557E:  MOVLW  14
5580:  MOVWF  01
5582:  CALL   3A4E
....................          strcpy(buffer1,"admin"); 
5586:  CLRF   FEA
5588:  MOVLW  2D
558A:  MOVWF  FE9
558C:  MOVLW  00
558E:  CALL   00BA
5592:  TBLRD*-
5594:  TBLRD*+
5596:  MOVF   FF5,W
5598:  MOVWF  FEE
559A:  IORLW  00
559C:  BNZ   5594
559E:  CLRF   19
55A0:  BTFSC  FF2.7
55A2:  BSF    19.7
55A4:  BCF    FF2.7
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
55A6:  MOVLB  8
55A8:  CLRF   x40
55AA:  CLRF   x3F
55AC:  CLRF   x3E
55AE:  CLRF   x3D
55B0:  CLRF   x44
55B2:  CLRF   x43
55B4:  CLRF   x42
55B6:  MOVLW  14
55B8:  MOVWF  x41
55BA:  CLRF   x46
55BC:  MOVLW  2D
55BE:  MOVWF  x45
55C0:  MOVLB  0
55C2:  CALL   4DBE
55C6:  BTFSC  19.7
55C8:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
55CA:  MOVLB  7
55CC:  CLRF   xF4
55CE:  CLRF   xF3
55D0:  CLRF   xF2
55D2:  CLRF   xF1
55D4:  CLRF   xF8
55D6:  CLRF   xF7
55D8:  CLRF   xF6
55DA:  MOVLW  14
55DC:  MOVWF  xF5
55DE:  CLRF   xFA
55E0:  MOVLW  55
55E2:  MOVWF  xF9
55E4:  MOVLB  0
55E6:  RCALL  549A
....................       } 
.................... } 
55E8:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
5C40:  MOVLB  8
5C42:  CLRF   x05
5C44:  MOVF   x05,W
5C46:  SUBLW  13
5C48:  BNC   5C5E
5C4A:  CLRF   03
5C4C:  MOVF   x05,W
5C4E:  ADDLW  F1
5C50:  MOVWF  FE9
5C52:  MOVLW  07
5C54:  ADDWFC 03,W
5C56:  MOVWF  FEA
5C58:  SETF   FEF
5C5A:  INCF   x05,F
5C5C:  BRA    5C44
5C5E:  CLRF   19
5C60:  BTFSC  FF2.7
5C62:  BSF    19.7
5C64:  BCF    FF2.7
....................    EEPROM_write(strobe_pass_addr,20,buf); 
5C66:  CLRF   x40
5C68:  CLRF   x3F
5C6A:  CLRF   x3E
5C6C:  CLRF   x3D
5C6E:  CLRF   x44
5C70:  CLRF   x43
5C72:  CLRF   x42
5C74:  MOVLW  14
5C76:  MOVWF  x41
5C78:  MOVLW  07
5C7A:  MOVWF  x46
5C7C:  MOVLW  F1
5C7E:  MOVWF  x45
5C80:  MOVLB  0
5C82:  CALL   4DBE
5C86:  BTFSC  19.7
5C88:  BSF    FF2.7
.................... } 
5C8A:  GOTO   63E0 (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include <scan_key.c> 
....................  
.................... //#include <aes.c> 
.................... //#include <aes_enc.c> 
.................... #include <TI_aes_128.c> 
.................... /* --COPYRIGHT--,BSD  
....................  * Copyright (c) 2011, Texas Instruments Incorporated 
....................  * All rights reserved. 
....................  * 
....................  * Redistribution and use in source and binary forms, with or without 
....................  * modification, are permitted provided that the following conditions 
....................  * are met: 
....................  * 
....................  * *  Redistributions of source code must retain the above copyright 
....................  *    notice, this list of conditions and the following disclaimer. 
....................  * 
....................  * *  Redistributions in binary form must reproduce the above copyright 
....................  *    notice, this list of conditions and the following disclaimer in the 
....................  *    documentation and/or other materials provided with the distribution. 
....................  * 
....................  * *  Neither the name of Texas Instruments Incorporated nor the names of 
....................  *    its contributors may be used to endorse or promote products derived 
....................  *    from this software without specific prior written permission. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
....................  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
....................  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
....................  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
....................  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
....................  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
....................  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
....................  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
....................  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
....................  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
....................  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
....................  * --/COPYRIGHT--*/ 
.................... /* 
....................  * TI_aes_128.c 
....................  * 
....................  *  Created on: Nov 3, 2011 
....................  *      Author: Eric Peeters 
....................  * 
....................  *  Description: Implementation of the AES-128 as defined by the FIPS PUB 197:  
....................  *  the official AES standard 
....................  */ 
....................  
.................... #define CRYPTO_KEY_SIZE   32 
....................  
.................... int8 crypto_key[CRYPTO_KEY_SIZE+1];  
.................... int8 cryption_enable=0; 
....................  
.................... int8 test_key[16]={ 
.................... 0xE8, 0xE9, 0xEA, 0xEB, 0xED, 0xEE, 0xEF, 0xF0, 0xF2, 0xF3, 0xF4, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA 
.................... };  
.................... int8 test_data[16]={ 
.................... 0x67, 0x43, 0xC3, 0xD1, 0x51, 0x9A, 0xB4, 0xF2, 0xCD, 0x9A, 0x78, 0xAB, 0x09, 0xA5, 0x11, 0xBD 
.................... };  
.................... // foreward sbox 
.................... const unsigned int8 sbox[] =   { 
.................... //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F 
.................... 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, //0 
.................... 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, //1 
.................... 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, //2 
.................... 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, //3 
.................... 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, //4 
.................... 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, //5 
.................... 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, //6 
.................... 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, //7 
.................... 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, //8 
.................... 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, //9 
.................... 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, //A 
.................... 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, //B 
.................... 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, //C 
.................... 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, //D 
.................... 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, //E 
.................... 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }; //F 
....................  
.................... // inverse sbox 
.................... const unsigned int8 rsbox[] = 
.................... { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb 
.................... , 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb 
.................... , 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e 
.................... , 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 
.................... , 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 
.................... , 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 
.................... , 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 
.................... , 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b 
.................... , 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 
.................... , 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e 
.................... , 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b 
.................... , 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 
.................... , 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f 
.................... , 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef 
.................... , 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 
.................... , 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }; 
....................  
.................... // round constant 
.................... const unsigned int8 Rcon[] = { 
....................     0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36}; 
....................  
....................  
.................... // multiply by 2 in the galois field 
.................... unsigned int16 galois_mul2(unsigned int16 value) 
.................... { 
....................   signed int16 temp; 
....................   // cast to signed value 
....................   temp = (signed char) value; 
*
409C:  CLRF   03
409E:  MOVLB  8
40A0:  MOVF   x4A,W
40A2:  BTFSC  FE8.7
40A4:  DECF   03,F
40A6:  MOVWF  x4C
40A8:  MOVFF  03,84D
....................   // if MSB is 1, then this will signed extend and fill the temp variable with 1's 
....................   temp = temp >> 7; 
40AC:  RRCF   x4D,W
40AE:  MOVWF  03
40B0:  RRCF   x4C,W
40B2:  MOVWF  02
40B4:  RRCF   03,F
40B6:  RRCF   02,F
40B8:  RRCF   03,F
40BA:  RRCF   02,F
40BC:  RRCF   03,F
40BE:  RRCF   02,F
40C0:  RRCF   03,F
40C2:  RRCF   02,F
40C4:  RRCF   03,F
40C6:  RRCF   02,F
40C8:  RRCF   03,F
40CA:  RRCF   02,F
40CC:  MOVLW  01
40CE:  ANDWF  03,F
40D0:  MOVFF  02,84C
40D4:  MOVFF  03,84D
....................   // AND with the reduction variable 
....................   temp = temp & 0x1b; 
40D8:  MOVLW  1B
40DA:  ANDWF  x4C,F
40DC:  CLRF   x4D
....................   // finally shift and reduce the value 
....................   return ((value << 1)^temp); 
40DE:  BCF    FD8.0
40E0:  RLCF   x4A,W
40E2:  MOVWF  x4E
40E4:  RLCF   x4B,W
40E6:  MOVWF  x4F
40E8:  MOVF   x4E,W
40EA:  XORWF  x4C,W
40EC:  MOVWF  00
40EE:  MOVF   x4F,W
40F0:  XORWF  x4D,W
40F2:  MOVWF  03
40F4:  MOVFF  00,01
40F8:  MOVWF  02
.................... } 
40FA:  MOVLB  0
40FC:  RETURN 0
....................  
.................... // AES encryption and decryption function 
.................... // The code was optimized for memory (flash and ram) 
.................... // Combining both encryption and decryption resulted in a slower implementation 
.................... // but much smaller than the 2 functions separated 
.................... // This function only implements AES-128 encryption and decryption (AES-192 and  
.................... // AES-256 are not supported by this code)  
.................... void aes_enc_dec(unsigned int8 *state, unsigned int8 *key, unsigned int8 dir) 
.................... { 
....................     unsigned int8 buf1, buf2, buf3, buf4, round, i; 
....................  
....................   // In case of decryption 
....................   if (dir != 0)  
40FE:  MOVLB  8
4100:  MOVF   x41,F
4102:  BTFSC  FD8.2
4104:  BRA    42D0
....................   { 
....................     // compute the last key of encryption before starting the decryption 
....................     for (round = 0 ; round < 10; round++) { 
4106:  CLRF   x46
4108:  MOVF   x46,W
410A:  SUBLW  09
410C:  BTFSS  FD8.0
410E:  BRA    4286
....................       //key schedule 
....................       key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[round]); 
4110:  MOVFF  83F,01
4114:  MOVFF  840,03
4118:  MOVFF  83F,848
411C:  MOVFF  840,849
4120:  MOVLW  0D
4122:  ADDWF  x3F,W
4124:  MOVWF  FE9
4126:  MOVLW  00
4128:  ADDWFC x40,W
412A:  MOVWF  FEA
412C:  CLRF   03
412E:  MOVF   FEF,W
4130:  MOVLB  0
4132:  CALL   00D0
4136:  MOVLB  8
4138:  MOVWF  x4A
413A:  MOVFF  83F,FE9
413E:  MOVFF  840,FEA
4142:  MOVF   FEF,W
4144:  XORWF  x4A,F
4146:  CLRF   03
4148:  MOVF   x46,W
414A:  MOVLB  0
414C:  CALL   02F0
4150:  MOVWF  01
4152:  MOVLB  8
4154:  MOVF   x4A,W
4156:  XORWF  01,W
4158:  MOVFF  849,FEA
415C:  MOVFF  848,FE9
4160:  MOVWF  FEF
....................       key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4162:  MOVLW  01
4164:  ADDWF  x3F,W
4166:  MOVWF  01
4168:  MOVLW  00
416A:  ADDWFC x40,W
416C:  MOVWF  03
416E:  MOVFF  01,848
4172:  MOVWF  x49
4174:  MOVLW  0E
4176:  ADDWF  x3F,W
4178:  MOVWF  FE9
417A:  MOVLW  00
417C:  ADDWFC x40,W
417E:  MOVWF  FEA
4180:  CLRF   03
4182:  MOVF   FEF,W
4184:  MOVLB  0
4186:  CALL   00D0
418A:  MOVLB  8
418C:  MOVWF  x4A
418E:  MOVLW  01
4190:  ADDWF  x3F,W
4192:  MOVWF  FE9
4194:  MOVLW  00
4196:  ADDWFC x40,W
4198:  MOVWF  FEA
419A:  MOVF   FEF,W
419C:  XORWF  x4A,W
419E:  MOVFF  849,FEA
41A2:  MOVFF  848,FE9
41A6:  MOVWF  FEF
....................       key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
41A8:  MOVLW  02
41AA:  ADDWF  x3F,W
41AC:  MOVWF  01
41AE:  MOVLW  00
41B0:  ADDWFC x40,W
41B2:  MOVWF  03
41B4:  MOVFF  01,848
41B8:  MOVWF  x49
41BA:  MOVLW  0F
41BC:  ADDWF  x3F,W
41BE:  MOVWF  FE9
41C0:  MOVLW  00
41C2:  ADDWFC x40,W
41C4:  MOVWF  FEA
41C6:  CLRF   03
41C8:  MOVF   FEF,W
41CA:  MOVLB  0
41CC:  CALL   00D0
41D0:  MOVLB  8
41D2:  MOVWF  x4A
41D4:  MOVLW  02
41D6:  ADDWF  x3F,W
41D8:  MOVWF  FE9
41DA:  MOVLW  00
41DC:  ADDWFC x40,W
41DE:  MOVWF  FEA
41E0:  MOVF   FEF,W
41E2:  XORWF  x4A,W
41E4:  MOVFF  849,FEA
41E8:  MOVFF  848,FE9
41EC:  MOVWF  FEF
....................       key[3] = (unsigned int8)(sbox[key[12]]^key[3]); 
41EE:  MOVLW  03
41F0:  ADDWF  x3F,W
41F2:  MOVWF  01
41F4:  MOVLW  00
41F6:  ADDWFC x40,W
41F8:  MOVWF  03
41FA:  MOVFF  01,848
41FE:  MOVWF  x49
4200:  MOVLW  0C
4202:  ADDWF  x3F,W
4204:  MOVWF  FE9
4206:  MOVLW  00
4208:  ADDWFC x40,W
420A:  MOVWF  FEA
420C:  CLRF   03
420E:  MOVF   FEF,W
4210:  MOVLB  0
4212:  CALL   00D0
4216:  MOVLB  8
4218:  MOVWF  x4A
421A:  MOVLW  03
421C:  ADDWF  x3F,W
421E:  MOVWF  FE9
4220:  MOVLW  00
4222:  ADDWFC x40,W
4224:  MOVWF  FEA
4226:  MOVF   FEF,W
4228:  XORWF  x4A,W
422A:  MOVFF  849,FEA
422E:  MOVFF  848,FE9
4232:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4234:  MOVLW  04
4236:  MOVWF  x47
4238:  MOVF   x47,W
423A:  SUBLW  0F
423C:  BNC   4282
....................         key[i] = key[i] ^ key[i-4]; 
423E:  CLRF   03
4240:  MOVF   x47,W
4242:  ADDWF  x3F,W
4244:  MOVWF  01
4246:  MOVF   x40,W
4248:  ADDWFC 03,F
424A:  MOVFF  03,849
424E:  CLRF   03
4250:  MOVF   x47,W
4252:  ADDWF  x3F,W
4254:  MOVWF  FE9
4256:  MOVF   x40,W
4258:  ADDWFC 03,W
425A:  MOVWF  FEA
425C:  MOVFF  FEF,84A
4260:  MOVLW  04
4262:  SUBWF  x47,W
4264:  CLRF   03
4266:  ADDWF  x3F,W
4268:  MOVWF  FE9
426A:  MOVF   x40,W
426C:  ADDWFC 03,W
426E:  MOVWF  FEA
4270:  MOVF   FEF,W
4272:  XORWF  x4A,W
4274:  MOVFF  849,FEA
4278:  MOVFF  01,FE9
427C:  MOVWF  FEF
....................       } 
427E:  INCF   x47,F
4280:  BRA    4238
....................     } 
4282:  INCF   x46,F
4284:  BRA    4108
....................     //first Addroundkey 
....................     for (i = 0; i <16; i++) 
4286:  CLRF   x47
4288:  MOVF   x47,W
428A:  SUBLW  0F
428C:  BNC   42D0
....................     { 
....................       state[i]=state[i] ^ key[i]; 
428E:  CLRF   03
4290:  MOVF   x47,W
4292:  ADDWF  x3D,W
4294:  MOVWF  01
4296:  MOVF   x3E,W
4298:  ADDWFC 03,F
429A:  MOVFF  03,849
429E:  CLRF   03
42A0:  MOVF   x47,W
42A2:  ADDWF  x3D,W
42A4:  MOVWF  FE9
42A6:  MOVF   x3E,W
42A8:  ADDWFC 03,W
42AA:  MOVWF  FEA
42AC:  MOVFF  FEF,84A
42B0:  CLRF   03
42B2:  MOVF   x47,W
42B4:  ADDWF  x3F,W
42B6:  MOVWF  FE9
42B8:  MOVF   x40,W
42BA:  ADDWFC 03,W
42BC:  MOVWF  FEA
42BE:  MOVF   FEF,W
42C0:  XORWF  x4A,W
42C2:  MOVFF  849,FEA
42C6:  MOVFF  01,FE9
42CA:  MOVWF  FEF
....................     } 
42CC:  INCF   x47,F
42CE:  BRA    4288
....................   } 
....................   // main loop 
....................   for (round = 0; round < 10; round++) 
42D0:  CLRF   x46
42D2:  MOVF   x46,W
42D4:  SUBLW  09
42D6:  BTFSS  FD8.0
42D8:  GOTO   4D20
....................   { 
....................     if (dir != 0) 
42DC:  MOVF   x41,F
42DE:  BTFSC  FD8.2
42E0:  BRA    445A
....................     { 
....................           //Inverse key schedule 
....................           for (i=15; i>3; --i)  
42E2:  MOVLW  0F
42E4:  MOVWF  x47
42E6:  MOVF   x47,W
42E8:  SUBLW  03
42EA:  BC    4330
....................           { 
....................             key[i] = key[i] ^ key[i-4]; 
42EC:  CLRF   03
42EE:  MOVF   x47,W
42F0:  ADDWF  x3F,W
42F2:  MOVWF  01
42F4:  MOVF   x40,W
42F6:  ADDWFC 03,F
42F8:  MOVFF  03,849
42FC:  CLRF   03
42FE:  MOVF   x47,W
4300:  ADDWF  x3F,W
4302:  MOVWF  FE9
4304:  MOVF   x40,W
4306:  ADDWFC 03,W
4308:  MOVWF  FEA
430A:  MOVFF  FEF,84A
430E:  MOVLW  04
4310:  SUBWF  x47,W
4312:  CLRF   03
4314:  ADDWF  x3F,W
4316:  MOVWF  FE9
4318:  MOVF   x40,W
431A:  ADDWFC 03,W
431C:  MOVWF  FEA
431E:  MOVF   FEF,W
4320:  XORWF  x4A,W
4322:  MOVFF  849,FEA
4326:  MOVFF  01,FE9
432A:  MOVWF  FEF
....................           }   
432C:  DECF   x47,F
432E:  BRA    42E6
....................           key[0] = (unsigned int8)(sbox[key[13]]^key[0]^Rcon[9-round]); 
4330:  MOVFF  83F,01
4334:  MOVFF  840,03
4338:  MOVFF  83F,848
433C:  MOVFF  840,849
4340:  MOVLW  0D
4342:  ADDWF  x3F,W
4344:  MOVWF  FE9
4346:  MOVLW  00
4348:  ADDWFC x40,W
434A:  MOVWF  FEA
434C:  CLRF   03
434E:  MOVF   FEF,W
4350:  MOVLB  0
4352:  CALL   00D0
4356:  MOVLB  8
4358:  MOVWF  x4A
435A:  MOVFF  83F,FE9
435E:  MOVFF  840,FEA
4362:  MOVF   FEF,W
4364:  XORWF  x4A,F
4366:  MOVLW  09
4368:  BSF    FD8.0
436A:  SUBFWB x46,W
436C:  CLRF   03
436E:  MOVLB  0
4370:  CALL   02F0
4374:  MOVWF  01
4376:  MOVLB  8
4378:  MOVF   x4A,W
437A:  XORWF  01,W
437C:  MOVFF  849,FEA
4380:  MOVFF  848,FE9
4384:  MOVWF  FEF
....................           key[1] = (unsigned int8)(sbox[key[14]]^key[1]); 
4386:  MOVLW  01
4388:  ADDWF  x3F,W
438A:  MOVWF  01
438C:  MOVLW  00
438E:  ADDWFC x40,W
4390:  MOVWF  03
4392:  MOVFF  01,848
4396:  MOVWF  x49
4398:  MOVLW  0E
439A:  ADDWF  x3F,W
439C:  MOVWF  FE9
439E:  MOVLW  00
43A0:  ADDWFC x40,W
43A2:  MOVWF  FEA
43A4:  CLRF   03
43A6:  MOVF   FEF,W
43A8:  MOVLB  0
43AA:  CALL   00D0
43AE:  MOVLB  8
43B0:  MOVWF  x4A
43B2:  MOVLW  01
43B4:  ADDWF  x3F,W
43B6:  MOVWF  FE9
43B8:  MOVLW  00
43BA:  ADDWFC x40,W
43BC:  MOVWF  FEA
43BE:  MOVF   FEF,W
43C0:  XORWF  x4A,W
43C2:  MOVFF  849,FEA
43C6:  MOVFF  848,FE9
43CA:  MOVWF  FEF
....................           key[2] = (unsigned int8)(sbox[key[15]]^key[2]); 
43CC:  MOVLW  02
43CE:  ADDWF  x3F,W
43D0:  MOVWF  01
43D2:  MOVLW  00
43D4:  ADDWFC x40,W
43D6:  MOVWF  03
43D8:  MOVFF  01,848
43DC:  MOVWF  x49
43DE:  MOVLW  0F
43E0:  ADDWF  x3F,W
43E2:  MOVWF  FE9
43E4:  MOVLW  00
43E6:  ADDWFC x40,W
43E8:  MOVWF  FEA
43EA:  CLRF   03
43EC:  MOVF   FEF,W
43EE:  MOVLB  0
43F0:  CALL   00D0
43F4:  MOVLB  8
43F6:  MOVWF  x4A
43F8:  MOVLW  02
43FA:  ADDWF  x3F,W
43FC:  MOVWF  FE9
43FE:  MOVLW  00
4400:  ADDWFC x40,W
4402:  MOVWF  FEA
4404:  MOVF   FEF,W
4406:  XORWF  x4A,W
4408:  MOVFF  849,FEA
440C:  MOVFF  848,FE9
4410:  MOVWF  FEF
....................           key[3] = (unsigned int8)(sbox[key[12]]^key[3]);  
4412:  MOVLW  03
4414:  ADDWF  x3F,W
4416:  MOVWF  01
4418:  MOVLW  00
441A:  ADDWFC x40,W
441C:  MOVWF  03
441E:  MOVFF  01,848
4422:  MOVWF  x49
4424:  MOVLW  0C
4426:  ADDWF  x3F,W
4428:  MOVWF  FE9
442A:  MOVLW  00
442C:  ADDWFC x40,W
442E:  MOVWF  FEA
4430:  CLRF   03
4432:  MOVF   FEF,W
4434:  MOVLB  0
4436:  CALL   00D0
443A:  MOVLB  8
443C:  MOVWF  x4A
443E:  MOVLW  03
4440:  ADDWF  x3F,W
4442:  MOVWF  FE9
4444:  MOVLW  00
4446:  ADDWFC x40,W
4448:  MOVWF  FEA
444A:  MOVF   FEF,W
444C:  XORWF  x4A,W
444E:  MOVFF  849,FEA
4452:  MOVFF  848,FE9
4456:  MOVWF  FEF
....................     }  
....................     else  
4458:  BRA    4672
....................     { 
....................         for (i = 0; i <16; i++) 
445A:  CLRF   x47
445C:  MOVF   x47,W
445E:  SUBLW  0F
4460:  BNC   44B2
....................         { 
....................             // with shiftrow i+5 mod 16 
....................             state[i]=sbox[state[i] ^ key[i]]; 
4462:  CLRF   03
4464:  MOVF   x47,W
4466:  ADDWF  x3D,W
4468:  MOVWF  01
446A:  MOVF   x3E,W
446C:  ADDWFC 03,F
446E:  MOVFF  01,848
4472:  MOVFF  03,849
4476:  CLRF   03
4478:  MOVF   x47,W
447A:  ADDWF  x3D,W
447C:  MOVWF  FE9
447E:  MOVF   x3E,W
4480:  ADDWFC 03,W
4482:  MOVWF  FEA
4484:  MOVFF  FEF,84A
4488:  CLRF   03
448A:  MOVF   x47,W
448C:  ADDWF  x3F,W
448E:  MOVWF  FE9
4490:  MOVF   x40,W
4492:  ADDWFC 03,W
4494:  MOVWF  FEA
4496:  MOVF   FEF,W
4498:  XORWF  x4A,W
449A:  CLRF   03
449C:  MOVLB  0
449E:  CALL   00D0
44A2:  MOVFF  849,FEA
44A6:  MOVFF  848,FE9
44AA:  MOVWF  FEF
....................         } 
44AC:  MOVLB  8
44AE:  INCF   x47,F
44B0:  BRA    445C
....................         //shift rows 
....................         buf1 = state[1]; 
44B2:  MOVLW  01
44B4:  ADDWF  x3D,W
44B6:  MOVWF  FE9
44B8:  MOVLW  00
44BA:  ADDWFC x3E,W
44BC:  MOVWF  FEA
44BE:  MOVFF  FEF,842
....................         state[1] = state[5]; 
44C2:  MOVLW  01
44C4:  ADDWF  x3D,W
44C6:  MOVWF  01
44C8:  MOVLW  00
44CA:  ADDWFC x3E,W
44CC:  MOVWF  03
44CE:  MOVLW  05
44D0:  ADDWF  x3D,W
44D2:  MOVWF  FE9
44D4:  MOVLW  00
44D6:  ADDWFC x3E,W
44D8:  MOVWF  FEA
44DA:  MOVFF  FEF,84A
44DE:  MOVFF  03,FEA
44E2:  MOVFF  01,FE9
44E6:  MOVFF  84A,FEF
....................         state[5] = state[9]; 
44EA:  MOVLW  05
44EC:  ADDWF  x3D,W
44EE:  MOVWF  01
44F0:  MOVLW  00
44F2:  ADDWFC x3E,W
44F4:  MOVWF  03
44F6:  MOVLW  09
44F8:  ADDWF  x3D,W
44FA:  MOVWF  FE9
44FC:  MOVLW  00
44FE:  ADDWFC x3E,W
4500:  MOVWF  FEA
4502:  MOVFF  FEF,84A
4506:  MOVFF  03,FEA
450A:  MOVFF  01,FE9
450E:  MOVFF  84A,FEF
....................         state[9] = state[13]; 
4512:  MOVLW  09
4514:  ADDWF  x3D,W
4516:  MOVWF  01
4518:  MOVLW  00
451A:  ADDWFC x3E,W
451C:  MOVWF  03
451E:  MOVLW  0D
4520:  ADDWF  x3D,W
4522:  MOVWF  FE9
4524:  MOVLW  00
4526:  ADDWFC x3E,W
4528:  MOVWF  FEA
452A:  MOVFF  FEF,84A
452E:  MOVFF  03,FEA
4532:  MOVFF  01,FE9
4536:  MOVFF  84A,FEF
....................         state[13] = buf1; 
453A:  MOVLW  0D
453C:  ADDWF  x3D,W
453E:  MOVWF  FE9
4540:  MOVLW  00
4542:  ADDWFC x3E,W
4544:  MOVWF  FEA
4546:  MOVFF  842,FEF
....................      
....................         buf1 = state[2]; 
454A:  MOVLW  02
454C:  ADDWF  x3D,W
454E:  MOVWF  FE9
4550:  MOVLW  00
4552:  ADDWFC x3E,W
4554:  MOVWF  FEA
4556:  MOVFF  FEF,842
....................         buf2 = state[6]; 
455A:  MOVLW  06
455C:  ADDWF  x3D,W
455E:  MOVWF  FE9
4560:  MOVLW  00
4562:  ADDWFC x3E,W
4564:  MOVWF  FEA
4566:  MOVFF  FEF,843
....................         state[2] = state[10]; 
456A:  MOVLW  02
456C:  ADDWF  x3D,W
456E:  MOVWF  01
4570:  MOVLW  00
4572:  ADDWFC x3E,W
4574:  MOVWF  03
4576:  MOVLW  0A
4578:  ADDWF  x3D,W
457A:  MOVWF  FE9
457C:  MOVLW  00
457E:  ADDWFC x3E,W
4580:  MOVWF  FEA
4582:  MOVFF  FEF,84A
4586:  MOVFF  03,FEA
458A:  MOVFF  01,FE9
458E:  MOVFF  84A,FEF
....................         state[6] = state[14]; 
4592:  MOVLW  06
4594:  ADDWF  x3D,W
4596:  MOVWF  01
4598:  MOVLW  00
459A:  ADDWFC x3E,W
459C:  MOVWF  03
459E:  MOVLW  0E
45A0:  ADDWF  x3D,W
45A2:  MOVWF  FE9
45A4:  MOVLW  00
45A6:  ADDWFC x3E,W
45A8:  MOVWF  FEA
45AA:  MOVFF  FEF,84A
45AE:  MOVFF  03,FEA
45B2:  MOVFF  01,FE9
45B6:  MOVFF  84A,FEF
....................         state[10] = buf1; 
45BA:  MOVLW  0A
45BC:  ADDWF  x3D,W
45BE:  MOVWF  FE9
45C0:  MOVLW  00
45C2:  ADDWFC x3E,W
45C4:  MOVWF  FEA
45C6:  MOVFF  842,FEF
....................         state[14] = buf2; 
45CA:  MOVLW  0E
45CC:  ADDWF  x3D,W
45CE:  MOVWF  FE9
45D0:  MOVLW  00
45D2:  ADDWFC x3E,W
45D4:  MOVWF  FEA
45D6:  MOVFF  843,FEF
....................      
....................         buf1 = state[15]; 
45DA:  MOVLW  0F
45DC:  ADDWF  x3D,W
45DE:  MOVWF  FE9
45E0:  MOVLW  00
45E2:  ADDWFC x3E,W
45E4:  MOVWF  FEA
45E6:  MOVFF  FEF,842
....................         state[15] = state[11]; 
45EA:  MOVLW  0F
45EC:  ADDWF  x3D,W
45EE:  MOVWF  01
45F0:  MOVLW  00
45F2:  ADDWFC x3E,W
45F4:  MOVWF  03
45F6:  MOVLW  0B
45F8:  ADDWF  x3D,W
45FA:  MOVWF  FE9
45FC:  MOVLW  00
45FE:  ADDWFC x3E,W
4600:  MOVWF  FEA
4602:  MOVFF  FEF,84A
4606:  MOVFF  03,FEA
460A:  MOVFF  01,FE9
460E:  MOVFF  84A,FEF
....................         state[11] = state[7]; 
4612:  MOVLW  0B
4614:  ADDWF  x3D,W
4616:  MOVWF  01
4618:  MOVLW  00
461A:  ADDWFC x3E,W
461C:  MOVWF  03
461E:  MOVLW  07
4620:  ADDWF  x3D,W
4622:  MOVWF  FE9
4624:  MOVLW  00
4626:  ADDWFC x3E,W
4628:  MOVWF  FEA
462A:  MOVFF  FEF,84A
462E:  MOVFF  03,FEA
4632:  MOVFF  01,FE9
4636:  MOVFF  84A,FEF
....................         state[7] = state[3]; 
463A:  MOVLW  07
463C:  ADDWF  x3D,W
463E:  MOVWF  01
4640:  MOVLW  00
4642:  ADDWFC x3E,W
4644:  MOVWF  03
4646:  MOVLW  03
4648:  ADDWF  x3D,W
464A:  MOVWF  FE9
464C:  MOVLW  00
464E:  ADDWFC x3E,W
4650:  MOVWF  FEA
4652:  MOVFF  FEF,84A
4656:  MOVFF  03,FEA
465A:  MOVFF  01,FE9
465E:  MOVFF  84A,FEF
....................         state[3] = buf1; 
4662:  MOVLW  03
4664:  ADDWF  x3D,W
4666:  MOVWF  FE9
4668:  MOVLW  00
466A:  ADDWFC x3E,W
466C:  MOVWF  FEA
466E:  MOVFF  842,FEF
....................     } 
....................      
....................     //mixcol - inv mix 
....................     if (((round > 0) && (dir != 0)) || ((round < 9) && (dir == 0)))  
4672:  MOVF   x46,F
4674:  BZ    467A
4676:  MOVF   x41,F
4678:  BNZ   4688
467A:  MOVF   x46,W
467C:  SUBLW  08
467E:  BTFSS  FD8.0
4680:  BRA    4988
4682:  MOVF   x41,F
4684:  BTFSS  FD8.2
4686:  BRA    4988
....................     { 
....................           for (i=0; i <4; i++) 
4688:  CLRF   x47
468A:  MOVF   x47,W
468C:  SUBLW  03
468E:  BTFSS  FD8.0
4690:  BRA    4988
....................           { 
....................                 buf4 = (unsigned int8)(i << 2); 
4692:  RLCF   x47,W
4694:  MOVWF  x45
4696:  RLCF   x45,F
4698:  MOVLW  FC
469A:  ANDWF  x45,F
....................                 if (dir != 0) 
469C:  MOVF   x41,F
469E:  BZ    4788
....................                 { 
....................                       // precompute for decryption 
....................                       buf1 = galois_mul2(galois_mul2((unsigned int8)(state[buf4]^state[buf4+2]))); 
46A0:  CLRF   03
46A2:  MOVF   x45,W
46A4:  ADDWF  x3D,W
46A6:  MOVWF  FE9
46A8:  MOVF   x3E,W
46AA:  ADDWFC 03,W
46AC:  MOVWF  FEA
46AE:  MOVFF  FEF,848
46B2:  MOVLW  02
46B4:  ADDWF  x45,W
46B6:  CLRF   03
46B8:  ADDWF  x3D,W
46BA:  MOVWF  FE9
46BC:  MOVF   x3E,W
46BE:  ADDWFC 03,W
46C0:  MOVWF  FEA
46C2:  MOVF   FEF,W
46C4:  XORWF  x48,F
46C6:  CLRF   x4B
46C8:  MOVFF  848,84A
46CC:  MOVLB  0
46CE:  RCALL  409C
46D0:  MOVFF  02,849
46D4:  MOVFF  01,848
46D8:  MOVFF  02,84B
46DC:  MOVFF  01,84A
46E0:  RCALL  409C
46E2:  MOVFF  01,842
....................                       buf2 = galois_mul2(galois_mul2((unsigned int8)(state[buf4+1]^state[buf4+3]))); 
46E6:  MOVLW  01
46E8:  MOVLB  8
46EA:  ADDWF  x45,W
46EC:  CLRF   03
46EE:  ADDWF  x3D,W
46F0:  MOVWF  FE9
46F2:  MOVF   x3E,W
46F4:  ADDWFC 03,W
46F6:  MOVWF  FEA
46F8:  MOVFF  FEF,848
46FC:  MOVLW  03
46FE:  ADDWF  x45,W
4700:  CLRF   03
4702:  ADDWF  x3D,W
4704:  MOVWF  FE9
4706:  MOVF   x3E,W
4708:  ADDWFC 03,W
470A:  MOVWF  FEA
470C:  MOVF   FEF,W
470E:  XORWF  x48,F
4710:  CLRF   x4B
4712:  MOVFF  848,84A
4716:  MOVLB  0
4718:  RCALL  409C
471A:  MOVFF  02,849
471E:  MOVFF  01,848
4722:  MOVFF  02,84B
4726:  MOVFF  01,84A
472A:  RCALL  409C
472C:  MOVFF  01,843
....................                       state[buf4] ^= buf1;  
4730:  CLRF   03
4732:  MOVLB  8
4734:  MOVF   x45,W
4736:  ADDWF  x3D,W
4738:  MOVWF  FE9
473A:  MOVF   x3E,W
473C:  ADDWFC 03,W
473E:  MOVWF  FEA
4740:  MOVF   FEF,W
4742:  XORWF  x42,W
4744:  MOVWF  FEF
....................                       state[buf4+1] ^= buf2;  
4746:  MOVLW  01
4748:  ADDWF  x45,W
474A:  CLRF   03
474C:  ADDWF  x3D,W
474E:  MOVWF  FE9
4750:  MOVF   x3E,W
4752:  ADDWFC 03,W
4754:  MOVWF  FEA
4756:  MOVF   FEF,W
4758:  XORWF  x43,W
475A:  MOVWF  FEF
....................                       state[buf4+2] ^= buf1;  
475C:  MOVLW  02
475E:  ADDWF  x45,W
4760:  CLRF   03
4762:  ADDWF  x3D,W
4764:  MOVWF  FE9
4766:  MOVF   x3E,W
4768:  ADDWFC 03,W
476A:  MOVWF  FEA
476C:  MOVF   FEF,W
476E:  XORWF  x42,W
4770:  MOVWF  FEF
....................                       state[buf4+3] ^= buf2;  
4772:  MOVLW  03
4774:  ADDWF  x45,W
4776:  CLRF   03
4778:  ADDWF  x3D,W
477A:  MOVWF  FE9
477C:  MOVF   x3E,W
477E:  ADDWFC 03,W
4780:  MOVWF  FEA
4782:  MOVF   FEF,W
4784:  XORWF  x43,W
4786:  MOVWF  FEF
....................                 } 
....................                 // in all cases 
....................                 buf1 = state[buf4] ^ state[buf4+1] ^ state[buf4+2] ^ state[buf4+3]; 
4788:  CLRF   03
478A:  MOVF   x45,W
478C:  ADDWF  x3D,W
478E:  MOVWF  FE9
4790:  MOVF   x3E,W
4792:  ADDWFC 03,W
4794:  MOVWF  FEA
4796:  MOVFF  FEF,848
479A:  MOVLW  01
479C:  ADDWF  x45,W
479E:  CLRF   03
47A0:  ADDWF  x3D,W
47A2:  MOVWF  FE9
47A4:  MOVF   x3E,W
47A6:  ADDWFC 03,W
47A8:  MOVWF  FEA
47AA:  MOVF   FEF,W
47AC:  XORWF  x48,F
47AE:  MOVLW  02
47B0:  ADDWF  x45,W
47B2:  CLRF   03
47B4:  ADDWF  x3D,W
47B6:  MOVWF  FE9
47B8:  MOVF   x3E,W
47BA:  ADDWFC 03,W
47BC:  MOVWF  FEA
47BE:  MOVF   FEF,W
47C0:  XORWF  x48,F
47C2:  MOVLW  03
47C4:  ADDWF  x45,W
47C6:  CLRF   03
47C8:  ADDWF  x3D,W
47CA:  MOVWF  FE9
47CC:  MOVF   x3E,W
47CE:  ADDWFC 03,W
47D0:  MOVWF  FEA
47D2:  MOVF   FEF,W
47D4:  XORWF  x48,W
47D6:  MOVWF  x42
....................                 buf2 = state[buf4]; 
47D8:  CLRF   03
47DA:  MOVF   x45,W
47DC:  ADDWF  x3D,W
47DE:  MOVWF  FE9
47E0:  MOVF   x3E,W
47E2:  ADDWFC 03,W
47E4:  MOVWF  FEA
47E6:  MOVFF  FEF,843
....................                 buf3 = state[buf4]^state[buf4+1];  
47EA:  CLRF   03
47EC:  MOVF   x45,W
47EE:  ADDWF  x3D,W
47F0:  MOVWF  FE9
47F2:  MOVF   x3E,W
47F4:  ADDWFC 03,W
47F6:  MOVWF  FEA
47F8:  MOVFF  FEF,848
47FC:  MOVLW  01
47FE:  ADDWF  x45,W
4800:  CLRF   03
4802:  ADDWF  x3D,W
4804:  MOVWF  FE9
4806:  MOVF   x3E,W
4808:  ADDWFC 03,W
480A:  MOVWF  FEA
480C:  MOVF   FEF,W
480E:  XORWF  x48,W
4810:  MOVWF  x44
....................                 buf3=galois_mul2(buf3);  
4812:  CLRF   x4B
4814:  MOVFF  844,84A
4818:  MOVLB  0
481A:  RCALL  409C
481C:  MOVFF  01,844
....................                 state[buf4] = state[buf4] ^ buf3 ^ buf1; 
4820:  CLRF   03
4822:  MOVLB  8
4824:  MOVF   x45,W
4826:  ADDWF  x3D,W
4828:  MOVWF  01
482A:  MOVF   x3E,W
482C:  ADDWFC 03,F
482E:  MOVFF  03,849
4832:  CLRF   03
4834:  MOVF   x45,W
4836:  ADDWF  x3D,W
4838:  MOVWF  FE9
483A:  MOVF   x3E,W
483C:  ADDWFC 03,W
483E:  MOVWF  FEA
4840:  MOVF   FEF,W
4842:  XORWF  x44,W
4844:  XORWF  x42,W
4846:  MOVFF  849,FEA
484A:  MOVFF  01,FE9
484E:  MOVWF  FEF
....................                 buf3 = state[buf4+1]^state[buf4+2];  
4850:  MOVLW  01
4852:  ADDWF  x45,W
4854:  CLRF   03
4856:  ADDWF  x3D,W
4858:  MOVWF  FE9
485A:  MOVF   x3E,W
485C:  ADDWFC 03,W
485E:  MOVWF  FEA
4860:  MOVFF  FEF,848
4864:  MOVLW  02
4866:  ADDWF  x45,W
4868:  CLRF   03
486A:  ADDWF  x3D,W
486C:  MOVWF  FE9
486E:  MOVF   x3E,W
4870:  ADDWFC 03,W
4872:  MOVWF  FEA
4874:  MOVF   FEF,W
4876:  XORWF  x48,W
4878:  MOVWF  x44
....................                 buf3=galois_mul2(buf3);  
487A:  CLRF   x4B
487C:  MOVFF  844,84A
4880:  MOVLB  0
4882:  RCALL  409C
4884:  MOVFF  01,844
....................                 state[buf4+1] = state[buf4+1] ^ buf3 ^ buf1; 
4888:  MOVLW  01
488A:  MOVLB  8
488C:  ADDWF  x45,W
488E:  CLRF   03
4890:  ADDWF  x3D,W
4892:  MOVWF  01
4894:  MOVF   x3E,W
4896:  ADDWFC 03,F
4898:  MOVFF  03,849
489C:  MOVLW  01
489E:  ADDWF  x45,W
48A0:  CLRF   03
48A2:  ADDWF  x3D,W
48A4:  MOVWF  FE9
48A6:  MOVF   x3E,W
48A8:  ADDWFC 03,W
48AA:  MOVWF  FEA
48AC:  MOVF   FEF,W
48AE:  XORWF  x44,W
48B0:  XORWF  x42,W
48B2:  MOVFF  849,FEA
48B6:  MOVFF  01,FE9
48BA:  MOVWF  FEF
....................                 buf3 = state[buf4+2]^state[buf4+3];  
48BC:  MOVLW  02
48BE:  ADDWF  x45,W
48C0:  CLRF   03
48C2:  ADDWF  x3D,W
48C4:  MOVWF  FE9
48C6:  MOVF   x3E,W
48C8:  ADDWFC 03,W
48CA:  MOVWF  FEA
48CC:  MOVFF  FEF,848
48D0:  MOVLW  03
48D2:  ADDWF  x45,W
48D4:  CLRF   03
48D6:  ADDWF  x3D,W
48D8:  MOVWF  FE9
48DA:  MOVF   x3E,W
48DC:  ADDWFC 03,W
48DE:  MOVWF  FEA
48E0:  MOVF   FEF,W
48E2:  XORWF  x48,W
48E4:  MOVWF  x44
....................                 buf3=galois_mul2(buf3);  
48E6:  CLRF   x4B
48E8:  MOVFF  844,84A
48EC:  MOVLB  0
48EE:  CALL   409C
48F2:  MOVFF  01,844
....................                 state[buf4+2] = state[buf4+2] ^ buf3 ^ buf1; 
48F6:  MOVLW  02
48F8:  MOVLB  8
48FA:  ADDWF  x45,W
48FC:  CLRF   03
48FE:  ADDWF  x3D,W
4900:  MOVWF  01
4902:  MOVF   x3E,W
4904:  ADDWFC 03,F
4906:  MOVFF  03,849
490A:  MOVLW  02
490C:  ADDWF  x45,W
490E:  CLRF   03
4910:  ADDWF  x3D,W
4912:  MOVWF  FE9
4914:  MOVF   x3E,W
4916:  ADDWFC 03,W
4918:  MOVWF  FEA
491A:  MOVF   FEF,W
491C:  XORWF  x44,W
491E:  XORWF  x42,W
4920:  MOVFF  849,FEA
4924:  MOVFF  01,FE9
4928:  MOVWF  FEF
....................                 buf3 = state[buf4+3]^buf2;      
492A:  MOVLW  03
492C:  ADDWF  x45,W
492E:  CLRF   03
4930:  ADDWF  x3D,W
4932:  MOVWF  FE9
4934:  MOVF   x3E,W
4936:  ADDWFC 03,W
4938:  MOVWF  FEA
493A:  MOVF   FEF,W
493C:  XORWF  x43,W
493E:  MOVWF  x44
....................                 buf3=galois_mul2(buf3);  
4940:  CLRF   x4B
4942:  MOVFF  844,84A
4946:  MOVLB  0
4948:  CALL   409C
494C:  MOVFF  01,844
....................                 state[buf4+3] = state[buf4+3] ^ buf3 ^ buf1;  
4950:  MOVLW  03
4952:  MOVLB  8
4954:  ADDWF  x45,W
4956:  CLRF   03
4958:  ADDWF  x3D,W
495A:  MOVWF  01
495C:  MOVF   x3E,W
495E:  ADDWFC 03,F
4960:  MOVFF  03,849
4964:  MOVLW  03
4966:  ADDWF  x45,W
4968:  CLRF   03
496A:  ADDWF  x3D,W
496C:  MOVWF  FE9
496E:  MOVF   x3E,W
4970:  ADDWFC 03,W
4972:  MOVWF  FEA
4974:  MOVF   FEF,W
4976:  XORWF  x44,W
4978:  XORWF  x42,W
497A:  MOVFF  849,FEA
497E:  MOVFF  01,FE9
4982:  MOVWF  FEF
....................           } 
4984:  INCF   x47,F
4986:  BRA    468A
....................     } 
....................      
....................     if (dir != 0)  
4988:  MOVF   x41,F
498A:  BTFSC  FD8.2
498C:  BRA    4BA8
....................     { 
....................       //Inv shift rows 
....................       // Row 1 
....................       buf1 = state[13]; 
498E:  MOVLW  0D
4990:  ADDWF  x3D,W
4992:  MOVWF  FE9
4994:  MOVLW  00
4996:  ADDWFC x3E,W
4998:  MOVWF  FEA
499A:  MOVFF  FEF,842
....................       state[13] = state[9]; 
499E:  MOVLW  0D
49A0:  ADDWF  x3D,W
49A2:  MOVWF  01
49A4:  MOVLW  00
49A6:  ADDWFC x3E,W
49A8:  MOVWF  03
49AA:  MOVLW  09
49AC:  ADDWF  x3D,W
49AE:  MOVWF  FE9
49B0:  MOVLW  00
49B2:  ADDWFC x3E,W
49B4:  MOVWF  FEA
49B6:  MOVFF  FEF,84A
49BA:  MOVFF  03,FEA
49BE:  MOVFF  01,FE9
49C2:  MOVFF  84A,FEF
....................       state[9] = state[5]; 
49C6:  MOVLW  09
49C8:  ADDWF  x3D,W
49CA:  MOVWF  01
49CC:  MOVLW  00
49CE:  ADDWFC x3E,W
49D0:  MOVWF  03
49D2:  MOVLW  05
49D4:  ADDWF  x3D,W
49D6:  MOVWF  FE9
49D8:  MOVLW  00
49DA:  ADDWFC x3E,W
49DC:  MOVWF  FEA
49DE:  MOVFF  FEF,84A
49E2:  MOVFF  03,FEA
49E6:  MOVFF  01,FE9
49EA:  MOVFF  84A,FEF
....................       state[5] = state[1]; 
49EE:  MOVLW  05
49F0:  ADDWF  x3D,W
49F2:  MOVWF  01
49F4:  MOVLW  00
49F6:  ADDWFC x3E,W
49F8:  MOVWF  03
49FA:  MOVLW  01
49FC:  ADDWF  x3D,W
49FE:  MOVWF  FE9
4A00:  MOVLW  00
4A02:  ADDWFC x3E,W
4A04:  MOVWF  FEA
4A06:  MOVFF  FEF,84A
4A0A:  MOVFF  03,FEA
4A0E:  MOVFF  01,FE9
4A12:  MOVFF  84A,FEF
....................       state[1] = buf1; 
4A16:  MOVLW  01
4A18:  ADDWF  x3D,W
4A1A:  MOVWF  FE9
4A1C:  MOVLW  00
4A1E:  ADDWFC x3E,W
4A20:  MOVWF  FEA
4A22:  MOVFF  842,FEF
....................       //Row 2 
....................       buf1 = state[10]; 
4A26:  MOVLW  0A
4A28:  ADDWF  x3D,W
4A2A:  MOVWF  FE9
4A2C:  MOVLW  00
4A2E:  ADDWFC x3E,W
4A30:  MOVWF  FEA
4A32:  MOVFF  FEF,842
....................       buf2 = state[14]; 
4A36:  MOVLW  0E
4A38:  ADDWF  x3D,W
4A3A:  MOVWF  FE9
4A3C:  MOVLW  00
4A3E:  ADDWFC x3E,W
4A40:  MOVWF  FEA
4A42:  MOVFF  FEF,843
....................       state[10] = state[2]; 
4A46:  MOVLW  0A
4A48:  ADDWF  x3D,W
4A4A:  MOVWF  01
4A4C:  MOVLW  00
4A4E:  ADDWFC x3E,W
4A50:  MOVWF  03
4A52:  MOVLW  02
4A54:  ADDWF  x3D,W
4A56:  MOVWF  FE9
4A58:  MOVLW  00
4A5A:  ADDWFC x3E,W
4A5C:  MOVWF  FEA
4A5E:  MOVFF  FEF,84A
4A62:  MOVFF  03,FEA
4A66:  MOVFF  01,FE9
4A6A:  MOVFF  84A,FEF
....................       state[14] = state[6]; 
4A6E:  MOVLW  0E
4A70:  ADDWF  x3D,W
4A72:  MOVWF  01
4A74:  MOVLW  00
4A76:  ADDWFC x3E,W
4A78:  MOVWF  03
4A7A:  MOVLW  06
4A7C:  ADDWF  x3D,W
4A7E:  MOVWF  FE9
4A80:  MOVLW  00
4A82:  ADDWFC x3E,W
4A84:  MOVWF  FEA
4A86:  MOVFF  FEF,84A
4A8A:  MOVFF  03,FEA
4A8E:  MOVFF  01,FE9
4A92:  MOVFF  84A,FEF
....................       state[2] = buf1; 
4A96:  MOVLW  02
4A98:  ADDWF  x3D,W
4A9A:  MOVWF  FE9
4A9C:  MOVLW  00
4A9E:  ADDWFC x3E,W
4AA0:  MOVWF  FEA
4AA2:  MOVFF  842,FEF
....................       state[6] = buf2; 
4AA6:  MOVLW  06
4AA8:  ADDWF  x3D,W
4AAA:  MOVWF  FE9
4AAC:  MOVLW  00
4AAE:  ADDWFC x3E,W
4AB0:  MOVWF  FEA
4AB2:  MOVFF  843,FEF
....................       //Row 3 
....................       buf1 = state[3]; 
4AB6:  MOVLW  03
4AB8:  ADDWF  x3D,W
4ABA:  MOVWF  FE9
4ABC:  MOVLW  00
4ABE:  ADDWFC x3E,W
4AC0:  MOVWF  FEA
4AC2:  MOVFF  FEF,842
....................       state[3] = state[7]; 
4AC6:  MOVLW  03
4AC8:  ADDWF  x3D,W
4ACA:  MOVWF  01
4ACC:  MOVLW  00
4ACE:  ADDWFC x3E,W
4AD0:  MOVWF  03
4AD2:  MOVLW  07
4AD4:  ADDWF  x3D,W
4AD6:  MOVWF  FE9
4AD8:  MOVLW  00
4ADA:  ADDWFC x3E,W
4ADC:  MOVWF  FEA
4ADE:  MOVFF  FEF,84A
4AE2:  MOVFF  03,FEA
4AE6:  MOVFF  01,FE9
4AEA:  MOVFF  84A,FEF
....................       state[7] = state[11]; 
4AEE:  MOVLW  07
4AF0:  ADDWF  x3D,W
4AF2:  MOVWF  01
4AF4:  MOVLW  00
4AF6:  ADDWFC x3E,W
4AF8:  MOVWF  03
4AFA:  MOVLW  0B
4AFC:  ADDWF  x3D,W
4AFE:  MOVWF  FE9
4B00:  MOVLW  00
4B02:  ADDWFC x3E,W
4B04:  MOVWF  FEA
4B06:  MOVFF  FEF,84A
4B0A:  MOVFF  03,FEA
4B0E:  MOVFF  01,FE9
4B12:  MOVFF  84A,FEF
....................       state[11] = state[15]; 
4B16:  MOVLW  0B
4B18:  ADDWF  x3D,W
4B1A:  MOVWF  01
4B1C:  MOVLW  00
4B1E:  ADDWFC x3E,W
4B20:  MOVWF  03
4B22:  MOVLW  0F
4B24:  ADDWF  x3D,W
4B26:  MOVWF  FE9
4B28:  MOVLW  00
4B2A:  ADDWFC x3E,W
4B2C:  MOVWF  FEA
4B2E:  MOVFF  FEF,84A
4B32:  MOVFF  03,FEA
4B36:  MOVFF  01,FE9
4B3A:  MOVFF  84A,FEF
....................       state[15] = buf1;          
4B3E:  MOVLW  0F
4B40:  ADDWF  x3D,W
4B42:  MOVWF  FE9
4B44:  MOVLW  00
4B46:  ADDWFC x3E,W
4B48:  MOVWF  FEA
4B4A:  MOVFF  842,FEF
....................             
....................       for (i = 0; i <16; i++){ 
4B4E:  CLRF   x47
4B50:  MOVF   x47,W
4B52:  SUBLW  0F
4B54:  BNC   4BA6
....................         // with shiftrow i+5 mod 16 
....................         state[i]=rsbox[state[i]] ^ key[i]; 
4B56:  CLRF   03
4B58:  MOVF   x47,W
4B5A:  ADDWF  x3D,W
4B5C:  MOVWF  01
4B5E:  MOVF   x3E,W
4B60:  ADDWFC 03,F
4B62:  MOVFF  01,848
4B66:  MOVFF  03,849
4B6A:  CLRF   03
4B6C:  MOVF   x47,W
4B6E:  ADDWF  x3D,W
4B70:  MOVWF  FE9
4B72:  MOVF   x3E,W
4B74:  ADDWFC 03,W
4B76:  MOVWF  FEA
4B78:  CLRF   03
4B7A:  MOVF   FEF,W
4B7C:  MOVLB  0
4B7E:  CALL   01E0
4B82:  MOVLB  8
4B84:  MOVWF  x4A
4B86:  CLRF   03
4B88:  MOVF   x47,W
4B8A:  ADDWF  x3F,W
4B8C:  MOVWF  FE9
4B8E:  MOVF   x40,W
4B90:  ADDWFC 03,W
4B92:  MOVWF  FEA
4B94:  MOVF   FEF,W
4B96:  XORWF  x4A,W
4B98:  MOVFF  849,FEA
4B9C:  MOVFF  848,FE9
4BA0:  MOVWF  FEF
....................       }  
4BA2:  INCF   x47,F
4BA4:  BRA    4B50
....................     }  
....................     else  
4BA6:  BRA    4D1A
....................     { 
....................       //key schedule 
....................       key[0] = sbox[key[13]]^key[0]^Rcon[round]; 
4BA8:  MOVFF  83F,01
4BAC:  MOVFF  840,03
4BB0:  MOVFF  83F,848
4BB4:  MOVFF  840,849
4BB8:  MOVLW  0D
4BBA:  ADDWF  x3F,W
4BBC:  MOVWF  FE9
4BBE:  MOVLW  00
4BC0:  ADDWFC x40,W
4BC2:  MOVWF  FEA
4BC4:  CLRF   03
4BC6:  MOVF   FEF,W
4BC8:  MOVLB  0
4BCA:  CALL   00D0
4BCE:  MOVLB  8
4BD0:  MOVWF  x4A
4BD2:  MOVFF  83F,FE9
4BD6:  MOVFF  840,FEA
4BDA:  MOVF   FEF,W
4BDC:  XORWF  x4A,F
4BDE:  CLRF   03
4BE0:  MOVF   x46,W
4BE2:  MOVLB  0
4BE4:  CALL   02F0
4BE8:  MOVWF  01
4BEA:  MOVLB  8
4BEC:  MOVF   x4A,W
4BEE:  XORWF  01,W
4BF0:  MOVFF  849,FEA
4BF4:  MOVFF  848,FE9
4BF8:  MOVWF  FEF
....................       key[1] = sbox[key[14]]^key[1]; 
4BFA:  MOVLW  01
4BFC:  ADDWF  x3F,W
4BFE:  MOVWF  01
4C00:  MOVLW  00
4C02:  ADDWFC x40,W
4C04:  MOVWF  03
4C06:  MOVFF  01,848
4C0A:  MOVWF  x49
4C0C:  MOVLW  0E
4C0E:  ADDWF  x3F,W
4C10:  MOVWF  FE9
4C12:  MOVLW  00
4C14:  ADDWFC x40,W
4C16:  MOVWF  FEA
4C18:  CLRF   03
4C1A:  MOVF   FEF,W
4C1C:  MOVLB  0
4C1E:  CALL   00D0
4C22:  MOVLB  8
4C24:  MOVWF  x4A
4C26:  MOVLW  01
4C28:  ADDWF  x3F,W
4C2A:  MOVWF  FE9
4C2C:  MOVLW  00
4C2E:  ADDWFC x40,W
4C30:  MOVWF  FEA
4C32:  MOVF   FEF,W
4C34:  XORWF  x4A,W
4C36:  MOVFF  849,FEA
4C3A:  MOVFF  848,FE9
4C3E:  MOVWF  FEF
....................       key[2] = sbox[key[15]]^key[2]; 
4C40:  MOVLW  02
4C42:  ADDWF  x3F,W
4C44:  MOVWF  01
4C46:  MOVLW  00
4C48:  ADDWFC x40,W
4C4A:  MOVWF  03
4C4C:  MOVFF  01,848
4C50:  MOVWF  x49
4C52:  MOVLW  0F
4C54:  ADDWF  x3F,W
4C56:  MOVWF  FE9
4C58:  MOVLW  00
4C5A:  ADDWFC x40,W
4C5C:  MOVWF  FEA
4C5E:  CLRF   03
4C60:  MOVF   FEF,W
4C62:  MOVLB  0
4C64:  CALL   00D0
4C68:  MOVLB  8
4C6A:  MOVWF  x4A
4C6C:  MOVLW  02
4C6E:  ADDWF  x3F,W
4C70:  MOVWF  FE9
4C72:  MOVLW  00
4C74:  ADDWFC x40,W
4C76:  MOVWF  FEA
4C78:  MOVF   FEF,W
4C7A:  XORWF  x4A,W
4C7C:  MOVFF  849,FEA
4C80:  MOVFF  848,FE9
4C84:  MOVWF  FEF
....................       key[3] = sbox[key[12]]^key[3]; 
4C86:  MOVLW  03
4C88:  ADDWF  x3F,W
4C8A:  MOVWF  01
4C8C:  MOVLW  00
4C8E:  ADDWFC x40,W
4C90:  MOVWF  03
4C92:  MOVFF  01,848
4C96:  MOVWF  x49
4C98:  MOVLW  0C
4C9A:  ADDWF  x3F,W
4C9C:  MOVWF  FE9
4C9E:  MOVLW  00
4CA0:  ADDWFC x40,W
4CA2:  MOVWF  FEA
4CA4:  CLRF   03
4CA6:  MOVF   FEF,W
4CA8:  MOVLB  0
4CAA:  CALL   00D0
4CAE:  MOVLB  8
4CB0:  MOVWF  x4A
4CB2:  MOVLW  03
4CB4:  ADDWF  x3F,W
4CB6:  MOVWF  FE9
4CB8:  MOVLW  00
4CBA:  ADDWFC x40,W
4CBC:  MOVWF  FEA
4CBE:  MOVF   FEF,W
4CC0:  XORWF  x4A,W
4CC2:  MOVFF  849,FEA
4CC6:  MOVFF  848,FE9
4CCA:  MOVWF  FEF
....................       for (i=4; i<16; i++) { 
4CCC:  MOVLW  04
4CCE:  MOVWF  x47
4CD0:  MOVF   x47,W
4CD2:  SUBLW  0F
4CD4:  BNC   4D1A
....................         key[i] = key[i] ^ key[i-4]; 
4CD6:  CLRF   03
4CD8:  MOVF   x47,W
4CDA:  ADDWF  x3F,W
4CDC:  MOVWF  01
4CDE:  MOVF   x40,W
4CE0:  ADDWFC 03,F
4CE2:  MOVFF  03,849
4CE6:  CLRF   03
4CE8:  MOVF   x47,W
4CEA:  ADDWF  x3F,W
4CEC:  MOVWF  FE9
4CEE:  MOVF   x40,W
4CF0:  ADDWFC 03,W
4CF2:  MOVWF  FEA
4CF4:  MOVFF  FEF,84A
4CF8:  MOVLW  04
4CFA:  SUBWF  x47,W
4CFC:  CLRF   03
4CFE:  ADDWF  x3F,W
4D00:  MOVWF  FE9
4D02:  MOVF   x40,W
4D04:  ADDWFC 03,W
4D06:  MOVWF  FEA
4D08:  MOVF   FEF,W
4D0A:  XORWF  x4A,W
4D0C:  MOVFF  849,FEA
4D10:  MOVFF  01,FE9
4D14:  MOVWF  FEF
....................       } 
4D16:  INCF   x47,F
4D18:  BRA    4CD0
....................     } 
....................   } 
4D1A:  INCF   x46,F
4D1C:  GOTO   42D2
....................   if (dir == 0)  
4D20:  MOVF   x41,F
4D22:  BNZ   4D6E
....................   { 
....................   //last Addroundkey 
....................     for (i = 0; i <16; i++){ 
4D24:  CLRF   x47
4D26:  MOVF   x47,W
4D28:  SUBLW  0F
4D2A:  BNC   4D6E
....................       // with shiftrow i+5 mod 16 
....................       state[i]=state[i] ^ key[i]; 
4D2C:  CLRF   03
4D2E:  MOVF   x47,W
4D30:  ADDWF  x3D,W
4D32:  MOVWF  01
4D34:  MOVF   x3E,W
4D36:  ADDWFC 03,F
4D38:  MOVFF  03,849
4D3C:  CLRF   03
4D3E:  MOVF   x47,W
4D40:  ADDWF  x3D,W
4D42:  MOVWF  FE9
4D44:  MOVF   x3E,W
4D46:  ADDWFC 03,W
4D48:  MOVWF  FEA
4D4A:  MOVFF  FEF,84A
4D4E:  CLRF   03
4D50:  MOVF   x47,W
4D52:  ADDWF  x3F,W
4D54:  MOVWF  FE9
4D56:  MOVF   x40,W
4D58:  ADDWFC 03,W
4D5A:  MOVWF  FEA
4D5C:  MOVF   FEF,W
4D5E:  XORWF  x4A,W
4D60:  MOVFF  849,FEA
4D64:  MOVFF  01,FE9
4D68:  MOVWF  FEF
....................     } // enf for 
4D6A:  INCF   x47,F
4D6C:  BRA    4D26
....................   } // end if (!dir) 
.................... } // end function 
4D6E:  MOVLB  0
4D70:  GOTO   4EF6 (RETURN)
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                  
....................  
.................... #define     wideofkeystore      16 
.................... #define     key_numbyte         wideofkeystore-4 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 kp_st=0; 
.................... int8 type_KB=0; 
....................  
.................... int8 key_data[wideofkeystore]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
1F36:  MOVLB  1
1F38:  INCF   x57,F
1F3A:  MOVF   x57,W
1F3C:  SUBLW  01
1F3E:  BTFSC  FD8.0
1F40:  BRA    20E4
....................        switch (col) { 
1F42:  MOVF   x5A,W
1F44:  ADDLW  FB
1F46:  BC    1FCA
1F48:  ADDLW  05
1F4A:  MOVLB  0
1F4C:  GOTO   20EE
....................          case 0   :  
....................                     output_low(COL0); 
1F50:  BCF    F92.5
1F52:  BCF    F89.5
....................                     output_high(COL1); 
1F54:  BCF    F92.3
1F56:  BSF    F89.3
....................                     output_high(COL2); 
1F58:  BCF    F92.2
1F5A:  BSF    F89.2
....................                     output_high(COL3); 
1F5C:  BCF    F92.1
1F5E:  BSF    F89.1
....................                     output_high(COL4); 
1F60:  BCF    F92.0
1F62:  BSF    F89.0
....................                     break; 
1F64:  MOVLB  1
1F66:  BRA    1FCA
....................          case 1   :  
....................                     output_low(COL1); 
1F68:  BCF    F92.3
1F6A:  BCF    F89.3
....................                     output_high(COL0); 
1F6C:  BCF    F92.5
1F6E:  BSF    F89.5
....................                     output_high(COL2); 
1F70:  BCF    F92.2
1F72:  BSF    F89.2
....................                     output_high(COL3); 
1F74:  BCF    F92.1
1F76:  BSF    F89.1
....................                     output_high(COL4); 
1F78:  BCF    F92.0
1F7A:  BSF    F89.0
....................                     break; 
1F7C:  MOVLB  1
1F7E:  BRA    1FCA
....................          case 2   :  
....................                     output_low(COL2); 
1F80:  BCF    F92.2
1F82:  BCF    F89.2
....................                     output_high(COL1); 
1F84:  BCF    F92.3
1F86:  BSF    F89.3
....................                     output_high(COL0); 
1F88:  BCF    F92.5
1F8A:  BSF    F89.5
....................                     output_high(COL3); 
1F8C:  BCF    F92.1
1F8E:  BSF    F89.1
....................                     output_high(COL4); 
1F90:  BCF    F92.0
1F92:  BSF    F89.0
....................                     break; 
1F94:  MOVLB  1
1F96:  BRA    1FCA
....................          case 3   :  
....................                     output_low(COL3); 
1F98:  BCF    F92.1
1F9A:  BCF    F89.1
....................                     output_high(COL1); 
1F9C:  BCF    F92.3
1F9E:  BSF    F89.3
....................                     output_high(COL2); 
1FA0:  BCF    F92.2
1FA2:  BSF    F89.2
....................                     output_high(COL0); 
1FA4:  BCF    F92.5
1FA6:  BSF    F89.5
....................                     output_high(COL4); 
1FA8:  BCF    F92.0
1FAA:  BSF    F89.0
....................                     break; 
1FAC:  MOVLB  1
1FAE:  BRA    1FCA
....................          case 4   :  
....................                     output_low(COL4); 
1FB0:  BCF    F92.0
1FB2:  BCF    F89.0
....................                     output_high(COL1); 
1FB4:  BCF    F92.3
1FB6:  BSF    F89.3
....................                     output_high(COL2); 
1FB8:  BCF    F92.2
1FBA:  BSF    F89.2
....................                     output_high(COL3); 
1FBC:  BCF    F92.1
1FBE:  BSF    F89.1
....................                     output_high(COL0); 
1FC0:  BCF    F92.5
1FC2:  BSF    F89.5
....................                     break; 
1FC4:  MOVLB  1
1FC6:  BRA    1FCA
1FC8:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
1FCA:  BTFSS  x58.0
1FCC:  BRA    204A
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
1FCE:  BSF    F93.4
1FD0:  MOVLW  00
1FD2:  BTFSC  F81.4
1FD4:  MOVLW  01
1FD6:  MOVLB  8
1FD8:  MOVWF  x2B
1FDA:  BSF    F93.5
1FDC:  MOVLW  00
1FDE:  BTFSC  F81.5
1FE0:  MOVLW  01
1FE2:  ANDWF  x2B,F
1FE4:  BSF    F93.6
1FE6:  MOVLW  00
1FE8:  BTFSC  F81.6
1FEA:  MOVLW  01
1FEC:  ANDWF  x2B,F
1FEE:  BSF    F93.7
1FF0:  MOVLW  00
1FF2:  BTFSC  F81.7
1FF4:  MOVLW  01
1FF6:  ANDWF  x2B,W
1FF8:  BZ    2046
....................          { 
....................             kchar=last_key; 
1FFA:  MOVFF  159,829
....................             if(keydebug_en==0) 
1FFE:  MOVLB  1
2000:  MOVF   x40,F
2002:  BNZ   2034
....................             { 
....................                 //count_timer0=0; 
....................                 charac_timeout=0; 
2004:  MOVLB  0
2006:  CLRF   xFC
2008:  CLRF   xFB
....................                 if(key_count_ms<wideofkeystore) 
200A:  MOVLB  1
200C:  MOVF   x43,W
200E:  SUBLW  0F
2010:  BNC   2032
....................                 { 
....................                     key_data[key_count_ms++]=kchar; 
2012:  MOVF   x43,W
2014:  INCF   x43,F
2016:  CLRF   03
2018:  ADDLW  46
201A:  MOVWF  FE9
201C:  MOVLW  01
201E:  ADDWFC 03,W
2020:  MOVWF  FEA
2022:  MOVFF  829,FEF
....................                     fputc(kchar,COM2); 
2026:  MOVFF  829,852
202A:  MOVLB  0
202C:  CALL   15C0
2030:  MOVLB  1
....................                 } 
....................             } 
....................                else fputc(kchar,COM2); 
2032:  BRA    2040
2034:  MOVFF  829,852
2038:  MOVLB  0
203A:  CALL   15C0
203E:  MOVLB  1
....................            kbd_down=FALSE; 
2040:  BCF    x58.0
....................            last_key=0; 
2042:  CLRF   x59
2044:  MOVLB  8
....................          } 
....................        } else 
2046:  BRA    20E0
2048:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
204A:  BSF    F93.4
204C:  MOVLW  00
204E:  BTFSC  F81.4
2050:  MOVLW  01
2052:  MOVLB  8
2054:  MOVWF  x2B
2056:  BSF    F93.5
2058:  MOVLW  00
205A:  BTFSC  F81.5
205C:  MOVLW  01
205E:  ANDWF  x2B,F
2060:  BSF    F93.6
2062:  MOVLW  00
2064:  BTFSC  F81.6
2066:  MOVLW  01
2068:  ANDWF  x2B,F
206A:  BSF    F93.7
206C:  MOVLW  00
206E:  BTFSC  F81.7
2070:  MOVLW  01
2072:  ANDWF  x2B,W
2074:  BNZ   20D4
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
2076:  BSF    F93.4
2078:  BTFSC  F81.4
207A:  BRA    2080
....................                   row=0; 
207C:  CLRF   x2A
....................                 else if(input(ROW1)==0) 
207E:  BRA    20A2
2080:  BSF    F93.5
2082:  BTFSC  F81.5
2084:  BRA    208C
....................                   row=1; 
2086:  MOVLW  01
2088:  MOVWF  x2A
....................                 else if(input(ROW2)==0) 
208A:  BRA    20A2
208C:  BSF    F93.6
208E:  BTFSC  F81.6
2090:  BRA    2098
....................                   row=2; 
2092:  MOVLW  02
2094:  MOVWF  x2A
....................                 else if(input(ROW3)==0) 
2096:  BRA    20A2
2098:  BSF    F93.7
209A:  BTFSC  F81.7
209C:  BRA    20A2
....................                   row=3; 
209E:  MOVLW  03
20A0:  MOVWF  x2A
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
20A2:  MOVF   x2A,W
20A4:  MULLW  05
20A6:  MOVF   FF3,W
20A8:  CLRF   x2C
20AA:  MOVWF  x2B
20AC:  CLRF   03
20AE:  MOVLB  1
20B0:  MOVF   x5A,W
20B2:  MOVLB  8
20B4:  ADDWF  x2B,W
20B6:  MOVWF  01
20B8:  MOVF   x2C,W
20BA:  ADDWFC 03,F
20BC:  MOVF   01,W
20BE:  MOVLB  0
20C0:  CALL   030A
20C4:  MOVFF  FE8,159
....................                 kbd_down = TRUE; 
20C8:  MOVLB  1
20CA:  BSF    x58.0
....................                 set_tris_a(0xff); 
20CC:  MOVLW  FF
20CE:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
20D0:  BRA    20E0
20D2:  MOVLB  8
....................                { 
....................                   ++col; 
20D4:  MOVLB  1
20D6:  INCF   x5A,F
....................                   if(col==5) col=0; 
20D8:  MOVF   x5A,W
20DA:  SUBLW  05
20DC:  BTFSC  FD8.2
20DE:  CLRF   x5A
....................                } 
....................          } 
....................       kbd_call_count=0; 
20E0:  MOVLB  1
20E2:  CLRF   x57
....................    } 
....................   return(kchar); 
20E4:  MOVLB  8
20E6:  MOVFF  829,01
.................... } 
20EA:  MOVLB  0
20EC:  RETURN 0
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2112:  MOVLW  E0
2114:  MOVLB  F
2116:  MOVWF  x48
2118:  BCF    FC2.6
211A:  BCF    FC2.7
211C:  MOVF   x49,W
211E:  ANDLW  E0
2120:  IORLW  17
2122:  MOVWF  x49
....................    switch(col) 
....................    { 
2124:  MOVLB  8
2126:  MOVF   x46,W
2128:  ADDLW  FA
212A:  BC    21F6
212C:  ADDLW  06
212E:  MOVLB  0
2130:  GOTO   21FA
....................       case 0: 
....................         set_adc_channel(4); 
2134:  MOVLW  10
2136:  MOVWF  01
2138:  MOVF   FC2,W
213A:  ANDLW  C3
213C:  IORWF  01,W
213E:  MOVWF  FC2
....................         adc=read_adc(); 
2140:  BSF    FC2.1
2142:  BTFSC  FC2.1
2144:  BRA    2142
2146:  MOVFF  FC4,847
....................         return adc; 
214A:  MOVLB  8
214C:  MOVFF  847,01
2150:  BRA    21F6
....................       break; 
2152:  BRA    21F6
....................       case 1: 
....................         set_adc_channel(3); 
2154:  MOVLW  0C
2156:  MOVWF  01
2158:  MOVF   FC2,W
215A:  ANDLW  C3
215C:  IORWF  01,W
215E:  MOVWF  FC2
....................         adc=read_adc(); 
2160:  BSF    FC2.1
2162:  BTFSC  FC2.1
2164:  BRA    2162
2166:  MOVFF  FC4,847
....................         return adc; 
216A:  MOVLB  8
216C:  MOVFF  847,01
2170:  BRA    21F6
....................       break; 
2172:  BRA    21F6
....................       case 2: 
....................         set_adc_channel(2); 
2174:  MOVLW  08
2176:  MOVWF  01
2178:  MOVF   FC2,W
217A:  ANDLW  C3
217C:  IORWF  01,W
217E:  MOVWF  FC2
....................         adc=read_adc(); 
2180:  BSF    FC2.1
2182:  BTFSC  FC2.1
2184:  BRA    2182
2186:  MOVFF  FC4,847
....................         return adc; 
218A:  MOVLB  8
218C:  MOVFF  847,01
2190:  BRA    21F6
....................       break; 
2192:  BRA    21F6
....................       case 3: 
....................         set_adc_channel(1); 
2194:  MOVLW  04
2196:  MOVWF  01
2198:  MOVF   FC2,W
219A:  ANDLW  C3
219C:  IORWF  01,W
219E:  MOVWF  FC2
....................         adc=read_adc(); 
21A0:  BSF    FC2.1
21A2:  BTFSC  FC2.1
21A4:  BRA    21A2
21A6:  MOVFF  FC4,847
....................         return adc; 
21AA:  MOVLB  8
21AC:  MOVFF  847,01
21B0:  BRA    21F6
....................       break; 
21B2:  BRA    21F6
....................       case 4: 
....................         set_adc_channel(0); 
21B4:  MOVLW  00
21B6:  MOVWF  01
21B8:  MOVF   FC2,W
21BA:  ANDLW  C3
21BC:  IORWF  01,W
21BE:  MOVWF  FC2
....................         adc=read_adc(); 
21C0:  BSF    FC2.1
21C2:  BTFSC  FC2.1
21C4:  BRA    21C2
21C6:  MOVFF  FC4,847
....................         return adc; 
21CA:  MOVLB  8
21CC:  MOVFF  847,01
21D0:  BRA    21F6
....................       break;      
21D2:  BRA    21F6
....................       case 5: 
....................         set_adc_channel(11); 
21D4:  MOVLW  2C
21D6:  MOVWF  01
21D8:  MOVF   FC2,W
21DA:  ANDLW  C3
21DC:  IORWF  01,W
21DE:  MOVWF  FC2
....................         adc=read_adc(); 
21E0:  BSF    FC2.1
21E2:  BTFSC  FC2.1
21E4:  BRA    21E2
21E6:  MOVFF  FC4,847
....................         return adc; 
21EA:  MOVLB  8
21EC:  MOVFF  847,01
21F0:  BRA    21F6
....................       break;      
21F2:  BRA    21F6
21F4:  MOVLB  8
....................    } 
.................... } 
21F6:  MOVLB  0
21F8:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
2374:  MOVLB  8
2376:  CLRF   x31
2378:  CLRF   x30
237A:  CLRF   x2F
237C:  CLRF   x2E
237E:  CLRF   x35
2380:  CLRF   x34
2382:  CLRF   x33
2384:  CLRF   x32
2386:  CLRF   x39
2388:  CLRF   x38
238A:  CLRF   x37
238C:  CLRF   x36
238E:  CLRF   x3D
2390:  CLRF   x3C
2392:  CLRF   x3B
2394:  CLRF   x3A
2396:  CLRF   x41
2398:  CLRF   x40
239A:  CLRF   x3F
239C:  CLRF   x3E
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
239E:  CLRF   x2D
23A0:  CLRF   x2C
23A2:  MOVF   x2D,W
23A4:  SUBLW  01
23A6:  BNC   2424
23A8:  BNZ   23B0
23AA:  MOVF   x2C,W
23AC:  SUBLW  F3
23AE:  BNC   2424
....................    { 
....................       col_0=read_col(0)+col_0; 
23B0:  CLRF   x46
23B2:  MOVLB  0
23B4:  RCALL  2112
23B6:  MOVF   01,W
23B8:  MOVLB  8
23BA:  ADDWF  x2E,F
23BC:  MOVLW  00
23BE:  ADDWFC x2F,F
23C0:  ADDWFC x30,F
23C2:  ADDWFC x31,F
....................       col_1=read_col(1)+col_1; 
23C4:  MOVLW  01
23C6:  MOVWF  x46
23C8:  MOVLB  0
23CA:  RCALL  2112
23CC:  MOVF   01,W
23CE:  MOVLB  8
23D0:  ADDWF  x32,F
23D2:  MOVLW  00
23D4:  ADDWFC x33,F
23D6:  ADDWFC x34,F
23D8:  ADDWFC x35,F
....................       col_2=read_col(2)+col_2; 
23DA:  MOVLW  02
23DC:  MOVWF  x46
23DE:  MOVLB  0
23E0:  RCALL  2112
23E2:  MOVF   01,W
23E4:  MOVLB  8
23E6:  ADDWF  x36,F
23E8:  MOVLW  00
23EA:  ADDWFC x37,F
23EC:  ADDWFC x38,F
23EE:  ADDWFC x39,F
....................       col_3=read_col(3)+col_3; 
23F0:  MOVLW  03
23F2:  MOVWF  x46
23F4:  MOVLB  0
23F6:  RCALL  2112
23F8:  MOVF   01,W
23FA:  MOVLB  8
23FC:  ADDWF  x3A,F
23FE:  MOVLW  00
2400:  ADDWFC x3B,F
2402:  ADDWFC x3C,F
2404:  ADDWFC x3D,F
....................       col_4=read_col(4)+col_4; 
2406:  MOVLW  04
2408:  MOVWF  x46
240A:  MOVLB  0
240C:  RCALL  2112
240E:  MOVF   01,W
2410:  MOVLB  8
2412:  ADDWF  x3E,F
2414:  MOVLW  00
2416:  ADDWFC x3F,F
2418:  ADDWFC x40,F
241A:  ADDWFC x41,F
....................    } 
241C:  INCF   x2C,F
241E:  BTFSC  FD8.2
2420:  INCF   x2D,F
2422:  BRA    23A2
....................    col_0=col_0/500; 
2424:  BCF    FD8.1
2426:  MOVFF  831,855
242A:  MOVFF  830,854
242E:  MOVFF  82F,853
2432:  MOVFF  82E,852
2436:  CLRF   x59
2438:  CLRF   x58
243A:  MOVLW  01
243C:  MOVWF  x57
243E:  MOVLW  F4
2440:  MOVWF  x56
2442:  MOVLB  0
2444:  RCALL  2220
2446:  MOVFF  03,831
244A:  MOVFF  02,830
244E:  MOVFF  01,82F
2452:  MOVFF  00,82E
....................    col_1=col_1/500; 
2456:  BCF    FD8.1
2458:  MOVFF  835,855
245C:  MOVFF  834,854
2460:  MOVFF  833,853
2464:  MOVFF  832,852
2468:  MOVLB  8
246A:  CLRF   x59
246C:  CLRF   x58
246E:  MOVLW  01
2470:  MOVWF  x57
2472:  MOVLW  F4
2474:  MOVWF  x56
2476:  MOVLB  0
2478:  RCALL  2220
247A:  MOVFF  03,835
247E:  MOVFF  02,834
2482:  MOVFF  01,833
2486:  MOVFF  00,832
....................    col_2=col_2/500; 
248A:  BCF    FD8.1
248C:  MOVFF  839,855
2490:  MOVFF  838,854
2494:  MOVFF  837,853
2498:  MOVFF  836,852
249C:  MOVLB  8
249E:  CLRF   x59
24A0:  CLRF   x58
24A2:  MOVLW  01
24A4:  MOVWF  x57
24A6:  MOVLW  F4
24A8:  MOVWF  x56
24AA:  MOVLB  0
24AC:  RCALL  2220
24AE:  MOVFF  03,839
24B2:  MOVFF  02,838
24B6:  MOVFF  01,837
24BA:  MOVFF  00,836
....................    col_3=col_3/500; 
24BE:  BCF    FD8.1
24C0:  MOVFF  83D,855
24C4:  MOVFF  83C,854
24C8:  MOVFF  83B,853
24CC:  MOVFF  83A,852
24D0:  MOVLB  8
24D2:  CLRF   x59
24D4:  CLRF   x58
24D6:  MOVLW  01
24D8:  MOVWF  x57
24DA:  MOVLW  F4
24DC:  MOVWF  x56
24DE:  MOVLB  0
24E0:  RCALL  2220
24E2:  MOVFF  03,83D
24E6:  MOVFF  02,83C
24EA:  MOVFF  01,83B
24EE:  MOVFF  00,83A
....................    col_4=col_4/500; 
24F2:  BCF    FD8.1
24F4:  MOVFF  841,855
24F8:  MOVFF  840,854
24FC:  MOVFF  83F,853
2500:  MOVFF  83E,852
2504:  MOVLB  8
2506:  CLRF   x59
2508:  CLRF   x58
250A:  MOVLW  01
250C:  MOVWF  x57
250E:  MOVLW  F4
2510:  MOVWF  x56
2512:  MOVLB  0
2514:  RCALL  2220
2516:  MOVFF  03,841
251A:  MOVFF  02,840
251E:  MOVFF  01,83F
2522:  MOVFF  00,83E
....................    if(keydebug_en) 
2526:  MOVLB  1
2528:  MOVF   x40,F
252A:  BTFSC  FD8.2
252C:  BRA    26A8
....................    { 
....................       fprintf(COM2,"\r\n");      
252E:  MOVLW  0D
2530:  MOVLB  8
2532:  MOVWF  x52
2534:  MOVLB  0
2536:  CALL   15C0
253A:  MOVLW  0A
253C:  MOVLB  8
253E:  MOVWF  x52
2540:  MOVLB  0
2542:  CALL   15C0
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2546:  MOVLW  BC
2548:  MOVWF  FF6
254A:  MOVLW  04
254C:  MOVWF  FF7
254E:  MOVLW  07
2550:  MOVLB  8
2552:  MOVWF  x46
2554:  MOVLB  0
2556:  CALL   1606
255A:  MOVLW  41
255C:  MOVWF  FE9
255E:  MOVFF  831,849
2562:  MOVFF  830,848
2566:  MOVFF  82F,847
256A:  MOVFF  82E,846
256E:  RCALL  22B4
2570:  MOVLW  0D
2572:  MOVLB  8
2574:  MOVWF  x52
2576:  MOVLB  0
2578:  CALL   15C0
257C:  MOVLW  0A
257E:  MOVLB  8
2580:  MOVWF  x52
2582:  MOVLB  0
2584:  CALL   15C0
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2588:  MOVLW  CA
258A:  MOVWF  FF6
258C:  MOVLW  04
258E:  MOVWF  FF7
2590:  MOVLW  07
2592:  MOVLB  8
2594:  MOVWF  x46
2596:  MOVLB  0
2598:  CALL   1606
259C:  MOVLW  41
259E:  MOVWF  FE9
25A0:  MOVFF  835,849
25A4:  MOVFF  834,848
25A8:  MOVFF  833,847
25AC:  MOVFF  832,846
25B0:  RCALL  22B4
25B2:  MOVLW  0D
25B4:  MOVLB  8
25B6:  MOVWF  x52
25B8:  MOVLB  0
25BA:  CALL   15C0
25BE:  MOVLW  0A
25C0:  MOVLB  8
25C2:  MOVWF  x52
25C4:  MOVLB  0
25C6:  CALL   15C0
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
25CA:  MOVLW  D8
25CC:  MOVWF  FF6
25CE:  MOVLW  04
25D0:  MOVWF  FF7
25D2:  MOVLW  07
25D4:  MOVLB  8
25D6:  MOVWF  x46
25D8:  MOVLB  0
25DA:  CALL   1606
25DE:  MOVLW  41
25E0:  MOVWF  FE9
25E2:  MOVFF  839,849
25E6:  MOVFF  838,848
25EA:  MOVFF  837,847
25EE:  MOVFF  836,846
25F2:  RCALL  22B4
25F4:  MOVLW  0D
25F6:  MOVLB  8
25F8:  MOVWF  x52
25FA:  MOVLB  0
25FC:  CALL   15C0
2600:  MOVLW  0A
2602:  MOVLB  8
2604:  MOVWF  x52
2606:  MOVLB  0
2608:  CALL   15C0
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
260C:  MOVLW  E6
260E:  MOVWF  FF6
2610:  MOVLW  04
2612:  MOVWF  FF7
2614:  MOVLW  07
2616:  MOVLB  8
2618:  MOVWF  x46
261A:  MOVLB  0
261C:  CALL   1606
2620:  MOVLW  41
2622:  MOVWF  FE9
2624:  MOVFF  83D,849
2628:  MOVFF  83C,848
262C:  MOVFF  83B,847
2630:  MOVFF  83A,846
2634:  RCALL  22B4
2636:  MOVLW  0D
2638:  MOVLB  8
263A:  MOVWF  x52
263C:  MOVLB  0
263E:  CALL   15C0
2642:  MOVLW  0A
2644:  MOVLB  8
2646:  MOVWF  x52
2648:  MOVLB  0
264A:  CALL   15C0
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
264E:  MOVLW  F4
2650:  MOVWF  FF6
2652:  MOVLW  04
2654:  MOVWF  FF7
2656:  MOVLW  07
2658:  MOVLB  8
265A:  MOVWF  x46
265C:  MOVLB  0
265E:  CALL   1606
2662:  MOVLW  41
2664:  MOVWF  FE9
2666:  MOVFF  841,849
266A:  MOVFF  840,848
266E:  MOVFF  83F,847
2672:  MOVFF  83E,846
2676:  RCALL  22B4
2678:  MOVLW  0D
267A:  MOVLB  8
267C:  MOVWF  x52
267E:  MOVLB  0
2680:  CALL   15C0
2684:  MOVLW  0A
2686:  MOVLB  8
2688:  MOVWF  x52
268A:  MOVLB  0
268C:  CALL   15C0
....................       fprintf(COM2,"\r\n"); 
2690:  MOVLW  0D
2692:  MOVLB  8
2694:  MOVWF  x52
2696:  MOVLB  0
2698:  CALL   15C0
269C:  MOVLW  0A
269E:  MOVLB  8
26A0:  MOVWF  x52
26A2:  MOVLB  0
26A4:  CALL   15C0
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
26A8:  MOVLB  8
26AA:  MOVF   x31,F
26AC:  BNZ   26BC
26AE:  MOVF   x30,F
26B0:  BNZ   26BC
26B2:  MOVF   x2F,F
26B4:  BNZ   26BC
26B6:  MOVF   x2E,W
26B8:  SUBLW  05
26BA:  BC    271C
26BC:  MOVF   x31,F
26BE:  BNZ   271C
26C0:  MOVF   x30,F
26C2:  BNZ   271C
26C4:  MOVF   x2F,F
26C6:  BNZ   271C
26C8:  MOVF   x2E,W
26CA:  SUBLW  3B
26CC:  BNC   271C
26CE:  MOVF   x35,F
26D0:  BNZ   26E0
26D2:  MOVF   x34,F
26D4:  BNZ   26E0
26D6:  MOVF   x33,F
26D8:  BNZ   26E0
26DA:  MOVF   x32,W
26DC:  SUBLW  64
26DE:  BC    271C
26E0:  MOVF   x39,F
26E2:  BNZ   26F2
26E4:  MOVF   x38,F
26E6:  BNZ   26F2
26E8:  MOVF   x37,F
26EA:  BNZ   26F2
26EC:  MOVF   x36,W
26EE:  SUBLW  64
26F0:  BC    271C
26F2:  MOVF   x3D,F
26F4:  BNZ   2704
26F6:  MOVF   x3C,F
26F8:  BNZ   2704
26FA:  MOVF   x3B,F
26FC:  BNZ   2704
26FE:  MOVF   x3A,W
2700:  SUBLW  64
2702:  BC    271C
2704:  MOVF   x41,F
2706:  BNZ   2716
2708:  MOVF   x40,F
270A:  BNZ   2716
270C:  MOVF   x3F,F
270E:  BNZ   2716
2710:  MOVF   x3E,W
2712:  SUBLW  64
2714:  BC    271C
2716:  MOVLW  00
2718:  MOVWF  01
271A:  BRA    299A
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
271C:  MOVF   x35,F
271E:  BNZ   272E
2720:  MOVF   x34,F
2722:  BNZ   272E
2724:  MOVF   x33,F
2726:  BNZ   272E
2728:  MOVF   x32,W
272A:  SUBLW  05
272C:  BC    278E
272E:  MOVF   x35,F
2730:  BNZ   278E
2732:  MOVF   x34,F
2734:  BNZ   278E
2736:  MOVF   x33,F
2738:  BNZ   278E
273A:  MOVF   x32,W
273C:  SUBLW  3B
273E:  BNC   278E
2740:  MOVF   x31,F
2742:  BNZ   2752
2744:  MOVF   x30,F
2746:  BNZ   2752
2748:  MOVF   x2F,F
274A:  BNZ   2752
274C:  MOVF   x2E,W
274E:  SUBLW  64
2750:  BC    278E
2752:  MOVF   x39,F
2754:  BNZ   2764
2756:  MOVF   x38,F
2758:  BNZ   2764
275A:  MOVF   x37,F
275C:  BNZ   2764
275E:  MOVF   x36,W
2760:  SUBLW  64
2762:  BC    278E
2764:  MOVF   x3D,F
2766:  BNZ   2776
2768:  MOVF   x3C,F
276A:  BNZ   2776
276C:  MOVF   x3B,F
276E:  BNZ   2776
2770:  MOVF   x3A,W
2772:  SUBLW  64
2774:  BC    278E
2776:  MOVF   x41,F
2778:  BNZ   2788
277A:  MOVF   x40,F
277C:  BNZ   2788
277E:  MOVF   x3F,F
2780:  BNZ   2788
2782:  MOVF   x3E,W
2784:  SUBLW  64
2786:  BC    278E
2788:  MOVLW  01
278A:  MOVWF  01
278C:  BRA    299A
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
278E:  MOVF   x39,F
2790:  BNZ   27A0
2792:  MOVF   x38,F
2794:  BNZ   27A0
2796:  MOVF   x37,F
2798:  BNZ   27A0
279A:  MOVF   x36,W
279C:  SUBLW  05
279E:  BC    2800
27A0:  MOVF   x39,F
27A2:  BNZ   2800
27A4:  MOVF   x38,F
27A6:  BNZ   2800
27A8:  MOVF   x37,F
27AA:  BNZ   2800
27AC:  MOVF   x36,W
27AE:  SUBLW  3B
27B0:  BNC   2800
27B2:  MOVF   x35,F
27B4:  BNZ   27C4
27B6:  MOVF   x34,F
27B8:  BNZ   27C4
27BA:  MOVF   x33,F
27BC:  BNZ   27C4
27BE:  MOVF   x32,W
27C0:  SUBLW  64
27C2:  BC    2800
27C4:  MOVF   x31,F
27C6:  BNZ   27D6
27C8:  MOVF   x30,F
27CA:  BNZ   27D6
27CC:  MOVF   x2F,F
27CE:  BNZ   27D6
27D0:  MOVF   x2E,W
27D2:  SUBLW  64
27D4:  BC    2800
27D6:  MOVF   x3D,F
27D8:  BNZ   27E8
27DA:  MOVF   x3C,F
27DC:  BNZ   27E8
27DE:  MOVF   x3B,F
27E0:  BNZ   27E8
27E2:  MOVF   x3A,W
27E4:  SUBLW  64
27E6:  BC    2800
27E8:  MOVF   x41,F
27EA:  BNZ   27FA
27EC:  MOVF   x40,F
27EE:  BNZ   27FA
27F0:  MOVF   x3F,F
27F2:  BNZ   27FA
27F4:  MOVF   x3E,W
27F6:  SUBLW  64
27F8:  BC    2800
27FA:  MOVLW  02
27FC:  MOVWF  01
27FE:  BRA    299A
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2800:  MOVF   x3D,F
2802:  BNZ   2812
2804:  MOVF   x3C,F
2806:  BNZ   2812
2808:  MOVF   x3B,F
280A:  BNZ   2812
280C:  MOVF   x3A,W
280E:  SUBLW  05
2810:  BC    2872
2812:  MOVF   x3D,F
2814:  BNZ   2872
2816:  MOVF   x3C,F
2818:  BNZ   2872
281A:  MOVF   x3B,F
281C:  BNZ   2872
281E:  MOVF   x3A,W
2820:  SUBLW  3B
2822:  BNC   2872
2824:  MOVF   x35,F
2826:  BNZ   2836
2828:  MOVF   x34,F
282A:  BNZ   2836
282C:  MOVF   x33,F
282E:  BNZ   2836
2830:  MOVF   x32,W
2832:  SUBLW  64
2834:  BC    2872
2836:  MOVF   x39,F
2838:  BNZ   2848
283A:  MOVF   x38,F
283C:  BNZ   2848
283E:  MOVF   x37,F
2840:  BNZ   2848
2842:  MOVF   x36,W
2844:  SUBLW  64
2846:  BC    2872
2848:  MOVF   x31,F
284A:  BNZ   285A
284C:  MOVF   x30,F
284E:  BNZ   285A
2850:  MOVF   x2F,F
2852:  BNZ   285A
2854:  MOVF   x2E,W
2856:  SUBLW  64
2858:  BC    2872
285A:  MOVF   x41,F
285C:  BNZ   286C
285E:  MOVF   x40,F
2860:  BNZ   286C
2862:  MOVF   x3F,F
2864:  BNZ   286C
2866:  MOVF   x3E,W
2868:  SUBLW  64
286A:  BC    2872
286C:  MOVLW  03
286E:  MOVWF  01
2870:  BRA    299A
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2872:  MOVF   x41,F
2874:  BNZ   2884
2876:  MOVF   x40,F
2878:  BNZ   2884
287A:  MOVF   x3F,F
287C:  BNZ   2884
287E:  MOVF   x3E,W
2880:  SUBLW  05
2882:  BC    28E4
2884:  MOVF   x41,F
2886:  BNZ   28E4
2888:  MOVF   x40,F
288A:  BNZ   28E4
288C:  MOVF   x3F,F
288E:  BNZ   28E4
2890:  MOVF   x3E,W
2892:  SUBLW  3B
2894:  BNC   28E4
2896:  MOVF   x35,F
2898:  BNZ   28A8
289A:  MOVF   x34,F
289C:  BNZ   28A8
289E:  MOVF   x33,F
28A0:  BNZ   28A8
28A2:  MOVF   x32,W
28A4:  SUBLW  64
28A6:  BC    28E4
28A8:  MOVF   x39,F
28AA:  BNZ   28BA
28AC:  MOVF   x38,F
28AE:  BNZ   28BA
28B0:  MOVF   x37,F
28B2:  BNZ   28BA
28B4:  MOVF   x36,W
28B6:  SUBLW  64
28B8:  BC    28E4
28BA:  MOVF   x3D,F
28BC:  BNZ   28CC
28BE:  MOVF   x3C,F
28C0:  BNZ   28CC
28C2:  MOVF   x3B,F
28C4:  BNZ   28CC
28C6:  MOVF   x3A,W
28C8:  SUBLW  64
28CA:  BC    28E4
28CC:  MOVF   x31,F
28CE:  BNZ   28DE
28D0:  MOVF   x30,F
28D2:  BNZ   28DE
28D4:  MOVF   x2F,F
28D6:  BNZ   28DE
28D8:  MOVF   x2E,W
28DA:  SUBLW  64
28DC:  BC    28E4
28DE:  MOVLW  04
28E0:  MOVWF  01
28E2:  BRA    299A
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
28E4:  MOVF   x41,F
28E6:  BNZ   28F8
28E8:  MOVF   x40,F
28EA:  BNZ   28F8
28EC:  MOVF   x3F,F
28EE:  BNZ   28F8
28F0:  MOVF   x3E,W
28F2:  SUBLW  C8
28F4:  BTFSC  FD8.0
28F6:  BRA    2996
28F8:  MOVF   x31,F
28FA:  BTFSS  FD8.2
28FC:  BRA    2996
28FE:  MOVF   x30,F
2900:  BTFSS  FD8.2
2902:  BRA    2996
2904:  MOVF   x2F,F
2906:  BTFSS  FD8.2
2908:  BRA    2996
290A:  MOVF   x2E,W
290C:  SUBLW  B3
290E:  BNC   2996
2910:  MOVF   x31,F
2912:  BNZ   2922
2914:  MOVF   x30,F
2916:  BNZ   2922
2918:  MOVF   x2F,F
291A:  BNZ   2922
291C:  MOVF   x2E,W
291E:  SUBLW  64
2920:  BC    2996
2922:  MOVF   x35,F
2924:  BNZ   2996
2926:  MOVF   x34,F
2928:  BNZ   2996
292A:  MOVF   x33,F
292C:  BNZ   2996
292E:  MOVF   x32,W
2930:  SUBLW  B3
2932:  BNC   2996
2934:  MOVF   x35,F
2936:  BNZ   2946
2938:  MOVF   x34,F
293A:  BNZ   2946
293C:  MOVF   x33,F
293E:  BNZ   2946
2940:  MOVF   x32,W
2942:  SUBLW  64
2944:  BC    2996
2946:  MOVF   x39,F
2948:  BNZ   2996
294A:  MOVF   x38,F
294C:  BNZ   2996
294E:  MOVF   x37,F
2950:  BNZ   2996
2952:  MOVF   x36,W
2954:  SUBLW  B3
2956:  BNC   2996
2958:  MOVF   x39,F
295A:  BNZ   296A
295C:  MOVF   x38,F
295E:  BNZ   296A
2960:  MOVF   x37,F
2962:  BNZ   296A
2964:  MOVF   x36,W
2966:  SUBLW  64
2968:  BC    2996
296A:  MOVF   x3D,F
296C:  BNZ   2996
296E:  MOVF   x3C,F
2970:  BNZ   2996
2972:  MOVF   x3B,F
2974:  BNZ   2996
2976:  MOVF   x3A,W
2978:  SUBLW  B3
297A:  BNC   2996
297C:  MOVF   x3D,F
297E:  BNZ   298E
2980:  MOVF   x3C,F
2982:  BNZ   298E
2984:  MOVF   x3B,F
2986:  BNZ   298E
2988:  MOVF   x3A,W
298A:  SUBLW  64
298C:  BC    2996
298E:  MOVLW  04
2990:  MOVWF  01
2992:  BRA    299A
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2994:  BRA    299A
2996:  MOVLW  FF
2998:  MOVWF  01
.................... } 
299A:  MOVLB  0
299C:  GOTO   31E6 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
29A0:  MOVLB  8
29A2:  CLRF   x31
29A4:  CLRF   x30
29A6:  CLRF   x2F
29A8:  CLRF   x2E
29AA:  CLRF   x35
29AC:  CLRF   x34
29AE:  CLRF   x33
29B0:  CLRF   x32
29B2:  CLRF   x39
29B4:  CLRF   x38
29B6:  CLRF   x37
29B8:  CLRF   x36
29BA:  CLRF   x3D
29BC:  CLRF   x3C
29BE:  CLRF   x3B
29C0:  CLRF   x3A
29C2:  CLRF   x41
29C4:  CLRF   x40
29C6:  CLRF   x3F
29C8:  CLRF   x3E
29CA:  CLRF   x45
29CC:  CLRF   x44
29CE:  CLRF   x43
29D0:  CLRF   x42
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
29D2:  CLRF   x2D
29D4:  CLRF   x2C
29D6:  MOVF   x2D,W
29D8:  SUBLW  01
29DA:  BNC   2A7A
29DC:  BNZ   29E4
29DE:  MOVF   x2C,W
29E0:  SUBLW  F3
29E2:  BNC   2A7A
....................    { 
....................       col_0=read_col(0)+col_0; 
29E4:  CLRF   x46
29E6:  MOVLB  0
29E8:  CALL   2112
29EC:  MOVF   01,W
29EE:  MOVLB  8
29F0:  ADDWF  x2E,F
29F2:  MOVLW  00
29F4:  ADDWFC x2F,F
29F6:  ADDWFC x30,F
29F8:  ADDWFC x31,F
....................       col_1=read_col(1)+col_1; 
29FA:  MOVLW  01
29FC:  MOVWF  x46
29FE:  MOVLB  0
2A00:  CALL   2112
2A04:  MOVF   01,W
2A06:  MOVLB  8
2A08:  ADDWF  x32,F
2A0A:  MOVLW  00
2A0C:  ADDWFC x33,F
2A0E:  ADDWFC x34,F
2A10:  ADDWFC x35,F
....................       col_2=read_col(2)+col_2; 
2A12:  MOVLW  02
2A14:  MOVWF  x46
2A16:  MOVLB  0
2A18:  CALL   2112
2A1C:  MOVF   01,W
2A1E:  MOVLB  8
2A20:  ADDWF  x36,F
2A22:  MOVLW  00
2A24:  ADDWFC x37,F
2A26:  ADDWFC x38,F
2A28:  ADDWFC x39,F
....................       col_3=read_col(3)+col_3; 
2A2A:  MOVLW  03
2A2C:  MOVWF  x46
2A2E:  MOVLB  0
2A30:  CALL   2112
2A34:  MOVF   01,W
2A36:  MOVLB  8
2A38:  ADDWF  x3A,F
2A3A:  MOVLW  00
2A3C:  ADDWFC x3B,F
2A3E:  ADDWFC x3C,F
2A40:  ADDWFC x3D,F
....................       col_4=read_col(4)+col_4; 
2A42:  MOVLW  04
2A44:  MOVWF  x46
2A46:  MOVLB  0
2A48:  CALL   2112
2A4C:  MOVF   01,W
2A4E:  MOVLB  8
2A50:  ADDWF  x3E,F
2A52:  MOVLW  00
2A54:  ADDWFC x3F,F
2A56:  ADDWFC x40,F
2A58:  ADDWFC x41,F
....................       col_5=read_col(5)+col_5; 
2A5A:  MOVLW  05
2A5C:  MOVWF  x46
2A5E:  MOVLB  0
2A60:  CALL   2112
2A64:  MOVF   01,W
2A66:  MOVLB  8
2A68:  ADDWF  x42,F
2A6A:  MOVLW  00
2A6C:  ADDWFC x43,F
2A6E:  ADDWFC x44,F
2A70:  ADDWFC x45,F
....................    } 
2A72:  INCF   x2C,F
2A74:  BTFSC  FD8.2
2A76:  INCF   x2D,F
2A78:  BRA    29D6
....................    col_0=col_0/500; 
2A7A:  BCF    FD8.1
2A7C:  MOVFF  831,855
2A80:  MOVFF  830,854
2A84:  MOVFF  82F,853
2A88:  MOVFF  82E,852
2A8C:  CLRF   x59
2A8E:  CLRF   x58
2A90:  MOVLW  01
2A92:  MOVWF  x57
2A94:  MOVLW  F4
2A96:  MOVWF  x56
2A98:  MOVLB  0
2A9A:  CALL   2220
2A9E:  MOVFF  03,831
2AA2:  MOVFF  02,830
2AA6:  MOVFF  01,82F
2AAA:  MOVFF  00,82E
....................    col_1=col_1/500; 
2AAE:  BCF    FD8.1
2AB0:  MOVFF  835,855
2AB4:  MOVFF  834,854
2AB8:  MOVFF  833,853
2ABC:  MOVFF  832,852
2AC0:  MOVLB  8
2AC2:  CLRF   x59
2AC4:  CLRF   x58
2AC6:  MOVLW  01
2AC8:  MOVWF  x57
2ACA:  MOVLW  F4
2ACC:  MOVWF  x56
2ACE:  MOVLB  0
2AD0:  CALL   2220
2AD4:  MOVFF  03,835
2AD8:  MOVFF  02,834
2ADC:  MOVFF  01,833
2AE0:  MOVFF  00,832
....................    col_2=col_2/500; 
2AE4:  BCF    FD8.1
2AE6:  MOVFF  839,855
2AEA:  MOVFF  838,854
2AEE:  MOVFF  837,853
2AF2:  MOVFF  836,852
2AF6:  MOVLB  8
2AF8:  CLRF   x59
2AFA:  CLRF   x58
2AFC:  MOVLW  01
2AFE:  MOVWF  x57
2B00:  MOVLW  F4
2B02:  MOVWF  x56
2B04:  MOVLB  0
2B06:  CALL   2220
2B0A:  MOVFF  03,839
2B0E:  MOVFF  02,838
2B12:  MOVFF  01,837
2B16:  MOVFF  00,836
....................    col_3=col_3/500; 
2B1A:  BCF    FD8.1
2B1C:  MOVFF  83D,855
2B20:  MOVFF  83C,854
2B24:  MOVFF  83B,853
2B28:  MOVFF  83A,852
2B2C:  MOVLB  8
2B2E:  CLRF   x59
2B30:  CLRF   x58
2B32:  MOVLW  01
2B34:  MOVWF  x57
2B36:  MOVLW  F4
2B38:  MOVWF  x56
2B3A:  MOVLB  0
2B3C:  CALL   2220
2B40:  MOVFF  03,83D
2B44:  MOVFF  02,83C
2B48:  MOVFF  01,83B
2B4C:  MOVFF  00,83A
....................    col_4=col_4/500; 
2B50:  BCF    FD8.1
2B52:  MOVFF  841,855
2B56:  MOVFF  840,854
2B5A:  MOVFF  83F,853
2B5E:  MOVFF  83E,852
2B62:  MOVLB  8
2B64:  CLRF   x59
2B66:  CLRF   x58
2B68:  MOVLW  01
2B6A:  MOVWF  x57
2B6C:  MOVLW  F4
2B6E:  MOVWF  x56
2B70:  MOVLB  0
2B72:  CALL   2220
2B76:  MOVFF  03,841
2B7A:  MOVFF  02,840
2B7E:  MOVFF  01,83F
2B82:  MOVFF  00,83E
....................    col_5=col_5/500; 
2B86:  BCF    FD8.1
2B88:  MOVFF  845,855
2B8C:  MOVFF  844,854
2B90:  MOVFF  843,853
2B94:  MOVFF  842,852
2B98:  MOVLB  8
2B9A:  CLRF   x59
2B9C:  CLRF   x58
2B9E:  MOVLW  01
2BA0:  MOVWF  x57
2BA2:  MOVLW  F4
2BA4:  MOVWF  x56
2BA6:  MOVLB  0
2BA8:  CALL   2220
2BAC:  MOVFF  03,845
2BB0:  MOVFF  02,844
2BB4:  MOVFF  01,843
2BB8:  MOVFF  00,842
....................    if(keydebug_en) 
2BBC:  MOVLB  1
2BBE:  MOVF   x40,F
2BC0:  BTFSC  FD8.2
2BC2:  BRA    2D8C
....................    { 
....................       fprintf(COM2,"\r\n");      
2BC4:  MOVLW  0D
2BC6:  MOVLB  8
2BC8:  MOVWF  x52
2BCA:  MOVLB  0
2BCC:  CALL   15C0
2BD0:  MOVLW  0A
2BD2:  MOVLB  8
2BD4:  MOVWF  x52
2BD6:  MOVLB  0
2BD8:  CALL   15C0
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2BDC:  MOVLW  02
2BDE:  MOVWF  FF6
2BE0:  MOVLW  05
2BE2:  MOVWF  FF7
2BE4:  MOVLW  07
2BE6:  MOVLB  8
2BE8:  MOVWF  x46
2BEA:  MOVLB  0
2BEC:  CALL   1606
2BF0:  MOVLW  41
2BF2:  MOVWF  FE9
2BF4:  MOVFF  831,849
2BF8:  MOVFF  830,848
2BFC:  MOVFF  82F,847
2C00:  MOVFF  82E,846
2C04:  CALL   22B4
2C08:  MOVLW  0D
2C0A:  MOVLB  8
2C0C:  MOVWF  x52
2C0E:  MOVLB  0
2C10:  CALL   15C0
2C14:  MOVLW  0A
2C16:  MOVLB  8
2C18:  MOVWF  x52
2C1A:  MOVLB  0
2C1C:  CALL   15C0
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2C20:  MOVLW  10
2C22:  MOVWF  FF6
2C24:  MOVLW  05
2C26:  MOVWF  FF7
2C28:  MOVLW  07
2C2A:  MOVLB  8
2C2C:  MOVWF  x46
2C2E:  MOVLB  0
2C30:  CALL   1606
2C34:  MOVLW  41
2C36:  MOVWF  FE9
2C38:  MOVFF  835,849
2C3C:  MOVFF  834,848
2C40:  MOVFF  833,847
2C44:  MOVFF  832,846
2C48:  CALL   22B4
2C4C:  MOVLW  0D
2C4E:  MOVLB  8
2C50:  MOVWF  x52
2C52:  MOVLB  0
2C54:  CALL   15C0
2C58:  MOVLW  0A
2C5A:  MOVLB  8
2C5C:  MOVWF  x52
2C5E:  MOVLB  0
2C60:  CALL   15C0
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2C64:  MOVLW  1E
2C66:  MOVWF  FF6
2C68:  MOVLW  05
2C6A:  MOVWF  FF7
2C6C:  MOVLW  07
2C6E:  MOVLB  8
2C70:  MOVWF  x46
2C72:  MOVLB  0
2C74:  CALL   1606
2C78:  MOVLW  41
2C7A:  MOVWF  FE9
2C7C:  MOVFF  839,849
2C80:  MOVFF  838,848
2C84:  MOVFF  837,847
2C88:  MOVFF  836,846
2C8C:  CALL   22B4
2C90:  MOVLW  0D
2C92:  MOVLB  8
2C94:  MOVWF  x52
2C96:  MOVLB  0
2C98:  CALL   15C0
2C9C:  MOVLW  0A
2C9E:  MOVLB  8
2CA0:  MOVWF  x52
2CA2:  MOVLB  0
2CA4:  CALL   15C0
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2CA8:  MOVLW  2C
2CAA:  MOVWF  FF6
2CAC:  MOVLW  05
2CAE:  MOVWF  FF7
2CB0:  MOVLW  07
2CB2:  MOVLB  8
2CB4:  MOVWF  x46
2CB6:  MOVLB  0
2CB8:  CALL   1606
2CBC:  MOVLW  41
2CBE:  MOVWF  FE9
2CC0:  MOVFF  83D,849
2CC4:  MOVFF  83C,848
2CC8:  MOVFF  83B,847
2CCC:  MOVFF  83A,846
2CD0:  CALL   22B4
2CD4:  MOVLW  0D
2CD6:  MOVLB  8
2CD8:  MOVWF  x52
2CDA:  MOVLB  0
2CDC:  CALL   15C0
2CE0:  MOVLW  0A
2CE2:  MOVLB  8
2CE4:  MOVWF  x52
2CE6:  MOVLB  0
2CE8:  CALL   15C0
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2CEC:  MOVLW  3A
2CEE:  MOVWF  FF6
2CF0:  MOVLW  05
2CF2:  MOVWF  FF7
2CF4:  MOVLW  07
2CF6:  MOVLB  8
2CF8:  MOVWF  x46
2CFA:  MOVLB  0
2CFC:  CALL   1606
2D00:  MOVLW  41
2D02:  MOVWF  FE9
2D04:  MOVFF  841,849
2D08:  MOVFF  840,848
2D0C:  MOVFF  83F,847
2D10:  MOVFF  83E,846
2D14:  CALL   22B4
2D18:  MOVLW  0D
2D1A:  MOVLB  8
2D1C:  MOVWF  x52
2D1E:  MOVLB  0
2D20:  CALL   15C0
2D24:  MOVLW  0A
2D26:  MOVLB  8
2D28:  MOVWF  x52
2D2A:  MOVLB  0
2D2C:  CALL   15C0
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
2D30:  MOVLW  48
2D32:  MOVWF  FF6
2D34:  MOVLW  05
2D36:  MOVWF  FF7
2D38:  MOVLW  07
2D3A:  MOVLB  8
2D3C:  MOVWF  x46
2D3E:  MOVLB  0
2D40:  CALL   1606
2D44:  MOVLW  41
2D46:  MOVWF  FE9
2D48:  MOVFF  845,849
2D4C:  MOVFF  844,848
2D50:  MOVFF  843,847
2D54:  MOVFF  842,846
2D58:  CALL   22B4
2D5C:  MOVLW  0D
2D5E:  MOVLB  8
2D60:  MOVWF  x52
2D62:  MOVLB  0
2D64:  CALL   15C0
2D68:  MOVLW  0A
2D6A:  MOVLB  8
2D6C:  MOVWF  x52
2D6E:  MOVLB  0
2D70:  CALL   15C0
....................       fprintf(COM2,"\r\n"); 
2D74:  MOVLW  0D
2D76:  MOVLB  8
2D78:  MOVWF  x52
2D7A:  MOVLB  0
2D7C:  CALL   15C0
2D80:  MOVLW  0A
2D82:  MOVLB  8
2D84:  MOVWF  x52
2D86:  MOVLB  0
2D88:  CALL   15C0
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
2D8C:  MOVLB  8
2D8E:  MOVF   x31,F
2D90:  BNZ   2DA0
2D92:  MOVF   x30,F
2D94:  BNZ   2DA0
2D96:  MOVF   x2F,F
2D98:  BNZ   2DA0
2D9A:  MOVF   x2E,W
2D9C:  SUBLW  05
2D9E:  BC    2E12
2DA0:  MOVF   x31,F
2DA2:  BNZ   2E12
2DA4:  MOVF   x30,F
2DA6:  BNZ   2E12
2DA8:  MOVF   x2F,F
2DAA:  BNZ   2E12
2DAC:  MOVF   x2E,W
2DAE:  SUBLW  3B
2DB0:  BNC   2E12
2DB2:  MOVF   x35,F
2DB4:  BNZ   2DC4
2DB6:  MOVF   x34,F
2DB8:  BNZ   2DC4
2DBA:  MOVF   x33,F
2DBC:  BNZ   2DC4
2DBE:  MOVF   x32,W
2DC0:  SUBLW  64
2DC2:  BC    2E12
2DC4:  MOVF   x39,F
2DC6:  BNZ   2DD6
2DC8:  MOVF   x38,F
2DCA:  BNZ   2DD6
2DCC:  MOVF   x37,F
2DCE:  BNZ   2DD6
2DD0:  MOVF   x36,W
2DD2:  SUBLW  64
2DD4:  BC    2E12
2DD6:  MOVF   x3D,F
2DD8:  BNZ   2DE8
2DDA:  MOVF   x3C,F
2DDC:  BNZ   2DE8
2DDE:  MOVF   x3B,F
2DE0:  BNZ   2DE8
2DE2:  MOVF   x3A,W
2DE4:  SUBLW  64
2DE6:  BC    2E12
2DE8:  MOVF   x41,F
2DEA:  BNZ   2DFA
2DEC:  MOVF   x40,F
2DEE:  BNZ   2DFA
2DF0:  MOVF   x3F,F
2DF2:  BNZ   2DFA
2DF4:  MOVF   x3E,W
2DF6:  SUBLW  64
2DF8:  BC    2E12
2DFA:  MOVF   x45,F
2DFC:  BNZ   2E0C
2DFE:  MOVF   x44,F
2E00:  BNZ   2E0C
2E02:  MOVF   x43,F
2E04:  BNZ   2E0C
2E06:  MOVF   x42,W
2E08:  SUBLW  64
2E0A:  BC    2E12
2E0C:  MOVLW  00
2E0E:  MOVWF  01
2E10:  BRA    318A
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
2E12:  MOVF   x35,F
2E14:  BNZ   2E24
2E16:  MOVF   x34,F
2E18:  BNZ   2E24
2E1A:  MOVF   x33,F
2E1C:  BNZ   2E24
2E1E:  MOVF   x32,W
2E20:  SUBLW  05
2E22:  BC    2E96
2E24:  MOVF   x35,F
2E26:  BNZ   2E96
2E28:  MOVF   x34,F
2E2A:  BNZ   2E96
2E2C:  MOVF   x33,F
2E2E:  BNZ   2E96
2E30:  MOVF   x32,W
2E32:  SUBLW  3B
2E34:  BNC   2E96
2E36:  MOVF   x31,F
2E38:  BNZ   2E48
2E3A:  MOVF   x30,F
2E3C:  BNZ   2E48
2E3E:  MOVF   x2F,F
2E40:  BNZ   2E48
2E42:  MOVF   x2E,W
2E44:  SUBLW  64
2E46:  BC    2E96
2E48:  MOVF   x39,F
2E4A:  BNZ   2E5A
2E4C:  MOVF   x38,F
2E4E:  BNZ   2E5A
2E50:  MOVF   x37,F
2E52:  BNZ   2E5A
2E54:  MOVF   x36,W
2E56:  SUBLW  64
2E58:  BC    2E96
2E5A:  MOVF   x3D,F
2E5C:  BNZ   2E6C
2E5E:  MOVF   x3C,F
2E60:  BNZ   2E6C
2E62:  MOVF   x3B,F
2E64:  BNZ   2E6C
2E66:  MOVF   x3A,W
2E68:  SUBLW  64
2E6A:  BC    2E96
2E6C:  MOVF   x41,F
2E6E:  BNZ   2E7E
2E70:  MOVF   x40,F
2E72:  BNZ   2E7E
2E74:  MOVF   x3F,F
2E76:  BNZ   2E7E
2E78:  MOVF   x3E,W
2E7A:  SUBLW  64
2E7C:  BC    2E96
2E7E:  MOVF   x45,F
2E80:  BNZ   2E90
2E82:  MOVF   x44,F
2E84:  BNZ   2E90
2E86:  MOVF   x43,F
2E88:  BNZ   2E90
2E8A:  MOVF   x42,W
2E8C:  SUBLW  64
2E8E:  BC    2E96
2E90:  MOVLW  01
2E92:  MOVWF  01
2E94:  BRA    318A
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
2E96:  MOVF   x39,F
2E98:  BNZ   2EA8
2E9A:  MOVF   x38,F
2E9C:  BNZ   2EA8
2E9E:  MOVF   x37,F
2EA0:  BNZ   2EA8
2EA2:  MOVF   x36,W
2EA4:  SUBLW  05
2EA6:  BC    2F1A
2EA8:  MOVF   x39,F
2EAA:  BNZ   2F1A
2EAC:  MOVF   x38,F
2EAE:  BNZ   2F1A
2EB0:  MOVF   x37,F
2EB2:  BNZ   2F1A
2EB4:  MOVF   x36,W
2EB6:  SUBLW  3B
2EB8:  BNC   2F1A
2EBA:  MOVF   x35,F
2EBC:  BNZ   2ECC
2EBE:  MOVF   x34,F
2EC0:  BNZ   2ECC
2EC2:  MOVF   x33,F
2EC4:  BNZ   2ECC
2EC6:  MOVF   x32,W
2EC8:  SUBLW  64
2ECA:  BC    2F1A
2ECC:  MOVF   x31,F
2ECE:  BNZ   2EDE
2ED0:  MOVF   x30,F
2ED2:  BNZ   2EDE
2ED4:  MOVF   x2F,F
2ED6:  BNZ   2EDE
2ED8:  MOVF   x2E,W
2EDA:  SUBLW  64
2EDC:  BC    2F1A
2EDE:  MOVF   x3D,F
2EE0:  BNZ   2EF0
2EE2:  MOVF   x3C,F
2EE4:  BNZ   2EF0
2EE6:  MOVF   x3B,F
2EE8:  BNZ   2EF0
2EEA:  MOVF   x3A,W
2EEC:  SUBLW  64
2EEE:  BC    2F1A
2EF0:  MOVF   x41,F
2EF2:  BNZ   2F02
2EF4:  MOVF   x40,F
2EF6:  BNZ   2F02
2EF8:  MOVF   x3F,F
2EFA:  BNZ   2F02
2EFC:  MOVF   x3E,W
2EFE:  SUBLW  64
2F00:  BC    2F1A
2F02:  MOVF   x45,F
2F04:  BNZ   2F14
2F06:  MOVF   x44,F
2F08:  BNZ   2F14
2F0A:  MOVF   x43,F
2F0C:  BNZ   2F14
2F0E:  MOVF   x42,W
2F10:  SUBLW  64
2F12:  BC    2F1A
2F14:  MOVLW  02
2F16:  MOVWF  01
2F18:  BRA    318A
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
2F1A:  MOVF   x3D,F
2F1C:  BNZ   2F2C
2F1E:  MOVF   x3C,F
2F20:  BNZ   2F2C
2F22:  MOVF   x3B,F
2F24:  BNZ   2F2C
2F26:  MOVF   x3A,W
2F28:  SUBLW  05
2F2A:  BC    2F9E
2F2C:  MOVF   x3D,F
2F2E:  BNZ   2F9E
2F30:  MOVF   x3C,F
2F32:  BNZ   2F9E
2F34:  MOVF   x3B,F
2F36:  BNZ   2F9E
2F38:  MOVF   x3A,W
2F3A:  SUBLW  3B
2F3C:  BNC   2F9E
2F3E:  MOVF   x35,F
2F40:  BNZ   2F50
2F42:  MOVF   x34,F
2F44:  BNZ   2F50
2F46:  MOVF   x33,F
2F48:  BNZ   2F50
2F4A:  MOVF   x32,W
2F4C:  SUBLW  64
2F4E:  BC    2F9E
2F50:  MOVF   x39,F
2F52:  BNZ   2F62
2F54:  MOVF   x38,F
2F56:  BNZ   2F62
2F58:  MOVF   x37,F
2F5A:  BNZ   2F62
2F5C:  MOVF   x36,W
2F5E:  SUBLW  64
2F60:  BC    2F9E
2F62:  MOVF   x31,F
2F64:  BNZ   2F74
2F66:  MOVF   x30,F
2F68:  BNZ   2F74
2F6A:  MOVF   x2F,F
2F6C:  BNZ   2F74
2F6E:  MOVF   x2E,W
2F70:  SUBLW  64
2F72:  BC    2F9E
2F74:  MOVF   x41,F
2F76:  BNZ   2F86
2F78:  MOVF   x40,F
2F7A:  BNZ   2F86
2F7C:  MOVF   x3F,F
2F7E:  BNZ   2F86
2F80:  MOVF   x3E,W
2F82:  SUBLW  64
2F84:  BC    2F9E
2F86:  MOVF   x45,F
2F88:  BNZ   2F98
2F8A:  MOVF   x44,F
2F8C:  BNZ   2F98
2F8E:  MOVF   x43,F
2F90:  BNZ   2F98
2F92:  MOVF   x42,W
2F94:  SUBLW  64
2F96:  BC    2F9E
2F98:  MOVLW  03
2F9A:  MOVWF  01
2F9C:  BRA    318A
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
2F9E:  MOVF   x41,F
2FA0:  BNZ   2FB0
2FA2:  MOVF   x40,F
2FA4:  BNZ   2FB0
2FA6:  MOVF   x3F,F
2FA8:  BNZ   2FB0
2FAA:  MOVF   x3E,W
2FAC:  SUBLW  05
2FAE:  BC    3022
2FB0:  MOVF   x41,F
2FB2:  BNZ   3022
2FB4:  MOVF   x40,F
2FB6:  BNZ   3022
2FB8:  MOVF   x3F,F
2FBA:  BNZ   3022
2FBC:  MOVF   x3E,W
2FBE:  SUBLW  3B
2FC0:  BNC   3022
2FC2:  MOVF   x35,F
2FC4:  BNZ   2FD4
2FC6:  MOVF   x34,F
2FC8:  BNZ   2FD4
2FCA:  MOVF   x33,F
2FCC:  BNZ   2FD4
2FCE:  MOVF   x32,W
2FD0:  SUBLW  64
2FD2:  BC    3022
2FD4:  MOVF   x39,F
2FD6:  BNZ   2FE6
2FD8:  MOVF   x38,F
2FDA:  BNZ   2FE6
2FDC:  MOVF   x37,F
2FDE:  BNZ   2FE6
2FE0:  MOVF   x36,W
2FE2:  SUBLW  64
2FE4:  BC    3022
2FE6:  MOVF   x3D,F
2FE8:  BNZ   2FF8
2FEA:  MOVF   x3C,F
2FEC:  BNZ   2FF8
2FEE:  MOVF   x3B,F
2FF0:  BNZ   2FF8
2FF2:  MOVF   x3A,W
2FF4:  SUBLW  64
2FF6:  BC    3022
2FF8:  MOVF   x31,F
2FFA:  BNZ   300A
2FFC:  MOVF   x30,F
2FFE:  BNZ   300A
3000:  MOVF   x2F,F
3002:  BNZ   300A
3004:  MOVF   x2E,W
3006:  SUBLW  64
3008:  BC    3022
300A:  MOVF   x45,F
300C:  BNZ   301C
300E:  MOVF   x44,F
3010:  BNZ   301C
3012:  MOVF   x43,F
3014:  BNZ   301C
3016:  MOVF   x42,W
3018:  SUBLW  64
301A:  BC    3022
301C:  MOVLW  04
301E:  MOVWF  01
3020:  BRA    318A
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
3022:  MOVF   x45,F
3024:  BNZ   3034
3026:  MOVF   x44,F
3028:  BNZ   3034
302A:  MOVF   x43,F
302C:  BNZ   3034
302E:  MOVF   x42,W
3030:  SUBLW  05
3032:  BC    30A6
3034:  MOVF   x45,F
3036:  BNZ   30A6
3038:  MOVF   x44,F
303A:  BNZ   30A6
303C:  MOVF   x43,F
303E:  BNZ   30A6
3040:  MOVF   x42,W
3042:  SUBLW  3B
3044:  BNC   30A6
3046:  MOVF   x35,F
3048:  BNZ   3058
304A:  MOVF   x34,F
304C:  BNZ   3058
304E:  MOVF   x33,F
3050:  BNZ   3058
3052:  MOVF   x32,W
3054:  SUBLW  64
3056:  BC    30A6
3058:  MOVF   x39,F
305A:  BNZ   306A
305C:  MOVF   x38,F
305E:  BNZ   306A
3060:  MOVF   x37,F
3062:  BNZ   306A
3064:  MOVF   x36,W
3066:  SUBLW  64
3068:  BC    30A6
306A:  MOVF   x3D,F
306C:  BNZ   307C
306E:  MOVF   x3C,F
3070:  BNZ   307C
3072:  MOVF   x3B,F
3074:  BNZ   307C
3076:  MOVF   x3A,W
3078:  SUBLW  64
307A:  BC    30A6
307C:  MOVF   x41,F
307E:  BNZ   308E
3080:  MOVF   x40,F
3082:  BNZ   308E
3084:  MOVF   x3F,F
3086:  BNZ   308E
3088:  MOVF   x3E,W
308A:  SUBLW  64
308C:  BC    30A6
308E:  MOVF   x31,F
3090:  BNZ   30A0
3092:  MOVF   x30,F
3094:  BNZ   30A0
3096:  MOVF   x2F,F
3098:  BNZ   30A0
309A:  MOVF   x2E,W
309C:  SUBLW  64
309E:  BC    30A6
30A0:  MOVLW  05
30A2:  MOVWF  01
30A4:  BRA    318A
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
30A6:  MOVF   x45,F
30A8:  BNZ   30BA
30AA:  MOVF   x44,F
30AC:  BNZ   30BA
30AE:  MOVF   x43,F
30B0:  BNZ   30BA
30B2:  MOVF   x42,W
30B4:  SUBLW  C8
30B6:  BTFSC  FD8.0
30B8:  BRA    3186
30BA:  MOVF   x31,F
30BC:  BTFSS  FD8.2
30BE:  BRA    3186
30C0:  MOVF   x30,F
30C2:  BTFSS  FD8.2
30C4:  BRA    3186
30C6:  MOVF   x2F,F
30C8:  BTFSS  FD8.2
30CA:  BRA    3186
30CC:  MOVF   x2E,W
30CE:  SUBLW  B3
30D0:  BTFSS  FD8.0
30D2:  BRA    3186
30D4:  MOVF   x31,F
30D6:  BNZ   30E8
30D8:  MOVF   x30,F
30DA:  BNZ   30E8
30DC:  MOVF   x2F,F
30DE:  BNZ   30E8
30E0:  MOVF   x2E,W
30E2:  SUBLW  64
30E4:  BTFSC  FD8.0
30E6:  BRA    3186
30E8:  MOVF   x35,F
30EA:  BTFSS  FD8.2
30EC:  BRA    3186
30EE:  MOVF   x34,F
30F0:  BTFSS  FD8.2
30F2:  BRA    3186
30F4:  MOVF   x33,F
30F6:  BTFSS  FD8.2
30F8:  BRA    3186
30FA:  MOVF   x32,W
30FC:  SUBLW  B3
30FE:  BNC   3186
3100:  MOVF   x35,F
3102:  BNZ   3112
3104:  MOVF   x34,F
3106:  BNZ   3112
3108:  MOVF   x33,F
310A:  BNZ   3112
310C:  MOVF   x32,W
310E:  SUBLW  64
3110:  BC    3186
3112:  MOVF   x39,F
3114:  BNZ   3186
3116:  MOVF   x38,F
3118:  BNZ   3186
311A:  MOVF   x37,F
311C:  BNZ   3186
311E:  MOVF   x36,W
3120:  SUBLW  B3
3122:  BNC   3186
3124:  MOVF   x39,F
3126:  BNZ   3136
3128:  MOVF   x38,F
312A:  BNZ   3136
312C:  MOVF   x37,F
312E:  BNZ   3136
3130:  MOVF   x36,W
3132:  SUBLW  64
3134:  BC    3186
3136:  MOVF   x3D,F
3138:  BNZ   3186
313A:  MOVF   x3C,F
313C:  BNZ   3186
313E:  MOVF   x3B,F
3140:  BNZ   3186
3142:  MOVF   x3A,W
3144:  SUBLW  B3
3146:  BNC   3186
3148:  MOVF   x3D,F
314A:  BNZ   315A
314C:  MOVF   x3C,F
314E:  BNZ   315A
3150:  MOVF   x3B,F
3152:  BNZ   315A
3154:  MOVF   x3A,W
3156:  SUBLW  64
3158:  BC    3186
315A:  MOVF   x41,F
315C:  BNZ   3186
315E:  MOVF   x40,F
3160:  BNZ   3186
3162:  MOVF   x3F,F
3164:  BNZ   3186
3166:  MOVF   x3E,W
3168:  SUBLW  B3
316A:  BNC   3186
316C:  MOVF   x41,F
316E:  BNZ   317E
3170:  MOVF   x40,F
3172:  BNZ   317E
3174:  MOVF   x3F,F
3176:  BNZ   317E
3178:  MOVF   x3E,W
317A:  SUBLW  64
317C:  BC    3186
317E:  MOVLW  05
3180:  MOVWF  01
3182:  BRA    318A
....................    else return 0xff; 
3184:  BRA    318A
3186:  MOVLW  FF
3188:  MOVWF  01
.................... } 
318A:  MOVLB  0
318C:  GOTO   31F2 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
3190:  MOVLW  20
3192:  MOVLB  8
3194:  MOVWF  x2A
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
3196:  BSF    F93.4
3198:  BTFSS  F81.4
319A:  BRA    31AE
319C:  BSF    F93.5
319E:  BTFSS  F81.5
31A0:  BRA    31AE
31A2:  BSF    F93.6
31A4:  BTFSS  F81.6
31A6:  BRA    31AE
31A8:  BSF    F93.7
31AA:  BTFSC  F81.7
31AC:  BRA    3314
....................     { 
....................        if(input(ROW0)==0) 
31AE:  BSF    F93.4
31B0:  BTFSC  F81.4
31B2:  BRA    31B8
....................          row=0; 
31B4:  CLRF   x2B
....................        else if(input(ROW1)==0) 
31B6:  BRA    31DA
31B8:  BSF    F93.5
31BA:  BTFSC  F81.5
31BC:  BRA    31C4
....................          row=1; 
31BE:  MOVLW  01
31C0:  MOVWF  x2B
....................        else if(input(ROW2)==0) 
31C2:  BRA    31DA
31C4:  BSF    F93.6
31C6:  BTFSC  F81.6
31C8:  BRA    31D0
....................          row=2; 
31CA:  MOVLW  02
31CC:  MOVWF  x2B
....................        else if(input(ROW3)==0) 
31CE:  BRA    31DA
31D0:  BSF    F93.7
31D2:  BTFSC  F81.7
31D4:  BRA    31DA
....................          row=3;      
31D6:  MOVLW  03
31D8:  MOVWF  x2B
....................        if(type_KB==0)col=check_col(); 
31DA:  MOVLB  1
31DC:  MOVF   x45,F
31DE:  BNZ   31EC
31E0:  MOVLB  0
31E2:  GOTO   2374
31E6:  MOVFF  01,829
....................          else col=new_check_col(); 
31EA:  BRA    31F6
31EC:  MOVLB  0
31EE:  GOTO   29A0
31F2:  MOVFF  01,829
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
31F6:  MOVLB  8
31F8:  INCFSZ x29,W
31FA:  BRA    31FE
31FC:  BRA    32E4
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
31FE:  MOVLB  1
3200:  MOVF   x45,F
3202:  BNZ   322A
3204:  MOVLB  8
3206:  MOVF   x2B,W
3208:  MULLW  05
320A:  MOVF   FF3,W
320C:  CLRF   x2D
320E:  MOVWF  x2C
3210:  CLRF   03
3212:  MOVF   x29,W
3214:  ADDWF  x2C,W
3216:  MOVWF  01
3218:  MOVF   x2D,W
321A:  ADDWFC 03,F
321C:  MOVF   01,W
321E:  MOVLB  0
3220:  CALL   030A
3224:  MOVFF  FE8,82A
....................            else kchar =newKEYS[row][col]; 
3228:  BRA    324E
322A:  MOVLB  8
322C:  MOVF   x2B,W
322E:  MULLW  06
3230:  MOVF   FF3,W
3232:  CLRF   x2D
3234:  MOVWF  x2C
3236:  CLRF   03
3238:  MOVF   x29,W
323A:  ADDWF  x2C,W
323C:  MOVWF  01
323E:  MOVF   x2D,W
3240:  ADDWFC 03,F
3242:  MOVF   01,W
3244:  MOVLB  0
3246:  CALL   032E
324A:  MOVFF  FE8,82A
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
324E:  MOVLB  1
3250:  MOVF   x40,F
3252:  BNZ   32D6
....................             { 
....................               charac_timeout=0; 
3254:  MOVLB  0
3256:  CLRF   xFC
3258:  CLRF   xFB
....................                if(key_count_ms<wideofkeystore) 
325A:  MOVLB  1
325C:  MOVF   x43,W
325E:  SUBLW  0F
3260:  BNC   32D4
....................                { 
....................                    key_data[key_count_ms++]=kchar; 
3262:  MOVF   x43,W
3264:  INCF   x43,F
3266:  CLRF   03
3268:  ADDLW  46
326A:  MOVWF  FE9
326C:  MOVLW  01
326E:  ADDWFC 03,W
3270:  MOVWF  FEA
3272:  MOVFF  82A,FEF
....................                    fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
3276:  MOVLW  56
3278:  MOVWF  FF6
327A:  MOVLW  05
327C:  MOVWF  FF7
327E:  MOVLW  09
3280:  MOVLB  8
3282:  MOVWF  x46
3284:  MOVLB  0
3286:  CALL   1606
328A:  MOVFF  143,832
328E:  MOVLW  18
3290:  MOVLB  8
3292:  MOVWF  x33
3294:  MOVLB  0
3296:  CALL   1736
329A:  MOVLW  5D
329C:  MOVLB  8
329E:  MOVWF  x52
32A0:  MOVLB  0
32A2:  CALL   15C0
32A6:  MOVLW  20
32A8:  MOVLB  8
32AA:  MOVWF  x52
32AC:  MOVLB  0
32AE:  CALL   15C0
32B2:  MOVFF  82A,852
32B6:  CALL   15C0
32BA:  MOVLW  0D
32BC:  MOVLB  8
32BE:  MOVWF  x52
32C0:  MOVLB  0
32C2:  CALL   15C0
32C6:  MOVLW  0A
32C8:  MOVLB  8
32CA:  MOVWF  x52
32CC:  MOVLB  0
32CE:  CALL   15C0
32D2:  MOVLB  1
....................                } 
....................             } 
....................                else fputc(kchar,COM2); 
32D4:  BRA    32E2
32D6:  MOVFF  82A,852
32DA:  MOVLB  0
32DC:  CALL   15C0
32E0:  MOVLB  1
32E2:  MOVLB  8
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
32E4:  BSF    F93.4
32E6:  BTFSS  F81.4
32E8:  BRA    32E4
32EA:  BSF    F93.5
32EC:  BTFSS  F81.5
32EE:  BRA    32E4
32F0:  BSF    F93.6
32F2:  BTFSS  F81.6
32F4:  BRA    32E4
32F6:  BSF    F93.7
32F8:  BTFSS  F81.7
32FA:  BRA    32E4
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
32FC:  BSF    F93.4
32FE:  BTFSS  F81.4
3300:  BRA    32FC
3302:  BSF    F93.5
3304:  BTFSS  F81.5
3306:  BRA    32FC
3308:  BSF    F93.6
330A:  BTFSS  F81.6
330C:  BRA    32FC
330E:  BSF    F93.7
3310:  BTFSS  F81.7
3312:  BRA    32FC
....................     } 
....................   set_tris_a(0xff);     
3314:  MOVLW  FF
3316:  MOVWF  F92
....................   return(kchar); 
3318:  MOVFF  82A,01
.................... }//*/ 
331C:  MOVLB  0
331E:  RETURN 0
....................  
.................... //============================================ 
.................... void save_key_new() 
.................... { 
....................    int8 i,tempdata; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
3EE6:  MOVF   27,F
3EE8:  BTFSS  FD8.2
3EEA:  BRA    4098
3EEC:  MOVF   26,W
3EEE:  SUBLW  01
3EF0:  BTFSS  FD8.0
3EF2:  BRA    4098
3EF4:  BNZ   3F08
3EF6:  MOVF   25,W
3EF8:  SUBLW  FF
3EFA:  BTFSS  FD8.0
3EFC:  BRA    4098
3EFE:  BNZ   3F08
3F00:  MOVF   24,W
3F02:  SUBLW  FE
3F04:  BTFSS  FD8.0
3F06:  BRA    4098
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
3F08:  MOVLB  1
3F0A:  MOVF   x46,F
3F0C:  BNZ   3F14
3F0E:  MOVF   x43,F
3F10:  BTFSC  FD8.2
3F12:  BRA    4046
....................       { 
....................          temp=get_countcard(); 
3F14:  MOVLB  0
3F16:  CALL   34CC
3F1A:  MOVFF  02,82C
3F1E:  MOVFF  01,82B
....................          //fprintf(COM2," get_countcard=%lu\n\r",temp); 
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
3F22:  MOVLB  8
3F24:  RLCF   x2B,W
3F26:  MOVWF  x2D
3F28:  RLCF   x2C,W
3F2A:  MOVWF  x2E
3F2C:  RLCF   x2D,F
3F2E:  RLCF   x2E,F
3F30:  RLCF   x2D,F
3F32:  RLCF   x2E,F
3F34:  RLCF   x2D,F
3F36:  RLCF   x2E,F
3F38:  MOVLW  F0
3F3A:  ANDWF  x2D,F
3F3C:  MOVLW  0E
3F3E:  ADDWF  x2D,F
3F40:  MOVLW  C3
3F42:  ADDWFC x2E,F
3F44:  MOVLW  01
3F46:  MOVWF  x2F
3F48:  BCF    FD8.2
3F4A:  BTFSC  FD8.0
3F4C:  INCF   x2F,F
3F4E:  CLRF   x30
3F50:  MOVLW  01
3F52:  ADDWF  x2D,W
3F54:  MOVWF  00
3F56:  MOVLW  00
3F58:  ADDWFC x2E,W
3F5A:  MOVWF  01
3F5C:  MOVLW  00
3F5E:  ADDWFC x2F,W
3F60:  MOVWF  02
3F62:  MOVLW  00
3F64:  ADDWFC x30,W
3F66:  MOVWF  27
3F68:  MOVFF  02,26
3F6C:  MOVFF  01,25
3F70:  MOVFF  00,24
....................          //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<wideofkeystore;i++) 
3F74:  CLRF   x29
3F76:  MOVF   x29,W
3F78:  SUBLW  0F
3F7A:  BNC   3FBC
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
3F7C:  MOVF   x29,W
3F7E:  ADDWF  24,W
3F80:  MOVWF  00
3F82:  MOVLW  00
3F84:  ADDWFC 25,W
3F86:  MOVWF  01
3F88:  MOVLW  00
3F8A:  ADDWFC 26,W
3F8C:  MOVWF  02
3F8E:  MOVLW  00
3F90:  ADDWFC 27,W
3F92:  MOVWF  03
3F94:  MOVWF  x30
3F96:  MOVFF  02,82F
3F9A:  MOVFF  01,82E
3F9E:  MOVFF  00,82D
3FA2:  MOVWF  x53
3FA4:  MOVFF  02,852
3FA8:  MOVFF  01,851
3FAC:  MOVFF  00,850
3FB0:  CLRF   x54
3FB2:  MOVLB  0
3FB4:  RCALL  3950
....................          } 
3FB6:  MOVLB  8
3FB8:  INCF   x29,F
3FBA:  BRA    3F76
....................          for(i=0;i<wideofkeystore;i++) 
3FBC:  CLRF   x29
3FBE:  MOVF   x29,W
3FC0:  SUBLW  0F
3FC2:  BNC   402C
....................          { 
....................             tempdata=key_data[i]; 
3FC4:  CLRF   03
3FC6:  MOVF   x29,W
3FC8:  ADDLW  46
3FCA:  MOVWF  FE9
3FCC:  MOVLW  01
3FCE:  ADDWFC 03,W
3FD0:  MOVWF  FEA
3FD2:  MOVFF  FEF,82A
....................             write_ext_eeprom((int32)ptr_card_key++,tempdata); 
3FD6:  MOVFF  27,03
3FDA:  MOVFF  26,02
3FDE:  MOVFF  25,01
3FE2:  MOVFF  24,00
3FE6:  MOVLW  01
3FE8:  ADDWF  24,F
3FEA:  BTFSC  FD8.0
3FEC:  INCF   25,F
3FEE:  BTFSC  FD8.2
3FF0:  INCF   26,F
3FF2:  BTFSC  FD8.2
3FF4:  INCF   27,F
3FF6:  MOVFF  03,830
3FFA:  MOVFF  02,82F
3FFE:  MOVFF  01,82E
4002:  MOVFF  00,82D
4006:  MOVFF  03,853
400A:  MOVFF  02,852
400E:  MOVFF  01,851
4012:  MOVFF  00,850
4016:  MOVFF  82A,854
401A:  MOVLB  0
401C:  RCALL  3950
....................             //delay_us(100); 
....................             fprintf(COM2,"%c",tempdata); 
401E:  MOVFF  82A,852
4022:  CALL   15C0
....................          } 
4026:  MOVLB  8
4028:  INCF   x29,F
402A:  BRA    3FBE
....................           //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................           /*fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<wideofkeystore;i++) 
....................           { 
....................             fprintf(COM2,"%c",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
402C:  MOVFF  27,840
4030:  MOVFF  26,83F
4034:  MOVFF  25,83E
4038:  MOVFF  24,83D
403C:  MOVLW  1E
403E:  MOVWF  x41
4040:  MOVLB  0
4042:  RCALL  3A68
4044:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
4046:  CLRF   x43
....................       memset(key_data,0,sizeof(key_data));  
4048:  MOVLW  01
404A:  MOVWF  FEA
404C:  MOVLW  46
404E:  MOVWF  FE9
4050:  CLRF   00
4052:  CLRF   02
4054:  MOVLW  10
4056:  MOVWF  01
4058:  MOVLB  0
405A:  RCALL  3A4E
....................       fprintf(COM2,"\r\n"); 
405C:  MOVLW  0D
405E:  MOVLB  8
4060:  MOVWF  x52
4062:  MOVLB  0
4064:  CALL   15C0
4068:  MOVLW  0A
406A:  MOVLB  8
406C:  MOVWF  x52
406E:  MOVLB  0
4070:  CALL   15C0
....................       fprintf(COM2,"Done save_key_new"); 
4074:  MOVLW  68
4076:  MOVWF  FF6
4078:  MOVLW  05
407A:  MOVWF  FF7
407C:  CALL   16EA
....................       fprintf(COM2,"\r\n"); 
4080:  MOVLW  0D
4082:  MOVLB  8
4084:  MOVWF  x52
4086:  MOVLB  0
4088:  CALL   15C0
408C:  MOVLW  0A
408E:  MOVLB  8
4090:  MOVWF  x52
4092:  MOVLB  0
4094:  CALL   15C0
....................    } 
.................... } 
4098:  GOTO   5310 (RETURN)
.................... //============================================ 
.................... void save_key_encrypt() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    int8 retval; 
....................    int8 rec[wideofkeystore]; 
....................     
....................    if(ptr_card_key<EEPROM_SIZE_endofkey) 
*
4E4E:  MOVF   27,F
4E50:  BTFSS  FD8.2
4E52:  BRA    5078
4E54:  MOVF   26,W
4E56:  SUBLW  01
4E58:  BTFSS  FD8.0
4E5A:  BRA    5078
4E5C:  BNZ   4E70
4E5E:  MOVF   25,W
4E60:  SUBLW  FF
4E62:  BTFSS  FD8.0
4E64:  BRA    5078
4E66:  BNZ   4E70
4E68:  MOVF   24,W
4E6A:  SUBLW  FE
4E6C:  BTFSS  FD8.0
4E6E:  BRA    5078
....................    { 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
4E70:  MOVLB  1
4E72:  MOVF   x46,F
4E74:  BNZ   4E7C
4E76:  MOVF   x43,F
4E78:  BTFSC  FD8.2
4E7A:  BRA    5024
....................       {    
....................          for(i=0;i<key_numbyte;i++) 
4E7C:  MOVLB  8
4E7E:  CLRF   x29
4E80:  MOVF   x29,W
4E82:  SUBLW  0B
4E84:  BNC   4ED8
....................          { 
....................             temp=key_data[i]; 
4E86:  CLRF   03
4E88:  MOVF   x29,W
4E8A:  ADDLW  46
4E8C:  MOVWF  FE9
4E8E:  MOVLW  01
4E90:  ADDWFC 03,W
4E92:  MOVWF  FEA
4E94:  CLRF   x2B
4E96:  MOVFF  FEF,82A
....................             fputc(temp,COM2); 
4E9A:  MOVFF  82A,852
4E9E:  MOVLB  0
4EA0:  CALL   15C0
....................             rec[i]=key_data[i]; 
4EA4:  CLRF   03
4EA6:  MOVLB  8
4EA8:  MOVF   x29,W
4EAA:  ADDLW  2D
4EAC:  MOVWF  01
4EAE:  MOVLW  08
4EB0:  ADDWFC 03,F
4EB2:  MOVFF  03,83E
4EB6:  CLRF   03
4EB8:  MOVF   x29,W
4EBA:  ADDLW  46
4EBC:  MOVWF  FE9
4EBE:  MOVLW  01
4EC0:  ADDWFC 03,W
4EC2:  MOVWF  FEA
4EC4:  MOVFF  FEF,83F
4EC8:  MOVFF  83E,FEA
4ECC:  MOVFF  01,FE9
4ED0:  MOVFF  83F,FEF
....................          } 
4ED4:  INCF   x29,F
4ED6:  BRA    4E80
....................          rec[key_numbyte] = 0; 
4ED8:  CLRF   x39
....................          rec[key_numbyte+1] = 0;          
4EDA:  CLRF   x3A
....................          rec[key_numbyte+2] = 0;          
4EDC:  CLRF   x3B
....................          rec[key_numbyte+3] = 0; 
4EDE:  CLRF   x3C
....................     #if 0 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"test_key:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2,"%x",test_key[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          fprintf(COM2,"\n\rdatain:\n\r"); 
....................          for(i=0;i<16;i++) fprintf(COM2," %x",rec[i]); 
....................          fprintf(COM2,"\n\r"); 
....................     #endif 
....................          aes_enc_dec((unsigned int8 *)&rec[0], (unsigned int8 *)&crypto_key[0],0); 
4EE0:  MOVLW  08
4EE2:  MOVWF  x3E
4EE4:  MOVLW  2D
4EE6:  MOVWF  x3D
4EE8:  CLRF   x40
4EEA:  MOVLW  FD
4EEC:  MOVWF  x3F
4EEE:  CLRF   x41
4EF0:  MOVLB  0
4EF2:  GOTO   40FE
....................          //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................           
....................          /* get the pointer of keyboard data */ 
....................          temp=get_countcard(); 
4EF6:  CALL   34CC
4EFA:  MOVFF  02,82B
4EFE:  MOVFF  01,82A
....................          ptr_card_key=(int32)(((temp)*wideofkeystore)+EEPROM_KEY_ST); 
4F02:  MOVLB  8
4F04:  RLCF   x2A,W
4F06:  MOVWF  x3D
4F08:  RLCF   x2B,W
4F0A:  MOVWF  x3E
4F0C:  RLCF   x3D,F
4F0E:  RLCF   x3E,F
4F10:  RLCF   x3D,F
4F12:  RLCF   x3E,F
4F14:  RLCF   x3D,F
4F16:  RLCF   x3E,F
4F18:  MOVLW  F0
4F1A:  ANDWF  x3D,F
4F1C:  MOVLW  0E
4F1E:  ADDWF  x3D,F
4F20:  MOVLW  C3
4F22:  ADDWFC x3E,F
4F24:  MOVLW  01
4F26:  MOVWF  x3F
4F28:  BCF    FD8.2
4F2A:  BTFSC  FD8.0
4F2C:  INCF   x3F,F
4F2E:  CLRF   x40
4F30:  MOVLW  01
4F32:  ADDWF  x3D,W
4F34:  MOVWF  00
4F36:  MOVLW  00
4F38:  ADDWFC x3E,W
4F3A:  MOVWF  01
4F3C:  MOVLW  00
4F3E:  ADDWFC x3F,W
4F40:  MOVWF  02
4F42:  MOVLW  00
4F44:  ADDWFC x40,W
4F46:  MOVWF  27
4F48:  MOVFF  02,26
4F4C:  MOVFF  01,25
4F50:  MOVFF  00,24
....................          /* delete the old data of key store area  */ 
....................          for(i=0;i<wideofkeystore;i++) 
4F54:  CLRF   x29
4F56:  MOVF   x29,W
4F58:  SUBLW  0F
4F5A:  BNC   4F9E
....................          { 
....................             write_ext_eeprom((int32)(ptr_card_key+i),0); 
4F5C:  MOVF   x29,W
4F5E:  ADDWF  24,W
4F60:  MOVWF  00
4F62:  MOVLW  00
4F64:  ADDWFC 25,W
4F66:  MOVWF  01
4F68:  MOVLW  00
4F6A:  ADDWFC 26,W
4F6C:  MOVWF  02
4F6E:  MOVLW  00
4F70:  ADDWFC 27,W
4F72:  MOVWF  03
4F74:  MOVWF  x40
4F76:  MOVFF  02,83F
4F7A:  MOVFF  01,83E
4F7E:  MOVFF  00,83D
4F82:  MOVWF  x53
4F84:  MOVFF  02,852
4F88:  MOVFF  01,851
4F8C:  MOVFF  00,850
4F90:  CLRF   x54
4F92:  MOVLB  0
4F94:  CALL   3950
....................          } 
4F98:  MOVLB  8
4F9A:  INCF   x29,F
4F9C:  BRA    4F56
....................           
....................          for(i=0;i<wideofkeystore;i++) fprintf(COM2,"%x",rec[i]); 
4F9E:  CLRF   x29
4FA0:  MOVF   x29,W
4FA2:  SUBLW  0F
4FA4:  BNC   4FCA
4FA6:  CLRF   03
4FA8:  MOVF   x29,W
4FAA:  ADDLW  2D
4FAC:  MOVWF  FE9
4FAE:  MOVLW  08
4FB0:  ADDWFC 03,W
4FB2:  MOVWF  FEA
4FB4:  MOVFF  FEF,83D
4FB8:  MOVFF  83D,83E
4FBC:  MOVLW  57
4FBE:  MOVWF  x3F
4FC0:  MOVLB  0
4FC2:  RCALL  4D74
4FC4:  MOVLB  8
4FC6:  INCF   x29,F
4FC8:  BRA    4FA0
....................          retval = EEPROM_write(ptr_card_key,wideofkeystore,rec);  
4FCA:  MOVFF  27,840
4FCE:  MOVFF  26,83F
4FD2:  MOVFF  25,83E
4FD6:  MOVFF  24,83D
4FDA:  CLRF   x44
4FDC:  CLRF   x43
4FDE:  CLRF   x42
4FE0:  MOVLW  10
4FE2:  MOVWF  x41
4FE4:  MOVLW  08
4FE6:  MOVWF  x46
4FE8:  MOVLW  2D
4FEA:  MOVWF  x45
4FEC:  MOVLB  0
4FEE:  RCALL  4DBE
4FF0:  MOVFF  01,82C
....................          if(retval!=0) 
4FF4:  MOVLB  8
4FF6:  MOVF   x2C,F
4FF8:  BZ    5022
....................          { 
....................             ptr_card_key+=wideofkeystore; 
4FFA:  MOVLW  10
4FFC:  ADDWF  24,F
4FFE:  MOVLW  00
5000:  ADDWFC 25,F
5002:  ADDWFC 26,F
5004:  ADDWFC 27,F
....................             save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5006:  MOVFF  27,840
500A:  MOVFF  26,83F
500E:  MOVFF  25,83E
5012:  MOVFF  24,83D
5016:  MOVLW  1E
5018:  MOVWF  x41
501A:  MOVLB  0
501C:  CALL   3A68
5020:  MOVLB  8
5022:  MOVLB  1
....................          }          
....................       } 
....................       key_count_ms=0; 
5024:  CLRF   x43
....................       memset(key_data,0,sizeof(key_data));  
5026:  MOVLW  01
5028:  MOVWF  FEA
502A:  MOVLW  46
502C:  MOVWF  FE9
502E:  CLRF   00
5030:  CLRF   02
5032:  MOVLW  10
5034:  MOVWF  01
5036:  MOVLB  0
5038:  CALL   3A4E
....................       fprintf(COM2,"\r\n"); 
503C:  MOVLW  0D
503E:  MOVLB  8
5040:  MOVWF  x52
5042:  MOVLB  0
5044:  CALL   15C0
5048:  MOVLW  0A
504A:  MOVLB  8
504C:  MOVWF  x52
504E:  MOVLB  0
5050:  CALL   15C0
....................       fprintf(COM2,"Done Encrypted PIN"); 
5054:  MOVLW  7A
5056:  MOVWF  FF6
5058:  MOVLW  05
505A:  MOVWF  FF7
505C:  CALL   16EA
....................       fprintf(COM2,"\r\n"); 
5060:  MOVLW  0D
5062:  MOVLB  8
5064:  MOVWF  x52
5066:  MOVLB  0
5068:  CALL   15C0
506C:  MOVLW  0A
506E:  MOVLB  8
5070:  MOVWF  x52
5072:  MOVLB  0
5074:  CALL   15C0
....................    } 
.................... } 
5078:  GOTO   5318 (RETURN)
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
57C0:  MOVLB  7
57C2:  CLRF   xF8
57C4:  CLRF   xF7
57C6:  CLRF   xF9
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
57C8:  MOVF   xF8,F
57CA:  BTFSS  FD8.2
57CC:  BRA    58F0
57CE:  MOVF   xF2,W
57D0:  SUBWF  xF7,W
57D2:  BTFSC  FD8.0
57D4:  BRA    58F0
57D6:  MOVF   xF9,F
57D8:  BTFSS  FD8.2
57DA:  BRA    58F0
....................       c = fgetc(COM2);//getc(); 
57DC:  MOVLB  0
57DE:  RCALL  5772
57E0:  MOVFF  01,7F5
....................       switch(c) 
....................       { 
57E4:  MOVLB  7
57E6:  MOVF   xF5,W
57E8:  XORLW  7F
57EA:  MOVLB  0
57EC:  BZ    57F4
57EE:  XORLW  72
57F0:  BZ    5842
57F2:  BRA    5880
....................          case 0x7f:    
....................             if(nbcar>0)   
57F4:  MOVLB  7
57F6:  MOVF   xF7,F
57F8:  BNZ   57FE
57FA:  MOVF   xF8,F
57FC:  BZ    5828
57FE:  CLRF   19
5800:  BTFSC  FF2.7
5802:  BSF    19.7
5804:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
5806:  MOVLW  7F
5808:  MOVLB  8
580A:  MOVWF  x52
580C:  MOVLB  0
580E:  CALL   15C0
5812:  BTFSC  19.7
5814:  BSF    FF2.7
....................                nbcar--; 
5816:  MOVLB  7
5818:  MOVF   xF7,W
581A:  BTFSC  FD8.2
581C:  DECF   xF8,F
581E:  DECF   xF7,F
....................                fgetc(COM2);//getc(); 
5820:  MOVLB  0
5822:  RCALL  5772
....................             } 
....................             else fputc(0x07,COM2);    
5824:  BRA    5840
5826:  MOVLB  7
5828:  CLRF   19
582A:  BTFSC  FF2.7
582C:  BSF    19.7
582E:  BCF    FF2.7
5830:  MOVLW  07
5832:  MOVLB  8
5834:  MOVWF  x52
5836:  MOVLB  0
5838:  CALL   15C0
583C:  BTFSC  19.7
583E:  BSF    FF2.7
....................          break;  
5840:  BRA    58EC
....................          case 0x0D:   
....................                keydebug_en=0; 
5842:  MOVLB  1
5844:  CLRF   x40
....................                set_tris_a(0xff); 
5846:  MOVLW  FF
5848:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
584A:  MOVFF  7F7,7F6
584E:  MOVLB  7
5850:  MOVF   xF2,W
5852:  SUBWF  xF6,W
5854:  BC    586A
....................                { 
....................                  chaine[i]=0; 
5856:  CLRF   03
5858:  MOVF   xF6,W
585A:  ADDWF  xF3,W
585C:  MOVWF  FE9
585E:  MOVF   xF4,W
5860:  ADDWFC 03,W
5862:  MOVWF  FEA
5864:  CLRF   FEF
....................                } 
5866:  INCF   xF6,F
5868:  BRA    5850
....................                if(nbcar==0)return(FAUX); 
586A:  MOVF   xF7,F
586C:  BNZ   5878
586E:  MOVF   xF8,F
5870:  BNZ   5878
5872:  MOVLW  00
5874:  MOVWF  01
5876:  BRA    58F4
....................                fini=VRAI; 
5878:  MOVLW  01
587A:  MOVWF  xF9
....................          break; 
587C:  MOVLB  0
587E:  BRA    58EC
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
5880:  MOVLB  7
5882:  MOVF   xF5,W
5884:  SUBLW  1F
5886:  BC    58EE
5888:  MOVF   xF5,W
588A:  SUBLW  7E
588C:  BNC   58EE
588E:  MOVLW  01
5890:  SUBWF  xF2,W
5892:  MOVF   xF8,F
5894:  BNZ   58EE
5896:  SUBWF  xF7,W
5898:  BC    58EE
....................             { 
....................                chaine[nbcar]=c; 
589A:  MOVF   xF3,W
589C:  ADDWF  xF7,W
589E:  MOVWF  FE9
58A0:  MOVF   xF4,W
58A2:  ADDWFC xF8,W
58A4:  MOVWF  FEA
58A6:  MOVFF  7F5,FEF
....................                nbcar++; 
58AA:  INCF   xF7,F
58AC:  BTFSC  FD8.2
58AE:  INCF   xF8,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
58B0:  DECFSZ xF1,W
58B2:  BRA    58CE
58B4:  CLRF   19
58B6:  BTFSC  FF2.7
58B8:  BSF    19.7
58BA:  BCF    FF2.7
58BC:  MOVFF  7F5,852
58C0:  MOVLB  0
58C2:  CALL   15C0
58C6:  BTFSC  19.7
58C8:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
58CA:  BRA    58EC
58CC:  MOVLB  7
58CE:  MOVF   xF1,W
58D0:  SUBLW  02
58D2:  BNZ   58EE
58D4:  CLRF   19
58D6:  BTFSC  FF2.7
58D8:  BSF    19.7
58DA:  BCF    FF2.7
58DC:  MOVLW  2A
58DE:  MOVLB  8
58E0:  MOVWF  x52
58E2:  MOVLB  0
58E4:  CALL   15C0
58E8:  BTFSC  19.7
58EA:  BSF    FF2.7
58EC:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
58EE:  BRA    57C8
....................    return(nbcar); 
58F0:  MOVFF  7F7,01
.................... } 
58F4:  MOVLB  0
58F6:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
58F8:  MOVFF  7F2,7F6
58FC:  MOVFF  7F1,7F5
5900:  MOVFF  7F4,7F8
5904:  MOVFF  7F3,7F7
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
5908:  MOVFF  7F6,03
590C:  MOVLB  7
590E:  MOVFF  7F5,FE9
5912:  MOVFF  7F6,FEA
5916:  MOVF   FEF,F
5918:  BZ    5960
591A:  MOVFF  7F8,03
591E:  MOVFF  7F7,FE9
5922:  MOVFF  7F8,FEA
5926:  MOVF   FEF,F
5928:  BZ    5960
....................       if(*aa!=*bb) 
592A:  MOVFF  7F5,FE9
592E:  MOVFF  7F6,FEA
5932:  MOVFF  FEF,7F9
5936:  MOVFF  7F8,03
593A:  MOVFF  7F7,FE9
593E:  MOVFF  7F8,FEA
5942:  MOVF   FEF,W
5944:  SUBWF  xF9,W
5946:  BZ    594E
....................          return(1); 
5948:  MOVLW  01
594A:  MOVWF  01
594C:  BRA    598C
....................       aa++; 
594E:  INCF   xF5,F
5950:  BTFSC  FD8.2
5952:  INCF   xF6,F
....................       bb++; 
5954:  INCF   xF7,F
5956:  BTFSC  FD8.2
5958:  INCF   xF8,F
....................    } 
595A:  MOVLB  0
595C:  BRA    5908
595E:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
5960:  MOVFF  7F6,03
5964:  MOVFF  7F5,FE9
5968:  MOVFF  7F6,FEA
596C:  MOVFF  FEF,7F9
5970:  MOVFF  7F8,03
5974:  MOVFF  7F7,FE9
5978:  MOVFF  7F8,FEA
597C:  MOVF   FEF,W
597E:  SUBWF  xF9,W
5980:  BZ    5988
5982:  MOVLW  01
5984:  MOVWF  01
5986:  BRA    598C
....................    return(0); 
5988:  MOVLW  00
598A:  MOVWF  01
.................... } 
598C:  MOVLB  0
598E:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
5DBE:  MOVLB  7
5DC0:  CLRF   xF3
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
5DC2:  MOVFF  7F2,03
5DC6:  MOVF   xF1,W
5DC8:  INCF   xF1,F
5DCA:  BTFSC  FD8.2
5DCC:  INCF   xF2,F
5DCE:  MOVWF  FE9
5DD0:  MOVFF  03,FEA
5DD4:  MOVFF  FEF,7F5
5DD8:  MOVF   xF5,F
5DDA:  BZ    5DFE
....................         if (c >= '0' && c <= '9') 
5DDC:  MOVF   xF5,W
5DDE:  SUBLW  2F
5DE0:  BC    5DF0
5DE2:  MOVF   xF5,W
5DE4:  SUBLW  39
5DE6:  BNC   5DF0
....................             digit = (unsigned int) (c - '0'); 
5DE8:  MOVLW  30
5DEA:  SUBWF  xF5,W
5DEC:  MOVWF  xF4
....................         else 
5DEE:  BRA    5DF2
....................             break; 
5DF0:  BRA    5DFE
....................  
....................         val = (val * 10) + digit; 
5DF2:  MOVF   xF3,W
5DF4:  MULLW  0A
5DF6:  MOVF   FF3,W
5DF8:  ADDWF  xF4,W
5DFA:  MOVWF  xF3
....................     } 
5DFC:  BRA    5DC2
....................  
....................     return val; 
5DFE:  CLRF   03
5E00:  MOVFF  7F3,01
5E04:  MOVFF  03,02
.................... } 
5E08:  MOVLB  0
5E0A:  RETURN 0
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
....................  
....................  
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
0668:  MOVLB  8
066A:  CLRF   x62
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
066C:  CLRF   x63
066E:  BTFSC  x5A.0
0670:  BSF    x63.7
0672:  SWAPF  x5B,W
0674:  MOVWF  00
0676:  RLCF   00,F
0678:  RLCF   00,F
067A:  MOVLW  C0
067C:  ANDWF  00,F
067E:  MOVF   00,W
0680:  IORWF  x63,F
0682:  SWAPF  x5C,W
0684:  MOVWF  00
0686:  RLCF   00,F
0688:  MOVLW  E0
068A:  ANDWF  00,F
068C:  MOVF   00,W
068E:  IORWF  x63,F
0690:  SWAPF  x5D,W
0692:  MOVWF  00
0694:  MOVLW  F0
0696:  ANDWF  00,F
0698:  MOVF   00,W
069A:  IORWF  x63,F
069C:  RLCF   x5E,W
069E:  MOVWF  00
06A0:  RLCF   00,F
06A2:  RLCF   00,F
06A4:  MOVLW  F8
06A6:  ANDWF  00,F
06A8:  MOVF   00,W
06AA:  IORWF  x63,F
06AC:  RLCF   x5F,W
06AE:  MOVWF  00
06B0:  RLCF   00,F
06B2:  MOVLW  FC
06B4:  ANDWF  00,F
06B6:  MOVF   00,W
06B8:  IORWF  x63,F
06BA:  BCF    FD8.0
06BC:  RLCF   x60,W
06BE:  IORWF  x63,F
06C0:  MOVF   x61,W
06C2:  IORWF  x63,W
06C4:  MOVWF  x62
....................    return temp; 
06C6:  MOVFF  862,01
.................... } 
06CA:  MOVLB  0
06CC:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
06CE:  MOVLB  8
06D0:  CLRF   x4A
....................    int8 temp=0; 
....................    if(direct==0) 
06D2:  MOVF   x45,F
06D4:  BNZ   07AA
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
06D6:  MOVF   x48,W
06D8:  ADDWF  x46,W
06DA:  MOVWF  FE9
06DC:  MOVF   x49,W
06DE:  ADDWFC x47,W
06E0:  MOVWF  FEA
06E2:  MOVFF  FEF,84B
06E6:  MOVLW  01
06E8:  ADDWF  x46,W
06EA:  MOVWF  x4C
06EC:  MOVLW  00
06EE:  ADDWFC x47,W
06F0:  MOVWF  x4D
06F2:  MOVF   x48,W
06F4:  ADDWF  x4C,W
06F6:  MOVWF  FE9
06F8:  MOVF   x49,W
06FA:  ADDWFC x4D,W
06FC:  MOVWF  FEA
06FE:  MOVF   FEF,W
0700:  XORWF  x4B,F
0702:  MOVLW  02
0704:  ADDWF  x46,W
0706:  MOVWF  x4E
0708:  MOVLW  00
070A:  ADDWFC x47,W
070C:  MOVWF  x4F
070E:  MOVF   x48,W
0710:  ADDWF  x4E,W
0712:  MOVWF  FE9
0714:  MOVF   x49,W
0716:  ADDWFC x4F,W
0718:  MOVWF  FEA
071A:  MOVF   FEF,W
071C:  XORWF  x4B,F
071E:  MOVLW  03
0720:  ADDWF  x46,W
0722:  MOVWF  x50
0724:  MOVLW  00
0726:  ADDWFC x47,W
0728:  MOVWF  x51
072A:  MOVF   x48,W
072C:  ADDWF  x50,W
072E:  MOVWF  FE9
0730:  MOVF   x49,W
0732:  ADDWFC x51,W
0734:  MOVWF  FEA
0736:  MOVF   FEF,W
0738:  XORWF  x4B,F
073A:  MOVLW  04
073C:  ADDWF  x46,W
073E:  MOVWF  x52
0740:  MOVLW  00
0742:  ADDWFC x47,W
0744:  MOVWF  x53
0746:  MOVF   x48,W
0748:  ADDWF  x52,W
074A:  MOVWF  FE9
074C:  MOVF   x49,W
074E:  ADDWFC x53,W
0750:  MOVWF  FEA
0752:  MOVF   FEF,W
0754:  XORWF  x4B,F
0756:  MOVLW  05
0758:  ADDWF  x46,W
075A:  MOVWF  x54
075C:  MOVLW  00
075E:  ADDWFC x47,W
0760:  MOVWF  x55
0762:  MOVF   x48,W
0764:  ADDWF  x54,W
0766:  MOVWF  FE9
0768:  MOVF   x49,W
076A:  ADDWFC x55,W
076C:  MOVWF  FEA
076E:  MOVF   FEF,W
0770:  XORWF  x4B,W
0772:  BZ    0778
0774:  MOVLW  00
0776:  BRA    077A
0778:  MOVLW  01
077A:  MOVWF  x4A
....................       if(temp==datain[offset+6]) return 1; 
077C:  MOVLW  06
077E:  ADDWF  x46,W
0780:  MOVWF  x4B
0782:  MOVLW  00
0784:  ADDWFC x47,W
0786:  MOVWF  x4C
0788:  MOVF   x48,W
078A:  ADDWF  x4B,W
078C:  MOVWF  FE9
078E:  MOVF   x49,W
0790:  ADDWFC x4C,W
0792:  MOVWF  FEA
0794:  MOVF   FEF,W
0796:  SUBWF  x4A,W
0798:  BNZ   07A2
079A:  MOVLW  01
079C:  MOVWF  01
079E:  BRA    087A
....................          else return 0; 
07A0:  BRA    07A8
07A2:  MOVLW  00
07A4:  MOVWF  01
07A6:  BRA    087A
....................    } 
....................       else  
07A8:  BRA    087A
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
07AA:  MOVF   x48,W
07AC:  ADDWF  x46,W
07AE:  MOVWF  FE9
07B0:  MOVF   x49,W
07B2:  ADDWFC x47,W
07B4:  MOVWF  FEA
07B6:  MOVFF  FEF,84B
07BA:  MOVLW  01
07BC:  SUBWF  x46,W
07BE:  MOVWF  x4C
07C0:  MOVLW  00
07C2:  SUBWFB x47,W
07C4:  MOVWF  x4D
07C6:  MOVF   x48,W
07C8:  ADDWF  x4C,W
07CA:  MOVWF  FE9
07CC:  MOVF   x49,W
07CE:  ADDWFC x4D,W
07D0:  MOVWF  FEA
07D2:  MOVF   FEF,W
07D4:  XORWF  x4B,F
07D6:  MOVLW  02
07D8:  SUBWF  x46,W
07DA:  MOVWF  x4E
07DC:  MOVLW  00
07DE:  SUBWFB x47,W
07E0:  MOVWF  x4F
07E2:  MOVF   x48,W
07E4:  ADDWF  x4E,W
07E6:  MOVWF  FE9
07E8:  MOVF   x49,W
07EA:  ADDWFC x4F,W
07EC:  MOVWF  FEA
07EE:  MOVF   FEF,W
07F0:  XORWF  x4B,F
07F2:  MOVLW  03
07F4:  SUBWF  x46,W
07F6:  MOVWF  x50
07F8:  MOVLW  00
07FA:  SUBWFB x47,W
07FC:  MOVWF  x51
07FE:  MOVF   x48,W
0800:  ADDWF  x50,W
0802:  MOVWF  FE9
0804:  MOVF   x49,W
0806:  ADDWFC x51,W
0808:  MOVWF  FEA
080A:  MOVF   FEF,W
080C:  XORWF  x4B,F
080E:  MOVLW  04
0810:  SUBWF  x46,W
0812:  MOVWF  x52
0814:  MOVLW  00
0816:  SUBWFB x47,W
0818:  MOVWF  x53
081A:  MOVF   x48,W
081C:  ADDWF  x52,W
081E:  MOVWF  FE9
0820:  MOVF   x49,W
0822:  ADDWFC x53,W
0824:  MOVWF  FEA
0826:  MOVF   FEF,W
0828:  XORWF  x4B,F
082A:  MOVLW  05
082C:  SUBWF  x46,W
082E:  MOVWF  x54
0830:  MOVLW  00
0832:  SUBWFB x47,W
0834:  MOVWF  x55
0836:  MOVF   x48,W
0838:  ADDWF  x54,W
083A:  MOVWF  FE9
083C:  MOVF   x49,W
083E:  ADDWFC x55,W
0840:  MOVWF  FEA
0842:  MOVF   FEF,W
0844:  XORWF  x4B,W
0846:  BZ    084C
0848:  MOVLW  00
084A:  BRA    084E
084C:  MOVLW  01
084E:  MOVWF  x4A
....................          if(temp==datain[offset-6]) return 1; 
0850:  MOVLW  06
0852:  SUBWF  x46,W
0854:  MOVWF  x4B
0856:  MOVLW  00
0858:  SUBWFB x47,W
085A:  MOVWF  x4C
085C:  MOVF   x48,W
085E:  ADDWF  x4B,W
0860:  MOVWF  FE9
0862:  MOVF   x49,W
0864:  ADDWFC x4C,W
0866:  MOVWF  FEA
0868:  MOVF   FEF,W
086A:  SUBWF  x4A,W
086C:  BNZ   0876
086E:  MOVLW  01
0870:  MOVWF  01
0872:  BRA    087A
....................             else return 0;          
0874:  BRA    087A
0876:  MOVLW  00
0878:  MOVWF  01
....................       } 
.................... } 
087A:  MOVLB  0
087C:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
087E:  MOVLB  8
0880:  CLRF   x4A
....................    int8 temp=0; 
....................    if(direct==0) 
0882:  MOVF   x45,F
0884:  BNZ   0922
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
0886:  MOVF   x48,W
0888:  ADDWF  x46,W
088A:  MOVWF  FE9
088C:  MOVF   x49,W
088E:  ADDWFC x47,W
0890:  MOVWF  FEA
0892:  MOVFF  FEF,84B
0896:  MOVLW  01
0898:  ADDWF  x46,W
089A:  MOVWF  x4C
089C:  MOVLW  00
089E:  ADDWFC x47,W
08A0:  MOVWF  x4D
08A2:  MOVF   x48,W
08A4:  ADDWF  x4C,W
08A6:  MOVWF  FE9
08A8:  MOVF   x49,W
08AA:  ADDWFC x4D,W
08AC:  MOVWF  FEA
08AE:  MOVF   FEF,W
08B0:  XORWF  x4B,F
08B2:  MOVLW  02
08B4:  ADDWF  x46,W
08B6:  MOVWF  x4E
08B8:  MOVLW  00
08BA:  ADDWFC x47,W
08BC:  MOVWF  x4F
08BE:  MOVF   x48,W
08C0:  ADDWF  x4E,W
08C2:  MOVWF  FE9
08C4:  MOVF   x49,W
08C6:  ADDWFC x4F,W
08C8:  MOVWF  FEA
08CA:  MOVF   FEF,W
08CC:  XORWF  x4B,F
08CE:  MOVLW  03
08D0:  ADDWF  x46,W
08D2:  MOVWF  x50
08D4:  MOVLW  00
08D6:  ADDWFC x47,W
08D8:  MOVWF  x51
08DA:  MOVF   x48,W
08DC:  ADDWF  x50,W
08DE:  MOVWF  FE9
08E0:  MOVF   x49,W
08E2:  ADDWFC x51,W
08E4:  MOVWF  FEA
08E6:  MOVF   FEF,W
08E8:  XORWF  x4B,W
08EA:  BZ    08F0
08EC:  MOVLW  00
08EE:  BRA    08F2
08F0:  MOVLW  01
08F2:  MOVWF  x4A
....................       if(temp==datain[offset+4]) return 1; 
08F4:  MOVLW  04
08F6:  ADDWF  x46,W
08F8:  MOVWF  x4B
08FA:  MOVLW  00
08FC:  ADDWFC x47,W
08FE:  MOVWF  x4C
0900:  MOVF   x48,W
0902:  ADDWF  x4B,W
0904:  MOVWF  FE9
0906:  MOVF   x49,W
0908:  ADDWFC x4C,W
090A:  MOVWF  FEA
090C:  MOVF   FEF,W
090E:  SUBWF  x4A,W
0910:  BNZ   091A
0912:  MOVLW  01
0914:  MOVWF  01
0916:  BRA    09BA
....................          else return 0; 
0918:  BRA    0920
091A:  MOVLW  00
091C:  MOVWF  01
091E:  BRA    09BA
....................    } 
....................    else 
0920:  BRA    09BA
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0922:  MOVF   x48,W
0924:  ADDWF  x46,W
0926:  MOVWF  FE9
0928:  MOVF   x49,W
092A:  ADDWFC x47,W
092C:  MOVWF  FEA
092E:  MOVFF  FEF,84B
0932:  MOVLW  01
0934:  SUBWF  x46,W
0936:  MOVWF  x4C
0938:  MOVLW  00
093A:  SUBWFB x47,W
093C:  MOVWF  x4D
093E:  MOVF   x48,W
0940:  ADDWF  x4C,W
0942:  MOVWF  FE9
0944:  MOVF   x49,W
0946:  ADDWFC x4D,W
0948:  MOVWF  FEA
094A:  MOVF   FEF,W
094C:  XORWF  x4B,F
094E:  MOVLW  02
0950:  SUBWF  x46,W
0952:  MOVWF  x4E
0954:  MOVLW  00
0956:  SUBWFB x47,W
0958:  MOVWF  x4F
095A:  MOVF   x48,W
095C:  ADDWF  x4E,W
095E:  MOVWF  FE9
0960:  MOVF   x49,W
0962:  ADDWFC x4F,W
0964:  MOVWF  FEA
0966:  MOVF   FEF,W
0968:  XORWF  x4B,F
096A:  MOVLW  03
096C:  SUBWF  x46,W
096E:  MOVWF  x50
0970:  MOVLW  00
0972:  SUBWFB x47,W
0974:  MOVWF  x51
0976:  MOVF   x48,W
0978:  ADDWF  x50,W
097A:  MOVWF  FE9
097C:  MOVF   x49,W
097E:  ADDWFC x51,W
0980:  MOVWF  FEA
0982:  MOVF   FEF,W
0984:  XORWF  x4B,W
0986:  BZ    098C
0988:  MOVLW  00
098A:  BRA    098E
098C:  MOVLW  01
098E:  MOVWF  x4A
....................       if(temp==datain[offset-4]) return 1; 
0990:  MOVLW  04
0992:  SUBWF  x46,W
0994:  MOVWF  x4B
0996:  MOVLW  00
0998:  SUBWFB x47,W
099A:  MOVWF  x4C
099C:  MOVF   x48,W
099E:  ADDWF  x4B,W
09A0:  MOVWF  FE9
09A2:  MOVF   x49,W
09A4:  ADDWFC x4C,W
09A6:  MOVWF  FEA
09A8:  MOVF   FEF,W
09AA:  SUBWF  x4A,W
09AC:  BNZ   09B6
09AE:  MOVLW  01
09B0:  MOVWF  01
09B2:  BRA    09BA
....................          else return 0;                
09B4:  BRA    09BA
09B6:  MOVLW  00
09B8:  MOVWF  01
....................    } 
.................... } 
09BA:  MOVLB  0
09BC:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
09BE:  MOVLB  8
09C0:  CLRF   x41
09C2:  CLRF   x42
09C4:  CLRF   x43
09C6:  CLRF   x44
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
09C8:  CLRF   x3E
09CA:  CLRF   x3D
09CC:  RRCF   x3A,W
09CE:  MOVWF  03
09D0:  RRCF   x39,W
09D2:  MOVWF  02
09D4:  RRCF   03,F
09D6:  RRCF   02,F
09D8:  MOVLW  3F
09DA:  ANDWF  03,F
09DC:  MOVFF  02,01
09E0:  MOVF   x3E,W
09E2:  SUBWF  03,W
09E4:  BTFSS  FD8.0
09E6:  BRA    0FA6
09E8:  BNZ   09F2
09EA:  MOVF   01,W
09EC:  SUBWF  x3D,W
09EE:  BTFSC  FD8.0
09F0:  BRA    0FA6
....................    { 
....................       if(track==0) 
09F2:  MOVF   x38,F
09F4:  BTFSS  FD8.2
09F6:  BRA    0D2C
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
09F8:  MOVLW  06
09FA:  ADDWF  x3D,W
09FC:  MOVWF  x45
09FE:  MOVLW  00
0A00:  ADDWFC x3E,W
0A02:  MOVWF  x46
0A04:  MOVF   x3B,W
0A06:  ADDWF  x45,W
0A08:  MOVWF  FE9
0A0A:  MOVF   x3C,W
0A0C:  ADDWFC x46,W
0A0E:  MOVWF  FEA
0A10:  MOVFF  FEF,847
0A14:  MOVLW  05
0A16:  ADDWF  x3D,W
0A18:  MOVWF  x48
0A1A:  MOVLW  00
0A1C:  ADDWFC x3E,W
0A1E:  MOVWF  x49
0A20:  MOVF   x3B,W
0A22:  ADDWF  x48,W
0A24:  MOVWF  FE9
0A26:  MOVF   x3C,W
0A28:  ADDWFC x49,W
0A2A:  MOVWF  FEA
0A2C:  MOVFF  FEF,84A
0A30:  MOVLW  04
0A32:  ADDWF  x3D,W
0A34:  MOVWF  x4B
0A36:  MOVLW  00
0A38:  ADDWFC x3E,W
0A3A:  MOVWF  x4C
0A3C:  MOVF   x3B,W
0A3E:  ADDWF  x4B,W
0A40:  MOVWF  FE9
0A42:  MOVF   x3C,W
0A44:  ADDWFC x4C,W
0A46:  MOVWF  FEA
0A48:  MOVFF  FEF,84D
0A4C:  MOVLW  03
0A4E:  ADDWF  x3D,W
0A50:  MOVWF  x4E
0A52:  MOVLW  00
0A54:  ADDWFC x3E,W
0A56:  MOVWF  x4F
0A58:  MOVF   x3B,W
0A5A:  ADDWF  x4E,W
0A5C:  MOVWF  FE9
0A5E:  MOVF   x3C,W
0A60:  ADDWFC x4F,W
0A62:  MOVWF  FEA
0A64:  MOVFF  FEF,850
0A68:  MOVLW  02
0A6A:  ADDWF  x3D,W
0A6C:  MOVWF  x51
0A6E:  MOVLW  00
0A70:  ADDWFC x3E,W
0A72:  MOVWF  x52
0A74:  MOVF   x3B,W
0A76:  ADDWF  x51,W
0A78:  MOVWF  FE9
0A7A:  MOVF   x3C,W
0A7C:  ADDWFC x52,W
0A7E:  MOVWF  FEA
0A80:  MOVFF  FEF,853
0A84:  MOVLW  01
0A86:  ADDWF  x3D,W
0A88:  MOVWF  x54
0A8A:  MOVLW  00
0A8C:  ADDWFC x3E,W
0A8E:  MOVWF  x55
0A90:  MOVF   x3B,W
0A92:  ADDWF  x54,W
0A94:  MOVWF  FE9
0A96:  MOVF   x3C,W
0A98:  ADDWFC x55,W
0A9A:  MOVWF  FEA
0A9C:  MOVFF  FEF,856
0AA0:  MOVF   x3B,W
0AA2:  ADDWF  x3D,W
0AA4:  MOVWF  FE9
0AA6:  MOVF   x3C,W
0AA8:  ADDWFC x3E,W
0AAA:  MOVWF  FEA
0AAC:  MOVFF  FEF,857
0AB0:  CLRF   x5A
0AB2:  MOVFF  847,85B
0AB6:  MOVFF  84A,85C
0ABA:  MOVFF  84D,85D
0ABE:  MOVFF  850,85E
0AC2:  MOVFF  853,85F
0AC6:  MOVFF  856,860
0ACA:  MOVFF  857,861
0ACE:  MOVLB  0
0AD0:  RCALL  0668
0AD2:  MOVFF  01,841
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0AD6:  MOVLW  0D
0AD8:  MOVLB  8
0ADA:  ADDWF  x3D,W
0ADC:  MOVWF  x45
0ADE:  MOVLW  00
0AE0:  ADDWFC x3E,W
0AE2:  MOVWF  x46
0AE4:  MOVF   x3B,W
0AE6:  ADDWF  x45,W
0AE8:  MOVWF  FE9
0AEA:  MOVF   x3C,W
0AEC:  ADDWFC x46,W
0AEE:  MOVWF  FEA
0AF0:  MOVFF  FEF,847
0AF4:  MOVLW  0C
0AF6:  ADDWF  x3D,W
0AF8:  MOVWF  x48
0AFA:  MOVLW  00
0AFC:  ADDWFC x3E,W
0AFE:  MOVWF  x49
0B00:  MOVF   x3B,W
0B02:  ADDWF  x48,W
0B04:  MOVWF  FE9
0B06:  MOVF   x3C,W
0B08:  ADDWFC x49,W
0B0A:  MOVWF  FEA
0B0C:  MOVFF  FEF,84A
0B10:  MOVLW  0B
0B12:  ADDWF  x3D,W
0B14:  MOVWF  x4B
0B16:  MOVLW  00
0B18:  ADDWFC x3E,W
0B1A:  MOVWF  x4C
0B1C:  MOVF   x3B,W
0B1E:  ADDWF  x4B,W
0B20:  MOVWF  FE9
0B22:  MOVF   x3C,W
0B24:  ADDWFC x4C,W
0B26:  MOVWF  FEA
0B28:  MOVFF  FEF,84D
0B2C:  MOVLW  0A
0B2E:  ADDWF  x3D,W
0B30:  MOVWF  x4E
0B32:  MOVLW  00
0B34:  ADDWFC x3E,W
0B36:  MOVWF  x4F
0B38:  MOVF   x3B,W
0B3A:  ADDWF  x4E,W
0B3C:  MOVWF  FE9
0B3E:  MOVF   x3C,W
0B40:  ADDWFC x4F,W
0B42:  MOVWF  FEA
0B44:  MOVFF  FEF,850
0B48:  MOVLW  09
0B4A:  ADDWF  x3D,W
0B4C:  MOVWF  x51
0B4E:  MOVLW  00
0B50:  ADDWFC x3E,W
0B52:  MOVWF  x52
0B54:  MOVF   x3B,W
0B56:  ADDWF  x51,W
0B58:  MOVWF  FE9
0B5A:  MOVF   x3C,W
0B5C:  ADDWFC x52,W
0B5E:  MOVWF  FEA
0B60:  MOVFF  FEF,853
0B64:  MOVLW  08
0B66:  ADDWF  x3D,W
0B68:  MOVWF  x54
0B6A:  MOVLW  00
0B6C:  ADDWFC x3E,W
0B6E:  MOVWF  x55
0B70:  MOVF   x3B,W
0B72:  ADDWF  x54,W
0B74:  MOVWF  FE9
0B76:  MOVF   x3C,W
0B78:  ADDWFC x55,W
0B7A:  MOVWF  FEA
0B7C:  MOVFF  FEF,856
0B80:  MOVLW  07
0B82:  ADDWF  x3D,W
0B84:  MOVWF  x57
0B86:  MOVLW  00
0B88:  ADDWFC x3E,W
0B8A:  MOVWF  x58
0B8C:  MOVF   x3B,W
0B8E:  ADDWF  x57,W
0B90:  MOVWF  FE9
0B92:  MOVF   x3C,W
0B94:  ADDWFC x58,W
0B96:  MOVWF  FEA
0B98:  MOVFF  FEF,859
0B9C:  CLRF   x5A
0B9E:  MOVFF  847,85B
0BA2:  MOVFF  84A,85C
0BA6:  MOVFF  84D,85D
0BAA:  MOVFF  850,85E
0BAE:  MOVFF  853,85F
0BB2:  MOVFF  856,860
0BB6:  MOVFF  859,861
0BBA:  MOVLB  0
0BBC:  RCALL  0668
0BBE:  MOVFF  01,842
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0BC2:  MOVLB  8
0BC4:  MOVF   x41,W
0BC6:  SUBLW  45
0BC8:  BTFSS  FD8.2
0BCA:  BRA    0D2A
0BCC:  MOVF   x42,W
0BCE:  SUBLW  7C
0BD0:  BTFSC  FD8.2
0BD2:  BRA    0D2A
0BD4:  MOVF   x42,W
0BD6:  SUBLW  3E
0BD8:  BTFSC  FD8.2
0BDA:  BRA    0D2A
0BDC:  MOVF   x42,W
0BDE:  SUBLW  1F
0BE0:  BTFSC  FD8.2
0BE2:  BRA    0D2A
....................          { 
....................             j=i; 
0BE4:  MOVFF  83E,840
0BE8:  MOVFF  83D,83F
....................             CRC=1; 
0BEC:  MOVLW  01
0BEE:  MOVWF  x44
....................             temp2=temp; 
0BF0:  MOVFF  841,843
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0BF4:  MOVF   x43,W
0BF6:  SUBLW  1F
0BF8:  BTFSC  FD8.2
0BFA:  BRA    0D14
0BFC:  MOVF   x40,W
0BFE:  SUBLW  03
0C00:  BTFSS  FD8.0
0C02:  BRA    0D14
0C04:  BNZ   0C0E
0C06:  MOVF   x3F,W
0C08:  SUBLW  E7
0C0A:  BTFSS  FD8.0
0C0C:  BRA    0D14
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C0E:  CLRF   x45
0C10:  MOVFF  840,847
0C14:  MOVFF  83F,846
0C18:  MOVFF  83C,849
0C1C:  MOVFF  83B,848
0C20:  MOVLB  0
0C22:  RCALL  06CE
0C24:  MOVF   01,W
0C26:  MOVLB  8
0C28:  ANDWF  x44,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C2A:  MOVLW  06
0C2C:  ADDWF  x3F,W
0C2E:  MOVWF  x45
0C30:  MOVLW  00
0C32:  ADDWFC x40,W
0C34:  MOVWF  x46
0C36:  MOVF   x3B,W
0C38:  ADDWF  x45,W
0C3A:  MOVWF  FE9
0C3C:  MOVF   x3C,W
0C3E:  ADDWFC x46,W
0C40:  MOVWF  FEA
0C42:  MOVFF  FEF,847
0C46:  MOVLW  05
0C48:  ADDWF  x3F,W
0C4A:  MOVWF  x48
0C4C:  MOVLW  00
0C4E:  ADDWFC x40,W
0C50:  MOVWF  x49
0C52:  MOVF   x3B,W
0C54:  ADDWF  x48,W
0C56:  MOVWF  FE9
0C58:  MOVF   x3C,W
0C5A:  ADDWFC x49,W
0C5C:  MOVWF  FEA
0C5E:  MOVFF  FEF,84A
0C62:  MOVLW  04
0C64:  ADDWF  x3F,W
0C66:  MOVWF  x4B
0C68:  MOVLW  00
0C6A:  ADDWFC x40,W
0C6C:  MOVWF  x4C
0C6E:  MOVF   x3B,W
0C70:  ADDWF  x4B,W
0C72:  MOVWF  FE9
0C74:  MOVF   x3C,W
0C76:  ADDWFC x4C,W
0C78:  MOVWF  FEA
0C7A:  MOVFF  FEF,84D
0C7E:  MOVLW  03
0C80:  ADDWF  x3F,W
0C82:  MOVWF  x4E
0C84:  MOVLW  00
0C86:  ADDWFC x40,W
0C88:  MOVWF  x4F
0C8A:  MOVF   x3B,W
0C8C:  ADDWF  x4E,W
0C8E:  MOVWF  FE9
0C90:  MOVF   x3C,W
0C92:  ADDWFC x4F,W
0C94:  MOVWF  FEA
0C96:  MOVFF  FEF,850
0C9A:  MOVLW  02
0C9C:  ADDWF  x3F,W
0C9E:  MOVWF  x51
0CA0:  MOVLW  00
0CA2:  ADDWFC x40,W
0CA4:  MOVWF  x52
0CA6:  MOVF   x3B,W
0CA8:  ADDWF  x51,W
0CAA:  MOVWF  FE9
0CAC:  MOVF   x3C,W
0CAE:  ADDWFC x52,W
0CB0:  MOVWF  FEA
0CB2:  MOVFF  FEF,853
0CB6:  MOVLW  01
0CB8:  ADDWF  x3F,W
0CBA:  MOVWF  x54
0CBC:  MOVLW  00
0CBE:  ADDWFC x40,W
0CC0:  MOVWF  x55
0CC2:  MOVF   x3B,W
0CC4:  ADDWF  x54,W
0CC6:  MOVWF  FE9
0CC8:  MOVF   x3C,W
0CCA:  ADDWFC x55,W
0CCC:  MOVWF  FEA
0CCE:  MOVFF  FEF,856
0CD2:  MOVF   x3B,W
0CD4:  ADDWF  x3F,W
0CD6:  MOVWF  FE9
0CD8:  MOVF   x3C,W
0CDA:  ADDWFC x40,W
0CDC:  MOVWF  FEA
0CDE:  MOVFF  FEF,857
0CE2:  CLRF   x5A
0CE4:  MOVFF  847,85B
0CE8:  MOVFF  84A,85C
0CEC:  MOVFF  84D,85D
0CF0:  MOVFF  850,85E
0CF4:  MOVFF  853,85F
0CF8:  MOVFF  856,860
0CFC:  MOVFF  857,861
0D00:  MOVLB  0
0D02:  RCALL  0668
0D04:  MOVFF  01,843
....................                j=j+7; 
0D08:  MOVLW  07
0D0A:  MOVLB  8
0D0C:  ADDWF  x3F,F
0D0E:  MOVLW  00
0D10:  ADDWFC x40,F
....................             } 
0D12:  BRA    0BF4
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D14:  DECFSZ x44,W
0D16:  BRA    0D2A
....................             { 
....................                dir=0; 
0D18:  MOVLB  6
0D1A:  CLRF   xC4
....................                return i; 
0D1C:  MOVLB  8
0D1E:  MOVFF  83D,01
0D22:  MOVFF  83E,02
0D26:  GOTO   15BC
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0D2A:  BRA    0F9E
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0D2C:  MOVLW  04
0D2E:  ADDWF  x3D,W
0D30:  MOVWF  x45
0D32:  MOVLW  00
0D34:  ADDWFC x3E,W
0D36:  MOVWF  x46
0D38:  MOVF   x3B,W
0D3A:  ADDWF  x45,W
0D3C:  MOVWF  FE9
0D3E:  MOVF   x3C,W
0D40:  ADDWFC x46,W
0D42:  MOVWF  FEA
0D44:  MOVFF  FEF,847
0D48:  MOVLW  03
0D4A:  ADDWF  x3D,W
0D4C:  MOVWF  x48
0D4E:  MOVLW  00
0D50:  ADDWFC x3E,W
0D52:  MOVWF  x49
0D54:  MOVF   x3B,W
0D56:  ADDWF  x48,W
0D58:  MOVWF  FE9
0D5A:  MOVF   x3C,W
0D5C:  ADDWFC x49,W
0D5E:  MOVWF  FEA
0D60:  MOVFF  FEF,84A
0D64:  MOVLW  02
0D66:  ADDWF  x3D,W
0D68:  MOVWF  x4B
0D6A:  MOVLW  00
0D6C:  ADDWFC x3E,W
0D6E:  MOVWF  x4C
0D70:  MOVF   x3B,W
0D72:  ADDWF  x4B,W
0D74:  MOVWF  FE9
0D76:  MOVF   x3C,W
0D78:  ADDWFC x4C,W
0D7A:  MOVWF  FEA
0D7C:  MOVFF  FEF,84D
0D80:  MOVLW  01
0D82:  ADDWF  x3D,W
0D84:  MOVWF  x4E
0D86:  MOVLW  00
0D88:  ADDWFC x3E,W
0D8A:  MOVWF  x4F
0D8C:  MOVF   x3B,W
0D8E:  ADDWF  x4E,W
0D90:  MOVWF  FE9
0D92:  MOVF   x3C,W
0D94:  ADDWFC x4F,W
0D96:  MOVWF  FEA
0D98:  MOVFF  FEF,850
0D9C:  MOVF   x3B,W
0D9E:  ADDWF  x3D,W
0DA0:  MOVWF  FE9
0DA2:  MOVF   x3C,W
0DA4:  ADDWFC x3E,W
0DA6:  MOVWF  FEA
0DA8:  MOVFF  FEF,851
0DAC:  CLRF   x5A
0DAE:  CLRF   x5B
0DB0:  CLRF   x5C
0DB2:  MOVFF  847,85D
0DB6:  MOVFF  84A,85E
0DBA:  MOVFF  84D,85F
0DBE:  MOVFF  850,860
0DC2:  MOVFF  851,861
0DC6:  MOVLB  0
0DC8:  RCALL  0668
0DCA:  MOVFF  01,841
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0DCE:  MOVLW  09
0DD0:  MOVLB  8
0DD2:  ADDWF  x3D,W
0DD4:  MOVWF  x45
0DD6:  MOVLW  00
0DD8:  ADDWFC x3E,W
0DDA:  MOVWF  x46
0DDC:  MOVF   x3B,W
0DDE:  ADDWF  x45,W
0DE0:  MOVWF  FE9
0DE2:  MOVF   x3C,W
0DE4:  ADDWFC x46,W
0DE6:  MOVWF  FEA
0DE8:  MOVFF  FEF,847
0DEC:  MOVLW  08
0DEE:  ADDWF  x3D,W
0DF0:  MOVWF  x48
0DF2:  MOVLW  00
0DF4:  ADDWFC x3E,W
0DF6:  MOVWF  x49
0DF8:  MOVF   x3B,W
0DFA:  ADDWF  x48,W
0DFC:  MOVWF  FE9
0DFE:  MOVF   x3C,W
0E00:  ADDWFC x49,W
0E02:  MOVWF  FEA
0E04:  MOVFF  FEF,84A
0E08:  MOVLW  07
0E0A:  ADDWF  x3D,W
0E0C:  MOVWF  x4B
0E0E:  MOVLW  00
0E10:  ADDWFC x3E,W
0E12:  MOVWF  x4C
0E14:  MOVF   x3B,W
0E16:  ADDWF  x4B,W
0E18:  MOVWF  FE9
0E1A:  MOVF   x3C,W
0E1C:  ADDWFC x4C,W
0E1E:  MOVWF  FEA
0E20:  MOVFF  FEF,84D
0E24:  MOVLW  06
0E26:  ADDWF  x3D,W
0E28:  MOVWF  x4E
0E2A:  MOVLW  00
0E2C:  ADDWFC x3E,W
0E2E:  MOVWF  x4F
0E30:  MOVF   x3B,W
0E32:  ADDWF  x4E,W
0E34:  MOVWF  FE9
0E36:  MOVF   x3C,W
0E38:  ADDWFC x4F,W
0E3A:  MOVWF  FEA
0E3C:  MOVFF  FEF,850
0E40:  MOVLW  05
0E42:  ADDWF  x3D,W
0E44:  MOVWF  x51
0E46:  MOVLW  00
0E48:  ADDWFC x3E,W
0E4A:  MOVWF  x52
0E4C:  MOVF   x3B,W
0E4E:  ADDWF  x51,W
0E50:  MOVWF  FE9
0E52:  MOVF   x3C,W
0E54:  ADDWFC x52,W
0E56:  MOVWF  FEA
0E58:  MOVFF  FEF,853
0E5C:  CLRF   x5A
0E5E:  CLRF   x5B
0E60:  CLRF   x5C
0E62:  MOVFF  847,85D
0E66:  MOVFF  84A,85E
0E6A:  MOVFF  84D,85F
0E6E:  MOVFF  850,860
0E72:  MOVFF  853,861
0E76:  MOVLB  0
0E78:  CALL   0668
0E7C:  MOVFF  01,842
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0E80:  MOVLB  8
0E82:  MOVF   x41,W
0E84:  SUBLW  0B
0E86:  BTFSS  FD8.2
0E88:  BRA    0F9E
0E8A:  MOVF   x42,W
0E8C:  SUBLW  1F
0E8E:  BTFSC  FD8.2
0E90:  BRA    0F9E
0E92:  MOVF   x42,W
0E94:  SUBLW  0F
0E96:  BTFSC  FD8.2
0E98:  BRA    0F9E
....................             { 
....................                j=i; 
0E9A:  MOVFF  83E,840
0E9E:  MOVFF  83D,83F
....................                CRC=1; 
0EA2:  MOVLW  01
0EA4:  MOVWF  x44
....................                temp2=temp; 
0EA6:  MOVFF  841,843
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0EAA:  MOVF   x43,W
0EAC:  SUBLW  1F
0EAE:  BZ    0F8A
0EB0:  MOVF   x40,W
0EB2:  SUBLW  01
0EB4:  BNC   0F8A
0EB6:  BNZ   0EBE
0EB8:  MOVF   x3F,W
0EBA:  SUBLW  F3
0EBC:  BNC   0F8A
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0EBE:  CLRF   x45
0EC0:  MOVFF  840,847
0EC4:  MOVFF  83F,846
0EC8:  MOVFF  83C,849
0ECC:  MOVFF  83B,848
0ED0:  MOVLB  0
0ED2:  RCALL  087E
0ED4:  MOVF   01,W
0ED6:  MOVLB  8
0ED8:  ANDWF  x44,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0EDA:  MOVLW  04
0EDC:  ADDWF  x3F,W
0EDE:  MOVWF  x45
0EE0:  MOVLW  00
0EE2:  ADDWFC x40,W
0EE4:  MOVWF  x46
0EE6:  MOVF   x3B,W
0EE8:  ADDWF  x45,W
0EEA:  MOVWF  FE9
0EEC:  MOVF   x3C,W
0EEE:  ADDWFC x46,W
0EF0:  MOVWF  FEA
0EF2:  MOVFF  FEF,847
0EF6:  MOVLW  03
0EF8:  ADDWF  x3F,W
0EFA:  MOVWF  x48
0EFC:  MOVLW  00
0EFE:  ADDWFC x40,W
0F00:  MOVWF  x49
0F02:  MOVF   x3B,W
0F04:  ADDWF  x48,W
0F06:  MOVWF  FE9
0F08:  MOVF   x3C,W
0F0A:  ADDWFC x49,W
0F0C:  MOVWF  FEA
0F0E:  MOVFF  FEF,84A
0F12:  MOVLW  02
0F14:  ADDWF  x3F,W
0F16:  MOVWF  x4B
0F18:  MOVLW  00
0F1A:  ADDWFC x40,W
0F1C:  MOVWF  x4C
0F1E:  MOVF   x3B,W
0F20:  ADDWF  x4B,W
0F22:  MOVWF  FE9
0F24:  MOVF   x3C,W
0F26:  ADDWFC x4C,W
0F28:  MOVWF  FEA
0F2A:  MOVFF  FEF,84D
0F2E:  MOVLW  01
0F30:  ADDWF  x3F,W
0F32:  MOVWF  x4E
0F34:  MOVLW  00
0F36:  ADDWFC x40,W
0F38:  MOVWF  x4F
0F3A:  MOVF   x3B,W
0F3C:  ADDWF  x4E,W
0F3E:  MOVWF  FE9
0F40:  MOVF   x3C,W
0F42:  ADDWFC x4F,W
0F44:  MOVWF  FEA
0F46:  MOVFF  FEF,850
0F4A:  MOVF   x3B,W
0F4C:  ADDWF  x3F,W
0F4E:  MOVWF  FE9
0F50:  MOVF   x3C,W
0F52:  ADDWFC x40,W
0F54:  MOVWF  FEA
0F56:  MOVFF  FEF,851
0F5A:  CLRF   x5A
0F5C:  CLRF   x5B
0F5E:  CLRF   x5C
0F60:  MOVFF  847,85D
0F64:  MOVFF  84A,85E
0F68:  MOVFF  84D,85F
0F6C:  MOVFF  850,860
0F70:  MOVFF  851,861
0F74:  MOVLB  0
0F76:  CALL   0668
0F7A:  MOVFF  01,843
....................                   j=j+5; 
0F7E:  MOVLW  05
0F80:  MOVLB  8
0F82:  ADDWF  x3F,F
0F84:  MOVLW  00
0F86:  ADDWFC x40,F
....................                } 
0F88:  BRA    0EAA
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0F8A:  DECFSZ x44,W
0F8C:  BRA    0F9E
....................                { 
....................                   dir=0; 
0F8E:  MOVLB  6
0F90:  CLRF   xC4
....................                   return i; 
0F92:  MOVLB  8
0F94:  MOVFF  83D,01
0F98:  MOVFF  83E,02
0F9C:  BRA    15BC
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0F9E:  INCF   x3D,F
0FA0:  BTFSC  FD8.2
0FA2:  INCF   x3E,F
0FA4:  BRA    09CC
....................    for(i=end_point;i>end_point/4;i--) 
0FA6:  MOVFF  83A,83E
0FAA:  MOVFF  839,83D
0FAE:  RRCF   x3A,W
0FB0:  MOVWF  03
0FB2:  RRCF   x39,W
0FB4:  MOVWF  02
0FB6:  RRCF   03,F
0FB8:  RRCF   02,F
0FBA:  MOVLW  3F
0FBC:  ANDWF  03,F
0FBE:  MOVFF  02,01
0FC2:  MOVF   03,W
0FC4:  SUBWF  x3E,W
0FC6:  BTFSS  FD8.0
0FC8:  BRA    15B6
0FCA:  BNZ   0FD4
0FCC:  MOVF   x3D,W
0FCE:  SUBWF  01,W
0FD0:  BTFSC  FD8.0
0FD2:  BRA    15B6
....................    { 
....................       if(track==0) 
0FD4:  MOVF   x38,F
0FD6:  BTFSS  FD8.2
0FD8:  BRA    132C
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
0FDA:  MOVLW  06
0FDC:  SUBWF  x3D,W
0FDE:  MOVWF  x45
0FE0:  MOVLW  00
0FE2:  SUBWFB x3E,W
0FE4:  MOVWF  x46
0FE6:  MOVF   x3B,W
0FE8:  ADDWF  x45,W
0FEA:  MOVWF  FE9
0FEC:  MOVF   x3C,W
0FEE:  ADDWFC x46,W
0FF0:  MOVWF  FEA
0FF2:  MOVFF  FEF,847
0FF6:  MOVLW  05
0FF8:  SUBWF  x3D,W
0FFA:  MOVWF  x48
0FFC:  MOVLW  00
0FFE:  SUBWFB x3E,W
1000:  MOVWF  x49
1002:  MOVF   x3B,W
1004:  ADDWF  x48,W
1006:  MOVWF  FE9
1008:  MOVF   x3C,W
100A:  ADDWFC x49,W
100C:  MOVWF  FEA
100E:  MOVFF  FEF,84A
1012:  MOVLW  04
1014:  SUBWF  x3D,W
1016:  MOVWF  x4B
1018:  MOVLW  00
101A:  SUBWFB x3E,W
101C:  MOVWF  x4C
101E:  MOVF   x3B,W
1020:  ADDWF  x4B,W
1022:  MOVWF  FE9
1024:  MOVF   x3C,W
1026:  ADDWFC x4C,W
1028:  MOVWF  FEA
102A:  MOVFF  FEF,84D
102E:  MOVLW  03
1030:  SUBWF  x3D,W
1032:  MOVWF  x4E
1034:  MOVLW  00
1036:  SUBWFB x3E,W
1038:  MOVWF  x4F
103A:  MOVF   x3B,W
103C:  ADDWF  x4E,W
103E:  MOVWF  FE9
1040:  MOVF   x3C,W
1042:  ADDWFC x4F,W
1044:  MOVWF  FEA
1046:  MOVFF  FEF,850
104A:  MOVLW  02
104C:  SUBWF  x3D,W
104E:  MOVWF  x51
1050:  MOVLW  00
1052:  SUBWFB x3E,W
1054:  MOVWF  x52
1056:  MOVF   x3B,W
1058:  ADDWF  x51,W
105A:  MOVWF  FE9
105C:  MOVF   x3C,W
105E:  ADDWFC x52,W
1060:  MOVWF  FEA
1062:  MOVFF  FEF,853
1066:  MOVLW  01
1068:  SUBWF  x3D,W
106A:  MOVWF  x54
106C:  MOVLW  00
106E:  SUBWFB x3E,W
1070:  MOVWF  x55
1072:  MOVF   x3B,W
1074:  ADDWF  x54,W
1076:  MOVWF  FE9
1078:  MOVF   x3C,W
107A:  ADDWFC x55,W
107C:  MOVWF  FEA
107E:  MOVFF  FEF,856
1082:  MOVF   x3B,W
1084:  ADDWF  x3D,W
1086:  MOVWF  FE9
1088:  MOVF   x3C,W
108A:  ADDWFC x3E,W
108C:  MOVWF  FEA
108E:  MOVFF  FEF,857
1092:  CLRF   x5A
1094:  MOVFF  847,85B
1098:  MOVFF  84A,85C
109C:  MOVFF  84D,85D
10A0:  MOVFF  850,85E
10A4:  MOVFF  853,85F
10A8:  MOVFF  856,860
10AC:  MOVFF  857,861
10B0:  MOVLB  0
10B2:  CALL   0668
10B6:  MOVFF  01,841
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
10BA:  MOVLW  0D
10BC:  MOVLB  8
10BE:  SUBWF  x3D,W
10C0:  MOVWF  x45
10C2:  MOVLW  00
10C4:  SUBWFB x3E,W
10C6:  MOVWF  x46
10C8:  MOVF   x3B,W
10CA:  ADDWF  x45,W
10CC:  MOVWF  FE9
10CE:  MOVF   x3C,W
10D0:  ADDWFC x46,W
10D2:  MOVWF  FEA
10D4:  MOVFF  FEF,847
10D8:  MOVLW  0C
10DA:  SUBWF  x3D,W
10DC:  MOVWF  x48
10DE:  MOVLW  00
10E0:  SUBWFB x3E,W
10E2:  MOVWF  x49
10E4:  MOVF   x3B,W
10E6:  ADDWF  x48,W
10E8:  MOVWF  FE9
10EA:  MOVF   x3C,W
10EC:  ADDWFC x49,W
10EE:  MOVWF  FEA
10F0:  MOVFF  FEF,84A
10F4:  MOVLW  0B
10F6:  SUBWF  x3D,W
10F8:  MOVWF  x4B
10FA:  MOVLW  00
10FC:  SUBWFB x3E,W
10FE:  MOVWF  x4C
1100:  MOVF   x3B,W
1102:  ADDWF  x4B,W
1104:  MOVWF  FE9
1106:  MOVF   x3C,W
1108:  ADDWFC x4C,W
110A:  MOVWF  FEA
110C:  MOVFF  FEF,84D
1110:  MOVLW  0A
1112:  SUBWF  x3D,W
1114:  MOVWF  x4E
1116:  MOVLW  00
1118:  SUBWFB x3E,W
111A:  MOVWF  x4F
111C:  MOVF   x3B,W
111E:  ADDWF  x4E,W
1120:  MOVWF  FE9
1122:  MOVF   x3C,W
1124:  ADDWFC x4F,W
1126:  MOVWF  FEA
1128:  MOVFF  FEF,850
112C:  MOVLW  09
112E:  SUBWF  x3D,W
1130:  MOVWF  x51
1132:  MOVLW  00
1134:  SUBWFB x3E,W
1136:  MOVWF  x52
1138:  MOVF   x3B,W
113A:  ADDWF  x51,W
113C:  MOVWF  FE9
113E:  MOVF   x3C,W
1140:  ADDWFC x52,W
1142:  MOVWF  FEA
1144:  MOVFF  FEF,853
1148:  MOVLW  08
114A:  SUBWF  x3D,W
114C:  MOVWF  x54
114E:  MOVLW  00
1150:  SUBWFB x3E,W
1152:  MOVWF  x55
1154:  MOVF   x3B,W
1156:  ADDWF  x54,W
1158:  MOVWF  FE9
115A:  MOVF   x3C,W
115C:  ADDWFC x55,W
115E:  MOVWF  FEA
1160:  MOVFF  FEF,856
1164:  MOVLW  07
1166:  SUBWF  x3D,W
1168:  MOVWF  x57
116A:  MOVLW  00
116C:  SUBWFB x3E,W
116E:  MOVWF  x58
1170:  MOVF   x3B,W
1172:  ADDWF  x57,W
1174:  MOVWF  FE9
1176:  MOVF   x3C,W
1178:  ADDWFC x58,W
117A:  MOVWF  FEA
117C:  MOVFF  FEF,859
1180:  CLRF   x5A
1182:  MOVFF  847,85B
1186:  MOVFF  84A,85C
118A:  MOVFF  84D,85D
118E:  MOVFF  850,85E
1192:  MOVFF  853,85F
1196:  MOVFF  856,860
119A:  MOVFF  859,861
119E:  MOVLB  0
11A0:  CALL   0668
11A4:  MOVFF  01,842
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
11A8:  MOVLB  8
11AA:  MOVF   x41,W
11AC:  SUBLW  45
11AE:  BTFSS  FD8.2
11B0:  BRA    132A
11B2:  MOVF   x42,W
11B4:  SUBLW  7C
11B6:  BTFSC  FD8.2
11B8:  BRA    132A
11BA:  MOVF   x42,W
11BC:  SUBLW  3E
11BE:  BTFSC  FD8.2
11C0:  BRA    132A
11C2:  MOVF   x42,W
11C4:  SUBLW  1F
11C6:  BTFSC  FD8.2
11C8:  BRA    132A
11CA:  MOVF   x42,W
11CC:  SUBLW  0F
11CE:  BTFSC  FD8.2
11D0:  BRA    132A
11D2:  MOVF   x42,W
11D4:  SUBLW  78
11D6:  BTFSC  FD8.2
11D8:  BRA    132A
....................          { 
....................             j=i; 
11DA:  MOVFF  83E,840
11DE:  MOVFF  83D,83F
....................             CRC=1; 
11E2:  MOVLW  01
11E4:  MOVWF  x44
....................             temp2=temp; 
11E6:  MOVFF  841,843
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
11EA:  MOVF   x43,W
11EC:  SUBLW  1F
11EE:  BTFSC  FD8.2
11F0:  BRA    130A
11F2:  MOVF   x40,F
11F4:  BNZ   11FE
11F6:  MOVF   x3F,W
11F8:  SUBLW  01
11FA:  BTFSC  FD8.0
11FC:  BRA    130A
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
11FE:  MOVLW  01
1200:  MOVWF  x45
1202:  MOVFF  840,847
1206:  MOVFF  83F,846
120A:  MOVFF  83C,849
120E:  MOVFF  83B,848
1212:  MOVLB  0
1214:  CALL   06CE
1218:  MOVF   01,W
121A:  MOVLB  8
121C:  ANDWF  x44,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
121E:  MOVLW  06
1220:  SUBWF  x3F,W
1222:  MOVWF  x45
1224:  MOVLW  00
1226:  SUBWFB x40,W
1228:  MOVWF  x46
122A:  MOVF   x3B,W
122C:  ADDWF  x45,W
122E:  MOVWF  FE9
1230:  MOVF   x3C,W
1232:  ADDWFC x46,W
1234:  MOVWF  FEA
1236:  MOVFF  FEF,847
123A:  MOVLW  05
123C:  SUBWF  x3F,W
123E:  MOVWF  x48
1240:  MOVLW  00
1242:  SUBWFB x40,W
1244:  MOVWF  x49
1246:  MOVF   x3B,W
1248:  ADDWF  x48,W
124A:  MOVWF  FE9
124C:  MOVF   x3C,W
124E:  ADDWFC x49,W
1250:  MOVWF  FEA
1252:  MOVFF  FEF,84A
1256:  MOVLW  04
1258:  SUBWF  x3F,W
125A:  MOVWF  x4B
125C:  MOVLW  00
125E:  SUBWFB x40,W
1260:  MOVWF  x4C
1262:  MOVF   x3B,W
1264:  ADDWF  x4B,W
1266:  MOVWF  FE9
1268:  MOVF   x3C,W
126A:  ADDWFC x4C,W
126C:  MOVWF  FEA
126E:  MOVFF  FEF,84D
1272:  MOVLW  03
1274:  SUBWF  x3F,W
1276:  MOVWF  x4E
1278:  MOVLW  00
127A:  SUBWFB x40,W
127C:  MOVWF  x4F
127E:  MOVF   x3B,W
1280:  ADDWF  x4E,W
1282:  MOVWF  FE9
1284:  MOVF   x3C,W
1286:  ADDWFC x4F,W
1288:  MOVWF  FEA
128A:  MOVFF  FEF,850
128E:  MOVLW  02
1290:  SUBWF  x3F,W
1292:  MOVWF  x51
1294:  MOVLW  00
1296:  SUBWFB x40,W
1298:  MOVWF  x52
129A:  MOVF   x3B,W
129C:  ADDWF  x51,W
129E:  MOVWF  FE9
12A0:  MOVF   x3C,W
12A2:  ADDWFC x52,W
12A4:  MOVWF  FEA
12A6:  MOVFF  FEF,853
12AA:  MOVLW  01
12AC:  SUBWF  x3F,W
12AE:  MOVWF  x54
12B0:  MOVLW  00
12B2:  SUBWFB x40,W
12B4:  MOVWF  x55
12B6:  MOVF   x3B,W
12B8:  ADDWF  x54,W
12BA:  MOVWF  FE9
12BC:  MOVF   x3C,W
12BE:  ADDWFC x55,W
12C0:  MOVWF  FEA
12C2:  MOVFF  FEF,856
12C6:  MOVF   x3B,W
12C8:  ADDWF  x3F,W
12CA:  MOVWF  FE9
12CC:  MOVF   x3C,W
12CE:  ADDWFC x40,W
12D0:  MOVWF  FEA
12D2:  MOVFF  FEF,857
12D6:  CLRF   x5A
12D8:  MOVFF  847,85B
12DC:  MOVFF  84A,85C
12E0:  MOVFF  84D,85D
12E4:  MOVFF  850,85E
12E8:  MOVFF  853,85F
12EC:  MOVFF  856,860
12F0:  MOVFF  857,861
12F4:  MOVLB  0
12F6:  CALL   0668
12FA:  MOVFF  01,843
....................                j=j-7;             
12FE:  MOVLW  07
1300:  MOVLB  8
1302:  SUBWF  x3F,F
1304:  MOVLW  00
1306:  SUBWFB x40,F
....................              } 
1308:  BRA    11EA
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
130A:  DECFSZ x44,W
130C:  BRA    1322
....................             { 
....................                dir=1; 
130E:  MOVLW  01
1310:  MOVLB  6
1312:  MOVWF  xC4
....................                return i; 
1314:  MOVLB  8
1316:  MOVFF  83D,01
131A:  MOVFF  83E,02
131E:  BRA    15BC
....................             } 
....................             else return 0; 
1320:  BRA    132A
1322:  MOVLW  00
1324:  MOVWF  01
1326:  MOVWF  02
1328:  BRA    15BC
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
132A:  BRA    15AC
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
132C:  MOVLW  04
132E:  SUBWF  x3D,W
1330:  MOVWF  x45
1332:  MOVLW  00
1334:  SUBWFB x3E,W
1336:  MOVWF  x46
1338:  MOVF   x3B,W
133A:  ADDWF  x45,W
133C:  MOVWF  FE9
133E:  MOVF   x3C,W
1340:  ADDWFC x46,W
1342:  MOVWF  FEA
1344:  MOVFF  FEF,847
1348:  MOVLW  03
134A:  SUBWF  x3D,W
134C:  MOVWF  x48
134E:  MOVLW  00
1350:  SUBWFB x3E,W
1352:  MOVWF  x49
1354:  MOVF   x3B,W
1356:  ADDWF  x48,W
1358:  MOVWF  FE9
135A:  MOVF   x3C,W
135C:  ADDWFC x49,W
135E:  MOVWF  FEA
1360:  MOVFF  FEF,84A
1364:  MOVLW  02
1366:  SUBWF  x3D,W
1368:  MOVWF  x4B
136A:  MOVLW  00
136C:  SUBWFB x3E,W
136E:  MOVWF  x4C
1370:  MOVF   x3B,W
1372:  ADDWF  x4B,W
1374:  MOVWF  FE9
1376:  MOVF   x3C,W
1378:  ADDWFC x4C,W
137A:  MOVWF  FEA
137C:  MOVFF  FEF,84D
1380:  MOVLW  01
1382:  SUBWF  x3D,W
1384:  MOVWF  x4E
1386:  MOVLW  00
1388:  SUBWFB x3E,W
138A:  MOVWF  x4F
138C:  MOVF   x3B,W
138E:  ADDWF  x4E,W
1390:  MOVWF  FE9
1392:  MOVF   x3C,W
1394:  ADDWFC x4F,W
1396:  MOVWF  FEA
1398:  MOVFF  FEF,850
139C:  MOVF   x3B,W
139E:  ADDWF  x3D,W
13A0:  MOVWF  FE9
13A2:  MOVF   x3C,W
13A4:  ADDWFC x3E,W
13A6:  MOVWF  FEA
13A8:  MOVFF  FEF,851
13AC:  CLRF   x5A
13AE:  CLRF   x5B
13B0:  CLRF   x5C
13B2:  MOVFF  847,85D
13B6:  MOVFF  84A,85E
13BA:  MOVFF  84D,85F
13BE:  MOVFF  850,860
13C2:  MOVFF  851,861
13C6:  MOVLB  0
13C8:  CALL   0668
13CC:  MOVFF  01,841
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
13D0:  MOVLW  09
13D2:  MOVLB  8
13D4:  SUBWF  x3D,W
13D6:  MOVWF  x45
13D8:  MOVLW  00
13DA:  SUBWFB x3E,W
13DC:  MOVWF  x46
13DE:  MOVF   x3B,W
13E0:  ADDWF  x45,W
13E2:  MOVWF  FE9
13E4:  MOVF   x3C,W
13E6:  ADDWFC x46,W
13E8:  MOVWF  FEA
13EA:  MOVFF  FEF,847
13EE:  MOVLW  08
13F0:  SUBWF  x3D,W
13F2:  MOVWF  x48
13F4:  MOVLW  00
13F6:  SUBWFB x3E,W
13F8:  MOVWF  x49
13FA:  MOVF   x3B,W
13FC:  ADDWF  x48,W
13FE:  MOVWF  FE9
1400:  MOVF   x3C,W
1402:  ADDWFC x49,W
1404:  MOVWF  FEA
1406:  MOVFF  FEF,84A
140A:  MOVLW  07
140C:  SUBWF  x3D,W
140E:  MOVWF  x4B
1410:  MOVLW  00
1412:  SUBWFB x3E,W
1414:  MOVWF  x4C
1416:  MOVF   x3B,W
1418:  ADDWF  x4B,W
141A:  MOVWF  FE9
141C:  MOVF   x3C,W
141E:  ADDWFC x4C,W
1420:  MOVWF  FEA
1422:  MOVFF  FEF,84D
1426:  MOVLW  06
1428:  SUBWF  x3D,W
142A:  MOVWF  x4E
142C:  MOVLW  00
142E:  SUBWFB x3E,W
1430:  MOVWF  x4F
1432:  MOVF   x3B,W
1434:  ADDWF  x4E,W
1436:  MOVWF  FE9
1438:  MOVF   x3C,W
143A:  ADDWFC x4F,W
143C:  MOVWF  FEA
143E:  MOVFF  FEF,850
1442:  MOVLW  05
1444:  SUBWF  x3D,W
1446:  MOVWF  x51
1448:  MOVLW  00
144A:  SUBWFB x3E,W
144C:  MOVWF  x52
144E:  MOVF   x3B,W
1450:  ADDWF  x51,W
1452:  MOVWF  FE9
1454:  MOVF   x3C,W
1456:  ADDWFC x52,W
1458:  MOVWF  FEA
145A:  MOVFF  FEF,853
145E:  CLRF   x5A
1460:  CLRF   x5B
1462:  CLRF   x5C
1464:  MOVFF  847,85D
1468:  MOVFF  84A,85E
146C:  MOVFF  84D,85F
1470:  MOVFF  850,860
1474:  MOVFF  853,861
1478:  MOVLB  0
147A:  CALL   0668
147E:  MOVFF  01,842
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
1482:  MOVLB  8
1484:  MOVF   x41,W
1486:  SUBLW  0B
1488:  BTFSS  FD8.2
148A:  BRA    15AC
148C:  MOVF   x42,W
148E:  SUBLW  1F
1490:  BTFSC  FD8.2
1492:  BRA    15AC
1494:  MOVF   x42,W
1496:  SUBLW  0F
1498:  BTFSC  FD8.2
149A:  BRA    15AC
....................             { 
....................                j=i; 
149C:  MOVFF  83E,840
14A0:  MOVFF  83D,83F
....................                CRC=1; 
14A4:  MOVLW  01
14A6:  MOVWF  x44
....................                temp2=temp; 
14A8:  MOVFF  841,843
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
14AC:  MOVF   x43,W
14AE:  SUBLW  1F
14B0:  BZ    158C
14B2:  MOVF   x40,F
14B4:  BNZ   14BC
14B6:  MOVF   x3F,W
14B8:  SUBLW  01
14BA:  BC    158C
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
14BC:  MOVLW  01
14BE:  MOVWF  x45
14C0:  MOVFF  840,847
14C4:  MOVFF  83F,846
14C8:  MOVFF  83C,849
14CC:  MOVFF  83B,848
14D0:  MOVLB  0
14D2:  CALL   087E
14D6:  MOVF   01,W
14D8:  MOVLB  8
14DA:  ANDWF  x44,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
14DC:  MOVLW  04
14DE:  SUBWF  x3F,W
14E0:  MOVWF  x45
14E2:  MOVLW  00
14E4:  SUBWFB x40,W
14E6:  MOVWF  x46
14E8:  MOVF   x3B,W
14EA:  ADDWF  x45,W
14EC:  MOVWF  FE9
14EE:  MOVF   x3C,W
14F0:  ADDWFC x46,W
14F2:  MOVWF  FEA
14F4:  MOVFF  FEF,847
14F8:  MOVLW  03
14FA:  SUBWF  x3F,W
14FC:  MOVWF  x48
14FE:  MOVLW  00
1500:  SUBWFB x40,W
1502:  MOVWF  x49
1504:  MOVF   x3B,W
1506:  ADDWF  x48,W
1508:  MOVWF  FE9
150A:  MOVF   x3C,W
150C:  ADDWFC x49,W
150E:  MOVWF  FEA
1510:  MOVFF  FEF,84A
1514:  MOVLW  02
1516:  SUBWF  x3F,W
1518:  MOVWF  x4B
151A:  MOVLW  00
151C:  SUBWFB x40,W
151E:  MOVWF  x4C
1520:  MOVF   x3B,W
1522:  ADDWF  x4B,W
1524:  MOVWF  FE9
1526:  MOVF   x3C,W
1528:  ADDWFC x4C,W
152A:  MOVWF  FEA
152C:  MOVFF  FEF,84D
1530:  MOVLW  01
1532:  SUBWF  x3F,W
1534:  MOVWF  x4E
1536:  MOVLW  00
1538:  SUBWFB x40,W
153A:  MOVWF  x4F
153C:  MOVF   x3B,W
153E:  ADDWF  x4E,W
1540:  MOVWF  FE9
1542:  MOVF   x3C,W
1544:  ADDWFC x4F,W
1546:  MOVWF  FEA
1548:  MOVFF  FEF,850
154C:  MOVF   x3B,W
154E:  ADDWF  x3F,W
1550:  MOVWF  FE9
1552:  MOVF   x3C,W
1554:  ADDWFC x40,W
1556:  MOVWF  FEA
1558:  MOVFF  FEF,851
155C:  CLRF   x5A
155E:  CLRF   x5B
1560:  CLRF   x5C
1562:  MOVFF  847,85D
1566:  MOVFF  84A,85E
156A:  MOVFF  84D,85F
156E:  MOVFF  850,860
1572:  MOVFF  851,861
1576:  MOVLB  0
1578:  CALL   0668
157C:  MOVFF  01,843
....................                   j=j-5; 
1580:  MOVLW  05
1582:  MOVLB  8
1584:  SUBWF  x3F,F
1586:  MOVLW  00
1588:  SUBWFB x40,F
....................                } 
158A:  BRA    14AC
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
158C:  DECFSZ x44,W
158E:  BRA    15A4
....................                { 
....................                   dir=1; 
1590:  MOVLW  01
1592:  MOVLB  6
1594:  MOVWF  xC4
....................                   return i; 
1596:  MOVLB  8
1598:  MOVFF  83D,01
159C:  MOVFF  83E,02
15A0:  BRA    15BC
....................                } 
....................                   else return 0; 
15A2:  BRA    15AC
15A4:  MOVLW  00
15A6:  MOVWF  01
15A8:  MOVWF  02
15AA:  BRA    15BC
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
15AC:  MOVF   x3D,W
15AE:  BTFSC  FD8.2
15B0:  DECF   x3E,F
15B2:  DECF   x3D,F
15B4:  BRA    0FAE
....................    return 0; 
15B6:  MOVLW  00
15B8:  MOVWF  01
15BA:  MOVWF  02
.................... } 
15BC:  MOVLB  0
15BE:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
3568:  MOVLB  8
356A:  CLRF   x37
356C:  MOVLW  01
356E:  MOVWF  x36
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3570:  MOVFF  82C,838
3574:  MOVFF  82E,83A
3578:  MOVFF  82D,839
357C:  MOVFF  830,83C
3580:  MOVFF  82F,83B
3584:  MOVLB  0
3586:  CALL   09BE
358A:  MOVFF  02,837
358E:  MOVFF  01,836
....................    if(temp==0) return 0; 
3592:  MOVLB  8
3594:  MOVF   x36,F
3596:  BNZ   35A2
3598:  MOVF   x37,F
359A:  BNZ   35A2
359C:  MOVLW  00
359E:  MOVWF  01
35A0:  BRA    394C
....................    j=temp; 
35A2:  MOVFF  837,835
35A6:  MOVFF  836,834
....................    if(dir==0) 
35AA:  MOVLB  6
35AC:  MOVF   xC4,F
35AE:  BTFSS  FD8.2
35B0:  BRA    376C
....................    { 
....................       if(track==0) 
35B2:  MOVLB  8
35B4:  MOVF   x2C,F
35B6:  BTFSS  FD8.2
35B8:  BRA    36B0
....................       { 
....................             for(i=0;i<79;i++) 
35BA:  CLRF   x33
35BC:  MOVF   x33,W
35BE:  SUBLW  4E
35C0:  BNC   36AE
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
35C2:  CLRF   03
35C4:  MOVF   x33,W
35C6:  ADDWF  x31,W
35C8:  MOVWF  01
35CA:  MOVF   x32,W
35CC:  ADDWFC 03,F
35CE:  MOVFF  01,838
35D2:  MOVFF  03,839
35D6:  MOVLW  05
35D8:  ADDWF  x34,W
35DA:  MOVWF  x3A
35DC:  MOVLW  00
35DE:  ADDWFC x35,W
35E0:  MOVWF  x3B
35E2:  MOVF   x2F,W
35E4:  ADDWF  x3A,W
35E6:  MOVWF  FE9
35E8:  MOVF   x30,W
35EA:  ADDWFC x3B,W
35EC:  MOVWF  FEA
35EE:  MOVFF  FEF,83C
35F2:  MOVLW  04
35F4:  ADDWF  x34,W
35F6:  MOVWF  x3D
35F8:  MOVLW  00
35FA:  ADDWFC x35,W
35FC:  MOVWF  x3E
35FE:  MOVF   x2F,W
3600:  ADDWF  x3D,W
3602:  MOVWF  FE9
3604:  MOVF   x30,W
3606:  ADDWFC x3E,W
3608:  MOVWF  FEA
360A:  MOVFF  FEF,83F
360E:  MOVLW  03
3610:  ADDWF  x34,W
3612:  MOVWF  x40
3614:  MOVLW  00
3616:  ADDWFC x35,W
3618:  MOVWF  x41
361A:  MOVF   x2F,W
361C:  ADDWF  x40,W
361E:  MOVWF  FE9
3620:  MOVF   x30,W
3622:  ADDWFC x41,W
3624:  MOVWF  FEA
3626:  MOVFF  FEF,842
362A:  MOVLW  02
362C:  ADDWF  x34,W
362E:  MOVWF  x43
3630:  MOVLW  00
3632:  ADDWFC x35,W
3634:  MOVWF  x44
3636:  MOVF   x2F,W
3638:  ADDWF  x43,W
363A:  MOVWF  FE9
363C:  MOVF   x30,W
363E:  ADDWFC x44,W
3640:  MOVWF  FEA
3642:  MOVFF  FEF,845
3646:  MOVLW  01
3648:  ADDWF  x34,W
364A:  MOVWF  x46
364C:  MOVLW  00
364E:  ADDWFC x35,W
3650:  MOVWF  x47
3652:  MOVF   x2F,W
3654:  ADDWF  x46,W
3656:  MOVWF  FE9
3658:  MOVF   x30,W
365A:  ADDWFC x47,W
365C:  MOVWF  FEA
365E:  MOVFF  FEF,848
3662:  MOVF   x2F,W
3664:  ADDWF  x34,W
3666:  MOVWF  FE9
3668:  MOVF   x30,W
366A:  ADDWFC x35,W
366C:  MOVWF  FEA
366E:  MOVFF  FEF,849
3672:  CLRF   x5A
3674:  CLRF   x5B
3676:  MOVFF  83C,85C
367A:  MOVFF  83F,85D
367E:  MOVFF  842,85E
3682:  MOVFF  845,85F
3686:  MOVFF  848,860
368A:  MOVFF  849,861
368E:  MOVLB  0
3690:  CALL   0668
3694:  MOVFF  839,FEA
3698:  MOVFF  838,FE9
369C:  MOVFF  01,FEF
....................                j=j+7; 
36A0:  MOVLW  07
36A2:  MOVLB  8
36A4:  ADDWF  x34,F
36A6:  MOVLW  00
36A8:  ADDWFC x35,F
....................             } 
36AA:  INCF   x33,F
36AC:  BRA    35BC
....................       } 
....................          else  
36AE:  BRA    3768
....................          { 
....................             for(i=0;i<40;i++) 
36B0:  CLRF   x33
36B2:  MOVF   x33,W
36B4:  SUBLW  27
36B6:  BNC   3768
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
36B8:  CLRF   03
36BA:  MOVF   x33,W
36BC:  ADDWF  x31,W
36BE:  MOVWF  01
36C0:  MOVF   x32,W
36C2:  ADDWFC 03,F
36C4:  MOVFF  01,838
36C8:  MOVFF  03,839
36CC:  MOVLW  03
36CE:  ADDWF  x34,W
36D0:  MOVWF  x3A
36D2:  MOVLW  00
36D4:  ADDWFC x35,W
36D6:  MOVWF  x3B
36D8:  MOVF   x2F,W
36DA:  ADDWF  x3A,W
36DC:  MOVWF  FE9
36DE:  MOVF   x30,W
36E0:  ADDWFC x3B,W
36E2:  MOVWF  FEA
36E4:  MOVFF  FEF,83C
36E8:  MOVLW  02
36EA:  ADDWF  x34,W
36EC:  MOVWF  x3D
36EE:  MOVLW  00
36F0:  ADDWFC x35,W
36F2:  MOVWF  x3E
36F4:  MOVF   x2F,W
36F6:  ADDWF  x3D,W
36F8:  MOVWF  FE9
36FA:  MOVF   x30,W
36FC:  ADDWFC x3E,W
36FE:  MOVWF  FEA
3700:  MOVFF  FEF,83F
3704:  MOVLW  01
3706:  ADDWF  x34,W
3708:  MOVWF  x40
370A:  MOVLW  00
370C:  ADDWFC x35,W
370E:  MOVWF  x41
3710:  MOVF   x2F,W
3712:  ADDWF  x40,W
3714:  MOVWF  FE9
3716:  MOVF   x30,W
3718:  ADDWFC x41,W
371A:  MOVWF  FEA
371C:  MOVFF  FEF,842
3720:  MOVF   x2F,W
3722:  ADDWF  x34,W
3724:  MOVWF  FE9
3726:  MOVF   x30,W
3728:  ADDWFC x35,W
372A:  MOVWF  FEA
372C:  MOVFF  FEF,843
3730:  CLRF   x5A
3732:  CLRF   x5B
3734:  CLRF   x5C
3736:  CLRF   x5D
3738:  MOVFF  83C,85E
373C:  MOVFF  83F,85F
3740:  MOVFF  842,860
3744:  MOVFF  843,861
3748:  MOVLB  0
374A:  CALL   0668
374E:  MOVFF  839,FEA
3752:  MOVFF  838,FE9
3756:  MOVFF  01,FEF
....................                j=j+5; 
375A:  MOVLW  05
375C:  MOVLB  8
375E:  ADDWF  x34,F
3760:  MOVLW  00
3762:  ADDWFC x35,F
....................             }          
3764:  INCF   x33,F
3766:  BRA    36B2
....................          } 
....................    } 
....................       else  
3768:  BRA    3922
376A:  MOVLB  6
....................       { 
....................          if(track==0) 
376C:  MOVLB  8
376E:  MOVF   x2C,F
3770:  BTFSS  FD8.2
3772:  BRA    386A
....................          { 
....................             for(i=0;i<79;i++) 
3774:  CLRF   x33
3776:  MOVF   x33,W
3778:  SUBLW  4E
377A:  BNC   3868
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
377C:  CLRF   03
377E:  MOVF   x33,W
3780:  ADDWF  x31,W
3782:  MOVWF  01
3784:  MOVF   x32,W
3786:  ADDWFC 03,F
3788:  MOVFF  01,838
378C:  MOVFF  03,839
3790:  MOVLW  05
3792:  SUBWF  x34,W
3794:  MOVWF  x3A
3796:  MOVLW  00
3798:  SUBWFB x35,W
379A:  MOVWF  x3B
379C:  MOVF   x2F,W
379E:  ADDWF  x3A,W
37A0:  MOVWF  FE9
37A2:  MOVF   x30,W
37A4:  ADDWFC x3B,W
37A6:  MOVWF  FEA
37A8:  MOVFF  FEF,83C
37AC:  MOVLW  04
37AE:  SUBWF  x34,W
37B0:  MOVWF  x3D
37B2:  MOVLW  00
37B4:  SUBWFB x35,W
37B6:  MOVWF  x3E
37B8:  MOVF   x2F,W
37BA:  ADDWF  x3D,W
37BC:  MOVWF  FE9
37BE:  MOVF   x30,W
37C0:  ADDWFC x3E,W
37C2:  MOVWF  FEA
37C4:  MOVFF  FEF,83F
37C8:  MOVLW  03
37CA:  SUBWF  x34,W
37CC:  MOVWF  x40
37CE:  MOVLW  00
37D0:  SUBWFB x35,W
37D2:  MOVWF  x41
37D4:  MOVF   x2F,W
37D6:  ADDWF  x40,W
37D8:  MOVWF  FE9
37DA:  MOVF   x30,W
37DC:  ADDWFC x41,W
37DE:  MOVWF  FEA
37E0:  MOVFF  FEF,842
37E4:  MOVLW  02
37E6:  SUBWF  x34,W
37E8:  MOVWF  x43
37EA:  MOVLW  00
37EC:  SUBWFB x35,W
37EE:  MOVWF  x44
37F0:  MOVF   x2F,W
37F2:  ADDWF  x43,W
37F4:  MOVWF  FE9
37F6:  MOVF   x30,W
37F8:  ADDWFC x44,W
37FA:  MOVWF  FEA
37FC:  MOVFF  FEF,845
3800:  MOVLW  01
3802:  SUBWF  x34,W
3804:  MOVWF  x46
3806:  MOVLW  00
3808:  SUBWFB x35,W
380A:  MOVWF  x47
380C:  MOVF   x2F,W
380E:  ADDWF  x46,W
3810:  MOVWF  FE9
3812:  MOVF   x30,W
3814:  ADDWFC x47,W
3816:  MOVWF  FEA
3818:  MOVFF  FEF,848
381C:  MOVF   x2F,W
381E:  ADDWF  x34,W
3820:  MOVWF  FE9
3822:  MOVF   x30,W
3824:  ADDWFC x35,W
3826:  MOVWF  FEA
3828:  MOVFF  FEF,849
382C:  CLRF   x5A
382E:  CLRF   x5B
3830:  MOVFF  83C,85C
3834:  MOVFF  83F,85D
3838:  MOVFF  842,85E
383C:  MOVFF  845,85F
3840:  MOVFF  848,860
3844:  MOVFF  849,861
3848:  MOVLB  0
384A:  CALL   0668
384E:  MOVFF  839,FEA
3852:  MOVFF  838,FE9
3856:  MOVFF  01,FEF
....................                j=j-7; 
385A:  MOVLW  07
385C:  MOVLB  8
385E:  SUBWF  x34,F
3860:  MOVLW  00
3862:  SUBWFB x35,F
....................             } 
3864:  INCF   x33,F
3866:  BRA    3776
....................          } 
....................             else 
3868:  BRA    3922
....................             { 
....................                for(i=0;i<40;i++) 
386A:  CLRF   x33
386C:  MOVF   x33,W
386E:  SUBLW  27
3870:  BNC   3922
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3872:  CLRF   03
3874:  MOVF   x33,W
3876:  ADDWF  x31,W
3878:  MOVWF  01
387A:  MOVF   x32,W
387C:  ADDWFC 03,F
387E:  MOVFF  01,838
3882:  MOVFF  03,839
3886:  MOVLW  03
3888:  SUBWF  x34,W
388A:  MOVWF  x3A
388C:  MOVLW  00
388E:  SUBWFB x35,W
3890:  MOVWF  x3B
3892:  MOVF   x2F,W
3894:  ADDWF  x3A,W
3896:  MOVWF  FE9
3898:  MOVF   x30,W
389A:  ADDWFC x3B,W
389C:  MOVWF  FEA
389E:  MOVFF  FEF,83C
38A2:  MOVLW  02
38A4:  SUBWF  x34,W
38A6:  MOVWF  x3D
38A8:  MOVLW  00
38AA:  SUBWFB x35,W
38AC:  MOVWF  x3E
38AE:  MOVF   x2F,W
38B0:  ADDWF  x3D,W
38B2:  MOVWF  FE9
38B4:  MOVF   x30,W
38B6:  ADDWFC x3E,W
38B8:  MOVWF  FEA
38BA:  MOVFF  FEF,83F
38BE:  MOVLW  01
38C0:  SUBWF  x34,W
38C2:  MOVWF  x40
38C4:  MOVLW  00
38C6:  SUBWFB x35,W
38C8:  MOVWF  x41
38CA:  MOVF   x2F,W
38CC:  ADDWF  x40,W
38CE:  MOVWF  FE9
38D0:  MOVF   x30,W
38D2:  ADDWFC x41,W
38D4:  MOVWF  FEA
38D6:  MOVFF  FEF,842
38DA:  MOVF   x2F,W
38DC:  ADDWF  x34,W
38DE:  MOVWF  FE9
38E0:  MOVF   x30,W
38E2:  ADDWFC x35,W
38E4:  MOVWF  FEA
38E6:  MOVFF  FEF,843
38EA:  CLRF   x5A
38EC:  CLRF   x5B
38EE:  CLRF   x5C
38F0:  CLRF   x5D
38F2:  MOVFF  83C,85E
38F6:  MOVFF  83F,85F
38FA:  MOVFF  842,860
38FE:  MOVFF  843,861
3902:  MOVLB  0
3904:  CALL   0668
3908:  MOVFF  839,FEA
390C:  MOVFF  838,FE9
3910:  MOVFF  01,FEF
....................                   j=j-5; 
3914:  MOVLW  05
3916:  MOVLB  8
3918:  SUBWF  x34,F
391A:  MOVLW  00
391C:  SUBWFB x35,F
....................                }             
391E:  INCF   x33,F
3920:  BRA    386C
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3922:  MOVF   x2C,F
3924:  BNZ   393A
3926:  MOVLW  52
3928:  MOVWF  x38
392A:  MOVFF  830,83A
392E:  MOVFF  82F,839
3932:  MOVLB  0
3934:  RCALL  3546
....................          else del_buf(numbyteofbuffer2,datin); 
3936:  BRA    394A
3938:  MOVLB  8
393A:  MOVLW  2C
393C:  MOVWF  x38
393E:  MOVFF  830,83A
3942:  MOVFF  82F,839
3946:  MOVLB  0
3948:  RCALL  3546
394A:  MOVLB  8
.................... } 
394C:  MOVLB  0
394E:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
17F2:  MOVLW  8E
17F4:  MOVWF  FF6
17F6:  MOVLW  05
17F8:  MOVWF  FF7
17FA:  RCALL  16EA
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
17FC:  MOVLB  8
17FE:  CLRF   x30
1800:  CLRF   x2F
1802:  MOVF   x30,W
1804:  SUBLW  03
1806:  BNC   1836
1808:  BNZ   1810
180A:  MOVF   x2F,W
180C:  SUBLW  51
180E:  BNC   1836
1810:  MOVLW  42
1812:  ADDWF  x2F,W
1814:  MOVWF  FE9
1816:  MOVLW  02
1818:  ADDWFC x30,W
181A:  MOVWF  FEA
181C:  MOVFF  FEF,831
1820:  MOVFF  831,832
1824:  MOVLW  18
1826:  MOVWF  x33
1828:  MOVLB  0
182A:  RCALL  1736
182C:  MOVLB  8
182E:  INCF   x2F,F
1830:  BTFSC  FD8.2
1832:  INCF   x30,F
1834:  BRA    1802
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1836:  MOVLW  A4
1838:  MOVWF  FF6
183A:  MOVLW  05
183C:  MOVWF  FF7
183E:  MOVLB  0
1840:  RCALL  16EA
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1842:  MOVLB  8
1844:  CLRF   x30
1846:  CLRF   x2F
1848:  MOVF   x30,W
184A:  SUBLW  01
184C:  BNC   187C
184E:  BNZ   1856
1850:  MOVF   x2F,W
1852:  SUBLW  2B
1854:  BNC   187C
1856:  MOVLW  94
1858:  ADDWF  x2F,W
185A:  MOVWF  FE9
185C:  MOVLW  05
185E:  ADDWFC x30,W
1860:  MOVWF  FEA
1862:  MOVFF  FEF,831
1866:  MOVFF  831,832
186A:  MOVLW  18
186C:  MOVWF  x33
186E:  MOVLB  0
1870:  RCALL  1736
1872:  MOVLB  8
1874:  INCF   x2F,F
1876:  BTFSC  FD8.2
1878:  INCF   x30,F
187A:  BRA    1848
.................... } 
187C:  MOVLB  0
187E:  GOTO   1B0C (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3AF6:  MOVLW  01
3AF8:  MOVLB  6
3AFA:  MOVWF  xD4
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3AFC:  MOVLB  0
3AFE:  RCALL  34CC
3B00:  MOVFF  02,82D
3B04:  MOVFF  01,82C
3B08:  MOVFF  02,82F
3B0C:  MOVFF  01,82E
3B10:  MOVLB  8
3B12:  CLRF   x31
3B14:  MOVLW  7C
3B16:  MOVWF  x30
3B18:  MOVLB  0
3B1A:  RCALL  3524
3B1C:  MOVFF  01,82C
3B20:  MOVLW  96
3B22:  MOVLB  8
3B24:  ADDWF  01,W
3B26:  MOVWF  01
3B28:  MOVLW  00
3B2A:  ADDWFC 02,W
3B2C:  MOVFF  01,20
3B30:  MOVWF  21
3B32:  CLRF   22
3B34:  CLRF   23
....................    if(datinbuf==0)  
3B36:  MOVLB  6
3B38:  MOVF   xD1,F
3B3A:  BNZ   3B5C
....................    { 
....................       countbit_T1=0; 
3B3C:  CLRF   xC6
3B3E:  CLRF   xC5
....................       countbit_T2=0; 
3B40:  CLRF   xC8
3B42:  CLRF   xC7
....................       bug_countbit_T1=0; 
3B44:  CLRF   xCA
3B46:  CLRF   xC9
....................       bug_countbit_T2=0; 
3B48:  CLRF   xCC
3B4A:  CLRF   xCB
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3B4C:  MOVF   xD5,F
3B4E:  BNZ   3B58
3B50:  MOVLB  0
3B52:  SETF   xFC
3B54:  SETF   xFB
3B56:  MOVLB  6
....................       saving_flag=0; 
3B58:  CLRF   xD4
....................       return; 
3B5A:  BRA    3EE0
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3B5C:  MOVLW  BA
3B5E:  MOVWF  FF6
3B60:  MOVLW  05
3B62:  MOVWF  FF7
3B64:  MOVLB  0
3B66:  CALL   16EA
....................    //key_count=0; 
....................    enable_getpin=1; 
3B6A:  MOVLW  01
3B6C:  MOVLB  1
3B6E:  MOVWF  x41
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3B70:  MOVFF  6C6,82B
3B74:  MOVFF  6C5,82A
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3B78:  MOVLB  8
3B7A:  CLRF   x2C
3B7C:  MOVFF  82B,82E
3B80:  MOVFF  82A,82D
3B84:  MOVLW  02
3B86:  MOVWF  x30
3B88:  MOVLW  42
3B8A:  MOVWF  x2F
3B8C:  MOVLW  01
3B8E:  MOVWF  x32
3B90:  MOVLW  CB
3B92:  MOVWF  x31
3B94:  MOVLB  0
3B96:  RCALL  3568
....................    countbit_T1=0; 
3B98:  MOVLB  6
3B9A:  CLRF   xC6
3B9C:  CLRF   xC5
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3B9E:  MOVFF  6C8,82B
3BA2:  MOVFF  6C7,82A
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3BA6:  MOVLW  01
3BA8:  MOVLB  8
3BAA:  MOVWF  x2C
3BAC:  MOVFF  82B,82E
3BB0:  MOVFF  82A,82D
3BB4:  MOVLW  05
3BB6:  MOVWF  x30
3BB8:  MOVLW  94
3BBA:  MOVWF  x2F
3BBC:  MOVLW  02
3BBE:  MOVWF  x32
3BC0:  MOVLW  1A
3BC2:  MOVWF  x31
3BC4:  MOVLB  0
3BC6:  RCALL  3568
....................    countbit_T2=0; 
3BC8:  MOVLB  6
3BCA:  CLRF   xC8
3BCC:  CLRF   xC7
....................    saving_flag=0; 
3BCE:  CLRF   xD4
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3BD0:  MOVLW  20
3BD2:  MOVLB  1
3BD4:  ADDWF  xCB,W
3BD6:  MOVLB  8
3BD8:  MOVWF  x29
....................    if((ptr_card<EEPROM_SIZE_stofkey)&&(temp=='%')) 
3BDA:  MOVF   23,F
3BDC:  BTFSS  FD8.2
3BDE:  BRA    3EDE
3BE0:  MOVF   22,W
3BE2:  SUBLW  01
3BE4:  BTFSS  FD8.0
3BE6:  BRA    3EDE
3BE8:  BNZ   3BFC
3BEA:  MOVF   21,W
3BEC:  SUBLW  C3
3BEE:  BTFSS  FD8.0
3BF0:  BRA    3EDE
3BF2:  BNZ   3BFC
3BF4:  MOVF   20,W
3BF6:  SUBLW  0D
3BF8:  BTFSS  FD8.0
3BFA:  BRA    3EDE
3BFC:  MOVF   x29,W
3BFE:  SUBLW  25
3C00:  BTFSS  FD8.2
3C02:  BRA    3EDE
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3C04:  MOVFF  23,03
3C08:  MOVFF  22,02
3C0C:  MOVFF  21,01
3C10:  MOVFF  20,00
3C14:  MOVLW  01
3C16:  ADDWF  20,F
3C18:  BTFSC  FD8.0
3C1A:  INCF   21,F
3C1C:  BTFSC  FD8.2
3C1E:  INCF   22,F
3C20:  BTFSC  FD8.2
3C22:  INCF   23,F
3C24:  MOVFF  01,82D
3C28:  MOVFF  00,82C
3C2C:  CLRF   x53
3C2E:  CLRF   x52
3C30:  MOVFF  01,851
3C34:  MOVFF  00,850
3C38:  MOVFF  1C7,854
3C3C:  MOVLB  0
3C3E:  RCALL  3950
....................          write_ext_eeprom((long int)ptr_card++,mon); 
3C40:  MOVFF  23,03
3C44:  MOVFF  22,02
3C48:  MOVFF  21,01
3C4C:  MOVFF  20,00
3C50:  MOVLW  01
3C52:  ADDWF  20,F
3C54:  BTFSC  FD8.0
3C56:  INCF   21,F
3C58:  BTFSC  FD8.2
3C5A:  INCF   22,F
3C5C:  BTFSC  FD8.2
3C5E:  INCF   23,F
3C60:  MOVFF  01,82D
3C64:  MOVFF  00,82C
3C68:  MOVLB  8
3C6A:  CLRF   x53
3C6C:  CLRF   x52
3C6E:  MOVFF  01,851
3C72:  MOVFF  00,850
3C76:  MOVFF  1C6,854
3C7A:  MOVLB  0
3C7C:  RCALL  3950
....................          write_ext_eeprom((long int)ptr_card++,h); 
3C7E:  MOVFF  23,03
3C82:  MOVFF  22,02
3C86:  MOVFF  21,01
3C8A:  MOVFF  20,00
3C8E:  MOVLW  01
3C90:  ADDWF  20,F
3C92:  BTFSC  FD8.0
3C94:  INCF   21,F
3C96:  BTFSC  FD8.2
3C98:  INCF   22,F
3C9A:  BTFSC  FD8.2
3C9C:  INCF   23,F
3C9E:  MOVFF  01,82D
3CA2:  MOVFF  00,82C
3CA6:  MOVLB  8
3CA8:  CLRF   x53
3CAA:  CLRF   x52
3CAC:  MOVFF  01,851
3CB0:  MOVFF  00,850
3CB4:  MOVFF  1C8,854
3CB8:  MOVLB  0
3CBA:  RCALL  3950
....................          write_ext_eeprom((long int)ptr_card++,min); 
3CBC:  MOVFF  23,03
3CC0:  MOVFF  22,02
3CC4:  MOVFF  21,01
3CC8:  MOVFF  20,00
3CCC:  MOVLW  01
3CCE:  ADDWF  20,F
3CD0:  BTFSC  FD8.0
3CD2:  INCF   21,F
3CD4:  BTFSC  FD8.2
3CD6:  INCF   22,F
3CD8:  BTFSC  FD8.2
3CDA:  INCF   23,F
3CDC:  MOVFF  01,82D
3CE0:  MOVFF  00,82C
3CE4:  MOVLB  8
3CE6:  CLRF   x53
3CE8:  CLRF   x52
3CEA:  MOVFF  01,851
3CEE:  MOVFF  00,850
3CF2:  MOVFF  1C9,854
3CF6:  MOVLB  0
3CF8:  RCALL  3950
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3CFA:  MOVFF  23,03
3CFE:  MOVFF  22,02
3D02:  MOVFF  21,01
3D06:  MOVFF  20,00
3D0A:  MOVLW  01
3D0C:  ADDWF  20,F
3D0E:  BTFSC  FD8.0
3D10:  INCF   21,F
3D12:  BTFSC  FD8.2
3D14:  INCF   22,F
3D16:  BTFSC  FD8.2
3D18:  INCF   23,F
3D1A:  MOVFF  01,82D
3D1E:  MOVFF  00,82C
3D22:  MOVLB  8
3D24:  CLRF   x53
3D26:  CLRF   x52
3D28:  MOVFF  01,851
3D2C:  MOVFF  00,850
3D30:  MOVFF  1CA,854
3D34:  MOVLB  0
3D36:  RCALL  3950
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3D38:  MOVLB  6
3D3A:  CLRF   xD0
3D3C:  CLRF   xCF
3D3E:  MOVF   xD0,F
3D40:  BNZ   3DA2
3D42:  MOVF   xCF,W
3D44:  SUBLW  4E
3D46:  BNC   3DA2
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3D48:  MOVFF  23,03
3D4C:  MOVFF  22,02
3D50:  MOVFF  21,01
3D54:  MOVFF  20,00
3D58:  MOVLW  01
3D5A:  ADDWF  20,F
3D5C:  BTFSC  FD8.0
3D5E:  INCF   21,F
3D60:  BTFSC  FD8.2
3D62:  INCF   22,F
3D64:  BTFSC  FD8.2
3D66:  INCF   23,F
3D68:  MOVFF  01,82D
3D6C:  MOVFF  00,82C
3D70:  MOVLW  CB
3D72:  ADDWF  xCF,W
3D74:  MOVWF  FE9
3D76:  MOVLW  01
3D78:  ADDWFC xD0,W
3D7A:  MOVWF  FEA
3D7C:  MOVF   FEF,W
3D7E:  ANDLW  3F
3D80:  ADDLW  20
3D82:  MOVLB  8
3D84:  MOVWF  x2E
3D86:  CLRF   x53
3D88:  CLRF   x52
3D8A:  MOVFF  01,851
3D8E:  MOVFF  00,850
3D92:  MOVWF  x54
3D94:  MOVLB  0
3D96:  RCALL  3950
....................              
....................          } 
3D98:  MOVLB  6
3D9A:  INCF   xCF,F
3D9C:  BTFSC  FD8.2
3D9E:  INCF   xD0,F
3DA0:  BRA    3D3E
....................          del_buf(numbyteoftrack1,Track1); 
3DA2:  MOVLW  4F
3DA4:  MOVLB  8
3DA6:  MOVWF  x38
3DA8:  MOVLW  01
3DAA:  MOVWF  x3A
3DAC:  MOVLW  CB
3DAE:  MOVWF  x39
3DB0:  MOVLB  0
3DB2:  CALL   3546
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3DB6:  MOVLB  6
3DB8:  CLRF   xD0
3DBA:  CLRF   xCF
3DBC:  MOVF   xD0,F
3DBE:  BNZ   3E20
3DC0:  MOVF   xCF,W
3DC2:  SUBLW  27
3DC4:  BNC   3E20
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3DC6:  MOVFF  23,03
3DCA:  MOVFF  22,02
3DCE:  MOVFF  21,01
3DD2:  MOVFF  20,00
3DD6:  MOVLW  01
3DD8:  ADDWF  20,F
3DDA:  BTFSC  FD8.0
3DDC:  INCF   21,F
3DDE:  BTFSC  FD8.2
3DE0:  INCF   22,F
3DE2:  BTFSC  FD8.2
3DE4:  INCF   23,F
3DE6:  MOVFF  01,82D
3DEA:  MOVFF  00,82C
3DEE:  MOVLW  1A
3DF0:  ADDWF  xCF,W
3DF2:  MOVWF  FE9
3DF4:  MOVLW  02
3DF6:  ADDWFC xD0,W
3DF8:  MOVWF  FEA
3DFA:  MOVF   FEF,W
3DFC:  ANDLW  0F
3DFE:  ADDLW  30
3E00:  MOVLB  8
3E02:  MOVWF  x2E
3E04:  CLRF   x53
3E06:  CLRF   x52
3E08:  MOVFF  01,851
3E0C:  MOVFF  00,850
3E10:  MOVWF  x54
3E12:  MOVLB  0
3E14:  RCALL  3950
....................          }  
3E16:  MOVLB  6
3E18:  INCF   xCF,F
3E1A:  BTFSC  FD8.2
3E1C:  INCF   xD0,F
3E1E:  BRA    3DBC
....................          del_buf(numbyteoftrack2,Track2); 
3E20:  MOVLW  28
3E22:  MOVLB  8
3E24:  MOVWF  x38
3E26:  MOVLW  02
3E28:  MOVWF  x3A
3E2A:  MOVLW  1A
3E2C:  MOVWF  x39
3E2E:  MOVLB  0
3E30:  CALL   3546
....................       fprintf(COM2,"\r\n"); 
3E34:  MOVLW  0D
3E36:  MOVLB  8
3E38:  MOVWF  x52
3E3A:  MOVLB  0
3E3C:  CALL   15C0
3E40:  MOVLW  0A
3E42:  MOVLB  8
3E44:  MOVWF  x52
3E46:  MOVLB  0
3E48:  CALL   15C0
....................       fprintf(COM2,"Done"); 
3E4C:  MOVLW  D0
3E4E:  MOVWF  FF6
3E50:  MOVLW  05
3E52:  MOVWF  FF7
3E54:  CALL   16EA
....................          
....................       fprintf(COM2,"\r\n"); 
3E58:  MOVLW  0D
3E5A:  MOVLB  8
3E5C:  MOVWF  x52
3E5E:  MOVLB  0
3E60:  CALL   15C0
3E64:  MOVLW  0A
3E66:  MOVLB  8
3E68:  MOVWF  x52
3E6A:  MOVLB  0
3E6C:  CALL   15C0
....................       fprintf(COM2,"Waiting for PIN number"); 
3E70:  MOVLW  D6
3E72:  MOVWF  FF6
3E74:  MOVLW  05
3E76:  MOVWF  FF7
3E78:  CALL   16EA
....................       memset(key_data,0,sizeof(key_data));  
3E7C:  MOVLW  01
3E7E:  MOVWF  FEA
3E80:  MOVLW  46
3E82:  MOVWF  FE9
3E84:  CLRF   00
3E86:  CLRF   02
3E88:  MOVLW  10
3E8A:  MOVWF  01
3E8C:  RCALL  3A4E
....................       fprintf(COM2,"\r\n"); 
3E8E:  MOVLW  0D
3E90:  MOVLB  8
3E92:  MOVWF  x52
3E94:  MOVLB  0
3E96:  CALL   15C0
3E9A:  MOVLW  0A
3E9C:  MOVLB  8
3E9E:  MOVWF  x52
3EA0:  MOVLB  0
3EA2:  CALL   15C0
....................       charac_timeout=0; 
3EA6:  CLRF   xFC
3EA8:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3EAA:  MOVFF  23,840
3EAE:  MOVFF  22,83F
3EB2:  MOVFF  21,83E
3EB6:  MOVFF  20,83D
3EBA:  MOVLW  19
3EBC:  MOVLB  8
3EBE:  MOVWF  x41
3EC0:  MOVLB  0
3EC2:  RCALL  3A68
....................       datinbuf=0; 
3EC4:  MOVLB  6
3EC6:  CLRF   xD1
....................       saving_flag=0; 
3EC8:  CLRF   xD4
....................       data_avai=1; 
3ECA:  MOVLW  01
3ECC:  MOVWF  xD5
....................       enable_getpin=1; 
3ECE:  MOVLB  1
3ED0:  MOVWF  x41
....................       charac_timeout=0; 
3ED2:  MOVLB  0
3ED4:  CLRF   xFC
3ED6:  CLRF   xFB
....................       key_count_ms=0; 
3ED8:  MOVLB  1
3EDA:  CLRF   x43
3EDC:  MOVLB  8
3EDE:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3EE0:  MOVLB  0
3EE2:  GOTO   5234 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
18AA:  MOVLW  01
18AC:  MOVLB  8
18AE:  MOVWF  x26
18B0:  MOVWF  x27
18B2:  MOVWF  x28
18B4:  MOVWF  x29
18B6:  CLRF   x2A
18B8:  MOVWF  x2B
18BA:  MOVWF  x2C
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
18BC:  MOVLB  6
18BE:  CLRF   xCE
18C0:  CLRF   xCD
....................    mcr_timeout=0; 
18C2:  CLRF   xC3
18C4:  CLRF   xC2
18C6:  CLRF   xC1
18C8:  CLRF   xC0
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
18CA:  MOVF   xCE,W
18CC:  SUBLW  FD
18CE:  BNC   18EC
18D0:  BNZ   18D8
18D2:  MOVF   xCD,W
18D4:  SUBLW  E7
18D6:  BNC   18EC
18D8:  BSF    F93.1
18DA:  BTFSS  F81.1
18DC:  BRA    18EC
18DE:  BSF    F94.5
18E0:  BTFSS  F82.5
18E2:  BRA    18EC
....................       card_timeout++; 
18E4:  INCF   xCD,F
18E6:  BTFSC  FD8.2
18E8:  INCF   xCE,F
....................    } 
18EA:  BRA    18CA
....................    card_timeout=0; 
18EC:  CLRF   xCE
18EE:  CLRF   xCD
....................    buffertrack1[bug_countbit_T1++]=0; 
18F0:  MOVFF  6CA,03
18F4:  MOVF   xC9,W
18F6:  INCF   xC9,F
18F8:  BTFSC  FD8.2
18FA:  INCF   xCA,F
18FC:  MOVLB  8
18FE:  MOVWF  x2F
1900:  MOVLW  42
1902:  ADDWF  x2F,W
1904:  MOVWF  FE9
1906:  MOVLW  02
1908:  ADDWFC 03,W
190A:  MOVWF  FEA
190C:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
190E:  MOVLB  6
1910:  MOVFF  6CA,03
1914:  MOVF   xC9,W
1916:  INCF   xC9,F
1918:  BTFSC  FD8.2
191A:  INCF   xCA,F
191C:  MOVLB  8
191E:  MOVWF  x2F
1920:  MOVLW  42
1922:  ADDWF  x2F,W
1924:  MOVWF  FE9
1926:  MOVLW  02
1928:  ADDWFC 03,W
192A:  MOVWF  FEA
192C:  MOVLW  01
192E:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1930:  MOVLB  6
1932:  MOVFF  6CC,03
1936:  MOVF   xCB,W
1938:  INCF   xCB,F
193A:  BTFSC  FD8.2
193C:  INCF   xCC,F
193E:  MOVLB  8
1940:  MOVWF  x2F
1942:  MOVLW  94
1944:  ADDWF  x2F,W
1946:  MOVWF  FE9
1948:  MOVLW  05
194A:  ADDWFC 03,W
194C:  MOVWF  FEA
194E:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1950:  MOVLB  6
1952:  MOVFF  6CC,03
1956:  MOVF   xCB,W
1958:  INCF   xCB,F
195A:  BTFSC  FD8.2
195C:  INCF   xCC,F
195E:  MOVLB  8
1960:  MOVWF  x2F
1962:  MOVLW  94
1964:  ADDWF  x2F,W
1966:  MOVWF  FE9
1968:  MOVLW  05
196A:  ADDWFC 03,W
196C:  MOVWF  FEA
196E:  MOVLW  01
1970:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1972:  MOVLB  6
1974:  MOVF   xCA,W
1976:  SUBLW  03
1978:  BTFSS  FD8.0
197A:  BRA    1A5A
197C:  BNZ   1986
197E:  MOVF   xC9,W
1980:  SUBLW  51
1982:  BTFSS  FD8.0
1984:  BRA    1A5A
1986:  MOVF   xCC,W
1988:  SUBLW  01
198A:  BTFSS  FD8.0
198C:  BRA    1A5A
198E:  BNZ   1996
1990:  MOVF   xCB,W
1992:  SUBLW  2B
1994:  BNC   1A5A
1996:  MOVF   xCE,W
1998:  SUBLW  FF
199A:  BNC   1A5A
199C:  BNZ   19A4
199E:  MOVF   xCD,W
19A0:  SUBLW  DB
19A2:  BNC   1A5A
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
19A4:  MOVF   xD7,F
19A6:  BZ    19B0
....................          { 
....................             bug_countbit_T1=0; 
19A8:  CLRF   xCA
19AA:  CLRF   xC9
....................             bug_countbit_T2=0; 
19AC:  CLRF   xCC
19AE:  CLRF   xCB
....................          } 
....................          card_timeout++; 
19B0:  INCF   xCD,F
19B2:  BTFSC  FD8.2
19B4:  INCF   xCE,F
....................          mcr_timeout=0; 
19B6:  CLRF   xC3
19B8:  CLRF   xC2
19BA:  CLRF   xC1
19BC:  CLRF   xC0
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
19BE:  BSF    F93.2
19C0:  MOVLB  8
19C2:  CLRF   x26
19C4:  BTFSC  F81.2
19C6:  INCF   x26,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
19C8:  MOVF   x26,F
19CA:  BNZ   1A08
19CC:  DECFSZ x27,W
19CE:  BRA    1A08
....................          { 
....................             ST1_old = 0; 
19D0:  CLRF   x27
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
19D2:  MOVLW  42
19D4:  MOVLB  6
19D6:  ADDWF  xC9,W
19D8:  MOVWF  FE9
19DA:  MOVLW  02
19DC:  ADDWFC xCA,W
19DE:  MOVWF  FEA
19E0:  BSF    F93.1
19E2:  MOVLW  00
19E4:  BTFSS  F81.1
19E6:  MOVLW  01
19E8:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
19EA:  MOVLW  94
19EC:  ADDWF  xCB,W
19EE:  MOVWF  FE9
19F0:  MOVLW  05
19F2:  ADDWFC xCC,W
19F4:  MOVWF  FEA
19F6:  MOVFF  82A,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
19FA:  INCF   xC9,F
19FC:  BTFSC  FD8.2
19FE:  INCF   xCA,F
....................             card_timeout=0; 
1A00:  CLRF   xCE
1A02:  CLRF   xCD
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1A04:  BRA    1A12
1A06:  MOVLB  8
1A08:  DECFSZ x26,W
1A0A:  BRA    1A10
1A0C:  MOVLW  01
1A0E:  MOVWF  x27
1A10:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1A12:  BSF    F93.3
1A14:  MOVLB  8
1A16:  CLRF   x28
1A18:  BTFSC  F81.3
1A1A:  INCF   x28,F
....................          if(ST2 == 0 && ST2_old == 1) 
1A1C:  MOVF   x28,F
1A1E:  BNZ   1A3E
1A20:  DECFSZ x29,W
1A22:  BRA    1A3E
....................          { 
....................             ST2_old = 0; 
1A24:  CLRF   x29
....................             Bit_t2 = !input(MCR_DATA2); 
1A26:  BSF    F94.5
1A28:  CLRF   x2A
1A2A:  BTFSS  F82.5
1A2C:  INCF   x2A,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1A2E:  MOVLB  6
1A30:  INCF   xCB,F
1A32:  BTFSC  FD8.2
1A34:  INCF   xCC,F
....................             card_timeout=0; 
1A36:  CLRF   xCE
1A38:  CLRF   xCD
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1A3A:  BRA    1A48
1A3C:  MOVLB  8
1A3E:  DECFSZ x28,W
1A40:  BRA    1A46
1A42:  MOVLW  01
1A44:  MOVWF  x29
1A46:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1A48:  BSF    F93.0
1A4A:  BTFSS  F81.0
1A4C:  BRA    1A58
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1A4E:  CLRF   xD7
....................             card_timeout=65500; 
1A50:  SETF   xCE
1A52:  MOVLW  DC
1A54:  MOVWF  xCD
....................             break;            
1A56:  BRA    1A5A
....................          } 
....................       } 
1A58:  BRA    1974
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1A5A:  CLRF   xCE
1A5C:  CLRF   xCD
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1A5E:  MOVLB  8
1A60:  CLRF   x38
1A62:  MOVFF  6CA,83A
1A66:  MOVFF  6C9,839
1A6A:  MOVLW  02
1A6C:  MOVWF  x3C
1A6E:  MOVLW  42
1A70:  MOVWF  x3B
1A72:  MOVLB  0
1A74:  CALL   09BE
1A78:  MOVFF  01,82B
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1A7C:  MOVLW  01
1A7E:  MOVLB  8
1A80:  MOVWF  x38
1A82:  MOVFF  6CC,83A
1A86:  MOVFF  6CB,839
1A8A:  MOVLW  05
1A8C:  MOVWF  x3C
1A8E:  MOVLW  94
1A90:  MOVWF  x3B
1A92:  MOVLB  0
1A94:  CALL   09BE
1A98:  MOVFF  01,82C
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1A9C:  MOVLB  6
1A9E:  DECFSZ xD2,W
1AA0:  BRA    1B36
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1AA2:  MOVLW  EE
1AA4:  MOVWF  FF6
1AA6:  MOVLW  05
1AA8:  MOVWF  FF7
1AAA:  MOVLW  0E
1AAC:  MOVLB  8
1AAE:  MOVWF  x46
1AB0:  MOVLB  0
1AB2:  RCALL  1606
1AB4:  MOVLW  10
1AB6:  MOVWF  FE9
1AB8:  MOVFF  6CA,830
1ABC:  MOVFF  6C9,82F
1AC0:  RCALL  162E
1AC2:  MOVLW  0D
1AC4:  MOVLB  8
1AC6:  MOVWF  x52
1AC8:  MOVLB  0
1ACA:  RCALL  15C0
1ACC:  MOVLW  0A
1ACE:  MOVLB  8
1AD0:  MOVWF  x52
1AD2:  MOVLB  0
1AD4:  RCALL  15C0
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1AD6:  MOVLW  02
1AD8:  MOVWF  FF6
1ADA:  MOVLW  06
1ADC:  MOVWF  FF7
1ADE:  MOVLW  0E
1AE0:  MOVLB  8
1AE2:  MOVWF  x46
1AE4:  MOVLB  0
1AE6:  RCALL  1606
1AE8:  MOVLW  10
1AEA:  MOVWF  FE9
1AEC:  MOVFF  6CC,830
1AF0:  MOVFF  6CB,82F
1AF4:  RCALL  162E
1AF6:  MOVLW  0D
1AF8:  MOVLB  8
1AFA:  MOVWF  x52
1AFC:  MOVLB  0
1AFE:  RCALL  15C0
1B00:  MOVLW  0A
1B02:  MOVLB  8
1B04:  MOVWF  x52
1B06:  MOVLB  0
1B08:  RCALL  15C0
....................          debug_reader();       
1B0A:  BRA    17F2
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1B0C:  MOVLB  8
1B0E:  MOVF   x2B,F
1B10:  BNZ   1B20
1B12:  MOVLW  16
1B14:  MOVWF  FF6
1B16:  MOVLW  06
1B18:  MOVWF  FF7
1B1A:  MOVLB  0
1B1C:  RCALL  16EA
1B1E:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1B20:  MOVF   x2C,F
1B22:  BNZ   1B32
1B24:  MOVLW  2C
1B26:  MOVWF  FF6
1B28:  MOVLW  06
1B2A:  MOVWF  FF7
1B2C:  MOVLB  0
1B2E:  RCALL  16EA
1B30:  MOVLB  8
....................       } 
....................          else 
1B32:  BRA    1B42
1B34:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1B36:  MOVLW  0F
1B38:  MOVLB  8
1B3A:  MOVWF  x2F
1B3C:  MOVLB  0
1B3E:  RCALL  1882
1B40:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1B42:  MOVF   x2B,F
1B44:  BZ    1B4A
1B46:  MOVF   x2C,F
1B48:  BNZ   1B6A
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1B4A:  MOVLB  6
1B4C:  CLRF   xCC
1B4E:  CLRF   xCB
....................          bug_countbit_T1=0; 
1B50:  CLRF   xCA
1B52:  CLRF   xC9
....................          reading_fg=0; 
1B54:  CLRF   xD6
....................          count_reading_error++; 
1B56:  INCF   xD7,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1B58:  CLRF   xC3
1B5A:  CLRF   xC2
1B5C:  CLRF   xC1
1B5E:  CLRF   xC0
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1B60:  MOVLW  00
1B62:  MOVWF  01
1B64:  BRA    1BA2
....................       } 
....................          else  
1B66:  BRA    1B9E
1B68:  MOVLB  8
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1B6A:  MOVLW  01
1B6C:  MOVLB  6
1B6E:  MOVWF  xD1
....................             reading_fg=1; 
1B70:  MOVWF  xD6
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1B72:  MOVFF  6CC,6C8
1B76:  MOVFF  6CB,6C7
....................             countbit_T1=bug_countbit_T1; 
1B7A:  MOVFF  6CA,6C6
1B7E:  MOVFF  6C9,6C5
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1B82:  CLRF   xCA
1B84:  CLRF   xC9
....................             bug_countbit_T2=0;  
1B86:  CLRF   xCC
1B88:  CLRF   xCB
....................             mcr_timeout=0; 
1B8A:  CLRF   xC3
1B8C:  CLRF   xC2
1B8E:  CLRF   xC1
1B90:  CLRF   xC0
....................             charac_timeout=0; 
1B92:  MOVLB  0
1B94:  CLRF   xFC
1B96:  CLRF   xFB
....................             return 1; 
1B98:  MOVWF  01
1B9A:  MOVLB  6
1B9C:  BRA    1BA2
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1B9E:  MOVLW  00
1BA0:  MOVWF  01
.................... } 
1BA2:  MOVLB  0
1BA4:  GOTO   1BCA (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       delay_us(500); 
1BA8:  MOVLW  02
1BAA:  MOVLB  8
1BAC:  MOVWF  x26
1BAE:  MOVLW  FA
1BB0:  MOVWF  x27
1BB2:  MOVLB  0
1BB4:  GOTO   0642
1BB8:  MOVLB  8
1BBA:  DECFSZ x26,F
1BBC:  BRA    1BAE
....................       if(saving_flag==1) return;      
1BBE:  MOVLB  6
1BC0:  DECFSZ xD4,W
1BC2:  BRA    1BC6
1BC4:  BRA    1BDC
....................       cardread_st=mcr_read(); 
1BC6:  MOVLB  0
1BC8:  BRA    18AA
1BCA:  MOVFF  01,6D3
....................       mcr_timeout=0; 
1BCE:  MOVLB  6
1BD0:  CLRF   xC3
1BD2:  CLRF   xC2
1BD4:  CLRF   xC1
1BD6:  CLRF   xC0
....................       card_timeout=0;      
1BD8:  CLRF   xCE
1BDA:  CLRF   xCD
.................... } 
.................... //==================================== 
.................... #if 0 
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... #endif 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
1BDC:  BCF    FF0.0
1BDE:  MOVLB  0
1BE0:  GOTO   006C
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
5C8E:  CLRF   19
5C90:  BTFSC  FF2.7
5C92:  BSF    19.7
5C94:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
5C96:  MOVLB  8
5C98:  CLRF   x53
5C9A:  CLRF   x52
5C9C:  CLRF   x51
5C9E:  MOVLW  3C
5CA0:  MOVWF  x50
5CA2:  MOVLW  03
5CA4:  MOVWF  x54
5CA6:  MOVLB  0
5CA8:  CALL   3950
5CAC:  BTFSC  19.7
5CAE:  BSF    FF2.7
5CB0:  CLRF   19
5CB2:  BTFSC  FF2.7
5CB4:  BSF    19.7
5CB6:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
5CB8:  MOVLB  8
5CBA:  CLRF   x53
5CBC:  CLRF   x52
5CBE:  CLRF   x51
5CC0:  MOVLW  3A
5CC2:  MOVWF  x50
5CC4:  MOVLW  01
5CC6:  MOVWF  x54
5CC8:  MOVLB  0
5CCA:  CALL   3950
5CCE:  BTFSC  19.7
5CD0:  BSF    FF2.7
5CD2:  CLRF   19
5CD4:  BTFSC  FF2.7
5CD6:  BSF    19.7
5CD8:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV);  
5CDA:  MOVLB  8
5CDC:  CLRF   x46
5CDE:  CLRF   x45
5CE0:  CLRF   x44
5CE2:  MOVLW  3A
5CE4:  MOVWF  x43
5CE6:  MOVLB  0
5CE8:  CALL   3400
5CEC:  BTFSC  19.7
5CEE:  BSF    FF2.7
5CF0:  MOVFF  01,6DE
.................... } 
5CF4:  GOTO   649C (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int16 countchar; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
5E0C:  MOVLW  06
5E0E:  MOVWF  FEA
5E10:  MOVLW  E3
5E12:  MOVWF  FE9
5E14:  RCALL  5740
5E16:  CLRF   19
5E18:  BTFSC  FF2.7
5E1A:  BSF    19.7
5E1C:  BCF    FF2.7
5E1E:  MOVLW  3E
5E20:  MOVLB  8
5E22:  MOVWF  x52
5E24:  MOVLB  0
5E26:  CALL   15C0
5E2A:  BTFSC  19.7
5E2C:  BSF    FF2.7
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
5E2E:  MOVLW  01
5E30:  MOVLB  7
5E32:  MOVWF  xF1
5E34:  MOVLW  14
5E36:  MOVWF  xF2
5E38:  MOVLW  01
5E3A:  MOVWF  xF4
5E3C:  MOVLW  5E
5E3E:  MOVWF  xF3
5E40:  MOVLB  0
5E42:  RCALL  57C0
5E44:  CLRF   19
5E46:  BTFSC  FF2.7
5E48:  BSF    19.7
5E4A:  BCF    FF2.7
....................       printf("\n\r"); 
5E4C:  MOVLW  0A
5E4E:  MOVLB  8
5E50:  MOVWF  x52
5E52:  MOVLB  0
5E54:  CALL   15C0
5E58:  BTFSC  19.7
5E5A:  BSF    FF2.7
5E5C:  CLRF   19
5E5E:  BTFSC  FF2.7
5E60:  BSF    19.7
5E62:  BCF    FF2.7
5E64:  MOVLW  0D
5E66:  MOVLB  8
5E68:  MOVWF  x52
5E6A:  MOVLB  0
5E6C:  CALL   15C0
5E70:  BTFSC  19.7
5E72:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
5E74:  CLRF   FEA
5E76:  MOVLW  41
5E78:  MOVWF  FE9
5E7A:  MOVLW  00
5E7C:  CALL   0356
5E80:  TBLRD*-
5E82:  TBLRD*+
5E84:  MOVF   FF5,W
5E86:  MOVWF  FEE
5E88:  IORLW  00
5E8A:  BNZ   5E82
....................       index=0; 
5E8C:  MOVLB  7
5E8E:  CLRF   xB9
....................       ee_dat=0; 
5E90:  MOVLB  6
5E92:  CLRF   xD9
....................       count_card=1; 
5E94:  CLRF   xDB
5E96:  MOVLW  01
5E98:  MOVWF  xDA
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
5E9A:  MOVLB  7
5E9C:  MOVWF  xF2
5E9E:  MOVLW  5E
5EA0:  MOVWF  xF1
5EA2:  CLRF   xF4
5EA4:  MOVLW  41
5EA6:  MOVWF  xF3
5EA8:  MOVLB  0
5EAA:  RCALL  58F8
5EAC:  MOVF   01,F
5EAE:  BTFSS  FD8.2
5EB0:  BRA    62CC
....................       { 
....................          unsigned long adr=0; 
5EB2:  MOVLB  7
5EB4:  CLRF   xF0
5EB6:  CLRF   xEF
....................          //unsigned int count=0; 
....................          rec[0]=0; 
5EB8:  MOVLB  0
5EBA:  CLRF   x7D
5EBC:  CLRF   19
5EBE:  BTFSC  FF2.7
5EC0:  BSF    19.7
5EC2:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
5EC4:  CALL   34CC
5EC8:  BTFSC  19.7
5ECA:  BSF    FF2.7
5ECC:  MOVFF  02,6DD
5ED0:  MOVFF  01,6DC
5ED4:  CLRF   19
5ED6:  BTFSC  FF2.7
5ED8:  BSF    19.7
5EDA:  BCF    FF2.7
....................          adr=count_card*numdata; 
5EDC:  MOVFF  6DB,82F
5EE0:  MOVFF  6DA,82E
5EE4:  MOVLB  8
5EE6:  CLRF   x31
5EE8:  MOVLW  7C
5EEA:  MOVWF  x30
5EEC:  MOVLB  0
5EEE:  CALL   3524
5EF2:  BTFSC  19.7
5EF4:  BSF    FF2.7
5EF6:  MOVFF  02,7F0
5EFA:  MOVFF  01,7EF
....................          addr_key=EEPROM_KEY_ST; 
5EFE:  MOVLB  6
5F00:  CLRF   xE2
5F02:  MOVLW  01
5F04:  MOVWF  xE1
5F06:  MOVLW  C3
5F08:  MOVWF  xE0
5F0A:  MOVLW  0F
5F0C:  MOVWF  xDF
....................          while(count_card<=count_card_tg) 
....................          { 
5F0E:  MOVF   xDB,W
5F10:  SUBWF  xDD,W
5F12:  BTFSS  FD8.0
5F14:  BRA    62CA
5F16:  BNZ   5F20
5F18:  MOVF   xDA,W
5F1A:  SUBWF  xDC,W
5F1C:  BTFSS  FD8.0
5F1E:  BRA    62CA
5F20:  CLRF   19
5F22:  BTFSC  FF2.7
5F24:  BSF    19.7
5F26:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
5F28:  MOVFF  6DB,82F
5F2C:  MOVFF  6DA,82E
5F30:  MOVLB  8
5F32:  CLRF   x31
5F34:  MOVLW  7C
5F36:  MOVWF  x30
5F38:  MOVLB  0
5F3A:  CALL   3524
5F3E:  BTFSC  19.7
5F40:  BSF    FF2.7
5F42:  MOVLW  96
5F44:  MOVLB  7
5F46:  ADDWF  01,W
5F48:  MOVWF  xEF
5F4A:  MOVLW  00
5F4C:  ADDWFC 02,W
5F4E:  MOVWF  xF0
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
5F50:  MOVLW  7C
5F52:  SUBWF  xEF,W
5F54:  MOVWF  xF1
5F56:  MOVLW  00
5F58:  SUBWFB xF0,W
5F5A:  MOVWF  xF2
5F5C:  MOVWF  xF4
5F5E:  MOVFF  7F1,7F3
5F62:  CLRF   xF6
5F64:  MOVLW  7C
5F66:  MOVWF  xF5
5F68:  CLRF   xF8
5F6A:  MOVLW  7D
5F6C:  MOVWF  xF7
5F6E:  MOVLB  0
5F70:  BRA    5990
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
5F72:  MOVLW  10
5F74:  MOVWF  FE9
5F76:  CLRF   19
5F78:  BTFSC  FF2.7
5F7A:  BSF    19.7
5F7C:  BCF    FF2.7
5F7E:  MOVFF  6DB,82A
5F82:  MOVFF  6DA,829
5F86:  CALL   50C2
5F8A:  BTFSC  19.7
5F8C:  BSF    FF2.7
5F8E:  CLRF   19
5F90:  BTFSC  FF2.7
5F92:  BSF    19.7
5F94:  BCF    FF2.7
5F96:  MOVLW  29
5F98:  MOVLB  8
5F9A:  MOVWF  x52
5F9C:  MOVLB  0
5F9E:  CALL   15C0
5FA2:  BTFSC  19.7
5FA4:  BSF    FF2.7
5FA6:  MOVFF  7D,7F1
5FAA:  MOVLW  01
5FAC:  MOVLB  7
5FAE:  MOVWF  xF2
5FB0:  MOVLB  0
5FB2:  RCALL  5A06
5FB4:  CLRF   19
5FB6:  BTFSC  FF2.7
5FB8:  BSF    19.7
5FBA:  BCF    FF2.7
5FBC:  MOVLW  2F
5FBE:  MOVLB  8
5FC0:  MOVWF  x52
5FC2:  MOVLB  0
5FC4:  CALL   15C0
5FC8:  BTFSC  19.7
5FCA:  BSF    FF2.7
5FCC:  MOVFF  7E,7F1
5FD0:  MOVLW  01
5FD2:  MOVLB  7
5FD4:  MOVWF  xF2
5FD6:  MOVLB  0
5FD8:  RCALL  5A06
5FDA:  CLRF   19
5FDC:  BTFSC  FF2.7
5FDE:  BSF    19.7
5FE0:  BCF    FF2.7
5FE2:  MOVLW  20
5FE4:  MOVLB  8
5FE6:  MOVWF  x52
5FE8:  MOVLB  0
5FEA:  CALL   15C0
5FEE:  BTFSC  19.7
5FF0:  BSF    FF2.7
5FF2:  MOVFF  7F,7F1
5FF6:  MOVLW  01
5FF8:  MOVLB  7
5FFA:  MOVWF  xF2
5FFC:  MOVLB  0
5FFE:  RCALL  5A06
6000:  CLRF   19
6002:  BTFSC  FF2.7
6004:  BSF    19.7
6006:  BCF    FF2.7
6008:  MOVLW  3A
600A:  MOVLB  8
600C:  MOVWF  x52
600E:  MOVLB  0
6010:  CALL   15C0
6014:  BTFSC  19.7
6016:  BSF    FF2.7
6018:  MOVFF  80,7F1
601C:  MOVLW  01
601E:  MOVLB  7
6020:  MOVWF  xF2
6022:  MOVLB  0
6024:  RCALL  5A06
6026:  CLRF   19
6028:  BTFSC  FF2.7
602A:  BSF    19.7
602C:  BCF    FF2.7
602E:  MOVLW  3A
6030:  MOVLB  8
6032:  MOVWF  x52
6034:  MOVLB  0
6036:  CALL   15C0
603A:  BTFSC  19.7
603C:  BSF    FF2.7
603E:  MOVFF  81,7F1
6042:  MOVLW  01
6044:  MOVLB  7
6046:  MOVWF  xF2
6048:  MOVLB  0
604A:  RCALL  5A06
....................             ee_dat=0; 
604C:  MOVLB  6
604E:  CLRF   xD9
....................             index=0; 
6050:  MOVLB  7
6052:  CLRF   xB9
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
6054:  MOVLW  E4
6056:  MOVWF  FF6
6058:  MOVLW  1B
605A:  MOVWF  FF7
605C:  CLRF   19
605E:  BTFSC  FF2.7
6060:  BSF    19.7
6062:  BCF    FF2.7
6064:  MOVLB  0
6066:  CALL   16EA
606A:  BTFSC  19.7
606C:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
606E:  MOVLB  7
6070:  MOVF   xB9,W
6072:  SUBLW  4E
6074:  BNC   60D2
6076:  MOVLB  6
6078:  MOVF   xD9,W
607A:  SUBLW  3F
607C:  BTFSS  FD8.2
607E:  BRA    6084
6080:  MOVLB  7
6082:  BRA    60D2
....................                ee_dat = rec[index+5]; 
6084:  MOVLW  05
6086:  MOVLB  7
6088:  ADDWF  xB9,W
608A:  CLRF   03
608C:  ADDLW  7D
608E:  MOVWF  FE9
6090:  MOVLW  00
6092:  ADDWFC 03,W
6094:  MOVWF  FEA
6096:  MOVFF  FEF,6D9
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
609A:  MOVLB  6
609C:  MOVF   xD9,W
609E:  SUBLW  1F
60A0:  BC    60BE
60A2:  MOVF   xD9,W
60A4:  SUBLW  7E
60A6:  BNC   60BE
60A8:  CLRF   19
60AA:  BTFSC  FF2.7
60AC:  BSF    19.7
60AE:  BCF    FF2.7
60B0:  MOVFF  6D9,852
60B4:  MOVLB  0
60B6:  CALL   15C0
60BA:  BTFSC  19.7
60BC:  BSF    FF2.7
....................                index++; 
60BE:  MOVLB  7
60C0:  INCF   xB9,F
....................                if(ee_dat==0)break; 
60C2:  MOVLB  6
60C4:  MOVF   xD9,F
60C6:  BNZ   60CC
60C8:  MOVLB  7
60CA:  BRA    60D2
....................             } 
60CC:  MOVLB  0
60CE:  BRA    606E
60D0:  MOVLB  7
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
60D2:  MOVLW  F6
60D4:  MOVWF  FF6
60D6:  MOVLW  1B
60D8:  MOVWF  FF7
60DA:  CLRF   19
60DC:  BTFSC  FF2.7
60DE:  BSF    19.7
60E0:  BCF    FF2.7
60E2:  MOVLB  0
60E4:  CALL   16EA
60E8:  BTFSC  19.7
60EA:  BSF    FF2.7
....................             index=0; 
60EC:  MOVLB  7
60EE:  CLRF   xB9
....................             ee_dat=0; 
60F0:  MOVLB  6
60F2:  CLRF   xD9
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
60F4:  MOVLB  7
60F6:  MOVF   xB9,W
60F8:  SUBLW  27
60FA:  BNC   615A
60FC:  MOVLB  6
60FE:  MOVF   xD9,W
6100:  SUBLW  3F
6102:  BTFSS  FD8.2
6104:  BRA    610A
6106:  MOVLB  7
6108:  BRA    615A
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
610A:  MOVLW  05
610C:  MOVLB  7
610E:  ADDWF  xB9,W
6110:  ADDLW  4F
6112:  CLRF   03
6114:  ADDLW  7D
6116:  MOVWF  FE9
6118:  MOVLW  00
611A:  ADDWFC 03,W
611C:  MOVWF  FEA
611E:  MOVFF  FEF,6D9
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
6122:  MOVLB  6
6124:  MOVF   xD9,W
6126:  SUBLW  1F
6128:  BC    6146
612A:  MOVF   xD9,W
612C:  SUBLW  7E
612E:  BNC   6146
6130:  CLRF   19
6132:  BTFSC  FF2.7
6134:  BSF    19.7
6136:  BCF    FF2.7
6138:  MOVFF  6D9,852
613C:  MOVLB  0
613E:  CALL   15C0
6142:  BTFSC  19.7
6144:  BSF    FF2.7
....................                index++; 
6146:  MOVLB  7
6148:  INCF   xB9,F
....................                if(ee_dat==0)break; 
614A:  MOVLB  6
614C:  MOVF   xD9,F
614E:  BNZ   6156
6150:  MOVLB  7
6152:  BRA    615A
6154:  MOVLB  6
....................             } 
6156:  BRA    60F4
6158:  MOVLB  7
....................             index=0; 
615A:  CLRF   xB9
....................             //ee_dat=0; 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
615C:  MOVLW  08
615E:  MOVWF  FF6
6160:  MOVLW  1C
6162:  MOVWF  FF7
6164:  CLRF   19
6166:  BTFSC  FF2.7
6168:  BSF    19.7
616A:  BCF    FF2.7
616C:  MOVLB  0
616E:  CALL   16EA
6172:  BTFSC  19.7
6174:  BSF    FF2.7
....................             //fprintf(COM2,"addr_key =%lu \n\r",addr_key);  
....................             //fprintf(COM2," ptr_card_key=%lu \n\r",ptr_card_key); 
....................              
....................             if((ptr_card_key>addr_key)) //&& 
6176:  MOVLB  6
6178:  MOVF   xE2,W
617A:  SUBWF  27,W
617C:  BTFSS  FD8.0
617E:  BRA    62C2
6180:  BNZ   619E
6182:  MOVF   xE1,W
6184:  SUBWF  26,W
6186:  BTFSS  FD8.0
6188:  BRA    62C2
618A:  BNZ   619E
618C:  MOVF   xE0,W
618E:  SUBWF  25,W
6190:  BTFSS  FD8.0
6192:  BRA    62C2
6194:  BNZ   619E
6196:  MOVF   24,W
6198:  SUBWF  xDF,W
619A:  BTFSC  FD8.0
619C:  BRA    62C2
....................             { 
....................                i=0; 
619E:  MOVLB  7
61A0:  CLRF   xBA
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
61A2:  MOVF   xBA,W
61A4:  MOVLB  6
61A6:  ADDWF  xDF,W
61A8:  MOVLB  7
61AA:  MOVWF  xF1
61AC:  MOVLW  00
61AE:  MOVLB  6
61B0:  ADDWFC xE0,W
61B2:  MOVLB  7
61B4:  MOVWF  xF2
61B6:  MOVLW  00
61B8:  MOVLB  6
61BA:  ADDWFC xE1,W
61BC:  MOVLB  7
61BE:  MOVWF  xF3
61C0:  MOVLW  00
61C2:  MOVLB  6
61C4:  ADDWFC xE2,W
61C6:  MOVLB  7
61C8:  MOVWF  xF4
61CA:  CLRF   19
61CC:  BTFSC  FF2.7
61CE:  BSF    19.7
61D0:  BCF    FF2.7
61D2:  MOVFF  FE8,846
61D6:  MOVFF  7F3,845
61DA:  MOVFF  7F2,844
61DE:  MOVFF  7F1,843
61E2:  MOVLB  0
61E4:  CALL   3400
61E8:  BTFSC  19.7
61EA:  BSF    FF2.7
61EC:  MOVFF  01,6D9
....................                   if(cryption_enable==0) 
61F0:  MOVLB  1
61F2:  MOVF   x1E,F
61F4:  BNZ   6238
....................                   { 
....................                       if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
61F6:  MOVLB  6
61F8:  MOVF   xD9,W
61FA:  SUBLW  2F
61FC:  BC    6204
61FE:  MOVF   xD9,W
6200:  SUBLW  39
6202:  BC    621C
6204:  MOVF   xD9,W
6206:  SUBLW  23
6208:  BZ    621C
620A:  MOVF   xD9,W
620C:  SUBLW  2A
620E:  BZ    621C
6210:  MOVF   xD9,W
6212:  SUBLW  40
6214:  BC    6234
6216:  MOVF   xD9,W
6218:  SUBLW  5A
621A:  BNC   6234
621C:  CLRF   19
621E:  BTFSC  FF2.7
6220:  BSF    19.7
6222:  BCF    FF2.7
....................                       { 
....................                          fprintf(COM2,"%c",ee_dat); 
6224:  MOVFF  6D9,852
6228:  MOVLB  0
622A:  CALL   15C0
622E:  BTFSC  19.7
6230:  BSF    FF2.7
6232:  MOVLB  6
....................                       } 
....................                   } 
....................                   else 
6234:  BRA    626C
6236:  MOVLB  1
6238:  CLRF   19
623A:  BTFSC  FF2.7
623C:  BSF    19.7
623E:  BCF    FF2.7
....................                   { 
....................                       fprintf(COM2," %x",ee_dat); 
6240:  MOVLW  20
6242:  MOVLB  8
6244:  MOVWF  x52
6246:  MOVLB  0
6248:  CALL   15C0
624C:  BTFSC  19.7
624E:  BSF    FF2.7
6250:  CLRF   19
6252:  BTFSC  FF2.7
6254:  BSF    19.7
6256:  BCF    FF2.7
6258:  MOVFF  6D9,83E
625C:  MOVLW  57
625E:  MOVLB  8
6260:  MOVWF  x3F
6262:  MOVLB  0
6264:  CALL   4D74
6268:  BTFSC  19.7
626A:  BSF    FF2.7
....................                   } 
....................                   i++; 
626C:  MOVLB  7
626E:  INCF   xBA,F
....................                } 
....................                while((i<wideofkeystore)&&(ee_dat!=0)); 
6270:  MOVF   xBA,W
6272:  SUBLW  0F
6274:  BNC   6282
6276:  MOVLB  6
6278:  MOVF   xD9,F
627A:  BTFSC  FD8.2
627C:  BRA    6282
627E:  MOVLB  7
6280:  BRA    61A2
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+wideofkeystore; 
6282:  MOVLW  10
6284:  MOVLB  6
6286:  ADDWF  xDF,F
6288:  MOVLW  00
628A:  ADDWFC xE0,F
628C:  ADDWFC xE1,F
628E:  ADDWFC xE2,F
6290:  CLRF   19
6292:  BTFSC  FF2.7
6294:  BSF    19.7
6296:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
6298:  MOVLW  0A
629A:  MOVLB  8
629C:  MOVWF  x52
629E:  MOVLB  0
62A0:  CALL   15C0
62A4:  BTFSC  19.7
62A6:  BSF    FF2.7
62A8:  CLRF   19
62AA:  BTFSC  FF2.7
62AC:  BSF    19.7
62AE:  BCF    FF2.7
62B0:  MOVLW  0D
62B2:  MOVLB  8
62B4:  MOVWF  x52
62B6:  MOVLB  0
62B8:  CALL   15C0
62BC:  BTFSC  19.7
62BE:  BSF    FF2.7
62C0:  MOVLB  6
....................             } 
....................             count_card++; 
62C2:  INCF   xDA,F
62C4:  BTFSC  FD8.2
62C6:  INCF   xDB,F
....................          } 
62C8:  BRA    5F0E
62CA:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
62CC:  CLRF   FEA
62CE:  MOVLW  41
62D0:  MOVWF  FE9
62D2:  MOVLW  00
62D4:  CALL   0368
62D8:  TBLRD*-
62DA:  TBLRD*+
62DC:  MOVF   FF5,W
62DE:  MOVWF  FEE
62E0:  IORLW  00
62E2:  BNZ   62DA
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
62E4:  MOVLW  01
62E6:  MOVLB  7
62E8:  MOVWF  xF2
62EA:  MOVLW  5E
62EC:  MOVWF  xF1
62EE:  CLRF   xF4
62F0:  MOVLW  41
62F2:  MOVWF  xF3
62F4:  MOVLB  0
62F6:  CALL   58F8
62FA:  MOVF   01,F
62FC:  BNZ   6330
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
62FE:  MOVLW  18
6300:  MOVWF  FF6
6302:  MOVLW  1C
6304:  MOVWF  FF7
6306:  CLRF   19
6308:  BTFSC  FF2.7
630A:  BSF    19.7
630C:  BCF    FF2.7
630E:  CALL   16EA
6312:  BTFSC  19.7
6314:  BSF    FF2.7
....................          format_eepromext(); 
6316:  BRA    5B20
....................          fprintf(COM2," exit\n\r");  
6318:  MOVLW  26
631A:  MOVWF  FF6
631C:  MOVLW  1C
631E:  MOVWF  FF7
6320:  CLRF   19
6322:  BTFSC  FF2.7
6324:  BSF    19.7
6326:  BCF    FF2.7
6328:  CALL   16EA
632C:  BTFSC  19.7
632E:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
6330:  CLRF   FEA
6332:  MOVLW  41
6334:  MOVWF  FE9
6336:  MOVLW  00
6338:  CALL   037A
633C:  TBLRD*-
633E:  TBLRD*+
6340:  MOVF   FF5,W
6342:  MOVWF  FEE
6344:  IORLW  00
6346:  BNZ   633E
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6348:  MOVLW  01
634A:  MOVLB  7
634C:  MOVWF  xF2
634E:  MOVLW  5E
6350:  MOVWF  xF1
6352:  CLRF   xF4
6354:  MOVLW  41
6356:  MOVWF  xF3
6358:  MOVLB  0
635A:  CALL   58F8
635E:  MOVF   01,F
6360:  BNZ   6394
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6362:  MOVLW  2E
6364:  MOVWF  FF6
6366:  MOVLW  1C
6368:  MOVWF  FF7
636A:  CLRF   19
636C:  BTFSC  FF2.7
636E:  BSF    19.7
6370:  BCF    FF2.7
6372:  CALL   16EA
6376:  BTFSC  19.7
6378:  BSF    FF2.7
....................          ease_eeprom(); 
637A:  BRA    5BBC
....................          fprintf(COM2," exit\n\r");  
637C:  MOVLW  3C
637E:  MOVWF  FF6
6380:  MOVLW  1C
6382:  MOVWF  FF7
6384:  CLRF   19
6386:  BTFSC  FF2.7
6388:  BSF    19.7
638A:  BCF    FF2.7
638C:  CALL   16EA
6390:  BTFSC  19.7
6392:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6394:  CLRF   FEA
6396:  MOVLW  41
6398:  MOVWF  FE9
639A:  MOVLW  00
639C:  CALL   0390
63A0:  TBLRD*-
63A2:  TBLRD*+
63A4:  MOVF   FF5,W
63A6:  MOVWF  FEE
63A8:  IORLW  00
63AA:  BNZ   63A2
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
63AC:  MOVLW  01
63AE:  MOVLB  7
63B0:  MOVWF  xF2
63B2:  MOVLW  5E
63B4:  MOVWF  xF1
63B6:  CLRF   xF4
63B8:  MOVLW  41
63BA:  MOVWF  xF3
63BC:  MOVLB  0
63BE:  CALL   58F8
63C2:  MOVF   01,F
63C4:  BNZ   63FC
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
63C6:  MOVLW  44
63C8:  MOVWF  FF6
63CA:  MOVLW  1C
63CC:  MOVWF  FF7
63CE:  CLRF   19
63D0:  BTFSC  FF2.7
63D2:  BSF    19.7
63D4:  BCF    FF2.7
63D6:  CALL   16EA
63DA:  BTFSC  19.7
63DC:  BSF    FF2.7
....................          reset_password(); 
63DE:  BRA    5C40
....................          init_password(); 
63E0:  CALL   554A
....................          fprintf(COM2," exit\n\r");  
63E4:  MOVLW  5A
63E6:  MOVWF  FF6
63E8:  MOVLW  1C
63EA:  MOVWF  FF7
63EC:  CLRF   19
63EE:  BTFSC  FF2.7
63F0:  BSF    19.7
63F2:  BCF    FF2.7
63F4:  CALL   16EA
63F8:  BTFSC  19.7
63FA:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
63FC:  CLRF   FEA
63FE:  MOVLW  41
6400:  MOVWF  FE9
6402:  MOVLW  00
6404:  CALL   03A6
6408:  TBLRD*-
640A:  TBLRD*+
640C:  MOVF   FF5,W
640E:  MOVWF  FEE
6410:  IORLW  00
6412:  BNZ   640A
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6414:  MOVLW  01
6416:  MOVLB  7
6418:  MOVWF  xF2
641A:  MOVLW  5E
641C:  MOVWF  xF1
641E:  CLRF   xF4
6420:  MOVLW  41
6422:  MOVWF  xF3
6424:  MOVLB  0
6426:  CALL   58F8
642A:  MOVF   01,F
642C:  BNZ   644E
....................       { 
....................          keydebug_en=1; 
642E:  MOVLW  01
6430:  MOVLB  1
6432:  MOVWF  x40
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
6434:  MOVLW  62
6436:  MOVWF  FF6
6438:  MOVLW  1C
643A:  MOVWF  FF7
643C:  CLRF   19
643E:  BTFSC  FF2.7
6440:  BSF    19.7
6442:  BCF    FF2.7
6444:  MOVLB  0
6446:  CALL   16EA
644A:  BTFSC  19.7
644C:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
644E:  CLRF   FEA
6450:  MOVLW  41
6452:  MOVWF  FE9
6454:  MOVLW  00
6456:  CALL   03BC
645A:  TBLRD*-
645C:  TBLRD*+
645E:  MOVF   FF5,W
6460:  MOVWF  FEE
6462:  IORLW  00
6464:  BNZ   645C
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6466:  MOVLW  01
6468:  MOVLB  7
646A:  MOVWF  xF2
646C:  MOVLW  5E
646E:  MOVWF  xF1
6470:  CLRF   xF4
6472:  MOVLW  41
6474:  MOVWF  xF3
6476:  MOVLB  0
6478:  CALL   58F8
647C:  MOVF   01,F
647E:  BNZ   649C
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6480:  MOVLW  76
6482:  MOVWF  FF6
6484:  MOVLW  1C
6486:  MOVWF  FF7
6488:  CLRF   19
648A:  BTFSC  FF2.7
648C:  BSF    19.7
648E:  BCF    FF2.7
6490:  CALL   16EA
6494:  BTFSC  19.7
6496:  BSF    FF2.7
....................          rstfact(); 
6498:  GOTO   5C8E
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
649C:  CLRF   FEA
649E:  MOVLW  41
64A0:  MOVWF  FE9
64A2:  MOVLW  00
64A4:  CALL   03D4
64A8:  TBLRD*-
64AA:  TBLRD*+
64AC:  MOVF   FF5,W
64AE:  MOVWF  FEE
64B0:  IORLW  00
64B2:  BNZ   64AA
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
64B4:  MOVLW  01
64B6:  MOVLB  7
64B8:  MOVWF  xF2
64BA:  MOVLW  5E
64BC:  MOVWF  xF1
64BE:  CLRF   xF4
64C0:  MOVLW  41
64C2:  MOVWF  xF3
64C4:  MOVLB  0
64C6:  CALL   58F8
64CA:  MOVF   01,F
64CC:  BNZ   64F4
....................       { 
....................          mode=LOGOFF; 
64CE:  MOVLB  6
64D0:  CLRF   xD8
....................          keydebug_en=0; 
64D2:  MOVLB  1
64D4:  CLRF   x40
....................          set_tris_a(0xff); 
64D6:  MOVLW  FF
64D8:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
64DA:  MOVLW  86
64DC:  MOVWF  FF6
64DE:  MOVLW  1C
64E0:  MOVWF  FF7
64E2:  CLRF   19
64E4:  BTFSC  FF2.7
64E6:  BSF    19.7
64E8:  BCF    FF2.7
64EA:  MOVLB  0
64EC:  CALL   16EA
64F0:  BTFSC  19.7
64F2:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
64F4:  CLRF   FEA
64F6:  MOVLW  41
64F8:  MOVWF  FE9
64FA:  MOVLW  00
64FC:  CALL   03E6
6500:  TBLRD*-
6502:  TBLRD*+
6504:  MOVF   FF5,W
6506:  MOVWF  FEE
6508:  IORLW  00
650A:  BNZ   6502
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
650C:  MOVLW  01
650E:  MOVLB  7
6510:  MOVWF  xF2
6512:  MOVLW  5E
6514:  MOVWF  xF1
6516:  CLRF   xF4
6518:  MOVLW  41
651A:  MOVWF  xF3
651C:  MOVLB  0
651E:  CALL   58F8
6522:  MOVF   01,F
6524:  BNZ   659E
....................       { 
....................          fprintf(COM2,"New console name>"); 
6526:  MOVLW  8E
6528:  MOVWF  FF6
652A:  MOVLW  1C
652C:  MOVWF  FF7
652E:  CLRF   19
6530:  BTFSC  FF2.7
6532:  BSF    19.7
6534:  BCF    FF2.7
6536:  CALL   16EA
653A:  BTFSC  19.7
653C:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,wide_strobe_nameconsole, console); 
653E:  MOVLW  01
6540:  MOVLB  7
6542:  MOVWF  xF1
6544:  MOVLW  10
6546:  MOVWF  xF2
6548:  MOVLW  06
654A:  MOVWF  xF4
654C:  MOVLW  E3
654E:  MOVWF  xF3
6550:  MOVLB  0
6552:  CALL   57C0
6556:  CLRF   19
6558:  BTFSC  FF2.7
655A:  BSF    19.7
655C:  BCF    FF2.7
....................          EEPROM_write(strobe_nameconsole,wide_strobe_nameconsole,console); 
655E:  MOVLB  8
6560:  CLRF   x40
6562:  CLRF   x3F
6564:  CLRF   x3E
6566:  MOVLW  28
6568:  MOVWF  x3D
656A:  CLRF   x44
656C:  CLRF   x43
656E:  CLRF   x42
6570:  MOVLW  10
6572:  MOVWF  x41
6574:  MOVLW  06
6576:  MOVWF  x46
6578:  MOVLW  E3
657A:  MOVWF  x45
657C:  MOVLB  0
657E:  CALL   4DBE
6582:  BTFSC  19.7
6584:  BSF    FF2.7
....................          fprintf(COM2," OK\n\r"); 
6586:  MOVLW  A0
6588:  MOVWF  FF6
658A:  MOVLW  1C
658C:  MOVWF  FF7
658E:  CLRF   19
6590:  BTFSC  FF2.7
6592:  BSF    19.7
6594:  BCF    FF2.7
6596:  CALL   16EA
659A:  BTFSC  19.7
659C:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
659E:  CLRF   FEA
65A0:  MOVLW  41
65A2:  MOVWF  FE9
65A4:  MOVLW  00
65A6:  CALL   03F8
65AA:  TBLRD*-
65AC:  TBLRD*+
65AE:  MOVF   FF5,W
65B0:  MOVWF  FEE
65B2:  IORLW  00
65B4:  BNZ   65AC
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
65B6:  MOVLW  01
65B8:  MOVLB  7
65BA:  MOVWF  xF2
65BC:  MOVLW  5E
65BE:  MOVWF  xF1
65C0:  CLRF   xF4
65C2:  MOVLW  41
65C4:  MOVWF  xF3
65C6:  MOVLB  0
65C8:  CALL   58F8
65CC:  MOVF   01,F
65CE:  BTFSS  FD8.2
65D0:  BRA    6774
65D2:  CLRF   19
65D4:  BTFSC  FF2.7
65D6:  BSF    19.7
65D8:  BCF    FF2.7
....................       { 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
65DA:  MOVLB  8
65DC:  CLRF   x46
65DE:  CLRF   x45
65E0:  CLRF   x44
65E2:  MOVLW  3A
65E4:  MOVWF  x43
65E6:  MOVLB  0
65E8:  CALL   3400
65EC:  BTFSC  19.7
65EE:  BSF    FF2.7
65F0:  MOVFF  01,6DE
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
65F4:  MOVLB  6
65F6:  MOVF   xDE,F
65F8:  BNZ   6618
65FA:  MOVLW  A6
65FC:  MOVWF  FF6
65FE:  MOVLW  1C
6600:  MOVWF  FF7
6602:  CLRF   19
6604:  BTFSC  FF2.7
6606:  BSF    19.7
6608:  BCF    FF2.7
660A:  MOVLB  0
660C:  CALL   16EA
6610:  BTFSC  19.7
6612:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6614:  BRA    6632
6616:  MOVLB  6
6618:  MOVLW  AA
661A:  MOVWF  FF6
661C:  MOVLW  1C
661E:  MOVWF  FF7
6620:  CLRF   19
6622:  BTFSC  FF2.7
6624:  BSF    19.7
6626:  BCF    FF2.7
6628:  MOVLB  0
662A:  CALL   16EA
662E:  BTFSC  19.7
6630:  BSF    FF2.7
6632:  CLRF   19
6634:  BTFSC  FF2.7
6636:  BSF    19.7
6638:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
663A:  MOVLB  8
663C:  CLRF   x46
663E:  CLRF   x45
6640:  CLRF   x44
6642:  MOVLW  3C
6644:  MOVWF  x43
6646:  MOVLB  0
6648:  CALL   3400
664C:  BTFSC  19.7
664E:  BSF    FF2.7
6650:  MOVFF  01,156
6654:  CLRF   19
6656:  BTFSC  FF2.7
6658:  BSF    19.7
665A:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
665C:  MOVLW  5B
665E:  MOVLB  8
6660:  MOVWF  x52
6662:  MOVLB  0
6664:  CALL   15C0
6668:  BTFSC  19.7
666A:  BSF    FF2.7
666C:  MOVFF  156,7F1
6670:  MOVLW  1B
6672:  MOVLB  7
6674:  MOVWF  xF2
6676:  MOVLB  0
6678:  GOTO   5CF8
667C:  CLRF   19
667E:  BTFSC  FF2.7
6680:  BSF    19.7
6682:  BCF    FF2.7
6684:  MOVLW  5D
6686:  MOVLB  8
6688:  MOVWF  x52
668A:  MOVLB  0
668C:  CALL   15C0
6690:  BTFSC  19.7
6692:  BSF    FF2.7
....................           
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
6694:  MOVFF  1C7,7F1
6698:  MOVLW  01
669A:  MOVLB  7
669C:  MOVWF  xF2
669E:  MOVLB  0
66A0:  CALL   5A06
66A4:  CLRF   19
66A6:  BTFSC  FF2.7
66A8:  BSF    19.7
66AA:  BCF    FF2.7
66AC:  MOVLW  2F
66AE:  MOVLB  8
66B0:  MOVWF  x52
66B2:  MOVLB  0
66B4:  CALL   15C0
66B8:  BTFSC  19.7
66BA:  BSF    FF2.7
66BC:  MOVFF  1C6,7F1
66C0:  MOVLW  01
66C2:  MOVLB  7
66C4:  MOVWF  xF2
66C6:  MOVLB  0
66C8:  CALL   5A06
66CC:  CLRF   19
66CE:  BTFSC  FF2.7
66D0:  BSF    19.7
66D2:  BCF    FF2.7
66D4:  MOVLW  20
66D6:  MOVLB  8
66D8:  MOVWF  x52
66DA:  MOVLB  0
66DC:  CALL   15C0
66E0:  BTFSC  19.7
66E2:  BSF    FF2.7
66E4:  MOVFF  1C8,7F1
66E8:  MOVLW  01
66EA:  MOVLB  7
66EC:  MOVWF  xF2
66EE:  MOVLB  0
66F0:  CALL   5A06
66F4:  CLRF   19
66F6:  BTFSC  FF2.7
66F8:  BSF    19.7
66FA:  BCF    FF2.7
66FC:  MOVLW  3A
66FE:  MOVLB  8
6700:  MOVWF  x52
6702:  MOVLB  0
6704:  CALL   15C0
6708:  BTFSC  19.7
670A:  BSF    FF2.7
670C:  MOVFF  1C9,7F1
6710:  MOVLW  01
6712:  MOVLB  7
6714:  MOVWF  xF2
6716:  MOVLB  0
6718:  CALL   5A06
671C:  CLRF   19
671E:  BTFSC  FF2.7
6720:  BSF    19.7
6722:  BCF    FF2.7
6724:  MOVLW  3A
6726:  MOVLB  8
6728:  MOVWF  x52
672A:  MOVLB  0
672C:  CALL   15C0
6730:  BTFSC  19.7
6732:  BSF    FF2.7
6734:  MOVFF  1CA,7F1
6738:  MOVLW  01
673A:  MOVLB  7
673C:  MOVWF  xF2
673E:  MOVLB  0
6740:  CALL   5A06
6744:  CLRF   19
6746:  BTFSC  FF2.7
6748:  BSF    19.7
674A:  BCF    FF2.7
....................           
....................          fprintf(COM2,"\n\r"); 
674C:  MOVLW  0A
674E:  MOVLB  8
6750:  MOVWF  x52
6752:  MOVLB  0
6754:  CALL   15C0
6758:  BTFSC  19.7
675A:  BSF    FF2.7
675C:  CLRF   19
675E:  BTFSC  FF2.7
6760:  BSF    19.7
6762:  BCF    FF2.7
6764:  MOVLW  0D
6766:  MOVLB  8
6768:  MOVWF  x52
676A:  MOVLB  0
676C:  CALL   15C0
6770:  BTFSC  19.7
6772:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
6774:  CLRF   FEA
6776:  MOVLW  41
6778:  MOVWF  FE9
677A:  MOVLW  00
677C:  CALL   040A
6780:  TBLRD*-
6782:  TBLRD*+
6784:  MOVF   FF5,W
6786:  MOVWF  FEE
6788:  IORLW  00
678A:  BNZ   6782
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
678C:  MOVLW  01
678E:  MOVLB  7
6790:  MOVWF  xF2
6792:  MOVLW  5E
6794:  MOVWF  xF1
6796:  CLRF   xF4
6798:  MOVLW  41
679A:  MOVWF  xF3
679C:  MOVLB  0
679E:  CALL   58F8
67A2:  MOVF   01,F
67A4:  BTFSS  FD8.2
67A6:  BRA    69B4
....................       { 
....................          fprintf(COM2,"Year>"); 
67A8:  MOVLW  AE
67AA:  MOVWF  FF6
67AC:  MOVLW  1C
67AE:  MOVWF  FF7
67B0:  CLRF   19
67B2:  BTFSC  FF2.7
67B4:  BSF    19.7
67B6:  BCF    FF2.7
67B8:  CALL   16EA
67BC:  BTFSC  19.7
67BE:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
67C0:  MOVLW  01
67C2:  MOVLB  7
67C4:  MOVWF  xF1
67C6:  MOVLW  03
67C8:  MOVWF  xF2
67CA:  MOVLW  07
67CC:  MOVWF  xF4
67CE:  MOVLW  BD
67D0:  MOVWF  xF3
67D2:  MOVLB  0
67D4:  CALL   57C0
....................          year=(unsigned int8)strtoi(temp); 
67D8:  MOVLW  07
67DA:  MOVLB  7
67DC:  MOVWF  xF2
67DE:  MOVLW  BD
67E0:  MOVWF  xF1
67E2:  MOVLB  0
67E4:  CALL   5DBE
67E8:  MOVFF  01,1C5
....................          fprintf(COM2,"Month>"); 
67EC:  MOVLW  B4
67EE:  MOVWF  FF6
67F0:  MOVLW  1C
67F2:  MOVWF  FF7
67F4:  CLRF   19
67F6:  BTFSC  FF2.7
67F8:  BSF    19.7
67FA:  BCF    FF2.7
67FC:  CALL   16EA
6800:  BTFSC  19.7
6802:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6804:  MOVLW  01
6806:  MOVLB  7
6808:  MOVWF  xF1
680A:  MOVLW  03
680C:  MOVWF  xF2
680E:  MOVLW  07
6810:  MOVWF  xF4
6812:  MOVLW  BD
6814:  MOVWF  xF3
6816:  MOVLB  0
6818:  CALL   57C0
....................          mon=(unsigned int8)strtoi(temp); 
681C:  MOVLW  07
681E:  MOVLB  7
6820:  MOVWF  xF2
6822:  MOVLW  BD
6824:  MOVWF  xF1
6826:  MOVLB  0
6828:  CALL   5DBE
682C:  MOVFF  01,1C6
....................          fprintf(COM2,"Date>"); 
6830:  MOVLW  BC
6832:  MOVWF  FF6
6834:  MOVLW  1C
6836:  MOVWF  FF7
6838:  CLRF   19
683A:  BTFSC  FF2.7
683C:  BSF    19.7
683E:  BCF    FF2.7
6840:  CALL   16EA
6844:  BTFSC  19.7
6846:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6848:  MOVLW  01
684A:  MOVLB  7
684C:  MOVWF  xF1
684E:  MOVLW  03
6850:  MOVWF  xF2
6852:  MOVLW  07
6854:  MOVWF  xF4
6856:  MOVLW  BD
6858:  MOVWF  xF3
685A:  MOVLB  0
685C:  CALL   57C0
....................          date = (unsigned int8)strtoi(temp); 
6860:  MOVLW  07
6862:  MOVLB  7
6864:  MOVWF  xF2
6866:  MOVLW  BD
6868:  MOVWF  xF1
686A:  MOVLB  0
686C:  CALL   5DBE
6870:  MOVFF  01,1C7
....................          fprintf(COM2,"Day>"); 
6874:  MOVLW  C2
6876:  MOVWF  FF6
6878:  MOVLW  1C
687A:  MOVWF  FF7
687C:  CLRF   19
687E:  BTFSC  FF2.7
6880:  BSF    19.7
6882:  BCF    FF2.7
6884:  CALL   16EA
6888:  BTFSC  19.7
688A:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
688C:  MOVLW  01
688E:  MOVLB  7
6890:  MOVWF  xF1
6892:  MOVLW  03
6894:  MOVWF  xF2
6896:  MOVLW  07
6898:  MOVWF  xF4
689A:  MOVLW  BD
689C:  MOVWF  xF3
689E:  MOVLB  0
68A0:  CALL   57C0
....................          day = (unsigned int8)strtoi(temp); 
68A4:  MOVLW  07
68A6:  MOVLB  7
68A8:  MOVWF  xF2
68AA:  MOVLW  BD
68AC:  MOVWF  xF1
68AE:  MOVLB  0
68B0:  CALL   5DBE
68B4:  MOVFF  01,1C4
....................          fprintf(COM2,"Hour>"); 
68B8:  MOVLW  C8
68BA:  MOVWF  FF6
68BC:  MOVLW  1C
68BE:  MOVWF  FF7
68C0:  CLRF   19
68C2:  BTFSC  FF2.7
68C4:  BSF    19.7
68C6:  BCF    FF2.7
68C8:  CALL   16EA
68CC:  BTFSC  19.7
68CE:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
68D0:  MOVLW  01
68D2:  MOVLB  7
68D4:  MOVWF  xF1
68D6:  MOVLW  03
68D8:  MOVWF  xF2
68DA:  MOVLW  07
68DC:  MOVWF  xF4
68DE:  MOVLW  BD
68E0:  MOVWF  xF3
68E2:  MOVLB  0
68E4:  CALL   57C0
....................          h = (unsigned int8)strtoi(temp); 
68E8:  MOVLW  07
68EA:  MOVLB  7
68EC:  MOVWF  xF2
68EE:  MOVLW  BD
68F0:  MOVWF  xF1
68F2:  MOVLB  0
68F4:  CALL   5DBE
68F8:  MOVFF  01,1C8
....................          fprintf(COM2,"Minutes>"); 
68FC:  MOVLW  CE
68FE:  MOVWF  FF6
6900:  MOVLW  1C
6902:  MOVWF  FF7
6904:  CLRF   19
6906:  BTFSC  FF2.7
6908:  BSF    19.7
690A:  BCF    FF2.7
690C:  CALL   16EA
6910:  BTFSC  19.7
6912:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6914:  MOVLW  01
6916:  MOVLB  7
6918:  MOVWF  xF1
691A:  MOVLW  03
691C:  MOVWF  xF2
691E:  MOVLW  07
6920:  MOVWF  xF4
6922:  MOVLW  BD
6924:  MOVWF  xF3
6926:  MOVLB  0
6928:  CALL   57C0
....................          min = (unsigned int8)strtoi(temp);                   
692C:  MOVLW  07
692E:  MOVLB  7
6930:  MOVWF  xF2
6932:  MOVLW  BD
6934:  MOVWF  xF1
6936:  MOVLB  0
6938:  CALL   5DBE
693C:  MOVFF  01,1C9
....................          fprintf(COM2,"Seconds>"); 
6940:  MOVLW  D8
6942:  MOVWF  FF6
6944:  MOVLW  1C
6946:  MOVWF  FF7
6948:  CLRF   19
694A:  BTFSC  FF2.7
694C:  BSF    19.7
694E:  BCF    FF2.7
6950:  CALL   16EA
6954:  BTFSC  19.7
6956:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6958:  MOVLW  01
695A:  MOVLB  7
695C:  MOVWF  xF1
695E:  MOVLW  03
6960:  MOVWF  xF2
6962:  MOVLW  07
6964:  MOVWF  xF4
6966:  MOVLW  BD
6968:  MOVWF  xF3
696A:  MOVLB  0
696C:  CALL   57C0
....................          sec = (unsigned int8)strtoi(temp);                   
6970:  MOVLW  07
6972:  MOVLB  7
6974:  MOVWF  xF2
6976:  MOVLW  BD
6978:  MOVWF  xF1
697A:  MOVLB  0
697C:  CALL   5DBE
6980:  MOVFF  01,1CA
6984:  CLRF   19
6986:  BTFSC  FF2.7
6988:  BSF    19.7
698A:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
698C:  MOVLW  0A
698E:  MOVLB  8
6990:  MOVWF  x52
6992:  MOVLB  0
6994:  CALL   15C0
6998:  BTFSC  19.7
699A:  BSF    FF2.7
699C:  CLRF   19
699E:  BTFSC  FF2.7
69A0:  BSF    19.7
69A2:  BCF    FF2.7
69A4:  MOVLW  0D
69A6:  MOVLB  8
69A8:  MOVWF  x52
69AA:  MOVLB  0
69AC:  CALL   15C0
69B0:  BTFSC  19.7
69B2:  BSF    FF2.7
....................          /* rtc_set_datetime(date,mon,year,day,h,min); */ 
....................       } 
....................       strcpy(buffer2,"MS"); 
69B4:  CLRF   FEA
69B6:  MOVLW  41
69B8:  MOVWF  FE9
69BA:  MOVLW  00
69BC:  CALL   041E
69C0:  TBLRD*-
69C2:  TBLRD*+
69C4:  MOVF   FF5,W
69C6:  MOVWF  FEE
69C8:  IORLW  00
69CA:  BNZ   69C2
....................       if(!stringcomp(buffer_uart,buffer2)) 
69CC:  MOVLW  01
69CE:  MOVLB  7
69D0:  MOVWF  xF2
69D2:  MOVLW  5E
69D4:  MOVWF  xF1
69D6:  CLRF   xF4
69D8:  MOVLW  41
69DA:  MOVWF  xF3
69DC:  MOVLB  0
69DE:  CALL   58F8
69E2:  MOVF   01,F
69E4:  BTFSS  FD8.2
69E6:  BRA    6AFA
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
69E8:  MOVLW  E2
69EA:  MOVWF  FF6
69EC:  MOVLW  1C
69EE:  MOVWF  FF7
69F0:  CLRF   19
69F2:  BTFSC  FF2.7
69F4:  BSF    19.7
69F6:  BCF    FF2.7
69F8:  CALL   16EA
69FC:  BTFSC  19.7
69FE:  BSF    FF2.7
6A00:  CLRF   19
6A02:  BTFSC  FF2.7
6A04:  BSF    19.7
6A06:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6A08:  MOVLW  0A
6A0A:  MOVLB  8
6A0C:  MOVWF  x52
6A0E:  MOVLB  0
6A10:  CALL   15C0
6A14:  BTFSC  19.7
6A16:  BSF    FF2.7
6A18:  CLRF   19
6A1A:  BTFSC  FF2.7
6A1C:  BSF    19.7
6A1E:  BCF    FF2.7
6A20:  MOVLW  0D
6A22:  MOVLB  8
6A24:  MOVWF  x52
6A26:  MOVLB  0
6A28:  CALL   15C0
6A2C:  BTFSC  19.7
6A2E:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
6A30:  MOVLW  02
6A32:  MOVWF  FF6
6A34:  MOVLW  1D
6A36:  MOVWF  FF7
6A38:  CLRF   19
6A3A:  BTFSC  FF2.7
6A3C:  BSF    19.7
6A3E:  BCF    FF2.7
6A40:  CALL   16EA
6A44:  BTFSC  19.7
6A46:  BSF    FF2.7
6A48:  CLRF   19
6A4A:  BTFSC  FF2.7
6A4C:  BSF    19.7
6A4E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6A50:  MOVLW  0A
6A52:  MOVLB  8
6A54:  MOVWF  x52
6A56:  MOVLB  0
6A58:  CALL   15C0
6A5C:  BTFSC  19.7
6A5E:  BSF    FF2.7
6A60:  CLRF   19
6A62:  BTFSC  FF2.7
6A64:  BSF    19.7
6A66:  BCF    FF2.7
6A68:  MOVLW  0D
6A6A:  MOVLB  8
6A6C:  MOVWF  x52
6A6E:  MOVLB  0
6A70:  CALL   15C0
6A74:  BTFSC  19.7
6A76:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6A78:  MOVLW  01
6A7A:  MOVLB  7
6A7C:  MOVWF  xF1
6A7E:  MOVLW  03
6A80:  MOVWF  xF2
6A82:  MOVLW  07
6A84:  MOVWF  xF4
6A86:  MOVLW  BD
6A88:  MOVWF  xF3
6A8A:  MOVLB  0
6A8C:  CALL   57C0
....................           mode_sl = (unsigned int8)strtoi(temp); 
6A90:  MOVLW  07
6A92:  MOVLB  7
6A94:  MOVWF  xF2
6A96:  MOVLW  BD
6A98:  MOVWF  xF1
6A9A:  MOVLB  0
6A9C:  CALL   5DBE
6AA0:  MOVFF  01,6DE
6AA4:  CLRF   19
6AA6:  BTFSC  FF2.7
6AA8:  BSF    19.7
6AAA:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
6AAC:  MOVLB  8
6AAE:  CLRF   x53
6AB0:  CLRF   x52
6AB2:  CLRF   x51
6AB4:  MOVLW  3A
6AB6:  MOVWF  x50
6AB8:  MOVFF  6DE,854
6ABC:  MOVLB  0
6ABE:  CALL   3950
6AC2:  BTFSC  19.7
6AC4:  BSF    FF2.7
....................           set_tris_a(0xff); 
6AC6:  MOVLW  FF
6AC8:  MOVWF  F92
6ACA:  CLRF   19
6ACC:  BTFSC  FF2.7
6ACE:  BSF    19.7
6AD0:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6AD2:  MOVLW  0A
6AD4:  MOVLB  8
6AD6:  MOVWF  x52
6AD8:  MOVLB  0
6ADA:  CALL   15C0
6ADE:  BTFSC  19.7
6AE0:  BSF    FF2.7
6AE2:  CLRF   19
6AE4:  BTFSC  FF2.7
6AE6:  BSF    19.7
6AE8:  BCF    FF2.7
6AEA:  MOVLW  0D
6AEC:  MOVLB  8
6AEE:  MOVWF  x52
6AF0:  MOVLB  0
6AF2:  CALL   15C0
6AF6:  BTFSC  19.7
6AF8:  BSF    FF2.7
....................       } 
....................       
....................       strcpy(buffer2,"tran time"); 
6AFA:  CLRF   FEA
6AFC:  MOVLW  41
6AFE:  MOVWF  FE9
6B00:  MOVLW  00
6B02:  CALL   0432
6B06:  TBLRD*-
6B08:  TBLRD*+
6B0A:  MOVF   FF5,W
6B0C:  MOVWF  FEE
6B0E:  IORLW  00
6B10:  BNZ   6B08
....................       if(!stringcomp(buffer_uart,buffer2)) 
6B12:  MOVLW  01
6B14:  MOVLB  7
6B16:  MOVWF  xF2
6B18:  MOVLW  5E
6B1A:  MOVWF  xF1
6B1C:  CLRF   xF4
6B1E:  MOVLW  41
6B20:  MOVWF  xF3
6B22:  MOVLB  0
6B24:  CALL   58F8
6B28:  MOVF   01,F
6B2A:  BNZ   6BF2
....................       { 
....................           fprintf(COM2,"Input Number"); 
6B2C:  MOVLW  22
6B2E:  MOVWF  FF6
6B30:  MOVLW  1D
6B32:  MOVWF  FF7
6B34:  CLRF   19
6B36:  BTFSC  FF2.7
6B38:  BSF    19.7
6B3A:  BCF    FF2.7
6B3C:  CALL   16EA
6B40:  BTFSC  19.7
6B42:  BSF    FF2.7
6B44:  CLRF   19
6B46:  BTFSC  FF2.7
6B48:  BSF    19.7
6B4A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6B4C:  MOVLW  0A
6B4E:  MOVLB  8
6B50:  MOVWF  x52
6B52:  MOVLB  0
6B54:  CALL   15C0
6B58:  BTFSC  19.7
6B5A:  BSF    FF2.7
6B5C:  CLRF   19
6B5E:  BTFSC  FF2.7
6B60:  BSF    19.7
6B62:  BCF    FF2.7
6B64:  MOVLW  0D
6B66:  MOVLB  8
6B68:  MOVWF  x52
6B6A:  MOVLB  0
6B6C:  CALL   15C0
6B70:  BTFSC  19.7
6B72:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6B74:  MOVLW  01
6B76:  MOVLB  7
6B78:  MOVWF  xF1
6B7A:  MOVLW  03
6B7C:  MOVWF  xF2
6B7E:  MOVLW  07
6B80:  MOVWF  xF4
6B82:  MOVLW  BD
6B84:  MOVWF  xF3
6B86:  MOVLB  0
6B88:  CALL   57C0
....................           delaycharaction = (unsigned int8)strtoi(temp); 
6B8C:  MOVLW  07
6B8E:  MOVLB  7
6B90:  MOVWF  xF2
6B92:  MOVLW  BD
6B94:  MOVWF  xF1
6B96:  MOVLB  0
6B98:  CALL   5DBE
6B9C:  MOVFF  01,156
6BA0:  CLRF   19
6BA2:  BTFSC  FF2.7
6BA4:  BSF    19.7
6BA6:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
6BA8:  MOVLB  8
6BAA:  CLRF   x53
6BAC:  CLRF   x52
6BAE:  CLRF   x51
6BB0:  MOVLW  3C
6BB2:  MOVWF  x50
6BB4:  MOVFF  156,854
6BB8:  MOVLB  0
6BBA:  CALL   3950
6BBE:  BTFSC  19.7
6BC0:  BSF    FF2.7
6BC2:  CLRF   19
6BC4:  BTFSC  FF2.7
6BC6:  BSF    19.7
6BC8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6BCA:  MOVLW  0A
6BCC:  MOVLB  8
6BCE:  MOVWF  x52
6BD0:  MOVLB  0
6BD2:  CALL   15C0
6BD6:  BTFSC  19.7
6BD8:  BSF    FF2.7
6BDA:  CLRF   19
6BDC:  BTFSC  FF2.7
6BDE:  BSF    19.7
6BE0:  BCF    FF2.7
6BE2:  MOVLW  0D
6BE4:  MOVLB  8
6BE6:  MOVWF  x52
6BE8:  MOVLB  0
6BEA:  CALL   15C0
6BEE:  BTFSC  19.7
6BF0:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
6BF2:  CLRF   FEA
6BF4:  MOVLW  41
6BF6:  MOVWF  FE9
6BF8:  MOVLW  00
6BFA:  CALL   044C
6BFE:  TBLRD*-
6C00:  TBLRD*+
6C02:  MOVF   FF5,W
6C04:  MOVWF  FEE
6C06:  IORLW  00
6C08:  BNZ   6C00
....................       if(!stringcomp(buffer_uart,buffer2)) 
6C0A:  MOVLW  01
6C0C:  MOVLB  7
6C0E:  MOVWF  xF2
6C10:  MOVLW  5E
6C12:  MOVWF  xF1
6C14:  CLRF   xF4
6C16:  MOVLW  41
6C18:  MOVWF  xF3
6C1A:  MOVLB  0
6C1C:  CALL   58F8
6C20:  MOVF   01,F
6C22:  BTFSS  FD8.2
6C24:  BRA    6D34
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
6C26:  MOVLW  30
6C28:  MOVWF  FF6
6C2A:  MOVLW  1D
6C2C:  MOVWF  FF7
6C2E:  CLRF   19
6C30:  BTFSC  FF2.7
6C32:  BSF    19.7
6C34:  BCF    FF2.7
6C36:  CALL   16EA
6C3A:  BTFSC  19.7
6C3C:  BSF    FF2.7
6C3E:  CLRF   19
6C40:  BTFSC  FF2.7
6C42:  BSF    19.7
6C44:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6C46:  MOVLW  0A
6C48:  MOVLB  8
6C4A:  MOVWF  x52
6C4C:  MOVLB  0
6C4E:  CALL   15C0
6C52:  BTFSC  19.7
6C54:  BSF    FF2.7
6C56:  CLRF   19
6C58:  BTFSC  FF2.7
6C5A:  BSF    19.7
6C5C:  BCF    FF2.7
6C5E:  MOVLW  0D
6C60:  MOVLB  8
6C62:  MOVWF  x52
6C64:  MOVLB  0
6C66:  CALL   15C0
6C6A:  BTFSC  19.7
6C6C:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
6C6E:  MOVLW  56
6C70:  MOVWF  FF6
6C72:  MOVLW  1D
6C74:  MOVWF  FF7
6C76:  CLRF   19
6C78:  BTFSC  FF2.7
6C7A:  BSF    19.7
6C7C:  BCF    FF2.7
6C7E:  CALL   16EA
6C82:  BTFSC  19.7
6C84:  BSF    FF2.7
6C86:  CLRF   19
6C88:  BTFSC  FF2.7
6C8A:  BSF    19.7
6C8C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6C8E:  MOVLW  0A
6C90:  MOVLB  8
6C92:  MOVWF  x52
6C94:  MOVLB  0
6C96:  CALL   15C0
6C9A:  BTFSC  19.7
6C9C:  BSF    FF2.7
6C9E:  CLRF   19
6CA0:  BTFSC  FF2.7
6CA2:  BSF    19.7
6CA4:  BCF    FF2.7
6CA6:  MOVLW  0D
6CA8:  MOVLB  8
6CAA:  MOVWF  x52
6CAC:  MOVLB  0
6CAE:  CALL   15C0
6CB2:  BTFSC  19.7
6CB4:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6CB6:  MOVLW  01
6CB8:  MOVLB  7
6CBA:  MOVWF  xF1
6CBC:  MOVLW  03
6CBE:  MOVWF  xF2
6CC0:  MOVLW  07
6CC2:  MOVWF  xF4
6CC4:  MOVLW  BD
6CC6:  MOVWF  xF3
6CC8:  MOVLB  0
6CCA:  CALL   57C0
....................           type_KB=(unsigned int8)strtoi(temp); 
6CCE:  MOVLW  07
6CD0:  MOVLB  7
6CD2:  MOVWF  xF2
6CD4:  MOVLW  BD
6CD6:  MOVWF  xF1
6CD8:  MOVLB  0
6CDA:  CALL   5DBE
6CDE:  MOVFF  01,145
6CE2:  CLRF   19
6CE4:  BTFSC  FF2.7
6CE6:  BSF    19.7
6CE8:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
6CEA:  MOVLB  8
6CEC:  CLRF   x53
6CEE:  CLRF   x52
6CF0:  CLRF   x51
6CF2:  MOVLW  3D
6CF4:  MOVWF  x50
6CF6:  MOVFF  145,854
6CFA:  MOVLB  0
6CFC:  CALL   3950
6D00:  BTFSC  19.7
6D02:  BSF    FF2.7
6D04:  CLRF   19
6D06:  BTFSC  FF2.7
6D08:  BSF    19.7
6D0A:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
6D0C:  MOVLW  0A
6D0E:  MOVLB  8
6D10:  MOVWF  x52
6D12:  MOVLB  0
6D14:  CALL   15C0
6D18:  BTFSC  19.7
6D1A:  BSF    FF2.7
6D1C:  CLRF   19
6D1E:  BTFSC  FF2.7
6D20:  BSF    19.7
6D22:  BCF    FF2.7
6D24:  MOVLW  0D
6D26:  MOVLB  8
6D28:  MOVWF  x52
6D2A:  MOVLB  0
6D2C:  CALL   15C0
6D30:  BTFSC  19.7
6D32:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       strcpy(buffer2,"h"); 
6D34:  CLRF   FEA
6D36:  MOVLW  41
6D38:  MOVWF  FE9
6D3A:  MOVLW  00
6D3C:  CALL   0462
6D40:  TBLRD*-
6D42:  TBLRD*+
6D44:  MOVF   FF5,W
6D46:  MOVWF  FEE
6D48:  IORLW  00
6D4A:  BNZ   6D42
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
6D4C:  MOVLW  01
6D4E:  MOVLB  7
6D50:  MOVWF  xF2
6D52:  MOVLW  5E
6D54:  MOVWF  xF1
6D56:  CLRF   xF4
6D58:  MOVLW  41
6D5A:  MOVWF  xF3
6D5C:  MOVLB  0
6D5E:  CALL   58F8
6D62:  MOVF   01,F
6D64:  BTFSS  FD8.2
6D66:  BRA    6ED6
....................       { 
....................          printf("h-> Help\n\r"); 
6D68:  MOVLW  7C
6D6A:  MOVWF  FF6
6D6C:  MOVLW  1D
6D6E:  MOVWF  FF7
6D70:  CLRF   19
6D72:  BTFSC  FF2.7
6D74:  BSF    19.7
6D76:  BCF    FF2.7
6D78:  CALL   16EA
6D7C:  BTFSC  19.7
6D7E:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
6D80:  MOVLW  88
6D82:  MOVWF  FF6
6D84:  MOVLW  1D
6D86:  MOVWF  FF7
6D88:  CLRF   19
6D8A:  BTFSC  FF2.7
6D8C:  BSF    19.7
6D8E:  BCF    FF2.7
6D90:  CALL   16EA
6D94:  BTFSC  19.7
6D96:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
6D98:  MOVLW  9A
6D9A:  MOVWF  FF6
6D9C:  MOVLW  1D
6D9E:  MOVWF  FF7
6DA0:  CLRF   19
6DA2:  BTFSC  FF2.7
6DA4:  BSF    19.7
6DA6:  BCF    FF2.7
6DA8:  CALL   16EA
6DAC:  BTFSC  19.7
6DAE:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
6DB0:  MOVLW  AC
6DB2:  MOVWF  FF6
6DB4:  MOVLW  1D
6DB6:  MOVWF  FF7
6DB8:  CLRF   19
6DBA:  BTFSC  FF2.7
6DBC:  BSF    19.7
6DBE:  BCF    FF2.7
6DC0:  CALL   16EA
6DC4:  BTFSC  19.7
6DC6:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
6DC8:  MOVLW  CC
6DCA:  MOVWF  FF6
6DCC:  MOVLW  1D
6DCE:  MOVWF  FF7
6DD0:  CLRF   19
6DD2:  BTFSC  FF2.7
6DD4:  BSF    19.7
6DD6:  BCF    FF2.7
6DD8:  CALL   16EA
6DDC:  BTFSC  19.7
6DDE:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
6DE0:  MOVLW  E8
6DE2:  MOVWF  FF6
6DE4:  MOVLW  1D
6DE6:  MOVWF  FF7
6DE8:  CLRF   19
6DEA:  BTFSC  FF2.7
6DEC:  BSF    19.7
6DEE:  BCF    FF2.7
6DF0:  CALL   16EA
6DF4:  BTFSC  19.7
6DF6:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
6DF8:  MOVLW  F6
6DFA:  MOVWF  FF6
6DFC:  MOVLW  1D
6DFE:  MOVWF  FF7
6E00:  CLRF   19
6E02:  BTFSC  FF2.7
6E04:  BSF    19.7
6E06:  BCF    FF2.7
6E08:  CALL   16EA
6E0C:  BTFSC  19.7
6E0E:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
6E10:  MOVLW  02
6E12:  MOVWF  FF6
6E14:  MOVLW  1E
6E16:  MOVWF  FF7
6E18:  CLRF   19
6E1A:  BTFSC  FF2.7
6E1C:  BSF    19.7
6E1E:  BCF    FF2.7
6E20:  CALL   16EA
6E24:  BTFSC  19.7
6E26:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
6E28:  MOVLW  2A
6E2A:  MOVWF  FF6
6E2C:  MOVLW  1E
6E2E:  MOVWF  FF7
6E30:  CLRF   19
6E32:  BTFSC  FF2.7
6E34:  BSF    19.7
6E36:  BCF    FF2.7
6E38:  CALL   16EA
6E3C:  BTFSC  19.7
6E3E:  BSF    FF2.7
6E40:  CLRF   19
6E42:  BTFSC  FF2.7
6E44:  BSF    19.7
6E46:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
6E48:  MOVLB  8
6E4A:  CLRF   x46
6E4C:  CLRF   x45
6E4E:  CLRF   x44
6E50:  MOVLW  3D
6E52:  MOVWF  x43
6E54:  MOVLB  0
6E56:  CALL   3400
6E5A:  BTFSC  19.7
6E5C:  BSF    FF2.7
6E5E:  MOVFF  01,7F1
6E62:  MOVLW  46
6E64:  MOVWF  FF6
6E66:  MOVLW  1E
6E68:  MOVWF  FF7
6E6A:  CLRF   19
6E6C:  BTFSC  FF2.7
6E6E:  BSF    19.7
6E70:  BCF    FF2.7
6E72:  MOVLW  06
6E74:  MOVLB  8
6E76:  MOVWF  x46
6E78:  MOVLB  0
6E7A:  CALL   1606
6E7E:  BTFSC  19.7
6E80:  BSF    FF2.7
6E82:  CLRF   19
6E84:  BTFSC  FF2.7
6E86:  BSF    19.7
6E88:  BCF    FF2.7
6E8A:  MOVFF  7F1,832
6E8E:  MOVLW  18
6E90:  MOVLB  8
6E92:  MOVWF  x33
6E94:  MOVLB  0
6E96:  CALL   1736
6E9A:  BTFSC  19.7
6E9C:  BSF    FF2.7
6E9E:  MOVLW  4E
6EA0:  MOVWF  FF6
6EA2:  MOVLW  1E
6EA4:  MOVWF  FF7
6EA6:  CLRF   19
6EA8:  BTFSC  FF2.7
6EAA:  BSF    19.7
6EAC:  BCF    FF2.7
6EAE:  MOVLW  1D
6EB0:  MOVLB  8
6EB2:  MOVWF  x46
6EB4:  MOVLB  0
6EB6:  CALL   1606
6EBA:  BTFSC  19.7
6EBC:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
6EBE:  MOVLW  6C
6EC0:  MOVWF  FF6
6EC2:  MOVLW  1E
6EC4:  MOVWF  FF7
6EC6:  CLRF   19
6EC8:  BTFSC  FF2.7
6ECA:  BSF    19.7
6ECC:  BCF    FF2.7
6ECE:  CALL   16EA
6ED2:  BTFSC  19.7
6ED4:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................       } 
....................       strcpy(buffer2,"password"); 
6ED6:  CLRF   FEA
6ED8:  MOVLW  41
6EDA:  MOVWF  FE9
6EDC:  MOVLW  00
6EDE:  CALL   0474
6EE2:  TBLRD*-
6EE4:  TBLRD*+
6EE6:  MOVF   FF5,W
6EE8:  MOVWF  FEE
6EEA:  IORLW  00
6EEC:  BNZ   6EE4
....................       if(!stringcomp(buffer_uart,buffer2))  
6EEE:  MOVLW  01
6EF0:  MOVLB  7
6EF2:  MOVWF  xF2
6EF4:  MOVLW  5E
6EF6:  MOVWF  xF1
6EF8:  CLRF   xF4
6EFA:  MOVLW  41
6EFC:  MOVWF  xF3
6EFE:  MOVLB  0
6F00:  CALL   58F8
6F04:  MOVF   01,F
6F06:  BTFSS  FD8.2
6F08:  BRA    705C
....................       { 
....................          fprintf(COM2,"old password:"); 
6F0A:  MOVLW  86
6F0C:  MOVWF  FF6
6F0E:  MOVLW  1E
6F10:  MOVWF  FF7
6F12:  CLRF   19
6F14:  BTFSC  FF2.7
6F16:  BSF    19.7
6F18:  BCF    FF2.7
6F1A:  CALL   16EA
6F1E:  BTFSC  19.7
6F20:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
6F22:  MOVLB  7
6F24:  CLRF   xF4
6F26:  CLRF   xF3
6F28:  CLRF   xF2
6F2A:  CLRF   xF1
6F2C:  CLRF   xF8
6F2E:  CLRF   xF7
6F30:  CLRF   xF6
6F32:  MOVLW  14
6F34:  MOVWF  xF5
6F36:  CLRF   xFA
6F38:  MOVLW  55
6F3A:  MOVWF  xF9
6F3C:  MOVLB  0
6F3E:  CALL   549A
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
6F42:  MOVLW  02
6F44:  MOVLB  7
6F46:  MOVWF  xF1
6F48:  MOVLW  14
6F4A:  MOVWF  xF2
6F4C:  CLRF   xF4
6F4E:  MOVLW  69
6F50:  MOVWF  xF3
6F52:  MOVLB  0
6F54:  CALL   57C0
....................          if(!stringcomp(entpassword,password)) 
6F58:  MOVLB  7
6F5A:  CLRF   xF2
6F5C:  MOVLW  69
6F5E:  MOVWF  xF1
6F60:  CLRF   xF4
6F62:  MOVLW  55
6F64:  MOVWF  xF3
6F66:  MOVLB  0
6F68:  CALL   58F8
6F6C:  MOVF   01,F
6F6E:  BNZ   7044
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
6F70:  MOVLW  94
6F72:  MOVWF  FF6
6F74:  MOVLW  1E
6F76:  MOVWF  FF7
6F78:  CLRF   19
6F7A:  BTFSC  FF2.7
6F7C:  BSF    19.7
6F7E:  BCF    FF2.7
6F80:  CALL   16EA
6F84:  BTFSC  19.7
6F86:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
6F88:  MOVLW  02
6F8A:  MOVLB  7
6F8C:  MOVWF  xF1
6F8E:  MOVLW  14
6F90:  MOVWF  xF2
6F92:  CLRF   xF4
6F94:  MOVLW  69
6F96:  MOVWF  xF3
6F98:  MOVLB  0
6F9A:  CALL   57C0
....................             fprintf(COM2,"\n\ragain:"); 
6F9E:  MOVLW  9C
6FA0:  MOVWF  FF6
6FA2:  MOVLW  1E
6FA4:  MOVWF  FF7
6FA6:  CLRF   19
6FA8:  BTFSC  FF2.7
6FAA:  BSF    19.7
6FAC:  BCF    FF2.7
6FAE:  CALL   16EA
6FB2:  BTFSC  19.7
6FB4:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
6FB6:  MOVLW  02
6FB8:  MOVLB  7
6FBA:  MOVWF  xF1
6FBC:  MOVLW  14
6FBE:  MOVWF  xF2
6FC0:  CLRF   xF4
6FC2:  MOVLW  55
6FC4:  MOVWF  xF3
6FC6:  MOVLB  0
6FC8:  CALL   57C0
....................             if(!stringcomp(entpassword,password)) 
6FCC:  MOVLB  7
6FCE:  CLRF   xF2
6FD0:  MOVLW  69
6FD2:  MOVWF  xF1
6FD4:  CLRF   xF4
6FD6:  MOVLW  55
6FD8:  MOVWF  xF3
6FDA:  MOVLB  0
6FDC:  CALL   58F8
6FE0:  MOVF   01,F
6FE2:  BNZ   702A
6FE4:  CLRF   19
6FE6:  BTFSC  FF2.7
6FE8:  BSF    19.7
6FEA:  BCF    FF2.7
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
6FEC:  MOVLB  8
6FEE:  CLRF   x40
6FF0:  CLRF   x3F
6FF2:  CLRF   x3E
6FF4:  CLRF   x3D
6FF6:  CLRF   x44
6FF8:  CLRF   x43
6FFA:  CLRF   x42
6FFC:  MOVLW  14
6FFE:  MOVWF  x41
7000:  CLRF   x46
7002:  MOVLW  55
7004:  MOVWF  x45
7006:  MOVLB  0
7008:  CALL   4DBE
700C:  BTFSC  19.7
700E:  BSF    FF2.7
....................                fprintf(COM2,"\n\rOK\n\r");    
7010:  MOVLW  A6
7012:  MOVWF  FF6
7014:  MOVLW  1E
7016:  MOVWF  FF7
7018:  CLRF   19
701A:  BTFSC  FF2.7
701C:  BSF    19.7
701E:  BCF    FF2.7
7020:  CALL   16EA
7024:  BTFSC  19.7
7026:  BSF    FF2.7
....................             } 
....................                else 
7028:  BRA    7042
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
702A:  MOVLW  AE
702C:  MOVWF  FF6
702E:  MOVLW  1E
7030:  MOVWF  FF7
7032:  CLRF   19
7034:  BTFSC  FF2.7
7036:  BSF    19.7
7038:  BCF    FF2.7
703A:  CALL   16EA
703E:  BTFSC  19.7
7040:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
7042:  BRA    705C
....................             { 
....................                fprintf(COM2," X\n\r"); 
7044:  MOVLW  B6
7046:  MOVWF  FF6
7048:  MOVLW  1E
704A:  MOVWF  FF7
704C:  CLRF   19
704E:  BTFSC  FF2.7
7050:  BSF    19.7
7052:  BCF    FF2.7
7054:  CALL   16EA
7058:  BTFSC  19.7
705A:  BSF    FF2.7
....................             }    
....................       } 
....................         strcpy(buffer2,"crypto"); 
705C:  CLRF   FEA
705E:  MOVLW  41
7060:  MOVWF  FE9
7062:  MOVLW  00
7064:  CALL   048E
7068:  TBLRD*-
706A:  TBLRD*+
706C:  MOVF   FF5,W
706E:  MOVWF  FEE
7070:  IORLW  00
7072:  BNZ   706A
....................         if(!stringcomp(buffer_uart,buffer2))  
7074:  MOVLW  01
7076:  MOVLB  7
7078:  MOVWF  xF2
707A:  MOVLW  5E
707C:  MOVWF  xF1
707E:  CLRF   xF4
7080:  MOVLW  41
7082:  MOVWF  xF3
7084:  MOVLB  0
7086:  CALL   58F8
708A:  MOVF   01,F
708C:  BTFSS  FD8.2
708E:  BRA    720E
....................         { 
....................             memset(crypto_key,0,sizeof(crypto_key)); 
7090:  CLRF   FEA
7092:  MOVLW  FD
7094:  MOVWF  FE9
7096:  CLRF   00
7098:  CLRF   02
709A:  MOVLW  21
709C:  MOVWF  01
709E:  CALL   3A4E
....................             fprintf(COM2,"New crypto key>"); 
70A2:  MOVLW  BC
70A4:  MOVWF  FF6
70A6:  MOVLW  1E
70A8:  MOVWF  FF7
70AA:  CLRF   19
70AC:  BTFSC  FF2.7
70AE:  BSF    19.7
70B0:  BCF    FF2.7
70B2:  CALL   16EA
70B6:  BTFSC  19.7
70B8:  BSF    FF2.7
....................             countchar = (int16)USART_getstring(EN_ECHO, CRYPTO_KEY_SIZE, crypto_key); 
70BA:  MOVLW  01
70BC:  MOVLB  7
70BE:  MOVWF  xF1
70C0:  MOVLW  20
70C2:  MOVWF  xF2
70C4:  CLRF   xF4
70C6:  MOVLW  FD
70C8:  MOVWF  xF3
70CA:  MOVLB  0
70CC:  CALL   57C0
70D0:  MOVLB  7
70D2:  CLRF   xBC
70D4:  MOVFF  01,7BB
70D8:  CLRF   19
70DA:  BTFSC  FF2.7
70DC:  BSF    19.7
70DE:  BCF    FF2.7
....................             EEPROM_write(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key); 
70E0:  MOVLB  8
70E2:  CLRF   x40
70E4:  CLRF   x3F
70E6:  CLRF   x3E
70E8:  MOVLW  3F
70EA:  MOVWF  x3D
70EC:  CLRF   x44
70EE:  CLRF   x43
70F0:  CLRF   x42
70F2:  MOVLW  20
70F4:  MOVWF  x41
70F6:  CLRF   x46
70F8:  MOVLW  FD
70FA:  MOVWF  x45
70FC:  MOVLB  0
70FE:  CALL   4DBE
7102:  BTFSC  19.7
7104:  BSF    FF2.7
....................              
....................             if(countchar>2) 
7106:  MOVLB  7
7108:  MOVF   xBC,F
710A:  BNZ   7112
710C:  MOVF   xBB,W
710E:  SUBLW  02
7110:  BC    71D0
....................             { 
....................                 cryption_enable = 1; 
7112:  MOVLW  01
7114:  MOVLB  1
7116:  MOVWF  x1E
7118:  CLRF   19
711A:  BTFSC  FF2.7
711C:  BSF    19.7
711E:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable);                    
7120:  MOVLB  8
7122:  CLRF   x53
7124:  CLRF   x52
7126:  CLRF   x51
7128:  MOVLW  3E
712A:  MOVWF  x50
712C:  MOVFF  11E,854
7130:  MOVLB  0
7132:  CALL   3950
7136:  BTFSC  19.7
7138:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rNew crypto key: "); 
713A:  MOVLW  CC
713C:  MOVWF  FF6
713E:  MOVLW  1E
7140:  MOVWF  FF7
7142:  CLRF   19
7144:  BTFSC  FF2.7
7146:  BSF    19.7
7148:  BCF    FF2.7
714A:  CALL   16EA
714E:  BTFSC  19.7
7150:  BSF    FF2.7
....................                 for(i=0;i<CRYPTO_KEY_SIZE;i++) 
7152:  MOVLB  7
7154:  CLRF   xBA
7156:  MOVF   xBA,W
7158:  SUBLW  1F
715A:  BNC   719C
....................                 { 
....................                     fprintf(COM2,"%c",read_ext_eeprom(strobe_crypto_key+i)); 
715C:  MOVLW  3F
715E:  ADDWF  xBA,W
7160:  MOVWF  xF1
7162:  CLRF   19
7164:  BTFSC  FF2.7
7166:  BSF    19.7
7168:  BCF    FF2.7
716A:  MOVLB  8
716C:  CLRF   x46
716E:  CLRF   x45
7170:  CLRF   x44
7172:  MOVWF  x43
7174:  MOVLB  0
7176:  CALL   3400
717A:  BTFSC  19.7
717C:  BSF    FF2.7
717E:  MOVFF  01,7F1
7182:  CLRF   19
7184:  BTFSC  FF2.7
7186:  BSF    19.7
7188:  BCF    FF2.7
718A:  MOVFF  01,852
718E:  CALL   15C0
7192:  BTFSC  19.7
7194:  BSF    FF2.7
....................                 } 
7196:  MOVLB  7
7198:  INCF   xBA,F
719A:  BRA    7156
719C:  CLRF   19
719E:  BTFSC  FF2.7
71A0:  BSF    19.7
71A2:  BCF    FF2.7
....................                 fprintf(COM2,"\n\r"); 
71A4:  MOVLW  0A
71A6:  MOVLB  8
71A8:  MOVWF  x52
71AA:  MOVLB  0
71AC:  CALL   15C0
71B0:  BTFSC  19.7
71B2:  BSF    FF2.7
71B4:  CLRF   19
71B6:  BTFSC  FF2.7
71B8:  BSF    19.7
71BA:  BCF    FF2.7
71BC:  MOVLW  0D
71BE:  MOVLB  8
71C0:  MOVWF  x52
71C2:  MOVLB  0
71C4:  CALL   15C0
71C8:  BTFSC  19.7
71CA:  BSF    FF2.7
....................             } 
....................             else 
71CC:  BRA    720E
71CE:  MOVLB  7
....................             { 
....................                 cryption_enable = 0; 
71D0:  MOVLB  1
71D2:  CLRF   x1E
71D4:  CLRF   19
71D6:  BTFSC  FF2.7
71D8:  BSF    19.7
71DA:  BCF    FF2.7
....................                 write_ext_eeprom(crypto_en,cryption_enable); 
71DC:  MOVLB  8
71DE:  CLRF   x53
71E0:  CLRF   x52
71E2:  CLRF   x51
71E4:  MOVLW  3E
71E6:  MOVWF  x50
71E8:  MOVFF  11E,854
71EC:  MOVLB  0
71EE:  CALL   3950
71F2:  BTFSC  19.7
71F4:  BSF    FF2.7
....................                 fprintf(COM2,"\n\rcrypto is disable\n\r"); 
71F6:  MOVLW  E0
71F8:  MOVWF  FF6
71FA:  MOVLW  1E
71FC:  MOVWF  FF7
71FE:  CLRF   19
7200:  BTFSC  FF2.7
7202:  BSF    19.7
7204:  BCF    FF2.7
7206:  CALL   16EA
720A:  BTFSC  19.7
720C:  BSF    FF2.7
....................             } 
....................         } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
720E:  CLRF   FEA
7210:  MOVLW  41
7212:  MOVWF  FE9
7214:  MOVLW  00
7216:  CALL   04A6
721A:  TBLRD*-
721C:  TBLRD*+
721E:  MOVF   FF5,W
7220:  MOVWF  FEE
7222:  IORLW  00
7224:  BNZ   721C
....................       if(!stringcomp(buffer_uart,buffer2)) 
7226:  MOVLW  01
7228:  MOVLB  7
722A:  MOVWF  xF2
722C:  MOVLW  5E
722E:  MOVWF  xF1
7230:  CLRF   xF4
7232:  MOVLW  41
7234:  MOVWF  xF3
7236:  MOVLB  0
7238:  CALL   58F8
723C:  MOVF   01,F
723E:  BTFSS  FD8.2
7240:  BRA    7350
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
7242:  MOVLW  F6
7244:  MOVWF  FF6
7246:  MOVLW  1E
7248:  MOVWF  FF7
724A:  CLRF   19
724C:  BTFSC  FF2.7
724E:  BSF    19.7
7250:  BCF    FF2.7
7252:  CALL   16EA
7256:  BTFSC  19.7
7258:  BSF    FF2.7
725A:  CLRF   19
725C:  BTFSC  FF2.7
725E:  BSF    19.7
7260:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7262:  MOVLW  0A
7264:  MOVLB  8
7266:  MOVWF  x52
7268:  MOVLB  0
726A:  CALL   15C0
726E:  BTFSC  19.7
7270:  BSF    FF2.7
7272:  CLRF   19
7274:  BTFSC  FF2.7
7276:  BSF    19.7
7278:  BCF    FF2.7
727A:  MOVLW  0D
727C:  MOVLB  8
727E:  MOVWF  x52
7280:  MOVLB  0
7282:  CALL   15C0
7286:  BTFSC  19.7
7288:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
728A:  MOVLW  16
728C:  MOVWF  FF6
728E:  MOVLW  1F
7290:  MOVWF  FF7
7292:  CLRF   19
7294:  BTFSC  FF2.7
7296:  BSF    19.7
7298:  BCF    FF2.7
729A:  CALL   16EA
729E:  BTFSC  19.7
72A0:  BSF    FF2.7
72A2:  CLRF   19
72A4:  BTFSC  FF2.7
72A6:  BSF    19.7
72A8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
72AA:  MOVLW  0A
72AC:  MOVLB  8
72AE:  MOVWF  x52
72B0:  MOVLB  0
72B2:  CALL   15C0
72B6:  BTFSC  19.7
72B8:  BSF    FF2.7
72BA:  CLRF   19
72BC:  BTFSC  FF2.7
72BE:  BSF    19.7
72C0:  BCF    FF2.7
72C2:  MOVLW  0D
72C4:  MOVLB  8
72C6:  MOVWF  x52
72C8:  MOVLB  0
72CA:  CALL   15C0
72CE:  BTFSC  19.7
72D0:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
72D2:  MOVLW  01
72D4:  MOVLB  7
72D6:  MOVWF  xF1
72D8:  MOVLW  03
72DA:  MOVWF  xF2
72DC:  MOVLW  07
72DE:  MOVWF  xF4
72E0:  MOVLW  BD
72E2:  MOVWF  xF3
72E4:  MOVLB  0
72E6:  CALL   57C0
....................           debugmode = (unsigned int8)strtoi(temp); 
72EA:  MOVLW  07
72EC:  MOVLB  7
72EE:  MOVWF  xF2
72F0:  MOVLW  BD
72F2:  MOVWF  xF1
72F4:  MOVLB  0
72F6:  CALL   5DBE
72FA:  MOVFF  01,6D2
72FE:  CLRF   19
7300:  BTFSC  FF2.7
7302:  BSF    19.7
7304:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
7306:  MOVLB  8
7308:  CLRF   x53
730A:  CLRF   x52
730C:  CLRF   x51
730E:  MOVLW  3B
7310:  MOVWF  x50
7312:  MOVFF  6D2,854
7316:  MOVLB  0
7318:  CALL   3950
731C:  BTFSC  19.7
731E:  BSF    FF2.7
7320:  CLRF   19
7322:  BTFSC  FF2.7
7324:  BSF    19.7
7326:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7328:  MOVLW  0A
732A:  MOVLB  8
732C:  MOVWF  x52
732E:  MOVLB  0
7330:  CALL   15C0
7334:  BTFSC  19.7
7336:  BSF    FF2.7
7338:  CLRF   19
733A:  BTFSC  FF2.7
733C:  BSF    19.7
733E:  BCF    FF2.7
7340:  MOVLW  0D
7342:  MOVLB  8
7344:  MOVWF  x52
7346:  MOVLB  0
7348:  CALL   15C0
734C:  BTFSC  19.7
734E:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
7350:  GOTO   790E (RETURN)
.................... //=============================================== 
....................  
....................  
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    if(keydebug_en==1) 
*
51B8:  MOVLB  1
51BA:  DECFSZ x40,W
51BC:  BRA    51D8
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
51BE:  MOVLB  6
51C0:  MOVF   xDE,F
51C2:  BNZ   51CC
51C4:  MOVLB  0
51C6:  CALL   1F36
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
51CA:  BRA    51D6
51CC:  MOVLB  0
51CE:  CALL   3190
51D2:  MOVFF  01,828
51D6:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
51D8:  DECFSZ x41,W
51DA:  BRA    51F4
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
51DC:  MOVLB  6
51DE:  MOVF   xDE,F
51E0:  BNZ   51EA
51E2:  MOVLB  0
51E4:  CALL   1F36
....................          else temp=kbd_getc_slv(); 
51E8:  BRA    51F4
51EA:  MOVLB  0
51EC:  CALL   3190
51F0:  MOVFF  01,828
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
51F4:  MOVLB  6
51F6:  MOVF   xC3,F
51F8:  BNZ   5218
51FA:  MOVF   xC2,F
51FC:  BNZ   5218
51FE:  MOVF   xC1,F
5200:  BNZ   5218
5202:  MOVF   xC0,W
5204:  SUBLW  04
5206:  BNC   5218
5208:  MOVLW  01
520A:  ADDWF  xC0,F
520C:  BTFSC  FD8.0
520E:  INCF   xC1,F
5210:  BTFSC  FD8.2
5212:  INCF   xC2,F
5214:  BTFSC  FD8.2
5216:  INCF   xC3,F
....................   if(mcr_timeout==5) 
5218:  MOVF   xC0,W
521A:  SUBLW  05
521C:  BNZ   5278
521E:  MOVF   xC1,F
5220:  BNZ   5278
5222:  MOVF   xC2,F
5224:  BNZ   5278
5226:  MOVF   xC3,F
5228:  BNZ   5278
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
522A:  DECFSZ xD6,W
522C:  BRA    5236
522E:  MOVLB  0
5230:  GOTO   3AF6
5234:  MOVLB  6
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
5236:  MOVLW  02
5238:  MOVWF  FEA
523A:  MOVLW  42
523C:  MOVWF  FE9
523E:  CLRF   00
5240:  MOVLW  03
5242:  MOVWF  02
5244:  MOVLW  52
5246:  MOVWF  01
5248:  MOVLB  0
524A:  CALL   3A4E
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
524E:  MOVLW  05
5250:  MOVWF  FEA
5252:  MOVLW  94
5254:  MOVWF  FE9
5256:  CLRF   00
5258:  MOVLW  01
525A:  MOVWF  02
525C:  MOVLW  2C
525E:  MOVWF  01
5260:  CALL   3A4E
....................       //debug_card(); 
....................       count_reading_error=0; 
5264:  MOVLB  6
5266:  CLRF   xD7
....................       mcr_timeout++;   
5268:  MOVLW  01
526A:  ADDWF  xC0,F
526C:  BTFSC  FD8.0
526E:  INCF   xC1,F
5270:  BTFSC  FD8.2
5272:  INCF   xC2,F
5274:  BTFSC  FD8.2
5276:  INCF   xC3,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
5278:  MOVLB  8
527A:  CLRF   x46
527C:  CLRF   x45
527E:  CLRF   x44
5280:  MOVLW  3C
5282:  MOVWF  x43
5284:  MOVLB  0
5286:  CALL   3400
528A:  MOVFF  01,156
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
528E:  MOVLW  02
5290:  MOVLB  8
5292:  MOVWF  x2F
5294:  MOVLW  BC
5296:  MOVWF  x2E
5298:  CLRF   x31
529A:  MOVFF  156,830
529E:  MOVLB  0
52A0:  CALL   3524
52A4:  MOVFF  02,03
52A8:  MOVF   xFC,W
52AA:  SUBWF  02,W
52AC:  BNC   52BC
52AE:  BNZ   52B6
52B0:  MOVF   01,W
52B2:  SUBWF  xFB,W
52B4:  BC    52BC
52B6:  INCF   xFB,F
52B8:  BTFSC  FD8.2
52BA:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
52BC:  MOVLW  02
52BE:  MOVLB  8
52C0:  MOVWF  x2F
52C2:  MOVLW  BC
52C4:  MOVWF  x2E
52C6:  CLRF   x31
52C8:  MOVFF  156,830
52CC:  MOVLB  0
52CE:  CALL   3524
52D2:  MOVFF  02,03
52D6:  MOVF   01,W
52D8:  SUBWF  xFB,W
52DA:  BNZ   5392
52DC:  MOVF   03,W
52DE:  SUBWF  xFC,W
52E0:  BNZ   5392
....................   { 
....................       charac_timeout++; 
52E2:  INCF   xFB,F
52E4:  BTFSC  FD8.2
52E6:  INCF   xFC,F
....................       buf=get_countcard(); 
52E8:  CALL   34CC
52EC:  MOVFF  02,827
52F0:  MOVFF  01,826
....................       if(buf<countcards) 
52F4:  MOVLB  8
52F6:  MOVF   x27,W
52F8:  SUBLW  03
52FA:  BNC   5332
52FC:  BNZ   5304
52FE:  MOVF   x26,W
5300:  SUBLW  A1
5302:  BNC   5332
....................       { 
....................          if(cryption_enable==0)  
5304:  MOVLB  1
5306:  MOVF   x1E,F
5308:  BNZ   5314
....................          { 
....................             save_key_new(); 
530A:  MOVLB  0
530C:  GOTO   3EE6
....................          } 
....................          else 
5310:  BRA    5318
5312:  MOVLB  1
....................          { 
....................             save_key_encrypt(); 
5314:  MOVLB  0
5316:  BRA    4E4E
....................          } 
....................          buf=buf+1; 
5318:  MOVLW  01
531A:  MOVLB  8
531C:  ADDWF  x26,F
531E:  MOVLW  00
5320:  ADDWFC x27,F
....................          save_coutcard(buf); 
5322:  MOVFF  827,82A
5326:  MOVFF  826,829
532A:  MOVLB  0
532C:  RCALL  507C
....................       } 
....................          else 
532E:  BRA    5342
5330:  MOVLB  8
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
5332:  MOVLW  98
5334:  MOVWF  FF6
5336:  MOVLW  53
5338:  MOVWF  FF7
533A:  MOVLB  0
533C:  CALL   16EA
....................             return; 
5340:  BRA    5392
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
5342:  MOVLW  A8
5344:  MOVWF  FF6
5346:  MOVLW  53
5348:  MOVWF  FF7
534A:  CALL   16EA
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
534E:  MOVLW  B8
5350:  MOVWF  FF6
5352:  MOVLW  53
5354:  MOVWF  FF7
5356:  MOVLW  14
5358:  MOVLB  8
535A:  MOVWF  x46
535C:  MOVLB  0
535E:  CALL   1606
5362:  MOVLW  10
5364:  MOVWF  FE9
5366:  MOVFF  827,82A
536A:  MOVFF  826,829
536E:  RCALL  50C2
5370:  MOVLW  CF
5372:  MOVWF  FF6
5374:  MOVLW  53
5376:  MOVWF  FF7
5378:  MOVLW  03
537A:  MOVLB  8
537C:  MOVWF  x46
537E:  MOVLB  0
5380:  CALL   1606
....................       data_avai=0; 
5384:  MOVLB  6
5386:  CLRF   xD5
....................       enable_getpin=0; 
5388:  MOVLB  1
538A:  CLRF   x41
....................       //dis_getpin; 
....................       output_low(LED); 
538C:  BCF    F92.6
538E:  BCF    F89.6
5390:  MOVLB  0
....................   } 
.................... } 
.................... //========================= 
5392:  BCF    FF2.2
5394:  GOTO   006C
.................... void main() 
.................... {  
*
7354:  CLRF   FF8
7356:  BCF    FD0.7
7358:  BSF    07.7
735A:  CLRF   FEA
735C:  CLRF   FE9
735E:  BCF    F94.0
7360:  BSF    F8B.0
7362:  CLRF   23
7364:  CLRF   22
7366:  CLRF   21
7368:  MOVLW  96
736A:  MOVWF  20
736C:  CLRF   27
736E:  MOVLW  01
7370:  MOVWF  26
7372:  MOVLW  C3
7374:  MOVWF  25
7376:  MOVLW  0F
7378:  MOVWF  24
737A:  CLRF   xFA
737C:  CLRF   xF9
737E:  SETF   xFC
7380:  SETF   xFB
7382:  MOVLB  1
7384:  CLRF   x1E
7386:  CLRF   x3F
7388:  CLRF   x40
738A:  CLRF   x41
738C:  MOVLW  64
738E:  MOVWF  x42
7390:  CLRF   x43
7392:  CLRF   x44
7394:  CLRF   x45
7396:  CLRF   x56
7398:  CLRF   x5B
739A:  CLRF   xC2
739C:  CLRF   xC3
739E:  MOVLW  0E
73A0:  MOVWF  xC5
73A2:  MOVLW  01
73A4:  MOVWF  xC6
73A6:  MOVWF  xC7
73A8:  CLRF   xC8
73AA:  CLRF   xC9
73AC:  CLRF   xCA
73AE:  MOVLB  6
73B0:  CLRF   xC3
73B2:  CLRF   xC2
73B4:  CLRF   xC1
73B6:  CLRF   xC0
73B8:  CLRF   xC4
73BA:  CLRF   xC6
73BC:  CLRF   xC5
73BE:  CLRF   xC8
73C0:  CLRF   xC7
73C2:  CLRF   xCA
73C4:  CLRF   xC9
73C6:  CLRF   xCC
73C8:  CLRF   xCB
73CA:  MOVLW  FD
73CC:  MOVWF  xCE
73CE:  MOVLW  E8
73D0:  MOVWF  xCD
73D2:  CLRF   xD0
73D4:  CLRF   xCF
73D6:  CLRF   xD1
73D8:  CLRF   xD2
73DA:  CLRF   xD3
73DC:  CLRF   xD4
73DE:  CLRF   xD5
73E0:  CLRF   xD6
73E2:  CLRF   xD7
73E4:  CLRF   xD8
73E6:  CLRF   xD9
73E8:  CLRF   xDB
73EA:  MOVLW  01
73EC:  MOVWF  xDA
73EE:  CLRF   xDD
73F0:  CLRF   xDC
73F2:  CLRF   xDE
73F4:  CLRF   xE2
73F6:  CLRF   xE1
73F8:  CLRF   xE0
73FA:  CLRF   xDF
73FC:  MOVLW  FF
73FE:  MOVLB  F
7400:  MOVWF  x48
7402:  BCF    FC2.6
7404:  BCF    FC2.7
7406:  MOVF   x49,W
7408:  ANDLW  E0
740A:  IORLW  1F
740C:  MOVWF  x49
740E:  CLRF   FD2
7410:  CLRF   FD1
7412:  CLRF   1A
7414:  CLRF   1B
7416:  MOVLW  E8
7418:  MOVLB  1
741A:  MOVWF  x1F
741C:  MOVLW  E9
741E:  MOVWF  x20
7420:  MOVLW  EA
7422:  MOVWF  x21
7424:  MOVLW  EB
7426:  MOVWF  x22
7428:  MOVLW  ED
742A:  MOVWF  x23
742C:  MOVLW  EE
742E:  MOVWF  x24
7430:  MOVLW  EF
7432:  MOVWF  x25
7434:  MOVLW  F0
7436:  MOVWF  x26
7438:  MOVLW  F2
743A:  MOVWF  x27
743C:  MOVLW  F3
743E:  MOVWF  x28
7440:  MOVLW  F4
7442:  MOVWF  x29
7444:  MOVLW  F5
7446:  MOVWF  x2A
7448:  MOVLW  F7
744A:  MOVWF  x2B
744C:  MOVLW  F8
744E:  MOVWF  x2C
7450:  MOVLW  F9
7452:  MOVWF  x2D
7454:  MOVLW  FA
7456:  MOVWF  x2E
7458:  MOVLW  67
745A:  MOVWF  x2F
745C:  MOVLW  43
745E:  MOVWF  x30
7460:  MOVLW  C3
7462:  MOVWF  x31
7464:  MOVLW  D1
7466:  MOVWF  x32
7468:  MOVLW  51
746A:  MOVWF  x33
746C:  MOVLW  9A
746E:  MOVWF  x34
7470:  MOVLW  B4
7472:  MOVWF  x35
7474:  MOVLW  F2
7476:  MOVWF  x36
7478:  MOVLW  CD
747A:  MOVWF  x37
747C:  MOVLW  9A
747E:  MOVWF  x38
7480:  MOVLW  78
7482:  MOVWF  x39
7484:  MOVLW  AB
7486:  MOVWF  x3A
7488:  MOVLW  09
748A:  MOVWF  x3B
748C:  MOVLW  A5
748E:  MOVWF  x3C
7490:  MOVLW  11
7492:  MOVWF  x3D
7494:  MOVLW  BD
7496:  MOVWF  x3E
7498:  CLRF   x57
749A:  BCF    x58.0
749C:  CLRF   x59
749E:  CLRF   x5A
74A0:  CLRF   x5C
74A2:  BCF    x58.1
74A4:  CLRF   x5D
74A6:  MOVLB  6
74A8:  CLRF   xF3
74AA:  CLRF   xF4
74AC:  CLRF   xF5
74AE:  CLRF   xF6
74B0:  CLRF   xF7
74B2:  CLRF   xF8
74B4:  CLRF   xF9
74B6:  CLRF   xFA
74B8:  CLRF   xFB
74BA:  CLRF   xFC
74BC:  CLRF   xFF
74BE:  MOVLB  7
74C0:  CLRF   x01
74C2:  CLRF   x00
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    RPINR1=5; 
74C4:  MOVLW  05
74C6:  MOVLB  E
74C8:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
74CA:  MOVLB  0
74CC:  SETF   xFC
74CE:  SETF   xFB
....................    setup_oscillator(OSC_32MHZ); 
74D0:  MOVLW  70
74D2:  MOVWF  FD3
74D4:  MOVLW  40
74D6:  MOVWF  F9B
74D8:  MOVF   FD3,W
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
74DA:  BCF    FF2.6
74DC:  BCF    FF2.7
74DE:  BTFSC  FF2.7
74E0:  BRA    74DC
....................    init_ext_eeprom(); 
74E2:  GOTO   5490
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif   
....................    //===================================== 
....................    delay_ms(1000); 
74E6:  MOVLW  04
74E8:  MOVLB  7
74EA:  MOVWF  xB9
74EC:  CLRF   19
74EE:  BTFSC  FF2.7
74F0:  BSF    19.7
74F2:  BCF    FF2.7
74F4:  MOVLW  FA
74F6:  MOVLB  8
74F8:  MOVWF  x2F
74FA:  MOVLB  0
74FC:  CALL   1882
7500:  BTFSC  19.7
7502:  BSF    FF2.7
7504:  MOVLB  7
7506:  DECFSZ xB9,F
7508:  BRA    74EC
....................    init_password(); 
750A:  MOVLB  0
750C:  CALL   554A
....................    //===================================== 
....................     
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
7510:  MOVLW  19
7512:  MOVLB  7
7514:  MOVWF  xB9
7516:  MOVLB  0
7518:  CALL   55EA
751C:  MOVFF  03,23
7520:  MOVFF  02,22
7524:  MOVFF  01,21
7528:  MOVFF  00,20
....................    printf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
752C:  CLRF   FEA
752E:  MOVLW  01
7530:  MOVWF  FE9
7532:  CALL   5740
....................     
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
7536:  MOVLW  1E
7538:  MOVLB  7
753A:  MOVWF  xB9
753C:  MOVLB  0
753E:  CALL   55EA
7542:  MOVFF  03,27
7546:  MOVFF  02,26
754A:  MOVFF  01,25
754E:  MOVFF  00,24
....................    fprintf(COM2,"booting\n\r"); 
7552:  MOVLW  D4
7554:  MOVWF  FF6
7556:  MOVLW  53
7558:  MOVWF  FF7
755A:  CLRF   19
755C:  BTFSC  FF2.7
755E:  BSF    19.7
7560:  BCF    FF2.7
7562:  CALL   16EA
7566:  BTFSC  19.7
7568:  BSF    FF2.7
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",ptr_card_key); 
756A:  MOVLW  DE
756C:  MOVWF  FF6
756E:  MOVLW  53
7570:  MOVWF  FF7
7572:  CLRF   19
7574:  BTFSC  FF2.7
7576:  BSF    19.7
7578:  BCF    FF2.7
757A:  MOVLW  12
757C:  MOVLB  8
757E:  MOVWF  x46
7580:  MOVLB  0
7582:  CALL   1606
7586:  BTFSC  19.7
7588:  BSF    FF2.7
758A:  MOVLW  41
758C:  MOVWF  FE9
758E:  CLRF   19
7590:  BTFSC  FF2.7
7592:  BSF    19.7
7594:  BCF    FF2.7
7596:  MOVFF  27,849
759A:  MOVFF  26,848
759E:  MOVFF  25,847
75A2:  MOVFF  24,846
75A6:  CALL   22B4
75AA:  BTFSC  19.7
75AC:  BSF    FF2.7
75AE:  CLRF   19
75B0:  BTFSC  FF2.7
75B2:  BSF    19.7
75B4:  BCF    FF2.7
75B6:  MOVLW  0A
75B8:  MOVLB  8
75BA:  MOVWF  x52
75BC:  MOVLB  0
75BE:  CALL   15C0
75C2:  BTFSC  19.7
75C4:  BSF    FF2.7
75C6:  CLRF   19
75C8:  BTFSC  FF2.7
75CA:  BSF    19.7
75CC:  BCF    FF2.7
75CE:  MOVLW  0D
75D0:  MOVLB  8
75D2:  MOVWF  x52
75D4:  MOVLB  0
75D6:  CALL   15C0
75DA:  BTFSC  19.7
75DC:  BSF    FF2.7
75DE:  CLRF   19
75E0:  BTFSC  FF2.7
75E2:  BSF    19.7
75E4:  BCF    FF2.7
....................    countcard=get_countcard(); 
75E6:  CALL   34CC
75EA:  BTFSC  19.7
75EC:  BSF    FF2.7
75EE:  MOVFF  02,FA
75F2:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
75F6:  SETF   xFC
75F8:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
75FA:  MOVLW  C7
75FC:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
75FE:  MOVLW  37
7600:  MOVWF  FCD
7602:  CLRF   F9A
7604:  CLRF   19
7606:  BTFSC  FF2.7
7608:  BSF    19.7
760A:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
760C:  MOVLB  8
760E:  CLRF   x46
7610:  CLRF   x45
7612:  CLRF   x44
7614:  MOVLW  3C
7616:  MOVWF  x43
7618:  MOVLB  0
761A:  CALL   3400
761E:  BTFSC  19.7
7620:  BSF    FF2.7
7622:  MOVFF  01,156
....................    if(delaycharaction==0)delaycharaction=1; 
7626:  MOVLB  1
7628:  MOVF   x56,F
762A:  BNZ   7630
762C:  MOVLW  01
762E:  MOVWF  x56
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
7630:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
7632:  BSF    FF0.3
7634:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
7636:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
7638:  MOVLW  C0
763A:  IORWF  FF2,F
....................   
....................     mcr_timeout=10000; 
763C:  MOVLB  6
763E:  CLRF   xC3
7640:  CLRF   xC2
7642:  MOVLW  27
7644:  MOVWF  xC1
7646:  MOVLW  10
7648:  MOVWF  xC0
764A:  CLRF   19
764C:  BTFSC  FF2.7
764E:  BSF    19.7
7650:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
7652:  MOVLB  8
7654:  CLRF   x46
7656:  CLRF   x45
7658:  CLRF   x44
765A:  MOVLW  3A
765C:  MOVWF  x43
765E:  MOVLB  0
7660:  CALL   3400
7664:  BTFSC  19.7
7666:  BSF    FF2.7
7668:  MOVFF  01,6DE
766C:  CLRF   19
766E:  BTFSC  FF2.7
7670:  BSF    19.7
7672:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
7674:  MOVLB  8
7676:  CLRF   x46
7678:  CLRF   x45
767A:  CLRF   x44
767C:  MOVLW  3B
767E:  MOVWF  x43
7680:  MOVLB  0
7682:  CALL   3400
7686:  BTFSC  19.7
7688:  BSF    FF2.7
768A:  MOVFF  01,6D2
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
768E:  SETF   xFC
7690:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,wide_strobe_nameconsole,console); 
7692:  MOVLB  7
7694:  CLRF   xF4
7696:  CLRF   xF3
7698:  CLRF   xF2
769A:  MOVLW  28
769C:  MOVWF  xF1
769E:  CLRF   xF8
76A0:  CLRF   xF7
76A2:  CLRF   xF6
76A4:  MOVLW  10
76A6:  MOVWF  xF5
76A8:  MOVLW  06
76AA:  MOVWF  xFA
76AC:  MOVLW  E3
76AE:  MOVWF  xF9
76B0:  MOVLB  0
76B2:  CALL   549A
....................    set_tris_a(0xff);  
76B6:  MOVLW  FF
76B8:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
76BA:  MOVLW  E0
76BC:  MOVLB  F
76BE:  MOVWF  x48
76C0:  BCF    FC2.6
76C2:  BCF    FC2.7
76C4:  MOVF   x49,W
76C6:  ANDLW  E0
76C8:  IORLW  1F
76CA:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
76CC:  MOVF   FC1,W
76CE:  ANDLW  C0
76D0:  IORLW  03
76D2:  MOVWF  FC1
76D4:  BCF    FC1.7
76D6:  BSF    FC2.0
76D8:  BSF    FC1.6
76DA:  BSF    FC2.1
76DC:  BTFSC  FC2.1
76DE:  BRA    76DC
76E0:  BCF    FC1.6
76E2:  CLRF   19
76E4:  BTFSC  FF2.7
76E6:  BSF    19.7
76E8:  BCF    FF2.7
....................     
....................    type_KB=read_ext_eeprom(kindofKB); 
76EA:  MOVLB  8
76EC:  CLRF   x46
76EE:  CLRF   x45
76F0:  CLRF   x44
76F2:  MOVLW  3D
76F4:  MOVWF  x43
76F6:  MOVLB  0
76F8:  CALL   3400
76FC:  BTFSC  19.7
76FE:  BSF    FF2.7
7700:  MOVFF  01,145
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
7704:  MOVLB  1
7706:  MOVF   x45,F
7708:  BZ    7728
770A:  MOVLW  F6
770C:  MOVWF  FF6
770E:  MOVLW  53
7710:  MOVWF  FF7
7712:  CLRF   19
7714:  BTFSC  FF2.7
7716:  BSF    19.7
7718:  BCF    FF2.7
771A:  MOVLB  0
771C:  CALL   16EA
7720:  BTFSC  19.7
7722:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
7724:  BRA    7742
7726:  MOVLB  1
7728:  MOVLW  0A
772A:  MOVWF  FF6
772C:  MOVLW  54
772E:  MOVWF  FF7
7730:  CLRF   19
7732:  BTFSC  FF2.7
7734:  BSF    19.7
7736:  BCF    FF2.7
7738:  MOVLB  0
773A:  CALL   16EA
773E:  BTFSC  19.7
7740:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
7742:  MOVLB  6
7744:  MOVF   xDE,F
7746:  BNZ   7766
7748:  MOVLW  1E
774A:  MOVWF  FF6
774C:  MOVLW  54
774E:  MOVWF  FF7
7750:  CLRF   19
7752:  BTFSC  FF2.7
7754:  BSF    19.7
7756:  BCF    FF2.7
7758:  MOVLB  0
775A:  CALL   16EA
775E:  BTFSC  19.7
7760:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
7762:  BRA    7780
7764:  MOVLB  6
7766:  MOVLW  38
7768:  MOVWF  FF6
776A:  MOVLW  54
776C:  MOVWF  FF7
776E:  CLRF   19
7770:  BTFSC  FF2.7
7772:  BSF    19.7
7774:  BCF    FF2.7
7776:  MOVLB  0
7778:  CALL   16EA
777C:  BTFSC  19.7
777E:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
7780:  MOVLW  01
7782:  MOVWF  FEA
7784:  MOVLW  46
7786:  MOVWF  FE9
7788:  CLRF   00
778A:  CLRF   02
778C:  MOVLW  10
778E:  MOVWF  01
7790:  CALL   3A4E
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
7794:  MOVLB  6
7796:  CLRF   xFD
7798:  MOVF   xFD,W
779A:  SUBLW  13
779C:  BNC   77B2
....................    { 
....................       password[i] = 0; 
779E:  CLRF   03
77A0:  MOVF   xFD,W
77A2:  ADDLW  55
77A4:  MOVWF  FE9
77A6:  MOVLW  00
77A8:  ADDWFC 03,W
77AA:  MOVWF  FEA
77AC:  CLRF   FEF
....................    } 
.................... #endif 
.................... #if 0 
....................    disable_interrupts(GLOBAL); 
....................    save_coutcard(0); 
....................    //save_ptrcard(0,strobe_ptrcard_key); 
....................    //save_ptrcard(0,strobe_ptrcard_addr); 
....................    //write_ext_eeprom(0xFFFE,0x0F); 
....................    //fprintf(COM2,"eeprom is testing: %x",read_ext_eeprom(0x10000)); 
....................    strcpy(key_data,"123456"); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................     
....................    save_key_encrypt(); 
....................   /*  for(i=0;i<8;i++) 
....................    { 
....................        fprintf(COM2,"%c",key_data[i]);   
....................    } */ 
....................    //for(i=0;i<8;i++) fprintf(COM2,"%c",crypto_key[i]); 
....................     
....................    EEPROM_read(EEPROM_KEY_ST,16,buftemp2); 
....................    memset(crypto_key,0,sizeof(crypto_key));  
....................    strcpy(crypto_key,"quang102"); 
....................    //for(i=0;i<16;i++) fprintf(COM2," %x",buftemp2[i]); 
....................    delay_ms(3000); 
....................     
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_data in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"test_key in:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    //strcpy(crypto_key,"@quang102"); 
....................    //rijndael('d', (unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0]); 
....................    aes_enc_dec((unsigned int8 *)&buftemp2[0], (unsigned char *)&crypto_key[0],1); 
....................    //aes_enc_dec((unsigned int8 *)&test_data[0], (unsigned int8 *)&test_key[0],1); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rdecrypted:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",buftemp2[i]); 
....................    fprintf(COM2,"\n\r"); 
....................    fprintf(COM2,"\n\rcrypto_key:\n\r"); 
....................    for(i=0;i<16;i++) fprintf(COM2,"%x",crypto_key[i]); 
....................    while(1); 
.................... #endif 
.................... #if 0 
77AE:  INCF   xFD,F
77B0:  BRA    7798
....................     fprintf(COM2,"\n\reeprom test\n\r"); 
....................     fprintf(COM2,"\n\reeprom is writing\n\r"); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         //write_ext_eeprom(115535+i,i); 
....................     } 
....................     write_ext_eeprom(EEPROM_KEY_ST,210); 
....................     write_ext_eeprom(EEPROM_SIZE_endofkey,123); 
....................     fprintf(COM2,"\n\r"); 
....................     fprintf(COM2,"eeprom is reading: %u",read_ext_eeprom(EEPROM_KEY_ST)); 
....................     for(i=0;i<16;i++) 
....................     { 
....................         fprintf(COM2," %u",read_ext_eeprom(115535+i)); 
....................     } 
....................     while(1); 
.................... #endif 
....................    EEPROM_read(strobe_pass_addr,20,password); 
77B2:  MOVLB  7
77B4:  CLRF   xF4
77B6:  CLRF   xF3
77B8:  CLRF   xF2
77BA:  CLRF   xF1
77BC:  CLRF   xF8
77BE:  CLRF   xF7
77C0:  CLRF   xF6
77C2:  MOVLW  14
77C4:  MOVWF  xF5
77C6:  CLRF   xFA
77C8:  MOVLW  55
77CA:  MOVWF  xF9
77CC:  MOVLB  0
77CE:  CALL   549A
77D2:  CLRF   19
77D4:  BTFSC  FF2.7
77D6:  BSF    19.7
77D8:  BCF    FF2.7
....................    cryption_enable = read_ext_eeprom(crypto_en); 
77DA:  MOVLB  8
77DC:  CLRF   x46
77DE:  CLRF   x45
77E0:  CLRF   x44
77E2:  MOVLW  3E
77E4:  MOVWF  x43
77E6:  MOVLB  0
77E8:  CALL   3400
77EC:  BTFSC  19.7
77EE:  BSF    FF2.7
77F0:  MOVFF  01,11E
....................    if(cryption_enable!=0) 
77F4:  MOVLB  1
77F6:  MOVF   x1E,F
77F8:  BZ    783A
....................    { 
....................         fprintf(COM2,"\n\crypto is enable\n\r"); 
77FA:  MOVLW  50
77FC:  MOVWF  FF6
77FE:  MOVLW  54
7800:  MOVWF  FF7
7802:  CLRF   19
7804:  BTFSC  FF2.7
7806:  BSF    19.7
7808:  BCF    FF2.7
780A:  MOVLB  0
780C:  CALL   16EA
7810:  BTFSC  19.7
7812:  BSF    FF2.7
....................         EEPROM_read(strobe_crypto_key,CRYPTO_KEY_SIZE,crypto_key);  
7814:  MOVLB  7
7816:  CLRF   xF4
7818:  CLRF   xF3
781A:  CLRF   xF2
781C:  MOVLW  3F
781E:  MOVWF  xF1
7820:  CLRF   xF8
7822:  CLRF   xF7
7824:  CLRF   xF6
7826:  MOVLW  20
7828:  MOVWF  xF5
782A:  CLRF   xFA
782C:  MOVLW  FD
782E:  MOVWF  xF9
7830:  MOVLB  0
7832:  CALL   549A
....................    } 
....................    else 
7836:  BRA    7854
7838:  MOVLB  1
....................    { 
....................        fprintf(COM2,"\n\crypto is disable\n\r"); 
783A:  MOVLW  64
783C:  MOVWF  FF6
783E:  MOVLW  54
7840:  MOVWF  FF7
7842:  CLRF   19
7844:  BTFSC  FF2.7
7846:  BSF    19.7
7848:  BCF    FF2.7
784A:  MOVLB  0
784C:  CALL   16EA
7850:  BTFSC  19.7
7852:  BSF    FF2.7
....................    } 
.................... #if 0    
....................    fprintf(COM2,"\n\crypto key:\n\r"); 
....................    for(i=0;i<CRYPTO_KEY_SIZE;i++) 
....................    { 
....................         fprintf(COM2,"%c",crypto_key[i]); 
....................    } 
....................    fprintf(COM2,"\n\r"); 
.................... #endif    
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
7854:  MOVLB  6
7856:  MOVF   xD8,F
7858:  BNZ   7904
....................       { 
....................          fprintf(COM2,"password:"); 
785A:  MOVLW  7A
785C:  MOVWF  FF6
785E:  MOVLW  54
7860:  MOVWF  FF7
7862:  CLRF   19
7864:  BTFSC  FF2.7
7866:  BSF    19.7
7868:  BCF    FF2.7
786A:  MOVLB  0
786C:  CALL   16EA
7870:  BTFSC  19.7
7872:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
7874:  MOVLW  02
7876:  MOVLB  7
7878:  MOVWF  xF1
787A:  MOVLW  14
787C:  MOVWF  xF2
787E:  MOVLW  01
7880:  MOVWF  xF4
7882:  MOVLW  5E
7884:  MOVWF  xF3
7886:  MOVLB  0
7888:  CALL   57C0
....................         // for(i=0;i<5;i++) fprintf(COM2," %c",password[i]); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          EEPROM_read(strobe_pass_addr,20,password); 
788C:  MOVLB  7
788E:  CLRF   xF4
7890:  CLRF   xF3
7892:  CLRF   xF2
7894:  CLRF   xF1
7896:  CLRF   xF8
7898:  CLRF   xF7
789A:  CLRF   xF6
789C:  MOVLW  14
789E:  MOVWF  xF5
78A0:  CLRF   xFA
78A2:  MOVLW  55
78A4:  MOVWF  xF9
78A6:  MOVLB  0
78A8:  CALL   549A
....................          if(!stringcomp(buffer_uart,password)) 
78AC:  MOVLW  01
78AE:  MOVLB  7
78B0:  MOVWF  xF2
78B2:  MOVLW  5E
78B4:  MOVWF  xF1
78B6:  CLRF   xF4
78B8:  MOVLW  55
78BA:  MOVWF  xF3
78BC:  MOVLB  0
78BE:  CALL   58F8
78C2:  MOVF   01,F
78C4:  BNZ   78E8
....................          { 
....................             mode=LOGON; 
78C6:  MOVLW  01
78C8:  MOVLB  6
78CA:  MOVWF  xD8
....................             fprintf(COM2," OK\n\r"); 
78CC:  MOVLW  84
78CE:  MOVWF  FF6
78D0:  MOVLW  54
78D2:  MOVWF  FF7
78D4:  CLRF   19
78D6:  BTFSC  FF2.7
78D8:  BSF    19.7
78DA:  BCF    FF2.7
78DC:  MOVLB  0
78DE:  CALL   16EA
78E2:  BTFSC  19.7
78E4:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
78E6:  BRA    7900
78E8:  MOVLW  8A
78EA:  MOVWF  FF6
78EC:  MOVLW  54
78EE:  MOVWF  FF7
78F0:  CLRF   19
78F2:  BTFSC  FF2.7
78F4:  BSF    19.7
78F6:  BCF    FF2.7
78F8:  CALL   16EA
78FC:  BTFSC  19.7
78FE:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
7900:  BRA    790E
7902:  MOVLB  6
7904:  DECFSZ xD8,W
7906:  BRA    7910
7908:  MOVLB  0
790A:  GOTO   5E0C
790E:  MOVLB  6
....................    } 
7910:  BRA    7856
.................... } 
7912:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

CCS PCH C Compiler, Version 4.140, 33034               24-Jan-17 19:26

               Filename:   D:\magnertic_card_prj\for michael perez\bluetooth_HM11\firmware\main.lst

               ROM used:   29098 bytes (44%)
                           Largest free fragment is 36426
               RAM used:   1925 (51%) at main() level
                           2103 (56%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   6CB4
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   47B4
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1E1E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0414:  MOVLW  02
0416:  MOVLB  7
0418:  SUBWF  xE4,F
041A:  BNC   0434
041C:  MOVLW  07
041E:  MOVWF  FEA
0420:  MOVLW  E4
0422:  MOVWF  FE9
0424:  MOVF   FEF,W
0426:  BZ    0434
0428:  BRA    0430
042A:  BRA    042C
042C:  BRA    042E
042E:  NOP   
0430:  DECFSZ FEF,F
0432:  BRA    042A
0434:  MOVLB  0
0436:  GOTO   1E2E (RETURN)
*
1AEC:  MOVLW  07
1AEE:  MOVWF  FEA
1AF0:  MOVLW  EC
1AF2:  MOVWF  FE9
1AF4:  MOVF   FEF,W
1AF6:  BZ    1B12
1AF8:  MOVLW  0A
1AFA:  MOVWF  01
1AFC:  CLRF   00
1AFE:  DECFSZ 00,F
1B00:  BRA    1AFE
1B02:  DECFSZ 01,F
1B04:  BRA    1AFC
1B06:  MOVLW  5F
1B08:  MOVWF  00
1B0A:  DECFSZ 00,F
1B0C:  BRA    1B0A
1B0E:  DECFSZ FEF,F
1B10:  BRA    1AF8
1B12:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
043A:  BCF    F94.0
043C:  BCF    F8B.0
043E:  MOVLW  08
0440:  MOVWF  01
0442:  BRA    0444
0444:  NOP   
0446:  BSF    01.7
0448:  BRA    046A
044A:  BCF    01.7
044C:  MOVLB  8
044E:  RRCF   x1A,F
0450:  MOVLB  0
0452:  BTFSC  FD8.0
0454:  BSF    F8B.0
0456:  BTFSS  FD8.0
0458:  BCF    F8B.0
045A:  BSF    01.6
045C:  BRA    046A
045E:  BCF    01.6
0460:  DECFSZ 01,F
0462:  BRA    044C
0464:  BRA    0466
0466:  NOP   
0468:  BSF    F8B.0
046A:  MOVLW  01
046C:  MOVWF  00
046E:  CLRF   FE9
0470:  DECFSZ FE9,F
0472:  BRA    0470
0474:  DECFSZ 00,F
0476:  BRA    046E
0478:  MOVLW  0E
047A:  MOVWF  FE9
047C:  DECFSZ FE9,F
047E:  BRA    047C
0480:  NOP   
0482:  BTFSC  01.7
0484:  BRA    044A
0486:  BTFSC  01.6
0488:  BRA    045E
048A:  RETURN 0
*
4D98:  BSF    F94.1
4D9A:  BTFSC  F82.1
4D9C:  BRA    4D9A
4D9E:  MOVLW  08
4DA0:  MOVWF  00
4DA2:  MOVLB  7
4DA4:  CLRF   xC3
4DA6:  BSF    00.7
4DA8:  BRA    4DC6
4DAA:  BCF    00.7
4DAC:  BRA    4DC6
4DAE:  BCF    FD8.0
4DB0:  BTFSC  F82.1
4DB2:  BSF    FD8.0
4DB4:  RRCF   xC3,F
4DB6:  BSF    00.6
4DB8:  BRA    4DC6
4DBA:  BCF    00.6
4DBC:  DECFSZ 00,F
4DBE:  BRA    4DAE
4DC0:  MOVFF  7C3,01
4DC4:  BRA    4DF0
4DC6:  MOVLW  01
4DC8:  MOVWF  FE9
4DCA:  MOVLW  00
4DCC:  BTFSC  00.7
4DCE:  MOVLW  55
4DD0:  MOVWF  01
4DD2:  DECFSZ 01,F
4DD4:  BRA    4DD2
4DD6:  DECFSZ FE9,F
4DD8:  BRA    4DCA
4DDA:  MOVLW  0D
4DDC:  BTFSC  00.7
4DDE:  MOVLW  03
4DE0:  MOVWF  01
4DE2:  DECFSZ 01,F
4DE4:  BRA    4DE2
4DE6:  BTFSC  00.7
4DE8:  BRA    4DAA
4DEA:  BTFSC  00.6
4DEC:  BRA    4DBA
4DEE:  BRA    4DAE
4DF0:  MOVLB  0
4DF2:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
371A:  MOVLW  08
371C:  MOVWF  01
371E:  MOVLW  0A
3720:  MOVWF  00
3722:  DECFSZ 00,F
3724:  BRA    3722
3726:  BCF    F8B.3
3728:  BCF    F94.3
372A:  MOVLW  0B
372C:  MOVWF  00
372E:  DECFSZ 00,F
3730:  BRA    372E
3732:  MOVLB  8
3734:  RLCF   x15,F
3736:  BCF    F8B.4
3738:  BTFSC  FD8.0
373A:  BSF    F94.4
373C:  BTFSS  FD8.0
373E:  BCF    F94.4
3740:  BSF    F94.3
3742:  BTFSS  F82.3
3744:  BRA    3742
3746:  DECFSZ 01,F
3748:  BRA    374C
374A:  BRA    3750
374C:  MOVLB  0
374E:  BRA    371E
3750:  MOVLW  0A
3752:  MOVWF  00
3754:  DECFSZ 00,F
3756:  BRA    3754
3758:  BCF    F8B.3
375A:  BCF    F94.3
375C:  NOP   
375E:  BSF    F94.4
3760:  MOVLW  0B
3762:  MOVWF  00
3764:  DECFSZ 00,F
3766:  BRA    3764
3768:  MOVLW  0B
376A:  MOVWF  00
376C:  DECFSZ 00,F
376E:  BRA    376C
3770:  BSF    F94.3
3772:  BTFSS  F82.3
3774:  BRA    3772
3776:  CLRF   01
3778:  MOVLW  0B
377A:  MOVWF  00
377C:  DECFSZ 00,F
377E:  BRA    377C
3780:  BTFSC  F82.4
3782:  BSF    01.0
3784:  BCF    F8B.3
3786:  BCF    F94.3
3788:  BCF    F8B.4
378A:  BCF    F94.4
378C:  MOVLB  0
378E:  RETURN 0
3790:  MOVLW  08
3792:  MOVLB  8
3794:  MOVWF  x11
3796:  MOVFF  00,812
379A:  BSF    F94.4
379C:  MOVLW  0B
379E:  MOVWF  00
37A0:  DECFSZ 00,F
37A2:  BRA    37A0
37A4:  BSF    F94.3
37A6:  BTFSS  F82.3
37A8:  BRA    37A6
37AA:  BTFSC  F82.4
37AC:  BSF    FD8.0
37AE:  BTFSS  F82.4
37B0:  BCF    FD8.0
37B2:  RLCF   01,F
37B4:  MOVLW  0A
37B6:  MOVWF  00
37B8:  DECFSZ 00,F
37BA:  BRA    37B8
37BC:  BCF    F94.3
37BE:  BCF    F8B.3
37C0:  DECFSZ x11,F
37C2:  BRA    379A
37C4:  BSF    F94.4
37C6:  MOVLW  0B
37C8:  MOVWF  00
37CA:  DECFSZ 00,F
37CC:  BRA    37CA
37CE:  BCF    F8B.4
37D0:  MOVF   x12,W
37D2:  BTFSS  FD8.2
37D4:  BCF    F94.4
37D6:  NOP   
37D8:  BSF    F94.3
37DA:  BTFSS  F82.3
37DC:  BRA    37DA
37DE:  MOVLW  0A
37E0:  MOVWF  00
37E2:  DECFSZ 00,F
37E4:  BRA    37E2
37E6:  BCF    F8B.3
37E8:  BCF    F94.3
37EA:  MOVLW  0B
37EC:  MOVWF  00
37EE:  DECFSZ 00,F
37F0:  BRA    37EE
37F2:  BCF    F8B.4
37F4:  BCF    F94.4
37F6:  MOVLB  0
37F8:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE_key    131071 
.................... #define EEPROM_SIZE        115470 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
4A8E:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
4A90:  BSF    F94.4
....................    port_b_pullups(0xff); 
4A92:  BCF    FF1.7
.................... } 
4A94:  GOTO   6DEE (RETURN)
.................... /* 
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
....................    if(address<0xffff)i2c_write(0xa0); 
....................       else if(address>=0xffff) i2c_write(0xa2); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
....................    i2c_start(); 
....................    status=i2c_write(0xa0); 
....................    while(status==1) 
....................    { 
....................       i2c_start(); 
....................       status=i2c_write(0xa0); 
....................    } 
....................    i2c_stop(); 
.................... } 
.................... */ 
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
....................  
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
*
3D9A:  MOVLB  8
3D9C:  MOVF   x05,F
3D9E:  BNZ   3DA6
3DA0:  MOVF   x04,W
3DA2:  SUBLW  00
3DA4:  BC    3DAC
3DA6:  MOVLW  A2
3DA8:  MOVWF  x08
....................    else command=0xa0; 
3DAA:  BRA    3DB0
3DAC:  MOVLW  A0
3DAE:  MOVWF  x08
....................  
....................    i2c_start(); 
3DB0:  BSF    F94.4
3DB2:  MOVLW  0A
3DB4:  MOVWF  00
3DB6:  DECFSZ 00,F
3DB8:  BRA    3DB6
3DBA:  BSF    F94.3
3DBC:  MOVLW  0B
3DBE:  MOVWF  00
3DC0:  DECFSZ 00,F
3DC2:  BRA    3DC0
3DC4:  BCF    F8B.4
3DC6:  BCF    F94.4
3DC8:  MOVLW  0A
3DCA:  MOVWF  00
3DCC:  DECFSZ 00,F
3DCE:  BRA    3DCC
3DD0:  BCF    F8B.3
3DD2:  BCF    F94.3
....................    i2c_write(command); 
3DD4:  MOVFF  808,815
3DD8:  MOVLB  0
3DDA:  RCALL  371A
....................    i2c_write(address>>8); 
3DDC:  MOVFF  803,80A
3DE0:  MOVFF  804,80B
3DE4:  MOVFF  805,80C
3DE8:  MOVLB  8
3DEA:  CLRF   x0D
3DEC:  MOVFF  803,815
3DF0:  MOVLB  0
3DF2:  RCALL  371A
....................    i2c_write(address); 
3DF4:  MOVFF  802,815
3DF8:  RCALL  371A
....................    i2c_write(data); 
3DFA:  MOVFF  806,815
3DFE:  RCALL  371A
....................  
....................    i2c_stop(); 
3E00:  BCF    F94.4
3E02:  NOP   
3E04:  BSF    F94.3
3E06:  BTFSS  F82.3
3E08:  BRA    3E06
3E0A:  MOVLW  0A
3E0C:  MOVWF  00
3E0E:  DECFSZ 00,F
3E10:  BRA    3E0E
3E12:  BRA    3E14
3E14:  NOP   
3E16:  BSF    F94.4
3E18:  MOVLW  0A
3E1A:  MOVWF  00
3E1C:  DECFSZ 00,F
3E1E:  BRA    3E1C
....................    i2c_start(); 
3E20:  BSF    F94.4
3E22:  MOVLW  0A
3E24:  MOVWF  00
3E26:  DECFSZ 00,F
3E28:  BRA    3E26
3E2A:  BSF    F94.3
3E2C:  MOVLW  0B
3E2E:  MOVWF  00
3E30:  DECFSZ 00,F
3E32:  BRA    3E30
3E34:  BCF    F8B.4
3E36:  BCF    F94.4
3E38:  MOVLW  0A
3E3A:  MOVWF  00
3E3C:  DECFSZ 00,F
3E3E:  BRA    3E3C
3E40:  BCF    F8B.3
3E42:  BCF    F94.3
....................    status=i2c_write(command); 
3E44:  MOVFF  808,815
3E48:  RCALL  371A
3E4A:  MOVF   01,W
3E4C:  MOVLB  8
3E4E:  BCF    x07.0
3E50:  BTFSC  01.0
3E52:  BSF    x07.0
....................    while(status==1) 
....................    { 
3E54:  BTFSS  x07.0
3E56:  BRA    3E94
....................       i2c_start(); 
3E58:  BSF    F94.4
3E5A:  MOVLW  0A
3E5C:  MOVWF  00
3E5E:  DECFSZ 00,F
3E60:  BRA    3E5E
3E62:  BSF    F94.3
3E64:  MOVLW  0B
3E66:  MOVWF  00
3E68:  DECFSZ 00,F
3E6A:  BRA    3E68
3E6C:  BTFSS  F82.3
3E6E:  BRA    3E6C
3E70:  BCF    F8B.4
3E72:  BCF    F94.4
3E74:  MOVLW  0A
3E76:  MOVWF  00
3E78:  DECFSZ 00,F
3E7A:  BRA    3E78
3E7C:  BCF    F8B.3
3E7E:  BCF    F94.3
....................       status=i2c_write(command); 
3E80:  MOVFF  808,815
3E84:  MOVLB  0
3E86:  RCALL  371A
3E88:  MOVF   01,W
3E8A:  MOVLB  8
3E8C:  BCF    x07.0
3E8E:  BTFSC  01.0
3E90:  BSF    x07.0
....................    } 
3E92:  BRA    3E54
....................    //delay_us(100); 
.................... } 
3E94:  MOVLB  0
3E96:  RETURN 0
....................  
.................... /* 
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(0xa1); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    return(data); 
.................... } 
.................... */ 
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
....................    if (address>65535)command=0xa2; 
*
37FA:  MOVLB  8
37FC:  MOVF   x0D,F
37FE:  BNZ   3806
3800:  MOVF   x0C,W
3802:  SUBLW  00
3804:  BC    380C
3806:  MOVLW  A2
3808:  MOVWF  x0F
....................    else command=0xa0; 
380A:  BRA    3810
380C:  MOVLW  A0
380E:  MOVWF  x0F
....................  
....................    i2c_start(); 
3810:  BSF    F94.4
3812:  MOVLW  0A
3814:  MOVWF  00
3816:  DECFSZ 00,F
3818:  BRA    3816
381A:  BSF    F94.3
381C:  MOVLW  0B
381E:  MOVWF  00
3820:  DECFSZ 00,F
3822:  BRA    3820
3824:  BTFSS  F82.3
3826:  BRA    3824
3828:  BCF    F8B.4
382A:  BCF    F94.4
382C:  MOVLW  0A
382E:  MOVWF  00
3830:  DECFSZ 00,F
3832:  BRA    3830
3834:  BCF    F8B.3
3836:  BCF    F94.3
....................    i2c_write(command); 
3838:  MOVFF  80F,815
383C:  MOVLB  0
383E:  RCALL  371A
....................    i2c_write(address>>8); 
3840:  MOVFF  80B,811
3844:  MOVFF  80C,812
3848:  MOVFF  80D,813
384C:  MOVLB  8
384E:  CLRF   x14
3850:  MOVFF  80B,815
3854:  MOVLB  0
3856:  RCALL  371A
....................    i2c_write(address); 
3858:  MOVFF  80A,815
385C:  RCALL  371A
....................    i2c_start(); 
385E:  BSF    F94.4
3860:  MOVLW  0A
3862:  MOVWF  00
3864:  DECFSZ 00,F
3866:  BRA    3864
3868:  BSF    F94.3
386A:  MOVLW  0B
386C:  MOVWF  00
386E:  DECFSZ 00,F
3870:  BRA    386E
3872:  BTFSS  F82.3
3874:  BRA    3872
3876:  BCF    F8B.4
3878:  BCF    F94.4
387A:  MOVLW  0A
387C:  MOVWF  00
387E:  DECFSZ 00,F
3880:  BRA    387E
3882:  BCF    F8B.3
3884:  BCF    F94.3
....................    i2c_write(command+1); 
3886:  MOVLW  01
3888:  MOVLB  8
388A:  ADDWF  x0F,W
388C:  MOVWF  x10
388E:  MOVWF  x15
3890:  MOVLB  0
3892:  RCALL  371A
....................    data=i2c_read(0); 
3894:  CLRF   00
3896:  RCALL  3790
3898:  MOVFF  01,80E
....................    i2c_stop(); 
389C:  BCF    F94.4
389E:  NOP   
38A0:  BSF    F94.3
38A2:  BTFSS  F82.3
38A4:  BRA    38A2
38A6:  MOVLW  0A
38A8:  MOVWF  00
38AA:  DECFSZ 00,F
38AC:  BRA    38AA
38AE:  BRA    38B0
38B0:  NOP   
38B2:  BSF    F94.4
38B4:  MOVLW  0A
38B6:  MOVWF  00
38B8:  DECFSZ 00,F
38BA:  BRA    38B8
....................    return(data); 
38BC:  MOVLB  8
38BE:  MOVFF  80E,01
.................... } 
38C2:  MOVLB  0
38C4:  RETURN 0
....................  
....................  
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
4FF8:  MOVLB  7
4FFA:  MOVF   xBE,W
4FFC:  ADDWF  xBC,W
4FFE:  MOVF   xBF,W
5000:  ADDWFC xBD,W
5002:  MOVWF  xC5
....................    for(i=0;i<len;i++) 
5004:  CLRF   xC3
5006:  CLRF   xC2
5008:  MOVF   xC3,W
500A:  SUBWF  xBF,W
500C:  BNC   5068
500E:  BNZ   5016
5010:  MOVF   xBE,W
5012:  SUBWF  xC2,W
5014:  BC    5068
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
5016:  MOVF   xC0,W
5018:  ADDWF  xC2,W
501A:  MOVWF  01
501C:  MOVF   xC1,W
501E:  ADDWFC xC3,W
5020:  MOVWF  03
5022:  MOVFF  01,7C4
5026:  MOVWF  xC5
5028:  MOVF   xC2,W
502A:  ADDWF  xBC,W
502C:  MOVWF  xC6
502E:  MOVF   xC3,W
5030:  ADDWFC xBD,W
5032:  MOVWF  xC7
5034:  CLRF   19
5036:  BTFSC  FF2.7
5038:  BSF    19.7
503A:  BCF    FF2.7
503C:  MOVLB  8
503E:  CLRF   x0D
5040:  CLRF   x0C
5042:  MOVWF  x0B
5044:  MOVFF  7C6,80A
5048:  MOVLB  0
504A:  CALL   37FA
504E:  BTFSC  19.7
5050:  BSF    FF2.7
5052:  MOVFF  7C5,FEA
5056:  MOVFF  7C4,FE9
505A:  MOVFF  01,FEF
....................    } 
505E:  MOVLB  7
5060:  INCF   xC2,F
5062:  BTFSC  FD8.2
5064:  INCF   xC3,F
5066:  BRA    5008
....................     
.................... } 
5068:  MOVLB  0
506A:  GOTO   5858 (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_mobile_num0        65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_two_number        149 
.................... #define kindofKB                 126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards               930   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
3944:  MOVLB  7
3946:  CLRF   xF8
3948:  MOVF   xF5,W
394A:  SUBWF  xF8,W
394C:  BC    3962
....................    { 
....................       inputdat[i]=0; 
394E:  CLRF   03
3950:  MOVF   xF8,W
3952:  ADDWF  xF6,W
3954:  MOVWF  FE9
3956:  MOVF   xF7,W
3958:  ADDWFC 03,W
395A:  MOVWF  FEA
395C:  CLRF   FEF
....................    } 
395E:  INCF   xF8,F
3960:  BRA    3948
.................... } 
3962:  MOVLB  0
3964:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_write(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
4AF8:  MOVLB  7
4AFA:  CLRF   xD3
4AFC:  MOVF   xD0,W
4AFE:  SUBWF  xD3,W
4B00:  BC    4B4C
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4B02:  MOVF   xD3,W
4B04:  ADDWF  xCF,W
4B06:  MOVWF  xD4
4B08:  CLRF   03
4B0A:  MOVF   xD3,W
4B0C:  ADDWF  xD1,W
4B0E:  MOVWF  FE9
4B10:  MOVF   xD2,W
4B12:  ADDWFC 03,W
4B14:  MOVWF  FEA
4B16:  MOVFF  FEF,7D5
4B1A:  CLRF   19
4B1C:  BTFSC  FF2.7
4B1E:  BSF    19.7
4B20:  BCF    FF2.7
4B22:  MOVLB  8
4B24:  CLRF   x05
4B26:  CLRF   x04
4B28:  CLRF   x03
4B2A:  MOVFF  7D4,802
4B2E:  MOVFF  7D5,806
4B32:  MOVLB  0
4B34:  CALL   3D9A
4B38:  BTFSC  19.7
4B3A:  BSF    FF2.7
....................       delay_us(10); 
4B3C:  MOVLW  1A
4B3E:  MOVWF  00
4B40:  DECFSZ 00,F
4B42:  BRA    4B40
4B44:  NOP   
....................    } 
4B46:  MOVLB  7
4B48:  INCF   xD3,F
4B4A:  BRA    4AFC
.................... } 
4B4C:  MOVLB  0
4B4E:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
4A98:  MOVLB  7
4A9A:  CLRF   xBE
4A9C:  MOVF   xBB,W
4A9E:  SUBWF  xBE,W
4AA0:  BC    4AF4
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
4AA2:  CLRF   03
4AA4:  MOVF   xBE,W
4AA6:  ADDWF  xBC,W
4AA8:  MOVWF  01
4AAA:  MOVF   xBD,W
4AAC:  ADDWFC 03,F
4AAE:  MOVFF  01,7BF
4AB2:  MOVFF  03,7C0
4AB6:  MOVF   xBE,W
4AB8:  ADDWF  xBA,W
4ABA:  MOVWF  xC1
4ABC:  CLRF   19
4ABE:  BTFSC  FF2.7
4AC0:  BSF    19.7
4AC2:  BCF    FF2.7
4AC4:  MOVLB  8
4AC6:  CLRF   x0D
4AC8:  CLRF   x0C
4ACA:  CLRF   x0B
4ACC:  MOVWF  x0A
4ACE:  MOVLB  0
4AD0:  CALL   37FA
4AD4:  BTFSC  19.7
4AD6:  BSF    FF2.7
4AD8:  MOVFF  7C0,FEA
4ADC:  MOVFF  7BF,FE9
4AE0:  MOVFF  01,FEF
....................       delay_us(10); 
4AE4:  MOVLW  1A
4AE6:  MOVWF  00
4AE8:  DECFSZ 00,F
4AEA:  BRA    4AE8
4AEC:  NOP   
....................    } 
4AEE:  MOVLB  7
4AF0:  INCF   xBE,F
4AF2:  BRA    4A9C
.................... } 
4AF4:  MOVLB  0
4AF6:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
4356:  MOVLB  7
4358:  CLRF   xED
435A:  CLRF   xEC
435C:  CLRF   xEB
435E:  CLRF   xEA
4360:  CLRF   xF1
4362:  CLRF   xF0
4364:  CLRF   xEF
4366:  CLRF   xEE
4368:  CLRF   xF5
436A:  CLRF   xF4
436C:  CLRF   xF3
436E:  CLRF   xF2
4370:  CLRF   xF9
4372:  CLRF   xF8
4374:  CLRF   xF7
4376:  CLRF   xF6
4378:  CLRF   xFD
437A:  CLRF   xFC
437C:  CLRF   xFB
437E:  CLRF   xFA
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
4380:  MOVLB  8
4382:  CLRF   x0D
4384:  CLRF   x0C
4386:  CLRF   x0B
4388:  MOVFF  7E9,80A
438C:  MOVLB  0
438E:  CALL   37FA
4392:  MOVLB  7
4394:  MOVFF  01,7EE
4398:  CLRF   xEF
439A:  CLRF   xF0
439C:  CLRF   xF1
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
439E:  MOVLW  01
43A0:  ADDWF  xE9,W
43A2:  MOVWF  xFE
43A4:  MOVLB  8
43A6:  CLRF   x0D
43A8:  CLRF   x0C
43AA:  CLRF   x0B
43AC:  MOVWF  x0A
43AE:  MOVLB  0
43B0:  CALL   37FA
43B4:  MOVLB  7
43B6:  CLRF   xF5
43B8:  CLRF   xF4
43BA:  CLRF   xF3
43BC:  MOVFF  01,7F2
....................    temp2<<=8; 
43C0:  MOVFF  7F4,7F5
43C4:  MOVFF  7F3,7F4
43C8:  MOVFF  7F2,7F3
43CC:  CLRF   xF2
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
43CE:  MOVLW  02
43D0:  ADDWF  xE9,W
43D2:  MOVWF  xFE
43D4:  MOVLB  8
43D6:  CLRF   x0D
43D8:  CLRF   x0C
43DA:  CLRF   x0B
43DC:  MOVWF  x0A
43DE:  MOVLB  0
43E0:  CALL   37FA
43E4:  MOVLB  7
43E6:  CLRF   xF9
43E8:  CLRF   xF8
43EA:  CLRF   xF7
43EC:  MOVFF  01,7F6
....................    temp3<<=16; 
43F0:  MOVFF  7F7,7F9
43F4:  MOVFF  7F6,7F8
43F8:  CLRF   xF6
43FA:  CLRF   xF7
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
43FC:  MOVLW  03
43FE:  ADDWF  xE9,W
4400:  MOVWF  xFE
4402:  MOVLB  8
4404:  CLRF   x0D
4406:  CLRF   x0C
4408:  CLRF   x0B
440A:  MOVWF  x0A
440C:  MOVLB  0
440E:  CALL   37FA
4412:  MOVLB  7
4414:  CLRF   xFD
4416:  CLRF   xFC
4418:  CLRF   xFB
441A:  MOVFF  01,7FA
....................    temp4<<=24; 
441E:  MOVFF  7FA,7FD
4422:  CLRF   xFA
4424:  CLRF   xFB
4426:  CLRF   xFC
....................    buffer = temp4|temp3|temp2|temp1; 
4428:  MOVF   xFA,W
442A:  IORWF  xF6,W
442C:  MOVWF  xFE
442E:  MOVF   xFB,W
4430:  IORWF  xF7,W
4432:  MOVWF  xFF
4434:  MOVF   xFC,W
4436:  IORWF  xF8,W
4438:  MOVLB  8
443A:  MOVWF  x00
443C:  MOVLB  7
443E:  MOVF   xFD,W
4440:  IORWF  xF9,W
4442:  MOVLB  8
4444:  MOVWF  x01
4446:  MOVLB  7
4448:  MOVF   xF2,W
444A:  IORWF  xFE,F
444C:  MOVF   xF3,W
444E:  IORWF  xFF,F
4450:  MOVF   xF4,W
4452:  MOVLB  8
4454:  IORWF  x00,F
4456:  MOVLB  7
4458:  MOVF   xF5,W
445A:  MOVLB  8
445C:  IORWF  x01,F
445E:  MOVLB  7
4460:  MOVF   xFE,W
4462:  IORWF  xEE,W
4464:  MOVWF  xEA
4466:  MOVF   xFF,W
4468:  IORWF  xEF,W
446A:  MOVWF  xEB
446C:  MOVLB  8
446E:  MOVF   x00,W
4470:  MOVLB  7
4472:  IORWF  xF0,W
4474:  MOVWF  xEC
4476:  MOVLB  8
4478:  MOVF   x01,W
447A:  MOVLB  7
447C:  IORWF  xF1,W
447E:  MOVWF  xED
....................    return(buffer); 
4480:  MOVFF  7EA,00
4484:  MOVFF  7EB,01
4488:  MOVFF  7EC,02
448C:  MOVFF  7ED,03
.................... } 
4490:  MOVLB  0
4492:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3E98:  MOVLB  7
3E9A:  CLRF   xF1
3E9C:  CLRF   xF0
3E9E:  CLRF   xEF
3EA0:  CLRF   xEE
3EA2:  CLRF   xF2
3EA4:  CLRF   xF3
3EA6:  CLRF   xF4
3EA8:  CLRF   xF5
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3EAA:  MOVFF  7EC,7F1
3EAE:  MOVFF  7EB,7F0
3EB2:  MOVFF  7EA,7EF
3EB6:  MOVFF  7E9,7EE
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3EBA:  MOVFF  7EE,7F2
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3EBE:  MOVFF  7EF,7F3
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3EC2:  MOVFF  7F0,7F4
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3EC6:  MOVFF  7F1,7F5
....................    write_ext_eeprom((addr+0),temp1); 
3ECA:  MOVLB  8
3ECC:  CLRF   x05
3ECE:  CLRF   x04
3ED0:  CLRF   x03
3ED2:  MOVFF  7ED,802
3ED6:  MOVFF  7F2,806
3EDA:  MOVLB  0
3EDC:  RCALL  3D9A
....................    write_ext_eeprom((addr+1),temp2); 
3EDE:  MOVLW  01
3EE0:  MOVLB  7
3EE2:  ADDWF  xED,W
3EE4:  MOVWF  xF6
3EE6:  MOVLB  8
3EE8:  CLRF   x05
3EEA:  CLRF   x04
3EEC:  CLRF   x03
3EEE:  MOVWF  x02
3EF0:  MOVFF  7F3,806
3EF4:  MOVLB  0
3EF6:  RCALL  3D9A
....................    write_ext_eeprom((addr+2),temp3); 
3EF8:  MOVLW  02
3EFA:  MOVLB  7
3EFC:  ADDWF  xED,W
3EFE:  MOVWF  xF6
3F00:  MOVLB  8
3F02:  CLRF   x05
3F04:  CLRF   x04
3F06:  CLRF   x03
3F08:  MOVWF  x02
3F0A:  MOVFF  7F4,806
3F0E:  MOVLB  0
3F10:  RCALL  3D9A
....................    write_ext_eeprom((addr+3),temp4); 
3F12:  MOVLW  03
3F14:  MOVLB  7
3F16:  ADDWF  xED,W
3F18:  MOVWF  xF6
3F1A:  MOVLB  8
3F1C:  CLRF   x05
3F1E:  CLRF   x04
3F20:  CLRF   x03
3F22:  MOVWF  x02
3F24:  MOVFF  7F5,806
3F28:  MOVLB  0
3F2A:  RCALL  3D9A
.................... } 
3F2C:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
4676:  MOVLB  7
4678:  CLRF   xE9
467A:  CLRF   xE8
467C:  CLRF   xEA
467E:  CLRF   xEB
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
4680:  MOVFF  7E7,7E9
4684:  MOVFF  7E6,7E8
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
4688:  MOVFF  7E8,7EA
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
468C:  MOVF   xE9,W
468E:  MOVWF  xEB
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
4690:  MOVLB  8
4692:  CLRF   x05
4694:  CLRF   x04
4696:  CLRF   x03
4698:  MOVLW  28
469A:  MOVWF  x02
469C:  MOVFF  7EA,806
46A0:  MOVLB  0
46A2:  CALL   3D9A
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
46A6:  MOVLB  8
46A8:  CLRF   x05
46AA:  CLRF   x04
46AC:  CLRF   x03
46AE:  MOVLW  29
46B0:  MOVWF  x02
46B2:  MOVFF  7EB,806
46B6:  MOVLB  0
46B8:  CALL   3D9A
.................... } 
46BC:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
38C6:  MOVLB  7
38C8:  CLRF   xEA
38CA:  CLRF   xE9
38CC:  CLRF   xEC
38CE:  CLRF   xEB
38D0:  CLRF   xEE
38D2:  CLRF   xED
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
38D4:  MOVLB  8
38D6:  CLRF   x0D
38D8:  CLRF   x0C
38DA:  CLRF   x0B
38DC:  MOVLW  28
38DE:  MOVWF  x0A
38E0:  MOVLB  0
38E2:  RCALL  37FA
38E4:  MOVLB  7
38E6:  MOVFF  01,7EB
38EA:  CLRF   xEC
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
38EC:  MOVLB  8
38EE:  CLRF   x0D
38F0:  CLRF   x0C
38F2:  CLRF   x0B
38F4:  MOVLW  29
38F6:  MOVWF  x0A
38F8:  MOVLB  0
38FA:  RCALL  37FA
38FC:  MOVLB  7
38FE:  CLRF   xEE
3900:  MOVFF  01,7ED
....................    temp2<<=8; 
3904:  MOVFF  7ED,7EE
3908:  CLRF   xED
....................    buffer = temp2|temp1; 
390A:  MOVF   xED,W
390C:  IORWF  xEB,W
390E:  MOVWF  xE9
3910:  MOVF   xEE,W
3912:  IORWF  xEC,W
3914:  MOVWF  xEA
....................    return(buffer); 
3916:  MOVFF  7E9,01
391A:  MOVFF  7EA,02
.................... } 
391E:  MOVLB  0
3920:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2,"EEPROM_KEY_ST=%lu\n\r",EEPROM_KEY_ST); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
5188:  MOVLB  7
518A:  CLRF   xBD
518C:  MOVLW  01
518E:  MOVWF  xBC
5190:  MOVLW  C3
5192:  MOVWF  xBB
5194:  MOVLW  0F
5196:  MOVWF  xBA
5198:  MOVF   xBD,W
519A:  SUBWF  27,W
519C:  BNC   51F0
519E:  BNZ   51B6
51A0:  MOVF   xBC,W
51A2:  SUBWF  26,W
51A4:  BNC   51F0
51A6:  BNZ   51B6
51A8:  MOVF   xBB,W
51AA:  SUBWF  25,W
51AC:  BNC   51F0
51AE:  BNZ   51B6
51B0:  MOVF   24,W
51B2:  SUBWF  xBA,W
51B4:  BC    51F0
51B6:  CLRF   19
51B8:  BTFSC  FF2.7
51BA:  BSF    19.7
51BC:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
51BE:  MOVFF  7BD,805
51C2:  MOVFF  7BC,804
51C6:  MOVFF  7BB,803
51CA:  MOVFF  7BA,802
51CE:  MOVLB  8
51D0:  CLRF   x06
51D2:  MOVLB  0
51D4:  CALL   3D9A
51D8:  BTFSC  19.7
51DA:  BSF    FF2.7
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    } 
51DC:  MOVLW  01
51DE:  MOVLB  7
51E0:  ADDWF  xBA,F
51E2:  BTFSC  FD8.0
51E4:  INCF   xBB,F
51E6:  BTFSC  FD8.2
51E8:  INCF   xBC,F
51EA:  BTFSC  FD8.2
51EC:  INCF   xBD,F
51EE:  BRA    5198
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=ptr_start;i<ptr_card;i++) 
51F0:  CLRF   xBD
51F2:  CLRF   xBC
51F4:  CLRF   xBB
51F6:  MOVLW  96
51F8:  MOVWF  xBA
51FA:  MOVF   xBD,W
51FC:  SUBWF  23,W
51FE:  BNC   5252
5200:  BNZ   5218
5202:  MOVF   xBC,W
5204:  SUBWF  22,W
5206:  BNC   5252
5208:  BNZ   5218
520A:  MOVF   xBB,W
520C:  SUBWF  21,W
520E:  BNC   5252
5210:  BNZ   5218
5212:  MOVF   20,W
5214:  SUBWF  xBA,W
5216:  BC    5252
5218:  CLRF   19
521A:  BTFSC  FF2.7
521C:  BSF    19.7
521E:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5220:  MOVFF  7BD,805
5224:  MOVFF  7BC,804
5228:  MOVFF  7BB,803
522C:  MOVFF  7BA,802
5230:  MOVLB  8
5232:  CLRF   x06
5234:  MOVLB  0
5236:  CALL   3D9A
523A:  BTFSC  19.7
523C:  BSF    FF2.7
....................    } 
523E:  MOVLW  01
5240:  MOVLB  7
5242:  ADDWF  xBA,F
5244:  BTFSC  FD8.0
5246:  INCF   xBB,F
5248:  BTFSC  FD8.2
524A:  INCF   xBC,F
524C:  BTFSC  FD8.2
524E:  INCF   xBD,F
5250:  BRA    51FA
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
5252:  CLRF   23
5254:  CLRF   22
5256:  CLRF   21
5258:  MOVLW  96
525A:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
525C:  CLRF   27
525E:  MOVLW  01
5260:  MOVWF  26
5262:  MOVLW  C3
5264:  MOVWF  25
5266:  MOVLW  0F
5268:  MOVWF  24
526A:  CLRF   19
526C:  BTFSC  FF2.7
526E:  BSF    19.7
5270:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5272:  MOVFF  23,7EC
5276:  MOVFF  22,7EB
527A:  MOVFF  21,7EA
527E:  MOVFF  20,7E9
5282:  MOVLW  19
5284:  MOVWF  xED
5286:  MOVLB  0
5288:  CALL   3E98
528C:  BTFSC  19.7
528E:  BSF    FF2.7
5290:  CLRF   19
5292:  BTFSC  FF2.7
5294:  BSF    19.7
5296:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5298:  MOVFF  27,7EC
529C:  MOVFF  26,7EB
52A0:  MOVFF  25,7EA
52A4:  MOVFF  24,7E9
52A8:  MOVLW  1E
52AA:  MOVLB  7
52AC:  MOVWF  xED
52AE:  MOVLB  0
52B0:  CALL   3E98
52B4:  BTFSC  19.7
52B6:  BSF    FF2.7
52B8:  CLRF   19
52BA:  BTFSC  FF2.7
52BC:  BSF    19.7
52BE:  BCF    FF2.7
....................    save_coutcard(0); 
52C0:  MOVLB  7
52C2:  CLRF   xE7
52C4:  CLRF   xE6
52C6:  MOVLB  0
52C8:  CALL   4676
52CC:  BTFSC  19.7
52CE:  BSF    FF2.7
52D0:  CLRF   19
52D2:  BTFSC  FF2.7
52D4:  BSF    19.7
52D6:  BCF    FF2.7
....................    countcard=get_countcard(); 
52D8:  CALL   38C6
52DC:  BTFSC  19.7
52DE:  BSF    FF2.7
52E0:  MOVFF  02,FA
52E4:  MOVFF  01,F9
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
52E8:  GOTO   5BCA (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    /*for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    ptr_card=ptr_start; 
52EC:  CLRF   23
52EE:  CLRF   22
52F0:  CLRF   21
52F2:  MOVLW  96
52F4:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
52F6:  CLRF   27
52F8:  MOVLW  01
52FA:  MOVWF  26
52FC:  MOVLW  C3
52FE:  MOVWF  25
5300:  MOVLW  0F
5302:  MOVWF  24
5304:  CLRF   19
5306:  BTFSC  FF2.7
5308:  BSF    19.7
530A:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
530C:  MOVFF  23,7EC
5310:  MOVFF  22,7EB
5314:  MOVFF  21,7EA
5318:  MOVFF  20,7E9
531C:  MOVLW  19
531E:  MOVLB  7
5320:  MOVWF  xED
5322:  MOVLB  0
5324:  CALL   3E98
5328:  BTFSC  19.7
532A:  BSF    FF2.7
532C:  CLRF   19
532E:  BTFSC  FF2.7
5330:  BSF    19.7
5332:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5334:  MOVFF  27,7EC
5338:  MOVFF  26,7EB
533C:  MOVFF  25,7EA
5340:  MOVFF  24,7E9
5344:  MOVLW  1E
5346:  MOVLB  7
5348:  MOVWF  xED
534A:  MOVLB  0
534C:  CALL   3E98
5350:  BTFSC  19.7
5352:  BSF    FF2.7
5354:  CLRF   19
5356:  BTFSC  FF2.7
5358:  BSF    19.7
535A:  BCF    FF2.7
....................    save_coutcard(0); 
535C:  MOVLB  7
535E:  CLRF   xE7
5360:  CLRF   xE6
5362:  MOVLB  0
5364:  CALL   4676
5368:  BTFSC  19.7
536A:  BSF    FF2.7
.................... } 
536C:  GOTO   5C30 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
4B50:  MOVLB  7
4B52:  CLRF   xBA
4B54:  MOVLW  14
4B56:  MOVWF  xBB
4B58:  CLRF   xBD
4B5A:  MOVLW  55
4B5C:  MOVWF  xBC
4B5E:  MOVLB  0
4B60:  RCALL  4A98
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
4B62:  INCFSZ 55,W
4B64:  BRA    4BBC
4B66:  INCFSZ 56,W
4B68:  BRA    4BBC
4B6A:  INCFSZ x64,W
4B6C:  BRA    4BBC
....................       { 
....................          memset(buffer1,0,20); 
4B6E:  CLRF   FEA
4B70:  MOVLW  2D
4B72:  MOVWF  FE9
4B74:  CLRF   00
4B76:  CLRF   02
4B78:  MOVLW  14
4B7A:  MOVWF  01
4B7C:  CALL   433C
....................          strcpy(buffer1,"admin"); 
4B80:  CLRF   FEA
4B82:  MOVLW  2D
4B84:  MOVWF  FE9
4B86:  MOVLW  00
4B88:  CALL   00BA
4B8C:  TBLRD*-
4B8E:  TBLRD*+
4B90:  MOVF   FF5,W
4B92:  MOVWF  FEE
4B94:  IORLW  00
4B96:  BNZ   4B8E
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
4B98:  MOVLB  7
4B9A:  CLRF   xCF
4B9C:  MOVLW  14
4B9E:  MOVWF  xD0
4BA0:  CLRF   xD2
4BA2:  MOVLW  2D
4BA4:  MOVWF  xD1
4BA6:  MOVLB  0
4BA8:  RCALL  4AF8
....................          EEPROM_read(strobe_pass_addr,20,password); 
4BAA:  MOVLB  7
4BAC:  CLRF   xBA
4BAE:  MOVLW  14
4BB0:  MOVWF  xBB
4BB2:  CLRF   xBD
4BB4:  MOVLW  55
4BB6:  MOVWF  xBC
4BB8:  MOVLB  0
4BBA:  RCALL  4A98
....................       } 
.................... } 
4BBC:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
5370:  MOVLB  7
5372:  CLRF   xCE
5374:  MOVF   xCE,W
5376:  SUBLW  13
5378:  BNC   538E
537A:  CLRF   03
537C:  MOVF   xCE,W
537E:  ADDLW  BA
5380:  MOVWF  FE9
5382:  MOVLW  07
5384:  ADDWFC 03,W
5386:  MOVWF  FEA
5388:  SETF   FEF
538A:  INCF   xCE,F
538C:  BRA    5374
....................    EEPROM_write(strobe_pass_addr,20,buf); 
538E:  CLRF   xCF
5390:  MOVLW  14
5392:  MOVWF  xD0
5394:  MOVLW  07
5396:  MOVWF  xD2
5398:  MOVLW  BA
539A:  MOVWF  xD1
539C:  MOVLB  0
539E:  CALL   4AF8
.................... } 
53A2:  GOTO   5C96 (RETURN)
.................... //============================================ 
.................... void reset_2nd_number() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0; 
....................    EEPROM_write(strobe_mobile_num0,20,buf); 
.................... } 
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
4BBE:  BSF    F94.4
4BC0:  MOVLW  0A
4BC2:  MOVWF  00
4BC4:  DECFSZ 00,F
4BC6:  BRA    4BC4
4BC8:  BSF    F94.3
4BCA:  MOVLW  0B
4BCC:  MOVWF  00
4BCE:  DECFSZ 00,F
4BD0:  BRA    4BCE
4BD2:  BCF    F8B.4
4BD4:  BCF    F94.4
4BD6:  MOVLW  0A
4BD8:  MOVWF  00
4BDA:  DECFSZ 00,F
4BDC:  BRA    4BDA
4BDE:  BCF    F8B.3
4BE0:  BCF    F94.3
4BE2:  CLRF   19
4BE4:  BTFSC  FF2.7
4BE6:  BSF    19.7
4BE8:  BCF    FF2.7
....................    i2c_write(0xD0); 
4BEA:  MOVLW  D0
4BEC:  MOVLB  8
4BEE:  MOVWF  x15
4BF0:  MOVLB  0
4BF2:  CALL   371A
4BF6:  BTFSC  19.7
4BF8:  BSF    FF2.7
4BFA:  CLRF   19
4BFC:  BTFSC  FF2.7
4BFE:  BSF    19.7
4C00:  BCF    FF2.7
....................    i2c_write(address); 
4C02:  MOVFF  7BE,815
4C06:  CALL   371A
4C0A:  BTFSC  19.7
4C0C:  BSF    FF2.7
....................    i2c_start(); 
4C0E:  BSF    F94.4
4C10:  MOVLW  0A
4C12:  MOVWF  00
4C14:  DECFSZ 00,F
4C16:  BRA    4C14
4C18:  BSF    F94.3
4C1A:  MOVLW  0B
4C1C:  MOVWF  00
4C1E:  DECFSZ 00,F
4C20:  BRA    4C1E
4C22:  BTFSS  F82.3
4C24:  BRA    4C22
4C26:  BCF    F8B.4
4C28:  BCF    F94.4
4C2A:  MOVLW  0A
4C2C:  MOVWF  00
4C2E:  DECFSZ 00,F
4C30:  BRA    4C2E
4C32:  BCF    F8B.3
4C34:  BCF    F94.3
4C36:  CLRF   19
4C38:  BTFSC  FF2.7
4C3A:  BSF    19.7
4C3C:  BCF    FF2.7
....................    i2c_write(0xD1); 
4C3E:  MOVLW  D1
4C40:  MOVLB  8
4C42:  MOVWF  x15
4C44:  MOVLB  0
4C46:  CALL   371A
4C4A:  BTFSC  19.7
4C4C:  BSF    FF2.7
....................    result = i2c_read(0); 
4C4E:  CLRF   00
4C50:  CLRF   19
4C52:  BTFSC  FF2.7
4C54:  BSF    19.7
4C56:  BCF    FF2.7
4C58:  CALL   3790
4C5C:  BTFSC  19.7
4C5E:  BSF    FF2.7
4C60:  MOVFF  01,7BF
....................    i2c_stop(); 
4C64:  BCF    F94.4
4C66:  NOP   
4C68:  BSF    F94.3
4C6A:  BTFSS  F82.3
4C6C:  BRA    4C6A
4C6E:  MOVLW  0A
4C70:  MOVWF  00
4C72:  DECFSZ 00,F
4C74:  BRA    4C72
4C76:  BRA    4C78
4C78:  NOP   
4C7A:  BSF    F94.4
4C7C:  MOVLW  0A
4C7E:  MOVWF  00
4C80:  DECFSZ 00,F
4C82:  BRA    4C80
....................     
....................    return(result); 
4C84:  MOVLB  7
4C86:  MOVFF  7BF,01
.................... } 
4C8A:  MOVLB  0
4C8C:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
5556:  BSF    F94.4
5558:  MOVLW  0A
555A:  MOVWF  00
555C:  DECFSZ 00,F
555E:  BRA    555C
5560:  BSF    F94.3
5562:  MOVLW  0B
5564:  MOVWF  00
5566:  DECFSZ 00,F
5568:  BRA    5566
556A:  BCF    F8B.4
556C:  BCF    F94.4
556E:  MOVLW  0A
5570:  MOVWF  00
5572:  DECFSZ 00,F
5574:  BRA    5572
5576:  BCF    F8B.3
5578:  BCF    F94.3
....................    delay_us(10); 
557A:  MOVLW  1A
557C:  MOVWF  00
557E:  DECFSZ 00,F
5580:  BRA    557E
5582:  NOP   
5584:  CLRF   19
5586:  BTFSC  FF2.7
5588:  BSF    19.7
558A:  BCF    FF2.7
....................    i2c_write(0xD0); 
558C:  MOVLW  D0
558E:  MOVLB  8
5590:  MOVWF  x15
5592:  MOVLB  0
5594:  CALL   371A
5598:  BTFSC  19.7
559A:  BSF    FF2.7
....................    delay_us(10); 
559C:  MOVLW  1A
559E:  MOVWF  00
55A0:  DECFSZ 00,F
55A2:  BRA    55A0
55A4:  NOP   
55A6:  CLRF   19
55A8:  BTFSC  FF2.7
55AA:  BSF    19.7
55AC:  BCF    FF2.7
....................    i2c_write(address); 
55AE:  MOVFF  7C1,815
55B2:  CALL   371A
55B6:  BTFSC  19.7
55B8:  BSF    FF2.7
....................    delay_us(10); 
55BA:  MOVLW  1A
55BC:  MOVWF  00
55BE:  DECFSZ 00,F
55C0:  BRA    55BE
55C2:  NOP   
55C4:  CLRF   19
55C6:  BTFSC  FF2.7
55C8:  BSF    19.7
55CA:  BCF    FF2.7
....................    i2c_write(data); 
55CC:  MOVFF  7C2,815
55D0:  CALL   371A
55D4:  BTFSC  19.7
55D6:  BSF    FF2.7
....................    i2c_stop(); 
55D8:  BCF    F94.4
55DA:  NOP   
55DC:  BSF    F94.3
55DE:  BTFSS  F82.3
55E0:  BRA    55DE
55E2:  MOVLW  0A
55E4:  MOVWF  00
55E6:  DECFSZ 00,F
55E8:  BRA    55E6
55EA:  BRA    55EC
55EC:  NOP   
55EE:  BSF    F94.4
55F0:  MOVLW  0A
55F2:  MOVWF  00
55F4:  DECFSZ 00,F
55F6:  BRA    55F4
....................    delay_us(10); 
55F8:  MOVLW  1A
55FA:  MOVWF  00
55FC:  DECFSZ 00,F
55FE:  BRA    55FC
5600:  NOP   
.................... } 
5602:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
*
4C8E:  MOVLB  7
4C90:  CLRF   xBE
4C92:  MOVLB  0
4C94:  RCALL  4BBE
4C96:  MOVFF  01,784
....................     
....................    data &= 0x7F; 
4C9A:  MOVLB  7
4C9C:  BCF    x84.7
....................     
....................    i2c_start(); 
4C9E:  BSF    F94.4
4CA0:  MOVLW  0A
4CA2:  MOVWF  00
4CA4:  DECFSZ 00,F
4CA6:  BRA    4CA4
4CA8:  BSF    F94.3
4CAA:  MOVLW  0B
4CAC:  MOVWF  00
4CAE:  DECFSZ 00,F
4CB0:  BRA    4CAE
4CB2:  BCF    F8B.4
4CB4:  BCF    F94.4
4CB6:  MOVLW  0A
4CB8:  MOVWF  00
4CBA:  DECFSZ 00,F
4CBC:  BRA    4CBA
4CBE:  BCF    F8B.3
4CC0:  BCF    F94.3
4CC2:  CLRF   19
4CC4:  BTFSC  FF2.7
4CC6:  BSF    19.7
4CC8:  BCF    FF2.7
....................    i2c_write(0xD0); 
4CCA:  MOVLW  D0
4CCC:  MOVLB  8
4CCE:  MOVWF  x15
4CD0:  MOVLB  0
4CD2:  CALL   371A
4CD6:  BTFSC  19.7
4CD8:  BSF    FF2.7
4CDA:  CLRF   19
4CDC:  BTFSC  FF2.7
4CDE:  BSF    19.7
4CE0:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
4CE2:  MOVLB  8
4CE4:  CLRF   x15
4CE6:  MOVLB  0
4CE8:  CALL   371A
4CEC:  BTFSC  19.7
4CEE:  BSF    FF2.7
4CF0:  CLRF   19
4CF2:  BTFSC  FF2.7
4CF4:  BSF    19.7
4CF6:  BCF    FF2.7
....................    i2c_write(data); 
4CF8:  MOVFF  784,815
4CFC:  CALL   371A
4D00:  BTFSC  19.7
4D02:  BSF    FF2.7
....................    i2c_start(); 
4D04:  BSF    F94.4
4D06:  MOVLW  0A
4D08:  MOVWF  00
4D0A:  DECFSZ 00,F
4D0C:  BRA    4D0A
4D0E:  BSF    F94.3
4D10:  MOVLW  0B
4D12:  MOVWF  00
4D14:  DECFSZ 00,F
4D16:  BRA    4D14
4D18:  BTFSS  F82.3
4D1A:  BRA    4D18
4D1C:  BCF    F8B.4
4D1E:  BCF    F94.4
4D20:  MOVLW  0A
4D22:  MOVWF  00
4D24:  DECFSZ 00,F
4D26:  BRA    4D24
4D28:  BCF    F8B.3
4D2A:  BCF    F94.3
4D2C:  CLRF   19
4D2E:  BTFSC  FF2.7
4D30:  BSF    19.7
4D32:  BCF    FF2.7
....................    i2c_write(0xD0); 
4D34:  MOVLW  D0
4D36:  MOVLB  8
4D38:  MOVWF  x15
4D3A:  MOVLB  0
4D3C:  CALL   371A
4D40:  BTFSC  19.7
4D42:  BSF    FF2.7
4D44:  CLRF   19
4D46:  BTFSC  FF2.7
4D48:  BSF    19.7
4D4A:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
4D4C:  MOVLW  07
4D4E:  MOVLB  8
4D50:  MOVWF  x15
4D52:  MOVLB  0
4D54:  CALL   371A
4D58:  BTFSC  19.7
4D5A:  BSF    FF2.7
4D5C:  CLRF   19
4D5E:  BTFSC  FF2.7
4D60:  BSF    19.7
4D62:  BCF    FF2.7
....................    i2c_write(0x80); 
4D64:  MOVLW  80
4D66:  MOVLB  8
4D68:  MOVWF  x15
4D6A:  MOVLB  0
4D6C:  CALL   371A
4D70:  BTFSC  19.7
4D72:  BSF    FF2.7
....................    i2c_stop(); 
4D74:  BCF    F94.4
4D76:  NOP   
4D78:  BSF    F94.3
4D7A:  BTFSS  F82.3
4D7C:  BRA    4D7A
4D7E:  MOVLW  0A
4D80:  MOVWF  00
4D82:  DECFSZ 00,F
4D84:  BRA    4D82
4D86:  BRA    4D88
4D88:  NOP   
4D8A:  BSF    F94.4
4D8C:  MOVLW  0A
4D8E:  MOVWF  00
4D90:  DECFSZ 00,F
4D92:  BRA    4D90
.................... } 
4D94:  GOTO   6E50 (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
5604:  CLRF   19
5606:  BTFSC  FF2.7
5608:  BSF    19.7
560A:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
560C:  MOVFF  7C0,800
5610:  MOVLW  0A
5612:  MOVLB  8
5614:  MOVWF  x01
5616:  MOVLB  0
5618:  CALL   1964
561C:  BTFSC  19.7
561E:  BSF    FF2.7
5620:  MOVFF  01,7C1
....................    nibl=data-(nibh*10); 
5624:  MOVLB  7
5626:  MOVF   xC1,W
5628:  MULLW  0A
562A:  MOVF   FF3,W
562C:  SUBWF  xC0,W
562E:  MOVWF  xC2
....................  
....................    return((nibh<<4)|nibl); 
5630:  SWAPF  xC1,W
5632:  MOVWF  00
5634:  MOVLW  F0
5636:  ANDWF  00,F
5638:  MOVF   00,W
563A:  IORWF  xC2,W
563C:  MOVWF  01
.................... } 
563E:  MOVLB  0
5640:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
5410:  MOVFF  7BF,7C0
....................    data=(i>>4)*10; 
5414:  MOVLB  7
5416:  SWAPF  xC0,W
5418:  MOVWF  00
541A:  MOVLW  0F
541C:  ANDWF  00,F
541E:  MOVF   00,W
5420:  MULLW  0A
5422:  MOVFF  FF3,7BF
....................    data=data+(i<<4>>4); 
5426:  SWAPF  xC0,W
5428:  MOVWF  00
542A:  MOVLW  F0
542C:  ANDWF  00,F
542E:  MOVF   00,W
5430:  SWAPF  00,F
5432:  MOVLW  0F
5434:  ANDWF  00,F
5436:  MOVF   00,W
5438:  ADDWF  xBF,F
....................  
....................    return data; 
543A:  MOVFF  7BF,01
.................... } 
543E:  MOVLB  0
5440:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
5642:  MOVLB  7
5644:  CLRF   xC1
5646:  CLRF   xC2
5648:  MOVLB  0
564A:  RCALL  5556
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
564C:  MOVFF  7BF,7C0
5650:  RCALL  5604
5652:  MOVFF  01,7C0
5656:  MOVLW  01
5658:  MOVLB  7
565A:  MOVWF  xC1
565C:  MOVFF  01,7C2
5660:  MOVLB  0
5662:  RCALL  5556
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
5664:  MOVFF  7BE,7C0
5668:  RCALL  5604
566A:  MOVFF  01,7C0
566E:  MOVLW  02
5670:  MOVLB  7
5672:  MOVWF  xC1
5674:  MOVFF  01,7C2
5678:  MOVLB  0
567A:  RCALL  5556
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
567C:  MOVFF  7BD,7C0
5680:  RCALL  5604
5682:  MOVFF  01,7C0
5686:  MOVLW  03
5688:  MOVLB  7
568A:  MOVWF  xC1
568C:  MOVFF  01,7C2
5690:  MOVLB  0
5692:  RCALL  5556
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
5694:  MOVFF  7BA,7C0
5698:  RCALL  5604
569A:  MOVFF  01,7C0
569E:  MOVLW  04
56A0:  MOVLB  7
56A2:  MOVWF  xC1
56A4:  MOVFF  01,7C2
56A8:  MOVLB  0
56AA:  RCALL  5556
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
56AC:  MOVFF  7BB,7C0
56B0:  RCALL  5604
56B2:  MOVFF  01,7C0
56B6:  MOVLW  05
56B8:  MOVLB  7
56BA:  MOVWF  xC1
56BC:  MOVFF  01,7C2
56C0:  MOVLB  0
56C2:  RCALL  5556
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
56C4:  MOVFF  7BC,7C0
56C8:  RCALL  5604
56CA:  MOVFF  01,7C0
56CE:  MOVLW  06
56D0:  MOVLB  7
56D2:  MOVWF  xC1
56D4:  MOVFF  01,7C2
56D8:  MOVLB  0
56DA:  RCALL  5556
....................    write_DS1307(DS1307_CONTROL,0);    
56DC:  MOVLW  07
56DE:  MOVLB  7
56E0:  MOVWF  xC1
56E2:  CLRF   xC2
56E4:  MOVLB  0
56E6:  RCALL  5556
.................... } 
56E8:  GOTO   6330 (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
5E70:  MOVLW  04
5E72:  MOVLB  7
5E74:  MOVWF  xBE
5E76:  MOVLB  0
5E78:  CALL   4BBE
5E7C:  MOVFF  01,7BA
5E80:  MOVFF  01,7BF
5E84:  CALL   5410
5E88:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
5E8C:  MOVLW  05
5E8E:  MOVLB  7
5E90:  MOVWF  xBE
5E92:  MOVLB  0
5E94:  CALL   4BBE
5E98:  MOVFF  01,7BA
5E9C:  MOVFF  01,7BF
5EA0:  CALL   5410
5EA4:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
5EA8:  MOVLW  06
5EAA:  MOVLB  7
5EAC:  MOVWF  xBE
5EAE:  MOVLB  0
5EB0:  CALL   4BBE
5EB4:  MOVFF  01,7BA
5EB8:  MOVFF  01,7BF
5EBC:  CALL   5410
5EC0:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
5EC4:  MOVLW  03
5EC6:  MOVLB  7
5EC8:  MOVWF  xBE
5ECA:  MOVLB  0
5ECC:  CALL   4BBE
5ED0:  MOVFF  01,7BA
5ED4:  MOVFF  01,7BF
5ED8:  CALL   5410
5EDC:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
5EE0:  MOVLW  02
5EE2:  MOVLB  7
5EE4:  MOVWF  xBE
5EE6:  MOVLB  0
5EE8:  CALL   4BBE
5EEC:  MOVFF  01,7BA
5EF0:  MOVFF  01,7BF
5EF4:  CALL   5410
5EF8:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
5EFC:  MOVLW  01
5EFE:  MOVLB  7
5F00:  MOVWF  xBE
5F02:  MOVLB  0
5F04:  CALL   4BBE
5F08:  MOVFF  01,7BA
5F0C:  MOVFF  01,7BF
5F10:  CALL   5410
5F14:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
5F18:  MOVLB  7
5F1A:  CLRF   xBE
5F1C:  MOVLB  0
5F1E:  CALL   4BBE
5F22:  MOVFF  01,7BA
5F26:  MOVFF  01,7BF
5F2A:  CALL   5410
5F2E:  MOVFF  01,103
5F32:  CLRF   19
5F34:  BTFSC  FF2.7
5F36:  BSF    19.7
5F38:  BCF    FF2.7
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0,booting=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... int16 count_checking=10; 
.................... #include <scan_key.c> 
....................  
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... int8 type_KB=0; 
.................... #define key_numbyte  16 
....................  
.................... int8 key_data[key_numbyte]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
22AC:  MOVLB  1
22AE:  INCF   x25,F
22B0:  MOVF   x25,W
22B2:  SUBLW  01
22B4:  BTFSC  FD8.0
22B6:  BRA    245C
....................        switch (col) { 
22B8:  MOVF   x28,W
22BA:  ADDLW  FB
22BC:  BC    2340
22BE:  ADDLW  05
22C0:  MOVLB  0
22C2:  GOTO   2466
....................          case 0   :  
....................                     output_low(COL0); 
22C6:  BCF    F92.5
22C8:  BCF    F89.5
....................                     output_high(COL1); 
22CA:  BCF    F92.3
22CC:  BSF    F89.3
....................                     output_high(COL2); 
22CE:  BCF    F92.2
22D0:  BSF    F89.2
....................                     output_high(COL3); 
22D2:  BCF    F92.1
22D4:  BSF    F89.1
....................                     output_high(COL4); 
22D6:  BCF    F92.0
22D8:  BSF    F89.0
....................                     break; 
22DA:  MOVLB  1
22DC:  BRA    2340
....................          case 1   :  
....................                     output_low(COL1); 
22DE:  BCF    F92.3
22E0:  BCF    F89.3
....................                     output_high(COL0); 
22E2:  BCF    F92.5
22E4:  BSF    F89.5
....................                     output_high(COL2); 
22E6:  BCF    F92.2
22E8:  BSF    F89.2
....................                     output_high(COL3); 
22EA:  BCF    F92.1
22EC:  BSF    F89.1
....................                     output_high(COL4); 
22EE:  BCF    F92.0
22F0:  BSF    F89.0
....................                     break; 
22F2:  MOVLB  1
22F4:  BRA    2340
....................          case 2   :  
....................                     output_low(COL2); 
22F6:  BCF    F92.2
22F8:  BCF    F89.2
....................                     output_high(COL1); 
22FA:  BCF    F92.3
22FC:  BSF    F89.3
....................                     output_high(COL0); 
22FE:  BCF    F92.5
2300:  BSF    F89.5
....................                     output_high(COL3); 
2302:  BCF    F92.1
2304:  BSF    F89.1
....................                     output_high(COL4); 
2306:  BCF    F92.0
2308:  BSF    F89.0
....................                     break; 
230A:  MOVLB  1
230C:  BRA    2340
....................          case 3   :  
....................                     output_low(COL3); 
230E:  BCF    F92.1
2310:  BCF    F89.1
....................                     output_high(COL1); 
2312:  BCF    F92.3
2314:  BSF    F89.3
....................                     output_high(COL2); 
2316:  BCF    F92.2
2318:  BSF    F89.2
....................                     output_high(COL0); 
231A:  BCF    F92.5
231C:  BSF    F89.5
....................                     output_high(COL4); 
231E:  BCF    F92.0
2320:  BSF    F89.0
....................                     break; 
2322:  MOVLB  1
2324:  BRA    2340
....................          case 4   :  
....................                     output_low(COL4); 
2326:  BCF    F92.0
2328:  BCF    F89.0
....................                     output_high(COL1); 
232A:  BCF    F92.3
232C:  BSF    F89.3
....................                     output_high(COL2); 
232E:  BCF    F92.2
2330:  BSF    F89.2
....................                     output_high(COL3); 
2332:  BCF    F92.1
2334:  BSF    F89.1
....................                     output_high(COL0); 
2336:  BCF    F92.5
2338:  BSF    F89.5
....................                     break; 
233A:  MOVLB  1
233C:  BRA    2340
233E:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2340:  BTFSS  x26.0
2342:  BRA    23C2
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2344:  BSF    F93.4
2346:  MOVLW  00
2348:  BTFSC  F81.4
234A:  MOVLW  01
234C:  MOVLB  7
234E:  MOVWF  xE8
2350:  BSF    F93.5
2352:  MOVLW  00
2354:  BTFSC  F81.5
2356:  MOVLW  01
2358:  ANDWF  xE8,F
235A:  BSF    F93.6
235C:  MOVLW  00
235E:  BTFSC  F81.6
2360:  MOVLW  01
2362:  ANDWF  xE8,F
2364:  BSF    F93.7
2366:  MOVLW  00
2368:  BTFSC  F81.7
236A:  MOVLW  01
236C:  ANDWF  xE8,W
236E:  BZ    23BE
....................          { 
....................             kchar=last_key; 
2370:  MOVFF  127,7E6
....................             if(keydebug_en==0) 
2374:  MOVLB  1
2376:  MOVF   x0B,F
2378:  BNZ   23AC
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
237A:  CLRF   x09
237C:  CLRF   x08
....................               charac_timeout=0; 
237E:  MOVLB  0
2380:  CLRF   xFC
2382:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
2384:  MOVLB  1
2386:  MOVF   x0E,W
2388:  SUBLW  0F
238A:  BNC   23A0
238C:  MOVF   x0E,W
238E:  INCF   x0E,F
2390:  CLRF   03
2392:  ADDLW  14
2394:  MOVWF  FE9
2396:  MOVLW  01
2398:  ADDWFC 03,W
239A:  MOVWF  FEA
239C:  MOVFF  7E6,FEF
....................                fputc(kchar,COM2); 
23A0:  MOVFF  7E6,81A
23A4:  MOVLB  0
23A6:  CALL   043A
....................             } 
....................                else fputc(kchar,COM2); 
23AA:  BRA    23B6
23AC:  MOVFF  7E6,81A
23B0:  MOVLB  0
23B2:  CALL   043A
....................            kbd_down=FALSE; 
23B6:  MOVLB  1
23B8:  BCF    x26.0
....................            last_key=0; 
23BA:  CLRF   x27
23BC:  MOVLB  7
....................          } 
....................        } else 
23BE:  BRA    2458
23C0:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
23C2:  BSF    F93.4
23C4:  MOVLW  00
23C6:  BTFSC  F81.4
23C8:  MOVLW  01
23CA:  MOVLB  7
23CC:  MOVWF  xE8
23CE:  BSF    F93.5
23D0:  MOVLW  00
23D2:  BTFSC  F81.5
23D4:  MOVLW  01
23D6:  ANDWF  xE8,F
23D8:  BSF    F93.6
23DA:  MOVLW  00
23DC:  BTFSC  F81.6
23DE:  MOVLW  01
23E0:  ANDWF  xE8,F
23E2:  BSF    F93.7
23E4:  MOVLW  00
23E6:  BTFSC  F81.7
23E8:  MOVLW  01
23EA:  ANDWF  xE8,W
23EC:  BNZ   244C
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
23EE:  BSF    F93.4
23F0:  BTFSC  F81.4
23F2:  BRA    23F8
....................                   row=0; 
23F4:  CLRF   xE7
....................                 else if(input(ROW1)==0) 
23F6:  BRA    241A
23F8:  BSF    F93.5
23FA:  BTFSC  F81.5
23FC:  BRA    2404
....................                   row=1; 
23FE:  MOVLW  01
2400:  MOVWF  xE7
....................                 else if(input(ROW2)==0) 
2402:  BRA    241A
2404:  BSF    F93.6
2406:  BTFSC  F81.6
2408:  BRA    2410
....................                   row=2; 
240A:  MOVLW  02
240C:  MOVWF  xE7
....................                 else if(input(ROW3)==0) 
240E:  BRA    241A
2410:  BSF    F93.7
2412:  BTFSC  F81.7
2414:  BRA    241A
....................                   row=3; 
2416:  MOVLW  03
2418:  MOVWF  xE7
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
241A:  MOVF   xE7,W
241C:  MULLW  05
241E:  MOVF   FF3,W
2420:  CLRF   xE9
2422:  MOVWF  xE8
2424:  CLRF   03
2426:  MOVLB  1
2428:  MOVF   x28,W
242A:  MOVLB  7
242C:  ADDWF  xE8,W
242E:  MOVWF  01
2430:  MOVF   xE9,W
2432:  ADDWFC 03,F
2434:  MOVF   01,W
2436:  MOVLB  0
2438:  CALL   00D0
243C:  MOVFF  FE8,127
....................                 kbd_down = TRUE; 
2440:  MOVLB  1
2442:  BSF    x26.0
....................                 set_tris_a(0xff); 
2444:  MOVLW  FF
2446:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2448:  BRA    2458
244A:  MOVLB  7
....................                { 
....................                   ++col; 
244C:  MOVLB  1
244E:  INCF   x28,F
....................                   if(col==5) col=0; 
2450:  MOVF   x28,W
2452:  SUBLW  05
2454:  BTFSC  FD8.2
2456:  CLRF   x28
....................                } 
....................          } 
....................       kbd_call_count=0; 
2458:  MOVLB  1
245A:  CLRF   x25
....................    } 
....................   return(kchar); 
245C:  MOVLB  7
245E:  MOVFF  7E6,01
.................... } 
2462:  MOVLB  0
2464:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
248A:  MOVLW  E0
248C:  MOVLB  F
248E:  MOVWF  x48
2490:  BCF    FC2.6
2492:  BCF    FC2.7
2494:  MOVF   x49,W
2496:  ANDLW  E0
2498:  IORLW  17
249A:  MOVWF  x49
....................    switch(col) 
....................    { 
249C:  MOVLB  8
249E:  MOVF   x0E,W
24A0:  ADDLW  FA
24A2:  BC    256E
24A4:  ADDLW  06
24A6:  MOVLB  0
24A8:  GOTO   2572
....................       case 0: 
....................         set_adc_channel(4); 
24AC:  MOVLW  10
24AE:  MOVWF  01
24B0:  MOVF   FC2,W
24B2:  ANDLW  C3
24B4:  IORWF  01,W
24B6:  MOVWF  FC2
....................         adc=read_adc(); 
24B8:  BSF    FC2.1
24BA:  BTFSC  FC2.1
24BC:  BRA    24BA
24BE:  MOVFF  FC4,80F
....................         return adc; 
24C2:  MOVLB  8
24C4:  MOVFF  80F,01
24C8:  BRA    256E
....................       break; 
24CA:  BRA    256E
....................       case 1: 
....................         set_adc_channel(3); 
24CC:  MOVLW  0C
24CE:  MOVWF  01
24D0:  MOVF   FC2,W
24D2:  ANDLW  C3
24D4:  IORWF  01,W
24D6:  MOVWF  FC2
....................         adc=read_adc(); 
24D8:  BSF    FC2.1
24DA:  BTFSC  FC2.1
24DC:  BRA    24DA
24DE:  MOVFF  FC4,80F
....................         return adc; 
24E2:  MOVLB  8
24E4:  MOVFF  80F,01
24E8:  BRA    256E
....................       break; 
24EA:  BRA    256E
....................       case 2: 
....................         set_adc_channel(2); 
24EC:  MOVLW  08
24EE:  MOVWF  01
24F0:  MOVF   FC2,W
24F2:  ANDLW  C3
24F4:  IORWF  01,W
24F6:  MOVWF  FC2
....................         adc=read_adc(); 
24F8:  BSF    FC2.1
24FA:  BTFSC  FC2.1
24FC:  BRA    24FA
24FE:  MOVFF  FC4,80F
....................         return adc; 
2502:  MOVLB  8
2504:  MOVFF  80F,01
2508:  BRA    256E
....................       break; 
250A:  BRA    256E
....................       case 3: 
....................         set_adc_channel(1); 
250C:  MOVLW  04
250E:  MOVWF  01
2510:  MOVF   FC2,W
2512:  ANDLW  C3
2514:  IORWF  01,W
2516:  MOVWF  FC2
....................         adc=read_adc(); 
2518:  BSF    FC2.1
251A:  BTFSC  FC2.1
251C:  BRA    251A
251E:  MOVFF  FC4,80F
....................         return adc; 
2522:  MOVLB  8
2524:  MOVFF  80F,01
2528:  BRA    256E
....................       break; 
252A:  BRA    256E
....................       case 4: 
....................         set_adc_channel(0); 
252C:  MOVLW  00
252E:  MOVWF  01
2530:  MOVF   FC2,W
2532:  ANDLW  C3
2534:  IORWF  01,W
2536:  MOVWF  FC2
....................         adc=read_adc(); 
2538:  BSF    FC2.1
253A:  BTFSC  FC2.1
253C:  BRA    253A
253E:  MOVFF  FC4,80F
....................         return adc; 
2542:  MOVLB  8
2544:  MOVFF  80F,01
2548:  BRA    256E
....................       break;      
254A:  BRA    256E
....................       case 5: 
....................         set_adc_channel(11); 
254C:  MOVLW  2C
254E:  MOVWF  01
2550:  MOVF   FC2,W
2552:  ANDLW  C3
2554:  IORWF  01,W
2556:  MOVWF  FC2
....................         adc=read_adc(); 
2558:  BSF    FC2.1
255A:  BTFSC  FC2.1
255C:  BRA    255A
255E:  MOVFF  FC4,80F
....................         return adc; 
2562:  MOVLB  8
2564:  MOVFF  80F,01
2568:  BRA    256E
....................       break;      
256A:  BRA    256E
256C:  MOVLB  8
....................    } 
.................... } 
256E:  MOVLB  0
2570:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
26EC:  MOVLB  7
26EE:  CLRF   xEE
26F0:  CLRF   xED
26F2:  CLRF   xEC
26F4:  CLRF   xEB
26F6:  CLRF   xF2
26F8:  CLRF   xF1
26FA:  CLRF   xF0
26FC:  CLRF   xEF
26FE:  CLRF   xF6
2700:  CLRF   xF5
2702:  CLRF   xF4
2704:  CLRF   xF3
2706:  CLRF   xFA
2708:  CLRF   xF9
270A:  CLRF   xF8
270C:  CLRF   xF7
270E:  CLRF   xFE
2710:  CLRF   xFD
2712:  CLRF   xFC
2714:  CLRF   xFB
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2716:  CLRF   xEA
2718:  CLRF   xE9
271A:  MOVF   xEA,W
271C:  SUBLW  01
271E:  BNC   27A6
2720:  BNZ   2728
2722:  MOVF   xE9,W
2724:  SUBLW  F3
2726:  BNC   27A6
....................    { 
....................       col_0=read_col(0)+col_0; 
2728:  MOVLB  8
272A:  CLRF   x0E
272C:  MOVLB  0
272E:  RCALL  248A
2730:  MOVF   01,W
2732:  MOVLB  7
2734:  ADDWF  xEB,F
2736:  MOVLW  00
2738:  ADDWFC xEC,F
273A:  ADDWFC xED,F
273C:  ADDWFC xEE,F
....................       col_1=read_col(1)+col_1; 
273E:  MOVLW  01
2740:  MOVLB  8
2742:  MOVWF  x0E
2744:  MOVLB  0
2746:  RCALL  248A
2748:  MOVF   01,W
274A:  MOVLB  7
274C:  ADDWF  xEF,F
274E:  MOVLW  00
2750:  ADDWFC xF0,F
2752:  ADDWFC xF1,F
2754:  ADDWFC xF2,F
....................       col_2=read_col(2)+col_2; 
2756:  MOVLW  02
2758:  MOVLB  8
275A:  MOVWF  x0E
275C:  MOVLB  0
275E:  RCALL  248A
2760:  MOVF   01,W
2762:  MOVLB  7
2764:  ADDWF  xF3,F
2766:  MOVLW  00
2768:  ADDWFC xF4,F
276A:  ADDWFC xF5,F
276C:  ADDWFC xF6,F
....................       col_3=read_col(3)+col_3; 
276E:  MOVLW  03
2770:  MOVLB  8
2772:  MOVWF  x0E
2774:  MOVLB  0
2776:  RCALL  248A
2778:  MOVF   01,W
277A:  MOVLB  7
277C:  ADDWF  xF7,F
277E:  MOVLW  00
2780:  ADDWFC xF8,F
2782:  ADDWFC xF9,F
2784:  ADDWFC xFA,F
....................       col_4=read_col(4)+col_4; 
2786:  MOVLW  04
2788:  MOVLB  8
278A:  MOVWF  x0E
278C:  MOVLB  0
278E:  RCALL  248A
2790:  MOVF   01,W
2792:  MOVLB  7
2794:  ADDWF  xFB,F
2796:  MOVLW  00
2798:  ADDWFC xFC,F
279A:  ADDWFC xFD,F
279C:  ADDWFC xFE,F
....................    } 
279E:  INCF   xE9,F
27A0:  BTFSC  FD8.2
27A2:  INCF   xEA,F
27A4:  BRA    271A
....................    col_0=col_0/500; 
27A6:  BCF    FD8.1
27A8:  MOVFF  7EE,81D
27AC:  MOVFF  7ED,81C
27B0:  MOVFF  7EC,81B
27B4:  MOVFF  7EB,81A
27B8:  MOVLB  8
27BA:  CLRF   x21
27BC:  CLRF   x20
27BE:  MOVLW  01
27C0:  MOVWF  x1F
27C2:  MOVLW  F4
27C4:  MOVWF  x1E
27C6:  MOVLB  0
27C8:  RCALL  2598
27CA:  MOVFF  03,7EE
27CE:  MOVFF  02,7ED
27D2:  MOVFF  01,7EC
27D6:  MOVFF  00,7EB
....................    col_1=col_1/500; 
27DA:  BCF    FD8.1
27DC:  MOVFF  7F2,81D
27E0:  MOVFF  7F1,81C
27E4:  MOVFF  7F0,81B
27E8:  MOVFF  7EF,81A
27EC:  MOVLB  8
27EE:  CLRF   x21
27F0:  CLRF   x20
27F2:  MOVLW  01
27F4:  MOVWF  x1F
27F6:  MOVLW  F4
27F8:  MOVWF  x1E
27FA:  MOVLB  0
27FC:  RCALL  2598
27FE:  MOVFF  03,7F2
2802:  MOVFF  02,7F1
2806:  MOVFF  01,7F0
280A:  MOVFF  00,7EF
....................    col_2=col_2/500; 
280E:  BCF    FD8.1
2810:  MOVFF  7F6,81D
2814:  MOVFF  7F5,81C
2818:  MOVFF  7F4,81B
281C:  MOVFF  7F3,81A
2820:  MOVLB  8
2822:  CLRF   x21
2824:  CLRF   x20
2826:  MOVLW  01
2828:  MOVWF  x1F
282A:  MOVLW  F4
282C:  MOVWF  x1E
282E:  MOVLB  0
2830:  RCALL  2598
2832:  MOVFF  03,7F6
2836:  MOVFF  02,7F5
283A:  MOVFF  01,7F4
283E:  MOVFF  00,7F3
....................    col_3=col_3/500; 
2842:  BCF    FD8.1
2844:  MOVFF  7FA,81D
2848:  MOVFF  7F9,81C
284C:  MOVFF  7F8,81B
2850:  MOVFF  7F7,81A
2854:  MOVLB  8
2856:  CLRF   x21
2858:  CLRF   x20
285A:  MOVLW  01
285C:  MOVWF  x1F
285E:  MOVLW  F4
2860:  MOVWF  x1E
2862:  MOVLB  0
2864:  RCALL  2598
2866:  MOVFF  03,7FA
286A:  MOVFF  02,7F9
286E:  MOVFF  01,7F8
2872:  MOVFF  00,7F7
....................    col_4=col_4/500; 
2876:  BCF    FD8.1
2878:  MOVFF  7FE,81D
287C:  MOVFF  7FD,81C
2880:  MOVFF  7FC,81B
2884:  MOVFF  7FB,81A
2888:  MOVLB  8
288A:  CLRF   x21
288C:  CLRF   x20
288E:  MOVLW  01
2890:  MOVWF  x1F
2892:  MOVLW  F4
2894:  MOVWF  x1E
2896:  MOVLB  0
2898:  RCALL  2598
289A:  MOVFF  03,7FE
289E:  MOVFF  02,7FD
28A2:  MOVFF  01,7FC
28A6:  MOVFF  00,7FB
....................    if(keydebug_en) 
28AA:  MOVLB  1
28AC:  MOVF   x0B,F
28AE:  BTFSC  FD8.2
28B0:  BRA    2A2C
....................    { 
....................       fprintf(COM2,"\r\n");      
28B2:  MOVLW  0D
28B4:  MOVLB  8
28B6:  MOVWF  x1A
28B8:  MOVLB  0
28BA:  CALL   043A
28BE:  MOVLW  0A
28C0:  MOVLB  8
28C2:  MOVWF  x1A
28C4:  MOVLB  0
28C6:  CALL   043A
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
28CA:  MOVLW  7E
28CC:  MOVWF  FF6
28CE:  MOVLW  02
28D0:  MOVWF  FF7
28D2:  MOVLW  07
28D4:  MOVLB  8
28D6:  MOVWF  x0E
28D8:  MOVLB  0
28DA:  CALL   187C
28DE:  MOVLW  41
28E0:  MOVWF  FE9
28E2:  MOVFF  7EE,811
28E6:  MOVFF  7ED,810
28EA:  MOVFF  7EC,80F
28EE:  MOVFF  7EB,80E
28F2:  RCALL  262C
28F4:  MOVLW  0D
28F6:  MOVLB  8
28F8:  MOVWF  x1A
28FA:  MOVLB  0
28FC:  CALL   043A
2900:  MOVLW  0A
2902:  MOVLB  8
2904:  MOVWF  x1A
2906:  MOVLB  0
2908:  CALL   043A
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
290C:  MOVLW  8C
290E:  MOVWF  FF6
2910:  MOVLW  02
2912:  MOVWF  FF7
2914:  MOVLW  07
2916:  MOVLB  8
2918:  MOVWF  x0E
291A:  MOVLB  0
291C:  CALL   187C
2920:  MOVLW  41
2922:  MOVWF  FE9
2924:  MOVFF  7F2,811
2928:  MOVFF  7F1,810
292C:  MOVFF  7F0,80F
2930:  MOVFF  7EF,80E
2934:  RCALL  262C
2936:  MOVLW  0D
2938:  MOVLB  8
293A:  MOVWF  x1A
293C:  MOVLB  0
293E:  CALL   043A
2942:  MOVLW  0A
2944:  MOVLB  8
2946:  MOVWF  x1A
2948:  MOVLB  0
294A:  CALL   043A
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
294E:  MOVLW  9A
2950:  MOVWF  FF6
2952:  MOVLW  02
2954:  MOVWF  FF7
2956:  MOVLW  07
2958:  MOVLB  8
295A:  MOVWF  x0E
295C:  MOVLB  0
295E:  CALL   187C
2962:  MOVLW  41
2964:  MOVWF  FE9
2966:  MOVFF  7F6,811
296A:  MOVFF  7F5,810
296E:  MOVFF  7F4,80F
2972:  MOVFF  7F3,80E
2976:  RCALL  262C
2978:  MOVLW  0D
297A:  MOVLB  8
297C:  MOVWF  x1A
297E:  MOVLB  0
2980:  CALL   043A
2984:  MOVLW  0A
2986:  MOVLB  8
2988:  MOVWF  x1A
298A:  MOVLB  0
298C:  CALL   043A
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2990:  MOVLW  A8
2992:  MOVWF  FF6
2994:  MOVLW  02
2996:  MOVWF  FF7
2998:  MOVLW  07
299A:  MOVLB  8
299C:  MOVWF  x0E
299E:  MOVLB  0
29A0:  CALL   187C
29A4:  MOVLW  41
29A6:  MOVWF  FE9
29A8:  MOVFF  7FA,811
29AC:  MOVFF  7F9,810
29B0:  MOVFF  7F8,80F
29B4:  MOVFF  7F7,80E
29B8:  RCALL  262C
29BA:  MOVLW  0D
29BC:  MOVLB  8
29BE:  MOVWF  x1A
29C0:  MOVLB  0
29C2:  CALL   043A
29C6:  MOVLW  0A
29C8:  MOVLB  8
29CA:  MOVWF  x1A
29CC:  MOVLB  0
29CE:  CALL   043A
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
29D2:  MOVLW  B6
29D4:  MOVWF  FF6
29D6:  MOVLW  02
29D8:  MOVWF  FF7
29DA:  MOVLW  07
29DC:  MOVLB  8
29DE:  MOVWF  x0E
29E0:  MOVLB  0
29E2:  CALL   187C
29E6:  MOVLW  41
29E8:  MOVWF  FE9
29EA:  MOVFF  7FE,811
29EE:  MOVFF  7FD,810
29F2:  MOVFF  7FC,80F
29F6:  MOVFF  7FB,80E
29FA:  RCALL  262C
29FC:  MOVLW  0D
29FE:  MOVLB  8
2A00:  MOVWF  x1A
2A02:  MOVLB  0
2A04:  CALL   043A
2A08:  MOVLW  0A
2A0A:  MOVLB  8
2A0C:  MOVWF  x1A
2A0E:  MOVLB  0
2A10:  CALL   043A
....................       fprintf(COM2,"\r\n"); 
2A14:  MOVLW  0D
2A16:  MOVLB  8
2A18:  MOVWF  x1A
2A1A:  MOVLB  0
2A1C:  CALL   043A
2A20:  MOVLW  0A
2A22:  MOVLB  8
2A24:  MOVWF  x1A
2A26:  MOVLB  0
2A28:  CALL   043A
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
2A2C:  MOVLB  7
2A2E:  MOVF   xEE,F
2A30:  BNZ   2A40
2A32:  MOVF   xED,F
2A34:  BNZ   2A40
2A36:  MOVF   xEC,F
2A38:  BNZ   2A40
2A3A:  MOVF   xEB,W
2A3C:  SUBLW  05
2A3E:  BC    2AA0
2A40:  MOVF   xEE,F
2A42:  BNZ   2AA0
2A44:  MOVF   xED,F
2A46:  BNZ   2AA0
2A48:  MOVF   xEC,F
2A4A:  BNZ   2AA0
2A4C:  MOVF   xEB,W
2A4E:  SUBLW  3B
2A50:  BNC   2AA0
2A52:  MOVF   xF2,F
2A54:  BNZ   2A64
2A56:  MOVF   xF1,F
2A58:  BNZ   2A64
2A5A:  MOVF   xF0,F
2A5C:  BNZ   2A64
2A5E:  MOVF   xEF,W
2A60:  SUBLW  64
2A62:  BC    2AA0
2A64:  MOVF   xF6,F
2A66:  BNZ   2A76
2A68:  MOVF   xF5,F
2A6A:  BNZ   2A76
2A6C:  MOVF   xF4,F
2A6E:  BNZ   2A76
2A70:  MOVF   xF3,W
2A72:  SUBLW  64
2A74:  BC    2AA0
2A76:  MOVF   xFA,F
2A78:  BNZ   2A88
2A7A:  MOVF   xF9,F
2A7C:  BNZ   2A88
2A7E:  MOVF   xF8,F
2A80:  BNZ   2A88
2A82:  MOVF   xF7,W
2A84:  SUBLW  64
2A86:  BC    2AA0
2A88:  MOVF   xFE,F
2A8A:  BNZ   2A9A
2A8C:  MOVF   xFD,F
2A8E:  BNZ   2A9A
2A90:  MOVF   xFC,F
2A92:  BNZ   2A9A
2A94:  MOVF   xFB,W
2A96:  SUBLW  64
2A98:  BC    2AA0
2A9A:  MOVLW  00
2A9C:  MOVWF  01
2A9E:  BRA    2D1E
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
2AA0:  MOVF   xF2,F
2AA2:  BNZ   2AB2
2AA4:  MOVF   xF1,F
2AA6:  BNZ   2AB2
2AA8:  MOVF   xF0,F
2AAA:  BNZ   2AB2
2AAC:  MOVF   xEF,W
2AAE:  SUBLW  05
2AB0:  BC    2B12
2AB2:  MOVF   xF2,F
2AB4:  BNZ   2B12
2AB6:  MOVF   xF1,F
2AB8:  BNZ   2B12
2ABA:  MOVF   xF0,F
2ABC:  BNZ   2B12
2ABE:  MOVF   xEF,W
2AC0:  SUBLW  3B
2AC2:  BNC   2B12
2AC4:  MOVF   xEE,F
2AC6:  BNZ   2AD6
2AC8:  MOVF   xED,F
2ACA:  BNZ   2AD6
2ACC:  MOVF   xEC,F
2ACE:  BNZ   2AD6
2AD0:  MOVF   xEB,W
2AD2:  SUBLW  64
2AD4:  BC    2B12
2AD6:  MOVF   xF6,F
2AD8:  BNZ   2AE8
2ADA:  MOVF   xF5,F
2ADC:  BNZ   2AE8
2ADE:  MOVF   xF4,F
2AE0:  BNZ   2AE8
2AE2:  MOVF   xF3,W
2AE4:  SUBLW  64
2AE6:  BC    2B12
2AE8:  MOVF   xFA,F
2AEA:  BNZ   2AFA
2AEC:  MOVF   xF9,F
2AEE:  BNZ   2AFA
2AF0:  MOVF   xF8,F
2AF2:  BNZ   2AFA
2AF4:  MOVF   xF7,W
2AF6:  SUBLW  64
2AF8:  BC    2B12
2AFA:  MOVF   xFE,F
2AFC:  BNZ   2B0C
2AFE:  MOVF   xFD,F
2B00:  BNZ   2B0C
2B02:  MOVF   xFC,F
2B04:  BNZ   2B0C
2B06:  MOVF   xFB,W
2B08:  SUBLW  64
2B0A:  BC    2B12
2B0C:  MOVLW  01
2B0E:  MOVWF  01
2B10:  BRA    2D1E
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
2B12:  MOVF   xF6,F
2B14:  BNZ   2B24
2B16:  MOVF   xF5,F
2B18:  BNZ   2B24
2B1A:  MOVF   xF4,F
2B1C:  BNZ   2B24
2B1E:  MOVF   xF3,W
2B20:  SUBLW  05
2B22:  BC    2B84
2B24:  MOVF   xF6,F
2B26:  BNZ   2B84
2B28:  MOVF   xF5,F
2B2A:  BNZ   2B84
2B2C:  MOVF   xF4,F
2B2E:  BNZ   2B84
2B30:  MOVF   xF3,W
2B32:  SUBLW  3B
2B34:  BNC   2B84
2B36:  MOVF   xF2,F
2B38:  BNZ   2B48
2B3A:  MOVF   xF1,F
2B3C:  BNZ   2B48
2B3E:  MOVF   xF0,F
2B40:  BNZ   2B48
2B42:  MOVF   xEF,W
2B44:  SUBLW  64
2B46:  BC    2B84
2B48:  MOVF   xEE,F
2B4A:  BNZ   2B5A
2B4C:  MOVF   xED,F
2B4E:  BNZ   2B5A
2B50:  MOVF   xEC,F
2B52:  BNZ   2B5A
2B54:  MOVF   xEB,W
2B56:  SUBLW  64
2B58:  BC    2B84
2B5A:  MOVF   xFA,F
2B5C:  BNZ   2B6C
2B5E:  MOVF   xF9,F
2B60:  BNZ   2B6C
2B62:  MOVF   xF8,F
2B64:  BNZ   2B6C
2B66:  MOVF   xF7,W
2B68:  SUBLW  64
2B6A:  BC    2B84
2B6C:  MOVF   xFE,F
2B6E:  BNZ   2B7E
2B70:  MOVF   xFD,F
2B72:  BNZ   2B7E
2B74:  MOVF   xFC,F
2B76:  BNZ   2B7E
2B78:  MOVF   xFB,W
2B7A:  SUBLW  64
2B7C:  BC    2B84
2B7E:  MOVLW  02
2B80:  MOVWF  01
2B82:  BRA    2D1E
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2B84:  MOVF   xFA,F
2B86:  BNZ   2B96
2B88:  MOVF   xF9,F
2B8A:  BNZ   2B96
2B8C:  MOVF   xF8,F
2B8E:  BNZ   2B96
2B90:  MOVF   xF7,W
2B92:  SUBLW  05
2B94:  BC    2BF6
2B96:  MOVF   xFA,F
2B98:  BNZ   2BF6
2B9A:  MOVF   xF9,F
2B9C:  BNZ   2BF6
2B9E:  MOVF   xF8,F
2BA0:  BNZ   2BF6
2BA2:  MOVF   xF7,W
2BA4:  SUBLW  3B
2BA6:  BNC   2BF6
2BA8:  MOVF   xF2,F
2BAA:  BNZ   2BBA
2BAC:  MOVF   xF1,F
2BAE:  BNZ   2BBA
2BB0:  MOVF   xF0,F
2BB2:  BNZ   2BBA
2BB4:  MOVF   xEF,W
2BB6:  SUBLW  64
2BB8:  BC    2BF6
2BBA:  MOVF   xF6,F
2BBC:  BNZ   2BCC
2BBE:  MOVF   xF5,F
2BC0:  BNZ   2BCC
2BC2:  MOVF   xF4,F
2BC4:  BNZ   2BCC
2BC6:  MOVF   xF3,W
2BC8:  SUBLW  64
2BCA:  BC    2BF6
2BCC:  MOVF   xEE,F
2BCE:  BNZ   2BDE
2BD0:  MOVF   xED,F
2BD2:  BNZ   2BDE
2BD4:  MOVF   xEC,F
2BD6:  BNZ   2BDE
2BD8:  MOVF   xEB,W
2BDA:  SUBLW  64
2BDC:  BC    2BF6
2BDE:  MOVF   xFE,F
2BE0:  BNZ   2BF0
2BE2:  MOVF   xFD,F
2BE4:  BNZ   2BF0
2BE6:  MOVF   xFC,F
2BE8:  BNZ   2BF0
2BEA:  MOVF   xFB,W
2BEC:  SUBLW  64
2BEE:  BC    2BF6
2BF0:  MOVLW  03
2BF2:  MOVWF  01
2BF4:  BRA    2D1E
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2BF6:  MOVF   xFE,F
2BF8:  BNZ   2C08
2BFA:  MOVF   xFD,F
2BFC:  BNZ   2C08
2BFE:  MOVF   xFC,F
2C00:  BNZ   2C08
2C02:  MOVF   xFB,W
2C04:  SUBLW  05
2C06:  BC    2C68
2C08:  MOVF   xFE,F
2C0A:  BNZ   2C68
2C0C:  MOVF   xFD,F
2C0E:  BNZ   2C68
2C10:  MOVF   xFC,F
2C12:  BNZ   2C68
2C14:  MOVF   xFB,W
2C16:  SUBLW  3B
2C18:  BNC   2C68
2C1A:  MOVF   xF2,F
2C1C:  BNZ   2C2C
2C1E:  MOVF   xF1,F
2C20:  BNZ   2C2C
2C22:  MOVF   xF0,F
2C24:  BNZ   2C2C
2C26:  MOVF   xEF,W
2C28:  SUBLW  64
2C2A:  BC    2C68
2C2C:  MOVF   xF6,F
2C2E:  BNZ   2C3E
2C30:  MOVF   xF5,F
2C32:  BNZ   2C3E
2C34:  MOVF   xF4,F
2C36:  BNZ   2C3E
2C38:  MOVF   xF3,W
2C3A:  SUBLW  64
2C3C:  BC    2C68
2C3E:  MOVF   xFA,F
2C40:  BNZ   2C50
2C42:  MOVF   xF9,F
2C44:  BNZ   2C50
2C46:  MOVF   xF8,F
2C48:  BNZ   2C50
2C4A:  MOVF   xF7,W
2C4C:  SUBLW  64
2C4E:  BC    2C68
2C50:  MOVF   xEE,F
2C52:  BNZ   2C62
2C54:  MOVF   xED,F
2C56:  BNZ   2C62
2C58:  MOVF   xEC,F
2C5A:  BNZ   2C62
2C5C:  MOVF   xEB,W
2C5E:  SUBLW  64
2C60:  BC    2C68
2C62:  MOVLW  04
2C64:  MOVWF  01
2C66:  BRA    2D1E
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2C68:  MOVF   xFE,F
2C6A:  BNZ   2C7C
2C6C:  MOVF   xFD,F
2C6E:  BNZ   2C7C
2C70:  MOVF   xFC,F
2C72:  BNZ   2C7C
2C74:  MOVF   xFB,W
2C76:  SUBLW  C8
2C78:  BTFSC  FD8.0
2C7A:  BRA    2D1A
2C7C:  MOVF   xEE,F
2C7E:  BTFSS  FD8.2
2C80:  BRA    2D1A
2C82:  MOVF   xED,F
2C84:  BTFSS  FD8.2
2C86:  BRA    2D1A
2C88:  MOVF   xEC,F
2C8A:  BTFSS  FD8.2
2C8C:  BRA    2D1A
2C8E:  MOVF   xEB,W
2C90:  SUBLW  B3
2C92:  BNC   2D1A
2C94:  MOVF   xEE,F
2C96:  BNZ   2CA6
2C98:  MOVF   xED,F
2C9A:  BNZ   2CA6
2C9C:  MOVF   xEC,F
2C9E:  BNZ   2CA6
2CA0:  MOVF   xEB,W
2CA2:  SUBLW  64
2CA4:  BC    2D1A
2CA6:  MOVF   xF2,F
2CA8:  BNZ   2D1A
2CAA:  MOVF   xF1,F
2CAC:  BNZ   2D1A
2CAE:  MOVF   xF0,F
2CB0:  BNZ   2D1A
2CB2:  MOVF   xEF,W
2CB4:  SUBLW  B3
2CB6:  BNC   2D1A
2CB8:  MOVF   xF2,F
2CBA:  BNZ   2CCA
2CBC:  MOVF   xF1,F
2CBE:  BNZ   2CCA
2CC0:  MOVF   xF0,F
2CC2:  BNZ   2CCA
2CC4:  MOVF   xEF,W
2CC6:  SUBLW  64
2CC8:  BC    2D1A
2CCA:  MOVF   xF6,F
2CCC:  BNZ   2D1A
2CCE:  MOVF   xF5,F
2CD0:  BNZ   2D1A
2CD2:  MOVF   xF4,F
2CD4:  BNZ   2D1A
2CD6:  MOVF   xF3,W
2CD8:  SUBLW  B3
2CDA:  BNC   2D1A
2CDC:  MOVF   xF6,F
2CDE:  BNZ   2CEE
2CE0:  MOVF   xF5,F
2CE2:  BNZ   2CEE
2CE4:  MOVF   xF4,F
2CE6:  BNZ   2CEE
2CE8:  MOVF   xF3,W
2CEA:  SUBLW  64
2CEC:  BC    2D1A
2CEE:  MOVF   xFA,F
2CF0:  BNZ   2D1A
2CF2:  MOVF   xF9,F
2CF4:  BNZ   2D1A
2CF6:  MOVF   xF8,F
2CF8:  BNZ   2D1A
2CFA:  MOVF   xF7,W
2CFC:  SUBLW  B3
2CFE:  BNC   2D1A
2D00:  MOVF   xFA,F
2D02:  BNZ   2D12
2D04:  MOVF   xF9,F
2D06:  BNZ   2D12
2D08:  MOVF   xF8,F
2D0A:  BNZ   2D12
2D0C:  MOVF   xF7,W
2D0E:  SUBLW  64
2D10:  BC    2D1A
2D12:  MOVLW  04
2D14:  MOVWF  01
2D16:  BRA    2D1E
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2D18:  BRA    2D1E
2D1A:  MOVLW  FF
2D1C:  MOVWF  01
.................... } 
2D1E:  MOVLB  0
2D20:  GOTO   35D8 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
2D24:  MOVLB  7
2D26:  CLRF   xEE
2D28:  CLRF   xED
2D2A:  CLRF   xEC
2D2C:  CLRF   xEB
2D2E:  CLRF   xF2
2D30:  CLRF   xF1
2D32:  CLRF   xF0
2D34:  CLRF   xEF
2D36:  CLRF   xF6
2D38:  CLRF   xF5
2D3A:  CLRF   xF4
2D3C:  CLRF   xF3
2D3E:  CLRF   xFA
2D40:  CLRF   xF9
2D42:  CLRF   xF8
2D44:  CLRF   xF7
2D46:  CLRF   xFE
2D48:  CLRF   xFD
2D4A:  CLRF   xFC
2D4C:  CLRF   xFB
2D4E:  MOVLB  8
2D50:  CLRF   x02
2D52:  CLRF   x01
2D54:  CLRF   x00
2D56:  MOVLB  7
2D58:  CLRF   xFF
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2D5A:  CLRF   xEA
2D5C:  CLRF   xE9
2D5E:  MOVF   xEA,W
2D60:  SUBLW  01
2D62:  BNC   2E12
2D64:  BNZ   2D6C
2D66:  MOVF   xE9,W
2D68:  SUBLW  F3
2D6A:  BNC   2E12
....................    { 
....................       col_0=read_col(0)+col_0; 
2D6C:  MOVLB  8
2D6E:  CLRF   x0E
2D70:  MOVLB  0
2D72:  CALL   248A
2D76:  MOVF   01,W
2D78:  MOVLB  7
2D7A:  ADDWF  xEB,F
2D7C:  MOVLW  00
2D7E:  ADDWFC xEC,F
2D80:  ADDWFC xED,F
2D82:  ADDWFC xEE,F
....................       col_1=read_col(1)+col_1; 
2D84:  MOVLW  01
2D86:  MOVLB  8
2D88:  MOVWF  x0E
2D8A:  MOVLB  0
2D8C:  CALL   248A
2D90:  MOVF   01,W
2D92:  MOVLB  7
2D94:  ADDWF  xEF,F
2D96:  MOVLW  00
2D98:  ADDWFC xF0,F
2D9A:  ADDWFC xF1,F
2D9C:  ADDWFC xF2,F
....................       col_2=read_col(2)+col_2; 
2D9E:  MOVLW  02
2DA0:  MOVLB  8
2DA2:  MOVWF  x0E
2DA4:  MOVLB  0
2DA6:  CALL   248A
2DAA:  MOVF   01,W
2DAC:  MOVLB  7
2DAE:  ADDWF  xF3,F
2DB0:  MOVLW  00
2DB2:  ADDWFC xF4,F
2DB4:  ADDWFC xF5,F
2DB6:  ADDWFC xF6,F
....................       col_3=read_col(3)+col_3; 
2DB8:  MOVLW  03
2DBA:  MOVLB  8
2DBC:  MOVWF  x0E
2DBE:  MOVLB  0
2DC0:  CALL   248A
2DC4:  MOVF   01,W
2DC6:  MOVLB  7
2DC8:  ADDWF  xF7,F
2DCA:  MOVLW  00
2DCC:  ADDWFC xF8,F
2DCE:  ADDWFC xF9,F
2DD0:  ADDWFC xFA,F
....................       col_4=read_col(4)+col_4; 
2DD2:  MOVLW  04
2DD4:  MOVLB  8
2DD6:  MOVWF  x0E
2DD8:  MOVLB  0
2DDA:  CALL   248A
2DDE:  MOVF   01,W
2DE0:  MOVLB  7
2DE2:  ADDWF  xFB,F
2DE4:  MOVLW  00
2DE6:  ADDWFC xFC,F
2DE8:  ADDWFC xFD,F
2DEA:  ADDWFC xFE,F
....................       col_5=read_col(5)+col_5; 
2DEC:  MOVLW  05
2DEE:  MOVLB  8
2DF0:  MOVWF  x0E
2DF2:  MOVLB  0
2DF4:  CALL   248A
2DF8:  MOVF   01,W
2DFA:  MOVLB  7
2DFC:  ADDWF  xFF,F
2DFE:  MOVLW  00
2E00:  MOVLB  8
2E02:  ADDWFC x00,F
2E04:  ADDWFC x01,F
2E06:  ADDWFC x02,F
....................    } 
2E08:  MOVLB  7
2E0A:  INCF   xE9,F
2E0C:  BTFSC  FD8.2
2E0E:  INCF   xEA,F
2E10:  BRA    2D5E
....................    col_0=col_0/500; 
2E12:  BCF    FD8.1
2E14:  MOVFF  7EE,81D
2E18:  MOVFF  7ED,81C
2E1C:  MOVFF  7EC,81B
2E20:  MOVFF  7EB,81A
2E24:  MOVLB  8
2E26:  CLRF   x21
2E28:  CLRF   x20
2E2A:  MOVLW  01
2E2C:  MOVWF  x1F
2E2E:  MOVLW  F4
2E30:  MOVWF  x1E
2E32:  MOVLB  0
2E34:  CALL   2598
2E38:  MOVFF  03,7EE
2E3C:  MOVFF  02,7ED
2E40:  MOVFF  01,7EC
2E44:  MOVFF  00,7EB
....................    col_1=col_1/500; 
2E48:  BCF    FD8.1
2E4A:  MOVFF  7F2,81D
2E4E:  MOVFF  7F1,81C
2E52:  MOVFF  7F0,81B
2E56:  MOVFF  7EF,81A
2E5A:  MOVLB  8
2E5C:  CLRF   x21
2E5E:  CLRF   x20
2E60:  MOVLW  01
2E62:  MOVWF  x1F
2E64:  MOVLW  F4
2E66:  MOVWF  x1E
2E68:  MOVLB  0
2E6A:  CALL   2598
2E6E:  MOVFF  03,7F2
2E72:  MOVFF  02,7F1
2E76:  MOVFF  01,7F0
2E7A:  MOVFF  00,7EF
....................    col_2=col_2/500; 
2E7E:  BCF    FD8.1
2E80:  MOVFF  7F6,81D
2E84:  MOVFF  7F5,81C
2E88:  MOVFF  7F4,81B
2E8C:  MOVFF  7F3,81A
2E90:  MOVLB  8
2E92:  CLRF   x21
2E94:  CLRF   x20
2E96:  MOVLW  01
2E98:  MOVWF  x1F
2E9A:  MOVLW  F4
2E9C:  MOVWF  x1E
2E9E:  MOVLB  0
2EA0:  CALL   2598
2EA4:  MOVFF  03,7F6
2EA8:  MOVFF  02,7F5
2EAC:  MOVFF  01,7F4
2EB0:  MOVFF  00,7F3
....................    col_3=col_3/500; 
2EB4:  BCF    FD8.1
2EB6:  MOVFF  7FA,81D
2EBA:  MOVFF  7F9,81C
2EBE:  MOVFF  7F8,81B
2EC2:  MOVFF  7F7,81A
2EC6:  MOVLB  8
2EC8:  CLRF   x21
2ECA:  CLRF   x20
2ECC:  MOVLW  01
2ECE:  MOVWF  x1F
2ED0:  MOVLW  F4
2ED2:  MOVWF  x1E
2ED4:  MOVLB  0
2ED6:  CALL   2598
2EDA:  MOVFF  03,7FA
2EDE:  MOVFF  02,7F9
2EE2:  MOVFF  01,7F8
2EE6:  MOVFF  00,7F7
....................    col_4=col_4/500; 
2EEA:  BCF    FD8.1
2EEC:  MOVFF  7FE,81D
2EF0:  MOVFF  7FD,81C
2EF4:  MOVFF  7FC,81B
2EF8:  MOVFF  7FB,81A
2EFC:  MOVLB  8
2EFE:  CLRF   x21
2F00:  CLRF   x20
2F02:  MOVLW  01
2F04:  MOVWF  x1F
2F06:  MOVLW  F4
2F08:  MOVWF  x1E
2F0A:  MOVLB  0
2F0C:  CALL   2598
2F10:  MOVFF  03,7FE
2F14:  MOVFF  02,7FD
2F18:  MOVFF  01,7FC
2F1C:  MOVFF  00,7FB
....................    col_5=col_5/500; 
2F20:  BCF    FD8.1
2F22:  MOVFF  802,81D
2F26:  MOVFF  801,81C
2F2A:  MOVFF  800,81B
2F2E:  MOVFF  7FF,81A
2F32:  MOVLB  8
2F34:  CLRF   x21
2F36:  CLRF   x20
2F38:  MOVLW  01
2F3A:  MOVWF  x1F
2F3C:  MOVLW  F4
2F3E:  MOVWF  x1E
2F40:  MOVLB  0
2F42:  CALL   2598
2F46:  MOVFF  03,802
2F4A:  MOVFF  02,801
2F4E:  MOVFF  01,800
2F52:  MOVFF  00,7FF
....................    if(keydebug_en) 
2F56:  MOVLB  1
2F58:  MOVF   x0B,F
2F5A:  BTFSC  FD8.2
2F5C:  BRA    3126
....................    { 
....................       fprintf(COM2,"\r\n");      
2F5E:  MOVLW  0D
2F60:  MOVLB  8
2F62:  MOVWF  x1A
2F64:  MOVLB  0
2F66:  CALL   043A
2F6A:  MOVLW  0A
2F6C:  MOVLB  8
2F6E:  MOVWF  x1A
2F70:  MOVLB  0
2F72:  CALL   043A
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2F76:  MOVLW  C4
2F78:  MOVWF  FF6
2F7A:  MOVLW  02
2F7C:  MOVWF  FF7
2F7E:  MOVLW  07
2F80:  MOVLB  8
2F82:  MOVWF  x0E
2F84:  MOVLB  0
2F86:  CALL   187C
2F8A:  MOVLW  41
2F8C:  MOVWF  FE9
2F8E:  MOVFF  7EE,811
2F92:  MOVFF  7ED,810
2F96:  MOVFF  7EC,80F
2F9A:  MOVFF  7EB,80E
2F9E:  CALL   262C
2FA2:  MOVLW  0D
2FA4:  MOVLB  8
2FA6:  MOVWF  x1A
2FA8:  MOVLB  0
2FAA:  CALL   043A
2FAE:  MOVLW  0A
2FB0:  MOVLB  8
2FB2:  MOVWF  x1A
2FB4:  MOVLB  0
2FB6:  CALL   043A
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2FBA:  MOVLW  D2
2FBC:  MOVWF  FF6
2FBE:  MOVLW  02
2FC0:  MOVWF  FF7
2FC2:  MOVLW  07
2FC4:  MOVLB  8
2FC6:  MOVWF  x0E
2FC8:  MOVLB  0
2FCA:  CALL   187C
2FCE:  MOVLW  41
2FD0:  MOVWF  FE9
2FD2:  MOVFF  7F2,811
2FD6:  MOVFF  7F1,810
2FDA:  MOVFF  7F0,80F
2FDE:  MOVFF  7EF,80E
2FE2:  CALL   262C
2FE6:  MOVLW  0D
2FE8:  MOVLB  8
2FEA:  MOVWF  x1A
2FEC:  MOVLB  0
2FEE:  CALL   043A
2FF2:  MOVLW  0A
2FF4:  MOVLB  8
2FF6:  MOVWF  x1A
2FF8:  MOVLB  0
2FFA:  CALL   043A
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2FFE:  MOVLW  E0
3000:  MOVWF  FF6
3002:  MOVLW  02
3004:  MOVWF  FF7
3006:  MOVLW  07
3008:  MOVLB  8
300A:  MOVWF  x0E
300C:  MOVLB  0
300E:  CALL   187C
3012:  MOVLW  41
3014:  MOVWF  FE9
3016:  MOVFF  7F6,811
301A:  MOVFF  7F5,810
301E:  MOVFF  7F4,80F
3022:  MOVFF  7F3,80E
3026:  CALL   262C
302A:  MOVLW  0D
302C:  MOVLB  8
302E:  MOVWF  x1A
3030:  MOVLB  0
3032:  CALL   043A
3036:  MOVLW  0A
3038:  MOVLB  8
303A:  MOVWF  x1A
303C:  MOVLB  0
303E:  CALL   043A
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
3042:  MOVLW  EE
3044:  MOVWF  FF6
3046:  MOVLW  02
3048:  MOVWF  FF7
304A:  MOVLW  07
304C:  MOVLB  8
304E:  MOVWF  x0E
3050:  MOVLB  0
3052:  CALL   187C
3056:  MOVLW  41
3058:  MOVWF  FE9
305A:  MOVFF  7FA,811
305E:  MOVFF  7F9,810
3062:  MOVFF  7F8,80F
3066:  MOVFF  7F7,80E
306A:  CALL   262C
306E:  MOVLW  0D
3070:  MOVLB  8
3072:  MOVWF  x1A
3074:  MOVLB  0
3076:  CALL   043A
307A:  MOVLW  0A
307C:  MOVLB  8
307E:  MOVWF  x1A
3080:  MOVLB  0
3082:  CALL   043A
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
3086:  MOVLW  FC
3088:  MOVWF  FF6
308A:  MOVLW  02
308C:  MOVWF  FF7
308E:  MOVLW  07
3090:  MOVLB  8
3092:  MOVWF  x0E
3094:  MOVLB  0
3096:  CALL   187C
309A:  MOVLW  41
309C:  MOVWF  FE9
309E:  MOVFF  7FE,811
30A2:  MOVFF  7FD,810
30A6:  MOVFF  7FC,80F
30AA:  MOVFF  7FB,80E
30AE:  CALL   262C
30B2:  MOVLW  0D
30B4:  MOVLB  8
30B6:  MOVWF  x1A
30B8:  MOVLB  0
30BA:  CALL   043A
30BE:  MOVLW  0A
30C0:  MOVLB  8
30C2:  MOVWF  x1A
30C4:  MOVLB  0
30C6:  CALL   043A
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
30CA:  MOVLW  0A
30CC:  MOVWF  FF6
30CE:  MOVLW  03
30D0:  MOVWF  FF7
30D2:  MOVLW  07
30D4:  MOVLB  8
30D6:  MOVWF  x0E
30D8:  MOVLB  0
30DA:  CALL   187C
30DE:  MOVLW  41
30E0:  MOVWF  FE9
30E2:  MOVFF  802,811
30E6:  MOVFF  801,810
30EA:  MOVFF  800,80F
30EE:  MOVFF  7FF,80E
30F2:  CALL   262C
30F6:  MOVLW  0D
30F8:  MOVLB  8
30FA:  MOVWF  x1A
30FC:  MOVLB  0
30FE:  CALL   043A
3102:  MOVLW  0A
3104:  MOVLB  8
3106:  MOVWF  x1A
3108:  MOVLB  0
310A:  CALL   043A
....................       fprintf(COM2,"\r\n"); 
310E:  MOVLW  0D
3110:  MOVLB  8
3112:  MOVWF  x1A
3114:  MOVLB  0
3116:  CALL   043A
311A:  MOVLW  0A
311C:  MOVLB  8
311E:  MOVWF  x1A
3120:  MOVLB  0
3122:  CALL   043A
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
3126:  MOVLB  7
3128:  MOVF   xEE,F
312A:  BNZ   313A
312C:  MOVF   xED,F
312E:  BNZ   313A
3130:  MOVF   xEC,F
3132:  BNZ   313A
3134:  MOVF   xEB,W
3136:  SUBLW  05
3138:  BC    31B4
313A:  MOVF   xEE,F
313C:  BNZ   31B4
313E:  MOVF   xED,F
3140:  BNZ   31B4
3142:  MOVF   xEC,F
3144:  BNZ   31B4
3146:  MOVF   xEB,W
3148:  SUBLW  3B
314A:  BNC   31B4
314C:  MOVF   xF2,F
314E:  BNZ   315E
3150:  MOVF   xF1,F
3152:  BNZ   315E
3154:  MOVF   xF0,F
3156:  BNZ   315E
3158:  MOVF   xEF,W
315A:  SUBLW  64
315C:  BC    31B4
315E:  MOVF   xF6,F
3160:  BNZ   3170
3162:  MOVF   xF5,F
3164:  BNZ   3170
3166:  MOVF   xF4,F
3168:  BNZ   3170
316A:  MOVF   xF3,W
316C:  SUBLW  64
316E:  BC    31B4
3170:  MOVF   xFA,F
3172:  BNZ   3182
3174:  MOVF   xF9,F
3176:  BNZ   3182
3178:  MOVF   xF8,F
317A:  BNZ   3182
317C:  MOVF   xF7,W
317E:  SUBLW  64
3180:  BC    31B4
3182:  MOVF   xFE,F
3184:  BNZ   3194
3186:  MOVF   xFD,F
3188:  BNZ   3194
318A:  MOVF   xFC,F
318C:  BNZ   3194
318E:  MOVF   xFB,W
3190:  SUBLW  64
3192:  BC    31B4
3194:  MOVLB  8
3196:  MOVF   x02,F
3198:  BNZ   31AC
319A:  MOVF   x01,F
319C:  BNZ   31AC
319E:  MOVF   x00,F
31A0:  BNZ   31AC
31A2:  MOVLB  7
31A4:  MOVF   xFF,W
31A6:  SUBLW  64
31A8:  BC    31B4
31AA:  MOVLB  8
31AC:  MOVLW  00
31AE:  MOVWF  01
31B0:  BRA    3574
31B2:  MOVLB  7
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
31B4:  MOVF   xF2,F
31B6:  BNZ   31C6
31B8:  MOVF   xF1,F
31BA:  BNZ   31C6
31BC:  MOVF   xF0,F
31BE:  BNZ   31C6
31C0:  MOVF   xEF,W
31C2:  SUBLW  05
31C4:  BC    3240
31C6:  MOVF   xF2,F
31C8:  BNZ   3240
31CA:  MOVF   xF1,F
31CC:  BNZ   3240
31CE:  MOVF   xF0,F
31D0:  BNZ   3240
31D2:  MOVF   xEF,W
31D4:  SUBLW  3B
31D6:  BNC   3240
31D8:  MOVF   xEE,F
31DA:  BNZ   31EA
31DC:  MOVF   xED,F
31DE:  BNZ   31EA
31E0:  MOVF   xEC,F
31E2:  BNZ   31EA
31E4:  MOVF   xEB,W
31E6:  SUBLW  64
31E8:  BC    3240
31EA:  MOVF   xF6,F
31EC:  BNZ   31FC
31EE:  MOVF   xF5,F
31F0:  BNZ   31FC
31F2:  MOVF   xF4,F
31F4:  BNZ   31FC
31F6:  MOVF   xF3,W
31F8:  SUBLW  64
31FA:  BC    3240
31FC:  MOVF   xFA,F
31FE:  BNZ   320E
3200:  MOVF   xF9,F
3202:  BNZ   320E
3204:  MOVF   xF8,F
3206:  BNZ   320E
3208:  MOVF   xF7,W
320A:  SUBLW  64
320C:  BC    3240
320E:  MOVF   xFE,F
3210:  BNZ   3220
3212:  MOVF   xFD,F
3214:  BNZ   3220
3216:  MOVF   xFC,F
3218:  BNZ   3220
321A:  MOVF   xFB,W
321C:  SUBLW  64
321E:  BC    3240
3220:  MOVLB  8
3222:  MOVF   x02,F
3224:  BNZ   3238
3226:  MOVF   x01,F
3228:  BNZ   3238
322A:  MOVF   x00,F
322C:  BNZ   3238
322E:  MOVLB  7
3230:  MOVF   xFF,W
3232:  SUBLW  64
3234:  BC    3240
3236:  MOVLB  8
3238:  MOVLW  01
323A:  MOVWF  01
323C:  BRA    3574
323E:  MOVLB  7
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
3240:  MOVF   xF6,F
3242:  BNZ   3252
3244:  MOVF   xF5,F
3246:  BNZ   3252
3248:  MOVF   xF4,F
324A:  BNZ   3252
324C:  MOVF   xF3,W
324E:  SUBLW  05
3250:  BC    32CC
3252:  MOVF   xF6,F
3254:  BNZ   32CC
3256:  MOVF   xF5,F
3258:  BNZ   32CC
325A:  MOVF   xF4,F
325C:  BNZ   32CC
325E:  MOVF   xF3,W
3260:  SUBLW  3B
3262:  BNC   32CC
3264:  MOVF   xF2,F
3266:  BNZ   3276
3268:  MOVF   xF1,F
326A:  BNZ   3276
326C:  MOVF   xF0,F
326E:  BNZ   3276
3270:  MOVF   xEF,W
3272:  SUBLW  64
3274:  BC    32CC
3276:  MOVF   xEE,F
3278:  BNZ   3288
327A:  MOVF   xED,F
327C:  BNZ   3288
327E:  MOVF   xEC,F
3280:  BNZ   3288
3282:  MOVF   xEB,W
3284:  SUBLW  64
3286:  BC    32CC
3288:  MOVF   xFA,F
328A:  BNZ   329A
328C:  MOVF   xF9,F
328E:  BNZ   329A
3290:  MOVF   xF8,F
3292:  BNZ   329A
3294:  MOVF   xF7,W
3296:  SUBLW  64
3298:  BC    32CC
329A:  MOVF   xFE,F
329C:  BNZ   32AC
329E:  MOVF   xFD,F
32A0:  BNZ   32AC
32A2:  MOVF   xFC,F
32A4:  BNZ   32AC
32A6:  MOVF   xFB,W
32A8:  SUBLW  64
32AA:  BC    32CC
32AC:  MOVLB  8
32AE:  MOVF   x02,F
32B0:  BNZ   32C4
32B2:  MOVF   x01,F
32B4:  BNZ   32C4
32B6:  MOVF   x00,F
32B8:  BNZ   32C4
32BA:  MOVLB  7
32BC:  MOVF   xFF,W
32BE:  SUBLW  64
32C0:  BC    32CC
32C2:  MOVLB  8
32C4:  MOVLW  02
32C6:  MOVWF  01
32C8:  BRA    3574
32CA:  MOVLB  7
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
32CC:  MOVF   xFA,F
32CE:  BNZ   32DE
32D0:  MOVF   xF9,F
32D2:  BNZ   32DE
32D4:  MOVF   xF8,F
32D6:  BNZ   32DE
32D8:  MOVF   xF7,W
32DA:  SUBLW  05
32DC:  BC    3358
32DE:  MOVF   xFA,F
32E0:  BNZ   3358
32E2:  MOVF   xF9,F
32E4:  BNZ   3358
32E6:  MOVF   xF8,F
32E8:  BNZ   3358
32EA:  MOVF   xF7,W
32EC:  SUBLW  3B
32EE:  BNC   3358
32F0:  MOVF   xF2,F
32F2:  BNZ   3302
32F4:  MOVF   xF1,F
32F6:  BNZ   3302
32F8:  MOVF   xF0,F
32FA:  BNZ   3302
32FC:  MOVF   xEF,W
32FE:  SUBLW  64
3300:  BC    3358
3302:  MOVF   xF6,F
3304:  BNZ   3314
3306:  MOVF   xF5,F
3308:  BNZ   3314
330A:  MOVF   xF4,F
330C:  BNZ   3314
330E:  MOVF   xF3,W
3310:  SUBLW  64
3312:  BC    3358
3314:  MOVF   xEE,F
3316:  BNZ   3326
3318:  MOVF   xED,F
331A:  BNZ   3326
331C:  MOVF   xEC,F
331E:  BNZ   3326
3320:  MOVF   xEB,W
3322:  SUBLW  64
3324:  BC    3358
3326:  MOVF   xFE,F
3328:  BNZ   3338
332A:  MOVF   xFD,F
332C:  BNZ   3338
332E:  MOVF   xFC,F
3330:  BNZ   3338
3332:  MOVF   xFB,W
3334:  SUBLW  64
3336:  BC    3358
3338:  MOVLB  8
333A:  MOVF   x02,F
333C:  BNZ   3350
333E:  MOVF   x01,F
3340:  BNZ   3350
3342:  MOVF   x00,F
3344:  BNZ   3350
3346:  MOVLB  7
3348:  MOVF   xFF,W
334A:  SUBLW  64
334C:  BC    3358
334E:  MOVLB  8
3350:  MOVLW  03
3352:  MOVWF  01
3354:  BRA    3574
3356:  MOVLB  7
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
3358:  MOVF   xFE,F
335A:  BNZ   336A
335C:  MOVF   xFD,F
335E:  BNZ   336A
3360:  MOVF   xFC,F
3362:  BNZ   336A
3364:  MOVF   xFB,W
3366:  SUBLW  05
3368:  BC    33E2
336A:  MOVF   xFE,F
336C:  BNZ   33E2
336E:  MOVF   xFD,F
3370:  BNZ   33E2
3372:  MOVF   xFC,F
3374:  BNZ   33E2
3376:  MOVF   xFB,W
3378:  SUBLW  3B
337A:  BNC   33E2
337C:  MOVF   xF2,F
337E:  BNZ   338E
3380:  MOVF   xF1,F
3382:  BNZ   338E
3384:  MOVF   xF0,F
3386:  BNZ   338E
3388:  MOVF   xEF,W
338A:  SUBLW  64
338C:  BC    33E2
338E:  MOVF   xF6,F
3390:  BNZ   33A0
3392:  MOVF   xF5,F
3394:  BNZ   33A0
3396:  MOVF   xF4,F
3398:  BNZ   33A0
339A:  MOVF   xF3,W
339C:  SUBLW  64
339E:  BC    33E2
33A0:  MOVF   xFA,F
33A2:  BNZ   33B2
33A4:  MOVF   xF9,F
33A6:  BNZ   33B2
33A8:  MOVF   xF8,F
33AA:  BNZ   33B2
33AC:  MOVF   xF7,W
33AE:  SUBLW  64
33B0:  BC    33E2
33B2:  MOVF   xEE,F
33B4:  BNZ   33C4
33B6:  MOVF   xED,F
33B8:  BNZ   33C4
33BA:  MOVF   xEC,F
33BC:  BNZ   33C4
33BE:  MOVF   xEB,W
33C0:  SUBLW  64
33C2:  BC    33E2
33C4:  MOVLB  8
33C6:  MOVF   x02,F
33C8:  BNZ   33DC
33CA:  MOVF   x01,F
33CC:  BNZ   33DC
33CE:  MOVF   x00,F
33D0:  BNZ   33DC
33D2:  MOVLB  7
33D4:  MOVF   xFF,W
33D6:  SUBLW  64
33D8:  BC    33E2
33DA:  MOVLB  8
33DC:  MOVLW  04
33DE:  MOVWF  01
33E0:  BRA    3574
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
33E2:  MOVLB  8
33E4:  MOVF   x02,F
33E6:  BNZ   33FA
33E8:  MOVF   x01,F
33EA:  BNZ   33FA
33EC:  MOVF   x00,F
33EE:  BNZ   33FA
33F0:  MOVLB  7
33F2:  MOVF   xFF,W
33F4:  SUBLW  05
33F6:  BC    3482
33F8:  MOVLB  8
33FA:  MOVF   x02,F
33FC:  BTFSC  FD8.2
33FE:  BRA    3404
3400:  MOVLB  7
3402:  BRA    3482
3404:  MOVF   x01,F
3406:  BTFSC  FD8.2
3408:  BRA    340E
340A:  MOVLB  7
340C:  BRA    3482
340E:  MOVF   x00,F
3410:  BTFSC  FD8.2
3412:  BRA    3418
3414:  MOVLB  7
3416:  BRA    3482
3418:  MOVLB  7
341A:  MOVF   xFF,W
341C:  SUBLW  3B
341E:  BNC   3482
3420:  MOVF   xF2,F
3422:  BNZ   3432
3424:  MOVF   xF1,F
3426:  BNZ   3432
3428:  MOVF   xF0,F
342A:  BNZ   3432
342C:  MOVF   xEF,W
342E:  SUBLW  64
3430:  BC    3482
3432:  MOVF   xF6,F
3434:  BNZ   3444
3436:  MOVF   xF5,F
3438:  BNZ   3444
343A:  MOVF   xF4,F
343C:  BNZ   3444
343E:  MOVF   xF3,W
3440:  SUBLW  64
3442:  BC    3482
3444:  MOVF   xFA,F
3446:  BNZ   3456
3448:  MOVF   xF9,F
344A:  BNZ   3456
344C:  MOVF   xF8,F
344E:  BNZ   3456
3450:  MOVF   xF7,W
3452:  SUBLW  64
3454:  BC    3482
3456:  MOVF   xFE,F
3458:  BNZ   3468
345A:  MOVF   xFD,F
345C:  BNZ   3468
345E:  MOVF   xFC,F
3460:  BNZ   3468
3462:  MOVF   xFB,W
3464:  SUBLW  64
3466:  BC    3482
3468:  MOVF   xEE,F
346A:  BNZ   347A
346C:  MOVF   xED,F
346E:  BNZ   347A
3470:  MOVF   xEC,F
3472:  BNZ   347A
3474:  MOVF   xEB,W
3476:  SUBLW  64
3478:  BC    3482
347A:  MOVLW  05
347C:  MOVWF  01
347E:  MOVLB  8
3480:  BRA    3574
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
3482:  MOVLB  8
3484:  MOVF   x02,F
3486:  BNZ   349A
3488:  MOVF   x01,F
348A:  BNZ   349A
348C:  MOVF   x00,F
348E:  BNZ   349A
3490:  MOVLB  7
3492:  MOVF   xFF,W
3494:  SUBLW  C8
3496:  BTFSC  FD8.0
3498:  BRA    356E
349A:  MOVLB  7
349C:  MOVF   xEE,F
349E:  BTFSS  FD8.2
34A0:  BRA    356E
34A2:  MOVF   xED,F
34A4:  BTFSS  FD8.2
34A6:  BRA    356E
34A8:  MOVF   xEC,F
34AA:  BTFSS  FD8.2
34AC:  BRA    356E
34AE:  MOVF   xEB,W
34B0:  SUBLW  B3
34B2:  BTFSS  FD8.0
34B4:  BRA    356E
34B6:  MOVF   xEE,F
34B8:  BNZ   34CA
34BA:  MOVF   xED,F
34BC:  BNZ   34CA
34BE:  MOVF   xEC,F
34C0:  BNZ   34CA
34C2:  MOVF   xEB,W
34C4:  SUBLW  64
34C6:  BTFSC  FD8.0
34C8:  BRA    356E
34CA:  MOVF   xF2,F
34CC:  BTFSS  FD8.2
34CE:  BRA    356E
34D0:  MOVF   xF1,F
34D2:  BTFSS  FD8.2
34D4:  BRA    356E
34D6:  MOVF   xF0,F
34D8:  BTFSS  FD8.2
34DA:  BRA    356E
34DC:  MOVF   xEF,W
34DE:  SUBLW  B3
34E0:  BTFSS  FD8.0
34E2:  BRA    356E
34E4:  MOVF   xF2,F
34E6:  BNZ   34F6
34E8:  MOVF   xF1,F
34EA:  BNZ   34F6
34EC:  MOVF   xF0,F
34EE:  BNZ   34F6
34F0:  MOVF   xEF,W
34F2:  SUBLW  64
34F4:  BC    356E
34F6:  MOVF   xF6,F
34F8:  BNZ   356E
34FA:  MOVF   xF5,F
34FC:  BNZ   356E
34FE:  MOVF   xF4,F
3500:  BNZ   356E
3502:  MOVF   xF3,W
3504:  SUBLW  B3
3506:  BNC   356E
3508:  MOVF   xF6,F
350A:  BNZ   351A
350C:  MOVF   xF5,F
350E:  BNZ   351A
3510:  MOVF   xF4,F
3512:  BNZ   351A
3514:  MOVF   xF3,W
3516:  SUBLW  64
3518:  BC    356E
351A:  MOVF   xFA,F
351C:  BNZ   356E
351E:  MOVF   xF9,F
3520:  BNZ   356E
3522:  MOVF   xF8,F
3524:  BNZ   356E
3526:  MOVF   xF7,W
3528:  SUBLW  B3
352A:  BNC   356E
352C:  MOVF   xFA,F
352E:  BNZ   353E
3530:  MOVF   xF9,F
3532:  BNZ   353E
3534:  MOVF   xF8,F
3536:  BNZ   353E
3538:  MOVF   xF7,W
353A:  SUBLW  64
353C:  BC    356E
353E:  MOVF   xFE,F
3540:  BNZ   356E
3542:  MOVF   xFD,F
3544:  BNZ   356E
3546:  MOVF   xFC,F
3548:  BNZ   356E
354A:  MOVF   xFB,W
354C:  SUBLW  B3
354E:  BNC   356E
3550:  MOVF   xFE,F
3552:  BNZ   3562
3554:  MOVF   xFD,F
3556:  BNZ   3562
3558:  MOVF   xFC,F
355A:  BNZ   3562
355C:  MOVF   xFB,W
355E:  SUBLW  64
3560:  BC    356E
3562:  MOVLW  05
3564:  MOVWF  01
3566:  MOVLB  8
3568:  BRA    3574
....................    else return 0xff; 
356A:  BRA    3574
356C:  MOVLB  7
356E:  MOVLW  FF
3570:  MOVWF  01
3572:  MOVLB  8
.................... } 
3574:  MOVLB  0
3576:  GOTO   35E4 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
357A:  BSF    F93.4
357C:  BTFSS  F81.4
357E:  BRA    3592
3580:  BSF    F93.5
3582:  BTFSS  F81.5
3584:  BRA    3592
3586:  BSF    F93.6
3588:  BTFSS  F81.6
358A:  BRA    3592
358C:  BSF    F93.7
358E:  BTFSC  F81.7
3590:  BRA    370C
....................     { 
....................        if(input(ROW0)==0) 
3592:  BSF    F93.4
3594:  BTFSC  F81.4
3596:  BRA    35A0
....................          row=0; 
3598:  MOVLB  7
359A:  CLRF   xE8
....................        else if(input(ROW1)==0) 
359C:  BRA    35CC
359E:  MOVLB  0
35A0:  BSF    F93.5
35A2:  BTFSC  F81.5
35A4:  BRA    35B0
....................          row=1; 
35A6:  MOVLW  01
35A8:  MOVLB  7
35AA:  MOVWF  xE8
....................        else if(input(ROW2)==0) 
35AC:  BRA    35CC
35AE:  MOVLB  0
35B0:  BSF    F93.6
35B2:  BTFSC  F81.6
35B4:  BRA    35C0
....................          row=2; 
35B6:  MOVLW  02
35B8:  MOVLB  7
35BA:  MOVWF  xE8
....................        else if(input(ROW3)==0) 
35BC:  BRA    35CC
35BE:  MOVLB  0
35C0:  BSF    F93.7
35C2:  BTFSC  F81.7
35C4:  BRA    35CC
....................          row=3;      
35C6:  MOVLW  03
35C8:  MOVLB  7
35CA:  MOVWF  xE8
....................        if(type_KB==0)col=check_col(); 
35CC:  MOVLB  1
35CE:  MOVF   x13,F
35D0:  BNZ   35DE
35D2:  MOVLB  0
35D4:  GOTO   26EC
35D8:  MOVFF  01,7E6
....................          else col=new_check_col(); 
35DC:  BRA    35E8
35DE:  MOVLB  0
35E0:  GOTO   2D24
35E4:  MOVFF  01,7E6
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
35E8:  MOVLB  7
35EA:  INCFSZ xE6,W
35EC:  BRA    35F0
35EE:  BRA    36DA
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
35F0:  MOVLB  1
35F2:  MOVF   x13,F
35F4:  BNZ   361C
35F6:  MOVLB  7
35F8:  MOVF   xE8,W
35FA:  MULLW  05
35FC:  MOVF   FF3,W
35FE:  CLRF   xEA
3600:  MOVWF  xE9
3602:  CLRF   03
3604:  MOVF   xE6,W
3606:  ADDWF  xE9,W
3608:  MOVWF  01
360A:  MOVF   xEA,W
360C:  ADDWFC 03,F
360E:  MOVF   01,W
3610:  MOVLB  0
3612:  CALL   00D0
3616:  MOVFF  FE8,7E7
....................            else kchar =newKEYS[row][col]; 
361A:  BRA    3640
361C:  MOVLB  7
361E:  MOVF   xE8,W
3620:  MULLW  06
3622:  MOVF   FF3,W
3624:  CLRF   xEA
3626:  MOVWF  xE9
3628:  CLRF   03
362A:  MOVF   xE6,W
362C:  ADDWF  xE9,W
362E:  MOVWF  01
3630:  MOVF   xEA,W
3632:  ADDWFC 03,F
3634:  MOVF   01,W
3636:  MOVLB  0
3638:  CALL   00F4
363C:  MOVFF  FE8,7E7
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
3640:  MOVLB  1
3642:  MOVF   x0B,F
3644:  BNZ   36CC
....................             { 
....................               charac_timeout=0; 
3646:  MOVLB  0
3648:  CLRF   xFC
364A:  CLRF   xFB
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
364C:  MOVLB  1
364E:  MOVF   x0E,W
3650:  SUBLW  0F
3652:  BNC   3668
3654:  MOVF   x0E,W
3656:  INCF   x0E,F
3658:  CLRF   03
365A:  ADDLW  14
365C:  MOVWF  FE9
365E:  MOVLW  01
3660:  ADDWFC 03,W
3662:  MOVWF  FEA
3664:  MOVFF  7E7,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
3668:  MOVLW  18
366A:  MOVWF  FF6
366C:  MOVLW  03
366E:  MOVWF  FF7
3670:  MOVLW  09
3672:  MOVLB  8
3674:  MOVWF  x0E
3676:  MOVLB  0
3678:  CALL   187C
367C:  MOVFF  10E,7EF
3680:  MOVLW  18
3682:  MOVLB  7
3684:  MOVWF  xF0
3686:  MOVLB  0
3688:  CALL   1990
368C:  MOVLW  5D
368E:  MOVLB  8
3690:  MOVWF  x1A
3692:  MOVLB  0
3694:  CALL   043A
3698:  MOVLW  20
369A:  MOVLB  8
369C:  MOVWF  x1A
369E:  MOVLB  0
36A0:  CALL   043A
36A4:  MOVFF  7E7,81A
36A8:  CALL   043A
36AC:  MOVLW  0D
36AE:  MOVLB  8
36B0:  MOVWF  x1A
36B2:  MOVLB  0
36B4:  CALL   043A
36B8:  MOVLW  0A
36BA:  MOVLB  8
36BC:  MOVWF  x1A
36BE:  MOVLB  0
36C0:  CALL   043A
....................                count_checking=0; 
36C4:  MOVLB  1
36C6:  CLRF   x07
36C8:  CLRF   x06
....................             } 
....................                else fputc(kchar,COM2); 
36CA:  BRA    36D8
36CC:  MOVFF  7E7,81A
36D0:  MOVLB  0
36D2:  CALL   043A
36D6:  MOVLB  1
36D8:  MOVLB  7
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
36DA:  BSF    F93.4
36DC:  BTFSS  F81.4
36DE:  BRA    36DA
36E0:  BSF    F93.5
36E2:  BTFSS  F81.5
36E4:  BRA    36DA
36E6:  BSF    F93.6
36E8:  BTFSS  F81.6
36EA:  BRA    36DA
36EC:  BSF    F93.7
36EE:  BTFSS  F81.7
36F0:  BRA    36DA
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
36F2:  BSF    F93.4
36F4:  BTFSS  F81.4
36F6:  BRA    36F2
36F8:  BSF    F93.5
36FA:  BTFSS  F81.5
36FC:  BRA    36F2
36FE:  BSF    F93.6
3700:  BTFSS  F81.6
3702:  BRA    36F2
3704:  BSF    F93.7
3706:  BTFSS  F81.7
3708:  BRA    36F2
370A:  MOVLB  0
....................     } 
....................   set_tris_a(0xff);     
370C:  MOVLW  FF
370E:  MOVWF  F92
....................   return(kchar); 
3710:  MOVLB  7
3712:  MOVFF  7E7,01
.................... }//*/ 
3716:  MOVLB  0
3718:  RETURN 0
.................... //============================================ 
....................  
.................... //=========================== 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
4494:  MOVF   27,F
4496:  BTFSS  FD8.2
4498:  BRA    4672
449A:  MOVF   26,W
449C:  SUBLW  01
449E:  BTFSS  FD8.0
44A0:  BRA    4672
44A2:  BNZ   44B6
44A4:  MOVF   25,W
44A6:  SUBLW  FF
44A8:  BTFSS  FD8.0
44AA:  BRA    4672
44AC:  BNZ   44B6
44AE:  MOVF   24,W
44B0:  SUBLW  FE
44B2:  BTFSS  FD8.0
44B4:  BRA    4672
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)) 
44B6:  MOVLB  1
44B8:  MOVF   x14,F
44BA:  BTFSC  FD8.2
44BC:  BRA    4620
....................       { 
....................          temp=get_countcard(); 
44BE:  MOVLB  0
44C0:  CALL   38C6
44C4:  MOVFF  02,7E8
44C8:  MOVFF  01,7E7
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
44CC:  MOVLB  7
44CE:  RLCF   xE7,W
44D0:  MOVWF  xE9
44D2:  RLCF   xE8,W
44D4:  MOVWF  xEA
44D6:  RLCF   xE9,F
44D8:  RLCF   xEA,F
44DA:  RLCF   xE9,F
44DC:  RLCF   xEA,F
44DE:  RLCF   xE9,F
44E0:  RLCF   xEA,F
44E2:  MOVLW  F0
44E4:  ANDWF  xE9,F
44E6:  MOVLW  0E
44E8:  ADDWF  xE9,F
44EA:  MOVLW  C3
44EC:  ADDWFC xEA,F
44EE:  MOVLW  01
44F0:  MOVWF  xEB
44F2:  BCF    FD8.2
44F4:  BTFSC  FD8.0
44F6:  INCF   xEB,F
44F8:  CLRF   xEC
44FA:  MOVLW  01
44FC:  ADDWF  xE9,W
44FE:  MOVWF  00
4500:  MOVLW  00
4502:  ADDWFC xEA,W
4504:  MOVWF  01
4506:  MOVLW  00
4508:  ADDWFC xEB,W
450A:  MOVWF  02
450C:  MOVLW  00
450E:  ADDWFC xEC,W
4510:  MOVWF  27
4512:  MOVFF  02,26
4516:  MOVFF  01,25
451A:  MOVFF  00,24
....................           //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<key_numbyte;i++) 
451E:  CLRF   xE6
4520:  MOVF   xE6,W
4522:  SUBLW  0F
4524:  BNC   4590
....................          { 
....................             temp=key_data[i]; 
4526:  CLRF   03
4528:  MOVF   xE6,W
452A:  ADDLW  14
452C:  MOVWF  FE9
452E:  MOVLW  01
4530:  ADDWFC 03,W
4532:  MOVWF  FEA
4534:  CLRF   xE8
4536:  MOVFF  FEF,7E7
....................             write_ext_eeprom((int32)ptr_card_key++,temp); 
453A:  MOVFF  27,03
453E:  MOVFF  26,02
4542:  MOVFF  25,01
4546:  MOVFF  24,00
454A:  MOVLW  01
454C:  ADDWF  24,F
454E:  BTFSC  FD8.0
4550:  INCF   25,F
4552:  BTFSC  FD8.2
4554:  INCF   26,F
4556:  BTFSC  FD8.2
4558:  INCF   27,F
455A:  MOVFF  03,7EC
455E:  MOVFF  02,7EB
4562:  MOVFF  01,7EA
4566:  MOVFF  00,7E9
456A:  MOVFF  03,805
456E:  MOVFF  02,804
4572:  MOVFF  01,803
4576:  MOVFF  00,802
457A:  MOVFF  7E7,806
457E:  MOVLB  0
4580:  RCALL  3D9A
....................             //delay_us(100); 
....................             fputc(temp,COM2); 
4582:  MOVFF  7E7,81A
4586:  CALL   043A
....................          } 
458A:  MOVLB  7
458C:  INCF   xE6,F
458E:  BRA    4520
....................          /*fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<key_numbyte;i++) 
....................           { 
....................             fprintf(COM2,"read key=%c\n\r",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          write_ext_eeprom((long int)ptr_card_key,0); 
4590:  MOVLB  8
4592:  CLRF   x05
4594:  CLRF   x04
4596:  MOVFF  25,803
459A:  MOVFF  24,802
459E:  CLRF   x06
45A0:  MOVLB  0
45A2:  CALL   3D9A
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
45A6:  MOVFF  27,7EC
45AA:  MOVFF  26,7EB
45AE:  MOVFF  25,7EA
45B2:  MOVFF  24,7E9
45B6:  MOVLW  1E
45B8:  MOVLB  7
45BA:  MOVWF  xED
45BC:  MOVLB  0
45BE:  RCALL  3E98
....................          fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
45C0:  MOVLW  1E
45C2:  MOVLB  7
45C4:  MOVWF  xE9
45C6:  MOVLB  0
45C8:  RCALL  4356
45CA:  MOVFF  03,7EC
45CE:  MOVFF  02,7EB
45D2:  MOVFF  01,7EA
45D6:  MOVFF  00,7E9
45DA:  MOVLW  2A
45DC:  MOVWF  FF6
45DE:  MOVLW  03
45E0:  MOVWF  FF7
45E2:  MOVLW  12
45E4:  MOVLB  8
45E6:  MOVWF  x0E
45E8:  MOVLB  0
45EA:  CALL   187C
45EE:  MOVLW  41
45F0:  MOVWF  FE9
45F2:  MOVFF  7EC,811
45F6:  MOVFF  7EB,810
45FA:  MOVFF  7EA,80F
45FE:  MOVFF  7E9,80E
4602:  CALL   262C
4606:  MOVLW  0A
4608:  MOVLB  8
460A:  MOVWF  x1A
460C:  MOVLB  0
460E:  CALL   043A
4612:  MOVLW  0D
4614:  MOVLB  8
4616:  MOVWF  x1A
4618:  MOVLB  0
461A:  CALL   043A
461E:  MOVLB  1
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
4620:  CLRF   x0E
....................       del_buf(key_numbyte,key_data); 
4622:  MOVLW  10
4624:  MOVLB  7
4626:  MOVWF  xF5
4628:  MOVLW  01
462A:  MOVWF  xF7
462C:  MOVLW  14
462E:  MOVWF  xF6
4630:  MOVLB  0
4632:  CALL   3944
....................       fprintf(COM2,"\r\n"); 
4636:  MOVLW  0D
4638:  MOVLB  8
463A:  MOVWF  x1A
463C:  MOVLB  0
463E:  CALL   043A
4642:  MOVLW  0A
4644:  MOVLB  8
4646:  MOVWF  x1A
4648:  MOVLB  0
464A:  CALL   043A
....................       fprintf(COM2,"Done PIN"); 
464E:  MOVLW  42
4650:  MOVWF  FF6
4652:  MOVLW  03
4654:  MOVWF  FF7
4656:  CALL   048C
....................       fprintf(COM2,"\r\n"); 
465A:  MOVLW  0D
465C:  MOVLB  8
465E:  MOVWF  x1A
4660:  MOVLB  0
4662:  CALL   043A
4666:  MOVLW  0A
4668:  MOVLB  8
466A:  MOVWF  x1A
466C:  MOVLB  0
466E:  CALL   043A
....................    } 
.................... } 
4672:  GOTO   493E (RETURN)
.................... //=========================================== 
.................... void key_press() 
.................... { 
....................    int8 col; 
....................    int32 KB_count_timeout=0; 
....................    fprintf(COM2,"\r\n"); 
....................    fprintf(COM2,"Key"); 
....................    //fprintf(COM2,"\r\n"); 
....................    KB_count_timeout=0; 
....................    while(1) 
....................    { 
....................       
....................       if(KB_count_timeout<150000)KB_count_timeout++; 
....................       if(KB_count_timeout==150000) 
....................       { 
....................          KB_count_timeout++; 
....................           
....................          break;             
....................       }   
....................    } 
.................... } 
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
4DF4:  MOVLB  7
4DF6:  CLRF   xC1
4DF8:  CLRF   xC0
4DFA:  CLRF   xC2
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
4DFC:  MOVF   xC1,F
4DFE:  BTFSS  FD8.2
4E00:  BRA    4F24
4E02:  MOVF   xBB,W
4E04:  SUBWF  xC0,W
4E06:  BTFSC  FD8.0
4E08:  BRA    4F24
4E0A:  MOVF   xC2,F
4E0C:  BTFSS  FD8.2
4E0E:  BRA    4F24
....................       c = fgetc(COM2);//getc(); 
4E10:  MOVLB  0
4E12:  RCALL  4D98
4E14:  MOVFF  01,7BE
....................       switch(c) 
....................       { 
4E18:  MOVLB  7
4E1A:  MOVF   xBE,W
4E1C:  XORLW  7F
4E1E:  MOVLB  0
4E20:  BZ    4E28
4E22:  XORLW  72
4E24:  BZ    4E76
4E26:  BRA    4EB4
....................          case 0x7f:    
....................             if(nbcar>0)   
4E28:  MOVLB  7
4E2A:  MOVF   xC0,F
4E2C:  BNZ   4E32
4E2E:  MOVF   xC1,F
4E30:  BZ    4E5C
4E32:  CLRF   19
4E34:  BTFSC  FF2.7
4E36:  BSF    19.7
4E38:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
4E3A:  MOVLW  7F
4E3C:  MOVLB  8
4E3E:  MOVWF  x1A
4E40:  MOVLB  0
4E42:  CALL   043A
4E46:  BTFSC  19.7
4E48:  BSF    FF2.7
....................                nbcar--; 
4E4A:  MOVLB  7
4E4C:  MOVF   xC0,W
4E4E:  BTFSC  FD8.2
4E50:  DECF   xC1,F
4E52:  DECF   xC0,F
....................                fgetc(COM2);//getc(); 
4E54:  MOVLB  0
4E56:  RCALL  4D98
....................             } 
....................             else fputc(0x07,COM2);    
4E58:  BRA    4E74
4E5A:  MOVLB  7
4E5C:  CLRF   19
4E5E:  BTFSC  FF2.7
4E60:  BSF    19.7
4E62:  BCF    FF2.7
4E64:  MOVLW  07
4E66:  MOVLB  8
4E68:  MOVWF  x1A
4E6A:  MOVLB  0
4E6C:  CALL   043A
4E70:  BTFSC  19.7
4E72:  BSF    FF2.7
....................          break;  
4E74:  BRA    4F20
....................          case 0x0D:   
....................                keydebug_en=0; 
4E76:  MOVLB  1
4E78:  CLRF   x0B
....................                set_tris_a(0xff); 
4E7A:  MOVLW  FF
4E7C:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
4E7E:  MOVFF  7C0,7BF
4E82:  MOVLB  7
4E84:  MOVF   xBB,W
4E86:  SUBWF  xBF,W
4E88:  BC    4E9E
....................                { 
....................                  chaine[i]=0; 
4E8A:  CLRF   03
4E8C:  MOVF   xBF,W
4E8E:  ADDWF  xBC,W
4E90:  MOVWF  FE9
4E92:  MOVF   xBD,W
4E94:  ADDWFC 03,W
4E96:  MOVWF  FEA
4E98:  CLRF   FEF
....................                } 
4E9A:  INCF   xBF,F
4E9C:  BRA    4E84
....................                if(nbcar==0)return(FAUX); 
4E9E:  MOVF   xC0,F
4EA0:  BNZ   4EAC
4EA2:  MOVF   xC1,F
4EA4:  BNZ   4EAC
4EA6:  MOVLW  00
4EA8:  MOVWF  01
4EAA:  BRA    4F28
....................                fini=VRAI; 
4EAC:  MOVLW  01
4EAE:  MOVWF  xC2
....................          break; 
4EB0:  MOVLB  0
4EB2:  BRA    4F20
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
4EB4:  MOVLB  7
4EB6:  MOVF   xBE,W
4EB8:  SUBLW  1F
4EBA:  BC    4F22
4EBC:  MOVF   xBE,W
4EBE:  SUBLW  7E
4EC0:  BNC   4F22
4EC2:  MOVLW  01
4EC4:  SUBWF  xBB,W
4EC6:  MOVF   xC1,F
4EC8:  BNZ   4F22
4ECA:  SUBWF  xC0,W
4ECC:  BC    4F22
....................             { 
....................                chaine[nbcar]=c; 
4ECE:  MOVF   xBC,W
4ED0:  ADDWF  xC0,W
4ED2:  MOVWF  FE9
4ED4:  MOVF   xBD,W
4ED6:  ADDWFC xC1,W
4ED8:  MOVWF  FEA
4EDA:  MOVFF  7BE,FEF
....................                nbcar++; 
4EDE:  INCF   xC0,F
4EE0:  BTFSC  FD8.2
4EE2:  INCF   xC1,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
4EE4:  DECFSZ xBA,W
4EE6:  BRA    4F02
4EE8:  CLRF   19
4EEA:  BTFSC  FF2.7
4EEC:  BSF    19.7
4EEE:  BCF    FF2.7
4EF0:  MOVFF  7BE,81A
4EF4:  MOVLB  0
4EF6:  CALL   043A
4EFA:  BTFSC  19.7
4EFC:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
4EFE:  BRA    4F20
4F00:  MOVLB  7
4F02:  MOVF   xBA,W
4F04:  SUBLW  02
4F06:  BNZ   4F22
4F08:  CLRF   19
4F0A:  BTFSC  FF2.7
4F0C:  BSF    19.7
4F0E:  BCF    FF2.7
4F10:  MOVLW  2A
4F12:  MOVLB  8
4F14:  MOVWF  x1A
4F16:  MOVLB  0
4F18:  CALL   043A
4F1C:  BTFSC  19.7
4F1E:  BSF    FF2.7
4F20:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
4F22:  BRA    4DFC
....................    return(nbcar); 
4F24:  MOVFF  7C0,01
.................... } 
4F28:  MOVLB  0
4F2A:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
4F2C:  MOVFF  7BB,7BF
4F30:  MOVFF  7BA,7BE
4F34:  MOVFF  7BD,7C1
4F38:  MOVFF  7BC,7C0
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
4F3C:  MOVFF  7BF,03
4F40:  MOVLB  7
4F42:  MOVFF  7BE,FE9
4F46:  MOVFF  7BF,FEA
4F4A:  MOVF   FEF,F
4F4C:  BZ    4F94
4F4E:  MOVFF  7C1,03
4F52:  MOVFF  7C0,FE9
4F56:  MOVFF  7C1,FEA
4F5A:  MOVF   FEF,F
4F5C:  BZ    4F94
....................       if(*aa!=*bb) 
4F5E:  MOVFF  7BE,FE9
4F62:  MOVFF  7BF,FEA
4F66:  MOVFF  FEF,7C2
4F6A:  MOVFF  7C1,03
4F6E:  MOVFF  7C0,FE9
4F72:  MOVFF  7C1,FEA
4F76:  MOVF   FEF,W
4F78:  SUBWF  xC2,W
4F7A:  BZ    4F82
....................          return(1); 
4F7C:  MOVLW  01
4F7E:  MOVWF  01
4F80:  BRA    4FC0
....................       aa++; 
4F82:  INCF   xBE,F
4F84:  BTFSC  FD8.2
4F86:  INCF   xBF,F
....................       bb++; 
4F88:  INCF   xC0,F
4F8A:  BTFSC  FD8.2
4F8C:  INCF   xC1,F
....................    } 
4F8E:  MOVLB  0
4F90:  BRA    4F3C
4F92:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
4F94:  MOVFF  7BF,03
4F98:  MOVFF  7BE,FE9
4F9C:  MOVFF  7BF,FEA
4FA0:  MOVFF  FEF,7C2
4FA4:  MOVFF  7C1,03
4FA8:  MOVFF  7C0,FE9
4FAC:  MOVFF  7C1,FEA
4FB0:  MOVF   FEF,W
4FB2:  SUBWF  xC2,W
4FB4:  BZ    4FBC
4FB6:  MOVLW  01
4FB8:  MOVWF  01
4FBA:  BRA    4FC0
....................    return(0); 
4FBC:  MOVLW  00
4FBE:  MOVWF  01
.................... } 
4FC0:  MOVLB  0
4FC2:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
5508:  MOVLB  7
550A:  CLRF   xBC
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
550C:  MOVFF  7BB,03
5510:  MOVF   xBA,W
5512:  INCF   xBA,F
5514:  BTFSC  FD8.2
5516:  INCF   xBB,F
5518:  MOVWF  FE9
551A:  MOVFF  03,FEA
551E:  MOVFF  FEF,7BE
5522:  MOVF   xBE,F
5524:  BZ    5548
....................         if (c >= '0' && c <= '9') 
5526:  MOVF   xBE,W
5528:  SUBLW  2F
552A:  BC    553A
552C:  MOVF   xBE,W
552E:  SUBLW  39
5530:  BNC   553A
....................             digit = (unsigned int) (c - '0'); 
5532:  MOVLW  30
5534:  SUBWF  xBE,W
5536:  MOVWF  xBD
....................         else 
5538:  BRA    553C
....................             break; 
553A:  BRA    5548
....................  
....................         val = (val * 10) + digit; 
553C:  MOVF   xBC,W
553E:  MULLW  0A
5540:  MOVF   FF3,W
5542:  ADDWF  xBD,W
5544:  MOVWF  xBC
....................     } 
5546:  BRA    550C
....................  
....................     return val; 
5548:  CLRF   03
554A:  MOVFF  7BC,01
554E:  MOVFF  03,02
.................... } 
5552:  MOVLB  0
5554:  RETURN 0
....................  
.................... int8 receiver_state=0,booting_done=0; 
.................... int16 over_byte=0; 
.................... //#include <GSM.c>  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
04AC:  MOVLB  8
04AE:  CLRF   x35
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
04B0:  CLRF   x36
04B2:  BTFSC  x2D.0
04B4:  BSF    x36.7
04B6:  SWAPF  x2E,W
04B8:  MOVWF  00
04BA:  RLCF   00,F
04BC:  RLCF   00,F
04BE:  MOVLW  C0
04C0:  ANDWF  00,F
04C2:  MOVF   00,W
04C4:  IORWF  x36,F
04C6:  SWAPF  x2F,W
04C8:  MOVWF  00
04CA:  RLCF   00,F
04CC:  MOVLW  E0
04CE:  ANDWF  00,F
04D0:  MOVF   00,W
04D2:  IORWF  x36,F
04D4:  SWAPF  x30,W
04D6:  MOVWF  00
04D8:  MOVLW  F0
04DA:  ANDWF  00,F
04DC:  MOVF   00,W
04DE:  IORWF  x36,F
04E0:  RLCF   x31,W
04E2:  MOVWF  00
04E4:  RLCF   00,F
04E6:  RLCF   00,F
04E8:  MOVLW  F8
04EA:  ANDWF  00,F
04EC:  MOVF   00,W
04EE:  IORWF  x36,F
04F0:  RLCF   x32,W
04F2:  MOVWF  00
04F4:  RLCF   00,F
04F6:  MOVLW  FC
04F8:  ANDWF  00,F
04FA:  MOVF   00,W
04FC:  IORWF  x36,F
04FE:  BCF    FD8.0
0500:  RLCF   x33,W
0502:  IORWF  x36,F
0504:  MOVF   x34,W
0506:  IORWF  x36,W
0508:  MOVWF  x35
....................    return temp; 
050A:  MOVFF  835,01
.................... } 
050E:  MOVLB  0
0510:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0512:  MOVLB  8
0514:  CLRF   x1D
....................    int8 temp=0; 
....................    if(direct==0) 
0516:  MOVF   x18,F
0518:  BNZ   05EE
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
051A:  MOVF   x1B,W
051C:  ADDWF  x19,W
051E:  MOVWF  FE9
0520:  MOVF   x1C,W
0522:  ADDWFC x1A,W
0524:  MOVWF  FEA
0526:  MOVFF  FEF,81E
052A:  MOVLW  01
052C:  ADDWF  x19,W
052E:  MOVWF  x1F
0530:  MOVLW  00
0532:  ADDWFC x1A,W
0534:  MOVWF  x20
0536:  MOVF   x1B,W
0538:  ADDWF  x1F,W
053A:  MOVWF  FE9
053C:  MOVF   x1C,W
053E:  ADDWFC x20,W
0540:  MOVWF  FEA
0542:  MOVF   FEF,W
0544:  XORWF  x1E,F
0546:  MOVLW  02
0548:  ADDWF  x19,W
054A:  MOVWF  x21
054C:  MOVLW  00
054E:  ADDWFC x1A,W
0550:  MOVWF  x22
0552:  MOVF   x1B,W
0554:  ADDWF  x21,W
0556:  MOVWF  FE9
0558:  MOVF   x1C,W
055A:  ADDWFC x22,W
055C:  MOVWF  FEA
055E:  MOVF   FEF,W
0560:  XORWF  x1E,F
0562:  MOVLW  03
0564:  ADDWF  x19,W
0566:  MOVWF  x23
0568:  MOVLW  00
056A:  ADDWFC x1A,W
056C:  MOVWF  x24
056E:  MOVF   x1B,W
0570:  ADDWF  x23,W
0572:  MOVWF  FE9
0574:  MOVF   x1C,W
0576:  ADDWFC x24,W
0578:  MOVWF  FEA
057A:  MOVF   FEF,W
057C:  XORWF  x1E,F
057E:  MOVLW  04
0580:  ADDWF  x19,W
0582:  MOVWF  x25
0584:  MOVLW  00
0586:  ADDWFC x1A,W
0588:  MOVWF  x26
058A:  MOVF   x1B,W
058C:  ADDWF  x25,W
058E:  MOVWF  FE9
0590:  MOVF   x1C,W
0592:  ADDWFC x26,W
0594:  MOVWF  FEA
0596:  MOVF   FEF,W
0598:  XORWF  x1E,F
059A:  MOVLW  05
059C:  ADDWF  x19,W
059E:  MOVWF  x27
05A0:  MOVLW  00
05A2:  ADDWFC x1A,W
05A4:  MOVWF  x28
05A6:  MOVF   x1B,W
05A8:  ADDWF  x27,W
05AA:  MOVWF  FE9
05AC:  MOVF   x1C,W
05AE:  ADDWFC x28,W
05B0:  MOVWF  FEA
05B2:  MOVF   FEF,W
05B4:  XORWF  x1E,W
05B6:  BZ    05BC
05B8:  MOVLW  00
05BA:  BRA    05BE
05BC:  MOVLW  01
05BE:  MOVWF  x1D
....................       if(temp==datain[offset+6]) return 1; 
05C0:  MOVLW  06
05C2:  ADDWF  x19,W
05C4:  MOVWF  x1E
05C6:  MOVLW  00
05C8:  ADDWFC x1A,W
05CA:  MOVWF  x1F
05CC:  MOVF   x1B,W
05CE:  ADDWF  x1E,W
05D0:  MOVWF  FE9
05D2:  MOVF   x1C,W
05D4:  ADDWFC x1F,W
05D6:  MOVWF  FEA
05D8:  MOVF   FEF,W
05DA:  SUBWF  x1D,W
05DC:  BNZ   05E6
05DE:  MOVLW  01
05E0:  MOVWF  01
05E2:  BRA    06BE
....................          else return 0; 
05E4:  BRA    05EC
05E6:  MOVLW  00
05E8:  MOVWF  01
05EA:  BRA    06BE
....................    } 
....................       else  
05EC:  BRA    06BE
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
05EE:  MOVF   x1B,W
05F0:  ADDWF  x19,W
05F2:  MOVWF  FE9
05F4:  MOVF   x1C,W
05F6:  ADDWFC x1A,W
05F8:  MOVWF  FEA
05FA:  MOVFF  FEF,81E
05FE:  MOVLW  01
0600:  SUBWF  x19,W
0602:  MOVWF  x1F
0604:  MOVLW  00
0606:  SUBWFB x1A,W
0608:  MOVWF  x20
060A:  MOVF   x1B,W
060C:  ADDWF  x1F,W
060E:  MOVWF  FE9
0610:  MOVF   x1C,W
0612:  ADDWFC x20,W
0614:  MOVWF  FEA
0616:  MOVF   FEF,W
0618:  XORWF  x1E,F
061A:  MOVLW  02
061C:  SUBWF  x19,W
061E:  MOVWF  x21
0620:  MOVLW  00
0622:  SUBWFB x1A,W
0624:  MOVWF  x22
0626:  MOVF   x1B,W
0628:  ADDWF  x21,W
062A:  MOVWF  FE9
062C:  MOVF   x1C,W
062E:  ADDWFC x22,W
0630:  MOVWF  FEA
0632:  MOVF   FEF,W
0634:  XORWF  x1E,F
0636:  MOVLW  03
0638:  SUBWF  x19,W
063A:  MOVWF  x23
063C:  MOVLW  00
063E:  SUBWFB x1A,W
0640:  MOVWF  x24
0642:  MOVF   x1B,W
0644:  ADDWF  x23,W
0646:  MOVWF  FE9
0648:  MOVF   x1C,W
064A:  ADDWFC x24,W
064C:  MOVWF  FEA
064E:  MOVF   FEF,W
0650:  XORWF  x1E,F
0652:  MOVLW  04
0654:  SUBWF  x19,W
0656:  MOVWF  x25
0658:  MOVLW  00
065A:  SUBWFB x1A,W
065C:  MOVWF  x26
065E:  MOVF   x1B,W
0660:  ADDWF  x25,W
0662:  MOVWF  FE9
0664:  MOVF   x1C,W
0666:  ADDWFC x26,W
0668:  MOVWF  FEA
066A:  MOVF   FEF,W
066C:  XORWF  x1E,F
066E:  MOVLW  05
0670:  SUBWF  x19,W
0672:  MOVWF  x27
0674:  MOVLW  00
0676:  SUBWFB x1A,W
0678:  MOVWF  x28
067A:  MOVF   x1B,W
067C:  ADDWF  x27,W
067E:  MOVWF  FE9
0680:  MOVF   x1C,W
0682:  ADDWFC x28,W
0684:  MOVWF  FEA
0686:  MOVF   FEF,W
0688:  XORWF  x1E,W
068A:  BZ    0690
068C:  MOVLW  00
068E:  BRA    0692
0690:  MOVLW  01
0692:  MOVWF  x1D
....................          if(temp==datain[offset-6]) return 1; 
0694:  MOVLW  06
0696:  SUBWF  x19,W
0698:  MOVWF  x1E
069A:  MOVLW  00
069C:  SUBWFB x1A,W
069E:  MOVWF  x1F
06A0:  MOVF   x1B,W
06A2:  ADDWF  x1E,W
06A4:  MOVWF  FE9
06A6:  MOVF   x1C,W
06A8:  ADDWFC x1F,W
06AA:  MOVWF  FEA
06AC:  MOVF   FEF,W
06AE:  SUBWF  x1D,W
06B0:  BNZ   06BA
06B2:  MOVLW  01
06B4:  MOVWF  01
06B6:  BRA    06BE
....................             else return 0;          
06B8:  BRA    06BE
06BA:  MOVLW  00
06BC:  MOVWF  01
....................       } 
.................... } 
06BE:  MOVLB  0
06C0:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
06C2:  MOVLB  8
06C4:  CLRF   x1D
....................    int8 temp=0; 
....................    if(direct==0) 
06C6:  MOVF   x18,F
06C8:  BNZ   0766
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
06CA:  MOVF   x1B,W
06CC:  ADDWF  x19,W
06CE:  MOVWF  FE9
06D0:  MOVF   x1C,W
06D2:  ADDWFC x1A,W
06D4:  MOVWF  FEA
06D6:  MOVFF  FEF,81E
06DA:  MOVLW  01
06DC:  ADDWF  x19,W
06DE:  MOVWF  x1F
06E0:  MOVLW  00
06E2:  ADDWFC x1A,W
06E4:  MOVWF  x20
06E6:  MOVF   x1B,W
06E8:  ADDWF  x1F,W
06EA:  MOVWF  FE9
06EC:  MOVF   x1C,W
06EE:  ADDWFC x20,W
06F0:  MOVWF  FEA
06F2:  MOVF   FEF,W
06F4:  XORWF  x1E,F
06F6:  MOVLW  02
06F8:  ADDWF  x19,W
06FA:  MOVWF  x21
06FC:  MOVLW  00
06FE:  ADDWFC x1A,W
0700:  MOVWF  x22
0702:  MOVF   x1B,W
0704:  ADDWF  x21,W
0706:  MOVWF  FE9
0708:  MOVF   x1C,W
070A:  ADDWFC x22,W
070C:  MOVWF  FEA
070E:  MOVF   FEF,W
0710:  XORWF  x1E,F
0712:  MOVLW  03
0714:  ADDWF  x19,W
0716:  MOVWF  x23
0718:  MOVLW  00
071A:  ADDWFC x1A,W
071C:  MOVWF  x24
071E:  MOVF   x1B,W
0720:  ADDWF  x23,W
0722:  MOVWF  FE9
0724:  MOVF   x1C,W
0726:  ADDWFC x24,W
0728:  MOVWF  FEA
072A:  MOVF   FEF,W
072C:  XORWF  x1E,W
072E:  BZ    0734
0730:  MOVLW  00
0732:  BRA    0736
0734:  MOVLW  01
0736:  MOVWF  x1D
....................       if(temp==datain[offset+4]) return 1; 
0738:  MOVLW  04
073A:  ADDWF  x19,W
073C:  MOVWF  x1E
073E:  MOVLW  00
0740:  ADDWFC x1A,W
0742:  MOVWF  x1F
0744:  MOVF   x1B,W
0746:  ADDWF  x1E,W
0748:  MOVWF  FE9
074A:  MOVF   x1C,W
074C:  ADDWFC x1F,W
074E:  MOVWF  FEA
0750:  MOVF   FEF,W
0752:  SUBWF  x1D,W
0754:  BNZ   075E
0756:  MOVLW  01
0758:  MOVWF  01
075A:  BRA    07FE
....................          else return 0; 
075C:  BRA    0764
075E:  MOVLW  00
0760:  MOVWF  01
0762:  BRA    07FE
....................    } 
....................    else 
0764:  BRA    07FE
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0766:  MOVF   x1B,W
0768:  ADDWF  x19,W
076A:  MOVWF  FE9
076C:  MOVF   x1C,W
076E:  ADDWFC x1A,W
0770:  MOVWF  FEA
0772:  MOVFF  FEF,81E
0776:  MOVLW  01
0778:  SUBWF  x19,W
077A:  MOVWF  x1F
077C:  MOVLW  00
077E:  SUBWFB x1A,W
0780:  MOVWF  x20
0782:  MOVF   x1B,W
0784:  ADDWF  x1F,W
0786:  MOVWF  FE9
0788:  MOVF   x1C,W
078A:  ADDWFC x20,W
078C:  MOVWF  FEA
078E:  MOVF   FEF,W
0790:  XORWF  x1E,F
0792:  MOVLW  02
0794:  SUBWF  x19,W
0796:  MOVWF  x21
0798:  MOVLW  00
079A:  SUBWFB x1A,W
079C:  MOVWF  x22
079E:  MOVF   x1B,W
07A0:  ADDWF  x21,W
07A2:  MOVWF  FE9
07A4:  MOVF   x1C,W
07A6:  ADDWFC x22,W
07A8:  MOVWF  FEA
07AA:  MOVF   FEF,W
07AC:  XORWF  x1E,F
07AE:  MOVLW  03
07B0:  SUBWF  x19,W
07B2:  MOVWF  x23
07B4:  MOVLW  00
07B6:  SUBWFB x1A,W
07B8:  MOVWF  x24
07BA:  MOVF   x1B,W
07BC:  ADDWF  x23,W
07BE:  MOVWF  FE9
07C0:  MOVF   x1C,W
07C2:  ADDWFC x24,W
07C4:  MOVWF  FEA
07C6:  MOVF   FEF,W
07C8:  XORWF  x1E,W
07CA:  BZ    07D0
07CC:  MOVLW  00
07CE:  BRA    07D2
07D0:  MOVLW  01
07D2:  MOVWF  x1D
....................       if(temp==datain[offset-4]) return 1; 
07D4:  MOVLW  04
07D6:  SUBWF  x19,W
07D8:  MOVWF  x1E
07DA:  MOVLW  00
07DC:  SUBWFB x1A,W
07DE:  MOVWF  x1F
07E0:  MOVF   x1B,W
07E2:  ADDWF  x1E,W
07E4:  MOVWF  FE9
07E6:  MOVF   x1C,W
07E8:  ADDWFC x1F,W
07EA:  MOVWF  FEA
07EC:  MOVF   FEF,W
07EE:  SUBWF  x1D,W
07F0:  BNZ   07FA
07F2:  MOVLW  01
07F4:  MOVWF  01
07F6:  BRA    07FE
....................          else return 0;                
07F8:  BRA    07FE
07FA:  MOVLW  00
07FC:  MOVWF  01
....................    } 
.................... } 
07FE:  MOVLB  0
0800:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0802:  MOVLB  7
0804:  CLRF   xFE
0806:  CLRF   xFF
0808:  MOVLB  8
080A:  CLRF   x00
080C:  CLRF   x01
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
080E:  MOVLB  7
0810:  CLRF   xFB
0812:  CLRF   xFA
0814:  RRCF   xF7,W
0816:  MOVWF  03
0818:  RRCF   xF6,W
081A:  MOVWF  02
081C:  RRCF   03,F
081E:  RRCF   02,F
0820:  MOVLW  3F
0822:  ANDWF  03,F
0824:  MOVFF  02,01
0828:  MOVF   xFB,W
082A:  SUBWF  03,W
082C:  BTFSS  FD8.0
082E:  GOTO   1030
0832:  BNZ   083E
0834:  MOVF   01,W
0836:  SUBWF  xFA,W
0838:  BTFSC  FD8.0
083A:  GOTO   1030
....................    { 
....................       if(track==0) 
083E:  MOVF   xF5,F
0840:  BTFSS  FD8.2
0842:  BRA    0CC0
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0844:  MOVLW  06
0846:  ADDWF  xFA,W
0848:  MOVLB  8
084A:  MOVWF  x02
084C:  MOVLW  00
084E:  MOVLB  7
0850:  ADDWFC xFB,W
0852:  MOVLB  8
0854:  MOVWF  x03
0856:  MOVLB  7
0858:  MOVF   xF8,W
085A:  MOVLB  8
085C:  ADDWF  x02,W
085E:  MOVWF  FE9
0860:  MOVLB  7
0862:  MOVF   xF9,W
0864:  MOVLB  8
0866:  ADDWFC x03,W
0868:  MOVWF  FEA
086A:  MOVFF  FEF,804
086E:  MOVLW  05
0870:  MOVLB  7
0872:  ADDWF  xFA,W
0874:  MOVLB  8
0876:  MOVWF  x05
0878:  MOVLW  00
087A:  MOVLB  7
087C:  ADDWFC xFB,W
087E:  MOVLB  8
0880:  MOVWF  x06
0882:  MOVLB  7
0884:  MOVF   xF8,W
0886:  MOVLB  8
0888:  ADDWF  x05,W
088A:  MOVWF  FE9
088C:  MOVLB  7
088E:  MOVF   xF9,W
0890:  MOVLB  8
0892:  ADDWFC x06,W
0894:  MOVWF  FEA
0896:  MOVFF  FEF,807
089A:  MOVLW  04
089C:  MOVLB  7
089E:  ADDWF  xFA,W
08A0:  MOVLB  8
08A2:  MOVWF  x08
08A4:  MOVLW  00
08A6:  MOVLB  7
08A8:  ADDWFC xFB,W
08AA:  MOVLB  8
08AC:  MOVWF  x09
08AE:  MOVLB  7
08B0:  MOVF   xF8,W
08B2:  MOVLB  8
08B4:  ADDWF  x08,W
08B6:  MOVWF  FE9
08B8:  MOVLB  7
08BA:  MOVF   xF9,W
08BC:  MOVLB  8
08BE:  ADDWFC x09,W
08C0:  MOVWF  FEA
08C2:  MOVFF  FEF,80A
08C6:  MOVLW  03
08C8:  MOVLB  7
08CA:  ADDWF  xFA,W
08CC:  MOVLB  8
08CE:  MOVWF  x0B
08D0:  MOVLW  00
08D2:  MOVLB  7
08D4:  ADDWFC xFB,W
08D6:  MOVLB  8
08D8:  MOVWF  x0C
08DA:  MOVLB  7
08DC:  MOVF   xF8,W
08DE:  MOVLB  8
08E0:  ADDWF  x0B,W
08E2:  MOVWF  FE9
08E4:  MOVLB  7
08E6:  MOVF   xF9,W
08E8:  MOVLB  8
08EA:  ADDWFC x0C,W
08EC:  MOVWF  FEA
08EE:  MOVFF  FEF,80D
08F2:  MOVLW  02
08F4:  MOVLB  7
08F6:  ADDWF  xFA,W
08F8:  MOVLB  8
08FA:  MOVWF  x0E
08FC:  MOVLW  00
08FE:  MOVLB  7
0900:  ADDWFC xFB,W
0902:  MOVLB  8
0904:  MOVWF  x0F
0906:  MOVLB  7
0908:  MOVF   xF8,W
090A:  MOVLB  8
090C:  ADDWF  x0E,W
090E:  MOVWF  FE9
0910:  MOVLB  7
0912:  MOVF   xF9,W
0914:  MOVLB  8
0916:  ADDWFC x0F,W
0918:  MOVWF  FEA
091A:  MOVFF  FEF,810
091E:  MOVLW  01
0920:  MOVLB  7
0922:  ADDWF  xFA,W
0924:  MOVLB  8
0926:  MOVWF  x11
0928:  MOVLW  00
092A:  MOVLB  7
092C:  ADDWFC xFB,W
092E:  MOVLB  8
0930:  MOVWF  x12
0932:  MOVLB  7
0934:  MOVF   xF8,W
0936:  MOVLB  8
0938:  ADDWF  x11,W
093A:  MOVWF  FE9
093C:  MOVLB  7
093E:  MOVF   xF9,W
0940:  MOVLB  8
0942:  ADDWFC x12,W
0944:  MOVWF  FEA
0946:  MOVFF  FEF,813
094A:  MOVLB  7
094C:  MOVF   xF8,W
094E:  ADDWF  xFA,W
0950:  MOVWF  FE9
0952:  MOVF   xF9,W
0954:  ADDWFC xFB,W
0956:  MOVWF  FEA
0958:  MOVFF  FEF,814
095C:  MOVLB  8
095E:  CLRF   x2D
0960:  MOVFF  804,82E
0964:  MOVFF  807,82F
0968:  MOVFF  80A,830
096C:  MOVFF  80D,831
0970:  MOVFF  810,832
0974:  MOVFF  813,833
0978:  MOVFF  814,834
097C:  MOVLB  0
097E:  RCALL  04AC
0980:  MOVFF  01,7FE
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0984:  MOVLW  0D
0986:  MOVLB  7
0988:  ADDWF  xFA,W
098A:  MOVLB  8
098C:  MOVWF  x02
098E:  MOVLW  00
0990:  MOVLB  7
0992:  ADDWFC xFB,W
0994:  MOVLB  8
0996:  MOVWF  x03
0998:  MOVLB  7
099A:  MOVF   xF8,W
099C:  MOVLB  8
099E:  ADDWF  x02,W
09A0:  MOVWF  FE9
09A2:  MOVLB  7
09A4:  MOVF   xF9,W
09A6:  MOVLB  8
09A8:  ADDWFC x03,W
09AA:  MOVWF  FEA
09AC:  MOVFF  FEF,804
09B0:  MOVLW  0C
09B2:  MOVLB  7
09B4:  ADDWF  xFA,W
09B6:  MOVLB  8
09B8:  MOVWF  x05
09BA:  MOVLW  00
09BC:  MOVLB  7
09BE:  ADDWFC xFB,W
09C0:  MOVLB  8
09C2:  MOVWF  x06
09C4:  MOVLB  7
09C6:  MOVF   xF8,W
09C8:  MOVLB  8
09CA:  ADDWF  x05,W
09CC:  MOVWF  FE9
09CE:  MOVLB  7
09D0:  MOVF   xF9,W
09D2:  MOVLB  8
09D4:  ADDWFC x06,W
09D6:  MOVWF  FEA
09D8:  MOVFF  FEF,807
09DC:  MOVLW  0B
09DE:  MOVLB  7
09E0:  ADDWF  xFA,W
09E2:  MOVLB  8
09E4:  MOVWF  x08
09E6:  MOVLW  00
09E8:  MOVLB  7
09EA:  ADDWFC xFB,W
09EC:  MOVLB  8
09EE:  MOVWF  x09
09F0:  MOVLB  7
09F2:  MOVF   xF8,W
09F4:  MOVLB  8
09F6:  ADDWF  x08,W
09F8:  MOVWF  FE9
09FA:  MOVLB  7
09FC:  MOVF   xF9,W
09FE:  MOVLB  8
0A00:  ADDWFC x09,W
0A02:  MOVWF  FEA
0A04:  MOVFF  FEF,80A
0A08:  MOVLW  0A
0A0A:  MOVLB  7
0A0C:  ADDWF  xFA,W
0A0E:  MOVLB  8
0A10:  MOVWF  x0B
0A12:  MOVLW  00
0A14:  MOVLB  7
0A16:  ADDWFC xFB,W
0A18:  MOVLB  8
0A1A:  MOVWF  x0C
0A1C:  MOVLB  7
0A1E:  MOVF   xF8,W
0A20:  MOVLB  8
0A22:  ADDWF  x0B,W
0A24:  MOVWF  FE9
0A26:  MOVLB  7
0A28:  MOVF   xF9,W
0A2A:  MOVLB  8
0A2C:  ADDWFC x0C,W
0A2E:  MOVWF  FEA
0A30:  MOVFF  FEF,80D
0A34:  MOVLW  09
0A36:  MOVLB  7
0A38:  ADDWF  xFA,W
0A3A:  MOVLB  8
0A3C:  MOVWF  x0E
0A3E:  MOVLW  00
0A40:  MOVLB  7
0A42:  ADDWFC xFB,W
0A44:  MOVLB  8
0A46:  MOVWF  x0F
0A48:  MOVLB  7
0A4A:  MOVF   xF8,W
0A4C:  MOVLB  8
0A4E:  ADDWF  x0E,W
0A50:  MOVWF  FE9
0A52:  MOVLB  7
0A54:  MOVF   xF9,W
0A56:  MOVLB  8
0A58:  ADDWFC x0F,W
0A5A:  MOVWF  FEA
0A5C:  MOVFF  FEF,810
0A60:  MOVLW  08
0A62:  MOVLB  7
0A64:  ADDWF  xFA,W
0A66:  MOVLB  8
0A68:  MOVWF  x11
0A6A:  MOVLW  00
0A6C:  MOVLB  7
0A6E:  ADDWFC xFB,W
0A70:  MOVLB  8
0A72:  MOVWF  x12
0A74:  MOVLB  7
0A76:  MOVF   xF8,W
0A78:  MOVLB  8
0A7A:  ADDWF  x11,W
0A7C:  MOVWF  FE9
0A7E:  MOVLB  7
0A80:  MOVF   xF9,W
0A82:  MOVLB  8
0A84:  ADDWFC x12,W
0A86:  MOVWF  FEA
0A88:  MOVFF  FEF,813
0A8C:  MOVLW  07
0A8E:  MOVLB  7
0A90:  ADDWF  xFA,W
0A92:  MOVLB  8
0A94:  MOVWF  x14
0A96:  MOVLW  00
0A98:  MOVLB  7
0A9A:  ADDWFC xFB,W
0A9C:  MOVLB  8
0A9E:  MOVWF  x15
0AA0:  MOVLB  7
0AA2:  MOVF   xF8,W
0AA4:  MOVLB  8
0AA6:  ADDWF  x14,W
0AA8:  MOVWF  FE9
0AAA:  MOVLB  7
0AAC:  MOVF   xF9,W
0AAE:  MOVLB  8
0AB0:  ADDWFC x15,W
0AB2:  MOVWF  FEA
0AB4:  MOVFF  FEF,816
0AB8:  CLRF   x2D
0ABA:  MOVFF  804,82E
0ABE:  MOVFF  807,82F
0AC2:  MOVFF  80A,830
0AC6:  MOVFF  80D,831
0ACA:  MOVFF  810,832
0ACE:  MOVFF  813,833
0AD2:  MOVFF  816,834
0AD6:  MOVLB  0
0AD8:  RCALL  04AC
0ADA:  MOVFF  01,7FF
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0ADE:  MOVLB  7
0AE0:  MOVF   xFE,W
0AE2:  SUBLW  45
0AE4:  BTFSS  FD8.2
0AE6:  BRA    0CBA
0AE8:  MOVF   xFF,W
0AEA:  SUBLW  7C
0AEC:  BTFSC  FD8.2
0AEE:  BRA    0CBA
0AF0:  MOVF   xFF,W
0AF2:  SUBLW  3E
0AF4:  BTFSC  FD8.2
0AF6:  BRA    0CBA
0AF8:  MOVF   xFF,W
0AFA:  SUBLW  1F
0AFC:  BTFSC  FD8.2
0AFE:  BRA    0CBA
....................          { 
....................             j=i; 
0B00:  MOVFF  7FB,7FD
0B04:  MOVFF  7FA,7FC
....................             CRC=1; 
0B08:  MOVLW  01
0B0A:  MOVLB  8
0B0C:  MOVWF  x01
....................             temp2=temp; 
0B0E:  MOVFF  7FE,800
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0B12:  MOVF   x00,W
0B14:  SUBLW  1F
0B16:  BTFSC  FD8.2
0B18:  BRA    0CA4
0B1A:  MOVLB  7
0B1C:  MOVF   xFD,W
0B1E:  SUBLW  03
0B20:  BTFSC  FD8.0
0B22:  BRA    0B28
0B24:  MOVLB  8
0B26:  BRA    0CA4
0B28:  BNZ   0B36
0B2A:  MOVF   xFC,W
0B2C:  SUBLW  E7
0B2E:  BTFSC  FD8.0
0B30:  BRA    0B36
0B32:  MOVLB  8
0B34:  BRA    0CA4
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0B36:  MOVLB  8
0B38:  CLRF   x18
0B3A:  MOVFF  7FD,81A
0B3E:  MOVFF  7FC,819
0B42:  MOVFF  7F9,81C
0B46:  MOVFF  7F8,81B
0B4A:  MOVLB  0
0B4C:  RCALL  0512
0B4E:  MOVF   01,W
0B50:  MOVLB  8
0B52:  ANDWF  x01,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0B54:  MOVLW  06
0B56:  MOVLB  7
0B58:  ADDWF  xFC,W
0B5A:  MOVLB  8
0B5C:  MOVWF  x02
0B5E:  MOVLW  00
0B60:  MOVLB  7
0B62:  ADDWFC xFD,W
0B64:  MOVLB  8
0B66:  MOVWF  x03
0B68:  MOVLB  7
0B6A:  MOVF   xF8,W
0B6C:  MOVLB  8
0B6E:  ADDWF  x02,W
0B70:  MOVWF  FE9
0B72:  MOVLB  7
0B74:  MOVF   xF9,W
0B76:  MOVLB  8
0B78:  ADDWFC x03,W
0B7A:  MOVWF  FEA
0B7C:  MOVFF  FEF,804
0B80:  MOVLW  05
0B82:  MOVLB  7
0B84:  ADDWF  xFC,W
0B86:  MOVLB  8
0B88:  MOVWF  x05
0B8A:  MOVLW  00
0B8C:  MOVLB  7
0B8E:  ADDWFC xFD,W
0B90:  MOVLB  8
0B92:  MOVWF  x06
0B94:  MOVLB  7
0B96:  MOVF   xF8,W
0B98:  MOVLB  8
0B9A:  ADDWF  x05,W
0B9C:  MOVWF  FE9
0B9E:  MOVLB  7
0BA0:  MOVF   xF9,W
0BA2:  MOVLB  8
0BA4:  ADDWFC x06,W
0BA6:  MOVWF  FEA
0BA8:  MOVFF  FEF,807
0BAC:  MOVLW  04
0BAE:  MOVLB  7
0BB0:  ADDWF  xFC,W
0BB2:  MOVLB  8
0BB4:  MOVWF  x08
0BB6:  MOVLW  00
0BB8:  MOVLB  7
0BBA:  ADDWFC xFD,W
0BBC:  MOVLB  8
0BBE:  MOVWF  x09
0BC0:  MOVLB  7
0BC2:  MOVF   xF8,W
0BC4:  MOVLB  8
0BC6:  ADDWF  x08,W
0BC8:  MOVWF  FE9
0BCA:  MOVLB  7
0BCC:  MOVF   xF9,W
0BCE:  MOVLB  8
0BD0:  ADDWFC x09,W
0BD2:  MOVWF  FEA
0BD4:  MOVFF  FEF,80A
0BD8:  MOVLW  03
0BDA:  MOVLB  7
0BDC:  ADDWF  xFC,W
0BDE:  MOVLB  8
0BE0:  MOVWF  x0B
0BE2:  MOVLW  00
0BE4:  MOVLB  7
0BE6:  ADDWFC xFD,W
0BE8:  MOVLB  8
0BEA:  MOVWF  x0C
0BEC:  MOVLB  7
0BEE:  MOVF   xF8,W
0BF0:  MOVLB  8
0BF2:  ADDWF  x0B,W
0BF4:  MOVWF  FE9
0BF6:  MOVLB  7
0BF8:  MOVF   xF9,W
0BFA:  MOVLB  8
0BFC:  ADDWFC x0C,W
0BFE:  MOVWF  FEA
0C00:  MOVFF  FEF,80D
0C04:  MOVLW  02
0C06:  MOVLB  7
0C08:  ADDWF  xFC,W
0C0A:  MOVLB  8
0C0C:  MOVWF  x0E
0C0E:  MOVLW  00
0C10:  MOVLB  7
0C12:  ADDWFC xFD,W
0C14:  MOVLB  8
0C16:  MOVWF  x0F
0C18:  MOVLB  7
0C1A:  MOVF   xF8,W
0C1C:  MOVLB  8
0C1E:  ADDWF  x0E,W
0C20:  MOVWF  FE9
0C22:  MOVLB  7
0C24:  MOVF   xF9,W
0C26:  MOVLB  8
0C28:  ADDWFC x0F,W
0C2A:  MOVWF  FEA
0C2C:  MOVFF  FEF,810
0C30:  MOVLW  01
0C32:  MOVLB  7
0C34:  ADDWF  xFC,W
0C36:  MOVLB  8
0C38:  MOVWF  x11
0C3A:  MOVLW  00
0C3C:  MOVLB  7
0C3E:  ADDWFC xFD,W
0C40:  MOVLB  8
0C42:  MOVWF  x12
0C44:  MOVLB  7
0C46:  MOVF   xF8,W
0C48:  MOVLB  8
0C4A:  ADDWF  x11,W
0C4C:  MOVWF  FE9
0C4E:  MOVLB  7
0C50:  MOVF   xF9,W
0C52:  MOVLB  8
0C54:  ADDWFC x12,W
0C56:  MOVWF  FEA
0C58:  MOVFF  FEF,813
0C5C:  MOVLB  7
0C5E:  MOVF   xF8,W
0C60:  ADDWF  xFC,W
0C62:  MOVWF  FE9
0C64:  MOVF   xF9,W
0C66:  ADDWFC xFD,W
0C68:  MOVWF  FEA
0C6A:  MOVFF  FEF,814
0C6E:  MOVLB  8
0C70:  CLRF   x2D
0C72:  MOVFF  804,82E
0C76:  MOVFF  807,82F
0C7A:  MOVFF  80A,830
0C7E:  MOVFF  80D,831
0C82:  MOVFF  810,832
0C86:  MOVFF  813,833
0C8A:  MOVFF  814,834
0C8E:  MOVLB  0
0C90:  RCALL  04AC
0C92:  MOVFF  01,800
....................                j=j+7; 
0C96:  MOVLW  07
0C98:  MOVLB  7
0C9A:  ADDWF  xFC,F
0C9C:  MOVLW  00
0C9E:  ADDWFC xFD,F
....................             } 
0CA0:  MOVLB  8
0CA2:  BRA    0B12
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0CA4:  DECFSZ x01,W
0CA6:  BRA    0CBC
....................             { 
....................                dir=0; 
0CA8:  MOVLB  6
0CAA:  CLRF   x8F
....................                return i; 
0CAC:  MOVLB  7
0CAE:  MOVFF  7FA,01
0CB2:  MOVFF  7FB,02
0CB6:  GOTO   1878
0CBA:  MOVLB  8
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0CBC:  BRA    1024
0CBE:  MOVLB  7
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0CC0:  MOVLW  04
0CC2:  ADDWF  xFA,W
0CC4:  MOVLB  8
0CC6:  MOVWF  x02
0CC8:  MOVLW  00
0CCA:  MOVLB  7
0CCC:  ADDWFC xFB,W
0CCE:  MOVLB  8
0CD0:  MOVWF  x03
0CD2:  MOVLB  7
0CD4:  MOVF   xF8,W
0CD6:  MOVLB  8
0CD8:  ADDWF  x02,W
0CDA:  MOVWF  FE9
0CDC:  MOVLB  7
0CDE:  MOVF   xF9,W
0CE0:  MOVLB  8
0CE2:  ADDWFC x03,W
0CE4:  MOVWF  FEA
0CE6:  MOVFF  FEF,804
0CEA:  MOVLW  03
0CEC:  MOVLB  7
0CEE:  ADDWF  xFA,W
0CF0:  MOVLB  8
0CF2:  MOVWF  x05
0CF4:  MOVLW  00
0CF6:  MOVLB  7
0CF8:  ADDWFC xFB,W
0CFA:  MOVLB  8
0CFC:  MOVWF  x06
0CFE:  MOVLB  7
0D00:  MOVF   xF8,W
0D02:  MOVLB  8
0D04:  ADDWF  x05,W
0D06:  MOVWF  FE9
0D08:  MOVLB  7
0D0A:  MOVF   xF9,W
0D0C:  MOVLB  8
0D0E:  ADDWFC x06,W
0D10:  MOVWF  FEA
0D12:  MOVFF  FEF,807
0D16:  MOVLW  02
0D18:  MOVLB  7
0D1A:  ADDWF  xFA,W
0D1C:  MOVLB  8
0D1E:  MOVWF  x08
0D20:  MOVLW  00
0D22:  MOVLB  7
0D24:  ADDWFC xFB,W
0D26:  MOVLB  8
0D28:  MOVWF  x09
0D2A:  MOVLB  7
0D2C:  MOVF   xF8,W
0D2E:  MOVLB  8
0D30:  ADDWF  x08,W
0D32:  MOVWF  FE9
0D34:  MOVLB  7
0D36:  MOVF   xF9,W
0D38:  MOVLB  8
0D3A:  ADDWFC x09,W
0D3C:  MOVWF  FEA
0D3E:  MOVFF  FEF,80A
0D42:  MOVLW  01
0D44:  MOVLB  7
0D46:  ADDWF  xFA,W
0D48:  MOVLB  8
0D4A:  MOVWF  x0B
0D4C:  MOVLW  00
0D4E:  MOVLB  7
0D50:  ADDWFC xFB,W
0D52:  MOVLB  8
0D54:  MOVWF  x0C
0D56:  MOVLB  7
0D58:  MOVF   xF8,W
0D5A:  MOVLB  8
0D5C:  ADDWF  x0B,W
0D5E:  MOVWF  FE9
0D60:  MOVLB  7
0D62:  MOVF   xF9,W
0D64:  MOVLB  8
0D66:  ADDWFC x0C,W
0D68:  MOVWF  FEA
0D6A:  MOVFF  FEF,80D
0D6E:  MOVLB  7
0D70:  MOVF   xF8,W
0D72:  ADDWF  xFA,W
0D74:  MOVWF  FE9
0D76:  MOVF   xF9,W
0D78:  ADDWFC xFB,W
0D7A:  MOVWF  FEA
0D7C:  MOVFF  FEF,80E
0D80:  MOVLB  8
0D82:  CLRF   x2D
0D84:  CLRF   x2E
0D86:  CLRF   x2F
0D88:  MOVFF  804,830
0D8C:  MOVFF  807,831
0D90:  MOVFF  80A,832
0D94:  MOVFF  80D,833
0D98:  MOVFF  80E,834
0D9C:  MOVLB  0
0D9E:  CALL   04AC
0DA2:  MOVFF  01,7FE
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0DA6:  MOVLW  09
0DA8:  MOVLB  7
0DAA:  ADDWF  xFA,W
0DAC:  MOVLB  8
0DAE:  MOVWF  x02
0DB0:  MOVLW  00
0DB2:  MOVLB  7
0DB4:  ADDWFC xFB,W
0DB6:  MOVLB  8
0DB8:  MOVWF  x03
0DBA:  MOVLB  7
0DBC:  MOVF   xF8,W
0DBE:  MOVLB  8
0DC0:  ADDWF  x02,W
0DC2:  MOVWF  FE9
0DC4:  MOVLB  7
0DC6:  MOVF   xF9,W
0DC8:  MOVLB  8
0DCA:  ADDWFC x03,W
0DCC:  MOVWF  FEA
0DCE:  MOVFF  FEF,804
0DD2:  MOVLW  08
0DD4:  MOVLB  7
0DD6:  ADDWF  xFA,W
0DD8:  MOVLB  8
0DDA:  MOVWF  x05
0DDC:  MOVLW  00
0DDE:  MOVLB  7
0DE0:  ADDWFC xFB,W
0DE2:  MOVLB  8
0DE4:  MOVWF  x06
0DE6:  MOVLB  7
0DE8:  MOVF   xF8,W
0DEA:  MOVLB  8
0DEC:  ADDWF  x05,W
0DEE:  MOVWF  FE9
0DF0:  MOVLB  7
0DF2:  MOVF   xF9,W
0DF4:  MOVLB  8
0DF6:  ADDWFC x06,W
0DF8:  MOVWF  FEA
0DFA:  MOVFF  FEF,807
0DFE:  MOVLW  07
0E00:  MOVLB  7
0E02:  ADDWF  xFA,W
0E04:  MOVLB  8
0E06:  MOVWF  x08
0E08:  MOVLW  00
0E0A:  MOVLB  7
0E0C:  ADDWFC xFB,W
0E0E:  MOVLB  8
0E10:  MOVWF  x09
0E12:  MOVLB  7
0E14:  MOVF   xF8,W
0E16:  MOVLB  8
0E18:  ADDWF  x08,W
0E1A:  MOVWF  FE9
0E1C:  MOVLB  7
0E1E:  MOVF   xF9,W
0E20:  MOVLB  8
0E22:  ADDWFC x09,W
0E24:  MOVWF  FEA
0E26:  MOVFF  FEF,80A
0E2A:  MOVLW  06
0E2C:  MOVLB  7
0E2E:  ADDWF  xFA,W
0E30:  MOVLB  8
0E32:  MOVWF  x0B
0E34:  MOVLW  00
0E36:  MOVLB  7
0E38:  ADDWFC xFB,W
0E3A:  MOVLB  8
0E3C:  MOVWF  x0C
0E3E:  MOVLB  7
0E40:  MOVF   xF8,W
0E42:  MOVLB  8
0E44:  ADDWF  x0B,W
0E46:  MOVWF  FE9
0E48:  MOVLB  7
0E4A:  MOVF   xF9,W
0E4C:  MOVLB  8
0E4E:  ADDWFC x0C,W
0E50:  MOVWF  FEA
0E52:  MOVFF  FEF,80D
0E56:  MOVLW  05
0E58:  MOVLB  7
0E5A:  ADDWF  xFA,W
0E5C:  MOVLB  8
0E5E:  MOVWF  x0E
0E60:  MOVLW  00
0E62:  MOVLB  7
0E64:  ADDWFC xFB,W
0E66:  MOVLB  8
0E68:  MOVWF  x0F
0E6A:  MOVLB  7
0E6C:  MOVF   xF8,W
0E6E:  MOVLB  8
0E70:  ADDWF  x0E,W
0E72:  MOVWF  FE9
0E74:  MOVLB  7
0E76:  MOVF   xF9,W
0E78:  MOVLB  8
0E7A:  ADDWFC x0F,W
0E7C:  MOVWF  FEA
0E7E:  MOVFF  FEF,810
0E82:  CLRF   x2D
0E84:  CLRF   x2E
0E86:  CLRF   x2F
0E88:  MOVFF  804,830
0E8C:  MOVFF  807,831
0E90:  MOVFF  80A,832
0E94:  MOVFF  80D,833
0E98:  MOVFF  810,834
0E9C:  MOVLB  0
0E9E:  CALL   04AC
0EA2:  MOVFF  01,7FF
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0EA6:  MOVLB  7
0EA8:  MOVF   xFE,W
0EAA:  SUBLW  0B
0EAC:  BTFSS  FD8.2
0EAE:  BRA    1022
0EB0:  MOVF   xFF,W
0EB2:  SUBLW  1F
0EB4:  BTFSC  FD8.2
0EB6:  BRA    1022
0EB8:  MOVF   xFF,W
0EBA:  SUBLW  0F
0EBC:  BTFSC  FD8.2
0EBE:  BRA    1022
....................             { 
....................                j=i; 
0EC0:  MOVFF  7FB,7FD
0EC4:  MOVFF  7FA,7FC
....................                CRC=1; 
0EC8:  MOVLW  01
0ECA:  MOVLB  8
0ECC:  MOVWF  x01
....................                temp2=temp; 
0ECE:  MOVFF  7FE,800
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0ED2:  MOVF   x00,W
0ED4:  SUBLW  1F
0ED6:  BTFSC  FD8.2
0ED8:  BRA    100C
0EDA:  MOVLB  7
0EDC:  MOVF   xFD,W
0EDE:  SUBLW  01
0EE0:  BTFSC  FD8.0
0EE2:  BRA    0EE8
0EE4:  MOVLB  8
0EE6:  BRA    100C
0EE8:  BNZ   0EF6
0EEA:  MOVF   xFC,W
0EEC:  SUBLW  F3
0EEE:  BTFSC  FD8.0
0EF0:  BRA    0EF6
0EF2:  MOVLB  8
0EF4:  BRA    100C
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0EF6:  MOVLB  8
0EF8:  CLRF   x18
0EFA:  MOVFF  7FD,81A
0EFE:  MOVFF  7FC,819
0F02:  MOVFF  7F9,81C
0F06:  MOVFF  7F8,81B
0F0A:  MOVLB  0
0F0C:  CALL   06C2
0F10:  MOVF   01,W
0F12:  MOVLB  8
0F14:  ANDWF  x01,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0F16:  MOVLW  04
0F18:  MOVLB  7
0F1A:  ADDWF  xFC,W
0F1C:  MOVLB  8
0F1E:  MOVWF  x02
0F20:  MOVLW  00
0F22:  MOVLB  7
0F24:  ADDWFC xFD,W
0F26:  MOVLB  8
0F28:  MOVWF  x03
0F2A:  MOVLB  7
0F2C:  MOVF   xF8,W
0F2E:  MOVLB  8
0F30:  ADDWF  x02,W
0F32:  MOVWF  FE9
0F34:  MOVLB  7
0F36:  MOVF   xF9,W
0F38:  MOVLB  8
0F3A:  ADDWFC x03,W
0F3C:  MOVWF  FEA
0F3E:  MOVFF  FEF,804
0F42:  MOVLW  03
0F44:  MOVLB  7
0F46:  ADDWF  xFC,W
0F48:  MOVLB  8
0F4A:  MOVWF  x05
0F4C:  MOVLW  00
0F4E:  MOVLB  7
0F50:  ADDWFC xFD,W
0F52:  MOVLB  8
0F54:  MOVWF  x06
0F56:  MOVLB  7
0F58:  MOVF   xF8,W
0F5A:  MOVLB  8
0F5C:  ADDWF  x05,W
0F5E:  MOVWF  FE9
0F60:  MOVLB  7
0F62:  MOVF   xF9,W
0F64:  MOVLB  8
0F66:  ADDWFC x06,W
0F68:  MOVWF  FEA
0F6A:  MOVFF  FEF,807
0F6E:  MOVLW  02
0F70:  MOVLB  7
0F72:  ADDWF  xFC,W
0F74:  MOVLB  8
0F76:  MOVWF  x08
0F78:  MOVLW  00
0F7A:  MOVLB  7
0F7C:  ADDWFC xFD,W
0F7E:  MOVLB  8
0F80:  MOVWF  x09
0F82:  MOVLB  7
0F84:  MOVF   xF8,W
0F86:  MOVLB  8
0F88:  ADDWF  x08,W
0F8A:  MOVWF  FE9
0F8C:  MOVLB  7
0F8E:  MOVF   xF9,W
0F90:  MOVLB  8
0F92:  ADDWFC x09,W
0F94:  MOVWF  FEA
0F96:  MOVFF  FEF,80A
0F9A:  MOVLW  01
0F9C:  MOVLB  7
0F9E:  ADDWF  xFC,W
0FA0:  MOVLB  8
0FA2:  MOVWF  x0B
0FA4:  MOVLW  00
0FA6:  MOVLB  7
0FA8:  ADDWFC xFD,W
0FAA:  MOVLB  8
0FAC:  MOVWF  x0C
0FAE:  MOVLB  7
0FB0:  MOVF   xF8,W
0FB2:  MOVLB  8
0FB4:  ADDWF  x0B,W
0FB6:  MOVWF  FE9
0FB8:  MOVLB  7
0FBA:  MOVF   xF9,W
0FBC:  MOVLB  8
0FBE:  ADDWFC x0C,W
0FC0:  MOVWF  FEA
0FC2:  MOVFF  FEF,80D
0FC6:  MOVLB  7
0FC8:  MOVF   xF8,W
0FCA:  ADDWF  xFC,W
0FCC:  MOVWF  FE9
0FCE:  MOVF   xF9,W
0FD0:  ADDWFC xFD,W
0FD2:  MOVWF  FEA
0FD4:  MOVFF  FEF,80E
0FD8:  MOVLB  8
0FDA:  CLRF   x2D
0FDC:  CLRF   x2E
0FDE:  CLRF   x2F
0FE0:  MOVFF  804,830
0FE4:  MOVFF  807,831
0FE8:  MOVFF  80A,832
0FEC:  MOVFF  80D,833
0FF0:  MOVFF  80E,834
0FF4:  MOVLB  0
0FF6:  CALL   04AC
0FFA:  MOVFF  01,800
....................                   j=j+5; 
0FFE:  MOVLW  05
1000:  MOVLB  7
1002:  ADDWF  xFC,F
1004:  MOVLW  00
1006:  ADDWFC xFD,F
....................                } 
1008:  MOVLB  8
100A:  BRA    0ED2
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
100C:  DECFSZ x01,W
100E:  BRA    1024
....................                { 
....................                   dir=0; 
1010:  MOVLB  6
1012:  CLRF   x8F
....................                   return i; 
1014:  MOVLB  7
1016:  MOVFF  7FA,01
101A:  MOVFF  7FB,02
101E:  GOTO   1878
1022:  MOVLB  8
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
1024:  MOVLB  7
1026:  INCF   xFA,F
1028:  BTFSC  FD8.2
102A:  INCF   xFB,F
102C:  GOTO   0814
....................    for(i=end_point;i>end_point/4;i--) 
1030:  MOVFF  7F7,7FB
1034:  MOVFF  7F6,7FA
1038:  RRCF   xF7,W
103A:  MOVWF  03
103C:  RRCF   xF6,W
103E:  MOVWF  02
1040:  RRCF   03,F
1042:  RRCF   02,F
1044:  MOVLW  3F
1046:  ANDWF  03,F
1048:  MOVFF  02,01
104C:  MOVF   03,W
104E:  SUBWF  xFB,W
1050:  BTFSS  FD8.0
1052:  GOTO   1872
1056:  BNZ   1062
1058:  MOVF   xFA,W
105A:  SUBWF  01,W
105C:  BTFSC  FD8.0
105E:  GOTO   1872
....................    { 
....................       if(track==0) 
1062:  MOVF   xF5,F
1064:  BTFSS  FD8.2
1066:  BRA    14FE
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1068:  MOVLW  06
106A:  SUBWF  xFA,W
106C:  MOVLB  8
106E:  MOVWF  x02
1070:  MOVLW  00
1072:  MOVLB  7
1074:  SUBWFB xFB,W
1076:  MOVLB  8
1078:  MOVWF  x03
107A:  MOVLB  7
107C:  MOVF   xF8,W
107E:  MOVLB  8
1080:  ADDWF  x02,W
1082:  MOVWF  FE9
1084:  MOVLB  7
1086:  MOVF   xF9,W
1088:  MOVLB  8
108A:  ADDWFC x03,W
108C:  MOVWF  FEA
108E:  MOVFF  FEF,804
1092:  MOVLW  05
1094:  MOVLB  7
1096:  SUBWF  xFA,W
1098:  MOVLB  8
109A:  MOVWF  x05
109C:  MOVLW  00
109E:  MOVLB  7
10A0:  SUBWFB xFB,W
10A2:  MOVLB  8
10A4:  MOVWF  x06
10A6:  MOVLB  7
10A8:  MOVF   xF8,W
10AA:  MOVLB  8
10AC:  ADDWF  x05,W
10AE:  MOVWF  FE9
10B0:  MOVLB  7
10B2:  MOVF   xF9,W
10B4:  MOVLB  8
10B6:  ADDWFC x06,W
10B8:  MOVWF  FEA
10BA:  MOVFF  FEF,807
10BE:  MOVLW  04
10C0:  MOVLB  7
10C2:  SUBWF  xFA,W
10C4:  MOVLB  8
10C6:  MOVWF  x08
10C8:  MOVLW  00
10CA:  MOVLB  7
10CC:  SUBWFB xFB,W
10CE:  MOVLB  8
10D0:  MOVWF  x09
10D2:  MOVLB  7
10D4:  MOVF   xF8,W
10D6:  MOVLB  8
10D8:  ADDWF  x08,W
10DA:  MOVWF  FE9
10DC:  MOVLB  7
10DE:  MOVF   xF9,W
10E0:  MOVLB  8
10E2:  ADDWFC x09,W
10E4:  MOVWF  FEA
10E6:  MOVFF  FEF,80A
10EA:  MOVLW  03
10EC:  MOVLB  7
10EE:  SUBWF  xFA,W
10F0:  MOVLB  8
10F2:  MOVWF  x0B
10F4:  MOVLW  00
10F6:  MOVLB  7
10F8:  SUBWFB xFB,W
10FA:  MOVLB  8
10FC:  MOVWF  x0C
10FE:  MOVLB  7
1100:  MOVF   xF8,W
1102:  MOVLB  8
1104:  ADDWF  x0B,W
1106:  MOVWF  FE9
1108:  MOVLB  7
110A:  MOVF   xF9,W
110C:  MOVLB  8
110E:  ADDWFC x0C,W
1110:  MOVWF  FEA
1112:  MOVFF  FEF,80D
1116:  MOVLW  02
1118:  MOVLB  7
111A:  SUBWF  xFA,W
111C:  MOVLB  8
111E:  MOVWF  x0E
1120:  MOVLW  00
1122:  MOVLB  7
1124:  SUBWFB xFB,W
1126:  MOVLB  8
1128:  MOVWF  x0F
112A:  MOVLB  7
112C:  MOVF   xF8,W
112E:  MOVLB  8
1130:  ADDWF  x0E,W
1132:  MOVWF  FE9
1134:  MOVLB  7
1136:  MOVF   xF9,W
1138:  MOVLB  8
113A:  ADDWFC x0F,W
113C:  MOVWF  FEA
113E:  MOVFF  FEF,810
1142:  MOVLW  01
1144:  MOVLB  7
1146:  SUBWF  xFA,W
1148:  MOVLB  8
114A:  MOVWF  x11
114C:  MOVLW  00
114E:  MOVLB  7
1150:  SUBWFB xFB,W
1152:  MOVLB  8
1154:  MOVWF  x12
1156:  MOVLB  7
1158:  MOVF   xF8,W
115A:  MOVLB  8
115C:  ADDWF  x11,W
115E:  MOVWF  FE9
1160:  MOVLB  7
1162:  MOVF   xF9,W
1164:  MOVLB  8
1166:  ADDWFC x12,W
1168:  MOVWF  FEA
116A:  MOVFF  FEF,813
116E:  MOVLB  7
1170:  MOVF   xF8,W
1172:  ADDWF  xFA,W
1174:  MOVWF  FE9
1176:  MOVF   xF9,W
1178:  ADDWFC xFB,W
117A:  MOVWF  FEA
117C:  MOVFF  FEF,814
1180:  MOVLB  8
1182:  CLRF   x2D
1184:  MOVFF  804,82E
1188:  MOVFF  807,82F
118C:  MOVFF  80A,830
1190:  MOVFF  80D,831
1194:  MOVFF  810,832
1198:  MOVFF  813,833
119C:  MOVFF  814,834
11A0:  MOVLB  0
11A2:  CALL   04AC
11A6:  MOVFF  01,7FE
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
11AA:  MOVLW  0D
11AC:  MOVLB  7
11AE:  SUBWF  xFA,W
11B0:  MOVLB  8
11B2:  MOVWF  x02
11B4:  MOVLW  00
11B6:  MOVLB  7
11B8:  SUBWFB xFB,W
11BA:  MOVLB  8
11BC:  MOVWF  x03
11BE:  MOVLB  7
11C0:  MOVF   xF8,W
11C2:  MOVLB  8
11C4:  ADDWF  x02,W
11C6:  MOVWF  FE9
11C8:  MOVLB  7
11CA:  MOVF   xF9,W
11CC:  MOVLB  8
11CE:  ADDWFC x03,W
11D0:  MOVWF  FEA
11D2:  MOVFF  FEF,804
11D6:  MOVLW  0C
11D8:  MOVLB  7
11DA:  SUBWF  xFA,W
11DC:  MOVLB  8
11DE:  MOVWF  x05
11E0:  MOVLW  00
11E2:  MOVLB  7
11E4:  SUBWFB xFB,W
11E6:  MOVLB  8
11E8:  MOVWF  x06
11EA:  MOVLB  7
11EC:  MOVF   xF8,W
11EE:  MOVLB  8
11F0:  ADDWF  x05,W
11F2:  MOVWF  FE9
11F4:  MOVLB  7
11F6:  MOVF   xF9,W
11F8:  MOVLB  8
11FA:  ADDWFC x06,W
11FC:  MOVWF  FEA
11FE:  MOVFF  FEF,807
1202:  MOVLW  0B
1204:  MOVLB  7
1206:  SUBWF  xFA,W
1208:  MOVLB  8
120A:  MOVWF  x08
120C:  MOVLW  00
120E:  MOVLB  7
1210:  SUBWFB xFB,W
1212:  MOVLB  8
1214:  MOVWF  x09
1216:  MOVLB  7
1218:  MOVF   xF8,W
121A:  MOVLB  8
121C:  ADDWF  x08,W
121E:  MOVWF  FE9
1220:  MOVLB  7
1222:  MOVF   xF9,W
1224:  MOVLB  8
1226:  ADDWFC x09,W
1228:  MOVWF  FEA
122A:  MOVFF  FEF,80A
122E:  MOVLW  0A
1230:  MOVLB  7
1232:  SUBWF  xFA,W
1234:  MOVLB  8
1236:  MOVWF  x0B
1238:  MOVLW  00
123A:  MOVLB  7
123C:  SUBWFB xFB,W
123E:  MOVLB  8
1240:  MOVWF  x0C
1242:  MOVLB  7
1244:  MOVF   xF8,W
1246:  MOVLB  8
1248:  ADDWF  x0B,W
124A:  MOVWF  FE9
124C:  MOVLB  7
124E:  MOVF   xF9,W
1250:  MOVLB  8
1252:  ADDWFC x0C,W
1254:  MOVWF  FEA
1256:  MOVFF  FEF,80D
125A:  MOVLW  09
125C:  MOVLB  7
125E:  SUBWF  xFA,W
1260:  MOVLB  8
1262:  MOVWF  x0E
1264:  MOVLW  00
1266:  MOVLB  7
1268:  SUBWFB xFB,W
126A:  MOVLB  8
126C:  MOVWF  x0F
126E:  MOVLB  7
1270:  MOVF   xF8,W
1272:  MOVLB  8
1274:  ADDWF  x0E,W
1276:  MOVWF  FE9
1278:  MOVLB  7
127A:  MOVF   xF9,W
127C:  MOVLB  8
127E:  ADDWFC x0F,W
1280:  MOVWF  FEA
1282:  MOVFF  FEF,810
1286:  MOVLW  08
1288:  MOVLB  7
128A:  SUBWF  xFA,W
128C:  MOVLB  8
128E:  MOVWF  x11
1290:  MOVLW  00
1292:  MOVLB  7
1294:  SUBWFB xFB,W
1296:  MOVLB  8
1298:  MOVWF  x12
129A:  MOVLB  7
129C:  MOVF   xF8,W
129E:  MOVLB  8
12A0:  ADDWF  x11,W
12A2:  MOVWF  FE9
12A4:  MOVLB  7
12A6:  MOVF   xF9,W
12A8:  MOVLB  8
12AA:  ADDWFC x12,W
12AC:  MOVWF  FEA
12AE:  MOVFF  FEF,813
12B2:  MOVLW  07
12B4:  MOVLB  7
12B6:  SUBWF  xFA,W
12B8:  MOVLB  8
12BA:  MOVWF  x14
12BC:  MOVLW  00
12BE:  MOVLB  7
12C0:  SUBWFB xFB,W
12C2:  MOVLB  8
12C4:  MOVWF  x15
12C6:  MOVLB  7
12C8:  MOVF   xF8,W
12CA:  MOVLB  8
12CC:  ADDWF  x14,W
12CE:  MOVWF  FE9
12D0:  MOVLB  7
12D2:  MOVF   xF9,W
12D4:  MOVLB  8
12D6:  ADDWFC x15,W
12D8:  MOVWF  FEA
12DA:  MOVFF  FEF,816
12DE:  CLRF   x2D
12E0:  MOVFF  804,82E
12E4:  MOVFF  807,82F
12E8:  MOVFF  80A,830
12EC:  MOVFF  80D,831
12F0:  MOVFF  810,832
12F4:  MOVFF  813,833
12F8:  MOVFF  816,834
12FC:  MOVLB  0
12FE:  CALL   04AC
1302:  MOVFF  01,7FF
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
1306:  MOVLB  7
1308:  MOVF   xFE,W
130A:  SUBLW  45
130C:  BTFSS  FD8.2
130E:  BRA    14FC
1310:  MOVF   xFF,W
1312:  SUBLW  7C
1314:  BTFSC  FD8.2
1316:  BRA    14FC
1318:  MOVF   xFF,W
131A:  SUBLW  3E
131C:  BTFSC  FD8.2
131E:  BRA    14FC
1320:  MOVF   xFF,W
1322:  SUBLW  1F
1324:  BTFSC  FD8.2
1326:  BRA    14FC
1328:  MOVF   xFF,W
132A:  SUBLW  0F
132C:  BTFSC  FD8.2
132E:  BRA    14FC
1330:  MOVF   xFF,W
1332:  SUBLW  78
1334:  BTFSC  FD8.2
1336:  BRA    14FC
....................          { 
....................             j=i; 
1338:  MOVFF  7FB,7FD
133C:  MOVFF  7FA,7FC
....................             CRC=1; 
1340:  MOVLW  01
1342:  MOVLB  8
1344:  MOVWF  x01
....................             temp2=temp; 
1346:  MOVFF  7FE,800
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
134A:  MOVF   x00,W
134C:  SUBLW  1F
134E:  BTFSC  FD8.2
1350:  BRA    14D8
1352:  MOVLB  7
1354:  MOVF   xFD,F
1356:  BNZ   1364
1358:  MOVF   xFC,W
135A:  SUBLW  01
135C:  BTFSS  FD8.0
135E:  BRA    1364
1360:  MOVLB  8
1362:  BRA    14D8
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1364:  MOVLW  01
1366:  MOVLB  8
1368:  MOVWF  x18
136A:  MOVFF  7FD,81A
136E:  MOVFF  7FC,819
1372:  MOVFF  7F9,81C
1376:  MOVFF  7F8,81B
137A:  MOVLB  0
137C:  CALL   0512
1380:  MOVF   01,W
1382:  MOVLB  8
1384:  ANDWF  x01,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1386:  MOVLW  06
1388:  MOVLB  7
138A:  SUBWF  xFC,W
138C:  MOVLB  8
138E:  MOVWF  x02
1390:  MOVLW  00
1392:  MOVLB  7
1394:  SUBWFB xFD,W
1396:  MOVLB  8
1398:  MOVWF  x03
139A:  MOVLB  7
139C:  MOVF   xF8,W
139E:  MOVLB  8
13A0:  ADDWF  x02,W
13A2:  MOVWF  FE9
13A4:  MOVLB  7
13A6:  MOVF   xF9,W
13A8:  MOVLB  8
13AA:  ADDWFC x03,W
13AC:  MOVWF  FEA
13AE:  MOVFF  FEF,804
13B2:  MOVLW  05
13B4:  MOVLB  7
13B6:  SUBWF  xFC,W
13B8:  MOVLB  8
13BA:  MOVWF  x05
13BC:  MOVLW  00
13BE:  MOVLB  7
13C0:  SUBWFB xFD,W
13C2:  MOVLB  8
13C4:  MOVWF  x06
13C6:  MOVLB  7
13C8:  MOVF   xF8,W
13CA:  MOVLB  8
13CC:  ADDWF  x05,W
13CE:  MOVWF  FE9
13D0:  MOVLB  7
13D2:  MOVF   xF9,W
13D4:  MOVLB  8
13D6:  ADDWFC x06,W
13D8:  MOVWF  FEA
13DA:  MOVFF  FEF,807
13DE:  MOVLW  04
13E0:  MOVLB  7
13E2:  SUBWF  xFC,W
13E4:  MOVLB  8
13E6:  MOVWF  x08
13E8:  MOVLW  00
13EA:  MOVLB  7
13EC:  SUBWFB xFD,W
13EE:  MOVLB  8
13F0:  MOVWF  x09
13F2:  MOVLB  7
13F4:  MOVF   xF8,W
13F6:  MOVLB  8
13F8:  ADDWF  x08,W
13FA:  MOVWF  FE9
13FC:  MOVLB  7
13FE:  MOVF   xF9,W
1400:  MOVLB  8
1402:  ADDWFC x09,W
1404:  MOVWF  FEA
1406:  MOVFF  FEF,80A
140A:  MOVLW  03
140C:  MOVLB  7
140E:  SUBWF  xFC,W
1410:  MOVLB  8
1412:  MOVWF  x0B
1414:  MOVLW  00
1416:  MOVLB  7
1418:  SUBWFB xFD,W
141A:  MOVLB  8
141C:  MOVWF  x0C
141E:  MOVLB  7
1420:  MOVF   xF8,W
1422:  MOVLB  8
1424:  ADDWF  x0B,W
1426:  MOVWF  FE9
1428:  MOVLB  7
142A:  MOVF   xF9,W
142C:  MOVLB  8
142E:  ADDWFC x0C,W
1430:  MOVWF  FEA
1432:  MOVFF  FEF,80D
1436:  MOVLW  02
1438:  MOVLB  7
143A:  SUBWF  xFC,W
143C:  MOVLB  8
143E:  MOVWF  x0E
1440:  MOVLW  00
1442:  MOVLB  7
1444:  SUBWFB xFD,W
1446:  MOVLB  8
1448:  MOVWF  x0F
144A:  MOVLB  7
144C:  MOVF   xF8,W
144E:  MOVLB  8
1450:  ADDWF  x0E,W
1452:  MOVWF  FE9
1454:  MOVLB  7
1456:  MOVF   xF9,W
1458:  MOVLB  8
145A:  ADDWFC x0F,W
145C:  MOVWF  FEA
145E:  MOVFF  FEF,810
1462:  MOVLW  01
1464:  MOVLB  7
1466:  SUBWF  xFC,W
1468:  MOVLB  8
146A:  MOVWF  x11
146C:  MOVLW  00
146E:  MOVLB  7
1470:  SUBWFB xFD,W
1472:  MOVLB  8
1474:  MOVWF  x12
1476:  MOVLB  7
1478:  MOVF   xF8,W
147A:  MOVLB  8
147C:  ADDWF  x11,W
147E:  MOVWF  FE9
1480:  MOVLB  7
1482:  MOVF   xF9,W
1484:  MOVLB  8
1486:  ADDWFC x12,W
1488:  MOVWF  FEA
148A:  MOVFF  FEF,813
148E:  MOVLB  7
1490:  MOVF   xF8,W
1492:  ADDWF  xFC,W
1494:  MOVWF  FE9
1496:  MOVF   xF9,W
1498:  ADDWFC xFD,W
149A:  MOVWF  FEA
149C:  MOVFF  FEF,814
14A0:  MOVLB  8
14A2:  CLRF   x2D
14A4:  MOVFF  804,82E
14A8:  MOVFF  807,82F
14AC:  MOVFF  80A,830
14B0:  MOVFF  80D,831
14B4:  MOVFF  810,832
14B8:  MOVFF  813,833
14BC:  MOVFF  814,834
14C0:  MOVLB  0
14C2:  CALL   04AC
14C6:  MOVFF  01,800
....................                j=j-7;             
14CA:  MOVLW  07
14CC:  MOVLB  7
14CE:  SUBWF  xFC,F
14D0:  MOVLW  00
14D2:  SUBWFB xFD,F
....................              } 
14D4:  MOVLB  8
14D6:  BRA    134A
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
14D8:  DECFSZ x01,W
14DA:  BRA    14F2
....................             { 
....................                dir=1; 
14DC:  MOVLW  01
14DE:  MOVLB  6
14E0:  MOVWF  x8F
....................                return i; 
14E2:  MOVLB  7
14E4:  MOVFF  7FA,01
14E8:  MOVFF  7FB,02
14EC:  BRA    1878
....................             } 
....................             else return 0; 
14EE:  BRA    14FC
14F0:  MOVLB  8
14F2:  MOVLW  00
14F4:  MOVWF  01
14F6:  MOVWF  02
14F8:  MOVLB  7
14FA:  BRA    1878
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
14FC:  BRA    1866
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
14FE:  MOVLW  04
1500:  SUBWF  xFA,W
1502:  MOVLB  8
1504:  MOVWF  x02
1506:  MOVLW  00
1508:  MOVLB  7
150A:  SUBWFB xFB,W
150C:  MOVLB  8
150E:  MOVWF  x03
1510:  MOVLB  7
1512:  MOVF   xF8,W
1514:  MOVLB  8
1516:  ADDWF  x02,W
1518:  MOVWF  FE9
151A:  MOVLB  7
151C:  MOVF   xF9,W
151E:  MOVLB  8
1520:  ADDWFC x03,W
1522:  MOVWF  FEA
1524:  MOVFF  FEF,804
1528:  MOVLW  03
152A:  MOVLB  7
152C:  SUBWF  xFA,W
152E:  MOVLB  8
1530:  MOVWF  x05
1532:  MOVLW  00
1534:  MOVLB  7
1536:  SUBWFB xFB,W
1538:  MOVLB  8
153A:  MOVWF  x06
153C:  MOVLB  7
153E:  MOVF   xF8,W
1540:  MOVLB  8
1542:  ADDWF  x05,W
1544:  MOVWF  FE9
1546:  MOVLB  7
1548:  MOVF   xF9,W
154A:  MOVLB  8
154C:  ADDWFC x06,W
154E:  MOVWF  FEA
1550:  MOVFF  FEF,807
1554:  MOVLW  02
1556:  MOVLB  7
1558:  SUBWF  xFA,W
155A:  MOVLB  8
155C:  MOVWF  x08
155E:  MOVLW  00
1560:  MOVLB  7
1562:  SUBWFB xFB,W
1564:  MOVLB  8
1566:  MOVWF  x09
1568:  MOVLB  7
156A:  MOVF   xF8,W
156C:  MOVLB  8
156E:  ADDWF  x08,W
1570:  MOVWF  FE9
1572:  MOVLB  7
1574:  MOVF   xF9,W
1576:  MOVLB  8
1578:  ADDWFC x09,W
157A:  MOVWF  FEA
157C:  MOVFF  FEF,80A
1580:  MOVLW  01
1582:  MOVLB  7
1584:  SUBWF  xFA,W
1586:  MOVLB  8
1588:  MOVWF  x0B
158A:  MOVLW  00
158C:  MOVLB  7
158E:  SUBWFB xFB,W
1590:  MOVLB  8
1592:  MOVWF  x0C
1594:  MOVLB  7
1596:  MOVF   xF8,W
1598:  MOVLB  8
159A:  ADDWF  x0B,W
159C:  MOVWF  FE9
159E:  MOVLB  7
15A0:  MOVF   xF9,W
15A2:  MOVLB  8
15A4:  ADDWFC x0C,W
15A6:  MOVWF  FEA
15A8:  MOVFF  FEF,80D
15AC:  MOVLB  7
15AE:  MOVF   xF8,W
15B0:  ADDWF  xFA,W
15B2:  MOVWF  FE9
15B4:  MOVF   xF9,W
15B6:  ADDWFC xFB,W
15B8:  MOVWF  FEA
15BA:  MOVFF  FEF,80E
15BE:  MOVLB  8
15C0:  CLRF   x2D
15C2:  CLRF   x2E
15C4:  CLRF   x2F
15C6:  MOVFF  804,830
15CA:  MOVFF  807,831
15CE:  MOVFF  80A,832
15D2:  MOVFF  80D,833
15D6:  MOVFF  80E,834
15DA:  MOVLB  0
15DC:  CALL   04AC
15E0:  MOVFF  01,7FE
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
15E4:  MOVLW  09
15E6:  MOVLB  7
15E8:  SUBWF  xFA,W
15EA:  MOVLB  8
15EC:  MOVWF  x02
15EE:  MOVLW  00
15F0:  MOVLB  7
15F2:  SUBWFB xFB,W
15F4:  MOVLB  8
15F6:  MOVWF  x03
15F8:  MOVLB  7
15FA:  MOVF   xF8,W
15FC:  MOVLB  8
15FE:  ADDWF  x02,W
1600:  MOVWF  FE9
1602:  MOVLB  7
1604:  MOVF   xF9,W
1606:  MOVLB  8
1608:  ADDWFC x03,W
160A:  MOVWF  FEA
160C:  MOVFF  FEF,804
1610:  MOVLW  08
1612:  MOVLB  7
1614:  SUBWF  xFA,W
1616:  MOVLB  8
1618:  MOVWF  x05
161A:  MOVLW  00
161C:  MOVLB  7
161E:  SUBWFB xFB,W
1620:  MOVLB  8
1622:  MOVWF  x06
1624:  MOVLB  7
1626:  MOVF   xF8,W
1628:  MOVLB  8
162A:  ADDWF  x05,W
162C:  MOVWF  FE9
162E:  MOVLB  7
1630:  MOVF   xF9,W
1632:  MOVLB  8
1634:  ADDWFC x06,W
1636:  MOVWF  FEA
1638:  MOVFF  FEF,807
163C:  MOVLW  07
163E:  MOVLB  7
1640:  SUBWF  xFA,W
1642:  MOVLB  8
1644:  MOVWF  x08
1646:  MOVLW  00
1648:  MOVLB  7
164A:  SUBWFB xFB,W
164C:  MOVLB  8
164E:  MOVWF  x09
1650:  MOVLB  7
1652:  MOVF   xF8,W
1654:  MOVLB  8
1656:  ADDWF  x08,W
1658:  MOVWF  FE9
165A:  MOVLB  7
165C:  MOVF   xF9,W
165E:  MOVLB  8
1660:  ADDWFC x09,W
1662:  MOVWF  FEA
1664:  MOVFF  FEF,80A
1668:  MOVLW  06
166A:  MOVLB  7
166C:  SUBWF  xFA,W
166E:  MOVLB  8
1670:  MOVWF  x0B
1672:  MOVLW  00
1674:  MOVLB  7
1676:  SUBWFB xFB,W
1678:  MOVLB  8
167A:  MOVWF  x0C
167C:  MOVLB  7
167E:  MOVF   xF8,W
1680:  MOVLB  8
1682:  ADDWF  x0B,W
1684:  MOVWF  FE9
1686:  MOVLB  7
1688:  MOVF   xF9,W
168A:  MOVLB  8
168C:  ADDWFC x0C,W
168E:  MOVWF  FEA
1690:  MOVFF  FEF,80D
1694:  MOVLW  05
1696:  MOVLB  7
1698:  SUBWF  xFA,W
169A:  MOVLB  8
169C:  MOVWF  x0E
169E:  MOVLW  00
16A0:  MOVLB  7
16A2:  SUBWFB xFB,W
16A4:  MOVLB  8
16A6:  MOVWF  x0F
16A8:  MOVLB  7
16AA:  MOVF   xF8,W
16AC:  MOVLB  8
16AE:  ADDWF  x0E,W
16B0:  MOVWF  FE9
16B2:  MOVLB  7
16B4:  MOVF   xF9,W
16B6:  MOVLB  8
16B8:  ADDWFC x0F,W
16BA:  MOVWF  FEA
16BC:  MOVFF  FEF,810
16C0:  CLRF   x2D
16C2:  CLRF   x2E
16C4:  CLRF   x2F
16C6:  MOVFF  804,830
16CA:  MOVFF  807,831
16CE:  MOVFF  80A,832
16D2:  MOVFF  80D,833
16D6:  MOVFF  810,834
16DA:  MOVLB  0
16DC:  CALL   04AC
16E0:  MOVFF  01,7FF
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
16E4:  MOVLB  7
16E6:  MOVF   xFE,W
16E8:  SUBLW  0B
16EA:  BTFSS  FD8.2
16EC:  BRA    1866
16EE:  MOVF   xFF,W
16F0:  SUBLW  1F
16F2:  BTFSC  FD8.2
16F4:  BRA    1866
16F6:  MOVF   xFF,W
16F8:  SUBLW  0F
16FA:  BTFSC  FD8.2
16FC:  BRA    1866
....................             { 
....................                j=i; 
16FE:  MOVFF  7FB,7FD
1702:  MOVFF  7FA,7FC
....................                CRC=1; 
1706:  MOVLW  01
1708:  MOVLB  8
170A:  MOVWF  x01
....................                temp2=temp; 
170C:  MOVFF  7FE,800
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
1710:  MOVF   x00,W
1712:  SUBLW  1F
1714:  BTFSC  FD8.2
1716:  BRA    1842
1718:  MOVLB  7
171A:  MOVF   xFD,F
171C:  BNZ   172A
171E:  MOVF   xFC,W
1720:  SUBLW  01
1722:  BTFSS  FD8.0
1724:  BRA    172A
1726:  MOVLB  8
1728:  BRA    1842
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
172A:  MOVLW  01
172C:  MOVLB  8
172E:  MOVWF  x18
1730:  MOVFF  7FD,81A
1734:  MOVFF  7FC,819
1738:  MOVFF  7F9,81C
173C:  MOVFF  7F8,81B
1740:  MOVLB  0
1742:  CALL   06C2
1746:  MOVF   01,W
1748:  MOVLB  8
174A:  ANDWF  x01,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
174C:  MOVLW  04
174E:  MOVLB  7
1750:  SUBWF  xFC,W
1752:  MOVLB  8
1754:  MOVWF  x02
1756:  MOVLW  00
1758:  MOVLB  7
175A:  SUBWFB xFD,W
175C:  MOVLB  8
175E:  MOVWF  x03
1760:  MOVLB  7
1762:  MOVF   xF8,W
1764:  MOVLB  8
1766:  ADDWF  x02,W
1768:  MOVWF  FE9
176A:  MOVLB  7
176C:  MOVF   xF9,W
176E:  MOVLB  8
1770:  ADDWFC x03,W
1772:  MOVWF  FEA
1774:  MOVFF  FEF,804
1778:  MOVLW  03
177A:  MOVLB  7
177C:  SUBWF  xFC,W
177E:  MOVLB  8
1780:  MOVWF  x05
1782:  MOVLW  00
1784:  MOVLB  7
1786:  SUBWFB xFD,W
1788:  MOVLB  8
178A:  MOVWF  x06
178C:  MOVLB  7
178E:  MOVF   xF8,W
1790:  MOVLB  8
1792:  ADDWF  x05,W
1794:  MOVWF  FE9
1796:  MOVLB  7
1798:  MOVF   xF9,W
179A:  MOVLB  8
179C:  ADDWFC x06,W
179E:  MOVWF  FEA
17A0:  MOVFF  FEF,807
17A4:  MOVLW  02
17A6:  MOVLB  7
17A8:  SUBWF  xFC,W
17AA:  MOVLB  8
17AC:  MOVWF  x08
17AE:  MOVLW  00
17B0:  MOVLB  7
17B2:  SUBWFB xFD,W
17B4:  MOVLB  8
17B6:  MOVWF  x09
17B8:  MOVLB  7
17BA:  MOVF   xF8,W
17BC:  MOVLB  8
17BE:  ADDWF  x08,W
17C0:  MOVWF  FE9
17C2:  MOVLB  7
17C4:  MOVF   xF9,W
17C6:  MOVLB  8
17C8:  ADDWFC x09,W
17CA:  MOVWF  FEA
17CC:  MOVFF  FEF,80A
17D0:  MOVLW  01
17D2:  MOVLB  7
17D4:  SUBWF  xFC,W
17D6:  MOVLB  8
17D8:  MOVWF  x0B
17DA:  MOVLW  00
17DC:  MOVLB  7
17DE:  SUBWFB xFD,W
17E0:  MOVLB  8
17E2:  MOVWF  x0C
17E4:  MOVLB  7
17E6:  MOVF   xF8,W
17E8:  MOVLB  8
17EA:  ADDWF  x0B,W
17EC:  MOVWF  FE9
17EE:  MOVLB  7
17F0:  MOVF   xF9,W
17F2:  MOVLB  8
17F4:  ADDWFC x0C,W
17F6:  MOVWF  FEA
17F8:  MOVFF  FEF,80D
17FC:  MOVLB  7
17FE:  MOVF   xF8,W
1800:  ADDWF  xFC,W
1802:  MOVWF  FE9
1804:  MOVF   xF9,W
1806:  ADDWFC xFD,W
1808:  MOVWF  FEA
180A:  MOVFF  FEF,80E
180E:  MOVLB  8
1810:  CLRF   x2D
1812:  CLRF   x2E
1814:  CLRF   x2F
1816:  MOVFF  804,830
181A:  MOVFF  807,831
181E:  MOVFF  80A,832
1822:  MOVFF  80D,833
1826:  MOVFF  80E,834
182A:  MOVLB  0
182C:  CALL   04AC
1830:  MOVFF  01,800
....................                   j=j-5; 
1834:  MOVLW  05
1836:  MOVLB  7
1838:  SUBWF  xFC,F
183A:  MOVLW  00
183C:  SUBWFB xFD,F
....................                } 
183E:  MOVLB  8
1840:  BRA    1710
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
1842:  DECFSZ x01,W
1844:  BRA    185C
....................                { 
....................                   dir=1; 
1846:  MOVLW  01
1848:  MOVLB  6
184A:  MOVWF  x8F
....................                   return i; 
184C:  MOVLB  7
184E:  MOVFF  7FA,01
1852:  MOVFF  7FB,02
1856:  BRA    1878
....................                } 
....................                   else return 0; 
1858:  BRA    1866
185A:  MOVLB  8
185C:  MOVLW  00
185E:  MOVWF  01
1860:  MOVWF  02
1862:  MOVLB  7
1864:  BRA    1878
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
1866:  MOVF   xFA,W
1868:  BTFSC  FD8.2
186A:  DECF   xFB,F
186C:  DECF   xFA,F
186E:  GOTO   1038
....................    return 0; 
1872:  MOVLW  00
1874:  MOVWF  01
1876:  MOVWF  02
.................... } 
1878:  MOVLB  0
187A:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
3966:  MOVLB  7
3968:  CLRF   xF4
396A:  MOVLW  01
396C:  MOVWF  xF3
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
396E:  MOVFF  7E9,7F5
3972:  MOVFF  7EB,7F7
3976:  MOVFF  7EA,7F6
397A:  MOVFF  7ED,7F9
397E:  MOVFF  7EC,7F8
3982:  MOVLB  0
3984:  CALL   0802
3988:  MOVFF  02,7F4
398C:  MOVFF  01,7F3
....................    if(temp==0) return 0; 
3990:  MOVLB  7
3992:  MOVF   xF3,F
3994:  BNZ   39A0
3996:  MOVF   xF4,F
3998:  BNZ   39A0
399A:  MOVLW  00
399C:  MOVWF  01
399E:  BRA    3D96
....................    j=temp; 
39A0:  MOVFF  7F4,7F2
39A4:  MOVFF  7F3,7F1
....................    if(dir==0) 
39A8:  MOVLB  6
39AA:  MOVF   x8F,F
39AC:  BTFSS  FD8.2
39AE:  BRA    3B90
....................    { 
....................       if(track==0) 
39B0:  MOVLB  7
39B2:  MOVF   xE9,F
39B4:  BTFSS  FD8.2
39B6:  BRA    3AD2
....................       { 
....................             for(i=0;i<79;i++) 
39B8:  CLRF   xF0
39BA:  MOVF   xF0,W
39BC:  SUBLW  4E
39BE:  BTFSS  FD8.0
39C0:  BRA    3AD0
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
39C2:  CLRF   03
39C4:  MOVF   xF0,W
39C6:  ADDWF  xEE,W
39C8:  MOVWF  01
39CA:  MOVF   xEF,W
39CC:  ADDWFC 03,F
39CE:  MOVFF  01,7F5
39D2:  MOVFF  03,7F6
39D6:  MOVLW  05
39D8:  ADDWF  xF1,W
39DA:  MOVWF  xF7
39DC:  MOVLW  00
39DE:  ADDWFC xF2,W
39E0:  MOVWF  xF8
39E2:  MOVF   xEC,W
39E4:  ADDWF  xF7,W
39E6:  MOVWF  FE9
39E8:  MOVF   xED,W
39EA:  ADDWFC xF8,W
39EC:  MOVWF  FEA
39EE:  MOVFF  FEF,7F9
39F2:  MOVLW  04
39F4:  ADDWF  xF1,W
39F6:  MOVWF  xFA
39F8:  MOVLW  00
39FA:  ADDWFC xF2,W
39FC:  MOVWF  xFB
39FE:  MOVF   xEC,W
3A00:  ADDWF  xFA,W
3A02:  MOVWF  FE9
3A04:  MOVF   xED,W
3A06:  ADDWFC xFB,W
3A08:  MOVWF  FEA
3A0A:  MOVFF  FEF,7FC
3A0E:  MOVLW  03
3A10:  ADDWF  xF1,W
3A12:  MOVWF  xFD
3A14:  MOVLW  00
3A16:  ADDWFC xF2,W
3A18:  MOVWF  xFE
3A1A:  MOVF   xEC,W
3A1C:  ADDWF  xFD,W
3A1E:  MOVWF  FE9
3A20:  MOVF   xED,W
3A22:  ADDWFC xFE,W
3A24:  MOVWF  FEA
3A26:  MOVFF  FEF,7FF
3A2A:  MOVLW  02
3A2C:  ADDWF  xF1,W
3A2E:  MOVLB  8
3A30:  MOVWF  x00
3A32:  MOVLW  00
3A34:  MOVLB  7
3A36:  ADDWFC xF2,W
3A38:  MOVLB  8
3A3A:  MOVWF  x01
3A3C:  MOVLB  7
3A3E:  MOVF   xEC,W
3A40:  MOVLB  8
3A42:  ADDWF  x00,W
3A44:  MOVWF  FE9
3A46:  MOVLB  7
3A48:  MOVF   xED,W
3A4A:  MOVLB  8
3A4C:  ADDWFC x01,W
3A4E:  MOVWF  FEA
3A50:  MOVFF  FEF,802
3A54:  MOVLW  01
3A56:  MOVLB  7
3A58:  ADDWF  xF1,W
3A5A:  MOVLB  8
3A5C:  MOVWF  x03
3A5E:  MOVLW  00
3A60:  MOVLB  7
3A62:  ADDWFC xF2,W
3A64:  MOVLB  8
3A66:  MOVWF  x04
3A68:  MOVLB  7
3A6A:  MOVF   xEC,W
3A6C:  MOVLB  8
3A6E:  ADDWF  x03,W
3A70:  MOVWF  FE9
3A72:  MOVLB  7
3A74:  MOVF   xED,W
3A76:  MOVLB  8
3A78:  ADDWFC x04,W
3A7A:  MOVWF  FEA
3A7C:  MOVFF  FEF,805
3A80:  MOVLB  7
3A82:  MOVF   xEC,W
3A84:  ADDWF  xF1,W
3A86:  MOVWF  FE9
3A88:  MOVF   xED,W
3A8A:  ADDWFC xF2,W
3A8C:  MOVWF  FEA
3A8E:  MOVFF  FEF,806
3A92:  MOVLB  8
3A94:  CLRF   x2D
3A96:  CLRF   x2E
3A98:  MOVFF  7F9,82F
3A9C:  MOVFF  7FC,830
3AA0:  MOVFF  7FF,831
3AA4:  MOVFF  802,832
3AA8:  MOVFF  805,833
3AAC:  MOVFF  806,834
3AB0:  MOVLB  0
3AB2:  CALL   04AC
3AB6:  MOVFF  7F6,FEA
3ABA:  MOVFF  7F5,FE9
3ABE:  MOVFF  01,FEF
....................                j=j+7; 
3AC2:  MOVLW  07
3AC4:  MOVLB  7
3AC6:  ADDWF  xF1,F
3AC8:  MOVLW  00
3ACA:  ADDWFC xF2,F
....................             } 
3ACC:  INCF   xF0,F
3ACE:  BRA    39BA
....................       } 
....................          else  
3AD0:  BRA    3B8C
....................          { 
....................             for(i=0;i<40;i++) 
3AD2:  CLRF   xF0
3AD4:  MOVF   xF0,W
3AD6:  SUBLW  27
3AD8:  BNC   3B8C
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3ADA:  CLRF   03
3ADC:  MOVF   xF0,W
3ADE:  ADDWF  xEE,W
3AE0:  MOVWF  01
3AE2:  MOVF   xEF,W
3AE4:  ADDWFC 03,F
3AE6:  MOVFF  01,7F5
3AEA:  MOVFF  03,7F6
3AEE:  MOVLW  03
3AF0:  ADDWF  xF1,W
3AF2:  MOVWF  xF7
3AF4:  MOVLW  00
3AF6:  ADDWFC xF2,W
3AF8:  MOVWF  xF8
3AFA:  MOVF   xEC,W
3AFC:  ADDWF  xF7,W
3AFE:  MOVWF  FE9
3B00:  MOVF   xED,W
3B02:  ADDWFC xF8,W
3B04:  MOVWF  FEA
3B06:  MOVFF  FEF,7F9
3B0A:  MOVLW  02
3B0C:  ADDWF  xF1,W
3B0E:  MOVWF  xFA
3B10:  MOVLW  00
3B12:  ADDWFC xF2,W
3B14:  MOVWF  xFB
3B16:  MOVF   xEC,W
3B18:  ADDWF  xFA,W
3B1A:  MOVWF  FE9
3B1C:  MOVF   xED,W
3B1E:  ADDWFC xFB,W
3B20:  MOVWF  FEA
3B22:  MOVFF  FEF,7FC
3B26:  MOVLW  01
3B28:  ADDWF  xF1,W
3B2A:  MOVWF  xFD
3B2C:  MOVLW  00
3B2E:  ADDWFC xF2,W
3B30:  MOVWF  xFE
3B32:  MOVF   xEC,W
3B34:  ADDWF  xFD,W
3B36:  MOVWF  FE9
3B38:  MOVF   xED,W
3B3A:  ADDWFC xFE,W
3B3C:  MOVWF  FEA
3B3E:  MOVFF  FEF,7FF
3B42:  MOVF   xEC,W
3B44:  ADDWF  xF1,W
3B46:  MOVWF  FE9
3B48:  MOVF   xED,W
3B4A:  ADDWFC xF2,W
3B4C:  MOVWF  FEA
3B4E:  MOVFF  FEF,800
3B52:  MOVLB  8
3B54:  CLRF   x2D
3B56:  CLRF   x2E
3B58:  CLRF   x2F
3B5A:  CLRF   x30
3B5C:  MOVFF  7F9,831
3B60:  MOVFF  7FC,832
3B64:  MOVFF  7FF,833
3B68:  MOVFF  800,834
3B6C:  MOVLB  0
3B6E:  CALL   04AC
3B72:  MOVFF  7F6,FEA
3B76:  MOVFF  7F5,FE9
3B7A:  MOVFF  01,FEF
....................                j=j+5; 
3B7E:  MOVLW  05
3B80:  MOVLB  7
3B82:  ADDWF  xF1,F
3B84:  MOVLW  00
3B86:  ADDWFC xF2,F
....................             }          
3B88:  INCF   xF0,F
3B8A:  BRA    3AD4
....................          } 
....................    } 
....................       else  
3B8C:  BRA    3D6C
3B8E:  MOVLB  6
....................       { 
....................          if(track==0) 
3B90:  MOVLB  7
3B92:  MOVF   xE9,F
3B94:  BTFSS  FD8.2
3B96:  BRA    3CB2
....................          { 
....................             for(i=0;i<79;i++) 
3B98:  CLRF   xF0
3B9A:  MOVF   xF0,W
3B9C:  SUBLW  4E
3B9E:  BTFSS  FD8.0
3BA0:  BRA    3CB0
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3BA2:  CLRF   03
3BA4:  MOVF   xF0,W
3BA6:  ADDWF  xEE,W
3BA8:  MOVWF  01
3BAA:  MOVF   xEF,W
3BAC:  ADDWFC 03,F
3BAE:  MOVFF  01,7F5
3BB2:  MOVFF  03,7F6
3BB6:  MOVLW  05
3BB8:  SUBWF  xF1,W
3BBA:  MOVWF  xF7
3BBC:  MOVLW  00
3BBE:  SUBWFB xF2,W
3BC0:  MOVWF  xF8
3BC2:  MOVF   xEC,W
3BC4:  ADDWF  xF7,W
3BC6:  MOVWF  FE9
3BC8:  MOVF   xED,W
3BCA:  ADDWFC xF8,W
3BCC:  MOVWF  FEA
3BCE:  MOVFF  FEF,7F9
3BD2:  MOVLW  04
3BD4:  SUBWF  xF1,W
3BD6:  MOVWF  xFA
3BD8:  MOVLW  00
3BDA:  SUBWFB xF2,W
3BDC:  MOVWF  xFB
3BDE:  MOVF   xEC,W
3BE0:  ADDWF  xFA,W
3BE2:  MOVWF  FE9
3BE4:  MOVF   xED,W
3BE6:  ADDWFC xFB,W
3BE8:  MOVWF  FEA
3BEA:  MOVFF  FEF,7FC
3BEE:  MOVLW  03
3BF0:  SUBWF  xF1,W
3BF2:  MOVWF  xFD
3BF4:  MOVLW  00
3BF6:  SUBWFB xF2,W
3BF8:  MOVWF  xFE
3BFA:  MOVF   xEC,W
3BFC:  ADDWF  xFD,W
3BFE:  MOVWF  FE9
3C00:  MOVF   xED,W
3C02:  ADDWFC xFE,W
3C04:  MOVWF  FEA
3C06:  MOVFF  FEF,7FF
3C0A:  MOVLW  02
3C0C:  SUBWF  xF1,W
3C0E:  MOVLB  8
3C10:  MOVWF  x00
3C12:  MOVLW  00
3C14:  MOVLB  7
3C16:  SUBWFB xF2,W
3C18:  MOVLB  8
3C1A:  MOVWF  x01
3C1C:  MOVLB  7
3C1E:  MOVF   xEC,W
3C20:  MOVLB  8
3C22:  ADDWF  x00,W
3C24:  MOVWF  FE9
3C26:  MOVLB  7
3C28:  MOVF   xED,W
3C2A:  MOVLB  8
3C2C:  ADDWFC x01,W
3C2E:  MOVWF  FEA
3C30:  MOVFF  FEF,802
3C34:  MOVLW  01
3C36:  MOVLB  7
3C38:  SUBWF  xF1,W
3C3A:  MOVLB  8
3C3C:  MOVWF  x03
3C3E:  MOVLW  00
3C40:  MOVLB  7
3C42:  SUBWFB xF2,W
3C44:  MOVLB  8
3C46:  MOVWF  x04
3C48:  MOVLB  7
3C4A:  MOVF   xEC,W
3C4C:  MOVLB  8
3C4E:  ADDWF  x03,W
3C50:  MOVWF  FE9
3C52:  MOVLB  7
3C54:  MOVF   xED,W
3C56:  MOVLB  8
3C58:  ADDWFC x04,W
3C5A:  MOVWF  FEA
3C5C:  MOVFF  FEF,805
3C60:  MOVLB  7
3C62:  MOVF   xEC,W
3C64:  ADDWF  xF1,W
3C66:  MOVWF  FE9
3C68:  MOVF   xED,W
3C6A:  ADDWFC xF2,W
3C6C:  MOVWF  FEA
3C6E:  MOVFF  FEF,806
3C72:  MOVLB  8
3C74:  CLRF   x2D
3C76:  CLRF   x2E
3C78:  MOVFF  7F9,82F
3C7C:  MOVFF  7FC,830
3C80:  MOVFF  7FF,831
3C84:  MOVFF  802,832
3C88:  MOVFF  805,833
3C8C:  MOVFF  806,834
3C90:  MOVLB  0
3C92:  CALL   04AC
3C96:  MOVFF  7F6,FEA
3C9A:  MOVFF  7F5,FE9
3C9E:  MOVFF  01,FEF
....................                j=j-7; 
3CA2:  MOVLW  07
3CA4:  MOVLB  7
3CA6:  SUBWF  xF1,F
3CA8:  MOVLW  00
3CAA:  SUBWFB xF2,F
....................             } 
3CAC:  INCF   xF0,F
3CAE:  BRA    3B9A
....................          } 
....................             else 
3CB0:  BRA    3D6C
....................             { 
....................                for(i=0;i<40;i++) 
3CB2:  CLRF   xF0
3CB4:  MOVF   xF0,W
3CB6:  SUBLW  27
3CB8:  BNC   3D6C
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3CBA:  CLRF   03
3CBC:  MOVF   xF0,W
3CBE:  ADDWF  xEE,W
3CC0:  MOVWF  01
3CC2:  MOVF   xEF,W
3CC4:  ADDWFC 03,F
3CC6:  MOVFF  01,7F5
3CCA:  MOVFF  03,7F6
3CCE:  MOVLW  03
3CD0:  SUBWF  xF1,W
3CD2:  MOVWF  xF7
3CD4:  MOVLW  00
3CD6:  SUBWFB xF2,W
3CD8:  MOVWF  xF8
3CDA:  MOVF   xEC,W
3CDC:  ADDWF  xF7,W
3CDE:  MOVWF  FE9
3CE0:  MOVF   xED,W
3CE2:  ADDWFC xF8,W
3CE4:  MOVWF  FEA
3CE6:  MOVFF  FEF,7F9
3CEA:  MOVLW  02
3CEC:  SUBWF  xF1,W
3CEE:  MOVWF  xFA
3CF0:  MOVLW  00
3CF2:  SUBWFB xF2,W
3CF4:  MOVWF  xFB
3CF6:  MOVF   xEC,W
3CF8:  ADDWF  xFA,W
3CFA:  MOVWF  FE9
3CFC:  MOVF   xED,W
3CFE:  ADDWFC xFB,W
3D00:  MOVWF  FEA
3D02:  MOVFF  FEF,7FC
3D06:  MOVLW  01
3D08:  SUBWF  xF1,W
3D0A:  MOVWF  xFD
3D0C:  MOVLW  00
3D0E:  SUBWFB xF2,W
3D10:  MOVWF  xFE
3D12:  MOVF   xEC,W
3D14:  ADDWF  xFD,W
3D16:  MOVWF  FE9
3D18:  MOVF   xED,W
3D1A:  ADDWFC xFE,W
3D1C:  MOVWF  FEA
3D1E:  MOVFF  FEF,7FF
3D22:  MOVF   xEC,W
3D24:  ADDWF  xF1,W
3D26:  MOVWF  FE9
3D28:  MOVF   xED,W
3D2A:  ADDWFC xF2,W
3D2C:  MOVWF  FEA
3D2E:  MOVFF  FEF,800
3D32:  MOVLB  8
3D34:  CLRF   x2D
3D36:  CLRF   x2E
3D38:  CLRF   x2F
3D3A:  CLRF   x30
3D3C:  MOVFF  7F9,831
3D40:  MOVFF  7FC,832
3D44:  MOVFF  7FF,833
3D48:  MOVFF  800,834
3D4C:  MOVLB  0
3D4E:  CALL   04AC
3D52:  MOVFF  7F6,FEA
3D56:  MOVFF  7F5,FE9
3D5A:  MOVFF  01,FEF
....................                   j=j-5; 
3D5E:  MOVLW  05
3D60:  MOVLB  7
3D62:  SUBWF  xF1,F
3D64:  MOVLW  00
3D66:  SUBWFB xF2,F
....................                }             
3D68:  INCF   xF0,F
3D6A:  BRA    3CB4
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3D6C:  MOVF   xE9,F
3D6E:  BNZ   3D84
3D70:  MOVLW  52
3D72:  MOVWF  xF5
3D74:  MOVFF  7ED,7F7
3D78:  MOVFF  7EC,7F6
3D7C:  MOVLB  0
3D7E:  RCALL  3944
....................          else del_buf(numbyteofbuffer2,datin); 
3D80:  BRA    3D94
3D82:  MOVLB  7
3D84:  MOVLW  2C
3D86:  MOVWF  xF5
3D88:  MOVFF  7ED,7F7
3D8C:  MOVFF  7EC,7F6
3D90:  MOVLB  0
3D92:  RCALL  3944
3D94:  MOVLB  7
.................... } 
3D96:  MOVLB  0
3D98:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1A58:  MOVLW  50
1A5A:  MOVWF  FF6
1A5C:  MOVLW  03
1A5E:  MOVWF  FF7
1A60:  CALL   048C
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1A64:  MOVLB  7
1A66:  CLRF   xED
1A68:  CLRF   xEC
1A6A:  MOVF   xED,W
1A6C:  SUBLW  03
1A6E:  BNC   1A9E
1A70:  BNZ   1A78
1A72:  MOVF   xEC,W
1A74:  SUBLW  51
1A76:  BNC   1A9E
1A78:  MOVLW  0D
1A7A:  ADDWF  xEC,W
1A7C:  MOVWF  FE9
1A7E:  MOVLW  02
1A80:  ADDWFC xED,W
1A82:  MOVWF  FEA
1A84:  MOVFF  FEF,7EE
1A88:  MOVFF  7EE,7EF
1A8C:  MOVLW  18
1A8E:  MOVWF  xF0
1A90:  MOVLB  0
1A92:  RCALL  1990
1A94:  MOVLB  7
1A96:  INCF   xEC,F
1A98:  BTFSC  FD8.2
1A9A:  INCF   xED,F
1A9C:  BRA    1A6A
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1A9E:  MOVLW  66
1AA0:  MOVWF  FF6
1AA2:  MOVLW  03
1AA4:  MOVWF  FF7
1AA6:  MOVLB  0
1AA8:  CALL   048C
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1AAC:  MOVLB  7
1AAE:  CLRF   xED
1AB0:  CLRF   xEC
1AB2:  MOVF   xED,W
1AB4:  SUBLW  01
1AB6:  BNC   1AE6
1AB8:  BNZ   1AC0
1ABA:  MOVF   xEC,W
1ABC:  SUBLW  2B
1ABE:  BNC   1AE6
1AC0:  MOVLW  5F
1AC2:  ADDWF  xEC,W
1AC4:  MOVWF  FE9
1AC6:  MOVLW  05
1AC8:  ADDWFC xED,W
1ACA:  MOVWF  FEA
1ACC:  MOVFF  FEF,7EE
1AD0:  MOVFF  7EE,7EF
1AD4:  MOVLW  18
1AD6:  MOVWF  xF0
1AD8:  MOVLB  0
1ADA:  RCALL  1990
1ADC:  MOVLB  7
1ADE:  INCF   xEC,F
1AE0:  BTFSC  FD8.2
1AE2:  INCF   xED,F
1AE4:  BRA    1AB2
.................... } 
1AE6:  MOVLB  0
1AE8:  GOTO   1D7E (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3F2E:  MOVLW  01
3F30:  MOVLB  6
3F32:  MOVWF  x9F
....................    //rtc_get_date(date,mon,year,day); 
....................    //rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3F34:  MOVLB  0
3F36:  RCALL  38C6
3F38:  MOVFF  02,7EA
3F3C:  MOVFF  01,7E9
3F40:  MOVFF  02,7EC
3F44:  MOVFF  01,7EB
3F48:  MOVLB  7
3F4A:  CLRF   xEE
3F4C:  MOVLW  7C
3F4E:  MOVWF  xED
3F50:  MOVLB  0
3F52:  RCALL  3922
3F54:  MOVFF  01,7E9
3F58:  MOVLW  96
3F5A:  MOVLB  7
3F5C:  ADDWF  01,W
3F5E:  MOVWF  01
3F60:  MOVLW  00
3F62:  ADDWFC 02,W
3F64:  MOVFF  01,20
3F68:  MOVWF  21
3F6A:  CLRF   22
3F6C:  CLRF   23
....................    if(datinbuf==0)  
3F6E:  MOVLB  6
3F70:  MOVF   x9C,F
3F72:  BNZ   3F94
....................    { 
....................       countbit_T1=0; 
3F74:  CLRF   x91
3F76:  CLRF   x90
....................       countbit_T2=0; 
3F78:  CLRF   x93
3F7A:  CLRF   x92
....................       bug_countbit_T1=0; 
3F7C:  CLRF   x95
3F7E:  CLRF   x94
....................       bug_countbit_T2=0; 
3F80:  CLRF   x97
3F82:  CLRF   x96
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3F84:  MOVF   xA0,F
3F86:  BNZ   3F90
3F88:  MOVLB  0
3F8A:  SETF   xFC
3F8C:  SETF   xFB
3F8E:  MOVLB  6
....................       saving_flag=0; 
3F90:  CLRF   x9F
....................       return; 
3F92:  BRA    4336
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3F94:  MOVLW  7C
3F96:  MOVWF  FF6
3F98:  MOVLW  03
3F9A:  MOVWF  FF7
3F9C:  MOVLB  0
3F9E:  CALL   048C
....................    key_timeout=0; 
3FA2:  MOVLB  1
3FA4:  CLRF   x09
3FA6:  CLRF   x08
....................    //key_count=0; 
....................    enable_getpin=1; 
3FA8:  MOVLW  01
3FAA:  MOVWF  x0C
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3FAC:  MOVFF  691,7E8
3FB0:  MOVFF  690,7E7
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3FB4:  MOVLB  7
3FB6:  CLRF   xE9
3FB8:  MOVFF  7E8,7EB
3FBC:  MOVFF  7E7,7EA
3FC0:  MOVLW  02
3FC2:  MOVWF  xED
3FC4:  MOVLW  0D
3FC6:  MOVWF  xEC
3FC8:  MOVLW  01
3FCA:  MOVWF  xEF
3FCC:  MOVLW  96
3FCE:  MOVWF  xEE
3FD0:  MOVLB  0
3FD2:  RCALL  3966
....................    countbit_T1=0; 
3FD4:  MOVLB  6
3FD6:  CLRF   x91
3FD8:  CLRF   x90
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3FDA:  MOVFF  693,7E8
3FDE:  MOVFF  692,7E7
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3FE2:  MOVLW  01
3FE4:  MOVLB  7
3FE6:  MOVWF  xE9
3FE8:  MOVFF  7E8,7EB
3FEC:  MOVFF  7E7,7EA
3FF0:  MOVLW  05
3FF2:  MOVWF  xED
3FF4:  MOVLW  5F
3FF6:  MOVWF  xEC
3FF8:  MOVLW  01
3FFA:  MOVWF  xEF
3FFC:  MOVLW  E5
3FFE:  MOVWF  xEE
4000:  MOVLB  0
4002:  RCALL  3966
....................    countbit_T2=0; 
4004:  MOVLB  6
4006:  CLRF   x93
4008:  CLRF   x92
....................    saving_flag=0; 
400A:  CLRF   x9F
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
400C:  MOVLW  20
400E:  MOVLB  1
4010:  ADDWF  x96,W
4012:  MOVLB  7
4014:  MOVWF  xE6
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
4016:  MOVF   23,F
4018:  BTFSS  FD8.2
401A:  BRA    4334
401C:  MOVF   22,W
401E:  SUBLW  01
4020:  BTFSS  FD8.0
4022:  BRA    4334
4024:  BNZ   4038
4026:  MOVF   21,W
4028:  SUBLW  C3
402A:  BTFSS  FD8.0
402C:  BRA    4334
402E:  BNZ   4038
4030:  MOVF   20,W
4032:  SUBLW  0D
4034:  BTFSS  FD8.0
4036:  BRA    4334
4038:  MOVF   xE6,W
403A:  SUBLW  25
403C:  BTFSS  FD8.2
403E:  BRA    4334
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
4040:  MOVFF  23,03
4044:  MOVFF  22,02
4048:  MOVFF  21,01
404C:  MOVFF  20,00
4050:  MOVLW  01
4052:  ADDWF  20,F
4054:  BTFSC  FD8.0
4056:  INCF   21,F
4058:  BTFSC  FD8.2
405A:  INCF   22,F
405C:  BTFSC  FD8.2
405E:  INCF   23,F
4060:  MOVFF  01,7EA
4064:  MOVFF  00,7E9
4068:  MOVLB  8
406A:  CLRF   x05
406C:  CLRF   x04
406E:  MOVFF  01,803
4072:  MOVFF  00,802
4076:  MOVFF  100,806
407A:  MOVLB  0
407C:  RCALL  3D9A
....................          write_ext_eeprom((long int)ptr_card++,mon); 
407E:  MOVFF  23,03
4082:  MOVFF  22,02
4086:  MOVFF  21,01
408A:  MOVFF  20,00
408E:  MOVLW  01
4090:  ADDWF  20,F
4092:  BTFSC  FD8.0
4094:  INCF   21,F
4096:  BTFSC  FD8.2
4098:  INCF   22,F
409A:  BTFSC  FD8.2
409C:  INCF   23,F
409E:  MOVFF  01,7EA
40A2:  MOVFF  00,7E9
40A6:  MOVLB  8
40A8:  CLRF   x05
40AA:  CLRF   x04
40AC:  MOVFF  01,803
40B0:  MOVFF  00,802
40B4:  MOVFF  FF,806
40B8:  MOVLB  0
40BA:  RCALL  3D9A
....................          write_ext_eeprom((long int)ptr_card++,h); 
40BC:  MOVFF  23,03
40C0:  MOVFF  22,02
40C4:  MOVFF  21,01
40C8:  MOVFF  20,00
40CC:  MOVLW  01
40CE:  ADDWF  20,F
40D0:  BTFSC  FD8.0
40D2:  INCF   21,F
40D4:  BTFSC  FD8.2
40D6:  INCF   22,F
40D8:  BTFSC  FD8.2
40DA:  INCF   23,F
40DC:  MOVFF  01,7EA
40E0:  MOVFF  00,7E9
40E4:  MOVLB  8
40E6:  CLRF   x05
40E8:  CLRF   x04
40EA:  MOVFF  01,803
40EE:  MOVFF  00,802
40F2:  MOVFF  101,806
40F6:  MOVLB  0
40F8:  RCALL  3D9A
....................          write_ext_eeprom((long int)ptr_card++,min); 
40FA:  MOVFF  23,03
40FE:  MOVFF  22,02
4102:  MOVFF  21,01
4106:  MOVFF  20,00
410A:  MOVLW  01
410C:  ADDWF  20,F
410E:  BTFSC  FD8.0
4110:  INCF   21,F
4112:  BTFSC  FD8.2
4114:  INCF   22,F
4116:  BTFSC  FD8.2
4118:  INCF   23,F
411A:  MOVFF  01,7EA
411E:  MOVFF  00,7E9
4122:  MOVLB  8
4124:  CLRF   x05
4126:  CLRF   x04
4128:  MOVFF  01,803
412C:  MOVFF  00,802
4130:  MOVFF  102,806
4134:  MOVLB  0
4136:  RCALL  3D9A
....................          write_ext_eeprom((long int)ptr_card++,sec);           
4138:  MOVFF  23,03
413C:  MOVFF  22,02
4140:  MOVFF  21,01
4144:  MOVFF  20,00
4148:  MOVLW  01
414A:  ADDWF  20,F
414C:  BTFSC  FD8.0
414E:  INCF   21,F
4150:  BTFSC  FD8.2
4152:  INCF   22,F
4154:  BTFSC  FD8.2
4156:  INCF   23,F
4158:  MOVFF  01,7EA
415C:  MOVFF  00,7E9
4160:  MOVLB  8
4162:  CLRF   x05
4164:  CLRF   x04
4166:  MOVFF  01,803
416A:  MOVFF  00,802
416E:  MOVFF  103,806
4172:  MOVLB  0
4174:  RCALL  3D9A
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
4176:  MOVLB  6
4178:  CLRF   x9B
417A:  CLRF   x9A
417C:  MOVF   x9B,F
417E:  BNZ   41E2
4180:  MOVF   x9A,W
4182:  SUBLW  4E
4184:  BNC   41E2
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
4186:  MOVFF  23,03
418A:  MOVFF  22,02
418E:  MOVFF  21,01
4192:  MOVFF  20,00
4196:  MOVLW  01
4198:  ADDWF  20,F
419A:  BTFSC  FD8.0
419C:  INCF   21,F
419E:  BTFSC  FD8.2
41A0:  INCF   22,F
41A2:  BTFSC  FD8.2
41A4:  INCF   23,F
41A6:  MOVFF  01,7EA
41AA:  MOVFF  00,7E9
41AE:  MOVLW  96
41B0:  ADDWF  x9A,W
41B2:  MOVWF  FE9
41B4:  MOVLW  01
41B6:  ADDWFC x9B,W
41B8:  MOVWF  FEA
41BA:  MOVF   FEF,W
41BC:  ANDLW  3F
41BE:  ADDLW  20
41C0:  MOVLB  7
41C2:  MOVWF  xEB
41C4:  MOVLB  8
41C6:  CLRF   x05
41C8:  CLRF   x04
41CA:  MOVFF  01,803
41CE:  MOVFF  00,802
41D2:  MOVWF  x06
41D4:  MOVLB  0
41D6:  RCALL  3D9A
....................              
....................          } 
41D8:  MOVLB  6
41DA:  INCF   x9A,F
41DC:  BTFSC  FD8.2
41DE:  INCF   x9B,F
41E0:  BRA    417C
....................          del_buf(numbyteoftrack1,Track1); 
41E2:  MOVLW  4F
41E4:  MOVLB  7
41E6:  MOVWF  xF5
41E8:  MOVLW  01
41EA:  MOVWF  xF7
41EC:  MOVLW  96
41EE:  MOVWF  xF6
41F0:  MOVLB  0
41F2:  CALL   3944
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
41F6:  MOVLB  6
41F8:  CLRF   x9B
41FA:  CLRF   x9A
41FC:  MOVF   x9B,F
41FE:  BNZ   4262
4200:  MOVF   x9A,W
4202:  SUBLW  27
4204:  BNC   4262
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
4206:  MOVFF  23,03
420A:  MOVFF  22,02
420E:  MOVFF  21,01
4212:  MOVFF  20,00
4216:  MOVLW  01
4218:  ADDWF  20,F
421A:  BTFSC  FD8.0
421C:  INCF   21,F
421E:  BTFSC  FD8.2
4220:  INCF   22,F
4222:  BTFSC  FD8.2
4224:  INCF   23,F
4226:  MOVFF  01,7EA
422A:  MOVFF  00,7E9
422E:  MOVLW  E5
4230:  ADDWF  x9A,W
4232:  MOVWF  FE9
4234:  MOVLW  01
4236:  ADDWFC x9B,W
4238:  MOVWF  FEA
423A:  MOVF   FEF,W
423C:  ANDLW  0F
423E:  ADDLW  30
4240:  MOVLB  7
4242:  MOVWF  xEB
4244:  MOVLB  8
4246:  CLRF   x05
4248:  CLRF   x04
424A:  MOVFF  01,803
424E:  MOVFF  00,802
4252:  MOVWF  x06
4254:  MOVLB  0
4256:  RCALL  3D9A
....................          }  
4258:  MOVLB  6
425A:  INCF   x9A,F
425C:  BTFSC  FD8.2
425E:  INCF   x9B,F
4260:  BRA    41FC
....................          del_buf(numbyteoftrack2,Track2); 
4262:  MOVLW  28
4264:  MOVLB  7
4266:  MOVWF  xF5
4268:  MOVLW  01
426A:  MOVWF  xF7
426C:  MOVLW  E5
426E:  MOVWF  xF6
4270:  MOVLB  0
4272:  CALL   3944
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
4276:  MOVLW  0D
4278:  MOVLB  8
427A:  MOVWF  x1A
427C:  MOVLB  0
427E:  CALL   043A
4282:  MOVLW  0A
4284:  MOVLB  8
4286:  MOVWF  x1A
4288:  MOVLB  0
428A:  CALL   043A
....................       fprintf(COM2,"Done"); 
428E:  MOVLW  92
4290:  MOVWF  FF6
4292:  MOVLW  03
4294:  MOVWF  FF7
4296:  CALL   048C
....................       if(KP_mode) 
429A:  MOVLB  1
429C:  MOVF   x0F,F
429E:  BZ    42B6
....................       { 
....................          printf("\n\rKey release\n\r"); 
42A0:  MOVLW  98
42A2:  MOVWF  FF6
42A4:  MOVLW  03
42A6:  MOVWF  FF7
42A8:  MOVLB  0
42AA:  CALL   048C
....................          keyprss_off; 
42AE:  BCF    F92.7
42B0:  BCF    F89.7
....................          kp_st=0; 
42B2:  MOVLB  1
42B4:  CLRF   x10
....................       }   
....................       count_kp=0xffff; 
42B6:  SETF   x12
42B8:  SETF   x11
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
42BA:  MOVLW  0D
42BC:  MOVLB  8
42BE:  MOVWF  x1A
42C0:  MOVLB  0
42C2:  CALL   043A
42C6:  MOVLW  0A
42C8:  MOVLB  8
42CA:  MOVWF  x1A
42CC:  MOVLB  0
42CE:  CALL   043A
....................       fprintf(COM2,"Waiting for PIN number"); 
42D2:  MOVLW  A8
42D4:  MOVWF  FF6
42D6:  MOVLW  03
42D8:  MOVWF  FF7
42DA:  CALL   048C
....................       count_checking=0; 
42DE:  MOVLB  1
42E0:  CLRF   x07
42E2:  CLRF   x06
....................       fprintf(COM2,"\r\n"); 
42E4:  MOVLW  0D
42E6:  MOVLB  8
42E8:  MOVWF  x1A
42EA:  MOVLB  0
42EC:  CALL   043A
42F0:  MOVLW  0A
42F2:  MOVLB  8
42F4:  MOVWF  x1A
42F6:  MOVLB  0
42F8:  CALL   043A
....................       charac_timeout=0; 
42FC:  CLRF   xFC
42FE:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
4300:  MOVFF  23,7EC
4304:  MOVFF  22,7EB
4308:  MOVFF  21,7EA
430C:  MOVFF  20,7E9
4310:  MOVLW  19
4312:  MOVLB  7
4314:  MOVWF  xED
4316:  MOVLB  0
4318:  RCALL  3E98
....................       datinbuf=0; 
431A:  MOVLB  6
431C:  CLRF   x9C
....................       saving_flag=0; 
431E:  CLRF   x9F
....................       data_avai=1; 
4320:  MOVLW  01
4322:  MOVWF  xA0
....................       enable_getpin=1; 
4324:  MOVLB  1
4326:  MOVWF  x0C
....................       charac_timeout=0; 
4328:  MOVLB  0
432A:  CLRF   xFC
432C:  CLRF   xFB
....................       key_count_ms=0; 
432E:  MOVLB  1
4330:  CLRF   x0E
4332:  MOVLB  7
4334:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
4336:  MOVLB  0
4338:  GOTO   486E (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
1B14:  MOVLW  01
1B16:  MOVLB  7
1B18:  MOVWF  xE3
1B1A:  MOVWF  xE4
1B1C:  MOVWF  xE5
1B1E:  MOVWF  xE6
1B20:  CLRF   xE7
1B22:  MOVWF  xE8
1B24:  MOVWF  xE9
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1B26:  MOVLB  6
1B28:  CLRF   x99
1B2A:  CLRF   x98
....................    mcr_timeout=0; 
1B2C:  CLRF   x8E
1B2E:  CLRF   x8D
1B30:  CLRF   x8C
1B32:  CLRF   x8B
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
1B34:  MOVF   x99,W
1B36:  SUBLW  FD
1B38:  BNC   1B56
1B3A:  BNZ   1B42
1B3C:  MOVF   x98,W
1B3E:  SUBLW  E7
1B40:  BNC   1B56
1B42:  BSF    F93.1
1B44:  BTFSS  F81.1
1B46:  BRA    1B56
1B48:  BSF    F94.5
1B4A:  BTFSS  F82.5
1B4C:  BRA    1B56
....................       card_timeout++; 
1B4E:  INCF   x98,F
1B50:  BTFSC  FD8.2
1B52:  INCF   x99,F
....................    } 
1B54:  BRA    1B34
....................    card_timeout=0; 
1B56:  CLRF   x99
1B58:  CLRF   x98
....................    buffertrack1[bug_countbit_T1++]=0; 
1B5A:  MOVFF  695,03
1B5E:  MOVF   x94,W
1B60:  INCF   x94,F
1B62:  BTFSC  FD8.2
1B64:  INCF   x95,F
1B66:  MOVLB  7
1B68:  MOVWF  xEC
1B6A:  MOVLW  0D
1B6C:  ADDWF  xEC,W
1B6E:  MOVWF  FE9
1B70:  MOVLW  02
1B72:  ADDWFC 03,W
1B74:  MOVWF  FEA
1B76:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1B78:  MOVLB  6
1B7A:  MOVFF  695,03
1B7E:  MOVF   x94,W
1B80:  INCF   x94,F
1B82:  BTFSC  FD8.2
1B84:  INCF   x95,F
1B86:  MOVLB  7
1B88:  MOVWF  xEC
1B8A:  MOVLW  0D
1B8C:  ADDWF  xEC,W
1B8E:  MOVWF  FE9
1B90:  MOVLW  02
1B92:  ADDWFC 03,W
1B94:  MOVWF  FEA
1B96:  MOVLW  01
1B98:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1B9A:  MOVLB  6
1B9C:  MOVFF  697,03
1BA0:  MOVF   x96,W
1BA2:  INCF   x96,F
1BA4:  BTFSC  FD8.2
1BA6:  INCF   x97,F
1BA8:  MOVLB  7
1BAA:  MOVWF  xEC
1BAC:  MOVLW  5F
1BAE:  ADDWF  xEC,W
1BB0:  MOVWF  FE9
1BB2:  MOVLW  05
1BB4:  ADDWFC 03,W
1BB6:  MOVWF  FEA
1BB8:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1BBA:  MOVLB  6
1BBC:  MOVFF  697,03
1BC0:  MOVF   x96,W
1BC2:  INCF   x96,F
1BC4:  BTFSC  FD8.2
1BC6:  INCF   x97,F
1BC8:  MOVLB  7
1BCA:  MOVWF  xEC
1BCC:  MOVLW  5F
1BCE:  ADDWF  xEC,W
1BD0:  MOVWF  FE9
1BD2:  MOVLW  05
1BD4:  ADDWFC 03,W
1BD6:  MOVWF  FEA
1BD8:  MOVLW  01
1BDA:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1BDC:  MOVLB  6
1BDE:  MOVF   x95,W
1BE0:  SUBLW  03
1BE2:  BTFSS  FD8.0
1BE4:  BRA    1CC4
1BE6:  BNZ   1BF0
1BE8:  MOVF   x94,W
1BEA:  SUBLW  51
1BEC:  BTFSS  FD8.0
1BEE:  BRA    1CC4
1BF0:  MOVF   x97,W
1BF2:  SUBLW  01
1BF4:  BTFSS  FD8.0
1BF6:  BRA    1CC4
1BF8:  BNZ   1C00
1BFA:  MOVF   x96,W
1BFC:  SUBLW  2B
1BFE:  BNC   1CC4
1C00:  MOVF   x99,W
1C02:  SUBLW  FF
1C04:  BNC   1CC4
1C06:  BNZ   1C0E
1C08:  MOVF   x98,W
1C0A:  SUBLW  DB
1C0C:  BNC   1CC4
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
1C0E:  MOVF   xA2,F
1C10:  BZ    1C1A
....................          { 
....................             bug_countbit_T1=0; 
1C12:  CLRF   x95
1C14:  CLRF   x94
....................             bug_countbit_T2=0; 
1C16:  CLRF   x97
1C18:  CLRF   x96
....................          } 
....................          card_timeout++; 
1C1A:  INCF   x98,F
1C1C:  BTFSC  FD8.2
1C1E:  INCF   x99,F
....................          mcr_timeout=0; 
1C20:  CLRF   x8E
1C22:  CLRF   x8D
1C24:  CLRF   x8C
1C26:  CLRF   x8B
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1C28:  BSF    F93.2
1C2A:  MOVLB  7
1C2C:  CLRF   xE3
1C2E:  BTFSC  F81.2
1C30:  INCF   xE3,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1C32:  MOVF   xE3,F
1C34:  BNZ   1C72
1C36:  DECFSZ xE4,W
1C38:  BRA    1C72
....................          { 
....................             ST1_old = 0; 
1C3A:  CLRF   xE4
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1C3C:  MOVLW  0D
1C3E:  MOVLB  6
1C40:  ADDWF  x94,W
1C42:  MOVWF  FE9
1C44:  MOVLW  02
1C46:  ADDWFC x95,W
1C48:  MOVWF  FEA
1C4A:  BSF    F93.1
1C4C:  MOVLW  00
1C4E:  BTFSS  F81.1
1C50:  MOVLW  01
1C52:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1C54:  MOVLW  5F
1C56:  ADDWF  x96,W
1C58:  MOVWF  FE9
1C5A:  MOVLW  05
1C5C:  ADDWFC x97,W
1C5E:  MOVWF  FEA
1C60:  MOVFF  7E7,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1C64:  INCF   x94,F
1C66:  BTFSC  FD8.2
1C68:  INCF   x95,F
....................             card_timeout=0; 
1C6A:  CLRF   x99
1C6C:  CLRF   x98
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1C6E:  BRA    1C7C
1C70:  MOVLB  7
1C72:  DECFSZ xE3,W
1C74:  BRA    1C7A
1C76:  MOVLW  01
1C78:  MOVWF  xE4
1C7A:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1C7C:  BSF    F93.3
1C7E:  MOVLB  7
1C80:  CLRF   xE5
1C82:  BTFSC  F81.3
1C84:  INCF   xE5,F
....................          if(ST2 == 0 && ST2_old == 1) 
1C86:  MOVF   xE5,F
1C88:  BNZ   1CA8
1C8A:  DECFSZ xE6,W
1C8C:  BRA    1CA8
....................          { 
....................             ST2_old = 0; 
1C8E:  CLRF   xE6
....................             Bit_t2 = !input(MCR_DATA2); 
1C90:  BSF    F94.5
1C92:  CLRF   xE7
1C94:  BTFSS  F82.5
1C96:  INCF   xE7,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1C98:  MOVLB  6
1C9A:  INCF   x96,F
1C9C:  BTFSC  FD8.2
1C9E:  INCF   x97,F
....................             card_timeout=0; 
1CA0:  CLRF   x99
1CA2:  CLRF   x98
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1CA4:  BRA    1CB2
1CA6:  MOVLB  7
1CA8:  DECFSZ xE5,W
1CAA:  BRA    1CB0
1CAC:  MOVLW  01
1CAE:  MOVWF  xE6
1CB0:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1CB2:  BSF    F93.0
1CB4:  BTFSS  F81.0
1CB6:  BRA    1CC2
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1CB8:  CLRF   xA2
....................             card_timeout=65500; 
1CBA:  SETF   x99
1CBC:  MOVLW  DC
1CBE:  MOVWF  x98
....................             break;            
1CC0:  BRA    1CC4
....................          } 
....................       } 
1CC2:  BRA    1BDE
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1CC4:  CLRF   x99
1CC6:  CLRF   x98
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1CC8:  MOVLB  7
1CCA:  CLRF   xF5
1CCC:  MOVFF  695,7F7
1CD0:  MOVFF  694,7F6
1CD4:  MOVLW  02
1CD6:  MOVWF  xF9
1CD8:  MOVLW  0D
1CDA:  MOVWF  xF8
1CDC:  MOVLB  0
1CDE:  CALL   0802
1CE2:  MOVFF  01,7E8
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1CE6:  MOVLW  01
1CE8:  MOVLB  7
1CEA:  MOVWF  xF5
1CEC:  MOVFF  697,7F7
1CF0:  MOVFF  696,7F6
1CF4:  MOVLW  05
1CF6:  MOVWF  xF9
1CF8:  MOVLW  5F
1CFA:  MOVWF  xF8
1CFC:  MOVLB  0
1CFE:  CALL   0802
1D02:  MOVFF  01,7E9
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1D06:  MOVLB  6
1D08:  DECFSZ x9D,W
1D0A:  BRA    1DAC
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1D0C:  MOVLW  C0
1D0E:  MOVWF  FF6
1D10:  MOVLW  03
1D12:  MOVWF  FF7
1D14:  MOVLW  0E
1D16:  MOVLB  8
1D18:  MOVWF  x0E
1D1A:  MOVLB  0
1D1C:  RCALL  187C
1D1E:  MOVLW  10
1D20:  MOVWF  FE9
1D22:  MOVFF  695,7ED
1D26:  MOVFF  694,7EC
1D2A:  RCALL  18A6
1D2C:  MOVLW  0D
1D2E:  MOVLB  8
1D30:  MOVWF  x1A
1D32:  MOVLB  0
1D34:  CALL   043A
1D38:  MOVLW  0A
1D3A:  MOVLB  8
1D3C:  MOVWF  x1A
1D3E:  MOVLB  0
1D40:  CALL   043A
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1D44:  MOVLW  D4
1D46:  MOVWF  FF6
1D48:  MOVLW  03
1D4A:  MOVWF  FF7
1D4C:  MOVLW  0E
1D4E:  MOVLB  8
1D50:  MOVWF  x0E
1D52:  MOVLB  0
1D54:  RCALL  187C
1D56:  MOVLW  10
1D58:  MOVWF  FE9
1D5A:  MOVFF  697,7ED
1D5E:  MOVFF  696,7EC
1D62:  RCALL  18A6
1D64:  MOVLW  0D
1D66:  MOVLB  8
1D68:  MOVWF  x1A
1D6A:  MOVLB  0
1D6C:  CALL   043A
1D70:  MOVLW  0A
1D72:  MOVLB  8
1D74:  MOVWF  x1A
1D76:  MOVLB  0
1D78:  CALL   043A
....................          debug_reader();       
1D7C:  BRA    1A58
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1D7E:  MOVLB  7
1D80:  MOVF   xE8,F
1D82:  BNZ   1D94
1D84:  MOVLW  E8
1D86:  MOVWF  FF6
1D88:  MOVLW  03
1D8A:  MOVWF  FF7
1D8C:  MOVLB  0
1D8E:  CALL   048C
1D92:  MOVLB  7
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1D94:  MOVF   xE9,F
1D96:  BNZ   1DA8
1D98:  MOVLW  FE
1D9A:  MOVWF  FF6
1D9C:  MOVLW  03
1D9E:  MOVWF  FF7
1DA0:  MOVLB  0
1DA2:  CALL   048C
1DA6:  MOVLB  7
....................       } 
....................          else 
1DA8:  BRA    1DB8
1DAA:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1DAC:  MOVLW  0F
1DAE:  MOVLB  7
1DB0:  MOVWF  xEC
1DB2:  MOVLB  0
1DB4:  RCALL  1AEC
1DB6:  MOVLB  7
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1DB8:  MOVF   xE8,F
1DBA:  BZ    1DC0
1DBC:  MOVF   xE9,F
1DBE:  BNZ   1DE0
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1DC0:  MOVLB  6
1DC2:  CLRF   x97
1DC4:  CLRF   x96
....................          bug_countbit_T1=0; 
1DC6:  CLRF   x95
1DC8:  CLRF   x94
....................          reading_fg=0; 
1DCA:  CLRF   xA1
....................          count_reading_error++; 
1DCC:  INCF   xA2,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1DCE:  CLRF   x8E
1DD0:  CLRF   x8D
1DD2:  CLRF   x8C
1DD4:  CLRF   x8B
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1DD6:  MOVLW  00
1DD8:  MOVWF  01
1DDA:  BRA    1E18
....................       } 
....................          else  
1DDC:  BRA    1E14
1DDE:  MOVLB  7
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1DE0:  MOVLW  01
1DE2:  MOVLB  6
1DE4:  MOVWF  x9C
....................             reading_fg=1; 
1DE6:  MOVWF  xA1
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1DE8:  MOVFF  697,693
1DEC:  MOVFF  696,692
....................             countbit_T1=bug_countbit_T1; 
1DF0:  MOVFF  695,691
1DF4:  MOVFF  694,690
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1DF8:  CLRF   x95
1DFA:  CLRF   x94
....................             bug_countbit_T2=0;  
1DFC:  CLRF   x97
1DFE:  CLRF   x96
....................             mcr_timeout=0; 
1E00:  CLRF   x8E
1E02:  CLRF   x8D
1E04:  CLRF   x8C
1E06:  CLRF   x8B
....................             charac_timeout=0; 
1E08:  MOVLB  0
1E0A:  CLRF   xFC
1E0C:  CLRF   xFB
....................             return 1; 
1E0E:  MOVWF  01
1E10:  MOVLB  6
1E12:  BRA    1E18
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1E14:  MOVLW  00
1E16:  MOVWF  01
.................... } 
1E18:  MOVLB  0
1E1A:  GOTO   1E86 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
1E1E:  MOVLW  02
1E20:  MOVLB  7
1E22:  MOVWF  xE3
1E24:  MOVLW  FA
1E26:  MOVWF  xE4
1E28:  MOVLB  0
1E2A:  GOTO   0414
1E2E:  MOVLB  7
1E30:  DECFSZ xE3,F
1E32:  BRA    1E24
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
1E34:  MOVLB  6
1E36:  DECFSZ x9F,W
1E38:  BRA    1E3C
1E3A:  BRA    1E98
....................       if((KP_mode)&&(enable_getpin==0)&&(booting==1)) 
1E3C:  MOVLB  1
1E3E:  MOVF   x0F,F
1E40:  BZ    1E82
1E42:  MOVF   x0C,F
1E44:  BNZ   1E82
1E46:  DECFSZ x05,W
1E48:  BRA    1E82
....................       { 
....................          if(kp_st==1) 
1E4A:  DECFSZ x10,W
1E4C:  BRA    1E66
....................          { 
....................             printf("\n\rKey release.\n\r"); 
1E4E:  MOVLW  A0
1E50:  MOVWF  FF6
1E52:  MOVLW  1E
1E54:  MOVWF  FF7
1E56:  MOVLB  0
1E58:  CALL   048C
....................             keyprss_off; 
1E5C:  BCF    F92.7
1E5E:  BCF    F89.7
....................             kp_st=0; 
1E60:  MOVLB  1
1E62:  CLRF   x10
....................          } 
....................          else 
1E64:  BRA    1E82
....................          { 
....................             printf("\n\rKey press.\n\r"); 
1E66:  MOVLW  B2
1E68:  MOVWF  FF6
1E6A:  MOVLW  1E
1E6C:  MOVWF  FF7
1E6E:  MOVLB  0
1E70:  CALL   048C
....................             keyprss_on; 
1E74:  BCF    F92.7
1E76:  BSF    F89.7
....................             kp_st=1;  
1E78:  MOVLW  01
1E7A:  MOVLB  1
1E7C:  MOVWF  x10
....................             count_kp=0; 
1E7E:  CLRF   x12
1E80:  CLRF   x11
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1E82:  MOVLB  0
1E84:  BRA    1B14
1E86:  MOVFF  01,69E
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1E8A:  MOVLB  6
1E8C:  CLRF   x8E
1E8E:  CLRF   x8D
1E90:  CLRF   x8C
1E92:  CLRF   x8B
....................       card_timeout=0; 
1E94:  CLRF   x99
1E96:  CLRF   x98
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1E98:  BCF    FF0.0
1E9A:  MOVLB  0
1E9C:  GOTO   006C
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
53A6:  CLRF   19
53A8:  BTFSC  FF2.7
53AA:  BSF    19.7
53AC:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
53AE:  MOVLB  8
53B0:  CLRF   x05
53B2:  CLRF   x04
53B4:  CLRF   x03
53B6:  MOVLW  94
53B8:  MOVWF  x02
53BA:  MOVLW  03
53BC:  MOVWF  x06
53BE:  MOVLB  0
53C0:  CALL   3D9A
53C4:  BTFSC  19.7
53C6:  BSF    FF2.7
53C8:  CLRF   19
53CA:  BTFSC  FF2.7
53CC:  BSF    19.7
53CE:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
53D0:  MOVLB  8
53D2:  CLRF   x05
53D4:  CLRF   x04
53D6:  CLRF   x03
53D8:  MOVLW  91
53DA:  MOVWF  x02
53DC:  MOVLW  01
53DE:  MOVWF  x06
53E0:  MOVLB  0
53E2:  CALL   3D9A
53E6:  BTFSC  19.7
53E8:  BSF    FF2.7
53EA:  CLRF   19
53EC:  BTFSC  FF2.7
53EE:  BSF    19.7
53F0:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
53F2:  MOVLB  8
53F4:  CLRF   x0D
53F6:  CLRF   x0C
53F8:  CLRF   x0B
53FA:  MOVLW  91
53FC:  MOVWF  x0A
53FE:  MOVLB  0
5400:  CALL   37FA
5404:  BTFSC  19.7
5406:  BSF    FF2.7
5408:  MOVFF  01,6A9
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
....................    #endif 
....................     
.................... } 
540C:  GOTO   5D52 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
56EC:  MOVLW  06
56EE:  MOVWF  FEA
56F0:  MOVLW  AE
56F2:  MOVWF  FE9
56F4:  BRA    4FC4
56F6:  CLRF   19
56F8:  BTFSC  FF2.7
56FA:  BSF    19.7
56FC:  BCF    FF2.7
56FE:  MOVLW  3E
5700:  MOVLB  8
5702:  MOVWF  x1A
5704:  MOVLB  0
5706:  CALL   043A
570A:  BTFSC  19.7
570C:  BSF    FF2.7
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
570E:  MOVLW  01
5710:  MOVLB  7
5712:  MOVWF  xBA
5714:  MOVLW  14
5716:  MOVWF  xBB
5718:  MOVLW  01
571A:  MOVWF  xBD
571C:  MOVLW  2C
571E:  MOVWF  xBC
5720:  MOVLB  0
5722:  CALL   4DF4
5726:  CLRF   19
5728:  BTFSC  FF2.7
572A:  BSF    19.7
572C:  BCF    FF2.7
....................       printf("\n\r"); 
572E:  MOVLW  0A
5730:  MOVLB  8
5732:  MOVWF  x1A
5734:  MOVLB  0
5736:  CALL   043A
573A:  BTFSC  19.7
573C:  BSF    FF2.7
573E:  CLRF   19
5740:  BTFSC  FF2.7
5742:  BSF    19.7
5744:  BCF    FF2.7
5746:  MOVLW  0D
5748:  MOVLB  8
574A:  MOVWF  x1A
574C:  MOVLB  0
574E:  CALL   043A
5752:  BTFSC  19.7
5754:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
5756:  CLRF   FEA
5758:  MOVLW  41
575A:  MOVWF  FE9
575C:  MOVLW  00
575E:  CALL   011C
5762:  TBLRD*-
5764:  TBLRD*+
5766:  MOVF   FF5,W
5768:  MOVWF  FEE
576A:  IORLW  00
576C:  BNZ   5764
....................       index=0; 
576E:  MOVLB  7
5770:  CLRF   x84
....................       ee_dat=0; 
5772:  MOVLB  6
5774:  CLRF   xA4
....................       count_card=1; 
5776:  CLRF   xA6
5778:  MOVLW  01
577A:  MOVWF  xA5
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
577C:  MOVLB  7
577E:  MOVWF  xBB
5780:  MOVLW  2C
5782:  MOVWF  xBA
5784:  CLRF   xBD
5786:  MOVLW  41
5788:  MOVWF  xBC
578A:  MOVLB  0
578C:  CALL   4F2C
5790:  MOVF   01,F
5792:  BTFSS  FD8.2
5794:  BRA    5B7C
....................       { 
....................          unsigned long adr=0; 
5796:  MOVLB  7
5798:  CLRF   xB9
579A:  CLRF   xB8
....................          //unsigned int count=0; 
....................          rec[0]=0; 
579C:  MOVLB  0
579E:  CLRF   x7D
57A0:  CLRF   19
57A2:  BTFSC  FF2.7
57A4:  BSF    19.7
57A6:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
57A8:  CALL   38C6
57AC:  BTFSC  19.7
57AE:  BSF    FF2.7
57B0:  MOVFF  02,6A8
57B4:  MOVFF  01,6A7
57B8:  CLRF   19
57BA:  BTFSC  FF2.7
57BC:  BSF    19.7
57BE:  BCF    FF2.7
....................          adr=count_card*numdata; 
57C0:  MOVFF  6A6,7EC
57C4:  MOVFF  6A5,7EB
57C8:  MOVLB  7
57CA:  CLRF   xEE
57CC:  MOVLW  7C
57CE:  MOVWF  xED
57D0:  MOVLB  0
57D2:  CALL   3922
57D6:  BTFSC  19.7
57D8:  BSF    FF2.7
57DA:  MOVFF  02,7B9
57DE:  MOVFF  01,7B8
....................          addr_key=EEPROM_KEY_ST; 
57E2:  MOVLB  6
57E4:  CLRF   xAD
57E6:  MOVLW  01
57E8:  MOVWF  xAC
57EA:  MOVLW  C3
57EC:  MOVWF  xAB
57EE:  MOVLW  0F
57F0:  MOVWF  xAA
....................          while(count_card<=count_card_tg) 
....................          { 
57F2:  MOVF   xA6,W
57F4:  SUBWF  xA8,W
57F6:  BTFSS  FD8.0
57F8:  BRA    5B7A
57FA:  BNZ   5804
57FC:  MOVF   xA5,W
57FE:  SUBWF  xA7,W
5800:  BTFSS  FD8.0
5802:  BRA    5B7A
5804:  CLRF   19
5806:  BTFSC  FF2.7
5808:  BSF    19.7
580A:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
580C:  MOVFF  6A6,7EC
5810:  MOVFF  6A5,7EB
5814:  MOVLB  7
5816:  CLRF   xEE
5818:  MOVLW  7C
581A:  MOVWF  xED
581C:  MOVLB  0
581E:  CALL   3922
5822:  BTFSC  19.7
5824:  BSF    FF2.7
5826:  MOVLW  96
5828:  MOVLB  7
582A:  ADDWF  01,W
582C:  MOVWF  xB8
582E:  MOVLW  00
5830:  ADDWFC 02,W
5832:  MOVWF  xB9
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
5834:  MOVLW  7C
5836:  SUBWF  xB8,W
5838:  MOVWF  xBA
583A:  MOVLW  00
583C:  SUBWFB xB9,W
583E:  MOVWF  xBB
5840:  MOVWF  xBD
5842:  MOVFF  7BA,7BC
5846:  CLRF   xBF
5848:  MOVLW  7C
584A:  MOVWF  xBE
584C:  CLRF   xC1
584E:  MOVLW  7D
5850:  MOVWF  xC0
5852:  MOVLB  0
5854:  GOTO   4FF8
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
5858:  MOVLW  10
585A:  MOVWF  FE9
585C:  CLRF   19
585E:  BTFSC  FF2.7
5860:  BSF    19.7
5862:  BCF    FF2.7
5864:  MOVFF  6A6,7E7
5868:  MOVFF  6A5,7E6
586C:  CALL   46BE
5870:  BTFSC  19.7
5872:  BSF    FF2.7
5874:  CLRF   19
5876:  BTFSC  FF2.7
5878:  BSF    19.7
587A:  BCF    FF2.7
587C:  MOVLW  29
587E:  MOVLB  8
5880:  MOVWF  x1A
5882:  MOVLB  0
5884:  CALL   043A
5888:  BTFSC  19.7
588A:  BSF    FF2.7
588C:  MOVFF  7D,7BA
5890:  MOVLW  01
5892:  MOVLB  7
5894:  MOVWF  xBB
5896:  MOVLB  0
5898:  CALL   506E
589C:  CLRF   19
589E:  BTFSC  FF2.7
58A0:  BSF    19.7
58A2:  BCF    FF2.7
58A4:  MOVLW  2F
58A6:  MOVLB  8
58A8:  MOVWF  x1A
58AA:  MOVLB  0
58AC:  CALL   043A
58B0:  BTFSC  19.7
58B2:  BSF    FF2.7
58B4:  MOVFF  7E,7BA
58B8:  MOVLW  01
58BA:  MOVLB  7
58BC:  MOVWF  xBB
58BE:  MOVLB  0
58C0:  CALL   506E
58C4:  CLRF   19
58C6:  BTFSC  FF2.7
58C8:  BSF    19.7
58CA:  BCF    FF2.7
58CC:  MOVLW  20
58CE:  MOVLB  8
58D0:  MOVWF  x1A
58D2:  MOVLB  0
58D4:  CALL   043A
58D8:  BTFSC  19.7
58DA:  BSF    FF2.7
58DC:  MOVFF  7F,7BA
58E0:  MOVLW  01
58E2:  MOVLB  7
58E4:  MOVWF  xBB
58E6:  MOVLB  0
58E8:  CALL   506E
58EC:  CLRF   19
58EE:  BTFSC  FF2.7
58F0:  BSF    19.7
58F2:  BCF    FF2.7
58F4:  MOVLW  3A
58F6:  MOVLB  8
58F8:  MOVWF  x1A
58FA:  MOVLB  0
58FC:  CALL   043A
5900:  BTFSC  19.7
5902:  BSF    FF2.7
5904:  MOVFF  80,7BA
5908:  MOVLW  01
590A:  MOVLB  7
590C:  MOVWF  xBB
590E:  MOVLB  0
5910:  CALL   506E
5914:  CLRF   19
5916:  BTFSC  FF2.7
5918:  BSF    19.7
591A:  BCF    FF2.7
591C:  MOVLW  3A
591E:  MOVLB  8
5920:  MOVWF  x1A
5922:  MOVLB  0
5924:  CALL   043A
5928:  BTFSC  19.7
592A:  BSF    FF2.7
592C:  MOVFF  81,7BA
5930:  MOVLW  01
5932:  MOVLB  7
5934:  MOVWF  xBB
5936:  MOVLB  0
5938:  CALL   506E
....................             ee_dat=0; 
593C:  MOVLB  6
593E:  CLRF   xA4
....................             index=0; 
5940:  MOVLB  7
5942:  CLRF   x84
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
5944:  MOVLW  E6
5946:  MOVWF  FF6
5948:  MOVLW  1E
594A:  MOVWF  FF7
594C:  CLRF   19
594E:  BTFSC  FF2.7
5950:  BSF    19.7
5952:  BCF    FF2.7
5954:  MOVLB  0
5956:  CALL   048C
595A:  BTFSC  19.7
595C:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
595E:  MOVLB  7
5960:  MOVF   x84,W
5962:  SUBLW  4E
5964:  BNC   59C2
5966:  MOVLB  6
5968:  MOVF   xA4,W
596A:  SUBLW  3F
596C:  BTFSS  FD8.2
596E:  BRA    5974
5970:  MOVLB  7
5972:  BRA    59C2
....................                ee_dat = rec[index+5]; 
5974:  MOVLW  05
5976:  MOVLB  7
5978:  ADDWF  x84,W
597A:  CLRF   03
597C:  ADDLW  7D
597E:  MOVWF  FE9
5980:  MOVLW  00
5982:  ADDWFC 03,W
5984:  MOVWF  FEA
5986:  MOVFF  FEF,6A4
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
598A:  MOVLB  6
598C:  MOVF   xA4,W
598E:  SUBLW  1F
5990:  BC    59AE
5992:  MOVF   xA4,W
5994:  SUBLW  7E
5996:  BNC   59AE
5998:  CLRF   19
599A:  BTFSC  FF2.7
599C:  BSF    19.7
599E:  BCF    FF2.7
59A0:  MOVFF  6A4,81A
59A4:  MOVLB  0
59A6:  CALL   043A
59AA:  BTFSC  19.7
59AC:  BSF    FF2.7
....................                index++; 
59AE:  MOVLB  7
59B0:  INCF   x84,F
....................                if(ee_dat==0)break; 
59B2:  MOVLB  6
59B4:  MOVF   xA4,F
59B6:  BNZ   59BC
59B8:  MOVLB  7
59BA:  BRA    59C2
....................             } 
59BC:  MOVLB  0
59BE:  BRA    595E
59C0:  MOVLB  7
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
59C2:  MOVLW  F8
59C4:  MOVWF  FF6
59C6:  MOVLW  1E
59C8:  MOVWF  FF7
59CA:  CLRF   19
59CC:  BTFSC  FF2.7
59CE:  BSF    19.7
59D0:  BCF    FF2.7
59D2:  MOVLB  0
59D4:  CALL   048C
59D8:  BTFSC  19.7
59DA:  BSF    FF2.7
....................             index=0; 
59DC:  MOVLB  7
59DE:  CLRF   x84
....................             ee_dat=0; 
59E0:  MOVLB  6
59E2:  CLRF   xA4
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
59E4:  MOVLB  7
59E6:  MOVF   x84,W
59E8:  SUBLW  27
59EA:  BNC   5A4A
59EC:  MOVLB  6
59EE:  MOVF   xA4,W
59F0:  SUBLW  3F
59F2:  BTFSS  FD8.2
59F4:  BRA    59FA
59F6:  MOVLB  7
59F8:  BRA    5A4A
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
59FA:  MOVLW  05
59FC:  MOVLB  7
59FE:  ADDWF  x84,W
5A00:  ADDLW  4F
5A02:  CLRF   03
5A04:  ADDLW  7D
5A06:  MOVWF  FE9
5A08:  MOVLW  00
5A0A:  ADDWFC 03,W
5A0C:  MOVWF  FEA
5A0E:  MOVFF  FEF,6A4
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
5A12:  MOVLB  6
5A14:  MOVF   xA4,W
5A16:  SUBLW  1F
5A18:  BC    5A36
5A1A:  MOVF   xA4,W
5A1C:  SUBLW  7E
5A1E:  BNC   5A36
5A20:  CLRF   19
5A22:  BTFSC  FF2.7
5A24:  BSF    19.7
5A26:  BCF    FF2.7
5A28:  MOVFF  6A4,81A
5A2C:  MOVLB  0
5A2E:  CALL   043A
5A32:  BTFSC  19.7
5A34:  BSF    FF2.7
....................                index++; 
5A36:  MOVLB  7
5A38:  INCF   x84,F
....................                if(ee_dat==0)break; 
5A3A:  MOVLB  6
5A3C:  MOVF   xA4,F
5A3E:  BNZ   5A46
5A40:  MOVLB  7
5A42:  BRA    5A4A
5A44:  MOVLB  6
....................             } 
5A46:  BRA    59E4
5A48:  MOVLB  7
....................             index=0; 
5A4A:  CLRF   x84
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
5A4C:  MOVLW  0A
5A4E:  MOVWF  FF6
5A50:  MOVLW  1F
5A52:  MOVWF  FF7
5A54:  CLRF   19
5A56:  BTFSC  FF2.7
5A58:  BSF    19.7
5A5A:  BCF    FF2.7
5A5C:  MOVLB  0
5A5E:  CALL   048C
5A62:  BTFSC  19.7
5A64:  BSF    FF2.7
....................             //fprintf(COM2,"addr_key =%lu \n\r",addr_key);  
....................             //fprintf(COM2," ptr_card_key=%lu \n\r",ptr_card_key);  
....................             if(ptr_card_key>addr_key) 
5A66:  MOVLB  6
5A68:  MOVF   xAD,W
5A6A:  SUBWF  27,W
5A6C:  BTFSS  FD8.0
5A6E:  BRA    5B72
5A70:  BNZ   5A8E
5A72:  MOVF   xAC,W
5A74:  SUBWF  26,W
5A76:  BTFSS  FD8.0
5A78:  BRA    5B72
5A7A:  BNZ   5A8E
5A7C:  MOVF   xAB,W
5A7E:  SUBWF  25,W
5A80:  BTFSS  FD8.0
5A82:  BRA    5B72
5A84:  BNZ   5A8E
5A86:  MOVF   24,W
5A88:  SUBWF  xAA,W
5A8A:  BTFSC  FD8.0
5A8C:  BRA    5B72
....................             { 
....................                i=0; 
5A8E:  MOVLB  7
5A90:  CLRF   x85
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
5A92:  MOVF   x85,W
5A94:  MOVLB  6
5A96:  ADDWF  xAA,W
5A98:  MOVLB  7
5A9A:  MOVWF  xBA
5A9C:  MOVLW  00
5A9E:  MOVLB  6
5AA0:  ADDWFC xAB,W
5AA2:  MOVLB  7
5AA4:  MOVWF  xBB
5AA6:  MOVLW  00
5AA8:  MOVLB  6
5AAA:  ADDWFC xAC,W
5AAC:  MOVLB  7
5AAE:  MOVWF  xBC
5AB0:  MOVLW  00
5AB2:  MOVLB  6
5AB4:  ADDWFC xAD,W
5AB6:  MOVLB  7
5AB8:  MOVWF  xBD
5ABA:  CLRF   19
5ABC:  BTFSC  FF2.7
5ABE:  BSF    19.7
5AC0:  BCF    FF2.7
5AC2:  MOVFF  FE8,80D
5AC6:  MOVFF  7BC,80C
5ACA:  MOVFF  7BB,80B
5ACE:  MOVFF  7BA,80A
5AD2:  MOVLB  0
5AD4:  CALL   37FA
5AD8:  BTFSC  19.7
5ADA:  BSF    FF2.7
5ADC:  MOVFF  01,6A4
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
5AE0:  MOVLB  6
5AE2:  MOVF   xA4,W
5AE4:  SUBLW  2F
5AE6:  BC    5AEE
5AE8:  MOVF   xA4,W
5AEA:  SUBLW  39
5AEC:  BC    5B06
5AEE:  MOVF   xA4,W
5AF0:  SUBLW  23
5AF2:  BZ    5B06
5AF4:  MOVF   xA4,W
5AF6:  SUBLW  2A
5AF8:  BZ    5B06
5AFA:  MOVF   xA4,W
5AFC:  SUBLW  40
5AFE:  BC    5B1C
5B00:  MOVF   xA4,W
5B02:  SUBLW  5A
5B04:  BNC   5B1C
5B06:  CLRF   19
5B08:  BTFSC  FF2.7
5B0A:  BSF    19.7
5B0C:  BCF    FF2.7
....................                      fputc(ee_dat,COM2); 
5B0E:  MOVFF  6A4,81A
5B12:  MOVLB  0
5B14:  CALL   043A
5B18:  BTFSC  19.7
5B1A:  BSF    FF2.7
....................                   i++; 
5B1C:  MOVLB  7
5B1E:  INCF   x85,F
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
5B20:  MOVF   x85,W
5B22:  SUBLW  0F
5B24:  BNC   5B32
5B26:  MOVLB  6
5B28:  MOVF   xA4,F
5B2A:  BTFSC  FD8.2
5B2C:  BRA    5B32
5B2E:  MOVLB  7
5B30:  BRA    5A92
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+key_numbyte; 
5B32:  MOVLW  10
5B34:  MOVLB  6
5B36:  ADDWF  xAA,F
5B38:  MOVLW  00
5B3A:  ADDWFC xAB,F
5B3C:  ADDWFC xAC,F
5B3E:  ADDWFC xAD,F
5B40:  CLRF   19
5B42:  BTFSC  FF2.7
5B44:  BSF    19.7
5B46:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
5B48:  MOVLW  0A
5B4A:  MOVLB  8
5B4C:  MOVWF  x1A
5B4E:  MOVLB  0
5B50:  CALL   043A
5B54:  BTFSC  19.7
5B56:  BSF    FF2.7
5B58:  CLRF   19
5B5A:  BTFSC  FF2.7
5B5C:  BSF    19.7
5B5E:  BCF    FF2.7
5B60:  MOVLW  0D
5B62:  MOVLB  8
5B64:  MOVWF  x1A
5B66:  MOVLB  0
5B68:  CALL   043A
5B6C:  BTFSC  19.7
5B6E:  BSF    FF2.7
5B70:  MOVLB  6
....................             } 
....................             count_card++; 
5B72:  INCF   xA5,F
5B74:  BTFSC  FD8.2
5B76:  INCF   xA6,F
....................          } 
5B78:  BRA    57F2
5B7A:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
5B7C:  CLRF   FEA
5B7E:  MOVLW  41
5B80:  MOVWF  FE9
5B82:  MOVLW  00
5B84:  CALL   012E
5B88:  TBLRD*-
5B8A:  TBLRD*+
5B8C:  MOVF   FF5,W
5B8E:  MOVWF  FEE
5B90:  IORLW  00
5B92:  BNZ   5B8A
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5B94:  MOVLW  01
5B96:  MOVLB  7
5B98:  MOVWF  xBB
5B9A:  MOVLW  2C
5B9C:  MOVWF  xBA
5B9E:  CLRF   xBD
5BA0:  MOVLW  41
5BA2:  MOVWF  xBC
5BA4:  MOVLB  0
5BA6:  CALL   4F2C
5BAA:  MOVF   01,F
5BAC:  BNZ   5BE2
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
5BAE:  MOVLW  1A
5BB0:  MOVWF  FF6
5BB2:  MOVLW  1F
5BB4:  MOVWF  FF7
5BB6:  CLRF   19
5BB8:  BTFSC  FF2.7
5BBA:  BSF    19.7
5BBC:  BCF    FF2.7
5BBE:  CALL   048C
5BC2:  BTFSC  19.7
5BC4:  BSF    FF2.7
....................          format_eepromext(); 
5BC6:  GOTO   5188
....................          fprintf(COM2," exit\n\r");  
5BCA:  MOVLW  28
5BCC:  MOVWF  FF6
5BCE:  MOVLW  1F
5BD0:  MOVWF  FF7
5BD2:  CLRF   19
5BD4:  BTFSC  FF2.7
5BD6:  BSF    19.7
5BD8:  BCF    FF2.7
5BDA:  CALL   048C
5BDE:  BTFSC  19.7
5BE0:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
5BE2:  CLRF   FEA
5BE4:  MOVLW  41
5BE6:  MOVWF  FE9
5BE8:  MOVLW  00
5BEA:  CALL   0140
5BEE:  TBLRD*-
5BF0:  TBLRD*+
5BF2:  MOVF   FF5,W
5BF4:  MOVWF  FEE
5BF6:  IORLW  00
5BF8:  BNZ   5BF0
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5BFA:  MOVLW  01
5BFC:  MOVLB  7
5BFE:  MOVWF  xBB
5C00:  MOVLW  2C
5C02:  MOVWF  xBA
5C04:  CLRF   xBD
5C06:  MOVLW  41
5C08:  MOVWF  xBC
5C0A:  MOVLB  0
5C0C:  CALL   4F2C
5C10:  MOVF   01,F
5C12:  BNZ   5C48
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
5C14:  MOVLW  30
5C16:  MOVWF  FF6
5C18:  MOVLW  1F
5C1A:  MOVWF  FF7
5C1C:  CLRF   19
5C1E:  BTFSC  FF2.7
5C20:  BSF    19.7
5C22:  BCF    FF2.7
5C24:  CALL   048C
5C28:  BTFSC  19.7
5C2A:  BSF    FF2.7
....................          ease_eeprom(); 
5C2C:  GOTO   52EC
....................          fprintf(COM2," exit\n\r");  
5C30:  MOVLW  3E
5C32:  MOVWF  FF6
5C34:  MOVLW  1F
5C36:  MOVWF  FF7
5C38:  CLRF   19
5C3A:  BTFSC  FF2.7
5C3C:  BSF    19.7
5C3E:  BCF    FF2.7
5C40:  CALL   048C
5C44:  BTFSC  19.7
5C46:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
5C48:  CLRF   FEA
5C4A:  MOVLW  41
5C4C:  MOVWF  FE9
5C4E:  MOVLW  00
5C50:  CALL   0156
5C54:  TBLRD*-
5C56:  TBLRD*+
5C58:  MOVF   FF5,W
5C5A:  MOVWF  FEE
5C5C:  IORLW  00
5C5E:  BNZ   5C56
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5C60:  MOVLW  01
5C62:  MOVLB  7
5C64:  MOVWF  xBB
5C66:  MOVLW  2C
5C68:  MOVWF  xBA
5C6A:  CLRF   xBD
5C6C:  MOVLW  41
5C6E:  MOVWF  xBC
5C70:  MOVLB  0
5C72:  CALL   4F2C
5C76:  MOVF   01,F
5C78:  BNZ   5CB2
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
5C7A:  MOVLW  46
5C7C:  MOVWF  FF6
5C7E:  MOVLW  1F
5C80:  MOVWF  FF7
5C82:  CLRF   19
5C84:  BTFSC  FF2.7
5C86:  BSF    19.7
5C88:  BCF    FF2.7
5C8A:  CALL   048C
5C8E:  BTFSC  19.7
5C90:  BSF    FF2.7
....................          reset_password(); 
5C92:  GOTO   5370
....................          init_password(); 
5C96:  CALL   4B50
....................          fprintf(COM2," exit\n\r");  
5C9A:  MOVLW  5C
5C9C:  MOVWF  FF6
5C9E:  MOVLW  1F
5CA0:  MOVWF  FF7
5CA2:  CLRF   19
5CA4:  BTFSC  FF2.7
5CA6:  BSF    19.7
5CA8:  BCF    FF2.7
5CAA:  CALL   048C
5CAE:  BTFSC  19.7
5CB0:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
5CB2:  CLRF   FEA
5CB4:  MOVLW  41
5CB6:  MOVWF  FE9
5CB8:  MOVLW  00
5CBA:  CALL   016C
5CBE:  TBLRD*-
5CC0:  TBLRD*+
5CC2:  MOVF   FF5,W
5CC4:  MOVWF  FEE
5CC6:  IORLW  00
5CC8:  BNZ   5CC0
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5CCA:  MOVLW  01
5CCC:  MOVLB  7
5CCE:  MOVWF  xBB
5CD0:  MOVLW  2C
5CD2:  MOVWF  xBA
5CD4:  CLRF   xBD
5CD6:  MOVLW  41
5CD8:  MOVWF  xBC
5CDA:  MOVLB  0
5CDC:  CALL   4F2C
5CE0:  MOVF   01,F
5CE2:  BNZ   5D04
....................       { 
....................          keydebug_en=1; 
5CE4:  MOVLW  01
5CE6:  MOVLB  1
5CE8:  MOVWF  x0B
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
5CEA:  MOVLW  64
5CEC:  MOVWF  FF6
5CEE:  MOVLW  1F
5CF0:  MOVWF  FF7
5CF2:  CLRF   19
5CF4:  BTFSC  FF2.7
5CF6:  BSF    19.7
5CF8:  BCF    FF2.7
5CFA:  MOVLB  0
5CFC:  CALL   048C
5D00:  BTFSC  19.7
5D02:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
5D04:  CLRF   FEA
5D06:  MOVLW  41
5D08:  MOVWF  FE9
5D0A:  MOVLW  00
5D0C:  CALL   0182
5D10:  TBLRD*-
5D12:  TBLRD*+
5D14:  MOVF   FF5,W
5D16:  MOVWF  FEE
5D18:  IORLW  00
5D1A:  BNZ   5D12
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5D1C:  MOVLW  01
5D1E:  MOVLB  7
5D20:  MOVWF  xBB
5D22:  MOVLW  2C
5D24:  MOVWF  xBA
5D26:  CLRF   xBD
5D28:  MOVLW  41
5D2A:  MOVWF  xBC
5D2C:  MOVLB  0
5D2E:  CALL   4F2C
5D32:  MOVF   01,F
5D34:  BNZ   5D52
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
5D36:  MOVLW  78
5D38:  MOVWF  FF6
5D3A:  MOVLW  1F
5D3C:  MOVWF  FF7
5D3E:  CLRF   19
5D40:  BTFSC  FF2.7
5D42:  BSF    19.7
5D44:  BCF    FF2.7
5D46:  CALL   048C
5D4A:  BTFSC  19.7
5D4C:  BSF    FF2.7
....................          rstfact(); 
5D4E:  GOTO   53A6
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
5D52:  CLRF   FEA
5D54:  MOVLW  41
5D56:  MOVWF  FE9
5D58:  MOVLW  00
5D5A:  CALL   019A
5D5E:  TBLRD*-
5D60:  TBLRD*+
5D62:  MOVF   FF5,W
5D64:  MOVWF  FEE
5D66:  IORLW  00
5D68:  BNZ   5D60
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
5D6A:  MOVLW  01
5D6C:  MOVLB  7
5D6E:  MOVWF  xBB
5D70:  MOVLW  2C
5D72:  MOVWF  xBA
5D74:  CLRF   xBD
5D76:  MOVLW  41
5D78:  MOVWF  xBC
5D7A:  MOVLB  0
5D7C:  CALL   4F2C
5D80:  MOVF   01,F
5D82:  BNZ   5DAA
....................       { 
....................          mode=LOGOFF; 
5D84:  MOVLB  6
5D86:  CLRF   xA3
....................          keydebug_en=0; 
5D88:  MOVLB  1
5D8A:  CLRF   x0B
....................          set_tris_a(0xff); 
5D8C:  MOVLW  FF
5D8E:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
5D90:  MOVLW  88
5D92:  MOVWF  FF6
5D94:  MOVLW  1F
5D96:  MOVWF  FF7
5D98:  CLRF   19
5D9A:  BTFSC  FF2.7
5D9C:  BSF    19.7
5D9E:  BCF    FF2.7
5DA0:  MOVLB  0
5DA2:  CALL   048C
5DA6:  BTFSC  19.7
5DA8:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
5DAA:  CLRF   FEA
5DAC:  MOVLW  41
5DAE:  MOVWF  FE9
5DB0:  MOVLW  00
5DB2:  CALL   01AC
5DB6:  TBLRD*-
5DB8:  TBLRD*+
5DBA:  MOVF   FF5,W
5DBC:  MOVWF  FEE
5DBE:  IORLW  00
5DC0:  BNZ   5DB8
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5DC2:  MOVLW  01
5DC4:  MOVLB  7
5DC6:  MOVWF  xBB
5DC8:  MOVLW  2C
5DCA:  MOVWF  xBA
5DCC:  CLRF   xBD
5DCE:  MOVLW  41
5DD0:  MOVWF  xBC
5DD2:  MOVLB  0
5DD4:  CALL   4F2C
5DD8:  MOVF   01,F
5DDA:  BNZ   5E3C
....................       { 
....................          fprintf(COM2,"New console name>"); 
5DDC:  MOVLW  90
5DDE:  MOVWF  FF6
5DE0:  MOVLW  1F
5DE2:  MOVWF  FF7
5DE4:  CLRF   19
5DE6:  BTFSC  FF2.7
5DE8:  BSF    19.7
5DEA:  BCF    FF2.7
5DEC:  CALL   048C
5DF0:  BTFSC  19.7
5DF2:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,16, console); 
5DF4:  MOVLW  01
5DF6:  MOVLB  7
5DF8:  MOVWF  xBA
5DFA:  MOVLW  10
5DFC:  MOVWF  xBB
5DFE:  MOVLW  06
5E00:  MOVWF  xBD
5E02:  MOVLW  AE
5E04:  MOVWF  xBC
5E06:  MOVLB  0
5E08:  CALL   4DF4
....................          EEPROM_write(strobe_nameconsole,16,console); 
5E0C:  MOVLW  66
5E0E:  MOVLB  7
5E10:  MOVWF  xCF
5E12:  MOVLW  10
5E14:  MOVWF  xD0
5E16:  MOVLW  06
5E18:  MOVWF  xD2
5E1A:  MOVLW  AE
5E1C:  MOVWF  xD1
5E1E:  MOVLB  0
5E20:  CALL   4AF8
....................          fprintf(COM2," OK\n\r"); 
5E24:  MOVLW  A2
5E26:  MOVWF  FF6
5E28:  MOVLW  1F
5E2A:  MOVWF  FF7
5E2C:  CLRF   19
5E2E:  BTFSC  FF2.7
5E30:  BSF    19.7
5E32:  BCF    FF2.7
5E34:  CALL   048C
5E38:  BTFSC  19.7
5E3A:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
5E3C:  CLRF   FEA
5E3E:  MOVLW  41
5E40:  MOVWF  FE9
5E42:  MOVLW  00
5E44:  CALL   01BE
5E48:  TBLRD*-
5E4A:  TBLRD*+
5E4C:  MOVF   FF5,W
5E4E:  MOVWF  FEE
5E50:  IORLW  00
5E52:  BNZ   5E4A
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
5E54:  MOVLW  01
5E56:  MOVLB  7
5E58:  MOVWF  xBB
5E5A:  MOVLW  2C
5E5C:  MOVWF  xBA
5E5E:  CLRF   xBD
5E60:  MOVLW  41
5E62:  MOVWF  xBC
5E64:  MOVLB  0
5E66:  CALL   4F2C
5E6A:  MOVF   01,F
5E6C:  BTFSS  FD8.2
5E6E:  BRA    60D4
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
*
5F3A:  MOVLB  8
5F3C:  CLRF   x0D
5F3E:  CLRF   x0C
5F40:  CLRF   x0B
5F42:  MOVLW  91
5F44:  MOVWF  x0A
5F46:  MOVLB  0
5F48:  CALL   37FA
5F4C:  BTFSC  19.7
5F4E:  BSF    FF2.7
5F50:  MOVFF  01,6A9
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
5F54:  MOVLB  6
5F56:  MOVF   xA9,F
5F58:  BNZ   5F78
5F5A:  MOVLW  A8
5F5C:  MOVWF  FF6
5F5E:  MOVLW  1F
5F60:  MOVWF  FF7
5F62:  CLRF   19
5F64:  BTFSC  FF2.7
5F66:  BSF    19.7
5F68:  BCF    FF2.7
5F6A:  MOVLB  0
5F6C:  CALL   048C
5F70:  BTFSC  19.7
5F72:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
5F74:  BRA    5F92
5F76:  MOVLB  6
5F78:  MOVLW  AC
5F7A:  MOVWF  FF6
5F7C:  MOVLW  1F
5F7E:  MOVWF  FF7
5F80:  CLRF   19
5F82:  BTFSC  FF2.7
5F84:  BSF    19.7
5F86:  BCF    FF2.7
5F88:  MOVLB  0
5F8A:  CALL   048C
5F8E:  BTFSC  19.7
5F90:  BSF    FF2.7
5F92:  CLRF   19
5F94:  BTFSC  FF2.7
5F96:  BSF    19.7
5F98:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
5F9A:  MOVLB  8
5F9C:  CLRF   x0D
5F9E:  CLRF   x0C
5FA0:  CLRF   x0B
5FA2:  MOVLW  94
5FA4:  MOVWF  x0A
5FA6:  MOVLB  0
5FA8:  CALL   37FA
5FAC:  BTFSC  19.7
5FAE:  BSF    FF2.7
5FB0:  MOVFF  01,124
5FB4:  CLRF   19
5FB6:  BTFSC  FF2.7
5FB8:  BSF    19.7
5FBA:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
5FBC:  MOVLW  5B
5FBE:  MOVLB  8
5FC0:  MOVWF  x1A
5FC2:  MOVLB  0
5FC4:  CALL   043A
5FC8:  BTFSC  19.7
5FCA:  BSF    FF2.7
5FCC:  MOVFF  124,7BA
5FD0:  MOVLW  1B
5FD2:  MOVLB  7
5FD4:  MOVWF  xBB
5FD6:  MOVLB  0
5FD8:  GOTO   5442
5FDC:  CLRF   19
5FDE:  BTFSC  FF2.7
5FE0:  BSF    19.7
5FE2:  BCF    FF2.7
5FE4:  MOVLW  5D
5FE6:  MOVLB  8
5FE8:  MOVWF  x1A
5FEA:  MOVLB  0
5FEC:  CALL   043A
5FF0:  BTFSC  19.7
5FF2:  BSF    FF2.7
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
5FF4:  MOVFF  100,7BA
5FF8:  MOVLW  01
5FFA:  MOVLB  7
5FFC:  MOVWF  xBB
5FFE:  MOVLB  0
6000:  CALL   506E
6004:  CLRF   19
6006:  BTFSC  FF2.7
6008:  BSF    19.7
600A:  BCF    FF2.7
600C:  MOVLW  2F
600E:  MOVLB  8
6010:  MOVWF  x1A
6012:  MOVLB  0
6014:  CALL   043A
6018:  BTFSC  19.7
601A:  BSF    FF2.7
601C:  MOVFF  FF,7BA
6020:  MOVLW  01
6022:  MOVLB  7
6024:  MOVWF  xBB
6026:  MOVLB  0
6028:  CALL   506E
602C:  CLRF   19
602E:  BTFSC  FF2.7
6030:  BSF    19.7
6032:  BCF    FF2.7
6034:  MOVLW  20
6036:  MOVLB  8
6038:  MOVWF  x1A
603A:  MOVLB  0
603C:  CALL   043A
6040:  BTFSC  19.7
6042:  BSF    FF2.7
6044:  MOVFF  101,7BA
6048:  MOVLW  01
604A:  MOVLB  7
604C:  MOVWF  xBB
604E:  MOVLB  0
6050:  CALL   506E
6054:  CLRF   19
6056:  BTFSC  FF2.7
6058:  BSF    19.7
605A:  BCF    FF2.7
605C:  MOVLW  3A
605E:  MOVLB  8
6060:  MOVWF  x1A
6062:  MOVLB  0
6064:  CALL   043A
6068:  BTFSC  19.7
606A:  BSF    FF2.7
606C:  MOVFF  102,7BA
6070:  MOVLW  01
6072:  MOVLB  7
6074:  MOVWF  xBB
6076:  MOVLB  0
6078:  CALL   506E
607C:  CLRF   19
607E:  BTFSC  FF2.7
6080:  BSF    19.7
6082:  BCF    FF2.7
6084:  MOVLW  3A
6086:  MOVLB  8
6088:  MOVWF  x1A
608A:  MOVLB  0
608C:  CALL   043A
6090:  BTFSC  19.7
6092:  BSF    FF2.7
6094:  MOVFF  103,7BA
6098:  MOVLW  01
609A:  MOVLB  7
609C:  MOVWF  xBB
609E:  MOVLB  0
60A0:  CALL   506E
60A4:  CLRF   19
60A6:  BTFSC  FF2.7
60A8:  BSF    19.7
60AA:  BCF    FF2.7
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
60AC:  MOVLW  0A
60AE:  MOVLB  8
60B0:  MOVWF  x1A
60B2:  MOVLB  0
60B4:  CALL   043A
60B8:  BTFSC  19.7
60BA:  BSF    FF2.7
60BC:  CLRF   19
60BE:  BTFSC  FF2.7
60C0:  BSF    19.7
60C2:  BCF    FF2.7
60C4:  MOVLW  0D
60C6:  MOVLB  8
60C8:  MOVWF  x1A
60CA:  MOVLB  0
60CC:  CALL   043A
60D0:  BTFSC  19.7
60D2:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
60D4:  CLRF   FEA
60D6:  MOVLW  41
60D8:  MOVWF  FE9
60DA:  MOVLW  00
60DC:  CALL   01D0
60E0:  TBLRD*-
60E2:  TBLRD*+
60E4:  MOVF   FF5,W
60E6:  MOVWF  FEE
60E8:  IORLW  00
60EA:  BNZ   60E2
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
60EC:  MOVLW  01
60EE:  MOVLB  7
60F0:  MOVWF  xBB
60F2:  MOVLW  2C
60F4:  MOVWF  xBA
60F6:  CLRF   xBD
60F8:  MOVLW  41
60FA:  MOVWF  xBC
60FC:  MOVLB  0
60FE:  CALL   4F2C
6102:  MOVF   01,F
6104:  BTFSS  FD8.2
6106:  BRA    6330
....................       { 
....................          fprintf(COM2,"Year>"); 
6108:  MOVLW  B0
610A:  MOVWF  FF6
610C:  MOVLW  1F
610E:  MOVWF  FF7
6110:  CLRF   19
6112:  BTFSC  FF2.7
6114:  BSF    19.7
6116:  BCF    FF2.7
6118:  CALL   048C
611C:  BTFSC  19.7
611E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6120:  MOVLW  01
6122:  MOVLB  7
6124:  MOVWF  xBA
6126:  MOVLW  03
6128:  MOVWF  xBB
612A:  MOVLW  07
612C:  MOVWF  xBD
612E:  MOVLW  86
6130:  MOVWF  xBC
6132:  MOVLB  0
6134:  CALL   4DF4
....................          year=(unsigned int8)strtoi(temp); 
6138:  MOVLW  07
613A:  MOVLB  7
613C:  MOVWF  xBB
613E:  MOVLW  86
6140:  MOVWF  xBA
6142:  MOVLB  0
6144:  CALL   5508
6148:  MOVFF  01,FE
....................          fprintf(COM2,"Month>"); 
614C:  MOVLW  B6
614E:  MOVWF  FF6
6150:  MOVLW  1F
6152:  MOVWF  FF7
6154:  CLRF   19
6156:  BTFSC  FF2.7
6158:  BSF    19.7
615A:  BCF    FF2.7
615C:  CALL   048C
6160:  BTFSC  19.7
6162:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6164:  MOVLW  01
6166:  MOVLB  7
6168:  MOVWF  xBA
616A:  MOVLW  03
616C:  MOVWF  xBB
616E:  MOVLW  07
6170:  MOVWF  xBD
6172:  MOVLW  86
6174:  MOVWF  xBC
6176:  MOVLB  0
6178:  CALL   4DF4
....................          mon=(unsigned int8)strtoi(temp); 
617C:  MOVLW  07
617E:  MOVLB  7
6180:  MOVWF  xBB
6182:  MOVLW  86
6184:  MOVWF  xBA
6186:  MOVLB  0
6188:  CALL   5508
618C:  MOVFF  01,FF
....................          fprintf(COM2,"Date>"); 
6190:  MOVLW  BE
6192:  MOVWF  FF6
6194:  MOVLW  1F
6196:  MOVWF  FF7
6198:  CLRF   19
619A:  BTFSC  FF2.7
619C:  BSF    19.7
619E:  BCF    FF2.7
61A0:  CALL   048C
61A4:  BTFSC  19.7
61A6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
61A8:  MOVLW  01
61AA:  MOVLB  7
61AC:  MOVWF  xBA
61AE:  MOVLW  03
61B0:  MOVWF  xBB
61B2:  MOVLW  07
61B4:  MOVWF  xBD
61B6:  MOVLW  86
61B8:  MOVWF  xBC
61BA:  MOVLB  0
61BC:  CALL   4DF4
....................          date = (unsigned int8)strtoi(temp); 
61C0:  MOVLW  07
61C2:  MOVLB  7
61C4:  MOVWF  xBB
61C6:  MOVLW  86
61C8:  MOVWF  xBA
61CA:  MOVLB  0
61CC:  CALL   5508
61D0:  MOVFF  01,100
....................          fprintf(COM2,"Day>"); 
61D4:  MOVLW  C4
61D6:  MOVWF  FF6
61D8:  MOVLW  1F
61DA:  MOVWF  FF7
61DC:  CLRF   19
61DE:  BTFSC  FF2.7
61E0:  BSF    19.7
61E2:  BCF    FF2.7
61E4:  CALL   048C
61E8:  BTFSC  19.7
61EA:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
61EC:  MOVLW  01
61EE:  MOVLB  7
61F0:  MOVWF  xBA
61F2:  MOVLW  03
61F4:  MOVWF  xBB
61F6:  MOVLW  07
61F8:  MOVWF  xBD
61FA:  MOVLW  86
61FC:  MOVWF  xBC
61FE:  MOVLB  0
6200:  CALL   4DF4
....................          day = (unsigned int8)strtoi(temp); 
6204:  MOVLW  07
6206:  MOVLB  7
6208:  MOVWF  xBB
620A:  MOVLW  86
620C:  MOVWF  xBA
620E:  MOVLB  0
6210:  CALL   5508
6214:  MOVFF  01,FD
....................          fprintf(COM2,"Hour>"); 
6218:  MOVLW  CA
621A:  MOVWF  FF6
621C:  MOVLW  1F
621E:  MOVWF  FF7
6220:  CLRF   19
6222:  BTFSC  FF2.7
6224:  BSF    19.7
6226:  BCF    FF2.7
6228:  CALL   048C
622C:  BTFSC  19.7
622E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6230:  MOVLW  01
6232:  MOVLB  7
6234:  MOVWF  xBA
6236:  MOVLW  03
6238:  MOVWF  xBB
623A:  MOVLW  07
623C:  MOVWF  xBD
623E:  MOVLW  86
6240:  MOVWF  xBC
6242:  MOVLB  0
6244:  CALL   4DF4
....................          h = (unsigned int8)strtoi(temp); 
6248:  MOVLW  07
624A:  MOVLB  7
624C:  MOVWF  xBB
624E:  MOVLW  86
6250:  MOVWF  xBA
6252:  MOVLB  0
6254:  CALL   5508
6258:  MOVFF  01,101
....................          fprintf(COM2,"Minutes>"); 
625C:  MOVLW  D0
625E:  MOVWF  FF6
6260:  MOVLW  1F
6262:  MOVWF  FF7
6264:  CLRF   19
6266:  BTFSC  FF2.7
6268:  BSF    19.7
626A:  BCF    FF2.7
626C:  CALL   048C
6270:  BTFSC  19.7
6272:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6274:  MOVLW  01
6276:  MOVLB  7
6278:  MOVWF  xBA
627A:  MOVLW  03
627C:  MOVWF  xBB
627E:  MOVLW  07
6280:  MOVWF  xBD
6282:  MOVLW  86
6284:  MOVWF  xBC
6286:  MOVLB  0
6288:  CALL   4DF4
....................          min = (unsigned int8)strtoi(temp);                   
628C:  MOVLW  07
628E:  MOVLB  7
6290:  MOVWF  xBB
6292:  MOVLW  86
6294:  MOVWF  xBA
6296:  MOVLB  0
6298:  CALL   5508
629C:  MOVFF  01,102
....................          fprintf(COM2,"Seconds>"); 
62A0:  MOVLW  DA
62A2:  MOVWF  FF6
62A4:  MOVLW  1F
62A6:  MOVWF  FF7
62A8:  CLRF   19
62AA:  BTFSC  FF2.7
62AC:  BSF    19.7
62AE:  BCF    FF2.7
62B0:  CALL   048C
62B4:  BTFSC  19.7
62B6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
62B8:  MOVLW  01
62BA:  MOVLB  7
62BC:  MOVWF  xBA
62BE:  MOVLW  03
62C0:  MOVWF  xBB
62C2:  MOVLW  07
62C4:  MOVWF  xBD
62C6:  MOVLW  86
62C8:  MOVWF  xBC
62CA:  MOVLB  0
62CC:  CALL   4DF4
....................          sec = (unsigned int8)strtoi(temp);                   
62D0:  MOVLW  07
62D2:  MOVLB  7
62D4:  MOVWF  xBB
62D6:  MOVLW  86
62D8:  MOVWF  xBA
62DA:  MOVLB  0
62DC:  CALL   5508
62E0:  MOVFF  01,103
62E4:  CLRF   19
62E6:  BTFSC  FF2.7
62E8:  BSF    19.7
62EA:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
62EC:  MOVLW  0A
62EE:  MOVLB  8
62F0:  MOVWF  x1A
62F2:  MOVLB  0
62F4:  CALL   043A
62F8:  BTFSC  19.7
62FA:  BSF    FF2.7
62FC:  CLRF   19
62FE:  BTFSC  FF2.7
6300:  BSF    19.7
6302:  BCF    FF2.7
6304:  MOVLW  0D
6306:  MOVLB  8
6308:  MOVWF  x1A
630A:  MOVLB  0
630C:  CALL   043A
6310:  BTFSC  19.7
6312:  BSF    FF2.7
....................          rtc_set_datetime(date,mon,year,day,h,min); 
6314:  MOVFF  100,7BA
6318:  MOVFF  FF,7BB
631C:  MOVFF  FE,7BC
6320:  MOVFF  FD,7BD
6324:  MOVFF  101,7BE
6328:  MOVFF  102,7BF
632C:  GOTO   5642
....................       } 
....................       strcpy(buffer2,"MS"); 
6330:  CLRF   FEA
6332:  MOVLW  41
6334:  MOVWF  FE9
6336:  MOVLW  00
6338:  CALL   01E4
633C:  TBLRD*-
633E:  TBLRD*+
6340:  MOVF   FF5,W
6342:  MOVWF  FEE
6344:  IORLW  00
6346:  BNZ   633E
....................       if(!stringcomp(buffer_uart,buffer2)) 
6348:  MOVLW  01
634A:  MOVLB  7
634C:  MOVWF  xBB
634E:  MOVLW  2C
6350:  MOVWF  xBA
6352:  CLRF   xBD
6354:  MOVLW  41
6356:  MOVWF  xBC
6358:  MOVLB  0
635A:  CALL   4F2C
635E:  MOVF   01,F
6360:  BTFSS  FD8.2
6362:  BRA    6476
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
6364:  MOVLW  E4
6366:  MOVWF  FF6
6368:  MOVLW  1F
636A:  MOVWF  FF7
636C:  CLRF   19
636E:  BTFSC  FF2.7
6370:  BSF    19.7
6372:  BCF    FF2.7
6374:  CALL   048C
6378:  BTFSC  19.7
637A:  BSF    FF2.7
637C:  CLRF   19
637E:  BTFSC  FF2.7
6380:  BSF    19.7
6382:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6384:  MOVLW  0A
6386:  MOVLB  8
6388:  MOVWF  x1A
638A:  MOVLB  0
638C:  CALL   043A
6390:  BTFSC  19.7
6392:  BSF    FF2.7
6394:  CLRF   19
6396:  BTFSC  FF2.7
6398:  BSF    19.7
639A:  BCF    FF2.7
639C:  MOVLW  0D
639E:  MOVLB  8
63A0:  MOVWF  x1A
63A2:  MOVLB  0
63A4:  CALL   043A
63A8:  BTFSC  19.7
63AA:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
63AC:  MOVLW  04
63AE:  MOVWF  FF6
63B0:  MOVLW  20
63B2:  MOVWF  FF7
63B4:  CLRF   19
63B6:  BTFSC  FF2.7
63B8:  BSF    19.7
63BA:  BCF    FF2.7
63BC:  CALL   048C
63C0:  BTFSC  19.7
63C2:  BSF    FF2.7
63C4:  CLRF   19
63C6:  BTFSC  FF2.7
63C8:  BSF    19.7
63CA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
63CC:  MOVLW  0A
63CE:  MOVLB  8
63D0:  MOVWF  x1A
63D2:  MOVLB  0
63D4:  CALL   043A
63D8:  BTFSC  19.7
63DA:  BSF    FF2.7
63DC:  CLRF   19
63DE:  BTFSC  FF2.7
63E0:  BSF    19.7
63E2:  BCF    FF2.7
63E4:  MOVLW  0D
63E6:  MOVLB  8
63E8:  MOVWF  x1A
63EA:  MOVLB  0
63EC:  CALL   043A
63F0:  BTFSC  19.7
63F2:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
63F4:  MOVLW  01
63F6:  MOVLB  7
63F8:  MOVWF  xBA
63FA:  MOVLW  03
63FC:  MOVWF  xBB
63FE:  MOVLW  07
6400:  MOVWF  xBD
6402:  MOVLW  86
6404:  MOVWF  xBC
6406:  MOVLB  0
6408:  CALL   4DF4
....................           mode_sl = (unsigned int8)strtoi(temp); 
640C:  MOVLW  07
640E:  MOVLB  7
6410:  MOVWF  xBB
6412:  MOVLW  86
6414:  MOVWF  xBA
6416:  MOVLB  0
6418:  CALL   5508
641C:  MOVFF  01,6A9
6420:  CLRF   19
6422:  BTFSC  FF2.7
6424:  BSF    19.7
6426:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
6428:  MOVLB  8
642A:  CLRF   x05
642C:  CLRF   x04
642E:  CLRF   x03
6430:  MOVLW  91
6432:  MOVWF  x02
6434:  MOVFF  6A9,806
6438:  MOVLB  0
643A:  CALL   3D9A
643E:  BTFSC  19.7
6440:  BSF    FF2.7
....................           set_tris_a(0xff); 
6442:  MOVLW  FF
6444:  MOVWF  F92
6446:  CLRF   19
6448:  BTFSC  FF2.7
644A:  BSF    19.7
644C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
644E:  MOVLW  0A
6450:  MOVLB  8
6452:  MOVWF  x1A
6454:  MOVLB  0
6456:  CALL   043A
645A:  BTFSC  19.7
645C:  BSF    FF2.7
645E:  CLRF   19
6460:  BTFSC  FF2.7
6462:  BSF    19.7
6464:  BCF    FF2.7
6466:  MOVLW  0D
6468:  MOVLB  8
646A:  MOVWF  x1A
646C:  MOVLB  0
646E:  CALL   043A
6472:  BTFSC  19.7
6474:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"KP"); 
6476:  CLRF   FEA
6478:  MOVLW  41
647A:  MOVWF  FE9
647C:  MOVLW  00
647E:  CALL   01F8
6482:  TBLRD*-
6484:  TBLRD*+
6486:  MOVF   FF5,W
6488:  MOVWF  FEE
648A:  IORLW  00
648C:  BNZ   6484
....................       if(!stringcomp(buffer_uart,buffer2)) 
648E:  MOVLW  01
6490:  MOVLB  7
6492:  MOVWF  xBB
6494:  MOVLW  2C
6496:  MOVWF  xBA
6498:  CLRF   xBD
649A:  MOVLW  41
649C:  MOVWF  xBC
649E:  MOVLB  0
64A0:  CALL   4F2C
64A4:  MOVF   01,F
64A6:  BTFSS  FD8.2
64A8:  BRA    65B8
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
64AA:  MOVLW  24
64AC:  MOVWF  FF6
64AE:  MOVLW  20
64B0:  MOVWF  FF7
64B2:  CLRF   19
64B4:  BTFSC  FF2.7
64B6:  BSF    19.7
64B8:  BCF    FF2.7
64BA:  CALL   048C
64BE:  BTFSC  19.7
64C0:  BSF    FF2.7
64C2:  CLRF   19
64C4:  BTFSC  FF2.7
64C6:  BSF    19.7
64C8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
64CA:  MOVLW  0A
64CC:  MOVLB  8
64CE:  MOVWF  x1A
64D0:  MOVLB  0
64D2:  CALL   043A
64D6:  BTFSC  19.7
64D8:  BSF    FF2.7
64DA:  CLRF   19
64DC:  BTFSC  FF2.7
64DE:  BSF    19.7
64E0:  BCF    FF2.7
64E2:  MOVLW  0D
64E4:  MOVLB  8
64E6:  MOVWF  x1A
64E8:  MOVLB  0
64EA:  CALL   043A
64EE:  BTFSC  19.7
64F0:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
64F2:  MOVLW  42
64F4:  MOVWF  FF6
64F6:  MOVLW  20
64F8:  MOVWF  FF7
64FA:  CLRF   19
64FC:  BTFSC  FF2.7
64FE:  BSF    19.7
6500:  BCF    FF2.7
6502:  CALL   048C
6506:  BTFSC  19.7
6508:  BSF    FF2.7
650A:  CLRF   19
650C:  BTFSC  FF2.7
650E:  BSF    19.7
6510:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6512:  MOVLW  0A
6514:  MOVLB  8
6516:  MOVWF  x1A
6518:  MOVLB  0
651A:  CALL   043A
651E:  BTFSC  19.7
6520:  BSF    FF2.7
6522:  CLRF   19
6524:  BTFSC  FF2.7
6526:  BSF    19.7
6528:  BCF    FF2.7
652A:  MOVLW  0D
652C:  MOVLB  8
652E:  MOVWF  x1A
6530:  MOVLB  0
6532:  CALL   043A
6536:  BTFSC  19.7
6538:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
653A:  MOVLW  01
653C:  MOVLB  7
653E:  MOVWF  xBA
6540:  MOVLW  03
6542:  MOVWF  xBB
6544:  MOVLW  07
6546:  MOVWF  xBD
6548:  MOVLW  86
654A:  MOVWF  xBC
654C:  MOVLB  0
654E:  CALL   4DF4
....................           KP_mode = (unsigned int8)strtoi(temp); 
6552:  MOVLW  07
6554:  MOVLB  7
6556:  MOVWF  xBB
6558:  MOVLW  86
655A:  MOVWF  xBA
655C:  MOVLB  0
655E:  CALL   5508
6562:  MOVFF  01,10F
6566:  CLRF   19
6568:  BTFSC  FF2.7
656A:  BSF    19.7
656C:  BCF    FF2.7
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
656E:  MOVLB  8
6570:  CLRF   x05
6572:  CLRF   x04
6574:  CLRF   x03
6576:  MOVLW  7F
6578:  MOVWF  x02
657A:  MOVFF  10F,806
657E:  MOVLB  0
6580:  CALL   3D9A
6584:  BTFSC  19.7
6586:  BSF    FF2.7
6588:  CLRF   19
658A:  BTFSC  FF2.7
658C:  BSF    19.7
658E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6590:  MOVLW  0A
6592:  MOVLB  8
6594:  MOVWF  x1A
6596:  MOVLB  0
6598:  CALL   043A
659C:  BTFSC  19.7
659E:  BSF    FF2.7
65A0:  CLRF   19
65A2:  BTFSC  FF2.7
65A4:  BSF    19.7
65A6:  BCF    FF2.7
65A8:  MOVLW  0D
65AA:  MOVLB  8
65AC:  MOVWF  x1A
65AE:  MOVLB  0
65B0:  CALL   043A
65B4:  BTFSC  19.7
65B6:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"tran time"); 
65B8:  CLRF   FEA
65BA:  MOVLW  41
65BC:  MOVWF  FE9
65BE:  MOVLW  00
65C0:  CALL   020C
65C4:  TBLRD*-
65C6:  TBLRD*+
65C8:  MOVF   FF5,W
65CA:  MOVWF  FEE
65CC:  IORLW  00
65CE:  BNZ   65C6
....................       if(!stringcomp(buffer_uart,buffer2)) 
65D0:  MOVLW  01
65D2:  MOVLB  7
65D4:  MOVWF  xBB
65D6:  MOVLW  2C
65D8:  MOVWF  xBA
65DA:  CLRF   xBD
65DC:  MOVLW  41
65DE:  MOVWF  xBC
65E0:  MOVLB  0
65E2:  CALL   4F2C
65E6:  MOVF   01,F
65E8:  BNZ   66B0
....................       { 
....................           fprintf(COM2,"Input Number"); 
65EA:  MOVLW  60
65EC:  MOVWF  FF6
65EE:  MOVLW  20
65F0:  MOVWF  FF7
65F2:  CLRF   19
65F4:  BTFSC  FF2.7
65F6:  BSF    19.7
65F8:  BCF    FF2.7
65FA:  CALL   048C
65FE:  BTFSC  19.7
6600:  BSF    FF2.7
6602:  CLRF   19
6604:  BTFSC  FF2.7
6606:  BSF    19.7
6608:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
660A:  MOVLW  0A
660C:  MOVLB  8
660E:  MOVWF  x1A
6610:  MOVLB  0
6612:  CALL   043A
6616:  BTFSC  19.7
6618:  BSF    FF2.7
661A:  CLRF   19
661C:  BTFSC  FF2.7
661E:  BSF    19.7
6620:  BCF    FF2.7
6622:  MOVLW  0D
6624:  MOVLB  8
6626:  MOVWF  x1A
6628:  MOVLB  0
662A:  CALL   043A
662E:  BTFSC  19.7
6630:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6632:  MOVLW  01
6634:  MOVLB  7
6636:  MOVWF  xBA
6638:  MOVLW  03
663A:  MOVWF  xBB
663C:  MOVLW  07
663E:  MOVWF  xBD
6640:  MOVLW  86
6642:  MOVWF  xBC
6644:  MOVLB  0
6646:  CALL   4DF4
....................           delaycharaction = (unsigned int8)strtoi(temp); 
664A:  MOVLW  07
664C:  MOVLB  7
664E:  MOVWF  xBB
6650:  MOVLW  86
6652:  MOVWF  xBA
6654:  MOVLB  0
6656:  CALL   5508
665A:  MOVFF  01,124
665E:  CLRF   19
6660:  BTFSC  FF2.7
6662:  BSF    19.7
6664:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
6666:  MOVLB  8
6668:  CLRF   x05
666A:  CLRF   x04
666C:  CLRF   x03
666E:  MOVLW  94
6670:  MOVWF  x02
6672:  MOVFF  124,806
6676:  MOVLB  0
6678:  CALL   3D9A
667C:  BTFSC  19.7
667E:  BSF    FF2.7
6680:  CLRF   19
6682:  BTFSC  FF2.7
6684:  BSF    19.7
6686:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6688:  MOVLW  0A
668A:  MOVLB  8
668C:  MOVWF  x1A
668E:  MOVLB  0
6690:  CALL   043A
6694:  BTFSC  19.7
6696:  BSF    FF2.7
6698:  CLRF   19
669A:  BTFSC  FF2.7
669C:  BSF    19.7
669E:  BCF    FF2.7
66A0:  MOVLW  0D
66A2:  MOVLB  8
66A4:  MOVWF  x1A
66A6:  MOVLB  0
66A8:  CALL   043A
66AC:  BTFSC  19.7
66AE:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
66B0:  CLRF   FEA
66B2:  MOVLW  41
66B4:  MOVWF  FE9
66B6:  MOVLW  00
66B8:  CALL   0226
66BC:  TBLRD*-
66BE:  TBLRD*+
66C0:  MOVF   FF5,W
66C2:  MOVWF  FEE
66C4:  IORLW  00
66C6:  BNZ   66BE
....................       if(!stringcomp(buffer_uart,buffer2)) 
66C8:  MOVLW  01
66CA:  MOVLB  7
66CC:  MOVWF  xBB
66CE:  MOVLW  2C
66D0:  MOVWF  xBA
66D2:  CLRF   xBD
66D4:  MOVLW  41
66D6:  MOVWF  xBC
66D8:  MOVLB  0
66DA:  CALL   4F2C
66DE:  MOVF   01,F
66E0:  BTFSS  FD8.2
66E2:  BRA    67F2
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
66E4:  MOVLW  6E
66E6:  MOVWF  FF6
66E8:  MOVLW  20
66EA:  MOVWF  FF7
66EC:  CLRF   19
66EE:  BTFSC  FF2.7
66F0:  BSF    19.7
66F2:  BCF    FF2.7
66F4:  CALL   048C
66F8:  BTFSC  19.7
66FA:  BSF    FF2.7
66FC:  CLRF   19
66FE:  BTFSC  FF2.7
6700:  BSF    19.7
6702:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6704:  MOVLW  0A
6706:  MOVLB  8
6708:  MOVWF  x1A
670A:  MOVLB  0
670C:  CALL   043A
6710:  BTFSC  19.7
6712:  BSF    FF2.7
6714:  CLRF   19
6716:  BTFSC  FF2.7
6718:  BSF    19.7
671A:  BCF    FF2.7
671C:  MOVLW  0D
671E:  MOVLB  8
6720:  MOVWF  x1A
6722:  MOVLB  0
6724:  CALL   043A
6728:  BTFSC  19.7
672A:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
672C:  MOVLW  94
672E:  MOVWF  FF6
6730:  MOVLW  20
6732:  MOVWF  FF7
6734:  CLRF   19
6736:  BTFSC  FF2.7
6738:  BSF    19.7
673A:  BCF    FF2.7
673C:  CALL   048C
6740:  BTFSC  19.7
6742:  BSF    FF2.7
6744:  CLRF   19
6746:  BTFSC  FF2.7
6748:  BSF    19.7
674A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
674C:  MOVLW  0A
674E:  MOVLB  8
6750:  MOVWF  x1A
6752:  MOVLB  0
6754:  CALL   043A
6758:  BTFSC  19.7
675A:  BSF    FF2.7
675C:  CLRF   19
675E:  BTFSC  FF2.7
6760:  BSF    19.7
6762:  BCF    FF2.7
6764:  MOVLW  0D
6766:  MOVLB  8
6768:  MOVWF  x1A
676A:  MOVLB  0
676C:  CALL   043A
6770:  BTFSC  19.7
6772:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6774:  MOVLW  01
6776:  MOVLB  7
6778:  MOVWF  xBA
677A:  MOVLW  03
677C:  MOVWF  xBB
677E:  MOVLW  07
6780:  MOVWF  xBD
6782:  MOVLW  86
6784:  MOVWF  xBC
6786:  MOVLB  0
6788:  CALL   4DF4
....................           type_KB=(unsigned int8)strtoi(temp); 
678C:  MOVLW  07
678E:  MOVLB  7
6790:  MOVWF  xBB
6792:  MOVLW  86
6794:  MOVWF  xBA
6796:  MOVLB  0
6798:  CALL   5508
679C:  MOVFF  01,113
67A0:  CLRF   19
67A2:  BTFSC  FF2.7
67A4:  BSF    19.7
67A6:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
67A8:  MOVLB  8
67AA:  CLRF   x05
67AC:  CLRF   x04
67AE:  CLRF   x03
67B0:  MOVLW  7E
67B2:  MOVWF  x02
67B4:  MOVFF  113,806
67B8:  MOVLB  0
67BA:  CALL   3D9A
67BE:  BTFSC  19.7
67C0:  BSF    FF2.7
67C2:  CLRF   19
67C4:  BTFSC  FF2.7
67C6:  BSF    19.7
67C8:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
67CA:  MOVLW  0A
67CC:  MOVLB  8
67CE:  MOVWF  x1A
67D0:  MOVLB  0
67D2:  CALL   043A
67D6:  BTFSC  19.7
67D8:  BSF    FF2.7
67DA:  CLRF   19
67DC:  BTFSC  FF2.7
67DE:  BSF    19.7
67E0:  BCF    FF2.7
67E2:  MOVLW  0D
67E4:  MOVLB  8
67E6:  MOVWF  x1A
67E8:  MOVLB  0
67EA:  CALL   043A
67EE:  BTFSC  19.7
67F0:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
67F2:  CLRF   FEA
67F4:  MOVLW  41
67F6:  MOVWF  FE9
67F8:  MOVLW  00
67FA:  CALL   023C
67FE:  TBLRD*-
6800:  TBLRD*+
6802:  MOVF   FF5,W
6804:  MOVWF  FEE
6806:  IORLW  00
6808:  BNZ   6800
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
680A:  MOVLW  01
680C:  MOVLB  7
680E:  MOVWF  xBB
6810:  MOVLW  2C
6812:  MOVWF  xBA
6814:  CLRF   xBD
6816:  MOVLW  41
6818:  MOVWF  xBC
681A:  MOVLB  0
681C:  CALL   4F2C
6820:  MOVF   01,F
6822:  BTFSS  FD8.2
6824:  BRA    6A0C
....................       { 
....................          printf("h-> Help\n\r"); 
6826:  MOVLW  BA
6828:  MOVWF  FF6
682A:  MOVLW  20
682C:  MOVWF  FF7
682E:  CLRF   19
6830:  BTFSC  FF2.7
6832:  BSF    19.7
6834:  BCF    FF2.7
6836:  CALL   048C
683A:  BTFSC  19.7
683C:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
683E:  MOVLW  C6
6840:  MOVWF  FF6
6842:  MOVLW  20
6844:  MOVWF  FF7
6846:  CLRF   19
6848:  BTFSC  FF2.7
684A:  BSF    19.7
684C:  BCF    FF2.7
684E:  CALL   048C
6852:  BTFSC  19.7
6854:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
6856:  MOVLW  D8
6858:  MOVWF  FF6
685A:  MOVLW  20
685C:  MOVWF  FF7
685E:  CLRF   19
6860:  BTFSC  FF2.7
6862:  BSF    19.7
6864:  BCF    FF2.7
6866:  CALL   048C
686A:  BTFSC  19.7
686C:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
686E:  MOVLW  EA
6870:  MOVWF  FF6
6872:  MOVLW  20
6874:  MOVWF  FF7
6876:  CLRF   19
6878:  BTFSC  FF2.7
687A:  BSF    19.7
687C:  BCF    FF2.7
687E:  CALL   048C
6882:  BTFSC  19.7
6884:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
6886:  MOVLW  0A
6888:  MOVWF  FF6
688A:  MOVLW  21
688C:  MOVWF  FF7
688E:  CLRF   19
6890:  BTFSC  FF2.7
6892:  BSF    19.7
6894:  BCF    FF2.7
6896:  CALL   048C
689A:  BTFSC  19.7
689C:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
689E:  MOVLW  26
68A0:  MOVWF  FF6
68A2:  MOVLW  21
68A4:  MOVWF  FF7
68A6:  CLRF   19
68A8:  BTFSC  FF2.7
68AA:  BSF    19.7
68AC:  BCF    FF2.7
68AE:  CALL   048C
68B2:  BTFSC  19.7
68B4:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
68B6:  MOVLW  34
68B8:  MOVWF  FF6
68BA:  MOVLW  21
68BC:  MOVWF  FF7
68BE:  CLRF   19
68C0:  BTFSC  FF2.7
68C2:  BSF    19.7
68C4:  BCF    FF2.7
68C6:  CALL   048C
68CA:  BTFSC  19.7
68CC:  BSF    FF2.7
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
68CE:  MOVLW  40
68D0:  MOVWF  FF6
68D2:  MOVLW  21
68D4:  MOVWF  FF7
68D6:  CLRF   19
68D8:  BTFSC  FF2.7
68DA:  BSF    19.7
68DC:  BCF    FF2.7
68DE:  CALL   048C
68E2:  BTFSC  19.7
68E4:  BSF    FF2.7
68E6:  CLRF   19
68E8:  BTFSC  FF2.7
68EA:  BSF    19.7
68EC:  BCF    FF2.7
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
68EE:  MOVLB  8
68F0:  CLRF   x0D
68F2:  CLRF   x0C
68F4:  CLRF   x0B
68F6:  MOVLW  7F
68F8:  MOVWF  x0A
68FA:  MOVLB  0
68FC:  CALL   37FA
6900:  BTFSC  19.7
6902:  BSF    FF2.7
6904:  MOVFF  01,10F
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
6908:  MOVLB  1
690A:  MOVF   x0F,F
690C:  BZ    692C
690E:  MOVLW  6C
6910:  MOVWF  FF6
6912:  MOVLW  21
6914:  MOVWF  FF7
6916:  CLRF   19
6918:  BTFSC  FF2.7
691A:  BSF    19.7
691C:  BCF    FF2.7
691E:  MOVLB  0
6920:  CALL   048C
6924:  BTFSC  19.7
6926:  BSF    FF2.7
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
6928:  BRA    6946
692A:  MOVLB  1
692C:  MOVLW  8E
692E:  MOVWF  FF6
6930:  MOVLW  21
6932:  MOVWF  FF7
6934:  CLRF   19
6936:  BTFSC  FF2.7
6938:  BSF    19.7
693A:  BCF    FF2.7
693C:  MOVLB  0
693E:  CALL   048C
6942:  BTFSC  19.7
6944:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
6946:  MOVLW  B2
6948:  MOVWF  FF6
694A:  MOVLW  21
694C:  MOVWF  FF7
694E:  CLRF   19
6950:  BTFSC  FF2.7
6952:  BSF    19.7
6954:  BCF    FF2.7
6956:  CALL   048C
695A:  BTFSC  19.7
695C:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
695E:  MOVLW  DA
6960:  MOVWF  FF6
6962:  MOVLW  21
6964:  MOVWF  FF7
6966:  CLRF   19
6968:  BTFSC  FF2.7
696A:  BSF    19.7
696C:  BCF    FF2.7
696E:  CALL   048C
6972:  BTFSC  19.7
6974:  BSF    FF2.7
6976:  CLRF   19
6978:  BTFSC  FF2.7
697A:  BSF    19.7
697C:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
697E:  MOVLB  8
6980:  CLRF   x0D
6982:  CLRF   x0C
6984:  CLRF   x0B
6986:  MOVLW  7E
6988:  MOVWF  x0A
698A:  MOVLB  0
698C:  CALL   37FA
6990:  BTFSC  19.7
6992:  BSF    FF2.7
6994:  MOVFF  01,7BA
6998:  MOVLW  F6
699A:  MOVWF  FF6
699C:  MOVLW  21
699E:  MOVWF  FF7
69A0:  CLRF   19
69A2:  BTFSC  FF2.7
69A4:  BSF    19.7
69A6:  BCF    FF2.7
69A8:  MOVLW  06
69AA:  MOVLB  8
69AC:  MOVWF  x0E
69AE:  MOVLB  0
69B0:  CALL   187C
69B4:  BTFSC  19.7
69B6:  BSF    FF2.7
69B8:  CLRF   19
69BA:  BTFSC  FF2.7
69BC:  BSF    19.7
69BE:  BCF    FF2.7
69C0:  MOVFF  7BA,7EF
69C4:  MOVLW  18
69C6:  MOVLB  7
69C8:  MOVWF  xF0
69CA:  MOVLB  0
69CC:  CALL   1990
69D0:  BTFSC  19.7
69D2:  BSF    FF2.7
69D4:  MOVLW  FE
69D6:  MOVWF  FF6
69D8:  MOVLW  21
69DA:  MOVWF  FF7
69DC:  CLRF   19
69DE:  BTFSC  FF2.7
69E0:  BSF    19.7
69E2:  BCF    FF2.7
69E4:  MOVLW  1D
69E6:  MOVLB  8
69E8:  MOVWF  x0E
69EA:  MOVLB  0
69EC:  CALL   187C
69F0:  BTFSC  19.7
69F2:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
69F4:  MOVLW  1C
69F6:  MOVWF  FF6
69F8:  MOVLW  22
69FA:  MOVWF  FF7
69FC:  CLRF   19
69FE:  BTFSC  FF2.7
6A00:  BSF    19.7
6A02:  BCF    FF2.7
6A04:  CALL   048C
6A08:  BTFSC  19.7
6A0A:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
6A0C:  CLRF   FEA
6A0E:  MOVLW  41
6A10:  MOVWF  FE9
6A12:  MOVLW  00
6A14:  CALL   024E
6A18:  TBLRD*-
6A1A:  TBLRD*+
6A1C:  MOVF   FF5,W
6A1E:  MOVWF  FEE
6A20:  IORLW  00
6A22:  BNZ   6A1A
....................       if(!stringcomp(buffer_uart,buffer2))  
6A24:  MOVLW  01
6A26:  MOVLB  7
6A28:  MOVWF  xBB
6A2A:  MOVLW  2C
6A2C:  MOVWF  xBA
6A2E:  CLRF   xBD
6A30:  MOVLW  41
6A32:  MOVWF  xBC
6A34:  MOVLB  0
6A36:  CALL   4F2C
6A3A:  MOVF   01,F
6A3C:  BTFSS  FD8.2
6A3E:  BRA    6B6E
....................       { 
....................          fprintf(COM2,"old password:"); 
6A40:  MOVLW  36
6A42:  MOVWF  FF6
6A44:  MOVLW  22
6A46:  MOVWF  FF7
6A48:  CLRF   19
6A4A:  BTFSC  FF2.7
6A4C:  BSF    19.7
6A4E:  BCF    FF2.7
6A50:  CALL   048C
6A54:  BTFSC  19.7
6A56:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
6A58:  MOVLB  7
6A5A:  CLRF   xBA
6A5C:  MOVLW  14
6A5E:  MOVWF  xBB
6A60:  CLRF   xBD
6A62:  MOVLW  55
6A64:  MOVWF  xBC
6A66:  MOVLB  0
6A68:  CALL   4A98
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
6A6C:  MOVLW  02
6A6E:  MOVLB  7
6A70:  MOVWF  xBA
6A72:  MOVLW  14
6A74:  MOVWF  xBB
6A76:  CLRF   xBD
6A78:  MOVLW  69
6A7A:  MOVWF  xBC
6A7C:  MOVLB  0
6A7E:  CALL   4DF4
....................          if(!stringcomp(entpassword,password)) 
6A82:  MOVLB  7
6A84:  CLRF   xBB
6A86:  MOVLW  69
6A88:  MOVWF  xBA
6A8A:  CLRF   xBD
6A8C:  MOVLW  55
6A8E:  MOVWF  xBC
6A90:  MOVLB  0
6A92:  CALL   4F2C
6A96:  MOVF   01,F
6A98:  BNZ   6B56
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
6A9A:  MOVLW  44
6A9C:  MOVWF  FF6
6A9E:  MOVLW  22
6AA0:  MOVWF  FF7
6AA2:  CLRF   19
6AA4:  BTFSC  FF2.7
6AA6:  BSF    19.7
6AA8:  BCF    FF2.7
6AAA:  CALL   048C
6AAE:  BTFSC  19.7
6AB0:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
6AB2:  MOVLW  02
6AB4:  MOVLB  7
6AB6:  MOVWF  xBA
6AB8:  MOVLW  14
6ABA:  MOVWF  xBB
6ABC:  CLRF   xBD
6ABE:  MOVLW  69
6AC0:  MOVWF  xBC
6AC2:  MOVLB  0
6AC4:  CALL   4DF4
....................             fprintf(COM2,"\n\ragain:"); 
6AC8:  MOVLW  4C
6ACA:  MOVWF  FF6
6ACC:  MOVLW  22
6ACE:  MOVWF  FF7
6AD0:  CLRF   19
6AD2:  BTFSC  FF2.7
6AD4:  BSF    19.7
6AD6:  BCF    FF2.7
6AD8:  CALL   048C
6ADC:  BTFSC  19.7
6ADE:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
6AE0:  MOVLW  02
6AE2:  MOVLB  7
6AE4:  MOVWF  xBA
6AE6:  MOVLW  14
6AE8:  MOVWF  xBB
6AEA:  CLRF   xBD
6AEC:  MOVLW  55
6AEE:  MOVWF  xBC
6AF0:  MOVLB  0
6AF2:  CALL   4DF4
....................             if(!stringcomp(entpassword,password)) 
6AF6:  MOVLB  7
6AF8:  CLRF   xBB
6AFA:  MOVLW  69
6AFC:  MOVWF  xBA
6AFE:  CLRF   xBD
6B00:  MOVLW  55
6B02:  MOVWF  xBC
6B04:  MOVLB  0
6B06:  CALL   4F2C
6B0A:  MOVF   01,F
6B0C:  BNZ   6B3C
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
6B0E:  MOVLB  7
6B10:  CLRF   xCF
6B12:  MOVLW  14
6B14:  MOVWF  xD0
6B16:  CLRF   xD2
6B18:  MOVLW  55
6B1A:  MOVWF  xD1
6B1C:  MOVLB  0
6B1E:  CALL   4AF8
....................                fprintf(COM2,"\n\rOK\n\r");    
6B22:  MOVLW  56
6B24:  MOVWF  FF6
6B26:  MOVLW  22
6B28:  MOVWF  FF7
6B2A:  CLRF   19
6B2C:  BTFSC  FF2.7
6B2E:  BSF    19.7
6B30:  BCF    FF2.7
6B32:  CALL   048C
6B36:  BTFSC  19.7
6B38:  BSF    FF2.7
....................             } 
....................                else 
6B3A:  BRA    6B54
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
6B3C:  MOVLW  5E
6B3E:  MOVWF  FF6
6B40:  MOVLW  22
6B42:  MOVWF  FF7
6B44:  CLRF   19
6B46:  BTFSC  FF2.7
6B48:  BSF    19.7
6B4A:  BCF    FF2.7
6B4C:  CALL   048C
6B50:  BTFSC  19.7
6B52:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
6B54:  BRA    6B6E
....................             { 
....................                fprintf(COM2," X\n\r"); 
6B56:  MOVLW  66
6B58:  MOVWF  FF6
6B5A:  MOVLW  22
6B5C:  MOVWF  FF7
6B5E:  CLRF   19
6B60:  BTFSC  FF2.7
6B62:  BSF    19.7
6B64:  BCF    FF2.7
6B66:  CALL   048C
6B6A:  BTFSC  19.7
6B6C:  BSF    FF2.7
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
6B6E:  CLRF   FEA
6B70:  MOVLW  41
6B72:  MOVWF  FE9
6B74:  MOVLW  00
6B76:  CALL   0268
6B7A:  TBLRD*-
6B7C:  TBLRD*+
6B7E:  MOVF   FF5,W
6B80:  MOVWF  FEE
6B82:  IORLW  00
6B84:  BNZ   6B7C
....................       if(!stringcomp(buffer_uart,buffer2)) 
6B86:  MOVLW  01
6B88:  MOVLB  7
6B8A:  MOVWF  xBB
6B8C:  MOVLW  2C
6B8E:  MOVWF  xBA
6B90:  CLRF   xBD
6B92:  MOVLW  41
6B94:  MOVWF  xBC
6B96:  MOVLB  0
6B98:  CALL   4F2C
6B9C:  MOVF   01,F
6B9E:  BTFSS  FD8.2
6BA0:  BRA    6CB0
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
6BA2:  MOVLW  6C
6BA4:  MOVWF  FF6
6BA6:  MOVLW  22
6BA8:  MOVWF  FF7
6BAA:  CLRF   19
6BAC:  BTFSC  FF2.7
6BAE:  BSF    19.7
6BB0:  BCF    FF2.7
6BB2:  CALL   048C
6BB6:  BTFSC  19.7
6BB8:  BSF    FF2.7
6BBA:  CLRF   19
6BBC:  BTFSC  FF2.7
6BBE:  BSF    19.7
6BC0:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6BC2:  MOVLW  0A
6BC4:  MOVLB  8
6BC6:  MOVWF  x1A
6BC8:  MOVLB  0
6BCA:  CALL   043A
6BCE:  BTFSC  19.7
6BD0:  BSF    FF2.7
6BD2:  CLRF   19
6BD4:  BTFSC  FF2.7
6BD6:  BSF    19.7
6BD8:  BCF    FF2.7
6BDA:  MOVLW  0D
6BDC:  MOVLB  8
6BDE:  MOVWF  x1A
6BE0:  MOVLB  0
6BE2:  CALL   043A
6BE6:  BTFSC  19.7
6BE8:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
6BEA:  MOVLW  8C
6BEC:  MOVWF  FF6
6BEE:  MOVLW  22
6BF0:  MOVWF  FF7
6BF2:  CLRF   19
6BF4:  BTFSC  FF2.7
6BF6:  BSF    19.7
6BF8:  BCF    FF2.7
6BFA:  CALL   048C
6BFE:  BTFSC  19.7
6C00:  BSF    FF2.7
6C02:  CLRF   19
6C04:  BTFSC  FF2.7
6C06:  BSF    19.7
6C08:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6C0A:  MOVLW  0A
6C0C:  MOVLB  8
6C0E:  MOVWF  x1A
6C10:  MOVLB  0
6C12:  CALL   043A
6C16:  BTFSC  19.7
6C18:  BSF    FF2.7
6C1A:  CLRF   19
6C1C:  BTFSC  FF2.7
6C1E:  BSF    19.7
6C20:  BCF    FF2.7
6C22:  MOVLW  0D
6C24:  MOVLB  8
6C26:  MOVWF  x1A
6C28:  MOVLB  0
6C2A:  CALL   043A
6C2E:  BTFSC  19.7
6C30:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6C32:  MOVLW  01
6C34:  MOVLB  7
6C36:  MOVWF  xBA
6C38:  MOVLW  03
6C3A:  MOVWF  xBB
6C3C:  MOVLW  07
6C3E:  MOVWF  xBD
6C40:  MOVLW  86
6C42:  MOVWF  xBC
6C44:  MOVLB  0
6C46:  CALL   4DF4
....................           debugmode = (unsigned int8)strtoi(temp); 
6C4A:  MOVLW  07
6C4C:  MOVLB  7
6C4E:  MOVWF  xBB
6C50:  MOVLW  86
6C52:  MOVWF  xBA
6C54:  MOVLB  0
6C56:  CALL   5508
6C5A:  MOVFF  01,69D
6C5E:  CLRF   19
6C60:  BTFSC  FF2.7
6C62:  BSF    19.7
6C64:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
6C66:  MOVLB  8
6C68:  CLRF   x05
6C6A:  CLRF   x04
6C6C:  CLRF   x03
6C6E:  MOVLW  92
6C70:  MOVWF  x02
6C72:  MOVFF  69D,806
6C76:  MOVLB  0
6C78:  CALL   3D9A
6C7C:  BTFSC  19.7
6C7E:  BSF    FF2.7
6C80:  CLRF   19
6C82:  BTFSC  FF2.7
6C84:  BSF    19.7
6C86:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6C88:  MOVLW  0A
6C8A:  MOVLB  8
6C8C:  MOVWF  x1A
6C8E:  MOVLB  0
6C90:  CALL   043A
6C94:  BTFSC  19.7
6C96:  BSF    FF2.7
6C98:  CLRF   19
6C9A:  BTFSC  FF2.7
6C9C:  BSF    19.7
6C9E:  BCF    FF2.7
6CA0:  MOVLW  0D
6CA2:  MOVLB  8
6CA4:  MOVWF  x1A
6CA6:  MOVLB  0
6CA8:  CALL   043A
6CAC:  BTFSC  19.7
6CAE:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
6CB0:  GOTO   71A8 (RETURN)
.................... //=============================================== 
....................  
....................  
.................... //========================= 
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
47B4:  MOVLB  1
47B6:  MOVF   x0F,F
47B8:  BZ    47F4
....................    { 
....................       if(count_kp<500)count_kp++; 
47BA:  MOVF   x12,W
47BC:  SUBLW  01
47BE:  BNC   47CE
47C0:  BNZ   47C8
47C2:  MOVF   x11,W
47C4:  SUBLW  F3
47C6:  BNC   47CE
47C8:  INCF   x11,F
47CA:  BTFSC  FD8.2
47CC:  INCF   x12,F
....................       if(count_kp==500) 
47CE:  MOVF   x11,W
47D0:  SUBLW  F4
47D2:  BNZ   47F4
47D4:  DECFSZ x12,W
47D6:  BRA    47F4
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
47D8:  MOVLW  BE
47DA:  MOVWF  FF6
47DC:  MOVLW  49
47DE:  MOVWF  FF7
47E0:  MOVLB  0
47E2:  CALL   048C
....................             keyprss_off; 
47E6:  BCF    F92.7
47E8:  BCF    F89.7
....................             kp_st=0;     
47EA:  MOVLB  1
47EC:  CLRF   x10
....................             count_kp++; 
47EE:  INCF   x11,F
47F0:  BTFSC  FD8.2
47F2:  INCF   x12,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
47F4:  DECFSZ x0B,W
47F6:  BRA    4812
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
47F8:  MOVLB  6
47FA:  MOVF   xA9,F
47FC:  BNZ   4806
47FE:  MOVLB  0
4800:  CALL   22AC
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
4804:  BRA    4810
4806:  MOVLB  0
4808:  CALL   357A
480C:  MOVFF  01,7E5
4810:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
4812:  DECFSZ x0C,W
4814:  BRA    482E
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
4816:  MOVLB  6
4818:  MOVF   xA9,F
481A:  BNZ   4824
481C:  MOVLB  0
481E:  CALL   22AC
....................          else temp=kbd_getc_slv(); 
4822:  BRA    482E
4824:  MOVLB  0
4826:  CALL   357A
482A:  MOVFF  01,7E5
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
482E:  MOVLB  6
4830:  MOVF   x8E,F
4832:  BNZ   4852
4834:  MOVF   x8D,F
4836:  BNZ   4852
4838:  MOVF   x8C,F
483A:  BNZ   4852
483C:  MOVF   x8B,W
483E:  SUBLW  04
4840:  BNC   4852
4842:  MOVLW  01
4844:  ADDWF  x8B,F
4846:  BTFSC  FD8.0
4848:  INCF   x8C,F
484A:  BTFSC  FD8.2
484C:  INCF   x8D,F
484E:  BTFSC  FD8.2
4850:  INCF   x8E,F
....................   if(mcr_timeout==5) 
4852:  MOVF   x8B,W
4854:  SUBLW  05
4856:  BNZ   48AE
4858:  MOVF   x8C,F
485A:  BNZ   48AE
485C:  MOVF   x8D,F
485E:  BNZ   48AE
4860:  MOVF   x8E,F
4862:  BNZ   48AE
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
4864:  DECFSZ xA1,W
4866:  BRA    4870
4868:  MOVLB  0
486A:  GOTO   3F2E
486E:  MOVLB  6
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
4870:  MOVLW  02
4872:  MOVWF  FEA
4874:  MOVLW  0D
4876:  MOVWF  FE9
4878:  CLRF   00
487A:  MOVLW  03
487C:  MOVWF  02
487E:  MOVLW  52
4880:  MOVWF  01
4882:  MOVLB  0
4884:  RCALL  433C
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
4886:  MOVLW  05
4888:  MOVWF  FEA
488A:  MOVLW  5F
488C:  MOVWF  FE9
488E:  CLRF   00
4890:  MOVLW  01
4892:  MOVWF  02
4894:  MOVLW  2C
4896:  MOVWF  01
4898:  RCALL  433C
....................       //debug_card(); 
....................       count_reading_error=0; 
489A:  MOVLB  6
489C:  CLRF   xA2
....................       mcr_timeout++;   
489E:  MOVLW  01
48A0:  ADDWF  x8B,F
48A2:  BTFSC  FD8.0
48A4:  INCF   x8C,F
48A6:  BTFSC  FD8.2
48A8:  INCF   x8D,F
48AA:  BTFSC  FD8.2
48AC:  INCF   x8E,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
48AE:  MOVLB  8
48B0:  CLRF   x0D
48B2:  CLRF   x0C
48B4:  CLRF   x0B
48B6:  MOVLW  94
48B8:  MOVWF  x0A
48BA:  MOVLB  0
48BC:  CALL   37FA
48C0:  MOVFF  01,124
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
48C4:  MOVLW  02
48C6:  MOVLB  7
48C8:  MOVWF  xEC
48CA:  MOVLW  BC
48CC:  MOVWF  xEB
48CE:  CLRF   xEE
48D0:  MOVFF  124,7ED
48D4:  MOVLB  0
48D6:  CALL   3922
48DA:  MOVFF  02,03
48DE:  MOVF   xFC,W
48E0:  SUBWF  02,W
48E2:  BNC   48F2
48E4:  BNZ   48EC
48E6:  MOVF   01,W
48E8:  SUBWF  xFB,W
48EA:  BC    48F2
48EC:  INCF   xFB,F
48EE:  BTFSC  FD8.2
48F0:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
48F2:  MOVLW  02
48F4:  MOVLB  7
48F6:  MOVWF  xEC
48F8:  MOVLW  BC
48FA:  MOVWF  xEB
48FC:  CLRF   xEE
48FE:  MOVFF  124,7ED
4902:  MOVLB  0
4904:  CALL   3922
4908:  MOVFF  02,03
490C:  MOVF   01,W
490E:  SUBWF  xFB,W
4910:  BNZ   49B8
4912:  MOVF   03,W
4914:  SUBWF  xFC,W
4916:  BNZ   49B8
....................   { 
....................       charac_timeout++; 
4918:  INCF   xFB,F
491A:  BTFSC  FD8.2
491C:  INCF   xFC,F
....................       buf=get_countcard(); 
491E:  CALL   38C6
4922:  MOVFF  02,7E4
4926:  MOVFF  01,7E3
....................       if(buf<countcards) 
492A:  MOVLB  7
492C:  MOVF   xE4,W
492E:  SUBLW  03
4930:  BNC   4958
4932:  BNZ   493A
4934:  MOVF   xE3,W
4936:  SUBLW  A1
4938:  BNC   4958
....................       { 
....................          save_key_new(); 
493A:  MOVLB  0
493C:  BRA    4494
....................          buf=buf+1; 
493E:  MOVLW  01
4940:  MOVLB  7
4942:  ADDWF  xE3,F
4944:  MOVLW  00
4946:  ADDWFC xE4,F
....................          save_coutcard(buf); 
4948:  MOVFF  7E4,7E7
494C:  MOVFF  7E3,7E6
4950:  MOVLB  0
4952:  RCALL  4676
....................       } 
....................          else 
4954:  BRA    4968
4956:  MOVLB  7
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
4958:  MOVLW  CE
495A:  MOVWF  FF6
495C:  MOVLW  49
495E:  MOVWF  FF7
4960:  MOVLB  0
4962:  CALL   048C
....................             return; 
4966:  BRA    49B8
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
4968:  MOVLW  DE
496A:  MOVWF  FF6
496C:  MOVLW  49
496E:  MOVWF  FF7
4970:  CALL   048C
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
4974:  MOVLW  EE
4976:  MOVWF  FF6
4978:  MOVLW  49
497A:  MOVWF  FF7
497C:  MOVLW  14
497E:  MOVLB  8
4980:  MOVWF  x0E
4982:  MOVLB  0
4984:  CALL   187C
4988:  MOVLW  10
498A:  MOVWF  FE9
498C:  MOVFF  7E4,7E7
4990:  MOVFF  7E3,7E6
4994:  RCALL  46BE
4996:  MOVLW  05
4998:  MOVWF  FF6
499A:  MOVLW  4A
499C:  MOVWF  FF7
499E:  MOVLW  03
49A0:  MOVLB  8
49A2:  MOVWF  x0E
49A4:  MOVLB  0
49A6:  CALL   187C
....................       data_avai=0; 
49AA:  MOVLB  6
49AC:  CLRF   xA0
....................       enable_getpin=0; 
49AE:  MOVLB  1
49B0:  CLRF   x0C
....................       //dis_getpin; 
....................       output_low(LED); 
49B2:  BCF    F92.6
49B4:  BCF    F89.6
49B6:  MOVLB  0
....................   } 
....................   //================================= 
....................   //================================= 
.................... } 
.................... //========================= 
49B8:  BCF    FF2.2
49BA:  GOTO   006C
.................... void main() 
.................... {  
*
6CB4:  CLRF   FF8
6CB6:  BCF    FD0.7
6CB8:  BSF    07.7
6CBA:  CLRF   FEA
6CBC:  CLRF   FE9
6CBE:  BCF    F94.0
6CC0:  BSF    F8B.0
6CC2:  CLRF   23
6CC4:  CLRF   22
6CC6:  CLRF   21
6CC8:  MOVLW  96
6CCA:  MOVWF  20
6CCC:  CLRF   27
6CCE:  MOVLW  01
6CD0:  MOVWF  26
6CD2:  MOVLW  C3
6CD4:  MOVWF  25
6CD6:  MOVLW  0F
6CD8:  MOVWF  24
6CDA:  CLRF   xFA
6CDC:  CLRF   xF9
6CDE:  SETF   xFC
6CE0:  SETF   xFB
6CE2:  MOVLW  0E
6CE4:  MOVWF  xFE
6CE6:  MOVLW  01
6CE8:  MOVWF  xFF
6CEA:  MOVLB  1
6CEC:  MOVWF  x00
6CEE:  CLRF   x01
6CF0:  CLRF   x02
6CF2:  CLRF   x03
6CF4:  CLRF   x04
6CF6:  CLRF   x05
6CF8:  CLRF   x07
6CFA:  MOVLW  0A
6CFC:  MOVWF  x06
6CFE:  MOVLW  03
6D00:  MOVWF  x09
6D02:  MOVLW  E8
6D04:  MOVWF  x08
6D06:  CLRF   x0A
6D08:  CLRF   x0B
6D0A:  CLRF   x0C
6D0C:  MOVLW  64
6D0E:  MOVWF  x0D
6D10:  CLRF   x0E
6D12:  CLRF   x0F
6D14:  CLRF   x10
6D16:  CLRF   x12
6D18:  CLRF   x11
6D1A:  CLRF   x13
6D1C:  CLRF   x24
6D1E:  CLRF   x29
6D20:  CLRF   x90
6D22:  CLRF   x91
6D24:  CLRF   x92
6D26:  CLRF   x93
6D28:  CLRF   x95
6D2A:  CLRF   x94
6D2C:  MOVLB  6
6D2E:  CLRF   x8E
6D30:  CLRF   x8D
6D32:  CLRF   x8C
6D34:  CLRF   x8B
6D36:  CLRF   x8F
6D38:  CLRF   x91
6D3A:  CLRF   x90
6D3C:  CLRF   x93
6D3E:  CLRF   x92
6D40:  CLRF   x95
6D42:  CLRF   x94
6D44:  CLRF   x97
6D46:  CLRF   x96
6D48:  MOVLW  FD
6D4A:  MOVWF  x99
6D4C:  MOVLW  E8
6D4E:  MOVWF  x98
6D50:  CLRF   x9B
6D52:  CLRF   x9A
6D54:  CLRF   x9C
6D56:  CLRF   x9D
6D58:  CLRF   x9E
6D5A:  CLRF   x9F
6D5C:  CLRF   xA0
6D5E:  CLRF   xA1
6D60:  CLRF   xA2
6D62:  CLRF   xA3
6D64:  CLRF   xA4
6D66:  CLRF   xA6
6D68:  MOVLW  01
6D6A:  MOVWF  xA5
6D6C:  CLRF   xA8
6D6E:  CLRF   xA7
6D70:  CLRF   xA9
6D72:  CLRF   xAD
6D74:  CLRF   xAC
6D76:  CLRF   xAB
6D78:  CLRF   xAA
6D7A:  MOVLW  FF
6D7C:  MOVLB  F
6D7E:  MOVWF  x48
6D80:  BCF    FC2.6
6D82:  BCF    FC2.7
6D84:  MOVF   x49,W
6D86:  ANDLW  E0
6D88:  IORLW  1F
6D8A:  MOVWF  x49
6D8C:  CLRF   FD2
6D8E:  CLRF   FD1
6D90:  CLRF   1A
6D92:  CLRF   1B
6D94:  MOVLB  1
6D96:  CLRF   x25
6D98:  BCF    x26.0
6D9A:  CLRF   x27
6D9C:  CLRF   x28
6D9E:  CLRF   x2A
6DA0:  BCF    x26.1
6DA2:  CLRF   x2B
6DA4:  MOVLB  6
6DA6:  CLRF   xBE
6DA8:  CLRF   xBF
6DAA:  CLRF   xC0
6DAC:  CLRF   xC1
6DAE:  CLRF   xC2
6DB0:  CLRF   xC3
6DB2:  CLRF   xC4
6DB4:  CLRF   xC5
6DB6:  CLRF   xC6
6DB8:  CLRF   xC7
6DBA:  CLRF   xCA
6DBC:  CLRF   xCC
6DBE:  CLRF   xCB
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................     RPINR1=5; 
6DC0:  MOVLW  05
6DC2:  MOVLB  E
6DC4:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
6DC6:  MOVLB  0
6DC8:  SETF   xFC
6DCA:  SETF   xFB
....................    key_timeout=0xffff; 
6DCC:  MOVLB  1
6DCE:  SETF   x09
6DD0:  SETF   x08
....................    setup_oscillator(OSC_32MHZ); 
6DD2:  MOVLW  70
6DD4:  MOVWF  FD3
6DD6:  MOVLW  40
6DD8:  MOVWF  F9B
6DDA:  MOVF   FD3,W
....................    keyprss_off; 
6DDC:  BCF    F92.7
6DDE:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
6DE0:  BCF    FF2.6
6DE2:  BCF    FF2.7
6DE4:  BTFSC  FF2.7
6DE6:  BRA    6DE2
....................    init_ext_eeprom(); 
6DE8:  MOVLB  0
6DEA:  GOTO   4A8E
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
6DEE:  MOVLW  04
6DF0:  MOVLB  7
6DF2:  MOVWF  x84
6DF4:  CLRF   19
6DF6:  BTFSC  FF2.7
6DF8:  BSF    19.7
6DFA:  BCF    FF2.7
6DFC:  MOVLW  FA
6DFE:  MOVWF  xEC
6E00:  MOVLB  0
6E02:  CALL   1AEC
6E06:  BTFSC  19.7
6E08:  BSF    FF2.7
6E0A:  MOVLB  7
6E0C:  DECFSZ x84,F
6E0E:  BRA    6DF4
....................    init_password(); 
6E10:  MOVLB  0
6E12:  CALL   4B50
....................    EEPROM_read(strobe_pass_addr,20,password); 
6E16:  MOVLB  7
6E18:  CLRF   xBA
6E1A:  MOVLW  14
6E1C:  MOVWF  xBB
6E1E:  CLRF   xBD
6E20:  MOVLW  55
6E22:  MOVWF  xBC
6E24:  MOVLB  0
6E26:  CALL   4A98
6E2A:  CLRF   19
6E2C:  BTFSC  FF2.7
6E2E:  BSF    19.7
6E30:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
6E32:  MOVLB  8
6E34:  CLRF   x0D
6E36:  CLRF   x0C
6E38:  CLRF   x0B
6E3A:  MOVLW  7F
6E3C:  MOVWF  x0A
6E3E:  MOVLB  0
6E40:  CALL   37FA
6E44:  BTFSC  19.7
6E46:  BSF    FF2.7
6E48:  MOVFF  01,10F
....................    //===================================== 
....................    rtc_init(); 
6E4C:  GOTO   4C8E
6E50:  CLRF   19
6E52:  BTFSC  FF2.7
6E54:  BSF    19.7
6E56:  BCF    FF2.7
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
6E58:  MOVLW  19
6E5A:  MOVLB  7
6E5C:  MOVWF  xE9
6E5E:  MOVLB  0
6E60:  CALL   4356
6E64:  BTFSC  19.7
6E66:  BSF    FF2.7
6E68:  MOVFF  03,23
6E6C:  MOVFF  02,22
6E70:  MOVFF  01,21
6E74:  MOVFF  00,20
6E78:  CLRF   19
6E7A:  BTFSC  FF2.7
6E7C:  BSF    19.7
6E7E:  BCF    FF2.7
....................     
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
6E80:  MOVLW  1E
6E82:  MOVLB  7
6E84:  MOVWF  xE9
6E86:  MOVLB  0
6E88:  CALL   4356
6E8C:  BTFSC  19.7
6E8E:  BSF    FF2.7
6E90:  MOVFF  03,27
6E94:  MOVFF  02,26
6E98:  MOVFF  01,25
6E9C:  MOVFF  00,24
....................    fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card_key); 
6EA0:  MOVLW  0A
6EA2:  MOVWF  FF6
6EA4:  MOVLW  4A
6EA6:  MOVWF  FF7
6EA8:  CLRF   19
6EAA:  BTFSC  FF2.7
6EAC:  BSF    19.7
6EAE:  BCF    FF2.7
6EB0:  MOVLW  0E
6EB2:  MOVLB  8
6EB4:  MOVWF  x0E
6EB6:  MOVLB  0
6EB8:  CALL   187C
6EBC:  BTFSC  19.7
6EBE:  BSF    FF2.7
6EC0:  MOVLW  41
6EC2:  MOVWF  FE9
6EC4:  CLRF   19
6EC6:  BTFSC  FF2.7
6EC8:  BSF    19.7
6ECA:  BCF    FF2.7
6ECC:  MOVFF  27,811
6ED0:  MOVFF  26,810
6ED4:  MOVFF  25,80F
6ED8:  MOVFF  24,80E
6EDC:  CALL   262C
6EE0:  BTFSC  19.7
6EE2:  BSF    FF2.7
6EE4:  CLRF   19
6EE6:  BTFSC  FF2.7
6EE8:  BSF    19.7
6EEA:  BCF    FF2.7
6EEC:  MOVLW  0A
6EEE:  MOVLB  8
6EF0:  MOVWF  x1A
6EF2:  MOVLB  0
6EF4:  CALL   043A
6EF8:  BTFSC  19.7
6EFA:  BSF    FF2.7
6EFC:  CLRF   19
6EFE:  BTFSC  FF2.7
6F00:  BSF    19.7
6F02:  BCF    FF2.7
6F04:  MOVLW  0D
6F06:  MOVLB  8
6F08:  MOVWF  x1A
6F0A:  MOVLB  0
6F0C:  CALL   043A
6F10:  BTFSC  19.7
6F12:  BSF    FF2.7
6F14:  CLRF   19
6F16:  BTFSC  FF2.7
6F18:  BSF    19.7
6F1A:  BCF    FF2.7
....................    countcard=get_countcard(); 
6F1C:  CALL   38C6
6F20:  BTFSC  19.7
6F22:  BSF    FF2.7
6F24:  MOVFF  02,FA
6F28:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
6F2C:  SETF   xFC
6F2E:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
6F30:  MOVLW  C7
6F32:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
6F34:  MOVLW  37
6F36:  MOVWF  FCD
6F38:  CLRF   F9A
6F3A:  CLRF   19
6F3C:  BTFSC  FF2.7
6F3E:  BSF    19.7
6F40:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
6F42:  MOVLB  8
6F44:  CLRF   x0D
6F46:  CLRF   x0C
6F48:  CLRF   x0B
6F4A:  MOVLW  94
6F4C:  MOVWF  x0A
6F4E:  MOVLB  0
6F50:  CALL   37FA
6F54:  BTFSC  19.7
6F56:  BSF    FF2.7
6F58:  MOVFF  01,124
....................    if(delaycharaction==0)delaycharaction=1; 
6F5C:  MOVLB  1
6F5E:  MOVF   x24,F
6F60:  BNZ   6F66
6F62:  MOVLW  01
6F64:  MOVWF  x24
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
6F66:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
6F68:  BSF    FF0.3
6F6A:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
6F6C:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
6F6E:  MOVLW  C0
6F70:  IORWF  FF2,F
....................   
....................    mcr_timeout=10000; 
6F72:  MOVLB  6
6F74:  CLRF   x8E
6F76:  CLRF   x8D
6F78:  MOVLW  27
6F7A:  MOVWF  x8C
6F7C:  MOVLW  10
6F7E:  MOVWF  x8B
6F80:  CLRF   19
6F82:  BTFSC  FF2.7
6F84:  BSF    19.7
6F86:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6F88:  MOVLB  8
6F8A:  CLRF   x0D
6F8C:  CLRF   x0C
6F8E:  CLRF   x0B
6F90:  MOVLW  91
6F92:  MOVWF  x0A
6F94:  MOVLB  0
6F96:  CALL   37FA
6F9A:  BTFSC  19.7
6F9C:  BSF    FF2.7
6F9E:  MOVFF  01,6A9
6FA2:  CLRF   19
6FA4:  BTFSC  FF2.7
6FA6:  BSF    19.7
6FA8:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
6FAA:  MOVLB  8
6FAC:  CLRF   x0D
6FAE:  CLRF   x0C
6FB0:  CLRF   x0B
6FB2:  MOVLW  92
6FB4:  MOVWF  x0A
6FB6:  MOVLB  0
6FB8:  CALL   37FA
6FBC:  BTFSC  19.7
6FBE:  BSF    FF2.7
6FC0:  MOVFF  01,69D
....................     key_timeout=1000; 
6FC4:  MOVLW  03
6FC6:  MOVLB  1
6FC8:  MOVWF  x09
6FCA:  MOVLW  E8
6FCC:  MOVWF  x08
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
6FCE:  MOVLB  0
6FD0:  SETF   xFC
6FD2:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    booting_done=1; 
6FD4:  MOVLW  01
6FD6:  MOVLB  1
6FD8:  MOVWF  x93
....................    booting=1; 
6FDA:  MOVWF  x05
....................    charac_timeout=0xffffffff; 
6FDC:  MOVLB  0
6FDE:  SETF   xFC
6FE0:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
6FE2:  MOVLW  66
6FE4:  MOVLB  7
6FE6:  MOVWF  xBA
6FE8:  MOVLW  10
6FEA:  MOVWF  xBB
6FEC:  MOVLW  06
6FEE:  MOVWF  xBD
6FF0:  MOVLW  AE
6FF2:  MOVWF  xBC
6FF4:  MOVLB  0
6FF6:  CALL   4A98
....................    EEPROM_read(strobe_pass_addr,20,password); 
6FFA:  MOVLB  7
6FFC:  CLRF   xBA
6FFE:  MOVLW  14
7000:  MOVWF  xBB
7002:  CLRF   xBD
7004:  MOVLW  55
7006:  MOVWF  xBC
7008:  MOVLB  0
700A:  CALL   4A98
....................    set_tris_a(0xff);  
700E:  MOVLW  FF
7010:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
7012:  MOVLW  E0
7014:  MOVLB  F
7016:  MOVWF  x48
7018:  BCF    FC2.6
701A:  BCF    FC2.7
701C:  MOVF   x49,W
701E:  ANDLW  E0
7020:  IORLW  1F
7022:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
7024:  MOVF   FC1,W
7026:  ANDLW  C0
7028:  IORLW  03
702A:  MOVWF  FC1
702C:  BCF    FC1.7
702E:  BSF    FC2.0
7030:  BSF    FC1.6
7032:  BSF    FC2.1
7034:  BTFSC  FC2.1
7036:  BRA    7034
7038:  BCF    FC1.6
703A:  CLRF   19
703C:  BTFSC  FF2.7
703E:  BSF    19.7
7040:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
7042:  MOVLB  8
7044:  CLRF   x0D
7046:  CLRF   x0C
7048:  CLRF   x0B
704A:  MOVLW  7F
704C:  MOVWF  x0A
704E:  MOVLB  0
7050:  CALL   37FA
7054:  BTFSC  19.7
7056:  BSF    FF2.7
7058:  MOVFF  01,10F
705C:  CLRF   19
705E:  BTFSC  FF2.7
7060:  BSF    19.7
7062:  BCF    FF2.7
....................    type_KB=read_ext_eeprom(kindofKB); 
7064:  MOVLB  8
7066:  CLRF   x0D
7068:  CLRF   x0C
706A:  CLRF   x0B
706C:  MOVLW  7E
706E:  MOVWF  x0A
7070:  MOVLB  0
7072:  CALL   37FA
7076:  BTFSC  19.7
7078:  BSF    FF2.7
707A:  MOVFF  01,113
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
707E:  MOVLB  1
7080:  MOVF   x13,F
7082:  BZ    70A2
7084:  MOVLW  1E
7086:  MOVWF  FF6
7088:  MOVLW  4A
708A:  MOVWF  FF7
708C:  CLRF   19
708E:  BTFSC  FF2.7
7090:  BSF    19.7
7092:  BCF    FF2.7
7094:  MOVLB  0
7096:  CALL   048C
709A:  BTFSC  19.7
709C:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
709E:  BRA    70BC
70A0:  MOVLB  1
70A2:  MOVLW  32
70A4:  MOVWF  FF6
70A6:  MOVLW  4A
70A8:  MOVWF  FF7
70AA:  CLRF   19
70AC:  BTFSC  FF2.7
70AE:  BSF    19.7
70B0:  BCF    FF2.7
70B2:  MOVLB  0
70B4:  CALL   048C
70B8:  BTFSC  19.7
70BA:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
70BC:  MOVLB  6
70BE:  MOVF   xA9,F
70C0:  BNZ   70E0
70C2:  MOVLW  46
70C4:  MOVWF  FF6
70C6:  MOVLW  4A
70C8:  MOVWF  FF7
70CA:  CLRF   19
70CC:  BTFSC  FF2.7
70CE:  BSF    19.7
70D0:  BCF    FF2.7
70D2:  MOVLB  0
70D4:  CALL   048C
70D8:  BTFSC  19.7
70DA:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
70DC:  BRA    70FA
70DE:  MOVLB  6
70E0:  MOVLW  60
70E2:  MOVWF  FF6
70E4:  MOVLW  4A
70E6:  MOVWF  FF7
70E8:  CLRF   19
70EA:  BTFSC  FF2.7
70EC:  BSF    19.7
70EE:  BCF    FF2.7
70F0:  MOVLB  0
70F2:  CALL   048C
70F6:  BTFSC  19.7
70F8:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
70FA:  MOVLW  01
70FC:  MOVWF  FEA
70FE:  MOVLW  14
7100:  MOVWF  FE9
7102:  CLRF   00
7104:  CLRF   02
7106:  MOVLW  10
7108:  MOVWF  01
710A:  CALL   433C
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
710E:  MOVLB  6
7110:  MOVF   xA3,F
7112:  BNZ   719E
....................       { 
....................          fprintf(COM2,"password:"); 
7114:  MOVLW  78
7116:  MOVWF  FF6
7118:  MOVLW  4A
711A:  MOVWF  FF7
711C:  CLRF   19
711E:  BTFSC  FF2.7
7120:  BSF    19.7
7122:  BCF    FF2.7
7124:  MOVLB  0
7126:  CALL   048C
712A:  BTFSC  19.7
712C:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
712E:  MOVLW  02
7130:  MOVLB  7
7132:  MOVWF  xBA
7134:  MOVLW  14
7136:  MOVWF  xBB
7138:  MOVLW  01
713A:  MOVWF  xBD
713C:  MOVLW  2C
713E:  MOVWF  xBC
7140:  MOVLB  0
7142:  CALL   4DF4
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          if(!stringcomp(buffer_uart,password)) 
7146:  MOVLW  01
7148:  MOVLB  7
714A:  MOVWF  xBB
714C:  MOVLW  2C
714E:  MOVWF  xBA
7150:  CLRF   xBD
7152:  MOVLW  55
7154:  MOVWF  xBC
7156:  MOVLB  0
7158:  CALL   4F2C
715C:  MOVF   01,F
715E:  BNZ   7182
....................          { 
....................             mode=LOGON; 
7160:  MOVLW  01
7162:  MOVLB  6
7164:  MOVWF  xA3
....................             fprintf(COM2," OK\n\r"); 
7166:  MOVLW  82
7168:  MOVWF  FF6
716A:  MOVLW  4A
716C:  MOVWF  FF7
716E:  CLRF   19
7170:  BTFSC  FF2.7
7172:  BSF    19.7
7174:  BCF    FF2.7
7176:  MOVLB  0
7178:  CALL   048C
717C:  BTFSC  19.7
717E:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
7180:  BRA    719A
7182:  MOVLW  88
7184:  MOVWF  FF6
7186:  MOVLW  4A
7188:  MOVWF  FF7
718A:  CLRF   19
718C:  BTFSC  FF2.7
718E:  BSF    19.7
7190:  BCF    FF2.7
7192:  CALL   048C
7196:  BTFSC  19.7
7198:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
719A:  BRA    71A8
719C:  MOVLB  6
719E:  DECFSZ xA3,W
71A0:  BRA    71AA
71A2:  MOVLB  0
71A4:  GOTO   56EC
71A8:  MOVLB  6
....................    } 
71AA:  BRA    7110
.................... } 
71AC:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

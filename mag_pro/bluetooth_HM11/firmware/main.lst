CCS PCH C Compiler, Version 4.140, 33034               30-Jun-17 18:03

               Filename:   D:\magnertic_card_prj\for michael perez\bluetooth_HM11\firmware\main.lst

               ROM used:   28982 bytes (44%)
                           Largest free fragment is 36542
               RAM used:   1926 (51%) at main() level
                           2103 (56%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   6C3C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   45F8
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   1E06
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define 24AA1025 
.................... #define nocheckpass 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
03FC:  MOVLW  02
03FE:  MOVLB  7
0400:  SUBWF  xE4,F
0402:  BNC   041C
0404:  MOVLW  07
0406:  MOVWF  FEA
0408:  MOVLW  E4
040A:  MOVWF  FE9
040C:  MOVF   FEF,W
040E:  BZ    041C
0410:  BRA    0418
0412:  BRA    0414
0414:  BRA    0416
0416:  NOP   
0418:  DECFSZ FEF,F
041A:  BRA    0412
041C:  MOVLB  0
041E:  GOTO   1E16 (RETURN)
*
1AD4:  MOVLW  07
1AD6:  MOVWF  FEA
1AD8:  MOVLW  EC
1ADA:  MOVWF  FE9
1ADC:  MOVF   FEF,W
1ADE:  BZ    1AFA
1AE0:  MOVLW  0A
1AE2:  MOVWF  01
1AE4:  CLRF   00
1AE6:  DECFSZ 00,F
1AE8:  BRA    1AE6
1AEA:  DECFSZ 01,F
1AEC:  BRA    1AE4
1AEE:  MOVLW  5F
1AF0:  MOVWF  00
1AF2:  DECFSZ 00,F
1AF4:  BRA    1AF2
1AF6:  DECFSZ FEF,F
1AF8:  BRA    1AE0
1AFA:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
0422:  BCF    F94.0
0424:  BCF    F8B.0
0426:  MOVLW  08
0428:  MOVWF  01
042A:  BRA    042C
042C:  NOP   
042E:  BSF    01.7
0430:  BRA    0452
0432:  BCF    01.7
0434:  MOVLB  8
0436:  RRCF   x1A,F
0438:  MOVLB  0
043A:  BTFSC  FD8.0
043C:  BSF    F8B.0
043E:  BTFSS  FD8.0
0440:  BCF    F8B.0
0442:  BSF    01.6
0444:  BRA    0452
0446:  BCF    01.6
0448:  DECFSZ 01,F
044A:  BRA    0434
044C:  BRA    044E
044E:  NOP   
0450:  BSF    F8B.0
0452:  MOVLW  01
0454:  MOVWF  00
0456:  CLRF   FE9
0458:  DECFSZ FE9,F
045A:  BRA    0458
045C:  DECFSZ 00,F
045E:  BRA    0456
0460:  MOVLW  0E
0462:  MOVWF  FE9
0464:  DECFSZ FE9,F
0466:  BRA    0464
0468:  NOP   
046A:  BTFSC  01.7
046C:  BRA    0432
046E:  BTFSC  01.6
0470:  BRA    0446
0472:  RETURN 0
*
4D24:  BSF    F94.1
4D26:  BTFSC  F82.1
4D28:  BRA    4D26
4D2A:  MOVLW  08
4D2C:  MOVWF  00
4D2E:  MOVLB  7
4D30:  CLRF   xC3
4D32:  BSF    00.7
4D34:  BRA    4D52
4D36:  BCF    00.7
4D38:  BRA    4D52
4D3A:  BCF    FD8.0
4D3C:  BTFSC  F82.1
4D3E:  BSF    FD8.0
4D40:  RRCF   xC3,F
4D42:  BSF    00.6
4D44:  BRA    4D52
4D46:  BCF    00.6
4D48:  DECFSZ 00,F
4D4A:  BRA    4D3A
4D4C:  MOVFF  7C3,01
4D50:  BRA    4D7C
4D52:  MOVLW  01
4D54:  MOVWF  FE9
4D56:  MOVLW  00
4D58:  BTFSC  00.7
4D5A:  MOVLW  55
4D5C:  MOVWF  01
4D5E:  DECFSZ 01,F
4D60:  BRA    4D5E
4D62:  DECFSZ FE9,F
4D64:  BRA    4D56
4D66:  MOVLW  0D
4D68:  BTFSC  00.7
4D6A:  MOVLW  03
4D6C:  MOVWF  01
4D6E:  DECFSZ 01,F
4D70:  BRA    4D6E
4D72:  BTFSC  00.7
4D74:  BRA    4D36
4D76:  BTFSC  00.6
4D78:  BRA    4D46
4D7A:  BRA    4D3A
4D7C:  MOVLB  0
4D7E:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
3702:  MOVLW  08
3704:  MOVWF  01
3706:  MOVLW  0A
3708:  MOVWF  00
370A:  DECFSZ 00,F
370C:  BRA    370A
370E:  BCF    F8B.3
3710:  BCF    F94.3
3712:  MOVLW  0B
3714:  MOVWF  00
3716:  DECFSZ 00,F
3718:  BRA    3716
371A:  MOVLB  8
371C:  RLCF   x0E,F
371E:  BCF    F8B.4
3720:  BTFSC  FD8.0
3722:  BSF    F94.4
3724:  BTFSS  FD8.0
3726:  BCF    F94.4
3728:  BSF    F94.3
372A:  BTFSS  F82.3
372C:  BRA    372A
372E:  DECFSZ 01,F
3730:  BRA    3734
3732:  BRA    3738
3734:  MOVLB  0
3736:  BRA    3706
3738:  MOVLW  0A
373A:  MOVWF  00
373C:  DECFSZ 00,F
373E:  BRA    373C
3740:  BCF    F8B.3
3742:  BCF    F94.3
3744:  NOP   
3746:  BSF    F94.4
3748:  MOVLW  0B
374A:  MOVWF  00
374C:  DECFSZ 00,F
374E:  BRA    374C
3750:  MOVLW  0B
3752:  MOVWF  00
3754:  DECFSZ 00,F
3756:  BRA    3754
3758:  BSF    F94.3
375A:  BTFSS  F82.3
375C:  BRA    375A
375E:  CLRF   01
3760:  MOVLW  0B
3762:  MOVWF  00
3764:  DECFSZ 00,F
3766:  BRA    3764
3768:  BTFSC  F82.4
376A:  BSF    01.0
376C:  BCF    F8B.3
376E:  BCF    F94.3
3770:  BCF    F8B.4
3772:  BCF    F94.4
3774:  MOVLB  0
3776:  RETURN 0
3778:  MOVLW  08
377A:  MOVLB  8
377C:  MOVWF  x01
377E:  MOVFF  00,802
3782:  BSF    F94.4
3784:  MOVLW  0B
3786:  MOVWF  00
3788:  DECFSZ 00,F
378A:  BRA    3788
378C:  BSF    F94.3
378E:  BTFSS  F82.3
3790:  BRA    378E
3792:  BTFSC  F82.4
3794:  BSF    FD8.0
3796:  BTFSS  F82.4
3798:  BCF    FD8.0
379A:  RLCF   01,F
379C:  MOVLW  0A
379E:  MOVWF  00
37A0:  DECFSZ 00,F
37A2:  BRA    37A0
37A4:  BCF    F94.3
37A6:  BCF    F8B.3
37A8:  DECFSZ x01,F
37AA:  BRA    3782
37AC:  BSF    F94.4
37AE:  MOVLW  0B
37B0:  MOVWF  00
37B2:  DECFSZ 00,F
37B4:  BRA    37B2
37B6:  BCF    F8B.4
37B8:  MOVF   x02,W
37BA:  BTFSS  FD8.2
37BC:  BCF    F94.4
37BE:  NOP   
37C0:  BSF    F94.3
37C2:  BTFSS  F82.3
37C4:  BRA    37C2
37C6:  MOVLW  0A
37C8:  MOVWF  00
37CA:  DECFSZ 00,F
37CC:  BRA    37CA
37CE:  BCF    F8B.3
37D0:  BCF    F94.3
37D2:  MOVLW  0B
37D4:  MOVWF  00
37D6:  DECFSZ 00,F
37D8:  BRA    37D6
37DA:  BCF    F8B.4
37DC:  BCF    F94.4
37DE:  MOVLB  0
37E0:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE_key    131071 
.................... #define EEPROM_SIZE        115470 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
48D0:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
48D2:  BSF    F94.4
....................    port_b_pullups(0xff); 
48D4:  BCF    FF1.7
.................... } 
48D6:  GOTO   6D76 (RETURN)
.................... /* 
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
....................    if(address<0xffff)i2c_write(0xa0); 
....................       else if(address>=0xffff) i2c_write(0xa2); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
....................    i2c_start(); 
....................    status=i2c_write(0xa0); 
....................    while(status==1) 
....................    { 
....................       i2c_start(); 
....................       status=i2c_write(0xa0); 
....................    } 
....................    i2c_stop(); 
.................... } 
.................... */ 
....................  
.................... void write_ext_eeprom(int32 address, int8 data) 
.................... { 
....................    int1 status; 
....................    int  command; 
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
3D80:  MOVLB  8
3D82:  MOVF   x05,F
3D84:  BNZ   3D8C
3D86:  MOVF   x04,W
3D88:  SUBLW  00
3D8A:  BC    3D92
3D8C:  MOVLW  A8
3D8E:  MOVWF  x08
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
3D90:  BRA    3D96
3D92:  MOVLW  A0
3D94:  MOVWF  x08
....................  
....................    i2c_start(); 
3D96:  BSF    F94.4
3D98:  MOVLW  0A
3D9A:  MOVWF  00
3D9C:  DECFSZ 00,F
3D9E:  BRA    3D9C
3DA0:  BSF    F94.3
3DA2:  MOVLW  0B
3DA4:  MOVWF  00
3DA6:  DECFSZ 00,F
3DA8:  BRA    3DA6
3DAA:  BCF    F8B.4
3DAC:  BCF    F94.4
3DAE:  MOVLW  0A
3DB0:  MOVWF  00
3DB2:  DECFSZ 00,F
3DB4:  BRA    3DB2
3DB6:  BCF    F8B.3
3DB8:  BCF    F94.3
....................    i2c_write(command); 
3DBA:  MOVFF  808,80E
3DBE:  MOVLB  0
3DC0:  RCALL  3702
....................    i2c_write(address>>8); 
3DC2:  MOVFF  803,80A
3DC6:  MOVFF  804,80B
3DCA:  MOVFF  805,80C
3DCE:  MOVLB  8
3DD0:  CLRF   x0D
3DD2:  MOVFF  803,80E
3DD6:  MOVLB  0
3DD8:  RCALL  3702
....................    i2c_write(address); 
3DDA:  MOVFF  802,80E
3DDE:  RCALL  3702
....................    i2c_write(data); 
3DE0:  MOVFF  806,80E
3DE4:  RCALL  3702
....................  
....................    i2c_stop(); 
3DE6:  BCF    F94.4
3DE8:  NOP   
3DEA:  BSF    F94.3
3DEC:  BTFSS  F82.3
3DEE:  BRA    3DEC
3DF0:  MOVLW  0A
3DF2:  MOVWF  00
3DF4:  DECFSZ 00,F
3DF6:  BRA    3DF4
3DF8:  BRA    3DFA
3DFA:  NOP   
3DFC:  BSF    F94.4
3DFE:  MOVLW  0A
3E00:  MOVWF  00
3E02:  DECFSZ 00,F
3E04:  BRA    3E02
....................    i2c_start(); 
3E06:  BSF    F94.4
3E08:  MOVLW  0A
3E0A:  MOVWF  00
3E0C:  DECFSZ 00,F
3E0E:  BRA    3E0C
3E10:  BSF    F94.3
3E12:  MOVLW  0B
3E14:  MOVWF  00
3E16:  DECFSZ 00,F
3E18:  BRA    3E16
3E1A:  BCF    F8B.4
3E1C:  BCF    F94.4
3E1E:  MOVLW  0A
3E20:  MOVWF  00
3E22:  DECFSZ 00,F
3E24:  BRA    3E22
3E26:  BCF    F8B.3
3E28:  BCF    F94.3
....................    status=i2c_write(command); 
3E2A:  MOVFF  808,80E
3E2E:  RCALL  3702
3E30:  MOVF   01,W
3E32:  MOVLB  8
3E34:  BCF    x07.0
3E36:  BTFSC  01.0
3E38:  BSF    x07.0
....................    while(status==1) 
....................    { 
3E3A:  BTFSS  x07.0
3E3C:  BRA    3E7A
....................       i2c_start(); 
3E3E:  BSF    F94.4
3E40:  MOVLW  0A
3E42:  MOVWF  00
3E44:  DECFSZ 00,F
3E46:  BRA    3E44
3E48:  BSF    F94.3
3E4A:  MOVLW  0B
3E4C:  MOVWF  00
3E4E:  DECFSZ 00,F
3E50:  BRA    3E4E
3E52:  BTFSS  F82.3
3E54:  BRA    3E52
3E56:  BCF    F8B.4
3E58:  BCF    F94.4
3E5A:  MOVLW  0A
3E5C:  MOVWF  00
3E5E:  DECFSZ 00,F
3E60:  BRA    3E5E
3E62:  BCF    F8B.3
3E64:  BCF    F94.3
....................       status=i2c_write(command); 
3E66:  MOVFF  808,80E
3E6A:  MOVLB  0
3E6C:  RCALL  3702
3E6E:  MOVF   01,W
3E70:  MOVLB  8
3E72:  BCF    x07.0
3E74:  BTFSC  01.0
3E76:  BSF    x07.0
....................    } 
3E78:  BRA    3E3A
....................    //delay_us(100); 
.................... } 
3E7A:  MOVLB  0
3E7C:  RETURN 0
....................  
.................... /* 
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
....................    i2c_write(0xa0); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(0xa1); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    return(data); 
.................... } 
.................... */ 
.................... BYTE read_ext_eeprom(int32 address) { 
....................    BYTE data; 
....................    int   command; 
....................  
.................... #if defined(24AA1025) 
....................    if (address>65535)command=0xa8; // Check if address is located in Block 0/1 
*
37E2:  MOVLB  7
37E4:  MOVF   xF2,F
37E6:  BNZ   37EE
37E8:  MOVF   xF1,W
37EA:  SUBLW  00
37EC:  BC    37F4
37EE:  MOVLW  A8
37F0:  MOVWF  xF4
.................... #else     
....................    if (address>65535)command=0xa2; // Check if address is located in Block 0/1 
.................... #endif 
....................    else command=0xa0; 
37F2:  BRA    37F8
37F4:  MOVLW  A0
37F6:  MOVWF  xF4
....................  
....................    i2c_start(); 
37F8:  BSF    F94.4
37FA:  MOVLW  0A
37FC:  MOVWF  00
37FE:  DECFSZ 00,F
3800:  BRA    37FE
3802:  BSF    F94.3
3804:  MOVLW  0B
3806:  MOVWF  00
3808:  DECFSZ 00,F
380A:  BRA    3808
380C:  BTFSS  F82.3
380E:  BRA    380C
3810:  BCF    F8B.4
3812:  BCF    F94.4
3814:  MOVLW  0A
3816:  MOVWF  00
3818:  DECFSZ 00,F
381A:  BRA    3818
381C:  BCF    F8B.3
381E:  BCF    F94.3
....................    i2c_write(command); 
3820:  MOVFF  7F4,80E
3824:  MOVLB  0
3826:  RCALL  3702
....................    i2c_write(address>>8); 
3828:  MOVFF  7F0,7F6
382C:  MOVFF  7F1,7F7
3830:  MOVFF  7F2,7F8
3834:  MOVLB  7
3836:  CLRF   xF9
3838:  MOVFF  7F0,80E
383C:  MOVLB  0
383E:  RCALL  3702
....................    i2c_write(address); 
3840:  MOVFF  7EF,80E
3844:  RCALL  3702
....................    i2c_start(); 
3846:  BSF    F94.4
3848:  MOVLW  0A
384A:  MOVWF  00
384C:  DECFSZ 00,F
384E:  BRA    384C
3850:  BSF    F94.3
3852:  MOVLW  0B
3854:  MOVWF  00
3856:  DECFSZ 00,F
3858:  BRA    3856
385A:  BTFSS  F82.3
385C:  BRA    385A
385E:  BCF    F8B.4
3860:  BCF    F94.4
3862:  MOVLW  0A
3864:  MOVWF  00
3866:  DECFSZ 00,F
3868:  BRA    3866
386A:  BCF    F8B.3
386C:  BCF    F94.3
....................    i2c_write(command+1); 
386E:  MOVLW  01
3870:  MOVLB  7
3872:  ADDWF  xF4,W
3874:  MOVWF  xF5
3876:  MOVFF  FE8,80E
387A:  MOVLB  0
387C:  RCALL  3702
....................    data=i2c_read(0); 
387E:  CLRF   00
3880:  RCALL  3778
3882:  MOVFF  01,7F3
....................    i2c_stop(); 
3886:  BCF    F94.4
3888:  NOP   
388A:  BSF    F94.3
388C:  BTFSS  F82.3
388E:  BRA    388C
3890:  MOVLW  0A
3892:  MOVWF  00
3894:  DECFSZ 00,F
3896:  BRA    3894
3898:  BRA    389A
389A:  NOP   
389C:  BSF    F94.4
389E:  MOVLW  0A
38A0:  MOVWF  00
38A2:  DECFSZ 00,F
38A4:  BRA    38A2
....................    return(data); 
38A6:  MOVLB  7
38A8:  MOVFF  7F3,01
.................... } 
38AC:  MOVLB  0
38AE:  RETURN 0
....................  
....................  
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
4F84:  MOVLB  7
4F86:  MOVF   xBE,W
4F88:  ADDWF  xBC,W
4F8A:  MOVF   xBF,W
4F8C:  ADDWFC xBD,W
4F8E:  MOVWF  xC5
....................    for(i=0;i<len;i++) 
4F90:  CLRF   xC3
4F92:  CLRF   xC2
4F94:  MOVF   xC3,W
4F96:  SUBWF  xBF,W
4F98:  BNC   4FF2
4F9A:  BNZ   4FA2
4F9C:  MOVF   xBE,W
4F9E:  SUBWF  xC2,W
4FA0:  BC    4FF2
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
4FA2:  MOVF   xC0,W
4FA4:  ADDWF  xC2,W
4FA6:  MOVWF  01
4FA8:  MOVF   xC1,W
4FAA:  ADDWFC xC3,W
4FAC:  MOVWF  03
4FAE:  MOVFF  01,7C4
4FB2:  MOVWF  xC5
4FB4:  MOVF   xC2,W
4FB6:  ADDWF  xBC,W
4FB8:  MOVWF  xC6
4FBA:  MOVF   xC3,W
4FBC:  ADDWFC xBD,W
4FBE:  MOVWF  xC7
4FC0:  CLRF   19
4FC2:  BTFSC  FF2.7
4FC4:  BSF    19.7
4FC6:  BCF    FF2.7
4FC8:  CLRF   xF2
4FCA:  CLRF   xF1
4FCC:  MOVWF  xF0
4FCE:  MOVFF  7C6,7EF
4FD2:  MOVLB  0
4FD4:  CALL   37E2
4FD8:  BTFSC  19.7
4FDA:  BSF    FF2.7
4FDC:  MOVFF  7C5,FEA
4FE0:  MOVFF  7C4,FE9
4FE4:  MOVFF  01,FEF
....................    } 
4FE8:  MOVLB  7
4FEA:  INCF   xC2,F
4FEC:  BTFSC  FD8.2
4FEE:  INCF   xC3,F
4FF0:  BRA    4F94
....................     
.................... } 
4FF2:  MOVLB  0
4FF4:  GOTO   57E2 (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_mobile_num0        65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_two_number        149 
.................... #define kindofKB                 126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards               930   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
392A:  MOVLB  7
392C:  CLRF   xF8
392E:  MOVF   xF5,W
3930:  SUBWF  xF8,W
3932:  BC    3948
....................    { 
....................       inputdat[i]=0; 
3934:  CLRF   03
3936:  MOVF   xF8,W
3938:  ADDWF  xF6,W
393A:  MOVWF  FE9
393C:  MOVF   xF7,W
393E:  ADDWFC 03,W
3940:  MOVWF  FEA
3942:  CLRF   FEF
....................    } 
3944:  INCF   xF8,F
3946:  BRA    392E
.................... } 
3948:  MOVLB  0
394A:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_write(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
4938:  MOVLB  7
493A:  CLRF   xD3
493C:  MOVF   xD0,W
493E:  SUBWF  xD3,W
4940:  BC    498C
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4942:  MOVF   xD3,W
4944:  ADDWF  xCF,W
4946:  MOVWF  xD4
4948:  CLRF   03
494A:  MOVF   xD3,W
494C:  ADDWF  xD1,W
494E:  MOVWF  FE9
4950:  MOVF   xD2,W
4952:  ADDWFC 03,W
4954:  MOVWF  FEA
4956:  MOVFF  FEF,7D5
495A:  CLRF   19
495C:  BTFSC  FF2.7
495E:  BSF    19.7
4960:  BCF    FF2.7
4962:  MOVLB  8
4964:  CLRF   x05
4966:  CLRF   x04
4968:  CLRF   x03
496A:  MOVFF  7D4,802
496E:  MOVFF  7D5,806
4972:  MOVLB  0
4974:  CALL   3D80
4978:  BTFSC  19.7
497A:  BSF    FF2.7
....................       delay_us(10); 
497C:  MOVLW  1A
497E:  MOVWF  00
4980:  DECFSZ 00,F
4982:  BRA    4980
4984:  NOP   
....................    } 
4986:  MOVLB  7
4988:  INCF   xD3,F
498A:  BRA    493C
.................... } 
498C:  MOVLB  0
498E:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
48DA:  MOVLB  7
48DC:  CLRF   xBE
48DE:  MOVF   xBB,W
48E0:  SUBWF  xBE,W
48E2:  BC    4934
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
48E4:  CLRF   03
48E6:  MOVF   xBE,W
48E8:  ADDWF  xBC,W
48EA:  MOVWF  01
48EC:  MOVF   xBD,W
48EE:  ADDWFC 03,F
48F0:  MOVFF  01,7BF
48F4:  MOVFF  03,7C0
48F8:  MOVF   xBE,W
48FA:  ADDWF  xBA,W
48FC:  MOVWF  xC1
48FE:  CLRF   19
4900:  BTFSC  FF2.7
4902:  BSF    19.7
4904:  BCF    FF2.7
4906:  CLRF   xF2
4908:  CLRF   xF1
490A:  CLRF   xF0
490C:  MOVWF  xEF
490E:  MOVLB  0
4910:  CALL   37E2
4914:  BTFSC  19.7
4916:  BSF    FF2.7
4918:  MOVFF  7C0,FEA
491C:  MOVFF  7BF,FE9
4920:  MOVFF  01,FEF
....................       delay_us(10); 
4924:  MOVLW  1A
4926:  MOVWF  00
4928:  DECFSZ 00,F
492A:  BRA    4928
492C:  NOP   
....................    } 
492E:  MOVLB  7
4930:  INCF   xBE,F
4932:  BRA    48DE
.................... } 
4934:  MOVLB  0
4936:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
4BD6:  MOVLB  7
4BD8:  CLRF   x88
4BDA:  CLRF   x87
4BDC:  CLRF   x86
4BDE:  CLRF   x85
4BE0:  CLRF   x8C
4BE2:  CLRF   x8B
4BE4:  CLRF   x8A
4BE6:  CLRF   x89
4BE8:  CLRF   x90
4BEA:  CLRF   x8F
4BEC:  CLRF   x8E
4BEE:  CLRF   x8D
4BF0:  CLRF   x94
4BF2:  CLRF   x93
4BF4:  CLRF   x92
4BF6:  CLRF   x91
4BF8:  CLRF   x98
4BFA:  CLRF   x97
4BFC:  CLRF   x96
4BFE:  CLRF   x95
4C00:  CLRF   19
4C02:  BTFSC  FF2.7
4C04:  BSF    19.7
4C06:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
4C08:  CLRF   xF2
4C0A:  CLRF   xF1
4C0C:  CLRF   xF0
4C0E:  MOVFF  784,7EF
4C12:  MOVLB  0
4C14:  CALL   37E2
4C18:  BTFSC  19.7
4C1A:  BSF    FF2.7
4C1C:  MOVLB  7
4C1E:  MOVFF  01,789
4C22:  CLRF   x8A
4C24:  CLRF   x8B
4C26:  CLRF   x8C
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
4C28:  MOVLW  01
4C2A:  ADDWF  x84,W
4C2C:  MOVWF  x99
4C2E:  CLRF   19
4C30:  BTFSC  FF2.7
4C32:  BSF    19.7
4C34:  BCF    FF2.7
4C36:  CLRF   xF2
4C38:  CLRF   xF1
4C3A:  CLRF   xF0
4C3C:  MOVWF  xEF
4C3E:  MOVLB  0
4C40:  CALL   37E2
4C44:  BTFSC  19.7
4C46:  BSF    FF2.7
4C48:  MOVLB  7
4C4A:  CLRF   x90
4C4C:  CLRF   x8F
4C4E:  CLRF   x8E
4C50:  MOVFF  01,78D
....................    temp2<<=8; 
4C54:  MOVFF  78F,790
4C58:  MOVFF  78E,78F
4C5C:  MOVFF  78D,78E
4C60:  CLRF   x8D
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
4C62:  MOVLW  02
4C64:  ADDWF  x84,W
4C66:  MOVWF  x99
4C68:  CLRF   19
4C6A:  BTFSC  FF2.7
4C6C:  BSF    19.7
4C6E:  BCF    FF2.7
4C70:  CLRF   xF2
4C72:  CLRF   xF1
4C74:  CLRF   xF0
4C76:  MOVWF  xEF
4C78:  MOVLB  0
4C7A:  CALL   37E2
4C7E:  BTFSC  19.7
4C80:  BSF    FF2.7
4C82:  MOVLB  7
4C84:  CLRF   x94
4C86:  CLRF   x93
4C88:  CLRF   x92
4C8A:  MOVFF  01,791
....................    temp3<<=16; 
4C8E:  MOVFF  792,794
4C92:  MOVFF  791,793
4C96:  CLRF   x91
4C98:  CLRF   x92
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
4C9A:  MOVLW  03
4C9C:  ADDWF  x84,W
4C9E:  MOVWF  x99
4CA0:  CLRF   19
4CA2:  BTFSC  FF2.7
4CA4:  BSF    19.7
4CA6:  BCF    FF2.7
4CA8:  CLRF   xF2
4CAA:  CLRF   xF1
4CAC:  CLRF   xF0
4CAE:  MOVWF  xEF
4CB0:  MOVLB  0
4CB2:  CALL   37E2
4CB6:  BTFSC  19.7
4CB8:  BSF    FF2.7
4CBA:  MOVLB  7
4CBC:  CLRF   x98
4CBE:  CLRF   x97
4CC0:  CLRF   x96
4CC2:  MOVFF  01,795
....................    temp4<<=24; 
4CC6:  MOVFF  795,798
4CCA:  CLRF   x95
4CCC:  CLRF   x96
4CCE:  CLRF   x97
....................    buffer = temp4|temp3|temp2|temp1; 
4CD0:  MOVF   x95,W
4CD2:  IORWF  x91,W
4CD4:  MOVWF  x99
4CD6:  MOVF   x96,W
4CD8:  IORWF  x92,W
4CDA:  MOVWF  x9A
4CDC:  MOVF   x97,W
4CDE:  IORWF  x93,W
4CE0:  MOVWF  x9B
4CE2:  MOVF   x98,W
4CE4:  IORWF  x94,W
4CE6:  MOVWF  x9C
4CE8:  MOVF   x8D,W
4CEA:  IORWF  x99,F
4CEC:  MOVF   x8E,W
4CEE:  IORWF  x9A,F
4CF0:  MOVF   x8F,W
4CF2:  IORWF  x9B,F
4CF4:  MOVF   x90,W
4CF6:  IORWF  x9C,F
4CF8:  MOVF   x99,W
4CFA:  IORWF  x89,W
4CFC:  MOVWF  x85
4CFE:  MOVF   x9A,W
4D00:  IORWF  x8A,W
4D02:  MOVWF  x86
4D04:  MOVF   x9B,W
4D06:  IORWF  x8B,W
4D08:  MOVWF  x87
4D0A:  MOVF   x9C,W
4D0C:  IORWF  x8C,W
4D0E:  MOVWF  x88
....................    return(buffer); 
4D10:  MOVFF  785,00
4D14:  MOVFF  786,01
4D18:  MOVFF  787,02
4D1C:  MOVFF  788,03
.................... } 
4D20:  MOVLB  0
4D22:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3E7E:  MOVLB  7
3E80:  CLRF   xF1
3E82:  CLRF   xF0
3E84:  CLRF   xEF
3E86:  CLRF   xEE
3E88:  CLRF   xF2
3E8A:  CLRF   xF3
3E8C:  CLRF   xF4
3E8E:  CLRF   xF5
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3E90:  MOVFF  7EC,7F1
3E94:  MOVFF  7EB,7F0
3E98:  MOVFF  7EA,7EF
3E9C:  MOVFF  7E9,7EE
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3EA0:  MOVFF  7EE,7F2
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3EA4:  MOVFF  7EF,7F3
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3EA8:  MOVFF  7F0,7F4
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3EAC:  MOVFF  7F1,7F5
....................    write_ext_eeprom((addr+0),temp1); 
3EB0:  MOVLB  8
3EB2:  CLRF   x05
3EB4:  CLRF   x04
3EB6:  CLRF   x03
3EB8:  MOVFF  7ED,802
3EBC:  MOVFF  7F2,806
3EC0:  MOVLB  0
3EC2:  RCALL  3D80
....................    write_ext_eeprom((addr+1),temp2); 
3EC4:  MOVLW  01
3EC6:  MOVLB  7
3EC8:  ADDWF  xED,W
3ECA:  MOVWF  xF6
3ECC:  MOVLB  8
3ECE:  CLRF   x05
3ED0:  CLRF   x04
3ED2:  CLRF   x03
3ED4:  MOVWF  x02
3ED6:  MOVFF  7F3,806
3EDA:  MOVLB  0
3EDC:  RCALL  3D80
....................    write_ext_eeprom((addr+2),temp3); 
3EDE:  MOVLW  02
3EE0:  MOVLB  7
3EE2:  ADDWF  xED,W
3EE4:  MOVWF  xF6
3EE6:  MOVLB  8
3EE8:  CLRF   x05
3EEA:  CLRF   x04
3EEC:  CLRF   x03
3EEE:  MOVWF  x02
3EF0:  MOVFF  7F4,806
3EF4:  MOVLB  0
3EF6:  RCALL  3D80
....................    write_ext_eeprom((addr+3),temp4); 
3EF8:  MOVLW  03
3EFA:  MOVLB  7
3EFC:  ADDWF  xED,W
3EFE:  MOVWF  xF6
3F00:  MOVLB  8
3F02:  CLRF   x05
3F04:  CLRF   x04
3F06:  CLRF   x03
3F08:  MOVWF  x02
3F0A:  MOVFF  7F5,806
3F0E:  MOVLB  0
3F10:  RCALL  3D80
.................... } 
3F12:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
44BE:  MOVLB  7
44C0:  CLRF   xE9
44C2:  CLRF   xE8
44C4:  CLRF   xEA
44C6:  CLRF   xEB
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
44C8:  MOVFF  7E7,7E9
44CC:  MOVFF  7E6,7E8
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
44D0:  MOVFF  7E8,7EA
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
44D4:  MOVF   xE9,W
44D6:  MOVWF  xEB
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
44D8:  MOVLB  8
44DA:  CLRF   x05
44DC:  CLRF   x04
44DE:  CLRF   x03
44E0:  MOVLW  28
44E2:  MOVWF  x02
44E4:  MOVFF  7EA,806
44E8:  MOVLB  0
44EA:  RCALL  3D80
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
44EC:  MOVLB  8
44EE:  CLRF   x05
44F0:  CLRF   x04
44F2:  CLRF   x03
44F4:  MOVLW  29
44F6:  MOVWF  x02
44F8:  MOVFF  7EB,806
44FC:  MOVLB  0
44FE:  RCALL  3D80
.................... } 
4500:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
38B0:  MOVLB  7
38B2:  CLRF   xEA
38B4:  CLRF   xE9
38B6:  CLRF   xEC
38B8:  CLRF   xEB
38BA:  CLRF   xEE
38BC:  CLRF   xED
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
38BE:  CLRF   xF2
38C0:  CLRF   xF1
38C2:  CLRF   xF0
38C4:  MOVLW  28
38C6:  MOVWF  xEF
38C8:  MOVLB  0
38CA:  RCALL  37E2
38CC:  MOVLB  7
38CE:  MOVFF  01,7EB
38D2:  CLRF   xEC
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
38D4:  CLRF   xF2
38D6:  CLRF   xF1
38D8:  CLRF   xF0
38DA:  MOVLW  29
38DC:  MOVWF  xEF
38DE:  MOVLB  0
38E0:  RCALL  37E2
38E2:  MOVLB  7
38E4:  CLRF   xEE
38E6:  MOVFF  01,7ED
....................    temp2<<=8; 
38EA:  MOVFF  7ED,7EE
38EE:  CLRF   xED
....................    buffer = temp2|temp1; 
38F0:  MOVF   xED,W
38F2:  IORWF  xEB,W
38F4:  MOVWF  xE9
38F6:  MOVF   xEE,W
38F8:  IORWF  xEC,W
38FA:  MOVWF  xEA
....................    return(buffer); 
38FC:  MOVFF  7E9,01
3900:  MOVFF  7EA,02
.................... } 
3904:  MOVLB  0
3906:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int32 i; 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2,"EEPROM_KEY_ST=%lu\n\r",EEPROM_KEY_ST); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
5112:  MOVLB  7
5114:  CLRF   xBD
5116:  MOVLW  01
5118:  MOVWF  xBC
511A:  MOVLW  C3
511C:  MOVWF  xBB
511E:  MOVLW  0F
5120:  MOVWF  xBA
5122:  MOVF   xBD,W
5124:  SUBWF  27,W
5126:  BNC   517A
5128:  BNZ   5140
512A:  MOVF   xBC,W
512C:  SUBWF  26,W
512E:  BNC   517A
5130:  BNZ   5140
5132:  MOVF   xBB,W
5134:  SUBWF  25,W
5136:  BNC   517A
5138:  BNZ   5140
513A:  MOVF   24,W
513C:  SUBWF  xBA,W
513E:  BC    517A
5140:  CLRF   19
5142:  BTFSC  FF2.7
5144:  BSF    19.7
5146:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5148:  MOVFF  7BD,805
514C:  MOVFF  7BC,804
5150:  MOVFF  7BB,803
5154:  MOVFF  7BA,802
5158:  MOVLB  8
515A:  CLRF   x06
515C:  MOVLB  0
515E:  CALL   3D80
5162:  BTFSC  19.7
5164:  BSF    FF2.7
....................      //fprintf(COM2," i=%lu\n\r",i); 
....................    } 
5166:  MOVLW  01
5168:  MOVLB  7
516A:  ADDWF  xBA,F
516C:  BTFSC  FD8.0
516E:  INCF   xBB,F
5170:  BTFSC  FD8.2
5172:  INCF   xBC,F
5174:  BTFSC  FD8.2
5176:  INCF   xBD,F
5178:  BRA    5122
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    for(i=ptr_start;i<ptr_card;i++) 
517A:  CLRF   xBD
517C:  CLRF   xBC
517E:  CLRF   xBB
5180:  MOVLW  96
5182:  MOVWF  xBA
5184:  MOVF   xBD,W
5186:  SUBWF  23,W
5188:  BNC   51DC
518A:  BNZ   51A2
518C:  MOVF   xBC,W
518E:  SUBWF  22,W
5190:  BNC   51DC
5192:  BNZ   51A2
5194:  MOVF   xBB,W
5196:  SUBWF  21,W
5198:  BNC   51DC
519A:  BNZ   51A2
519C:  MOVF   20,W
519E:  SUBWF  xBA,W
51A0:  BC    51DC
51A2:  CLRF   19
51A4:  BTFSC  FF2.7
51A6:  BSF    19.7
51A8:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
51AA:  MOVFF  7BD,805
51AE:  MOVFF  7BC,804
51B2:  MOVFF  7BB,803
51B6:  MOVFF  7BA,802
51BA:  MOVLB  8
51BC:  CLRF   x06
51BE:  MOVLB  0
51C0:  CALL   3D80
51C4:  BTFSC  19.7
51C6:  BSF    FF2.7
....................    } 
51C8:  MOVLW  01
51CA:  MOVLB  7
51CC:  ADDWF  xBA,F
51CE:  BTFSC  FD8.0
51D0:  INCF   xBB,F
51D2:  BTFSC  FD8.2
51D4:  INCF   xBC,F
51D6:  BTFSC  FD8.2
51D8:  INCF   xBD,F
51DA:  BRA    5184
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    ptr_card=ptr_start; 
51DC:  CLRF   23
51DE:  CLRF   22
51E0:  CLRF   21
51E2:  MOVLW  96
51E4:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
51E6:  CLRF   27
51E8:  MOVLW  01
51EA:  MOVWF  26
51EC:  MOVLW  C3
51EE:  MOVWF  25
51F0:  MOVLW  0F
51F2:  MOVWF  24
51F4:  CLRF   19
51F6:  BTFSC  FF2.7
51F8:  BSF    19.7
51FA:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
51FC:  MOVFF  23,7EC
5200:  MOVFF  22,7EB
5204:  MOVFF  21,7EA
5208:  MOVFF  20,7E9
520C:  MOVLW  19
520E:  MOVWF  xED
5210:  MOVLB  0
5212:  CALL   3E7E
5216:  BTFSC  19.7
5218:  BSF    FF2.7
521A:  CLRF   19
521C:  BTFSC  FF2.7
521E:  BSF    19.7
5220:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5222:  MOVFF  27,7EC
5226:  MOVFF  26,7EB
522A:  MOVFF  25,7EA
522E:  MOVFF  24,7E9
5232:  MOVLW  1E
5234:  MOVLB  7
5236:  MOVWF  xED
5238:  MOVLB  0
523A:  CALL   3E7E
523E:  BTFSC  19.7
5240:  BSF    FF2.7
5242:  CLRF   19
5244:  BTFSC  FF2.7
5246:  BSF    19.7
5248:  BCF    FF2.7
....................    save_coutcard(0); 
524A:  MOVLB  7
524C:  CLRF   xE7
524E:  CLRF   xE6
5250:  MOVLB  0
5252:  CALL   44BE
5256:  BTFSC  19.7
5258:  BSF    FF2.7
525A:  CLRF   19
525C:  BTFSC  FF2.7
525E:  BSF    19.7
5260:  BCF    FF2.7
....................    countcard=get_countcard(); 
5262:  CALL   38B0
5266:  BTFSC  19.7
5268:  BSF    FF2.7
526A:  MOVFF  02,FA
526E:  MOVFF  01,F9
....................    /*fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    fprintf(COM2," countcard=%lu\n\r",countcard);*/ 
.................... } 
5272:  GOTO   5B52 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int32 i; 
....................    /*for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
....................    { 
....................      write_ext_eeprom(i,0); 
....................    }*/ 
....................    ptr_card=ptr_start; 
5276:  CLRF   23
5278:  CLRF   22
527A:  CLRF   21
527C:  MOVLW  96
527E:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5280:  CLRF   27
5282:  MOVLW  01
5284:  MOVWF  26
5286:  MOVLW  C3
5288:  MOVWF  25
528A:  MOVLW  0F
528C:  MOVWF  24
528E:  CLRF   19
5290:  BTFSC  FF2.7
5292:  BSF    19.7
5294:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5296:  MOVFF  23,7EC
529A:  MOVFF  22,7EB
529E:  MOVFF  21,7EA
52A2:  MOVFF  20,7E9
52A6:  MOVLW  19
52A8:  MOVLB  7
52AA:  MOVWF  xED
52AC:  MOVLB  0
52AE:  CALL   3E7E
52B2:  BTFSC  19.7
52B4:  BSF    FF2.7
52B6:  CLRF   19
52B8:  BTFSC  FF2.7
52BA:  BSF    19.7
52BC:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
52BE:  MOVFF  27,7EC
52C2:  MOVFF  26,7EB
52C6:  MOVFF  25,7EA
52CA:  MOVFF  24,7E9
52CE:  MOVLW  1E
52D0:  MOVLB  7
52D2:  MOVWF  xED
52D4:  MOVLB  0
52D6:  CALL   3E7E
52DA:  BTFSC  19.7
52DC:  BSF    FF2.7
52DE:  CLRF   19
52E0:  BTFSC  FF2.7
52E2:  BSF    19.7
52E4:  BCF    FF2.7
....................    save_coutcard(0); 
52E6:  MOVLB  7
52E8:  CLRF   xE7
52EA:  CLRF   xE6
52EC:  MOVLB  0
52EE:  CALL   44BE
52F2:  BTFSC  19.7
52F4:  BSF    FF2.7
.................... } 
52F6:  GOTO   5BB8 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
4990:  MOVLB  7
4992:  CLRF   xBA
4994:  MOVLW  14
4996:  MOVWF  xBB
4998:  CLRF   xBD
499A:  MOVLW  55
499C:  MOVWF  xBC
499E:  MOVLB  0
49A0:  RCALL  48DA
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
49A2:  INCFSZ 55,W
49A4:  BRA    49FA
49A6:  INCFSZ 56,W
49A8:  BRA    49FA
49AA:  INCFSZ x64,W
49AC:  BRA    49FA
....................       { 
....................          memset(buffer1,0,20); 
49AE:  CLRF   FEA
49B0:  MOVLW  2D
49B2:  MOVWF  FE9
49B4:  CLRF   00
49B6:  CLRF   02
49B8:  MOVLW  14
49BA:  MOVWF  01
49BC:  RCALL  4322
....................          strcpy(buffer1,"admin"); 
49BE:  CLRF   FEA
49C0:  MOVLW  2D
49C2:  MOVWF  FE9
49C4:  MOVLW  00
49C6:  CALL   00BA
49CA:  TBLRD*-
49CC:  TBLRD*+
49CE:  MOVF   FF5,W
49D0:  MOVWF  FEE
49D2:  IORLW  00
49D4:  BNZ   49CC
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
49D6:  MOVLB  7
49D8:  CLRF   xCF
49DA:  MOVLW  14
49DC:  MOVWF  xD0
49DE:  CLRF   xD2
49E0:  MOVLW  2D
49E2:  MOVWF  xD1
49E4:  MOVLB  0
49E6:  RCALL  4938
....................          EEPROM_read(strobe_pass_addr,20,password); 
49E8:  MOVLB  7
49EA:  CLRF   xBA
49EC:  MOVLW  14
49EE:  MOVWF  xBB
49F0:  CLRF   xBD
49F2:  MOVLW  55
49F4:  MOVWF  xBC
49F6:  MOVLB  0
49F8:  RCALL  48DA
....................       } 
.................... } 
49FA:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
52FA:  MOVLB  7
52FC:  CLRF   xCE
52FE:  MOVF   xCE,W
5300:  SUBLW  13
5302:  BNC   5318
5304:  CLRF   03
5306:  MOVF   xCE,W
5308:  ADDLW  BA
530A:  MOVWF  FE9
530C:  MOVLW  07
530E:  ADDWFC 03,W
5310:  MOVWF  FEA
5312:  SETF   FEF
5314:  INCF   xCE,F
5316:  BRA    52FE
....................    EEPROM_write(strobe_pass_addr,20,buf); 
5318:  CLRF   xCF
531A:  MOVLW  14
531C:  MOVWF  xD0
531E:  MOVLW  07
5320:  MOVWF  xD2
5322:  MOVLW  BA
5324:  MOVWF  xD1
5326:  MOVLB  0
5328:  CALL   4938
.................... } 
532C:  GOTO   5C1E (RETURN)
.................... //============================================ 
.................... void reset_2nd_number() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0; 
....................    EEPROM_write(strobe_mobile_num0,20,buf); 
.................... } 
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
49FC:  BSF    F94.4
49FE:  MOVLW  0A
4A00:  MOVWF  00
4A02:  DECFSZ 00,F
4A04:  BRA    4A02
4A06:  BSF    F94.3
4A08:  MOVLW  0B
4A0A:  MOVWF  00
4A0C:  DECFSZ 00,F
4A0E:  BRA    4A0C
4A10:  BCF    F8B.4
4A12:  BCF    F94.4
4A14:  MOVLW  0A
4A16:  MOVWF  00
4A18:  DECFSZ 00,F
4A1A:  BRA    4A18
4A1C:  BCF    F8B.3
4A1E:  BCF    F94.3
4A20:  CLRF   19
4A22:  BTFSC  FF2.7
4A24:  BSF    19.7
4A26:  BCF    FF2.7
....................    i2c_write(0xD0); 
4A28:  MOVLW  D0
4A2A:  MOVLB  8
4A2C:  MOVWF  x0E
4A2E:  MOVLB  0
4A30:  CALL   3702
4A34:  BTFSC  19.7
4A36:  BSF    FF2.7
4A38:  CLRF   19
4A3A:  BTFSC  FF2.7
4A3C:  BSF    19.7
4A3E:  BCF    FF2.7
....................    i2c_write(address); 
4A40:  MOVFF  7BE,80E
4A44:  CALL   3702
4A48:  BTFSC  19.7
4A4A:  BSF    FF2.7
....................    i2c_start(); 
4A4C:  BSF    F94.4
4A4E:  MOVLW  0A
4A50:  MOVWF  00
4A52:  DECFSZ 00,F
4A54:  BRA    4A52
4A56:  BSF    F94.3
4A58:  MOVLW  0B
4A5A:  MOVWF  00
4A5C:  DECFSZ 00,F
4A5E:  BRA    4A5C
4A60:  BTFSS  F82.3
4A62:  BRA    4A60
4A64:  BCF    F8B.4
4A66:  BCF    F94.4
4A68:  MOVLW  0A
4A6A:  MOVWF  00
4A6C:  DECFSZ 00,F
4A6E:  BRA    4A6C
4A70:  BCF    F8B.3
4A72:  BCF    F94.3
4A74:  CLRF   19
4A76:  BTFSC  FF2.7
4A78:  BSF    19.7
4A7A:  BCF    FF2.7
....................    i2c_write(0xD1); 
4A7C:  MOVLW  D1
4A7E:  MOVLB  8
4A80:  MOVWF  x0E
4A82:  MOVLB  0
4A84:  CALL   3702
4A88:  BTFSC  19.7
4A8A:  BSF    FF2.7
....................    result = i2c_read(0); 
4A8C:  CLRF   00
4A8E:  CLRF   19
4A90:  BTFSC  FF2.7
4A92:  BSF    19.7
4A94:  BCF    FF2.7
4A96:  CALL   3778
4A9A:  BTFSC  19.7
4A9C:  BSF    FF2.7
4A9E:  MOVFF  01,7BF
....................    i2c_stop(); 
4AA2:  BCF    F94.4
4AA4:  NOP   
4AA6:  BSF    F94.3
4AA8:  BTFSS  F82.3
4AAA:  BRA    4AA8
4AAC:  MOVLW  0A
4AAE:  MOVWF  00
4AB0:  DECFSZ 00,F
4AB2:  BRA    4AB0
4AB4:  BRA    4AB6
4AB6:  NOP   
4AB8:  BSF    F94.4
4ABA:  MOVLW  0A
4ABC:  MOVWF  00
4ABE:  DECFSZ 00,F
4AC0:  BRA    4ABE
....................     
....................    return(result); 
4AC2:  MOVLB  7
4AC4:  MOVFF  7BF,01
.................... } 
4AC8:  MOVLB  0
4ACA:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
54E0:  BSF    F94.4
54E2:  MOVLW  0A
54E4:  MOVWF  00
54E6:  DECFSZ 00,F
54E8:  BRA    54E6
54EA:  BSF    F94.3
54EC:  MOVLW  0B
54EE:  MOVWF  00
54F0:  DECFSZ 00,F
54F2:  BRA    54F0
54F4:  BCF    F8B.4
54F6:  BCF    F94.4
54F8:  MOVLW  0A
54FA:  MOVWF  00
54FC:  DECFSZ 00,F
54FE:  BRA    54FC
5500:  BCF    F8B.3
5502:  BCF    F94.3
....................    delay_us(10); 
5504:  MOVLW  1A
5506:  MOVWF  00
5508:  DECFSZ 00,F
550A:  BRA    5508
550C:  NOP   
550E:  CLRF   19
5510:  BTFSC  FF2.7
5512:  BSF    19.7
5514:  BCF    FF2.7
....................    i2c_write(0xD0); 
5516:  MOVLW  D0
5518:  MOVLB  8
551A:  MOVWF  x0E
551C:  MOVLB  0
551E:  CALL   3702
5522:  BTFSC  19.7
5524:  BSF    FF2.7
....................    delay_us(10); 
5526:  MOVLW  1A
5528:  MOVWF  00
552A:  DECFSZ 00,F
552C:  BRA    552A
552E:  NOP   
5530:  CLRF   19
5532:  BTFSC  FF2.7
5534:  BSF    19.7
5536:  BCF    FF2.7
....................    i2c_write(address); 
5538:  MOVFF  7C1,80E
553C:  CALL   3702
5540:  BTFSC  19.7
5542:  BSF    FF2.7
....................    delay_us(10); 
5544:  MOVLW  1A
5546:  MOVWF  00
5548:  DECFSZ 00,F
554A:  BRA    5548
554C:  NOP   
554E:  CLRF   19
5550:  BTFSC  FF2.7
5552:  BSF    19.7
5554:  BCF    FF2.7
....................    i2c_write(data); 
5556:  MOVFF  7C2,80E
555A:  CALL   3702
555E:  BTFSC  19.7
5560:  BSF    FF2.7
....................    i2c_stop(); 
5562:  BCF    F94.4
5564:  NOP   
5566:  BSF    F94.3
5568:  BTFSS  F82.3
556A:  BRA    5568
556C:  MOVLW  0A
556E:  MOVWF  00
5570:  DECFSZ 00,F
5572:  BRA    5570
5574:  BRA    5576
5576:  NOP   
5578:  BSF    F94.4
557A:  MOVLW  0A
557C:  MOVWF  00
557E:  DECFSZ 00,F
5580:  BRA    557E
....................    delay_us(10); 
5582:  MOVLW  1A
5584:  MOVWF  00
5586:  DECFSZ 00,F
5588:  BRA    5586
558A:  NOP   
.................... } 
558C:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
*
4ACC:  MOVLB  7
4ACE:  CLRF   xBE
4AD0:  MOVLB  0
4AD2:  RCALL  49FC
4AD4:  MOVFF  01,784
....................     
....................    data &= 0x7F; 
4AD8:  MOVLB  7
4ADA:  BCF    x84.7
....................     
....................    i2c_start(); 
4ADC:  BSF    F94.4
4ADE:  MOVLW  0A
4AE0:  MOVWF  00
4AE2:  DECFSZ 00,F
4AE4:  BRA    4AE2
4AE6:  BSF    F94.3
4AE8:  MOVLW  0B
4AEA:  MOVWF  00
4AEC:  DECFSZ 00,F
4AEE:  BRA    4AEC
4AF0:  BCF    F8B.4
4AF2:  BCF    F94.4
4AF4:  MOVLW  0A
4AF6:  MOVWF  00
4AF8:  DECFSZ 00,F
4AFA:  BRA    4AF8
4AFC:  BCF    F8B.3
4AFE:  BCF    F94.3
4B00:  CLRF   19
4B02:  BTFSC  FF2.7
4B04:  BSF    19.7
4B06:  BCF    FF2.7
....................    i2c_write(0xD0); 
4B08:  MOVLW  D0
4B0A:  MOVLB  8
4B0C:  MOVWF  x0E
4B0E:  MOVLB  0
4B10:  CALL   3702
4B14:  BTFSC  19.7
4B16:  BSF    FF2.7
4B18:  CLRF   19
4B1A:  BTFSC  FF2.7
4B1C:  BSF    19.7
4B1E:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
4B20:  MOVLB  8
4B22:  CLRF   x0E
4B24:  MOVLB  0
4B26:  CALL   3702
4B2A:  BTFSC  19.7
4B2C:  BSF    FF2.7
4B2E:  CLRF   19
4B30:  BTFSC  FF2.7
4B32:  BSF    19.7
4B34:  BCF    FF2.7
....................    i2c_write(data); 
4B36:  MOVFF  784,80E
4B3A:  CALL   3702
4B3E:  BTFSC  19.7
4B40:  BSF    FF2.7
....................    i2c_start(); 
4B42:  BSF    F94.4
4B44:  MOVLW  0A
4B46:  MOVWF  00
4B48:  DECFSZ 00,F
4B4A:  BRA    4B48
4B4C:  BSF    F94.3
4B4E:  MOVLW  0B
4B50:  MOVWF  00
4B52:  DECFSZ 00,F
4B54:  BRA    4B52
4B56:  BTFSS  F82.3
4B58:  BRA    4B56
4B5A:  BCF    F8B.4
4B5C:  BCF    F94.4
4B5E:  MOVLW  0A
4B60:  MOVWF  00
4B62:  DECFSZ 00,F
4B64:  BRA    4B62
4B66:  BCF    F8B.3
4B68:  BCF    F94.3
4B6A:  CLRF   19
4B6C:  BTFSC  FF2.7
4B6E:  BSF    19.7
4B70:  BCF    FF2.7
....................    i2c_write(0xD0); 
4B72:  MOVLW  D0
4B74:  MOVLB  8
4B76:  MOVWF  x0E
4B78:  MOVLB  0
4B7A:  CALL   3702
4B7E:  BTFSC  19.7
4B80:  BSF    FF2.7
4B82:  CLRF   19
4B84:  BTFSC  FF2.7
4B86:  BSF    19.7
4B88:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
4B8A:  MOVLW  07
4B8C:  MOVLB  8
4B8E:  MOVWF  x0E
4B90:  MOVLB  0
4B92:  CALL   3702
4B96:  BTFSC  19.7
4B98:  BSF    FF2.7
4B9A:  CLRF   19
4B9C:  BTFSC  FF2.7
4B9E:  BSF    19.7
4BA0:  BCF    FF2.7
....................    i2c_write(0x80); 
4BA2:  MOVLW  80
4BA4:  MOVLB  8
4BA6:  MOVWF  x0E
4BA8:  MOVLB  0
4BAA:  CALL   3702
4BAE:  BTFSC  19.7
4BB0:  BSF    FF2.7
....................    i2c_stop(); 
4BB2:  BCF    F94.4
4BB4:  NOP   
4BB6:  BSF    F94.3
4BB8:  BTFSS  F82.3
4BBA:  BRA    4BB8
4BBC:  MOVLW  0A
4BBE:  MOVWF  00
4BC0:  DECFSZ 00,F
4BC2:  BRA    4BC0
4BC4:  BRA    4BC6
4BC6:  NOP   
4BC8:  BSF    F94.4
4BCA:  MOVLW  0A
4BCC:  MOVWF  00
4BCE:  DECFSZ 00,F
4BD0:  BRA    4BCE
.................... } 
4BD2:  GOTO   6DD8 (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
558E:  CLRF   19
5590:  BTFSC  FF2.7
5592:  BSF    19.7
5594:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
5596:  MOVFF  7C0,800
559A:  MOVLW  0A
559C:  MOVLB  8
559E:  MOVWF  x01
55A0:  MOVLB  0
55A2:  CALL   194C
55A6:  BTFSC  19.7
55A8:  BSF    FF2.7
55AA:  MOVFF  01,7C1
....................    nibl=data-(nibh*10); 
55AE:  MOVLB  7
55B0:  MOVF   xC1,W
55B2:  MULLW  0A
55B4:  MOVF   FF3,W
55B6:  SUBWF  xC0,W
55B8:  MOVWF  xC2
....................  
....................    return((nibh<<4)|nibl); 
55BA:  SWAPF  xC1,W
55BC:  MOVWF  00
55BE:  MOVLW  F0
55C0:  ANDWF  00,F
55C2:  MOVF   00,W
55C4:  IORWF  xC2,W
55C6:  MOVWF  01
.................... } 
55C8:  MOVLB  0
55CA:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
539A:  MOVFF  7BF,7C0
....................    data=(i>>4)*10; 
539E:  MOVLB  7
53A0:  SWAPF  xC0,W
53A2:  MOVWF  00
53A4:  MOVLW  0F
53A6:  ANDWF  00,F
53A8:  MOVF   00,W
53AA:  MULLW  0A
53AC:  MOVFF  FF3,7BF
....................    data=data+(i<<4>>4); 
53B0:  SWAPF  xC0,W
53B2:  MOVWF  00
53B4:  MOVLW  F0
53B6:  ANDWF  00,F
53B8:  MOVF   00,W
53BA:  SWAPF  00,F
53BC:  MOVLW  0F
53BE:  ANDWF  00,F
53C0:  MOVF   00,W
53C2:  ADDWF  xBF,F
....................  
....................    return data; 
53C4:  MOVFF  7BF,01
.................... } 
53C8:  MOVLB  0
53CA:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
55CC:  MOVLB  7
55CE:  CLRF   xC1
55D0:  CLRF   xC2
55D2:  MOVLB  0
55D4:  RCALL  54E0
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
55D6:  MOVFF  7BF,7C0
55DA:  RCALL  558E
55DC:  MOVFF  01,7C0
55E0:  MOVLW  01
55E2:  MOVLB  7
55E4:  MOVWF  xC1
55E6:  MOVFF  01,7C2
55EA:  MOVLB  0
55EC:  RCALL  54E0
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
55EE:  MOVFF  7BE,7C0
55F2:  RCALL  558E
55F4:  MOVFF  01,7C0
55F8:  MOVLW  02
55FA:  MOVLB  7
55FC:  MOVWF  xC1
55FE:  MOVFF  01,7C2
5602:  MOVLB  0
5604:  RCALL  54E0
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
5606:  MOVFF  7BD,7C0
560A:  RCALL  558E
560C:  MOVFF  01,7C0
5610:  MOVLW  03
5612:  MOVLB  7
5614:  MOVWF  xC1
5616:  MOVFF  01,7C2
561A:  MOVLB  0
561C:  RCALL  54E0
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
561E:  MOVFF  7BA,7C0
5622:  RCALL  558E
5624:  MOVFF  01,7C0
5628:  MOVLW  04
562A:  MOVLB  7
562C:  MOVWF  xC1
562E:  MOVFF  01,7C2
5632:  MOVLB  0
5634:  RCALL  54E0
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
5636:  MOVFF  7BB,7C0
563A:  RCALL  558E
563C:  MOVFF  01,7C0
5640:  MOVLW  05
5642:  MOVLB  7
5644:  MOVWF  xC1
5646:  MOVFF  01,7C2
564A:  MOVLB  0
564C:  RCALL  54E0
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
564E:  MOVFF  7BC,7C0
5652:  RCALL  558E
5654:  MOVFF  01,7C0
5658:  MOVLW  06
565A:  MOVLB  7
565C:  MOVWF  xC1
565E:  MOVFF  01,7C2
5662:  MOVLB  0
5664:  RCALL  54E0
....................    write_DS1307(DS1307_CONTROL,0);    
5666:  MOVLW  07
5668:  MOVLB  7
566A:  MOVWF  xC1
566C:  CLRF   xC2
566E:  MOVLB  0
5670:  RCALL  54E0
.................... } 
5672:  GOTO   62B8 (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
5DF8:  MOVLW  04
5DFA:  MOVLB  7
5DFC:  MOVWF  xBE
5DFE:  MOVLB  0
5E00:  CALL   49FC
5E04:  MOVFF  01,7BA
5E08:  MOVFF  01,7BF
5E0C:  CALL   539A
5E10:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
5E14:  MOVLW  05
5E16:  MOVLB  7
5E18:  MOVWF  xBE
5E1A:  MOVLB  0
5E1C:  CALL   49FC
5E20:  MOVFF  01,7BA
5E24:  MOVFF  01,7BF
5E28:  CALL   539A
5E2C:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
5E30:  MOVLW  06
5E32:  MOVLB  7
5E34:  MOVWF  xBE
5E36:  MOVLB  0
5E38:  CALL   49FC
5E3C:  MOVFF  01,7BA
5E40:  MOVFF  01,7BF
5E44:  CALL   539A
5E48:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
5E4C:  MOVLW  03
5E4E:  MOVLB  7
5E50:  MOVWF  xBE
5E52:  MOVLB  0
5E54:  CALL   49FC
5E58:  MOVFF  01,7BA
5E5C:  MOVFF  01,7BF
5E60:  CALL   539A
5E64:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
5E68:  MOVLW  02
5E6A:  MOVLB  7
5E6C:  MOVWF  xBE
5E6E:  MOVLB  0
5E70:  CALL   49FC
5E74:  MOVFF  01,7BA
5E78:  MOVFF  01,7BF
5E7C:  CALL   539A
5E80:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
5E84:  MOVLW  01
5E86:  MOVLB  7
5E88:  MOVWF  xBE
5E8A:  MOVLB  0
5E8C:  CALL   49FC
5E90:  MOVFF  01,7BA
5E94:  MOVFF  01,7BF
5E98:  CALL   539A
5E9C:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
5EA0:  MOVLB  7
5EA2:  CLRF   xBE
5EA4:  MOVLB  0
5EA6:  CALL   49FC
5EAA:  MOVFF  01,7BA
5EAE:  MOVFF  01,7BF
5EB2:  CALL   539A
5EB6:  MOVFF  01,103
5EBA:  CLRF   19
5EBC:  BTFSC  FF2.7
5EBE:  BSF    19.7
5EC0:  BCF    FF2.7
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0,booting=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... int16 count_checking=10; 
.................... #include <scan_key.c> 
....................  
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... int8 type_KB=0; 
.................... #define key_numbyte  16 
....................  
.................... int8 key_data[key_numbyte]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
2294:  MOVLB  1
2296:  INCF   x25,F
2298:  MOVF   x25,W
229A:  SUBLW  01
229C:  BTFSC  FD8.0
229E:  BRA    2444
....................        switch (col) { 
22A0:  MOVF   x28,W
22A2:  ADDLW  FB
22A4:  BC    2328
22A6:  ADDLW  05
22A8:  MOVLB  0
22AA:  GOTO   244E
....................          case 0   :  
....................                     output_low(COL0); 
22AE:  BCF    F92.5
22B0:  BCF    F89.5
....................                     output_high(COL1); 
22B2:  BCF    F92.3
22B4:  BSF    F89.3
....................                     output_high(COL2); 
22B6:  BCF    F92.2
22B8:  BSF    F89.2
....................                     output_high(COL3); 
22BA:  BCF    F92.1
22BC:  BSF    F89.1
....................                     output_high(COL4); 
22BE:  BCF    F92.0
22C0:  BSF    F89.0
....................                     break; 
22C2:  MOVLB  1
22C4:  BRA    2328
....................          case 1   :  
....................                     output_low(COL1); 
22C6:  BCF    F92.3
22C8:  BCF    F89.3
....................                     output_high(COL0); 
22CA:  BCF    F92.5
22CC:  BSF    F89.5
....................                     output_high(COL2); 
22CE:  BCF    F92.2
22D0:  BSF    F89.2
....................                     output_high(COL3); 
22D2:  BCF    F92.1
22D4:  BSF    F89.1
....................                     output_high(COL4); 
22D6:  BCF    F92.0
22D8:  BSF    F89.0
....................                     break; 
22DA:  MOVLB  1
22DC:  BRA    2328
....................          case 2   :  
....................                     output_low(COL2); 
22DE:  BCF    F92.2
22E0:  BCF    F89.2
....................                     output_high(COL1); 
22E2:  BCF    F92.3
22E4:  BSF    F89.3
....................                     output_high(COL0); 
22E6:  BCF    F92.5
22E8:  BSF    F89.5
....................                     output_high(COL3); 
22EA:  BCF    F92.1
22EC:  BSF    F89.1
....................                     output_high(COL4); 
22EE:  BCF    F92.0
22F0:  BSF    F89.0
....................                     break; 
22F2:  MOVLB  1
22F4:  BRA    2328
....................          case 3   :  
....................                     output_low(COL3); 
22F6:  BCF    F92.1
22F8:  BCF    F89.1
....................                     output_high(COL1); 
22FA:  BCF    F92.3
22FC:  BSF    F89.3
....................                     output_high(COL2); 
22FE:  BCF    F92.2
2300:  BSF    F89.2
....................                     output_high(COL0); 
2302:  BCF    F92.5
2304:  BSF    F89.5
....................                     output_high(COL4); 
2306:  BCF    F92.0
2308:  BSF    F89.0
....................                     break; 
230A:  MOVLB  1
230C:  BRA    2328
....................          case 4   :  
....................                     output_low(COL4); 
230E:  BCF    F92.0
2310:  BCF    F89.0
....................                     output_high(COL1); 
2312:  BCF    F92.3
2314:  BSF    F89.3
....................                     output_high(COL2); 
2316:  BCF    F92.2
2318:  BSF    F89.2
....................                     output_high(COL3); 
231A:  BCF    F92.1
231C:  BSF    F89.1
....................                     output_high(COL0); 
231E:  BCF    F92.5
2320:  BSF    F89.5
....................                     break; 
2322:  MOVLB  1
2324:  BRA    2328
2326:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2328:  BTFSS  x26.0
232A:  BRA    23AA
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
232C:  BSF    F93.4
232E:  MOVLW  00
2330:  BTFSC  F81.4
2332:  MOVLW  01
2334:  MOVLB  7
2336:  MOVWF  xE8
2338:  BSF    F93.5
233A:  MOVLW  00
233C:  BTFSC  F81.5
233E:  MOVLW  01
2340:  ANDWF  xE8,F
2342:  BSF    F93.6
2344:  MOVLW  00
2346:  BTFSC  F81.6
2348:  MOVLW  01
234A:  ANDWF  xE8,F
234C:  BSF    F93.7
234E:  MOVLW  00
2350:  BTFSC  F81.7
2352:  MOVLW  01
2354:  ANDWF  xE8,W
2356:  BZ    23A6
....................          { 
....................             kchar=last_key; 
2358:  MOVFF  127,7E6
....................             if(keydebug_en==0) 
235C:  MOVLB  1
235E:  MOVF   x0B,F
2360:  BNZ   2394
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
2362:  CLRF   x09
2364:  CLRF   x08
....................               charac_timeout=0; 
2366:  MOVLB  0
2368:  CLRF   xFC
236A:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
236C:  MOVLB  1
236E:  MOVF   x0E,W
2370:  SUBLW  0F
2372:  BNC   2388
2374:  MOVF   x0E,W
2376:  INCF   x0E,F
2378:  CLRF   03
237A:  ADDLW  14
237C:  MOVWF  FE9
237E:  MOVLW  01
2380:  ADDWFC 03,W
2382:  MOVWF  FEA
2384:  MOVFF  7E6,FEF
....................                fputc(kchar,COM2); 
2388:  MOVFF  7E6,81A
238C:  MOVLB  0
238E:  CALL   0422
....................             } 
....................                else fputc(kchar,COM2); 
2392:  BRA    239E
2394:  MOVFF  7E6,81A
2398:  MOVLB  0
239A:  CALL   0422
....................            kbd_down=FALSE; 
239E:  MOVLB  1
23A0:  BCF    x26.0
....................            last_key=0; 
23A2:  CLRF   x27
23A4:  MOVLB  7
....................          } 
....................        } else 
23A6:  BRA    2440
23A8:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
23AA:  BSF    F93.4
23AC:  MOVLW  00
23AE:  BTFSC  F81.4
23B0:  MOVLW  01
23B2:  MOVLB  7
23B4:  MOVWF  xE8
23B6:  BSF    F93.5
23B8:  MOVLW  00
23BA:  BTFSC  F81.5
23BC:  MOVLW  01
23BE:  ANDWF  xE8,F
23C0:  BSF    F93.6
23C2:  MOVLW  00
23C4:  BTFSC  F81.6
23C6:  MOVLW  01
23C8:  ANDWF  xE8,F
23CA:  BSF    F93.7
23CC:  MOVLW  00
23CE:  BTFSC  F81.7
23D0:  MOVLW  01
23D2:  ANDWF  xE8,W
23D4:  BNZ   2434
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
23D6:  BSF    F93.4
23D8:  BTFSC  F81.4
23DA:  BRA    23E0
....................                   row=0; 
23DC:  CLRF   xE7
....................                 else if(input(ROW1)==0) 
23DE:  BRA    2402
23E0:  BSF    F93.5
23E2:  BTFSC  F81.5
23E4:  BRA    23EC
....................                   row=1; 
23E6:  MOVLW  01
23E8:  MOVWF  xE7
....................                 else if(input(ROW2)==0) 
23EA:  BRA    2402
23EC:  BSF    F93.6
23EE:  BTFSC  F81.6
23F0:  BRA    23F8
....................                   row=2; 
23F2:  MOVLW  02
23F4:  MOVWF  xE7
....................                 else if(input(ROW3)==0) 
23F6:  BRA    2402
23F8:  BSF    F93.7
23FA:  BTFSC  F81.7
23FC:  BRA    2402
....................                   row=3; 
23FE:  MOVLW  03
2400:  MOVWF  xE7
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
2402:  MOVF   xE7,W
2404:  MULLW  05
2406:  MOVF   FF3,W
2408:  CLRF   xE9
240A:  MOVWF  xE8
240C:  CLRF   03
240E:  MOVLB  1
2410:  MOVF   x28,W
2412:  MOVLB  7
2414:  ADDWF  xE8,W
2416:  MOVWF  01
2418:  MOVF   xE9,W
241A:  ADDWFC 03,F
241C:  MOVF   01,W
241E:  MOVLB  0
2420:  CALL   00D0
2424:  MOVFF  FE8,127
....................                 kbd_down = TRUE; 
2428:  MOVLB  1
242A:  BSF    x26.0
....................                 set_tris_a(0xff); 
242C:  MOVLW  FF
242E:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2430:  BRA    2440
2432:  MOVLB  7
....................                { 
....................                   ++col; 
2434:  MOVLB  1
2436:  INCF   x28,F
....................                   if(col==5) col=0; 
2438:  MOVF   x28,W
243A:  SUBLW  05
243C:  BTFSC  FD8.2
243E:  CLRF   x28
....................                } 
....................          } 
....................       kbd_call_count=0; 
2440:  MOVLB  1
2442:  CLRF   x25
....................    } 
....................   return(kchar); 
2444:  MOVLB  7
2446:  MOVFF  7E6,01
.................... } 
244A:  MOVLB  0
244C:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2472:  MOVLW  E0
2474:  MOVLB  F
2476:  MOVWF  x48
2478:  BCF    FC2.6
247A:  BCF    FC2.7
247C:  MOVF   x49,W
247E:  ANDLW  E0
2480:  IORLW  17
2482:  MOVWF  x49
....................    switch(col) 
....................    { 
2484:  MOVLB  8
2486:  MOVF   x0E,W
2488:  ADDLW  FA
248A:  BC    2556
248C:  ADDLW  06
248E:  MOVLB  0
2490:  GOTO   255A
....................       case 0: 
....................         set_adc_channel(4); 
2494:  MOVLW  10
2496:  MOVWF  01
2498:  MOVF   FC2,W
249A:  ANDLW  C3
249C:  IORWF  01,W
249E:  MOVWF  FC2
....................         adc=read_adc(); 
24A0:  BSF    FC2.1
24A2:  BTFSC  FC2.1
24A4:  BRA    24A2
24A6:  MOVFF  FC4,80F
....................         return adc; 
24AA:  MOVLB  8
24AC:  MOVFF  80F,01
24B0:  BRA    2556
....................       break; 
24B2:  BRA    2556
....................       case 1: 
....................         set_adc_channel(3); 
24B4:  MOVLW  0C
24B6:  MOVWF  01
24B8:  MOVF   FC2,W
24BA:  ANDLW  C3
24BC:  IORWF  01,W
24BE:  MOVWF  FC2
....................         adc=read_adc(); 
24C0:  BSF    FC2.1
24C2:  BTFSC  FC2.1
24C4:  BRA    24C2
24C6:  MOVFF  FC4,80F
....................         return adc; 
24CA:  MOVLB  8
24CC:  MOVFF  80F,01
24D0:  BRA    2556
....................       break; 
24D2:  BRA    2556
....................       case 2: 
....................         set_adc_channel(2); 
24D4:  MOVLW  08
24D6:  MOVWF  01
24D8:  MOVF   FC2,W
24DA:  ANDLW  C3
24DC:  IORWF  01,W
24DE:  MOVWF  FC2
....................         adc=read_adc(); 
24E0:  BSF    FC2.1
24E2:  BTFSC  FC2.1
24E4:  BRA    24E2
24E6:  MOVFF  FC4,80F
....................         return adc; 
24EA:  MOVLB  8
24EC:  MOVFF  80F,01
24F0:  BRA    2556
....................       break; 
24F2:  BRA    2556
....................       case 3: 
....................         set_adc_channel(1); 
24F4:  MOVLW  04
24F6:  MOVWF  01
24F8:  MOVF   FC2,W
24FA:  ANDLW  C3
24FC:  IORWF  01,W
24FE:  MOVWF  FC2
....................         adc=read_adc(); 
2500:  BSF    FC2.1
2502:  BTFSC  FC2.1
2504:  BRA    2502
2506:  MOVFF  FC4,80F
....................         return adc; 
250A:  MOVLB  8
250C:  MOVFF  80F,01
2510:  BRA    2556
....................       break; 
2512:  BRA    2556
....................       case 4: 
....................         set_adc_channel(0); 
2514:  MOVLW  00
2516:  MOVWF  01
2518:  MOVF   FC2,W
251A:  ANDLW  C3
251C:  IORWF  01,W
251E:  MOVWF  FC2
....................         adc=read_adc(); 
2520:  BSF    FC2.1
2522:  BTFSC  FC2.1
2524:  BRA    2522
2526:  MOVFF  FC4,80F
....................         return adc; 
252A:  MOVLB  8
252C:  MOVFF  80F,01
2530:  BRA    2556
....................       break;      
2532:  BRA    2556
....................       case 5: 
....................         set_adc_channel(11); 
2534:  MOVLW  2C
2536:  MOVWF  01
2538:  MOVF   FC2,W
253A:  ANDLW  C3
253C:  IORWF  01,W
253E:  MOVWF  FC2
....................         adc=read_adc(); 
2540:  BSF    FC2.1
2542:  BTFSC  FC2.1
2544:  BRA    2542
2546:  MOVFF  FC4,80F
....................         return adc; 
254A:  MOVLB  8
254C:  MOVFF  80F,01
2550:  BRA    2556
....................       break;      
2552:  BRA    2556
2554:  MOVLB  8
....................    } 
.................... } 
2556:  MOVLB  0
2558:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
26D4:  MOVLB  7
26D6:  CLRF   xEE
26D8:  CLRF   xED
26DA:  CLRF   xEC
26DC:  CLRF   xEB
26DE:  CLRF   xF2
26E0:  CLRF   xF1
26E2:  CLRF   xF0
26E4:  CLRF   xEF
26E6:  CLRF   xF6
26E8:  CLRF   xF5
26EA:  CLRF   xF4
26EC:  CLRF   xF3
26EE:  CLRF   xFA
26F0:  CLRF   xF9
26F2:  CLRF   xF8
26F4:  CLRF   xF7
26F6:  CLRF   xFE
26F8:  CLRF   xFD
26FA:  CLRF   xFC
26FC:  CLRF   xFB
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
26FE:  CLRF   xEA
2700:  CLRF   xE9
2702:  MOVF   xEA,W
2704:  SUBLW  01
2706:  BNC   278E
2708:  BNZ   2710
270A:  MOVF   xE9,W
270C:  SUBLW  F3
270E:  BNC   278E
....................    { 
....................       col_0=read_col(0)+col_0; 
2710:  MOVLB  8
2712:  CLRF   x0E
2714:  MOVLB  0
2716:  RCALL  2472
2718:  MOVF   01,W
271A:  MOVLB  7
271C:  ADDWF  xEB,F
271E:  MOVLW  00
2720:  ADDWFC xEC,F
2722:  ADDWFC xED,F
2724:  ADDWFC xEE,F
....................       col_1=read_col(1)+col_1; 
2726:  MOVLW  01
2728:  MOVLB  8
272A:  MOVWF  x0E
272C:  MOVLB  0
272E:  RCALL  2472
2730:  MOVF   01,W
2732:  MOVLB  7
2734:  ADDWF  xEF,F
2736:  MOVLW  00
2738:  ADDWFC xF0,F
273A:  ADDWFC xF1,F
273C:  ADDWFC xF2,F
....................       col_2=read_col(2)+col_2; 
273E:  MOVLW  02
2740:  MOVLB  8
2742:  MOVWF  x0E
2744:  MOVLB  0
2746:  RCALL  2472
2748:  MOVF   01,W
274A:  MOVLB  7
274C:  ADDWF  xF3,F
274E:  MOVLW  00
2750:  ADDWFC xF4,F
2752:  ADDWFC xF5,F
2754:  ADDWFC xF6,F
....................       col_3=read_col(3)+col_3; 
2756:  MOVLW  03
2758:  MOVLB  8
275A:  MOVWF  x0E
275C:  MOVLB  0
275E:  RCALL  2472
2760:  MOVF   01,W
2762:  MOVLB  7
2764:  ADDWF  xF7,F
2766:  MOVLW  00
2768:  ADDWFC xF8,F
276A:  ADDWFC xF9,F
276C:  ADDWFC xFA,F
....................       col_4=read_col(4)+col_4; 
276E:  MOVLW  04
2770:  MOVLB  8
2772:  MOVWF  x0E
2774:  MOVLB  0
2776:  RCALL  2472
2778:  MOVF   01,W
277A:  MOVLB  7
277C:  ADDWF  xFB,F
277E:  MOVLW  00
2780:  ADDWFC xFC,F
2782:  ADDWFC xFD,F
2784:  ADDWFC xFE,F
....................    } 
2786:  INCF   xE9,F
2788:  BTFSC  FD8.2
278A:  INCF   xEA,F
278C:  BRA    2702
....................    col_0=col_0/500; 
278E:  BCF    FD8.1
2790:  MOVFF  7EE,81D
2794:  MOVFF  7ED,81C
2798:  MOVFF  7EC,81B
279C:  MOVFF  7EB,81A
27A0:  MOVLB  8
27A2:  CLRF   x21
27A4:  CLRF   x20
27A6:  MOVLW  01
27A8:  MOVWF  x1F
27AA:  MOVLW  F4
27AC:  MOVWF  x1E
27AE:  MOVLB  0
27B0:  RCALL  2580
27B2:  MOVFF  03,7EE
27B6:  MOVFF  02,7ED
27BA:  MOVFF  01,7EC
27BE:  MOVFF  00,7EB
....................    col_1=col_1/500; 
27C2:  BCF    FD8.1
27C4:  MOVFF  7F2,81D
27C8:  MOVFF  7F1,81C
27CC:  MOVFF  7F0,81B
27D0:  MOVFF  7EF,81A
27D4:  MOVLB  8
27D6:  CLRF   x21
27D8:  CLRF   x20
27DA:  MOVLW  01
27DC:  MOVWF  x1F
27DE:  MOVLW  F4
27E0:  MOVWF  x1E
27E2:  MOVLB  0
27E4:  RCALL  2580
27E6:  MOVFF  03,7F2
27EA:  MOVFF  02,7F1
27EE:  MOVFF  01,7F0
27F2:  MOVFF  00,7EF
....................    col_2=col_2/500; 
27F6:  BCF    FD8.1
27F8:  MOVFF  7F6,81D
27FC:  MOVFF  7F5,81C
2800:  MOVFF  7F4,81B
2804:  MOVFF  7F3,81A
2808:  MOVLB  8
280A:  CLRF   x21
280C:  CLRF   x20
280E:  MOVLW  01
2810:  MOVWF  x1F
2812:  MOVLW  F4
2814:  MOVWF  x1E
2816:  MOVLB  0
2818:  RCALL  2580
281A:  MOVFF  03,7F6
281E:  MOVFF  02,7F5
2822:  MOVFF  01,7F4
2826:  MOVFF  00,7F3
....................    col_3=col_3/500; 
282A:  BCF    FD8.1
282C:  MOVFF  7FA,81D
2830:  MOVFF  7F9,81C
2834:  MOVFF  7F8,81B
2838:  MOVFF  7F7,81A
283C:  MOVLB  8
283E:  CLRF   x21
2840:  CLRF   x20
2842:  MOVLW  01
2844:  MOVWF  x1F
2846:  MOVLW  F4
2848:  MOVWF  x1E
284A:  MOVLB  0
284C:  RCALL  2580
284E:  MOVFF  03,7FA
2852:  MOVFF  02,7F9
2856:  MOVFF  01,7F8
285A:  MOVFF  00,7F7
....................    col_4=col_4/500; 
285E:  BCF    FD8.1
2860:  MOVFF  7FE,81D
2864:  MOVFF  7FD,81C
2868:  MOVFF  7FC,81B
286C:  MOVFF  7FB,81A
2870:  MOVLB  8
2872:  CLRF   x21
2874:  CLRF   x20
2876:  MOVLW  01
2878:  MOVWF  x1F
287A:  MOVLW  F4
287C:  MOVWF  x1E
287E:  MOVLB  0
2880:  RCALL  2580
2882:  MOVFF  03,7FE
2886:  MOVFF  02,7FD
288A:  MOVFF  01,7FC
288E:  MOVFF  00,7FB
....................    if(keydebug_en) 
2892:  MOVLB  1
2894:  MOVF   x0B,F
2896:  BTFSC  FD8.2
2898:  BRA    2A14
....................    { 
....................       fprintf(COM2,"\r\n");      
289A:  MOVLW  0D
289C:  MOVLB  8
289E:  MOVWF  x1A
28A0:  MOVLB  0
28A2:  CALL   0422
28A6:  MOVLW  0A
28A8:  MOVLB  8
28AA:  MOVWF  x1A
28AC:  MOVLB  0
28AE:  CALL   0422
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
28B2:  MOVLW  7E
28B4:  MOVWF  FF6
28B6:  MOVLW  02
28B8:  MOVWF  FF7
28BA:  MOVLW  07
28BC:  MOVLB  8
28BE:  MOVWF  x0E
28C0:  MOVLB  0
28C2:  CALL   1864
28C6:  MOVLW  41
28C8:  MOVWF  FE9
28CA:  MOVFF  7EE,811
28CE:  MOVFF  7ED,810
28D2:  MOVFF  7EC,80F
28D6:  MOVFF  7EB,80E
28DA:  RCALL  2614
28DC:  MOVLW  0D
28DE:  MOVLB  8
28E0:  MOVWF  x1A
28E2:  MOVLB  0
28E4:  CALL   0422
28E8:  MOVLW  0A
28EA:  MOVLB  8
28EC:  MOVWF  x1A
28EE:  MOVLB  0
28F0:  CALL   0422
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
28F4:  MOVLW  8C
28F6:  MOVWF  FF6
28F8:  MOVLW  02
28FA:  MOVWF  FF7
28FC:  MOVLW  07
28FE:  MOVLB  8
2900:  MOVWF  x0E
2902:  MOVLB  0
2904:  CALL   1864
2908:  MOVLW  41
290A:  MOVWF  FE9
290C:  MOVFF  7F2,811
2910:  MOVFF  7F1,810
2914:  MOVFF  7F0,80F
2918:  MOVFF  7EF,80E
291C:  RCALL  2614
291E:  MOVLW  0D
2920:  MOVLB  8
2922:  MOVWF  x1A
2924:  MOVLB  0
2926:  CALL   0422
292A:  MOVLW  0A
292C:  MOVLB  8
292E:  MOVWF  x1A
2930:  MOVLB  0
2932:  CALL   0422
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2936:  MOVLW  9A
2938:  MOVWF  FF6
293A:  MOVLW  02
293C:  MOVWF  FF7
293E:  MOVLW  07
2940:  MOVLB  8
2942:  MOVWF  x0E
2944:  MOVLB  0
2946:  CALL   1864
294A:  MOVLW  41
294C:  MOVWF  FE9
294E:  MOVFF  7F6,811
2952:  MOVFF  7F5,810
2956:  MOVFF  7F4,80F
295A:  MOVFF  7F3,80E
295E:  RCALL  2614
2960:  MOVLW  0D
2962:  MOVLB  8
2964:  MOVWF  x1A
2966:  MOVLB  0
2968:  CALL   0422
296C:  MOVLW  0A
296E:  MOVLB  8
2970:  MOVWF  x1A
2972:  MOVLB  0
2974:  CALL   0422
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2978:  MOVLW  A8
297A:  MOVWF  FF6
297C:  MOVLW  02
297E:  MOVWF  FF7
2980:  MOVLW  07
2982:  MOVLB  8
2984:  MOVWF  x0E
2986:  MOVLB  0
2988:  CALL   1864
298C:  MOVLW  41
298E:  MOVWF  FE9
2990:  MOVFF  7FA,811
2994:  MOVFF  7F9,810
2998:  MOVFF  7F8,80F
299C:  MOVFF  7F7,80E
29A0:  RCALL  2614
29A2:  MOVLW  0D
29A4:  MOVLB  8
29A6:  MOVWF  x1A
29A8:  MOVLB  0
29AA:  CALL   0422
29AE:  MOVLW  0A
29B0:  MOVLB  8
29B2:  MOVWF  x1A
29B4:  MOVLB  0
29B6:  CALL   0422
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
29BA:  MOVLW  B6
29BC:  MOVWF  FF6
29BE:  MOVLW  02
29C0:  MOVWF  FF7
29C2:  MOVLW  07
29C4:  MOVLB  8
29C6:  MOVWF  x0E
29C8:  MOVLB  0
29CA:  CALL   1864
29CE:  MOVLW  41
29D0:  MOVWF  FE9
29D2:  MOVFF  7FE,811
29D6:  MOVFF  7FD,810
29DA:  MOVFF  7FC,80F
29DE:  MOVFF  7FB,80E
29E2:  RCALL  2614
29E4:  MOVLW  0D
29E6:  MOVLB  8
29E8:  MOVWF  x1A
29EA:  MOVLB  0
29EC:  CALL   0422
29F0:  MOVLW  0A
29F2:  MOVLB  8
29F4:  MOVWF  x1A
29F6:  MOVLB  0
29F8:  CALL   0422
....................       fprintf(COM2,"\r\n"); 
29FC:  MOVLW  0D
29FE:  MOVLB  8
2A00:  MOVWF  x1A
2A02:  MOVLB  0
2A04:  CALL   0422
2A08:  MOVLW  0A
2A0A:  MOVLB  8
2A0C:  MOVWF  x1A
2A0E:  MOVLB  0
2A10:  CALL   0422
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
2A14:  MOVLB  7
2A16:  MOVF   xEE,F
2A18:  BNZ   2A28
2A1A:  MOVF   xED,F
2A1C:  BNZ   2A28
2A1E:  MOVF   xEC,F
2A20:  BNZ   2A28
2A22:  MOVF   xEB,W
2A24:  SUBLW  05
2A26:  BC    2A88
2A28:  MOVF   xEE,F
2A2A:  BNZ   2A88
2A2C:  MOVF   xED,F
2A2E:  BNZ   2A88
2A30:  MOVF   xEC,F
2A32:  BNZ   2A88
2A34:  MOVF   xEB,W
2A36:  SUBLW  3B
2A38:  BNC   2A88
2A3A:  MOVF   xF2,F
2A3C:  BNZ   2A4C
2A3E:  MOVF   xF1,F
2A40:  BNZ   2A4C
2A42:  MOVF   xF0,F
2A44:  BNZ   2A4C
2A46:  MOVF   xEF,W
2A48:  SUBLW  64
2A4A:  BC    2A88
2A4C:  MOVF   xF6,F
2A4E:  BNZ   2A5E
2A50:  MOVF   xF5,F
2A52:  BNZ   2A5E
2A54:  MOVF   xF4,F
2A56:  BNZ   2A5E
2A58:  MOVF   xF3,W
2A5A:  SUBLW  64
2A5C:  BC    2A88
2A5E:  MOVF   xFA,F
2A60:  BNZ   2A70
2A62:  MOVF   xF9,F
2A64:  BNZ   2A70
2A66:  MOVF   xF8,F
2A68:  BNZ   2A70
2A6A:  MOVF   xF7,W
2A6C:  SUBLW  64
2A6E:  BC    2A88
2A70:  MOVF   xFE,F
2A72:  BNZ   2A82
2A74:  MOVF   xFD,F
2A76:  BNZ   2A82
2A78:  MOVF   xFC,F
2A7A:  BNZ   2A82
2A7C:  MOVF   xFB,W
2A7E:  SUBLW  64
2A80:  BC    2A88
2A82:  MOVLW  00
2A84:  MOVWF  01
2A86:  BRA    2D06
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
2A88:  MOVF   xF2,F
2A8A:  BNZ   2A9A
2A8C:  MOVF   xF1,F
2A8E:  BNZ   2A9A
2A90:  MOVF   xF0,F
2A92:  BNZ   2A9A
2A94:  MOVF   xEF,W
2A96:  SUBLW  05
2A98:  BC    2AFA
2A9A:  MOVF   xF2,F
2A9C:  BNZ   2AFA
2A9E:  MOVF   xF1,F
2AA0:  BNZ   2AFA
2AA2:  MOVF   xF0,F
2AA4:  BNZ   2AFA
2AA6:  MOVF   xEF,W
2AA8:  SUBLW  3B
2AAA:  BNC   2AFA
2AAC:  MOVF   xEE,F
2AAE:  BNZ   2ABE
2AB0:  MOVF   xED,F
2AB2:  BNZ   2ABE
2AB4:  MOVF   xEC,F
2AB6:  BNZ   2ABE
2AB8:  MOVF   xEB,W
2ABA:  SUBLW  64
2ABC:  BC    2AFA
2ABE:  MOVF   xF6,F
2AC0:  BNZ   2AD0
2AC2:  MOVF   xF5,F
2AC4:  BNZ   2AD0
2AC6:  MOVF   xF4,F
2AC8:  BNZ   2AD0
2ACA:  MOVF   xF3,W
2ACC:  SUBLW  64
2ACE:  BC    2AFA
2AD0:  MOVF   xFA,F
2AD2:  BNZ   2AE2
2AD4:  MOVF   xF9,F
2AD6:  BNZ   2AE2
2AD8:  MOVF   xF8,F
2ADA:  BNZ   2AE2
2ADC:  MOVF   xF7,W
2ADE:  SUBLW  64
2AE0:  BC    2AFA
2AE2:  MOVF   xFE,F
2AE4:  BNZ   2AF4
2AE6:  MOVF   xFD,F
2AE8:  BNZ   2AF4
2AEA:  MOVF   xFC,F
2AEC:  BNZ   2AF4
2AEE:  MOVF   xFB,W
2AF0:  SUBLW  64
2AF2:  BC    2AFA
2AF4:  MOVLW  01
2AF6:  MOVWF  01
2AF8:  BRA    2D06
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
2AFA:  MOVF   xF6,F
2AFC:  BNZ   2B0C
2AFE:  MOVF   xF5,F
2B00:  BNZ   2B0C
2B02:  MOVF   xF4,F
2B04:  BNZ   2B0C
2B06:  MOVF   xF3,W
2B08:  SUBLW  05
2B0A:  BC    2B6C
2B0C:  MOVF   xF6,F
2B0E:  BNZ   2B6C
2B10:  MOVF   xF5,F
2B12:  BNZ   2B6C
2B14:  MOVF   xF4,F
2B16:  BNZ   2B6C
2B18:  MOVF   xF3,W
2B1A:  SUBLW  3B
2B1C:  BNC   2B6C
2B1E:  MOVF   xF2,F
2B20:  BNZ   2B30
2B22:  MOVF   xF1,F
2B24:  BNZ   2B30
2B26:  MOVF   xF0,F
2B28:  BNZ   2B30
2B2A:  MOVF   xEF,W
2B2C:  SUBLW  64
2B2E:  BC    2B6C
2B30:  MOVF   xEE,F
2B32:  BNZ   2B42
2B34:  MOVF   xED,F
2B36:  BNZ   2B42
2B38:  MOVF   xEC,F
2B3A:  BNZ   2B42
2B3C:  MOVF   xEB,W
2B3E:  SUBLW  64
2B40:  BC    2B6C
2B42:  MOVF   xFA,F
2B44:  BNZ   2B54
2B46:  MOVF   xF9,F
2B48:  BNZ   2B54
2B4A:  MOVF   xF8,F
2B4C:  BNZ   2B54
2B4E:  MOVF   xF7,W
2B50:  SUBLW  64
2B52:  BC    2B6C
2B54:  MOVF   xFE,F
2B56:  BNZ   2B66
2B58:  MOVF   xFD,F
2B5A:  BNZ   2B66
2B5C:  MOVF   xFC,F
2B5E:  BNZ   2B66
2B60:  MOVF   xFB,W
2B62:  SUBLW  64
2B64:  BC    2B6C
2B66:  MOVLW  02
2B68:  MOVWF  01
2B6A:  BRA    2D06
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2B6C:  MOVF   xFA,F
2B6E:  BNZ   2B7E
2B70:  MOVF   xF9,F
2B72:  BNZ   2B7E
2B74:  MOVF   xF8,F
2B76:  BNZ   2B7E
2B78:  MOVF   xF7,W
2B7A:  SUBLW  05
2B7C:  BC    2BDE
2B7E:  MOVF   xFA,F
2B80:  BNZ   2BDE
2B82:  MOVF   xF9,F
2B84:  BNZ   2BDE
2B86:  MOVF   xF8,F
2B88:  BNZ   2BDE
2B8A:  MOVF   xF7,W
2B8C:  SUBLW  3B
2B8E:  BNC   2BDE
2B90:  MOVF   xF2,F
2B92:  BNZ   2BA2
2B94:  MOVF   xF1,F
2B96:  BNZ   2BA2
2B98:  MOVF   xF0,F
2B9A:  BNZ   2BA2
2B9C:  MOVF   xEF,W
2B9E:  SUBLW  64
2BA0:  BC    2BDE
2BA2:  MOVF   xF6,F
2BA4:  BNZ   2BB4
2BA6:  MOVF   xF5,F
2BA8:  BNZ   2BB4
2BAA:  MOVF   xF4,F
2BAC:  BNZ   2BB4
2BAE:  MOVF   xF3,W
2BB0:  SUBLW  64
2BB2:  BC    2BDE
2BB4:  MOVF   xEE,F
2BB6:  BNZ   2BC6
2BB8:  MOVF   xED,F
2BBA:  BNZ   2BC6
2BBC:  MOVF   xEC,F
2BBE:  BNZ   2BC6
2BC0:  MOVF   xEB,W
2BC2:  SUBLW  64
2BC4:  BC    2BDE
2BC6:  MOVF   xFE,F
2BC8:  BNZ   2BD8
2BCA:  MOVF   xFD,F
2BCC:  BNZ   2BD8
2BCE:  MOVF   xFC,F
2BD0:  BNZ   2BD8
2BD2:  MOVF   xFB,W
2BD4:  SUBLW  64
2BD6:  BC    2BDE
2BD8:  MOVLW  03
2BDA:  MOVWF  01
2BDC:  BRA    2D06
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2BDE:  MOVF   xFE,F
2BE0:  BNZ   2BF0
2BE2:  MOVF   xFD,F
2BE4:  BNZ   2BF0
2BE6:  MOVF   xFC,F
2BE8:  BNZ   2BF0
2BEA:  MOVF   xFB,W
2BEC:  SUBLW  05
2BEE:  BC    2C50
2BF0:  MOVF   xFE,F
2BF2:  BNZ   2C50
2BF4:  MOVF   xFD,F
2BF6:  BNZ   2C50
2BF8:  MOVF   xFC,F
2BFA:  BNZ   2C50
2BFC:  MOVF   xFB,W
2BFE:  SUBLW  3B
2C00:  BNC   2C50
2C02:  MOVF   xF2,F
2C04:  BNZ   2C14
2C06:  MOVF   xF1,F
2C08:  BNZ   2C14
2C0A:  MOVF   xF0,F
2C0C:  BNZ   2C14
2C0E:  MOVF   xEF,W
2C10:  SUBLW  64
2C12:  BC    2C50
2C14:  MOVF   xF6,F
2C16:  BNZ   2C26
2C18:  MOVF   xF5,F
2C1A:  BNZ   2C26
2C1C:  MOVF   xF4,F
2C1E:  BNZ   2C26
2C20:  MOVF   xF3,W
2C22:  SUBLW  64
2C24:  BC    2C50
2C26:  MOVF   xFA,F
2C28:  BNZ   2C38
2C2A:  MOVF   xF9,F
2C2C:  BNZ   2C38
2C2E:  MOVF   xF8,F
2C30:  BNZ   2C38
2C32:  MOVF   xF7,W
2C34:  SUBLW  64
2C36:  BC    2C50
2C38:  MOVF   xEE,F
2C3A:  BNZ   2C4A
2C3C:  MOVF   xED,F
2C3E:  BNZ   2C4A
2C40:  MOVF   xEC,F
2C42:  BNZ   2C4A
2C44:  MOVF   xEB,W
2C46:  SUBLW  64
2C48:  BC    2C50
2C4A:  MOVLW  04
2C4C:  MOVWF  01
2C4E:  BRA    2D06
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2C50:  MOVF   xFE,F
2C52:  BNZ   2C64
2C54:  MOVF   xFD,F
2C56:  BNZ   2C64
2C58:  MOVF   xFC,F
2C5A:  BNZ   2C64
2C5C:  MOVF   xFB,W
2C5E:  SUBLW  C8
2C60:  BTFSC  FD8.0
2C62:  BRA    2D02
2C64:  MOVF   xEE,F
2C66:  BTFSS  FD8.2
2C68:  BRA    2D02
2C6A:  MOVF   xED,F
2C6C:  BTFSS  FD8.2
2C6E:  BRA    2D02
2C70:  MOVF   xEC,F
2C72:  BTFSS  FD8.2
2C74:  BRA    2D02
2C76:  MOVF   xEB,W
2C78:  SUBLW  B3
2C7A:  BNC   2D02
2C7C:  MOVF   xEE,F
2C7E:  BNZ   2C8E
2C80:  MOVF   xED,F
2C82:  BNZ   2C8E
2C84:  MOVF   xEC,F
2C86:  BNZ   2C8E
2C88:  MOVF   xEB,W
2C8A:  SUBLW  64
2C8C:  BC    2D02
2C8E:  MOVF   xF2,F
2C90:  BNZ   2D02
2C92:  MOVF   xF1,F
2C94:  BNZ   2D02
2C96:  MOVF   xF0,F
2C98:  BNZ   2D02
2C9A:  MOVF   xEF,W
2C9C:  SUBLW  B3
2C9E:  BNC   2D02
2CA0:  MOVF   xF2,F
2CA2:  BNZ   2CB2
2CA4:  MOVF   xF1,F
2CA6:  BNZ   2CB2
2CA8:  MOVF   xF0,F
2CAA:  BNZ   2CB2
2CAC:  MOVF   xEF,W
2CAE:  SUBLW  64
2CB0:  BC    2D02
2CB2:  MOVF   xF6,F
2CB4:  BNZ   2D02
2CB6:  MOVF   xF5,F
2CB8:  BNZ   2D02
2CBA:  MOVF   xF4,F
2CBC:  BNZ   2D02
2CBE:  MOVF   xF3,W
2CC0:  SUBLW  B3
2CC2:  BNC   2D02
2CC4:  MOVF   xF6,F
2CC6:  BNZ   2CD6
2CC8:  MOVF   xF5,F
2CCA:  BNZ   2CD6
2CCC:  MOVF   xF4,F
2CCE:  BNZ   2CD6
2CD0:  MOVF   xF3,W
2CD2:  SUBLW  64
2CD4:  BC    2D02
2CD6:  MOVF   xFA,F
2CD8:  BNZ   2D02
2CDA:  MOVF   xF9,F
2CDC:  BNZ   2D02
2CDE:  MOVF   xF8,F
2CE0:  BNZ   2D02
2CE2:  MOVF   xF7,W
2CE4:  SUBLW  B3
2CE6:  BNC   2D02
2CE8:  MOVF   xFA,F
2CEA:  BNZ   2CFA
2CEC:  MOVF   xF9,F
2CEE:  BNZ   2CFA
2CF0:  MOVF   xF8,F
2CF2:  BNZ   2CFA
2CF4:  MOVF   xF7,W
2CF6:  SUBLW  64
2CF8:  BC    2D02
2CFA:  MOVLW  04
2CFC:  MOVWF  01
2CFE:  BRA    2D06
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2D00:  BRA    2D06
2D02:  MOVLW  FF
2D04:  MOVWF  01
.................... } 
2D06:  MOVLB  0
2D08:  GOTO   35C0 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
2D0C:  MOVLB  7
2D0E:  CLRF   xEE
2D10:  CLRF   xED
2D12:  CLRF   xEC
2D14:  CLRF   xEB
2D16:  CLRF   xF2
2D18:  CLRF   xF1
2D1A:  CLRF   xF0
2D1C:  CLRF   xEF
2D1E:  CLRF   xF6
2D20:  CLRF   xF5
2D22:  CLRF   xF4
2D24:  CLRF   xF3
2D26:  CLRF   xFA
2D28:  CLRF   xF9
2D2A:  CLRF   xF8
2D2C:  CLRF   xF7
2D2E:  CLRF   xFE
2D30:  CLRF   xFD
2D32:  CLRF   xFC
2D34:  CLRF   xFB
2D36:  MOVLB  8
2D38:  CLRF   x02
2D3A:  CLRF   x01
2D3C:  CLRF   x00
2D3E:  MOVLB  7
2D40:  CLRF   xFF
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2D42:  CLRF   xEA
2D44:  CLRF   xE9
2D46:  MOVF   xEA,W
2D48:  SUBLW  01
2D4A:  BNC   2DFA
2D4C:  BNZ   2D54
2D4E:  MOVF   xE9,W
2D50:  SUBLW  F3
2D52:  BNC   2DFA
....................    { 
....................       col_0=read_col(0)+col_0; 
2D54:  MOVLB  8
2D56:  CLRF   x0E
2D58:  MOVLB  0
2D5A:  CALL   2472
2D5E:  MOVF   01,W
2D60:  MOVLB  7
2D62:  ADDWF  xEB,F
2D64:  MOVLW  00
2D66:  ADDWFC xEC,F
2D68:  ADDWFC xED,F
2D6A:  ADDWFC xEE,F
....................       col_1=read_col(1)+col_1; 
2D6C:  MOVLW  01
2D6E:  MOVLB  8
2D70:  MOVWF  x0E
2D72:  MOVLB  0
2D74:  CALL   2472
2D78:  MOVF   01,W
2D7A:  MOVLB  7
2D7C:  ADDWF  xEF,F
2D7E:  MOVLW  00
2D80:  ADDWFC xF0,F
2D82:  ADDWFC xF1,F
2D84:  ADDWFC xF2,F
....................       col_2=read_col(2)+col_2; 
2D86:  MOVLW  02
2D88:  MOVLB  8
2D8A:  MOVWF  x0E
2D8C:  MOVLB  0
2D8E:  CALL   2472
2D92:  MOVF   01,W
2D94:  MOVLB  7
2D96:  ADDWF  xF3,F
2D98:  MOVLW  00
2D9A:  ADDWFC xF4,F
2D9C:  ADDWFC xF5,F
2D9E:  ADDWFC xF6,F
....................       col_3=read_col(3)+col_3; 
2DA0:  MOVLW  03
2DA2:  MOVLB  8
2DA4:  MOVWF  x0E
2DA6:  MOVLB  0
2DA8:  CALL   2472
2DAC:  MOVF   01,W
2DAE:  MOVLB  7
2DB0:  ADDWF  xF7,F
2DB2:  MOVLW  00
2DB4:  ADDWFC xF8,F
2DB6:  ADDWFC xF9,F
2DB8:  ADDWFC xFA,F
....................       col_4=read_col(4)+col_4; 
2DBA:  MOVLW  04
2DBC:  MOVLB  8
2DBE:  MOVWF  x0E
2DC0:  MOVLB  0
2DC2:  CALL   2472
2DC6:  MOVF   01,W
2DC8:  MOVLB  7
2DCA:  ADDWF  xFB,F
2DCC:  MOVLW  00
2DCE:  ADDWFC xFC,F
2DD0:  ADDWFC xFD,F
2DD2:  ADDWFC xFE,F
....................       col_5=read_col(5)+col_5; 
2DD4:  MOVLW  05
2DD6:  MOVLB  8
2DD8:  MOVWF  x0E
2DDA:  MOVLB  0
2DDC:  CALL   2472
2DE0:  MOVF   01,W
2DE2:  MOVLB  7
2DE4:  ADDWF  xFF,F
2DE6:  MOVLW  00
2DE8:  MOVLB  8
2DEA:  ADDWFC x00,F
2DEC:  ADDWFC x01,F
2DEE:  ADDWFC x02,F
....................    } 
2DF0:  MOVLB  7
2DF2:  INCF   xE9,F
2DF4:  BTFSC  FD8.2
2DF6:  INCF   xEA,F
2DF8:  BRA    2D46
....................    col_0=col_0/500; 
2DFA:  BCF    FD8.1
2DFC:  MOVFF  7EE,81D
2E00:  MOVFF  7ED,81C
2E04:  MOVFF  7EC,81B
2E08:  MOVFF  7EB,81A
2E0C:  MOVLB  8
2E0E:  CLRF   x21
2E10:  CLRF   x20
2E12:  MOVLW  01
2E14:  MOVWF  x1F
2E16:  MOVLW  F4
2E18:  MOVWF  x1E
2E1A:  MOVLB  0
2E1C:  CALL   2580
2E20:  MOVFF  03,7EE
2E24:  MOVFF  02,7ED
2E28:  MOVFF  01,7EC
2E2C:  MOVFF  00,7EB
....................    col_1=col_1/500; 
2E30:  BCF    FD8.1
2E32:  MOVFF  7F2,81D
2E36:  MOVFF  7F1,81C
2E3A:  MOVFF  7F0,81B
2E3E:  MOVFF  7EF,81A
2E42:  MOVLB  8
2E44:  CLRF   x21
2E46:  CLRF   x20
2E48:  MOVLW  01
2E4A:  MOVWF  x1F
2E4C:  MOVLW  F4
2E4E:  MOVWF  x1E
2E50:  MOVLB  0
2E52:  CALL   2580
2E56:  MOVFF  03,7F2
2E5A:  MOVFF  02,7F1
2E5E:  MOVFF  01,7F0
2E62:  MOVFF  00,7EF
....................    col_2=col_2/500; 
2E66:  BCF    FD8.1
2E68:  MOVFF  7F6,81D
2E6C:  MOVFF  7F5,81C
2E70:  MOVFF  7F4,81B
2E74:  MOVFF  7F3,81A
2E78:  MOVLB  8
2E7A:  CLRF   x21
2E7C:  CLRF   x20
2E7E:  MOVLW  01
2E80:  MOVWF  x1F
2E82:  MOVLW  F4
2E84:  MOVWF  x1E
2E86:  MOVLB  0
2E88:  CALL   2580
2E8C:  MOVFF  03,7F6
2E90:  MOVFF  02,7F5
2E94:  MOVFF  01,7F4
2E98:  MOVFF  00,7F3
....................    col_3=col_3/500; 
2E9C:  BCF    FD8.1
2E9E:  MOVFF  7FA,81D
2EA2:  MOVFF  7F9,81C
2EA6:  MOVFF  7F8,81B
2EAA:  MOVFF  7F7,81A
2EAE:  MOVLB  8
2EB0:  CLRF   x21
2EB2:  CLRF   x20
2EB4:  MOVLW  01
2EB6:  MOVWF  x1F
2EB8:  MOVLW  F4
2EBA:  MOVWF  x1E
2EBC:  MOVLB  0
2EBE:  CALL   2580
2EC2:  MOVFF  03,7FA
2EC6:  MOVFF  02,7F9
2ECA:  MOVFF  01,7F8
2ECE:  MOVFF  00,7F7
....................    col_4=col_4/500; 
2ED2:  BCF    FD8.1
2ED4:  MOVFF  7FE,81D
2ED8:  MOVFF  7FD,81C
2EDC:  MOVFF  7FC,81B
2EE0:  MOVFF  7FB,81A
2EE4:  MOVLB  8
2EE6:  CLRF   x21
2EE8:  CLRF   x20
2EEA:  MOVLW  01
2EEC:  MOVWF  x1F
2EEE:  MOVLW  F4
2EF0:  MOVWF  x1E
2EF2:  MOVLB  0
2EF4:  CALL   2580
2EF8:  MOVFF  03,7FE
2EFC:  MOVFF  02,7FD
2F00:  MOVFF  01,7FC
2F04:  MOVFF  00,7FB
....................    col_5=col_5/500; 
2F08:  BCF    FD8.1
2F0A:  MOVFF  802,81D
2F0E:  MOVFF  801,81C
2F12:  MOVFF  800,81B
2F16:  MOVFF  7FF,81A
2F1A:  MOVLB  8
2F1C:  CLRF   x21
2F1E:  CLRF   x20
2F20:  MOVLW  01
2F22:  MOVWF  x1F
2F24:  MOVLW  F4
2F26:  MOVWF  x1E
2F28:  MOVLB  0
2F2A:  CALL   2580
2F2E:  MOVFF  03,802
2F32:  MOVFF  02,801
2F36:  MOVFF  01,800
2F3A:  MOVFF  00,7FF
....................    if(keydebug_en) 
2F3E:  MOVLB  1
2F40:  MOVF   x0B,F
2F42:  BTFSC  FD8.2
2F44:  BRA    310E
....................    { 
....................       fprintf(COM2,"\r\n");      
2F46:  MOVLW  0D
2F48:  MOVLB  8
2F4A:  MOVWF  x1A
2F4C:  MOVLB  0
2F4E:  CALL   0422
2F52:  MOVLW  0A
2F54:  MOVLB  8
2F56:  MOVWF  x1A
2F58:  MOVLB  0
2F5A:  CALL   0422
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2F5E:  MOVLW  C4
2F60:  MOVWF  FF6
2F62:  MOVLW  02
2F64:  MOVWF  FF7
2F66:  MOVLW  07
2F68:  MOVLB  8
2F6A:  MOVWF  x0E
2F6C:  MOVLB  0
2F6E:  CALL   1864
2F72:  MOVLW  41
2F74:  MOVWF  FE9
2F76:  MOVFF  7EE,811
2F7A:  MOVFF  7ED,810
2F7E:  MOVFF  7EC,80F
2F82:  MOVFF  7EB,80E
2F86:  CALL   2614
2F8A:  MOVLW  0D
2F8C:  MOVLB  8
2F8E:  MOVWF  x1A
2F90:  MOVLB  0
2F92:  CALL   0422
2F96:  MOVLW  0A
2F98:  MOVLB  8
2F9A:  MOVWF  x1A
2F9C:  MOVLB  0
2F9E:  CALL   0422
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2FA2:  MOVLW  D2
2FA4:  MOVWF  FF6
2FA6:  MOVLW  02
2FA8:  MOVWF  FF7
2FAA:  MOVLW  07
2FAC:  MOVLB  8
2FAE:  MOVWF  x0E
2FB0:  MOVLB  0
2FB2:  CALL   1864
2FB6:  MOVLW  41
2FB8:  MOVWF  FE9
2FBA:  MOVFF  7F2,811
2FBE:  MOVFF  7F1,810
2FC2:  MOVFF  7F0,80F
2FC6:  MOVFF  7EF,80E
2FCA:  CALL   2614
2FCE:  MOVLW  0D
2FD0:  MOVLB  8
2FD2:  MOVWF  x1A
2FD4:  MOVLB  0
2FD6:  CALL   0422
2FDA:  MOVLW  0A
2FDC:  MOVLB  8
2FDE:  MOVWF  x1A
2FE0:  MOVLB  0
2FE2:  CALL   0422
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2FE6:  MOVLW  E0
2FE8:  MOVWF  FF6
2FEA:  MOVLW  02
2FEC:  MOVWF  FF7
2FEE:  MOVLW  07
2FF0:  MOVLB  8
2FF2:  MOVWF  x0E
2FF4:  MOVLB  0
2FF6:  CALL   1864
2FFA:  MOVLW  41
2FFC:  MOVWF  FE9
2FFE:  MOVFF  7F6,811
3002:  MOVFF  7F5,810
3006:  MOVFF  7F4,80F
300A:  MOVFF  7F3,80E
300E:  CALL   2614
3012:  MOVLW  0D
3014:  MOVLB  8
3016:  MOVWF  x1A
3018:  MOVLB  0
301A:  CALL   0422
301E:  MOVLW  0A
3020:  MOVLB  8
3022:  MOVWF  x1A
3024:  MOVLB  0
3026:  CALL   0422
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
302A:  MOVLW  EE
302C:  MOVWF  FF6
302E:  MOVLW  02
3030:  MOVWF  FF7
3032:  MOVLW  07
3034:  MOVLB  8
3036:  MOVWF  x0E
3038:  MOVLB  0
303A:  CALL   1864
303E:  MOVLW  41
3040:  MOVWF  FE9
3042:  MOVFF  7FA,811
3046:  MOVFF  7F9,810
304A:  MOVFF  7F8,80F
304E:  MOVFF  7F7,80E
3052:  CALL   2614
3056:  MOVLW  0D
3058:  MOVLB  8
305A:  MOVWF  x1A
305C:  MOVLB  0
305E:  CALL   0422
3062:  MOVLW  0A
3064:  MOVLB  8
3066:  MOVWF  x1A
3068:  MOVLB  0
306A:  CALL   0422
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
306E:  MOVLW  FC
3070:  MOVWF  FF6
3072:  MOVLW  02
3074:  MOVWF  FF7
3076:  MOVLW  07
3078:  MOVLB  8
307A:  MOVWF  x0E
307C:  MOVLB  0
307E:  CALL   1864
3082:  MOVLW  41
3084:  MOVWF  FE9
3086:  MOVFF  7FE,811
308A:  MOVFF  7FD,810
308E:  MOVFF  7FC,80F
3092:  MOVFF  7FB,80E
3096:  CALL   2614
309A:  MOVLW  0D
309C:  MOVLB  8
309E:  MOVWF  x1A
30A0:  MOVLB  0
30A2:  CALL   0422
30A6:  MOVLW  0A
30A8:  MOVLB  8
30AA:  MOVWF  x1A
30AC:  MOVLB  0
30AE:  CALL   0422
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
30B2:  MOVLW  0A
30B4:  MOVWF  FF6
30B6:  MOVLW  03
30B8:  MOVWF  FF7
30BA:  MOVLW  07
30BC:  MOVLB  8
30BE:  MOVWF  x0E
30C0:  MOVLB  0
30C2:  CALL   1864
30C6:  MOVLW  41
30C8:  MOVWF  FE9
30CA:  MOVFF  802,811
30CE:  MOVFF  801,810
30D2:  MOVFF  800,80F
30D6:  MOVFF  7FF,80E
30DA:  CALL   2614
30DE:  MOVLW  0D
30E0:  MOVLB  8
30E2:  MOVWF  x1A
30E4:  MOVLB  0
30E6:  CALL   0422
30EA:  MOVLW  0A
30EC:  MOVLB  8
30EE:  MOVWF  x1A
30F0:  MOVLB  0
30F2:  CALL   0422
....................       fprintf(COM2,"\r\n"); 
30F6:  MOVLW  0D
30F8:  MOVLB  8
30FA:  MOVWF  x1A
30FC:  MOVLB  0
30FE:  CALL   0422
3102:  MOVLW  0A
3104:  MOVLB  8
3106:  MOVWF  x1A
3108:  MOVLB  0
310A:  CALL   0422
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
310E:  MOVLB  7
3110:  MOVF   xEE,F
3112:  BNZ   3122
3114:  MOVF   xED,F
3116:  BNZ   3122
3118:  MOVF   xEC,F
311A:  BNZ   3122
311C:  MOVF   xEB,W
311E:  SUBLW  05
3120:  BC    319C
3122:  MOVF   xEE,F
3124:  BNZ   319C
3126:  MOVF   xED,F
3128:  BNZ   319C
312A:  MOVF   xEC,F
312C:  BNZ   319C
312E:  MOVF   xEB,W
3130:  SUBLW  3B
3132:  BNC   319C
3134:  MOVF   xF2,F
3136:  BNZ   3146
3138:  MOVF   xF1,F
313A:  BNZ   3146
313C:  MOVF   xF0,F
313E:  BNZ   3146
3140:  MOVF   xEF,W
3142:  SUBLW  64
3144:  BC    319C
3146:  MOVF   xF6,F
3148:  BNZ   3158
314A:  MOVF   xF5,F
314C:  BNZ   3158
314E:  MOVF   xF4,F
3150:  BNZ   3158
3152:  MOVF   xF3,W
3154:  SUBLW  64
3156:  BC    319C
3158:  MOVF   xFA,F
315A:  BNZ   316A
315C:  MOVF   xF9,F
315E:  BNZ   316A
3160:  MOVF   xF8,F
3162:  BNZ   316A
3164:  MOVF   xF7,W
3166:  SUBLW  64
3168:  BC    319C
316A:  MOVF   xFE,F
316C:  BNZ   317C
316E:  MOVF   xFD,F
3170:  BNZ   317C
3172:  MOVF   xFC,F
3174:  BNZ   317C
3176:  MOVF   xFB,W
3178:  SUBLW  64
317A:  BC    319C
317C:  MOVLB  8
317E:  MOVF   x02,F
3180:  BNZ   3194
3182:  MOVF   x01,F
3184:  BNZ   3194
3186:  MOVF   x00,F
3188:  BNZ   3194
318A:  MOVLB  7
318C:  MOVF   xFF,W
318E:  SUBLW  64
3190:  BC    319C
3192:  MOVLB  8
3194:  MOVLW  00
3196:  MOVWF  01
3198:  BRA    355C
319A:  MOVLB  7
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
319C:  MOVF   xF2,F
319E:  BNZ   31AE
31A0:  MOVF   xF1,F
31A2:  BNZ   31AE
31A4:  MOVF   xF0,F
31A6:  BNZ   31AE
31A8:  MOVF   xEF,W
31AA:  SUBLW  05
31AC:  BC    3228
31AE:  MOVF   xF2,F
31B0:  BNZ   3228
31B2:  MOVF   xF1,F
31B4:  BNZ   3228
31B6:  MOVF   xF0,F
31B8:  BNZ   3228
31BA:  MOVF   xEF,W
31BC:  SUBLW  3B
31BE:  BNC   3228
31C0:  MOVF   xEE,F
31C2:  BNZ   31D2
31C4:  MOVF   xED,F
31C6:  BNZ   31D2
31C8:  MOVF   xEC,F
31CA:  BNZ   31D2
31CC:  MOVF   xEB,W
31CE:  SUBLW  64
31D0:  BC    3228
31D2:  MOVF   xF6,F
31D4:  BNZ   31E4
31D6:  MOVF   xF5,F
31D8:  BNZ   31E4
31DA:  MOVF   xF4,F
31DC:  BNZ   31E4
31DE:  MOVF   xF3,W
31E0:  SUBLW  64
31E2:  BC    3228
31E4:  MOVF   xFA,F
31E6:  BNZ   31F6
31E8:  MOVF   xF9,F
31EA:  BNZ   31F6
31EC:  MOVF   xF8,F
31EE:  BNZ   31F6
31F0:  MOVF   xF7,W
31F2:  SUBLW  64
31F4:  BC    3228
31F6:  MOVF   xFE,F
31F8:  BNZ   3208
31FA:  MOVF   xFD,F
31FC:  BNZ   3208
31FE:  MOVF   xFC,F
3200:  BNZ   3208
3202:  MOVF   xFB,W
3204:  SUBLW  64
3206:  BC    3228
3208:  MOVLB  8
320A:  MOVF   x02,F
320C:  BNZ   3220
320E:  MOVF   x01,F
3210:  BNZ   3220
3212:  MOVF   x00,F
3214:  BNZ   3220
3216:  MOVLB  7
3218:  MOVF   xFF,W
321A:  SUBLW  64
321C:  BC    3228
321E:  MOVLB  8
3220:  MOVLW  01
3222:  MOVWF  01
3224:  BRA    355C
3226:  MOVLB  7
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
3228:  MOVF   xF6,F
322A:  BNZ   323A
322C:  MOVF   xF5,F
322E:  BNZ   323A
3230:  MOVF   xF4,F
3232:  BNZ   323A
3234:  MOVF   xF3,W
3236:  SUBLW  05
3238:  BC    32B4
323A:  MOVF   xF6,F
323C:  BNZ   32B4
323E:  MOVF   xF5,F
3240:  BNZ   32B4
3242:  MOVF   xF4,F
3244:  BNZ   32B4
3246:  MOVF   xF3,W
3248:  SUBLW  3B
324A:  BNC   32B4
324C:  MOVF   xF2,F
324E:  BNZ   325E
3250:  MOVF   xF1,F
3252:  BNZ   325E
3254:  MOVF   xF0,F
3256:  BNZ   325E
3258:  MOVF   xEF,W
325A:  SUBLW  64
325C:  BC    32B4
325E:  MOVF   xEE,F
3260:  BNZ   3270
3262:  MOVF   xED,F
3264:  BNZ   3270
3266:  MOVF   xEC,F
3268:  BNZ   3270
326A:  MOVF   xEB,W
326C:  SUBLW  64
326E:  BC    32B4
3270:  MOVF   xFA,F
3272:  BNZ   3282
3274:  MOVF   xF9,F
3276:  BNZ   3282
3278:  MOVF   xF8,F
327A:  BNZ   3282
327C:  MOVF   xF7,W
327E:  SUBLW  64
3280:  BC    32B4
3282:  MOVF   xFE,F
3284:  BNZ   3294
3286:  MOVF   xFD,F
3288:  BNZ   3294
328A:  MOVF   xFC,F
328C:  BNZ   3294
328E:  MOVF   xFB,W
3290:  SUBLW  64
3292:  BC    32B4
3294:  MOVLB  8
3296:  MOVF   x02,F
3298:  BNZ   32AC
329A:  MOVF   x01,F
329C:  BNZ   32AC
329E:  MOVF   x00,F
32A0:  BNZ   32AC
32A2:  MOVLB  7
32A4:  MOVF   xFF,W
32A6:  SUBLW  64
32A8:  BC    32B4
32AA:  MOVLB  8
32AC:  MOVLW  02
32AE:  MOVWF  01
32B0:  BRA    355C
32B2:  MOVLB  7
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
32B4:  MOVF   xFA,F
32B6:  BNZ   32C6
32B8:  MOVF   xF9,F
32BA:  BNZ   32C6
32BC:  MOVF   xF8,F
32BE:  BNZ   32C6
32C0:  MOVF   xF7,W
32C2:  SUBLW  05
32C4:  BC    3340
32C6:  MOVF   xFA,F
32C8:  BNZ   3340
32CA:  MOVF   xF9,F
32CC:  BNZ   3340
32CE:  MOVF   xF8,F
32D0:  BNZ   3340
32D2:  MOVF   xF7,W
32D4:  SUBLW  3B
32D6:  BNC   3340
32D8:  MOVF   xF2,F
32DA:  BNZ   32EA
32DC:  MOVF   xF1,F
32DE:  BNZ   32EA
32E0:  MOVF   xF0,F
32E2:  BNZ   32EA
32E4:  MOVF   xEF,W
32E6:  SUBLW  64
32E8:  BC    3340
32EA:  MOVF   xF6,F
32EC:  BNZ   32FC
32EE:  MOVF   xF5,F
32F0:  BNZ   32FC
32F2:  MOVF   xF4,F
32F4:  BNZ   32FC
32F6:  MOVF   xF3,W
32F8:  SUBLW  64
32FA:  BC    3340
32FC:  MOVF   xEE,F
32FE:  BNZ   330E
3300:  MOVF   xED,F
3302:  BNZ   330E
3304:  MOVF   xEC,F
3306:  BNZ   330E
3308:  MOVF   xEB,W
330A:  SUBLW  64
330C:  BC    3340
330E:  MOVF   xFE,F
3310:  BNZ   3320
3312:  MOVF   xFD,F
3314:  BNZ   3320
3316:  MOVF   xFC,F
3318:  BNZ   3320
331A:  MOVF   xFB,W
331C:  SUBLW  64
331E:  BC    3340
3320:  MOVLB  8
3322:  MOVF   x02,F
3324:  BNZ   3338
3326:  MOVF   x01,F
3328:  BNZ   3338
332A:  MOVF   x00,F
332C:  BNZ   3338
332E:  MOVLB  7
3330:  MOVF   xFF,W
3332:  SUBLW  64
3334:  BC    3340
3336:  MOVLB  8
3338:  MOVLW  03
333A:  MOVWF  01
333C:  BRA    355C
333E:  MOVLB  7
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
3340:  MOVF   xFE,F
3342:  BNZ   3352
3344:  MOVF   xFD,F
3346:  BNZ   3352
3348:  MOVF   xFC,F
334A:  BNZ   3352
334C:  MOVF   xFB,W
334E:  SUBLW  05
3350:  BC    33CA
3352:  MOVF   xFE,F
3354:  BNZ   33CA
3356:  MOVF   xFD,F
3358:  BNZ   33CA
335A:  MOVF   xFC,F
335C:  BNZ   33CA
335E:  MOVF   xFB,W
3360:  SUBLW  3B
3362:  BNC   33CA
3364:  MOVF   xF2,F
3366:  BNZ   3376
3368:  MOVF   xF1,F
336A:  BNZ   3376
336C:  MOVF   xF0,F
336E:  BNZ   3376
3370:  MOVF   xEF,W
3372:  SUBLW  64
3374:  BC    33CA
3376:  MOVF   xF6,F
3378:  BNZ   3388
337A:  MOVF   xF5,F
337C:  BNZ   3388
337E:  MOVF   xF4,F
3380:  BNZ   3388
3382:  MOVF   xF3,W
3384:  SUBLW  64
3386:  BC    33CA
3388:  MOVF   xFA,F
338A:  BNZ   339A
338C:  MOVF   xF9,F
338E:  BNZ   339A
3390:  MOVF   xF8,F
3392:  BNZ   339A
3394:  MOVF   xF7,W
3396:  SUBLW  64
3398:  BC    33CA
339A:  MOVF   xEE,F
339C:  BNZ   33AC
339E:  MOVF   xED,F
33A0:  BNZ   33AC
33A2:  MOVF   xEC,F
33A4:  BNZ   33AC
33A6:  MOVF   xEB,W
33A8:  SUBLW  64
33AA:  BC    33CA
33AC:  MOVLB  8
33AE:  MOVF   x02,F
33B0:  BNZ   33C4
33B2:  MOVF   x01,F
33B4:  BNZ   33C4
33B6:  MOVF   x00,F
33B8:  BNZ   33C4
33BA:  MOVLB  7
33BC:  MOVF   xFF,W
33BE:  SUBLW  64
33C0:  BC    33CA
33C2:  MOVLB  8
33C4:  MOVLW  04
33C6:  MOVWF  01
33C8:  BRA    355C
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
33CA:  MOVLB  8
33CC:  MOVF   x02,F
33CE:  BNZ   33E2
33D0:  MOVF   x01,F
33D2:  BNZ   33E2
33D4:  MOVF   x00,F
33D6:  BNZ   33E2
33D8:  MOVLB  7
33DA:  MOVF   xFF,W
33DC:  SUBLW  05
33DE:  BC    346A
33E0:  MOVLB  8
33E2:  MOVF   x02,F
33E4:  BTFSC  FD8.2
33E6:  BRA    33EC
33E8:  MOVLB  7
33EA:  BRA    346A
33EC:  MOVF   x01,F
33EE:  BTFSC  FD8.2
33F0:  BRA    33F6
33F2:  MOVLB  7
33F4:  BRA    346A
33F6:  MOVF   x00,F
33F8:  BTFSC  FD8.2
33FA:  BRA    3400
33FC:  MOVLB  7
33FE:  BRA    346A
3400:  MOVLB  7
3402:  MOVF   xFF,W
3404:  SUBLW  3B
3406:  BNC   346A
3408:  MOVF   xF2,F
340A:  BNZ   341A
340C:  MOVF   xF1,F
340E:  BNZ   341A
3410:  MOVF   xF0,F
3412:  BNZ   341A
3414:  MOVF   xEF,W
3416:  SUBLW  64
3418:  BC    346A
341A:  MOVF   xF6,F
341C:  BNZ   342C
341E:  MOVF   xF5,F
3420:  BNZ   342C
3422:  MOVF   xF4,F
3424:  BNZ   342C
3426:  MOVF   xF3,W
3428:  SUBLW  64
342A:  BC    346A
342C:  MOVF   xFA,F
342E:  BNZ   343E
3430:  MOVF   xF9,F
3432:  BNZ   343E
3434:  MOVF   xF8,F
3436:  BNZ   343E
3438:  MOVF   xF7,W
343A:  SUBLW  64
343C:  BC    346A
343E:  MOVF   xFE,F
3440:  BNZ   3450
3442:  MOVF   xFD,F
3444:  BNZ   3450
3446:  MOVF   xFC,F
3448:  BNZ   3450
344A:  MOVF   xFB,W
344C:  SUBLW  64
344E:  BC    346A
3450:  MOVF   xEE,F
3452:  BNZ   3462
3454:  MOVF   xED,F
3456:  BNZ   3462
3458:  MOVF   xEC,F
345A:  BNZ   3462
345C:  MOVF   xEB,W
345E:  SUBLW  64
3460:  BC    346A
3462:  MOVLW  05
3464:  MOVWF  01
3466:  MOVLB  8
3468:  BRA    355C
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
346A:  MOVLB  8
346C:  MOVF   x02,F
346E:  BNZ   3482
3470:  MOVF   x01,F
3472:  BNZ   3482
3474:  MOVF   x00,F
3476:  BNZ   3482
3478:  MOVLB  7
347A:  MOVF   xFF,W
347C:  SUBLW  C8
347E:  BTFSC  FD8.0
3480:  BRA    3556
3482:  MOVLB  7
3484:  MOVF   xEE,F
3486:  BTFSS  FD8.2
3488:  BRA    3556
348A:  MOVF   xED,F
348C:  BTFSS  FD8.2
348E:  BRA    3556
3490:  MOVF   xEC,F
3492:  BTFSS  FD8.2
3494:  BRA    3556
3496:  MOVF   xEB,W
3498:  SUBLW  B3
349A:  BTFSS  FD8.0
349C:  BRA    3556
349E:  MOVF   xEE,F
34A0:  BNZ   34B2
34A2:  MOVF   xED,F
34A4:  BNZ   34B2
34A6:  MOVF   xEC,F
34A8:  BNZ   34B2
34AA:  MOVF   xEB,W
34AC:  SUBLW  64
34AE:  BTFSC  FD8.0
34B0:  BRA    3556
34B2:  MOVF   xF2,F
34B4:  BTFSS  FD8.2
34B6:  BRA    3556
34B8:  MOVF   xF1,F
34BA:  BTFSS  FD8.2
34BC:  BRA    3556
34BE:  MOVF   xF0,F
34C0:  BTFSS  FD8.2
34C2:  BRA    3556
34C4:  MOVF   xEF,W
34C6:  SUBLW  B3
34C8:  BTFSS  FD8.0
34CA:  BRA    3556
34CC:  MOVF   xF2,F
34CE:  BNZ   34DE
34D0:  MOVF   xF1,F
34D2:  BNZ   34DE
34D4:  MOVF   xF0,F
34D6:  BNZ   34DE
34D8:  MOVF   xEF,W
34DA:  SUBLW  64
34DC:  BC    3556
34DE:  MOVF   xF6,F
34E0:  BNZ   3556
34E2:  MOVF   xF5,F
34E4:  BNZ   3556
34E6:  MOVF   xF4,F
34E8:  BNZ   3556
34EA:  MOVF   xF3,W
34EC:  SUBLW  B3
34EE:  BNC   3556
34F0:  MOVF   xF6,F
34F2:  BNZ   3502
34F4:  MOVF   xF5,F
34F6:  BNZ   3502
34F8:  MOVF   xF4,F
34FA:  BNZ   3502
34FC:  MOVF   xF3,W
34FE:  SUBLW  64
3500:  BC    3556
3502:  MOVF   xFA,F
3504:  BNZ   3556
3506:  MOVF   xF9,F
3508:  BNZ   3556
350A:  MOVF   xF8,F
350C:  BNZ   3556
350E:  MOVF   xF7,W
3510:  SUBLW  B3
3512:  BNC   3556
3514:  MOVF   xFA,F
3516:  BNZ   3526
3518:  MOVF   xF9,F
351A:  BNZ   3526
351C:  MOVF   xF8,F
351E:  BNZ   3526
3520:  MOVF   xF7,W
3522:  SUBLW  64
3524:  BC    3556
3526:  MOVF   xFE,F
3528:  BNZ   3556
352A:  MOVF   xFD,F
352C:  BNZ   3556
352E:  MOVF   xFC,F
3530:  BNZ   3556
3532:  MOVF   xFB,W
3534:  SUBLW  B3
3536:  BNC   3556
3538:  MOVF   xFE,F
353A:  BNZ   354A
353C:  MOVF   xFD,F
353E:  BNZ   354A
3540:  MOVF   xFC,F
3542:  BNZ   354A
3544:  MOVF   xFB,W
3546:  SUBLW  64
3548:  BC    3556
354A:  MOVLW  05
354C:  MOVWF  01
354E:  MOVLB  8
3550:  BRA    355C
....................    else return 0xff; 
3552:  BRA    355C
3554:  MOVLB  7
3556:  MOVLW  FF
3558:  MOVWF  01
355A:  MOVLB  8
.................... } 
355C:  MOVLB  0
355E:  GOTO   35CC (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
3562:  BSF    F93.4
3564:  BTFSS  F81.4
3566:  BRA    357A
3568:  BSF    F93.5
356A:  BTFSS  F81.5
356C:  BRA    357A
356E:  BSF    F93.6
3570:  BTFSS  F81.6
3572:  BRA    357A
3574:  BSF    F93.7
3576:  BTFSC  F81.7
3578:  BRA    36F4
....................     { 
....................        if(input(ROW0)==0) 
357A:  BSF    F93.4
357C:  BTFSC  F81.4
357E:  BRA    3588
....................          row=0; 
3580:  MOVLB  7
3582:  CLRF   xE8
....................        else if(input(ROW1)==0) 
3584:  BRA    35B4
3586:  MOVLB  0
3588:  BSF    F93.5
358A:  BTFSC  F81.5
358C:  BRA    3598
....................          row=1; 
358E:  MOVLW  01
3590:  MOVLB  7
3592:  MOVWF  xE8
....................        else if(input(ROW2)==0) 
3594:  BRA    35B4
3596:  MOVLB  0
3598:  BSF    F93.6
359A:  BTFSC  F81.6
359C:  BRA    35A8
....................          row=2; 
359E:  MOVLW  02
35A0:  MOVLB  7
35A2:  MOVWF  xE8
....................        else if(input(ROW3)==0) 
35A4:  BRA    35B4
35A6:  MOVLB  0
35A8:  BSF    F93.7
35AA:  BTFSC  F81.7
35AC:  BRA    35B4
....................          row=3;      
35AE:  MOVLW  03
35B0:  MOVLB  7
35B2:  MOVWF  xE8
....................        if(type_KB==0)col=check_col(); 
35B4:  MOVLB  1
35B6:  MOVF   x13,F
35B8:  BNZ   35C6
35BA:  MOVLB  0
35BC:  GOTO   26D4
35C0:  MOVFF  01,7E6
....................          else col=new_check_col(); 
35C4:  BRA    35D0
35C6:  MOVLB  0
35C8:  GOTO   2D0C
35CC:  MOVFF  01,7E6
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
35D0:  MOVLB  7
35D2:  INCFSZ xE6,W
35D4:  BRA    35D8
35D6:  BRA    36C2
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
35D8:  MOVLB  1
35DA:  MOVF   x13,F
35DC:  BNZ   3604
35DE:  MOVLB  7
35E0:  MOVF   xE8,W
35E2:  MULLW  05
35E4:  MOVF   FF3,W
35E6:  CLRF   xEA
35E8:  MOVWF  xE9
35EA:  CLRF   03
35EC:  MOVF   xE6,W
35EE:  ADDWF  xE9,W
35F0:  MOVWF  01
35F2:  MOVF   xEA,W
35F4:  ADDWFC 03,F
35F6:  MOVF   01,W
35F8:  MOVLB  0
35FA:  CALL   00D0
35FE:  MOVFF  FE8,7E7
....................            else kchar =newKEYS[row][col]; 
3602:  BRA    3628
3604:  MOVLB  7
3606:  MOVF   xE8,W
3608:  MULLW  06
360A:  MOVF   FF3,W
360C:  CLRF   xEA
360E:  MOVWF  xE9
3610:  CLRF   03
3612:  MOVF   xE6,W
3614:  ADDWF  xE9,W
3616:  MOVWF  01
3618:  MOVF   xEA,W
361A:  ADDWFC 03,F
361C:  MOVF   01,W
361E:  MOVLB  0
3620:  CALL   00F4
3624:  MOVFF  FE8,7E7
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
3628:  MOVLB  1
362A:  MOVF   x0B,F
362C:  BNZ   36B4
....................             { 
....................               charac_timeout=0; 
362E:  MOVLB  0
3630:  CLRF   xFC
3632:  CLRF   xFB
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
3634:  MOVLB  1
3636:  MOVF   x0E,W
3638:  SUBLW  0F
363A:  BNC   3650
363C:  MOVF   x0E,W
363E:  INCF   x0E,F
3640:  CLRF   03
3642:  ADDLW  14
3644:  MOVWF  FE9
3646:  MOVLW  01
3648:  ADDWFC 03,W
364A:  MOVWF  FEA
364C:  MOVFF  7E7,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
3650:  MOVLW  18
3652:  MOVWF  FF6
3654:  MOVLW  03
3656:  MOVWF  FF7
3658:  MOVLW  09
365A:  MOVLB  8
365C:  MOVWF  x0E
365E:  MOVLB  0
3660:  CALL   1864
3664:  MOVFF  10E,7EF
3668:  MOVLW  18
366A:  MOVLB  7
366C:  MOVWF  xF0
366E:  MOVLB  0
3670:  CALL   1978
3674:  MOVLW  5D
3676:  MOVLB  8
3678:  MOVWF  x1A
367A:  MOVLB  0
367C:  CALL   0422
3680:  MOVLW  20
3682:  MOVLB  8
3684:  MOVWF  x1A
3686:  MOVLB  0
3688:  CALL   0422
368C:  MOVFF  7E7,81A
3690:  CALL   0422
3694:  MOVLW  0D
3696:  MOVLB  8
3698:  MOVWF  x1A
369A:  MOVLB  0
369C:  CALL   0422
36A0:  MOVLW  0A
36A2:  MOVLB  8
36A4:  MOVWF  x1A
36A6:  MOVLB  0
36A8:  CALL   0422
....................                count_checking=0; 
36AC:  MOVLB  1
36AE:  CLRF   x07
36B0:  CLRF   x06
....................             } 
....................                else fputc(kchar,COM2); 
36B2:  BRA    36C0
36B4:  MOVFF  7E7,81A
36B8:  MOVLB  0
36BA:  CALL   0422
36BE:  MOVLB  1
36C0:  MOVLB  7
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
36C2:  BSF    F93.4
36C4:  BTFSS  F81.4
36C6:  BRA    36C2
36C8:  BSF    F93.5
36CA:  BTFSS  F81.5
36CC:  BRA    36C2
36CE:  BSF    F93.6
36D0:  BTFSS  F81.6
36D2:  BRA    36C2
36D4:  BSF    F93.7
36D6:  BTFSS  F81.7
36D8:  BRA    36C2
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
36DA:  BSF    F93.4
36DC:  BTFSS  F81.4
36DE:  BRA    36DA
36E0:  BSF    F93.5
36E2:  BTFSS  F81.5
36E4:  BRA    36DA
36E6:  BSF    F93.6
36E8:  BTFSS  F81.6
36EA:  BRA    36DA
36EC:  BSF    F93.7
36EE:  BTFSS  F81.7
36F0:  BRA    36DA
36F2:  MOVLB  0
....................     } 
....................   set_tris_a(0xff);     
36F4:  MOVLW  FF
36F6:  MOVWF  F92
....................   return(kchar); 
36F8:  MOVLB  7
36FA:  MOVFF  7E7,01
.................... }//*/ 
36FE:  MOVLB  0
3700:  RETURN 0
.................... //============================================ 
....................  
.................... //=========================== 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
433C:  MOVF   27,F
433E:  BTFSS  FD8.2
4340:  BRA    44BA
4342:  MOVF   26,W
4344:  SUBLW  01
4346:  BTFSS  FD8.0
4348:  BRA    44BA
434A:  BNZ   435E
434C:  MOVF   25,W
434E:  SUBLW  FF
4350:  BTFSS  FD8.0
4352:  BRA    44BA
4354:  BNZ   435E
4356:  MOVF   24,W
4358:  SUBLW  FE
435A:  BTFSS  FD8.0
435C:  BRA    44BA
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)) 
435E:  MOVLB  1
4360:  MOVF   x14,F
4362:  BTFSC  FD8.2
4364:  BRA    4468
....................       { 
....................          temp=get_countcard(); 
4366:  MOVLB  0
4368:  CALL   38B0
436C:  MOVFF  02,7E8
4370:  MOVFF  01,7E7
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
4374:  MOVLB  7
4376:  RLCF   xE7,W
4378:  MOVWF  xE9
437A:  RLCF   xE8,W
437C:  MOVWF  xEA
437E:  RLCF   xE9,F
4380:  RLCF   xEA,F
4382:  RLCF   xE9,F
4384:  RLCF   xEA,F
4386:  RLCF   xE9,F
4388:  RLCF   xEA,F
438A:  MOVLW  F0
438C:  ANDWF  xE9,F
438E:  MOVLW  0E
4390:  ADDWF  xE9,F
4392:  MOVLW  C3
4394:  ADDWFC xEA,F
4396:  MOVLW  01
4398:  MOVWF  xEB
439A:  BCF    FD8.2
439C:  BTFSC  FD8.0
439E:  INCF   xEB,F
43A0:  CLRF   xEC
43A2:  MOVLW  01
43A4:  ADDWF  xE9,W
43A6:  MOVWF  00
43A8:  MOVLW  00
43AA:  ADDWFC xEA,W
43AC:  MOVWF  01
43AE:  MOVLW  00
43B0:  ADDWFC xEB,W
43B2:  MOVWF  02
43B4:  MOVLW  00
43B6:  ADDWFC xEC,W
43B8:  MOVWF  27
43BA:  MOVFF  02,26
43BE:  MOVFF  01,25
43C2:  MOVFF  00,24
....................           //fprintf(COM2," ptr_card_key=%lu\n\r",ptr_card_key); 
....................          for(i=0;i<key_numbyte;i++) 
43C6:  CLRF   xE6
43C8:  MOVF   xE6,W
43CA:  SUBLW  0F
43CC:  BNC   4438
....................          { 
....................             temp=key_data[i]; 
43CE:  CLRF   03
43D0:  MOVF   xE6,W
43D2:  ADDLW  14
43D4:  MOVWF  FE9
43D6:  MOVLW  01
43D8:  ADDWFC 03,W
43DA:  MOVWF  FEA
43DC:  CLRF   xE8
43DE:  MOVFF  FEF,7E7
....................             write_ext_eeprom((int32)ptr_card_key++,temp); 
43E2:  MOVFF  27,03
43E6:  MOVFF  26,02
43EA:  MOVFF  25,01
43EE:  MOVFF  24,00
43F2:  MOVLW  01
43F4:  ADDWF  24,F
43F6:  BTFSC  FD8.0
43F8:  INCF   25,F
43FA:  BTFSC  FD8.2
43FC:  INCF   26,F
43FE:  BTFSC  FD8.2
4400:  INCF   27,F
4402:  MOVFF  03,7EC
4406:  MOVFF  02,7EB
440A:  MOVFF  01,7EA
440E:  MOVFF  00,7E9
4412:  MOVFF  03,805
4416:  MOVFF  02,804
441A:  MOVFF  01,803
441E:  MOVFF  00,802
4422:  MOVFF  7E7,806
4426:  MOVLB  0
4428:  RCALL  3D80
....................             //delay_us(100); 
....................             fputc(temp,COM2); 
442A:  MOVFF  7E7,81A
442E:  CALL   0422
....................          } 
4432:  MOVLB  7
4434:  INCF   xE6,F
4436:  BRA    43C8
....................          /*fprintf(COM2,"read key=\n\r"); 
....................           for(i=0;i<key_numbyte;i++) 
....................           { 
....................             fprintf(COM2,"read key=%c\n\r",read_ext_eeprom(ptr_card_key-i)); 
....................           }*/ 
....................          write_ext_eeprom((long int)ptr_card_key,0); 
4438:  MOVLB  8
443A:  CLRF   x05
443C:  CLRF   x04
443E:  MOVFF  25,803
4442:  MOVFF  24,802
4446:  CLRF   x06
4448:  MOVLB  0
444A:  RCALL  3D80
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
444C:  MOVFF  27,7EC
4450:  MOVFF  26,7EB
4454:  MOVFF  25,7EA
4458:  MOVFF  24,7E9
445C:  MOVLW  1E
445E:  MOVLB  7
4460:  MOVWF  xED
4462:  MOVLB  0
4464:  RCALL  3E7E
4466:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
4468:  CLRF   x0E
....................       del_buf(key_numbyte,key_data); 
446A:  MOVLW  10
446C:  MOVLB  7
446E:  MOVWF  xF5
4470:  MOVLW  01
4472:  MOVWF  xF7
4474:  MOVLW  14
4476:  MOVWF  xF6
4478:  MOVLB  0
447A:  CALL   392A
....................       fprintf(COM2,"\r\n"); 
447E:  MOVLW  0D
4480:  MOVLB  8
4482:  MOVWF  x1A
4484:  MOVLB  0
4486:  CALL   0422
448A:  MOVLW  0A
448C:  MOVLB  8
448E:  MOVWF  x1A
4490:  MOVLB  0
4492:  CALL   0422
....................       fprintf(COM2,"Done PIN"); 
4496:  MOVLW  2A
4498:  MOVWF  FF6
449A:  MOVLW  03
449C:  MOVWF  FF7
449E:  CALL   0474
....................       fprintf(COM2,"\r\n"); 
44A2:  MOVLW  0D
44A4:  MOVLB  8
44A6:  MOVWF  x1A
44A8:  MOVLB  0
44AA:  CALL   0422
44AE:  MOVLW  0A
44B0:  MOVLB  8
44B2:  MOVWF  x1A
44B4:  MOVLB  0
44B6:  CALL   0422
....................    } 
.................... } 
44BA:  GOTO   4780 (RETURN)
.................... //=========================================== 
.................... void key_press() 
.................... { 
....................    int8 col; 
....................    int32 KB_count_timeout=0; 
....................    fprintf(COM2,"\r\n"); 
....................    fprintf(COM2,"Key"); 
....................    //fprintf(COM2,"\r\n"); 
....................    KB_count_timeout=0; 
....................    while(1) 
....................    { 
....................       
....................       if(KB_count_timeout<150000)KB_count_timeout++; 
....................       if(KB_count_timeout==150000) 
....................       { 
....................          KB_count_timeout++; 
....................           
....................          break;             
....................       }   
....................    } 
.................... } 
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
4D80:  MOVLB  7
4D82:  CLRF   xC1
4D84:  CLRF   xC0
4D86:  CLRF   xC2
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
4D88:  MOVF   xC1,F
4D8A:  BTFSS  FD8.2
4D8C:  BRA    4EB0
4D8E:  MOVF   xBB,W
4D90:  SUBWF  xC0,W
4D92:  BTFSC  FD8.0
4D94:  BRA    4EB0
4D96:  MOVF   xC2,F
4D98:  BTFSS  FD8.2
4D9A:  BRA    4EB0
....................       c = fgetc(COM2);//getc(); 
4D9C:  MOVLB  0
4D9E:  RCALL  4D24
4DA0:  MOVFF  01,7BE
....................       switch(c) 
....................       { 
4DA4:  MOVLB  7
4DA6:  MOVF   xBE,W
4DA8:  XORLW  7F
4DAA:  MOVLB  0
4DAC:  BZ    4DB4
4DAE:  XORLW  72
4DB0:  BZ    4E02
4DB2:  BRA    4E40
....................          case 0x7f:    
....................             if(nbcar>0)   
4DB4:  MOVLB  7
4DB6:  MOVF   xC0,F
4DB8:  BNZ   4DBE
4DBA:  MOVF   xC1,F
4DBC:  BZ    4DE8
4DBE:  CLRF   19
4DC0:  BTFSC  FF2.7
4DC2:  BSF    19.7
4DC4:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
4DC6:  MOVLW  7F
4DC8:  MOVLB  8
4DCA:  MOVWF  x1A
4DCC:  MOVLB  0
4DCE:  CALL   0422
4DD2:  BTFSC  19.7
4DD4:  BSF    FF2.7
....................                nbcar--; 
4DD6:  MOVLB  7
4DD8:  MOVF   xC0,W
4DDA:  BTFSC  FD8.2
4DDC:  DECF   xC1,F
4DDE:  DECF   xC0,F
....................                fgetc(COM2);//getc(); 
4DE0:  MOVLB  0
4DE2:  RCALL  4D24
....................             } 
....................             else fputc(0x07,COM2);    
4DE4:  BRA    4E00
4DE6:  MOVLB  7
4DE8:  CLRF   19
4DEA:  BTFSC  FF2.7
4DEC:  BSF    19.7
4DEE:  BCF    FF2.7
4DF0:  MOVLW  07
4DF2:  MOVLB  8
4DF4:  MOVWF  x1A
4DF6:  MOVLB  0
4DF8:  CALL   0422
4DFC:  BTFSC  19.7
4DFE:  BSF    FF2.7
....................          break;  
4E00:  BRA    4EAC
....................          case 0x0D:   
....................                keydebug_en=0; 
4E02:  MOVLB  1
4E04:  CLRF   x0B
....................                set_tris_a(0xff); 
4E06:  MOVLW  FF
4E08:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
4E0A:  MOVFF  7C0,7BF
4E0E:  MOVLB  7
4E10:  MOVF   xBB,W
4E12:  SUBWF  xBF,W
4E14:  BC    4E2A
....................                { 
....................                  chaine[i]=0; 
4E16:  CLRF   03
4E18:  MOVF   xBF,W
4E1A:  ADDWF  xBC,W
4E1C:  MOVWF  FE9
4E1E:  MOVF   xBD,W
4E20:  ADDWFC 03,W
4E22:  MOVWF  FEA
4E24:  CLRF   FEF
....................                } 
4E26:  INCF   xBF,F
4E28:  BRA    4E10
....................                if(nbcar==0)return(FAUX); 
4E2A:  MOVF   xC0,F
4E2C:  BNZ   4E38
4E2E:  MOVF   xC1,F
4E30:  BNZ   4E38
4E32:  MOVLW  00
4E34:  MOVWF  01
4E36:  BRA    4EB4
....................                fini=VRAI; 
4E38:  MOVLW  01
4E3A:  MOVWF  xC2
....................          break; 
4E3C:  MOVLB  0
4E3E:  BRA    4EAC
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
4E40:  MOVLB  7
4E42:  MOVF   xBE,W
4E44:  SUBLW  1F
4E46:  BC    4EAE
4E48:  MOVF   xBE,W
4E4A:  SUBLW  7E
4E4C:  BNC   4EAE
4E4E:  MOVLW  01
4E50:  SUBWF  xBB,W
4E52:  MOVF   xC1,F
4E54:  BNZ   4EAE
4E56:  SUBWF  xC0,W
4E58:  BC    4EAE
....................             { 
....................                chaine[nbcar]=c; 
4E5A:  MOVF   xBC,W
4E5C:  ADDWF  xC0,W
4E5E:  MOVWF  FE9
4E60:  MOVF   xBD,W
4E62:  ADDWFC xC1,W
4E64:  MOVWF  FEA
4E66:  MOVFF  7BE,FEF
....................                nbcar++; 
4E6A:  INCF   xC0,F
4E6C:  BTFSC  FD8.2
4E6E:  INCF   xC1,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
4E70:  DECFSZ xBA,W
4E72:  BRA    4E8E
4E74:  CLRF   19
4E76:  BTFSC  FF2.7
4E78:  BSF    19.7
4E7A:  BCF    FF2.7
4E7C:  MOVFF  7BE,81A
4E80:  MOVLB  0
4E82:  CALL   0422
4E86:  BTFSC  19.7
4E88:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
4E8A:  BRA    4EAC
4E8C:  MOVLB  7
4E8E:  MOVF   xBA,W
4E90:  SUBLW  02
4E92:  BNZ   4EAE
4E94:  CLRF   19
4E96:  BTFSC  FF2.7
4E98:  BSF    19.7
4E9A:  BCF    FF2.7
4E9C:  MOVLW  2A
4E9E:  MOVLB  8
4EA0:  MOVWF  x1A
4EA2:  MOVLB  0
4EA4:  CALL   0422
4EA8:  BTFSC  19.7
4EAA:  BSF    FF2.7
4EAC:  MOVLB  7
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
4EAE:  BRA    4D88
....................    return(nbcar); 
4EB0:  MOVFF  7C0,01
.................... } 
4EB4:  MOVLB  0
4EB6:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
4EB8:  MOVFF  7BB,7BF
4EBC:  MOVFF  7BA,7BE
4EC0:  MOVFF  7BD,7C1
4EC4:  MOVFF  7BC,7C0
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
4EC8:  MOVFF  7BF,03
4ECC:  MOVLB  7
4ECE:  MOVFF  7BE,FE9
4ED2:  MOVFF  7BF,FEA
4ED6:  MOVF   FEF,F
4ED8:  BZ    4F20
4EDA:  MOVFF  7C1,03
4EDE:  MOVFF  7C0,FE9
4EE2:  MOVFF  7C1,FEA
4EE6:  MOVF   FEF,F
4EE8:  BZ    4F20
....................       if(*aa!=*bb) 
4EEA:  MOVFF  7BE,FE9
4EEE:  MOVFF  7BF,FEA
4EF2:  MOVFF  FEF,7C2
4EF6:  MOVFF  7C1,03
4EFA:  MOVFF  7C0,FE9
4EFE:  MOVFF  7C1,FEA
4F02:  MOVF   FEF,W
4F04:  SUBWF  xC2,W
4F06:  BZ    4F0E
....................          return(1); 
4F08:  MOVLW  01
4F0A:  MOVWF  01
4F0C:  BRA    4F4C
....................       aa++; 
4F0E:  INCF   xBE,F
4F10:  BTFSC  FD8.2
4F12:  INCF   xBF,F
....................       bb++; 
4F14:  INCF   xC0,F
4F16:  BTFSC  FD8.2
4F18:  INCF   xC1,F
....................    } 
4F1A:  MOVLB  0
4F1C:  BRA    4EC8
4F1E:  MOVLB  7
....................    if(*aa!=*bb)return(1); 
4F20:  MOVFF  7BF,03
4F24:  MOVFF  7BE,FE9
4F28:  MOVFF  7BF,FEA
4F2C:  MOVFF  FEF,7C2
4F30:  MOVFF  7C1,03
4F34:  MOVFF  7C0,FE9
4F38:  MOVFF  7C1,FEA
4F3C:  MOVF   FEF,W
4F3E:  SUBWF  xC2,W
4F40:  BZ    4F48
4F42:  MOVLW  01
4F44:  MOVWF  01
4F46:  BRA    4F4C
....................    return(0); 
4F48:  MOVLW  00
4F4A:  MOVWF  01
.................... } 
4F4C:  MOVLB  0
4F4E:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
5492:  MOVLB  7
5494:  CLRF   xBC
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
5496:  MOVFF  7BB,03
549A:  MOVF   xBA,W
549C:  INCF   xBA,F
549E:  BTFSC  FD8.2
54A0:  INCF   xBB,F
54A2:  MOVWF  FE9
54A4:  MOVFF  03,FEA
54A8:  MOVFF  FEF,7BE
54AC:  MOVF   xBE,F
54AE:  BZ    54D2
....................         if (c >= '0' && c <= '9') 
54B0:  MOVF   xBE,W
54B2:  SUBLW  2F
54B4:  BC    54C4
54B6:  MOVF   xBE,W
54B8:  SUBLW  39
54BA:  BNC   54C4
....................             digit = (unsigned int) (c - '0'); 
54BC:  MOVLW  30
54BE:  SUBWF  xBE,W
54C0:  MOVWF  xBD
....................         else 
54C2:  BRA    54C6
....................             break; 
54C4:  BRA    54D2
....................  
....................         val = (val * 10) + digit; 
54C6:  MOVF   xBC,W
54C8:  MULLW  0A
54CA:  MOVF   FF3,W
54CC:  ADDWF  xBD,W
54CE:  MOVWF  xBC
....................     } 
54D0:  BRA    5496
....................  
....................     return val; 
54D2:  CLRF   03
54D4:  MOVFF  7BC,01
54D8:  MOVFF  03,02
.................... } 
54DC:  MOVLB  0
54DE:  RETURN 0
....................  
.................... int8 receiver_state=0,booting_done=0; 
.................... int16 over_byte=0; 
.................... //#include <GSM.c>  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
0494:  MOVLB  8
0496:  CLRF   x35
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
0498:  CLRF   x36
049A:  BTFSC  x2D.0
049C:  BSF    x36.7
049E:  SWAPF  x2E,W
04A0:  MOVWF  00
04A2:  RLCF   00,F
04A4:  RLCF   00,F
04A6:  MOVLW  C0
04A8:  ANDWF  00,F
04AA:  MOVF   00,W
04AC:  IORWF  x36,F
04AE:  SWAPF  x2F,W
04B0:  MOVWF  00
04B2:  RLCF   00,F
04B4:  MOVLW  E0
04B6:  ANDWF  00,F
04B8:  MOVF   00,W
04BA:  IORWF  x36,F
04BC:  SWAPF  x30,W
04BE:  MOVWF  00
04C0:  MOVLW  F0
04C2:  ANDWF  00,F
04C4:  MOVF   00,W
04C6:  IORWF  x36,F
04C8:  RLCF   x31,W
04CA:  MOVWF  00
04CC:  RLCF   00,F
04CE:  RLCF   00,F
04D0:  MOVLW  F8
04D2:  ANDWF  00,F
04D4:  MOVF   00,W
04D6:  IORWF  x36,F
04D8:  RLCF   x32,W
04DA:  MOVWF  00
04DC:  RLCF   00,F
04DE:  MOVLW  FC
04E0:  ANDWF  00,F
04E2:  MOVF   00,W
04E4:  IORWF  x36,F
04E6:  BCF    FD8.0
04E8:  RLCF   x33,W
04EA:  IORWF  x36,F
04EC:  MOVF   x34,W
04EE:  IORWF  x36,W
04F0:  MOVWF  x35
....................    return temp; 
04F2:  MOVFF  835,01
.................... } 
04F6:  MOVLB  0
04F8:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
04FA:  MOVLB  8
04FC:  CLRF   x1D
....................    int8 temp=0; 
....................    if(direct==0) 
04FE:  MOVF   x18,F
0500:  BNZ   05D6
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
0502:  MOVF   x1B,W
0504:  ADDWF  x19,W
0506:  MOVWF  FE9
0508:  MOVF   x1C,W
050A:  ADDWFC x1A,W
050C:  MOVWF  FEA
050E:  MOVFF  FEF,81E
0512:  MOVLW  01
0514:  ADDWF  x19,W
0516:  MOVWF  x1F
0518:  MOVLW  00
051A:  ADDWFC x1A,W
051C:  MOVWF  x20
051E:  MOVF   x1B,W
0520:  ADDWF  x1F,W
0522:  MOVWF  FE9
0524:  MOVF   x1C,W
0526:  ADDWFC x20,W
0528:  MOVWF  FEA
052A:  MOVF   FEF,W
052C:  XORWF  x1E,F
052E:  MOVLW  02
0530:  ADDWF  x19,W
0532:  MOVWF  x21
0534:  MOVLW  00
0536:  ADDWFC x1A,W
0538:  MOVWF  x22
053A:  MOVF   x1B,W
053C:  ADDWF  x21,W
053E:  MOVWF  FE9
0540:  MOVF   x1C,W
0542:  ADDWFC x22,W
0544:  MOVWF  FEA
0546:  MOVF   FEF,W
0548:  XORWF  x1E,F
054A:  MOVLW  03
054C:  ADDWF  x19,W
054E:  MOVWF  x23
0550:  MOVLW  00
0552:  ADDWFC x1A,W
0554:  MOVWF  x24
0556:  MOVF   x1B,W
0558:  ADDWF  x23,W
055A:  MOVWF  FE9
055C:  MOVF   x1C,W
055E:  ADDWFC x24,W
0560:  MOVWF  FEA
0562:  MOVF   FEF,W
0564:  XORWF  x1E,F
0566:  MOVLW  04
0568:  ADDWF  x19,W
056A:  MOVWF  x25
056C:  MOVLW  00
056E:  ADDWFC x1A,W
0570:  MOVWF  x26
0572:  MOVF   x1B,W
0574:  ADDWF  x25,W
0576:  MOVWF  FE9
0578:  MOVF   x1C,W
057A:  ADDWFC x26,W
057C:  MOVWF  FEA
057E:  MOVF   FEF,W
0580:  XORWF  x1E,F
0582:  MOVLW  05
0584:  ADDWF  x19,W
0586:  MOVWF  x27
0588:  MOVLW  00
058A:  ADDWFC x1A,W
058C:  MOVWF  x28
058E:  MOVF   x1B,W
0590:  ADDWF  x27,W
0592:  MOVWF  FE9
0594:  MOVF   x1C,W
0596:  ADDWFC x28,W
0598:  MOVWF  FEA
059A:  MOVF   FEF,W
059C:  XORWF  x1E,W
059E:  BZ    05A4
05A0:  MOVLW  00
05A2:  BRA    05A6
05A4:  MOVLW  01
05A6:  MOVWF  x1D
....................       if(temp==datain[offset+6]) return 1; 
05A8:  MOVLW  06
05AA:  ADDWF  x19,W
05AC:  MOVWF  x1E
05AE:  MOVLW  00
05B0:  ADDWFC x1A,W
05B2:  MOVWF  x1F
05B4:  MOVF   x1B,W
05B6:  ADDWF  x1E,W
05B8:  MOVWF  FE9
05BA:  MOVF   x1C,W
05BC:  ADDWFC x1F,W
05BE:  MOVWF  FEA
05C0:  MOVF   FEF,W
05C2:  SUBWF  x1D,W
05C4:  BNZ   05CE
05C6:  MOVLW  01
05C8:  MOVWF  01
05CA:  BRA    06A6
....................          else return 0; 
05CC:  BRA    05D4
05CE:  MOVLW  00
05D0:  MOVWF  01
05D2:  BRA    06A6
....................    } 
....................       else  
05D4:  BRA    06A6
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
05D6:  MOVF   x1B,W
05D8:  ADDWF  x19,W
05DA:  MOVWF  FE9
05DC:  MOVF   x1C,W
05DE:  ADDWFC x1A,W
05E0:  MOVWF  FEA
05E2:  MOVFF  FEF,81E
05E6:  MOVLW  01
05E8:  SUBWF  x19,W
05EA:  MOVWF  x1F
05EC:  MOVLW  00
05EE:  SUBWFB x1A,W
05F0:  MOVWF  x20
05F2:  MOVF   x1B,W
05F4:  ADDWF  x1F,W
05F6:  MOVWF  FE9
05F8:  MOVF   x1C,W
05FA:  ADDWFC x20,W
05FC:  MOVWF  FEA
05FE:  MOVF   FEF,W
0600:  XORWF  x1E,F
0602:  MOVLW  02
0604:  SUBWF  x19,W
0606:  MOVWF  x21
0608:  MOVLW  00
060A:  SUBWFB x1A,W
060C:  MOVWF  x22
060E:  MOVF   x1B,W
0610:  ADDWF  x21,W
0612:  MOVWF  FE9
0614:  MOVF   x1C,W
0616:  ADDWFC x22,W
0618:  MOVWF  FEA
061A:  MOVF   FEF,W
061C:  XORWF  x1E,F
061E:  MOVLW  03
0620:  SUBWF  x19,W
0622:  MOVWF  x23
0624:  MOVLW  00
0626:  SUBWFB x1A,W
0628:  MOVWF  x24
062A:  MOVF   x1B,W
062C:  ADDWF  x23,W
062E:  MOVWF  FE9
0630:  MOVF   x1C,W
0632:  ADDWFC x24,W
0634:  MOVWF  FEA
0636:  MOVF   FEF,W
0638:  XORWF  x1E,F
063A:  MOVLW  04
063C:  SUBWF  x19,W
063E:  MOVWF  x25
0640:  MOVLW  00
0642:  SUBWFB x1A,W
0644:  MOVWF  x26
0646:  MOVF   x1B,W
0648:  ADDWF  x25,W
064A:  MOVWF  FE9
064C:  MOVF   x1C,W
064E:  ADDWFC x26,W
0650:  MOVWF  FEA
0652:  MOVF   FEF,W
0654:  XORWF  x1E,F
0656:  MOVLW  05
0658:  SUBWF  x19,W
065A:  MOVWF  x27
065C:  MOVLW  00
065E:  SUBWFB x1A,W
0660:  MOVWF  x28
0662:  MOVF   x1B,W
0664:  ADDWF  x27,W
0666:  MOVWF  FE9
0668:  MOVF   x1C,W
066A:  ADDWFC x28,W
066C:  MOVWF  FEA
066E:  MOVF   FEF,W
0670:  XORWF  x1E,W
0672:  BZ    0678
0674:  MOVLW  00
0676:  BRA    067A
0678:  MOVLW  01
067A:  MOVWF  x1D
....................          if(temp==datain[offset-6]) return 1; 
067C:  MOVLW  06
067E:  SUBWF  x19,W
0680:  MOVWF  x1E
0682:  MOVLW  00
0684:  SUBWFB x1A,W
0686:  MOVWF  x1F
0688:  MOVF   x1B,W
068A:  ADDWF  x1E,W
068C:  MOVWF  FE9
068E:  MOVF   x1C,W
0690:  ADDWFC x1F,W
0692:  MOVWF  FEA
0694:  MOVF   FEF,W
0696:  SUBWF  x1D,W
0698:  BNZ   06A2
069A:  MOVLW  01
069C:  MOVWF  01
069E:  BRA    06A6
....................             else return 0;          
06A0:  BRA    06A6
06A2:  MOVLW  00
06A4:  MOVWF  01
....................       } 
.................... } 
06A6:  MOVLB  0
06A8:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
06AA:  MOVLB  8
06AC:  CLRF   x1D
....................    int8 temp=0; 
....................    if(direct==0) 
06AE:  MOVF   x18,F
06B0:  BNZ   074E
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
06B2:  MOVF   x1B,W
06B4:  ADDWF  x19,W
06B6:  MOVWF  FE9
06B8:  MOVF   x1C,W
06BA:  ADDWFC x1A,W
06BC:  MOVWF  FEA
06BE:  MOVFF  FEF,81E
06C2:  MOVLW  01
06C4:  ADDWF  x19,W
06C6:  MOVWF  x1F
06C8:  MOVLW  00
06CA:  ADDWFC x1A,W
06CC:  MOVWF  x20
06CE:  MOVF   x1B,W
06D0:  ADDWF  x1F,W
06D2:  MOVWF  FE9
06D4:  MOVF   x1C,W
06D6:  ADDWFC x20,W
06D8:  MOVWF  FEA
06DA:  MOVF   FEF,W
06DC:  XORWF  x1E,F
06DE:  MOVLW  02
06E0:  ADDWF  x19,W
06E2:  MOVWF  x21
06E4:  MOVLW  00
06E6:  ADDWFC x1A,W
06E8:  MOVWF  x22
06EA:  MOVF   x1B,W
06EC:  ADDWF  x21,W
06EE:  MOVWF  FE9
06F0:  MOVF   x1C,W
06F2:  ADDWFC x22,W
06F4:  MOVWF  FEA
06F6:  MOVF   FEF,W
06F8:  XORWF  x1E,F
06FA:  MOVLW  03
06FC:  ADDWF  x19,W
06FE:  MOVWF  x23
0700:  MOVLW  00
0702:  ADDWFC x1A,W
0704:  MOVWF  x24
0706:  MOVF   x1B,W
0708:  ADDWF  x23,W
070A:  MOVWF  FE9
070C:  MOVF   x1C,W
070E:  ADDWFC x24,W
0710:  MOVWF  FEA
0712:  MOVF   FEF,W
0714:  XORWF  x1E,W
0716:  BZ    071C
0718:  MOVLW  00
071A:  BRA    071E
071C:  MOVLW  01
071E:  MOVWF  x1D
....................       if(temp==datain[offset+4]) return 1; 
0720:  MOVLW  04
0722:  ADDWF  x19,W
0724:  MOVWF  x1E
0726:  MOVLW  00
0728:  ADDWFC x1A,W
072A:  MOVWF  x1F
072C:  MOVF   x1B,W
072E:  ADDWF  x1E,W
0730:  MOVWF  FE9
0732:  MOVF   x1C,W
0734:  ADDWFC x1F,W
0736:  MOVWF  FEA
0738:  MOVF   FEF,W
073A:  SUBWF  x1D,W
073C:  BNZ   0746
073E:  MOVLW  01
0740:  MOVWF  01
0742:  BRA    07E6
....................          else return 0; 
0744:  BRA    074C
0746:  MOVLW  00
0748:  MOVWF  01
074A:  BRA    07E6
....................    } 
....................    else 
074C:  BRA    07E6
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
074E:  MOVF   x1B,W
0750:  ADDWF  x19,W
0752:  MOVWF  FE9
0754:  MOVF   x1C,W
0756:  ADDWFC x1A,W
0758:  MOVWF  FEA
075A:  MOVFF  FEF,81E
075E:  MOVLW  01
0760:  SUBWF  x19,W
0762:  MOVWF  x1F
0764:  MOVLW  00
0766:  SUBWFB x1A,W
0768:  MOVWF  x20
076A:  MOVF   x1B,W
076C:  ADDWF  x1F,W
076E:  MOVWF  FE9
0770:  MOVF   x1C,W
0772:  ADDWFC x20,W
0774:  MOVWF  FEA
0776:  MOVF   FEF,W
0778:  XORWF  x1E,F
077A:  MOVLW  02
077C:  SUBWF  x19,W
077E:  MOVWF  x21
0780:  MOVLW  00
0782:  SUBWFB x1A,W
0784:  MOVWF  x22
0786:  MOVF   x1B,W
0788:  ADDWF  x21,W
078A:  MOVWF  FE9
078C:  MOVF   x1C,W
078E:  ADDWFC x22,W
0790:  MOVWF  FEA
0792:  MOVF   FEF,W
0794:  XORWF  x1E,F
0796:  MOVLW  03
0798:  SUBWF  x19,W
079A:  MOVWF  x23
079C:  MOVLW  00
079E:  SUBWFB x1A,W
07A0:  MOVWF  x24
07A2:  MOVF   x1B,W
07A4:  ADDWF  x23,W
07A6:  MOVWF  FE9
07A8:  MOVF   x1C,W
07AA:  ADDWFC x24,W
07AC:  MOVWF  FEA
07AE:  MOVF   FEF,W
07B0:  XORWF  x1E,W
07B2:  BZ    07B8
07B4:  MOVLW  00
07B6:  BRA    07BA
07B8:  MOVLW  01
07BA:  MOVWF  x1D
....................       if(temp==datain[offset-4]) return 1; 
07BC:  MOVLW  04
07BE:  SUBWF  x19,W
07C0:  MOVWF  x1E
07C2:  MOVLW  00
07C4:  SUBWFB x1A,W
07C6:  MOVWF  x1F
07C8:  MOVF   x1B,W
07CA:  ADDWF  x1E,W
07CC:  MOVWF  FE9
07CE:  MOVF   x1C,W
07D0:  ADDWFC x1F,W
07D2:  MOVWF  FEA
07D4:  MOVF   FEF,W
07D6:  SUBWF  x1D,W
07D8:  BNZ   07E2
07DA:  MOVLW  01
07DC:  MOVWF  01
07DE:  BRA    07E6
....................          else return 0;                
07E0:  BRA    07E6
07E2:  MOVLW  00
07E4:  MOVWF  01
....................    } 
.................... } 
07E6:  MOVLB  0
07E8:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
07EA:  MOVLB  7
07EC:  CLRF   xFE
07EE:  CLRF   xFF
07F0:  MOVLB  8
07F2:  CLRF   x00
07F4:  CLRF   x01
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
07F6:  MOVLB  7
07F8:  CLRF   xFB
07FA:  CLRF   xFA
07FC:  RRCF   xF7,W
07FE:  MOVWF  03
0800:  RRCF   xF6,W
0802:  MOVWF  02
0804:  RRCF   03,F
0806:  RRCF   02,F
0808:  MOVLW  3F
080A:  ANDWF  03,F
080C:  MOVFF  02,01
0810:  MOVF   xFB,W
0812:  SUBWF  03,W
0814:  BTFSS  FD8.0
0816:  GOTO   1018
081A:  BNZ   0826
081C:  MOVF   01,W
081E:  SUBWF  xFA,W
0820:  BTFSC  FD8.0
0822:  GOTO   1018
....................    { 
....................       if(track==0) 
0826:  MOVF   xF5,F
0828:  BTFSS  FD8.2
082A:  BRA    0CA8
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
082C:  MOVLW  06
082E:  ADDWF  xFA,W
0830:  MOVLB  8
0832:  MOVWF  x02
0834:  MOVLW  00
0836:  MOVLB  7
0838:  ADDWFC xFB,W
083A:  MOVLB  8
083C:  MOVWF  x03
083E:  MOVLB  7
0840:  MOVF   xF8,W
0842:  MOVLB  8
0844:  ADDWF  x02,W
0846:  MOVWF  FE9
0848:  MOVLB  7
084A:  MOVF   xF9,W
084C:  MOVLB  8
084E:  ADDWFC x03,W
0850:  MOVWF  FEA
0852:  MOVFF  FEF,804
0856:  MOVLW  05
0858:  MOVLB  7
085A:  ADDWF  xFA,W
085C:  MOVLB  8
085E:  MOVWF  x05
0860:  MOVLW  00
0862:  MOVLB  7
0864:  ADDWFC xFB,W
0866:  MOVLB  8
0868:  MOVWF  x06
086A:  MOVLB  7
086C:  MOVF   xF8,W
086E:  MOVLB  8
0870:  ADDWF  x05,W
0872:  MOVWF  FE9
0874:  MOVLB  7
0876:  MOVF   xF9,W
0878:  MOVLB  8
087A:  ADDWFC x06,W
087C:  MOVWF  FEA
087E:  MOVFF  FEF,807
0882:  MOVLW  04
0884:  MOVLB  7
0886:  ADDWF  xFA,W
0888:  MOVLB  8
088A:  MOVWF  x08
088C:  MOVLW  00
088E:  MOVLB  7
0890:  ADDWFC xFB,W
0892:  MOVLB  8
0894:  MOVWF  x09
0896:  MOVLB  7
0898:  MOVF   xF8,W
089A:  MOVLB  8
089C:  ADDWF  x08,W
089E:  MOVWF  FE9
08A0:  MOVLB  7
08A2:  MOVF   xF9,W
08A4:  MOVLB  8
08A6:  ADDWFC x09,W
08A8:  MOVWF  FEA
08AA:  MOVFF  FEF,80A
08AE:  MOVLW  03
08B0:  MOVLB  7
08B2:  ADDWF  xFA,W
08B4:  MOVLB  8
08B6:  MOVWF  x0B
08B8:  MOVLW  00
08BA:  MOVLB  7
08BC:  ADDWFC xFB,W
08BE:  MOVLB  8
08C0:  MOVWF  x0C
08C2:  MOVLB  7
08C4:  MOVF   xF8,W
08C6:  MOVLB  8
08C8:  ADDWF  x0B,W
08CA:  MOVWF  FE9
08CC:  MOVLB  7
08CE:  MOVF   xF9,W
08D0:  MOVLB  8
08D2:  ADDWFC x0C,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEF,80D
08DA:  MOVLW  02
08DC:  MOVLB  7
08DE:  ADDWF  xFA,W
08E0:  MOVLB  8
08E2:  MOVWF  x0E
08E4:  MOVLW  00
08E6:  MOVLB  7
08E8:  ADDWFC xFB,W
08EA:  MOVLB  8
08EC:  MOVWF  x0F
08EE:  MOVLB  7
08F0:  MOVF   xF8,W
08F2:  MOVLB  8
08F4:  ADDWF  x0E,W
08F6:  MOVWF  FE9
08F8:  MOVLB  7
08FA:  MOVF   xF9,W
08FC:  MOVLB  8
08FE:  ADDWFC x0F,W
0900:  MOVWF  FEA
0902:  MOVFF  FEF,810
0906:  MOVLW  01
0908:  MOVLB  7
090A:  ADDWF  xFA,W
090C:  MOVLB  8
090E:  MOVWF  x11
0910:  MOVLW  00
0912:  MOVLB  7
0914:  ADDWFC xFB,W
0916:  MOVLB  8
0918:  MOVWF  x12
091A:  MOVLB  7
091C:  MOVF   xF8,W
091E:  MOVLB  8
0920:  ADDWF  x11,W
0922:  MOVWF  FE9
0924:  MOVLB  7
0926:  MOVF   xF9,W
0928:  MOVLB  8
092A:  ADDWFC x12,W
092C:  MOVWF  FEA
092E:  MOVFF  FEF,813
0932:  MOVLB  7
0934:  MOVF   xF8,W
0936:  ADDWF  xFA,W
0938:  MOVWF  FE9
093A:  MOVF   xF9,W
093C:  ADDWFC xFB,W
093E:  MOVWF  FEA
0940:  MOVFF  FEF,814
0944:  MOVLB  8
0946:  CLRF   x2D
0948:  MOVFF  804,82E
094C:  MOVFF  807,82F
0950:  MOVFF  80A,830
0954:  MOVFF  80D,831
0958:  MOVFF  810,832
095C:  MOVFF  813,833
0960:  MOVFF  814,834
0964:  MOVLB  0
0966:  RCALL  0494
0968:  MOVFF  01,7FE
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
096C:  MOVLW  0D
096E:  MOVLB  7
0970:  ADDWF  xFA,W
0972:  MOVLB  8
0974:  MOVWF  x02
0976:  MOVLW  00
0978:  MOVLB  7
097A:  ADDWFC xFB,W
097C:  MOVLB  8
097E:  MOVWF  x03
0980:  MOVLB  7
0982:  MOVF   xF8,W
0984:  MOVLB  8
0986:  ADDWF  x02,W
0988:  MOVWF  FE9
098A:  MOVLB  7
098C:  MOVF   xF9,W
098E:  MOVLB  8
0990:  ADDWFC x03,W
0992:  MOVWF  FEA
0994:  MOVFF  FEF,804
0998:  MOVLW  0C
099A:  MOVLB  7
099C:  ADDWF  xFA,W
099E:  MOVLB  8
09A0:  MOVWF  x05
09A2:  MOVLW  00
09A4:  MOVLB  7
09A6:  ADDWFC xFB,W
09A8:  MOVLB  8
09AA:  MOVWF  x06
09AC:  MOVLB  7
09AE:  MOVF   xF8,W
09B0:  MOVLB  8
09B2:  ADDWF  x05,W
09B4:  MOVWF  FE9
09B6:  MOVLB  7
09B8:  MOVF   xF9,W
09BA:  MOVLB  8
09BC:  ADDWFC x06,W
09BE:  MOVWF  FEA
09C0:  MOVFF  FEF,807
09C4:  MOVLW  0B
09C6:  MOVLB  7
09C8:  ADDWF  xFA,W
09CA:  MOVLB  8
09CC:  MOVWF  x08
09CE:  MOVLW  00
09D0:  MOVLB  7
09D2:  ADDWFC xFB,W
09D4:  MOVLB  8
09D6:  MOVWF  x09
09D8:  MOVLB  7
09DA:  MOVF   xF8,W
09DC:  MOVLB  8
09DE:  ADDWF  x08,W
09E0:  MOVWF  FE9
09E2:  MOVLB  7
09E4:  MOVF   xF9,W
09E6:  MOVLB  8
09E8:  ADDWFC x09,W
09EA:  MOVWF  FEA
09EC:  MOVFF  FEF,80A
09F0:  MOVLW  0A
09F2:  MOVLB  7
09F4:  ADDWF  xFA,W
09F6:  MOVLB  8
09F8:  MOVWF  x0B
09FA:  MOVLW  00
09FC:  MOVLB  7
09FE:  ADDWFC xFB,W
0A00:  MOVLB  8
0A02:  MOVWF  x0C
0A04:  MOVLB  7
0A06:  MOVF   xF8,W
0A08:  MOVLB  8
0A0A:  ADDWF  x0B,W
0A0C:  MOVWF  FE9
0A0E:  MOVLB  7
0A10:  MOVF   xF9,W
0A12:  MOVLB  8
0A14:  ADDWFC x0C,W
0A16:  MOVWF  FEA
0A18:  MOVFF  FEF,80D
0A1C:  MOVLW  09
0A1E:  MOVLB  7
0A20:  ADDWF  xFA,W
0A22:  MOVLB  8
0A24:  MOVWF  x0E
0A26:  MOVLW  00
0A28:  MOVLB  7
0A2A:  ADDWFC xFB,W
0A2C:  MOVLB  8
0A2E:  MOVWF  x0F
0A30:  MOVLB  7
0A32:  MOVF   xF8,W
0A34:  MOVLB  8
0A36:  ADDWF  x0E,W
0A38:  MOVWF  FE9
0A3A:  MOVLB  7
0A3C:  MOVF   xF9,W
0A3E:  MOVLB  8
0A40:  ADDWFC x0F,W
0A42:  MOVWF  FEA
0A44:  MOVFF  FEF,810
0A48:  MOVLW  08
0A4A:  MOVLB  7
0A4C:  ADDWF  xFA,W
0A4E:  MOVLB  8
0A50:  MOVWF  x11
0A52:  MOVLW  00
0A54:  MOVLB  7
0A56:  ADDWFC xFB,W
0A58:  MOVLB  8
0A5A:  MOVWF  x12
0A5C:  MOVLB  7
0A5E:  MOVF   xF8,W
0A60:  MOVLB  8
0A62:  ADDWF  x11,W
0A64:  MOVWF  FE9
0A66:  MOVLB  7
0A68:  MOVF   xF9,W
0A6A:  MOVLB  8
0A6C:  ADDWFC x12,W
0A6E:  MOVWF  FEA
0A70:  MOVFF  FEF,813
0A74:  MOVLW  07
0A76:  MOVLB  7
0A78:  ADDWF  xFA,W
0A7A:  MOVLB  8
0A7C:  MOVWF  x14
0A7E:  MOVLW  00
0A80:  MOVLB  7
0A82:  ADDWFC xFB,W
0A84:  MOVLB  8
0A86:  MOVWF  x15
0A88:  MOVLB  7
0A8A:  MOVF   xF8,W
0A8C:  MOVLB  8
0A8E:  ADDWF  x14,W
0A90:  MOVWF  FE9
0A92:  MOVLB  7
0A94:  MOVF   xF9,W
0A96:  MOVLB  8
0A98:  ADDWFC x15,W
0A9A:  MOVWF  FEA
0A9C:  MOVFF  FEF,816
0AA0:  CLRF   x2D
0AA2:  MOVFF  804,82E
0AA6:  MOVFF  807,82F
0AAA:  MOVFF  80A,830
0AAE:  MOVFF  80D,831
0AB2:  MOVFF  810,832
0AB6:  MOVFF  813,833
0ABA:  MOVFF  816,834
0ABE:  MOVLB  0
0AC0:  RCALL  0494
0AC2:  MOVFF  01,7FF
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0AC6:  MOVLB  7
0AC8:  MOVF   xFE,W
0ACA:  SUBLW  45
0ACC:  BTFSS  FD8.2
0ACE:  BRA    0CA2
0AD0:  MOVF   xFF,W
0AD2:  SUBLW  7C
0AD4:  BTFSC  FD8.2
0AD6:  BRA    0CA2
0AD8:  MOVF   xFF,W
0ADA:  SUBLW  3E
0ADC:  BTFSC  FD8.2
0ADE:  BRA    0CA2
0AE0:  MOVF   xFF,W
0AE2:  SUBLW  1F
0AE4:  BTFSC  FD8.2
0AE6:  BRA    0CA2
....................          { 
....................             j=i; 
0AE8:  MOVFF  7FB,7FD
0AEC:  MOVFF  7FA,7FC
....................             CRC=1; 
0AF0:  MOVLW  01
0AF2:  MOVLB  8
0AF4:  MOVWF  x01
....................             temp2=temp; 
0AF6:  MOVFF  7FE,800
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0AFA:  MOVF   x00,W
0AFC:  SUBLW  1F
0AFE:  BTFSC  FD8.2
0B00:  BRA    0C8C
0B02:  MOVLB  7
0B04:  MOVF   xFD,W
0B06:  SUBLW  03
0B08:  BTFSC  FD8.0
0B0A:  BRA    0B10
0B0C:  MOVLB  8
0B0E:  BRA    0C8C
0B10:  BNZ   0B1E
0B12:  MOVF   xFC,W
0B14:  SUBLW  E7
0B16:  BTFSC  FD8.0
0B18:  BRA    0B1E
0B1A:  MOVLB  8
0B1C:  BRA    0C8C
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0B1E:  MOVLB  8
0B20:  CLRF   x18
0B22:  MOVFF  7FD,81A
0B26:  MOVFF  7FC,819
0B2A:  MOVFF  7F9,81C
0B2E:  MOVFF  7F8,81B
0B32:  MOVLB  0
0B34:  RCALL  04FA
0B36:  MOVF   01,W
0B38:  MOVLB  8
0B3A:  ANDWF  x01,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0B3C:  MOVLW  06
0B3E:  MOVLB  7
0B40:  ADDWF  xFC,W
0B42:  MOVLB  8
0B44:  MOVWF  x02
0B46:  MOVLW  00
0B48:  MOVLB  7
0B4A:  ADDWFC xFD,W
0B4C:  MOVLB  8
0B4E:  MOVWF  x03
0B50:  MOVLB  7
0B52:  MOVF   xF8,W
0B54:  MOVLB  8
0B56:  ADDWF  x02,W
0B58:  MOVWF  FE9
0B5A:  MOVLB  7
0B5C:  MOVF   xF9,W
0B5E:  MOVLB  8
0B60:  ADDWFC x03,W
0B62:  MOVWF  FEA
0B64:  MOVFF  FEF,804
0B68:  MOVLW  05
0B6A:  MOVLB  7
0B6C:  ADDWF  xFC,W
0B6E:  MOVLB  8
0B70:  MOVWF  x05
0B72:  MOVLW  00
0B74:  MOVLB  7
0B76:  ADDWFC xFD,W
0B78:  MOVLB  8
0B7A:  MOVWF  x06
0B7C:  MOVLB  7
0B7E:  MOVF   xF8,W
0B80:  MOVLB  8
0B82:  ADDWF  x05,W
0B84:  MOVWF  FE9
0B86:  MOVLB  7
0B88:  MOVF   xF9,W
0B8A:  MOVLB  8
0B8C:  ADDWFC x06,W
0B8E:  MOVWF  FEA
0B90:  MOVFF  FEF,807
0B94:  MOVLW  04
0B96:  MOVLB  7
0B98:  ADDWF  xFC,W
0B9A:  MOVLB  8
0B9C:  MOVWF  x08
0B9E:  MOVLW  00
0BA0:  MOVLB  7
0BA2:  ADDWFC xFD,W
0BA4:  MOVLB  8
0BA6:  MOVWF  x09
0BA8:  MOVLB  7
0BAA:  MOVF   xF8,W
0BAC:  MOVLB  8
0BAE:  ADDWF  x08,W
0BB0:  MOVWF  FE9
0BB2:  MOVLB  7
0BB4:  MOVF   xF9,W
0BB6:  MOVLB  8
0BB8:  ADDWFC x09,W
0BBA:  MOVWF  FEA
0BBC:  MOVFF  FEF,80A
0BC0:  MOVLW  03
0BC2:  MOVLB  7
0BC4:  ADDWF  xFC,W
0BC6:  MOVLB  8
0BC8:  MOVWF  x0B
0BCA:  MOVLW  00
0BCC:  MOVLB  7
0BCE:  ADDWFC xFD,W
0BD0:  MOVLB  8
0BD2:  MOVWF  x0C
0BD4:  MOVLB  7
0BD6:  MOVF   xF8,W
0BD8:  MOVLB  8
0BDA:  ADDWF  x0B,W
0BDC:  MOVWF  FE9
0BDE:  MOVLB  7
0BE0:  MOVF   xF9,W
0BE2:  MOVLB  8
0BE4:  ADDWFC x0C,W
0BE6:  MOVWF  FEA
0BE8:  MOVFF  FEF,80D
0BEC:  MOVLW  02
0BEE:  MOVLB  7
0BF0:  ADDWF  xFC,W
0BF2:  MOVLB  8
0BF4:  MOVWF  x0E
0BF6:  MOVLW  00
0BF8:  MOVLB  7
0BFA:  ADDWFC xFD,W
0BFC:  MOVLB  8
0BFE:  MOVWF  x0F
0C00:  MOVLB  7
0C02:  MOVF   xF8,W
0C04:  MOVLB  8
0C06:  ADDWF  x0E,W
0C08:  MOVWF  FE9
0C0A:  MOVLB  7
0C0C:  MOVF   xF9,W
0C0E:  MOVLB  8
0C10:  ADDWFC x0F,W
0C12:  MOVWF  FEA
0C14:  MOVFF  FEF,810
0C18:  MOVLW  01
0C1A:  MOVLB  7
0C1C:  ADDWF  xFC,W
0C1E:  MOVLB  8
0C20:  MOVWF  x11
0C22:  MOVLW  00
0C24:  MOVLB  7
0C26:  ADDWFC xFD,W
0C28:  MOVLB  8
0C2A:  MOVWF  x12
0C2C:  MOVLB  7
0C2E:  MOVF   xF8,W
0C30:  MOVLB  8
0C32:  ADDWF  x11,W
0C34:  MOVWF  FE9
0C36:  MOVLB  7
0C38:  MOVF   xF9,W
0C3A:  MOVLB  8
0C3C:  ADDWFC x12,W
0C3E:  MOVWF  FEA
0C40:  MOVFF  FEF,813
0C44:  MOVLB  7
0C46:  MOVF   xF8,W
0C48:  ADDWF  xFC,W
0C4A:  MOVWF  FE9
0C4C:  MOVF   xF9,W
0C4E:  ADDWFC xFD,W
0C50:  MOVWF  FEA
0C52:  MOVFF  FEF,814
0C56:  MOVLB  8
0C58:  CLRF   x2D
0C5A:  MOVFF  804,82E
0C5E:  MOVFF  807,82F
0C62:  MOVFF  80A,830
0C66:  MOVFF  80D,831
0C6A:  MOVFF  810,832
0C6E:  MOVFF  813,833
0C72:  MOVFF  814,834
0C76:  MOVLB  0
0C78:  RCALL  0494
0C7A:  MOVFF  01,800
....................                j=j+7; 
0C7E:  MOVLW  07
0C80:  MOVLB  7
0C82:  ADDWF  xFC,F
0C84:  MOVLW  00
0C86:  ADDWFC xFD,F
....................             } 
0C88:  MOVLB  8
0C8A:  BRA    0AFA
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0C8C:  DECFSZ x01,W
0C8E:  BRA    0CA4
....................             { 
....................                dir=0; 
0C90:  MOVLB  6
0C92:  CLRF   x8F
....................                return i; 
0C94:  MOVLB  7
0C96:  MOVFF  7FA,01
0C9A:  MOVFF  7FB,02
0C9E:  GOTO   1860
0CA2:  MOVLB  8
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0CA4:  BRA    100C
0CA6:  MOVLB  7
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0CA8:  MOVLW  04
0CAA:  ADDWF  xFA,W
0CAC:  MOVLB  8
0CAE:  MOVWF  x02
0CB0:  MOVLW  00
0CB2:  MOVLB  7
0CB4:  ADDWFC xFB,W
0CB6:  MOVLB  8
0CB8:  MOVWF  x03
0CBA:  MOVLB  7
0CBC:  MOVF   xF8,W
0CBE:  MOVLB  8
0CC0:  ADDWF  x02,W
0CC2:  MOVWF  FE9
0CC4:  MOVLB  7
0CC6:  MOVF   xF9,W
0CC8:  MOVLB  8
0CCA:  ADDWFC x03,W
0CCC:  MOVWF  FEA
0CCE:  MOVFF  FEF,804
0CD2:  MOVLW  03
0CD4:  MOVLB  7
0CD6:  ADDWF  xFA,W
0CD8:  MOVLB  8
0CDA:  MOVWF  x05
0CDC:  MOVLW  00
0CDE:  MOVLB  7
0CE0:  ADDWFC xFB,W
0CE2:  MOVLB  8
0CE4:  MOVWF  x06
0CE6:  MOVLB  7
0CE8:  MOVF   xF8,W
0CEA:  MOVLB  8
0CEC:  ADDWF  x05,W
0CEE:  MOVWF  FE9
0CF0:  MOVLB  7
0CF2:  MOVF   xF9,W
0CF4:  MOVLB  8
0CF6:  ADDWFC x06,W
0CF8:  MOVWF  FEA
0CFA:  MOVFF  FEF,807
0CFE:  MOVLW  02
0D00:  MOVLB  7
0D02:  ADDWF  xFA,W
0D04:  MOVLB  8
0D06:  MOVWF  x08
0D08:  MOVLW  00
0D0A:  MOVLB  7
0D0C:  ADDWFC xFB,W
0D0E:  MOVLB  8
0D10:  MOVWF  x09
0D12:  MOVLB  7
0D14:  MOVF   xF8,W
0D16:  MOVLB  8
0D18:  ADDWF  x08,W
0D1A:  MOVWF  FE9
0D1C:  MOVLB  7
0D1E:  MOVF   xF9,W
0D20:  MOVLB  8
0D22:  ADDWFC x09,W
0D24:  MOVWF  FEA
0D26:  MOVFF  FEF,80A
0D2A:  MOVLW  01
0D2C:  MOVLB  7
0D2E:  ADDWF  xFA,W
0D30:  MOVLB  8
0D32:  MOVWF  x0B
0D34:  MOVLW  00
0D36:  MOVLB  7
0D38:  ADDWFC xFB,W
0D3A:  MOVLB  8
0D3C:  MOVWF  x0C
0D3E:  MOVLB  7
0D40:  MOVF   xF8,W
0D42:  MOVLB  8
0D44:  ADDWF  x0B,W
0D46:  MOVWF  FE9
0D48:  MOVLB  7
0D4A:  MOVF   xF9,W
0D4C:  MOVLB  8
0D4E:  ADDWFC x0C,W
0D50:  MOVWF  FEA
0D52:  MOVFF  FEF,80D
0D56:  MOVLB  7
0D58:  MOVF   xF8,W
0D5A:  ADDWF  xFA,W
0D5C:  MOVWF  FE9
0D5E:  MOVF   xF9,W
0D60:  ADDWFC xFB,W
0D62:  MOVWF  FEA
0D64:  MOVFF  FEF,80E
0D68:  MOVLB  8
0D6A:  CLRF   x2D
0D6C:  CLRF   x2E
0D6E:  CLRF   x2F
0D70:  MOVFF  804,830
0D74:  MOVFF  807,831
0D78:  MOVFF  80A,832
0D7C:  MOVFF  80D,833
0D80:  MOVFF  80E,834
0D84:  MOVLB  0
0D86:  CALL   0494
0D8A:  MOVFF  01,7FE
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0D8E:  MOVLW  09
0D90:  MOVLB  7
0D92:  ADDWF  xFA,W
0D94:  MOVLB  8
0D96:  MOVWF  x02
0D98:  MOVLW  00
0D9A:  MOVLB  7
0D9C:  ADDWFC xFB,W
0D9E:  MOVLB  8
0DA0:  MOVWF  x03
0DA2:  MOVLB  7
0DA4:  MOVF   xF8,W
0DA6:  MOVLB  8
0DA8:  ADDWF  x02,W
0DAA:  MOVWF  FE9
0DAC:  MOVLB  7
0DAE:  MOVF   xF9,W
0DB0:  MOVLB  8
0DB2:  ADDWFC x03,W
0DB4:  MOVWF  FEA
0DB6:  MOVFF  FEF,804
0DBA:  MOVLW  08
0DBC:  MOVLB  7
0DBE:  ADDWF  xFA,W
0DC0:  MOVLB  8
0DC2:  MOVWF  x05
0DC4:  MOVLW  00
0DC6:  MOVLB  7
0DC8:  ADDWFC xFB,W
0DCA:  MOVLB  8
0DCC:  MOVWF  x06
0DCE:  MOVLB  7
0DD0:  MOVF   xF8,W
0DD2:  MOVLB  8
0DD4:  ADDWF  x05,W
0DD6:  MOVWF  FE9
0DD8:  MOVLB  7
0DDA:  MOVF   xF9,W
0DDC:  MOVLB  8
0DDE:  ADDWFC x06,W
0DE0:  MOVWF  FEA
0DE2:  MOVFF  FEF,807
0DE6:  MOVLW  07
0DE8:  MOVLB  7
0DEA:  ADDWF  xFA,W
0DEC:  MOVLB  8
0DEE:  MOVWF  x08
0DF0:  MOVLW  00
0DF2:  MOVLB  7
0DF4:  ADDWFC xFB,W
0DF6:  MOVLB  8
0DF8:  MOVWF  x09
0DFA:  MOVLB  7
0DFC:  MOVF   xF8,W
0DFE:  MOVLB  8
0E00:  ADDWF  x08,W
0E02:  MOVWF  FE9
0E04:  MOVLB  7
0E06:  MOVF   xF9,W
0E08:  MOVLB  8
0E0A:  ADDWFC x09,W
0E0C:  MOVWF  FEA
0E0E:  MOVFF  FEF,80A
0E12:  MOVLW  06
0E14:  MOVLB  7
0E16:  ADDWF  xFA,W
0E18:  MOVLB  8
0E1A:  MOVWF  x0B
0E1C:  MOVLW  00
0E1E:  MOVLB  7
0E20:  ADDWFC xFB,W
0E22:  MOVLB  8
0E24:  MOVWF  x0C
0E26:  MOVLB  7
0E28:  MOVF   xF8,W
0E2A:  MOVLB  8
0E2C:  ADDWF  x0B,W
0E2E:  MOVWF  FE9
0E30:  MOVLB  7
0E32:  MOVF   xF9,W
0E34:  MOVLB  8
0E36:  ADDWFC x0C,W
0E38:  MOVWF  FEA
0E3A:  MOVFF  FEF,80D
0E3E:  MOVLW  05
0E40:  MOVLB  7
0E42:  ADDWF  xFA,W
0E44:  MOVLB  8
0E46:  MOVWF  x0E
0E48:  MOVLW  00
0E4A:  MOVLB  7
0E4C:  ADDWFC xFB,W
0E4E:  MOVLB  8
0E50:  MOVWF  x0F
0E52:  MOVLB  7
0E54:  MOVF   xF8,W
0E56:  MOVLB  8
0E58:  ADDWF  x0E,W
0E5A:  MOVWF  FE9
0E5C:  MOVLB  7
0E5E:  MOVF   xF9,W
0E60:  MOVLB  8
0E62:  ADDWFC x0F,W
0E64:  MOVWF  FEA
0E66:  MOVFF  FEF,810
0E6A:  CLRF   x2D
0E6C:  CLRF   x2E
0E6E:  CLRF   x2F
0E70:  MOVFF  804,830
0E74:  MOVFF  807,831
0E78:  MOVFF  80A,832
0E7C:  MOVFF  80D,833
0E80:  MOVFF  810,834
0E84:  MOVLB  0
0E86:  CALL   0494
0E8A:  MOVFF  01,7FF
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0E8E:  MOVLB  7
0E90:  MOVF   xFE,W
0E92:  SUBLW  0B
0E94:  BTFSS  FD8.2
0E96:  BRA    100A
0E98:  MOVF   xFF,W
0E9A:  SUBLW  1F
0E9C:  BTFSC  FD8.2
0E9E:  BRA    100A
0EA0:  MOVF   xFF,W
0EA2:  SUBLW  0F
0EA4:  BTFSC  FD8.2
0EA6:  BRA    100A
....................             { 
....................                j=i; 
0EA8:  MOVFF  7FB,7FD
0EAC:  MOVFF  7FA,7FC
....................                CRC=1; 
0EB0:  MOVLW  01
0EB2:  MOVLB  8
0EB4:  MOVWF  x01
....................                temp2=temp; 
0EB6:  MOVFF  7FE,800
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0EBA:  MOVF   x00,W
0EBC:  SUBLW  1F
0EBE:  BTFSC  FD8.2
0EC0:  BRA    0FF4
0EC2:  MOVLB  7
0EC4:  MOVF   xFD,W
0EC6:  SUBLW  01
0EC8:  BTFSC  FD8.0
0ECA:  BRA    0ED0
0ECC:  MOVLB  8
0ECE:  BRA    0FF4
0ED0:  BNZ   0EDE
0ED2:  MOVF   xFC,W
0ED4:  SUBLW  F3
0ED6:  BTFSC  FD8.0
0ED8:  BRA    0EDE
0EDA:  MOVLB  8
0EDC:  BRA    0FF4
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0EDE:  MOVLB  8
0EE0:  CLRF   x18
0EE2:  MOVFF  7FD,81A
0EE6:  MOVFF  7FC,819
0EEA:  MOVFF  7F9,81C
0EEE:  MOVFF  7F8,81B
0EF2:  MOVLB  0
0EF4:  CALL   06AA
0EF8:  MOVF   01,W
0EFA:  MOVLB  8
0EFC:  ANDWF  x01,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0EFE:  MOVLW  04
0F00:  MOVLB  7
0F02:  ADDWF  xFC,W
0F04:  MOVLB  8
0F06:  MOVWF  x02
0F08:  MOVLW  00
0F0A:  MOVLB  7
0F0C:  ADDWFC xFD,W
0F0E:  MOVLB  8
0F10:  MOVWF  x03
0F12:  MOVLB  7
0F14:  MOVF   xF8,W
0F16:  MOVLB  8
0F18:  ADDWF  x02,W
0F1A:  MOVWF  FE9
0F1C:  MOVLB  7
0F1E:  MOVF   xF9,W
0F20:  MOVLB  8
0F22:  ADDWFC x03,W
0F24:  MOVWF  FEA
0F26:  MOVFF  FEF,804
0F2A:  MOVLW  03
0F2C:  MOVLB  7
0F2E:  ADDWF  xFC,W
0F30:  MOVLB  8
0F32:  MOVWF  x05
0F34:  MOVLW  00
0F36:  MOVLB  7
0F38:  ADDWFC xFD,W
0F3A:  MOVLB  8
0F3C:  MOVWF  x06
0F3E:  MOVLB  7
0F40:  MOVF   xF8,W
0F42:  MOVLB  8
0F44:  ADDWF  x05,W
0F46:  MOVWF  FE9
0F48:  MOVLB  7
0F4A:  MOVF   xF9,W
0F4C:  MOVLB  8
0F4E:  ADDWFC x06,W
0F50:  MOVWF  FEA
0F52:  MOVFF  FEF,807
0F56:  MOVLW  02
0F58:  MOVLB  7
0F5A:  ADDWF  xFC,W
0F5C:  MOVLB  8
0F5E:  MOVWF  x08
0F60:  MOVLW  00
0F62:  MOVLB  7
0F64:  ADDWFC xFD,W
0F66:  MOVLB  8
0F68:  MOVWF  x09
0F6A:  MOVLB  7
0F6C:  MOVF   xF8,W
0F6E:  MOVLB  8
0F70:  ADDWF  x08,W
0F72:  MOVWF  FE9
0F74:  MOVLB  7
0F76:  MOVF   xF9,W
0F78:  MOVLB  8
0F7A:  ADDWFC x09,W
0F7C:  MOVWF  FEA
0F7E:  MOVFF  FEF,80A
0F82:  MOVLW  01
0F84:  MOVLB  7
0F86:  ADDWF  xFC,W
0F88:  MOVLB  8
0F8A:  MOVWF  x0B
0F8C:  MOVLW  00
0F8E:  MOVLB  7
0F90:  ADDWFC xFD,W
0F92:  MOVLB  8
0F94:  MOVWF  x0C
0F96:  MOVLB  7
0F98:  MOVF   xF8,W
0F9A:  MOVLB  8
0F9C:  ADDWF  x0B,W
0F9E:  MOVWF  FE9
0FA0:  MOVLB  7
0FA2:  MOVF   xF9,W
0FA4:  MOVLB  8
0FA6:  ADDWFC x0C,W
0FA8:  MOVWF  FEA
0FAA:  MOVFF  FEF,80D
0FAE:  MOVLB  7
0FB0:  MOVF   xF8,W
0FB2:  ADDWF  xFC,W
0FB4:  MOVWF  FE9
0FB6:  MOVF   xF9,W
0FB8:  ADDWFC xFD,W
0FBA:  MOVWF  FEA
0FBC:  MOVFF  FEF,80E
0FC0:  MOVLB  8
0FC2:  CLRF   x2D
0FC4:  CLRF   x2E
0FC6:  CLRF   x2F
0FC8:  MOVFF  804,830
0FCC:  MOVFF  807,831
0FD0:  MOVFF  80A,832
0FD4:  MOVFF  80D,833
0FD8:  MOVFF  80E,834
0FDC:  MOVLB  0
0FDE:  CALL   0494
0FE2:  MOVFF  01,800
....................                   j=j+5; 
0FE6:  MOVLW  05
0FE8:  MOVLB  7
0FEA:  ADDWF  xFC,F
0FEC:  MOVLW  00
0FEE:  ADDWFC xFD,F
....................                } 
0FF0:  MOVLB  8
0FF2:  BRA    0EBA
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0FF4:  DECFSZ x01,W
0FF6:  BRA    100C
....................                { 
....................                   dir=0; 
0FF8:  MOVLB  6
0FFA:  CLRF   x8F
....................                   return i; 
0FFC:  MOVLB  7
0FFE:  MOVFF  7FA,01
1002:  MOVFF  7FB,02
1006:  GOTO   1860
100A:  MOVLB  8
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
100C:  MOVLB  7
100E:  INCF   xFA,F
1010:  BTFSC  FD8.2
1012:  INCF   xFB,F
1014:  GOTO   07FC
....................    for(i=end_point;i>end_point/4;i--) 
1018:  MOVFF  7F7,7FB
101C:  MOVFF  7F6,7FA
1020:  RRCF   xF7,W
1022:  MOVWF  03
1024:  RRCF   xF6,W
1026:  MOVWF  02
1028:  RRCF   03,F
102A:  RRCF   02,F
102C:  MOVLW  3F
102E:  ANDWF  03,F
1030:  MOVFF  02,01
1034:  MOVF   03,W
1036:  SUBWF  xFB,W
1038:  BTFSS  FD8.0
103A:  GOTO   185A
103E:  BNZ   104A
1040:  MOVF   xFA,W
1042:  SUBWF  01,W
1044:  BTFSC  FD8.0
1046:  GOTO   185A
....................    { 
....................       if(track==0) 
104A:  MOVF   xF5,F
104C:  BTFSS  FD8.2
104E:  BRA    14E6
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1050:  MOVLW  06
1052:  SUBWF  xFA,W
1054:  MOVLB  8
1056:  MOVWF  x02
1058:  MOVLW  00
105A:  MOVLB  7
105C:  SUBWFB xFB,W
105E:  MOVLB  8
1060:  MOVWF  x03
1062:  MOVLB  7
1064:  MOVF   xF8,W
1066:  MOVLB  8
1068:  ADDWF  x02,W
106A:  MOVWF  FE9
106C:  MOVLB  7
106E:  MOVF   xF9,W
1070:  MOVLB  8
1072:  ADDWFC x03,W
1074:  MOVWF  FEA
1076:  MOVFF  FEF,804
107A:  MOVLW  05
107C:  MOVLB  7
107E:  SUBWF  xFA,W
1080:  MOVLB  8
1082:  MOVWF  x05
1084:  MOVLW  00
1086:  MOVLB  7
1088:  SUBWFB xFB,W
108A:  MOVLB  8
108C:  MOVWF  x06
108E:  MOVLB  7
1090:  MOVF   xF8,W
1092:  MOVLB  8
1094:  ADDWF  x05,W
1096:  MOVWF  FE9
1098:  MOVLB  7
109A:  MOVF   xF9,W
109C:  MOVLB  8
109E:  ADDWFC x06,W
10A0:  MOVWF  FEA
10A2:  MOVFF  FEF,807
10A6:  MOVLW  04
10A8:  MOVLB  7
10AA:  SUBWF  xFA,W
10AC:  MOVLB  8
10AE:  MOVWF  x08
10B0:  MOVLW  00
10B2:  MOVLB  7
10B4:  SUBWFB xFB,W
10B6:  MOVLB  8
10B8:  MOVWF  x09
10BA:  MOVLB  7
10BC:  MOVF   xF8,W
10BE:  MOVLB  8
10C0:  ADDWF  x08,W
10C2:  MOVWF  FE9
10C4:  MOVLB  7
10C6:  MOVF   xF9,W
10C8:  MOVLB  8
10CA:  ADDWFC x09,W
10CC:  MOVWF  FEA
10CE:  MOVFF  FEF,80A
10D2:  MOVLW  03
10D4:  MOVLB  7
10D6:  SUBWF  xFA,W
10D8:  MOVLB  8
10DA:  MOVWF  x0B
10DC:  MOVLW  00
10DE:  MOVLB  7
10E0:  SUBWFB xFB,W
10E2:  MOVLB  8
10E4:  MOVWF  x0C
10E6:  MOVLB  7
10E8:  MOVF   xF8,W
10EA:  MOVLB  8
10EC:  ADDWF  x0B,W
10EE:  MOVWF  FE9
10F0:  MOVLB  7
10F2:  MOVF   xF9,W
10F4:  MOVLB  8
10F6:  ADDWFC x0C,W
10F8:  MOVWF  FEA
10FA:  MOVFF  FEF,80D
10FE:  MOVLW  02
1100:  MOVLB  7
1102:  SUBWF  xFA,W
1104:  MOVLB  8
1106:  MOVWF  x0E
1108:  MOVLW  00
110A:  MOVLB  7
110C:  SUBWFB xFB,W
110E:  MOVLB  8
1110:  MOVWF  x0F
1112:  MOVLB  7
1114:  MOVF   xF8,W
1116:  MOVLB  8
1118:  ADDWF  x0E,W
111A:  MOVWF  FE9
111C:  MOVLB  7
111E:  MOVF   xF9,W
1120:  MOVLB  8
1122:  ADDWFC x0F,W
1124:  MOVWF  FEA
1126:  MOVFF  FEF,810
112A:  MOVLW  01
112C:  MOVLB  7
112E:  SUBWF  xFA,W
1130:  MOVLB  8
1132:  MOVWF  x11
1134:  MOVLW  00
1136:  MOVLB  7
1138:  SUBWFB xFB,W
113A:  MOVLB  8
113C:  MOVWF  x12
113E:  MOVLB  7
1140:  MOVF   xF8,W
1142:  MOVLB  8
1144:  ADDWF  x11,W
1146:  MOVWF  FE9
1148:  MOVLB  7
114A:  MOVF   xF9,W
114C:  MOVLB  8
114E:  ADDWFC x12,W
1150:  MOVWF  FEA
1152:  MOVFF  FEF,813
1156:  MOVLB  7
1158:  MOVF   xF8,W
115A:  ADDWF  xFA,W
115C:  MOVWF  FE9
115E:  MOVF   xF9,W
1160:  ADDWFC xFB,W
1162:  MOVWF  FEA
1164:  MOVFF  FEF,814
1168:  MOVLB  8
116A:  CLRF   x2D
116C:  MOVFF  804,82E
1170:  MOVFF  807,82F
1174:  MOVFF  80A,830
1178:  MOVFF  80D,831
117C:  MOVFF  810,832
1180:  MOVFF  813,833
1184:  MOVFF  814,834
1188:  MOVLB  0
118A:  CALL   0494
118E:  MOVFF  01,7FE
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
1192:  MOVLW  0D
1194:  MOVLB  7
1196:  SUBWF  xFA,W
1198:  MOVLB  8
119A:  MOVWF  x02
119C:  MOVLW  00
119E:  MOVLB  7
11A0:  SUBWFB xFB,W
11A2:  MOVLB  8
11A4:  MOVWF  x03
11A6:  MOVLB  7
11A8:  MOVF   xF8,W
11AA:  MOVLB  8
11AC:  ADDWF  x02,W
11AE:  MOVWF  FE9
11B0:  MOVLB  7
11B2:  MOVF   xF9,W
11B4:  MOVLB  8
11B6:  ADDWFC x03,W
11B8:  MOVWF  FEA
11BA:  MOVFF  FEF,804
11BE:  MOVLW  0C
11C0:  MOVLB  7
11C2:  SUBWF  xFA,W
11C4:  MOVLB  8
11C6:  MOVWF  x05
11C8:  MOVLW  00
11CA:  MOVLB  7
11CC:  SUBWFB xFB,W
11CE:  MOVLB  8
11D0:  MOVWF  x06
11D2:  MOVLB  7
11D4:  MOVF   xF8,W
11D6:  MOVLB  8
11D8:  ADDWF  x05,W
11DA:  MOVWF  FE9
11DC:  MOVLB  7
11DE:  MOVF   xF9,W
11E0:  MOVLB  8
11E2:  ADDWFC x06,W
11E4:  MOVWF  FEA
11E6:  MOVFF  FEF,807
11EA:  MOVLW  0B
11EC:  MOVLB  7
11EE:  SUBWF  xFA,W
11F0:  MOVLB  8
11F2:  MOVWF  x08
11F4:  MOVLW  00
11F6:  MOVLB  7
11F8:  SUBWFB xFB,W
11FA:  MOVLB  8
11FC:  MOVWF  x09
11FE:  MOVLB  7
1200:  MOVF   xF8,W
1202:  MOVLB  8
1204:  ADDWF  x08,W
1206:  MOVWF  FE9
1208:  MOVLB  7
120A:  MOVF   xF9,W
120C:  MOVLB  8
120E:  ADDWFC x09,W
1210:  MOVWF  FEA
1212:  MOVFF  FEF,80A
1216:  MOVLW  0A
1218:  MOVLB  7
121A:  SUBWF  xFA,W
121C:  MOVLB  8
121E:  MOVWF  x0B
1220:  MOVLW  00
1222:  MOVLB  7
1224:  SUBWFB xFB,W
1226:  MOVLB  8
1228:  MOVWF  x0C
122A:  MOVLB  7
122C:  MOVF   xF8,W
122E:  MOVLB  8
1230:  ADDWF  x0B,W
1232:  MOVWF  FE9
1234:  MOVLB  7
1236:  MOVF   xF9,W
1238:  MOVLB  8
123A:  ADDWFC x0C,W
123C:  MOVWF  FEA
123E:  MOVFF  FEF,80D
1242:  MOVLW  09
1244:  MOVLB  7
1246:  SUBWF  xFA,W
1248:  MOVLB  8
124A:  MOVWF  x0E
124C:  MOVLW  00
124E:  MOVLB  7
1250:  SUBWFB xFB,W
1252:  MOVLB  8
1254:  MOVWF  x0F
1256:  MOVLB  7
1258:  MOVF   xF8,W
125A:  MOVLB  8
125C:  ADDWF  x0E,W
125E:  MOVWF  FE9
1260:  MOVLB  7
1262:  MOVF   xF9,W
1264:  MOVLB  8
1266:  ADDWFC x0F,W
1268:  MOVWF  FEA
126A:  MOVFF  FEF,810
126E:  MOVLW  08
1270:  MOVLB  7
1272:  SUBWF  xFA,W
1274:  MOVLB  8
1276:  MOVWF  x11
1278:  MOVLW  00
127A:  MOVLB  7
127C:  SUBWFB xFB,W
127E:  MOVLB  8
1280:  MOVWF  x12
1282:  MOVLB  7
1284:  MOVF   xF8,W
1286:  MOVLB  8
1288:  ADDWF  x11,W
128A:  MOVWF  FE9
128C:  MOVLB  7
128E:  MOVF   xF9,W
1290:  MOVLB  8
1292:  ADDWFC x12,W
1294:  MOVWF  FEA
1296:  MOVFF  FEF,813
129A:  MOVLW  07
129C:  MOVLB  7
129E:  SUBWF  xFA,W
12A0:  MOVLB  8
12A2:  MOVWF  x14
12A4:  MOVLW  00
12A6:  MOVLB  7
12A8:  SUBWFB xFB,W
12AA:  MOVLB  8
12AC:  MOVWF  x15
12AE:  MOVLB  7
12B0:  MOVF   xF8,W
12B2:  MOVLB  8
12B4:  ADDWF  x14,W
12B6:  MOVWF  FE9
12B8:  MOVLB  7
12BA:  MOVF   xF9,W
12BC:  MOVLB  8
12BE:  ADDWFC x15,W
12C0:  MOVWF  FEA
12C2:  MOVFF  FEF,816
12C6:  CLRF   x2D
12C8:  MOVFF  804,82E
12CC:  MOVFF  807,82F
12D0:  MOVFF  80A,830
12D4:  MOVFF  80D,831
12D8:  MOVFF  810,832
12DC:  MOVFF  813,833
12E0:  MOVFF  816,834
12E4:  MOVLB  0
12E6:  CALL   0494
12EA:  MOVFF  01,7FF
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
12EE:  MOVLB  7
12F0:  MOVF   xFE,W
12F2:  SUBLW  45
12F4:  BTFSS  FD8.2
12F6:  BRA    14E4
12F8:  MOVF   xFF,W
12FA:  SUBLW  7C
12FC:  BTFSC  FD8.2
12FE:  BRA    14E4
1300:  MOVF   xFF,W
1302:  SUBLW  3E
1304:  BTFSC  FD8.2
1306:  BRA    14E4
1308:  MOVF   xFF,W
130A:  SUBLW  1F
130C:  BTFSC  FD8.2
130E:  BRA    14E4
1310:  MOVF   xFF,W
1312:  SUBLW  0F
1314:  BTFSC  FD8.2
1316:  BRA    14E4
1318:  MOVF   xFF,W
131A:  SUBLW  78
131C:  BTFSC  FD8.2
131E:  BRA    14E4
....................          { 
....................             j=i; 
1320:  MOVFF  7FB,7FD
1324:  MOVFF  7FA,7FC
....................             CRC=1; 
1328:  MOVLW  01
132A:  MOVLB  8
132C:  MOVWF  x01
....................             temp2=temp; 
132E:  MOVFF  7FE,800
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
1332:  MOVF   x00,W
1334:  SUBLW  1F
1336:  BTFSC  FD8.2
1338:  BRA    14C0
133A:  MOVLB  7
133C:  MOVF   xFD,F
133E:  BNZ   134C
1340:  MOVF   xFC,W
1342:  SUBLW  01
1344:  BTFSS  FD8.0
1346:  BRA    134C
1348:  MOVLB  8
134A:  BRA    14C0
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
134C:  MOVLW  01
134E:  MOVLB  8
1350:  MOVWF  x18
1352:  MOVFF  7FD,81A
1356:  MOVFF  7FC,819
135A:  MOVFF  7F9,81C
135E:  MOVFF  7F8,81B
1362:  MOVLB  0
1364:  CALL   04FA
1368:  MOVF   01,W
136A:  MOVLB  8
136C:  ANDWF  x01,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
136E:  MOVLW  06
1370:  MOVLB  7
1372:  SUBWF  xFC,W
1374:  MOVLB  8
1376:  MOVWF  x02
1378:  MOVLW  00
137A:  MOVLB  7
137C:  SUBWFB xFD,W
137E:  MOVLB  8
1380:  MOVWF  x03
1382:  MOVLB  7
1384:  MOVF   xF8,W
1386:  MOVLB  8
1388:  ADDWF  x02,W
138A:  MOVWF  FE9
138C:  MOVLB  7
138E:  MOVF   xF9,W
1390:  MOVLB  8
1392:  ADDWFC x03,W
1394:  MOVWF  FEA
1396:  MOVFF  FEF,804
139A:  MOVLW  05
139C:  MOVLB  7
139E:  SUBWF  xFC,W
13A0:  MOVLB  8
13A2:  MOVWF  x05
13A4:  MOVLW  00
13A6:  MOVLB  7
13A8:  SUBWFB xFD,W
13AA:  MOVLB  8
13AC:  MOVWF  x06
13AE:  MOVLB  7
13B0:  MOVF   xF8,W
13B2:  MOVLB  8
13B4:  ADDWF  x05,W
13B6:  MOVWF  FE9
13B8:  MOVLB  7
13BA:  MOVF   xF9,W
13BC:  MOVLB  8
13BE:  ADDWFC x06,W
13C0:  MOVWF  FEA
13C2:  MOVFF  FEF,807
13C6:  MOVLW  04
13C8:  MOVLB  7
13CA:  SUBWF  xFC,W
13CC:  MOVLB  8
13CE:  MOVWF  x08
13D0:  MOVLW  00
13D2:  MOVLB  7
13D4:  SUBWFB xFD,W
13D6:  MOVLB  8
13D8:  MOVWF  x09
13DA:  MOVLB  7
13DC:  MOVF   xF8,W
13DE:  MOVLB  8
13E0:  ADDWF  x08,W
13E2:  MOVWF  FE9
13E4:  MOVLB  7
13E6:  MOVF   xF9,W
13E8:  MOVLB  8
13EA:  ADDWFC x09,W
13EC:  MOVWF  FEA
13EE:  MOVFF  FEF,80A
13F2:  MOVLW  03
13F4:  MOVLB  7
13F6:  SUBWF  xFC,W
13F8:  MOVLB  8
13FA:  MOVWF  x0B
13FC:  MOVLW  00
13FE:  MOVLB  7
1400:  SUBWFB xFD,W
1402:  MOVLB  8
1404:  MOVWF  x0C
1406:  MOVLB  7
1408:  MOVF   xF8,W
140A:  MOVLB  8
140C:  ADDWF  x0B,W
140E:  MOVWF  FE9
1410:  MOVLB  7
1412:  MOVF   xF9,W
1414:  MOVLB  8
1416:  ADDWFC x0C,W
1418:  MOVWF  FEA
141A:  MOVFF  FEF,80D
141E:  MOVLW  02
1420:  MOVLB  7
1422:  SUBWF  xFC,W
1424:  MOVLB  8
1426:  MOVWF  x0E
1428:  MOVLW  00
142A:  MOVLB  7
142C:  SUBWFB xFD,W
142E:  MOVLB  8
1430:  MOVWF  x0F
1432:  MOVLB  7
1434:  MOVF   xF8,W
1436:  MOVLB  8
1438:  ADDWF  x0E,W
143A:  MOVWF  FE9
143C:  MOVLB  7
143E:  MOVF   xF9,W
1440:  MOVLB  8
1442:  ADDWFC x0F,W
1444:  MOVWF  FEA
1446:  MOVFF  FEF,810
144A:  MOVLW  01
144C:  MOVLB  7
144E:  SUBWF  xFC,W
1450:  MOVLB  8
1452:  MOVWF  x11
1454:  MOVLW  00
1456:  MOVLB  7
1458:  SUBWFB xFD,W
145A:  MOVLB  8
145C:  MOVWF  x12
145E:  MOVLB  7
1460:  MOVF   xF8,W
1462:  MOVLB  8
1464:  ADDWF  x11,W
1466:  MOVWF  FE9
1468:  MOVLB  7
146A:  MOVF   xF9,W
146C:  MOVLB  8
146E:  ADDWFC x12,W
1470:  MOVWF  FEA
1472:  MOVFF  FEF,813
1476:  MOVLB  7
1478:  MOVF   xF8,W
147A:  ADDWF  xFC,W
147C:  MOVWF  FE9
147E:  MOVF   xF9,W
1480:  ADDWFC xFD,W
1482:  MOVWF  FEA
1484:  MOVFF  FEF,814
1488:  MOVLB  8
148A:  CLRF   x2D
148C:  MOVFF  804,82E
1490:  MOVFF  807,82F
1494:  MOVFF  80A,830
1498:  MOVFF  80D,831
149C:  MOVFF  810,832
14A0:  MOVFF  813,833
14A4:  MOVFF  814,834
14A8:  MOVLB  0
14AA:  CALL   0494
14AE:  MOVFF  01,800
....................                j=j-7;             
14B2:  MOVLW  07
14B4:  MOVLB  7
14B6:  SUBWF  xFC,F
14B8:  MOVLW  00
14BA:  SUBWFB xFD,F
....................              } 
14BC:  MOVLB  8
14BE:  BRA    1332
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
14C0:  DECFSZ x01,W
14C2:  BRA    14DA
....................             { 
....................                dir=1; 
14C4:  MOVLW  01
14C6:  MOVLB  6
14C8:  MOVWF  x8F
....................                return i; 
14CA:  MOVLB  7
14CC:  MOVFF  7FA,01
14D0:  MOVFF  7FB,02
14D4:  BRA    1860
....................             } 
....................             else return 0; 
14D6:  BRA    14E4
14D8:  MOVLB  8
14DA:  MOVLW  00
14DC:  MOVWF  01
14DE:  MOVWF  02
14E0:  MOVLB  7
14E2:  BRA    1860
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
14E4:  BRA    184E
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
14E6:  MOVLW  04
14E8:  SUBWF  xFA,W
14EA:  MOVLB  8
14EC:  MOVWF  x02
14EE:  MOVLW  00
14F0:  MOVLB  7
14F2:  SUBWFB xFB,W
14F4:  MOVLB  8
14F6:  MOVWF  x03
14F8:  MOVLB  7
14FA:  MOVF   xF8,W
14FC:  MOVLB  8
14FE:  ADDWF  x02,W
1500:  MOVWF  FE9
1502:  MOVLB  7
1504:  MOVF   xF9,W
1506:  MOVLB  8
1508:  ADDWFC x03,W
150A:  MOVWF  FEA
150C:  MOVFF  FEF,804
1510:  MOVLW  03
1512:  MOVLB  7
1514:  SUBWF  xFA,W
1516:  MOVLB  8
1518:  MOVWF  x05
151A:  MOVLW  00
151C:  MOVLB  7
151E:  SUBWFB xFB,W
1520:  MOVLB  8
1522:  MOVWF  x06
1524:  MOVLB  7
1526:  MOVF   xF8,W
1528:  MOVLB  8
152A:  ADDWF  x05,W
152C:  MOVWF  FE9
152E:  MOVLB  7
1530:  MOVF   xF9,W
1532:  MOVLB  8
1534:  ADDWFC x06,W
1536:  MOVWF  FEA
1538:  MOVFF  FEF,807
153C:  MOVLW  02
153E:  MOVLB  7
1540:  SUBWF  xFA,W
1542:  MOVLB  8
1544:  MOVWF  x08
1546:  MOVLW  00
1548:  MOVLB  7
154A:  SUBWFB xFB,W
154C:  MOVLB  8
154E:  MOVWF  x09
1550:  MOVLB  7
1552:  MOVF   xF8,W
1554:  MOVLB  8
1556:  ADDWF  x08,W
1558:  MOVWF  FE9
155A:  MOVLB  7
155C:  MOVF   xF9,W
155E:  MOVLB  8
1560:  ADDWFC x09,W
1562:  MOVWF  FEA
1564:  MOVFF  FEF,80A
1568:  MOVLW  01
156A:  MOVLB  7
156C:  SUBWF  xFA,W
156E:  MOVLB  8
1570:  MOVWF  x0B
1572:  MOVLW  00
1574:  MOVLB  7
1576:  SUBWFB xFB,W
1578:  MOVLB  8
157A:  MOVWF  x0C
157C:  MOVLB  7
157E:  MOVF   xF8,W
1580:  MOVLB  8
1582:  ADDWF  x0B,W
1584:  MOVWF  FE9
1586:  MOVLB  7
1588:  MOVF   xF9,W
158A:  MOVLB  8
158C:  ADDWFC x0C,W
158E:  MOVWF  FEA
1590:  MOVFF  FEF,80D
1594:  MOVLB  7
1596:  MOVF   xF8,W
1598:  ADDWF  xFA,W
159A:  MOVWF  FE9
159C:  MOVF   xF9,W
159E:  ADDWFC xFB,W
15A0:  MOVWF  FEA
15A2:  MOVFF  FEF,80E
15A6:  MOVLB  8
15A8:  CLRF   x2D
15AA:  CLRF   x2E
15AC:  CLRF   x2F
15AE:  MOVFF  804,830
15B2:  MOVFF  807,831
15B6:  MOVFF  80A,832
15BA:  MOVFF  80D,833
15BE:  MOVFF  80E,834
15C2:  MOVLB  0
15C4:  CALL   0494
15C8:  MOVFF  01,7FE
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
15CC:  MOVLW  09
15CE:  MOVLB  7
15D0:  SUBWF  xFA,W
15D2:  MOVLB  8
15D4:  MOVWF  x02
15D6:  MOVLW  00
15D8:  MOVLB  7
15DA:  SUBWFB xFB,W
15DC:  MOVLB  8
15DE:  MOVWF  x03
15E0:  MOVLB  7
15E2:  MOVF   xF8,W
15E4:  MOVLB  8
15E6:  ADDWF  x02,W
15E8:  MOVWF  FE9
15EA:  MOVLB  7
15EC:  MOVF   xF9,W
15EE:  MOVLB  8
15F0:  ADDWFC x03,W
15F2:  MOVWF  FEA
15F4:  MOVFF  FEF,804
15F8:  MOVLW  08
15FA:  MOVLB  7
15FC:  SUBWF  xFA,W
15FE:  MOVLB  8
1600:  MOVWF  x05
1602:  MOVLW  00
1604:  MOVLB  7
1606:  SUBWFB xFB,W
1608:  MOVLB  8
160A:  MOVWF  x06
160C:  MOVLB  7
160E:  MOVF   xF8,W
1610:  MOVLB  8
1612:  ADDWF  x05,W
1614:  MOVWF  FE9
1616:  MOVLB  7
1618:  MOVF   xF9,W
161A:  MOVLB  8
161C:  ADDWFC x06,W
161E:  MOVWF  FEA
1620:  MOVFF  FEF,807
1624:  MOVLW  07
1626:  MOVLB  7
1628:  SUBWF  xFA,W
162A:  MOVLB  8
162C:  MOVWF  x08
162E:  MOVLW  00
1630:  MOVLB  7
1632:  SUBWFB xFB,W
1634:  MOVLB  8
1636:  MOVWF  x09
1638:  MOVLB  7
163A:  MOVF   xF8,W
163C:  MOVLB  8
163E:  ADDWF  x08,W
1640:  MOVWF  FE9
1642:  MOVLB  7
1644:  MOVF   xF9,W
1646:  MOVLB  8
1648:  ADDWFC x09,W
164A:  MOVWF  FEA
164C:  MOVFF  FEF,80A
1650:  MOVLW  06
1652:  MOVLB  7
1654:  SUBWF  xFA,W
1656:  MOVLB  8
1658:  MOVWF  x0B
165A:  MOVLW  00
165C:  MOVLB  7
165E:  SUBWFB xFB,W
1660:  MOVLB  8
1662:  MOVWF  x0C
1664:  MOVLB  7
1666:  MOVF   xF8,W
1668:  MOVLB  8
166A:  ADDWF  x0B,W
166C:  MOVWF  FE9
166E:  MOVLB  7
1670:  MOVF   xF9,W
1672:  MOVLB  8
1674:  ADDWFC x0C,W
1676:  MOVWF  FEA
1678:  MOVFF  FEF,80D
167C:  MOVLW  05
167E:  MOVLB  7
1680:  SUBWF  xFA,W
1682:  MOVLB  8
1684:  MOVWF  x0E
1686:  MOVLW  00
1688:  MOVLB  7
168A:  SUBWFB xFB,W
168C:  MOVLB  8
168E:  MOVWF  x0F
1690:  MOVLB  7
1692:  MOVF   xF8,W
1694:  MOVLB  8
1696:  ADDWF  x0E,W
1698:  MOVWF  FE9
169A:  MOVLB  7
169C:  MOVF   xF9,W
169E:  MOVLB  8
16A0:  ADDWFC x0F,W
16A2:  MOVWF  FEA
16A4:  MOVFF  FEF,810
16A8:  CLRF   x2D
16AA:  CLRF   x2E
16AC:  CLRF   x2F
16AE:  MOVFF  804,830
16B2:  MOVFF  807,831
16B6:  MOVFF  80A,832
16BA:  MOVFF  80D,833
16BE:  MOVFF  810,834
16C2:  MOVLB  0
16C4:  CALL   0494
16C8:  MOVFF  01,7FF
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
16CC:  MOVLB  7
16CE:  MOVF   xFE,W
16D0:  SUBLW  0B
16D2:  BTFSS  FD8.2
16D4:  BRA    184E
16D6:  MOVF   xFF,W
16D8:  SUBLW  1F
16DA:  BTFSC  FD8.2
16DC:  BRA    184E
16DE:  MOVF   xFF,W
16E0:  SUBLW  0F
16E2:  BTFSC  FD8.2
16E4:  BRA    184E
....................             { 
....................                j=i; 
16E6:  MOVFF  7FB,7FD
16EA:  MOVFF  7FA,7FC
....................                CRC=1; 
16EE:  MOVLW  01
16F0:  MOVLB  8
16F2:  MOVWF  x01
....................                temp2=temp; 
16F4:  MOVFF  7FE,800
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
16F8:  MOVF   x00,W
16FA:  SUBLW  1F
16FC:  BTFSC  FD8.2
16FE:  BRA    182A
1700:  MOVLB  7
1702:  MOVF   xFD,F
1704:  BNZ   1712
1706:  MOVF   xFC,W
1708:  SUBLW  01
170A:  BTFSS  FD8.0
170C:  BRA    1712
170E:  MOVLB  8
1710:  BRA    182A
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1712:  MOVLW  01
1714:  MOVLB  8
1716:  MOVWF  x18
1718:  MOVFF  7FD,81A
171C:  MOVFF  7FC,819
1720:  MOVFF  7F9,81C
1724:  MOVFF  7F8,81B
1728:  MOVLB  0
172A:  CALL   06AA
172E:  MOVF   01,W
1730:  MOVLB  8
1732:  ANDWF  x01,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1734:  MOVLW  04
1736:  MOVLB  7
1738:  SUBWF  xFC,W
173A:  MOVLB  8
173C:  MOVWF  x02
173E:  MOVLW  00
1740:  MOVLB  7
1742:  SUBWFB xFD,W
1744:  MOVLB  8
1746:  MOVWF  x03
1748:  MOVLB  7
174A:  MOVF   xF8,W
174C:  MOVLB  8
174E:  ADDWF  x02,W
1750:  MOVWF  FE9
1752:  MOVLB  7
1754:  MOVF   xF9,W
1756:  MOVLB  8
1758:  ADDWFC x03,W
175A:  MOVWF  FEA
175C:  MOVFF  FEF,804
1760:  MOVLW  03
1762:  MOVLB  7
1764:  SUBWF  xFC,W
1766:  MOVLB  8
1768:  MOVWF  x05
176A:  MOVLW  00
176C:  MOVLB  7
176E:  SUBWFB xFD,W
1770:  MOVLB  8
1772:  MOVWF  x06
1774:  MOVLB  7
1776:  MOVF   xF8,W
1778:  MOVLB  8
177A:  ADDWF  x05,W
177C:  MOVWF  FE9
177E:  MOVLB  7
1780:  MOVF   xF9,W
1782:  MOVLB  8
1784:  ADDWFC x06,W
1786:  MOVWF  FEA
1788:  MOVFF  FEF,807
178C:  MOVLW  02
178E:  MOVLB  7
1790:  SUBWF  xFC,W
1792:  MOVLB  8
1794:  MOVWF  x08
1796:  MOVLW  00
1798:  MOVLB  7
179A:  SUBWFB xFD,W
179C:  MOVLB  8
179E:  MOVWF  x09
17A0:  MOVLB  7
17A2:  MOVF   xF8,W
17A4:  MOVLB  8
17A6:  ADDWF  x08,W
17A8:  MOVWF  FE9
17AA:  MOVLB  7
17AC:  MOVF   xF9,W
17AE:  MOVLB  8
17B0:  ADDWFC x09,W
17B2:  MOVWF  FEA
17B4:  MOVFF  FEF,80A
17B8:  MOVLW  01
17BA:  MOVLB  7
17BC:  SUBWF  xFC,W
17BE:  MOVLB  8
17C0:  MOVWF  x0B
17C2:  MOVLW  00
17C4:  MOVLB  7
17C6:  SUBWFB xFD,W
17C8:  MOVLB  8
17CA:  MOVWF  x0C
17CC:  MOVLB  7
17CE:  MOVF   xF8,W
17D0:  MOVLB  8
17D2:  ADDWF  x0B,W
17D4:  MOVWF  FE9
17D6:  MOVLB  7
17D8:  MOVF   xF9,W
17DA:  MOVLB  8
17DC:  ADDWFC x0C,W
17DE:  MOVWF  FEA
17E0:  MOVFF  FEF,80D
17E4:  MOVLB  7
17E6:  MOVF   xF8,W
17E8:  ADDWF  xFC,W
17EA:  MOVWF  FE9
17EC:  MOVF   xF9,W
17EE:  ADDWFC xFD,W
17F0:  MOVWF  FEA
17F2:  MOVFF  FEF,80E
17F6:  MOVLB  8
17F8:  CLRF   x2D
17FA:  CLRF   x2E
17FC:  CLRF   x2F
17FE:  MOVFF  804,830
1802:  MOVFF  807,831
1806:  MOVFF  80A,832
180A:  MOVFF  80D,833
180E:  MOVFF  80E,834
1812:  MOVLB  0
1814:  CALL   0494
1818:  MOVFF  01,800
....................                   j=j-5; 
181C:  MOVLW  05
181E:  MOVLB  7
1820:  SUBWF  xFC,F
1822:  MOVLW  00
1824:  SUBWFB xFD,F
....................                } 
1826:  MOVLB  8
1828:  BRA    16F8
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
182A:  DECFSZ x01,W
182C:  BRA    1844
....................                { 
....................                   dir=1; 
182E:  MOVLW  01
1830:  MOVLB  6
1832:  MOVWF  x8F
....................                   return i; 
1834:  MOVLB  7
1836:  MOVFF  7FA,01
183A:  MOVFF  7FB,02
183E:  BRA    1860
....................                } 
....................                   else return 0; 
1840:  BRA    184E
1842:  MOVLB  8
1844:  MOVLW  00
1846:  MOVWF  01
1848:  MOVWF  02
184A:  MOVLB  7
184C:  BRA    1860
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
184E:  MOVF   xFA,W
1850:  BTFSC  FD8.2
1852:  DECF   xFB,F
1854:  DECF   xFA,F
1856:  GOTO   1020
....................    return 0; 
185A:  MOVLW  00
185C:  MOVWF  01
185E:  MOVWF  02
.................... } 
1860:  MOVLB  0
1862:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
394C:  MOVLB  7
394E:  CLRF   xF4
3950:  MOVLW  01
3952:  MOVWF  xF3
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3954:  MOVFF  7E9,7F5
3958:  MOVFF  7EB,7F7
395C:  MOVFF  7EA,7F6
3960:  MOVFF  7ED,7F9
3964:  MOVFF  7EC,7F8
3968:  MOVLB  0
396A:  CALL   07EA
396E:  MOVFF  02,7F4
3972:  MOVFF  01,7F3
....................    if(temp==0) return 0; 
3976:  MOVLB  7
3978:  MOVF   xF3,F
397A:  BNZ   3986
397C:  MOVF   xF4,F
397E:  BNZ   3986
3980:  MOVLW  00
3982:  MOVWF  01
3984:  BRA    3D7C
....................    j=temp; 
3986:  MOVFF  7F4,7F2
398A:  MOVFF  7F3,7F1
....................    if(dir==0) 
398E:  MOVLB  6
3990:  MOVF   x8F,F
3992:  BTFSS  FD8.2
3994:  BRA    3B76
....................    { 
....................       if(track==0) 
3996:  MOVLB  7
3998:  MOVF   xE9,F
399A:  BTFSS  FD8.2
399C:  BRA    3AB8
....................       { 
....................             for(i=0;i<79;i++) 
399E:  CLRF   xF0
39A0:  MOVF   xF0,W
39A2:  SUBLW  4E
39A4:  BTFSS  FD8.0
39A6:  BRA    3AB6
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
39A8:  CLRF   03
39AA:  MOVF   xF0,W
39AC:  ADDWF  xEE,W
39AE:  MOVWF  01
39B0:  MOVF   xEF,W
39B2:  ADDWFC 03,F
39B4:  MOVFF  01,7F5
39B8:  MOVFF  03,7F6
39BC:  MOVLW  05
39BE:  ADDWF  xF1,W
39C0:  MOVWF  xF7
39C2:  MOVLW  00
39C4:  ADDWFC xF2,W
39C6:  MOVWF  xF8
39C8:  MOVF   xEC,W
39CA:  ADDWF  xF7,W
39CC:  MOVWF  FE9
39CE:  MOVF   xED,W
39D0:  ADDWFC xF8,W
39D2:  MOVWF  FEA
39D4:  MOVFF  FEF,7F9
39D8:  MOVLW  04
39DA:  ADDWF  xF1,W
39DC:  MOVWF  xFA
39DE:  MOVLW  00
39E0:  ADDWFC xF2,W
39E2:  MOVWF  xFB
39E4:  MOVF   xEC,W
39E6:  ADDWF  xFA,W
39E8:  MOVWF  FE9
39EA:  MOVF   xED,W
39EC:  ADDWFC xFB,W
39EE:  MOVWF  FEA
39F0:  MOVFF  FEF,7FC
39F4:  MOVLW  03
39F6:  ADDWF  xF1,W
39F8:  MOVWF  xFD
39FA:  MOVLW  00
39FC:  ADDWFC xF2,W
39FE:  MOVWF  xFE
3A00:  MOVF   xEC,W
3A02:  ADDWF  xFD,W
3A04:  MOVWF  FE9
3A06:  MOVF   xED,W
3A08:  ADDWFC xFE,W
3A0A:  MOVWF  FEA
3A0C:  MOVFF  FEF,7FF
3A10:  MOVLW  02
3A12:  ADDWF  xF1,W
3A14:  MOVLB  8
3A16:  MOVWF  x00
3A18:  MOVLW  00
3A1A:  MOVLB  7
3A1C:  ADDWFC xF2,W
3A1E:  MOVLB  8
3A20:  MOVWF  x01
3A22:  MOVLB  7
3A24:  MOVF   xEC,W
3A26:  MOVLB  8
3A28:  ADDWF  x00,W
3A2A:  MOVWF  FE9
3A2C:  MOVLB  7
3A2E:  MOVF   xED,W
3A30:  MOVLB  8
3A32:  ADDWFC x01,W
3A34:  MOVWF  FEA
3A36:  MOVFF  FEF,802
3A3A:  MOVLW  01
3A3C:  MOVLB  7
3A3E:  ADDWF  xF1,W
3A40:  MOVLB  8
3A42:  MOVWF  x03
3A44:  MOVLW  00
3A46:  MOVLB  7
3A48:  ADDWFC xF2,W
3A4A:  MOVLB  8
3A4C:  MOVWF  x04
3A4E:  MOVLB  7
3A50:  MOVF   xEC,W
3A52:  MOVLB  8
3A54:  ADDWF  x03,W
3A56:  MOVWF  FE9
3A58:  MOVLB  7
3A5A:  MOVF   xED,W
3A5C:  MOVLB  8
3A5E:  ADDWFC x04,W
3A60:  MOVWF  FEA
3A62:  MOVFF  FEF,805
3A66:  MOVLB  7
3A68:  MOVF   xEC,W
3A6A:  ADDWF  xF1,W
3A6C:  MOVWF  FE9
3A6E:  MOVF   xED,W
3A70:  ADDWFC xF2,W
3A72:  MOVWF  FEA
3A74:  MOVFF  FEF,806
3A78:  MOVLB  8
3A7A:  CLRF   x2D
3A7C:  CLRF   x2E
3A7E:  MOVFF  7F9,82F
3A82:  MOVFF  7FC,830
3A86:  MOVFF  7FF,831
3A8A:  MOVFF  802,832
3A8E:  MOVFF  805,833
3A92:  MOVFF  806,834
3A96:  MOVLB  0
3A98:  CALL   0494
3A9C:  MOVFF  7F6,FEA
3AA0:  MOVFF  7F5,FE9
3AA4:  MOVFF  01,FEF
....................                j=j+7; 
3AA8:  MOVLW  07
3AAA:  MOVLB  7
3AAC:  ADDWF  xF1,F
3AAE:  MOVLW  00
3AB0:  ADDWFC xF2,F
....................             } 
3AB2:  INCF   xF0,F
3AB4:  BRA    39A0
....................       } 
....................          else  
3AB6:  BRA    3B72
....................          { 
....................             for(i=0;i<40;i++) 
3AB8:  CLRF   xF0
3ABA:  MOVF   xF0,W
3ABC:  SUBLW  27
3ABE:  BNC   3B72
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3AC0:  CLRF   03
3AC2:  MOVF   xF0,W
3AC4:  ADDWF  xEE,W
3AC6:  MOVWF  01
3AC8:  MOVF   xEF,W
3ACA:  ADDWFC 03,F
3ACC:  MOVFF  01,7F5
3AD0:  MOVFF  03,7F6
3AD4:  MOVLW  03
3AD6:  ADDWF  xF1,W
3AD8:  MOVWF  xF7
3ADA:  MOVLW  00
3ADC:  ADDWFC xF2,W
3ADE:  MOVWF  xF8
3AE0:  MOVF   xEC,W
3AE2:  ADDWF  xF7,W
3AE4:  MOVWF  FE9
3AE6:  MOVF   xED,W
3AE8:  ADDWFC xF8,W
3AEA:  MOVWF  FEA
3AEC:  MOVFF  FEF,7F9
3AF0:  MOVLW  02
3AF2:  ADDWF  xF1,W
3AF4:  MOVWF  xFA
3AF6:  MOVLW  00
3AF8:  ADDWFC xF2,W
3AFA:  MOVWF  xFB
3AFC:  MOVF   xEC,W
3AFE:  ADDWF  xFA,W
3B00:  MOVWF  FE9
3B02:  MOVF   xED,W
3B04:  ADDWFC xFB,W
3B06:  MOVWF  FEA
3B08:  MOVFF  FEF,7FC
3B0C:  MOVLW  01
3B0E:  ADDWF  xF1,W
3B10:  MOVWF  xFD
3B12:  MOVLW  00
3B14:  ADDWFC xF2,W
3B16:  MOVWF  xFE
3B18:  MOVF   xEC,W
3B1A:  ADDWF  xFD,W
3B1C:  MOVWF  FE9
3B1E:  MOVF   xED,W
3B20:  ADDWFC xFE,W
3B22:  MOVWF  FEA
3B24:  MOVFF  FEF,7FF
3B28:  MOVF   xEC,W
3B2A:  ADDWF  xF1,W
3B2C:  MOVWF  FE9
3B2E:  MOVF   xED,W
3B30:  ADDWFC xF2,W
3B32:  MOVWF  FEA
3B34:  MOVFF  FEF,800
3B38:  MOVLB  8
3B3A:  CLRF   x2D
3B3C:  CLRF   x2E
3B3E:  CLRF   x2F
3B40:  CLRF   x30
3B42:  MOVFF  7F9,831
3B46:  MOVFF  7FC,832
3B4A:  MOVFF  7FF,833
3B4E:  MOVFF  800,834
3B52:  MOVLB  0
3B54:  CALL   0494
3B58:  MOVFF  7F6,FEA
3B5C:  MOVFF  7F5,FE9
3B60:  MOVFF  01,FEF
....................                j=j+5; 
3B64:  MOVLW  05
3B66:  MOVLB  7
3B68:  ADDWF  xF1,F
3B6A:  MOVLW  00
3B6C:  ADDWFC xF2,F
....................             }          
3B6E:  INCF   xF0,F
3B70:  BRA    3ABA
....................          } 
....................    } 
....................       else  
3B72:  BRA    3D52
3B74:  MOVLB  6
....................       { 
....................          if(track==0) 
3B76:  MOVLB  7
3B78:  MOVF   xE9,F
3B7A:  BTFSS  FD8.2
3B7C:  BRA    3C98
....................          { 
....................             for(i=0;i<79;i++) 
3B7E:  CLRF   xF0
3B80:  MOVF   xF0,W
3B82:  SUBLW  4E
3B84:  BTFSS  FD8.0
3B86:  BRA    3C96
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3B88:  CLRF   03
3B8A:  MOVF   xF0,W
3B8C:  ADDWF  xEE,W
3B8E:  MOVWF  01
3B90:  MOVF   xEF,W
3B92:  ADDWFC 03,F
3B94:  MOVFF  01,7F5
3B98:  MOVFF  03,7F6
3B9C:  MOVLW  05
3B9E:  SUBWF  xF1,W
3BA0:  MOVWF  xF7
3BA2:  MOVLW  00
3BA4:  SUBWFB xF2,W
3BA6:  MOVWF  xF8
3BA8:  MOVF   xEC,W
3BAA:  ADDWF  xF7,W
3BAC:  MOVWF  FE9
3BAE:  MOVF   xED,W
3BB0:  ADDWFC xF8,W
3BB2:  MOVWF  FEA
3BB4:  MOVFF  FEF,7F9
3BB8:  MOVLW  04
3BBA:  SUBWF  xF1,W
3BBC:  MOVWF  xFA
3BBE:  MOVLW  00
3BC0:  SUBWFB xF2,W
3BC2:  MOVWF  xFB
3BC4:  MOVF   xEC,W
3BC6:  ADDWF  xFA,W
3BC8:  MOVWF  FE9
3BCA:  MOVF   xED,W
3BCC:  ADDWFC xFB,W
3BCE:  MOVWF  FEA
3BD0:  MOVFF  FEF,7FC
3BD4:  MOVLW  03
3BD6:  SUBWF  xF1,W
3BD8:  MOVWF  xFD
3BDA:  MOVLW  00
3BDC:  SUBWFB xF2,W
3BDE:  MOVWF  xFE
3BE0:  MOVF   xEC,W
3BE2:  ADDWF  xFD,W
3BE4:  MOVWF  FE9
3BE6:  MOVF   xED,W
3BE8:  ADDWFC xFE,W
3BEA:  MOVWF  FEA
3BEC:  MOVFF  FEF,7FF
3BF0:  MOVLW  02
3BF2:  SUBWF  xF1,W
3BF4:  MOVLB  8
3BF6:  MOVWF  x00
3BF8:  MOVLW  00
3BFA:  MOVLB  7
3BFC:  SUBWFB xF2,W
3BFE:  MOVLB  8
3C00:  MOVWF  x01
3C02:  MOVLB  7
3C04:  MOVF   xEC,W
3C06:  MOVLB  8
3C08:  ADDWF  x00,W
3C0A:  MOVWF  FE9
3C0C:  MOVLB  7
3C0E:  MOVF   xED,W
3C10:  MOVLB  8
3C12:  ADDWFC x01,W
3C14:  MOVWF  FEA
3C16:  MOVFF  FEF,802
3C1A:  MOVLW  01
3C1C:  MOVLB  7
3C1E:  SUBWF  xF1,W
3C20:  MOVLB  8
3C22:  MOVWF  x03
3C24:  MOVLW  00
3C26:  MOVLB  7
3C28:  SUBWFB xF2,W
3C2A:  MOVLB  8
3C2C:  MOVWF  x04
3C2E:  MOVLB  7
3C30:  MOVF   xEC,W
3C32:  MOVLB  8
3C34:  ADDWF  x03,W
3C36:  MOVWF  FE9
3C38:  MOVLB  7
3C3A:  MOVF   xED,W
3C3C:  MOVLB  8
3C3E:  ADDWFC x04,W
3C40:  MOVWF  FEA
3C42:  MOVFF  FEF,805
3C46:  MOVLB  7
3C48:  MOVF   xEC,W
3C4A:  ADDWF  xF1,W
3C4C:  MOVWF  FE9
3C4E:  MOVF   xED,W
3C50:  ADDWFC xF2,W
3C52:  MOVWF  FEA
3C54:  MOVFF  FEF,806
3C58:  MOVLB  8
3C5A:  CLRF   x2D
3C5C:  CLRF   x2E
3C5E:  MOVFF  7F9,82F
3C62:  MOVFF  7FC,830
3C66:  MOVFF  7FF,831
3C6A:  MOVFF  802,832
3C6E:  MOVFF  805,833
3C72:  MOVFF  806,834
3C76:  MOVLB  0
3C78:  CALL   0494
3C7C:  MOVFF  7F6,FEA
3C80:  MOVFF  7F5,FE9
3C84:  MOVFF  01,FEF
....................                j=j-7; 
3C88:  MOVLW  07
3C8A:  MOVLB  7
3C8C:  SUBWF  xF1,F
3C8E:  MOVLW  00
3C90:  SUBWFB xF2,F
....................             } 
3C92:  INCF   xF0,F
3C94:  BRA    3B80
....................          } 
....................             else 
3C96:  BRA    3D52
....................             { 
....................                for(i=0;i<40;i++) 
3C98:  CLRF   xF0
3C9A:  MOVF   xF0,W
3C9C:  SUBLW  27
3C9E:  BNC   3D52
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3CA0:  CLRF   03
3CA2:  MOVF   xF0,W
3CA4:  ADDWF  xEE,W
3CA6:  MOVWF  01
3CA8:  MOVF   xEF,W
3CAA:  ADDWFC 03,F
3CAC:  MOVFF  01,7F5
3CB0:  MOVFF  03,7F6
3CB4:  MOVLW  03
3CB6:  SUBWF  xF1,W
3CB8:  MOVWF  xF7
3CBA:  MOVLW  00
3CBC:  SUBWFB xF2,W
3CBE:  MOVWF  xF8
3CC0:  MOVF   xEC,W
3CC2:  ADDWF  xF7,W
3CC4:  MOVWF  FE9
3CC6:  MOVF   xED,W
3CC8:  ADDWFC xF8,W
3CCA:  MOVWF  FEA
3CCC:  MOVFF  FEF,7F9
3CD0:  MOVLW  02
3CD2:  SUBWF  xF1,W
3CD4:  MOVWF  xFA
3CD6:  MOVLW  00
3CD8:  SUBWFB xF2,W
3CDA:  MOVWF  xFB
3CDC:  MOVF   xEC,W
3CDE:  ADDWF  xFA,W
3CE0:  MOVWF  FE9
3CE2:  MOVF   xED,W
3CE4:  ADDWFC xFB,W
3CE6:  MOVWF  FEA
3CE8:  MOVFF  FEF,7FC
3CEC:  MOVLW  01
3CEE:  SUBWF  xF1,W
3CF0:  MOVWF  xFD
3CF2:  MOVLW  00
3CF4:  SUBWFB xF2,W
3CF6:  MOVWF  xFE
3CF8:  MOVF   xEC,W
3CFA:  ADDWF  xFD,W
3CFC:  MOVWF  FE9
3CFE:  MOVF   xED,W
3D00:  ADDWFC xFE,W
3D02:  MOVWF  FEA
3D04:  MOVFF  FEF,7FF
3D08:  MOVF   xEC,W
3D0A:  ADDWF  xF1,W
3D0C:  MOVWF  FE9
3D0E:  MOVF   xED,W
3D10:  ADDWFC xF2,W
3D12:  MOVWF  FEA
3D14:  MOVFF  FEF,800
3D18:  MOVLB  8
3D1A:  CLRF   x2D
3D1C:  CLRF   x2E
3D1E:  CLRF   x2F
3D20:  CLRF   x30
3D22:  MOVFF  7F9,831
3D26:  MOVFF  7FC,832
3D2A:  MOVFF  7FF,833
3D2E:  MOVFF  800,834
3D32:  MOVLB  0
3D34:  CALL   0494
3D38:  MOVFF  7F6,FEA
3D3C:  MOVFF  7F5,FE9
3D40:  MOVFF  01,FEF
....................                   j=j-5; 
3D44:  MOVLW  05
3D46:  MOVLB  7
3D48:  SUBWF  xF1,F
3D4A:  MOVLW  00
3D4C:  SUBWFB xF2,F
....................                }             
3D4E:  INCF   xF0,F
3D50:  BRA    3C9A
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3D52:  MOVF   xE9,F
3D54:  BNZ   3D6A
3D56:  MOVLW  52
3D58:  MOVWF  xF5
3D5A:  MOVFF  7ED,7F7
3D5E:  MOVFF  7EC,7F6
3D62:  MOVLB  0
3D64:  RCALL  392A
....................          else del_buf(numbyteofbuffer2,datin); 
3D66:  BRA    3D7A
3D68:  MOVLB  7
3D6A:  MOVLW  2C
3D6C:  MOVWF  xF5
3D6E:  MOVFF  7ED,7F7
3D72:  MOVFF  7EC,7F6
3D76:  MOVLB  0
3D78:  RCALL  392A
3D7A:  MOVLB  7
.................... } 
3D7C:  MOVLB  0
3D7E:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1A40:  MOVLW  38
1A42:  MOVWF  FF6
1A44:  MOVLW  03
1A46:  MOVWF  FF7
1A48:  CALL   0474
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1A4C:  MOVLB  7
1A4E:  CLRF   xED
1A50:  CLRF   xEC
1A52:  MOVF   xED,W
1A54:  SUBLW  03
1A56:  BNC   1A86
1A58:  BNZ   1A60
1A5A:  MOVF   xEC,W
1A5C:  SUBLW  51
1A5E:  BNC   1A86
1A60:  MOVLW  0D
1A62:  ADDWF  xEC,W
1A64:  MOVWF  FE9
1A66:  MOVLW  02
1A68:  ADDWFC xED,W
1A6A:  MOVWF  FEA
1A6C:  MOVFF  FEF,7EE
1A70:  MOVFF  7EE,7EF
1A74:  MOVLW  18
1A76:  MOVWF  xF0
1A78:  MOVLB  0
1A7A:  RCALL  1978
1A7C:  MOVLB  7
1A7E:  INCF   xEC,F
1A80:  BTFSC  FD8.2
1A82:  INCF   xED,F
1A84:  BRA    1A52
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1A86:  MOVLW  4E
1A88:  MOVWF  FF6
1A8A:  MOVLW  03
1A8C:  MOVWF  FF7
1A8E:  MOVLB  0
1A90:  CALL   0474
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1A94:  MOVLB  7
1A96:  CLRF   xED
1A98:  CLRF   xEC
1A9A:  MOVF   xED,W
1A9C:  SUBLW  01
1A9E:  BNC   1ACE
1AA0:  BNZ   1AA8
1AA2:  MOVF   xEC,W
1AA4:  SUBLW  2B
1AA6:  BNC   1ACE
1AA8:  MOVLW  5F
1AAA:  ADDWF  xEC,W
1AAC:  MOVWF  FE9
1AAE:  MOVLW  05
1AB0:  ADDWFC xED,W
1AB2:  MOVWF  FEA
1AB4:  MOVFF  FEF,7EE
1AB8:  MOVFF  7EE,7EF
1ABC:  MOVLW  18
1ABE:  MOVWF  xF0
1AC0:  MOVLB  0
1AC2:  RCALL  1978
1AC4:  MOVLB  7
1AC6:  INCF   xEC,F
1AC8:  BTFSC  FD8.2
1ACA:  INCF   xED,F
1ACC:  BRA    1A9A
.................... } 
1ACE:  MOVLB  0
1AD0:  GOTO   1D66 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3F14:  MOVLW  01
3F16:  MOVLB  6
3F18:  MOVWF  x9F
....................    //rtc_get_date(date,mon,year,day); 
....................    //rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
3F1A:  MOVLB  0
3F1C:  RCALL  38B0
3F1E:  MOVFF  02,7EA
3F22:  MOVFF  01,7E9
3F26:  MOVFF  02,7EC
3F2A:  MOVFF  01,7EB
3F2E:  MOVLB  7
3F30:  CLRF   xEE
3F32:  MOVLW  7C
3F34:  MOVWF  xED
3F36:  MOVLB  0
3F38:  RCALL  3908
3F3A:  MOVFF  01,7E9
3F3E:  MOVLW  96
3F40:  MOVLB  7
3F42:  ADDWF  01,W
3F44:  MOVWF  01
3F46:  MOVLW  00
3F48:  ADDWFC 02,W
3F4A:  MOVFF  01,20
3F4E:  MOVWF  21
3F50:  CLRF   22
3F52:  CLRF   23
....................    if(datinbuf==0)  
3F54:  MOVLB  6
3F56:  MOVF   x9C,F
3F58:  BNZ   3F7A
....................    { 
....................       countbit_T1=0; 
3F5A:  CLRF   x91
3F5C:  CLRF   x90
....................       countbit_T2=0; 
3F5E:  CLRF   x93
3F60:  CLRF   x92
....................       bug_countbit_T1=0; 
3F62:  CLRF   x95
3F64:  CLRF   x94
....................       bug_countbit_T2=0; 
3F66:  CLRF   x97
3F68:  CLRF   x96
....................       if(data_avai==0)charac_timeout=0xffffffff; 
3F6A:  MOVF   xA0,F
3F6C:  BNZ   3F76
3F6E:  MOVLB  0
3F70:  SETF   xFC
3F72:  SETF   xFB
3F74:  MOVLB  6
....................       saving_flag=0; 
3F76:  CLRF   x9F
....................       return; 
3F78:  BRA    431C
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
3F7A:  MOVLW  64
3F7C:  MOVWF  FF6
3F7E:  MOVLW  03
3F80:  MOVWF  FF7
3F82:  MOVLB  0
3F84:  CALL   0474
....................    key_timeout=0; 
3F88:  MOVLB  1
3F8A:  CLRF   x09
3F8C:  CLRF   x08
....................    //key_count=0; 
....................    enable_getpin=1; 
3F8E:  MOVLW  01
3F90:  MOVWF  x0C
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3F92:  MOVFF  691,7E8
3F96:  MOVFF  690,7E7
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3F9A:  MOVLB  7
3F9C:  CLRF   xE9
3F9E:  MOVFF  7E8,7EB
3FA2:  MOVFF  7E7,7EA
3FA6:  MOVLW  02
3FA8:  MOVWF  xED
3FAA:  MOVLW  0D
3FAC:  MOVWF  xEC
3FAE:  MOVLW  01
3FB0:  MOVWF  xEF
3FB2:  MOVLW  96
3FB4:  MOVWF  xEE
3FB6:  MOVLB  0
3FB8:  RCALL  394C
....................    countbit_T1=0; 
3FBA:  MOVLB  6
3FBC:  CLRF   x91
3FBE:  CLRF   x90
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3FC0:  MOVFF  693,7E8
3FC4:  MOVFF  692,7E7
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3FC8:  MOVLW  01
3FCA:  MOVLB  7
3FCC:  MOVWF  xE9
3FCE:  MOVFF  7E8,7EB
3FD2:  MOVFF  7E7,7EA
3FD6:  MOVLW  05
3FD8:  MOVWF  xED
3FDA:  MOVLW  5F
3FDC:  MOVWF  xEC
3FDE:  MOVLW  01
3FE0:  MOVWF  xEF
3FE2:  MOVLW  E5
3FE4:  MOVWF  xEE
3FE6:  MOVLB  0
3FE8:  RCALL  394C
....................    countbit_T2=0; 
3FEA:  MOVLB  6
3FEC:  CLRF   x93
3FEE:  CLRF   x92
....................    saving_flag=0; 
3FF0:  CLRF   x9F
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3FF2:  MOVLW  20
3FF4:  MOVLB  1
3FF6:  ADDWF  x96,W
3FF8:  MOVLB  7
3FFA:  MOVWF  xE6
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
3FFC:  MOVF   23,F
3FFE:  BTFSS  FD8.2
4000:  BRA    431A
4002:  MOVF   22,W
4004:  SUBLW  01
4006:  BTFSS  FD8.0
4008:  BRA    431A
400A:  BNZ   401E
400C:  MOVF   21,W
400E:  SUBLW  C3
4010:  BTFSS  FD8.0
4012:  BRA    431A
4014:  BNZ   401E
4016:  MOVF   20,W
4018:  SUBLW  0D
401A:  BTFSS  FD8.0
401C:  BRA    431A
401E:  MOVF   xE6,W
4020:  SUBLW  25
4022:  BTFSS  FD8.2
4024:  BRA    431A
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
4026:  MOVFF  23,03
402A:  MOVFF  22,02
402E:  MOVFF  21,01
4032:  MOVFF  20,00
4036:  MOVLW  01
4038:  ADDWF  20,F
403A:  BTFSC  FD8.0
403C:  INCF   21,F
403E:  BTFSC  FD8.2
4040:  INCF   22,F
4042:  BTFSC  FD8.2
4044:  INCF   23,F
4046:  MOVFF  01,7EA
404A:  MOVFF  00,7E9
404E:  MOVLB  8
4050:  CLRF   x05
4052:  CLRF   x04
4054:  MOVFF  01,803
4058:  MOVFF  00,802
405C:  MOVFF  100,806
4060:  MOVLB  0
4062:  RCALL  3D80
....................          write_ext_eeprom((long int)ptr_card++,mon); 
4064:  MOVFF  23,03
4068:  MOVFF  22,02
406C:  MOVFF  21,01
4070:  MOVFF  20,00
4074:  MOVLW  01
4076:  ADDWF  20,F
4078:  BTFSC  FD8.0
407A:  INCF   21,F
407C:  BTFSC  FD8.2
407E:  INCF   22,F
4080:  BTFSC  FD8.2
4082:  INCF   23,F
4084:  MOVFF  01,7EA
4088:  MOVFF  00,7E9
408C:  MOVLB  8
408E:  CLRF   x05
4090:  CLRF   x04
4092:  MOVFF  01,803
4096:  MOVFF  00,802
409A:  MOVFF  FF,806
409E:  MOVLB  0
40A0:  RCALL  3D80
....................          write_ext_eeprom((long int)ptr_card++,h); 
40A2:  MOVFF  23,03
40A6:  MOVFF  22,02
40AA:  MOVFF  21,01
40AE:  MOVFF  20,00
40B2:  MOVLW  01
40B4:  ADDWF  20,F
40B6:  BTFSC  FD8.0
40B8:  INCF   21,F
40BA:  BTFSC  FD8.2
40BC:  INCF   22,F
40BE:  BTFSC  FD8.2
40C0:  INCF   23,F
40C2:  MOVFF  01,7EA
40C6:  MOVFF  00,7E9
40CA:  MOVLB  8
40CC:  CLRF   x05
40CE:  CLRF   x04
40D0:  MOVFF  01,803
40D4:  MOVFF  00,802
40D8:  MOVFF  101,806
40DC:  MOVLB  0
40DE:  RCALL  3D80
....................          write_ext_eeprom((long int)ptr_card++,min); 
40E0:  MOVFF  23,03
40E4:  MOVFF  22,02
40E8:  MOVFF  21,01
40EC:  MOVFF  20,00
40F0:  MOVLW  01
40F2:  ADDWF  20,F
40F4:  BTFSC  FD8.0
40F6:  INCF   21,F
40F8:  BTFSC  FD8.2
40FA:  INCF   22,F
40FC:  BTFSC  FD8.2
40FE:  INCF   23,F
4100:  MOVFF  01,7EA
4104:  MOVFF  00,7E9
4108:  MOVLB  8
410A:  CLRF   x05
410C:  CLRF   x04
410E:  MOVFF  01,803
4112:  MOVFF  00,802
4116:  MOVFF  102,806
411A:  MOVLB  0
411C:  RCALL  3D80
....................          write_ext_eeprom((long int)ptr_card++,sec);           
411E:  MOVFF  23,03
4122:  MOVFF  22,02
4126:  MOVFF  21,01
412A:  MOVFF  20,00
412E:  MOVLW  01
4130:  ADDWF  20,F
4132:  BTFSC  FD8.0
4134:  INCF   21,F
4136:  BTFSC  FD8.2
4138:  INCF   22,F
413A:  BTFSC  FD8.2
413C:  INCF   23,F
413E:  MOVFF  01,7EA
4142:  MOVFF  00,7E9
4146:  MOVLB  8
4148:  CLRF   x05
414A:  CLRF   x04
414C:  MOVFF  01,803
4150:  MOVFF  00,802
4154:  MOVFF  103,806
4158:  MOVLB  0
415A:  RCALL  3D80
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
415C:  MOVLB  6
415E:  CLRF   x9B
4160:  CLRF   x9A
4162:  MOVF   x9B,F
4164:  BNZ   41C8
4166:  MOVF   x9A,W
4168:  SUBLW  4E
416A:  BNC   41C8
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
416C:  MOVFF  23,03
4170:  MOVFF  22,02
4174:  MOVFF  21,01
4178:  MOVFF  20,00
417C:  MOVLW  01
417E:  ADDWF  20,F
4180:  BTFSC  FD8.0
4182:  INCF   21,F
4184:  BTFSC  FD8.2
4186:  INCF   22,F
4188:  BTFSC  FD8.2
418A:  INCF   23,F
418C:  MOVFF  01,7EA
4190:  MOVFF  00,7E9
4194:  MOVLW  96
4196:  ADDWF  x9A,W
4198:  MOVWF  FE9
419A:  MOVLW  01
419C:  ADDWFC x9B,W
419E:  MOVWF  FEA
41A0:  MOVF   FEF,W
41A2:  ANDLW  3F
41A4:  ADDLW  20
41A6:  MOVLB  7
41A8:  MOVWF  xEB
41AA:  MOVLB  8
41AC:  CLRF   x05
41AE:  CLRF   x04
41B0:  MOVFF  01,803
41B4:  MOVFF  00,802
41B8:  MOVWF  x06
41BA:  MOVLB  0
41BC:  RCALL  3D80
....................              
....................          } 
41BE:  MOVLB  6
41C0:  INCF   x9A,F
41C2:  BTFSC  FD8.2
41C4:  INCF   x9B,F
41C6:  BRA    4162
....................          del_buf(numbyteoftrack1,Track1); 
41C8:  MOVLW  4F
41CA:  MOVLB  7
41CC:  MOVWF  xF5
41CE:  MOVLW  01
41D0:  MOVWF  xF7
41D2:  MOVLW  96
41D4:  MOVWF  xF6
41D6:  MOVLB  0
41D8:  CALL   392A
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
41DC:  MOVLB  6
41DE:  CLRF   x9B
41E0:  CLRF   x9A
41E2:  MOVF   x9B,F
41E4:  BNZ   4248
41E6:  MOVF   x9A,W
41E8:  SUBLW  27
41EA:  BNC   4248
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
41EC:  MOVFF  23,03
41F0:  MOVFF  22,02
41F4:  MOVFF  21,01
41F8:  MOVFF  20,00
41FC:  MOVLW  01
41FE:  ADDWF  20,F
4200:  BTFSC  FD8.0
4202:  INCF   21,F
4204:  BTFSC  FD8.2
4206:  INCF   22,F
4208:  BTFSC  FD8.2
420A:  INCF   23,F
420C:  MOVFF  01,7EA
4210:  MOVFF  00,7E9
4214:  MOVLW  E5
4216:  ADDWF  x9A,W
4218:  MOVWF  FE9
421A:  MOVLW  01
421C:  ADDWFC x9B,W
421E:  MOVWF  FEA
4220:  MOVF   FEF,W
4222:  ANDLW  0F
4224:  ADDLW  30
4226:  MOVLB  7
4228:  MOVWF  xEB
422A:  MOVLB  8
422C:  CLRF   x05
422E:  CLRF   x04
4230:  MOVFF  01,803
4234:  MOVFF  00,802
4238:  MOVWF  x06
423A:  MOVLB  0
423C:  RCALL  3D80
....................          }  
423E:  MOVLB  6
4240:  INCF   x9A,F
4242:  BTFSC  FD8.2
4244:  INCF   x9B,F
4246:  BRA    41E2
....................          del_buf(numbyteoftrack2,Track2); 
4248:  MOVLW  28
424A:  MOVLB  7
424C:  MOVWF  xF5
424E:  MOVLW  01
4250:  MOVWF  xF7
4252:  MOVLW  E5
4254:  MOVWF  xF6
4256:  MOVLB  0
4258:  CALL   392A
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
425C:  MOVLW  0D
425E:  MOVLB  8
4260:  MOVWF  x1A
4262:  MOVLB  0
4264:  CALL   0422
4268:  MOVLW  0A
426A:  MOVLB  8
426C:  MOVWF  x1A
426E:  MOVLB  0
4270:  CALL   0422
....................       fprintf(COM2,"Done"); 
4274:  MOVLW  7A
4276:  MOVWF  FF6
4278:  MOVLW  03
427A:  MOVWF  FF7
427C:  CALL   0474
....................       if(KP_mode) 
4280:  MOVLB  1
4282:  MOVF   x0F,F
4284:  BZ    429C
....................       { 
....................          printf("\n\rKey release\n\r"); 
4286:  MOVLW  80
4288:  MOVWF  FF6
428A:  MOVLW  03
428C:  MOVWF  FF7
428E:  MOVLB  0
4290:  CALL   0474
....................          keyprss_off; 
4294:  BCF    F92.7
4296:  BCF    F89.7
....................          kp_st=0; 
4298:  MOVLB  1
429A:  CLRF   x10
....................       }   
....................       count_kp=0xffff; 
429C:  SETF   x12
429E:  SETF   x11
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
42A0:  MOVLW  0D
42A2:  MOVLB  8
42A4:  MOVWF  x1A
42A6:  MOVLB  0
42A8:  CALL   0422
42AC:  MOVLW  0A
42AE:  MOVLB  8
42B0:  MOVWF  x1A
42B2:  MOVLB  0
42B4:  CALL   0422
....................       fprintf(COM2,"Waiting for PIN number"); 
42B8:  MOVLW  90
42BA:  MOVWF  FF6
42BC:  MOVLW  03
42BE:  MOVWF  FF7
42C0:  CALL   0474
....................       count_checking=0; 
42C4:  MOVLB  1
42C6:  CLRF   x07
42C8:  CLRF   x06
....................       fprintf(COM2,"\r\n"); 
42CA:  MOVLW  0D
42CC:  MOVLB  8
42CE:  MOVWF  x1A
42D0:  MOVLB  0
42D2:  CALL   0422
42D6:  MOVLW  0A
42D8:  MOVLB  8
42DA:  MOVWF  x1A
42DC:  MOVLB  0
42DE:  CALL   0422
....................       charac_timeout=0; 
42E2:  CLRF   xFC
42E4:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
42E6:  MOVFF  23,7EC
42EA:  MOVFF  22,7EB
42EE:  MOVFF  21,7EA
42F2:  MOVFF  20,7E9
42F6:  MOVLW  19
42F8:  MOVLB  7
42FA:  MOVWF  xED
42FC:  MOVLB  0
42FE:  RCALL  3E7E
....................       datinbuf=0; 
4300:  MOVLB  6
4302:  CLRF   x9C
....................       saving_flag=0; 
4304:  CLRF   x9F
....................       data_avai=1; 
4306:  MOVLW  01
4308:  MOVWF  xA0
....................       enable_getpin=1; 
430A:  MOVLB  1
430C:  MOVWF  x0C
....................       charac_timeout=0; 
430E:  MOVLB  0
4310:  CLRF   xFC
4312:  CLRF   xFB
....................       key_count_ms=0; 
4314:  MOVLB  1
4316:  CLRF   x0E
4318:  MOVLB  7
431A:  MOVLB  6
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
431C:  MOVLB  0
431E:  GOTO   46B0 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
1AFC:  MOVLW  01
1AFE:  MOVLB  7
1B00:  MOVWF  xE3
1B02:  MOVWF  xE4
1B04:  MOVWF  xE5
1B06:  MOVWF  xE6
1B08:  CLRF   xE7
1B0A:  MOVWF  xE8
1B0C:  MOVWF  xE9
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1B0E:  MOVLB  6
1B10:  CLRF   x99
1B12:  CLRF   x98
....................    mcr_timeout=0; 
1B14:  CLRF   x8E
1B16:  CLRF   x8D
1B18:  CLRF   x8C
1B1A:  CLRF   x8B
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
1B1C:  MOVF   x99,W
1B1E:  SUBLW  FD
1B20:  BNC   1B3E
1B22:  BNZ   1B2A
1B24:  MOVF   x98,W
1B26:  SUBLW  E7
1B28:  BNC   1B3E
1B2A:  BSF    F93.1
1B2C:  BTFSS  F81.1
1B2E:  BRA    1B3E
1B30:  BSF    F94.5
1B32:  BTFSS  F82.5
1B34:  BRA    1B3E
....................       card_timeout++; 
1B36:  INCF   x98,F
1B38:  BTFSC  FD8.2
1B3A:  INCF   x99,F
....................    } 
1B3C:  BRA    1B1C
....................    card_timeout=0; 
1B3E:  CLRF   x99
1B40:  CLRF   x98
....................    buffertrack1[bug_countbit_T1++]=0; 
1B42:  MOVFF  695,03
1B46:  MOVF   x94,W
1B48:  INCF   x94,F
1B4A:  BTFSC  FD8.2
1B4C:  INCF   x95,F
1B4E:  MOVLB  7
1B50:  MOVWF  xEC
1B52:  MOVLW  0D
1B54:  ADDWF  xEC,W
1B56:  MOVWF  FE9
1B58:  MOVLW  02
1B5A:  ADDWFC 03,W
1B5C:  MOVWF  FEA
1B5E:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1B60:  MOVLB  6
1B62:  MOVFF  695,03
1B66:  MOVF   x94,W
1B68:  INCF   x94,F
1B6A:  BTFSC  FD8.2
1B6C:  INCF   x95,F
1B6E:  MOVLB  7
1B70:  MOVWF  xEC
1B72:  MOVLW  0D
1B74:  ADDWF  xEC,W
1B76:  MOVWF  FE9
1B78:  MOVLW  02
1B7A:  ADDWFC 03,W
1B7C:  MOVWF  FEA
1B7E:  MOVLW  01
1B80:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1B82:  MOVLB  6
1B84:  MOVFF  697,03
1B88:  MOVF   x96,W
1B8A:  INCF   x96,F
1B8C:  BTFSC  FD8.2
1B8E:  INCF   x97,F
1B90:  MOVLB  7
1B92:  MOVWF  xEC
1B94:  MOVLW  5F
1B96:  ADDWF  xEC,W
1B98:  MOVWF  FE9
1B9A:  MOVLW  05
1B9C:  ADDWFC 03,W
1B9E:  MOVWF  FEA
1BA0:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1BA2:  MOVLB  6
1BA4:  MOVFF  697,03
1BA8:  MOVF   x96,W
1BAA:  INCF   x96,F
1BAC:  BTFSC  FD8.2
1BAE:  INCF   x97,F
1BB0:  MOVLB  7
1BB2:  MOVWF  xEC
1BB4:  MOVLW  5F
1BB6:  ADDWF  xEC,W
1BB8:  MOVWF  FE9
1BBA:  MOVLW  05
1BBC:  ADDWFC 03,W
1BBE:  MOVWF  FEA
1BC0:  MOVLW  01
1BC2:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1BC4:  MOVLB  6
1BC6:  MOVF   x95,W
1BC8:  SUBLW  03
1BCA:  BTFSS  FD8.0
1BCC:  BRA    1CAC
1BCE:  BNZ   1BD8
1BD0:  MOVF   x94,W
1BD2:  SUBLW  51
1BD4:  BTFSS  FD8.0
1BD6:  BRA    1CAC
1BD8:  MOVF   x97,W
1BDA:  SUBLW  01
1BDC:  BTFSS  FD8.0
1BDE:  BRA    1CAC
1BE0:  BNZ   1BE8
1BE2:  MOVF   x96,W
1BE4:  SUBLW  2B
1BE6:  BNC   1CAC
1BE8:  MOVF   x99,W
1BEA:  SUBLW  FF
1BEC:  BNC   1CAC
1BEE:  BNZ   1BF6
1BF0:  MOVF   x98,W
1BF2:  SUBLW  DB
1BF4:  BNC   1CAC
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
1BF6:  MOVF   xA2,F
1BF8:  BZ    1C02
....................          { 
....................             bug_countbit_T1=0; 
1BFA:  CLRF   x95
1BFC:  CLRF   x94
....................             bug_countbit_T2=0; 
1BFE:  CLRF   x97
1C00:  CLRF   x96
....................          } 
....................          card_timeout++; 
1C02:  INCF   x98,F
1C04:  BTFSC  FD8.2
1C06:  INCF   x99,F
....................          mcr_timeout=0; 
1C08:  CLRF   x8E
1C0A:  CLRF   x8D
1C0C:  CLRF   x8C
1C0E:  CLRF   x8B
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1C10:  BSF    F93.2
1C12:  MOVLB  7
1C14:  CLRF   xE3
1C16:  BTFSC  F81.2
1C18:  INCF   xE3,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1C1A:  MOVF   xE3,F
1C1C:  BNZ   1C5A
1C1E:  DECFSZ xE4,W
1C20:  BRA    1C5A
....................          { 
....................             ST1_old = 0; 
1C22:  CLRF   xE4
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1C24:  MOVLW  0D
1C26:  MOVLB  6
1C28:  ADDWF  x94,W
1C2A:  MOVWF  FE9
1C2C:  MOVLW  02
1C2E:  ADDWFC x95,W
1C30:  MOVWF  FEA
1C32:  BSF    F93.1
1C34:  MOVLW  00
1C36:  BTFSS  F81.1
1C38:  MOVLW  01
1C3A:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1C3C:  MOVLW  5F
1C3E:  ADDWF  x96,W
1C40:  MOVWF  FE9
1C42:  MOVLW  05
1C44:  ADDWFC x97,W
1C46:  MOVWF  FEA
1C48:  MOVFF  7E7,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1C4C:  INCF   x94,F
1C4E:  BTFSC  FD8.2
1C50:  INCF   x95,F
....................             card_timeout=0; 
1C52:  CLRF   x99
1C54:  CLRF   x98
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1C56:  BRA    1C64
1C58:  MOVLB  7
1C5A:  DECFSZ xE3,W
1C5C:  BRA    1C62
1C5E:  MOVLW  01
1C60:  MOVWF  xE4
1C62:  MOVLB  6
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1C64:  BSF    F93.3
1C66:  MOVLB  7
1C68:  CLRF   xE5
1C6A:  BTFSC  F81.3
1C6C:  INCF   xE5,F
....................          if(ST2 == 0 && ST2_old == 1) 
1C6E:  MOVF   xE5,F
1C70:  BNZ   1C90
1C72:  DECFSZ xE6,W
1C74:  BRA    1C90
....................          { 
....................             ST2_old = 0; 
1C76:  CLRF   xE6
....................             Bit_t2 = !input(MCR_DATA2); 
1C78:  BSF    F94.5
1C7A:  CLRF   xE7
1C7C:  BTFSS  F82.5
1C7E:  INCF   xE7,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1C80:  MOVLB  6
1C82:  INCF   x96,F
1C84:  BTFSC  FD8.2
1C86:  INCF   x97,F
....................             card_timeout=0; 
1C88:  CLRF   x99
1C8A:  CLRF   x98
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1C8C:  BRA    1C9A
1C8E:  MOVLB  7
1C90:  DECFSZ xE5,W
1C92:  BRA    1C98
1C94:  MOVLW  01
1C96:  MOVWF  xE6
1C98:  MOVLB  6
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1C9A:  BSF    F93.0
1C9C:  BTFSS  F81.0
1C9E:  BRA    1CAA
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1CA0:  CLRF   xA2
....................             card_timeout=65500; 
1CA2:  SETF   x99
1CA4:  MOVLW  DC
1CA6:  MOVWF  x98
....................             break;            
1CA8:  BRA    1CAC
....................          } 
....................       } 
1CAA:  BRA    1BC6
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1CAC:  CLRF   x99
1CAE:  CLRF   x98
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1CB0:  MOVLB  7
1CB2:  CLRF   xF5
1CB4:  MOVFF  695,7F7
1CB8:  MOVFF  694,7F6
1CBC:  MOVLW  02
1CBE:  MOVWF  xF9
1CC0:  MOVLW  0D
1CC2:  MOVWF  xF8
1CC4:  MOVLB  0
1CC6:  CALL   07EA
1CCA:  MOVFF  01,7E8
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1CCE:  MOVLW  01
1CD0:  MOVLB  7
1CD2:  MOVWF  xF5
1CD4:  MOVFF  697,7F7
1CD8:  MOVFF  696,7F6
1CDC:  MOVLW  05
1CDE:  MOVWF  xF9
1CE0:  MOVLW  5F
1CE2:  MOVWF  xF8
1CE4:  MOVLB  0
1CE6:  CALL   07EA
1CEA:  MOVFF  01,7E9
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1CEE:  MOVLB  6
1CF0:  DECFSZ x9D,W
1CF2:  BRA    1D94
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1CF4:  MOVLW  A8
1CF6:  MOVWF  FF6
1CF8:  MOVLW  03
1CFA:  MOVWF  FF7
1CFC:  MOVLW  0E
1CFE:  MOVLB  8
1D00:  MOVWF  x0E
1D02:  MOVLB  0
1D04:  RCALL  1864
1D06:  MOVLW  10
1D08:  MOVWF  FE9
1D0A:  MOVFF  695,7ED
1D0E:  MOVFF  694,7EC
1D12:  RCALL  188E
1D14:  MOVLW  0D
1D16:  MOVLB  8
1D18:  MOVWF  x1A
1D1A:  MOVLB  0
1D1C:  CALL   0422
1D20:  MOVLW  0A
1D22:  MOVLB  8
1D24:  MOVWF  x1A
1D26:  MOVLB  0
1D28:  CALL   0422
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1D2C:  MOVLW  BC
1D2E:  MOVWF  FF6
1D30:  MOVLW  03
1D32:  MOVWF  FF7
1D34:  MOVLW  0E
1D36:  MOVLB  8
1D38:  MOVWF  x0E
1D3A:  MOVLB  0
1D3C:  RCALL  1864
1D3E:  MOVLW  10
1D40:  MOVWF  FE9
1D42:  MOVFF  697,7ED
1D46:  MOVFF  696,7EC
1D4A:  RCALL  188E
1D4C:  MOVLW  0D
1D4E:  MOVLB  8
1D50:  MOVWF  x1A
1D52:  MOVLB  0
1D54:  CALL   0422
1D58:  MOVLW  0A
1D5A:  MOVLB  8
1D5C:  MOVWF  x1A
1D5E:  MOVLB  0
1D60:  CALL   0422
....................          debug_reader();       
1D64:  BRA    1A40
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1D66:  MOVLB  7
1D68:  MOVF   xE8,F
1D6A:  BNZ   1D7C
1D6C:  MOVLW  D0
1D6E:  MOVWF  FF6
1D70:  MOVLW  03
1D72:  MOVWF  FF7
1D74:  MOVLB  0
1D76:  CALL   0474
1D7A:  MOVLB  7
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1D7C:  MOVF   xE9,F
1D7E:  BNZ   1D90
1D80:  MOVLW  E6
1D82:  MOVWF  FF6
1D84:  MOVLW  03
1D86:  MOVWF  FF7
1D88:  MOVLB  0
1D8A:  CALL   0474
1D8E:  MOVLB  7
....................       } 
....................          else 
1D90:  BRA    1DA0
1D92:  MOVLB  6
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1D94:  MOVLW  0F
1D96:  MOVLB  7
1D98:  MOVWF  xEC
1D9A:  MOVLB  0
1D9C:  RCALL  1AD4
1D9E:  MOVLB  7
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1DA0:  MOVF   xE8,F
1DA2:  BZ    1DA8
1DA4:  MOVF   xE9,F
1DA6:  BNZ   1DC8
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1DA8:  MOVLB  6
1DAA:  CLRF   x97
1DAC:  CLRF   x96
....................          bug_countbit_T1=0; 
1DAE:  CLRF   x95
1DB0:  CLRF   x94
....................          reading_fg=0; 
1DB2:  CLRF   xA1
....................          count_reading_error++; 
1DB4:  INCF   xA2,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1DB6:  CLRF   x8E
1DB8:  CLRF   x8D
1DBA:  CLRF   x8C
1DBC:  CLRF   x8B
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1DBE:  MOVLW  00
1DC0:  MOVWF  01
1DC2:  BRA    1E00
....................       } 
....................          else  
1DC4:  BRA    1DFC
1DC6:  MOVLB  7
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1DC8:  MOVLW  01
1DCA:  MOVLB  6
1DCC:  MOVWF  x9C
....................             reading_fg=1; 
1DCE:  MOVWF  xA1
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1DD0:  MOVFF  697,693
1DD4:  MOVFF  696,692
....................             countbit_T1=bug_countbit_T1; 
1DD8:  MOVFF  695,691
1DDC:  MOVFF  694,690
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1DE0:  CLRF   x95
1DE2:  CLRF   x94
....................             bug_countbit_T2=0;  
1DE4:  CLRF   x97
1DE6:  CLRF   x96
....................             mcr_timeout=0; 
1DE8:  CLRF   x8E
1DEA:  CLRF   x8D
1DEC:  CLRF   x8C
1DEE:  CLRF   x8B
....................             charac_timeout=0; 
1DF0:  MOVLB  0
1DF2:  CLRF   xFC
1DF4:  CLRF   xFB
....................             return 1; 
1DF6:  MOVWF  01
1DF8:  MOVLB  6
1DFA:  BRA    1E00
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1DFC:  MOVLW  00
1DFE:  MOVWF  01
.................... } 
1E00:  MOVLB  0
1E02:  GOTO   1E6E (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
1E06:  MOVLW  02
1E08:  MOVLB  7
1E0A:  MOVWF  xE3
1E0C:  MOVLW  FA
1E0E:  MOVWF  xE4
1E10:  MOVLB  0
1E12:  GOTO   03FC
1E16:  MOVLB  7
1E18:  DECFSZ xE3,F
1E1A:  BRA    1E0C
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
1E1C:  MOVLB  6
1E1E:  DECFSZ x9F,W
1E20:  BRA    1E24
1E22:  BRA    1E80
....................       if((KP_mode)&&(enable_getpin==0)&&(booting==1)) 
1E24:  MOVLB  1
1E26:  MOVF   x0F,F
1E28:  BZ    1E6A
1E2A:  MOVF   x0C,F
1E2C:  BNZ   1E6A
1E2E:  DECFSZ x05,W
1E30:  BRA    1E6A
....................       { 
....................          if(kp_st==1) 
1E32:  DECFSZ x10,W
1E34:  BRA    1E4E
....................          { 
....................             printf("\n\rKey release.\n\r"); 
1E36:  MOVLW  88
1E38:  MOVWF  FF6
1E3A:  MOVLW  1E
1E3C:  MOVWF  FF7
1E3E:  MOVLB  0
1E40:  CALL   0474
....................             keyprss_off; 
1E44:  BCF    F92.7
1E46:  BCF    F89.7
....................             kp_st=0; 
1E48:  MOVLB  1
1E4A:  CLRF   x10
....................          } 
....................          else 
1E4C:  BRA    1E6A
....................          { 
....................             printf("\n\rKey press.\n\r"); 
1E4E:  MOVLW  9A
1E50:  MOVWF  FF6
1E52:  MOVLW  1E
1E54:  MOVWF  FF7
1E56:  MOVLB  0
1E58:  CALL   0474
....................             keyprss_on; 
1E5C:  BCF    F92.7
1E5E:  BSF    F89.7
....................             kp_st=1;  
1E60:  MOVLW  01
1E62:  MOVLB  1
1E64:  MOVWF  x10
....................             count_kp=0; 
1E66:  CLRF   x12
1E68:  CLRF   x11
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1E6A:  MOVLB  0
1E6C:  BRA    1AFC
1E6E:  MOVFF  01,69E
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1E72:  MOVLB  6
1E74:  CLRF   x8E
1E76:  CLRF   x8D
1E78:  CLRF   x8C
1E7A:  CLRF   x8B
....................       card_timeout=0; 
1E7C:  CLRF   x99
1E7E:  CLRF   x98
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1E80:  BCF    FF0.0
1E82:  MOVLB  0
1E84:  GOTO   006C
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
5330:  CLRF   19
5332:  BTFSC  FF2.7
5334:  BSF    19.7
5336:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
5338:  MOVLB  8
533A:  CLRF   x05
533C:  CLRF   x04
533E:  CLRF   x03
5340:  MOVLW  94
5342:  MOVWF  x02
5344:  MOVLW  03
5346:  MOVWF  x06
5348:  MOVLB  0
534A:  CALL   3D80
534E:  BTFSC  19.7
5350:  BSF    FF2.7
5352:  CLRF   19
5354:  BTFSC  FF2.7
5356:  BSF    19.7
5358:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
535A:  MOVLB  8
535C:  CLRF   x05
535E:  CLRF   x04
5360:  CLRF   x03
5362:  MOVLW  91
5364:  MOVWF  x02
5366:  MOVLW  01
5368:  MOVWF  x06
536A:  MOVLB  0
536C:  CALL   3D80
5370:  BTFSC  19.7
5372:  BSF    FF2.7
5374:  CLRF   19
5376:  BTFSC  FF2.7
5378:  BSF    19.7
537A:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
537C:  MOVLB  7
537E:  CLRF   xF2
5380:  CLRF   xF1
5382:  CLRF   xF0
5384:  MOVLW  91
5386:  MOVWF  xEF
5388:  MOVLB  0
538A:  CALL   37E2
538E:  BTFSC  19.7
5390:  BSF    FF2.7
5392:  MOVFF  01,6A9
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
....................    #endif 
....................     
.................... } 
5396:  GOTO   5CDA (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
5676:  MOVLW  06
5678:  MOVWF  FEA
567A:  MOVLW  AE
567C:  MOVWF  FE9
567E:  BRA    4F50
5680:  CLRF   19
5682:  BTFSC  FF2.7
5684:  BSF    19.7
5686:  BCF    FF2.7
5688:  MOVLW  3E
568A:  MOVLB  8
568C:  MOVWF  x1A
568E:  MOVLB  0
5690:  CALL   0422
5694:  BTFSC  19.7
5696:  BSF    FF2.7
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
5698:  MOVLW  01
569A:  MOVLB  7
569C:  MOVWF  xBA
569E:  MOVLW  14
56A0:  MOVWF  xBB
56A2:  MOVLW  01
56A4:  MOVWF  xBD
56A6:  MOVLW  2C
56A8:  MOVWF  xBC
56AA:  MOVLB  0
56AC:  CALL   4D80
56B0:  CLRF   19
56B2:  BTFSC  FF2.7
56B4:  BSF    19.7
56B6:  BCF    FF2.7
....................       printf("\n\r"); 
56B8:  MOVLW  0A
56BA:  MOVLB  8
56BC:  MOVWF  x1A
56BE:  MOVLB  0
56C0:  CALL   0422
56C4:  BTFSC  19.7
56C6:  BSF    FF2.7
56C8:  CLRF   19
56CA:  BTFSC  FF2.7
56CC:  BSF    19.7
56CE:  BCF    FF2.7
56D0:  MOVLW  0D
56D2:  MOVLB  8
56D4:  MOVWF  x1A
56D6:  MOVLB  0
56D8:  CALL   0422
56DC:  BTFSC  19.7
56DE:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
56E0:  CLRF   FEA
56E2:  MOVLW  41
56E4:  MOVWF  FE9
56E6:  MOVLW  00
56E8:  CALL   011C
56EC:  TBLRD*-
56EE:  TBLRD*+
56F0:  MOVF   FF5,W
56F2:  MOVWF  FEE
56F4:  IORLW  00
56F6:  BNZ   56EE
....................       index=0; 
56F8:  MOVLB  7
56FA:  CLRF   x84
....................       ee_dat=0; 
56FC:  MOVLB  6
56FE:  CLRF   xA4
....................       count_card=1; 
5700:  CLRF   xA6
5702:  MOVLW  01
5704:  MOVWF  xA5
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
5706:  MOVLB  7
5708:  MOVWF  xBB
570A:  MOVLW  2C
570C:  MOVWF  xBA
570E:  CLRF   xBD
5710:  MOVLW  41
5712:  MOVWF  xBC
5714:  MOVLB  0
5716:  CALL   4EB8
571A:  MOVF   01,F
571C:  BTFSS  FD8.2
571E:  BRA    5B04
....................       { 
....................          unsigned long adr=0; 
5720:  MOVLB  7
5722:  CLRF   xB9
5724:  CLRF   xB8
....................          //unsigned int count=0; 
....................          rec[0]=0; 
5726:  MOVLB  0
5728:  CLRF   x7D
572A:  CLRF   19
572C:  BTFSC  FF2.7
572E:  BSF    19.7
5730:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
5732:  CALL   38B0
5736:  BTFSC  19.7
5738:  BSF    FF2.7
573A:  MOVFF  02,6A8
573E:  MOVFF  01,6A7
5742:  CLRF   19
5744:  BTFSC  FF2.7
5746:  BSF    19.7
5748:  BCF    FF2.7
....................          adr=count_card*numdata; 
574A:  MOVFF  6A6,7EC
574E:  MOVFF  6A5,7EB
5752:  MOVLB  7
5754:  CLRF   xEE
5756:  MOVLW  7C
5758:  MOVWF  xED
575A:  MOVLB  0
575C:  CALL   3908
5760:  BTFSC  19.7
5762:  BSF    FF2.7
5764:  MOVFF  02,7B9
5768:  MOVFF  01,7B8
....................          addr_key=EEPROM_KEY_ST; 
576C:  MOVLB  6
576E:  CLRF   xAD
5770:  MOVLW  01
5772:  MOVWF  xAC
5774:  MOVLW  C3
5776:  MOVWF  xAB
5778:  MOVLW  0F
577A:  MOVWF  xAA
....................          while(count_card<=count_card_tg) 
....................          { 
577C:  MOVF   xA6,W
577E:  SUBWF  xA8,W
5780:  BTFSS  FD8.0
5782:  BRA    5B02
5784:  BNZ   578E
5786:  MOVF   xA5,W
5788:  SUBWF  xA7,W
578A:  BTFSS  FD8.0
578C:  BRA    5B02
578E:  CLRF   19
5790:  BTFSC  FF2.7
5792:  BSF    19.7
5794:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
5796:  MOVFF  6A6,7EC
579A:  MOVFF  6A5,7EB
579E:  MOVLB  7
57A0:  CLRF   xEE
57A2:  MOVLW  7C
57A4:  MOVWF  xED
57A6:  MOVLB  0
57A8:  CALL   3908
57AC:  BTFSC  19.7
57AE:  BSF    FF2.7
57B0:  MOVLW  96
57B2:  MOVLB  7
57B4:  ADDWF  01,W
57B6:  MOVWF  xB8
57B8:  MOVLW  00
57BA:  ADDWFC 02,W
57BC:  MOVWF  xB9
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
57BE:  MOVLW  7C
57C0:  SUBWF  xB8,W
57C2:  MOVWF  xBA
57C4:  MOVLW  00
57C6:  SUBWFB xB9,W
57C8:  MOVWF  xBB
57CA:  MOVWF  xBD
57CC:  MOVFF  7BA,7BC
57D0:  CLRF   xBF
57D2:  MOVLW  7C
57D4:  MOVWF  xBE
57D6:  CLRF   xC1
57D8:  MOVLW  7D
57DA:  MOVWF  xC0
57DC:  MOVLB  0
57DE:  GOTO   4F84
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
57E2:  MOVLW  10
57E4:  MOVWF  FE9
57E6:  CLRF   19
57E8:  BTFSC  FF2.7
57EA:  BSF    19.7
57EC:  BCF    FF2.7
57EE:  MOVFF  6A6,7E7
57F2:  MOVFF  6A5,7E6
57F6:  CALL   4502
57FA:  BTFSC  19.7
57FC:  BSF    FF2.7
57FE:  CLRF   19
5800:  BTFSC  FF2.7
5802:  BSF    19.7
5804:  BCF    FF2.7
5806:  MOVLW  29
5808:  MOVLB  8
580A:  MOVWF  x1A
580C:  MOVLB  0
580E:  CALL   0422
5812:  BTFSC  19.7
5814:  BSF    FF2.7
5816:  MOVFF  7D,7BA
581A:  MOVLW  01
581C:  MOVLB  7
581E:  MOVWF  xBB
5820:  MOVLB  0
5822:  CALL   4FF8
5826:  CLRF   19
5828:  BTFSC  FF2.7
582A:  BSF    19.7
582C:  BCF    FF2.7
582E:  MOVLW  2F
5830:  MOVLB  8
5832:  MOVWF  x1A
5834:  MOVLB  0
5836:  CALL   0422
583A:  BTFSC  19.7
583C:  BSF    FF2.7
583E:  MOVFF  7E,7BA
5842:  MOVLW  01
5844:  MOVLB  7
5846:  MOVWF  xBB
5848:  MOVLB  0
584A:  CALL   4FF8
584E:  CLRF   19
5850:  BTFSC  FF2.7
5852:  BSF    19.7
5854:  BCF    FF2.7
5856:  MOVLW  20
5858:  MOVLB  8
585A:  MOVWF  x1A
585C:  MOVLB  0
585E:  CALL   0422
5862:  BTFSC  19.7
5864:  BSF    FF2.7
5866:  MOVFF  7F,7BA
586A:  MOVLW  01
586C:  MOVLB  7
586E:  MOVWF  xBB
5870:  MOVLB  0
5872:  CALL   4FF8
5876:  CLRF   19
5878:  BTFSC  FF2.7
587A:  BSF    19.7
587C:  BCF    FF2.7
587E:  MOVLW  3A
5880:  MOVLB  8
5882:  MOVWF  x1A
5884:  MOVLB  0
5886:  CALL   0422
588A:  BTFSC  19.7
588C:  BSF    FF2.7
588E:  MOVFF  80,7BA
5892:  MOVLW  01
5894:  MOVLB  7
5896:  MOVWF  xBB
5898:  MOVLB  0
589A:  CALL   4FF8
589E:  CLRF   19
58A0:  BTFSC  FF2.7
58A2:  BSF    19.7
58A4:  BCF    FF2.7
58A6:  MOVLW  3A
58A8:  MOVLB  8
58AA:  MOVWF  x1A
58AC:  MOVLB  0
58AE:  CALL   0422
58B2:  BTFSC  19.7
58B4:  BSF    FF2.7
58B6:  MOVFF  81,7BA
58BA:  MOVLW  01
58BC:  MOVLB  7
58BE:  MOVWF  xBB
58C0:  MOVLB  0
58C2:  CALL   4FF8
....................             ee_dat=0; 
58C6:  MOVLB  6
58C8:  CLRF   xA4
....................             index=0; 
58CA:  MOVLB  7
58CC:  CLRF   x84
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
58CE:  MOVLW  CE
58D0:  MOVWF  FF6
58D2:  MOVLW  1E
58D4:  MOVWF  FF7
58D6:  CLRF   19
58D8:  BTFSC  FF2.7
58DA:  BSF    19.7
58DC:  BCF    FF2.7
58DE:  MOVLB  0
58E0:  CALL   0474
58E4:  BTFSC  19.7
58E6:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
58E8:  MOVLB  7
58EA:  MOVF   x84,W
58EC:  SUBLW  4E
58EE:  BNC   594C
58F0:  MOVLB  6
58F2:  MOVF   xA4,W
58F4:  SUBLW  3F
58F6:  BTFSS  FD8.2
58F8:  BRA    58FE
58FA:  MOVLB  7
58FC:  BRA    594C
....................                ee_dat = rec[index+5]; 
58FE:  MOVLW  05
5900:  MOVLB  7
5902:  ADDWF  x84,W
5904:  CLRF   03
5906:  ADDLW  7D
5908:  MOVWF  FE9
590A:  MOVLW  00
590C:  ADDWFC 03,W
590E:  MOVWF  FEA
5910:  MOVFF  FEF,6A4
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
5914:  MOVLB  6
5916:  MOVF   xA4,W
5918:  SUBLW  1F
591A:  BC    5938
591C:  MOVF   xA4,W
591E:  SUBLW  7E
5920:  BNC   5938
5922:  CLRF   19
5924:  BTFSC  FF2.7
5926:  BSF    19.7
5928:  BCF    FF2.7
592A:  MOVFF  6A4,81A
592E:  MOVLB  0
5930:  CALL   0422
5934:  BTFSC  19.7
5936:  BSF    FF2.7
....................                index++; 
5938:  MOVLB  7
593A:  INCF   x84,F
....................                if(ee_dat==0)break; 
593C:  MOVLB  6
593E:  MOVF   xA4,F
5940:  BNZ   5946
5942:  MOVLB  7
5944:  BRA    594C
....................             } 
5946:  MOVLB  0
5948:  BRA    58E8
594A:  MOVLB  7
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
594C:  MOVLW  E0
594E:  MOVWF  FF6
5950:  MOVLW  1E
5952:  MOVWF  FF7
5954:  CLRF   19
5956:  BTFSC  FF2.7
5958:  BSF    19.7
595A:  BCF    FF2.7
595C:  MOVLB  0
595E:  CALL   0474
5962:  BTFSC  19.7
5964:  BSF    FF2.7
....................             index=0; 
5966:  MOVLB  7
5968:  CLRF   x84
....................             ee_dat=0; 
596A:  MOVLB  6
596C:  CLRF   xA4
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
596E:  MOVLB  7
5970:  MOVF   x84,W
5972:  SUBLW  27
5974:  BNC   59D4
5976:  MOVLB  6
5978:  MOVF   xA4,W
597A:  SUBLW  3F
597C:  BTFSS  FD8.2
597E:  BRA    5984
5980:  MOVLB  7
5982:  BRA    59D4
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
5984:  MOVLW  05
5986:  MOVLB  7
5988:  ADDWF  x84,W
598A:  ADDLW  4F
598C:  CLRF   03
598E:  ADDLW  7D
5990:  MOVWF  FE9
5992:  MOVLW  00
5994:  ADDWFC 03,W
5996:  MOVWF  FEA
5998:  MOVFF  FEF,6A4
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
599C:  MOVLB  6
599E:  MOVF   xA4,W
59A0:  SUBLW  1F
59A2:  BC    59C0
59A4:  MOVF   xA4,W
59A6:  SUBLW  7E
59A8:  BNC   59C0
59AA:  CLRF   19
59AC:  BTFSC  FF2.7
59AE:  BSF    19.7
59B0:  BCF    FF2.7
59B2:  MOVFF  6A4,81A
59B6:  MOVLB  0
59B8:  CALL   0422
59BC:  BTFSC  19.7
59BE:  BSF    FF2.7
....................                index++; 
59C0:  MOVLB  7
59C2:  INCF   x84,F
....................                if(ee_dat==0)break; 
59C4:  MOVLB  6
59C6:  MOVF   xA4,F
59C8:  BNZ   59D0
59CA:  MOVLB  7
59CC:  BRA    59D4
59CE:  MOVLB  6
....................             } 
59D0:  BRA    596E
59D2:  MOVLB  7
....................             index=0; 
59D4:  CLRF   x84
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
59D6:  MOVLW  F2
59D8:  MOVWF  FF6
59DA:  MOVLW  1E
59DC:  MOVWF  FF7
59DE:  CLRF   19
59E0:  BTFSC  FF2.7
59E2:  BSF    19.7
59E4:  BCF    FF2.7
59E6:  MOVLB  0
59E8:  CALL   0474
59EC:  BTFSC  19.7
59EE:  BSF    FF2.7
....................             //fprintf(COM2,"addr_key =%lu \n\r",addr_key);  
....................             //fprintf(COM2," ptr_card_key=%lu \n\r",ptr_card_key);  
....................             if(ptr_card_key>addr_key) 
59F0:  MOVLB  6
59F2:  MOVF   xAD,W
59F4:  SUBWF  27,W
59F6:  BTFSS  FD8.0
59F8:  BRA    5AFA
59FA:  BNZ   5A18
59FC:  MOVF   xAC,W
59FE:  SUBWF  26,W
5A00:  BTFSS  FD8.0
5A02:  BRA    5AFA
5A04:  BNZ   5A18
5A06:  MOVF   xAB,W
5A08:  SUBWF  25,W
5A0A:  BTFSS  FD8.0
5A0C:  BRA    5AFA
5A0E:  BNZ   5A18
5A10:  MOVF   24,W
5A12:  SUBWF  xAA,W
5A14:  BTFSC  FD8.0
5A16:  BRA    5AFA
....................             { 
....................                i=0; 
5A18:  MOVLB  7
5A1A:  CLRF   x85
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
5A1C:  MOVF   x85,W
5A1E:  MOVLB  6
5A20:  ADDWF  xAA,W
5A22:  MOVLB  7
5A24:  MOVWF  xBA
5A26:  MOVLW  00
5A28:  MOVLB  6
5A2A:  ADDWFC xAB,W
5A2C:  MOVLB  7
5A2E:  MOVWF  xBB
5A30:  MOVLW  00
5A32:  MOVLB  6
5A34:  ADDWFC xAC,W
5A36:  MOVLB  7
5A38:  MOVWF  xBC
5A3A:  MOVLW  00
5A3C:  MOVLB  6
5A3E:  ADDWFC xAD,W
5A40:  MOVLB  7
5A42:  MOVWF  xBD
5A44:  CLRF   19
5A46:  BTFSC  FF2.7
5A48:  BSF    19.7
5A4A:  BCF    FF2.7
5A4C:  MOVWF  xF2
5A4E:  MOVFF  7BC,7F1
5A52:  MOVFF  7BB,7F0
5A56:  MOVFF  7BA,7EF
5A5A:  MOVLB  0
5A5C:  CALL   37E2
5A60:  BTFSC  19.7
5A62:  BSF    FF2.7
5A64:  MOVFF  01,6A4
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
5A68:  MOVLB  6
5A6A:  MOVF   xA4,W
5A6C:  SUBLW  2F
5A6E:  BC    5A76
5A70:  MOVF   xA4,W
5A72:  SUBLW  39
5A74:  BC    5A8E
5A76:  MOVF   xA4,W
5A78:  SUBLW  23
5A7A:  BZ    5A8E
5A7C:  MOVF   xA4,W
5A7E:  SUBLW  2A
5A80:  BZ    5A8E
5A82:  MOVF   xA4,W
5A84:  SUBLW  40
5A86:  BC    5AA4
5A88:  MOVF   xA4,W
5A8A:  SUBLW  5A
5A8C:  BNC   5AA4
5A8E:  CLRF   19
5A90:  BTFSC  FF2.7
5A92:  BSF    19.7
5A94:  BCF    FF2.7
....................                      fputc(ee_dat,COM2); 
5A96:  MOVFF  6A4,81A
5A9A:  MOVLB  0
5A9C:  CALL   0422
5AA0:  BTFSC  19.7
5AA2:  BSF    FF2.7
....................                   i++; 
5AA4:  MOVLB  7
5AA6:  INCF   x85,F
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
5AA8:  MOVF   x85,W
5AAA:  SUBLW  0F
5AAC:  BNC   5ABA
5AAE:  MOVLB  6
5AB0:  MOVF   xA4,F
5AB2:  BTFSC  FD8.2
5AB4:  BRA    5ABA
5AB6:  MOVLB  7
5AB8:  BRA    5A1C
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+key_numbyte; 
5ABA:  MOVLW  10
5ABC:  MOVLB  6
5ABE:  ADDWF  xAA,F
5AC0:  MOVLW  00
5AC2:  ADDWFC xAB,F
5AC4:  ADDWFC xAC,F
5AC6:  ADDWFC xAD,F
5AC8:  CLRF   19
5ACA:  BTFSC  FF2.7
5ACC:  BSF    19.7
5ACE:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
5AD0:  MOVLW  0A
5AD2:  MOVLB  8
5AD4:  MOVWF  x1A
5AD6:  MOVLB  0
5AD8:  CALL   0422
5ADC:  BTFSC  19.7
5ADE:  BSF    FF2.7
5AE0:  CLRF   19
5AE2:  BTFSC  FF2.7
5AE4:  BSF    19.7
5AE6:  BCF    FF2.7
5AE8:  MOVLW  0D
5AEA:  MOVLB  8
5AEC:  MOVWF  x1A
5AEE:  MOVLB  0
5AF0:  CALL   0422
5AF4:  BTFSC  19.7
5AF6:  BSF    FF2.7
5AF8:  MOVLB  6
....................             } 
....................             count_card++; 
5AFA:  INCF   xA5,F
5AFC:  BTFSC  FD8.2
5AFE:  INCF   xA6,F
....................          } 
5B00:  BRA    577C
5B02:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
5B04:  CLRF   FEA
5B06:  MOVLW  41
5B08:  MOVWF  FE9
5B0A:  MOVLW  00
5B0C:  CALL   012E
5B10:  TBLRD*-
5B12:  TBLRD*+
5B14:  MOVF   FF5,W
5B16:  MOVWF  FEE
5B18:  IORLW  00
5B1A:  BNZ   5B12
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5B1C:  MOVLW  01
5B1E:  MOVLB  7
5B20:  MOVWF  xBB
5B22:  MOVLW  2C
5B24:  MOVWF  xBA
5B26:  CLRF   xBD
5B28:  MOVLW  41
5B2A:  MOVWF  xBC
5B2C:  MOVLB  0
5B2E:  CALL   4EB8
5B32:  MOVF   01,F
5B34:  BNZ   5B6A
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
5B36:  MOVLW  02
5B38:  MOVWF  FF6
5B3A:  MOVLW  1F
5B3C:  MOVWF  FF7
5B3E:  CLRF   19
5B40:  BTFSC  FF2.7
5B42:  BSF    19.7
5B44:  BCF    FF2.7
5B46:  CALL   0474
5B4A:  BTFSC  19.7
5B4C:  BSF    FF2.7
....................          format_eepromext(); 
5B4E:  GOTO   5112
....................          fprintf(COM2," exit\n\r");  
5B52:  MOVLW  10
5B54:  MOVWF  FF6
5B56:  MOVLW  1F
5B58:  MOVWF  FF7
5B5A:  CLRF   19
5B5C:  BTFSC  FF2.7
5B5E:  BSF    19.7
5B60:  BCF    FF2.7
5B62:  CALL   0474
5B66:  BTFSC  19.7
5B68:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
5B6A:  CLRF   FEA
5B6C:  MOVLW  41
5B6E:  MOVWF  FE9
5B70:  MOVLW  00
5B72:  CALL   0140
5B76:  TBLRD*-
5B78:  TBLRD*+
5B7A:  MOVF   FF5,W
5B7C:  MOVWF  FEE
5B7E:  IORLW  00
5B80:  BNZ   5B78
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5B82:  MOVLW  01
5B84:  MOVLB  7
5B86:  MOVWF  xBB
5B88:  MOVLW  2C
5B8A:  MOVWF  xBA
5B8C:  CLRF   xBD
5B8E:  MOVLW  41
5B90:  MOVWF  xBC
5B92:  MOVLB  0
5B94:  CALL   4EB8
5B98:  MOVF   01,F
5B9A:  BNZ   5BD0
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
5B9C:  MOVLW  18
5B9E:  MOVWF  FF6
5BA0:  MOVLW  1F
5BA2:  MOVWF  FF7
5BA4:  CLRF   19
5BA6:  BTFSC  FF2.7
5BA8:  BSF    19.7
5BAA:  BCF    FF2.7
5BAC:  CALL   0474
5BB0:  BTFSC  19.7
5BB2:  BSF    FF2.7
....................          ease_eeprom(); 
5BB4:  GOTO   5276
....................          fprintf(COM2," exit\n\r");  
5BB8:  MOVLW  26
5BBA:  MOVWF  FF6
5BBC:  MOVLW  1F
5BBE:  MOVWF  FF7
5BC0:  CLRF   19
5BC2:  BTFSC  FF2.7
5BC4:  BSF    19.7
5BC6:  BCF    FF2.7
5BC8:  CALL   0474
5BCC:  BTFSC  19.7
5BCE:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
5BD0:  CLRF   FEA
5BD2:  MOVLW  41
5BD4:  MOVWF  FE9
5BD6:  MOVLW  00
5BD8:  CALL   0156
5BDC:  TBLRD*-
5BDE:  TBLRD*+
5BE0:  MOVF   FF5,W
5BE2:  MOVWF  FEE
5BE4:  IORLW  00
5BE6:  BNZ   5BDE
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5BE8:  MOVLW  01
5BEA:  MOVLB  7
5BEC:  MOVWF  xBB
5BEE:  MOVLW  2C
5BF0:  MOVWF  xBA
5BF2:  CLRF   xBD
5BF4:  MOVLW  41
5BF6:  MOVWF  xBC
5BF8:  MOVLB  0
5BFA:  CALL   4EB8
5BFE:  MOVF   01,F
5C00:  BNZ   5C3A
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
5C02:  MOVLW  2E
5C04:  MOVWF  FF6
5C06:  MOVLW  1F
5C08:  MOVWF  FF7
5C0A:  CLRF   19
5C0C:  BTFSC  FF2.7
5C0E:  BSF    19.7
5C10:  BCF    FF2.7
5C12:  CALL   0474
5C16:  BTFSC  19.7
5C18:  BSF    FF2.7
....................          reset_password(); 
5C1A:  GOTO   52FA
....................          init_password(); 
5C1E:  CALL   4990
....................          fprintf(COM2," exit\n\r");  
5C22:  MOVLW  44
5C24:  MOVWF  FF6
5C26:  MOVLW  1F
5C28:  MOVWF  FF7
5C2A:  CLRF   19
5C2C:  BTFSC  FF2.7
5C2E:  BSF    19.7
5C30:  BCF    FF2.7
5C32:  CALL   0474
5C36:  BTFSC  19.7
5C38:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
5C3A:  CLRF   FEA
5C3C:  MOVLW  41
5C3E:  MOVWF  FE9
5C40:  MOVLW  00
5C42:  CALL   016C
5C46:  TBLRD*-
5C48:  TBLRD*+
5C4A:  MOVF   FF5,W
5C4C:  MOVWF  FEE
5C4E:  IORLW  00
5C50:  BNZ   5C48
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5C52:  MOVLW  01
5C54:  MOVLB  7
5C56:  MOVWF  xBB
5C58:  MOVLW  2C
5C5A:  MOVWF  xBA
5C5C:  CLRF   xBD
5C5E:  MOVLW  41
5C60:  MOVWF  xBC
5C62:  MOVLB  0
5C64:  CALL   4EB8
5C68:  MOVF   01,F
5C6A:  BNZ   5C8C
....................       { 
....................          keydebug_en=1; 
5C6C:  MOVLW  01
5C6E:  MOVLB  1
5C70:  MOVWF  x0B
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
5C72:  MOVLW  4C
5C74:  MOVWF  FF6
5C76:  MOVLW  1F
5C78:  MOVWF  FF7
5C7A:  CLRF   19
5C7C:  BTFSC  FF2.7
5C7E:  BSF    19.7
5C80:  BCF    FF2.7
5C82:  MOVLB  0
5C84:  CALL   0474
5C88:  BTFSC  19.7
5C8A:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
5C8C:  CLRF   FEA
5C8E:  MOVLW  41
5C90:  MOVWF  FE9
5C92:  MOVLW  00
5C94:  CALL   0182
5C98:  TBLRD*-
5C9A:  TBLRD*+
5C9C:  MOVF   FF5,W
5C9E:  MOVWF  FEE
5CA0:  IORLW  00
5CA2:  BNZ   5C9A
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5CA4:  MOVLW  01
5CA6:  MOVLB  7
5CA8:  MOVWF  xBB
5CAA:  MOVLW  2C
5CAC:  MOVWF  xBA
5CAE:  CLRF   xBD
5CB0:  MOVLW  41
5CB2:  MOVWF  xBC
5CB4:  MOVLB  0
5CB6:  CALL   4EB8
5CBA:  MOVF   01,F
5CBC:  BNZ   5CDA
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
5CBE:  MOVLW  60
5CC0:  MOVWF  FF6
5CC2:  MOVLW  1F
5CC4:  MOVWF  FF7
5CC6:  CLRF   19
5CC8:  BTFSC  FF2.7
5CCA:  BSF    19.7
5CCC:  BCF    FF2.7
5CCE:  CALL   0474
5CD2:  BTFSC  19.7
5CD4:  BSF    FF2.7
....................          rstfact(); 
5CD6:  GOTO   5330
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
5CDA:  CLRF   FEA
5CDC:  MOVLW  41
5CDE:  MOVWF  FE9
5CE0:  MOVLW  00
5CE2:  CALL   019A
5CE6:  TBLRD*-
5CE8:  TBLRD*+
5CEA:  MOVF   FF5,W
5CEC:  MOVWF  FEE
5CEE:  IORLW  00
5CF0:  BNZ   5CE8
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
5CF2:  MOVLW  01
5CF4:  MOVLB  7
5CF6:  MOVWF  xBB
5CF8:  MOVLW  2C
5CFA:  MOVWF  xBA
5CFC:  CLRF   xBD
5CFE:  MOVLW  41
5D00:  MOVWF  xBC
5D02:  MOVLB  0
5D04:  CALL   4EB8
5D08:  MOVF   01,F
5D0A:  BNZ   5D32
....................       { 
....................          mode=LOGOFF; 
5D0C:  MOVLB  6
5D0E:  CLRF   xA3
....................          keydebug_en=0; 
5D10:  MOVLB  1
5D12:  CLRF   x0B
....................          set_tris_a(0xff); 
5D14:  MOVLW  FF
5D16:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
5D18:  MOVLW  70
5D1A:  MOVWF  FF6
5D1C:  MOVLW  1F
5D1E:  MOVWF  FF7
5D20:  CLRF   19
5D22:  BTFSC  FF2.7
5D24:  BSF    19.7
5D26:  BCF    FF2.7
5D28:  MOVLB  0
5D2A:  CALL   0474
5D2E:  BTFSC  19.7
5D30:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
5D32:  CLRF   FEA
5D34:  MOVLW  41
5D36:  MOVWF  FE9
5D38:  MOVLW  00
5D3A:  CALL   01AC
5D3E:  TBLRD*-
5D40:  TBLRD*+
5D42:  MOVF   FF5,W
5D44:  MOVWF  FEE
5D46:  IORLW  00
5D48:  BNZ   5D40
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5D4A:  MOVLW  01
5D4C:  MOVLB  7
5D4E:  MOVWF  xBB
5D50:  MOVLW  2C
5D52:  MOVWF  xBA
5D54:  CLRF   xBD
5D56:  MOVLW  41
5D58:  MOVWF  xBC
5D5A:  MOVLB  0
5D5C:  CALL   4EB8
5D60:  MOVF   01,F
5D62:  BNZ   5DC4
....................       { 
....................          fprintf(COM2,"New console name>"); 
5D64:  MOVLW  78
5D66:  MOVWF  FF6
5D68:  MOVLW  1F
5D6A:  MOVWF  FF7
5D6C:  CLRF   19
5D6E:  BTFSC  FF2.7
5D70:  BSF    19.7
5D72:  BCF    FF2.7
5D74:  CALL   0474
5D78:  BTFSC  19.7
5D7A:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,16, console); 
5D7C:  MOVLW  01
5D7E:  MOVLB  7
5D80:  MOVWF  xBA
5D82:  MOVLW  10
5D84:  MOVWF  xBB
5D86:  MOVLW  06
5D88:  MOVWF  xBD
5D8A:  MOVLW  AE
5D8C:  MOVWF  xBC
5D8E:  MOVLB  0
5D90:  CALL   4D80
....................          EEPROM_write(strobe_nameconsole,16,console); 
5D94:  MOVLW  66
5D96:  MOVLB  7
5D98:  MOVWF  xCF
5D9A:  MOVLW  10
5D9C:  MOVWF  xD0
5D9E:  MOVLW  06
5DA0:  MOVWF  xD2
5DA2:  MOVLW  AE
5DA4:  MOVWF  xD1
5DA6:  MOVLB  0
5DA8:  CALL   4938
....................          fprintf(COM2," OK\n\r"); 
5DAC:  MOVLW  8A
5DAE:  MOVWF  FF6
5DB0:  MOVLW  1F
5DB2:  MOVWF  FF7
5DB4:  CLRF   19
5DB6:  BTFSC  FF2.7
5DB8:  BSF    19.7
5DBA:  BCF    FF2.7
5DBC:  CALL   0474
5DC0:  BTFSC  19.7
5DC2:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
5DC4:  CLRF   FEA
5DC6:  MOVLW  41
5DC8:  MOVWF  FE9
5DCA:  MOVLW  00
5DCC:  CALL   01BE
5DD0:  TBLRD*-
5DD2:  TBLRD*+
5DD4:  MOVF   FF5,W
5DD6:  MOVWF  FEE
5DD8:  IORLW  00
5DDA:  BNZ   5DD2
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
5DDC:  MOVLW  01
5DDE:  MOVLB  7
5DE0:  MOVWF  xBB
5DE2:  MOVLW  2C
5DE4:  MOVWF  xBA
5DE6:  CLRF   xBD
5DE8:  MOVLW  41
5DEA:  MOVWF  xBC
5DEC:  MOVLB  0
5DEE:  CALL   4EB8
5DF2:  MOVF   01,F
5DF4:  BTFSS  FD8.2
5DF6:  BRA    605C
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
*
5EC2:  MOVLB  7
5EC4:  CLRF   xF2
5EC6:  CLRF   xF1
5EC8:  CLRF   xF0
5ECA:  MOVLW  91
5ECC:  MOVWF  xEF
5ECE:  MOVLB  0
5ED0:  CALL   37E2
5ED4:  BTFSC  19.7
5ED6:  BSF    FF2.7
5ED8:  MOVFF  01,6A9
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
5EDC:  MOVLB  6
5EDE:  MOVF   xA9,F
5EE0:  BNZ   5F00
5EE2:  MOVLW  90
5EE4:  MOVWF  FF6
5EE6:  MOVLW  1F
5EE8:  MOVWF  FF7
5EEA:  CLRF   19
5EEC:  BTFSC  FF2.7
5EEE:  BSF    19.7
5EF0:  BCF    FF2.7
5EF2:  MOVLB  0
5EF4:  CALL   0474
5EF8:  BTFSC  19.7
5EFA:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
5EFC:  BRA    5F1A
5EFE:  MOVLB  6
5F00:  MOVLW  94
5F02:  MOVWF  FF6
5F04:  MOVLW  1F
5F06:  MOVWF  FF7
5F08:  CLRF   19
5F0A:  BTFSC  FF2.7
5F0C:  BSF    19.7
5F0E:  BCF    FF2.7
5F10:  MOVLB  0
5F12:  CALL   0474
5F16:  BTFSC  19.7
5F18:  BSF    FF2.7
5F1A:  CLRF   19
5F1C:  BTFSC  FF2.7
5F1E:  BSF    19.7
5F20:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
5F22:  MOVLB  7
5F24:  CLRF   xF2
5F26:  CLRF   xF1
5F28:  CLRF   xF0
5F2A:  MOVLW  94
5F2C:  MOVWF  xEF
5F2E:  MOVLB  0
5F30:  CALL   37E2
5F34:  BTFSC  19.7
5F36:  BSF    FF2.7
5F38:  MOVFF  01,124
5F3C:  CLRF   19
5F3E:  BTFSC  FF2.7
5F40:  BSF    19.7
5F42:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
5F44:  MOVLW  5B
5F46:  MOVLB  8
5F48:  MOVWF  x1A
5F4A:  MOVLB  0
5F4C:  CALL   0422
5F50:  BTFSC  19.7
5F52:  BSF    FF2.7
5F54:  MOVFF  124,7BA
5F58:  MOVLW  1B
5F5A:  MOVLB  7
5F5C:  MOVWF  xBB
5F5E:  MOVLB  0
5F60:  GOTO   53CC
5F64:  CLRF   19
5F66:  BTFSC  FF2.7
5F68:  BSF    19.7
5F6A:  BCF    FF2.7
5F6C:  MOVLW  5D
5F6E:  MOVLB  8
5F70:  MOVWF  x1A
5F72:  MOVLB  0
5F74:  CALL   0422
5F78:  BTFSC  19.7
5F7A:  BSF    FF2.7
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
5F7C:  MOVFF  100,7BA
5F80:  MOVLW  01
5F82:  MOVLB  7
5F84:  MOVWF  xBB
5F86:  MOVLB  0
5F88:  CALL   4FF8
5F8C:  CLRF   19
5F8E:  BTFSC  FF2.7
5F90:  BSF    19.7
5F92:  BCF    FF2.7
5F94:  MOVLW  2F
5F96:  MOVLB  8
5F98:  MOVWF  x1A
5F9A:  MOVLB  0
5F9C:  CALL   0422
5FA0:  BTFSC  19.7
5FA2:  BSF    FF2.7
5FA4:  MOVFF  FF,7BA
5FA8:  MOVLW  01
5FAA:  MOVLB  7
5FAC:  MOVWF  xBB
5FAE:  MOVLB  0
5FB0:  CALL   4FF8
5FB4:  CLRF   19
5FB6:  BTFSC  FF2.7
5FB8:  BSF    19.7
5FBA:  BCF    FF2.7
5FBC:  MOVLW  20
5FBE:  MOVLB  8
5FC0:  MOVWF  x1A
5FC2:  MOVLB  0
5FC4:  CALL   0422
5FC8:  BTFSC  19.7
5FCA:  BSF    FF2.7
5FCC:  MOVFF  101,7BA
5FD0:  MOVLW  01
5FD2:  MOVLB  7
5FD4:  MOVWF  xBB
5FD6:  MOVLB  0
5FD8:  CALL   4FF8
5FDC:  CLRF   19
5FDE:  BTFSC  FF2.7
5FE0:  BSF    19.7
5FE2:  BCF    FF2.7
5FE4:  MOVLW  3A
5FE6:  MOVLB  8
5FE8:  MOVWF  x1A
5FEA:  MOVLB  0
5FEC:  CALL   0422
5FF0:  BTFSC  19.7
5FF2:  BSF    FF2.7
5FF4:  MOVFF  102,7BA
5FF8:  MOVLW  01
5FFA:  MOVLB  7
5FFC:  MOVWF  xBB
5FFE:  MOVLB  0
6000:  CALL   4FF8
6004:  CLRF   19
6006:  BTFSC  FF2.7
6008:  BSF    19.7
600A:  BCF    FF2.7
600C:  MOVLW  3A
600E:  MOVLB  8
6010:  MOVWF  x1A
6012:  MOVLB  0
6014:  CALL   0422
6018:  BTFSC  19.7
601A:  BSF    FF2.7
601C:  MOVFF  103,7BA
6020:  MOVLW  01
6022:  MOVLB  7
6024:  MOVWF  xBB
6026:  MOVLB  0
6028:  CALL   4FF8
602C:  CLRF   19
602E:  BTFSC  FF2.7
6030:  BSF    19.7
6032:  BCF    FF2.7
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
6034:  MOVLW  0A
6036:  MOVLB  8
6038:  MOVWF  x1A
603A:  MOVLB  0
603C:  CALL   0422
6040:  BTFSC  19.7
6042:  BSF    FF2.7
6044:  CLRF   19
6046:  BTFSC  FF2.7
6048:  BSF    19.7
604A:  BCF    FF2.7
604C:  MOVLW  0D
604E:  MOVLB  8
6050:  MOVWF  x1A
6052:  MOVLB  0
6054:  CALL   0422
6058:  BTFSC  19.7
605A:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
605C:  CLRF   FEA
605E:  MOVLW  41
6060:  MOVWF  FE9
6062:  MOVLW  00
6064:  CALL   01D0
6068:  TBLRD*-
606A:  TBLRD*+
606C:  MOVF   FF5,W
606E:  MOVWF  FEE
6070:  IORLW  00
6072:  BNZ   606A
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
6074:  MOVLW  01
6076:  MOVLB  7
6078:  MOVWF  xBB
607A:  MOVLW  2C
607C:  MOVWF  xBA
607E:  CLRF   xBD
6080:  MOVLW  41
6082:  MOVWF  xBC
6084:  MOVLB  0
6086:  CALL   4EB8
608A:  MOVF   01,F
608C:  BTFSS  FD8.2
608E:  BRA    62B8
....................       { 
....................          fprintf(COM2,"Year>"); 
6090:  MOVLW  98
6092:  MOVWF  FF6
6094:  MOVLW  1F
6096:  MOVWF  FF7
6098:  CLRF   19
609A:  BTFSC  FF2.7
609C:  BSF    19.7
609E:  BCF    FF2.7
60A0:  CALL   0474
60A4:  BTFSC  19.7
60A6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
60A8:  MOVLW  01
60AA:  MOVLB  7
60AC:  MOVWF  xBA
60AE:  MOVLW  03
60B0:  MOVWF  xBB
60B2:  MOVLW  07
60B4:  MOVWF  xBD
60B6:  MOVLW  86
60B8:  MOVWF  xBC
60BA:  MOVLB  0
60BC:  CALL   4D80
....................          year=(unsigned int8)strtoi(temp); 
60C0:  MOVLW  07
60C2:  MOVLB  7
60C4:  MOVWF  xBB
60C6:  MOVLW  86
60C8:  MOVWF  xBA
60CA:  MOVLB  0
60CC:  CALL   5492
60D0:  MOVFF  01,FE
....................          fprintf(COM2,"Month>"); 
60D4:  MOVLW  9E
60D6:  MOVWF  FF6
60D8:  MOVLW  1F
60DA:  MOVWF  FF7
60DC:  CLRF   19
60DE:  BTFSC  FF2.7
60E0:  BSF    19.7
60E2:  BCF    FF2.7
60E4:  CALL   0474
60E8:  BTFSC  19.7
60EA:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
60EC:  MOVLW  01
60EE:  MOVLB  7
60F0:  MOVWF  xBA
60F2:  MOVLW  03
60F4:  MOVWF  xBB
60F6:  MOVLW  07
60F8:  MOVWF  xBD
60FA:  MOVLW  86
60FC:  MOVWF  xBC
60FE:  MOVLB  0
6100:  CALL   4D80
....................          mon=(unsigned int8)strtoi(temp); 
6104:  MOVLW  07
6106:  MOVLB  7
6108:  MOVWF  xBB
610A:  MOVLW  86
610C:  MOVWF  xBA
610E:  MOVLB  0
6110:  CALL   5492
6114:  MOVFF  01,FF
....................          fprintf(COM2,"Date>"); 
6118:  MOVLW  A6
611A:  MOVWF  FF6
611C:  MOVLW  1F
611E:  MOVWF  FF7
6120:  CLRF   19
6122:  BTFSC  FF2.7
6124:  BSF    19.7
6126:  BCF    FF2.7
6128:  CALL   0474
612C:  BTFSC  19.7
612E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6130:  MOVLW  01
6132:  MOVLB  7
6134:  MOVWF  xBA
6136:  MOVLW  03
6138:  MOVWF  xBB
613A:  MOVLW  07
613C:  MOVWF  xBD
613E:  MOVLW  86
6140:  MOVWF  xBC
6142:  MOVLB  0
6144:  CALL   4D80
....................          date = (unsigned int8)strtoi(temp); 
6148:  MOVLW  07
614A:  MOVLB  7
614C:  MOVWF  xBB
614E:  MOVLW  86
6150:  MOVWF  xBA
6152:  MOVLB  0
6154:  CALL   5492
6158:  MOVFF  01,100
....................          fprintf(COM2,"Day>"); 
615C:  MOVLW  AC
615E:  MOVWF  FF6
6160:  MOVLW  1F
6162:  MOVWF  FF7
6164:  CLRF   19
6166:  BTFSC  FF2.7
6168:  BSF    19.7
616A:  BCF    FF2.7
616C:  CALL   0474
6170:  BTFSC  19.7
6172:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6174:  MOVLW  01
6176:  MOVLB  7
6178:  MOVWF  xBA
617A:  MOVLW  03
617C:  MOVWF  xBB
617E:  MOVLW  07
6180:  MOVWF  xBD
6182:  MOVLW  86
6184:  MOVWF  xBC
6186:  MOVLB  0
6188:  CALL   4D80
....................          day = (unsigned int8)strtoi(temp); 
618C:  MOVLW  07
618E:  MOVLB  7
6190:  MOVWF  xBB
6192:  MOVLW  86
6194:  MOVWF  xBA
6196:  MOVLB  0
6198:  CALL   5492
619C:  MOVFF  01,FD
....................          fprintf(COM2,"Hour>"); 
61A0:  MOVLW  B2
61A2:  MOVWF  FF6
61A4:  MOVLW  1F
61A6:  MOVWF  FF7
61A8:  CLRF   19
61AA:  BTFSC  FF2.7
61AC:  BSF    19.7
61AE:  BCF    FF2.7
61B0:  CALL   0474
61B4:  BTFSC  19.7
61B6:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
61B8:  MOVLW  01
61BA:  MOVLB  7
61BC:  MOVWF  xBA
61BE:  MOVLW  03
61C0:  MOVWF  xBB
61C2:  MOVLW  07
61C4:  MOVWF  xBD
61C6:  MOVLW  86
61C8:  MOVWF  xBC
61CA:  MOVLB  0
61CC:  CALL   4D80
....................          h = (unsigned int8)strtoi(temp); 
61D0:  MOVLW  07
61D2:  MOVLB  7
61D4:  MOVWF  xBB
61D6:  MOVLW  86
61D8:  MOVWF  xBA
61DA:  MOVLB  0
61DC:  CALL   5492
61E0:  MOVFF  01,101
....................          fprintf(COM2,"Minutes>"); 
61E4:  MOVLW  B8
61E6:  MOVWF  FF6
61E8:  MOVLW  1F
61EA:  MOVWF  FF7
61EC:  CLRF   19
61EE:  BTFSC  FF2.7
61F0:  BSF    19.7
61F2:  BCF    FF2.7
61F4:  CALL   0474
61F8:  BTFSC  19.7
61FA:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
61FC:  MOVLW  01
61FE:  MOVLB  7
6200:  MOVWF  xBA
6202:  MOVLW  03
6204:  MOVWF  xBB
6206:  MOVLW  07
6208:  MOVWF  xBD
620A:  MOVLW  86
620C:  MOVWF  xBC
620E:  MOVLB  0
6210:  CALL   4D80
....................          min = (unsigned int8)strtoi(temp);                   
6214:  MOVLW  07
6216:  MOVLB  7
6218:  MOVWF  xBB
621A:  MOVLW  86
621C:  MOVWF  xBA
621E:  MOVLB  0
6220:  CALL   5492
6224:  MOVFF  01,102
....................          fprintf(COM2,"Seconds>"); 
6228:  MOVLW  C2
622A:  MOVWF  FF6
622C:  MOVLW  1F
622E:  MOVWF  FF7
6230:  CLRF   19
6232:  BTFSC  FF2.7
6234:  BSF    19.7
6236:  BCF    FF2.7
6238:  CALL   0474
623C:  BTFSC  19.7
623E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6240:  MOVLW  01
6242:  MOVLB  7
6244:  MOVWF  xBA
6246:  MOVLW  03
6248:  MOVWF  xBB
624A:  MOVLW  07
624C:  MOVWF  xBD
624E:  MOVLW  86
6250:  MOVWF  xBC
6252:  MOVLB  0
6254:  CALL   4D80
....................          sec = (unsigned int8)strtoi(temp);                   
6258:  MOVLW  07
625A:  MOVLB  7
625C:  MOVWF  xBB
625E:  MOVLW  86
6260:  MOVWF  xBA
6262:  MOVLB  0
6264:  CALL   5492
6268:  MOVFF  01,103
626C:  CLRF   19
626E:  BTFSC  FF2.7
6270:  BSF    19.7
6272:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
6274:  MOVLW  0A
6276:  MOVLB  8
6278:  MOVWF  x1A
627A:  MOVLB  0
627C:  CALL   0422
6280:  BTFSC  19.7
6282:  BSF    FF2.7
6284:  CLRF   19
6286:  BTFSC  FF2.7
6288:  BSF    19.7
628A:  BCF    FF2.7
628C:  MOVLW  0D
628E:  MOVLB  8
6290:  MOVWF  x1A
6292:  MOVLB  0
6294:  CALL   0422
6298:  BTFSC  19.7
629A:  BSF    FF2.7
....................          rtc_set_datetime(date,mon,year,day,h,min); 
629C:  MOVFF  100,7BA
62A0:  MOVFF  FF,7BB
62A4:  MOVFF  FE,7BC
62A8:  MOVFF  FD,7BD
62AC:  MOVFF  101,7BE
62B0:  MOVFF  102,7BF
62B4:  GOTO   55CC
....................       } 
....................       strcpy(buffer2,"MS"); 
62B8:  CLRF   FEA
62BA:  MOVLW  41
62BC:  MOVWF  FE9
62BE:  MOVLW  00
62C0:  CALL   01E4
62C4:  TBLRD*-
62C6:  TBLRD*+
62C8:  MOVF   FF5,W
62CA:  MOVWF  FEE
62CC:  IORLW  00
62CE:  BNZ   62C6
....................       if(!stringcomp(buffer_uart,buffer2)) 
62D0:  MOVLW  01
62D2:  MOVLB  7
62D4:  MOVWF  xBB
62D6:  MOVLW  2C
62D8:  MOVWF  xBA
62DA:  CLRF   xBD
62DC:  MOVLW  41
62DE:  MOVWF  xBC
62E0:  MOVLB  0
62E2:  CALL   4EB8
62E6:  MOVF   01,F
62E8:  BTFSS  FD8.2
62EA:  BRA    63FE
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
62EC:  MOVLW  CC
62EE:  MOVWF  FF6
62F0:  MOVLW  1F
62F2:  MOVWF  FF7
62F4:  CLRF   19
62F6:  BTFSC  FF2.7
62F8:  BSF    19.7
62FA:  BCF    FF2.7
62FC:  CALL   0474
6300:  BTFSC  19.7
6302:  BSF    FF2.7
6304:  CLRF   19
6306:  BTFSC  FF2.7
6308:  BSF    19.7
630A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
630C:  MOVLW  0A
630E:  MOVLB  8
6310:  MOVWF  x1A
6312:  MOVLB  0
6314:  CALL   0422
6318:  BTFSC  19.7
631A:  BSF    FF2.7
631C:  CLRF   19
631E:  BTFSC  FF2.7
6320:  BSF    19.7
6322:  BCF    FF2.7
6324:  MOVLW  0D
6326:  MOVLB  8
6328:  MOVWF  x1A
632A:  MOVLB  0
632C:  CALL   0422
6330:  BTFSC  19.7
6332:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
6334:  MOVLW  EC
6336:  MOVWF  FF6
6338:  MOVLW  1F
633A:  MOVWF  FF7
633C:  CLRF   19
633E:  BTFSC  FF2.7
6340:  BSF    19.7
6342:  BCF    FF2.7
6344:  CALL   0474
6348:  BTFSC  19.7
634A:  BSF    FF2.7
634C:  CLRF   19
634E:  BTFSC  FF2.7
6350:  BSF    19.7
6352:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6354:  MOVLW  0A
6356:  MOVLB  8
6358:  MOVWF  x1A
635A:  MOVLB  0
635C:  CALL   0422
6360:  BTFSC  19.7
6362:  BSF    FF2.7
6364:  CLRF   19
6366:  BTFSC  FF2.7
6368:  BSF    19.7
636A:  BCF    FF2.7
636C:  MOVLW  0D
636E:  MOVLB  8
6370:  MOVWF  x1A
6372:  MOVLB  0
6374:  CALL   0422
6378:  BTFSC  19.7
637A:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
637C:  MOVLW  01
637E:  MOVLB  7
6380:  MOVWF  xBA
6382:  MOVLW  03
6384:  MOVWF  xBB
6386:  MOVLW  07
6388:  MOVWF  xBD
638A:  MOVLW  86
638C:  MOVWF  xBC
638E:  MOVLB  0
6390:  CALL   4D80
....................           mode_sl = (unsigned int8)strtoi(temp); 
6394:  MOVLW  07
6396:  MOVLB  7
6398:  MOVWF  xBB
639A:  MOVLW  86
639C:  MOVWF  xBA
639E:  MOVLB  0
63A0:  CALL   5492
63A4:  MOVFF  01,6A9
63A8:  CLRF   19
63AA:  BTFSC  FF2.7
63AC:  BSF    19.7
63AE:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
63B0:  MOVLB  8
63B2:  CLRF   x05
63B4:  CLRF   x04
63B6:  CLRF   x03
63B8:  MOVLW  91
63BA:  MOVWF  x02
63BC:  MOVFF  6A9,806
63C0:  MOVLB  0
63C2:  CALL   3D80
63C6:  BTFSC  19.7
63C8:  BSF    FF2.7
....................           set_tris_a(0xff); 
63CA:  MOVLW  FF
63CC:  MOVWF  F92
63CE:  CLRF   19
63D0:  BTFSC  FF2.7
63D2:  BSF    19.7
63D4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
63D6:  MOVLW  0A
63D8:  MOVLB  8
63DA:  MOVWF  x1A
63DC:  MOVLB  0
63DE:  CALL   0422
63E2:  BTFSC  19.7
63E4:  BSF    FF2.7
63E6:  CLRF   19
63E8:  BTFSC  FF2.7
63EA:  BSF    19.7
63EC:  BCF    FF2.7
63EE:  MOVLW  0D
63F0:  MOVLB  8
63F2:  MOVWF  x1A
63F4:  MOVLB  0
63F6:  CALL   0422
63FA:  BTFSC  19.7
63FC:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"KP"); 
63FE:  CLRF   FEA
6400:  MOVLW  41
6402:  MOVWF  FE9
6404:  MOVLW  00
6406:  CALL   01F8
640A:  TBLRD*-
640C:  TBLRD*+
640E:  MOVF   FF5,W
6410:  MOVWF  FEE
6412:  IORLW  00
6414:  BNZ   640C
....................       if(!stringcomp(buffer_uart,buffer2)) 
6416:  MOVLW  01
6418:  MOVLB  7
641A:  MOVWF  xBB
641C:  MOVLW  2C
641E:  MOVWF  xBA
6420:  CLRF   xBD
6422:  MOVLW  41
6424:  MOVWF  xBC
6426:  MOVLB  0
6428:  CALL   4EB8
642C:  MOVF   01,F
642E:  BTFSS  FD8.2
6430:  BRA    6540
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
6432:  MOVLW  0C
6434:  MOVWF  FF6
6436:  MOVLW  20
6438:  MOVWF  FF7
643A:  CLRF   19
643C:  BTFSC  FF2.7
643E:  BSF    19.7
6440:  BCF    FF2.7
6442:  CALL   0474
6446:  BTFSC  19.7
6448:  BSF    FF2.7
644A:  CLRF   19
644C:  BTFSC  FF2.7
644E:  BSF    19.7
6450:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6452:  MOVLW  0A
6454:  MOVLB  8
6456:  MOVWF  x1A
6458:  MOVLB  0
645A:  CALL   0422
645E:  BTFSC  19.7
6460:  BSF    FF2.7
6462:  CLRF   19
6464:  BTFSC  FF2.7
6466:  BSF    19.7
6468:  BCF    FF2.7
646A:  MOVLW  0D
646C:  MOVLB  8
646E:  MOVWF  x1A
6470:  MOVLB  0
6472:  CALL   0422
6476:  BTFSC  19.7
6478:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
647A:  MOVLW  2A
647C:  MOVWF  FF6
647E:  MOVLW  20
6480:  MOVWF  FF7
6482:  CLRF   19
6484:  BTFSC  FF2.7
6486:  BSF    19.7
6488:  BCF    FF2.7
648A:  CALL   0474
648E:  BTFSC  19.7
6490:  BSF    FF2.7
6492:  CLRF   19
6494:  BTFSC  FF2.7
6496:  BSF    19.7
6498:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
649A:  MOVLW  0A
649C:  MOVLB  8
649E:  MOVWF  x1A
64A0:  MOVLB  0
64A2:  CALL   0422
64A6:  BTFSC  19.7
64A8:  BSF    FF2.7
64AA:  CLRF   19
64AC:  BTFSC  FF2.7
64AE:  BSF    19.7
64B0:  BCF    FF2.7
64B2:  MOVLW  0D
64B4:  MOVLB  8
64B6:  MOVWF  x1A
64B8:  MOVLB  0
64BA:  CALL   0422
64BE:  BTFSC  19.7
64C0:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
64C2:  MOVLW  01
64C4:  MOVLB  7
64C6:  MOVWF  xBA
64C8:  MOVLW  03
64CA:  MOVWF  xBB
64CC:  MOVLW  07
64CE:  MOVWF  xBD
64D0:  MOVLW  86
64D2:  MOVWF  xBC
64D4:  MOVLB  0
64D6:  CALL   4D80
....................           KP_mode = (unsigned int8)strtoi(temp); 
64DA:  MOVLW  07
64DC:  MOVLB  7
64DE:  MOVWF  xBB
64E0:  MOVLW  86
64E2:  MOVWF  xBA
64E4:  MOVLB  0
64E6:  CALL   5492
64EA:  MOVFF  01,10F
64EE:  CLRF   19
64F0:  BTFSC  FF2.7
64F2:  BSF    19.7
64F4:  BCF    FF2.7
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
64F6:  MOVLB  8
64F8:  CLRF   x05
64FA:  CLRF   x04
64FC:  CLRF   x03
64FE:  MOVLW  7F
6500:  MOVWF  x02
6502:  MOVFF  10F,806
6506:  MOVLB  0
6508:  CALL   3D80
650C:  BTFSC  19.7
650E:  BSF    FF2.7
6510:  CLRF   19
6512:  BTFSC  FF2.7
6514:  BSF    19.7
6516:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6518:  MOVLW  0A
651A:  MOVLB  8
651C:  MOVWF  x1A
651E:  MOVLB  0
6520:  CALL   0422
6524:  BTFSC  19.7
6526:  BSF    FF2.7
6528:  CLRF   19
652A:  BTFSC  FF2.7
652C:  BSF    19.7
652E:  BCF    FF2.7
6530:  MOVLW  0D
6532:  MOVLB  8
6534:  MOVWF  x1A
6536:  MOVLB  0
6538:  CALL   0422
653C:  BTFSC  19.7
653E:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"tran time"); 
6540:  CLRF   FEA
6542:  MOVLW  41
6544:  MOVWF  FE9
6546:  MOVLW  00
6548:  CALL   020C
654C:  TBLRD*-
654E:  TBLRD*+
6550:  MOVF   FF5,W
6552:  MOVWF  FEE
6554:  IORLW  00
6556:  BNZ   654E
....................       if(!stringcomp(buffer_uart,buffer2)) 
6558:  MOVLW  01
655A:  MOVLB  7
655C:  MOVWF  xBB
655E:  MOVLW  2C
6560:  MOVWF  xBA
6562:  CLRF   xBD
6564:  MOVLW  41
6566:  MOVWF  xBC
6568:  MOVLB  0
656A:  CALL   4EB8
656E:  MOVF   01,F
6570:  BNZ   6638
....................       { 
....................           fprintf(COM2,"Input Number"); 
6572:  MOVLW  48
6574:  MOVWF  FF6
6576:  MOVLW  20
6578:  MOVWF  FF7
657A:  CLRF   19
657C:  BTFSC  FF2.7
657E:  BSF    19.7
6580:  BCF    FF2.7
6582:  CALL   0474
6586:  BTFSC  19.7
6588:  BSF    FF2.7
658A:  CLRF   19
658C:  BTFSC  FF2.7
658E:  BSF    19.7
6590:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6592:  MOVLW  0A
6594:  MOVLB  8
6596:  MOVWF  x1A
6598:  MOVLB  0
659A:  CALL   0422
659E:  BTFSC  19.7
65A0:  BSF    FF2.7
65A2:  CLRF   19
65A4:  BTFSC  FF2.7
65A6:  BSF    19.7
65A8:  BCF    FF2.7
65AA:  MOVLW  0D
65AC:  MOVLB  8
65AE:  MOVWF  x1A
65B0:  MOVLB  0
65B2:  CALL   0422
65B6:  BTFSC  19.7
65B8:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
65BA:  MOVLW  01
65BC:  MOVLB  7
65BE:  MOVWF  xBA
65C0:  MOVLW  03
65C2:  MOVWF  xBB
65C4:  MOVLW  07
65C6:  MOVWF  xBD
65C8:  MOVLW  86
65CA:  MOVWF  xBC
65CC:  MOVLB  0
65CE:  CALL   4D80
....................           delaycharaction = (unsigned int8)strtoi(temp); 
65D2:  MOVLW  07
65D4:  MOVLB  7
65D6:  MOVWF  xBB
65D8:  MOVLW  86
65DA:  MOVWF  xBA
65DC:  MOVLB  0
65DE:  CALL   5492
65E2:  MOVFF  01,124
65E6:  CLRF   19
65E8:  BTFSC  FF2.7
65EA:  BSF    19.7
65EC:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
65EE:  MOVLB  8
65F0:  CLRF   x05
65F2:  CLRF   x04
65F4:  CLRF   x03
65F6:  MOVLW  94
65F8:  MOVWF  x02
65FA:  MOVFF  124,806
65FE:  MOVLB  0
6600:  CALL   3D80
6604:  BTFSC  19.7
6606:  BSF    FF2.7
6608:  CLRF   19
660A:  BTFSC  FF2.7
660C:  BSF    19.7
660E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6610:  MOVLW  0A
6612:  MOVLB  8
6614:  MOVWF  x1A
6616:  MOVLB  0
6618:  CALL   0422
661C:  BTFSC  19.7
661E:  BSF    FF2.7
6620:  CLRF   19
6622:  BTFSC  FF2.7
6624:  BSF    19.7
6626:  BCF    FF2.7
6628:  MOVLW  0D
662A:  MOVLB  8
662C:  MOVWF  x1A
662E:  MOVLB  0
6630:  CALL   0422
6634:  BTFSC  19.7
6636:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
6638:  CLRF   FEA
663A:  MOVLW  41
663C:  MOVWF  FE9
663E:  MOVLW  00
6640:  CALL   0226
6644:  TBLRD*-
6646:  TBLRD*+
6648:  MOVF   FF5,W
664A:  MOVWF  FEE
664C:  IORLW  00
664E:  BNZ   6646
....................       if(!stringcomp(buffer_uart,buffer2)) 
6650:  MOVLW  01
6652:  MOVLB  7
6654:  MOVWF  xBB
6656:  MOVLW  2C
6658:  MOVWF  xBA
665A:  CLRF   xBD
665C:  MOVLW  41
665E:  MOVWF  xBC
6660:  MOVLB  0
6662:  CALL   4EB8
6666:  MOVF   01,F
6668:  BTFSS  FD8.2
666A:  BRA    677A
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
666C:  MOVLW  56
666E:  MOVWF  FF6
6670:  MOVLW  20
6672:  MOVWF  FF7
6674:  CLRF   19
6676:  BTFSC  FF2.7
6678:  BSF    19.7
667A:  BCF    FF2.7
667C:  CALL   0474
6680:  BTFSC  19.7
6682:  BSF    FF2.7
6684:  CLRF   19
6686:  BTFSC  FF2.7
6688:  BSF    19.7
668A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
668C:  MOVLW  0A
668E:  MOVLB  8
6690:  MOVWF  x1A
6692:  MOVLB  0
6694:  CALL   0422
6698:  BTFSC  19.7
669A:  BSF    FF2.7
669C:  CLRF   19
669E:  BTFSC  FF2.7
66A0:  BSF    19.7
66A2:  BCF    FF2.7
66A4:  MOVLW  0D
66A6:  MOVLB  8
66A8:  MOVWF  x1A
66AA:  MOVLB  0
66AC:  CALL   0422
66B0:  BTFSC  19.7
66B2:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
66B4:  MOVLW  7C
66B6:  MOVWF  FF6
66B8:  MOVLW  20
66BA:  MOVWF  FF7
66BC:  CLRF   19
66BE:  BTFSC  FF2.7
66C0:  BSF    19.7
66C2:  BCF    FF2.7
66C4:  CALL   0474
66C8:  BTFSC  19.7
66CA:  BSF    FF2.7
66CC:  CLRF   19
66CE:  BTFSC  FF2.7
66D0:  BSF    19.7
66D2:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
66D4:  MOVLW  0A
66D6:  MOVLB  8
66D8:  MOVWF  x1A
66DA:  MOVLB  0
66DC:  CALL   0422
66E0:  BTFSC  19.7
66E2:  BSF    FF2.7
66E4:  CLRF   19
66E6:  BTFSC  FF2.7
66E8:  BSF    19.7
66EA:  BCF    FF2.7
66EC:  MOVLW  0D
66EE:  MOVLB  8
66F0:  MOVWF  x1A
66F2:  MOVLB  0
66F4:  CALL   0422
66F8:  BTFSC  19.7
66FA:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
66FC:  MOVLW  01
66FE:  MOVLB  7
6700:  MOVWF  xBA
6702:  MOVLW  03
6704:  MOVWF  xBB
6706:  MOVLW  07
6708:  MOVWF  xBD
670A:  MOVLW  86
670C:  MOVWF  xBC
670E:  MOVLB  0
6710:  CALL   4D80
....................           type_KB=(unsigned int8)strtoi(temp); 
6714:  MOVLW  07
6716:  MOVLB  7
6718:  MOVWF  xBB
671A:  MOVLW  86
671C:  MOVWF  xBA
671E:  MOVLB  0
6720:  CALL   5492
6724:  MOVFF  01,113
6728:  CLRF   19
672A:  BTFSC  FF2.7
672C:  BSF    19.7
672E:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
6730:  MOVLB  8
6732:  CLRF   x05
6734:  CLRF   x04
6736:  CLRF   x03
6738:  MOVLW  7E
673A:  MOVWF  x02
673C:  MOVFF  113,806
6740:  MOVLB  0
6742:  CALL   3D80
6746:  BTFSC  19.7
6748:  BSF    FF2.7
674A:  CLRF   19
674C:  BTFSC  FF2.7
674E:  BSF    19.7
6750:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
6752:  MOVLW  0A
6754:  MOVLB  8
6756:  MOVWF  x1A
6758:  MOVLB  0
675A:  CALL   0422
675E:  BTFSC  19.7
6760:  BSF    FF2.7
6762:  CLRF   19
6764:  BTFSC  FF2.7
6766:  BSF    19.7
6768:  BCF    FF2.7
676A:  MOVLW  0D
676C:  MOVLB  8
676E:  MOVWF  x1A
6770:  MOVLB  0
6772:  CALL   0422
6776:  BTFSC  19.7
6778:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
677A:  CLRF   FEA
677C:  MOVLW  41
677E:  MOVWF  FE9
6780:  MOVLW  00
6782:  CALL   023C
6786:  TBLRD*-
6788:  TBLRD*+
678A:  MOVF   FF5,W
678C:  MOVWF  FEE
678E:  IORLW  00
6790:  BNZ   6788
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
6792:  MOVLW  01
6794:  MOVLB  7
6796:  MOVWF  xBB
6798:  MOVLW  2C
679A:  MOVWF  xBA
679C:  CLRF   xBD
679E:  MOVLW  41
67A0:  MOVWF  xBC
67A2:  MOVLB  0
67A4:  CALL   4EB8
67A8:  MOVF   01,F
67AA:  BTFSS  FD8.2
67AC:  BRA    6994
....................       { 
....................          printf("h-> Help\n\r"); 
67AE:  MOVLW  A2
67B0:  MOVWF  FF6
67B2:  MOVLW  20
67B4:  MOVWF  FF7
67B6:  CLRF   19
67B8:  BTFSC  FF2.7
67BA:  BSF    19.7
67BC:  BCF    FF2.7
67BE:  CALL   0474
67C2:  BTFSC  19.7
67C4:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
67C6:  MOVLW  AE
67C8:  MOVWF  FF6
67CA:  MOVLW  20
67CC:  MOVWF  FF7
67CE:  CLRF   19
67D0:  BTFSC  FF2.7
67D2:  BSF    19.7
67D4:  BCF    FF2.7
67D6:  CALL   0474
67DA:  BTFSC  19.7
67DC:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
67DE:  MOVLW  C0
67E0:  MOVWF  FF6
67E2:  MOVLW  20
67E4:  MOVWF  FF7
67E6:  CLRF   19
67E8:  BTFSC  FF2.7
67EA:  BSF    19.7
67EC:  BCF    FF2.7
67EE:  CALL   0474
67F2:  BTFSC  19.7
67F4:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
67F6:  MOVLW  D2
67F8:  MOVWF  FF6
67FA:  MOVLW  20
67FC:  MOVWF  FF7
67FE:  CLRF   19
6800:  BTFSC  FF2.7
6802:  BSF    19.7
6804:  BCF    FF2.7
6806:  CALL   0474
680A:  BTFSC  19.7
680C:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
680E:  MOVLW  F2
6810:  MOVWF  FF6
6812:  MOVLW  20
6814:  MOVWF  FF7
6816:  CLRF   19
6818:  BTFSC  FF2.7
681A:  BSF    19.7
681C:  BCF    FF2.7
681E:  CALL   0474
6822:  BTFSC  19.7
6824:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
6826:  MOVLW  0E
6828:  MOVWF  FF6
682A:  MOVLW  21
682C:  MOVWF  FF7
682E:  CLRF   19
6830:  BTFSC  FF2.7
6832:  BSF    19.7
6834:  BCF    FF2.7
6836:  CALL   0474
683A:  BTFSC  19.7
683C:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
683E:  MOVLW  1C
6840:  MOVWF  FF6
6842:  MOVLW  21
6844:  MOVWF  FF7
6846:  CLRF   19
6848:  BTFSC  FF2.7
684A:  BSF    19.7
684C:  BCF    FF2.7
684E:  CALL   0474
6852:  BTFSC  19.7
6854:  BSF    FF2.7
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
6856:  MOVLW  28
6858:  MOVWF  FF6
685A:  MOVLW  21
685C:  MOVWF  FF7
685E:  CLRF   19
6860:  BTFSC  FF2.7
6862:  BSF    19.7
6864:  BCF    FF2.7
6866:  CALL   0474
686A:  BTFSC  19.7
686C:  BSF    FF2.7
686E:  CLRF   19
6870:  BTFSC  FF2.7
6872:  BSF    19.7
6874:  BCF    FF2.7
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
6876:  MOVLB  7
6878:  CLRF   xF2
687A:  CLRF   xF1
687C:  CLRF   xF0
687E:  MOVLW  7F
6880:  MOVWF  xEF
6882:  MOVLB  0
6884:  CALL   37E2
6888:  BTFSC  19.7
688A:  BSF    FF2.7
688C:  MOVFF  01,10F
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
6890:  MOVLB  1
6892:  MOVF   x0F,F
6894:  BZ    68B4
6896:  MOVLW  54
6898:  MOVWF  FF6
689A:  MOVLW  21
689C:  MOVWF  FF7
689E:  CLRF   19
68A0:  BTFSC  FF2.7
68A2:  BSF    19.7
68A4:  BCF    FF2.7
68A6:  MOVLB  0
68A8:  CALL   0474
68AC:  BTFSC  19.7
68AE:  BSF    FF2.7
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
68B0:  BRA    68CE
68B2:  MOVLB  1
68B4:  MOVLW  76
68B6:  MOVWF  FF6
68B8:  MOVLW  21
68BA:  MOVWF  FF7
68BC:  CLRF   19
68BE:  BTFSC  FF2.7
68C0:  BSF    19.7
68C2:  BCF    FF2.7
68C4:  MOVLB  0
68C6:  CALL   0474
68CA:  BTFSC  19.7
68CC:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
68CE:  MOVLW  9A
68D0:  MOVWF  FF6
68D2:  MOVLW  21
68D4:  MOVWF  FF7
68D6:  CLRF   19
68D8:  BTFSC  FF2.7
68DA:  BSF    19.7
68DC:  BCF    FF2.7
68DE:  CALL   0474
68E2:  BTFSC  19.7
68E4:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
68E6:  MOVLW  C2
68E8:  MOVWF  FF6
68EA:  MOVLW  21
68EC:  MOVWF  FF7
68EE:  CLRF   19
68F0:  BTFSC  FF2.7
68F2:  BSF    19.7
68F4:  BCF    FF2.7
68F6:  CALL   0474
68FA:  BTFSC  19.7
68FC:  BSF    FF2.7
68FE:  CLRF   19
6900:  BTFSC  FF2.7
6902:  BSF    19.7
6904:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
6906:  MOVLB  7
6908:  CLRF   xF2
690A:  CLRF   xF1
690C:  CLRF   xF0
690E:  MOVLW  7E
6910:  MOVWF  xEF
6912:  MOVLB  0
6914:  CALL   37E2
6918:  BTFSC  19.7
691A:  BSF    FF2.7
691C:  MOVFF  01,7BA
6920:  MOVLW  DE
6922:  MOVWF  FF6
6924:  MOVLW  21
6926:  MOVWF  FF7
6928:  CLRF   19
692A:  BTFSC  FF2.7
692C:  BSF    19.7
692E:  BCF    FF2.7
6930:  MOVLW  06
6932:  MOVLB  8
6934:  MOVWF  x0E
6936:  MOVLB  0
6938:  CALL   1864
693C:  BTFSC  19.7
693E:  BSF    FF2.7
6940:  CLRF   19
6942:  BTFSC  FF2.7
6944:  BSF    19.7
6946:  BCF    FF2.7
6948:  MOVFF  7BA,7EF
694C:  MOVLW  18
694E:  MOVLB  7
6950:  MOVWF  xF0
6952:  MOVLB  0
6954:  CALL   1978
6958:  BTFSC  19.7
695A:  BSF    FF2.7
695C:  MOVLW  E6
695E:  MOVWF  FF6
6960:  MOVLW  21
6962:  MOVWF  FF7
6964:  CLRF   19
6966:  BTFSC  FF2.7
6968:  BSF    19.7
696A:  BCF    FF2.7
696C:  MOVLW  1D
696E:  MOVLB  8
6970:  MOVWF  x0E
6972:  MOVLB  0
6974:  CALL   1864
6978:  BTFSC  19.7
697A:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
697C:  MOVLW  04
697E:  MOVWF  FF6
6980:  MOVLW  22
6982:  MOVWF  FF7
6984:  CLRF   19
6986:  BTFSC  FF2.7
6988:  BSF    19.7
698A:  BCF    FF2.7
698C:  CALL   0474
6990:  BTFSC  19.7
6992:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
6994:  CLRF   FEA
6996:  MOVLW  41
6998:  MOVWF  FE9
699A:  MOVLW  00
699C:  CALL   024E
69A0:  TBLRD*-
69A2:  TBLRD*+
69A4:  MOVF   FF5,W
69A6:  MOVWF  FEE
69A8:  IORLW  00
69AA:  BNZ   69A2
....................       if(!stringcomp(buffer_uart,buffer2))  
69AC:  MOVLW  01
69AE:  MOVLB  7
69B0:  MOVWF  xBB
69B2:  MOVLW  2C
69B4:  MOVWF  xBA
69B6:  CLRF   xBD
69B8:  MOVLW  41
69BA:  MOVWF  xBC
69BC:  MOVLB  0
69BE:  CALL   4EB8
69C2:  MOVF   01,F
69C4:  BTFSS  FD8.2
69C6:  BRA    6AF6
....................       { 
....................          fprintf(COM2,"old password:"); 
69C8:  MOVLW  1E
69CA:  MOVWF  FF6
69CC:  MOVLW  22
69CE:  MOVWF  FF7
69D0:  CLRF   19
69D2:  BTFSC  FF2.7
69D4:  BSF    19.7
69D6:  BCF    FF2.7
69D8:  CALL   0474
69DC:  BTFSC  19.7
69DE:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
69E0:  MOVLB  7
69E2:  CLRF   xBA
69E4:  MOVLW  14
69E6:  MOVWF  xBB
69E8:  CLRF   xBD
69EA:  MOVLW  55
69EC:  MOVWF  xBC
69EE:  MOVLB  0
69F0:  CALL   48DA
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
69F4:  MOVLW  02
69F6:  MOVLB  7
69F8:  MOVWF  xBA
69FA:  MOVLW  14
69FC:  MOVWF  xBB
69FE:  CLRF   xBD
6A00:  MOVLW  69
6A02:  MOVWF  xBC
6A04:  MOVLB  0
6A06:  CALL   4D80
....................          if(!stringcomp(entpassword,password)) 
6A0A:  MOVLB  7
6A0C:  CLRF   xBB
6A0E:  MOVLW  69
6A10:  MOVWF  xBA
6A12:  CLRF   xBD
6A14:  MOVLW  55
6A16:  MOVWF  xBC
6A18:  MOVLB  0
6A1A:  CALL   4EB8
6A1E:  MOVF   01,F
6A20:  BNZ   6ADE
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
6A22:  MOVLW  2C
6A24:  MOVWF  FF6
6A26:  MOVLW  22
6A28:  MOVWF  FF7
6A2A:  CLRF   19
6A2C:  BTFSC  FF2.7
6A2E:  BSF    19.7
6A30:  BCF    FF2.7
6A32:  CALL   0474
6A36:  BTFSC  19.7
6A38:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
6A3A:  MOVLW  02
6A3C:  MOVLB  7
6A3E:  MOVWF  xBA
6A40:  MOVLW  14
6A42:  MOVWF  xBB
6A44:  CLRF   xBD
6A46:  MOVLW  69
6A48:  MOVWF  xBC
6A4A:  MOVLB  0
6A4C:  CALL   4D80
....................             fprintf(COM2,"\n\ragain:"); 
6A50:  MOVLW  34
6A52:  MOVWF  FF6
6A54:  MOVLW  22
6A56:  MOVWF  FF7
6A58:  CLRF   19
6A5A:  BTFSC  FF2.7
6A5C:  BSF    19.7
6A5E:  BCF    FF2.7
6A60:  CALL   0474
6A64:  BTFSC  19.7
6A66:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
6A68:  MOVLW  02
6A6A:  MOVLB  7
6A6C:  MOVWF  xBA
6A6E:  MOVLW  14
6A70:  MOVWF  xBB
6A72:  CLRF   xBD
6A74:  MOVLW  55
6A76:  MOVWF  xBC
6A78:  MOVLB  0
6A7A:  CALL   4D80
....................             if(!stringcomp(entpassword,password)) 
6A7E:  MOVLB  7
6A80:  CLRF   xBB
6A82:  MOVLW  69
6A84:  MOVWF  xBA
6A86:  CLRF   xBD
6A88:  MOVLW  55
6A8A:  MOVWF  xBC
6A8C:  MOVLB  0
6A8E:  CALL   4EB8
6A92:  MOVF   01,F
6A94:  BNZ   6AC4
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
6A96:  MOVLB  7
6A98:  CLRF   xCF
6A9A:  MOVLW  14
6A9C:  MOVWF  xD0
6A9E:  CLRF   xD2
6AA0:  MOVLW  55
6AA2:  MOVWF  xD1
6AA4:  MOVLB  0
6AA6:  CALL   4938
....................                fprintf(COM2,"\n\rOK\n\r");    
6AAA:  MOVLW  3E
6AAC:  MOVWF  FF6
6AAE:  MOVLW  22
6AB0:  MOVWF  FF7
6AB2:  CLRF   19
6AB4:  BTFSC  FF2.7
6AB6:  BSF    19.7
6AB8:  BCF    FF2.7
6ABA:  CALL   0474
6ABE:  BTFSC  19.7
6AC0:  BSF    FF2.7
....................             } 
....................                else 
6AC2:  BRA    6ADC
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
6AC4:  MOVLW  46
6AC6:  MOVWF  FF6
6AC8:  MOVLW  22
6ACA:  MOVWF  FF7
6ACC:  CLRF   19
6ACE:  BTFSC  FF2.7
6AD0:  BSF    19.7
6AD2:  BCF    FF2.7
6AD4:  CALL   0474
6AD8:  BTFSC  19.7
6ADA:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
6ADC:  BRA    6AF6
....................             { 
....................                fprintf(COM2," X\n\r"); 
6ADE:  MOVLW  4E
6AE0:  MOVWF  FF6
6AE2:  MOVLW  22
6AE4:  MOVWF  FF7
6AE6:  CLRF   19
6AE8:  BTFSC  FF2.7
6AEA:  BSF    19.7
6AEC:  BCF    FF2.7
6AEE:  CALL   0474
6AF2:  BTFSC  19.7
6AF4:  BSF    FF2.7
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
6AF6:  CLRF   FEA
6AF8:  MOVLW  41
6AFA:  MOVWF  FE9
6AFC:  MOVLW  00
6AFE:  CALL   0268
6B02:  TBLRD*-
6B04:  TBLRD*+
6B06:  MOVF   FF5,W
6B08:  MOVWF  FEE
6B0A:  IORLW  00
6B0C:  BNZ   6B04
....................       if(!stringcomp(buffer_uart,buffer2)) 
6B0E:  MOVLW  01
6B10:  MOVLB  7
6B12:  MOVWF  xBB
6B14:  MOVLW  2C
6B16:  MOVWF  xBA
6B18:  CLRF   xBD
6B1A:  MOVLW  41
6B1C:  MOVWF  xBC
6B1E:  MOVLB  0
6B20:  CALL   4EB8
6B24:  MOVF   01,F
6B26:  BTFSS  FD8.2
6B28:  BRA    6C38
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
6B2A:  MOVLW  54
6B2C:  MOVWF  FF6
6B2E:  MOVLW  22
6B30:  MOVWF  FF7
6B32:  CLRF   19
6B34:  BTFSC  FF2.7
6B36:  BSF    19.7
6B38:  BCF    FF2.7
6B3A:  CALL   0474
6B3E:  BTFSC  19.7
6B40:  BSF    FF2.7
6B42:  CLRF   19
6B44:  BTFSC  FF2.7
6B46:  BSF    19.7
6B48:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6B4A:  MOVLW  0A
6B4C:  MOVLB  8
6B4E:  MOVWF  x1A
6B50:  MOVLB  0
6B52:  CALL   0422
6B56:  BTFSC  19.7
6B58:  BSF    FF2.7
6B5A:  CLRF   19
6B5C:  BTFSC  FF2.7
6B5E:  BSF    19.7
6B60:  BCF    FF2.7
6B62:  MOVLW  0D
6B64:  MOVLB  8
6B66:  MOVWF  x1A
6B68:  MOVLB  0
6B6A:  CALL   0422
6B6E:  BTFSC  19.7
6B70:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
6B72:  MOVLW  74
6B74:  MOVWF  FF6
6B76:  MOVLW  22
6B78:  MOVWF  FF7
6B7A:  CLRF   19
6B7C:  BTFSC  FF2.7
6B7E:  BSF    19.7
6B80:  BCF    FF2.7
6B82:  CALL   0474
6B86:  BTFSC  19.7
6B88:  BSF    FF2.7
6B8A:  CLRF   19
6B8C:  BTFSC  FF2.7
6B8E:  BSF    19.7
6B90:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6B92:  MOVLW  0A
6B94:  MOVLB  8
6B96:  MOVWF  x1A
6B98:  MOVLB  0
6B9A:  CALL   0422
6B9E:  BTFSC  19.7
6BA0:  BSF    FF2.7
6BA2:  CLRF   19
6BA4:  BTFSC  FF2.7
6BA6:  BSF    19.7
6BA8:  BCF    FF2.7
6BAA:  MOVLW  0D
6BAC:  MOVLB  8
6BAE:  MOVWF  x1A
6BB0:  MOVLB  0
6BB2:  CALL   0422
6BB6:  BTFSC  19.7
6BB8:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6BBA:  MOVLW  01
6BBC:  MOVLB  7
6BBE:  MOVWF  xBA
6BC0:  MOVLW  03
6BC2:  MOVWF  xBB
6BC4:  MOVLW  07
6BC6:  MOVWF  xBD
6BC8:  MOVLW  86
6BCA:  MOVWF  xBC
6BCC:  MOVLB  0
6BCE:  CALL   4D80
....................           debugmode = (unsigned int8)strtoi(temp); 
6BD2:  MOVLW  07
6BD4:  MOVLB  7
6BD6:  MOVWF  xBB
6BD8:  MOVLW  86
6BDA:  MOVWF  xBA
6BDC:  MOVLB  0
6BDE:  CALL   5492
6BE2:  MOVFF  01,69D
6BE6:  CLRF   19
6BE8:  BTFSC  FF2.7
6BEA:  BSF    19.7
6BEC:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
6BEE:  MOVLB  8
6BF0:  CLRF   x05
6BF2:  CLRF   x04
6BF4:  CLRF   x03
6BF6:  MOVLW  92
6BF8:  MOVWF  x02
6BFA:  MOVFF  69D,806
6BFE:  MOVLB  0
6C00:  CALL   3D80
6C04:  BTFSC  19.7
6C06:  BSF    FF2.7
6C08:  CLRF   19
6C0A:  BTFSC  FF2.7
6C0C:  BSF    19.7
6C0E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6C10:  MOVLW  0A
6C12:  MOVLB  8
6C14:  MOVWF  x1A
6C16:  MOVLB  0
6C18:  CALL   0422
6C1C:  BTFSC  19.7
6C1E:  BSF    FF2.7
6C20:  CLRF   19
6C22:  BTFSC  FF2.7
6C24:  BSF    19.7
6C26:  BCF    FF2.7
6C28:  MOVLW  0D
6C2A:  MOVLB  8
6C2C:  MOVWF  x1A
6C2E:  MOVLB  0
6C30:  CALL   0422
6C34:  BTFSC  19.7
6C36:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
6C38:  GOTO   7134 (RETURN)
.................... //=============================================== 
....................  
....................  
.................... //========================= 
....................  
.................... //========================== 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
45F8:  MOVLB  1
45FA:  MOVF   x0F,F
45FC:  BZ    4638
....................    { 
....................       if(count_kp<500)count_kp++; 
45FE:  MOVF   x12,W
4600:  SUBLW  01
4602:  BNC   4612
4604:  BNZ   460C
4606:  MOVF   x11,W
4608:  SUBLW  F3
460A:  BNC   4612
460C:  INCF   x11,F
460E:  BTFSC  FD8.2
4610:  INCF   x12,F
....................       if(count_kp==500) 
4612:  MOVF   x11,W
4614:  SUBLW  F4
4616:  BNZ   4638
4618:  DECFSZ x12,W
461A:  BRA    4638
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
461C:  MOVLW  00
461E:  MOVWF  FF6
4620:  MOVLW  48
4622:  MOVWF  FF7
4624:  MOVLB  0
4626:  CALL   0474
....................             keyprss_off; 
462A:  BCF    F92.7
462C:  BCF    F89.7
....................             kp_st=0;     
462E:  MOVLB  1
4630:  CLRF   x10
....................             count_kp++; 
4632:  INCF   x11,F
4634:  BTFSC  FD8.2
4636:  INCF   x12,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
4638:  DECFSZ x0B,W
463A:  BRA    4656
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
463C:  MOVLB  6
463E:  MOVF   xA9,F
4640:  BNZ   464A
4642:  MOVLB  0
4644:  CALL   2294
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
4648:  BRA    4654
464A:  MOVLB  0
464C:  CALL   3562
4650:  MOVFF  01,7E5
4654:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
4656:  DECFSZ x0C,W
4658:  BRA    4672
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
465A:  MOVLB  6
465C:  MOVF   xA9,F
465E:  BNZ   4668
4660:  MOVLB  0
4662:  CALL   2294
....................          else temp=kbd_getc_slv(); 
4666:  BRA    4672
4668:  MOVLB  0
466A:  CALL   3562
466E:  MOVFF  01,7E5
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
4672:  MOVLB  6
4674:  MOVF   x8E,F
4676:  BNZ   4696
4678:  MOVF   x8D,F
467A:  BNZ   4696
467C:  MOVF   x8C,F
467E:  BNZ   4696
4680:  MOVF   x8B,W
4682:  SUBLW  04
4684:  BNC   4696
4686:  MOVLW  01
4688:  ADDWF  x8B,F
468A:  BTFSC  FD8.0
468C:  INCF   x8C,F
468E:  BTFSC  FD8.2
4690:  INCF   x8D,F
4692:  BTFSC  FD8.2
4694:  INCF   x8E,F
....................   if(mcr_timeout==5) 
4696:  MOVF   x8B,W
4698:  SUBLW  05
469A:  BNZ   46F0
469C:  MOVF   x8C,F
469E:  BNZ   46F0
46A0:  MOVF   x8D,F
46A2:  BNZ   46F0
46A4:  MOVF   x8E,F
46A6:  BNZ   46F0
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
46A8:  DECFSZ xA1,W
46AA:  BRA    46B2
46AC:  MOVLB  0
46AE:  BRA    3F14
46B0:  MOVLB  6
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
46B2:  MOVLW  02
46B4:  MOVWF  FEA
46B6:  MOVLW  0D
46B8:  MOVWF  FE9
46BA:  CLRF   00
46BC:  MOVLW  03
46BE:  MOVWF  02
46C0:  MOVLW  52
46C2:  MOVWF  01
46C4:  MOVLB  0
46C6:  RCALL  4322
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
46C8:  MOVLW  05
46CA:  MOVWF  FEA
46CC:  MOVLW  5F
46CE:  MOVWF  FE9
46D0:  CLRF   00
46D2:  MOVLW  01
46D4:  MOVWF  02
46D6:  MOVLW  2C
46D8:  MOVWF  01
46DA:  RCALL  4322
....................       //debug_card(); 
....................       count_reading_error=0; 
46DC:  MOVLB  6
46DE:  CLRF   xA2
....................       mcr_timeout++;   
46E0:  MOVLW  01
46E2:  ADDWF  x8B,F
46E4:  BTFSC  FD8.0
46E6:  INCF   x8C,F
46E8:  BTFSC  FD8.2
46EA:  INCF   x8D,F
46EC:  BTFSC  FD8.2
46EE:  INCF   x8E,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
46F0:  MOVLB  7
46F2:  CLRF   xF2
46F4:  CLRF   xF1
46F6:  CLRF   xF0
46F8:  MOVLW  94
46FA:  MOVWF  xEF
46FC:  MOVLB  0
46FE:  CALL   37E2
4702:  MOVFF  01,124
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
4706:  MOVLW  02
4708:  MOVLB  7
470A:  MOVWF  xEC
470C:  MOVLW  BC
470E:  MOVWF  xEB
4710:  CLRF   xEE
4712:  MOVFF  124,7ED
4716:  MOVLB  0
4718:  CALL   3908
471C:  MOVFF  02,03
4720:  MOVF   xFC,W
4722:  SUBWF  02,W
4724:  BNC   4734
4726:  BNZ   472E
4728:  MOVF   01,W
472A:  SUBWF  xFB,W
472C:  BC    4734
472E:  INCF   xFB,F
4730:  BTFSC  FD8.2
4732:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
4734:  MOVLW  02
4736:  MOVLB  7
4738:  MOVWF  xEC
473A:  MOVLW  BC
473C:  MOVWF  xEB
473E:  CLRF   xEE
4740:  MOVFF  124,7ED
4744:  MOVLB  0
4746:  CALL   3908
474A:  MOVFF  02,03
474E:  MOVF   01,W
4750:  SUBWF  xFB,W
4752:  BNZ   47FA
4754:  MOVF   03,W
4756:  SUBWF  xFC,W
4758:  BNZ   47FA
....................   { 
....................       charac_timeout++; 
475A:  INCF   xFB,F
475C:  BTFSC  FD8.2
475E:  INCF   xFC,F
....................       buf=get_countcard(); 
4760:  CALL   38B0
4764:  MOVFF  02,7E4
4768:  MOVFF  01,7E3
....................       if(buf<countcards) 
476C:  MOVLB  7
476E:  MOVF   xE4,W
4770:  SUBLW  03
4772:  BNC   479A
4774:  BNZ   477C
4776:  MOVF   xE3,W
4778:  SUBLW  A1
477A:  BNC   479A
....................       { 
....................          save_key_new(); 
477C:  MOVLB  0
477E:  BRA    433C
....................          buf=buf+1; 
4780:  MOVLW  01
4782:  MOVLB  7
4784:  ADDWF  xE3,F
4786:  MOVLW  00
4788:  ADDWFC xE4,F
....................          save_coutcard(buf); 
478A:  MOVFF  7E4,7E7
478E:  MOVFF  7E3,7E6
4792:  MOVLB  0
4794:  RCALL  44BE
....................       } 
....................          else 
4796:  BRA    47AA
4798:  MOVLB  7
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
479A:  MOVLW  10
479C:  MOVWF  FF6
479E:  MOVLW  48
47A0:  MOVWF  FF7
47A2:  MOVLB  0
47A4:  CALL   0474
....................             return; 
47A8:  BRA    47FA
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
47AA:  MOVLW  20
47AC:  MOVWF  FF6
47AE:  MOVLW  48
47B0:  MOVWF  FF7
47B2:  CALL   0474
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
47B6:  MOVLW  30
47B8:  MOVWF  FF6
47BA:  MOVLW  48
47BC:  MOVWF  FF7
47BE:  MOVLW  14
47C0:  MOVLB  8
47C2:  MOVWF  x0E
47C4:  MOVLB  0
47C6:  CALL   1864
47CA:  MOVLW  10
47CC:  MOVWF  FE9
47CE:  MOVFF  7E4,7E7
47D2:  MOVFF  7E3,7E6
47D6:  RCALL  4502
47D8:  MOVLW  47
47DA:  MOVWF  FF6
47DC:  MOVLW  48
47DE:  MOVWF  FF7
47E0:  MOVLW  03
47E2:  MOVLB  8
47E4:  MOVWF  x0E
47E6:  MOVLB  0
47E8:  CALL   1864
....................       data_avai=0; 
47EC:  MOVLB  6
47EE:  CLRF   xA0
....................       enable_getpin=0; 
47F0:  MOVLB  1
47F2:  CLRF   x0C
....................       //dis_getpin; 
....................       output_low(LED); 
47F4:  BCF    F92.6
47F6:  BCF    F89.6
47F8:  MOVLB  0
....................   } 
....................   //================================= 
....................   //================================= 
.................... } 
.................... //========================= 
47FA:  BCF    FF2.2
47FC:  GOTO   006C
.................... void main() 
.................... {  
*
6C3C:  CLRF   FF8
6C3E:  BCF    FD0.7
6C40:  BSF    07.7
6C42:  CLRF   FEA
6C44:  CLRF   FE9
6C46:  BCF    F94.0
6C48:  BSF    F8B.0
6C4A:  CLRF   23
6C4C:  CLRF   22
6C4E:  CLRF   21
6C50:  MOVLW  96
6C52:  MOVWF  20
6C54:  CLRF   27
6C56:  MOVLW  01
6C58:  MOVWF  26
6C5A:  MOVLW  C3
6C5C:  MOVWF  25
6C5E:  MOVLW  0F
6C60:  MOVWF  24
6C62:  CLRF   xFA
6C64:  CLRF   xF9
6C66:  SETF   xFC
6C68:  SETF   xFB
6C6A:  MOVLW  0E
6C6C:  MOVWF  xFE
6C6E:  MOVLW  01
6C70:  MOVWF  xFF
6C72:  MOVLB  1
6C74:  MOVWF  x00
6C76:  CLRF   x01
6C78:  CLRF   x02
6C7A:  CLRF   x03
6C7C:  CLRF   x04
6C7E:  CLRF   x05
6C80:  CLRF   x07
6C82:  MOVLW  0A
6C84:  MOVWF  x06
6C86:  MOVLW  03
6C88:  MOVWF  x09
6C8A:  MOVLW  E8
6C8C:  MOVWF  x08
6C8E:  CLRF   x0A
6C90:  CLRF   x0B
6C92:  CLRF   x0C
6C94:  MOVLW  64
6C96:  MOVWF  x0D
6C98:  CLRF   x0E
6C9A:  CLRF   x0F
6C9C:  CLRF   x10
6C9E:  CLRF   x12
6CA0:  CLRF   x11
6CA2:  CLRF   x13
6CA4:  CLRF   x24
6CA6:  CLRF   x29
6CA8:  CLRF   x90
6CAA:  CLRF   x91
6CAC:  CLRF   x92
6CAE:  CLRF   x93
6CB0:  CLRF   x95
6CB2:  CLRF   x94
6CB4:  MOVLB  6
6CB6:  CLRF   x8E
6CB8:  CLRF   x8D
6CBA:  CLRF   x8C
6CBC:  CLRF   x8B
6CBE:  CLRF   x8F
6CC0:  CLRF   x91
6CC2:  CLRF   x90
6CC4:  CLRF   x93
6CC6:  CLRF   x92
6CC8:  CLRF   x95
6CCA:  CLRF   x94
6CCC:  CLRF   x97
6CCE:  CLRF   x96
6CD0:  MOVLW  FD
6CD2:  MOVWF  x99
6CD4:  MOVLW  E8
6CD6:  MOVWF  x98
6CD8:  CLRF   x9B
6CDA:  CLRF   x9A
6CDC:  CLRF   x9C
6CDE:  CLRF   x9D
6CE0:  CLRF   x9E
6CE2:  CLRF   x9F
6CE4:  CLRF   xA0
6CE6:  CLRF   xA1
6CE8:  CLRF   xA2
6CEA:  CLRF   xA3
6CEC:  CLRF   xA4
6CEE:  CLRF   xA6
6CF0:  MOVLW  01
6CF2:  MOVWF  xA5
6CF4:  CLRF   xA8
6CF6:  CLRF   xA7
6CF8:  CLRF   xA9
6CFA:  CLRF   xAD
6CFC:  CLRF   xAC
6CFE:  CLRF   xAB
6D00:  CLRF   xAA
6D02:  MOVLW  FF
6D04:  MOVLB  F
6D06:  MOVWF  x48
6D08:  BCF    FC2.6
6D0A:  BCF    FC2.7
6D0C:  MOVF   x49,W
6D0E:  ANDLW  E0
6D10:  IORLW  1F
6D12:  MOVWF  x49
6D14:  CLRF   FD2
6D16:  CLRF   FD1
6D18:  CLRF   1A
6D1A:  CLRF   1B
6D1C:  MOVLB  1
6D1E:  CLRF   x25
6D20:  BCF    x26.0
6D22:  CLRF   x27
6D24:  CLRF   x28
6D26:  CLRF   x2A
6D28:  BCF    x26.1
6D2A:  CLRF   x2B
6D2C:  MOVLB  6
6D2E:  CLRF   xBE
6D30:  CLRF   xBF
6D32:  CLRF   xC0
6D34:  CLRF   xC1
6D36:  CLRF   xC2
6D38:  CLRF   xC3
6D3A:  CLRF   xC4
6D3C:  CLRF   xC5
6D3E:  CLRF   xC6
6D40:  CLRF   xC7
6D42:  CLRF   xCA
6D44:  CLRF   xCC
6D46:  CLRF   xCB
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................     RPINR1=5; 
6D48:  MOVLW  05
6D4A:  MOVLB  E
6D4C:  MOVWF  xE7
....................    charac_timeout=0xffffffff; 
6D4E:  MOVLB  0
6D50:  SETF   xFC
6D52:  SETF   xFB
....................    key_timeout=0xffff; 
6D54:  MOVLB  1
6D56:  SETF   x09
6D58:  SETF   x08
....................    setup_oscillator(OSC_32MHZ); 
6D5A:  MOVLW  70
6D5C:  MOVWF  FD3
6D5E:  MOVLW  40
6D60:  MOVWF  F9B
6D62:  MOVF   FD3,W
....................    keyprss_off; 
6D64:  BCF    F92.7
6D66:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
6D68:  BCF    FF2.6
6D6A:  BCF    FF2.7
6D6C:  BTFSC  FF2.7
6D6E:  BRA    6D6A
....................    init_ext_eeprom(); 
6D70:  MOVLB  0
6D72:  GOTO   48D0
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       init_password(); 
....................       for(i=0;i<10;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_pass_addr+i)); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
6D76:  MOVLW  04
6D78:  MOVLB  7
6D7A:  MOVWF  x84
6D7C:  CLRF   19
6D7E:  BTFSC  FF2.7
6D80:  BSF    19.7
6D82:  BCF    FF2.7
6D84:  MOVLW  FA
6D86:  MOVWF  xEC
6D88:  MOVLB  0
6D8A:  CALL   1AD4
6D8E:  BTFSC  19.7
6D90:  BSF    FF2.7
6D92:  MOVLB  7
6D94:  DECFSZ x84,F
6D96:  BRA    6D7C
....................    init_password(); 
6D98:  MOVLB  0
6D9A:  CALL   4990
....................    EEPROM_read(strobe_pass_addr,20,password); 
6D9E:  MOVLB  7
6DA0:  CLRF   xBA
6DA2:  MOVLW  14
6DA4:  MOVWF  xBB
6DA6:  CLRF   xBD
6DA8:  MOVLW  55
6DAA:  MOVWF  xBC
6DAC:  MOVLB  0
6DAE:  CALL   48DA
6DB2:  CLRF   19
6DB4:  BTFSC  FF2.7
6DB6:  BSF    19.7
6DB8:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
6DBA:  MOVLB  7
6DBC:  CLRF   xF2
6DBE:  CLRF   xF1
6DC0:  CLRF   xF0
6DC2:  MOVLW  7F
6DC4:  MOVWF  xEF
6DC6:  MOVLB  0
6DC8:  CALL   37E2
6DCC:  BTFSC  19.7
6DCE:  BSF    FF2.7
6DD0:  MOVFF  01,10F
....................    //===================================== 
....................    rtc_init(); 
6DD4:  GOTO   4ACC
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
6DD8:  MOVLW  19
6DDA:  MOVLB  7
6DDC:  MOVWF  x84
6DDE:  MOVLB  0
6DE0:  CALL   4BD6
6DE4:  MOVFF  03,23
6DE8:  MOVFF  02,22
6DEC:  MOVFF  01,21
6DF0:  MOVFF  00,20
....................     
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
6DF4:  MOVLW  1E
6DF6:  MOVLB  7
6DF8:  MOVWF  x84
6DFA:  MOVLB  0
6DFC:  CALL   4BD6
6E00:  MOVFF  03,27
6E04:  MOVFF  02,26
6E08:  MOVFF  01,25
6E0C:  MOVFF  00,24
....................    fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card_key); 
6E10:  MOVLW  4C
6E12:  MOVWF  FF6
6E14:  MOVLW  48
6E16:  MOVWF  FF7
6E18:  CLRF   19
6E1A:  BTFSC  FF2.7
6E1C:  BSF    19.7
6E1E:  BCF    FF2.7
6E20:  MOVLW  0E
6E22:  MOVLB  8
6E24:  MOVWF  x0E
6E26:  MOVLB  0
6E28:  CALL   1864
6E2C:  BTFSC  19.7
6E2E:  BSF    FF2.7
6E30:  MOVLW  41
6E32:  MOVWF  FE9
6E34:  CLRF   19
6E36:  BTFSC  FF2.7
6E38:  BSF    19.7
6E3A:  BCF    FF2.7
6E3C:  MOVFF  27,811
6E40:  MOVFF  26,810
6E44:  MOVFF  25,80F
6E48:  MOVFF  24,80E
6E4C:  CALL   2614
6E50:  BTFSC  19.7
6E52:  BSF    FF2.7
6E54:  CLRF   19
6E56:  BTFSC  FF2.7
6E58:  BSF    19.7
6E5A:  BCF    FF2.7
6E5C:  MOVLW  0A
6E5E:  MOVLB  8
6E60:  MOVWF  x1A
6E62:  MOVLB  0
6E64:  CALL   0422
6E68:  BTFSC  19.7
6E6A:  BSF    FF2.7
6E6C:  CLRF   19
6E6E:  BTFSC  FF2.7
6E70:  BSF    19.7
6E72:  BCF    FF2.7
6E74:  MOVLW  0D
6E76:  MOVLB  8
6E78:  MOVWF  x1A
6E7A:  MOVLB  0
6E7C:  CALL   0422
6E80:  BTFSC  19.7
6E82:  BSF    FF2.7
6E84:  CLRF   19
6E86:  BTFSC  FF2.7
6E88:  BSF    19.7
6E8A:  BCF    FF2.7
....................    countcard=get_countcard(); 
6E8C:  CALL   38B0
6E90:  BTFSC  19.7
6E92:  BSF    FF2.7
6E94:  MOVFF  02,FA
6E98:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
6E9C:  SETF   xFC
6E9E:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
6EA0:  MOVLW  C7
6EA2:  MOVWF  FD5
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
6EA4:  MOVLW  37
6EA6:  MOVWF  FCD
6EA8:  CLRF   F9A
6EAA:  CLRF   19
6EAC:  BTFSC  FF2.7
6EAE:  BSF    19.7
6EB0:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
6EB2:  MOVLB  7
6EB4:  CLRF   xF2
6EB6:  CLRF   xF1
6EB8:  CLRF   xF0
6EBA:  MOVLW  94
6EBC:  MOVWF  xEF
6EBE:  MOVLB  0
6EC0:  CALL   37E2
6EC4:  BTFSC  19.7
6EC6:  BSF    FF2.7
6EC8:  MOVFF  01,124
....................    if(delaycharaction==0)delaycharaction=1; 
6ECC:  MOVLB  1
6ECE:  MOVF   x24,F
6ED0:  BNZ   6ED6
6ED2:  MOVLW  01
6ED4:  MOVWF  x24
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
6ED6:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
6ED8:  BSF    FF0.3
6EDA:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
6EDC:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
6EDE:  MOVLW  C0
6EE0:  IORWF  FF2,F
....................   
....................    mcr_timeout=10000; 
6EE2:  MOVLB  6
6EE4:  CLRF   x8E
6EE6:  CLRF   x8D
6EE8:  MOVLW  27
6EEA:  MOVWF  x8C
6EEC:  MOVLW  10
6EEE:  MOVWF  x8B
6EF0:  CLRF   19
6EF2:  BTFSC  FF2.7
6EF4:  BSF    19.7
6EF6:  BCF    FF2.7
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6EF8:  MOVLB  7
6EFA:  CLRF   xF2
6EFC:  CLRF   xF1
6EFE:  CLRF   xF0
6F00:  MOVLW  91
6F02:  MOVWF  xEF
6F04:  MOVLB  0
6F06:  CALL   37E2
6F0A:  BTFSC  19.7
6F0C:  BSF    FF2.7
6F0E:  MOVFF  01,6A9
6F12:  CLRF   19
6F14:  BTFSC  FF2.7
6F16:  BSF    19.7
6F18:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
6F1A:  MOVLB  7
6F1C:  CLRF   xF2
6F1E:  CLRF   xF1
6F20:  CLRF   xF0
6F22:  MOVLW  92
6F24:  MOVWF  xEF
6F26:  MOVLB  0
6F28:  CALL   37E2
6F2C:  BTFSC  19.7
6F2E:  BSF    FF2.7
6F30:  MOVFF  01,69D
....................     key_timeout=1000; 
6F34:  MOVLW  03
6F36:  MOVLB  1
6F38:  MOVWF  x09
6F3A:  MOVLW  E8
6F3C:  MOVWF  x08
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
6F3E:  MOVLB  0
6F40:  SETF   xFC
6F42:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    booting_done=1; 
6F44:  MOVLW  01
6F46:  MOVLB  1
6F48:  MOVWF  x93
....................    booting=1; 
6F4A:  MOVWF  x05
....................    charac_timeout=0xffffffff; 
6F4C:  MOVLB  0
6F4E:  SETF   xFC
6F50:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
6F52:  MOVLW  66
6F54:  MOVLB  7
6F56:  MOVWF  xBA
6F58:  MOVLW  10
6F5A:  MOVWF  xBB
6F5C:  MOVLW  06
6F5E:  MOVWF  xBD
6F60:  MOVLW  AE
6F62:  MOVWF  xBC
6F64:  MOVLB  0
6F66:  CALL   48DA
....................    EEPROM_read(strobe_pass_addr,20,password); 
6F6A:  MOVLB  7
6F6C:  CLRF   xBA
6F6E:  MOVLW  14
6F70:  MOVWF  xBB
6F72:  CLRF   xBD
6F74:  MOVLW  55
6F76:  MOVWF  xBC
6F78:  MOVLB  0
6F7A:  CALL   48DA
....................    set_tris_a(0xff);  
6F7E:  MOVLW  FF
6F80:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
6F82:  MOVLW  E0
6F84:  MOVLB  F
6F86:  MOVWF  x48
6F88:  BCF    FC2.6
6F8A:  BCF    FC2.7
6F8C:  MOVF   x49,W
6F8E:  ANDLW  E0
6F90:  IORLW  1F
6F92:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
6F94:  MOVF   FC1,W
6F96:  ANDLW  C0
6F98:  IORLW  03
6F9A:  MOVWF  FC1
6F9C:  BCF    FC1.7
6F9E:  BSF    FC2.0
6FA0:  BSF    FC1.6
6FA2:  BSF    FC2.1
6FA4:  BTFSC  FC2.1
6FA6:  BRA    6FA4
6FA8:  BCF    FC1.6
6FAA:  CLRF   19
6FAC:  BTFSC  FF2.7
6FAE:  BSF    19.7
6FB0:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
6FB2:  MOVLB  7
6FB4:  CLRF   xF2
6FB6:  CLRF   xF1
6FB8:  CLRF   xF0
6FBA:  MOVLW  7F
6FBC:  MOVWF  xEF
6FBE:  MOVLB  0
6FC0:  CALL   37E2
6FC4:  BTFSC  19.7
6FC6:  BSF    FF2.7
6FC8:  MOVFF  01,10F
6FCC:  CLRF   19
6FCE:  BTFSC  FF2.7
6FD0:  BSF    19.7
6FD2:  BCF    FF2.7
....................    type_KB=read_ext_eeprom(kindofKB); 
6FD4:  MOVLB  7
6FD6:  CLRF   xF2
6FD8:  CLRF   xF1
6FDA:  CLRF   xF0
6FDC:  MOVLW  7E
6FDE:  MOVWF  xEF
6FE0:  MOVLB  0
6FE2:  CALL   37E2
6FE6:  BTFSC  19.7
6FE8:  BSF    FF2.7
6FEA:  MOVFF  01,113
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
6FEE:  MOVLB  1
6FF0:  MOVF   x13,F
6FF2:  BZ    7012
6FF4:  MOVLW  60
6FF6:  MOVWF  FF6
6FF8:  MOVLW  48
6FFA:  MOVWF  FF7
6FFC:  CLRF   19
6FFE:  BTFSC  FF2.7
7000:  BSF    19.7
7002:  BCF    FF2.7
7004:  MOVLB  0
7006:  CALL   0474
700A:  BTFSC  19.7
700C:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
700E:  BRA    702C
7010:  MOVLB  1
7012:  MOVLW  74
7014:  MOVWF  FF6
7016:  MOVLW  48
7018:  MOVWF  FF7
701A:  CLRF   19
701C:  BTFSC  FF2.7
701E:  BSF    19.7
7020:  BCF    FF2.7
7022:  MOVLB  0
7024:  CALL   0474
7028:  BTFSC  19.7
702A:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
702C:  MOVLB  6
702E:  MOVF   xA9,F
7030:  BNZ   7050
7032:  MOVLW  88
7034:  MOVWF  FF6
7036:  MOVLW  48
7038:  MOVWF  FF7
703A:  CLRF   19
703C:  BTFSC  FF2.7
703E:  BSF    19.7
7040:  BCF    FF2.7
7042:  MOVLB  0
7044:  CALL   0474
7048:  BTFSC  19.7
704A:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
704C:  BRA    706A
704E:  MOVLB  6
7050:  MOVLW  A2
7052:  MOVWF  FF6
7054:  MOVLW  48
7056:  MOVWF  FF7
7058:  CLRF   19
705A:  BTFSC  FF2.7
705C:  BSF    19.7
705E:  BCF    FF2.7
7060:  MOVLB  0
7062:  CALL   0474
7066:  BTFSC  19.7
7068:  BSF    FF2.7
....................     
....................  
....................    memset(key_data,0,sizeof(key_data));  
706A:  MOVLW  01
706C:  MOVWF  FEA
706E:  MOVLW  14
7070:  MOVWF  FE9
7072:  CLRF   00
7074:  CLRF   02
7076:  MOVLW  10
7078:  MOVWF  01
707A:  CALL   4322
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     //write_ext_eeprom(131071,100);   
....................     //fprintf(COM2," eeprom test=%d\n\r",read_ext_eeprom(131071)); 
....................      //while(1); 
....................    //save_coutcard(928);  
.................... #if defined(nocheckpass) 
....................    for(i=0;i<20;i++) 
707E:  MOVLB  6
7080:  CLRF   xC8
7082:  MOVF   xC8,W
7084:  SUBLW  13
7086:  BNC   709C
....................    { 
....................       password[i] = 0; 
7088:  CLRF   03
708A:  MOVF   xC8,W
708C:  ADDLW  55
708E:  MOVWF  FE9
7090:  MOVLW  00
7092:  ADDWFC 03,W
7094:  MOVWF  FEA
7096:  CLRF   FEF
....................    } 
7098:  INCF   xC8,F
709A:  BRA    7082
.................... #endif    
....................    while(1) 
....................    { 
....................       if(mode==LOGOFF) 
709C:  MOVF   xA3,F
709E:  BNZ   712A
....................       { 
....................          fprintf(COM2,"password:"); 
70A0:  MOVLW  BA
70A2:  MOVWF  FF6
70A4:  MOVLW  48
70A6:  MOVWF  FF7
70A8:  CLRF   19
70AA:  BTFSC  FF2.7
70AC:  BSF    19.7
70AE:  BCF    FF2.7
70B0:  MOVLB  0
70B2:  CALL   0474
70B6:  BTFSC  19.7
70B8:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
70BA:  MOVLW  02
70BC:  MOVLB  7
70BE:  MOVWF  xBA
70C0:  MOVLW  14
70C2:  MOVWF  xBB
70C4:  MOVLW  01
70C6:  MOVWF  xBD
70C8:  MOVLW  2C
70CA:  MOVWF  xBC
70CC:  MOVLB  0
70CE:  CALL   4D80
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          if(!stringcomp(buffer_uart,password)) 
70D2:  MOVLW  01
70D4:  MOVLB  7
70D6:  MOVWF  xBB
70D8:  MOVLW  2C
70DA:  MOVWF  xBA
70DC:  CLRF   xBD
70DE:  MOVLW  55
70E0:  MOVWF  xBC
70E2:  MOVLB  0
70E4:  CALL   4EB8
70E8:  MOVF   01,F
70EA:  BNZ   710E
....................          { 
....................             mode=LOGON; 
70EC:  MOVLW  01
70EE:  MOVLB  6
70F0:  MOVWF  xA3
....................             fprintf(COM2," OK\n\r"); 
70F2:  MOVLW  C4
70F4:  MOVWF  FF6
70F6:  MOVLW  48
70F8:  MOVWF  FF7
70FA:  CLRF   19
70FC:  BTFSC  FF2.7
70FE:  BSF    19.7
7100:  BCF    FF2.7
7102:  MOVLB  0
7104:  CALL   0474
7108:  BTFSC  19.7
710A:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
710C:  BRA    7126
710E:  MOVLW  CA
7110:  MOVWF  FF6
7112:  MOVLW  48
7114:  MOVWF  FF7
7116:  CLRF   19
7118:  BTFSC  FF2.7
711A:  BSF    19.7
711C:  BCF    FF2.7
711E:  CALL   0474
7122:  BTFSC  19.7
7124:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/   
7126:  BRA    7134
7128:  MOVLB  6
712A:  DECFSZ xA3,W
712C:  BRA    7136
712E:  MOVLB  0
7130:  GOTO   5676
7134:  MOVLB  6
....................    } 
7136:  BRA    709C
.................... } 
7138:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

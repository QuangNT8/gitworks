CCS PCH C Compiler, Version 4.140, 33034               24-Apr-16 21:26

               Filename:   G:\projects\car\clock\main.lst

               ROM used:   5188 bytes (8%)
                           Largest free fragment is 60336
               RAM used:   58 (2%) at main() level
                           87 (2%) worst case
               Stack:     5 worst case (3 in main + 2 for interrupts)

*
0000:  GOTO   1102
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   03AC
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   00BA
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
07B2:  CLRF   FEA
07B4:  MOVLW  3F
07B6:  MOVWF  FE9
07B8:  MOVF   FEF,W
07BA:  BZ    07D6
07BC:  MOVLW  0A
07BE:  MOVWF  01
07C0:  CLRF   00
07C2:  DECFSZ 00,F
07C4:  BRA    07C2
07C6:  DECFSZ 01,F
07C8:  BRA    07C0
07CA:  MOVLW  5F
07CC:  MOVWF  00
07CE:  DECFSZ 00,F
07D0:  BRA    07CE
07D2:  DECFSZ FEF,F
07D4:  BRA    07BC
07D6:  RETURN 0
*
0A26:  MOVLW  02
0A28:  SUBWF  40,F
0A2A:  BNC   0A42
0A2C:  CLRF   FEA
0A2E:  MOVLW  40
0A30:  MOVWF  FE9
0A32:  MOVF   FEF,W
0A34:  BZ    0A42
0A36:  BRA    0A3E
0A38:  BRA    0A3A
0A3A:  BRA    0A3C
0A3C:  NOP   
0A3E:  DECFSZ FEF,F
0A40:  BRA    0A38
0A42:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
04F0:  MOVLW  08
04F2:  MOVWF  01
04F4:  MOVLW  0A
04F6:  MOVWF  00
04F8:  DECFSZ 00,F
04FA:  BRA    04F8
04FC:  BCF    F8B.3
04FE:  BCF    F94.3
0500:  MOVLW  0B
0502:  MOVWF  00
0504:  DECFSZ 00,F
0506:  BRA    0504
0508:  RLCF   42,F
050A:  BCF    F8B.4
050C:  BTFSC  FD8.0
050E:  BSF    F94.4
0510:  BTFSS  FD8.0
0512:  BCF    F94.4
0514:  BSF    F94.3
0516:  BTFSS  F82.3
0518:  BRA    0516
051A:  DECFSZ 01,F
051C:  BRA    04F4
051E:  MOVLW  0A
0520:  MOVWF  00
0522:  DECFSZ 00,F
0524:  BRA    0522
0526:  BCF    F8B.3
0528:  BCF    F94.3
052A:  NOP   
052C:  BSF    F94.4
052E:  MOVLW  0B
0530:  MOVWF  00
0532:  DECFSZ 00,F
0534:  BRA    0532
0536:  MOVLW  0B
0538:  MOVWF  00
053A:  DECFSZ 00,F
053C:  BRA    053A
053E:  BSF    F94.3
0540:  BTFSS  F82.3
0542:  BRA    0540
0544:  CLRF   01
0546:  MOVLW  0B
0548:  MOVWF  00
054A:  DECFSZ 00,F
054C:  BRA    054A
054E:  BTFSC  F82.4
0550:  BSF    01.0
0552:  BCF    F8B.3
0554:  BCF    F94.3
0556:  BCF    F8B.4
0558:  BCF    F94.4
055A:  RETURN 0
055C:  MOVLW  08
055E:  MOVWF  3F
0560:  MOVFF  00,40
0564:  BSF    F94.4
0566:  MOVLW  0B
0568:  MOVWF  00
056A:  DECFSZ 00,F
056C:  BRA    056A
056E:  BSF    F94.3
0570:  BTFSS  F82.3
0572:  BRA    0570
0574:  BTFSC  F82.4
0576:  BSF    FD8.0
0578:  BTFSS  F82.4
057A:  BCF    FD8.0
057C:  RLCF   01,F
057E:  MOVLW  0A
0580:  MOVWF  00
0582:  DECFSZ 00,F
0584:  BRA    0582
0586:  BCF    F94.3
0588:  BCF    F8B.3
058A:  DECFSZ 3F,F
058C:  BRA    0564
058E:  BSF    F94.4
0590:  MOVLW  0B
0592:  MOVWF  00
0594:  DECFSZ 00,F
0596:  BRA    0594
0598:  BCF    F8B.4
059A:  MOVF   40,W
059C:  BTFSS  FD8.2
059E:  BCF    F94.4
05A0:  NOP   
05A2:  BSF    F94.3
05A4:  BTFSS  F82.3
05A6:  BRA    05A4
05A8:  MOVLW  0A
05AA:  MOVWF  00
05AC:  DECFSZ 00,F
05AE:  BRA    05AC
05B0:  BCF    F8B.3
05B2:  BCF    F94.3
05B4:  MOVLW  0B
05B6:  MOVWF  00
05B8:  DECFSZ 00,F
05BA:  BRA    05B8
05BC:  BCF    F8B.4
05BE:  BCF    F94.4
05C0:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... //#define EEPROM_SIZE   65535 
.................... #define EEPROM_SIZE_key    65535 
.................... #define EEPROM_SIZE        43590 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
....................  
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
04E6:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
04E8:  BSF    F94.4
....................    port_b_pullups(0xff); 
04EA:  BCF    FF1.7
.................... } 
04EC:  GOTO   116E (RETURN)
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
0ECA:  BSF    F94.4
0ECC:  MOVLW  0A
0ECE:  MOVWF  00
0ED0:  DECFSZ 00,F
0ED2:  BRA    0ED0
0ED4:  BSF    F94.3
0ED6:  MOVLW  0B
0ED8:  MOVWF  00
0EDA:  DECFSZ 00,F
0EDC:  BRA    0EDA
0EDE:  BCF    F8B.4
0EE0:  BCF    F94.4
0EE2:  MOVLW  0A
0EE4:  MOVWF  00
0EE6:  DECFSZ 00,F
0EE8:  BRA    0EE6
0EEA:  BCF    F8B.3
0EEC:  BCF    F94.3
....................    i2c_write(0xa0); 
0EEE:  MOVLW  A0
0EF0:  MOVWF  42
0EF2:  CALL   04F0
....................    i2c_write(address>>8); 
0EF6:  MOVFF  3A,3D
0EFA:  CLRF   3E
0EFC:  MOVFF  3A,42
0F00:  CALL   04F0
....................    i2c_write(address); 
0F04:  MOVFF  39,42
0F08:  CALL   04F0
....................    i2c_write(data); 
0F0C:  MOVFF  3B,42
0F10:  CALL   04F0
....................    i2c_stop(); 
0F14:  BCF    F94.4
0F16:  NOP   
0F18:  BSF    F94.3
0F1A:  BTFSS  F82.3
0F1C:  BRA    0F1A
0F1E:  MOVLW  0A
0F20:  MOVWF  00
0F22:  DECFSZ 00,F
0F24:  BRA    0F22
0F26:  BRA    0F28
0F28:  NOP   
0F2A:  BSF    F94.4
0F2C:  MOVLW  0A
0F2E:  MOVWF  00
0F30:  DECFSZ 00,F
0F32:  BRA    0F30
....................    i2c_start(); 
0F34:  BSF    F94.4
0F36:  MOVLW  0A
0F38:  MOVWF  00
0F3A:  DECFSZ 00,F
0F3C:  BRA    0F3A
0F3E:  BSF    F94.3
0F40:  MOVLW  0B
0F42:  MOVWF  00
0F44:  DECFSZ 00,F
0F46:  BRA    0F44
0F48:  BCF    F8B.4
0F4A:  BCF    F94.4
0F4C:  MOVLW  0A
0F4E:  MOVWF  00
0F50:  DECFSZ 00,F
0F52:  BRA    0F50
0F54:  BCF    F8B.3
0F56:  BCF    F94.3
....................    status=i2c_write(0xa0); 
0F58:  MOVLW  A0
0F5A:  MOVWF  42
0F5C:  CALL   04F0
0F60:  MOVF   01,W
0F62:  BCF    3C.0
0F64:  BTFSC  01.0
0F66:  BSF    3C.0
....................    while(status==1) 
....................    { 
0F68:  BTFSS  3C.0
0F6A:  BRA    0FA6
....................       i2c_start(); 
0F6C:  BSF    F94.4
0F6E:  MOVLW  0A
0F70:  MOVWF  00
0F72:  DECFSZ 00,F
0F74:  BRA    0F72
0F76:  BSF    F94.3
0F78:  MOVLW  0B
0F7A:  MOVWF  00
0F7C:  DECFSZ 00,F
0F7E:  BRA    0F7C
0F80:  BTFSS  F82.3
0F82:  BRA    0F80
0F84:  BCF    F8B.4
0F86:  BCF    F94.4
0F88:  MOVLW  0A
0F8A:  MOVWF  00
0F8C:  DECFSZ 00,F
0F8E:  BRA    0F8C
0F90:  BCF    F8B.3
0F92:  BCF    F94.3
....................       status=i2c_write(0xa0); 
0F94:  MOVLW  A0
0F96:  MOVWF  42
0F98:  CALL   04F0
0F9C:  MOVF   01,W
0F9E:  BCF    3C.0
0FA0:  BTFSC  01.0
0FA2:  BSF    3C.0
....................    } 
0FA4:  BRA    0F68
....................    i2c_stop(); 
0FA6:  BCF    F94.4
0FA8:  NOP   
0FAA:  BSF    F94.3
0FAC:  BTFSS  F82.3
0FAE:  BRA    0FAC
0FB0:  MOVLW  0A
0FB2:  MOVWF  00
0FB4:  DECFSZ 00,F
0FB6:  BRA    0FB4
0FB8:  BRA    0FBA
0FBA:  NOP   
0FBC:  BSF    F94.4
0FBE:  MOVLW  0A
0FC0:  MOVWF  00
0FC2:  DECFSZ 00,F
0FC4:  BRA    0FC2
.................... } 
0FC6:  GOTO   1294 (RETURN)
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
06EA:  BSF    F94.4
06EC:  MOVLW  0A
06EE:  MOVWF  00
06F0:  DECFSZ 00,F
06F2:  BRA    06F0
06F4:  BSF    F94.3
06F6:  MOVLW  0B
06F8:  MOVWF  00
06FA:  DECFSZ 00,F
06FC:  BRA    06FA
06FE:  BCF    F8B.4
0700:  BCF    F94.4
0702:  MOVLW  0A
0704:  MOVWF  00
0706:  DECFSZ 00,F
0708:  BRA    0706
070A:  BCF    F8B.3
070C:  BCF    F94.3
....................    i2c_write(0xa0); 
070E:  MOVLW  A0
0710:  MOVWF  42
0712:  RCALL  04F0
....................    i2c_write(address>>8); 
0714:  MOVFF  3A,3C
0718:  CLRF   3D
071A:  MOVFF  3A,42
071E:  RCALL  04F0
....................    i2c_write(address); 
0720:  MOVFF  39,42
0724:  RCALL  04F0
....................    i2c_start(); 
0726:  BSF    F94.4
0728:  MOVLW  0A
072A:  MOVWF  00
072C:  DECFSZ 00,F
072E:  BRA    072C
0730:  BSF    F94.3
0732:  MOVLW  0B
0734:  MOVWF  00
0736:  DECFSZ 00,F
0738:  BRA    0736
073A:  BTFSS  F82.3
073C:  BRA    073A
073E:  BCF    F8B.4
0740:  BCF    F94.4
0742:  MOVLW  0A
0744:  MOVWF  00
0746:  DECFSZ 00,F
0748:  BRA    0746
074A:  BCF    F8B.3
074C:  BCF    F94.3
....................    i2c_write(0xa1); 
074E:  MOVLW  A1
0750:  MOVWF  42
0752:  RCALL  04F0
....................    data=i2c_read(0); 
0754:  CLRF   00
0756:  RCALL  055C
0758:  MOVFF  01,3B
....................    i2c_stop(); 
075C:  BCF    F94.4
075E:  NOP   
0760:  BSF    F94.3
0762:  BTFSS  F82.3
0764:  BRA    0762
0766:  MOVLW  0A
0768:  MOVWF  00
076A:  DECFSZ 00,F
076C:  BRA    076A
076E:  BRA    0770
0770:  NOP   
0772:  BSF    F94.4
0774:  MOVLW  0A
0776:  MOVWF  00
0778:  DECFSZ 00,F
077A:  BRA    0778
....................    return(data); 
077C:  MOVFF  3B,01
.................... } 
0780:  GOTO   1184 (RETURN)
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
....................    for(i=0;i<len;i++) 
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
....................    } 
....................     
.................... } 
....................  
....................  
.................... //#include <eeprom.c> 
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
05C2:  BSF    F94.4
05C4:  MOVLW  0A
05C6:  MOVWF  00
05C8:  DECFSZ 00,F
05CA:  BRA    05C8
05CC:  BSF    F94.3
05CE:  MOVLW  0B
05D0:  MOVWF  00
05D2:  DECFSZ 00,F
05D4:  BRA    05D2
05D6:  BCF    F8B.4
05D8:  BCF    F94.4
05DA:  MOVLW  0A
05DC:  MOVWF  00
05DE:  DECFSZ 00,F
05E0:  BRA    05DE
05E2:  BCF    F8B.3
05E4:  BCF    F94.3
....................    i2c_write(0xD0); 
05E6:  MOVLW  D0
05E8:  MOVWF  42
05EA:  RCALL  04F0
....................    i2c_write(address); 
05EC:  MOVFF  3C,42
05F0:  RCALL  04F0
....................    i2c_start(); 
05F2:  BSF    F94.4
05F4:  MOVLW  0A
05F6:  MOVWF  00
05F8:  DECFSZ 00,F
05FA:  BRA    05F8
05FC:  BSF    F94.3
05FE:  MOVLW  0B
0600:  MOVWF  00
0602:  DECFSZ 00,F
0604:  BRA    0602
0606:  BTFSS  F82.3
0608:  BRA    0606
060A:  BCF    F8B.4
060C:  BCF    F94.4
060E:  MOVLW  0A
0610:  MOVWF  00
0612:  DECFSZ 00,F
0614:  BRA    0612
0616:  BCF    F8B.3
0618:  BCF    F94.3
....................    i2c_write(0xD1); 
061A:  MOVLW  D1
061C:  MOVWF  42
061E:  RCALL  04F0
....................    result = i2c_read(0); 
0620:  CLRF   00
0622:  RCALL  055C
0624:  MOVFF  01,3D
....................    i2c_stop(); 
0628:  BCF    F94.4
062A:  NOP   
062C:  BSF    F94.3
062E:  BTFSS  F82.3
0630:  BRA    062E
0632:  MOVLW  0A
0634:  MOVWF  00
0636:  DECFSZ 00,F
0638:  BRA    0636
063A:  BRA    063C
063C:  NOP   
063E:  BSF    F94.4
0640:  MOVLW  0A
0642:  MOVWF  00
0644:  DECFSZ 00,F
0646:  BRA    0644
....................     
....................    return(result); 
0648:  MOVFF  3D,01
.................... } 
064C:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
0FCA:  BSF    F94.4
0FCC:  MOVLW  0A
0FCE:  MOVWF  00
0FD0:  DECFSZ 00,F
0FD2:  BRA    0FD0
0FD4:  BSF    F94.3
0FD6:  MOVLW  0B
0FD8:  MOVWF  00
0FDA:  DECFSZ 00,F
0FDC:  BRA    0FDA
0FDE:  BCF    F8B.4
0FE0:  BCF    F94.4
0FE2:  MOVLW  0A
0FE4:  MOVWF  00
0FE6:  DECFSZ 00,F
0FE8:  BRA    0FE6
0FEA:  BCF    F8B.3
0FEC:  BCF    F94.3
....................    delay_us(10); 
0FEE:  MOVLW  1A
0FF0:  MOVWF  00
0FF2:  DECFSZ 00,F
0FF4:  BRA    0FF2
0FF6:  NOP   
....................    i2c_write(0xD0); 
0FF8:  MOVLW  D0
0FFA:  MOVWF  42
0FFC:  CALL   04F0
....................    delay_us(10); 
1000:  MOVLW  1A
1002:  MOVWF  00
1004:  DECFSZ 00,F
1006:  BRA    1004
1008:  NOP   
....................    i2c_write(address); 
100A:  MOVFF  40,42
100E:  CALL   04F0
....................    delay_us(10); 
1012:  MOVLW  1A
1014:  MOVWF  00
1016:  DECFSZ 00,F
1018:  BRA    1016
101A:  NOP   
....................    i2c_write(data); 
101C:  MOVFF  41,42
1020:  CALL   04F0
....................    i2c_stop(); 
1024:  BCF    F94.4
1026:  NOP   
1028:  BSF    F94.3
102A:  BTFSS  F82.3
102C:  BRA    102A
102E:  MOVLW  0A
1030:  MOVWF  00
1032:  DECFSZ 00,F
1034:  BRA    1032
1036:  BRA    1038
1038:  NOP   
103A:  BSF    F94.4
103C:  MOVLW  0A
103E:  MOVWF  00
1040:  DECFSZ 00,F
1042:  BRA    1040
....................    delay_us(10); 
1044:  MOVLW  1A
1046:  MOVWF  00
1048:  DECFSZ 00,F
104A:  BRA    1048
104C:  NOP   
.................... } 
104E:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
*
064E:  CLRF   3C
0650:  RCALL  05C2
0652:  MOVFF  01,39
....................     
....................    data &= 0x7F; 
0656:  BCF    39.7
....................     
....................    i2c_start(); 
0658:  BSF    F94.4
065A:  MOVLW  0A
065C:  MOVWF  00
065E:  DECFSZ 00,F
0660:  BRA    065E
0662:  BSF    F94.3
0664:  MOVLW  0B
0666:  MOVWF  00
0668:  DECFSZ 00,F
066A:  BRA    0668
066C:  BCF    F8B.4
066E:  BCF    F94.4
0670:  MOVLW  0A
0672:  MOVWF  00
0674:  DECFSZ 00,F
0676:  BRA    0674
0678:  BCF    F8B.3
067A:  BCF    F94.3
....................    i2c_write(0xD0); 
067C:  MOVLW  D0
067E:  MOVWF  42
0680:  RCALL  04F0
....................    i2c_write(DS1307_SEC); 
0682:  CLRF   42
0684:  RCALL  04F0
....................    i2c_write(data); 
0686:  MOVFF  39,42
068A:  RCALL  04F0
....................    i2c_start(); 
068C:  BSF    F94.4
068E:  MOVLW  0A
0690:  MOVWF  00
0692:  DECFSZ 00,F
0694:  BRA    0692
0696:  BSF    F94.3
0698:  MOVLW  0B
069A:  MOVWF  00
069C:  DECFSZ 00,F
069E:  BRA    069C
06A0:  BTFSS  F82.3
06A2:  BRA    06A0
06A4:  BCF    F8B.4
06A6:  BCF    F94.4
06A8:  MOVLW  0A
06AA:  MOVWF  00
06AC:  DECFSZ 00,F
06AE:  BRA    06AC
06B0:  BCF    F8B.3
06B2:  BCF    F94.3
....................    i2c_write(0xD0); 
06B4:  MOVLW  D0
06B6:  MOVWF  42
06B8:  RCALL  04F0
....................    i2c_write(DS1307_CONTROL); 
06BA:  MOVLW  07
06BC:  MOVWF  42
06BE:  RCALL  04F0
....................    i2c_write(0x80); 
06C0:  MOVLW  80
06C2:  MOVWF  42
06C4:  RCALL  04F0
....................    i2c_stop(); 
06C6:  BCF    F94.4
06C8:  NOP   
06CA:  BSF    F94.3
06CC:  BTFSS  F82.3
06CE:  BRA    06CC
06D0:  MOVLW  0A
06D2:  MOVWF  00
06D4:  DECFSZ 00,F
06D6:  BRA    06D4
06D8:  BRA    06DA
06DA:  NOP   
06DC:  BSF    F94.4
06DE:  MOVLW  0A
06E0:  MOVWF  00
06E2:  DECFSZ 00,F
06E4:  BRA    06E2
.................... } 
06E6:  GOTO   1172 (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
*
1050:  MOVFF  3F,42
1054:  MOVLW  0A
1056:  MOVWF  43
1058:  CALL   080A
105C:  MOVFF  01,40
....................    nibl=data-(nibh*10); 
1060:  MOVF   40,W
1062:  MULLW  0A
1064:  MOVF   FF3,W
1066:  SUBWF  3F,W
1068:  MOVWF  41
....................  
....................    return((nibh<<4)|nibl); 
106A:  SWAPF  40,W
106C:  MOVWF  00
106E:  MOVLW  F0
1070:  ANDWF  00,F
1072:  MOVF   00,W
1074:  IORWF  41,W
1076:  MOVWF  01
.................... } 
1078:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
0784:  MOVFF  3D,3E
....................    data=(i>>4)*10; 
0788:  SWAPF  3E,W
078A:  MOVWF  00
078C:  MOVLW  0F
078E:  ANDWF  00,F
0790:  MOVF   00,W
0792:  MULLW  0A
0794:  MOVFF  FF3,3D
....................    data=data+(i<<4>>4); 
0798:  SWAPF  3E,W
079A:  MOVWF  00
079C:  MOVLW  F0
079E:  ANDWF  00,F
07A0:  MOVF   00,W
07A2:  SWAPF  00,F
07A4:  MOVLW  0F
07A6:  ANDWF  00,F
07A8:  MOVF   00,W
07AA:  ADDWF  3D,F
....................  
....................    return data; 
07AC:  MOVFF  3D,01
.................... } 
07B0:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
107A:  CLRF   40
107C:  CLRF   41
107E:  RCALL  0FCA
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
1080:  MOVFF  3E,3F
1084:  RCALL  1050
1086:  MOVFF  01,3F
108A:  MOVLW  01
108C:  MOVWF  40
108E:  MOVFF  01,41
1092:  RCALL  0FCA
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
1094:  MOVFF  3D,3F
1098:  RCALL  1050
109A:  MOVFF  01,3F
109E:  MOVLW  02
10A0:  MOVWF  40
10A2:  MOVFF  01,41
10A6:  RCALL  0FCA
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
10A8:  MOVFF  3C,3F
10AC:  RCALL  1050
10AE:  MOVFF  01,3F
10B2:  MOVLW  03
10B4:  MOVWF  40
10B6:  MOVFF  01,41
10BA:  RCALL  0FCA
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
10BC:  MOVFF  39,3F
10C0:  RCALL  1050
10C2:  MOVFF  01,3F
10C6:  MOVLW  04
10C8:  MOVWF  40
10CA:  MOVFF  01,41
10CE:  RCALL  0FCA
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
10D0:  MOVFF  3A,3F
10D4:  RCALL  1050
10D6:  MOVFF  01,3F
10DA:  MOVLW  05
10DC:  MOVWF  40
10DE:  MOVFF  01,41
10E2:  RCALL  0FCA
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
10E4:  MOVFF  3B,3F
10E8:  RCALL  1050
10EA:  MOVFF  01,3F
10EE:  MOVLW  06
10F0:  MOVWF  40
10F2:  MOVFF  01,41
10F6:  RCALL  0FCA
....................    write_DS1307(DS1307_CONTROL,0);    
10F8:  MOVLW  07
10FA:  MOVWF  40
10FC:  CLRF   41
10FE:  RCALL  0FCA
.................... } 
1100:  RETURN 0
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
*
11D0:  MOVLW  02
11D2:  MOVWF  3C
11D4:  CALL   05C2
11D8:  MOVFF  01,39
11DC:  MOVFF  01,3D
11E0:  CALL   0784
11E4:  MOVFF  01,33
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
11E8:  MOVLW  01
11EA:  MOVWF  3C
11EC:  CALL   05C2
11F0:  MOVFF  01,39
11F4:  MOVFF  01,3D
11F8:  CALL   0784
11FC:  MOVFF  01,34
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
1200:  CLRF   3C
1202:  CALL   05C2
1206:  MOVFF  01,39
120A:  MOVFF  01,3D
120E:  CALL   0784
1212:  MOVFF  01,35
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... #include <LED7SG.c> 
....................  
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  dot       PIN_A2 
.................... #define  KEY       PIN_A1 
.................... //#define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  relay     PIN_A7 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
....................  
.................... //================================================= 
.................... void offled() 
.................... { 
....................       output_low(PIN_B1); 
*
07D8:  BCF    F93.1
07DA:  BCF    F8A.1
....................       output_low(PIN_B3);   
07DC:  BCF    F93.3
07DE:  BCF    F8A.3
....................       output_low(PIN_B2); 
07E0:  BCF    F93.2
07E2:  BCF    F8A.2
....................       output_low(PIN_C5); 
07E4:  BCF    F94.5
07E6:  BCF    F8B.5
....................        
....................       output_low(COL0); 
07E8:  BCF    F92.5
07EA:  BCF    F89.5
....................       output_low(COL1);   
07EC:  BCF    F92.3
07EE:  BCF    F89.3
....................       output_low(dot);// dau cham 
07F0:  BCF    F92.2
07F2:  BCF    F89.2
....................       output_low(ROW0); 
07F4:  BCF    F93.4
07F6:  BCF    F8A.4
....................       output_low(ROW1); 
07F8:  BCF    F93.5
07FA:  BCF    F8A.5
....................       output_low(PIN_C7); 
07FC:  BCF    F94.7
07FE:  BCF    F8B.7
....................       output_low(PIN_C6); 
0800:  BCF    F94.6
0802:  BCF    F8B.6
....................       output_low(PIN_B0);     
0804:  BCF    F93.0
0806:  BCF    F8A.0
.................... } 
0808:  RETURN 0
.................... //================================================= 
.................... void dis_number(int8 num,int8 dott) 
.................... { 
....................    switch(num) 
....................    { 
*
0832:  MOVF   40,W
0834:  ADDLW  F6
0836:  BTFSC  FD8.0
0838:  BRA    09F6
083A:  ADDLW  0A
083C:  GOTO   09F8
....................       case 0: 
....................          output_low(COL0); 
0840:  BCF    F92.5
0842:  BCF    F89.5
....................          output_low(COL1); 
0844:  BCF    F92.3
0846:  BCF    F89.3
....................          if(dott==0) output_high(dot);// dau cham 
0848:  MOVF   41,F
084A:  BNZ   0852
084C:  BCF    F92.2
084E:  BSF    F89.2
....................             else output_low(dot);// dau cham 
0850:  BRA    0856
0852:  BCF    F92.2
0854:  BCF    F89.2
....................          output_low(ROW0); 
0856:  BCF    F93.4
0858:  BCF    F8A.4
....................          output_low(ROW1); 
085A:  BCF    F93.5
085C:  BCF    F8A.5
....................          output_low(PIN_C7); 
085E:  BCF    F94.7
0860:  BCF    F8B.7
....................          output_high(PIN_C6); 
0862:  BCF    F94.6
0864:  BSF    F8B.6
....................          output_low(PIN_B0); 
0866:  BCF    F93.0
0868:  BCF    F8A.0
....................       break; 
086A:  BRA    09F6
....................       case 1: 
....................          output_high(COL0); 
086C:  BCF    F92.5
086E:  BSF    F89.5
....................          output_high(COL1); 
0870:  BCF    F92.3
0872:  BSF    F89.3
....................          if(dott==0) output_high(dot);// dau cham 
0874:  MOVF   41,F
0876:  BNZ   087E
0878:  BCF    F92.2
087A:  BSF    F89.2
....................             else output_low(dot);// dau cham 
087C:  BRA    0882
087E:  BCF    F92.2
0880:  BCF    F89.2
....................          output_low(ROW0); 
0882:  BCF    F93.4
0884:  BCF    F8A.4
....................          output_high(ROW1); 
0886:  BCF    F93.5
0888:  BSF    F8A.5
....................          output_high(PIN_C7); 
088A:  BCF    F94.7
088C:  BSF    F8B.7
....................          output_high(PIN_C6); 
088E:  BCF    F94.6
0890:  BSF    F8B.6
....................          output_low(PIN_B0); 
0892:  BCF    F93.0
0894:  BCF    F8A.0
....................       break; 
0896:  BRA    09F6
....................       case 2: 
....................          output_low(COL0); 
0898:  BCF    F92.5
089A:  BCF    F89.5
....................          output_low(COL1); 
089C:  BCF    F92.3
089E:  BCF    F89.3
....................          if(dott==0) output_high(dot);// dau cham 
08A0:  MOVF   41,F
08A2:  BNZ   08AA
08A4:  BCF    F92.2
08A6:  BSF    F89.2
....................             else output_low(dot);// dau cham 
08A8:  BRA    08AE
08AA:  BCF    F92.2
08AC:  BCF    F89.2
....................          output_low(ROW0); 
08AE:  BCF    F93.4
08B0:  BCF    F8A.4
....................          output_high(ROW1); 
08B2:  BCF    F93.5
08B4:  BSF    F8A.5
....................          output_low(PIN_C7); 
08B6:  BCF    F94.7
08B8:  BCF    F8B.7
....................          output_low(PIN_C6); 
08BA:  BCF    F94.6
08BC:  BCF    F8B.6
....................          output_high(PIN_B0); 
08BE:  BCF    F93.0
08C0:  BSF    F8A.0
....................       break; 
08C2:  BRA    09F6
....................       case 3: 
....................          output_high(COL0); 
08C4:  BCF    F92.5
08C6:  BSF    F89.5
....................          output_low(COL1); 
08C8:  BCF    F92.3
08CA:  BCF    F89.3
....................          if(dott==0) output_high(dot);// dau cham 
08CC:  MOVF   41,F
08CE:  BNZ   08D6
08D0:  BCF    F92.2
08D2:  BSF    F89.2
....................             else output_low(dot);// dau cham 
08D4:  BRA    08DA
08D6:  BCF    F92.2
08D8:  BCF    F89.2
....................          output_low(ROW0); 
08DA:  BCF    F93.4
08DC:  BCF    F8A.4
....................          output_high(ROW1); 
08DE:  BCF    F93.5
08E0:  BSF    F8A.5
....................          output_low(PIN_C7); 
08E2:  BCF    F94.7
08E4:  BCF    F8B.7
....................          output_low(PIN_C6); 
08E6:  BCF    F94.6
08E8:  BCF    F8B.6
....................          output_low(PIN_B0);          
08EA:  BCF    F93.0
08EC:  BCF    F8A.0
....................       break; 
08EE:  BRA    09F6
....................       case 4: 
....................          output_high(COL0); 
08F0:  BCF    F92.5
08F2:  BSF    F89.5
....................          output_high(COL1); 
08F4:  BCF    F92.3
08F6:  BSF    F89.3
....................          if(dott==0) output_high(dot);// dau cham 
08F8:  MOVF   41,F
08FA:  BNZ   0902
08FC:  BCF    F92.2
08FE:  BSF    F89.2
....................             else output_low(dot);// dau cham 
0900:  BRA    0906
0902:  BCF    F92.2
0904:  BCF    F89.2
....................          output_low(ROW0); 
0906:  BCF    F93.4
0908:  BCF    F8A.4
....................          output_low(ROW1); 
090A:  BCF    F93.5
090C:  BCF    F8A.5
....................          output_high(PIN_C7); 
090E:  BCF    F94.7
0910:  BSF    F8B.7
....................          output_low(PIN_C6); 
0912:  BCF    F94.6
0914:  BCF    F8B.6
....................          output_low(PIN_B0);                   
0916:  BCF    F93.0
0918:  BCF    F8A.0
....................       break; 
091A:  BRA    09F6
....................       case 5: 
....................          output_high(COL0); 
091C:  BCF    F92.5
091E:  BSF    F89.5
....................          output_low(COL1); 
0920:  BCF    F92.3
0922:  BCF    F89.3
....................          if(dott==0) output_high(dot);// dau cham 
0924:  MOVF   41,F
0926:  BNZ   092E
0928:  BCF    F92.2
092A:  BSF    F89.2
....................             else output_low(dot);// dau cham 
092C:  BRA    0932
092E:  BCF    F92.2
0930:  BCF    F89.2
....................          output_high(ROW0); 
0932:  BCF    F93.4
0934:  BSF    F8A.4
....................          output_low(ROW1); 
0936:  BCF    F93.5
0938:  BCF    F8A.5
....................          output_low(PIN_C7); 
093A:  BCF    F94.7
093C:  BCF    F8B.7
....................          output_low(PIN_C6); 
093E:  BCF    F94.6
0940:  BCF    F8B.6
....................          output_low(PIN_B0); 
0942:  BCF    F93.0
0944:  BCF    F8A.0
....................       break; 
0946:  BRA    09F6
....................       case 6: 
....................          output_low(COL0); 
0948:  BCF    F92.5
094A:  BCF    F89.5
....................          output_low(COL1); 
094C:  BCF    F92.3
094E:  BCF    F89.3
....................          if(dott==0) output_high(dot);// dau cham 
0950:  MOVF   41,F
0952:  BNZ   095A
0954:  BCF    F92.2
0956:  BSF    F89.2
....................             else output_low(dot);// dau cham 
0958:  BRA    095E
095A:  BCF    F92.2
095C:  BCF    F89.2
....................          output_high(ROW0); 
095E:  BCF    F93.4
0960:  BSF    F8A.4
....................          output_low(ROW1); 
0962:  BCF    F93.5
0964:  BCF    F8A.5
....................          output_low(PIN_C7); 
0966:  BCF    F94.7
0968:  BCF    F8B.7
....................          output_low(PIN_C6); 
096A:  BCF    F94.6
096C:  BCF    F8B.6
....................          output_low(PIN_B0);      
096E:  BCF    F93.0
0970:  BCF    F8A.0
....................       break; 
0972:  BRA    09F6
....................       case 7: 
....................          output_high(COL0); 
0974:  BCF    F92.5
0976:  BSF    F89.5
....................          output_high(COL1); 
0978:  BCF    F92.3
097A:  BSF    F89.3
....................          if(dott==0) output_high(dot);// dau cham 
097C:  MOVF   41,F
097E:  BNZ   0986
0980:  BCF    F92.2
0982:  BSF    F89.2
....................             else output_low(dot);// dau cham 
0984:  BRA    098A
0986:  BCF    F92.2
0988:  BCF    F89.2
....................          output_low(ROW0); 
098A:  BCF    F93.4
098C:  BCF    F8A.4
....................          output_high(ROW1); 
098E:  BCF    F93.5
0990:  BSF    F8A.5
....................          output_low(PIN_C7); 
0992:  BCF    F94.7
0994:  BCF    F8B.7
....................          output_high(PIN_C6); 
0996:  BCF    F94.6
0998:  BSF    F8B.6
....................          output_low(PIN_B0); 
099A:  BCF    F93.0
099C:  BCF    F8A.0
....................       break; 
099E:  BRA    09F6
....................       case 8: 
....................          output_low(COL0); 
09A0:  BCF    F92.5
09A2:  BCF    F89.5
....................          output_low(COL1); 
09A4:  BCF    F92.3
09A6:  BCF    F89.3
....................          if(dott==0) output_high(dot);// dau cham 
09A8:  MOVF   41,F
09AA:  BNZ   09B2
09AC:  BCF    F92.2
09AE:  BSF    F89.2
....................             else output_low(dot);// dau cham 
09B0:  BRA    09B6
09B2:  BCF    F92.2
09B4:  BCF    F89.2
....................          output_low(ROW0); 
09B6:  BCF    F93.4
09B8:  BCF    F8A.4
....................          output_low(ROW1); 
09BA:  BCF    F93.5
09BC:  BCF    F8A.5
....................          output_low(PIN_C7); 
09BE:  BCF    F94.7
09C0:  BCF    F8B.7
....................          output_low(PIN_C6); 
09C2:  BCF    F94.6
09C4:  BCF    F8B.6
....................          output_low(PIN_B0); 
09C6:  BCF    F93.0
09C8:  BCF    F8A.0
....................       break; 
09CA:  BRA    09F6
....................       case 9: 
....................          output_high(COL0); 
09CC:  BCF    F92.5
09CE:  BSF    F89.5
....................          output_low(COL1); 
09D0:  BCF    F92.3
09D2:  BCF    F89.3
....................          if(dott==0) output_high(dot);// dau cham 
09D4:  MOVF   41,F
09D6:  BNZ   09DE
09D8:  BCF    F92.2
09DA:  BSF    F89.2
....................             else output_low(dot);// dau cham 
09DC:  BRA    09E2
09DE:  BCF    F92.2
09E0:  BCF    F89.2
....................          output_low(ROW0); 
09E2:  BCF    F93.4
09E4:  BCF    F8A.4
....................          output_low(ROW1); 
09E6:  BCF    F93.5
09E8:  BCF    F8A.5
....................          output_low(PIN_C7); 
09EA:  BCF    F94.7
09EC:  BCF    F8B.7
....................          output_low(PIN_C6); 
09EE:  BCF    F94.6
09F0:  BCF    F8B.6
....................          output_low(PIN_B0);                         
09F2:  BCF    F93.0
09F4:  BCF    F8A.0
....................       break;     
....................    } 
.................... } 
09F6:  RETURN 0
.................... //============================================ 
.................... void dis_vol(int16 num) 
.................... { 
....................    int16 temp; 
....................    offled(); 
*
0BE4:  RCALL  07D8
....................    delay_us(1000); 
0BE6:  MOVLW  01
0BE8:  MOVWF  3F
0BEA:  RCALL  07B2
....................    temp=num/1000; 
0BEC:  MOVFF  3A,3E
0BF0:  MOVFF  39,3D
0BF4:  MOVLW  03
0BF6:  MOVWF  40
0BF8:  MOVLW  E8
0BFA:  MOVWF  3F
0BFC:  RCALL  0BA2
0BFE:  MOVFF  02,3C
0C02:  MOVFF  01,3B
....................    dis_number(temp,1); 
0C06:  MOVFF  3B,40
0C0A:  MOVLW  01
0C0C:  MOVWF  41
0C0E:  RCALL  0832
....................    output_high(PIN_B1); 
0C10:  BCF    F93.1
0C12:  BSF    F8A.1
....................    output_low(PIN_B3);   
0C14:  BCF    F93.3
0C16:  BCF    F8A.3
....................    output_low(PIN_B2); 
0C18:  BCF    F93.2
0C1A:  BCF    F8A.2
....................    output_low(PIN_C5); 
0C1C:  BCF    F94.5
0C1E:  BCF    F8B.5
....................    delay_us(200); 
0C20:  MOVLW  C8
0C22:  MOVWF  40
0C24:  RCALL  0A26
....................    temp=num%1000; 
0C26:  MOVFF  3A,3E
0C2A:  MOVFF  39,3D
0C2E:  MOVLW  03
0C30:  MOVWF  40
0C32:  MOVLW  E8
0C34:  MOVWF  3F
0C36:  RCALL  0BA2
0C38:  MOVFF  00,3B
0C3C:  MOVFF  03,3C
....................    offled(); 
0C40:  RCALL  07D8
....................    dis_number(temp/100,0); 
0C42:  MOVFF  3C,3E
0C46:  MOVFF  3B,3D
0C4A:  CLRF   40
0C4C:  MOVLW  64
0C4E:  MOVWF  3F
0C50:  RCALL  0BA2
0C52:  MOVFF  02,3E
0C56:  MOVFF  01,3D
0C5A:  MOVFF  01,40
0C5E:  CLRF   41
0C60:  RCALL  0832
....................    output_low(PIN_B1); 
0C62:  BCF    F93.1
0C64:  BCF    F8A.1
....................    output_high(PIN_B3);   
0C66:  BCF    F93.3
0C68:  BSF    F8A.3
....................    output_low(PIN_B2); 
0C6A:  BCF    F93.2
0C6C:  BCF    F8A.2
....................    output_low(PIN_C5); 
0C6E:  BCF    F94.5
0C70:  BCF    F8B.5
....................    delay_us(200); 
0C72:  MOVLW  C8
0C74:  MOVWF  40
0C76:  RCALL  0A26
....................    temp=num%100; 
0C78:  MOVFF  3A,3E
0C7C:  MOVFF  39,3D
0C80:  CLRF   40
0C82:  MOVLW  64
0C84:  MOVWF  3F
0C86:  RCALL  0BA2
0C88:  MOVFF  00,3B
0C8C:  MOVFF  03,3C
....................    temp=temp/10; 
0C90:  MOVFF  3C,3E
0C94:  MOVFF  3B,3D
0C98:  CLRF   40
0C9A:  MOVLW  0A
0C9C:  MOVWF  3F
0C9E:  RCALL  0BA2
0CA0:  MOVFF  02,3C
0CA4:  MOVFF  01,3B
....................    offled(); 
0CA8:  RCALL  07D8
....................    dis_number(temp,0); 
0CAA:  MOVFF  3B,40
0CAE:  CLRF   41
0CB0:  RCALL  0832
....................    output_low(PIN_B1); 
0CB2:  BCF    F93.1
0CB4:  BCF    F8A.1
....................    output_low(PIN_B3);   
0CB6:  BCF    F93.3
0CB8:  BCF    F8A.3
....................    output_high(PIN_B2); 
0CBA:  BCF    F93.2
0CBC:  BSF    F8A.2
....................    output_low(PIN_C5); 
0CBE:  BCF    F94.5
0CC0:  BCF    F8B.5
....................    delay_us(100); 
0CC2:  MOVLW  64
0CC4:  MOVWF  40
0CC6:  RCALL  0A26
....................    temp=num%100; 
0CC8:  MOVFF  3A,3E
0CCC:  MOVFF  39,3D
0CD0:  CLRF   40
0CD2:  MOVLW  64
0CD4:  MOVWF  3F
0CD6:  RCALL  0BA2
0CD8:  MOVFF  00,3B
0CDC:  MOVFF  03,3C
....................    temp=temp%10; 
0CE0:  MOVFF  3C,3E
0CE4:  MOVFF  3B,3D
0CE8:  CLRF   40
0CEA:  MOVLW  0A
0CEC:  MOVWF  3F
0CEE:  RCALL  0BA2
0CF0:  MOVFF  00,3B
0CF4:  MOVFF  03,3C
....................    offled(); 
0CF8:  RCALL  07D8
....................    dis_number(temp,0); 
0CFA:  MOVFF  3B,40
0CFE:  CLRF   41
0D00:  RCALL  0832
....................    output_low(PIN_B1); 
0D02:  BCF    F93.1
0D04:  BCF    F8A.1
....................    output_low(PIN_B3);   
0D06:  BCF    F93.3
0D08:  BCF    F8A.3
....................    output_low(PIN_B2); 
0D0A:  BCF    F93.2
0D0C:  BCF    F8A.2
....................    output_high(PIN_C5); 
0D0E:  BCF    F94.5
0D10:  BSF    F8B.5
....................    delay_us(400); 
0D12:  MOVLW  02
0D14:  MOVWF  3D
0D16:  MOVLW  C8
0D18:  MOVWF  40
0D1A:  RCALL  0A26
0D1C:  DECFSZ 3D,F
0D1E:  BRA    0D16
....................    offled(); 
0D20:  RCALL  07D8
....................  
.................... } 
0D22:  RETURN 0
.................... //============================================ 
.................... void dis_time(int8 h,int8 min,int8 sec,int8 h_blink,int8 m_blink) 
.................... { 
....................    output_low(PIN_B1); 
*
0A44:  BCF    F93.1
0A46:  BCF    F8A.1
....................    output_low(PIN_B3); 
0A48:  BCF    F93.3
0A4A:  BCF    F8A.3
....................    output_low(PIN_B2); 
0A4C:  BCF    F93.2
0A4E:  BCF    F8A.2
....................    output_low(PIN_C5); 
0A50:  BCF    F94.5
0A52:  BCF    F8B.5
....................     
....................    offled(); 
0A54:  RCALL  07D8
....................    dis_number(h/10,0); 
0A56:  MOVFF  3A,42
0A5A:  MOVLW  0A
0A5C:  MOVWF  43
0A5E:  RCALL  080A
0A60:  MOVFF  01,3F
0A64:  MOVFF  01,40
0A68:  CLRF   41
0A6A:  RCALL  0832
....................    if(h_blink==1)output_high(PIN_B1); 
0A6C:  DECFSZ 3D,W
0A6E:  BRA    0A76
0A70:  BCF    F93.1
0A72:  BSF    F8A.1
....................       else output_low(PIN_B1); 
0A74:  BRA    0A7A
0A76:  BCF    F93.1
0A78:  BCF    F8A.1
....................    output_low(PIN_B3);   
0A7A:  BCF    F93.3
0A7C:  BCF    F8A.3
....................    output_low(PIN_B2); 
0A7E:  BCF    F93.2
0A80:  BCF    F8A.2
....................    output_low(PIN_C5); 
0A82:  BCF    F94.5
0A84:  BCF    F8B.5
....................    delay_us(600); 
0A86:  MOVLW  03
0A88:  MOVWF  3F
0A8A:  MOVLW  C8
0A8C:  MOVWF  40
0A8E:  RCALL  0A26
0A90:  DECFSZ 3F,F
0A92:  BRA    0A8A
....................     
....................    output_low(PIN_B1); 
0A94:  BCF    F93.1
0A96:  BCF    F8A.1
....................    output_low(PIN_B3); 
0A98:  BCF    F93.3
0A9A:  BCF    F8A.3
....................    output_low(PIN_B2); 
0A9C:  BCF    F93.2
0A9E:  BCF    F8A.2
....................    output_low(PIN_C5); 
0AA0:  BCF    F94.5
0AA2:  BCF    F8B.5
....................    delay_us(500); 
0AA4:  MOVLW  02
0AA6:  MOVWF  3F
0AA8:  MOVLW  FA
0AAA:  MOVWF  40
0AAC:  RCALL  0A26
0AAE:  DECFSZ 3F,F
0AB0:  BRA    0AA8
....................     
....................    offled(); 
0AB2:  RCALL  07D8
....................    dis_number(h%10,sec); 
0AB4:  MOVFF  3A,42
0AB8:  MOVLW  0A
0ABA:  MOVWF  43
0ABC:  RCALL  080A
0ABE:  MOVFF  00,3F
0AC2:  MOVFF  00,40
0AC6:  MOVFF  3C,41
0ACA:  RCALL  0832
....................    output_low(PIN_B1); 
0ACC:  BCF    F93.1
0ACE:  BCF    F8A.1
....................    if(h_blink==1)output_high(PIN_B3); 
0AD0:  DECFSZ 3D,W
0AD2:  BRA    0ADA
0AD4:  BCF    F93.3
0AD6:  BSF    F8A.3
....................       else output_low(PIN_B3); 
0AD8:  BRA    0ADE
0ADA:  BCF    F93.3
0ADC:  BCF    F8A.3
....................    output_low(PIN_B2); 
0ADE:  BCF    F93.2
0AE0:  BCF    F8A.2
....................    output_low(PIN_C5); 
0AE2:  BCF    F94.5
0AE4:  BCF    F8B.5
....................    delay_us(400); 
0AE6:  MOVLW  02
0AE8:  MOVWF  3F
0AEA:  MOVLW  C8
0AEC:  MOVWF  40
0AEE:  RCALL  0A26
0AF0:  DECFSZ 3F,F
0AF2:  BRA    0AEA
....................  
....................    output_low(PIN_B1); 
0AF4:  BCF    F93.1
0AF6:  BCF    F8A.1
....................    output_low(PIN_B3); 
0AF8:  BCF    F93.3
0AFA:  BCF    F8A.3
....................    output_low(PIN_B2); 
0AFC:  BCF    F93.2
0AFE:  BCF    F8A.2
....................    output_low(PIN_C5); 
0B00:  BCF    F94.5
0B02:  BCF    F8B.5
....................    delay_us(500); 
0B04:  MOVLW  02
0B06:  MOVWF  3F
0B08:  MOVLW  FA
0B0A:  MOVWF  40
0B0C:  RCALL  0A26
0B0E:  DECFSZ 3F,F
0B10:  BRA    0B08
....................    //int8 temp; 
....................    offled(); 
0B12:  RCALL  07D8
....................    dis_number(min/10,0); 
0B14:  MOVFF  3B,42
0B18:  MOVLW  0A
0B1A:  MOVWF  43
0B1C:  RCALL  080A
0B1E:  MOVFF  01,3F
0B22:  MOVFF  01,40
0B26:  CLRF   41
0B28:  RCALL  0832
....................    output_low(PIN_B1); 
0B2A:  BCF    F93.1
0B2C:  BCF    F8A.1
....................    output_low(PIN_B3);   
0B2E:  BCF    F93.3
0B30:  BCF    F8A.3
....................     
....................    if(m_blink==1)output_high(PIN_B2); 
0B32:  DECFSZ 3E,W
0B34:  BRA    0B3C
0B36:  BCF    F93.2
0B38:  BSF    F8A.2
....................       else output_low(PIN_B2); 
0B3A:  BRA    0B40
0B3C:  BCF    F93.2
0B3E:  BCF    F8A.2
....................    output_low(PIN_C5); 
0B40:  BCF    F94.5
0B42:  BCF    F8B.5
....................    delay_us(300); 
0B44:  MOVLW  02
0B46:  MOVWF  3F
0B48:  MOVLW  96
0B4A:  MOVWF  40
0B4C:  RCALL  0A26
0B4E:  DECFSZ 3F,F
0B50:  BRA    0B48
....................     
....................    offled(); 
0B52:  RCALL  07D8
....................    dis_number(min%10,0); 
0B54:  MOVFF  3B,42
0B58:  MOVLW  0A
0B5A:  MOVWF  43
0B5C:  RCALL  080A
0B5E:  MOVFF  00,3F
0B62:  MOVFF  00,40
0B66:  CLRF   41
0B68:  RCALL  0832
....................    output_low(PIN_B2); 
0B6A:  BCF    F93.2
0B6C:  BCF    F8A.2
....................    if(m_blink==1) output_high(PIN_C5); 
0B6E:  DECFSZ 3E,W
0B70:  BRA    0B78
0B72:  BCF    F94.5
0B74:  BSF    F8B.5
....................       else output_low(PIN_C5); 
0B76:  BRA    0B7C
0B78:  BCF    F94.5
0B7A:  BCF    F8B.5
....................    delay_us(500); 
0B7C:  MOVLW  02
0B7E:  MOVWF  3F
0B80:  MOVLW  FA
0B82:  MOVWF  40
0B84:  RCALL  0A26
0B86:  DECFSZ 3F,F
0B88:  BRA    0B80
....................     
....................    output_low(PIN_B1); 
0B8A:  BCF    F93.1
0B8C:  BCF    F8A.1
....................    output_low(PIN_B3);   
0B8E:  BCF    F93.3
0B90:  BCF    F8A.3
....................    output_low(PIN_B2); 
0B92:  BCF    F93.2
0B94:  BCF    F8A.2
....................    output_low(PIN_C5); 
0B96:  BCF    F94.5
0B98:  BCF    F8B.5
....................    delay_ms(1); 
0B9A:  MOVLW  01
0B9C:  MOVWF  3F
0B9E:  RCALL  07B2
.................... } 
0BA0:  RETURN 0
.................... //================================================== 
.................... void dis_autolight(int8 blk,int8 st) 
.................... { 
....................    offled(); 
*
0D24:  RCALL  07D8
....................    delay_us(1000); 
0D26:  MOVLW  01
0D28:  MOVWF  3F
0D2A:  RCALL  07B2
....................    offled(); 
0D2C:  RCALL  07D8
....................    if(blk==1)output_high(PIN_B1); 
0D2E:  DECFSZ 39,W
0D30:  BRA    0D38
0D32:  BCF    F93.1
0D34:  BSF    F8A.1
....................       else output_low(PIN_B1); 
0D36:  BRA    0D3C
0D38:  BCF    F93.1
0D3A:  BCF    F8A.1
....................    output_low(PIN_B3);   
0D3C:  BCF    F93.3
0D3E:  BCF    F8A.3
....................    output_low(PIN_B2); 
0D40:  BCF    F93.2
0D42:  BCF    F8A.2
....................    output_low(PIN_C5); 
0D44:  BCF    F94.5
0D46:  BCF    F8B.5
....................     
....................    output_low(COL0); 
0D48:  BCF    F92.5
0D4A:  BCF    F89.5
....................    output_high(COL1);   
0D4C:  BCF    F92.3
0D4E:  BSF    F89.3
....................    output_high(dot);// dau cham 
0D50:  BCF    F92.2
0D52:  BSF    F89.2
....................    output_low(ROW0); 
0D54:  BCF    F93.4
0D56:  BCF    F8A.4
....................    output_low(ROW1); 
0D58:  BCF    F93.5
0D5A:  BCF    F8A.5
....................    output_low(PIN_C7); 
0D5C:  BCF    F94.7
0D5E:  BCF    F8B.7
....................    output_low(PIN_C6); 
0D60:  BCF    F94.6
0D62:  BCF    F8B.6
....................    output_low(PIN_B0); 
0D64:  BCF    F93.0
0D66:  BCF    F8A.0
....................    delay_us(500); 
0D68:  MOVLW  02
0D6A:  MOVWF  3B
0D6C:  MOVLW  FA
0D6E:  MOVWF  40
0D70:  RCALL  0A26
0D72:  DECFSZ 3B,F
0D74:  BRA    0D6C
....................    offled(); 
0D76:  RCALL  07D8
....................    output_low(PIN_B1); 
0D78:  BCF    F93.1
0D7A:  BCF    F8A.1
....................    if(blk==1)output_high(PIN_B3); 
0D7C:  DECFSZ 39,W
0D7E:  BRA    0D86
0D80:  BCF    F93.3
0D82:  BSF    F8A.3
....................       else output_low(PIN_B3); 
0D84:  BRA    0D8A
0D86:  BCF    F93.3
0D88:  BCF    F8A.3
....................    output_low(PIN_B2); 
0D8A:  BCF    F93.2
0D8C:  BCF    F8A.2
....................    output_low(PIN_C5); 
0D8E:  BCF    F94.5
0D90:  BCF    F8B.5
....................     
....................    output_low(COL0); 
0D92:  BCF    F92.5
0D94:  BCF    F89.5
....................    output_low(COL1);   
0D96:  BCF    F92.3
0D98:  BCF    F89.3
....................    output_high(dot);// dau cham 
0D9A:  BCF    F92.2
0D9C:  BSF    F89.2
....................    output_high(ROW0); 
0D9E:  BCF    F93.4
0DA0:  BSF    F8A.4
....................    output_low(ROW1); 
0DA2:  BCF    F93.5
0DA4:  BCF    F8A.5
....................    output_high(PIN_C7); 
0DA6:  BCF    F94.7
0DA8:  BSF    F8B.7
....................    output_high(PIN_C6); 
0DAA:  BCF    F94.6
0DAC:  BSF    F8B.6
....................    output_high(PIN_B0); 
0DAE:  BCF    F93.0
0DB0:  BSF    F8A.0
....................    delay_us(500); 
0DB2:  MOVLW  02
0DB4:  MOVWF  3B
0DB6:  MOVLW  FA
0DB8:  MOVWF  40
0DBA:  RCALL  0A26
0DBC:  DECFSZ 3B,F
0DBE:  BRA    0DB6
....................    if(st==1) 
0DC0:  DECFSZ 3A,W
0DC2:  BRA    0E38
....................    { 
....................       offled(); 
0DC4:  RCALL  07D8
....................       output_low(PIN_B1); 
0DC6:  BCF    F93.1
0DC8:  BCF    F8A.1
....................       output_low(PIN_B3);   
0DCA:  BCF    F93.3
0DCC:  BCF    F8A.3
....................       output_high(PIN_B2); 
0DCE:  BCF    F93.2
0DD0:  BSF    F8A.2
....................       output_low(PIN_C5); 
0DD2:  BCF    F94.5
0DD4:  BCF    F8B.5
....................        
....................       output_low(COL0); 
0DD6:  BCF    F92.5
0DD8:  BCF    F89.5
....................       output_low(COL1);   
0DDA:  BCF    F92.3
0DDC:  BCF    F89.3
....................       output_high(dot);// dau cham 
0DDE:  BCF    F92.2
0DE0:  BSF    F89.2
....................       output_high(ROW0); 
0DE2:  BCF    F93.4
0DE4:  BSF    F8A.4
....................       output_high(ROW1); 
0DE6:  BCF    F93.5
0DE8:  BSF    F8A.5
....................       output_high(PIN_C7); 
0DEA:  BCF    F94.7
0DEC:  BSF    F8B.7
....................       output_low(PIN_C6); 
0DEE:  BCF    F94.6
0DF0:  BCF    F8B.6
....................       output_low(PIN_B0);    
0DF2:  BCF    F93.0
0DF4:  BCF    F8A.0
....................       delay_us(500); 
0DF6:  MOVLW  02
0DF8:  MOVWF  3B
0DFA:  MOVLW  FA
0DFC:  MOVWF  40
0DFE:  RCALL  0A26
0E00:  DECFSZ 3B,F
0E02:  BRA    0DFA
....................       offled();       
0E04:  RCALL  07D8
....................       output_low(PIN_B1); 
0E06:  BCF    F93.1
0E08:  BCF    F8A.1
....................       output_low(PIN_B3);   
0E0A:  BCF    F93.3
0E0C:  BCF    F8A.3
....................       output_low(PIN_B2); 
0E0E:  BCF    F93.2
0E10:  BCF    F8A.2
....................       output_high(PIN_C5); 
0E12:  BCF    F94.5
0E14:  BSF    F8B.5
....................        
....................       output_low(COL0); 
0E16:  BCF    F92.5
0E18:  BCF    F89.5
....................       output_high(COL1);   
0E1A:  BCF    F92.3
0E1C:  BSF    F89.3
....................       output_high(dot);// dau cham 
0E1E:  BCF    F92.2
0E20:  BSF    F89.2
....................       output_high(ROW0); 
0E22:  BCF    F93.4
0E24:  BSF    F8A.4
....................       output_high(ROW1); 
0E26:  BCF    F93.5
0E28:  BSF    F8A.5
....................       output_high(PIN_C7); 
0E2A:  BCF    F94.7
0E2C:  BSF    F8B.7
....................       output_low(PIN_C6); 
0E2E:  BCF    F94.6
0E30:  BCF    F8B.6
....................       output_low(PIN_B0);    
0E32:  BCF    F93.0
0E34:  BCF    F8A.0
....................  
....................    } 
....................       else  
0E36:  BRA    0EAA
....................       { 
....................          offled(); 
0E38:  RCALL  07D8
....................          output_low(PIN_B1); 
0E3A:  BCF    F93.1
0E3C:  BCF    F8A.1
....................          output_low(PIN_B3);   
0E3E:  BCF    F93.3
0E40:  BCF    F8A.3
....................          output_high(PIN_B2); 
0E42:  BCF    F93.2
0E44:  BSF    F8A.2
....................          output_low(PIN_C5); 
0E46:  BCF    F94.5
0E48:  BCF    F8B.5
....................           
....................          output_low(COL0); 
0E4A:  BCF    F92.5
0E4C:  BCF    F89.5
....................          output_low(COL1);   
0E4E:  BCF    F92.3
0E50:  BCF    F89.3
....................          output_high(dot);// dau cham 
0E52:  BCF    F92.2
0E54:  BSF    F89.2
....................          output_high(ROW0); 
0E56:  BCF    F93.4
0E58:  BSF    F8A.4
....................          output_high(ROW1); 
0E5A:  BCF    F93.5
0E5C:  BSF    F8A.5
....................          output_high(PIN_C7); 
0E5E:  BCF    F94.7
0E60:  BSF    F8B.7
....................          output_low(PIN_C6); 
0E62:  BCF    F94.6
0E64:  BCF    F8B.6
....................          output_low(PIN_B0);    
0E66:  BCF    F93.0
0E68:  BCF    F8A.0
....................          delay_us(400); 
0E6A:  MOVLW  02
0E6C:  MOVWF  3B
0E6E:  MOVLW  C8
0E70:  MOVWF  40
0E72:  RCALL  0A26
0E74:  DECFSZ 3B,F
0E76:  BRA    0E6E
....................          offled(); 
0E78:  RCALL  07D8
....................          output_low(PIN_B1); 
0E7A:  BCF    F93.1
0E7C:  BCF    F8A.1
....................          output_low(PIN_B3);   
0E7E:  BCF    F93.3
0E80:  BCF    F8A.3
....................          output_low(PIN_B2); 
0E82:  BCF    F93.2
0E84:  BCF    F8A.2
....................          output_high(PIN_C5); 
0E86:  BCF    F94.5
0E88:  BSF    F8B.5
....................           
....................          output_low(COL0); 
0E8A:  BCF    F92.5
0E8C:  BCF    F89.5
....................          output_high(COL1);   
0E8E:  BCF    F92.3
0E90:  BSF    F89.3
....................          output_high(dot);// dau cham 
0E92:  BCF    F92.2
0E94:  BSF    F89.2
....................          output_high(ROW0); 
0E96:  BCF    F93.4
0E98:  BSF    F8A.4
....................          output_low(ROW1); 
0E9A:  BCF    F93.5
0E9C:  BCF    F8A.5
....................          output_low(PIN_C7); 
0E9E:  BCF    F94.7
0EA0:  BCF    F8B.7
....................          output_low(PIN_C6); 
0EA2:  BCF    F94.6
0EA4:  BCF    F8B.6
....................          output_high(PIN_B0);   
0EA6:  BCF    F93.0
0EA8:  BSF    F8A.0
....................       } 
....................    delay_us(500); 
0EAA:  MOVLW  02
0EAC:  MOVWF  3B
0EAE:  MOVLW  FA
0EB0:  MOVWF  40
0EB2:  RCALL  0A26
0EB4:  DECFSZ 3B,F
0EB6:  BRA    0EAE
....................    offled(); 
0EB8:  RCALL  07D8
....................    delay_us(400); 
0EBA:  MOVLW  02
0EBC:  MOVWF  3B
0EBE:  MOVLW  C8
0EC0:  MOVWF  40
0EC2:  RCALL  0A26
0EC4:  DECFSZ 3B,F
0EC6:  BRA    0EBE
.................... } 
0EC8:  RETURN 0
.................... //================================================== 
....................  
.................... //========================= 
.................... //========================= 
.................... #INT_TIMER1 
.................... void timer1() 
.................... { 
....................    output_toggle(LED); 
*
00BA:  BCF    F92.6
00BC:  BTG    F89.6
....................    set_timer1(0xffff-50); 
00BE:  SETF   FCF
00C0:  MOVLW  CD
00C2:  MOVWF  FCE
.................... } 
.................... //========================== 
00C4:  BCF    F9E.0
00C6:  GOTO   006C
.................... int8 blh=0,blm=0,modeck=0,mode=0,blal=0,modebal=0; 
.................... int8 count_press=0,adc,alst=0; 
.................... int16 vol_accu=0; 
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    if((mode==0)||(mode==2)) 
*
03AC:  MOVF   27,F
03AE:  BZ    03B6
03B0:  MOVF   27,W
03B2:  SUBLW  02
03B4:  BNZ   03C2
....................    { 
....................       if((input(KEY)==0))count_press++; 
03B6:  BSF    F92.1
03B8:  BTFSC  F80.1
03BA:  BRA    03C0
03BC:  INCF   2A,F
....................          else count_press=0; 
03BE:  BRA    03C2
03C0:  CLRF   2A
....................    } 
....................    if(count_press>=10) 
03C2:  MOVF   2A,W
03C4:  SUBLW  09
03C6:  BC    03EE
....................    { 
....................       if(mode==0) 
03C8:  MOVF   27,F
03CA:  BNZ   03D6
....................       { 
....................          modeck++; 
03CC:  INCF   26,F
....................          if(modeck==3)modeck=0; 
03CE:  MOVF   26,W
03D0:  SUBLW  03
03D2:  BTFSC  FD8.2
03D4:  CLRF   26
....................       } 
....................       if(mode==2) 
03D6:  MOVF   27,W
03D8:  SUBLW  02
03DA:  BNZ   03EC
....................       { 
....................         modebal=!modebal;  
03DC:  MOVF   29,F
03DE:  BZ    03E4
03E0:  MOVLW  00
03E2:  BRA    03E6
03E4:  MOVLW  01
03E6:  MOVWF  29
....................         blal=1; 
03E8:  MOVLW  01
03EA:  MOVWF  28
....................       } 
....................       count_press=0; 
03EC:  CLRF   2A
....................    } 
....................    if(modebal==1) 
03EE:  DECFSZ 29,W
03F0:  BRA    0404
....................    { 
....................       blal=!blal; 
03F2:  MOVF   28,F
03F4:  BZ    03FA
03F6:  MOVLW  00
03F8:  BRA    03FC
03FA:  MOVLW  01
03FC:  MOVWF  28
....................       modeck=0; 
03FE:  CLRF   26
....................       mode=2; 
0400:  MOVLW  02
0402:  MOVWF  27
....................    } 
....................    if(modeck==1)  
0404:  DECFSZ 26,W
0406:  BRA    041C
....................    { 
....................       modebal=0; 
0408:  CLRF   29
....................       mode=0; 
040A:  CLRF   27
....................       blm=!blm; 
040C:  MOVF   25,F
040E:  BZ    0414
0410:  MOVLW  00
0412:  BRA    0416
0414:  MOVLW  01
0416:  MOVWF  25
....................       blh=1; 
0418:  MOVLW  01
041A:  MOVWF  24
....................    } 
....................    if(modeck==2)  
041C:  MOVF   26,W
041E:  SUBLW  02
0420:  BNZ   0436
....................    { 
....................       modebal=0; 
0422:  CLRF   29
....................       mode=0; 
0424:  CLRF   27
....................       blh=!blh; 
0426:  MOVF   24,F
0428:  BZ    042E
042A:  MOVLW  00
042C:  BRA    0430
042E:  MOVLW  01
0430:  MOVWF  24
....................       blm=1; 
0432:  MOVLW  01
0434:  MOVWF  25
....................    } 
....................    if(modeck==0) 
0436:  MOVF   26,F
0438:  BNZ   0440
....................    { 
....................       blh=1; 
043A:  MOVLW  01
043C:  MOVWF  24
....................       blm=1; 
043E:  MOVWF  25
....................    } 
....................    set_adc_channel(0); 
0440:  MOVLW  00
0442:  MOVWF  01
0444:  MOVF   FC2,W
0446:  ANDLW  C3
0448:  IORWF  01,W
044A:  MOVWF  FC2
....................    adc=read_adc(); 
044C:  BSF    FC2.1
044E:  BTFSC  FC2.1
0450:  BRA    044E
0452:  MOVFF  FC4,2B
....................    vol_accu=(int16)((3360/255)*adc*10.6/10); 
0456:  CLRF   46
0458:  MOVLW  0D
045A:  MOVWF  45
045C:  CLRF   48
045E:  MOVFF  2B,47
0462:  BRA    00CA
0464:  MOVFF  02,46
0468:  MOVFF  01,45
046C:  MOVFF  02,48
0470:  MOVFF  01,47
0474:  BRA    00EA
0476:  MOVFF  03,4A
047A:  MOVFF  02,49
047E:  MOVFF  01,48
0482:  MOVFF  00,47
0486:  MOVLW  9A
0488:  MOVWF  4E
048A:  MOVLW  99
048C:  MOVWF  4D
048E:  MOVLW  29
0490:  MOVWF  4C
0492:  MOVLW  82
0494:  MOVWF  4B
0496:  BRA    0122
0498:  MOVFF  00,45
049C:  MOVFF  01,46
04A0:  MOVFF  02,47
04A4:  MOVFF  03,48
04A8:  MOVFF  03,4C
04AC:  MOVFF  02,4B
04B0:  MOVFF  01,4A
04B4:  MOVFF  00,49
04B8:  CLRF   50
04BA:  CLRF   4F
04BC:  MOVLW  20
04BE:  MOVWF  4E
04C0:  MOVLW  82
04C2:  MOVWF  4D
04C4:  BRA    0216
04C6:  MOVFF  03,48
04CA:  MOVFF  02,47
04CE:  MOVFF  01,46
04D2:  MOVFF  00,45
04D6:  BRA    0372
04D8:  MOVFF  02,2E
04DC:  MOVFF  01,2D
.................... } 
.................... //========================= 
04E0:  BCF    FF2.2
04E2:  GOTO   006C
.................... void main() 
.................... { 
*
1102:  CLRF   FF8
1104:  BCF    FD0.7
1106:  BSF    07.7
1108:  CLRF   FEA
110A:  CLRF   FE9
110C:  BCF    F94.0
110E:  BSF    F8B.0
1110:  MOVLW  0E
1112:  MOVWF  20
1114:  CLRF   21
1116:  CLRF   22
1118:  CLRF   23
111A:  CLRF   24
111C:  CLRF   25
111E:  CLRF   26
1120:  CLRF   27
1122:  CLRF   28
1124:  CLRF   29
1126:  CLRF   2A
1128:  CLRF   2C
112A:  CLRF   2E
112C:  CLRF   2D
112E:  MOVLW  FF
1130:  MOVLB  F
1132:  MOVWF  x48
1134:  BCF    FC2.6
1136:  BCF    FC2.7
1138:  MOVF   x49,W
113A:  ANDLW  E0
113C:  IORLW  1F
113E:  MOVWF  x49
1140:  CLRF   FD2
1142:  CLRF   FD1
1144:  CLRF   19
1146:  CLRF   1A
1148:  CLRF   32
114A:  CLRF   31
114C:  CLRF   30
114E:  CLRF   2F
1150:  CLRF   36
1152:  CLRF   37
1154:  CLRF   38
....................    int32 timeout_setting=0; 
....................    int8 h,m,s,day=0,month=0,year=0; 
....................    //RPINR2=6; 
....................    // RPINR1=5; 
....................  
....................    setup_oscillator(OSC_32MHZ); 
1156:  MOVLW  70
1158:  MOVWF  FD3
115A:  MOVLW  40
115C:  MOVWF  F9B
115E:  MOVF   FD3,W
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
1160:  BCF    FF2.6
1162:  BCF    FF2.7
1164:  BTFSC  FF2.7
1166:  BRA    1162
....................    init_ext_eeprom(); 
1168:  MOVLB  0
116A:  GOTO   04E6
....................  
....................    //===================================== 
....................    rtc_init(); 
116E:  GOTO   064E
....................     
....................    setup_timer_0(T0_INTERNAL|T0_DIV_32); 
1172:  MOVLW  84
1174:  MOVWF  FD5
....................    //setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
....................  
....................  
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................     enable_interrupts(INT_TIMER0); 
1176:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       //enable_interrupts(INT_RDA); 
....................        
....................      enable_interrupts(GLOBAL); 
1178:  MOVLW  C0
117A:  IORWF  FF2,F
....................    //========================================== 
....................    alst = read_ext_eeprom(0); 
117C:  CLRF   3A
117E:  CLRF   39
1180:  GOTO   06EA
1184:  MOVFF  01,2C
....................    //========================================== 
....................    setup_adc_ports(sAN0|VSS_VDD); 
1188:  MOVLW  FE
118A:  MOVLB  F
118C:  MOVWF  x48
118E:  BCF    FC2.6
1190:  BCF    FC2.7
1192:  MOVF   x49,W
1194:  ANDLW  E0
1196:  IORLW  1F
1198:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_CLOCK_DIV_32); 
119A:  MOVF   FC1,W
119C:  ANDLW  C0
119E:  IORLW  03
11A0:  MOVWF  FC1
11A2:  BCF    FC1.7
11A4:  BSF    FC2.0
11A6:  BSF    FC1.6
11A8:  BSF    FC2.1
11AA:  BTFSC  FC2.1
11AC:  BRA    11AA
11AE:  BCF    FC1.6
....................     
....................    
....................    //save_coutcard(349); 
....................    output_high(PIN_B1); 
11B0:  BCF    F93.1
11B2:  BSF    F8A.1
....................    output_low(PIN_B3);   
11B4:  BCF    F93.3
11B6:  BCF    F8A.3
....................    output_low(PIN_B2); 
11B8:  BCF    F93.2
11BA:  BCF    F8A.2
....................    output_low(PIN_C5); 
11BC:  BCF    F94.5
11BE:  BCF    F8B.5
....................     
....................    //dis_number(9); 
....................     
....................     
....................    //output_low(PIN_B3); 
....................    //output_high(PIN_B1); 
....................    //output_high(PIN_B2); 
....................    /*while(1) 
....................    { 
....................       dis_vol(vol_accu); 
....................       delay_ms(1); 
....................    }*/ 
....................    while(1) 
....................    { 
....................       switch(modeck) 
....................       { 
11C0:  MOVF   26,W
11C2:  ADDLW  FC
11C4:  BTFSC  FD8.0
11C6:  BRA    1382
11C8:  ADDLW  04
11CA:  MOVLB  0
11CC:  GOTO   1426
....................          case 0: 
....................             rtc_get_time(h,m,s);   
....................             if(input(KEY)==0) 
*
1216:  BSF    F92.1
1218:  BTFSC  F80.1
121A:  BRA    1294
....................             { 
....................                delay_ms(10); 
121C:  MOVLW  0A
121E:  MOVWF  3F
1220:  CALL   07B2
....................                while(input(KEY)==0) 
....................                { 
1224:  BSF    F92.1
1226:  BTFSC  F80.1
1228:  BRA    126A
....................                   if(mode==0)dis_time(h,m,s%2,blh,blm);  
122A:  MOVF   27,F
122C:  BNZ   124A
122E:  MOVF   35,W
1230:  ANDLW  01
1232:  MOVWF  39
1234:  MOVFF  33,3A
1238:  MOVFF  34,3B
123C:  MOVWF  3C
123E:  MOVFF  24,3D
1242:  MOVFF  25,3E
1246:  CALL   0A44
....................                   if(mode==1)dis_vol(vol_accu); 
124A:  DECFSZ 27,W
124C:  BRA    1258
124E:  MOVFF  2E,3A
1252:  MOVFF  2D,39
1256:  RCALL  0BE4
....................                   if(mode==2)dis_autolight(blal,alst); 
1258:  MOVF   27,W
125A:  SUBLW  02
125C:  BNZ   1268
125E:  MOVFF  28,39
1262:  MOVFF  2C,3A
1266:  RCALL  0D24
....................                } 
1268:  BRA    1224
....................                blal=1; 
126A:  MOVLW  01
126C:  MOVWF  28
....................                if(modebal==0) 
126E:  MOVF   29,F
1270:  BNZ   127E
....................                { 
....................                   mode++; 
1272:  INCF   27,F
....................                   if(mode>=3)mode=0; 
1274:  MOVF   27,W
1276:  SUBLW  02
1278:  BTFSS  FD8.0
127A:  CLRF   27
....................                } 
....................                   else 
127C:  BRA    1294
....................                   { 
....................                      alst=!alst; 
127E:  MOVF   2C,F
1280:  BZ    1286
1282:  MOVLW  00
1284:  BRA    1288
1286:  MOVLW  01
1288:  MOVWF  2C
....................                      write_ext_eeprom(0,alst); 
128A:  CLRF   3A
128C:  CLRF   39
128E:  MOVFF  2C,3B
1292:  BRA    0ECA
....................                   } 
....................             } 
....................          break; 
1294:  MOVLB  F
1296:  BRA    1382
....................          case 1: 
....................             if(input(KEY)==0) 
1298:  BSF    F92.1
129A:  BTFSC  F80.1
129C:  BRA    12F4
....................             { 
....................                delay_ms(10); 
129E:  MOVLW  0A
12A0:  MOVWF  3F
12A2:  CALL   07B2
....................                m++; 
12A6:  INCF   34,F
....................                timeout_setting=0; 
12A8:  CLRF   32
12AA:  CLRF   31
12AC:  CLRF   30
12AE:  CLRF   2F
....................                if(m>=60)m=0; 
12B0:  MOVF   34,W
12B2:  SUBLW  3B
12B4:  BTFSS  FD8.0
12B6:  CLRF   34
....................                while(input(KEY)==0)dis_time(h,m,s%2,blh,blm);                                
12B8:  BSF    F92.1
12BA:  BTFSC  F80.1
12BC:  BRA    12DC
12BE:  MOVF   35,W
12C0:  ANDLW  01
12C2:  MOVWF  39
12C4:  MOVFF  33,3A
12C8:  MOVFF  34,3B
12CC:  MOVWF  3C
12CE:  MOVFF  24,3D
12D2:  MOVFF  25,3E
12D6:  CALL   0A44
12DA:  BRA    12B8
....................                rtc_set_datetime(day,month,year,0,h,m); 
12DC:  MOVFF  36,39
12E0:  MOVFF  37,3A
12E4:  MOVFF  38,3B
12E8:  CLRF   3C
12EA:  MOVFF  33,3D
12EE:  MOVFF  34,3E
12F2:  RCALL  107A
....................                 
....................             } 
....................          break; 
12F4:  MOVLB  F
12F6:  BRA    1382
....................          case 2: 
....................             if(input(KEY)==0) 
12F8:  BSF    F92.1
12FA:  BTFSC  F80.1
12FC:  BRA    1354
....................             { 
....................                delay_ms(10); 
12FE:  MOVLW  0A
1300:  MOVWF  3F
1302:  CALL   07B2
....................                h++; 
1306:  INCF   33,F
....................                timeout_setting=0; 
1308:  CLRF   32
130A:  CLRF   31
130C:  CLRF   30
130E:  CLRF   2F
....................                if(h>=24)h=0; 
1310:  MOVF   33,W
1312:  SUBLW  17
1314:  BTFSS  FD8.0
1316:  CLRF   33
....................                while(input(KEY)==0)dis_time(h,m,s%2,blh,blm);                                
1318:  BSF    F92.1
131A:  BTFSC  F80.1
131C:  BRA    133C
131E:  MOVF   35,W
1320:  ANDLW  01
1322:  MOVWF  39
1324:  MOVFF  33,3A
1328:  MOVFF  34,3B
132C:  MOVWF  3C
132E:  MOVFF  24,3D
1332:  MOVFF  25,3E
1336:  CALL   0A44
133A:  BRA    1318
....................                rtc_set_datetime(day,month,year,0,h,m); 
133C:  MOVFF  36,39
1340:  MOVFF  37,3A
1344:  MOVFF  38,3B
1348:  CLRF   3C
134A:  MOVFF  33,3D
134E:  MOVFF  34,3E
1352:  RCALL  107A
....................                 
....................             }  
....................          break; 
1354:  MOVLB  F
1356:  BRA    1382
....................          case 3: 
....................              dis_vol(vol_accu); 
1358:  MOVFF  2E,3A
135C:  MOVFF  2D,39
1360:  RCALL  0BE4
....................              if(input(KEY)==0) 
1362:  BSF    F92.1
1364:  BTFSC  F80.1
1366:  BRA    137C
....................             { 
....................                while(input(KEY)==0)dis_vol(vol_accu); 
1368:  BSF    F92.1
136A:  BTFSC  F80.1
136C:  BRA    137A
136E:  MOVFF  2E,3A
1372:  MOVFF  2D,39
1376:  RCALL  0BE4
1378:  BRA    1368
....................                modeck=0; 
137A:  CLRF   26
....................             } 
....................          break; 
137C:  MOVLB  F
137E:  BRA    1382
1380:  MOVLB  F
....................       } 
....................       if(mode==0)dis_time(h,m,s%2,blh,blm);  
1382:  MOVF   27,F
1384:  BNZ   13A6
1386:  MOVF   35,W
1388:  ANDLW  01
138A:  MOVWF  39
138C:  MOVFF  33,3A
1390:  MOVFF  34,3B
1394:  MOVWF  3C
1396:  MOVFF  24,3D
139A:  MOVFF  25,3E
139E:  MOVLB  0
13A0:  CALL   0A44
13A4:  MOVLB  F
....................       if(mode==1)dis_vol(vol_accu); 
13A6:  DECFSZ 27,W
13A8:  BRA    13B8
13AA:  MOVFF  2E,3A
13AE:  MOVFF  2D,39
13B2:  MOVLB  0
13B4:  RCALL  0BE4
13B6:  MOVLB  F
....................       if(mode==2)dis_autolight(blal,alst); 
13B8:  MOVF   27,W
13BA:  SUBLW  02
13BC:  BNZ   13CC
13BE:  MOVFF  28,39
13C2:  MOVFF  2C,3A
13C6:  MOVLB  0
13C8:  RCALL  0D24
13CA:  MOVLB  F
....................       if(alst==0)output_low(relay); 
13CC:  MOVF   2C,F
13CE:  BNZ   13D6
13D0:  BCF    F92.7
13D2:  BCF    F89.7
....................          else output_high(relay); 
13D4:  BRA    13DA
13D6:  BCF    F92.7
13D8:  BSF    F89.7
....................       if((modeck==1)||(modeck==2)) 
13DA:  DECFSZ 26,W
13DC:  BRA    13E0
13DE:  BRA    13E6
13E0:  MOVF   26,W
13E2:  SUBLW  02
13E4:  BNZ   1422
....................       { 
....................          if(timeout_setting==5000)modeck=0; 
13E6:  MOVF   2F,W
13E8:  SUBLW  88
13EA:  BNZ   13FC
13EC:  MOVF   30,W
13EE:  SUBLW  13
13F0:  BNZ   13FC
13F2:  MOVF   31,F
13F4:  BNZ   13FC
13F6:  MOVF   32,F
13F8:  BTFSC  FD8.2
13FA:  CLRF   26
....................          if(timeout_setting<5001)timeout_setting++; 
13FC:  MOVF   32,F
13FE:  BNZ   1422
1400:  MOVF   31,F
1402:  BNZ   1422
1404:  MOVF   30,W
1406:  SUBLW  13
1408:  BNC   1422
140A:  BNZ   1412
140C:  MOVF   2F,W
140E:  SUBLW  88
1410:  BNC   1422
1412:  MOVLW  01
1414:  ADDWF  2F,F
1416:  BTFSC  FD8.0
1418:  INCF   30,F
141A:  BTFSC  FD8.2
141C:  INCF   31,F
141E:  BTFSC  FD8.2
1420:  INCF   32,F
....................       } 
....................       //if(input(KEY)==0) 
....................          //dis_time(1,1,1); 
....................       //dis_number(s); 
....................        //delay_ms(500);     
....................    } 
1422:  BRA    11C0
....................     
....................     
.................... } 
1424:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

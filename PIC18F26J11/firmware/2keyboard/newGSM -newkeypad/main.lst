CCS PCH C Compiler, Version 4.140, 6310               02-Mar-16 12:10

               Filename:   E:\projects\magnertic proj\for chris\PIC18F26J11\firmware\2keyboard\newGSM -newkeypad\main.lst

               ROM used:   29190 bytes (45%)
                           Largest free fragment is 36334
               RAM used:   2697 (71%) at main() level
                           2872 (76%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   6D46
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   4886
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   2440
006C:  BTFSS  FF0.3
006E:  GOTO   0078
0072:  BTFSC  FF0.0
0074:  GOTO   1F66
0078:  BTFSS  F9D.5
007A:  GOTO   0084
007E:  BTFSC  F9E.5
0080:  GOTO   23EC
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0584:  MOVLW  02
0586:  MOVLB  A
0588:  SUBWF  xE3,F
058A:  BNC   05A4
058C:  MOVLW  0A
058E:  MOVWF  FEA
0590:  MOVLW  E3
0592:  MOVWF  FE9
0594:  MOVF   FEF,W
0596:  BZ    05A4
0598:  BRA    05A0
059A:  BRA    059C
059C:  BRA    059E
059E:  NOP   
05A0:  DECFSZ FEF,F
05A2:  BRA    059A
05A4:  MOVLB  0
05A6:  GOTO   1F76 (RETURN)
*
1C34:  MOVLW  0A
1C36:  MOVWF  FEA
1C38:  MOVLW  EB
1C3A:  MOVWF  FE9
1C3C:  MOVF   FEF,W
1C3E:  BZ    1C5A
1C40:  MOVLW  0A
1C42:  MOVWF  01
1C44:  CLRF   00
1C46:  DECFSZ 00,F
1C48:  BRA    1C46
1C4A:  DECFSZ 01,F
1C4C:  BRA    1C44
1C4E:  MOVLW  5F
1C50:  MOVWF  00
1C52:  DECFSZ 00,F
1C54:  BRA    1C52
1C56:  DECFSZ FEF,F
1C58:  BRA    1C40
1C5A:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
05AA:  BCF    F94.0
05AC:  BCF    F8B.0
05AE:  MOVLW  08
05B0:  MOVWF  01
05B2:  BRA    05B4
05B4:  NOP   
05B6:  BSF    01.7
05B8:  BRA    05DA
05BA:  BCF    01.7
05BC:  MOVLB  B
05BE:  RRCF   x1A,F
05C0:  MOVLB  0
05C2:  BTFSC  FD8.0
05C4:  BSF    F8B.0
05C6:  BTFSS  FD8.0
05C8:  BCF    F8B.0
05CA:  BSF    01.6
05CC:  BRA    05DA
05CE:  BCF    01.6
05D0:  DECFSZ 01,F
05D2:  BRA    05BC
05D4:  BRA    05D6
05D6:  NOP   
05D8:  BSF    F8B.0
05DA:  MOVLW  10
05DC:  MOVWF  FE9
05DE:  DECFSZ FE9,F
05E0:  BRA    05DE
05E2:  BRA    05E4
05E4:  NOP   
05E6:  BTFSC  01.7
05E8:  BRA    05BA
05EA:  BTFSC  01.6
05EC:  BRA    05CE
05EE:  RETURN 0
*
4EC0:  BSF    F94.1
4EC2:  BTFSC  F82.1
4EC4:  BRA    4EC2
4EC6:  MOVLW  08
4EC8:  MOVWF  00
4ECA:  MOVLB  A
4ECC:  CLRF   xC7
4ECE:  BSF    00.7
4ED0:  BRA    4EF2
4ED2:  BCF    00.7
4ED4:  BRA    4EF2
4ED6:  MOVFF  AC7,02
4EDA:  BCF    FD8.0
4EDC:  BTFSC  F82.1
4EDE:  BSF    FD8.0
4EE0:  RRCF   02,F
4EE2:  BSF    00.6
4EE4:  BRA    4EF2
4EE6:  BCF    00.6
4EE8:  DECFSZ 00,F
4EEA:  BRA    4EDA
4EEC:  MOVFF  02,01
4EF0:  BRA    4F0A
4EF2:  MOVLW  10
4EF4:  BTFSC  00.7
4EF6:  MOVLW  04
4EF8:  MOVWF  01
4EFA:  DECFSZ 01,F
4EFC:  BRA    4EFA
4EFE:  BRA    4F00
4F00:  BTFSC  00.7
4F02:  BRA    4ED2
4F04:  BTFSC  00.6
4F06:  BRA    4EE6
4F08:  BRA    4EDA
4F0A:  MOVLB  0
4F0C:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
38DA:  MOVLW  08
38DC:  MOVWF  01
38DE:  MOVLW  0A
38E0:  MOVWF  00
38E2:  DECFSZ 00,F
38E4:  BRA    38E2
38E6:  BCF    F8B.3
38E8:  BCF    F94.3
38EA:  MOVLW  0B
38EC:  MOVWF  00
38EE:  DECFSZ 00,F
38F0:  BRA    38EE
38F2:  MOVLB  B
38F4:  RLCF   x09,F
38F6:  BCF    F8B.4
38F8:  BTFSC  FD8.0
38FA:  BSF    F94.4
38FC:  BTFSS  FD8.0
38FE:  BCF    F94.4
3900:  BSF    F94.3
3902:  BTFSS  F82.3
3904:  BRA    3902
3906:  DECFSZ 01,F
3908:  BRA    390C
390A:  BRA    3910
390C:  MOVLB  0
390E:  BRA    38DE
3910:  MOVLW  0A
3912:  MOVWF  00
3914:  DECFSZ 00,F
3916:  BRA    3914
3918:  BCF    F8B.3
391A:  BCF    F94.3
391C:  NOP   
391E:  BSF    F94.4
3920:  MOVLW  0B
3922:  MOVWF  00
3924:  DECFSZ 00,F
3926:  BRA    3924
3928:  MOVLW  0B
392A:  MOVWF  00
392C:  DECFSZ 00,F
392E:  BRA    392C
3930:  BSF    F94.3
3932:  BTFSS  F82.3
3934:  BRA    3932
3936:  CLRF   01
3938:  MOVLW  0B
393A:  MOVWF  00
393C:  DECFSZ 00,F
393E:  BRA    393C
3940:  BTFSC  F82.4
3942:  BSF    01.0
3944:  BCF    F8B.3
3946:  BCF    F94.3
3948:  BCF    F8B.4
394A:  BCF    F94.4
394C:  MOVLB  0
394E:  RETURN 0
3950:  MOVLW  08
3952:  MOVLB  A
3954:  MOVWF  xF2
3956:  MOVFF  00,AF3
395A:  BSF    F94.4
395C:  MOVLW  0B
395E:  MOVWF  00
3960:  DECFSZ 00,F
3962:  BRA    3960
3964:  BSF    F94.3
3966:  BTFSS  F82.3
3968:  BRA    3966
396A:  BTFSC  F82.4
396C:  BSF    FD8.0
396E:  BTFSS  F82.4
3970:  BCF    FD8.0
3972:  RLCF   01,F
3974:  MOVLW  0A
3976:  MOVWF  00
3978:  DECFSZ 00,F
397A:  BRA    3978
397C:  BCF    F94.3
397E:  BCF    F8B.3
3980:  DECFSZ xF2,F
3982:  BRA    395A
3984:  BSF    F94.4
3986:  MOVLW  0B
3988:  MOVWF  00
398A:  DECFSZ 00,F
398C:  BRA    398A
398E:  BCF    F8B.4
3990:  MOVF   xF3,W
3992:  BTFSS  FD8.2
3994:  BCF    F94.4
3996:  NOP   
3998:  BSF    F94.3
399A:  BTFSS  F82.3
399C:  BRA    399A
399E:  MOVLW  0A
39A0:  MOVWF  00
39A2:  DECFSZ 00,F
39A4:  BRA    39A2
39A6:  BCF    F8B.3
39A8:  BCF    F94.3
39AA:  MOVLW  0B
39AC:  MOVWF  00
39AE:  DECFSZ 00,F
39B0:  BRA    39AE
39B2:  BCF    F8B.4
39B4:  BCF    F94.4
39B6:  MOVLB  0
39B8:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... //#define EEPROM_SIZE   65535 
.................... #define EEPROM_SIZE_key    65535 
.................... #define EEPROM_SIZE        43590 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
4B46:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
4B48:  BSF    F94.4
....................    port_b_pullups(0xff); 
4B4A:  BCF    FF1.7
.................... } 
4B4C:  GOTO   6EDE (RETURN)
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
3FE4:  BSF    F94.4
3FE6:  MOVLW  0A
3FE8:  MOVWF  00
3FEA:  DECFSZ 00,F
3FEC:  BRA    3FEA
3FEE:  BSF    F94.3
3FF0:  MOVLW  0B
3FF2:  MOVWF  00
3FF4:  DECFSZ 00,F
3FF6:  BRA    3FF4
3FF8:  BCF    F8B.4
3FFA:  BCF    F94.4
3FFC:  MOVLW  0A
3FFE:  MOVWF  00
4000:  DECFSZ 00,F
4002:  BRA    4000
4004:  BCF    F8B.3
4006:  BCF    F94.3
....................    i2c_write(0xa0); 
4008:  MOVLW  A0
400A:  MOVLB  B
400C:  MOVWF  x09
400E:  MOVLB  0
4010:  RCALL  38DA
....................    i2c_write(address>>8); 
4012:  MOVFF  B03,B07
4016:  MOVLB  B
4018:  CLRF   x08
401A:  MOVFF  B03,B09
401E:  MOVLB  0
4020:  RCALL  38DA
....................    i2c_write(address); 
4022:  MOVFF  B02,B09
4026:  RCALL  38DA
....................    i2c_write(data); 
4028:  MOVFF  B04,B09
402C:  RCALL  38DA
....................    i2c_stop(); 
402E:  BCF    F94.4
4030:  NOP   
4032:  BSF    F94.3
4034:  BTFSS  F82.3
4036:  BRA    4034
4038:  MOVLW  0A
403A:  MOVWF  00
403C:  DECFSZ 00,F
403E:  BRA    403C
4040:  BRA    4042
4042:  NOP   
4044:  BSF    F94.4
4046:  MOVLW  0A
4048:  MOVWF  00
404A:  DECFSZ 00,F
404C:  BRA    404A
....................    i2c_start(); 
404E:  BSF    F94.4
4050:  MOVLW  0A
4052:  MOVWF  00
4054:  DECFSZ 00,F
4056:  BRA    4054
4058:  BSF    F94.3
405A:  MOVLW  0B
405C:  MOVWF  00
405E:  DECFSZ 00,F
4060:  BRA    405E
4062:  BCF    F8B.4
4064:  BCF    F94.4
4066:  MOVLW  0A
4068:  MOVWF  00
406A:  DECFSZ 00,F
406C:  BRA    406A
406E:  BCF    F8B.3
4070:  BCF    F94.3
....................    status=i2c_write(0xa0); 
4072:  MOVLW  A0
4074:  MOVLB  B
4076:  MOVWF  x09
4078:  MOVLB  0
407A:  RCALL  38DA
407C:  MOVF   01,W
407E:  MOVLB  B
4080:  BCF    x05.0
4082:  BTFSC  01.0
4084:  BSF    x05.0
....................    while(status==1) 
....................    { 
4086:  BTFSS  x05.0
4088:  BRA    40C6
....................       i2c_start(); 
408A:  BSF    F94.4
408C:  MOVLW  0A
408E:  MOVWF  00
4090:  DECFSZ 00,F
4092:  BRA    4090
4094:  BSF    F94.3
4096:  MOVLW  0B
4098:  MOVWF  00
409A:  DECFSZ 00,F
409C:  BRA    409A
409E:  BTFSS  F82.3
40A0:  BRA    409E
40A2:  BCF    F8B.4
40A4:  BCF    F94.4
40A6:  MOVLW  0A
40A8:  MOVWF  00
40AA:  DECFSZ 00,F
40AC:  BRA    40AA
40AE:  BCF    F8B.3
40B0:  BCF    F94.3
....................       status=i2c_write(0xa0); 
40B2:  MOVLW  A0
40B4:  MOVWF  x09
40B6:  MOVLB  0
40B8:  RCALL  38DA
40BA:  MOVF   01,W
40BC:  MOVLB  B
40BE:  BCF    x05.0
40C0:  BTFSC  01.0
40C2:  BSF    x05.0
....................    } 
40C4:  BRA    4086
....................    i2c_stop(); 
40C6:  BCF    F94.4
40C8:  NOP   
40CA:  BSF    F94.3
40CC:  BTFSS  F82.3
40CE:  BRA    40CC
40D0:  MOVLW  0A
40D2:  MOVWF  00
40D4:  DECFSZ 00,F
40D6:  BRA    40D4
40D8:  BRA    40DA
40DA:  NOP   
40DC:  BSF    F94.4
40DE:  MOVLW  0A
40E0:  MOVWF  00
40E2:  DECFSZ 00,F
40E4:  BRA    40E2
.................... } 
40E6:  MOVLB  0
40E8:  RETURN 0
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
3A84:  BSF    F94.4
3A86:  MOVLW  0A
3A88:  MOVWF  00
3A8A:  DECFSZ 00,F
3A8C:  BRA    3A8A
3A8E:  BSF    F94.3
3A90:  MOVLW  0B
3A92:  MOVWF  00
3A94:  DECFSZ 00,F
3A96:  BRA    3A94
3A98:  BCF    F8B.4
3A9A:  BCF    F94.4
3A9C:  MOVLW  0A
3A9E:  MOVWF  00
3AA0:  DECFSZ 00,F
3AA2:  BRA    3AA0
3AA4:  BCF    F8B.3
3AA6:  BCF    F94.3
....................    i2c_write(0xa0); 
3AA8:  MOVLW  A0
3AAA:  MOVLB  B
3AAC:  MOVWF  x09
3AAE:  MOVLB  0
3AB0:  RCALL  38DA
....................    i2c_write(address>>8); 
3AB2:  MOVFF  AEF,AF1
3AB6:  MOVLB  A
3AB8:  CLRF   xF2
3ABA:  MOVFF  AEF,B09
3ABE:  MOVLB  0
3AC0:  RCALL  38DA
....................    i2c_write(address); 
3AC2:  MOVFF  AEE,B09
3AC6:  RCALL  38DA
....................    i2c_start(); 
3AC8:  BSF    F94.4
3ACA:  MOVLW  0A
3ACC:  MOVWF  00
3ACE:  DECFSZ 00,F
3AD0:  BRA    3ACE
3AD2:  BSF    F94.3
3AD4:  MOVLW  0B
3AD6:  MOVWF  00
3AD8:  DECFSZ 00,F
3ADA:  BRA    3AD8
3ADC:  BTFSS  F82.3
3ADE:  BRA    3ADC
3AE0:  BCF    F8B.4
3AE2:  BCF    F94.4
3AE4:  MOVLW  0A
3AE6:  MOVWF  00
3AE8:  DECFSZ 00,F
3AEA:  BRA    3AE8
3AEC:  BCF    F8B.3
3AEE:  BCF    F94.3
....................    i2c_write(0xa1); 
3AF0:  MOVLW  A1
3AF2:  MOVLB  B
3AF4:  MOVWF  x09
3AF6:  MOVLB  0
3AF8:  RCALL  38DA
....................    data=i2c_read(0); 
3AFA:  CLRF   00
3AFC:  RCALL  3950
3AFE:  MOVFF  01,AF0
....................    i2c_stop(); 
3B02:  BCF    F94.4
3B04:  NOP   
3B06:  BSF    F94.3
3B08:  BTFSS  F82.3
3B0A:  BRA    3B08
3B0C:  MOVLW  0A
3B0E:  MOVWF  00
3B10:  DECFSZ 00,F
3B12:  BRA    3B10
3B14:  BRA    3B16
3B16:  NOP   
3B18:  BSF    F94.4
3B1A:  MOVLW  0A
3B1C:  MOVWF  00
3B1E:  DECFSZ 00,F
3B20:  BRA    3B1E
....................    return(data); 
3B22:  MOVLB  A
3B24:  MOVFF  AF0,01
.................... } 
3B28:  MOVLB  0
3B2A:  RETURN 0
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
5112:  MOVLB  A
5114:  MOVF   xC2,W
5116:  ADDWF  xC0,W
5118:  MOVWF  xC8
511A:  MOVF   xC3,W
511C:  ADDWFC xC1,W
511E:  MOVWF  xC9
5120:  SUBLW  A9
5122:  BC    5134
5124:  XORLW  FF
5126:  BNZ   512E
5128:  MOVF   xC8,W
512A:  SUBLW  45
512C:  BC    5134
512E:  MOVLW  00
5130:  MOVWF  01
5132:  BRA    5192
....................    for(i=0;i<len;i++) 
5134:  CLRF   xC7
5136:  CLRF   xC6
5138:  MOVF   xC7,W
513A:  SUBWF  xC3,W
513C:  BNC   5192
513E:  BNZ   5146
5140:  MOVF   xC2,W
5142:  SUBWF  xC6,W
5144:  BC    5192
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
5146:  MOVF   xC4,W
5148:  ADDWF  xC6,W
514A:  MOVWF  01
514C:  MOVF   xC5,W
514E:  ADDWFC xC7,W
5150:  MOVWF  03
5152:  MOVFF  01,AC8
5156:  MOVWF  xC9
5158:  MOVF   xC6,W
515A:  ADDWF  xC0,W
515C:  MOVWF  xCA
515E:  MOVF   xC7,W
5160:  ADDWFC xC1,W
5162:  MOVWF  xCB
5164:  CLRF   19
5166:  BTFSC  FF2.7
5168:  BSF    19.7
516A:  BCF    FF2.7
516C:  MOVWF  xEF
516E:  MOVFF  ACA,AEE
5172:  MOVLB  0
5174:  CALL   3A84
5178:  BTFSC  19.7
517A:  BSF    FF2.7
517C:  MOVFF  AC9,FEA
5180:  MOVFF  AC8,FE9
5184:  MOVFF  01,FEF
....................    } 
5188:  MOVLB  A
518A:  INCF   xC6,F
518C:  BTFSC  FD8.2
518E:  INCF   xC7,F
5190:  BRA    5138
....................     
.................... } 
5192:  MOVLB  0
5194:  GOTO   5932 (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_mobile_num0        65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_two_number        149 
.................... #define kindofKB                 126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards                350   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
3B9E:  MOVLB  A
3BA0:  CLRF   xF7
3BA2:  MOVF   xF4,W
3BA4:  SUBWF  xF7,W
3BA6:  BC    3BBC
....................    { 
....................       inputdat[i]=0; 
3BA8:  CLRF   03
3BAA:  MOVF   xF7,W
3BAC:  ADDWF  xF5,W
3BAE:  MOVWF  FE9
3BB0:  MOVF   xF6,W
3BB2:  ADDWFC 03,W
3BB4:  MOVWF  FEA
3BB6:  CLRF   FEF
....................    } 
3BB8:  INCF   xF7,F
3BBA:  BRA    3BA2
.................... } 
3BBC:  MOVLB  0
3BBE:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_write(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
4BAA:  MOVLB  A
4BAC:  CLRF   xD7
4BAE:  MOVF   xD4,W
4BB0:  SUBWF  xD7,W
4BB2:  BC    4BFA
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
4BB4:  MOVF   xD7,W
4BB6:  ADDWF  xD3,W
4BB8:  MOVWF  xD8
4BBA:  CLRF   03
4BBC:  MOVF   xD7,W
4BBE:  ADDWF  xD5,W
4BC0:  MOVWF  FE9
4BC2:  MOVF   xD6,W
4BC4:  ADDWFC 03,W
4BC6:  MOVWF  FEA
4BC8:  MOVFF  FEF,AD9
4BCC:  CLRF   19
4BCE:  BTFSC  FF2.7
4BD0:  BSF    19.7
4BD2:  BCF    FF2.7
4BD4:  MOVLB  B
4BD6:  CLRF   x03
4BD8:  MOVFF  AD8,B02
4BDC:  MOVFF  AD9,B04
4BE0:  MOVLB  0
4BE2:  CALL   3FE4
4BE6:  BTFSC  19.7
4BE8:  BSF    FF2.7
....................       delay_us(10); 
4BEA:  MOVLW  1A
4BEC:  MOVWF  00
4BEE:  DECFSZ 00,F
4BF0:  BRA    4BEE
4BF2:  NOP   
....................    } 
4BF4:  MOVLB  A
4BF6:  INCF   xD7,F
4BF8:  BRA    4BAE
.................... } 
4BFA:  MOVLB  0
4BFC:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
4B50:  MOVLB  A
4B52:  CLRF   xC2
4B54:  MOVF   xBF,W
4B56:  SUBWF  xC2,W
4B58:  BC    4BA6
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
4B5A:  CLRF   03
4B5C:  MOVF   xC2,W
4B5E:  ADDWF  xC0,W
4B60:  MOVWF  01
4B62:  MOVF   xC1,W
4B64:  ADDWFC 03,F
4B66:  MOVFF  01,AC3
4B6A:  MOVFF  03,AC4
4B6E:  MOVF   xC2,W
4B70:  ADDWF  xBE,W
4B72:  MOVWF  xC5
4B74:  CLRF   19
4B76:  BTFSC  FF2.7
4B78:  BSF    19.7
4B7A:  BCF    FF2.7
4B7C:  CLRF   xEF
4B7E:  MOVWF  xEE
4B80:  MOVLB  0
4B82:  CALL   3A84
4B86:  BTFSC  19.7
4B88:  BSF    FF2.7
4B8A:  MOVFF  AC4,FEA
4B8E:  MOVFF  AC3,FE9
4B92:  MOVFF  01,FEF
....................       delay_us(10); 
4B96:  MOVLW  1A
4B98:  MOVWF  00
4B9A:  DECFSZ 00,F
4B9C:  BRA    4B9A
4B9E:  NOP   
....................    } 
4BA0:  MOVLB  A
4BA2:  INCF   xC2,F
4BA4:  BRA    4B54
.................... } 
4BA6:  MOVLB  0
4BA8:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
4D82:  MOVLB  A
4D84:  CLRF   x8C
4D86:  CLRF   x8B
4D88:  CLRF   x8A
4D8A:  CLRF   x89
4D8C:  CLRF   x90
4D8E:  CLRF   x8F
4D90:  CLRF   x8E
4D92:  CLRF   x8D
4D94:  CLRF   x94
4D96:  CLRF   x93
4D98:  CLRF   x92
4D9A:  CLRF   x91
4D9C:  CLRF   x98
4D9E:  CLRF   x97
4DA0:  CLRF   x96
4DA2:  CLRF   x95
4DA4:  CLRF   x9C
4DA6:  CLRF   x9B
4DA8:  CLRF   x9A
4DAA:  CLRF   x99
4DAC:  CLRF   19
4DAE:  BTFSC  FF2.7
4DB0:  BSF    19.7
4DB2:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
4DB4:  CLRF   xEF
4DB6:  MOVFF  A88,AEE
4DBA:  MOVLB  0
4DBC:  CALL   3A84
4DC0:  BTFSC  19.7
4DC2:  BSF    FF2.7
4DC4:  MOVLB  A
4DC6:  MOVFF  01,A8D
4DCA:  CLRF   x8E
4DCC:  CLRF   x8F
4DCE:  CLRF   x90
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
4DD0:  MOVLW  01
4DD2:  ADDWF  x88,W
4DD4:  MOVWF  x9D
4DD6:  CLRF   19
4DD8:  BTFSC  FF2.7
4DDA:  BSF    19.7
4DDC:  BCF    FF2.7
4DDE:  CLRF   xEF
4DE0:  MOVWF  xEE
4DE2:  MOVLB  0
4DE4:  CALL   3A84
4DE8:  BTFSC  19.7
4DEA:  BSF    FF2.7
4DEC:  MOVLB  A
4DEE:  CLRF   x94
4DF0:  CLRF   x93
4DF2:  CLRF   x92
4DF4:  MOVFF  01,A91
....................    temp2<<=8; 
4DF8:  MOVFF  A93,A94
4DFC:  MOVFF  A92,A93
4E00:  MOVFF  A91,A92
4E04:  CLRF   x91
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
4E06:  MOVLW  02
4E08:  ADDWF  x88,W
4E0A:  MOVWF  x9D
4E0C:  CLRF   19
4E0E:  BTFSC  FF2.7
4E10:  BSF    19.7
4E12:  BCF    FF2.7
4E14:  CLRF   xEF
4E16:  MOVWF  xEE
4E18:  MOVLB  0
4E1A:  CALL   3A84
4E1E:  BTFSC  19.7
4E20:  BSF    FF2.7
4E22:  MOVLB  A
4E24:  CLRF   x98
4E26:  CLRF   x97
4E28:  CLRF   x96
4E2A:  MOVFF  01,A95
....................    temp3<<=16; 
4E2E:  MOVFF  A96,A98
4E32:  MOVFF  A95,A97
4E36:  CLRF   x95
4E38:  CLRF   x96
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
4E3A:  MOVLW  03
4E3C:  ADDWF  x88,W
4E3E:  MOVWF  x9D
4E40:  CLRF   19
4E42:  BTFSC  FF2.7
4E44:  BSF    19.7
4E46:  BCF    FF2.7
4E48:  CLRF   xEF
4E4A:  MOVWF  xEE
4E4C:  MOVLB  0
4E4E:  CALL   3A84
4E52:  BTFSC  19.7
4E54:  BSF    FF2.7
4E56:  MOVLB  A
4E58:  CLRF   x9C
4E5A:  CLRF   x9B
4E5C:  CLRF   x9A
4E5E:  MOVFF  01,A99
....................    temp4<<=24; 
4E62:  MOVFF  A99,A9C
4E66:  CLRF   x99
4E68:  CLRF   x9A
4E6A:  CLRF   x9B
....................    buffer = temp4|temp3|temp2|temp1; 
4E6C:  MOVF   x99,W
4E6E:  IORWF  x95,W
4E70:  MOVWF  x9D
4E72:  MOVF   x9A,W
4E74:  IORWF  x96,W
4E76:  MOVWF  x9E
4E78:  MOVF   x9B,W
4E7A:  IORWF  x97,W
4E7C:  MOVWF  x9F
4E7E:  MOVF   x9C,W
4E80:  IORWF  x98,W
4E82:  MOVWF  xA0
4E84:  MOVF   x91,W
4E86:  IORWF  x9D,F
4E88:  MOVF   x92,W
4E8A:  IORWF  x9E,F
4E8C:  MOVF   x93,W
4E8E:  IORWF  x9F,F
4E90:  MOVF   x94,W
4E92:  IORWF  xA0,F
4E94:  MOVF   x9D,W
4E96:  IORWF  x8D,W
4E98:  MOVWF  x89
4E9A:  MOVF   x9E,W
4E9C:  IORWF  x8E,W
4E9E:  MOVWF  x8A
4EA0:  MOVF   x9F,W
4EA2:  IORWF  x8F,W
4EA4:  MOVWF  x8B
4EA6:  MOVF   xA0,W
4EA8:  IORWF  x90,W
4EAA:  MOVWF  x8C
....................    return(buffer); 
4EAC:  MOVFF  A89,00
4EB0:  MOVFF  A8A,01
4EB4:  MOVFF  A8B,02
4EB8:  MOVFF  A8C,03
.................... } 
4EBC:  MOVLB  0
4EBE:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
40EA:  MOVLB  A
40EC:  CLRF   xF0
40EE:  CLRF   xEF
40F0:  CLRF   xEE
40F2:  CLRF   xED
40F4:  CLRF   xF1
40F6:  CLRF   xF2
40F8:  CLRF   xF3
40FA:  CLRF   xF4
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
40FC:  MOVFF  AEB,AF0
4100:  MOVFF  AEA,AEF
4104:  MOVFF  AE9,AEE
4108:  MOVFF  AE8,AED
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
410C:  MOVFF  AED,AF1
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
4110:  MOVFF  AEE,AF2
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
4114:  MOVFF  AEF,AF3
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
4118:  MOVFF  AF0,AF4
....................    write_ext_eeprom((addr+0),temp1); 
411C:  MOVLB  B
411E:  CLRF   x03
4120:  MOVFF  AEC,B02
4124:  MOVFF  AF1,B04
4128:  MOVLB  0
412A:  RCALL  3FE4
....................    write_ext_eeprom((addr+1),temp2); 
412C:  MOVLW  01
412E:  MOVLB  A
4130:  ADDWF  xEC,W
4132:  MOVWF  xF5
4134:  MOVLB  B
4136:  CLRF   x03
4138:  MOVWF  x02
413A:  MOVFF  AF2,B04
413E:  MOVLB  0
4140:  RCALL  3FE4
....................    write_ext_eeprom((addr+2),temp3); 
4142:  MOVLW  02
4144:  MOVLB  A
4146:  ADDWF  xEC,W
4148:  MOVWF  xF5
414A:  MOVLB  B
414C:  CLRF   x03
414E:  MOVWF  x02
4150:  MOVFF  AF3,B04
4154:  MOVLB  0
4156:  RCALL  3FE4
....................    write_ext_eeprom((addr+3),temp4); 
4158:  MOVLW  03
415A:  MOVLB  A
415C:  ADDWF  xEC,W
415E:  MOVWF  xF5
4160:  MOVLB  B
4162:  CLRF   x03
4164:  MOVWF  x02
4166:  MOVFF  AF4,B04
416A:  MOVLB  0
416C:  RCALL  3FE4
.................... } 
416E:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
4754:  MOVLB  A
4756:  CLRF   xE8
4758:  CLRF   xE7
475A:  CLRF   xE9
475C:  CLRF   xEA
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
475E:  MOVFF  AE6,AE8
4762:  MOVFF  AE5,AE7
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
4766:  MOVFF  AE7,AE9
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
476A:  MOVF   xE8,W
476C:  MOVWF  xEA
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
476E:  MOVLB  B
4770:  CLRF   x03
4772:  MOVLW  28
4774:  MOVWF  x02
4776:  MOVFF  AE9,B04
477A:  MOVLB  0
477C:  RCALL  3FE4
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
477E:  MOVLB  B
4780:  CLRF   x03
4782:  MOVLW  29
4784:  MOVWF  x02
4786:  MOVFF  AEA,B04
478A:  MOVLB  0
478C:  RCALL  3FE4
.................... } 
478E:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
3B2C:  MOVLB  A
3B2E:  CLRF   xE9
3B30:  CLRF   xE8
3B32:  CLRF   xEB
3B34:  CLRF   xEA
3B36:  CLRF   xED
3B38:  CLRF   xEC
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
3B3A:  CLRF   xEF
3B3C:  MOVLW  28
3B3E:  MOVWF  xEE
3B40:  MOVLB  0
3B42:  RCALL  3A84
3B44:  MOVLB  A
3B46:  MOVFF  01,AEA
3B4A:  CLRF   xEB
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3B4C:  CLRF   xEF
3B4E:  MOVLW  29
3B50:  MOVWF  xEE
3B52:  MOVLB  0
3B54:  RCALL  3A84
3B56:  MOVLB  A
3B58:  CLRF   xED
3B5A:  MOVFF  01,AEC
....................    temp2<<=8; 
3B5E:  MOVFF  AEC,AED
3B62:  CLRF   xEC
....................    buffer = temp2|temp1; 
3B64:  MOVF   xEC,W
3B66:  IORWF  xEA,W
3B68:  MOVWF  xE8
3B6A:  MOVF   xED,W
3B6C:  IORWF  xEB,W
3B6E:  MOVWF  xE9
....................    return(buffer); 
3B70:  MOVFF  AE8,01
3B74:  MOVFF  AE9,02
.................... } 
3B78:  MOVLB  0
3B7A:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int16 i; 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
52AE:  MOVLW  AA
52B0:  MOVLB  A
52B2:  MOVWF  xBF
52B4:  MOVLW  47
52B6:  MOVWF  xBE
52B8:  MOVF   27,F
52BA:  BNZ   52CE
52BC:  MOVF   26,F
52BE:  BNZ   52CE
52C0:  MOVF   xBF,W
52C2:  SUBWF  25,W
52C4:  BNC   52F6
52C6:  BNZ   52CE
52C8:  MOVF   24,W
52CA:  SUBWF  xBE,W
52CC:  BC    52F6
52CE:  CLRF   19
52D0:  BTFSC  FF2.7
52D2:  BSF    19.7
52D4:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
52D6:  MOVFF  ABF,B03
52DA:  MOVFF  ABE,B02
52DE:  MOVLB  B
52E0:  CLRF   x04
52E2:  MOVLB  0
52E4:  CALL   3FE4
52E8:  BTFSC  19.7
52EA:  BSF    FF2.7
....................    } 
52EC:  MOVLB  A
52EE:  INCF   xBE,F
52F0:  BTFSC  FD8.2
52F2:  INCF   xBF,F
52F4:  BRA    52B8
....................    for(i=ptr_start;i<ptr_card;i++) 
52F6:  CLRF   xBF
52F8:  MOVLW  96
52FA:  MOVWF  xBE
52FC:  MOVF   23,F
52FE:  BNZ   5312
5300:  MOVF   22,F
5302:  BNZ   5312
5304:  MOVF   xBF,W
5306:  SUBWF  21,W
5308:  BNC   533A
530A:  BNZ   5312
530C:  MOVF   20,W
530E:  SUBWF  xBE,W
5310:  BC    533A
5312:  CLRF   19
5314:  BTFSC  FF2.7
5316:  BSF    19.7
5318:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
531A:  MOVFF  ABF,B03
531E:  MOVFF  ABE,B02
5322:  MOVLB  B
5324:  CLRF   x04
5326:  MOVLB  0
5328:  CALL   3FE4
532C:  BTFSC  19.7
532E:  BSF    FF2.7
....................    } 
5330:  MOVLB  A
5332:  INCF   xBE,F
5334:  BTFSC  FD8.2
5336:  INCF   xBF,F
5338:  BRA    52FC
....................    ptr_card=ptr_start; 
533A:  CLRF   23
533C:  CLRF   22
533E:  CLRF   21
5340:  MOVLW  96
5342:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5344:  CLRF   27
5346:  CLRF   26
5348:  MOVLW  AA
534A:  MOVWF  25
534C:  MOVLW  47
534E:  MOVWF  24
5350:  CLRF   19
5352:  BTFSC  FF2.7
5354:  BSF    19.7
5356:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5358:  MOVFF  23,AEB
535C:  MOVFF  22,AEA
5360:  MOVFF  21,AE9
5364:  MOVFF  20,AE8
5368:  MOVLW  19
536A:  MOVWF  xEC
536C:  MOVLB  0
536E:  CALL   40EA
5372:  BTFSC  19.7
5374:  BSF    FF2.7
5376:  CLRF   19
5378:  BTFSC  FF2.7
537A:  BSF    19.7
537C:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
537E:  MOVFF  27,AEB
5382:  MOVFF  26,AEA
5386:  MOVFF  25,AE9
538A:  MOVFF  24,AE8
538E:  MOVLW  1E
5390:  MOVLB  A
5392:  MOVWF  xEC
5394:  MOVLB  0
5396:  CALL   40EA
539A:  BTFSC  19.7
539C:  BSF    FF2.7
539E:  CLRF   19
53A0:  BTFSC  FF2.7
53A2:  BSF    19.7
53A4:  BCF    FF2.7
....................    save_coutcard(0); 
53A6:  MOVLB  A
53A8:  CLRF   xE6
53AA:  CLRF   xE5
53AC:  MOVLB  0
53AE:  CALL   4754
53B2:  BTFSC  19.7
53B4:  BSF    FF2.7
53B6:  CLRF   19
53B8:  BTFSC  FF2.7
53BA:  BSF    19.7
53BC:  BCF    FF2.7
....................    countcard=get_countcard(); 
53BE:  CALL   3B2C
53C2:  BTFSC  19.7
53C4:  BSF    FF2.7
53C6:  MOVFF  02,FA
53CA:  MOVFF  01,F9
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
.................... } 
53CE:  GOTO   5C80 (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int16 i; 
....................    for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
53D2:  MOVLB  A
53D4:  CLRF   xBF
53D6:  MOVLW  96
53D8:  MOVWF  xBE
53DA:  INCFSZ xBE,W
53DC:  BRA    53E4
53DE:  INCFSZ xBF,W
53E0:  BRA    53E4
53E2:  BRA    540C
53E4:  CLRF   19
53E6:  BTFSC  FF2.7
53E8:  BSF    19.7
53EA:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
53EC:  MOVFF  ABF,B03
53F0:  MOVFF  ABE,B02
53F4:  MOVLB  B
53F6:  CLRF   x04
53F8:  MOVLB  0
53FA:  CALL   3FE4
53FE:  BTFSC  19.7
5400:  BSF    FF2.7
....................    } 
5402:  MOVLB  A
5404:  INCF   xBE,F
5406:  BTFSC  FD8.2
5408:  INCF   xBF,F
540A:  BRA    53DA
....................    ptr_card=ptr_start; 
540C:  CLRF   23
540E:  CLRF   22
5410:  CLRF   21
5412:  MOVLW  96
5414:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5416:  CLRF   27
5418:  CLRF   26
541A:  MOVLW  AA
541C:  MOVWF  25
541E:  MOVLW  47
5420:  MOVWF  24
5422:  CLRF   19
5424:  BTFSC  FF2.7
5426:  BSF    19.7
5428:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
542A:  MOVFF  23,AEB
542E:  MOVFF  22,AEA
5432:  MOVFF  21,AE9
5436:  MOVFF  20,AE8
543A:  MOVLW  19
543C:  MOVWF  xEC
543E:  MOVLB  0
5440:  CALL   40EA
5444:  BTFSC  19.7
5446:  BSF    FF2.7
5448:  CLRF   19
544A:  BTFSC  FF2.7
544C:  BSF    19.7
544E:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5450:  MOVFF  27,AEB
5454:  MOVFF  26,AEA
5458:  MOVFF  25,AE9
545C:  MOVFF  24,AE8
5460:  MOVLW  1E
5462:  MOVLB  A
5464:  MOVWF  xEC
5466:  MOVLB  0
5468:  CALL   40EA
546C:  BTFSC  19.7
546E:  BSF    FF2.7
5470:  CLRF   19
5472:  BTFSC  FF2.7
5474:  BSF    19.7
5476:  BCF    FF2.7
....................    save_coutcard(0); 
5478:  MOVLB  A
547A:  CLRF   xE6
547C:  CLRF   xE5
547E:  MOVLB  0
5480:  CALL   4754
5484:  BTFSC  19.7
5486:  BSF    FF2.7
.................... } 
5488:  GOTO   5CE6 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
4BFE:  MOVLB  A
4C00:  CLRF   xBE
4C02:  MOVLW  14
4C04:  MOVWF  xBF
4C06:  CLRF   xC1
4C08:  MOVLW  55
4C0A:  MOVWF  xC0
4C0C:  MOVLB  0
4C0E:  RCALL  4B50
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
4C10:  INCFSZ 55,W
4C12:  BRA    4C68
4C14:  INCFSZ 56,W
4C16:  BRA    4C68
4C18:  INCFSZ x64,W
4C1A:  BRA    4C68
....................       { 
....................          memset(buffer1,0,20); 
4C1C:  CLRF   FEA
4C1E:  MOVLW  2D
4C20:  MOVWF  FE9
4C22:  CLRF   00
4C24:  CLRF   02
4C26:  MOVLW  14
4C28:  MOVWF  01
4C2A:  RCALL  45F2
....................          strcpy(buffer1,"admin"); 
4C2C:  CLRF   FEA
4C2E:  MOVLW  2D
4C30:  MOVWF  FE9
4C32:  MOVLW  00
4C34:  CALL   00D2
4C38:  TBLRD*-
4C3A:  TBLRD*+
4C3C:  MOVF   FF5,W
4C3E:  MOVWF  FEE
4C40:  IORLW  00
4C42:  BNZ   4C3A
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
4C44:  MOVLB  A
4C46:  CLRF   xD3
4C48:  MOVLW  14
4C4A:  MOVWF  xD4
4C4C:  CLRF   xD6
4C4E:  MOVLW  2D
4C50:  MOVWF  xD5
4C52:  MOVLB  0
4C54:  RCALL  4BAA
....................          EEPROM_read(strobe_pass_addr,20,password); 
4C56:  MOVLB  A
4C58:  CLRF   xBE
4C5A:  MOVLW  14
4C5C:  MOVWF  xBF
4C5E:  CLRF   xC1
4C60:  MOVLW  55
4C62:  MOVWF  xC0
4C64:  MOVLB  0
4C66:  RCALL  4B50
....................       } 
.................... } 
4C68:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
548C:  MOVLB  A
548E:  CLRF   xD2
5490:  MOVF   xD2,W
5492:  SUBLW  13
5494:  BNC   54AA
5496:  CLRF   03
5498:  MOVF   xD2,W
549A:  ADDLW  BE
549C:  MOVWF  FE9
549E:  MOVLW  0A
54A0:  ADDWFC 03,W
54A2:  MOVWF  FEA
54A4:  SETF   FEF
54A6:  INCF   xD2,F
54A8:  BRA    5490
....................    EEPROM_write(strobe_pass_addr,20,buf); 
54AA:  CLRF   xD3
54AC:  MOVLW  14
54AE:  MOVWF  xD4
54B0:  MOVLW  0A
54B2:  MOVWF  xD6
54B4:  MOVLW  BE
54B6:  MOVWF  xD5
54B8:  MOVLB  0
54BA:  CALL   4BAA
.................... } 
54BE:  GOTO   5D4C (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
39BA:  BSF    F94.4
39BC:  MOVLW  0A
39BE:  MOVWF  00
39C0:  DECFSZ 00,F
39C2:  BRA    39C0
39C4:  BSF    F94.3
39C6:  MOVLW  0B
39C8:  MOVWF  00
39CA:  DECFSZ 00,F
39CC:  BRA    39CA
39CE:  BCF    F8B.4
39D0:  BCF    F94.4
39D2:  MOVLW  0A
39D4:  MOVWF  00
39D6:  DECFSZ 00,F
39D8:  BRA    39D6
39DA:  BCF    F8B.3
39DC:  BCF    F94.3
....................    i2c_write(0xD0); 
39DE:  MOVLW  D0
39E0:  MOVLB  B
39E2:  MOVWF  x09
39E4:  MOVLB  0
39E6:  RCALL  38DA
....................    i2c_write(address); 
39E8:  MOVFF  AEC,B09
39EC:  RCALL  38DA
....................    i2c_start(); 
39EE:  BSF    F94.4
39F0:  MOVLW  0A
39F2:  MOVWF  00
39F4:  DECFSZ 00,F
39F6:  BRA    39F4
39F8:  BSF    F94.3
39FA:  MOVLW  0B
39FC:  MOVWF  00
39FE:  DECFSZ 00,F
3A00:  BRA    39FE
3A02:  BTFSS  F82.3
3A04:  BRA    3A02
3A06:  BCF    F8B.4
3A08:  BCF    F94.4
3A0A:  MOVLW  0A
3A0C:  MOVWF  00
3A0E:  DECFSZ 00,F
3A10:  BRA    3A0E
3A12:  BCF    F8B.3
3A14:  BCF    F94.3
....................    i2c_write(0xD1); 
3A16:  MOVLW  D1
3A18:  MOVLB  B
3A1A:  MOVWF  x09
3A1C:  MOVLB  0
3A1E:  RCALL  38DA
....................    result = i2c_read(0); 
3A20:  CLRF   00
3A22:  RCALL  3950
3A24:  MOVFF  01,AED
....................    i2c_stop(); 
3A28:  BCF    F94.4
3A2A:  NOP   
3A2C:  BSF    F94.3
3A2E:  BTFSS  F82.3
3A30:  BRA    3A2E
3A32:  MOVLW  0A
3A34:  MOVWF  00
3A36:  DECFSZ 00,F
3A38:  BRA    3A36
3A3A:  BRA    3A3C
3A3C:  NOP   
3A3E:  BSF    F94.4
3A40:  MOVLW  0A
3A42:  MOVWF  00
3A44:  DECFSZ 00,F
3A46:  BRA    3A44
....................     
....................    return(result); 
3A48:  MOVLB  A
3A4A:  MOVFF  AED,01
.................... } 
3A4E:  MOVLB  0
3A50:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
5632:  BSF    F94.4
5634:  MOVLW  0A
5636:  MOVWF  00
5638:  DECFSZ 00,F
563A:  BRA    5638
563C:  BSF    F94.3
563E:  MOVLW  0B
5640:  MOVWF  00
5642:  DECFSZ 00,F
5644:  BRA    5642
5646:  BCF    F8B.4
5648:  BCF    F94.4
564A:  MOVLW  0A
564C:  MOVWF  00
564E:  DECFSZ 00,F
5650:  BRA    564E
5652:  BCF    F8B.3
5654:  BCF    F94.3
....................    delay_us(10); 
5656:  MOVLW  1A
5658:  MOVWF  00
565A:  DECFSZ 00,F
565C:  BRA    565A
565E:  NOP   
5660:  CLRF   19
5662:  BTFSC  FF2.7
5664:  BSF    19.7
5666:  BCF    FF2.7
....................    i2c_write(0xD0); 
5668:  MOVLW  D0
566A:  MOVLB  B
566C:  MOVWF  x09
566E:  MOVLB  0
5670:  CALL   38DA
5674:  BTFSC  19.7
5676:  BSF    FF2.7
....................    delay_us(10); 
5678:  MOVLW  1A
567A:  MOVWF  00
567C:  DECFSZ 00,F
567E:  BRA    567C
5680:  NOP   
5682:  CLRF   19
5684:  BTFSC  FF2.7
5686:  BSF    19.7
5688:  BCF    FF2.7
....................    i2c_write(address); 
568A:  MOVFF  AC5,B09
568E:  CALL   38DA
5692:  BTFSC  19.7
5694:  BSF    FF2.7
....................    delay_us(10); 
5696:  MOVLW  1A
5698:  MOVWF  00
569A:  DECFSZ 00,F
569C:  BRA    569A
569E:  NOP   
56A0:  CLRF   19
56A2:  BTFSC  FF2.7
56A4:  BSF    19.7
56A6:  BCF    FF2.7
....................    i2c_write(data); 
56A8:  MOVFF  AC6,B09
56AC:  CALL   38DA
56B0:  BTFSC  19.7
56B2:  BSF    FF2.7
....................    i2c_stop(); 
56B4:  BCF    F94.4
56B6:  NOP   
56B8:  BSF    F94.3
56BA:  BTFSS  F82.3
56BC:  BRA    56BA
56BE:  MOVLW  0A
56C0:  MOVWF  00
56C2:  DECFSZ 00,F
56C4:  BRA    56C2
56C6:  BRA    56C8
56C8:  NOP   
56CA:  BSF    F94.4
56CC:  MOVLW  0A
56CE:  MOVWF  00
56D0:  DECFSZ 00,F
56D2:  BRA    56D0
....................    delay_us(10); 
56D4:  MOVLW  1A
56D6:  MOVWF  00
56D8:  DECFSZ 00,F
56DA:  BRA    56D8
56DC:  NOP   
.................... } 
56DE:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
*
4C6A:  CLRF   19
4C6C:  BTFSC  FF2.7
4C6E:  BSF    19.7
4C70:  BCF    FF2.7
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
4C72:  MOVLB  A
4C74:  CLRF   xEC
4C76:  MOVLB  0
4C78:  CALL   39BA
4C7C:  BTFSC  19.7
4C7E:  BSF    FF2.7
4C80:  MOVFF  01,A88
....................     
....................    data &= 0x7F; 
4C84:  MOVLB  A
4C86:  BCF    x88.7
....................     
....................    i2c_start(); 
4C88:  BSF    F94.4
4C8A:  MOVLW  0A
4C8C:  MOVWF  00
4C8E:  DECFSZ 00,F
4C90:  BRA    4C8E
4C92:  BSF    F94.3
4C94:  MOVLW  0B
4C96:  MOVWF  00
4C98:  DECFSZ 00,F
4C9A:  BRA    4C98
4C9C:  BCF    F8B.4
4C9E:  BCF    F94.4
4CA0:  MOVLW  0A
4CA2:  MOVWF  00
4CA4:  DECFSZ 00,F
4CA6:  BRA    4CA4
4CA8:  BCF    F8B.3
4CAA:  BCF    F94.3
4CAC:  CLRF   19
4CAE:  BTFSC  FF2.7
4CB0:  BSF    19.7
4CB2:  BCF    FF2.7
....................    i2c_write(0xD0); 
4CB4:  MOVLW  D0
4CB6:  MOVLB  B
4CB8:  MOVWF  x09
4CBA:  MOVLB  0
4CBC:  CALL   38DA
4CC0:  BTFSC  19.7
4CC2:  BSF    FF2.7
4CC4:  CLRF   19
4CC6:  BTFSC  FF2.7
4CC8:  BSF    19.7
4CCA:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
4CCC:  MOVLB  B
4CCE:  CLRF   x09
4CD0:  MOVLB  0
4CD2:  CALL   38DA
4CD6:  BTFSC  19.7
4CD8:  BSF    FF2.7
4CDA:  CLRF   19
4CDC:  BTFSC  FF2.7
4CDE:  BSF    19.7
4CE0:  BCF    FF2.7
....................    i2c_write(data); 
4CE2:  MOVFF  A88,B09
4CE6:  CALL   38DA
4CEA:  BTFSC  19.7
4CEC:  BSF    FF2.7
....................    i2c_start(); 
4CEE:  BSF    F94.4
4CF0:  MOVLW  0A
4CF2:  MOVWF  00
4CF4:  DECFSZ 00,F
4CF6:  BRA    4CF4
4CF8:  BSF    F94.3
4CFA:  MOVLW  0B
4CFC:  MOVWF  00
4CFE:  DECFSZ 00,F
4D00:  BRA    4CFE
4D02:  BTFSS  F82.3
4D04:  BRA    4D02
4D06:  BCF    F8B.4
4D08:  BCF    F94.4
4D0A:  MOVLW  0A
4D0C:  MOVWF  00
4D0E:  DECFSZ 00,F
4D10:  BRA    4D0E
4D12:  BCF    F8B.3
4D14:  BCF    F94.3
4D16:  CLRF   19
4D18:  BTFSC  FF2.7
4D1A:  BSF    19.7
4D1C:  BCF    FF2.7
....................    i2c_write(0xD0); 
4D1E:  MOVLW  D0
4D20:  MOVLB  B
4D22:  MOVWF  x09
4D24:  MOVLB  0
4D26:  CALL   38DA
4D2A:  BTFSC  19.7
4D2C:  BSF    FF2.7
4D2E:  CLRF   19
4D30:  BTFSC  FF2.7
4D32:  BSF    19.7
4D34:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
4D36:  MOVLW  07
4D38:  MOVLB  B
4D3A:  MOVWF  x09
4D3C:  MOVLB  0
4D3E:  CALL   38DA
4D42:  BTFSC  19.7
4D44:  BSF    FF2.7
4D46:  CLRF   19
4D48:  BTFSC  FF2.7
4D4A:  BSF    19.7
4D4C:  BCF    FF2.7
....................    i2c_write(0x80); 
4D4E:  MOVLW  80
4D50:  MOVLB  B
4D52:  MOVWF  x09
4D54:  MOVLB  0
4D56:  CALL   38DA
4D5A:  BTFSC  19.7
4D5C:  BSF    FF2.7
....................    i2c_stop(); 
4D5E:  BCF    F94.4
4D60:  NOP   
4D62:  BSF    F94.3
4D64:  BTFSS  F82.3
4D66:  BRA    4D64
4D68:  MOVLW  0A
4D6A:  MOVWF  00
4D6C:  DECFSZ 00,F
4D6E:  BRA    4D6C
4D70:  BRA    4D72
4D72:  NOP   
4D74:  BSF    F94.4
4D76:  MOVLW  0A
4D78:  MOVWF  00
4D7A:  DECFSZ 00,F
4D7C:  BRA    4D7A
.................... } 
4D7E:  GOTO   6F3C (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
56E0:  CLRF   19
56E2:  BTFSC  FF2.7
56E4:  BSF    19.7
56E6:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
56E8:  MOVFF  AC4,AF4
56EC:  MOVLW  0A
56EE:  MOVLB  A
56F0:  MOVWF  xF5
56F2:  MOVLB  0
56F4:  CALL   1AB0
56F8:  BTFSC  19.7
56FA:  BSF    FF2.7
56FC:  MOVFF  01,AC5
....................    nibl=data-(nibh*10); 
5700:  MOVLB  A
5702:  MOVF   xC5,W
5704:  MULLW  0A
5706:  MOVF   FF3,W
5708:  SUBWF  xC4,W
570A:  MOVWF  xC6
....................  
....................    return((nibh<<4)|nibl); 
570C:  SWAPF  xC5,W
570E:  MOVWF  00
5710:  MOVLW  F0
5712:  ANDWF  00,F
5714:  MOVF   00,W
5716:  IORWF  xC6,W
5718:  MOVWF  01
.................... } 
571A:  MOVLB  0
571C:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
3A52:  MOVFF  AED,AEE
....................    data=(i>>4)*10; 
3A56:  MOVLB  A
3A58:  SWAPF  xEE,W
3A5A:  MOVWF  00
3A5C:  MOVLW  0F
3A5E:  ANDWF  00,F
3A60:  MOVF   00,W
3A62:  MULLW  0A
3A64:  MOVFF  FF3,AED
....................    data=data+(i<<4>>4); 
3A68:  SWAPF  xEE,W
3A6A:  MOVWF  00
3A6C:  MOVLW  F0
3A6E:  ANDWF  00,F
3A70:  MOVF   00,W
3A72:  SWAPF  00,F
3A74:  MOVLW  0F
3A76:  ANDWF  00,F
3A78:  MOVF   00,W
3A7A:  ADDWF  xED,F
....................  
....................    return data; 
3A7C:  MOVFF  AED,01
.................... } 
3A80:  MOVLB  0
3A82:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
571E:  MOVLB  A
5720:  CLRF   xC5
5722:  CLRF   xC6
5724:  MOVLB  0
5726:  RCALL  5632
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
5728:  MOVFF  AC3,AC4
572C:  RCALL  56E0
572E:  MOVFF  01,AC4
5732:  MOVLW  01
5734:  MOVLB  A
5736:  MOVWF  xC5
5738:  MOVFF  01,AC6
573C:  MOVLB  0
573E:  RCALL  5632
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
5740:  MOVFF  AC2,AC4
5744:  RCALL  56E0
5746:  MOVFF  01,AC4
574A:  MOVLW  02
574C:  MOVLB  A
574E:  MOVWF  xC5
5750:  MOVFF  01,AC6
5754:  MOVLB  0
5756:  RCALL  5632
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
5758:  MOVFF  AC1,AC4
575C:  RCALL  56E0
575E:  MOVFF  01,AC4
5762:  MOVLW  03
5764:  MOVLB  A
5766:  MOVWF  xC5
5768:  MOVFF  01,AC6
576C:  MOVLB  0
576E:  RCALL  5632
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
5770:  MOVFF  ABE,AC4
5774:  RCALL  56E0
5776:  MOVFF  01,AC4
577A:  MOVLW  04
577C:  MOVLB  A
577E:  MOVWF  xC5
5780:  MOVFF  01,AC6
5784:  MOVLB  0
5786:  RCALL  5632
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
5788:  MOVFF  ABF,AC4
578C:  RCALL  56E0
578E:  MOVFF  01,AC4
5792:  MOVLW  05
5794:  MOVLB  A
5796:  MOVWF  xC5
5798:  MOVFF  01,AC6
579C:  MOVLB  0
579E:  RCALL  5632
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
57A0:  MOVFF  AC0,AC4
57A4:  RCALL  56E0
57A6:  MOVFF  01,AC4
57AA:  MOVLW  06
57AC:  MOVLB  A
57AE:  MOVWF  xC5
57B0:  MOVFF  01,AC6
57B4:  MOVLB  0
57B6:  RCALL  5632
....................    write_DS1307(DS1307_CONTROL,0);    
57B8:  MOVLW  07
57BA:  MOVLB  A
57BC:  MOVWF  xC5
57BE:  CLRF   xC6
57C0:  MOVLB  0
57C2:  RCALL  5632
.................... } 
57C4:  GOTO   63DE (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
4176:  MOVLW  04
4178:  MOVLB  A
417A:  MOVWF  xEC
417C:  MOVLB  0
417E:  RCALL  39BA
4180:  MOVFF  01,AE8
4184:  MOVFF  01,AED
4188:  RCALL  3A52
418A:  MOVFF  01,100
*
5F26:  MOVLW  04
5F28:  MOVLB  A
5F2A:  MOVWF  xEC
5F2C:  MOVLB  0
5F2E:  CALL   39BA
5F32:  MOVFF  01,AE8
5F36:  MOVFF  01,AED
5F3A:  CALL   3A52
5F3E:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
*
418E:  MOVLW  05
4190:  MOVLB  A
4192:  MOVWF  xEC
4194:  MOVLB  0
4196:  RCALL  39BA
4198:  MOVFF  01,AE8
419C:  MOVFF  01,AED
41A0:  RCALL  3A52
41A2:  MOVFF  01,FF
*
5F42:  MOVLW  05
5F44:  MOVLB  A
5F46:  MOVWF  xEC
5F48:  MOVLB  0
5F4A:  CALL   39BA
5F4E:  MOVFF  01,AE8
5F52:  MOVFF  01,AED
5F56:  CALL   3A52
5F5A:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
*
41A6:  MOVLW  06
41A8:  MOVLB  A
41AA:  MOVWF  xEC
41AC:  MOVLB  0
41AE:  RCALL  39BA
41B0:  MOVFF  01,AE8
41B4:  MOVFF  01,AED
41B8:  RCALL  3A52
41BA:  MOVFF  01,FE
*
5F5E:  MOVLW  06
5F60:  MOVLB  A
5F62:  MOVWF  xEC
5F64:  MOVLB  0
5F66:  CALL   39BA
5F6A:  MOVFF  01,AE8
5F6E:  MOVFF  01,AED
5F72:  CALL   3A52
5F76:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
*
41BE:  MOVLW  03
41C0:  MOVLB  A
41C2:  MOVWF  xEC
41C4:  MOVLB  0
41C6:  CALL   39BA
41CA:  MOVFF  01,AE8
41CE:  MOVFF  01,AED
41D2:  RCALL  3A52
41D4:  MOVFF  01,FD
*
5F7A:  MOVLW  03
5F7C:  MOVLB  A
5F7E:  MOVWF  xEC
5F80:  MOVLB  0
5F82:  CALL   39BA
5F86:  MOVFF  01,AE8
5F8A:  MOVFF  01,AED
5F8E:  CALL   3A52
5F92:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
*
41D8:  MOVLW  02
41DA:  MOVLB  A
41DC:  MOVWF  xEC
41DE:  MOVLB  0
41E0:  CALL   39BA
41E4:  MOVFF  01,AE8
41E8:  MOVFF  01,AED
41EC:  RCALL  3A52
41EE:  MOVFF  01,101
*
5F96:  MOVLW  02
5F98:  MOVLB  A
5F9A:  MOVWF  xEC
5F9C:  MOVLB  0
5F9E:  CALL   39BA
5FA2:  MOVFF  01,AE8
5FA6:  MOVFF  01,AED
5FAA:  CALL   3A52
5FAE:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
*
41F2:  MOVLW  01
41F4:  MOVLB  A
41F6:  MOVWF  xEC
41F8:  MOVLB  0
41FA:  CALL   39BA
41FE:  MOVFF  01,AE8
4202:  MOVFF  01,AED
4206:  RCALL  3A52
4208:  MOVFF  01,102
*
5FB2:  MOVLW  01
5FB4:  MOVLB  A
5FB6:  MOVWF  xEC
5FB8:  MOVLB  0
5FBA:  CALL   39BA
5FBE:  MOVFF  01,AE8
5FC2:  MOVFF  01,AED
5FC6:  CALL   3A52
5FCA:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
*
420C:  MOVLB  A
420E:  CLRF   xEC
4210:  MOVLB  0
4212:  CALL   39BA
4216:  MOVFF  01,AE8
421A:  MOVFF  01,AED
421E:  RCALL  3A52
4220:  MOVFF  01,103
*
5FCE:  MOVLB  A
5FD0:  CLRF   xEC
5FD2:  MOVLB  0
5FD4:  CALL   39BA
5FD8:  MOVFF  01,AE8
5FDC:  MOVFF  01,AED
5FE0:  CALL   3A52
5FE4:  MOVFF  01,103
5FE8:  CLRF   19
5FEA:  BTFSC  FF2.7
5FEC:  BSF    19.7
5FEE:  BCF    FF2.7
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... #include <scan_key.c> 
....................  
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                           
.................... char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };                          
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... int8 type_KB=0; 
.................... #define key_numbyte  50 
....................  
.................... int8 key_data[key_numbyte]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
2450:  MOVLB  1
2452:  INCF   x44,F
2454:  MOVF   x44,W
2456:  SUBLW  01
2458:  BTFSC  FD8.0
245A:  BRA    2600
....................        switch (col) { 
245C:  MOVF   x47,W
245E:  ADDLW  FB
2460:  BC    24E4
2462:  ADDLW  05
2464:  MOVLB  0
2466:  GOTO   260A
....................          case 0   :  
....................                     output_low(COL0); 
246A:  BCF    F92.5
246C:  BCF    F89.5
....................                     output_high(COL1); 
246E:  BCF    F92.3
2470:  BSF    F89.3
....................                     output_high(COL2); 
2472:  BCF    F92.2
2474:  BSF    F89.2
....................                     output_high(COL3); 
2476:  BCF    F92.1
2478:  BSF    F89.1
....................                     output_high(COL4); 
247A:  BCF    F92.0
247C:  BSF    F89.0
....................                     break; 
247E:  MOVLB  1
2480:  BRA    24E4
....................          case 1   :  
....................                     output_low(COL1); 
2482:  BCF    F92.3
2484:  BCF    F89.3
....................                     output_high(COL0); 
2486:  BCF    F92.5
2488:  BSF    F89.5
....................                     output_high(COL2); 
248A:  BCF    F92.2
248C:  BSF    F89.2
....................                     output_high(COL3); 
248E:  BCF    F92.1
2490:  BSF    F89.1
....................                     output_high(COL4); 
2492:  BCF    F92.0
2494:  BSF    F89.0
....................                     break; 
2496:  MOVLB  1
2498:  BRA    24E4
....................          case 2   :  
....................                     output_low(COL2); 
249A:  BCF    F92.2
249C:  BCF    F89.2
....................                     output_high(COL1); 
249E:  BCF    F92.3
24A0:  BSF    F89.3
....................                     output_high(COL0); 
24A2:  BCF    F92.5
24A4:  BSF    F89.5
....................                     output_high(COL3); 
24A6:  BCF    F92.1
24A8:  BSF    F89.1
....................                     output_high(COL4); 
24AA:  BCF    F92.0
24AC:  BSF    F89.0
....................                     break; 
24AE:  MOVLB  1
24B0:  BRA    24E4
....................          case 3   :  
....................                     output_low(COL3); 
24B2:  BCF    F92.1
24B4:  BCF    F89.1
....................                     output_high(COL1); 
24B6:  BCF    F92.3
24B8:  BSF    F89.3
....................                     output_high(COL2); 
24BA:  BCF    F92.2
24BC:  BSF    F89.2
....................                     output_high(COL0); 
24BE:  BCF    F92.5
24C0:  BSF    F89.5
....................                     output_high(COL4); 
24C2:  BCF    F92.0
24C4:  BSF    F89.0
....................                     break; 
24C6:  MOVLB  1
24C8:  BRA    24E4
....................          case 4   :  
....................                     output_low(COL4); 
24CA:  BCF    F92.0
24CC:  BCF    F89.0
....................                     output_high(COL1); 
24CE:  BCF    F92.3
24D0:  BSF    F89.3
....................                     output_high(COL2); 
24D2:  BCF    F92.2
24D4:  BSF    F89.2
....................                     output_high(COL3); 
24D6:  BCF    F92.1
24D8:  BSF    F89.1
....................                     output_high(COL0); 
24DA:  BCF    F92.5
24DC:  BSF    F89.5
....................                     break; 
24DE:  MOVLB  1
24E0:  BRA    24E4
24E2:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
24E4:  BTFSS  x45.0
24E6:  BRA    2566
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
24E8:  BSF    F93.4
24EA:  MOVLW  00
24EC:  BTFSC  F81.4
24EE:  MOVLW  01
24F0:  MOVLB  A
24F2:  MOVWF  xE7
24F4:  BSF    F93.5
24F6:  MOVLW  00
24F8:  BTFSC  F81.5
24FA:  MOVLW  01
24FC:  ANDWF  xE7,F
24FE:  BSF    F93.6
2500:  MOVLW  00
2502:  BTFSC  F81.6
2504:  MOVLW  01
2506:  ANDWF  xE7,F
2508:  BSF    F93.7
250A:  MOVLW  00
250C:  BTFSC  F81.7
250E:  MOVLW  01
2510:  ANDWF  xE7,W
2512:  BZ    2562
....................          { 
....................             kchar=last_key; 
2514:  MOVFF  146,AE5
....................             if(keydebug_en==0) 
2518:  MOVLB  1
251A:  MOVF   x08,F
251C:  BNZ   2550
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
251E:  CLRF   x06
2520:  CLRF   x05
....................               charac_timeout=0; 
2522:  MOVLB  0
2524:  CLRF   xFC
2526:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
2528:  MOVLB  1
252A:  MOVF   x0B,W
252C:  SUBLW  31
252E:  BNC   2544
2530:  MOVF   x0B,W
2532:  INCF   x0B,F
2534:  CLRF   03
2536:  ADDLW  11
2538:  MOVWF  FE9
253A:  MOVLW  01
253C:  ADDWFC 03,W
253E:  MOVWF  FEA
2540:  MOVFF  AE5,FEF
....................                fputc(kchar,COM2); 
2544:  MOVFF  AE5,B1A
2548:  MOVLB  0
254A:  CALL   05AA
....................             } 
....................                else fputc(kchar,COM2); 
254E:  BRA    255A
2550:  MOVFF  AE5,B1A
2554:  MOVLB  0
2556:  CALL   05AA
....................            kbd_down=FALSE; 
255A:  MOVLB  1
255C:  BCF    x45.0
....................            last_key=0; 
255E:  CLRF   x46
2560:  MOVLB  A
....................          } 
....................        } else 
2562:  BRA    25FC
2564:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
2566:  BSF    F93.4
2568:  MOVLW  00
256A:  BTFSC  F81.4
256C:  MOVLW  01
256E:  MOVLB  A
2570:  MOVWF  xE7
2572:  BSF    F93.5
2574:  MOVLW  00
2576:  BTFSC  F81.5
2578:  MOVLW  01
257A:  ANDWF  xE7,F
257C:  BSF    F93.6
257E:  MOVLW  00
2580:  BTFSC  F81.6
2582:  MOVLW  01
2584:  ANDWF  xE7,F
2586:  BSF    F93.7
2588:  MOVLW  00
258A:  BTFSC  F81.7
258C:  MOVLW  01
258E:  ANDWF  xE7,W
2590:  BNZ   25F0
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
2592:  BSF    F93.4
2594:  BTFSC  F81.4
2596:  BRA    259C
....................                   row=0; 
2598:  CLRF   xE6
....................                 else if(input(ROW1)==0) 
259A:  BRA    25BE
259C:  BSF    F93.5
259E:  BTFSC  F81.5
25A0:  BRA    25A8
....................                   row=1; 
25A2:  MOVLW  01
25A4:  MOVWF  xE6
....................                 else if(input(ROW2)==0) 
25A6:  BRA    25BE
25A8:  BSF    F93.6
25AA:  BTFSC  F81.6
25AC:  BRA    25B4
....................                   row=2; 
25AE:  MOVLW  02
25B0:  MOVWF  xE6
....................                 else if(input(ROW3)==0) 
25B2:  BRA    25BE
25B4:  BSF    F93.7
25B6:  BTFSC  F81.7
25B8:  BRA    25BE
....................                   row=3; 
25BA:  MOVLW  03
25BC:  MOVWF  xE6
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
25BE:  MOVF   xE6,W
25C0:  MULLW  05
25C2:  MOVF   FF3,W
25C4:  CLRF   xE8
25C6:  MOVWF  xE7
25C8:  CLRF   03
25CA:  MOVLB  1
25CC:  MOVF   x47,W
25CE:  MOVLB  A
25D0:  ADDWF  xE7,W
25D2:  MOVWF  01
25D4:  MOVF   xE8,W
25D6:  ADDWFC 03,F
25D8:  MOVF   01,W
25DA:  MOVLB  0
25DC:  CALL   00E8
25E0:  MOVFF  FE8,146
....................                 kbd_down = TRUE; 
25E4:  MOVLB  1
25E6:  BSF    x45.0
....................                 set_tris_a(0xff); 
25E8:  MOVLW  FF
25EA:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
25EC:  BRA    25FC
25EE:  MOVLB  A
....................                { 
....................                   ++col; 
25F0:  MOVLB  1
25F2:  INCF   x47,F
....................                   if(col==5) col=0; 
25F4:  MOVF   x47,W
25F6:  SUBLW  05
25F8:  BTFSC  FD8.2
25FA:  CLRF   x47
....................                } 
....................          } 
....................       kbd_call_count=0; 
25FC:  MOVLB  1
25FE:  CLRF   x44
....................    } 
....................   return(kchar); 
2600:  MOVLB  A
2602:  MOVFF  AE5,01
.................... } 
2606:  MOVLB  0
2608:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
262E:  MOVLW  E0
2630:  MOVLB  F
2632:  MOVWF  x48
2634:  BCF    FC2.6
2636:  BCF    FC2.7
2638:  MOVF   x49,W
263A:  ANDLW  E0
263C:  IORLW  17
263E:  MOVWF  x49
....................    switch(col) 
....................    { 
2640:  MOVLB  B
2642:  MOVF   x0E,W
2644:  ADDLW  FA
2646:  BC    2712
2648:  ADDLW  06
264A:  MOVLB  0
264C:  GOTO   2716
....................       case 0: 
....................         set_adc_channel(4); 
2650:  MOVLW  10
2652:  MOVWF  01
2654:  MOVF   FC2,W
2656:  ANDLW  C3
2658:  IORWF  01,W
265A:  MOVWF  FC2
....................         adc=read_adc(); 
265C:  BSF    FC2.1
265E:  BTFSC  FC2.1
2660:  BRA    265E
2662:  MOVFF  FC4,B0F
....................         return adc; 
2666:  MOVLB  B
2668:  MOVFF  B0F,01
266C:  BRA    2712
....................       break; 
266E:  BRA    2712
....................       case 1: 
....................         set_adc_channel(3); 
2670:  MOVLW  0C
2672:  MOVWF  01
2674:  MOVF   FC2,W
2676:  ANDLW  C3
2678:  IORWF  01,W
267A:  MOVWF  FC2
....................         adc=read_adc(); 
267C:  BSF    FC2.1
267E:  BTFSC  FC2.1
2680:  BRA    267E
2682:  MOVFF  FC4,B0F
....................         return adc; 
2686:  MOVLB  B
2688:  MOVFF  B0F,01
268C:  BRA    2712
....................       break; 
268E:  BRA    2712
....................       case 2: 
....................         set_adc_channel(2); 
2690:  MOVLW  08
2692:  MOVWF  01
2694:  MOVF   FC2,W
2696:  ANDLW  C3
2698:  IORWF  01,W
269A:  MOVWF  FC2
....................         adc=read_adc(); 
269C:  BSF    FC2.1
269E:  BTFSC  FC2.1
26A0:  BRA    269E
26A2:  MOVFF  FC4,B0F
....................         return adc; 
26A6:  MOVLB  B
26A8:  MOVFF  B0F,01
26AC:  BRA    2712
....................       break; 
26AE:  BRA    2712
....................       case 3: 
....................         set_adc_channel(1); 
26B0:  MOVLW  04
26B2:  MOVWF  01
26B4:  MOVF   FC2,W
26B6:  ANDLW  C3
26B8:  IORWF  01,W
26BA:  MOVWF  FC2
....................         adc=read_adc(); 
26BC:  BSF    FC2.1
26BE:  BTFSC  FC2.1
26C0:  BRA    26BE
26C2:  MOVFF  FC4,B0F
....................         return adc; 
26C6:  MOVLB  B
26C8:  MOVFF  B0F,01
26CC:  BRA    2712
....................       break; 
26CE:  BRA    2712
....................       case 4: 
....................         set_adc_channel(0); 
26D0:  MOVLW  00
26D2:  MOVWF  01
26D4:  MOVF   FC2,W
26D6:  ANDLW  C3
26D8:  IORWF  01,W
26DA:  MOVWF  FC2
....................         adc=read_adc(); 
26DC:  BSF    FC2.1
26DE:  BTFSC  FC2.1
26E0:  BRA    26DE
26E2:  MOVFF  FC4,B0F
....................         return adc; 
26E6:  MOVLB  B
26E8:  MOVFF  B0F,01
26EC:  BRA    2712
....................       break;      
26EE:  BRA    2712
....................       case 5: 
....................         set_adc_channel(11); 
26F0:  MOVLW  2C
26F2:  MOVWF  01
26F4:  MOVF   FC2,W
26F6:  ANDLW  C3
26F8:  IORWF  01,W
26FA:  MOVWF  FC2
....................         adc=read_adc(); 
26FC:  BSF    FC2.1
26FE:  BTFSC  FC2.1
2700:  BRA    26FE
2702:  MOVFF  FC4,B0F
....................         return adc; 
2706:  MOVLB  B
2708:  MOVFF  B0F,01
270C:  BRA    2712
....................       break;      
270E:  BRA    2712
2710:  MOVLB  B
....................    } 
.................... } 
2712:  MOVLB  0
2714:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
2890:  MOVLB  A
2892:  CLRF   xED
2894:  CLRF   xEC
2896:  CLRF   xEB
2898:  CLRF   xEA
289A:  CLRF   xF1
289C:  CLRF   xF0
289E:  CLRF   xEF
28A0:  CLRF   xEE
28A2:  CLRF   xF5
28A4:  CLRF   xF4
28A6:  CLRF   xF3
28A8:  CLRF   xF2
28AA:  CLRF   xF9
28AC:  CLRF   xF8
28AE:  CLRF   xF7
28B0:  CLRF   xF6
28B2:  CLRF   xFD
28B4:  CLRF   xFC
28B6:  CLRF   xFB
28B8:  CLRF   xFA
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
28BA:  CLRF   xE9
28BC:  CLRF   xE8
28BE:  MOVF   xE9,W
28C0:  SUBLW  01
28C2:  BNC   294A
28C4:  BNZ   28CC
28C6:  MOVF   xE8,W
28C8:  SUBLW  F3
28CA:  BNC   294A
....................    { 
....................       col_0=read_col(0)+col_0; 
28CC:  MOVLB  B
28CE:  CLRF   x0E
28D0:  MOVLB  0
28D2:  RCALL  262E
28D4:  MOVF   01,W
28D6:  MOVLB  A
28D8:  ADDWF  xEA,F
28DA:  MOVLW  00
28DC:  ADDWFC xEB,F
28DE:  ADDWFC xEC,F
28E0:  ADDWFC xED,F
....................       col_1=read_col(1)+col_1; 
28E2:  MOVLW  01
28E4:  MOVLB  B
28E6:  MOVWF  x0E
28E8:  MOVLB  0
28EA:  RCALL  262E
28EC:  MOVF   01,W
28EE:  MOVLB  A
28F0:  ADDWF  xEE,F
28F2:  MOVLW  00
28F4:  ADDWFC xEF,F
28F6:  ADDWFC xF0,F
28F8:  ADDWFC xF1,F
....................       col_2=read_col(2)+col_2; 
28FA:  MOVLW  02
28FC:  MOVLB  B
28FE:  MOVWF  x0E
2900:  MOVLB  0
2902:  RCALL  262E
2904:  MOVF   01,W
2906:  MOVLB  A
2908:  ADDWF  xF2,F
290A:  MOVLW  00
290C:  ADDWFC xF3,F
290E:  ADDWFC xF4,F
2910:  ADDWFC xF5,F
....................       col_3=read_col(3)+col_3; 
2912:  MOVLW  03
2914:  MOVLB  B
2916:  MOVWF  x0E
2918:  MOVLB  0
291A:  RCALL  262E
291C:  MOVF   01,W
291E:  MOVLB  A
2920:  ADDWF  xF6,F
2922:  MOVLW  00
2924:  ADDWFC xF7,F
2926:  ADDWFC xF8,F
2928:  ADDWFC xF9,F
....................       col_4=read_col(4)+col_4; 
292A:  MOVLW  04
292C:  MOVLB  B
292E:  MOVWF  x0E
2930:  MOVLB  0
2932:  RCALL  262E
2934:  MOVF   01,W
2936:  MOVLB  A
2938:  ADDWF  xFA,F
293A:  MOVLW  00
293C:  ADDWFC xFB,F
293E:  ADDWFC xFC,F
2940:  ADDWFC xFD,F
....................    } 
2942:  INCF   xE8,F
2944:  BTFSC  FD8.2
2946:  INCF   xE9,F
2948:  BRA    28BE
....................    col_0=col_0/500; 
294A:  BCF    FD8.1
294C:  MOVFF  AED,B1D
2950:  MOVFF  AEC,B1C
2954:  MOVFF  AEB,B1B
2958:  MOVFF  AEA,B1A
295C:  MOVLB  B
295E:  CLRF   x21
2960:  CLRF   x20
2962:  MOVLW  01
2964:  MOVWF  x1F
2966:  MOVLW  F4
2968:  MOVWF  x1E
296A:  MOVLB  0
296C:  RCALL  273C
296E:  MOVFF  03,AED
2972:  MOVFF  02,AEC
2976:  MOVFF  01,AEB
297A:  MOVFF  00,AEA
....................    col_1=col_1/500; 
297E:  BCF    FD8.1
2980:  MOVFF  AF1,B1D
2984:  MOVFF  AF0,B1C
2988:  MOVFF  AEF,B1B
298C:  MOVFF  AEE,B1A
2990:  MOVLB  B
2992:  CLRF   x21
2994:  CLRF   x20
2996:  MOVLW  01
2998:  MOVWF  x1F
299A:  MOVLW  F4
299C:  MOVWF  x1E
299E:  MOVLB  0
29A0:  RCALL  273C
29A2:  MOVFF  03,AF1
29A6:  MOVFF  02,AF0
29AA:  MOVFF  01,AEF
29AE:  MOVFF  00,AEE
....................    col_2=col_2/500; 
29B2:  BCF    FD8.1
29B4:  MOVFF  AF5,B1D
29B8:  MOVFF  AF4,B1C
29BC:  MOVFF  AF3,B1B
29C0:  MOVFF  AF2,B1A
29C4:  MOVLB  B
29C6:  CLRF   x21
29C8:  CLRF   x20
29CA:  MOVLW  01
29CC:  MOVWF  x1F
29CE:  MOVLW  F4
29D0:  MOVWF  x1E
29D2:  MOVLB  0
29D4:  RCALL  273C
29D6:  MOVFF  03,AF5
29DA:  MOVFF  02,AF4
29DE:  MOVFF  01,AF3
29E2:  MOVFF  00,AF2
....................    col_3=col_3/500; 
29E6:  BCF    FD8.1
29E8:  MOVFF  AF9,B1D
29EC:  MOVFF  AF8,B1C
29F0:  MOVFF  AF7,B1B
29F4:  MOVFF  AF6,B1A
29F8:  MOVLB  B
29FA:  CLRF   x21
29FC:  CLRF   x20
29FE:  MOVLW  01
2A00:  MOVWF  x1F
2A02:  MOVLW  F4
2A04:  MOVWF  x1E
2A06:  MOVLB  0
2A08:  RCALL  273C
2A0A:  MOVFF  03,AF9
2A0E:  MOVFF  02,AF8
2A12:  MOVFF  01,AF7
2A16:  MOVFF  00,AF6
....................    col_4=col_4/500; 
2A1A:  BCF    FD8.1
2A1C:  MOVFF  AFD,B1D
2A20:  MOVFF  AFC,B1C
2A24:  MOVFF  AFB,B1B
2A28:  MOVFF  AFA,B1A
2A2C:  MOVLB  B
2A2E:  CLRF   x21
2A30:  CLRF   x20
2A32:  MOVLW  01
2A34:  MOVWF  x1F
2A36:  MOVLW  F4
2A38:  MOVWF  x1E
2A3A:  MOVLB  0
2A3C:  RCALL  273C
2A3E:  MOVFF  03,AFD
2A42:  MOVFF  02,AFC
2A46:  MOVFF  01,AFB
2A4A:  MOVFF  00,AFA
....................    if(keydebug_en) 
2A4E:  MOVLB  1
2A50:  MOVF   x08,F
2A52:  BTFSC  FD8.2
2A54:  BRA    2BD0
....................    { 
....................       fprintf(COM2,"\r\n");      
2A56:  MOVLW  0D
2A58:  MOVLB  B
2A5A:  MOVWF  x1A
2A5C:  MOVLB  0
2A5E:  CALL   05AA
2A62:  MOVLW  0A
2A64:  MOVLB  B
2A66:  MOVWF  x1A
2A68:  MOVLB  0
2A6A:  CALL   05AA
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
2A6E:  MOVLW  96
2A70:  MOVWF  FF6
2A72:  MOVLW  02
2A74:  MOVWF  FF7
2A76:  MOVLW  07
2A78:  MOVLB  B
2A7A:  MOVWF  x0E
2A7C:  MOVLB  0
2A7E:  CALL   19C8
2A82:  MOVLW  41
2A84:  MOVWF  FE9
2A86:  MOVFF  AED,B11
2A8A:  MOVFF  AEC,B10
2A8E:  MOVFF  AEB,B0F
2A92:  MOVFF  AEA,B0E
2A96:  RCALL  27D0
2A98:  MOVLW  0D
2A9A:  MOVLB  B
2A9C:  MOVWF  x1A
2A9E:  MOVLB  0
2AA0:  CALL   05AA
2AA4:  MOVLW  0A
2AA6:  MOVLB  B
2AA8:  MOVWF  x1A
2AAA:  MOVLB  0
2AAC:  CALL   05AA
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2AB0:  MOVLW  A4
2AB2:  MOVWF  FF6
2AB4:  MOVLW  02
2AB6:  MOVWF  FF7
2AB8:  MOVLW  07
2ABA:  MOVLB  B
2ABC:  MOVWF  x0E
2ABE:  MOVLB  0
2AC0:  CALL   19C8
2AC4:  MOVLW  41
2AC6:  MOVWF  FE9
2AC8:  MOVFF  AF1,B11
2ACC:  MOVFF  AF0,B10
2AD0:  MOVFF  AEF,B0F
2AD4:  MOVFF  AEE,B0E
2AD8:  RCALL  27D0
2ADA:  MOVLW  0D
2ADC:  MOVLB  B
2ADE:  MOVWF  x1A
2AE0:  MOVLB  0
2AE2:  CALL   05AA
2AE6:  MOVLW  0A
2AE8:  MOVLB  B
2AEA:  MOVWF  x1A
2AEC:  MOVLB  0
2AEE:  CALL   05AA
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2AF2:  MOVLW  B2
2AF4:  MOVWF  FF6
2AF6:  MOVLW  02
2AF8:  MOVWF  FF7
2AFA:  MOVLW  07
2AFC:  MOVLB  B
2AFE:  MOVWF  x0E
2B00:  MOVLB  0
2B02:  CALL   19C8
2B06:  MOVLW  41
2B08:  MOVWF  FE9
2B0A:  MOVFF  AF5,B11
2B0E:  MOVFF  AF4,B10
2B12:  MOVFF  AF3,B0F
2B16:  MOVFF  AF2,B0E
2B1A:  RCALL  27D0
2B1C:  MOVLW  0D
2B1E:  MOVLB  B
2B20:  MOVWF  x1A
2B22:  MOVLB  0
2B24:  CALL   05AA
2B28:  MOVLW  0A
2B2A:  MOVLB  B
2B2C:  MOVWF  x1A
2B2E:  MOVLB  0
2B30:  CALL   05AA
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2B34:  MOVLW  C0
2B36:  MOVWF  FF6
2B38:  MOVLW  02
2B3A:  MOVWF  FF7
2B3C:  MOVLW  07
2B3E:  MOVLB  B
2B40:  MOVWF  x0E
2B42:  MOVLB  0
2B44:  CALL   19C8
2B48:  MOVLW  41
2B4A:  MOVWF  FE9
2B4C:  MOVFF  AF9,B11
2B50:  MOVFF  AF8,B10
2B54:  MOVFF  AF7,B0F
2B58:  MOVFF  AF6,B0E
2B5C:  RCALL  27D0
2B5E:  MOVLW  0D
2B60:  MOVLB  B
2B62:  MOVWF  x1A
2B64:  MOVLB  0
2B66:  CALL   05AA
2B6A:  MOVLW  0A
2B6C:  MOVLB  B
2B6E:  MOVWF  x1A
2B70:  MOVLB  0
2B72:  CALL   05AA
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2B76:  MOVLW  CE
2B78:  MOVWF  FF6
2B7A:  MOVLW  02
2B7C:  MOVWF  FF7
2B7E:  MOVLW  07
2B80:  MOVLB  B
2B82:  MOVWF  x0E
2B84:  MOVLB  0
2B86:  CALL   19C8
2B8A:  MOVLW  41
2B8C:  MOVWF  FE9
2B8E:  MOVFF  AFD,B11
2B92:  MOVFF  AFC,B10
2B96:  MOVFF  AFB,B0F
2B9A:  MOVFF  AFA,B0E
2B9E:  RCALL  27D0
2BA0:  MOVLW  0D
2BA2:  MOVLB  B
2BA4:  MOVWF  x1A
2BA6:  MOVLB  0
2BA8:  CALL   05AA
2BAC:  MOVLW  0A
2BAE:  MOVLB  B
2BB0:  MOVWF  x1A
2BB2:  MOVLB  0
2BB4:  CALL   05AA
....................       fprintf(COM2,"\r\n"); 
2BB8:  MOVLW  0D
2BBA:  MOVLB  B
2BBC:  MOVWF  x1A
2BBE:  MOVLB  0
2BC0:  CALL   05AA
2BC4:  MOVLW  0A
2BC6:  MOVLB  B
2BC8:  MOVWF  x1A
2BCA:  MOVLB  0
2BCC:  CALL   05AA
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
2BD0:  MOVLB  A
2BD2:  MOVF   xED,F
2BD4:  BNZ   2BE4
2BD6:  MOVF   xEC,F
2BD8:  BNZ   2BE4
2BDA:  MOVF   xEB,F
2BDC:  BNZ   2BE4
2BDE:  MOVF   xEA,W
2BE0:  SUBLW  05
2BE2:  BC    2C44
2BE4:  MOVF   xED,F
2BE6:  BNZ   2C44
2BE8:  MOVF   xEC,F
2BEA:  BNZ   2C44
2BEC:  MOVF   xEB,F
2BEE:  BNZ   2C44
2BF0:  MOVF   xEA,W
2BF2:  SUBLW  3B
2BF4:  BNC   2C44
2BF6:  MOVF   xF1,F
2BF8:  BNZ   2C08
2BFA:  MOVF   xF0,F
2BFC:  BNZ   2C08
2BFE:  MOVF   xEF,F
2C00:  BNZ   2C08
2C02:  MOVF   xEE,W
2C04:  SUBLW  64
2C06:  BC    2C44
2C08:  MOVF   xF5,F
2C0A:  BNZ   2C1A
2C0C:  MOVF   xF4,F
2C0E:  BNZ   2C1A
2C10:  MOVF   xF3,F
2C12:  BNZ   2C1A
2C14:  MOVF   xF2,W
2C16:  SUBLW  64
2C18:  BC    2C44
2C1A:  MOVF   xF9,F
2C1C:  BNZ   2C2C
2C1E:  MOVF   xF8,F
2C20:  BNZ   2C2C
2C22:  MOVF   xF7,F
2C24:  BNZ   2C2C
2C26:  MOVF   xF6,W
2C28:  SUBLW  64
2C2A:  BC    2C44
2C2C:  MOVF   xFD,F
2C2E:  BNZ   2C3E
2C30:  MOVF   xFC,F
2C32:  BNZ   2C3E
2C34:  MOVF   xFB,F
2C36:  BNZ   2C3E
2C38:  MOVF   xFA,W
2C3A:  SUBLW  64
2C3C:  BC    2C44
2C3E:  MOVLW  00
2C40:  MOVWF  01
2C42:  BRA    2EC2
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
2C44:  MOVF   xF1,F
2C46:  BNZ   2C56
2C48:  MOVF   xF0,F
2C4A:  BNZ   2C56
2C4C:  MOVF   xEF,F
2C4E:  BNZ   2C56
2C50:  MOVF   xEE,W
2C52:  SUBLW  05
2C54:  BC    2CB6
2C56:  MOVF   xF1,F
2C58:  BNZ   2CB6
2C5A:  MOVF   xF0,F
2C5C:  BNZ   2CB6
2C5E:  MOVF   xEF,F
2C60:  BNZ   2CB6
2C62:  MOVF   xEE,W
2C64:  SUBLW  3B
2C66:  BNC   2CB6
2C68:  MOVF   xED,F
2C6A:  BNZ   2C7A
2C6C:  MOVF   xEC,F
2C6E:  BNZ   2C7A
2C70:  MOVF   xEB,F
2C72:  BNZ   2C7A
2C74:  MOVF   xEA,W
2C76:  SUBLW  64
2C78:  BC    2CB6
2C7A:  MOVF   xF5,F
2C7C:  BNZ   2C8C
2C7E:  MOVF   xF4,F
2C80:  BNZ   2C8C
2C82:  MOVF   xF3,F
2C84:  BNZ   2C8C
2C86:  MOVF   xF2,W
2C88:  SUBLW  64
2C8A:  BC    2CB6
2C8C:  MOVF   xF9,F
2C8E:  BNZ   2C9E
2C90:  MOVF   xF8,F
2C92:  BNZ   2C9E
2C94:  MOVF   xF7,F
2C96:  BNZ   2C9E
2C98:  MOVF   xF6,W
2C9A:  SUBLW  64
2C9C:  BC    2CB6
2C9E:  MOVF   xFD,F
2CA0:  BNZ   2CB0
2CA2:  MOVF   xFC,F
2CA4:  BNZ   2CB0
2CA6:  MOVF   xFB,F
2CA8:  BNZ   2CB0
2CAA:  MOVF   xFA,W
2CAC:  SUBLW  64
2CAE:  BC    2CB6
2CB0:  MOVLW  01
2CB2:  MOVWF  01
2CB4:  BRA    2EC2
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
2CB6:  MOVF   xF5,F
2CB8:  BNZ   2CC8
2CBA:  MOVF   xF4,F
2CBC:  BNZ   2CC8
2CBE:  MOVF   xF3,F
2CC0:  BNZ   2CC8
2CC2:  MOVF   xF2,W
2CC4:  SUBLW  05
2CC6:  BC    2D28
2CC8:  MOVF   xF5,F
2CCA:  BNZ   2D28
2CCC:  MOVF   xF4,F
2CCE:  BNZ   2D28
2CD0:  MOVF   xF3,F
2CD2:  BNZ   2D28
2CD4:  MOVF   xF2,W
2CD6:  SUBLW  3B
2CD8:  BNC   2D28
2CDA:  MOVF   xF1,F
2CDC:  BNZ   2CEC
2CDE:  MOVF   xF0,F
2CE0:  BNZ   2CEC
2CE2:  MOVF   xEF,F
2CE4:  BNZ   2CEC
2CE6:  MOVF   xEE,W
2CE8:  SUBLW  64
2CEA:  BC    2D28
2CEC:  MOVF   xED,F
2CEE:  BNZ   2CFE
2CF0:  MOVF   xEC,F
2CF2:  BNZ   2CFE
2CF4:  MOVF   xEB,F
2CF6:  BNZ   2CFE
2CF8:  MOVF   xEA,W
2CFA:  SUBLW  64
2CFC:  BC    2D28
2CFE:  MOVF   xF9,F
2D00:  BNZ   2D10
2D02:  MOVF   xF8,F
2D04:  BNZ   2D10
2D06:  MOVF   xF7,F
2D08:  BNZ   2D10
2D0A:  MOVF   xF6,W
2D0C:  SUBLW  64
2D0E:  BC    2D28
2D10:  MOVF   xFD,F
2D12:  BNZ   2D22
2D14:  MOVF   xFC,F
2D16:  BNZ   2D22
2D18:  MOVF   xFB,F
2D1A:  BNZ   2D22
2D1C:  MOVF   xFA,W
2D1E:  SUBLW  64
2D20:  BC    2D28
2D22:  MOVLW  02
2D24:  MOVWF  01
2D26:  BRA    2EC2
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2D28:  MOVF   xF9,F
2D2A:  BNZ   2D3A
2D2C:  MOVF   xF8,F
2D2E:  BNZ   2D3A
2D30:  MOVF   xF7,F
2D32:  BNZ   2D3A
2D34:  MOVF   xF6,W
2D36:  SUBLW  05
2D38:  BC    2D9A
2D3A:  MOVF   xF9,F
2D3C:  BNZ   2D9A
2D3E:  MOVF   xF8,F
2D40:  BNZ   2D9A
2D42:  MOVF   xF7,F
2D44:  BNZ   2D9A
2D46:  MOVF   xF6,W
2D48:  SUBLW  3B
2D4A:  BNC   2D9A
2D4C:  MOVF   xF1,F
2D4E:  BNZ   2D5E
2D50:  MOVF   xF0,F
2D52:  BNZ   2D5E
2D54:  MOVF   xEF,F
2D56:  BNZ   2D5E
2D58:  MOVF   xEE,W
2D5A:  SUBLW  64
2D5C:  BC    2D9A
2D5E:  MOVF   xF5,F
2D60:  BNZ   2D70
2D62:  MOVF   xF4,F
2D64:  BNZ   2D70
2D66:  MOVF   xF3,F
2D68:  BNZ   2D70
2D6A:  MOVF   xF2,W
2D6C:  SUBLW  64
2D6E:  BC    2D9A
2D70:  MOVF   xED,F
2D72:  BNZ   2D82
2D74:  MOVF   xEC,F
2D76:  BNZ   2D82
2D78:  MOVF   xEB,F
2D7A:  BNZ   2D82
2D7C:  MOVF   xEA,W
2D7E:  SUBLW  64
2D80:  BC    2D9A
2D82:  MOVF   xFD,F
2D84:  BNZ   2D94
2D86:  MOVF   xFC,F
2D88:  BNZ   2D94
2D8A:  MOVF   xFB,F
2D8C:  BNZ   2D94
2D8E:  MOVF   xFA,W
2D90:  SUBLW  64
2D92:  BC    2D9A
2D94:  MOVLW  03
2D96:  MOVWF  01
2D98:  BRA    2EC2
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2D9A:  MOVF   xFD,F
2D9C:  BNZ   2DAC
2D9E:  MOVF   xFC,F
2DA0:  BNZ   2DAC
2DA2:  MOVF   xFB,F
2DA4:  BNZ   2DAC
2DA6:  MOVF   xFA,W
2DA8:  SUBLW  05
2DAA:  BC    2E0C
2DAC:  MOVF   xFD,F
2DAE:  BNZ   2E0C
2DB0:  MOVF   xFC,F
2DB2:  BNZ   2E0C
2DB4:  MOVF   xFB,F
2DB6:  BNZ   2E0C
2DB8:  MOVF   xFA,W
2DBA:  SUBLW  3B
2DBC:  BNC   2E0C
2DBE:  MOVF   xF1,F
2DC0:  BNZ   2DD0
2DC2:  MOVF   xF0,F
2DC4:  BNZ   2DD0
2DC6:  MOVF   xEF,F
2DC8:  BNZ   2DD0
2DCA:  MOVF   xEE,W
2DCC:  SUBLW  64
2DCE:  BC    2E0C
2DD0:  MOVF   xF5,F
2DD2:  BNZ   2DE2
2DD4:  MOVF   xF4,F
2DD6:  BNZ   2DE2
2DD8:  MOVF   xF3,F
2DDA:  BNZ   2DE2
2DDC:  MOVF   xF2,W
2DDE:  SUBLW  64
2DE0:  BC    2E0C
2DE2:  MOVF   xF9,F
2DE4:  BNZ   2DF4
2DE6:  MOVF   xF8,F
2DE8:  BNZ   2DF4
2DEA:  MOVF   xF7,F
2DEC:  BNZ   2DF4
2DEE:  MOVF   xF6,W
2DF0:  SUBLW  64
2DF2:  BC    2E0C
2DF4:  MOVF   xED,F
2DF6:  BNZ   2E06
2DF8:  MOVF   xEC,F
2DFA:  BNZ   2E06
2DFC:  MOVF   xEB,F
2DFE:  BNZ   2E06
2E00:  MOVF   xEA,W
2E02:  SUBLW  64
2E04:  BC    2E0C
2E06:  MOVLW  04
2E08:  MOVWF  01
2E0A:  BRA    2EC2
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2E0C:  MOVF   xFD,F
2E0E:  BNZ   2E20
2E10:  MOVF   xFC,F
2E12:  BNZ   2E20
2E14:  MOVF   xFB,F
2E16:  BNZ   2E20
2E18:  MOVF   xFA,W
2E1A:  SUBLW  C8
2E1C:  BTFSC  FD8.0
2E1E:  BRA    2EBE
2E20:  MOVF   xED,F
2E22:  BTFSS  FD8.2
2E24:  BRA    2EBE
2E26:  MOVF   xEC,F
2E28:  BTFSS  FD8.2
2E2A:  BRA    2EBE
2E2C:  MOVF   xEB,F
2E2E:  BTFSS  FD8.2
2E30:  BRA    2EBE
2E32:  MOVF   xEA,W
2E34:  SUBLW  B3
2E36:  BNC   2EBE
2E38:  MOVF   xED,F
2E3A:  BNZ   2E4A
2E3C:  MOVF   xEC,F
2E3E:  BNZ   2E4A
2E40:  MOVF   xEB,F
2E42:  BNZ   2E4A
2E44:  MOVF   xEA,W
2E46:  SUBLW  64
2E48:  BC    2EBE
2E4A:  MOVF   xF1,F
2E4C:  BNZ   2EBE
2E4E:  MOVF   xF0,F
2E50:  BNZ   2EBE
2E52:  MOVF   xEF,F
2E54:  BNZ   2EBE
2E56:  MOVF   xEE,W
2E58:  SUBLW  B3
2E5A:  BNC   2EBE
2E5C:  MOVF   xF1,F
2E5E:  BNZ   2E6E
2E60:  MOVF   xF0,F
2E62:  BNZ   2E6E
2E64:  MOVF   xEF,F
2E66:  BNZ   2E6E
2E68:  MOVF   xEE,W
2E6A:  SUBLW  64
2E6C:  BC    2EBE
2E6E:  MOVF   xF5,F
2E70:  BNZ   2EBE
2E72:  MOVF   xF4,F
2E74:  BNZ   2EBE
2E76:  MOVF   xF3,F
2E78:  BNZ   2EBE
2E7A:  MOVF   xF2,W
2E7C:  SUBLW  B3
2E7E:  BNC   2EBE
2E80:  MOVF   xF5,F
2E82:  BNZ   2E92
2E84:  MOVF   xF4,F
2E86:  BNZ   2E92
2E88:  MOVF   xF3,F
2E8A:  BNZ   2E92
2E8C:  MOVF   xF2,W
2E8E:  SUBLW  64
2E90:  BC    2EBE
2E92:  MOVF   xF9,F
2E94:  BNZ   2EBE
2E96:  MOVF   xF8,F
2E98:  BNZ   2EBE
2E9A:  MOVF   xF7,F
2E9C:  BNZ   2EBE
2E9E:  MOVF   xF6,W
2EA0:  SUBLW  B3
2EA2:  BNC   2EBE
2EA4:  MOVF   xF9,F
2EA6:  BNZ   2EB6
2EA8:  MOVF   xF8,F
2EAA:  BNZ   2EB6
2EAC:  MOVF   xF7,F
2EAE:  BNZ   2EB6
2EB0:  MOVF   xF6,W
2EB2:  SUBLW  64
2EB4:  BC    2EBE
2EB6:  MOVLW  04
2EB8:  MOVWF  01
2EBA:  BRA    2EC2
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2EBC:  BRA    2EC2
2EBE:  MOVLW  FF
2EC0:  MOVWF  01
.................... } 
2EC2:  MOVLB  0
2EC4:  GOTO   37A0 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
2EC8:  MOVLB  A
2ECA:  CLRF   xED
2ECC:  CLRF   xEC
2ECE:  CLRF   xEB
2ED0:  CLRF   xEA
2ED2:  CLRF   xF1
2ED4:  CLRF   xF0
2ED6:  CLRF   xEF
2ED8:  CLRF   xEE
2EDA:  CLRF   xF5
2EDC:  CLRF   xF4
2EDE:  CLRF   xF3
2EE0:  CLRF   xF2
2EE2:  CLRF   xF9
2EE4:  CLRF   xF8
2EE6:  CLRF   xF7
2EE8:  CLRF   xF6
2EEA:  CLRF   xFD
2EEC:  CLRF   xFC
2EEE:  CLRF   xFB
2EF0:  CLRF   xFA
2EF2:  MOVLB  B
2EF4:  CLRF   x01
2EF6:  CLRF   x00
2EF8:  MOVLB  A
2EFA:  CLRF   xFF
2EFC:  CLRF   xFE
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2EFE:  CLRF   xE9
2F00:  CLRF   xE8
2F02:  MOVF   xE9,W
2F04:  SUBLW  01
2F06:  BNC   2FB6
2F08:  BNZ   2F10
2F0A:  MOVF   xE8,W
2F0C:  SUBLW  F3
2F0E:  BNC   2FB6
....................    { 
....................       col_0=read_col(0)+col_0; 
2F10:  MOVLB  B
2F12:  CLRF   x0E
2F14:  MOVLB  0
2F16:  CALL   262E
2F1A:  MOVF   01,W
2F1C:  MOVLB  A
2F1E:  ADDWF  xEA,F
2F20:  MOVLW  00
2F22:  ADDWFC xEB,F
2F24:  ADDWFC xEC,F
2F26:  ADDWFC xED,F
....................       col_1=read_col(1)+col_1; 
2F28:  MOVLW  01
2F2A:  MOVLB  B
2F2C:  MOVWF  x0E
2F2E:  MOVLB  0
2F30:  CALL   262E
2F34:  MOVF   01,W
2F36:  MOVLB  A
2F38:  ADDWF  xEE,F
2F3A:  MOVLW  00
2F3C:  ADDWFC xEF,F
2F3E:  ADDWFC xF0,F
2F40:  ADDWFC xF1,F
....................       col_2=read_col(2)+col_2; 
2F42:  MOVLW  02
2F44:  MOVLB  B
2F46:  MOVWF  x0E
2F48:  MOVLB  0
2F4A:  CALL   262E
2F4E:  MOVF   01,W
2F50:  MOVLB  A
2F52:  ADDWF  xF2,F
2F54:  MOVLW  00
2F56:  ADDWFC xF3,F
2F58:  ADDWFC xF4,F
2F5A:  ADDWFC xF5,F
....................       col_3=read_col(3)+col_3; 
2F5C:  MOVLW  03
2F5E:  MOVLB  B
2F60:  MOVWF  x0E
2F62:  MOVLB  0
2F64:  CALL   262E
2F68:  MOVF   01,W
2F6A:  MOVLB  A
2F6C:  ADDWF  xF6,F
2F6E:  MOVLW  00
2F70:  ADDWFC xF7,F
2F72:  ADDWFC xF8,F
2F74:  ADDWFC xF9,F
....................       col_4=read_col(4)+col_4; 
2F76:  MOVLW  04
2F78:  MOVLB  B
2F7A:  MOVWF  x0E
2F7C:  MOVLB  0
2F7E:  CALL   262E
2F82:  MOVF   01,W
2F84:  MOVLB  A
2F86:  ADDWF  xFA,F
2F88:  MOVLW  00
2F8A:  ADDWFC xFB,F
2F8C:  ADDWFC xFC,F
2F8E:  ADDWFC xFD,F
....................       col_5=read_col(5)+col_5; 
2F90:  MOVLW  05
2F92:  MOVLB  B
2F94:  MOVWF  x0E
2F96:  MOVLB  0
2F98:  CALL   262E
2F9C:  MOVF   01,W
2F9E:  MOVLB  A
2FA0:  ADDWF  xFE,F
2FA2:  MOVLW  00
2FA4:  ADDWFC xFF,F
2FA6:  MOVLB  B
2FA8:  ADDWFC x00,F
2FAA:  ADDWFC x01,F
....................    } 
2FAC:  MOVLB  A
2FAE:  INCF   xE8,F
2FB0:  BTFSC  FD8.2
2FB2:  INCF   xE9,F
2FB4:  BRA    2F02
....................    col_0=col_0/500; 
2FB6:  BCF    FD8.1
2FB8:  MOVFF  AED,B1D
2FBC:  MOVFF  AEC,B1C
2FC0:  MOVFF  AEB,B1B
2FC4:  MOVFF  AEA,B1A
2FC8:  MOVLB  B
2FCA:  CLRF   x21
2FCC:  CLRF   x20
2FCE:  MOVLW  01
2FD0:  MOVWF  x1F
2FD2:  MOVLW  F4
2FD4:  MOVWF  x1E
2FD6:  MOVLB  0
2FD8:  CALL   273C
2FDC:  MOVFF  03,AED
2FE0:  MOVFF  02,AEC
2FE4:  MOVFF  01,AEB
2FE8:  MOVFF  00,AEA
....................    col_1=col_1/500; 
2FEC:  BCF    FD8.1
2FEE:  MOVFF  AF1,B1D
2FF2:  MOVFF  AF0,B1C
2FF6:  MOVFF  AEF,B1B
2FFA:  MOVFF  AEE,B1A
2FFE:  MOVLB  B
3000:  CLRF   x21
3002:  CLRF   x20
3004:  MOVLW  01
3006:  MOVWF  x1F
3008:  MOVLW  F4
300A:  MOVWF  x1E
300C:  MOVLB  0
300E:  CALL   273C
3012:  MOVFF  03,AF1
3016:  MOVFF  02,AF0
301A:  MOVFF  01,AEF
301E:  MOVFF  00,AEE
....................    col_2=col_2/500; 
3022:  BCF    FD8.1
3024:  MOVFF  AF5,B1D
3028:  MOVFF  AF4,B1C
302C:  MOVFF  AF3,B1B
3030:  MOVFF  AF2,B1A
3034:  MOVLB  B
3036:  CLRF   x21
3038:  CLRF   x20
303A:  MOVLW  01
303C:  MOVWF  x1F
303E:  MOVLW  F4
3040:  MOVWF  x1E
3042:  MOVLB  0
3044:  CALL   273C
3048:  MOVFF  03,AF5
304C:  MOVFF  02,AF4
3050:  MOVFF  01,AF3
3054:  MOVFF  00,AF2
....................    col_3=col_3/500; 
3058:  BCF    FD8.1
305A:  MOVFF  AF9,B1D
305E:  MOVFF  AF8,B1C
3062:  MOVFF  AF7,B1B
3066:  MOVFF  AF6,B1A
306A:  MOVLB  B
306C:  CLRF   x21
306E:  CLRF   x20
3070:  MOVLW  01
3072:  MOVWF  x1F
3074:  MOVLW  F4
3076:  MOVWF  x1E
3078:  MOVLB  0
307A:  CALL   273C
307E:  MOVFF  03,AF9
3082:  MOVFF  02,AF8
3086:  MOVFF  01,AF7
308A:  MOVFF  00,AF6
....................    col_4=col_4/500; 
308E:  BCF    FD8.1
3090:  MOVFF  AFD,B1D
3094:  MOVFF  AFC,B1C
3098:  MOVFF  AFB,B1B
309C:  MOVFF  AFA,B1A
30A0:  MOVLB  B
30A2:  CLRF   x21
30A4:  CLRF   x20
30A6:  MOVLW  01
30A8:  MOVWF  x1F
30AA:  MOVLW  F4
30AC:  MOVWF  x1E
30AE:  MOVLB  0
30B0:  CALL   273C
30B4:  MOVFF  03,AFD
30B8:  MOVFF  02,AFC
30BC:  MOVFF  01,AFB
30C0:  MOVFF  00,AFA
....................    col_5=col_5/500; 
30C4:  BCF    FD8.1
30C6:  MOVFF  B01,B1D
30CA:  MOVFF  B00,B1C
30CE:  MOVFF  AFF,B1B
30D2:  MOVFF  AFE,B1A
30D6:  MOVLB  B
30D8:  CLRF   x21
30DA:  CLRF   x20
30DC:  MOVLW  01
30DE:  MOVWF  x1F
30E0:  MOVLW  F4
30E2:  MOVWF  x1E
30E4:  MOVLB  0
30E6:  CALL   273C
30EA:  MOVFF  03,B01
30EE:  MOVFF  02,B00
30F2:  MOVFF  01,AFF
30F6:  MOVFF  00,AFE
....................    if(keydebug_en) 
30FA:  MOVLB  1
30FC:  MOVF   x08,F
30FE:  BTFSC  FD8.2
3100:  BRA    32CA
....................    { 
....................       fprintf(COM2,"\r\n");      
3102:  MOVLW  0D
3104:  MOVLB  B
3106:  MOVWF  x1A
3108:  MOVLB  0
310A:  CALL   05AA
310E:  MOVLW  0A
3110:  MOVLB  B
3112:  MOVWF  x1A
3114:  MOVLB  0
3116:  CALL   05AA
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
311A:  MOVLW  DC
311C:  MOVWF  FF6
311E:  MOVLW  02
3120:  MOVWF  FF7
3122:  MOVLW  07
3124:  MOVLB  B
3126:  MOVWF  x0E
3128:  MOVLB  0
312A:  CALL   19C8
312E:  MOVLW  41
3130:  MOVWF  FE9
3132:  MOVFF  AED,B11
3136:  MOVFF  AEC,B10
313A:  MOVFF  AEB,B0F
313E:  MOVFF  AEA,B0E
3142:  CALL   27D0
3146:  MOVLW  0D
3148:  MOVLB  B
314A:  MOVWF  x1A
314C:  MOVLB  0
314E:  CALL   05AA
3152:  MOVLW  0A
3154:  MOVLB  B
3156:  MOVWF  x1A
3158:  MOVLB  0
315A:  CALL   05AA
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
315E:  MOVLW  EA
3160:  MOVWF  FF6
3162:  MOVLW  02
3164:  MOVWF  FF7
3166:  MOVLW  07
3168:  MOVLB  B
316A:  MOVWF  x0E
316C:  MOVLB  0
316E:  CALL   19C8
3172:  MOVLW  41
3174:  MOVWF  FE9
3176:  MOVFF  AF1,B11
317A:  MOVFF  AF0,B10
317E:  MOVFF  AEF,B0F
3182:  MOVFF  AEE,B0E
3186:  CALL   27D0
318A:  MOVLW  0D
318C:  MOVLB  B
318E:  MOVWF  x1A
3190:  MOVLB  0
3192:  CALL   05AA
3196:  MOVLW  0A
3198:  MOVLB  B
319A:  MOVWF  x1A
319C:  MOVLB  0
319E:  CALL   05AA
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
31A2:  MOVLW  F8
31A4:  MOVWF  FF6
31A6:  MOVLW  02
31A8:  MOVWF  FF7
31AA:  MOVLW  07
31AC:  MOVLB  B
31AE:  MOVWF  x0E
31B0:  MOVLB  0
31B2:  CALL   19C8
31B6:  MOVLW  41
31B8:  MOVWF  FE9
31BA:  MOVFF  AF5,B11
31BE:  MOVFF  AF4,B10
31C2:  MOVFF  AF3,B0F
31C6:  MOVFF  AF2,B0E
31CA:  CALL   27D0
31CE:  MOVLW  0D
31D0:  MOVLB  B
31D2:  MOVWF  x1A
31D4:  MOVLB  0
31D6:  CALL   05AA
31DA:  MOVLW  0A
31DC:  MOVLB  B
31DE:  MOVWF  x1A
31E0:  MOVLB  0
31E2:  CALL   05AA
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
31E6:  MOVLW  06
31E8:  MOVWF  FF6
31EA:  MOVLW  03
31EC:  MOVWF  FF7
31EE:  MOVLW  07
31F0:  MOVLB  B
31F2:  MOVWF  x0E
31F4:  MOVLB  0
31F6:  CALL   19C8
31FA:  MOVLW  41
31FC:  MOVWF  FE9
31FE:  MOVFF  AF9,B11
3202:  MOVFF  AF8,B10
3206:  MOVFF  AF7,B0F
320A:  MOVFF  AF6,B0E
320E:  CALL   27D0
3212:  MOVLW  0D
3214:  MOVLB  B
3216:  MOVWF  x1A
3218:  MOVLB  0
321A:  CALL   05AA
321E:  MOVLW  0A
3220:  MOVLB  B
3222:  MOVWF  x1A
3224:  MOVLB  0
3226:  CALL   05AA
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
322A:  MOVLW  14
322C:  MOVWF  FF6
322E:  MOVLW  03
3230:  MOVWF  FF7
3232:  MOVLW  07
3234:  MOVLB  B
3236:  MOVWF  x0E
3238:  MOVLB  0
323A:  CALL   19C8
323E:  MOVLW  41
3240:  MOVWF  FE9
3242:  MOVFF  AFD,B11
3246:  MOVFF  AFC,B10
324A:  MOVFF  AFB,B0F
324E:  MOVFF  AFA,B0E
3252:  CALL   27D0
3256:  MOVLW  0D
3258:  MOVLB  B
325A:  MOVWF  x1A
325C:  MOVLB  0
325E:  CALL   05AA
3262:  MOVLW  0A
3264:  MOVLB  B
3266:  MOVWF  x1A
3268:  MOVLB  0
326A:  CALL   05AA
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
326E:  MOVLW  22
3270:  MOVWF  FF6
3272:  MOVLW  03
3274:  MOVWF  FF7
3276:  MOVLW  07
3278:  MOVLB  B
327A:  MOVWF  x0E
327C:  MOVLB  0
327E:  CALL   19C8
3282:  MOVLW  41
3284:  MOVWF  FE9
3286:  MOVFF  B01,B11
328A:  MOVFF  B00,B10
328E:  MOVFF  AFF,B0F
3292:  MOVFF  AFE,B0E
3296:  CALL   27D0
329A:  MOVLW  0D
329C:  MOVLB  B
329E:  MOVWF  x1A
32A0:  MOVLB  0
32A2:  CALL   05AA
32A6:  MOVLW  0A
32A8:  MOVLB  B
32AA:  MOVWF  x1A
32AC:  MOVLB  0
32AE:  CALL   05AA
....................       fprintf(COM2,"\r\n"); 
32B2:  MOVLW  0D
32B4:  MOVLB  B
32B6:  MOVWF  x1A
32B8:  MOVLB  0
32BA:  CALL   05AA
32BE:  MOVLW  0A
32C0:  MOVLB  B
32C2:  MOVWF  x1A
32C4:  MOVLB  0
32C6:  CALL   05AA
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
32CA:  MOVLB  A
32CC:  MOVF   xED,F
32CE:  BNZ   32DE
32D0:  MOVF   xEC,F
32D2:  BNZ   32DE
32D4:  MOVF   xEB,F
32D6:  BNZ   32DE
32D8:  MOVF   xEA,W
32DA:  SUBLW  05
32DC:  BC    335E
32DE:  MOVF   xED,F
32E0:  BNZ   335E
32E2:  MOVF   xEC,F
32E4:  BNZ   335E
32E6:  MOVF   xEB,F
32E8:  BNZ   335E
32EA:  MOVF   xEA,W
32EC:  SUBLW  3B
32EE:  BNC   335E
32F0:  MOVF   xF1,F
32F2:  BNZ   3302
32F4:  MOVF   xF0,F
32F6:  BNZ   3302
32F8:  MOVF   xEF,F
32FA:  BNZ   3302
32FC:  MOVF   xEE,W
32FE:  SUBLW  64
3300:  BC    335E
3302:  MOVF   xF5,F
3304:  BNZ   3314
3306:  MOVF   xF4,F
3308:  BNZ   3314
330A:  MOVF   xF3,F
330C:  BNZ   3314
330E:  MOVF   xF2,W
3310:  SUBLW  64
3312:  BC    335E
3314:  MOVF   xF9,F
3316:  BNZ   3326
3318:  MOVF   xF8,F
331A:  BNZ   3326
331C:  MOVF   xF7,F
331E:  BNZ   3326
3320:  MOVF   xF6,W
3322:  SUBLW  64
3324:  BC    335E
3326:  MOVF   xFD,F
3328:  BNZ   3338
332A:  MOVF   xFC,F
332C:  BNZ   3338
332E:  MOVF   xFB,F
3330:  BNZ   3338
3332:  MOVF   xFA,W
3334:  SUBLW  64
3336:  BC    335E
3338:  MOVLB  B
333A:  MOVF   x01,F
333C:  BNZ   3356
333E:  MOVF   x00,F
3340:  BNZ   3356
3342:  MOVLB  A
3344:  MOVF   xFF,F
3346:  BTFSC  FD8.2
3348:  BRA    334E
334A:  MOVLB  B
334C:  BRA    3356
334E:  MOVF   xFE,W
3350:  SUBLW  64
3352:  BC    335E
3354:  MOVLB  B
3356:  MOVLW  00
3358:  MOVWF  01
335A:  BRA    373C
335C:  MOVLB  A
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
335E:  MOVF   xF1,F
3360:  BNZ   3370
3362:  MOVF   xF0,F
3364:  BNZ   3370
3366:  MOVF   xEF,F
3368:  BNZ   3370
336A:  MOVF   xEE,W
336C:  SUBLW  05
336E:  BC    33F0
3370:  MOVF   xF1,F
3372:  BNZ   33F0
3374:  MOVF   xF0,F
3376:  BNZ   33F0
3378:  MOVF   xEF,F
337A:  BNZ   33F0
337C:  MOVF   xEE,W
337E:  SUBLW  3B
3380:  BNC   33F0
3382:  MOVF   xED,F
3384:  BNZ   3394
3386:  MOVF   xEC,F
3388:  BNZ   3394
338A:  MOVF   xEB,F
338C:  BNZ   3394
338E:  MOVF   xEA,W
3390:  SUBLW  64
3392:  BC    33F0
3394:  MOVF   xF5,F
3396:  BNZ   33A6
3398:  MOVF   xF4,F
339A:  BNZ   33A6
339C:  MOVF   xF3,F
339E:  BNZ   33A6
33A0:  MOVF   xF2,W
33A2:  SUBLW  64
33A4:  BC    33F0
33A6:  MOVF   xF9,F
33A8:  BNZ   33B8
33AA:  MOVF   xF8,F
33AC:  BNZ   33B8
33AE:  MOVF   xF7,F
33B0:  BNZ   33B8
33B2:  MOVF   xF6,W
33B4:  SUBLW  64
33B6:  BC    33F0
33B8:  MOVF   xFD,F
33BA:  BNZ   33CA
33BC:  MOVF   xFC,F
33BE:  BNZ   33CA
33C0:  MOVF   xFB,F
33C2:  BNZ   33CA
33C4:  MOVF   xFA,W
33C6:  SUBLW  64
33C8:  BC    33F0
33CA:  MOVLB  B
33CC:  MOVF   x01,F
33CE:  BNZ   33E8
33D0:  MOVF   x00,F
33D2:  BNZ   33E8
33D4:  MOVLB  A
33D6:  MOVF   xFF,F
33D8:  BTFSC  FD8.2
33DA:  BRA    33E0
33DC:  MOVLB  B
33DE:  BRA    33E8
33E0:  MOVF   xFE,W
33E2:  SUBLW  64
33E4:  BC    33F0
33E6:  MOVLB  B
33E8:  MOVLW  01
33EA:  MOVWF  01
33EC:  BRA    373C
33EE:  MOVLB  A
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
33F0:  MOVF   xF5,F
33F2:  BNZ   3402
33F4:  MOVF   xF4,F
33F6:  BNZ   3402
33F8:  MOVF   xF3,F
33FA:  BNZ   3402
33FC:  MOVF   xF2,W
33FE:  SUBLW  05
3400:  BC    3482
3402:  MOVF   xF5,F
3404:  BNZ   3482
3406:  MOVF   xF4,F
3408:  BNZ   3482
340A:  MOVF   xF3,F
340C:  BNZ   3482
340E:  MOVF   xF2,W
3410:  SUBLW  3B
3412:  BNC   3482
3414:  MOVF   xF1,F
3416:  BNZ   3426
3418:  MOVF   xF0,F
341A:  BNZ   3426
341C:  MOVF   xEF,F
341E:  BNZ   3426
3420:  MOVF   xEE,W
3422:  SUBLW  64
3424:  BC    3482
3426:  MOVF   xED,F
3428:  BNZ   3438
342A:  MOVF   xEC,F
342C:  BNZ   3438
342E:  MOVF   xEB,F
3430:  BNZ   3438
3432:  MOVF   xEA,W
3434:  SUBLW  64
3436:  BC    3482
3438:  MOVF   xF9,F
343A:  BNZ   344A
343C:  MOVF   xF8,F
343E:  BNZ   344A
3440:  MOVF   xF7,F
3442:  BNZ   344A
3444:  MOVF   xF6,W
3446:  SUBLW  64
3448:  BC    3482
344A:  MOVF   xFD,F
344C:  BNZ   345C
344E:  MOVF   xFC,F
3450:  BNZ   345C
3452:  MOVF   xFB,F
3454:  BNZ   345C
3456:  MOVF   xFA,W
3458:  SUBLW  64
345A:  BC    3482
345C:  MOVLB  B
345E:  MOVF   x01,F
3460:  BNZ   347A
3462:  MOVF   x00,F
3464:  BNZ   347A
3466:  MOVLB  A
3468:  MOVF   xFF,F
346A:  BTFSC  FD8.2
346C:  BRA    3472
346E:  MOVLB  B
3470:  BRA    347A
3472:  MOVF   xFE,W
3474:  SUBLW  64
3476:  BC    3482
3478:  MOVLB  B
347A:  MOVLW  02
347C:  MOVWF  01
347E:  BRA    373C
3480:  MOVLB  A
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
3482:  MOVF   xF9,F
3484:  BNZ   3494
3486:  MOVF   xF8,F
3488:  BNZ   3494
348A:  MOVF   xF7,F
348C:  BNZ   3494
348E:  MOVF   xF6,W
3490:  SUBLW  05
3492:  BC    3514
3494:  MOVF   xF9,F
3496:  BNZ   3514
3498:  MOVF   xF8,F
349A:  BNZ   3514
349C:  MOVF   xF7,F
349E:  BNZ   3514
34A0:  MOVF   xF6,W
34A2:  SUBLW  3B
34A4:  BNC   3514
34A6:  MOVF   xF1,F
34A8:  BNZ   34B8
34AA:  MOVF   xF0,F
34AC:  BNZ   34B8
34AE:  MOVF   xEF,F
34B0:  BNZ   34B8
34B2:  MOVF   xEE,W
34B4:  SUBLW  64
34B6:  BC    3514
34B8:  MOVF   xF5,F
34BA:  BNZ   34CA
34BC:  MOVF   xF4,F
34BE:  BNZ   34CA
34C0:  MOVF   xF3,F
34C2:  BNZ   34CA
34C4:  MOVF   xF2,W
34C6:  SUBLW  64
34C8:  BC    3514
34CA:  MOVF   xED,F
34CC:  BNZ   34DC
34CE:  MOVF   xEC,F
34D0:  BNZ   34DC
34D2:  MOVF   xEB,F
34D4:  BNZ   34DC
34D6:  MOVF   xEA,W
34D8:  SUBLW  64
34DA:  BC    3514
34DC:  MOVF   xFD,F
34DE:  BNZ   34EE
34E0:  MOVF   xFC,F
34E2:  BNZ   34EE
34E4:  MOVF   xFB,F
34E6:  BNZ   34EE
34E8:  MOVF   xFA,W
34EA:  SUBLW  64
34EC:  BC    3514
34EE:  MOVLB  B
34F0:  MOVF   x01,F
34F2:  BNZ   350C
34F4:  MOVF   x00,F
34F6:  BNZ   350C
34F8:  MOVLB  A
34FA:  MOVF   xFF,F
34FC:  BTFSC  FD8.2
34FE:  BRA    3504
3500:  MOVLB  B
3502:  BRA    350C
3504:  MOVF   xFE,W
3506:  SUBLW  64
3508:  BC    3514
350A:  MOVLB  B
350C:  MOVLW  03
350E:  MOVWF  01
3510:  BRA    373C
3512:  MOVLB  A
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
3514:  MOVF   xFD,F
3516:  BNZ   3526
3518:  MOVF   xFC,F
351A:  BNZ   3526
351C:  MOVF   xFB,F
351E:  BNZ   3526
3520:  MOVF   xFA,W
3522:  SUBLW  05
3524:  BC    35A4
3526:  MOVF   xFD,F
3528:  BNZ   35A4
352A:  MOVF   xFC,F
352C:  BNZ   35A4
352E:  MOVF   xFB,F
3530:  BNZ   35A4
3532:  MOVF   xFA,W
3534:  SUBLW  3B
3536:  BNC   35A4
3538:  MOVF   xF1,F
353A:  BNZ   354A
353C:  MOVF   xF0,F
353E:  BNZ   354A
3540:  MOVF   xEF,F
3542:  BNZ   354A
3544:  MOVF   xEE,W
3546:  SUBLW  64
3548:  BC    35A4
354A:  MOVF   xF5,F
354C:  BNZ   355C
354E:  MOVF   xF4,F
3550:  BNZ   355C
3552:  MOVF   xF3,F
3554:  BNZ   355C
3556:  MOVF   xF2,W
3558:  SUBLW  64
355A:  BC    35A4
355C:  MOVF   xF9,F
355E:  BNZ   356E
3560:  MOVF   xF8,F
3562:  BNZ   356E
3564:  MOVF   xF7,F
3566:  BNZ   356E
3568:  MOVF   xF6,W
356A:  SUBLW  64
356C:  BC    35A4
356E:  MOVF   xED,F
3570:  BNZ   3580
3572:  MOVF   xEC,F
3574:  BNZ   3580
3576:  MOVF   xEB,F
3578:  BNZ   3580
357A:  MOVF   xEA,W
357C:  SUBLW  64
357E:  BC    35A4
3580:  MOVLB  B
3582:  MOVF   x01,F
3584:  BNZ   359E
3586:  MOVF   x00,F
3588:  BNZ   359E
358A:  MOVLB  A
358C:  MOVF   xFF,F
358E:  BTFSC  FD8.2
3590:  BRA    3596
3592:  MOVLB  B
3594:  BRA    359E
3596:  MOVF   xFE,W
3598:  SUBLW  64
359A:  BC    35A4
359C:  MOVLB  B
359E:  MOVLW  04
35A0:  MOVWF  01
35A2:  BRA    373C
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
35A4:  MOVLB  B
35A6:  MOVF   x01,F
35A8:  BNZ   35C2
35AA:  MOVF   x00,F
35AC:  BNZ   35C2
35AE:  MOVLB  A
35B0:  MOVF   xFF,F
35B2:  BTFSC  FD8.2
35B4:  BRA    35BA
35B6:  MOVLB  B
35B8:  BRA    35C2
35BA:  MOVF   xFE,W
35BC:  SUBLW  05
35BE:  BC    3644
35C0:  MOVLB  B
35C2:  MOVF   x01,F
35C4:  BTFSC  FD8.2
35C6:  BRA    35CC
35C8:  MOVLB  A
35CA:  BRA    3644
35CC:  MOVF   x00,F
35CE:  BTFSC  FD8.2
35D0:  BRA    35D6
35D2:  MOVLB  A
35D4:  BRA    3644
35D6:  MOVLB  A
35D8:  MOVF   xFF,F
35DA:  BNZ   3644
35DC:  MOVF   xFE,W
35DE:  SUBLW  3B
35E0:  BNC   3644
35E2:  MOVF   xF1,F
35E4:  BNZ   35F4
35E6:  MOVF   xF0,F
35E8:  BNZ   35F4
35EA:  MOVF   xEF,F
35EC:  BNZ   35F4
35EE:  MOVF   xEE,W
35F0:  SUBLW  64
35F2:  BC    3644
35F4:  MOVF   xF5,F
35F6:  BNZ   3606
35F8:  MOVF   xF4,F
35FA:  BNZ   3606
35FC:  MOVF   xF3,F
35FE:  BNZ   3606
3600:  MOVF   xF2,W
3602:  SUBLW  64
3604:  BC    3644
3606:  MOVF   xF9,F
3608:  BNZ   3618
360A:  MOVF   xF8,F
360C:  BNZ   3618
360E:  MOVF   xF7,F
3610:  BNZ   3618
3612:  MOVF   xF6,W
3614:  SUBLW  64
3616:  BC    3644
3618:  MOVF   xFD,F
361A:  BNZ   362A
361C:  MOVF   xFC,F
361E:  BNZ   362A
3620:  MOVF   xFB,F
3622:  BNZ   362A
3624:  MOVF   xFA,W
3626:  SUBLW  64
3628:  BC    3644
362A:  MOVF   xED,F
362C:  BNZ   363C
362E:  MOVF   xEC,F
3630:  BNZ   363C
3632:  MOVF   xEB,F
3634:  BNZ   363C
3636:  MOVF   xEA,W
3638:  SUBLW  64
363A:  BC    3644
363C:  MOVLW  05
363E:  MOVWF  01
3640:  MOVLB  B
3642:  BRA    373C
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
3644:  MOVLB  B
3646:  MOVF   x01,F
3648:  BNZ   3662
364A:  MOVF   x00,F
364C:  BNZ   3662
364E:  MOVLB  A
3650:  MOVF   xFF,F
3652:  BTFSC  FD8.2
3654:  BRA    365A
3656:  MOVLB  B
3658:  BRA    3662
365A:  MOVF   xFE,W
365C:  SUBLW  C8
365E:  BTFSC  FD8.0
3660:  BRA    3736
3662:  MOVLB  A
3664:  MOVF   xED,F
3666:  BTFSS  FD8.2
3668:  BRA    3736
366A:  MOVF   xEC,F
366C:  BTFSS  FD8.2
366E:  BRA    3736
3670:  MOVF   xEB,F
3672:  BTFSS  FD8.2
3674:  BRA    3736
3676:  MOVF   xEA,W
3678:  SUBLW  B3
367A:  BTFSS  FD8.0
367C:  BRA    3736
367E:  MOVF   xED,F
3680:  BNZ   3692
3682:  MOVF   xEC,F
3684:  BNZ   3692
3686:  MOVF   xEB,F
3688:  BNZ   3692
368A:  MOVF   xEA,W
368C:  SUBLW  64
368E:  BTFSC  FD8.0
3690:  BRA    3736
3692:  MOVF   xF1,F
3694:  BTFSS  FD8.2
3696:  BRA    3736
3698:  MOVF   xF0,F
369A:  BTFSS  FD8.2
369C:  BRA    3736
369E:  MOVF   xEF,F
36A0:  BTFSS  FD8.2
36A2:  BRA    3736
36A4:  MOVF   xEE,W
36A6:  SUBLW  B3
36A8:  BTFSS  FD8.0
36AA:  BRA    3736
36AC:  MOVF   xF1,F
36AE:  BNZ   36BE
36B0:  MOVF   xF0,F
36B2:  BNZ   36BE
36B4:  MOVF   xEF,F
36B6:  BNZ   36BE
36B8:  MOVF   xEE,W
36BA:  SUBLW  64
36BC:  BC    3736
36BE:  MOVF   xF5,F
36C0:  BNZ   3736
36C2:  MOVF   xF4,F
36C4:  BNZ   3736
36C6:  MOVF   xF3,F
36C8:  BNZ   3736
36CA:  MOVF   xF2,W
36CC:  SUBLW  B3
36CE:  BNC   3736
36D0:  MOVF   xF5,F
36D2:  BNZ   36E2
36D4:  MOVF   xF4,F
36D6:  BNZ   36E2
36D8:  MOVF   xF3,F
36DA:  BNZ   36E2
36DC:  MOVF   xF2,W
36DE:  SUBLW  64
36E0:  BC    3736
36E2:  MOVF   xF9,F
36E4:  BNZ   3736
36E6:  MOVF   xF8,F
36E8:  BNZ   3736
36EA:  MOVF   xF7,F
36EC:  BNZ   3736
36EE:  MOVF   xF6,W
36F0:  SUBLW  B3
36F2:  BNC   3736
36F4:  MOVF   xF9,F
36F6:  BNZ   3706
36F8:  MOVF   xF8,F
36FA:  BNZ   3706
36FC:  MOVF   xF7,F
36FE:  BNZ   3706
3700:  MOVF   xF6,W
3702:  SUBLW  64
3704:  BC    3736
3706:  MOVF   xFD,F
3708:  BNZ   3736
370A:  MOVF   xFC,F
370C:  BNZ   3736
370E:  MOVF   xFB,F
3710:  BNZ   3736
3712:  MOVF   xFA,W
3714:  SUBLW  B3
3716:  BNC   3736
3718:  MOVF   xFD,F
371A:  BNZ   372A
371C:  MOVF   xFC,F
371E:  BNZ   372A
3720:  MOVF   xFB,F
3722:  BNZ   372A
3724:  MOVF   xFA,W
3726:  SUBLW  64
3728:  BC    3736
372A:  MOVLW  05
372C:  MOVWF  01
372E:  MOVLB  B
3730:  BRA    373C
....................    else return 0xff; 
3732:  BRA    373C
3734:  MOVLB  A
3736:  MOVLW  FF
3738:  MOVWF  01
373A:  MOVLB  B
.................... } 
373C:  MOVLB  0
373E:  GOTO   37AC (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
3742:  BSF    F93.4
3744:  BTFSS  F81.4
3746:  BRA    375A
3748:  BSF    F93.5
374A:  BTFSS  F81.5
374C:  BRA    375A
374E:  BSF    F93.6
3750:  BTFSS  F81.6
3752:  BRA    375A
3754:  BSF    F93.7
3756:  BTFSC  F81.7
3758:  BRA    38CC
....................     { 
....................        if(input(ROW0)==0) 
375A:  BSF    F93.4
375C:  BTFSC  F81.4
375E:  BRA    3768
....................          row=0; 
3760:  MOVLB  A
3762:  CLRF   xE7
....................        else if(input(ROW1)==0) 
3764:  BRA    3794
3766:  MOVLB  0
3768:  BSF    F93.5
376A:  BTFSC  F81.5
376C:  BRA    3778
....................          row=1; 
376E:  MOVLW  01
3770:  MOVLB  A
3772:  MOVWF  xE7
....................        else if(input(ROW2)==0) 
3774:  BRA    3794
3776:  MOVLB  0
3778:  BSF    F93.6
377A:  BTFSC  F81.6
377C:  BRA    3788
....................          row=2; 
377E:  MOVLW  02
3780:  MOVLB  A
3782:  MOVWF  xE7
....................        else if(input(ROW3)==0) 
3784:  BRA    3794
3786:  MOVLB  0
3788:  BSF    F93.7
378A:  BTFSC  F81.7
378C:  BRA    3794
....................          row=3;      
378E:  MOVLW  03
3790:  MOVLB  A
3792:  MOVWF  xE7
....................        if(type_KB==0)col=check_col(); 
3794:  MOVLB  1
3796:  MOVF   x10,F
3798:  BNZ   37A6
379A:  MOVLB  0
379C:  GOTO   2890
37A0:  MOVFF  01,AE5
....................          else col=new_check_col(); 
37A4:  BRA    37B0
37A6:  MOVLB  0
37A8:  GOTO   2EC8
37AC:  MOVFF  01,AE5
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
37B0:  MOVLB  A
37B2:  INCFSZ xE5,W
37B4:  BRA    37B8
37B6:  BRA    389A
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
37B8:  MOVLB  1
37BA:  MOVF   x10,F
37BC:  BNZ   37E4
37BE:  MOVLB  A
37C0:  MOVF   xE7,W
37C2:  MULLW  05
37C4:  MOVF   FF3,W
37C6:  CLRF   xE9
37C8:  MOVWF  xE8
37CA:  CLRF   03
37CC:  MOVF   xE5,W
37CE:  ADDWF  xE8,W
37D0:  MOVWF  01
37D2:  MOVF   xE9,W
37D4:  ADDWFC 03,F
37D6:  MOVF   01,W
37D8:  MOVLB  0
37DA:  CALL   00E8
37DE:  MOVFF  FE8,AE6
....................            else kchar =newKEYS[row][col]; 
37E2:  BRA    3808
37E4:  MOVLB  A
37E6:  MOVF   xE7,W
37E8:  MULLW  06
37EA:  MOVF   FF3,W
37EC:  CLRF   xE9
37EE:  MOVWF  xE8
37F0:  CLRF   03
37F2:  MOVF   xE5,W
37F4:  ADDWF  xE8,W
37F6:  MOVWF  01
37F8:  MOVF   xE9,W
37FA:  ADDWFC 03,F
37FC:  MOVF   01,W
37FE:  MOVLB  0
3800:  CALL   010C
3804:  MOVFF  FE8,AE6
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
3808:  MOVLB  1
380A:  MOVF   x08,F
380C:  BNZ   388E
....................             { 
....................               charac_timeout=0; 
380E:  MOVLB  0
3810:  CLRF   xFC
3812:  CLRF   xFB
....................                if(key_count_ms<20)key_data[key_count_ms++]=kchar; 
3814:  MOVLB  1
3816:  MOVF   x0B,W
3818:  SUBLW  13
381A:  BNC   3830
381C:  MOVF   x0B,W
381E:  INCF   x0B,F
3820:  CLRF   03
3822:  ADDLW  11
3824:  MOVWF  FE9
3826:  MOVLW  01
3828:  ADDWFC 03,W
382A:  MOVWF  FEA
382C:  MOVFF  AE6,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
3830:  MOVLW  30
3832:  MOVWF  FF6
3834:  MOVLW  03
3836:  MOVWF  FF7
3838:  MOVLW  09
383A:  MOVLB  B
383C:  MOVWF  x0E
383E:  MOVLB  0
3840:  CALL   19C8
3844:  MOVFF  10B,AEE
3848:  MOVLW  18
384A:  MOVLB  A
384C:  MOVWF  xEF
384E:  MOVLB  0
3850:  CALL   1ADC
3854:  MOVLW  5D
3856:  MOVLB  B
3858:  MOVWF  x1A
385A:  MOVLB  0
385C:  CALL   05AA
3860:  MOVLW  20
3862:  MOVLB  B
3864:  MOVWF  x1A
3866:  MOVLB  0
3868:  CALL   05AA
386C:  MOVFF  AE6,B1A
3870:  CALL   05AA
3874:  MOVLW  0D
3876:  MOVLB  B
3878:  MOVWF  x1A
387A:  MOVLB  0
387C:  CALL   05AA
3880:  MOVLW  0A
3882:  MOVLB  B
3884:  MOVWF  x1A
3886:  MOVLB  0
3888:  CALL   05AA
....................             } 
....................                else fputc(kchar,COM2); 
388C:  BRA    3898
388E:  MOVFF  AE6,B1A
3892:  MOVLB  0
3894:  CALL   05AA
3898:  MOVLB  A
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
389A:  BSF    F93.4
389C:  BTFSS  F81.4
389E:  BRA    389A
38A0:  BSF    F93.5
38A2:  BTFSS  F81.5
38A4:  BRA    389A
38A6:  BSF    F93.6
38A8:  BTFSS  F81.6
38AA:  BRA    389A
38AC:  BSF    F93.7
38AE:  BTFSS  F81.7
38B0:  BRA    389A
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
38B2:  BSF    F93.4
38B4:  BTFSS  F81.4
38B6:  BRA    38B2
38B8:  BSF    F93.5
38BA:  BTFSS  F81.5
38BC:  BRA    38B2
38BE:  BSF    F93.6
38C0:  BTFSS  F81.6
38C2:  BRA    38B2
38C4:  BSF    F93.7
38C6:  BTFSS  F81.7
38C8:  BRA    38B2
38CA:  MOVLB  0
....................     } 
....................   set_tris_a(0xff);     
38CC:  MOVLW  FF
38CE:  MOVWF  F92
....................   return(kchar); 
38D0:  MOVLB  A
38D2:  MOVFF  AE6,01
.................... }//*/ 
38D6:  MOVLB  0
38D8:  RETURN 0
.................... //============================================ 
....................  
.................... //=========================== 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
460C:  MOVF   27,F
460E:  BTFSS  FD8.2
4610:  BRA    4750
4612:  MOVF   26,F
4614:  BTFSS  FD8.2
4616:  BRA    4750
4618:  MOVF   25,W
461A:  SUBLW  FF
461C:  BTFSS  FD8.0
461E:  BRA    4750
4620:  BNZ   462A
4622:  MOVF   24,W
4624:  SUBLW  FE
4626:  BTFSS  FD8.0
4628:  BRA    4750
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)) 
462A:  MOVLB  1
462C:  MOVF   x11,F
462E:  BZ    46FE
....................       { 
....................          temp=get_countcard(); 
4630:  MOVLB  0
4632:  CALL   3B2C
4636:  MOVFF  02,AE7
463A:  MOVFF  01,AE6
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
463E:  MOVFF  AE7,AEB
4642:  MOVFF  AE6,AEA
4646:  MOVLB  A
4648:  CLRF   xED
464A:  MOVLW  32
464C:  MOVWF  xEC
464E:  MOVLB  0
4650:  CALL   3B7C
4654:  MOVFF  02,AE9
4658:  MOVFF  01,AE8
465C:  MOVLW  46
465E:  MOVLB  A
4660:  ADDWF  xE8,F
4662:  MOVLW  AA
4664:  ADDWFC xE9,F
4666:  MOVLW  01
4668:  ADDWF  xE8,W
466A:  MOVWF  01
466C:  MOVLW  00
466E:  ADDWFC xE9,W
4670:  MOVFF  01,24
4674:  MOVWF  25
4676:  CLRF   26
4678:  CLRF   27
....................          for(i=0;i<key_numbyte-5;i++) 
467A:  CLRF   xE5
467C:  MOVF   xE5,W
467E:  SUBLW  2C
4680:  BNC   46D2
....................          { 
....................             write_ext_eeprom((long int)ptr_card_key++,key_data[i]); 
4682:  MOVFF  27,03
4686:  MOVFF  26,02
468A:  MOVFF  25,01
468E:  MOVFF  24,00
4692:  MOVLW  01
4694:  ADDWF  24,F
4696:  BTFSC  FD8.0
4698:  INCF   25,F
469A:  BTFSC  FD8.2
469C:  INCF   26,F
469E:  BTFSC  FD8.2
46A0:  INCF   27,F
46A2:  MOVFF  01,AE9
46A6:  MOVFF  00,AE8
46AA:  CLRF   03
46AC:  MOVF   xE5,W
46AE:  ADDLW  11
46B0:  MOVWF  FE9
46B2:  MOVLW  01
46B4:  ADDWFC 03,W
46B6:  MOVWF  FEA
46B8:  MOVFF  FEF,AEA
46BC:  MOVFF  01,B03
46C0:  MOVFF  00,B02
46C4:  MOVFF  AEA,B04
46C8:  MOVLB  0
46CA:  RCALL  3FE4
....................             //fputc(key_data[i],COM2); 
....................          } 
46CC:  MOVLB  A
46CE:  INCF   xE5,F
46D0:  BRA    467C
....................          write_ext_eeprom((long int)ptr_card_key,0); 
46D2:  MOVFF  25,B03
46D6:  MOVFF  24,B02
46DA:  MOVLB  B
46DC:  CLRF   x04
46DE:  MOVLB  0
46E0:  RCALL  3FE4
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
46E2:  MOVFF  27,AEB
46E6:  MOVFF  26,AEA
46EA:  MOVFF  25,AE9
46EE:  MOVFF  24,AE8
46F2:  MOVLW  1E
46F4:  MOVLB  A
46F6:  MOVWF  xEC
46F8:  MOVLB  0
46FA:  RCALL  40EA
46FC:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
46FE:  CLRF   x0B
....................       del_buf(key_numbyte,key_data); 
4700:  MOVLW  32
4702:  MOVLB  A
4704:  MOVWF  xF4
4706:  MOVLW  01
4708:  MOVWF  xF6
470A:  MOVLW  11
470C:  MOVWF  xF5
470E:  MOVLB  0
4710:  CALL   3B9E
....................       fprintf(COM2,"\r\n"); 
4714:  MOVLW  0D
4716:  MOVLB  B
4718:  MOVWF  x1A
471A:  MOVLB  0
471C:  CALL   05AA
4720:  MOVLW  0A
4722:  MOVLB  B
4724:  MOVWF  x1A
4726:  MOVLB  0
4728:  CALL   05AA
....................       fprintf(COM2,"Done PIN"); 
472C:  MOVLW  42
472E:  MOVWF  FF6
4730:  MOVLW  03
4732:  MOVWF  FF7
4734:  CALL   05F0
....................       fprintf(COM2,"\r\n"); 
4738:  MOVLW  0D
473A:  MOVLB  B
473C:  MOVWF  x1A
473E:  MOVLB  0
4740:  CALL   05AA
4744:  MOVLW  0A
4746:  MOVLB  B
4748:  MOVWF  x1A
474A:  MOVLB  0
474C:  CALL   05AA
....................    } 
.................... } 
4750:  GOTO   4A0A (RETURN)
.................... //=========================================== 
.................... void key_press() 
.................... { 
....................    int8 col; 
....................    int32 KB_count_timeout=0; 
....................    fprintf(COM2,"\r\n"); 
....................    fprintf(COM2,"Key"); 
....................    //fprintf(COM2,"\r\n"); 
....................    KB_count_timeout=0; 
....................    while(1) 
....................    { 
....................       
....................       if(KB_count_timeout<150000)KB_count_timeout++; 
....................       if(KB_count_timeout==150000) 
....................       { 
....................          KB_count_timeout++; 
....................           
....................          break;             
....................       }   
....................    } 
.................... } 
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
4F0E:  MOVLB  A
4F10:  CLRF   xC5
4F12:  CLRF   xC4
4F14:  CLRF   xC6
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
4F16:  MOVF   xC5,F
4F18:  BTFSS  FD8.2
4F1A:  BRA    503E
4F1C:  MOVF   xBF,W
4F1E:  SUBWF  xC4,W
4F20:  BTFSC  FD8.0
4F22:  BRA    503E
4F24:  MOVF   xC6,F
4F26:  BTFSS  FD8.2
4F28:  BRA    503E
....................       c = fgetc(COM2);//getc(); 
4F2A:  MOVLB  0
4F2C:  RCALL  4EC0
4F2E:  MOVFF  01,AC2
....................       switch(c) 
....................       { 
4F32:  MOVLB  A
4F34:  MOVF   xC2,W
4F36:  XORLW  7F
4F38:  MOVLB  0
4F3A:  BZ    4F42
4F3C:  XORLW  72
4F3E:  BZ    4F90
4F40:  BRA    4FCE
....................          case 0x7f:    
....................             if(nbcar>0)   
4F42:  MOVLB  A
4F44:  MOVF   xC4,F
4F46:  BNZ   4F4C
4F48:  MOVF   xC5,F
4F4A:  BZ    4F76
4F4C:  CLRF   19
4F4E:  BTFSC  FF2.7
4F50:  BSF    19.7
4F52:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
4F54:  MOVLW  7F
4F56:  MOVLB  B
4F58:  MOVWF  x1A
4F5A:  MOVLB  0
4F5C:  CALL   05AA
4F60:  BTFSC  19.7
4F62:  BSF    FF2.7
....................                nbcar--; 
4F64:  MOVLB  A
4F66:  MOVF   xC4,W
4F68:  BTFSC  FD8.2
4F6A:  DECF   xC5,F
4F6C:  DECF   xC4,F
....................                fgetc(COM2);//getc(); 
4F6E:  MOVLB  0
4F70:  RCALL  4EC0
....................             } 
....................             else fputc(0x07,COM2);    
4F72:  BRA    4F8E
4F74:  MOVLB  A
4F76:  CLRF   19
4F78:  BTFSC  FF2.7
4F7A:  BSF    19.7
4F7C:  BCF    FF2.7
4F7E:  MOVLW  07
4F80:  MOVLB  B
4F82:  MOVWF  x1A
4F84:  MOVLB  0
4F86:  CALL   05AA
4F8A:  BTFSC  19.7
4F8C:  BSF    FF2.7
....................          break;  
4F8E:  BRA    503A
....................          case 0x0D:   
....................                keydebug_en=0; 
4F90:  MOVLB  1
4F92:  CLRF   x08
....................                set_tris_a(0xff); 
4F94:  MOVLW  FF
4F96:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
4F98:  MOVFF  AC4,AC3
4F9C:  MOVLB  A
4F9E:  MOVF   xBF,W
4FA0:  SUBWF  xC3,W
4FA2:  BC    4FB8
....................                { 
....................                  chaine[i]=0; 
4FA4:  CLRF   03
4FA6:  MOVF   xC3,W
4FA8:  ADDWF  xC0,W
4FAA:  MOVWF  FE9
4FAC:  MOVF   xC1,W
4FAE:  ADDWFC 03,W
4FB0:  MOVWF  FEA
4FB2:  CLRF   FEF
....................                } 
4FB4:  INCF   xC3,F
4FB6:  BRA    4F9E
....................                if(nbcar==0)return(FAUX); 
4FB8:  MOVF   xC4,F
4FBA:  BNZ   4FC6
4FBC:  MOVF   xC5,F
4FBE:  BNZ   4FC6
4FC0:  MOVLW  00
4FC2:  MOVWF  01
4FC4:  BRA    5042
....................                fini=VRAI; 
4FC6:  MOVLW  01
4FC8:  MOVWF  xC6
....................          break; 
4FCA:  MOVLB  0
4FCC:  BRA    503A
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
4FCE:  MOVLB  A
4FD0:  MOVF   xC2,W
4FD2:  SUBLW  1F
4FD4:  BC    503C
4FD6:  MOVF   xC2,W
4FD8:  SUBLW  7E
4FDA:  BNC   503C
4FDC:  MOVLW  01
4FDE:  SUBWF  xBF,W
4FE0:  MOVF   xC5,F
4FE2:  BNZ   503C
4FE4:  SUBWF  xC4,W
4FE6:  BC    503C
....................             { 
....................                chaine[nbcar]=c; 
4FE8:  MOVF   xC0,W
4FEA:  ADDWF  xC4,W
4FEC:  MOVWF  FE9
4FEE:  MOVF   xC1,W
4FF0:  ADDWFC xC5,W
4FF2:  MOVWF  FEA
4FF4:  MOVFF  AC2,FEF
....................                nbcar++; 
4FF8:  INCF   xC4,F
4FFA:  BTFSC  FD8.2
4FFC:  INCF   xC5,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
4FFE:  DECFSZ xBE,W
5000:  BRA    501C
5002:  CLRF   19
5004:  BTFSC  FF2.7
5006:  BSF    19.7
5008:  BCF    FF2.7
500A:  MOVFF  AC2,B1A
500E:  MOVLB  0
5010:  CALL   05AA
5014:  BTFSC  19.7
5016:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
5018:  BRA    503A
501A:  MOVLB  A
501C:  MOVF   xBE,W
501E:  SUBLW  02
5020:  BNZ   503C
5022:  CLRF   19
5024:  BTFSC  FF2.7
5026:  BSF    19.7
5028:  BCF    FF2.7
502A:  MOVLW  2A
502C:  MOVLB  B
502E:  MOVWF  x1A
5030:  MOVLB  0
5032:  CALL   05AA
5036:  BTFSC  19.7
5038:  BSF    FF2.7
503A:  MOVLB  A
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
503C:  BRA    4F16
....................    return(nbcar); 
503E:  MOVFF  AC4,01
.................... } 
5042:  MOVLB  0
5044:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
5046:  MOVFF  ABF,AC3
504A:  MOVFF  ABE,AC2
504E:  MOVFF  AC1,AC5
5052:  MOVFF  AC0,AC4
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
5056:  MOVFF  AC3,03
505A:  MOVLB  A
505C:  MOVFF  AC2,FE9
5060:  MOVFF  AC3,FEA
5064:  MOVF   FEF,F
5066:  BZ    50AE
5068:  MOVFF  AC5,03
506C:  MOVFF  AC4,FE9
5070:  MOVFF  AC5,FEA
5074:  MOVF   FEF,F
5076:  BZ    50AE
....................       if(*aa!=*bb) 
5078:  MOVFF  AC2,FE9
507C:  MOVFF  AC3,FEA
5080:  MOVFF  FEF,AC6
5084:  MOVFF  AC5,03
5088:  MOVFF  AC4,FE9
508C:  MOVFF  AC5,FEA
5090:  MOVF   FEF,W
5092:  SUBWF  xC6,W
5094:  BZ    509C
....................          return(1); 
5096:  MOVLW  01
5098:  MOVWF  01
509A:  BRA    50DA
....................       aa++; 
509C:  INCF   xC2,F
509E:  BTFSC  FD8.2
50A0:  INCF   xC3,F
....................       bb++; 
50A2:  INCF   xC4,F
50A4:  BTFSC  FD8.2
50A6:  INCF   xC5,F
....................    } 
50A8:  MOVLB  0
50AA:  BRA    5056
50AC:  MOVLB  A
....................    if(*aa!=*bb)return(1); 
50AE:  MOVFF  AC3,03
50B2:  MOVFF  AC2,FE9
50B6:  MOVFF  AC3,FEA
50BA:  MOVFF  FEF,AC6
50BE:  MOVFF  AC5,03
50C2:  MOVFF  AC4,FE9
50C6:  MOVFF  AC5,FEA
50CA:  MOVF   FEF,W
50CC:  SUBWF  xC6,W
50CE:  BZ    50D6
50D0:  MOVLW  01
50D2:  MOVWF  01
50D4:  BRA    50DA
....................    return(0); 
50D6:  MOVLW  00
50D8:  MOVWF  01
.................... } 
50DA:  MOVLB  0
50DC:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
55E4:  MOVLB  A
55E6:  CLRF   xC0
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
55E8:  MOVFF  ABF,03
55EC:  MOVF   xBE,W
55EE:  INCF   xBE,F
55F0:  BTFSC  FD8.2
55F2:  INCF   xBF,F
55F4:  MOVWF  FE9
55F6:  MOVFF  03,FEA
55FA:  MOVFF  FEF,AC2
55FE:  MOVF   xC2,F
5600:  BZ    5624
....................         if (c >= '0' && c <= '9') 
5602:  MOVF   xC2,W
5604:  SUBLW  2F
5606:  BC    5616
5608:  MOVF   xC2,W
560A:  SUBLW  39
560C:  BNC   5616
....................             digit = (unsigned int) (c - '0'); 
560E:  MOVLW  30
5610:  SUBWF  xC2,W
5612:  MOVWF  xC1
....................         else 
5614:  BRA    5618
....................             break; 
5616:  BRA    5624
....................  
....................         val = (val * 10) + digit; 
5618:  MOVF   xC0,W
561A:  MULLW  0A
561C:  MOVF   FF3,W
561E:  ADDWF  xC1,W
5620:  MOVWF  xC0
....................     } 
5622:  BRA    55E8
....................  
....................     return val; 
5624:  CLRF   03
5626:  MOVFF  AC0,01
562A:  MOVFF  03,02
.................... } 
562E:  MOVLB  0
5630:  RETURN 0
....................  
.................... #include <GSM.c>  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#include "myRS485.C" 
....................  
.................... #define        EMERGOFF       PIN_A7 
.................... #define        reading_sms_cmd      1 
.................... #define        MSG_avai             2 
.................... #define        analyze_sms          3 
.................... #define        checking_MN          4 
.................... #define        doing_sms            5 
.................... #define        delete_MSG           6 
.................... #define        pre_cmd              7 
.................... #define        MSG_sending          8 
.................... #define        check_st             9 
.................... #define        config               10 
.................... #define        autosending          11 
.................... #define        idle                 12 
.................... #define        data_analyze         13 
.................... #define        SIM_reply            14 
.................... #define        check_comunication   15 
.................... #define        phone_activity_status 16 
.................... #define        check_inbox          17 
.................... #define        checking_MN0         18 
.................... #define        autosending1         19 
.................... //#define     IGT            PIN_A6 
....................  
.................... //#define     batmb    sendto485(0,0x11,1) 
.................... //#define     tatmb    sendto485(0,0x11,0) 
....................  
....................  
.................... unsigned int8 msg_data_sending[280]; 
.................... int8 sim_bug[50]; 
.................... unsigned int8 msg_buffer1[20]; 
.................... unsigned int8 msg_buffer2[50]; 
.................... unsigned int8 reply_buffer[280]; 
.................... unsigned int8 datetime[25]; 
.................... unsigned int8 mobilenumb[26]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... //unsigned int8 buf_checkMBN[16]; 
.................... int16 count_polling=0; 
.................... int8 SIM_state=0,MSG_sending_st=0; 
.................... int16 timing_wait=300; 
.................... int8 auto_sending=0; 
.................... int8 send_oneMSG=0; 
.................... int8 SIM_reply_st=0; 
.................... int8 checking_sim=0; 
.................... int16 count_checking=90; 
.................... #if defined(twonumber) 
....................   int8 two_number_sending=0;        
.................... #endif 
.................... //unsigned int8 com_buffer1[20]="it is OK"; 
.................... //============================================== 
.................... void earse_buffer_uart(unsigned int8 numbuf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<numbuf;i++) 
....................    { 
....................        buffer_uart[i]=0; 
....................    } 
.................... } 
.................... //============================================== 
.................... void sim900_init() 
.................... { 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(500); 
....................    fprintf(COM1,"AT+CMGF=1\r\n"); 
....................    delay_ms(500); 
....................    //del_buf(26,mobilenumb); 
....................    //strcpy(mobilenumb,"+84903219082"); 
.................... } 
.................... //============================================== 
.................... int8 get_datasim900(int8 *datin) 
.................... { 
....................    int8 c,i,index=0; 
....................    int8 testtemp[20]; 
....................    while(index<5) 
....................    { 
....................       c = getc(); 
....................       index++; 
....................       fprintf(COM2,"%c", c);  
....................    } 
....................    for(i=0;i<15;i++) 
....................    { 
....................       fprintf(COM2,"%c", testtemp[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", index);//*/ 
....................    return 0; 
.................... } 
.................... //============================================== 
.................... int8 check_module() 
.................... { 
....................    int8 temp=0,i; 
....................    earse_buffer_uart(10); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    UART_index=0; 
....................    delay_ms(200); 
....................    //fputc('c',COM2); 
....................    //fprintf("MSG is OK\r\n"); 
....................    for(i=0;i<10;i++) 
....................    { 
....................       //fputc(buffer_uart[i],COM2); 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) 
....................       { 
....................          i=10; 
....................          temp=1; 
....................          return(temp); 
....................       } 
....................          else temp=0; 
....................    } 
....................    UART_index=0; 
....................    return(temp); 
.................... } 
.................... //============================================== 
.................... void power_on() 
.................... { 
....................    /*while(temp==0) 
....................    { 
....................       temp = check_module(); 
....................       if(temp==0) 
....................       { 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
....................       } 
....................          else break; 
....................    }*/ 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
.................... } 
.................... //============================================== 
.................... void power_off() 
.................... { 
....................    fprintf(COM1,"AT+CPOWD\r\n"); 
.................... } 
.................... //============================================== 
.................... unsigned int8 mymemcmp(void * s1,char *s2,size_t n) 
.................... { 
....................    char *su1, *su2; 
....................    unsigned int8 temp=0,i=0; 
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................       { 
....................          temp=1; 
....................          if(*su1>*su2) 
....................          { 
....................             if((i==0)&&(*su1==(*su2)+32)) temp = 0; 
....................                //else temp = 0; 
....................          } 
....................             else  
....................                { 
....................                   if((i==0)&&(*su2==(*su1)+32)) temp = 0; 
....................                     // else temp = 0; 
....................                } 
....................       } 
....................       i++; 
....................    } 
....................    return (temp); 
.................... } 
.................... //============================================== 
.................... int8 pre_msg(int8 *datin,int8 *datout,int16 index) 
.................... { 
....................    int8 i,len=0; 
....................    len = strlen(datin); 
....................    for(i=0;i<len;i++)datout[index++]=datin[i]; 
....................    return index; 
.................... } 
.................... //============================================== 
.................... void delete_sms(char number_sms) 
.................... { 
....................    switch(number_sms) 
....................    { 
....................        case  1: 
....................             fprintf(COM1,"AT+CMGD=1\r\n");  
....................        break; 
....................        case  2: 
....................             fprintf(COM1,"AT+CMGD=2\r\n"); 
....................        break; 
....................        case  3: 
....................             fprintf(COM1,"AT+CMGD=3\r\n"); 
....................        break; 
....................        case  4: 
....................             fprintf(COM1,"AT+CMGD=4\r\n");        
....................        break; 
....................        case  5: 
....................             fprintf(COM1,"AT+CMGD=5\r\n"); 
....................        break; 
....................        case  6: 
....................             fprintf(COM1,"AT+CMGD=6\r\n"); 
....................        break; 
....................        case  7: 
....................              fprintf(COM1,"AT+CMGD=7\r\n"); 
....................        break;        
....................        case  8: 
....................             fprintf(COM1,"AT+CMGD=8\r\n"); 
....................        break;        
....................    } 
....................    delay_ms(500); 
.................... } 
.................... //============================================== 
.................... void del_multi_sms(int8 num_sms) 
.................... { 
....................    int8 i; 
....................    for(i=1;i<=num_sms;i++) 
....................    { 
....................      delete_sms(i);  
....................      delay_ms(100); 
....................    } 
.................... } 
.................... //============================================== 
.................... //============================================== 
.................... void send_sms(unsigned int8* mobile_num,unsigned int8* MSG) 
.................... { 
....................       unsigned int8 i=0,strl=0; 
....................       strl= strlen(MSG);   
....................       fprintf(COM1,"AT+CMGS="); 
....................       delay_ms(500); 
....................       fputc('"',COM1); 
....................       while((mobile_num[i]!=0)&&(i<20)) 
....................       { 
....................          //fputc(mobile_num[i],COM2); 
....................          //putc(mobile_num[i]); 
....................          fputc(mobile_num[i],COM1); 
....................          i++; 
....................       } 
....................       fputc('"',COM1); 
....................       fprintf(COM1,"\r\n"); 
....................       delay_ms(500);         
....................       for(i=0;i<strl;i++) 
....................       { 
....................          fputc(MSG[i],COM1); 
....................       } 
....................       delay_ms(500); 
....................       fputc(26,COM1); 
.................... } 
.................... //============================================= 
.................... //============================================== 
.................... void reading_sms() 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<16;i++) mobilenumb[i]=0; 
....................    earse_buffer_uart(200); 
....................    printf("AT+CMGF=1\r\n"); 
....................    printf("AT+CMGR=1\r\n");  
....................    UART_index=0;  
....................    delay_ms(1000); 
....................    for(i=0;i<200;i++) 
....................    { 
....................       if((buffer_uart[i]=='a')&&(buffer_uart[i+1]=='d')&&(buffer_uart[i+2]=='m')&&(buffer_uart[i+3]=='i')&&(buffer_uart[i+4]=='n')&&(buffer_uart[i+5]==' ')) 
....................       { 
....................          write_ext_eeprom(strobe_mobile_num1,buffer_uart[i+6]); 
....................          fputc(buffer_uart[i+6],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+1,buffer_uart[i+7]); 
....................          fputc(buffer_uart[i+7],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+2,buffer_uart[i+8]); 
....................          fputc(buffer_uart[i+8],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+3,buffer_uart[i+9]); 
....................          fputc(buffer_uart[i+9],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+4,buffer_uart[i+10]); 
....................          fputc(buffer_uart[i+10],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+5,buffer_uart[i+11]); 
....................          fputc(buffer_uart[i+11],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+6,buffer_uart[i+12]); 
....................          fputc(buffer_uart[i+12],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+7,buffer_uart[i+13]); 
....................          fputc(buffer_uart[i+13],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+8,buffer_uart[i+14]); 
....................          fputc(buffer_uart[i+14],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+9,buffer_uart[i+15]); 
....................          fputc(buffer_uart[i+15],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+10,buffer_uart[i+16]); 
....................          fputc(buffer_uart[i+16],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+11,buffer_uart[i+17]); 
....................          fputc(buffer_uart[i+17],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+12,buffer_uart[i+18]); 
....................          fputc(buffer_uart[i+18],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+13,buffer_uart[i+19]); 
....................          fputc(buffer_uart[i+19],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+14,buffer_uart[i+20]); 
....................          fputc(buffer_uart[i+20],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+15,buffer_uart[i+21]); 
....................          fputc(buffer_uart[i+21],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+16,buffer_uart[i+22]); 
....................          fputc(buffer_uart[i+22],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+17,buffer_uart[i+23]); 
....................          fputc(buffer_uart[i+23],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+18,buffer_uart[i+24]); 
....................          fputc(buffer_uart[i+24],COM2);          
....................          write_ext_eeprom(strobe_mobile_num1+19,buffer_uart[i+25]); 
....................          fputc(buffer_uart[i+25],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+20,buffer_uart[i+26]); 
....................          fputc(buffer_uart[i+26],COM2);          
....................          fprintf(COM2,"\r\n"); 
....................          EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................          i=250; 
....................          sms_unread_flag=0; 
....................          strcpy (msg_data_sending, "done"); 
....................          send_sms(mobilenumb,msg_data_sending); 
....................          delay_ms(5000); 
....................          delete_sms(1); 
....................          delay_ms(5000); 
....................          UART_index=0; 
....................       } 
....................         else  
....................          { 
....................             if(i>198)  
....................             { 
....................                delay_ms(5000); 
....................                delete_sms(1); 
....................                delay_ms(5000); 
....................                UART_index=0; 
....................                sms_unread_flag=0; 
....................                EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................             } 
....................          } 
....................    } 
.................... } 
.................... //============================================== 
.................... /*void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... }*/ 
.................... //============================================================ 
.................... int8 checking_msg_avai() 
.................... { 
....................    int8 i; 
....................    /*for(i=0;i<100;i++) 
....................    { 
....................       fprintf(COM2,"%c", buffer_uart[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", UART_index);//*/ 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) return 1; 
....................    } 
....................    return 0; 
.................... } 
.................... //============================================================ 
.................... int8 SMS_coming() 
.................... { 
.................... //+CMTI: "SM",25 
....................    int8 i,st=0; 
....................    //int8 msg_temp[20],msg_temp1[20]; 
....................    //strncpy(msg_temp1,buffer_uart,20); 
....................    //strcpy(msg_temp,"+CMTI:"); 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='T')&&(buffer_uart[4+i]=='I')&&(buffer_uart[5+i]==':'))  
....................       {  
....................          fprintf(COM2,"\n\rNew SMS\n\r"); 
....................          //output_high(PIN_C2); 
....................          SIM_state=reading_sms_cmd; 
....................          st = 2; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='G')&&(buffer_uart[4+i]=='R')&&(buffer_uart[5+i]==':'))  
....................       {  
....................          fprintf(COM2,"\n\rREC UNREAD\n\r"); 
....................          //output_high(PIN_C2); 
....................          SIM_state=reading_sms_cmd; 
....................          st = 2; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='R')&&(buffer_uart[1+i]=='I')&&(buffer_uart[2+i]=='N')&&(buffer_uart[3+i]=='G'))  
....................       {  
....................          fprintf(COM2,"\n\rRING\n\r"); 
....................          output_high(LED); 
....................          st = 1; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................    } 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='P')&&(buffer_uart[3+i]=='A')&&(buffer_uart[4+i]=='S')&&(buffer_uart[5+i]==':'))  
....................       {  
....................          if(buffer_uart[7+i]=='0')  
....................          { 
....................             fprintf(COM2,"Ready (MT allows commands from TA/TE)\n\r"); 
....................             SIM_state= check_inbox; 
....................          } 
....................          if(buffer_uart[7+i]=='2') 
....................          { 
....................             fprintf(COM2,"No network\n\r"); 
....................             SIM_state=check_comunication; 
....................          } 
....................          if(buffer_uart[7+i]=='3') fprintf(COM2,"Ringing\n\r"); 
....................          if(buffer_uart[7+i]=='4') fprintf(COM2,"Call in progress\n\r"); 
....................          st = 3; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................    } 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='U')&&(buffer_uart[1+i]=='N')&&(buffer_uart[2+i]=='D')&&(buffer_uart[3+i]=='E')&&(buffer_uart[4+i]=='R')&&(buffer_uart[5+i]=='-')&&(buffer_uart[6+i]=='V')&&(buffer_uart[7+i]=='O')&&(buffer_uart[8+i]=='L'))  
....................       {  
....................          fprintf(COM2,"\n\rUNDER-VOLTAGE WARNNING\n\r"); 
....................          SIM_state=reading_sms_cmd; 
....................          st = 4; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................    } 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='O')&&(buffer_uart[1+i]=='V')&&(buffer_uart[2+i]=='E')&&(buffer_uart[3+i]=='R')&&(buffer_uart[4+i]=='-')&&(buffer_uart[5+i]=='V')&&(buffer_uart[6+i]=='O')&&(buffer_uart[7+i]=='L')&&(buffer_uart[8+i]=='T'))  
....................       {  
....................          fprintf(COM2,"\n\rOVER-VOLTAGE POWER DOWN\n\r"); 
....................          SIM_state=reading_sms_cmd; 
....................          st = 4; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................    } 
....................  
....................    UART_index=0; 
....................    memset(buffer_uart,0,sizeof(buffer_uart));  
....................    return st; 
.................... } 
.................... //============================================================ 
.................... unsigned int8 analyzing_msg(char* MSG,char* mobile_number) 
.................... { 
....................    unsigned int8 i=0,a=0,b=0,d=0,u=0,v=0; 
....................    unsigned int8 st=0,temp; 
....................    del_buf(50,MSG); 
....................    del_buf(20,mobile_number); 
....................    for(i=0;i<100;i++) 
....................    { 
....................       if((buffer_uart[i]=='+')&&(buffer_uart[i+1]=='C')&&(buffer_uart[i+2]=='M')&&(buffer_uart[i+3]=='G')&&(buffer_uart[i+4]=='R')&&(buffer_uart[i+5]==':')&&(buffer_uart[i+6]==' ')&&(buffer_uart[i+7]=='0')&&(buffer_uart[i+8]==',')&&(buffer_uart[i+9]==',')&&(buffer_uart[i+10]=='0'))  
....................       { 
....................          st=0; 
....................          i=200; 
....................          del_buf(100,MSG); 
....................          del_buf(16,mobile_number); 
....................          count_spam=0; 
....................          //output_toggle(pin_a5); 
....................       } 
....................          //else st=2; 
....................      temp = buffer_uart[i]; 
....................      if((a==3))  
....................      { 
....................        if((temp>47)&&(temp<58)||temp=='+') mobile_number[i-b] = temp; 
....................      } 
....................      if(d==2) 
....................      { 
....................          MSG[i-b] = temp; 
....................          st=1; 
....................      } 
....................      if(u==2) 
....................      { 
....................          datetime[i-v]=temp; 
....................      } 
....................       //else st=2; 
....................      if(temp==34)  
....................      { 
....................          if(a<6)a++; 
....................          if(a==3) b = i+1; 
....................      } 
....................      if(a==6) 
....................      { 
....................          if((temp==13)||(temp==10))  
....................          { 
....................             d++; 
....................             if(d==2) b = i+1; 
....................          } 
....................          if(temp==34)  
....................          { 
....................             u++; 
....................             if(u==2)v=i+1; 
....................          } 
....................      } 
....................      //if((temp==',')&&(a==6)) 
....................     // { 
....................          //if(c<2)c++; 
....................      //} 
....................    } 
....................    return(st); 
.................... } 
.................... //================================ 
.................... int8 ascii2int(int8 num1,int8 num2) 
.................... { 
....................    int8 temp; 
....................    temp=(num1-48)*10 + (num2-48); 
....................    return temp; 
.................... } 
.................... //================================ 
.................... void updatetime2ds1307() 
.................... { 
....................    int8 temp; 
....................    year=ascii2int(datetime[0],datetime[1]); 
....................    mon=ascii2int(datetime[3],datetime[4]); 
....................    date=ascii2int(datetime[6],datetime[7]); 
....................    h=ascii2int(datetime[9],datetime[10]); 
....................    min=ascii2int(datetime[12],datetime[13])+1; 
....................    //h=ascii2int(datetime[9],datetime[10]); 
....................    rtc_set_datetime(date,mon,year,day,h,min); 
.................... } 
.................... //================================ 
....................  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
0610:  MOVLB  B
0612:  CLRF   x36
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
0614:  CLRF   x37
0616:  BTFSC  x2E.0
0618:  BSF    x37.7
061A:  SWAPF  x2F,W
061C:  MOVWF  00
061E:  RLCF   00,F
0620:  RLCF   00,F
0622:  MOVLW  C0
0624:  ANDWF  00,F
0626:  MOVF   00,W
0628:  IORWF  x37,F
062A:  SWAPF  x30,W
062C:  MOVWF  00
062E:  RLCF   00,F
0630:  MOVLW  E0
0632:  ANDWF  00,F
0634:  MOVF   00,W
0636:  IORWF  x37,F
0638:  SWAPF  x31,W
063A:  MOVWF  00
063C:  MOVLW  F0
063E:  ANDWF  00,F
0640:  MOVF   00,W
0642:  IORWF  x37,F
0644:  RLCF   x32,W
0646:  MOVWF  00
0648:  RLCF   00,F
064A:  RLCF   00,F
064C:  MOVLW  F8
064E:  ANDWF  00,F
0650:  MOVF   00,W
0652:  IORWF  x37,F
0654:  RLCF   x33,W
0656:  MOVWF  00
0658:  RLCF   00,F
065A:  MOVLW  FC
065C:  ANDWF  00,F
065E:  MOVF   00,W
0660:  IORWF  x37,F
0662:  BCF    FD8.0
0664:  RLCF   x34,W
0666:  IORWF  x37,F
0668:  MOVF   x35,W
066A:  IORWF  x37,W
066C:  MOVWF  x36
....................    return temp; 
066E:  MOVFF  B36,01
.................... } 
0672:  MOVLB  0
0674:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0676:  MOVLB  B
0678:  CLRF   x1E
....................    int8 temp=0; 
....................    if(direct==0) 
067A:  MOVF   x19,F
067C:  BNZ   0752
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
067E:  MOVF   x1C,W
0680:  ADDWF  x1A,W
0682:  MOVWF  FE9
0684:  MOVF   x1D,W
0686:  ADDWFC x1B,W
0688:  MOVWF  FEA
068A:  MOVFF  FEF,B1F
068E:  MOVLW  01
0690:  ADDWF  x1A,W
0692:  MOVWF  x20
0694:  MOVLW  00
0696:  ADDWFC x1B,W
0698:  MOVWF  x21
069A:  MOVF   x1C,W
069C:  ADDWF  x20,W
069E:  MOVWF  FE9
06A0:  MOVF   x1D,W
06A2:  ADDWFC x21,W
06A4:  MOVWF  FEA
06A6:  MOVF   FEF,W
06A8:  XORWF  x1F,F
06AA:  MOVLW  02
06AC:  ADDWF  x1A,W
06AE:  MOVWF  x22
06B0:  MOVLW  00
06B2:  ADDWFC x1B,W
06B4:  MOVWF  x23
06B6:  MOVF   x1C,W
06B8:  ADDWF  x22,W
06BA:  MOVWF  FE9
06BC:  MOVF   x1D,W
06BE:  ADDWFC x23,W
06C0:  MOVWF  FEA
06C2:  MOVF   FEF,W
06C4:  XORWF  x1F,F
06C6:  MOVLW  03
06C8:  ADDWF  x1A,W
06CA:  MOVWF  x24
06CC:  MOVLW  00
06CE:  ADDWFC x1B,W
06D0:  MOVWF  x25
06D2:  MOVF   x1C,W
06D4:  ADDWF  x24,W
06D6:  MOVWF  FE9
06D8:  MOVF   x1D,W
06DA:  ADDWFC x25,W
06DC:  MOVWF  FEA
06DE:  MOVF   FEF,W
06E0:  XORWF  x1F,F
06E2:  MOVLW  04
06E4:  ADDWF  x1A,W
06E6:  MOVWF  x26
06E8:  MOVLW  00
06EA:  ADDWFC x1B,W
06EC:  MOVWF  x27
06EE:  MOVF   x1C,W
06F0:  ADDWF  x26,W
06F2:  MOVWF  FE9
06F4:  MOVF   x1D,W
06F6:  ADDWFC x27,W
06F8:  MOVWF  FEA
06FA:  MOVF   FEF,W
06FC:  XORWF  x1F,F
06FE:  MOVLW  05
0700:  ADDWF  x1A,W
0702:  MOVWF  x28
0704:  MOVLW  00
0706:  ADDWFC x1B,W
0708:  MOVWF  x29
070A:  MOVF   x1C,W
070C:  ADDWF  x28,W
070E:  MOVWF  FE9
0710:  MOVF   x1D,W
0712:  ADDWFC x29,W
0714:  MOVWF  FEA
0716:  MOVF   FEF,W
0718:  XORWF  x1F,W
071A:  BZ    0720
071C:  MOVLW  00
071E:  BRA    0722
0720:  MOVLW  01
0722:  MOVWF  x1E
....................       if(temp==datain[offset+6]) return 1; 
0724:  MOVLW  06
0726:  ADDWF  x1A,W
0728:  MOVWF  x1F
072A:  MOVLW  00
072C:  ADDWFC x1B,W
072E:  MOVWF  x20
0730:  MOVF   x1C,W
0732:  ADDWF  x1F,W
0734:  MOVWF  FE9
0736:  MOVF   x1D,W
0738:  ADDWFC x20,W
073A:  MOVWF  FEA
073C:  MOVF   FEF,W
073E:  SUBWF  x1E,W
0740:  BNZ   074A
0742:  MOVLW  01
0744:  MOVWF  01
0746:  BRA    0822
....................          else return 0; 
0748:  BRA    0750
074A:  MOVLW  00
074C:  MOVWF  01
074E:  BRA    0822
....................    } 
....................       else  
0750:  BRA    0822
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
0752:  MOVF   x1C,W
0754:  ADDWF  x1A,W
0756:  MOVWF  FE9
0758:  MOVF   x1D,W
075A:  ADDWFC x1B,W
075C:  MOVWF  FEA
075E:  MOVFF  FEF,B1F
0762:  MOVLW  01
0764:  SUBWF  x1A,W
0766:  MOVWF  x20
0768:  MOVLW  00
076A:  SUBWFB x1B,W
076C:  MOVWF  x21
076E:  MOVF   x1C,W
0770:  ADDWF  x20,W
0772:  MOVWF  FE9
0774:  MOVF   x1D,W
0776:  ADDWFC x21,W
0778:  MOVWF  FEA
077A:  MOVF   FEF,W
077C:  XORWF  x1F,F
077E:  MOVLW  02
0780:  SUBWF  x1A,W
0782:  MOVWF  x22
0784:  MOVLW  00
0786:  SUBWFB x1B,W
0788:  MOVWF  x23
078A:  MOVF   x1C,W
078C:  ADDWF  x22,W
078E:  MOVWF  FE9
0790:  MOVF   x1D,W
0792:  ADDWFC x23,W
0794:  MOVWF  FEA
0796:  MOVF   FEF,W
0798:  XORWF  x1F,F
079A:  MOVLW  03
079C:  SUBWF  x1A,W
079E:  MOVWF  x24
07A0:  MOVLW  00
07A2:  SUBWFB x1B,W
07A4:  MOVWF  x25
07A6:  MOVF   x1C,W
07A8:  ADDWF  x24,W
07AA:  MOVWF  FE9
07AC:  MOVF   x1D,W
07AE:  ADDWFC x25,W
07B0:  MOVWF  FEA
07B2:  MOVF   FEF,W
07B4:  XORWF  x1F,F
07B6:  MOVLW  04
07B8:  SUBWF  x1A,W
07BA:  MOVWF  x26
07BC:  MOVLW  00
07BE:  SUBWFB x1B,W
07C0:  MOVWF  x27
07C2:  MOVF   x1C,W
07C4:  ADDWF  x26,W
07C6:  MOVWF  FE9
07C8:  MOVF   x1D,W
07CA:  ADDWFC x27,W
07CC:  MOVWF  FEA
07CE:  MOVF   FEF,W
07D0:  XORWF  x1F,F
07D2:  MOVLW  05
07D4:  SUBWF  x1A,W
07D6:  MOVWF  x28
07D8:  MOVLW  00
07DA:  SUBWFB x1B,W
07DC:  MOVWF  x29
07DE:  MOVF   x1C,W
07E0:  ADDWF  x28,W
07E2:  MOVWF  FE9
07E4:  MOVF   x1D,W
07E6:  ADDWFC x29,W
07E8:  MOVWF  FEA
07EA:  MOVF   FEF,W
07EC:  XORWF  x1F,W
07EE:  BZ    07F4
07F0:  MOVLW  00
07F2:  BRA    07F6
07F4:  MOVLW  01
07F6:  MOVWF  x1E
....................          if(temp==datain[offset-6]) return 1; 
07F8:  MOVLW  06
07FA:  SUBWF  x1A,W
07FC:  MOVWF  x1F
07FE:  MOVLW  00
0800:  SUBWFB x1B,W
0802:  MOVWF  x20
0804:  MOVF   x1C,W
0806:  ADDWF  x1F,W
0808:  MOVWF  FE9
080A:  MOVF   x1D,W
080C:  ADDWFC x20,W
080E:  MOVWF  FEA
0810:  MOVF   FEF,W
0812:  SUBWF  x1E,W
0814:  BNZ   081E
0816:  MOVLW  01
0818:  MOVWF  01
081A:  BRA    0822
....................             else return 0;          
081C:  BRA    0822
081E:  MOVLW  00
0820:  MOVWF  01
....................       } 
.................... } 
0822:  MOVLB  0
0824:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
0826:  MOVLB  B
0828:  CLRF   x1E
....................    int8 temp=0; 
....................    if(direct==0) 
082A:  MOVF   x19,F
082C:  BNZ   08CA
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
082E:  MOVF   x1C,W
0830:  ADDWF  x1A,W
0832:  MOVWF  FE9
0834:  MOVF   x1D,W
0836:  ADDWFC x1B,W
0838:  MOVWF  FEA
083A:  MOVFF  FEF,B1F
083E:  MOVLW  01
0840:  ADDWF  x1A,W
0842:  MOVWF  x20
0844:  MOVLW  00
0846:  ADDWFC x1B,W
0848:  MOVWF  x21
084A:  MOVF   x1C,W
084C:  ADDWF  x20,W
084E:  MOVWF  FE9
0850:  MOVF   x1D,W
0852:  ADDWFC x21,W
0854:  MOVWF  FEA
0856:  MOVF   FEF,W
0858:  XORWF  x1F,F
085A:  MOVLW  02
085C:  ADDWF  x1A,W
085E:  MOVWF  x22
0860:  MOVLW  00
0862:  ADDWFC x1B,W
0864:  MOVWF  x23
0866:  MOVF   x1C,W
0868:  ADDWF  x22,W
086A:  MOVWF  FE9
086C:  MOVF   x1D,W
086E:  ADDWFC x23,W
0870:  MOVWF  FEA
0872:  MOVF   FEF,W
0874:  XORWF  x1F,F
0876:  MOVLW  03
0878:  ADDWF  x1A,W
087A:  MOVWF  x24
087C:  MOVLW  00
087E:  ADDWFC x1B,W
0880:  MOVWF  x25
0882:  MOVF   x1C,W
0884:  ADDWF  x24,W
0886:  MOVWF  FE9
0888:  MOVF   x1D,W
088A:  ADDWFC x25,W
088C:  MOVWF  FEA
088E:  MOVF   FEF,W
0890:  XORWF  x1F,W
0892:  BZ    0898
0894:  MOVLW  00
0896:  BRA    089A
0898:  MOVLW  01
089A:  MOVWF  x1E
....................       if(temp==datain[offset+4]) return 1; 
089C:  MOVLW  04
089E:  ADDWF  x1A,W
08A0:  MOVWF  x1F
08A2:  MOVLW  00
08A4:  ADDWFC x1B,W
08A6:  MOVWF  x20
08A8:  MOVF   x1C,W
08AA:  ADDWF  x1F,W
08AC:  MOVWF  FE9
08AE:  MOVF   x1D,W
08B0:  ADDWFC x20,W
08B2:  MOVWF  FEA
08B4:  MOVF   FEF,W
08B6:  SUBWF  x1E,W
08B8:  BNZ   08C2
08BA:  MOVLW  01
08BC:  MOVWF  01
08BE:  BRA    0962
....................          else return 0; 
08C0:  BRA    08C8
08C2:  MOVLW  00
08C4:  MOVWF  01
08C6:  BRA    0962
....................    } 
....................    else 
08C8:  BRA    0962
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
08CA:  MOVF   x1C,W
08CC:  ADDWF  x1A,W
08CE:  MOVWF  FE9
08D0:  MOVF   x1D,W
08D2:  ADDWFC x1B,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEF,B1F
08DA:  MOVLW  01
08DC:  SUBWF  x1A,W
08DE:  MOVWF  x20
08E0:  MOVLW  00
08E2:  SUBWFB x1B,W
08E4:  MOVWF  x21
08E6:  MOVF   x1C,W
08E8:  ADDWF  x20,W
08EA:  MOVWF  FE9
08EC:  MOVF   x1D,W
08EE:  ADDWFC x21,W
08F0:  MOVWF  FEA
08F2:  MOVF   FEF,W
08F4:  XORWF  x1F,F
08F6:  MOVLW  02
08F8:  SUBWF  x1A,W
08FA:  MOVWF  x22
08FC:  MOVLW  00
08FE:  SUBWFB x1B,W
0900:  MOVWF  x23
0902:  MOVF   x1C,W
0904:  ADDWF  x22,W
0906:  MOVWF  FE9
0908:  MOVF   x1D,W
090A:  ADDWFC x23,W
090C:  MOVWF  FEA
090E:  MOVF   FEF,W
0910:  XORWF  x1F,F
0912:  MOVLW  03
0914:  SUBWF  x1A,W
0916:  MOVWF  x24
0918:  MOVLW  00
091A:  SUBWFB x1B,W
091C:  MOVWF  x25
091E:  MOVF   x1C,W
0920:  ADDWF  x24,W
0922:  MOVWF  FE9
0924:  MOVF   x1D,W
0926:  ADDWFC x25,W
0928:  MOVWF  FEA
092A:  MOVF   FEF,W
092C:  XORWF  x1F,W
092E:  BZ    0934
0930:  MOVLW  00
0932:  BRA    0936
0934:  MOVLW  01
0936:  MOVWF  x1E
....................       if(temp==datain[offset-4]) return 1; 
0938:  MOVLW  04
093A:  SUBWF  x1A,W
093C:  MOVWF  x1F
093E:  MOVLW  00
0940:  SUBWFB x1B,W
0942:  MOVWF  x20
0944:  MOVF   x1C,W
0946:  ADDWF  x1F,W
0948:  MOVWF  FE9
094A:  MOVF   x1D,W
094C:  ADDWFC x20,W
094E:  MOVWF  FEA
0950:  MOVF   FEF,W
0952:  SUBWF  x1E,W
0954:  BNZ   095E
0956:  MOVLW  01
0958:  MOVWF  01
095A:  BRA    0962
....................          else return 0;                
095C:  BRA    0962
095E:  MOVLW  00
0960:  MOVWF  01
....................    } 
.................... } 
0962:  MOVLB  0
0964:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0966:  MOVLB  A
0968:  CLRF   xFD
096A:  CLRF   xFE
096C:  CLRF   xFF
096E:  MOVLB  B
0970:  CLRF   x00
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0972:  MOVLB  A
0974:  CLRF   xFA
0976:  CLRF   xF9
0978:  RRCF   xF6,W
097A:  MOVWF  03
097C:  RRCF   xF5,W
097E:  MOVWF  02
0980:  RRCF   03,F
0982:  RRCF   02,F
0984:  MOVLW  3F
0986:  ANDWF  03,F
0988:  MOVFF  02,01
098C:  MOVF   xFA,W
098E:  SUBWF  03,W
0990:  BTFSS  FD8.0
0992:  GOTO   1184
0996:  BNZ   09A2
0998:  MOVF   01,W
099A:  SUBWF  xF9,W
099C:  BTFSC  FD8.0
099E:  GOTO   1184
....................    { 
....................       if(track==0) 
09A2:  MOVF   xF4,F
09A4:  BTFSS  FD8.2
09A6:  BRA    0E1C
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
09A8:  MOVLW  06
09AA:  ADDWF  xF9,W
09AC:  MOVLB  B
09AE:  MOVWF  x01
09B0:  MOVLW  00
09B2:  MOVLB  A
09B4:  ADDWFC xFA,W
09B6:  MOVLB  B
09B8:  MOVWF  x02
09BA:  MOVLB  A
09BC:  MOVF   xF7,W
09BE:  MOVLB  B
09C0:  ADDWF  x01,W
09C2:  MOVWF  FE9
09C4:  MOVLB  A
09C6:  MOVF   xF8,W
09C8:  MOVLB  B
09CA:  ADDWFC x02,W
09CC:  MOVWF  FEA
09CE:  MOVFF  FEF,B03
09D2:  MOVLW  05
09D4:  MOVLB  A
09D6:  ADDWF  xF9,W
09D8:  MOVLB  B
09DA:  MOVWF  x04
09DC:  MOVLW  00
09DE:  MOVLB  A
09E0:  ADDWFC xFA,W
09E2:  MOVLB  B
09E4:  MOVWF  x05
09E6:  MOVLB  A
09E8:  MOVF   xF7,W
09EA:  MOVLB  B
09EC:  ADDWF  x04,W
09EE:  MOVWF  FE9
09F0:  MOVLB  A
09F2:  MOVF   xF8,W
09F4:  MOVLB  B
09F6:  ADDWFC x05,W
09F8:  MOVWF  FEA
09FA:  MOVFF  FEF,B06
09FE:  MOVLW  04
0A00:  MOVLB  A
0A02:  ADDWF  xF9,W
0A04:  MOVLB  B
0A06:  MOVWF  x07
0A08:  MOVLW  00
0A0A:  MOVLB  A
0A0C:  ADDWFC xFA,W
0A0E:  MOVLB  B
0A10:  MOVWF  x08
0A12:  MOVLB  A
0A14:  MOVF   xF7,W
0A16:  MOVLB  B
0A18:  ADDWF  x07,W
0A1A:  MOVWF  FE9
0A1C:  MOVLB  A
0A1E:  MOVF   xF8,W
0A20:  MOVLB  B
0A22:  ADDWFC x08,W
0A24:  MOVWF  FEA
0A26:  MOVFF  FEF,B09
0A2A:  MOVLW  03
0A2C:  MOVLB  A
0A2E:  ADDWF  xF9,W
0A30:  MOVLB  B
0A32:  MOVWF  x0A
0A34:  MOVLW  00
0A36:  MOVLB  A
0A38:  ADDWFC xFA,W
0A3A:  MOVLB  B
0A3C:  MOVWF  x0B
0A3E:  MOVLB  A
0A40:  MOVF   xF7,W
0A42:  MOVLB  B
0A44:  ADDWF  x0A,W
0A46:  MOVWF  FE9
0A48:  MOVLB  A
0A4A:  MOVF   xF8,W
0A4C:  MOVLB  B
0A4E:  ADDWFC x0B,W
0A50:  MOVWF  FEA
0A52:  MOVFF  FEF,B0C
0A56:  MOVLW  02
0A58:  MOVLB  A
0A5A:  ADDWF  xF9,W
0A5C:  MOVLB  B
0A5E:  MOVWF  x0D
0A60:  MOVLW  00
0A62:  MOVLB  A
0A64:  ADDWFC xFA,W
0A66:  MOVLB  B
0A68:  MOVWF  x0E
0A6A:  MOVLB  A
0A6C:  MOVF   xF7,W
0A6E:  MOVLB  B
0A70:  ADDWF  x0D,W
0A72:  MOVWF  FE9
0A74:  MOVLB  A
0A76:  MOVF   xF8,W
0A78:  MOVLB  B
0A7A:  ADDWFC x0E,W
0A7C:  MOVWF  FEA
0A7E:  MOVFF  FEF,B0F
0A82:  MOVLW  01
0A84:  MOVLB  A
0A86:  ADDWF  xF9,W
0A88:  MOVLB  B
0A8A:  MOVWF  x10
0A8C:  MOVLW  00
0A8E:  MOVLB  A
0A90:  ADDWFC xFA,W
0A92:  MOVLB  B
0A94:  MOVWF  x11
0A96:  MOVLB  A
0A98:  MOVF   xF7,W
0A9A:  MOVLB  B
0A9C:  ADDWF  x10,W
0A9E:  MOVWF  FE9
0AA0:  MOVLB  A
0AA2:  MOVF   xF8,W
0AA4:  MOVLB  B
0AA6:  ADDWFC x11,W
0AA8:  MOVWF  FEA
0AAA:  MOVFF  FEF,B12
0AAE:  MOVLB  A
0AB0:  MOVF   xF7,W
0AB2:  ADDWF  xF9,W
0AB4:  MOVWF  FE9
0AB6:  MOVF   xF8,W
0AB8:  ADDWFC xFA,W
0ABA:  MOVWF  FEA
0ABC:  MOVFF  FEF,B13
0AC0:  MOVLB  B
0AC2:  CLRF   x2E
0AC4:  MOVFF  B03,B2F
0AC8:  MOVFF  B06,B30
0ACC:  MOVFF  B09,B31
0AD0:  MOVFF  B0C,B32
0AD4:  MOVFF  B0F,B33
0AD8:  MOVFF  B12,B34
0ADC:  MOVFF  B13,B35
0AE0:  MOVLB  0
0AE2:  RCALL  0610
0AE4:  MOVFF  01,AFD
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0AE8:  MOVLW  0D
0AEA:  MOVLB  A
0AEC:  ADDWF  xF9,W
0AEE:  MOVLB  B
0AF0:  MOVWF  x01
0AF2:  MOVLW  00
0AF4:  MOVLB  A
0AF6:  ADDWFC xFA,W
0AF8:  MOVLB  B
0AFA:  MOVWF  x02
0AFC:  MOVLB  A
0AFE:  MOVF   xF7,W
0B00:  MOVLB  B
0B02:  ADDWF  x01,W
0B04:  MOVWF  FE9
0B06:  MOVLB  A
0B08:  MOVF   xF8,W
0B0A:  MOVLB  B
0B0C:  ADDWFC x02,W
0B0E:  MOVWF  FEA
0B10:  MOVFF  FEF,B03
0B14:  MOVLW  0C
0B16:  MOVLB  A
0B18:  ADDWF  xF9,W
0B1A:  MOVLB  B
0B1C:  MOVWF  x04
0B1E:  MOVLW  00
0B20:  MOVLB  A
0B22:  ADDWFC xFA,W
0B24:  MOVLB  B
0B26:  MOVWF  x05
0B28:  MOVLB  A
0B2A:  MOVF   xF7,W
0B2C:  MOVLB  B
0B2E:  ADDWF  x04,W
0B30:  MOVWF  FE9
0B32:  MOVLB  A
0B34:  MOVF   xF8,W
0B36:  MOVLB  B
0B38:  ADDWFC x05,W
0B3A:  MOVWF  FEA
0B3C:  MOVFF  FEF,B06
0B40:  MOVLW  0B
0B42:  MOVLB  A
0B44:  ADDWF  xF9,W
0B46:  MOVLB  B
0B48:  MOVWF  x07
0B4A:  MOVLW  00
0B4C:  MOVLB  A
0B4E:  ADDWFC xFA,W
0B50:  MOVLB  B
0B52:  MOVWF  x08
0B54:  MOVLB  A
0B56:  MOVF   xF7,W
0B58:  MOVLB  B
0B5A:  ADDWF  x07,W
0B5C:  MOVWF  FE9
0B5E:  MOVLB  A
0B60:  MOVF   xF8,W
0B62:  MOVLB  B
0B64:  ADDWFC x08,W
0B66:  MOVWF  FEA
0B68:  MOVFF  FEF,B09
0B6C:  MOVLW  0A
0B6E:  MOVLB  A
0B70:  ADDWF  xF9,W
0B72:  MOVLB  B
0B74:  MOVWF  x0A
0B76:  MOVLW  00
0B78:  MOVLB  A
0B7A:  ADDWFC xFA,W
0B7C:  MOVLB  B
0B7E:  MOVWF  x0B
0B80:  MOVLB  A
0B82:  MOVF   xF7,W
0B84:  MOVLB  B
0B86:  ADDWF  x0A,W
0B88:  MOVWF  FE9
0B8A:  MOVLB  A
0B8C:  MOVF   xF8,W
0B8E:  MOVLB  B
0B90:  ADDWFC x0B,W
0B92:  MOVWF  FEA
0B94:  MOVFF  FEF,B0C
0B98:  MOVLW  09
0B9A:  MOVLB  A
0B9C:  ADDWF  xF9,W
0B9E:  MOVLB  B
0BA0:  MOVWF  x0D
0BA2:  MOVLW  00
0BA4:  MOVLB  A
0BA6:  ADDWFC xFA,W
0BA8:  MOVLB  B
0BAA:  MOVWF  x0E
0BAC:  MOVLB  A
0BAE:  MOVF   xF7,W
0BB0:  MOVLB  B
0BB2:  ADDWF  x0D,W
0BB4:  MOVWF  FE9
0BB6:  MOVLB  A
0BB8:  MOVF   xF8,W
0BBA:  MOVLB  B
0BBC:  ADDWFC x0E,W
0BBE:  MOVWF  FEA
0BC0:  MOVFF  FEF,B0F
0BC4:  MOVLW  08
0BC6:  MOVLB  A
0BC8:  ADDWF  xF9,W
0BCA:  MOVLB  B
0BCC:  MOVWF  x10
0BCE:  MOVLW  00
0BD0:  MOVLB  A
0BD2:  ADDWFC xFA,W
0BD4:  MOVLB  B
0BD6:  MOVWF  x11
0BD8:  MOVLB  A
0BDA:  MOVF   xF7,W
0BDC:  MOVLB  B
0BDE:  ADDWF  x10,W
0BE0:  MOVWF  FE9
0BE2:  MOVLB  A
0BE4:  MOVF   xF8,W
0BE6:  MOVLB  B
0BE8:  ADDWFC x11,W
0BEA:  MOVWF  FEA
0BEC:  MOVFF  FEF,B12
0BF0:  MOVLW  07
0BF2:  MOVLB  A
0BF4:  ADDWF  xF9,W
0BF6:  MOVLB  B
0BF8:  MOVWF  x13
0BFA:  MOVLW  00
0BFC:  MOVLB  A
0BFE:  ADDWFC xFA,W
0C00:  MOVLB  B
0C02:  MOVWF  x14
0C04:  MOVLB  A
0C06:  MOVF   xF7,W
0C08:  MOVLB  B
0C0A:  ADDWF  x13,W
0C0C:  MOVWF  FE9
0C0E:  MOVLB  A
0C10:  MOVF   xF8,W
0C12:  MOVLB  B
0C14:  ADDWFC x14,W
0C16:  MOVWF  FEA
0C18:  MOVFF  FEF,B15
0C1C:  CLRF   x2E
0C1E:  MOVFF  B03,B2F
0C22:  MOVFF  B06,B30
0C26:  MOVFF  B09,B31
0C2A:  MOVFF  B0C,B32
0C2E:  MOVFF  B0F,B33
0C32:  MOVFF  B12,B34
0C36:  MOVFF  B15,B35
0C3A:  MOVLB  0
0C3C:  RCALL  0610
0C3E:  MOVFF  01,AFE
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0C42:  MOVLB  A
0C44:  MOVF   xFD,W
0C46:  SUBLW  45
0C48:  BTFSS  FD8.2
0C4A:  BRA    0E16
0C4C:  MOVF   xFE,W
0C4E:  SUBLW  7C
0C50:  BTFSC  FD8.2
0C52:  BRA    0E16
0C54:  MOVF   xFE,W
0C56:  SUBLW  3E
0C58:  BTFSC  FD8.2
0C5A:  BRA    0E16
0C5C:  MOVF   xFE,W
0C5E:  SUBLW  1F
0C60:  BTFSC  FD8.2
0C62:  BRA    0E16
....................          { 
....................             j=i; 
0C64:  MOVFF  AFA,AFC
0C68:  MOVFF  AF9,AFB
....................             CRC=1; 
0C6C:  MOVLW  01
0C6E:  MOVLB  B
0C70:  MOVWF  x00
....................             temp2=temp; 
0C72:  MOVFF  AFD,AFF
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0C76:  MOVLB  A
0C78:  MOVF   xFF,W
0C7A:  SUBLW  1F
0C7C:  BTFSC  FD8.2
0C7E:  BRA    0DFE
0C80:  MOVF   xFC,W
0C82:  SUBLW  03
0C84:  BTFSS  FD8.0
0C86:  BRA    0DFE
0C88:  BNZ   0C92
0C8A:  MOVF   xFB,W
0C8C:  SUBLW  E7
0C8E:  BTFSS  FD8.0
0C90:  BRA    0DFE
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C92:  MOVLB  B
0C94:  CLRF   x19
0C96:  MOVFF  AFC,B1B
0C9A:  MOVFF  AFB,B1A
0C9E:  MOVFF  AF8,B1D
0CA2:  MOVFF  AF7,B1C
0CA6:  MOVLB  0
0CA8:  RCALL  0676
0CAA:  MOVF   01,W
0CAC:  MOVLB  B
0CAE:  ANDWF  x00,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0CB0:  MOVLW  06
0CB2:  MOVLB  A
0CB4:  ADDWF  xFB,W
0CB6:  MOVLB  B
0CB8:  MOVWF  x01
0CBA:  MOVLW  00
0CBC:  MOVLB  A
0CBE:  ADDWFC xFC,W
0CC0:  MOVLB  B
0CC2:  MOVWF  x02
0CC4:  MOVLB  A
0CC6:  MOVF   xF7,W
0CC8:  MOVLB  B
0CCA:  ADDWF  x01,W
0CCC:  MOVWF  FE9
0CCE:  MOVLB  A
0CD0:  MOVF   xF8,W
0CD2:  MOVLB  B
0CD4:  ADDWFC x02,W
0CD6:  MOVWF  FEA
0CD8:  MOVFF  FEF,B03
0CDC:  MOVLW  05
0CDE:  MOVLB  A
0CE0:  ADDWF  xFB,W
0CE2:  MOVLB  B
0CE4:  MOVWF  x04
0CE6:  MOVLW  00
0CE8:  MOVLB  A
0CEA:  ADDWFC xFC,W
0CEC:  MOVLB  B
0CEE:  MOVWF  x05
0CF0:  MOVLB  A
0CF2:  MOVF   xF7,W
0CF4:  MOVLB  B
0CF6:  ADDWF  x04,W
0CF8:  MOVWF  FE9
0CFA:  MOVLB  A
0CFC:  MOVF   xF8,W
0CFE:  MOVLB  B
0D00:  ADDWFC x05,W
0D02:  MOVWF  FEA
0D04:  MOVFF  FEF,B06
0D08:  MOVLW  04
0D0A:  MOVLB  A
0D0C:  ADDWF  xFB,W
0D0E:  MOVLB  B
0D10:  MOVWF  x07
0D12:  MOVLW  00
0D14:  MOVLB  A
0D16:  ADDWFC xFC,W
0D18:  MOVLB  B
0D1A:  MOVWF  x08
0D1C:  MOVLB  A
0D1E:  MOVF   xF7,W
0D20:  MOVLB  B
0D22:  ADDWF  x07,W
0D24:  MOVWF  FE9
0D26:  MOVLB  A
0D28:  MOVF   xF8,W
0D2A:  MOVLB  B
0D2C:  ADDWFC x08,W
0D2E:  MOVWF  FEA
0D30:  MOVFF  FEF,B09
0D34:  MOVLW  03
0D36:  MOVLB  A
0D38:  ADDWF  xFB,W
0D3A:  MOVLB  B
0D3C:  MOVWF  x0A
0D3E:  MOVLW  00
0D40:  MOVLB  A
0D42:  ADDWFC xFC,W
0D44:  MOVLB  B
0D46:  MOVWF  x0B
0D48:  MOVLB  A
0D4A:  MOVF   xF7,W
0D4C:  MOVLB  B
0D4E:  ADDWF  x0A,W
0D50:  MOVWF  FE9
0D52:  MOVLB  A
0D54:  MOVF   xF8,W
0D56:  MOVLB  B
0D58:  ADDWFC x0B,W
0D5A:  MOVWF  FEA
0D5C:  MOVFF  FEF,B0C
0D60:  MOVLW  02
0D62:  MOVLB  A
0D64:  ADDWF  xFB,W
0D66:  MOVLB  B
0D68:  MOVWF  x0D
0D6A:  MOVLW  00
0D6C:  MOVLB  A
0D6E:  ADDWFC xFC,W
0D70:  MOVLB  B
0D72:  MOVWF  x0E
0D74:  MOVLB  A
0D76:  MOVF   xF7,W
0D78:  MOVLB  B
0D7A:  ADDWF  x0D,W
0D7C:  MOVWF  FE9
0D7E:  MOVLB  A
0D80:  MOVF   xF8,W
0D82:  MOVLB  B
0D84:  ADDWFC x0E,W
0D86:  MOVWF  FEA
0D88:  MOVFF  FEF,B0F
0D8C:  MOVLW  01
0D8E:  MOVLB  A
0D90:  ADDWF  xFB,W
0D92:  MOVLB  B
0D94:  MOVWF  x10
0D96:  MOVLW  00
0D98:  MOVLB  A
0D9A:  ADDWFC xFC,W
0D9C:  MOVLB  B
0D9E:  MOVWF  x11
0DA0:  MOVLB  A
0DA2:  MOVF   xF7,W
0DA4:  MOVLB  B
0DA6:  ADDWF  x10,W
0DA8:  MOVWF  FE9
0DAA:  MOVLB  A
0DAC:  MOVF   xF8,W
0DAE:  MOVLB  B
0DB0:  ADDWFC x11,W
0DB2:  MOVWF  FEA
0DB4:  MOVFF  FEF,B12
0DB8:  MOVLB  A
0DBA:  MOVF   xF7,W
0DBC:  ADDWF  xFB,W
0DBE:  MOVWF  FE9
0DC0:  MOVF   xF8,W
0DC2:  ADDWFC xFC,W
0DC4:  MOVWF  FEA
0DC6:  MOVFF  FEF,B13
0DCA:  MOVLB  B
0DCC:  CLRF   x2E
0DCE:  MOVFF  B03,B2F
0DD2:  MOVFF  B06,B30
0DD6:  MOVFF  B09,B31
0DDA:  MOVFF  B0C,B32
0DDE:  MOVFF  B0F,B33
0DE2:  MOVFF  B12,B34
0DE6:  MOVFF  B13,B35
0DEA:  MOVLB  0
0DEC:  RCALL  0610
0DEE:  MOVFF  01,AFF
....................                j=j+7; 
0DF2:  MOVLW  07
0DF4:  MOVLB  A
0DF6:  ADDWF  xFB,F
0DF8:  MOVLW  00
0DFA:  ADDWFC xFC,F
....................             } 
0DFC:  BRA    0C78
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0DFE:  MOVLB  B
0E00:  DECFSZ x00,W
0E02:  BRA    0E18
....................             { 
....................                dir=0; 
0E04:  MOVLB  9
0E06:  CLRF   x91
....................                return i; 
0E08:  MOVLB  A
0E0A:  MOVFF  AF9,01
0E0E:  MOVFF  AFA,02
0E12:  GOTO   19C4
0E16:  MOVLB  B
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0E18:  BRA    1178
0E1A:  MOVLB  A
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0E1C:  MOVLW  04
0E1E:  ADDWF  xF9,W
0E20:  MOVLB  B
0E22:  MOVWF  x01
0E24:  MOVLW  00
0E26:  MOVLB  A
0E28:  ADDWFC xFA,W
0E2A:  MOVLB  B
0E2C:  MOVWF  x02
0E2E:  MOVLB  A
0E30:  MOVF   xF7,W
0E32:  MOVLB  B
0E34:  ADDWF  x01,W
0E36:  MOVWF  FE9
0E38:  MOVLB  A
0E3A:  MOVF   xF8,W
0E3C:  MOVLB  B
0E3E:  ADDWFC x02,W
0E40:  MOVWF  FEA
0E42:  MOVFF  FEF,B03
0E46:  MOVLW  03
0E48:  MOVLB  A
0E4A:  ADDWF  xF9,W
0E4C:  MOVLB  B
0E4E:  MOVWF  x04
0E50:  MOVLW  00
0E52:  MOVLB  A
0E54:  ADDWFC xFA,W
0E56:  MOVLB  B
0E58:  MOVWF  x05
0E5A:  MOVLB  A
0E5C:  MOVF   xF7,W
0E5E:  MOVLB  B
0E60:  ADDWF  x04,W
0E62:  MOVWF  FE9
0E64:  MOVLB  A
0E66:  MOVF   xF8,W
0E68:  MOVLB  B
0E6A:  ADDWFC x05,W
0E6C:  MOVWF  FEA
0E6E:  MOVFF  FEF,B06
0E72:  MOVLW  02
0E74:  MOVLB  A
0E76:  ADDWF  xF9,W
0E78:  MOVLB  B
0E7A:  MOVWF  x07
0E7C:  MOVLW  00
0E7E:  MOVLB  A
0E80:  ADDWFC xFA,W
0E82:  MOVLB  B
0E84:  MOVWF  x08
0E86:  MOVLB  A
0E88:  MOVF   xF7,W
0E8A:  MOVLB  B
0E8C:  ADDWF  x07,W
0E8E:  MOVWF  FE9
0E90:  MOVLB  A
0E92:  MOVF   xF8,W
0E94:  MOVLB  B
0E96:  ADDWFC x08,W
0E98:  MOVWF  FEA
0E9A:  MOVFF  FEF,B09
0E9E:  MOVLW  01
0EA0:  MOVLB  A
0EA2:  ADDWF  xF9,W
0EA4:  MOVLB  B
0EA6:  MOVWF  x0A
0EA8:  MOVLW  00
0EAA:  MOVLB  A
0EAC:  ADDWFC xFA,W
0EAE:  MOVLB  B
0EB0:  MOVWF  x0B
0EB2:  MOVLB  A
0EB4:  MOVF   xF7,W
0EB6:  MOVLB  B
0EB8:  ADDWF  x0A,W
0EBA:  MOVWF  FE9
0EBC:  MOVLB  A
0EBE:  MOVF   xF8,W
0EC0:  MOVLB  B
0EC2:  ADDWFC x0B,W
0EC4:  MOVWF  FEA
0EC6:  MOVFF  FEF,B0C
0ECA:  MOVLB  A
0ECC:  MOVF   xF7,W
0ECE:  ADDWF  xF9,W
0ED0:  MOVWF  FE9
0ED2:  MOVF   xF8,W
0ED4:  ADDWFC xFA,W
0ED6:  MOVWF  FEA
0ED8:  MOVFF  FEF,B0D
0EDC:  MOVLB  B
0EDE:  CLRF   x2E
0EE0:  CLRF   x2F
0EE2:  CLRF   x30
0EE4:  MOVFF  B03,B31
0EE8:  MOVFF  B06,B32
0EEC:  MOVFF  B09,B33
0EF0:  MOVFF  B0C,B34
0EF4:  MOVFF  B0D,B35
0EF8:  MOVLB  0
0EFA:  CALL   0610
0EFE:  MOVFF  01,AFD
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0F02:  MOVLW  09
0F04:  MOVLB  A
0F06:  ADDWF  xF9,W
0F08:  MOVLB  B
0F0A:  MOVWF  x01
0F0C:  MOVLW  00
0F0E:  MOVLB  A
0F10:  ADDWFC xFA,W
0F12:  MOVLB  B
0F14:  MOVWF  x02
0F16:  MOVLB  A
0F18:  MOVF   xF7,W
0F1A:  MOVLB  B
0F1C:  ADDWF  x01,W
0F1E:  MOVWF  FE9
0F20:  MOVLB  A
0F22:  MOVF   xF8,W
0F24:  MOVLB  B
0F26:  ADDWFC x02,W
0F28:  MOVWF  FEA
0F2A:  MOVFF  FEF,B03
0F2E:  MOVLW  08
0F30:  MOVLB  A
0F32:  ADDWF  xF9,W
0F34:  MOVLB  B
0F36:  MOVWF  x04
0F38:  MOVLW  00
0F3A:  MOVLB  A
0F3C:  ADDWFC xFA,W
0F3E:  MOVLB  B
0F40:  MOVWF  x05
0F42:  MOVLB  A
0F44:  MOVF   xF7,W
0F46:  MOVLB  B
0F48:  ADDWF  x04,W
0F4A:  MOVWF  FE9
0F4C:  MOVLB  A
0F4E:  MOVF   xF8,W
0F50:  MOVLB  B
0F52:  ADDWFC x05,W
0F54:  MOVWF  FEA
0F56:  MOVFF  FEF,B06
0F5A:  MOVLW  07
0F5C:  MOVLB  A
0F5E:  ADDWF  xF9,W
0F60:  MOVLB  B
0F62:  MOVWF  x07
0F64:  MOVLW  00
0F66:  MOVLB  A
0F68:  ADDWFC xFA,W
0F6A:  MOVLB  B
0F6C:  MOVWF  x08
0F6E:  MOVLB  A
0F70:  MOVF   xF7,W
0F72:  MOVLB  B
0F74:  ADDWF  x07,W
0F76:  MOVWF  FE9
0F78:  MOVLB  A
0F7A:  MOVF   xF8,W
0F7C:  MOVLB  B
0F7E:  ADDWFC x08,W
0F80:  MOVWF  FEA
0F82:  MOVFF  FEF,B09
0F86:  MOVLW  06
0F88:  MOVLB  A
0F8A:  ADDWF  xF9,W
0F8C:  MOVLB  B
0F8E:  MOVWF  x0A
0F90:  MOVLW  00
0F92:  MOVLB  A
0F94:  ADDWFC xFA,W
0F96:  MOVLB  B
0F98:  MOVWF  x0B
0F9A:  MOVLB  A
0F9C:  MOVF   xF7,W
0F9E:  MOVLB  B
0FA0:  ADDWF  x0A,W
0FA2:  MOVWF  FE9
0FA4:  MOVLB  A
0FA6:  MOVF   xF8,W
0FA8:  MOVLB  B
0FAA:  ADDWFC x0B,W
0FAC:  MOVWF  FEA
0FAE:  MOVFF  FEF,B0C
0FB2:  MOVLW  05
0FB4:  MOVLB  A
0FB6:  ADDWF  xF9,W
0FB8:  MOVLB  B
0FBA:  MOVWF  x0D
0FBC:  MOVLW  00
0FBE:  MOVLB  A
0FC0:  ADDWFC xFA,W
0FC2:  MOVLB  B
0FC4:  MOVWF  x0E
0FC6:  MOVLB  A
0FC8:  MOVF   xF7,W
0FCA:  MOVLB  B
0FCC:  ADDWF  x0D,W
0FCE:  MOVWF  FE9
0FD0:  MOVLB  A
0FD2:  MOVF   xF8,W
0FD4:  MOVLB  B
0FD6:  ADDWFC x0E,W
0FD8:  MOVWF  FEA
0FDA:  MOVFF  FEF,B0F
0FDE:  CLRF   x2E
0FE0:  CLRF   x2F
0FE2:  CLRF   x30
0FE4:  MOVFF  B03,B31
0FE8:  MOVFF  B06,B32
0FEC:  MOVFF  B09,B33
0FF0:  MOVFF  B0C,B34
0FF4:  MOVFF  B0F,B35
0FF8:  MOVLB  0
0FFA:  CALL   0610
0FFE:  MOVFF  01,AFE
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
1002:  MOVLB  A
1004:  MOVF   xFD,W
1006:  SUBLW  0B
1008:  BTFSS  FD8.2
100A:  BRA    1176
100C:  MOVF   xFE,W
100E:  SUBLW  1F
1010:  BTFSC  FD8.2
1012:  BRA    1176
1014:  MOVF   xFE,W
1016:  SUBLW  0F
1018:  BTFSC  FD8.2
101A:  BRA    1176
....................             { 
....................                j=i; 
101C:  MOVFF  AFA,AFC
1020:  MOVFF  AF9,AFB
....................                CRC=1; 
1024:  MOVLW  01
1026:  MOVLB  B
1028:  MOVWF  x00
....................                temp2=temp; 
102A:  MOVFF  AFD,AFF
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
102E:  MOVLB  A
1030:  MOVF   xFF,W
1032:  SUBLW  1F
1034:  BTFSC  FD8.2
1036:  BRA    115E
1038:  MOVF   xFC,W
103A:  SUBLW  01
103C:  BTFSS  FD8.0
103E:  BRA    115E
1040:  BNZ   104A
1042:  MOVF   xFB,W
1044:  SUBLW  F3
1046:  BTFSS  FD8.0
1048:  BRA    115E
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
104A:  MOVLB  B
104C:  CLRF   x19
104E:  MOVFF  AFC,B1B
1052:  MOVFF  AFB,B1A
1056:  MOVFF  AF8,B1D
105A:  MOVFF  AF7,B1C
105E:  MOVLB  0
1060:  CALL   0826
1064:  MOVF   01,W
1066:  MOVLB  B
1068:  ANDWF  x00,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
106A:  MOVLW  04
106C:  MOVLB  A
106E:  ADDWF  xFB,W
1070:  MOVLB  B
1072:  MOVWF  x01
1074:  MOVLW  00
1076:  MOVLB  A
1078:  ADDWFC xFC,W
107A:  MOVLB  B
107C:  MOVWF  x02
107E:  MOVLB  A
1080:  MOVF   xF7,W
1082:  MOVLB  B
1084:  ADDWF  x01,W
1086:  MOVWF  FE9
1088:  MOVLB  A
108A:  MOVF   xF8,W
108C:  MOVLB  B
108E:  ADDWFC x02,W
1090:  MOVWF  FEA
1092:  MOVFF  FEF,B03
1096:  MOVLW  03
1098:  MOVLB  A
109A:  ADDWF  xFB,W
109C:  MOVLB  B
109E:  MOVWF  x04
10A0:  MOVLW  00
10A2:  MOVLB  A
10A4:  ADDWFC xFC,W
10A6:  MOVLB  B
10A8:  MOVWF  x05
10AA:  MOVLB  A
10AC:  MOVF   xF7,W
10AE:  MOVLB  B
10B0:  ADDWF  x04,W
10B2:  MOVWF  FE9
10B4:  MOVLB  A
10B6:  MOVF   xF8,W
10B8:  MOVLB  B
10BA:  ADDWFC x05,W
10BC:  MOVWF  FEA
10BE:  MOVFF  FEF,B06
10C2:  MOVLW  02
10C4:  MOVLB  A
10C6:  ADDWF  xFB,W
10C8:  MOVLB  B
10CA:  MOVWF  x07
10CC:  MOVLW  00
10CE:  MOVLB  A
10D0:  ADDWFC xFC,W
10D2:  MOVLB  B
10D4:  MOVWF  x08
10D6:  MOVLB  A
10D8:  MOVF   xF7,W
10DA:  MOVLB  B
10DC:  ADDWF  x07,W
10DE:  MOVWF  FE9
10E0:  MOVLB  A
10E2:  MOVF   xF8,W
10E4:  MOVLB  B
10E6:  ADDWFC x08,W
10E8:  MOVWF  FEA
10EA:  MOVFF  FEF,B09
10EE:  MOVLW  01
10F0:  MOVLB  A
10F2:  ADDWF  xFB,W
10F4:  MOVLB  B
10F6:  MOVWF  x0A
10F8:  MOVLW  00
10FA:  MOVLB  A
10FC:  ADDWFC xFC,W
10FE:  MOVLB  B
1100:  MOVWF  x0B
1102:  MOVLB  A
1104:  MOVF   xF7,W
1106:  MOVLB  B
1108:  ADDWF  x0A,W
110A:  MOVWF  FE9
110C:  MOVLB  A
110E:  MOVF   xF8,W
1110:  MOVLB  B
1112:  ADDWFC x0B,W
1114:  MOVWF  FEA
1116:  MOVFF  FEF,B0C
111A:  MOVLB  A
111C:  MOVF   xF7,W
111E:  ADDWF  xFB,W
1120:  MOVWF  FE9
1122:  MOVF   xF8,W
1124:  ADDWFC xFC,W
1126:  MOVWF  FEA
1128:  MOVFF  FEF,B0D
112C:  MOVLB  B
112E:  CLRF   x2E
1130:  CLRF   x2F
1132:  CLRF   x30
1134:  MOVFF  B03,B31
1138:  MOVFF  B06,B32
113C:  MOVFF  B09,B33
1140:  MOVFF  B0C,B34
1144:  MOVFF  B0D,B35
1148:  MOVLB  0
114A:  CALL   0610
114E:  MOVFF  01,AFF
....................                   j=j+5; 
1152:  MOVLW  05
1154:  MOVLB  A
1156:  ADDWF  xFB,F
1158:  MOVLW  00
115A:  ADDWFC xFC,F
....................                } 
115C:  BRA    1030
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
115E:  MOVLB  B
1160:  DECFSZ x00,W
1162:  BRA    1178
....................                { 
....................                   dir=0; 
1164:  MOVLB  9
1166:  CLRF   x91
....................                   return i; 
1168:  MOVLB  A
116A:  MOVFF  AF9,01
116E:  MOVFF  AFA,02
1172:  GOTO   19C4
1176:  MOVLB  B
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
1178:  MOVLB  A
117A:  INCF   xF9,F
117C:  BTFSC  FD8.2
117E:  INCF   xFA,F
1180:  GOTO   0978
....................    for(i=end_point;i>end_point/4;i--) 
1184:  MOVFF  AF6,AFA
1188:  MOVFF  AF5,AF9
118C:  RRCF   xF6,W
118E:  MOVWF  03
1190:  RRCF   xF5,W
1192:  MOVWF  02
1194:  RRCF   03,F
1196:  RRCF   02,F
1198:  MOVLW  3F
119A:  ANDWF  03,F
119C:  MOVFF  02,01
11A0:  MOVF   03,W
11A2:  SUBWF  xFA,W
11A4:  BTFSS  FD8.0
11A6:  GOTO   19BE
11AA:  BNZ   11B6
11AC:  MOVF   xF9,W
11AE:  SUBWF  01,W
11B0:  BTFSC  FD8.0
11B2:  GOTO   19BE
....................    { 
....................       if(track==0) 
11B6:  MOVF   xF4,F
11B8:  BTFSS  FD8.2
11BA:  BRA    164E
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
11BC:  MOVLW  06
11BE:  SUBWF  xF9,W
11C0:  MOVLB  B
11C2:  MOVWF  x01
11C4:  MOVLW  00
11C6:  MOVLB  A
11C8:  SUBWFB xFA,W
11CA:  MOVLB  B
11CC:  MOVWF  x02
11CE:  MOVLB  A
11D0:  MOVF   xF7,W
11D2:  MOVLB  B
11D4:  ADDWF  x01,W
11D6:  MOVWF  FE9
11D8:  MOVLB  A
11DA:  MOVF   xF8,W
11DC:  MOVLB  B
11DE:  ADDWFC x02,W
11E0:  MOVWF  FEA
11E2:  MOVFF  FEF,B03
11E6:  MOVLW  05
11E8:  MOVLB  A
11EA:  SUBWF  xF9,W
11EC:  MOVLB  B
11EE:  MOVWF  x04
11F0:  MOVLW  00
11F2:  MOVLB  A
11F4:  SUBWFB xFA,W
11F6:  MOVLB  B
11F8:  MOVWF  x05
11FA:  MOVLB  A
11FC:  MOVF   xF7,W
11FE:  MOVLB  B
1200:  ADDWF  x04,W
1202:  MOVWF  FE9
1204:  MOVLB  A
1206:  MOVF   xF8,W
1208:  MOVLB  B
120A:  ADDWFC x05,W
120C:  MOVWF  FEA
120E:  MOVFF  FEF,B06
1212:  MOVLW  04
1214:  MOVLB  A
1216:  SUBWF  xF9,W
1218:  MOVLB  B
121A:  MOVWF  x07
121C:  MOVLW  00
121E:  MOVLB  A
1220:  SUBWFB xFA,W
1222:  MOVLB  B
1224:  MOVWF  x08
1226:  MOVLB  A
1228:  MOVF   xF7,W
122A:  MOVLB  B
122C:  ADDWF  x07,W
122E:  MOVWF  FE9
1230:  MOVLB  A
1232:  MOVF   xF8,W
1234:  MOVLB  B
1236:  ADDWFC x08,W
1238:  MOVWF  FEA
123A:  MOVFF  FEF,B09
123E:  MOVLW  03
1240:  MOVLB  A
1242:  SUBWF  xF9,W
1244:  MOVLB  B
1246:  MOVWF  x0A
1248:  MOVLW  00
124A:  MOVLB  A
124C:  SUBWFB xFA,W
124E:  MOVLB  B
1250:  MOVWF  x0B
1252:  MOVLB  A
1254:  MOVF   xF7,W
1256:  MOVLB  B
1258:  ADDWF  x0A,W
125A:  MOVWF  FE9
125C:  MOVLB  A
125E:  MOVF   xF8,W
1260:  MOVLB  B
1262:  ADDWFC x0B,W
1264:  MOVWF  FEA
1266:  MOVFF  FEF,B0C
126A:  MOVLW  02
126C:  MOVLB  A
126E:  SUBWF  xF9,W
1270:  MOVLB  B
1272:  MOVWF  x0D
1274:  MOVLW  00
1276:  MOVLB  A
1278:  SUBWFB xFA,W
127A:  MOVLB  B
127C:  MOVWF  x0E
127E:  MOVLB  A
1280:  MOVF   xF7,W
1282:  MOVLB  B
1284:  ADDWF  x0D,W
1286:  MOVWF  FE9
1288:  MOVLB  A
128A:  MOVF   xF8,W
128C:  MOVLB  B
128E:  ADDWFC x0E,W
1290:  MOVWF  FEA
1292:  MOVFF  FEF,B0F
1296:  MOVLW  01
1298:  MOVLB  A
129A:  SUBWF  xF9,W
129C:  MOVLB  B
129E:  MOVWF  x10
12A0:  MOVLW  00
12A2:  MOVLB  A
12A4:  SUBWFB xFA,W
12A6:  MOVLB  B
12A8:  MOVWF  x11
12AA:  MOVLB  A
12AC:  MOVF   xF7,W
12AE:  MOVLB  B
12B0:  ADDWF  x10,W
12B2:  MOVWF  FE9
12B4:  MOVLB  A
12B6:  MOVF   xF8,W
12B8:  MOVLB  B
12BA:  ADDWFC x11,W
12BC:  MOVWF  FEA
12BE:  MOVFF  FEF,B12
12C2:  MOVLB  A
12C4:  MOVF   xF7,W
12C6:  ADDWF  xF9,W
12C8:  MOVWF  FE9
12CA:  MOVF   xF8,W
12CC:  ADDWFC xFA,W
12CE:  MOVWF  FEA
12D0:  MOVFF  FEF,B13
12D4:  MOVLB  B
12D6:  CLRF   x2E
12D8:  MOVFF  B03,B2F
12DC:  MOVFF  B06,B30
12E0:  MOVFF  B09,B31
12E4:  MOVFF  B0C,B32
12E8:  MOVFF  B0F,B33
12EC:  MOVFF  B12,B34
12F0:  MOVFF  B13,B35
12F4:  MOVLB  0
12F6:  CALL   0610
12FA:  MOVFF  01,AFD
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
12FE:  MOVLW  0D
1300:  MOVLB  A
1302:  SUBWF  xF9,W
1304:  MOVLB  B
1306:  MOVWF  x01
1308:  MOVLW  00
130A:  MOVLB  A
130C:  SUBWFB xFA,W
130E:  MOVLB  B
1310:  MOVWF  x02
1312:  MOVLB  A
1314:  MOVF   xF7,W
1316:  MOVLB  B
1318:  ADDWF  x01,W
131A:  MOVWF  FE9
131C:  MOVLB  A
131E:  MOVF   xF8,W
1320:  MOVLB  B
1322:  ADDWFC x02,W
1324:  MOVWF  FEA
1326:  MOVFF  FEF,B03
132A:  MOVLW  0C
132C:  MOVLB  A
132E:  SUBWF  xF9,W
1330:  MOVLB  B
1332:  MOVWF  x04
1334:  MOVLW  00
1336:  MOVLB  A
1338:  SUBWFB xFA,W
133A:  MOVLB  B
133C:  MOVWF  x05
133E:  MOVLB  A
1340:  MOVF   xF7,W
1342:  MOVLB  B
1344:  ADDWF  x04,W
1346:  MOVWF  FE9
1348:  MOVLB  A
134A:  MOVF   xF8,W
134C:  MOVLB  B
134E:  ADDWFC x05,W
1350:  MOVWF  FEA
1352:  MOVFF  FEF,B06
1356:  MOVLW  0B
1358:  MOVLB  A
135A:  SUBWF  xF9,W
135C:  MOVLB  B
135E:  MOVWF  x07
1360:  MOVLW  00
1362:  MOVLB  A
1364:  SUBWFB xFA,W
1366:  MOVLB  B
1368:  MOVWF  x08
136A:  MOVLB  A
136C:  MOVF   xF7,W
136E:  MOVLB  B
1370:  ADDWF  x07,W
1372:  MOVWF  FE9
1374:  MOVLB  A
1376:  MOVF   xF8,W
1378:  MOVLB  B
137A:  ADDWFC x08,W
137C:  MOVWF  FEA
137E:  MOVFF  FEF,B09
1382:  MOVLW  0A
1384:  MOVLB  A
1386:  SUBWF  xF9,W
1388:  MOVLB  B
138A:  MOVWF  x0A
138C:  MOVLW  00
138E:  MOVLB  A
1390:  SUBWFB xFA,W
1392:  MOVLB  B
1394:  MOVWF  x0B
1396:  MOVLB  A
1398:  MOVF   xF7,W
139A:  MOVLB  B
139C:  ADDWF  x0A,W
139E:  MOVWF  FE9
13A0:  MOVLB  A
13A2:  MOVF   xF8,W
13A4:  MOVLB  B
13A6:  ADDWFC x0B,W
13A8:  MOVWF  FEA
13AA:  MOVFF  FEF,B0C
13AE:  MOVLW  09
13B0:  MOVLB  A
13B2:  SUBWF  xF9,W
13B4:  MOVLB  B
13B6:  MOVWF  x0D
13B8:  MOVLW  00
13BA:  MOVLB  A
13BC:  SUBWFB xFA,W
13BE:  MOVLB  B
13C0:  MOVWF  x0E
13C2:  MOVLB  A
13C4:  MOVF   xF7,W
13C6:  MOVLB  B
13C8:  ADDWF  x0D,W
13CA:  MOVWF  FE9
13CC:  MOVLB  A
13CE:  MOVF   xF8,W
13D0:  MOVLB  B
13D2:  ADDWFC x0E,W
13D4:  MOVWF  FEA
13D6:  MOVFF  FEF,B0F
13DA:  MOVLW  08
13DC:  MOVLB  A
13DE:  SUBWF  xF9,W
13E0:  MOVLB  B
13E2:  MOVWF  x10
13E4:  MOVLW  00
13E6:  MOVLB  A
13E8:  SUBWFB xFA,W
13EA:  MOVLB  B
13EC:  MOVWF  x11
13EE:  MOVLB  A
13F0:  MOVF   xF7,W
13F2:  MOVLB  B
13F4:  ADDWF  x10,W
13F6:  MOVWF  FE9
13F8:  MOVLB  A
13FA:  MOVF   xF8,W
13FC:  MOVLB  B
13FE:  ADDWFC x11,W
1400:  MOVWF  FEA
1402:  MOVFF  FEF,B12
1406:  MOVLW  07
1408:  MOVLB  A
140A:  SUBWF  xF9,W
140C:  MOVLB  B
140E:  MOVWF  x13
1410:  MOVLW  00
1412:  MOVLB  A
1414:  SUBWFB xFA,W
1416:  MOVLB  B
1418:  MOVWF  x14
141A:  MOVLB  A
141C:  MOVF   xF7,W
141E:  MOVLB  B
1420:  ADDWF  x13,W
1422:  MOVWF  FE9
1424:  MOVLB  A
1426:  MOVF   xF8,W
1428:  MOVLB  B
142A:  ADDWFC x14,W
142C:  MOVWF  FEA
142E:  MOVFF  FEF,B15
1432:  CLRF   x2E
1434:  MOVFF  B03,B2F
1438:  MOVFF  B06,B30
143C:  MOVFF  B09,B31
1440:  MOVFF  B0C,B32
1444:  MOVFF  B0F,B33
1448:  MOVFF  B12,B34
144C:  MOVFF  B15,B35
1450:  MOVLB  0
1452:  CALL   0610
1456:  MOVFF  01,AFE
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
145A:  MOVLB  A
145C:  MOVF   xFD,W
145E:  SUBLW  45
1460:  BTFSS  FD8.2
1462:  BRA    164C
1464:  MOVF   xFE,W
1466:  SUBLW  7C
1468:  BTFSC  FD8.2
146A:  BRA    164C
146C:  MOVF   xFE,W
146E:  SUBLW  3E
1470:  BTFSC  FD8.2
1472:  BRA    164C
1474:  MOVF   xFE,W
1476:  SUBLW  1F
1478:  BTFSC  FD8.2
147A:  BRA    164C
147C:  MOVF   xFE,W
147E:  SUBLW  0F
1480:  BTFSC  FD8.2
1482:  BRA    164C
1484:  MOVF   xFE,W
1486:  SUBLW  78
1488:  BTFSC  FD8.2
148A:  BRA    164C
....................          { 
....................             j=i; 
148C:  MOVFF  AFA,AFC
1490:  MOVFF  AF9,AFB
....................             CRC=1; 
1494:  MOVLW  01
1496:  MOVLB  B
1498:  MOVWF  x00
....................             temp2=temp; 
149A:  MOVFF  AFD,AFF
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
149E:  MOVLB  A
14A0:  MOVF   xFF,W
14A2:  SUBLW  1F
14A4:  BTFSC  FD8.2
14A6:  BRA    1626
14A8:  MOVF   xFC,F
14AA:  BNZ   14B4
14AC:  MOVF   xFB,W
14AE:  SUBLW  01
14B0:  BTFSC  FD8.0
14B2:  BRA    1626
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
14B4:  MOVLW  01
14B6:  MOVLB  B
14B8:  MOVWF  x19
14BA:  MOVFF  AFC,B1B
14BE:  MOVFF  AFB,B1A
14C2:  MOVFF  AF8,B1D
14C6:  MOVFF  AF7,B1C
14CA:  MOVLB  0
14CC:  CALL   0676
14D0:  MOVF   01,W
14D2:  MOVLB  B
14D4:  ANDWF  x00,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
14D6:  MOVLW  06
14D8:  MOVLB  A
14DA:  SUBWF  xFB,W
14DC:  MOVLB  B
14DE:  MOVWF  x01
14E0:  MOVLW  00
14E2:  MOVLB  A
14E4:  SUBWFB xFC,W
14E6:  MOVLB  B
14E8:  MOVWF  x02
14EA:  MOVLB  A
14EC:  MOVF   xF7,W
14EE:  MOVLB  B
14F0:  ADDWF  x01,W
14F2:  MOVWF  FE9
14F4:  MOVLB  A
14F6:  MOVF   xF8,W
14F8:  MOVLB  B
14FA:  ADDWFC x02,W
14FC:  MOVWF  FEA
14FE:  MOVFF  FEF,B03
1502:  MOVLW  05
1504:  MOVLB  A
1506:  SUBWF  xFB,W
1508:  MOVLB  B
150A:  MOVWF  x04
150C:  MOVLW  00
150E:  MOVLB  A
1510:  SUBWFB xFC,W
1512:  MOVLB  B
1514:  MOVWF  x05
1516:  MOVLB  A
1518:  MOVF   xF7,W
151A:  MOVLB  B
151C:  ADDWF  x04,W
151E:  MOVWF  FE9
1520:  MOVLB  A
1522:  MOVF   xF8,W
1524:  MOVLB  B
1526:  ADDWFC x05,W
1528:  MOVWF  FEA
152A:  MOVFF  FEF,B06
152E:  MOVLW  04
1530:  MOVLB  A
1532:  SUBWF  xFB,W
1534:  MOVLB  B
1536:  MOVWF  x07
1538:  MOVLW  00
153A:  MOVLB  A
153C:  SUBWFB xFC,W
153E:  MOVLB  B
1540:  MOVWF  x08
1542:  MOVLB  A
1544:  MOVF   xF7,W
1546:  MOVLB  B
1548:  ADDWF  x07,W
154A:  MOVWF  FE9
154C:  MOVLB  A
154E:  MOVF   xF8,W
1550:  MOVLB  B
1552:  ADDWFC x08,W
1554:  MOVWF  FEA
1556:  MOVFF  FEF,B09
155A:  MOVLW  03
155C:  MOVLB  A
155E:  SUBWF  xFB,W
1560:  MOVLB  B
1562:  MOVWF  x0A
1564:  MOVLW  00
1566:  MOVLB  A
1568:  SUBWFB xFC,W
156A:  MOVLB  B
156C:  MOVWF  x0B
156E:  MOVLB  A
1570:  MOVF   xF7,W
1572:  MOVLB  B
1574:  ADDWF  x0A,W
1576:  MOVWF  FE9
1578:  MOVLB  A
157A:  MOVF   xF8,W
157C:  MOVLB  B
157E:  ADDWFC x0B,W
1580:  MOVWF  FEA
1582:  MOVFF  FEF,B0C
1586:  MOVLW  02
1588:  MOVLB  A
158A:  SUBWF  xFB,W
158C:  MOVLB  B
158E:  MOVWF  x0D
1590:  MOVLW  00
1592:  MOVLB  A
1594:  SUBWFB xFC,W
1596:  MOVLB  B
1598:  MOVWF  x0E
159A:  MOVLB  A
159C:  MOVF   xF7,W
159E:  MOVLB  B
15A0:  ADDWF  x0D,W
15A2:  MOVWF  FE9
15A4:  MOVLB  A
15A6:  MOVF   xF8,W
15A8:  MOVLB  B
15AA:  ADDWFC x0E,W
15AC:  MOVWF  FEA
15AE:  MOVFF  FEF,B0F
15B2:  MOVLW  01
15B4:  MOVLB  A
15B6:  SUBWF  xFB,W
15B8:  MOVLB  B
15BA:  MOVWF  x10
15BC:  MOVLW  00
15BE:  MOVLB  A
15C0:  SUBWFB xFC,W
15C2:  MOVLB  B
15C4:  MOVWF  x11
15C6:  MOVLB  A
15C8:  MOVF   xF7,W
15CA:  MOVLB  B
15CC:  ADDWF  x10,W
15CE:  MOVWF  FE9
15D0:  MOVLB  A
15D2:  MOVF   xF8,W
15D4:  MOVLB  B
15D6:  ADDWFC x11,W
15D8:  MOVWF  FEA
15DA:  MOVFF  FEF,B12
15DE:  MOVLB  A
15E0:  MOVF   xF7,W
15E2:  ADDWF  xFB,W
15E4:  MOVWF  FE9
15E6:  MOVF   xF8,W
15E8:  ADDWFC xFC,W
15EA:  MOVWF  FEA
15EC:  MOVFF  FEF,B13
15F0:  MOVLB  B
15F2:  CLRF   x2E
15F4:  MOVFF  B03,B2F
15F8:  MOVFF  B06,B30
15FC:  MOVFF  B09,B31
1600:  MOVFF  B0C,B32
1604:  MOVFF  B0F,B33
1608:  MOVFF  B12,B34
160C:  MOVFF  B13,B35
1610:  MOVLB  0
1612:  CALL   0610
1616:  MOVFF  01,AFF
....................                j=j-7;             
161A:  MOVLW  07
161C:  MOVLB  A
161E:  SUBWF  xFB,F
1620:  MOVLW  00
1622:  SUBWFB xFC,F
....................              } 
1624:  BRA    14A0
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
1626:  MOVLB  B
1628:  DECFSZ x00,W
162A:  BRA    1642
....................             { 
....................                dir=1; 
162C:  MOVLW  01
162E:  MOVLB  9
1630:  MOVWF  x91
....................                return i; 
1632:  MOVLB  A
1634:  MOVFF  AF9,01
1638:  MOVFF  AFA,02
163C:  BRA    19C4
....................             } 
....................             else return 0; 
163E:  BRA    164C
1640:  MOVLB  B
1642:  MOVLW  00
1644:  MOVWF  01
1646:  MOVWF  02
1648:  MOVLB  A
164A:  BRA    19C4
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
164C:  BRA    19B2
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
164E:  MOVLW  04
1650:  SUBWF  xF9,W
1652:  MOVLB  B
1654:  MOVWF  x01
1656:  MOVLW  00
1658:  MOVLB  A
165A:  SUBWFB xFA,W
165C:  MOVLB  B
165E:  MOVWF  x02
1660:  MOVLB  A
1662:  MOVF   xF7,W
1664:  MOVLB  B
1666:  ADDWF  x01,W
1668:  MOVWF  FE9
166A:  MOVLB  A
166C:  MOVF   xF8,W
166E:  MOVLB  B
1670:  ADDWFC x02,W
1672:  MOVWF  FEA
1674:  MOVFF  FEF,B03
1678:  MOVLW  03
167A:  MOVLB  A
167C:  SUBWF  xF9,W
167E:  MOVLB  B
1680:  MOVWF  x04
1682:  MOVLW  00
1684:  MOVLB  A
1686:  SUBWFB xFA,W
1688:  MOVLB  B
168A:  MOVWF  x05
168C:  MOVLB  A
168E:  MOVF   xF7,W
1690:  MOVLB  B
1692:  ADDWF  x04,W
1694:  MOVWF  FE9
1696:  MOVLB  A
1698:  MOVF   xF8,W
169A:  MOVLB  B
169C:  ADDWFC x05,W
169E:  MOVWF  FEA
16A0:  MOVFF  FEF,B06
16A4:  MOVLW  02
16A6:  MOVLB  A
16A8:  SUBWF  xF9,W
16AA:  MOVLB  B
16AC:  MOVWF  x07
16AE:  MOVLW  00
16B0:  MOVLB  A
16B2:  SUBWFB xFA,W
16B4:  MOVLB  B
16B6:  MOVWF  x08
16B8:  MOVLB  A
16BA:  MOVF   xF7,W
16BC:  MOVLB  B
16BE:  ADDWF  x07,W
16C0:  MOVWF  FE9
16C2:  MOVLB  A
16C4:  MOVF   xF8,W
16C6:  MOVLB  B
16C8:  ADDWFC x08,W
16CA:  MOVWF  FEA
16CC:  MOVFF  FEF,B09
16D0:  MOVLW  01
16D2:  MOVLB  A
16D4:  SUBWF  xF9,W
16D6:  MOVLB  B
16D8:  MOVWF  x0A
16DA:  MOVLW  00
16DC:  MOVLB  A
16DE:  SUBWFB xFA,W
16E0:  MOVLB  B
16E2:  MOVWF  x0B
16E4:  MOVLB  A
16E6:  MOVF   xF7,W
16E8:  MOVLB  B
16EA:  ADDWF  x0A,W
16EC:  MOVWF  FE9
16EE:  MOVLB  A
16F0:  MOVF   xF8,W
16F2:  MOVLB  B
16F4:  ADDWFC x0B,W
16F6:  MOVWF  FEA
16F8:  MOVFF  FEF,B0C
16FC:  MOVLB  A
16FE:  MOVF   xF7,W
1700:  ADDWF  xF9,W
1702:  MOVWF  FE9
1704:  MOVF   xF8,W
1706:  ADDWFC xFA,W
1708:  MOVWF  FEA
170A:  MOVFF  FEF,B0D
170E:  MOVLB  B
1710:  CLRF   x2E
1712:  CLRF   x2F
1714:  CLRF   x30
1716:  MOVFF  B03,B31
171A:  MOVFF  B06,B32
171E:  MOVFF  B09,B33
1722:  MOVFF  B0C,B34
1726:  MOVFF  B0D,B35
172A:  MOVLB  0
172C:  CALL   0610
1730:  MOVFF  01,AFD
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1734:  MOVLW  09
1736:  MOVLB  A
1738:  SUBWF  xF9,W
173A:  MOVLB  B
173C:  MOVWF  x01
173E:  MOVLW  00
1740:  MOVLB  A
1742:  SUBWFB xFA,W
1744:  MOVLB  B
1746:  MOVWF  x02
1748:  MOVLB  A
174A:  MOVF   xF7,W
174C:  MOVLB  B
174E:  ADDWF  x01,W
1750:  MOVWF  FE9
1752:  MOVLB  A
1754:  MOVF   xF8,W
1756:  MOVLB  B
1758:  ADDWFC x02,W
175A:  MOVWF  FEA
175C:  MOVFF  FEF,B03
1760:  MOVLW  08
1762:  MOVLB  A
1764:  SUBWF  xF9,W
1766:  MOVLB  B
1768:  MOVWF  x04
176A:  MOVLW  00
176C:  MOVLB  A
176E:  SUBWFB xFA,W
1770:  MOVLB  B
1772:  MOVWF  x05
1774:  MOVLB  A
1776:  MOVF   xF7,W
1778:  MOVLB  B
177A:  ADDWF  x04,W
177C:  MOVWF  FE9
177E:  MOVLB  A
1780:  MOVF   xF8,W
1782:  MOVLB  B
1784:  ADDWFC x05,W
1786:  MOVWF  FEA
1788:  MOVFF  FEF,B06
178C:  MOVLW  07
178E:  MOVLB  A
1790:  SUBWF  xF9,W
1792:  MOVLB  B
1794:  MOVWF  x07
1796:  MOVLW  00
1798:  MOVLB  A
179A:  SUBWFB xFA,W
179C:  MOVLB  B
179E:  MOVWF  x08
17A0:  MOVLB  A
17A2:  MOVF   xF7,W
17A4:  MOVLB  B
17A6:  ADDWF  x07,W
17A8:  MOVWF  FE9
17AA:  MOVLB  A
17AC:  MOVF   xF8,W
17AE:  MOVLB  B
17B0:  ADDWFC x08,W
17B2:  MOVWF  FEA
17B4:  MOVFF  FEF,B09
17B8:  MOVLW  06
17BA:  MOVLB  A
17BC:  SUBWF  xF9,W
17BE:  MOVLB  B
17C0:  MOVWF  x0A
17C2:  MOVLW  00
17C4:  MOVLB  A
17C6:  SUBWFB xFA,W
17C8:  MOVLB  B
17CA:  MOVWF  x0B
17CC:  MOVLB  A
17CE:  MOVF   xF7,W
17D0:  MOVLB  B
17D2:  ADDWF  x0A,W
17D4:  MOVWF  FE9
17D6:  MOVLB  A
17D8:  MOVF   xF8,W
17DA:  MOVLB  B
17DC:  ADDWFC x0B,W
17DE:  MOVWF  FEA
17E0:  MOVFF  FEF,B0C
17E4:  MOVLW  05
17E6:  MOVLB  A
17E8:  SUBWF  xF9,W
17EA:  MOVLB  B
17EC:  MOVWF  x0D
17EE:  MOVLW  00
17F0:  MOVLB  A
17F2:  SUBWFB xFA,W
17F4:  MOVLB  B
17F6:  MOVWF  x0E
17F8:  MOVLB  A
17FA:  MOVF   xF7,W
17FC:  MOVLB  B
17FE:  ADDWF  x0D,W
1800:  MOVWF  FE9
1802:  MOVLB  A
1804:  MOVF   xF8,W
1806:  MOVLB  B
1808:  ADDWFC x0E,W
180A:  MOVWF  FEA
180C:  MOVFF  FEF,B0F
1810:  CLRF   x2E
1812:  CLRF   x2F
1814:  CLRF   x30
1816:  MOVFF  B03,B31
181A:  MOVFF  B06,B32
181E:  MOVFF  B09,B33
1822:  MOVFF  B0C,B34
1826:  MOVFF  B0F,B35
182A:  MOVLB  0
182C:  CALL   0610
1830:  MOVFF  01,AFE
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
1834:  MOVLB  A
1836:  MOVF   xFD,W
1838:  SUBLW  0B
183A:  BTFSS  FD8.2
183C:  BRA    19B2
183E:  MOVF   xFE,W
1840:  SUBLW  1F
1842:  BTFSC  FD8.2
1844:  BRA    19B2
1846:  MOVF   xFE,W
1848:  SUBLW  0F
184A:  BTFSC  FD8.2
184C:  BRA    19B2
....................             { 
....................                j=i; 
184E:  MOVFF  AFA,AFC
1852:  MOVFF  AF9,AFB
....................                CRC=1; 
1856:  MOVLW  01
1858:  MOVLB  B
185A:  MOVWF  x00
....................                temp2=temp; 
185C:  MOVFF  AFD,AFF
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
1860:  MOVLB  A
1862:  MOVF   xFF,W
1864:  SUBLW  1F
1866:  BTFSC  FD8.2
1868:  BRA    198C
186A:  MOVF   xFC,F
186C:  BNZ   1876
186E:  MOVF   xFB,W
1870:  SUBLW  01
1872:  BTFSC  FD8.0
1874:  BRA    198C
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1876:  MOVLW  01
1878:  MOVLB  B
187A:  MOVWF  x19
187C:  MOVFF  AFC,B1B
1880:  MOVFF  AFB,B1A
1884:  MOVFF  AF8,B1D
1888:  MOVFF  AF7,B1C
188C:  MOVLB  0
188E:  CALL   0826
1892:  MOVF   01,W
1894:  MOVLB  B
1896:  ANDWF  x00,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1898:  MOVLW  04
189A:  MOVLB  A
189C:  SUBWF  xFB,W
189E:  MOVLB  B
18A0:  MOVWF  x01
18A2:  MOVLW  00
18A4:  MOVLB  A
18A6:  SUBWFB xFC,W
18A8:  MOVLB  B
18AA:  MOVWF  x02
18AC:  MOVLB  A
18AE:  MOVF   xF7,W
18B0:  MOVLB  B
18B2:  ADDWF  x01,W
18B4:  MOVWF  FE9
18B6:  MOVLB  A
18B8:  MOVF   xF8,W
18BA:  MOVLB  B
18BC:  ADDWFC x02,W
18BE:  MOVWF  FEA
18C0:  MOVFF  FEF,B03
18C4:  MOVLW  03
18C6:  MOVLB  A
18C8:  SUBWF  xFB,W
18CA:  MOVLB  B
18CC:  MOVWF  x04
18CE:  MOVLW  00
18D0:  MOVLB  A
18D2:  SUBWFB xFC,W
18D4:  MOVLB  B
18D6:  MOVWF  x05
18D8:  MOVLB  A
18DA:  MOVF   xF7,W
18DC:  MOVLB  B
18DE:  ADDWF  x04,W
18E0:  MOVWF  FE9
18E2:  MOVLB  A
18E4:  MOVF   xF8,W
18E6:  MOVLB  B
18E8:  ADDWFC x05,W
18EA:  MOVWF  FEA
18EC:  MOVFF  FEF,B06
18F0:  MOVLW  02
18F2:  MOVLB  A
18F4:  SUBWF  xFB,W
18F6:  MOVLB  B
18F8:  MOVWF  x07
18FA:  MOVLW  00
18FC:  MOVLB  A
18FE:  SUBWFB xFC,W
1900:  MOVLB  B
1902:  MOVWF  x08
1904:  MOVLB  A
1906:  MOVF   xF7,W
1908:  MOVLB  B
190A:  ADDWF  x07,W
190C:  MOVWF  FE9
190E:  MOVLB  A
1910:  MOVF   xF8,W
1912:  MOVLB  B
1914:  ADDWFC x08,W
1916:  MOVWF  FEA
1918:  MOVFF  FEF,B09
191C:  MOVLW  01
191E:  MOVLB  A
1920:  SUBWF  xFB,W
1922:  MOVLB  B
1924:  MOVWF  x0A
1926:  MOVLW  00
1928:  MOVLB  A
192A:  SUBWFB xFC,W
192C:  MOVLB  B
192E:  MOVWF  x0B
1930:  MOVLB  A
1932:  MOVF   xF7,W
1934:  MOVLB  B
1936:  ADDWF  x0A,W
1938:  MOVWF  FE9
193A:  MOVLB  A
193C:  MOVF   xF8,W
193E:  MOVLB  B
1940:  ADDWFC x0B,W
1942:  MOVWF  FEA
1944:  MOVFF  FEF,B0C
1948:  MOVLB  A
194A:  MOVF   xF7,W
194C:  ADDWF  xFB,W
194E:  MOVWF  FE9
1950:  MOVF   xF8,W
1952:  ADDWFC xFC,W
1954:  MOVWF  FEA
1956:  MOVFF  FEF,B0D
195A:  MOVLB  B
195C:  CLRF   x2E
195E:  CLRF   x2F
1960:  CLRF   x30
1962:  MOVFF  B03,B31
1966:  MOVFF  B06,B32
196A:  MOVFF  B09,B33
196E:  MOVFF  B0C,B34
1972:  MOVFF  B0D,B35
1976:  MOVLB  0
1978:  CALL   0610
197C:  MOVFF  01,AFF
....................                   j=j-5; 
1980:  MOVLW  05
1982:  MOVLB  A
1984:  SUBWF  xFB,F
1986:  MOVLW  00
1988:  SUBWFB xFC,F
....................                } 
198A:  BRA    1862
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
198C:  MOVLB  B
198E:  DECFSZ x00,W
1990:  BRA    19A8
....................                { 
....................                   dir=1; 
1992:  MOVLW  01
1994:  MOVLB  9
1996:  MOVWF  x91
....................                   return i; 
1998:  MOVLB  A
199A:  MOVFF  AF9,01
199E:  MOVFF  AFA,02
19A2:  BRA    19C4
....................                } 
....................                   else return 0; 
19A4:  BRA    19B2
19A6:  MOVLB  B
19A8:  MOVLW  00
19AA:  MOVWF  01
19AC:  MOVWF  02
19AE:  MOVLB  A
19B0:  BRA    19C4
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
19B2:  MOVF   xF9,W
19B4:  BTFSC  FD8.2
19B6:  DECF   xFA,F
19B8:  DECF   xF9,F
19BA:  GOTO   118C
....................    return 0; 
19BE:  MOVLW  00
19C0:  MOVWF  01
19C2:  MOVWF  02
.................... } 
19C4:  MOVLB  0
19C6:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
3BC0:  MOVLB  A
3BC2:  CLRF   xF3
3BC4:  MOVLW  01
3BC6:  MOVWF  xF2
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3BC8:  MOVFF  AE8,AF4
3BCC:  MOVFF  AEA,AF6
3BD0:  MOVFF  AE9,AF5
3BD4:  MOVFF  AEC,AF8
3BD8:  MOVFF  AEB,AF7
3BDC:  MOVLB  0
3BDE:  CALL   0966
3BE2:  MOVFF  02,AF3
3BE6:  MOVFF  01,AF2
....................    if(temp==0) return 0; 
3BEA:  MOVLB  A
3BEC:  MOVF   xF2,F
3BEE:  BNZ   3BFA
3BF0:  MOVF   xF3,F
3BF2:  BNZ   3BFA
3BF4:  MOVLW  00
3BF6:  MOVWF  01
3BF8:  BRA    3FE0
....................    j=temp; 
3BFA:  MOVFF  AF3,AF1
3BFE:  MOVFF  AF2,AF0
....................    if(dir==0) 
3C02:  MOVLB  9
3C04:  MOVF   x91,F
3C06:  BTFSS  FD8.2
3C08:  BRA    3DE2
....................    { 
....................       if(track==0) 
3C0A:  MOVLB  A
3C0C:  MOVF   xE8,F
3C0E:  BTFSS  FD8.2
3C10:  BRA    3D24
....................       { 
....................             for(i=0;i<79;i++) 
3C12:  CLRF   xEF
3C14:  MOVF   xEF,W
3C16:  SUBLW  4E
3C18:  BTFSS  FD8.0
3C1A:  BRA    3D22
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3C1C:  CLRF   03
3C1E:  MOVF   xEF,W
3C20:  ADDWF  xED,W
3C22:  MOVWF  01
3C24:  MOVF   xEE,W
3C26:  ADDWFC 03,F
3C28:  MOVFF  01,AF4
3C2C:  MOVFF  03,AF5
3C30:  MOVLW  05
3C32:  ADDWF  xF0,W
3C34:  MOVWF  xF6
3C36:  MOVLW  00
3C38:  ADDWFC xF1,W
3C3A:  MOVWF  xF7
3C3C:  MOVF   xEB,W
3C3E:  ADDWF  xF6,W
3C40:  MOVWF  FE9
3C42:  MOVF   xEC,W
3C44:  ADDWFC xF7,W
3C46:  MOVWF  FEA
3C48:  MOVFF  FEF,AF8
3C4C:  MOVLW  04
3C4E:  ADDWF  xF0,W
3C50:  MOVWF  xF9
3C52:  MOVLW  00
3C54:  ADDWFC xF1,W
3C56:  MOVWF  xFA
3C58:  MOVF   xEB,W
3C5A:  ADDWF  xF9,W
3C5C:  MOVWF  FE9
3C5E:  MOVF   xEC,W
3C60:  ADDWFC xFA,W
3C62:  MOVWF  FEA
3C64:  MOVFF  FEF,AFB
3C68:  MOVLW  03
3C6A:  ADDWF  xF0,W
3C6C:  MOVWF  xFC
3C6E:  MOVLW  00
3C70:  ADDWFC xF1,W
3C72:  MOVWF  xFD
3C74:  MOVF   xEB,W
3C76:  ADDWF  xFC,W
3C78:  MOVWF  FE9
3C7A:  MOVF   xEC,W
3C7C:  ADDWFC xFD,W
3C7E:  MOVWF  FEA
3C80:  MOVFF  FEF,AFE
3C84:  MOVLW  02
3C86:  ADDWF  xF0,W
3C88:  MOVWF  xFF
3C8A:  MOVLW  00
3C8C:  ADDWFC xF1,W
3C8E:  MOVLB  B
3C90:  MOVWF  x00
3C92:  MOVLB  A
3C94:  MOVF   xEB,W
3C96:  ADDWF  xFF,W
3C98:  MOVWF  FE9
3C9A:  MOVF   xEC,W
3C9C:  MOVLB  B
3C9E:  ADDWFC x00,W
3CA0:  MOVWF  FEA
3CA2:  MOVFF  FEF,B01
3CA6:  MOVLW  01
3CA8:  MOVLB  A
3CAA:  ADDWF  xF0,W
3CAC:  MOVLB  B
3CAE:  MOVWF  x02
3CB0:  MOVLW  00
3CB2:  MOVLB  A
3CB4:  ADDWFC xF1,W
3CB6:  MOVLB  B
3CB8:  MOVWF  x03
3CBA:  MOVLB  A
3CBC:  MOVF   xEB,W
3CBE:  MOVLB  B
3CC0:  ADDWF  x02,W
3CC2:  MOVWF  FE9
3CC4:  MOVLB  A
3CC6:  MOVF   xEC,W
3CC8:  MOVLB  B
3CCA:  ADDWFC x03,W
3CCC:  MOVWF  FEA
3CCE:  MOVFF  FEF,B04
3CD2:  MOVLB  A
3CD4:  MOVF   xEB,W
3CD6:  ADDWF  xF0,W
3CD8:  MOVWF  FE9
3CDA:  MOVF   xEC,W
3CDC:  ADDWFC xF1,W
3CDE:  MOVWF  FEA
3CE0:  MOVFF  FEF,B05
3CE4:  MOVLB  B
3CE6:  CLRF   x2E
3CE8:  CLRF   x2F
3CEA:  MOVFF  AF8,B30
3CEE:  MOVFF  AFB,B31
3CF2:  MOVFF  AFE,B32
3CF6:  MOVFF  B01,B33
3CFA:  MOVFF  B04,B34
3CFE:  MOVFF  B05,B35
3D02:  MOVLB  0
3D04:  CALL   0610
3D08:  MOVFF  AF5,FEA
3D0C:  MOVFF  AF4,FE9
3D10:  MOVFF  01,FEF
....................                j=j+7; 
3D14:  MOVLW  07
3D16:  MOVLB  A
3D18:  ADDWF  xF0,F
3D1A:  MOVLW  00
3D1C:  ADDWFC xF1,F
....................             } 
3D1E:  INCF   xEF,F
3D20:  BRA    3C14
....................       } 
....................          else  
3D22:  BRA    3DDE
....................          { 
....................             for(i=0;i<40;i++) 
3D24:  CLRF   xEF
3D26:  MOVF   xEF,W
3D28:  SUBLW  27
3D2A:  BNC   3DDE
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3D2C:  CLRF   03
3D2E:  MOVF   xEF,W
3D30:  ADDWF  xED,W
3D32:  MOVWF  01
3D34:  MOVF   xEE,W
3D36:  ADDWFC 03,F
3D38:  MOVFF  01,AF4
3D3C:  MOVFF  03,AF5
3D40:  MOVLW  03
3D42:  ADDWF  xF0,W
3D44:  MOVWF  xF6
3D46:  MOVLW  00
3D48:  ADDWFC xF1,W
3D4A:  MOVWF  xF7
3D4C:  MOVF   xEB,W
3D4E:  ADDWF  xF6,W
3D50:  MOVWF  FE9
3D52:  MOVF   xEC,W
3D54:  ADDWFC xF7,W
3D56:  MOVWF  FEA
3D58:  MOVFF  FEF,AF8
3D5C:  MOVLW  02
3D5E:  ADDWF  xF0,W
3D60:  MOVWF  xF9
3D62:  MOVLW  00
3D64:  ADDWFC xF1,W
3D66:  MOVWF  xFA
3D68:  MOVF   xEB,W
3D6A:  ADDWF  xF9,W
3D6C:  MOVWF  FE9
3D6E:  MOVF   xEC,W
3D70:  ADDWFC xFA,W
3D72:  MOVWF  FEA
3D74:  MOVFF  FEF,AFB
3D78:  MOVLW  01
3D7A:  ADDWF  xF0,W
3D7C:  MOVWF  xFC
3D7E:  MOVLW  00
3D80:  ADDWFC xF1,W
3D82:  MOVWF  xFD
3D84:  MOVF   xEB,W
3D86:  ADDWF  xFC,W
3D88:  MOVWF  FE9
3D8A:  MOVF   xEC,W
3D8C:  ADDWFC xFD,W
3D8E:  MOVWF  FEA
3D90:  MOVFF  FEF,AFE
3D94:  MOVF   xEB,W
3D96:  ADDWF  xF0,W
3D98:  MOVWF  FE9
3D9A:  MOVF   xEC,W
3D9C:  ADDWFC xF1,W
3D9E:  MOVWF  FEA
3DA0:  MOVFF  FEF,AFF
3DA4:  MOVLB  B
3DA6:  CLRF   x2E
3DA8:  CLRF   x2F
3DAA:  CLRF   x30
3DAC:  CLRF   x31
3DAE:  MOVFF  AF8,B32
3DB2:  MOVFF  AFB,B33
3DB6:  MOVFF  AFE,B34
3DBA:  MOVFF  AFF,B35
3DBE:  MOVLB  0
3DC0:  CALL   0610
3DC4:  MOVFF  AF5,FEA
3DC8:  MOVFF  AF4,FE9
3DCC:  MOVFF  01,FEF
....................                j=j+5; 
3DD0:  MOVLW  05
3DD2:  MOVLB  A
3DD4:  ADDWF  xF0,F
3DD6:  MOVLW  00
3DD8:  ADDWFC xF1,F
....................             }          
3DDA:  INCF   xEF,F
3DDC:  BRA    3D26
....................          } 
....................    } 
....................       else  
3DDE:  BRA    3FB6
3DE0:  MOVLB  9
....................       { 
....................          if(track==0) 
3DE2:  MOVLB  A
3DE4:  MOVF   xE8,F
3DE6:  BTFSS  FD8.2
3DE8:  BRA    3EFC
....................          { 
....................             for(i=0;i<79;i++) 
3DEA:  CLRF   xEF
3DEC:  MOVF   xEF,W
3DEE:  SUBLW  4E
3DF0:  BTFSS  FD8.0
3DF2:  BRA    3EFA
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3DF4:  CLRF   03
3DF6:  MOVF   xEF,W
3DF8:  ADDWF  xED,W
3DFA:  MOVWF  01
3DFC:  MOVF   xEE,W
3DFE:  ADDWFC 03,F
3E00:  MOVFF  01,AF4
3E04:  MOVFF  03,AF5
3E08:  MOVLW  05
3E0A:  SUBWF  xF0,W
3E0C:  MOVWF  xF6
3E0E:  MOVLW  00
3E10:  SUBWFB xF1,W
3E12:  MOVWF  xF7
3E14:  MOVF   xEB,W
3E16:  ADDWF  xF6,W
3E18:  MOVWF  FE9
3E1A:  MOVF   xEC,W
3E1C:  ADDWFC xF7,W
3E1E:  MOVWF  FEA
3E20:  MOVFF  FEF,AF8
3E24:  MOVLW  04
3E26:  SUBWF  xF0,W
3E28:  MOVWF  xF9
3E2A:  MOVLW  00
3E2C:  SUBWFB xF1,W
3E2E:  MOVWF  xFA
3E30:  MOVF   xEB,W
3E32:  ADDWF  xF9,W
3E34:  MOVWF  FE9
3E36:  MOVF   xEC,W
3E38:  ADDWFC xFA,W
3E3A:  MOVWF  FEA
3E3C:  MOVFF  FEF,AFB
3E40:  MOVLW  03
3E42:  SUBWF  xF0,W
3E44:  MOVWF  xFC
3E46:  MOVLW  00
3E48:  SUBWFB xF1,W
3E4A:  MOVWF  xFD
3E4C:  MOVF   xEB,W
3E4E:  ADDWF  xFC,W
3E50:  MOVWF  FE9
3E52:  MOVF   xEC,W
3E54:  ADDWFC xFD,W
3E56:  MOVWF  FEA
3E58:  MOVFF  FEF,AFE
3E5C:  MOVLW  02
3E5E:  SUBWF  xF0,W
3E60:  MOVWF  xFF
3E62:  MOVLW  00
3E64:  SUBWFB xF1,W
3E66:  MOVLB  B
3E68:  MOVWF  x00
3E6A:  MOVLB  A
3E6C:  MOVF   xEB,W
3E6E:  ADDWF  xFF,W
3E70:  MOVWF  FE9
3E72:  MOVF   xEC,W
3E74:  MOVLB  B
3E76:  ADDWFC x00,W
3E78:  MOVWF  FEA
3E7A:  MOVFF  FEF,B01
3E7E:  MOVLW  01
3E80:  MOVLB  A
3E82:  SUBWF  xF0,W
3E84:  MOVLB  B
3E86:  MOVWF  x02
3E88:  MOVLW  00
3E8A:  MOVLB  A
3E8C:  SUBWFB xF1,W
3E8E:  MOVLB  B
3E90:  MOVWF  x03
3E92:  MOVLB  A
3E94:  MOVF   xEB,W
3E96:  MOVLB  B
3E98:  ADDWF  x02,W
3E9A:  MOVWF  FE9
3E9C:  MOVLB  A
3E9E:  MOVF   xEC,W
3EA0:  MOVLB  B
3EA2:  ADDWFC x03,W
3EA4:  MOVWF  FEA
3EA6:  MOVFF  FEF,B04
3EAA:  MOVLB  A
3EAC:  MOVF   xEB,W
3EAE:  ADDWF  xF0,W
3EB0:  MOVWF  FE9
3EB2:  MOVF   xEC,W
3EB4:  ADDWFC xF1,W
3EB6:  MOVWF  FEA
3EB8:  MOVFF  FEF,B05
3EBC:  MOVLB  B
3EBE:  CLRF   x2E
3EC0:  CLRF   x2F
3EC2:  MOVFF  AF8,B30
3EC6:  MOVFF  AFB,B31
3ECA:  MOVFF  AFE,B32
3ECE:  MOVFF  B01,B33
3ED2:  MOVFF  B04,B34
3ED6:  MOVFF  B05,B35
3EDA:  MOVLB  0
3EDC:  CALL   0610
3EE0:  MOVFF  AF5,FEA
3EE4:  MOVFF  AF4,FE9
3EE8:  MOVFF  01,FEF
....................                j=j-7; 
3EEC:  MOVLW  07
3EEE:  MOVLB  A
3EF0:  SUBWF  xF0,F
3EF2:  MOVLW  00
3EF4:  SUBWFB xF1,F
....................             } 
3EF6:  INCF   xEF,F
3EF8:  BRA    3DEC
....................          } 
....................             else 
3EFA:  BRA    3FB6
....................             { 
....................                for(i=0;i<40;i++) 
3EFC:  CLRF   xEF
3EFE:  MOVF   xEF,W
3F00:  SUBLW  27
3F02:  BNC   3FB6
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3F04:  CLRF   03
3F06:  MOVF   xEF,W
3F08:  ADDWF  xED,W
3F0A:  MOVWF  01
3F0C:  MOVF   xEE,W
3F0E:  ADDWFC 03,F
3F10:  MOVFF  01,AF4
3F14:  MOVFF  03,AF5
3F18:  MOVLW  03
3F1A:  SUBWF  xF0,W
3F1C:  MOVWF  xF6
3F1E:  MOVLW  00
3F20:  SUBWFB xF1,W
3F22:  MOVWF  xF7
3F24:  MOVF   xEB,W
3F26:  ADDWF  xF6,W
3F28:  MOVWF  FE9
3F2A:  MOVF   xEC,W
3F2C:  ADDWFC xF7,W
3F2E:  MOVWF  FEA
3F30:  MOVFF  FEF,AF8
3F34:  MOVLW  02
3F36:  SUBWF  xF0,W
3F38:  MOVWF  xF9
3F3A:  MOVLW  00
3F3C:  SUBWFB xF1,W
3F3E:  MOVWF  xFA
3F40:  MOVF   xEB,W
3F42:  ADDWF  xF9,W
3F44:  MOVWF  FE9
3F46:  MOVF   xEC,W
3F48:  ADDWFC xFA,W
3F4A:  MOVWF  FEA
3F4C:  MOVFF  FEF,AFB
3F50:  MOVLW  01
3F52:  SUBWF  xF0,W
3F54:  MOVWF  xFC
3F56:  MOVLW  00
3F58:  SUBWFB xF1,W
3F5A:  MOVWF  xFD
3F5C:  MOVF   xEB,W
3F5E:  ADDWF  xFC,W
3F60:  MOVWF  FE9
3F62:  MOVF   xEC,W
3F64:  ADDWFC xFD,W
3F66:  MOVWF  FEA
3F68:  MOVFF  FEF,AFE
3F6C:  MOVF   xEB,W
3F6E:  ADDWF  xF0,W
3F70:  MOVWF  FE9
3F72:  MOVF   xEC,W
3F74:  ADDWFC xF1,W
3F76:  MOVWF  FEA
3F78:  MOVFF  FEF,AFF
3F7C:  MOVLB  B
3F7E:  CLRF   x2E
3F80:  CLRF   x2F
3F82:  CLRF   x30
3F84:  CLRF   x31
3F86:  MOVFF  AF8,B32
3F8A:  MOVFF  AFB,B33
3F8E:  MOVFF  AFE,B34
3F92:  MOVFF  AFF,B35
3F96:  MOVLB  0
3F98:  CALL   0610
3F9C:  MOVFF  AF5,FEA
3FA0:  MOVFF  AF4,FE9
3FA4:  MOVFF  01,FEF
....................                   j=j-5; 
3FA8:  MOVLW  05
3FAA:  MOVLB  A
3FAC:  SUBWF  xF0,F
3FAE:  MOVLW  00
3FB0:  SUBWFB xF1,F
....................                }             
3FB2:  INCF   xEF,F
3FB4:  BRA    3EFE
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3FB6:  MOVF   xE8,F
3FB8:  BNZ   3FCE
3FBA:  MOVLW  52
3FBC:  MOVWF  xF4
3FBE:  MOVFF  AEC,AF6
3FC2:  MOVFF  AEB,AF5
3FC6:  MOVLB  0
3FC8:  RCALL  3B9E
....................          else del_buf(numbyteofbuffer2,datin); 
3FCA:  BRA    3FDE
3FCC:  MOVLB  A
3FCE:  MOVLW  2C
3FD0:  MOVWF  xF4
3FD2:  MOVFF  AEC,AF6
3FD6:  MOVFF  AEB,AF5
3FDA:  MOVLB  0
3FDC:  RCALL  3B9E
3FDE:  MOVLB  A
.................... } 
3FE0:  MOVLB  0
3FE2:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1BA0:  MOVLW  C0
1BA2:  MOVWF  FF6
1BA4:  MOVLW  04
1BA6:  MOVWF  FF7
1BA8:  CALL   05F0
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1BAC:  MOVLB  A
1BAE:  CLRF   xEC
1BB0:  CLRF   xEB
1BB2:  MOVF   xEC,W
1BB4:  SUBLW  03
1BB6:  BNC   1BE6
1BB8:  BNZ   1BC0
1BBA:  MOVF   xEB,W
1BBC:  SUBLW  51
1BBE:  BNC   1BE6
1BC0:  MOVLW  0F
1BC2:  ADDWF  xEB,W
1BC4:  MOVWF  FE9
1BC6:  MOVLW  05
1BC8:  ADDWFC xEC,W
1BCA:  MOVWF  FEA
1BCC:  MOVFF  FEF,AED
1BD0:  MOVFF  AED,AEE
1BD4:  MOVLW  18
1BD6:  MOVWF  xEF
1BD8:  MOVLB  0
1BDA:  RCALL  1ADC
1BDC:  MOVLB  A
1BDE:  INCF   xEB,F
1BE0:  BTFSC  FD8.2
1BE2:  INCF   xEC,F
1BE4:  BRA    1BB2
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1BE6:  MOVLW  D6
1BE8:  MOVWF  FF6
1BEA:  MOVLW  04
1BEC:  MOVWF  FF7
1BEE:  MOVLB  0
1BF0:  CALL   05F0
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1BF4:  MOVLB  A
1BF6:  CLRF   xEC
1BF8:  CLRF   xEB
1BFA:  MOVF   xEC,W
1BFC:  SUBLW  01
1BFE:  BNC   1C2E
1C00:  BNZ   1C08
1C02:  MOVF   xEB,W
1C04:  SUBLW  2B
1C06:  BNC   1C2E
1C08:  MOVLW  61
1C0A:  ADDWF  xEB,W
1C0C:  MOVWF  FE9
1C0E:  MOVLW  08
1C10:  ADDWFC xEC,W
1C12:  MOVWF  FEA
1C14:  MOVFF  FEF,AED
1C18:  MOVFF  AED,AEE
1C1C:  MOVLW  18
1C1E:  MOVWF  xEF
1C20:  MOVLB  0
1C22:  RCALL  1ADC
1C24:  MOVLB  A
1C26:  INCF   xEB,F
1C28:  BTFSC  FD8.2
1C2A:  INCF   xEC,F
1C2C:  BRA    1BFA
.................... } 
1C2E:  MOVLB  0
1C30:  GOTO   1EC6 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
4170:  MOVLW  01
4172:  MOVLB  9
4174:  MOVWF  xA1
....................    rtc_get_date(date,mon,year,day); 
....................    rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
*
4224:  RCALL  3B2C
4226:  MOVFF  02,AE9
422A:  MOVFF  01,AE8
422E:  MOVFF  02,AEB
4232:  MOVFF  01,AEA
4236:  MOVLB  A
4238:  CLRF   xED
423A:  MOVLW  7C
423C:  MOVWF  xEC
423E:  MOVLB  0
4240:  RCALL  3B7C
4242:  MOVFF  01,AE8
4246:  MOVLW  96
4248:  MOVLB  A
424A:  ADDWF  01,W
424C:  MOVWF  01
424E:  MOVLW  00
4250:  ADDWFC 02,W
4252:  MOVFF  01,20
4256:  MOVWF  21
4258:  CLRF   22
425A:  CLRF   23
....................    if(datinbuf==0)  
425C:  MOVLB  9
425E:  MOVF   x9E,F
4260:  BNZ   4282
....................    { 
....................       countbit_T1=0; 
4262:  CLRF   x93
4264:  CLRF   x92
....................       countbit_T2=0; 
4266:  CLRF   x95
4268:  CLRF   x94
....................       bug_countbit_T1=0; 
426A:  CLRF   x97
426C:  CLRF   x96
....................       bug_countbit_T2=0; 
426E:  CLRF   x99
4270:  CLRF   x98
....................       if(data_avai==0)charac_timeout=0xffffffff; 
4272:  MOVF   xA2,F
4274:  BNZ   427E
4276:  MOVLB  0
4278:  SETF   xFC
427A:  SETF   xFB
427C:  MOVLB  9
....................       saving_flag=0; 
427E:  CLRF   xA1
....................       return; 
4280:  BRA    45EC
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
4282:  MOVLW  EC
4284:  MOVWF  FF6
4286:  MOVLW  04
4288:  MOVWF  FF7
428A:  MOVLB  0
428C:  CALL   05F0
....................    key_timeout=0; 
4290:  MOVLB  1
4292:  CLRF   x06
4294:  CLRF   x05
....................    //key_count=0; 
....................    enable_getpin=1; 
4296:  MOVLW  01
4298:  MOVWF  x09
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
429A:  MOVFF  993,AE7
429E:  MOVFF  992,AE6
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
42A2:  MOVLB  A
42A4:  CLRF   xE8
42A6:  MOVFF  AE7,AEA
42AA:  MOVFF  AE6,AE9
42AE:  MOVLW  05
42B0:  MOVWF  xEC
42B2:  MOVLW  0F
42B4:  MOVWF  xEB
42B6:  MOVLW  04
42B8:  MOVWF  xEE
42BA:  MOVLW  98
42BC:  MOVWF  xED
42BE:  MOVLB  0
42C0:  RCALL  3BC0
....................    countbit_T1=0; 
42C2:  MOVLB  9
42C4:  CLRF   x93
42C6:  CLRF   x92
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
42C8:  MOVFF  995,AE7
42CC:  MOVFF  994,AE6
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
42D0:  MOVLW  01
42D2:  MOVLB  A
42D4:  MOVWF  xE8
42D6:  MOVFF  AE7,AEA
42DA:  MOVFF  AE6,AE9
42DE:  MOVLW  08
42E0:  MOVWF  xEC
42E2:  MOVLW  61
42E4:  MOVWF  xEB
42E6:  MOVLW  04
42E8:  MOVWF  xEE
42EA:  MOVLW  E7
42EC:  MOVWF  xED
42EE:  MOVLB  0
42F0:  RCALL  3BC0
....................    countbit_T2=0; 
42F2:  MOVLB  9
42F4:  CLRF   x95
42F6:  CLRF   x94
....................    saving_flag=0; 
42F8:  CLRF   xA1
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
42FA:  MOVLW  20
42FC:  MOVLB  4
42FE:  ADDWF  x98,W
4300:  MOVLB  A
4302:  MOVWF  xE5
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
4304:  MOVF   23,F
4306:  BTFSS  FD8.2
4308:  BRA    45EA
430A:  MOVF   22,F
430C:  BTFSS  FD8.2
430E:  BRA    45EA
4310:  MOVF   21,W
4312:  SUBLW  AA
4314:  BTFSS  FD8.0
4316:  BRA    45EA
4318:  BNZ   4322
431A:  MOVF   20,W
431C:  SUBLW  45
431E:  BTFSS  FD8.0
4320:  BRA    45EA
4322:  MOVF   xE5,W
4324:  SUBLW  25
4326:  BTFSS  FD8.2
4328:  BRA    45EA
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
432A:  MOVFF  23,03
432E:  MOVFF  22,02
4332:  MOVFF  21,01
4336:  MOVFF  20,00
433A:  MOVLW  01
433C:  ADDWF  20,F
433E:  BTFSC  FD8.0
4340:  INCF   21,F
4342:  BTFSC  FD8.2
4344:  INCF   22,F
4346:  BTFSC  FD8.2
4348:  INCF   23,F
434A:  MOVFF  01,AE9
434E:  MOVFF  00,AE8
4352:  MOVFF  01,B03
4356:  MOVFF  00,B02
435A:  MOVFF  100,B04
435E:  MOVLB  0
4360:  RCALL  3FE4
....................          write_ext_eeprom((long int)ptr_card++,mon); 
4362:  MOVFF  23,03
4366:  MOVFF  22,02
436A:  MOVFF  21,01
436E:  MOVFF  20,00
4372:  MOVLW  01
4374:  ADDWF  20,F
4376:  BTFSC  FD8.0
4378:  INCF   21,F
437A:  BTFSC  FD8.2
437C:  INCF   22,F
437E:  BTFSC  FD8.2
4380:  INCF   23,F
4382:  MOVFF  01,AE9
4386:  MOVFF  00,AE8
438A:  MOVFF  01,B03
438E:  MOVFF  00,B02
4392:  MOVFF  FF,B04
4396:  RCALL  3FE4
....................          write_ext_eeprom((long int)ptr_card++,h); 
4398:  MOVFF  23,03
439C:  MOVFF  22,02
43A0:  MOVFF  21,01
43A4:  MOVFF  20,00
43A8:  MOVLW  01
43AA:  ADDWF  20,F
43AC:  BTFSC  FD8.0
43AE:  INCF   21,F
43B0:  BTFSC  FD8.2
43B2:  INCF   22,F
43B4:  BTFSC  FD8.2
43B6:  INCF   23,F
43B8:  MOVFF  01,AE9
43BC:  MOVFF  00,AE8
43C0:  MOVFF  01,B03
43C4:  MOVFF  00,B02
43C8:  MOVFF  101,B04
43CC:  RCALL  3FE4
....................          write_ext_eeprom((long int)ptr_card++,min); 
43CE:  MOVFF  23,03
43D2:  MOVFF  22,02
43D6:  MOVFF  21,01
43DA:  MOVFF  20,00
43DE:  MOVLW  01
43E0:  ADDWF  20,F
43E2:  BTFSC  FD8.0
43E4:  INCF   21,F
43E6:  BTFSC  FD8.2
43E8:  INCF   22,F
43EA:  BTFSC  FD8.2
43EC:  INCF   23,F
43EE:  MOVFF  01,AE9
43F2:  MOVFF  00,AE8
43F6:  MOVFF  01,B03
43FA:  MOVFF  00,B02
43FE:  MOVFF  102,B04
4402:  RCALL  3FE4
....................          write_ext_eeprom((long int)ptr_card++,sec);           
4404:  MOVFF  23,03
4408:  MOVFF  22,02
440C:  MOVFF  21,01
4410:  MOVFF  20,00
4414:  MOVLW  01
4416:  ADDWF  20,F
4418:  BTFSC  FD8.0
441A:  INCF   21,F
441C:  BTFSC  FD8.2
441E:  INCF   22,F
4420:  BTFSC  FD8.2
4422:  INCF   23,F
4424:  MOVFF  01,AE9
4428:  MOVFF  00,AE8
442C:  MOVFF  01,B03
4430:  MOVFF  00,B02
4434:  MOVFF  103,B04
4438:  RCALL  3FE4
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
443A:  MOVLB  9
443C:  CLRF   x9D
443E:  CLRF   x9C
4440:  MOVF   x9D,F
4442:  BNZ   44A2
4444:  MOVF   x9C,W
4446:  SUBLW  4E
4448:  BNC   44A2
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
444A:  MOVFF  23,03
444E:  MOVFF  22,02
4452:  MOVFF  21,01
4456:  MOVFF  20,00
445A:  MOVLW  01
445C:  ADDWF  20,F
445E:  BTFSC  FD8.0
4460:  INCF   21,F
4462:  BTFSC  FD8.2
4464:  INCF   22,F
4466:  BTFSC  FD8.2
4468:  INCF   23,F
446A:  MOVFF  01,AE9
446E:  MOVFF  00,AE8
4472:  MOVLW  98
4474:  ADDWF  x9C,W
4476:  MOVWF  FE9
4478:  MOVLW  04
447A:  ADDWFC x9D,W
447C:  MOVWF  FEA
447E:  MOVF   FEF,W
4480:  ANDLW  3F
4482:  ADDLW  20
4484:  MOVLB  A
4486:  MOVWF  xEA
4488:  MOVFF  01,B03
448C:  MOVFF  00,B02
4490:  MOVFF  FE8,B04
4494:  MOVLB  0
4496:  RCALL  3FE4
....................              
....................          } 
4498:  MOVLB  9
449A:  INCF   x9C,F
449C:  BTFSC  FD8.2
449E:  INCF   x9D,F
44A0:  BRA    4440
....................          del_buf(numbyteoftrack1,Track1); 
44A2:  MOVLW  4F
44A4:  MOVLB  A
44A6:  MOVWF  xF4
44A8:  MOVLW  04
44AA:  MOVWF  xF6
44AC:  MOVLW  98
44AE:  MOVWF  xF5
44B0:  MOVLB  0
44B2:  CALL   3B9E
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
44B6:  MOVLB  9
44B8:  CLRF   x9D
44BA:  CLRF   x9C
44BC:  MOVF   x9D,F
44BE:  BNZ   451E
44C0:  MOVF   x9C,W
44C2:  SUBLW  27
44C4:  BNC   451E
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
44C6:  MOVFF  23,03
44CA:  MOVFF  22,02
44CE:  MOVFF  21,01
44D2:  MOVFF  20,00
44D6:  MOVLW  01
44D8:  ADDWF  20,F
44DA:  BTFSC  FD8.0
44DC:  INCF   21,F
44DE:  BTFSC  FD8.2
44E0:  INCF   22,F
44E2:  BTFSC  FD8.2
44E4:  INCF   23,F
44E6:  MOVFF  01,AE9
44EA:  MOVFF  00,AE8
44EE:  MOVLW  E7
44F0:  ADDWF  x9C,W
44F2:  MOVWF  FE9
44F4:  MOVLW  04
44F6:  ADDWFC x9D,W
44F8:  MOVWF  FEA
44FA:  MOVF   FEF,W
44FC:  ANDLW  0F
44FE:  ADDLW  30
4500:  MOVLB  A
4502:  MOVWF  xEA
4504:  MOVFF  01,B03
4508:  MOVFF  00,B02
450C:  MOVFF  FE8,B04
4510:  MOVLB  0
4512:  RCALL  3FE4
....................          }  
4514:  MOVLB  9
4516:  INCF   x9C,F
4518:  BTFSC  FD8.2
451A:  INCF   x9D,F
451C:  BRA    44BC
....................          del_buf(numbyteoftrack2,Track2); 
451E:  MOVLW  28
4520:  MOVLB  A
4522:  MOVWF  xF4
4524:  MOVLW  04
4526:  MOVWF  xF6
4528:  MOVLW  E7
452A:  MOVWF  xF5
452C:  MOVLB  0
452E:  CALL   3B9E
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
4532:  MOVLW  0D
4534:  MOVLB  B
4536:  MOVWF  x1A
4538:  MOVLB  0
453A:  CALL   05AA
453E:  MOVLW  0A
4540:  MOVLB  B
4542:  MOVWF  x1A
4544:  MOVLB  0
4546:  CALL   05AA
....................       fprintf(COM2,"Done"); 
454A:  MOVLW  02
454C:  MOVWF  FF6
454E:  MOVLW  05
4550:  MOVWF  FF7
4552:  CALL   05F0
....................       if(KP_mode) 
4556:  MOVLB  1
4558:  MOVF   x0C,F
455A:  BZ    4572
....................       { 
....................          printf("\n\rKey release\n\r"); 
455C:  MOVLW  08
455E:  MOVWF  FF6
4560:  MOVLW  05
4562:  MOVWF  FF7
4564:  MOVLB  0
4566:  CALL   05F0
....................          keyprss_off; 
456A:  BCF    F92.7
456C:  BCF    F89.7
....................          kp_st=0; 
456E:  MOVLB  1
4570:  CLRF   x0D
....................       }   
....................       count_kp=0xffff; 
4572:  SETF   x0F
4574:  SETF   x0E
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
4576:  MOVLW  0D
4578:  MOVLB  B
457A:  MOVWF  x1A
457C:  MOVLB  0
457E:  CALL   05AA
4582:  MOVLW  0A
4584:  MOVLB  B
4586:  MOVWF  x1A
4588:  MOVLB  0
458A:  CALL   05AA
....................       fprintf(COM2,"Waiting for PIN number"); 
458E:  MOVLW  18
4590:  MOVWF  FF6
4592:  MOVLW  05
4594:  MOVWF  FF7
4596:  CALL   05F0
....................       fprintf(COM2,"\r\n"); 
459A:  MOVLW  0D
459C:  MOVLB  B
459E:  MOVWF  x1A
45A0:  MOVLB  0
45A2:  CALL   05AA
45A6:  MOVLW  0A
45A8:  MOVLB  B
45AA:  MOVWF  x1A
45AC:  MOVLB  0
45AE:  CALL   05AA
....................       charac_timeout=0; 
45B2:  CLRF   xFC
45B4:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
45B6:  MOVFF  23,AEB
45BA:  MOVFF  22,AEA
45BE:  MOVFF  21,AE9
45C2:  MOVFF  20,AE8
45C6:  MOVLW  19
45C8:  MOVLB  A
45CA:  MOVWF  xEC
45CC:  MOVLB  0
45CE:  RCALL  40EA
....................       datinbuf=0; 
45D0:  MOVLB  9
45D2:  CLRF   x9E
....................       saving_flag=0; 
45D4:  CLRF   xA1
....................       data_avai=1; 
45D6:  MOVLW  01
45D8:  MOVWF  xA2
....................       enable_getpin=1; 
45DA:  MOVLB  1
45DC:  MOVWF  x09
....................       charac_timeout=0; 
45DE:  MOVLB  0
45E0:  CLRF   xFC
45E2:  CLRF   xFB
....................       key_count_ms=0; 
45E4:  MOVLB  1
45E6:  CLRF   x0B
45E8:  MOVLB  A
45EA:  MOVLB  9
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
45EC:  MOVLB  0
45EE:  GOTO   493E (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
1C5C:  MOVLW  01
1C5E:  MOVLB  A
1C60:  MOVWF  xE2
1C62:  MOVWF  xE3
1C64:  MOVWF  xE4
1C66:  MOVWF  xE5
1C68:  CLRF   xE6
1C6A:  MOVWF  xE7
1C6C:  MOVWF  xE8
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1C6E:  MOVLB  9
1C70:  CLRF   x9B
1C72:  CLRF   x9A
....................    mcr_timeout=0; 
1C74:  CLRF   x90
1C76:  CLRF   x8F
1C78:  CLRF   x8E
1C7A:  CLRF   x8D
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
1C7C:  MOVF   x9B,W
1C7E:  SUBLW  FD
1C80:  BNC   1C9E
1C82:  BNZ   1C8A
1C84:  MOVF   x9A,W
1C86:  SUBLW  E7
1C88:  BNC   1C9E
1C8A:  BSF    F93.1
1C8C:  BTFSS  F81.1
1C8E:  BRA    1C9E
1C90:  BSF    F94.5
1C92:  BTFSS  F82.5
1C94:  BRA    1C9E
....................       card_timeout++; 
1C96:  INCF   x9A,F
1C98:  BTFSC  FD8.2
1C9A:  INCF   x9B,F
....................    } 
1C9C:  BRA    1C7C
....................    card_timeout=0; 
1C9E:  CLRF   x9B
1CA0:  CLRF   x9A
....................    buffertrack1[bug_countbit_T1++]=0; 
1CA2:  MOVFF  997,03
1CA6:  MOVF   x96,W
1CA8:  INCF   x96,F
1CAA:  BTFSC  FD8.2
1CAC:  INCF   x97,F
1CAE:  MOVLB  A
1CB0:  MOVWF  xEB
1CB2:  MOVLW  0F
1CB4:  ADDWF  xEB,W
1CB6:  MOVWF  FE9
1CB8:  MOVLW  05
1CBA:  ADDWFC 03,W
1CBC:  MOVWF  FEA
1CBE:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1CC0:  MOVLB  9
1CC2:  MOVFF  997,03
1CC6:  MOVF   x96,W
1CC8:  INCF   x96,F
1CCA:  BTFSC  FD8.2
1CCC:  INCF   x97,F
1CCE:  MOVLB  A
1CD0:  MOVWF  xEB
1CD2:  MOVLW  0F
1CD4:  ADDWF  xEB,W
1CD6:  MOVWF  FE9
1CD8:  MOVLW  05
1CDA:  ADDWFC 03,W
1CDC:  MOVWF  FEA
1CDE:  MOVLW  01
1CE0:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1CE2:  MOVLB  9
1CE4:  MOVFF  999,03
1CE8:  MOVF   x98,W
1CEA:  INCF   x98,F
1CEC:  BTFSC  FD8.2
1CEE:  INCF   x99,F
1CF0:  MOVLB  A
1CF2:  MOVWF  xEB
1CF4:  MOVLW  61
1CF6:  ADDWF  xEB,W
1CF8:  MOVWF  FE9
1CFA:  MOVLW  08
1CFC:  ADDWFC 03,W
1CFE:  MOVWF  FEA
1D00:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1D02:  MOVLB  9
1D04:  MOVFF  999,03
1D08:  MOVF   x98,W
1D0A:  INCF   x98,F
1D0C:  BTFSC  FD8.2
1D0E:  INCF   x99,F
1D10:  MOVLB  A
1D12:  MOVWF  xEB
1D14:  MOVLW  61
1D16:  ADDWF  xEB,W
1D18:  MOVWF  FE9
1D1A:  MOVLW  08
1D1C:  ADDWFC 03,W
1D1E:  MOVWF  FEA
1D20:  MOVLW  01
1D22:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1D24:  MOVLB  9
1D26:  MOVF   x97,W
1D28:  SUBLW  03
1D2A:  BTFSS  FD8.0
1D2C:  BRA    1E0C
1D2E:  BNZ   1D38
1D30:  MOVF   x96,W
1D32:  SUBLW  51
1D34:  BTFSS  FD8.0
1D36:  BRA    1E0C
1D38:  MOVF   x99,W
1D3A:  SUBLW  01
1D3C:  BTFSS  FD8.0
1D3E:  BRA    1E0C
1D40:  BNZ   1D48
1D42:  MOVF   x98,W
1D44:  SUBLW  2B
1D46:  BNC   1E0C
1D48:  MOVF   x9B,W
1D4A:  SUBLW  FF
1D4C:  BNC   1E0C
1D4E:  BNZ   1D56
1D50:  MOVF   x9A,W
1D52:  SUBLW  DB
1D54:  BNC   1E0C
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
1D56:  MOVF   xA4,F
1D58:  BZ    1D62
....................          { 
....................             bug_countbit_T1=0; 
1D5A:  CLRF   x97
1D5C:  CLRF   x96
....................             bug_countbit_T2=0; 
1D5E:  CLRF   x99
1D60:  CLRF   x98
....................          } 
....................          card_timeout++; 
1D62:  INCF   x9A,F
1D64:  BTFSC  FD8.2
1D66:  INCF   x9B,F
....................          mcr_timeout=0; 
1D68:  CLRF   x90
1D6A:  CLRF   x8F
1D6C:  CLRF   x8E
1D6E:  CLRF   x8D
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1D70:  BSF    F93.2
1D72:  MOVLB  A
1D74:  CLRF   xE2
1D76:  BTFSC  F81.2
1D78:  INCF   xE2,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1D7A:  MOVF   xE2,F
1D7C:  BNZ   1DBA
1D7E:  DECFSZ xE3,W
1D80:  BRA    1DBA
....................          { 
....................             ST1_old = 0; 
1D82:  CLRF   xE3
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1D84:  MOVLW  0F
1D86:  MOVLB  9
1D88:  ADDWF  x96,W
1D8A:  MOVWF  FE9
1D8C:  MOVLW  05
1D8E:  ADDWFC x97,W
1D90:  MOVWF  FEA
1D92:  BSF    F93.1
1D94:  MOVLW  00
1D96:  BTFSS  F81.1
1D98:  MOVLW  01
1D9A:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1D9C:  MOVLW  61
1D9E:  ADDWF  x98,W
1DA0:  MOVWF  FE9
1DA2:  MOVLW  08
1DA4:  ADDWFC x99,W
1DA6:  MOVWF  FEA
1DA8:  MOVFF  AE6,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1DAC:  INCF   x96,F
1DAE:  BTFSC  FD8.2
1DB0:  INCF   x97,F
....................             card_timeout=0; 
1DB2:  CLRF   x9B
1DB4:  CLRF   x9A
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1DB6:  BRA    1DC4
1DB8:  MOVLB  A
1DBA:  DECFSZ xE2,W
1DBC:  BRA    1DC2
1DBE:  MOVLW  01
1DC0:  MOVWF  xE3
1DC2:  MOVLB  9
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1DC4:  BSF    F93.3
1DC6:  MOVLB  A
1DC8:  CLRF   xE4
1DCA:  BTFSC  F81.3
1DCC:  INCF   xE4,F
....................          if(ST2 == 0 && ST2_old == 1) 
1DCE:  MOVF   xE4,F
1DD0:  BNZ   1DF0
1DD2:  DECFSZ xE5,W
1DD4:  BRA    1DF0
....................          { 
....................             ST2_old = 0; 
1DD6:  CLRF   xE5
....................             Bit_t2 = !input(MCR_DATA2); 
1DD8:  BSF    F94.5
1DDA:  CLRF   xE6
1DDC:  BTFSS  F82.5
1DDE:  INCF   xE6,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1DE0:  MOVLB  9
1DE2:  INCF   x98,F
1DE4:  BTFSC  FD8.2
1DE6:  INCF   x99,F
....................             card_timeout=0; 
1DE8:  CLRF   x9B
1DEA:  CLRF   x9A
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1DEC:  BRA    1DFA
1DEE:  MOVLB  A
1DF0:  DECFSZ xE4,W
1DF2:  BRA    1DF8
1DF4:  MOVLW  01
1DF6:  MOVWF  xE5
1DF8:  MOVLB  9
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1DFA:  BSF    F93.0
1DFC:  BTFSS  F81.0
1DFE:  BRA    1E0A
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1E00:  CLRF   xA4
....................             card_timeout=65500; 
1E02:  SETF   x9B
1E04:  MOVLW  DC
1E06:  MOVWF  x9A
....................             break;            
1E08:  BRA    1E0C
....................          } 
....................       } 
1E0A:  BRA    1D26
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1E0C:  CLRF   x9B
1E0E:  CLRF   x9A
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1E10:  MOVLB  A
1E12:  CLRF   xF4
1E14:  MOVFF  997,AF6
1E18:  MOVFF  996,AF5
1E1C:  MOVLW  05
1E1E:  MOVWF  xF8
1E20:  MOVLW  0F
1E22:  MOVWF  xF7
1E24:  MOVLB  0
1E26:  CALL   0966
1E2A:  MOVFF  01,AE7
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1E2E:  MOVLW  01
1E30:  MOVLB  A
1E32:  MOVWF  xF4
1E34:  MOVFF  999,AF6
1E38:  MOVFF  998,AF5
1E3C:  MOVLW  08
1E3E:  MOVWF  xF8
1E40:  MOVLW  61
1E42:  MOVWF  xF7
1E44:  MOVLB  0
1E46:  CALL   0966
1E4A:  MOVFF  01,AE8
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1E4E:  MOVLB  9
1E50:  DECFSZ x9F,W
1E52:  BRA    1EF4
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1E54:  MOVLW  30
1E56:  MOVWF  FF6
1E58:  MOVLW  05
1E5A:  MOVWF  FF7
1E5C:  MOVLW  0E
1E5E:  MOVLB  B
1E60:  MOVWF  x0E
1E62:  MOVLB  0
1E64:  RCALL  19C8
1E66:  MOVLW  10
1E68:  MOVWF  FE9
1E6A:  MOVFF  997,AEC
1E6E:  MOVFF  996,AEB
1E72:  RCALL  19F2
1E74:  MOVLW  0D
1E76:  MOVLB  B
1E78:  MOVWF  x1A
1E7A:  MOVLB  0
1E7C:  CALL   05AA
1E80:  MOVLW  0A
1E82:  MOVLB  B
1E84:  MOVWF  x1A
1E86:  MOVLB  0
1E88:  CALL   05AA
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1E8C:  MOVLW  44
1E8E:  MOVWF  FF6
1E90:  MOVLW  05
1E92:  MOVWF  FF7
1E94:  MOVLW  0E
1E96:  MOVLB  B
1E98:  MOVWF  x0E
1E9A:  MOVLB  0
1E9C:  RCALL  19C8
1E9E:  MOVLW  10
1EA0:  MOVWF  FE9
1EA2:  MOVFF  999,AEC
1EA6:  MOVFF  998,AEB
1EAA:  RCALL  19F2
1EAC:  MOVLW  0D
1EAE:  MOVLB  B
1EB0:  MOVWF  x1A
1EB2:  MOVLB  0
1EB4:  CALL   05AA
1EB8:  MOVLW  0A
1EBA:  MOVLB  B
1EBC:  MOVWF  x1A
1EBE:  MOVLB  0
1EC0:  CALL   05AA
....................          debug_reader();       
1EC4:  BRA    1BA0
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1EC6:  MOVLB  A
1EC8:  MOVF   xE7,F
1ECA:  BNZ   1EDC
1ECC:  MOVLW  58
1ECE:  MOVWF  FF6
1ED0:  MOVLW  05
1ED2:  MOVWF  FF7
1ED4:  MOVLB  0
1ED6:  CALL   05F0
1EDA:  MOVLB  A
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1EDC:  MOVF   xE8,F
1EDE:  BNZ   1EF0
1EE0:  MOVLW  6E
1EE2:  MOVWF  FF6
1EE4:  MOVLW  05
1EE6:  MOVWF  FF7
1EE8:  MOVLB  0
1EEA:  CALL   05F0
1EEE:  MOVLB  A
....................       } 
....................          else 
1EF0:  BRA    1F00
1EF2:  MOVLB  9
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1EF4:  MOVLW  0F
1EF6:  MOVLB  A
1EF8:  MOVWF  xEB
1EFA:  MOVLB  0
1EFC:  RCALL  1C34
1EFE:  MOVLB  A
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1F00:  MOVF   xE7,F
1F02:  BZ    1F08
1F04:  MOVF   xE8,F
1F06:  BNZ   1F28
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1F08:  MOVLB  9
1F0A:  CLRF   x99
1F0C:  CLRF   x98
....................          bug_countbit_T1=0; 
1F0E:  CLRF   x97
1F10:  CLRF   x96
....................          reading_fg=0; 
1F12:  CLRF   xA3
....................          count_reading_error++; 
1F14:  INCF   xA4,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1F16:  CLRF   x90
1F18:  CLRF   x8F
1F1A:  CLRF   x8E
1F1C:  CLRF   x8D
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1F1E:  MOVLW  00
1F20:  MOVWF  01
1F22:  BRA    1F60
....................       } 
....................          else  
1F24:  BRA    1F5C
1F26:  MOVLB  A
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1F28:  MOVLW  01
1F2A:  MOVLB  9
1F2C:  MOVWF  x9E
....................             reading_fg=1; 
1F2E:  MOVWF  xA3
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1F30:  MOVFF  999,995
1F34:  MOVFF  998,994
....................             countbit_T1=bug_countbit_T1; 
1F38:  MOVFF  997,993
1F3C:  MOVFF  996,992
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1F40:  CLRF   x97
1F42:  CLRF   x96
....................             bug_countbit_T2=0;  
1F44:  CLRF   x99
1F46:  CLRF   x98
....................             mcr_timeout=0; 
1F48:  CLRF   x90
1F4A:  CLRF   x8F
1F4C:  CLRF   x8E
1F4E:  CLRF   x8D
....................             charac_timeout=0; 
1F50:  MOVLB  0
1F52:  CLRF   xFC
1F54:  CLRF   xFB
....................             return 1; 
1F56:  MOVWF  01
1F58:  MOVLB  9
1F5A:  BRA    1F60
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1F5C:  MOVLW  00
1F5E:  MOVWF  01
.................... } 
1F60:  MOVLB  0
1F62:  GOTO   1FCA (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
1F66:  MOVLW  02
1F68:  MOVLB  A
1F6A:  MOVWF  xE2
1F6C:  MOVLW  FA
1F6E:  MOVWF  xE3
1F70:  MOVLB  0
1F72:  GOTO   0584
1F76:  MOVLB  A
1F78:  DECFSZ xE2,F
1F7A:  BRA    1F6C
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
1F7C:  MOVLB  9
1F7E:  DECFSZ xA1,W
1F80:  BRA    1F84
1F82:  BRA    1FDC
....................       if((KP_mode)&&(enable_getpin==0)) 
1F84:  MOVLB  1
1F86:  MOVF   x0C,F
1F88:  BZ    1FC6
1F8A:  MOVF   x09,F
1F8C:  BNZ   1FC6
....................       { 
....................          if(kp_st==1) 
1F8E:  DECFSZ x0D,W
1F90:  BRA    1FAA
....................          { 
....................             printf("\n\rKey release\n\r"); 
1F92:  MOVLW  E4
1F94:  MOVWF  FF6
1F96:  MOVLW  1F
1F98:  MOVWF  FF7
1F9A:  MOVLB  0
1F9C:  CALL   05F0
....................             keyprss_off; 
1FA0:  BCF    F92.7
1FA2:  BCF    F89.7
....................             kp_st=0; 
1FA4:  MOVLB  1
1FA6:  CLRF   x0D
....................          } 
....................          else 
1FA8:  BRA    1FC6
....................          { 
....................             printf("\n\rKey press\n\r"); 
1FAA:  MOVLW  F4
1FAC:  MOVWF  FF6
1FAE:  MOVLW  1F
1FB0:  MOVWF  FF7
1FB2:  MOVLB  0
1FB4:  CALL   05F0
....................             keyprss_on; 
1FB8:  BCF    F92.7
1FBA:  BSF    F89.7
....................             kp_st=1;  
1FBC:  MOVLW  01
1FBE:  MOVLB  1
1FC0:  MOVWF  x0D
....................             count_kp=0; 
1FC2:  CLRF   x0F
1FC4:  CLRF   x0E
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1FC6:  MOVLB  0
1FC8:  BRA    1C5C
1FCA:  MOVFF  01,9A0
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1FCE:  MOVLB  9
1FD0:  CLRF   x90
1FD2:  CLRF   x8F
1FD4:  CLRF   x8E
1FD6:  CLRF   x8D
....................       card_timeout=0; 
1FD8:  CLRF   x9B
1FDA:  CLRF   x9A
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1FDC:  BCF    FF0.0
1FDE:  MOVLB  0
1FE0:  GOTO   0084
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
54C2:  CLRF   19
54C4:  BTFSC  FF2.7
54C6:  BSF    19.7
54C8:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
54CA:  MOVLB  B
54CC:  CLRF   x03
54CE:  MOVLW  94
54D0:  MOVWF  x02
54D2:  MOVLW  03
54D4:  MOVWF  x04
54D6:  MOVLB  0
54D8:  CALL   3FE4
54DC:  BTFSC  19.7
54DE:  BSF    FF2.7
54E0:  CLRF   19
54E2:  BTFSC  FF2.7
54E4:  BSF    19.7
54E6:  BCF    FF2.7
....................    //write_ext_eeprom(strobe_delaykb,100); 
....................    //write_ext_eeprom(KB_time,2); 
....................    write_ext_eeprom(strobe_Master_SLV,1);    
54E8:  MOVLB  B
54EA:  CLRF   x03
54EC:  MOVLW  91
54EE:  MOVWF  x02
54F0:  MOVLW  01
54F2:  MOVWF  x04
54F4:  MOVLB  0
54F6:  CALL   3FE4
54FA:  BTFSC  19.7
54FC:  BSF    FF2.7
54FE:  CLRF   19
5500:  BTFSC  FF2.7
5502:  BSF    19.7
5504:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
5506:  MOVLB  A
5508:  CLRF   xEF
550A:  MOVLW  91
550C:  MOVWF  xEE
550E:  MOVLB  0
5510:  CALL   3A84
5514:  BTFSC  19.7
5516:  BSF    FF2.7
5518:  MOVFF  01,9AB
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
....................    #endif 
....................     
.................... } 
551C:  GOTO   5E08 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
57C8:  MOVLW  09
57CA:  MOVWF  FEA
57CC:  MOVLW  B0
57CE:  MOVWF  FE9
57D0:  BRA    50DE
57D2:  CLRF   19
57D4:  BTFSC  FF2.7
57D6:  BSF    19.7
57D8:  BCF    FF2.7
57DA:  MOVLW  3E
57DC:  MOVLB  B
57DE:  MOVWF  x1A
57E0:  MOVLB  0
57E2:  CALL   05AA
57E6:  BTFSC  19.7
57E8:  BSF    FF2.7
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
57EA:  MOVLW  01
57EC:  MOVLB  A
57EE:  MOVWF  xBE
57F0:  MOVLW  14
57F2:  MOVWF  xBF
57F4:  MOVLW  01
57F6:  MOVWF  xC1
57F8:  MOVLW  4B
57FA:  MOVWF  xC0
57FC:  MOVLB  0
57FE:  CALL   4F0E
5802:  CLRF   19
5804:  BTFSC  FF2.7
5806:  BSF    19.7
5808:  BCF    FF2.7
....................       printf("\n\r"); 
580A:  MOVLW  0A
580C:  MOVLB  B
580E:  MOVWF  x1A
5810:  MOVLB  0
5812:  CALL   05AA
5816:  BTFSC  19.7
5818:  BSF    FF2.7
581A:  CLRF   19
581C:  BTFSC  FF2.7
581E:  BSF    19.7
5820:  BCF    FF2.7
5822:  MOVLW  0D
5824:  MOVLB  B
5826:  MOVWF  x1A
5828:  MOVLB  0
582A:  CALL   05AA
582E:  BTFSC  19.7
5830:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
5832:  CLRF   FEA
5834:  MOVLW  41
5836:  MOVWF  FE9
5838:  MOVLW  00
583A:  CALL   0134
583E:  TBLRD*-
5840:  TBLRD*+
5842:  MOVF   FF5,W
5844:  MOVWF  FEE
5846:  IORLW  00
5848:  BNZ   5840
....................       index=0; 
584A:  MOVLB  A
584C:  CLRF   x88
....................       ee_dat=0; 
584E:  MOVLB  9
5850:  CLRF   xA6
....................       count_card=1; 
5852:  CLRF   xA8
5854:  MOVLW  01
5856:  MOVWF  xA7
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
5858:  MOVLB  A
585A:  MOVWF  xBF
585C:  MOVLW  4B
585E:  MOVWF  xBE
5860:  CLRF   xC1
5862:  MOVLW  41
5864:  MOVWF  xC0
5866:  MOVLB  0
5868:  CALL   5046
586C:  MOVF   01,F
586E:  BTFSS  FD8.2
5870:  BRA    5C32
....................       { 
....................          unsigned long adr=0; 
5872:  MOVLB  A
5874:  CLRF   xBD
5876:  CLRF   xBC
....................          //unsigned int count=0; 
....................          rec[0]=0; 
5878:  MOVLB  0
587A:  CLRF   x7D
587C:  CLRF   19
587E:  BTFSC  FF2.7
5880:  BSF    19.7
5882:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
5884:  CALL   3B2C
5888:  BTFSC  19.7
588A:  BSF    FF2.7
588C:  MOVFF  02,9AA
5890:  MOVFF  01,9A9
5894:  CLRF   19
5896:  BTFSC  FF2.7
5898:  BSF    19.7
589A:  BCF    FF2.7
....................          adr=count_card*numdata; 
589C:  MOVFF  9A8,AEB
58A0:  MOVFF  9A7,AEA
58A4:  MOVLB  A
58A6:  CLRF   xED
58A8:  MOVLW  7C
58AA:  MOVWF  xEC
58AC:  MOVLB  0
58AE:  CALL   3B7C
58B2:  BTFSC  19.7
58B4:  BSF    FF2.7
58B6:  MOVFF  02,ABD
58BA:  MOVFF  01,ABC
....................          addr_key=EEPROM_KEY_ST; 
58BE:  MOVLB  9
58C0:  CLRF   xAF
58C2:  CLRF   xAE
58C4:  MOVLW  AA
58C6:  MOVWF  xAD
58C8:  MOVLW  47
58CA:  MOVWF  xAC
....................          while(count_card<=count_card_tg) 
....................          { 
58CC:  MOVF   xA8,W
58CE:  SUBWF  xAA,W
58D0:  BTFSS  FD8.0
58D2:  BRA    5C30
58D4:  BNZ   58DE
58D6:  MOVF   xA7,W
58D8:  SUBWF  xA9,W
58DA:  BTFSS  FD8.0
58DC:  BRA    5C30
58DE:  CLRF   19
58E0:  BTFSC  FF2.7
58E2:  BSF    19.7
58E4:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
58E6:  MOVFF  9A8,AEB
58EA:  MOVFF  9A7,AEA
58EE:  MOVLB  A
58F0:  CLRF   xED
58F2:  MOVLW  7C
58F4:  MOVWF  xEC
58F6:  MOVLB  0
58F8:  CALL   3B7C
58FC:  BTFSC  19.7
58FE:  BSF    FF2.7
5900:  MOVLW  96
5902:  MOVLB  A
5904:  ADDWF  01,W
5906:  MOVWF  xBC
5908:  MOVLW  00
590A:  ADDWFC 02,W
590C:  MOVWF  xBD
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
590E:  MOVLW  7C
5910:  SUBWF  xBC,W
5912:  MOVWF  xBE
5914:  MOVLW  00
5916:  SUBWFB xBD,W
5918:  MOVWF  xBF
591A:  MOVWF  xC1
591C:  MOVFF  ABE,AC0
5920:  CLRF   xC3
5922:  MOVLW  7C
5924:  MOVWF  xC2
5926:  CLRF   xC5
5928:  MOVLW  7D
592A:  MOVWF  xC4
592C:  MOVLB  0
592E:  GOTO   5112
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
5932:  MOVLW  10
5934:  MOVWF  FE9
5936:  CLRF   19
5938:  BTFSC  FF2.7
593A:  BSF    19.7
593C:  BCF    FF2.7
593E:  MOVFF  9A8,AE6
5942:  MOVFF  9A7,AE5
5946:  CALL   4790
594A:  BTFSC  19.7
594C:  BSF    FF2.7
594E:  CLRF   19
5950:  BTFSC  FF2.7
5952:  BSF    19.7
5954:  BCF    FF2.7
5956:  MOVLW  29
5958:  MOVLB  B
595A:  MOVWF  x1A
595C:  MOVLB  0
595E:  CALL   05AA
5962:  BTFSC  19.7
5964:  BSF    FF2.7
5966:  MOVFF  7D,ABE
596A:  MOVLW  01
596C:  MOVLB  A
596E:  MOVWF  xBF
5970:  MOVLB  0
5972:  RCALL  5198
5974:  CLRF   19
5976:  BTFSC  FF2.7
5978:  BSF    19.7
597A:  BCF    FF2.7
597C:  MOVLW  2F
597E:  MOVLB  B
5980:  MOVWF  x1A
5982:  MOVLB  0
5984:  CALL   05AA
5988:  BTFSC  19.7
598A:  BSF    FF2.7
598C:  MOVFF  7E,ABE
5990:  MOVLW  01
5992:  MOVLB  A
5994:  MOVWF  xBF
5996:  MOVLB  0
5998:  CALL   5198
599C:  CLRF   19
599E:  BTFSC  FF2.7
59A0:  BSF    19.7
59A2:  BCF    FF2.7
59A4:  MOVLW  20
59A6:  MOVLB  B
59A8:  MOVWF  x1A
59AA:  MOVLB  0
59AC:  CALL   05AA
59B0:  BTFSC  19.7
59B2:  BSF    FF2.7
59B4:  MOVFF  7F,ABE
59B8:  MOVLW  01
59BA:  MOVLB  A
59BC:  MOVWF  xBF
59BE:  MOVLB  0
59C0:  CALL   5198
59C4:  CLRF   19
59C6:  BTFSC  FF2.7
59C8:  BSF    19.7
59CA:  BCF    FF2.7
59CC:  MOVLW  3A
59CE:  MOVLB  B
59D0:  MOVWF  x1A
59D2:  MOVLB  0
59D4:  CALL   05AA
59D8:  BTFSC  19.7
59DA:  BSF    FF2.7
59DC:  MOVFF  80,ABE
59E0:  MOVLW  01
59E2:  MOVLB  A
59E4:  MOVWF  xBF
59E6:  MOVLB  0
59E8:  CALL   5198
59EC:  CLRF   19
59EE:  BTFSC  FF2.7
59F0:  BSF    19.7
59F2:  BCF    FF2.7
59F4:  MOVLW  3A
59F6:  MOVLB  B
59F8:  MOVWF  x1A
59FA:  MOVLB  0
59FC:  CALL   05AA
5A00:  BTFSC  19.7
5A02:  BSF    FF2.7
5A04:  MOVFF  81,ABE
5A08:  MOVLW  01
5A0A:  MOVLB  A
5A0C:  MOVWF  xBF
5A0E:  MOVLB  0
5A10:  CALL   5198
....................             ee_dat=0; 
5A14:  MOVLB  9
5A16:  CLRF   xA6
....................             index=0; 
5A18:  MOVLB  A
5A1A:  CLRF   x88
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
5A1C:  MOVLW  26
5A1E:  MOVWF  FF6
5A20:  MOVLW  20
5A22:  MOVWF  FF7
5A24:  CLRF   19
5A26:  BTFSC  FF2.7
5A28:  BSF    19.7
5A2A:  BCF    FF2.7
5A2C:  MOVLB  0
5A2E:  CALL   05F0
5A32:  BTFSC  19.7
5A34:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
5A36:  MOVLB  A
5A38:  MOVF   x88,W
5A3A:  SUBLW  4E
5A3C:  BNC   5A9A
5A3E:  MOVLB  9
5A40:  MOVF   xA6,W
5A42:  SUBLW  3F
5A44:  BTFSS  FD8.2
5A46:  BRA    5A4C
5A48:  MOVLB  A
5A4A:  BRA    5A9A
....................                ee_dat = rec[index+5]; 
5A4C:  MOVLW  05
5A4E:  MOVLB  A
5A50:  ADDWF  x88,W
5A52:  CLRF   03
5A54:  ADDLW  7D
5A56:  MOVWF  FE9
5A58:  MOVLW  00
5A5A:  ADDWFC 03,W
5A5C:  MOVWF  FEA
5A5E:  MOVFF  FEF,9A6
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
5A62:  MOVLB  9
5A64:  MOVF   xA6,W
5A66:  SUBLW  1F
5A68:  BC    5A86
5A6A:  MOVF   xA6,W
5A6C:  SUBLW  7E
5A6E:  BNC   5A86
5A70:  CLRF   19
5A72:  BTFSC  FF2.7
5A74:  BSF    19.7
5A76:  BCF    FF2.7
5A78:  MOVFF  9A6,B1A
5A7C:  MOVLB  0
5A7E:  CALL   05AA
5A82:  BTFSC  19.7
5A84:  BSF    FF2.7
....................                index++; 
5A86:  MOVLB  A
5A88:  INCF   x88,F
....................                if(ee_dat==0)break; 
5A8A:  MOVLB  9
5A8C:  MOVF   xA6,F
5A8E:  BNZ   5A94
5A90:  MOVLB  A
5A92:  BRA    5A9A
....................             } 
5A94:  MOVLB  0
5A96:  BRA    5A36
5A98:  MOVLB  A
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
5A9A:  MOVLW  38
5A9C:  MOVWF  FF6
5A9E:  MOVLW  20
5AA0:  MOVWF  FF7
5AA2:  CLRF   19
5AA4:  BTFSC  FF2.7
5AA6:  BSF    19.7
5AA8:  BCF    FF2.7
5AAA:  MOVLB  0
5AAC:  CALL   05F0
5AB0:  BTFSC  19.7
5AB2:  BSF    FF2.7
....................             index=0; 
5AB4:  MOVLB  A
5AB6:  CLRF   x88
....................             ee_dat=0; 
5AB8:  MOVLB  9
5ABA:  CLRF   xA6
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
5ABC:  MOVLB  A
5ABE:  MOVF   x88,W
5AC0:  SUBLW  27
5AC2:  BNC   5B22
5AC4:  MOVLB  9
5AC6:  MOVF   xA6,W
5AC8:  SUBLW  3F
5ACA:  BTFSS  FD8.2
5ACC:  BRA    5AD2
5ACE:  MOVLB  A
5AD0:  BRA    5B22
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
5AD2:  MOVLW  05
5AD4:  MOVLB  A
5AD6:  ADDWF  x88,W
5AD8:  ADDLW  4F
5ADA:  CLRF   03
5ADC:  ADDLW  7D
5ADE:  MOVWF  FE9
5AE0:  MOVLW  00
5AE2:  ADDWFC 03,W
5AE4:  MOVWF  FEA
5AE6:  MOVFF  FEF,9A6
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
5AEA:  MOVLB  9
5AEC:  MOVF   xA6,W
5AEE:  SUBLW  1F
5AF0:  BC    5B0E
5AF2:  MOVF   xA6,W
5AF4:  SUBLW  7E
5AF6:  BNC   5B0E
5AF8:  CLRF   19
5AFA:  BTFSC  FF2.7
5AFC:  BSF    19.7
5AFE:  BCF    FF2.7
5B00:  MOVFF  9A6,B1A
5B04:  MOVLB  0
5B06:  CALL   05AA
5B0A:  BTFSC  19.7
5B0C:  BSF    FF2.7
....................                index++; 
5B0E:  MOVLB  A
5B10:  INCF   x88,F
....................                if(ee_dat==0)break; 
5B12:  MOVLB  9
5B14:  MOVF   xA6,F
5B16:  BNZ   5B1E
5B18:  MOVLB  A
5B1A:  BRA    5B22
5B1C:  MOVLB  9
....................             } 
5B1E:  BRA    5ABC
5B20:  MOVLB  A
....................             index=0; 
5B22:  CLRF   x88
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
5B24:  MOVLW  4A
5B26:  MOVWF  FF6
5B28:  MOVLW  20
5B2A:  MOVWF  FF7
5B2C:  CLRF   19
5B2E:  BTFSC  FF2.7
5B30:  BSF    19.7
5B32:  BCF    FF2.7
5B34:  MOVLB  0
5B36:  CALL   05F0
5B3A:  BTFSC  19.7
5B3C:  BSF    FF2.7
....................             if(ptr_card_key>addr_key) 
5B3E:  MOVLB  9
5B40:  MOVF   xAF,W
5B42:  SUBWF  27,W
5B44:  BTFSS  FD8.0
5B46:  BRA    5C28
5B48:  BNZ   5B62
5B4A:  MOVF   xAE,W
5B4C:  SUBWF  26,W
5B4E:  BTFSS  FD8.0
5B50:  BRA    5C28
5B52:  BNZ   5B62
5B54:  MOVF   xAD,W
5B56:  SUBWF  25,W
5B58:  BNC   5C28
5B5A:  BNZ   5B62
5B5C:  MOVF   24,W
5B5E:  SUBWF  xAC,W
5B60:  BC    5C28
....................             { 
....................                i=0; 
5B62:  MOVLB  A
5B64:  CLRF   x89
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
5B66:  MOVF   x89,W
5B68:  MOVLB  9
5B6A:  ADDWF  xAC,W
5B6C:  MOVLB  A
5B6E:  MOVWF  xBE
5B70:  MOVLW  00
5B72:  MOVLB  9
5B74:  ADDWFC xAD,W
5B76:  MOVLB  A
5B78:  MOVWF  xBF
5B7A:  CLRF   19
5B7C:  BTFSC  FF2.7
5B7E:  BSF    19.7
5B80:  BCF    FF2.7
5B82:  MOVWF  xEF
5B84:  MOVFF  ABE,AEE
5B88:  MOVLB  0
5B8A:  CALL   3A84
5B8E:  BTFSC  19.7
5B90:  BSF    FF2.7
5B92:  MOVFF  01,9A6
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<73)) 
5B96:  MOVLB  9
5B98:  MOVF   xA6,W
5B9A:  SUBLW  2F
5B9C:  BC    5BA4
5B9E:  MOVF   xA6,W
5BA0:  SUBLW  39
5BA2:  BC    5BBC
5BA4:  MOVF   xA6,W
5BA6:  SUBLW  23
5BA8:  BZ    5BBC
5BAA:  MOVF   xA6,W
5BAC:  SUBLW  2A
5BAE:  BZ    5BBC
5BB0:  MOVF   xA6,W
5BB2:  SUBLW  40
5BB4:  BC    5BD2
5BB6:  MOVF   xA6,W
5BB8:  SUBLW  48
5BBA:  BNC   5BD2
5BBC:  CLRF   19
5BBE:  BTFSC  FF2.7
5BC0:  BSF    19.7
5BC2:  BCF    FF2.7
....................                      fputc(ee_dat,COM2); 
5BC4:  MOVFF  9A6,B1A
5BC8:  MOVLB  0
5BCA:  CALL   05AA
5BCE:  BTFSC  19.7
5BD0:  BSF    FF2.7
....................                   i++; 
5BD2:  MOVLB  A
5BD4:  INCF   x89,F
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
5BD6:  MOVF   x89,W
5BD8:  SUBLW  31
5BDA:  BNC   5BE8
5BDC:  MOVLB  9
5BDE:  MOVF   xA6,F
5BE0:  BTFSC  FD8.2
5BE2:  BRA    5BE8
5BE4:  MOVLB  A
5BE6:  BRA    5B66
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+50; 
5BE8:  MOVLW  32
5BEA:  MOVLB  9
5BEC:  ADDWF  xAC,F
5BEE:  MOVLW  00
5BF0:  ADDWFC xAD,F
5BF2:  ADDWFC xAE,F
5BF4:  ADDWFC xAF,F
5BF6:  CLRF   19
5BF8:  BTFSC  FF2.7
5BFA:  BSF    19.7
5BFC:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
5BFE:  MOVLW  0A
5C00:  MOVLB  B
5C02:  MOVWF  x1A
5C04:  MOVLB  0
5C06:  CALL   05AA
5C0A:  BTFSC  19.7
5C0C:  BSF    FF2.7
5C0E:  CLRF   19
5C10:  BTFSC  FF2.7
5C12:  BSF    19.7
5C14:  BCF    FF2.7
5C16:  MOVLW  0D
5C18:  MOVLB  B
5C1A:  MOVWF  x1A
5C1C:  MOVLB  0
5C1E:  CALL   05AA
5C22:  BTFSC  19.7
5C24:  BSF    FF2.7
5C26:  MOVLB  9
....................             } 
....................             count_card++; 
5C28:  INCF   xA7,F
5C2A:  BTFSC  FD8.2
5C2C:  INCF   xA8,F
....................          } 
5C2E:  BRA    58CC
5C30:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
5C32:  CLRF   FEA
5C34:  MOVLW  41
5C36:  MOVWF  FE9
5C38:  MOVLW  00
5C3A:  CALL   0146
5C3E:  TBLRD*-
5C40:  TBLRD*+
5C42:  MOVF   FF5,W
5C44:  MOVWF  FEE
5C46:  IORLW  00
5C48:  BNZ   5C40
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5C4A:  MOVLW  01
5C4C:  MOVLB  A
5C4E:  MOVWF  xBF
5C50:  MOVLW  4B
5C52:  MOVWF  xBE
5C54:  CLRF   xC1
5C56:  MOVLW  41
5C58:  MOVWF  xC0
5C5A:  MOVLB  0
5C5C:  CALL   5046
5C60:  MOVF   01,F
5C62:  BNZ   5C98
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
5C64:  MOVLW  5A
5C66:  MOVWF  FF6
5C68:  MOVLW  20
5C6A:  MOVWF  FF7
5C6C:  CLRF   19
5C6E:  BTFSC  FF2.7
5C70:  BSF    19.7
5C72:  BCF    FF2.7
5C74:  CALL   05F0
5C78:  BTFSC  19.7
5C7A:  BSF    FF2.7
....................          format_eepromext(); 
5C7C:  GOTO   52AE
....................          fprintf(COM2," exit\n\r");  
5C80:  MOVLW  68
5C82:  MOVWF  FF6
5C84:  MOVLW  20
5C86:  MOVWF  FF7
5C88:  CLRF   19
5C8A:  BTFSC  FF2.7
5C8C:  BSF    19.7
5C8E:  BCF    FF2.7
5C90:  CALL   05F0
5C94:  BTFSC  19.7
5C96:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
5C98:  CLRF   FEA
5C9A:  MOVLW  41
5C9C:  MOVWF  FE9
5C9E:  MOVLW  00
5CA0:  CALL   0158
5CA4:  TBLRD*-
5CA6:  TBLRD*+
5CA8:  MOVF   FF5,W
5CAA:  MOVWF  FEE
5CAC:  IORLW  00
5CAE:  BNZ   5CA6
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5CB0:  MOVLW  01
5CB2:  MOVLB  A
5CB4:  MOVWF  xBF
5CB6:  MOVLW  4B
5CB8:  MOVWF  xBE
5CBA:  CLRF   xC1
5CBC:  MOVLW  41
5CBE:  MOVWF  xC0
5CC0:  MOVLB  0
5CC2:  CALL   5046
5CC6:  MOVF   01,F
5CC8:  BNZ   5CFE
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
5CCA:  MOVLW  70
5CCC:  MOVWF  FF6
5CCE:  MOVLW  20
5CD0:  MOVWF  FF7
5CD2:  CLRF   19
5CD4:  BTFSC  FF2.7
5CD6:  BSF    19.7
5CD8:  BCF    FF2.7
5CDA:  CALL   05F0
5CDE:  BTFSC  19.7
5CE0:  BSF    FF2.7
....................          ease_eeprom(); 
5CE2:  GOTO   53D2
....................          fprintf(COM2," exit\n\r");  
5CE6:  MOVLW  7E
5CE8:  MOVWF  FF6
5CEA:  MOVLW  20
5CEC:  MOVWF  FF7
5CEE:  CLRF   19
5CF0:  BTFSC  FF2.7
5CF2:  BSF    19.7
5CF4:  BCF    FF2.7
5CF6:  CALL   05F0
5CFA:  BTFSC  19.7
5CFC:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
5CFE:  CLRF   FEA
5D00:  MOVLW  41
5D02:  MOVWF  FE9
5D04:  MOVLW  00
5D06:  CALL   016E
5D0A:  TBLRD*-
5D0C:  TBLRD*+
5D0E:  MOVF   FF5,W
5D10:  MOVWF  FEE
5D12:  IORLW  00
5D14:  BNZ   5D0C
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5D16:  MOVLW  01
5D18:  MOVLB  A
5D1A:  MOVWF  xBF
5D1C:  MOVLW  4B
5D1E:  MOVWF  xBE
5D20:  CLRF   xC1
5D22:  MOVLW  41
5D24:  MOVWF  xC0
5D26:  MOVLB  0
5D28:  CALL   5046
5D2C:  MOVF   01,F
5D2E:  BNZ   5D68
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
5D30:  MOVLW  86
5D32:  MOVWF  FF6
5D34:  MOVLW  20
5D36:  MOVWF  FF7
5D38:  CLRF   19
5D3A:  BTFSC  FF2.7
5D3C:  BSF    19.7
5D3E:  BCF    FF2.7
5D40:  CALL   05F0
5D44:  BTFSC  19.7
5D46:  BSF    FF2.7
....................          reset_password(); 
5D48:  GOTO   548C
....................          init_password(); 
5D4C:  CALL   4BFE
....................          fprintf(COM2," exit\n\r");  
5D50:  MOVLW  9C
5D52:  MOVWF  FF6
5D54:  MOVLW  20
5D56:  MOVWF  FF7
5D58:  CLRF   19
5D5A:  BTFSC  FF2.7
5D5C:  BSF    19.7
5D5E:  BCF    FF2.7
5D60:  CALL   05F0
5D64:  BTFSC  19.7
5D66:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
5D68:  CLRF   FEA
5D6A:  MOVLW  41
5D6C:  MOVWF  FE9
5D6E:  MOVLW  00
5D70:  CALL   0184
5D74:  TBLRD*-
5D76:  TBLRD*+
5D78:  MOVF   FF5,W
5D7A:  MOVWF  FEE
5D7C:  IORLW  00
5D7E:  BNZ   5D76
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5D80:  MOVLW  01
5D82:  MOVLB  A
5D84:  MOVWF  xBF
5D86:  MOVLW  4B
5D88:  MOVWF  xBE
5D8A:  CLRF   xC1
5D8C:  MOVLW  41
5D8E:  MOVWF  xC0
5D90:  MOVLB  0
5D92:  CALL   5046
5D96:  MOVF   01,F
5D98:  BNZ   5DBA
....................       { 
....................          keydebug_en=1; 
5D9A:  MOVLW  01
5D9C:  MOVLB  1
5D9E:  MOVWF  x08
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
5DA0:  MOVLW  A4
5DA2:  MOVWF  FF6
5DA4:  MOVLW  20
5DA6:  MOVWF  FF7
5DA8:  CLRF   19
5DAA:  BTFSC  FF2.7
5DAC:  BSF    19.7
5DAE:  BCF    FF2.7
5DB0:  MOVLB  0
5DB2:  CALL   05F0
5DB6:  BTFSC  19.7
5DB8:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
5DBA:  CLRF   FEA
5DBC:  MOVLW  41
5DBE:  MOVWF  FE9
5DC0:  MOVLW  00
5DC2:  CALL   019A
5DC6:  TBLRD*-
5DC8:  TBLRD*+
5DCA:  MOVF   FF5,W
5DCC:  MOVWF  FEE
5DCE:  IORLW  00
5DD0:  BNZ   5DC8
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5DD2:  MOVLW  01
5DD4:  MOVLB  A
5DD6:  MOVWF  xBF
5DD8:  MOVLW  4B
5DDA:  MOVWF  xBE
5DDC:  CLRF   xC1
5DDE:  MOVLW  41
5DE0:  MOVWF  xC0
5DE2:  MOVLB  0
5DE4:  CALL   5046
5DE8:  MOVF   01,F
5DEA:  BNZ   5E08
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
5DEC:  MOVLW  B8
5DEE:  MOVWF  FF6
5DF0:  MOVLW  20
5DF2:  MOVWF  FF7
5DF4:  CLRF   19
5DF6:  BTFSC  FF2.7
5DF8:  BSF    19.7
5DFA:  BCF    FF2.7
5DFC:  CALL   05F0
5E00:  BTFSC  19.7
5E02:  BSF    FF2.7
....................          rstfact(); 
5E04:  GOTO   54C2
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
5E08:  CLRF   FEA
5E0A:  MOVLW  41
5E0C:  MOVWF  FE9
5E0E:  MOVLW  00
5E10:  CALL   01B2
5E14:  TBLRD*-
5E16:  TBLRD*+
5E18:  MOVF   FF5,W
5E1A:  MOVWF  FEE
5E1C:  IORLW  00
5E1E:  BNZ   5E16
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
5E20:  MOVLW  01
5E22:  MOVLB  A
5E24:  MOVWF  xBF
5E26:  MOVLW  4B
5E28:  MOVWF  xBE
5E2A:  CLRF   xC1
5E2C:  MOVLW  41
5E2E:  MOVWF  xC0
5E30:  MOVLB  0
5E32:  CALL   5046
5E36:  MOVF   01,F
5E38:  BNZ   5E60
....................       { 
....................          mode=LOGOFF; 
5E3A:  MOVLB  9
5E3C:  CLRF   xA5
....................          keydebug_en=0; 
5E3E:  MOVLB  1
5E40:  CLRF   x08
....................          set_tris_a(0xff); 
5E42:  MOVLW  FF
5E44:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
5E46:  MOVLW  C8
5E48:  MOVWF  FF6
5E4A:  MOVLW  20
5E4C:  MOVWF  FF7
5E4E:  CLRF   19
5E50:  BTFSC  FF2.7
5E52:  BSF    19.7
5E54:  BCF    FF2.7
5E56:  MOVLB  0
5E58:  CALL   05F0
5E5C:  BTFSC  19.7
5E5E:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
5E60:  CLRF   FEA
5E62:  MOVLW  41
5E64:  MOVWF  FE9
5E66:  MOVLW  00
5E68:  CALL   01C4
5E6C:  TBLRD*-
5E6E:  TBLRD*+
5E70:  MOVF   FF5,W
5E72:  MOVWF  FEE
5E74:  IORLW  00
5E76:  BNZ   5E6E
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5E78:  MOVLW  01
5E7A:  MOVLB  A
5E7C:  MOVWF  xBF
5E7E:  MOVLW  4B
5E80:  MOVWF  xBE
5E82:  CLRF   xC1
5E84:  MOVLW  41
5E86:  MOVWF  xC0
5E88:  MOVLB  0
5E8A:  CALL   5046
5E8E:  MOVF   01,F
5E90:  BNZ   5EF2
....................       { 
....................          fprintf(COM2,"New console name>"); 
5E92:  MOVLW  D0
5E94:  MOVWF  FF6
5E96:  MOVLW  20
5E98:  MOVWF  FF7
5E9A:  CLRF   19
5E9C:  BTFSC  FF2.7
5E9E:  BSF    19.7
5EA0:  BCF    FF2.7
5EA2:  CALL   05F0
5EA6:  BTFSC  19.7
5EA8:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,16, console); 
5EAA:  MOVLW  01
5EAC:  MOVLB  A
5EAE:  MOVWF  xBE
5EB0:  MOVLW  10
5EB2:  MOVWF  xBF
5EB4:  MOVLW  09
5EB6:  MOVWF  xC1
5EB8:  MOVLW  B0
5EBA:  MOVWF  xC0
5EBC:  MOVLB  0
5EBE:  CALL   4F0E
....................          EEPROM_write(strobe_nameconsole,16,console); 
5EC2:  MOVLW  66
5EC4:  MOVLB  A
5EC6:  MOVWF  xD3
5EC8:  MOVLW  10
5ECA:  MOVWF  xD4
5ECC:  MOVLW  09
5ECE:  MOVWF  xD6
5ED0:  MOVLW  B0
5ED2:  MOVWF  xD5
5ED4:  MOVLB  0
5ED6:  CALL   4BAA
....................          fprintf(COM2," OK\n\r"); 
5EDA:  MOVLW  E2
5EDC:  MOVWF  FF6
5EDE:  MOVLW  20
5EE0:  MOVWF  FF7
5EE2:  CLRF   19
5EE4:  BTFSC  FF2.7
5EE6:  BSF    19.7
5EE8:  BCF    FF2.7
5EEA:  CALL   05F0
5EEE:  BTFSC  19.7
5EF0:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
5EF2:  CLRF   FEA
5EF4:  MOVLW  41
5EF6:  MOVWF  FE9
5EF8:  MOVLW  00
5EFA:  CALL   01D6
5EFE:  TBLRD*-
5F00:  TBLRD*+
5F02:  MOVF   FF5,W
5F04:  MOVWF  FEE
5F06:  IORLW  00
5F08:  BNZ   5F00
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
5F0A:  MOVLW  01
5F0C:  MOVLB  A
5F0E:  MOVWF  xBF
5F10:  MOVLW  4B
5F12:  MOVWF  xBE
5F14:  CLRF   xC1
5F16:  MOVLW  41
5F18:  MOVWF  xC0
5F1A:  MOVLB  0
5F1C:  CALL   5046
5F20:  MOVF   01,F
5F22:  BTFSS  FD8.2
5F24:  BRA    6182
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
*
5FF0:  MOVLB  A
5FF2:  CLRF   xEF
5FF4:  MOVLW  91
5FF6:  MOVWF  xEE
5FF8:  MOVLB  0
5FFA:  CALL   3A84
5FFE:  BTFSC  19.7
6000:  BSF    FF2.7
6002:  MOVFF  01,9AB
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6006:  MOVLB  9
6008:  MOVF   xAB,F
600A:  BNZ   602A
600C:  MOVLW  E8
600E:  MOVWF  FF6
6010:  MOVLW  20
6012:  MOVWF  FF7
6014:  CLRF   19
6016:  BTFSC  FF2.7
6018:  BSF    19.7
601A:  BCF    FF2.7
601C:  MOVLB  0
601E:  CALL   05F0
6022:  BTFSC  19.7
6024:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6026:  BRA    6044
6028:  MOVLB  9
602A:  MOVLW  EC
602C:  MOVWF  FF6
602E:  MOVLW  20
6030:  MOVWF  FF7
6032:  CLRF   19
6034:  BTFSC  FF2.7
6036:  BSF    19.7
6038:  BCF    FF2.7
603A:  MOVLB  0
603C:  CALL   05F0
6040:  BTFSC  19.7
6042:  BSF    FF2.7
6044:  CLRF   19
6046:  BTFSC  FF2.7
6048:  BSF    19.7
604A:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
604C:  MOVLB  A
604E:  CLRF   xEF
6050:  MOVLW  94
6052:  MOVWF  xEE
6054:  MOVLB  0
6056:  CALL   3A84
605A:  BTFSC  19.7
605C:  BSF    FF2.7
605E:  MOVFF  01,143
6062:  CLRF   19
6064:  BTFSC  FF2.7
6066:  BSF    19.7
6068:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
606A:  MOVLW  5B
606C:  MOVLB  B
606E:  MOVWF  x1A
6070:  MOVLB  0
6072:  CALL   05AA
6076:  BTFSC  19.7
6078:  BSF    FF2.7
607A:  MOVFF  143,ABE
607E:  MOVLW  1B
6080:  MOVLB  A
6082:  MOVWF  xBF
6084:  MOVLB  0
6086:  GOTO   5520
608A:  CLRF   19
608C:  BTFSC  FF2.7
608E:  BSF    19.7
6090:  BCF    FF2.7
6092:  MOVLW  5D
6094:  MOVLB  B
6096:  MOVWF  x1A
6098:  MOVLB  0
609A:  CALL   05AA
609E:  BTFSC  19.7
60A0:  BSF    FF2.7
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
60A2:  MOVFF  100,ABE
60A6:  MOVLW  01
60A8:  MOVLB  A
60AA:  MOVWF  xBF
60AC:  MOVLB  0
60AE:  CALL   5198
60B2:  CLRF   19
60B4:  BTFSC  FF2.7
60B6:  BSF    19.7
60B8:  BCF    FF2.7
60BA:  MOVLW  2F
60BC:  MOVLB  B
60BE:  MOVWF  x1A
60C0:  MOVLB  0
60C2:  CALL   05AA
60C6:  BTFSC  19.7
60C8:  BSF    FF2.7
60CA:  MOVFF  FF,ABE
60CE:  MOVLW  01
60D0:  MOVLB  A
60D2:  MOVWF  xBF
60D4:  MOVLB  0
60D6:  CALL   5198
60DA:  CLRF   19
60DC:  BTFSC  FF2.7
60DE:  BSF    19.7
60E0:  BCF    FF2.7
60E2:  MOVLW  20
60E4:  MOVLB  B
60E6:  MOVWF  x1A
60E8:  MOVLB  0
60EA:  CALL   05AA
60EE:  BTFSC  19.7
60F0:  BSF    FF2.7
60F2:  MOVFF  101,ABE
60F6:  MOVLW  01
60F8:  MOVLB  A
60FA:  MOVWF  xBF
60FC:  MOVLB  0
60FE:  CALL   5198
6102:  CLRF   19
6104:  BTFSC  FF2.7
6106:  BSF    19.7
6108:  BCF    FF2.7
610A:  MOVLW  3A
610C:  MOVLB  B
610E:  MOVWF  x1A
6110:  MOVLB  0
6112:  CALL   05AA
6116:  BTFSC  19.7
6118:  BSF    FF2.7
611A:  MOVFF  102,ABE
611E:  MOVLW  01
6120:  MOVLB  A
6122:  MOVWF  xBF
6124:  MOVLB  0
6126:  CALL   5198
612A:  CLRF   19
612C:  BTFSC  FF2.7
612E:  BSF    19.7
6130:  BCF    FF2.7
6132:  MOVLW  3A
6134:  MOVLB  B
6136:  MOVWF  x1A
6138:  MOVLB  0
613A:  CALL   05AA
613E:  BTFSC  19.7
6140:  BSF    FF2.7
6142:  MOVFF  103,ABE
6146:  MOVLW  01
6148:  MOVLB  A
614A:  MOVWF  xBF
614C:  MOVLB  0
614E:  CALL   5198
6152:  CLRF   19
6154:  BTFSC  FF2.7
6156:  BSF    19.7
6158:  BCF    FF2.7
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
615A:  MOVLW  0A
615C:  MOVLB  B
615E:  MOVWF  x1A
6160:  MOVLB  0
6162:  CALL   05AA
6166:  BTFSC  19.7
6168:  BSF    FF2.7
616A:  CLRF   19
616C:  BTFSC  FF2.7
616E:  BSF    19.7
6170:  BCF    FF2.7
6172:  MOVLW  0D
6174:  MOVLB  B
6176:  MOVWF  x1A
6178:  MOVLB  0
617A:  CALL   05AA
617E:  BTFSC  19.7
6180:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
6182:  CLRF   FEA
6184:  MOVLW  41
6186:  MOVWF  FE9
6188:  MOVLW  00
618A:  CALL   01E8
618E:  TBLRD*-
6190:  TBLRD*+
6192:  MOVF   FF5,W
6194:  MOVWF  FEE
6196:  IORLW  00
6198:  BNZ   6190
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
619A:  MOVLW  01
619C:  MOVLB  A
619E:  MOVWF  xBF
61A0:  MOVLW  4B
61A2:  MOVWF  xBE
61A4:  CLRF   xC1
61A6:  MOVLW  41
61A8:  MOVWF  xC0
61AA:  MOVLB  0
61AC:  CALL   5046
61B0:  MOVF   01,F
61B2:  BTFSS  FD8.2
61B4:  BRA    63DE
....................       { 
....................          fprintf(COM2,"Year>"); 
61B6:  MOVLW  F0
61B8:  MOVWF  FF6
61BA:  MOVLW  20
61BC:  MOVWF  FF7
61BE:  CLRF   19
61C0:  BTFSC  FF2.7
61C2:  BSF    19.7
61C4:  BCF    FF2.7
61C6:  CALL   05F0
61CA:  BTFSC  19.7
61CC:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
61CE:  MOVLW  01
61D0:  MOVLB  A
61D2:  MOVWF  xBE
61D4:  MOVLW  03
61D6:  MOVWF  xBF
61D8:  MOVLW  0A
61DA:  MOVWF  xC1
61DC:  MOVLW  8A
61DE:  MOVWF  xC0
61E0:  MOVLB  0
61E2:  CALL   4F0E
....................          year=(unsigned int8)strtoi(temp); 
61E6:  MOVLW  0A
61E8:  MOVLB  A
61EA:  MOVWF  xBF
61EC:  MOVLW  8A
61EE:  MOVWF  xBE
61F0:  MOVLB  0
61F2:  CALL   55E4
61F6:  MOVFF  01,FE
....................          fprintf(COM2,"Month>"); 
61FA:  MOVLW  F6
61FC:  MOVWF  FF6
61FE:  MOVLW  20
6200:  MOVWF  FF7
6202:  CLRF   19
6204:  BTFSC  FF2.7
6206:  BSF    19.7
6208:  BCF    FF2.7
620A:  CALL   05F0
620E:  BTFSC  19.7
6210:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6212:  MOVLW  01
6214:  MOVLB  A
6216:  MOVWF  xBE
6218:  MOVLW  03
621A:  MOVWF  xBF
621C:  MOVLW  0A
621E:  MOVWF  xC1
6220:  MOVLW  8A
6222:  MOVWF  xC0
6224:  MOVLB  0
6226:  CALL   4F0E
....................          mon=(unsigned int8)strtoi(temp); 
622A:  MOVLW  0A
622C:  MOVLB  A
622E:  MOVWF  xBF
6230:  MOVLW  8A
6232:  MOVWF  xBE
6234:  MOVLB  0
6236:  CALL   55E4
623A:  MOVFF  01,FF
....................          fprintf(COM2,"Date>"); 
623E:  MOVLW  FE
6240:  MOVWF  FF6
6242:  MOVLW  20
6244:  MOVWF  FF7
6246:  CLRF   19
6248:  BTFSC  FF2.7
624A:  BSF    19.7
624C:  BCF    FF2.7
624E:  CALL   05F0
6252:  BTFSC  19.7
6254:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6256:  MOVLW  01
6258:  MOVLB  A
625A:  MOVWF  xBE
625C:  MOVLW  03
625E:  MOVWF  xBF
6260:  MOVLW  0A
6262:  MOVWF  xC1
6264:  MOVLW  8A
6266:  MOVWF  xC0
6268:  MOVLB  0
626A:  CALL   4F0E
....................          date = (unsigned int8)strtoi(temp); 
626E:  MOVLW  0A
6270:  MOVLB  A
6272:  MOVWF  xBF
6274:  MOVLW  8A
6276:  MOVWF  xBE
6278:  MOVLB  0
627A:  CALL   55E4
627E:  MOVFF  01,100
....................          fprintf(COM2,"Day>"); 
6282:  MOVLW  04
6284:  MOVWF  FF6
6286:  MOVLW  21
6288:  MOVWF  FF7
628A:  CLRF   19
628C:  BTFSC  FF2.7
628E:  BSF    19.7
6290:  BCF    FF2.7
6292:  CALL   05F0
6296:  BTFSC  19.7
6298:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
629A:  MOVLW  01
629C:  MOVLB  A
629E:  MOVWF  xBE
62A0:  MOVLW  03
62A2:  MOVWF  xBF
62A4:  MOVLW  0A
62A6:  MOVWF  xC1
62A8:  MOVLW  8A
62AA:  MOVWF  xC0
62AC:  MOVLB  0
62AE:  CALL   4F0E
....................          day = (unsigned int8)strtoi(temp); 
62B2:  MOVLW  0A
62B4:  MOVLB  A
62B6:  MOVWF  xBF
62B8:  MOVLW  8A
62BA:  MOVWF  xBE
62BC:  MOVLB  0
62BE:  CALL   55E4
62C2:  MOVFF  01,FD
....................          fprintf(COM2,"Hour>"); 
62C6:  MOVLW  0A
62C8:  MOVWF  FF6
62CA:  MOVLW  21
62CC:  MOVWF  FF7
62CE:  CLRF   19
62D0:  BTFSC  FF2.7
62D2:  BSF    19.7
62D4:  BCF    FF2.7
62D6:  CALL   05F0
62DA:  BTFSC  19.7
62DC:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
62DE:  MOVLW  01
62E0:  MOVLB  A
62E2:  MOVWF  xBE
62E4:  MOVLW  03
62E6:  MOVWF  xBF
62E8:  MOVLW  0A
62EA:  MOVWF  xC1
62EC:  MOVLW  8A
62EE:  MOVWF  xC0
62F0:  MOVLB  0
62F2:  CALL   4F0E
....................          h = (unsigned int8)strtoi(temp); 
62F6:  MOVLW  0A
62F8:  MOVLB  A
62FA:  MOVWF  xBF
62FC:  MOVLW  8A
62FE:  MOVWF  xBE
6300:  MOVLB  0
6302:  CALL   55E4
6306:  MOVFF  01,101
....................          fprintf(COM2,"Minutes>"); 
630A:  MOVLW  10
630C:  MOVWF  FF6
630E:  MOVLW  21
6310:  MOVWF  FF7
6312:  CLRF   19
6314:  BTFSC  FF2.7
6316:  BSF    19.7
6318:  BCF    FF2.7
631A:  CALL   05F0
631E:  BTFSC  19.7
6320:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6322:  MOVLW  01
6324:  MOVLB  A
6326:  MOVWF  xBE
6328:  MOVLW  03
632A:  MOVWF  xBF
632C:  MOVLW  0A
632E:  MOVWF  xC1
6330:  MOVLW  8A
6332:  MOVWF  xC0
6334:  MOVLB  0
6336:  CALL   4F0E
....................          min = (unsigned int8)strtoi(temp);                   
633A:  MOVLW  0A
633C:  MOVLB  A
633E:  MOVWF  xBF
6340:  MOVLW  8A
6342:  MOVWF  xBE
6344:  MOVLB  0
6346:  CALL   55E4
634A:  MOVFF  01,102
....................          fprintf(COM2,"Seconds>"); 
634E:  MOVLW  1A
6350:  MOVWF  FF6
6352:  MOVLW  21
6354:  MOVWF  FF7
6356:  CLRF   19
6358:  BTFSC  FF2.7
635A:  BSF    19.7
635C:  BCF    FF2.7
635E:  CALL   05F0
6362:  BTFSC  19.7
6364:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
6366:  MOVLW  01
6368:  MOVLB  A
636A:  MOVWF  xBE
636C:  MOVLW  03
636E:  MOVWF  xBF
6370:  MOVLW  0A
6372:  MOVWF  xC1
6374:  MOVLW  8A
6376:  MOVWF  xC0
6378:  MOVLB  0
637A:  CALL   4F0E
....................          sec = (unsigned int8)strtoi(temp);                   
637E:  MOVLW  0A
6380:  MOVLB  A
6382:  MOVWF  xBF
6384:  MOVLW  8A
6386:  MOVWF  xBE
6388:  MOVLB  0
638A:  CALL   55E4
638E:  MOVFF  01,103
6392:  CLRF   19
6394:  BTFSC  FF2.7
6396:  BSF    19.7
6398:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
639A:  MOVLW  0A
639C:  MOVLB  B
639E:  MOVWF  x1A
63A0:  MOVLB  0
63A2:  CALL   05AA
63A6:  BTFSC  19.7
63A8:  BSF    FF2.7
63AA:  CLRF   19
63AC:  BTFSC  FF2.7
63AE:  BSF    19.7
63B0:  BCF    FF2.7
63B2:  MOVLW  0D
63B4:  MOVLB  B
63B6:  MOVWF  x1A
63B8:  MOVLB  0
63BA:  CALL   05AA
63BE:  BTFSC  19.7
63C0:  BSF    FF2.7
....................          rtc_set_datetime(date,mon,year,day,h,min); 
63C2:  MOVFF  100,ABE
63C6:  MOVFF  FF,ABF
63CA:  MOVFF  FE,AC0
63CE:  MOVFF  FD,AC1
63D2:  MOVFF  101,AC2
63D6:  MOVFF  102,AC3
63DA:  GOTO   571E
....................       } 
....................       strcpy(buffer2,"MS"); 
63DE:  CLRF   FEA
63E0:  MOVLW  41
63E2:  MOVWF  FE9
63E4:  MOVLW  00
63E6:  CALL   01FC
63EA:  TBLRD*-
63EC:  TBLRD*+
63EE:  MOVF   FF5,W
63F0:  MOVWF  FEE
63F2:  IORLW  00
63F4:  BNZ   63EC
....................       if(!stringcomp(buffer_uart,buffer2)) 
63F6:  MOVLW  01
63F8:  MOVLB  A
63FA:  MOVWF  xBF
63FC:  MOVLW  4B
63FE:  MOVWF  xBE
6400:  CLRF   xC1
6402:  MOVLW  41
6404:  MOVWF  xC0
6406:  MOVLB  0
6408:  CALL   5046
640C:  MOVF   01,F
640E:  BTFSS  FD8.2
6410:  BRA    6520
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
6412:  MOVLW  24
6414:  MOVWF  FF6
6416:  MOVLW  21
6418:  MOVWF  FF7
641A:  CLRF   19
641C:  BTFSC  FF2.7
641E:  BSF    19.7
6420:  BCF    FF2.7
6422:  CALL   05F0
6426:  BTFSC  19.7
6428:  BSF    FF2.7
642A:  CLRF   19
642C:  BTFSC  FF2.7
642E:  BSF    19.7
6430:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6432:  MOVLW  0A
6434:  MOVLB  B
6436:  MOVWF  x1A
6438:  MOVLB  0
643A:  CALL   05AA
643E:  BTFSC  19.7
6440:  BSF    FF2.7
6442:  CLRF   19
6444:  BTFSC  FF2.7
6446:  BSF    19.7
6448:  BCF    FF2.7
644A:  MOVLW  0D
644C:  MOVLB  B
644E:  MOVWF  x1A
6450:  MOVLB  0
6452:  CALL   05AA
6456:  BTFSC  19.7
6458:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
645A:  MOVLW  44
645C:  MOVWF  FF6
645E:  MOVLW  21
6460:  MOVWF  FF7
6462:  CLRF   19
6464:  BTFSC  FF2.7
6466:  BSF    19.7
6468:  BCF    FF2.7
646A:  CALL   05F0
646E:  BTFSC  19.7
6470:  BSF    FF2.7
6472:  CLRF   19
6474:  BTFSC  FF2.7
6476:  BSF    19.7
6478:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
647A:  MOVLW  0A
647C:  MOVLB  B
647E:  MOVWF  x1A
6480:  MOVLB  0
6482:  CALL   05AA
6486:  BTFSC  19.7
6488:  BSF    FF2.7
648A:  CLRF   19
648C:  BTFSC  FF2.7
648E:  BSF    19.7
6490:  BCF    FF2.7
6492:  MOVLW  0D
6494:  MOVLB  B
6496:  MOVWF  x1A
6498:  MOVLB  0
649A:  CALL   05AA
649E:  BTFSC  19.7
64A0:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
64A2:  MOVLW  01
64A4:  MOVLB  A
64A6:  MOVWF  xBE
64A8:  MOVLW  03
64AA:  MOVWF  xBF
64AC:  MOVLW  0A
64AE:  MOVWF  xC1
64B0:  MOVLW  8A
64B2:  MOVWF  xC0
64B4:  MOVLB  0
64B6:  CALL   4F0E
....................           mode_sl = (unsigned int8)strtoi(temp); 
64BA:  MOVLW  0A
64BC:  MOVLB  A
64BE:  MOVWF  xBF
64C0:  MOVLW  8A
64C2:  MOVWF  xBE
64C4:  MOVLB  0
64C6:  CALL   55E4
64CA:  MOVFF  01,9AB
64CE:  CLRF   19
64D0:  BTFSC  FF2.7
64D2:  BSF    19.7
64D4:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
64D6:  MOVLB  B
64D8:  CLRF   x03
64DA:  MOVLW  91
64DC:  MOVWF  x02
64DE:  MOVFF  9AB,B04
64E2:  MOVLB  0
64E4:  CALL   3FE4
64E8:  BTFSC  19.7
64EA:  BSF    FF2.7
....................           set_tris_a(0xff); 
64EC:  MOVLW  FF
64EE:  MOVWF  F92
64F0:  CLRF   19
64F2:  BTFSC  FF2.7
64F4:  BSF    19.7
64F6:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
64F8:  MOVLW  0A
64FA:  MOVLB  B
64FC:  MOVWF  x1A
64FE:  MOVLB  0
6500:  CALL   05AA
6504:  BTFSC  19.7
6506:  BSF    FF2.7
6508:  CLRF   19
650A:  BTFSC  FF2.7
650C:  BSF    19.7
650E:  BCF    FF2.7
6510:  MOVLW  0D
6512:  MOVLB  B
6514:  MOVWF  x1A
6516:  MOVLB  0
6518:  CALL   05AA
651C:  BTFSC  19.7
651E:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"KP"); 
6520:  CLRF   FEA
6522:  MOVLW  41
6524:  MOVWF  FE9
6526:  MOVLW  00
6528:  CALL   0210
652C:  TBLRD*-
652E:  TBLRD*+
6530:  MOVF   FF5,W
6532:  MOVWF  FEE
6534:  IORLW  00
6536:  BNZ   652E
....................       if(!stringcomp(buffer_uart,buffer2)) 
6538:  MOVLW  01
653A:  MOVLB  A
653C:  MOVWF  xBF
653E:  MOVLW  4B
6540:  MOVWF  xBE
6542:  CLRF   xC1
6544:  MOVLW  41
6546:  MOVWF  xC0
6548:  MOVLB  0
654A:  CALL   5046
654E:  MOVF   01,F
6550:  BTFSS  FD8.2
6552:  BRA    665E
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
6554:  MOVLW  64
6556:  MOVWF  FF6
6558:  MOVLW  21
655A:  MOVWF  FF7
655C:  CLRF   19
655E:  BTFSC  FF2.7
6560:  BSF    19.7
6562:  BCF    FF2.7
6564:  CALL   05F0
6568:  BTFSC  19.7
656A:  BSF    FF2.7
656C:  CLRF   19
656E:  BTFSC  FF2.7
6570:  BSF    19.7
6572:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6574:  MOVLW  0A
6576:  MOVLB  B
6578:  MOVWF  x1A
657A:  MOVLB  0
657C:  CALL   05AA
6580:  BTFSC  19.7
6582:  BSF    FF2.7
6584:  CLRF   19
6586:  BTFSC  FF2.7
6588:  BSF    19.7
658A:  BCF    FF2.7
658C:  MOVLW  0D
658E:  MOVLB  B
6590:  MOVWF  x1A
6592:  MOVLB  0
6594:  CALL   05AA
6598:  BTFSC  19.7
659A:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
659C:  MOVLW  82
659E:  MOVWF  FF6
65A0:  MOVLW  21
65A2:  MOVWF  FF7
65A4:  CLRF   19
65A6:  BTFSC  FF2.7
65A8:  BSF    19.7
65AA:  BCF    FF2.7
65AC:  CALL   05F0
65B0:  BTFSC  19.7
65B2:  BSF    FF2.7
65B4:  CLRF   19
65B6:  BTFSC  FF2.7
65B8:  BSF    19.7
65BA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
65BC:  MOVLW  0A
65BE:  MOVLB  B
65C0:  MOVWF  x1A
65C2:  MOVLB  0
65C4:  CALL   05AA
65C8:  BTFSC  19.7
65CA:  BSF    FF2.7
65CC:  CLRF   19
65CE:  BTFSC  FF2.7
65D0:  BSF    19.7
65D2:  BCF    FF2.7
65D4:  MOVLW  0D
65D6:  MOVLB  B
65D8:  MOVWF  x1A
65DA:  MOVLB  0
65DC:  CALL   05AA
65E0:  BTFSC  19.7
65E2:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
65E4:  MOVLW  01
65E6:  MOVLB  A
65E8:  MOVWF  xBE
65EA:  MOVLW  03
65EC:  MOVWF  xBF
65EE:  MOVLW  0A
65F0:  MOVWF  xC1
65F2:  MOVLW  8A
65F4:  MOVWF  xC0
65F6:  MOVLB  0
65F8:  CALL   4F0E
....................           KP_mode = (unsigned int8)strtoi(temp); 
65FC:  MOVLW  0A
65FE:  MOVLB  A
6600:  MOVWF  xBF
6602:  MOVLW  8A
6604:  MOVWF  xBE
6606:  MOVLB  0
6608:  CALL   55E4
660C:  MOVFF  01,10C
6610:  CLRF   19
6612:  BTFSC  FF2.7
6614:  BSF    19.7
6616:  BCF    FF2.7
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
6618:  MOVLB  B
661A:  CLRF   x03
661C:  MOVLW  7F
661E:  MOVWF  x02
6620:  MOVFF  10C,B04
6624:  MOVLB  0
6626:  CALL   3FE4
662A:  BTFSC  19.7
662C:  BSF    FF2.7
662E:  CLRF   19
6630:  BTFSC  FF2.7
6632:  BSF    19.7
6634:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6636:  MOVLW  0A
6638:  MOVLB  B
663A:  MOVWF  x1A
663C:  MOVLB  0
663E:  CALL   05AA
6642:  BTFSC  19.7
6644:  BSF    FF2.7
6646:  CLRF   19
6648:  BTFSC  FF2.7
664A:  BSF    19.7
664C:  BCF    FF2.7
664E:  MOVLW  0D
6650:  MOVLB  B
6652:  MOVWF  x1A
6654:  MOVLB  0
6656:  CALL   05AA
665A:  BTFSC  19.7
665C:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"tran time"); 
665E:  CLRF   FEA
6660:  MOVLW  41
6662:  MOVWF  FE9
6664:  MOVLW  00
6666:  CALL   0224
666A:  TBLRD*-
666C:  TBLRD*+
666E:  MOVF   FF5,W
6670:  MOVWF  FEE
6672:  IORLW  00
6674:  BNZ   666C
....................       if(!stringcomp(buffer_uart,buffer2)) 
6676:  MOVLW  01
6678:  MOVLB  A
667A:  MOVWF  xBF
667C:  MOVLW  4B
667E:  MOVWF  xBE
6680:  CLRF   xC1
6682:  MOVLW  41
6684:  MOVWF  xC0
6686:  MOVLB  0
6688:  CALL   5046
668C:  MOVF   01,F
668E:  BNZ   6752
....................       { 
....................           fprintf(COM2,"Input Number"); 
6690:  MOVLW  A0
6692:  MOVWF  FF6
6694:  MOVLW  21
6696:  MOVWF  FF7
6698:  CLRF   19
669A:  BTFSC  FF2.7
669C:  BSF    19.7
669E:  BCF    FF2.7
66A0:  CALL   05F0
66A4:  BTFSC  19.7
66A6:  BSF    FF2.7
66A8:  CLRF   19
66AA:  BTFSC  FF2.7
66AC:  BSF    19.7
66AE:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
66B0:  MOVLW  0A
66B2:  MOVLB  B
66B4:  MOVWF  x1A
66B6:  MOVLB  0
66B8:  CALL   05AA
66BC:  BTFSC  19.7
66BE:  BSF    FF2.7
66C0:  CLRF   19
66C2:  BTFSC  FF2.7
66C4:  BSF    19.7
66C6:  BCF    FF2.7
66C8:  MOVLW  0D
66CA:  MOVLB  B
66CC:  MOVWF  x1A
66CE:  MOVLB  0
66D0:  CALL   05AA
66D4:  BTFSC  19.7
66D6:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
66D8:  MOVLW  01
66DA:  MOVLB  A
66DC:  MOVWF  xBE
66DE:  MOVLW  03
66E0:  MOVWF  xBF
66E2:  MOVLW  0A
66E4:  MOVWF  xC1
66E6:  MOVLW  8A
66E8:  MOVWF  xC0
66EA:  MOVLB  0
66EC:  CALL   4F0E
....................           delaycharaction = (unsigned int8)strtoi(temp); 
66F0:  MOVLW  0A
66F2:  MOVLB  A
66F4:  MOVWF  xBF
66F6:  MOVLW  8A
66F8:  MOVWF  xBE
66FA:  MOVLB  0
66FC:  CALL   55E4
6700:  MOVFF  01,143
6704:  CLRF   19
6706:  BTFSC  FF2.7
6708:  BSF    19.7
670A:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
670C:  MOVLB  B
670E:  CLRF   x03
6710:  MOVLW  94
6712:  MOVWF  x02
6714:  MOVFF  143,B04
6718:  MOVLB  0
671A:  CALL   3FE4
671E:  BTFSC  19.7
6720:  BSF    FF2.7
6722:  CLRF   19
6724:  BTFSC  FF2.7
6726:  BSF    19.7
6728:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
672A:  MOVLW  0A
672C:  MOVLB  B
672E:  MOVWF  x1A
6730:  MOVLB  0
6732:  CALL   05AA
6736:  BTFSC  19.7
6738:  BSF    FF2.7
673A:  CLRF   19
673C:  BTFSC  FF2.7
673E:  BSF    19.7
6740:  BCF    FF2.7
6742:  MOVLW  0D
6744:  MOVLB  B
6746:  MOVWF  x1A
6748:  MOVLB  0
674A:  CALL   05AA
674E:  BTFSC  19.7
6750:  BSF    FF2.7
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
6752:  CLRF   FEA
6754:  MOVLW  41
6756:  MOVWF  FE9
6758:  MOVLW  00
675A:  CALL   023E
675E:  TBLRD*-
6760:  TBLRD*+
6762:  MOVF   FF5,W
6764:  MOVWF  FEE
6766:  IORLW  00
6768:  BNZ   6760
....................       if(!stringcomp(buffer_uart,buffer2)) 
676A:  MOVLW  01
676C:  MOVLB  A
676E:  MOVWF  xBF
6770:  MOVLW  4B
6772:  MOVWF  xBE
6774:  CLRF   xC1
6776:  MOVLW  41
6778:  MOVWF  xC0
677A:  MOVLB  0
677C:  CALL   5046
6780:  MOVF   01,F
6782:  BTFSS  FD8.2
6784:  BRA    6890
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
6786:  MOVLW  AE
6788:  MOVWF  FF6
678A:  MOVLW  21
678C:  MOVWF  FF7
678E:  CLRF   19
6790:  BTFSC  FF2.7
6792:  BSF    19.7
6794:  BCF    FF2.7
6796:  CALL   05F0
679A:  BTFSC  19.7
679C:  BSF    FF2.7
679E:  CLRF   19
67A0:  BTFSC  FF2.7
67A2:  BSF    19.7
67A4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
67A6:  MOVLW  0A
67A8:  MOVLB  B
67AA:  MOVWF  x1A
67AC:  MOVLB  0
67AE:  CALL   05AA
67B2:  BTFSC  19.7
67B4:  BSF    FF2.7
67B6:  CLRF   19
67B8:  BTFSC  FF2.7
67BA:  BSF    19.7
67BC:  BCF    FF2.7
67BE:  MOVLW  0D
67C0:  MOVLB  B
67C2:  MOVWF  x1A
67C4:  MOVLB  0
67C6:  CALL   05AA
67CA:  BTFSC  19.7
67CC:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
67CE:  MOVLW  D4
67D0:  MOVWF  FF6
67D2:  MOVLW  21
67D4:  MOVWF  FF7
67D6:  CLRF   19
67D8:  BTFSC  FF2.7
67DA:  BSF    19.7
67DC:  BCF    FF2.7
67DE:  CALL   05F0
67E2:  BTFSC  19.7
67E4:  BSF    FF2.7
67E6:  CLRF   19
67E8:  BTFSC  FF2.7
67EA:  BSF    19.7
67EC:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
67EE:  MOVLW  0A
67F0:  MOVLB  B
67F2:  MOVWF  x1A
67F4:  MOVLB  0
67F6:  CALL   05AA
67FA:  BTFSC  19.7
67FC:  BSF    FF2.7
67FE:  CLRF   19
6800:  BTFSC  FF2.7
6802:  BSF    19.7
6804:  BCF    FF2.7
6806:  MOVLW  0D
6808:  MOVLB  B
680A:  MOVWF  x1A
680C:  MOVLB  0
680E:  CALL   05AA
6812:  BTFSC  19.7
6814:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6816:  MOVLW  01
6818:  MOVLB  A
681A:  MOVWF  xBE
681C:  MOVLW  03
681E:  MOVWF  xBF
6820:  MOVLW  0A
6822:  MOVWF  xC1
6824:  MOVLW  8A
6826:  MOVWF  xC0
6828:  MOVLB  0
682A:  CALL   4F0E
....................           type_KB=(unsigned int8)strtoi(temp); 
682E:  MOVLW  0A
6830:  MOVLB  A
6832:  MOVWF  xBF
6834:  MOVLW  8A
6836:  MOVWF  xBE
6838:  MOVLB  0
683A:  CALL   55E4
683E:  MOVFF  01,110
6842:  CLRF   19
6844:  BTFSC  FF2.7
6846:  BSF    19.7
6848:  BCF    FF2.7
....................           write_ext_eeprom(kindofKB,type_KB); 
684A:  MOVLB  B
684C:  CLRF   x03
684E:  MOVLW  7E
6850:  MOVWF  x02
6852:  MOVFF  110,B04
6856:  MOVLB  0
6858:  CALL   3FE4
685C:  BTFSC  19.7
685E:  BSF    FF2.7
6860:  CLRF   19
6862:  BTFSC  FF2.7
6864:  BSF    19.7
6866:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
6868:  MOVLW  0A
686A:  MOVLB  B
686C:  MOVWF  x1A
686E:  MOVLB  0
6870:  CALL   05AA
6874:  BTFSC  19.7
6876:  BSF    FF2.7
6878:  CLRF   19
687A:  BTFSC  FF2.7
687C:  BSF    19.7
687E:  BCF    FF2.7
6880:  MOVLW  0D
6882:  MOVLB  B
6884:  MOVWF  x1A
6886:  MOVLB  0
6888:  CALL   05AA
688C:  BTFSC  19.7
688E:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
6890:  CLRF   FEA
6892:  MOVLW  41
6894:  MOVWF  FE9
6896:  MOVLW  00
6898:  CALL   0254
689C:  TBLRD*-
689E:  TBLRD*+
68A0:  MOVF   FF5,W
68A2:  MOVWF  FEE
68A4:  IORLW  00
68A6:  BNZ   689E
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
68A8:  MOVLW  01
68AA:  MOVLB  A
68AC:  MOVWF  xBF
68AE:  MOVLW  4B
68B0:  MOVWF  xBE
68B2:  CLRF   xC1
68B4:  MOVLW  41
68B6:  MOVWF  xC0
68B8:  MOVLB  0
68BA:  CALL   5046
68BE:  MOVF   01,F
68C0:  BTFSS  FD8.2
68C2:  BRA    6AA2
....................       { 
....................          printf("h-> Help\n\r"); 
68C4:  MOVLW  FA
68C6:  MOVWF  FF6
68C8:  MOVLW  21
68CA:  MOVWF  FF7
68CC:  CLRF   19
68CE:  BTFSC  FF2.7
68D0:  BSF    19.7
68D2:  BCF    FF2.7
68D4:  CALL   05F0
68D8:  BTFSC  19.7
68DA:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
68DC:  MOVLW  06
68DE:  MOVWF  FF6
68E0:  MOVLW  22
68E2:  MOVWF  FF7
68E4:  CLRF   19
68E6:  BTFSC  FF2.7
68E8:  BSF    19.7
68EA:  BCF    FF2.7
68EC:  CALL   05F0
68F0:  BTFSC  19.7
68F2:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
68F4:  MOVLW  18
68F6:  MOVWF  FF6
68F8:  MOVLW  22
68FA:  MOVWF  FF7
68FC:  CLRF   19
68FE:  BTFSC  FF2.7
6900:  BSF    19.7
6902:  BCF    FF2.7
6904:  CALL   05F0
6908:  BTFSC  19.7
690A:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
690C:  MOVLW  2A
690E:  MOVWF  FF6
6910:  MOVLW  22
6912:  MOVWF  FF7
6914:  CLRF   19
6916:  BTFSC  FF2.7
6918:  BSF    19.7
691A:  BCF    FF2.7
691C:  CALL   05F0
6920:  BTFSC  19.7
6922:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
6924:  MOVLW  4A
6926:  MOVWF  FF6
6928:  MOVLW  22
692A:  MOVWF  FF7
692C:  CLRF   19
692E:  BTFSC  FF2.7
6930:  BSF    19.7
6932:  BCF    FF2.7
6934:  CALL   05F0
6938:  BTFSC  19.7
693A:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
693C:  MOVLW  66
693E:  MOVWF  FF6
6940:  MOVLW  22
6942:  MOVWF  FF7
6944:  CLRF   19
6946:  BTFSC  FF2.7
6948:  BSF    19.7
694A:  BCF    FF2.7
694C:  CALL   05F0
6950:  BTFSC  19.7
6952:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
6954:  MOVLW  74
6956:  MOVWF  FF6
6958:  MOVLW  22
695A:  MOVWF  FF7
695C:  CLRF   19
695E:  BTFSC  FF2.7
6960:  BSF    19.7
6962:  BCF    FF2.7
6964:  CALL   05F0
6968:  BTFSC  19.7
696A:  BSF    FF2.7
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
696C:  MOVLW  80
696E:  MOVWF  FF6
6970:  MOVLW  22
6972:  MOVWF  FF7
6974:  CLRF   19
6976:  BTFSC  FF2.7
6978:  BSF    19.7
697A:  BCF    FF2.7
697C:  CALL   05F0
6980:  BTFSC  19.7
6982:  BSF    FF2.7
6984:  CLRF   19
6986:  BTFSC  FF2.7
6988:  BSF    19.7
698A:  BCF    FF2.7
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
698C:  MOVLB  A
698E:  CLRF   xEF
6990:  MOVLW  7F
6992:  MOVWF  xEE
6994:  MOVLB  0
6996:  CALL   3A84
699A:  BTFSC  19.7
699C:  BSF    FF2.7
699E:  MOVFF  01,10C
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
69A2:  MOVLB  1
69A4:  MOVF   x0C,F
69A6:  BZ    69C6
69A8:  MOVLW  AC
69AA:  MOVWF  FF6
69AC:  MOVLW  22
69AE:  MOVWF  FF7
69B0:  CLRF   19
69B2:  BTFSC  FF2.7
69B4:  BSF    19.7
69B6:  BCF    FF2.7
69B8:  MOVLB  0
69BA:  CALL   05F0
69BE:  BTFSC  19.7
69C0:  BSF    FF2.7
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
69C2:  BRA    69E0
69C4:  MOVLB  1
69C6:  MOVLW  CE
69C8:  MOVWF  FF6
69CA:  MOVLW  22
69CC:  MOVWF  FF7
69CE:  CLRF   19
69D0:  BTFSC  FF2.7
69D2:  BSF    19.7
69D4:  BCF    FF2.7
69D6:  MOVLB  0
69D8:  CALL   05F0
69DC:  BTFSC  19.7
69DE:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
69E0:  MOVLW  F2
69E2:  MOVWF  FF6
69E4:  MOVLW  22
69E6:  MOVWF  FF7
69E8:  CLRF   19
69EA:  BTFSC  FF2.7
69EC:  BSF    19.7
69EE:  BCF    FF2.7
69F0:  CALL   05F0
69F4:  BTFSC  19.7
69F6:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
69F8:  MOVLW  1A
69FA:  MOVWF  FF6
69FC:  MOVLW  23
69FE:  MOVWF  FF7
6A00:  CLRF   19
6A02:  BTFSC  FF2.7
6A04:  BSF    19.7
6A06:  BCF    FF2.7
6A08:  CALL   05F0
6A0C:  BTFSC  19.7
6A0E:  BSF    FF2.7
6A10:  CLRF   19
6A12:  BTFSC  FF2.7
6A14:  BSF    19.7
6A16:  BCF    FF2.7
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
6A18:  MOVLB  A
6A1A:  CLRF   xEF
6A1C:  MOVLW  7E
6A1E:  MOVWF  xEE
6A20:  MOVLB  0
6A22:  CALL   3A84
6A26:  BTFSC  19.7
6A28:  BSF    FF2.7
6A2A:  MOVFF  01,ABE
6A2E:  MOVLW  36
6A30:  MOVWF  FF6
6A32:  MOVLW  23
6A34:  MOVWF  FF7
6A36:  CLRF   19
6A38:  BTFSC  FF2.7
6A3A:  BSF    19.7
6A3C:  BCF    FF2.7
6A3E:  MOVLW  06
6A40:  MOVLB  B
6A42:  MOVWF  x0E
6A44:  MOVLB  0
6A46:  CALL   19C8
6A4A:  BTFSC  19.7
6A4C:  BSF    FF2.7
6A4E:  CLRF   19
6A50:  BTFSC  FF2.7
6A52:  BSF    19.7
6A54:  BCF    FF2.7
6A56:  MOVFF  ABE,AEE
6A5A:  MOVLW  18
6A5C:  MOVLB  A
6A5E:  MOVWF  xEF
6A60:  MOVLB  0
6A62:  CALL   1ADC
6A66:  BTFSC  19.7
6A68:  BSF    FF2.7
6A6A:  MOVLW  3E
6A6C:  MOVWF  FF6
6A6E:  MOVLW  23
6A70:  MOVWF  FF7
6A72:  CLRF   19
6A74:  BTFSC  FF2.7
6A76:  BSF    19.7
6A78:  BCF    FF2.7
6A7A:  MOVLW  1D
6A7C:  MOVLB  B
6A7E:  MOVWF  x0E
6A80:  MOVLB  0
6A82:  CALL   19C8
6A86:  BTFSC  19.7
6A88:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");      
6A8A:  MOVLW  5C
6A8C:  MOVWF  FF6
6A8E:  MOVLW  23
6A90:  MOVWF  FF7
6A92:  CLRF   19
6A94:  BTFSC  FF2.7
6A96:  BSF    19.7
6A98:  BCF    FF2.7
6A9A:  CALL   05F0
6A9E:  BTFSC  19.7
6AA0:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
6AA2:  CLRF   FEA
6AA4:  MOVLW  41
6AA6:  MOVWF  FE9
6AA8:  MOVLW  00
6AAA:  CALL   0266
6AAE:  TBLRD*-
6AB0:  TBLRD*+
6AB2:  MOVF   FF5,W
6AB4:  MOVWF  FEE
6AB6:  IORLW  00
6AB8:  BNZ   6AB0
....................       if(!stringcomp(buffer_uart,buffer2))  
6ABA:  MOVLW  01
6ABC:  MOVLB  A
6ABE:  MOVWF  xBF
6AC0:  MOVLW  4B
6AC2:  MOVWF  xBE
6AC4:  CLRF   xC1
6AC6:  MOVLW  41
6AC8:  MOVWF  xC0
6ACA:  MOVLB  0
6ACC:  CALL   5046
6AD0:  MOVF   01,F
6AD2:  BTFSS  FD8.2
6AD4:  BRA    6C04
....................       { 
....................          fprintf(COM2,"old password:"); 
6AD6:  MOVLW  76
6AD8:  MOVWF  FF6
6ADA:  MOVLW  23
6ADC:  MOVWF  FF7
6ADE:  CLRF   19
6AE0:  BTFSC  FF2.7
6AE2:  BSF    19.7
6AE4:  BCF    FF2.7
6AE6:  CALL   05F0
6AEA:  BTFSC  19.7
6AEC:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
6AEE:  MOVLB  A
6AF0:  CLRF   xBE
6AF2:  MOVLW  14
6AF4:  MOVWF  xBF
6AF6:  CLRF   xC1
6AF8:  MOVLW  55
6AFA:  MOVWF  xC0
6AFC:  MOVLB  0
6AFE:  CALL   4B50
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
6B02:  MOVLW  02
6B04:  MOVLB  A
6B06:  MOVWF  xBE
6B08:  MOVLW  14
6B0A:  MOVWF  xBF
6B0C:  CLRF   xC1
6B0E:  MOVLW  69
6B10:  MOVWF  xC0
6B12:  MOVLB  0
6B14:  CALL   4F0E
....................          if(!stringcomp(entpassword,password)) 
6B18:  MOVLB  A
6B1A:  CLRF   xBF
6B1C:  MOVLW  69
6B1E:  MOVWF  xBE
6B20:  CLRF   xC1
6B22:  MOVLW  55
6B24:  MOVWF  xC0
6B26:  MOVLB  0
6B28:  CALL   5046
6B2C:  MOVF   01,F
6B2E:  BNZ   6BEC
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
6B30:  MOVLW  84
6B32:  MOVWF  FF6
6B34:  MOVLW  23
6B36:  MOVWF  FF7
6B38:  CLRF   19
6B3A:  BTFSC  FF2.7
6B3C:  BSF    19.7
6B3E:  BCF    FF2.7
6B40:  CALL   05F0
6B44:  BTFSC  19.7
6B46:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
6B48:  MOVLW  02
6B4A:  MOVLB  A
6B4C:  MOVWF  xBE
6B4E:  MOVLW  14
6B50:  MOVWF  xBF
6B52:  CLRF   xC1
6B54:  MOVLW  69
6B56:  MOVWF  xC0
6B58:  MOVLB  0
6B5A:  CALL   4F0E
....................             fprintf(COM2,"\n\ragain:"); 
6B5E:  MOVLW  8C
6B60:  MOVWF  FF6
6B62:  MOVLW  23
6B64:  MOVWF  FF7
6B66:  CLRF   19
6B68:  BTFSC  FF2.7
6B6A:  BSF    19.7
6B6C:  BCF    FF2.7
6B6E:  CALL   05F0
6B72:  BTFSC  19.7
6B74:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
6B76:  MOVLW  02
6B78:  MOVLB  A
6B7A:  MOVWF  xBE
6B7C:  MOVLW  14
6B7E:  MOVWF  xBF
6B80:  CLRF   xC1
6B82:  MOVLW  55
6B84:  MOVWF  xC0
6B86:  MOVLB  0
6B88:  CALL   4F0E
....................             if(!stringcomp(entpassword,password)) 
6B8C:  MOVLB  A
6B8E:  CLRF   xBF
6B90:  MOVLW  69
6B92:  MOVWF  xBE
6B94:  CLRF   xC1
6B96:  MOVLW  55
6B98:  MOVWF  xC0
6B9A:  MOVLB  0
6B9C:  CALL   5046
6BA0:  MOVF   01,F
6BA2:  BNZ   6BD2
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
6BA4:  MOVLB  A
6BA6:  CLRF   xD3
6BA8:  MOVLW  14
6BAA:  MOVWF  xD4
6BAC:  CLRF   xD6
6BAE:  MOVLW  55
6BB0:  MOVWF  xD5
6BB2:  MOVLB  0
6BB4:  CALL   4BAA
....................                fprintf(COM2,"\n\rOK\n\r");    
6BB8:  MOVLW  96
6BBA:  MOVWF  FF6
6BBC:  MOVLW  23
6BBE:  MOVWF  FF7
6BC0:  CLRF   19
6BC2:  BTFSC  FF2.7
6BC4:  BSF    19.7
6BC6:  BCF    FF2.7
6BC8:  CALL   05F0
6BCC:  BTFSC  19.7
6BCE:  BSF    FF2.7
....................             } 
....................                else 
6BD0:  BRA    6BEA
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
6BD2:  MOVLW  9E
6BD4:  MOVWF  FF6
6BD6:  MOVLW  23
6BD8:  MOVWF  FF7
6BDA:  CLRF   19
6BDC:  BTFSC  FF2.7
6BDE:  BSF    19.7
6BE0:  BCF    FF2.7
6BE2:  CALL   05F0
6BE6:  BTFSC  19.7
6BE8:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
6BEA:  BRA    6C04
....................             { 
....................                fprintf(COM2," X\n\r"); 
6BEC:  MOVLW  A6
6BEE:  MOVWF  FF6
6BF0:  MOVLW  23
6BF2:  MOVWF  FF7
6BF4:  CLRF   19
6BF6:  BTFSC  FF2.7
6BF8:  BSF    19.7
6BFA:  BCF    FF2.7
6BFC:  CALL   05F0
6C00:  BTFSC  19.7
6C02:  BSF    FF2.7
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
6C04:  CLRF   FEA
6C06:  MOVLW  41
6C08:  MOVWF  FE9
6C0A:  MOVLW  00
6C0C:  CALL   0280
6C10:  TBLRD*-
6C12:  TBLRD*+
6C14:  MOVF   FF5,W
6C16:  MOVWF  FEE
6C18:  IORLW  00
6C1A:  BNZ   6C12
....................       if(!stringcomp(buffer_uart,buffer2)) 
6C1C:  MOVLW  01
6C1E:  MOVLB  A
6C20:  MOVWF  xBF
6C22:  MOVLW  4B
6C24:  MOVWF  xBE
6C26:  CLRF   xC1
6C28:  MOVLW  41
6C2A:  MOVWF  xC0
6C2C:  MOVLB  0
6C2E:  CALL   5046
6C32:  MOVF   01,F
6C34:  BTFSS  FD8.2
6C36:  BRA    6D42
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
6C38:  MOVLW  AC
6C3A:  MOVWF  FF6
6C3C:  MOVLW  23
6C3E:  MOVWF  FF7
6C40:  CLRF   19
6C42:  BTFSC  FF2.7
6C44:  BSF    19.7
6C46:  BCF    FF2.7
6C48:  CALL   05F0
6C4C:  BTFSC  19.7
6C4E:  BSF    FF2.7
6C50:  CLRF   19
6C52:  BTFSC  FF2.7
6C54:  BSF    19.7
6C56:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6C58:  MOVLW  0A
6C5A:  MOVLB  B
6C5C:  MOVWF  x1A
6C5E:  MOVLB  0
6C60:  CALL   05AA
6C64:  BTFSC  19.7
6C66:  BSF    FF2.7
6C68:  CLRF   19
6C6A:  BTFSC  FF2.7
6C6C:  BSF    19.7
6C6E:  BCF    FF2.7
6C70:  MOVLW  0D
6C72:  MOVLB  B
6C74:  MOVWF  x1A
6C76:  MOVLB  0
6C78:  CALL   05AA
6C7C:  BTFSC  19.7
6C7E:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
6C80:  MOVLW  CC
6C82:  MOVWF  FF6
6C84:  MOVLW  23
6C86:  MOVWF  FF7
6C88:  CLRF   19
6C8A:  BTFSC  FF2.7
6C8C:  BSF    19.7
6C8E:  BCF    FF2.7
6C90:  CALL   05F0
6C94:  BTFSC  19.7
6C96:  BSF    FF2.7
6C98:  CLRF   19
6C9A:  BTFSC  FF2.7
6C9C:  BSF    19.7
6C9E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6CA0:  MOVLW  0A
6CA2:  MOVLB  B
6CA4:  MOVWF  x1A
6CA6:  MOVLB  0
6CA8:  CALL   05AA
6CAC:  BTFSC  19.7
6CAE:  BSF    FF2.7
6CB0:  CLRF   19
6CB2:  BTFSC  FF2.7
6CB4:  BSF    19.7
6CB6:  BCF    FF2.7
6CB8:  MOVLW  0D
6CBA:  MOVLB  B
6CBC:  MOVWF  x1A
6CBE:  MOVLB  0
6CC0:  CALL   05AA
6CC4:  BTFSC  19.7
6CC6:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6CC8:  MOVLW  01
6CCA:  MOVLB  A
6CCC:  MOVWF  xBE
6CCE:  MOVLW  03
6CD0:  MOVWF  xBF
6CD2:  MOVLW  0A
6CD4:  MOVWF  xC1
6CD6:  MOVLW  8A
6CD8:  MOVWF  xC0
6CDA:  MOVLB  0
6CDC:  CALL   4F0E
....................           debugmode = (unsigned int8)strtoi(temp); 
6CE0:  MOVLW  0A
6CE2:  MOVLB  A
6CE4:  MOVWF  xBF
6CE6:  MOVLW  8A
6CE8:  MOVWF  xBE
6CEA:  MOVLB  0
6CEC:  CALL   55E4
6CF0:  MOVFF  01,99F
6CF4:  CLRF   19
6CF6:  BTFSC  FF2.7
6CF8:  BSF    19.7
6CFA:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
6CFC:  MOVLB  B
6CFE:  CLRF   x03
6D00:  MOVLW  92
6D02:  MOVWF  x02
6D04:  MOVFF  99F,B04
6D08:  MOVLB  0
6D0A:  CALL   3FE4
6D0E:  BTFSC  19.7
6D10:  BSF    FF2.7
6D12:  CLRF   19
6D14:  BTFSC  FF2.7
6D16:  BSF    19.7
6D18:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6D1A:  MOVLW  0A
6D1C:  MOVLB  B
6D1E:  MOVWF  x1A
6D20:  MOVLB  0
6D22:  CALL   05AA
6D26:  BTFSC  19.7
6D28:  BSF    FF2.7
6D2A:  CLRF   19
6D2C:  BTFSC  FF2.7
6D2E:  BSF    19.7
6D30:  BCF    FF2.7
6D32:  MOVLW  0D
6D34:  MOVLB  B
6D36:  MOVWF  x1A
6D38:  MOVLB  0
6D3A:  CALL   05AA
6D3E:  BTFSC  19.7
6D40:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
6D42:  GOTO   7204 (RETURN)
.................... //=============================================== 
....................  
....................  
.................... //========================= 
.................... int8 receiver_state=0,booting_done=0; 
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... {   
....................    char c; 
....................    //restart_wdt(); 
....................    //disable_interrupts(INT_TIMER0); 
....................    //set_timer0(0);   
....................    //disable_interrupts(INT_RDA);   
....................    c=fgetc(COM1); 
*
23EC:  BTFSS  F9E.5
23EE:  BRA    23EC
23F0:  MOVFF  FAF,AE2
23F4:  MOVLB  A
....................    //if((c>127)||(c<30)) return; 
....................    //fprintf(COM2,"%c ",c);   
....................    #if defined(SIM900) 
....................    count_checking=0; 
....................    if(checking_sim==1) 
....................    { 
....................       restart_wdt(); 
....................       setup_wdt(WDT_OFF); 
....................       checking_sim=0; 
....................       fprintf(COM2,"OK\n\r"); 
....................    } 
....................    #endif 
....................    output_toggle(LED); 
23F6:  BCF    F92.6
23F8:  BTG    F89.6
....................    if(booting_done) 
23FA:  MOVLB  9
23FC:  MOVF   xC1,F
23FE:  BZ    2438
....................    { 
....................       buffer_uart[UART_index++]=c; 
2400:  MOVLB  1
2402:  MOVF   xAF,W
2404:  INCF   xAF,F
2406:  CLRF   03
2408:  ADDLW  4B
240A:  MOVWF  FE9
240C:  MOVLW  01
240E:  ADDWFC 03,W
2410:  MOVWF  FEA
2412:  MOVFF  AE2,FEF
....................       if(UART_index>=99) UART_index=0; 
2416:  MOVF   xAF,W
2418:  SUBLW  62
241A:  BTFSS  FD8.0
241C:  CLRF   xAF
....................       //============================= 
....................       //output_toggle(PIN_C2); 
....................       if(receiver_state==0) 
241E:  MOVLB  9
2420:  MOVF   xC0,F
2422:  BNZ   2438
....................       { 
....................          timing_wait=3000; 
2424:  MOVLW  0B
2426:  MOVLB  4
2428:  MOVWF  x91
242A:  MOVLW  B8
242C:  MOVWF  x90
....................          SIM_state=data_analyze; 
242E:  MOVLW  0D
2430:  MOVWF  x8E
....................          count_polling=0; 
2432:  CLRF   x8D
2434:  CLRF   x8C
2436:  MOVLB  9
....................       } 
....................       //============================= 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................    } 
....................    return; 
....................    //enable_interrupts(INT_TIMER0); 
.................... } 
.................... //========================= 
2438:  BCF    F9E.5
243A:  MOVLB  0
243C:  GOTO   0084
.................... #INT_TIMER1 
.................... void timer1() 
.................... { 
....................    output_toggle(LED); 
2440:  BCF    F92.6
2442:  BTG    F89.6
....................    set_timer1(0xffff-50); 
2444:  SETF   FCF
2446:  MOVLW  CD
2448:  MOVWF  FCE
.................... } 
.................... //========================== 
244A:  BCF    F9E.0
244C:  GOTO   0084
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
4886:  MOVLB  1
4888:  MOVF   x0C,F
488A:  BZ    48C6
....................    { 
....................       if(count_kp<500)count_kp++; 
488C:  MOVF   x0F,W
488E:  SUBLW  01
4890:  BNC   48A0
4892:  BNZ   489A
4894:  MOVF   x0E,W
4896:  SUBLW  F3
4898:  BNC   48A0
489A:  INCF   x0E,F
489C:  BTFSC  FD8.2
489E:  INCF   x0F,F
....................       if(count_kp==500) 
48A0:  MOVF   x0E,W
48A2:  SUBLW  F4
48A4:  BNZ   48C6
48A6:  DECFSZ x0F,W
48A8:  BRA    48C6
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
48AA:  MOVLW  8A
48AC:  MOVWF  FF6
48AE:  MOVLW  4A
48B0:  MOVWF  FF7
48B2:  MOVLB  0
48B4:  CALL   05F0
....................             keyprss_off; 
48B8:  BCF    F92.7
48BA:  BCF    F89.7
....................             kp_st=0;     
48BC:  MOVLB  1
48BE:  CLRF   x0D
....................             count_kp++; 
48C0:  INCF   x0E,F
48C2:  BTFSC  FD8.2
48C4:  INCF   x0F,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
48C6:  DECFSZ x08,W
48C8:  BRA    48E4
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
48CA:  MOVLB  9
48CC:  MOVF   xAB,F
48CE:  BNZ   48D8
48D0:  MOVLB  0
48D2:  CALL   2450
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
48D6:  BRA    48E2
48D8:  MOVLB  0
48DA:  CALL   3742
48DE:  MOVFF  01,AE4
48E2:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
48E4:  DECFSZ x09,W
48E6:  BRA    4900
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
48E8:  MOVLB  9
48EA:  MOVF   xAB,F
48EC:  BNZ   48F6
48EE:  MOVLB  0
48F0:  CALL   2450
....................          else temp=kbd_getc_slv(); 
48F4:  BRA    4900
48F6:  MOVLB  0
48F8:  CALL   3742
48FC:  MOVFF  01,AE4
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
4900:  MOVLB  9
4902:  MOVF   x90,F
4904:  BNZ   4924
4906:  MOVF   x8F,F
4908:  BNZ   4924
490A:  MOVF   x8E,F
490C:  BNZ   4924
490E:  MOVF   x8D,W
4910:  SUBLW  04
4912:  BNC   4924
4914:  MOVLW  01
4916:  ADDWF  x8D,F
4918:  BTFSC  FD8.0
491A:  INCF   x8E,F
491C:  BTFSC  FD8.2
491E:  INCF   x8F,F
4920:  BTFSC  FD8.2
4922:  INCF   x90,F
....................   if(mcr_timeout==5) 
4924:  MOVF   x8D,W
4926:  SUBLW  05
4928:  BNZ   497E
492A:  MOVF   x8E,F
492C:  BNZ   497E
492E:  MOVF   x8F,F
4930:  BNZ   497E
4932:  MOVF   x90,F
4934:  BNZ   497E
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
4936:  DECFSZ xA3,W
4938:  BRA    4940
493A:  MOVLB  0
493C:  BRA    4170
493E:  MOVLB  9
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
4940:  MOVLW  05
4942:  MOVWF  FEA
4944:  MOVLW  0F
4946:  MOVWF  FE9
4948:  CLRF   00
494A:  MOVLW  03
494C:  MOVWF  02
494E:  MOVLW  52
4950:  MOVWF  01
4952:  MOVLB  0
4954:  RCALL  45F2
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
4956:  MOVLW  08
4958:  MOVWF  FEA
495A:  MOVLW  61
495C:  MOVWF  FE9
495E:  CLRF   00
4960:  MOVLW  01
4962:  MOVWF  02
4964:  MOVLW  2C
4966:  MOVWF  01
4968:  RCALL  45F2
....................       //debug_card(); 
....................       count_reading_error=0; 
496A:  MOVLB  9
496C:  CLRF   xA4
....................       mcr_timeout++;   
496E:  MOVLW  01
4970:  ADDWF  x8D,F
4972:  BTFSC  FD8.0
4974:  INCF   x8E,F
4976:  BTFSC  FD8.2
4978:  INCF   x8F,F
497A:  BTFSC  FD8.2
497C:  INCF   x90,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
497E:  MOVLB  A
4980:  CLRF   xEF
4982:  MOVLW  94
4984:  MOVWF  xEE
4986:  MOVLB  0
4988:  CALL   3A84
498C:  MOVFF  01,143
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
4990:  MOVLW  02
4992:  MOVLB  A
4994:  MOVWF  xEB
4996:  MOVLW  BC
4998:  MOVWF  xEA
499A:  CLRF   xED
499C:  MOVFF  143,AEC
49A0:  MOVLB  0
49A2:  CALL   3B7C
49A6:  MOVFF  02,03
49AA:  MOVF   xFC,W
49AC:  SUBWF  02,W
49AE:  BNC   49BE
49B0:  BNZ   49B8
49B2:  MOVF   01,W
49B4:  SUBWF  xFB,W
49B6:  BC    49BE
49B8:  INCF   xFB,F
49BA:  BTFSC  FD8.2
49BC:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
49BE:  MOVLW  02
49C0:  MOVLB  A
49C2:  MOVWF  xEB
49C4:  MOVLW  BC
49C6:  MOVWF  xEA
49C8:  CLRF   xED
49CA:  MOVFF  143,AEC
49CE:  MOVLB  0
49D0:  CALL   3B7C
49D4:  MOVFF  02,03
49D8:  MOVF   01,W
49DA:  SUBWF  xFB,W
49DC:  BNZ   4A84
49DE:  MOVF   03,W
49E0:  SUBWF  xFC,W
49E2:  BNZ   4A84
....................   { 
....................       charac_timeout++; 
49E4:  INCF   xFB,F
49E6:  BTFSC  FD8.2
49E8:  INCF   xFC,F
....................       buf=get_countcard(); 
49EA:  CALL   3B2C
49EE:  MOVFF  02,AE3
49F2:  MOVFF  01,AE2
....................       if(buf<countcards) 
49F6:  MOVLB  A
49F8:  MOVF   xE3,W
49FA:  SUBLW  01
49FC:  BNC   4A24
49FE:  BNZ   4A06
4A00:  MOVF   xE2,W
4A02:  SUBLW  5D
4A04:  BNC   4A24
....................       { 
....................          save_key_new(); 
4A06:  MOVLB  0
4A08:  BRA    460C
....................          buf=buf+1; 
4A0A:  MOVLW  01
4A0C:  MOVLB  A
4A0E:  ADDWF  xE2,F
4A10:  MOVLW  00
4A12:  ADDWFC xE3,F
....................          save_coutcard(buf); 
4A14:  MOVFF  AE3,AE6
4A18:  MOVFF  AE2,AE5
4A1C:  MOVLB  0
4A1E:  RCALL  4754
....................       } 
....................          else 
4A20:  BRA    4A34
4A22:  MOVLB  A
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
4A24:  MOVLW  9A
4A26:  MOVWF  FF6
4A28:  MOVLW  4A
4A2A:  MOVWF  FF7
4A2C:  MOVLB  0
4A2E:  CALL   05F0
....................             #if defined(SIM900) 
....................                //SIM_state=autosending; 
....................                SIM_state=SIM_reply;   
....................                strcpy(reply_buffer,"Full memory, please format memory"); 
....................             #endif 
....................             return; 
4A32:  BRA    4A84
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
4A34:  MOVLW  AA
4A36:  MOVWF  FF6
4A38:  MOVLW  4A
4A3A:  MOVWF  FF7
4A3C:  CALL   05F0
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
4A40:  MOVLW  BA
4A42:  MOVWF  FF6
4A44:  MOVLW  4A
4A46:  MOVWF  FF7
4A48:  MOVLW  14
4A4A:  MOVLB  B
4A4C:  MOVWF  x0E
4A4E:  MOVLB  0
4A50:  CALL   19C8
4A54:  MOVLW  10
4A56:  MOVWF  FE9
4A58:  MOVFF  AE3,AE6
4A5C:  MOVFF  AE2,AE5
4A60:  RCALL  4790
4A62:  MOVLW  D1
4A64:  MOVWF  FF6
4A66:  MOVLW  4A
4A68:  MOVWF  FF7
4A6A:  MOVLW  03
4A6C:  MOVLB  B
4A6E:  MOVWF  x0E
4A70:  MOVLB  0
4A72:  CALL   19C8
....................       data_avai=0; 
4A76:  MOVLB  9
4A78:  CLRF   xA2
....................       enable_getpin=0; 
4A7A:  MOVLB  1
4A7C:  CLRF   x09
....................       //dis_getpin; 
....................       output_low(LED); 
4A7E:  BCF    F92.6
4A80:  BCF    F89.6
4A82:  MOVLB  0
....................       #if defined(SIM900) 
....................        if(auto_sending==1)SIM_state=autosending; 
....................        #if defined(twonumber) 
....................             two_number_sending=1; 
....................        #endif 
....................       #endif 
....................   } 
....................   //================================= 
....................   //================================= 
.................... } 
.................... //========================= 
4A84:  BCF    FF2.2
4A86:  GOTO   0084
.................... void main() 
.................... {  
*
6D46:  CLRF   FF8
6D48:  BCF    FD0.7
6D4A:  BSF    07.7
6D4C:  CLRF   FEA
6D4E:  CLRF   FE9
6D50:  BSF    F7E.3
6D52:  MOVLW  40
6D54:  MOVWF  FB0
6D56:  MOVLW  03
6D58:  MOVWF  F7F
6D5A:  MOVLW  A6
6D5C:  MOVWF  FAD
6D5E:  MOVLW  90
6D60:  MOVWF  FAC
6D62:  BCF    F94.0
6D64:  BSF    F8B.0
6D66:  CLRF   23
6D68:  CLRF   22
6D6A:  CLRF   21
6D6C:  MOVLW  96
6D6E:  MOVWF  20
6D70:  CLRF   27
6D72:  CLRF   26
6D74:  MOVLW  AA
6D76:  MOVWF  25
6D78:  MOVLW  47
6D7A:  MOVWF  24
6D7C:  CLRF   xFA
6D7E:  CLRF   xF9
6D80:  SETF   xFC
6D82:  SETF   xFB
6D84:  MOVLW  0E
6D86:  MOVWF  xFE
6D88:  MOVLW  01
6D8A:  MOVWF  xFF
6D8C:  MOVLB  1
6D8E:  MOVWF  x00
6D90:  CLRF   x01
6D92:  CLRF   x02
6D94:  CLRF   x03
6D96:  CLRF   x04
6D98:  MOVLW  03
6D9A:  MOVWF  x06
6D9C:  MOVLW  E8
6D9E:  MOVWF  x05
6DA0:  CLRF   x07
6DA2:  CLRF   x08
6DA4:  CLRF   x09
6DA6:  MOVLW  64
6DA8:  MOVWF  x0A
6DAA:  CLRF   x0B
6DAC:  CLRF   x0C
6DAE:  CLRF   x0D
6DB0:  CLRF   x0F
6DB2:  CLRF   x0E
6DB4:  CLRF   x10
6DB6:  CLRF   x43
6DB8:  CLRF   x48
6DBA:  CLRF   xAF
6DBC:  CLRF   xB0
6DBE:  MOVLB  4
6DC0:  CLRF   x8D
6DC2:  CLRF   x8C
6DC4:  CLRF   x8E
6DC6:  CLRF   x8F
6DC8:  MOVLW  01
6DCA:  MOVWF  x91
6DCC:  MOVLW  2C
6DCE:  MOVWF  x90
6DD0:  CLRF   x92
6DD2:  CLRF   x93
6DD4:  CLRF   x94
6DD6:  CLRF   x95
6DD8:  CLRF   x97
6DDA:  MOVLW  5A
6DDC:  MOVWF  x96
6DDE:  MOVLB  9
6DE0:  CLRF   x90
6DE2:  CLRF   x8F
6DE4:  CLRF   x8E
6DE6:  CLRF   x8D
6DE8:  CLRF   x91
6DEA:  CLRF   x93
6DEC:  CLRF   x92
6DEE:  CLRF   x95
6DF0:  CLRF   x94
6DF2:  CLRF   x97
6DF4:  CLRF   x96
6DF6:  CLRF   x99
6DF8:  CLRF   x98
6DFA:  MOVLW  FD
6DFC:  MOVWF  x9B
6DFE:  MOVLW  E8
6E00:  MOVWF  x9A
6E02:  CLRF   x9D
6E04:  CLRF   x9C
6E06:  CLRF   x9E
6E08:  CLRF   x9F
6E0A:  CLRF   xA0
6E0C:  CLRF   xA1
6E0E:  CLRF   xA2
6E10:  CLRF   xA3
6E12:  CLRF   xA4
6E14:  CLRF   xA5
6E16:  CLRF   xA6
6E18:  CLRF   xA8
6E1A:  MOVLW  01
6E1C:  MOVWF  xA7
6E1E:  CLRF   xAA
6E20:  CLRF   xA9
6E22:  CLRF   xAB
6E24:  CLRF   xAF
6E26:  CLRF   xAE
6E28:  CLRF   xAD
6E2A:  CLRF   xAC
6E2C:  CLRF   xC0
6E2E:  CLRF   xC1
6E30:  MOVLW  FF
6E32:  MOVLB  F
6E34:  MOVWF  x48
6E36:  BCF    FC2.6
6E38:  BCF    FC2.7
6E3A:  MOVF   x49,W
6E3C:  ANDLW  E0
6E3E:  IORLW  1F
6E40:  MOVWF  x49
6E42:  CLRF   FD2
6E44:  CLRF   FD1
6E46:  CLRF   1A
6E48:  CLRF   1B
6E4A:  MOVLB  1
6E4C:  CLRF   x44
6E4E:  BCF    x45.0
6E50:  CLRF   x46
6E52:  CLRF   x47
6E54:  CLRF   x49
6E56:  BCF    x45.1
6E58:  CLRF   x4A
6E5A:  MOVLB  4
6E5C:  CLRF   x72
6E5E:  CLRF   x73
6E60:  CLRF   x74
6E62:  CLRF   x75
6E64:  CLRF   x76
6E66:  CLRF   x77
6E68:  CLRF   x78
6E6A:  CLRF   x79
6E6C:  CLRF   x7A
6E6E:  CLRF   x7B
6E70:  CLRF   x7C
6E72:  CLRF   x7D
6E74:  CLRF   x7E
6E76:  CLRF   x7F
6E78:  CLRF   x80
6E7A:  CLRF   x81
6E7C:  CLRF   x82
6E7E:  CLRF   x83
6E80:  CLRF   x84
6E82:  CLRF   x85
6E84:  CLRF   x86
6E86:  CLRF   x87
6E88:  CLRF   x88
6E8A:  CLRF   x89
6E8C:  CLRF   x8A
6E8E:  CLRF   x8B
6E90:  MOVLB  9
6E92:  CLRF   xC2
6E94:  CLRF   xC3
6E96:  CLRF   xC4
6E98:  CLRF   xC5
6E9A:  CLRF   xC6
6E9C:  CLRF   xC7
6E9E:  CLRF   xC8
6EA0:  CLRF   xC9
6EA2:  CLRF   xCA
6EA4:  CLRF   xCB
6EA6:  CLRF   xCE
6EA8:  CLRF   xD0
6EAA:  CLRF   xCF
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................     RPINR1=5; 
6EAC:  MOVLW  05
6EAE:  MOVLB  E
6EB0:  MOVWF  xE7
....................    SIM_state = 0xff; 
6EB2:  MOVLB  4
6EB4:  SETF   x8E
....................    charac_timeout=0xffffffff; 
6EB6:  MOVLB  0
6EB8:  SETF   xFC
6EBA:  SETF   xFB
....................    key_timeout=0xffff; 
6EBC:  MOVLB  1
6EBE:  SETF   x06
6EC0:  SETF   x05
....................    setup_oscillator(OSC_32MHZ); 
6EC2:  MOVLW  70
6EC4:  MOVWF  FD3
6EC6:  MOVLW  40
6EC8:  MOVWF  F9B
6ECA:  MOVF   FD3,W
....................    keyprss_off; 
6ECC:  BCF    F92.7
6ECE:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
6ED0:  BCF    FF2.6
6ED2:  BCF    FF2.7
6ED4:  BTFSC  FF2.7
6ED6:  BRA    6ED2
....................    init_ext_eeprom(); 
6ED8:  MOVLB  0
6EDA:  GOTO   4B46
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
6EDE:  MOVLW  04
6EE0:  MOVLB  A
6EE2:  MOVWF  x88
6EE4:  CLRF   19
6EE6:  BTFSC  FF2.7
6EE8:  BSF    19.7
6EEA:  BCF    FF2.7
6EEC:  MOVLW  FA
6EEE:  MOVWF  xEB
6EF0:  MOVLB  0
6EF2:  CALL   1C34
6EF6:  BTFSC  19.7
6EF8:  BSF    FF2.7
6EFA:  MOVLB  A
6EFC:  DECFSZ x88,F
6EFE:  BRA    6EE4
....................    init_password(); 
6F00:  MOVLB  0
6F02:  CALL   4BFE
....................    EEPROM_read(strobe_pass_addr,20,password); 
6F06:  MOVLB  A
6F08:  CLRF   xBE
6F0A:  MOVLW  14
6F0C:  MOVWF  xBF
6F0E:  CLRF   xC1
6F10:  MOVLW  55
6F12:  MOVWF  xC0
6F14:  MOVLB  0
6F16:  CALL   4B50
6F1A:  CLRF   19
6F1C:  BTFSC  FF2.7
6F1E:  BSF    19.7
6F20:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
6F22:  MOVLB  A
6F24:  CLRF   xEF
6F26:  MOVLW  7F
6F28:  MOVWF  xEE
6F2A:  MOVLB  0
6F2C:  CALL   3A84
6F30:  BTFSC  19.7
6F32:  BSF    FF2.7
6F34:  MOVFF  01,10C
....................    //===================================== 
....................    rtc_init(); 
6F38:  GOTO   4C6A
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
6F3C:  MOVLW  19
6F3E:  MOVLB  A
6F40:  MOVWF  x88
6F42:  MOVLB  0
6F44:  CALL   4D82
6F48:  MOVFF  03,23
6F4C:  MOVFF  02,22
6F50:  MOVFF  01,21
6F54:  MOVFF  00,20
....................     
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
6F58:  MOVLW  1E
6F5A:  MOVLB  A
6F5C:  MOVWF  x88
6F5E:  MOVLB  0
6F60:  CALL   4D82
6F64:  MOVFF  03,27
6F68:  MOVFF  02,26
6F6C:  MOVFF  01,25
6F70:  MOVFF  00,24
6F74:  CLRF   19
6F76:  BTFSC  FF2.7
6F78:  BSF    19.7
6F7A:  BCF    FF2.7
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card_key); 
....................    countcard=get_countcard(); 
6F7C:  CALL   3B2C
6F80:  BTFSC  19.7
6F82:  BSF    FF2.7
6F84:  MOVFF  02,FA
6F88:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
6F8C:  SETF   xFC
6F8E:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
6F90:  MOVLW  C7
6F92:  MOVWF  FD5
6F94:  CLRF   19
6F96:  BTFSC  FF2.7
6F98:  BSF    19.7
6F9A:  BCF    FF2.7
....................    //setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
6F9C:  MOVLB  A
6F9E:  CLRF   xEF
6FA0:  MOVLW  94
6FA2:  MOVWF  xEE
6FA4:  MOVLB  0
6FA6:  CALL   3A84
6FAA:  BTFSC  19.7
6FAC:  BSF    FF2.7
6FAE:  MOVFF  01,143
....................    if(delaycharaction==0)delaycharaction=1; 
6FB2:  MOVLB  1
6FB4:  MOVF   x43,F
6FB6:  BNZ   6FBC
6FB8:  MOVLW  01
6FBA:  MOVWF  x43
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
6FBC:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
6FBE:  BSF    FF0.3
6FC0:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
6FC2:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
6FC4:  MOVLW  C0
6FC6:  IORWF  FF2,F
....................    //========================================== 
....................    //delay_ms(100); 
....................    //EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................    //reset_password(); 
....................    //init_password(); 
....................    //fprintf(COM2,"Start\r\n"); 
....................    mcr_timeout=10000; 
6FC8:  MOVLB  9
6FCA:  CLRF   x90
6FCC:  CLRF   x8F
6FCE:  MOVLW  27
6FD0:  MOVWF  x8E
6FD2:  MOVLW  10
6FD4:  MOVWF  x8D
6FD6:  CLRF   19
6FD8:  BTFSC  FF2.7
6FDA:  BSF    19.7
6FDC:  BCF    FF2.7
....................    //EEPROM_read(strobe_pass_addr,20,password); 
....................    //========================================== 
....................    //write_ext_eeprom(strobe_Master_SLV,1); 
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6FDE:  MOVLB  A
6FE0:  CLRF   xEF
6FE2:  MOVLW  91
6FE4:  MOVWF  xEE
6FE6:  MOVLB  0
6FE8:  CALL   3A84
6FEC:  BTFSC  19.7
6FEE:  BSF    FF2.7
6FF0:  MOVFF  01,9AB
6FF4:  CLRF   19
6FF6:  BTFSC  FF2.7
6FF8:  BSF    19.7
6FFA:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
6FFC:  MOVLB  A
6FFE:  CLRF   xEF
7000:  MOVLW  92
7002:  MOVWF  xEE
7004:  MOVLB  0
7006:  CALL   3A84
700A:  BTFSC  19.7
700C:  BSF    FF2.7
700E:  MOVFF  01,99F
....................     key_timeout=1000; 
7012:  MOVLW  03
7014:  MOVLB  1
7016:  MOVWF  x06
7018:  MOVLW  E8
701A:  MOVWF  x05
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
701C:  MOVLB  0
701E:  SETF   xFC
7020:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    #if defined(SIM900) 
....................       //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................       //output_low(PIN_C7); 
....................       //set_tris_c(0); 
....................       #ASM 
....................          BCF    0xF94.7 
....................       #ENDASM 
....................       SIM_state = 0xff; 
....................       fprintf(COM2,"\r\nbooting...\r\n"); 
....................       delay_ms(10000); 
....................       receiver_state=1; 
....................       fprintf(COM1,"AT\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGF=1\r\n"); 
....................       delay_ms(1000); 
....................       //sim900_init(); 
....................       EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................       fprintf(COM1,"AT+CSMP=17,167,0,245\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGD=1\r\n");  
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGD=2\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGD=3\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGD=4\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGD=5\r\n");  
....................       output_high(LED); 
....................       delay_ms(1000); 
....................       SIM_state= idle; 
....................       #ASM 
....................          BSF    0xF94.7 
....................       #ENDASM 
....................       //set_tris_c(0xff); 
....................       //setup_wdt(WDT_ON); 
....................    #endif 
....................    booting_done=1; 
7022:  MOVLW  01
7024:  MOVLB  9
7026:  MOVWF  xC1
....................    charac_timeout=0xffffffff; 
7028:  MOVLB  0
702A:  SETF   xFC
702C:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
702E:  MOVLW  66
7030:  MOVLB  A
7032:  MOVWF  xBE
7034:  MOVLW  10
7036:  MOVWF  xBF
7038:  MOVLW  09
703A:  MOVWF  xC1
703C:  MOVLW  B0
703E:  MOVWF  xC0
7040:  MOVLB  0
7042:  CALL   4B50
....................    EEPROM_read(strobe_pass_addr,20,password); 
7046:  MOVLB  A
7048:  CLRF   xBE
704A:  MOVLW  14
704C:  MOVWF  xBF
704E:  CLRF   xC1
7050:  MOVLW  55
7052:  MOVWF  xC0
7054:  MOVLB  0
7056:  CALL   4B50
....................    set_tris_a(0xff);  
705A:  MOVLW  FF
705C:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
705E:  MOVLW  E0
7060:  MOVLB  F
7062:  MOVWF  x48
7064:  BCF    FC2.6
7066:  BCF    FC2.7
7068:  MOVF   x49,W
706A:  ANDLW  E0
706C:  IORLW  1F
706E:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
7070:  MOVF   FC1,W
7072:  ANDLW  C0
7074:  IORLW  03
7076:  MOVWF  FC1
7078:  BCF    FC1.7
707A:  BSF    FC2.0
707C:  BSF    FC1.6
707E:  BSF    FC2.1
7080:  BTFSC  FC2.1
7082:  BRA    7080
7084:  BCF    FC1.6
7086:  CLRF   19
7088:  BTFSC  FF2.7
708A:  BSF    19.7
708C:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
708E:  MOVLB  A
7090:  CLRF   xEF
7092:  MOVLW  7F
7094:  MOVWF  xEE
7096:  MOVLB  0
7098:  CALL   3A84
709C:  BTFSC  19.7
709E:  BSF    FF2.7
70A0:  MOVFF  01,10C
70A4:  CLRF   19
70A6:  BTFSC  FF2.7
70A8:  BSF    19.7
70AA:  BCF    FF2.7
....................    type_KB=read_ext_eeprom(kindofKB); 
70AC:  MOVLB  A
70AE:  CLRF   xEF
70B0:  MOVLW  7E
70B2:  MOVWF  xEE
70B4:  MOVLB  0
70B6:  CALL   3A84
70BA:  BTFSC  19.7
70BC:  BSF    FF2.7
70BE:  MOVFF  01,110
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
70C2:  MOVLB  1
70C4:  MOVF   x10,F
70C6:  BZ    70E6
70C8:  MOVLW  D6
70CA:  MOVWF  FF6
70CC:  MOVLW  4A
70CE:  MOVWF  FF7
70D0:  CLRF   19
70D2:  BTFSC  FF2.7
70D4:  BSF    19.7
70D6:  BCF    FF2.7
70D8:  MOVLB  0
70DA:  CALL   05F0
70DE:  BTFSC  19.7
70E0:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
70E2:  BRA    7100
70E4:  MOVLB  1
70E6:  MOVLW  EA
70E8:  MOVWF  FF6
70EA:  MOVLW  4A
70EC:  MOVWF  FF7
70EE:  CLRF   19
70F0:  BTFSC  FF2.7
70F2:  BSF    19.7
70F4:  BCF    FF2.7
70F6:  MOVLB  0
70F8:  CALL   05F0
70FC:  BTFSC  19.7
70FE:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
7100:  MOVLB  9
7102:  MOVF   xAB,F
7104:  BNZ   7124
7106:  MOVLW  FE
7108:  MOVWF  FF6
710A:  MOVLW  4A
710C:  MOVWF  FF7
710E:  CLRF   19
7110:  BTFSC  FF2.7
7112:  BSF    19.7
7114:  BCF    FF2.7
7116:  MOVLB  0
7118:  CALL   05F0
711C:  BTFSC  19.7
711E:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
7120:  BRA    713E
7122:  MOVLB  9
7124:  MOVLW  18
7126:  MOVWF  FF6
7128:  MOVLW  4B
712A:  MOVWF  FF7
712C:  CLRF   19
712E:  BTFSC  FF2.7
7130:  BSF    19.7
7132:  BCF    FF2.7
7134:  MOVLB  0
7136:  CALL   05F0
713A:  BTFSC  19.7
713C:  BSF    FF2.7
....................     
....................    #if defined(SIM900) 
....................       #if defined(twonumber) 
....................          fprintf(COM2,"two numbers mode ver\n\r"); 
....................          #else    
....................             fprintf(COM2,"one numbers mode ver\n\r"); 
....................       #endif 
....................       //twonumber=read_ext_eeprom(strobe_two_number); 
....................       auto_sending=read_ext_eeprom(strobe_autosending);   
....................       if(auto_sending==0)fprintf(COM2,"autosending is disable\n\r"); 
....................          else fprintf(COM2,"autosending is enable\n\r"); 
....................    #endif 
....................    memset(reply_buffer,0,sizeof(reply_buffer));  
713E:  MOVLW  03
7140:  MOVWF  FEA
7142:  MOVLW  41
7144:  MOVWF  FE9
7146:  CLRF   00
7148:  MOVLW  01
714A:  MOVWF  02
714C:  MOVLW  18
714E:  MOVWF  01
7150:  CALL   45F2
....................    memset(msg_data_sending,0,sizeof(msg_data_sending));  
7154:  MOVLW  01
7156:  MOVWF  FEA
7158:  MOVLW  B1
715A:  MOVWF  FE9
715C:  CLRF   00
715E:  MOVLW  01
7160:  MOVWF  02
7162:  MOVLW  18
7164:  MOVWF  01
7166:  CALL   45F2
....................     
....................    //save_coutcard(349); 
....................    while(1) 
....................    { 
....................      #if defined(SIM900) 
....................       count_polling++; 
....................       if(count_polling>=timing_wait) 
....................       { 
....................          count_polling=0; 
....................          //fprintf(COM2,"SIM_state %d\n\r",SIM_state); 
....................          switch(SIM_state) 
....................          { 
....................             case reading_sms_cmd:             
....................                cards=get_countcard(); 
....................                receiver_state=1; 
....................                memset(buffer_uart,0,sizeof(buffer_uart));  
....................                memset(mobilenumb,0,sizeof(mobilenumb));  
....................                fprintf(COM2,"reading_sms...\n\r"); 
....................                #ASM BCF    0xF94.7 #ENDASM                   
....................                   fprintf(COM1,"AT+CMGR=1\r\n"); 
....................                #ASM BSF    0xF94.7 #ENDASM 
....................                //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................                SIM_state=MSG_avai; 
....................                UART_index=0; 
....................                timing_wait=3000; 
....................                //fprintf(COM2,"device has %lu charactions\n\r",cards); 
....................             break; 
....................             case MSG_avai: 
....................                //fprintf(COM2,"MSG_avai...\n\r"); 
....................                //temp=checking_msg_avai(); 
....................                //fprintf(COM2,"MSG_avai...%d\n\r",temp); 
....................                //if(temp==1) SIM_state=reading_sms_cmd; 
....................                SIM_state=analyze_sms;  
....................                //fprintf(COM2,"\r\ntemp=%d\r\n",temp); 
....................                timing_wait=2000; 
....................             break; 
....................             case analyze_sms: 
....................                fprintf(COM2,"analyze_sms...\n\r");  
....................                del_buf(20,msg_buffer1); 
....................                del_buf(50,msg_buffer2); 
....................                del_buf(50,sim_bug); 
....................                //memset(msg_buffer1,0,sizeof(msg_buffer1)); 
....................                //memset(msg_buffer2,0,sizeof(msg_buffer2)); 
....................                //memset(sim_bug,0,sizeof(sim_bug)); 
....................                analyzing_msg(sim_bug,mobilenumb); 
....................                /*for(i=0;i<25;i++) 
....................                { 
....................                   fprintf(COM2,"%d",sim_bug[i]); 
....................                }*/ 
....................                 
....................                memset(buffer_uart,0,sizeof(buffer_uart));  
....................                #if defined(twonumber)  
....................                   SIM_state=checking_MN0; 
....................                   #else SIM_state=checking_MN; 
....................                #endif     
....................                if((mobilenumb[0]==0)&&(mobilenumb[1]==0)&&(mobilenumb[2]==0)&&(mobilenumb[3]==0)&&(mobilenumb[4]==0))SIM_state= delete_MSG; 
....................                timing_wait=1500; 
....................                count_char=0; 
....................             break; 
....................             #if defined(twonumber)  
....................             case checking_MN0: 
....................                fprintf(COM2,"\n\rchecking the first number\n\r"); 
....................                fprintf(COM2,"\n\rMobile phone number is "); 
....................                for(i=0;i<20;i++) fprintf(COM2,"%c",mobilenumb[i]);  
....................                fprintf(COM2,"\n\rMSG: "); 
....................                for(i=0;i<50;i++) fprintf(COM2,"%c",sim_bug[i]); 
....................                fprintf(COM2,"\n\rTIME: "); 
....................                for(i=0;i<25;i++) 
....................                { 
....................                   if(datetime[i]=='"')break; 
....................                   fprintf(COM2,"%c",datetime[i]); 
....................                } 
....................                EEPROM_read(strobe_mobile_num0,20,msg_buffer1);  
....................                if(!stringcomp(mobilenumb,msg_buffer1))   
....................                { 
....................                   fprintf(COM2,"\n\rchecking phone number is done\n\r");  
....................                   updatetime2ds1307(); 
....................                   SIM_state=doing_sms; 
....................                } 
....................                else 
....................                { 
....................                  SIM_state=checking_MN; 
....................                  strcpy(msg_buffer2,"cfmbn1"); 
....................                  if(!strncmp(msg_buffer2,sim_bug,6))  
....................                  { 
....................                    SIM_state=delete_MSG;   
....................                    for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+7];                 
....................                    fprintf(COM2,"\n\rconfigured mobile phone number\n\r");  
....................                    for(i=0;i<20;i++)fprintf(COM2,"%c",msg_buffer2[i]);  
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",msg_buffer2[i]); 
....................                    fprintf(COM2,"\n\r");  
....................                    EEPROM_read(strobe_pass_addr,20,password); 
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%c",password[i]); 
....................                    for(i=0;i<20;i++) 
....................                    { 
....................                      if(password[i]==0)break; 
....................                            else count_char++; 
....................                    } 
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",password[i]); 
....................                    //fprintf(COM2,"count_char=%d\n\r",count_char);  
....................                    //fprintf(COM2,"\n\r"); 
....................                    if(!strncmp(password,msg_buffer2,count_char))  
....................                    { 
....................                       EEPROM_write(strobe_mobile_num0,20,mobilenumb); 
....................                       fprintf(COM2,"changed phone number\n\r("); 
....................                       for(i=0;i<20;i++)fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num0+i));  
....................                       strcpy(reply_buffer,"done"); 
....................                       fprintf(COM2,")\n\r"); 
....................                    } 
....................                      else 
....................                      { 
....................                         fprintf(COM2,"wrong password\n\r"); 
....................                         strcpy(reply_buffer,"wrong password"); 
....................                      }                      
....................                    SIM_state=SIM_reply;   
....................                  } 
....................  
....................                } 
....................             break; 
....................             #endif  
....................             case checking_MN: 
....................                #if defined(twonumber)  
....................                   fprintf(COM2,"\n\rchecking the second number\n\r"); 
....................                #endif 
....................                fprintf(COM2,"\n\rMobile phone number is "); 
....................                for(i=0;i<20;i++) fprintf(COM2,"%c",mobilenumb[i]);   
....................                fprintf(COM2,"\n\rMSG: "); 
....................                for(i=0;i<50;i++) fprintf(COM2,"%c",sim_bug[i]); 
....................                fprintf(COM2,"\n\rTIME: "); 
....................                for(i=0;i<25;i++) 
....................                { 
....................                   if(datetime[i]=='"')break; 
....................                   fprintf(COM2,"%c",datetime[i]); 
....................                }               
....................                EEPROM_read(strobe_mobile_num1,20,msg_buffer1);                 
....................               //strcpy(msg_buffer1,"+84903219082"); 
....................               //strcpy(msg_buffer1,"+16612891316");//+16612891316 
....................               strcpy(msg_buffer2,"rstpwd"); 
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
....................               { 
....................                  fprintf(COM2,"\n\rreset the password\n\r"); 
....................                  reset_password(); 
....................                  init_password(); 
....................                  strcpy(reply_buffer,"done"); 
....................                  fprintf(COM2,"done\n\r"); 
....................                  SIM_state=SIM_reply;  
....................                  break; 
....................               } 
....................               if(!stringcomp(mobilenumb,msg_buffer1))   
....................               { 
....................                   fprintf(COM2,"\n\rchecking phone number is done\n\r");  
....................                   updatetime2ds1307(); 
....................                   SIM_state=doing_sms; 
....................               } 
....................                else 
....................                { 
....................                  SIM_state=delete_MSG; 
....................                  strcpy(msg_buffer2,"cfmbn"); 
....................                  if(!strncmp(msg_buffer2,sim_bug,5))  
....................                  { 
....................                    SIM_state=delete_MSG;   
....................                    for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+6];                 
....................                    fprintf(COM2,"\n\rconfigured mobile phone number\n\r");  
....................                    for(i=0;i<20;i++)fprintf(COM2,"%c",msg_buffer2[i]);  
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",msg_buffer2[i]); 
....................                    fprintf(COM2,"\n\r");  
....................                    EEPROM_read(strobe_pass_addr,20,password); 
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%c",password[i]); 
....................                    for(i=0;i<20;i++) 
....................                    { 
....................                      if(password[i]==0)break; 
....................                            else count_char++; 
....................                    } 
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",password[i]); 
....................                    //fprintf(COM2,"count_char=%d\n\r",count_char);  
....................                    //fprintf(COM2,"\n\r"); 
....................                    if(!strncmp(password,msg_buffer2,count_char))  
....................                    { 
....................                       EEPROM_write(strobe_mobile_num1,20,mobilenumb); 
....................                       fprintf(COM2,"changed phone number\n\r("); 
....................                       for(i=0;i<20;i++)fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));  
....................                       strcpy(reply_buffer,"done"); 
....................                       fprintf(COM2,")\n\r"); 
....................                    } 
....................                      else 
....................                      { 
....................                         fprintf(COM2,"wrong password\n\r"); 
....................                         strcpy(reply_buffer,"wrong password"); 
....................                      }                      
....................                    SIM_state=SIM_reply;   
....................                  } 
....................                   else fprintf(COM2,"\n\r this phone unable to send commands \n\r"); 
....................                } 
....................             break; 
....................             case doing_sms: 
....................                
....................               memset(msg_data_sending,0,sizeof(msg_data_sending)); 
....................                
....................               strcpy(msg_buffer2,"password"); 
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
....................               { 
....................                 //SIM_state=delete_MSG;   
....................                 SIM_state=SIM_reply; 
....................                 for(i=0;i<20;i++) 
....................                 { 
....................                   write_ext_eeprom(strobe_pass_addr+i,sim_bug[i+9]); 
....................                   delay_us(10); 
....................                 } 
....................                 //EEPROM_write(strobe_pass_addr,20,sim_bug); 
....................                 fprintf(COM2,"changed the password\n\r");               
....................                 memset(password,0,sizeof(password)); 
....................                 EEPROM_read(strobe_pass_addr,20,password); 
....................                 for(i=0;i<20;i++) fprintf(COM2,"%c",password[i]); 
....................                 fprintf(COM2,"\n\rexit\n\r"); 
....................                 strcpy(reply_buffer,"done"); 
....................                 break; 
....................               } 
....................                
....................               strcpy(msg_buffer2,"keypress"); 
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 //SIM_state=SIM_reply; 
....................                 SIM_state=SIM_reply; 
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+9]; 
....................                 strcpy(msg_buffer1,"on"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
....................                 { 
....................                   fprintf(COM2,"\n\rkeypress turn on\n\r"); 
....................                   KP_mode = 1; 
....................                   write_ext_eeprom(strobe_keypressmode,KP_mode); 
....................                   fprintf(COM2," exit\n\r");                  
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
....................                 { 
....................                   fprintf(COM2,"\n\rkeypress turn off\n\r"); 
....................                   KP_mode = 0; 
....................                   write_ext_eeprom(strobe_keypressmode,KP_mode); 
....................                   fprintf(COM2," exit\n\r"); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................                 } 
....................                 strcpy(reply_buffer,"please check your syntax");  
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
....................                 break; 
....................               } 
....................               strcpy(msg_buffer2,"master"); 
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+7]; 
....................                 strcpy(msg_buffer1,"on"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
....................                 { 
....................                   fprintf(COM2,"\n\rmaster mode turn on\n\r"); 
....................                    mode_sl = 0; 
....................                    write_ext_eeprom(strobe_Master_SLV,mode_sl); 
....................                    strcpy(reply_buffer,"done"); 
....................                    fprintf(COM2," exit\n\r"); 
....................                    break; 
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
....................                 { 
....................                   fprintf(COM2,"\n\rmaster mode turn off\n\r"); 
....................                   mode_sl = 1; 
....................                   write_ext_eeprom(strobe_Master_SLV,mode_sl); 
....................                   strcpy(reply_buffer,"done"); 
....................                   fprintf(COM2," exit\n\r"); 
....................                   break; 
....................                 } 
....................                 strcpy(reply_buffer,"please check your syntax");  
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
....................                 break; 
....................               } 
....................                
....................               strcpy(msg_buffer2,"rsfact"); 
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
....................                   fprintf(COM2,"reset factory\n\r"); 
....................                   rstfact(); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................               }    
....................               strcpy(msg_buffer2,"kofkb new"); 
....................               if(!strncmp(msg_buffer2,sim_bug,9))  
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
....................                   fprintf(COM2,"changed to new keyboard\n\r"); 
....................                   type_KB=1; 
....................                   write_ext_eeprom(kindofKB,type_KB); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................               } 
....................               strcpy(msg_buffer2,"kofkb old"); 
....................               if(!strncmp(msg_buffer2,sim_bug,9))  
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
....................                   fprintf(COM2,"changed to old keyboard\n\r"); 
....................                   type_KB=0; 
....................                   write_ext_eeprom(kindofKB,type_KB); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................               } 
....................               strcpy(msg_buffer2,"trantime"); 
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
....................                 memset(msg_buffer2,0,sizeof(msg_buffer2)); 
....................                 //for(i=0;i<3;i++)msg_buffer2[i]=sim_bug[i+9]; 
....................                 if((sim_bug[9]>47)&&(sim_bug[9]<58))  
....................                 { 
....................                    delaycharaction = (sim_bug[9]-48)*10; 
....................                    if((sim_bug[10]>47)&&(sim_bug[10]<58))delaycharaction=delaycharaction+(sim_bug[10]-48); 
....................                      else delaycharaction = sim_bug[9]-48; 
....................                   fprintf(COM2,"tran time = %d\n\r",delaycharaction);   
....................                   write_ext_eeprom(strobe_delaytime,delaycharaction); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................                 } 
....................                   else  
....................                      { 
....................                         fprintf(COM2,"\n\rplease check your syntax\n\r"); 
....................                         strcpy(reply_buffer,"please check your syntax");  
....................                         break; 
....................                      } 
....................                 break; 
....................               } 
....................                 
....................               strcpy(msg_buffer2,"autosending"); 
....................               if(!strncmp(msg_buffer2,sim_bug,11))  
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+12]; 
....................                 strcpy(msg_buffer1,"on"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
....................                 { 
....................                   fprintf(COM2,"\n\rautosending turn on\n\r"); 
....................                   auto_sending = 1; 
....................                   write_ext_eeprom(strobe_autosending,auto_sending); 
....................                   fprintf(COM2," exit\n\r"); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
....................                 { 
....................                   fprintf(COM2,"\n\rautosending turn off\n\r"); 
....................                   auto_sending = 0; 
....................                   write_ext_eeprom(strobe_autosending,auto_sending); 
....................                   fprintf(COM2," exit\n\r"); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................                 } 
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
....................                 strcpy(reply_buffer,"please check your syntax"); 
....................                 //fprintf(COM2," exit\n\r"); 
....................                 break; 
....................               } 
....................  
....................               strcpy(msg_buffer2,"qullf"); 
....................               if(!strncmp(msg_buffer2,sim_bug,5))  
....................               { 
....................                 SIM_state=delete_MSG; 
....................                 fprintf(COM2,"FORMATTING..."); 
....................                 ease_eeprom(); 
....................                 fprintf(COM2," exit\n\r"); 
....................                 break; 
....................               } 
....................               strcpy(msg_buffer2,"format"); 
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
....................                   fprintf(COM2,"FORMATTING..."); 
....................                   format_eepromext(); 
....................                   fprintf(COM2," exit\n\r"); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................               } 
....................               strcpy(msg_buffer2,"count tran"); 
....................               if(!strncmp(msg_buffer2,sim_bug,10))  
....................               {   
....................                   len=0; 
....................                   cards=get_countcard(); 
....................                   strcpy(msg_buffer2,"device has "); 
....................                   len=pre_msg(msg_buffer2,msg_data_sending,0); 
....................                   itoa(cards,10,string); 
....................                   len=pre_msg(string,msg_data_sending,len); 
....................                   strcpy(msg_buffer2," transaction "); 
....................                   len=pre_msg(msg_buffer2,msg_data_sending,len); 
....................                   SIM_state=MSG_sending; 
....................                   lastlen=0; 
....................                   fprintf(COM2,"device has %lu transaction \n\r",cards); 
....................                   countc=0; 
....................                   count_dwla=0; 
....................                   break; 
....................               } 
....................               strcpy(msg_buffer2,"download all"); 
....................               if(!strncmp(msg_buffer2,sim_bug,12)) 
....................               { 
....................                    fprintf(COM2,"download all\n\r");   
....................                    count_dwla=get_countcard(); 
....................                    len=0; 
....................                    num_card=count_dwla; 
....................                    SIM_state=pre_cmd; 
....................                    countc=0; 
....................                    break; 
....................               } 
....................               strcpy(msg_buffer2,"download "); 
....................               if(!strncmp(msg_buffer2,sim_bug,9)) 
....................               { 
....................                   if((sim_bug[9]<48)||(sim_bug[9]>57)) 
....................                   { 
....................                      SIM_state=SIM_reply; 
....................                      fprintf(COM2,"\n\rplease check your syntax\n\r"); 
....................                      strcpy(reply_buffer,"please check your syntax"); 
....................                      break; 
....................                   } 
....................                   i=0; 
....................                   temp=sim_bug[9]; 
....................                   while(temp!=0) 
....................                   { 
....................                      temp=sim_bug[i+9]; 
....................                      string[i++]=temp; 
....................                   } 
....................                   countc=atoi(string); 
....................                   //fprintf(COM2,"countc=%lu\n\r",countc); 
....................                   count_dwla=get_countcard(); 
....................                   if(count_dwla<countc) 
....................                   { 
....................                      len=0; 
....................                      strcpy(buftemp2,"Device has only "); 
....................                      len=pre_msg(buftemp2,msg_data_sending,0); 
....................                      itoa(count_dwla,10,string); 
....................                      len=pre_msg(string,msg_data_sending,len); 
....................                      strcpy(buftemp2," transaction ");//transaction\n\r 
....................                      len=pre_msg(buftemp2,msg_data_sending,len); 
....................                      SIM_state=MSG_sending; 
....................                      lastlen=0; 
....................                      count_dwla=0; 
....................                      num_card=0; 
....................                      break; 
....................                   } 
....................                   else  
....................                   { 
....................                      num_card=count_dwla; 
....................                      countc=num_card-countc; 
....................                      if(countc==0)count_dwla=num_card; 
....................                      else count_dwla=0; 
....................                      SIM_state=pre_cmd; 
....................                      break; 
....................                   } 
....................                   //SIM_state=delete_MSG; 
....................               } 
....................               else SIM_state=delete_MSG; 
....................             break; 
....................             case delete_MSG: 
....................                fprintf(COM2,"delete_MSG...\n\r"); 
....................                #ASM BCF    0xF94.7 #ENDASM  
....................                   fprintf(COM1,"AT+CMGD=1\r\n"); 
....................                #ASM BSF    0xF94.7 #ENDASM  
....................                del_buf(200,buffer_uart); 
....................                //SIM_state=sending_cmd;        
....................                timing_wait=10000; 
....................                SIM_state= idle; 
....................                output_low(LED); 
....................                memset(reply_buffer,0,sizeof(reply_buffer));  
....................                SIM_reply_st=0; 
....................                #if defined(twonumber) 
....................                   if(two_number_sending==1) 
....................                   { 
....................                     SIM_state=autosending1;  
....................                     two_number_sending=0; 
....................                   } 
....................                #endif 
....................             break; 
....................             case pre_cmd: 
....................                    //fprintf(COM2,"pre_cmd-> num_card,countc, count_dwla=%lu,%lu,%lu\r\n",num_card,countc,count_dwla);   
....................                    if(num_card==0)  
....................                    { 
....................                      SIM_state=delete_MSG; 
....................                      break; 
....................                    } 
....................                    len=0; 
....................                    //num_card=1; 
....................                    memset(msg_data_sending,0,sizeof(msg_data_sending));  
....................                    addr_dat=num_card*numdata+ptr_start; 
....................                    I2CEEPROM_read((unsigned int16)(addr_dat-numdata),numdata,buftemp); 
....................                    itoa(buftemp[0],10,string); 
....................                    len=pre_msg(string,msg_data_sending,0); 
....................                    msg_data_sending[len++]='/'; 
....................                    itoa(buftemp[1],10,string); 
....................                    len=pre_msg(string,msg_data_sending,len); 
....................                    msg_data_sending[len++]='/'; 
....................                    msg_data_sending[len++]=' '; 
....................                    itoa(buftemp[2],10,string); 
....................                    len=pre_msg(string,msg_data_sending,len); 
....................                    msg_data_sending[len++]=':'; 
....................                    itoa(buftemp[3],10,string); 
....................                    len=pre_msg(string,msg_data_sending,len); 
....................                    msg_data_sending[len++]=':'; 
....................                    itoa(buftemp[4],10,string); 
....................                    len=pre_msg(string,msg_data_sending,len); 
....................                    //msg_data_sending[len++]=' '; 
....................                    i=0; 
....................                    strcpy(buftemp2," Track1>"); 
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
....................                    temp=0; 
....................                    while((i<numbyteoftrack1)&&(temp!='?')) 
....................                    { 
....................                      temp = buftemp[i+5]; 
....................                      //fprintf(COM2,"%c",temp);  
....................                      if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
....................                      i++; 
....................                      if(temp==0)break; 
....................                    } 
....................                    i=0; 
....................                    temp=0; 
....................                    strcpy(buftemp2," Track2>"); 
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
....................                    while((i<numbyteoftrack2)&&(temp!='?')) 
....................                    { 
....................                      temp = buftemp[i+5+numbyteoftrack1]; 
....................                      //fprintf(COM2,"%c",temp);  
....................                      if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
....................                      i++; 
....................                      if(temp==0)break; 
....................                    } 
....................                    addr_key=EEPROM_KEY_ST+((num_card-1)*50); 
....................                    //if(ptr_card_key>addr_key) 
....................                    //{ 
....................                       strcpy(buftemp2," PIN:"); 
....................                       len=pre_msg(buftemp2,msg_data_sending,len); 
....................                       j=0; 
....................                       do 
....................                       { 
....................                         temp=read_ext_eeprom(j+addr_key); 
....................                         if(((temp>47)&&(temp<58))||((temp=='#')||(temp=='*'))||(temp>64)&&(temp<73)) 
....................                            msg_data_sending[len++]=temp; 
....................                         j++; 
....................                       } 
....................                       while((j<key_numbyte)&&(temp!=0)); 
....................                       fprintf(COM2,"%lu character\n\r",len);   
....................                      //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                       //addr_key=addr_key+(50); 
....................                     //}        
....................                    lastlen=0;  
....................                    //fprintf(COM2,"countc,num_card =%lu,%lu\n\r",countc,num_card); 
....................                    if((countc==num_card)&&(countc!=0)) 
....................                    { 
....................                      SIM_state=delete_MSG;  
....................                      break; 
....................                    } 
....................                    num_card--; 
....................                    //fprintf(COM2,"send_oneMSG =%d\n\r",send_oneMSG); 
....................                    if(send_oneMSG==1) 
....................                    { 
....................                      num_card=0; 
....................                      send_oneMSG=0; 
....................                    } 
....................                    SIM_state=MSG_sending;               
....................             break; 
....................             case MSG_sending: 
....................                   fprintf(COM2,"MSG_sending %d\n\r",MSG_sending_st); 
....................                   //fprintf(COM2,"MSG_sending_st %d\n\r",MSG_sending_st); 
....................                   timing_wait=10000; 
....................                output_high(LED); 
....................                #ASM BCF    0xF94.7 #ENDASM  
....................                switch(MSG_sending_st) 
....................                { 
....................                   case 0:// configure MSG 
....................                      receiver_state=1; 
....................                         fprintf(COM1,"AT+CMGF=1\r\n"); // text mode 
....................                      //fprintf(COM2,"AT+CMGF=1\r\n"); // text mode 
....................                      strl= strlen(msg_data_sending); 
....................                      MSG_sending_st=1; 
....................                      //EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
....................                   break; 
....................                   case 1: 
....................                         fprintf(COM1,"AT+CMGS="); 
....................                      //fprintf(COM2,"AT+CMGS="); 
....................                      fputc('"',COM1); 
....................                      i=0; 
....................                      while((mobilenumb[i]!=0)&&(i<20)) 
....................                      { 
....................                         fputc(mobilenumb[i],COM1); 
....................                         //fprintf(COM2,"%c",mobilenumb[i]);  
....................                         i++; 
....................                      } 
....................                      fputc('"',COM1); 
....................                      fprintf(COM1,"\r\n"); 
....................                      MSG_sending_st=2; 
....................                   break; 
....................                   case 2: 
....................                      //while((msg_data_sending[i]!=0)&&(i<140)) 
....................                      for(i=0;i<140;i++) 
....................                      { 
....................                         if(msg_data_sending[i+lastlen]==0) 
....................                         { 
....................                            SIM_state=delete_MSG;    
....................                            MSG_sending_st=0; 
....................                            break; 
....................                         } 
....................                         fputc(msg_data_sending[i+lastlen],COM1); 
....................                      } 
....................                      //fprintf(COM2,"i= %u\n\r",i);  
....................                      fputc(26,COM1); 
....................                      MSG_sending_st=0; 
....................                      if(i<140) 
....................                      { 
....................                         SIM_state=check_st; 
....................                         lastlen=0; 
....................                      } 
....................                      else 
....................                      { 
....................                         lastlen=140; 
....................                         if(msg_data_sending[140]==0)SIM_state=check_st; 
....................                      } 
....................                      if(lastlen==140)SIM_state=MSG_sending; 
....................                      //fprintf(COM2,"lastlen %lu\n\r",lastlen);   
....................                   break; 
....................                } 
....................                #ASM BSF    0xF94.7 #ENDASM  
....................             break; 
....................             case check_st: 
....................                //fprintf(COM2,"check_st->num_card,countc, count_dwla, lastlen =%lu,%lu,%lu,%lu\r\n",num_card,countc,count_dwla,lastlen);   
....................                if(count_dwla>1) 
....................                { 
....................                   count_dwla--; 
....................                   SIM_state=pre_cmd; 
....................                   break; 
....................                } 
....................                else if(countc>0)  
....................                { 
....................                   SIM_state=pre_cmd; 
....................                   break; 
....................                } 
....................                else SIM_state=delete_MSG; 
....................             break; 
....................             case autosending:  
....................                   //auto_sending=read_ext_eeprom(strobe_autosending); 
....................                   //if(auto_sending==1) 
....................                   //{ 
....................                      EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
....................                      #if defined(twonumber)  
....................                         fprintf(COM2,"\r\nSending to the first number\r\n"); 
....................                      #else  
....................                         fprintf(COM2,"\r\nSending\r\n"); 
....................                      #endif 
....................                      num_card=get_countcard(); 
....................                      countc=0; 
....................                      count_dwla=0; 
....................                      lastlen=0; 
....................                      send_oneMSG=1; 
....................                      SIM_state=pre_cmd; 
....................                   //} 
....................                   //else SIM_state= reading_sms_cmd; 
....................             break; 
....................             #if defined(twonumber)  
....................             case autosending1:  
....................                   //auto_sending=read_ext_eeprom(strobe_autosending); 
....................                   //if(auto_sending==1) 
....................                   //{ 
....................                      EEPROM_read(strobe_mobile_num0,20,mobilenumb);  
....................                      fprintf(COM2,"\r\nSending to the second number\r\n"); 
....................                      num_card=get_countcard(); 
....................                      countc=0; 
....................                      count_dwla=0; 
....................                      lastlen=0; 
....................                      send_oneMSG=1; 
....................                      SIM_state=pre_cmd; 
....................                   //} 
....................                   //else SIM_state= reading_sms_cmd; 
....................             break; 
....................             #endif 
....................             case idle: 
....................                   output_toggle(LED); 
....................                   fprintf(COM2,"idle\n\r"); 
....................                   fprintf(COM1,"AT+CMGF=1\r\n"); 
....................                   output_low(LED); 
....................                   SIM_state= data_analyze; 
....................                   receiver_state=0; 
....................                   timing_wait=1500; 
....................             break; 
....................             case data_analyze: 
....................                   //fprintf(COM2,"data_analyze=%d\n\r",temp); 
....................                   booting_done=1; 
....................                   output_low(LED); 
....................                   temp=SMS_coming(); 
....................                   if(temp==2) 
....................                   { 
....................                      output_high(LED); 
....................                      SIM_state=reading_sms_cmd; 
....................                      count_checking=0; 
....................                   } 
....................                   count_checking++; 
....................                   if(count_checking==100) 
....................                   { 
....................                      //SIM_state=phone_activity_status; 
....................                      SIM_state=check_comunication; 
....................                      count_checking=0; 
....................                   } 
....................             break; 
....................             case SIM_reply: 
....................                   fprintf(COM2,"SIM is replying\n\r"); 
....................                   //send_sms(mobilenumb,reply_buffer); 
....................                   len=0; 
....................                   cards=get_countcard(); 
....................                   //strcpy(msg_buffer2,"device has "); 
....................                   len=pre_msg(reply_buffer,msg_data_sending,0); 
....................                   //itoa(cards,10,string); 
....................                   //len=pre_msg(string,msg_data_sending,len); 
....................                   //strcpy(msg_buffer2," transaction "); 
....................                   //len=pre_msg(msg_buffer2,msg_data_sending,len); 
....................                   SIM_state=MSG_sending; 
....................                   lastlen=0; 
....................                   //fprintf(COM2,"device has %lu transaction \n\r",cards); 
....................                   countc=0; 
....................                   count_dwla=0; 
....................             break; 
....................             case check_comunication: 
....................                fprintf(COM2,"check comunication\n\r"); 
....................                //SIM_state= data_analyze; 
....................                SIM_state= phone_activity_status; 
....................                booting_done=0; 
....................                checking_sim=1; 
....................                setup_wdt(WDT_ON); 
....................                fprintf(COM1,"AT\r\n");   
....................             break; 
....................             case phone_activity_status: 
....................                booting_done=1; 
....................                fprintf(COM2,"SIM activity status\n\r"); 
....................                SIM_state= data_analyze; 
....................                fprintf(COM1,"AT+CPAS\r\n");  
....................             break; 
....................             case check_inbox: 
....................                fprintf(COM2,"check inbox\n\r"); 
....................                SIM_state= data_analyze; 
....................                fprintf(COM1,"AT+CMGR=1\r\n"); 
....................             break; 
....................          }         
....................       } 
....................       //restart_wdt(); 
....................       delay_us(500); 
....................      #else 
....................       if(mode==LOGOFF) 
716A:  MOVLB  9
716C:  MOVF   xA5,F
716E:  BNZ   71FA
....................       { 
....................          fprintf(COM2,"password:"); 
7170:  MOVLW  30
7172:  MOVWF  FF6
7174:  MOVLW  4B
7176:  MOVWF  FF7
7178:  CLRF   19
717A:  BTFSC  FF2.7
717C:  BSF    19.7
717E:  BCF    FF2.7
7180:  MOVLB  0
7182:  CALL   05F0
7186:  BTFSC  19.7
7188:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
718A:  MOVLW  02
718C:  MOVLB  A
718E:  MOVWF  xBE
7190:  MOVLW  14
7192:  MOVWF  xBF
7194:  MOVLW  01
7196:  MOVWF  xC1
7198:  MOVLW  4B
719A:  MOVWF  xC0
719C:  MOVLB  0
719E:  CALL   4F0E
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          if(!stringcomp(buffer_uart,password)) 
71A2:  MOVLW  01
71A4:  MOVLB  A
71A6:  MOVWF  xBF
71A8:  MOVLW  4B
71AA:  MOVWF  xBE
71AC:  CLRF   xC1
71AE:  MOVLW  55
71B0:  MOVWF  xC0
71B2:  MOVLB  0
71B4:  CALL   5046
71B8:  MOVF   01,F
71BA:  BNZ   71DE
....................          { 
....................             mode=LOGON; 
71BC:  MOVLW  01
71BE:  MOVLB  9
71C0:  MOVWF  xA5
....................             fprintf(COM2," OK\n\r"); 
71C2:  MOVLW  3A
71C4:  MOVWF  FF6
71C6:  MOVLW  4B
71C8:  MOVWF  FF7
71CA:  CLRF   19
71CC:  BTFSC  FF2.7
71CE:  BSF    19.7
71D0:  BCF    FF2.7
71D2:  MOVLB  0
71D4:  CALL   05F0
71D8:  BTFSC  19.7
71DA:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
71DC:  BRA    71F6
71DE:  MOVLW  40
71E0:  MOVWF  FF6
71E2:  MOVLW  4B
71E4:  MOVWF  FF7
71E6:  CLRF   19
71E8:  BTFSC  FF2.7
71EA:  BSF    19.7
71EC:  BCF    FF2.7
71EE:  CALL   05F0
71F2:  BTFSC  19.7
71F4:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/ 
71F6:  BRA    7204
71F8:  MOVLB  9
71FA:  DECFSZ xA5,W
71FC:  BRA    7206
71FE:  MOVLB  0
7200:  GOTO   57C8
7204:  MOVLB  9
....................      #endif     
....................    } 
7206:  BRA    716C
.................... } 
7208:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

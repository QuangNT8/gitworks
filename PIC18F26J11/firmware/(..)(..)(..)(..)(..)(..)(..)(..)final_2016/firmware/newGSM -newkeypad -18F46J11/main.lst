CCS PCH C Compiler, Version 4.140, 33034               22-Dec-16 20:20

               Filename:   D:\magnertic_card_prj\for chris\PIC18F46J11\firmware\newGSM -newkeypad -18F46J11\main.lst

               ROM used:   39298 bytes (60%)
                           Largest free fragment is 26226
               RAM used:   2706 (72%) at main() level
                           2801 (74%) worst case
               Stack:     9 worst case (4 in main + 5 for interrupts)

*
0000:  GOTO   6BFA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   4716
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   239E
006C:  BTFSS  FF0.3
006E:  GOTO   0078
0072:  BTFSC  FF0.0
0074:  GOTO   1CB6
0078:  BTFSS  F9D.5
007A:  GOTO   0084
007E:  BTFSC  F9E.5
0080:  GOTO   22CC
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... #define SIM900 
.................... #define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0736:  MOVLW  02
0738:  MOVLB  A
073A:  SUBWF  xB4,F
073C:  BNC   0756
073E:  MOVLW  0A
0740:  MOVWF  FEA
0742:  MOVLW  B4
0744:  MOVWF  FE9
0746:  MOVF   FEF,W
0748:  BZ    0756
074A:  BRA    0752
074C:  BRA    074E
074E:  BRA    0750
0750:  NOP   
0752:  DECFSZ FEF,F
0754:  BRA    074C
0756:  MOVLB  0
0758:  RETURN 0
*
1984:  MOVLW  0A
1986:  MOVWF  FEA
1988:  MOVLW  BC
198A:  MOVWF  FE9
198C:  MOVF   FEF,W
198E:  BZ    19AA
1990:  MOVLW  0A
1992:  MOVWF  01
1994:  CLRF   00
1996:  DECFSZ 00,F
1998:  BRA    1996
199A:  DECFSZ 01,F
199C:  BRA    1994
199E:  MOVLW  5F
19A0:  MOVWF  00
19A2:  DECFSZ 00,F
19A4:  BRA    19A2
19A6:  DECFSZ FEF,F
19A8:  BRA    1990
19AA:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
*
6528:  BTFSS  F9E.4
652A:  BRA    6528
652C:  MOVWF  FAE
652E:  RETURN 0
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
075A:  BCF    F94.0
075C:  BCF    F8B.0
075E:  MOVLW  08
0760:  MOVWF  01
0762:  BRA    0764
0764:  NOP   
0766:  BSF    01.7
0768:  BRA    078A
076A:  BCF    01.7
076C:  MOVLB  A
076E:  RRCF   xDF,F
0770:  MOVLB  0
0772:  BTFSC  FD8.0
0774:  BSF    F8B.0
0776:  BTFSS  FD8.0
0778:  BCF    F8B.0
077A:  BSF    01.6
077C:  BRA    078A
077E:  BCF    01.6
0780:  DECFSZ 01,F
0782:  BRA    076C
0784:  BRA    0786
0786:  NOP   
0788:  BSF    F8B.0
078A:  MOVLW  10
078C:  MOVWF  FE9
078E:  DECFSZ FE9,F
0790:  BRA    078E
0792:  BRA    0794
0794:  NOP   
0796:  BTFSC  01.7
0798:  BRA    076A
079A:  BTFSC  01.6
079C:  BRA    077E
079E:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
569E:  MOVLB  A
56A0:  MOVF   x92,F
56A2:  BNZ   56A8
56A4:  MOVF   x93,F
56A6:  BZ    572C
....................       if (*s1 != *s2) 
56A8:  MOVFF  A8E,FE9
56AC:  MOVFF  A8F,FEA
56B0:  MOVFF  FEF,A94
56B4:  MOVFF  A91,03
56B8:  MOVFF  A90,FE9
56BC:  MOVFF  A91,FEA
56C0:  MOVF   FEF,W
56C2:  SUBWF  x94,W
56C4:  BZ    56F4
....................          return((*s1 <*s2) ? -1: 1); 
56C6:  MOVFF  A8F,03
56CA:  MOVFF  A8E,FE9
56CE:  MOVFF  A8F,FEA
56D2:  MOVFF  FEF,A94
56D6:  MOVFF  A91,03
56DA:  MOVFF  A90,FE9
56DE:  MOVFF  A91,FEA
56E2:  MOVF   FEF,W
56E4:  SUBWF  x94,W
56E6:  BC    56EC
56E8:  MOVLW  FF
56EA:  BRA    56EE
56EC:  MOVLW  01
56EE:  MOVWF  01
56F0:  BRA    5730
....................       else if (*s1 == '\0') 
56F2:  BRA    570A
56F4:  MOVFF  A8F,03
56F8:  MOVFF  A8E,FE9
56FC:  MOVFF  A8F,FEA
5700:  MOVF   FEF,F
5702:  BNZ   570A
....................          return(0); 
5704:  MOVLW  00
5706:  MOVWF  01
5708:  BRA    5730
570A:  MOVFF  A8F,03
570E:  MOVF   x8E,W
5710:  INCF   x8E,F
5712:  BTFSC  FD8.2
5714:  INCF   x8F,F
5716:  MOVFF  A91,03
571A:  MOVF   x90,W
571C:  INCF   x90,F
571E:  BTFSC  FD8.2
5720:  INCF   x91,F
5722:  MOVF   x92,W
5724:  BTFSC  FD8.2
5726:  DECF   x93,F
5728:  DECF   x92,F
572A:  BRA    56A0
....................    return(0); 
572C:  MOVLW  00
572E:  MOVWF  01
.................... } 
5730:  MOVLB  0
5732:  RETURN 0
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
5EF8:  MOVFF  A97,A99
5EFC:  MOVFF  A96,A98
5F00:  MOVFF  A99,03
5F04:  MOVLB  A
5F06:  MOVFF  A98,FE9
5F0A:  MOVFF  A99,FEA
5F0E:  MOVF   FEF,F
5F10:  BZ    5F1E
5F12:  INCF   x98,F
5F14:  BTFSC  FD8.2
5F16:  INCF   x99,F
5F18:  MOVLB  0
5F1A:  BRA    5F00
5F1C:  MOVLB  A
....................    return(sc - s); 
5F1E:  MOVF   x96,W
5F20:  SUBWF  x98,W
5F22:  MOVWF  00
5F24:  MOVF   x97,W
5F26:  SUBWFB x99,W
5F28:  MOVWF  03
5F2A:  MOVFF  00,01
.................... } 
5F2E:  MOVLB  0
5F30:  RETURN 0
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
62FE:  MOVLB  A
6300:  CLRF   x93
....................    sign = 0; 
6302:  CLRF   x91
....................    base = 10; 
6304:  MOVLW  0A
6306:  MOVWF  x92
....................    result = 0; 
6308:  CLRF   x90
....................  
....................    if (!s) 
630A:  MOVF   x8E,W
630C:  IORWF  x8F,W
630E:  BNZ   6316
....................       return 0; 
6310:  MOVLW  00
6312:  MOVWF  01
6314:  BRA    649C
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
6316:  MOVF   x93,W
6318:  INCF   x93,F
631A:  CLRF   03
631C:  ADDWF  x8E,W
631E:  MOVWF  FE9
6320:  MOVF   x8F,W
6322:  ADDWFC 03,W
6324:  MOVWF  FEA
6326:  MOVFF  FEF,A94
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
632A:  MOVF   x94,W
632C:  SUBLW  2D
632E:  BNZ   634A
....................    { 
....................       sign = 1;         // Set the sign to negative 
6330:  MOVLW  01
6332:  MOVWF  x91
....................       c = s[index++]; 
6334:  MOVF   x93,W
6336:  INCF   x93,F
6338:  CLRF   03
633A:  ADDWF  x8E,W
633C:  MOVWF  FE9
633E:  MOVF   x8F,W
6340:  ADDWFC 03,W
6342:  MOVWF  FEA
6344:  MOVFF  FEF,A94
....................    } 
....................    else if (c == '+') 
6348:  BRA    6364
634A:  MOVF   x94,W
634C:  SUBLW  2B
634E:  BNZ   6364
....................    { 
....................       c = s[index++]; 
6350:  MOVF   x93,W
6352:  INCF   x93,F
6354:  CLRF   03
6356:  ADDWF  x8E,W
6358:  MOVWF  FE9
635A:  MOVF   x8F,W
635C:  ADDWFC 03,W
635E:  MOVWF  FEA
6360:  MOVFF  FEF,A94
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
6364:  MOVF   x94,W
6366:  SUBLW  2F
6368:  BTFSC  FD8.0
636A:  BRA    648C
636C:  MOVF   x94,W
636E:  SUBLW  39
6370:  BTFSS  FD8.0
6372:  BRA    648C
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
6374:  MOVF   x94,W
6376:  SUBLW  30
6378:  BNZ   63BC
637A:  CLRF   03
637C:  MOVF   x93,W
637E:  ADDWF  x8E,W
6380:  MOVWF  FE9
6382:  MOVF   x8F,W
6384:  ADDWFC 03,W
6386:  MOVWF  FEA
6388:  MOVF   FEF,W
638A:  SUBLW  78
638C:  BZ    63A2
638E:  CLRF   03
6390:  MOVF   x93,W
6392:  ADDWF  x8E,W
6394:  MOVWF  FE9
6396:  MOVF   x8F,W
6398:  ADDWFC 03,W
639A:  MOVWF  FEA
639C:  MOVF   FEF,W
639E:  SUBLW  58
63A0:  BNZ   63BC
....................       { 
....................          base = 16; 
63A2:  MOVLW  10
63A4:  MOVWF  x92
....................          index++; 
63A6:  INCF   x93,F
....................          c = s[index++]; 
63A8:  MOVF   x93,W
63AA:  INCF   x93,F
63AC:  CLRF   03
63AE:  ADDWF  x8E,W
63B0:  MOVWF  FE9
63B2:  MOVF   x8F,W
63B4:  ADDWFC 03,W
63B6:  MOVWF  FEA
63B8:  MOVFF  FEF,A94
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
63BC:  MOVF   x92,W
63BE:  SUBLW  0A
63C0:  BNZ   63FC
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
63C2:  MOVF   x94,W
63C4:  SUBLW  2F
63C6:  BC    63FA
63C8:  MOVF   x94,W
63CA:  SUBLW  39
63CC:  BNC   63FA
....................             result = 10*result + (c - '0'); 
63CE:  MOVLW  0A
63D0:  MOVWF  x95
63D2:  MOVFF  A90,A96
63D6:  MOVLB  0
63D8:  BRA    62AE
63DA:  MOVLW  30
63DC:  MOVLB  A
63DE:  SUBWF  x94,W
63E0:  ADDWF  01,W
63E2:  MOVWF  x90
....................             c = s[index++]; 
63E4:  MOVF   x93,W
63E6:  INCF   x93,F
63E8:  CLRF   03
63EA:  ADDWF  x8E,W
63EC:  MOVWF  FE9
63EE:  MOVF   x8F,W
63F0:  ADDWFC 03,W
63F2:  MOVWF  FEA
63F4:  MOVFF  FEF,A94
....................          } 
63F8:  BRA    63C2
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
63FA:  BRA    648C
63FC:  MOVF   x92,W
63FE:  SUBLW  10
6400:  BNZ   648C
....................       { 
....................          c = toupper(c); 
6402:  MOVF   x94,W
6404:  SUBLW  60
6406:  BC    6414
6408:  MOVF   x94,W
640A:  SUBLW  7A
640C:  BNC   6414
640E:  MOVF   x94,W
6410:  ANDLW  DF
6412:  BRA    6416
6414:  MOVF   x94,W
6416:  MOVWF  x94
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
6418:  MOVF   x94,W
641A:  SUBLW  2F
641C:  BC    6424
641E:  MOVF   x94,W
6420:  SUBLW  39
6422:  BC    6430
6424:  MOVF   x94,W
6426:  SUBLW  40
6428:  BC    648C
642A:  MOVF   x94,W
642C:  SUBLW  46
642E:  BNC   648C
....................             if (c >= '0' && c <= '9') 
6430:  MOVF   x94,W
6432:  SUBLW  2F
6434:  BC    644E
6436:  MOVF   x94,W
6438:  SUBLW  39
643A:  BNC   644E
....................                result = (result << 4) + (c - '0'); 
643C:  SWAPF  x90,W
643E:  MOVWF  x95
6440:  MOVLW  F0
6442:  ANDWF  x95,F
6444:  MOVLW  30
6446:  SUBWF  x94,W
6448:  ADDWF  x95,W
644A:  MOVWF  x90
....................             else 
644C:  BRA    6460
....................                result = (result << 4) + (c - 'A' + 10); 
644E:  SWAPF  x90,W
6450:  MOVWF  x95
6452:  MOVLW  F0
6454:  ANDWF  x95,F
6456:  MOVLW  41
6458:  SUBWF  x94,W
645A:  ADDLW  0A
645C:  ADDWF  x95,W
645E:  MOVWF  x90
....................  
....................             c = s[index++]; 
6460:  MOVF   x93,W
6462:  INCF   x93,F
6464:  CLRF   03
6466:  ADDWF  x8E,W
6468:  MOVWF  FE9
646A:  MOVF   x8F,W
646C:  ADDWFC 03,W
646E:  MOVWF  FEA
6470:  MOVFF  FEF,A94
....................             c = toupper(c); 
6474:  MOVF   x94,W
6476:  SUBLW  60
6478:  BC    6486
647A:  MOVF   x94,W
647C:  SUBLW  7A
647E:  BNC   6486
6480:  MOVF   x94,W
6482:  ANDLW  DF
6484:  BRA    6488
6486:  MOVF   x94,W
6488:  MOVWF  x94
....................          } 
648A:  BRA    6418
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
648C:  DECFSZ x91,W
648E:  BRA    6498
6490:  MOVF   x92,W
6492:  SUBLW  0A
6494:  BNZ   6498
....................        result = -result; 
6496:  NEGF   x90
....................  
....................    return(result); 
6498:  MOVFF  A90,01
.................... } 
649C:  MOVLB  0
649E:  GOTO   8C8A (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
*
60E2:  MOVLB  A
60E4:  CLRF   x98
60E6:  CLRF   x97
60E8:  CLRF   x96
60EA:  MOVLW  01
60EC:  MOVWF  x95
60EE:  CLRF   x9A
60F0:  CLRF   x9B
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
60F2:  BTFSS  x91.7
60F4:  BRA    6128
....................          sign=1;        // Check for negative number 
60F6:  MOVLW  01
60F8:  MOVWF  x9A
....................          num*=-1; 
60FA:  MOVFF  A91,AA0
60FE:  MOVFF  A90,A9F
6102:  MOVFF  A8F,A9E
6106:  MOVFF  A8E,A9D
610A:  SETF   xA4
610C:  SETF   xA3
610E:  SETF   xA2
6110:  SETF   xA1
6112:  MOVLB  0
6114:  BRA    5F9A
6116:  MOVFF  03,A91
611A:  MOVFF  02,A90
611E:  MOVFF  01,A8F
6122:  MOVFF  00,A8E
6126:  MOVLB  A
....................      } 
....................  
....................      while(temp>0) { 
6128:  MOVF   x95,F
612A:  BNZ   6138
612C:  MOVF   x96,F
612E:  BNZ   6138
6130:  MOVF   x97,F
6132:  BNZ   6138
6134:  MOVF   x98,F
6136:  BZ    6212
....................          temp=(num/base); 
6138:  BCF    FD8.1
613A:  MOVFF  A91,AA8
613E:  MOVFF  A90,AA7
6142:  MOVFF  A8F,AA6
6146:  MOVFF  A8E,AA5
614A:  CLRF   xAC
614C:  CLRF   xAB
614E:  CLRF   xAA
6150:  MOVFF  A92,AA9
6154:  MOVLB  0
6156:  RCALL  5FF8
6158:  MOVFF  03,A98
615C:  MOVFF  02,A97
6160:  MOVFF  01,A96
6164:  MOVFF  00,A95
....................          s[cnt]=(num%base)+'0';    // Conversion 
6168:  CLRF   03
616A:  MOVLB  A
616C:  MOVF   x9B,W
616E:  ADDWF  x93,W
6170:  MOVWF  01
6172:  MOVF   x94,W
6174:  ADDWFC 03,F
6176:  MOVFF  01,A9D
617A:  MOVFF  03,A9E
617E:  MOVFF  FEA,AA0
6182:  MOVFF  FE9,A9F
6186:  BSF    FD8.1
6188:  MOVLW  0A
618A:  MOVWF  FEA
618C:  MOVLW  A1
618E:  MOVWF  FE9
6190:  MOVFF  A91,AA8
6194:  MOVFF  A90,AA7
6198:  MOVFF  A8F,AA6
619C:  MOVFF  A8E,AA5
61A0:  CLRF   xAC
61A2:  CLRF   xAB
61A4:  CLRF   xAA
61A6:  MOVFF  A92,AA9
61AA:  MOVLB  0
61AC:  RCALL  5FF8
61AE:  MOVFF  AA0,FEA
61B2:  MOVFF  A9F,FE9
61B6:  MOVLW  30
61B8:  MOVLB  A
61BA:  ADDWF  xA1,W
61BC:  MOVWF  00
61BE:  MOVLW  00
61C0:  ADDWFC xA2,W
61C2:  MOVLW  00
61C4:  ADDWFC xA3,W
61C6:  MOVLW  00
61C8:  ADDWFC xA4,W
61CA:  MOVFF  A9E,FEA
61CE:  MOVFF  A9D,FE9
61D2:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
61D6:  CLRF   03
61D8:  MOVF   x9B,W
61DA:  ADDWF  x93,W
61DC:  MOVWF  FE9
61DE:  MOVF   x94,W
61E0:  ADDWFC 03,W
61E2:  MOVWF  FEA
61E4:  MOVF   FEF,W
61E6:  SUBLW  39
61E8:  BC    61FE
....................             s[cnt]+=0x7; 
61EA:  CLRF   03
61EC:  MOVF   x9B,W
61EE:  ADDWF  x93,W
61F0:  MOVWF  FE9
61F2:  MOVF   x94,W
61F4:  ADDWFC 03,W
61F6:  MOVWF  FEA
61F8:  MOVLW  07
61FA:  ADDWF  FEF,W
61FC:  MOVWF  FEF
....................  
....................          cnt++; 
61FE:  INCF   x9B,F
....................          num=temp; 
6200:  MOVFF  A98,A91
6204:  MOVFF  A97,A90
6208:  MOVFF  A96,A8F
620C:  MOVFF  A95,A8E
....................      } 
6210:  BRA    6128
....................  
....................      if(sign==1) { 
6212:  DECFSZ x9A,W
6214:  BRA    622A
....................          s[cnt]=0x2D;      // Negative sign 
6216:  CLRF   03
6218:  MOVF   x9B,W
621A:  ADDWF  x93,W
621C:  MOVWF  FE9
621E:  MOVF   x94,W
6220:  ADDWFC 03,W
6222:  MOVWF  FEA
6224:  MOVLW  2D
6226:  MOVWF  FEF
....................          cnt++; 
6228:  INCF   x9B,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
622A:  CLRF   x99
622C:  BCF    FD8.0
622E:  RRCF   x9B,W
6230:  SUBWF  x99,W
6232:  BC    6292
....................  
....................          c=s[i]; 
6234:  CLRF   03
6236:  MOVF   x99,W
6238:  ADDWF  x93,W
623A:  MOVWF  FE9
623C:  MOVF   x94,W
623E:  ADDWFC 03,W
6240:  MOVWF  FEA
6242:  MOVFF  FEF,A9C
....................          s[i]=s[cnt-i-1];        // Reverse the number 
6246:  CLRF   03
6248:  MOVF   x99,W
624A:  ADDWF  x93,W
624C:  MOVWF  01
624E:  MOVF   x94,W
6250:  ADDWFC 03,F
6252:  MOVFF  03,A9E
6256:  MOVF   x99,W
6258:  SUBWF  x9B,W
625A:  ADDLW  FF
625C:  CLRF   03
625E:  ADDWF  x93,W
6260:  MOVWF  FE9
6262:  MOVF   x94,W
6264:  ADDWFC 03,W
6266:  MOVWF  FEA
6268:  MOVFF  FEF,A9F
626C:  MOVFF  A9E,FEA
6270:  MOVFF  01,FE9
6274:  MOVFF  A9F,FEF
....................          s[cnt-i-1]=c; 
6278:  MOVF   x99,W
627A:  SUBWF  x9B,W
627C:  ADDLW  FF
627E:  CLRF   03
6280:  ADDWF  x93,W
6282:  MOVWF  FE9
6284:  MOVF   x94,W
6286:  ADDWFC 03,W
6288:  MOVWF  FEA
628A:  MOVFF  A9C,FEF
....................      } 
628E:  INCF   x99,F
6290:  BRA    622C
....................      s[cnt]='\0';     // End the string 
6292:  CLRF   03
6294:  MOVF   x9B,W
6296:  ADDWF  x93,W
6298:  MOVWF  FE9
629A:  MOVF   x94,W
629C:  ADDWFC 03,W
629E:  MOVWF  FEA
62A0:  CLRF   FEF
....................      return s; 
62A2:  MOVFF  A93,01
62A6:  MOVFF  A94,02
.................... } 
62AA:  MOVLB  0
62AC:  RETURN 0
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
37AA:  MOVLW  08
37AC:  MOVWF  01
37AE:  MOVLW  0A
37B0:  MOVWF  00
37B2:  DECFSZ 00,F
37B4:  BRA    37B2
37B6:  BCF    F8B.3
37B8:  BCF    F94.3
37BA:  MOVLW  0B
37BC:  MOVWF  00
37BE:  DECFSZ 00,F
37C0:  BRA    37BE
37C2:  MOVLB  A
37C4:  RLCF   xCE,F
37C6:  BCF    F8B.4
37C8:  BTFSC  FD8.0
37CA:  BSF    F94.4
37CC:  BTFSS  FD8.0
37CE:  BCF    F94.4
37D0:  BSF    F94.3
37D2:  BTFSS  F82.3
37D4:  BRA    37D2
37D6:  DECFSZ 01,F
37D8:  BRA    37DC
37DA:  BRA    37E0
37DC:  MOVLB  0
37DE:  BRA    37AE
37E0:  MOVLW  0A
37E2:  MOVWF  00
37E4:  DECFSZ 00,F
37E6:  BRA    37E4
37E8:  BCF    F8B.3
37EA:  BCF    F94.3
37EC:  NOP   
37EE:  BSF    F94.4
37F0:  MOVLW  0B
37F2:  MOVWF  00
37F4:  DECFSZ 00,F
37F6:  BRA    37F4
37F8:  MOVLW  0B
37FA:  MOVWF  00
37FC:  DECFSZ 00,F
37FE:  BRA    37FC
3800:  BSF    F94.3
3802:  BTFSS  F82.3
3804:  BRA    3802
3806:  CLRF   01
3808:  MOVLW  0B
380A:  MOVWF  00
380C:  DECFSZ 00,F
380E:  BRA    380C
3810:  BTFSC  F82.4
3812:  BSF    01.0
3814:  BCF    F8B.3
3816:  BCF    F94.3
3818:  BCF    F8B.4
381A:  BCF    F94.4
381C:  MOVLB  0
381E:  RETURN 0
3820:  MOVLW  08
3822:  MOVLB  A
3824:  MOVWF  xC3
3826:  MOVFF  00,AC4
382A:  BSF    F94.4
382C:  MOVLW  0B
382E:  MOVWF  00
3830:  DECFSZ 00,F
3832:  BRA    3830
3834:  BSF    F94.3
3836:  BTFSS  F82.3
3838:  BRA    3836
383A:  BTFSC  F82.4
383C:  BSF    FD8.0
383E:  BTFSS  F82.4
3840:  BCF    FD8.0
3842:  RLCF   01,F
3844:  MOVLW  0A
3846:  MOVWF  00
3848:  DECFSZ 00,F
384A:  BRA    3848
384C:  BCF    F94.3
384E:  BCF    F8B.3
3850:  DECFSZ xC3,F
3852:  BRA    382A
3854:  BSF    F94.4
3856:  MOVLW  0B
3858:  MOVWF  00
385A:  DECFSZ 00,F
385C:  BRA    385A
385E:  BCF    F8B.4
3860:  MOVF   xC4,W
3862:  BTFSS  FD8.2
3864:  BCF    F94.4
3866:  NOP   
3868:  BSF    F94.3
386A:  BTFSS  F82.3
386C:  BRA    386A
386E:  MOVLW  0A
3870:  MOVWF  00
3872:  DECFSZ 00,F
3874:  BRA    3872
3876:  BCF    F8B.3
3878:  BCF    F94.3
387A:  MOVLW  0B
387C:  MOVWF  00
387E:  DECFSZ 00,F
3880:  BRA    387E
3882:  BCF    F8B.4
3884:  BCF    F94.4
3886:  MOVLB  0
3888:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... //#define EEPROM_SIZE   65535 
.................... #define EEPROM_SIZE_key    65535 
.................... #define EEPROM_SIZE        43590 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5060:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
5062:  BSF    F94.4
....................    port_b_pullups(0xff); 
5064:  BCF    FF1.7
.................... } 
5066:  GOTO   6D9A (RETURN)
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
3E78:  BSF    F94.4
3E7A:  MOVLW  0A
3E7C:  MOVWF  00
3E7E:  DECFSZ 00,F
3E80:  BRA    3E7E
3E82:  BSF    F94.3
3E84:  MOVLW  0B
3E86:  MOVWF  00
3E88:  DECFSZ 00,F
3E8A:  BRA    3E88
3E8C:  BCF    F8B.4
3E8E:  BCF    F94.4
3E90:  MOVLW  0A
3E92:  MOVWF  00
3E94:  DECFSZ 00,F
3E96:  BRA    3E94
3E98:  BCF    F8B.3
3E9A:  BCF    F94.3
....................    i2c_write(0xa0); 
3E9C:  MOVLW  A0
3E9E:  MOVLB  A
3EA0:  MOVWF  xCE
3EA2:  MOVLB  0
3EA4:  RCALL  37AA
....................    i2c_write(address>>8); 
3EA6:  MOVFF  AC8,ACC
3EAA:  MOVLB  A
3EAC:  CLRF   xCD
3EAE:  MOVFF  AC8,ACE
3EB2:  MOVLB  0
3EB4:  RCALL  37AA
....................    i2c_write(address); 
3EB6:  MOVFF  AC7,ACE
3EBA:  RCALL  37AA
....................    i2c_write(data); 
3EBC:  MOVFF  AC9,ACE
3EC0:  RCALL  37AA
....................    i2c_stop(); 
3EC2:  BCF    F94.4
3EC4:  NOP   
3EC6:  BSF    F94.3
3EC8:  BTFSS  F82.3
3ECA:  BRA    3EC8
3ECC:  MOVLW  0A
3ECE:  MOVWF  00
3ED0:  DECFSZ 00,F
3ED2:  BRA    3ED0
3ED4:  BRA    3ED6
3ED6:  NOP   
3ED8:  BSF    F94.4
3EDA:  MOVLW  0A
3EDC:  MOVWF  00
3EDE:  DECFSZ 00,F
3EE0:  BRA    3EDE
....................    i2c_start(); 
3EE2:  BSF    F94.4
3EE4:  MOVLW  0A
3EE6:  MOVWF  00
3EE8:  DECFSZ 00,F
3EEA:  BRA    3EE8
3EEC:  BSF    F94.3
3EEE:  MOVLW  0B
3EF0:  MOVWF  00
3EF2:  DECFSZ 00,F
3EF4:  BRA    3EF2
3EF6:  BCF    F8B.4
3EF8:  BCF    F94.4
3EFA:  MOVLW  0A
3EFC:  MOVWF  00
3EFE:  DECFSZ 00,F
3F00:  BRA    3EFE
3F02:  BCF    F8B.3
3F04:  BCF    F94.3
....................    status=i2c_write(0xa0); 
3F06:  MOVLW  A0
3F08:  MOVLB  A
3F0A:  MOVWF  xCE
3F0C:  MOVLB  0
3F0E:  RCALL  37AA
3F10:  MOVF   01,W
3F12:  MOVLB  A
3F14:  BCF    xCA.0
3F16:  BTFSC  01.0
3F18:  BSF    xCA.0
....................    while(status==1) 
....................    { 
3F1A:  BTFSS  xCA.0
3F1C:  BRA    3F5A
....................       i2c_start(); 
3F1E:  BSF    F94.4
3F20:  MOVLW  0A
3F22:  MOVWF  00
3F24:  DECFSZ 00,F
3F26:  BRA    3F24
3F28:  BSF    F94.3
3F2A:  MOVLW  0B
3F2C:  MOVWF  00
3F2E:  DECFSZ 00,F
3F30:  BRA    3F2E
3F32:  BTFSS  F82.3
3F34:  BRA    3F32
3F36:  BCF    F8B.4
3F38:  BCF    F94.4
3F3A:  MOVLW  0A
3F3C:  MOVWF  00
3F3E:  DECFSZ 00,F
3F40:  BRA    3F3E
3F42:  BCF    F8B.3
3F44:  BCF    F94.3
....................       status=i2c_write(0xa0); 
3F46:  MOVLW  A0
3F48:  MOVWF  xCE
3F4A:  MOVLB  0
3F4C:  RCALL  37AA
3F4E:  MOVF   01,W
3F50:  MOVLB  A
3F52:  BCF    xCA.0
3F54:  BTFSC  01.0
3F56:  BSF    xCA.0
....................    } 
3F58:  BRA    3F1A
....................    i2c_stop(); 
3F5A:  BCF    F94.4
3F5C:  NOP   
3F5E:  BSF    F94.3
3F60:  BTFSS  F82.3
3F62:  BRA    3F60
3F64:  MOVLW  0A
3F66:  MOVWF  00
3F68:  DECFSZ 00,F
3F6A:  BRA    3F68
3F6C:  BRA    3F6E
3F6E:  NOP   
3F70:  BSF    F94.4
3F72:  MOVLW  0A
3F74:  MOVWF  00
3F76:  DECFSZ 00,F
3F78:  BRA    3F76
.................... } 
3F7A:  MOVLB  0
3F7C:  RETURN 0
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
3954:  BSF    F94.4
3956:  MOVLW  0A
3958:  MOVWF  00
395A:  DECFSZ 00,F
395C:  BRA    395A
395E:  BSF    F94.3
3960:  MOVLW  0B
3962:  MOVWF  00
3964:  DECFSZ 00,F
3966:  BRA    3964
3968:  BCF    F8B.4
396A:  BCF    F94.4
396C:  MOVLW  0A
396E:  MOVWF  00
3970:  DECFSZ 00,F
3972:  BRA    3970
3974:  BCF    F8B.3
3976:  BCF    F94.3
....................    i2c_write(0xa0); 
3978:  MOVLW  A0
397A:  MOVLB  A
397C:  MOVWF  xCE
397E:  MOVLB  0
3980:  RCALL  37AA
....................    i2c_write(address>>8); 
3982:  MOVFF  AC0,AC2
3986:  MOVLB  A
3988:  CLRF   xC3
398A:  MOVFF  AC0,ACE
398E:  MOVLB  0
3990:  RCALL  37AA
....................    i2c_write(address); 
3992:  MOVFF  ABF,ACE
3996:  RCALL  37AA
....................    i2c_start(); 
3998:  BSF    F94.4
399A:  MOVLW  0A
399C:  MOVWF  00
399E:  DECFSZ 00,F
39A0:  BRA    399E
39A2:  BSF    F94.3
39A4:  MOVLW  0B
39A6:  MOVWF  00
39A8:  DECFSZ 00,F
39AA:  BRA    39A8
39AC:  BTFSS  F82.3
39AE:  BRA    39AC
39B0:  BCF    F8B.4
39B2:  BCF    F94.4
39B4:  MOVLW  0A
39B6:  MOVWF  00
39B8:  DECFSZ 00,F
39BA:  BRA    39B8
39BC:  BCF    F8B.3
39BE:  BCF    F94.3
....................    i2c_write(0xa1); 
39C0:  MOVLW  A1
39C2:  MOVLB  A
39C4:  MOVWF  xCE
39C6:  MOVLB  0
39C8:  RCALL  37AA
....................    data=i2c_read(0); 
39CA:  CLRF   00
39CC:  RCALL  3820
39CE:  MOVFF  01,AC1
....................    i2c_stop(); 
39D2:  BCF    F94.4
39D4:  NOP   
39D6:  BSF    F94.3
39D8:  BTFSS  F82.3
39DA:  BRA    39D8
39DC:  MOVLW  0A
39DE:  MOVWF  00
39E0:  DECFSZ 00,F
39E2:  BRA    39E0
39E4:  BRA    39E6
39E6:  NOP   
39E8:  BSF    F94.4
39EA:  MOVLW  0A
39EC:  MOVWF  00
39EE:  DECFSZ 00,F
39F0:  BRA    39EE
....................    return(data); 
39F2:  MOVLB  A
39F4:  MOVFF  AC1,01
.................... } 
39F8:  MOVLB  0
39FA:  RETURN 0
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
64A2:  MOVLB  A
64A4:  MOVF   x92,W
64A6:  ADDWF  x90,W
64A8:  MOVWF  x98
64AA:  MOVF   x93,W
64AC:  ADDWFC x91,W
64AE:  MOVWF  x99
64B0:  SUBLW  A9
64B2:  BC    64C4
64B4:  XORLW  FF
64B6:  BNZ   64BE
64B8:  MOVF   x98,W
64BA:  SUBLW  45
64BC:  BC    64C4
64BE:  MOVLW  00
64C0:  MOVWF  01
64C2:  BRA    6522
....................    for(i=0;i<len;i++) 
64C4:  CLRF   x97
64C6:  CLRF   x96
64C8:  MOVF   x97,W
64CA:  SUBWF  x93,W
64CC:  BNC   6522
64CE:  BNZ   64D6
64D0:  MOVF   x92,W
64D2:  SUBWF  x96,W
64D4:  BC    6522
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
64D6:  MOVF   x94,W
64D8:  ADDWF  x96,W
64DA:  MOVWF  01
64DC:  MOVF   x95,W
64DE:  ADDWFC x97,W
64E0:  MOVWF  03
64E2:  MOVFF  01,A98
64E6:  MOVWF  x99
64E8:  MOVF   x96,W
64EA:  ADDWF  x90,W
64EC:  MOVWF  x9A
64EE:  MOVF   x97,W
64F0:  ADDWFC x91,W
64F2:  MOVWF  x9B
64F4:  CLRF   19
64F6:  BTFSC  FF2.7
64F8:  BSF    19.7
64FA:  BCF    FF2.7
64FC:  MOVWF  xC0
64FE:  MOVFF  A9A,ABF
6502:  MOVLB  0
6504:  CALL   3954
6508:  BTFSC  19.7
650A:  BSF    FF2.7
650C:  MOVFF  A99,FEA
6510:  MOVFF  A98,FE9
6514:  MOVFF  01,FEF
....................    } 
6518:  MOVLB  A
651A:  INCF   x96,F
651C:  BTFSC  FD8.2
651E:  INCF   x97,F
6520:  BRA    64C8
....................     
.................... } 
6522:  MOVLB  0
6524:  GOTO   8F2A (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_mobile_num0        65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_two_number        149 
.................... #define kindofKB                 126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards                350   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
3A6E:  MOVLB  A
3A70:  CLRF   xC8
3A72:  MOVF   xC5,W
3A74:  SUBWF  xC8,W
3A76:  BC    3A8C
....................    { 
....................       inputdat[i]=0; 
3A78:  CLRF   03
3A7A:  MOVF   xC8,W
3A7C:  ADDWF  xC6,W
3A7E:  MOVWF  FE9
3A80:  MOVF   xC7,W
3A82:  ADDWFC 03,W
3A84:  MOVWF  FEA
3A86:  CLRF   FEF
....................    } 
3A88:  INCF   xC8,F
3A8A:  BRA    3A72
.................... } 
3A8C:  MOVLB  0
3A8E:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_write(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
50C4:  MOVLB  A
50C6:  CLRF   xA7
50C8:  MOVF   xA4,W
50CA:  SUBWF  xA7,W
50CC:  BC    5112
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
50CE:  MOVF   xA7,W
50D0:  ADDWF  xA3,W
50D2:  MOVWF  xA8
50D4:  CLRF   03
50D6:  MOVF   xA7,W
50D8:  ADDWF  xA5,W
50DA:  MOVWF  FE9
50DC:  MOVF   xA6,W
50DE:  ADDWFC 03,W
50E0:  MOVWF  FEA
50E2:  MOVFF  FEF,AA9
50E6:  CLRF   19
50E8:  BTFSC  FF2.7
50EA:  BSF    19.7
50EC:  BCF    FF2.7
50EE:  CLRF   xC8
50F0:  MOVFF  AA8,AC7
50F4:  MOVFF  AA9,AC9
50F8:  MOVLB  0
50FA:  CALL   3E78
50FE:  BTFSC  19.7
5100:  BSF    FF2.7
....................       delay_us(10); 
5102:  MOVLW  1A
5104:  MOVWF  00
5106:  DECFSZ 00,F
5108:  BRA    5106
510A:  NOP   
....................    } 
510C:  MOVLB  A
510E:  INCF   xA7,F
5110:  BRA    50C8
.................... } 
5112:  MOVLB  0
5114:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
506A:  MOVLB  A
506C:  CLRF   x92
506E:  MOVF   x8F,W
5070:  SUBWF  x92,W
5072:  BC    50C0
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
5074:  CLRF   03
5076:  MOVF   x92,W
5078:  ADDWF  x90,W
507A:  MOVWF  01
507C:  MOVF   x91,W
507E:  ADDWFC 03,F
5080:  MOVFF  01,A93
5084:  MOVFF  03,A94
5088:  MOVF   x92,W
508A:  ADDWF  x8E,W
508C:  MOVWF  x95
508E:  CLRF   19
5090:  BTFSC  FF2.7
5092:  BSF    19.7
5094:  BCF    FF2.7
5096:  CLRF   xC0
5098:  MOVWF  xBF
509A:  MOVLB  0
509C:  CALL   3954
50A0:  BTFSC  19.7
50A2:  BSF    FF2.7
50A4:  MOVFF  A94,FEA
50A8:  MOVFF  A93,FE9
50AC:  MOVFF  01,FEF
....................       delay_us(10); 
50B0:  MOVLW  1A
50B2:  MOVWF  00
50B4:  DECFSZ 00,F
50B6:  BRA    50B4
50B8:  NOP   
....................    } 
50BA:  MOVLB  A
50BC:  INCF   x92,F
50BE:  BRA    506E
.................... } 
50C0:  MOVLB  0
50C2:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
529A:  MOVLB  A
529C:  CLRF   x92
529E:  CLRF   x91
52A0:  CLRF   x90
52A2:  CLRF   x8F
52A4:  CLRF   x96
52A6:  CLRF   x95
52A8:  CLRF   x94
52AA:  CLRF   x93
52AC:  CLRF   x9A
52AE:  CLRF   x99
52B0:  CLRF   x98
52B2:  CLRF   x97
52B4:  CLRF   x9E
52B6:  CLRF   x9D
52B8:  CLRF   x9C
52BA:  CLRF   x9B
52BC:  CLRF   xA2
52BE:  CLRF   xA1
52C0:  CLRF   xA0
52C2:  CLRF   x9F
52C4:  CLRF   19
52C6:  BTFSC  FF2.7
52C8:  BSF    19.7
52CA:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
52CC:  CLRF   xC0
52CE:  MOVFF  A8E,ABF
52D2:  MOVLB  0
52D4:  CALL   3954
52D8:  BTFSC  19.7
52DA:  BSF    FF2.7
52DC:  MOVLB  A
52DE:  MOVFF  01,A93
52E2:  CLRF   x94
52E4:  CLRF   x95
52E6:  CLRF   x96
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
52E8:  MOVLW  01
52EA:  ADDWF  x8E,W
52EC:  MOVWF  xA3
52EE:  CLRF   19
52F0:  BTFSC  FF2.7
52F2:  BSF    19.7
52F4:  BCF    FF2.7
52F6:  CLRF   xC0
52F8:  MOVWF  xBF
52FA:  MOVLB  0
52FC:  CALL   3954
5300:  BTFSC  19.7
5302:  BSF    FF2.7
5304:  MOVLB  A
5306:  CLRF   x9A
5308:  CLRF   x99
530A:  CLRF   x98
530C:  MOVFF  01,A97
....................    temp2<<=8; 
5310:  MOVFF  A99,A9A
5314:  MOVFF  A98,A99
5318:  MOVFF  A97,A98
531C:  CLRF   x97
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
531E:  MOVLW  02
5320:  ADDWF  x8E,W
5322:  MOVWF  xA3
5324:  CLRF   19
5326:  BTFSC  FF2.7
5328:  BSF    19.7
532A:  BCF    FF2.7
532C:  CLRF   xC0
532E:  MOVWF  xBF
5330:  MOVLB  0
5332:  CALL   3954
5336:  BTFSC  19.7
5338:  BSF    FF2.7
533A:  MOVLB  A
533C:  CLRF   x9E
533E:  CLRF   x9D
5340:  CLRF   x9C
5342:  MOVFF  01,A9B
....................    temp3<<=16; 
5346:  MOVFF  A9C,A9E
534A:  MOVFF  A9B,A9D
534E:  CLRF   x9B
5350:  CLRF   x9C
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
5352:  MOVLW  03
5354:  ADDWF  x8E,W
5356:  MOVWF  xA3
5358:  CLRF   19
535A:  BTFSC  FF2.7
535C:  BSF    19.7
535E:  BCF    FF2.7
5360:  CLRF   xC0
5362:  MOVWF  xBF
5364:  MOVLB  0
5366:  CALL   3954
536A:  BTFSC  19.7
536C:  BSF    FF2.7
536E:  MOVLB  A
5370:  CLRF   xA2
5372:  CLRF   xA1
5374:  CLRF   xA0
5376:  MOVFF  01,A9F
....................    temp4<<=24; 
537A:  MOVFF  A9F,AA2
537E:  CLRF   x9F
5380:  CLRF   xA0
5382:  CLRF   xA1
....................    buffer = temp4|temp3|temp2|temp1; 
5384:  MOVF   x9F,W
5386:  IORWF  x9B,W
5388:  MOVWF  xA3
538A:  MOVF   xA0,W
538C:  IORWF  x9C,W
538E:  MOVWF  xA4
5390:  MOVF   xA1,W
5392:  IORWF  x9D,W
5394:  MOVWF  xA5
5396:  MOVF   xA2,W
5398:  IORWF  x9E,W
539A:  MOVWF  xA6
539C:  MOVF   x97,W
539E:  IORWF  xA3,F
53A0:  MOVF   x98,W
53A2:  IORWF  xA4,F
53A4:  MOVF   x99,W
53A6:  IORWF  xA5,F
53A8:  MOVF   x9A,W
53AA:  IORWF  xA6,F
53AC:  MOVF   xA3,W
53AE:  IORWF  x93,W
53B0:  MOVWF  x8F
53B2:  MOVF   xA4,W
53B4:  IORWF  x94,W
53B6:  MOVWF  x90
53B8:  MOVF   xA5,W
53BA:  IORWF  x95,W
53BC:  MOVWF  x91
53BE:  MOVF   xA6,W
53C0:  IORWF  x96,W
53C2:  MOVWF  x92
....................    return(buffer); 
53C4:  MOVFF  A8F,00
53C8:  MOVFF  A90,01
53CC:  MOVFF  A91,02
53D0:  MOVFF  A92,03
.................... } 
53D4:  MOVLB  0
53D6:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3F7E:  MOVLB  A
3F80:  CLRF   xC1
3F82:  CLRF   xC0
3F84:  CLRF   xBF
3F86:  CLRF   xBE
3F88:  CLRF   xC2
3F8A:  CLRF   xC3
3F8C:  CLRF   xC4
3F8E:  CLRF   xC5
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3F90:  MOVFF  ABC,AC1
3F94:  MOVFF  ABB,AC0
3F98:  MOVFF  ABA,ABF
3F9C:  MOVFF  AB9,ABE
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3FA0:  MOVFF  ABE,AC2
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3FA4:  MOVFF  ABF,AC3
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3FA8:  MOVFF  AC0,AC4
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3FAC:  MOVFF  AC1,AC5
....................    write_ext_eeprom((addr+0),temp1); 
3FB0:  CLRF   xC8
3FB2:  MOVFF  ABD,AC7
3FB6:  MOVFF  AC2,AC9
3FBA:  MOVLB  0
3FBC:  RCALL  3E78
....................    write_ext_eeprom((addr+1),temp2); 
3FBE:  MOVLW  01
3FC0:  MOVLB  A
3FC2:  ADDWF  xBD,W
3FC4:  MOVWF  xC6
3FC6:  CLRF   xC8
3FC8:  MOVWF  xC7
3FCA:  MOVFF  AC3,AC9
3FCE:  MOVLB  0
3FD0:  RCALL  3E78
....................    write_ext_eeprom((addr+2),temp3); 
3FD2:  MOVLW  02
3FD4:  MOVLB  A
3FD6:  ADDWF  xBD,W
3FD8:  MOVWF  xC6
3FDA:  CLRF   xC8
3FDC:  MOVWF  xC7
3FDE:  MOVFF  AC4,AC9
3FE2:  MOVLB  0
3FE4:  RCALL  3E78
....................    write_ext_eeprom((addr+3),temp4); 
3FE6:  MOVLW  03
3FE8:  MOVLB  A
3FEA:  ADDWF  xBD,W
3FEC:  MOVWF  xC6
3FEE:  CLRF   xC8
3FF0:  MOVWF  xC7
3FF2:  MOVFF  AC5,AC9
3FF6:  MOVLB  0
3FF8:  RCALL  3E78
.................... } 
3FFA:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
45E4:  MOVLB  A
45E6:  CLRF   xB9
45E8:  CLRF   xB8
45EA:  CLRF   xBA
45EC:  CLRF   xBB
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
45EE:  MOVFF  AB7,AB9
45F2:  MOVFF  AB6,AB8
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
45F6:  MOVFF  AB8,ABA
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
45FA:  MOVF   xB9,W
45FC:  MOVWF  xBB
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
45FE:  CLRF   xC8
4600:  MOVLW  28
4602:  MOVWF  xC7
4604:  MOVFF  ABA,AC9
4608:  MOVLB  0
460A:  RCALL  3E78
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
460C:  MOVLB  A
460E:  CLRF   xC8
4610:  MOVLW  29
4612:  MOVWF  xC7
4614:  MOVFF  ABB,AC9
4618:  MOVLB  0
461A:  RCALL  3E78
.................... } 
461C:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
39FC:  MOVLB  A
39FE:  CLRF   xBA
3A00:  CLRF   xB9
3A02:  CLRF   xBC
3A04:  CLRF   xBB
3A06:  CLRF   xBE
3A08:  CLRF   xBD
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
3A0A:  CLRF   xC0
3A0C:  MOVLW  28
3A0E:  MOVWF  xBF
3A10:  MOVLB  0
3A12:  RCALL  3954
3A14:  MOVLB  A
3A16:  MOVFF  01,ABB
3A1A:  CLRF   xBC
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3A1C:  CLRF   xC0
3A1E:  MOVLW  29
3A20:  MOVWF  xBF
3A22:  MOVLB  0
3A24:  RCALL  3954
3A26:  MOVLB  A
3A28:  CLRF   xBE
3A2A:  MOVFF  01,ABD
....................    temp2<<=8; 
3A2E:  MOVFF  ABD,ABE
3A32:  CLRF   xBD
....................    buffer = temp2|temp1; 
3A34:  MOVF   xBD,W
3A36:  IORWF  xBB,W
3A38:  MOVWF  xB9
3A3A:  MOVF   xBE,W
3A3C:  IORWF  xBC,W
3A3E:  MOVWF  xBA
....................    return(buffer); 
3A40:  MOVFF  AB9,01
3A44:  MOVFF  ABA,02
.................... } 
3A48:  MOVLB  0
3A4A:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int16 i; 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
5DD8:  MOVLW  AA
5DDA:  MOVLB  A
5DDC:  MOVWF  x8F
5DDE:  MOVLW  47
5DE0:  MOVWF  x8E
5DE2:  MOVF   27,F
5DE4:  BNZ   5DF8
5DE6:  MOVF   26,F
5DE8:  BNZ   5DF8
5DEA:  MOVF   x8F,W
5DEC:  SUBWF  25,W
5DEE:  BNC   5E1E
5DF0:  BNZ   5DF8
5DF2:  MOVF   24,W
5DF4:  SUBWF  x8E,W
5DF6:  BC    5E1E
5DF8:  CLRF   19
5DFA:  BTFSC  FF2.7
5DFC:  BSF    19.7
5DFE:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5E00:  MOVFF  A8F,AC8
5E04:  MOVFF  A8E,AC7
5E08:  CLRF   xC9
5E0A:  MOVLB  0
5E0C:  CALL   3E78
5E10:  BTFSC  19.7
5E12:  BSF    FF2.7
....................    } 
5E14:  MOVLB  A
5E16:  INCF   x8E,F
5E18:  BTFSC  FD8.2
5E1A:  INCF   x8F,F
5E1C:  BRA    5DE2
....................    for(i=ptr_start;i<ptr_card;i++) 
5E1E:  CLRF   x8F
5E20:  MOVLW  96
5E22:  MOVWF  x8E
5E24:  MOVF   23,F
5E26:  BNZ   5E3A
5E28:  MOVF   22,F
5E2A:  BNZ   5E3A
5E2C:  MOVF   x8F,W
5E2E:  SUBWF  21,W
5E30:  BNC   5E60
5E32:  BNZ   5E3A
5E34:  MOVF   20,W
5E36:  SUBWF  x8E,W
5E38:  BC    5E60
5E3A:  CLRF   19
5E3C:  BTFSC  FF2.7
5E3E:  BSF    19.7
5E40:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5E42:  MOVFF  A8F,AC8
5E46:  MOVFF  A8E,AC7
5E4A:  CLRF   xC9
5E4C:  MOVLB  0
5E4E:  CALL   3E78
5E52:  BTFSC  19.7
5E54:  BSF    FF2.7
....................    } 
5E56:  MOVLB  A
5E58:  INCF   x8E,F
5E5A:  BTFSC  FD8.2
5E5C:  INCF   x8F,F
5E5E:  BRA    5E24
....................    ptr_card=ptr_start; 
5E60:  CLRF   23
5E62:  CLRF   22
5E64:  CLRF   21
5E66:  MOVLW  96
5E68:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5E6A:  CLRF   27
5E6C:  CLRF   26
5E6E:  MOVLW  AA
5E70:  MOVWF  25
5E72:  MOVLW  47
5E74:  MOVWF  24
5E76:  CLRF   19
5E78:  BTFSC  FF2.7
5E7A:  BSF    19.7
5E7C:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5E7E:  MOVFF  23,ABC
5E82:  MOVFF  22,ABB
5E86:  MOVFF  21,ABA
5E8A:  MOVFF  20,AB9
5E8E:  MOVLW  19
5E90:  MOVWF  xBD
5E92:  MOVLB  0
5E94:  CALL   3F7E
5E98:  BTFSC  19.7
5E9A:  BSF    FF2.7
5E9C:  CLRF   19
5E9E:  BTFSC  FF2.7
5EA0:  BSF    19.7
5EA2:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5EA4:  MOVFF  27,ABC
5EA8:  MOVFF  26,ABB
5EAC:  MOVFF  25,ABA
5EB0:  MOVFF  24,AB9
5EB4:  MOVLW  1E
5EB6:  MOVLB  A
5EB8:  MOVWF  xBD
5EBA:  MOVLB  0
5EBC:  CALL   3F7E
5EC0:  BTFSC  19.7
5EC2:  BSF    FF2.7
5EC4:  CLRF   19
5EC6:  BTFSC  FF2.7
5EC8:  BSF    19.7
5ECA:  BCF    FF2.7
....................    save_coutcard(0); 
5ECC:  MOVLB  A
5ECE:  CLRF   xB7
5ED0:  CLRF   xB6
5ED2:  MOVLB  0
5ED4:  CALL   45E4
5ED8:  BTFSC  19.7
5EDA:  BSF    FF2.7
5EDC:  CLRF   19
5EDE:  BTFSC  FF2.7
5EE0:  BSF    19.7
5EE2:  BCF    FF2.7
....................    countcard=get_countcard(); 
5EE4:  CALL   39FC
5EE8:  BTFSC  19.7
5EEA:  BSF    FF2.7
5EEC:  MOVFF  02,FA
5EF0:  MOVFF  01,F9
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
.................... } 
5EF4:  GOTO   894E (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int16 i; 
....................    for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
*
5D20:  MOVLB  A
5D22:  CLRF   x8F
5D24:  MOVLW  96
5D26:  MOVWF  x8E
5D28:  INCFSZ x8E,W
5D2A:  BRA    5D32
5D2C:  INCFSZ x8F,W
5D2E:  BRA    5D32
5D30:  BRA    5D58
5D32:  CLRF   19
5D34:  BTFSC  FF2.7
5D36:  BSF    19.7
5D38:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5D3A:  MOVFF  A8F,AC8
5D3E:  MOVFF  A8E,AC7
5D42:  CLRF   xC9
5D44:  MOVLB  0
5D46:  CALL   3E78
5D4A:  BTFSC  19.7
5D4C:  BSF    FF2.7
....................    } 
5D4E:  MOVLB  A
5D50:  INCF   x8E,F
5D52:  BTFSC  FD8.2
5D54:  INCF   x8F,F
5D56:  BRA    5D28
....................    ptr_card=ptr_start; 
5D58:  CLRF   23
5D5A:  CLRF   22
5D5C:  CLRF   21
5D5E:  MOVLW  96
5D60:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5D62:  CLRF   27
5D64:  CLRF   26
5D66:  MOVLW  AA
5D68:  MOVWF  25
5D6A:  MOVLW  47
5D6C:  MOVWF  24
5D6E:  CLRF   19
5D70:  BTFSC  FF2.7
5D72:  BSF    19.7
5D74:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5D76:  MOVFF  23,ABC
5D7A:  MOVFF  22,ABB
5D7E:  MOVFF  21,ABA
5D82:  MOVFF  20,AB9
5D86:  MOVLW  19
5D88:  MOVWF  xBD
5D8A:  MOVLB  0
5D8C:  CALL   3F7E
5D90:  BTFSC  19.7
5D92:  BSF    FF2.7
5D94:  CLRF   19
5D96:  BTFSC  FF2.7
5D98:  BSF    19.7
5D9A:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5D9C:  MOVFF  27,ABC
5DA0:  MOVFF  26,ABB
5DA4:  MOVFF  25,ABA
5DA8:  MOVFF  24,AB9
5DAC:  MOVLW  1E
5DAE:  MOVLB  A
5DB0:  MOVWF  xBD
5DB2:  MOVLB  0
5DB4:  CALL   3F7E
5DB8:  BTFSC  19.7
5DBA:  BSF    FF2.7
5DBC:  CLRF   19
5DBE:  BTFSC  FF2.7
5DC0:  BSF    19.7
5DC2:  BCF    FF2.7
....................    save_coutcard(0); 
5DC4:  MOVLB  A
5DC6:  CLRF   xB7
5DC8:  CLRF   xB6
5DCA:  MOVLB  0
5DCC:  CALL   45E4
5DD0:  BTFSC  19.7
5DD2:  BSF    FF2.7
.................... } 
5DD4:  GOTO   88CE (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
5116:  MOVLB  A
5118:  CLRF   x8E
511A:  MOVLW  14
511C:  MOVWF  x8F
511E:  CLRF   x91
5120:  MOVLW  55
5122:  MOVWF  x90
5124:  MOVLB  0
5126:  RCALL  506A
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5128:  INCFSZ 55,W
512A:  BRA    5182
512C:  INCFSZ 56,W
512E:  BRA    5182
5130:  INCFSZ x64,W
5132:  BRA    5182
....................       { 
....................          memset(buffer1,0,20); 
5134:  CLRF   FEA
5136:  MOVLW  2D
5138:  MOVWF  FE9
513A:  CLRF   00
513C:  CLRF   02
513E:  MOVLW  14
5140:  MOVWF  01
5142:  CALL   447A
....................          strcpy(buffer1,"admin"); 
5146:  CLRF   FEA
5148:  MOVLW  2D
514A:  MOVWF  FE9
514C:  MOVLW  00
514E:  CALL   00D2
5152:  TBLRD*-
5154:  TBLRD*+
5156:  MOVF   FF5,W
5158:  MOVWF  FEE
515A:  IORLW  00
515C:  BNZ   5154
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
515E:  MOVLB  A
5160:  CLRF   xA3
5162:  MOVLW  14
5164:  MOVWF  xA4
5166:  CLRF   xA6
5168:  MOVLW  2D
516A:  MOVWF  xA5
516C:  MOVLB  0
516E:  RCALL  50C4
....................          EEPROM_read(strobe_pass_addr,20,password); 
5170:  MOVLB  A
5172:  CLRF   x8E
5174:  MOVLW  14
5176:  MOVWF  x8F
5178:  CLRF   x91
517A:  MOVLW  55
517C:  MOVWF  x90
517E:  MOVLB  0
5180:  RCALL  506A
....................       } 
.................... } 
5182:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
5734:  MOVLB  A
5736:  CLRF   xA2
5738:  MOVF   xA2,W
573A:  SUBLW  13
573C:  BNC   5752
573E:  CLRF   03
5740:  MOVF   xA2,W
5742:  ADDLW  8E
5744:  MOVWF  FE9
5746:  MOVLW  0A
5748:  ADDWFC 03,W
574A:  MOVWF  FEA
574C:  SETF   FEF
574E:  INCF   xA2,F
5750:  BRA    5738
....................    EEPROM_write(strobe_pass_addr,20,buf); 
5752:  CLRF   xA3
5754:  MOVLW  14
5756:  MOVWF  xA4
5758:  MOVLW  0A
575A:  MOVWF  xA6
575C:  MOVLW  8E
575E:  MOVWF  xA5
5760:  MOVLB  0
5762:  RCALL  50C4
.................... } 
5764:  GOTO   768E (RETURN)
.................... //============================================ 
.................... void reset_2nd_number() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0; 
5768:  MOVLB  A
576A:  CLRF   xA2
576C:  MOVF   xA2,W
576E:  SUBLW  13
5770:  BNC   5786
5772:  CLRF   03
5774:  MOVF   xA2,W
5776:  ADDLW  8E
5778:  MOVWF  FE9
577A:  MOVLW  0A
577C:  ADDWFC 03,W
577E:  MOVWF  FEA
5780:  CLRF   FEF
5782:  INCF   xA2,F
5784:  BRA    576C
....................    EEPROM_write(strobe_mobile_num0,20,buf); 
5786:  MOVLW  41
5788:  MOVWF  xA3
578A:  MOVLW  14
578C:  MOVWF  xA4
578E:  MOVLW  0A
5790:  MOVWF  xA6
5792:  MOVLW  8E
5794:  MOVWF  xA5
5796:  MOVLB  0
5798:  RCALL  50C4
.................... } 
579A:  GOTO   7696 (RETURN)
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
388A:  BSF    F94.4
388C:  MOVLW  0A
388E:  MOVWF  00
3890:  DECFSZ 00,F
3892:  BRA    3890
3894:  BSF    F94.3
3896:  MOVLW  0B
3898:  MOVWF  00
389A:  DECFSZ 00,F
389C:  BRA    389A
389E:  BCF    F8B.4
38A0:  BCF    F94.4
38A2:  MOVLW  0A
38A4:  MOVWF  00
38A6:  DECFSZ 00,F
38A8:  BRA    38A6
38AA:  BCF    F8B.3
38AC:  BCF    F94.3
....................    i2c_write(0xD0); 
38AE:  MOVLW  D0
38B0:  MOVLB  A
38B2:  MOVWF  xCE
38B4:  MOVLB  0
38B6:  RCALL  37AA
....................    i2c_write(address); 
38B8:  MOVFF  ABD,ACE
38BC:  RCALL  37AA
....................    i2c_start(); 
38BE:  BSF    F94.4
38C0:  MOVLW  0A
38C2:  MOVWF  00
38C4:  DECFSZ 00,F
38C6:  BRA    38C4
38C8:  BSF    F94.3
38CA:  MOVLW  0B
38CC:  MOVWF  00
38CE:  DECFSZ 00,F
38D0:  BRA    38CE
38D2:  BTFSS  F82.3
38D4:  BRA    38D2
38D6:  BCF    F8B.4
38D8:  BCF    F94.4
38DA:  MOVLW  0A
38DC:  MOVWF  00
38DE:  DECFSZ 00,F
38E0:  BRA    38DE
38E2:  BCF    F8B.3
38E4:  BCF    F94.3
....................    i2c_write(0xD1); 
38E6:  MOVLW  D1
38E8:  MOVLB  A
38EA:  MOVWF  xCE
38EC:  MOVLB  0
38EE:  RCALL  37AA
....................    result = i2c_read(0); 
38F0:  CLRF   00
38F2:  RCALL  3820
38F4:  MOVFF  01,ABE
....................    i2c_stop(); 
38F8:  BCF    F94.4
38FA:  NOP   
38FC:  BSF    F94.3
38FE:  BTFSS  F82.3
3900:  BRA    38FE
3902:  MOVLW  0A
3904:  MOVWF  00
3906:  DECFSZ 00,F
3908:  BRA    3906
390A:  BRA    390C
390C:  NOP   
390E:  BSF    F94.4
3910:  MOVLW  0A
3912:  MOVWF  00
3914:  DECFSZ 00,F
3916:  BRA    3914
....................     
....................    return(result); 
3918:  MOVLB  A
391A:  MOVFF  ABE,01
.................... } 
391E:  MOVLB  0
3920:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
5852:  BSF    F94.4
5854:  MOVLW  0A
5856:  MOVWF  00
5858:  DECFSZ 00,F
585A:  BRA    5858
585C:  BSF    F94.3
585E:  MOVLW  0B
5860:  MOVWF  00
5862:  DECFSZ 00,F
5864:  BRA    5862
5866:  BCF    F8B.4
5868:  BCF    F94.4
586A:  MOVLW  0A
586C:  MOVWF  00
586E:  DECFSZ 00,F
5870:  BRA    586E
5872:  BCF    F8B.3
5874:  BCF    F94.3
....................    delay_us(10); 
5876:  MOVLW  1A
5878:  MOVWF  00
587A:  DECFSZ 00,F
587C:  BRA    587A
587E:  NOP   
5880:  CLRF   19
5882:  BTFSC  FF2.7
5884:  BSF    19.7
5886:  BCF    FF2.7
....................    i2c_write(0xD0); 
5888:  MOVLW  D0
588A:  MOVLB  A
588C:  MOVWF  xCE
588E:  MOVLB  0
5890:  CALL   37AA
5894:  BTFSC  19.7
5896:  BSF    FF2.7
....................    delay_us(10); 
5898:  MOVLW  1A
589A:  MOVWF  00
589C:  DECFSZ 00,F
589E:  BRA    589C
58A0:  NOP   
58A2:  CLRF   19
58A4:  BTFSC  FF2.7
58A6:  BSF    19.7
58A8:  BCF    FF2.7
....................    i2c_write(address); 
58AA:  MOVFF  A96,ACE
58AE:  CALL   37AA
58B2:  BTFSC  19.7
58B4:  BSF    FF2.7
....................    delay_us(10); 
58B6:  MOVLW  1A
58B8:  MOVWF  00
58BA:  DECFSZ 00,F
58BC:  BRA    58BA
58BE:  NOP   
58C0:  CLRF   19
58C2:  BTFSC  FF2.7
58C4:  BSF    19.7
58C6:  BCF    FF2.7
....................    i2c_write(data); 
58C8:  MOVFF  A97,ACE
58CC:  CALL   37AA
58D0:  BTFSC  19.7
58D2:  BSF    FF2.7
....................    i2c_stop(); 
58D4:  BCF    F94.4
58D6:  NOP   
58D8:  BSF    F94.3
58DA:  BTFSS  F82.3
58DC:  BRA    58DA
58DE:  MOVLW  0A
58E0:  MOVWF  00
58E2:  DECFSZ 00,F
58E4:  BRA    58E2
58E6:  BRA    58E8
58E8:  NOP   
58EA:  BSF    F94.4
58EC:  MOVLW  0A
58EE:  MOVWF  00
58F0:  DECFSZ 00,F
58F2:  BRA    58F0
....................    delay_us(10); 
58F4:  MOVLW  1A
58F6:  MOVWF  00
58F8:  DECFSZ 00,F
58FA:  BRA    58F8
58FC:  NOP   
.................... } 
58FE:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
*
5184:  CLRF   19
5186:  BTFSC  FF2.7
5188:  BSF    19.7
518A:  BCF    FF2.7
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
518C:  MOVLB  A
518E:  CLRF   xBD
5190:  MOVLB  0
5192:  CALL   388A
5196:  BTFSC  19.7
5198:  BSF    FF2.7
519A:  MOVFF  01,A8E
....................     
....................    data &= 0x7F; 
519E:  MOVLB  A
51A0:  BCF    x8E.7
....................     
....................    i2c_start(); 
51A2:  BSF    F94.4
51A4:  MOVLW  0A
51A6:  MOVWF  00
51A8:  DECFSZ 00,F
51AA:  BRA    51A8
51AC:  BSF    F94.3
51AE:  MOVLW  0B
51B0:  MOVWF  00
51B2:  DECFSZ 00,F
51B4:  BRA    51B2
51B6:  BCF    F8B.4
51B8:  BCF    F94.4
51BA:  MOVLW  0A
51BC:  MOVWF  00
51BE:  DECFSZ 00,F
51C0:  BRA    51BE
51C2:  BCF    F8B.3
51C4:  BCF    F94.3
51C6:  CLRF   19
51C8:  BTFSC  FF2.7
51CA:  BSF    19.7
51CC:  BCF    FF2.7
....................    i2c_write(0xD0); 
51CE:  MOVLW  D0
51D0:  MOVWF  xCE
51D2:  MOVLB  0
51D4:  CALL   37AA
51D8:  BTFSC  19.7
51DA:  BSF    FF2.7
51DC:  CLRF   19
51DE:  BTFSC  FF2.7
51E0:  BSF    19.7
51E2:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
51E4:  MOVLB  A
51E6:  CLRF   xCE
51E8:  MOVLB  0
51EA:  CALL   37AA
51EE:  BTFSC  19.7
51F0:  BSF    FF2.7
51F2:  CLRF   19
51F4:  BTFSC  FF2.7
51F6:  BSF    19.7
51F8:  BCF    FF2.7
....................    i2c_write(data); 
51FA:  MOVFF  A8E,ACE
51FE:  CALL   37AA
5202:  BTFSC  19.7
5204:  BSF    FF2.7
....................    i2c_start(); 
5206:  BSF    F94.4
5208:  MOVLW  0A
520A:  MOVWF  00
520C:  DECFSZ 00,F
520E:  BRA    520C
5210:  BSF    F94.3
5212:  MOVLW  0B
5214:  MOVWF  00
5216:  DECFSZ 00,F
5218:  BRA    5216
521A:  BTFSS  F82.3
521C:  BRA    521A
521E:  BCF    F8B.4
5220:  BCF    F94.4
5222:  MOVLW  0A
5224:  MOVWF  00
5226:  DECFSZ 00,F
5228:  BRA    5226
522A:  BCF    F8B.3
522C:  BCF    F94.3
522E:  CLRF   19
5230:  BTFSC  FF2.7
5232:  BSF    19.7
5234:  BCF    FF2.7
....................    i2c_write(0xD0); 
5236:  MOVLW  D0
5238:  MOVLB  A
523A:  MOVWF  xCE
523C:  MOVLB  0
523E:  CALL   37AA
5242:  BTFSC  19.7
5244:  BSF    FF2.7
5246:  CLRF   19
5248:  BTFSC  FF2.7
524A:  BSF    19.7
524C:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
524E:  MOVLW  07
5250:  MOVLB  A
5252:  MOVWF  xCE
5254:  MOVLB  0
5256:  CALL   37AA
525A:  BTFSC  19.7
525C:  BSF    FF2.7
525E:  CLRF   19
5260:  BTFSC  FF2.7
5262:  BSF    19.7
5264:  BCF    FF2.7
....................    i2c_write(0x80); 
5266:  MOVLW  80
5268:  MOVLB  A
526A:  MOVWF  xCE
526C:  MOVLB  0
526E:  CALL   37AA
5272:  BTFSC  19.7
5274:  BSF    FF2.7
....................    i2c_stop(); 
5276:  BCF    F94.4
5278:  NOP   
527A:  BSF    F94.3
527C:  BTFSS  F82.3
527E:  BRA    527C
5280:  MOVLW  0A
5282:  MOVWF  00
5284:  DECFSZ 00,F
5286:  BRA    5284
5288:  BRA    528A
528A:  NOP   
528C:  BSF    F94.4
528E:  MOVLW  0A
5290:  MOVWF  00
5292:  DECFSZ 00,F
5294:  BRA    5292
.................... } 
5296:  GOTO   6DF8 (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
5900:  CLRF   19
5902:  BTFSC  FF2.7
5904:  BSF    19.7
5906:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
5908:  MOVFF  A95,AC5
590C:  MOVLW  0A
590E:  MOVLB  A
5910:  MOVWF  xC6
5912:  MOVLB  0
5914:  CALL   1800
5918:  BTFSC  19.7
591A:  BSF    FF2.7
591C:  MOVFF  01,A96
....................    nibl=data-(nibh*10); 
5920:  MOVLB  A
5922:  MOVF   x96,W
5924:  MULLW  0A
5926:  MOVF   FF3,W
5928:  SUBWF  x95,W
592A:  MOVWF  x97
....................  
....................    return((nibh<<4)|nibl); 
592C:  SWAPF  x96,W
592E:  MOVWF  00
5930:  MOVLW  F0
5932:  ANDWF  00,F
5934:  MOVF   00,W
5936:  IORWF  x97,W
5938:  MOVWF  01
.................... } 
593A:  MOVLB  0
593C:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
3922:  MOVFF  ABE,ABF
....................    data=(i>>4)*10; 
3926:  MOVLB  A
3928:  SWAPF  xBF,W
392A:  MOVWF  00
392C:  MOVLW  0F
392E:  ANDWF  00,F
3930:  MOVF   00,W
3932:  MULLW  0A
3934:  MOVFF  FF3,ABE
....................    data=data+(i<<4>>4); 
3938:  SWAPF  xBF,W
393A:  MOVWF  00
393C:  MOVLW  F0
393E:  ANDWF  00,F
3940:  MOVF   00,W
3942:  SWAPF  00,F
3944:  MOVLW  0F
3946:  ANDWF  00,F
3948:  MOVF   00,W
394A:  ADDWF  xBE,F
....................  
....................    return data; 
394C:  MOVFF  ABE,01
.................... } 
3950:  MOVLB  0
3952:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
593E:  MOVLB  A
5940:  CLRF   x96
5942:  CLRF   x97
5944:  MOVLB  0
5946:  RCALL  5852
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
5948:  MOVFF  A94,A95
594C:  RCALL  5900
594E:  MOVFF  01,A95
5952:  MOVLW  01
5954:  MOVLB  A
5956:  MOVWF  x96
5958:  MOVFF  01,A97
595C:  MOVLB  0
595E:  RCALL  5852
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
5960:  MOVFF  A93,A95
5964:  RCALL  5900
5966:  MOVFF  01,A95
596A:  MOVLW  02
596C:  MOVLB  A
596E:  MOVWF  x96
5970:  MOVFF  01,A97
5974:  MOVLB  0
5976:  RCALL  5852
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
5978:  MOVFF  A92,A95
597C:  RCALL  5900
597E:  MOVFF  01,A95
5982:  MOVLW  03
5984:  MOVLB  A
5986:  MOVWF  x96
5988:  MOVFF  01,A97
598C:  MOVLB  0
598E:  RCALL  5852
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
5990:  MOVFF  A8F,A95
5994:  RCALL  5900
5996:  MOVFF  01,A95
599A:  MOVLW  04
599C:  MOVLB  A
599E:  MOVWF  x96
59A0:  MOVFF  01,A97
59A4:  MOVLB  0
59A6:  RCALL  5852
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
59A8:  MOVFF  A90,A95
59AC:  RCALL  5900
59AE:  MOVFF  01,A95
59B2:  MOVLW  05
59B4:  MOVLB  A
59B6:  MOVWF  x96
59B8:  MOVFF  01,A97
59BC:  MOVLB  0
59BE:  RCALL  5852
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
59C0:  MOVFF  A91,A95
59C4:  RCALL  5900
59C6:  MOVFF  01,A95
59CA:  MOVLW  06
59CC:  MOVLB  A
59CE:  MOVWF  x96
59D0:  MOVFF  01,A97
59D4:  MOVLB  0
59D6:  RCALL  5852
....................    write_DS1307(DS1307_CONTROL,0);    
59D8:  MOVLW  07
59DA:  MOVLB  A
59DC:  MOVWF  x96
59DE:  CLRF   x97
59E0:  MOVLB  0
59E2:  RCALL  5852
.................... } 
59E4:  GOTO   5A4E (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
4002:  MOVLW  04
4004:  MOVLB  A
4006:  MOVWF  xBD
4008:  MOVLB  0
400A:  RCALL  388A
400C:  MOVFF  01,AB9
4010:  MOVFF  01,ABE
4014:  RCALL  3922
4016:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
401A:  MOVLW  05
401C:  MOVLB  A
401E:  MOVWF  xBD
4020:  MOVLB  0
4022:  RCALL  388A
4024:  MOVFF  01,AB9
4028:  MOVFF  01,ABE
402C:  RCALL  3922
402E:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
4032:  MOVLW  06
4034:  MOVLB  A
4036:  MOVWF  xBD
4038:  MOVLB  0
403A:  RCALL  388A
403C:  MOVFF  01,AB9
4040:  MOVFF  01,ABE
4044:  RCALL  3922
4046:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
404A:  MOVLW  03
404C:  MOVLB  A
404E:  MOVWF  xBD
4050:  MOVLB  0
4052:  RCALL  388A
4054:  MOVFF  01,AB9
4058:  MOVFF  01,ABE
405C:  RCALL  3922
405E:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
4062:  MOVLW  02
4064:  MOVLB  A
4066:  MOVWF  xBD
4068:  MOVLB  0
406A:  RCALL  388A
406C:  MOVFF  01,AB9
4070:  MOVFF  01,ABE
4074:  RCALL  3922
4076:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
407A:  MOVLW  01
407C:  MOVLB  A
407E:  MOVWF  xBD
4080:  MOVLB  0
4082:  RCALL  388A
4084:  MOVFF  01,AB9
4088:  MOVFF  01,ABE
408C:  RCALL  3922
408E:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
4092:  MOVLB  A
4094:  CLRF   xBD
4096:  MOVLB  0
4098:  CALL   388A
409C:  MOVFF  01,AB9
40A0:  MOVFF  01,ABE
40A4:  RCALL  3922
40A6:  MOVFF  01,103
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0,booting=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... int16 count_checking=10; 
.................... #include <scan_key.c> 
....................  
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... int8 type_KB=0; 
.................... #define key_numbyte  50 
....................  
.................... int8 key_data[key_numbyte]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
23AE:  MOVLB  1
23B0:  INCF   x47,F
23B2:  MOVF   x47,W
23B4:  SUBLW  01
23B6:  BTFSC  FD8.0
23B8:  BRA    255E
....................        switch (col) { 
23BA:  MOVF   x4A,W
23BC:  ADDLW  FB
23BE:  BC    2442
23C0:  ADDLW  05
23C2:  MOVLB  0
23C4:  GOTO   2568
....................          case 0   :  
....................                     output_low(COL0); 
23C8:  BCF    F92.5
23CA:  BCF    F89.5
....................                     output_high(COL1); 
23CC:  BCF    F92.3
23CE:  BSF    F89.3
....................                     output_high(COL2); 
23D0:  BCF    F92.2
23D2:  BSF    F89.2
....................                     output_high(COL3); 
23D4:  BCF    F92.1
23D6:  BSF    F89.1
....................                     output_high(COL4); 
23D8:  BCF    F92.0
23DA:  BSF    F89.0
....................                     break; 
23DC:  MOVLB  1
23DE:  BRA    2442
....................          case 1   :  
....................                     output_low(COL1); 
23E0:  BCF    F92.3
23E2:  BCF    F89.3
....................                     output_high(COL0); 
23E4:  BCF    F92.5
23E6:  BSF    F89.5
....................                     output_high(COL2); 
23E8:  BCF    F92.2
23EA:  BSF    F89.2
....................                     output_high(COL3); 
23EC:  BCF    F92.1
23EE:  BSF    F89.1
....................                     output_high(COL4); 
23F0:  BCF    F92.0
23F2:  BSF    F89.0
....................                     break; 
23F4:  MOVLB  1
23F6:  BRA    2442
....................          case 2   :  
....................                     output_low(COL2); 
23F8:  BCF    F92.2
23FA:  BCF    F89.2
....................                     output_high(COL1); 
23FC:  BCF    F92.3
23FE:  BSF    F89.3
....................                     output_high(COL0); 
2400:  BCF    F92.5
2402:  BSF    F89.5
....................                     output_high(COL3); 
2404:  BCF    F92.1
2406:  BSF    F89.1
....................                     output_high(COL4); 
2408:  BCF    F92.0
240A:  BSF    F89.0
....................                     break; 
240C:  MOVLB  1
240E:  BRA    2442
....................          case 3   :  
....................                     output_low(COL3); 
2410:  BCF    F92.1
2412:  BCF    F89.1
....................                     output_high(COL1); 
2414:  BCF    F92.3
2416:  BSF    F89.3
....................                     output_high(COL2); 
2418:  BCF    F92.2
241A:  BSF    F89.2
....................                     output_high(COL0); 
241C:  BCF    F92.5
241E:  BSF    F89.5
....................                     output_high(COL4); 
2420:  BCF    F92.0
2422:  BSF    F89.0
....................                     break; 
2424:  MOVLB  1
2426:  BRA    2442
....................          case 4   :  
....................                     output_low(COL4); 
2428:  BCF    F92.0
242A:  BCF    F89.0
....................                     output_high(COL1); 
242C:  BCF    F92.3
242E:  BSF    F89.3
....................                     output_high(COL2); 
2430:  BCF    F92.2
2432:  BSF    F89.2
....................                     output_high(COL3); 
2434:  BCF    F92.1
2436:  BSF    F89.1
....................                     output_high(COL0); 
2438:  BCF    F92.5
243A:  BSF    F89.5
....................                     break; 
243C:  MOVLB  1
243E:  BRA    2442
2440:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2442:  BTFSS  x48.0
2444:  BRA    24C4
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2446:  BSF    F93.4
2448:  MOVLW  00
244A:  BTFSC  F81.4
244C:  MOVLW  01
244E:  MOVLB  A
2450:  MOVWF  xB8
2452:  BSF    F93.5
2454:  MOVLW  00
2456:  BTFSC  F81.5
2458:  MOVLW  01
245A:  ANDWF  xB8,F
245C:  BSF    F93.6
245E:  MOVLW  00
2460:  BTFSC  F81.6
2462:  MOVLW  01
2464:  ANDWF  xB8,F
2466:  BSF    F93.7
2468:  MOVLW  00
246A:  BTFSC  F81.7
246C:  MOVLW  01
246E:  ANDWF  xB8,W
2470:  BZ    24C0
....................          { 
....................             kchar=last_key; 
2472:  MOVFF  149,AB6
....................             if(keydebug_en==0) 
2476:  MOVLB  1
2478:  MOVF   x0B,F
247A:  BNZ   24AE
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
247C:  CLRF   x09
247E:  CLRF   x08
....................               charac_timeout=0; 
2480:  MOVLB  0
2482:  CLRF   xFC
2484:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
2486:  MOVLB  1
2488:  MOVF   x0E,W
248A:  SUBLW  31
248C:  BNC   24A2
248E:  MOVF   x0E,W
2490:  INCF   x0E,F
2492:  CLRF   03
2494:  ADDLW  14
2496:  MOVWF  FE9
2498:  MOVLW  01
249A:  ADDWFC 03,W
249C:  MOVWF  FEA
249E:  MOVFF  AB6,FEF
....................                fputc(kchar,COM2); 
24A2:  MOVFF  AB6,ADF
24A6:  MOVLB  0
24A8:  CALL   075A
....................             } 
....................                else fputc(kchar,COM2); 
24AC:  BRA    24B8
24AE:  MOVFF  AB6,ADF
24B2:  MOVLB  0
24B4:  CALL   075A
....................            kbd_down=FALSE; 
24B8:  MOVLB  1
24BA:  BCF    x48.0
....................            last_key=0; 
24BC:  CLRF   x49
24BE:  MOVLB  A
....................          } 
....................        } else 
24C0:  BRA    255A
24C2:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
24C4:  BSF    F93.4
24C6:  MOVLW  00
24C8:  BTFSC  F81.4
24CA:  MOVLW  01
24CC:  MOVLB  A
24CE:  MOVWF  xB8
24D0:  BSF    F93.5
24D2:  MOVLW  00
24D4:  BTFSC  F81.5
24D6:  MOVLW  01
24D8:  ANDWF  xB8,F
24DA:  BSF    F93.6
24DC:  MOVLW  00
24DE:  BTFSC  F81.6
24E0:  MOVLW  01
24E2:  ANDWF  xB8,F
24E4:  BSF    F93.7
24E6:  MOVLW  00
24E8:  BTFSC  F81.7
24EA:  MOVLW  01
24EC:  ANDWF  xB8,W
24EE:  BNZ   254E
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
24F0:  BSF    F93.4
24F2:  BTFSC  F81.4
24F4:  BRA    24FA
....................                   row=0; 
24F6:  CLRF   xB7
....................                 else if(input(ROW1)==0) 
24F8:  BRA    251C
24FA:  BSF    F93.5
24FC:  BTFSC  F81.5
24FE:  BRA    2506
....................                   row=1; 
2500:  MOVLW  01
2502:  MOVWF  xB7
....................                 else if(input(ROW2)==0) 
2504:  BRA    251C
2506:  BSF    F93.6
2508:  BTFSC  F81.6
250A:  BRA    2512
....................                   row=2; 
250C:  MOVLW  02
250E:  MOVWF  xB7
....................                 else if(input(ROW3)==0) 
2510:  BRA    251C
2512:  BSF    F93.7
2514:  BTFSC  F81.7
2516:  BRA    251C
....................                   row=3; 
2518:  MOVLW  03
251A:  MOVWF  xB7
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
251C:  MOVF   xB7,W
251E:  MULLW  05
2520:  MOVF   FF3,W
2522:  CLRF   xB9
2524:  MOVWF  xB8
2526:  CLRF   03
2528:  MOVLB  1
252A:  MOVF   x4A,W
252C:  MOVLB  A
252E:  ADDWF  xB8,W
2530:  MOVWF  01
2532:  MOVF   xB9,W
2534:  ADDWFC 03,F
2536:  MOVF   01,W
2538:  MOVLB  0
253A:  CALL   00E8
253E:  MOVFF  FE8,149
....................                 kbd_down = TRUE; 
2542:  MOVLB  1
2544:  BSF    x48.0
....................                 set_tris_a(0xff); 
2546:  MOVLW  FF
2548:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
254A:  BRA    255A
254C:  MOVLB  A
....................                { 
....................                   ++col; 
254E:  MOVLB  1
2550:  INCF   x4A,F
....................                   if(col==5) col=0; 
2552:  MOVF   x4A,W
2554:  SUBLW  05
2556:  BTFSC  FD8.2
2558:  CLRF   x4A
....................                } 
....................          } 
....................       kbd_call_count=0; 
255A:  MOVLB  1
255C:  CLRF   x47
....................    } 
....................   return(kchar); 
255E:  MOVLB  A
2560:  MOVFF  AB6,01
.................... } 
2564:  MOVLB  0
2566:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
258C:  MOVLW  E0
258E:  MOVLB  F
2590:  MOVWF  x48
2592:  BCF    FC2.6
2594:  BCF    FC2.7
2596:  MOVF   x49,W
2598:  ANDLW  E0
259A:  IORLW  17
259C:  MOVWF  x49
....................    switch(col) 
....................    { 
259E:  MOVLB  A
25A0:  MOVF   xD3,W
25A2:  ADDLW  FA
25A4:  BC    2670
25A6:  ADDLW  06
25A8:  MOVLB  0
25AA:  GOTO   2674
....................       case 0: 
....................         set_adc_channel(4); 
25AE:  MOVLW  10
25B0:  MOVWF  01
25B2:  MOVF   FC2,W
25B4:  ANDLW  C3
25B6:  IORWF  01,W
25B8:  MOVWF  FC2
....................         adc=read_adc(); 
25BA:  BSF    FC2.1
25BC:  BTFSC  FC2.1
25BE:  BRA    25BC
25C0:  MOVFF  FC4,AD4
....................         return adc; 
25C4:  MOVLB  A
25C6:  MOVFF  AD4,01
25CA:  BRA    2670
....................       break; 
25CC:  BRA    2670
....................       case 1: 
....................         set_adc_channel(3); 
25CE:  MOVLW  0C
25D0:  MOVWF  01
25D2:  MOVF   FC2,W
25D4:  ANDLW  C3
25D6:  IORWF  01,W
25D8:  MOVWF  FC2
....................         adc=read_adc(); 
25DA:  BSF    FC2.1
25DC:  BTFSC  FC2.1
25DE:  BRA    25DC
25E0:  MOVFF  FC4,AD4
....................         return adc; 
25E4:  MOVLB  A
25E6:  MOVFF  AD4,01
25EA:  BRA    2670
....................       break; 
25EC:  BRA    2670
....................       case 2: 
....................         set_adc_channel(2); 
25EE:  MOVLW  08
25F0:  MOVWF  01
25F2:  MOVF   FC2,W
25F4:  ANDLW  C3
25F6:  IORWF  01,W
25F8:  MOVWF  FC2
....................         adc=read_adc(); 
25FA:  BSF    FC2.1
25FC:  BTFSC  FC2.1
25FE:  BRA    25FC
2600:  MOVFF  FC4,AD4
....................         return adc; 
2604:  MOVLB  A
2606:  MOVFF  AD4,01
260A:  BRA    2670
....................       break; 
260C:  BRA    2670
....................       case 3: 
....................         set_adc_channel(1); 
260E:  MOVLW  04
2610:  MOVWF  01
2612:  MOVF   FC2,W
2614:  ANDLW  C3
2616:  IORWF  01,W
2618:  MOVWF  FC2
....................         adc=read_adc(); 
261A:  BSF    FC2.1
261C:  BTFSC  FC2.1
261E:  BRA    261C
2620:  MOVFF  FC4,AD4
....................         return adc; 
2624:  MOVLB  A
2626:  MOVFF  AD4,01
262A:  BRA    2670
....................       break; 
262C:  BRA    2670
....................       case 4: 
....................         set_adc_channel(0); 
262E:  MOVLW  00
2630:  MOVWF  01
2632:  MOVF   FC2,W
2634:  ANDLW  C3
2636:  IORWF  01,W
2638:  MOVWF  FC2
....................         adc=read_adc(); 
263A:  BSF    FC2.1
263C:  BTFSC  FC2.1
263E:  BRA    263C
2640:  MOVFF  FC4,AD4
....................         return adc; 
2644:  MOVLB  A
2646:  MOVFF  AD4,01
264A:  BRA    2670
....................       break;      
264C:  BRA    2670
....................       case 5: 
....................         set_adc_channel(11); 
264E:  MOVLW  2C
2650:  MOVWF  01
2652:  MOVF   FC2,W
2654:  ANDLW  C3
2656:  IORWF  01,W
2658:  MOVWF  FC2
....................         adc=read_adc(); 
265A:  BSF    FC2.1
265C:  BTFSC  FC2.1
265E:  BRA    265C
2660:  MOVFF  FC4,AD4
....................         return adc; 
2664:  MOVLB  A
2666:  MOVFF  AD4,01
266A:  BRA    2670
....................       break;      
266C:  BRA    2670
266E:  MOVLB  A
....................    } 
.................... } 
2670:  MOVLB  0
2672:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
27EE:  MOVLB  A
27F0:  CLRF   xBE
27F2:  CLRF   xBD
27F4:  CLRF   xBC
27F6:  CLRF   xBB
27F8:  CLRF   xC2
27FA:  CLRF   xC1
27FC:  CLRF   xC0
27FE:  CLRF   xBF
2800:  CLRF   xC6
2802:  CLRF   xC5
2804:  CLRF   xC4
2806:  CLRF   xC3
2808:  CLRF   xCA
280A:  CLRF   xC9
280C:  CLRF   xC8
280E:  CLRF   xC7
2810:  CLRF   xCE
2812:  CLRF   xCD
2814:  CLRF   xCC
2816:  CLRF   xCB
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2818:  CLRF   xBA
281A:  CLRF   xB9
281C:  MOVF   xBA,W
281E:  SUBLW  01
2820:  BNC   289E
2822:  BNZ   282A
2824:  MOVF   xB9,W
2826:  SUBLW  F3
2828:  BNC   289E
....................    { 
....................       col_0=read_col(0)+col_0; 
282A:  CLRF   xD3
282C:  MOVLB  0
282E:  RCALL  258C
2830:  MOVF   01,W
2832:  MOVLB  A
2834:  ADDWF  xBB,F
2836:  MOVLW  00
2838:  ADDWFC xBC,F
283A:  ADDWFC xBD,F
283C:  ADDWFC xBE,F
....................       col_1=read_col(1)+col_1; 
283E:  MOVLW  01
2840:  MOVWF  xD3
2842:  MOVLB  0
2844:  RCALL  258C
2846:  MOVF   01,W
2848:  MOVLB  A
284A:  ADDWF  xBF,F
284C:  MOVLW  00
284E:  ADDWFC xC0,F
2850:  ADDWFC xC1,F
2852:  ADDWFC xC2,F
....................       col_2=read_col(2)+col_2; 
2854:  MOVLW  02
2856:  MOVWF  xD3
2858:  MOVLB  0
285A:  RCALL  258C
285C:  MOVF   01,W
285E:  MOVLB  A
2860:  ADDWF  xC3,F
2862:  MOVLW  00
2864:  ADDWFC xC4,F
2866:  ADDWFC xC5,F
2868:  ADDWFC xC6,F
....................       col_3=read_col(3)+col_3; 
286A:  MOVLW  03
286C:  MOVWF  xD3
286E:  MOVLB  0
2870:  RCALL  258C
2872:  MOVF   01,W
2874:  MOVLB  A
2876:  ADDWF  xC7,F
2878:  MOVLW  00
287A:  ADDWFC xC8,F
287C:  ADDWFC xC9,F
287E:  ADDWFC xCA,F
....................       col_4=read_col(4)+col_4; 
2880:  MOVLW  04
2882:  MOVWF  xD3
2884:  MOVLB  0
2886:  RCALL  258C
2888:  MOVF   01,W
288A:  MOVLB  A
288C:  ADDWF  xCB,F
288E:  MOVLW  00
2890:  ADDWFC xCC,F
2892:  ADDWFC xCD,F
2894:  ADDWFC xCE,F
....................    } 
2896:  INCF   xB9,F
2898:  BTFSC  FD8.2
289A:  INCF   xBA,F
289C:  BRA    281C
....................    col_0=col_0/500; 
289E:  BCF    FD8.1
28A0:  MOVFF  ABE,AE2
28A4:  MOVFF  ABD,AE1
28A8:  MOVFF  ABC,AE0
28AC:  MOVFF  ABB,ADF
28B0:  CLRF   xE6
28B2:  CLRF   xE5
28B4:  MOVLW  01
28B6:  MOVWF  xE4
28B8:  MOVLW  F4
28BA:  MOVWF  xE3
28BC:  MOVLB  0
28BE:  RCALL  269A
28C0:  MOVFF  03,ABE
28C4:  MOVFF  02,ABD
28C8:  MOVFF  01,ABC
28CC:  MOVFF  00,ABB
....................    col_1=col_1/500; 
28D0:  BCF    FD8.1
28D2:  MOVFF  AC2,AE2
28D6:  MOVFF  AC1,AE1
28DA:  MOVFF  AC0,AE0
28DE:  MOVFF  ABF,ADF
28E2:  MOVLB  A
28E4:  CLRF   xE6
28E6:  CLRF   xE5
28E8:  MOVLW  01
28EA:  MOVWF  xE4
28EC:  MOVLW  F4
28EE:  MOVWF  xE3
28F0:  MOVLB  0
28F2:  RCALL  269A
28F4:  MOVFF  03,AC2
28F8:  MOVFF  02,AC1
28FC:  MOVFF  01,AC0
2900:  MOVFF  00,ABF
....................    col_2=col_2/500; 
2904:  BCF    FD8.1
2906:  MOVFF  AC6,AE2
290A:  MOVFF  AC5,AE1
290E:  MOVFF  AC4,AE0
2912:  MOVFF  AC3,ADF
2916:  MOVLB  A
2918:  CLRF   xE6
291A:  CLRF   xE5
291C:  MOVLW  01
291E:  MOVWF  xE4
2920:  MOVLW  F4
2922:  MOVWF  xE3
2924:  MOVLB  0
2926:  RCALL  269A
2928:  MOVFF  03,AC6
292C:  MOVFF  02,AC5
2930:  MOVFF  01,AC4
2934:  MOVFF  00,AC3
....................    col_3=col_3/500; 
2938:  BCF    FD8.1
293A:  MOVFF  ACA,AE2
293E:  MOVFF  AC9,AE1
2942:  MOVFF  AC8,AE0
2946:  MOVFF  AC7,ADF
294A:  MOVLB  A
294C:  CLRF   xE6
294E:  CLRF   xE5
2950:  MOVLW  01
2952:  MOVWF  xE4
2954:  MOVLW  F4
2956:  MOVWF  xE3
2958:  MOVLB  0
295A:  RCALL  269A
295C:  MOVFF  03,ACA
2960:  MOVFF  02,AC9
2964:  MOVFF  01,AC8
2968:  MOVFF  00,AC7
....................    col_4=col_4/500; 
296C:  BCF    FD8.1
296E:  MOVFF  ACE,AE2
2972:  MOVFF  ACD,AE1
2976:  MOVFF  ACC,AE0
297A:  MOVFF  ACB,ADF
297E:  MOVLB  A
2980:  CLRF   xE6
2982:  CLRF   xE5
2984:  MOVLW  01
2986:  MOVWF  xE4
2988:  MOVLW  F4
298A:  MOVWF  xE3
298C:  MOVLB  0
298E:  RCALL  269A
2990:  MOVFF  03,ACE
2994:  MOVFF  02,ACD
2998:  MOVFF  01,ACC
299C:  MOVFF  00,ACB
....................    if(keydebug_en) 
29A0:  MOVLB  1
29A2:  MOVF   x0B,F
29A4:  BTFSC  FD8.2
29A6:  BRA    2B22
....................    { 
....................       fprintf(COM2,"\r\n");      
29A8:  MOVLW  0D
29AA:  MOVLB  A
29AC:  MOVWF  xDF
29AE:  MOVLB  0
29B0:  CALL   075A
29B4:  MOVLW  0A
29B6:  MOVLB  A
29B8:  MOVWF  xDF
29BA:  MOVLB  0
29BC:  CALL   075A
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
29C0:  MOVLW  26
29C2:  MOVWF  FF6
29C4:  MOVLW  04
29C6:  MOVWF  FF7
29C8:  MOVLW  07
29CA:  MOVLB  A
29CC:  MOVWF  xD3
29CE:  MOVLB  0
29D0:  CALL   1718
29D4:  MOVLW  41
29D6:  MOVWF  FE9
29D8:  MOVFF  ABE,AD6
29DC:  MOVFF  ABD,AD5
29E0:  MOVFF  ABC,AD4
29E4:  MOVFF  ABB,AD3
29E8:  RCALL  272E
29EA:  MOVLW  0D
29EC:  MOVLB  A
29EE:  MOVWF  xDF
29F0:  MOVLB  0
29F2:  CALL   075A
29F6:  MOVLW  0A
29F8:  MOVLB  A
29FA:  MOVWF  xDF
29FC:  MOVLB  0
29FE:  CALL   075A
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2A02:  MOVLW  34
2A04:  MOVWF  FF6
2A06:  MOVLW  04
2A08:  MOVWF  FF7
2A0A:  MOVLW  07
2A0C:  MOVLB  A
2A0E:  MOVWF  xD3
2A10:  MOVLB  0
2A12:  CALL   1718
2A16:  MOVLW  41
2A18:  MOVWF  FE9
2A1A:  MOVFF  AC2,AD6
2A1E:  MOVFF  AC1,AD5
2A22:  MOVFF  AC0,AD4
2A26:  MOVFF  ABF,AD3
2A2A:  RCALL  272E
2A2C:  MOVLW  0D
2A2E:  MOVLB  A
2A30:  MOVWF  xDF
2A32:  MOVLB  0
2A34:  CALL   075A
2A38:  MOVLW  0A
2A3A:  MOVLB  A
2A3C:  MOVWF  xDF
2A3E:  MOVLB  0
2A40:  CALL   075A
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2A44:  MOVLW  42
2A46:  MOVWF  FF6
2A48:  MOVLW  04
2A4A:  MOVWF  FF7
2A4C:  MOVLW  07
2A4E:  MOVLB  A
2A50:  MOVWF  xD3
2A52:  MOVLB  0
2A54:  CALL   1718
2A58:  MOVLW  41
2A5A:  MOVWF  FE9
2A5C:  MOVFF  AC6,AD6
2A60:  MOVFF  AC5,AD5
2A64:  MOVFF  AC4,AD4
2A68:  MOVFF  AC3,AD3
2A6C:  RCALL  272E
2A6E:  MOVLW  0D
2A70:  MOVLB  A
2A72:  MOVWF  xDF
2A74:  MOVLB  0
2A76:  CALL   075A
2A7A:  MOVLW  0A
2A7C:  MOVLB  A
2A7E:  MOVWF  xDF
2A80:  MOVLB  0
2A82:  CALL   075A
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2A86:  MOVLW  50
2A88:  MOVWF  FF6
2A8A:  MOVLW  04
2A8C:  MOVWF  FF7
2A8E:  MOVLW  07
2A90:  MOVLB  A
2A92:  MOVWF  xD3
2A94:  MOVLB  0
2A96:  CALL   1718
2A9A:  MOVLW  41
2A9C:  MOVWF  FE9
2A9E:  MOVFF  ACA,AD6
2AA2:  MOVFF  AC9,AD5
2AA6:  MOVFF  AC8,AD4
2AAA:  MOVFF  AC7,AD3
2AAE:  RCALL  272E
2AB0:  MOVLW  0D
2AB2:  MOVLB  A
2AB4:  MOVWF  xDF
2AB6:  MOVLB  0
2AB8:  CALL   075A
2ABC:  MOVLW  0A
2ABE:  MOVLB  A
2AC0:  MOVWF  xDF
2AC2:  MOVLB  0
2AC4:  CALL   075A
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2AC8:  MOVLW  5E
2ACA:  MOVWF  FF6
2ACC:  MOVLW  04
2ACE:  MOVWF  FF7
2AD0:  MOVLW  07
2AD2:  MOVLB  A
2AD4:  MOVWF  xD3
2AD6:  MOVLB  0
2AD8:  CALL   1718
2ADC:  MOVLW  41
2ADE:  MOVWF  FE9
2AE0:  MOVFF  ACE,AD6
2AE4:  MOVFF  ACD,AD5
2AE8:  MOVFF  ACC,AD4
2AEC:  MOVFF  ACB,AD3
2AF0:  RCALL  272E
2AF2:  MOVLW  0D
2AF4:  MOVLB  A
2AF6:  MOVWF  xDF
2AF8:  MOVLB  0
2AFA:  CALL   075A
2AFE:  MOVLW  0A
2B00:  MOVLB  A
2B02:  MOVWF  xDF
2B04:  MOVLB  0
2B06:  CALL   075A
....................       fprintf(COM2,"\r\n"); 
2B0A:  MOVLW  0D
2B0C:  MOVLB  A
2B0E:  MOVWF  xDF
2B10:  MOVLB  0
2B12:  CALL   075A
2B16:  MOVLW  0A
2B18:  MOVLB  A
2B1A:  MOVWF  xDF
2B1C:  MOVLB  0
2B1E:  CALL   075A
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
2B22:  MOVLB  A
2B24:  MOVF   xBE,F
2B26:  BNZ   2B36
2B28:  MOVF   xBD,F
2B2A:  BNZ   2B36
2B2C:  MOVF   xBC,F
2B2E:  BNZ   2B36
2B30:  MOVF   xBB,W
2B32:  SUBLW  05
2B34:  BC    2B96
2B36:  MOVF   xBE,F
2B38:  BNZ   2B96
2B3A:  MOVF   xBD,F
2B3C:  BNZ   2B96
2B3E:  MOVF   xBC,F
2B40:  BNZ   2B96
2B42:  MOVF   xBB,W
2B44:  SUBLW  3B
2B46:  BNC   2B96
2B48:  MOVF   xC2,F
2B4A:  BNZ   2B5A
2B4C:  MOVF   xC1,F
2B4E:  BNZ   2B5A
2B50:  MOVF   xC0,F
2B52:  BNZ   2B5A
2B54:  MOVF   xBF,W
2B56:  SUBLW  64
2B58:  BC    2B96
2B5A:  MOVF   xC6,F
2B5C:  BNZ   2B6C
2B5E:  MOVF   xC5,F
2B60:  BNZ   2B6C
2B62:  MOVF   xC4,F
2B64:  BNZ   2B6C
2B66:  MOVF   xC3,W
2B68:  SUBLW  64
2B6A:  BC    2B96
2B6C:  MOVF   xCA,F
2B6E:  BNZ   2B7E
2B70:  MOVF   xC9,F
2B72:  BNZ   2B7E
2B74:  MOVF   xC8,F
2B76:  BNZ   2B7E
2B78:  MOVF   xC7,W
2B7A:  SUBLW  64
2B7C:  BC    2B96
2B7E:  MOVF   xCE,F
2B80:  BNZ   2B90
2B82:  MOVF   xCD,F
2B84:  BNZ   2B90
2B86:  MOVF   xCC,F
2B88:  BNZ   2B90
2B8A:  MOVF   xCB,W
2B8C:  SUBLW  64
2B8E:  BC    2B96
2B90:  MOVLW  00
2B92:  MOVWF  01
2B94:  BRA    2E14
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
2B96:  MOVF   xC2,F
2B98:  BNZ   2BA8
2B9A:  MOVF   xC1,F
2B9C:  BNZ   2BA8
2B9E:  MOVF   xC0,F
2BA0:  BNZ   2BA8
2BA2:  MOVF   xBF,W
2BA4:  SUBLW  05
2BA6:  BC    2C08
2BA8:  MOVF   xC2,F
2BAA:  BNZ   2C08
2BAC:  MOVF   xC1,F
2BAE:  BNZ   2C08
2BB0:  MOVF   xC0,F
2BB2:  BNZ   2C08
2BB4:  MOVF   xBF,W
2BB6:  SUBLW  3B
2BB8:  BNC   2C08
2BBA:  MOVF   xBE,F
2BBC:  BNZ   2BCC
2BBE:  MOVF   xBD,F
2BC0:  BNZ   2BCC
2BC2:  MOVF   xBC,F
2BC4:  BNZ   2BCC
2BC6:  MOVF   xBB,W
2BC8:  SUBLW  64
2BCA:  BC    2C08
2BCC:  MOVF   xC6,F
2BCE:  BNZ   2BDE
2BD0:  MOVF   xC5,F
2BD2:  BNZ   2BDE
2BD4:  MOVF   xC4,F
2BD6:  BNZ   2BDE
2BD8:  MOVF   xC3,W
2BDA:  SUBLW  64
2BDC:  BC    2C08
2BDE:  MOVF   xCA,F
2BE0:  BNZ   2BF0
2BE2:  MOVF   xC9,F
2BE4:  BNZ   2BF0
2BE6:  MOVF   xC8,F
2BE8:  BNZ   2BF0
2BEA:  MOVF   xC7,W
2BEC:  SUBLW  64
2BEE:  BC    2C08
2BF0:  MOVF   xCE,F
2BF2:  BNZ   2C02
2BF4:  MOVF   xCD,F
2BF6:  BNZ   2C02
2BF8:  MOVF   xCC,F
2BFA:  BNZ   2C02
2BFC:  MOVF   xCB,W
2BFE:  SUBLW  64
2C00:  BC    2C08
2C02:  MOVLW  01
2C04:  MOVWF  01
2C06:  BRA    2E14
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
2C08:  MOVF   xC6,F
2C0A:  BNZ   2C1A
2C0C:  MOVF   xC5,F
2C0E:  BNZ   2C1A
2C10:  MOVF   xC4,F
2C12:  BNZ   2C1A
2C14:  MOVF   xC3,W
2C16:  SUBLW  05
2C18:  BC    2C7A
2C1A:  MOVF   xC6,F
2C1C:  BNZ   2C7A
2C1E:  MOVF   xC5,F
2C20:  BNZ   2C7A
2C22:  MOVF   xC4,F
2C24:  BNZ   2C7A
2C26:  MOVF   xC3,W
2C28:  SUBLW  3B
2C2A:  BNC   2C7A
2C2C:  MOVF   xC2,F
2C2E:  BNZ   2C3E
2C30:  MOVF   xC1,F
2C32:  BNZ   2C3E
2C34:  MOVF   xC0,F
2C36:  BNZ   2C3E
2C38:  MOVF   xBF,W
2C3A:  SUBLW  64
2C3C:  BC    2C7A
2C3E:  MOVF   xBE,F
2C40:  BNZ   2C50
2C42:  MOVF   xBD,F
2C44:  BNZ   2C50
2C46:  MOVF   xBC,F
2C48:  BNZ   2C50
2C4A:  MOVF   xBB,W
2C4C:  SUBLW  64
2C4E:  BC    2C7A
2C50:  MOVF   xCA,F
2C52:  BNZ   2C62
2C54:  MOVF   xC9,F
2C56:  BNZ   2C62
2C58:  MOVF   xC8,F
2C5A:  BNZ   2C62
2C5C:  MOVF   xC7,W
2C5E:  SUBLW  64
2C60:  BC    2C7A
2C62:  MOVF   xCE,F
2C64:  BNZ   2C74
2C66:  MOVF   xCD,F
2C68:  BNZ   2C74
2C6A:  MOVF   xCC,F
2C6C:  BNZ   2C74
2C6E:  MOVF   xCB,W
2C70:  SUBLW  64
2C72:  BC    2C7A
2C74:  MOVLW  02
2C76:  MOVWF  01
2C78:  BRA    2E14
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2C7A:  MOVF   xCA,F
2C7C:  BNZ   2C8C
2C7E:  MOVF   xC9,F
2C80:  BNZ   2C8C
2C82:  MOVF   xC8,F
2C84:  BNZ   2C8C
2C86:  MOVF   xC7,W
2C88:  SUBLW  05
2C8A:  BC    2CEC
2C8C:  MOVF   xCA,F
2C8E:  BNZ   2CEC
2C90:  MOVF   xC9,F
2C92:  BNZ   2CEC
2C94:  MOVF   xC8,F
2C96:  BNZ   2CEC
2C98:  MOVF   xC7,W
2C9A:  SUBLW  3B
2C9C:  BNC   2CEC
2C9E:  MOVF   xC2,F
2CA0:  BNZ   2CB0
2CA2:  MOVF   xC1,F
2CA4:  BNZ   2CB0
2CA6:  MOVF   xC0,F
2CA8:  BNZ   2CB0
2CAA:  MOVF   xBF,W
2CAC:  SUBLW  64
2CAE:  BC    2CEC
2CB0:  MOVF   xC6,F
2CB2:  BNZ   2CC2
2CB4:  MOVF   xC5,F
2CB6:  BNZ   2CC2
2CB8:  MOVF   xC4,F
2CBA:  BNZ   2CC2
2CBC:  MOVF   xC3,W
2CBE:  SUBLW  64
2CC0:  BC    2CEC
2CC2:  MOVF   xBE,F
2CC4:  BNZ   2CD4
2CC6:  MOVF   xBD,F
2CC8:  BNZ   2CD4
2CCA:  MOVF   xBC,F
2CCC:  BNZ   2CD4
2CCE:  MOVF   xBB,W
2CD0:  SUBLW  64
2CD2:  BC    2CEC
2CD4:  MOVF   xCE,F
2CD6:  BNZ   2CE6
2CD8:  MOVF   xCD,F
2CDA:  BNZ   2CE6
2CDC:  MOVF   xCC,F
2CDE:  BNZ   2CE6
2CE0:  MOVF   xCB,W
2CE2:  SUBLW  64
2CE4:  BC    2CEC
2CE6:  MOVLW  03
2CE8:  MOVWF  01
2CEA:  BRA    2E14
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2CEC:  MOVF   xCE,F
2CEE:  BNZ   2CFE
2CF0:  MOVF   xCD,F
2CF2:  BNZ   2CFE
2CF4:  MOVF   xCC,F
2CF6:  BNZ   2CFE
2CF8:  MOVF   xCB,W
2CFA:  SUBLW  05
2CFC:  BC    2D5E
2CFE:  MOVF   xCE,F
2D00:  BNZ   2D5E
2D02:  MOVF   xCD,F
2D04:  BNZ   2D5E
2D06:  MOVF   xCC,F
2D08:  BNZ   2D5E
2D0A:  MOVF   xCB,W
2D0C:  SUBLW  3B
2D0E:  BNC   2D5E
2D10:  MOVF   xC2,F
2D12:  BNZ   2D22
2D14:  MOVF   xC1,F
2D16:  BNZ   2D22
2D18:  MOVF   xC0,F
2D1A:  BNZ   2D22
2D1C:  MOVF   xBF,W
2D1E:  SUBLW  64
2D20:  BC    2D5E
2D22:  MOVF   xC6,F
2D24:  BNZ   2D34
2D26:  MOVF   xC5,F
2D28:  BNZ   2D34
2D2A:  MOVF   xC4,F
2D2C:  BNZ   2D34
2D2E:  MOVF   xC3,W
2D30:  SUBLW  64
2D32:  BC    2D5E
2D34:  MOVF   xCA,F
2D36:  BNZ   2D46
2D38:  MOVF   xC9,F
2D3A:  BNZ   2D46
2D3C:  MOVF   xC8,F
2D3E:  BNZ   2D46
2D40:  MOVF   xC7,W
2D42:  SUBLW  64
2D44:  BC    2D5E
2D46:  MOVF   xBE,F
2D48:  BNZ   2D58
2D4A:  MOVF   xBD,F
2D4C:  BNZ   2D58
2D4E:  MOVF   xBC,F
2D50:  BNZ   2D58
2D52:  MOVF   xBB,W
2D54:  SUBLW  64
2D56:  BC    2D5E
2D58:  MOVLW  04
2D5A:  MOVWF  01
2D5C:  BRA    2E14
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2D5E:  MOVF   xCE,F
2D60:  BNZ   2D72
2D62:  MOVF   xCD,F
2D64:  BNZ   2D72
2D66:  MOVF   xCC,F
2D68:  BNZ   2D72
2D6A:  MOVF   xCB,W
2D6C:  SUBLW  C8
2D6E:  BTFSC  FD8.0
2D70:  BRA    2E10
2D72:  MOVF   xBE,F
2D74:  BTFSS  FD8.2
2D76:  BRA    2E10
2D78:  MOVF   xBD,F
2D7A:  BTFSS  FD8.2
2D7C:  BRA    2E10
2D7E:  MOVF   xBC,F
2D80:  BTFSS  FD8.2
2D82:  BRA    2E10
2D84:  MOVF   xBB,W
2D86:  SUBLW  B3
2D88:  BNC   2E10
2D8A:  MOVF   xBE,F
2D8C:  BNZ   2D9C
2D8E:  MOVF   xBD,F
2D90:  BNZ   2D9C
2D92:  MOVF   xBC,F
2D94:  BNZ   2D9C
2D96:  MOVF   xBB,W
2D98:  SUBLW  64
2D9A:  BC    2E10
2D9C:  MOVF   xC2,F
2D9E:  BNZ   2E10
2DA0:  MOVF   xC1,F
2DA2:  BNZ   2E10
2DA4:  MOVF   xC0,F
2DA6:  BNZ   2E10
2DA8:  MOVF   xBF,W
2DAA:  SUBLW  B3
2DAC:  BNC   2E10
2DAE:  MOVF   xC2,F
2DB0:  BNZ   2DC0
2DB2:  MOVF   xC1,F
2DB4:  BNZ   2DC0
2DB6:  MOVF   xC0,F
2DB8:  BNZ   2DC0
2DBA:  MOVF   xBF,W
2DBC:  SUBLW  64
2DBE:  BC    2E10
2DC0:  MOVF   xC6,F
2DC2:  BNZ   2E10
2DC4:  MOVF   xC5,F
2DC6:  BNZ   2E10
2DC8:  MOVF   xC4,F
2DCA:  BNZ   2E10
2DCC:  MOVF   xC3,W
2DCE:  SUBLW  B3
2DD0:  BNC   2E10
2DD2:  MOVF   xC6,F
2DD4:  BNZ   2DE4
2DD6:  MOVF   xC5,F
2DD8:  BNZ   2DE4
2DDA:  MOVF   xC4,F
2DDC:  BNZ   2DE4
2DDE:  MOVF   xC3,W
2DE0:  SUBLW  64
2DE2:  BC    2E10
2DE4:  MOVF   xCA,F
2DE6:  BNZ   2E10
2DE8:  MOVF   xC9,F
2DEA:  BNZ   2E10
2DEC:  MOVF   xC8,F
2DEE:  BNZ   2E10
2DF0:  MOVF   xC7,W
2DF2:  SUBLW  B3
2DF4:  BNC   2E10
2DF6:  MOVF   xCA,F
2DF8:  BNZ   2E08
2DFA:  MOVF   xC9,F
2DFC:  BNZ   2E08
2DFE:  MOVF   xC8,F
2E00:  BNZ   2E08
2E02:  MOVF   xC7,W
2E04:  SUBLW  64
2E06:  BC    2E10
2E08:  MOVLW  04
2E0A:  MOVWF  01
2E0C:  BRA    2E14
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2E0E:  BRA    2E14
2E10:  MOVLW  FF
2E12:  MOVWF  01
.................... } 
2E14:  MOVLB  0
2E16:  GOTO   3668 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
2E1A:  MOVLB  A
2E1C:  CLRF   xBE
2E1E:  CLRF   xBD
2E20:  CLRF   xBC
2E22:  CLRF   xBB
2E24:  CLRF   xC2
2E26:  CLRF   xC1
2E28:  CLRF   xC0
2E2A:  CLRF   xBF
2E2C:  CLRF   xC6
2E2E:  CLRF   xC5
2E30:  CLRF   xC4
2E32:  CLRF   xC3
2E34:  CLRF   xCA
2E36:  CLRF   xC9
2E38:  CLRF   xC8
2E3A:  CLRF   xC7
2E3C:  CLRF   xCE
2E3E:  CLRF   xCD
2E40:  CLRF   xCC
2E42:  CLRF   xCB
2E44:  CLRF   xD2
2E46:  CLRF   xD1
2E48:  CLRF   xD0
2E4A:  CLRF   xCF
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2E4C:  CLRF   xBA
2E4E:  CLRF   xB9
2E50:  MOVF   xBA,W
2E52:  SUBLW  01
2E54:  BNC   2EF4
2E56:  BNZ   2E5E
2E58:  MOVF   xB9,W
2E5A:  SUBLW  F3
2E5C:  BNC   2EF4
....................    { 
....................       col_0=read_col(0)+col_0; 
2E5E:  CLRF   xD3
2E60:  MOVLB  0
2E62:  CALL   258C
2E66:  MOVF   01,W
2E68:  MOVLB  A
2E6A:  ADDWF  xBB,F
2E6C:  MOVLW  00
2E6E:  ADDWFC xBC,F
2E70:  ADDWFC xBD,F
2E72:  ADDWFC xBE,F
....................       col_1=read_col(1)+col_1; 
2E74:  MOVLW  01
2E76:  MOVWF  xD3
2E78:  MOVLB  0
2E7A:  CALL   258C
2E7E:  MOVF   01,W
2E80:  MOVLB  A
2E82:  ADDWF  xBF,F
2E84:  MOVLW  00
2E86:  ADDWFC xC0,F
2E88:  ADDWFC xC1,F
2E8A:  ADDWFC xC2,F
....................       col_2=read_col(2)+col_2; 
2E8C:  MOVLW  02
2E8E:  MOVWF  xD3
2E90:  MOVLB  0
2E92:  CALL   258C
2E96:  MOVF   01,W
2E98:  MOVLB  A
2E9A:  ADDWF  xC3,F
2E9C:  MOVLW  00
2E9E:  ADDWFC xC4,F
2EA0:  ADDWFC xC5,F
2EA2:  ADDWFC xC6,F
....................       col_3=read_col(3)+col_3; 
2EA4:  MOVLW  03
2EA6:  MOVWF  xD3
2EA8:  MOVLB  0
2EAA:  CALL   258C
2EAE:  MOVF   01,W
2EB0:  MOVLB  A
2EB2:  ADDWF  xC7,F
2EB4:  MOVLW  00
2EB6:  ADDWFC xC8,F
2EB8:  ADDWFC xC9,F
2EBA:  ADDWFC xCA,F
....................       col_4=read_col(4)+col_4; 
2EBC:  MOVLW  04
2EBE:  MOVWF  xD3
2EC0:  MOVLB  0
2EC2:  CALL   258C
2EC6:  MOVF   01,W
2EC8:  MOVLB  A
2ECA:  ADDWF  xCB,F
2ECC:  MOVLW  00
2ECE:  ADDWFC xCC,F
2ED0:  ADDWFC xCD,F
2ED2:  ADDWFC xCE,F
....................       col_5=read_col(5)+col_5; 
2ED4:  MOVLW  05
2ED6:  MOVWF  xD3
2ED8:  MOVLB  0
2EDA:  CALL   258C
2EDE:  MOVF   01,W
2EE0:  MOVLB  A
2EE2:  ADDWF  xCF,F
2EE4:  MOVLW  00
2EE6:  ADDWFC xD0,F
2EE8:  ADDWFC xD1,F
2EEA:  ADDWFC xD2,F
....................    } 
2EEC:  INCF   xB9,F
2EEE:  BTFSC  FD8.2
2EF0:  INCF   xBA,F
2EF2:  BRA    2E50
....................    col_0=col_0/500; 
2EF4:  BCF    FD8.1
2EF6:  MOVFF  ABE,AE2
2EFA:  MOVFF  ABD,AE1
2EFE:  MOVFF  ABC,AE0
2F02:  MOVFF  ABB,ADF
2F06:  CLRF   xE6
2F08:  CLRF   xE5
2F0A:  MOVLW  01
2F0C:  MOVWF  xE4
2F0E:  MOVLW  F4
2F10:  MOVWF  xE3
2F12:  MOVLB  0
2F14:  CALL   269A
2F18:  MOVFF  03,ABE
2F1C:  MOVFF  02,ABD
2F20:  MOVFF  01,ABC
2F24:  MOVFF  00,ABB
....................    col_1=col_1/500; 
2F28:  BCF    FD8.1
2F2A:  MOVFF  AC2,AE2
2F2E:  MOVFF  AC1,AE1
2F32:  MOVFF  AC0,AE0
2F36:  MOVFF  ABF,ADF
2F3A:  MOVLB  A
2F3C:  CLRF   xE6
2F3E:  CLRF   xE5
2F40:  MOVLW  01
2F42:  MOVWF  xE4
2F44:  MOVLW  F4
2F46:  MOVWF  xE3
2F48:  MOVLB  0
2F4A:  CALL   269A
2F4E:  MOVFF  03,AC2
2F52:  MOVFF  02,AC1
2F56:  MOVFF  01,AC0
2F5A:  MOVFF  00,ABF
....................    col_2=col_2/500; 
2F5E:  BCF    FD8.1
2F60:  MOVFF  AC6,AE2
2F64:  MOVFF  AC5,AE1
2F68:  MOVFF  AC4,AE0
2F6C:  MOVFF  AC3,ADF
2F70:  MOVLB  A
2F72:  CLRF   xE6
2F74:  CLRF   xE5
2F76:  MOVLW  01
2F78:  MOVWF  xE4
2F7A:  MOVLW  F4
2F7C:  MOVWF  xE3
2F7E:  MOVLB  0
2F80:  CALL   269A
2F84:  MOVFF  03,AC6
2F88:  MOVFF  02,AC5
2F8C:  MOVFF  01,AC4
2F90:  MOVFF  00,AC3
....................    col_3=col_3/500; 
2F94:  BCF    FD8.1
2F96:  MOVFF  ACA,AE2
2F9A:  MOVFF  AC9,AE1
2F9E:  MOVFF  AC8,AE0
2FA2:  MOVFF  AC7,ADF
2FA6:  MOVLB  A
2FA8:  CLRF   xE6
2FAA:  CLRF   xE5
2FAC:  MOVLW  01
2FAE:  MOVWF  xE4
2FB0:  MOVLW  F4
2FB2:  MOVWF  xE3
2FB4:  MOVLB  0
2FB6:  CALL   269A
2FBA:  MOVFF  03,ACA
2FBE:  MOVFF  02,AC9
2FC2:  MOVFF  01,AC8
2FC6:  MOVFF  00,AC7
....................    col_4=col_4/500; 
2FCA:  BCF    FD8.1
2FCC:  MOVFF  ACE,AE2
2FD0:  MOVFF  ACD,AE1
2FD4:  MOVFF  ACC,AE0
2FD8:  MOVFF  ACB,ADF
2FDC:  MOVLB  A
2FDE:  CLRF   xE6
2FE0:  CLRF   xE5
2FE2:  MOVLW  01
2FE4:  MOVWF  xE4
2FE6:  MOVLW  F4
2FE8:  MOVWF  xE3
2FEA:  MOVLB  0
2FEC:  CALL   269A
2FF0:  MOVFF  03,ACE
2FF4:  MOVFF  02,ACD
2FF8:  MOVFF  01,ACC
2FFC:  MOVFF  00,ACB
....................    col_5=col_5/500; 
3000:  BCF    FD8.1
3002:  MOVFF  AD2,AE2
3006:  MOVFF  AD1,AE1
300A:  MOVFF  AD0,AE0
300E:  MOVFF  ACF,ADF
3012:  MOVLB  A
3014:  CLRF   xE6
3016:  CLRF   xE5
3018:  MOVLW  01
301A:  MOVWF  xE4
301C:  MOVLW  F4
301E:  MOVWF  xE3
3020:  MOVLB  0
3022:  CALL   269A
3026:  MOVFF  03,AD2
302A:  MOVFF  02,AD1
302E:  MOVFF  01,AD0
3032:  MOVFF  00,ACF
....................    if(keydebug_en) 
3036:  MOVLB  1
3038:  MOVF   x0B,F
303A:  BTFSC  FD8.2
303C:  BRA    3206
....................    { 
....................       fprintf(COM2,"\r\n");      
303E:  MOVLW  0D
3040:  MOVLB  A
3042:  MOVWF  xDF
3044:  MOVLB  0
3046:  CALL   075A
304A:  MOVLW  0A
304C:  MOVLB  A
304E:  MOVWF  xDF
3050:  MOVLB  0
3052:  CALL   075A
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
3056:  MOVLW  6C
3058:  MOVWF  FF6
305A:  MOVLW  04
305C:  MOVWF  FF7
305E:  MOVLW  07
3060:  MOVLB  A
3062:  MOVWF  xD3
3064:  MOVLB  0
3066:  CALL   1718
306A:  MOVLW  41
306C:  MOVWF  FE9
306E:  MOVFF  ABE,AD6
3072:  MOVFF  ABD,AD5
3076:  MOVFF  ABC,AD4
307A:  MOVFF  ABB,AD3
307E:  CALL   272E
3082:  MOVLW  0D
3084:  MOVLB  A
3086:  MOVWF  xDF
3088:  MOVLB  0
308A:  CALL   075A
308E:  MOVLW  0A
3090:  MOVLB  A
3092:  MOVWF  xDF
3094:  MOVLB  0
3096:  CALL   075A
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
309A:  MOVLW  7A
309C:  MOVWF  FF6
309E:  MOVLW  04
30A0:  MOVWF  FF7
30A2:  MOVLW  07
30A4:  MOVLB  A
30A6:  MOVWF  xD3
30A8:  MOVLB  0
30AA:  CALL   1718
30AE:  MOVLW  41
30B0:  MOVWF  FE9
30B2:  MOVFF  AC2,AD6
30B6:  MOVFF  AC1,AD5
30BA:  MOVFF  AC0,AD4
30BE:  MOVFF  ABF,AD3
30C2:  CALL   272E
30C6:  MOVLW  0D
30C8:  MOVLB  A
30CA:  MOVWF  xDF
30CC:  MOVLB  0
30CE:  CALL   075A
30D2:  MOVLW  0A
30D4:  MOVLB  A
30D6:  MOVWF  xDF
30D8:  MOVLB  0
30DA:  CALL   075A
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
30DE:  MOVLW  88
30E0:  MOVWF  FF6
30E2:  MOVLW  04
30E4:  MOVWF  FF7
30E6:  MOVLW  07
30E8:  MOVLB  A
30EA:  MOVWF  xD3
30EC:  MOVLB  0
30EE:  CALL   1718
30F2:  MOVLW  41
30F4:  MOVWF  FE9
30F6:  MOVFF  AC6,AD6
30FA:  MOVFF  AC5,AD5
30FE:  MOVFF  AC4,AD4
3102:  MOVFF  AC3,AD3
3106:  CALL   272E
310A:  MOVLW  0D
310C:  MOVLB  A
310E:  MOVWF  xDF
3110:  MOVLB  0
3112:  CALL   075A
3116:  MOVLW  0A
3118:  MOVLB  A
311A:  MOVWF  xDF
311C:  MOVLB  0
311E:  CALL   075A
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
3122:  MOVLW  96
3124:  MOVWF  FF6
3126:  MOVLW  04
3128:  MOVWF  FF7
312A:  MOVLW  07
312C:  MOVLB  A
312E:  MOVWF  xD3
3130:  MOVLB  0
3132:  CALL   1718
3136:  MOVLW  41
3138:  MOVWF  FE9
313A:  MOVFF  ACA,AD6
313E:  MOVFF  AC9,AD5
3142:  MOVFF  AC8,AD4
3146:  MOVFF  AC7,AD3
314A:  CALL   272E
314E:  MOVLW  0D
3150:  MOVLB  A
3152:  MOVWF  xDF
3154:  MOVLB  0
3156:  CALL   075A
315A:  MOVLW  0A
315C:  MOVLB  A
315E:  MOVWF  xDF
3160:  MOVLB  0
3162:  CALL   075A
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
3166:  MOVLW  A4
3168:  MOVWF  FF6
316A:  MOVLW  04
316C:  MOVWF  FF7
316E:  MOVLW  07
3170:  MOVLB  A
3172:  MOVWF  xD3
3174:  MOVLB  0
3176:  CALL   1718
317A:  MOVLW  41
317C:  MOVWF  FE9
317E:  MOVFF  ACE,AD6
3182:  MOVFF  ACD,AD5
3186:  MOVFF  ACC,AD4
318A:  MOVFF  ACB,AD3
318E:  CALL   272E
3192:  MOVLW  0D
3194:  MOVLB  A
3196:  MOVWF  xDF
3198:  MOVLB  0
319A:  CALL   075A
319E:  MOVLW  0A
31A0:  MOVLB  A
31A2:  MOVWF  xDF
31A4:  MOVLB  0
31A6:  CALL   075A
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
31AA:  MOVLW  B2
31AC:  MOVWF  FF6
31AE:  MOVLW  04
31B0:  MOVWF  FF7
31B2:  MOVLW  07
31B4:  MOVLB  A
31B6:  MOVWF  xD3
31B8:  MOVLB  0
31BA:  CALL   1718
31BE:  MOVLW  41
31C0:  MOVWF  FE9
31C2:  MOVFF  AD2,AD6
31C6:  MOVFF  AD1,AD5
31CA:  MOVFF  AD0,AD4
31CE:  MOVFF  ACF,AD3
31D2:  CALL   272E
31D6:  MOVLW  0D
31D8:  MOVLB  A
31DA:  MOVWF  xDF
31DC:  MOVLB  0
31DE:  CALL   075A
31E2:  MOVLW  0A
31E4:  MOVLB  A
31E6:  MOVWF  xDF
31E8:  MOVLB  0
31EA:  CALL   075A
....................       fprintf(COM2,"\r\n"); 
31EE:  MOVLW  0D
31F0:  MOVLB  A
31F2:  MOVWF  xDF
31F4:  MOVLB  0
31F6:  CALL   075A
31FA:  MOVLW  0A
31FC:  MOVLB  A
31FE:  MOVWF  xDF
3200:  MOVLB  0
3202:  CALL   075A
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
3206:  MOVLB  A
3208:  MOVF   xBE,F
320A:  BNZ   321A
320C:  MOVF   xBD,F
320E:  BNZ   321A
3210:  MOVF   xBC,F
3212:  BNZ   321A
3214:  MOVF   xBB,W
3216:  SUBLW  05
3218:  BC    328C
321A:  MOVF   xBE,F
321C:  BNZ   328C
321E:  MOVF   xBD,F
3220:  BNZ   328C
3222:  MOVF   xBC,F
3224:  BNZ   328C
3226:  MOVF   xBB,W
3228:  SUBLW  3B
322A:  BNC   328C
322C:  MOVF   xC2,F
322E:  BNZ   323E
3230:  MOVF   xC1,F
3232:  BNZ   323E
3234:  MOVF   xC0,F
3236:  BNZ   323E
3238:  MOVF   xBF,W
323A:  SUBLW  64
323C:  BC    328C
323E:  MOVF   xC6,F
3240:  BNZ   3250
3242:  MOVF   xC5,F
3244:  BNZ   3250
3246:  MOVF   xC4,F
3248:  BNZ   3250
324A:  MOVF   xC3,W
324C:  SUBLW  64
324E:  BC    328C
3250:  MOVF   xCA,F
3252:  BNZ   3262
3254:  MOVF   xC9,F
3256:  BNZ   3262
3258:  MOVF   xC8,F
325A:  BNZ   3262
325C:  MOVF   xC7,W
325E:  SUBLW  64
3260:  BC    328C
3262:  MOVF   xCE,F
3264:  BNZ   3274
3266:  MOVF   xCD,F
3268:  BNZ   3274
326A:  MOVF   xCC,F
326C:  BNZ   3274
326E:  MOVF   xCB,W
3270:  SUBLW  64
3272:  BC    328C
3274:  MOVF   xD2,F
3276:  BNZ   3286
3278:  MOVF   xD1,F
327A:  BNZ   3286
327C:  MOVF   xD0,F
327E:  BNZ   3286
3280:  MOVF   xCF,W
3282:  SUBLW  64
3284:  BC    328C
3286:  MOVLW  00
3288:  MOVWF  01
328A:  BRA    3604
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
328C:  MOVF   xC2,F
328E:  BNZ   329E
3290:  MOVF   xC1,F
3292:  BNZ   329E
3294:  MOVF   xC0,F
3296:  BNZ   329E
3298:  MOVF   xBF,W
329A:  SUBLW  05
329C:  BC    3310
329E:  MOVF   xC2,F
32A0:  BNZ   3310
32A2:  MOVF   xC1,F
32A4:  BNZ   3310
32A6:  MOVF   xC0,F
32A8:  BNZ   3310
32AA:  MOVF   xBF,W
32AC:  SUBLW  3B
32AE:  BNC   3310
32B0:  MOVF   xBE,F
32B2:  BNZ   32C2
32B4:  MOVF   xBD,F
32B6:  BNZ   32C2
32B8:  MOVF   xBC,F
32BA:  BNZ   32C2
32BC:  MOVF   xBB,W
32BE:  SUBLW  64
32C0:  BC    3310
32C2:  MOVF   xC6,F
32C4:  BNZ   32D4
32C6:  MOVF   xC5,F
32C8:  BNZ   32D4
32CA:  MOVF   xC4,F
32CC:  BNZ   32D4
32CE:  MOVF   xC3,W
32D0:  SUBLW  64
32D2:  BC    3310
32D4:  MOVF   xCA,F
32D6:  BNZ   32E6
32D8:  MOVF   xC9,F
32DA:  BNZ   32E6
32DC:  MOVF   xC8,F
32DE:  BNZ   32E6
32E0:  MOVF   xC7,W
32E2:  SUBLW  64
32E4:  BC    3310
32E6:  MOVF   xCE,F
32E8:  BNZ   32F8
32EA:  MOVF   xCD,F
32EC:  BNZ   32F8
32EE:  MOVF   xCC,F
32F0:  BNZ   32F8
32F2:  MOVF   xCB,W
32F4:  SUBLW  64
32F6:  BC    3310
32F8:  MOVF   xD2,F
32FA:  BNZ   330A
32FC:  MOVF   xD1,F
32FE:  BNZ   330A
3300:  MOVF   xD0,F
3302:  BNZ   330A
3304:  MOVF   xCF,W
3306:  SUBLW  64
3308:  BC    3310
330A:  MOVLW  01
330C:  MOVWF  01
330E:  BRA    3604
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
3310:  MOVF   xC6,F
3312:  BNZ   3322
3314:  MOVF   xC5,F
3316:  BNZ   3322
3318:  MOVF   xC4,F
331A:  BNZ   3322
331C:  MOVF   xC3,W
331E:  SUBLW  05
3320:  BC    3394
3322:  MOVF   xC6,F
3324:  BNZ   3394
3326:  MOVF   xC5,F
3328:  BNZ   3394
332A:  MOVF   xC4,F
332C:  BNZ   3394
332E:  MOVF   xC3,W
3330:  SUBLW  3B
3332:  BNC   3394
3334:  MOVF   xC2,F
3336:  BNZ   3346
3338:  MOVF   xC1,F
333A:  BNZ   3346
333C:  MOVF   xC0,F
333E:  BNZ   3346
3340:  MOVF   xBF,W
3342:  SUBLW  64
3344:  BC    3394
3346:  MOVF   xBE,F
3348:  BNZ   3358
334A:  MOVF   xBD,F
334C:  BNZ   3358
334E:  MOVF   xBC,F
3350:  BNZ   3358
3352:  MOVF   xBB,W
3354:  SUBLW  64
3356:  BC    3394
3358:  MOVF   xCA,F
335A:  BNZ   336A
335C:  MOVF   xC9,F
335E:  BNZ   336A
3360:  MOVF   xC8,F
3362:  BNZ   336A
3364:  MOVF   xC7,W
3366:  SUBLW  64
3368:  BC    3394
336A:  MOVF   xCE,F
336C:  BNZ   337C
336E:  MOVF   xCD,F
3370:  BNZ   337C
3372:  MOVF   xCC,F
3374:  BNZ   337C
3376:  MOVF   xCB,W
3378:  SUBLW  64
337A:  BC    3394
337C:  MOVF   xD2,F
337E:  BNZ   338E
3380:  MOVF   xD1,F
3382:  BNZ   338E
3384:  MOVF   xD0,F
3386:  BNZ   338E
3388:  MOVF   xCF,W
338A:  SUBLW  64
338C:  BC    3394
338E:  MOVLW  02
3390:  MOVWF  01
3392:  BRA    3604
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
3394:  MOVF   xCA,F
3396:  BNZ   33A6
3398:  MOVF   xC9,F
339A:  BNZ   33A6
339C:  MOVF   xC8,F
339E:  BNZ   33A6
33A0:  MOVF   xC7,W
33A2:  SUBLW  05
33A4:  BC    3418
33A6:  MOVF   xCA,F
33A8:  BNZ   3418
33AA:  MOVF   xC9,F
33AC:  BNZ   3418
33AE:  MOVF   xC8,F
33B0:  BNZ   3418
33B2:  MOVF   xC7,W
33B4:  SUBLW  3B
33B6:  BNC   3418
33B8:  MOVF   xC2,F
33BA:  BNZ   33CA
33BC:  MOVF   xC1,F
33BE:  BNZ   33CA
33C0:  MOVF   xC0,F
33C2:  BNZ   33CA
33C4:  MOVF   xBF,W
33C6:  SUBLW  64
33C8:  BC    3418
33CA:  MOVF   xC6,F
33CC:  BNZ   33DC
33CE:  MOVF   xC5,F
33D0:  BNZ   33DC
33D2:  MOVF   xC4,F
33D4:  BNZ   33DC
33D6:  MOVF   xC3,W
33D8:  SUBLW  64
33DA:  BC    3418
33DC:  MOVF   xBE,F
33DE:  BNZ   33EE
33E0:  MOVF   xBD,F
33E2:  BNZ   33EE
33E4:  MOVF   xBC,F
33E6:  BNZ   33EE
33E8:  MOVF   xBB,W
33EA:  SUBLW  64
33EC:  BC    3418
33EE:  MOVF   xCE,F
33F0:  BNZ   3400
33F2:  MOVF   xCD,F
33F4:  BNZ   3400
33F6:  MOVF   xCC,F
33F8:  BNZ   3400
33FA:  MOVF   xCB,W
33FC:  SUBLW  64
33FE:  BC    3418
3400:  MOVF   xD2,F
3402:  BNZ   3412
3404:  MOVF   xD1,F
3406:  BNZ   3412
3408:  MOVF   xD0,F
340A:  BNZ   3412
340C:  MOVF   xCF,W
340E:  SUBLW  64
3410:  BC    3418
3412:  MOVLW  03
3414:  MOVWF  01
3416:  BRA    3604
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
3418:  MOVF   xCE,F
341A:  BNZ   342A
341C:  MOVF   xCD,F
341E:  BNZ   342A
3420:  MOVF   xCC,F
3422:  BNZ   342A
3424:  MOVF   xCB,W
3426:  SUBLW  05
3428:  BC    349C
342A:  MOVF   xCE,F
342C:  BNZ   349C
342E:  MOVF   xCD,F
3430:  BNZ   349C
3432:  MOVF   xCC,F
3434:  BNZ   349C
3436:  MOVF   xCB,W
3438:  SUBLW  3B
343A:  BNC   349C
343C:  MOVF   xC2,F
343E:  BNZ   344E
3440:  MOVF   xC1,F
3442:  BNZ   344E
3444:  MOVF   xC0,F
3446:  BNZ   344E
3448:  MOVF   xBF,W
344A:  SUBLW  64
344C:  BC    349C
344E:  MOVF   xC6,F
3450:  BNZ   3460
3452:  MOVF   xC5,F
3454:  BNZ   3460
3456:  MOVF   xC4,F
3458:  BNZ   3460
345A:  MOVF   xC3,W
345C:  SUBLW  64
345E:  BC    349C
3460:  MOVF   xCA,F
3462:  BNZ   3472
3464:  MOVF   xC9,F
3466:  BNZ   3472
3468:  MOVF   xC8,F
346A:  BNZ   3472
346C:  MOVF   xC7,W
346E:  SUBLW  64
3470:  BC    349C
3472:  MOVF   xBE,F
3474:  BNZ   3484
3476:  MOVF   xBD,F
3478:  BNZ   3484
347A:  MOVF   xBC,F
347C:  BNZ   3484
347E:  MOVF   xBB,W
3480:  SUBLW  64
3482:  BC    349C
3484:  MOVF   xD2,F
3486:  BNZ   3496
3488:  MOVF   xD1,F
348A:  BNZ   3496
348C:  MOVF   xD0,F
348E:  BNZ   3496
3490:  MOVF   xCF,W
3492:  SUBLW  64
3494:  BC    349C
3496:  MOVLW  04
3498:  MOVWF  01
349A:  BRA    3604
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
349C:  MOVF   xD2,F
349E:  BNZ   34AE
34A0:  MOVF   xD1,F
34A2:  BNZ   34AE
34A4:  MOVF   xD0,F
34A6:  BNZ   34AE
34A8:  MOVF   xCF,W
34AA:  SUBLW  05
34AC:  BC    3520
34AE:  MOVF   xD2,F
34B0:  BNZ   3520
34B2:  MOVF   xD1,F
34B4:  BNZ   3520
34B6:  MOVF   xD0,F
34B8:  BNZ   3520
34BA:  MOVF   xCF,W
34BC:  SUBLW  3B
34BE:  BNC   3520
34C0:  MOVF   xC2,F
34C2:  BNZ   34D2
34C4:  MOVF   xC1,F
34C6:  BNZ   34D2
34C8:  MOVF   xC0,F
34CA:  BNZ   34D2
34CC:  MOVF   xBF,W
34CE:  SUBLW  64
34D0:  BC    3520
34D2:  MOVF   xC6,F
34D4:  BNZ   34E4
34D6:  MOVF   xC5,F
34D8:  BNZ   34E4
34DA:  MOVF   xC4,F
34DC:  BNZ   34E4
34DE:  MOVF   xC3,W
34E0:  SUBLW  64
34E2:  BC    3520
34E4:  MOVF   xCA,F
34E6:  BNZ   34F6
34E8:  MOVF   xC9,F
34EA:  BNZ   34F6
34EC:  MOVF   xC8,F
34EE:  BNZ   34F6
34F0:  MOVF   xC7,W
34F2:  SUBLW  64
34F4:  BC    3520
34F6:  MOVF   xCE,F
34F8:  BNZ   3508
34FA:  MOVF   xCD,F
34FC:  BNZ   3508
34FE:  MOVF   xCC,F
3500:  BNZ   3508
3502:  MOVF   xCB,W
3504:  SUBLW  64
3506:  BC    3520
3508:  MOVF   xBE,F
350A:  BNZ   351A
350C:  MOVF   xBD,F
350E:  BNZ   351A
3510:  MOVF   xBC,F
3512:  BNZ   351A
3514:  MOVF   xBB,W
3516:  SUBLW  64
3518:  BC    3520
351A:  MOVLW  05
351C:  MOVWF  01
351E:  BRA    3604
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
3520:  MOVF   xD2,F
3522:  BNZ   3534
3524:  MOVF   xD1,F
3526:  BNZ   3534
3528:  MOVF   xD0,F
352A:  BNZ   3534
352C:  MOVF   xCF,W
352E:  SUBLW  C8
3530:  BTFSC  FD8.0
3532:  BRA    3600
3534:  MOVF   xBE,F
3536:  BTFSS  FD8.2
3538:  BRA    3600
353A:  MOVF   xBD,F
353C:  BTFSS  FD8.2
353E:  BRA    3600
3540:  MOVF   xBC,F
3542:  BTFSS  FD8.2
3544:  BRA    3600
3546:  MOVF   xBB,W
3548:  SUBLW  B3
354A:  BTFSS  FD8.0
354C:  BRA    3600
354E:  MOVF   xBE,F
3550:  BNZ   3562
3552:  MOVF   xBD,F
3554:  BNZ   3562
3556:  MOVF   xBC,F
3558:  BNZ   3562
355A:  MOVF   xBB,W
355C:  SUBLW  64
355E:  BTFSC  FD8.0
3560:  BRA    3600
3562:  MOVF   xC2,F
3564:  BTFSS  FD8.2
3566:  BRA    3600
3568:  MOVF   xC1,F
356A:  BTFSS  FD8.2
356C:  BRA    3600
356E:  MOVF   xC0,F
3570:  BTFSS  FD8.2
3572:  BRA    3600
3574:  MOVF   xBF,W
3576:  SUBLW  B3
3578:  BNC   3600
357A:  MOVF   xC2,F
357C:  BNZ   358C
357E:  MOVF   xC1,F
3580:  BNZ   358C
3582:  MOVF   xC0,F
3584:  BNZ   358C
3586:  MOVF   xBF,W
3588:  SUBLW  64
358A:  BC    3600
358C:  MOVF   xC6,F
358E:  BNZ   3600
3590:  MOVF   xC5,F
3592:  BNZ   3600
3594:  MOVF   xC4,F
3596:  BNZ   3600
3598:  MOVF   xC3,W
359A:  SUBLW  B3
359C:  BNC   3600
359E:  MOVF   xC6,F
35A0:  BNZ   35B0
35A2:  MOVF   xC5,F
35A4:  BNZ   35B0
35A6:  MOVF   xC4,F
35A8:  BNZ   35B0
35AA:  MOVF   xC3,W
35AC:  SUBLW  64
35AE:  BC    3600
35B0:  MOVF   xCA,F
35B2:  BNZ   3600
35B4:  MOVF   xC9,F
35B6:  BNZ   3600
35B8:  MOVF   xC8,F
35BA:  BNZ   3600
35BC:  MOVF   xC7,W
35BE:  SUBLW  B3
35C0:  BNC   3600
35C2:  MOVF   xCA,F
35C4:  BNZ   35D4
35C6:  MOVF   xC9,F
35C8:  BNZ   35D4
35CA:  MOVF   xC8,F
35CC:  BNZ   35D4
35CE:  MOVF   xC7,W
35D0:  SUBLW  64
35D2:  BC    3600
35D4:  MOVF   xCE,F
35D6:  BNZ   3600
35D8:  MOVF   xCD,F
35DA:  BNZ   3600
35DC:  MOVF   xCC,F
35DE:  BNZ   3600
35E0:  MOVF   xCB,W
35E2:  SUBLW  B3
35E4:  BNC   3600
35E6:  MOVF   xCE,F
35E8:  BNZ   35F8
35EA:  MOVF   xCD,F
35EC:  BNZ   35F8
35EE:  MOVF   xCC,F
35F0:  BNZ   35F8
35F2:  MOVF   xCB,W
35F4:  SUBLW  64
35F6:  BC    3600
35F8:  MOVLW  05
35FA:  MOVWF  01
35FC:  BRA    3604
....................    else return 0xff; 
35FE:  BRA    3604
3600:  MOVLW  FF
3602:  MOVWF  01
.................... } 
3604:  MOVLB  0
3606:  GOTO   3674 (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
360A:  BSF    F93.4
360C:  BTFSS  F81.4
360E:  BRA    3622
3610:  BSF    F93.5
3612:  BTFSS  F81.5
3614:  BRA    3622
3616:  BSF    F93.6
3618:  BTFSS  F81.6
361A:  BRA    3622
361C:  BSF    F93.7
361E:  BTFSC  F81.7
3620:  BRA    379C
....................     { 
....................        if(input(ROW0)==0) 
3622:  BSF    F93.4
3624:  BTFSC  F81.4
3626:  BRA    3630
....................          row=0; 
3628:  MOVLB  A
362A:  CLRF   xB8
....................        else if(input(ROW1)==0) 
362C:  BRA    365C
362E:  MOVLB  0
3630:  BSF    F93.5
3632:  BTFSC  F81.5
3634:  BRA    3640
....................          row=1; 
3636:  MOVLW  01
3638:  MOVLB  A
363A:  MOVWF  xB8
....................        else if(input(ROW2)==0) 
363C:  BRA    365C
363E:  MOVLB  0
3640:  BSF    F93.6
3642:  BTFSC  F81.6
3644:  BRA    3650
....................          row=2; 
3646:  MOVLW  02
3648:  MOVLB  A
364A:  MOVWF  xB8
....................        else if(input(ROW3)==0) 
364C:  BRA    365C
364E:  MOVLB  0
3650:  BSF    F93.7
3652:  BTFSC  F81.7
3654:  BRA    365C
....................          row=3;      
3656:  MOVLW  03
3658:  MOVLB  A
365A:  MOVWF  xB8
....................        if(type_KB==0)col=check_col(); 
365C:  MOVLB  1
365E:  MOVF   x13,F
3660:  BNZ   366E
3662:  MOVLB  0
3664:  GOTO   27EE
3668:  MOVFF  01,AB6
....................          else col=new_check_col(); 
366C:  BRA    3678
366E:  MOVLB  0
3670:  GOTO   2E1A
3674:  MOVFF  01,AB6
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
3678:  MOVLB  A
367A:  INCFSZ xB6,W
367C:  BRA    3680
367E:  BRA    376A
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
3680:  MOVLB  1
3682:  MOVF   x13,F
3684:  BNZ   36AC
3686:  MOVLB  A
3688:  MOVF   xB8,W
368A:  MULLW  05
368C:  MOVF   FF3,W
368E:  CLRF   xBA
3690:  MOVWF  xB9
3692:  CLRF   03
3694:  MOVF   xB6,W
3696:  ADDWF  xB9,W
3698:  MOVWF  01
369A:  MOVF   xBA,W
369C:  ADDWFC 03,F
369E:  MOVF   01,W
36A0:  MOVLB  0
36A2:  CALL   00E8
36A6:  MOVFF  FE8,AB7
....................            else kchar =newKEYS[row][col]; 
36AA:  BRA    36D0
36AC:  MOVLB  A
36AE:  MOVF   xB8,W
36B0:  MULLW  06
36B2:  MOVF   FF3,W
36B4:  CLRF   xBA
36B6:  MOVWF  xB9
36B8:  CLRF   03
36BA:  MOVF   xB6,W
36BC:  ADDWF  xB9,W
36BE:  MOVWF  01
36C0:  MOVF   xBA,W
36C2:  ADDWFC 03,F
36C4:  MOVF   01,W
36C6:  MOVLB  0
36C8:  CALL   010C
36CC:  MOVFF  FE8,AB7
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
36D0:  MOVLB  1
36D2:  MOVF   x0B,F
36D4:  BNZ   375C
....................             { 
....................               charac_timeout=0; 
36D6:  MOVLB  0
36D8:  CLRF   xFC
36DA:  CLRF   xFB
....................                if(key_count_ms<20)key_data[key_count_ms++]=kchar; 
36DC:  MOVLB  1
36DE:  MOVF   x0E,W
36E0:  SUBLW  13
36E2:  BNC   36F8
36E4:  MOVF   x0E,W
36E6:  INCF   x0E,F
36E8:  CLRF   03
36EA:  ADDLW  14
36EC:  MOVWF  FE9
36EE:  MOVLW  01
36F0:  ADDWFC 03,W
36F2:  MOVWF  FEA
36F4:  MOVFF  AB7,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
36F8:  MOVLW  C0
36FA:  MOVWF  FF6
36FC:  MOVLW  04
36FE:  MOVWF  FF7
3700:  MOVLW  09
3702:  MOVLB  A
3704:  MOVWF  xD3
3706:  MOVLB  0
3708:  CALL   1718
370C:  MOVFF  10E,ABF
3710:  MOVLW  18
3712:  MOVLB  A
3714:  MOVWF  xC0
3716:  MOVLB  0
3718:  CALL   182C
371C:  MOVLW  5D
371E:  MOVLB  A
3720:  MOVWF  xDF
3722:  MOVLB  0
3724:  CALL   075A
3728:  MOVLW  20
372A:  MOVLB  A
372C:  MOVWF  xDF
372E:  MOVLB  0
3730:  CALL   075A
3734:  MOVFF  AB7,ADF
3738:  CALL   075A
373C:  MOVLW  0D
373E:  MOVLB  A
3740:  MOVWF  xDF
3742:  MOVLB  0
3744:  CALL   075A
3748:  MOVLW  0A
374A:  MOVLB  A
374C:  MOVWF  xDF
374E:  MOVLB  0
3750:  CALL   075A
....................                count_checking=0; 
3754:  MOVLB  1
3756:  CLRF   x07
3758:  CLRF   x06
....................             } 
....................                else fputc(kchar,COM2); 
375A:  BRA    3768
375C:  MOVFF  AB7,ADF
3760:  MOVLB  0
3762:  CALL   075A
3766:  MOVLB  1
3768:  MOVLB  A
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
376A:  BSF    F93.4
376C:  BTFSS  F81.4
376E:  BRA    376A
3770:  BSF    F93.5
3772:  BTFSS  F81.5
3774:  BRA    376A
3776:  BSF    F93.6
3778:  BTFSS  F81.6
377A:  BRA    376A
377C:  BSF    F93.7
377E:  BTFSS  F81.7
3780:  BRA    376A
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3782:  BSF    F93.4
3784:  BTFSS  F81.4
3786:  BRA    3782
3788:  BSF    F93.5
378A:  BTFSS  F81.5
378C:  BRA    3782
378E:  BSF    F93.6
3790:  BTFSS  F81.6
3792:  BRA    3782
3794:  BSF    F93.7
3796:  BTFSS  F81.7
3798:  BRA    3782
379A:  MOVLB  0
....................     } 
....................   set_tris_a(0xff);     
379C:  MOVLW  FF
379E:  MOVWF  F92
....................   return(kchar); 
37A0:  MOVLB  A
37A2:  MOVFF  AB7,01
.................... }//*/ 
37A6:  MOVLB  0
37A8:  RETURN 0
.................... //============================================ 
....................  
.................... //=========================== 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
4494:  MOVF   27,F
4496:  BTFSS  FD8.2
4498:  BRA    45E0
449A:  MOVF   26,F
449C:  BTFSS  FD8.2
449E:  BRA    45E0
44A0:  MOVF   25,W
44A2:  SUBLW  FF
44A4:  BTFSS  FD8.0
44A6:  BRA    45E0
44A8:  BNZ   44B2
44AA:  MOVF   24,W
44AC:  SUBLW  FE
44AE:  BTFSS  FD8.0
44B0:  BRA    45E0
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)) 
44B2:  MOVLB  1
44B4:  MOVF   x14,F
44B6:  BZ    458E
....................       { 
....................          temp=get_countcard(); 
44B8:  MOVLB  0
44BA:  CALL   39FC
44BE:  MOVFF  02,AB8
44C2:  MOVFF  01,AB7
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
44C6:  MOVFF  AB8,ABC
44CA:  MOVFF  AB7,ABB
44CE:  MOVLB  A
44D0:  CLRF   xBE
44D2:  MOVLW  32
44D4:  MOVWF  xBD
44D6:  MOVLB  0
44D8:  CALL   3A4C
44DC:  MOVFF  02,ABA
44E0:  MOVFF  01,AB9
44E4:  MOVLW  46
44E6:  MOVLB  A
44E8:  ADDWF  xB9,F
44EA:  MOVLW  AA
44EC:  ADDWFC xBA,F
44EE:  MOVLW  01
44F0:  ADDWF  xB9,W
44F2:  MOVWF  01
44F4:  MOVLW  00
44F6:  ADDWFC xBA,W
44F8:  MOVFF  01,24
44FC:  MOVWF  25
44FE:  CLRF   26
4500:  CLRF   27
....................          for(i=0;i<key_numbyte-5;i++) 
4502:  CLRF   xB6
4504:  MOVF   xB6,W
4506:  SUBLW  2C
4508:  BNC   4564
....................          { 
....................             temp=key_data[i]; 
450A:  CLRF   03
450C:  MOVF   xB6,W
450E:  ADDLW  14
4510:  MOVWF  FE9
4512:  MOVLW  01
4514:  ADDWFC 03,W
4516:  MOVWF  FEA
4518:  CLRF   xB8
451A:  MOVFF  FEF,AB7
....................             write_ext_eeprom((long int)ptr_card_key++,temp); 
451E:  MOVFF  27,03
4522:  MOVFF  26,02
4526:  MOVFF  25,01
452A:  MOVFF  24,00
452E:  MOVLW  01
4530:  ADDWF  24,F
4532:  BTFSC  FD8.0
4534:  INCF   25,F
4536:  BTFSC  FD8.2
4538:  INCF   26,F
453A:  BTFSC  FD8.2
453C:  INCF   27,F
453E:  MOVFF  01,ABA
4542:  MOVFF  00,AB9
4546:  MOVFF  01,AC8
454A:  MOVFF  00,AC7
454E:  MOVFF  AB7,AC9
4552:  MOVLB  0
4554:  RCALL  3E78
....................             //delay_us(100); 
....................             fputc(temp,COM2); 
4556:  MOVFF  AB7,ADF
455A:  CALL   075A
....................          } 
455E:  MOVLB  A
4560:  INCF   xB6,F
4562:  BRA    4504
....................          write_ext_eeprom((long int)ptr_card_key,0); 
4564:  MOVFF  25,AC8
4568:  MOVFF  24,AC7
456C:  CLRF   xC9
456E:  MOVLB  0
4570:  RCALL  3E78
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
4572:  MOVFF  27,ABC
4576:  MOVFF  26,ABB
457A:  MOVFF  25,ABA
457E:  MOVFF  24,AB9
4582:  MOVLW  1E
4584:  MOVLB  A
4586:  MOVWF  xBD
4588:  MOVLB  0
458A:  RCALL  3F7E
458C:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
458E:  CLRF   x0E
....................       del_buf(key_numbyte,key_data); 
4590:  MOVLW  32
4592:  MOVLB  A
4594:  MOVWF  xC5
4596:  MOVLW  01
4598:  MOVWF  xC7
459A:  MOVLW  14
459C:  MOVWF  xC6
459E:  MOVLB  0
45A0:  CALL   3A6E
....................       fprintf(COM2,"\r\n"); 
45A4:  MOVLW  0D
45A6:  MOVLB  A
45A8:  MOVWF  xDF
45AA:  MOVLB  0
45AC:  CALL   075A
45B0:  MOVLW  0A
45B2:  MOVLB  A
45B4:  MOVWF  xDF
45B6:  MOVLB  0
45B8:  CALL   075A
....................       fprintf(COM2,"Done PIN"); 
45BC:  MOVLW  D2
45BE:  MOVWF  FF6
45C0:  MOVLW  04
45C2:  MOVWF  FF7
45C4:  CALL   07A0
....................       fprintf(COM2,"\r\n"); 
45C8:  MOVLW  0D
45CA:  MOVLB  A
45CC:  MOVWF  xDF
45CE:  MOVLB  0
45D0:  CALL   075A
45D4:  MOVLW  0A
45D6:  MOVLB  A
45D8:  MOVWF  xDF
45DA:  MOVLB  0
45DC:  CALL   075A
....................    } 
.................... } 
45E0:  GOTO   489A (RETURN)
.................... //=========================================== 
.................... void key_press() 
.................... { 
....................    int8 col; 
....................    int32 KB_count_timeout=0; 
....................    fprintf(COM2,"\r\n"); 
....................    fprintf(COM2,"Key"); 
....................    //fprintf(COM2,"\r\n"); 
....................    KB_count_timeout=0; 
....................    while(1) 
....................    { 
....................       
....................       if(KB_count_timeout<150000)KB_count_timeout++; 
....................       if(KB_count_timeout==150000) 
....................       { 
....................          KB_count_timeout++; 
....................           
....................          break;             
....................       }   
....................    } 
.................... } 
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
....................       c = fgetc(COM2);//getc(); 
....................       switch(c) 
....................       { 
....................          case 0x7f:    
....................             if(nbcar>0)   
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
....................                nbcar--; 
....................                fgetc(COM2);//getc(); 
....................             } 
....................             else fputc(0x07,COM2);    
....................          break;  
....................          case 0x0D:   
....................                keydebug_en=0; 
....................                set_tris_a(0xff); 
....................                for(i=nbcar;i<nbcarmax;i++) 
....................                { 
....................                  chaine[i]=0; 
....................                } 
....................                if(nbcar==0)return(FAUX); 
....................                fini=VRAI; 
....................          break; 
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
....................             { 
....................                chaine[nbcar]=c; 
....................                nbcar++; 
....................                if(echo==EN_ECHO) fputc(c,COM2); 
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
....................    return(nbcar); 
.................... } 
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
*
579E:  MOVFF  A8F,A93
57A2:  MOVFF  A8E,A92
57A6:  MOVFF  A91,A95
57AA:  MOVFF  A90,A94
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
57AE:  MOVFF  A93,03
57B2:  MOVLB  A
57B4:  MOVFF  A92,FE9
57B8:  MOVFF  A93,FEA
57BC:  MOVF   FEF,F
57BE:  BZ    5806
57C0:  MOVFF  A95,03
57C4:  MOVFF  A94,FE9
57C8:  MOVFF  A95,FEA
57CC:  MOVF   FEF,F
57CE:  BZ    5806
....................       if(*aa!=*bb) 
57D0:  MOVFF  A92,FE9
57D4:  MOVFF  A93,FEA
57D8:  MOVFF  FEF,A96
57DC:  MOVFF  A95,03
57E0:  MOVFF  A94,FE9
57E4:  MOVFF  A95,FEA
57E8:  MOVF   FEF,W
57EA:  SUBWF  x96,W
57EC:  BZ    57F4
....................          return(1); 
57EE:  MOVLW  01
57F0:  MOVWF  01
57F2:  BRA    5832
....................       aa++; 
57F4:  INCF   x92,F
57F6:  BTFSC  FD8.2
57F8:  INCF   x93,F
....................       bb++; 
57FA:  INCF   x94,F
57FC:  BTFSC  FD8.2
57FE:  INCF   x95,F
....................    } 
5800:  MOVLB  0
5802:  BRA    57AE
5804:  MOVLB  A
....................    if(*aa!=*bb)return(1); 
5806:  MOVFF  A93,03
580A:  MOVFF  A92,FE9
580E:  MOVFF  A93,FEA
5812:  MOVFF  FEF,A96
5816:  MOVFF  A95,03
581A:  MOVFF  A94,FE9
581E:  MOVFF  A95,FEA
5822:  MOVF   FEF,W
5824:  SUBWF  x96,W
5826:  BZ    582E
5828:  MOVLW  01
582A:  MOVWF  01
582C:  BRA    5832
....................    return(0); 
582E:  MOVLW  00
5830:  MOVWF  01
.................... } 
5832:  MOVLB  0
5834:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
....................         if (c >= '0' && c <= '9') 
....................             digit = (unsigned int) (c - '0'); 
....................         else 
....................             break; 
....................  
....................         val = (val * 10) + digit; 
....................     } 
....................  
....................     return val; 
.................... } 
....................  
.................... int8 receiver_state=0,booting_done=0; 
.................... int16 over_byte=0; 
.................... #include <GSM.c>  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#include "myRS485.C" 
....................  
.................... #define        EMERGOFF       PIN_A7 
.................... #define        config_sms           0 
.................... #define        reading_sms_cmd      1 
.................... #define        MSG_avai             2 
.................... #define        analyze_sms          3 
.................... #define        checking_MN          4 
.................... #define        doing_sms            5 
.................... #define        delete_MSG           6 
.................... #define        pre_cmd              7 
.................... #define        MSG_sending          8 
.................... #define        check_st             9 
.................... #define        config               10 
.................... #define        autosending          11 
.................... #define        idle                 12 
.................... #define        data_analyze         13 
.................... #define        SIM_reply            14 
.................... #define        check_comunication   15 
.................... #define        phone_activity_status 16 
.................... #define        check_inbox          17 
.................... #define        checking_MN0         18 
.................... #define        autosending1         19 
.................... #define        reset_module         20 
.................... #if defined(twonumber) 
....................    #define        second_number_en     21 
.................... #endif    
....................  
.................... //#define     IGT            PIN_A6 
....................  
.................... //#define     batmb    sendto485(0,0x11,1) 
.................... //#define     tatmb    sendto485(0,0x11,0) 
....................  
....................  
.................... unsigned int8 msg_data_sending[280]; 
.................... int8 sim_bug[50]; 
.................... unsigned int8 msg_buffer1[20]; 
.................... unsigned int8 msg_buffer2[50]; 
.................... unsigned int8 reply_buffer[280]; 
.................... unsigned int8 datetime[25]; 
.................... unsigned int8 mobilenumb[26]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... //unsigned int8 buf_checkMBN[16]; 
.................... int16 count_polling=0; 
.................... int8 SIM_state=0,MSG_sending_st=0; 
.................... int16 timing_wait=100; 
.................... int8 auto_sending=0; 
.................... int8 send_oneMSG=0; 
.................... int8 SIM_reply_st=0; 
.................... int8 checking_sim=0; 
.................... int8 count_checking_nw=0; 
.................... int8 firstime_pw=0; 
.................... #if defined(twonumber) 
....................   int8 two_number_sending=0;  
....................    
.................... #endif 
.................... //unsigned int8 com_buffer1[20]="it is OK"; 
.................... //============================================== 
.................... void earse_buffer_uart(unsigned int8 numbuf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<numbuf;i++) 
....................    { 
....................        buffer_uart[i]=0; 
....................    } 
.................... } 
.................... //============================================== 
.................... void sim900_init() 
.................... { 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(500); 
....................    fprintf(COM1,"AT+CMGF=1\r\n"); 
....................    delay_ms(500); 
....................    //del_buf(26,mobilenumb); 
....................    //strcpy(mobilenumb,"+84903219082"); 
.................... } 
.................... //============================================== 
.................... int8 get_datasim900(int8 *datin) 
.................... { 
....................    int8 c,i,index=0; 
....................    int8 testtemp[20]; 
....................    while(index<5) 
....................    { 
....................       c = getc(); 
....................       index++; 
....................       fprintf(COM2,"%c", c);  
....................    } 
....................    for(i=0;i<15;i++) 
....................    { 
....................       fprintf(COM2,"%c", testtemp[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", index);//*/ 
....................    return 0; 
.................... } 
.................... //============================================== 
.................... int8 check_module() 
.................... { 
....................    int8 temp=0,i; 
....................    earse_buffer_uart(10); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    UART_index=0; 
....................    delay_ms(200); 
....................    //fputc('c',COM2); 
....................    //fprintf("MSG is OK\r\n"); 
....................    for(i=0;i<10;i++) 
....................    { 
....................       //fputc(buffer_uart[i],COM2); 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) 
....................       { 
....................          i=10; 
....................          temp=1; 
....................          return(temp); 
....................       } 
....................          else temp=0; 
....................    } 
....................    UART_index=0; 
....................    return(temp); 
.................... } 
.................... //============================================== 
.................... void power_on() 
.................... { 
....................    /*while(temp==0) 
....................    { 
....................       temp = check_module(); 
....................       if(temp==0) 
....................       { 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
....................       } 
....................          else break; 
....................    }*/ 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
.................... } 
.................... //============================================== 
.................... void power_off() 
.................... { 
....................    fprintf(COM1,"AT+CPOWD\r\n"); 
.................... } 
.................... //============================================== 
.................... unsigned int8 mymemcmp(void * s1,char *s2,size_t n) 
.................... { 
....................    char *su1, *su2; 
....................    unsigned int8 temp=0,i=0; 
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................       { 
....................          temp=1; 
....................          if(*su1>*su2) 
....................          { 
....................             if((i==0)&&(*su1==(*su2)+32)) temp = 0; 
....................                //else temp = 0; 
....................          } 
....................             else  
....................                { 
....................                   if((i==0)&&(*su2==(*su1)+32)) temp = 0; 
....................                     // else temp = 0; 
....................                } 
....................       } 
....................       i++; 
....................    } 
....................    return (temp); 
.................... } 
.................... //============================================== 
.................... int8 pre_msg(int8 *datin,int8 *datout,int16 index) 
.................... { 
*
5F32:  MOVLB  A
5F34:  CLRF   x95
....................    int8 i,len=0; 
....................    len = strlen(datin); 
5F36:  MOVFF  A8F,A97
5F3A:  MOVFF  A8E,A96
5F3E:  MOVLB  0
5F40:  RCALL  5EF8
5F42:  MOVFF  01,A95
....................    for(i=0;i<len;i++)datout[index++]=datin[i]; 
5F46:  MOVLB  A
5F48:  CLRF   x94
5F4A:  MOVF   x95,W
5F4C:  SUBWF  x94,W
5F4E:  BC    5F92
5F50:  MOVFF  A93,03
5F54:  MOVF   x92,W
5F56:  INCF   x92,F
5F58:  BTFSC  FD8.2
5F5A:  INCF   x93,F
5F5C:  MOVWF  x96
5F5E:  MOVFF  03,A97
5F62:  MOVF   x90,W
5F64:  ADDWF  x96,W
5F66:  MOVWF  01
5F68:  MOVF   x91,W
5F6A:  ADDWFC 03,W
5F6C:  MOVWF  03
5F6E:  MOVWF  x99
5F70:  CLRF   03
5F72:  MOVF   x94,W
5F74:  ADDWF  x8E,W
5F76:  MOVWF  FE9
5F78:  MOVF   x8F,W
5F7A:  ADDWFC 03,W
5F7C:  MOVWF  FEA
5F7E:  MOVFF  FEF,A9A
5F82:  MOVFF  A99,FEA
5F86:  MOVFF  01,FE9
5F8A:  MOVFF  A9A,FEF
5F8E:  INCF   x94,F
5F90:  BRA    5F4A
....................    return index; 
5F92:  MOVFF  A92,01
.................... } 
5F96:  MOVLB  0
5F98:  RETURN 0
.................... //============================================== 
.................... void delete_sms(char number_sms) 
.................... { 
....................    switch(number_sms) 
....................    { 
....................        case  1: 
....................             fprintf(COM1,"AT+CMGD=1\r\n");  
....................        break; 
....................        case  2: 
....................             fprintf(COM1,"AT+CMGD=2\r\n"); 
....................        break; 
....................        case  3: 
....................             fprintf(COM1,"AT+CMGD=3\r\n"); 
....................        break; 
....................        case  4: 
....................             fprintf(COM1,"AT+CMGD=4\r\n");        
....................        break; 
....................        case  5: 
....................             fprintf(COM1,"AT+CMGD=5\r\n"); 
....................        break; 
....................        case  6: 
....................             fprintf(COM1,"AT+CMGD=6\r\n"); 
....................        break; 
....................        case  7: 
....................              fprintf(COM1,"AT+CMGD=7\r\n"); 
....................        break;        
....................        case  8: 
....................             fprintf(COM1,"AT+CMGD=8\r\n"); 
....................        break;        
....................    } 
....................    delay_ms(500); 
.................... } 
.................... //============================================== 
.................... void del_multi_sms(int8 num_sms) 
.................... { 
....................    int8 i; 
....................    for(i=1;i<=num_sms;i++) 
....................    { 
....................      delete_sms(i);  
....................      delay_ms(100); 
....................    } 
.................... } 
.................... //============================================== 
.................... //============================================== 
.................... void send_sms(unsigned int8* mobile_num,unsigned int8* MSG) 
.................... { 
....................       unsigned int8 i=0,strl=0; 
....................       strl= strlen(MSG);   
....................       fprintf(COM1,"AT+CMGS="); 
....................       delay_ms(500); 
....................       fputc('"',COM1); 
....................       while((mobile_num[i]!=0)&&(i<20)) 
....................       { 
....................          //fputc(mobile_num[i],COM2); 
....................          //putc(mobile_num[i]); 
....................          fputc(mobile_num[i],COM1); 
....................          i++; 
....................       } 
....................       fputc('"',COM1); 
....................       fprintf(COM1,"\r\n"); 
....................       delay_ms(500);         
....................       for(i=0;i<strl;i++) 
....................       { 
....................          fputc(MSG[i],COM1); 
....................       } 
....................       delay_ms(500); 
....................       fputc(26,COM1); 
.................... } 
.................... //============================================= 
.................... //============================================== 
.................... void reading_sms() 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<16;i++) mobilenumb[i]=0; 
....................    earse_buffer_uart(200); 
....................    printf("AT+CMGF=1\r\n"); 
....................    printf("AT+CMGR=1\r\n");  
....................    UART_index=0;  
....................    delay_ms(1000); 
....................    for(i=0;i<200;i++) 
....................    { 
....................       if((buffer_uart[i]=='a')&&(buffer_uart[i+1]=='d')&&(buffer_uart[i+2]=='m')&&(buffer_uart[i+3]=='i')&&(buffer_uart[i+4]=='n')&&(buffer_uart[i+5]==' ')) 
....................       { 
....................          write_ext_eeprom(strobe_mobile_num1,buffer_uart[i+6]); 
....................          fputc(buffer_uart[i+6],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+1,buffer_uart[i+7]); 
....................          fputc(buffer_uart[i+7],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+2,buffer_uart[i+8]); 
....................          fputc(buffer_uart[i+8],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+3,buffer_uart[i+9]); 
....................          fputc(buffer_uart[i+9],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+4,buffer_uart[i+10]); 
....................          fputc(buffer_uart[i+10],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+5,buffer_uart[i+11]); 
....................          fputc(buffer_uart[i+11],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+6,buffer_uart[i+12]); 
....................          fputc(buffer_uart[i+12],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+7,buffer_uart[i+13]); 
....................          fputc(buffer_uart[i+13],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+8,buffer_uart[i+14]); 
....................          fputc(buffer_uart[i+14],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+9,buffer_uart[i+15]); 
....................          fputc(buffer_uart[i+15],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+10,buffer_uart[i+16]); 
....................          fputc(buffer_uart[i+16],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+11,buffer_uart[i+17]); 
....................          fputc(buffer_uart[i+17],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+12,buffer_uart[i+18]); 
....................          fputc(buffer_uart[i+18],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+13,buffer_uart[i+19]); 
....................          fputc(buffer_uart[i+19],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+14,buffer_uart[i+20]); 
....................          fputc(buffer_uart[i+20],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+15,buffer_uart[i+21]); 
....................          fputc(buffer_uart[i+21],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+16,buffer_uart[i+22]); 
....................          fputc(buffer_uart[i+22],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+17,buffer_uart[i+23]); 
....................          fputc(buffer_uart[i+23],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+18,buffer_uart[i+24]); 
....................          fputc(buffer_uart[i+24],COM2);          
....................          write_ext_eeprom(strobe_mobile_num1+19,buffer_uart[i+25]); 
....................          fputc(buffer_uart[i+25],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+20,buffer_uart[i+26]); 
....................          fputc(buffer_uart[i+26],COM2);          
....................          fprintf(COM2,"\r\n"); 
....................          EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................          i=250; 
....................          sms_unread_flag=0; 
....................          strcpy (msg_data_sending, "done"); 
....................          send_sms(mobilenumb,msg_data_sending); 
....................          delay_ms(5000); 
....................          delete_sms(1); 
....................          delay_ms(5000); 
....................          UART_index=0; 
....................       } 
....................         else  
....................          { 
....................             if(i>198)  
....................             { 
....................                delay_ms(5000); 
....................                delete_sms(1); 
....................                delay_ms(5000); 
....................                UART_index=0; 
....................                sms_unread_flag=0; 
....................                EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................             } 
....................          } 
....................    } 
.................... } 
.................... //============================================== 
.................... /*void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... }*/ 
.................... //============================================================ 
.................... int8 checking_msg_avai() 
.................... { 
....................    int8 i; 
....................    /*for(i=0;i<100;i++) 
....................    { 
....................       fprintf(COM2,"%c", buffer_uart[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", UART_index);//*/ 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) return 1; 
....................    } 
....................    return 0; 
.................... } 
.................... //============================================================ 
.................... int8 SMS_coming() 
.................... { 
*
6530:  MOVLB  A
6532:  CLRF   x8F
.................... //+CMTI: "SM",25 
....................    int8 i,st=0; 
....................    //int8 msg_temp[20],msg_temp1[20]; 
....................    //strncpy(msg_temp1,buffer_uart,20); 
....................    //strcpy(msg_temp,"+CMTI:"); 
....................    for(i=0;i<20;i++) 
6534:  CLRF   x8E
6536:  MOVF   x8E,W
6538:  SUBLW  13
653A:  BTFSS  FD8.0
653C:  BRA    6648
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='T')&&(buffer_uart[4+i]=='I')&&(buffer_uart[5+i]==':'))  
653E:  CLRF   03
6540:  MOVF   x8E,W
6542:  ADDLW  4E
6544:  MOVWF  FE9
6546:  MOVLW  01
6548:  ADDWFC 03,W
654A:  MOVWF  FEA
654C:  MOVF   FEF,W
654E:  SUBLW  2B
6550:  BTFSS  FD8.2
6552:  BRA    6642
6554:  MOVLW  01
6556:  ADDWF  x8E,W
6558:  CLRF   03
655A:  ADDLW  4E
655C:  MOVWF  FE9
655E:  MOVLW  01
6560:  ADDWFC 03,W
6562:  MOVWF  FEA
6564:  MOVF   FEF,W
6566:  SUBLW  43
6568:  BNZ   6642
656A:  MOVLW  02
656C:  ADDWF  x8E,W
656E:  CLRF   03
6570:  ADDLW  4E
6572:  MOVWF  FE9
6574:  MOVLW  01
6576:  ADDWFC 03,W
6578:  MOVWF  FEA
657A:  MOVF   FEF,W
657C:  SUBLW  4D
657E:  BNZ   6642
6580:  MOVLW  03
6582:  ADDWF  x8E,W
6584:  CLRF   03
6586:  ADDLW  4E
6588:  MOVWF  FE9
658A:  MOVLW  01
658C:  ADDWFC 03,W
658E:  MOVWF  FEA
6590:  MOVF   FEF,W
6592:  SUBLW  54
6594:  BNZ   6642
6596:  MOVLW  04
6598:  ADDWF  x8E,W
659A:  CLRF   03
659C:  ADDLW  4E
659E:  MOVWF  FE9
65A0:  MOVLW  01
65A2:  ADDWFC 03,W
65A4:  MOVWF  FEA
65A6:  MOVF   FEF,W
65A8:  SUBLW  49
65AA:  BNZ   6642
65AC:  MOVLW  05
65AE:  ADDWF  x8E,W
65B0:  CLRF   03
65B2:  ADDLW  4E
65B4:  MOVWF  FE9
65B6:  MOVLW  01
65B8:  ADDWFC 03,W
65BA:  MOVWF  FEA
65BC:  MOVF   FEF,W
65BE:  SUBLW  3A
65C0:  BNZ   6642
....................       {  
....................          fprintf(COM2,"\n\rNew SMS %lu\n\r",over_byte); 
65C2:  MOVLW  9E
65C4:  MOVWF  FF6
65C6:  MOVLW  05
65C8:  MOVWF  FF7
65CA:  CLRF   19
65CC:  BTFSC  FF2.7
65CE:  BSF    19.7
65D0:  BCF    FF2.7
65D2:  MOVLW  0A
65D4:  MOVWF  xD3
65D6:  MOVLB  0
65D8:  CALL   1718
65DC:  BTFSC  19.7
65DE:  BSF    FF2.7
65E0:  MOVLW  10
65E2:  MOVWF  FE9
65E4:  CLRF   19
65E6:  BTFSC  FF2.7
65E8:  BSF    19.7
65EA:  BCF    FF2.7
65EC:  MOVFF  1B7,ABD
65F0:  MOVFF  1B6,ABC
65F4:  CALL   1742
65F8:  BTFSC  19.7
65FA:  BSF    FF2.7
65FC:  CLRF   19
65FE:  BTFSC  FF2.7
6600:  BSF    19.7
6602:  BCF    FF2.7
6604:  MOVLW  0A
6606:  MOVLB  A
6608:  MOVWF  xDF
660A:  MOVLB  0
660C:  CALL   075A
6610:  BTFSC  19.7
6612:  BSF    FF2.7
6614:  CLRF   19
6616:  BTFSC  FF2.7
6618:  BSF    19.7
661A:  BCF    FF2.7
661C:  MOVLW  0D
661E:  MOVLB  A
6620:  MOVWF  xDF
6622:  MOVLB  0
6624:  CALL   075A
6628:  BTFSC  19.7
662A:  BSF    FF2.7
....................          //output_high(PIN_C2); 
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
662C:  MOVLB  4
662E:  CLRF   x95
....................          over_byte=0; 
6630:  MOVLB  1
6632:  CLRF   xB7
6634:  CLRF   xB6
....................          st = 2; 
6636:  MOVLW  02
6638:  MOVLB  A
663A:  MOVWF  x8F
....................          i=23; 
663C:  MOVLW  17
663E:  MOVWF  x8E
....................       } 
....................          else st=0; 
6640:  BRA    6644
6642:  CLRF   x8F
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
6644:  INCF   x8E,F
6646:  BRA    6536
....................    for(i=0;i<20;i++) 
6648:  CLRF   x8E
664A:  MOVF   x8E,W
664C:  SUBLW  13
664E:  BNC   6702
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='G')&&(buffer_uart[4+i]=='R')&&(buffer_uart[5+i]==':'))  
6650:  CLRF   03
6652:  MOVF   x8E,W
6654:  ADDLW  4E
6656:  MOVWF  FE9
6658:  MOVLW  01
665A:  ADDWFC 03,W
665C:  MOVWF  FEA
665E:  MOVF   FEF,W
6660:  SUBLW  2B
6662:  BNZ   66FC
6664:  MOVLW  01
6666:  ADDWF  x8E,W
6668:  CLRF   03
666A:  ADDLW  4E
666C:  MOVWF  FE9
666E:  MOVLW  01
6670:  ADDWFC 03,W
6672:  MOVWF  FEA
6674:  MOVF   FEF,W
6676:  SUBLW  43
6678:  BNZ   66FC
667A:  MOVLW  02
667C:  ADDWF  x8E,W
667E:  CLRF   03
6680:  ADDLW  4E
6682:  MOVWF  FE9
6684:  MOVLW  01
6686:  ADDWFC 03,W
6688:  MOVWF  FEA
668A:  MOVF   FEF,W
668C:  SUBLW  4D
668E:  BNZ   66FC
6690:  MOVLW  03
6692:  ADDWF  x8E,W
6694:  CLRF   03
6696:  ADDLW  4E
6698:  MOVWF  FE9
669A:  MOVLW  01
669C:  ADDWFC 03,W
669E:  MOVWF  FEA
66A0:  MOVF   FEF,W
66A2:  SUBLW  47
66A4:  BNZ   66FC
66A6:  MOVLW  04
66A8:  ADDWF  x8E,W
66AA:  CLRF   03
66AC:  ADDLW  4E
66AE:  MOVWF  FE9
66B0:  MOVLW  01
66B2:  ADDWFC 03,W
66B4:  MOVWF  FEA
66B6:  MOVF   FEF,W
66B8:  SUBLW  52
66BA:  BNZ   66FC
66BC:  MOVLW  05
66BE:  ADDWF  x8E,W
66C0:  CLRF   03
66C2:  ADDLW  4E
66C4:  MOVWF  FE9
66C6:  MOVLW  01
66C8:  ADDWFC 03,W
66CA:  MOVWF  FEA
66CC:  MOVF   FEF,W
66CE:  SUBLW  3A
66D0:  BNZ   66FC
....................       {  
....................          fprintf(COM2,"\n\rREC UNREAD\n\r"); 
66D2:  MOVLW  AE
66D4:  MOVWF  FF6
66D6:  MOVLW  05
66D8:  MOVWF  FF7
66DA:  CLRF   19
66DC:  BTFSC  FF2.7
66DE:  BSF    19.7
66E0:  BCF    FF2.7
66E2:  MOVLB  0
66E4:  CALL   07A0
66E8:  BTFSC  19.7
66EA:  BSF    FF2.7
....................          //output_high(PIN_C2); 
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
66EC:  MOVLB  4
66EE:  CLRF   x95
....................          st = 2; 
66F0:  MOVLW  02
66F2:  MOVLB  A
66F4:  MOVWF  x8F
....................          i=23; 
66F6:  MOVLW  17
66F8:  MOVWF  x8E
....................       } 
....................          else st=0; 
66FA:  BRA    66FE
66FC:  CLRF   x8F
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
66FE:  INCF   x8E,F
6700:  BRA    664A
....................    for(i=0;i<20;i++) 
6702:  CLRF   x8E
6704:  MOVF   x8E,W
6706:  SUBLW  13
6708:  BNC   67E0
....................    { 
....................       if((buffer_uart[0+i]=='R')&&(buffer_uart[1+i]=='I')&&(buffer_uart[2+i]=='N')&&(buffer_uart[3+i]=='G'))  
670A:  CLRF   03
670C:  MOVF   x8E,W
670E:  ADDLW  4E
6710:  MOVWF  FE9
6712:  MOVLW  01
6714:  ADDWFC 03,W
6716:  MOVWF  FEA
6718:  MOVF   FEF,W
671A:  SUBLW  52
671C:  BNZ   67DA
671E:  MOVLW  01
6720:  ADDWF  x8E,W
6722:  CLRF   03
6724:  ADDLW  4E
6726:  MOVWF  FE9
6728:  MOVLW  01
672A:  ADDWFC 03,W
672C:  MOVWF  FEA
672E:  MOVF   FEF,W
6730:  SUBLW  49
6732:  BNZ   67DA
6734:  MOVLW  02
6736:  ADDWF  x8E,W
6738:  CLRF   03
673A:  ADDLW  4E
673C:  MOVWF  FE9
673E:  MOVLW  01
6740:  ADDWFC 03,W
6742:  MOVWF  FEA
6744:  MOVF   FEF,W
6746:  SUBLW  4E
6748:  BNZ   67DA
674A:  MOVLW  03
674C:  ADDWF  x8E,W
674E:  CLRF   03
6750:  ADDLW  4E
6752:  MOVWF  FE9
6754:  MOVLW  01
6756:  ADDWFC 03,W
6758:  MOVWF  FEA
675A:  MOVF   FEF,W
675C:  SUBLW  47
675E:  BNZ   67DA
....................       {  
....................          fprintf(COM2,"\n\rRING %lu\n\r",over_byte); 
6760:  MOVLW  BE
6762:  MOVWF  FF6
6764:  MOVLW  05
6766:  MOVWF  FF7
6768:  CLRF   19
676A:  BTFSC  FF2.7
676C:  BSF    19.7
676E:  BCF    FF2.7
6770:  MOVLW  07
6772:  MOVWF  xD3
6774:  MOVLB  0
6776:  CALL   1718
677A:  BTFSC  19.7
677C:  BSF    FF2.7
677E:  MOVLW  10
6780:  MOVWF  FE9
6782:  CLRF   19
6784:  BTFSC  FF2.7
6786:  BSF    19.7
6788:  BCF    FF2.7
678A:  MOVFF  1B7,ABD
678E:  MOVFF  1B6,ABC
6792:  CALL   1742
6796:  BTFSC  19.7
6798:  BSF    FF2.7
679A:  CLRF   19
679C:  BTFSC  FF2.7
679E:  BSF    19.7
67A0:  BCF    FF2.7
67A2:  MOVLW  0A
67A4:  MOVLB  A
67A6:  MOVWF  xDF
67A8:  MOVLB  0
67AA:  CALL   075A
67AE:  BTFSC  19.7
67B0:  BSF    FF2.7
67B2:  CLRF   19
67B4:  BTFSC  FF2.7
67B6:  BSF    19.7
67B8:  BCF    FF2.7
67BA:  MOVLW  0D
67BC:  MOVLB  A
67BE:  MOVWF  xDF
67C0:  MOVLB  0
67C2:  CALL   075A
67C6:  BTFSC  19.7
67C8:  BSF    FF2.7
....................          output_high(LED); 
67CA:  BCF    F92.6
67CC:  BSF    F89.6
....................          st = 1; 
67CE:  MOVLW  01
67D0:  MOVLB  A
67D2:  MOVWF  x8F
....................          i=23; 
67D4:  MOVLW  17
67D6:  MOVWF  x8E
....................       } 
....................          else st=0; 
67D8:  BRA    67DC
67DA:  CLRF   x8F
....................    } 
67DC:  INCF   x8E,F
67DE:  BRA    6704
....................    for(i=0;i<20;i++) 
67E0:  CLRF   x8E
67E2:  MOVF   x8E,W
67E4:  SUBLW  13
67E6:  BTFSS  FD8.0
67E8:  BRA    69D4
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='P')&&(buffer_uart[3+i]=='A')&&(buffer_uart[4+i]=='S')&&(buffer_uart[5+i]==':'))  
67EA:  CLRF   03
67EC:  MOVF   x8E,W
67EE:  ADDLW  4E
67F0:  MOVWF  FE9
67F2:  MOVLW  01
67F4:  ADDWFC 03,W
67F6:  MOVWF  FEA
67F8:  MOVF   FEF,W
67FA:  SUBLW  2B
67FC:  BTFSS  FD8.2
67FE:  BRA    69CE
6800:  MOVLW  01
6802:  ADDWF  x8E,W
6804:  CLRF   03
6806:  ADDLW  4E
6808:  MOVWF  FE9
680A:  MOVLW  01
680C:  ADDWFC 03,W
680E:  MOVWF  FEA
6810:  MOVF   FEF,W
6812:  SUBLW  43
6814:  BTFSS  FD8.2
6816:  BRA    69CE
6818:  MOVLW  02
681A:  ADDWF  x8E,W
681C:  CLRF   03
681E:  ADDLW  4E
6820:  MOVWF  FE9
6822:  MOVLW  01
6824:  ADDWFC 03,W
6826:  MOVWF  FEA
6828:  MOVF   FEF,W
682A:  SUBLW  50
682C:  BTFSS  FD8.2
682E:  BRA    69CE
6830:  MOVLW  03
6832:  ADDWF  x8E,W
6834:  CLRF   03
6836:  ADDLW  4E
6838:  MOVWF  FE9
683A:  MOVLW  01
683C:  ADDWFC 03,W
683E:  MOVWF  FEA
6840:  MOVF   FEF,W
6842:  SUBLW  41
6844:  BTFSS  FD8.2
6846:  BRA    69CE
6848:  MOVLW  04
684A:  ADDWF  x8E,W
684C:  CLRF   03
684E:  ADDLW  4E
6850:  MOVWF  FE9
6852:  MOVLW  01
6854:  ADDWFC 03,W
6856:  MOVWF  FEA
6858:  MOVF   FEF,W
685A:  SUBLW  53
685C:  BTFSS  FD8.2
685E:  BRA    69CE
6860:  MOVLW  05
6862:  ADDWF  x8E,W
6864:  CLRF   03
6866:  ADDLW  4E
6868:  MOVWF  FE9
686A:  MOVLW  01
686C:  ADDWFC 03,W
686E:  MOVWF  FEA
6870:  MOVF   FEF,W
6872:  SUBLW  3A
6874:  BTFSS  FD8.2
6876:  BRA    69CE
....................       {  
....................          if(buffer_uart[7+i]=='0')  
6878:  MOVLW  07
687A:  ADDWF  x8E,W
687C:  CLRF   03
687E:  ADDLW  4E
6880:  MOVWF  FE9
6882:  MOVLW  01
6884:  ADDWFC 03,W
6886:  MOVWF  FEA
6888:  MOVF   FEF,W
688A:  SUBLW  30
688C:  BNZ   6906
....................          { 
....................             fprintf(COM2,"Ready (MT allows commands from TA/TE)%lu\n\r",over_byte); 
688E:  MOVLW  CC
6890:  MOVWF  FF6
6892:  MOVLW  05
6894:  MOVWF  FF7
6896:  CLRF   19
6898:  BTFSC  FF2.7
689A:  BSF    19.7
689C:  BCF    FF2.7
689E:  MOVLW  25
68A0:  MOVWF  xD3
68A2:  MOVLB  0
68A4:  CALL   1718
68A8:  BTFSC  19.7
68AA:  BSF    FF2.7
68AC:  MOVLW  10
68AE:  MOVWF  FE9
68B0:  CLRF   19
68B2:  BTFSC  FF2.7
68B4:  BSF    19.7
68B6:  BCF    FF2.7
68B8:  MOVFF  1B7,ABD
68BC:  MOVFF  1B6,ABC
68C0:  CALL   1742
68C4:  BTFSC  19.7
68C6:  BSF    FF2.7
68C8:  CLRF   19
68CA:  BTFSC  FF2.7
68CC:  BSF    19.7
68CE:  BCF    FF2.7
68D0:  MOVLW  0A
68D2:  MOVLB  A
68D4:  MOVWF  xDF
68D6:  MOVLB  0
68D8:  CALL   075A
68DC:  BTFSC  19.7
68DE:  BSF    FF2.7
68E0:  CLRF   19
68E2:  BTFSC  FF2.7
68E4:  BSF    19.7
68E6:  BCF    FF2.7
68E8:  MOVLW  0D
68EA:  MOVLB  A
68EC:  MOVWF  xDF
68EE:  MOVLB  0
68F0:  CALL   075A
68F4:  BTFSC  19.7
68F6:  BSF    FF2.7
....................             SIM_state= check_inbox; 
68F8:  MOVLW  11
68FA:  MOVLB  4
68FC:  MOVWF  x95
....................             over_byte=0; 
68FE:  MOVLB  1
6900:  CLRF   xB7
6902:  CLRF   xB6
6904:  MOVLB  A
....................          } 
....................          if(buffer_uart[7+i]=='2') 
6906:  MOVLW  07
6908:  ADDWF  x8E,W
690A:  CLRF   03
690C:  ADDLW  4E
690E:  MOVWF  FE9
6910:  MOVLW  01
6912:  ADDWFC 03,W
6914:  MOVWF  FEA
6916:  MOVF   FEF,W
6918:  SUBLW  32
691A:  BNZ   6960
....................          { 
....................             fprintf(COM2,"No network\n\r"); 
691C:  MOVLW  F8
691E:  MOVWF  FF6
6920:  MOVLW  05
6922:  MOVWF  FF7
6924:  CLRF   19
6926:  BTFSC  FF2.7
6928:  BSF    19.7
692A:  BCF    FF2.7
692C:  MOVLB  0
692E:  CALL   07A0
6932:  BTFSC  19.7
6934:  BSF    FF2.7
....................             #if defined(SIM900) 
....................                booting_done=0; 
6936:  MOVLB  1
6938:  CLRF   xB5
....................                output_low(rst_sim); 
693A:  BCF    F94.1
693C:  BCF    F8B.1
....................                fprintf(COM2,"reseting module SIM\n\r"); 
693E:  MOVLW  06
6940:  MOVWF  FF6
6942:  MOVLW  06
6944:  MOVWF  FF7
6946:  CLRF   19
6948:  BTFSC  FF2.7
694A:  BSF    19.7
694C:  BCF    FF2.7
694E:  MOVLB  0
6950:  CALL   07A0
6954:  BTFSC  19.7
6956:  BSF    FF2.7
....................             #endif    
....................             SIM_state=check_comunication; 
6958:  MOVLW  0F
695A:  MOVLB  4
695C:  MOVWF  x95
695E:  MOVLB  A
....................          } 
....................          if(buffer_uart[7+i]=='3') fprintf(COM2,"Ringing\n\r"); 
6960:  MOVLW  07
6962:  ADDWF  x8E,W
6964:  CLRF   03
6966:  ADDLW  4E
6968:  MOVWF  FE9
696A:  MOVLW  01
696C:  ADDWFC 03,W
696E:  MOVWF  FEA
6970:  MOVF   FEF,W
6972:  SUBLW  33
6974:  BNZ   6992
6976:  MOVLW  1C
6978:  MOVWF  FF6
697A:  MOVLW  06
697C:  MOVWF  FF7
697E:  CLRF   19
6980:  BTFSC  FF2.7
6982:  BSF    19.7
6984:  BCF    FF2.7
6986:  MOVLB  0
6988:  CALL   07A0
698C:  BTFSC  19.7
698E:  BSF    FF2.7
6990:  MOVLB  A
....................          if(buffer_uart[7+i]=='4') fprintf(COM2,"Call in progress\n\r"); 
6992:  MOVLW  07
6994:  ADDWF  x8E,W
6996:  CLRF   03
6998:  ADDLW  4E
699A:  MOVWF  FE9
699C:  MOVLW  01
699E:  ADDWFC 03,W
69A0:  MOVWF  FEA
69A2:  MOVF   FEF,W
69A4:  SUBLW  34
69A6:  BNZ   69C4
69A8:  MOVLW  26
69AA:  MOVWF  FF6
69AC:  MOVLW  06
69AE:  MOVWF  FF7
69B0:  CLRF   19
69B2:  BTFSC  FF2.7
69B4:  BSF    19.7
69B6:  BCF    FF2.7
69B8:  MOVLB  0
69BA:  CALL   07A0
69BE:  BTFSC  19.7
69C0:  BSF    FF2.7
69C2:  MOVLB  A
....................          st = 3; 
69C4:  MOVLW  03
69C6:  MOVWF  x8F
....................          i=23; 
69C8:  MOVLW  17
69CA:  MOVWF  x8E
....................       } 
....................          else st=0; 
69CC:  BRA    69D0
69CE:  CLRF   x8F
....................    } 
69D0:  INCF   x8E,F
69D2:  BRA    67E2
....................    for(i=0;i<20;i++) 
69D4:  CLRF   x8E
69D6:  MOVF   x8E,W
69D8:  SUBLW  13
69DA:  BTFSS  FD8.0
69DC:  BRA    6AD4
....................    { 
....................       if((buffer_uart[0+i]=='U')&&(buffer_uart[1+i]=='N')&&(buffer_uart[2+i]=='D')&&(buffer_uart[3+i]=='E')&&(buffer_uart[4+i]=='R')&&(buffer_uart[5+i]=='-')&&(buffer_uart[6+i]=='V')&&(buffer_uart[7+i]=='O')&&(buffer_uart[8+i]=='L'))  
69DE:  CLRF   03
69E0:  MOVF   x8E,W
69E2:  ADDLW  4E
69E4:  MOVWF  FE9
69E6:  MOVLW  01
69E8:  ADDWFC 03,W
69EA:  MOVWF  FEA
69EC:  MOVF   FEF,W
69EE:  SUBLW  55
69F0:  BTFSS  FD8.2
69F2:  BRA    6ACE
69F4:  MOVLW  01
69F6:  ADDWF  x8E,W
69F8:  CLRF   03
69FA:  ADDLW  4E
69FC:  MOVWF  FE9
69FE:  MOVLW  01
6A00:  ADDWFC 03,W
6A02:  MOVWF  FEA
6A04:  MOVF   FEF,W
6A06:  SUBLW  4E
6A08:  BNZ   6ACE
6A0A:  MOVLW  02
6A0C:  ADDWF  x8E,W
6A0E:  CLRF   03
6A10:  ADDLW  4E
6A12:  MOVWF  FE9
6A14:  MOVLW  01
6A16:  ADDWFC 03,W
6A18:  MOVWF  FEA
6A1A:  MOVF   FEF,W
6A1C:  SUBLW  44
6A1E:  BNZ   6ACE
6A20:  MOVLW  03
6A22:  ADDWF  x8E,W
6A24:  CLRF   03
6A26:  ADDLW  4E
6A28:  MOVWF  FE9
6A2A:  MOVLW  01
6A2C:  ADDWFC 03,W
6A2E:  MOVWF  FEA
6A30:  MOVF   FEF,W
6A32:  SUBLW  45
6A34:  BNZ   6ACE
6A36:  MOVLW  04
6A38:  ADDWF  x8E,W
6A3A:  CLRF   03
6A3C:  ADDLW  4E
6A3E:  MOVWF  FE9
6A40:  MOVLW  01
6A42:  ADDWFC 03,W
6A44:  MOVWF  FEA
6A46:  MOVF   FEF,W
6A48:  SUBLW  52
6A4A:  BNZ   6ACE
6A4C:  MOVLW  05
6A4E:  ADDWF  x8E,W
6A50:  CLRF   03
6A52:  ADDLW  4E
6A54:  MOVWF  FE9
6A56:  MOVLW  01
6A58:  ADDWFC 03,W
6A5A:  MOVWF  FEA
6A5C:  MOVF   FEF,W
6A5E:  SUBLW  2D
6A60:  BNZ   6ACE
6A62:  MOVLW  06
6A64:  ADDWF  x8E,W
6A66:  CLRF   03
6A68:  ADDLW  4E
6A6A:  MOVWF  FE9
6A6C:  MOVLW  01
6A6E:  ADDWFC 03,W
6A70:  MOVWF  FEA
6A72:  MOVF   FEF,W
6A74:  SUBLW  56
6A76:  BNZ   6ACE
6A78:  MOVLW  07
6A7A:  ADDWF  x8E,W
6A7C:  CLRF   03
6A7E:  ADDLW  4E
6A80:  MOVWF  FE9
6A82:  MOVLW  01
6A84:  ADDWFC 03,W
6A86:  MOVWF  FEA
6A88:  MOVF   FEF,W
6A8A:  SUBLW  4F
6A8C:  BNZ   6ACE
6A8E:  MOVLW  08
6A90:  ADDWF  x8E,W
6A92:  CLRF   03
6A94:  ADDLW  4E
6A96:  MOVWF  FE9
6A98:  MOVLW  01
6A9A:  ADDWFC 03,W
6A9C:  MOVWF  FEA
6A9E:  MOVF   FEF,W
6AA0:  SUBLW  4C
6AA2:  BNZ   6ACE
....................       {  
....................          fprintf(COM2,"\n\rUNDER-VOLTAGE WARNNING\n\r"); 
6AA4:  MOVLW  3A
6AA6:  MOVWF  FF6
6AA8:  MOVLW  06
6AAA:  MOVWF  FF7
6AAC:  CLRF   19
6AAE:  BTFSC  FF2.7
6AB0:  BSF    19.7
6AB2:  BCF    FF2.7
6AB4:  MOVLB  0
6AB6:  CALL   07A0
6ABA:  BTFSC  19.7
6ABC:  BSF    FF2.7
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
6ABE:  MOVLB  4
6AC0:  CLRF   x95
....................          st = 4; 
6AC2:  MOVLW  04
6AC4:  MOVLB  A
6AC6:  MOVWF  x8F
....................          i=23; 
6AC8:  MOVLW  17
6ACA:  MOVWF  x8E
....................       } 
....................          else st=0; 
6ACC:  BRA    6AD0
6ACE:  CLRF   x8F
....................    } 
6AD0:  INCF   x8E,F
6AD2:  BRA    69D6
....................    for(i=0;i<20;i++) 
6AD4:  CLRF   x8E
6AD6:  MOVF   x8E,W
6AD8:  SUBLW  13
6ADA:  BTFSS  FD8.0
6ADC:  BRA    6BD4
....................    { 
....................       if((buffer_uart[0+i]=='O')&&(buffer_uart[1+i]=='V')&&(buffer_uart[2+i]=='E')&&(buffer_uart[3+i]=='R')&&(buffer_uart[4+i]=='-')&&(buffer_uart[5+i]=='V')&&(buffer_uart[6+i]=='O')&&(buffer_uart[7+i]=='L')&&(buffer_uart[8+i]=='T'))  
6ADE:  CLRF   03
6AE0:  MOVF   x8E,W
6AE2:  ADDLW  4E
6AE4:  MOVWF  FE9
6AE6:  MOVLW  01
6AE8:  ADDWFC 03,W
6AEA:  MOVWF  FEA
6AEC:  MOVF   FEF,W
6AEE:  SUBLW  4F
6AF0:  BTFSS  FD8.2
6AF2:  BRA    6BCE
6AF4:  MOVLW  01
6AF6:  ADDWF  x8E,W
6AF8:  CLRF   03
6AFA:  ADDLW  4E
6AFC:  MOVWF  FE9
6AFE:  MOVLW  01
6B00:  ADDWFC 03,W
6B02:  MOVWF  FEA
6B04:  MOVF   FEF,W
6B06:  SUBLW  56
6B08:  BNZ   6BCE
6B0A:  MOVLW  02
6B0C:  ADDWF  x8E,W
6B0E:  CLRF   03
6B10:  ADDLW  4E
6B12:  MOVWF  FE9
6B14:  MOVLW  01
6B16:  ADDWFC 03,W
6B18:  MOVWF  FEA
6B1A:  MOVF   FEF,W
6B1C:  SUBLW  45
6B1E:  BNZ   6BCE
6B20:  MOVLW  03
6B22:  ADDWF  x8E,W
6B24:  CLRF   03
6B26:  ADDLW  4E
6B28:  MOVWF  FE9
6B2A:  MOVLW  01
6B2C:  ADDWFC 03,W
6B2E:  MOVWF  FEA
6B30:  MOVF   FEF,W
6B32:  SUBLW  52
6B34:  BNZ   6BCE
6B36:  MOVLW  04
6B38:  ADDWF  x8E,W
6B3A:  CLRF   03
6B3C:  ADDLW  4E
6B3E:  MOVWF  FE9
6B40:  MOVLW  01
6B42:  ADDWFC 03,W
6B44:  MOVWF  FEA
6B46:  MOVF   FEF,W
6B48:  SUBLW  2D
6B4A:  BNZ   6BCE
6B4C:  MOVLW  05
6B4E:  ADDWF  x8E,W
6B50:  CLRF   03
6B52:  ADDLW  4E
6B54:  MOVWF  FE9
6B56:  MOVLW  01
6B58:  ADDWFC 03,W
6B5A:  MOVWF  FEA
6B5C:  MOVF   FEF,W
6B5E:  SUBLW  56
6B60:  BNZ   6BCE
6B62:  MOVLW  06
6B64:  ADDWF  x8E,W
6B66:  CLRF   03
6B68:  ADDLW  4E
6B6A:  MOVWF  FE9
6B6C:  MOVLW  01
6B6E:  ADDWFC 03,W
6B70:  MOVWF  FEA
6B72:  MOVF   FEF,W
6B74:  SUBLW  4F
6B76:  BNZ   6BCE
6B78:  MOVLW  07
6B7A:  ADDWF  x8E,W
6B7C:  CLRF   03
6B7E:  ADDLW  4E
6B80:  MOVWF  FE9
6B82:  MOVLW  01
6B84:  ADDWFC 03,W
6B86:  MOVWF  FEA
6B88:  MOVF   FEF,W
6B8A:  SUBLW  4C
6B8C:  BNZ   6BCE
6B8E:  MOVLW  08
6B90:  ADDWF  x8E,W
6B92:  CLRF   03
6B94:  ADDLW  4E
6B96:  MOVWF  FE9
6B98:  MOVLW  01
6B9A:  ADDWFC 03,W
6B9C:  MOVWF  FEA
6B9E:  MOVF   FEF,W
6BA0:  SUBLW  54
6BA2:  BNZ   6BCE
....................       {  
....................          fprintf(COM2,"\n\rOVER-VOLTAGE POWER DOWN\n\r"); 
6BA4:  MOVLW  56
6BA6:  MOVWF  FF6
6BA8:  MOVLW  06
6BAA:  MOVWF  FF7
6BAC:  CLRF   19
6BAE:  BTFSC  FF2.7
6BB0:  BSF    19.7
6BB2:  BCF    FF2.7
6BB4:  MOVLB  0
6BB6:  CALL   07A0
6BBA:  BTFSC  19.7
6BBC:  BSF    FF2.7
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
6BBE:  MOVLB  4
6BC0:  CLRF   x95
....................          st = 4; 
6BC2:  MOVLW  04
6BC4:  MOVLB  A
6BC6:  MOVWF  x8F
....................          i=23; 
6BC8:  MOVLW  17
6BCA:  MOVWF  x8E
....................       } 
....................          else st=0; 
6BCC:  BRA    6BD0
6BCE:  CLRF   x8F
....................    } 
6BD0:  INCF   x8E,F
6BD2:  BRA    6AD6
....................  
....................    UART_index=0; 
6BD4:  MOVLB  1
6BD6:  CLRF   xB2
....................    memset(buffer_uart,0,sizeof(buffer_uart));  
6BD8:  MOVLW  01
6BDA:  MOVWF  FEA
6BDC:  MOVLW  4E
6BDE:  MOVWF  FE9
6BE0:  CLRF   00
6BE2:  CLRF   02
6BE4:  MOVLW  64
6BE6:  MOVWF  01
6BE8:  MOVLB  0
6BEA:  CALL   447A
....................    return st; 
6BEE:  MOVLB  A
6BF0:  MOVFF  A8F,01
.................... } 
6BF4:  MOVLB  0
6BF6:  GOTO   97A2 (RETURN)
.................... //============================================================ 
.................... unsigned int8 analyzing_msg(char* MSG,char* mobile_number) 
.................... { 
*
53FA:  MOVLB  A
53FC:  CLRF   x92
53FE:  CLRF   x93
5400:  CLRF   x94
5402:  CLRF   x95
5404:  CLRF   x96
5406:  CLRF   x97
5408:  CLRF   x98
540A:  CLRF   19
540C:  BTFSC  FF2.7
540E:  BSF    19.7
5410:  BCF    FF2.7
....................    unsigned int8 i=0,a=0,b=0,d=0,u=0,v=0; 
....................    unsigned int8 st=0,temp; 
....................    del_buf(50,MSG); 
5412:  MOVLW  32
5414:  MOVWF  xC5
5416:  MOVFF  A8F,AC7
541A:  MOVFF  A8E,AC6
541E:  MOVLB  0
5420:  CALL   3A6E
5424:  BTFSC  19.7
5426:  BSF    FF2.7
5428:  CLRF   19
542A:  BTFSC  FF2.7
542C:  BSF    19.7
542E:  BCF    FF2.7
....................    del_buf(20,mobile_number); 
5430:  MOVLW  14
5432:  MOVLB  A
5434:  MOVWF  xC5
5436:  MOVFF  A91,AC7
543A:  MOVFF  A90,AC6
543E:  MOVLB  0
5440:  CALL   3A6E
5444:  BTFSC  19.7
5446:  BSF    FF2.7
....................    for(i=0;i<100;i++) 
5448:  MOVLB  A
544A:  CLRF   x92
544C:  MOVF   x92,W
544E:  SUBLW  63
5450:  BNC   5480
....................    { 
....................       fprintf(COM2,"%c",buffer_uart[i]);  
5452:  CLRF   03
5454:  MOVF   x92,W
5456:  ADDLW  4E
5458:  MOVWF  FE9
545A:  MOVLW  01
545C:  ADDWFC 03,W
545E:  MOVWF  FEA
5460:  MOVFF  FEF,A9A
5464:  CLRF   19
5466:  BTFSC  FF2.7
5468:  BSF    19.7
546A:  BCF    FF2.7
546C:  MOVFF  A9A,ADF
5470:  MOVLB  0
5472:  CALL   075A
5476:  BTFSC  19.7
5478:  BSF    FF2.7
....................    } 
547A:  MOVLB  A
547C:  INCF   x92,F
547E:  BRA    544C
....................    for(i=0;i<100;i++) 
5480:  CLRF   x92
5482:  MOVF   x92,W
5484:  SUBLW  63
5486:  BTFSS  FD8.0
5488:  BRA    5694
....................    { 
....................       if((buffer_uart[i]=='+')&&(buffer_uart[i+1]=='C')&&(buffer_uart[i+2]=='M')&&(buffer_uart[i+3]=='G')&&(buffer_uart[i+4]=='R')&&(buffer_uart[i+5]==':')&&(buffer_uart[i+6]==' ')&&(buffer_uart[i+7]=='0')&&(buffer_uart[i+8]==',')&&(buffer_uart[i+9]==',')&&(buffer_uart[i+10]=='0'))  
548A:  CLRF   03
548C:  MOVF   x92,W
548E:  ADDLW  4E
5490:  MOVWF  FE9
5492:  MOVLW  01
5494:  ADDWFC 03,W
5496:  MOVWF  FEA
5498:  MOVF   FEF,W
549A:  SUBLW  2B
549C:  BTFSS  FD8.2
549E:  BRA    55CC
54A0:  MOVLW  01
54A2:  ADDWF  x92,W
54A4:  CLRF   03
54A6:  ADDLW  4E
54A8:  MOVWF  FE9
54AA:  MOVLW  01
54AC:  ADDWFC 03,W
54AE:  MOVWF  FEA
54B0:  MOVF   FEF,W
54B2:  SUBLW  43
54B4:  BTFSS  FD8.2
54B6:  BRA    55CC
54B8:  MOVLW  02
54BA:  ADDWF  x92,W
54BC:  CLRF   03
54BE:  ADDLW  4E
54C0:  MOVWF  FE9
54C2:  MOVLW  01
54C4:  ADDWFC 03,W
54C6:  MOVWF  FEA
54C8:  MOVF   FEF,W
54CA:  SUBLW  4D
54CC:  BTFSS  FD8.2
54CE:  BRA    55CC
54D0:  MOVLW  03
54D2:  ADDWF  x92,W
54D4:  CLRF   03
54D6:  ADDLW  4E
54D8:  MOVWF  FE9
54DA:  MOVLW  01
54DC:  ADDWFC 03,W
54DE:  MOVWF  FEA
54E0:  MOVF   FEF,W
54E2:  SUBLW  47
54E4:  BTFSS  FD8.2
54E6:  BRA    55CC
54E8:  MOVLW  04
54EA:  ADDWF  x92,W
54EC:  CLRF   03
54EE:  ADDLW  4E
54F0:  MOVWF  FE9
54F2:  MOVLW  01
54F4:  ADDWFC 03,W
54F6:  MOVWF  FEA
54F8:  MOVF   FEF,W
54FA:  SUBLW  52
54FC:  BNZ   55CC
54FE:  MOVLW  05
5500:  ADDWF  x92,W
5502:  CLRF   03
5504:  ADDLW  4E
5506:  MOVWF  FE9
5508:  MOVLW  01
550A:  ADDWFC 03,W
550C:  MOVWF  FEA
550E:  MOVF   FEF,W
5510:  SUBLW  3A
5512:  BNZ   55CC
5514:  MOVLW  06
5516:  ADDWF  x92,W
5518:  CLRF   03
551A:  ADDLW  4E
551C:  MOVWF  FE9
551E:  MOVLW  01
5520:  ADDWFC 03,W
5522:  MOVWF  FEA
5524:  MOVF   FEF,W
5526:  SUBLW  20
5528:  BNZ   55CC
552A:  MOVLW  07
552C:  ADDWF  x92,W
552E:  CLRF   03
5530:  ADDLW  4E
5532:  MOVWF  FE9
5534:  MOVLW  01
5536:  ADDWFC 03,W
5538:  MOVWF  FEA
553A:  MOVF   FEF,W
553C:  SUBLW  30
553E:  BNZ   55CC
5540:  MOVLW  08
5542:  ADDWF  x92,W
5544:  CLRF   03
5546:  ADDLW  4E
5548:  MOVWF  FE9
554A:  MOVLW  01
554C:  ADDWFC 03,W
554E:  MOVWF  FEA
5550:  MOVF   FEF,W
5552:  SUBLW  2C
5554:  BNZ   55CC
5556:  MOVLW  09
5558:  ADDWF  x92,W
555A:  CLRF   03
555C:  ADDLW  4E
555E:  MOVWF  FE9
5560:  MOVLW  01
5562:  ADDWFC 03,W
5564:  MOVWF  FEA
5566:  MOVF   FEF,W
5568:  SUBLW  2C
556A:  BNZ   55CC
556C:  MOVLW  0A
556E:  ADDWF  x92,W
5570:  CLRF   03
5572:  ADDLW  4E
5574:  MOVWF  FE9
5576:  MOVLW  01
5578:  ADDWFC 03,W
557A:  MOVWF  FEA
557C:  MOVF   FEF,W
557E:  SUBLW  30
5580:  BNZ   55CC
....................       { 
....................          st=0; 
5582:  CLRF   x98
....................          i=200; 
5584:  MOVLW  C8
5586:  MOVWF  x92
5588:  CLRF   19
558A:  BTFSC  FF2.7
558C:  BSF    19.7
558E:  BCF    FF2.7
....................          del_buf(100,MSG); 
5590:  MOVLW  64
5592:  MOVWF  xC5
5594:  MOVFF  A8F,AC7
5598:  MOVFF  A8E,AC6
559C:  MOVLB  0
559E:  CALL   3A6E
55A2:  BTFSC  19.7
55A4:  BSF    FF2.7
55A6:  CLRF   19
55A8:  BTFSC  FF2.7
55AA:  BSF    19.7
55AC:  BCF    FF2.7
....................          del_buf(16,mobile_number); 
55AE:  MOVLW  10
55B0:  MOVLB  A
55B2:  MOVWF  xC5
55B4:  MOVFF  A91,AC7
55B8:  MOVFF  A90,AC6
55BC:  MOVLB  0
55BE:  CALL   3A6E
55C2:  BTFSC  19.7
55C4:  BSF    FF2.7
....................          count_spam=0; 
55C6:  MOVLB  1
55C8:  CLRF   x04
55CA:  MOVLB  A
....................          //output_toggle(pin_a5); 
....................       } 
....................          //else st=2; 
....................      temp = buffer_uart[i]; 
55CC:  CLRF   03
55CE:  MOVF   x92,W
55D0:  ADDLW  4E
55D2:  MOVWF  FE9
55D4:  MOVLW  01
55D6:  ADDWFC 03,W
55D8:  MOVWF  FEA
55DA:  MOVFF  FEF,A99
....................      if((a==3))  
55DE:  MOVF   x93,W
55E0:  SUBLW  03
55E2:  BNZ   560A
....................      { 
....................        if((temp>47)&&(temp<58)||temp=='+') mobile_number[i-b] = temp; 
55E4:  MOVF   x99,W
55E6:  SUBLW  2F
55E8:  BC    55F0
55EA:  MOVF   x99,W
55EC:  SUBLW  39
55EE:  BC    55F6
55F0:  MOVF   x99,W
55F2:  SUBLW  2B
55F4:  BNZ   560A
55F6:  MOVF   x94,W
55F8:  SUBWF  x92,W
55FA:  CLRF   03
55FC:  ADDWF  x90,W
55FE:  MOVWF  FE9
5600:  MOVF   x91,W
5602:  ADDWFC 03,W
5604:  MOVWF  FEA
5606:  MOVFF  A99,FEF
....................      } 
....................      if(d==2) 
560A:  MOVF   x95,W
560C:  SUBLW  02
560E:  BNZ   5628
....................      { 
....................          MSG[i-b] = temp; 
5610:  MOVF   x94,W
5612:  SUBWF  x92,W
5614:  CLRF   03
5616:  ADDWF  x8E,W
5618:  MOVWF  FE9
561A:  MOVF   x8F,W
561C:  ADDWFC 03,W
561E:  MOVWF  FEA
5620:  MOVFF  A99,FEF
....................          st=1; 
5624:  MOVLW  01
5626:  MOVWF  x98
....................      } 
....................      if(u==2) 
5628:  MOVF   x96,W
562A:  SUBLW  02
562C:  BNZ   5642
....................      { 
....................          datetime[i-v]=temp; 
562E:  MOVF   x97,W
5630:  SUBWF  x92,W
5632:  CLRF   03
5634:  ADDLW  60
5636:  MOVWF  FE9
5638:  MOVLW  04
563A:  ADDWFC 03,W
563C:  MOVWF  FEA
563E:  MOVFF  A99,FEF
....................      } 
....................       //else st=2; 
....................      if(temp==34)  
5642:  MOVF   x99,W
5644:  SUBLW  22
5646:  BNZ   565C
....................      { 
....................          if(a<6)a++; 
5648:  MOVF   x93,W
564A:  SUBLW  05
564C:  BTFSC  FD8.0
564E:  INCF   x93,F
....................          if(a==3) b = i+1; 
5650:  MOVF   x93,W
5652:  SUBLW  03
5654:  BNZ   565C
5656:  MOVLW  01
5658:  ADDWF  x92,W
565A:  MOVWF  x94
....................      } 
....................      if(a==6) 
565C:  MOVF   x93,W
565E:  SUBLW  06
5660:  BNZ   5690
....................      { 
....................          if((temp==13)||(temp==10))  
5662:  MOVF   x99,W
5664:  SUBLW  0D
5666:  BZ    566E
5668:  MOVF   x99,W
566A:  SUBLW  0A
566C:  BNZ   567C
....................          { 
....................             d++; 
566E:  INCF   x95,F
....................             if(d==2) b = i+1; 
5670:  MOVF   x95,W
5672:  SUBLW  02
5674:  BNZ   567C
5676:  MOVLW  01
5678:  ADDWF  x92,W
567A:  MOVWF  x94
....................          } 
....................          if(temp==34)  
567C:  MOVF   x99,W
567E:  SUBLW  22
5680:  BNZ   5690
....................          { 
....................             u++; 
5682:  INCF   x96,F
....................             if(u==2)v=i+1; 
5684:  MOVF   x96,W
5686:  SUBLW  02
5688:  BNZ   5690
568A:  MOVLW  01
568C:  ADDWF  x92,W
568E:  MOVWF  x97
....................          } 
....................      } 
....................      //if((temp==',')&&(a==6)) 
....................     // { 
....................          //if(c<2)c++; 
....................      //} 
....................    } 
5690:  INCF   x92,F
5692:  BRA    5482
....................    return(st); 
5694:  MOVFF  A98,01
.................... } 
5698:  MOVLB  0
569A:  GOTO   7496 (RETURN)
.................... //================================ 
.................... int8 ascii2int(int8 num1,int8 num2) 
.................... { 
....................    int8 temp; 
....................    temp=(num1-48)*10 + (num2-48); 
*
5836:  MOVLW  30
5838:  MOVLB  A
583A:  SUBWF  x8F,W
583C:  MULLW  0A
583E:  MOVFF  FF3,A92
5842:  MOVLW  30
5844:  SUBWF  x90,W
5846:  ADDWF  x92,W
5848:  MOVWF  x91
....................    return temp; 
584A:  MOVFF  A91,01
.................... } 
584E:  MOVLB  0
5850:  RETURN 0
.................... //================================ 
.................... void updatetime2ds1307() 
.................... { 
....................    int8 temp; 
....................    year=ascii2int(datetime[0],datetime[1]); 
*
59E8:  MOVFF  460,A8F
59EC:  MOVFF  461,A90
59F0:  RCALL  5836
59F2:  MOVFF  01,FE
....................    mon=ascii2int(datetime[3],datetime[4]); 
59F6:  MOVFF  463,A8F
59FA:  MOVFF  464,A90
59FE:  RCALL  5836
5A00:  MOVFF  01,FF
....................    date=ascii2int(datetime[6],datetime[7]); 
5A04:  MOVFF  466,A8F
5A08:  MOVFF  467,A90
5A0C:  RCALL  5836
5A0E:  MOVFF  01,100
....................    h=ascii2int(datetime[9],datetime[10]); 
5A12:  MOVFF  469,A8F
5A16:  MOVFF  46A,A90
5A1A:  RCALL  5836
5A1C:  MOVFF  01,101
....................    min=ascii2int(datetime[12],datetime[13])+1; 
5A20:  MOVFF  46C,A8F
5A24:  MOVFF  46D,A90
5A28:  RCALL  5836
5A2A:  MOVLW  01
5A2C:  ADDWF  01,W
5A2E:  MOVLB  1
5A30:  MOVWF  x02
....................    //h=ascii2int(datetime[9],datetime[10]); 
....................    rtc_set_datetime(date,mon,year,day,h,min); 
5A32:  MOVFF  100,A8F
5A36:  MOVFF  FF,A90
5A3A:  MOVFF  FE,A91
5A3E:  MOVFF  FD,A92
5A42:  MOVFF  101,A93
5A46:  MOVFF  102,A94
5A4A:  MOVLB  0
5A4C:  BRA    593E
.................... } 
5A4E:  RETURN 0
.................... //================================ 
....................  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
07C0:  MOVLB  A
07C2:  CLRF   xEF
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
07C4:  CLRF   xF0
07C6:  BTFSC  xE7.0
07C8:  BSF    xF0.7
07CA:  SWAPF  xE8,W
07CC:  MOVWF  00
07CE:  RLCF   00,F
07D0:  RLCF   00,F
07D2:  MOVLW  C0
07D4:  ANDWF  00,F
07D6:  MOVF   00,W
07D8:  IORWF  xF0,F
07DA:  SWAPF  xE9,W
07DC:  MOVWF  00
07DE:  RLCF   00,F
07E0:  MOVLW  E0
07E2:  ANDWF  00,F
07E4:  MOVF   00,W
07E6:  IORWF  xF0,F
07E8:  SWAPF  xEA,W
07EA:  MOVWF  00
07EC:  MOVLW  F0
07EE:  ANDWF  00,F
07F0:  MOVF   00,W
07F2:  IORWF  xF0,F
07F4:  RLCF   xEB,W
07F6:  MOVWF  00
07F8:  RLCF   00,F
07FA:  RLCF   00,F
07FC:  MOVLW  F8
07FE:  ANDWF  00,F
0800:  MOVF   00,W
0802:  IORWF  xF0,F
0804:  RLCF   xEC,W
0806:  MOVWF  00
0808:  RLCF   00,F
080A:  MOVLW  FC
080C:  ANDWF  00,F
080E:  MOVF   00,W
0810:  IORWF  xF0,F
0812:  BCF    FD8.0
0814:  RLCF   xED,W
0816:  IORWF  xF0,F
0818:  MOVF   xEE,W
081A:  IORWF  xF0,W
081C:  MOVWF  xEF
....................    return temp; 
081E:  MOVFF  AEF,01
.................... } 
0822:  MOVLB  0
0824:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0826:  MOVLB  A
0828:  CLRF   xD7
....................    int8 temp=0; 
....................    if(direct==0) 
082A:  MOVF   xD2,F
082C:  BNZ   0902
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
082E:  MOVF   xD5,W
0830:  ADDWF  xD3,W
0832:  MOVWF  FE9
0834:  MOVF   xD6,W
0836:  ADDWFC xD4,W
0838:  MOVWF  FEA
083A:  MOVFF  FEF,AD8
083E:  MOVLW  01
0840:  ADDWF  xD3,W
0842:  MOVWF  xD9
0844:  MOVLW  00
0846:  ADDWFC xD4,W
0848:  MOVWF  xDA
084A:  MOVF   xD5,W
084C:  ADDWF  xD9,W
084E:  MOVWF  FE9
0850:  MOVF   xD6,W
0852:  ADDWFC xDA,W
0854:  MOVWF  FEA
0856:  MOVF   FEF,W
0858:  XORWF  xD8,F
085A:  MOVLW  02
085C:  ADDWF  xD3,W
085E:  MOVWF  xDB
0860:  MOVLW  00
0862:  ADDWFC xD4,W
0864:  MOVWF  xDC
0866:  MOVF   xD5,W
0868:  ADDWF  xDB,W
086A:  MOVWF  FE9
086C:  MOVF   xD6,W
086E:  ADDWFC xDC,W
0870:  MOVWF  FEA
0872:  MOVF   FEF,W
0874:  XORWF  xD8,F
0876:  MOVLW  03
0878:  ADDWF  xD3,W
087A:  MOVWF  xDD
087C:  MOVLW  00
087E:  ADDWFC xD4,W
0880:  MOVWF  xDE
0882:  MOVF   xD5,W
0884:  ADDWF  xDD,W
0886:  MOVWF  FE9
0888:  MOVF   xD6,W
088A:  ADDWFC xDE,W
088C:  MOVWF  FEA
088E:  MOVF   FEF,W
0890:  XORWF  xD8,F
0892:  MOVLW  04
0894:  ADDWF  xD3,W
0896:  MOVWF  xDF
0898:  MOVLW  00
089A:  ADDWFC xD4,W
089C:  MOVWF  xE0
089E:  MOVF   xD5,W
08A0:  ADDWF  xDF,W
08A2:  MOVWF  FE9
08A4:  MOVF   xD6,W
08A6:  ADDWFC xE0,W
08A8:  MOVWF  FEA
08AA:  MOVF   FEF,W
08AC:  XORWF  xD8,F
08AE:  MOVLW  05
08B0:  ADDWF  xD3,W
08B2:  MOVWF  xE1
08B4:  MOVLW  00
08B6:  ADDWFC xD4,W
08B8:  MOVWF  xE2
08BA:  MOVF   xD5,W
08BC:  ADDWF  xE1,W
08BE:  MOVWF  FE9
08C0:  MOVF   xD6,W
08C2:  ADDWFC xE2,W
08C4:  MOVWF  FEA
08C6:  MOVF   FEF,W
08C8:  XORWF  xD8,W
08CA:  BZ    08D0
08CC:  MOVLW  00
08CE:  BRA    08D2
08D0:  MOVLW  01
08D2:  MOVWF  xD7
....................       if(temp==datain[offset+6]) return 1; 
08D4:  MOVLW  06
08D6:  ADDWF  xD3,W
08D8:  MOVWF  xD8
08DA:  MOVLW  00
08DC:  ADDWFC xD4,W
08DE:  MOVWF  xD9
08E0:  MOVF   xD5,W
08E2:  ADDWF  xD8,W
08E4:  MOVWF  FE9
08E6:  MOVF   xD6,W
08E8:  ADDWFC xD9,W
08EA:  MOVWF  FEA
08EC:  MOVF   FEF,W
08EE:  SUBWF  xD7,W
08F0:  BNZ   08FA
08F2:  MOVLW  01
08F4:  MOVWF  01
08F6:  BRA    09D2
....................          else return 0; 
08F8:  BRA    0900
08FA:  MOVLW  00
08FC:  MOVWF  01
08FE:  BRA    09D2
....................    } 
....................       else  
0900:  BRA    09D2
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
0902:  MOVF   xD5,W
0904:  ADDWF  xD3,W
0906:  MOVWF  FE9
0908:  MOVF   xD6,W
090A:  ADDWFC xD4,W
090C:  MOVWF  FEA
090E:  MOVFF  FEF,AD8
0912:  MOVLW  01
0914:  SUBWF  xD3,W
0916:  MOVWF  xD9
0918:  MOVLW  00
091A:  SUBWFB xD4,W
091C:  MOVWF  xDA
091E:  MOVF   xD5,W
0920:  ADDWF  xD9,W
0922:  MOVWF  FE9
0924:  MOVF   xD6,W
0926:  ADDWFC xDA,W
0928:  MOVWF  FEA
092A:  MOVF   FEF,W
092C:  XORWF  xD8,F
092E:  MOVLW  02
0930:  SUBWF  xD3,W
0932:  MOVWF  xDB
0934:  MOVLW  00
0936:  SUBWFB xD4,W
0938:  MOVWF  xDC
093A:  MOVF   xD5,W
093C:  ADDWF  xDB,W
093E:  MOVWF  FE9
0940:  MOVF   xD6,W
0942:  ADDWFC xDC,W
0944:  MOVWF  FEA
0946:  MOVF   FEF,W
0948:  XORWF  xD8,F
094A:  MOVLW  03
094C:  SUBWF  xD3,W
094E:  MOVWF  xDD
0950:  MOVLW  00
0952:  SUBWFB xD4,W
0954:  MOVWF  xDE
0956:  MOVF   xD5,W
0958:  ADDWF  xDD,W
095A:  MOVWF  FE9
095C:  MOVF   xD6,W
095E:  ADDWFC xDE,W
0960:  MOVWF  FEA
0962:  MOVF   FEF,W
0964:  XORWF  xD8,F
0966:  MOVLW  04
0968:  SUBWF  xD3,W
096A:  MOVWF  xDF
096C:  MOVLW  00
096E:  SUBWFB xD4,W
0970:  MOVWF  xE0
0972:  MOVF   xD5,W
0974:  ADDWF  xDF,W
0976:  MOVWF  FE9
0978:  MOVF   xD6,W
097A:  ADDWFC xE0,W
097C:  MOVWF  FEA
097E:  MOVF   FEF,W
0980:  XORWF  xD8,F
0982:  MOVLW  05
0984:  SUBWF  xD3,W
0986:  MOVWF  xE1
0988:  MOVLW  00
098A:  SUBWFB xD4,W
098C:  MOVWF  xE2
098E:  MOVF   xD5,W
0990:  ADDWF  xE1,W
0992:  MOVWF  FE9
0994:  MOVF   xD6,W
0996:  ADDWFC xE2,W
0998:  MOVWF  FEA
099A:  MOVF   FEF,W
099C:  XORWF  xD8,W
099E:  BZ    09A4
09A0:  MOVLW  00
09A2:  BRA    09A6
09A4:  MOVLW  01
09A6:  MOVWF  xD7
....................          if(temp==datain[offset-6]) return 1; 
09A8:  MOVLW  06
09AA:  SUBWF  xD3,W
09AC:  MOVWF  xD8
09AE:  MOVLW  00
09B0:  SUBWFB xD4,W
09B2:  MOVWF  xD9
09B4:  MOVF   xD5,W
09B6:  ADDWF  xD8,W
09B8:  MOVWF  FE9
09BA:  MOVF   xD6,W
09BC:  ADDWFC xD9,W
09BE:  MOVWF  FEA
09C0:  MOVF   FEF,W
09C2:  SUBWF  xD7,W
09C4:  BNZ   09CE
09C6:  MOVLW  01
09C8:  MOVWF  01
09CA:  BRA    09D2
....................             else return 0;          
09CC:  BRA    09D2
09CE:  MOVLW  00
09D0:  MOVWF  01
....................       } 
.................... } 
09D2:  MOVLB  0
09D4:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
09D6:  MOVLB  A
09D8:  CLRF   xD7
....................    int8 temp=0; 
....................    if(direct==0) 
09DA:  MOVF   xD2,F
09DC:  BNZ   0A7A
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
09DE:  MOVF   xD5,W
09E0:  ADDWF  xD3,W
09E2:  MOVWF  FE9
09E4:  MOVF   xD6,W
09E6:  ADDWFC xD4,W
09E8:  MOVWF  FEA
09EA:  MOVFF  FEF,AD8
09EE:  MOVLW  01
09F0:  ADDWF  xD3,W
09F2:  MOVWF  xD9
09F4:  MOVLW  00
09F6:  ADDWFC xD4,W
09F8:  MOVWF  xDA
09FA:  MOVF   xD5,W
09FC:  ADDWF  xD9,W
09FE:  MOVWF  FE9
0A00:  MOVF   xD6,W
0A02:  ADDWFC xDA,W
0A04:  MOVWF  FEA
0A06:  MOVF   FEF,W
0A08:  XORWF  xD8,F
0A0A:  MOVLW  02
0A0C:  ADDWF  xD3,W
0A0E:  MOVWF  xDB
0A10:  MOVLW  00
0A12:  ADDWFC xD4,W
0A14:  MOVWF  xDC
0A16:  MOVF   xD5,W
0A18:  ADDWF  xDB,W
0A1A:  MOVWF  FE9
0A1C:  MOVF   xD6,W
0A1E:  ADDWFC xDC,W
0A20:  MOVWF  FEA
0A22:  MOVF   FEF,W
0A24:  XORWF  xD8,F
0A26:  MOVLW  03
0A28:  ADDWF  xD3,W
0A2A:  MOVWF  xDD
0A2C:  MOVLW  00
0A2E:  ADDWFC xD4,W
0A30:  MOVWF  xDE
0A32:  MOVF   xD5,W
0A34:  ADDWF  xDD,W
0A36:  MOVWF  FE9
0A38:  MOVF   xD6,W
0A3A:  ADDWFC xDE,W
0A3C:  MOVWF  FEA
0A3E:  MOVF   FEF,W
0A40:  XORWF  xD8,W
0A42:  BZ    0A48
0A44:  MOVLW  00
0A46:  BRA    0A4A
0A48:  MOVLW  01
0A4A:  MOVWF  xD7
....................       if(temp==datain[offset+4]) return 1; 
0A4C:  MOVLW  04
0A4E:  ADDWF  xD3,W
0A50:  MOVWF  xD8
0A52:  MOVLW  00
0A54:  ADDWFC xD4,W
0A56:  MOVWF  xD9
0A58:  MOVF   xD5,W
0A5A:  ADDWF  xD8,W
0A5C:  MOVWF  FE9
0A5E:  MOVF   xD6,W
0A60:  ADDWFC xD9,W
0A62:  MOVWF  FEA
0A64:  MOVF   FEF,W
0A66:  SUBWF  xD7,W
0A68:  BNZ   0A72
0A6A:  MOVLW  01
0A6C:  MOVWF  01
0A6E:  BRA    0B12
....................          else return 0; 
0A70:  BRA    0A78
0A72:  MOVLW  00
0A74:  MOVWF  01
0A76:  BRA    0B12
....................    } 
....................    else 
0A78:  BRA    0B12
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0A7A:  MOVF   xD5,W
0A7C:  ADDWF  xD3,W
0A7E:  MOVWF  FE9
0A80:  MOVF   xD6,W
0A82:  ADDWFC xD4,W
0A84:  MOVWF  FEA
0A86:  MOVFF  FEF,AD8
0A8A:  MOVLW  01
0A8C:  SUBWF  xD3,W
0A8E:  MOVWF  xD9
0A90:  MOVLW  00
0A92:  SUBWFB xD4,W
0A94:  MOVWF  xDA
0A96:  MOVF   xD5,W
0A98:  ADDWF  xD9,W
0A9A:  MOVWF  FE9
0A9C:  MOVF   xD6,W
0A9E:  ADDWFC xDA,W
0AA0:  MOVWF  FEA
0AA2:  MOVF   FEF,W
0AA4:  XORWF  xD8,F
0AA6:  MOVLW  02
0AA8:  SUBWF  xD3,W
0AAA:  MOVWF  xDB
0AAC:  MOVLW  00
0AAE:  SUBWFB xD4,W
0AB0:  MOVWF  xDC
0AB2:  MOVF   xD5,W
0AB4:  ADDWF  xDB,W
0AB6:  MOVWF  FE9
0AB8:  MOVF   xD6,W
0ABA:  ADDWFC xDC,W
0ABC:  MOVWF  FEA
0ABE:  MOVF   FEF,W
0AC0:  XORWF  xD8,F
0AC2:  MOVLW  03
0AC4:  SUBWF  xD3,W
0AC6:  MOVWF  xDD
0AC8:  MOVLW  00
0ACA:  SUBWFB xD4,W
0ACC:  MOVWF  xDE
0ACE:  MOVF   xD5,W
0AD0:  ADDWF  xDD,W
0AD2:  MOVWF  FE9
0AD4:  MOVF   xD6,W
0AD6:  ADDWFC xDE,W
0AD8:  MOVWF  FEA
0ADA:  MOVF   FEF,W
0ADC:  XORWF  xD8,W
0ADE:  BZ    0AE4
0AE0:  MOVLW  00
0AE2:  BRA    0AE6
0AE4:  MOVLW  01
0AE6:  MOVWF  xD7
....................       if(temp==datain[offset-4]) return 1; 
0AE8:  MOVLW  04
0AEA:  SUBWF  xD3,W
0AEC:  MOVWF  xD8
0AEE:  MOVLW  00
0AF0:  SUBWFB xD4,W
0AF2:  MOVWF  xD9
0AF4:  MOVF   xD5,W
0AF6:  ADDWF  xD8,W
0AF8:  MOVWF  FE9
0AFA:  MOVF   xD6,W
0AFC:  ADDWFC xD9,W
0AFE:  MOVWF  FEA
0B00:  MOVF   FEF,W
0B02:  SUBWF  xD7,W
0B04:  BNZ   0B0E
0B06:  MOVLW  01
0B08:  MOVWF  01
0B0A:  BRA    0B12
....................          else return 0;                
0B0C:  BRA    0B12
0B0E:  MOVLW  00
0B10:  MOVWF  01
....................    } 
.................... } 
0B12:  MOVLB  0
0B14:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0B16:  MOVLB  A
0B18:  CLRF   xCE
0B1A:  CLRF   xCF
0B1C:  CLRF   xD0
0B1E:  CLRF   xD1
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0B20:  CLRF   xCB
0B22:  CLRF   xCA
0B24:  RRCF   xC7,W
0B26:  MOVWF  03
0B28:  RRCF   xC6,W
0B2A:  MOVWF  02
0B2C:  RRCF   03,F
0B2E:  RRCF   02,F
0B30:  MOVLW  3F
0B32:  ANDWF  03,F
0B34:  MOVFF  02,01
0B38:  MOVF   xCB,W
0B3A:  SUBWF  03,W
0B3C:  BTFSS  FD8.0
0B3E:  BRA    10FE
0B40:  BNZ   0B4A
0B42:  MOVF   01,W
0B44:  SUBWF  xCA,W
0B46:  BTFSC  FD8.0
0B48:  BRA    10FE
....................    { 
....................       if(track==0) 
0B4A:  MOVF   xC5,F
0B4C:  BTFSS  FD8.2
0B4E:  BRA    0E84
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0B50:  MOVLW  06
0B52:  ADDWF  xCA,W
0B54:  MOVWF  xD2
0B56:  MOVLW  00
0B58:  ADDWFC xCB,W
0B5A:  MOVWF  xD3
0B5C:  MOVF   xC8,W
0B5E:  ADDWF  xD2,W
0B60:  MOVWF  FE9
0B62:  MOVF   xC9,W
0B64:  ADDWFC xD3,W
0B66:  MOVWF  FEA
0B68:  MOVFF  FEF,AD4
0B6C:  MOVLW  05
0B6E:  ADDWF  xCA,W
0B70:  MOVWF  xD5
0B72:  MOVLW  00
0B74:  ADDWFC xCB,W
0B76:  MOVWF  xD6
0B78:  MOVF   xC8,W
0B7A:  ADDWF  xD5,W
0B7C:  MOVWF  FE9
0B7E:  MOVF   xC9,W
0B80:  ADDWFC xD6,W
0B82:  MOVWF  FEA
0B84:  MOVFF  FEF,AD7
0B88:  MOVLW  04
0B8A:  ADDWF  xCA,W
0B8C:  MOVWF  xD8
0B8E:  MOVLW  00
0B90:  ADDWFC xCB,W
0B92:  MOVWF  xD9
0B94:  MOVF   xC8,W
0B96:  ADDWF  xD8,W
0B98:  MOVWF  FE9
0B9A:  MOVF   xC9,W
0B9C:  ADDWFC xD9,W
0B9E:  MOVWF  FEA
0BA0:  MOVFF  FEF,ADA
0BA4:  MOVLW  03
0BA6:  ADDWF  xCA,W
0BA8:  MOVWF  xDB
0BAA:  MOVLW  00
0BAC:  ADDWFC xCB,W
0BAE:  MOVWF  xDC
0BB0:  MOVF   xC8,W
0BB2:  ADDWF  xDB,W
0BB4:  MOVWF  FE9
0BB6:  MOVF   xC9,W
0BB8:  ADDWFC xDC,W
0BBA:  MOVWF  FEA
0BBC:  MOVFF  FEF,ADD
0BC0:  MOVLW  02
0BC2:  ADDWF  xCA,W
0BC4:  MOVWF  xDE
0BC6:  MOVLW  00
0BC8:  ADDWFC xCB,W
0BCA:  MOVWF  xDF
0BCC:  MOVF   xC8,W
0BCE:  ADDWF  xDE,W
0BD0:  MOVWF  FE9
0BD2:  MOVF   xC9,W
0BD4:  ADDWFC xDF,W
0BD6:  MOVWF  FEA
0BD8:  MOVFF  FEF,AE0
0BDC:  MOVLW  01
0BDE:  ADDWF  xCA,W
0BE0:  MOVWF  xE1
0BE2:  MOVLW  00
0BE4:  ADDWFC xCB,W
0BE6:  MOVWF  xE2
0BE8:  MOVF   xC8,W
0BEA:  ADDWF  xE1,W
0BEC:  MOVWF  FE9
0BEE:  MOVF   xC9,W
0BF0:  ADDWFC xE2,W
0BF2:  MOVWF  FEA
0BF4:  MOVFF  FEF,AE3
0BF8:  MOVF   xC8,W
0BFA:  ADDWF  xCA,W
0BFC:  MOVWF  FE9
0BFE:  MOVF   xC9,W
0C00:  ADDWFC xCB,W
0C02:  MOVWF  FEA
0C04:  MOVFF  FEF,AE4
0C08:  CLRF   xE7
0C0A:  MOVFF  AD4,AE8
0C0E:  MOVFF  AD7,AE9
0C12:  MOVFF  ADA,AEA
0C16:  MOVFF  ADD,AEB
0C1A:  MOVFF  AE0,AEC
0C1E:  MOVFF  AE3,AED
0C22:  MOVFF  AE4,AEE
0C26:  MOVLB  0
0C28:  RCALL  07C0
0C2A:  MOVFF  01,ACE
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0C2E:  MOVLW  0D
0C30:  MOVLB  A
0C32:  ADDWF  xCA,W
0C34:  MOVWF  xD2
0C36:  MOVLW  00
0C38:  ADDWFC xCB,W
0C3A:  MOVWF  xD3
0C3C:  MOVF   xC8,W
0C3E:  ADDWF  xD2,W
0C40:  MOVWF  FE9
0C42:  MOVF   xC9,W
0C44:  ADDWFC xD3,W
0C46:  MOVWF  FEA
0C48:  MOVFF  FEF,AD4
0C4C:  MOVLW  0C
0C4E:  ADDWF  xCA,W
0C50:  MOVWF  xD5
0C52:  MOVLW  00
0C54:  ADDWFC xCB,W
0C56:  MOVWF  xD6
0C58:  MOVF   xC8,W
0C5A:  ADDWF  xD5,W
0C5C:  MOVWF  FE9
0C5E:  MOVF   xC9,W
0C60:  ADDWFC xD6,W
0C62:  MOVWF  FEA
0C64:  MOVFF  FEF,AD7
0C68:  MOVLW  0B
0C6A:  ADDWF  xCA,W
0C6C:  MOVWF  xD8
0C6E:  MOVLW  00
0C70:  ADDWFC xCB,W
0C72:  MOVWF  xD9
0C74:  MOVF   xC8,W
0C76:  ADDWF  xD8,W
0C78:  MOVWF  FE9
0C7A:  MOVF   xC9,W
0C7C:  ADDWFC xD9,W
0C7E:  MOVWF  FEA
0C80:  MOVFF  FEF,ADA
0C84:  MOVLW  0A
0C86:  ADDWF  xCA,W
0C88:  MOVWF  xDB
0C8A:  MOVLW  00
0C8C:  ADDWFC xCB,W
0C8E:  MOVWF  xDC
0C90:  MOVF   xC8,W
0C92:  ADDWF  xDB,W
0C94:  MOVWF  FE9
0C96:  MOVF   xC9,W
0C98:  ADDWFC xDC,W
0C9A:  MOVWF  FEA
0C9C:  MOVFF  FEF,ADD
0CA0:  MOVLW  09
0CA2:  ADDWF  xCA,W
0CA4:  MOVWF  xDE
0CA6:  MOVLW  00
0CA8:  ADDWFC xCB,W
0CAA:  MOVWF  xDF
0CAC:  MOVF   xC8,W
0CAE:  ADDWF  xDE,W
0CB0:  MOVWF  FE9
0CB2:  MOVF   xC9,W
0CB4:  ADDWFC xDF,W
0CB6:  MOVWF  FEA
0CB8:  MOVFF  FEF,AE0
0CBC:  MOVLW  08
0CBE:  ADDWF  xCA,W
0CC0:  MOVWF  xE1
0CC2:  MOVLW  00
0CC4:  ADDWFC xCB,W
0CC6:  MOVWF  xE2
0CC8:  MOVF   xC8,W
0CCA:  ADDWF  xE1,W
0CCC:  MOVWF  FE9
0CCE:  MOVF   xC9,W
0CD0:  ADDWFC xE2,W
0CD2:  MOVWF  FEA
0CD4:  MOVFF  FEF,AE3
0CD8:  MOVLW  07
0CDA:  ADDWF  xCA,W
0CDC:  MOVWF  xE4
0CDE:  MOVLW  00
0CE0:  ADDWFC xCB,W
0CE2:  MOVWF  xE5
0CE4:  MOVF   xC8,W
0CE6:  ADDWF  xE4,W
0CE8:  MOVWF  FE9
0CEA:  MOVF   xC9,W
0CEC:  ADDWFC xE5,W
0CEE:  MOVWF  FEA
0CF0:  MOVFF  FEF,AE6
0CF4:  CLRF   xE7
0CF6:  MOVFF  AD4,AE8
0CFA:  MOVFF  AD7,AE9
0CFE:  MOVFF  ADA,AEA
0D02:  MOVFF  ADD,AEB
0D06:  MOVFF  AE0,AEC
0D0A:  MOVFF  AE3,AED
0D0E:  MOVFF  AE6,AEE
0D12:  MOVLB  0
0D14:  RCALL  07C0
0D16:  MOVFF  01,ACF
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0D1A:  MOVLB  A
0D1C:  MOVF   xCE,W
0D1E:  SUBLW  45
0D20:  BTFSS  FD8.2
0D22:  BRA    0E82
0D24:  MOVF   xCF,W
0D26:  SUBLW  7C
0D28:  BTFSC  FD8.2
0D2A:  BRA    0E82
0D2C:  MOVF   xCF,W
0D2E:  SUBLW  3E
0D30:  BTFSC  FD8.2
0D32:  BRA    0E82
0D34:  MOVF   xCF,W
0D36:  SUBLW  1F
0D38:  BTFSC  FD8.2
0D3A:  BRA    0E82
....................          { 
....................             j=i; 
0D3C:  MOVFF  ACB,ACD
0D40:  MOVFF  ACA,ACC
....................             CRC=1; 
0D44:  MOVLW  01
0D46:  MOVWF  xD1
....................             temp2=temp; 
0D48:  MOVFF  ACE,AD0
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0D4C:  MOVF   xD0,W
0D4E:  SUBLW  1F
0D50:  BTFSC  FD8.2
0D52:  BRA    0E6C
0D54:  MOVF   xCD,W
0D56:  SUBLW  03
0D58:  BTFSS  FD8.0
0D5A:  BRA    0E6C
0D5C:  BNZ   0D66
0D5E:  MOVF   xCC,W
0D60:  SUBLW  E7
0D62:  BTFSS  FD8.0
0D64:  BRA    0E6C
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0D66:  CLRF   xD2
0D68:  MOVFF  ACD,AD4
0D6C:  MOVFF  ACC,AD3
0D70:  MOVFF  AC9,AD6
0D74:  MOVFF  AC8,AD5
0D78:  MOVLB  0
0D7A:  RCALL  0826
0D7C:  MOVF   01,W
0D7E:  MOVLB  A
0D80:  ANDWF  xD1,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0D82:  MOVLW  06
0D84:  ADDWF  xCC,W
0D86:  MOVWF  xD2
0D88:  MOVLW  00
0D8A:  ADDWFC xCD,W
0D8C:  MOVWF  xD3
0D8E:  MOVF   xC8,W
0D90:  ADDWF  xD2,W
0D92:  MOVWF  FE9
0D94:  MOVF   xC9,W
0D96:  ADDWFC xD3,W
0D98:  MOVWF  FEA
0D9A:  MOVFF  FEF,AD4
0D9E:  MOVLW  05
0DA0:  ADDWF  xCC,W
0DA2:  MOVWF  xD5
0DA4:  MOVLW  00
0DA6:  ADDWFC xCD,W
0DA8:  MOVWF  xD6
0DAA:  MOVF   xC8,W
0DAC:  ADDWF  xD5,W
0DAE:  MOVWF  FE9
0DB0:  MOVF   xC9,W
0DB2:  ADDWFC xD6,W
0DB4:  MOVWF  FEA
0DB6:  MOVFF  FEF,AD7
0DBA:  MOVLW  04
0DBC:  ADDWF  xCC,W
0DBE:  MOVWF  xD8
0DC0:  MOVLW  00
0DC2:  ADDWFC xCD,W
0DC4:  MOVWF  xD9
0DC6:  MOVF   xC8,W
0DC8:  ADDWF  xD8,W
0DCA:  MOVWF  FE9
0DCC:  MOVF   xC9,W
0DCE:  ADDWFC xD9,W
0DD0:  MOVWF  FEA
0DD2:  MOVFF  FEF,ADA
0DD6:  MOVLW  03
0DD8:  ADDWF  xCC,W
0DDA:  MOVWF  xDB
0DDC:  MOVLW  00
0DDE:  ADDWFC xCD,W
0DE0:  MOVWF  xDC
0DE2:  MOVF   xC8,W
0DE4:  ADDWF  xDB,W
0DE6:  MOVWF  FE9
0DE8:  MOVF   xC9,W
0DEA:  ADDWFC xDC,W
0DEC:  MOVWF  FEA
0DEE:  MOVFF  FEF,ADD
0DF2:  MOVLW  02
0DF4:  ADDWF  xCC,W
0DF6:  MOVWF  xDE
0DF8:  MOVLW  00
0DFA:  ADDWFC xCD,W
0DFC:  MOVWF  xDF
0DFE:  MOVF   xC8,W
0E00:  ADDWF  xDE,W
0E02:  MOVWF  FE9
0E04:  MOVF   xC9,W
0E06:  ADDWFC xDF,W
0E08:  MOVWF  FEA
0E0A:  MOVFF  FEF,AE0
0E0E:  MOVLW  01
0E10:  ADDWF  xCC,W
0E12:  MOVWF  xE1
0E14:  MOVLW  00
0E16:  ADDWFC xCD,W
0E18:  MOVWF  xE2
0E1A:  MOVF   xC8,W
0E1C:  ADDWF  xE1,W
0E1E:  MOVWF  FE9
0E20:  MOVF   xC9,W
0E22:  ADDWFC xE2,W
0E24:  MOVWF  FEA
0E26:  MOVFF  FEF,AE3
0E2A:  MOVF   xC8,W
0E2C:  ADDWF  xCC,W
0E2E:  MOVWF  FE9
0E30:  MOVF   xC9,W
0E32:  ADDWFC xCD,W
0E34:  MOVWF  FEA
0E36:  MOVFF  FEF,AE4
0E3A:  CLRF   xE7
0E3C:  MOVFF  AD4,AE8
0E40:  MOVFF  AD7,AE9
0E44:  MOVFF  ADA,AEA
0E48:  MOVFF  ADD,AEB
0E4C:  MOVFF  AE0,AEC
0E50:  MOVFF  AE3,AED
0E54:  MOVFF  AE4,AEE
0E58:  MOVLB  0
0E5A:  RCALL  07C0
0E5C:  MOVFF  01,AD0
....................                j=j+7; 
0E60:  MOVLW  07
0E62:  MOVLB  A
0E64:  ADDWF  xCC,F
0E66:  MOVLW  00
0E68:  ADDWFC xCD,F
....................             } 
0E6A:  BRA    0D4C
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0E6C:  DECFSZ xD1,W
0E6E:  BRA    0E82
....................             { 
....................                dir=0; 
0E70:  MOVLB  9
0E72:  CLRF   x99
....................                return i; 
0E74:  MOVLB  A
0E76:  MOVFF  ACA,01
0E7A:  MOVFF  ACB,02
0E7E:  GOTO   1714
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0E82:  BRA    10F6
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0E84:  MOVLW  04
0E86:  ADDWF  xCA,W
0E88:  MOVWF  xD2
0E8A:  MOVLW  00
0E8C:  ADDWFC xCB,W
0E8E:  MOVWF  xD3
0E90:  MOVF   xC8,W
0E92:  ADDWF  xD2,W
0E94:  MOVWF  FE9
0E96:  MOVF   xC9,W
0E98:  ADDWFC xD3,W
0E9A:  MOVWF  FEA
0E9C:  MOVFF  FEF,AD4
0EA0:  MOVLW  03
0EA2:  ADDWF  xCA,W
0EA4:  MOVWF  xD5
0EA6:  MOVLW  00
0EA8:  ADDWFC xCB,W
0EAA:  MOVWF  xD6
0EAC:  MOVF   xC8,W
0EAE:  ADDWF  xD5,W
0EB0:  MOVWF  FE9
0EB2:  MOVF   xC9,W
0EB4:  ADDWFC xD6,W
0EB6:  MOVWF  FEA
0EB8:  MOVFF  FEF,AD7
0EBC:  MOVLW  02
0EBE:  ADDWF  xCA,W
0EC0:  MOVWF  xD8
0EC2:  MOVLW  00
0EC4:  ADDWFC xCB,W
0EC6:  MOVWF  xD9
0EC8:  MOVF   xC8,W
0ECA:  ADDWF  xD8,W
0ECC:  MOVWF  FE9
0ECE:  MOVF   xC9,W
0ED0:  ADDWFC xD9,W
0ED2:  MOVWF  FEA
0ED4:  MOVFF  FEF,ADA
0ED8:  MOVLW  01
0EDA:  ADDWF  xCA,W
0EDC:  MOVWF  xDB
0EDE:  MOVLW  00
0EE0:  ADDWFC xCB,W
0EE2:  MOVWF  xDC
0EE4:  MOVF   xC8,W
0EE6:  ADDWF  xDB,W
0EE8:  MOVWF  FE9
0EEA:  MOVF   xC9,W
0EEC:  ADDWFC xDC,W
0EEE:  MOVWF  FEA
0EF0:  MOVFF  FEF,ADD
0EF4:  MOVF   xC8,W
0EF6:  ADDWF  xCA,W
0EF8:  MOVWF  FE9
0EFA:  MOVF   xC9,W
0EFC:  ADDWFC xCB,W
0EFE:  MOVWF  FEA
0F00:  MOVFF  FEF,ADE
0F04:  CLRF   xE7
0F06:  CLRF   xE8
0F08:  CLRF   xE9
0F0A:  MOVFF  AD4,AEA
0F0E:  MOVFF  AD7,AEB
0F12:  MOVFF  ADA,AEC
0F16:  MOVFF  ADD,AED
0F1A:  MOVFF  ADE,AEE
0F1E:  MOVLB  0
0F20:  RCALL  07C0
0F22:  MOVFF  01,ACE
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0F26:  MOVLW  09
0F28:  MOVLB  A
0F2A:  ADDWF  xCA,W
0F2C:  MOVWF  xD2
0F2E:  MOVLW  00
0F30:  ADDWFC xCB,W
0F32:  MOVWF  xD3
0F34:  MOVF   xC8,W
0F36:  ADDWF  xD2,W
0F38:  MOVWF  FE9
0F3A:  MOVF   xC9,W
0F3C:  ADDWFC xD3,W
0F3E:  MOVWF  FEA
0F40:  MOVFF  FEF,AD4
0F44:  MOVLW  08
0F46:  ADDWF  xCA,W
0F48:  MOVWF  xD5
0F4A:  MOVLW  00
0F4C:  ADDWFC xCB,W
0F4E:  MOVWF  xD6
0F50:  MOVF   xC8,W
0F52:  ADDWF  xD5,W
0F54:  MOVWF  FE9
0F56:  MOVF   xC9,W
0F58:  ADDWFC xD6,W
0F5A:  MOVWF  FEA
0F5C:  MOVFF  FEF,AD7
0F60:  MOVLW  07
0F62:  ADDWF  xCA,W
0F64:  MOVWF  xD8
0F66:  MOVLW  00
0F68:  ADDWFC xCB,W
0F6A:  MOVWF  xD9
0F6C:  MOVF   xC8,W
0F6E:  ADDWF  xD8,W
0F70:  MOVWF  FE9
0F72:  MOVF   xC9,W
0F74:  ADDWFC xD9,W
0F76:  MOVWF  FEA
0F78:  MOVFF  FEF,ADA
0F7C:  MOVLW  06
0F7E:  ADDWF  xCA,W
0F80:  MOVWF  xDB
0F82:  MOVLW  00
0F84:  ADDWFC xCB,W
0F86:  MOVWF  xDC
0F88:  MOVF   xC8,W
0F8A:  ADDWF  xDB,W
0F8C:  MOVWF  FE9
0F8E:  MOVF   xC9,W
0F90:  ADDWFC xDC,W
0F92:  MOVWF  FEA
0F94:  MOVFF  FEF,ADD
0F98:  MOVLW  05
0F9A:  ADDWF  xCA,W
0F9C:  MOVWF  xDE
0F9E:  MOVLW  00
0FA0:  ADDWFC xCB,W
0FA2:  MOVWF  xDF
0FA4:  MOVF   xC8,W
0FA6:  ADDWF  xDE,W
0FA8:  MOVWF  FE9
0FAA:  MOVF   xC9,W
0FAC:  ADDWFC xDF,W
0FAE:  MOVWF  FEA
0FB0:  MOVFF  FEF,AE0
0FB4:  CLRF   xE7
0FB6:  CLRF   xE8
0FB8:  CLRF   xE9
0FBA:  MOVFF  AD4,AEA
0FBE:  MOVFF  AD7,AEB
0FC2:  MOVFF  ADA,AEC
0FC6:  MOVFF  ADD,AED
0FCA:  MOVFF  AE0,AEE
0FCE:  MOVLB  0
0FD0:  CALL   07C0
0FD4:  MOVFF  01,ACF
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0FD8:  MOVLB  A
0FDA:  MOVF   xCE,W
0FDC:  SUBLW  0B
0FDE:  BTFSS  FD8.2
0FE0:  BRA    10F6
0FE2:  MOVF   xCF,W
0FE4:  SUBLW  1F
0FE6:  BTFSC  FD8.2
0FE8:  BRA    10F6
0FEA:  MOVF   xCF,W
0FEC:  SUBLW  0F
0FEE:  BTFSC  FD8.2
0FF0:  BRA    10F6
....................             { 
....................                j=i; 
0FF2:  MOVFF  ACB,ACD
0FF6:  MOVFF  ACA,ACC
....................                CRC=1; 
0FFA:  MOVLW  01
0FFC:  MOVWF  xD1
....................                temp2=temp; 
0FFE:  MOVFF  ACE,AD0
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
1002:  MOVF   xD0,W
1004:  SUBLW  1F
1006:  BZ    10E2
1008:  MOVF   xCD,W
100A:  SUBLW  01
100C:  BNC   10E2
100E:  BNZ   1016
1010:  MOVF   xCC,W
1012:  SUBLW  F3
1014:  BNC   10E2
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
1016:  CLRF   xD2
1018:  MOVFF  ACD,AD4
101C:  MOVFF  ACC,AD3
1020:  MOVFF  AC9,AD6
1024:  MOVFF  AC8,AD5
1028:  MOVLB  0
102A:  RCALL  09D6
102C:  MOVF   01,W
102E:  MOVLB  A
1030:  ANDWF  xD1,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
1032:  MOVLW  04
1034:  ADDWF  xCC,W
1036:  MOVWF  xD2
1038:  MOVLW  00
103A:  ADDWFC xCD,W
103C:  MOVWF  xD3
103E:  MOVF   xC8,W
1040:  ADDWF  xD2,W
1042:  MOVWF  FE9
1044:  MOVF   xC9,W
1046:  ADDWFC xD3,W
1048:  MOVWF  FEA
104A:  MOVFF  FEF,AD4
104E:  MOVLW  03
1050:  ADDWF  xCC,W
1052:  MOVWF  xD5
1054:  MOVLW  00
1056:  ADDWFC xCD,W
1058:  MOVWF  xD6
105A:  MOVF   xC8,W
105C:  ADDWF  xD5,W
105E:  MOVWF  FE9
1060:  MOVF   xC9,W
1062:  ADDWFC xD6,W
1064:  MOVWF  FEA
1066:  MOVFF  FEF,AD7
106A:  MOVLW  02
106C:  ADDWF  xCC,W
106E:  MOVWF  xD8
1070:  MOVLW  00
1072:  ADDWFC xCD,W
1074:  MOVWF  xD9
1076:  MOVF   xC8,W
1078:  ADDWF  xD8,W
107A:  MOVWF  FE9
107C:  MOVF   xC9,W
107E:  ADDWFC xD9,W
1080:  MOVWF  FEA
1082:  MOVFF  FEF,ADA
1086:  MOVLW  01
1088:  ADDWF  xCC,W
108A:  MOVWF  xDB
108C:  MOVLW  00
108E:  ADDWFC xCD,W
1090:  MOVWF  xDC
1092:  MOVF   xC8,W
1094:  ADDWF  xDB,W
1096:  MOVWF  FE9
1098:  MOVF   xC9,W
109A:  ADDWFC xDC,W
109C:  MOVWF  FEA
109E:  MOVFF  FEF,ADD
10A2:  MOVF   xC8,W
10A4:  ADDWF  xCC,W
10A6:  MOVWF  FE9
10A8:  MOVF   xC9,W
10AA:  ADDWFC xCD,W
10AC:  MOVWF  FEA
10AE:  MOVFF  FEF,ADE
10B2:  CLRF   xE7
10B4:  CLRF   xE8
10B6:  CLRF   xE9
10B8:  MOVFF  AD4,AEA
10BC:  MOVFF  AD7,AEB
10C0:  MOVFF  ADA,AEC
10C4:  MOVFF  ADD,AED
10C8:  MOVFF  ADE,AEE
10CC:  MOVLB  0
10CE:  CALL   07C0
10D2:  MOVFF  01,AD0
....................                   j=j+5; 
10D6:  MOVLW  05
10D8:  MOVLB  A
10DA:  ADDWF  xCC,F
10DC:  MOVLW  00
10DE:  ADDWFC xCD,F
....................                } 
10E0:  BRA    1002
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
10E2:  DECFSZ xD1,W
10E4:  BRA    10F6
....................                { 
....................                   dir=0; 
10E6:  MOVLB  9
10E8:  CLRF   x99
....................                   return i; 
10EA:  MOVLB  A
10EC:  MOVFF  ACA,01
10F0:  MOVFF  ACB,02
10F4:  BRA    1714
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
10F6:  INCF   xCA,F
10F8:  BTFSC  FD8.2
10FA:  INCF   xCB,F
10FC:  BRA    0B24
....................    for(i=end_point;i>end_point/4;i--) 
10FE:  MOVFF  AC7,ACB
1102:  MOVFF  AC6,ACA
1106:  RRCF   xC7,W
1108:  MOVWF  03
110A:  RRCF   xC6,W
110C:  MOVWF  02
110E:  RRCF   03,F
1110:  RRCF   02,F
1112:  MOVLW  3F
1114:  ANDWF  03,F
1116:  MOVFF  02,01
111A:  MOVF   03,W
111C:  SUBWF  xCB,W
111E:  BTFSS  FD8.0
1120:  BRA    170E
1122:  BNZ   112C
1124:  MOVF   xCA,W
1126:  SUBWF  01,W
1128:  BTFSC  FD8.0
112A:  BRA    170E
....................    { 
....................       if(track==0) 
112C:  MOVF   xC5,F
112E:  BTFSS  FD8.2
1130:  BRA    1484
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1132:  MOVLW  06
1134:  SUBWF  xCA,W
1136:  MOVWF  xD2
1138:  MOVLW  00
113A:  SUBWFB xCB,W
113C:  MOVWF  xD3
113E:  MOVF   xC8,W
1140:  ADDWF  xD2,W
1142:  MOVWF  FE9
1144:  MOVF   xC9,W
1146:  ADDWFC xD3,W
1148:  MOVWF  FEA
114A:  MOVFF  FEF,AD4
114E:  MOVLW  05
1150:  SUBWF  xCA,W
1152:  MOVWF  xD5
1154:  MOVLW  00
1156:  SUBWFB xCB,W
1158:  MOVWF  xD6
115A:  MOVF   xC8,W
115C:  ADDWF  xD5,W
115E:  MOVWF  FE9
1160:  MOVF   xC9,W
1162:  ADDWFC xD6,W
1164:  MOVWF  FEA
1166:  MOVFF  FEF,AD7
116A:  MOVLW  04
116C:  SUBWF  xCA,W
116E:  MOVWF  xD8
1170:  MOVLW  00
1172:  SUBWFB xCB,W
1174:  MOVWF  xD9
1176:  MOVF   xC8,W
1178:  ADDWF  xD8,W
117A:  MOVWF  FE9
117C:  MOVF   xC9,W
117E:  ADDWFC xD9,W
1180:  MOVWF  FEA
1182:  MOVFF  FEF,ADA
1186:  MOVLW  03
1188:  SUBWF  xCA,W
118A:  MOVWF  xDB
118C:  MOVLW  00
118E:  SUBWFB xCB,W
1190:  MOVWF  xDC
1192:  MOVF   xC8,W
1194:  ADDWF  xDB,W
1196:  MOVWF  FE9
1198:  MOVF   xC9,W
119A:  ADDWFC xDC,W
119C:  MOVWF  FEA
119E:  MOVFF  FEF,ADD
11A2:  MOVLW  02
11A4:  SUBWF  xCA,W
11A6:  MOVWF  xDE
11A8:  MOVLW  00
11AA:  SUBWFB xCB,W
11AC:  MOVWF  xDF
11AE:  MOVF   xC8,W
11B0:  ADDWF  xDE,W
11B2:  MOVWF  FE9
11B4:  MOVF   xC9,W
11B6:  ADDWFC xDF,W
11B8:  MOVWF  FEA
11BA:  MOVFF  FEF,AE0
11BE:  MOVLW  01
11C0:  SUBWF  xCA,W
11C2:  MOVWF  xE1
11C4:  MOVLW  00
11C6:  SUBWFB xCB,W
11C8:  MOVWF  xE2
11CA:  MOVF   xC8,W
11CC:  ADDWF  xE1,W
11CE:  MOVWF  FE9
11D0:  MOVF   xC9,W
11D2:  ADDWFC xE2,W
11D4:  MOVWF  FEA
11D6:  MOVFF  FEF,AE3
11DA:  MOVF   xC8,W
11DC:  ADDWF  xCA,W
11DE:  MOVWF  FE9
11E0:  MOVF   xC9,W
11E2:  ADDWFC xCB,W
11E4:  MOVWF  FEA
11E6:  MOVFF  FEF,AE4
11EA:  CLRF   xE7
11EC:  MOVFF  AD4,AE8
11F0:  MOVFF  AD7,AE9
11F4:  MOVFF  ADA,AEA
11F8:  MOVFF  ADD,AEB
11FC:  MOVFF  AE0,AEC
1200:  MOVFF  AE3,AED
1204:  MOVFF  AE4,AEE
1208:  MOVLB  0
120A:  CALL   07C0
120E:  MOVFF  01,ACE
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
1212:  MOVLW  0D
1214:  MOVLB  A
1216:  SUBWF  xCA,W
1218:  MOVWF  xD2
121A:  MOVLW  00
121C:  SUBWFB xCB,W
121E:  MOVWF  xD3
1220:  MOVF   xC8,W
1222:  ADDWF  xD2,W
1224:  MOVWF  FE9
1226:  MOVF   xC9,W
1228:  ADDWFC xD3,W
122A:  MOVWF  FEA
122C:  MOVFF  FEF,AD4
1230:  MOVLW  0C
1232:  SUBWF  xCA,W
1234:  MOVWF  xD5
1236:  MOVLW  00
1238:  SUBWFB xCB,W
123A:  MOVWF  xD6
123C:  MOVF   xC8,W
123E:  ADDWF  xD5,W
1240:  MOVWF  FE9
1242:  MOVF   xC9,W
1244:  ADDWFC xD6,W
1246:  MOVWF  FEA
1248:  MOVFF  FEF,AD7
124C:  MOVLW  0B
124E:  SUBWF  xCA,W
1250:  MOVWF  xD8
1252:  MOVLW  00
1254:  SUBWFB xCB,W
1256:  MOVWF  xD9
1258:  MOVF   xC8,W
125A:  ADDWF  xD8,W
125C:  MOVWF  FE9
125E:  MOVF   xC9,W
1260:  ADDWFC xD9,W
1262:  MOVWF  FEA
1264:  MOVFF  FEF,ADA
1268:  MOVLW  0A
126A:  SUBWF  xCA,W
126C:  MOVWF  xDB
126E:  MOVLW  00
1270:  SUBWFB xCB,W
1272:  MOVWF  xDC
1274:  MOVF   xC8,W
1276:  ADDWF  xDB,W
1278:  MOVWF  FE9
127A:  MOVF   xC9,W
127C:  ADDWFC xDC,W
127E:  MOVWF  FEA
1280:  MOVFF  FEF,ADD
1284:  MOVLW  09
1286:  SUBWF  xCA,W
1288:  MOVWF  xDE
128A:  MOVLW  00
128C:  SUBWFB xCB,W
128E:  MOVWF  xDF
1290:  MOVF   xC8,W
1292:  ADDWF  xDE,W
1294:  MOVWF  FE9
1296:  MOVF   xC9,W
1298:  ADDWFC xDF,W
129A:  MOVWF  FEA
129C:  MOVFF  FEF,AE0
12A0:  MOVLW  08
12A2:  SUBWF  xCA,W
12A4:  MOVWF  xE1
12A6:  MOVLW  00
12A8:  SUBWFB xCB,W
12AA:  MOVWF  xE2
12AC:  MOVF   xC8,W
12AE:  ADDWF  xE1,W
12B0:  MOVWF  FE9
12B2:  MOVF   xC9,W
12B4:  ADDWFC xE2,W
12B6:  MOVWF  FEA
12B8:  MOVFF  FEF,AE3
12BC:  MOVLW  07
12BE:  SUBWF  xCA,W
12C0:  MOVWF  xE4
12C2:  MOVLW  00
12C4:  SUBWFB xCB,W
12C6:  MOVWF  xE5
12C8:  MOVF   xC8,W
12CA:  ADDWF  xE4,W
12CC:  MOVWF  FE9
12CE:  MOVF   xC9,W
12D0:  ADDWFC xE5,W
12D2:  MOVWF  FEA
12D4:  MOVFF  FEF,AE6
12D8:  CLRF   xE7
12DA:  MOVFF  AD4,AE8
12DE:  MOVFF  AD7,AE9
12E2:  MOVFF  ADA,AEA
12E6:  MOVFF  ADD,AEB
12EA:  MOVFF  AE0,AEC
12EE:  MOVFF  AE3,AED
12F2:  MOVFF  AE6,AEE
12F6:  MOVLB  0
12F8:  CALL   07C0
12FC:  MOVFF  01,ACF
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
1300:  MOVLB  A
1302:  MOVF   xCE,W
1304:  SUBLW  45
1306:  BTFSS  FD8.2
1308:  BRA    1482
130A:  MOVF   xCF,W
130C:  SUBLW  7C
130E:  BTFSC  FD8.2
1310:  BRA    1482
1312:  MOVF   xCF,W
1314:  SUBLW  3E
1316:  BTFSC  FD8.2
1318:  BRA    1482
131A:  MOVF   xCF,W
131C:  SUBLW  1F
131E:  BTFSC  FD8.2
1320:  BRA    1482
1322:  MOVF   xCF,W
1324:  SUBLW  0F
1326:  BTFSC  FD8.2
1328:  BRA    1482
132A:  MOVF   xCF,W
132C:  SUBLW  78
132E:  BTFSC  FD8.2
1330:  BRA    1482
....................          { 
....................             j=i; 
1332:  MOVFF  ACB,ACD
1336:  MOVFF  ACA,ACC
....................             CRC=1; 
133A:  MOVLW  01
133C:  MOVWF  xD1
....................             temp2=temp; 
133E:  MOVFF  ACE,AD0
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
1342:  MOVF   xD0,W
1344:  SUBLW  1F
1346:  BTFSC  FD8.2
1348:  BRA    1462
134A:  MOVF   xCD,F
134C:  BNZ   1356
134E:  MOVF   xCC,W
1350:  SUBLW  01
1352:  BTFSC  FD8.0
1354:  BRA    1462
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1356:  MOVLW  01
1358:  MOVWF  xD2
135A:  MOVFF  ACD,AD4
135E:  MOVFF  ACC,AD3
1362:  MOVFF  AC9,AD6
1366:  MOVFF  AC8,AD5
136A:  MOVLB  0
136C:  CALL   0826
1370:  MOVF   01,W
1372:  MOVLB  A
1374:  ANDWF  xD1,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1376:  MOVLW  06
1378:  SUBWF  xCC,W
137A:  MOVWF  xD2
137C:  MOVLW  00
137E:  SUBWFB xCD,W
1380:  MOVWF  xD3
1382:  MOVF   xC8,W
1384:  ADDWF  xD2,W
1386:  MOVWF  FE9
1388:  MOVF   xC9,W
138A:  ADDWFC xD3,W
138C:  MOVWF  FEA
138E:  MOVFF  FEF,AD4
1392:  MOVLW  05
1394:  SUBWF  xCC,W
1396:  MOVWF  xD5
1398:  MOVLW  00
139A:  SUBWFB xCD,W
139C:  MOVWF  xD6
139E:  MOVF   xC8,W
13A0:  ADDWF  xD5,W
13A2:  MOVWF  FE9
13A4:  MOVF   xC9,W
13A6:  ADDWFC xD6,W
13A8:  MOVWF  FEA
13AA:  MOVFF  FEF,AD7
13AE:  MOVLW  04
13B0:  SUBWF  xCC,W
13B2:  MOVWF  xD8
13B4:  MOVLW  00
13B6:  SUBWFB xCD,W
13B8:  MOVWF  xD9
13BA:  MOVF   xC8,W
13BC:  ADDWF  xD8,W
13BE:  MOVWF  FE9
13C0:  MOVF   xC9,W
13C2:  ADDWFC xD9,W
13C4:  MOVWF  FEA
13C6:  MOVFF  FEF,ADA
13CA:  MOVLW  03
13CC:  SUBWF  xCC,W
13CE:  MOVWF  xDB
13D0:  MOVLW  00
13D2:  SUBWFB xCD,W
13D4:  MOVWF  xDC
13D6:  MOVF   xC8,W
13D8:  ADDWF  xDB,W
13DA:  MOVWF  FE9
13DC:  MOVF   xC9,W
13DE:  ADDWFC xDC,W
13E0:  MOVWF  FEA
13E2:  MOVFF  FEF,ADD
13E6:  MOVLW  02
13E8:  SUBWF  xCC,W
13EA:  MOVWF  xDE
13EC:  MOVLW  00
13EE:  SUBWFB xCD,W
13F0:  MOVWF  xDF
13F2:  MOVF   xC8,W
13F4:  ADDWF  xDE,W
13F6:  MOVWF  FE9
13F8:  MOVF   xC9,W
13FA:  ADDWFC xDF,W
13FC:  MOVWF  FEA
13FE:  MOVFF  FEF,AE0
1402:  MOVLW  01
1404:  SUBWF  xCC,W
1406:  MOVWF  xE1
1408:  MOVLW  00
140A:  SUBWFB xCD,W
140C:  MOVWF  xE2
140E:  MOVF   xC8,W
1410:  ADDWF  xE1,W
1412:  MOVWF  FE9
1414:  MOVF   xC9,W
1416:  ADDWFC xE2,W
1418:  MOVWF  FEA
141A:  MOVFF  FEF,AE3
141E:  MOVF   xC8,W
1420:  ADDWF  xCC,W
1422:  MOVWF  FE9
1424:  MOVF   xC9,W
1426:  ADDWFC xCD,W
1428:  MOVWF  FEA
142A:  MOVFF  FEF,AE4
142E:  CLRF   xE7
1430:  MOVFF  AD4,AE8
1434:  MOVFF  AD7,AE9
1438:  MOVFF  ADA,AEA
143C:  MOVFF  ADD,AEB
1440:  MOVFF  AE0,AEC
1444:  MOVFF  AE3,AED
1448:  MOVFF  AE4,AEE
144C:  MOVLB  0
144E:  CALL   07C0
1452:  MOVFF  01,AD0
....................                j=j-7;             
1456:  MOVLW  07
1458:  MOVLB  A
145A:  SUBWF  xCC,F
145C:  MOVLW  00
145E:  SUBWFB xCD,F
....................              } 
1460:  BRA    1342
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
1462:  DECFSZ xD1,W
1464:  BRA    147A
....................             { 
....................                dir=1; 
1466:  MOVLW  01
1468:  MOVLB  9
146A:  MOVWF  x99
....................                return i; 
146C:  MOVLB  A
146E:  MOVFF  ACA,01
1472:  MOVFF  ACB,02
1476:  BRA    1714
....................             } 
....................             else return 0; 
1478:  BRA    1482
147A:  MOVLW  00
147C:  MOVWF  01
147E:  MOVWF  02
1480:  BRA    1714
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
1482:  BRA    1704
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1484:  MOVLW  04
1486:  SUBWF  xCA,W
1488:  MOVWF  xD2
148A:  MOVLW  00
148C:  SUBWFB xCB,W
148E:  MOVWF  xD3
1490:  MOVF   xC8,W
1492:  ADDWF  xD2,W
1494:  MOVWF  FE9
1496:  MOVF   xC9,W
1498:  ADDWFC xD3,W
149A:  MOVWF  FEA
149C:  MOVFF  FEF,AD4
14A0:  MOVLW  03
14A2:  SUBWF  xCA,W
14A4:  MOVWF  xD5
14A6:  MOVLW  00
14A8:  SUBWFB xCB,W
14AA:  MOVWF  xD6
14AC:  MOVF   xC8,W
14AE:  ADDWF  xD5,W
14B0:  MOVWF  FE9
14B2:  MOVF   xC9,W
14B4:  ADDWFC xD6,W
14B6:  MOVWF  FEA
14B8:  MOVFF  FEF,AD7
14BC:  MOVLW  02
14BE:  SUBWF  xCA,W
14C0:  MOVWF  xD8
14C2:  MOVLW  00
14C4:  SUBWFB xCB,W
14C6:  MOVWF  xD9
14C8:  MOVF   xC8,W
14CA:  ADDWF  xD8,W
14CC:  MOVWF  FE9
14CE:  MOVF   xC9,W
14D0:  ADDWFC xD9,W
14D2:  MOVWF  FEA
14D4:  MOVFF  FEF,ADA
14D8:  MOVLW  01
14DA:  SUBWF  xCA,W
14DC:  MOVWF  xDB
14DE:  MOVLW  00
14E0:  SUBWFB xCB,W
14E2:  MOVWF  xDC
14E4:  MOVF   xC8,W
14E6:  ADDWF  xDB,W
14E8:  MOVWF  FE9
14EA:  MOVF   xC9,W
14EC:  ADDWFC xDC,W
14EE:  MOVWF  FEA
14F0:  MOVFF  FEF,ADD
14F4:  MOVF   xC8,W
14F6:  ADDWF  xCA,W
14F8:  MOVWF  FE9
14FA:  MOVF   xC9,W
14FC:  ADDWFC xCB,W
14FE:  MOVWF  FEA
1500:  MOVFF  FEF,ADE
1504:  CLRF   xE7
1506:  CLRF   xE8
1508:  CLRF   xE9
150A:  MOVFF  AD4,AEA
150E:  MOVFF  AD7,AEB
1512:  MOVFF  ADA,AEC
1516:  MOVFF  ADD,AED
151A:  MOVFF  ADE,AEE
151E:  MOVLB  0
1520:  CALL   07C0
1524:  MOVFF  01,ACE
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1528:  MOVLW  09
152A:  MOVLB  A
152C:  SUBWF  xCA,W
152E:  MOVWF  xD2
1530:  MOVLW  00
1532:  SUBWFB xCB,W
1534:  MOVWF  xD3
1536:  MOVF   xC8,W
1538:  ADDWF  xD2,W
153A:  MOVWF  FE9
153C:  MOVF   xC9,W
153E:  ADDWFC xD3,W
1540:  MOVWF  FEA
1542:  MOVFF  FEF,AD4
1546:  MOVLW  08
1548:  SUBWF  xCA,W
154A:  MOVWF  xD5
154C:  MOVLW  00
154E:  SUBWFB xCB,W
1550:  MOVWF  xD6
1552:  MOVF   xC8,W
1554:  ADDWF  xD5,W
1556:  MOVWF  FE9
1558:  MOVF   xC9,W
155A:  ADDWFC xD6,W
155C:  MOVWF  FEA
155E:  MOVFF  FEF,AD7
1562:  MOVLW  07
1564:  SUBWF  xCA,W
1566:  MOVWF  xD8
1568:  MOVLW  00
156A:  SUBWFB xCB,W
156C:  MOVWF  xD9
156E:  MOVF   xC8,W
1570:  ADDWF  xD8,W
1572:  MOVWF  FE9
1574:  MOVF   xC9,W
1576:  ADDWFC xD9,W
1578:  MOVWF  FEA
157A:  MOVFF  FEF,ADA
157E:  MOVLW  06
1580:  SUBWF  xCA,W
1582:  MOVWF  xDB
1584:  MOVLW  00
1586:  SUBWFB xCB,W
1588:  MOVWF  xDC
158A:  MOVF   xC8,W
158C:  ADDWF  xDB,W
158E:  MOVWF  FE9
1590:  MOVF   xC9,W
1592:  ADDWFC xDC,W
1594:  MOVWF  FEA
1596:  MOVFF  FEF,ADD
159A:  MOVLW  05
159C:  SUBWF  xCA,W
159E:  MOVWF  xDE
15A0:  MOVLW  00
15A2:  SUBWFB xCB,W
15A4:  MOVWF  xDF
15A6:  MOVF   xC8,W
15A8:  ADDWF  xDE,W
15AA:  MOVWF  FE9
15AC:  MOVF   xC9,W
15AE:  ADDWFC xDF,W
15B0:  MOVWF  FEA
15B2:  MOVFF  FEF,AE0
15B6:  CLRF   xE7
15B8:  CLRF   xE8
15BA:  CLRF   xE9
15BC:  MOVFF  AD4,AEA
15C0:  MOVFF  AD7,AEB
15C4:  MOVFF  ADA,AEC
15C8:  MOVFF  ADD,AED
15CC:  MOVFF  AE0,AEE
15D0:  MOVLB  0
15D2:  CALL   07C0
15D6:  MOVFF  01,ACF
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
15DA:  MOVLB  A
15DC:  MOVF   xCE,W
15DE:  SUBLW  0B
15E0:  BTFSS  FD8.2
15E2:  BRA    1704
15E4:  MOVF   xCF,W
15E6:  SUBLW  1F
15E8:  BTFSC  FD8.2
15EA:  BRA    1704
15EC:  MOVF   xCF,W
15EE:  SUBLW  0F
15F0:  BTFSC  FD8.2
15F2:  BRA    1704
....................             { 
....................                j=i; 
15F4:  MOVFF  ACB,ACD
15F8:  MOVFF  ACA,ACC
....................                CRC=1; 
15FC:  MOVLW  01
15FE:  MOVWF  xD1
....................                temp2=temp; 
1600:  MOVFF  ACE,AD0
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
1604:  MOVF   xD0,W
1606:  SUBLW  1F
1608:  BZ    16E4
160A:  MOVF   xCD,F
160C:  BNZ   1614
160E:  MOVF   xCC,W
1610:  SUBLW  01
1612:  BC    16E4
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1614:  MOVLW  01
1616:  MOVWF  xD2
1618:  MOVFF  ACD,AD4
161C:  MOVFF  ACC,AD3
1620:  MOVFF  AC9,AD6
1624:  MOVFF  AC8,AD5
1628:  MOVLB  0
162A:  CALL   09D6
162E:  MOVF   01,W
1630:  MOVLB  A
1632:  ANDWF  xD1,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1634:  MOVLW  04
1636:  SUBWF  xCC,W
1638:  MOVWF  xD2
163A:  MOVLW  00
163C:  SUBWFB xCD,W
163E:  MOVWF  xD3
1640:  MOVF   xC8,W
1642:  ADDWF  xD2,W
1644:  MOVWF  FE9
1646:  MOVF   xC9,W
1648:  ADDWFC xD3,W
164A:  MOVWF  FEA
164C:  MOVFF  FEF,AD4
1650:  MOVLW  03
1652:  SUBWF  xCC,W
1654:  MOVWF  xD5
1656:  MOVLW  00
1658:  SUBWFB xCD,W
165A:  MOVWF  xD6
165C:  MOVF   xC8,W
165E:  ADDWF  xD5,W
1660:  MOVWF  FE9
1662:  MOVF   xC9,W
1664:  ADDWFC xD6,W
1666:  MOVWF  FEA
1668:  MOVFF  FEF,AD7
166C:  MOVLW  02
166E:  SUBWF  xCC,W
1670:  MOVWF  xD8
1672:  MOVLW  00
1674:  SUBWFB xCD,W
1676:  MOVWF  xD9
1678:  MOVF   xC8,W
167A:  ADDWF  xD8,W
167C:  MOVWF  FE9
167E:  MOVF   xC9,W
1680:  ADDWFC xD9,W
1682:  MOVWF  FEA
1684:  MOVFF  FEF,ADA
1688:  MOVLW  01
168A:  SUBWF  xCC,W
168C:  MOVWF  xDB
168E:  MOVLW  00
1690:  SUBWFB xCD,W
1692:  MOVWF  xDC
1694:  MOVF   xC8,W
1696:  ADDWF  xDB,W
1698:  MOVWF  FE9
169A:  MOVF   xC9,W
169C:  ADDWFC xDC,W
169E:  MOVWF  FEA
16A0:  MOVFF  FEF,ADD
16A4:  MOVF   xC8,W
16A6:  ADDWF  xCC,W
16A8:  MOVWF  FE9
16AA:  MOVF   xC9,W
16AC:  ADDWFC xCD,W
16AE:  MOVWF  FEA
16B0:  MOVFF  FEF,ADE
16B4:  CLRF   xE7
16B6:  CLRF   xE8
16B8:  CLRF   xE9
16BA:  MOVFF  AD4,AEA
16BE:  MOVFF  AD7,AEB
16C2:  MOVFF  ADA,AEC
16C6:  MOVFF  ADD,AED
16CA:  MOVFF  ADE,AEE
16CE:  MOVLB  0
16D0:  CALL   07C0
16D4:  MOVFF  01,AD0
....................                   j=j-5; 
16D8:  MOVLW  05
16DA:  MOVLB  A
16DC:  SUBWF  xCC,F
16DE:  MOVLW  00
16E0:  SUBWFB xCD,F
....................                } 
16E2:  BRA    1604
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
16E4:  DECFSZ xD1,W
16E6:  BRA    16FC
....................                { 
....................                   dir=1; 
16E8:  MOVLW  01
16EA:  MOVLB  9
16EC:  MOVWF  x99
....................                   return i; 
16EE:  MOVLB  A
16F0:  MOVFF  ACA,01
16F4:  MOVFF  ACB,02
16F8:  BRA    1714
....................                } 
....................                   else return 0; 
16FA:  BRA    1704
16FC:  MOVLW  00
16FE:  MOVWF  01
1700:  MOVWF  02
1702:  BRA    1714
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
1704:  MOVF   xCA,W
1706:  BTFSC  FD8.2
1708:  DECF   xCB,F
170A:  DECF   xCA,F
170C:  BRA    1106
....................    return 0; 
170E:  MOVLW  00
1710:  MOVWF  01
1712:  MOVWF  02
.................... } 
1714:  MOVLB  0
1716:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
3A90:  MOVLB  A
3A92:  CLRF   xC4
3A94:  MOVLW  01
3A96:  MOVWF  xC3
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3A98:  MOVFF  AB9,AC5
3A9C:  MOVFF  ABB,AC7
3AA0:  MOVFF  ABA,AC6
3AA4:  MOVFF  ABD,AC9
3AA8:  MOVFF  ABC,AC8
3AAC:  MOVLB  0
3AAE:  CALL   0B16
3AB2:  MOVFF  02,AC4
3AB6:  MOVFF  01,AC3
....................    if(temp==0) return 0; 
3ABA:  MOVLB  A
3ABC:  MOVF   xC3,F
3ABE:  BNZ   3ACA
3AC0:  MOVF   xC4,F
3AC2:  BNZ   3ACA
3AC4:  MOVLW  00
3AC6:  MOVWF  01
3AC8:  BRA    3E74
....................    j=temp; 
3ACA:  MOVFF  AC4,AC2
3ACE:  MOVFF  AC3,AC1
....................    if(dir==0) 
3AD2:  MOVLB  9
3AD4:  MOVF   x99,F
3AD6:  BTFSS  FD8.2
3AD8:  BRA    3C94
....................    { 
....................       if(track==0) 
3ADA:  MOVLB  A
3ADC:  MOVF   xB9,F
3ADE:  BTFSS  FD8.2
3AE0:  BRA    3BD8
....................       { 
....................             for(i=0;i<79;i++) 
3AE2:  CLRF   xC0
3AE4:  MOVF   xC0,W
3AE6:  SUBLW  4E
3AE8:  BNC   3BD6
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3AEA:  CLRF   03
3AEC:  MOVF   xC0,W
3AEE:  ADDWF  xBE,W
3AF0:  MOVWF  01
3AF2:  MOVF   xBF,W
3AF4:  ADDWFC 03,F
3AF6:  MOVFF  01,AC5
3AFA:  MOVFF  03,AC6
3AFE:  MOVLW  05
3B00:  ADDWF  xC1,W
3B02:  MOVWF  xC7
3B04:  MOVLW  00
3B06:  ADDWFC xC2,W
3B08:  MOVWF  xC8
3B0A:  MOVF   xBC,W
3B0C:  ADDWF  xC7,W
3B0E:  MOVWF  FE9
3B10:  MOVF   xBD,W
3B12:  ADDWFC xC8,W
3B14:  MOVWF  FEA
3B16:  MOVFF  FEF,AC9
3B1A:  MOVLW  04
3B1C:  ADDWF  xC1,W
3B1E:  MOVWF  xCA
3B20:  MOVLW  00
3B22:  ADDWFC xC2,W
3B24:  MOVWF  xCB
3B26:  MOVF   xBC,W
3B28:  ADDWF  xCA,W
3B2A:  MOVWF  FE9
3B2C:  MOVF   xBD,W
3B2E:  ADDWFC xCB,W
3B30:  MOVWF  FEA
3B32:  MOVFF  FEF,ACC
3B36:  MOVLW  03
3B38:  ADDWF  xC1,W
3B3A:  MOVWF  xCD
3B3C:  MOVLW  00
3B3E:  ADDWFC xC2,W
3B40:  MOVWF  xCE
3B42:  MOVF   xBC,W
3B44:  ADDWF  xCD,W
3B46:  MOVWF  FE9
3B48:  MOVF   xBD,W
3B4A:  ADDWFC xCE,W
3B4C:  MOVWF  FEA
3B4E:  MOVFF  FEF,ACF
3B52:  MOVLW  02
3B54:  ADDWF  xC1,W
3B56:  MOVWF  xD0
3B58:  MOVLW  00
3B5A:  ADDWFC xC2,W
3B5C:  MOVWF  xD1
3B5E:  MOVF   xBC,W
3B60:  ADDWF  xD0,W
3B62:  MOVWF  FE9
3B64:  MOVF   xBD,W
3B66:  ADDWFC xD1,W
3B68:  MOVWF  FEA
3B6A:  MOVFF  FEF,AD2
3B6E:  MOVLW  01
3B70:  ADDWF  xC1,W
3B72:  MOVWF  xD3
3B74:  MOVLW  00
3B76:  ADDWFC xC2,W
3B78:  MOVWF  xD4
3B7A:  MOVF   xBC,W
3B7C:  ADDWF  xD3,W
3B7E:  MOVWF  FE9
3B80:  MOVF   xBD,W
3B82:  ADDWFC xD4,W
3B84:  MOVWF  FEA
3B86:  MOVFF  FEF,AD5
3B8A:  MOVF   xBC,W
3B8C:  ADDWF  xC1,W
3B8E:  MOVWF  FE9
3B90:  MOVF   xBD,W
3B92:  ADDWFC xC2,W
3B94:  MOVWF  FEA
3B96:  MOVFF  FEF,AD6
3B9A:  CLRF   xE7
3B9C:  CLRF   xE8
3B9E:  MOVFF  AC9,AE9
3BA2:  MOVFF  ACC,AEA
3BA6:  MOVFF  ACF,AEB
3BAA:  MOVFF  AD2,AEC
3BAE:  MOVFF  AD5,AED
3BB2:  MOVFF  AD6,AEE
3BB6:  MOVLB  0
3BB8:  CALL   07C0
3BBC:  MOVFF  AC6,FEA
3BC0:  MOVFF  AC5,FE9
3BC4:  MOVFF  01,FEF
....................                j=j+7; 
3BC8:  MOVLW  07
3BCA:  MOVLB  A
3BCC:  ADDWF  xC1,F
3BCE:  MOVLW  00
3BD0:  ADDWFC xC2,F
....................             } 
3BD2:  INCF   xC0,F
3BD4:  BRA    3AE4
....................       } 
....................          else  
3BD6:  BRA    3C90
....................          { 
....................             for(i=0;i<40;i++) 
3BD8:  CLRF   xC0
3BDA:  MOVF   xC0,W
3BDC:  SUBLW  27
3BDE:  BNC   3C90
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3BE0:  CLRF   03
3BE2:  MOVF   xC0,W
3BE4:  ADDWF  xBE,W
3BE6:  MOVWF  01
3BE8:  MOVF   xBF,W
3BEA:  ADDWFC 03,F
3BEC:  MOVFF  01,AC5
3BF0:  MOVFF  03,AC6
3BF4:  MOVLW  03
3BF6:  ADDWF  xC1,W
3BF8:  MOVWF  xC7
3BFA:  MOVLW  00
3BFC:  ADDWFC xC2,W
3BFE:  MOVWF  xC8
3C00:  MOVF   xBC,W
3C02:  ADDWF  xC7,W
3C04:  MOVWF  FE9
3C06:  MOVF   xBD,W
3C08:  ADDWFC xC8,W
3C0A:  MOVWF  FEA
3C0C:  MOVFF  FEF,AC9
3C10:  MOVLW  02
3C12:  ADDWF  xC1,W
3C14:  MOVWF  xCA
3C16:  MOVLW  00
3C18:  ADDWFC xC2,W
3C1A:  MOVWF  xCB
3C1C:  MOVF   xBC,W
3C1E:  ADDWF  xCA,W
3C20:  MOVWF  FE9
3C22:  MOVF   xBD,W
3C24:  ADDWFC xCB,W
3C26:  MOVWF  FEA
3C28:  MOVFF  FEF,ACC
3C2C:  MOVLW  01
3C2E:  ADDWF  xC1,W
3C30:  MOVWF  xCD
3C32:  MOVLW  00
3C34:  ADDWFC xC2,W
3C36:  MOVWF  xCE
3C38:  MOVF   xBC,W
3C3A:  ADDWF  xCD,W
3C3C:  MOVWF  FE9
3C3E:  MOVF   xBD,W
3C40:  ADDWFC xCE,W
3C42:  MOVWF  FEA
3C44:  MOVFF  FEF,ACF
3C48:  MOVF   xBC,W
3C4A:  ADDWF  xC1,W
3C4C:  MOVWF  FE9
3C4E:  MOVF   xBD,W
3C50:  ADDWFC xC2,W
3C52:  MOVWF  FEA
3C54:  MOVFF  FEF,AD0
3C58:  CLRF   xE7
3C5A:  CLRF   xE8
3C5C:  CLRF   xE9
3C5E:  CLRF   xEA
3C60:  MOVFF  AC9,AEB
3C64:  MOVFF  ACC,AEC
3C68:  MOVFF  ACF,AED
3C6C:  MOVFF  AD0,AEE
3C70:  MOVLB  0
3C72:  CALL   07C0
3C76:  MOVFF  AC6,FEA
3C7A:  MOVFF  AC5,FE9
3C7E:  MOVFF  01,FEF
....................                j=j+5; 
3C82:  MOVLW  05
3C84:  MOVLB  A
3C86:  ADDWF  xC1,F
3C88:  MOVLW  00
3C8A:  ADDWFC xC2,F
....................             }          
3C8C:  INCF   xC0,F
3C8E:  BRA    3BDA
....................          } 
....................    } 
....................       else  
3C90:  BRA    3E4A
3C92:  MOVLB  9
....................       { 
....................          if(track==0) 
3C94:  MOVLB  A
3C96:  MOVF   xB9,F
3C98:  BTFSS  FD8.2
3C9A:  BRA    3D92
....................          { 
....................             for(i=0;i<79;i++) 
3C9C:  CLRF   xC0
3C9E:  MOVF   xC0,W
3CA0:  SUBLW  4E
3CA2:  BNC   3D90
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3CA4:  CLRF   03
3CA6:  MOVF   xC0,W
3CA8:  ADDWF  xBE,W
3CAA:  MOVWF  01
3CAC:  MOVF   xBF,W
3CAE:  ADDWFC 03,F
3CB0:  MOVFF  01,AC5
3CB4:  MOVFF  03,AC6
3CB8:  MOVLW  05
3CBA:  SUBWF  xC1,W
3CBC:  MOVWF  xC7
3CBE:  MOVLW  00
3CC0:  SUBWFB xC2,W
3CC2:  MOVWF  xC8
3CC4:  MOVF   xBC,W
3CC6:  ADDWF  xC7,W
3CC8:  MOVWF  FE9
3CCA:  MOVF   xBD,W
3CCC:  ADDWFC xC8,W
3CCE:  MOVWF  FEA
3CD0:  MOVFF  FEF,AC9
3CD4:  MOVLW  04
3CD6:  SUBWF  xC1,W
3CD8:  MOVWF  xCA
3CDA:  MOVLW  00
3CDC:  SUBWFB xC2,W
3CDE:  MOVWF  xCB
3CE0:  MOVF   xBC,W
3CE2:  ADDWF  xCA,W
3CE4:  MOVWF  FE9
3CE6:  MOVF   xBD,W
3CE8:  ADDWFC xCB,W
3CEA:  MOVWF  FEA
3CEC:  MOVFF  FEF,ACC
3CF0:  MOVLW  03
3CF2:  SUBWF  xC1,W
3CF4:  MOVWF  xCD
3CF6:  MOVLW  00
3CF8:  SUBWFB xC2,W
3CFA:  MOVWF  xCE
3CFC:  MOVF   xBC,W
3CFE:  ADDWF  xCD,W
3D00:  MOVWF  FE9
3D02:  MOVF   xBD,W
3D04:  ADDWFC xCE,W
3D06:  MOVWF  FEA
3D08:  MOVFF  FEF,ACF
3D0C:  MOVLW  02
3D0E:  SUBWF  xC1,W
3D10:  MOVWF  xD0
3D12:  MOVLW  00
3D14:  SUBWFB xC2,W
3D16:  MOVWF  xD1
3D18:  MOVF   xBC,W
3D1A:  ADDWF  xD0,W
3D1C:  MOVWF  FE9
3D1E:  MOVF   xBD,W
3D20:  ADDWFC xD1,W
3D22:  MOVWF  FEA
3D24:  MOVFF  FEF,AD2
3D28:  MOVLW  01
3D2A:  SUBWF  xC1,W
3D2C:  MOVWF  xD3
3D2E:  MOVLW  00
3D30:  SUBWFB xC2,W
3D32:  MOVWF  xD4
3D34:  MOVF   xBC,W
3D36:  ADDWF  xD3,W
3D38:  MOVWF  FE9
3D3A:  MOVF   xBD,W
3D3C:  ADDWFC xD4,W
3D3E:  MOVWF  FEA
3D40:  MOVFF  FEF,AD5
3D44:  MOVF   xBC,W
3D46:  ADDWF  xC1,W
3D48:  MOVWF  FE9
3D4A:  MOVF   xBD,W
3D4C:  ADDWFC xC2,W
3D4E:  MOVWF  FEA
3D50:  MOVFF  FEF,AD6
3D54:  CLRF   xE7
3D56:  CLRF   xE8
3D58:  MOVFF  AC9,AE9
3D5C:  MOVFF  ACC,AEA
3D60:  MOVFF  ACF,AEB
3D64:  MOVFF  AD2,AEC
3D68:  MOVFF  AD5,AED
3D6C:  MOVFF  AD6,AEE
3D70:  MOVLB  0
3D72:  CALL   07C0
3D76:  MOVFF  AC6,FEA
3D7A:  MOVFF  AC5,FE9
3D7E:  MOVFF  01,FEF
....................                j=j-7; 
3D82:  MOVLW  07
3D84:  MOVLB  A
3D86:  SUBWF  xC1,F
3D88:  MOVLW  00
3D8A:  SUBWFB xC2,F
....................             } 
3D8C:  INCF   xC0,F
3D8E:  BRA    3C9E
....................          } 
....................             else 
3D90:  BRA    3E4A
....................             { 
....................                for(i=0;i<40;i++) 
3D92:  CLRF   xC0
3D94:  MOVF   xC0,W
3D96:  SUBLW  27
3D98:  BNC   3E4A
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3D9A:  CLRF   03
3D9C:  MOVF   xC0,W
3D9E:  ADDWF  xBE,W
3DA0:  MOVWF  01
3DA2:  MOVF   xBF,W
3DA4:  ADDWFC 03,F
3DA6:  MOVFF  01,AC5
3DAA:  MOVFF  03,AC6
3DAE:  MOVLW  03
3DB0:  SUBWF  xC1,W
3DB2:  MOVWF  xC7
3DB4:  MOVLW  00
3DB6:  SUBWFB xC2,W
3DB8:  MOVWF  xC8
3DBA:  MOVF   xBC,W
3DBC:  ADDWF  xC7,W
3DBE:  MOVWF  FE9
3DC0:  MOVF   xBD,W
3DC2:  ADDWFC xC8,W
3DC4:  MOVWF  FEA
3DC6:  MOVFF  FEF,AC9
3DCA:  MOVLW  02
3DCC:  SUBWF  xC1,W
3DCE:  MOVWF  xCA
3DD0:  MOVLW  00
3DD2:  SUBWFB xC2,W
3DD4:  MOVWF  xCB
3DD6:  MOVF   xBC,W
3DD8:  ADDWF  xCA,W
3DDA:  MOVWF  FE9
3DDC:  MOVF   xBD,W
3DDE:  ADDWFC xCB,W
3DE0:  MOVWF  FEA
3DE2:  MOVFF  FEF,ACC
3DE6:  MOVLW  01
3DE8:  SUBWF  xC1,W
3DEA:  MOVWF  xCD
3DEC:  MOVLW  00
3DEE:  SUBWFB xC2,W
3DF0:  MOVWF  xCE
3DF2:  MOVF   xBC,W
3DF4:  ADDWF  xCD,W
3DF6:  MOVWF  FE9
3DF8:  MOVF   xBD,W
3DFA:  ADDWFC xCE,W
3DFC:  MOVWF  FEA
3DFE:  MOVFF  FEF,ACF
3E02:  MOVF   xBC,W
3E04:  ADDWF  xC1,W
3E06:  MOVWF  FE9
3E08:  MOVF   xBD,W
3E0A:  ADDWFC xC2,W
3E0C:  MOVWF  FEA
3E0E:  MOVFF  FEF,AD0
3E12:  CLRF   xE7
3E14:  CLRF   xE8
3E16:  CLRF   xE9
3E18:  CLRF   xEA
3E1A:  MOVFF  AC9,AEB
3E1E:  MOVFF  ACC,AEC
3E22:  MOVFF  ACF,AED
3E26:  MOVFF  AD0,AEE
3E2A:  MOVLB  0
3E2C:  CALL   07C0
3E30:  MOVFF  AC6,FEA
3E34:  MOVFF  AC5,FE9
3E38:  MOVFF  01,FEF
....................                   j=j-5; 
3E3C:  MOVLW  05
3E3E:  MOVLB  A
3E40:  SUBWF  xC1,F
3E42:  MOVLW  00
3E44:  SUBWFB xC2,F
....................                }             
3E46:  INCF   xC0,F
3E48:  BRA    3D94
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3E4A:  MOVF   xB9,F
3E4C:  BNZ   3E62
3E4E:  MOVLW  52
3E50:  MOVWF  xC5
3E52:  MOVFF  ABD,AC7
3E56:  MOVFF  ABC,AC6
3E5A:  MOVLB  0
3E5C:  RCALL  3A6E
....................          else del_buf(numbyteofbuffer2,datin); 
3E5E:  BRA    3E72
3E60:  MOVLB  A
3E62:  MOVLW  2C
3E64:  MOVWF  xC5
3E66:  MOVFF  ABD,AC7
3E6A:  MOVFF  ABC,AC6
3E6E:  MOVLB  0
3E70:  RCALL  3A6E
3E72:  MOVLB  A
.................... } 
3E74:  MOVLB  0
3E76:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
18F0:  MOVLW  72
18F2:  MOVWF  FF6
18F4:  MOVLW  06
18F6:  MOVWF  FF7
18F8:  CALL   07A0
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
18FC:  MOVLB  A
18FE:  CLRF   xBD
1900:  CLRF   xBC
1902:  MOVF   xBD,W
1904:  SUBLW  03
1906:  BNC   1936
1908:  BNZ   1910
190A:  MOVF   xBC,W
190C:  SUBLW  51
190E:  BNC   1936
1910:  MOVLW  17
1912:  ADDWF  xBC,W
1914:  MOVWF  FE9
1916:  MOVLW  05
1918:  ADDWFC xBD,W
191A:  MOVWF  FEA
191C:  MOVFF  FEF,ABE
1920:  MOVFF  ABE,ABF
1924:  MOVLW  18
1926:  MOVWF  xC0
1928:  MOVLB  0
192A:  RCALL  182C
192C:  MOVLB  A
192E:  INCF   xBC,F
1930:  BTFSC  FD8.2
1932:  INCF   xBD,F
1934:  BRA    1902
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1936:  MOVLW  88
1938:  MOVWF  FF6
193A:  MOVLW  06
193C:  MOVWF  FF7
193E:  MOVLB  0
1940:  CALL   07A0
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1944:  MOVLB  A
1946:  CLRF   xBD
1948:  CLRF   xBC
194A:  MOVF   xBD,W
194C:  SUBLW  01
194E:  BNC   197E
1950:  BNZ   1958
1952:  MOVF   xBC,W
1954:  SUBLW  2B
1956:  BNC   197E
1958:  MOVLW  69
195A:  ADDWF  xBC,W
195C:  MOVWF  FE9
195E:  MOVLW  08
1960:  ADDWFC xBD,W
1962:  MOVWF  FEA
1964:  MOVFF  FEF,ABE
1968:  MOVFF  ABE,ABF
196C:  MOVLW  18
196E:  MOVWF  xC0
1970:  MOVLB  0
1972:  RCALL  182C
1974:  MOVLB  A
1976:  INCF   xBC,F
1978:  BTFSC  FD8.2
197A:  INCF   xBD,F
197C:  BRA    194A
.................... } 
197E:  MOVLB  0
1980:  GOTO   1C16 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3FFC:  MOVLW  01
3FFE:  MOVLB  9
4000:  MOVWF  xA9
....................    rtc_get_date(date,mon,year,day); 
....................    rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
*
40AA:  RCALL  39FC
40AC:  MOVFF  02,ABA
40B0:  MOVFF  01,AB9
40B4:  MOVFF  02,ABC
40B8:  MOVFF  01,ABB
40BC:  MOVLB  A
40BE:  CLRF   xBE
40C0:  MOVLW  7C
40C2:  MOVWF  xBD
40C4:  MOVLB  0
40C6:  RCALL  3A4C
40C8:  MOVFF  01,AB9
40CC:  MOVLW  96
40CE:  MOVLB  A
40D0:  ADDWF  01,W
40D2:  MOVWF  01
40D4:  MOVLW  00
40D6:  ADDWFC 02,W
40D8:  MOVFF  01,20
40DC:  MOVWF  21
40DE:  CLRF   22
40E0:  CLRF   23
....................    if(datinbuf==0)  
40E2:  MOVLB  9
40E4:  MOVF   xA6,F
40E6:  BNZ   4108
....................    { 
....................       countbit_T1=0; 
40E8:  CLRF   x9B
40EA:  CLRF   x9A
....................       countbit_T2=0; 
40EC:  CLRF   x9D
40EE:  CLRF   x9C
....................       bug_countbit_T1=0; 
40F0:  CLRF   x9F
40F2:  CLRF   x9E
....................       bug_countbit_T2=0; 
40F4:  CLRF   xA1
40F6:  CLRF   xA0
....................       if(data_avai==0)charac_timeout=0xffffffff; 
40F8:  MOVF   xAA,F
40FA:  BNZ   4104
40FC:  MOVLB  0
40FE:  SETF   xFC
4100:  SETF   xFB
4102:  MOVLB  9
....................       saving_flag=0; 
4104:  CLRF   xA9
....................       return; 
4106:  BRA    4474
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
4108:  MOVLW  9E
410A:  MOVWF  FF6
410C:  MOVLW  06
410E:  MOVWF  FF7
4110:  MOVLB  0
4112:  CALL   07A0
....................    key_timeout=0; 
4116:  MOVLB  1
4118:  CLRF   x09
411A:  CLRF   x08
....................    //key_count=0; 
....................    enable_getpin=1; 
411C:  MOVLW  01
411E:  MOVWF  x0C
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
4120:  MOVFF  99B,AB8
4124:  MOVFF  99A,AB7
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
4128:  MOVLB  A
412A:  CLRF   xB9
412C:  MOVFF  AB8,ABB
4130:  MOVFF  AB7,ABA
4134:  MOVLW  05
4136:  MOVWF  xBD
4138:  MOVLW  17
413A:  MOVWF  xBC
413C:  MOVLW  04
413E:  MOVWF  xBF
4140:  MOVLW  A0
4142:  MOVWF  xBE
4144:  MOVLB  0
4146:  RCALL  3A90
....................    countbit_T1=0; 
4148:  MOVLB  9
414A:  CLRF   x9B
414C:  CLRF   x9A
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
414E:  MOVFF  99D,AB8
4152:  MOVFF  99C,AB7
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
4156:  MOVLW  01
4158:  MOVLB  A
415A:  MOVWF  xB9
415C:  MOVFF  AB8,ABB
4160:  MOVFF  AB7,ABA
4164:  MOVLW  08
4166:  MOVWF  xBD
4168:  MOVLW  69
416A:  MOVWF  xBC
416C:  MOVLW  04
416E:  MOVWF  xBF
4170:  MOVLW  EF
4172:  MOVWF  xBE
4174:  MOVLB  0
4176:  RCALL  3A90
....................    countbit_T2=0; 
4178:  MOVLB  9
417A:  CLRF   x9D
417C:  CLRF   x9C
....................    saving_flag=0; 
417E:  CLRF   xA9
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
4180:  MOVLW  20
4182:  MOVLB  4
4184:  ADDWF  xA0,W
4186:  MOVLB  A
4188:  MOVWF  xB6
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
418A:  MOVF   23,F
418C:  BTFSS  FD8.2
418E:  BRA    4472
4190:  MOVF   22,F
4192:  BTFSS  FD8.2
4194:  BRA    4472
4196:  MOVF   21,W
4198:  SUBLW  AA
419A:  BTFSS  FD8.0
419C:  BRA    4472
419E:  BNZ   41A8
41A0:  MOVF   20,W
41A2:  SUBLW  45
41A4:  BTFSS  FD8.0
41A6:  BRA    4472
41A8:  MOVF   xB6,W
41AA:  SUBLW  25
41AC:  BTFSS  FD8.2
41AE:  BRA    4472
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
41B0:  MOVFF  23,03
41B4:  MOVFF  22,02
41B8:  MOVFF  21,01
41BC:  MOVFF  20,00
41C0:  MOVLW  01
41C2:  ADDWF  20,F
41C4:  BTFSC  FD8.0
41C6:  INCF   21,F
41C8:  BTFSC  FD8.2
41CA:  INCF   22,F
41CC:  BTFSC  FD8.2
41CE:  INCF   23,F
41D0:  MOVFF  01,ABA
41D4:  MOVFF  00,AB9
41D8:  MOVFF  01,AC8
41DC:  MOVFF  00,AC7
41E0:  MOVFF  100,AC9
41E4:  MOVLB  0
41E6:  RCALL  3E78
....................          write_ext_eeprom((long int)ptr_card++,mon); 
41E8:  MOVFF  23,03
41EC:  MOVFF  22,02
41F0:  MOVFF  21,01
41F4:  MOVFF  20,00
41F8:  MOVLW  01
41FA:  ADDWF  20,F
41FC:  BTFSC  FD8.0
41FE:  INCF   21,F
4200:  BTFSC  FD8.2
4202:  INCF   22,F
4204:  BTFSC  FD8.2
4206:  INCF   23,F
4208:  MOVFF  01,ABA
420C:  MOVFF  00,AB9
4210:  MOVFF  01,AC8
4214:  MOVFF  00,AC7
4218:  MOVFF  FF,AC9
421C:  RCALL  3E78
....................          write_ext_eeprom((long int)ptr_card++,h); 
421E:  MOVFF  23,03
4222:  MOVFF  22,02
4226:  MOVFF  21,01
422A:  MOVFF  20,00
422E:  MOVLW  01
4230:  ADDWF  20,F
4232:  BTFSC  FD8.0
4234:  INCF   21,F
4236:  BTFSC  FD8.2
4238:  INCF   22,F
423A:  BTFSC  FD8.2
423C:  INCF   23,F
423E:  MOVFF  01,ABA
4242:  MOVFF  00,AB9
4246:  MOVFF  01,AC8
424A:  MOVFF  00,AC7
424E:  MOVFF  101,AC9
4252:  RCALL  3E78
....................          write_ext_eeprom((long int)ptr_card++,min); 
4254:  MOVFF  23,03
4258:  MOVFF  22,02
425C:  MOVFF  21,01
4260:  MOVFF  20,00
4264:  MOVLW  01
4266:  ADDWF  20,F
4268:  BTFSC  FD8.0
426A:  INCF   21,F
426C:  BTFSC  FD8.2
426E:  INCF   22,F
4270:  BTFSC  FD8.2
4272:  INCF   23,F
4274:  MOVFF  01,ABA
4278:  MOVFF  00,AB9
427C:  MOVFF  01,AC8
4280:  MOVFF  00,AC7
4284:  MOVFF  102,AC9
4288:  RCALL  3E78
....................          write_ext_eeprom((long int)ptr_card++,sec);           
428A:  MOVFF  23,03
428E:  MOVFF  22,02
4292:  MOVFF  21,01
4296:  MOVFF  20,00
429A:  MOVLW  01
429C:  ADDWF  20,F
429E:  BTFSC  FD8.0
42A0:  INCF   21,F
42A2:  BTFSC  FD8.2
42A4:  INCF   22,F
42A6:  BTFSC  FD8.2
42A8:  INCF   23,F
42AA:  MOVFF  01,ABA
42AE:  MOVFF  00,AB9
42B2:  MOVFF  01,AC8
42B6:  MOVFF  00,AC7
42BA:  MOVFF  103,AC9
42BE:  RCALL  3E78
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
42C0:  MOVLB  9
42C2:  CLRF   xA5
42C4:  CLRF   xA4
42C6:  MOVF   xA5,F
42C8:  BNZ   4326
42CA:  MOVF   xA4,W
42CC:  SUBLW  4E
42CE:  BNC   4326
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
42D0:  MOVFF  23,03
42D4:  MOVFF  22,02
42D8:  MOVFF  21,01
42DC:  MOVFF  20,00
42E0:  MOVLW  01
42E2:  ADDWF  20,F
42E4:  BTFSC  FD8.0
42E6:  INCF   21,F
42E8:  BTFSC  FD8.2
42EA:  INCF   22,F
42EC:  BTFSC  FD8.2
42EE:  INCF   23,F
42F0:  MOVFF  01,ABA
42F4:  MOVFF  00,AB9
42F8:  MOVLW  A0
42FA:  ADDWF  xA4,W
42FC:  MOVWF  FE9
42FE:  MOVLW  04
4300:  ADDWFC xA5,W
4302:  MOVWF  FEA
4304:  MOVF   FEF,W
4306:  ANDLW  3F
4308:  ADDLW  20
430A:  MOVLB  A
430C:  MOVWF  xBB
430E:  MOVFF  01,AC8
4312:  MOVFF  00,AC7
4316:  MOVWF  xC9
4318:  MOVLB  0
431A:  RCALL  3E78
....................              
....................          } 
431C:  MOVLB  9
431E:  INCF   xA4,F
4320:  BTFSC  FD8.2
4322:  INCF   xA5,F
4324:  BRA    42C6
....................          del_buf(numbyteoftrack1,Track1); 
4326:  MOVLW  4F
4328:  MOVLB  A
432A:  MOVWF  xC5
432C:  MOVLW  04
432E:  MOVWF  xC7
4330:  MOVLW  A0
4332:  MOVWF  xC6
4334:  MOVLB  0
4336:  CALL   3A6E
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
433A:  MOVLB  9
433C:  CLRF   xA5
433E:  CLRF   xA4
4340:  MOVF   xA5,F
4342:  BNZ   43A0
4344:  MOVF   xA4,W
4346:  SUBLW  27
4348:  BNC   43A0
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
434A:  MOVFF  23,03
434E:  MOVFF  22,02
4352:  MOVFF  21,01
4356:  MOVFF  20,00
435A:  MOVLW  01
435C:  ADDWF  20,F
435E:  BTFSC  FD8.0
4360:  INCF   21,F
4362:  BTFSC  FD8.2
4364:  INCF   22,F
4366:  BTFSC  FD8.2
4368:  INCF   23,F
436A:  MOVFF  01,ABA
436E:  MOVFF  00,AB9
4372:  MOVLW  EF
4374:  ADDWF  xA4,W
4376:  MOVWF  FE9
4378:  MOVLW  04
437A:  ADDWFC xA5,W
437C:  MOVWF  FEA
437E:  MOVF   FEF,W
4380:  ANDLW  0F
4382:  ADDLW  30
4384:  MOVLB  A
4386:  MOVWF  xBB
4388:  MOVFF  01,AC8
438C:  MOVFF  00,AC7
4390:  MOVWF  xC9
4392:  MOVLB  0
4394:  RCALL  3E78
....................          }  
4396:  MOVLB  9
4398:  INCF   xA4,F
439A:  BTFSC  FD8.2
439C:  INCF   xA5,F
439E:  BRA    4340
....................          del_buf(numbyteoftrack2,Track2); 
43A0:  MOVLW  28
43A2:  MOVLB  A
43A4:  MOVWF  xC5
43A6:  MOVLW  04
43A8:  MOVWF  xC7
43AA:  MOVLW  EF
43AC:  MOVWF  xC6
43AE:  MOVLB  0
43B0:  CALL   3A6E
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
43B4:  MOVLW  0D
43B6:  MOVLB  A
43B8:  MOVWF  xDF
43BA:  MOVLB  0
43BC:  CALL   075A
43C0:  MOVLW  0A
43C2:  MOVLB  A
43C4:  MOVWF  xDF
43C6:  MOVLB  0
43C8:  CALL   075A
....................       fprintf(COM2,"Done"); 
43CC:  MOVLW  B4
43CE:  MOVWF  FF6
43D0:  MOVLW  06
43D2:  MOVWF  FF7
43D4:  CALL   07A0
....................       if(KP_mode) 
43D8:  MOVLB  1
43DA:  MOVF   x0F,F
43DC:  BZ    43F4
....................       { 
....................          printf("\n\rKey release\n\r"); 
43DE:  MOVLW  BA
43E0:  MOVWF  FF6
43E2:  MOVLW  06
43E4:  MOVWF  FF7
43E6:  MOVLB  0
43E8:  CALL   07A0
....................          keyprss_off; 
43EC:  BCF    F92.7
43EE:  BCF    F89.7
....................          kp_st=0; 
43F0:  MOVLB  1
43F2:  CLRF   x10
....................       }   
....................       count_kp=0xffff; 
43F4:  SETF   x12
43F6:  SETF   x11
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
43F8:  MOVLW  0D
43FA:  MOVLB  A
43FC:  MOVWF  xDF
43FE:  MOVLB  0
4400:  CALL   075A
4404:  MOVLW  0A
4406:  MOVLB  A
4408:  MOVWF  xDF
440A:  MOVLB  0
440C:  CALL   075A
....................       fprintf(COM2,"Waiting for PIN number"); 
4410:  MOVLW  CA
4412:  MOVWF  FF6
4414:  MOVLW  06
4416:  MOVWF  FF7
4418:  CALL   07A0
....................       count_checking=0; 
441C:  MOVLB  1
441E:  CLRF   x07
4420:  CLRF   x06
....................       fprintf(COM2,"\r\n"); 
4422:  MOVLW  0D
4424:  MOVLB  A
4426:  MOVWF  xDF
4428:  MOVLB  0
442A:  CALL   075A
442E:  MOVLW  0A
4430:  MOVLB  A
4432:  MOVWF  xDF
4434:  MOVLB  0
4436:  CALL   075A
....................       charac_timeout=0; 
443A:  CLRF   xFC
443C:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
443E:  MOVFF  23,ABC
4442:  MOVFF  22,ABB
4446:  MOVFF  21,ABA
444A:  MOVFF  20,AB9
444E:  MOVLW  19
4450:  MOVLB  A
4452:  MOVWF  xBD
4454:  MOVLB  0
4456:  RCALL  3F7E
....................       datinbuf=0; 
4458:  MOVLB  9
445A:  CLRF   xA6
....................       saving_flag=0; 
445C:  CLRF   xA9
....................       data_avai=1; 
445E:  MOVLW  01
4460:  MOVWF  xAA
....................       enable_getpin=1; 
4462:  MOVLB  1
4464:  MOVWF  x0C
....................       charac_timeout=0; 
4466:  MOVLB  0
4468:  CLRF   xFC
446A:  CLRF   xFB
....................       key_count_ms=0; 
446C:  MOVLB  1
446E:  CLRF   x0E
4470:  MOVLB  A
4472:  MOVLB  9
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
4474:  MOVLB  0
4476:  GOTO   47CE (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
19AC:  MOVLW  01
19AE:  MOVLB  A
19B0:  MOVWF  xB3
19B2:  MOVWF  xB4
19B4:  MOVWF  xB5
19B6:  MOVWF  xB6
19B8:  CLRF   xB7
19BA:  MOVWF  xB8
19BC:  MOVWF  xB9
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
19BE:  MOVLB  9
19C0:  CLRF   xA3
19C2:  CLRF   xA2
....................    mcr_timeout=0; 
19C4:  CLRF   x98
19C6:  CLRF   x97
19C8:  CLRF   x96
19CA:  CLRF   x95
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
19CC:  MOVF   xA3,W
19CE:  SUBLW  FD
19D0:  BNC   19EE
19D2:  BNZ   19DA
19D4:  MOVF   xA2,W
19D6:  SUBLW  E7
19D8:  BNC   19EE
19DA:  BSF    F93.1
19DC:  BTFSS  F81.1
19DE:  BRA    19EE
19E0:  BSF    F94.5
19E2:  BTFSS  F82.5
19E4:  BRA    19EE
....................       card_timeout++; 
19E6:  INCF   xA2,F
19E8:  BTFSC  FD8.2
19EA:  INCF   xA3,F
....................    } 
19EC:  BRA    19CC
....................    card_timeout=0; 
19EE:  CLRF   xA3
19F0:  CLRF   xA2
....................    buffertrack1[bug_countbit_T1++]=0; 
19F2:  MOVFF  99F,03
19F6:  MOVF   x9E,W
19F8:  INCF   x9E,F
19FA:  BTFSC  FD8.2
19FC:  INCF   x9F,F
19FE:  MOVLB  A
1A00:  MOVWF  xBC
1A02:  MOVLW  17
1A04:  ADDWF  xBC,W
1A06:  MOVWF  FE9
1A08:  MOVLW  05
1A0A:  ADDWFC 03,W
1A0C:  MOVWF  FEA
1A0E:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1A10:  MOVLB  9
1A12:  MOVFF  99F,03
1A16:  MOVF   x9E,W
1A18:  INCF   x9E,F
1A1A:  BTFSC  FD8.2
1A1C:  INCF   x9F,F
1A1E:  MOVLB  A
1A20:  MOVWF  xBC
1A22:  MOVLW  17
1A24:  ADDWF  xBC,W
1A26:  MOVWF  FE9
1A28:  MOVLW  05
1A2A:  ADDWFC 03,W
1A2C:  MOVWF  FEA
1A2E:  MOVLW  01
1A30:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1A32:  MOVLB  9
1A34:  MOVFF  9A1,03
1A38:  MOVF   xA0,W
1A3A:  INCF   xA0,F
1A3C:  BTFSC  FD8.2
1A3E:  INCF   xA1,F
1A40:  MOVLB  A
1A42:  MOVWF  xBC
1A44:  MOVLW  69
1A46:  ADDWF  xBC,W
1A48:  MOVWF  FE9
1A4A:  MOVLW  08
1A4C:  ADDWFC 03,W
1A4E:  MOVWF  FEA
1A50:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1A52:  MOVLB  9
1A54:  MOVFF  9A1,03
1A58:  MOVF   xA0,W
1A5A:  INCF   xA0,F
1A5C:  BTFSC  FD8.2
1A5E:  INCF   xA1,F
1A60:  MOVLB  A
1A62:  MOVWF  xBC
1A64:  MOVLW  69
1A66:  ADDWF  xBC,W
1A68:  MOVWF  FE9
1A6A:  MOVLW  08
1A6C:  ADDWFC 03,W
1A6E:  MOVWF  FEA
1A70:  MOVLW  01
1A72:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1A74:  MOVLB  9
1A76:  MOVF   x9F,W
1A78:  SUBLW  03
1A7A:  BTFSS  FD8.0
1A7C:  BRA    1B5C
1A7E:  BNZ   1A88
1A80:  MOVF   x9E,W
1A82:  SUBLW  51
1A84:  BTFSS  FD8.0
1A86:  BRA    1B5C
1A88:  MOVF   xA1,W
1A8A:  SUBLW  01
1A8C:  BTFSS  FD8.0
1A8E:  BRA    1B5C
1A90:  BNZ   1A98
1A92:  MOVF   xA0,W
1A94:  SUBLW  2B
1A96:  BNC   1B5C
1A98:  MOVF   xA3,W
1A9A:  SUBLW  FF
1A9C:  BNC   1B5C
1A9E:  BNZ   1AA6
1AA0:  MOVF   xA2,W
1AA2:  SUBLW  DB
1AA4:  BNC   1B5C
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
1AA6:  MOVF   xAC,F
1AA8:  BZ    1AB2
....................          { 
....................             bug_countbit_T1=0; 
1AAA:  CLRF   x9F
1AAC:  CLRF   x9E
....................             bug_countbit_T2=0; 
1AAE:  CLRF   xA1
1AB0:  CLRF   xA0
....................          } 
....................          card_timeout++; 
1AB2:  INCF   xA2,F
1AB4:  BTFSC  FD8.2
1AB6:  INCF   xA3,F
....................          mcr_timeout=0; 
1AB8:  CLRF   x98
1ABA:  CLRF   x97
1ABC:  CLRF   x96
1ABE:  CLRF   x95
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1AC0:  BSF    F93.2
1AC2:  MOVLB  A
1AC4:  CLRF   xB3
1AC6:  BTFSC  F81.2
1AC8:  INCF   xB3,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1ACA:  MOVF   xB3,F
1ACC:  BNZ   1B0A
1ACE:  DECFSZ xB4,W
1AD0:  BRA    1B0A
....................          { 
....................             ST1_old = 0; 
1AD2:  CLRF   xB4
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1AD4:  MOVLW  17
1AD6:  MOVLB  9
1AD8:  ADDWF  x9E,W
1ADA:  MOVWF  FE9
1ADC:  MOVLW  05
1ADE:  ADDWFC x9F,W
1AE0:  MOVWF  FEA
1AE2:  BSF    F93.1
1AE4:  MOVLW  00
1AE6:  BTFSS  F81.1
1AE8:  MOVLW  01
1AEA:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1AEC:  MOVLW  69
1AEE:  ADDWF  xA0,W
1AF0:  MOVWF  FE9
1AF2:  MOVLW  08
1AF4:  ADDWFC xA1,W
1AF6:  MOVWF  FEA
1AF8:  MOVFF  AB7,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1AFC:  INCF   x9E,F
1AFE:  BTFSC  FD8.2
1B00:  INCF   x9F,F
....................             card_timeout=0; 
1B02:  CLRF   xA3
1B04:  CLRF   xA2
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1B06:  BRA    1B14
1B08:  MOVLB  A
1B0A:  DECFSZ xB3,W
1B0C:  BRA    1B12
1B0E:  MOVLW  01
1B10:  MOVWF  xB4
1B12:  MOVLB  9
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1B14:  BSF    F93.3
1B16:  MOVLB  A
1B18:  CLRF   xB5
1B1A:  BTFSC  F81.3
1B1C:  INCF   xB5,F
....................          if(ST2 == 0 && ST2_old == 1) 
1B1E:  MOVF   xB5,F
1B20:  BNZ   1B40
1B22:  DECFSZ xB6,W
1B24:  BRA    1B40
....................          { 
....................             ST2_old = 0; 
1B26:  CLRF   xB6
....................             Bit_t2 = !input(MCR_DATA2); 
1B28:  BSF    F94.5
1B2A:  CLRF   xB7
1B2C:  BTFSS  F82.5
1B2E:  INCF   xB7,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1B30:  MOVLB  9
1B32:  INCF   xA0,F
1B34:  BTFSC  FD8.2
1B36:  INCF   xA1,F
....................             card_timeout=0; 
1B38:  CLRF   xA3
1B3A:  CLRF   xA2
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1B3C:  BRA    1B4A
1B3E:  MOVLB  A
1B40:  DECFSZ xB5,W
1B42:  BRA    1B48
1B44:  MOVLW  01
1B46:  MOVWF  xB6
1B48:  MOVLB  9
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1B4A:  BSF    F93.0
1B4C:  BTFSS  F81.0
1B4E:  BRA    1B5A
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1B50:  CLRF   xAC
....................             card_timeout=65500; 
1B52:  SETF   xA3
1B54:  MOVLW  DC
1B56:  MOVWF  xA2
....................             break;            
1B58:  BRA    1B5C
....................          } 
....................       } 
1B5A:  BRA    1A76
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1B5C:  CLRF   xA3
1B5E:  CLRF   xA2
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1B60:  MOVLB  A
1B62:  CLRF   xC5
1B64:  MOVFF  99F,AC7
1B68:  MOVFF  99E,AC6
1B6C:  MOVLW  05
1B6E:  MOVWF  xC9
1B70:  MOVLW  17
1B72:  MOVWF  xC8
1B74:  MOVLB  0
1B76:  CALL   0B16
1B7A:  MOVFF  01,AB8
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1B7E:  MOVLW  01
1B80:  MOVLB  A
1B82:  MOVWF  xC5
1B84:  MOVFF  9A1,AC7
1B88:  MOVFF  9A0,AC6
1B8C:  MOVLW  08
1B8E:  MOVWF  xC9
1B90:  MOVLW  69
1B92:  MOVWF  xC8
1B94:  MOVLB  0
1B96:  CALL   0B16
1B9A:  MOVFF  01,AB9
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1B9E:  MOVLB  9
1BA0:  DECFSZ xA7,W
1BA2:  BRA    1C44
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1BA4:  MOVLW  E2
1BA6:  MOVWF  FF6
1BA8:  MOVLW  06
1BAA:  MOVWF  FF7
1BAC:  MOVLW  0E
1BAE:  MOVLB  A
1BB0:  MOVWF  xD3
1BB2:  MOVLB  0
1BB4:  RCALL  1718
1BB6:  MOVLW  10
1BB8:  MOVWF  FE9
1BBA:  MOVFF  99F,ABD
1BBE:  MOVFF  99E,ABC
1BC2:  RCALL  1742
1BC4:  MOVLW  0D
1BC6:  MOVLB  A
1BC8:  MOVWF  xDF
1BCA:  MOVLB  0
1BCC:  CALL   075A
1BD0:  MOVLW  0A
1BD2:  MOVLB  A
1BD4:  MOVWF  xDF
1BD6:  MOVLB  0
1BD8:  CALL   075A
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1BDC:  MOVLW  F6
1BDE:  MOVWF  FF6
1BE0:  MOVLW  06
1BE2:  MOVWF  FF7
1BE4:  MOVLW  0E
1BE6:  MOVLB  A
1BE8:  MOVWF  xD3
1BEA:  MOVLB  0
1BEC:  RCALL  1718
1BEE:  MOVLW  10
1BF0:  MOVWF  FE9
1BF2:  MOVFF  9A1,ABD
1BF6:  MOVFF  9A0,ABC
1BFA:  RCALL  1742
1BFC:  MOVLW  0D
1BFE:  MOVLB  A
1C00:  MOVWF  xDF
1C02:  MOVLB  0
1C04:  CALL   075A
1C08:  MOVLW  0A
1C0A:  MOVLB  A
1C0C:  MOVWF  xDF
1C0E:  MOVLB  0
1C10:  CALL   075A
....................          debug_reader();       
1C14:  BRA    18F0
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1C16:  MOVLB  A
1C18:  MOVF   xB8,F
1C1A:  BNZ   1C2C
1C1C:  MOVLW  0A
1C1E:  MOVWF  FF6
1C20:  MOVLW  07
1C22:  MOVWF  FF7
1C24:  MOVLB  0
1C26:  CALL   07A0
1C2A:  MOVLB  A
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1C2C:  MOVF   xB9,F
1C2E:  BNZ   1C40
1C30:  MOVLW  20
1C32:  MOVWF  FF6
1C34:  MOVLW  07
1C36:  MOVWF  FF7
1C38:  MOVLB  0
1C3A:  CALL   07A0
1C3E:  MOVLB  A
....................       } 
....................          else 
1C40:  BRA    1C50
1C42:  MOVLB  9
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1C44:  MOVLW  0F
1C46:  MOVLB  A
1C48:  MOVWF  xBC
1C4A:  MOVLB  0
1C4C:  RCALL  1984
1C4E:  MOVLB  A
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1C50:  MOVF   xB8,F
1C52:  BZ    1C58
1C54:  MOVF   xB9,F
1C56:  BNZ   1C78
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1C58:  MOVLB  9
1C5A:  CLRF   xA1
1C5C:  CLRF   xA0
....................          bug_countbit_T1=0; 
1C5E:  CLRF   x9F
1C60:  CLRF   x9E
....................          reading_fg=0; 
1C62:  CLRF   xAB
....................          count_reading_error++; 
1C64:  INCF   xAC,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1C66:  CLRF   x98
1C68:  CLRF   x97
1C6A:  CLRF   x96
1C6C:  CLRF   x95
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1C6E:  MOVLW  00
1C70:  MOVWF  01
1C72:  BRA    1CB0
....................       } 
....................          else  
1C74:  BRA    1CAC
1C76:  MOVLB  A
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1C78:  MOVLW  01
1C7A:  MOVLB  9
1C7C:  MOVWF  xA6
....................             reading_fg=1; 
1C7E:  MOVWF  xAB
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1C80:  MOVFF  9A1,99D
1C84:  MOVFF  9A0,99C
....................             countbit_T1=bug_countbit_T1; 
1C88:  MOVFF  99F,99B
1C8C:  MOVFF  99E,99A
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1C90:  CLRF   x9F
1C92:  CLRF   x9E
....................             bug_countbit_T2=0;  
1C94:  CLRF   xA1
1C96:  CLRF   xA0
....................             mcr_timeout=0; 
1C98:  CLRF   x98
1C9A:  CLRF   x97
1C9C:  CLRF   x96
1C9E:  CLRF   x95
....................             charac_timeout=0; 
1CA0:  MOVLB  0
1CA2:  CLRF   xFC
1CA4:  CLRF   xFB
....................             return 1; 
1CA6:  MOVWF  01
1CA8:  MOVLB  9
1CAA:  BRA    1CB0
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1CAC:  MOVLW  00
1CAE:  MOVWF  01
.................... } 
1CB0:  MOVLB  0
1CB2:  GOTO   1D1E (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
1CB6:  MOVLW  02
1CB8:  MOVLB  A
1CBA:  MOVWF  xB3
1CBC:  MOVLW  FA
1CBE:  MOVWF  xB4
1CC0:  MOVLB  0
1CC2:  CALL   0736
1CC6:  MOVLB  A
1CC8:  DECFSZ xB3,F
1CCA:  BRA    1CBC
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
1CCC:  MOVLB  9
1CCE:  DECFSZ xA9,W
1CD0:  BRA    1CD4
1CD2:  BRA    1D30
....................       if((KP_mode)&&(enable_getpin==0)&&(booting==1)) 
1CD4:  MOVLB  1
1CD6:  MOVF   x0F,F
1CD8:  BZ    1D1A
1CDA:  MOVF   x0C,F
1CDC:  BNZ   1D1A
1CDE:  DECFSZ x05,W
1CE0:  BRA    1D1A
....................       { 
....................          if(kp_st==1) 
1CE2:  DECFSZ x10,W
1CE4:  BRA    1CFE
....................          { 
....................             printf("\n\rKey release.\n\r"); 
1CE6:  MOVLW  38
1CE8:  MOVWF  FF6
1CEA:  MOVLW  1D
1CEC:  MOVWF  FF7
1CEE:  MOVLB  0
1CF0:  CALL   07A0
....................             keyprss_off; 
1CF4:  BCF    F92.7
1CF6:  BCF    F89.7
....................             kp_st=0; 
1CF8:  MOVLB  1
1CFA:  CLRF   x10
....................          } 
....................          else 
1CFC:  BRA    1D1A
....................          { 
....................             printf("\n\rKey press.\n\r"); 
1CFE:  MOVLW  4A
1D00:  MOVWF  FF6
1D02:  MOVLW  1D
1D04:  MOVWF  FF7
1D06:  MOVLB  0
1D08:  CALL   07A0
....................             keyprss_on; 
1D0C:  BCF    F92.7
1D0E:  BSF    F89.7
....................             kp_st=1;  
1D10:  MOVLW  01
1D12:  MOVLB  1
1D14:  MOVWF  x10
....................             count_kp=0; 
1D16:  CLRF   x12
1D18:  CLRF   x11
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1D1A:  MOVLB  0
1D1C:  BRA    19AC
1D1E:  MOVFF  01,9A8
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1D22:  MOVLB  9
1D24:  CLRF   x98
1D26:  CLRF   x97
1D28:  CLRF   x96
1D2A:  CLRF   x95
....................       card_timeout=0; 
1D2C:  CLRF   xA3
1D2E:  CLRF   xA2
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1D30:  BCF    FF0.0
1D32:  MOVLB  0
1D34:  GOTO   0084
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
5A50:  CLRF   19
5A52:  BTFSC  FF2.7
5A54:  BSF    19.7
5A56:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
5A58:  MOVLB  A
5A5A:  CLRF   xC8
5A5C:  MOVLW  94
5A5E:  MOVWF  xC7
5A60:  MOVLW  03
5A62:  MOVWF  xC9
5A64:  MOVLB  0
5A66:  CALL   3E78
5A6A:  BTFSC  19.7
5A6C:  BSF    FF2.7
5A6E:  CLRF   19
5A70:  BTFSC  FF2.7
5A72:  BSF    19.7
5A74:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
5A76:  MOVLB  A
5A78:  CLRF   xC0
5A7A:  MOVLW  94
5A7C:  MOVWF  xBF
5A7E:  MOVLB  0
5A80:  CALL   3954
5A84:  BTFSC  19.7
5A86:  BSF    FF2.7
5A88:  MOVFF  01,146
....................    fprintf(COM2,"tran time = %d\n\r",delaycharaction);   
5A8C:  MOVLW  7E
5A8E:  MOVWF  FF6
5A90:  MOVLW  1D
5A92:  MOVWF  FF7
5A94:  CLRF   19
5A96:  BTFSC  FF2.7
5A98:  BSF    19.7
5A9A:  BCF    FF2.7
5A9C:  MOVLW  0C
5A9E:  MOVLB  A
5AA0:  MOVWF  xD3
5AA2:  MOVLB  0
5AA4:  CALL   1718
5AA8:  BTFSC  19.7
5AAA:  BSF    FF2.7
5AAC:  CLRF   19
5AAE:  BTFSC  FF2.7
5AB0:  BSF    19.7
5AB2:  BCF    FF2.7
5AB4:  MOVFF  146,ABF
5AB8:  MOVLW  18
5ABA:  MOVLB  A
5ABC:  MOVWF  xC0
5ABE:  MOVLB  0
5AC0:  CALL   182C
5AC4:  BTFSC  19.7
5AC6:  BSF    FF2.7
5AC8:  CLRF   19
5ACA:  BTFSC  FF2.7
5ACC:  BSF    19.7
5ACE:  BCF    FF2.7
5AD0:  MOVLW  0A
5AD2:  MOVLB  A
5AD4:  MOVWF  xDF
5AD6:  MOVLB  0
5AD8:  CALL   075A
5ADC:  BTFSC  19.7
5ADE:  BSF    FF2.7
5AE0:  CLRF   19
5AE2:  BTFSC  FF2.7
5AE4:  BSF    19.7
5AE6:  BCF    FF2.7
5AE8:  MOVLW  0D
5AEA:  MOVLB  A
5AEC:  MOVWF  xDF
5AEE:  MOVLB  0
5AF0:  CALL   075A
5AF4:  BTFSC  19.7
5AF6:  BSF    FF2.7
5AF8:  CLRF   19
5AFA:  BTFSC  FF2.7
5AFC:  BSF    19.7
5AFE:  BCF    FF2.7
....................  
....................    write_ext_eeprom(strobe_keypressmode,0); 
5B00:  MOVLB  A
5B02:  CLRF   xC8
5B04:  MOVLW  7F
5B06:  MOVWF  xC7
5B08:  CLRF   xC9
5B0A:  MOVLB  0
5B0C:  CALL   3E78
5B10:  BTFSC  19.7
5B12:  BSF    FF2.7
5B14:  CLRF   19
5B16:  BTFSC  FF2.7
5B18:  BSF    19.7
5B1A:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
5B1C:  MOVLB  A
5B1E:  CLRF   xC0
5B20:  MOVLW  7F
5B22:  MOVWF  xBF
5B24:  MOVLB  0
5B26:  CALL   3954
5B2A:  BTFSC  19.7
5B2C:  BSF    FF2.7
5B2E:  MOVFF  01,10F
....................    if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
5B32:  MOVLB  1
5B34:  MOVF   x0F,F
5B36:  BZ    5B56
5B38:  MOVLW  90
5B3A:  MOVWF  FF6
5B3C:  MOVLW  1D
5B3E:  MOVWF  FF7
5B40:  CLRF   19
5B42:  BTFSC  FF2.7
5B44:  BSF    19.7
5B46:  BCF    FF2.7
5B48:  MOVLB  0
5B4A:  CALL   07A0
5B4E:  BTFSC  19.7
5B50:  BSF    FF2.7
....................    else printf("KP-> Keypress mode setting (Off)\n\r"); 
5B52:  BRA    5B70
5B54:  MOVLB  1
5B56:  MOVLW  B2
5B58:  MOVWF  FF6
5B5A:  MOVLW  1D
5B5C:  MOVWF  FF7
5B5E:  CLRF   19
5B60:  BTFSC  FF2.7
5B62:  BSF    19.7
5B64:  BCF    FF2.7
5B66:  MOVLB  0
5B68:  CALL   07A0
5B6C:  BTFSC  19.7
5B6E:  BSF    FF2.7
5B70:  CLRF   19
5B72:  BTFSC  FF2.7
5B74:  BSF    19.7
5B76:  BCF    FF2.7
....................  
....................    write_ext_eeprom(strobe_Master_SLV,1);    
5B78:  MOVLB  A
5B7A:  CLRF   xC8
5B7C:  MOVLW  91
5B7E:  MOVWF  xC7
5B80:  MOVLW  01
5B82:  MOVWF  xC9
5B84:  MOVLB  0
5B86:  CALL   3E78
5B8A:  BTFSC  19.7
5B8C:  BSF    FF2.7
5B8E:  CLRF   19
5B90:  BTFSC  FF2.7
5B92:  BSF    19.7
5B94:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
5B96:  MOVLB  A
5B98:  CLRF   xC0
5B9A:  MOVLW  91
5B9C:  MOVWF  xBF
5B9E:  MOVLB  0
5BA0:  CALL   3954
5BA4:  BTFSC  19.7
5BA6:  BSF    FF2.7
5BA8:  MOVFF  01,9B3
....................    if(mode_sl) printf("Is Slave mode\n\r"); 
5BAC:  MOVLB  9
5BAE:  MOVF   xB3,F
5BB0:  BZ    5BD0
5BB2:  MOVLW  D6
5BB4:  MOVWF  FF6
5BB6:  MOVLW  1D
5BB8:  MOVWF  FF7
5BBA:  CLRF   19
5BBC:  BTFSC  FF2.7
5BBE:  BSF    19.7
5BC0:  BCF    FF2.7
5BC2:  MOVLB  0
5BC4:  CALL   07A0
5BC8:  BTFSC  19.7
5BCA:  BSF    FF2.7
....................    else printf("Is Master mode)\n\r"); 
5BCC:  BRA    5BEA
5BCE:  MOVLB  9
5BD0:  MOVLW  E6
5BD2:  MOVWF  FF6
5BD4:  MOVLW  1D
5BD6:  MOVWF  FF7
5BD8:  CLRF   19
5BDA:  BTFSC  FF2.7
5BDC:  BSF    19.7
5BDE:  BCF    FF2.7
5BE0:  MOVLB  0
5BE2:  CALL   07A0
5BE6:  BTFSC  19.7
5BE8:  BSF    FF2.7
5BEA:  CLRF   19
5BEC:  BTFSC  FF2.7
5BEE:  BSF    19.7
5BF0:  BCF    FF2.7
....................     
....................    write_ext_eeprom(kindofKB,1); 
5BF2:  MOVLB  A
5BF4:  CLRF   xC8
5BF6:  MOVLW  7E
5BF8:  MOVWF  xC7
5BFA:  MOVLW  01
5BFC:  MOVWF  xC9
5BFE:  MOVLB  0
5C00:  CALL   3E78
5C04:  BTFSC  19.7
5C06:  BSF    FF2.7
5C08:  CLRF   19
5C0A:  BTFSC  FF2.7
5C0C:  BSF    19.7
5C0E:  BCF    FF2.7
....................    type_KB = read_ext_eeprom(kindofKB); 
5C10:  MOVLB  A
5C12:  CLRF   xC0
5C14:  MOVLW  7E
5C16:  MOVWF  xBF
5C18:  MOVLB  0
5C1A:  CALL   3954
5C1E:  BTFSC  19.7
5C20:  BSF    FF2.7
5C22:  MOVFF  01,113
....................    if(type_KB) printf("Is 4x6 matrix\n\r"); 
5C26:  MOVLB  1
5C28:  MOVF   x13,F
5C2A:  BZ    5C4A
5C2C:  MOVLW  F8
5C2E:  MOVWF  FF6
5C30:  MOVLW  1D
5C32:  MOVWF  FF7
5C34:  CLRF   19
5C36:  BTFSC  FF2.7
5C38:  BSF    19.7
5C3A:  BCF    FF2.7
5C3C:  MOVLB  0
5C3E:  CALL   07A0
5C42:  BTFSC  19.7
5C44:  BSF    FF2.7
....................    else printf("Is 4x5 matrix\n\r"); 
5C46:  BRA    5C64
5C48:  MOVLB  1
5C4A:  MOVLW  08
5C4C:  MOVWF  FF6
5C4E:  MOVLW  1E
5C50:  MOVWF  FF7
5C52:  CLRF   19
5C54:  BTFSC  FF2.7
5C56:  BSF    19.7
5C58:  BCF    FF2.7
5C5A:  MOVLB  0
5C5C:  CALL   07A0
5C60:  BTFSC  19.7
5C62:  BSF    FF2.7
....................     
....................    ptr_card=ptr_start; 
5C64:  CLRF   23
5C66:  CLRF   22
5C68:  CLRF   21
5C6A:  MOVLW  96
5C6C:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5C6E:  CLRF   27
5C70:  CLRF   26
5C72:  MOVLW  AA
5C74:  MOVWF  25
5C76:  MOVLW  47
5C78:  MOVWF  24
5C7A:  CLRF   19
5C7C:  BTFSC  FF2.7
5C7E:  BSF    19.7
5C80:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5C82:  MOVFF  23,ABC
5C86:  MOVFF  22,ABB
5C8A:  MOVFF  21,ABA
5C8E:  MOVFF  20,AB9
5C92:  MOVLW  19
5C94:  MOVLB  A
5C96:  MOVWF  xBD
5C98:  MOVLB  0
5C9A:  CALL   3F7E
5C9E:  BTFSC  19.7
5CA0:  BSF    FF2.7
5CA2:  CLRF   19
5CA4:  BTFSC  FF2.7
5CA6:  BSF    19.7
5CA8:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5CAA:  MOVFF  27,ABC
5CAE:  MOVFF  26,ABB
5CB2:  MOVFF  25,ABA
5CB6:  MOVFF  24,AB9
5CBA:  MOVLW  1E
5CBC:  MOVLB  A
5CBE:  MOVWF  xBD
5CC0:  MOVLB  0
5CC2:  CALL   3F7E
5CC6:  BTFSC  19.7
5CC8:  BSF    FF2.7
5CCA:  CLRF   19
5CCC:  BTFSC  FF2.7
5CCE:  BSF    19.7
5CD0:  BCF    FF2.7
....................    save_coutcard(0); 
5CD2:  MOVLB  A
5CD4:  CLRF   xB7
5CD6:  CLRF   xB6
5CD8:  MOVLB  0
5CDA:  CALL   45E4
5CDE:  BTFSC  19.7
5CE0:  BSF    FF2.7
5CE2:  CLRF   19
5CE4:  BTFSC  FF2.7
5CE6:  BSF    19.7
5CE8:  BCF    FF2.7
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
5CEA:  MOVLB  A
5CEC:  CLRF   xC8
5CEE:  MOVLW  93
5CF0:  MOVWF  xC7
5CF2:  CLRF   xC9
5CF4:  MOVLB  0
5CF6:  CALL   3E78
5CFA:  BTFSC  19.7
5CFC:  BSF    FF2.7
5CFE:  CLRF   19
5D00:  BTFSC  FF2.7
5D02:  BSF    19.7
5D04:  BCF    FF2.7
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
5D06:  MOVLB  A
5D08:  CLRF   xC0
5D0A:  MOVLW  93
5D0C:  MOVWF  xBF
5D0E:  MOVLB  0
5D10:  CALL   3954
5D14:  BTFSC  19.7
5D16:  BSF    FF2.7
5D18:  MOVFF  01,499
....................    #endif 
.................... } 
5D1C:  GOTO   835C (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
....................       printf("\n\r"); 
....................       strcpy(buffer2,"d"); 
....................       index=0; 
....................       ee_dat=0; 
....................       count_card=1; 
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
....................       { 
....................          unsigned long adr=0; 
....................          //unsigned int count=0; 
....................          rec[0]=0; 
....................          count_card_tg=get_countcard(); 
....................          adr=count_card*numdata; 
....................          addr_key=EEPROM_KEY_ST; 
....................          while(count_card<=count_card_tg) 
....................          { 
....................             adr=count_card*numdata+ptr_start; 
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
....................             ee_dat=0; 
....................             index=0; 
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
....................                ee_dat = rec[index+5]; 
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
....................                index++; 
....................                if(ee_dat==0)break; 
....................             } 
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................             index=0; 
....................             ee_dat=0; 
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
....................                index++; 
....................                if(ee_dat==0)break; 
....................             } 
....................             index=0; 
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
....................             if(ptr_card_key>addr_key) 
....................             { 
....................                i=0; 
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
....................                      fputc(ee_dat,COM2); 
....................                   i++; 
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+50; 
....................                fprintf(COM2,"\n\r"); 
....................             } 
....................             count_card++; 
....................          } 
....................       }  
....................       strcpy(buffer2,"f"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
....................          format_eepromext(); 
....................          fprintf(COM2," exit\n\r");  
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
....................          ease_eeprom(); 
....................          fprintf(COM2," exit\n\r");  
....................       }     
....................      strcpy(buffer2,"RSPW"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
....................          reset_password(); 
....................          init_password(); 
....................          fprintf(COM2," exit\n\r");  
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
....................       }   
....................       strcpy(buffer2,"rsfact"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
....................          rstfact(); 
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
....................       { 
....................          mode=LOGOFF; 
....................          keydebug_en=0; 
....................          set_tris_a(0xff); 
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          fprintf(COM2,"New console name>"); 
....................          USART_getstring(EN_ECHO,16, console); 
....................          EEPROM_write(strobe_nameconsole,16,console); 
....................          fprintf(COM2," OK\n\r"); 
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
....................          else fprintf(COM2,"[S]");   
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
....................          fprintf(COM2,"[%u]",delaycharaction); 
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
....................       } 
....................       strcpy(buffer2,"sc"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          fprintf(COM2,"Year>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          year=(unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Month>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          mon=(unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Date>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          date = (unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Day>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          day = (unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Hour>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          h = (unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Minutes>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          min = (unsigned int8)strtoi(temp);                   
....................          fprintf(COM2,"Seconds>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          sec = (unsigned int8)strtoi(temp);                   
....................          fprintf(COM2,"\n\r"); 
....................          rtc_set_datetime(date,mon,year,day,h,min); 
....................       } 
....................       strcpy(buffer2,"MS"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to select Master mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           mode_sl = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
....................           set_tris_a(0xff); 
....................           fprintf(COM2,"\n\r"); 
....................       } 
....................       strcpy(buffer2,"KP"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           KP_mode = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
....................           fprintf(COM2,"\n\r"); 
....................       } 
....................       strcpy(buffer2,"tran time"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaycharaction = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           type_KB=(unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(kindofKB,type_KB); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          printf("h-> Help\n\r"); 
....................          printf("sc-> Set Clock\n\r"); 
....................          printf("c-> show Clock\n\r"); 
....................          printf("password-> changing PASSWORD\n\r"); 
....................          printf("n -> change console Name\n\r"); 
....................          printf("f-> Format\n\r"); 
....................          printf("e-> Exit\n\r");   
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
....................          printf("tran time-> time of each transaction\n\r"); 
....................          printf("debug-> on/off debug mode\n\r");      
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
....................          printf("rsfact-> reset factory\n\r");      
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
....................       if(!stringcomp(buffer_uart,buffer2))  
....................       { 
....................          fprintf(COM2,"old password:"); 
....................          EEPROM_read(strobe_pass_addr,20,password); 
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
....................          if(!stringcomp(entpassword,password)) 
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
....................             fprintf(COM2,"\n\ragain:"); 
....................             USART_getstring(STAR_ECHO, 20, password); 
....................             if(!stringcomp(entpassword,password)) 
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
....................                fprintf(COM2,"\n\rOK\n\r");    
....................             } 
....................                else 
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
....................                } 
....................          } 
....................             else 
....................             { 
....................                fprintf(COM2," X\n\r"); 
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           debugmode = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
.................... } 
.................... //=============================================== 
....................  
....................  
.................... //========================= 
....................  
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... {   
....................    char c; 
....................    //restart_wdt(); 
....................    //disable_interrupts(INT_TIMER0); 
....................    //set_timer0(0);   
....................    //disable_interrupts(INT_RDA);   
....................    c=fgetc(COM1); 
*
22CC:  BTFSS  F9E.5
22CE:  BRA    22CC
22D0:  MOVFF  FAF,AB3
22D4:  MOVLB  A
....................    //if((c>127)||(c<30)) return; 
....................    //fprintf(COM2,"%c ",c);   
....................    #if defined(SIM900) 
....................    count_checking=0; 
22D6:  MOVLB  1
22D8:  CLRF   x07
22DA:  CLRF   x06
....................    if(checking_sim==1) 
22DC:  MOVLB  4
22DE:  DECFSZ x9C,W
22E0:  BRA    22F8
....................    { 
....................       restart_wdt(); 
22E2:  CLRWDT
....................       setup_wdt(WDT_OFF); 
22E4:  BCF    FC0.0
....................       checking_sim=0; 
22E6:  CLRF   x9C
....................       fprintf(COM2,"OK\n\r"); 
22E8:  MOVLW  82
22EA:  MOVWF  FF6
22EC:  MOVLW  23
22EE:  MOVWF  FF7
22F0:  MOVLB  0
22F2:  CALL   07A0
22F6:  MOVLB  4
....................    } 
....................    #endif 
....................    output_toggle(LED); 
22F8:  BCF    F92.6
22FA:  BTG    F89.6
....................    if(booting_done) 
22FC:  MOVLB  1
22FE:  MOVF   xB5,F
2300:  BZ    2336
....................    { 
....................       buffer_uart[UART_index++]=c; 
2302:  MOVF   xB2,W
2304:  INCF   xB2,F
2306:  CLRF   03
2308:  ADDLW  4E
230A:  MOVWF  FE9
230C:  MOVLW  01
230E:  ADDWFC 03,W
2310:  MOVWF  FEA
2312:  MOVFF  AB3,FEF
....................       if(UART_index>=99)  
2316:  MOVF   xB2,W
2318:  SUBLW  62
231A:  BC    231E
....................       { 
....................          UART_index=0; 
231C:  CLRF   xB2
....................       } 
....................       //============================= 
....................       //output_toggle(PIN_C2); 
....................       if(receiver_state==0) 
231E:  MOVF   xB4,F
2320:  BNZ   2336
....................       { 
....................          timing_wait=3000;//3000 
2322:  MOVLW  0B
2324:  MOVLB  4
2326:  MOVWF  x98
2328:  MOVLW  B8
232A:  MOVWF  x97
....................          SIM_state=data_analyze; 
232C:  MOVLW  0D
232E:  MOVWF  x95
....................          count_polling=0; 
2330:  CLRF   x94
2332:  CLRF   x93
2334:  MOVLB  1
....................       } 
....................       //============================= 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................    } 
....................    #if defined(SIM900) 
....................    if(SIM_state==data_analyze) 
2336:  MOVLB  4
2338:  MOVF   x95,W
233A:  SUBLW  0D
233C:  BNZ   236C
....................    { 
....................       over_byte++; 
233E:  MOVLB  1
2340:  INCF   xB6,F
2342:  BTFSC  FD8.2
2344:  INCF   xB7,F
....................       if(over_byte>=200) 
2346:  MOVF   xB7,F
2348:  BNZ   2350
234A:  MOVF   xB6,W
234C:  SUBLW  C7
234E:  BC    236A
....................       { 
....................          over_byte=0; 
2350:  CLRF   xB7
2352:  CLRF   xB6
....................          setup_wdt(WDT_ON); 
2354:  BSF    FC0.0
....................          output_low(rst_sim); 
2356:  BCF    F94.1
2358:  BCF    F8B.1
....................          fprintf(COM2,"\n\rDevice will reset\n\r"); 
235A:  MOVLW  88
235C:  MOVWF  FF6
235E:  MOVLW  23
2360:  MOVWF  FF7
2362:  MOVLB  0
2364:  CALL   07A0
2368:  MOVLB  1
236A:  MOVLB  4
....................       } 
....................    } 
....................    if(SIM_state==MSG_sending)over_byte=0; 
236C:  MOVF   x95,W
236E:  SUBLW  08
2370:  BNZ   237A
2372:  MOVLB  1
2374:  CLRF   xB7
2376:  CLRF   xB6
2378:  MOVLB  4
....................    #endif 
....................    return; 
....................    //enable_interrupts(INT_TIMER0); 
.................... } 
.................... //========================= 
237A:  BCF    F9E.5
237C:  MOVLB  0
237E:  GOTO   0084
.................... #INT_TIMER1 
.................... void timer1() 
.................... { 
....................    output_toggle(LED); 
*
239E:  BCF    F92.6
23A0:  BTG    F89.6
....................    set_timer1(0xffff-50); 
23A2:  SETF   FCF
23A4:  MOVLW  CD
23A6:  MOVWF  FCE
.................... } 
.................... //========================== 
23A8:  BCF    F9E.0
23AA:  GOTO   0084
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
4716:  MOVLB  1
4718:  MOVF   x0F,F
471A:  BZ    4756
....................    { 
....................       if(count_kp<500)count_kp++; 
471C:  MOVF   x12,W
471E:  SUBLW  01
4720:  BNC   4730
4722:  BNZ   472A
4724:  MOVF   x11,W
4726:  SUBLW  F3
4728:  BNC   4730
472A:  INCF   x11,F
472C:  BTFSC  FD8.2
472E:  INCF   x12,F
....................       if(count_kp==500) 
4730:  MOVF   x11,W
4732:  SUBLW  F4
4734:  BNZ   4756
4736:  DECFSZ x12,W
4738:  BRA    4756
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
473A:  MOVLW  4A
473C:  MOVWF  FF6
473E:  MOVLW  49
4740:  MOVWF  FF7
4742:  MOVLB  0
4744:  CALL   07A0
....................             keyprss_off; 
4748:  BCF    F92.7
474A:  BCF    F89.7
....................             kp_st=0;     
474C:  MOVLB  1
474E:  CLRF   x10
....................             count_kp++; 
4750:  INCF   x11,F
4752:  BTFSC  FD8.2
4754:  INCF   x12,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
4756:  DECFSZ x0B,W
4758:  BRA    4774
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
475A:  MOVLB  9
475C:  MOVF   xB3,F
475E:  BNZ   4768
4760:  MOVLB  0
4762:  CALL   23AE
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
4766:  BRA    4772
4768:  MOVLB  0
476A:  CALL   360A
476E:  MOVFF  01,AB5
4772:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
4774:  DECFSZ x0C,W
4776:  BRA    4790
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
4778:  MOVLB  9
477A:  MOVF   xB3,F
477C:  BNZ   4786
477E:  MOVLB  0
4780:  CALL   23AE
....................          else temp=kbd_getc_slv(); 
4784:  BRA    4790
4786:  MOVLB  0
4788:  CALL   360A
478C:  MOVFF  01,AB5
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
4790:  MOVLB  9
4792:  MOVF   x98,F
4794:  BNZ   47B4
4796:  MOVF   x97,F
4798:  BNZ   47B4
479A:  MOVF   x96,F
479C:  BNZ   47B4
479E:  MOVF   x95,W
47A0:  SUBLW  04
47A2:  BNC   47B4
47A4:  MOVLW  01
47A6:  ADDWF  x95,F
47A8:  BTFSC  FD8.0
47AA:  INCF   x96,F
47AC:  BTFSC  FD8.2
47AE:  INCF   x97,F
47B0:  BTFSC  FD8.2
47B2:  INCF   x98,F
....................   if(mcr_timeout==5) 
47B4:  MOVF   x95,W
47B6:  SUBLW  05
47B8:  BNZ   480E
47BA:  MOVF   x96,F
47BC:  BNZ   480E
47BE:  MOVF   x97,F
47C0:  BNZ   480E
47C2:  MOVF   x98,F
47C4:  BNZ   480E
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
47C6:  DECFSZ xAB,W
47C8:  BRA    47D0
47CA:  MOVLB  0
47CC:  BRA    3FFC
47CE:  MOVLB  9
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
47D0:  MOVLW  05
47D2:  MOVWF  FEA
47D4:  MOVLW  17
47D6:  MOVWF  FE9
47D8:  CLRF   00
47DA:  MOVLW  03
47DC:  MOVWF  02
47DE:  MOVLW  52
47E0:  MOVWF  01
47E2:  MOVLB  0
47E4:  RCALL  447A
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
47E6:  MOVLW  08
47E8:  MOVWF  FEA
47EA:  MOVLW  69
47EC:  MOVWF  FE9
47EE:  CLRF   00
47F0:  MOVLW  01
47F2:  MOVWF  02
47F4:  MOVLW  2C
47F6:  MOVWF  01
47F8:  RCALL  447A
....................       //debug_card(); 
....................       count_reading_error=0; 
47FA:  MOVLB  9
47FC:  CLRF   xAC
....................       mcr_timeout++;   
47FE:  MOVLW  01
4800:  ADDWF  x95,F
4802:  BTFSC  FD8.0
4804:  INCF   x96,F
4806:  BTFSC  FD8.2
4808:  INCF   x97,F
480A:  BTFSC  FD8.2
480C:  INCF   x98,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
480E:  MOVLB  A
4810:  CLRF   xC0
4812:  MOVLW  94
4814:  MOVWF  xBF
4816:  MOVLB  0
4818:  CALL   3954
481C:  MOVFF  01,146
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
4820:  MOVLW  02
4822:  MOVLB  A
4824:  MOVWF  xBC
4826:  MOVLW  BC
4828:  MOVWF  xBB
482A:  CLRF   xBE
482C:  MOVFF  146,ABD
4830:  MOVLB  0
4832:  CALL   3A4C
4836:  MOVFF  02,03
483A:  MOVF   xFC,W
483C:  SUBWF  02,W
483E:  BNC   484E
4840:  BNZ   4848
4842:  MOVF   01,W
4844:  SUBWF  xFB,W
4846:  BC    484E
4848:  INCF   xFB,F
484A:  BTFSC  FD8.2
484C:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
484E:  MOVLW  02
4850:  MOVLB  A
4852:  MOVWF  xBC
4854:  MOVLW  BC
4856:  MOVWF  xBB
4858:  CLRF   xBE
485A:  MOVFF  146,ABD
485E:  MOVLB  0
4860:  CALL   3A4C
4864:  MOVFF  02,03
4868:  MOVF   01,W
486A:  SUBWF  xFB,W
486C:  BNZ   4944
486E:  MOVF   03,W
4870:  SUBWF  xFC,W
4872:  BNZ   4944
....................   { 
....................       charac_timeout++; 
4874:  INCF   xFB,F
4876:  BTFSC  FD8.2
4878:  INCF   xFC,F
....................       buf=get_countcard(); 
487A:  CALL   39FC
487E:  MOVFF  02,AB4
4882:  MOVFF  01,AB3
....................       if(buf<countcards) 
4886:  MOVLB  A
4888:  MOVF   xB4,W
488A:  SUBLW  01
488C:  BNC   48B4
488E:  BNZ   4896
4890:  MOVF   xB3,W
4892:  SUBLW  5D
4894:  BNC   48B4
....................       { 
....................          save_key_new(); 
4896:  MOVLB  0
4898:  BRA    4494
....................          buf=buf+1; 
489A:  MOVLW  01
489C:  MOVLB  A
489E:  ADDWF  xB3,F
48A0:  MOVLW  00
48A2:  ADDWFC xB4,F
....................          save_coutcard(buf); 
48A4:  MOVFF  AB4,AB7
48A8:  MOVFF  AB3,AB6
48AC:  MOVLB  0
48AE:  RCALL  45E4
....................       } 
....................          else 
48B0:  BRA    48E6
48B2:  MOVLB  A
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
48B4:  MOVLW  5A
48B6:  MOVWF  FF6
48B8:  MOVLW  49
48BA:  MOVWF  FF7
48BC:  MOVLB  0
48BE:  CALL   07A0
....................             #if defined(SIM900) 
....................                //SIM_state=autosending; 
....................                SIM_state=SIM_reply;   
48C2:  MOVLW  0E
48C4:  MOVLB  4
48C6:  MOVWF  x95
....................                strcpy(reply_buffer,"Full memory, please format memory"); 
48C8:  MOVLW  03
48CA:  MOVWF  FEA
48CC:  MOVLW  48
48CE:  MOVWF  FE9
48D0:  MOVLW  00
48D2:  MOVLB  0
48D4:  CALL   017C
48D8:  TBLRD*-
48DA:  TBLRD*+
48DC:  MOVF   FF5,W
48DE:  MOVWF  FEE
48E0:  IORLW  00
48E2:  BNZ   48DA
....................             #endif 
....................             return; 
48E4:  BRA    4944
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
48E6:  MOVLW  6A
48E8:  MOVWF  FF6
48EA:  MOVLW  49
48EC:  MOVWF  FF7
48EE:  CALL   07A0
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
48F2:  MOVLW  7A
48F4:  MOVWF  FF6
48F6:  MOVLW  49
48F8:  MOVWF  FF7
48FA:  MOVLW  14
48FC:  MOVLB  A
48FE:  MOVWF  xD3
4900:  MOVLB  0
4902:  CALL   1718
4906:  MOVLW  10
4908:  MOVWF  FE9
490A:  MOVFF  AB4,AB7
490E:  MOVFF  AB3,AB6
4912:  BRA    461E
4914:  MOVLW  91
4916:  MOVWF  FF6
4918:  MOVLW  49
491A:  MOVWF  FF7
491C:  MOVLW  03
491E:  MOVLB  A
4920:  MOVWF  xD3
4922:  MOVLB  0
4924:  CALL   1718
....................       data_avai=0; 
4928:  MOVLB  9
492A:  CLRF   xAA
....................       enable_getpin=0; 
492C:  MOVLB  1
492E:  CLRF   x0C
....................       //dis_getpin; 
....................       output_low(LED); 
4930:  BCF    F92.6
4932:  BCF    F89.6
....................       #if defined(SIM900) 
....................        if(auto_sending==1)SIM_state=autosending; 
4934:  MOVLB  4
4936:  DECFSZ x99,W
4938:  BRA    493E
493A:  MOVLW  0B
493C:  MOVWF  x95
....................        #if defined(twonumber) 
....................             two_number_sending=1; 
493E:  MOVLW  01
4940:  MOVWF  x9F
4942:  MOVLB  0
....................        #endif 
....................       #endif 
....................   } 
....................   //================================= 
....................   //================================= 
.................... } 
.................... //========================= 
4944:  BCF    FF2.2
4946:  GOTO   0084
.................... void main() 
.................... {  
*
6BFA:  CLRF   FF8
6BFC:  BCF    FD0.7
6BFE:  BSF    07.7
6C00:  CLRF   FEA
6C02:  CLRF   FE9
6C04:  BSF    F7E.3
6C06:  MOVLW  40
6C08:  MOVWF  FB0
6C0A:  MOVLW  03
6C0C:  MOVWF  F7F
6C0E:  MOVLW  A6
6C10:  MOVWF  FAD
6C12:  MOVLW  90
6C14:  MOVWF  FAC
6C16:  BCF    F94.0
6C18:  BSF    F8B.0
6C1A:  CLRF   23
6C1C:  CLRF   22
6C1E:  CLRF   21
6C20:  MOVLW  96
6C22:  MOVWF  20
6C24:  CLRF   27
6C26:  CLRF   26
6C28:  MOVLW  AA
6C2A:  MOVWF  25
6C2C:  MOVLW  47
6C2E:  MOVWF  24
6C30:  CLRF   xFA
6C32:  CLRF   xF9
6C34:  SETF   xFC
6C36:  SETF   xFB
6C38:  MOVLW  0E
6C3A:  MOVWF  xFE
6C3C:  MOVLW  01
6C3E:  MOVWF  xFF
6C40:  MOVLB  1
6C42:  MOVWF  x00
6C44:  CLRF   x01
6C46:  CLRF   x02
6C48:  CLRF   x03
6C4A:  CLRF   x04
6C4C:  CLRF   x05
6C4E:  CLRF   x07
6C50:  MOVLW  0A
6C52:  MOVWF  x06
6C54:  MOVLW  03
6C56:  MOVWF  x09
6C58:  MOVLW  E8
6C5A:  MOVWF  x08
6C5C:  CLRF   x0A
6C5E:  CLRF   x0B
6C60:  CLRF   x0C
6C62:  MOVLW  64
6C64:  MOVWF  x0D
6C66:  CLRF   x0E
6C68:  CLRF   x0F
6C6A:  CLRF   x10
6C6C:  CLRF   x12
6C6E:  CLRF   x11
6C70:  CLRF   x13
6C72:  CLRF   x46
6C74:  CLRF   x4B
6C76:  CLRF   xB2
6C78:  CLRF   xB3
6C7A:  CLRF   xB4
6C7C:  CLRF   xB5
6C7E:  CLRF   xB7
6C80:  CLRF   xB6
6C82:  MOVLB  4
6C84:  CLRF   x94
6C86:  CLRF   x93
6C88:  CLRF   x95
6C8A:  CLRF   x96
6C8C:  CLRF   x98
6C8E:  MOVWF  x97
6C90:  CLRF   x99
6C92:  CLRF   x9A
6C94:  CLRF   x9B
6C96:  CLRF   x9C
6C98:  CLRF   x9D
6C9A:  CLRF   x9E
6C9C:  CLRF   x9F
6C9E:  MOVLB  9
6CA0:  CLRF   x98
6CA2:  CLRF   x97
6CA4:  CLRF   x96
6CA6:  CLRF   x95
6CA8:  CLRF   x99
6CAA:  CLRF   x9B
6CAC:  CLRF   x9A
6CAE:  CLRF   x9D
6CB0:  CLRF   x9C
6CB2:  CLRF   x9F
6CB4:  CLRF   x9E
6CB6:  CLRF   xA1
6CB8:  CLRF   xA0
6CBA:  MOVLW  FD
6CBC:  MOVWF  xA3
6CBE:  MOVLW  E8
6CC0:  MOVWF  xA2
6CC2:  CLRF   xA5
6CC4:  CLRF   xA4
6CC6:  CLRF   xA6
6CC8:  CLRF   xA7
6CCA:  CLRF   xA8
6CCC:  CLRF   xA9
6CCE:  CLRF   xAA
6CD0:  CLRF   xAB
6CD2:  CLRF   xAC
6CD4:  CLRF   xAD
6CD6:  CLRF   xAE
6CD8:  CLRF   xB0
6CDA:  MOVLW  01
6CDC:  MOVWF  xAF
6CDE:  CLRF   xB2
6CE0:  CLRF   xB1
6CE2:  CLRF   xB3
6CE4:  CLRF   xB7
6CE6:  CLRF   xB6
6CE8:  CLRF   xB5
6CEA:  CLRF   xB4
6CEC:  MOVLW  FF
6CEE:  MOVLB  F
6CF0:  MOVWF  x48
6CF2:  BCF    FC2.6
6CF4:  BCF    FC2.7
6CF6:  MOVF   x49,W
6CF8:  ANDLW  E0
6CFA:  IORLW  1F
6CFC:  MOVWF  x49
6CFE:  CLRF   FD2
6D00:  CLRF   FD1
6D02:  CLRF   1A
6D04:  CLRF   1B
6D06:  MOVLB  1
6D08:  CLRF   x47
6D0A:  BCF    x48.0
6D0C:  CLRF   x49
6D0E:  CLRF   x4A
6D10:  CLRF   x4C
6D12:  BCF    x48.1
6D14:  CLRF   x4D
6D16:  MOVLB  4
6D18:  CLRF   x79
6D1A:  CLRF   x7A
6D1C:  CLRF   x7B
6D1E:  CLRF   x7C
6D20:  CLRF   x7D
6D22:  CLRF   x7E
6D24:  CLRF   x7F
6D26:  CLRF   x80
6D28:  CLRF   x81
6D2A:  CLRF   x82
6D2C:  CLRF   x83
6D2E:  CLRF   x84
6D30:  CLRF   x85
6D32:  CLRF   x86
6D34:  CLRF   x87
6D36:  CLRF   x88
6D38:  CLRF   x89
6D3A:  CLRF   x8A
6D3C:  CLRF   x8B
6D3E:  CLRF   x8C
6D40:  CLRF   x8D
6D42:  CLRF   x8E
6D44:  CLRF   x8F
6D46:  CLRF   x90
6D48:  CLRF   x91
6D4A:  CLRF   x92
6D4C:  MOVLB  9
6D4E:  CLRF   xC8
6D50:  CLRF   xC9
6D52:  CLRF   xCA
6D54:  CLRF   xCB
6D56:  CLRF   xCC
6D58:  CLRF   xCD
6D5A:  CLRF   xCE
6D5C:  CLRF   xCF
6D5E:  CLRF   xD0
6D60:  CLRF   xD1
6D62:  CLRF   xD4
6D64:  CLRF   xD6
6D66:  CLRF   xD5
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................     RPINR1=5; 
6D68:  MOVLW  05
6D6A:  MOVLB  E
6D6C:  MOVWF  xE7
....................    SIM_state = 0xff; 
6D6E:  MOVLB  4
6D70:  SETF   x95
....................    charac_timeout=0xffffffff; 
6D72:  MOVLB  0
6D74:  SETF   xFC
6D76:  SETF   xFB
....................    key_timeout=0xffff; 
6D78:  MOVLB  1
6D7A:  SETF   x09
6D7C:  SETF   x08
....................    setup_oscillator(OSC_32MHZ); 
6D7E:  MOVLW  70
6D80:  MOVWF  FD3
6D82:  MOVLW  40
6D84:  MOVWF  F9B
6D86:  MOVF   FD3,W
....................    keyprss_off; 
6D88:  BCF    F92.7
6D8A:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
6D8C:  BCF    FF2.6
6D8E:  BCF    FF2.7
6D90:  BTFSC  FF2.7
6D92:  BRA    6D8E
....................    init_ext_eeprom(); 
6D94:  MOVLB  0
6D96:  GOTO   5060
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
6D9A:  MOVLW  04
6D9C:  MOVLB  A
6D9E:  MOVWF  x8E
6DA0:  CLRF   19
6DA2:  BTFSC  FF2.7
6DA4:  BSF    19.7
6DA6:  BCF    FF2.7
6DA8:  MOVLW  FA
6DAA:  MOVWF  xBC
6DAC:  MOVLB  0
6DAE:  CALL   1984
6DB2:  BTFSC  19.7
6DB4:  BSF    FF2.7
6DB6:  MOVLB  A
6DB8:  DECFSZ x8E,F
6DBA:  BRA    6DA0
....................    init_password(); 
6DBC:  MOVLB  0
6DBE:  CALL   5116
....................    EEPROM_read(strobe_pass_addr,20,password); 
6DC2:  MOVLB  A
6DC4:  CLRF   x8E
6DC6:  MOVLW  14
6DC8:  MOVWF  x8F
6DCA:  CLRF   x91
6DCC:  MOVLW  55
6DCE:  MOVWF  x90
6DD0:  MOVLB  0
6DD2:  CALL   506A
6DD6:  CLRF   19
6DD8:  BTFSC  FF2.7
6DDA:  BSF    19.7
6DDC:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
6DDE:  MOVLB  A
6DE0:  CLRF   xC0
6DE2:  MOVLW  7F
6DE4:  MOVWF  xBF
6DE6:  MOVLB  0
6DE8:  CALL   3954
6DEC:  BTFSC  19.7
6DEE:  BSF    FF2.7
6DF0:  MOVFF  01,10F
....................    //===================================== 
....................    rtc_init(); 
6DF4:  GOTO   5184
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
6DF8:  MOVLW  19
6DFA:  MOVLB  A
6DFC:  MOVWF  x8E
6DFE:  MOVLB  0
6E00:  CALL   529A
6E04:  MOVFF  03,23
6E08:  MOVFF  02,22
6E0C:  MOVFF  01,21
6E10:  MOVFF  00,20
....................     
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
6E14:  MOVLW  1E
6E16:  MOVLB  A
6E18:  MOVWF  x8E
6E1A:  MOVLB  0
6E1C:  CALL   529A
6E20:  MOVFF  03,27
6E24:  MOVFF  02,26
6E28:  MOVFF  01,25
6E2C:  MOVFF  00,24
6E30:  CLRF   19
6E32:  BTFSC  FF2.7
6E34:  BSF    19.7
6E36:  BCF    FF2.7
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card_key); 
....................    countcard=get_countcard(); 
6E38:  CALL   39FC
6E3C:  BTFSC  19.7
6E3E:  BSF    FF2.7
6E40:  MOVFF  02,FA
6E44:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
6E48:  SETF   xFC
6E4A:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
6E4C:  MOVLW  C7
6E4E:  MOVWF  FD5
6E50:  CLRF   19
6E52:  BTFSC  FF2.7
6E54:  BSF    19.7
6E56:  BCF    FF2.7
....................    //setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
6E58:  MOVLB  A
6E5A:  CLRF   xC0
6E5C:  MOVLW  94
6E5E:  MOVWF  xBF
6E60:  MOVLB  0
6E62:  CALL   3954
6E66:  BTFSC  19.7
6E68:  BSF    FF2.7
6E6A:  MOVFF  01,146
....................    if(delaycharaction==0)delaycharaction=1; 
6E6E:  MOVLB  1
6E70:  MOVF   x46,F
6E72:  BNZ   6E78
6E74:  MOVLW  01
6E76:  MOVWF  x46
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
6E78:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
6E7A:  BSF    FF0.3
6E7C:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
6E7E:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
6E80:  MOVLW  C0
6E82:  IORWF  FF2,F
....................    //========================================== 
....................    //delay_ms(100); 
....................    //EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................    //reset_password(); 
....................    //init_password(); 
....................    //fprintf(COM2,"Start\r\n"); 
....................    mcr_timeout=10000; 
6E84:  MOVLB  9
6E86:  CLRF   x98
6E88:  CLRF   x97
6E8A:  MOVLW  27
6E8C:  MOVWF  x96
6E8E:  MOVLW  10
6E90:  MOVWF  x95
6E92:  CLRF   19
6E94:  BTFSC  FF2.7
6E96:  BSF    19.7
6E98:  BCF    FF2.7
....................    //EEPROM_read(strobe_pass_addr,20,password); 
....................    //========================================== 
....................    //write_ext_eeprom(strobe_Master_SLV,1); 
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6E9A:  MOVLB  A
6E9C:  CLRF   xC0
6E9E:  MOVLW  91
6EA0:  MOVWF  xBF
6EA2:  MOVLB  0
6EA4:  CALL   3954
6EA8:  BTFSC  19.7
6EAA:  BSF    FF2.7
6EAC:  MOVFF  01,9B3
6EB0:  CLRF   19
6EB2:  BTFSC  FF2.7
6EB4:  BSF    19.7
6EB6:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
6EB8:  MOVLB  A
6EBA:  CLRF   xC0
6EBC:  MOVLW  92
6EBE:  MOVWF  xBF
6EC0:  MOVLB  0
6EC2:  CALL   3954
6EC6:  BTFSC  19.7
6EC8:  BSF    FF2.7
6ECA:  MOVFF  01,9A7
....................     key_timeout=1000; 
6ECE:  MOVLW  03
6ED0:  MOVLB  1
6ED2:  MOVWF  x09
6ED4:  MOVLW  E8
6ED6:  MOVWF  x08
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
6ED8:  MOVLB  0
6EDA:  SETF   xFC
6EDC:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    #if defined(SIM900) 
....................       disable_interrupts(GLOBAL); 
6EDE:  BCF    FF2.6
6EE0:  BCF    FF2.7
6EE2:  BTFSC  FF2.7
6EE4:  BRA    6EE0
....................       output_high(rst_sim); 
6EE6:  BCF    F94.1
6EE8:  BSF    F8B.1
....................       //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................       //output_low(PIN_C7); 
....................       //set_tris_c(0); 
....................       #ASM 
....................          BCF    0xF94.7 
6EEA:  BCF    F94.7
....................       #ENDASM 
....................       SIM_state = 0xff; 
6EEC:  MOVLB  4
6EEE:  SETF   x95
....................       fprintf(COM2,"\r\nbooting...\r\n"); 
6EF0:  MOVLW  96
6EF2:  MOVWF  FF6
6EF4:  MOVLW  49
6EF6:  MOVWF  FF7
6EF8:  CLRF   19
6EFA:  BTFSC  FF2.7
6EFC:  BSF    19.7
6EFE:  BCF    FF2.7
6F00:  MOVLB  0
6F02:  CALL   07A0
6F06:  BTFSC  19.7
6F08:  BSF    FF2.7
....................       delay_ms(10000); 
6F0A:  MOVLW  28
6F0C:  MOVLB  A
6F0E:  MOVWF  x8E
6F10:  CLRF   19
6F12:  BTFSC  FF2.7
6F14:  BSF    19.7
6F16:  BCF    FF2.7
6F18:  MOVLW  FA
6F1A:  MOVWF  xBC
6F1C:  MOVLB  0
6F1E:  CALL   1984
6F22:  BTFSC  19.7
6F24:  BSF    FF2.7
6F26:  MOVLB  A
6F28:  DECFSZ x8E,F
6F2A:  BRA    6F10
....................       receiver_state=1; 
6F2C:  MOVLW  01
6F2E:  MOVLB  1
6F30:  MOVWF  xB4
....................       fprintf(COM1,"AT\r\n"); 
6F32:  MOVLW  A6
6F34:  MOVWF  FF6
6F36:  MOVLW  49
6F38:  MOVWF  FF7
6F3A:  MOVLB  0
6F3C:  CALL   53D8
....................       delay_ms(1000); 
6F40:  MOVLW  04
6F42:  MOVLB  A
6F44:  MOVWF  x8E
6F46:  CLRF   19
6F48:  BTFSC  FF2.7
6F4A:  BSF    19.7
6F4C:  BCF    FF2.7
6F4E:  MOVLW  FA
6F50:  MOVWF  xBC
6F52:  MOVLB  0
6F54:  CALL   1984
6F58:  BTFSC  19.7
6F5A:  BSF    FF2.7
6F5C:  MOVLB  A
6F5E:  DECFSZ x8E,F
6F60:  BRA    6F46
....................       fprintf(COM1,"AT+CMGF=1\r\n"); 
6F62:  MOVLW  AC
6F64:  MOVWF  FF6
6F66:  MOVLW  49
6F68:  MOVWF  FF7
6F6A:  MOVLB  0
6F6C:  CALL   53D8
....................       delay_ms(1000); 
6F70:  MOVLW  04
6F72:  MOVLB  A
6F74:  MOVWF  x8E
6F76:  CLRF   19
6F78:  BTFSC  FF2.7
6F7A:  BSF    19.7
6F7C:  BCF    FF2.7
6F7E:  MOVLW  FA
6F80:  MOVWF  xBC
6F82:  MOVLB  0
6F84:  CALL   1984
6F88:  BTFSC  19.7
6F8A:  BSF    FF2.7
6F8C:  MOVLB  A
6F8E:  DECFSZ x8E,F
6F90:  BRA    6F76
....................       //sim900_init(); 
....................       EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
6F92:  MOVLW  55
6F94:  MOVWF  x8E
6F96:  MOVLW  14
6F98:  MOVWF  x8F
6F9A:  MOVLW  04
6F9C:  MOVWF  x91
6F9E:  MOVLW  79
6FA0:  MOVWF  x90
6FA2:  MOVLB  0
6FA4:  CALL   506A
....................       fprintf(COM1,"AT+CSMP=17,167,0,245\r\n"); 
6FA8:  MOVLW  B8
6FAA:  MOVWF  FF6
6FAC:  MOVLW  49
6FAE:  MOVWF  FF7
6FB0:  CALL   53D8
....................       delay_ms(1000); 
6FB4:  MOVLW  04
6FB6:  MOVLB  A
6FB8:  MOVWF  x8E
6FBA:  CLRF   19
6FBC:  BTFSC  FF2.7
6FBE:  BSF    19.7
6FC0:  BCF    FF2.7
6FC2:  MOVLW  FA
6FC4:  MOVWF  xBC
6FC6:  MOVLB  0
6FC8:  CALL   1984
6FCC:  BTFSC  19.7
6FCE:  BSF    FF2.7
6FD0:  MOVLB  A
6FD2:  DECFSZ x8E,F
6FD4:  BRA    6FBA
....................       fprintf(COM1,"AT+CMGD=1\r\n");  
6FD6:  MOVLW  D0
6FD8:  MOVWF  FF6
6FDA:  MOVLW  49
6FDC:  MOVWF  FF7
6FDE:  MOVLB  0
6FE0:  CALL   53D8
....................       delay_ms(1000); 
6FE4:  MOVLW  04
6FE6:  MOVLB  A
6FE8:  MOVWF  x8E
6FEA:  CLRF   19
6FEC:  BTFSC  FF2.7
6FEE:  BSF    19.7
6FF0:  BCF    FF2.7
6FF2:  MOVLW  FA
6FF4:  MOVWF  xBC
6FF6:  MOVLB  0
6FF8:  CALL   1984
6FFC:  BTFSC  19.7
6FFE:  BSF    FF2.7
7000:  MOVLB  A
7002:  DECFSZ x8E,F
7004:  BRA    6FEA
....................       fprintf(COM1,"AT+CMGD=2\r\n"); 
7006:  MOVLW  DC
7008:  MOVWF  FF6
700A:  MOVLW  49
700C:  MOVWF  FF7
700E:  MOVLB  0
7010:  CALL   53D8
....................       delay_ms(1000); 
7014:  MOVLW  04
7016:  MOVLB  A
7018:  MOVWF  x8E
701A:  CLRF   19
701C:  BTFSC  FF2.7
701E:  BSF    19.7
7020:  BCF    FF2.7
7022:  MOVLW  FA
7024:  MOVWF  xBC
7026:  MOVLB  0
7028:  CALL   1984
702C:  BTFSC  19.7
702E:  BSF    FF2.7
7030:  MOVLB  A
7032:  DECFSZ x8E,F
7034:  BRA    701A
....................       fprintf(COM1,"AT+CMGD=3\r\n"); 
7036:  MOVLW  E8
7038:  MOVWF  FF6
703A:  MOVLW  49
703C:  MOVWF  FF7
703E:  MOVLB  0
7040:  CALL   53D8
....................       delay_ms(1000); 
7044:  MOVLW  04
7046:  MOVLB  A
7048:  MOVWF  x8E
704A:  CLRF   19
704C:  BTFSC  FF2.7
704E:  BSF    19.7
7050:  BCF    FF2.7
7052:  MOVLW  FA
7054:  MOVWF  xBC
7056:  MOVLB  0
7058:  CALL   1984
705C:  BTFSC  19.7
705E:  BSF    FF2.7
7060:  MOVLB  A
7062:  DECFSZ x8E,F
7064:  BRA    704A
....................       fprintf(COM1,"AT+CMGD=4\r\n"); 
7066:  MOVLW  F4
7068:  MOVWF  FF6
706A:  MOVLW  49
706C:  MOVWF  FF7
706E:  MOVLB  0
7070:  CALL   53D8
....................       delay_ms(1000); 
7074:  MOVLW  04
7076:  MOVLB  A
7078:  MOVWF  x8E
707A:  CLRF   19
707C:  BTFSC  FF2.7
707E:  BSF    19.7
7080:  BCF    FF2.7
7082:  MOVLW  FA
7084:  MOVWF  xBC
7086:  MOVLB  0
7088:  CALL   1984
708C:  BTFSC  19.7
708E:  BSF    FF2.7
7090:  MOVLB  A
7092:  DECFSZ x8E,F
7094:  BRA    707A
....................       fprintf(COM1,"AT+CMGD=5\r\n");  
7096:  MOVLW  00
7098:  MOVWF  FF6
709A:  MOVLW  4A
709C:  MOVWF  FF7
709E:  MOVLB  0
70A0:  CALL   53D8
....................       output_high(LED); 
70A4:  BCF    F92.6
70A6:  BSF    F89.6
....................       delay_ms(1000); 
70A8:  MOVLW  04
70AA:  MOVLB  A
70AC:  MOVWF  x8E
70AE:  CLRF   19
70B0:  BTFSC  FF2.7
70B2:  BSF    19.7
70B4:  BCF    FF2.7
70B6:  MOVLW  FA
70B8:  MOVWF  xBC
70BA:  MOVLB  0
70BC:  CALL   1984
70C0:  BTFSC  19.7
70C2:  BSF    FF2.7
70C4:  MOVLB  A
70C6:  DECFSZ x8E,F
70C8:  BRA    70AE
....................       SIM_state= idle; 
70CA:  MOVLW  0C
70CC:  MOVLB  4
70CE:  MOVWF  x95
....................       #ASM 
....................          BSF    0xF94.7 
70D0:  BSF    F94.7
....................       #ENDASM 
....................       //set_tris_c(0xff); 
....................       //setup_wdt(WDT_ON); 
....................       enable_interrupts(GLOBAL); 
70D2:  MOVLW  C0
70D4:  IORWF  FF2,F
....................    #endif 
....................    booting_done=1; 
70D6:  MOVLW  01
70D8:  MOVLB  1
70DA:  MOVWF  xB5
....................    booting=1; 
70DC:  MOVWF  x05
....................    charac_timeout=0xffffffff; 
70DE:  MOVLB  0
70E0:  SETF   xFC
70E2:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
70E4:  MOVLW  66
70E6:  MOVLB  A
70E8:  MOVWF  x8E
70EA:  MOVLW  10
70EC:  MOVWF  x8F
70EE:  MOVLW  09
70F0:  MOVWF  x91
70F2:  MOVLW  B8
70F4:  MOVWF  x90
70F6:  MOVLB  0
70F8:  CALL   506A
....................    EEPROM_read(strobe_pass_addr,20,password); 
70FC:  MOVLB  A
70FE:  CLRF   x8E
7100:  MOVLW  14
7102:  MOVWF  x8F
7104:  CLRF   x91
7106:  MOVLW  55
7108:  MOVWF  x90
710A:  MOVLB  0
710C:  CALL   506A
....................    set_tris_a(0xff);  
7110:  MOVLW  FF
7112:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
7114:  MOVLW  E0
7116:  MOVLB  F
7118:  MOVWF  x48
711A:  BCF    FC2.6
711C:  BCF    FC2.7
711E:  MOVF   x49,W
7120:  ANDLW  E0
7122:  IORLW  1F
7124:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
7126:  MOVF   FC1,W
7128:  ANDLW  C0
712A:  IORLW  03
712C:  MOVWF  FC1
712E:  BCF    FC1.7
7130:  BSF    FC2.0
7132:  BSF    FC1.6
7134:  BSF    FC2.1
7136:  BTFSC  FC2.1
7138:  BRA    7136
713A:  BCF    FC1.6
713C:  CLRF   19
713E:  BTFSC  FF2.7
7140:  BSF    19.7
7142:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
7144:  MOVLB  A
7146:  CLRF   xC0
7148:  MOVLW  7F
714A:  MOVWF  xBF
714C:  MOVLB  0
714E:  CALL   3954
7152:  BTFSC  19.7
7154:  BSF    FF2.7
7156:  MOVFF  01,10F
715A:  CLRF   19
715C:  BTFSC  FF2.7
715E:  BSF    19.7
7160:  BCF    FF2.7
....................    type_KB=read_ext_eeprom(kindofKB); 
7162:  MOVLB  A
7164:  CLRF   xC0
7166:  MOVLW  7E
7168:  MOVWF  xBF
716A:  MOVLB  0
716C:  CALL   3954
7170:  BTFSC  19.7
7172:  BSF    FF2.7
7174:  MOVFF  01,113
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
7178:  MOVLB  1
717A:  MOVF   x13,F
717C:  BZ    719C
717E:  MOVLW  0C
7180:  MOVWF  FF6
7182:  MOVLW  4A
7184:  MOVWF  FF7
7186:  CLRF   19
7188:  BTFSC  FF2.7
718A:  BSF    19.7
718C:  BCF    FF2.7
718E:  MOVLB  0
7190:  CALL   07A0
7194:  BTFSC  19.7
7196:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
7198:  BRA    71B6
719A:  MOVLB  1
719C:  MOVLW  20
719E:  MOVWF  FF6
71A0:  MOVLW  4A
71A2:  MOVWF  FF7
71A4:  CLRF   19
71A6:  BTFSC  FF2.7
71A8:  BSF    19.7
71AA:  BCF    FF2.7
71AC:  MOVLB  0
71AE:  CALL   07A0
71B2:  BTFSC  19.7
71B4:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
71B6:  MOVLB  9
71B8:  MOVF   xB3,F
71BA:  BNZ   71DA
71BC:  MOVLW  34
71BE:  MOVWF  FF6
71C0:  MOVLW  4A
71C2:  MOVWF  FF7
71C4:  CLRF   19
71C6:  BTFSC  FF2.7
71C8:  BSF    19.7
71CA:  BCF    FF2.7
71CC:  MOVLB  0
71CE:  CALL   07A0
71D2:  BTFSC  19.7
71D4:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
71D6:  BRA    71F4
71D8:  MOVLB  9
71DA:  MOVLW  4E
71DC:  MOVWF  FF6
71DE:  MOVLW  4A
71E0:  MOVWF  FF7
71E2:  CLRF   19
71E4:  BTFSC  FF2.7
71E6:  BSF    19.7
71E8:  BCF    FF2.7
71EA:  MOVLB  0
71EC:  CALL   07A0
71F0:  BTFSC  19.7
71F2:  BSF    FF2.7
....................     
....................    #if defined(SIM900) 
....................       #if defined(twonumber) 
....................          fprintf(COM2,"two numbers mode ver\n\r"); 
71F4:  MOVLW  66
71F6:  MOVWF  FF6
71F8:  MOVLW  4A
71FA:  MOVWF  FF7
71FC:  CLRF   19
71FE:  BTFSC  FF2.7
7200:  BSF    19.7
7202:  BCF    FF2.7
7204:  CALL   07A0
7208:  BTFSC  19.7
720A:  BSF    FF2.7
720C:  CLRF   19
720E:  BTFSC  FF2.7
7210:  BSF    19.7
7212:  BCF    FF2.7
....................          #else    
....................             fprintf(COM2,"one numbers mode ver\n\r"); 
....................       #endif 
....................       //twonumber=read_ext_eeprom(strobe_two_number); 
....................       auto_sending=read_ext_eeprom(strobe_autosending);   
7214:  MOVLB  A
7216:  CLRF   xC0
7218:  MOVLW  93
721A:  MOVWF  xBF
721C:  MOVLB  0
721E:  CALL   3954
7222:  BTFSC  19.7
7224:  BSF    FF2.7
7226:  MOVFF  01,499
....................       if(auto_sending==0)fprintf(COM2,"autosending is disable\n\r"); 
722A:  MOVLB  4
722C:  MOVF   x99,F
722E:  BNZ   724E
7230:  MOVLW  7E
7232:  MOVWF  FF6
7234:  MOVLW  4A
7236:  MOVWF  FF7
7238:  CLRF   19
723A:  BTFSC  FF2.7
723C:  BSF    19.7
723E:  BCF    FF2.7
7240:  MOVLB  0
7242:  CALL   07A0
7246:  BTFSC  19.7
7248:  BSF    FF2.7
....................          else fprintf(COM2,"autosending is enable\n\r"); 
724A:  BRA    7268
724C:  MOVLB  4
724E:  MOVLW  98
7250:  MOVWF  FF6
7252:  MOVLW  4A
7254:  MOVWF  FF7
7256:  CLRF   19
7258:  BTFSC  FF2.7
725A:  BSF    19.7
725C:  BCF    FF2.7
725E:  MOVLB  0
7260:  CALL   07A0
7264:  BTFSC  19.7
7266:  BSF    FF2.7
....................    #endif 
....................    memset(reply_buffer,0,sizeof(reply_buffer));  
7268:  MOVLW  03
726A:  MOVWF  FEA
726C:  MOVLW  48
726E:  MOVWF  FE9
7270:  CLRF   00
7272:  MOVLW  01
7274:  MOVWF  02
7276:  MOVLW  18
7278:  MOVWF  01
727A:  CALL   447A
....................    memset(msg_data_sending,0,sizeof(msg_data_sending));  
727E:  MOVLW  01
7280:  MOVWF  FEA
7282:  MOVLW  B8
7284:  MOVWF  FE9
7286:  CLRF   00
7288:  MOVLW  01
728A:  MOVWF  02
728C:  MOVLW  18
728E:  MOVWF  01
7290:  CALL   447A
....................     
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     
....................    while(1) 
....................    { 
....................      #if defined(SIM900) 
....................       count_polling++; 
7294:  MOVLB  4
7296:  INCF   x93,F
7298:  BTFSC  FD8.2
729A:  INCF   x94,F
....................       if(count_polling>=timing_wait) 
729C:  MOVF   x98,W
729E:  SUBWF  x94,W
72A0:  BTFSS  FD8.0
72A2:  GOTO   9918
72A6:  BNZ   72B2
72A8:  MOVF   x97,W
72AA:  SUBWF  x93,W
72AC:  BTFSS  FD8.0
72AE:  GOTO   9918
....................       { 
....................          count_polling=0; 
72B2:  CLRF   x94
72B4:  CLRF   x93
....................          //fprintf(COM2,"SIM_state %d\n\r",SIM_state); 
....................          switch(SIM_state) 
....................          { 
72B6:  MOVF   x95,W
72B8:  ADDLW  EB
72BA:  BTFSC  FD8.0
72BC:  GOTO   9918
72C0:  ADDLW  15
72C2:  MOVLB  0
72C4:  GOTO   9942
....................             case config_sms: 
....................                receiver_state=1; 
72C8:  MOVLW  01
72CA:  MOVLB  1
72CC:  MOVWF  xB4
....................                //fprintf(COM2,"AT+CMGF=1...\n\r"); 
....................                fprintf(COM1,"AT+CMGF=1\r\n"); 
72CE:  MOVLW  B0
72D0:  MOVWF  FF6
72D2:  MOVLW  4A
72D4:  MOVWF  FF7
72D6:  MOVLB  0
72D8:  CALL   53D8
....................                SIM_state=reading_sms_cmd; 
72DC:  MOVLW  01
72DE:  MOVLB  4
72E0:  MOVWF  x95
....................                timing_wait=1000; 
72E2:  MOVLW  03
72E4:  MOVWF  x98
72E6:  MOVLW  E8
72E8:  MOVWF  x97
....................             break; 
72EA:  GOTO   9918
....................             case reading_sms_cmd:     
....................                booting_done=1; 
72EE:  MOVLW  01
72F0:  MOVLB  1
72F2:  MOVWF  xB5
72F4:  CLRF   19
72F6:  BTFSC  FF2.7
72F8:  BSF    19.7
72FA:  BCF    FF2.7
....................                cards=get_countcard(); 
72FC:  MOVLB  0
72FE:  CALL   39FC
7302:  BTFSC  19.7
7304:  BSF    FF2.7
7306:  MOVFF  02,9CB
730A:  MOVFF  01,9CA
....................                receiver_state=1; 
730E:  MOVLW  01
7310:  MOVLB  1
7312:  MOVWF  xB4
....................                memset(buffer_uart,0,sizeof(buffer_uart));  
7314:  MOVWF  FEA
7316:  MOVLW  4E
7318:  MOVWF  FE9
731A:  CLRF   00
731C:  CLRF   02
731E:  MOVLW  64
7320:  MOVWF  01
7322:  MOVLB  0
7324:  CALL   447A
....................                memset(mobilenumb,0,sizeof(mobilenumb));  
7328:  MOVLW  04
732A:  MOVWF  FEA
732C:  MOVLW  79
732E:  MOVWF  FE9
7330:  CLRF   00
7332:  CLRF   02
7334:  MOVLW  1A
7336:  MOVWF  01
7338:  CALL   447A
....................                memset(msg_buffer2,0,sizeof(msg_buffer2));                               
733C:  MOVLW  03
733E:  MOVWF  FEA
7340:  MOVLW  16
7342:  MOVWF  FE9
7344:  CLRF   00
7346:  CLRF   02
7348:  MOVLW  32
734A:  MOVWF  01
734C:  CALL   447A
....................                fprintf(COM2,"reading_sms...\n\r"); 
7350:  MOVLW  BC
7352:  MOVWF  FF6
7354:  MOVLW  4A
7356:  MOVWF  FF7
7358:  CLRF   19
735A:  BTFSC  FF2.7
735C:  BSF    19.7
735E:  BCF    FF2.7
7360:  CALL   07A0
7364:  BTFSC  19.7
7366:  BSF    FF2.7
....................                #ASM BCF    0xF94.7 #ENDASM                   
7368:  BCF    F94.7
....................                   fprintf(COM1,"AT+CMGR=1\r\n"); 
736A:  MOVLW  CE
736C:  MOVWF  FF6
736E:  MOVLW  4A
7370:  MOVWF  FF7
7372:  CALL   53D8
....................                #ASM BSF    0xF94.7 #ENDASM 
7376:  BSF    F94.7
....................                //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................                SIM_state=MSG_avai; 
7378:  MOVLW  02
737A:  MOVLB  4
737C:  MOVWF  x95
....................                UART_index=0; 
737E:  MOVLB  1
7380:  CLRF   xB2
....................                timing_wait=5000; 
7382:  MOVLW  13
7384:  MOVLB  4
7386:  MOVWF  x98
7388:  MOVLW  88
738A:  MOVWF  x97
....................                //fprintf(COM2,"device has %lu charactions\n\r",cards); 
....................             break; 
738C:  GOTO   9918
....................             case MSG_avai: 
....................                //fprintf(COM2,"MSG_avai...\n\r"); 
....................                //temp=checking_msg_avai(); 
....................                fprintf(COM2,"MSG_avai...%d\n\r",temp); 
7390:  MOVLW  DA
7392:  MOVWF  FF6
7394:  MOVLW  4A
7396:  MOVWF  FF7
7398:  CLRF   19
739A:  BTFSC  FF2.7
739C:  BSF    19.7
739E:  BCF    FF2.7
73A0:  MOVLW  0B
73A2:  MOVLB  A
73A4:  MOVWF  xD3
73A6:  MOVLB  0
73A8:  CALL   1718
73AC:  BTFSC  19.7
73AE:  BSF    FF2.7
73B0:  CLRF   19
73B2:  BTFSC  FF2.7
73B4:  BSF    19.7
73B6:  BCF    FF2.7
73B8:  MOVFF  9D3,ABF
73BC:  MOVLW  18
73BE:  MOVLB  A
73C0:  MOVWF  xC0
73C2:  MOVLB  0
73C4:  CALL   182C
73C8:  BTFSC  19.7
73CA:  BSF    FF2.7
73CC:  CLRF   19
73CE:  BTFSC  FF2.7
73D0:  BSF    19.7
73D2:  BCF    FF2.7
73D4:  MOVLW  0A
73D6:  MOVLB  A
73D8:  MOVWF  xDF
73DA:  MOVLB  0
73DC:  CALL   075A
73E0:  BTFSC  19.7
73E2:  BSF    FF2.7
73E4:  CLRF   19
73E6:  BTFSC  FF2.7
73E8:  BSF    19.7
73EA:  BCF    FF2.7
73EC:  MOVLW  0D
73EE:  MOVLB  A
73F0:  MOVWF  xDF
73F2:  MOVLB  0
73F4:  CALL   075A
73F8:  BTFSC  19.7
73FA:  BSF    FF2.7
....................                //if(temp==1) SIM_state=reading_sms_cmd; 
....................                /*for(i=0;i<100;i++) 
....................                { 
....................                   fprintf(COM2,"%c",buffer_uart[i]);  
....................                }*/ 
....................                SIM_state=analyze_sms;  
73FC:  MOVLW  03
73FE:  MOVLB  4
7400:  MOVWF  x95
....................                //fprintf(COM2,"\r\ntemp=%d\r\n",temp); 
....................                //timing_wait=2000; 
....................             break; 
7402:  GOTO   9918
....................             case analyze_sms: 
....................                fprintf(COM2,"analyze_sms...\n\r");  
7406:  MOVLW  EA
7408:  MOVWF  FF6
740A:  MOVLW  4A
740C:  MOVWF  FF7
740E:  CLRF   19
7410:  BTFSC  FF2.7
7412:  BSF    19.7
7414:  BCF    FF2.7
7416:  CALL   07A0
741A:  BTFSC  19.7
741C:  BSF    FF2.7
741E:  CLRF   19
7420:  BTFSC  FF2.7
7422:  BSF    19.7
7424:  BCF    FF2.7
....................                del_buf(20,msg_buffer1); 
7426:  MOVLW  14
7428:  MOVLB  A
742A:  MOVWF  xC5
742C:  MOVLW  03
742E:  MOVWF  xC7
7430:  MOVLW  02
7432:  MOVWF  xC6
7434:  MOVLB  0
7436:  CALL   3A6E
743A:  BTFSC  19.7
743C:  BSF    FF2.7
743E:  CLRF   19
7440:  BTFSC  FF2.7
7442:  BSF    19.7
7444:  BCF    FF2.7
....................                del_buf(50,msg_buffer2); 
7446:  MOVLW  32
7448:  MOVLB  A
744A:  MOVWF  xC5
744C:  MOVLW  03
744E:  MOVWF  xC7
7450:  MOVLW  16
7452:  MOVWF  xC6
7454:  MOVLB  0
7456:  CALL   3A6E
745A:  BTFSC  19.7
745C:  BSF    FF2.7
745E:  CLRF   19
7460:  BTFSC  FF2.7
7462:  BSF    19.7
7464:  BCF    FF2.7
....................                del_buf(50,sim_bug); 
7466:  MOVLW  32
7468:  MOVLB  A
746A:  MOVWF  xC5
746C:  MOVLW  02
746E:  MOVWF  xC7
7470:  MOVLW  D0
7472:  MOVWF  xC6
7474:  MOVLB  0
7476:  CALL   3A6E
747A:  BTFSC  19.7
747C:  BSF    FF2.7
....................                //memset(msg_buffer1,0,sizeof(msg_buffer1)); 
....................                //memset(msg_buffer2,0,sizeof(msg_buffer2)); 
....................                //memset(sim_bug,0,sizeof(sim_bug)); 
....................                analyzing_msg(sim_bug,mobilenumb); 
747E:  MOVLW  02
7480:  MOVLB  A
7482:  MOVWF  x8F
7484:  MOVLW  D0
7486:  MOVWF  x8E
7488:  MOVLW  04
748A:  MOVWF  x91
748C:  MOVLW  79
748E:  MOVWF  x90
7490:  MOVLB  0
7492:  GOTO   53FA
....................                /*for(i=0;i<25;i++) 
....................                { 
....................                   fprintf(COM2,"%d",sim_bug[i]); 
....................                }*/ 
....................                 
....................                memset(buffer_uart,0,sizeof(buffer_uart));  
7496:  MOVLW  01
7498:  MOVWF  FEA
749A:  MOVLW  4E
749C:  MOVWF  FE9
749E:  CLRF   00
74A0:  CLRF   02
74A2:  MOVLW  64
74A4:  MOVWF  01
74A6:  CALL   447A
....................                #if defined(twonumber)  
....................                   SIM_state=checking_MN0; 
74AA:  MOVLW  12
74AC:  MOVLB  4
74AE:  MOVWF  x95
....................                   #else SIM_state=checking_MN; 
....................                #endif     
....................                if((mobilenumb[0]==0)&&(mobilenumb[1]==0)&&(mobilenumb[2]==0)&&(mobilenumb[3]==0)&&(mobilenumb[4]==0)) 
74B0:  MOVF   x79,F
74B2:  BNZ   74EA
74B4:  MOVF   x7A,F
74B6:  BNZ   74EA
74B8:  MOVF   x7B,F
74BA:  BNZ   74EA
74BC:  MOVF   x7C,F
74BE:  BNZ   74EA
74C0:  MOVF   x7D,F
74C2:  BNZ   74EA
....................                { 
....................                   SIM_state= delete_MSG; 
74C4:  MOVLW  06
74C6:  MOVWF  x95
....................                   //SIM_state=config_sms; 
....................                   output_low(rst_sim); 
74C8:  BCF    F94.1
74CA:  BCF    F8B.1
....................                   fprintf(COM2,"the signal is not good, device will reboot\n\r"); 
74CC:  MOVLW  FC
74CE:  MOVWF  FF6
74D0:  MOVLW  4A
74D2:  MOVWF  FF7
74D4:  CLRF   19
74D6:  BTFSC  FF2.7
74D8:  BSF    19.7
74DA:  BCF    FF2.7
74DC:  MOVLB  0
74DE:  CALL   07A0
74E2:  BTFSC  19.7
74E4:  BSF    FF2.7
....................                   setup_wdt(WDT_ON); 
74E6:  BSF    FC0.0
74E8:  MOVLB  4
....................                } 
....................                timing_wait=1500; 
74EA:  MOVLW  05
74EC:  MOVWF  x98
74EE:  MOVLW  DC
74F0:  MOVWF  x97
....................                count_char=0; 
74F2:  MOVLB  9
74F4:  CLRF   xD4
....................             break; 
74F6:  MOVLB  4
74F8:  GOTO   9918
....................             #if defined(twonumber)  
....................             case checking_MN0: 
....................                fprintf(COM2,"\n\rchecking the first number\n\r"); 
74FC:  MOVLW  2A
74FE:  MOVWF  FF6
7500:  MOVLW  4B
7502:  MOVWF  FF7
7504:  CLRF   19
7506:  BTFSC  FF2.7
7508:  BSF    19.7
750A:  BCF    FF2.7
750C:  CALL   07A0
7510:  BTFSC  19.7
7512:  BSF    FF2.7
....................                fprintf(COM2,"\n\rMobile phone number is "); 
7514:  MOVLW  48
7516:  MOVWF  FF6
7518:  MOVLW  4B
751A:  MOVWF  FF7
751C:  CLRF   19
751E:  BTFSC  FF2.7
7520:  BSF    19.7
7522:  BCF    FF2.7
7524:  CALL   07A0
7528:  BTFSC  19.7
752A:  BSF    FF2.7
....................                for(i=0;i<20;i++) fprintf(COM2,"%c",mobilenumb[i]);  
752C:  MOVLB  9
752E:  CLRF   xD2
7530:  MOVF   xD2,W
7532:  SUBLW  13
7534:  BNC   7564
7536:  CLRF   03
7538:  MOVF   xD2,W
753A:  ADDLW  79
753C:  MOVWF  FE9
753E:  MOVLW  04
7540:  ADDWFC 03,W
7542:  MOVWF  FEA
7544:  MOVFF  FEF,A8E
7548:  CLRF   19
754A:  BTFSC  FF2.7
754C:  BSF    19.7
754E:  BCF    FF2.7
7550:  MOVFF  A8E,ADF
7554:  MOVLB  0
7556:  CALL   075A
755A:  BTFSC  19.7
755C:  BSF    FF2.7
755E:  MOVLB  9
7560:  INCF   xD2,F
7562:  BRA    7530
....................                fprintf(COM2,"\n\rMSG: "); 
7564:  MOVLW  62
7566:  MOVWF  FF6
7568:  MOVLW  4B
756A:  MOVWF  FF7
756C:  CLRF   19
756E:  BTFSC  FF2.7
7570:  BSF    19.7
7572:  BCF    FF2.7
7574:  MOVLB  0
7576:  CALL   07A0
757A:  BTFSC  19.7
757C:  BSF    FF2.7
....................                for(i=0;i<50;i++) fprintf(COM2,"%c",sim_bug[i]); 
757E:  MOVLB  9
7580:  CLRF   xD2
7582:  MOVF   xD2,W
7584:  SUBLW  31
7586:  BNC   75B6
7588:  CLRF   03
758A:  MOVF   xD2,W
758C:  ADDLW  D0
758E:  MOVWF  FE9
7590:  MOVLW  02
7592:  ADDWFC 03,W
7594:  MOVWF  FEA
7596:  MOVFF  FEF,A8E
759A:  CLRF   19
759C:  BTFSC  FF2.7
759E:  BSF    19.7
75A0:  BCF    FF2.7
75A2:  MOVFF  A8E,ADF
75A6:  MOVLB  0
75A8:  CALL   075A
75AC:  BTFSC  19.7
75AE:  BSF    FF2.7
75B0:  MOVLB  9
75B2:  INCF   xD2,F
75B4:  BRA    7582
....................                fprintf(COM2,"\n\rTIME: "); 
75B6:  MOVLW  6A
75B8:  MOVWF  FF6
75BA:  MOVLW  4B
75BC:  MOVWF  FF7
75BE:  CLRF   19
75C0:  BTFSC  FF2.7
75C2:  BSF    19.7
75C4:  BCF    FF2.7
75C6:  MOVLB  0
75C8:  CALL   07A0
75CC:  BTFSC  19.7
75CE:  BSF    FF2.7
....................                for(i=0;i<25;i++) 
75D0:  MOVLB  9
75D2:  CLRF   xD2
75D4:  MOVF   xD2,W
75D6:  SUBLW  18
75D8:  BNC   761E
....................                { 
....................                   if(datetime[i]=='"')break; 
75DA:  CLRF   03
75DC:  MOVF   xD2,W
75DE:  ADDLW  60
75E0:  MOVWF  FE9
75E2:  MOVLW  04
75E4:  ADDWFC 03,W
75E6:  MOVWF  FEA
75E8:  MOVF   FEF,W
75EA:  SUBLW  22
75EC:  BNZ   75F0
75EE:  BRA    761E
....................                   fprintf(COM2,"%c",datetime[i]); 
75F0:  CLRF   03
75F2:  MOVF   xD2,W
75F4:  ADDLW  60
75F6:  MOVWF  FE9
75F8:  MOVLW  04
75FA:  ADDWFC 03,W
75FC:  MOVWF  FEA
75FE:  MOVFF  FEF,A8E
7602:  CLRF   19
7604:  BTFSC  FF2.7
7606:  BSF    19.7
7608:  BCF    FF2.7
760A:  MOVFF  A8E,ADF
760E:  MOVLB  0
7610:  CALL   075A
7614:  BTFSC  19.7
7616:  BSF    FF2.7
....................                } 
7618:  MOVLB  9
761A:  INCF   xD2,F
761C:  BRA    75D4
....................                EEPROM_read(strobe_mobile_num0,20,msg_buffer1);  
761E:  MOVLW  41
7620:  MOVLB  A
7622:  MOVWF  x8E
7624:  MOVLW  14
7626:  MOVWF  x8F
7628:  MOVLW  03
762A:  MOVWF  x91
762C:  MOVLW  02
762E:  MOVWF  x90
7630:  MOVLB  0
7632:  CALL   506A
....................                strcpy(msg_buffer2,"redoo"); 
7636:  MOVLW  03
7638:  MOVWF  FEA
763A:  MOVLW  16
763C:  MOVWF  FE9
763E:  MOVLW  00
7640:  CALL   01AE
7644:  TBLRD*-
7646:  TBLRD*+
7648:  MOVF   FF5,W
764A:  MOVWF  FEE
764C:  IORLW  00
764E:  BNZ   7646
....................                if(!strncmp(msg_buffer2,sim_bug,5))  
7650:  MOVLW  03
7652:  MOVLB  A
7654:  MOVWF  x8F
7656:  MOVLW  16
7658:  MOVWF  x8E
765A:  MOVLW  02
765C:  MOVWF  x91
765E:  MOVLW  D0
7660:  MOVWF  x90
7662:  CLRF   x93
7664:  MOVLW  05
7666:  MOVWF  x92
7668:  MOVLB  0
766A:  CALL   569E
766E:  MOVF   01,F
7670:  BNZ   76D2
....................                { 
....................                  fprintf(COM2,"\n\rreset the password\n\r"); 
7672:  MOVLW  74
7674:  MOVWF  FF6
7676:  MOVLW  4B
7678:  MOVWF  FF7
767A:  CLRF   19
767C:  BTFSC  FF2.7
767E:  BSF    19.7
7680:  BCF    FF2.7
7682:  CALL   07A0
7686:  BTFSC  19.7
7688:  BSF    FF2.7
....................                  reset_password(); 
768A:  GOTO   5734
....................                  init_password(); 
768E:  CALL   5116
....................                  reset_2nd_number(); 
7692:  GOTO   5768
....................                  strcpy(reply_buffer,"done"); 
7696:  MOVLW  03
7698:  MOVWF  FEA
769A:  MOVLW  48
769C:  MOVWF  FE9
769E:  MOVLW  00
76A0:  CALL   0134
76A4:  TBLRD*-
76A6:  TBLRD*+
76A8:  MOVF   FF5,W
76AA:  MOVWF  FEE
76AC:  IORLW  00
76AE:  BNZ   76A6
....................                  fprintf(COM2,"done\n\r"); 
76B0:  MOVLW  8C
76B2:  MOVWF  FF6
76B4:  MOVLW  4B
76B6:  MOVWF  FF7
76B8:  CLRF   19
76BA:  BTFSC  FF2.7
76BC:  BSF    19.7
76BE:  BCF    FF2.7
76C0:  CALL   07A0
76C4:  BTFSC  19.7
76C6:  BSF    FF2.7
....................                  SIM_state=SIM_reply;  
76C8:  MOVLW  0E
76CA:  MOVLB  4
76CC:  MOVWF  x95
....................                  break; 
76CE:  GOTO   9918
....................                } 
....................                if(!stringcomp(mobilenumb,msg_buffer1))   
76D2:  MOVLW  04
76D4:  MOVLB  A
76D6:  MOVWF  x8F
76D8:  MOVLW  79
76DA:  MOVWF  x8E
76DC:  MOVLW  03
76DE:  MOVWF  x91
76E0:  MOVLW  02
76E2:  MOVWF  x90
76E4:  MOVLB  0
76E6:  CALL   579E
76EA:  MOVF   01,F
76EC:  BNZ   7714
....................                { 
....................                   fprintf(COM2,"\n\rchecking phone number is done\n\r");  
76EE:  MOVLW  94
76F0:  MOVWF  FF6
76F2:  MOVLW  4B
76F4:  MOVWF  FF7
76F6:  CLRF   19
76F8:  BTFSC  FF2.7
76FA:  BSF    19.7
76FC:  BCF    FF2.7
76FE:  CALL   07A0
7702:  BTFSC  19.7
7704:  BSF    FF2.7
....................                   updatetime2ds1307(); 
7706:  CALL   59E8
....................                   SIM_state=doing_sms; 
770A:  MOVLW  05
770C:  MOVLB  4
770E:  MOVWF  x95
....................                } 
....................                else 
7710:  BRA    7964
7712:  MOVLB  0
....................                { 
....................                  SIM_state=checking_MN; 
7714:  MOVLW  04
7716:  MOVLB  4
7718:  MOVWF  x95
....................                  strcpy(msg_buffer2,"goodbye"); 
771A:  MOVLW  03
771C:  MOVWF  FEA
771E:  MOVLW  16
7720:  MOVWF  FE9
7722:  MOVLW  00
7724:  MOVLB  0
7726:  CALL   01C4
772A:  TBLRD*-
772C:  TBLRD*+
772E:  MOVF   FF5,W
7730:  MOVWF  FEE
7732:  IORLW  00
7734:  BNZ   772C
....................                  if(!strncmp(msg_buffer2,sim_bug,7))  
7736:  MOVLW  03
7738:  MOVLB  A
773A:  MOVWF  x8F
773C:  MOVLW  16
773E:  MOVWF  x8E
7740:  MOVLW  02
7742:  MOVWF  x91
7744:  MOVLW  D0
7746:  MOVWF  x90
7748:  CLRF   x93
774A:  MOVLW  07
774C:  MOVWF  x92
774E:  MOVLB  0
7750:  CALL   569E
7754:  MOVF   01,F
7756:  BTFSS  FD8.2
7758:  BRA    7966
....................                  { 
....................                    SIM_state=delete_MSG;   
775A:  MOVLW  06
775C:  MOVLB  4
775E:  MOVWF  x95
....................                    for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+8];                 
7760:  MOVLB  9
7762:  CLRF   xD2
7764:  MOVF   xD2,W
7766:  SUBLW  13
7768:  BNC   77A4
776A:  CLRF   03
776C:  MOVF   xD2,W
776E:  ADDLW  16
7770:  MOVWF  01
7772:  MOVLW  03
7774:  ADDWFC 03,F
7776:  MOVFF  03,A8F
777A:  MOVLW  08
777C:  MOVLB  9
777E:  ADDWF  xD2,W
7780:  CLRF   03
7782:  ADDLW  D0
7784:  MOVWF  FE9
7786:  MOVLW  02
7788:  ADDWFC 03,W
778A:  MOVWF  FEA
778C:  MOVFF  FEF,A90
7790:  MOVLB  A
7792:  MOVFF  A8F,FEA
7796:  MOVFF  01,FE9
779A:  MOVFF  A90,FEF
779E:  MOVLB  9
77A0:  INCF   xD2,F
77A2:  BRA    7764
....................                    fprintf(COM2,"\n\rconfigured mobile phone number\n\r");  
77A4:  MOVLW  B6
77A6:  MOVWF  FF6
77A8:  MOVLW  4B
77AA:  MOVWF  FF7
77AC:  CLRF   19
77AE:  BTFSC  FF2.7
77B0:  BSF    19.7
77B2:  BCF    FF2.7
77B4:  MOVLB  0
77B6:  CALL   07A0
77BA:  BTFSC  19.7
77BC:  BSF    FF2.7
....................                    for(i=0;i<20;i++)fprintf(COM2,"%c",msg_buffer2[i]);  
77BE:  MOVLB  9
77C0:  CLRF   xD2
77C2:  MOVF   xD2,W
77C4:  SUBLW  13
77C6:  BNC   77F6
77C8:  CLRF   03
77CA:  MOVF   xD2,W
77CC:  ADDLW  16
77CE:  MOVWF  FE9
77D0:  MOVLW  03
77D2:  ADDWFC 03,W
77D4:  MOVWF  FEA
77D6:  MOVFF  FEF,A8E
77DA:  CLRF   19
77DC:  BTFSC  FF2.7
77DE:  BSF    19.7
77E0:  BCF    FF2.7
77E2:  MOVFF  A8E,ADF
77E6:  MOVLB  0
77E8:  CALL   075A
77EC:  BTFSC  19.7
77EE:  BSF    FF2.7
77F0:  MOVLB  9
77F2:  INCF   xD2,F
77F4:  BRA    77C2
77F6:  CLRF   19
77F8:  BTFSC  FF2.7
77FA:  BSF    19.7
77FC:  BCF    FF2.7
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",msg_buffer2[i]); 
....................                    fprintf(COM2,"\n\r");  
77FE:  MOVLW  0A
7800:  MOVLB  A
7802:  MOVWF  xDF
7804:  MOVLB  0
7806:  CALL   075A
780A:  BTFSC  19.7
780C:  BSF    FF2.7
780E:  CLRF   19
7810:  BTFSC  FF2.7
7812:  BSF    19.7
7814:  BCF    FF2.7
7816:  MOVLW  0D
7818:  MOVLB  A
781A:  MOVWF  xDF
781C:  MOVLB  0
781E:  CALL   075A
7822:  BTFSC  19.7
7824:  BSF    FF2.7
....................                    EEPROM_read(strobe_pass_addr,20,password); 
7826:  MOVLB  A
7828:  CLRF   x8E
782A:  MOVLW  14
782C:  MOVWF  x8F
782E:  CLRF   x91
7830:  MOVLW  55
7832:  MOVWF  x90
7834:  MOVLB  0
7836:  CALL   506A
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%c",password[i]); 
....................                    for(i=0;i<20;i++) 
783A:  MOVLB  9
783C:  CLRF   xD2
783E:  MOVF   xD2,W
7840:  SUBLW  13
7842:  BNC   7860
....................                    { 
....................                      if(password[i]==0)break; 
7844:  CLRF   03
7846:  MOVF   xD2,W
7848:  ADDLW  55
784A:  MOVWF  FE9
784C:  MOVLW  00
784E:  ADDWFC 03,W
7850:  MOVWF  FEA
7852:  MOVF   FEF,F
7854:  BNZ   785A
7856:  BRA    7860
....................                            else count_char++; 
7858:  BRA    785C
785A:  INCF   xD4,F
....................                    } 
785C:  INCF   xD2,F
785E:  BRA    783E
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",password[i]); 
....................                    //fprintf(COM2,"count_char=%d\n\r",count_char);  
....................                    //fprintf(COM2,"\n\r"); 
....................                    if(!strncmp(password,msg_buffer2,count_char))  
7860:  MOVLB  A
7862:  CLRF   x8F
7864:  MOVLW  55
7866:  MOVWF  x8E
7868:  MOVLW  03
786A:  MOVWF  x91
786C:  MOVLW  16
786E:  MOVWF  x90
7870:  CLRF   x93
7872:  MOVFF  9D4,A92
7876:  MOVLB  0
7878:  CALL   569E
787C:  MOVF   01,F
787E:  BNZ   792C
....................                    { 
....................                       EEPROM_write(strobe_mobile_num0,20,mobilenumb); 
7880:  MOVLW  41
7882:  MOVLB  A
7884:  MOVWF  xA3
7886:  MOVLW  14
7888:  MOVWF  xA4
788A:  MOVLW  04
788C:  MOVWF  xA6
788E:  MOVLW  79
7890:  MOVWF  xA5
7892:  MOVLB  0
7894:  CALL   50C4
....................                       fprintf(COM2,"changed phone number\n\r("); 
7898:  MOVLW  DA
789A:  MOVWF  FF6
789C:  MOVLW  4B
789E:  MOVWF  FF7
78A0:  CLRF   19
78A2:  BTFSC  FF2.7
78A4:  BSF    19.7
78A6:  BCF    FF2.7
78A8:  CALL   07A0
78AC:  BTFSC  19.7
78AE:  BSF    FF2.7
....................                       for(i=0;i<20;i++)fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num0+i));  
78B0:  MOVLB  9
78B2:  CLRF   xD2
78B4:  MOVF   xD2,W
78B6:  SUBLW  13
78B8:  BNC   78F6
78BA:  MOVLW  41
78BC:  ADDWF  xD2,W
78BE:  MOVLB  A
78C0:  MOVWF  x8E
78C2:  CLRF   19
78C4:  BTFSC  FF2.7
78C6:  BSF    19.7
78C8:  BCF    FF2.7
78CA:  CLRF   xC0
78CC:  MOVWF  xBF
78CE:  MOVLB  0
78D0:  CALL   3954
78D4:  BTFSC  19.7
78D6:  BSF    FF2.7
78D8:  MOVFF  01,A8E
78DC:  CLRF   19
78DE:  BTFSC  FF2.7
78E0:  BSF    19.7
78E2:  BCF    FF2.7
78E4:  MOVFF  01,ADF
78E8:  CALL   075A
78EC:  BTFSC  19.7
78EE:  BSF    FF2.7
78F0:  MOVLB  9
78F2:  INCF   xD2,F
78F4:  BRA    78B4
....................                       strcpy(reply_buffer,"done"); 
78F6:  MOVLW  03
78F8:  MOVWF  FEA
78FA:  MOVLW  48
78FC:  MOVWF  FE9
78FE:  MOVLW  00
7900:  MOVLB  0
7902:  CALL   0134
7906:  TBLRD*-
7908:  TBLRD*+
790A:  MOVF   FF5,W
790C:  MOVWF  FEE
790E:  IORLW  00
7910:  BNZ   7908
....................                       fprintf(COM2,")\n\r"); 
7912:  MOVLW  F2
7914:  MOVWF  FF6
7916:  MOVLW  4B
7918:  MOVWF  FF7
791A:  CLRF   19
791C:  BTFSC  FF2.7
791E:  BSF    19.7
7920:  BCF    FF2.7
7922:  CALL   07A0
7926:  BTFSC  19.7
7928:  BSF    FF2.7
....................                    } 
....................                      else 
792A:  BRA    795E
....................                      { 
....................                         fprintf(COM2,"wrong password\n\r"); 
792C:  MOVLW  F6
792E:  MOVWF  FF6
7930:  MOVLW  4B
7932:  MOVWF  FF7
7934:  CLRF   19
7936:  BTFSC  FF2.7
7938:  BSF    19.7
793A:  BCF    FF2.7
793C:  CALL   07A0
7940:  BTFSC  19.7
7942:  BSF    FF2.7
....................                         strcpy(reply_buffer,"wrong password"); 
7944:  MOVLW  03
7946:  MOVWF  FEA
7948:  MOVLW  48
794A:  MOVWF  FE9
794C:  MOVLW  00
794E:  CALL   01DC
7952:  TBLRD*-
7954:  TBLRD*+
7956:  MOVF   FF5,W
7958:  MOVWF  FEE
795A:  IORLW  00
795C:  BNZ   7954
....................                      }                      
....................                    SIM_state=SIM_reply;   
795E:  MOVLW  0E
7960:  MOVLB  4
7962:  MOVWF  x95
7964:  MOVLB  0
....................                  } 
....................  
....................                } 
....................             break; 
7966:  MOVLB  4
7968:  GOTO   9918
....................             #endif  
....................             case checking_MN: 
....................                #if defined(twonumber)  
....................                   fprintf(COM2,"\n\rchecking the second number\n\r"); 
796C:  MOVLW  08
796E:  MOVWF  FF6
7970:  MOVLW  4C
7972:  MOVWF  FF7
7974:  CLRF   19
7976:  BTFSC  FF2.7
7978:  BSF    19.7
797A:  BCF    FF2.7
797C:  CALL   07A0
7980:  BTFSC  19.7
7982:  BSF    FF2.7
....................                #endif 
....................                fprintf(COM2,"\n\rMobile phone number is "); 
7984:  MOVLW  28
7986:  MOVWF  FF6
7988:  MOVLW  4C
798A:  MOVWF  FF7
798C:  CLRF   19
798E:  BTFSC  FF2.7
7990:  BSF    19.7
7992:  BCF    FF2.7
7994:  CALL   07A0
7998:  BTFSC  19.7
799A:  BSF    FF2.7
....................                for(i=0;i<20;i++) fprintf(COM2,"%c",mobilenumb[i]);   
799C:  MOVLB  9
799E:  CLRF   xD2
79A0:  MOVF   xD2,W
79A2:  SUBLW  13
79A4:  BNC   79D4
79A6:  CLRF   03
79A8:  MOVF   xD2,W
79AA:  ADDLW  79
79AC:  MOVWF  FE9
79AE:  MOVLW  04
79B0:  ADDWFC 03,W
79B2:  MOVWF  FEA
79B4:  MOVFF  FEF,A8E
79B8:  CLRF   19
79BA:  BTFSC  FF2.7
79BC:  BSF    19.7
79BE:  BCF    FF2.7
79C0:  MOVFF  A8E,ADF
79C4:  MOVLB  0
79C6:  CALL   075A
79CA:  BTFSC  19.7
79CC:  BSF    FF2.7
79CE:  MOVLB  9
79D0:  INCF   xD2,F
79D2:  BRA    79A0
....................                fprintf(COM2,"\n\rMSG: "); 
79D4:  MOVLW  42
79D6:  MOVWF  FF6
79D8:  MOVLW  4C
79DA:  MOVWF  FF7
79DC:  CLRF   19
79DE:  BTFSC  FF2.7
79E0:  BSF    19.7
79E2:  BCF    FF2.7
79E4:  MOVLB  0
79E6:  CALL   07A0
79EA:  BTFSC  19.7
79EC:  BSF    FF2.7
....................                for(i=0;i<50;i++) fprintf(COM2,"%c",sim_bug[i]); 
79EE:  MOVLB  9
79F0:  CLRF   xD2
79F2:  MOVF   xD2,W
79F4:  SUBLW  31
79F6:  BNC   7A26
79F8:  CLRF   03
79FA:  MOVF   xD2,W
79FC:  ADDLW  D0
79FE:  MOVWF  FE9
7A00:  MOVLW  02
7A02:  ADDWFC 03,W
7A04:  MOVWF  FEA
7A06:  MOVFF  FEF,A8E
7A0A:  CLRF   19
7A0C:  BTFSC  FF2.7
7A0E:  BSF    19.7
7A10:  BCF    FF2.7
7A12:  MOVFF  A8E,ADF
7A16:  MOVLB  0
7A18:  CALL   075A
7A1C:  BTFSC  19.7
7A1E:  BSF    FF2.7
7A20:  MOVLB  9
7A22:  INCF   xD2,F
7A24:  BRA    79F2
....................                fprintf(COM2,"\n\rTIME: "); 
7A26:  MOVLW  4A
7A28:  MOVWF  FF6
7A2A:  MOVLW  4C
7A2C:  MOVWF  FF7
7A2E:  CLRF   19
7A30:  BTFSC  FF2.7
7A32:  BSF    19.7
7A34:  BCF    FF2.7
7A36:  MOVLB  0
7A38:  CALL   07A0
7A3C:  BTFSC  19.7
7A3E:  BSF    FF2.7
....................                for(i=0;i<25;i++) 
7A40:  MOVLB  9
7A42:  CLRF   xD2
7A44:  MOVF   xD2,W
7A46:  SUBLW  18
7A48:  BNC   7A8E
....................                { 
....................                   if(datetime[i]=='"')break; 
7A4A:  CLRF   03
7A4C:  MOVF   xD2,W
7A4E:  ADDLW  60
7A50:  MOVWF  FE9
7A52:  MOVLW  04
7A54:  ADDWFC 03,W
7A56:  MOVWF  FEA
7A58:  MOVF   FEF,W
7A5A:  SUBLW  22
7A5C:  BNZ   7A60
7A5E:  BRA    7A8E
....................                   fprintf(COM2,"%c",datetime[i]); 
7A60:  CLRF   03
7A62:  MOVF   xD2,W
7A64:  ADDLW  60
7A66:  MOVWF  FE9
7A68:  MOVLW  04
7A6A:  ADDWFC 03,W
7A6C:  MOVWF  FEA
7A6E:  MOVFF  FEF,A8E
7A72:  CLRF   19
7A74:  BTFSC  FF2.7
7A76:  BSF    19.7
7A78:  BCF    FF2.7
7A7A:  MOVFF  A8E,ADF
7A7E:  MOVLB  0
7A80:  CALL   075A
7A84:  BTFSC  19.7
7A86:  BSF    FF2.7
....................                }               
7A88:  MOVLB  9
7A8A:  INCF   xD2,F
7A8C:  BRA    7A44
....................                EEPROM_read(strobe_mobile_num1,20,msg_buffer1);                 
7A8E:  MOVLW  55
7A90:  MOVLB  A
7A92:  MOVWF  x8E
7A94:  MOVLW  14
7A96:  MOVWF  x8F
7A98:  MOVLW  03
7A9A:  MOVWF  x91
7A9C:  MOVLW  02
7A9E:  MOVWF  x90
7AA0:  MOVLB  0
7AA2:  CALL   506A
....................               //strcpy(msg_buffer1,"+84903219082"); 
....................               //strcpy(msg_buffer1,"+16612891316");//+16612891316 
....................               #if defined(twonumber)  
....................               #else 
....................               strcpy(msg_buffer2,"redoo"); 
....................               if(!strncmp(msg_buffer2,sim_bug,5))  
....................               { 
....................                  fprintf(COM2,"\n\rreset the password\n\r"); 
....................                  reset_password(); 
....................                  init_password(); 
....................                  strcpy(reply_buffer,"done"); 
....................                  fprintf(COM2,"done\n\r"); 
....................                  SIM_state=SIM_reply;  
....................                  break; 
....................               } 
....................               #endif 
....................               if(!stringcomp(mobilenumb,msg_buffer1))   
7AA6:  MOVLW  04
7AA8:  MOVLB  A
7AAA:  MOVWF  x8F
7AAC:  MOVLW  79
7AAE:  MOVWF  x8E
7AB0:  MOVLW  03
7AB2:  MOVWF  x91
7AB4:  MOVLW  02
7AB6:  MOVWF  x90
7AB8:  MOVLB  0
7ABA:  CALL   579E
7ABE:  MOVF   01,F
7AC0:  BNZ   7AE8
....................               { 
....................                   fprintf(COM2,"\n\rchecking phone number is done\n\r");  
7AC2:  MOVLW  54
7AC4:  MOVWF  FF6
7AC6:  MOVLW  4C
7AC8:  MOVWF  FF7
7ACA:  CLRF   19
7ACC:  BTFSC  FF2.7
7ACE:  BSF    19.7
7AD0:  BCF    FF2.7
7AD2:  CALL   07A0
7AD6:  BTFSC  19.7
7AD8:  BSF    FF2.7
....................                   updatetime2ds1307(); 
7ADA:  CALL   59E8
....................                   SIM_state=doing_sms; 
7ADE:  MOVLW  05
7AE0:  MOVLB  4
7AE2:  MOVWF  x95
....................               } 
....................                else 
7AE4:  BRA    7D56
7AE6:  MOVLB  0
....................                { 
....................                  SIM_state=delete_MSG; 
7AE8:  MOVLW  06
7AEA:  MOVLB  4
7AEC:  MOVWF  x95
....................                  strcpy(msg_buffer2,"hello"); 
7AEE:  MOVLW  03
7AF0:  MOVWF  FEA
7AF2:  MOVLW  16
7AF4:  MOVWF  FE9
7AF6:  MOVLW  00
7AF8:  MOVLB  0
7AFA:  CALL   01FC
7AFE:  TBLRD*-
7B00:  TBLRD*+
7B02:  MOVF   FF5,W
7B04:  MOVWF  FEE
7B06:  IORLW  00
7B08:  BNZ   7B00
....................                  if(!strncmp(msg_buffer2,sim_bug,5))  
7B0A:  MOVLW  03
7B0C:  MOVLB  A
7B0E:  MOVWF  x8F
7B10:  MOVLW  16
7B12:  MOVWF  x8E
7B14:  MOVLW  02
7B16:  MOVWF  x91
7B18:  MOVLW  D0
7B1A:  MOVWF  x90
7B1C:  CLRF   x93
7B1E:  MOVLW  05
7B20:  MOVWF  x92
7B22:  MOVLB  0
7B24:  CALL   569E
7B28:  MOVF   01,F
7B2A:  BTFSS  FD8.2
7B2C:  BRA    7D3C
....................                  { 
....................                    SIM_state=delete_MSG;   
7B2E:  MOVLW  06
7B30:  MOVLB  4
7B32:  MOVWF  x95
....................                    for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+6];                 
7B34:  MOVLB  9
7B36:  CLRF   xD2
7B38:  MOVF   xD2,W
7B3A:  SUBLW  13
7B3C:  BNC   7B78
7B3E:  CLRF   03
7B40:  MOVF   xD2,W
7B42:  ADDLW  16
7B44:  MOVWF  01
7B46:  MOVLW  03
7B48:  ADDWFC 03,F
7B4A:  MOVFF  03,A8F
7B4E:  MOVLW  06
7B50:  MOVLB  9
7B52:  ADDWF  xD2,W
7B54:  CLRF   03
7B56:  ADDLW  D0
7B58:  MOVWF  FE9
7B5A:  MOVLW  02
7B5C:  ADDWFC 03,W
7B5E:  MOVWF  FEA
7B60:  MOVFF  FEF,A90
7B64:  MOVLB  A
7B66:  MOVFF  A8F,FEA
7B6A:  MOVFF  01,FE9
7B6E:  MOVFF  A90,FEF
7B72:  MOVLB  9
7B74:  INCF   xD2,F
7B76:  BRA    7B38
....................                    fprintf(COM2,"\n\rconfigured mobile phone number\n\r");  
7B78:  MOVLW  76
7B7A:  MOVWF  FF6
7B7C:  MOVLW  4C
7B7E:  MOVWF  FF7
7B80:  CLRF   19
7B82:  BTFSC  FF2.7
7B84:  BSF    19.7
7B86:  BCF    FF2.7
7B88:  MOVLB  0
7B8A:  CALL   07A0
7B8E:  BTFSC  19.7
7B90:  BSF    FF2.7
....................                    for(i=0;i<20;i++)fprintf(COM2,"%c",msg_buffer2[i]);  
7B92:  MOVLB  9
7B94:  CLRF   xD2
7B96:  MOVF   xD2,W
7B98:  SUBLW  13
7B9A:  BNC   7BCA
7B9C:  CLRF   03
7B9E:  MOVF   xD2,W
7BA0:  ADDLW  16
7BA2:  MOVWF  FE9
7BA4:  MOVLW  03
7BA6:  ADDWFC 03,W
7BA8:  MOVWF  FEA
7BAA:  MOVFF  FEF,A8E
7BAE:  CLRF   19
7BB0:  BTFSC  FF2.7
7BB2:  BSF    19.7
7BB4:  BCF    FF2.7
7BB6:  MOVFF  A8E,ADF
7BBA:  MOVLB  0
7BBC:  CALL   075A
7BC0:  BTFSC  19.7
7BC2:  BSF    FF2.7
7BC4:  MOVLB  9
7BC6:  INCF   xD2,F
7BC8:  BRA    7B96
7BCA:  CLRF   19
7BCC:  BTFSC  FF2.7
7BCE:  BSF    19.7
7BD0:  BCF    FF2.7
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",msg_buffer2[i]); 
....................                    fprintf(COM2,"\n\r");  
7BD2:  MOVLW  0A
7BD4:  MOVLB  A
7BD6:  MOVWF  xDF
7BD8:  MOVLB  0
7BDA:  CALL   075A
7BDE:  BTFSC  19.7
7BE0:  BSF    FF2.7
7BE2:  CLRF   19
7BE4:  BTFSC  FF2.7
7BE6:  BSF    19.7
7BE8:  BCF    FF2.7
7BEA:  MOVLW  0D
7BEC:  MOVLB  A
7BEE:  MOVWF  xDF
7BF0:  MOVLB  0
7BF2:  CALL   075A
7BF6:  BTFSC  19.7
7BF8:  BSF    FF2.7
....................                    EEPROM_read(strobe_pass_addr,20,password); 
7BFA:  MOVLB  A
7BFC:  CLRF   x8E
7BFE:  MOVLW  14
7C00:  MOVWF  x8F
7C02:  CLRF   x91
7C04:  MOVLW  55
7C06:  MOVWF  x90
7C08:  MOVLB  0
7C0A:  CALL   506A
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%c",password[i]); 
....................                    for(i=0;i<20;i++) 
7C0E:  MOVLB  9
7C10:  CLRF   xD2
7C12:  MOVF   xD2,W
7C14:  SUBLW  13
7C16:  BNC   7C34
....................                    { 
....................                      if(password[i]==0)break; 
7C18:  CLRF   03
7C1A:  MOVF   xD2,W
7C1C:  ADDLW  55
7C1E:  MOVWF  FE9
7C20:  MOVLW  00
7C22:  ADDWFC 03,W
7C24:  MOVWF  FEA
7C26:  MOVF   FEF,F
7C28:  BNZ   7C2E
7C2A:  BRA    7C34
....................                            else count_char++; 
7C2C:  BRA    7C30
7C2E:  INCF   xD4,F
....................                    } 
7C30:  INCF   xD2,F
7C32:  BRA    7C12
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",password[i]); 
....................                    //fprintf(COM2,"count_char=%d\n\r",count_char);  
....................                    //fprintf(COM2,"\n\r"); 
....................                    if(!strncmp(password,msg_buffer2,count_char))  
7C34:  MOVLB  A
7C36:  CLRF   x8F
7C38:  MOVLW  55
7C3A:  MOVWF  x8E
7C3C:  MOVLW  03
7C3E:  MOVWF  x91
7C40:  MOVLW  16
7C42:  MOVWF  x90
7C44:  CLRF   x93
7C46:  MOVFF  9D4,A92
7C4A:  MOVLB  0
7C4C:  CALL   569E
7C50:  MOVF   01,F
7C52:  BNZ   7D00
....................                    { 
....................                       EEPROM_write(strobe_mobile_num1,20,mobilenumb); 
7C54:  MOVLW  55
7C56:  MOVLB  A
7C58:  MOVWF  xA3
7C5A:  MOVLW  14
7C5C:  MOVWF  xA4
7C5E:  MOVLW  04
7C60:  MOVWF  xA6
7C62:  MOVLW  79
7C64:  MOVWF  xA5
7C66:  MOVLB  0
7C68:  CALL   50C4
....................                       fprintf(COM2,"changed phone number\n\r("); 
7C6C:  MOVLW  9A
7C6E:  MOVWF  FF6
7C70:  MOVLW  4C
7C72:  MOVWF  FF7
7C74:  CLRF   19
7C76:  BTFSC  FF2.7
7C78:  BSF    19.7
7C7A:  BCF    FF2.7
7C7C:  CALL   07A0
7C80:  BTFSC  19.7
7C82:  BSF    FF2.7
....................                       for(i=0;i<20;i++)fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));  
7C84:  MOVLB  9
7C86:  CLRF   xD2
7C88:  MOVF   xD2,W
7C8A:  SUBLW  13
7C8C:  BNC   7CCA
7C8E:  MOVLW  55
7C90:  ADDWF  xD2,W
7C92:  MOVLB  A
7C94:  MOVWF  x8E
7C96:  CLRF   19
7C98:  BTFSC  FF2.7
7C9A:  BSF    19.7
7C9C:  BCF    FF2.7
7C9E:  CLRF   xC0
7CA0:  MOVWF  xBF
7CA2:  MOVLB  0
7CA4:  CALL   3954
7CA8:  BTFSC  19.7
7CAA:  BSF    FF2.7
7CAC:  MOVFF  01,A8E
7CB0:  CLRF   19
7CB2:  BTFSC  FF2.7
7CB4:  BSF    19.7
7CB6:  BCF    FF2.7
7CB8:  MOVFF  01,ADF
7CBC:  CALL   075A
7CC0:  BTFSC  19.7
7CC2:  BSF    FF2.7
7CC4:  MOVLB  9
7CC6:  INCF   xD2,F
7CC8:  BRA    7C88
....................                       strcpy(reply_buffer,"done"); 
7CCA:  MOVLW  03
7CCC:  MOVWF  FEA
7CCE:  MOVLW  48
7CD0:  MOVWF  FE9
7CD2:  MOVLW  00
7CD4:  MOVLB  0
7CD6:  CALL   0134
7CDA:  TBLRD*-
7CDC:  TBLRD*+
7CDE:  MOVF   FF5,W
7CE0:  MOVWF  FEE
7CE2:  IORLW  00
7CE4:  BNZ   7CDC
....................                       fprintf(COM2,")\n\r"); 
7CE6:  MOVLW  B2
7CE8:  MOVWF  FF6
7CEA:  MOVLW  4C
7CEC:  MOVWF  FF7
7CEE:  CLRF   19
7CF0:  BTFSC  FF2.7
7CF2:  BSF    19.7
7CF4:  BCF    FF2.7
7CF6:  CALL   07A0
7CFA:  BTFSC  19.7
7CFC:  BSF    FF2.7
....................                    } 
....................                      else 
7CFE:  BRA    7D32
....................                      { 
....................                         fprintf(COM2,"wrong password\n\r"); 
7D00:  MOVLW  B6
7D02:  MOVWF  FF6
7D04:  MOVLW  4C
7D06:  MOVWF  FF7
7D08:  CLRF   19
7D0A:  BTFSC  FF2.7
7D0C:  BSF    19.7
7D0E:  BCF    FF2.7
7D10:  CALL   07A0
7D14:  BTFSC  19.7
7D16:  BSF    FF2.7
....................                         strcpy(reply_buffer,"wrong password"); 
7D18:  MOVLW  03
7D1A:  MOVWF  FEA
7D1C:  MOVLW  48
7D1E:  MOVWF  FE9
7D20:  MOVLW  00
7D22:  CALL   01DC
7D26:  TBLRD*-
7D28:  TBLRD*+
7D2A:  MOVF   FF5,W
7D2C:  MOVWF  FEE
7D2E:  IORLW  00
7D30:  BNZ   7D28
....................                      }                      
....................                    SIM_state=SIM_reply;   
7D32:  MOVLW  0E
7D34:  MOVLB  4
7D36:  MOVWF  x95
....................                  } 
....................                   else fprintf(COM2,"\n\r this phone unable to send commands \n\r"); 
7D38:  BRA    7D56
7D3A:  MOVLB  0
7D3C:  MOVLW  C8
7D3E:  MOVWF  FF6
7D40:  MOVLW  4C
7D42:  MOVWF  FF7
7D44:  CLRF   19
7D46:  BTFSC  FF2.7
7D48:  BSF    19.7
7D4A:  BCF    FF2.7
7D4C:  CALL   07A0
7D50:  BTFSC  19.7
7D52:  BSF    FF2.7
7D54:  MOVLB  4
....................                } 
....................             break; 
7D56:  GOTO   9918
....................             case doing_sms: 
....................                
....................               memset(msg_data_sending,0,sizeof(msg_data_sending)); 
7D5A:  MOVLW  01
7D5C:  MOVWF  FEA
7D5E:  MOVLW  B8
7D60:  MOVWF  FE9
7D62:  CLRF   00
7D64:  MOVLW  01
7D66:  MOVWF  02
7D68:  MOVLW  18
7D6A:  MOVWF  01
7D6C:  CALL   447A
....................                
....................               strcpy(msg_buffer2,"password"); 
7D70:  MOVLW  03
7D72:  MOVWF  FEA
7D74:  MOVLW  16
7D76:  MOVWF  FE9
7D78:  MOVLW  00
7D7A:  CALL   0162
7D7E:  TBLRD*-
7D80:  TBLRD*+
7D82:  MOVF   FF5,W
7D84:  MOVWF  FEE
7D86:  IORLW  00
7D88:  BNZ   7D80
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
7D8A:  MOVLW  03
7D8C:  MOVLB  A
7D8E:  MOVWF  x8F
7D90:  MOVLW  16
7D92:  MOVWF  x8E
7D94:  MOVLW  02
7D96:  MOVWF  x91
7D98:  MOVLW  D0
7D9A:  MOVWF  x90
7D9C:  CLRF   x93
7D9E:  MOVLW  08
7DA0:  MOVWF  x92
7DA2:  MOVLB  0
7DA4:  CALL   569E
7DA8:  MOVF   01,F
7DAA:  BTFSS  FD8.2
7DAC:  BRA    7EB4
....................               { 
....................                 //SIM_state=delete_MSG;   
....................                 SIM_state=SIM_reply; 
7DAE:  MOVLW  0E
7DB0:  MOVLB  4
7DB2:  MOVWF  x95
....................                 for(i=0;i<20;i++) 
7DB4:  MOVLB  9
7DB6:  CLRF   xD2
7DB8:  MOVF   xD2,W
7DBA:  SUBLW  13
7DBC:  BNC   7E00
....................                 { 
....................                   write_ext_eeprom(strobe_pass_addr+i,sim_bug[i+9]); 
7DBE:  MOVLW  09
7DC0:  ADDWF  xD2,W
7DC2:  CLRF   03
7DC4:  ADDLW  D0
7DC6:  MOVWF  FE9
7DC8:  MOVLW  02
7DCA:  ADDWFC 03,W
7DCC:  MOVWF  FEA
7DCE:  MOVFF  FEF,A8E
7DD2:  CLRF   19
7DD4:  BTFSC  FF2.7
7DD6:  BSF    19.7
7DD8:  BCF    FF2.7
7DDA:  MOVLB  A
7DDC:  CLRF   xC8
7DDE:  MOVFF  9D2,AC7
7DE2:  MOVFF  A8E,AC9
7DE6:  MOVLB  0
7DE8:  CALL   3E78
7DEC:  BTFSC  19.7
7DEE:  BSF    FF2.7
....................                   delay_us(10); 
7DF0:  MOVLW  1A
7DF2:  MOVWF  00
7DF4:  DECFSZ 00,F
7DF6:  BRA    7DF4
7DF8:  NOP   
....................                 } 
7DFA:  MOVLB  9
7DFC:  INCF   xD2,F
7DFE:  BRA    7DB8
....................                 //EEPROM_write(strobe_pass_addr,20,sim_bug); 
....................                 fprintf(COM2,"changed the password\n\r");               
7E00:  MOVLW  F2
7E02:  MOVWF  FF6
7E04:  MOVLW  4C
7E06:  MOVWF  FF7
7E08:  CLRF   19
7E0A:  BTFSC  FF2.7
7E0C:  BSF    19.7
7E0E:  BCF    FF2.7
7E10:  MOVLB  0
7E12:  CALL   07A0
7E16:  BTFSC  19.7
7E18:  BSF    FF2.7
....................                 memset(password,0,sizeof(password)); 
7E1A:  CLRF   FEA
7E1C:  MOVLW  55
7E1E:  MOVWF  FE9
7E20:  CLRF   00
7E22:  CLRF   02
7E24:  MOVLW  14
7E26:  MOVWF  01
7E28:  CALL   447A
....................                 EEPROM_read(strobe_pass_addr,20,password); 
7E2C:  MOVLB  A
7E2E:  CLRF   x8E
7E30:  MOVLW  14
7E32:  MOVWF  x8F
7E34:  CLRF   x91
7E36:  MOVLW  55
7E38:  MOVWF  x90
7E3A:  MOVLB  0
7E3C:  CALL   506A
....................                 for(i=0;i<20;i++) fprintf(COM2,"%c",password[i]); 
7E40:  MOVLB  9
7E42:  CLRF   xD2
7E44:  MOVF   xD2,W
7E46:  SUBLW  13
7E48:  BNC   7E78
7E4A:  CLRF   03
7E4C:  MOVF   xD2,W
7E4E:  ADDLW  55
7E50:  MOVWF  FE9
7E52:  MOVLW  00
7E54:  ADDWFC 03,W
7E56:  MOVWF  FEA
7E58:  MOVFF  FEF,A8E
7E5C:  CLRF   19
7E5E:  BTFSC  FF2.7
7E60:  BSF    19.7
7E62:  BCF    FF2.7
7E64:  MOVFF  A8E,ADF
7E68:  MOVLB  0
7E6A:  CALL   075A
7E6E:  BTFSC  19.7
7E70:  BSF    FF2.7
7E72:  MOVLB  9
7E74:  INCF   xD2,F
7E76:  BRA    7E44
....................                 fprintf(COM2,"\n\rexit\n\r"); 
7E78:  MOVLW  0A
7E7A:  MOVWF  FF6
7E7C:  MOVLW  4D
7E7E:  MOVWF  FF7
7E80:  CLRF   19
7E82:  BTFSC  FF2.7
7E84:  BSF    19.7
7E86:  BCF    FF2.7
7E88:  MOVLB  0
7E8A:  CALL   07A0
7E8E:  BTFSC  19.7
7E90:  BSF    FF2.7
....................                 strcpy(reply_buffer,"done"); 
7E92:  MOVLW  03
7E94:  MOVWF  FEA
7E96:  MOVLW  48
7E98:  MOVWF  FE9
7E9A:  MOVLW  00
7E9C:  CALL   0134
7EA0:  TBLRD*-
7EA2:  TBLRD*+
7EA4:  MOVF   FF5,W
7EA6:  MOVWF  FEE
7EA8:  IORLW  00
7EAA:  BNZ   7EA2
....................                 break; 
7EAC:  MOVLB  4
7EAE:  GOTO   9918
7EB2:  MOVLB  0
....................               } 
....................                
....................               strcpy(msg_buffer2,"keypress"); 
7EB4:  MOVLW  03
7EB6:  MOVWF  FEA
7EB8:  MOVLW  16
7EBA:  MOVWF  FE9
7EBC:  MOVLW  00
7EBE:  CALL   0212
7EC2:  TBLRD*-
7EC4:  TBLRD*+
7EC6:  MOVF   FF5,W
7EC8:  MOVWF  FEE
7ECA:  IORLW  00
7ECC:  BNZ   7EC4
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
7ECE:  MOVLW  03
7ED0:  MOVLB  A
7ED2:  MOVWF  x8F
7ED4:  MOVLW  16
7ED6:  MOVWF  x8E
7ED8:  MOVLW  02
7EDA:  MOVWF  x91
7EDC:  MOVLW  D0
7EDE:  MOVWF  x90
7EE0:  CLRF   x93
7EE2:  MOVLW  08
7EE4:  MOVWF  x92
7EE6:  MOVLB  0
7EE8:  CALL   569E
7EEC:  MOVF   01,F
7EEE:  BTFSS  FD8.2
7EF0:  BRA    80D8
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 //SIM_state=SIM_reply; 
....................                 SIM_state=SIM_reply; 
7EF2:  MOVLW  0E
7EF4:  MOVLB  4
7EF6:  MOVWF  x95
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+9]; 
7EF8:  MOVLB  9
7EFA:  CLRF   xD2
7EFC:  MOVF   xD2,W
7EFE:  SUBLW  13
7F00:  BNC   7F3C
7F02:  CLRF   03
7F04:  MOVF   xD2,W
7F06:  ADDLW  16
7F08:  MOVWF  01
7F0A:  MOVLW  03
7F0C:  ADDWFC 03,F
7F0E:  MOVFF  03,A8F
7F12:  MOVLW  09
7F14:  MOVLB  9
7F16:  ADDWF  xD2,W
7F18:  CLRF   03
7F1A:  ADDLW  D0
7F1C:  MOVWF  FE9
7F1E:  MOVLW  02
7F20:  ADDWFC 03,W
7F22:  MOVWF  FEA
7F24:  MOVFF  FEF,A90
7F28:  MOVLB  A
7F2A:  MOVFF  A8F,FEA
7F2E:  MOVFF  01,FE9
7F32:  MOVFF  A90,FEF
7F36:  MOVLB  9
7F38:  INCF   xD2,F
7F3A:  BRA    7EFC
....................                 strcpy(msg_buffer1,"on"); 
7F3C:  MOVLW  03
7F3E:  MOVWF  FEA
7F40:  MOVLW  02
7F42:  MOVWF  FE9
7F44:  MOVLW  00
7F46:  MOVLB  0
7F48:  CALL   022C
7F4C:  TBLRD*-
7F4E:  TBLRD*+
7F50:  MOVF   FF5,W
7F52:  MOVWF  FEE
7F54:  IORLW  00
7F56:  BNZ   7F4E
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
7F58:  MOVLW  03
7F5A:  MOVLB  A
7F5C:  MOVWF  x8F
7F5E:  MOVLW  16
7F60:  MOVWF  x8E
7F62:  MOVLW  03
7F64:  MOVWF  x91
7F66:  MOVLW  02
7F68:  MOVWF  x90
7F6A:  CLRF   x93
7F6C:  MOVWF  x92
7F6E:  MOVLB  0
7F70:  CALL   569E
7F74:  MOVF   01,F
7F76:  BNZ   7FEE
....................                 { 
....................                   fprintf(COM2,"\n\rkeypress turn on\n\r"); 
7F78:  MOVLW  14
7F7A:  MOVWF  FF6
7F7C:  MOVLW  4D
7F7E:  MOVWF  FF7
7F80:  CLRF   19
7F82:  BTFSC  FF2.7
7F84:  BSF    19.7
7F86:  BCF    FF2.7
7F88:  CALL   07A0
7F8C:  BTFSC  19.7
7F8E:  BSF    FF2.7
....................                   KP_mode = 1; 
7F90:  MOVLW  01
7F92:  MOVLB  1
7F94:  MOVWF  x0F
7F96:  CLRF   19
7F98:  BTFSC  FF2.7
7F9A:  BSF    19.7
7F9C:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_keypressmode,KP_mode); 
7F9E:  MOVLB  A
7FA0:  CLRF   xC8
7FA2:  MOVLW  7F
7FA4:  MOVWF  xC7
7FA6:  MOVFF  10F,AC9
7FAA:  MOVLB  0
7FAC:  CALL   3E78
7FB0:  BTFSC  19.7
7FB2:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r");                  
7FB4:  MOVLW  2A
7FB6:  MOVWF  FF6
7FB8:  MOVLW  4D
7FBA:  MOVWF  FF7
7FBC:  CLRF   19
7FBE:  BTFSC  FF2.7
7FC0:  BSF    19.7
7FC2:  BCF    FF2.7
7FC4:  CALL   07A0
7FC8:  BTFSC  19.7
7FCA:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
7FCC:  MOVLW  03
7FCE:  MOVWF  FEA
7FD0:  MOVLW  48
7FD2:  MOVWF  FE9
7FD4:  MOVLW  00
7FD6:  CALL   0134
7FDA:  TBLRD*-
7FDC:  TBLRD*+
7FDE:  MOVF   FF5,W
7FE0:  MOVWF  FEE
7FE2:  IORLW  00
7FE4:  BNZ   7FDC
....................                   break; 
7FE6:  MOVLB  4
7FE8:  GOTO   9918
7FEC:  MOVLB  0
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
7FEE:  MOVLW  03
7FF0:  MOVWF  FEA
7FF2:  MOVLW  02
7FF4:  MOVWF  FE9
7FF6:  MOVLW  00
7FF8:  CALL   0240
7FFC:  TBLRD*-
7FFE:  TBLRD*+
8000:  MOVF   FF5,W
8002:  MOVWF  FEE
8004:  IORLW  00
8006:  BNZ   7FFE
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
8008:  MOVLW  03
800A:  MOVLB  A
800C:  MOVWF  x8F
800E:  MOVLW  16
8010:  MOVWF  x8E
8012:  MOVLW  03
8014:  MOVWF  x91
8016:  MOVLW  02
8018:  MOVWF  x90
801A:  CLRF   x93
801C:  MOVLW  03
801E:  MOVWF  x92
8020:  MOVLB  0
8022:  CALL   569E
8026:  MOVF   01,F
8028:  BNZ   809E
....................                 { 
....................                   fprintf(COM2,"\n\rkeypress turn off\n\r"); 
802A:  MOVLW  32
802C:  MOVWF  FF6
802E:  MOVLW  4D
8030:  MOVWF  FF7
8032:  CLRF   19
8034:  BTFSC  FF2.7
8036:  BSF    19.7
8038:  BCF    FF2.7
803A:  CALL   07A0
803E:  BTFSC  19.7
8040:  BSF    FF2.7
....................                   KP_mode = 0; 
8042:  MOVLB  1
8044:  CLRF   x0F
8046:  CLRF   19
8048:  BTFSC  FF2.7
804A:  BSF    19.7
804C:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_keypressmode,KP_mode); 
804E:  MOVLB  A
8050:  CLRF   xC8
8052:  MOVLW  7F
8054:  MOVWF  xC7
8056:  MOVFF  10F,AC9
805A:  MOVLB  0
805C:  CALL   3E78
8060:  BTFSC  19.7
8062:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r"); 
8064:  MOVLW  48
8066:  MOVWF  FF6
8068:  MOVLW  4D
806A:  MOVWF  FF7
806C:  CLRF   19
806E:  BTFSC  FF2.7
8070:  BSF    19.7
8072:  BCF    FF2.7
8074:  CALL   07A0
8078:  BTFSC  19.7
807A:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
807C:  MOVLW  03
807E:  MOVWF  FEA
8080:  MOVLW  48
8082:  MOVWF  FE9
8084:  MOVLW  00
8086:  CALL   0134
808A:  TBLRD*-
808C:  TBLRD*+
808E:  MOVF   FF5,W
8090:  MOVWF  FEE
8092:  IORLW  00
8094:  BNZ   808C
....................                   break; 
8096:  MOVLB  4
8098:  GOTO   9918
809C:  MOVLB  0
....................                 } 
....................                 strcpy(reply_buffer,"please check your syntax");  
809E:  MOVLW  03
80A0:  MOVWF  FEA
80A2:  MOVLW  48
80A4:  MOVWF  FE9
80A6:  MOVLW  00
80A8:  CALL   0254
80AC:  TBLRD*-
80AE:  TBLRD*+
80B0:  MOVF   FF5,W
80B2:  MOVWF  FEE
80B4:  IORLW  00
80B6:  BNZ   80AE
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
80B8:  MOVLW  50
80BA:  MOVWF  FF6
80BC:  MOVLW  4D
80BE:  MOVWF  FF7
80C0:  CLRF   19
80C2:  BTFSC  FF2.7
80C4:  BSF    19.7
80C6:  BCF    FF2.7
80C8:  CALL   07A0
80CC:  BTFSC  19.7
80CE:  BSF    FF2.7
....................                 break; 
80D0:  MOVLB  4
80D2:  GOTO   9918
80D6:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"master"); 
80D8:  MOVLW  03
80DA:  MOVWF  FEA
80DC:  MOVLW  16
80DE:  MOVWF  FE9
80E0:  MOVLW  00
80E2:  CALL   027E
80E6:  TBLRD*-
80E8:  TBLRD*+
80EA:  MOVF   FF5,W
80EC:  MOVWF  FEE
80EE:  IORLW  00
80F0:  BNZ   80E8
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
80F2:  MOVLW  03
80F4:  MOVLB  A
80F6:  MOVWF  x8F
80F8:  MOVLW  16
80FA:  MOVWF  x8E
80FC:  MOVLW  02
80FE:  MOVWF  x91
8100:  MOVLW  D0
8102:  MOVWF  x90
8104:  CLRF   x93
8106:  MOVLW  06
8108:  MOVWF  x92
810A:  MOVLB  0
810C:  CALL   569E
8110:  MOVF   01,F
8112:  BTFSS  FD8.2
8114:  BRA    82FC
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
8116:  MOVLW  0E
8118:  MOVLB  4
811A:  MOVWF  x95
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+7]; 
811C:  MOVLB  9
811E:  CLRF   xD2
8120:  MOVF   xD2,W
8122:  SUBLW  13
8124:  BNC   8160
8126:  CLRF   03
8128:  MOVF   xD2,W
812A:  ADDLW  16
812C:  MOVWF  01
812E:  MOVLW  03
8130:  ADDWFC 03,F
8132:  MOVFF  03,A8F
8136:  MOVLW  07
8138:  MOVLB  9
813A:  ADDWF  xD2,W
813C:  CLRF   03
813E:  ADDLW  D0
8140:  MOVWF  FE9
8142:  MOVLW  02
8144:  ADDWFC 03,W
8146:  MOVWF  FEA
8148:  MOVFF  FEF,A90
814C:  MOVLB  A
814E:  MOVFF  A8F,FEA
8152:  MOVFF  01,FE9
8156:  MOVFF  A90,FEF
815A:  MOVLB  9
815C:  INCF   xD2,F
815E:  BRA    8120
....................                 strcpy(msg_buffer1,"on"); 
8160:  MOVLW  03
8162:  MOVWF  FEA
8164:  MOVLW  02
8166:  MOVWF  FE9
8168:  MOVLW  00
816A:  MOVLB  0
816C:  CALL   022C
8170:  TBLRD*-
8172:  TBLRD*+
8174:  MOVF   FF5,W
8176:  MOVWF  FEE
8178:  IORLW  00
817A:  BNZ   8172
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
817C:  MOVLW  03
817E:  MOVLB  A
8180:  MOVWF  x8F
8182:  MOVLW  16
8184:  MOVWF  x8E
8186:  MOVLW  03
8188:  MOVWF  x91
818A:  MOVLW  02
818C:  MOVWF  x90
818E:  CLRF   x93
8190:  MOVWF  x92
8192:  MOVLB  0
8194:  CALL   569E
8198:  MOVF   01,F
819A:  BNZ   8210
....................                 { 
....................                   fprintf(COM2,"\n\rmaster mode turn on\n\r"); 
819C:  MOVLW  6E
819E:  MOVWF  FF6
81A0:  MOVLW  4D
81A2:  MOVWF  FF7
81A4:  CLRF   19
81A6:  BTFSC  FF2.7
81A8:  BSF    19.7
81AA:  BCF    FF2.7
81AC:  CALL   07A0
81B0:  BTFSC  19.7
81B2:  BSF    FF2.7
....................                    mode_sl = 0; 
81B4:  MOVLB  9
81B6:  CLRF   xB3
81B8:  CLRF   19
81BA:  BTFSC  FF2.7
81BC:  BSF    19.7
81BE:  BCF    FF2.7
....................                    write_ext_eeprom(strobe_Master_SLV,mode_sl); 
81C0:  MOVLB  A
81C2:  CLRF   xC8
81C4:  MOVLW  91
81C6:  MOVWF  xC7
81C8:  MOVFF  9B3,AC9
81CC:  MOVLB  0
81CE:  CALL   3E78
81D2:  BTFSC  19.7
81D4:  BSF    FF2.7
....................                    strcpy(reply_buffer,"done"); 
81D6:  MOVLW  03
81D8:  MOVWF  FEA
81DA:  MOVLW  48
81DC:  MOVWF  FE9
81DE:  MOVLW  00
81E0:  CALL   0134
81E4:  TBLRD*-
81E6:  TBLRD*+
81E8:  MOVF   FF5,W
81EA:  MOVWF  FEE
81EC:  IORLW  00
81EE:  BNZ   81E6
....................                    fprintf(COM2," exit\n\r"); 
81F0:  MOVLW  86
81F2:  MOVWF  FF6
81F4:  MOVLW  4D
81F6:  MOVWF  FF7
81F8:  CLRF   19
81FA:  BTFSC  FF2.7
81FC:  BSF    19.7
81FE:  BCF    FF2.7
8200:  CALL   07A0
8204:  BTFSC  19.7
8206:  BSF    FF2.7
....................                    break; 
8208:  MOVLB  4
820A:  GOTO   9918
820E:  MOVLB  0
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
8210:  MOVLW  03
8212:  MOVWF  FEA
8214:  MOVLW  02
8216:  MOVWF  FE9
8218:  MOVLW  00
821A:  CALL   0240
821E:  TBLRD*-
8220:  TBLRD*+
8222:  MOVF   FF5,W
8224:  MOVWF  FEE
8226:  IORLW  00
8228:  BNZ   8220
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
822A:  MOVLW  03
822C:  MOVLB  A
822E:  MOVWF  x8F
8230:  MOVLW  16
8232:  MOVWF  x8E
8234:  MOVLW  03
8236:  MOVWF  x91
8238:  MOVLW  02
823A:  MOVWF  x90
823C:  CLRF   x93
823E:  MOVLW  03
8240:  MOVWF  x92
8242:  MOVLB  0
8244:  CALL   569E
8248:  MOVF   01,F
824A:  BNZ   82C2
....................                 { 
....................                   fprintf(COM2,"\n\rmaster mode turn off\n\r"); 
824C:  MOVLW  8E
824E:  MOVWF  FF6
8250:  MOVLW  4D
8252:  MOVWF  FF7
8254:  CLRF   19
8256:  BTFSC  FF2.7
8258:  BSF    19.7
825A:  BCF    FF2.7
825C:  CALL   07A0
8260:  BTFSC  19.7
8262:  BSF    FF2.7
....................                   mode_sl = 1; 
8264:  MOVLW  01
8266:  MOVLB  9
8268:  MOVWF  xB3
826A:  CLRF   19
826C:  BTFSC  FF2.7
826E:  BSF    19.7
8270:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_Master_SLV,mode_sl); 
8272:  MOVLB  A
8274:  CLRF   xC8
8276:  MOVLW  91
8278:  MOVWF  xC7
827A:  MOVFF  9B3,AC9
827E:  MOVLB  0
8280:  CALL   3E78
8284:  BTFSC  19.7
8286:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8288:  MOVLW  03
828A:  MOVWF  FEA
828C:  MOVLW  48
828E:  MOVWF  FE9
8290:  MOVLW  00
8292:  CALL   0134
8296:  TBLRD*-
8298:  TBLRD*+
829A:  MOVF   FF5,W
829C:  MOVWF  FEE
829E:  IORLW  00
82A0:  BNZ   8298
....................                   fprintf(COM2," exit\n\r"); 
82A2:  MOVLW  A8
82A4:  MOVWF  FF6
82A6:  MOVLW  4D
82A8:  MOVWF  FF7
82AA:  CLRF   19
82AC:  BTFSC  FF2.7
82AE:  BSF    19.7
82B0:  BCF    FF2.7
82B2:  CALL   07A0
82B6:  BTFSC  19.7
82B8:  BSF    FF2.7
....................                   break; 
82BA:  MOVLB  4
82BC:  GOTO   9918
82C0:  MOVLB  0
....................                 } 
....................                 strcpy(reply_buffer,"please check your syntax");  
82C2:  MOVLW  03
82C4:  MOVWF  FEA
82C6:  MOVLW  48
82C8:  MOVWF  FE9
82CA:  MOVLW  00
82CC:  CALL   0254
82D0:  TBLRD*-
82D2:  TBLRD*+
82D4:  MOVF   FF5,W
82D6:  MOVWF  FEE
82D8:  IORLW  00
82DA:  BNZ   82D2
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
82DC:  MOVLW  B0
82DE:  MOVWF  FF6
82E0:  MOVLW  4D
82E2:  MOVWF  FF7
82E4:  CLRF   19
82E6:  BTFSC  FF2.7
82E8:  BSF    19.7
82EA:  BCF    FF2.7
82EC:  CALL   07A0
82F0:  BTFSC  19.7
82F2:  BSF    FF2.7
....................                 break; 
82F4:  MOVLB  4
82F6:  GOTO   9918
82FA:  MOVLB  0
....................               } 
....................                
....................               strcpy(msg_buffer2,"rsfact"); 
82FC:  MOVLW  03
82FE:  MOVWF  FEA
8300:  MOVLW  16
8302:  MOVWF  FE9
8304:  MOVLW  00
8306:  CALL   014A
830A:  TBLRD*-
830C:  TBLRD*+
830E:  MOVF   FF5,W
8310:  MOVWF  FEE
8312:  IORLW  00
8314:  BNZ   830C
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
8316:  MOVLW  03
8318:  MOVLB  A
831A:  MOVWF  x8F
831C:  MOVLW  16
831E:  MOVWF  x8E
8320:  MOVLW  02
8322:  MOVWF  x91
8324:  MOVLW  D0
8326:  MOVWF  x90
8328:  CLRF   x93
832A:  MOVLW  06
832C:  MOVWF  x92
832E:  MOVLB  0
8330:  CALL   569E
8334:  MOVF   01,F
8336:  BNZ   837E
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
8338:  MOVLW  0E
833A:  MOVLB  4
833C:  MOVWF  x95
....................                   fprintf(COM2,"reset factory\n\r"); 
833E:  MOVLW  CE
8340:  MOVWF  FF6
8342:  MOVLW  4D
8344:  MOVWF  FF7
8346:  CLRF   19
8348:  BTFSC  FF2.7
834A:  BSF    19.7
834C:  BCF    FF2.7
834E:  MOVLB  0
8350:  CALL   07A0
8354:  BTFSC  19.7
8356:  BSF    FF2.7
....................                   rstfact(); 
8358:  GOTO   5A50
....................                   strcpy(reply_buffer,"done"); 
835C:  MOVLW  03
835E:  MOVWF  FEA
8360:  MOVLW  48
8362:  MOVWF  FE9
8364:  MOVLW  00
8366:  CALL   0134
836A:  TBLRD*-
836C:  TBLRD*+
836E:  MOVF   FF5,W
8370:  MOVWF  FEE
8372:  IORLW  00
8374:  BNZ   836C
....................                   break; 
8376:  MOVLB  4
8378:  GOTO   9918
837C:  MOVLB  0
....................               }    
....................               strcpy(msg_buffer2,"kofkb new"); 
837E:  MOVLW  03
8380:  MOVWF  FEA
8382:  MOVLW  16
8384:  MOVWF  FE9
8386:  MOVLW  00
8388:  CALL   0296
838C:  TBLRD*-
838E:  TBLRD*+
8390:  MOVF   FF5,W
8392:  MOVWF  FEE
8394:  IORLW  00
8396:  BNZ   838E
....................               if(!strncmp(msg_buffer2,sim_bug,9))  
8398:  MOVLW  03
839A:  MOVLB  A
839C:  MOVWF  x8F
839E:  MOVLW  16
83A0:  MOVWF  x8E
83A2:  MOVLW  02
83A4:  MOVWF  x91
83A6:  MOVLW  D0
83A8:  MOVWF  x90
83AA:  CLRF   x93
83AC:  MOVLW  09
83AE:  MOVWF  x92
83B0:  MOVLB  0
83B2:  CALL   569E
83B6:  MOVF   01,F
83B8:  BNZ   8420
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
83BA:  MOVLW  0E
83BC:  MOVLB  4
83BE:  MOVWF  x95
....................                   fprintf(COM2,"changed to new keyboard\n\r"); 
83C0:  MOVLW  DE
83C2:  MOVWF  FF6
83C4:  MOVLW  4D
83C6:  MOVWF  FF7
83C8:  CLRF   19
83CA:  BTFSC  FF2.7
83CC:  BSF    19.7
83CE:  BCF    FF2.7
83D0:  MOVLB  0
83D2:  CALL   07A0
83D6:  BTFSC  19.7
83D8:  BSF    FF2.7
....................                   type_KB=1; 
83DA:  MOVLW  01
83DC:  MOVLB  1
83DE:  MOVWF  x13
83E0:  CLRF   19
83E2:  BTFSC  FF2.7
83E4:  BSF    19.7
83E6:  BCF    FF2.7
....................                   write_ext_eeprom(kindofKB,type_KB); 
83E8:  MOVLB  A
83EA:  CLRF   xC8
83EC:  MOVLW  7E
83EE:  MOVWF  xC7
83F0:  MOVFF  113,AC9
83F4:  MOVLB  0
83F6:  CALL   3E78
83FA:  BTFSC  19.7
83FC:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
83FE:  MOVLW  03
8400:  MOVWF  FEA
8402:  MOVLW  48
8404:  MOVWF  FE9
8406:  MOVLW  00
8408:  CALL   0134
840C:  TBLRD*-
840E:  TBLRD*+
8410:  MOVF   FF5,W
8412:  MOVWF  FEE
8414:  IORLW  00
8416:  BNZ   840E
....................                   break; 
8418:  MOVLB  4
841A:  GOTO   9918
841E:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"kofkb old"); 
8420:  MOVLW  03
8422:  MOVWF  FEA
8424:  MOVLW  16
8426:  MOVWF  FE9
8428:  MOVLW  00
842A:  CALL   02B0
842E:  TBLRD*-
8430:  TBLRD*+
8432:  MOVF   FF5,W
8434:  MOVWF  FEE
8436:  IORLW  00
8438:  BNZ   8430
....................               if(!strncmp(msg_buffer2,sim_bug,9))  
843A:  MOVLW  03
843C:  MOVLB  A
843E:  MOVWF  x8F
8440:  MOVLW  16
8442:  MOVWF  x8E
8444:  MOVLW  02
8446:  MOVWF  x91
8448:  MOVLW  D0
844A:  MOVWF  x90
844C:  CLRF   x93
844E:  MOVLW  09
8450:  MOVWF  x92
8452:  MOVLB  0
8454:  CALL   569E
8458:  MOVF   01,F
845A:  BNZ   84C0
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
845C:  MOVLW  0E
845E:  MOVLB  4
8460:  MOVWF  x95
....................                   fprintf(COM2,"changed to old keyboard\n\r"); 
8462:  MOVLW  F8
8464:  MOVWF  FF6
8466:  MOVLW  4D
8468:  MOVWF  FF7
846A:  CLRF   19
846C:  BTFSC  FF2.7
846E:  BSF    19.7
8470:  BCF    FF2.7
8472:  MOVLB  0
8474:  CALL   07A0
8478:  BTFSC  19.7
847A:  BSF    FF2.7
....................                   type_KB=0; 
847C:  MOVLB  1
847E:  CLRF   x13
8480:  CLRF   19
8482:  BTFSC  FF2.7
8484:  BSF    19.7
8486:  BCF    FF2.7
....................                   write_ext_eeprom(kindofKB,type_KB); 
8488:  MOVLB  A
848A:  CLRF   xC8
848C:  MOVLW  7E
848E:  MOVWF  xC7
8490:  MOVFF  113,AC9
8494:  MOVLB  0
8496:  CALL   3E78
849A:  BTFSC  19.7
849C:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
849E:  MOVLW  03
84A0:  MOVWF  FEA
84A2:  MOVLW  48
84A4:  MOVWF  FE9
84A6:  MOVLW  00
84A8:  CALL   0134
84AC:  TBLRD*-
84AE:  TBLRD*+
84B0:  MOVF   FF5,W
84B2:  MOVWF  FEE
84B4:  IORLW  00
84B6:  BNZ   84AE
....................                   break; 
84B8:  MOVLB  4
84BA:  GOTO   9918
84BE:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"trantime"); 
84C0:  MOVLW  03
84C2:  MOVWF  FEA
84C4:  MOVLW  16
84C6:  MOVWF  FE9
84C8:  MOVLW  00
84CA:  CALL   02CA
84CE:  TBLRD*-
84D0:  TBLRD*+
84D2:  MOVF   FF5,W
84D4:  MOVWF  FEE
84D6:  IORLW  00
84D8:  BNZ   84D0
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
84DA:  MOVLW  03
84DC:  MOVLB  A
84DE:  MOVWF  x8F
84E0:  MOVLW  16
84E2:  MOVWF  x8E
84E4:  MOVLW  02
84E6:  MOVWF  x91
84E8:  MOVLW  D0
84EA:  MOVWF  x90
84EC:  CLRF   x93
84EE:  MOVLW  08
84F0:  MOVWF  x92
84F2:  MOVLB  0
84F4:  CALL   569E
84F8:  MOVF   01,F
84FA:  BTFSS  FD8.2
84FC:  BRA    8644
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
84FE:  MOVLW  0E
8500:  MOVLB  4
8502:  MOVWF  x95
....................                 memset(msg_buffer2,0,sizeof(msg_buffer2)); 
8504:  MOVLW  03
8506:  MOVWF  FEA
8508:  MOVLW  16
850A:  MOVWF  FE9
850C:  CLRF   00
850E:  CLRF   02
8510:  MOVLW  32
8512:  MOVWF  01
8514:  MOVLB  0
8516:  CALL   447A
....................                 //for(i=0;i<3;i++)msg_buffer2[i]=sim_bug[i+9]; 
....................                 if((sim_bug[9]>47)&&(sim_bug[9]<58))  
851A:  MOVLB  2
851C:  MOVF   xD9,W
851E:  SUBLW  2F
8520:  BC    8604
8522:  MOVF   xD9,W
8524:  SUBLW  39
8526:  BNC   8604
....................                 { 
....................                    delaycharaction = (sim_bug[9]-48)*10; 
8528:  MOVLW  30
852A:  SUBWF  xD9,W
852C:  MULLW  0A
852E:  MOVFF  FF3,146
8532:  MOVLB  1
....................                    if((sim_bug[10]>47)&&(sim_bug[10]<58))delaycharaction=delaycharaction+(sim_bug[10]-48); 
8534:  MOVLB  2
8536:  MOVF   xDA,W
8538:  SUBLW  2F
853A:  BC    854E
853C:  MOVF   xDA,W
853E:  SUBLW  39
8540:  BNC   854E
8542:  MOVLW  30
8544:  SUBWF  xDA,W
8546:  MOVLB  1
8548:  ADDWF  x46,F
....................                      else delaycharaction = sim_bug[9]-48; 
854A:  BRA    8556
854C:  MOVLB  2
854E:  MOVLW  30
8550:  SUBWF  xD9,W
8552:  MOVLB  1
8554:  MOVWF  x46
....................                   fprintf(COM2,"tran time = %d\n\r",delaycharaction);   
8556:  MOVLW  12
8558:  MOVWF  FF6
855A:  MOVLW  4E
855C:  MOVWF  FF7
855E:  CLRF   19
8560:  BTFSC  FF2.7
8562:  BSF    19.7
8564:  BCF    FF2.7
8566:  MOVLW  0C
8568:  MOVLB  A
856A:  MOVWF  xD3
856C:  MOVLB  0
856E:  CALL   1718
8572:  BTFSC  19.7
8574:  BSF    FF2.7
8576:  CLRF   19
8578:  BTFSC  FF2.7
857A:  BSF    19.7
857C:  BCF    FF2.7
857E:  MOVFF  146,ABF
8582:  MOVLW  18
8584:  MOVLB  A
8586:  MOVWF  xC0
8588:  MOVLB  0
858A:  CALL   182C
858E:  BTFSC  19.7
8590:  BSF    FF2.7
8592:  CLRF   19
8594:  BTFSC  FF2.7
8596:  BSF    19.7
8598:  BCF    FF2.7
859A:  MOVLW  0A
859C:  MOVLB  A
859E:  MOVWF  xDF
85A0:  MOVLB  0
85A2:  CALL   075A
85A6:  BTFSC  19.7
85A8:  BSF    FF2.7
85AA:  CLRF   19
85AC:  BTFSC  FF2.7
85AE:  BSF    19.7
85B0:  BCF    FF2.7
85B2:  MOVLW  0D
85B4:  MOVLB  A
85B6:  MOVWF  xDF
85B8:  MOVLB  0
85BA:  CALL   075A
85BE:  BTFSC  19.7
85C0:  BSF    FF2.7
85C2:  CLRF   19
85C4:  BTFSC  FF2.7
85C6:  BSF    19.7
85C8:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_delaytime,delaycharaction); 
85CA:  MOVLB  A
85CC:  CLRF   xC8
85CE:  MOVLW  94
85D0:  MOVWF  xC7
85D2:  MOVFF  146,AC9
85D6:  MOVLB  0
85D8:  CALL   3E78
85DC:  BTFSC  19.7
85DE:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
85E0:  MOVLW  03
85E2:  MOVWF  FEA
85E4:  MOVLW  48
85E6:  MOVWF  FE9
85E8:  MOVLW  00
85EA:  CALL   0134
85EE:  TBLRD*-
85F0:  TBLRD*+
85F2:  MOVF   FF5,W
85F4:  MOVWF  FEE
85F6:  IORLW  00
85F8:  BNZ   85F0
....................                   break; 
85FA:  MOVLB  4
85FC:  GOTO   9918
....................                 } 
....................                   else  
8600:  BRA    863E
8602:  MOVLB  2
....................                      { 
....................                         fprintf(COM2,"\n\rplease check your syntax\n\r"); 
8604:  MOVLW  24
8606:  MOVWF  FF6
8608:  MOVLW  4E
860A:  MOVWF  FF7
860C:  CLRF   19
860E:  BTFSC  FF2.7
8610:  BSF    19.7
8612:  BCF    FF2.7
8614:  MOVLB  0
8616:  CALL   07A0
861A:  BTFSC  19.7
861C:  BSF    FF2.7
....................                         strcpy(reply_buffer,"please check your syntax");  
861E:  MOVLW  03
8620:  MOVWF  FEA
8622:  MOVLW  48
8624:  MOVWF  FE9
8626:  MOVLW  00
8628:  CALL   0254
862C:  TBLRD*-
862E:  TBLRD*+
8630:  MOVF   FF5,W
8632:  MOVWF  FEE
8634:  IORLW  00
8636:  BNZ   862E
....................                         break; 
8638:  MOVLB  4
863A:  GOTO   9918
....................                      } 
....................                 break; 
863E:  GOTO   9918
8642:  MOVLB  0
....................               } 
....................                 
....................               strcpy(msg_buffer2,"autosending"); 
8644:  MOVLW  03
8646:  MOVWF  FEA
8648:  MOVLW  16
864A:  MOVWF  FE9
864C:  MOVLW  00
864E:  CALL   02E4
8652:  TBLRD*-
8654:  TBLRD*+
8656:  MOVF   FF5,W
8658:  MOVWF  FEE
865A:  IORLW  00
865C:  BNZ   8654
....................               if(!strncmp(msg_buffer2,sim_bug,11))  
865E:  MOVLW  03
8660:  MOVLB  A
8662:  MOVWF  x8F
8664:  MOVLW  16
8666:  MOVWF  x8E
8668:  MOVLW  02
866A:  MOVWF  x91
866C:  MOVLW  D0
866E:  MOVWF  x90
8670:  CLRF   x93
8672:  MOVLW  0B
8674:  MOVWF  x92
8676:  MOVLB  0
8678:  CALL   569E
867C:  MOVF   01,F
867E:  BTFSS  FD8.2
8680:  BRA    886E
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
8682:  MOVLW  0E
8684:  MOVLB  4
8686:  MOVWF  x95
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+12]; 
8688:  MOVLB  9
868A:  CLRF   xD2
868C:  MOVF   xD2,W
868E:  SUBLW  13
8690:  BNC   86CC
8692:  CLRF   03
8694:  MOVF   xD2,W
8696:  ADDLW  16
8698:  MOVWF  01
869A:  MOVLW  03
869C:  ADDWFC 03,F
869E:  MOVFF  03,A8F
86A2:  MOVLW  0C
86A4:  MOVLB  9
86A6:  ADDWF  xD2,W
86A8:  CLRF   03
86AA:  ADDLW  D0
86AC:  MOVWF  FE9
86AE:  MOVLW  02
86B0:  ADDWFC 03,W
86B2:  MOVWF  FEA
86B4:  MOVFF  FEF,A90
86B8:  MOVLB  A
86BA:  MOVFF  A8F,FEA
86BE:  MOVFF  01,FE9
86C2:  MOVFF  A90,FEF
86C6:  MOVLB  9
86C8:  INCF   xD2,F
86CA:  BRA    868C
....................                 strcpy(msg_buffer1,"on"); 
86CC:  MOVLW  03
86CE:  MOVWF  FEA
86D0:  MOVLW  02
86D2:  MOVWF  FE9
86D4:  MOVLW  00
86D6:  MOVLB  0
86D8:  CALL   022C
86DC:  TBLRD*-
86DE:  TBLRD*+
86E0:  MOVF   FF5,W
86E2:  MOVWF  FEE
86E4:  IORLW  00
86E6:  BNZ   86DE
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
86E8:  MOVLW  03
86EA:  MOVLB  A
86EC:  MOVWF  x8F
86EE:  MOVLW  16
86F0:  MOVWF  x8E
86F2:  MOVLW  03
86F4:  MOVWF  x91
86F6:  MOVLW  02
86F8:  MOVWF  x90
86FA:  CLRF   x93
86FC:  MOVWF  x92
86FE:  MOVLB  0
8700:  CALL   569E
8704:  MOVF   01,F
8706:  BNZ   8784
....................                 { 
....................                   #if defined(twonumber)  
....................                      two_number_sending=0; 
8708:  MOVLB  4
870A:  CLRF   x9F
....................                   #endif    
....................                   fprintf(COM2,"\n\rautosending turn on\n\r"); 
870C:  MOVLW  42
870E:  MOVWF  FF6
8710:  MOVLW  4E
8712:  MOVWF  FF7
8714:  CLRF   19
8716:  BTFSC  FF2.7
8718:  BSF    19.7
871A:  BCF    FF2.7
871C:  MOVLB  0
871E:  CALL   07A0
8722:  BTFSC  19.7
8724:  BSF    FF2.7
....................                   auto_sending = 1; 
8726:  MOVLW  01
8728:  MOVLB  4
872A:  MOVWF  x99
872C:  CLRF   19
872E:  BTFSC  FF2.7
8730:  BSF    19.7
8732:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_autosending,auto_sending); 
8734:  MOVLB  A
8736:  CLRF   xC8
8738:  MOVLW  93
873A:  MOVWF  xC7
873C:  MOVFF  499,AC9
8740:  MOVLB  0
8742:  CALL   3E78
8746:  BTFSC  19.7
8748:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r"); 
874A:  MOVLW  5A
874C:  MOVWF  FF6
874E:  MOVLW  4E
8750:  MOVWF  FF7
8752:  CLRF   19
8754:  BTFSC  FF2.7
8756:  BSF    19.7
8758:  BCF    FF2.7
875A:  CALL   07A0
875E:  BTFSC  19.7
8760:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8762:  MOVLW  03
8764:  MOVWF  FEA
8766:  MOVLW  48
8768:  MOVWF  FE9
876A:  MOVLW  00
876C:  CALL   0134
8770:  TBLRD*-
8772:  TBLRD*+
8774:  MOVF   FF5,W
8776:  MOVWF  FEE
8778:  IORLW  00
877A:  BNZ   8772
....................                   break; 
877C:  MOVLB  4
877E:  GOTO   9918
8782:  MOVLB  0
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
8784:  MOVLW  03
8786:  MOVWF  FEA
8788:  MOVLW  02
878A:  MOVWF  FE9
878C:  MOVLW  00
878E:  CALL   0240
8792:  TBLRD*-
8794:  TBLRD*+
8796:  MOVF   FF5,W
8798:  MOVWF  FEE
879A:  IORLW  00
879C:  BNZ   8794
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
879E:  MOVLW  03
87A0:  MOVLB  A
87A2:  MOVWF  x8F
87A4:  MOVLW  16
87A6:  MOVWF  x8E
87A8:  MOVLW  03
87AA:  MOVWF  x91
87AC:  MOVLW  02
87AE:  MOVWF  x90
87B0:  CLRF   x93
87B2:  MOVLW  03
87B4:  MOVWF  x92
87B6:  MOVLB  0
87B8:  CALL   569E
87BC:  MOVF   01,F
87BE:  BNZ   8834
....................                 { 
....................                   fprintf(COM2,"\n\rautosending turn off\n\r"); 
87C0:  MOVLW  62
87C2:  MOVWF  FF6
87C4:  MOVLW  4E
87C6:  MOVWF  FF7
87C8:  CLRF   19
87CA:  BTFSC  FF2.7
87CC:  BSF    19.7
87CE:  BCF    FF2.7
87D0:  CALL   07A0
87D4:  BTFSC  19.7
87D6:  BSF    FF2.7
....................                   auto_sending = 0; 
87D8:  MOVLB  4
87DA:  CLRF   x99
87DC:  CLRF   19
87DE:  BTFSC  FF2.7
87E0:  BSF    19.7
87E2:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_autosending,auto_sending); 
87E4:  MOVLB  A
87E6:  CLRF   xC8
87E8:  MOVLW  93
87EA:  MOVWF  xC7
87EC:  MOVFF  499,AC9
87F0:  MOVLB  0
87F2:  CALL   3E78
87F6:  BTFSC  19.7
87F8:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r"); 
87FA:  MOVLW  7C
87FC:  MOVWF  FF6
87FE:  MOVLW  4E
8800:  MOVWF  FF7
8802:  CLRF   19
8804:  BTFSC  FF2.7
8806:  BSF    19.7
8808:  BCF    FF2.7
880A:  CALL   07A0
880E:  BTFSC  19.7
8810:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8812:  MOVLW  03
8814:  MOVWF  FEA
8816:  MOVLW  48
8818:  MOVWF  FE9
881A:  MOVLW  00
881C:  CALL   0134
8820:  TBLRD*-
8822:  TBLRD*+
8824:  MOVF   FF5,W
8826:  MOVWF  FEE
8828:  IORLW  00
882A:  BNZ   8822
....................                   break; 
882C:  MOVLB  4
882E:  GOTO   9918
8832:  MOVLB  0
....................                 } 
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
8834:  MOVLW  84
8836:  MOVWF  FF6
8838:  MOVLW  4E
883A:  MOVWF  FF7
883C:  CLRF   19
883E:  BTFSC  FF2.7
8840:  BSF    19.7
8842:  BCF    FF2.7
8844:  CALL   07A0
8848:  BTFSC  19.7
884A:  BSF    FF2.7
....................                 strcpy(reply_buffer,"please check your syntax"); 
884C:  MOVLW  03
884E:  MOVWF  FEA
8850:  MOVLW  48
8852:  MOVWF  FE9
8854:  MOVLW  00
8856:  CALL   0254
885A:  TBLRD*-
885C:  TBLRD*+
885E:  MOVF   FF5,W
8860:  MOVWF  FEE
8862:  IORLW  00
8864:  BNZ   885C
....................                 //fprintf(COM2," exit\n\r"); 
....................                 break; 
8866:  MOVLB  4
8868:  GOTO   9918
886C:  MOVLB  0
....................               } 
....................  
....................               strcpy(msg_buffer2,"qullf"); 
886E:  MOVLW  03
8870:  MOVWF  FEA
8872:  MOVLW  16
8874:  MOVWF  FE9
8876:  MOVLW  00
8878:  CALL   0300
887C:  TBLRD*-
887E:  TBLRD*+
8880:  MOVF   FF5,W
8882:  MOVWF  FEE
8884:  IORLW  00
8886:  BNZ   887E
....................               if(!strncmp(msg_buffer2,sim_bug,5))  
8888:  MOVLW  03
888A:  MOVLB  A
888C:  MOVWF  x8F
888E:  MOVLW  16
8890:  MOVWF  x8E
8892:  MOVLW  02
8894:  MOVWF  x91
8896:  MOVLW  D0
8898:  MOVWF  x90
889A:  CLRF   x93
889C:  MOVLW  05
889E:  MOVWF  x92
88A0:  MOVLB  0
88A2:  CALL   569E
88A6:  MOVF   01,F
88A8:  BNZ   88EE
....................               { 
....................                 SIM_state=delete_MSG; 
88AA:  MOVLW  06
88AC:  MOVLB  4
88AE:  MOVWF  x95
....................                 fprintf(COM2,"FORMATTING..."); 
88B0:  MOVLW  A2
88B2:  MOVWF  FF6
88B4:  MOVLW  4E
88B6:  MOVWF  FF7
88B8:  CLRF   19
88BA:  BTFSC  FF2.7
88BC:  BSF    19.7
88BE:  BCF    FF2.7
88C0:  MOVLB  0
88C2:  CALL   07A0
88C6:  BTFSC  19.7
88C8:  BSF    FF2.7
....................                 ease_eeprom(); 
88CA:  GOTO   5D20
....................                 fprintf(COM2," exit\n\r"); 
88CE:  MOVLW  B0
88D0:  MOVWF  FF6
88D2:  MOVLW  4E
88D4:  MOVWF  FF7
88D6:  CLRF   19
88D8:  BTFSC  FF2.7
88DA:  BSF    19.7
88DC:  BCF    FF2.7
88DE:  CALL   07A0
88E2:  BTFSC  19.7
88E4:  BSF    FF2.7
....................                 break; 
88E6:  MOVLB  4
88E8:  GOTO   9918
88EC:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"format"); 
88EE:  MOVLW  03
88F0:  MOVWF  FEA
88F2:  MOVLW  16
88F4:  MOVWF  FE9
88F6:  MOVLW  00
88F8:  CALL   0316
88FC:  TBLRD*-
88FE:  TBLRD*+
8900:  MOVF   FF5,W
8902:  MOVWF  FEE
8904:  IORLW  00
8906:  BNZ   88FE
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
8908:  MOVLW  03
890A:  MOVLB  A
890C:  MOVWF  x8F
890E:  MOVLW  16
8910:  MOVWF  x8E
8912:  MOVLW  02
8914:  MOVWF  x91
8916:  MOVLW  D0
8918:  MOVWF  x90
891A:  CLRF   x93
891C:  MOVLW  06
891E:  MOVWF  x92
8920:  MOVLB  0
8922:  CALL   569E
8926:  MOVF   01,F
8928:  BNZ   8988
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
892A:  MOVLW  0E
892C:  MOVLB  4
892E:  MOVWF  x95
....................                   fprintf(COM2,"FORMATTING..."); 
8930:  MOVLW  B8
8932:  MOVWF  FF6
8934:  MOVLW  4E
8936:  MOVWF  FF7
8938:  CLRF   19
893A:  BTFSC  FF2.7
893C:  BSF    19.7
893E:  BCF    FF2.7
8940:  MOVLB  0
8942:  CALL   07A0
8946:  BTFSC  19.7
8948:  BSF    FF2.7
....................                   format_eepromext(); 
894A:  GOTO   5DD8
....................                   fprintf(COM2," exit\n\r"); 
894E:  MOVLW  C6
8950:  MOVWF  FF6
8952:  MOVLW  4E
8954:  MOVWF  FF7
8956:  CLRF   19
8958:  BTFSC  FF2.7
895A:  BSF    19.7
895C:  BCF    FF2.7
895E:  CALL   07A0
8962:  BTFSC  19.7
8964:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8966:  MOVLW  03
8968:  MOVWF  FEA
896A:  MOVLW  48
896C:  MOVWF  FE9
896E:  MOVLW  00
8970:  CALL   0134
8974:  TBLRD*-
8976:  TBLRD*+
8978:  MOVF   FF5,W
897A:  MOVWF  FEE
897C:  IORLW  00
897E:  BNZ   8976
....................                   break; 
8980:  MOVLB  4
8982:  GOTO   9918
8986:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"countrec"); 
8988:  MOVLW  03
898A:  MOVWF  FEA
898C:  MOVLW  16
898E:  MOVWF  FE9
8990:  MOVLW  00
8992:  CALL   032E
8996:  TBLRD*-
8998:  TBLRD*+
899A:  MOVF   FF5,W
899C:  MOVWF  FEE
899E:  IORLW  00
89A0:  BNZ   8998
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
89A2:  MOVLW  03
89A4:  MOVLB  A
89A6:  MOVWF  x8F
89A8:  MOVLW  16
89AA:  MOVWF  x8E
89AC:  MOVLW  02
89AE:  MOVWF  x91
89B0:  MOVLW  D0
89B2:  MOVWF  x90
89B4:  CLRF   x93
89B6:  MOVLW  08
89B8:  MOVWF  x92
89BA:  MOVLB  0
89BC:  CALL   569E
89C0:  MOVF   01,F
89C2:  BTFSS  FD8.2
89C4:  BRA    8B2A
....................               {   
....................                   len=0; 
89C6:  MOVLB  9
89C8:  CLRF   xD6
89CA:  CLRF   xD5
89CC:  CLRF   19
89CE:  BTFSC  FF2.7
89D0:  BSF    19.7
89D2:  BCF    FF2.7
....................                   cards=get_countcard(); 
89D4:  MOVLB  0
89D6:  CALL   39FC
89DA:  BTFSC  19.7
89DC:  BSF    FF2.7
89DE:  MOVFF  02,9CB
89E2:  MOVFF  01,9CA
....................                   strcpy(msg_buffer2,"device has "); 
89E6:  MOVLW  03
89E8:  MOVWF  FEA
89EA:  MOVLW  16
89EC:  MOVWF  FE9
89EE:  MOVLW  00
89F0:  CALL   0348
89F4:  TBLRD*-
89F6:  TBLRD*+
89F8:  MOVF   FF5,W
89FA:  MOVWF  FEE
89FC:  IORLW  00
89FE:  BNZ   89F6
....................                   len=pre_msg(msg_buffer2,msg_data_sending,0); 
8A00:  MOVLW  03
8A02:  MOVLB  A
8A04:  MOVWF  x8F
8A06:  MOVLW  16
8A08:  MOVWF  x8E
8A0A:  MOVLW  01
8A0C:  MOVWF  x91
8A0E:  MOVLW  B8
8A10:  MOVWF  x90
8A12:  CLRF   x93
8A14:  CLRF   x92
8A16:  MOVLB  0
8A18:  CALL   5F32
8A1C:  MOVLB  9
8A1E:  CLRF   xD6
8A20:  MOVFF  01,9D5
....................                   itoa(cards,10,string); 
8A24:  MOVLB  A
8A26:  CLRF   x91
8A28:  CLRF   x90
8A2A:  MOVFF  9CB,A8F
8A2E:  MOVFF  9CA,A8E
8A32:  MOVLW  0A
8A34:  MOVWF  x92
8A36:  MOVLW  09
8A38:  MOVWF  x94
8A3A:  MOVLW  DB
8A3C:  MOVWF  x93
8A3E:  MOVLB  0
8A40:  CALL   60E2
....................                   len=pre_msg(string,msg_data_sending,len); 
8A44:  MOVLW  09
8A46:  MOVLB  A
8A48:  MOVWF  x8F
8A4A:  MOVLW  DB
8A4C:  MOVWF  x8E
8A4E:  MOVLW  01
8A50:  MOVWF  x91
8A52:  MOVLW  B8
8A54:  MOVWF  x90
8A56:  MOVFF  9D6,A93
8A5A:  MOVFF  9D5,A92
8A5E:  MOVLB  0
8A60:  CALL   5F32
8A64:  MOVLB  9
8A66:  CLRF   xD6
8A68:  MOVFF  01,9D5
....................                   strcpy(msg_buffer2," transaction "); 
8A6C:  MOVLW  03
8A6E:  MOVWF  FEA
8A70:  MOVLW  16
8A72:  MOVWF  FE9
8A74:  MOVLW  00
8A76:  MOVLB  0
8A78:  CALL   0364
8A7C:  TBLRD*-
8A7E:  TBLRD*+
8A80:  MOVF   FF5,W
8A82:  MOVWF  FEE
8A84:  IORLW  00
8A86:  BNZ   8A7E
....................                   len=pre_msg(msg_buffer2,msg_data_sending,len); 
8A88:  MOVLW  03
8A8A:  MOVLB  A
8A8C:  MOVWF  x8F
8A8E:  MOVLW  16
8A90:  MOVWF  x8E
8A92:  MOVLW  01
8A94:  MOVWF  x91
8A96:  MOVLW  B8
8A98:  MOVWF  x90
8A9A:  MOVFF  9D6,A93
8A9E:  MOVFF  9D5,A92
8AA2:  MOVLB  0
8AA4:  CALL   5F32
8AA8:  MOVLB  9
8AAA:  CLRF   xD6
8AAC:  MOVFF  01,9D5
....................                   SIM_state=MSG_sending; 
8AB0:  MOVLW  08
8AB2:  MOVLB  4
8AB4:  MOVWF  x95
....................                   lastlen=0; 
8AB6:  MOVLB  9
8AB8:  CLRF   xD1
8ABA:  CLRF   xD0
....................                   fprintf(COM2,"device has %lu transaction \n\r",cards); 
8ABC:  MOVLW  CE
8ABE:  MOVWF  FF6
8AC0:  MOVLW  4E
8AC2:  MOVWF  FF7
8AC4:  CLRF   19
8AC6:  BTFSC  FF2.7
8AC8:  BSF    19.7
8ACA:  BCF    FF2.7
8ACC:  MOVLW  0B
8ACE:  MOVLB  A
8AD0:  MOVWF  xD3
8AD2:  MOVLB  0
8AD4:  CALL   1718
8AD8:  BTFSC  19.7
8ADA:  BSF    FF2.7
8ADC:  MOVLW  10
8ADE:  MOVWF  FE9
8AE0:  CLRF   19
8AE2:  BTFSC  FF2.7
8AE4:  BSF    19.7
8AE6:  BCF    FF2.7
8AE8:  MOVFF  9CB,ABD
8AEC:  MOVFF  9CA,ABC
8AF0:  CALL   1742
8AF4:  BTFSC  19.7
8AF6:  BSF    FF2.7
8AF8:  MOVLW  DC
8AFA:  MOVWF  FF6
8AFC:  MOVLW  4E
8AFE:  MOVWF  FF7
8B00:  CLRF   19
8B02:  BTFSC  FF2.7
8B04:  BSF    19.7
8B06:  BCF    FF2.7
8B08:  MOVLW  0F
8B0A:  MOVLB  A
8B0C:  MOVWF  xD3
8B0E:  MOVLB  0
8B10:  CALL   1718
8B14:  BTFSC  19.7
8B16:  BSF    FF2.7
....................                   countc=0; 
8B18:  MOVLB  9
8B1A:  CLRF   xCD
8B1C:  CLRF   xCC
....................                   count_dwla=0; 
8B1E:  CLRF   xCF
8B20:  CLRF   xCE
....................                   break; 
8B22:  MOVLB  4
8B24:  GOTO   9918
8B28:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"download all"); 
8B2A:  MOVLW  03
8B2C:  MOVWF  FEA
8B2E:  MOVLW  16
8B30:  MOVWF  FE9
8B32:  MOVLW  00
8B34:  CALL   0382
8B38:  TBLRD*-
8B3A:  TBLRD*+
8B3C:  MOVF   FF5,W
8B3E:  MOVWF  FEE
8B40:  IORLW  00
8B42:  BNZ   8B3A
....................               if(!strncmp(msg_buffer2,sim_bug,12)) 
8B44:  MOVLW  03
8B46:  MOVLB  A
8B48:  MOVWF  x8F
8B4A:  MOVLW  16
8B4C:  MOVWF  x8E
8B4E:  MOVLW  02
8B50:  MOVWF  x91
8B52:  MOVLW  D0
8B54:  MOVWF  x90
8B56:  CLRF   x93
8B58:  MOVLW  0C
8B5A:  MOVWF  x92
8B5C:  MOVLB  0
8B5E:  CALL   569E
8B62:  MOVF   01,F
8B64:  BNZ   8BB8
....................               { 
....................                    fprintf(COM2,"download all\n\r");   
8B66:  MOVLW  EC
8B68:  MOVWF  FF6
8B6A:  MOVLW  4E
8B6C:  MOVWF  FF7
8B6E:  CLRF   19
8B70:  BTFSC  FF2.7
8B72:  BSF    19.7
8B74:  BCF    FF2.7
8B76:  CALL   07A0
8B7A:  BTFSC  19.7
8B7C:  BSF    FF2.7
8B7E:  CLRF   19
8B80:  BTFSC  FF2.7
8B82:  BSF    19.7
8B84:  BCF    FF2.7
....................                    count_dwla=get_countcard(); 
8B86:  CALL   39FC
8B8A:  BTFSC  19.7
8B8C:  BSF    FF2.7
8B8E:  MOVFF  02,9CF
8B92:  MOVFF  01,9CE
....................                    len=0; 
8B96:  MOVLB  9
8B98:  CLRF   xD6
8B9A:  CLRF   xD5
....................                    num_card=count_dwla; 
8B9C:  MOVFF  9CF,9C9
8BA0:  MOVFF  9CE,9C8
....................                    SIM_state=pre_cmd; 
8BA4:  MOVLW  07
8BA6:  MOVLB  4
8BA8:  MOVWF  x95
....................                    countc=0; 
8BAA:  MOVLB  9
8BAC:  CLRF   xCD
8BAE:  CLRF   xCC
....................                    break; 
8BB0:  MOVLB  4
8BB2:  GOTO   9918
8BB6:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"download "); 
8BB8:  MOVLW  03
8BBA:  MOVWF  FEA
8BBC:  MOVLW  16
8BBE:  MOVWF  FE9
8BC0:  MOVLW  00
8BC2:  CALL   03A0
8BC6:  TBLRD*-
8BC8:  TBLRD*+
8BCA:  MOVF   FF5,W
8BCC:  MOVWF  FEE
8BCE:  IORLW  00
8BD0:  BNZ   8BC8
....................               if(!strncmp(msg_buffer2,sim_bug,9)) 
8BD2:  MOVLW  03
8BD4:  MOVLB  A
8BD6:  MOVWF  x8F
8BD8:  MOVLW  16
8BDA:  MOVWF  x8E
8BDC:  MOVLW  02
8BDE:  MOVWF  x91
8BE0:  MOVLW  D0
8BE2:  MOVWF  x90
8BE4:  CLRF   x93
8BE6:  MOVLW  09
8BE8:  MOVWF  x92
8BEA:  MOVLB  0
8BEC:  CALL   569E
8BF0:  MOVF   01,F
8BF2:  BTFSS  FD8.2
8BF4:  BRA    8DE6
....................               { 
....................                   if((sim_bug[9]<48)||(sim_bug[9]>57)) 
8BF6:  MOVLB  2
8BF8:  MOVF   xD9,W
8BFA:  SUBLW  2F
8BFC:  BC    8C04
8BFE:  MOVF   xD9,W
8C00:  SUBLW  39
8C02:  BC    8C44
....................                   { 
....................                      SIM_state=SIM_reply; 
8C04:  MOVLW  0E
8C06:  MOVLB  4
8C08:  MOVWF  x95
....................                      fprintf(COM2,"\n\rplease check your syntax\n\r"); 
8C0A:  MOVLW  FC
8C0C:  MOVWF  FF6
8C0E:  MOVLW  4E
8C10:  MOVWF  FF7
8C12:  CLRF   19
8C14:  BTFSC  FF2.7
8C16:  BSF    19.7
8C18:  BCF    FF2.7
8C1A:  MOVLB  0
8C1C:  CALL   07A0
8C20:  BTFSC  19.7
8C22:  BSF    FF2.7
....................                      strcpy(reply_buffer,"please check your syntax"); 
8C24:  MOVLW  03
8C26:  MOVWF  FEA
8C28:  MOVLW  48
8C2A:  MOVWF  FE9
8C2C:  MOVLW  00
8C2E:  CALL   0254
8C32:  TBLRD*-
8C34:  TBLRD*+
8C36:  MOVF   FF5,W
8C38:  MOVWF  FEE
8C3A:  IORLW  00
8C3C:  BNZ   8C34
....................                      break; 
8C3E:  MOVLB  4
8C40:  GOTO   9918
....................                   } 
....................                   i=0; 
8C44:  MOVLB  9
8C46:  CLRF   xD2
....................                   temp=sim_bug[9]; 
8C48:  MOVFF  2D9,9D3
....................                   while(temp!=0) 
....................                   { 
8C4C:  MOVF   xD3,F
8C4E:  BZ    8C7A
....................                      temp=sim_bug[i+9]; 
8C50:  MOVLW  09
8C52:  ADDWF  xD2,W
8C54:  CLRF   03
8C56:  ADDLW  D0
8C58:  MOVWF  FE9
8C5A:  MOVLW  02
8C5C:  ADDWFC 03,W
8C5E:  MOVWF  FEA
8C60:  MOVFF  FEF,9D3
....................                      string[i++]=temp; 
8C64:  MOVF   xD2,W
8C66:  INCF   xD2,F
8C68:  CLRF   03
8C6A:  ADDLW  DB
8C6C:  MOVWF  FE9
8C6E:  MOVLW  09
8C70:  ADDWFC 03,W
8C72:  MOVWF  FEA
8C74:  MOVFF  9D3,FEF
....................                   } 
8C78:  BRA    8C4C
....................                   countc=atoi(string); 
8C7A:  MOVLW  09
8C7C:  MOVLB  A
8C7E:  MOVWF  x8F
8C80:  MOVLW  DB
8C82:  MOVWF  x8E
8C84:  MOVLB  0
8C86:  GOTO   62FE
8C8A:  CLRF   03
8C8C:  MOVFF  01,9CC
8C90:  MOVLB  9
8C92:  MOVFF  03,9CD
8C96:  CLRF   19
8C98:  BTFSC  FF2.7
8C9A:  BSF    19.7
8C9C:  BCF    FF2.7
....................                   //fprintf(COM2,"countc=%lu\n\r",countc); 
....................                   count_dwla=get_countcard(); 
8C9E:  MOVLB  0
8CA0:  CALL   39FC
8CA4:  BTFSC  19.7
8CA6:  BSF    FF2.7
8CA8:  MOVFF  02,9CF
8CAC:  MOVFF  01,9CE
....................                   if(count_dwla<countc) 
8CB0:  MOVLB  9
8CB2:  MOVF   xCF,W
8CB4:  SUBWF  xCD,W
8CB6:  BTFSS  FD8.0
8CB8:  BRA    8DB0
8CBA:  BNZ   8CC2
8CBC:  MOVF   xCC,W
8CBE:  SUBWF  xCE,W
8CC0:  BC    8DB0
....................                   { 
....................                      len=0; 
8CC2:  CLRF   xD6
8CC4:  CLRF   xD5
....................                      strcpy(buftemp2,"Device has only "); 
8CC6:  MOVLW  0A
8CC8:  MOVWF  FEA
8CCA:  MOVLW  5C
8CCC:  MOVWF  FE9
8CCE:  MOVLW  00
8CD0:  MOVLB  0
8CD2:  CALL   03BA
8CD6:  TBLRD*-
8CD8:  TBLRD*+
8CDA:  MOVF   FF5,W
8CDC:  MOVWF  FEE
8CDE:  IORLW  00
8CE0:  BNZ   8CD8
....................                      len=pre_msg(buftemp2,msg_data_sending,0); 
8CE2:  MOVLW  0A
8CE4:  MOVLB  A
8CE6:  MOVWF  x8F
8CE8:  MOVLW  5C
8CEA:  MOVWF  x8E
8CEC:  MOVLW  01
8CEE:  MOVWF  x91
8CF0:  MOVLW  B8
8CF2:  MOVWF  x90
8CF4:  CLRF   x93
8CF6:  CLRF   x92
8CF8:  MOVLB  0
8CFA:  CALL   5F32
8CFE:  MOVLB  9
8D00:  CLRF   xD6
8D02:  MOVFF  01,9D5
....................                      itoa(count_dwla,10,string); 
8D06:  MOVLB  A
8D08:  CLRF   x91
8D0A:  CLRF   x90
8D0C:  MOVFF  9CF,A8F
8D10:  MOVFF  9CE,A8E
8D14:  MOVLW  0A
8D16:  MOVWF  x92
8D18:  MOVLW  09
8D1A:  MOVWF  x94
8D1C:  MOVLW  DB
8D1E:  MOVWF  x93
8D20:  MOVLB  0
8D22:  CALL   60E2
....................                      len=pre_msg(string,msg_data_sending,len); 
8D26:  MOVLW  09
8D28:  MOVLB  A
8D2A:  MOVWF  x8F
8D2C:  MOVLW  DB
8D2E:  MOVWF  x8E
8D30:  MOVLW  01
8D32:  MOVWF  x91
8D34:  MOVLW  B8
8D36:  MOVWF  x90
8D38:  MOVFF  9D6,A93
8D3C:  MOVFF  9D5,A92
8D40:  MOVLB  0
8D42:  CALL   5F32
8D46:  MOVLB  9
8D48:  CLRF   xD6
8D4A:  MOVFF  01,9D5
....................                      strcpy(buftemp2," transaction ");//transaction\n\r 
8D4E:  MOVLW  0A
8D50:  MOVWF  FEA
8D52:  MOVLW  5C
8D54:  MOVWF  FE9
8D56:  MOVLW  00
8D58:  MOVLB  0
8D5A:  CALL   0364
8D5E:  TBLRD*-
8D60:  TBLRD*+
8D62:  MOVF   FF5,W
8D64:  MOVWF  FEE
8D66:  IORLW  00
8D68:  BNZ   8D60
....................                      len=pre_msg(buftemp2,msg_data_sending,len); 
8D6A:  MOVLW  0A
8D6C:  MOVLB  A
8D6E:  MOVWF  x8F
8D70:  MOVLW  5C
8D72:  MOVWF  x8E
8D74:  MOVLW  01
8D76:  MOVWF  x91
8D78:  MOVLW  B8
8D7A:  MOVWF  x90
8D7C:  MOVFF  9D6,A93
8D80:  MOVFF  9D5,A92
8D84:  MOVLB  0
8D86:  CALL   5F32
8D8A:  MOVLB  9
8D8C:  CLRF   xD6
8D8E:  MOVFF  01,9D5
....................                      SIM_state=MSG_sending; 
8D92:  MOVLW  08
8D94:  MOVLB  4
8D96:  MOVWF  x95
....................                      lastlen=0; 
8D98:  MOVLB  9
8D9A:  CLRF   xD1
8D9C:  CLRF   xD0
....................                      count_dwla=0; 
8D9E:  CLRF   xCF
8DA0:  CLRF   xCE
....................                      num_card=0; 
8DA2:  CLRF   xC9
8DA4:  CLRF   xC8
....................                      break; 
8DA6:  MOVLB  4
8DA8:  GOTO   9918
....................                   } 
....................                   else  
8DAC:  BRA    8DE4
8DAE:  MOVLB  9
....................                   { 
....................                      num_card=count_dwla; 
8DB0:  MOVFF  9CF,9C9
8DB4:  MOVFF  9CE,9C8
....................                      countc=num_card-countc; 
8DB8:  MOVF   xCC,W
8DBA:  SUBWF  xC8,W
8DBC:  MOVWF  xCC
8DBE:  MOVF   xCD,W
8DC0:  SUBWFB xC9,W
8DC2:  MOVWF  xCD
....................                      if(countc==0)count_dwla=num_card; 
8DC4:  MOVF   xCC,F
8DC6:  BNZ   8DD6
8DC8:  MOVF   xCD,F
8DCA:  BNZ   8DD6
8DCC:  MOVFF  9C9,9CF
8DD0:  MOVFF  9C8,9CE
....................                      else count_dwla=0; 
8DD4:  BRA    8DDA
8DD6:  CLRF   xCF
8DD8:  CLRF   xCE
....................                      SIM_state=pre_cmd; 
8DDA:  MOVLW  07
8DDC:  MOVLB  4
8DDE:  MOVWF  x95
....................                      break; 
8DE0:  GOTO   9918
....................                   } 
....................                   //SIM_state=delete_MSG; 
....................               } 
....................               else SIM_state=delete_MSG; 
8DE4:  BRA    8DEC
8DE6:  MOVLW  06
8DE8:  MOVLB  4
8DEA:  MOVWF  x95
....................             break; 
8DEC:  GOTO   9918
....................             case delete_MSG: 
....................                receiver_state=1; 
8DF0:  MOVLW  01
8DF2:  MOVLB  1
8DF4:  MOVWF  xB4
....................                fprintf(COM2,"delete_MSG...\n\r"); 
8DF6:  MOVLW  1A
8DF8:  MOVWF  FF6
8DFA:  MOVLW  4F
8DFC:  MOVWF  FF7
8DFE:  CLRF   19
8E00:  BTFSC  FF2.7
8E02:  BSF    19.7
8E04:  BCF    FF2.7
8E06:  MOVLB  0
8E08:  CALL   07A0
8E0C:  BTFSC  19.7
8E0E:  BSF    FF2.7
....................                #ASM BCF    0xF94.7 #ENDASM  
8E10:  BCF    F94.7
....................                   fprintf(COM1,"AT+CMGD=1\r\n"); 
8E12:  MOVLW  2A
8E14:  MOVWF  FF6
8E16:  MOVLW  4F
8E18:  MOVWF  FF7
8E1A:  CALL   53D8
....................                #ASM BSF    0xF94.7 #ENDASM  
8E1E:  BSF    F94.7
8E20:  CLRF   19
8E22:  BTFSC  FF2.7
8E24:  BSF    19.7
8E26:  BCF    FF2.7
....................                del_buf(200,buffer_uart); 
8E28:  MOVLW  C8
8E2A:  MOVLB  A
8E2C:  MOVWF  xC5
8E2E:  MOVLW  01
8E30:  MOVWF  xC7
8E32:  MOVLW  4E
8E34:  MOVWF  xC6
8E36:  MOVLB  0
8E38:  CALL   3A6E
8E3C:  BTFSC  19.7
8E3E:  BSF    FF2.7
....................                //SIM_state=sending_cmd;        
....................                timing_wait=10000; 
8E40:  MOVLW  27
8E42:  MOVLB  4
8E44:  MOVWF  x98
8E46:  MOVLW  10
8E48:  MOVWF  x97
....................                SIM_state= idle; 
8E4A:  MOVLW  0C
8E4C:  MOVWF  x95
....................                over_byte=0; 
8E4E:  MOVLB  1
8E50:  CLRF   xB7
8E52:  CLRF   xB6
....................                output_low(LED); 
8E54:  BCF    F92.6
8E56:  BCF    F89.6
....................                memset(reply_buffer,0,sizeof(reply_buffer));  
8E58:  MOVLW  03
8E5A:  MOVWF  FEA
8E5C:  MOVLW  48
8E5E:  MOVWF  FE9
8E60:  CLRF   00
8E62:  MOVLW  01
8E64:  MOVWF  02
8E66:  MOVLW  18
8E68:  MOVWF  01
8E6A:  MOVLB  0
8E6C:  CALL   447A
....................                memset(buffer_uart,0,sizeof(buffer_uart));                 
8E70:  MOVLW  01
8E72:  MOVWF  FEA
8E74:  MOVLW  4E
8E76:  MOVWF  FE9
8E78:  CLRF   00
8E7A:  CLRF   02
8E7C:  MOVLW  64
8E7E:  MOVWF  01
8E80:  CALL   447A
....................                SIM_reply_st=0; 
8E84:  MOVLB  4
8E86:  CLRF   x9B
....................                #if defined(twonumber) 
....................                   if(two_number_sending==1) 
8E88:  DECFSZ x9F,W
8E8A:  BRA    8E92
....................                   { 
....................                     SIM_state=autosending1;  
8E8C:  MOVLW  13
8E8E:  MOVWF  x95
....................                     two_number_sending=0; 
8E90:  CLRF   x9F
....................                   } 
....................                #endif 
....................             break; 
8E92:  GOTO   9918
....................             case pre_cmd: 
....................                    //fprintf(COM2,"pre_cmd-> num_card,countc, count_dwla=%lu,%lu,%lu\r\n",num_card,countc,count_dwla);   
....................                    if(num_card==0)  
8E96:  MOVLB  9
8E98:  MOVF   xC8,F
8E9A:  BNZ   8EAC
8E9C:  MOVF   xC9,F
8E9E:  BNZ   8EAC
....................                    { 
....................                      SIM_state=delete_MSG; 
8EA0:  MOVLW  06
8EA2:  MOVLB  4
8EA4:  MOVWF  x95
....................                      break; 
8EA6:  GOTO   9918
8EAA:  MOVLB  9
....................                    } 
....................                    len=0; 
8EAC:  CLRF   xD6
8EAE:  CLRF   xD5
....................                    //num_card=1; 
....................                    memset(msg_data_sending,0,sizeof(msg_data_sending));  
8EB0:  MOVLW  01
8EB2:  MOVWF  FEA
8EB4:  MOVLW  B8
8EB6:  MOVWF  FE9
8EB8:  CLRF   00
8EBA:  MOVLW  01
8EBC:  MOVWF  02
8EBE:  MOVLW  18
8EC0:  MOVWF  01
8EC2:  MOVLB  0
8EC4:  CALL   447A
8EC8:  CLRF   19
8ECA:  BTFSC  FF2.7
8ECC:  BSF    19.7
8ECE:  BCF    FF2.7
....................                    addr_dat=num_card*numdata+ptr_start; 
8ED0:  MOVFF  9C9,ABC
8ED4:  MOVFF  9C8,ABB
8ED8:  MOVLB  A
8EDA:  CLRF   xBE
8EDC:  MOVLW  7C
8EDE:  MOVWF  xBD
8EE0:  MOVLB  0
8EE2:  CALL   3A4C
8EE6:  BTFSC  19.7
8EE8:  BSF    FF2.7
8EEA:  MOVLW  96
8EEC:  MOVLB  A
8EEE:  ADDWF  01,W
8EF0:  MOVLB  9
8EF2:  MOVWF  xD7
8EF4:  MOVLW  00
8EF6:  MOVLB  A
8EF8:  ADDWFC 02,W
8EFA:  MOVLB  9
8EFC:  MOVWF  xD8
....................                    I2CEEPROM_read((unsigned int16)(addr_dat-numdata),numdata,buftemp); 
8EFE:  MOVLW  7C
8F00:  SUBWF  xD7,W
8F02:  MOVLB  A
8F04:  MOVWF  x8E
8F06:  MOVLW  00
8F08:  MOVLB  9
8F0A:  SUBWFB xD8,W
8F0C:  MOVLB  A
8F0E:  MOVWF  x8F
8F10:  MOVWF  x91
8F12:  MOVFF  A8E,A90
8F16:  CLRF   x93
8F18:  MOVLW  7C
8F1A:  MOVWF  x92
8F1C:  MOVLW  09
8F1E:  MOVWF  x95
8F20:  MOVLW  E0
8F22:  MOVWF  x94
8F24:  MOVLB  0
8F26:  GOTO   64A2
....................                    itoa(buftemp[0],10,string); 
8F2A:  MOVLB  A
8F2C:  CLRF   x91
8F2E:  CLRF   x90
8F30:  CLRF   x8F
8F32:  MOVFF  9E0,A8E
8F36:  MOVLW  0A
8F38:  MOVWF  x92
8F3A:  MOVLW  09
8F3C:  MOVWF  x94
8F3E:  MOVLW  DB
8F40:  MOVWF  x93
8F42:  MOVLB  0
8F44:  CALL   60E2
....................                    len=pre_msg(string,msg_data_sending,0); 
8F48:  MOVLW  09
8F4A:  MOVLB  A
8F4C:  MOVWF  x8F
8F4E:  MOVLW  DB
8F50:  MOVWF  x8E
8F52:  MOVLW  01
8F54:  MOVWF  x91
8F56:  MOVLW  B8
8F58:  MOVWF  x90
8F5A:  CLRF   x93
8F5C:  CLRF   x92
8F5E:  MOVLB  0
8F60:  CALL   5F32
8F64:  MOVLB  9
8F66:  CLRF   xD6
8F68:  MOVFF  01,9D5
....................                    msg_data_sending[len++]='/'; 
8F6C:  MOVFF  9D6,03
8F70:  MOVF   xD5,W
8F72:  INCF   xD5,F
8F74:  BTFSC  FD8.2
8F76:  INCF   xD6,F
8F78:  MOVLB  A
8F7A:  MOVWF  x8E
8F7C:  MOVLW  B8
8F7E:  ADDWF  x8E,W
8F80:  MOVWF  FE9
8F82:  MOVLW  01
8F84:  ADDWFC 03,W
8F86:  MOVWF  FEA
8F88:  MOVLW  2F
8F8A:  MOVWF  FEF
....................                    itoa(buftemp[1],10,string); 
8F8C:  CLRF   x91
8F8E:  CLRF   x90
8F90:  CLRF   x8F
8F92:  MOVFF  9E1,A8E
8F96:  MOVLW  0A
8F98:  MOVWF  x92
8F9A:  MOVLW  09
8F9C:  MOVWF  x94
8F9E:  MOVLW  DB
8FA0:  MOVWF  x93
8FA2:  MOVLB  0
8FA4:  CALL   60E2
....................                    len=pre_msg(string,msg_data_sending,len); 
8FA8:  MOVLW  09
8FAA:  MOVLB  A
8FAC:  MOVWF  x8F
8FAE:  MOVLW  DB
8FB0:  MOVWF  x8E
8FB2:  MOVLW  01
8FB4:  MOVWF  x91
8FB6:  MOVLW  B8
8FB8:  MOVWF  x90
8FBA:  MOVFF  9D6,A93
8FBE:  MOVFF  9D5,A92
8FC2:  MOVLB  0
8FC4:  CALL   5F32
8FC8:  MOVLB  9
8FCA:  CLRF   xD6
8FCC:  MOVFF  01,9D5
....................                    msg_data_sending[len++]='/'; 
8FD0:  MOVFF  9D6,03
8FD4:  MOVF   xD5,W
8FD6:  INCF   xD5,F
8FD8:  BTFSC  FD8.2
8FDA:  INCF   xD6,F
8FDC:  MOVLB  A
8FDE:  MOVWF  x8E
8FE0:  MOVLW  B8
8FE2:  ADDWF  x8E,W
8FE4:  MOVWF  FE9
8FE6:  MOVLW  01
8FE8:  ADDWFC 03,W
8FEA:  MOVWF  FEA
8FEC:  MOVLW  2F
8FEE:  MOVWF  FEF
....................                    msg_data_sending[len++]=' '; 
8FF0:  MOVLB  9
8FF2:  MOVFF  9D6,03
8FF6:  MOVF   xD5,W
8FF8:  INCF   xD5,F
8FFA:  BTFSC  FD8.2
8FFC:  INCF   xD6,F
8FFE:  MOVLB  A
9000:  MOVWF  x8E
9002:  MOVLW  B8
9004:  ADDWF  x8E,W
9006:  MOVWF  FE9
9008:  MOVLW  01
900A:  ADDWFC 03,W
900C:  MOVWF  FEA
900E:  MOVLW  20
9010:  MOVWF  FEF
....................                    itoa(buftemp[2],10,string); 
9012:  CLRF   x91
9014:  CLRF   x90
9016:  CLRF   x8F
9018:  MOVFF  9E2,A8E
901C:  MOVLW  0A
901E:  MOVWF  x92
9020:  MOVLW  09
9022:  MOVWF  x94
9024:  MOVLW  DB
9026:  MOVWF  x93
9028:  MOVLB  0
902A:  CALL   60E2
....................                    len=pre_msg(string,msg_data_sending,len); 
902E:  MOVLW  09
9030:  MOVLB  A
9032:  MOVWF  x8F
9034:  MOVLW  DB
9036:  MOVWF  x8E
9038:  MOVLW  01
903A:  MOVWF  x91
903C:  MOVLW  B8
903E:  MOVWF  x90
9040:  MOVFF  9D6,A93
9044:  MOVFF  9D5,A92
9048:  MOVLB  0
904A:  CALL   5F32
904E:  MOVLB  9
9050:  CLRF   xD6
9052:  MOVFF  01,9D5
....................                    msg_data_sending[len++]=':'; 
9056:  MOVFF  9D6,03
905A:  MOVF   xD5,W
905C:  INCF   xD5,F
905E:  BTFSC  FD8.2
9060:  INCF   xD6,F
9062:  MOVLB  A
9064:  MOVWF  x8E
9066:  MOVLW  B8
9068:  ADDWF  x8E,W
906A:  MOVWF  FE9
906C:  MOVLW  01
906E:  ADDWFC 03,W
9070:  MOVWF  FEA
9072:  MOVLW  3A
9074:  MOVWF  FEF
....................                    itoa(buftemp[3],10,string); 
9076:  CLRF   x91
9078:  CLRF   x90
907A:  CLRF   x8F
907C:  MOVFF  9E3,A8E
9080:  MOVLW  0A
9082:  MOVWF  x92
9084:  MOVLW  09
9086:  MOVWF  x94
9088:  MOVLW  DB
908A:  MOVWF  x93
908C:  MOVLB  0
908E:  CALL   60E2
....................                    len=pre_msg(string,msg_data_sending,len); 
9092:  MOVLW  09
9094:  MOVLB  A
9096:  MOVWF  x8F
9098:  MOVLW  DB
909A:  MOVWF  x8E
909C:  MOVLW  01
909E:  MOVWF  x91
90A0:  MOVLW  B8
90A2:  MOVWF  x90
90A4:  MOVFF  9D6,A93
90A8:  MOVFF  9D5,A92
90AC:  MOVLB  0
90AE:  CALL   5F32
90B2:  MOVLB  9
90B4:  CLRF   xD6
90B6:  MOVFF  01,9D5
....................                    msg_data_sending[len++]=':'; 
90BA:  MOVFF  9D6,03
90BE:  MOVF   xD5,W
90C0:  INCF   xD5,F
90C2:  BTFSC  FD8.2
90C4:  INCF   xD6,F
90C6:  MOVLB  A
90C8:  MOVWF  x8E
90CA:  MOVLW  B8
90CC:  ADDWF  x8E,W
90CE:  MOVWF  FE9
90D0:  MOVLW  01
90D2:  ADDWFC 03,W
90D4:  MOVWF  FEA
90D6:  MOVLW  3A
90D8:  MOVWF  FEF
....................                    itoa(buftemp[4],10,string); 
90DA:  CLRF   x91
90DC:  CLRF   x90
90DE:  CLRF   x8F
90E0:  MOVFF  9E4,A8E
90E4:  MOVLW  0A
90E6:  MOVWF  x92
90E8:  MOVLW  09
90EA:  MOVWF  x94
90EC:  MOVLW  DB
90EE:  MOVWF  x93
90F0:  MOVLB  0
90F2:  CALL   60E2
....................                    len=pre_msg(string,msg_data_sending,len); 
90F6:  MOVLW  09
90F8:  MOVLB  A
90FA:  MOVWF  x8F
90FC:  MOVLW  DB
90FE:  MOVWF  x8E
9100:  MOVLW  01
9102:  MOVWF  x91
9104:  MOVLW  B8
9106:  MOVWF  x90
9108:  MOVFF  9D6,A93
910C:  MOVFF  9D5,A92
9110:  MOVLB  0
9112:  CALL   5F32
9116:  MOVLB  9
9118:  CLRF   xD6
911A:  MOVFF  01,9D5
....................                    //msg_data_sending[len++]=' '; 
....................                    i=0; 
911E:  CLRF   xD2
....................                    strcpy(buftemp2," Track1>"); 
9120:  MOVLW  0A
9122:  MOVWF  FEA
9124:  MOVLW  5C
9126:  MOVWF  FE9
9128:  MOVLW  00
912A:  MOVLB  0
912C:  CALL   03DC
9130:  TBLRD*-
9132:  TBLRD*+
9134:  MOVF   FF5,W
9136:  MOVWF  FEE
9138:  IORLW  00
913A:  BNZ   9132
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
913C:  MOVLW  0A
913E:  MOVLB  A
9140:  MOVWF  x8F
9142:  MOVLW  5C
9144:  MOVWF  x8E
9146:  MOVLW  01
9148:  MOVWF  x91
914A:  MOVLW  B8
914C:  MOVWF  x90
914E:  MOVFF  9D6,A93
9152:  MOVFF  9D5,A92
9156:  MOVLB  0
9158:  CALL   5F32
915C:  MOVLB  9
915E:  CLRF   xD6
9160:  MOVFF  01,9D5
....................                    temp=0; 
9164:  CLRF   xD3
....................                    while((i<numbyteoftrack1)&&(temp!='?')) 
....................                    { 
9166:  MOVF   xD2,W
9168:  SUBLW  4E
916A:  BNC   91BE
916C:  MOVF   xD3,W
916E:  SUBLW  3F
9170:  BZ    91BE
....................                      temp = buftemp[i+5]; 
9172:  MOVLW  05
9174:  ADDWF  xD2,W
9176:  CLRF   03
9178:  ADDLW  E0
917A:  MOVWF  FE9
917C:  MOVLW  09
917E:  ADDWFC 03,W
9180:  MOVWF  FEA
9182:  MOVFF  FEF,9D3
....................                      //fprintf(COM2,"%c",temp);  
....................                      if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
9186:  MOVF   xD3,W
9188:  SUBLW  1F
918A:  BC    91B4
918C:  MOVF   xD3,W
918E:  SUBLW  7E
9190:  BNC   91B4
9192:  MOVFF  9D6,03
9196:  MOVF   xD5,W
9198:  INCF   xD5,F
919A:  BTFSC  FD8.2
919C:  INCF   xD6,F
919E:  MOVLB  A
91A0:  MOVWF  x8E
91A2:  MOVLW  B8
91A4:  ADDWF  x8E,W
91A6:  MOVWF  FE9
91A8:  MOVLW  01
91AA:  ADDWFC 03,W
91AC:  MOVWF  FEA
91AE:  MOVFF  9D3,FEF
91B2:  MOVLB  9
....................                      i++; 
91B4:  INCF   xD2,F
....................                      if(temp==0)break; 
91B6:  MOVF   xD3,F
91B8:  BNZ   91BC
91BA:  BRA    91BE
....................                    } 
91BC:  BRA    9166
....................                    i=0; 
91BE:  CLRF   xD2
....................                    temp=0; 
91C0:  CLRF   xD3
....................                    strcpy(buftemp2," Track2>"); 
91C2:  MOVLW  0A
91C4:  MOVWF  FEA
91C6:  MOVLW  5C
91C8:  MOVWF  FE9
91CA:  MOVLW  00
91CC:  MOVLB  0
91CE:  CALL   03F6
91D2:  TBLRD*-
91D4:  TBLRD*+
91D6:  MOVF   FF5,W
91D8:  MOVWF  FEE
91DA:  IORLW  00
91DC:  BNZ   91D4
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
91DE:  MOVLW  0A
91E0:  MOVLB  A
91E2:  MOVWF  x8F
91E4:  MOVLW  5C
91E6:  MOVWF  x8E
91E8:  MOVLW  01
91EA:  MOVWF  x91
91EC:  MOVLW  B8
91EE:  MOVWF  x90
91F0:  MOVFF  9D6,A93
91F4:  MOVFF  9D5,A92
91F8:  MOVLB  0
91FA:  CALL   5F32
91FE:  MOVLB  9
9200:  CLRF   xD6
9202:  MOVFF  01,9D5
....................                    while((i<numbyteoftrack2)&&(temp!='?')) 
....................                    { 
9206:  MOVF   xD2,W
9208:  SUBLW  27
920A:  BNC   9260
920C:  MOVF   xD3,W
920E:  SUBLW  3F
9210:  BZ    9260
....................                      temp = buftemp[i+5+numbyteoftrack1]; 
9212:  MOVLW  05
9214:  ADDWF  xD2,W
9216:  ADDLW  4F
9218:  CLRF   03
921A:  ADDLW  E0
921C:  MOVWF  FE9
921E:  MOVLW  09
9220:  ADDWFC 03,W
9222:  MOVWF  FEA
9224:  MOVFF  FEF,9D3
....................                      //fprintf(COM2,"%c",temp);  
....................                      if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
9228:  MOVF   xD3,W
922A:  SUBLW  1F
922C:  BC    9256
922E:  MOVF   xD3,W
9230:  SUBLW  7E
9232:  BNC   9256
9234:  MOVFF  9D6,03
9238:  MOVF   xD5,W
923A:  INCF   xD5,F
923C:  BTFSC  FD8.2
923E:  INCF   xD6,F
9240:  MOVLB  A
9242:  MOVWF  x8E
9244:  MOVLW  B8
9246:  ADDWF  x8E,W
9248:  MOVWF  FE9
924A:  MOVLW  01
924C:  ADDWFC 03,W
924E:  MOVWF  FEA
9250:  MOVFF  9D3,FEF
9254:  MOVLB  9
....................                      i++; 
9256:  INCF   xD2,F
....................                      if(temp==0)break; 
9258:  MOVF   xD3,F
925A:  BNZ   925E
925C:  BRA    9260
....................                    } 
925E:  BRA    9206
....................                    addr_key=EEPROM_KEY_ST+((num_card-1)*50); 
9260:  MOVLW  01
9262:  SUBWF  xC8,W
9264:  MOVLB  A
9266:  MOVWF  x8E
9268:  MOVLW  00
926A:  MOVLB  9
926C:  SUBWFB xC9,W
926E:  MOVLB  A
9270:  MOVWF  x8F
9272:  CLRF   19
9274:  BTFSC  FF2.7
9276:  BSF    19.7
9278:  BCF    FF2.7
927A:  MOVWF  xBC
927C:  MOVFF  A8E,ABB
9280:  CLRF   xBE
9282:  MOVLW  32
9284:  MOVWF  xBD
9286:  MOVLB  0
9288:  CALL   3A4C
928C:  BTFSC  19.7
928E:  BSF    FF2.7
9290:  MOVF   01,W
9292:  ADDLW  47
9294:  MOVLB  9
9296:  MOVWF  xB4
9298:  MOVLW  AA
929A:  ADDWFC 02,W
929C:  MOVWF  xB5
929E:  CLRF   xB6
92A0:  CLRF   xB7
....................                    //if(ptr_card_key>addr_key) 
....................                    //{ 
....................                       strcpy(buftemp2," PIN:"); 
92A2:  MOVLW  0A
92A4:  MOVWF  FEA
92A6:  MOVLW  5C
92A8:  MOVWF  FE9
92AA:  MOVLW  00
92AC:  MOVLB  0
92AE:  CALL   0410
92B2:  TBLRD*-
92B4:  TBLRD*+
92B6:  MOVF   FF5,W
92B8:  MOVWF  FEE
92BA:  IORLW  00
92BC:  BNZ   92B4
....................                       len=pre_msg(buftemp2,msg_data_sending,len); 
92BE:  MOVLW  0A
92C0:  MOVLB  A
92C2:  MOVWF  x8F
92C4:  MOVLW  5C
92C6:  MOVWF  x8E
92C8:  MOVLW  01
92CA:  MOVWF  x91
92CC:  MOVLW  B8
92CE:  MOVWF  x90
92D0:  MOVFF  9D6,A93
92D4:  MOVFF  9D5,A92
92D8:  MOVLB  0
92DA:  CALL   5F32
92DE:  MOVLB  9
92E0:  CLRF   xD6
92E2:  MOVFF  01,9D5
....................                       j=0; 
92E6:  CLRF   xDA
....................                       do 
....................                       { 
....................                         temp=read_ext_eeprom(j+addr_key); 
92E8:  MOVF   xDA,W
92EA:  ADDWF  xB4,W
92EC:  MOVLB  A
92EE:  MOVWF  x8E
92F0:  MOVLW  00
92F2:  MOVLB  9
92F4:  ADDWFC xB5,W
92F6:  MOVLB  A
92F8:  MOVWF  x8F
92FA:  CLRF   19
92FC:  BTFSC  FF2.7
92FE:  BSF    19.7
9300:  BCF    FF2.7
9302:  MOVWF  xC0
9304:  MOVFF  A8E,ABF
9308:  MOVLB  0
930A:  CALL   3954
930E:  BTFSC  19.7
9310:  BSF    FF2.7
9312:  MOVFF  01,9D3
....................                         if(((temp>47)&&(temp<58))||((temp=='#')||(temp=='*'))||(temp>64)&&(temp<91)) 
9316:  MOVLB  9
9318:  MOVF   xD3,W
931A:  SUBLW  2F
931C:  BC    9324
931E:  MOVF   xD3,W
9320:  SUBLW  39
9322:  BC    933C
9324:  MOVF   xD3,W
9326:  SUBLW  23
9328:  BZ    933C
932A:  MOVF   xD3,W
932C:  SUBLW  2A
932E:  BZ    933C
9330:  MOVF   xD3,W
9332:  SUBLW  40
9334:  BC    935E
9336:  MOVF   xD3,W
9338:  SUBLW  5A
933A:  BNC   935E
....................                            msg_data_sending[len++]=temp; 
933C:  MOVFF  9D6,03
9340:  MOVF   xD5,W
9342:  INCF   xD5,F
9344:  BTFSC  FD8.2
9346:  INCF   xD6,F
9348:  MOVLB  A
934A:  MOVWF  x8E
934C:  MOVLW  B8
934E:  ADDWF  x8E,W
9350:  MOVWF  FE9
9352:  MOVLW  01
9354:  ADDWFC 03,W
9356:  MOVWF  FEA
9358:  MOVFF  9D3,FEF
935C:  MOVLB  9
....................                         j++; 
935E:  INCF   xDA,F
....................                       } 
....................                       while((j<key_numbyte)&&(temp!=0)); 
9360:  MOVF   xDA,W
9362:  SUBLW  31
9364:  BNC   936A
9366:  MOVF   xD3,F
9368:  BNZ   92E8
....................                       fprintf(COM2,"%lu character\n\r",len);   
936A:  MOVLW  10
936C:  MOVWF  FE9
936E:  CLRF   19
9370:  BTFSC  FF2.7
9372:  BSF    19.7
9374:  BCF    FF2.7
9376:  MOVFF  9D6,ABD
937A:  MOVFF  9D5,ABC
937E:  MOVLB  0
9380:  CALL   1742
9384:  BTFSC  19.7
9386:  BSF    FF2.7
9388:  MOVLW  39
938A:  MOVWF  FF6
938C:  MOVLW  4F
938E:  MOVWF  FF7
9390:  CLRF   19
9392:  BTFSC  FF2.7
9394:  BSF    19.7
9396:  BCF    FF2.7
9398:  MOVLW  0C
939A:  MOVLB  A
939C:  MOVWF  xD3
939E:  MOVLB  0
93A0:  CALL   1718
93A4:  BTFSC  19.7
93A6:  BSF    FF2.7
....................                      //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                       //addr_key=addr_key+(50); 
....................                     //}        
....................                    lastlen=0;  
93A8:  MOVLB  9
93AA:  CLRF   xD1
93AC:  CLRF   xD0
....................                    //fprintf(COM2,"countc,num_card =%lu,%lu\n\r",countc,num_card); 
....................                    if((countc==num_card)&&(countc!=0)) 
93AE:  MOVF   xC8,W
93B0:  SUBWF  xCC,W
93B2:  BNZ   93CC
93B4:  MOVF   xC9,W
93B6:  SUBWF  xCD,W
93B8:  BNZ   93CC
93BA:  MOVF   xCC,F
93BC:  BNZ   93C2
93BE:  MOVF   xCD,F
93C0:  BZ    93CC
....................                    { 
....................                      SIM_state=delete_MSG;  
93C2:  MOVLW  06
93C4:  MOVLB  4
93C6:  MOVWF  x95
....................                      break; 
93C8:  BRA    9918
93CA:  MOVLB  9
....................                    } 
....................                    num_card--; 
93CC:  MOVF   xC8,W
93CE:  BTFSC  FD8.2
93D0:  DECF   xC9,F
93D2:  DECF   xC8,F
....................                    //fprintf(COM2,"send_oneMSG =%d\n\r",send_oneMSG); 
....................                    if(send_oneMSG==1) 
93D4:  MOVLB  4
93D6:  DECFSZ x9A,W
93D8:  BRA    93E4
....................                    { 
....................                      num_card=0; 
93DA:  MOVLB  9
93DC:  CLRF   xC9
93DE:  CLRF   xC8
....................                      send_oneMSG=0; 
93E0:  MOVLB  4
93E2:  CLRF   x9A
....................                    } 
....................                    SIM_state=MSG_sending;               
93E4:  MOVLW  08
93E6:  MOVWF  x95
....................             break; 
93E8:  BRA    9918
....................             case MSG_sending: 
....................                   fprintf(COM2,"MSG_sending %d\n\r",MSG_sending_st); 
93EA:  MOVLW  46
93EC:  MOVWF  FF6
93EE:  MOVLW  4F
93F0:  MOVWF  FF7
93F2:  CLRF   19
93F4:  BTFSC  FF2.7
93F6:  BSF    19.7
93F8:  BCF    FF2.7
93FA:  MOVLW  0C
93FC:  MOVLB  A
93FE:  MOVWF  xD3
9400:  MOVLB  0
9402:  CALL   1718
9406:  BTFSC  19.7
9408:  BSF    FF2.7
940A:  CLRF   19
940C:  BTFSC  FF2.7
940E:  BSF    19.7
9410:  BCF    FF2.7
9412:  MOVFF  496,ABF
9416:  MOVLW  18
9418:  MOVLB  A
941A:  MOVWF  xC0
941C:  MOVLB  0
941E:  CALL   182C
9422:  BTFSC  19.7
9424:  BSF    FF2.7
9426:  CLRF   19
9428:  BTFSC  FF2.7
942A:  BSF    19.7
942C:  BCF    FF2.7
942E:  MOVLW  0A
9430:  MOVLB  A
9432:  MOVWF  xDF
9434:  MOVLB  0
9436:  CALL   075A
943A:  BTFSC  19.7
943C:  BSF    FF2.7
943E:  CLRF   19
9440:  BTFSC  FF2.7
9442:  BSF    19.7
9444:  BCF    FF2.7
9446:  MOVLW  0D
9448:  MOVLB  A
944A:  MOVWF  xDF
944C:  MOVLB  0
944E:  CALL   075A
9452:  BTFSC  19.7
9454:  BSF    FF2.7
....................                   //fprintf(COM2,"lastlen = %ld\n\r",lastlen); 
....................                    
....................                   //fprintf(COM2,"MSG_sending_st %d\n\r",MSG_sending_st); 
....................                   timing_wait=10000; 
9456:  MOVLW  27
9458:  MOVLB  4
945A:  MOVWF  x98
945C:  MOVLW  10
945E:  MOVWF  x97
....................                output_high(LED); 
9460:  BCF    F92.6
9462:  BSF    F89.6
....................                #ASM BCF    0xF94.7 #ENDASM  
9464:  BCF    F94.7
....................                switch(MSG_sending_st) 
....................                { 
9466:  MOVF   x96,W
9468:  XORLW  00
946A:  MOVLB  0
946C:  BZ    9478
946E:  XORLW  01
9470:  BZ    94D2
9472:  XORLW  03
9474:  BZ    9544
9476:  BRA    9602
....................                   case 0:// configure MSG 
....................                      receiver_state=1; 
9478:  MOVLW  01
947A:  MOVLB  1
947C:  MOVWF  xB4
....................                         fprintf(COM1,"AT+CMGF=1\r\n"); // text mode 
947E:  MOVLW  58
9480:  MOVWF  FF6
9482:  MOVLW  4F
9484:  MOVWF  FF7
9486:  MOVLB  0
9488:  CALL   53D8
....................                      //fprintf(COM2,"AT+CMGF=1\r\n"); // text mode 
....................                      strl= strlen(msg_data_sending); 
948C:  MOVLW  01
948E:  MOVLB  A
9490:  MOVWF  x97
9492:  MOVLW  B8
9494:  MOVWF  x96
9496:  MOVLB  0
9498:  CALL   5EF8
949C:  MOVFF  01,9D9
....................                      MSG_sending_st=1; 
94A0:  MOVLW  01
94A2:  MOVLB  4
94A4:  MOVWF  x96
....................                      if((lastlen==140)&&(msg_data_sending[lastlen]==0)) 
94A6:  MOVLB  9
94A8:  MOVF   xD0,W
94AA:  SUBLW  8C
94AC:  BNZ   94CE
94AE:  MOVF   xD1,F
94B0:  BNZ   94CE
94B2:  MOVLW  B8
94B4:  ADDWF  xD0,W
94B6:  MOVWF  FE9
94B8:  MOVLW  01
94BA:  ADDWFC xD1,W
94BC:  MOVWF  FEA
94BE:  MOVF   FEF,F
94C0:  BNZ   94CE
....................                      { 
....................                         MSG_sending_st=0; 
94C2:  MOVLB  4
94C4:  CLRF   x96
....................                         SIM_state=delete_MSG; 
94C6:  MOVLW  06
94C8:  MOVWF  x95
....................                         break; 
94CA:  MOVLB  0
94CC:  BRA    9602
....................                      } 
....................                      //EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
....................                   break; 
94CE:  MOVLB  0
94D0:  BRA    9602
....................                   case 1: 
....................                         fprintf(COM1,"AT+CMGS="); 
94D2:  MOVLW  64
94D4:  MOVWF  FF6
94D6:  MOVLW  4F
94D8:  MOVWF  FF7
94DA:  CALL   53D8
....................                      //fprintf(COM2,"AT+CMGS="); 
....................                      fputc('"',COM1); 
94DE:  MOVLW  22
94E0:  CALL   6528
....................                      i=0; 
94E4:  MOVLB  9
94E6:  CLRF   xD2
....................                      while((mobilenumb[i]!=0)&&(i<20)) 
....................                      { 
94E8:  CLRF   03
94EA:  MOVF   xD2,W
94EC:  ADDLW  79
94EE:  MOVWF  FE9
94F0:  MOVLW  04
94F2:  ADDWFC 03,W
94F4:  MOVWF  FEA
94F6:  MOVF   FEF,F
94F8:  BZ    9522
94FA:  MOVF   xD2,W
94FC:  SUBLW  13
94FE:  BNC   9522
....................                         fputc(mobilenumb[i],COM1); 
9500:  CLRF   03
9502:  MOVF   xD2,W
9504:  ADDLW  79
9506:  MOVWF  FE9
9508:  MOVLW  04
950A:  ADDWFC 03,W
950C:  MOVWF  FEA
950E:  MOVFF  FEF,A8E
9512:  MOVLB  A
9514:  MOVF   x8E,W
9516:  MOVLB  0
9518:  CALL   6528
....................                         //fprintf(COM2,"%c",mobilenumb[i]);  
....................                         i++; 
951C:  MOVLB  9
951E:  INCF   xD2,F
....................                      } 
9520:  BRA    94E8
....................                      fputc('"',COM1); 
9522:  MOVLW  22
9524:  MOVLB  0
9526:  CALL   6528
....................                      fprintf(COM1,"\r\n"); 
952A:  MOVLW  0D
952C:  BTFSS  F9E.4
952E:  BRA    952C
9530:  MOVWF  FAE
9532:  MOVLW  0A
9534:  BTFSS  F9E.4
9536:  BRA    9534
9538:  MOVWF  FAE
....................                      MSG_sending_st=2; 
953A:  MOVLW  02
953C:  MOVLB  4
953E:  MOVWF  x96
....................                   break; 
9540:  MOVLB  0
9542:  BRA    9602
....................                   case 2: 
....................                      //while((msg_data_sending[i]!=0)&&(i<140)) 
....................                      for(i=0;i<140;i++) 
9544:  MOVLB  9
9546:  CLRF   xD2
9548:  MOVF   xD2,W
954A:  SUBLW  8B
954C:  BNC   95B8
....................                      { 
....................                         if(msg_data_sending[i+lastlen]==0) 
954E:  MOVF   xD2,W
9550:  ADDWF  xD0,W
9552:  MOVLB  A
9554:  MOVWF  x8E
9556:  MOVLW  00
9558:  MOVLB  9
955A:  ADDWFC xD1,W
955C:  MOVLB  A
955E:  MOVWF  x8F
9560:  MOVLW  B8
9562:  ADDWF  x8E,W
9564:  MOVWF  FE9
9566:  MOVLW  01
9568:  ADDWFC x8F,W
956A:  MOVWF  FEA
956C:  MOVF   FEF,F
956E:  BNZ   9586
....................                         { 
....................                            SIM_state=delete_MSG;    
9570:  MOVLW  06
9572:  MOVLB  4
9574:  MOVWF  x95
....................                            MSG_sending_st=0; 
9576:  CLRF   x96
....................                            fputc(26,COM1); 
9578:  MOVLW  1A
957A:  MOVLB  0
957C:  CALL   6528
....................                            break; 
9580:  MOVLB  9
9582:  BRA    95B8
9584:  MOVLB  A
....................                         } 
....................                         fputc(msg_data_sending[i+lastlen],COM1); 
9586:  MOVLB  9
9588:  MOVF   xD2,W
958A:  ADDWF  xD0,W
958C:  MOVLB  A
958E:  MOVWF  x8E
9590:  MOVLW  00
9592:  MOVLB  9
9594:  ADDWFC xD1,W
9596:  MOVLB  A
9598:  MOVWF  x8F
959A:  MOVLW  B8
959C:  ADDWF  x8E,W
959E:  MOVWF  FE9
95A0:  MOVLW  01
95A2:  ADDWFC x8F,W
95A4:  MOVWF  FEA
95A6:  MOVFF  FEF,A90
95AA:  MOVF   x90,W
95AC:  MOVLB  0
95AE:  CALL   6528
....................                      } 
95B2:  MOVLB  9
95B4:  INCF   xD2,F
95B6:  BRA    9548
....................                      //fprintf(COM2,"i= %u\n\r",i);  
....................                      fputc(26,COM1); 
95B8:  MOVLW  1A
95BA:  MOVLB  0
95BC:  CALL   6528
....................                      MSG_sending_st=0; 
95C0:  MOVLB  4
95C2:  CLRF   x96
....................                      if(i<140) 
95C4:  MOVLB  9
95C6:  MOVF   xD2,W
95C8:  SUBLW  8B
95CA:  BNC   95DA
....................                      { 
....................                         SIM_state=check_st; 
95CC:  MOVLW  09
95CE:  MOVLB  4
95D0:  MOVWF  x95
....................                         lastlen=0; 
95D2:  MOVLB  9
95D4:  CLRF   xD1
95D6:  CLRF   xD0
....................                      } 
....................                      else 
95D8:  BRA    95F0
....................                      { 
....................                         lastlen=140; 
95DA:  CLRF   xD1
95DC:  MOVLW  8C
95DE:  MOVWF  xD0
....................                         if(msg_data_sending[140]==0)SIM_state=check_st; 
95E0:  MOVLB  2
95E2:  MOVF   x44,F
95E4:  BNZ   95EE
95E6:  MOVLW  09
95E8:  MOVLB  4
95EA:  MOVWF  x95
95EC:  MOVLB  2
95EE:  MOVLB  9
....................                      } 
....................                      if(lastlen==140)SIM_state=MSG_sending; 
95F0:  MOVF   xD0,W
95F2:  SUBLW  8C
95F4:  BNZ   9600
95F6:  MOVF   xD1,F
95F8:  BNZ   9600
95FA:  MOVLW  08
95FC:  MOVLB  4
95FE:  MOVWF  x95
....................                      //fprintf(COM2,"lastlen %lu\n\r",lastlen);   
....................                   break; 
9600:  MOVLB  0
....................                } 
....................                #ASM BSF    0xF94.7 #ENDASM  
9602:  BSF    F94.7
....................             break; 
9604:  MOVLB  4
9606:  BRA    9918
....................             case check_st: 
....................                //fprintf(COM2,"check_st->num_card,countc, count_dwla, lastlen =%lu,%lu,%lu,%lu\r\n",num_card,countc,count_dwla,lastlen);   
....................                if(count_dwla>1) 
9608:  MOVLB  9
960A:  MOVF   xCF,F
960C:  BNZ   9614
960E:  MOVF   xCE,W
9610:  SUBLW  01
9612:  BC    9628
....................                { 
....................                   count_dwla--; 
9614:  MOVF   xCE,W
9616:  BTFSC  FD8.2
9618:  DECF   xCF,F
961A:  DECF   xCE,F
....................                   SIM_state=pre_cmd; 
961C:  MOVLW  07
961E:  MOVLB  4
9620:  MOVWF  x95
....................                   break; 
9622:  BRA    9918
....................                } 
....................                else if(countc>0)  
9624:  BRA    9640
9626:  MOVLB  9
9628:  MOVF   xCC,F
962A:  BNZ   9630
962C:  MOVF   xCD,F
962E:  BZ    963A
....................                { 
....................                   SIM_state=pre_cmd; 
9630:  MOVLW  07
9632:  MOVLB  4
9634:  MOVWF  x95
....................                   break; 
9636:  BRA    9918
....................                } 
....................                else SIM_state=delete_MSG; 
9638:  BRA    9640
963A:  MOVLW  06
963C:  MOVLB  4
963E:  MOVWF  x95
....................             break; 
9640:  BRA    9918
....................             case autosending:  
....................                   //auto_sending=read_ext_eeprom(strobe_autosending); 
....................                   //if(auto_sending==1) 
....................                   //{ 
....................                      EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
9642:  MOVLW  55
9644:  MOVLB  A
9646:  MOVWF  x8E
9648:  MOVLW  14
964A:  MOVWF  x8F
964C:  MOVLW  04
964E:  MOVWF  x91
9650:  MOVLW  79
9652:  MOVWF  x90
9654:  MOVLB  0
9656:  CALL   506A
....................                      #if defined(twonumber)  
....................                         fprintf(COM2,"\r\nSending to the first number\r\n"); 
965A:  MOVLW  6E
965C:  MOVWF  FF6
965E:  MOVLW  4F
9660:  MOVWF  FF7
9662:  CLRF   19
9664:  BTFSC  FF2.7
9666:  BSF    19.7
9668:  BCF    FF2.7
966A:  CALL   07A0
966E:  BTFSC  19.7
9670:  BSF    FF2.7
9672:  CLRF   19
9674:  BTFSC  FF2.7
9676:  BSF    19.7
9678:  BCF    FF2.7
....................                      #else  
....................                         fprintf(COM2,"\r\nSending\r\n"); 
....................                      #endif 
....................                      num_card=get_countcard(); 
967A:  CALL   39FC
967E:  BTFSC  19.7
9680:  BSF    FF2.7
9682:  MOVFF  02,9C9
9686:  MOVFF  01,9C8
....................                      countc=0; 
968A:  MOVLB  9
968C:  CLRF   xCD
968E:  CLRF   xCC
....................                      count_dwla=0; 
9690:  CLRF   xCF
9692:  CLRF   xCE
....................                      lastlen=0; 
9694:  CLRF   xD1
9696:  CLRF   xD0
....................                      send_oneMSG=1; 
9698:  MOVLW  01
969A:  MOVLB  4
969C:  MOVWF  x9A
....................                      SIM_state=pre_cmd; 
969E:  MOVLW  07
96A0:  MOVWF  x95
....................                   //} 
....................                   //else SIM_state= reading_sms_cmd; 
....................             break; 
96A2:  BRA    9918
....................             #if defined(twonumber)  
....................             case autosending1:  
....................                   //auto_sending=read_ext_eeprom(strobe_autosending); 
....................                   //if(auto_sending==1) 
....................                   //{ 
....................                      EEPROM_read(strobe_mobile_num0,20,mobilenumb);  
96A4:  MOVLW  41
96A6:  MOVLB  A
96A8:  MOVWF  x8E
96AA:  MOVLW  14
96AC:  MOVWF  x8F
96AE:  MOVLW  04
96B0:  MOVWF  x91
96B2:  MOVLW  79
96B4:  MOVWF  x90
96B6:  MOVLB  0
96B8:  CALL   506A
....................                      if((mobilenumb[0]==0)&&(mobilenumb[1]==0)&&(mobilenumb[2]==0)&&(mobilenumb[3]==0)&&(mobilenumb[5]==0)&&(mobilenumb[7]==0)&&(mobilenumb[9]==0)) 
96BC:  MOVLB  4
96BE:  MOVF   x79,F
96C0:  BNZ   96FE
96C2:  MOVF   x7A,F
96C4:  BNZ   96FE
96C6:  MOVF   x7B,F
96C8:  BNZ   96FE
96CA:  MOVF   x7C,F
96CC:  BNZ   96FE
96CE:  MOVF   x7E,F
96D0:  BNZ   96FE
96D2:  MOVF   x80,F
96D4:  BNZ   96FE
96D6:  MOVF   x82,F
96D8:  BNZ   96FE
....................                      { 
....................                         send_oneMSG=0; 
96DA:  CLRF   x9A
....................                         fprintf(COM2,"\r\nthe 2nd number is not installed\r\n"); 
96DC:  MOVLW  8E
96DE:  MOVWF  FF6
96E0:  MOVLW  4F
96E2:  MOVWF  FF7
96E4:  CLRF   19
96E6:  BTFSC  FF2.7
96E8:  BSF    19.7
96EA:  BCF    FF2.7
96EC:  MOVLB  0
96EE:  CALL   07A0
96F2:  BTFSC  19.7
96F4:  BSF    FF2.7
....................                         SIM_state=delete_MSG;    
96F6:  MOVLW  06
96F8:  MOVLB  4
96FA:  MOVWF  x95
....................                      } 
....................                      else 
96FC:  BRA    973E
....................                      { 
....................                         fprintf(COM2,"\r\nSending to the second number\r\n"); 
96FE:  MOVLW  B2
9700:  MOVWF  FF6
9702:  MOVLW  4F
9704:  MOVWF  FF7
9706:  CLRF   19
9708:  BTFSC  FF2.7
970A:  BSF    19.7
970C:  BCF    FF2.7
970E:  MOVLB  0
9710:  CALL   07A0
9714:  BTFSC  19.7
9716:  BSF    FF2.7
....................                         send_oneMSG=1; 
9718:  MOVLW  01
971A:  MOVLB  4
971C:  MOVWF  x9A
971E:  CLRF   19
9720:  BTFSC  FF2.7
9722:  BSF    19.7
9724:  BCF    FF2.7
....................                         num_card=get_countcard(); 
9726:  MOVLB  0
9728:  CALL   39FC
972C:  BTFSC  19.7
972E:  BSF    FF2.7
9730:  MOVFF  02,9C9
9734:  MOVFF  01,9C8
....................                         SIM_state=pre_cmd; 
9738:  MOVLW  07
973A:  MOVLB  4
973C:  MOVWF  x95
....................                      }                      
....................                      countc=0; 
973E:  MOVLB  9
9740:  CLRF   xCD
9742:  CLRF   xCC
....................                      count_dwla=0; 
9744:  CLRF   xCF
9746:  CLRF   xCE
....................                      lastlen=0;                      
9748:  CLRF   xD1
974A:  CLRF   xD0
....................                   //} 
....................                   //else SIM_state= reading_sms_cmd; 
....................             break; 
974C:  MOVLB  4
974E:  BRA    9918
....................             #endif 
....................             case idle: 
....................                   output_toggle(LED); 
9750:  BCF    F92.6
9752:  BTG    F89.6
....................                   fprintf(COM2,"idle\n\r"); 
9754:  MOVLW  D4
9756:  MOVWF  FF6
9758:  MOVLW  4F
975A:  MOVWF  FF7
975C:  CLRF   19
975E:  BTFSC  FF2.7
9760:  BSF    19.7
9762:  BCF    FF2.7
9764:  CALL   07A0
9768:  BTFSC  19.7
976A:  BSF    FF2.7
....................                   fprintf(COM1,"AT+CMGF=1\r\n"); 
976C:  MOVLW  DC
976E:  MOVWF  FF6
9770:  MOVLW  4F
9772:  MOVWF  FF7
9774:  CALL   53D8
....................                   output_low(LED); 
9778:  BCF    F92.6
977A:  BCF    F89.6
....................                   SIM_state= data_analyze; 
977C:  MOVLW  0D
977E:  MOVLB  4
9780:  MOVWF  x95
....................                   receiver_state=0; 
9782:  MOVLB  1
9784:  CLRF   xB4
....................                   timing_wait=1500; 
9786:  MOVLW  05
9788:  MOVLB  4
978A:  MOVWF  x98
978C:  MOVLW  DC
978E:  MOVWF  x97
....................             break; 
9790:  BRA    9918
....................             case data_analyze: 
....................              
....................                   /*use for debug*/ 
....................                   /*fprintf(COM2,"\n\rcard_timeout %lu\n\r",card_timeout); 
....................                   fprintf(COM2,"\n\rbug_countbit_T1 %lu\n\r",bug_countbit_T1); 
....................                   fprintf(COM2,"\n\rbug_countbit_T2 %lu\n\r",bug_countbit_T2);*/                   
....................                   /*use for debug*/ 
....................                   //fprintf(COM2,"data_analyze=%d\n\r",temp); 
....................                   booting_done=1; 
9792:  MOVLW  01
9794:  MOVLB  1
9796:  MOVWF  xB5
....................                   output_low(LED); 
9798:  BCF    F92.6
979A:  BCF    F89.6
....................                   temp=SMS_coming(); 
979C:  MOVLB  0
979E:  GOTO   6530
97A2:  MOVFF  01,9D3
....................                   if(temp==2) 
97A6:  MOVLB  9
97A8:  MOVF   xD3,W
97AA:  SUBLW  02
97AC:  BNZ   97BE
....................                   { 
....................                      output_high(LED); 
97AE:  BCF    F92.6
97B0:  BSF    F89.6
....................                      SIM_state=reading_sms_cmd; 
97B2:  MOVLW  01
97B4:  MOVLB  4
97B6:  MOVWF  x95
....................                      count_checking=0; 
97B8:  MOVLB  1
97BA:  CLRF   x07
97BC:  CLRF   x06
....................                   } 
....................                   count_checking++; 
97BE:  MOVLB  1
97C0:  INCF   x06,F
97C2:  BTFSC  FD8.2
97C4:  INCF   x07,F
....................                   if(count_checking==20) 
97C6:  MOVF   x06,W
97C8:  SUBLW  14
97CA:  BNZ   97DC
97CC:  MOVF   x07,F
97CE:  BNZ   97DC
....................                   { 
....................                      //SIM_state=phone_activity_status; 
....................                      SIM_state=check_comunication; 
97D0:  MOVLW  0F
97D2:  MOVLB  4
97D4:  MOVWF  x95
....................                      count_checking=0; 
97D6:  MOVLB  1
97D8:  CLRF   x07
97DA:  CLRF   x06
....................                   } 
....................             break; 
97DC:  MOVLB  4
97DE:  BRA    9918
....................             case SIM_reply: 
....................                   fprintf(COM2,"SIM is replying\n\r"); 
97E0:  MOVLW  E8
97E2:  MOVWF  FF6
97E4:  MOVLW  4F
97E6:  MOVWF  FF7
97E8:  CLRF   19
97EA:  BTFSC  FF2.7
97EC:  BSF    19.7
97EE:  BCF    FF2.7
97F0:  CALL   07A0
97F4:  BTFSC  19.7
97F6:  BSF    FF2.7
....................                   //send_sms(mobilenumb,reply_buffer); 
....................                   len=0; 
97F8:  MOVLB  9
97FA:  CLRF   xD6
97FC:  CLRF   xD5
97FE:  CLRF   19
9800:  BTFSC  FF2.7
9802:  BSF    19.7
9804:  BCF    FF2.7
....................                   cards=get_countcard(); 
9806:  MOVLB  0
9808:  CALL   39FC
980C:  BTFSC  19.7
980E:  BSF    FF2.7
9810:  MOVFF  02,9CB
9814:  MOVFF  01,9CA
....................                   //strcpy(msg_buffer2,"device has "); 
....................                   len=pre_msg(reply_buffer,msg_data_sending,0); 
9818:  MOVLW  03
981A:  MOVLB  A
981C:  MOVWF  x8F
981E:  MOVLW  48
9820:  MOVWF  x8E
9822:  MOVLW  01
9824:  MOVWF  x91
9826:  MOVLW  B8
9828:  MOVWF  x90
982A:  CLRF   x93
982C:  CLRF   x92
982E:  MOVLB  0
9830:  CALL   5F32
9834:  MOVLB  9
9836:  CLRF   xD6
9838:  MOVFF  01,9D5
....................                   //itoa(cards,10,string); 
....................                   //len=pre_msg(string,msg_data_sending,len); 
....................                   //strcpy(msg_buffer2," transaction "); 
....................                   //len=pre_msg(msg_buffer2,msg_data_sending,len); 
....................                   SIM_state=MSG_sending; 
983C:  MOVLW  08
983E:  MOVLB  4
9840:  MOVWF  x95
....................                   lastlen=0; 
9842:  MOVLB  9
9844:  CLRF   xD1
9846:  CLRF   xD0
....................                   //fprintf(COM2,"device has %lu transaction \n\r",cards); 
....................                   countc=0; 
9848:  CLRF   xCD
984A:  CLRF   xCC
....................                   count_dwla=0; 
984C:  CLRF   xCF
984E:  CLRF   xCE
....................             break; 
9850:  MOVLB  4
9852:  BRA    9918
....................             case check_comunication: 
....................                fprintf(COM2,"check comunication\n\r"); 
9854:  MOVLW  FA
9856:  MOVWF  FF6
9858:  MOVLW  4F
985A:  MOVWF  FF7
985C:  CLRF   19
985E:  BTFSC  FF2.7
9860:  BSF    19.7
9862:  BCF    FF2.7
9864:  CALL   07A0
9868:  BTFSC  19.7
986A:  BSF    FF2.7
....................                //SIM_state= data_analyze; 
....................                SIM_state= phone_activity_status; 
986C:  MOVLW  10
986E:  MOVLB  4
9870:  MOVWF  x95
....................                booting_done=0; 
9872:  MOVLB  1
9874:  CLRF   xB5
....................                checking_sim=1; 
9876:  MOVLW  01
9878:  MOVLB  4
987A:  MOVWF  x9C
....................                setup_wdt(WDT_ON); 
987C:  BSF    FC0.0
....................                fprintf(COM1,"AT\r\n");   
987E:  MOVLW  10
9880:  MOVWF  FF6
9882:  MOVLW  50
9884:  MOVWF  FF7
9886:  MOVLB  0
9888:  CALL   53D8
....................             break; 
988C:  MOVLB  4
988E:  BRA    9918
....................             case phone_activity_status: 
....................                booting_done=1; 
9890:  MOVLW  01
9892:  MOVLB  1
9894:  MOVWF  xB5
....................                fprintf(COM2,"SIM activity status\n\r"); 
9896:  MOVLW  16
9898:  MOVWF  FF6
989A:  MOVLW  50
989C:  MOVWF  FF7
989E:  CLRF   19
98A0:  BTFSC  FF2.7
98A2:  BSF    19.7
98A4:  BCF    FF2.7
98A6:  MOVLB  0
98A8:  CALL   07A0
98AC:  BTFSC  19.7
98AE:  BSF    FF2.7
....................                SIM_state= data_analyze; 
98B0:  MOVLW  0D
98B2:  MOVLB  4
98B4:  MOVWF  x95
....................                fprintf(COM1,"AT+CPAS\r\n");  
98B6:  MOVLW  2C
98B8:  MOVWF  FF6
98BA:  MOVLW  50
98BC:  MOVWF  FF7
98BE:  MOVLB  0
98C0:  CALL   53D8
....................             break; 
98C4:  MOVLB  4
98C6:  BRA    9918
....................             case check_inbox: 
....................                fprintf(COM2,"check inbox\n\r"); 
98C8:  MOVLW  36
98CA:  MOVWF  FF6
98CC:  MOVLW  50
98CE:  MOVWF  FF7
98D0:  CLRF   19
98D2:  BTFSC  FF2.7
98D4:  BSF    19.7
98D6:  BCF    FF2.7
98D8:  CALL   07A0
98DC:  BTFSC  19.7
98DE:  BSF    FF2.7
....................                SIM_state= data_analyze; 
98E0:  MOVLW  0D
98E2:  MOVLB  4
98E4:  MOVWF  x95
....................                fprintf(COM1,"AT+CMGR=1\r\n"); 
98E6:  MOVLW  44
98E8:  MOVWF  FF6
98EA:  MOVLW  50
98EC:  MOVWF  FF7
98EE:  MOVLB  0
98F0:  CALL   53D8
....................             break; 
98F4:  MOVLB  4
98F6:  BRA    9918
....................             case reset_module: 
....................                setup_wdt(WDT_ON); 
98F8:  BSF    FC0.0
....................                fprintf(COM2,"reset_module\n\r"); 
98FA:  MOVLW  50
98FC:  MOVWF  FF6
98FE:  MOVLW  50
9900:  MOVWF  FF7
9902:  CLRF   19
9904:  BTFSC  FF2.7
9906:  BSF    19.7
9908:  BCF    FF2.7
990A:  CALL   07A0
990E:  BTFSC  19.7
9910:  BSF    FF2.7
....................             break; 
9912:  MOVLB  4
9914:  BRA    9918
9916:  MOVLB  4
....................          }         
....................       } 
....................       //restart_wdt(); 
....................       delay_us(500); 
9918:  MOVLW  02
991A:  MOVLB  A
991C:  MOVWF  x8E
991E:  CLRF   19
9920:  BTFSC  FF2.7
9922:  BSF    19.7
9924:  BCF    FF2.7
9926:  MOVLW  FA
9928:  MOVWF  xB4
992A:  MOVLB  0
992C:  CALL   0736
9930:  BTFSC  19.7
9932:  BSF    FF2.7
9934:  MOVLB  A
9936:  DECFSZ x8E,F
9938:  BRA    991E
....................      #else 
....................       if(mode==LOGOFF) 
....................       { 
....................          fprintf(COM2,"password:"); 
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          if(!stringcomp(buffer_uart,password)) 
....................          { 
....................             mode=LOGON; 
....................             fprintf(COM2," OK\n\r"); 
....................          } 
....................          else fprintf(COM2," X\n\r"); 
....................       } 
....................          else if(mode==LOGON)adminmode();//*/ 
....................      #endif     
....................    } 
993A:  MOVLB  0
993C:  GOTO   7294
.................... } 
9940:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

CCS PCH C Compiler, Version 4.140, 6310               29-Sep-15 14:04

               Filename:   C:\Users\quangnt\Desktop\new\main.lst

               ROM used:   34610 bytes (53%)
                           Largest free fragment is 30914
               RAM used:   2200 (58%) at main() level
                           2537 (67%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   808A
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   47CC
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   20EE
006C:  BTFSS  FF0.3
006E:  GOTO   0078
0072:  BTFSC  FF0.0
0074:  GOTO   1B38
0078:  BTFSS  F9D.5
007A:  GOTO   0084
007E:  BTFSC  F9E.5
0080:  GOTO   2098
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... #define SIM900 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
05E2:  MOVLW  02
05E4:  MOVLB  8
05E6:  SUBWF  xF2,F
05E8:  BNC   0602
05EA:  MOVLW  08
05EC:  MOVWF  FEA
05EE:  MOVLW  F2
05F0:  MOVWF  FE9
05F2:  MOVF   FEF,W
05F4:  BZ    0602
05F6:  BRA    05FE
05F8:  BRA    05FA
05FA:  BRA    05FC
05FC:  NOP   
05FE:  DECFSZ FEF,F
0600:  BRA    05F8
0602:  MOVLB  0
0604:  GOTO   1B48 (RETURN)
*
1836:  MOVLW  08
1838:  MOVWF  FEA
183A:  MOVLW  FA
183C:  MOVWF  FE9
183E:  MOVF   FEF,W
1840:  BZ    185C
1842:  MOVLW  0A
1844:  MOVWF  01
1846:  CLRF   00
1848:  DECFSZ 00,F
184A:  BRA    1848
184C:  DECFSZ 01,F
184E:  BRA    1846
1850:  MOVLW  5F
1852:  MOVWF  00
1854:  DECFSZ 00,F
1856:  BRA    1854
1858:  DECFSZ FEF,F
185A:  BRA    1842
185C:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
*
466C:  BTFSS  F9E.4
466E:  BRA    466C
4670:  MOVWF  FAE
4672:  RETURN 0
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
0608:  BCF    F94.0
060A:  BCF    F8B.0
060C:  MOVLW  08
060E:  MOVWF  01
0610:  BRA    0612
0612:  NOP   
0614:  BSF    01.7
0616:  BRA    0638
0618:  BCF    01.7
061A:  MOVLB  9
061C:  RRCF   xD3,F
061E:  MOVLB  0
0620:  BTFSC  FD8.0
0622:  BSF    F8B.0
0624:  BTFSS  FD8.0
0626:  BCF    F8B.0
0628:  BSF    01.6
062A:  BRA    0638
062C:  BCF    01.6
062E:  DECFSZ 01,F
0630:  BRA    061A
0632:  BRA    0634
0634:  NOP   
0636:  BSF    F8B.0
0638:  MOVLW  10
063A:  MOVWF  FE9
063C:  DECFSZ FE9,F
063E:  BRA    063C
0640:  BRA    0642
0642:  NOP   
0644:  BTFSC  01.7
0646:  BRA    0618
0648:  BTFSC  01.6
064A:  BRA    062C
064C:  RETURN 0
*
5DB6:  BSF    F94.1
5DB8:  BTFSC  F82.1
5DBA:  BRA    5DB8
5DBC:  MOVLW  08
5DBE:  MOVWF  00
5DC0:  MOVLB  8
5DC2:  CLRF   xD6
5DC4:  BSF    00.7
5DC6:  BRA    5DE8
5DC8:  BCF    00.7
5DCA:  BRA    5DE8
5DCC:  MOVFF  8D6,02
5DD0:  BCF    FD8.0
5DD2:  BTFSC  F82.1
5DD4:  BSF    FD8.0
5DD6:  RRCF   02,F
5DD8:  BSF    00.6
5DDA:  BRA    5DE8
5DDC:  BCF    00.6
5DDE:  DECFSZ 00,F
5DE0:  BRA    5DD0
5DE2:  MOVFF  02,01
5DE6:  BRA    5E00
5DE8:  MOVLW  10
5DEA:  BTFSC  00.7
5DEC:  MOVLW  04
5DEE:  MOVWF  01
5DF0:  DECFSZ 01,F
5DF2:  BRA    5DF0
5DF4:  BRA    5DF6
5DF6:  BTFSC  00.7
5DF8:  BRA    5DC8
5DFA:  BTFSC  00.6
5DFC:  BRA    5DDC
5DFE:  BRA    5DD0
5E00:  MOVLB  0
5E02:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
3E5C:  MOVLB  9
3E5E:  MOVF   xB2,F
3E60:  BNZ   3E66
3E62:  MOVF   xB3,F
3E64:  BZ    3EEA
....................       if (*s1 != *s2) 
3E66:  MOVFF  9AE,FE9
3E6A:  MOVFF  9AF,FEA
3E6E:  MOVFF  FEF,9B4
3E72:  MOVFF  9B1,03
3E76:  MOVFF  9B0,FE9
3E7A:  MOVFF  9B1,FEA
3E7E:  MOVF   FEF,W
3E80:  SUBWF  xB4,W
3E82:  BZ    3EB2
....................          return((*s1 <*s2) ? -1: 1); 
3E84:  MOVFF  9AF,03
3E88:  MOVFF  9AE,FE9
3E8C:  MOVFF  9AF,FEA
3E90:  MOVFF  FEF,9B4
3E94:  MOVFF  9B1,03
3E98:  MOVFF  9B0,FE9
3E9C:  MOVFF  9B1,FEA
3EA0:  MOVF   FEF,W
3EA2:  SUBWF  xB4,W
3EA4:  BC    3EAA
3EA6:  MOVLW  FF
3EA8:  BRA    3EAC
3EAA:  MOVLW  01
3EAC:  MOVWF  01
3EAE:  BRA    3EEE
....................       else if (*s1 == '\0') 
3EB0:  BRA    3EC8
3EB2:  MOVFF  9AF,03
3EB6:  MOVFF  9AE,FE9
3EBA:  MOVFF  9AF,FEA
3EBE:  MOVF   FEF,F
3EC0:  BNZ   3EC8
....................          return(0); 
3EC2:  MOVLW  00
3EC4:  MOVWF  01
3EC6:  BRA    3EEE
3EC8:  MOVFF  9AF,03
3ECC:  MOVF   xAE,W
3ECE:  INCF   xAE,F
3ED0:  BTFSC  FD8.2
3ED2:  INCF   xAF,F
3ED4:  MOVFF  9B1,03
3ED8:  MOVF   xB0,W
3EDA:  INCF   xB0,F
3EDC:  BTFSC  FD8.2
3EDE:  INCF   xB1,F
3EE0:  MOVF   xB2,W
3EE2:  BTFSC  FD8.2
3EE4:  DECF   xB3,F
3EE6:  DECF   xB2,F
3EE8:  BRA    3E5E
....................    return(0); 
3EEA:  MOVLW  00
3EEC:  MOVWF  01
.................... } 
3EEE:  MOVLB  0
3EF0:  RETURN 0
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
404A:  MOVFF  9B7,9B9
404E:  MOVFF  9B6,9B8
4052:  MOVFF  9B9,03
4056:  MOVLB  9
4058:  MOVFF  9B8,FE9
405C:  MOVFF  9B9,FEA
4060:  MOVF   FEF,F
4062:  BZ    4070
4064:  INCF   xB8,F
4066:  BTFSC  FD8.2
4068:  INCF   xB9,F
406A:  MOVLB  0
406C:  BRA    4052
406E:  MOVLB  9
....................    return(sc - s); 
4070:  MOVF   xB6,W
4072:  SUBWF  xB8,W
4074:  MOVWF  00
4076:  MOVF   xB7,W
4078:  SUBWFB xB9,W
407A:  MOVWF  03
407C:  MOVFF  00,01
.................... } 
4080:  MOVLB  0
4082:  RETURN 0
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
4450:  MOVLB  9
4452:  CLRF   xB3
....................    sign = 0; 
4454:  CLRF   xB1
....................    base = 10; 
4456:  MOVLW  0A
4458:  MOVWF  xB2
....................    result = 0; 
445A:  CLRF   xB0
....................  
....................    if (!s) 
445C:  MOVF   xAE,W
445E:  IORWF  xAF,W
4460:  BNZ   4468
....................       return 0; 
4462:  MOVLW  00
4464:  MOVWF  01
4466:  BRA    45EE
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
4468:  MOVF   xB3,W
446A:  INCF   xB3,F
446C:  CLRF   03
446E:  ADDWF  xAE,W
4470:  MOVWF  FE9
4472:  MOVF   xAF,W
4474:  ADDWFC 03,W
4476:  MOVWF  FEA
4478:  MOVFF  FEF,9B4
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
447C:  MOVF   xB4,W
447E:  SUBLW  2D
4480:  BNZ   449C
....................    { 
....................       sign = 1;         // Set the sign to negative 
4482:  MOVLW  01
4484:  MOVWF  xB1
....................       c = s[index++]; 
4486:  MOVF   xB3,W
4488:  INCF   xB3,F
448A:  CLRF   03
448C:  ADDWF  xAE,W
448E:  MOVWF  FE9
4490:  MOVF   xAF,W
4492:  ADDWFC 03,W
4494:  MOVWF  FEA
4496:  MOVFF  FEF,9B4
....................    } 
....................    else if (c == '+') 
449A:  BRA    44B6
449C:  MOVF   xB4,W
449E:  SUBLW  2B
44A0:  BNZ   44B6
....................    { 
....................       c = s[index++]; 
44A2:  MOVF   xB3,W
44A4:  INCF   xB3,F
44A6:  CLRF   03
44A8:  ADDWF  xAE,W
44AA:  MOVWF  FE9
44AC:  MOVF   xAF,W
44AE:  ADDWFC 03,W
44B0:  MOVWF  FEA
44B2:  MOVFF  FEF,9B4
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
44B6:  MOVF   xB4,W
44B8:  SUBLW  2F
44BA:  BTFSC  FD8.0
44BC:  BRA    45DE
44BE:  MOVF   xB4,W
44C0:  SUBLW  39
44C2:  BTFSS  FD8.0
44C4:  BRA    45DE
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
44C6:  MOVF   xB4,W
44C8:  SUBLW  30
44CA:  BNZ   450E
44CC:  CLRF   03
44CE:  MOVF   xB3,W
44D0:  ADDWF  xAE,W
44D2:  MOVWF  FE9
44D4:  MOVF   xAF,W
44D6:  ADDWFC 03,W
44D8:  MOVWF  FEA
44DA:  MOVF   FEF,W
44DC:  SUBLW  78
44DE:  BZ    44F4
44E0:  CLRF   03
44E2:  MOVF   xB3,W
44E4:  ADDWF  xAE,W
44E6:  MOVWF  FE9
44E8:  MOVF   xAF,W
44EA:  ADDWFC 03,W
44EC:  MOVWF  FEA
44EE:  MOVF   FEF,W
44F0:  SUBLW  58
44F2:  BNZ   450E
....................       { 
....................          base = 16; 
44F4:  MOVLW  10
44F6:  MOVWF  xB2
....................          index++; 
44F8:  INCF   xB3,F
....................          c = s[index++]; 
44FA:  MOVF   xB3,W
44FC:  INCF   xB3,F
44FE:  CLRF   03
4500:  ADDWF  xAE,W
4502:  MOVWF  FE9
4504:  MOVF   xAF,W
4506:  ADDWFC 03,W
4508:  MOVWF  FEA
450A:  MOVFF  FEF,9B4
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
450E:  MOVF   xB2,W
4510:  SUBLW  0A
4512:  BNZ   454E
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
4514:  MOVF   xB4,W
4516:  SUBLW  2F
4518:  BC    454C
451A:  MOVF   xB4,W
451C:  SUBLW  39
451E:  BNC   454C
....................             result = 10*result + (c - '0'); 
4520:  MOVLW  0A
4522:  MOVWF  xB5
4524:  MOVFF  9B0,9B6
4528:  MOVLB  0
452A:  BRA    4400
452C:  MOVLW  30
452E:  MOVLB  9
4530:  SUBWF  xB4,W
4532:  ADDWF  01,W
4534:  MOVWF  xB0
....................             c = s[index++]; 
4536:  MOVF   xB3,W
4538:  INCF   xB3,F
453A:  CLRF   03
453C:  ADDWF  xAE,W
453E:  MOVWF  FE9
4540:  MOVF   xAF,W
4542:  ADDWFC 03,W
4544:  MOVWF  FEA
4546:  MOVFF  FEF,9B4
....................          } 
454A:  BRA    4514
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
454C:  BRA    45DE
454E:  MOVF   xB2,W
4550:  SUBLW  10
4552:  BNZ   45DE
....................       { 
....................          c = toupper(c); 
4554:  MOVF   xB4,W
4556:  SUBLW  60
4558:  BC    4566
455A:  MOVF   xB4,W
455C:  SUBLW  7A
455E:  BNC   4566
4560:  MOVF   xB4,W
4562:  ANDLW  DF
4564:  BRA    4568
4566:  MOVF   xB4,W
4568:  MOVWF  xB4
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
456A:  MOVF   xB4,W
456C:  SUBLW  2F
456E:  BC    4576
4570:  MOVF   xB4,W
4572:  SUBLW  39
4574:  BC    4582
4576:  MOVF   xB4,W
4578:  SUBLW  40
457A:  BC    45DE
457C:  MOVF   xB4,W
457E:  SUBLW  46
4580:  BNC   45DE
....................             if (c >= '0' && c <= '9') 
4582:  MOVF   xB4,W
4584:  SUBLW  2F
4586:  BC    45A0
4588:  MOVF   xB4,W
458A:  SUBLW  39
458C:  BNC   45A0
....................                result = (result << 4) + (c - '0'); 
458E:  SWAPF  xB0,W
4590:  MOVWF  xB5
4592:  MOVLW  F0
4594:  ANDWF  xB5,F
4596:  MOVLW  30
4598:  SUBWF  xB4,W
459A:  ADDWF  xB5,W
459C:  MOVWF  xB0
....................             else 
459E:  BRA    45B2
....................                result = (result << 4) + (c - 'A' + 10); 
45A0:  SWAPF  xB0,W
45A2:  MOVWF  xB5
45A4:  MOVLW  F0
45A6:  ANDWF  xB5,F
45A8:  MOVLW  41
45AA:  SUBWF  xB4,W
45AC:  ADDLW  0A
45AE:  ADDWF  xB5,W
45B0:  MOVWF  xB0
....................  
....................             c = s[index++]; 
45B2:  MOVF   xB3,W
45B4:  INCF   xB3,F
45B6:  CLRF   03
45B8:  ADDWF  xAE,W
45BA:  MOVWF  FE9
45BC:  MOVF   xAF,W
45BE:  ADDWFC 03,W
45C0:  MOVWF  FEA
45C2:  MOVFF  FEF,9B4
....................             c = toupper(c); 
45C6:  MOVF   xB4,W
45C8:  SUBLW  60
45CA:  BC    45D8
45CC:  MOVF   xB4,W
45CE:  SUBLW  7A
45D0:  BNC   45D8
45D2:  MOVF   xB4,W
45D4:  ANDLW  DF
45D6:  BRA    45DA
45D8:  MOVF   xB4,W
45DA:  MOVWF  xB4
....................          } 
45DC:  BRA    456A
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
45DE:  DECFSZ xB1,W
45E0:  BRA    45EA
45E2:  MOVF   xB2,W
45E4:  SUBLW  0A
45E6:  BNZ   45EA
....................        result = -result; 
45E8:  NEGF   xB0
....................  
....................    return(result); 
45EA:  MOVFF  9B0,01
.................... } 
45EE:  MOVLB  0
45F0:  GOTO   4F06 (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
*
4234:  MOVLB  9
4236:  CLRF   xB8
4238:  CLRF   xB7
423A:  CLRF   xB6
423C:  MOVLW  01
423E:  MOVWF  xB5
4240:  CLRF   xBA
4242:  CLRF   xBB
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
4244:  BTFSS  xB1.7
4246:  BRA    427A
....................          sign=1;        // Check for negative number 
4248:  MOVLW  01
424A:  MOVWF  xBA
....................          num*=-1; 
424C:  MOVFF  9B1,9C0
4250:  MOVFF  9B0,9BF
4254:  MOVFF  9AF,9BE
4258:  MOVFF  9AE,9BD
425C:  SETF   xC4
425E:  SETF   xC3
4260:  SETF   xC2
4262:  SETF   xC1
4264:  MOVLB  0
4266:  BRA    40EC
4268:  MOVFF  03,9B1
426C:  MOVFF  02,9B0
4270:  MOVFF  01,9AF
4274:  MOVFF  00,9AE
4278:  MOVLB  9
....................      } 
....................  
....................      while(temp>0) { 
427A:  MOVF   xB5,F
427C:  BNZ   428A
427E:  MOVF   xB6,F
4280:  BNZ   428A
4282:  MOVF   xB7,F
4284:  BNZ   428A
4286:  MOVF   xB8,F
4288:  BZ    4364
....................          temp=(num/base); 
428A:  BCF    FD8.1
428C:  MOVFF  9B1,9C8
4290:  MOVFF  9B0,9C7
4294:  MOVFF  9AF,9C6
4298:  MOVFF  9AE,9C5
429C:  CLRF   xCC
429E:  CLRF   xCB
42A0:  CLRF   xCA
42A2:  MOVFF  9B2,9C9
42A6:  MOVLB  0
42A8:  RCALL  414A
42AA:  MOVFF  03,9B8
42AE:  MOVFF  02,9B7
42B2:  MOVFF  01,9B6
42B6:  MOVFF  00,9B5
....................          s[cnt]=(num%base)+'0';    // Conversion 
42BA:  CLRF   03
42BC:  MOVLB  9
42BE:  MOVF   xBB,W
42C0:  ADDWF  xB3,W
42C2:  MOVWF  01
42C4:  MOVF   xB4,W
42C6:  ADDWFC 03,F
42C8:  MOVFF  01,9BD
42CC:  MOVFF  03,9BE
42D0:  MOVFF  FEA,9C0
42D4:  MOVFF  FE9,9BF
42D8:  BSF    FD8.1
42DA:  MOVLW  09
42DC:  MOVWF  FEA
42DE:  MOVLW  C1
42E0:  MOVWF  FE9
42E2:  MOVFF  9B1,9C8
42E6:  MOVFF  9B0,9C7
42EA:  MOVFF  9AF,9C6
42EE:  MOVFF  9AE,9C5
42F2:  CLRF   xCC
42F4:  CLRF   xCB
42F6:  CLRF   xCA
42F8:  MOVFF  9B2,9C9
42FC:  MOVLB  0
42FE:  RCALL  414A
4300:  MOVFF  9C0,FEA
4304:  MOVFF  9BF,FE9
4308:  MOVLW  30
430A:  MOVLB  9
430C:  ADDWF  xC1,W
430E:  MOVWF  00
4310:  MOVLW  00
4312:  ADDWFC xC2,W
4314:  MOVLW  00
4316:  ADDWFC xC3,W
4318:  MOVLW  00
431A:  ADDWFC xC4,W
431C:  MOVFF  9BE,FEA
4320:  MOVFF  9BD,FE9
4324:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
4328:  CLRF   03
432A:  MOVF   xBB,W
432C:  ADDWF  xB3,W
432E:  MOVWF  FE9
4330:  MOVF   xB4,W
4332:  ADDWFC 03,W
4334:  MOVWF  FEA
4336:  MOVF   FEF,W
4338:  SUBLW  39
433A:  BC    4350
....................             s[cnt]+=0x7; 
433C:  CLRF   03
433E:  MOVF   xBB,W
4340:  ADDWF  xB3,W
4342:  MOVWF  FE9
4344:  MOVF   xB4,W
4346:  ADDWFC 03,W
4348:  MOVWF  FEA
434A:  MOVLW  07
434C:  ADDWF  FEF,W
434E:  MOVWF  FEF
....................  
....................          cnt++; 
4350:  INCF   xBB,F
....................          num=temp; 
4352:  MOVFF  9B8,9B1
4356:  MOVFF  9B7,9B0
435A:  MOVFF  9B6,9AF
435E:  MOVFF  9B5,9AE
....................      } 
4362:  BRA    427A
....................  
....................      if(sign==1) { 
4364:  DECFSZ xBA,W
4366:  BRA    437C
....................          s[cnt]=0x2D;      // Negative sign 
4368:  CLRF   03
436A:  MOVF   xBB,W
436C:  ADDWF  xB3,W
436E:  MOVWF  FE9
4370:  MOVF   xB4,W
4372:  ADDWFC 03,W
4374:  MOVWF  FEA
4376:  MOVLW  2D
4378:  MOVWF  FEF
....................          cnt++; 
437A:  INCF   xBB,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
437C:  CLRF   xB9
437E:  BCF    FD8.0
4380:  RRCF   xBB,W
4382:  SUBWF  xB9,W
4384:  BC    43E4
....................  
....................          c=s[i]; 
4386:  CLRF   03
4388:  MOVF   xB9,W
438A:  ADDWF  xB3,W
438C:  MOVWF  FE9
438E:  MOVF   xB4,W
4390:  ADDWFC 03,W
4392:  MOVWF  FEA
4394:  MOVFF  FEF,9BC
....................          s[i]=s[cnt-i-1];        // Reverse the number 
4398:  CLRF   03
439A:  MOVF   xB9,W
439C:  ADDWF  xB3,W
439E:  MOVWF  01
43A0:  MOVF   xB4,W
43A2:  ADDWFC 03,F
43A4:  MOVFF  03,9BE
43A8:  MOVF   xB9,W
43AA:  SUBWF  xBB,W
43AC:  ADDLW  FF
43AE:  CLRF   03
43B0:  ADDWF  xB3,W
43B2:  MOVWF  FE9
43B4:  MOVF   xB4,W
43B6:  ADDWFC 03,W
43B8:  MOVWF  FEA
43BA:  MOVFF  FEF,9BF
43BE:  MOVFF  9BE,FEA
43C2:  MOVFF  01,FE9
43C6:  MOVFF  9BF,FEF
....................          s[cnt-i-1]=c; 
43CA:  MOVF   xB9,W
43CC:  SUBWF  xBB,W
43CE:  ADDLW  FF
43D0:  CLRF   03
43D2:  ADDWF  xB3,W
43D4:  MOVWF  FE9
43D6:  MOVF   xB4,W
43D8:  ADDWFC 03,W
43DA:  MOVWF  FEA
43DC:  MOVFF  9BC,FEF
....................      } 
43E0:  INCF   xB9,F
43E2:  BRA    437E
....................      s[cnt]='\0';     // End the string 
43E4:  CLRF   03
43E6:  MOVF   xBB,W
43E8:  ADDWF  xB3,W
43EA:  MOVWF  FE9
43EC:  MOVF   xB4,W
43EE:  ADDWFC 03,W
43F0:  MOVWF  FEA
43F2:  CLRF   FEF
....................      return s; 
43F4:  MOVFF  9B3,01
43F8:  MOVFF  9B4,02
.................... } 
43FC:  MOVLB  0
43FE:  RETURN 0
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
2C9E:  MOVLW  08
2CA0:  MOVWF  01
2CA2:  MOVLW  0A
2CA4:  MOVWF  00
2CA6:  DECFSZ 00,F
2CA8:  BRA    2CA6
2CAA:  BCF    F8B.3
2CAC:  BCF    F94.3
2CAE:  MOVLW  0B
2CB0:  MOVWF  00
2CB2:  DECFSZ 00,F
2CB4:  BRA    2CB2
2CB6:  MOVLB  9
2CB8:  RLCF   xC6,F
2CBA:  BCF    F8B.4
2CBC:  BTFSC  FD8.0
2CBE:  BSF    F94.4
2CC0:  BTFSS  FD8.0
2CC2:  BCF    F94.4
2CC4:  BSF    F94.3
2CC6:  BTFSS  F82.3
2CC8:  BRA    2CC6
2CCA:  DECFSZ 01,F
2CCC:  BRA    2CD0
2CCE:  BRA    2CD4
2CD0:  MOVLB  0
2CD2:  BRA    2CA2
2CD4:  MOVLW  0A
2CD6:  MOVWF  00
2CD8:  DECFSZ 00,F
2CDA:  BRA    2CD8
2CDC:  BCF    F8B.3
2CDE:  BCF    F94.3
2CE0:  NOP   
2CE2:  BSF    F94.4
2CE4:  MOVLW  0B
2CE6:  MOVWF  00
2CE8:  DECFSZ 00,F
2CEA:  BRA    2CE8
2CEC:  MOVLW  0B
2CEE:  MOVWF  00
2CF0:  DECFSZ 00,F
2CF2:  BRA    2CF0
2CF4:  BSF    F94.3
2CF6:  BTFSS  F82.3
2CF8:  BRA    2CF6
2CFA:  CLRF   01
2CFC:  MOVLW  0B
2CFE:  MOVWF  00
2D00:  DECFSZ 00,F
2D02:  BRA    2D00
2D04:  BTFSC  F82.4
2D06:  BSF    01.0
2D08:  BCF    F8B.3
2D0A:  BCF    F94.3
2D0C:  BCF    F8B.4
2D0E:  BCF    F94.4
2D10:  MOVLB  0
2D12:  RETURN 0
2D14:  MOVLW  08
2D16:  MOVLB  9
2D18:  MOVWF  xC0
2D1A:  MOVFF  00,9C1
2D1E:  BSF    F94.4
2D20:  MOVLW  0B
2D22:  MOVWF  00
2D24:  DECFSZ 00,F
2D26:  BRA    2D24
2D28:  BSF    F94.3
2D2A:  BTFSS  F82.3
2D2C:  BRA    2D2A
2D2E:  BTFSC  F82.4
2D30:  BSF    FD8.0
2D32:  BTFSS  F82.4
2D34:  BCF    FD8.0
2D36:  RLCF   01,F
2D38:  MOVLW  0A
2D3A:  MOVWF  00
2D3C:  DECFSZ 00,F
2D3E:  BRA    2D3C
2D40:  BCF    F94.3
2D42:  BCF    F8B.3
2D44:  DECFSZ xC0,F
2D46:  BRA    2D1E
2D48:  BSF    F94.4
2D4A:  MOVLW  0B
2D4C:  MOVWF  00
2D4E:  DECFSZ 00,F
2D50:  BRA    2D4E
2D52:  BCF    F8B.4
2D54:  MOVF   xC1,W
2D56:  BTFSS  FD8.2
2D58:  BCF    F94.4
2D5A:  NOP   
2D5C:  BSF    F94.3
2D5E:  BTFSS  F82.3
2D60:  BRA    2D5E
2D62:  MOVLW  0A
2D64:  MOVWF  00
2D66:  DECFSZ 00,F
2D68:  BRA    2D66
2D6A:  BCF    F8B.3
2D6C:  BCF    F94.3
2D6E:  MOVLW  0B
2D70:  MOVWF  00
2D72:  DECFSZ 00,F
2D74:  BRA    2D72
2D76:  BCF    F8B.4
2D78:  BCF    F94.4
2D7A:  MOVLB  0
2D7C:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... //#define EEPROM_SIZE   65535 
.................... #define EEPROM_SIZE_key    65535 
.................... #define EEPROM_SIZE        43590 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5A82:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
5A84:  BSF    F94.4
....................    port_b_pullups(0xff); 
5A86:  BCF    FF1.7
.................... } 
5A88:  GOTO   8210 (RETURN)
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
336C:  BSF    F94.4
336E:  MOVLW  0A
3370:  MOVWF  00
3372:  DECFSZ 00,F
3374:  BRA    3372
3376:  BSF    F94.3
3378:  MOVLW  0B
337A:  MOVWF  00
337C:  DECFSZ 00,F
337E:  BRA    337C
3380:  BCF    F8B.4
3382:  BCF    F94.4
3384:  MOVLW  0A
3386:  MOVWF  00
3388:  DECFSZ 00,F
338A:  BRA    3388
338C:  BCF    F8B.3
338E:  BCF    F94.3
....................    i2c_write(0xa0); 
3390:  MOVLW  A0
3392:  MOVLB  9
3394:  MOVWF  xC6
3396:  MOVLB  0
3398:  RCALL  2C9E
....................    i2c_write(address>>8); 
339A:  MOVFF  9C0,9C4
339E:  MOVLB  9
33A0:  CLRF   xC5
33A2:  MOVFF  9C0,9C6
33A6:  MOVLB  0
33A8:  RCALL  2C9E
....................    i2c_write(address); 
33AA:  MOVFF  9BF,9C6
33AE:  RCALL  2C9E
....................    i2c_write(data); 
33B0:  MOVFF  9C1,9C6
33B4:  RCALL  2C9E
....................    i2c_stop(); 
33B6:  BCF    F94.4
33B8:  NOP   
33BA:  BSF    F94.3
33BC:  BTFSS  F82.3
33BE:  BRA    33BC
33C0:  MOVLW  0A
33C2:  MOVWF  00
33C4:  DECFSZ 00,F
33C6:  BRA    33C4
33C8:  BRA    33CA
33CA:  NOP   
33CC:  BSF    F94.4
33CE:  MOVLW  0A
33D0:  MOVWF  00
33D2:  DECFSZ 00,F
33D4:  BRA    33D2
....................    i2c_start(); 
33D6:  BSF    F94.4
33D8:  MOVLW  0A
33DA:  MOVWF  00
33DC:  DECFSZ 00,F
33DE:  BRA    33DC
33E0:  BSF    F94.3
33E2:  MOVLW  0B
33E4:  MOVWF  00
33E6:  DECFSZ 00,F
33E8:  BRA    33E6
33EA:  BCF    F8B.4
33EC:  BCF    F94.4
33EE:  MOVLW  0A
33F0:  MOVWF  00
33F2:  DECFSZ 00,F
33F4:  BRA    33F2
33F6:  BCF    F8B.3
33F8:  BCF    F94.3
....................    status=i2c_write(0xa0); 
33FA:  MOVLW  A0
33FC:  MOVLB  9
33FE:  MOVWF  xC6
3400:  MOVLB  0
3402:  RCALL  2C9E
3404:  MOVF   01,W
3406:  MOVLB  9
3408:  BCF    xC2.0
340A:  BTFSC  01.0
340C:  BSF    xC2.0
....................    while(status==1) 
....................    { 
340E:  BTFSS  xC2.0
3410:  BRA    344E
....................       i2c_start(); 
3412:  BSF    F94.4
3414:  MOVLW  0A
3416:  MOVWF  00
3418:  DECFSZ 00,F
341A:  BRA    3418
341C:  BSF    F94.3
341E:  MOVLW  0B
3420:  MOVWF  00
3422:  DECFSZ 00,F
3424:  BRA    3422
3426:  BTFSS  F82.3
3428:  BRA    3426
342A:  BCF    F8B.4
342C:  BCF    F94.4
342E:  MOVLW  0A
3430:  MOVWF  00
3432:  DECFSZ 00,F
3434:  BRA    3432
3436:  BCF    F8B.3
3438:  BCF    F94.3
....................       status=i2c_write(0xa0); 
343A:  MOVLW  A0
343C:  MOVWF  xC6
343E:  MOVLB  0
3440:  RCALL  2C9E
3442:  MOVF   01,W
3444:  MOVLB  9
3446:  BCF    xC2.0
3448:  BTFSC  01.0
344A:  BSF    xC2.0
....................    } 
344C:  BRA    340E
....................    i2c_stop(); 
344E:  BCF    F94.4
3450:  NOP   
3452:  BSF    F94.3
3454:  BTFSS  F82.3
3456:  BRA    3454
3458:  MOVLW  0A
345A:  MOVWF  00
345C:  DECFSZ 00,F
345E:  BRA    345C
3460:  BRA    3462
3462:  NOP   
3464:  BSF    F94.4
3466:  MOVLW  0A
3468:  MOVWF  00
346A:  DECFSZ 00,F
346C:  BRA    346A
.................... } 
346E:  MOVLB  0
3470:  RETURN 0
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
2E48:  BSF    F94.4
2E4A:  MOVLW  0A
2E4C:  MOVWF  00
2E4E:  DECFSZ 00,F
2E50:  BRA    2E4E
2E52:  BSF    F94.3
2E54:  MOVLW  0B
2E56:  MOVWF  00
2E58:  DECFSZ 00,F
2E5A:  BRA    2E58
2E5C:  BCF    F8B.4
2E5E:  BCF    F94.4
2E60:  MOVLW  0A
2E62:  MOVWF  00
2E64:  DECFSZ 00,F
2E66:  BRA    2E64
2E68:  BCF    F8B.3
2E6A:  BCF    F94.3
....................    i2c_write(0xa0); 
2E6C:  MOVLW  A0
2E6E:  MOVLB  9
2E70:  MOVWF  xC6
2E72:  MOVLB  0
2E74:  RCALL  2C9E
....................    i2c_write(address>>8); 
2E76:  MOVFF  9BD,9BF
2E7A:  MOVLB  9
2E7C:  CLRF   xC0
2E7E:  MOVFF  9BD,9C6
2E82:  MOVLB  0
2E84:  RCALL  2C9E
....................    i2c_write(address); 
2E86:  MOVFF  9BC,9C6
2E8A:  RCALL  2C9E
....................    i2c_start(); 
2E8C:  BSF    F94.4
2E8E:  MOVLW  0A
2E90:  MOVWF  00
2E92:  DECFSZ 00,F
2E94:  BRA    2E92
2E96:  BSF    F94.3
2E98:  MOVLW  0B
2E9A:  MOVWF  00
2E9C:  DECFSZ 00,F
2E9E:  BRA    2E9C
2EA0:  BTFSS  F82.3
2EA2:  BRA    2EA0
2EA4:  BCF    F8B.4
2EA6:  BCF    F94.4
2EA8:  MOVLW  0A
2EAA:  MOVWF  00
2EAC:  DECFSZ 00,F
2EAE:  BRA    2EAC
2EB0:  BCF    F8B.3
2EB2:  BCF    F94.3
....................    i2c_write(0xa1); 
2EB4:  MOVLW  A1
2EB6:  MOVLB  9
2EB8:  MOVWF  xC6
2EBA:  MOVLB  0
2EBC:  RCALL  2C9E
....................    data=i2c_read(0); 
2EBE:  CLRF   00
2EC0:  RCALL  2D14
2EC2:  MOVFF  01,9BE
....................    i2c_stop(); 
2EC6:  BCF    F94.4
2EC8:  NOP   
2ECA:  BSF    F94.3
2ECC:  BTFSS  F82.3
2ECE:  BRA    2ECC
2ED0:  MOVLW  0A
2ED2:  MOVWF  00
2ED4:  DECFSZ 00,F
2ED6:  BRA    2ED4
2ED8:  BRA    2EDA
2EDA:  NOP   
2EDC:  BSF    F94.4
2EDE:  MOVLW  0A
2EE0:  MOVWF  00
2EE2:  DECFSZ 00,F
2EE4:  BRA    2EE2
....................    return(data); 
2EE6:  MOVLB  9
2EE8:  MOVFF  9BE,01
.................... } 
2EEC:  MOVLB  0
2EEE:  RETURN 0
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
45F4:  MOVLB  9
45F6:  MOVF   xB2,W
45F8:  ADDWF  xB0,W
45FA:  MOVWF  xB8
45FC:  MOVF   xB3,W
45FE:  ADDWFC xB1,W
4600:  MOVWF  xB9
4602:  SUBLW  A9
4604:  BC    4616
4606:  XORLW  FF
4608:  BNZ   4610
460A:  MOVF   xB8,W
460C:  SUBLW  45
460E:  BC    4616
4610:  MOVLW  00
4612:  MOVWF  01
4614:  BRA    4668
....................    for(i=0;i<len;i++) 
4616:  CLRF   xB7
4618:  CLRF   xB6
461A:  MOVF   xB7,W
461C:  SUBWF  xB3,W
461E:  BNC   4668
4620:  BNZ   4628
4622:  MOVF   xB2,W
4624:  SUBWF  xB6,W
4626:  BC    4668
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
4628:  MOVF   xB4,W
462A:  ADDWF  xB6,W
462C:  MOVWF  01
462E:  MOVF   xB5,W
4630:  ADDWFC xB7,W
4632:  MOVWF  03
4634:  MOVFF  01,9B8
4638:  MOVWF  xB9
463A:  MOVF   xB6,W
463C:  ADDWF  xB0,W
463E:  MOVWF  xBA
4640:  MOVF   xB7,W
4642:  ADDWFC xB1,W
4644:  MOVWF  xBB
4646:  MOVWF  xBD
4648:  MOVFF  9BA,9BC
464C:  MOVLB  0
464E:  CALL   2E48
4652:  MOVFF  9B9,FEA
4656:  MOVFF  9B8,FE9
465A:  MOVFF  01,FEF
....................    } 
465E:  MOVLB  9
4660:  INCF   xB6,F
4662:  BTFSC  FD8.2
4664:  INCF   xB7,F
4666:  BRA    461A
....................     
.................... } 
4668:  MOVLB  0
466A:  RETURN 0
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_count_num         65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_delaykb           149 
.................... #define KB_time                  126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
2F62:  MOVLB  9
2F64:  CLRF   xC0
2F66:  MOVF   xBD,W
2F68:  SUBWF  xC0,W
2F6A:  BC    2F80
....................    { 
....................       inputdat[i]=0; 
2F6C:  CLRF   03
2F6E:  MOVF   xC0,W
2F70:  ADDWF  xBE,W
2F72:  MOVWF  FE9
2F74:  MOVF   xBF,W
2F76:  ADDWFC 03,W
2F78:  MOVWF  FEA
2F7A:  CLRF   FEF
....................    } 
2F7C:  INCF   xC0,F
2F7E:  BRA    2F66
.................... } 
2F80:  MOVLB  0
2F82:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_write(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
5A8C:  MOVLB  8
5A8E:  CLRF   xE6
5A90:  MOVF   xE3,W
5A92:  SUBWF  xE6,W
5A94:  BC    5ADC
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
5A96:  MOVF   xE6,W
5A98:  ADDWF  xE2,W
5A9A:  MOVWF  xE7
5A9C:  CLRF   03
5A9E:  MOVF   xE6,W
5AA0:  ADDWF  xE4,W
5AA2:  MOVWF  FE9
5AA4:  MOVF   xE5,W
5AA6:  ADDWFC 03,W
5AA8:  MOVWF  FEA
5AAA:  MOVFF  FEF,8E8
5AAE:  CLRF   19
5AB0:  BTFSC  FF2.7
5AB2:  BSF    19.7
5AB4:  BCF    FF2.7
5AB6:  MOVLB  9
5AB8:  CLRF   xC0
5ABA:  MOVFF  8E7,9BF
5ABE:  MOVFF  8E8,9C1
5AC2:  MOVLB  0
5AC4:  CALL   336C
5AC8:  BTFSC  19.7
5ACA:  BSF    FF2.7
....................       delay_us(10); 
5ACC:  MOVLW  1A
5ACE:  MOVWF  00
5AD0:  DECFSZ 00,F
5AD2:  BRA    5AD0
5AD4:  NOP   
....................    } 
5AD6:  MOVLB  8
5AD8:  INCF   xE6,F
5ADA:  BRA    5A90
.................... } 
5ADC:  MOVLB  0
5ADE:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
3D76:  MOVLB  9
3D78:  CLRF   xB2
3D7A:  MOVF   xAF,W
3D7C:  SUBWF  xB2,W
3D7E:  BC    3DC0
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
3D80:  CLRF   03
3D82:  MOVF   xB2,W
3D84:  ADDWF  xB0,W
3D86:  MOVWF  01
3D88:  MOVF   xB1,W
3D8A:  ADDWFC 03,F
3D8C:  MOVFF  01,9B3
3D90:  MOVFF  03,9B4
3D94:  MOVF   xB2,W
3D96:  ADDWF  xAE,W
3D98:  MOVWF  xB5
3D9A:  CLRF   xBD
3D9C:  MOVWF  xBC
3D9E:  MOVLB  0
3DA0:  CALL   2E48
3DA4:  MOVFF  9B4,FEA
3DA8:  MOVFF  9B3,FE9
3DAC:  MOVFF  01,FEF
....................       delay_us(10); 
3DB0:  MOVLW  1A
3DB2:  MOVWF  00
3DB4:  DECFSZ 00,F
3DB6:  BRA    3DB4
3DB8:  NOP   
....................    } 
3DBA:  MOVLB  9
3DBC:  INCF   xB2,F
3DBE:  BRA    3D7A
.................... } 
3DC0:  MOVLB  0
3DC2:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
5C70:  MOVLB  8
5C72:  CLRF   x9B
5C74:  CLRF   x9A
5C76:  CLRF   x99
5C78:  CLRF   x98
5C7A:  CLRF   x9F
5C7C:  CLRF   x9E
5C7E:  CLRF   x9D
5C80:  CLRF   x9C
5C82:  CLRF   xA3
5C84:  CLRF   xA2
5C86:  CLRF   xA1
5C88:  CLRF   xA0
5C8A:  CLRF   xA7
5C8C:  CLRF   xA6
5C8E:  CLRF   xA5
5C90:  CLRF   xA4
5C92:  CLRF   xAB
5C94:  CLRF   xAA
5C96:  CLRF   xA9
5C98:  CLRF   xA8
5C9A:  CLRF   19
5C9C:  BTFSC  FF2.7
5C9E:  BSF    19.7
5CA0:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
5CA2:  MOVLB  9
5CA4:  CLRF   xBD
5CA6:  MOVFF  897,9BC
5CAA:  MOVLB  0
5CAC:  CALL   2E48
5CB0:  BTFSC  19.7
5CB2:  BSF    FF2.7
5CB4:  MOVLB  8
5CB6:  MOVFF  01,89C
5CBA:  CLRF   x9D
5CBC:  CLRF   x9E
5CBE:  CLRF   x9F
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
5CC0:  MOVLW  01
5CC2:  ADDWF  x97,W
5CC4:  MOVWF  xAC
5CC6:  CLRF   19
5CC8:  BTFSC  FF2.7
5CCA:  BSF    19.7
5CCC:  BCF    FF2.7
5CCE:  MOVLB  9
5CD0:  CLRF   xBD
5CD2:  MOVWF  xBC
5CD4:  MOVLB  0
5CD6:  CALL   2E48
5CDA:  BTFSC  19.7
5CDC:  BSF    FF2.7
5CDE:  MOVLB  8
5CE0:  CLRF   xA3
5CE2:  CLRF   xA2
5CE4:  CLRF   xA1
5CE6:  MOVFF  01,8A0
....................    temp2<<=8; 
5CEA:  MOVFF  8A2,8A3
5CEE:  MOVFF  8A1,8A2
5CF2:  MOVFF  8A0,8A1
5CF6:  CLRF   xA0
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
5CF8:  MOVLW  02
5CFA:  ADDWF  x97,W
5CFC:  MOVWF  xAC
5CFE:  CLRF   19
5D00:  BTFSC  FF2.7
5D02:  BSF    19.7
5D04:  BCF    FF2.7
5D06:  MOVLB  9
5D08:  CLRF   xBD
5D0A:  MOVWF  xBC
5D0C:  MOVLB  0
5D0E:  CALL   2E48
5D12:  BTFSC  19.7
5D14:  BSF    FF2.7
5D16:  MOVLB  8
5D18:  CLRF   xA7
5D1A:  CLRF   xA6
5D1C:  CLRF   xA5
5D1E:  MOVFF  01,8A4
....................    temp3<<=16; 
5D22:  MOVFF  8A5,8A7
5D26:  MOVFF  8A4,8A6
5D2A:  CLRF   xA4
5D2C:  CLRF   xA5
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
5D2E:  MOVLW  03
5D30:  ADDWF  x97,W
5D32:  MOVWF  xAC
5D34:  CLRF   19
5D36:  BTFSC  FF2.7
5D38:  BSF    19.7
5D3A:  BCF    FF2.7
5D3C:  MOVLB  9
5D3E:  CLRF   xBD
5D40:  MOVWF  xBC
5D42:  MOVLB  0
5D44:  CALL   2E48
5D48:  BTFSC  19.7
5D4A:  BSF    FF2.7
5D4C:  MOVLB  8
5D4E:  CLRF   xAB
5D50:  CLRF   xAA
5D52:  CLRF   xA9
5D54:  MOVFF  01,8A8
....................    temp4<<=24; 
5D58:  MOVFF  8A8,8AB
5D5C:  CLRF   xA8
5D5E:  CLRF   xA9
5D60:  CLRF   xAA
....................    buffer = temp4|temp3|temp2|temp1; 
5D62:  MOVF   xA8,W
5D64:  IORWF  xA4,W
5D66:  MOVWF  xAC
5D68:  MOVF   xA9,W
5D6A:  IORWF  xA5,W
5D6C:  MOVWF  xAD
5D6E:  MOVF   xAA,W
5D70:  IORWF  xA6,W
5D72:  MOVWF  xAE
5D74:  MOVF   xAB,W
5D76:  IORWF  xA7,W
5D78:  MOVWF  xAF
5D7A:  MOVF   xA0,W
5D7C:  IORWF  xAC,F
5D7E:  MOVF   xA1,W
5D80:  IORWF  xAD,F
5D82:  MOVF   xA2,W
5D84:  IORWF  xAE,F
5D86:  MOVF   xA3,W
5D88:  IORWF  xAF,F
5D8A:  MOVF   xAC,W
5D8C:  IORWF  x9C,W
5D8E:  MOVWF  x98
5D90:  MOVF   xAD,W
5D92:  IORWF  x9D,W
5D94:  MOVWF  x99
5D96:  MOVF   xAE,W
5D98:  IORWF  x9E,W
5D9A:  MOVWF  x9A
5D9C:  MOVF   xAF,W
5D9E:  IORWF  x9F,W
5DA0:  MOVWF  x9B
....................    return(buffer); 
5DA2:  MOVFF  898,00
5DA6:  MOVFF  899,01
5DAA:  MOVFF  89A,02
5DAE:  MOVFF  89B,03
.................... } 
5DB2:  MOVLB  0
5DB4:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3472:  MOVLB  9
3474:  CLRF   xB9
3476:  CLRF   xB8
3478:  CLRF   xB7
347A:  CLRF   xB6
347C:  CLRF   xBA
347E:  CLRF   xBB
3480:  CLRF   xBC
3482:  CLRF   xBD
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3484:  MOVFF  9B4,9B9
3488:  MOVFF  9B3,9B8
348C:  MOVFF  9B2,9B7
3490:  MOVFF  9B1,9B6
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3494:  MOVFF  9B6,9BA
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3498:  MOVFF  9B7,9BB
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
349C:  MOVFF  9B8,9BC
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
34A0:  MOVFF  9B9,9BD
....................    write_ext_eeprom((addr+0),temp1); 
34A4:  CLRF   xC0
34A6:  MOVFF  9B5,9BF
34AA:  MOVFF  9BA,9C1
34AE:  MOVLB  0
34B0:  RCALL  336C
....................    write_ext_eeprom((addr+1),temp2); 
34B2:  MOVLW  01
34B4:  MOVLB  9
34B6:  ADDWF  xB5,W
34B8:  MOVWF  xBE
34BA:  CLRF   xC0
34BC:  MOVWF  xBF
34BE:  MOVFF  9BB,9C1
34C2:  MOVLB  0
34C4:  RCALL  336C
....................    write_ext_eeprom((addr+2),temp3); 
34C6:  MOVLW  02
34C8:  MOVLB  9
34CA:  ADDWF  xB5,W
34CC:  MOVWF  xBE
34CE:  CLRF   xC0
34D0:  MOVWF  xBF
34D2:  MOVFF  9BC,9C1
34D6:  MOVLB  0
34D8:  RCALL  336C
....................    write_ext_eeprom((addr+3),temp4); 
34DA:  MOVLW  03
34DC:  MOVLB  9
34DE:  ADDWF  xB5,W
34E0:  MOVWF  xBE
34E2:  CLRF   xC0
34E4:  MOVWF  xBF
34E6:  MOVFF  9BD,9C1
34EA:  MOVLB  0
34EC:  RCALL  336C
.................... } 
34EE:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
3AC8:  MOVLB  9
3ACA:  CLRF   xB3
3ACC:  CLRF   xB2
3ACE:  CLRF   xB4
3AD0:  CLRF   xB5
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
3AD2:  MOVFF  9B1,9B3
3AD6:  MOVFF  9B0,9B2
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3ADA:  MOVFF  9B2,9B4
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3ADE:  MOVF   xB3,W
3AE0:  MOVWF  xB5
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
3AE2:  CLRF   xC0
3AE4:  MOVLW  28
3AE6:  MOVWF  xBF
3AE8:  MOVFF  9B4,9C1
3AEC:  MOVLB  0
3AEE:  RCALL  336C
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
3AF0:  MOVLB  9
3AF2:  CLRF   xC0
3AF4:  MOVLW  29
3AF6:  MOVWF  xBF
3AF8:  MOVFF  9B5,9C1
3AFC:  MOVLB  0
3AFE:  RCALL  336C
.................... } 
3B00:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
2EF0:  MOVLB  9
2EF2:  CLRF   xB2
2EF4:  CLRF   xB1
2EF6:  CLRF   xB4
2EF8:  CLRF   xB3
2EFA:  CLRF   xB6
2EFC:  CLRF   xB5
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
2EFE:  CLRF   xBD
2F00:  MOVLW  28
2F02:  MOVWF  xBC
2F04:  MOVLB  0
2F06:  RCALL  2E48
2F08:  MOVLB  9
2F0A:  MOVFF  01,9B3
2F0E:  CLRF   xB4
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
2F10:  CLRF   xBD
2F12:  MOVLW  29
2F14:  MOVWF  xBC
2F16:  MOVLB  0
2F18:  RCALL  2E48
2F1A:  MOVLB  9
2F1C:  CLRF   xB6
2F1E:  MOVFF  01,9B5
....................    temp2<<=8; 
2F22:  MOVFF  9B5,9B6
2F26:  CLRF   xB5
....................    buffer = temp2|temp1; 
2F28:  MOVF   xB5,W
2F2A:  IORWF  xB3,W
2F2C:  MOVWF  xB1
2F2E:  MOVF   xB6,W
2F30:  IORWF  xB4,W
2F32:  MOVWF  xB2
....................    return(buffer); 
2F34:  MOVFF  9B1,01
2F38:  MOVFF  9B2,02
.................... } 
2F3C:  MOVLB  0
2F3E:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int16 i; 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
3F76:  MOVLW  AA
3F78:  MOVLB  9
3F7A:  MOVWF  xAF
3F7C:  MOVLW  47
3F7E:  MOVWF  xAE
3F80:  MOVF   27,F
3F82:  BNZ   3F96
3F84:  MOVF   26,F
3F86:  BNZ   3F96
3F88:  MOVF   xAF,W
3F8A:  SUBWF  25,W
3F8C:  BNC   3FB0
3F8E:  BNZ   3F96
3F90:  MOVF   24,W
3F92:  SUBWF  xAE,W
3F94:  BC    3FB0
....................    { 
....................      write_ext_eeprom(i,0); 
3F96:  MOVFF  9AF,9C0
3F9A:  MOVFF  9AE,9BF
3F9E:  CLRF   xC1
3FA0:  MOVLB  0
3FA2:  CALL   336C
....................    } 
3FA6:  MOVLB  9
3FA8:  INCF   xAE,F
3FAA:  BTFSC  FD8.2
3FAC:  INCF   xAF,F
3FAE:  BRA    3F80
....................    for(i=ptr_start;i<ptr_card;i++) 
3FB0:  CLRF   xAF
3FB2:  MOVLW  96
3FB4:  MOVWF  xAE
3FB6:  MOVF   23,F
3FB8:  BNZ   3FCC
3FBA:  MOVF   22,F
3FBC:  BNZ   3FCC
3FBE:  MOVF   xAF,W
3FC0:  SUBWF  21,W
3FC2:  BNC   3FE6
3FC4:  BNZ   3FCC
3FC6:  MOVF   20,W
3FC8:  SUBWF  xAE,W
3FCA:  BC    3FE6
....................    { 
....................      write_ext_eeprom(i,0); 
3FCC:  MOVFF  9AF,9C0
3FD0:  MOVFF  9AE,9BF
3FD4:  CLRF   xC1
3FD6:  MOVLB  0
3FD8:  CALL   336C
....................    } 
3FDC:  MOVLB  9
3FDE:  INCF   xAE,F
3FE0:  BTFSC  FD8.2
3FE2:  INCF   xAF,F
3FE4:  BRA    3FB6
....................    ptr_card=ptr_start; 
3FE6:  CLRF   23
3FE8:  CLRF   22
3FEA:  CLRF   21
3FEC:  MOVLW  96
3FEE:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
3FF0:  CLRF   27
3FF2:  CLRF   26
3FF4:  MOVLW  AA
3FF6:  MOVWF  25
3FF8:  MOVLW  47
3FFA:  MOVWF  24
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3FFC:  MOVFF  23,9B4
4000:  MOVFF  22,9B3
4004:  MOVFF  21,9B2
4008:  MOVFF  20,9B1
400C:  MOVLW  19
400E:  MOVWF  xB5
4010:  MOVLB  0
4012:  CALL   3472
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
4016:  MOVFF  27,9B4
401A:  MOVFF  26,9B3
401E:  MOVFF  25,9B2
4022:  MOVFF  24,9B1
4026:  MOVLW  1E
4028:  MOVLB  9
402A:  MOVWF  xB5
402C:  MOVLB  0
402E:  CALL   3472
....................    save_coutcard(0); 
4032:  MOVLB  9
4034:  CLRF   xB1
4036:  CLRF   xB0
4038:  MOVLB  0
403A:  RCALL  3AC8
....................    countcard=get_countcard(); 
403C:  CALL   2EF0
4040:  MOVFF  02,FA
4044:  MOVFF  01,F9
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
.................... } 
4048:  RETURN 0
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int16 i; 
....................    for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
*
3EF2:  MOVLB  9
3EF4:  CLRF   xAF
3EF6:  MOVLW  96
3EF8:  MOVWF  xAE
3EFA:  INCFSZ xAE,W
3EFC:  BRA    3F04
3EFE:  INCFSZ xAF,W
3F00:  BRA    3F04
3F02:  BRA    3F1E
....................    { 
....................      write_ext_eeprom(i,0); 
3F04:  MOVFF  9AF,9C0
3F08:  MOVFF  9AE,9BF
3F0C:  CLRF   xC1
3F0E:  MOVLB  0
3F10:  CALL   336C
....................    } 
3F14:  MOVLB  9
3F16:  INCF   xAE,F
3F18:  BTFSC  FD8.2
3F1A:  INCF   xAF,F
3F1C:  BRA    3EFA
....................    ptr_card=ptr_start; 
3F1E:  CLRF   23
3F20:  CLRF   22
3F22:  CLRF   21
3F24:  MOVLW  96
3F26:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
3F28:  CLRF   27
3F2A:  CLRF   26
3F2C:  MOVLW  AA
3F2E:  MOVWF  25
3F30:  MOVLW  47
3F32:  MOVWF  24
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3F34:  MOVFF  23,9B4
3F38:  MOVFF  22,9B3
3F3C:  MOVFF  21,9B2
3F40:  MOVFF  20,9B1
3F44:  MOVLW  19
3F46:  MOVWF  xB5
3F48:  MOVLB  0
3F4A:  CALL   3472
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
3F4E:  MOVFF  27,9B4
3F52:  MOVFF  26,9B3
3F56:  MOVFF  25,9B2
3F5A:  MOVFF  24,9B1
3F5E:  MOVLW  1E
3F60:  MOVLB  9
3F62:  MOVWF  xB5
3F64:  MOVLB  0
3F66:  CALL   3472
....................    save_coutcard(0); 
3F6A:  MOVLB  9
3F6C:  CLRF   xB1
3F6E:  CLRF   xB0
3F70:  MOVLB  0
3F72:  RCALL  3AC8
.................... } 
3F74:  RETURN 0
.................... //=========================================== 
.................... void init_password() 
.................... { 
*
5AE0:  CLRF   19
5AE2:  BTFSC  FF2.7
5AE4:  BSF    19.7
5AE6:  BCF    FF2.7
....................       EEPROM_read(strobe_pass_addr,20,password); 
5AE8:  MOVLB  9
5AEA:  CLRF   xAE
5AEC:  MOVLW  14
5AEE:  MOVWF  xAF
5AF0:  CLRF   xB1
5AF2:  MOVLW  55
5AF4:  MOVWF  xB0
5AF6:  MOVLB  0
5AF8:  CALL   3D76
5AFC:  BTFSC  19.7
5AFE:  BSF    FF2.7
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5B00:  INCFSZ 55,W
5B02:  BRA    5B56
5B04:  INCFSZ 56,W
5B06:  BRA    5B56
5B08:  INCFSZ x64,W
5B0A:  BRA    5B56
....................       { 
....................          strcpy(buffer1,"admin"); 
5B0C:  CLRF   FEA
5B0E:  MOVLW  2D
5B10:  MOVWF  FE9
5B12:  MOVLW  00
5B14:  CALL   00D2
5B18:  TBLRD*-
5B1A:  TBLRD*+
5B1C:  MOVF   FF5,W
5B1E:  MOVWF  FEE
5B20:  IORLW  00
5B22:  BNZ   5B1A
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
5B24:  MOVLB  8
5B26:  CLRF   xE2
5B28:  MOVLW  14
5B2A:  MOVWF  xE3
5B2C:  CLRF   xE5
5B2E:  MOVLW  2D
5B30:  MOVWF  xE4
5B32:  MOVLB  0
5B34:  RCALL  5A8C
5B36:  CLRF   19
5B38:  BTFSC  FF2.7
5B3A:  BSF    19.7
5B3C:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
5B3E:  MOVLB  9
5B40:  CLRF   xAE
5B42:  MOVLW  14
5B44:  MOVWF  xAF
5B46:  CLRF   xB1
5B48:  MOVLW  55
5B4A:  MOVWF  xB0
5B4C:  MOVLB  0
5B4E:  CALL   3D76
5B52:  BTFSC  19.7
5B54:  BSF    FF2.7
....................       } 
.................... } 
5B56:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
618E:  MOVLB  8
6190:  CLRF   xE1
6192:  MOVF   xE1,W
6194:  SUBLW  13
6196:  BNC   61AC
6198:  CLRF   03
619A:  MOVF   xE1,W
619C:  ADDLW  CD
619E:  MOVWF  FE9
61A0:  MOVLW  08
61A2:  ADDWFC 03,W
61A4:  MOVWF  FEA
61A6:  SETF   FEF
61A8:  INCF   xE1,F
61AA:  BRA    6192
....................    EEPROM_write(strobe_pass_addr,20,buf); 
61AC:  CLRF   xE2
61AE:  MOVLW  14
61B0:  MOVWF  xE3
61B2:  MOVLW  08
61B4:  MOVWF  xE5
61B6:  MOVLW  CD
61B8:  MOVWF  xE4
61BA:  MOVLB  0
61BC:  RCALL  5A8C
.................... } 
61BE:  GOTO   6AC8 (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
2D7E:  BSF    F94.4
2D80:  MOVLW  0A
2D82:  MOVWF  00
2D84:  DECFSZ 00,F
2D86:  BRA    2D84
2D88:  BSF    F94.3
2D8A:  MOVLW  0B
2D8C:  MOVWF  00
2D8E:  DECFSZ 00,F
2D90:  BRA    2D8E
2D92:  BCF    F8B.4
2D94:  BCF    F94.4
2D96:  MOVLW  0A
2D98:  MOVWF  00
2D9A:  DECFSZ 00,F
2D9C:  BRA    2D9A
2D9E:  BCF    F8B.3
2DA0:  BCF    F94.3
....................    i2c_write(0xD0); 
2DA2:  MOVLW  D0
2DA4:  MOVLB  9
2DA6:  MOVWF  xC6
2DA8:  MOVLB  0
2DAA:  RCALL  2C9E
....................    i2c_write(address); 
2DAC:  MOVFF  9B5,9C6
2DB0:  RCALL  2C9E
....................    i2c_start(); 
2DB2:  BSF    F94.4
2DB4:  MOVLW  0A
2DB6:  MOVWF  00
2DB8:  DECFSZ 00,F
2DBA:  BRA    2DB8
2DBC:  BSF    F94.3
2DBE:  MOVLW  0B
2DC0:  MOVWF  00
2DC2:  DECFSZ 00,F
2DC4:  BRA    2DC2
2DC6:  BTFSS  F82.3
2DC8:  BRA    2DC6
2DCA:  BCF    F8B.4
2DCC:  BCF    F94.4
2DCE:  MOVLW  0A
2DD0:  MOVWF  00
2DD2:  DECFSZ 00,F
2DD4:  BRA    2DD2
2DD6:  BCF    F8B.3
2DD8:  BCF    F94.3
....................    i2c_write(0xD1); 
2DDA:  MOVLW  D1
2DDC:  MOVLB  9
2DDE:  MOVWF  xC6
2DE0:  MOVLB  0
2DE2:  RCALL  2C9E
....................    result = i2c_read(0); 
2DE4:  CLRF   00
2DE6:  RCALL  2D14
2DE8:  MOVFF  01,9B6
....................    i2c_stop(); 
2DEC:  BCF    F94.4
2DEE:  NOP   
2DF0:  BSF    F94.3
2DF2:  BTFSS  F82.3
2DF4:  BRA    2DF2
2DF6:  MOVLW  0A
2DF8:  MOVWF  00
2DFA:  DECFSZ 00,F
2DFC:  BRA    2DFA
2DFE:  BRA    2E00
2E00:  NOP   
2E02:  BSF    F94.4
2E04:  MOVLW  0A
2E06:  MOVWF  00
2E08:  DECFSZ 00,F
2E0A:  BRA    2E08
....................     
....................    return(result); 
2E0C:  MOVLB  9
2E0E:  MOVFF  9B6,01
.................... } 
2E12:  MOVLB  0
2E14:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
63AA:  BSF    F94.4
63AC:  MOVLW  0A
63AE:  MOVWF  00
63B0:  DECFSZ 00,F
63B2:  BRA    63B0
63B4:  BSF    F94.3
63B6:  MOVLW  0B
63B8:  MOVWF  00
63BA:  DECFSZ 00,F
63BC:  BRA    63BA
63BE:  BCF    F8B.4
63C0:  BCF    F94.4
63C2:  MOVLW  0A
63C4:  MOVWF  00
63C6:  DECFSZ 00,F
63C8:  BRA    63C6
63CA:  BCF    F8B.3
63CC:  BCF    F94.3
....................    delay_us(10); 
63CE:  MOVLW  1A
63D0:  MOVWF  00
63D2:  DECFSZ 00,F
63D4:  BRA    63D2
63D6:  NOP   
63D8:  CLRF   19
63DA:  BTFSC  FF2.7
63DC:  BSF    19.7
63DE:  BCF    FF2.7
....................    i2c_write(0xD0); 
63E0:  MOVLW  D0
63E2:  MOVLB  9
63E4:  MOVWF  xC6
63E6:  MOVLB  0
63E8:  CALL   2C9E
63EC:  BTFSC  19.7
63EE:  BSF    FF2.7
....................    delay_us(10); 
63F0:  MOVLW  1A
63F2:  MOVWF  00
63F4:  DECFSZ 00,F
63F6:  BRA    63F4
63F8:  NOP   
63FA:  CLRF   19
63FC:  BTFSC  FF2.7
63FE:  BSF    19.7
6400:  BCF    FF2.7
....................    i2c_write(address); 
6402:  MOVFF  8D4,9C6
6406:  CALL   2C9E
640A:  BTFSC  19.7
640C:  BSF    FF2.7
....................    delay_us(10); 
640E:  MOVLW  1A
6410:  MOVWF  00
6412:  DECFSZ 00,F
6414:  BRA    6412
6416:  NOP   
6418:  CLRF   19
641A:  BTFSC  FF2.7
641C:  BSF    19.7
641E:  BCF    FF2.7
....................    i2c_write(data); 
6420:  MOVFF  8D5,9C6
6424:  CALL   2C9E
6428:  BTFSC  19.7
642A:  BSF    FF2.7
....................    i2c_stop(); 
642C:  BCF    F94.4
642E:  NOP   
6430:  BSF    F94.3
6432:  BTFSS  F82.3
6434:  BRA    6432
6436:  MOVLW  0A
6438:  MOVWF  00
643A:  DECFSZ 00,F
643C:  BRA    643A
643E:  BRA    6440
6440:  NOP   
6442:  BSF    F94.4
6444:  MOVLW  0A
6446:  MOVWF  00
6448:  DECFSZ 00,F
644A:  BRA    6448
....................    delay_us(10); 
644C:  MOVLW  1A
644E:  MOVWF  00
6450:  DECFSZ 00,F
6452:  BRA    6450
6454:  NOP   
.................... } 
6456:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
*
5B58:  CLRF   19
5B5A:  BTFSC  FF2.7
5B5C:  BSF    19.7
5B5E:  BCF    FF2.7
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
5B60:  MOVLB  9
5B62:  CLRF   xB5
5B64:  MOVLB  0
5B66:  CALL   2D7E
5B6A:  BTFSC  19.7
5B6C:  BSF    FF2.7
5B6E:  MOVFF  01,897
....................     
....................    data &= 0x7F; 
5B72:  MOVLB  8
5B74:  BCF    x97.7
....................     
....................    i2c_start(); 
5B76:  BSF    F94.4
5B78:  MOVLW  0A
5B7A:  MOVWF  00
5B7C:  DECFSZ 00,F
5B7E:  BRA    5B7C
5B80:  BSF    F94.3
5B82:  MOVLW  0B
5B84:  MOVWF  00
5B86:  DECFSZ 00,F
5B88:  BRA    5B86
5B8A:  BCF    F8B.4
5B8C:  BCF    F94.4
5B8E:  MOVLW  0A
5B90:  MOVWF  00
5B92:  DECFSZ 00,F
5B94:  BRA    5B92
5B96:  BCF    F8B.3
5B98:  BCF    F94.3
5B9A:  CLRF   19
5B9C:  BTFSC  FF2.7
5B9E:  BSF    19.7
5BA0:  BCF    FF2.7
....................    i2c_write(0xD0); 
5BA2:  MOVLW  D0
5BA4:  MOVLB  9
5BA6:  MOVWF  xC6
5BA8:  MOVLB  0
5BAA:  CALL   2C9E
5BAE:  BTFSC  19.7
5BB0:  BSF    FF2.7
5BB2:  CLRF   19
5BB4:  BTFSC  FF2.7
5BB6:  BSF    19.7
5BB8:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
5BBA:  MOVLB  9
5BBC:  CLRF   xC6
5BBE:  MOVLB  0
5BC0:  CALL   2C9E
5BC4:  BTFSC  19.7
5BC6:  BSF    FF2.7
5BC8:  CLRF   19
5BCA:  BTFSC  FF2.7
5BCC:  BSF    19.7
5BCE:  BCF    FF2.7
....................    i2c_write(data); 
5BD0:  MOVFF  897,9C6
5BD4:  CALL   2C9E
5BD8:  BTFSC  19.7
5BDA:  BSF    FF2.7
....................    i2c_start(); 
5BDC:  BSF    F94.4
5BDE:  MOVLW  0A
5BE0:  MOVWF  00
5BE2:  DECFSZ 00,F
5BE4:  BRA    5BE2
5BE6:  BSF    F94.3
5BE8:  MOVLW  0B
5BEA:  MOVWF  00
5BEC:  DECFSZ 00,F
5BEE:  BRA    5BEC
5BF0:  BTFSS  F82.3
5BF2:  BRA    5BF0
5BF4:  BCF    F8B.4
5BF6:  BCF    F94.4
5BF8:  MOVLW  0A
5BFA:  MOVWF  00
5BFC:  DECFSZ 00,F
5BFE:  BRA    5BFC
5C00:  BCF    F8B.3
5C02:  BCF    F94.3
5C04:  CLRF   19
5C06:  BTFSC  FF2.7
5C08:  BSF    19.7
5C0A:  BCF    FF2.7
....................    i2c_write(0xD0); 
5C0C:  MOVLW  D0
5C0E:  MOVLB  9
5C10:  MOVWF  xC6
5C12:  MOVLB  0
5C14:  CALL   2C9E
5C18:  BTFSC  19.7
5C1A:  BSF    FF2.7
5C1C:  CLRF   19
5C1E:  BTFSC  FF2.7
5C20:  BSF    19.7
5C22:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
5C24:  MOVLW  07
5C26:  MOVLB  9
5C28:  MOVWF  xC6
5C2A:  MOVLB  0
5C2C:  CALL   2C9E
5C30:  BTFSC  19.7
5C32:  BSF    FF2.7
5C34:  CLRF   19
5C36:  BTFSC  FF2.7
5C38:  BSF    19.7
5C3A:  BCF    FF2.7
....................    i2c_write(0x80); 
5C3C:  MOVLW  80
5C3E:  MOVLB  9
5C40:  MOVWF  xC6
5C42:  MOVLB  0
5C44:  CALL   2C9E
5C48:  BTFSC  19.7
5C4A:  BSF    FF2.7
....................    i2c_stop(); 
5C4C:  BCF    F94.4
5C4E:  NOP   
5C50:  BSF    F94.3
5C52:  BTFSS  F82.3
5C54:  BRA    5C52
5C56:  MOVLW  0A
5C58:  MOVWF  00
5C5A:  DECFSZ 00,F
5C5C:  BRA    5C5A
5C5E:  BRA    5C60
5C60:  NOP   
5C62:  BSF    F94.4
5C64:  MOVLW  0A
5C66:  MOVWF  00
5C68:  DECFSZ 00,F
5C6A:  BRA    5C68
.................... } 
5C6C:  GOTO   827A (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
6458:  CLRF   19
645A:  BTFSC  FF2.7
645C:  BSF    19.7
645E:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
6460:  MOVFF  8D3,9B7
6464:  MOVLW  0A
6466:  MOVLB  9
6468:  MOVWF  xB8
646A:  MOVLB  0
646C:  CALL   16AE
6470:  BTFSC  19.7
6472:  BSF    FF2.7
6474:  MOVFF  01,8D4
....................    nibl=data-(nibh*10); 
6478:  MOVLB  8
647A:  MOVF   xD4,W
647C:  MULLW  0A
647E:  MOVF   FF3,W
6480:  SUBWF  xD3,W
6482:  MOVWF  xD5
....................  
....................    return((nibh<<4)|nibl); 
6484:  SWAPF  xD4,W
6486:  MOVWF  00
6488:  MOVLW  F0
648A:  ANDWF  00,F
648C:  MOVF   00,W
648E:  IORWF  xD5,W
6490:  MOVWF  01
.................... } 
6492:  MOVLB  0
6494:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
2E16:  MOVFF  9B6,9B7
....................    data=(i>>4)*10; 
2E1A:  MOVLB  9
2E1C:  SWAPF  xB7,W
2E1E:  MOVWF  00
2E20:  MOVLW  0F
2E22:  ANDWF  00,F
2E24:  MOVF   00,W
2E26:  MULLW  0A
2E28:  MOVFF  FF3,9B6
....................    data=data+(i<<4>>4); 
2E2C:  SWAPF  xB7,W
2E2E:  MOVWF  00
2E30:  MOVLW  F0
2E32:  ANDWF  00,F
2E34:  MOVF   00,W
2E36:  SWAPF  00,F
2E38:  MOVLW  0F
2E3A:  ANDWF  00,F
2E3C:  MOVF   00,W
2E3E:  ADDWF  xB6,F
....................  
....................    return data; 
2E40:  MOVFF  9B6,01
.................... } 
2E44:  MOVLB  0
2E46:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
6496:  MOVLB  8
6498:  CLRF   xD4
649A:  CLRF   xD5
649C:  MOVLB  0
649E:  RCALL  63AA
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
64A0:  MOVFF  8D2,8D3
64A4:  RCALL  6458
64A6:  MOVFF  01,8D3
64AA:  MOVLW  01
64AC:  MOVLB  8
64AE:  MOVWF  xD4
64B0:  MOVFF  01,8D5
64B4:  MOVLB  0
64B6:  RCALL  63AA
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
64B8:  MOVFF  8D1,8D3
64BC:  RCALL  6458
64BE:  MOVFF  01,8D3
64C2:  MOVLW  02
64C4:  MOVLB  8
64C6:  MOVWF  xD4
64C8:  MOVFF  01,8D5
64CC:  MOVLB  0
64CE:  RCALL  63AA
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
64D0:  MOVFF  8D0,8D3
64D4:  RCALL  6458
64D6:  MOVFF  01,8D3
64DA:  MOVLW  03
64DC:  MOVLB  8
64DE:  MOVWF  xD4
64E0:  MOVFF  01,8D5
64E4:  MOVLB  0
64E6:  RCALL  63AA
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
64E8:  MOVFF  8CD,8D3
64EC:  RCALL  6458
64EE:  MOVFF  01,8D3
64F2:  MOVLW  04
64F4:  MOVLB  8
64F6:  MOVWF  xD4
64F8:  MOVFF  01,8D5
64FC:  MOVLB  0
64FE:  RCALL  63AA
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
6500:  MOVFF  8CE,8D3
6504:  RCALL  6458
6506:  MOVFF  01,8D3
650A:  MOVLW  05
650C:  MOVLB  8
650E:  MOVWF  xD4
6510:  MOVFF  01,8D5
6514:  MOVLB  0
6516:  RCALL  63AA
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
6518:  MOVFF  8CF,8D3
651C:  RCALL  6458
651E:  MOVFF  01,8D3
6522:  MOVLW  06
6524:  MOVLB  8
6526:  MOVWF  xD4
6528:  MOVFF  01,8D5
652C:  MOVLB  0
652E:  RCALL  63AA
....................    write_DS1307(DS1307_CONTROL,0);    
6530:  MOVLW  07
6532:  MOVLB  8
6534:  MOVWF  xD4
6536:  CLRF   xD5
6538:  MOVLB  0
653A:  RCALL  63AA
.................... } 
653C:  GOTO   728C (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
34F6:  MOVLW  04
34F8:  MOVLB  9
34FA:  MOVWF  xB5
34FC:  MOVLB  0
34FE:  RCALL  2D7E
3500:  MOVFF  01,9B1
3504:  MOVFF  01,9B6
3508:  RCALL  2E16
350A:  MOVFF  01,100
*
6CDE:  MOVLW  04
6CE0:  MOVLB  9
6CE2:  MOVWF  xB5
6CE4:  MOVLB  0
6CE6:  CALL   2D7E
6CEA:  MOVFF  01,9B1
6CEE:  MOVFF  01,9B6
6CF2:  CALL   2E16
6CF6:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
*
350E:  MOVLW  05
3510:  MOVLB  9
3512:  MOVWF  xB5
3514:  MOVLB  0
3516:  RCALL  2D7E
3518:  MOVFF  01,9B1
351C:  MOVFF  01,9B6
3520:  RCALL  2E16
3522:  MOVFF  01,FF
*
6CFA:  MOVLW  05
6CFC:  MOVLB  9
6CFE:  MOVWF  xB5
6D00:  MOVLB  0
6D02:  CALL   2D7E
6D06:  MOVFF  01,9B1
6D0A:  MOVFF  01,9B6
6D0E:  CALL   2E16
6D12:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
*
3526:  MOVLW  06
3528:  MOVLB  9
352A:  MOVWF  xB5
352C:  MOVLB  0
352E:  RCALL  2D7E
3530:  MOVFF  01,9B1
3534:  MOVFF  01,9B6
3538:  RCALL  2E16
353A:  MOVFF  01,FE
*
6D16:  MOVLW  06
6D18:  MOVLB  9
6D1A:  MOVWF  xB5
6D1C:  MOVLB  0
6D1E:  CALL   2D7E
6D22:  MOVFF  01,9B1
6D26:  MOVFF  01,9B6
6D2A:  CALL   2E16
6D2E:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
*
353E:  MOVLW  03
3540:  MOVLB  9
3542:  MOVWF  xB5
3544:  MOVLB  0
3546:  RCALL  2D7E
3548:  MOVFF  01,9B1
354C:  MOVFF  01,9B6
3550:  RCALL  2E16
3552:  MOVFF  01,FD
*
6D32:  MOVLW  03
6D34:  MOVLB  9
6D36:  MOVWF  xB5
6D38:  MOVLB  0
6D3A:  CALL   2D7E
6D3E:  MOVFF  01,9B1
6D42:  MOVFF  01,9B6
6D46:  CALL   2E16
6D4A:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
*
3556:  MOVLW  02
3558:  MOVLB  9
355A:  MOVWF  xB5
355C:  MOVLB  0
355E:  RCALL  2D7E
3560:  MOVFF  01,9B1
3564:  MOVFF  01,9B6
3568:  RCALL  2E16
356A:  MOVFF  01,101
*
6D4E:  MOVLW  02
6D50:  MOVLB  9
6D52:  MOVWF  xB5
6D54:  MOVLB  0
6D56:  CALL   2D7E
6D5A:  MOVFF  01,9B1
6D5E:  MOVFF  01,9B6
6D62:  CALL   2E16
6D66:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
*
356E:  MOVLW  01
3570:  MOVLB  9
3572:  MOVWF  xB5
3574:  MOVLB  0
3576:  RCALL  2D7E
3578:  MOVFF  01,9B1
357C:  MOVFF  01,9B6
3580:  RCALL  2E16
3582:  MOVFF  01,102
*
6D6A:  MOVLW  01
6D6C:  MOVLB  9
6D6E:  MOVWF  xB5
6D70:  MOVLB  0
6D72:  CALL   2D7E
6D76:  MOVFF  01,9B1
6D7A:  MOVFF  01,9B6
6D7E:  CALL   2E16
6D82:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
*
3586:  MOVLB  9
3588:  CLRF   xB5
358A:  MOVLB  0
358C:  CALL   2D7E
3590:  MOVFF  01,9B1
3594:  MOVFF  01,9B6
3598:  RCALL  2E16
359A:  MOVFF  01,103
*
6D86:  MOVLB  9
6D88:  CLRF   xB5
6D8A:  MOVLB  0
6D8C:  CALL   2D7E
6D90:  MOVFF  01,9B1
6D94:  MOVFF  01,9B6
6D98:  CALL   2E16
6D9C:  MOVFF  01,103
6DA0:  CLRF   19
6DA2:  BTFSC  FF2.7
6DA4:  BSF    19.7
6DA6:  BCF    FF2.7
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... #include <scan_key.c> 
....................  
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... #define key_numbyte  50 
....................  
.................... int8 key_data[key_numbyte]; 
....................  
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
20FE:  MOVLB  1
2100:  INCF   x43,F
2102:  MOVF   x43,W
2104:  SUBLW  01
2106:  BTFSC  FD8.0
2108:  BRA    22AE
....................        switch (col) { 
210A:  MOVF   x46,W
210C:  ADDLW  FB
210E:  BC    2192
2110:  ADDLW  05
2112:  MOVLB  0
2114:  GOTO   22B8
....................          case 0   :  
....................                     output_low(COL0); 
2118:  BCF    F92.5
211A:  BCF    F89.5
....................                     output_high(COL1); 
211C:  BCF    F92.3
211E:  BSF    F89.3
....................                     output_high(COL2); 
2120:  BCF    F92.2
2122:  BSF    F89.2
....................                     output_high(COL3); 
2124:  BCF    F92.1
2126:  BSF    F89.1
....................                     output_high(COL4); 
2128:  BCF    F92.0
212A:  BSF    F89.0
....................                     break; 
212C:  MOVLB  1
212E:  BRA    2192
....................          case 1   :  
....................                     output_low(COL1); 
2130:  BCF    F92.3
2132:  BCF    F89.3
....................                     output_high(COL0); 
2134:  BCF    F92.5
2136:  BSF    F89.5
....................                     output_high(COL2); 
2138:  BCF    F92.2
213A:  BSF    F89.2
....................                     output_high(COL3); 
213C:  BCF    F92.1
213E:  BSF    F89.1
....................                     output_high(COL4); 
2140:  BCF    F92.0
2142:  BSF    F89.0
....................                     break; 
2144:  MOVLB  1
2146:  BRA    2192
....................          case 2   :  
....................                     output_low(COL2); 
2148:  BCF    F92.2
214A:  BCF    F89.2
....................                     output_high(COL1); 
214C:  BCF    F92.3
214E:  BSF    F89.3
....................                     output_high(COL0); 
2150:  BCF    F92.5
2152:  BSF    F89.5
....................                     output_high(COL3); 
2154:  BCF    F92.1
2156:  BSF    F89.1
....................                     output_high(COL4); 
2158:  BCF    F92.0
215A:  BSF    F89.0
....................                     break; 
215C:  MOVLB  1
215E:  BRA    2192
....................          case 3   :  
....................                     output_low(COL3); 
2160:  BCF    F92.1
2162:  BCF    F89.1
....................                     output_high(COL1); 
2164:  BCF    F92.3
2166:  BSF    F89.3
....................                     output_high(COL2); 
2168:  BCF    F92.2
216A:  BSF    F89.2
....................                     output_high(COL0); 
216C:  BCF    F92.5
216E:  BSF    F89.5
....................                     output_high(COL4); 
2170:  BCF    F92.0
2172:  BSF    F89.0
....................                     break; 
2174:  MOVLB  1
2176:  BRA    2192
....................          case 4   :  
....................                     output_low(COL4); 
2178:  BCF    F92.0
217A:  BCF    F89.0
....................                     output_high(COL1); 
217C:  BCF    F92.3
217E:  BSF    F89.3
....................                     output_high(COL2); 
2180:  BCF    F92.2
2182:  BSF    F89.2
....................                     output_high(COL3); 
2184:  BCF    F92.1
2186:  BSF    F89.1
....................                     output_high(COL0); 
2188:  BCF    F92.5
218A:  BSF    F89.5
....................                     break; 
218C:  MOVLB  1
218E:  BRA    2192
2190:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2192:  BTFSS  x44.0
2194:  BRA    2214
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2196:  BSF    F93.4
2198:  MOVLW  00
219A:  BTFSC  F81.4
219C:  MOVLW  01
219E:  MOVLB  9
21A0:  MOVWF  xB0
21A2:  BSF    F93.5
21A4:  MOVLW  00
21A6:  BTFSC  F81.5
21A8:  MOVLW  01
21AA:  ANDWF  xB0,F
21AC:  BSF    F93.6
21AE:  MOVLW  00
21B0:  BTFSC  F81.6
21B2:  MOVLW  01
21B4:  ANDWF  xB0,F
21B6:  BSF    F93.7
21B8:  MOVLW  00
21BA:  BTFSC  F81.7
21BC:  MOVLW  01
21BE:  ANDWF  xB0,W
21C0:  BZ    2210
....................          { 
....................             kchar=last_key; 
21C2:  MOVFF  145,9AE
....................             if(keydebug_en==0) 
21C6:  MOVLB  1
21C8:  MOVF   x08,F
21CA:  BNZ   21FE
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
21CC:  CLRF   x06
21CE:  CLRF   x05
....................               charac_timeout=0; 
21D0:  MOVLB  0
21D2:  CLRF   xFC
21D4:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
21D6:  MOVLB  1
21D8:  MOVF   x0B,W
21DA:  SUBLW  31
21DC:  BNC   21F2
21DE:  MOVF   x0B,W
21E0:  INCF   x0B,F
21E2:  CLRF   03
21E4:  ADDLW  10
21E6:  MOVWF  FE9
21E8:  MOVLW  01
21EA:  ADDWFC 03,W
21EC:  MOVWF  FEA
21EE:  MOVFF  9AE,FEF
....................                fputc(kchar,COM2); 
21F2:  MOVFF  9AE,9D3
21F6:  MOVLB  0
21F8:  CALL   0608
....................             } 
....................                else fputc(kchar,COM2); 
21FC:  BRA    2208
21FE:  MOVFF  9AE,9D3
2202:  MOVLB  0
2204:  CALL   0608
....................            kbd_down=FALSE; 
2208:  MOVLB  1
220A:  BCF    x44.0
....................            last_key=0; 
220C:  CLRF   x45
220E:  MOVLB  9
....................          } 
....................        } else 
2210:  BRA    22AA
2212:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
2214:  BSF    F93.4
2216:  MOVLW  00
2218:  BTFSC  F81.4
221A:  MOVLW  01
221C:  MOVLB  9
221E:  MOVWF  xB0
2220:  BSF    F93.5
2222:  MOVLW  00
2224:  BTFSC  F81.5
2226:  MOVLW  01
2228:  ANDWF  xB0,F
222A:  BSF    F93.6
222C:  MOVLW  00
222E:  BTFSC  F81.6
2230:  MOVLW  01
2232:  ANDWF  xB0,F
2234:  BSF    F93.7
2236:  MOVLW  00
2238:  BTFSC  F81.7
223A:  MOVLW  01
223C:  ANDWF  xB0,W
223E:  BNZ   229E
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
2240:  BSF    F93.4
2242:  BTFSC  F81.4
2244:  BRA    224A
....................                   row=0; 
2246:  CLRF   xAF
....................                 else if(input(ROW1)==0) 
2248:  BRA    226C
224A:  BSF    F93.5
224C:  BTFSC  F81.5
224E:  BRA    2256
....................                   row=1; 
2250:  MOVLW  01
2252:  MOVWF  xAF
....................                 else if(input(ROW2)==0) 
2254:  BRA    226C
2256:  BSF    F93.6
2258:  BTFSC  F81.6
225A:  BRA    2262
....................                   row=2; 
225C:  MOVLW  02
225E:  MOVWF  xAF
....................                 else if(input(ROW3)==0) 
2260:  BRA    226C
2262:  BSF    F93.7
2264:  BTFSC  F81.7
2266:  BRA    226C
....................                   row=3; 
2268:  MOVLW  03
226A:  MOVWF  xAF
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
226C:  MOVF   xAF,W
226E:  MULLW  05
2270:  MOVF   FF3,W
2272:  CLRF   xB1
2274:  MOVWF  xB0
2276:  CLRF   03
2278:  MOVLB  1
227A:  MOVF   x46,W
227C:  MOVLB  9
227E:  ADDWF  xB0,W
2280:  MOVWF  01
2282:  MOVF   xB1,W
2284:  ADDWFC 03,F
2286:  MOVF   01,W
2288:  MOVLB  0
228A:  CALL   00E8
228E:  MOVFF  FE8,145
....................                 kbd_down = TRUE; 
2292:  MOVLB  1
2294:  BSF    x44.0
....................                 set_tris_a(0xff); 
2296:  MOVLW  FF
2298:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
229A:  BRA    22AA
229C:  MOVLB  9
....................                { 
....................                   ++col; 
229E:  MOVLB  1
22A0:  INCF   x46,F
....................                   if(col==5) col=0; 
22A2:  MOVF   x46,W
22A4:  SUBLW  05
22A6:  BTFSC  FD8.2
22A8:  CLRF   x46
....................                } 
....................          } 
....................       kbd_call_count=0; 
22AA:  MOVLB  1
22AC:  CLRF   x43
....................    } 
....................   return(kchar); 
22AE:  MOVLB  9
22B0:  MOVFF  9AE,01
.................... } 
22B4:  MOVLB  0
22B6:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
*
22DC:  MOVLW  E0
22DE:  MOVLB  F
22E0:  MOVWF  x48
22E2:  BCF    FC2.6
22E4:  BCF    FC2.7
22E6:  MOVF   x49,W
22E8:  ANDLW  E0
22EA:  IORLW  1F
22EC:  MOVWF  x49
....................    switch(col) 
....................    { 
22EE:  MOVLB  9
22F0:  MOVF   xC7,W
22F2:  ADDLW  FB
22F4:  BC    23A0
22F6:  ADDLW  05
22F8:  MOVLB  0
22FA:  GOTO   23A4
....................       case 0: 
....................         set_adc_channel(4); 
22FE:  MOVLW  10
2300:  MOVWF  01
2302:  MOVF   FC2,W
2304:  ANDLW  C3
2306:  IORWF  01,W
2308:  MOVWF  FC2
....................         adc=read_adc(); 
230A:  BSF    FC2.1
230C:  BTFSC  FC2.1
230E:  BRA    230C
2310:  MOVFF  FC4,9C8
....................         return adc; 
2314:  MOVLB  9
2316:  MOVFF  9C8,01
231A:  BRA    23A0
....................       break; 
231C:  BRA    23A0
....................       case 1: 
....................         set_adc_channel(3); 
231E:  MOVLW  0C
2320:  MOVWF  01
2322:  MOVF   FC2,W
2324:  ANDLW  C3
2326:  IORWF  01,W
2328:  MOVWF  FC2
....................         adc=read_adc(); 
232A:  BSF    FC2.1
232C:  BTFSC  FC2.1
232E:  BRA    232C
2330:  MOVFF  FC4,9C8
....................         return adc; 
2334:  MOVLB  9
2336:  MOVFF  9C8,01
233A:  BRA    23A0
....................       break; 
233C:  BRA    23A0
....................       case 2: 
....................         set_adc_channel(2); 
233E:  MOVLW  08
2340:  MOVWF  01
2342:  MOVF   FC2,W
2344:  ANDLW  C3
2346:  IORWF  01,W
2348:  MOVWF  FC2
....................         adc=read_adc(); 
234A:  BSF    FC2.1
234C:  BTFSC  FC2.1
234E:  BRA    234C
2350:  MOVFF  FC4,9C8
....................         return adc; 
2354:  MOVLB  9
2356:  MOVFF  9C8,01
235A:  BRA    23A0
....................       break; 
235C:  BRA    23A0
....................       case 3: 
....................         set_adc_channel(1); 
235E:  MOVLW  04
2360:  MOVWF  01
2362:  MOVF   FC2,W
2364:  ANDLW  C3
2366:  IORWF  01,W
2368:  MOVWF  FC2
....................         adc=read_adc(); 
236A:  BSF    FC2.1
236C:  BTFSC  FC2.1
236E:  BRA    236C
2370:  MOVFF  FC4,9C8
....................         return adc; 
2374:  MOVLB  9
2376:  MOVFF  9C8,01
237A:  BRA    23A0
....................       break; 
237C:  BRA    23A0
....................       case 4: 
....................         set_adc_channel(0); 
237E:  MOVLW  00
2380:  MOVWF  01
2382:  MOVF   FC2,W
2384:  ANDLW  C3
2386:  IORWF  01,W
2388:  MOVWF  FC2
....................         adc=read_adc(); 
238A:  BSF    FC2.1
238C:  BTFSC  FC2.1
238E:  BRA    238C
2390:  MOVFF  FC4,9C8
....................         return adc; 
2394:  MOVLB  9
2396:  MOVFF  9C8,01
239A:  BRA    23A0
....................       break;      
239C:  BRA    23A0
239E:  MOVLB  9
....................    } 
.................... } 
23A0:  MOVLB  0
23A2:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
251C:  MOVLB  9
251E:  CLRF   xB6
2520:  CLRF   xB5
2522:  CLRF   xB4
2524:  CLRF   xB3
2526:  CLRF   xBA
2528:  CLRF   xB9
252A:  CLRF   xB8
252C:  CLRF   xB7
252E:  CLRF   xBE
2530:  CLRF   xBD
2532:  CLRF   xBC
2534:  CLRF   xBB
2536:  CLRF   xC2
2538:  CLRF   xC1
253A:  CLRF   xC0
253C:  CLRF   xBF
253E:  CLRF   xC6
2540:  CLRF   xC5
2542:  CLRF   xC4
2544:  CLRF   xC3
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2546:  CLRF   xB2
2548:  CLRF   xB1
254A:  MOVF   xB2,W
254C:  SUBLW  01
254E:  BNC   25CC
2550:  BNZ   2558
2552:  MOVF   xB1,W
2554:  SUBLW  F3
2556:  BNC   25CC
....................    { 
....................       col_0=read_col(0)+col_0; 
2558:  CLRF   xC7
255A:  MOVLB  0
255C:  RCALL  22DC
255E:  MOVF   01,W
2560:  MOVLB  9
2562:  ADDWF  xB3,F
2564:  MOVLW  00
2566:  ADDWFC xB4,F
2568:  ADDWFC xB5,F
256A:  ADDWFC xB6,F
....................       col_1=read_col(1)+col_1; 
256C:  MOVLW  01
256E:  MOVWF  xC7
2570:  MOVLB  0
2572:  RCALL  22DC
2574:  MOVF   01,W
2576:  MOVLB  9
2578:  ADDWF  xB7,F
257A:  MOVLW  00
257C:  ADDWFC xB8,F
257E:  ADDWFC xB9,F
2580:  ADDWFC xBA,F
....................       col_2=read_col(2)+col_2; 
2582:  MOVLW  02
2584:  MOVWF  xC7
2586:  MOVLB  0
2588:  RCALL  22DC
258A:  MOVF   01,W
258C:  MOVLB  9
258E:  ADDWF  xBB,F
2590:  MOVLW  00
2592:  ADDWFC xBC,F
2594:  ADDWFC xBD,F
2596:  ADDWFC xBE,F
....................       col_3=read_col(3)+col_3; 
2598:  MOVLW  03
259A:  MOVWF  xC7
259C:  MOVLB  0
259E:  RCALL  22DC
25A0:  MOVF   01,W
25A2:  MOVLB  9
25A4:  ADDWF  xBF,F
25A6:  MOVLW  00
25A8:  ADDWFC xC0,F
25AA:  ADDWFC xC1,F
25AC:  ADDWFC xC2,F
....................       col_4=read_col(4)+col_4; 
25AE:  MOVLW  04
25B0:  MOVWF  xC7
25B2:  MOVLB  0
25B4:  RCALL  22DC
25B6:  MOVF   01,W
25B8:  MOVLB  9
25BA:  ADDWF  xC3,F
25BC:  MOVLW  00
25BE:  ADDWFC xC4,F
25C0:  ADDWFC xC5,F
25C2:  ADDWFC xC6,F
....................    } 
25C4:  INCF   xB1,F
25C6:  BTFSC  FD8.2
25C8:  INCF   xB2,F
25CA:  BRA    254A
....................    col_0=col_0/500; 
25CC:  BCF    FD8.1
25CE:  MOVFF  9B6,9D6
25D2:  MOVFF  9B5,9D5
25D6:  MOVFF  9B4,9D4
25DA:  MOVFF  9B3,9D3
25DE:  CLRF   xDA
25E0:  CLRF   xD9
25E2:  MOVLW  01
25E4:  MOVWF  xD8
25E6:  MOVLW  F4
25E8:  MOVWF  xD7
25EA:  MOVLB  0
25EC:  RCALL  23C8
25EE:  MOVFF  03,9B6
25F2:  MOVFF  02,9B5
25F6:  MOVFF  01,9B4
25FA:  MOVFF  00,9B3
....................    col_1=col_1/500; 
25FE:  BCF    FD8.1
2600:  MOVFF  9BA,9D6
2604:  MOVFF  9B9,9D5
2608:  MOVFF  9B8,9D4
260C:  MOVFF  9B7,9D3
2610:  MOVLB  9
2612:  CLRF   xDA
2614:  CLRF   xD9
2616:  MOVLW  01
2618:  MOVWF  xD8
261A:  MOVLW  F4
261C:  MOVWF  xD7
261E:  MOVLB  0
2620:  RCALL  23C8
2622:  MOVFF  03,9BA
2626:  MOVFF  02,9B9
262A:  MOVFF  01,9B8
262E:  MOVFF  00,9B7
....................    col_2=col_2/500; 
2632:  BCF    FD8.1
2634:  MOVFF  9BE,9D6
2638:  MOVFF  9BD,9D5
263C:  MOVFF  9BC,9D4
2640:  MOVFF  9BB,9D3
2644:  MOVLB  9
2646:  CLRF   xDA
2648:  CLRF   xD9
264A:  MOVLW  01
264C:  MOVWF  xD8
264E:  MOVLW  F4
2650:  MOVWF  xD7
2652:  MOVLB  0
2654:  RCALL  23C8
2656:  MOVFF  03,9BE
265A:  MOVFF  02,9BD
265E:  MOVFF  01,9BC
2662:  MOVFF  00,9BB
....................    col_3=col_3/500; 
2666:  BCF    FD8.1
2668:  MOVFF  9C2,9D6
266C:  MOVFF  9C1,9D5
2670:  MOVFF  9C0,9D4
2674:  MOVFF  9BF,9D3
2678:  MOVLB  9
267A:  CLRF   xDA
267C:  CLRF   xD9
267E:  MOVLW  01
2680:  MOVWF  xD8
2682:  MOVLW  F4
2684:  MOVWF  xD7
2686:  MOVLB  0
2688:  RCALL  23C8
268A:  MOVFF  03,9C2
268E:  MOVFF  02,9C1
2692:  MOVFF  01,9C0
2696:  MOVFF  00,9BF
....................    col_4=col_4/500; 
269A:  BCF    FD8.1
269C:  MOVFF  9C6,9D6
26A0:  MOVFF  9C5,9D5
26A4:  MOVFF  9C4,9D4
26A8:  MOVFF  9C3,9D3
26AC:  MOVLB  9
26AE:  CLRF   xDA
26B0:  CLRF   xD9
26B2:  MOVLW  01
26B4:  MOVWF  xD8
26B6:  MOVLW  F4
26B8:  MOVWF  xD7
26BA:  MOVLB  0
26BC:  RCALL  23C8
26BE:  MOVFF  03,9C6
26C2:  MOVFF  02,9C5
26C6:  MOVFF  01,9C4
26CA:  MOVFF  00,9C3
....................    if(keydebug_en) 
26CE:  MOVLB  1
26D0:  MOVF   x08,F
26D2:  BTFSC  FD8.2
26D4:  BRA    2850
....................    { 
....................       fprintf(COM2,"\r\n");      
26D6:  MOVLW  0D
26D8:  MOVLB  9
26DA:  MOVWF  xD3
26DC:  MOVLB  0
26DE:  CALL   0608
26E2:  MOVLW  0A
26E4:  MOVLB  9
26E6:  MOVWF  xD3
26E8:  MOVLB  0
26EA:  CALL   0608
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
26EE:  MOVLW  E4
26F0:  MOVWF  FF6
26F2:  MOVLW  03
26F4:  MOVWF  FF7
26F6:  MOVLW  07
26F8:  MOVLB  9
26FA:  MOVWF  xC7
26FC:  MOVLB  0
26FE:  CALL   15C6
2702:  MOVLW  41
2704:  MOVWF  FE9
2706:  MOVFF  9B6,9CA
270A:  MOVFF  9B5,9C9
270E:  MOVFF  9B4,9C8
2712:  MOVFF  9B3,9C7
2716:  RCALL  245C
2718:  MOVLW  0D
271A:  MOVLB  9
271C:  MOVWF  xD3
271E:  MOVLB  0
2720:  CALL   0608
2724:  MOVLW  0A
2726:  MOVLB  9
2728:  MOVWF  xD3
272A:  MOVLB  0
272C:  CALL   0608
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2730:  MOVLW  F2
2732:  MOVWF  FF6
2734:  MOVLW  03
2736:  MOVWF  FF7
2738:  MOVLW  07
273A:  MOVLB  9
273C:  MOVWF  xC7
273E:  MOVLB  0
2740:  CALL   15C6
2744:  MOVLW  41
2746:  MOVWF  FE9
2748:  MOVFF  9BA,9CA
274C:  MOVFF  9B9,9C9
2750:  MOVFF  9B8,9C8
2754:  MOVFF  9B7,9C7
2758:  RCALL  245C
275A:  MOVLW  0D
275C:  MOVLB  9
275E:  MOVWF  xD3
2760:  MOVLB  0
2762:  CALL   0608
2766:  MOVLW  0A
2768:  MOVLB  9
276A:  MOVWF  xD3
276C:  MOVLB  0
276E:  CALL   0608
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2772:  MOVLW  00
2774:  MOVWF  FF6
2776:  MOVLW  04
2778:  MOVWF  FF7
277A:  MOVLW  07
277C:  MOVLB  9
277E:  MOVWF  xC7
2780:  MOVLB  0
2782:  CALL   15C6
2786:  MOVLW  41
2788:  MOVWF  FE9
278A:  MOVFF  9BE,9CA
278E:  MOVFF  9BD,9C9
2792:  MOVFF  9BC,9C8
2796:  MOVFF  9BB,9C7
279A:  RCALL  245C
279C:  MOVLW  0D
279E:  MOVLB  9
27A0:  MOVWF  xD3
27A2:  MOVLB  0
27A4:  CALL   0608
27A8:  MOVLW  0A
27AA:  MOVLB  9
27AC:  MOVWF  xD3
27AE:  MOVLB  0
27B0:  CALL   0608
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
27B4:  MOVLW  0E
27B6:  MOVWF  FF6
27B8:  MOVLW  04
27BA:  MOVWF  FF7
27BC:  MOVLW  07
27BE:  MOVLB  9
27C0:  MOVWF  xC7
27C2:  MOVLB  0
27C4:  CALL   15C6
27C8:  MOVLW  41
27CA:  MOVWF  FE9
27CC:  MOVFF  9C2,9CA
27D0:  MOVFF  9C1,9C9
27D4:  MOVFF  9C0,9C8
27D8:  MOVFF  9BF,9C7
27DC:  RCALL  245C
27DE:  MOVLW  0D
27E0:  MOVLB  9
27E2:  MOVWF  xD3
27E4:  MOVLB  0
27E6:  CALL   0608
27EA:  MOVLW  0A
27EC:  MOVLB  9
27EE:  MOVWF  xD3
27F0:  MOVLB  0
27F2:  CALL   0608
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
27F6:  MOVLW  1C
27F8:  MOVWF  FF6
27FA:  MOVLW  04
27FC:  MOVWF  FF7
27FE:  MOVLW  07
2800:  MOVLB  9
2802:  MOVWF  xC7
2804:  MOVLB  0
2806:  CALL   15C6
280A:  MOVLW  41
280C:  MOVWF  FE9
280E:  MOVFF  9C6,9CA
2812:  MOVFF  9C5,9C9
2816:  MOVFF  9C4,9C8
281A:  MOVFF  9C3,9C7
281E:  RCALL  245C
2820:  MOVLW  0D
2822:  MOVLB  9
2824:  MOVWF  xD3
2826:  MOVLB  0
2828:  CALL   0608
282C:  MOVLW  0A
282E:  MOVLB  9
2830:  MOVWF  xD3
2832:  MOVLB  0
2834:  CALL   0608
....................       fprintf(COM2,"\r\n"); 
2838:  MOVLW  0D
283A:  MOVLB  9
283C:  MOVWF  xD3
283E:  MOVLB  0
2840:  CALL   0608
2844:  MOVLW  0A
2846:  MOVLB  9
2848:  MOVWF  xD3
284A:  MOVLB  0
284C:  CALL   0608
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
2850:  MOVLB  9
2852:  MOVF   xB6,F
2854:  BNZ   2864
2856:  MOVF   xB5,F
2858:  BNZ   2864
285A:  MOVF   xB4,F
285C:  BNZ   2864
285E:  MOVF   xB3,W
2860:  SUBLW  05
2862:  BC    28C4
2864:  MOVF   xB6,F
2866:  BNZ   28C4
2868:  MOVF   xB5,F
286A:  BNZ   28C4
286C:  MOVF   xB4,F
286E:  BNZ   28C4
2870:  MOVF   xB3,W
2872:  SUBLW  3B
2874:  BNC   28C4
2876:  MOVF   xBA,F
2878:  BNZ   2888
287A:  MOVF   xB9,F
287C:  BNZ   2888
287E:  MOVF   xB8,F
2880:  BNZ   2888
2882:  MOVF   xB7,W
2884:  SUBLW  64
2886:  BC    28C4
2888:  MOVF   xBE,F
288A:  BNZ   289A
288C:  MOVF   xBD,F
288E:  BNZ   289A
2890:  MOVF   xBC,F
2892:  BNZ   289A
2894:  MOVF   xBB,W
2896:  SUBLW  64
2898:  BC    28C4
289A:  MOVF   xC2,F
289C:  BNZ   28AC
289E:  MOVF   xC1,F
28A0:  BNZ   28AC
28A2:  MOVF   xC0,F
28A4:  BNZ   28AC
28A6:  MOVF   xBF,W
28A8:  SUBLW  64
28AA:  BC    28C4
28AC:  MOVF   xC6,F
28AE:  BNZ   28BE
28B0:  MOVF   xC5,F
28B2:  BNZ   28BE
28B4:  MOVF   xC4,F
28B6:  BNZ   28BE
28B8:  MOVF   xC3,W
28BA:  SUBLW  64
28BC:  BC    28C4
28BE:  MOVLW  00
28C0:  MOVWF  01
28C2:  BRA    2B42
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
28C4:  MOVF   xBA,F
28C6:  BNZ   28D6
28C8:  MOVF   xB9,F
28CA:  BNZ   28D6
28CC:  MOVF   xB8,F
28CE:  BNZ   28D6
28D0:  MOVF   xB7,W
28D2:  SUBLW  05
28D4:  BC    2936
28D6:  MOVF   xBA,F
28D8:  BNZ   2936
28DA:  MOVF   xB9,F
28DC:  BNZ   2936
28DE:  MOVF   xB8,F
28E0:  BNZ   2936
28E2:  MOVF   xB7,W
28E4:  SUBLW  3B
28E6:  BNC   2936
28E8:  MOVF   xB6,F
28EA:  BNZ   28FA
28EC:  MOVF   xB5,F
28EE:  BNZ   28FA
28F0:  MOVF   xB4,F
28F2:  BNZ   28FA
28F4:  MOVF   xB3,W
28F6:  SUBLW  64
28F8:  BC    2936
28FA:  MOVF   xBE,F
28FC:  BNZ   290C
28FE:  MOVF   xBD,F
2900:  BNZ   290C
2902:  MOVF   xBC,F
2904:  BNZ   290C
2906:  MOVF   xBB,W
2908:  SUBLW  64
290A:  BC    2936
290C:  MOVF   xC2,F
290E:  BNZ   291E
2910:  MOVF   xC1,F
2912:  BNZ   291E
2914:  MOVF   xC0,F
2916:  BNZ   291E
2918:  MOVF   xBF,W
291A:  SUBLW  64
291C:  BC    2936
291E:  MOVF   xC6,F
2920:  BNZ   2930
2922:  MOVF   xC5,F
2924:  BNZ   2930
2926:  MOVF   xC4,F
2928:  BNZ   2930
292A:  MOVF   xC3,W
292C:  SUBLW  64
292E:  BC    2936
2930:  MOVLW  01
2932:  MOVWF  01
2934:  BRA    2B42
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
2936:  MOVF   xBE,F
2938:  BNZ   2948
293A:  MOVF   xBD,F
293C:  BNZ   2948
293E:  MOVF   xBC,F
2940:  BNZ   2948
2942:  MOVF   xBB,W
2944:  SUBLW  05
2946:  BC    29A8
2948:  MOVF   xBE,F
294A:  BNZ   29A8
294C:  MOVF   xBD,F
294E:  BNZ   29A8
2950:  MOVF   xBC,F
2952:  BNZ   29A8
2954:  MOVF   xBB,W
2956:  SUBLW  3B
2958:  BNC   29A8
295A:  MOVF   xBA,F
295C:  BNZ   296C
295E:  MOVF   xB9,F
2960:  BNZ   296C
2962:  MOVF   xB8,F
2964:  BNZ   296C
2966:  MOVF   xB7,W
2968:  SUBLW  64
296A:  BC    29A8
296C:  MOVF   xB6,F
296E:  BNZ   297E
2970:  MOVF   xB5,F
2972:  BNZ   297E
2974:  MOVF   xB4,F
2976:  BNZ   297E
2978:  MOVF   xB3,W
297A:  SUBLW  64
297C:  BC    29A8
297E:  MOVF   xC2,F
2980:  BNZ   2990
2982:  MOVF   xC1,F
2984:  BNZ   2990
2986:  MOVF   xC0,F
2988:  BNZ   2990
298A:  MOVF   xBF,W
298C:  SUBLW  64
298E:  BC    29A8
2990:  MOVF   xC6,F
2992:  BNZ   29A2
2994:  MOVF   xC5,F
2996:  BNZ   29A2
2998:  MOVF   xC4,F
299A:  BNZ   29A2
299C:  MOVF   xC3,W
299E:  SUBLW  64
29A0:  BC    29A8
29A2:  MOVLW  02
29A4:  MOVWF  01
29A6:  BRA    2B42
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
29A8:  MOVF   xC2,F
29AA:  BNZ   29BA
29AC:  MOVF   xC1,F
29AE:  BNZ   29BA
29B0:  MOVF   xC0,F
29B2:  BNZ   29BA
29B4:  MOVF   xBF,W
29B6:  SUBLW  05
29B8:  BC    2A1A
29BA:  MOVF   xC2,F
29BC:  BNZ   2A1A
29BE:  MOVF   xC1,F
29C0:  BNZ   2A1A
29C2:  MOVF   xC0,F
29C4:  BNZ   2A1A
29C6:  MOVF   xBF,W
29C8:  SUBLW  3B
29CA:  BNC   2A1A
29CC:  MOVF   xBA,F
29CE:  BNZ   29DE
29D0:  MOVF   xB9,F
29D2:  BNZ   29DE
29D4:  MOVF   xB8,F
29D6:  BNZ   29DE
29D8:  MOVF   xB7,W
29DA:  SUBLW  64
29DC:  BC    2A1A
29DE:  MOVF   xBE,F
29E0:  BNZ   29F0
29E2:  MOVF   xBD,F
29E4:  BNZ   29F0
29E6:  MOVF   xBC,F
29E8:  BNZ   29F0
29EA:  MOVF   xBB,W
29EC:  SUBLW  64
29EE:  BC    2A1A
29F0:  MOVF   xB6,F
29F2:  BNZ   2A02
29F4:  MOVF   xB5,F
29F6:  BNZ   2A02
29F8:  MOVF   xB4,F
29FA:  BNZ   2A02
29FC:  MOVF   xB3,W
29FE:  SUBLW  64
2A00:  BC    2A1A
2A02:  MOVF   xC6,F
2A04:  BNZ   2A14
2A06:  MOVF   xC5,F
2A08:  BNZ   2A14
2A0A:  MOVF   xC4,F
2A0C:  BNZ   2A14
2A0E:  MOVF   xC3,W
2A10:  SUBLW  64
2A12:  BC    2A1A
2A14:  MOVLW  03
2A16:  MOVWF  01
2A18:  BRA    2B42
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2A1A:  MOVF   xC6,F
2A1C:  BNZ   2A2C
2A1E:  MOVF   xC5,F
2A20:  BNZ   2A2C
2A22:  MOVF   xC4,F
2A24:  BNZ   2A2C
2A26:  MOVF   xC3,W
2A28:  SUBLW  05
2A2A:  BC    2A8C
2A2C:  MOVF   xC6,F
2A2E:  BNZ   2A8C
2A30:  MOVF   xC5,F
2A32:  BNZ   2A8C
2A34:  MOVF   xC4,F
2A36:  BNZ   2A8C
2A38:  MOVF   xC3,W
2A3A:  SUBLW  3B
2A3C:  BNC   2A8C
2A3E:  MOVF   xBA,F
2A40:  BNZ   2A50
2A42:  MOVF   xB9,F
2A44:  BNZ   2A50
2A46:  MOVF   xB8,F
2A48:  BNZ   2A50
2A4A:  MOVF   xB7,W
2A4C:  SUBLW  64
2A4E:  BC    2A8C
2A50:  MOVF   xBE,F
2A52:  BNZ   2A62
2A54:  MOVF   xBD,F
2A56:  BNZ   2A62
2A58:  MOVF   xBC,F
2A5A:  BNZ   2A62
2A5C:  MOVF   xBB,W
2A5E:  SUBLW  64
2A60:  BC    2A8C
2A62:  MOVF   xC2,F
2A64:  BNZ   2A74
2A66:  MOVF   xC1,F
2A68:  BNZ   2A74
2A6A:  MOVF   xC0,F
2A6C:  BNZ   2A74
2A6E:  MOVF   xBF,W
2A70:  SUBLW  64
2A72:  BC    2A8C
2A74:  MOVF   xB6,F
2A76:  BNZ   2A86
2A78:  MOVF   xB5,F
2A7A:  BNZ   2A86
2A7C:  MOVF   xB4,F
2A7E:  BNZ   2A86
2A80:  MOVF   xB3,W
2A82:  SUBLW  64
2A84:  BC    2A8C
2A86:  MOVLW  04
2A88:  MOVWF  01
2A8A:  BRA    2B42
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2A8C:  MOVF   xC6,F
2A8E:  BNZ   2AA0
2A90:  MOVF   xC5,F
2A92:  BNZ   2AA0
2A94:  MOVF   xC4,F
2A96:  BNZ   2AA0
2A98:  MOVF   xC3,W
2A9A:  SUBLW  C8
2A9C:  BTFSC  FD8.0
2A9E:  BRA    2B3E
2AA0:  MOVF   xB6,F
2AA2:  BTFSS  FD8.2
2AA4:  BRA    2B3E
2AA6:  MOVF   xB5,F
2AA8:  BTFSS  FD8.2
2AAA:  BRA    2B3E
2AAC:  MOVF   xB4,F
2AAE:  BTFSS  FD8.2
2AB0:  BRA    2B3E
2AB2:  MOVF   xB3,W
2AB4:  SUBLW  B3
2AB6:  BNC   2B3E
2AB8:  MOVF   xB6,F
2ABA:  BNZ   2ACA
2ABC:  MOVF   xB5,F
2ABE:  BNZ   2ACA
2AC0:  MOVF   xB4,F
2AC2:  BNZ   2ACA
2AC4:  MOVF   xB3,W
2AC6:  SUBLW  64
2AC8:  BC    2B3E
2ACA:  MOVF   xBA,F
2ACC:  BNZ   2B3E
2ACE:  MOVF   xB9,F
2AD0:  BNZ   2B3E
2AD2:  MOVF   xB8,F
2AD4:  BNZ   2B3E
2AD6:  MOVF   xB7,W
2AD8:  SUBLW  B3
2ADA:  BNC   2B3E
2ADC:  MOVF   xBA,F
2ADE:  BNZ   2AEE
2AE0:  MOVF   xB9,F
2AE2:  BNZ   2AEE
2AE4:  MOVF   xB8,F
2AE6:  BNZ   2AEE
2AE8:  MOVF   xB7,W
2AEA:  SUBLW  64
2AEC:  BC    2B3E
2AEE:  MOVF   xBE,F
2AF0:  BNZ   2B3E
2AF2:  MOVF   xBD,F
2AF4:  BNZ   2B3E
2AF6:  MOVF   xBC,F
2AF8:  BNZ   2B3E
2AFA:  MOVF   xBB,W
2AFC:  SUBLW  B3
2AFE:  BNC   2B3E
2B00:  MOVF   xBE,F
2B02:  BNZ   2B12
2B04:  MOVF   xBD,F
2B06:  BNZ   2B12
2B08:  MOVF   xBC,F
2B0A:  BNZ   2B12
2B0C:  MOVF   xBB,W
2B0E:  SUBLW  64
2B10:  BC    2B3E
2B12:  MOVF   xC2,F
2B14:  BNZ   2B3E
2B16:  MOVF   xC1,F
2B18:  BNZ   2B3E
2B1A:  MOVF   xC0,F
2B1C:  BNZ   2B3E
2B1E:  MOVF   xBF,W
2B20:  SUBLW  B3
2B22:  BNC   2B3E
2B24:  MOVF   xC2,F
2B26:  BNZ   2B36
2B28:  MOVF   xC1,F
2B2A:  BNZ   2B36
2B2C:  MOVF   xC0,F
2B2E:  BNZ   2B36
2B30:  MOVF   xBF,W
2B32:  SUBLW  64
2B34:  BC    2B3E
2B36:  MOVLW  04
2B38:  MOVWF  01
2B3A:  BRA    2B42
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2B3C:  BRA    2B42
2B3E:  MOVLW  FF
2B40:  MOVWF  01
.................... } 
2B42:  MOVLB  0
2B44:  GOTO   2B9E (RETURN)
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
2B48:  BSF    F93.4
2B4A:  BTFSS  F81.4
2B4C:  BRA    2B60
2B4E:  BSF    F93.5
2B50:  BTFSS  F81.5
2B52:  BRA    2B60
2B54:  BSF    F93.6
2B56:  BTFSS  F81.6
2B58:  BRA    2B60
2B5A:  BSF    F93.7
2B5C:  BTFSC  F81.7
2B5E:  BRA    2C90
....................     { 
....................        if(input(ROW0)==0) 
2B60:  BSF    F93.4
2B62:  BTFSC  F81.4
2B64:  BRA    2B6E
....................          row=0; 
2B66:  MOVLB  9
2B68:  CLRF   xB0
....................        else if(input(ROW1)==0) 
2B6A:  BRA    2B9A
2B6C:  MOVLB  0
2B6E:  BSF    F93.5
2B70:  BTFSC  F81.5
2B72:  BRA    2B7E
....................          row=1; 
2B74:  MOVLW  01
2B76:  MOVLB  9
2B78:  MOVWF  xB0
....................        else if(input(ROW2)==0) 
2B7A:  BRA    2B9A
2B7C:  MOVLB  0
2B7E:  BSF    F93.6
2B80:  BTFSC  F81.6
2B82:  BRA    2B8E
....................          row=2; 
2B84:  MOVLW  02
2B86:  MOVLB  9
2B88:  MOVWF  xB0
....................        else if(input(ROW3)==0) 
2B8A:  BRA    2B9A
2B8C:  MOVLB  0
2B8E:  BSF    F93.7
2B90:  BTFSC  F81.7
2B92:  BRA    2B9C
....................          row=3;      
2B94:  MOVLW  03
2B96:  MOVLB  9
2B98:  MOVWF  xB0
2B9A:  MOVLB  0
....................        col=check_col(); 
2B9C:  BRA    251C
2B9E:  MOVFF  01,9AE
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
2BA2:  MOVLB  9
2BA4:  INCFSZ xAE,W
2BA6:  BRA    2BAA
2BA8:  BRA    2C5E
....................        { 
....................          kchar =KEYS[row][col]; 
2BAA:  MOVF   xB0,W
2BAC:  MULLW  05
2BAE:  MOVF   FF3,W
2BB0:  CLRF   xB2
2BB2:  MOVWF  xB1
2BB4:  CLRF   03
2BB6:  MOVF   xAE,W
2BB8:  ADDWF  xB1,W
2BBA:  MOVWF  01
2BBC:  MOVF   xB2,W
2BBE:  ADDWFC 03,F
2BC0:  MOVF   01,W
2BC2:  MOVLB  0
2BC4:  CALL   00E8
2BC8:  MOVFF  FE8,9AF
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
2BCC:  MOVLB  1
2BCE:  MOVF   x08,F
2BD0:  BNZ   2C52
....................             { 
....................               charac_timeout=0; 
2BD2:  MOVLB  0
2BD4:  CLRF   xFC
2BD6:  CLRF   xFB
....................                if(key_count_ms<20)key_data[key_count_ms++]=kchar; 
2BD8:  MOVLB  1
2BDA:  MOVF   x0B,W
2BDC:  SUBLW  13
2BDE:  BNC   2BF4
2BE0:  MOVF   x0B,W
2BE2:  INCF   x0B,F
2BE4:  CLRF   03
2BE6:  ADDLW  10
2BE8:  MOVWF  FE9
2BEA:  MOVLW  01
2BEC:  ADDWFC 03,W
2BEE:  MOVWF  FEA
2BF0:  MOVFF  9AF,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
2BF4:  MOVLW  2A
2BF6:  MOVWF  FF6
2BF8:  MOVLW  04
2BFA:  MOVWF  FF7
2BFC:  MOVLW  09
2BFE:  MOVLB  9
2C00:  MOVWF  xC7
2C02:  MOVLB  0
2C04:  CALL   15C6
2C08:  MOVFF  10B,9B1
2C0C:  MOVLW  18
2C0E:  MOVLB  9
2C10:  MOVWF  xB2
2C12:  MOVLB  0
2C14:  CALL   16DA
2C18:  MOVLW  5D
2C1A:  MOVLB  9
2C1C:  MOVWF  xD3
2C1E:  MOVLB  0
2C20:  CALL   0608
2C24:  MOVLW  20
2C26:  MOVLB  9
2C28:  MOVWF  xD3
2C2A:  MOVLB  0
2C2C:  CALL   0608
2C30:  MOVFF  9AF,9D3
2C34:  CALL   0608
2C38:  MOVLW  0D
2C3A:  MOVLB  9
2C3C:  MOVWF  xD3
2C3E:  MOVLB  0
2C40:  CALL   0608
2C44:  MOVLW  0A
2C46:  MOVLB  9
2C48:  MOVWF  xD3
2C4A:  MOVLB  0
2C4C:  CALL   0608
....................             } 
....................                else fputc(kchar,COM2); 
2C50:  BRA    2C5C
2C52:  MOVFF  9AF,9D3
2C56:  MOVLB  0
2C58:  CALL   0608
2C5C:  MOVLB  9
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
2C5E:  BSF    F93.4
2C60:  BTFSS  F81.4
2C62:  BRA    2C5E
2C64:  BSF    F93.5
2C66:  BTFSS  F81.5
2C68:  BRA    2C5E
2C6A:  BSF    F93.6
2C6C:  BTFSS  F81.6
2C6E:  BRA    2C5E
2C70:  BSF    F93.7
2C72:  BTFSS  F81.7
2C74:  BRA    2C5E
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
2C76:  BSF    F93.4
2C78:  BTFSS  F81.4
2C7A:  BRA    2C76
2C7C:  BSF    F93.5
2C7E:  BTFSS  F81.5
2C80:  BRA    2C76
2C82:  BSF    F93.6
2C84:  BTFSS  F81.6
2C86:  BRA    2C76
2C88:  BSF    F93.7
2C8A:  BTFSS  F81.7
2C8C:  BRA    2C76
2C8E:  MOVLB  0
....................     } 
....................   set_tris_a(0xff);     
2C90:  MOVLW  FF
2C92:  MOVWF  F92
....................   return(kchar); 
2C94:  MOVLB  9
2C96:  MOVFF  9AF,01
.................... }//*/ 
2C9A:  MOVLB  0
2C9C:  RETURN 0
.................... //============================================ 
....................  
.................... //=========================== 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
3982:  MOVF   27,F
3984:  BTFSS  FD8.2
3986:  BRA    3AC4
3988:  MOVF   26,F
398A:  BTFSS  FD8.2
398C:  BRA    3AC4
398E:  MOVF   25,W
3990:  SUBLW  FF
3992:  BTFSS  FD8.0
3994:  BRA    3AC4
3996:  BNZ   39A0
3998:  MOVF   24,W
399A:  SUBLW  FE
399C:  BTFSS  FD8.0
399E:  BRA    3AC4
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)) 
39A0:  MOVLB  1
39A2:  MOVF   x10,F
39A4:  BZ    3A72
....................       { 
....................          temp=get_countcard(); 
39A6:  MOVLB  0
39A8:  CALL   2EF0
39AC:  MOVFF  02,9B0
39B0:  MOVFF  01,9AF
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
39B4:  MOVFF  9B0,9B4
39B8:  MOVFF  9AF,9B3
39BC:  MOVLB  9
39BE:  CLRF   xB6
39C0:  MOVLW  32
39C2:  MOVWF  xB5
39C4:  MOVLB  0
39C6:  CALL   2F40
39CA:  MOVFF  02,9B2
39CE:  MOVFF  01,9B1
39D2:  MOVLW  46
39D4:  MOVLB  9
39D6:  ADDWF  xB1,F
39D8:  MOVLW  AA
39DA:  ADDWFC xB2,F
39DC:  MOVLW  01
39DE:  ADDWF  xB1,W
39E0:  MOVWF  01
39E2:  MOVLW  00
39E4:  ADDWFC xB2,W
39E6:  MOVFF  01,24
39EA:  MOVWF  25
39EC:  CLRF   26
39EE:  CLRF   27
....................          for(i=0;i<key_numbyte-5;i++) 
39F0:  CLRF   xAE
39F2:  MOVF   xAE,W
39F4:  SUBLW  2C
39F6:  BNC   3A48
....................          { 
....................             write_ext_eeprom((long int)ptr_card_key++,key_data[i]); 
39F8:  MOVFF  27,03
39FC:  MOVFF  26,02
3A00:  MOVFF  25,01
3A04:  MOVFF  24,00
3A08:  MOVLW  01
3A0A:  ADDWF  24,F
3A0C:  BTFSC  FD8.0
3A0E:  INCF   25,F
3A10:  BTFSC  FD8.2
3A12:  INCF   26,F
3A14:  BTFSC  FD8.2
3A16:  INCF   27,F
3A18:  MOVFF  01,9B2
3A1C:  MOVFF  00,9B1
3A20:  CLRF   03
3A22:  MOVF   xAE,W
3A24:  ADDLW  10
3A26:  MOVWF  FE9
3A28:  MOVLW  01
3A2A:  ADDWFC 03,W
3A2C:  MOVWF  FEA
3A2E:  MOVFF  FEF,9B3
3A32:  MOVFF  01,9C0
3A36:  MOVFF  00,9BF
3A3A:  MOVFF  9B3,9C1
3A3E:  MOVLB  0
3A40:  RCALL  336C
....................             //fputc(key_data[i],COM2); 
....................          } 
3A42:  MOVLB  9
3A44:  INCF   xAE,F
3A46:  BRA    39F2
....................          write_ext_eeprom((long int)ptr_card_key,0); 
3A48:  MOVFF  25,9C0
3A4C:  MOVFF  24,9BF
3A50:  CLRF   xC1
3A52:  MOVLB  0
3A54:  RCALL  336C
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
3A56:  MOVFF  27,9B4
3A5A:  MOVFF  26,9B3
3A5E:  MOVFF  25,9B2
3A62:  MOVFF  24,9B1
3A66:  MOVLW  1E
3A68:  MOVLB  9
3A6A:  MOVWF  xB5
3A6C:  MOVLB  0
3A6E:  RCALL  3472
3A70:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
3A72:  CLRF   x0B
....................       del_buf(key_numbyte,key_data); 
3A74:  MOVLW  32
3A76:  MOVLB  9
3A78:  MOVWF  xBD
3A7A:  MOVLW  01
3A7C:  MOVWF  xBF
3A7E:  MOVLW  10
3A80:  MOVWF  xBE
3A82:  MOVLB  0
3A84:  CALL   2F62
....................       fprintf(COM2,"\r\n"); 
3A88:  MOVLW  0D
3A8A:  MOVLB  9
3A8C:  MOVWF  xD3
3A8E:  MOVLB  0
3A90:  CALL   0608
3A94:  MOVLW  0A
3A96:  MOVLB  9
3A98:  MOVWF  xD3
3A9A:  MOVLB  0
3A9C:  CALL   0608
....................       fprintf(COM2,"Done PIN"); 
3AA0:  MOVLW  3C
3AA2:  MOVWF  FF6
3AA4:  MOVLW  04
3AA6:  MOVWF  FF7
3AA8:  CALL   064E
....................       fprintf(COM2,"\r\n"); 
3AAC:  MOVLW  0D
3AAE:  MOVLB  9
3AB0:  MOVWF  xD3
3AB2:  MOVLB  0
3AB4:  CALL   0608
3AB8:  MOVLW  0A
3ABA:  MOVLB  9
3ABC:  MOVWF  xD3
3ABE:  MOVLB  0
3AC0:  CALL   0608
....................    } 
.................... } 
3AC4:  GOTO   4976 (RETURN)
.................... //=========================================== 
.................... void key_press() 
.................... { 
....................    int8 col; 
....................    int32 KB_count_timeout=0; 
....................    fprintf(COM2,"\r\n"); 
....................    fprintf(COM2,"Key"); 
....................    //fprintf(COM2,"\r\n"); 
....................    KB_count_timeout=0; 
....................    while(1) 
....................    { 
....................       
....................       if(KB_count_timeout<150000)KB_count_timeout++; 
....................       if(KB_count_timeout==150000) 
....................       { 
....................          KB_count_timeout++; 
....................           
....................          break;             
....................       }   
....................    } 
.................... } 
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
5E04:  MOVLB  8
5E06:  CLRF   xD4
5E08:  CLRF   xD3
5E0A:  CLRF   xD5
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
5E0C:  MOVF   xD4,F
5E0E:  BTFSS  FD8.2
5E10:  BRA    5F34
5E12:  MOVF   xCE,W
5E14:  SUBWF  xD3,W
5E16:  BTFSC  FD8.0
5E18:  BRA    5F34
5E1A:  MOVF   xD5,F
5E1C:  BTFSS  FD8.2
5E1E:  BRA    5F34
....................       c = fgetc(COM2);//getc(); 
5E20:  MOVLB  0
5E22:  RCALL  5DB6
5E24:  MOVFF  01,8D1
....................       switch(c) 
....................       { 
5E28:  MOVLB  8
5E2A:  MOVF   xD1,W
5E2C:  XORLW  7F
5E2E:  MOVLB  0
5E30:  BZ    5E38
5E32:  XORLW  72
5E34:  BZ    5E86
5E36:  BRA    5EC4
....................          case 0x7f:    
....................             if(nbcar>0)   
5E38:  MOVLB  8
5E3A:  MOVF   xD3,F
5E3C:  BNZ   5E42
5E3E:  MOVF   xD4,F
5E40:  BZ    5E6C
5E42:  CLRF   19
5E44:  BTFSC  FF2.7
5E46:  BSF    19.7
5E48:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
5E4A:  MOVLW  7F
5E4C:  MOVLB  9
5E4E:  MOVWF  xD3
5E50:  MOVLB  0
5E52:  CALL   0608
5E56:  BTFSC  19.7
5E58:  BSF    FF2.7
....................                nbcar--; 
5E5A:  MOVLB  8
5E5C:  MOVF   xD3,W
5E5E:  BTFSC  FD8.2
5E60:  DECF   xD4,F
5E62:  DECF   xD3,F
....................                fgetc(COM2);//getc(); 
5E64:  MOVLB  0
5E66:  RCALL  5DB6
....................             } 
....................             else fputc(0x07,COM2);    
5E68:  BRA    5E84
5E6A:  MOVLB  8
5E6C:  CLRF   19
5E6E:  BTFSC  FF2.7
5E70:  BSF    19.7
5E72:  BCF    FF2.7
5E74:  MOVLW  07
5E76:  MOVLB  9
5E78:  MOVWF  xD3
5E7A:  MOVLB  0
5E7C:  CALL   0608
5E80:  BTFSC  19.7
5E82:  BSF    FF2.7
....................          break;  
5E84:  BRA    5F30
....................          case 0x0D:   
....................                keydebug_en=0; 
5E86:  MOVLB  1
5E88:  CLRF   x08
....................                set_tris_a(0xff); 
5E8A:  MOVLW  FF
5E8C:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
5E8E:  MOVFF  8D3,8D2
5E92:  MOVLB  8
5E94:  MOVF   xCE,W
5E96:  SUBWF  xD2,W
5E98:  BC    5EAE
....................                { 
....................                  chaine[i]=0; 
5E9A:  CLRF   03
5E9C:  MOVF   xD2,W
5E9E:  ADDWF  xCF,W
5EA0:  MOVWF  FE9
5EA2:  MOVF   xD0,W
5EA4:  ADDWFC 03,W
5EA6:  MOVWF  FEA
5EA8:  CLRF   FEF
....................                } 
5EAA:  INCF   xD2,F
5EAC:  BRA    5E94
....................                if(nbcar==0)return(FAUX); 
5EAE:  MOVF   xD3,F
5EB0:  BNZ   5EBC
5EB2:  MOVF   xD4,F
5EB4:  BNZ   5EBC
5EB6:  MOVLW  00
5EB8:  MOVWF  01
5EBA:  BRA    5F38
....................                fini=VRAI; 
5EBC:  MOVLW  01
5EBE:  MOVWF  xD5
....................          break; 
5EC0:  MOVLB  0
5EC2:  BRA    5F30
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
5EC4:  MOVLB  8
5EC6:  MOVF   xD1,W
5EC8:  SUBLW  1F
5ECA:  BC    5F32
5ECC:  MOVF   xD1,W
5ECE:  SUBLW  7E
5ED0:  BNC   5F32
5ED2:  MOVLW  01
5ED4:  SUBWF  xCE,W
5ED6:  MOVF   xD4,F
5ED8:  BNZ   5F32
5EDA:  SUBWF  xD3,W
5EDC:  BC    5F32
....................             { 
....................                chaine[nbcar]=c; 
5EDE:  MOVF   xCF,W
5EE0:  ADDWF  xD3,W
5EE2:  MOVWF  FE9
5EE4:  MOVF   xD0,W
5EE6:  ADDWFC xD4,W
5EE8:  MOVWF  FEA
5EEA:  MOVFF  8D1,FEF
....................                nbcar++; 
5EEE:  INCF   xD3,F
5EF0:  BTFSC  FD8.2
5EF2:  INCF   xD4,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
5EF4:  DECFSZ xCD,W
5EF6:  BRA    5F12
5EF8:  CLRF   19
5EFA:  BTFSC  FF2.7
5EFC:  BSF    19.7
5EFE:  BCF    FF2.7
5F00:  MOVFF  8D1,9D3
5F04:  MOVLB  0
5F06:  CALL   0608
5F0A:  BTFSC  19.7
5F0C:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
5F0E:  BRA    5F30
5F10:  MOVLB  8
5F12:  MOVF   xCD,W
5F14:  SUBLW  02
5F16:  BNZ   5F32
5F18:  CLRF   19
5F1A:  BTFSC  FF2.7
5F1C:  BSF    19.7
5F1E:  BCF    FF2.7
5F20:  MOVLW  2A
5F22:  MOVLB  9
5F24:  MOVWF  xD3
5F26:  MOVLB  0
5F28:  CALL   0608
5F2C:  BTFSC  19.7
5F2E:  BSF    FF2.7
5F30:  MOVLB  8
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
5F32:  BRA    5E0C
....................    return(nbcar); 
5F34:  MOVFF  8D3,01
.................... } 
5F38:  MOVLB  0
5F3A:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
*
3DC4:  MOVFF  9AF,9B3
3DC8:  MOVFF  9AE,9B2
3DCC:  MOVFF  9B1,9B5
3DD0:  MOVFF  9B0,9B4
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
3DD4:  MOVFF  9B3,03
3DD8:  MOVLB  9
3DDA:  MOVFF  9B2,FE9
3DDE:  MOVFF  9B3,FEA
3DE2:  MOVF   FEF,F
3DE4:  BZ    3E2C
3DE6:  MOVFF  9B5,03
3DEA:  MOVFF  9B4,FE9
3DEE:  MOVFF  9B5,FEA
3DF2:  MOVF   FEF,F
3DF4:  BZ    3E2C
....................       if(*aa!=*bb) 
3DF6:  MOVFF  9B2,FE9
3DFA:  MOVFF  9B3,FEA
3DFE:  MOVFF  FEF,9B6
3E02:  MOVFF  9B5,03
3E06:  MOVFF  9B4,FE9
3E0A:  MOVFF  9B5,FEA
3E0E:  MOVF   FEF,W
3E10:  SUBWF  xB6,W
3E12:  BZ    3E1A
....................          return(1); 
3E14:  MOVLW  01
3E16:  MOVWF  01
3E18:  BRA    3E58
....................       aa++; 
3E1A:  INCF   xB2,F
3E1C:  BTFSC  FD8.2
3E1E:  INCF   xB3,F
....................       bb++; 
3E20:  INCF   xB4,F
3E22:  BTFSC  FD8.2
3E24:  INCF   xB5,F
....................    } 
3E26:  MOVLB  0
3E28:  BRA    3DD4
3E2A:  MOVLB  9
....................    if(*aa!=*bb)return(1); 
3E2C:  MOVFF  9B3,03
3E30:  MOVFF  9B2,FE9
3E34:  MOVFF  9B3,FEA
3E38:  MOVFF  FEF,9B6
3E3C:  MOVFF  9B5,03
3E40:  MOVFF  9B4,FE9
3E44:  MOVFF  9B5,FEA
3E48:  MOVF   FEF,W
3E4A:  SUBWF  xB6,W
3E4C:  BZ    3E54
3E4E:  MOVLW  01
3E50:  MOVWF  01
3E52:  BRA    3E58
....................    return(0); 
3E54:  MOVLW  00
3E56:  MOVWF  01
.................... } 
3E58:  MOVLB  0
3E5A:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
635C:  MOVLB  8
635E:  CLRF   xCF
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
6360:  MOVFF  8CE,03
6364:  MOVF   xCD,W
6366:  INCF   xCD,F
6368:  BTFSC  FD8.2
636A:  INCF   xCE,F
636C:  MOVWF  FE9
636E:  MOVFF  03,FEA
6372:  MOVFF  FEF,8D1
6376:  MOVF   xD1,F
6378:  BZ    639C
....................         if (c >= '0' && c <= '9') 
637A:  MOVF   xD1,W
637C:  SUBLW  2F
637E:  BC    638E
6380:  MOVF   xD1,W
6382:  SUBLW  39
6384:  BNC   638E
....................             digit = (unsigned int) (c - '0'); 
6386:  MOVLW  30
6388:  SUBWF  xD1,W
638A:  MOVWF  xD0
....................         else 
638C:  BRA    6390
....................             break; 
638E:  BRA    639C
....................  
....................         val = (val * 10) + digit; 
6390:  MOVF   xCF,W
6392:  MULLW  0A
6394:  MOVF   FF3,W
6396:  ADDWF  xD0,W
6398:  MOVWF  xCF
....................     } 
639A:  BRA    6360
....................  
....................     return val; 
639C:  CLRF   03
639E:  MOVFF  8CF,01
63A2:  MOVFF  03,02
.................... } 
63A6:  MOVLB  0
63A8:  RETURN 0
....................  
.................... #include <GSM.c>  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#include "myRS485.C" 
....................  
.................... #define        EMERGOFF       PIN_A7 
.................... #define        reading_sms_cmd      1 
.................... #define        MSG_avai             2 
.................... #define        analyze_sms          3 
.................... #define        checking_MN          4 
.................... #define        doing_sms            5 
.................... #define        delete_MSG           6 
.................... #define        pre_cmd              7 
.................... #define        MSG_sending          8 
.................... #define        check_st             9 
.................... #define        config               10 
.................... #define        autosending          11 
.................... #define        idle                 12 
.................... #define        data_analyze         13 
.................... //#define     IGT            PIN_A6 
....................  
.................... //#define     batmb    sendto485(0,0x11,1) 
.................... //#define     tatmb    sendto485(0,0x11,0) 
....................  
....................  
.................... unsigned int8 msg_data_sending[280]; 
.................... int8 sim_bug[50]; 
.................... unsigned int8 msg_buffer1[20]; 
.................... unsigned int8 msg_buffer2[50]; 
.................... unsigned int8 mobilenumb[26]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... //unsigned int8 buf_checkMBN[16]; 
.................... int16 count_polling=0; 
.................... int8 SIM_state=0,MSG_sending_st=0; 
.................... int16 timing_wait=300; 
.................... int8 auto_sending=0; 
.................... int8 send_oneMSG=0; 
.................... //unsigned int8 com_buffer1[20]="it is OK"; 
.................... //============================================== 
.................... void earse_buffer_uart(unsigned int8 numbuf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<numbuf;i++) 
....................    { 
....................        buffer_uart[i]=0; 
....................    } 
.................... } 
.................... //============================================== 
.................... void sim900_init() 
.................... { 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(500); 
....................    fprintf(COM1,"AT+CMGF=1\r\n"); 
....................    delay_ms(500); 
....................    //del_buf(26,mobilenumb); 
....................    //strcpy(mobilenumb,"+84903219082"); 
.................... } 
.................... //============================================== 
.................... int8 get_datasim900(int8 *datin) 
.................... { 
....................    int8 c,i,index=0; 
....................    int8 testtemp[20]; 
....................    while(index<5) 
....................    { 
....................       c = getc(); 
....................       index++; 
....................       fprintf(COM2,"%c", c);  
....................    } 
....................    for(i=0;i<15;i++) 
....................    { 
....................       fprintf(COM2,"%c", testtemp[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", index);//*/ 
....................    return 0; 
.................... } 
.................... //============================================== 
.................... int8 check_module() 
.................... { 
....................    int8 temp=0,i; 
....................    earse_buffer_uart(10); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    UART_index=0; 
....................    delay_ms(200); 
....................    //fputc('c',COM2); 
....................    //fprintf("MSG is OK\r\n"); 
....................    for(i=0;i<10;i++) 
....................    { 
....................       //fputc(buffer_uart[i],COM2); 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) 
....................       { 
....................          i=10; 
....................          temp=1; 
....................          return(temp); 
....................       } 
....................          else temp=0; 
....................    } 
....................    UART_index=0; 
....................    return(temp); 
.................... } 
.................... //============================================== 
.................... void power_on() 
.................... { 
....................    /*while(temp==0) 
....................    { 
....................       temp = check_module(); 
....................       if(temp==0) 
....................       { 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
....................       } 
....................          else break; 
....................    }*/ 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
.................... } 
.................... //============================================== 
.................... void power_off() 
.................... { 
....................    fprintf(COM1,"AT+CPOWD\r\n"); 
.................... } 
.................... //============================================== 
.................... unsigned int8 mymemcmp(void * s1,char *s2,size_t n) 
.................... { 
....................    char *su1, *su2; 
....................    unsigned int8 temp=0,i=0; 
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................       { 
....................          temp=1; 
....................          if(*su1>*su2) 
....................          { 
....................             if((i==0)&&(*su1==(*su2)+32)) temp = 0; 
....................                //else temp = 0; 
....................          } 
....................             else  
....................                { 
....................                   if((i==0)&&(*su2==(*su1)+32)) temp = 0; 
....................                     // else temp = 0; 
....................                } 
....................       } 
....................       i++; 
....................    } 
....................    return (temp); 
.................... } 
.................... //============================================== 
.................... int8 pre_msg(int8 *datin,int8 *datout,int16 index) 
.................... { 
*
4084:  MOVLB  9
4086:  CLRF   xB5
....................    int8 i,len=0; 
....................    len = strlen(datin); 
4088:  MOVFF  9AF,9B7
408C:  MOVFF  9AE,9B6
4090:  MOVLB  0
4092:  RCALL  404A
4094:  MOVFF  01,9B5
....................    for(i=0;i<len;i++)datout[index++]=datin[i]; 
4098:  MOVLB  9
409A:  CLRF   xB4
409C:  MOVF   xB5,W
409E:  SUBWF  xB4,W
40A0:  BC    40E4
40A2:  MOVFF  9B3,03
40A6:  MOVF   xB2,W
40A8:  INCF   xB2,F
40AA:  BTFSC  FD8.2
40AC:  INCF   xB3,F
40AE:  MOVWF  xB6
40B0:  MOVFF  03,9B7
40B4:  MOVF   xB0,W
40B6:  ADDWF  xB6,W
40B8:  MOVWF  01
40BA:  MOVF   xB1,W
40BC:  ADDWFC 03,W
40BE:  MOVWF  03
40C0:  MOVWF  xB9
40C2:  CLRF   03
40C4:  MOVF   xB4,W
40C6:  ADDWF  xAE,W
40C8:  MOVWF  FE9
40CA:  MOVF   xAF,W
40CC:  ADDWFC 03,W
40CE:  MOVWF  FEA
40D0:  MOVFF  FEF,9BA
40D4:  MOVFF  9B9,FEA
40D8:  MOVFF  01,FE9
40DC:  MOVFF  9BA,FEF
40E0:  INCF   xB4,F
40E2:  BRA    409C
....................    return index; 
40E4:  MOVFF  9B2,01
.................... } 
40E8:  MOVLB  0
40EA:  RETURN 0
.................... //============================================== 
.................... void delete_sms(char number_sms) 
.................... { 
....................    switch(number_sms) 
....................    { 
....................        case  1: 
....................             fprintf(COM1,"AT+CMGD=1\r\n");  
....................        break; 
....................        case  2: 
....................             fprintf(COM1,"AT+CMGD=2\r\n"); 
....................        break; 
....................        case  3: 
....................             fprintf(COM1,"AT+CMGD=3\r\n"); 
....................        break; 
....................        case  4: 
....................             fprintf(COM1,"AT+CMGD=4\r\n");        
....................        break; 
....................        case  5: 
....................             fprintf(COM1,"AT+CMGD=5\r\n"); 
....................        break; 
....................        case  6: 
....................             fprintf(COM1,"AT+CMGD=6\r\n"); 
....................        break; 
....................        case  7: 
....................              fprintf(COM1,"AT+CMGD=7\r\n"); 
....................        break;        
....................        case  8: 
....................             fprintf(COM1,"AT+CMGD=8\r\n"); 
....................        break;        
....................    } 
....................    delay_ms(500); 
.................... } 
.................... //============================================== 
.................... void del_multi_sms(int8 num_sms) 
.................... { 
....................    int8 i; 
....................    for(i=1;i<=num_sms;i++) 
....................    { 
....................      delete_sms(i);  
....................      delay_ms(100); 
....................    } 
.................... } 
.................... //============================================== 
.................... //============================================== 
.................... void send_sms(unsigned int8* mobile_num,unsigned int8* MSG) 
.................... { 
....................       unsigned int8 i=0,strl=0; 
....................       strl= strlen(MSG);   
....................       //fprintf(COM1,"AT+CMGF=1\r\n"); // text mode 
....................       //delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGS="); 
....................       //putc('"'); 
....................       fputc('"',COM1); 
....................       while((mobile_num[i]!=0)&&(i<20)) 
....................       { 
....................          //fputc(mobile_num[i],COM2); 
....................          //putc(mobile_num[i]); 
....................          fputc(mobile_num[i],COM1); 
....................          i++; 
....................       } 
....................       fputc('"',COM1); 
....................       //fputc(0x0d,COM1); 
....................       //putc('"'); 
....................       fprintf(COM1,"\r\n"); 
....................       delay_ms(500);         
....................       for(i=0;i<strl;i++) 
....................       { 
....................          fputc(MSG[i],COM1); 
....................          //putc(MSG[i]); 
....................       } 
....................       //delay_ms(100); 
....................       //putc(26); 
....................       fputc(26,COM1); 
....................       //printf("\r\n"); 
....................      // delay_ms(500);   
.................... } 
.................... //============================================= 
.................... //============================================== 
.................... void reading_sms() 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<16;i++) mobilenumb[i]=0; 
....................    earse_buffer_uart(200); 
....................    printf("AT+CMGF=1\r\n"); 
....................    printf("AT+CMGR=1\r\n");  
....................    UART_index=0;  
....................    delay_ms(1000); 
....................    for(i=0;i<200;i++) 
....................    { 
....................       if((buffer_uart[i]=='a')&&(buffer_uart[i+1]=='d')&&(buffer_uart[i+2]=='m')&&(buffer_uart[i+3]=='i')&&(buffer_uart[i+4]=='n')&&(buffer_uart[i+5]==' ')) 
....................       { 
....................          write_ext_eeprom(strobe_mobile_num1,buffer_uart[i+6]); 
....................          fputc(buffer_uart[i+6],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+1,buffer_uart[i+7]); 
....................          fputc(buffer_uart[i+7],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+2,buffer_uart[i+8]); 
....................          fputc(buffer_uart[i+8],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+3,buffer_uart[i+9]); 
....................          fputc(buffer_uart[i+9],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+4,buffer_uart[i+10]); 
....................          fputc(buffer_uart[i+10],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+5,buffer_uart[i+11]); 
....................          fputc(buffer_uart[i+11],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+6,buffer_uart[i+12]); 
....................          fputc(buffer_uart[i+12],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+7,buffer_uart[i+13]); 
....................          fputc(buffer_uart[i+13],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+8,buffer_uart[i+14]); 
....................          fputc(buffer_uart[i+14],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+9,buffer_uart[i+15]); 
....................          fputc(buffer_uart[i+15],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+10,buffer_uart[i+16]); 
....................          fputc(buffer_uart[i+16],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+11,buffer_uart[i+17]); 
....................          fputc(buffer_uart[i+17],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+12,buffer_uart[i+18]); 
....................          fputc(buffer_uart[i+18],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+13,buffer_uart[i+19]); 
....................          fputc(buffer_uart[i+19],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+14,buffer_uart[i+20]); 
....................          fputc(buffer_uart[i+20],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+15,buffer_uart[i+21]); 
....................          fputc(buffer_uart[i+21],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+16,buffer_uart[i+22]); 
....................          fputc(buffer_uart[i+22],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+17,buffer_uart[i+23]); 
....................          fputc(buffer_uart[i+23],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+18,buffer_uart[i+24]); 
....................          fputc(buffer_uart[i+24],COM2);          
....................          write_ext_eeprom(strobe_mobile_num1+19,buffer_uart[i+25]); 
....................          fputc(buffer_uart[i+25],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+20,buffer_uart[i+26]); 
....................          fputc(buffer_uart[i+26],COM2);          
....................          fprintf(COM2,"\r\n"); 
....................          EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................          i=250; 
....................          sms_unread_flag=0; 
....................          strcpy (msg_data_sending, "done"); 
....................          send_sms(mobilenumb,msg_data_sending); 
....................          delay_ms(5000); 
....................          delete_sms(1); 
....................          delay_ms(5000); 
....................          UART_index=0; 
....................       } 
....................         else  
....................          { 
....................             if(i>198)  
....................             { 
....................                delay_ms(5000); 
....................                delete_sms(1); 
....................                delay_ms(5000); 
....................                UART_index=0; 
....................                sms_unread_flag=0; 
....................                EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................             } 
....................          } 
....................    } 
.................... } 
.................... //============================================== 
.................... /*void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... }*/ 
.................... //============================================================ 
.................... int8 checking_msg_avai() 
.................... { 
....................    int8 i; 
....................    /*for(i=0;i<100;i++) 
....................    { 
....................       fprintf(COM2,"%c", buffer_uart[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", UART_index);//*/ 
....................    for(i=0;i<20;i++) 
*
3B24:  MOVLB  9
3B26:  CLRF   xAE
3B28:  MOVF   xAE,W
3B2A:  SUBLW  13
3B2C:  BNC   3B62
....................    { 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) return 1; 
3B2E:  CLRF   03
3B30:  MOVF   xAE,W
3B32:  ADDLW  4A
3B34:  MOVWF  FE9
3B36:  MOVLW  01
3B38:  ADDWFC 03,W
3B3A:  MOVWF  FEA
3B3C:  MOVF   FEF,W
3B3E:  SUBLW  4F
3B40:  BNZ   3B5E
3B42:  MOVLW  01
3B44:  ADDWF  xAE,W
3B46:  CLRF   03
3B48:  ADDLW  4A
3B4A:  MOVWF  FE9
3B4C:  MOVLW  01
3B4E:  ADDWFC 03,W
3B50:  MOVWF  FEA
3B52:  MOVF   FEF,W
3B54:  SUBLW  4B
3B56:  BNZ   3B5E
3B58:  MOVLW  01
3B5A:  MOVWF  01
3B5C:  BRA    3B66
....................    } 
3B5E:  INCF   xAE,F
3B60:  BRA    3B28
....................    return 0; 
3B62:  MOVLW  00
3B64:  MOVWF  01
.................... } 
3B66:  MOVLB  0
3B68:  GOTO   4A80 (RETURN)
.................... //============================================================ 
.................... int8 SMS_coming() 
.................... { 
*
4674:  MOVLB  9
4676:  CLRF   xAF
.................... //+CMTI: "SM",25 
....................    int8 i,st=0; 
....................    //int8 msg_temp[20],msg_temp1[20]; 
....................    //strncpy(msg_temp1,buffer_uart,20); 
....................    //strcpy(msg_temp,"+CMTI:"); 
....................    for(i=0;i<20;i++) 
4678:  CLRF   xAE
467A:  MOVF   xAE,W
467C:  SUBLW  13
467E:  BNC   4728
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='T')&&(buffer_uart[4+i]=='I')&&(buffer_uart[5+i]==':'))  
4680:  CLRF   03
4682:  MOVF   xAE,W
4684:  ADDLW  4A
4686:  MOVWF  FE9
4688:  MOVLW  01
468A:  ADDWFC 03,W
468C:  MOVWF  FEA
468E:  MOVF   FEF,W
4690:  SUBLW  2B
4692:  BNZ   4722
4694:  MOVLW  01
4696:  ADDWF  xAE,W
4698:  CLRF   03
469A:  ADDLW  4A
469C:  MOVWF  FE9
469E:  MOVLW  01
46A0:  ADDWFC 03,W
46A2:  MOVWF  FEA
46A4:  MOVF   FEF,W
46A6:  SUBLW  43
46A8:  BNZ   4722
46AA:  MOVLW  02
46AC:  ADDWF  xAE,W
46AE:  CLRF   03
46B0:  ADDLW  4A
46B2:  MOVWF  FE9
46B4:  MOVLW  01
46B6:  ADDWFC 03,W
46B8:  MOVWF  FEA
46BA:  MOVF   FEF,W
46BC:  SUBLW  4D
46BE:  BNZ   4722
46C0:  MOVLW  03
46C2:  ADDWF  xAE,W
46C4:  CLRF   03
46C6:  ADDLW  4A
46C8:  MOVWF  FE9
46CA:  MOVLW  01
46CC:  ADDWFC 03,W
46CE:  MOVWF  FEA
46D0:  MOVF   FEF,W
46D2:  SUBLW  54
46D4:  BNZ   4722
46D6:  MOVLW  04
46D8:  ADDWF  xAE,W
46DA:  CLRF   03
46DC:  ADDLW  4A
46DE:  MOVWF  FE9
46E0:  MOVLW  01
46E2:  ADDWFC 03,W
46E4:  MOVWF  FEA
46E6:  MOVF   FEF,W
46E8:  SUBLW  49
46EA:  BNZ   4722
46EC:  MOVLW  05
46EE:  ADDWF  xAE,W
46F0:  CLRF   03
46F2:  ADDLW  4A
46F4:  MOVWF  FE9
46F6:  MOVLW  01
46F8:  ADDWFC 03,W
46FA:  MOVWF  FEA
46FC:  MOVF   FEF,W
46FE:  SUBLW  3A
4700:  BNZ   4722
....................       {  
....................          fprintf(COM2,"\n\rNew SMS\n\r"); 
4702:  MOVLW  08
4704:  MOVWF  FF6
4706:  MOVLW  05
4708:  MOVWF  FF7
470A:  MOVLB  0
470C:  CALL   064E
....................          SIM_state=reading_sms_cmd; 
4710:  MOVLW  01
4712:  MOVLB  3
4714:  MOVWF  x5C
....................          st = 2; 
4716:  MOVLW  02
4718:  MOVLB  9
471A:  MOVWF  xAF
....................          i=23; 
471C:  MOVLW  17
471E:  MOVWF  xAE
....................       } 
....................          else st=0; 
4720:  BRA    4724
4722:  CLRF   xAF
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
4724:  INCF   xAE,F
4726:  BRA    467A
....................    for(i=0;i<20;i++) 
4728:  CLRF   xAE
472A:  MOVF   xAE,W
472C:  SUBLW  13
472E:  BNC   47A6
....................    { 
....................       if((buffer_uart[0+i]=='R')&&(buffer_uart[1+i]=='I')&&(buffer_uart[2+i]=='N')&&(buffer_uart[3+i]=='G'))  
4730:  CLRF   03
4732:  MOVF   xAE,W
4734:  ADDLW  4A
4736:  MOVWF  FE9
4738:  MOVLW  01
473A:  ADDWFC 03,W
473C:  MOVWF  FEA
473E:  MOVF   FEF,W
4740:  SUBLW  52
4742:  BNZ   47A0
4744:  MOVLW  01
4746:  ADDWF  xAE,W
4748:  CLRF   03
474A:  ADDLW  4A
474C:  MOVWF  FE9
474E:  MOVLW  01
4750:  ADDWFC 03,W
4752:  MOVWF  FEA
4754:  MOVF   FEF,W
4756:  SUBLW  49
4758:  BNZ   47A0
475A:  MOVLW  02
475C:  ADDWF  xAE,W
475E:  CLRF   03
4760:  ADDLW  4A
4762:  MOVWF  FE9
4764:  MOVLW  01
4766:  ADDWFC 03,W
4768:  MOVWF  FEA
476A:  MOVF   FEF,W
476C:  SUBLW  4E
476E:  BNZ   47A0
4770:  MOVLW  03
4772:  ADDWF  xAE,W
4774:  CLRF   03
4776:  ADDLW  4A
4778:  MOVWF  FE9
477A:  MOVLW  01
477C:  ADDWFC 03,W
477E:  MOVWF  FEA
4780:  MOVF   FEF,W
4782:  SUBLW  47
4784:  BNZ   47A0
....................       {  
....................          fprintf(COM2,"\n\rRING\n\r"); 
4786:  MOVLW  14
4788:  MOVWF  FF6
478A:  MOVLW  05
478C:  MOVWF  FF7
478E:  MOVLB  0
4790:  CALL   064E
....................          st = 1; 
4794:  MOVLW  01
4796:  MOVLB  9
4798:  MOVWF  xAF
....................          i=23; 
479A:  MOVLW  17
479C:  MOVWF  xAE
....................       } 
....................          else st=0; 
479E:  BRA    47A2
47A0:  CLRF   xAF
....................    } 
47A2:  INCF   xAE,F
47A4:  BRA    472A
....................    UART_index=0; 
47A6:  MOVLB  1
47A8:  CLRF   xAE
....................    memset(buffer_uart,0,sizeof(buffer_uart));  
47AA:  MOVLW  01
47AC:  MOVWF  FEA
47AE:  MOVLW  4A
47B0:  MOVWF  FE9
47B2:  CLRF   00
47B4:  CLRF   02
47B6:  MOVLW  64
47B8:  MOVWF  01
47BA:  MOVLB  0
47BC:  CALL   3968
....................    return st; 
47C0:  MOVLB  9
47C2:  MOVFF  9AF,01
.................... } 
47C6:  MOVLB  0
47C8:  GOTO   581E (RETURN)
.................... //============================================================ 
.................... unsigned int8 analyzing_msg(char* MSG,char* mobile_number) 
.................... { 
*
3B6C:  MOVLB  9
3B6E:  CLRF   xB2
3B70:  CLRF   xB3
3B72:  CLRF   xB4
3B74:  CLRF   xB5
3B76:  CLRF   xB6
....................    unsigned int8 i=0,a=0,b=0,d=0; 
....................    unsigned int8 st=0,temp; 
....................    del_buf(50,MSG); 
3B78:  MOVLW  32
3B7A:  MOVWF  xBD
3B7C:  MOVFF  9AF,9BF
3B80:  MOVFF  9AE,9BE
3B84:  MOVLB  0
3B86:  CALL   2F62
....................    del_buf(20,mobile_number); 
3B8A:  MOVLW  14
3B8C:  MOVLB  9
3B8E:  MOVWF  xBD
3B90:  MOVFF  9B1,9BF
3B94:  MOVFF  9B0,9BE
3B98:  MOVLB  0
3B9A:  CALL   2F62
....................    for(i=0;i<200;i++) 
3B9E:  MOVLB  9
3BA0:  CLRF   xB2
3BA2:  MOVF   xB2,W
3BA4:  SUBLW  C7
3BA6:  BTFSS  FD8.0
3BA8:  BRA    3D6C
....................    { 
....................       if((buffer_uart[i]=='+')&&(buffer_uart[i+1]=='C')&&(buffer_uart[i+2]=='M')&&(buffer_uart[i+3]=='G')&&(buffer_uart[i+4]=='R')&&(buffer_uart[i+5]==':')&&(buffer_uart[i+6]==' ')&&(buffer_uart[i+7]=='0')&&(buffer_uart[i+8]==',')&&(buffer_uart[i+9]==',')&&(buffer_uart[i+10]=='0'))  
3BAA:  CLRF   03
3BAC:  MOVF   xB2,W
3BAE:  ADDLW  4A
3BB0:  MOVWF  FE9
3BB2:  MOVLW  01
3BB4:  ADDWFC 03,W
3BB6:  MOVWF  FEA
3BB8:  MOVF   FEF,W
3BBA:  SUBLW  2B
3BBC:  BTFSS  FD8.2
3BBE:  BRA    3CD2
3BC0:  MOVLW  01
3BC2:  ADDWF  xB2,W
3BC4:  CLRF   03
3BC6:  ADDLW  4A
3BC8:  MOVWF  FE9
3BCA:  MOVLW  01
3BCC:  ADDWFC 03,W
3BCE:  MOVWF  FEA
3BD0:  MOVF   FEF,W
3BD2:  SUBLW  43
3BD4:  BTFSS  FD8.2
3BD6:  BRA    3CD2
3BD8:  MOVLW  02
3BDA:  ADDWF  xB2,W
3BDC:  CLRF   03
3BDE:  ADDLW  4A
3BE0:  MOVWF  FE9
3BE2:  MOVLW  01
3BE4:  ADDWFC 03,W
3BE6:  MOVWF  FEA
3BE8:  MOVF   FEF,W
3BEA:  SUBLW  4D
3BEC:  BTFSS  FD8.2
3BEE:  BRA    3CD2
3BF0:  MOVLW  03
3BF2:  ADDWF  xB2,W
3BF4:  CLRF   03
3BF6:  ADDLW  4A
3BF8:  MOVWF  FE9
3BFA:  MOVLW  01
3BFC:  ADDWFC 03,W
3BFE:  MOVWF  FEA
3C00:  MOVF   FEF,W
3C02:  SUBLW  47
3C04:  BNZ   3CD2
3C06:  MOVLW  04
3C08:  ADDWF  xB2,W
3C0A:  CLRF   03
3C0C:  ADDLW  4A
3C0E:  MOVWF  FE9
3C10:  MOVLW  01
3C12:  ADDWFC 03,W
3C14:  MOVWF  FEA
3C16:  MOVF   FEF,W
3C18:  SUBLW  52
3C1A:  BNZ   3CD2
3C1C:  MOVLW  05
3C1E:  ADDWF  xB2,W
3C20:  CLRF   03
3C22:  ADDLW  4A
3C24:  MOVWF  FE9
3C26:  MOVLW  01
3C28:  ADDWFC 03,W
3C2A:  MOVWF  FEA
3C2C:  MOVF   FEF,W
3C2E:  SUBLW  3A
3C30:  BNZ   3CD2
3C32:  MOVLW  06
3C34:  ADDWF  xB2,W
3C36:  CLRF   03
3C38:  ADDLW  4A
3C3A:  MOVWF  FE9
3C3C:  MOVLW  01
3C3E:  ADDWFC 03,W
3C40:  MOVWF  FEA
3C42:  MOVF   FEF,W
3C44:  SUBLW  20
3C46:  BNZ   3CD2
3C48:  MOVLW  07
3C4A:  ADDWF  xB2,W
3C4C:  CLRF   03
3C4E:  ADDLW  4A
3C50:  MOVWF  FE9
3C52:  MOVLW  01
3C54:  ADDWFC 03,W
3C56:  MOVWF  FEA
3C58:  MOVF   FEF,W
3C5A:  SUBLW  30
3C5C:  BNZ   3CD2
3C5E:  MOVLW  08
3C60:  ADDWF  xB2,W
3C62:  CLRF   03
3C64:  ADDLW  4A
3C66:  MOVWF  FE9
3C68:  MOVLW  01
3C6A:  ADDWFC 03,W
3C6C:  MOVWF  FEA
3C6E:  MOVF   FEF,W
3C70:  SUBLW  2C
3C72:  BNZ   3CD2
3C74:  MOVLW  09
3C76:  ADDWF  xB2,W
3C78:  CLRF   03
3C7A:  ADDLW  4A
3C7C:  MOVWF  FE9
3C7E:  MOVLW  01
3C80:  ADDWFC 03,W
3C82:  MOVWF  FEA
3C84:  MOVF   FEF,W
3C86:  SUBLW  2C
3C88:  BNZ   3CD2
3C8A:  MOVLW  0A
3C8C:  ADDWF  xB2,W
3C8E:  CLRF   03
3C90:  ADDLW  4A
3C92:  MOVWF  FE9
3C94:  MOVLW  01
3C96:  ADDWFC 03,W
3C98:  MOVWF  FEA
3C9A:  MOVF   FEF,W
3C9C:  SUBLW  30
3C9E:  BNZ   3CD2
....................       { 
....................          st=0; 
3CA0:  CLRF   xB6
....................          i=200; 
3CA2:  MOVLW  C8
3CA4:  MOVWF  xB2
....................          del_buf(100,MSG); 
3CA6:  MOVLW  64
3CA8:  MOVWF  xBD
3CAA:  MOVFF  9AF,9BF
3CAE:  MOVFF  9AE,9BE
3CB2:  MOVLB  0
3CB4:  CALL   2F62
....................          del_buf(16,mobile_number); 
3CB8:  MOVLW  10
3CBA:  MOVLB  9
3CBC:  MOVWF  xBD
3CBE:  MOVFF  9B1,9BF
3CC2:  MOVFF  9B0,9BE
3CC6:  MOVLB  0
3CC8:  CALL   2F62
....................          count_spam=0; 
3CCC:  MOVLB  1
3CCE:  CLRF   x04
3CD0:  MOVLB  9
....................          //output_toggle(pin_a5); 
....................       } 
....................          //else st=2; 
....................      temp = buffer_uart[i]; 
3CD2:  CLRF   03
3CD4:  MOVF   xB2,W
3CD6:  ADDLW  4A
3CD8:  MOVWF  FE9
3CDA:  MOVLW  01
3CDC:  ADDWFC 03,W
3CDE:  MOVWF  FEA
3CE0:  MOVFF  FEF,9B7
....................      if((a==3))  
3CE4:  MOVF   xB3,W
3CE6:  SUBLW  03
3CE8:  BNZ   3D10
....................      { 
....................        if((temp>47)&&(temp<58)||temp=='+') mobile_number[i-b] = temp; 
3CEA:  MOVF   xB7,W
3CEC:  SUBLW  2F
3CEE:  BC    3CF6
3CF0:  MOVF   xB7,W
3CF2:  SUBLW  39
3CF4:  BC    3CFC
3CF6:  MOVF   xB7,W
3CF8:  SUBLW  2B
3CFA:  BNZ   3D10
3CFC:  MOVF   xB4,W
3CFE:  SUBWF  xB2,W
3D00:  CLRF   03
3D02:  ADDWF  xB0,W
3D04:  MOVWF  FE9
3D06:  MOVF   xB1,W
3D08:  ADDWFC 03,W
3D0A:  MOVWF  FEA
3D0C:  MOVFF  9B7,FEF
....................      } 
....................      if(d==2) 
3D10:  MOVF   xB5,W
3D12:  SUBLW  02
3D14:  BNZ   3D2E
....................      { 
....................          MSG[i-b] = temp; 
3D16:  MOVF   xB4,W
3D18:  SUBWF  xB2,W
3D1A:  CLRF   03
3D1C:  ADDWF  xAE,W
3D1E:  MOVWF  FE9
3D20:  MOVF   xAF,W
3D22:  ADDWFC 03,W
3D24:  MOVWF  FEA
3D26:  MOVFF  9B7,FEF
....................          st=1; 
3D2A:  MOVLW  01
3D2C:  MOVWF  xB6
....................      } 
....................       //else st=2; 
....................      if(temp==34)  
3D2E:  MOVF   xB7,W
3D30:  SUBLW  22
3D32:  BNZ   3D48
....................      { 
....................          if(a<6)a++; 
3D34:  MOVF   xB3,W
3D36:  SUBLW  05
3D38:  BTFSC  FD8.0
3D3A:  INCF   xB3,F
....................          if(a==3) b = i+1; 
3D3C:  MOVF   xB3,W
3D3E:  SUBLW  03
3D40:  BNZ   3D48
3D42:  MOVLW  01
3D44:  ADDWF  xB2,W
3D46:  MOVWF  xB4
....................      } 
....................      if(a==6) 
3D48:  MOVF   xB3,W
3D4A:  SUBLW  06
3D4C:  BNZ   3D68
....................      { 
....................          if((temp==13)||(temp==10))  
3D4E:  MOVF   xB7,W
3D50:  SUBLW  0D
3D52:  BZ    3D5A
3D54:  MOVF   xB7,W
3D56:  SUBLW  0A
3D58:  BNZ   3D68
....................          { 
....................             d++; 
3D5A:  INCF   xB5,F
....................             if(d==2) b = i+1; 
3D5C:  MOVF   xB5,W
3D5E:  SUBLW  02
3D60:  BNZ   3D68
3D62:  MOVLW  01
3D64:  ADDWF  xB2,W
3D66:  MOVWF  xB4
....................          } 
....................      } 
....................      //if((temp==',')&&(a==6)) 
....................     // { 
....................          //if(c<2)c++; 
....................      //} 
....................    } 
3D68:  INCF   xB2,F
3D6A:  BRA    3BA2
....................    return(st); 
3D6C:  MOVFF  9B6,01
.................... } 
3D70:  MOVLB  0
3D72:  GOTO   4AF6 (RETURN)
....................  
....................  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
066E:  MOVLB  9
0670:  CLRF   xE7
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
0672:  CLRF   xE8
0674:  BTFSC  xDF.0
0676:  BSF    xE8.7
0678:  SWAPF  xE0,W
067A:  MOVWF  00
067C:  RLCF   00,F
067E:  RLCF   00,F
0680:  MOVLW  C0
0682:  ANDWF  00,F
0684:  MOVF   00,W
0686:  IORWF  xE8,F
0688:  SWAPF  xE1,W
068A:  MOVWF  00
068C:  RLCF   00,F
068E:  MOVLW  E0
0690:  ANDWF  00,F
0692:  MOVF   00,W
0694:  IORWF  xE8,F
0696:  SWAPF  xE2,W
0698:  MOVWF  00
069A:  MOVLW  F0
069C:  ANDWF  00,F
069E:  MOVF   00,W
06A0:  IORWF  xE8,F
06A2:  RLCF   xE3,W
06A4:  MOVWF  00
06A6:  RLCF   00,F
06A8:  RLCF   00,F
06AA:  MOVLW  F8
06AC:  ANDWF  00,F
06AE:  MOVF   00,W
06B0:  IORWF  xE8,F
06B2:  RLCF   xE4,W
06B4:  MOVWF  00
06B6:  RLCF   00,F
06B8:  MOVLW  FC
06BA:  ANDWF  00,F
06BC:  MOVF   00,W
06BE:  IORWF  xE8,F
06C0:  BCF    FD8.0
06C2:  RLCF   xE5,W
06C4:  IORWF  xE8,F
06C6:  MOVF   xE6,W
06C8:  IORWF  xE8,W
06CA:  MOVWF  xE7
....................    return temp; 
06CC:  MOVFF  9E7,01
.................... } 
06D0:  MOVLB  0
06D2:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
06D4:  MOVLB  9
06D6:  CLRF   xCF
....................    int8 temp=0; 
....................    if(direct==0) 
06D8:  MOVF   xCA,F
06DA:  BNZ   07B0
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
06DC:  MOVF   xCD,W
06DE:  ADDWF  xCB,W
06E0:  MOVWF  FE9
06E2:  MOVF   xCE,W
06E4:  ADDWFC xCC,W
06E6:  MOVWF  FEA
06E8:  MOVFF  FEF,9D0
06EC:  MOVLW  01
06EE:  ADDWF  xCB,W
06F0:  MOVWF  xD1
06F2:  MOVLW  00
06F4:  ADDWFC xCC,W
06F6:  MOVWF  xD2
06F8:  MOVF   xCD,W
06FA:  ADDWF  xD1,W
06FC:  MOVWF  FE9
06FE:  MOVF   xCE,W
0700:  ADDWFC xD2,W
0702:  MOVWF  FEA
0704:  MOVF   FEF,W
0706:  XORWF  xD0,F
0708:  MOVLW  02
070A:  ADDWF  xCB,W
070C:  MOVWF  xD3
070E:  MOVLW  00
0710:  ADDWFC xCC,W
0712:  MOVWF  xD4
0714:  MOVF   xCD,W
0716:  ADDWF  xD3,W
0718:  MOVWF  FE9
071A:  MOVF   xCE,W
071C:  ADDWFC xD4,W
071E:  MOVWF  FEA
0720:  MOVF   FEF,W
0722:  XORWF  xD0,F
0724:  MOVLW  03
0726:  ADDWF  xCB,W
0728:  MOVWF  xD5
072A:  MOVLW  00
072C:  ADDWFC xCC,W
072E:  MOVWF  xD6
0730:  MOVF   xCD,W
0732:  ADDWF  xD5,W
0734:  MOVWF  FE9
0736:  MOVF   xCE,W
0738:  ADDWFC xD6,W
073A:  MOVWF  FEA
073C:  MOVF   FEF,W
073E:  XORWF  xD0,F
0740:  MOVLW  04
0742:  ADDWF  xCB,W
0744:  MOVWF  xD7
0746:  MOVLW  00
0748:  ADDWFC xCC,W
074A:  MOVWF  xD8
074C:  MOVF   xCD,W
074E:  ADDWF  xD7,W
0750:  MOVWF  FE9
0752:  MOVF   xCE,W
0754:  ADDWFC xD8,W
0756:  MOVWF  FEA
0758:  MOVF   FEF,W
075A:  XORWF  xD0,F
075C:  MOVLW  05
075E:  ADDWF  xCB,W
0760:  MOVWF  xD9
0762:  MOVLW  00
0764:  ADDWFC xCC,W
0766:  MOVWF  xDA
0768:  MOVF   xCD,W
076A:  ADDWF  xD9,W
076C:  MOVWF  FE9
076E:  MOVF   xCE,W
0770:  ADDWFC xDA,W
0772:  MOVWF  FEA
0774:  MOVF   FEF,W
0776:  XORWF  xD0,W
0778:  BZ    077E
077A:  MOVLW  00
077C:  BRA    0780
077E:  MOVLW  01
0780:  MOVWF  xCF
....................       if(temp==datain[offset+6]) return 1; 
0782:  MOVLW  06
0784:  ADDWF  xCB,W
0786:  MOVWF  xD0
0788:  MOVLW  00
078A:  ADDWFC xCC,W
078C:  MOVWF  xD1
078E:  MOVF   xCD,W
0790:  ADDWF  xD0,W
0792:  MOVWF  FE9
0794:  MOVF   xCE,W
0796:  ADDWFC xD1,W
0798:  MOVWF  FEA
079A:  MOVF   FEF,W
079C:  SUBWF  xCF,W
079E:  BNZ   07A8
07A0:  MOVLW  01
07A2:  MOVWF  01
07A4:  BRA    0880
....................          else return 0; 
07A6:  BRA    07AE
07A8:  MOVLW  00
07AA:  MOVWF  01
07AC:  BRA    0880
....................    } 
....................       else  
07AE:  BRA    0880
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
07B0:  MOVF   xCD,W
07B2:  ADDWF  xCB,W
07B4:  MOVWF  FE9
07B6:  MOVF   xCE,W
07B8:  ADDWFC xCC,W
07BA:  MOVWF  FEA
07BC:  MOVFF  FEF,9D0
07C0:  MOVLW  01
07C2:  SUBWF  xCB,W
07C4:  MOVWF  xD1
07C6:  MOVLW  00
07C8:  SUBWFB xCC,W
07CA:  MOVWF  xD2
07CC:  MOVF   xCD,W
07CE:  ADDWF  xD1,W
07D0:  MOVWF  FE9
07D2:  MOVF   xCE,W
07D4:  ADDWFC xD2,W
07D6:  MOVWF  FEA
07D8:  MOVF   FEF,W
07DA:  XORWF  xD0,F
07DC:  MOVLW  02
07DE:  SUBWF  xCB,W
07E0:  MOVWF  xD3
07E2:  MOVLW  00
07E4:  SUBWFB xCC,W
07E6:  MOVWF  xD4
07E8:  MOVF   xCD,W
07EA:  ADDWF  xD3,W
07EC:  MOVWF  FE9
07EE:  MOVF   xCE,W
07F0:  ADDWFC xD4,W
07F2:  MOVWF  FEA
07F4:  MOVF   FEF,W
07F6:  XORWF  xD0,F
07F8:  MOVLW  03
07FA:  SUBWF  xCB,W
07FC:  MOVWF  xD5
07FE:  MOVLW  00
0800:  SUBWFB xCC,W
0802:  MOVWF  xD6
0804:  MOVF   xCD,W
0806:  ADDWF  xD5,W
0808:  MOVWF  FE9
080A:  MOVF   xCE,W
080C:  ADDWFC xD6,W
080E:  MOVWF  FEA
0810:  MOVF   FEF,W
0812:  XORWF  xD0,F
0814:  MOVLW  04
0816:  SUBWF  xCB,W
0818:  MOVWF  xD7
081A:  MOVLW  00
081C:  SUBWFB xCC,W
081E:  MOVWF  xD8
0820:  MOVF   xCD,W
0822:  ADDWF  xD7,W
0824:  MOVWF  FE9
0826:  MOVF   xCE,W
0828:  ADDWFC xD8,W
082A:  MOVWF  FEA
082C:  MOVF   FEF,W
082E:  XORWF  xD0,F
0830:  MOVLW  05
0832:  SUBWF  xCB,W
0834:  MOVWF  xD9
0836:  MOVLW  00
0838:  SUBWFB xCC,W
083A:  MOVWF  xDA
083C:  MOVF   xCD,W
083E:  ADDWF  xD9,W
0840:  MOVWF  FE9
0842:  MOVF   xCE,W
0844:  ADDWFC xDA,W
0846:  MOVWF  FEA
0848:  MOVF   FEF,W
084A:  XORWF  xD0,W
084C:  BZ    0852
084E:  MOVLW  00
0850:  BRA    0854
0852:  MOVLW  01
0854:  MOVWF  xCF
....................          if(temp==datain[offset-6]) return 1; 
0856:  MOVLW  06
0858:  SUBWF  xCB,W
085A:  MOVWF  xD0
085C:  MOVLW  00
085E:  SUBWFB xCC,W
0860:  MOVWF  xD1
0862:  MOVF   xCD,W
0864:  ADDWF  xD0,W
0866:  MOVWF  FE9
0868:  MOVF   xCE,W
086A:  ADDWFC xD1,W
086C:  MOVWF  FEA
086E:  MOVF   FEF,W
0870:  SUBWF  xCF,W
0872:  BNZ   087C
0874:  MOVLW  01
0876:  MOVWF  01
0878:  BRA    0880
....................             else return 0;          
087A:  BRA    0880
087C:  MOVLW  00
087E:  MOVWF  01
....................       } 
.................... } 
0880:  MOVLB  0
0882:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
0884:  MOVLB  9
0886:  CLRF   xCF
....................    int8 temp=0; 
....................    if(direct==0) 
0888:  MOVF   xCA,F
088A:  BNZ   0928
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
088C:  MOVF   xCD,W
088E:  ADDWF  xCB,W
0890:  MOVWF  FE9
0892:  MOVF   xCE,W
0894:  ADDWFC xCC,W
0896:  MOVWF  FEA
0898:  MOVFF  FEF,9D0
089C:  MOVLW  01
089E:  ADDWF  xCB,W
08A0:  MOVWF  xD1
08A2:  MOVLW  00
08A4:  ADDWFC xCC,W
08A6:  MOVWF  xD2
08A8:  MOVF   xCD,W
08AA:  ADDWF  xD1,W
08AC:  MOVWF  FE9
08AE:  MOVF   xCE,W
08B0:  ADDWFC xD2,W
08B2:  MOVWF  FEA
08B4:  MOVF   FEF,W
08B6:  XORWF  xD0,F
08B8:  MOVLW  02
08BA:  ADDWF  xCB,W
08BC:  MOVWF  xD3
08BE:  MOVLW  00
08C0:  ADDWFC xCC,W
08C2:  MOVWF  xD4
08C4:  MOVF   xCD,W
08C6:  ADDWF  xD3,W
08C8:  MOVWF  FE9
08CA:  MOVF   xCE,W
08CC:  ADDWFC xD4,W
08CE:  MOVWF  FEA
08D0:  MOVF   FEF,W
08D2:  XORWF  xD0,F
08D4:  MOVLW  03
08D6:  ADDWF  xCB,W
08D8:  MOVWF  xD5
08DA:  MOVLW  00
08DC:  ADDWFC xCC,W
08DE:  MOVWF  xD6
08E0:  MOVF   xCD,W
08E2:  ADDWF  xD5,W
08E4:  MOVWF  FE9
08E6:  MOVF   xCE,W
08E8:  ADDWFC xD6,W
08EA:  MOVWF  FEA
08EC:  MOVF   FEF,W
08EE:  XORWF  xD0,W
08F0:  BZ    08F6
08F2:  MOVLW  00
08F4:  BRA    08F8
08F6:  MOVLW  01
08F8:  MOVWF  xCF
....................       if(temp==datain[offset+4]) return 1; 
08FA:  MOVLW  04
08FC:  ADDWF  xCB,W
08FE:  MOVWF  xD0
0900:  MOVLW  00
0902:  ADDWFC xCC,W
0904:  MOVWF  xD1
0906:  MOVF   xCD,W
0908:  ADDWF  xD0,W
090A:  MOVWF  FE9
090C:  MOVF   xCE,W
090E:  ADDWFC xD1,W
0910:  MOVWF  FEA
0912:  MOVF   FEF,W
0914:  SUBWF  xCF,W
0916:  BNZ   0920
0918:  MOVLW  01
091A:  MOVWF  01
091C:  BRA    09C0
....................          else return 0; 
091E:  BRA    0926
0920:  MOVLW  00
0922:  MOVWF  01
0924:  BRA    09C0
....................    } 
....................    else 
0926:  BRA    09C0
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0928:  MOVF   xCD,W
092A:  ADDWF  xCB,W
092C:  MOVWF  FE9
092E:  MOVF   xCE,W
0930:  ADDWFC xCC,W
0932:  MOVWF  FEA
0934:  MOVFF  FEF,9D0
0938:  MOVLW  01
093A:  SUBWF  xCB,W
093C:  MOVWF  xD1
093E:  MOVLW  00
0940:  SUBWFB xCC,W
0942:  MOVWF  xD2
0944:  MOVF   xCD,W
0946:  ADDWF  xD1,W
0948:  MOVWF  FE9
094A:  MOVF   xCE,W
094C:  ADDWFC xD2,W
094E:  MOVWF  FEA
0950:  MOVF   FEF,W
0952:  XORWF  xD0,F
0954:  MOVLW  02
0956:  SUBWF  xCB,W
0958:  MOVWF  xD3
095A:  MOVLW  00
095C:  SUBWFB xCC,W
095E:  MOVWF  xD4
0960:  MOVF   xCD,W
0962:  ADDWF  xD3,W
0964:  MOVWF  FE9
0966:  MOVF   xCE,W
0968:  ADDWFC xD4,W
096A:  MOVWF  FEA
096C:  MOVF   FEF,W
096E:  XORWF  xD0,F
0970:  MOVLW  03
0972:  SUBWF  xCB,W
0974:  MOVWF  xD5
0976:  MOVLW  00
0978:  SUBWFB xCC,W
097A:  MOVWF  xD6
097C:  MOVF   xCD,W
097E:  ADDWF  xD5,W
0980:  MOVWF  FE9
0982:  MOVF   xCE,W
0984:  ADDWFC xD6,W
0986:  MOVWF  FEA
0988:  MOVF   FEF,W
098A:  XORWF  xD0,W
098C:  BZ    0992
098E:  MOVLW  00
0990:  BRA    0994
0992:  MOVLW  01
0994:  MOVWF  xCF
....................       if(temp==datain[offset-4]) return 1; 
0996:  MOVLW  04
0998:  SUBWF  xCB,W
099A:  MOVWF  xD0
099C:  MOVLW  00
099E:  SUBWFB xCC,W
09A0:  MOVWF  xD1
09A2:  MOVF   xCD,W
09A4:  ADDWF  xD0,W
09A6:  MOVWF  FE9
09A8:  MOVF   xCE,W
09AA:  ADDWFC xD1,W
09AC:  MOVWF  FEA
09AE:  MOVF   FEF,W
09B0:  SUBWF  xCF,W
09B2:  BNZ   09BC
09B4:  MOVLW  01
09B6:  MOVWF  01
09B8:  BRA    09C0
....................          else return 0;                
09BA:  BRA    09C0
09BC:  MOVLW  00
09BE:  MOVWF  01
....................    } 
.................... } 
09C0:  MOVLB  0
09C2:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
09C4:  MOVLB  9
09C6:  CLRF   xC6
09C8:  CLRF   xC7
09CA:  CLRF   xC8
09CC:  CLRF   xC9
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
09CE:  CLRF   xC3
09D0:  CLRF   xC2
09D2:  RRCF   xBF,W
09D4:  MOVWF  03
09D6:  RRCF   xBE,W
09D8:  MOVWF  02
09DA:  RRCF   03,F
09DC:  RRCF   02,F
09DE:  MOVLW  3F
09E0:  ANDWF  03,F
09E2:  MOVFF  02,01
09E6:  MOVF   xC3,W
09E8:  SUBWF  03,W
09EA:  BTFSS  FD8.0
09EC:  BRA    0FAC
09EE:  BNZ   09F8
09F0:  MOVF   01,W
09F2:  SUBWF  xC2,W
09F4:  BTFSC  FD8.0
09F6:  BRA    0FAC
....................    { 
....................       if(track==0) 
09F8:  MOVF   xBD,F
09FA:  BTFSS  FD8.2
09FC:  BRA    0D32
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
09FE:  MOVLW  06
0A00:  ADDWF  xC2,W
0A02:  MOVWF  xCA
0A04:  MOVLW  00
0A06:  ADDWFC xC3,W
0A08:  MOVWF  xCB
0A0A:  MOVF   xC0,W
0A0C:  ADDWF  xCA,W
0A0E:  MOVWF  FE9
0A10:  MOVF   xC1,W
0A12:  ADDWFC xCB,W
0A14:  MOVWF  FEA
0A16:  MOVFF  FEF,9CC
0A1A:  MOVLW  05
0A1C:  ADDWF  xC2,W
0A1E:  MOVWF  xCD
0A20:  MOVLW  00
0A22:  ADDWFC xC3,W
0A24:  MOVWF  xCE
0A26:  MOVF   xC0,W
0A28:  ADDWF  xCD,W
0A2A:  MOVWF  FE9
0A2C:  MOVF   xC1,W
0A2E:  ADDWFC xCE,W
0A30:  MOVWF  FEA
0A32:  MOVFF  FEF,9CF
0A36:  MOVLW  04
0A38:  ADDWF  xC2,W
0A3A:  MOVWF  xD0
0A3C:  MOVLW  00
0A3E:  ADDWFC xC3,W
0A40:  MOVWF  xD1
0A42:  MOVF   xC0,W
0A44:  ADDWF  xD0,W
0A46:  MOVWF  FE9
0A48:  MOVF   xC1,W
0A4A:  ADDWFC xD1,W
0A4C:  MOVWF  FEA
0A4E:  MOVFF  FEF,9D2
0A52:  MOVLW  03
0A54:  ADDWF  xC2,W
0A56:  MOVWF  xD3
0A58:  MOVLW  00
0A5A:  ADDWFC xC3,W
0A5C:  MOVWF  xD4
0A5E:  MOVF   xC0,W
0A60:  ADDWF  xD3,W
0A62:  MOVWF  FE9
0A64:  MOVF   xC1,W
0A66:  ADDWFC xD4,W
0A68:  MOVWF  FEA
0A6A:  MOVFF  FEF,9D5
0A6E:  MOVLW  02
0A70:  ADDWF  xC2,W
0A72:  MOVWF  xD6
0A74:  MOVLW  00
0A76:  ADDWFC xC3,W
0A78:  MOVWF  xD7
0A7A:  MOVF   xC0,W
0A7C:  ADDWF  xD6,W
0A7E:  MOVWF  FE9
0A80:  MOVF   xC1,W
0A82:  ADDWFC xD7,W
0A84:  MOVWF  FEA
0A86:  MOVFF  FEF,9D8
0A8A:  MOVLW  01
0A8C:  ADDWF  xC2,W
0A8E:  MOVWF  xD9
0A90:  MOVLW  00
0A92:  ADDWFC xC3,W
0A94:  MOVWF  xDA
0A96:  MOVF   xC0,W
0A98:  ADDWF  xD9,W
0A9A:  MOVWF  FE9
0A9C:  MOVF   xC1,W
0A9E:  ADDWFC xDA,W
0AA0:  MOVWF  FEA
0AA2:  MOVFF  FEF,9DB
0AA6:  MOVF   xC0,W
0AA8:  ADDWF  xC2,W
0AAA:  MOVWF  FE9
0AAC:  MOVF   xC1,W
0AAE:  ADDWFC xC3,W
0AB0:  MOVWF  FEA
0AB2:  MOVFF  FEF,9DC
0AB6:  CLRF   xDF
0AB8:  MOVFF  9CC,9E0
0ABC:  MOVFF  9CF,9E1
0AC0:  MOVFF  9D2,9E2
0AC4:  MOVFF  9D5,9E3
0AC8:  MOVFF  9D8,9E4
0ACC:  MOVFF  9DB,9E5
0AD0:  MOVFF  9DC,9E6
0AD4:  MOVLB  0
0AD6:  RCALL  066E
0AD8:  MOVFF  01,9C6
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0ADC:  MOVLW  0D
0ADE:  MOVLB  9
0AE0:  ADDWF  xC2,W
0AE2:  MOVWF  xCA
0AE4:  MOVLW  00
0AE6:  ADDWFC xC3,W
0AE8:  MOVWF  xCB
0AEA:  MOVF   xC0,W
0AEC:  ADDWF  xCA,W
0AEE:  MOVWF  FE9
0AF0:  MOVF   xC1,W
0AF2:  ADDWFC xCB,W
0AF4:  MOVWF  FEA
0AF6:  MOVFF  FEF,9CC
0AFA:  MOVLW  0C
0AFC:  ADDWF  xC2,W
0AFE:  MOVWF  xCD
0B00:  MOVLW  00
0B02:  ADDWFC xC3,W
0B04:  MOVWF  xCE
0B06:  MOVF   xC0,W
0B08:  ADDWF  xCD,W
0B0A:  MOVWF  FE9
0B0C:  MOVF   xC1,W
0B0E:  ADDWFC xCE,W
0B10:  MOVWF  FEA
0B12:  MOVFF  FEF,9CF
0B16:  MOVLW  0B
0B18:  ADDWF  xC2,W
0B1A:  MOVWF  xD0
0B1C:  MOVLW  00
0B1E:  ADDWFC xC3,W
0B20:  MOVWF  xD1
0B22:  MOVF   xC0,W
0B24:  ADDWF  xD0,W
0B26:  MOVWF  FE9
0B28:  MOVF   xC1,W
0B2A:  ADDWFC xD1,W
0B2C:  MOVWF  FEA
0B2E:  MOVFF  FEF,9D2
0B32:  MOVLW  0A
0B34:  ADDWF  xC2,W
0B36:  MOVWF  xD3
0B38:  MOVLW  00
0B3A:  ADDWFC xC3,W
0B3C:  MOVWF  xD4
0B3E:  MOVF   xC0,W
0B40:  ADDWF  xD3,W
0B42:  MOVWF  FE9
0B44:  MOVF   xC1,W
0B46:  ADDWFC xD4,W
0B48:  MOVWF  FEA
0B4A:  MOVFF  FEF,9D5
0B4E:  MOVLW  09
0B50:  ADDWF  xC2,W
0B52:  MOVWF  xD6
0B54:  MOVLW  00
0B56:  ADDWFC xC3,W
0B58:  MOVWF  xD7
0B5A:  MOVF   xC0,W
0B5C:  ADDWF  xD6,W
0B5E:  MOVWF  FE9
0B60:  MOVF   xC1,W
0B62:  ADDWFC xD7,W
0B64:  MOVWF  FEA
0B66:  MOVFF  FEF,9D8
0B6A:  MOVLW  08
0B6C:  ADDWF  xC2,W
0B6E:  MOVWF  xD9
0B70:  MOVLW  00
0B72:  ADDWFC xC3,W
0B74:  MOVWF  xDA
0B76:  MOVF   xC0,W
0B78:  ADDWF  xD9,W
0B7A:  MOVWF  FE9
0B7C:  MOVF   xC1,W
0B7E:  ADDWFC xDA,W
0B80:  MOVWF  FEA
0B82:  MOVFF  FEF,9DB
0B86:  MOVLW  07
0B88:  ADDWF  xC2,W
0B8A:  MOVWF  xDC
0B8C:  MOVLW  00
0B8E:  ADDWFC xC3,W
0B90:  MOVWF  xDD
0B92:  MOVF   xC0,W
0B94:  ADDWF  xDC,W
0B96:  MOVWF  FE9
0B98:  MOVF   xC1,W
0B9A:  ADDWFC xDD,W
0B9C:  MOVWF  FEA
0B9E:  MOVFF  FEF,9DE
0BA2:  CLRF   xDF
0BA4:  MOVFF  9CC,9E0
0BA8:  MOVFF  9CF,9E1
0BAC:  MOVFF  9D2,9E2
0BB0:  MOVFF  9D5,9E3
0BB4:  MOVFF  9D8,9E4
0BB8:  MOVFF  9DB,9E5
0BBC:  MOVFF  9DE,9E6
0BC0:  MOVLB  0
0BC2:  RCALL  066E
0BC4:  MOVFF  01,9C7
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0BC8:  MOVLB  9
0BCA:  MOVF   xC6,W
0BCC:  SUBLW  45
0BCE:  BTFSS  FD8.2
0BD0:  BRA    0D30
0BD2:  MOVF   xC7,W
0BD4:  SUBLW  7C
0BD6:  BTFSC  FD8.2
0BD8:  BRA    0D30
0BDA:  MOVF   xC7,W
0BDC:  SUBLW  3E
0BDE:  BTFSC  FD8.2
0BE0:  BRA    0D30
0BE2:  MOVF   xC7,W
0BE4:  SUBLW  1F
0BE6:  BTFSC  FD8.2
0BE8:  BRA    0D30
....................          { 
....................             j=i; 
0BEA:  MOVFF  9C3,9C5
0BEE:  MOVFF  9C2,9C4
....................             CRC=1; 
0BF2:  MOVLW  01
0BF4:  MOVWF  xC9
....................             temp2=temp; 
0BF6:  MOVFF  9C6,9C8
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0BFA:  MOVF   xC8,W
0BFC:  SUBLW  1F
0BFE:  BTFSC  FD8.2
0C00:  BRA    0D1A
0C02:  MOVF   xC5,W
0C04:  SUBLW  03
0C06:  BTFSS  FD8.0
0C08:  BRA    0D1A
0C0A:  BNZ   0C14
0C0C:  MOVF   xC4,W
0C0E:  SUBLW  E7
0C10:  BTFSS  FD8.0
0C12:  BRA    0D1A
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C14:  CLRF   xCA
0C16:  MOVFF  9C5,9CC
0C1A:  MOVFF  9C4,9CB
0C1E:  MOVFF  9C1,9CE
0C22:  MOVFF  9C0,9CD
0C26:  MOVLB  0
0C28:  RCALL  06D4
0C2A:  MOVF   01,W
0C2C:  MOVLB  9
0C2E:  ANDWF  xC9,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C30:  MOVLW  06
0C32:  ADDWF  xC4,W
0C34:  MOVWF  xCA
0C36:  MOVLW  00
0C38:  ADDWFC xC5,W
0C3A:  MOVWF  xCB
0C3C:  MOVF   xC0,W
0C3E:  ADDWF  xCA,W
0C40:  MOVWF  FE9
0C42:  MOVF   xC1,W
0C44:  ADDWFC xCB,W
0C46:  MOVWF  FEA
0C48:  MOVFF  FEF,9CC
0C4C:  MOVLW  05
0C4E:  ADDWF  xC4,W
0C50:  MOVWF  xCD
0C52:  MOVLW  00
0C54:  ADDWFC xC5,W
0C56:  MOVWF  xCE
0C58:  MOVF   xC0,W
0C5A:  ADDWF  xCD,W
0C5C:  MOVWF  FE9
0C5E:  MOVF   xC1,W
0C60:  ADDWFC xCE,W
0C62:  MOVWF  FEA
0C64:  MOVFF  FEF,9CF
0C68:  MOVLW  04
0C6A:  ADDWF  xC4,W
0C6C:  MOVWF  xD0
0C6E:  MOVLW  00
0C70:  ADDWFC xC5,W
0C72:  MOVWF  xD1
0C74:  MOVF   xC0,W
0C76:  ADDWF  xD0,W
0C78:  MOVWF  FE9
0C7A:  MOVF   xC1,W
0C7C:  ADDWFC xD1,W
0C7E:  MOVWF  FEA
0C80:  MOVFF  FEF,9D2
0C84:  MOVLW  03
0C86:  ADDWF  xC4,W
0C88:  MOVWF  xD3
0C8A:  MOVLW  00
0C8C:  ADDWFC xC5,W
0C8E:  MOVWF  xD4
0C90:  MOVF   xC0,W
0C92:  ADDWF  xD3,W
0C94:  MOVWF  FE9
0C96:  MOVF   xC1,W
0C98:  ADDWFC xD4,W
0C9A:  MOVWF  FEA
0C9C:  MOVFF  FEF,9D5
0CA0:  MOVLW  02
0CA2:  ADDWF  xC4,W
0CA4:  MOVWF  xD6
0CA6:  MOVLW  00
0CA8:  ADDWFC xC5,W
0CAA:  MOVWF  xD7
0CAC:  MOVF   xC0,W
0CAE:  ADDWF  xD6,W
0CB0:  MOVWF  FE9
0CB2:  MOVF   xC1,W
0CB4:  ADDWFC xD7,W
0CB6:  MOVWF  FEA
0CB8:  MOVFF  FEF,9D8
0CBC:  MOVLW  01
0CBE:  ADDWF  xC4,W
0CC0:  MOVWF  xD9
0CC2:  MOVLW  00
0CC4:  ADDWFC xC5,W
0CC6:  MOVWF  xDA
0CC8:  MOVF   xC0,W
0CCA:  ADDWF  xD9,W
0CCC:  MOVWF  FE9
0CCE:  MOVF   xC1,W
0CD0:  ADDWFC xDA,W
0CD2:  MOVWF  FEA
0CD4:  MOVFF  FEF,9DB
0CD8:  MOVF   xC0,W
0CDA:  ADDWF  xC4,W
0CDC:  MOVWF  FE9
0CDE:  MOVF   xC1,W
0CE0:  ADDWFC xC5,W
0CE2:  MOVWF  FEA
0CE4:  MOVFF  FEF,9DC
0CE8:  CLRF   xDF
0CEA:  MOVFF  9CC,9E0
0CEE:  MOVFF  9CF,9E1
0CF2:  MOVFF  9D2,9E2
0CF6:  MOVFF  9D5,9E3
0CFA:  MOVFF  9D8,9E4
0CFE:  MOVFF  9DB,9E5
0D02:  MOVFF  9DC,9E6
0D06:  MOVLB  0
0D08:  RCALL  066E
0D0A:  MOVFF  01,9C8
....................                j=j+7; 
0D0E:  MOVLW  07
0D10:  MOVLB  9
0D12:  ADDWF  xC4,F
0D14:  MOVLW  00
0D16:  ADDWFC xC5,F
....................             } 
0D18:  BRA    0BFA
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D1A:  DECFSZ xC9,W
0D1C:  BRA    0D30
....................             { 
....................                dir=0; 
0D1E:  MOVLB  8
0D20:  CLRF   x5B
....................                return i; 
0D22:  MOVLB  9
0D24:  MOVFF  9C2,01
0D28:  MOVFF  9C3,02
0D2C:  GOTO   15C2
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0D30:  BRA    0FA4
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0D32:  MOVLW  04
0D34:  ADDWF  xC2,W
0D36:  MOVWF  xCA
0D38:  MOVLW  00
0D3A:  ADDWFC xC3,W
0D3C:  MOVWF  xCB
0D3E:  MOVF   xC0,W
0D40:  ADDWF  xCA,W
0D42:  MOVWF  FE9
0D44:  MOVF   xC1,W
0D46:  ADDWFC xCB,W
0D48:  MOVWF  FEA
0D4A:  MOVFF  FEF,9CC
0D4E:  MOVLW  03
0D50:  ADDWF  xC2,W
0D52:  MOVWF  xCD
0D54:  MOVLW  00
0D56:  ADDWFC xC3,W
0D58:  MOVWF  xCE
0D5A:  MOVF   xC0,W
0D5C:  ADDWF  xCD,W
0D5E:  MOVWF  FE9
0D60:  MOVF   xC1,W
0D62:  ADDWFC xCE,W
0D64:  MOVWF  FEA
0D66:  MOVFF  FEF,9CF
0D6A:  MOVLW  02
0D6C:  ADDWF  xC2,W
0D6E:  MOVWF  xD0
0D70:  MOVLW  00
0D72:  ADDWFC xC3,W
0D74:  MOVWF  xD1
0D76:  MOVF   xC0,W
0D78:  ADDWF  xD0,W
0D7A:  MOVWF  FE9
0D7C:  MOVF   xC1,W
0D7E:  ADDWFC xD1,W
0D80:  MOVWF  FEA
0D82:  MOVFF  FEF,9D2
0D86:  MOVLW  01
0D88:  ADDWF  xC2,W
0D8A:  MOVWF  xD3
0D8C:  MOVLW  00
0D8E:  ADDWFC xC3,W
0D90:  MOVWF  xD4
0D92:  MOVF   xC0,W
0D94:  ADDWF  xD3,W
0D96:  MOVWF  FE9
0D98:  MOVF   xC1,W
0D9A:  ADDWFC xD4,W
0D9C:  MOVWF  FEA
0D9E:  MOVFF  FEF,9D5
0DA2:  MOVF   xC0,W
0DA4:  ADDWF  xC2,W
0DA6:  MOVWF  FE9
0DA8:  MOVF   xC1,W
0DAA:  ADDWFC xC3,W
0DAC:  MOVWF  FEA
0DAE:  MOVFF  FEF,9D6
0DB2:  CLRF   xDF
0DB4:  CLRF   xE0
0DB6:  CLRF   xE1
0DB8:  MOVFF  9CC,9E2
0DBC:  MOVFF  9CF,9E3
0DC0:  MOVFF  9D2,9E4
0DC4:  MOVFF  9D5,9E5
0DC8:  MOVFF  9D6,9E6
0DCC:  MOVLB  0
0DCE:  RCALL  066E
0DD0:  MOVFF  01,9C6
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0DD4:  MOVLW  09
0DD6:  MOVLB  9
0DD8:  ADDWF  xC2,W
0DDA:  MOVWF  xCA
0DDC:  MOVLW  00
0DDE:  ADDWFC xC3,W
0DE0:  MOVWF  xCB
0DE2:  MOVF   xC0,W
0DE4:  ADDWF  xCA,W
0DE6:  MOVWF  FE9
0DE8:  MOVF   xC1,W
0DEA:  ADDWFC xCB,W
0DEC:  MOVWF  FEA
0DEE:  MOVFF  FEF,9CC
0DF2:  MOVLW  08
0DF4:  ADDWF  xC2,W
0DF6:  MOVWF  xCD
0DF8:  MOVLW  00
0DFA:  ADDWFC xC3,W
0DFC:  MOVWF  xCE
0DFE:  MOVF   xC0,W
0E00:  ADDWF  xCD,W
0E02:  MOVWF  FE9
0E04:  MOVF   xC1,W
0E06:  ADDWFC xCE,W
0E08:  MOVWF  FEA
0E0A:  MOVFF  FEF,9CF
0E0E:  MOVLW  07
0E10:  ADDWF  xC2,W
0E12:  MOVWF  xD0
0E14:  MOVLW  00
0E16:  ADDWFC xC3,W
0E18:  MOVWF  xD1
0E1A:  MOVF   xC0,W
0E1C:  ADDWF  xD0,W
0E1E:  MOVWF  FE9
0E20:  MOVF   xC1,W
0E22:  ADDWFC xD1,W
0E24:  MOVWF  FEA
0E26:  MOVFF  FEF,9D2
0E2A:  MOVLW  06
0E2C:  ADDWF  xC2,W
0E2E:  MOVWF  xD3
0E30:  MOVLW  00
0E32:  ADDWFC xC3,W
0E34:  MOVWF  xD4
0E36:  MOVF   xC0,W
0E38:  ADDWF  xD3,W
0E3A:  MOVWF  FE9
0E3C:  MOVF   xC1,W
0E3E:  ADDWFC xD4,W
0E40:  MOVWF  FEA
0E42:  MOVFF  FEF,9D5
0E46:  MOVLW  05
0E48:  ADDWF  xC2,W
0E4A:  MOVWF  xD6
0E4C:  MOVLW  00
0E4E:  ADDWFC xC3,W
0E50:  MOVWF  xD7
0E52:  MOVF   xC0,W
0E54:  ADDWF  xD6,W
0E56:  MOVWF  FE9
0E58:  MOVF   xC1,W
0E5A:  ADDWFC xD7,W
0E5C:  MOVWF  FEA
0E5E:  MOVFF  FEF,9D8
0E62:  CLRF   xDF
0E64:  CLRF   xE0
0E66:  CLRF   xE1
0E68:  MOVFF  9CC,9E2
0E6C:  MOVFF  9CF,9E3
0E70:  MOVFF  9D2,9E4
0E74:  MOVFF  9D5,9E5
0E78:  MOVFF  9D8,9E6
0E7C:  MOVLB  0
0E7E:  CALL   066E
0E82:  MOVFF  01,9C7
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0E86:  MOVLB  9
0E88:  MOVF   xC6,W
0E8A:  SUBLW  0B
0E8C:  BTFSS  FD8.2
0E8E:  BRA    0FA4
0E90:  MOVF   xC7,W
0E92:  SUBLW  1F
0E94:  BTFSC  FD8.2
0E96:  BRA    0FA4
0E98:  MOVF   xC7,W
0E9A:  SUBLW  0F
0E9C:  BTFSC  FD8.2
0E9E:  BRA    0FA4
....................             { 
....................                j=i; 
0EA0:  MOVFF  9C3,9C5
0EA4:  MOVFF  9C2,9C4
....................                CRC=1; 
0EA8:  MOVLW  01
0EAA:  MOVWF  xC9
....................                temp2=temp; 
0EAC:  MOVFF  9C6,9C8
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0EB0:  MOVF   xC8,W
0EB2:  SUBLW  1F
0EB4:  BZ    0F90
0EB6:  MOVF   xC5,W
0EB8:  SUBLW  01
0EBA:  BNC   0F90
0EBC:  BNZ   0EC4
0EBE:  MOVF   xC4,W
0EC0:  SUBLW  F3
0EC2:  BNC   0F90
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0EC4:  CLRF   xCA
0EC6:  MOVFF  9C5,9CC
0ECA:  MOVFF  9C4,9CB
0ECE:  MOVFF  9C1,9CE
0ED2:  MOVFF  9C0,9CD
0ED6:  MOVLB  0
0ED8:  RCALL  0884
0EDA:  MOVF   01,W
0EDC:  MOVLB  9
0EDE:  ANDWF  xC9,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0EE0:  MOVLW  04
0EE2:  ADDWF  xC4,W
0EE4:  MOVWF  xCA
0EE6:  MOVLW  00
0EE8:  ADDWFC xC5,W
0EEA:  MOVWF  xCB
0EEC:  MOVF   xC0,W
0EEE:  ADDWF  xCA,W
0EF0:  MOVWF  FE9
0EF2:  MOVF   xC1,W
0EF4:  ADDWFC xCB,W
0EF6:  MOVWF  FEA
0EF8:  MOVFF  FEF,9CC
0EFC:  MOVLW  03
0EFE:  ADDWF  xC4,W
0F00:  MOVWF  xCD
0F02:  MOVLW  00
0F04:  ADDWFC xC5,W
0F06:  MOVWF  xCE
0F08:  MOVF   xC0,W
0F0A:  ADDWF  xCD,W
0F0C:  MOVWF  FE9
0F0E:  MOVF   xC1,W
0F10:  ADDWFC xCE,W
0F12:  MOVWF  FEA
0F14:  MOVFF  FEF,9CF
0F18:  MOVLW  02
0F1A:  ADDWF  xC4,W
0F1C:  MOVWF  xD0
0F1E:  MOVLW  00
0F20:  ADDWFC xC5,W
0F22:  MOVWF  xD1
0F24:  MOVF   xC0,W
0F26:  ADDWF  xD0,W
0F28:  MOVWF  FE9
0F2A:  MOVF   xC1,W
0F2C:  ADDWFC xD1,W
0F2E:  MOVWF  FEA
0F30:  MOVFF  FEF,9D2
0F34:  MOVLW  01
0F36:  ADDWF  xC4,W
0F38:  MOVWF  xD3
0F3A:  MOVLW  00
0F3C:  ADDWFC xC5,W
0F3E:  MOVWF  xD4
0F40:  MOVF   xC0,W
0F42:  ADDWF  xD3,W
0F44:  MOVWF  FE9
0F46:  MOVF   xC1,W
0F48:  ADDWFC xD4,W
0F4A:  MOVWF  FEA
0F4C:  MOVFF  FEF,9D5
0F50:  MOVF   xC0,W
0F52:  ADDWF  xC4,W
0F54:  MOVWF  FE9
0F56:  MOVF   xC1,W
0F58:  ADDWFC xC5,W
0F5A:  MOVWF  FEA
0F5C:  MOVFF  FEF,9D6
0F60:  CLRF   xDF
0F62:  CLRF   xE0
0F64:  CLRF   xE1
0F66:  MOVFF  9CC,9E2
0F6A:  MOVFF  9CF,9E3
0F6E:  MOVFF  9D2,9E4
0F72:  MOVFF  9D5,9E5
0F76:  MOVFF  9D6,9E6
0F7A:  MOVLB  0
0F7C:  CALL   066E
0F80:  MOVFF  01,9C8
....................                   j=j+5; 
0F84:  MOVLW  05
0F86:  MOVLB  9
0F88:  ADDWF  xC4,F
0F8A:  MOVLW  00
0F8C:  ADDWFC xC5,F
....................                } 
0F8E:  BRA    0EB0
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
0F90:  DECFSZ xC9,W
0F92:  BRA    0FA4
....................                { 
....................                   dir=0; 
0F94:  MOVLB  8
0F96:  CLRF   x5B
....................                   return i; 
0F98:  MOVLB  9
0F9A:  MOVFF  9C2,01
0F9E:  MOVFF  9C3,02
0FA2:  BRA    15C2
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
0FA4:  INCF   xC2,F
0FA6:  BTFSC  FD8.2
0FA8:  INCF   xC3,F
0FAA:  BRA    09D2
....................    for(i=end_point;i>end_point/4;i--) 
0FAC:  MOVFF  9BF,9C3
0FB0:  MOVFF  9BE,9C2
0FB4:  RRCF   xBF,W
0FB6:  MOVWF  03
0FB8:  RRCF   xBE,W
0FBA:  MOVWF  02
0FBC:  RRCF   03,F
0FBE:  RRCF   02,F
0FC0:  MOVLW  3F
0FC2:  ANDWF  03,F
0FC4:  MOVFF  02,01
0FC8:  MOVF   03,W
0FCA:  SUBWF  xC3,W
0FCC:  BTFSS  FD8.0
0FCE:  BRA    15BC
0FD0:  BNZ   0FDA
0FD2:  MOVF   xC2,W
0FD4:  SUBWF  01,W
0FD6:  BTFSC  FD8.0
0FD8:  BRA    15BC
....................    { 
....................       if(track==0) 
0FDA:  MOVF   xBD,F
0FDC:  BTFSS  FD8.2
0FDE:  BRA    1332
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
0FE0:  MOVLW  06
0FE2:  SUBWF  xC2,W
0FE4:  MOVWF  xCA
0FE6:  MOVLW  00
0FE8:  SUBWFB xC3,W
0FEA:  MOVWF  xCB
0FEC:  MOVF   xC0,W
0FEE:  ADDWF  xCA,W
0FF0:  MOVWF  FE9
0FF2:  MOVF   xC1,W
0FF4:  ADDWFC xCB,W
0FF6:  MOVWF  FEA
0FF8:  MOVFF  FEF,9CC
0FFC:  MOVLW  05
0FFE:  SUBWF  xC2,W
1000:  MOVWF  xCD
1002:  MOVLW  00
1004:  SUBWFB xC3,W
1006:  MOVWF  xCE
1008:  MOVF   xC0,W
100A:  ADDWF  xCD,W
100C:  MOVWF  FE9
100E:  MOVF   xC1,W
1010:  ADDWFC xCE,W
1012:  MOVWF  FEA
1014:  MOVFF  FEF,9CF
1018:  MOVLW  04
101A:  SUBWF  xC2,W
101C:  MOVWF  xD0
101E:  MOVLW  00
1020:  SUBWFB xC3,W
1022:  MOVWF  xD1
1024:  MOVF   xC0,W
1026:  ADDWF  xD0,W
1028:  MOVWF  FE9
102A:  MOVF   xC1,W
102C:  ADDWFC xD1,W
102E:  MOVWF  FEA
1030:  MOVFF  FEF,9D2
1034:  MOVLW  03
1036:  SUBWF  xC2,W
1038:  MOVWF  xD3
103A:  MOVLW  00
103C:  SUBWFB xC3,W
103E:  MOVWF  xD4
1040:  MOVF   xC0,W
1042:  ADDWF  xD3,W
1044:  MOVWF  FE9
1046:  MOVF   xC1,W
1048:  ADDWFC xD4,W
104A:  MOVWF  FEA
104C:  MOVFF  FEF,9D5
1050:  MOVLW  02
1052:  SUBWF  xC2,W
1054:  MOVWF  xD6
1056:  MOVLW  00
1058:  SUBWFB xC3,W
105A:  MOVWF  xD7
105C:  MOVF   xC0,W
105E:  ADDWF  xD6,W
1060:  MOVWF  FE9
1062:  MOVF   xC1,W
1064:  ADDWFC xD7,W
1066:  MOVWF  FEA
1068:  MOVFF  FEF,9D8
106C:  MOVLW  01
106E:  SUBWF  xC2,W
1070:  MOVWF  xD9
1072:  MOVLW  00
1074:  SUBWFB xC3,W
1076:  MOVWF  xDA
1078:  MOVF   xC0,W
107A:  ADDWF  xD9,W
107C:  MOVWF  FE9
107E:  MOVF   xC1,W
1080:  ADDWFC xDA,W
1082:  MOVWF  FEA
1084:  MOVFF  FEF,9DB
1088:  MOVF   xC0,W
108A:  ADDWF  xC2,W
108C:  MOVWF  FE9
108E:  MOVF   xC1,W
1090:  ADDWFC xC3,W
1092:  MOVWF  FEA
1094:  MOVFF  FEF,9DC
1098:  CLRF   xDF
109A:  MOVFF  9CC,9E0
109E:  MOVFF  9CF,9E1
10A2:  MOVFF  9D2,9E2
10A6:  MOVFF  9D5,9E3
10AA:  MOVFF  9D8,9E4
10AE:  MOVFF  9DB,9E5
10B2:  MOVFF  9DC,9E6
10B6:  MOVLB  0
10B8:  CALL   066E
10BC:  MOVFF  01,9C6
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
10C0:  MOVLW  0D
10C2:  MOVLB  9
10C4:  SUBWF  xC2,W
10C6:  MOVWF  xCA
10C8:  MOVLW  00
10CA:  SUBWFB xC3,W
10CC:  MOVWF  xCB
10CE:  MOVF   xC0,W
10D0:  ADDWF  xCA,W
10D2:  MOVWF  FE9
10D4:  MOVF   xC1,W
10D6:  ADDWFC xCB,W
10D8:  MOVWF  FEA
10DA:  MOVFF  FEF,9CC
10DE:  MOVLW  0C
10E0:  SUBWF  xC2,W
10E2:  MOVWF  xCD
10E4:  MOVLW  00
10E6:  SUBWFB xC3,W
10E8:  MOVWF  xCE
10EA:  MOVF   xC0,W
10EC:  ADDWF  xCD,W
10EE:  MOVWF  FE9
10F0:  MOVF   xC1,W
10F2:  ADDWFC xCE,W
10F4:  MOVWF  FEA
10F6:  MOVFF  FEF,9CF
10FA:  MOVLW  0B
10FC:  SUBWF  xC2,W
10FE:  MOVWF  xD0
1100:  MOVLW  00
1102:  SUBWFB xC3,W
1104:  MOVWF  xD1
1106:  MOVF   xC0,W
1108:  ADDWF  xD0,W
110A:  MOVWF  FE9
110C:  MOVF   xC1,W
110E:  ADDWFC xD1,W
1110:  MOVWF  FEA
1112:  MOVFF  FEF,9D2
1116:  MOVLW  0A
1118:  SUBWF  xC2,W
111A:  MOVWF  xD3
111C:  MOVLW  00
111E:  SUBWFB xC3,W
1120:  MOVWF  xD4
1122:  MOVF   xC0,W
1124:  ADDWF  xD3,W
1126:  MOVWF  FE9
1128:  MOVF   xC1,W
112A:  ADDWFC xD4,W
112C:  MOVWF  FEA
112E:  MOVFF  FEF,9D5
1132:  MOVLW  09
1134:  SUBWF  xC2,W
1136:  MOVWF  xD6
1138:  MOVLW  00
113A:  SUBWFB xC3,W
113C:  MOVWF  xD7
113E:  MOVF   xC0,W
1140:  ADDWF  xD6,W
1142:  MOVWF  FE9
1144:  MOVF   xC1,W
1146:  ADDWFC xD7,W
1148:  MOVWF  FEA
114A:  MOVFF  FEF,9D8
114E:  MOVLW  08
1150:  SUBWF  xC2,W
1152:  MOVWF  xD9
1154:  MOVLW  00
1156:  SUBWFB xC3,W
1158:  MOVWF  xDA
115A:  MOVF   xC0,W
115C:  ADDWF  xD9,W
115E:  MOVWF  FE9
1160:  MOVF   xC1,W
1162:  ADDWFC xDA,W
1164:  MOVWF  FEA
1166:  MOVFF  FEF,9DB
116A:  MOVLW  07
116C:  SUBWF  xC2,W
116E:  MOVWF  xDC
1170:  MOVLW  00
1172:  SUBWFB xC3,W
1174:  MOVWF  xDD
1176:  MOVF   xC0,W
1178:  ADDWF  xDC,W
117A:  MOVWF  FE9
117C:  MOVF   xC1,W
117E:  ADDWFC xDD,W
1180:  MOVWF  FEA
1182:  MOVFF  FEF,9DE
1186:  CLRF   xDF
1188:  MOVFF  9CC,9E0
118C:  MOVFF  9CF,9E1
1190:  MOVFF  9D2,9E2
1194:  MOVFF  9D5,9E3
1198:  MOVFF  9D8,9E4
119C:  MOVFF  9DB,9E5
11A0:  MOVFF  9DE,9E6
11A4:  MOVLB  0
11A6:  CALL   066E
11AA:  MOVFF  01,9C7
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
11AE:  MOVLB  9
11B0:  MOVF   xC6,W
11B2:  SUBLW  45
11B4:  BTFSS  FD8.2
11B6:  BRA    1330
11B8:  MOVF   xC7,W
11BA:  SUBLW  7C
11BC:  BTFSC  FD8.2
11BE:  BRA    1330
11C0:  MOVF   xC7,W
11C2:  SUBLW  3E
11C4:  BTFSC  FD8.2
11C6:  BRA    1330
11C8:  MOVF   xC7,W
11CA:  SUBLW  1F
11CC:  BTFSC  FD8.2
11CE:  BRA    1330
11D0:  MOVF   xC7,W
11D2:  SUBLW  0F
11D4:  BTFSC  FD8.2
11D6:  BRA    1330
11D8:  MOVF   xC7,W
11DA:  SUBLW  78
11DC:  BTFSC  FD8.2
11DE:  BRA    1330
....................          { 
....................             j=i; 
11E0:  MOVFF  9C3,9C5
11E4:  MOVFF  9C2,9C4
....................             CRC=1; 
11E8:  MOVLW  01
11EA:  MOVWF  xC9
....................             temp2=temp; 
11EC:  MOVFF  9C6,9C8
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
11F0:  MOVF   xC8,W
11F2:  SUBLW  1F
11F4:  BTFSC  FD8.2
11F6:  BRA    1310
11F8:  MOVF   xC5,F
11FA:  BNZ   1204
11FC:  MOVF   xC4,W
11FE:  SUBLW  01
1200:  BTFSC  FD8.0
1202:  BRA    1310
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1204:  MOVLW  01
1206:  MOVWF  xCA
1208:  MOVFF  9C5,9CC
120C:  MOVFF  9C4,9CB
1210:  MOVFF  9C1,9CE
1214:  MOVFF  9C0,9CD
1218:  MOVLB  0
121A:  CALL   06D4
121E:  MOVF   01,W
1220:  MOVLB  9
1222:  ANDWF  xC9,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1224:  MOVLW  06
1226:  SUBWF  xC4,W
1228:  MOVWF  xCA
122A:  MOVLW  00
122C:  SUBWFB xC5,W
122E:  MOVWF  xCB
1230:  MOVF   xC0,W
1232:  ADDWF  xCA,W
1234:  MOVWF  FE9
1236:  MOVF   xC1,W
1238:  ADDWFC xCB,W
123A:  MOVWF  FEA
123C:  MOVFF  FEF,9CC
1240:  MOVLW  05
1242:  SUBWF  xC4,W
1244:  MOVWF  xCD
1246:  MOVLW  00
1248:  SUBWFB xC5,W
124A:  MOVWF  xCE
124C:  MOVF   xC0,W
124E:  ADDWF  xCD,W
1250:  MOVWF  FE9
1252:  MOVF   xC1,W
1254:  ADDWFC xCE,W
1256:  MOVWF  FEA
1258:  MOVFF  FEF,9CF
125C:  MOVLW  04
125E:  SUBWF  xC4,W
1260:  MOVWF  xD0
1262:  MOVLW  00
1264:  SUBWFB xC5,W
1266:  MOVWF  xD1
1268:  MOVF   xC0,W
126A:  ADDWF  xD0,W
126C:  MOVWF  FE9
126E:  MOVF   xC1,W
1270:  ADDWFC xD1,W
1272:  MOVWF  FEA
1274:  MOVFF  FEF,9D2
1278:  MOVLW  03
127A:  SUBWF  xC4,W
127C:  MOVWF  xD3
127E:  MOVLW  00
1280:  SUBWFB xC5,W
1282:  MOVWF  xD4
1284:  MOVF   xC0,W
1286:  ADDWF  xD3,W
1288:  MOVWF  FE9
128A:  MOVF   xC1,W
128C:  ADDWFC xD4,W
128E:  MOVWF  FEA
1290:  MOVFF  FEF,9D5
1294:  MOVLW  02
1296:  SUBWF  xC4,W
1298:  MOVWF  xD6
129A:  MOVLW  00
129C:  SUBWFB xC5,W
129E:  MOVWF  xD7
12A0:  MOVF   xC0,W
12A2:  ADDWF  xD6,W
12A4:  MOVWF  FE9
12A6:  MOVF   xC1,W
12A8:  ADDWFC xD7,W
12AA:  MOVWF  FEA
12AC:  MOVFF  FEF,9D8
12B0:  MOVLW  01
12B2:  SUBWF  xC4,W
12B4:  MOVWF  xD9
12B6:  MOVLW  00
12B8:  SUBWFB xC5,W
12BA:  MOVWF  xDA
12BC:  MOVF   xC0,W
12BE:  ADDWF  xD9,W
12C0:  MOVWF  FE9
12C2:  MOVF   xC1,W
12C4:  ADDWFC xDA,W
12C6:  MOVWF  FEA
12C8:  MOVFF  FEF,9DB
12CC:  MOVF   xC0,W
12CE:  ADDWF  xC4,W
12D0:  MOVWF  FE9
12D2:  MOVF   xC1,W
12D4:  ADDWFC xC5,W
12D6:  MOVWF  FEA
12D8:  MOVFF  FEF,9DC
12DC:  CLRF   xDF
12DE:  MOVFF  9CC,9E0
12E2:  MOVFF  9CF,9E1
12E6:  MOVFF  9D2,9E2
12EA:  MOVFF  9D5,9E3
12EE:  MOVFF  9D8,9E4
12F2:  MOVFF  9DB,9E5
12F6:  MOVFF  9DC,9E6
12FA:  MOVLB  0
12FC:  CALL   066E
1300:  MOVFF  01,9C8
....................                j=j-7;             
1304:  MOVLW  07
1306:  MOVLB  9
1308:  SUBWF  xC4,F
130A:  MOVLW  00
130C:  SUBWFB xC5,F
....................              } 
130E:  BRA    11F0
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
1310:  DECFSZ xC9,W
1312:  BRA    1328
....................             { 
....................                dir=1; 
1314:  MOVLW  01
1316:  MOVLB  8
1318:  MOVWF  x5B
....................                return i; 
131A:  MOVLB  9
131C:  MOVFF  9C2,01
1320:  MOVFF  9C3,02
1324:  BRA    15C2
....................             } 
....................             else return 0; 
1326:  BRA    1330
1328:  MOVLW  00
132A:  MOVWF  01
132C:  MOVWF  02
132E:  BRA    15C2
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
1330:  BRA    15B2
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1332:  MOVLW  04
1334:  SUBWF  xC2,W
1336:  MOVWF  xCA
1338:  MOVLW  00
133A:  SUBWFB xC3,W
133C:  MOVWF  xCB
133E:  MOVF   xC0,W
1340:  ADDWF  xCA,W
1342:  MOVWF  FE9
1344:  MOVF   xC1,W
1346:  ADDWFC xCB,W
1348:  MOVWF  FEA
134A:  MOVFF  FEF,9CC
134E:  MOVLW  03
1350:  SUBWF  xC2,W
1352:  MOVWF  xCD
1354:  MOVLW  00
1356:  SUBWFB xC3,W
1358:  MOVWF  xCE
135A:  MOVF   xC0,W
135C:  ADDWF  xCD,W
135E:  MOVWF  FE9
1360:  MOVF   xC1,W
1362:  ADDWFC xCE,W
1364:  MOVWF  FEA
1366:  MOVFF  FEF,9CF
136A:  MOVLW  02
136C:  SUBWF  xC2,W
136E:  MOVWF  xD0
1370:  MOVLW  00
1372:  SUBWFB xC3,W
1374:  MOVWF  xD1
1376:  MOVF   xC0,W
1378:  ADDWF  xD0,W
137A:  MOVWF  FE9
137C:  MOVF   xC1,W
137E:  ADDWFC xD1,W
1380:  MOVWF  FEA
1382:  MOVFF  FEF,9D2
1386:  MOVLW  01
1388:  SUBWF  xC2,W
138A:  MOVWF  xD3
138C:  MOVLW  00
138E:  SUBWFB xC3,W
1390:  MOVWF  xD4
1392:  MOVF   xC0,W
1394:  ADDWF  xD3,W
1396:  MOVWF  FE9
1398:  MOVF   xC1,W
139A:  ADDWFC xD4,W
139C:  MOVWF  FEA
139E:  MOVFF  FEF,9D5
13A2:  MOVF   xC0,W
13A4:  ADDWF  xC2,W
13A6:  MOVWF  FE9
13A8:  MOVF   xC1,W
13AA:  ADDWFC xC3,W
13AC:  MOVWF  FEA
13AE:  MOVFF  FEF,9D6
13B2:  CLRF   xDF
13B4:  CLRF   xE0
13B6:  CLRF   xE1
13B8:  MOVFF  9CC,9E2
13BC:  MOVFF  9CF,9E3
13C0:  MOVFF  9D2,9E4
13C4:  MOVFF  9D5,9E5
13C8:  MOVFF  9D6,9E6
13CC:  MOVLB  0
13CE:  CALL   066E
13D2:  MOVFF  01,9C6
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
13D6:  MOVLW  09
13D8:  MOVLB  9
13DA:  SUBWF  xC2,W
13DC:  MOVWF  xCA
13DE:  MOVLW  00
13E0:  SUBWFB xC3,W
13E2:  MOVWF  xCB
13E4:  MOVF   xC0,W
13E6:  ADDWF  xCA,W
13E8:  MOVWF  FE9
13EA:  MOVF   xC1,W
13EC:  ADDWFC xCB,W
13EE:  MOVWF  FEA
13F0:  MOVFF  FEF,9CC
13F4:  MOVLW  08
13F6:  SUBWF  xC2,W
13F8:  MOVWF  xCD
13FA:  MOVLW  00
13FC:  SUBWFB xC3,W
13FE:  MOVWF  xCE
1400:  MOVF   xC0,W
1402:  ADDWF  xCD,W
1404:  MOVWF  FE9
1406:  MOVF   xC1,W
1408:  ADDWFC xCE,W
140A:  MOVWF  FEA
140C:  MOVFF  FEF,9CF
1410:  MOVLW  07
1412:  SUBWF  xC2,W
1414:  MOVWF  xD0
1416:  MOVLW  00
1418:  SUBWFB xC3,W
141A:  MOVWF  xD1
141C:  MOVF   xC0,W
141E:  ADDWF  xD0,W
1420:  MOVWF  FE9
1422:  MOVF   xC1,W
1424:  ADDWFC xD1,W
1426:  MOVWF  FEA
1428:  MOVFF  FEF,9D2
142C:  MOVLW  06
142E:  SUBWF  xC2,W
1430:  MOVWF  xD3
1432:  MOVLW  00
1434:  SUBWFB xC3,W
1436:  MOVWF  xD4
1438:  MOVF   xC0,W
143A:  ADDWF  xD3,W
143C:  MOVWF  FE9
143E:  MOVF   xC1,W
1440:  ADDWFC xD4,W
1442:  MOVWF  FEA
1444:  MOVFF  FEF,9D5
1448:  MOVLW  05
144A:  SUBWF  xC2,W
144C:  MOVWF  xD6
144E:  MOVLW  00
1450:  SUBWFB xC3,W
1452:  MOVWF  xD7
1454:  MOVF   xC0,W
1456:  ADDWF  xD6,W
1458:  MOVWF  FE9
145A:  MOVF   xC1,W
145C:  ADDWFC xD7,W
145E:  MOVWF  FEA
1460:  MOVFF  FEF,9D8
1464:  CLRF   xDF
1466:  CLRF   xE0
1468:  CLRF   xE1
146A:  MOVFF  9CC,9E2
146E:  MOVFF  9CF,9E3
1472:  MOVFF  9D2,9E4
1476:  MOVFF  9D5,9E5
147A:  MOVFF  9D8,9E6
147E:  MOVLB  0
1480:  CALL   066E
1484:  MOVFF  01,9C7
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
1488:  MOVLB  9
148A:  MOVF   xC6,W
148C:  SUBLW  0B
148E:  BTFSS  FD8.2
1490:  BRA    15B2
1492:  MOVF   xC7,W
1494:  SUBLW  1F
1496:  BTFSC  FD8.2
1498:  BRA    15B2
149A:  MOVF   xC7,W
149C:  SUBLW  0F
149E:  BTFSC  FD8.2
14A0:  BRA    15B2
....................             { 
....................                j=i; 
14A2:  MOVFF  9C3,9C5
14A6:  MOVFF  9C2,9C4
....................                CRC=1; 
14AA:  MOVLW  01
14AC:  MOVWF  xC9
....................                temp2=temp; 
14AE:  MOVFF  9C6,9C8
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
14B2:  MOVF   xC8,W
14B4:  SUBLW  1F
14B6:  BZ    1592
14B8:  MOVF   xC5,F
14BA:  BNZ   14C2
14BC:  MOVF   xC4,W
14BE:  SUBLW  01
14C0:  BC    1592
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
14C2:  MOVLW  01
14C4:  MOVWF  xCA
14C6:  MOVFF  9C5,9CC
14CA:  MOVFF  9C4,9CB
14CE:  MOVFF  9C1,9CE
14D2:  MOVFF  9C0,9CD
14D6:  MOVLB  0
14D8:  CALL   0884
14DC:  MOVF   01,W
14DE:  MOVLB  9
14E0:  ANDWF  xC9,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
14E2:  MOVLW  04
14E4:  SUBWF  xC4,W
14E6:  MOVWF  xCA
14E8:  MOVLW  00
14EA:  SUBWFB xC5,W
14EC:  MOVWF  xCB
14EE:  MOVF   xC0,W
14F0:  ADDWF  xCA,W
14F2:  MOVWF  FE9
14F4:  MOVF   xC1,W
14F6:  ADDWFC xCB,W
14F8:  MOVWF  FEA
14FA:  MOVFF  FEF,9CC
14FE:  MOVLW  03
1500:  SUBWF  xC4,W
1502:  MOVWF  xCD
1504:  MOVLW  00
1506:  SUBWFB xC5,W
1508:  MOVWF  xCE
150A:  MOVF   xC0,W
150C:  ADDWF  xCD,W
150E:  MOVWF  FE9
1510:  MOVF   xC1,W
1512:  ADDWFC xCE,W
1514:  MOVWF  FEA
1516:  MOVFF  FEF,9CF
151A:  MOVLW  02
151C:  SUBWF  xC4,W
151E:  MOVWF  xD0
1520:  MOVLW  00
1522:  SUBWFB xC5,W
1524:  MOVWF  xD1
1526:  MOVF   xC0,W
1528:  ADDWF  xD0,W
152A:  MOVWF  FE9
152C:  MOVF   xC1,W
152E:  ADDWFC xD1,W
1530:  MOVWF  FEA
1532:  MOVFF  FEF,9D2
1536:  MOVLW  01
1538:  SUBWF  xC4,W
153A:  MOVWF  xD3
153C:  MOVLW  00
153E:  SUBWFB xC5,W
1540:  MOVWF  xD4
1542:  MOVF   xC0,W
1544:  ADDWF  xD3,W
1546:  MOVWF  FE9
1548:  MOVF   xC1,W
154A:  ADDWFC xD4,W
154C:  MOVWF  FEA
154E:  MOVFF  FEF,9D5
1552:  MOVF   xC0,W
1554:  ADDWF  xC4,W
1556:  MOVWF  FE9
1558:  MOVF   xC1,W
155A:  ADDWFC xC5,W
155C:  MOVWF  FEA
155E:  MOVFF  FEF,9D6
1562:  CLRF   xDF
1564:  CLRF   xE0
1566:  CLRF   xE1
1568:  MOVFF  9CC,9E2
156C:  MOVFF  9CF,9E3
1570:  MOVFF  9D2,9E4
1574:  MOVFF  9D5,9E5
1578:  MOVFF  9D6,9E6
157C:  MOVLB  0
157E:  CALL   066E
1582:  MOVFF  01,9C8
....................                   j=j-5; 
1586:  MOVLW  05
1588:  MOVLB  9
158A:  SUBWF  xC4,F
158C:  MOVLW  00
158E:  SUBWFB xC5,F
....................                } 
1590:  BRA    14B2
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
1592:  DECFSZ xC9,W
1594:  BRA    15AA
....................                { 
....................                   dir=1; 
1596:  MOVLW  01
1598:  MOVLB  8
159A:  MOVWF  x5B
....................                   return i; 
159C:  MOVLB  9
159E:  MOVFF  9C2,01
15A2:  MOVFF  9C3,02
15A6:  BRA    15C2
....................                } 
....................                   else return 0; 
15A8:  BRA    15B2
15AA:  MOVLW  00
15AC:  MOVWF  01
15AE:  MOVWF  02
15B0:  BRA    15C2
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
15B2:  MOVF   xC2,W
15B4:  BTFSC  FD8.2
15B6:  DECF   xC3,F
15B8:  DECF   xC2,F
15BA:  BRA    0FB4
....................    return 0; 
15BC:  MOVLW  00
15BE:  MOVWF  01
15C0:  MOVWF  02
.................... } 
15C2:  MOVLB  0
15C4:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
2F84:  MOVLB  9
2F86:  CLRF   xBC
2F88:  MOVLW  01
2F8A:  MOVWF  xBB
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
2F8C:  MOVFF  9B1,9BD
2F90:  MOVFF  9B3,9BF
2F94:  MOVFF  9B2,9BE
2F98:  MOVFF  9B5,9C1
2F9C:  MOVFF  9B4,9C0
2FA0:  MOVLB  0
2FA2:  CALL   09C4
2FA6:  MOVFF  02,9BC
2FAA:  MOVFF  01,9BB
....................    if(temp==0) return 0; 
2FAE:  MOVLB  9
2FB0:  MOVF   xBB,F
2FB2:  BNZ   2FBE
2FB4:  MOVF   xBC,F
2FB6:  BNZ   2FBE
2FB8:  MOVLW  00
2FBA:  MOVWF  01
2FBC:  BRA    3368
....................    j=temp; 
2FBE:  MOVFF  9BC,9BA
2FC2:  MOVFF  9BB,9B9
....................    if(dir==0) 
2FC6:  MOVLB  8
2FC8:  MOVF   x5B,F
2FCA:  BTFSS  FD8.2
2FCC:  BRA    3188
....................    { 
....................       if(track==0) 
2FCE:  MOVLB  9
2FD0:  MOVF   xB1,F
2FD2:  BTFSS  FD8.2
2FD4:  BRA    30CC
....................       { 
....................             for(i=0;i<79;i++) 
2FD6:  CLRF   xB8
2FD8:  MOVF   xB8,W
2FDA:  SUBLW  4E
2FDC:  BNC   30CA
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
2FDE:  CLRF   03
2FE0:  MOVF   xB8,W
2FE2:  ADDWF  xB6,W
2FE4:  MOVWF  01
2FE6:  MOVF   xB7,W
2FE8:  ADDWFC 03,F
2FEA:  MOVFF  01,9BD
2FEE:  MOVFF  03,9BE
2FF2:  MOVLW  05
2FF4:  ADDWF  xB9,W
2FF6:  MOVWF  xBF
2FF8:  MOVLW  00
2FFA:  ADDWFC xBA,W
2FFC:  MOVWF  xC0
2FFE:  MOVF   xB4,W
3000:  ADDWF  xBF,W
3002:  MOVWF  FE9
3004:  MOVF   xB5,W
3006:  ADDWFC xC0,W
3008:  MOVWF  FEA
300A:  MOVFF  FEF,9C1
300E:  MOVLW  04
3010:  ADDWF  xB9,W
3012:  MOVWF  xC2
3014:  MOVLW  00
3016:  ADDWFC xBA,W
3018:  MOVWF  xC3
301A:  MOVF   xB4,W
301C:  ADDWF  xC2,W
301E:  MOVWF  FE9
3020:  MOVF   xB5,W
3022:  ADDWFC xC3,W
3024:  MOVWF  FEA
3026:  MOVFF  FEF,9C4
302A:  MOVLW  03
302C:  ADDWF  xB9,W
302E:  MOVWF  xC5
3030:  MOVLW  00
3032:  ADDWFC xBA,W
3034:  MOVWF  xC6
3036:  MOVF   xB4,W
3038:  ADDWF  xC5,W
303A:  MOVWF  FE9
303C:  MOVF   xB5,W
303E:  ADDWFC xC6,W
3040:  MOVWF  FEA
3042:  MOVFF  FEF,9C7
3046:  MOVLW  02
3048:  ADDWF  xB9,W
304A:  MOVWF  xC8
304C:  MOVLW  00
304E:  ADDWFC xBA,W
3050:  MOVWF  xC9
3052:  MOVF   xB4,W
3054:  ADDWF  xC8,W
3056:  MOVWF  FE9
3058:  MOVF   xB5,W
305A:  ADDWFC xC9,W
305C:  MOVWF  FEA
305E:  MOVFF  FEF,9CA
3062:  MOVLW  01
3064:  ADDWF  xB9,W
3066:  MOVWF  xCB
3068:  MOVLW  00
306A:  ADDWFC xBA,W
306C:  MOVWF  xCC
306E:  MOVF   xB4,W
3070:  ADDWF  xCB,W
3072:  MOVWF  FE9
3074:  MOVF   xB5,W
3076:  ADDWFC xCC,W
3078:  MOVWF  FEA
307A:  MOVFF  FEF,9CD
307E:  MOVF   xB4,W
3080:  ADDWF  xB9,W
3082:  MOVWF  FE9
3084:  MOVF   xB5,W
3086:  ADDWFC xBA,W
3088:  MOVWF  FEA
308A:  MOVFF  FEF,9CE
308E:  CLRF   xDF
3090:  CLRF   xE0
3092:  MOVFF  9C1,9E1
3096:  MOVFF  9C4,9E2
309A:  MOVFF  9C7,9E3
309E:  MOVFF  9CA,9E4
30A2:  MOVFF  9CD,9E5
30A6:  MOVFF  9CE,9E6
30AA:  MOVLB  0
30AC:  CALL   066E
30B0:  MOVFF  9BE,FEA
30B4:  MOVFF  9BD,FE9
30B8:  MOVFF  01,FEF
....................                j=j+7; 
30BC:  MOVLW  07
30BE:  MOVLB  9
30C0:  ADDWF  xB9,F
30C2:  MOVLW  00
30C4:  ADDWFC xBA,F
....................             } 
30C6:  INCF   xB8,F
30C8:  BRA    2FD8
....................       } 
....................          else  
30CA:  BRA    3184
....................          { 
....................             for(i=0;i<40;i++) 
30CC:  CLRF   xB8
30CE:  MOVF   xB8,W
30D0:  SUBLW  27
30D2:  BNC   3184
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
30D4:  CLRF   03
30D6:  MOVF   xB8,W
30D8:  ADDWF  xB6,W
30DA:  MOVWF  01
30DC:  MOVF   xB7,W
30DE:  ADDWFC 03,F
30E0:  MOVFF  01,9BD
30E4:  MOVFF  03,9BE
30E8:  MOVLW  03
30EA:  ADDWF  xB9,W
30EC:  MOVWF  xBF
30EE:  MOVLW  00
30F0:  ADDWFC xBA,W
30F2:  MOVWF  xC0
30F4:  MOVF   xB4,W
30F6:  ADDWF  xBF,W
30F8:  MOVWF  FE9
30FA:  MOVF   xB5,W
30FC:  ADDWFC xC0,W
30FE:  MOVWF  FEA
3100:  MOVFF  FEF,9C1
3104:  MOVLW  02
3106:  ADDWF  xB9,W
3108:  MOVWF  xC2
310A:  MOVLW  00
310C:  ADDWFC xBA,W
310E:  MOVWF  xC3
3110:  MOVF   xB4,W
3112:  ADDWF  xC2,W
3114:  MOVWF  FE9
3116:  MOVF   xB5,W
3118:  ADDWFC xC3,W
311A:  MOVWF  FEA
311C:  MOVFF  FEF,9C4
3120:  MOVLW  01
3122:  ADDWF  xB9,W
3124:  MOVWF  xC5
3126:  MOVLW  00
3128:  ADDWFC xBA,W
312A:  MOVWF  xC6
312C:  MOVF   xB4,W
312E:  ADDWF  xC5,W
3130:  MOVWF  FE9
3132:  MOVF   xB5,W
3134:  ADDWFC xC6,W
3136:  MOVWF  FEA
3138:  MOVFF  FEF,9C7
313C:  MOVF   xB4,W
313E:  ADDWF  xB9,W
3140:  MOVWF  FE9
3142:  MOVF   xB5,W
3144:  ADDWFC xBA,W
3146:  MOVWF  FEA
3148:  MOVFF  FEF,9C8
314C:  CLRF   xDF
314E:  CLRF   xE0
3150:  CLRF   xE1
3152:  CLRF   xE2
3154:  MOVFF  9C1,9E3
3158:  MOVFF  9C4,9E4
315C:  MOVFF  9C7,9E5
3160:  MOVFF  9C8,9E6
3164:  MOVLB  0
3166:  CALL   066E
316A:  MOVFF  9BE,FEA
316E:  MOVFF  9BD,FE9
3172:  MOVFF  01,FEF
....................                j=j+5; 
3176:  MOVLW  05
3178:  MOVLB  9
317A:  ADDWF  xB9,F
317C:  MOVLW  00
317E:  ADDWFC xBA,F
....................             }          
3180:  INCF   xB8,F
3182:  BRA    30CE
....................          } 
....................    } 
....................       else  
3184:  BRA    333E
3186:  MOVLB  8
....................       { 
....................          if(track==0) 
3188:  MOVLB  9
318A:  MOVF   xB1,F
318C:  BTFSS  FD8.2
318E:  BRA    3286
....................          { 
....................             for(i=0;i<79;i++) 
3190:  CLRF   xB8
3192:  MOVF   xB8,W
3194:  SUBLW  4E
3196:  BNC   3284
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3198:  CLRF   03
319A:  MOVF   xB8,W
319C:  ADDWF  xB6,W
319E:  MOVWF  01
31A0:  MOVF   xB7,W
31A2:  ADDWFC 03,F
31A4:  MOVFF  01,9BD
31A8:  MOVFF  03,9BE
31AC:  MOVLW  05
31AE:  SUBWF  xB9,W
31B0:  MOVWF  xBF
31B2:  MOVLW  00
31B4:  SUBWFB xBA,W
31B6:  MOVWF  xC0
31B8:  MOVF   xB4,W
31BA:  ADDWF  xBF,W
31BC:  MOVWF  FE9
31BE:  MOVF   xB5,W
31C0:  ADDWFC xC0,W
31C2:  MOVWF  FEA
31C4:  MOVFF  FEF,9C1
31C8:  MOVLW  04
31CA:  SUBWF  xB9,W
31CC:  MOVWF  xC2
31CE:  MOVLW  00
31D0:  SUBWFB xBA,W
31D2:  MOVWF  xC3
31D4:  MOVF   xB4,W
31D6:  ADDWF  xC2,W
31D8:  MOVWF  FE9
31DA:  MOVF   xB5,W
31DC:  ADDWFC xC3,W
31DE:  MOVWF  FEA
31E0:  MOVFF  FEF,9C4
31E4:  MOVLW  03
31E6:  SUBWF  xB9,W
31E8:  MOVWF  xC5
31EA:  MOVLW  00
31EC:  SUBWFB xBA,W
31EE:  MOVWF  xC6
31F0:  MOVF   xB4,W
31F2:  ADDWF  xC5,W
31F4:  MOVWF  FE9
31F6:  MOVF   xB5,W
31F8:  ADDWFC xC6,W
31FA:  MOVWF  FEA
31FC:  MOVFF  FEF,9C7
3200:  MOVLW  02
3202:  SUBWF  xB9,W
3204:  MOVWF  xC8
3206:  MOVLW  00
3208:  SUBWFB xBA,W
320A:  MOVWF  xC9
320C:  MOVF   xB4,W
320E:  ADDWF  xC8,W
3210:  MOVWF  FE9
3212:  MOVF   xB5,W
3214:  ADDWFC xC9,W
3216:  MOVWF  FEA
3218:  MOVFF  FEF,9CA
321C:  MOVLW  01
321E:  SUBWF  xB9,W
3220:  MOVWF  xCB
3222:  MOVLW  00
3224:  SUBWFB xBA,W
3226:  MOVWF  xCC
3228:  MOVF   xB4,W
322A:  ADDWF  xCB,W
322C:  MOVWF  FE9
322E:  MOVF   xB5,W
3230:  ADDWFC xCC,W
3232:  MOVWF  FEA
3234:  MOVFF  FEF,9CD
3238:  MOVF   xB4,W
323A:  ADDWF  xB9,W
323C:  MOVWF  FE9
323E:  MOVF   xB5,W
3240:  ADDWFC xBA,W
3242:  MOVWF  FEA
3244:  MOVFF  FEF,9CE
3248:  CLRF   xDF
324A:  CLRF   xE0
324C:  MOVFF  9C1,9E1
3250:  MOVFF  9C4,9E2
3254:  MOVFF  9C7,9E3
3258:  MOVFF  9CA,9E4
325C:  MOVFF  9CD,9E5
3260:  MOVFF  9CE,9E6
3264:  MOVLB  0
3266:  CALL   066E
326A:  MOVFF  9BE,FEA
326E:  MOVFF  9BD,FE9
3272:  MOVFF  01,FEF
....................                j=j-7; 
3276:  MOVLW  07
3278:  MOVLB  9
327A:  SUBWF  xB9,F
327C:  MOVLW  00
327E:  SUBWFB xBA,F
....................             } 
3280:  INCF   xB8,F
3282:  BRA    3192
....................          } 
....................             else 
3284:  BRA    333E
....................             { 
....................                for(i=0;i<40;i++) 
3286:  CLRF   xB8
3288:  MOVF   xB8,W
328A:  SUBLW  27
328C:  BNC   333E
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
328E:  CLRF   03
3290:  MOVF   xB8,W
3292:  ADDWF  xB6,W
3294:  MOVWF  01
3296:  MOVF   xB7,W
3298:  ADDWFC 03,F
329A:  MOVFF  01,9BD
329E:  MOVFF  03,9BE
32A2:  MOVLW  03
32A4:  SUBWF  xB9,W
32A6:  MOVWF  xBF
32A8:  MOVLW  00
32AA:  SUBWFB xBA,W
32AC:  MOVWF  xC0
32AE:  MOVF   xB4,W
32B0:  ADDWF  xBF,W
32B2:  MOVWF  FE9
32B4:  MOVF   xB5,W
32B6:  ADDWFC xC0,W
32B8:  MOVWF  FEA
32BA:  MOVFF  FEF,9C1
32BE:  MOVLW  02
32C0:  SUBWF  xB9,W
32C2:  MOVWF  xC2
32C4:  MOVLW  00
32C6:  SUBWFB xBA,W
32C8:  MOVWF  xC3
32CA:  MOVF   xB4,W
32CC:  ADDWF  xC2,W
32CE:  MOVWF  FE9
32D0:  MOVF   xB5,W
32D2:  ADDWFC xC3,W
32D4:  MOVWF  FEA
32D6:  MOVFF  FEF,9C4
32DA:  MOVLW  01
32DC:  SUBWF  xB9,W
32DE:  MOVWF  xC5
32E0:  MOVLW  00
32E2:  SUBWFB xBA,W
32E4:  MOVWF  xC6
32E6:  MOVF   xB4,W
32E8:  ADDWF  xC5,W
32EA:  MOVWF  FE9
32EC:  MOVF   xB5,W
32EE:  ADDWFC xC6,W
32F0:  MOVWF  FEA
32F2:  MOVFF  FEF,9C7
32F6:  MOVF   xB4,W
32F8:  ADDWF  xB9,W
32FA:  MOVWF  FE9
32FC:  MOVF   xB5,W
32FE:  ADDWFC xBA,W
3300:  MOVWF  FEA
3302:  MOVFF  FEF,9C8
3306:  CLRF   xDF
3308:  CLRF   xE0
330A:  CLRF   xE1
330C:  CLRF   xE2
330E:  MOVFF  9C1,9E3
3312:  MOVFF  9C4,9E4
3316:  MOVFF  9C7,9E5
331A:  MOVFF  9C8,9E6
331E:  MOVLB  0
3320:  CALL   066E
3324:  MOVFF  9BE,FEA
3328:  MOVFF  9BD,FE9
332C:  MOVFF  01,FEF
....................                   j=j-5; 
3330:  MOVLW  05
3332:  MOVLB  9
3334:  SUBWF  xB9,F
3336:  MOVLW  00
3338:  SUBWFB xBA,F
....................                }             
333A:  INCF   xB8,F
333C:  BRA    3288
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
333E:  MOVF   xB1,F
3340:  BNZ   3356
3342:  MOVLW  52
3344:  MOVWF  xBD
3346:  MOVFF  9B5,9BF
334A:  MOVFF  9B4,9BE
334E:  MOVLB  0
3350:  RCALL  2F62
....................          else del_buf(numbyteofbuffer2,datin); 
3352:  BRA    3366
3354:  MOVLB  9
3356:  MOVLW  2C
3358:  MOVWF  xBD
335A:  MOVFF  9B5,9BF
335E:  MOVFF  9B4,9BE
3362:  MOVLB  0
3364:  RCALL  2F62
3366:  MOVLB  9
.................... } 
3368:  MOVLB  0
336A:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
179E:  MOVLW  1E
17A0:  MOVWF  FF6
17A2:  MOVLW  05
17A4:  MOVWF  FF7
17A6:  CALL   064E
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
17AA:  MOVLB  8
17AC:  CLRF   xFB
17AE:  CLRF   xFA
17B0:  MOVF   xFB,W
17B2:  SUBLW  03
17B4:  BNC   17E6
17B6:  BNZ   17BE
17B8:  MOVF   xFA,W
17BA:  SUBLW  51
17BC:  BNC   17E6
17BE:  MOVLW  D9
17C0:  ADDWF  xFA,W
17C2:  MOVWF  FE9
17C4:  MOVLW  03
17C6:  ADDWFC xFB,W
17C8:  MOVWF  FEA
17CA:  MOVFF  FEF,8FC
17CE:  MOVFF  8FC,9B1
17D2:  MOVLW  18
17D4:  MOVLB  9
17D6:  MOVWF  xB2
17D8:  MOVLB  0
17DA:  RCALL  16DA
17DC:  MOVLB  8
17DE:  INCF   xFA,F
17E0:  BTFSC  FD8.2
17E2:  INCF   xFB,F
17E4:  BRA    17B0
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
17E6:  MOVLW  34
17E8:  MOVWF  FF6
17EA:  MOVLW  05
17EC:  MOVWF  FF7
17EE:  MOVLB  0
17F0:  CALL   064E
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
17F4:  MOVLB  8
17F6:  CLRF   xFB
17F8:  CLRF   xFA
17FA:  MOVF   xFB,W
17FC:  SUBLW  01
17FE:  BNC   1830
1800:  BNZ   1808
1802:  MOVF   xFA,W
1804:  SUBLW  2B
1806:  BNC   1830
1808:  MOVLW  2B
180A:  ADDWF  xFA,W
180C:  MOVWF  FE9
180E:  MOVLW  07
1810:  ADDWFC xFB,W
1812:  MOVWF  FEA
1814:  MOVFF  FEF,8FC
1818:  MOVFF  8FC,9B1
181C:  MOVLW  18
181E:  MOVLB  9
1820:  MOVWF  xB2
1822:  MOVLB  0
1824:  RCALL  16DA
1826:  MOVLB  8
1828:  INCF   xFA,F
182A:  BTFSC  FD8.2
182C:  INCF   xFB,F
182E:  BRA    17FA
.................... } 
1830:  MOVLB  0
1832:  GOTO   1AA2 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
34F0:  MOVLW  01
34F2:  MOVLB  8
34F4:  MOVWF  x6B
....................    rtc_get_date(date,mon,year,day); 
....................    rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
*
359E:  RCALL  2EF0
35A0:  MOVFF  02,9B2
35A4:  MOVFF  01,9B1
35A8:  MOVFF  02,9B4
35AC:  MOVFF  01,9B3
35B0:  MOVLB  9
35B2:  CLRF   xB6
35B4:  MOVLW  7C
35B6:  MOVWF  xB5
35B8:  MOVLB  0
35BA:  RCALL  2F40
35BC:  MOVFF  01,9B1
35C0:  MOVLW  96
35C2:  MOVLB  9
35C4:  ADDWF  01,W
35C6:  MOVWF  01
35C8:  MOVLW  00
35CA:  ADDWFC 02,W
35CC:  MOVFF  01,20
35D0:  MOVWF  21
35D2:  CLRF   22
35D4:  CLRF   23
....................    if(datinbuf==0)  
35D6:  MOVLB  8
35D8:  MOVF   x68,F
35DA:  BNZ   35FC
....................    { 
....................       countbit_T1=0; 
35DC:  CLRF   x5D
35DE:  CLRF   x5C
....................       countbit_T2=0; 
35E0:  CLRF   x5F
35E2:  CLRF   x5E
....................       bug_countbit_T1=0; 
35E4:  CLRF   x61
35E6:  CLRF   x60
....................       bug_countbit_T2=0; 
35E8:  CLRF   x63
35EA:  CLRF   x62
....................       if(data_avai==0)charac_timeout=0xffffffff; 
35EC:  MOVF   x6C,F
35EE:  BNZ   35F8
35F0:  MOVLB  0
35F2:  SETF   xFC
35F4:  SETF   xFB
35F6:  MOVLB  8
....................       saving_flag=0; 
35F8:  CLRF   x6B
....................       return; 
35FA:  BRA    3962
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
35FC:  MOVLW  4A
35FE:  MOVWF  FF6
3600:  MOVLW  05
3602:  MOVWF  FF7
3604:  MOVLB  0
3606:  CALL   064E
....................    key_timeout=0; 
360A:  MOVLB  1
360C:  CLRF   x06
360E:  CLRF   x05
....................    //key_count=0; 
....................    enable_getpin=1; 
3610:  MOVLW  01
3612:  MOVWF  x09
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3614:  MOVFF  85D,9B0
3618:  MOVFF  85C,9AF
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
361C:  MOVLB  9
361E:  CLRF   xB1
3620:  MOVFF  9B0,9B3
3624:  MOVFF  9AF,9B2
3628:  MOVLW  03
362A:  MOVWF  xB5
362C:  MOVLW  D9
362E:  MOVWF  xB4
3630:  MOVLW  03
3632:  MOVWF  xB7
3634:  MOVLW  62
3636:  MOVWF  xB6
3638:  MOVLB  0
363A:  RCALL  2F84
....................    countbit_T1=0; 
363C:  MOVLB  8
363E:  CLRF   x5D
3640:  CLRF   x5C
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
3642:  MOVFF  85F,9B0
3646:  MOVFF  85E,9AF
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
364A:  MOVLW  01
364C:  MOVLB  9
364E:  MOVWF  xB1
3650:  MOVFF  9B0,9B3
3654:  MOVFF  9AF,9B2
3658:  MOVLW  07
365A:  MOVWF  xB5
365C:  MOVLW  2B
365E:  MOVWF  xB4
3660:  MOVLW  03
3662:  MOVWF  xB7
3664:  MOVLW  B1
3666:  MOVWF  xB6
3668:  MOVLB  0
366A:  RCALL  2F84
....................    countbit_T2=0; 
366C:  MOVLB  8
366E:  CLRF   x5F
3670:  CLRF   x5E
....................    saving_flag=0; 
3672:  CLRF   x6B
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3674:  MOVLW  20
3676:  MOVLB  3
3678:  ADDWF  x62,W
367A:  MOVLB  9
367C:  MOVWF  xAE
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
367E:  MOVF   23,F
3680:  BTFSS  FD8.2
3682:  BRA    3960
3684:  MOVF   22,F
3686:  BTFSS  FD8.2
3688:  BRA    3960
368A:  MOVF   21,W
368C:  SUBLW  AA
368E:  BTFSS  FD8.0
3690:  BRA    3960
3692:  BNZ   369C
3694:  MOVF   20,W
3696:  SUBLW  45
3698:  BTFSS  FD8.0
369A:  BRA    3960
369C:  MOVF   xAE,W
369E:  SUBLW  25
36A0:  BTFSS  FD8.2
36A2:  BRA    3960
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
36A4:  MOVFF  23,03
36A8:  MOVFF  22,02
36AC:  MOVFF  21,01
36B0:  MOVFF  20,00
36B4:  MOVLW  01
36B6:  ADDWF  20,F
36B8:  BTFSC  FD8.0
36BA:  INCF   21,F
36BC:  BTFSC  FD8.2
36BE:  INCF   22,F
36C0:  BTFSC  FD8.2
36C2:  INCF   23,F
36C4:  MOVFF  01,9B2
36C8:  MOVFF  00,9B1
36CC:  MOVFF  01,9C0
36D0:  MOVFF  00,9BF
36D4:  MOVFF  100,9C1
36D8:  MOVLB  0
36DA:  RCALL  336C
....................          write_ext_eeprom((long int)ptr_card++,mon); 
36DC:  MOVFF  23,03
36E0:  MOVFF  22,02
36E4:  MOVFF  21,01
36E8:  MOVFF  20,00
36EC:  MOVLW  01
36EE:  ADDWF  20,F
36F0:  BTFSC  FD8.0
36F2:  INCF   21,F
36F4:  BTFSC  FD8.2
36F6:  INCF   22,F
36F8:  BTFSC  FD8.2
36FA:  INCF   23,F
36FC:  MOVFF  01,9B2
3700:  MOVFF  00,9B1
3704:  MOVFF  01,9C0
3708:  MOVFF  00,9BF
370C:  MOVFF  FF,9C1
3710:  RCALL  336C
....................          write_ext_eeprom((long int)ptr_card++,h); 
3712:  MOVFF  23,03
3716:  MOVFF  22,02
371A:  MOVFF  21,01
371E:  MOVFF  20,00
3722:  MOVLW  01
3724:  ADDWF  20,F
3726:  BTFSC  FD8.0
3728:  INCF   21,F
372A:  BTFSC  FD8.2
372C:  INCF   22,F
372E:  BTFSC  FD8.2
3730:  INCF   23,F
3732:  MOVFF  01,9B2
3736:  MOVFF  00,9B1
373A:  MOVFF  01,9C0
373E:  MOVFF  00,9BF
3742:  MOVFF  101,9C1
3746:  RCALL  336C
....................          write_ext_eeprom((long int)ptr_card++,min); 
3748:  MOVFF  23,03
374C:  MOVFF  22,02
3750:  MOVFF  21,01
3754:  MOVFF  20,00
3758:  MOVLW  01
375A:  ADDWF  20,F
375C:  BTFSC  FD8.0
375E:  INCF   21,F
3760:  BTFSC  FD8.2
3762:  INCF   22,F
3764:  BTFSC  FD8.2
3766:  INCF   23,F
3768:  MOVFF  01,9B2
376C:  MOVFF  00,9B1
3770:  MOVFF  01,9C0
3774:  MOVFF  00,9BF
3778:  MOVFF  102,9C1
377C:  RCALL  336C
....................          write_ext_eeprom((long int)ptr_card++,sec);           
377E:  MOVFF  23,03
3782:  MOVFF  22,02
3786:  MOVFF  21,01
378A:  MOVFF  20,00
378E:  MOVLW  01
3790:  ADDWF  20,F
3792:  BTFSC  FD8.0
3794:  INCF   21,F
3796:  BTFSC  FD8.2
3798:  INCF   22,F
379A:  BTFSC  FD8.2
379C:  INCF   23,F
379E:  MOVFF  01,9B2
37A2:  MOVFF  00,9B1
37A6:  MOVFF  01,9C0
37AA:  MOVFF  00,9BF
37AE:  MOVFF  103,9C1
37B2:  RCALL  336C
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
37B4:  MOVLB  8
37B6:  CLRF   x67
37B8:  CLRF   x66
37BA:  MOVF   x67,F
37BC:  BNZ   381A
37BE:  MOVF   x66,W
37C0:  SUBLW  4E
37C2:  BNC   381A
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
37C4:  MOVFF  23,03
37C8:  MOVFF  22,02
37CC:  MOVFF  21,01
37D0:  MOVFF  20,00
37D4:  MOVLW  01
37D6:  ADDWF  20,F
37D8:  BTFSC  FD8.0
37DA:  INCF   21,F
37DC:  BTFSC  FD8.2
37DE:  INCF   22,F
37E0:  BTFSC  FD8.2
37E2:  INCF   23,F
37E4:  MOVFF  01,9B2
37E8:  MOVFF  00,9B1
37EC:  MOVLW  62
37EE:  ADDWF  x66,W
37F0:  MOVWF  FE9
37F2:  MOVLW  03
37F4:  ADDWFC x67,W
37F6:  MOVWF  FEA
37F8:  MOVF   FEF,W
37FA:  ANDLW  3F
37FC:  ADDLW  20
37FE:  MOVLB  9
3800:  MOVWF  xB3
3802:  MOVFF  01,9C0
3806:  MOVFF  00,9BF
380A:  MOVWF  xC1
380C:  MOVLB  0
380E:  RCALL  336C
....................              
....................          } 
3810:  MOVLB  8
3812:  INCF   x66,F
3814:  BTFSC  FD8.2
3816:  INCF   x67,F
3818:  BRA    37BA
....................          del_buf(numbyteoftrack1,Track1); 
381A:  MOVLW  4F
381C:  MOVLB  9
381E:  MOVWF  xBD
3820:  MOVLW  03
3822:  MOVWF  xBF
3824:  MOVLW  62
3826:  MOVWF  xBE
3828:  MOVLB  0
382A:  CALL   2F62
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
382E:  MOVLB  8
3830:  CLRF   x67
3832:  CLRF   x66
3834:  MOVF   x67,F
3836:  BNZ   3894
3838:  MOVF   x66,W
383A:  SUBLW  27
383C:  BNC   3894
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
383E:  MOVFF  23,03
3842:  MOVFF  22,02
3846:  MOVFF  21,01
384A:  MOVFF  20,00
384E:  MOVLW  01
3850:  ADDWF  20,F
3852:  BTFSC  FD8.0
3854:  INCF   21,F
3856:  BTFSC  FD8.2
3858:  INCF   22,F
385A:  BTFSC  FD8.2
385C:  INCF   23,F
385E:  MOVFF  01,9B2
3862:  MOVFF  00,9B1
3866:  MOVLW  B1
3868:  ADDWF  x66,W
386A:  MOVWF  FE9
386C:  MOVLW  03
386E:  ADDWFC x67,W
3870:  MOVWF  FEA
3872:  MOVF   FEF,W
3874:  ANDLW  0F
3876:  ADDLW  30
3878:  MOVLB  9
387A:  MOVWF  xB3
387C:  MOVFF  01,9C0
3880:  MOVFF  00,9BF
3884:  MOVWF  xC1
3886:  MOVLB  0
3888:  RCALL  336C
....................          }  
388A:  MOVLB  8
388C:  INCF   x66,F
388E:  BTFSC  FD8.2
3890:  INCF   x67,F
3892:  BRA    3834
....................          del_buf(numbyteoftrack2,Track2); 
3894:  MOVLW  28
3896:  MOVLB  9
3898:  MOVWF  xBD
389A:  MOVLW  03
389C:  MOVWF  xBF
389E:  MOVLW  B1
38A0:  MOVWF  xBE
38A2:  MOVLB  0
38A4:  CALL   2F62
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
38A8:  MOVLW  0D
38AA:  MOVLB  9
38AC:  MOVWF  xD3
38AE:  MOVLB  0
38B0:  CALL   0608
38B4:  MOVLW  0A
38B6:  MOVLB  9
38B8:  MOVWF  xD3
38BA:  MOVLB  0
38BC:  CALL   0608
....................       fprintf(COM2,"Done"); 
38C0:  MOVLW  60
38C2:  MOVWF  FF6
38C4:  MOVLW  05
38C6:  MOVWF  FF7
38C8:  CALL   064E
....................       if(KP_mode) 
38CC:  MOVLB  1
38CE:  MOVF   x0C,F
38D0:  BZ    38E8
....................       { 
....................          printf("\n\rKey release\n\r"); 
38D2:  MOVLW  66
38D4:  MOVWF  FF6
38D6:  MOVLW  05
38D8:  MOVWF  FF7
38DA:  MOVLB  0
38DC:  CALL   064E
....................          keyprss_off; 
38E0:  BCF    F92.7
38E2:  BCF    F89.7
....................          kp_st=0; 
38E4:  MOVLB  1
38E6:  CLRF   x0D
....................       }   
....................       count_kp=0xffff; 
38E8:  SETF   x0F
38EA:  SETF   x0E
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
38EC:  MOVLW  0D
38EE:  MOVLB  9
38F0:  MOVWF  xD3
38F2:  MOVLB  0
38F4:  CALL   0608
38F8:  MOVLW  0A
38FA:  MOVLB  9
38FC:  MOVWF  xD3
38FE:  MOVLB  0
3900:  CALL   0608
....................       fprintf(COM2,"Waiting for PIN number"); 
3904:  MOVLW  76
3906:  MOVWF  FF6
3908:  MOVLW  05
390A:  MOVWF  FF7
390C:  CALL   064E
....................       fprintf(COM2,"\r\n"); 
3910:  MOVLW  0D
3912:  MOVLB  9
3914:  MOVWF  xD3
3916:  MOVLB  0
3918:  CALL   0608
391C:  MOVLW  0A
391E:  MOVLB  9
3920:  MOVWF  xD3
3922:  MOVLB  0
3924:  CALL   0608
....................       charac_timeout=0; 
3928:  CLRF   xFC
392A:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
392C:  MOVFF  23,9B4
3930:  MOVFF  22,9B3
3934:  MOVFF  21,9B2
3938:  MOVFF  20,9B1
393C:  MOVLW  19
393E:  MOVLB  9
3940:  MOVWF  xB5
3942:  MOVLB  0
3944:  RCALL  3472
....................       datinbuf=0; 
3946:  MOVLB  8
3948:  CLRF   x68
....................       saving_flag=0; 
394A:  CLRF   x6B
....................       data_avai=1; 
394C:  MOVLW  01
394E:  MOVWF  x6C
....................       enable_getpin=1; 
3950:  MOVLB  1
3952:  MOVWF  x09
....................       charac_timeout=0; 
3954:  MOVLB  0
3956:  CLRF   xFC
3958:  CLRF   xFB
....................       key_count_ms=0; 
395A:  MOVLB  1
395C:  CLRF   x0B
395E:  MOVLB  9
3960:  MOVLB  8
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3962:  MOVLB  0
3964:  GOTO   488C (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
185E:  MOVLW  01
1860:  MOVLB  8
1862:  MOVWF  xF1
1864:  MOVWF  xF2
1866:  MOVWF  xF3
1868:  MOVWF  xF4
186A:  CLRF   xF5
186C:  MOVWF  xF6
186E:  MOVWF  xF7
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1870:  CLRF   x65
1872:  CLRF   x64
....................    mcr_timeout=0; 
1874:  CLRF   x5A
1876:  CLRF   x59
1878:  CLRF   x58
187A:  CLRF   x57
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
187C:  MOVF   x65,W
187E:  SUBLW  FD
1880:  BNC   189E
1882:  BNZ   188A
1884:  MOVF   x64,W
1886:  SUBLW  E7
1888:  BNC   189E
188A:  BSF    F93.1
188C:  BTFSS  F81.1
188E:  BRA    189E
1890:  BSF    F94.5
1892:  BTFSS  F82.5
1894:  BRA    189E
....................       card_timeout++; 
1896:  INCF   x64,F
1898:  BTFSC  FD8.2
189A:  INCF   x65,F
....................    } 
189C:  BRA    187C
....................    card_timeout=0; 
189E:  CLRF   x65
18A0:  CLRF   x64
....................    buffertrack1[bug_countbit_T1++]=0; 
18A2:  MOVFF  861,03
18A6:  MOVF   x60,W
18A8:  INCF   x60,F
18AA:  BTFSC  FD8.2
18AC:  INCF   x61,F
18AE:  MOVWF  xFA
18B0:  MOVLW  D9
18B2:  ADDWF  xFA,W
18B4:  MOVWF  FE9
18B6:  MOVLW  03
18B8:  ADDWFC 03,W
18BA:  MOVWF  FEA
18BC:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
18BE:  MOVFF  861,03
18C2:  MOVF   x60,W
18C4:  INCF   x60,F
18C6:  BTFSC  FD8.2
18C8:  INCF   x61,F
18CA:  MOVWF  xFA
18CC:  MOVLW  D9
18CE:  ADDWF  xFA,W
18D0:  MOVWF  FE9
18D2:  MOVLW  03
18D4:  ADDWFC 03,W
18D6:  MOVWF  FEA
18D8:  MOVLW  01
18DA:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
18DC:  MOVFF  863,03
18E0:  MOVF   x62,W
18E2:  INCF   x62,F
18E4:  BTFSC  FD8.2
18E6:  INCF   x63,F
18E8:  MOVWF  xFA
18EA:  MOVLW  2B
18EC:  ADDWF  xFA,W
18EE:  MOVWF  FE9
18F0:  MOVLW  07
18F2:  ADDWFC 03,W
18F4:  MOVWF  FEA
18F6:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
18F8:  MOVFF  863,03
18FC:  MOVF   x62,W
18FE:  INCF   x62,F
1900:  BTFSC  FD8.2
1902:  INCF   x63,F
1904:  MOVWF  xFA
1906:  MOVLW  2B
1908:  ADDWF  xFA,W
190A:  MOVWF  FE9
190C:  MOVLW  07
190E:  ADDWFC 03,W
1910:  MOVWF  FEA
1912:  MOVLW  01
1914:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1916:  MOVF   x61,W
1918:  SUBLW  03
191A:  BTFSS  FD8.0
191C:  BRA    19E8
191E:  BNZ   1926
1920:  MOVF   x60,W
1922:  SUBLW  51
1924:  BNC   19E8
1926:  MOVF   x63,W
1928:  SUBLW  01
192A:  BNC   19E8
192C:  BNZ   1934
192E:  MOVF   x62,W
1930:  SUBLW  2B
1932:  BNC   19E8
1934:  MOVF   x65,W
1936:  SUBLW  FF
1938:  BNC   19E8
193A:  BNZ   1942
193C:  MOVF   x64,W
193E:  SUBLW  DB
1940:  BNC   19E8
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
1942:  MOVF   x6E,F
1944:  BZ    194E
....................          { 
....................             bug_countbit_T1=0; 
1946:  CLRF   x61
1948:  CLRF   x60
....................             bug_countbit_T2=0; 
194A:  CLRF   x63
194C:  CLRF   x62
....................          } 
....................          card_timeout++; 
194E:  INCF   x64,F
1950:  BTFSC  FD8.2
1952:  INCF   x65,F
....................          mcr_timeout=0; 
1954:  CLRF   x5A
1956:  CLRF   x59
1958:  CLRF   x58
195A:  CLRF   x57
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
195C:  BSF    F93.2
195E:  CLRF   xF1
1960:  BTFSC  F81.2
1962:  INCF   xF1,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1964:  MOVF   xF1,F
1966:  BNZ   19A0
1968:  DECFSZ xF2,W
196A:  BRA    19A0
....................          { 
....................             ST1_old = 0; 
196C:  CLRF   xF2
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
196E:  MOVLW  D9
1970:  ADDWF  x60,W
1972:  MOVWF  FE9
1974:  MOVLW  03
1976:  ADDWFC x61,W
1978:  MOVWF  FEA
197A:  BSF    F93.1
197C:  MOVLW  00
197E:  BTFSS  F81.1
1980:  MOVLW  01
1982:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1984:  MOVLW  2B
1986:  ADDWF  x62,W
1988:  MOVWF  FE9
198A:  MOVLW  07
198C:  ADDWFC x63,W
198E:  MOVWF  FEA
1990:  MOVFF  8F5,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1994:  INCF   x60,F
1996:  BTFSC  FD8.2
1998:  INCF   x61,F
....................             card_timeout=0; 
199A:  CLRF   x65
199C:  CLRF   x64
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
199E:  BRA    19A8
19A0:  DECFSZ xF1,W
19A2:  BRA    19A8
19A4:  MOVLW  01
19A6:  MOVWF  xF2
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
19A8:  BSF    F93.3
19AA:  CLRF   xF3
19AC:  BTFSC  F81.3
19AE:  INCF   xF3,F
....................          if(ST2 == 0 && ST2_old == 1) 
19B0:  MOVF   xF3,F
19B2:  BNZ   19CE
19B4:  DECFSZ xF4,W
19B6:  BRA    19CE
....................          { 
....................             ST2_old = 0; 
19B8:  CLRF   xF4
....................             Bit_t2 = !input(MCR_DATA2); 
19BA:  BSF    F94.5
19BC:  CLRF   xF5
19BE:  BTFSS  F82.5
19C0:  INCF   xF5,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
19C2:  INCF   x62,F
19C4:  BTFSC  FD8.2
19C6:  INCF   x63,F
....................             card_timeout=0; 
19C8:  CLRF   x65
19CA:  CLRF   x64
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
19CC:  BRA    19D6
19CE:  DECFSZ xF3,W
19D0:  BRA    19D6
19D2:  MOVLW  01
19D4:  MOVWF  xF4
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
19D6:  BSF    F93.0
19D8:  BTFSS  F81.0
19DA:  BRA    19E6
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
19DC:  CLRF   x6E
....................             card_timeout=65500; 
19DE:  SETF   x65
19E0:  MOVLW  DC
19E2:  MOVWF  x64
....................             break;            
19E4:  BRA    19E8
....................          } 
....................       } 
19E6:  BRA    1916
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
19E8:  CLRF   x65
19EA:  CLRF   x64
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
19EC:  MOVLB  9
19EE:  CLRF   xBD
19F0:  MOVFF  861,9BF
19F4:  MOVFF  860,9BE
19F8:  MOVLW  03
19FA:  MOVWF  xC1
19FC:  MOVLW  D9
19FE:  MOVWF  xC0
1A00:  MOVLB  0
1A02:  CALL   09C4
1A06:  MOVFF  01,8F6
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1A0A:  MOVLW  01
1A0C:  MOVLB  9
1A0E:  MOVWF  xBD
1A10:  MOVFF  863,9BF
1A14:  MOVFF  862,9BE
1A18:  MOVLW  07
1A1A:  MOVWF  xC1
1A1C:  MOVLW  2B
1A1E:  MOVWF  xC0
1A20:  MOVLB  0
1A22:  CALL   09C4
1A26:  MOVFF  01,8F7
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1A2A:  MOVLB  8
1A2C:  DECFSZ x69,W
1A2E:  BRA    1ACE
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1A30:  MOVLW  8E
1A32:  MOVWF  FF6
1A34:  MOVLW  05
1A36:  MOVWF  FF7
1A38:  MOVLW  0E
1A3A:  MOVLB  9
1A3C:  MOVWF  xC7
1A3E:  MOVLB  0
1A40:  RCALL  15C6
1A42:  MOVLW  10
1A44:  MOVWF  FE9
1A46:  MOVFF  861,9AF
1A4A:  MOVFF  860,9AE
1A4E:  RCALL  15F0
1A50:  MOVLW  0D
1A52:  MOVLB  9
1A54:  MOVWF  xD3
1A56:  MOVLB  0
1A58:  CALL   0608
1A5C:  MOVLW  0A
1A5E:  MOVLB  9
1A60:  MOVWF  xD3
1A62:  MOVLB  0
1A64:  CALL   0608
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1A68:  MOVLW  A2
1A6A:  MOVWF  FF6
1A6C:  MOVLW  05
1A6E:  MOVWF  FF7
1A70:  MOVLW  0E
1A72:  MOVLB  9
1A74:  MOVWF  xC7
1A76:  MOVLB  0
1A78:  RCALL  15C6
1A7A:  MOVLW  10
1A7C:  MOVWF  FE9
1A7E:  MOVFF  863,9AF
1A82:  MOVFF  862,9AE
1A86:  RCALL  15F0
1A88:  MOVLW  0D
1A8A:  MOVLB  9
1A8C:  MOVWF  xD3
1A8E:  MOVLB  0
1A90:  CALL   0608
1A94:  MOVLW  0A
1A96:  MOVLB  9
1A98:  MOVWF  xD3
1A9A:  MOVLB  0
1A9C:  CALL   0608
....................          debug_reader();       
1AA0:  BRA    179E
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1AA2:  MOVLB  8
1AA4:  MOVF   xF6,F
1AA6:  BNZ   1AB8
1AA8:  MOVLW  B6
1AAA:  MOVWF  FF6
1AAC:  MOVLW  05
1AAE:  MOVWF  FF7
1AB0:  MOVLB  0
1AB2:  CALL   064E
1AB6:  MOVLB  8
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1AB8:  MOVF   xF7,F
1ABA:  BNZ   1ACC
1ABC:  MOVLW  CC
1ABE:  MOVWF  FF6
1AC0:  MOVLW  05
1AC2:  MOVWF  FF7
1AC4:  MOVLB  0
1AC6:  CALL   064E
1ACA:  MOVLB  8
....................       } 
....................          else 
1ACC:  BRA    1AD8
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1ACE:  MOVLW  0F
1AD0:  MOVWF  xFA
1AD2:  MOVLB  0
1AD4:  RCALL  1836
1AD6:  MOVLB  8
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1AD8:  MOVF   xF6,F
1ADA:  BZ    1AE0
1ADC:  MOVF   xF7,F
1ADE:  BNZ   1AFC
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1AE0:  CLRF   x63
1AE2:  CLRF   x62
....................          bug_countbit_T1=0; 
1AE4:  CLRF   x61
1AE6:  CLRF   x60
....................          reading_fg=0; 
1AE8:  CLRF   x6D
....................          count_reading_error++; 
1AEA:  INCF   x6E,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1AEC:  CLRF   x5A
1AEE:  CLRF   x59
1AF0:  CLRF   x58
1AF2:  CLRF   x57
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1AF4:  MOVLW  00
1AF6:  MOVWF  01
1AF8:  BRA    1B32
....................       } 
....................          else  
1AFA:  BRA    1B2E
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1AFC:  MOVLW  01
1AFE:  MOVWF  x68
....................             reading_fg=1; 
1B00:  MOVWF  x6D
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1B02:  MOVFF  863,85F
1B06:  MOVFF  862,85E
....................             countbit_T1=bug_countbit_T1; 
1B0A:  MOVFF  861,85D
1B0E:  MOVFF  860,85C
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1B12:  CLRF   x61
1B14:  CLRF   x60
....................             bug_countbit_T2=0;  
1B16:  CLRF   x63
1B18:  CLRF   x62
....................             mcr_timeout=0; 
1B1A:  CLRF   x5A
1B1C:  CLRF   x59
1B1E:  CLRF   x58
1B20:  CLRF   x57
....................             charac_timeout=0; 
1B22:  MOVLB  0
1B24:  CLRF   xFC
1B26:  CLRF   xFB
....................             return 1; 
1B28:  MOVWF  01
1B2A:  MOVLB  8
1B2C:  BRA    1B32
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1B2E:  MOVLW  00
1B30:  MOVWF  01
.................... } 
1B32:  MOVLB  0
1B34:  GOTO   1B9A (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
1B38:  MOVLW  02
1B3A:  MOVLB  8
1B3C:  MOVWF  xF1
1B3E:  MOVLW  FA
1B40:  MOVWF  xF2
1B42:  MOVLB  0
1B44:  GOTO   05E2
1B48:  MOVLB  8
1B4A:  DECFSZ xF1,F
1B4C:  BRA    1B3E
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
1B4E:  DECFSZ x6B,W
1B50:  BRA    1B54
1B52:  BRA    1BAC
....................       if((KP_mode)&&(enable_getpin==0)) 
1B54:  MOVLB  1
1B56:  MOVF   x0C,F
1B58:  BZ    1B96
1B5A:  MOVF   x09,F
1B5C:  BNZ   1B96
....................       { 
....................          if(kp_st==1) 
1B5E:  DECFSZ x0D,W
1B60:  BRA    1B7A
....................          { 
....................             printf("\n\rKey release\n\r"); 
1B62:  MOVLW  B4
1B64:  MOVWF  FF6
1B66:  MOVLW  1B
1B68:  MOVWF  FF7
1B6A:  MOVLB  0
1B6C:  CALL   064E
....................             keyprss_off; 
1B70:  BCF    F92.7
1B72:  BCF    F89.7
....................             kp_st=0; 
1B74:  MOVLB  1
1B76:  CLRF   x0D
....................          } 
....................          else 
1B78:  BRA    1B96
....................          { 
....................             printf("\n\rKey press\n\r"); 
1B7A:  MOVLW  C4
1B7C:  MOVWF  FF6
1B7E:  MOVLW  1B
1B80:  MOVWF  FF7
1B82:  MOVLB  0
1B84:  CALL   064E
....................             keyprss_on; 
1B88:  BCF    F92.7
1B8A:  BSF    F89.7
....................             kp_st=1;  
1B8C:  MOVLW  01
1B8E:  MOVLB  1
1B90:  MOVWF  x0D
....................             count_kp=0; 
1B92:  CLRF   x0F
1B94:  CLRF   x0E
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1B96:  MOVLB  0
1B98:  BRA    185E
1B9A:  MOVFF  01,86A
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1B9E:  MOVLB  8
1BA0:  CLRF   x5A
1BA2:  CLRF   x59
1BA4:  CLRF   x58
1BA6:  CLRF   x57
....................       card_timeout=0; 
1BA8:  CLRF   x65
1BAA:  CLRF   x64
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1BAC:  BCF    FF0.0
1BAE:  MOVLB  0
1BB0:  GOTO   0084
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
61C2:  CLRF   19
61C4:  BTFSC  FF2.7
61C6:  BSF    19.7
61C8:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
61CA:  MOVLB  9
61CC:  CLRF   xC0
61CE:  MOVLW  94
61D0:  MOVWF  xBF
61D2:  MOVLW  03
61D4:  MOVWF  xC1
61D6:  MOVLB  0
61D8:  CALL   336C
61DC:  BTFSC  19.7
61DE:  BSF    FF2.7
61E0:  CLRF   19
61E2:  BTFSC  FF2.7
61E4:  BSF    19.7
61E6:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaykb,100); 
61E8:  MOVLB  9
61EA:  CLRF   xC0
61EC:  MOVLW  95
61EE:  MOVWF  xBF
61F0:  MOVLW  64
61F2:  MOVWF  xC1
61F4:  MOVLB  0
61F6:  CALL   336C
61FA:  BTFSC  19.7
61FC:  BSF    FF2.7
61FE:  CLRF   19
6200:  BTFSC  FF2.7
6202:  BSF    19.7
6204:  BCF    FF2.7
....................    write_ext_eeprom(KB_time,2); 
6206:  MOVLB  9
6208:  CLRF   xC0
620A:  MOVLW  7E
620C:  MOVWF  xBF
620E:  MOVLW  02
6210:  MOVWF  xC1
6212:  MOVLB  0
6214:  CALL   336C
6218:  BTFSC  19.7
621A:  BSF    FF2.7
621C:  CLRF   19
621E:  BTFSC  FF2.7
6220:  BSF    19.7
6222:  BCF    FF2.7
....................    write_ext_eeprom(strobe_Master_SLV,1);    
6224:  MOVLB  9
6226:  CLRF   xC0
6228:  MOVLW  91
622A:  MOVWF  xBF
622C:  MOVLW  01
622E:  MOVWF  xC1
6230:  MOVLB  0
6232:  CALL   336C
6236:  BTFSC  19.7
6238:  BSF    FF2.7
623A:  CLRF   19
623C:  BTFSC  FF2.7
623E:  BSF    19.7
6240:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6242:  MOVLB  9
6244:  CLRF   xBD
6246:  MOVLW  91
6248:  MOVWF  xBC
624A:  MOVLB  0
624C:  CALL   2E48
6250:  BTFSC  19.7
6252:  BSF    FF2.7
6254:  MOVFF  01,875
6258:  CLRF   19
625A:  BTFSC  FF2.7
625C:  BSF    19.7
625E:  BCF    FF2.7
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
6260:  MOVLB  9
6262:  CLRF   xC0
6264:  MOVLW  93
6266:  MOVWF  xBF
6268:  CLRF   xC1
626A:  MOVLB  0
626C:  CALL   336C
6270:  BTFSC  19.7
6272:  BSF    FF2.7
6274:  CLRF   19
6276:  BTFSC  FF2.7
6278:  BSF    19.7
627A:  BCF    FF2.7
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
627C:  MOVLB  9
627E:  CLRF   xBD
6280:  MOVLW  93
6282:  MOVWF  xBC
6284:  MOVLB  0
6286:  CALL   2E48
628A:  BTFSC  19.7
628C:  BSF    FF2.7
628E:  MOVFF  01,360
....................    #endif 
....................     
.................... } 
6292:  GOTO   6B9C (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
6540:  MOVLW  08
6542:  MOVWF  FEA
6544:  MOVLW  7A
6546:  MOVWF  FE9
6548:  BRA    5F3C
654A:  CLRF   19
654C:  BTFSC  FF2.7
654E:  BSF    19.7
6550:  BCF    FF2.7
6552:  MOVLW  3E
6554:  MOVLB  9
6556:  MOVWF  xD3
6558:  MOVLB  0
655A:  CALL   0608
655E:  BTFSC  19.7
6560:  BSF    FF2.7
....................       #if defined(SIM900) 
....................          SIM_state=config; 
6562:  MOVLW  0A
6564:  MOVLB  3
6566:  MOVWF  x5C
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
6568:  MOVLW  01
656A:  MOVLB  8
656C:  MOVWF  xCD
656E:  MOVLW  14
6570:  MOVWF  xCE
6572:  MOVLW  01
6574:  MOVWF  xD0
6576:  MOVLW  4A
6578:  MOVWF  xCF
657A:  MOVLB  0
657C:  RCALL  5E04
657E:  CLRF   19
6580:  BTFSC  FF2.7
6582:  BSF    19.7
6584:  BCF    FF2.7
....................       printf("\n\r"); 
6586:  MOVLW  0A
6588:  MOVLB  9
658A:  MOVWF  xD3
658C:  MOVLB  0
658E:  CALL   0608
6592:  BTFSC  19.7
6594:  BSF    FF2.7
6596:  CLRF   19
6598:  BTFSC  FF2.7
659A:  BSF    19.7
659C:  BCF    FF2.7
659E:  MOVLW  0D
65A0:  MOVLB  9
65A2:  MOVWF  xD3
65A4:  MOVLB  0
65A6:  CALL   0608
65AA:  BTFSC  19.7
65AC:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
65AE:  CLRF   FEA
65B0:  MOVLW  41
65B2:  MOVWF  FE9
65B4:  MOVLW  00
65B6:  CALL   010C
65BA:  TBLRD*-
65BC:  TBLRD*+
65BE:  MOVF   FF5,W
65C0:  MOVWF  FEE
65C2:  IORLW  00
65C4:  BNZ   65BC
....................       index=0; 
65C6:  MOVLB  8
65C8:  CLRF   x97
....................       ee_dat=0; 
65CA:  CLRF   x70
....................       count_card=1; 
65CC:  CLRF   x72
65CE:  MOVLW  01
65D0:  MOVWF  x71
65D2:  CLRF   19
65D4:  BTFSC  FF2.7
65D6:  BSF    19.7
65D8:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
65DA:  MOVLW  01
65DC:  MOVLB  9
65DE:  MOVWF  xAF
65E0:  MOVLW  4A
65E2:  MOVWF  xAE
65E4:  CLRF   xB1
65E6:  MOVLW  41
65E8:  MOVWF  xB0
65EA:  MOVLB  0
65EC:  CALL   3DC4
65F0:  BTFSC  19.7
65F2:  BSF    FF2.7
65F4:  MOVF   01,F
65F6:  BTFSS  FD8.2
65F8:  BRA    6972
....................       { 
....................          unsigned long adr=0; 
65FA:  MOVLB  8
65FC:  CLRF   xCC
65FE:  CLRF   xCB
....................          //unsigned int count=0; 
....................          rec[0]=0; 
6600:  MOVLB  0
6602:  CLRF   x7D
6604:  CLRF   19
6606:  BTFSC  FF2.7
6608:  BSF    19.7
660A:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
660C:  CALL   2EF0
6610:  BTFSC  19.7
6612:  BSF    FF2.7
6614:  MOVFF  02,874
6618:  MOVFF  01,873
661C:  CLRF   19
661E:  BTFSC  FF2.7
6620:  BSF    19.7
6622:  BCF    FF2.7
....................          adr=count_card*numdata; 
6624:  MOVFF  872,9B4
6628:  MOVFF  871,9B3
662C:  MOVLB  9
662E:  CLRF   xB6
6630:  MOVLW  7C
6632:  MOVWF  xB5
6634:  MOVLB  0
6636:  CALL   2F40
663A:  BTFSC  19.7
663C:  BSF    FF2.7
663E:  MOVFF  02,8CC
6642:  MOVFF  01,8CB
....................          addr_key=EEPROM_KEY_ST; 
6646:  MOVLB  8
6648:  CLRF   x79
664A:  CLRF   x78
664C:  MOVLW  AA
664E:  MOVWF  x77
6650:  MOVLW  47
6652:  MOVWF  x76
....................          while(count_card<=count_card_tg) 
....................          { 
6654:  MOVF   x72,W
6656:  SUBWF  x74,W
6658:  BTFSS  FD8.0
665A:  BRA    6970
665C:  BNZ   6666
665E:  MOVF   x71,W
6660:  SUBWF  x73,W
6662:  BTFSS  FD8.0
6664:  BRA    6970
6666:  CLRF   19
6668:  BTFSC  FF2.7
666A:  BSF    19.7
666C:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
666E:  MOVFF  872,9B4
6672:  MOVFF  871,9B3
6676:  MOVLB  9
6678:  CLRF   xB6
667A:  MOVLW  7C
667C:  MOVWF  xB5
667E:  MOVLB  0
6680:  CALL   2F40
6684:  BTFSC  19.7
6686:  BSF    FF2.7
6688:  MOVLW  96
668A:  MOVLB  8
668C:  ADDWF  01,W
668E:  MOVWF  xCB
6690:  MOVLW  00
6692:  ADDWFC 02,W
6694:  MOVWF  xCC
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
6696:  MOVLW  7C
6698:  SUBWF  xCB,W
669A:  MOVWF  xCD
669C:  MOVLW  00
669E:  SUBWFB xCC,W
66A0:  MOVWF  xCE
66A2:  CLRF   19
66A4:  BTFSC  FF2.7
66A6:  BSF    19.7
66A8:  BCF    FF2.7
66AA:  MOVFF  FE8,9B1
66AE:  MOVFF  8CD,9B0
66B2:  MOVLB  9
66B4:  CLRF   xB3
66B6:  MOVLW  7C
66B8:  MOVWF  xB2
66BA:  CLRF   xB5
66BC:  MOVLW  7D
66BE:  MOVWF  xB4
66C0:  MOVLB  0
66C2:  CALL   45F4
66C6:  BTFSC  19.7
66C8:  BSF    FF2.7
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
66CA:  MOVLW  10
66CC:  MOVWF  FE9
66CE:  MOVFF  872,8CE
66D2:  MOVFF  871,8CD
66D6:  BRA    5F70
66D8:  CLRF   19
66DA:  BTFSC  FF2.7
66DC:  BSF    19.7
66DE:  BCF    FF2.7
66E0:  MOVLW  29
66E2:  MOVLB  9
66E4:  MOVWF  xD3
66E6:  MOVLB  0
66E8:  CALL   0608
66EC:  BTFSC  19.7
66EE:  BSF    FF2.7
66F0:  MOVFF  7D,8CD
66F4:  MOVLW  01
66F6:  MOVLB  8
66F8:  MOVWF  xCE
66FA:  MOVLB  0
66FC:  RCALL  6074
66FE:  CLRF   19
6700:  BTFSC  FF2.7
6702:  BSF    19.7
6704:  BCF    FF2.7
6706:  MOVLW  2F
6708:  MOVLB  9
670A:  MOVWF  xD3
670C:  MOVLB  0
670E:  CALL   0608
6712:  BTFSC  19.7
6714:  BSF    FF2.7
6716:  MOVFF  7E,8CD
671A:  MOVLW  01
671C:  MOVLB  8
671E:  MOVWF  xCE
6720:  MOVLB  0
6722:  RCALL  6074
6724:  CLRF   19
6726:  BTFSC  FF2.7
6728:  BSF    19.7
672A:  BCF    FF2.7
672C:  MOVLW  20
672E:  MOVLB  9
6730:  MOVWF  xD3
6732:  MOVLB  0
6734:  CALL   0608
6738:  BTFSC  19.7
673A:  BSF    FF2.7
673C:  MOVFF  7F,8CD
6740:  MOVLW  01
6742:  MOVLB  8
6744:  MOVWF  xCE
6746:  MOVLB  0
6748:  RCALL  6074
674A:  CLRF   19
674C:  BTFSC  FF2.7
674E:  BSF    19.7
6750:  BCF    FF2.7
6752:  MOVLW  3A
6754:  MOVLB  9
6756:  MOVWF  xD3
6758:  MOVLB  0
675A:  CALL   0608
675E:  BTFSC  19.7
6760:  BSF    FF2.7
6762:  MOVFF  80,8CD
6766:  MOVLW  01
6768:  MOVLB  8
676A:  MOVWF  xCE
676C:  MOVLB  0
676E:  RCALL  6074
6770:  CLRF   19
6772:  BTFSC  FF2.7
6774:  BSF    19.7
6776:  BCF    FF2.7
6778:  MOVLW  3A
677A:  MOVLB  9
677C:  MOVWF  xD3
677E:  MOVLB  0
6780:  CALL   0608
6784:  BTFSC  19.7
6786:  BSF    FF2.7
6788:  MOVFF  81,8CD
678C:  MOVLW  01
678E:  MOVLB  8
6790:  MOVWF  xCE
6792:  MOVLB  0
6794:  RCALL  6074
....................             ee_dat=0; 
6796:  MOVLB  8
6798:  CLRF   x70
....................             index=0; 
679A:  CLRF   x97
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
679C:  MOVLW  F6
679E:  MOVWF  FF6
67A0:  MOVLW  1B
67A2:  MOVWF  FF7
67A4:  CLRF   19
67A6:  BTFSC  FF2.7
67A8:  BSF    19.7
67AA:  BCF    FF2.7
67AC:  MOVLB  0
67AE:  CALL   064E
67B2:  BTFSC  19.7
67B4:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
67B6:  MOVLB  8
67B8:  MOVF   x97,W
67BA:  SUBLW  4E
67BC:  BNC   6806
67BE:  MOVF   x70,W
67C0:  SUBLW  3F
67C2:  BZ    6806
....................                ee_dat = rec[index+5]; 
67C4:  MOVLW  05
67C6:  ADDWF  x97,W
67C8:  CLRF   03
67CA:  ADDLW  7D
67CC:  MOVWF  FE9
67CE:  MOVLW  00
67D0:  ADDWFC 03,W
67D2:  MOVWF  FEA
67D4:  MOVFF  FEF,870
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
67D8:  MOVF   x70,W
67DA:  SUBLW  1F
67DC:  BC    67FC
67DE:  MOVF   x70,W
67E0:  SUBLW  7E
67E2:  BNC   67FC
67E4:  CLRF   19
67E6:  BTFSC  FF2.7
67E8:  BSF    19.7
67EA:  BCF    FF2.7
67EC:  MOVFF  870,9D3
67F0:  MOVLB  0
67F2:  CALL   0608
67F6:  BTFSC  19.7
67F8:  BSF    FF2.7
67FA:  MOVLB  8
....................                index++; 
67FC:  INCF   x97,F
....................                if(ee_dat==0)break; 
67FE:  MOVF   x70,F
6800:  BNZ   6804
6802:  BRA    6806
....................             } 
6804:  BRA    67B8
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
6806:  MOVLW  08
6808:  MOVWF  FF6
680A:  MOVLW  1C
680C:  MOVWF  FF7
680E:  CLRF   19
6810:  BTFSC  FF2.7
6812:  BSF    19.7
6814:  BCF    FF2.7
6816:  MOVLB  0
6818:  CALL   064E
681C:  BTFSC  19.7
681E:  BSF    FF2.7
....................             index=0; 
6820:  MOVLB  8
6822:  CLRF   x97
....................             ee_dat=0; 
6824:  CLRF   x70
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
6826:  MOVF   x97,W
6828:  SUBLW  27
682A:  BNC   6876
682C:  MOVF   x70,W
682E:  SUBLW  3F
6830:  BZ    6876
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
6832:  MOVLW  05
6834:  ADDWF  x97,W
6836:  ADDLW  4F
6838:  CLRF   03
683A:  ADDLW  7D
683C:  MOVWF  FE9
683E:  MOVLW  00
6840:  ADDWFC 03,W
6842:  MOVWF  FEA
6844:  MOVFF  FEF,870
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
6848:  MOVF   x70,W
684A:  SUBLW  1F
684C:  BC    686C
684E:  MOVF   x70,W
6850:  SUBLW  7E
6852:  BNC   686C
6854:  CLRF   19
6856:  BTFSC  FF2.7
6858:  BSF    19.7
685A:  BCF    FF2.7
685C:  MOVFF  870,9D3
6860:  MOVLB  0
6862:  CALL   0608
6866:  BTFSC  19.7
6868:  BSF    FF2.7
686A:  MOVLB  8
....................                index++; 
686C:  INCF   x97,F
....................                if(ee_dat==0)break; 
686E:  MOVF   x70,F
6870:  BNZ   6874
6872:  BRA    6876
....................             } 
6874:  BRA    6826
....................             index=0; 
6876:  CLRF   x97
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
6878:  MOVLW  1A
687A:  MOVWF  FF6
687C:  MOVLW  1C
687E:  MOVWF  FF7
6880:  CLRF   19
6882:  BTFSC  FF2.7
6884:  BSF    19.7
6886:  BCF    FF2.7
6888:  MOVLB  0
688A:  CALL   064E
688E:  BTFSC  19.7
6890:  BSF    FF2.7
....................             if(ptr_card_key>addr_key) 
6892:  MOVLB  8
6894:  MOVF   x79,W
6896:  SUBWF  27,W
6898:  BTFSS  FD8.0
689A:  BRA    6968
689C:  BNZ   68B4
689E:  MOVF   x78,W
68A0:  SUBWF  26,W
68A2:  BNC   6968
68A4:  BNZ   68B4
68A6:  MOVF   x77,W
68A8:  SUBWF  25,W
68AA:  BNC   6968
68AC:  BNZ   68B4
68AE:  MOVF   24,W
68B0:  SUBWF  x76,W
68B2:  BC    6968
....................             { 
....................                i=0; 
68B4:  CLRF   x98
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
68B6:  MOVF   x98,W
68B8:  ADDWF  x76,W
68BA:  MOVWF  xCD
68BC:  MOVLW  00
68BE:  ADDWFC x77,W
68C0:  MOVWF  xCE
68C2:  CLRF   19
68C4:  BTFSC  FF2.7
68C6:  BSF    19.7
68C8:  BCF    FF2.7
68CA:  MOVFF  FE8,9BD
68CE:  MOVFF  8CD,9BC
68D2:  MOVLB  0
68D4:  CALL   2E48
68D8:  BTFSC  19.7
68DA:  BSF    FF2.7
68DC:  MOVFF  01,870
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<73)) 
68E0:  MOVLB  8
68E2:  MOVF   x70,W
68E4:  SUBLW  2F
68E6:  BC    68EE
68E8:  MOVF   x70,W
68EA:  SUBLW  39
68EC:  BC    6906
68EE:  MOVF   x70,W
68F0:  SUBLW  23
68F2:  BZ    6906
68F4:  MOVF   x70,W
68F6:  SUBLW  2A
68F8:  BZ    6906
68FA:  MOVF   x70,W
68FC:  SUBLW  40
68FE:  BC    691E
6900:  MOVF   x70,W
6902:  SUBLW  48
6904:  BNC   691E
6906:  CLRF   19
6908:  BTFSC  FF2.7
690A:  BSF    19.7
690C:  BCF    FF2.7
....................                      fputc(ee_dat,COM2); 
690E:  MOVFF  870,9D3
6912:  MOVLB  0
6914:  CALL   0608
6918:  BTFSC  19.7
691A:  BSF    FF2.7
691C:  MOVLB  8
....................                   i++; 
691E:  INCF   x98,F
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
6920:  MOVF   x98,W
6922:  SUBLW  31
6924:  BNC   692A
6926:  MOVF   x70,F
6928:  BNZ   68B6
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+50; 
692A:  MOVLW  32
692C:  ADDWF  x76,F
692E:  MOVLW  00
6930:  ADDWFC x77,F
6932:  ADDWFC x78,F
6934:  ADDWFC x79,F
6936:  CLRF   19
6938:  BTFSC  FF2.7
693A:  BSF    19.7
693C:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
693E:  MOVLW  0A
6940:  MOVLB  9
6942:  MOVWF  xD3
6944:  MOVLB  0
6946:  CALL   0608
694A:  BTFSC  19.7
694C:  BSF    FF2.7
694E:  CLRF   19
6950:  BTFSC  FF2.7
6952:  BSF    19.7
6954:  BCF    FF2.7
6956:  MOVLW  0D
6958:  MOVLB  9
695A:  MOVWF  xD3
695C:  MOVLB  0
695E:  CALL   0608
6962:  BTFSC  19.7
6964:  BSF    FF2.7
6966:  MOVLB  8
....................             } 
....................             count_card++; 
6968:  INCF   x71,F
696A:  BTFSC  FD8.2
696C:  INCF   x72,F
....................          } 
696E:  BRA    6654
6970:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
6972:  CLRF   FEA
6974:  MOVLW  41
6976:  MOVWF  FE9
6978:  MOVLW  00
697A:  CALL   011E
697E:  TBLRD*-
6980:  TBLRD*+
6982:  MOVF   FF5,W
6984:  MOVWF  FEE
6986:  IORLW  00
6988:  BNZ   6980
698A:  CLRF   19
698C:  BTFSC  FF2.7
698E:  BSF    19.7
6990:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6992:  MOVLW  01
6994:  MOVLB  9
6996:  MOVWF  xAF
6998:  MOVLW  4A
699A:  MOVWF  xAE
699C:  CLRF   xB1
699E:  MOVLW  41
69A0:  MOVWF  xB0
69A2:  MOVLB  0
69A4:  CALL   3DC4
69A8:  BTFSC  19.7
69AA:  BSF    FF2.7
69AC:  MOVF   01,F
69AE:  BNZ   69F0
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
69B0:  MOVLW  2A
69B2:  MOVWF  FF6
69B4:  MOVLW  1C
69B6:  MOVWF  FF7
69B8:  CLRF   19
69BA:  BTFSC  FF2.7
69BC:  BSF    19.7
69BE:  BCF    FF2.7
69C0:  CALL   064E
69C4:  BTFSC  19.7
69C6:  BSF    FF2.7
69C8:  CLRF   19
69CA:  BTFSC  FF2.7
69CC:  BSF    19.7
69CE:  BCF    FF2.7
....................          format_eepromext(); 
69D0:  CALL   3F76
69D4:  BTFSC  19.7
69D6:  BSF    FF2.7
....................          fprintf(COM2," exit\n\r");  
69D8:  MOVLW  38
69DA:  MOVWF  FF6
69DC:  MOVLW  1C
69DE:  MOVWF  FF7
69E0:  CLRF   19
69E2:  BTFSC  FF2.7
69E4:  BSF    19.7
69E6:  BCF    FF2.7
69E8:  CALL   064E
69EC:  BTFSC  19.7
69EE:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
69F0:  CLRF   FEA
69F2:  MOVLW  41
69F4:  MOVWF  FE9
69F6:  MOVLW  00
69F8:  CALL   0130
69FC:  TBLRD*-
69FE:  TBLRD*+
6A00:  MOVF   FF5,W
6A02:  MOVWF  FEE
6A04:  IORLW  00
6A06:  BNZ   69FE
6A08:  CLRF   19
6A0A:  BTFSC  FF2.7
6A0C:  BSF    19.7
6A0E:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6A10:  MOVLW  01
6A12:  MOVLB  9
6A14:  MOVWF  xAF
6A16:  MOVLW  4A
6A18:  MOVWF  xAE
6A1A:  CLRF   xB1
6A1C:  MOVLW  41
6A1E:  MOVWF  xB0
6A20:  MOVLB  0
6A22:  CALL   3DC4
6A26:  BTFSC  19.7
6A28:  BSF    FF2.7
6A2A:  MOVF   01,F
6A2C:  BNZ   6A6E
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
6A2E:  MOVLW  40
6A30:  MOVWF  FF6
6A32:  MOVLW  1C
6A34:  MOVWF  FF7
6A36:  CLRF   19
6A38:  BTFSC  FF2.7
6A3A:  BSF    19.7
6A3C:  BCF    FF2.7
6A3E:  CALL   064E
6A42:  BTFSC  19.7
6A44:  BSF    FF2.7
6A46:  CLRF   19
6A48:  BTFSC  FF2.7
6A4A:  BSF    19.7
6A4C:  BCF    FF2.7
....................          ease_eeprom(); 
6A4E:  CALL   3EF2
6A52:  BTFSC  19.7
6A54:  BSF    FF2.7
....................          fprintf(COM2," exit\n\r");  
6A56:  MOVLW  4E
6A58:  MOVWF  FF6
6A5A:  MOVLW  1C
6A5C:  MOVWF  FF7
6A5E:  CLRF   19
6A60:  BTFSC  FF2.7
6A62:  BSF    19.7
6A64:  BCF    FF2.7
6A66:  CALL   064E
6A6A:  BTFSC  19.7
6A6C:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
6A6E:  CLRF   FEA
6A70:  MOVLW  41
6A72:  MOVWF  FE9
6A74:  MOVLW  00
6A76:  CALL   0146
6A7A:  TBLRD*-
6A7C:  TBLRD*+
6A7E:  MOVF   FF5,W
6A80:  MOVWF  FEE
6A82:  IORLW  00
6A84:  BNZ   6A7C
6A86:  CLRF   19
6A88:  BTFSC  FF2.7
6A8A:  BSF    19.7
6A8C:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6A8E:  MOVLW  01
6A90:  MOVLB  9
6A92:  MOVWF  xAF
6A94:  MOVLW  4A
6A96:  MOVWF  xAE
6A98:  CLRF   xB1
6A9A:  MOVLW  41
6A9C:  MOVWF  xB0
6A9E:  MOVLB  0
6AA0:  CALL   3DC4
6AA4:  BTFSC  19.7
6AA6:  BSF    FF2.7
6AA8:  MOVF   01,F
6AAA:  BNZ   6AE4
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
6AAC:  MOVLW  56
6AAE:  MOVWF  FF6
6AB0:  MOVLW  1C
6AB2:  MOVWF  FF7
6AB4:  CLRF   19
6AB6:  BTFSC  FF2.7
6AB8:  BSF    19.7
6ABA:  BCF    FF2.7
6ABC:  CALL   064E
6AC0:  BTFSC  19.7
6AC2:  BSF    FF2.7
....................          reset_password(); 
6AC4:  GOTO   618E
....................          init_password(); 
6AC8:  CALL   5AE0
....................          fprintf(COM2," exit\n\r");  
6ACC:  MOVLW  6C
6ACE:  MOVWF  FF6
6AD0:  MOVLW  1C
6AD2:  MOVWF  FF7
6AD4:  CLRF   19
6AD6:  BTFSC  FF2.7
6AD8:  BSF    19.7
6ADA:  BCF    FF2.7
6ADC:  CALL   064E
6AE0:  BTFSC  19.7
6AE2:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
6AE4:  CLRF   FEA
6AE6:  MOVLW  41
6AE8:  MOVWF  FE9
6AEA:  MOVLW  00
6AEC:  CALL   015C
6AF0:  TBLRD*-
6AF2:  TBLRD*+
6AF4:  MOVF   FF5,W
6AF6:  MOVWF  FEE
6AF8:  IORLW  00
6AFA:  BNZ   6AF2
6AFC:  CLRF   19
6AFE:  BTFSC  FF2.7
6B00:  BSF    19.7
6B02:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6B04:  MOVLW  01
6B06:  MOVLB  9
6B08:  MOVWF  xAF
6B0A:  MOVLW  4A
6B0C:  MOVWF  xAE
6B0E:  CLRF   xB1
6B10:  MOVLW  41
6B12:  MOVWF  xB0
6B14:  MOVLB  0
6B16:  CALL   3DC4
6B1A:  BTFSC  19.7
6B1C:  BSF    FF2.7
6B1E:  MOVF   01,F
6B20:  BNZ   6B42
....................       { 
....................          keydebug_en=1; 
6B22:  MOVLW  01
6B24:  MOVLB  1
6B26:  MOVWF  x08
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
6B28:  MOVLW  74
6B2A:  MOVWF  FF6
6B2C:  MOVLW  1C
6B2E:  MOVWF  FF7
6B30:  CLRF   19
6B32:  BTFSC  FF2.7
6B34:  BSF    19.7
6B36:  BCF    FF2.7
6B38:  MOVLB  0
6B3A:  CALL   064E
6B3E:  BTFSC  19.7
6B40:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
6B42:  CLRF   FEA
6B44:  MOVLW  41
6B46:  MOVWF  FE9
6B48:  MOVLW  00
6B4A:  CALL   0172
6B4E:  TBLRD*-
6B50:  TBLRD*+
6B52:  MOVF   FF5,W
6B54:  MOVWF  FEE
6B56:  IORLW  00
6B58:  BNZ   6B50
6B5A:  CLRF   19
6B5C:  BTFSC  FF2.7
6B5E:  BSF    19.7
6B60:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6B62:  MOVLW  01
6B64:  MOVLB  9
6B66:  MOVWF  xAF
6B68:  MOVLW  4A
6B6A:  MOVWF  xAE
6B6C:  CLRF   xB1
6B6E:  MOVLW  41
6B70:  MOVWF  xB0
6B72:  MOVLB  0
6B74:  CALL   3DC4
6B78:  BTFSC  19.7
6B7A:  BSF    FF2.7
6B7C:  MOVF   01,F
6B7E:  BNZ   6B9C
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
6B80:  MOVLW  88
6B82:  MOVWF  FF6
6B84:  MOVLW  1C
6B86:  MOVWF  FF7
6B88:  CLRF   19
6B8A:  BTFSC  FF2.7
6B8C:  BSF    19.7
6B8E:  BCF    FF2.7
6B90:  CALL   064E
6B94:  BTFSC  19.7
6B96:  BSF    FF2.7
....................          rstfact(); 
6B98:  GOTO   61C2
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
6B9C:  CLRF   FEA
6B9E:  MOVLW  41
6BA0:  MOVWF  FE9
6BA2:  MOVLW  00
6BA4:  CALL   018A
6BA8:  TBLRD*-
6BAA:  TBLRD*+
6BAC:  MOVF   FF5,W
6BAE:  MOVWF  FEE
6BB0:  IORLW  00
6BB2:  BNZ   6BAA
6BB4:  CLRF   19
6BB6:  BTFSC  FF2.7
6BB8:  BSF    19.7
6BBA:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
6BBC:  MOVLW  01
6BBE:  MOVLB  9
6BC0:  MOVWF  xAF
6BC2:  MOVLW  4A
6BC4:  MOVWF  xAE
6BC6:  CLRF   xB1
6BC8:  MOVLW  41
6BCA:  MOVWF  xB0
6BCC:  MOVLB  0
6BCE:  CALL   3DC4
6BD2:  BTFSC  19.7
6BD4:  BSF    FF2.7
6BD6:  MOVF   01,F
6BD8:  BNZ   6C00
....................       { 
....................          mode=LOGOFF; 
6BDA:  MOVLB  8
6BDC:  CLRF   x6F
....................          keydebug_en=0; 
6BDE:  MOVLB  1
6BE0:  CLRF   x08
....................          set_tris_a(0xff); 
6BE2:  MOVLW  FF
6BE4:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
6BE6:  MOVLW  98
6BE8:  MOVWF  FF6
6BEA:  MOVLW  1C
6BEC:  MOVWF  FF7
6BEE:  CLRF   19
6BF0:  BTFSC  FF2.7
6BF2:  BSF    19.7
6BF4:  BCF    FF2.7
6BF6:  MOVLB  0
6BF8:  CALL   064E
6BFC:  BTFSC  19.7
6BFE:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
6C00:  CLRF   FEA
6C02:  MOVLW  41
6C04:  MOVWF  FE9
6C06:  MOVLW  00
6C08:  CALL   019C
6C0C:  TBLRD*-
6C0E:  TBLRD*+
6C10:  MOVF   FF5,W
6C12:  MOVWF  FEE
6C14:  IORLW  00
6C16:  BNZ   6C0E
6C18:  CLRF   19
6C1A:  BTFSC  FF2.7
6C1C:  BSF    19.7
6C1E:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
6C20:  MOVLW  01
6C22:  MOVLB  9
6C24:  MOVWF  xAF
6C26:  MOVLW  4A
6C28:  MOVWF  xAE
6C2A:  CLRF   xB1
6C2C:  MOVLW  41
6C2E:  MOVWF  xB0
6C30:  MOVLB  0
6C32:  CALL   3DC4
6C36:  BTFSC  19.7
6C38:  BSF    FF2.7
6C3A:  MOVF   01,F
6C3C:  BNZ   6C9E
....................       { 
....................          fprintf(COM2,"New console name>"); 
6C3E:  MOVLW  A0
6C40:  MOVWF  FF6
6C42:  MOVLW  1C
6C44:  MOVWF  FF7
6C46:  CLRF   19
6C48:  BTFSC  FF2.7
6C4A:  BSF    19.7
6C4C:  BCF    FF2.7
6C4E:  CALL   064E
6C52:  BTFSC  19.7
6C54:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,16, console); 
6C56:  MOVLW  01
6C58:  MOVLB  8
6C5A:  MOVWF  xCD
6C5C:  MOVLW  10
6C5E:  MOVWF  xCE
6C60:  MOVLW  08
6C62:  MOVWF  xD0
6C64:  MOVLW  7A
6C66:  MOVWF  xCF
6C68:  MOVLB  0
6C6A:  CALL   5E04
....................          EEPROM_write(strobe_nameconsole,16,console); 
6C6E:  MOVLW  66
6C70:  MOVLB  8
6C72:  MOVWF  xE2
6C74:  MOVLW  10
6C76:  MOVWF  xE3
6C78:  MOVLW  08
6C7A:  MOVWF  xE5
6C7C:  MOVLW  7A
6C7E:  MOVWF  xE4
6C80:  MOVLB  0
6C82:  CALL   5A8C
....................          fprintf(COM2," OK\n\r"); 
6C86:  MOVLW  B2
6C88:  MOVWF  FF6
6C8A:  MOVLW  1C
6C8C:  MOVWF  FF7
6C8E:  CLRF   19
6C90:  BTFSC  FF2.7
6C92:  BSF    19.7
6C94:  BCF    FF2.7
6C96:  CALL   064E
6C9A:  BTFSC  19.7
6C9C:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
6C9E:  CLRF   FEA
6CA0:  MOVLW  41
6CA2:  MOVWF  FE9
6CA4:  MOVLW  00
6CA6:  CALL   01AE
6CAA:  TBLRD*-
6CAC:  TBLRD*+
6CAE:  MOVF   FF5,W
6CB0:  MOVWF  FEE
6CB2:  IORLW  00
6CB4:  BNZ   6CAC
6CB6:  CLRF   19
6CB8:  BTFSC  FF2.7
6CBA:  BSF    19.7
6CBC:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
6CBE:  MOVLW  01
6CC0:  MOVLB  9
6CC2:  MOVWF  xAF
6CC4:  MOVLW  4A
6CC6:  MOVWF  xAE
6CC8:  CLRF   xB1
6CCA:  MOVLW  41
6CCC:  MOVWF  xB0
6CCE:  MOVLB  0
6CD0:  CALL   3DC4
6CD4:  BTFSC  19.7
6CD6:  BSF    FF2.7
6CD8:  MOVF   01,F
6CDA:  BTFSS  FD8.2
6CDC:  BRA    7024
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
*
6DA8:  MOVLB  9
6DAA:  CLRF   xBD
6DAC:  MOVLW  91
6DAE:  MOVWF  xBC
6DB0:  MOVLB  0
6DB2:  CALL   2E48
6DB6:  BTFSC  19.7
6DB8:  BSF    FF2.7
6DBA:  MOVFF  01,875
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
6DBE:  MOVLB  8
6DC0:  MOVF   x75,F
6DC2:  BNZ   6DE2
6DC4:  MOVLW  B8
6DC6:  MOVWF  FF6
6DC8:  MOVLW  1C
6DCA:  MOVWF  FF7
6DCC:  CLRF   19
6DCE:  BTFSC  FF2.7
6DD0:  BSF    19.7
6DD2:  BCF    FF2.7
6DD4:  MOVLB  0
6DD6:  CALL   064E
6DDA:  BTFSC  19.7
6DDC:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
6DDE:  BRA    6DFC
6DE0:  MOVLB  8
6DE2:  MOVLW  BC
6DE4:  MOVWF  FF6
6DE6:  MOVLW  1C
6DE8:  MOVWF  FF7
6DEA:  CLRF   19
6DEC:  BTFSC  FF2.7
6DEE:  BSF    19.7
6DF0:  BCF    FF2.7
6DF2:  MOVLB  0
6DF4:  CALL   064E
6DF8:  BTFSC  19.7
6DFA:  BSF    FF2.7
6DFC:  CLRF   19
6DFE:  BTFSC  FF2.7
6E00:  BSF    19.7
6E02:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
6E04:  MOVLB  9
6E06:  CLRF   xBD
6E08:  MOVLW  94
6E0A:  MOVWF  xBC
6E0C:  MOVLB  0
6E0E:  CALL   2E48
6E12:  BTFSC  19.7
6E14:  BSF    FF2.7
6E16:  MOVFF  01,142
6E1A:  CLRF   19
6E1C:  BTFSC  FF2.7
6E1E:  BSF    19.7
6E20:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
6E22:  MOVLW  5B
6E24:  MOVLB  9
6E26:  MOVWF  xD3
6E28:  MOVLB  0
6E2A:  CALL   0608
6E2E:  BTFSC  19.7
6E30:  BSF    FF2.7
6E32:  MOVFF  142,8CD
6E36:  MOVLW  1B
6E38:  MOVLB  8
6E3A:  MOVWF  xCE
6E3C:  MOVLB  0
6E3E:  GOTO   6296
6E42:  CLRF   19
6E44:  BTFSC  FF2.7
6E46:  BSF    19.7
6E48:  BCF    FF2.7
6E4A:  MOVLW  5D
6E4C:  MOVLB  9
6E4E:  MOVWF  xD3
6E50:  MOVLB  0
6E52:  CALL   0608
6E56:  BTFSC  19.7
6E58:  BSF    FF2.7
6E5A:  CLRF   19
6E5C:  BTFSC  FF2.7
6E5E:  BSF    19.7
6E60:  BCF    FF2.7
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
6E62:  MOVLB  9
6E64:  CLRF   xBD
6E66:  MOVLW  93
6E68:  MOVWF  xBC
6E6A:  MOVLB  0
6E6C:  CALL   2E48
6E70:  BTFSC  19.7
6E72:  BSF    FF2.7
6E74:  MOVFF  01,360
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
6E78:  MOVLB  3
6E7A:  MOVF   x60,F
6E7C:  BNZ   6E9C
6E7E:  MOVLW  C0
6E80:  MOVWF  FF6
6E82:  MOVLW  1C
6E84:  MOVWF  FF7
6E86:  CLRF   19
6E88:  BTFSC  FF2.7
6E8A:  BSF    19.7
6E8C:  BCF    FF2.7
6E8E:  MOVLB  0
6E90:  CALL   064E
6E94:  BTFSC  19.7
6E96:  BSF    FF2.7
....................             else fprintf(COM2,"[auto sending (on)]"); 
6E98:  BRA    6EB6
6E9A:  MOVLB  3
6E9C:  MOVLW  D6
6E9E:  MOVWF  FF6
6EA0:  MOVLW  1C
6EA2:  MOVWF  FF7
6EA4:  CLRF   19
6EA6:  BTFSC  FF2.7
6EA8:  BSF    19.7
6EAA:  BCF    FF2.7
6EAC:  MOVLB  0
6EAE:  CALL   064E
6EB2:  BTFSC  19.7
6EB4:  BSF    FF2.7
6EB6:  CLRF   19
6EB8:  BTFSC  FF2.7
6EBA:  BSF    19.7
6EBC:  BCF    FF2.7
....................          fprintf(COM2,"[");    
6EBE:  MOVLW  5B
6EC0:  MOVLB  9
6EC2:  MOVWF  xD3
6EC4:  MOVLB  0
6EC6:  CALL   0608
6ECA:  BTFSC  19.7
6ECC:  BSF    FF2.7
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
6ECE:  MOVLB  8
6ED0:  CLRF   x98
6ED2:  MOVF   x98,W
6ED4:  SUBLW  0F
6ED6:  BNC   6F14
6ED8:  MOVLW  55
6EDA:  ADDWF  x98,W
6EDC:  MOVWF  xCD
6EDE:  CLRF   19
6EE0:  BTFSC  FF2.7
6EE2:  BSF    19.7
6EE4:  BCF    FF2.7
6EE6:  MOVLB  9
6EE8:  CLRF   xBD
6EEA:  MOVWF  xBC
6EEC:  MOVLB  0
6EEE:  CALL   2E48
6EF2:  BTFSC  19.7
6EF4:  BSF    FF2.7
6EF6:  MOVFF  01,8CD
6EFA:  CLRF   19
6EFC:  BTFSC  FF2.7
6EFE:  BSF    19.7
6F00:  BCF    FF2.7
6F02:  MOVFF  01,9D3
6F06:  CALL   0608
6F0A:  BTFSC  19.7
6F0C:  BSF    FF2.7
6F0E:  MOVLB  8
6F10:  INCF   x98,F
6F12:  BRA    6ED2
6F14:  CLRF   19
6F16:  BTFSC  FF2.7
6F18:  BSF    19.7
6F1A:  BCF    FF2.7
....................          fprintf(COM2,"] "); 
6F1C:  MOVLW  5D
6F1E:  MOVLB  9
6F20:  MOVWF  xD3
6F22:  MOVLB  0
6F24:  CALL   0608
6F28:  BTFSC  19.7
6F2A:  BSF    FF2.7
6F2C:  CLRF   19
6F2E:  BTFSC  FF2.7
6F30:  BSF    19.7
6F32:  BCF    FF2.7
6F34:  MOVLW  20
6F36:  MOVLB  9
6F38:  MOVWF  xD3
6F3A:  MOVLB  0
6F3C:  CALL   0608
6F40:  BTFSC  19.7
6F42:  BSF    FF2.7
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
6F44:  MOVFF  100,8CD
6F48:  MOVLW  01
6F4A:  MOVLB  8
6F4C:  MOVWF  xCE
6F4E:  MOVLB  0
6F50:  CALL   6074
6F54:  CLRF   19
6F56:  BTFSC  FF2.7
6F58:  BSF    19.7
6F5A:  BCF    FF2.7
6F5C:  MOVLW  2F
6F5E:  MOVLB  9
6F60:  MOVWF  xD3
6F62:  MOVLB  0
6F64:  CALL   0608
6F68:  BTFSC  19.7
6F6A:  BSF    FF2.7
6F6C:  MOVFF  FF,8CD
6F70:  MOVLW  01
6F72:  MOVLB  8
6F74:  MOVWF  xCE
6F76:  MOVLB  0
6F78:  CALL   6074
6F7C:  CLRF   19
6F7E:  BTFSC  FF2.7
6F80:  BSF    19.7
6F82:  BCF    FF2.7
6F84:  MOVLW  20
6F86:  MOVLB  9
6F88:  MOVWF  xD3
6F8A:  MOVLB  0
6F8C:  CALL   0608
6F90:  BTFSC  19.7
6F92:  BSF    FF2.7
6F94:  MOVFF  101,8CD
6F98:  MOVLW  01
6F9A:  MOVLB  8
6F9C:  MOVWF  xCE
6F9E:  MOVLB  0
6FA0:  CALL   6074
6FA4:  CLRF   19
6FA6:  BTFSC  FF2.7
6FA8:  BSF    19.7
6FAA:  BCF    FF2.7
6FAC:  MOVLW  3A
6FAE:  MOVLB  9
6FB0:  MOVWF  xD3
6FB2:  MOVLB  0
6FB4:  CALL   0608
6FB8:  BTFSC  19.7
6FBA:  BSF    FF2.7
6FBC:  MOVFF  102,8CD
6FC0:  MOVLW  01
6FC2:  MOVLB  8
6FC4:  MOVWF  xCE
6FC6:  MOVLB  0
6FC8:  CALL   6074
6FCC:  CLRF   19
6FCE:  BTFSC  FF2.7
6FD0:  BSF    19.7
6FD2:  BCF    FF2.7
6FD4:  MOVLW  3A
6FD6:  MOVLB  9
6FD8:  MOVWF  xD3
6FDA:  MOVLB  0
6FDC:  CALL   0608
6FE0:  BTFSC  19.7
6FE2:  BSF    FF2.7
6FE4:  MOVFF  103,8CD
6FE8:  MOVLW  01
6FEA:  MOVLB  8
6FEC:  MOVWF  xCE
6FEE:  MOVLB  0
6FF0:  CALL   6074
6FF4:  CLRF   19
6FF6:  BTFSC  FF2.7
6FF8:  BSF    19.7
6FFA:  BCF    FF2.7
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
6FFC:  MOVLW  0A
6FFE:  MOVLB  9
7000:  MOVWF  xD3
7002:  MOVLB  0
7004:  CALL   0608
7008:  BTFSC  19.7
700A:  BSF    FF2.7
700C:  CLRF   19
700E:  BTFSC  FF2.7
7010:  BSF    19.7
7012:  BCF    FF2.7
7014:  MOVLW  0D
7016:  MOVLB  9
7018:  MOVWF  xD3
701A:  MOVLB  0
701C:  CALL   0608
7020:  BTFSC  19.7
7022:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
7024:  CLRF   FEA
7026:  MOVLW  41
7028:  MOVWF  FE9
702A:  MOVLW  00
702C:  CALL   01C0
7030:  TBLRD*-
7032:  TBLRD*+
7034:  MOVF   FF5,W
7036:  MOVWF  FEE
7038:  IORLW  00
703A:  BNZ   7032
703C:  CLRF   19
703E:  BTFSC  FF2.7
7040:  BSF    19.7
7042:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7044:  MOVLW  01
7046:  MOVLB  9
7048:  MOVWF  xAF
704A:  MOVLW  4A
704C:  MOVWF  xAE
704E:  CLRF   xB1
7050:  MOVLW  41
7052:  MOVWF  xB0
7054:  MOVLB  0
7056:  CALL   3DC4
705A:  BTFSC  19.7
705C:  BSF    FF2.7
705E:  MOVF   01,F
7060:  BTFSS  FD8.2
7062:  BRA    728C
....................       { 
....................          fprintf(COM2,"Year>"); 
7064:  MOVLW  EA
7066:  MOVWF  FF6
7068:  MOVLW  1C
706A:  MOVWF  FF7
706C:  CLRF   19
706E:  BTFSC  FF2.7
7070:  BSF    19.7
7072:  BCF    FF2.7
7074:  CALL   064E
7078:  BTFSC  19.7
707A:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
707C:  MOVLW  01
707E:  MOVLB  8
7080:  MOVWF  xCD
7082:  MOVLW  03
7084:  MOVWF  xCE
7086:  MOVLW  08
7088:  MOVWF  xD0
708A:  MOVLW  99
708C:  MOVWF  xCF
708E:  MOVLB  0
7090:  CALL   5E04
....................          year=(unsigned int8)strtoi(temp); 
7094:  MOVLW  08
7096:  MOVLB  8
7098:  MOVWF  xCE
709A:  MOVLW  99
709C:  MOVWF  xCD
709E:  MOVLB  0
70A0:  CALL   635C
70A4:  MOVFF  01,FE
....................          fprintf(COM2,"Month>"); 
70A8:  MOVLW  F0
70AA:  MOVWF  FF6
70AC:  MOVLW  1C
70AE:  MOVWF  FF7
70B0:  CLRF   19
70B2:  BTFSC  FF2.7
70B4:  BSF    19.7
70B6:  BCF    FF2.7
70B8:  CALL   064E
70BC:  BTFSC  19.7
70BE:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
70C0:  MOVLW  01
70C2:  MOVLB  8
70C4:  MOVWF  xCD
70C6:  MOVLW  03
70C8:  MOVWF  xCE
70CA:  MOVLW  08
70CC:  MOVWF  xD0
70CE:  MOVLW  99
70D0:  MOVWF  xCF
70D2:  MOVLB  0
70D4:  CALL   5E04
....................          mon=(unsigned int8)strtoi(temp); 
70D8:  MOVLW  08
70DA:  MOVLB  8
70DC:  MOVWF  xCE
70DE:  MOVLW  99
70E0:  MOVWF  xCD
70E2:  MOVLB  0
70E4:  CALL   635C
70E8:  MOVFF  01,FF
....................          fprintf(COM2,"Date>"); 
70EC:  MOVLW  F8
70EE:  MOVWF  FF6
70F0:  MOVLW  1C
70F2:  MOVWF  FF7
70F4:  CLRF   19
70F6:  BTFSC  FF2.7
70F8:  BSF    19.7
70FA:  BCF    FF2.7
70FC:  CALL   064E
7100:  BTFSC  19.7
7102:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7104:  MOVLW  01
7106:  MOVLB  8
7108:  MOVWF  xCD
710A:  MOVLW  03
710C:  MOVWF  xCE
710E:  MOVLW  08
7110:  MOVWF  xD0
7112:  MOVLW  99
7114:  MOVWF  xCF
7116:  MOVLB  0
7118:  CALL   5E04
....................          date = (unsigned int8)strtoi(temp); 
711C:  MOVLW  08
711E:  MOVLB  8
7120:  MOVWF  xCE
7122:  MOVLW  99
7124:  MOVWF  xCD
7126:  MOVLB  0
7128:  CALL   635C
712C:  MOVFF  01,100
....................          fprintf(COM2,"Day>"); 
7130:  MOVLW  FE
7132:  MOVWF  FF6
7134:  MOVLW  1C
7136:  MOVWF  FF7
7138:  CLRF   19
713A:  BTFSC  FF2.7
713C:  BSF    19.7
713E:  BCF    FF2.7
7140:  CALL   064E
7144:  BTFSC  19.7
7146:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7148:  MOVLW  01
714A:  MOVLB  8
714C:  MOVWF  xCD
714E:  MOVLW  03
7150:  MOVWF  xCE
7152:  MOVLW  08
7154:  MOVWF  xD0
7156:  MOVLW  99
7158:  MOVWF  xCF
715A:  MOVLB  0
715C:  CALL   5E04
....................          day = (unsigned int8)strtoi(temp); 
7160:  MOVLW  08
7162:  MOVLB  8
7164:  MOVWF  xCE
7166:  MOVLW  99
7168:  MOVWF  xCD
716A:  MOVLB  0
716C:  CALL   635C
7170:  MOVFF  01,FD
....................          fprintf(COM2,"Hour>"); 
7174:  MOVLW  04
7176:  MOVWF  FF6
7178:  MOVLW  1D
717A:  MOVWF  FF7
717C:  CLRF   19
717E:  BTFSC  FF2.7
7180:  BSF    19.7
7182:  BCF    FF2.7
7184:  CALL   064E
7188:  BTFSC  19.7
718A:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
718C:  MOVLW  01
718E:  MOVLB  8
7190:  MOVWF  xCD
7192:  MOVLW  03
7194:  MOVWF  xCE
7196:  MOVLW  08
7198:  MOVWF  xD0
719A:  MOVLW  99
719C:  MOVWF  xCF
719E:  MOVLB  0
71A0:  CALL   5E04
....................          h = (unsigned int8)strtoi(temp); 
71A4:  MOVLW  08
71A6:  MOVLB  8
71A8:  MOVWF  xCE
71AA:  MOVLW  99
71AC:  MOVWF  xCD
71AE:  MOVLB  0
71B0:  CALL   635C
71B4:  MOVFF  01,101
....................          fprintf(COM2,"Minutes>"); 
71B8:  MOVLW  0A
71BA:  MOVWF  FF6
71BC:  MOVLW  1D
71BE:  MOVWF  FF7
71C0:  CLRF   19
71C2:  BTFSC  FF2.7
71C4:  BSF    19.7
71C6:  BCF    FF2.7
71C8:  CALL   064E
71CC:  BTFSC  19.7
71CE:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
71D0:  MOVLW  01
71D2:  MOVLB  8
71D4:  MOVWF  xCD
71D6:  MOVLW  03
71D8:  MOVWF  xCE
71DA:  MOVLW  08
71DC:  MOVWF  xD0
71DE:  MOVLW  99
71E0:  MOVWF  xCF
71E2:  MOVLB  0
71E4:  CALL   5E04
....................          min = (unsigned int8)strtoi(temp);                   
71E8:  MOVLW  08
71EA:  MOVLB  8
71EC:  MOVWF  xCE
71EE:  MOVLW  99
71F0:  MOVWF  xCD
71F2:  MOVLB  0
71F4:  CALL   635C
71F8:  MOVFF  01,102
....................          fprintf(COM2,"Seconds>"); 
71FC:  MOVLW  14
71FE:  MOVWF  FF6
7200:  MOVLW  1D
7202:  MOVWF  FF7
7204:  CLRF   19
7206:  BTFSC  FF2.7
7208:  BSF    19.7
720A:  BCF    FF2.7
720C:  CALL   064E
7210:  BTFSC  19.7
7212:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
7214:  MOVLW  01
7216:  MOVLB  8
7218:  MOVWF  xCD
721A:  MOVLW  03
721C:  MOVWF  xCE
721E:  MOVLW  08
7220:  MOVWF  xD0
7222:  MOVLW  99
7224:  MOVWF  xCF
7226:  MOVLB  0
7228:  CALL   5E04
....................          sec = (unsigned int8)strtoi(temp);                   
722C:  MOVLW  08
722E:  MOVLB  8
7230:  MOVWF  xCE
7232:  MOVLW  99
7234:  MOVWF  xCD
7236:  MOVLB  0
7238:  CALL   635C
723C:  MOVFF  01,103
7240:  CLRF   19
7242:  BTFSC  FF2.7
7244:  BSF    19.7
7246:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
7248:  MOVLW  0A
724A:  MOVLB  9
724C:  MOVWF  xD3
724E:  MOVLB  0
7250:  CALL   0608
7254:  BTFSC  19.7
7256:  BSF    FF2.7
7258:  CLRF   19
725A:  BTFSC  FF2.7
725C:  BSF    19.7
725E:  BCF    FF2.7
7260:  MOVLW  0D
7262:  MOVLB  9
7264:  MOVWF  xD3
7266:  MOVLB  0
7268:  CALL   0608
726C:  BTFSC  19.7
726E:  BSF    FF2.7
....................          rtc_set_datetime(date,mon,year,day,h,min); 
7270:  MOVFF  100,8CD
7274:  MOVFF  FF,8CE
7278:  MOVFF  FE,8CF
727C:  MOVFF  FD,8D0
7280:  MOVFF  101,8D1
7284:  MOVFF  102,8D2
7288:  GOTO   6496
....................       } 
....................       strcpy(buffer2,"MS"); 
728C:  CLRF   FEA
728E:  MOVLW  41
7290:  MOVWF  FE9
7292:  MOVLW  00
7294:  CALL   01D4
7298:  TBLRD*-
729A:  TBLRD*+
729C:  MOVF   FF5,W
729E:  MOVWF  FEE
72A0:  IORLW  00
72A2:  BNZ   729A
72A4:  CLRF   19
72A6:  BTFSC  FF2.7
72A8:  BSF    19.7
72AA:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2)) 
72AC:  MOVLW  01
72AE:  MOVLB  9
72B0:  MOVWF  xAF
72B2:  MOVLW  4A
72B4:  MOVWF  xAE
72B6:  CLRF   xB1
72B8:  MOVLW  41
72BA:  MOVWF  xB0
72BC:  MOVLB  0
72BE:  CALL   3DC4
72C2:  BTFSC  19.7
72C4:  BSF    FF2.7
72C6:  MOVF   01,F
72C8:  BTFSS  FD8.2
72CA:  BRA    73DA
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
72CC:  MOVLW  1E
72CE:  MOVWF  FF6
72D0:  MOVLW  1D
72D2:  MOVWF  FF7
72D4:  CLRF   19
72D6:  BTFSC  FF2.7
72D8:  BSF    19.7
72DA:  BCF    FF2.7
72DC:  CALL   064E
72E0:  BTFSC  19.7
72E2:  BSF    FF2.7
72E4:  CLRF   19
72E6:  BTFSC  FF2.7
72E8:  BSF    19.7
72EA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
72EC:  MOVLW  0A
72EE:  MOVLB  9
72F0:  MOVWF  xD3
72F2:  MOVLB  0
72F4:  CALL   0608
72F8:  BTFSC  19.7
72FA:  BSF    FF2.7
72FC:  CLRF   19
72FE:  BTFSC  FF2.7
7300:  BSF    19.7
7302:  BCF    FF2.7
7304:  MOVLW  0D
7306:  MOVLB  9
7308:  MOVWF  xD3
730A:  MOVLB  0
730C:  CALL   0608
7310:  BTFSC  19.7
7312:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
7314:  MOVLW  3E
7316:  MOVWF  FF6
7318:  MOVLW  1D
731A:  MOVWF  FF7
731C:  CLRF   19
731E:  BTFSC  FF2.7
7320:  BSF    19.7
7322:  BCF    FF2.7
7324:  CALL   064E
7328:  BTFSC  19.7
732A:  BSF    FF2.7
732C:  CLRF   19
732E:  BTFSC  FF2.7
7330:  BSF    19.7
7332:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7334:  MOVLW  0A
7336:  MOVLB  9
7338:  MOVWF  xD3
733A:  MOVLB  0
733C:  CALL   0608
7340:  BTFSC  19.7
7342:  BSF    FF2.7
7344:  CLRF   19
7346:  BTFSC  FF2.7
7348:  BSF    19.7
734A:  BCF    FF2.7
734C:  MOVLW  0D
734E:  MOVLB  9
7350:  MOVWF  xD3
7352:  MOVLB  0
7354:  CALL   0608
7358:  BTFSC  19.7
735A:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
735C:  MOVLW  01
735E:  MOVLB  8
7360:  MOVWF  xCD
7362:  MOVLW  03
7364:  MOVWF  xCE
7366:  MOVLW  08
7368:  MOVWF  xD0
736A:  MOVLW  99
736C:  MOVWF  xCF
736E:  MOVLB  0
7370:  CALL   5E04
....................           mode_sl = (unsigned int8)strtoi(temp); 
7374:  MOVLW  08
7376:  MOVLB  8
7378:  MOVWF  xCE
737A:  MOVLW  99
737C:  MOVWF  xCD
737E:  MOVLB  0
7380:  CALL   635C
7384:  MOVFF  01,875
7388:  CLRF   19
738A:  BTFSC  FF2.7
738C:  BSF    19.7
738E:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
7390:  MOVLB  9
7392:  CLRF   xC0
7394:  MOVLW  91
7396:  MOVWF  xBF
7398:  MOVFF  875,9C1
739C:  MOVLB  0
739E:  CALL   336C
73A2:  BTFSC  19.7
73A4:  BSF    FF2.7
....................           set_tris_a(0xff); 
73A6:  MOVLW  FF
73A8:  MOVWF  F92
73AA:  CLRF   19
73AC:  BTFSC  FF2.7
73AE:  BSF    19.7
73B0:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
73B2:  MOVLW  0A
73B4:  MOVLB  9
73B6:  MOVWF  xD3
73B8:  MOVLB  0
73BA:  CALL   0608
73BE:  BTFSC  19.7
73C0:  BSF    FF2.7
73C2:  CLRF   19
73C4:  BTFSC  FF2.7
73C6:  BSF    19.7
73C8:  BCF    FF2.7
73CA:  MOVLW  0D
73CC:  MOVLB  9
73CE:  MOVWF  xD3
73D0:  MOVLB  0
73D2:  CALL   0608
73D6:  BTFSC  19.7
73D8:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"KP"); 
73DA:  CLRF   FEA
73DC:  MOVLW  41
73DE:  MOVWF  FE9
73E0:  MOVLW  00
73E2:  CALL   01E8
73E6:  TBLRD*-
73E8:  TBLRD*+
73EA:  MOVF   FF5,W
73EC:  MOVWF  FEE
73EE:  IORLW  00
73F0:  BNZ   73E8
73F2:  CLRF   19
73F4:  BTFSC  FF2.7
73F6:  BSF    19.7
73F8:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2)) 
73FA:  MOVLW  01
73FC:  MOVLB  9
73FE:  MOVWF  xAF
7400:  MOVLW  4A
7402:  MOVWF  xAE
7404:  CLRF   xB1
7406:  MOVLW  41
7408:  MOVWF  xB0
740A:  MOVLB  0
740C:  CALL   3DC4
7410:  BTFSC  19.7
7412:  BSF    FF2.7
7414:  MOVF   01,F
7416:  BTFSS  FD8.2
7418:  BRA    7524
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
741A:  MOVLW  5E
741C:  MOVWF  FF6
741E:  MOVLW  1D
7420:  MOVWF  FF7
7422:  CLRF   19
7424:  BTFSC  FF2.7
7426:  BSF    19.7
7428:  BCF    FF2.7
742A:  CALL   064E
742E:  BTFSC  19.7
7430:  BSF    FF2.7
7432:  CLRF   19
7434:  BTFSC  FF2.7
7436:  BSF    19.7
7438:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
743A:  MOVLW  0A
743C:  MOVLB  9
743E:  MOVWF  xD3
7440:  MOVLB  0
7442:  CALL   0608
7446:  BTFSC  19.7
7448:  BSF    FF2.7
744A:  CLRF   19
744C:  BTFSC  FF2.7
744E:  BSF    19.7
7450:  BCF    FF2.7
7452:  MOVLW  0D
7454:  MOVLB  9
7456:  MOVWF  xD3
7458:  MOVLB  0
745A:  CALL   0608
745E:  BTFSC  19.7
7460:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
7462:  MOVLW  7C
7464:  MOVWF  FF6
7466:  MOVLW  1D
7468:  MOVWF  FF7
746A:  CLRF   19
746C:  BTFSC  FF2.7
746E:  BSF    19.7
7470:  BCF    FF2.7
7472:  CALL   064E
7476:  BTFSC  19.7
7478:  BSF    FF2.7
747A:  CLRF   19
747C:  BTFSC  FF2.7
747E:  BSF    19.7
7480:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7482:  MOVLW  0A
7484:  MOVLB  9
7486:  MOVWF  xD3
7488:  MOVLB  0
748A:  CALL   0608
748E:  BTFSC  19.7
7490:  BSF    FF2.7
7492:  CLRF   19
7494:  BTFSC  FF2.7
7496:  BSF    19.7
7498:  BCF    FF2.7
749A:  MOVLW  0D
749C:  MOVLB  9
749E:  MOVWF  xD3
74A0:  MOVLB  0
74A2:  CALL   0608
74A6:  BTFSC  19.7
74A8:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
74AA:  MOVLW  01
74AC:  MOVLB  8
74AE:  MOVWF  xCD
74B0:  MOVLW  03
74B2:  MOVWF  xCE
74B4:  MOVLW  08
74B6:  MOVWF  xD0
74B8:  MOVLW  99
74BA:  MOVWF  xCF
74BC:  MOVLB  0
74BE:  CALL   5E04
....................           KP_mode = (unsigned int8)strtoi(temp); 
74C2:  MOVLW  08
74C4:  MOVLB  8
74C6:  MOVWF  xCE
74C8:  MOVLW  99
74CA:  MOVWF  xCD
74CC:  MOVLB  0
74CE:  CALL   635C
74D2:  MOVFF  01,10C
74D6:  CLRF   19
74D8:  BTFSC  FF2.7
74DA:  BSF    19.7
74DC:  BCF    FF2.7
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
74DE:  MOVLB  9
74E0:  CLRF   xC0
74E2:  MOVLW  7F
74E4:  MOVWF  xBF
74E6:  MOVFF  10C,9C1
74EA:  MOVLB  0
74EC:  CALL   336C
74F0:  BTFSC  19.7
74F2:  BSF    FF2.7
74F4:  CLRF   19
74F6:  BTFSC  FF2.7
74F8:  BSF    19.7
74FA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
74FC:  MOVLW  0A
74FE:  MOVLB  9
7500:  MOVWF  xD3
7502:  MOVLB  0
7504:  CALL   0608
7508:  BTFSC  19.7
750A:  BSF    FF2.7
750C:  CLRF   19
750E:  BTFSC  FF2.7
7510:  BSF    19.7
7512:  BCF    FF2.7
7514:  MOVLW  0D
7516:  MOVLB  9
7518:  MOVWF  xD3
751A:  MOVLB  0
751C:  CALL   0608
7520:  BTFSC  19.7
7522:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"tran time"); 
7524:  CLRF   FEA
7526:  MOVLW  41
7528:  MOVWF  FE9
752A:  MOVLW  00
752C:  CALL   01FC
7530:  TBLRD*-
7532:  TBLRD*+
7534:  MOVF   FF5,W
7536:  MOVWF  FEE
7538:  IORLW  00
753A:  BNZ   7532
753C:  CLRF   19
753E:  BTFSC  FF2.7
7540:  BSF    19.7
7542:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2)) 
7544:  MOVLW  01
7546:  MOVLB  9
7548:  MOVWF  xAF
754A:  MOVLW  4A
754C:  MOVWF  xAE
754E:  CLRF   xB1
7550:  MOVLW  41
7552:  MOVWF  xB0
7554:  MOVLB  0
7556:  CALL   3DC4
755A:  BTFSC  19.7
755C:  BSF    FF2.7
755E:  MOVF   01,F
7560:  BNZ   7624
....................       { 
....................           fprintf(COM2,"Input Number"); 
7562:  MOVLW  9A
7564:  MOVWF  FF6
7566:  MOVLW  1D
7568:  MOVWF  FF7
756A:  CLRF   19
756C:  BTFSC  FF2.7
756E:  BSF    19.7
7570:  BCF    FF2.7
7572:  CALL   064E
7576:  BTFSC  19.7
7578:  BSF    FF2.7
757A:  CLRF   19
757C:  BTFSC  FF2.7
757E:  BSF    19.7
7580:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7582:  MOVLW  0A
7584:  MOVLB  9
7586:  MOVWF  xD3
7588:  MOVLB  0
758A:  CALL   0608
758E:  BTFSC  19.7
7590:  BSF    FF2.7
7592:  CLRF   19
7594:  BTFSC  FF2.7
7596:  BSF    19.7
7598:  BCF    FF2.7
759A:  MOVLW  0D
759C:  MOVLB  9
759E:  MOVWF  xD3
75A0:  MOVLB  0
75A2:  CALL   0608
75A6:  BTFSC  19.7
75A8:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
75AA:  MOVLW  01
75AC:  MOVLB  8
75AE:  MOVWF  xCD
75B0:  MOVLW  03
75B2:  MOVWF  xCE
75B4:  MOVLW  08
75B6:  MOVWF  xD0
75B8:  MOVLW  99
75BA:  MOVWF  xCF
75BC:  MOVLB  0
75BE:  CALL   5E04
....................           delaycharaction = (unsigned int8)strtoi(temp); 
75C2:  MOVLW  08
75C4:  MOVLB  8
75C6:  MOVWF  xCE
75C8:  MOVLW  99
75CA:  MOVWF  xCD
75CC:  MOVLB  0
75CE:  CALL   635C
75D2:  MOVFF  01,142
75D6:  CLRF   19
75D8:  BTFSC  FF2.7
75DA:  BSF    19.7
75DC:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
75DE:  MOVLB  9
75E0:  CLRF   xC0
75E2:  MOVLW  94
75E4:  MOVWF  xBF
75E6:  MOVFF  142,9C1
75EA:  MOVLB  0
75EC:  CALL   336C
75F0:  BTFSC  19.7
75F2:  BSF    FF2.7
75F4:  CLRF   19
75F6:  BTFSC  FF2.7
75F8:  BSF    19.7
75FA:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
75FC:  MOVLW  0A
75FE:  MOVLB  9
7600:  MOVWF  xD3
7602:  MOVLB  0
7604:  CALL   0608
7608:  BTFSC  19.7
760A:  BSF    FF2.7
760C:  CLRF   19
760E:  BTFSC  FF2.7
7610:  BSF    19.7
7612:  BCF    FF2.7
7614:  MOVLW  0D
7616:  MOVLB  9
7618:  MOVWF  xD3
761A:  MOVLB  0
761C:  CALL   0608
7620:  BTFSC  19.7
7622:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"delaykb"); 
7624:  CLRF   FEA
7626:  MOVLW  41
7628:  MOVWF  FE9
762A:  MOVLW  00
762C:  CALL   0216
7630:  TBLRD*-
7632:  TBLRD*+
7634:  MOVF   FF5,W
7636:  MOVWF  FEE
7638:  IORLW  00
763A:  BNZ   7632
763C:  CLRF   19
763E:  BTFSC  FF2.7
7640:  BSF    19.7
7642:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2)) 
7644:  MOVLW  01
7646:  MOVLB  9
7648:  MOVWF  xAF
764A:  MOVLW  4A
764C:  MOVWF  xAE
764E:  CLRF   xB1
7650:  MOVLW  41
7652:  MOVWF  xB0
7654:  MOVLB  0
7656:  CALL   3DC4
765A:  BTFSC  19.7
765C:  BSF    FF2.7
765E:  MOVF   01,F
7660:  BNZ   7724
....................       { 
....................           fprintf(COM2,"Input Number"); 
7662:  MOVLW  A8
7664:  MOVWF  FF6
7666:  MOVLW  1D
7668:  MOVWF  FF7
766A:  CLRF   19
766C:  BTFSC  FF2.7
766E:  BSF    19.7
7670:  BCF    FF2.7
7672:  CALL   064E
7676:  BTFSC  19.7
7678:  BSF    FF2.7
767A:  CLRF   19
767C:  BTFSC  FF2.7
767E:  BSF    19.7
7680:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7682:  MOVLW  0A
7684:  MOVLB  9
7686:  MOVWF  xD3
7688:  MOVLB  0
768A:  CALL   0608
768E:  BTFSC  19.7
7690:  BSF    FF2.7
7692:  CLRF   19
7694:  BTFSC  FF2.7
7696:  BSF    19.7
7698:  BCF    FF2.7
769A:  MOVLW  0D
769C:  MOVLB  9
769E:  MOVWF  xD3
76A0:  MOVLB  0
76A2:  CALL   0608
76A6:  BTFSC  19.7
76A8:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
76AA:  MOVLW  01
76AC:  MOVLB  8
76AE:  MOVWF  xCD
76B0:  MOVLW  03
76B2:  MOVWF  xCE
76B4:  MOVLW  08
76B6:  MOVWF  xD0
76B8:  MOVLW  99
76BA:  MOVWF  xCF
76BC:  MOVLB  0
76BE:  CALL   5E04
....................           delaykey = (unsigned int8)strtoi(temp); 
76C2:  MOVLW  08
76C4:  MOVLB  8
76C6:  MOVWF  xCE
76C8:  MOVLW  99
76CA:  MOVWF  xCD
76CC:  MOVLB  0
76CE:  CALL   635C
76D2:  MOVFF  01,107
76D6:  CLRF   19
76D8:  BTFSC  FF2.7
76DA:  BSF    19.7
76DC:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
76DE:  MOVLB  9
76E0:  CLRF   xC0
76E2:  MOVLW  95
76E4:  MOVWF  xBF
76E6:  MOVFF  107,9C1
76EA:  MOVLB  0
76EC:  CALL   336C
76F0:  BTFSC  19.7
76F2:  BSF    FF2.7
76F4:  CLRF   19
76F6:  BTFSC  FF2.7
76F8:  BSF    19.7
76FA:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
76FC:  MOVLW  0A
76FE:  MOVLB  9
7700:  MOVWF  xD3
7702:  MOVLB  0
7704:  CALL   0608
7708:  BTFSC  19.7
770A:  BSF    FF2.7
770C:  CLRF   19
770E:  BTFSC  FF2.7
7710:  BSF    19.7
7712:  BCF    FF2.7
7714:  MOVLW  0D
7716:  MOVLB  9
7718:  MOVWF  xD3
771A:  MOVLB  0
771C:  CALL   0608
7720:  BTFSC  19.7
7722:  BSF    FF2.7
....................       }  
....................       strcpy(buffer2,"KBtime"); 
7724:  CLRF   FEA
7726:  MOVLW  41
7728:  MOVWF  FE9
772A:  MOVLW  00
772C:  CALL   022E
7730:  TBLRD*-
7732:  TBLRD*+
7734:  MOVF   FF5,W
7736:  MOVWF  FEE
7738:  IORLW  00
773A:  BNZ   7732
773C:  CLRF   19
773E:  BTFSC  FF2.7
7740:  BSF    19.7
7742:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2)) 
7744:  MOVLW  01
7746:  MOVLB  9
7748:  MOVWF  xAF
774A:  MOVLW  4A
774C:  MOVWF  xAE
774E:  CLRF   xB1
7750:  MOVLW  41
7752:  MOVWF  xB0
7754:  MOVLB  0
7756:  CALL   3DC4
775A:  BTFSC  19.7
775C:  BSF    FF2.7
775E:  MOVF   01,F
7760:  BNZ   7824
....................       { 
....................           fprintf(COM2,"Input Number"); 
7762:  MOVLW  B6
7764:  MOVWF  FF6
7766:  MOVLW  1D
7768:  MOVWF  FF7
776A:  CLRF   19
776C:  BTFSC  FF2.7
776E:  BSF    19.7
7770:  BCF    FF2.7
7772:  CALL   064E
7776:  BTFSC  19.7
7778:  BSF    FF2.7
777A:  CLRF   19
777C:  BTFSC  FF2.7
777E:  BSF    19.7
7780:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7782:  MOVLW  0A
7784:  MOVLB  9
7786:  MOVWF  xD3
7788:  MOVLB  0
778A:  CALL   0608
778E:  BTFSC  19.7
7790:  BSF    FF2.7
7792:  CLRF   19
7794:  BTFSC  FF2.7
7796:  BSF    19.7
7798:  BCF    FF2.7
779A:  MOVLW  0D
779C:  MOVLB  9
779E:  MOVWF  xD3
77A0:  MOVLB  0
77A2:  CALL   0608
77A6:  BTFSC  19.7
77A8:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
77AA:  MOVLW  01
77AC:  MOVLB  8
77AE:  MOVWF  xCD
77B0:  MOVLW  03
77B2:  MOVWF  xCE
77B4:  MOVLW  08
77B6:  MOVWF  xD0
77B8:  MOVLW  99
77BA:  MOVWF  xCF
77BC:  MOVLB  0
77BE:  CALL   5E04
....................           write_ext_eeprom(KB_time,(unsigned int8)strtoi(temp)); 
77C2:  MOVLW  08
77C4:  MOVLB  8
77C6:  MOVWF  xCE
77C8:  MOVLW  99
77CA:  MOVWF  xCD
77CC:  MOVLB  0
77CE:  CALL   635C
77D2:  MOVFF  01,8CD
77D6:  CLRF   19
77D8:  BTFSC  FF2.7
77DA:  BSF    19.7
77DC:  BCF    FF2.7
77DE:  MOVLB  9
77E0:  CLRF   xC0
77E2:  MOVLW  7E
77E4:  MOVWF  xBF
77E6:  MOVFF  01,9C1
77EA:  MOVLB  0
77EC:  CALL   336C
77F0:  BTFSC  19.7
77F2:  BSF    FF2.7
77F4:  CLRF   19
77F6:  BTFSC  FF2.7
77F8:  BSF    19.7
77FA:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
77FC:  MOVLW  0A
77FE:  MOVLB  9
7800:  MOVWF  xD3
7802:  MOVLB  0
7804:  CALL   0608
7808:  BTFSC  19.7
780A:  BSF    FF2.7
780C:  CLRF   19
780E:  BTFSC  FF2.7
7810:  BSF    19.7
7812:  BCF    FF2.7
7814:  MOVLW  0D
7816:  MOVLB  9
7818:  MOVWF  xD3
781A:  MOVLB  0
781C:  CALL   0608
7820:  BTFSC  19.7
7822:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
7824:  CLRF   FEA
7826:  MOVLW  41
7828:  MOVWF  FE9
782A:  CLRF   00
782C:  CLRF   02
782E:  MOVLW  14
7830:  MOVWF  01
7832:  CALL   3968
....................       strcpy(buffer2,"cf mbn"); 
7836:  CLRF   FEA
7838:  MOVLW  41
783A:  MOVWF  FE9
783C:  MOVLW  00
783E:  CALL   0246
7842:  TBLRD*-
7844:  TBLRD*+
7846:  MOVF   FF5,W
7848:  MOVWF  FEE
784A:  IORLW  00
784C:  BNZ   7844
784E:  CLRF   19
7850:  BTFSC  FF2.7
7852:  BSF    19.7
7854:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7856:  MOVLW  01
7858:  MOVLB  9
785A:  MOVWF  xAF
785C:  MOVLW  4A
785E:  MOVWF  xAE
7860:  CLRF   xB1
7862:  MOVLW  41
7864:  MOVWF  xB0
7866:  MOVLB  0
7868:  CALL   3DC4
786C:  BTFSC  19.7
786E:  BSF    FF2.7
7870:  MOVF   01,F
7872:  BTFSS  FD8.2
7874:  BRA    7998
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
7876:  MOVLB  8
7878:  CLRF   x98
787A:  MOVF   x98,W
787C:  SUBLW  13
787E:  BNC   7894
7880:  CLRF   03
7882:  MOVF   x98,W
7884:  ADDLW  2D
7886:  MOVWF  FE9
7888:  MOVLW  00
788A:  ADDWFC 03,W
788C:  MOVWF  FEA
788E:  CLRF   FEF
7890:  INCF   x98,F
7892:  BRA    787A
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
7894:  MOVLW  C4
7896:  MOVWF  FF6
7898:  MOVLW  1D
789A:  MOVWF  FF7
789C:  CLRF   19
789E:  BTFSC  FF2.7
78A0:  BSF    19.7
78A2:  BCF    FF2.7
78A4:  MOVLB  0
78A6:  CALL   064E
78AA:  BTFSC  19.7
78AC:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 20, buffer1); 
78AE:  MOVLW  01
78B0:  MOVLB  8
78B2:  MOVWF  xCD
78B4:  MOVLW  14
78B6:  MOVWF  xCE
78B8:  CLRF   xD0
78BA:  MOVLW  2D
78BC:  MOVWF  xCF
78BE:  MOVLB  0
78C0:  CALL   5E04
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
78C4:  MOVLW  55
78C6:  MOVLB  8
78C8:  MOVWF  xE2
78CA:  MOVLW  14
78CC:  MOVWF  xE3
78CE:  CLRF   xE5
78D0:  MOVLW  2D
78D2:  MOVWF  xE4
78D4:  MOVLB  0
78D6:  CALL   5A8C
....................          fprintf(COM2,"\n\rdone\n\r");   
78DA:  MOVLW  E6
78DC:  MOVWF  FF6
78DE:  MOVLW  1D
78E0:  MOVWF  FF7
78E2:  CLRF   19
78E4:  BTFSC  FF2.7
78E6:  BSF    19.7
78E8:  BCF    FF2.7
78EA:  CALL   064E
78EE:  BTFSC  19.7
78F0:  BSF    FF2.7
78F2:  CLRF   19
78F4:  BTFSC  FF2.7
78F6:  BSF    19.7
78F8:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
78FA:  MOVLW  0A
78FC:  MOVLB  9
78FE:  MOVWF  xD3
7900:  MOVLB  0
7902:  CALL   0608
7906:  BTFSC  19.7
7908:  BSF    FF2.7
790A:  CLRF   19
790C:  BTFSC  FF2.7
790E:  BSF    19.7
7910:  BCF    FF2.7
7912:  MOVLW  0D
7914:  MOVLB  9
7916:  MOVWF  xD3
7918:  MOVLB  0
791A:  CALL   0608
791E:  BTFSC  19.7
7920:  BSF    FF2.7
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
7922:  MOVLB  8
7924:  CLRF   x98
7926:  MOVF   x98,W
7928:  SUBLW  13
792A:  BNC   7968
792C:  MOVLW  55
792E:  ADDWF  x98,W
7930:  MOVWF  xCD
7932:  CLRF   19
7934:  BTFSC  FF2.7
7936:  BSF    19.7
7938:  BCF    FF2.7
793A:  MOVLB  9
793C:  CLRF   xBD
793E:  MOVWF  xBC
7940:  MOVLB  0
7942:  CALL   2E48
7946:  BTFSC  19.7
7948:  BSF    FF2.7
794A:  MOVFF  01,8CD
794E:  CLRF   19
7950:  BTFSC  FF2.7
7952:  BSF    19.7
7954:  BCF    FF2.7
7956:  MOVFF  01,9D3
795A:  CALL   0608
795E:  BTFSC  19.7
7960:  BSF    FF2.7
7962:  MOVLB  8
7964:  INCF   x98,F
7966:  BRA    7926
7968:  CLRF   19
796A:  BTFSC  FF2.7
796C:  BSF    19.7
796E:  BCF    FF2.7
....................          fprintf(COM2,"\n\r");//*/ 
7970:  MOVLW  0A
7972:  MOVLB  9
7974:  MOVWF  xD3
7976:  MOVLB  0
7978:  CALL   0608
797C:  BTFSC  19.7
797E:  BSF    FF2.7
7980:  CLRF   19
7982:  BTFSC  FF2.7
7984:  BSF    19.7
7986:  BCF    FF2.7
7988:  MOVLW  0D
798A:  MOVLB  9
798C:  MOVWF  xD3
798E:  MOVLB  0
7990:  CALL   0608
7994:  BTFSC  19.7
7996:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
7998:  CLRF   FEA
799A:  MOVLW  41
799C:  MOVWF  FE9
799E:  MOVLW  00
79A0:  CALL   025E
79A4:  TBLRD*-
79A6:  TBLRD*+
79A8:  MOVF   FF5,W
79AA:  MOVWF  FEE
79AC:  IORLW  00
79AE:  BNZ   79A6
79B0:  CLRF   19
79B2:  BTFSC  FF2.7
79B4:  BSF    19.7
79B6:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2)) 
79B8:  MOVLW  01
79BA:  MOVLB  9
79BC:  MOVWF  xAF
79BE:  MOVLW  4A
79C0:  MOVWF  xAE
79C2:  CLRF   xB1
79C4:  MOVLW  41
79C6:  MOVWF  xB0
79C8:  MOVLB  0
79CA:  CALL   3DC4
79CE:  BTFSC  19.7
79D0:  BSF    FF2.7
79D2:  MOVF   01,F
79D4:  BTFSS  FD8.2
79D6:  BRA    7AE2
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
79D8:  MOVLW  F0
79DA:  MOVWF  FF6
79DC:  MOVLW  1D
79DE:  MOVWF  FF7
79E0:  CLRF   19
79E2:  BTFSC  FF2.7
79E4:  BSF    19.7
79E6:  BCF    FF2.7
79E8:  CALL   064E
79EC:  BTFSC  19.7
79EE:  BSF    FF2.7
79F0:  CLRF   19
79F2:  BTFSC  FF2.7
79F4:  BSF    19.7
79F6:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
79F8:  MOVLW  0A
79FA:  MOVLB  9
79FC:  MOVWF  xD3
79FE:  MOVLB  0
7A00:  CALL   0608
7A04:  BTFSC  19.7
7A06:  BSF    FF2.7
7A08:  CLRF   19
7A0A:  BTFSC  FF2.7
7A0C:  BSF    19.7
7A0E:  BCF    FF2.7
7A10:  MOVLW  0D
7A12:  MOVLB  9
7A14:  MOVWF  xD3
7A16:  MOVLB  0
7A18:  CALL   0608
7A1C:  BTFSC  19.7
7A1E:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
7A20:  MOVLW  10
7A22:  MOVWF  FF6
7A24:  MOVLW  1E
7A26:  MOVWF  FF7
7A28:  CLRF   19
7A2A:  BTFSC  FF2.7
7A2C:  BSF    19.7
7A2E:  BCF    FF2.7
7A30:  CALL   064E
7A34:  BTFSC  19.7
7A36:  BSF    FF2.7
7A38:  CLRF   19
7A3A:  BTFSC  FF2.7
7A3C:  BSF    19.7
7A3E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7A40:  MOVLW  0A
7A42:  MOVLB  9
7A44:  MOVWF  xD3
7A46:  MOVLB  0
7A48:  CALL   0608
7A4C:  BTFSC  19.7
7A4E:  BSF    FF2.7
7A50:  CLRF   19
7A52:  BTFSC  FF2.7
7A54:  BSF    19.7
7A56:  BCF    FF2.7
7A58:  MOVLW  0D
7A5A:  MOVLB  9
7A5C:  MOVWF  xD3
7A5E:  MOVLB  0
7A60:  CALL   0608
7A64:  BTFSC  19.7
7A66:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
7A68:  MOVLW  01
7A6A:  MOVLB  8
7A6C:  MOVWF  xCD
7A6E:  MOVLW  03
7A70:  MOVWF  xCE
7A72:  MOVLW  08
7A74:  MOVWF  xD0
7A76:  MOVLW  99
7A78:  MOVWF  xCF
7A7A:  MOVLB  0
7A7C:  CALL   5E04
....................           auto_sending = (unsigned int8)strtoi(temp); 
7A80:  MOVLW  08
7A82:  MOVLB  8
7A84:  MOVWF  xCE
7A86:  MOVLW  99
7A88:  MOVWF  xCD
7A8A:  MOVLB  0
7A8C:  CALL   635C
7A90:  MOVFF  01,360
7A94:  CLRF   19
7A96:  BTFSC  FF2.7
7A98:  BSF    19.7
7A9A:  BCF    FF2.7
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
7A9C:  MOVLB  9
7A9E:  CLRF   xC0
7AA0:  MOVLW  93
7AA2:  MOVWF  xBF
7AA4:  MOVFF  360,9C1
7AA8:  MOVLB  0
7AAA:  CALL   336C
7AAE:  BTFSC  19.7
7AB0:  BSF    FF2.7
7AB2:  CLRF   19
7AB4:  BTFSC  FF2.7
7AB6:  BSF    19.7
7AB8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7ABA:  MOVLW  0A
7ABC:  MOVLB  9
7ABE:  MOVWF  xD3
7AC0:  MOVLB  0
7AC2:  CALL   0608
7AC6:  BTFSC  19.7
7AC8:  BSF    FF2.7
7ACA:  CLRF   19
7ACC:  BTFSC  FF2.7
7ACE:  BSF    19.7
7AD0:  BCF    FF2.7
7AD2:  MOVLW  0D
7AD4:  MOVLB  9
7AD6:  MOVWF  xD3
7AD8:  MOVLB  0
7ADA:  CALL   0608
7ADE:  BTFSC  19.7
7AE0:  BSF    FF2.7
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
7AE2:  CLRF   FEA
7AE4:  MOVLW  41
7AE6:  MOVWF  FE9
7AE8:  MOVLW  00
7AEA:  CALL   027A
7AEE:  TBLRD*-
7AF0:  TBLRD*+
7AF2:  MOVF   FF5,W
7AF4:  MOVWF  FEE
7AF6:  IORLW  00
7AF8:  BNZ   7AF0
7AFA:  CLRF   19
7AFC:  BTFSC  FF2.7
7AFE:  BSF    19.7
7B00:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
7B02:  MOVLW  01
7B04:  MOVLB  9
7B06:  MOVWF  xAF
7B08:  MOVLW  4A
7B0A:  MOVWF  xAE
7B0C:  CLRF   xB1
7B0E:  MOVLW  41
7B10:  MOVWF  xB0
7B12:  MOVLB  0
7B14:  CALL   3DC4
7B18:  BTFSC  19.7
7B1A:  BSF    FF2.7
7B1C:  MOVF   01,F
7B1E:  BTFSS  FD8.2
7B20:  BRA    7DAA
....................       { 
....................          printf("h-> Help\n\r"); 
7B22:  MOVLW  30
7B24:  MOVWF  FF6
7B26:  MOVLW  1E
7B28:  MOVWF  FF7
7B2A:  CLRF   19
7B2C:  BTFSC  FF2.7
7B2E:  BSF    19.7
7B30:  BCF    FF2.7
7B32:  CALL   064E
7B36:  BTFSC  19.7
7B38:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
7B3A:  MOVLW  3C
7B3C:  MOVWF  FF6
7B3E:  MOVLW  1E
7B40:  MOVWF  FF7
7B42:  CLRF   19
7B44:  BTFSC  FF2.7
7B46:  BSF    19.7
7B48:  BCF    FF2.7
7B4A:  CALL   064E
7B4E:  BTFSC  19.7
7B50:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
7B52:  MOVLW  4E
7B54:  MOVWF  FF6
7B56:  MOVLW  1E
7B58:  MOVWF  FF7
7B5A:  CLRF   19
7B5C:  BTFSC  FF2.7
7B5E:  BSF    19.7
7B60:  BCF    FF2.7
7B62:  CALL   064E
7B66:  BTFSC  19.7
7B68:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
7B6A:  MOVLW  60
7B6C:  MOVWF  FF6
7B6E:  MOVLW  1E
7B70:  MOVWF  FF7
7B72:  CLRF   19
7B74:  BTFSC  FF2.7
7B76:  BSF    19.7
7B78:  BCF    FF2.7
7B7A:  CALL   064E
7B7E:  BTFSC  19.7
7B80:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
7B82:  MOVLW  80
7B84:  MOVWF  FF6
7B86:  MOVLW  1E
7B88:  MOVWF  FF7
7B8A:  CLRF   19
7B8C:  BTFSC  FF2.7
7B8E:  BSF    19.7
7B90:  BCF    FF2.7
7B92:  CALL   064E
7B96:  BTFSC  19.7
7B98:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
7B9A:  MOVLW  9C
7B9C:  MOVWF  FF6
7B9E:  MOVLW  1E
7BA0:  MOVWF  FF7
7BA2:  CLRF   19
7BA4:  BTFSC  FF2.7
7BA6:  BSF    19.7
7BA8:  BCF    FF2.7
7BAA:  CALL   064E
7BAE:  BTFSC  19.7
7BB0:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
7BB2:  MOVLW  AA
7BB4:  MOVWF  FF6
7BB6:  MOVLW  1E
7BB8:  MOVWF  FF7
7BBA:  CLRF   19
7BBC:  BTFSC  FF2.7
7BBE:  BSF    19.7
7BC0:  BCF    FF2.7
7BC2:  CALL   064E
7BC6:  BTFSC  19.7
7BC8:  BSF    FF2.7
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
7BCA:  MOVLW  B6
7BCC:  MOVWF  FF6
7BCE:  MOVLW  1E
7BD0:  MOVWF  FF7
7BD2:  CLRF   19
7BD4:  BTFSC  FF2.7
7BD6:  BSF    19.7
7BD8:  BCF    FF2.7
7BDA:  CALL   064E
7BDE:  BTFSC  19.7
7BE0:  BSF    FF2.7
7BE2:  CLRF   19
7BE4:  BTFSC  FF2.7
7BE6:  BSF    19.7
7BE8:  BCF    FF2.7
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
7BEA:  MOVLB  9
7BEC:  CLRF   xBD
7BEE:  MOVLW  7F
7BF0:  MOVWF  xBC
7BF2:  MOVLB  0
7BF4:  CALL   2E48
7BF8:  BTFSC  19.7
7BFA:  BSF    FF2.7
7BFC:  MOVFF  01,10C
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
7C00:  MOVLB  1
7C02:  MOVF   x0C,F
7C04:  BZ    7C24
7C06:  MOVLW  E2
7C08:  MOVWF  FF6
7C0A:  MOVLW  1E
7C0C:  MOVWF  FF7
7C0E:  CLRF   19
7C10:  BTFSC  FF2.7
7C12:  BSF    19.7
7C14:  BCF    FF2.7
7C16:  MOVLB  0
7C18:  CALL   064E
7C1C:  BTFSC  19.7
7C1E:  BSF    FF2.7
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
7C20:  BRA    7C3E
7C22:  MOVLB  1
7C24:  MOVLW  04
7C26:  MOVWF  FF6
7C28:  MOVLW  1F
7C2A:  MOVWF  FF7
7C2C:  CLRF   19
7C2E:  BTFSC  FF2.7
7C30:  BSF    19.7
7C32:  BCF    FF2.7
7C34:  MOVLB  0
7C36:  CALL   064E
7C3A:  BTFSC  19.7
7C3C:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
7C3E:  MOVLW  28
7C40:  MOVWF  FF6
7C42:  MOVLW  1F
7C44:  MOVWF  FF7
7C46:  CLRF   19
7C48:  BTFSC  FF2.7
7C4A:  BSF    19.7
7C4C:  BCF    FF2.7
7C4E:  CALL   064E
7C52:  BTFSC  19.7
7C54:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
7C56:  MOVLW  50
7C58:  MOVWF  FF6
7C5A:  MOVLW  1F
7C5C:  MOVWF  FF7
7C5E:  CLRF   19
7C60:  BTFSC  FF2.7
7C62:  BSF    19.7
7C64:  BCF    FF2.7
7C66:  CALL   064E
7C6A:  BTFSC  19.7
7C6C:  BSF    FF2.7
7C6E:  CLRF   19
7C70:  BTFSC  FF2.7
7C72:  BSF    19.7
7C74:  BCF    FF2.7
....................          printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
7C76:  MOVLB  9
7C78:  CLRF   xBD
7C7A:  MOVLW  95
7C7C:  MOVWF  xBC
7C7E:  MOVLB  0
7C80:  CALL   2E48
7C84:  BTFSC  19.7
7C86:  BSF    FF2.7
7C88:  MOVFF  01,8CD
7C8C:  MOVLW  6C
7C8E:  MOVWF  FF6
7C90:  MOVLW  1F
7C92:  MOVWF  FF7
7C94:  CLRF   19
7C96:  BTFSC  FF2.7
7C98:  BSF    19.7
7C9A:  BCF    FF2.7
7C9C:  MOVLW  08
7C9E:  MOVLB  9
7CA0:  MOVWF  xC7
7CA2:  MOVLB  0
7CA4:  CALL   15C6
7CA8:  BTFSC  19.7
7CAA:  BSF    FF2.7
7CAC:  CLRF   19
7CAE:  BTFSC  FF2.7
7CB0:  BSF    19.7
7CB2:  BCF    FF2.7
7CB4:  MOVFF  8CD,9B1
7CB8:  MOVLW  18
7CBA:  MOVLB  9
7CBC:  MOVWF  xB2
7CBE:  MOVLB  0
7CC0:  CALL   16DA
7CC4:  BTFSC  19.7
7CC6:  BSF    FF2.7
7CC8:  MOVLW  76
7CCA:  MOVWF  FF6
7CCC:  MOVLW  1F
7CCE:  MOVWF  FF7
7CD0:  CLRF   19
7CD2:  BTFSC  FF2.7
7CD4:  BSF    19.7
7CD6:  BCF    FF2.7
7CD8:  MOVLW  17
7CDA:  MOVLB  9
7CDC:  MOVWF  xC7
7CDE:  MOVLB  0
7CE0:  CALL   15C6
7CE4:  BTFSC  19.7
7CE6:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");     
7CE8:  MOVLW  8E
7CEA:  MOVWF  FF6
7CEC:  MOVLW  1F
7CEE:  MOVWF  FF7
7CF0:  CLRF   19
7CF2:  BTFSC  FF2.7
7CF4:  BSF    19.7
7CF6:  BCF    FF2.7
7CF8:  CALL   064E
7CFC:  BTFSC  19.7
7CFE:  BSF    FF2.7
7D00:  CLRF   19
7D02:  BTFSC  FF2.7
7D04:  BSF    19.7
7D06:  BCF    FF2.7
....................          printf("KBtime %d -> Keyboard's Timeout\n\r",read_ext_eeprom(KB_time));  
7D08:  MOVLB  9
7D0A:  CLRF   xBD
7D0C:  MOVLW  7E
7D0E:  MOVWF  xBC
7D10:  MOVLB  0
7D12:  CALL   2E48
7D16:  BTFSC  19.7
7D18:  BSF    FF2.7
7D1A:  MOVFF  01,8CD
7D1E:  MOVLW  A8
7D20:  MOVWF  FF6
7D22:  MOVLW  1F
7D24:  MOVWF  FF7
7D26:  CLRF   19
7D28:  BTFSC  FF2.7
7D2A:  BSF    19.7
7D2C:  BCF    FF2.7
7D2E:  MOVLW  07
7D30:  MOVLB  9
7D32:  MOVWF  xC7
7D34:  MOVLB  0
7D36:  CALL   15C6
7D3A:  BTFSC  19.7
7D3C:  BSF    FF2.7
7D3E:  CLRF   19
7D40:  BTFSC  FF2.7
7D42:  BSF    19.7
7D44:  BCF    FF2.7
7D46:  MOVFF  8CD,9B1
7D4A:  MOVLW  18
7D4C:  MOVLB  9
7D4E:  MOVWF  xB2
7D50:  MOVLB  0
7D52:  CALL   16DA
7D56:  BTFSC  19.7
7D58:  BSF    FF2.7
7D5A:  MOVLW  B1
7D5C:  MOVWF  FF6
7D5E:  MOVLW  1F
7D60:  MOVWF  FF7
7D62:  CLRF   19
7D64:  BTFSC  FF2.7
7D66:  BSF    19.7
7D68:  BCF    FF2.7
7D6A:  MOVLW  18
7D6C:  MOVLB  9
7D6E:  MOVWF  xC7
7D70:  MOVLB  0
7D72:  CALL   15C6
7D76:  BTFSC  19.7
7D78:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
7D7A:  MOVLW  CA
7D7C:  MOVWF  FF6
7D7E:  MOVLW  1F
7D80:  MOVWF  FF7
7D82:  CLRF   19
7D84:  BTFSC  FF2.7
7D86:  BSF    19.7
7D88:  BCF    FF2.7
7D8A:  CALL   064E
7D8E:  BTFSC  19.7
7D90:  BSF    FF2.7
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
7D92:  MOVLW  FA
7D94:  MOVWF  FF6
7D96:  MOVLW  1F
7D98:  MOVWF  FF7
7D9A:  CLRF   19
7D9C:  BTFSC  FF2.7
7D9E:  BSF    19.7
7DA0:  BCF    FF2.7
7DA2:  CALL   064E
7DA6:  BTFSC  19.7
7DA8:  BSF    FF2.7
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
7DAA:  CLRF   FEA
7DAC:  MOVLW  41
7DAE:  MOVWF  FE9
7DB0:  MOVLW  00
7DB2:  CALL   028C
7DB6:  TBLRD*-
7DB8:  TBLRD*+
7DBA:  MOVF   FF5,W
7DBC:  MOVWF  FEE
7DBE:  IORLW  00
7DC0:  BNZ   7DB8
7DC2:  CLRF   19
7DC4:  BTFSC  FF2.7
7DC6:  BSF    19.7
7DC8:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2))  
7DCA:  MOVLW  01
7DCC:  MOVLB  9
7DCE:  MOVWF  xAF
7DD0:  MOVLW  4A
7DD2:  MOVWF  xAE
7DD4:  CLRF   xB1
7DD6:  MOVLW  41
7DD8:  MOVWF  xB0
7DDA:  MOVLB  0
7DDC:  CALL   3DC4
7DE0:  BTFSC  19.7
7DE2:  BSF    FF2.7
7DE4:  MOVF   01,F
7DE6:  BTFSS  FD8.2
7DE8:  BRA    7F3C
....................       { 
....................          fprintf(COM2,"old password:"); 
7DEA:  MOVLW  22
7DEC:  MOVWF  FF6
7DEE:  MOVLW  20
7DF0:  MOVWF  FF7
7DF2:  CLRF   19
7DF4:  BTFSC  FF2.7
7DF6:  BSF    19.7
7DF8:  BCF    FF2.7
7DFA:  CALL   064E
7DFE:  BTFSC  19.7
7E00:  BSF    FF2.7
7E02:  CLRF   19
7E04:  BTFSC  FF2.7
7E06:  BSF    19.7
7E08:  BCF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
7E0A:  MOVLB  9
7E0C:  CLRF   xAE
7E0E:  MOVLW  14
7E10:  MOVWF  xAF
7E12:  CLRF   xB1
7E14:  MOVLW  55
7E16:  MOVWF  xB0
7E18:  MOVLB  0
7E1A:  CALL   3D76
7E1E:  BTFSC  19.7
7E20:  BSF    FF2.7
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
7E22:  MOVLW  02
7E24:  MOVLB  8
7E26:  MOVWF  xCD
7E28:  MOVLW  14
7E2A:  MOVWF  xCE
7E2C:  CLRF   xD0
7E2E:  MOVLW  69
7E30:  MOVWF  xCF
7E32:  MOVLB  0
7E34:  CALL   5E04
7E38:  CLRF   19
7E3A:  BTFSC  FF2.7
7E3C:  BSF    19.7
7E3E:  BCF    FF2.7
....................          if(!stringcomp(entpassword,password)) 
7E40:  MOVLB  9
7E42:  CLRF   xAF
7E44:  MOVLW  69
7E46:  MOVWF  xAE
7E48:  CLRF   xB1
7E4A:  MOVLW  55
7E4C:  MOVWF  xB0
7E4E:  MOVLB  0
7E50:  CALL   3DC4
7E54:  BTFSC  19.7
7E56:  BSF    FF2.7
7E58:  MOVF   01,F
7E5A:  BNZ   7F24
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
7E5C:  MOVLW  30
7E5E:  MOVWF  FF6
7E60:  MOVLW  20
7E62:  MOVWF  FF7
7E64:  CLRF   19
7E66:  BTFSC  FF2.7
7E68:  BSF    19.7
7E6A:  BCF    FF2.7
7E6C:  CALL   064E
7E70:  BTFSC  19.7
7E72:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
7E74:  MOVLW  02
7E76:  MOVLB  8
7E78:  MOVWF  xCD
7E7A:  MOVLW  14
7E7C:  MOVWF  xCE
7E7E:  CLRF   xD0
7E80:  MOVLW  69
7E82:  MOVWF  xCF
7E84:  MOVLB  0
7E86:  CALL   5E04
....................             fprintf(COM2,"\n\ragain:"); 
7E8A:  MOVLW  38
7E8C:  MOVWF  FF6
7E8E:  MOVLW  20
7E90:  MOVWF  FF7
7E92:  CLRF   19
7E94:  BTFSC  FF2.7
7E96:  BSF    19.7
7E98:  BCF    FF2.7
7E9A:  CALL   064E
7E9E:  BTFSC  19.7
7EA0:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
7EA2:  MOVLW  02
7EA4:  MOVLB  8
7EA6:  MOVWF  xCD
7EA8:  MOVLW  14
7EAA:  MOVWF  xCE
7EAC:  CLRF   xD0
7EAE:  MOVLW  55
7EB0:  MOVWF  xCF
7EB2:  MOVLB  0
7EB4:  CALL   5E04
7EB8:  CLRF   19
7EBA:  BTFSC  FF2.7
7EBC:  BSF    19.7
7EBE:  BCF    FF2.7
....................             if(!stringcomp(entpassword,password)) 
7EC0:  MOVLB  9
7EC2:  CLRF   xAF
7EC4:  MOVLW  69
7EC6:  MOVWF  xAE
7EC8:  CLRF   xB1
7ECA:  MOVLW  55
7ECC:  MOVWF  xB0
7ECE:  MOVLB  0
7ED0:  CALL   3DC4
7ED4:  BTFSC  19.7
7ED6:  BSF    FF2.7
7ED8:  MOVF   01,F
7EDA:  BNZ   7F0A
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
7EDC:  MOVLB  8
7EDE:  CLRF   xE2
7EE0:  MOVLW  14
7EE2:  MOVWF  xE3
7EE4:  CLRF   xE5
7EE6:  MOVLW  55
7EE8:  MOVWF  xE4
7EEA:  MOVLB  0
7EEC:  CALL   5A8C
....................                fprintf(COM2,"\n\rOK\n\r");    
7EF0:  MOVLW  42
7EF2:  MOVWF  FF6
7EF4:  MOVLW  20
7EF6:  MOVWF  FF7
7EF8:  CLRF   19
7EFA:  BTFSC  FF2.7
7EFC:  BSF    19.7
7EFE:  BCF    FF2.7
7F00:  CALL   064E
7F04:  BTFSC  19.7
7F06:  BSF    FF2.7
....................             } 
....................                else 
7F08:  BRA    7F22
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
7F0A:  MOVLW  4A
7F0C:  MOVWF  FF6
7F0E:  MOVLW  20
7F10:  MOVWF  FF7
7F12:  CLRF   19
7F14:  BTFSC  FF2.7
7F16:  BSF    19.7
7F18:  BCF    FF2.7
7F1A:  CALL   064E
7F1E:  BTFSC  19.7
7F20:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
7F22:  BRA    7F3C
....................             { 
....................                fprintf(COM2," X\n\r"); 
7F24:  MOVLW  52
7F26:  MOVWF  FF6
7F28:  MOVLW  20
7F2A:  MOVWF  FF7
7F2C:  CLRF   19
7F2E:  BTFSC  FF2.7
7F30:  BSF    19.7
7F32:  BCF    FF2.7
7F34:  CALL   064E
7F38:  BTFSC  19.7
7F3A:  BSF    FF2.7
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
7F3C:  CLRF   FEA
7F3E:  MOVLW  41
7F40:  MOVWF  FE9
7F42:  MOVLW  00
7F44:  CALL   02A6
7F48:  TBLRD*-
7F4A:  TBLRD*+
7F4C:  MOVF   FF5,W
7F4E:  MOVWF  FEE
7F50:  IORLW  00
7F52:  BNZ   7F4A
7F54:  CLRF   19
7F56:  BTFSC  FF2.7
7F58:  BSF    19.7
7F5A:  BCF    FF2.7
....................       if(!stringcomp(buffer_uart,buffer2)) 
7F5C:  MOVLW  01
7F5E:  MOVLB  9
7F60:  MOVWF  xAF
7F62:  MOVLW  4A
7F64:  MOVWF  xAE
7F66:  CLRF   xB1
7F68:  MOVLW  41
7F6A:  MOVWF  xB0
7F6C:  MOVLB  0
7F6E:  CALL   3DC4
7F72:  BTFSC  19.7
7F74:  BSF    FF2.7
7F76:  MOVF   01,F
7F78:  BTFSS  FD8.2
7F7A:  BRA    8086
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
7F7C:  MOVLW  58
7F7E:  MOVWF  FF6
7F80:  MOVLW  20
7F82:  MOVWF  FF7
7F84:  CLRF   19
7F86:  BTFSC  FF2.7
7F88:  BSF    19.7
7F8A:  BCF    FF2.7
7F8C:  CALL   064E
7F90:  BTFSC  19.7
7F92:  BSF    FF2.7
7F94:  CLRF   19
7F96:  BTFSC  FF2.7
7F98:  BSF    19.7
7F9A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7F9C:  MOVLW  0A
7F9E:  MOVLB  9
7FA0:  MOVWF  xD3
7FA2:  MOVLB  0
7FA4:  CALL   0608
7FA8:  BTFSC  19.7
7FAA:  BSF    FF2.7
7FAC:  CLRF   19
7FAE:  BTFSC  FF2.7
7FB0:  BSF    19.7
7FB2:  BCF    FF2.7
7FB4:  MOVLW  0D
7FB6:  MOVLB  9
7FB8:  MOVWF  xD3
7FBA:  MOVLB  0
7FBC:  CALL   0608
7FC0:  BTFSC  19.7
7FC2:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
7FC4:  MOVLW  78
7FC6:  MOVWF  FF6
7FC8:  MOVLW  20
7FCA:  MOVWF  FF7
7FCC:  CLRF   19
7FCE:  BTFSC  FF2.7
7FD0:  BSF    19.7
7FD2:  BCF    FF2.7
7FD4:  CALL   064E
7FD8:  BTFSC  19.7
7FDA:  BSF    FF2.7
7FDC:  CLRF   19
7FDE:  BTFSC  FF2.7
7FE0:  BSF    19.7
7FE2:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
7FE4:  MOVLW  0A
7FE6:  MOVLB  9
7FE8:  MOVWF  xD3
7FEA:  MOVLB  0
7FEC:  CALL   0608
7FF0:  BTFSC  19.7
7FF2:  BSF    FF2.7
7FF4:  CLRF   19
7FF6:  BTFSC  FF2.7
7FF8:  BSF    19.7
7FFA:  BCF    FF2.7
7FFC:  MOVLW  0D
7FFE:  MOVLB  9
8000:  MOVWF  xD3
8002:  MOVLB  0
8004:  CALL   0608
8008:  BTFSC  19.7
800A:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
800C:  MOVLW  01
800E:  MOVLB  8
8010:  MOVWF  xCD
8012:  MOVLW  03
8014:  MOVWF  xCE
8016:  MOVLW  08
8018:  MOVWF  xD0
801A:  MOVLW  99
801C:  MOVWF  xCF
801E:  MOVLB  0
8020:  CALL   5E04
....................           debugmode = (unsigned int8)strtoi(temp); 
8024:  MOVLW  08
8026:  MOVLB  8
8028:  MOVWF  xCE
802A:  MOVLW  99
802C:  MOVWF  xCD
802E:  MOVLB  0
8030:  CALL   635C
8034:  MOVFF  01,869
8038:  CLRF   19
803A:  BTFSC  FF2.7
803C:  BSF    19.7
803E:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
8040:  MOVLB  9
8042:  CLRF   xC0
8044:  MOVLW  92
8046:  MOVWF  xBF
8048:  MOVFF  869,9C1
804C:  MOVLB  0
804E:  CALL   336C
8052:  BTFSC  19.7
8054:  BSF    FF2.7
8056:  CLRF   19
8058:  BTFSC  FF2.7
805A:  BSF    19.7
805C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
805E:  MOVLW  0A
8060:  MOVLB  9
8062:  MOVWF  xD3
8064:  MOVLB  0
8066:  CALL   0608
806A:  BTFSC  19.7
806C:  BSF    FF2.7
806E:  CLRF   19
8070:  BTFSC  FF2.7
8072:  BSF    19.7
8074:  BCF    FF2.7
8076:  MOVLW  0D
8078:  MOVLB  9
807A:  MOVWF  xD3
807C:  MOVLB  0
807E:  CALL   0608
8082:  BTFSC  19.7
8084:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
8086:  GOTO   8730 (RETURN)
.................... //=============================================== 
....................  
....................  
.................... //========================= 
.................... int8 receiver_state=0,booting_done=0; 
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... {   
....................    char c; 
....................    //restart_wdt(); 
....................    //disable_interrupts(INT_TIMER0); 
....................    //set_timer0(0);   
....................    //disable_interrupts(INT_RDA);   
....................    c=fgetc(COM1); 
*
2098:  BTFSS  F9E.5
209A:  BRA    2098
209C:  MOVFF  FAF,8F1
20A0:  MOVLB  8
....................    //fprintf(COM2,"%c",c);   
....................    output_toggle(PIN_C2); 
20A2:  BCF    F94.2
20A4:  BTG    F8B.2
....................    if(booting_done) 
20A6:  MOVF   x8B,F
20A8:  BZ    20E6
....................    { 
....................       buffer_uart[UART_index++]=c; 
20AA:  MOVLB  1
20AC:  MOVF   xAE,W
20AE:  INCF   xAE,F
20B0:  CLRF   03
20B2:  ADDLW  4A
20B4:  MOVWF  FE9
20B6:  MOVLW  01
20B8:  ADDWFC 03,W
20BA:  MOVWF  FEA
20BC:  MOVFF  8F1,FEF
....................       if(UART_index>=99) UART_index=0; 
20C0:  MOVF   xAE,W
20C2:  SUBLW  62
20C4:  BTFSS  FD8.0
20C6:  CLRF   xAE
....................       //============================= 
....................       output_toggle(PIN_C2); 
20C8:  BCF    F94.2
20CA:  BTG    F8B.2
....................       if(receiver_state==0) 
20CC:  MOVLB  8
20CE:  MOVF   x8A,F
20D0:  BNZ   20E6
....................       { 
....................          timing_wait=300; 
20D2:  MOVLW  01
20D4:  MOVLB  3
20D6:  MOVWF  x5F
20D8:  MOVLW  2C
20DA:  MOVWF  x5E
....................          SIM_state=data_analyze; 
20DC:  MOVLW  0D
20DE:  MOVWF  x5C
....................          count_polling=0; 
20E0:  CLRF   x5B
20E2:  CLRF   x5A
20E4:  MOVLB  8
....................       } 
....................       //============================= 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................    } 
....................    return; 
....................    //enable_interrupts(INT_TIMER0); 
.................... } 
.................... //========================= 
20E6:  BCF    F9E.5
20E8:  MOVLB  0
20EA:  GOTO   0084
.................... #INT_TIMER1 
.................... void timer1() 
.................... { 
....................    output_toggle(PIN_C2); 
20EE:  BCF    F94.2
20F0:  BTG    F8B.2
....................    set_timer1(0xffff-50); 
20F2:  SETF   FCF
20F4:  MOVLW  CD
20F6:  MOVWF  FCE
.................... } 
.................... //========================== 
20F8:  BCF    F9E.0
20FA:  GOTO   0084
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
*
47CC:  MOVLB  8
47CE:  CLRF   xF2
47D0:  CLRF   xF1
....................    static int16 lastlen; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    int16 len=0,addr_dat,buf; 
....................    int8 temp,i,strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
47D2:  MOVLB  1
47D4:  MOVF   x0C,F
47D6:  BZ    4812
....................    { 
....................       if(count_kp<500)count_kp++; 
47D8:  MOVF   x0F,W
47DA:  SUBLW  01
47DC:  BNC   47EC
47DE:  BNZ   47E6
47E0:  MOVF   x0E,W
47E2:  SUBLW  F3
47E4:  BNC   47EC
47E6:  INCF   x0E,F
47E8:  BTFSC  FD8.2
47EA:  INCF   x0F,F
....................       if(count_kp==500) 
47EC:  MOVF   x0E,W
47EE:  SUBLW  F4
47F0:  BNZ   4812
47F2:  DECFSZ x0F,W
47F4:  BRA    4812
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
47F6:  MOVLW  76
47F8:  MOVWF  FF6
47FA:  MOVLW  58
47FC:  MOVWF  FF7
47FE:  MOVLB  0
4800:  CALL   064E
....................             keyprss_off; 
4804:  BCF    F92.7
4806:  BCF    F89.7
....................             kp_st=0;     
4808:  MOVLB  1
480A:  CLRF   x0D
....................             count_kp++; 
480C:  INCF   x0E,F
480E:  BTFSC  FD8.2
4810:  INCF   x0F,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
4812:  DECFSZ x08,W
4814:  BRA    4830
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
4816:  MOVLB  8
4818:  MOVF   x75,F
481A:  BNZ   4824
481C:  MOVLB  0
481E:  CALL   20FE
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
4822:  BRA    482E
4824:  MOVLB  0
4826:  CALL   2B48
482A:  MOVFF  01,8F7
482E:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
4830:  DECFSZ x09,W
4832:  BRA    484C
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
4834:  MOVLB  8
4836:  MOVF   x75,F
4838:  BNZ   4842
483A:  MOVLB  0
483C:  CALL   20FE
....................          else temp=kbd_getc_slv(); 
4840:  BRA    484C
4842:  MOVLB  0
4844:  CALL   2B48
4848:  MOVFF  01,8F7
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
484C:  MOVLB  8
484E:  MOVF   x5A,F
4850:  BNZ   4870
4852:  MOVF   x59,F
4854:  BNZ   4870
4856:  MOVF   x58,F
4858:  BNZ   4870
485A:  MOVF   x57,W
485C:  SUBLW  04
485E:  BNC   4870
4860:  MOVLW  01
4862:  ADDWF  x57,F
4864:  BTFSC  FD8.0
4866:  INCF   x58,F
4868:  BTFSC  FD8.2
486A:  INCF   x59,F
486C:  BTFSC  FD8.2
486E:  INCF   x5A,F
....................   if(mcr_timeout==5) 
4870:  MOVF   x57,W
4872:  SUBLW  05
4874:  BNZ   48D0
4876:  MOVF   x58,F
4878:  BNZ   48D0
487A:  MOVF   x59,F
487C:  BNZ   48D0
487E:  MOVF   x5A,F
4880:  BNZ   48D0
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
4882:  DECFSZ x6D,W
4884:  BRA    488E
4886:  MOVLB  0
4888:  GOTO   34F0
488C:  MOVLB  8
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
488E:  MOVLW  03
4890:  MOVWF  FEA
4892:  MOVLW  D9
4894:  MOVWF  FE9
4896:  CLRF   00
4898:  MOVLW  03
489A:  MOVWF  02
489C:  MOVLW  52
489E:  MOVWF  01
48A0:  MOVLB  0
48A2:  CALL   3968
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
48A6:  MOVLW  07
48A8:  MOVWF  FEA
48AA:  MOVLW  2B
48AC:  MOVWF  FE9
48AE:  CLRF   00
48B0:  MOVLW  01
48B2:  MOVWF  02
48B4:  MOVLW  2C
48B6:  MOVWF  01
48B8:  CALL   3968
....................       //debug_card(); 
....................       count_reading_error=0; 
48BC:  MOVLB  8
48BE:  CLRF   x6E
....................       mcr_timeout++;   
48C0:  MOVLW  01
48C2:  ADDWF  x57,F
48C4:  BTFSC  FD8.0
48C6:  INCF   x58,F
48C8:  BTFSC  FD8.2
48CA:  INCF   x59,F
48CC:  BTFSC  FD8.2
48CE:  INCF   x5A,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
48D0:  MOVLB  9
48D2:  CLRF   xBD
48D4:  MOVLW  94
48D6:  MOVWF  xBC
48D8:  MOVLB  0
48DA:  CALL   2E48
48DE:  MOVFF  01,142
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
48E2:  MOVLW  02
48E4:  MOVLB  9
48E6:  MOVWF  xB4
48E8:  MOVLW  BC
48EA:  MOVWF  xB3
48EC:  CLRF   xB6
48EE:  MOVFF  142,9B5
48F2:  MOVLB  0
48F4:  CALL   2F40
48F8:  MOVFF  02,03
48FC:  MOVF   xFC,W
48FE:  SUBWF  02,W
4900:  BNC   4910
4902:  BNZ   490A
4904:  MOVF   01,W
4906:  SUBWF  xFB,W
4908:  BC    4910
490A:  INCF   xFB,F
490C:  BTFSC  FD8.2
490E:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
4910:  MOVLW  02
4912:  MOVLB  9
4914:  MOVWF  xB4
4916:  MOVLW  BC
4918:  MOVWF  xB3
491A:  CLRF   xB6
491C:  MOVFF  142,9B5
4920:  MOVLB  0
4922:  CALL   2F40
4926:  MOVFF  02,03
492A:  MOVF   01,W
492C:  SUBWF  xFB,W
492E:  BNZ   49DA
4930:  MOVF   03,W
4932:  SUBWF  xFC,W
4934:  BNZ   49DA
....................   { 
....................       buf=get_countcard(); 
4936:  CALL   2EF0
493A:  MOVFF  02,8F6
493E:  MOVFF  01,8F5
....................       if(numdata*buf<EEPROM_SIZE) 
4942:  MOVLB  9
4944:  CLRF   xB4
4946:  MOVLW  7C
4948:  MOVWF  xB3
494A:  MOVFF  8F6,9B6
494E:  MOVFF  8F5,9B5
4952:  MOVLB  0
4954:  CALL   2F40
4958:  MOVFF  02,9AF
495C:  MOVFF  01,9AE
4960:  MOVLB  9
4962:  MOVF   02,W
4964:  SUBLW  AA
4966:  BNC   4992
4968:  BNZ   4970
496A:  MOVF   xAE,W
496C:  SUBLW  45
496E:  BNC   4992
....................       { 
....................          save_key_new(); 
4970:  MOVLB  0
4972:  GOTO   3982
....................          buf=buf+1; 
4976:  MOVLW  01
4978:  MOVLB  8
497A:  ADDWF  xF5,F
497C:  MOVLW  00
497E:  ADDWFC xF6,F
....................          save_coutcard(buf); 
4980:  MOVFF  8F6,9B1
4984:  MOVFF  8F5,9B0
4988:  MOVLB  0
498A:  CALL   3AC8
....................       } 
....................          else 
498E:  BRA    49A4
4990:  MOVLB  9
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
4992:  MOVLW  86
4994:  MOVWF  FF6
4996:  MOVLW  58
4998:  MOVWF  FF7
499A:  MOVLB  0
499C:  CALL   064E
....................             return; 
49A0:  GOTO   5838
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
49A4:  MOVLW  96
49A6:  MOVWF  FF6
49A8:  MOVLW  58
49AA:  MOVWF  FF7
49AC:  CALL   064E
....................       fprintf(COM2,"\r\nnext transaction\r\n");  
49B0:  MOVLW  A6
49B2:  MOVWF  FF6
49B4:  MOVLW  58
49B6:  MOVWF  FF7
49B8:  CALL   064E
....................       data_avai=0; 
49BC:  MOVLB  8
49BE:  CLRF   x6C
....................       charac_timeout++; 
49C0:  MOVLB  0
49C2:  INCF   xFB,F
49C4:  BTFSC  FD8.2
49C6:  INCF   xFC,F
....................       enable_getpin=0; 
49C8:  MOVLB  1
49CA:  CLRF   x09
....................       //dis_getpin; 
....................       output_low(PIN_C2); 
49CC:  BCF    F94.2
49CE:  BCF    F8B.2
....................       #if defined(SIM900) 
....................        if(auto_sending==1)SIM_state=autosending; 
49D0:  MOVLB  3
49D2:  DECFSZ x60,W
49D4:  BRA    49DA
49D6:  MOVLW  0B
49D8:  MOVWF  x5C
....................       #endif 
....................   } 
....................   //================================= 
....................   #if defined(SIM900) 
....................    count_polling++; 
49DA:  MOVLB  3
49DC:  INCF   x5A,F
49DE:  BTFSC  FD8.2
49E0:  INCF   x5B,F
....................    if(count_polling>=timing_wait) 
49E2:  MOVF   x5F,W
49E4:  SUBWF  x5B,W
49E6:  BTFSS  FD8.0
49E8:  GOTO   583A
49EC:  BNZ   49F8
49EE:  MOVF   x5E,W
49F0:  SUBWF  x5A,W
49F2:  BTFSS  FD8.0
49F4:  GOTO   583A
....................    { 
....................       count_polling=0; 
49F8:  CLRF   x5B
49FA:  CLRF   x5A
....................       switch(SIM_state) 
....................       { 
49FC:  MOVLW  01
49FE:  SUBWF  x5C,W
4A00:  ADDLW  F3
4A02:  BTFSC  FD8.0
4A04:  GOTO   583A
4A08:  ADDLW  0D
4A0A:  MOVLB  0
4A0C:  GOTO   5842
....................          case reading_sms_cmd:             
....................             cards=get_countcard(); 
4A10:  CALL   2EF0
4A14:  MOVFF  02,891
4A18:  MOVFF  01,890
....................             receiver_state=1; 
4A1C:  MOVLW  01
4A1E:  MOVLB  8
4A20:  MOVWF  x8A
....................             memset(buffer_uart,0,sizeof(buffer_uart));  
4A22:  MOVWF  FEA
4A24:  MOVLW  4A
4A26:  MOVWF  FE9
4A28:  CLRF   00
4A2A:  CLRF   02
4A2C:  MOVLW  64
4A2E:  MOVWF  01
4A30:  MOVLB  0
4A32:  CALL   3968
....................             memset(mobilenumb,0,sizeof(mobilenumb));  
4A36:  MOVLW  03
4A38:  MOVWF  FEA
4A3A:  MOVLW  40
4A3C:  MOVWF  FE9
4A3E:  CLRF   00
4A40:  CLRF   02
4A42:  MOVLW  1A
4A44:  MOVWF  01
4A46:  CALL   3968
....................             fprintf(COM2,"reading_sms...\n\r"); 
4A4A:  MOVLW  BC
4A4C:  MOVWF  FF6
4A4E:  MOVLW  58
4A50:  MOVWF  FF7
4A52:  CALL   064E
....................             #ASM BCF    0xF94.7 #ENDASM                   
4A56:  BCF    F94.7
....................                fprintf(COM1,"AT+CMGR=1\r\n"); 
4A58:  MOVLW  CE
4A5A:  MOVWF  FF6
4A5C:  MOVLW  58
4A5E:  MOVWF  FF7
4A60:  CALL   3B02
....................             #ASM BSF    0xF94.7 #ENDASM 
4A64:  BSF    F94.7
....................             //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................             SIM_state=MSG_avai; 
4A66:  MOVLW  02
4A68:  MOVLB  3
4A6A:  MOVWF  x5C
....................             UART_index=0; 
4A6C:  MOVLB  1
4A6E:  CLRF   xAE
....................             timing_wait=200; 
4A70:  MOVLB  3
4A72:  CLRF   x5F
4A74:  MOVLW  C8
4A76:  MOVWF  x5E
....................             //fprintf(COM2,"device has %lu charactions\n\r",cards); 
....................          break; 
4A78:  GOTO   583A
....................          case MSG_avai: 
....................             //fprintf(COM2,"MSG_avai...\n\r"); 
....................             temp=checking_msg_avai(); 
4A7C:  GOTO   3B24
4A80:  MOVFF  01,8F7
....................             if(temp==1) SIM_state=reading_sms_cmd; 
4A84:  MOVLB  8
4A86:  DECFSZ xF7,W
4A88:  BRA    4A92
4A8A:  MOVLW  01
4A8C:  MOVLB  3
4A8E:  MOVWF  x5C
....................             else SIM_state=analyze_sms;  
4A90:  BRA    4A98
4A92:  MOVLW  03
4A94:  MOVLB  3
4A96:  MOVWF  x5C
....................             //fprintf(COM2,"\r\ntemp=%d\r\n",temp); 
....................             timing_wait=100; 
4A98:  CLRF   x5F
4A9A:  MOVLW  64
4A9C:  MOVWF  x5E
....................          break; 
4A9E:  GOTO   583A
....................          case analyze_sms: 
....................             //fprintf(COM2,"analyze_sms...\n\r");  
....................             del_buf(20,msg_buffer1); 
4AA2:  MOVLW  14
4AA4:  MOVLB  9
4AA6:  MOVWF  xBD
4AA8:  MOVLW  02
4AAA:  MOVWF  xBF
4AAC:  MOVLW  FA
4AAE:  MOVWF  xBE
4AB0:  MOVLB  0
4AB2:  CALL   2F62
....................             del_buf(50,msg_buffer2); 
4AB6:  MOVLW  32
4AB8:  MOVLB  9
4ABA:  MOVWF  xBD
4ABC:  MOVLW  03
4ABE:  MOVWF  xBF
4AC0:  MOVLW  0E
4AC2:  MOVWF  xBE
4AC4:  MOVLB  0
4AC6:  CALL   2F62
....................             del_buf(50,sim_bug); 
4ACA:  MOVLW  32
4ACC:  MOVLB  9
4ACE:  MOVWF  xBD
4AD0:  MOVLW  02
4AD2:  MOVWF  xBF
4AD4:  MOVLW  C8
4AD6:  MOVWF  xBE
4AD8:  MOVLB  0
4ADA:  CALL   2F62
....................             analyzing_msg(sim_bug,mobilenumb); 
4ADE:  MOVLW  02
4AE0:  MOVLB  9
4AE2:  MOVWF  xAF
4AE4:  MOVLW  C8
4AE6:  MOVWF  xAE
4AE8:  MOVLW  03
4AEA:  MOVWF  xB1
4AEC:  MOVLW  40
4AEE:  MOVWF  xB0
4AF0:  MOVLB  0
4AF2:  GOTO   3B6C
....................             memset(buffer_uart,0,sizeof(buffer_uart));  
4AF6:  MOVLW  01
4AF8:  MOVWF  FEA
4AFA:  MOVLW  4A
4AFC:  MOVWF  FE9
4AFE:  CLRF   00
4B00:  CLRF   02
4B02:  MOVLW  64
4B04:  MOVWF  01
4B06:  CALL   3968
....................             SIM_state=checking_MN; 
4B0A:  MOVLW  04
4B0C:  MOVLB  3
4B0E:  MOVWF  x5C
....................             timing_wait=300; 
4B10:  MOVLW  01
4B12:  MOVWF  x5F
4B14:  MOVLW  2C
4B16:  MOVWF  x5E
....................          break; 
4B18:  GOTO   583A
....................          case checking_MN: 
....................             fprintf(COM2,"\n\rMobile phone number is "); 
4B1C:  MOVLW  DA
4B1E:  MOVWF  FF6
4B20:  MOVLW  58
4B22:  MOVWF  FF7
4B24:  CALL   064E
....................             for(i=0;i<20;i++) fprintf(COM2,"%c",mobilenumb[i]);   
4B28:  MOVLB  8
4B2A:  CLRF   xF8
4B2C:  MOVF   xF8,W
4B2E:  SUBLW  13
4B30:  BNC   4B54
4B32:  CLRF   03
4B34:  MOVF   xF8,W
4B36:  ADDLW  40
4B38:  MOVWF  FE9
4B3A:  MOVLW  03
4B3C:  ADDWFC 03,W
4B3E:  MOVWF  FEA
4B40:  MOVFF  FEF,9AE
4B44:  MOVFF  9AE,9D3
4B48:  MOVLB  0
4B4A:  CALL   0608
4B4E:  MOVLB  8
4B50:  INCF   xF8,F
4B52:  BRA    4B2C
....................            EEPROM_read(strobe_mobile_num1,20,msg_buffer1);  
4B54:  MOVLW  55
4B56:  MOVLB  9
4B58:  MOVWF  xAE
4B5A:  MOVLW  14
4B5C:  MOVWF  xAF
4B5E:  MOVLW  02
4B60:  MOVWF  xB1
4B62:  MOVLW  FA
4B64:  MOVWF  xB0
4B66:  MOVLB  0
4B68:  CALL   3D76
....................            //strcpy(msg_buffer1,"+84903219082"); 
....................            //strcpy(msg_buffer1,"+16612891316");//+16612891316 
....................            if(!stringcomp(mobilenumb,msg_buffer1))   
4B6C:  MOVLW  03
4B6E:  MOVLB  9
4B70:  MOVWF  xAF
4B72:  MOVLW  40
4B74:  MOVWF  xAE
4B76:  MOVLW  02
4B78:  MOVWF  xB1
4B7A:  MOVLW  FA
4B7C:  MOVWF  xB0
4B7E:  MOVLB  0
4B80:  CALL   3DC4
4B84:  MOVF   01,F
4B86:  BNZ   4B9E
....................            { 
....................                fprintf(COM2,"\n\r checking phone number is done\n\r");  
4B88:  MOVLW  F4
4B8A:  MOVWF  FF6
4B8C:  MOVLW  58
4B8E:  MOVWF  FF7
4B90:  CALL   064E
....................                SIM_state=doing_sms; 
4B94:  MOVLW  05
4B96:  MOVLB  3
4B98:  MOVWF  x5C
....................            } 
....................             else 
4B9A:  BRA    4BB0
4B9C:  MOVLB  0
....................             { 
....................                fprintf(COM2,"\n\r this phone unable to send commands \n\r"); 
4B9E:  MOVLW  18
4BA0:  MOVWF  FF6
4BA2:  MOVLW  59
4BA4:  MOVWF  FF7
4BA6:  CALL   064E
....................                SIM_state=delete_MSG; 
4BAA:  MOVLW  06
4BAC:  MOVLB  3
4BAE:  MOVWF  x5C
....................             } 
....................          break; 
4BB0:  GOTO   583A
....................          case doing_sms: 
....................            memset(msg_data_sending,0,sizeof(msg_data_sending)); 
4BB4:  MOVLW  01
4BB6:  MOVWF  FEA
4BB8:  MOVLW  B0
4BBA:  MOVWF  FE9
4BBC:  CLRF   00
4BBE:  MOVLW  01
4BC0:  MOVWF  02
4BC2:  MOVLW  18
4BC4:  MOVWF  01
4BC6:  CALL   3968
....................            strcpy(msg_buffer2,"qullf"); 
4BCA:  MOVLW  03
4BCC:  MOVWF  FEA
4BCE:  MOVLW  0E
4BD0:  MOVWF  FE9
4BD2:  MOVLW  00
4BD4:  CALL   02BC
4BD8:  TBLRD*-
4BDA:  TBLRD*+
4BDC:  MOVF   FF5,W
4BDE:  MOVWF  FEE
4BE0:  IORLW  00
4BE2:  BNZ   4BDA
....................            if(!strncmp(msg_buffer2,sim_bug,5))  
4BE4:  MOVLW  03
4BE6:  MOVLB  9
4BE8:  MOVWF  xAF
4BEA:  MOVLW  0E
4BEC:  MOVWF  xAE
4BEE:  MOVLW  02
4BF0:  MOVWF  xB1
4BF2:  MOVLW  C8
4BF4:  MOVWF  xB0
4BF6:  CLRF   xB3
4BF8:  MOVLW  05
4BFA:  MOVWF  xB2
4BFC:  MOVLB  0
4BFE:  CALL   3E5C
4C02:  MOVF   01,F
4C04:  BNZ   4C32
....................            { 
....................              SIM_state=delete_MSG; 
4C06:  MOVLW  06
4C08:  MOVLB  3
4C0A:  MOVWF  x5C
....................              fprintf(COM2,"FORMATTING..."); 
4C0C:  MOVLW  42
4C0E:  MOVWF  FF6
4C10:  MOVLW  59
4C12:  MOVWF  FF7
4C14:  MOVLB  0
4C16:  CALL   064E
....................              ease_eeprom(); 
4C1A:  CALL   3EF2
....................              fprintf(COM2," exit\n\r"); 
4C1E:  MOVLW  50
4C20:  MOVWF  FF6
4C22:  MOVLW  59
4C24:  MOVWF  FF7
4C26:  CALL   064E
....................              break; 
4C2A:  MOVLB  3
4C2C:  GOTO   583A
4C30:  MOVLB  0
....................            } 
....................            strcpy(msg_buffer2,"format"); 
4C32:  MOVLW  03
4C34:  MOVWF  FEA
4C36:  MOVLW  0E
4C38:  MOVWF  FE9
4C3A:  MOVLW  00
4C3C:  CALL   02D2
4C40:  TBLRD*-
4C42:  TBLRD*+
4C44:  MOVF   FF5,W
4C46:  MOVWF  FEE
4C48:  IORLW  00
4C4A:  BNZ   4C42
....................            if(!strncmp(msg_buffer2,sim_bug,6))  
4C4C:  MOVLW  03
4C4E:  MOVLB  9
4C50:  MOVWF  xAF
4C52:  MOVLW  0E
4C54:  MOVWF  xAE
4C56:  MOVLW  02
4C58:  MOVWF  xB1
4C5A:  MOVLW  C8
4C5C:  MOVWF  xB0
4C5E:  CLRF   xB3
4C60:  MOVLW  06
4C62:  MOVWF  xB2
4C64:  MOVLB  0
4C66:  CALL   3E5C
4C6A:  MOVF   01,F
4C6C:  BNZ   4C9A
....................            { 
....................                SIM_state=delete_MSG; 
4C6E:  MOVLW  06
4C70:  MOVLB  3
4C72:  MOVWF  x5C
....................                fprintf(COM2,"FORMATTING..."); 
4C74:  MOVLW  58
4C76:  MOVWF  FF6
4C78:  MOVLW  59
4C7A:  MOVWF  FF7
4C7C:  MOVLB  0
4C7E:  CALL   064E
....................                format_eepromext(); 
4C82:  CALL   3F76
....................                fprintf(COM2," exit\n\r"); 
4C86:  MOVLW  66
4C88:  MOVWF  FF6
4C8A:  MOVLW  59
4C8C:  MOVWF  FF7
4C8E:  CALL   064E
....................                break; 
4C92:  MOVLB  3
4C94:  GOTO   583A
4C98:  MOVLB  0
....................            } 
....................            strcpy(msg_buffer2,"count tran"); 
4C9A:  MOVLW  03
4C9C:  MOVWF  FEA
4C9E:  MOVLW  0E
4CA0:  MOVWF  FE9
4CA2:  MOVLW  00
4CA4:  CALL   02EA
4CA8:  TBLRD*-
4CAA:  TBLRD*+
4CAC:  MOVF   FF5,W
4CAE:  MOVWF  FEE
4CB0:  IORLW  00
4CB2:  BNZ   4CAA
....................            if(!strncmp(msg_buffer2,sim_bug,10))  
4CB4:  MOVLW  03
4CB6:  MOVLB  9
4CB8:  MOVWF  xAF
4CBA:  MOVLW  0E
4CBC:  MOVWF  xAE
4CBE:  MOVLW  02
4CC0:  MOVWF  xB1
4CC2:  MOVLW  C8
4CC4:  MOVWF  xB0
4CC6:  CLRF   xB3
4CC8:  MOVLW  0A
4CCA:  MOVWF  xB2
4CCC:  MOVLB  0
4CCE:  CALL   3E5C
4CD2:  MOVF   01,F
4CD4:  BTFSS  FD8.2
4CD6:  BRA    4E0C
....................            {   
....................                len=0; 
4CD8:  MOVLB  8
4CDA:  CLRF   xF2
4CDC:  CLRF   xF1
....................                cards=get_countcard(); 
4CDE:  MOVLB  0
4CE0:  CALL   2EF0
4CE4:  MOVFF  02,891
4CE8:  MOVFF  01,890
....................                strcpy(msg_buffer2,"device has "); 
4CEC:  MOVLW  03
4CEE:  MOVWF  FEA
4CF0:  MOVLW  0E
4CF2:  MOVWF  FE9
4CF4:  MOVLW  00
4CF6:  CALL   0306
4CFA:  TBLRD*-
4CFC:  TBLRD*+
4CFE:  MOVF   FF5,W
4D00:  MOVWF  FEE
4D02:  IORLW  00
4D04:  BNZ   4CFC
....................                len=pre_msg(msg_buffer2,msg_data_sending,0); 
4D06:  MOVLW  03
4D08:  MOVLB  9
4D0A:  MOVWF  xAF
4D0C:  MOVLW  0E
4D0E:  MOVWF  xAE
4D10:  MOVLW  01
4D12:  MOVWF  xB1
4D14:  MOVLW  B0
4D16:  MOVWF  xB0
4D18:  CLRF   xB3
4D1A:  CLRF   xB2
4D1C:  MOVLB  0
4D1E:  CALL   4084
4D22:  MOVLB  8
4D24:  CLRF   xF2
4D26:  MOVFF  01,8F1
....................                itoa(cards,10,string); 
4D2A:  MOVLB  9
4D2C:  CLRF   xB1
4D2E:  CLRF   xB0
4D30:  MOVFF  891,9AF
4D34:  MOVFF  890,9AE
4D38:  MOVLW  0A
4D3A:  MOVWF  xB2
4D3C:  MOVLW  08
4D3E:  MOVWF  xB4
4D40:  MOVLW  FB
4D42:  MOVWF  xB3
4D44:  MOVLB  0
4D46:  CALL   4234
....................                len=pre_msg(string,msg_data_sending,len); 
4D4A:  MOVLW  08
4D4C:  MOVLB  9
4D4E:  MOVWF  xAF
4D50:  MOVLW  FB
4D52:  MOVWF  xAE
4D54:  MOVLW  01
4D56:  MOVWF  xB1
4D58:  MOVLW  B0
4D5A:  MOVWF  xB0
4D5C:  MOVFF  8F2,9B3
4D60:  MOVFF  8F1,9B2
4D64:  MOVLB  0
4D66:  CALL   4084
4D6A:  MOVLB  8
4D6C:  CLRF   xF2
4D6E:  MOVFF  01,8F1
....................                strcpy(msg_buffer2," transaction "); 
4D72:  MOVLW  03
4D74:  MOVWF  FEA
4D76:  MOVLW  0E
4D78:  MOVWF  FE9
4D7A:  MOVLW  00
4D7C:  MOVLB  0
4D7E:  CALL   0322
4D82:  TBLRD*-
4D84:  TBLRD*+
4D86:  MOVF   FF5,W
4D88:  MOVWF  FEE
4D8A:  IORLW  00
4D8C:  BNZ   4D84
....................                len=pre_msg(msg_buffer2,msg_data_sending,len); 
4D8E:  MOVLW  03
4D90:  MOVLB  9
4D92:  MOVWF  xAF
4D94:  MOVLW  0E
4D96:  MOVWF  xAE
4D98:  MOVLW  01
4D9A:  MOVWF  xB1
4D9C:  MOVLW  B0
4D9E:  MOVWF  xB0
4DA0:  MOVFF  8F2,9B3
4DA4:  MOVFF  8F1,9B2
4DA8:  MOVLB  0
4DAA:  CALL   4084
4DAE:  MOVLB  8
4DB0:  CLRF   xF2
4DB2:  MOVFF  01,8F1
....................                SIM_state=MSG_sending; 
4DB6:  MOVLW  08
4DB8:  MOVLB  3
4DBA:  MOVWF  x5C
....................                lastlen=0; 
4DBC:  MOVLB  8
4DBE:  CLRF   x8D
4DC0:  CLRF   x8C
....................                fprintf(COM2,"device has %lu transaction \n\r",cards); 
4DC2:  MOVLW  6E
4DC4:  MOVWF  FF6
4DC6:  MOVLW  59
4DC8:  MOVWF  FF7
4DCA:  MOVLW  0B
4DCC:  MOVLB  9
4DCE:  MOVWF  xC7
4DD0:  MOVLB  0
4DD2:  CALL   15C6
4DD6:  MOVLW  10
4DD8:  MOVWF  FE9
4DDA:  MOVFF  891,9AF
4DDE:  MOVFF  890,9AE
4DE2:  CALL   15F0
4DE6:  MOVLW  7C
4DE8:  MOVWF  FF6
4DEA:  MOVLW  59
4DEC:  MOVWF  FF7
4DEE:  MOVLW  0F
4DF0:  MOVLB  9
4DF2:  MOVWF  xC7
4DF4:  MOVLB  0
4DF6:  CALL   15C6
....................                countc=0; 
4DFA:  MOVLB  8
4DFC:  CLRF   x93
4DFE:  CLRF   x92
....................                count_dwla=0; 
4E00:  CLRF   x95
4E02:  CLRF   x94
....................                break; 
4E04:  MOVLB  3
4E06:  GOTO   583A
4E0A:  MOVLB  0
....................            } 
....................            strcpy(msg_buffer2,"download all"); 
4E0C:  MOVLW  03
4E0E:  MOVWF  FEA
4E10:  MOVLW  0E
4E12:  MOVWF  FE9
4E14:  MOVLW  00
4E16:  CALL   0340
4E1A:  TBLRD*-
4E1C:  TBLRD*+
4E1E:  MOVF   FF5,W
4E20:  MOVWF  FEE
4E22:  IORLW  00
4E24:  BNZ   4E1C
....................            if(!strncmp(msg_buffer2,sim_bug,12)) 
4E26:  MOVLW  03
4E28:  MOVLB  9
4E2A:  MOVWF  xAF
4E2C:  MOVLW  0E
4E2E:  MOVWF  xAE
4E30:  MOVLW  02
4E32:  MOVWF  xB1
4E34:  MOVLW  C8
4E36:  MOVWF  xB0
4E38:  CLRF   xB3
4E3A:  MOVLW  0C
4E3C:  MOVWF  xB2
4E3E:  MOVLB  0
4E40:  CALL   3E5C
4E44:  MOVF   01,F
4E46:  BNZ   4E82
....................            { 
....................                 fprintf(COM2,"download all\n\r");   
4E48:  MOVLW  8C
4E4A:  MOVWF  FF6
4E4C:  MOVLW  59
4E4E:  MOVWF  FF7
4E50:  CALL   064E
....................                 count_dwla=get_countcard(); 
4E54:  CALL   2EF0
4E58:  MOVFF  02,895
4E5C:  MOVFF  01,894
....................                 len=0; 
4E60:  MOVLB  8
4E62:  CLRF   xF2
4E64:  CLRF   xF1
....................                 num_card=count_dwla; 
4E66:  MOVFF  895,88F
4E6A:  MOVFF  894,88E
....................                 SIM_state=pre_cmd; 
4E6E:  MOVLW  07
4E70:  MOVLB  3
4E72:  MOVWF  x5C
....................                 countc=0; 
4E74:  MOVLB  8
4E76:  CLRF   x93
4E78:  CLRF   x92
....................                 break; 
4E7A:  MOVLB  3
4E7C:  GOTO   583A
4E80:  MOVLB  0
....................            } 
....................            strcpy(msg_buffer2,"download "); 
4E82:  MOVLW  03
4E84:  MOVWF  FEA
4E86:  MOVLW  0E
4E88:  MOVWF  FE9
4E8A:  MOVLW  00
4E8C:  CALL   035E
4E90:  TBLRD*-
4E92:  TBLRD*+
4E94:  MOVF   FF5,W
4E96:  MOVWF  FEE
4E98:  IORLW  00
4E9A:  BNZ   4E92
....................            if(!strncmp(msg_buffer2,sim_bug,9)) 
4E9C:  MOVLW  03
4E9E:  MOVLB  9
4EA0:  MOVWF  xAF
4EA2:  MOVLW  0E
4EA4:  MOVWF  xAE
4EA6:  MOVLW  02
4EA8:  MOVWF  xB1
4EAA:  MOVLW  C8
4EAC:  MOVWF  xB0
4EAE:  CLRF   xB3
4EB0:  MOVLW  09
4EB2:  MOVWF  xB2
4EB4:  MOVLB  0
4EB6:  CALL   3E5C
4EBA:  MOVF   01,F
4EBC:  BTFSS  FD8.2
4EBE:  BRA    5056
....................            { 
....................                i=0; 
4EC0:  MOVLB  8
4EC2:  CLRF   xF8
....................                temp=sim_bug[9]; 
4EC4:  MOVFF  2D1,8F7
....................                while(temp!=0) 
....................                { 
4EC8:  MOVF   xF7,F
4ECA:  BZ    4EF6
....................                   temp=sim_bug[i+9]; 
4ECC:  MOVLW  09
4ECE:  ADDWF  xF8,W
4ED0:  CLRF   03
4ED2:  ADDLW  C8
4ED4:  MOVWF  FE9
4ED6:  MOVLW  02
4ED8:  ADDWFC 03,W
4EDA:  MOVWF  FEA
4EDC:  MOVFF  FEF,8F7
....................                   string[i++]=temp; 
4EE0:  MOVF   xF8,W
4EE2:  INCF   xF8,F
4EE4:  CLRF   03
4EE6:  ADDLW  FB
4EE8:  MOVWF  FE9
4EEA:  MOVLW  08
4EEC:  ADDWFC 03,W
4EEE:  MOVWF  FEA
4EF0:  MOVFF  8F7,FEF
....................                } 
4EF4:  BRA    4EC8
....................                countc=atoi(string); 
4EF6:  MOVLW  08
4EF8:  MOVLB  9
4EFA:  MOVWF  xAF
4EFC:  MOVLW  FB
4EFE:  MOVWF  xAE
4F00:  MOVLB  0
4F02:  GOTO   4450
4F06:  CLRF   03
4F08:  MOVFF  01,892
4F0C:  MOVLB  8
4F0E:  MOVFF  03,893
....................                //fprintf(COM2,"countc=%lu\n\r",countc); 
....................                count_dwla=get_countcard(); 
4F12:  MOVLB  0
4F14:  CALL   2EF0
4F18:  MOVFF  02,895
4F1C:  MOVFF  01,894
....................                if(count_dwla<countc) 
4F20:  MOVLB  8
4F22:  MOVF   x95,W
4F24:  SUBWF  x93,W
4F26:  BTFSS  FD8.0
4F28:  BRA    5020
4F2A:  BNZ   4F32
4F2C:  MOVF   x92,W
4F2E:  SUBWF  x94,W
4F30:  BC    5020
....................                { 
....................                   len=0; 
4F32:  CLRF   xF2
4F34:  CLRF   xF1
....................                   strcpy(buftemp2,"Device has only "); 
4F36:  MOVLW  09
4F38:  MOVWF  FEA
4F3A:  MOVLW  7C
4F3C:  MOVWF  FE9
4F3E:  MOVLW  00
4F40:  MOVLB  0
4F42:  CALL   0378
4F46:  TBLRD*-
4F48:  TBLRD*+
4F4A:  MOVF   FF5,W
4F4C:  MOVWF  FEE
4F4E:  IORLW  00
4F50:  BNZ   4F48
....................                   len=pre_msg(buftemp2,msg_data_sending,0); 
4F52:  MOVLW  09
4F54:  MOVLB  9
4F56:  MOVWF  xAF
4F58:  MOVLW  7C
4F5A:  MOVWF  xAE
4F5C:  MOVLW  01
4F5E:  MOVWF  xB1
4F60:  MOVLW  B0
4F62:  MOVWF  xB0
4F64:  CLRF   xB3
4F66:  CLRF   xB2
4F68:  MOVLB  0
4F6A:  CALL   4084
4F6E:  MOVLB  8
4F70:  CLRF   xF2
4F72:  MOVFF  01,8F1
....................                   itoa(count_dwla,10,string); 
4F76:  MOVLB  9
4F78:  CLRF   xB1
4F7A:  CLRF   xB0
4F7C:  MOVFF  895,9AF
4F80:  MOVFF  894,9AE
4F84:  MOVLW  0A
4F86:  MOVWF  xB2
4F88:  MOVLW  08
4F8A:  MOVWF  xB4
4F8C:  MOVLW  FB
4F8E:  MOVWF  xB3
4F90:  MOVLB  0
4F92:  CALL   4234
....................                   len=pre_msg(string,msg_data_sending,len); 
4F96:  MOVLW  08
4F98:  MOVLB  9
4F9A:  MOVWF  xAF
4F9C:  MOVLW  FB
4F9E:  MOVWF  xAE
4FA0:  MOVLW  01
4FA2:  MOVWF  xB1
4FA4:  MOVLW  B0
4FA6:  MOVWF  xB0
4FA8:  MOVFF  8F2,9B3
4FAC:  MOVFF  8F1,9B2
4FB0:  MOVLB  0
4FB2:  CALL   4084
4FB6:  MOVLB  8
4FB8:  CLRF   xF2
4FBA:  MOVFF  01,8F1
....................                   strcpy(buftemp2," transaction ");//transaction\n\r 
4FBE:  MOVLW  09
4FC0:  MOVWF  FEA
4FC2:  MOVLW  7C
4FC4:  MOVWF  FE9
4FC6:  MOVLW  00
4FC8:  MOVLB  0
4FCA:  CALL   0322
4FCE:  TBLRD*-
4FD0:  TBLRD*+
4FD2:  MOVF   FF5,W
4FD4:  MOVWF  FEE
4FD6:  IORLW  00
4FD8:  BNZ   4FD0
....................                   len=pre_msg(buftemp2,msg_data_sending,len); 
4FDA:  MOVLW  09
4FDC:  MOVLB  9
4FDE:  MOVWF  xAF
4FE0:  MOVLW  7C
4FE2:  MOVWF  xAE
4FE4:  MOVLW  01
4FE6:  MOVWF  xB1
4FE8:  MOVLW  B0
4FEA:  MOVWF  xB0
4FEC:  MOVFF  8F2,9B3
4FF0:  MOVFF  8F1,9B2
4FF4:  MOVLB  0
4FF6:  CALL   4084
4FFA:  MOVLB  8
4FFC:  CLRF   xF2
4FFE:  MOVFF  01,8F1
....................                   SIM_state=MSG_sending; 
5002:  MOVLW  08
5004:  MOVLB  3
5006:  MOVWF  x5C
....................                   lastlen=0; 
5008:  MOVLB  8
500A:  CLRF   x8D
500C:  CLRF   x8C
....................                   count_dwla=0; 
500E:  CLRF   x95
5010:  CLRF   x94
....................                   num_card=0; 
5012:  CLRF   x8F
5014:  CLRF   x8E
....................                   break; 
5016:  MOVLB  3
5018:  GOTO   583A
....................                } 
....................                else  
501C:  BRA    5054
501E:  MOVLB  8
....................                { 
....................                   num_card=count_dwla; 
5020:  MOVFF  895,88F
5024:  MOVFF  894,88E
....................                   countc=num_card-countc; 
5028:  MOVF   x92,W
502A:  SUBWF  x8E,W
502C:  MOVWF  x92
502E:  MOVF   x93,W
5030:  SUBWFB x8F,W
5032:  MOVWF  x93
....................                   if(countc==0)count_dwla=num_card; 
5034:  MOVF   x92,F
5036:  BNZ   5046
5038:  MOVF   x93,F
503A:  BNZ   5046
503C:  MOVFF  88F,895
5040:  MOVFF  88E,894
....................                   else count_dwla=0; 
5044:  BRA    504A
5046:  CLRF   x95
5048:  CLRF   x94
....................                   SIM_state=pre_cmd; 
504A:  MOVLW  07
504C:  MOVLB  3
504E:  MOVWF  x5C
....................                   break; 
5050:  GOTO   583A
....................                } 
....................                //SIM_state=delete_MSG; 
....................            } 
....................            else SIM_state=delete_MSG; 
5054:  BRA    505C
5056:  MOVLW  06
5058:  MOVLB  3
505A:  MOVWF  x5C
....................          break; 
505C:  GOTO   583A
....................          case delete_MSG: 
....................             fprintf(COM2,"delete_MSG...\n\r"); 
5060:  MOVLW  9C
5062:  MOVWF  FF6
5064:  MOVLW  59
5066:  MOVWF  FF7
5068:  CALL   064E
....................             #ASM BCF    0xF94.7 #ENDASM  
506C:  BCF    F94.7
....................                fprintf(COM1,"AT+CMGD=1\r\n"); 
506E:  MOVLW  AC
5070:  MOVWF  FF6
5072:  MOVLW  59
5074:  MOVWF  FF7
5076:  CALL   3B02
....................             #ASM BSF    0xF94.7 #ENDASM  
507A:  BSF    F94.7
....................             del_buf(200,buffer_uart); 
507C:  MOVLW  C8
507E:  MOVLB  9
5080:  MOVWF  xBD
5082:  MOVLW  01
5084:  MOVWF  xBF
5086:  MOVLW  4A
5088:  MOVWF  xBE
508A:  MOVLB  0
508C:  CALL   2F62
....................             //SIM_state=sending_cmd;        
....................             timing_wait=800; 
5090:  MOVLW  03
5092:  MOVLB  3
5094:  MOVWF  x5F
5096:  MOVLW  20
5098:  MOVWF  x5E
....................             SIM_state= idle; 
509A:  MOVLW  0C
509C:  MOVWF  x5C
....................             output_low(PIN_C2); 
509E:  BCF    F94.2
50A0:  BCF    F8B.2
....................          break; 
50A2:  GOTO   583A
....................          case pre_cmd: 
....................                 //fprintf(COM2,"pre_cmd-> num_card,countc, count_dwla=%lu,%lu,%lu\r\n",num_card,countc,count_dwla);   
....................                 if(num_card==0)  
50A6:  MOVLB  8
50A8:  MOVF   x8E,F
50AA:  BNZ   50BC
50AC:  MOVF   x8F,F
50AE:  BNZ   50BC
....................                 { 
....................                   SIM_state=delete_MSG; 
50B0:  MOVLW  06
50B2:  MOVLB  3
50B4:  MOVWF  x5C
....................                   break; 
50B6:  GOTO   583A
50BA:  MOVLB  8
....................                 } 
....................                 len=0; 
50BC:  CLRF   xF2
50BE:  CLRF   xF1
....................                 //num_card=1; 
....................                 memset(msg_data_sending,0,sizeof(msg_data_sending));  
50C0:  MOVLW  01
50C2:  MOVWF  FEA
50C4:  MOVLW  B0
50C6:  MOVWF  FE9
50C8:  CLRF   00
50CA:  MOVLW  01
50CC:  MOVWF  02
50CE:  MOVLW  18
50D0:  MOVWF  01
50D2:  MOVLB  0
50D4:  CALL   3968
....................                 addr_dat=num_card*numdata+ptr_start; 
50D8:  MOVFF  88F,9B4
50DC:  MOVFF  88E,9B3
50E0:  MOVLB  9
50E2:  CLRF   xB6
50E4:  MOVLW  7C
50E6:  MOVWF  xB5
50E8:  MOVLB  0
50EA:  CALL   2F40
50EE:  MOVLW  96
50F0:  MOVLB  9
50F2:  ADDWF  01,W
50F4:  MOVLB  8
50F6:  MOVWF  xF3
50F8:  MOVLW  00
50FA:  MOVLB  9
50FC:  ADDWFC 02,W
50FE:  MOVLB  8
5100:  MOVWF  xF4
....................                 I2CEEPROM_read((unsigned int16)(addr_dat-numdata),numdata,buftemp); 
5102:  MOVLW  7C
5104:  SUBWF  xF3,W
5106:  MOVLB  9
5108:  MOVWF  xAE
510A:  MOVLW  00
510C:  MOVLB  8
510E:  SUBWFB xF4,W
5110:  MOVLB  9
5112:  MOVWF  xAF
5114:  MOVWF  xB1
5116:  MOVFF  9AE,9B0
511A:  CLRF   xB3
511C:  MOVLW  7C
511E:  MOVWF  xB2
5120:  MOVLW  09
5122:  MOVWF  xB5
5124:  CLRF   xB4
5126:  MOVLB  0
5128:  CALL   45F4
....................                 itoa(buftemp[0],10,string); 
512C:  MOVLB  9
512E:  CLRF   xB1
5130:  CLRF   xB0
5132:  CLRF   xAF
5134:  MOVFF  900,9AE
5138:  MOVLW  0A
513A:  MOVWF  xB2
513C:  MOVLW  08
513E:  MOVWF  xB4
5140:  MOVLW  FB
5142:  MOVWF  xB3
5144:  MOVLB  0
5146:  CALL   4234
....................                 len=pre_msg(string,msg_data_sending,0); 
514A:  MOVLW  08
514C:  MOVLB  9
514E:  MOVWF  xAF
5150:  MOVLW  FB
5152:  MOVWF  xAE
5154:  MOVLW  01
5156:  MOVWF  xB1
5158:  MOVLW  B0
515A:  MOVWF  xB0
515C:  CLRF   xB3
515E:  CLRF   xB2
5160:  MOVLB  0
5162:  CALL   4084
5166:  MOVLB  8
5168:  CLRF   xF2
516A:  MOVFF  01,8F1
....................                 msg_data_sending[len++]='/'; 
516E:  MOVFF  8F2,03
5172:  MOVF   xF1,W
5174:  INCF   xF1,F
5176:  BTFSC  FD8.2
5178:  INCF   xF2,F
517A:  MOVLB  9
517C:  MOVWF  xAE
517E:  MOVLW  B0
5180:  ADDWF  xAE,W
5182:  MOVWF  FE9
5184:  MOVLW  01
5186:  ADDWFC 03,W
5188:  MOVWF  FEA
518A:  MOVLW  2F
518C:  MOVWF  FEF
....................                 itoa(buftemp[1],10,string); 
518E:  CLRF   xB1
5190:  CLRF   xB0
5192:  CLRF   xAF
5194:  MOVFF  901,9AE
5198:  MOVLW  0A
519A:  MOVWF  xB2
519C:  MOVLW  08
519E:  MOVWF  xB4
51A0:  MOVLW  FB
51A2:  MOVWF  xB3
51A4:  MOVLB  0
51A6:  CALL   4234
....................                 len=pre_msg(string,msg_data_sending,len); 
51AA:  MOVLW  08
51AC:  MOVLB  9
51AE:  MOVWF  xAF
51B0:  MOVLW  FB
51B2:  MOVWF  xAE
51B4:  MOVLW  01
51B6:  MOVWF  xB1
51B8:  MOVLW  B0
51BA:  MOVWF  xB0
51BC:  MOVFF  8F2,9B3
51C0:  MOVFF  8F1,9B2
51C4:  MOVLB  0
51C6:  CALL   4084
51CA:  MOVLB  8
51CC:  CLRF   xF2
51CE:  MOVFF  01,8F1
....................                 msg_data_sending[len++]='/'; 
51D2:  MOVFF  8F2,03
51D6:  MOVF   xF1,W
51D8:  INCF   xF1,F
51DA:  BTFSC  FD8.2
51DC:  INCF   xF2,F
51DE:  MOVLB  9
51E0:  MOVWF  xAE
51E2:  MOVLW  B0
51E4:  ADDWF  xAE,W
51E6:  MOVWF  FE9
51E8:  MOVLW  01
51EA:  ADDWFC 03,W
51EC:  MOVWF  FEA
51EE:  MOVLW  2F
51F0:  MOVWF  FEF
....................                 msg_data_sending[len++]=' '; 
51F2:  MOVLB  8
51F4:  MOVFF  8F2,03
51F8:  MOVF   xF1,W
51FA:  INCF   xF1,F
51FC:  BTFSC  FD8.2
51FE:  INCF   xF2,F
5200:  MOVLB  9
5202:  MOVWF  xAE
5204:  MOVLW  B0
5206:  ADDWF  xAE,W
5208:  MOVWF  FE9
520A:  MOVLW  01
520C:  ADDWFC 03,W
520E:  MOVWF  FEA
5210:  MOVLW  20
5212:  MOVWF  FEF
....................                 itoa(buftemp[2],10,string); 
5214:  CLRF   xB1
5216:  CLRF   xB0
5218:  CLRF   xAF
521A:  MOVFF  902,9AE
521E:  MOVLW  0A
5220:  MOVWF  xB2
5222:  MOVLW  08
5224:  MOVWF  xB4
5226:  MOVLW  FB
5228:  MOVWF  xB3
522A:  MOVLB  0
522C:  CALL   4234
....................                 len=pre_msg(string,msg_data_sending,len); 
5230:  MOVLW  08
5232:  MOVLB  9
5234:  MOVWF  xAF
5236:  MOVLW  FB
5238:  MOVWF  xAE
523A:  MOVLW  01
523C:  MOVWF  xB1
523E:  MOVLW  B0
5240:  MOVWF  xB0
5242:  MOVFF  8F2,9B3
5246:  MOVFF  8F1,9B2
524A:  MOVLB  0
524C:  CALL   4084
5250:  MOVLB  8
5252:  CLRF   xF2
5254:  MOVFF  01,8F1
....................                 msg_data_sending[len++]=':'; 
5258:  MOVFF  8F2,03
525C:  MOVF   xF1,W
525E:  INCF   xF1,F
5260:  BTFSC  FD8.2
5262:  INCF   xF2,F
5264:  MOVLB  9
5266:  MOVWF  xAE
5268:  MOVLW  B0
526A:  ADDWF  xAE,W
526C:  MOVWF  FE9
526E:  MOVLW  01
5270:  ADDWFC 03,W
5272:  MOVWF  FEA
5274:  MOVLW  3A
5276:  MOVWF  FEF
....................                 itoa(buftemp[3],10,string); 
5278:  CLRF   xB1
527A:  CLRF   xB0
527C:  CLRF   xAF
527E:  MOVFF  903,9AE
5282:  MOVLW  0A
5284:  MOVWF  xB2
5286:  MOVLW  08
5288:  MOVWF  xB4
528A:  MOVLW  FB
528C:  MOVWF  xB3
528E:  MOVLB  0
5290:  CALL   4234
....................                 len=pre_msg(string,msg_data_sending,len); 
5294:  MOVLW  08
5296:  MOVLB  9
5298:  MOVWF  xAF
529A:  MOVLW  FB
529C:  MOVWF  xAE
529E:  MOVLW  01
52A0:  MOVWF  xB1
52A2:  MOVLW  B0
52A4:  MOVWF  xB0
52A6:  MOVFF  8F2,9B3
52AA:  MOVFF  8F1,9B2
52AE:  MOVLB  0
52B0:  CALL   4084
52B4:  MOVLB  8
52B6:  CLRF   xF2
52B8:  MOVFF  01,8F1
....................                 msg_data_sending[len++]=':'; 
52BC:  MOVFF  8F2,03
52C0:  MOVF   xF1,W
52C2:  INCF   xF1,F
52C4:  BTFSC  FD8.2
52C6:  INCF   xF2,F
52C8:  MOVLB  9
52CA:  MOVWF  xAE
52CC:  MOVLW  B0
52CE:  ADDWF  xAE,W
52D0:  MOVWF  FE9
52D2:  MOVLW  01
52D4:  ADDWFC 03,W
52D6:  MOVWF  FEA
52D8:  MOVLW  3A
52DA:  MOVWF  FEF
....................                 itoa(buftemp[4],10,string); 
52DC:  CLRF   xB1
52DE:  CLRF   xB0
52E0:  CLRF   xAF
52E2:  MOVFF  904,9AE
52E6:  MOVLW  0A
52E8:  MOVWF  xB2
52EA:  MOVLW  08
52EC:  MOVWF  xB4
52EE:  MOVLW  FB
52F0:  MOVWF  xB3
52F2:  MOVLB  0
52F4:  CALL   4234
....................                 len=pre_msg(string,msg_data_sending,len); 
52F8:  MOVLW  08
52FA:  MOVLB  9
52FC:  MOVWF  xAF
52FE:  MOVLW  FB
5300:  MOVWF  xAE
5302:  MOVLW  01
5304:  MOVWF  xB1
5306:  MOVLW  B0
5308:  MOVWF  xB0
530A:  MOVFF  8F2,9B3
530E:  MOVFF  8F1,9B2
5312:  MOVLB  0
5314:  CALL   4084
5318:  MOVLB  8
531A:  CLRF   xF2
531C:  MOVFF  01,8F1
....................                 //msg_data_sending[len++]=' '; 
....................                 i=0; 
5320:  CLRF   xF8
....................                 strcpy(buftemp2," Track1>"); 
5322:  MOVLW  09
5324:  MOVWF  FEA
5326:  MOVLW  7C
5328:  MOVWF  FE9
532A:  MOVLW  00
532C:  MOVLB  0
532E:  CALL   039A
5332:  TBLRD*-
5334:  TBLRD*+
5336:  MOVF   FF5,W
5338:  MOVWF  FEE
533A:  IORLW  00
533C:  BNZ   5334
....................                 len=pre_msg(buftemp2,msg_data_sending,len); 
533E:  MOVLW  09
5340:  MOVLB  9
5342:  MOVWF  xAF
5344:  MOVLW  7C
5346:  MOVWF  xAE
5348:  MOVLW  01
534A:  MOVWF  xB1
534C:  MOVLW  B0
534E:  MOVWF  xB0
5350:  MOVFF  8F2,9B3
5354:  MOVFF  8F1,9B2
5358:  MOVLB  0
535A:  CALL   4084
535E:  MOVLB  8
5360:  CLRF   xF2
5362:  MOVFF  01,8F1
....................                 temp=0; 
5366:  CLRF   xF7
....................                 while((i<numbyteoftrack1)&&(temp!='?')) 
....................                 { 
5368:  MOVF   xF8,W
536A:  SUBLW  4E
536C:  BNC   53BE
536E:  MOVF   xF7,W
5370:  SUBLW  3F
5372:  BZ    53BE
....................                   temp = buftemp[i+5]; 
5374:  MOVLW  05
5376:  ADDWF  xF8,W
5378:  CLRF   03
537A:  MOVWF  FE9
537C:  MOVLW  09
537E:  ADDWF  03,W
5380:  MOVWF  FEA
5382:  MOVFF  FEF,8F7
....................                   //fprintf(COM2,"%c",temp);  
....................                   if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
5386:  MOVF   xF7,W
5388:  SUBLW  1F
538A:  BC    53B4
538C:  MOVF   xF7,W
538E:  SUBLW  7E
5390:  BNC   53B4
5392:  MOVFF  8F2,03
5396:  MOVF   xF1,W
5398:  INCF   xF1,F
539A:  BTFSC  FD8.2
539C:  INCF   xF2,F
539E:  MOVLB  9
53A0:  MOVWF  xAE
53A2:  MOVLW  B0
53A4:  ADDWF  xAE,W
53A6:  MOVWF  FE9
53A8:  MOVLW  01
53AA:  ADDWFC 03,W
53AC:  MOVWF  FEA
53AE:  MOVFF  8F7,FEF
53B2:  MOVLB  8
....................                   i++; 
53B4:  INCF   xF8,F
....................                   if(temp==0)break; 
53B6:  MOVF   xF7,F
53B8:  BNZ   53BC
53BA:  BRA    53BE
....................                 } 
53BC:  BRA    5368
....................                 i=0; 
53BE:  CLRF   xF8
....................                 temp=0; 
53C0:  CLRF   xF7
....................                 strcpy(buftemp2," Track2>"); 
53C2:  MOVLW  09
53C4:  MOVWF  FEA
53C6:  MOVLW  7C
53C8:  MOVWF  FE9
53CA:  MOVLW  00
53CC:  MOVLB  0
53CE:  CALL   03B4
53D2:  TBLRD*-
53D4:  TBLRD*+
53D6:  MOVF   FF5,W
53D8:  MOVWF  FEE
53DA:  IORLW  00
53DC:  BNZ   53D4
....................                 len=pre_msg(buftemp2,msg_data_sending,len); 
53DE:  MOVLW  09
53E0:  MOVLB  9
53E2:  MOVWF  xAF
53E4:  MOVLW  7C
53E6:  MOVWF  xAE
53E8:  MOVLW  01
53EA:  MOVWF  xB1
53EC:  MOVLW  B0
53EE:  MOVWF  xB0
53F0:  MOVFF  8F2,9B3
53F4:  MOVFF  8F1,9B2
53F8:  MOVLB  0
53FA:  CALL   4084
53FE:  MOVLB  8
5400:  CLRF   xF2
5402:  MOVFF  01,8F1
....................                 while((i<numbyteoftrack2)&&(temp!='?')) 
....................                 { 
5406:  MOVF   xF8,W
5408:  SUBLW  27
540A:  BNC   545E
540C:  MOVF   xF7,W
540E:  SUBLW  3F
5410:  BZ    545E
....................                   temp = buftemp[i+5+numbyteoftrack1]; 
5412:  MOVLW  05
5414:  ADDWF  xF8,W
5416:  ADDLW  4F
5418:  CLRF   03
541A:  MOVWF  FE9
541C:  MOVLW  09
541E:  ADDWF  03,W
5420:  MOVWF  FEA
5422:  MOVFF  FEF,8F7
....................                   //fprintf(COM2,"%c",temp);  
....................                   if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
5426:  MOVF   xF7,W
5428:  SUBLW  1F
542A:  BC    5454
542C:  MOVF   xF7,W
542E:  SUBLW  7E
5430:  BNC   5454
5432:  MOVFF  8F2,03
5436:  MOVF   xF1,W
5438:  INCF   xF1,F
543A:  BTFSC  FD8.2
543C:  INCF   xF2,F
543E:  MOVLB  9
5440:  MOVWF  xAE
5442:  MOVLW  B0
5444:  ADDWF  xAE,W
5446:  MOVWF  FE9
5448:  MOVLW  01
544A:  ADDWFC 03,W
544C:  MOVWF  FEA
544E:  MOVFF  8F7,FEF
5452:  MOVLB  8
....................                   i++; 
5454:  INCF   xF8,F
....................                   if(temp==0)break; 
5456:  MOVF   xF7,F
5458:  BNZ   545C
545A:  BRA    545E
....................                 } 
545C:  BRA    5406
....................                 addr_key=EEPROM_KEY_ST+((num_card-1)*50); 
545E:  MOVLW  01
5460:  SUBWF  x8E,W
5462:  MOVLB  9
5464:  MOVWF  xAE
5466:  MOVLW  00
5468:  MOVLB  8
546A:  SUBWFB x8F,W
546C:  MOVLB  9
546E:  MOVWF  xAF
5470:  MOVWF  xB4
5472:  MOVFF  9AE,9B3
5476:  CLRF   xB6
5478:  MOVLW  32
547A:  MOVWF  xB5
547C:  MOVLB  0
547E:  CALL   2F40
5482:  MOVF   01,W
5484:  ADDLW  47
5486:  MOVLB  8
5488:  MOVWF  x76
548A:  MOVLW  AA
548C:  ADDWFC 02,W
548E:  MOVWF  x77
5490:  CLRF   x78
5492:  CLRF   x79
....................                 //if(ptr_card_key>addr_key) 
....................                 //{ 
....................                    strcpy(buftemp2," PIN:"); 
5494:  MOVLW  09
5496:  MOVWF  FEA
5498:  MOVLW  7C
549A:  MOVWF  FE9
549C:  MOVLW  00
549E:  MOVLB  0
54A0:  CALL   03CE
54A4:  TBLRD*-
54A6:  TBLRD*+
54A8:  MOVF   FF5,W
54AA:  MOVWF  FEE
54AC:  IORLW  00
54AE:  BNZ   54A6
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
54B0:  MOVLW  09
54B2:  MOVLB  9
54B4:  MOVWF  xAF
54B6:  MOVLW  7C
54B8:  MOVWF  xAE
54BA:  MOVLW  01
54BC:  MOVWF  xB1
54BE:  MOVLW  B0
54C0:  MOVWF  xB0
54C2:  MOVFF  8F2,9B3
54C6:  MOVFF  8F1,9B2
54CA:  MOVLB  0
54CC:  CALL   4084
54D0:  MOVLB  8
54D2:  CLRF   xF2
54D4:  MOVFF  01,8F1
....................                    j=0; 
54D8:  CLRF   xFA
....................                    do 
....................                    { 
....................                      temp=read_ext_eeprom(j+addr_key); 
54DA:  MOVF   xFA,W
54DC:  ADDWF  x76,W
54DE:  MOVLB  9
54E0:  MOVWF  xAE
54E2:  MOVLW  00
54E4:  MOVLB  8
54E6:  ADDWFC x77,W
54E8:  MOVLB  9
54EA:  MOVWF  xAF
54EC:  MOVWF  xBD
54EE:  MOVFF  9AE,9BC
54F2:  MOVLB  0
54F4:  CALL   2E48
54F8:  MOVFF  01,8F7
....................                      if(((temp>47)&&(temp<58))||((temp=='#')||(temp=='*'))||(temp>64)&&(temp<73)) 
54FC:  MOVLB  8
54FE:  MOVF   xF7,W
5500:  SUBLW  2F
5502:  BC    550A
5504:  MOVF   xF7,W
5506:  SUBLW  39
5508:  BC    5522
550A:  MOVF   xF7,W
550C:  SUBLW  23
550E:  BZ    5522
5510:  MOVF   xF7,W
5512:  SUBLW  2A
5514:  BZ    5522
5516:  MOVF   xF7,W
5518:  SUBLW  40
551A:  BC    5544
551C:  MOVF   xF7,W
551E:  SUBLW  48
5520:  BNC   5544
....................                         msg_data_sending[len++]=temp; 
5522:  MOVFF  8F2,03
5526:  MOVF   xF1,W
5528:  INCF   xF1,F
552A:  BTFSC  FD8.2
552C:  INCF   xF2,F
552E:  MOVLB  9
5530:  MOVWF  xAE
5532:  MOVLW  B0
5534:  ADDWF  xAE,W
5536:  MOVWF  FE9
5538:  MOVLW  01
553A:  ADDWFC 03,W
553C:  MOVWF  FEA
553E:  MOVFF  8F7,FEF
5542:  MOVLB  8
....................                      j++; 
5544:  INCF   xFA,F
....................                    } 
....................                    while((j<key_numbyte)&&(temp!=0)); 
5546:  MOVF   xFA,W
5548:  SUBLW  31
554A:  BNC   5550
554C:  MOVF   xF7,F
554E:  BNZ   54DA
....................                    fprintf(COM2,"%lu character\n\r",len);   
5550:  MOVLW  10
5552:  MOVWF  FE9
5554:  MOVFF  8F2,9AF
5558:  MOVFF  8F1,9AE
555C:  MOVLB  0
555E:  CALL   15F0
5562:  MOVLW  BB
5564:  MOVWF  FF6
5566:  MOVLW  59
5568:  MOVWF  FF7
556A:  MOVLW  0C
556C:  MOVLB  9
556E:  MOVWF  xC7
5570:  MOVLB  0
5572:  CALL   15C6
....................                   //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                    //addr_key=addr_key+(50); 
....................                  //}        
....................                 lastlen=0;  
5576:  MOVLB  8
5578:  CLRF   x8D
557A:  CLRF   x8C
....................                 //fprintf(COM2,"countc,num_card =%lu,%lu\n\r",countc,num_card); 
....................                 if((countc==num_card)&&(countc!=0)) 
557C:  MOVF   x8E,W
557E:  SUBWF  x92,W
5580:  BNZ   559A
5582:  MOVF   x8F,W
5584:  SUBWF  x93,W
5586:  BNZ   559A
5588:  MOVF   x92,F
558A:  BNZ   5590
558C:  MOVF   x93,F
558E:  BZ    559A
....................                 { 
....................                   SIM_state=delete_MSG;  
5590:  MOVLW  06
5592:  MOVLB  3
5594:  MOVWF  x5C
....................                   break; 
5596:  BRA    583A
5598:  MOVLB  8
....................                 } 
....................                 num_card--; 
559A:  MOVF   x8E,W
559C:  BTFSC  FD8.2
559E:  DECF   x8F,F
55A0:  DECF   x8E,F
....................                 //fprintf(COM2,"send_oneMSG =%d\n\r",send_oneMSG); 
....................                 if(send_oneMSG==1) 
55A2:  MOVLB  3
55A4:  DECFSZ x61,W
55A6:  BRA    55B2
....................                 { 
....................                   num_card=0; 
55A8:  MOVLB  8
55AA:  CLRF   x8F
55AC:  CLRF   x8E
....................                   send_oneMSG=0; 
55AE:  MOVLB  3
55B0:  CLRF   x61
....................                 } 
....................                 SIM_state=MSG_sending;               
55B2:  MOVLW  08
55B4:  MOVWF  x5C
....................          break; 
55B6:  BRA    583A
....................          case MSG_sending: 
....................                //fprintf(COM2,"MSG_sending\n\r"); 
....................             output_high(PIN_C2); 
55B8:  BCF    F94.2
55BA:  BSF    F8B.2
....................             #ASM BCF    0xF94.7 #ENDASM  
55BC:  BCF    F94.7
....................             switch(MSG_sending_st) 
....................             { 
55BE:  MOVLB  3
55C0:  MOVF   x5D,W
55C2:  XORLW  00
55C4:  MOVLB  0
55C6:  BZ    55D2
55C8:  XORLW  01
55CA:  BZ    5620
55CC:  XORLW  03
55CE:  BZ    5692
55D0:  BRA    5748
....................                case 0:// configure MSG 
....................                   receiver_state=1; 
55D2:  MOVLW  01
55D4:  MOVLB  8
55D6:  MOVWF  x8A
....................                      fprintf(COM1,"AT+CMGF=1\r\n"); // text mode 
55D8:  MOVLW  C8
55DA:  MOVWF  FF6
55DC:  MOVLW  59
55DE:  MOVWF  FF7
55E0:  MOVLB  0
55E2:  CALL   3B02
....................                   //fprintf(COM2,"AT+CMGF=1\r\n"); // text mode 
....................                   strl= strlen(msg_data_sending); 
55E6:  MOVLW  01
55E8:  MOVLB  9
55EA:  MOVWF  xB7
55EC:  MOVLW  B0
55EE:  MOVWF  xB6
55F0:  MOVLB  0
55F2:  CALL   404A
55F6:  MOVFF  01,8F9
....................                   MSG_sending_st=1; 
55FA:  MOVLW  01
55FC:  MOVLB  3
55FE:  MOVWF  x5D
....................                   timing_wait=500; 
5600:  MOVWF  x5F
5602:  MOVLW  F4
5604:  MOVWF  x5E
....................                   EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
5606:  MOVLW  55
5608:  MOVLB  9
560A:  MOVWF  xAE
560C:  MOVLW  14
560E:  MOVWF  xAF
5610:  MOVLW  03
5612:  MOVWF  xB1
5614:  MOVLW  40
5616:  MOVWF  xB0
5618:  MOVLB  0
561A:  CALL   3D76
....................                break; 
561E:  BRA    5748
....................                case 1: 
....................                      fprintf(COM1,"AT+CMGS="); 
5620:  MOVLW  D4
5622:  MOVWF  FF6
5624:  MOVLW  59
5626:  MOVWF  FF7
5628:  CALL   3B02
....................                   //fprintf(COM2,"AT+CMGS="); 
....................                   fputc('"',COM1); 
562C:  MOVLW  22
562E:  CALL   466C
....................                   i=0; 
5632:  MOVLB  8
5634:  CLRF   xF8
....................                   while((mobilenumb[i]!=0)&&(i<20)) 
....................                   { 
5636:  CLRF   03
5638:  MOVF   xF8,W
563A:  ADDLW  40
563C:  MOVWF  FE9
563E:  MOVLW  03
5640:  ADDWFC 03,W
5642:  MOVWF  FEA
5644:  MOVF   FEF,F
5646:  BZ    5670
5648:  MOVF   xF8,W
564A:  SUBLW  13
564C:  BNC   5670
....................                      fputc(mobilenumb[i],COM1); 
564E:  CLRF   03
5650:  MOVF   xF8,W
5652:  ADDLW  40
5654:  MOVWF  FE9
5656:  MOVLW  03
5658:  ADDWFC 03,W
565A:  MOVWF  FEA
565C:  MOVFF  FEF,9AE
5660:  MOVLB  9
5662:  MOVF   xAE,W
5664:  MOVLB  0
5666:  CALL   466C
....................                      //fprintf(COM2,"%c",mobilenumb[i]);  
....................                      i++; 
566A:  MOVLB  8
566C:  INCF   xF8,F
....................                   } 
566E:  BRA    5636
....................                   fputc('"',COM1); 
5670:  MOVLW  22
5672:  MOVLB  0
5674:  CALL   466C
....................                   fprintf(COM1,"\r\n"); 
5678:  MOVLW  0D
567A:  BTFSS  F9E.4
567C:  BRA    567A
567E:  MOVWF  FAE
5680:  MOVLW  0A
5682:  BTFSS  F9E.4
5684:  BRA    5682
5686:  MOVWF  FAE
....................                   MSG_sending_st=2; 
5688:  MOVLW  02
568A:  MOVLB  3
568C:  MOVWF  x5D
....................                break; 
568E:  MOVLB  0
5690:  BRA    5748
....................                case 2: 
....................                   //while((msg_data_sending[i]!=0)&&(i<140)) 
....................                   for(i=0;i<140;i++) 
5692:  MOVLB  8
5694:  CLRF   xF8
5696:  MOVF   xF8,W
5698:  SUBLW  8B
569A:  BNC   56FE
....................                   { 
....................                      if(msg_data_sending[i+lastlen]==0) 
569C:  MOVF   xF8,W
569E:  ADDWF  x8C,W
56A0:  MOVLB  9
56A2:  MOVWF  xAE
56A4:  MOVLW  00
56A6:  MOVLB  8
56A8:  ADDWFC x8D,W
56AA:  MOVLB  9
56AC:  MOVWF  xAF
56AE:  MOVLW  B0
56B0:  ADDWF  xAE,W
56B2:  MOVWF  FE9
56B4:  MOVLW  01
56B6:  ADDWFC xAF,W
56B8:  MOVWF  FEA
56BA:  MOVF   FEF,F
56BC:  BNZ   56CC
....................                      { 
....................                         SIM_state=delete_MSG;    
56BE:  MOVLW  06
56C0:  MOVLB  3
56C2:  MOVWF  x5C
....................                         MSG_sending_st=0; 
56C4:  CLRF   x5D
....................                         break; 
56C6:  MOVLB  8
56C8:  BRA    56FE
56CA:  MOVLB  9
....................                      } 
....................                      fputc(msg_data_sending[i+lastlen],COM1); 
56CC:  MOVLB  8
56CE:  MOVF   xF8,W
56D0:  ADDWF  x8C,W
56D2:  MOVLB  9
56D4:  MOVWF  xAE
56D6:  MOVLW  00
56D8:  MOVLB  8
56DA:  ADDWFC x8D,W
56DC:  MOVLB  9
56DE:  MOVWF  xAF
56E0:  MOVLW  B0
56E2:  ADDWF  xAE,W
56E4:  MOVWF  FE9
56E6:  MOVLW  01
56E8:  ADDWFC xAF,W
56EA:  MOVWF  FEA
56EC:  MOVFF  FEF,9B0
56F0:  MOVF   xB0,W
56F2:  MOVLB  0
56F4:  CALL   466C
....................                   } 
56F8:  MOVLB  8
56FA:  INCF   xF8,F
56FC:  BRA    5696
....................                   //fprintf(COM2,"i= %u\n\r",i);  
....................                   fputc(26,COM1); 
56FE:  MOVLW  1A
5700:  MOVLB  0
5702:  CALL   466C
....................                   MSG_sending_st=0; 
5706:  MOVLB  3
5708:  CLRF   x5D
....................                   if(i<140) 
570A:  MOVLB  8
570C:  MOVF   xF8,W
570E:  SUBLW  8B
5710:  BNC   5720
....................                   { 
....................                      SIM_state=check_st; 
5712:  MOVLW  09
5714:  MOVLB  3
5716:  MOVWF  x5C
....................                      lastlen=0; 
5718:  MOVLB  8
571A:  CLRF   x8D
571C:  CLRF   x8C
....................                   } 
....................                   else 
571E:  BRA    5736
....................                   { 
....................                      lastlen=140; 
5720:  CLRF   x8D
5722:  MOVLW  8C
5724:  MOVWF  x8C
....................                      if(msg_data_sending[140]==0)SIM_state=check_st; 
5726:  MOVLB  2
5728:  MOVF   x3C,F
572A:  BNZ   5734
572C:  MOVLW  09
572E:  MOVLB  3
5730:  MOVWF  x5C
5732:  MOVLB  2
5734:  MOVLB  8
....................                   } 
....................                   if(lastlen==140)SIM_state=MSG_sending; 
5736:  MOVF   x8C,W
5738:  SUBLW  8C
573A:  BNZ   5746
573C:  MOVF   x8D,F
573E:  BNZ   5746
5740:  MOVLW  08
5742:  MOVLB  3
5744:  MOVWF  x5C
....................                   //fprintf(COM2,"lastlen %lu\n\r",lastlen);   
....................                break; 
5746:  MOVLB  0
....................             } 
....................             #ASM BSF    0xF94.7 #ENDASM  
5748:  BSF    F94.7
....................          break; 
574A:  MOVLB  3
574C:  BRA    583A
....................          case check_st: 
....................             //fprintf(COM2,"check_st->num_card,countc, count_dwla, lastlen =%lu,%lu,%lu,%lu\r\n",num_card,countc,count_dwla,lastlen);   
....................             if(count_dwla>1) 
574E:  MOVLB  8
5750:  MOVF   x95,F
5752:  BNZ   575A
5754:  MOVF   x94,W
5756:  SUBLW  01
5758:  BC    576E
....................             { 
....................                count_dwla--; 
575A:  MOVF   x94,W
575C:  BTFSC  FD8.2
575E:  DECF   x95,F
5760:  DECF   x94,F
....................                SIM_state=pre_cmd; 
5762:  MOVLW  07
5764:  MOVLB  3
5766:  MOVWF  x5C
....................                break; 
5768:  BRA    583A
....................             } 
....................             else if(countc>0)  
576A:  BRA    5786
576C:  MOVLB  8
576E:  MOVF   x92,F
5770:  BNZ   5776
5772:  MOVF   x93,F
5774:  BZ    5780
....................             { 
....................                SIM_state=pre_cmd; 
5776:  MOVLW  07
5778:  MOVLB  3
577A:  MOVWF  x5C
....................                break; 
577C:  BRA    583A
....................             } 
....................             else SIM_state=delete_MSG; 
577E:  BRA    5786
5780:  MOVLW  06
5782:  MOVLB  3
5784:  MOVWF  x5C
....................          break; 
5786:  BRA    583A
....................          case autosending:  
....................                auto_sending=read_ext_eeprom(strobe_autosending); 
5788:  MOVLB  9
578A:  CLRF   xBD
578C:  MOVLW  93
578E:  MOVWF  xBC
5790:  MOVLB  0
5792:  CALL   2E48
5796:  MOVFF  01,360
....................                if(auto_sending==1) 
579A:  MOVLB  3
579C:  DECFSZ x60,W
579E:  BRA    57EA
....................                { 
....................                   EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
57A0:  MOVLW  55
57A2:  MOVLB  9
57A4:  MOVWF  xAE
57A6:  MOVLW  14
57A8:  MOVWF  xAF
57AA:  MOVLW  03
57AC:  MOVWF  xB1
57AE:  MOVLW  40
57B0:  MOVWF  xB0
57B2:  MOVLB  0
57B4:  CALL   3D76
....................                   fprintf(COM2,"\r\nSending...\r\n");  
57B8:  MOVLW  DE
57BA:  MOVWF  FF6
57BC:  MOVLW  59
57BE:  MOVWF  FF7
57C0:  CALL   064E
....................                   num_card=get_countcard(); 
57C4:  CALL   2EF0
57C8:  MOVFF  02,88F
57CC:  MOVFF  01,88E
....................                   countc=0; 
57D0:  MOVLB  8
57D2:  CLRF   x93
57D4:  CLRF   x92
....................                   count_dwla=0; 
57D6:  CLRF   x95
57D8:  CLRF   x94
....................                   lastlen=0; 
57DA:  CLRF   x8D
57DC:  CLRF   x8C
....................                   send_oneMSG=1; 
57DE:  MOVLW  01
57E0:  MOVLB  3
57E2:  MOVWF  x61
....................                   SIM_state=pre_cmd; 
57E4:  MOVLW  07
57E6:  MOVWF  x5C
....................                } 
....................                else SIM_state= reading_sms_cmd; 
57E8:  BRA    57EE
57EA:  MOVLW  01
57EC:  MOVWF  x5C
....................          break; 
57EE:  BRA    583A
....................          case idle: 
....................                output_toggle(PIN_C2); 
57F0:  BCF    F94.2
57F2:  BTG    F8B.2
....................                fprintf(COM2,"idle\n\r"); 
57F4:  MOVLW  EE
57F6:  MOVWF  FF6
57F8:  MOVLW  59
57FA:  MOVWF  FF7
57FC:  CALL   064E
....................                output_low(PIN_C2); 
5800:  BCF    F94.2
5802:  BCF    F8B.2
....................                SIM_state= data_analyze; 
5804:  MOVLW  0D
5806:  MOVLB  3
5808:  MOVWF  x5C
....................                receiver_state=0; 
580A:  MOVLB  8
580C:  CLRF   x8A
....................                timing_wait=300; 
580E:  MOVLW  01
5810:  MOVLB  3
5812:  MOVWF  x5F
5814:  MOVLW  2C
5816:  MOVWF  x5E
....................          break; 
5818:  BRA    583A
....................          case data_analyze: 
....................                //fprintf(COM2,"data_analyze=%d\n\r",booting_done); 
....................                //output_toggle(PIN_C2); 
....................                temp=SMS_coming(); 
581A:  GOTO   4674
581E:  MOVFF  01,8F7
....................                if(temp==2) 
5822:  MOVLB  8
5824:  MOVF   xF7,W
5826:  SUBLW  02
5828:  BNZ   5834
....................                { 
....................                   output_high(PIN_C2); 
582A:  BCF    F94.2
582C:  BSF    F8B.2
....................                   SIM_state=reading_sms_cmd; 
582E:  MOVLW  01
5830:  MOVLB  3
5832:  MOVWF  x5C
....................                } 
....................          break; 
5834:  MOVLB  3
5836:  BRA    583A
5838:  MOVLB  3
....................       }     
....................    } 
....................   #endif 
....................   //================================= 
.................... } 
.................... //========================= 
583A:  BCF    FF2.2
583C:  MOVLB  0
583E:  GOTO   0084
.................... void main() 
.................... {  
*
808A:  CLRF   FF8
808C:  BCF    FD0.7
808E:  BSF    07.7
8090:  CLRF   FEA
8092:  CLRF   FE9
8094:  BSF    F7E.3
8096:  MOVLW  40
8098:  MOVWF  FB0
809A:  MOVLW  03
809C:  MOVWF  F7F
809E:  MOVLW  A6
80A0:  MOVWF  FAD
80A2:  MOVLW  90
80A4:  MOVWF  FAC
80A6:  BCF    F94.0
80A8:  BSF    F8B.0
80AA:  CLRF   23
80AC:  CLRF   22
80AE:  CLRF   21
80B0:  MOVLW  96
80B2:  MOVWF  20
80B4:  CLRF   27
80B6:  CLRF   26
80B8:  MOVLW  AA
80BA:  MOVWF  25
80BC:  MOVLW  47
80BE:  MOVWF  24
80C0:  CLRF   xFA
80C2:  CLRF   xF9
80C4:  SETF   xFC
80C6:  SETF   xFB
80C8:  MOVLW  0E
80CA:  MOVWF  xFE
80CC:  MOVLW  01
80CE:  MOVWF  xFF
80D0:  MOVLB  1
80D2:  MOVWF  x00
80D4:  CLRF   x01
80D6:  CLRF   x02
80D8:  CLRF   x03
80DA:  CLRF   x04
80DC:  MOVLW  03
80DE:  MOVWF  x06
80E0:  MOVLW  E8
80E2:  MOVWF  x05
80E4:  CLRF   x07
80E6:  CLRF   x08
80E8:  CLRF   x09
80EA:  MOVLW  64
80EC:  MOVWF  x0A
80EE:  CLRF   x0B
80F0:  CLRF   x0C
80F2:  CLRF   x0D
80F4:  CLRF   x0F
80F6:  CLRF   x0E
80F8:  CLRF   x42
80FA:  CLRF   x47
80FC:  CLRF   xAE
80FE:  CLRF   xAF
8100:  MOVLB  3
8102:  CLRF   x5B
8104:  CLRF   x5A
8106:  CLRF   x5C
8108:  CLRF   x5D
810A:  MOVLW  01
810C:  MOVWF  x5F
810E:  MOVLW  2C
8110:  MOVWF  x5E
8112:  CLRF   x60
8114:  CLRF   x61
8116:  MOVLB  8
8118:  CLRF   x5A
811A:  CLRF   x59
811C:  CLRF   x58
811E:  CLRF   x57
8120:  CLRF   x5B
8122:  CLRF   x5D
8124:  CLRF   x5C
8126:  CLRF   x5F
8128:  CLRF   x5E
812A:  CLRF   x61
812C:  CLRF   x60
812E:  CLRF   x63
8130:  CLRF   x62
8132:  MOVLW  FD
8134:  MOVWF  x65
8136:  MOVLW  E8
8138:  MOVWF  x64
813A:  CLRF   x67
813C:  CLRF   x66
813E:  CLRF   x68
8140:  CLRF   x69
8142:  CLRF   x6A
8144:  CLRF   x6B
8146:  CLRF   x6C
8148:  CLRF   x6D
814A:  CLRF   x6E
814C:  CLRF   x6F
814E:  CLRF   x70
8150:  CLRF   x72
8152:  MOVLW  01
8154:  MOVWF  x71
8156:  CLRF   x74
8158:  CLRF   x73
815A:  CLRF   x75
815C:  CLRF   x79
815E:  CLRF   x78
8160:  CLRF   x77
8162:  CLRF   x76
8164:  CLRF   x8A
8166:  CLRF   x8B
8168:  MOVLW  FF
816A:  MOVLB  F
816C:  MOVWF  x48
816E:  BCF    FC2.6
8170:  BCF    FC2.7
8172:  MOVF   x49,W
8174:  ANDLW  E0
8176:  IORLW  1F
8178:  MOVWF  x49
817A:  CLRF   FD2
817C:  CLRF   FD1
817E:  CLRF   1A
8180:  CLRF   1B
8182:  MOVLB  1
8184:  CLRF   x43
8186:  BCF    x44.0
8188:  CLRF   x45
818A:  CLRF   x46
818C:  CLRF   x48
818E:  BCF    x44.1
8190:  CLRF   x49
8192:  MOVLB  3
8194:  CLRF   x40
8196:  CLRF   x41
8198:  CLRF   x42
819A:  CLRF   x43
819C:  CLRF   x44
819E:  CLRF   x45
81A0:  CLRF   x46
81A2:  CLRF   x47
81A4:  CLRF   x48
81A6:  CLRF   x49
81A8:  CLRF   x4A
81AA:  CLRF   x4B
81AC:  CLRF   x4C
81AE:  CLRF   x4D
81B0:  CLRF   x4E
81B2:  CLRF   x4F
81B4:  CLRF   x50
81B6:  CLRF   x51
81B8:  CLRF   x52
81BA:  CLRF   x53
81BC:  CLRF   x54
81BE:  CLRF   x55
81C0:  CLRF   x56
81C2:  CLRF   x57
81C4:  CLRF   x58
81C6:  CLRF   x59
81C8:  MOVLB  8
81CA:  CLRF   x8C
81CC:  CLRF   x8D
81CE:  CLRF   x8E
81D0:  CLRF   x8F
81D2:  CLRF   x90
81D4:  CLRF   x91
81D6:  CLRF   x92
81D8:  CLRF   x93
81DA:  CLRF   x94
81DC:  CLRF   x95
....................    int8 i; 
....................    //RPINR2=6; 
....................     RPINR1=5; 
81DE:  MOVLW  05
81E0:  MOVLB  E
81E2:  MOVWF  xE7
....................    SIM_state = 0xff; 
81E4:  MOVLB  3
81E6:  SETF   x5C
....................    charac_timeout=0xffffffff; 
81E8:  MOVLB  0
81EA:  SETF   xFC
81EC:  SETF   xFB
....................    key_timeout=0xffff; 
81EE:  MOVLB  1
81F0:  SETF   x06
81F2:  SETF   x05
....................    setup_oscillator(OSC_32MHZ); 
81F4:  MOVLW  70
81F6:  MOVWF  FD3
81F8:  MOVLW  40
81FA:  MOVWF  F9B
81FC:  MOVF   FD3,W
....................    keyprss_off; 
81FE:  BCF    F92.7
8200:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
8202:  BCF    FF2.6
8204:  BCF    FF2.7
8206:  BTFSC  FF2.7
8208:  BRA    8204
....................    init_ext_eeprom(); 
820A:  MOVLB  0
820C:  GOTO   5A82
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
8210:  MOVLW  04
8212:  MOVLB  8
8214:  MOVWF  x97
8216:  CLRF   19
8218:  BTFSC  FF2.7
821A:  BSF    19.7
821C:  BCF    FF2.7
821E:  MOVLW  FA
8220:  MOVWF  xFA
8222:  MOVLB  0
8224:  CALL   1836
8228:  BTFSC  19.7
822A:  BSF    FF2.7
822C:  MOVLB  8
822E:  DECFSZ x97,F
8230:  BRA    8216
....................    init_password(); 
8232:  MOVLB  0
8234:  CALL   5AE0
8238:  CLRF   19
823A:  BTFSC  FF2.7
823C:  BSF    19.7
823E:  BCF    FF2.7
....................    EEPROM_read(strobe_pass_addr,20,password); 
8240:  MOVLB  9
8242:  CLRF   xAE
8244:  MOVLW  14
8246:  MOVWF  xAF
8248:  CLRF   xB1
824A:  MOVLW  55
824C:  MOVWF  xB0
824E:  MOVLB  0
8250:  CALL   3D76
8254:  BTFSC  19.7
8256:  BSF    FF2.7
8258:  CLRF   19
825A:  BTFSC  FF2.7
825C:  BSF    19.7
825E:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
8260:  MOVLB  9
8262:  CLRF   xBD
8264:  MOVLW  7F
8266:  MOVWF  xBC
8268:  MOVLB  0
826A:  CALL   2E48
826E:  BTFSC  19.7
8270:  BSF    FF2.7
8272:  MOVFF  01,10C
....................    //===================================== 
....................    rtc_init(); 
8276:  GOTO   5B58
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
827A:  MOVLW  19
827C:  MOVLB  8
827E:  MOVWF  x97
8280:  MOVLB  0
8282:  CALL   5C70
8286:  MOVFF  03,23
828A:  MOVFF  02,22
828E:  MOVFF  01,21
8292:  MOVFF  00,20
....................     
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
8296:  MOVLW  1E
8298:  MOVLB  8
829A:  MOVWF  x97
829C:  MOVLB  0
829E:  CALL   5C70
82A2:  MOVFF  03,27
82A6:  MOVFF  02,26
82AA:  MOVFF  01,25
82AE:  MOVFF  00,24
82B2:  CLRF   19
82B4:  BTFSC  FF2.7
82B6:  BSF    19.7
82B8:  BCF    FF2.7
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card_key); 
....................    countcard=get_countcard(); 
82BA:  CALL   2EF0
82BE:  BTFSC  19.7
82C0:  BSF    FF2.7
82C2:  MOVFF  02,FA
82C6:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
82CA:  SETF   xFC
82CC:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
82CE:  MOVLW  C7
82D0:  MOVWF  FD5
82D2:  CLRF   19
82D4:  BTFSC  FF2.7
82D6:  BSF    19.7
82D8:  BCF    FF2.7
....................    //setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
82DA:  MOVLB  9
82DC:  CLRF   xBD
82DE:  MOVLW  94
82E0:  MOVWF  xBC
82E2:  MOVLB  0
82E4:  CALL   2E48
82E8:  BTFSC  19.7
82EA:  BSF    FF2.7
82EC:  MOVFF  01,142
....................    if(delaycharaction==0)delaycharaction=1; 
82F0:  MOVLB  1
82F2:  MOVF   x42,F
82F4:  BNZ   82FA
82F6:  MOVLW  01
82F8:  MOVWF  x42
82FA:  CLRF   19
82FC:  BTFSC  FF2.7
82FE:  BSF    19.7
8300:  BCF    FF2.7
....................    delaykey=read_ext_eeprom(strobe_delaykb); 
8302:  MOVLB  9
8304:  CLRF   xBD
8306:  MOVLW  95
8308:  MOVWF  xBC
830A:  MOVLB  0
830C:  CALL   2E48
8310:  BTFSC  19.7
8312:  BSF    FF2.7
8314:  MOVFF  01,107
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
8318:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
831A:  BSF    FF0.3
831C:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
831E:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
8320:  MOVLW  C0
8322:  IORWF  FF2,F
....................    //========================================== 
....................    //delay_ms(100); 
....................    //EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................    //reset_password(); 
....................    //init_password(); 
....................    //fprintf(COM2,"Start\r\n"); 
....................    mcr_timeout=10000; 
8324:  MOVLB  8
8326:  CLRF   x5A
8328:  CLRF   x59
832A:  MOVLW  27
832C:  MOVWF  x58
832E:  MOVLW  10
8330:  MOVWF  x57
8332:  CLRF   19
8334:  BTFSC  FF2.7
8336:  BSF    19.7
8338:  BCF    FF2.7
....................    //EEPROM_read(strobe_pass_addr,20,password); 
....................    //========================================== 
....................    //write_ext_eeprom(strobe_Master_SLV,1); 
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
833A:  MOVLB  9
833C:  CLRF   xBD
833E:  MOVLW  91
8340:  MOVWF  xBC
8342:  MOVLB  0
8344:  CALL   2E48
8348:  BTFSC  19.7
834A:  BSF    FF2.7
834C:  MOVFF  01,875
8350:  CLRF   19
8352:  BTFSC  FF2.7
8354:  BSF    19.7
8356:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
8358:  MOVLB  9
835A:  CLRF   xBD
835C:  MOVLW  92
835E:  MOVWF  xBC
8360:  MOVLB  0
8362:  CALL   2E48
8366:  BTFSC  19.7
8368:  BSF    FF2.7
836A:  MOVFF  01,869
836E:  CLRF   19
8370:  BTFSC  FF2.7
8372:  BSF    19.7
8374:  BCF    FF2.7
....................     auto_sending=read_ext_eeprom(strobe_autosending); 
8376:  MOVLB  9
8378:  CLRF   xBD
837A:  MOVLW  93
837C:  MOVWF  xBC
837E:  MOVLB  0
8380:  CALL   2E48
8384:  BTFSC  19.7
8386:  BSF    FF2.7
8388:  MOVFF  01,360
....................     key_timeout=1000; 
838C:  MOVLW  03
838E:  MOVLB  1
8390:  MOVWF  x06
8392:  MOVLW  E8
8394:  MOVWF  x05
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
8396:  MOVLB  0
8398:  SETF   xFC
839A:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    #if defined(SIM900) 
....................       //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................       //output_low(PIN_C7); 
....................       //set_tris_c(0); 
....................       #ASM 
....................          BCF    0xF94.7 
839C:  BCF    F94.7
....................       #ENDASM 
....................       SIM_state = 0xff; 
839E:  MOVLB  3
83A0:  SETF   x5C
....................       fprintf(COM2,"\r\nbooting...\r\n"); 
83A2:  MOVLW  F6
83A4:  MOVWF  FF6
83A6:  MOVLW  59
83A8:  MOVWF  FF7
83AA:  CLRF   19
83AC:  BTFSC  FF2.7
83AE:  BSF    19.7
83B0:  BCF    FF2.7
83B2:  MOVLB  0
83B4:  CALL   064E
83B8:  BTFSC  19.7
83BA:  BSF    FF2.7
....................       delay_ms(15000); 
83BC:  MOVLW  3C
83BE:  MOVLB  8
83C0:  MOVWF  x97
83C2:  CLRF   19
83C4:  BTFSC  FF2.7
83C6:  BSF    19.7
83C8:  BCF    FF2.7
83CA:  MOVLW  FA
83CC:  MOVWF  xFA
83CE:  MOVLB  0
83D0:  CALL   1836
83D4:  BTFSC  19.7
83D6:  BSF    FF2.7
83D8:  MOVLB  8
83DA:  DECFSZ x97,F
83DC:  BRA    83C2
....................       receiver_state=1; 
83DE:  MOVLW  01
83E0:  MOVWF  x8A
....................       fprintf(COM1,"AT\r\n"); 
83E2:  MOVLW  06
83E4:  MOVWF  FF6
83E6:  MOVLW  5A
83E8:  MOVWF  FF7
83EA:  CLRF   19
83EC:  BTFSC  FF2.7
83EE:  BSF    19.7
83F0:  BCF    FF2.7
83F2:  MOVLB  0
83F4:  CALL   3B02
83F8:  BTFSC  19.7
83FA:  BSF    FF2.7
....................       delay_ms(1000); 
83FC:  MOVLW  04
83FE:  MOVLB  8
8400:  MOVWF  x97
8402:  CLRF   19
8404:  BTFSC  FF2.7
8406:  BSF    19.7
8408:  BCF    FF2.7
840A:  MOVLW  FA
840C:  MOVWF  xFA
840E:  MOVLB  0
8410:  CALL   1836
8414:  BTFSC  19.7
8416:  BSF    FF2.7
8418:  MOVLB  8
841A:  DECFSZ x97,F
841C:  BRA    8402
....................       fprintf(COM1,"AT+CMGF=1\r\n"); 
841E:  MOVLW  0C
8420:  MOVWF  FF6
8422:  MOVLW  5A
8424:  MOVWF  FF7
8426:  CLRF   19
8428:  BTFSC  FF2.7
842A:  BSF    19.7
842C:  BCF    FF2.7
842E:  MOVLB  0
8430:  CALL   3B02
8434:  BTFSC  19.7
8436:  BSF    FF2.7
....................       delay_ms(1000); 
8438:  MOVLW  04
843A:  MOVLB  8
843C:  MOVWF  x97
843E:  CLRF   19
8440:  BTFSC  FF2.7
8442:  BSF    19.7
8444:  BCF    FF2.7
8446:  MOVLW  FA
8448:  MOVWF  xFA
844A:  MOVLB  0
844C:  CALL   1836
8450:  BTFSC  19.7
8452:  BSF    FF2.7
8454:  MOVLB  8
8456:  DECFSZ x97,F
8458:  BRA    843E
845A:  CLRF   19
845C:  BTFSC  FF2.7
845E:  BSF    19.7
8460:  BCF    FF2.7
....................       //sim900_init(); 
....................       EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
8462:  MOVLW  55
8464:  MOVLB  9
8466:  MOVWF  xAE
8468:  MOVLW  14
846A:  MOVWF  xAF
846C:  MOVLW  03
846E:  MOVWF  xB1
8470:  MOVLW  40
8472:  MOVWF  xB0
8474:  MOVLB  0
8476:  CALL   3D76
847A:  BTFSC  19.7
847C:  BSF    FF2.7
....................       fprintf(COM1,"AT+CSMP=17,167,0,245\r\n"); 
847E:  MOVLW  18
8480:  MOVWF  FF6
8482:  MOVLW  5A
8484:  MOVWF  FF7
8486:  CLRF   19
8488:  BTFSC  FF2.7
848A:  BSF    19.7
848C:  BCF    FF2.7
848E:  CALL   3B02
8492:  BTFSC  19.7
8494:  BSF    FF2.7
....................       delay_ms(1000); 
8496:  MOVLW  04
8498:  MOVLB  8
849A:  MOVWF  x97
849C:  CLRF   19
849E:  BTFSC  FF2.7
84A0:  BSF    19.7
84A2:  BCF    FF2.7
84A4:  MOVLW  FA
84A6:  MOVWF  xFA
84A8:  MOVLB  0
84AA:  CALL   1836
84AE:  BTFSC  19.7
84B0:  BSF    FF2.7
84B2:  MOVLB  8
84B4:  DECFSZ x97,F
84B6:  BRA    849C
....................       fprintf(COM1,"AT+CMGD=1\r\n");  
84B8:  MOVLW  30
84BA:  MOVWF  FF6
84BC:  MOVLW  5A
84BE:  MOVWF  FF7
84C0:  CLRF   19
84C2:  BTFSC  FF2.7
84C4:  BSF    19.7
84C6:  BCF    FF2.7
84C8:  MOVLB  0
84CA:  CALL   3B02
84CE:  BTFSC  19.7
84D0:  BSF    FF2.7
....................       delay_ms(1000); 
84D2:  MOVLW  04
84D4:  MOVLB  8
84D6:  MOVWF  x97
84D8:  CLRF   19
84DA:  BTFSC  FF2.7
84DC:  BSF    19.7
84DE:  BCF    FF2.7
84E0:  MOVLW  FA
84E2:  MOVWF  xFA
84E4:  MOVLB  0
84E6:  CALL   1836
84EA:  BTFSC  19.7
84EC:  BSF    FF2.7
84EE:  MOVLB  8
84F0:  DECFSZ x97,F
84F2:  BRA    84D8
....................       fprintf(COM1,"AT+CMGD=2\r\n"); 
84F4:  MOVLW  3C
84F6:  MOVWF  FF6
84F8:  MOVLW  5A
84FA:  MOVWF  FF7
84FC:  CLRF   19
84FE:  BTFSC  FF2.7
8500:  BSF    19.7
8502:  BCF    FF2.7
8504:  MOVLB  0
8506:  CALL   3B02
850A:  BTFSC  19.7
850C:  BSF    FF2.7
....................       delay_ms(1000); 
850E:  MOVLW  04
8510:  MOVLB  8
8512:  MOVWF  x97
8514:  CLRF   19
8516:  BTFSC  FF2.7
8518:  BSF    19.7
851A:  BCF    FF2.7
851C:  MOVLW  FA
851E:  MOVWF  xFA
8520:  MOVLB  0
8522:  CALL   1836
8526:  BTFSC  19.7
8528:  BSF    FF2.7
852A:  MOVLB  8
852C:  DECFSZ x97,F
852E:  BRA    8514
....................       fprintf(COM1,"AT+CMGD=3\r\n"); 
8530:  MOVLW  48
8532:  MOVWF  FF6
8534:  MOVLW  5A
8536:  MOVWF  FF7
8538:  CLRF   19
853A:  BTFSC  FF2.7
853C:  BSF    19.7
853E:  BCF    FF2.7
8540:  MOVLB  0
8542:  CALL   3B02
8546:  BTFSC  19.7
8548:  BSF    FF2.7
....................       delay_ms(1000); 
854A:  MOVLW  04
854C:  MOVLB  8
854E:  MOVWF  x97
8550:  CLRF   19
8552:  BTFSC  FF2.7
8554:  BSF    19.7
8556:  BCF    FF2.7
8558:  MOVLW  FA
855A:  MOVWF  xFA
855C:  MOVLB  0
855E:  CALL   1836
8562:  BTFSC  19.7
8564:  BSF    FF2.7
8566:  MOVLB  8
8568:  DECFSZ x97,F
856A:  BRA    8550
....................       fprintf(COM1,"AT+CMGD=4\r\n"); 
856C:  MOVLW  54
856E:  MOVWF  FF6
8570:  MOVLW  5A
8572:  MOVWF  FF7
8574:  CLRF   19
8576:  BTFSC  FF2.7
8578:  BSF    19.7
857A:  BCF    FF2.7
857C:  MOVLB  0
857E:  CALL   3B02
8582:  BTFSC  19.7
8584:  BSF    FF2.7
....................       delay_ms(1000); 
8586:  MOVLW  04
8588:  MOVLB  8
858A:  MOVWF  x97
858C:  CLRF   19
858E:  BTFSC  FF2.7
8590:  BSF    19.7
8592:  BCF    FF2.7
8594:  MOVLW  FA
8596:  MOVWF  xFA
8598:  MOVLB  0
859A:  CALL   1836
859E:  BTFSC  19.7
85A0:  BSF    FF2.7
85A2:  MOVLB  8
85A4:  DECFSZ x97,F
85A6:  BRA    858C
....................       fprintf(COM1,"AT+CMGD=5\r\n");  
85A8:  MOVLW  60
85AA:  MOVWF  FF6
85AC:  MOVLW  5A
85AE:  MOVWF  FF7
85B0:  CLRF   19
85B2:  BTFSC  FF2.7
85B4:  BSF    19.7
85B6:  BCF    FF2.7
85B8:  MOVLB  0
85BA:  CALL   3B02
85BE:  BTFSC  19.7
85C0:  BSF    FF2.7
....................       output_high(PIN_C2); 
85C2:  BCF    F94.2
85C4:  BSF    F8B.2
....................       delay_ms(1000); 
85C6:  MOVLW  04
85C8:  MOVLB  8
85CA:  MOVWF  x97
85CC:  CLRF   19
85CE:  BTFSC  FF2.7
85D0:  BSF    19.7
85D2:  BCF    FF2.7
85D4:  MOVLW  FA
85D6:  MOVWF  xFA
85D8:  MOVLB  0
85DA:  CALL   1836
85DE:  BTFSC  19.7
85E0:  BSF    FF2.7
85E2:  MOVLB  8
85E4:  DECFSZ x97,F
85E6:  BRA    85CC
....................       SIM_state= idle; 
85E8:  MOVLW  0C
85EA:  MOVLB  3
85EC:  MOVWF  x5C
....................       #ASM 
....................          BSF    0xF94.7 
85EE:  BSF    F94.7
....................       #ENDASM 
....................       //set_tris_c(0xff); 
....................    #endif 
....................    booting_done=1; 
85F0:  MOVLW  01
85F2:  MOVLB  8
85F4:  MOVWF  x8B
....................    charac_timeout=0xffffffff; 
85F6:  MOVLB  0
85F8:  SETF   xFC
85FA:  SETF   xFB
85FC:  CLRF   19
85FE:  BTFSC  FF2.7
8600:  BSF    19.7
8602:  BCF    FF2.7
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
8604:  MOVLW  66
8606:  MOVLB  9
8608:  MOVWF  xAE
860A:  MOVLW  10
860C:  MOVWF  xAF
860E:  MOVLW  08
8610:  MOVWF  xB1
8612:  MOVLW  7A
8614:  MOVWF  xB0
8616:  MOVLB  0
8618:  CALL   3D76
861C:  BTFSC  19.7
861E:  BSF    FF2.7
8620:  CLRF   19
8622:  BTFSC  FF2.7
8624:  BSF    19.7
8626:  BCF    FF2.7
....................    EEPROM_read(strobe_pass_addr,20,password); 
8628:  MOVLB  9
862A:  CLRF   xAE
862C:  MOVLW  14
862E:  MOVWF  xAF
8630:  CLRF   xB1
8632:  MOVLW  55
8634:  MOVWF  xB0
8636:  MOVLB  0
8638:  CALL   3D76
863C:  BTFSC  19.7
863E:  BSF    FF2.7
....................    set_tris_a(0xff);  
8640:  MOVLW  FF
8642:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
8644:  MOVLW  E0
8646:  MOVLB  F
8648:  MOVWF  x48
864A:  BCF    FC2.6
864C:  BCF    FC2.7
864E:  MOVF   x49,W
8650:  ANDLW  E0
8652:  IORLW  1F
8654:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
8656:  MOVF   FC1,W
8658:  ANDLW  C0
865A:  IORLW  03
865C:  MOVWF  FC1
865E:  BCF    FC1.7
8660:  BSF    FC2.0
8662:  BSF    FC1.6
8664:  BSF    FC2.1
8666:  BTFSC  FC2.1
8668:  BRA    8666
866A:  BCF    FC1.6
866C:  CLRF   19
866E:  BTFSC  FF2.7
8670:  BSF    19.7
8672:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
8674:  MOVLB  9
8676:  CLRF   xBD
8678:  MOVLW  7F
867A:  MOVWF  xBC
867C:  MOVLB  0
867E:  CALL   2E48
8682:  BTFSC  19.7
8684:  BSF    FF2.7
8686:  MOVFF  01,10C
....................    
....................    while(1) 
....................    { 
....................      if(mode==LOGOFF) 
868A:  MOVLB  8
868C:  MOVF   x6F,F
868E:  BNZ   8726
....................       { 
....................          fprintf(COM2,"password:"); 
8690:  MOVLW  6C
8692:  MOVWF  FF6
8694:  MOVLW  5A
8696:  MOVWF  FF7
8698:  CLRF   19
869A:  BTFSC  FF2.7
869C:  BSF    19.7
869E:  BCF    FF2.7
86A0:  MOVLB  0
86A2:  CALL   064E
86A6:  BTFSC  19.7
86A8:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
86AA:  MOVLW  02
86AC:  MOVLB  8
86AE:  MOVWF  xCD
86B0:  MOVLW  14
86B2:  MOVWF  xCE
86B4:  MOVLW  01
86B6:  MOVWF  xD0
86B8:  MOVLW  4A
86BA:  MOVWF  xCF
86BC:  MOVLB  0
86BE:  CALL   5E04
86C2:  CLRF   19
86C4:  BTFSC  FF2.7
86C6:  BSF    19.7
86C8:  BCF    FF2.7
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          if(!stringcomp(buffer_uart,password)) 
86CA:  MOVLW  01
86CC:  MOVLB  9
86CE:  MOVWF  xAF
86D0:  MOVLW  4A
86D2:  MOVWF  xAE
86D4:  CLRF   xB1
86D6:  MOVLW  55
86D8:  MOVWF  xB0
86DA:  MOVLB  0
86DC:  CALL   3DC4
86E0:  BTFSC  19.7
86E2:  BSF    FF2.7
86E4:  MOVF   01,F
86E6:  BNZ   870A
....................          { 
....................             mode=LOGON; 
86E8:  MOVLW  01
86EA:  MOVLB  8
86EC:  MOVWF  x6F
....................             fprintf(COM2," OK\n\r"); 
86EE:  MOVLW  76
86F0:  MOVWF  FF6
86F2:  MOVLW  5A
86F4:  MOVWF  FF7
86F6:  CLRF   19
86F8:  BTFSC  FF2.7
86FA:  BSF    19.7
86FC:  BCF    FF2.7
86FE:  MOVLB  0
8700:  CALL   064E
8704:  BTFSC  19.7
8706:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
8708:  BRA    8722
870A:  MOVLW  7C
870C:  MOVWF  FF6
870E:  MOVLW  5A
8710:  MOVWF  FF7
8712:  CLRF   19
8714:  BTFSC  FF2.7
8716:  BSF    19.7
8718:  BCF    FF2.7
871A:  CALL   064E
871E:  BTFSC  19.7
8720:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/ 
8722:  BRA    8730
8724:  MOVLB  8
8726:  DECFSZ x6F,W
8728:  BRA    8732
872A:  MOVLB  0
872C:  GOTO   6540
8730:  MOVLB  8
....................    } 
8732:  BRA    868C
.................... } 
8734:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

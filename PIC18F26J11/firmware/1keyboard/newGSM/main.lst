CCS PCH C Compiler, Version 4.140, 6310               29-Nov-15 07:07

               Filename:   C:\Users\quangnt\Desktop\newGSM\main.lst

               ROM used:   26900 bytes (41%)
                           Largest free fragment is 38624
               RAM used:   2696 (71%) at main() level
                           2873 (76%) worst case
               Stack:     10 worst case (5 in main + 5 for interrupts)

*
0000:  GOTO   64B4
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   3EEC
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   2396
006C:  BTFSS  FF0.3
006E:  GOTO   0078
0072:  BTFSC  FF0.0
0074:  GOTO   1ECE
0078:  BTFSS  F9D.5
007A:  GOTO   0084
007E:  BTFSC  F9E.5
0080:  GOTO   2342
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... //#define SIM900 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0522:  MOVLW  02
0524:  MOVLB  A
0526:  SUBWF  xE2,F
0528:  BNC   0542
052A:  MOVLW  0A
052C:  MOVWF  FEA
052E:  MOVLW  E2
0530:  MOVWF  FE9
0532:  MOVF   FEF,W
0534:  BZ    0542
0536:  BRA    053E
0538:  BRA    053A
053A:  BRA    053C
053C:  NOP   
053E:  DECFSZ FEF,F
0540:  BRA    0538
0542:  MOVLB  0
0544:  GOTO   1EDE (RETURN)
*
1B9C:  MOVLW  0A
1B9E:  MOVWF  FEA
1BA0:  MOVLW  EA
1BA2:  MOVWF  FE9
1BA4:  MOVF   FEF,W
1BA6:  BZ    1BC2
1BA8:  MOVLW  0A
1BAA:  MOVWF  01
1BAC:  CLRF   00
1BAE:  DECFSZ 00,F
1BB0:  BRA    1BAE
1BB2:  DECFSZ 01,F
1BB4:  BRA    1BAC
1BB6:  MOVLW  5F
1BB8:  MOVWF  00
1BBA:  DECFSZ 00,F
1BBC:  BRA    1BBA
1BBE:  DECFSZ FEF,F
1BC0:  BRA    1BA8
1BC2:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
0548:  BCF    F94.0
054A:  BCF    F8B.0
054C:  MOVLW  08
054E:  MOVWF  01
0550:  BRA    0552
0552:  NOP   
0554:  BSF    01.7
0556:  BRA    0578
0558:  BCF    01.7
055A:  MOVLB  B
055C:  RRCF   x16,F
055E:  MOVLB  0
0560:  BTFSC  FD8.0
0562:  BSF    F8B.0
0564:  BTFSS  FD8.0
0566:  BCF    F8B.0
0568:  BSF    01.6
056A:  BRA    0578
056C:  BCF    01.6
056E:  DECFSZ 01,F
0570:  BRA    055A
0572:  BRA    0574
0574:  NOP   
0576:  BSF    F8B.0
0578:  MOVLW  10
057A:  MOVWF  FE9
057C:  DECFSZ FE9,F
057E:  BRA    057C
0580:  BRA    0582
0582:  NOP   
0584:  BTFSC  01.7
0586:  BRA    0558
0588:  BTFSC  01.6
058A:  BRA    056C
058C:  RETURN 0
*
44CC:  BSF    F94.1
44CE:  BTFSC  F82.1
44D0:  BRA    44CE
44D2:  MOVLW  08
44D4:  MOVWF  00
44D6:  MOVLB  A
44D8:  CLRF   xC6
44DA:  BSF    00.7
44DC:  BRA    44FE
44DE:  BCF    00.7
44E0:  BRA    44FE
44E2:  MOVFF  AC6,02
44E6:  BCF    FD8.0
44E8:  BTFSC  F82.1
44EA:  BSF    FD8.0
44EC:  RRCF   02,F
44EE:  BSF    00.6
44F0:  BRA    44FE
44F2:  BCF    00.6
44F4:  DECFSZ 00,F
44F6:  BRA    44E6
44F8:  MOVFF  02,01
44FC:  BRA    4516
44FE:  MOVLW  10
4500:  BTFSC  00.7
4502:  MOVLW  04
4504:  MOVWF  01
4506:  DECFSZ 01,F
4508:  BRA    4506
450A:  BRA    450C
450C:  BTFSC  00.7
450E:  BRA    44DE
4510:  BTFSC  00.6
4512:  BRA    44F2
4514:  BRA    44E6
4516:  MOVLB  0
4518:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
2F52:  MOVLW  08
2F54:  MOVWF  01
2F56:  MOVLW  0A
2F58:  MOVWF  00
2F5A:  DECFSZ 00,F
2F5C:  BRA    2F5A
2F5E:  BCF    F8B.3
2F60:  BCF    F94.3
2F62:  MOVLW  0B
2F64:  MOVWF  00
2F66:  DECFSZ 00,F
2F68:  BRA    2F66
2F6A:  MOVLB  B
2F6C:  RLCF   x09,F
2F6E:  BCF    F8B.4
2F70:  BTFSC  FD8.0
2F72:  BSF    F94.4
2F74:  BTFSS  FD8.0
2F76:  BCF    F94.4
2F78:  BSF    F94.3
2F7A:  BTFSS  F82.3
2F7C:  BRA    2F7A
2F7E:  DECFSZ 01,F
2F80:  BRA    2F84
2F82:  BRA    2F88
2F84:  MOVLB  0
2F86:  BRA    2F56
2F88:  MOVLW  0A
2F8A:  MOVWF  00
2F8C:  DECFSZ 00,F
2F8E:  BRA    2F8C
2F90:  BCF    F8B.3
2F92:  BCF    F94.3
2F94:  NOP   
2F96:  BSF    F94.4
2F98:  MOVLW  0B
2F9A:  MOVWF  00
2F9C:  DECFSZ 00,F
2F9E:  BRA    2F9C
2FA0:  MOVLW  0B
2FA2:  MOVWF  00
2FA4:  DECFSZ 00,F
2FA6:  BRA    2FA4
2FA8:  BSF    F94.3
2FAA:  BTFSS  F82.3
2FAC:  BRA    2FAA
2FAE:  CLRF   01
2FB0:  MOVLW  0B
2FB2:  MOVWF  00
2FB4:  DECFSZ 00,F
2FB6:  BRA    2FB4
2FB8:  BTFSC  F82.4
2FBA:  BSF    01.0
2FBC:  BCF    F8B.3
2FBE:  BCF    F94.3
2FC0:  BCF    F8B.4
2FC2:  BCF    F94.4
2FC4:  MOVLB  0
2FC6:  RETURN 0
2FC8:  MOVLW  08
2FCA:  MOVLB  A
2FCC:  MOVWF  xF1
2FCE:  MOVFF  00,AF2
2FD2:  BSF    F94.4
2FD4:  MOVLW  0B
2FD6:  MOVWF  00
2FD8:  DECFSZ 00,F
2FDA:  BRA    2FD8
2FDC:  BSF    F94.3
2FDE:  BTFSS  F82.3
2FE0:  BRA    2FDE
2FE2:  BTFSC  F82.4
2FE4:  BSF    FD8.0
2FE6:  BTFSS  F82.4
2FE8:  BCF    FD8.0
2FEA:  RLCF   01,F
2FEC:  MOVLW  0A
2FEE:  MOVWF  00
2FF0:  DECFSZ 00,F
2FF2:  BRA    2FF0
2FF4:  BCF    F94.3
2FF6:  BCF    F8B.3
2FF8:  DECFSZ xF1,F
2FFA:  BRA    2FD2
2FFC:  BSF    F94.4
2FFE:  MOVLW  0B
3000:  MOVWF  00
3002:  DECFSZ 00,F
3004:  BRA    3002
3006:  BCF    F8B.4
3008:  MOVF   xF2,W
300A:  BTFSS  FD8.2
300C:  BCF    F94.4
300E:  NOP   
3010:  BSF    F94.3
3012:  BTFSS  F82.3
3014:  BRA    3012
3016:  MOVLW  0A
3018:  MOVWF  00
301A:  DECFSZ 00,F
301C:  BRA    301A
301E:  BCF    F8B.3
3020:  BCF    F94.3
3022:  MOVLW  0B
3024:  MOVWF  00
3026:  DECFSZ 00,F
3028:  BRA    3026
302A:  BCF    F8B.4
302C:  BCF    F94.4
302E:  MOVLB  0
3030:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... //#define EEPROM_SIZE   65535 
.................... #define EEPROM_SIZE_key    65535 
.................... #define EEPROM_SIZE        43590 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
4152:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
4154:  BSF    F94.4
....................    port_b_pullups(0xff); 
4156:  BCF    FF1.7
.................... } 
4158:  GOTO   664A (RETURN)
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
364C:  BSF    F94.4
364E:  MOVLW  0A
3650:  MOVWF  00
3652:  DECFSZ 00,F
3654:  BRA    3652
3656:  BSF    F94.3
3658:  MOVLW  0B
365A:  MOVWF  00
365C:  DECFSZ 00,F
365E:  BRA    365C
3660:  BCF    F8B.4
3662:  BCF    F94.4
3664:  MOVLW  0A
3666:  MOVWF  00
3668:  DECFSZ 00,F
366A:  BRA    3668
366C:  BCF    F8B.3
366E:  BCF    F94.3
....................    i2c_write(0xa0); 
3670:  MOVLW  A0
3672:  MOVLB  B
3674:  MOVWF  x09
3676:  MOVLB  0
3678:  RCALL  2F52
....................    i2c_write(address>>8); 
367A:  MOVFF  B03,B07
367E:  MOVLB  B
3680:  CLRF   x08
3682:  MOVFF  B03,B09
3686:  MOVLB  0
3688:  RCALL  2F52
....................    i2c_write(address); 
368A:  MOVFF  B02,B09
368E:  RCALL  2F52
....................    i2c_write(data); 
3690:  MOVFF  B04,B09
3694:  RCALL  2F52
....................    i2c_stop(); 
3696:  BCF    F94.4
3698:  NOP   
369A:  BSF    F94.3
369C:  BTFSS  F82.3
369E:  BRA    369C
36A0:  MOVLW  0A
36A2:  MOVWF  00
36A4:  DECFSZ 00,F
36A6:  BRA    36A4
36A8:  BRA    36AA
36AA:  NOP   
36AC:  BSF    F94.4
36AE:  MOVLW  0A
36B0:  MOVWF  00
36B2:  DECFSZ 00,F
36B4:  BRA    36B2
....................    i2c_start(); 
36B6:  BSF    F94.4
36B8:  MOVLW  0A
36BA:  MOVWF  00
36BC:  DECFSZ 00,F
36BE:  BRA    36BC
36C0:  BSF    F94.3
36C2:  MOVLW  0B
36C4:  MOVWF  00
36C6:  DECFSZ 00,F
36C8:  BRA    36C6
36CA:  BCF    F8B.4
36CC:  BCF    F94.4
36CE:  MOVLW  0A
36D0:  MOVWF  00
36D2:  DECFSZ 00,F
36D4:  BRA    36D2
36D6:  BCF    F8B.3
36D8:  BCF    F94.3
....................    status=i2c_write(0xa0); 
36DA:  MOVLW  A0
36DC:  MOVLB  B
36DE:  MOVWF  x09
36E0:  MOVLB  0
36E2:  RCALL  2F52
36E4:  MOVF   01,W
36E6:  MOVLB  B
36E8:  BCF    x05.0
36EA:  BTFSC  01.0
36EC:  BSF    x05.0
....................    while(status==1) 
....................    { 
36EE:  BTFSS  x05.0
36F0:  BRA    372E
....................       i2c_start(); 
36F2:  BSF    F94.4
36F4:  MOVLW  0A
36F6:  MOVWF  00
36F8:  DECFSZ 00,F
36FA:  BRA    36F8
36FC:  BSF    F94.3
36FE:  MOVLW  0B
3700:  MOVWF  00
3702:  DECFSZ 00,F
3704:  BRA    3702
3706:  BTFSS  F82.3
3708:  BRA    3706
370A:  BCF    F8B.4
370C:  BCF    F94.4
370E:  MOVLW  0A
3710:  MOVWF  00
3712:  DECFSZ 00,F
3714:  BRA    3712
3716:  BCF    F8B.3
3718:  BCF    F94.3
....................       status=i2c_write(0xa0); 
371A:  MOVLW  A0
371C:  MOVWF  x09
371E:  MOVLB  0
3720:  RCALL  2F52
3722:  MOVF   01,W
3724:  MOVLB  B
3726:  BCF    x05.0
3728:  BTFSC  01.0
372A:  BSF    x05.0
....................    } 
372C:  BRA    36EE
....................    i2c_stop(); 
372E:  BCF    F94.4
3730:  NOP   
3732:  BSF    F94.3
3734:  BTFSS  F82.3
3736:  BRA    3734
3738:  MOVLW  0A
373A:  MOVWF  00
373C:  DECFSZ 00,F
373E:  BRA    373C
3740:  BRA    3742
3742:  NOP   
3744:  BSF    F94.4
3746:  MOVLW  0A
3748:  MOVWF  00
374A:  DECFSZ 00,F
374C:  BRA    374A
.................... } 
374E:  MOVLB  0
3750:  RETURN 0
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
30FC:  BSF    F94.4
30FE:  MOVLW  0A
3100:  MOVWF  00
3102:  DECFSZ 00,F
3104:  BRA    3102
3106:  BSF    F94.3
3108:  MOVLW  0B
310A:  MOVWF  00
310C:  DECFSZ 00,F
310E:  BRA    310C
3110:  BCF    F8B.4
3112:  BCF    F94.4
3114:  MOVLW  0A
3116:  MOVWF  00
3118:  DECFSZ 00,F
311A:  BRA    3118
311C:  BCF    F8B.3
311E:  BCF    F94.3
....................    i2c_write(0xa0); 
3120:  MOVLW  A0
3122:  MOVLB  B
3124:  MOVWF  x09
3126:  MOVLB  0
3128:  RCALL  2F52
....................    i2c_write(address>>8); 
312A:  MOVFF  AEE,AF0
312E:  MOVLB  A
3130:  CLRF   xF1
3132:  MOVFF  AEE,B09
3136:  MOVLB  0
3138:  RCALL  2F52
....................    i2c_write(address); 
313A:  MOVFF  AED,B09
313E:  RCALL  2F52
....................    i2c_start(); 
3140:  BSF    F94.4
3142:  MOVLW  0A
3144:  MOVWF  00
3146:  DECFSZ 00,F
3148:  BRA    3146
314A:  BSF    F94.3
314C:  MOVLW  0B
314E:  MOVWF  00
3150:  DECFSZ 00,F
3152:  BRA    3150
3154:  BTFSS  F82.3
3156:  BRA    3154
3158:  BCF    F8B.4
315A:  BCF    F94.4
315C:  MOVLW  0A
315E:  MOVWF  00
3160:  DECFSZ 00,F
3162:  BRA    3160
3164:  BCF    F8B.3
3166:  BCF    F94.3
....................    i2c_write(0xa1); 
3168:  MOVLW  A1
316A:  MOVLB  B
316C:  MOVWF  x09
316E:  MOVLB  0
3170:  RCALL  2F52
....................    data=i2c_read(0); 
3172:  CLRF   00
3174:  RCALL  2FC8
3176:  MOVFF  01,AEF
....................    i2c_stop(); 
317A:  BCF    F94.4
317C:  NOP   
317E:  BSF    F94.3
3180:  BTFSS  F82.3
3182:  BRA    3180
3184:  MOVLW  0A
3186:  MOVWF  00
3188:  DECFSZ 00,F
318A:  BRA    3188
318C:  BRA    318E
318E:  NOP   
3190:  BSF    F94.4
3192:  MOVLW  0A
3194:  MOVWF  00
3196:  DECFSZ 00,F
3198:  BRA    3196
....................    return(data); 
319A:  MOVLB  A
319C:  MOVFF  AEF,01
.................... } 
31A0:  MOVLB  0
31A2:  RETURN 0
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
471E:  MOVLB  A
4720:  MOVF   xC1,W
4722:  ADDWF  xBF,W
4724:  MOVWF  xC7
4726:  MOVF   xC2,W
4728:  ADDWFC xC0,W
472A:  MOVWF  xC8
472C:  SUBLW  A9
472E:  BC    4740
4730:  XORLW  FF
4732:  BNZ   473A
4734:  MOVF   xC7,W
4736:  SUBLW  45
4738:  BC    4740
473A:  MOVLW  00
473C:  MOVWF  01
473E:  BRA    479E
....................    for(i=0;i<len;i++) 
4740:  CLRF   xC6
4742:  CLRF   xC5
4744:  MOVF   xC6,W
4746:  SUBWF  xC2,W
4748:  BNC   479E
474A:  BNZ   4752
474C:  MOVF   xC1,W
474E:  SUBWF  xC5,W
4750:  BC    479E
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
4752:  MOVF   xC3,W
4754:  ADDWF  xC5,W
4756:  MOVWF  01
4758:  MOVF   xC4,W
475A:  ADDWFC xC6,W
475C:  MOVWF  03
475E:  MOVFF  01,AC7
4762:  MOVWF  xC8
4764:  MOVF   xC5,W
4766:  ADDWF  xBF,W
4768:  MOVWF  xC9
476A:  MOVF   xC6,W
476C:  ADDWFC xC0,W
476E:  MOVWF  xCA
4770:  CLRF   19
4772:  BTFSC  FF2.7
4774:  BSF    19.7
4776:  BCF    FF2.7
4778:  MOVWF  xEE
477A:  MOVFF  AC9,AED
477E:  MOVLB  0
4780:  CALL   30FC
4784:  BTFSC  19.7
4786:  BSF    FF2.7
4788:  MOVFF  AC8,FEA
478C:  MOVFF  AC7,FE9
4790:  MOVFF  01,FEF
....................    } 
4794:  MOVLB  A
4796:  INCF   xC5,F
4798:  BTFSC  FD8.2
479A:  INCF   xC6,F
479C:  BRA    4744
....................     
.................... } 
479E:  MOVLB  0
47A0:  GOTO   4F7A (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_count_num         65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_delaykb           149 
.................... #define KB_time                  126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards                350   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
3216:  MOVLB  A
3218:  CLRF   xF6
321A:  MOVF   xF3,W
321C:  SUBWF  xF6,W
321E:  BC    3234
....................    { 
....................       inputdat[i]=0; 
3220:  CLRF   03
3222:  MOVF   xF6,W
3224:  ADDWF  xF4,W
3226:  MOVWF  FE9
3228:  MOVF   xF5,W
322A:  ADDWFC 03,W
322C:  MOVWF  FEA
322E:  CLRF   FEF
....................    } 
3230:  INCF   xF6,F
3232:  BRA    321A
.................... } 
3234:  MOVLB  0
3236:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_write(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
41B6:  MOVLB  A
41B8:  CLRF   xD6
41BA:  MOVF   xD3,W
41BC:  SUBWF  xD6,W
41BE:  BC    4206
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
41C0:  MOVF   xD6,W
41C2:  ADDWF  xD2,W
41C4:  MOVWF  xD7
41C6:  CLRF   03
41C8:  MOVF   xD6,W
41CA:  ADDWF  xD4,W
41CC:  MOVWF  FE9
41CE:  MOVF   xD5,W
41D0:  ADDWFC 03,W
41D2:  MOVWF  FEA
41D4:  MOVFF  FEF,AD8
41D8:  CLRF   19
41DA:  BTFSC  FF2.7
41DC:  BSF    19.7
41DE:  BCF    FF2.7
41E0:  MOVLB  B
41E2:  CLRF   x03
41E4:  MOVFF  AD7,B02
41E8:  MOVFF  AD8,B04
41EC:  MOVLB  0
41EE:  CALL   364C
41F2:  BTFSC  19.7
41F4:  BSF    FF2.7
....................       delay_us(10); 
41F6:  MOVLW  1A
41F8:  MOVWF  00
41FA:  DECFSZ 00,F
41FC:  BRA    41FA
41FE:  NOP   
....................    } 
4200:  MOVLB  A
4202:  INCF   xD6,F
4204:  BRA    41BA
.................... } 
4206:  MOVLB  0
4208:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
415C:  MOVLB  A
415E:  CLRF   xC1
4160:  MOVF   xBE,W
4162:  SUBWF  xC1,W
4164:  BC    41B2
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
4166:  CLRF   03
4168:  MOVF   xC1,W
416A:  ADDWF  xBF,W
416C:  MOVWF  01
416E:  MOVF   xC0,W
4170:  ADDWFC 03,F
4172:  MOVFF  01,AC2
4176:  MOVFF  03,AC3
417A:  MOVF   xC1,W
417C:  ADDWF  xBD,W
417E:  MOVWF  xC4
4180:  CLRF   19
4182:  BTFSC  FF2.7
4184:  BSF    19.7
4186:  BCF    FF2.7
4188:  CLRF   xEE
418A:  MOVWF  xED
418C:  MOVLB  0
418E:  CALL   30FC
4192:  BTFSC  19.7
4194:  BSF    FF2.7
4196:  MOVFF  AC3,FEA
419A:  MOVFF  AC2,FE9
419E:  MOVFF  01,FEF
....................       delay_us(10); 
41A2:  MOVLW  1A
41A4:  MOVWF  00
41A6:  DECFSZ 00,F
41A8:  BRA    41A6
41AA:  NOP   
....................    } 
41AC:  MOVLB  A
41AE:  INCF   xC1,F
41B0:  BRA    4160
.................... } 
41B2:  MOVLB  0
41B4:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
438E:  MOVLB  A
4390:  CLRF   x8B
4392:  CLRF   x8A
4394:  CLRF   x89
4396:  CLRF   x88
4398:  CLRF   x8F
439A:  CLRF   x8E
439C:  CLRF   x8D
439E:  CLRF   x8C
43A0:  CLRF   x93
43A2:  CLRF   x92
43A4:  CLRF   x91
43A6:  CLRF   x90
43A8:  CLRF   x97
43AA:  CLRF   x96
43AC:  CLRF   x95
43AE:  CLRF   x94
43B0:  CLRF   x9B
43B2:  CLRF   x9A
43B4:  CLRF   x99
43B6:  CLRF   x98
43B8:  CLRF   19
43BA:  BTFSC  FF2.7
43BC:  BSF    19.7
43BE:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
43C0:  CLRF   xEE
43C2:  MOVFF  A87,AED
43C6:  MOVLB  0
43C8:  CALL   30FC
43CC:  BTFSC  19.7
43CE:  BSF    FF2.7
43D0:  MOVLB  A
43D2:  MOVFF  01,A8C
43D6:  CLRF   x8D
43D8:  CLRF   x8E
43DA:  CLRF   x8F
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
43DC:  MOVLW  01
43DE:  ADDWF  x87,W
43E0:  MOVWF  x9C
43E2:  CLRF   19
43E4:  BTFSC  FF2.7
43E6:  BSF    19.7
43E8:  BCF    FF2.7
43EA:  CLRF   xEE
43EC:  MOVWF  xED
43EE:  MOVLB  0
43F0:  CALL   30FC
43F4:  BTFSC  19.7
43F6:  BSF    FF2.7
43F8:  MOVLB  A
43FA:  CLRF   x93
43FC:  CLRF   x92
43FE:  CLRF   x91
4400:  MOVFF  01,A90
....................    temp2<<=8; 
4404:  MOVFF  A92,A93
4408:  MOVFF  A91,A92
440C:  MOVFF  A90,A91
4410:  CLRF   x90
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
4412:  MOVLW  02
4414:  ADDWF  x87,W
4416:  MOVWF  x9C
4418:  CLRF   19
441A:  BTFSC  FF2.7
441C:  BSF    19.7
441E:  BCF    FF2.7
4420:  CLRF   xEE
4422:  MOVWF  xED
4424:  MOVLB  0
4426:  CALL   30FC
442A:  BTFSC  19.7
442C:  BSF    FF2.7
442E:  MOVLB  A
4430:  CLRF   x97
4432:  CLRF   x96
4434:  CLRF   x95
4436:  MOVFF  01,A94
....................    temp3<<=16; 
443A:  MOVFF  A95,A97
443E:  MOVFF  A94,A96
4442:  CLRF   x94
4444:  CLRF   x95
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
4446:  MOVLW  03
4448:  ADDWF  x87,W
444A:  MOVWF  x9C
444C:  CLRF   19
444E:  BTFSC  FF2.7
4450:  BSF    19.7
4452:  BCF    FF2.7
4454:  CLRF   xEE
4456:  MOVWF  xED
4458:  MOVLB  0
445A:  CALL   30FC
445E:  BTFSC  19.7
4460:  BSF    FF2.7
4462:  MOVLB  A
4464:  CLRF   x9B
4466:  CLRF   x9A
4468:  CLRF   x99
446A:  MOVFF  01,A98
....................    temp4<<=24; 
446E:  MOVFF  A98,A9B
4472:  CLRF   x98
4474:  CLRF   x99
4476:  CLRF   x9A
....................    buffer = temp4|temp3|temp2|temp1; 
4478:  MOVF   x98,W
447A:  IORWF  x94,W
447C:  MOVWF  x9C
447E:  MOVF   x99,W
4480:  IORWF  x95,W
4482:  MOVWF  x9D
4484:  MOVF   x9A,W
4486:  IORWF  x96,W
4488:  MOVWF  x9E
448A:  MOVF   x9B,W
448C:  IORWF  x97,W
448E:  MOVWF  x9F
4490:  MOVF   x90,W
4492:  IORWF  x9C,F
4494:  MOVF   x91,W
4496:  IORWF  x9D,F
4498:  MOVF   x92,W
449A:  IORWF  x9E,F
449C:  MOVF   x93,W
449E:  IORWF  x9F,F
44A0:  MOVF   x9C,W
44A2:  IORWF  x8C,W
44A4:  MOVWF  x88
44A6:  MOVF   x9D,W
44A8:  IORWF  x8D,W
44AA:  MOVWF  x89
44AC:  MOVF   x9E,W
44AE:  IORWF  x8E,W
44B0:  MOVWF  x8A
44B2:  MOVF   x9F,W
44B4:  IORWF  x8F,W
44B6:  MOVWF  x8B
....................    return(buffer); 
44B8:  MOVFF  A88,00
44BC:  MOVFF  A89,01
44C0:  MOVFF  A8A,02
44C4:  MOVFF  A8B,03
.................... } 
44C8:  MOVLB  0
44CA:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3752:  MOVLB  A
3754:  CLRF   xEF
3756:  CLRF   xEE
3758:  CLRF   xED
375A:  CLRF   xEC
375C:  CLRF   xF0
375E:  CLRF   xF1
3760:  CLRF   xF2
3762:  CLRF   xF3
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3764:  MOVFF  AEA,AEF
3768:  MOVFF  AE9,AEE
376C:  MOVFF  AE8,AED
3770:  MOVFF  AE7,AEC
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3774:  MOVFF  AEC,AF0
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3778:  MOVFF  AED,AF1
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
377C:  MOVFF  AEE,AF2
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3780:  MOVFF  AEF,AF3
....................    write_ext_eeprom((addr+0),temp1); 
3784:  MOVLB  B
3786:  CLRF   x03
3788:  MOVFF  AEB,B02
378C:  MOVFF  AF0,B04
3790:  MOVLB  0
3792:  RCALL  364C
....................    write_ext_eeprom((addr+1),temp2); 
3794:  MOVLW  01
3796:  MOVLB  A
3798:  ADDWF  xEB,W
379A:  MOVWF  xF4
379C:  MOVLB  B
379E:  CLRF   x03
37A0:  MOVWF  x02
37A2:  MOVFF  AF1,B04
37A6:  MOVLB  0
37A8:  RCALL  364C
....................    write_ext_eeprom((addr+2),temp3); 
37AA:  MOVLW  02
37AC:  MOVLB  A
37AE:  ADDWF  xEB,W
37B0:  MOVWF  xF4
37B2:  MOVLB  B
37B4:  CLRF   x03
37B6:  MOVWF  x02
37B8:  MOVFF  AF2,B04
37BC:  MOVLB  0
37BE:  RCALL  364C
....................    write_ext_eeprom((addr+3),temp4); 
37C0:  MOVLW  03
37C2:  MOVLB  A
37C4:  ADDWF  xEB,W
37C6:  MOVWF  xF4
37C8:  MOVLB  B
37CA:  CLRF   x03
37CC:  MOVWF  x02
37CE:  MOVFF  AF3,B04
37D2:  MOVLB  0
37D4:  RCALL  364C
.................... } 
37D6:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
3DBA:  MOVLB  A
3DBC:  CLRF   xE7
3DBE:  CLRF   xE6
3DC0:  CLRF   xE8
3DC2:  CLRF   xE9
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
3DC4:  MOVFF  AE5,AE7
3DC8:  MOVFF  AE4,AE6
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3DCC:  MOVFF  AE6,AE8
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3DD0:  MOVF   xE7,W
3DD2:  MOVWF  xE9
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
3DD4:  MOVLB  B
3DD6:  CLRF   x03
3DD8:  MOVLW  28
3DDA:  MOVWF  x02
3DDC:  MOVFF  AE8,B04
3DE0:  MOVLB  0
3DE2:  RCALL  364C
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
3DE4:  MOVLB  B
3DE6:  CLRF   x03
3DE8:  MOVLW  29
3DEA:  MOVWF  x02
3DEC:  MOVFF  AE9,B04
3DF0:  MOVLB  0
3DF2:  RCALL  364C
.................... } 
3DF4:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
31A4:  MOVLB  A
31A6:  CLRF   xE8
31A8:  CLRF   xE7
31AA:  CLRF   xEA
31AC:  CLRF   xE9
31AE:  CLRF   xEC
31B0:  CLRF   xEB
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
31B2:  CLRF   xEE
31B4:  MOVLW  28
31B6:  MOVWF  xED
31B8:  MOVLB  0
31BA:  RCALL  30FC
31BC:  MOVLB  A
31BE:  MOVFF  01,AE9
31C2:  CLRF   xEA
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
31C4:  CLRF   xEE
31C6:  MOVLW  29
31C8:  MOVWF  xED
31CA:  MOVLB  0
31CC:  RCALL  30FC
31CE:  MOVLB  A
31D0:  CLRF   xEC
31D2:  MOVFF  01,AEB
....................    temp2<<=8; 
31D6:  MOVFF  AEB,AEC
31DA:  CLRF   xEB
....................    buffer = temp2|temp1; 
31DC:  MOVF   xEB,W
31DE:  IORWF  xE9,W
31E0:  MOVWF  xE7
31E2:  MOVF   xEC,W
31E4:  IORWF  xEA,W
31E6:  MOVWF  xE8
....................    return(buffer); 
31E8:  MOVFF  AE7,01
31EC:  MOVFF  AE8,02
.................... } 
31F0:  MOVLB  0
31F2:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int16 i; 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
48BA:  MOVLW  AA
48BC:  MOVLB  A
48BE:  MOVWF  xBE
48C0:  MOVLW  47
48C2:  MOVWF  xBD
48C4:  MOVF   27,F
48C6:  BNZ   48DA
48C8:  MOVF   26,F
48CA:  BNZ   48DA
48CC:  MOVF   xBE,W
48CE:  SUBWF  25,W
48D0:  BNC   4902
48D2:  BNZ   48DA
48D4:  MOVF   24,W
48D6:  SUBWF  xBD,W
48D8:  BC    4902
48DA:  CLRF   19
48DC:  BTFSC  FF2.7
48DE:  BSF    19.7
48E0:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
48E2:  MOVFF  ABE,B03
48E6:  MOVFF  ABD,B02
48EA:  MOVLB  B
48EC:  CLRF   x04
48EE:  MOVLB  0
48F0:  CALL   364C
48F4:  BTFSC  19.7
48F6:  BSF    FF2.7
....................    } 
48F8:  MOVLB  A
48FA:  INCF   xBD,F
48FC:  BTFSC  FD8.2
48FE:  INCF   xBE,F
4900:  BRA    48C4
....................    for(i=ptr_start;i<ptr_card;i++) 
4902:  CLRF   xBE
4904:  MOVLW  96
4906:  MOVWF  xBD
4908:  MOVF   23,F
490A:  BNZ   491E
490C:  MOVF   22,F
490E:  BNZ   491E
4910:  MOVF   xBE,W
4912:  SUBWF  21,W
4914:  BNC   4946
4916:  BNZ   491E
4918:  MOVF   20,W
491A:  SUBWF  xBD,W
491C:  BC    4946
491E:  CLRF   19
4920:  BTFSC  FF2.7
4922:  BSF    19.7
4924:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
4926:  MOVFF  ABE,B03
492A:  MOVFF  ABD,B02
492E:  MOVLB  B
4930:  CLRF   x04
4932:  MOVLB  0
4934:  CALL   364C
4938:  BTFSC  19.7
493A:  BSF    FF2.7
....................    } 
493C:  MOVLB  A
493E:  INCF   xBD,F
4940:  BTFSC  FD8.2
4942:  INCF   xBE,F
4944:  BRA    4908
....................    ptr_card=ptr_start; 
4946:  CLRF   23
4948:  CLRF   22
494A:  CLRF   21
494C:  MOVLW  96
494E:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
4950:  CLRF   27
4952:  CLRF   26
4954:  MOVLW  AA
4956:  MOVWF  25
4958:  MOVLW  47
495A:  MOVWF  24
495C:  CLRF   19
495E:  BTFSC  FF2.7
4960:  BSF    19.7
4962:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
4964:  MOVFF  23,AEA
4968:  MOVFF  22,AE9
496C:  MOVFF  21,AE8
4970:  MOVFF  20,AE7
4974:  MOVLW  19
4976:  MOVWF  xEB
4978:  MOVLB  0
497A:  CALL   3752
497E:  BTFSC  19.7
4980:  BSF    FF2.7
4982:  CLRF   19
4984:  BTFSC  FF2.7
4986:  BSF    19.7
4988:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
498A:  MOVFF  27,AEA
498E:  MOVFF  26,AE9
4992:  MOVFF  25,AE8
4996:  MOVFF  24,AE7
499A:  MOVLW  1E
499C:  MOVLB  A
499E:  MOVWF  xEB
49A0:  MOVLB  0
49A2:  CALL   3752
49A6:  BTFSC  19.7
49A8:  BSF    FF2.7
49AA:  CLRF   19
49AC:  BTFSC  FF2.7
49AE:  BSF    19.7
49B0:  BCF    FF2.7
....................    save_coutcard(0); 
49B2:  MOVLB  A
49B4:  CLRF   xE5
49B6:  CLRF   xE4
49B8:  MOVLB  0
49BA:  CALL   3DBA
49BE:  BTFSC  19.7
49C0:  BSF    FF2.7
49C2:  CLRF   19
49C4:  BTFSC  FF2.7
49C6:  BSF    19.7
49C8:  BCF    FF2.7
....................    countcard=get_countcard(); 
49CA:  CALL   31A4
49CE:  BTFSC  19.7
49D0:  BSF    FF2.7
49D2:  MOVFF  02,FA
49D6:  MOVFF  01,F9
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
.................... } 
49DA:  GOTO   52CA (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int16 i; 
....................    for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
49DE:  MOVLB  A
49E0:  CLRF   xBE
49E2:  MOVLW  96
49E4:  MOVWF  xBD
49E6:  INCFSZ xBD,W
49E8:  BRA    49F0
49EA:  INCFSZ xBE,W
49EC:  BRA    49F0
49EE:  BRA    4A18
49F0:  CLRF   19
49F2:  BTFSC  FF2.7
49F4:  BSF    19.7
49F6:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
49F8:  MOVFF  ABE,B03
49FC:  MOVFF  ABD,B02
4A00:  MOVLB  B
4A02:  CLRF   x04
4A04:  MOVLB  0
4A06:  CALL   364C
4A0A:  BTFSC  19.7
4A0C:  BSF    FF2.7
....................    } 
4A0E:  MOVLB  A
4A10:  INCF   xBD,F
4A12:  BTFSC  FD8.2
4A14:  INCF   xBE,F
4A16:  BRA    49E6
....................    ptr_card=ptr_start; 
4A18:  CLRF   23
4A1A:  CLRF   22
4A1C:  CLRF   21
4A1E:  MOVLW  96
4A20:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
4A22:  CLRF   27
4A24:  CLRF   26
4A26:  MOVLW  AA
4A28:  MOVWF  25
4A2A:  MOVLW  47
4A2C:  MOVWF  24
4A2E:  CLRF   19
4A30:  BTFSC  FF2.7
4A32:  BSF    19.7
4A34:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
4A36:  MOVFF  23,AEA
4A3A:  MOVFF  22,AE9
4A3E:  MOVFF  21,AE8
4A42:  MOVFF  20,AE7
4A46:  MOVLW  19
4A48:  MOVWF  xEB
4A4A:  MOVLB  0
4A4C:  CALL   3752
4A50:  BTFSC  19.7
4A52:  BSF    FF2.7
4A54:  CLRF   19
4A56:  BTFSC  FF2.7
4A58:  BSF    19.7
4A5A:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
4A5C:  MOVFF  27,AEA
4A60:  MOVFF  26,AE9
4A64:  MOVFF  25,AE8
4A68:  MOVFF  24,AE7
4A6C:  MOVLW  1E
4A6E:  MOVLB  A
4A70:  MOVWF  xEB
4A72:  MOVLB  0
4A74:  CALL   3752
4A78:  BTFSC  19.7
4A7A:  BSF    FF2.7
4A7C:  CLRF   19
4A7E:  BTFSC  FF2.7
4A80:  BSF    19.7
4A82:  BCF    FF2.7
....................    save_coutcard(0); 
4A84:  MOVLB  A
4A86:  CLRF   xE5
4A88:  CLRF   xE4
4A8A:  MOVLB  0
4A8C:  CALL   3DBA
4A90:  BTFSC  19.7
4A92:  BSF    FF2.7
.................... } 
4A94:  GOTO   5330 (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
420A:  MOVLB  A
420C:  CLRF   xBD
420E:  MOVLW  14
4210:  MOVWF  xBE
4212:  CLRF   xC0
4214:  MOVLW  55
4216:  MOVWF  xBF
4218:  MOVLB  0
421A:  RCALL  415C
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
421C:  INCFSZ 55,W
421E:  BRA    4274
4220:  INCFSZ 56,W
4222:  BRA    4274
4224:  INCFSZ x64,W
4226:  BRA    4274
....................       { 
....................          memset(buffer1,0,20); 
4228:  CLRF   FEA
422A:  MOVLW  2D
422C:  MOVWF  FE9
422E:  CLRF   00
4230:  CLRF   02
4232:  MOVLW  14
4234:  MOVWF  01
4236:  RCALL  3C58
....................          strcpy(buffer1,"admin"); 
4238:  CLRF   FEA
423A:  MOVLW  2D
423C:  MOVWF  FE9
423E:  MOVLW  00
4240:  CALL   00D2
4244:  TBLRD*-
4246:  TBLRD*+
4248:  MOVF   FF5,W
424A:  MOVWF  FEE
424C:  IORLW  00
424E:  BNZ   4246
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
4250:  MOVLB  A
4252:  CLRF   xD2
4254:  MOVLW  14
4256:  MOVWF  xD3
4258:  CLRF   xD5
425A:  MOVLW  2D
425C:  MOVWF  xD4
425E:  MOVLB  0
4260:  RCALL  41B6
....................          EEPROM_read(strobe_pass_addr,20,password); 
4262:  MOVLB  A
4264:  CLRF   xBD
4266:  MOVLW  14
4268:  MOVWF  xBE
426A:  CLRF   xC0
426C:  MOVLW  55
426E:  MOVWF  xBF
4270:  MOVLB  0
4272:  RCALL  415C
....................       } 
.................... } 
4274:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
4A98:  MOVLB  A
4A9A:  CLRF   xD1
4A9C:  MOVF   xD1,W
4A9E:  SUBLW  13
4AA0:  BNC   4AB6
4AA2:  CLRF   03
4AA4:  MOVF   xD1,W
4AA6:  ADDLW  BD
4AA8:  MOVWF  FE9
4AAA:  MOVLW  0A
4AAC:  ADDWFC 03,W
4AAE:  MOVWF  FEA
4AB0:  SETF   FEF
4AB2:  INCF   xD1,F
4AB4:  BRA    4A9C
....................    EEPROM_write(strobe_pass_addr,20,buf); 
4AB6:  CLRF   xD2
4AB8:  MOVLW  14
4ABA:  MOVWF  xD3
4ABC:  MOVLW  0A
4ABE:  MOVWF  xD5
4AC0:  MOVLW  BD
4AC2:  MOVWF  xD4
4AC4:  MOVLB  0
4AC6:  CALL   41B6
.................... } 
4ACA:  GOTO   5396 (RETURN)
.................... //============================================ 
....................  
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
3032:  BSF    F94.4
3034:  MOVLW  0A
3036:  MOVWF  00
3038:  DECFSZ 00,F
303A:  BRA    3038
303C:  BSF    F94.3
303E:  MOVLW  0B
3040:  MOVWF  00
3042:  DECFSZ 00,F
3044:  BRA    3042
3046:  BCF    F8B.4
3048:  BCF    F94.4
304A:  MOVLW  0A
304C:  MOVWF  00
304E:  DECFSZ 00,F
3050:  BRA    304E
3052:  BCF    F8B.3
3054:  BCF    F94.3
....................    i2c_write(0xD0); 
3056:  MOVLW  D0
3058:  MOVLB  B
305A:  MOVWF  x09
305C:  MOVLB  0
305E:  RCALL  2F52
....................    i2c_write(address); 
3060:  MOVFF  AEB,B09
3064:  RCALL  2F52
....................    i2c_start(); 
3066:  BSF    F94.4
3068:  MOVLW  0A
306A:  MOVWF  00
306C:  DECFSZ 00,F
306E:  BRA    306C
3070:  BSF    F94.3
3072:  MOVLW  0B
3074:  MOVWF  00
3076:  DECFSZ 00,F
3078:  BRA    3076
307A:  BTFSS  F82.3
307C:  BRA    307A
307E:  BCF    F8B.4
3080:  BCF    F94.4
3082:  MOVLW  0A
3084:  MOVWF  00
3086:  DECFSZ 00,F
3088:  BRA    3086
308A:  BCF    F8B.3
308C:  BCF    F94.3
....................    i2c_write(0xD1); 
308E:  MOVLW  D1
3090:  MOVLB  B
3092:  MOVWF  x09
3094:  MOVLB  0
3096:  RCALL  2F52
....................    result = i2c_read(0); 
3098:  CLRF   00
309A:  RCALL  2FC8
309C:  MOVFF  01,AEC
....................    i2c_stop(); 
30A0:  BCF    F94.4
30A2:  NOP   
30A4:  BSF    F94.3
30A6:  BTFSS  F82.3
30A8:  BRA    30A6
30AA:  MOVLW  0A
30AC:  MOVWF  00
30AE:  DECFSZ 00,F
30B0:  BRA    30AE
30B2:  BRA    30B4
30B4:  NOP   
30B6:  BSF    F94.4
30B8:  MOVLW  0A
30BA:  MOVWF  00
30BC:  DECFSZ 00,F
30BE:  BRA    30BC
....................     
....................    return(result); 
30C0:  MOVLB  A
30C2:  MOVFF  AEC,01
.................... } 
30C6:  MOVLB  0
30C8:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
4C7A:  BSF    F94.4
4C7C:  MOVLW  0A
4C7E:  MOVWF  00
4C80:  DECFSZ 00,F
4C82:  BRA    4C80
4C84:  BSF    F94.3
4C86:  MOVLW  0B
4C88:  MOVWF  00
4C8A:  DECFSZ 00,F
4C8C:  BRA    4C8A
4C8E:  BCF    F8B.4
4C90:  BCF    F94.4
4C92:  MOVLW  0A
4C94:  MOVWF  00
4C96:  DECFSZ 00,F
4C98:  BRA    4C96
4C9A:  BCF    F8B.3
4C9C:  BCF    F94.3
....................    delay_us(10); 
4C9E:  MOVLW  1A
4CA0:  MOVWF  00
4CA2:  DECFSZ 00,F
4CA4:  BRA    4CA2
4CA6:  NOP   
4CA8:  CLRF   19
4CAA:  BTFSC  FF2.7
4CAC:  BSF    19.7
4CAE:  BCF    FF2.7
....................    i2c_write(0xD0); 
4CB0:  MOVLW  D0
4CB2:  MOVLB  B
4CB4:  MOVWF  x09
4CB6:  MOVLB  0
4CB8:  CALL   2F52
4CBC:  BTFSC  19.7
4CBE:  BSF    FF2.7
....................    delay_us(10); 
4CC0:  MOVLW  1A
4CC2:  MOVWF  00
4CC4:  DECFSZ 00,F
4CC6:  BRA    4CC4
4CC8:  NOP   
4CCA:  CLRF   19
4CCC:  BTFSC  FF2.7
4CCE:  BSF    19.7
4CD0:  BCF    FF2.7
....................    i2c_write(address); 
4CD2:  MOVFF  AC4,B09
4CD6:  CALL   2F52
4CDA:  BTFSC  19.7
4CDC:  BSF    FF2.7
....................    delay_us(10); 
4CDE:  MOVLW  1A
4CE0:  MOVWF  00
4CE2:  DECFSZ 00,F
4CE4:  BRA    4CE2
4CE6:  NOP   
4CE8:  CLRF   19
4CEA:  BTFSC  FF2.7
4CEC:  BSF    19.7
4CEE:  BCF    FF2.7
....................    i2c_write(data); 
4CF0:  MOVFF  AC5,B09
4CF4:  CALL   2F52
4CF8:  BTFSC  19.7
4CFA:  BSF    FF2.7
....................    i2c_stop(); 
4CFC:  BCF    F94.4
4CFE:  NOP   
4D00:  BSF    F94.3
4D02:  BTFSS  F82.3
4D04:  BRA    4D02
4D06:  MOVLW  0A
4D08:  MOVWF  00
4D0A:  DECFSZ 00,F
4D0C:  BRA    4D0A
4D0E:  BRA    4D10
4D10:  NOP   
4D12:  BSF    F94.4
4D14:  MOVLW  0A
4D16:  MOVWF  00
4D18:  DECFSZ 00,F
4D1A:  BRA    4D18
....................    delay_us(10); 
4D1C:  MOVLW  1A
4D1E:  MOVWF  00
4D20:  DECFSZ 00,F
4D22:  BRA    4D20
4D24:  NOP   
.................... } 
4D26:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
*
4276:  CLRF   19
4278:  BTFSC  FF2.7
427A:  BSF    19.7
427C:  BCF    FF2.7
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
427E:  MOVLB  A
4280:  CLRF   xEB
4282:  MOVLB  0
4284:  CALL   3032
4288:  BTFSC  19.7
428A:  BSF    FF2.7
428C:  MOVFF  01,A87
....................     
....................    data &= 0x7F; 
4290:  MOVLB  A
4292:  BCF    x87.7
....................     
....................    i2c_start(); 
4294:  BSF    F94.4
4296:  MOVLW  0A
4298:  MOVWF  00
429A:  DECFSZ 00,F
429C:  BRA    429A
429E:  BSF    F94.3
42A0:  MOVLW  0B
42A2:  MOVWF  00
42A4:  DECFSZ 00,F
42A6:  BRA    42A4
42A8:  BCF    F8B.4
42AA:  BCF    F94.4
42AC:  MOVLW  0A
42AE:  MOVWF  00
42B0:  DECFSZ 00,F
42B2:  BRA    42B0
42B4:  BCF    F8B.3
42B6:  BCF    F94.3
42B8:  CLRF   19
42BA:  BTFSC  FF2.7
42BC:  BSF    19.7
42BE:  BCF    FF2.7
....................    i2c_write(0xD0); 
42C0:  MOVLW  D0
42C2:  MOVLB  B
42C4:  MOVWF  x09
42C6:  MOVLB  0
42C8:  CALL   2F52
42CC:  BTFSC  19.7
42CE:  BSF    FF2.7
42D0:  CLRF   19
42D2:  BTFSC  FF2.7
42D4:  BSF    19.7
42D6:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
42D8:  MOVLB  B
42DA:  CLRF   x09
42DC:  MOVLB  0
42DE:  CALL   2F52
42E2:  BTFSC  19.7
42E4:  BSF    FF2.7
42E6:  CLRF   19
42E8:  BTFSC  FF2.7
42EA:  BSF    19.7
42EC:  BCF    FF2.7
....................    i2c_write(data); 
42EE:  MOVFF  A87,B09
42F2:  CALL   2F52
42F6:  BTFSC  19.7
42F8:  BSF    FF2.7
....................    i2c_start(); 
42FA:  BSF    F94.4
42FC:  MOVLW  0A
42FE:  MOVWF  00
4300:  DECFSZ 00,F
4302:  BRA    4300
4304:  BSF    F94.3
4306:  MOVLW  0B
4308:  MOVWF  00
430A:  DECFSZ 00,F
430C:  BRA    430A
430E:  BTFSS  F82.3
4310:  BRA    430E
4312:  BCF    F8B.4
4314:  BCF    F94.4
4316:  MOVLW  0A
4318:  MOVWF  00
431A:  DECFSZ 00,F
431C:  BRA    431A
431E:  BCF    F8B.3
4320:  BCF    F94.3
4322:  CLRF   19
4324:  BTFSC  FF2.7
4326:  BSF    19.7
4328:  BCF    FF2.7
....................    i2c_write(0xD0); 
432A:  MOVLW  D0
432C:  MOVLB  B
432E:  MOVWF  x09
4330:  MOVLB  0
4332:  CALL   2F52
4336:  BTFSC  19.7
4338:  BSF    FF2.7
433A:  CLRF   19
433C:  BTFSC  FF2.7
433E:  BSF    19.7
4340:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
4342:  MOVLW  07
4344:  MOVLB  B
4346:  MOVWF  x09
4348:  MOVLB  0
434A:  CALL   2F52
434E:  BTFSC  19.7
4350:  BSF    FF2.7
4352:  CLRF   19
4354:  BTFSC  FF2.7
4356:  BSF    19.7
4358:  BCF    FF2.7
....................    i2c_write(0x80); 
435A:  MOVLW  80
435C:  MOVLB  B
435E:  MOVWF  x09
4360:  MOVLB  0
4362:  CALL   2F52
4366:  BTFSC  19.7
4368:  BSF    FF2.7
....................    i2c_stop(); 
436A:  BCF    F94.4
436C:  NOP   
436E:  BSF    F94.3
4370:  BTFSS  F82.3
4372:  BRA    4370
4374:  MOVLW  0A
4376:  MOVWF  00
4378:  DECFSZ 00,F
437A:  BRA    4378
437C:  BRA    437E
437E:  NOP   
4380:  BSF    F94.4
4382:  MOVLW  0A
4384:  MOVWF  00
4386:  DECFSZ 00,F
4388:  BRA    4386
.................... } 
438A:  GOTO   66A8 (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
4D28:  CLRF   19
4D2A:  BTFSC  FF2.7
4D2C:  BSF    19.7
4D2E:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
4D30:  MOVFF  AC3,AF3
4D34:  MOVLW  0A
4D36:  MOVLB  A
4D38:  MOVWF  xF4
4D3A:  MOVLB  0
4D3C:  CALL   1A18
4D40:  BTFSC  19.7
4D42:  BSF    FF2.7
4D44:  MOVFF  01,AC4
....................    nibl=data-(nibh*10); 
4D48:  MOVLB  A
4D4A:  MOVF   xC4,W
4D4C:  MULLW  0A
4D4E:  MOVF   FF3,W
4D50:  SUBWF  xC3,W
4D52:  MOVWF  xC5
....................  
....................    return((nibh<<4)|nibl); 
4D54:  SWAPF  xC4,W
4D56:  MOVWF  00
4D58:  MOVLW  F0
4D5A:  ANDWF  00,F
4D5C:  MOVF   00,W
4D5E:  IORWF  xC5,W
4D60:  MOVWF  01
.................... } 
4D62:  MOVLB  0
4D64:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
30CA:  MOVFF  AEC,AED
....................    data=(i>>4)*10; 
30CE:  MOVLB  A
30D0:  SWAPF  xED,W
30D2:  MOVWF  00
30D4:  MOVLW  0F
30D6:  ANDWF  00,F
30D8:  MOVF   00,W
30DA:  MULLW  0A
30DC:  MOVFF  FF3,AEC
....................    data=data+(i<<4>>4); 
30E0:  SWAPF  xED,W
30E2:  MOVWF  00
30E4:  MOVLW  F0
30E6:  ANDWF  00,F
30E8:  MOVF   00,W
30EA:  SWAPF  00,F
30EC:  MOVLW  0F
30EE:  ANDWF  00,F
30F0:  MOVF   00,W
30F2:  ADDWF  xEC,F
....................  
....................    return data; 
30F4:  MOVFF  AEC,01
.................... } 
30F8:  MOVLB  0
30FA:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
4D66:  MOVLB  A
4D68:  CLRF   xC4
4D6A:  CLRF   xC5
4D6C:  MOVLB  0
4D6E:  RCALL  4C7A
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
4D70:  MOVFF  AC2,AC3
4D74:  RCALL  4D28
4D76:  MOVFF  01,AC3
4D7A:  MOVLW  01
4D7C:  MOVLB  A
4D7E:  MOVWF  xC4
4D80:  MOVFF  01,AC5
4D84:  MOVLB  0
4D86:  RCALL  4C7A
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
4D88:  MOVFF  AC1,AC3
4D8C:  RCALL  4D28
4D8E:  MOVFF  01,AC3
4D92:  MOVLW  02
4D94:  MOVLB  A
4D96:  MOVWF  xC4
4D98:  MOVFF  01,AC5
4D9C:  MOVLB  0
4D9E:  RCALL  4C7A
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
4DA0:  MOVFF  AC0,AC3
4DA4:  RCALL  4D28
4DA6:  MOVFF  01,AC3
4DAA:  MOVLW  03
4DAC:  MOVLB  A
4DAE:  MOVWF  xC4
4DB0:  MOVFF  01,AC5
4DB4:  MOVLB  0
4DB6:  RCALL  4C7A
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
4DB8:  MOVFF  ABD,AC3
4DBC:  RCALL  4D28
4DBE:  MOVFF  01,AC3
4DC2:  MOVLW  04
4DC4:  MOVLB  A
4DC6:  MOVWF  xC4
4DC8:  MOVFF  01,AC5
4DCC:  MOVLB  0
4DCE:  RCALL  4C7A
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
4DD0:  MOVFF  ABE,AC3
4DD4:  RCALL  4D28
4DD6:  MOVFF  01,AC3
4DDA:  MOVLW  05
4DDC:  MOVLB  A
4DDE:  MOVWF  xC4
4DE0:  MOVFF  01,AC5
4DE4:  MOVLB  0
4DE6:  RCALL  4C7A
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
4DE8:  MOVFF  ABF,AC3
4DEC:  RCALL  4D28
4DEE:  MOVFF  01,AC3
4DF2:  MOVLW  06
4DF4:  MOVLB  A
4DF6:  MOVWF  xC4
4DF8:  MOVFF  01,AC5
4DFC:  MOVLB  0
4DFE:  RCALL  4C7A
....................    write_DS1307(DS1307_CONTROL,0);    
4E00:  MOVLW  07
4E02:  MOVLB  A
4E04:  MOVWF  xC4
4E06:  CLRF   xC5
4E08:  MOVLB  0
4E0A:  RCALL  4C7A
.................... } 
4E0C:  GOTO   5A28 (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
37DE:  MOVLW  04
37E0:  MOVLB  A
37E2:  MOVWF  xEB
37E4:  MOVLB  0
37E6:  RCALL  3032
37E8:  MOVFF  01,AE7
37EC:  MOVFF  01,AEC
37F0:  RCALL  30CA
37F2:  MOVFF  01,100
*
5570:  MOVLW  04
5572:  MOVLB  A
5574:  MOVWF  xEB
5576:  MOVLB  0
5578:  CALL   3032
557C:  MOVFF  01,AE7
5580:  MOVFF  01,AEC
5584:  CALL   30CA
5588:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
*
37F6:  MOVLW  05
37F8:  MOVLB  A
37FA:  MOVWF  xEB
37FC:  MOVLB  0
37FE:  RCALL  3032
3800:  MOVFF  01,AE7
3804:  MOVFF  01,AEC
3808:  RCALL  30CA
380A:  MOVFF  01,FF
*
558C:  MOVLW  05
558E:  MOVLB  A
5590:  MOVWF  xEB
5592:  MOVLB  0
5594:  CALL   3032
5598:  MOVFF  01,AE7
559C:  MOVFF  01,AEC
55A0:  CALL   30CA
55A4:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
*
380E:  MOVLW  06
3810:  MOVLB  A
3812:  MOVWF  xEB
3814:  MOVLB  0
3816:  RCALL  3032
3818:  MOVFF  01,AE7
381C:  MOVFF  01,AEC
3820:  RCALL  30CA
3822:  MOVFF  01,FE
*
55A8:  MOVLW  06
55AA:  MOVLB  A
55AC:  MOVWF  xEB
55AE:  MOVLB  0
55B0:  CALL   3032
55B4:  MOVFF  01,AE7
55B8:  MOVFF  01,AEC
55BC:  CALL   30CA
55C0:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
*
3826:  MOVLW  03
3828:  MOVLB  A
382A:  MOVWF  xEB
382C:  MOVLB  0
382E:  RCALL  3032
3830:  MOVFF  01,AE7
3834:  MOVFF  01,AEC
3838:  RCALL  30CA
383A:  MOVFF  01,FD
*
55C4:  MOVLW  03
55C6:  MOVLB  A
55C8:  MOVWF  xEB
55CA:  MOVLB  0
55CC:  CALL   3032
55D0:  MOVFF  01,AE7
55D4:  MOVFF  01,AEC
55D8:  CALL   30CA
55DC:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
*
383E:  MOVLW  02
3840:  MOVLB  A
3842:  MOVWF  xEB
3844:  MOVLB  0
3846:  CALL   3032
384A:  MOVFF  01,AE7
384E:  MOVFF  01,AEC
3852:  RCALL  30CA
3854:  MOVFF  01,101
*
55E0:  MOVLW  02
55E2:  MOVLB  A
55E4:  MOVWF  xEB
55E6:  MOVLB  0
55E8:  CALL   3032
55EC:  MOVFF  01,AE7
55F0:  MOVFF  01,AEC
55F4:  CALL   30CA
55F8:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
*
3858:  MOVLW  01
385A:  MOVLB  A
385C:  MOVWF  xEB
385E:  MOVLB  0
3860:  CALL   3032
3864:  MOVFF  01,AE7
3868:  MOVFF  01,AEC
386C:  RCALL  30CA
386E:  MOVFF  01,102
*
55FC:  MOVLW  01
55FE:  MOVLB  A
5600:  MOVWF  xEB
5602:  MOVLB  0
5604:  CALL   3032
5608:  MOVFF  01,AE7
560C:  MOVFF  01,AEC
5610:  CALL   30CA
5614:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
*
3872:  MOVLB  A
3874:  CLRF   xEB
3876:  MOVLB  0
3878:  CALL   3032
387C:  MOVFF  01,AE7
3880:  MOVFF  01,AEC
3884:  RCALL  30CA
3886:  MOVFF  01,103
*
5618:  MOVLB  A
561A:  CLRF   xEB
561C:  MOVLB  0
561E:  CALL   3032
5622:  MOVFF  01,AE7
5626:  MOVFF  01,AEC
562A:  CALL   30CA
562E:  MOVFF  01,103
5632:  CLRF   19
5634:  BTFSC  FF2.7
5636:  BSF    19.7
5638:  BCF    FF2.7
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... #include <scan_key.c> 
....................  
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... #define key_numbyte  50 
....................  
.................... int8 key_data[key_numbyte]; 
....................  
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
23A6:  MOVLB  1
23A8:  INCF   x43,F
23AA:  MOVF   x43,W
23AC:  SUBLW  01
23AE:  BTFSC  FD8.0
23B0:  BRA    2556
....................        switch (col) { 
23B2:  MOVF   x46,W
23B4:  ADDLW  FB
23B6:  BC    243A
23B8:  ADDLW  05
23BA:  MOVLB  0
23BC:  GOTO   2560
....................          case 0   :  
....................                     output_low(COL0); 
23C0:  BCF    F92.5
23C2:  BCF    F89.5
....................                     output_high(COL1); 
23C4:  BCF    F92.3
23C6:  BSF    F89.3
....................                     output_high(COL2); 
23C8:  BCF    F92.2
23CA:  BSF    F89.2
....................                     output_high(COL3); 
23CC:  BCF    F92.1
23CE:  BSF    F89.1
....................                     output_high(COL4); 
23D0:  BCF    F92.0
23D2:  BSF    F89.0
....................                     break; 
23D4:  MOVLB  1
23D6:  BRA    243A
....................          case 1   :  
....................                     output_low(COL1); 
23D8:  BCF    F92.3
23DA:  BCF    F89.3
....................                     output_high(COL0); 
23DC:  BCF    F92.5
23DE:  BSF    F89.5
....................                     output_high(COL2); 
23E0:  BCF    F92.2
23E2:  BSF    F89.2
....................                     output_high(COL3); 
23E4:  BCF    F92.1
23E6:  BSF    F89.1
....................                     output_high(COL4); 
23E8:  BCF    F92.0
23EA:  BSF    F89.0
....................                     break; 
23EC:  MOVLB  1
23EE:  BRA    243A
....................          case 2   :  
....................                     output_low(COL2); 
23F0:  BCF    F92.2
23F2:  BCF    F89.2
....................                     output_high(COL1); 
23F4:  BCF    F92.3
23F6:  BSF    F89.3
....................                     output_high(COL0); 
23F8:  BCF    F92.5
23FA:  BSF    F89.5
....................                     output_high(COL3); 
23FC:  BCF    F92.1
23FE:  BSF    F89.1
....................                     output_high(COL4); 
2400:  BCF    F92.0
2402:  BSF    F89.0
....................                     break; 
2404:  MOVLB  1
2406:  BRA    243A
....................          case 3   :  
....................                     output_low(COL3); 
2408:  BCF    F92.1
240A:  BCF    F89.1
....................                     output_high(COL1); 
240C:  BCF    F92.3
240E:  BSF    F89.3
....................                     output_high(COL2); 
2410:  BCF    F92.2
2412:  BSF    F89.2
....................                     output_high(COL0); 
2414:  BCF    F92.5
2416:  BSF    F89.5
....................                     output_high(COL4); 
2418:  BCF    F92.0
241A:  BSF    F89.0
....................                     break; 
241C:  MOVLB  1
241E:  BRA    243A
....................          case 4   :  
....................                     output_low(COL4); 
2420:  BCF    F92.0
2422:  BCF    F89.0
....................                     output_high(COL1); 
2424:  BCF    F92.3
2426:  BSF    F89.3
....................                     output_high(COL2); 
2428:  BCF    F92.2
242A:  BSF    F89.2
....................                     output_high(COL3); 
242C:  BCF    F92.1
242E:  BSF    F89.1
....................                     output_high(COL0); 
2430:  BCF    F92.5
2432:  BSF    F89.5
....................                     break; 
2434:  MOVLB  1
2436:  BRA    243A
2438:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
243A:  BTFSS  x44.0
243C:  BRA    24BC
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
243E:  BSF    F93.4
2440:  MOVLW  00
2442:  BTFSC  F81.4
2444:  MOVLW  01
2446:  MOVLB  A
2448:  MOVWF  xE6
244A:  BSF    F93.5
244C:  MOVLW  00
244E:  BTFSC  F81.5
2450:  MOVLW  01
2452:  ANDWF  xE6,F
2454:  BSF    F93.6
2456:  MOVLW  00
2458:  BTFSC  F81.6
245A:  MOVLW  01
245C:  ANDWF  xE6,F
245E:  BSF    F93.7
2460:  MOVLW  00
2462:  BTFSC  F81.7
2464:  MOVLW  01
2466:  ANDWF  xE6,W
2468:  BZ    24B8
....................          { 
....................             kchar=last_key; 
246A:  MOVFF  145,AE4
....................             if(keydebug_en==0) 
246E:  MOVLB  1
2470:  MOVF   x08,F
2472:  BNZ   24A6
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
2474:  CLRF   x06
2476:  CLRF   x05
....................               charac_timeout=0; 
2478:  MOVLB  0
247A:  CLRF   xFC
247C:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
247E:  MOVLB  1
2480:  MOVF   x0B,W
2482:  SUBLW  31
2484:  BNC   249A
2486:  MOVF   x0B,W
2488:  INCF   x0B,F
248A:  CLRF   03
248C:  ADDLW  10
248E:  MOVWF  FE9
2490:  MOVLW  01
2492:  ADDWFC 03,W
2494:  MOVWF  FEA
2496:  MOVFF  AE4,FEF
....................                fputc(kchar,COM2); 
249A:  MOVFF  AE4,B16
249E:  MOVLB  0
24A0:  CALL   0548
....................             } 
....................                else fputc(kchar,COM2); 
24A4:  BRA    24B0
24A6:  MOVFF  AE4,B16
24AA:  MOVLB  0
24AC:  CALL   0548
....................            kbd_down=FALSE; 
24B0:  MOVLB  1
24B2:  BCF    x44.0
....................            last_key=0; 
24B4:  CLRF   x45
24B6:  MOVLB  A
....................          } 
....................        } else 
24B8:  BRA    2552
24BA:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
24BC:  BSF    F93.4
24BE:  MOVLW  00
24C0:  BTFSC  F81.4
24C2:  MOVLW  01
24C4:  MOVLB  A
24C6:  MOVWF  xE6
24C8:  BSF    F93.5
24CA:  MOVLW  00
24CC:  BTFSC  F81.5
24CE:  MOVLW  01
24D0:  ANDWF  xE6,F
24D2:  BSF    F93.6
24D4:  MOVLW  00
24D6:  BTFSC  F81.6
24D8:  MOVLW  01
24DA:  ANDWF  xE6,F
24DC:  BSF    F93.7
24DE:  MOVLW  00
24E0:  BTFSC  F81.7
24E2:  MOVLW  01
24E4:  ANDWF  xE6,W
24E6:  BNZ   2546
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
24E8:  BSF    F93.4
24EA:  BTFSC  F81.4
24EC:  BRA    24F2
....................                   row=0; 
24EE:  CLRF   xE5
....................                 else if(input(ROW1)==0) 
24F0:  BRA    2514
24F2:  BSF    F93.5
24F4:  BTFSC  F81.5
24F6:  BRA    24FE
....................                   row=1; 
24F8:  MOVLW  01
24FA:  MOVWF  xE5
....................                 else if(input(ROW2)==0) 
24FC:  BRA    2514
24FE:  BSF    F93.6
2500:  BTFSC  F81.6
2502:  BRA    250A
....................                   row=2; 
2504:  MOVLW  02
2506:  MOVWF  xE5
....................                 else if(input(ROW3)==0) 
2508:  BRA    2514
250A:  BSF    F93.7
250C:  BTFSC  F81.7
250E:  BRA    2514
....................                   row=3; 
2510:  MOVLW  03
2512:  MOVWF  xE5
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
2514:  MOVF   xE5,W
2516:  MULLW  05
2518:  MOVF   FF3,W
251A:  CLRF   xE7
251C:  MOVWF  xE6
251E:  CLRF   03
2520:  MOVLB  1
2522:  MOVF   x46,W
2524:  MOVLB  A
2526:  ADDWF  xE6,W
2528:  MOVWF  01
252A:  MOVF   xE7,W
252C:  ADDWFC 03,F
252E:  MOVF   01,W
2530:  MOVLB  0
2532:  CALL   00E8
2536:  MOVFF  FE8,145
....................                 kbd_down = TRUE; 
253A:  MOVLB  1
253C:  BSF    x44.0
....................                 set_tris_a(0xff); 
253E:  MOVLW  FF
2540:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2542:  BRA    2552
2544:  MOVLB  A
....................                { 
....................                   ++col; 
2546:  MOVLB  1
2548:  INCF   x46,F
....................                   if(col==5) col=0; 
254A:  MOVF   x46,W
254C:  SUBLW  05
254E:  BTFSC  FD8.2
2550:  CLRF   x46
....................                } 
....................          } 
....................       kbd_call_count=0; 
2552:  MOVLB  1
2554:  CLRF   x43
....................    } 
....................   return(kchar); 
2556:  MOVLB  A
2558:  MOVFF  AE4,01
.................... } 
255C:  MOVLB  0
255E:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
*
2584:  MOVLW  E0
2586:  MOVLB  F
2588:  MOVWF  x48
258A:  BCF    FC2.6
258C:  BCF    FC2.7
258E:  MOVF   x49,W
2590:  ANDLW  E0
2592:  IORLW  1F
2594:  MOVWF  x49
....................    switch(col) 
....................    { 
2596:  MOVLB  B
2598:  MOVF   x0A,W
259A:  ADDLW  FB
259C:  BC    2648
259E:  ADDLW  05
25A0:  MOVLB  0
25A2:  GOTO   264C
....................       case 0: 
....................         set_adc_channel(4); 
25A6:  MOVLW  10
25A8:  MOVWF  01
25AA:  MOVF   FC2,W
25AC:  ANDLW  C3
25AE:  IORWF  01,W
25B0:  MOVWF  FC2
....................         adc=read_adc(); 
25B2:  BSF    FC2.1
25B4:  BTFSC  FC2.1
25B6:  BRA    25B4
25B8:  MOVFF  FC4,B0B
....................         return adc; 
25BC:  MOVLB  B
25BE:  MOVFF  B0B,01
25C2:  BRA    2648
....................       break; 
25C4:  BRA    2648
....................       case 1: 
....................         set_adc_channel(3); 
25C6:  MOVLW  0C
25C8:  MOVWF  01
25CA:  MOVF   FC2,W
25CC:  ANDLW  C3
25CE:  IORWF  01,W
25D0:  MOVWF  FC2
....................         adc=read_adc(); 
25D2:  BSF    FC2.1
25D4:  BTFSC  FC2.1
25D6:  BRA    25D4
25D8:  MOVFF  FC4,B0B
....................         return adc; 
25DC:  MOVLB  B
25DE:  MOVFF  B0B,01
25E2:  BRA    2648
....................       break; 
25E4:  BRA    2648
....................       case 2: 
....................         set_adc_channel(2); 
25E6:  MOVLW  08
25E8:  MOVWF  01
25EA:  MOVF   FC2,W
25EC:  ANDLW  C3
25EE:  IORWF  01,W
25F0:  MOVWF  FC2
....................         adc=read_adc(); 
25F2:  BSF    FC2.1
25F4:  BTFSC  FC2.1
25F6:  BRA    25F4
25F8:  MOVFF  FC4,B0B
....................         return adc; 
25FC:  MOVLB  B
25FE:  MOVFF  B0B,01
2602:  BRA    2648
....................       break; 
2604:  BRA    2648
....................       case 3: 
....................         set_adc_channel(1); 
2606:  MOVLW  04
2608:  MOVWF  01
260A:  MOVF   FC2,W
260C:  ANDLW  C3
260E:  IORWF  01,W
2610:  MOVWF  FC2
....................         adc=read_adc(); 
2612:  BSF    FC2.1
2614:  BTFSC  FC2.1
2616:  BRA    2614
2618:  MOVFF  FC4,B0B
....................         return adc; 
261C:  MOVLB  B
261E:  MOVFF  B0B,01
2622:  BRA    2648
....................       break; 
2624:  BRA    2648
....................       case 4: 
....................         set_adc_channel(0); 
2626:  MOVLW  00
2628:  MOVWF  01
262A:  MOVF   FC2,W
262C:  ANDLW  C3
262E:  IORWF  01,W
2630:  MOVWF  FC2
....................         adc=read_adc(); 
2632:  BSF    FC2.1
2634:  BTFSC  FC2.1
2636:  BRA    2634
2638:  MOVFF  FC4,B0B
....................         return adc; 
263C:  MOVLB  B
263E:  MOVFF  B0B,01
2642:  BRA    2648
....................       break;      
2644:  BRA    2648
2646:  MOVLB  B
....................    } 
.................... } 
2648:  MOVLB  0
264A:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
27C4:  MOVLB  A
27C6:  CLRF   xEC
27C8:  CLRF   xEB
27CA:  CLRF   xEA
27CC:  CLRF   xE9
27CE:  CLRF   xF0
27D0:  CLRF   xEF
27D2:  CLRF   xEE
27D4:  CLRF   xED
27D6:  CLRF   xF4
27D8:  CLRF   xF3
27DA:  CLRF   xF2
27DC:  CLRF   xF1
27DE:  CLRF   xF8
27E0:  CLRF   xF7
27E2:  CLRF   xF6
27E4:  CLRF   xF5
27E6:  CLRF   xFC
27E8:  CLRF   xFB
27EA:  CLRF   xFA
27EC:  CLRF   xF9
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
27EE:  CLRF   xE8
27F0:  CLRF   xE7
27F2:  MOVF   xE8,W
27F4:  SUBLW  01
27F6:  BNC   287E
27F8:  BNZ   2800
27FA:  MOVF   xE7,W
27FC:  SUBLW  F3
27FE:  BNC   287E
....................    { 
....................       col_0=read_col(0)+col_0; 
2800:  MOVLB  B
2802:  CLRF   x0A
2804:  MOVLB  0
2806:  RCALL  2584
2808:  MOVF   01,W
280A:  MOVLB  A
280C:  ADDWF  xE9,F
280E:  MOVLW  00
2810:  ADDWFC xEA,F
2812:  ADDWFC xEB,F
2814:  ADDWFC xEC,F
....................       col_1=read_col(1)+col_1; 
2816:  MOVLW  01
2818:  MOVLB  B
281A:  MOVWF  x0A
281C:  MOVLB  0
281E:  RCALL  2584
2820:  MOVF   01,W
2822:  MOVLB  A
2824:  ADDWF  xED,F
2826:  MOVLW  00
2828:  ADDWFC xEE,F
282A:  ADDWFC xEF,F
282C:  ADDWFC xF0,F
....................       col_2=read_col(2)+col_2; 
282E:  MOVLW  02
2830:  MOVLB  B
2832:  MOVWF  x0A
2834:  MOVLB  0
2836:  RCALL  2584
2838:  MOVF   01,W
283A:  MOVLB  A
283C:  ADDWF  xF1,F
283E:  MOVLW  00
2840:  ADDWFC xF2,F
2842:  ADDWFC xF3,F
2844:  ADDWFC xF4,F
....................       col_3=read_col(3)+col_3; 
2846:  MOVLW  03
2848:  MOVLB  B
284A:  MOVWF  x0A
284C:  MOVLB  0
284E:  RCALL  2584
2850:  MOVF   01,W
2852:  MOVLB  A
2854:  ADDWF  xF5,F
2856:  MOVLW  00
2858:  ADDWFC xF6,F
285A:  ADDWFC xF7,F
285C:  ADDWFC xF8,F
....................       col_4=read_col(4)+col_4; 
285E:  MOVLW  04
2860:  MOVLB  B
2862:  MOVWF  x0A
2864:  MOVLB  0
2866:  RCALL  2584
2868:  MOVF   01,W
286A:  MOVLB  A
286C:  ADDWF  xF9,F
286E:  MOVLW  00
2870:  ADDWFC xFA,F
2872:  ADDWFC xFB,F
2874:  ADDWFC xFC,F
....................    } 
2876:  INCF   xE7,F
2878:  BTFSC  FD8.2
287A:  INCF   xE8,F
287C:  BRA    27F2
....................    col_0=col_0/500; 
287E:  BCF    FD8.1
2880:  MOVFF  AEC,B19
2884:  MOVFF  AEB,B18
2888:  MOVFF  AEA,B17
288C:  MOVFF  AE9,B16
2890:  MOVLB  B
2892:  CLRF   x1D
2894:  CLRF   x1C
2896:  MOVLW  01
2898:  MOVWF  x1B
289A:  MOVLW  F4
289C:  MOVWF  x1A
289E:  MOVLB  0
28A0:  RCALL  2670
28A2:  MOVFF  03,AEC
28A6:  MOVFF  02,AEB
28AA:  MOVFF  01,AEA
28AE:  MOVFF  00,AE9
....................    col_1=col_1/500; 
28B2:  BCF    FD8.1
28B4:  MOVFF  AF0,B19
28B8:  MOVFF  AEF,B18
28BC:  MOVFF  AEE,B17
28C0:  MOVFF  AED,B16
28C4:  MOVLB  B
28C6:  CLRF   x1D
28C8:  CLRF   x1C
28CA:  MOVLW  01
28CC:  MOVWF  x1B
28CE:  MOVLW  F4
28D0:  MOVWF  x1A
28D2:  MOVLB  0
28D4:  RCALL  2670
28D6:  MOVFF  03,AF0
28DA:  MOVFF  02,AEF
28DE:  MOVFF  01,AEE
28E2:  MOVFF  00,AED
....................    col_2=col_2/500; 
28E6:  BCF    FD8.1
28E8:  MOVFF  AF4,B19
28EC:  MOVFF  AF3,B18
28F0:  MOVFF  AF2,B17
28F4:  MOVFF  AF1,B16
28F8:  MOVLB  B
28FA:  CLRF   x1D
28FC:  CLRF   x1C
28FE:  MOVLW  01
2900:  MOVWF  x1B
2902:  MOVLW  F4
2904:  MOVWF  x1A
2906:  MOVLB  0
2908:  RCALL  2670
290A:  MOVFF  03,AF4
290E:  MOVFF  02,AF3
2912:  MOVFF  01,AF2
2916:  MOVFF  00,AF1
....................    col_3=col_3/500; 
291A:  BCF    FD8.1
291C:  MOVFF  AF8,B19
2920:  MOVFF  AF7,B18
2924:  MOVFF  AF6,B17
2928:  MOVFF  AF5,B16
292C:  MOVLB  B
292E:  CLRF   x1D
2930:  CLRF   x1C
2932:  MOVLW  01
2934:  MOVWF  x1B
2936:  MOVLW  F4
2938:  MOVWF  x1A
293A:  MOVLB  0
293C:  RCALL  2670
293E:  MOVFF  03,AF8
2942:  MOVFF  02,AF7
2946:  MOVFF  01,AF6
294A:  MOVFF  00,AF5
....................    col_4=col_4/500; 
294E:  BCF    FD8.1
2950:  MOVFF  AFC,B19
2954:  MOVFF  AFB,B18
2958:  MOVFF  AFA,B17
295C:  MOVFF  AF9,B16
2960:  MOVLB  B
2962:  CLRF   x1D
2964:  CLRF   x1C
2966:  MOVLW  01
2968:  MOVWF  x1B
296A:  MOVLW  F4
296C:  MOVWF  x1A
296E:  MOVLB  0
2970:  RCALL  2670
2972:  MOVFF  03,AFC
2976:  MOVFF  02,AFB
297A:  MOVFF  01,AFA
297E:  MOVFF  00,AF9
....................    if(keydebug_en) 
2982:  MOVLB  1
2984:  MOVF   x08,F
2986:  BTFSC  FD8.2
2988:  BRA    2B04
....................    { 
....................       fprintf(COM2,"\r\n");      
298A:  MOVLW  0D
298C:  MOVLB  B
298E:  MOVWF  x16
2990:  MOVLB  0
2992:  CALL   0548
2996:  MOVLW  0A
2998:  MOVLB  B
299A:  MOVWF  x16
299C:  MOVLB  0
299E:  CALL   0548
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
29A2:  MOVLW  88
29A4:  MOVWF  FF6
29A6:  MOVLW  02
29A8:  MOVWF  FF7
29AA:  MOVLW  07
29AC:  MOVLB  B
29AE:  MOVWF  x0A
29B0:  MOVLB  0
29B2:  CALL   1930
29B6:  MOVLW  41
29B8:  MOVWF  FE9
29BA:  MOVFF  AEC,B0D
29BE:  MOVFF  AEB,B0C
29C2:  MOVFF  AEA,B0B
29C6:  MOVFF  AE9,B0A
29CA:  RCALL  2704
29CC:  MOVLW  0D
29CE:  MOVLB  B
29D0:  MOVWF  x16
29D2:  MOVLB  0
29D4:  CALL   0548
29D8:  MOVLW  0A
29DA:  MOVLB  B
29DC:  MOVWF  x16
29DE:  MOVLB  0
29E0:  CALL   0548
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
29E4:  MOVLW  96
29E6:  MOVWF  FF6
29E8:  MOVLW  02
29EA:  MOVWF  FF7
29EC:  MOVLW  07
29EE:  MOVLB  B
29F0:  MOVWF  x0A
29F2:  MOVLB  0
29F4:  CALL   1930
29F8:  MOVLW  41
29FA:  MOVWF  FE9
29FC:  MOVFF  AF0,B0D
2A00:  MOVFF  AEF,B0C
2A04:  MOVFF  AEE,B0B
2A08:  MOVFF  AED,B0A
2A0C:  RCALL  2704
2A0E:  MOVLW  0D
2A10:  MOVLB  B
2A12:  MOVWF  x16
2A14:  MOVLB  0
2A16:  CALL   0548
2A1A:  MOVLW  0A
2A1C:  MOVLB  B
2A1E:  MOVWF  x16
2A20:  MOVLB  0
2A22:  CALL   0548
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2A26:  MOVLW  A4
2A28:  MOVWF  FF6
2A2A:  MOVLW  02
2A2C:  MOVWF  FF7
2A2E:  MOVLW  07
2A30:  MOVLB  B
2A32:  MOVWF  x0A
2A34:  MOVLB  0
2A36:  CALL   1930
2A3A:  MOVLW  41
2A3C:  MOVWF  FE9
2A3E:  MOVFF  AF4,B0D
2A42:  MOVFF  AF3,B0C
2A46:  MOVFF  AF2,B0B
2A4A:  MOVFF  AF1,B0A
2A4E:  RCALL  2704
2A50:  MOVLW  0D
2A52:  MOVLB  B
2A54:  MOVWF  x16
2A56:  MOVLB  0
2A58:  CALL   0548
2A5C:  MOVLW  0A
2A5E:  MOVLB  B
2A60:  MOVWF  x16
2A62:  MOVLB  0
2A64:  CALL   0548
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2A68:  MOVLW  B2
2A6A:  MOVWF  FF6
2A6C:  MOVLW  02
2A6E:  MOVWF  FF7
2A70:  MOVLW  07
2A72:  MOVLB  B
2A74:  MOVWF  x0A
2A76:  MOVLB  0
2A78:  CALL   1930
2A7C:  MOVLW  41
2A7E:  MOVWF  FE9
2A80:  MOVFF  AF8,B0D
2A84:  MOVFF  AF7,B0C
2A88:  MOVFF  AF6,B0B
2A8C:  MOVFF  AF5,B0A
2A90:  RCALL  2704
2A92:  MOVLW  0D
2A94:  MOVLB  B
2A96:  MOVWF  x16
2A98:  MOVLB  0
2A9A:  CALL   0548
2A9E:  MOVLW  0A
2AA0:  MOVLB  B
2AA2:  MOVWF  x16
2AA4:  MOVLB  0
2AA6:  CALL   0548
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2AAA:  MOVLW  C0
2AAC:  MOVWF  FF6
2AAE:  MOVLW  02
2AB0:  MOVWF  FF7
2AB2:  MOVLW  07
2AB4:  MOVLB  B
2AB6:  MOVWF  x0A
2AB8:  MOVLB  0
2ABA:  CALL   1930
2ABE:  MOVLW  41
2AC0:  MOVWF  FE9
2AC2:  MOVFF  AFC,B0D
2AC6:  MOVFF  AFB,B0C
2ACA:  MOVFF  AFA,B0B
2ACE:  MOVFF  AF9,B0A
2AD2:  RCALL  2704
2AD4:  MOVLW  0D
2AD6:  MOVLB  B
2AD8:  MOVWF  x16
2ADA:  MOVLB  0
2ADC:  CALL   0548
2AE0:  MOVLW  0A
2AE2:  MOVLB  B
2AE4:  MOVWF  x16
2AE6:  MOVLB  0
2AE8:  CALL   0548
....................       fprintf(COM2,"\r\n"); 
2AEC:  MOVLW  0D
2AEE:  MOVLB  B
2AF0:  MOVWF  x16
2AF2:  MOVLB  0
2AF4:  CALL   0548
2AF8:  MOVLW  0A
2AFA:  MOVLB  B
2AFC:  MOVWF  x16
2AFE:  MOVLB  0
2B00:  CALL   0548
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
2B04:  MOVLB  A
2B06:  MOVF   xEC,F
2B08:  BNZ   2B18
2B0A:  MOVF   xEB,F
2B0C:  BNZ   2B18
2B0E:  MOVF   xEA,F
2B10:  BNZ   2B18
2B12:  MOVF   xE9,W
2B14:  SUBLW  05
2B16:  BC    2B78
2B18:  MOVF   xEC,F
2B1A:  BNZ   2B78
2B1C:  MOVF   xEB,F
2B1E:  BNZ   2B78
2B20:  MOVF   xEA,F
2B22:  BNZ   2B78
2B24:  MOVF   xE9,W
2B26:  SUBLW  3B
2B28:  BNC   2B78
2B2A:  MOVF   xF0,F
2B2C:  BNZ   2B3C
2B2E:  MOVF   xEF,F
2B30:  BNZ   2B3C
2B32:  MOVF   xEE,F
2B34:  BNZ   2B3C
2B36:  MOVF   xED,W
2B38:  SUBLW  64
2B3A:  BC    2B78
2B3C:  MOVF   xF4,F
2B3E:  BNZ   2B4E
2B40:  MOVF   xF3,F
2B42:  BNZ   2B4E
2B44:  MOVF   xF2,F
2B46:  BNZ   2B4E
2B48:  MOVF   xF1,W
2B4A:  SUBLW  64
2B4C:  BC    2B78
2B4E:  MOVF   xF8,F
2B50:  BNZ   2B60
2B52:  MOVF   xF7,F
2B54:  BNZ   2B60
2B56:  MOVF   xF6,F
2B58:  BNZ   2B60
2B5A:  MOVF   xF5,W
2B5C:  SUBLW  64
2B5E:  BC    2B78
2B60:  MOVF   xFC,F
2B62:  BNZ   2B72
2B64:  MOVF   xFB,F
2B66:  BNZ   2B72
2B68:  MOVF   xFA,F
2B6A:  BNZ   2B72
2B6C:  MOVF   xF9,W
2B6E:  SUBLW  64
2B70:  BC    2B78
2B72:  MOVLW  00
2B74:  MOVWF  01
2B76:  BRA    2DF6
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
2B78:  MOVF   xF0,F
2B7A:  BNZ   2B8A
2B7C:  MOVF   xEF,F
2B7E:  BNZ   2B8A
2B80:  MOVF   xEE,F
2B82:  BNZ   2B8A
2B84:  MOVF   xED,W
2B86:  SUBLW  05
2B88:  BC    2BEA
2B8A:  MOVF   xF0,F
2B8C:  BNZ   2BEA
2B8E:  MOVF   xEF,F
2B90:  BNZ   2BEA
2B92:  MOVF   xEE,F
2B94:  BNZ   2BEA
2B96:  MOVF   xED,W
2B98:  SUBLW  3B
2B9A:  BNC   2BEA
2B9C:  MOVF   xEC,F
2B9E:  BNZ   2BAE
2BA0:  MOVF   xEB,F
2BA2:  BNZ   2BAE
2BA4:  MOVF   xEA,F
2BA6:  BNZ   2BAE
2BA8:  MOVF   xE9,W
2BAA:  SUBLW  64
2BAC:  BC    2BEA
2BAE:  MOVF   xF4,F
2BB0:  BNZ   2BC0
2BB2:  MOVF   xF3,F
2BB4:  BNZ   2BC0
2BB6:  MOVF   xF2,F
2BB8:  BNZ   2BC0
2BBA:  MOVF   xF1,W
2BBC:  SUBLW  64
2BBE:  BC    2BEA
2BC0:  MOVF   xF8,F
2BC2:  BNZ   2BD2
2BC4:  MOVF   xF7,F
2BC6:  BNZ   2BD2
2BC8:  MOVF   xF6,F
2BCA:  BNZ   2BD2
2BCC:  MOVF   xF5,W
2BCE:  SUBLW  64
2BD0:  BC    2BEA
2BD2:  MOVF   xFC,F
2BD4:  BNZ   2BE4
2BD6:  MOVF   xFB,F
2BD8:  BNZ   2BE4
2BDA:  MOVF   xFA,F
2BDC:  BNZ   2BE4
2BDE:  MOVF   xF9,W
2BE0:  SUBLW  64
2BE2:  BC    2BEA
2BE4:  MOVLW  01
2BE6:  MOVWF  01
2BE8:  BRA    2DF6
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
2BEA:  MOVF   xF4,F
2BEC:  BNZ   2BFC
2BEE:  MOVF   xF3,F
2BF0:  BNZ   2BFC
2BF2:  MOVF   xF2,F
2BF4:  BNZ   2BFC
2BF6:  MOVF   xF1,W
2BF8:  SUBLW  05
2BFA:  BC    2C5C
2BFC:  MOVF   xF4,F
2BFE:  BNZ   2C5C
2C00:  MOVF   xF3,F
2C02:  BNZ   2C5C
2C04:  MOVF   xF2,F
2C06:  BNZ   2C5C
2C08:  MOVF   xF1,W
2C0A:  SUBLW  3B
2C0C:  BNC   2C5C
2C0E:  MOVF   xF0,F
2C10:  BNZ   2C20
2C12:  MOVF   xEF,F
2C14:  BNZ   2C20
2C16:  MOVF   xEE,F
2C18:  BNZ   2C20
2C1A:  MOVF   xED,W
2C1C:  SUBLW  64
2C1E:  BC    2C5C
2C20:  MOVF   xEC,F
2C22:  BNZ   2C32
2C24:  MOVF   xEB,F
2C26:  BNZ   2C32
2C28:  MOVF   xEA,F
2C2A:  BNZ   2C32
2C2C:  MOVF   xE9,W
2C2E:  SUBLW  64
2C30:  BC    2C5C
2C32:  MOVF   xF8,F
2C34:  BNZ   2C44
2C36:  MOVF   xF7,F
2C38:  BNZ   2C44
2C3A:  MOVF   xF6,F
2C3C:  BNZ   2C44
2C3E:  MOVF   xF5,W
2C40:  SUBLW  64
2C42:  BC    2C5C
2C44:  MOVF   xFC,F
2C46:  BNZ   2C56
2C48:  MOVF   xFB,F
2C4A:  BNZ   2C56
2C4C:  MOVF   xFA,F
2C4E:  BNZ   2C56
2C50:  MOVF   xF9,W
2C52:  SUBLW  64
2C54:  BC    2C5C
2C56:  MOVLW  02
2C58:  MOVWF  01
2C5A:  BRA    2DF6
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2C5C:  MOVF   xF8,F
2C5E:  BNZ   2C6E
2C60:  MOVF   xF7,F
2C62:  BNZ   2C6E
2C64:  MOVF   xF6,F
2C66:  BNZ   2C6E
2C68:  MOVF   xF5,W
2C6A:  SUBLW  05
2C6C:  BC    2CCE
2C6E:  MOVF   xF8,F
2C70:  BNZ   2CCE
2C72:  MOVF   xF7,F
2C74:  BNZ   2CCE
2C76:  MOVF   xF6,F
2C78:  BNZ   2CCE
2C7A:  MOVF   xF5,W
2C7C:  SUBLW  3B
2C7E:  BNC   2CCE
2C80:  MOVF   xF0,F
2C82:  BNZ   2C92
2C84:  MOVF   xEF,F
2C86:  BNZ   2C92
2C88:  MOVF   xEE,F
2C8A:  BNZ   2C92
2C8C:  MOVF   xED,W
2C8E:  SUBLW  64
2C90:  BC    2CCE
2C92:  MOVF   xF4,F
2C94:  BNZ   2CA4
2C96:  MOVF   xF3,F
2C98:  BNZ   2CA4
2C9A:  MOVF   xF2,F
2C9C:  BNZ   2CA4
2C9E:  MOVF   xF1,W
2CA0:  SUBLW  64
2CA2:  BC    2CCE
2CA4:  MOVF   xEC,F
2CA6:  BNZ   2CB6
2CA8:  MOVF   xEB,F
2CAA:  BNZ   2CB6
2CAC:  MOVF   xEA,F
2CAE:  BNZ   2CB6
2CB0:  MOVF   xE9,W
2CB2:  SUBLW  64
2CB4:  BC    2CCE
2CB6:  MOVF   xFC,F
2CB8:  BNZ   2CC8
2CBA:  MOVF   xFB,F
2CBC:  BNZ   2CC8
2CBE:  MOVF   xFA,F
2CC0:  BNZ   2CC8
2CC2:  MOVF   xF9,W
2CC4:  SUBLW  64
2CC6:  BC    2CCE
2CC8:  MOVLW  03
2CCA:  MOVWF  01
2CCC:  BRA    2DF6
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2CCE:  MOVF   xFC,F
2CD0:  BNZ   2CE0
2CD2:  MOVF   xFB,F
2CD4:  BNZ   2CE0
2CD6:  MOVF   xFA,F
2CD8:  BNZ   2CE0
2CDA:  MOVF   xF9,W
2CDC:  SUBLW  05
2CDE:  BC    2D40
2CE0:  MOVF   xFC,F
2CE2:  BNZ   2D40
2CE4:  MOVF   xFB,F
2CE6:  BNZ   2D40
2CE8:  MOVF   xFA,F
2CEA:  BNZ   2D40
2CEC:  MOVF   xF9,W
2CEE:  SUBLW  3B
2CF0:  BNC   2D40
2CF2:  MOVF   xF0,F
2CF4:  BNZ   2D04
2CF6:  MOVF   xEF,F
2CF8:  BNZ   2D04
2CFA:  MOVF   xEE,F
2CFC:  BNZ   2D04
2CFE:  MOVF   xED,W
2D00:  SUBLW  64
2D02:  BC    2D40
2D04:  MOVF   xF4,F
2D06:  BNZ   2D16
2D08:  MOVF   xF3,F
2D0A:  BNZ   2D16
2D0C:  MOVF   xF2,F
2D0E:  BNZ   2D16
2D10:  MOVF   xF1,W
2D12:  SUBLW  64
2D14:  BC    2D40
2D16:  MOVF   xF8,F
2D18:  BNZ   2D28
2D1A:  MOVF   xF7,F
2D1C:  BNZ   2D28
2D1E:  MOVF   xF6,F
2D20:  BNZ   2D28
2D22:  MOVF   xF5,W
2D24:  SUBLW  64
2D26:  BC    2D40
2D28:  MOVF   xEC,F
2D2A:  BNZ   2D3A
2D2C:  MOVF   xEB,F
2D2E:  BNZ   2D3A
2D30:  MOVF   xEA,F
2D32:  BNZ   2D3A
2D34:  MOVF   xE9,W
2D36:  SUBLW  64
2D38:  BC    2D40
2D3A:  MOVLW  04
2D3C:  MOVWF  01
2D3E:  BRA    2DF6
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2D40:  MOVF   xFC,F
2D42:  BNZ   2D54
2D44:  MOVF   xFB,F
2D46:  BNZ   2D54
2D48:  MOVF   xFA,F
2D4A:  BNZ   2D54
2D4C:  MOVF   xF9,W
2D4E:  SUBLW  C8
2D50:  BTFSC  FD8.0
2D52:  BRA    2DF2
2D54:  MOVF   xEC,F
2D56:  BTFSS  FD8.2
2D58:  BRA    2DF2
2D5A:  MOVF   xEB,F
2D5C:  BTFSS  FD8.2
2D5E:  BRA    2DF2
2D60:  MOVF   xEA,F
2D62:  BTFSS  FD8.2
2D64:  BRA    2DF2
2D66:  MOVF   xE9,W
2D68:  SUBLW  B3
2D6A:  BNC   2DF2
2D6C:  MOVF   xEC,F
2D6E:  BNZ   2D7E
2D70:  MOVF   xEB,F
2D72:  BNZ   2D7E
2D74:  MOVF   xEA,F
2D76:  BNZ   2D7E
2D78:  MOVF   xE9,W
2D7A:  SUBLW  64
2D7C:  BC    2DF2
2D7E:  MOVF   xF0,F
2D80:  BNZ   2DF2
2D82:  MOVF   xEF,F
2D84:  BNZ   2DF2
2D86:  MOVF   xEE,F
2D88:  BNZ   2DF2
2D8A:  MOVF   xED,W
2D8C:  SUBLW  B3
2D8E:  BNC   2DF2
2D90:  MOVF   xF0,F
2D92:  BNZ   2DA2
2D94:  MOVF   xEF,F
2D96:  BNZ   2DA2
2D98:  MOVF   xEE,F
2D9A:  BNZ   2DA2
2D9C:  MOVF   xED,W
2D9E:  SUBLW  64
2DA0:  BC    2DF2
2DA2:  MOVF   xF4,F
2DA4:  BNZ   2DF2
2DA6:  MOVF   xF3,F
2DA8:  BNZ   2DF2
2DAA:  MOVF   xF2,F
2DAC:  BNZ   2DF2
2DAE:  MOVF   xF1,W
2DB0:  SUBLW  B3
2DB2:  BNC   2DF2
2DB4:  MOVF   xF4,F
2DB6:  BNZ   2DC6
2DB8:  MOVF   xF3,F
2DBA:  BNZ   2DC6
2DBC:  MOVF   xF2,F
2DBE:  BNZ   2DC6
2DC0:  MOVF   xF1,W
2DC2:  SUBLW  64
2DC4:  BC    2DF2
2DC6:  MOVF   xF8,F
2DC8:  BNZ   2DF2
2DCA:  MOVF   xF7,F
2DCC:  BNZ   2DF2
2DCE:  MOVF   xF6,F
2DD0:  BNZ   2DF2
2DD2:  MOVF   xF5,W
2DD4:  SUBLW  B3
2DD6:  BNC   2DF2
2DD8:  MOVF   xF8,F
2DDA:  BNZ   2DEA
2DDC:  MOVF   xF7,F
2DDE:  BNZ   2DEA
2DE0:  MOVF   xF6,F
2DE2:  BNZ   2DEA
2DE4:  MOVF   xF5,W
2DE6:  SUBLW  64
2DE8:  BC    2DF2
2DEA:  MOVLW  04
2DEC:  MOVWF  01
2DEE:  BRA    2DF6
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2DF0:  BRA    2DF6
2DF2:  MOVLW  FF
2DF4:  MOVWF  01
.................... } 
2DF6:  MOVLB  0
2DF8:  GOTO   2E52 (RETURN)
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
2DFC:  BSF    F93.4
2DFE:  BTFSS  F81.4
2E00:  BRA    2E14
2E02:  BSF    F93.5
2E04:  BTFSS  F81.5
2E06:  BRA    2E14
2E08:  BSF    F93.6
2E0A:  BTFSS  F81.6
2E0C:  BRA    2E14
2E0E:  BSF    F93.7
2E10:  BTFSC  F81.7
2E12:  BRA    2F44
....................     { 
....................        if(input(ROW0)==0) 
2E14:  BSF    F93.4
2E16:  BTFSC  F81.4
2E18:  BRA    2E22
....................          row=0; 
2E1A:  MOVLB  A
2E1C:  CLRF   xE6
....................        else if(input(ROW1)==0) 
2E1E:  BRA    2E4E
2E20:  MOVLB  0
2E22:  BSF    F93.5
2E24:  BTFSC  F81.5
2E26:  BRA    2E32
....................          row=1; 
2E28:  MOVLW  01
2E2A:  MOVLB  A
2E2C:  MOVWF  xE6
....................        else if(input(ROW2)==0) 
2E2E:  BRA    2E4E
2E30:  MOVLB  0
2E32:  BSF    F93.6
2E34:  BTFSC  F81.6
2E36:  BRA    2E42
....................          row=2; 
2E38:  MOVLW  02
2E3A:  MOVLB  A
2E3C:  MOVWF  xE6
....................        else if(input(ROW3)==0) 
2E3E:  BRA    2E4E
2E40:  MOVLB  0
2E42:  BSF    F93.7
2E44:  BTFSC  F81.7
2E46:  BRA    2E50
....................          row=3;      
2E48:  MOVLW  03
2E4A:  MOVLB  A
2E4C:  MOVWF  xE6
2E4E:  MOVLB  0
....................        col=check_col(); 
2E50:  BRA    27C4
2E52:  MOVFF  01,AE4
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
2E56:  MOVLB  A
2E58:  INCFSZ xE4,W
2E5A:  BRA    2E5E
2E5C:  BRA    2F12
....................        { 
....................          kchar =KEYS[row][col]; 
2E5E:  MOVF   xE6,W
2E60:  MULLW  05
2E62:  MOVF   FF3,W
2E64:  CLRF   xE8
2E66:  MOVWF  xE7
2E68:  CLRF   03
2E6A:  MOVF   xE4,W
2E6C:  ADDWF  xE7,W
2E6E:  MOVWF  01
2E70:  MOVF   xE8,W
2E72:  ADDWFC 03,F
2E74:  MOVF   01,W
2E76:  MOVLB  0
2E78:  CALL   00E8
2E7C:  MOVFF  FE8,AE5
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
2E80:  MOVLB  1
2E82:  MOVF   x08,F
2E84:  BNZ   2F06
....................             { 
....................               charac_timeout=0; 
2E86:  MOVLB  0
2E88:  CLRF   xFC
2E8A:  CLRF   xFB
....................                if(key_count_ms<20)key_data[key_count_ms++]=kchar; 
2E8C:  MOVLB  1
2E8E:  MOVF   x0B,W
2E90:  SUBLW  13
2E92:  BNC   2EA8
2E94:  MOVF   x0B,W
2E96:  INCF   x0B,F
2E98:  CLRF   03
2E9A:  ADDLW  10
2E9C:  MOVWF  FE9
2E9E:  MOVLW  01
2EA0:  ADDWFC 03,W
2EA2:  MOVWF  FEA
2EA4:  MOVFF  AE5,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
2EA8:  MOVLW  CE
2EAA:  MOVWF  FF6
2EAC:  MOVLW  02
2EAE:  MOVWF  FF7
2EB0:  MOVLW  09
2EB2:  MOVLB  B
2EB4:  MOVWF  x0A
2EB6:  MOVLB  0
2EB8:  CALL   1930
2EBC:  MOVFF  10B,AED
2EC0:  MOVLW  18
2EC2:  MOVLB  A
2EC4:  MOVWF  xEE
2EC6:  MOVLB  0
2EC8:  CALL   1A44
2ECC:  MOVLW  5D
2ECE:  MOVLB  B
2ED0:  MOVWF  x16
2ED2:  MOVLB  0
2ED4:  CALL   0548
2ED8:  MOVLW  20
2EDA:  MOVLB  B
2EDC:  MOVWF  x16
2EDE:  MOVLB  0
2EE0:  CALL   0548
2EE4:  MOVFF  AE5,B16
2EE8:  CALL   0548
2EEC:  MOVLW  0D
2EEE:  MOVLB  B
2EF0:  MOVWF  x16
2EF2:  MOVLB  0
2EF4:  CALL   0548
2EF8:  MOVLW  0A
2EFA:  MOVLB  B
2EFC:  MOVWF  x16
2EFE:  MOVLB  0
2F00:  CALL   0548
....................             } 
....................                else fputc(kchar,COM2); 
2F04:  BRA    2F10
2F06:  MOVFF  AE5,B16
2F0A:  MOVLB  0
2F0C:  CALL   0548
2F10:  MOVLB  A
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
2F12:  BSF    F93.4
2F14:  BTFSS  F81.4
2F16:  BRA    2F12
2F18:  BSF    F93.5
2F1A:  BTFSS  F81.5
2F1C:  BRA    2F12
2F1E:  BSF    F93.6
2F20:  BTFSS  F81.6
2F22:  BRA    2F12
2F24:  BSF    F93.7
2F26:  BTFSS  F81.7
2F28:  BRA    2F12
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
2F2A:  BSF    F93.4
2F2C:  BTFSS  F81.4
2F2E:  BRA    2F2A
2F30:  BSF    F93.5
2F32:  BTFSS  F81.5
2F34:  BRA    2F2A
2F36:  BSF    F93.6
2F38:  BTFSS  F81.6
2F3A:  BRA    2F2A
2F3C:  BSF    F93.7
2F3E:  BTFSS  F81.7
2F40:  BRA    2F2A
2F42:  MOVLB  0
....................     } 
....................   set_tris_a(0xff);     
2F44:  MOVLW  FF
2F46:  MOVWF  F92
....................   return(kchar); 
2F48:  MOVLB  A
2F4A:  MOVFF  AE5,01
.................... }//*/ 
2F4E:  MOVLB  0
2F50:  RETURN 0
.................... //============================================ 
....................  
.................... //=========================== 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
3C72:  MOVF   27,F
3C74:  BTFSS  FD8.2
3C76:  BRA    3DB6
3C78:  MOVF   26,F
3C7A:  BTFSS  FD8.2
3C7C:  BRA    3DB6
3C7E:  MOVF   25,W
3C80:  SUBLW  FF
3C82:  BTFSS  FD8.0
3C84:  BRA    3DB6
3C86:  BNZ   3C90
3C88:  MOVF   24,W
3C8A:  SUBLW  FE
3C8C:  BTFSS  FD8.0
3C8E:  BRA    3DB6
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)) 
3C90:  MOVLB  1
3C92:  MOVF   x10,F
3C94:  BZ    3D64
....................       { 
....................          temp=get_countcard(); 
3C96:  MOVLB  0
3C98:  CALL   31A4
3C9C:  MOVFF  02,AE6
3CA0:  MOVFF  01,AE5
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
3CA4:  MOVFF  AE6,AEA
3CA8:  MOVFF  AE5,AE9
3CAC:  MOVLB  A
3CAE:  CLRF   xEC
3CB0:  MOVLW  32
3CB2:  MOVWF  xEB
3CB4:  MOVLB  0
3CB6:  CALL   31F4
3CBA:  MOVFF  02,AE8
3CBE:  MOVFF  01,AE7
3CC2:  MOVLW  46
3CC4:  MOVLB  A
3CC6:  ADDWF  xE7,F
3CC8:  MOVLW  AA
3CCA:  ADDWFC xE8,F
3CCC:  MOVLW  01
3CCE:  ADDWF  xE7,W
3CD0:  MOVWF  01
3CD2:  MOVLW  00
3CD4:  ADDWFC xE8,W
3CD6:  MOVFF  01,24
3CDA:  MOVWF  25
3CDC:  CLRF   26
3CDE:  CLRF   27
....................          for(i=0;i<key_numbyte-5;i++) 
3CE0:  CLRF   xE4
3CE2:  MOVF   xE4,W
3CE4:  SUBLW  2C
3CE6:  BNC   3D38
....................          { 
....................             write_ext_eeprom((long int)ptr_card_key++,key_data[i]); 
3CE8:  MOVFF  27,03
3CEC:  MOVFF  26,02
3CF0:  MOVFF  25,01
3CF4:  MOVFF  24,00
3CF8:  MOVLW  01
3CFA:  ADDWF  24,F
3CFC:  BTFSC  FD8.0
3CFE:  INCF   25,F
3D00:  BTFSC  FD8.2
3D02:  INCF   26,F
3D04:  BTFSC  FD8.2
3D06:  INCF   27,F
3D08:  MOVFF  01,AE8
3D0C:  MOVFF  00,AE7
3D10:  CLRF   03
3D12:  MOVF   xE4,W
3D14:  ADDLW  10
3D16:  MOVWF  FE9
3D18:  MOVLW  01
3D1A:  ADDWFC 03,W
3D1C:  MOVWF  FEA
3D1E:  MOVFF  FEF,AE9
3D22:  MOVFF  01,B03
3D26:  MOVFF  00,B02
3D2A:  MOVFF  AE9,B04
3D2E:  MOVLB  0
3D30:  RCALL  364C
....................             //fputc(key_data[i],COM2); 
....................          } 
3D32:  MOVLB  A
3D34:  INCF   xE4,F
3D36:  BRA    3CE2
....................          write_ext_eeprom((long int)ptr_card_key,0); 
3D38:  MOVFF  25,B03
3D3C:  MOVFF  24,B02
3D40:  MOVLB  B
3D42:  CLRF   x04
3D44:  MOVLB  0
3D46:  RCALL  364C
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
3D48:  MOVFF  27,AEA
3D4C:  MOVFF  26,AE9
3D50:  MOVFF  25,AE8
3D54:  MOVFF  24,AE7
3D58:  MOVLW  1E
3D5A:  MOVLB  A
3D5C:  MOVWF  xEB
3D5E:  MOVLB  0
3D60:  RCALL  3752
3D62:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
3D64:  CLRF   x0B
....................       del_buf(key_numbyte,key_data); 
3D66:  MOVLW  32
3D68:  MOVLB  A
3D6A:  MOVWF  xF3
3D6C:  MOVLW  01
3D6E:  MOVWF  xF5
3D70:  MOVLW  10
3D72:  MOVWF  xF4
3D74:  MOVLB  0
3D76:  CALL   3216
....................       fprintf(COM2,"\r\n"); 
3D7A:  MOVLW  0D
3D7C:  MOVLB  B
3D7E:  MOVWF  x16
3D80:  MOVLB  0
3D82:  CALL   0548
3D86:  MOVLW  0A
3D88:  MOVLB  B
3D8A:  MOVWF  x16
3D8C:  MOVLB  0
3D8E:  CALL   0548
....................       fprintf(COM2,"Done PIN"); 
3D92:  MOVLW  E0
3D94:  MOVWF  FF6
3D96:  MOVLW  02
3D98:  MOVWF  FF7
3D9A:  CALL   058E
....................       fprintf(COM2,"\r\n"); 
3D9E:  MOVLW  0D
3DA0:  MOVLB  B
3DA2:  MOVWF  x16
3DA4:  MOVLB  0
3DA6:  CALL   0548
3DAA:  MOVLW  0A
3DAC:  MOVLB  B
3DAE:  MOVWF  x16
3DB0:  MOVLB  0
3DB2:  CALL   0548
....................    } 
.................... } 
3DB6:  GOTO   4070 (RETURN)
.................... //=========================================== 
.................... void key_press() 
.................... { 
....................    int8 col; 
....................    int32 KB_count_timeout=0; 
....................    fprintf(COM2,"\r\n"); 
....................    fprintf(COM2,"Key"); 
....................    //fprintf(COM2,"\r\n"); 
....................    KB_count_timeout=0; 
....................    while(1) 
....................    { 
....................       
....................       if(KB_count_timeout<150000)KB_count_timeout++; 
....................       if(KB_count_timeout==150000) 
....................       { 
....................          KB_count_timeout++; 
....................           
....................          break;             
....................       }   
....................    } 
.................... } 
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
*
451A:  MOVLB  A
451C:  CLRF   xC4
451E:  CLRF   xC3
4520:  CLRF   xC5
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
4522:  MOVF   xC4,F
4524:  BTFSS  FD8.2
4526:  BRA    464A
4528:  MOVF   xBE,W
452A:  SUBWF  xC3,W
452C:  BTFSC  FD8.0
452E:  BRA    464A
4530:  MOVF   xC5,F
4532:  BTFSS  FD8.2
4534:  BRA    464A
....................       c = fgetc(COM2);//getc(); 
4536:  MOVLB  0
4538:  RCALL  44CC
453A:  MOVFF  01,AC1
....................       switch(c) 
....................       { 
453E:  MOVLB  A
4540:  MOVF   xC1,W
4542:  XORLW  7F
4544:  MOVLB  0
4546:  BZ    454E
4548:  XORLW  72
454A:  BZ    459C
454C:  BRA    45DA
....................          case 0x7f:    
....................             if(nbcar>0)   
454E:  MOVLB  A
4550:  MOVF   xC3,F
4552:  BNZ   4558
4554:  MOVF   xC4,F
4556:  BZ    4582
4558:  CLRF   19
455A:  BTFSC  FF2.7
455C:  BSF    19.7
455E:  BCF    FF2.7
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
4560:  MOVLW  7F
4562:  MOVLB  B
4564:  MOVWF  x16
4566:  MOVLB  0
4568:  CALL   0548
456C:  BTFSC  19.7
456E:  BSF    FF2.7
....................                nbcar--; 
4570:  MOVLB  A
4572:  MOVF   xC3,W
4574:  BTFSC  FD8.2
4576:  DECF   xC4,F
4578:  DECF   xC3,F
....................                fgetc(COM2);//getc(); 
457A:  MOVLB  0
457C:  RCALL  44CC
....................             } 
....................             else fputc(0x07,COM2);    
457E:  BRA    459A
4580:  MOVLB  A
4582:  CLRF   19
4584:  BTFSC  FF2.7
4586:  BSF    19.7
4588:  BCF    FF2.7
458A:  MOVLW  07
458C:  MOVLB  B
458E:  MOVWF  x16
4590:  MOVLB  0
4592:  CALL   0548
4596:  BTFSC  19.7
4598:  BSF    FF2.7
....................          break;  
459A:  BRA    4646
....................          case 0x0D:   
....................                keydebug_en=0; 
459C:  MOVLB  1
459E:  CLRF   x08
....................                set_tris_a(0xff); 
45A0:  MOVLW  FF
45A2:  MOVWF  F92
....................                for(i=nbcar;i<nbcarmax;i++) 
45A4:  MOVFF  AC3,AC2
45A8:  MOVLB  A
45AA:  MOVF   xBE,W
45AC:  SUBWF  xC2,W
45AE:  BC    45C4
....................                { 
....................                  chaine[i]=0; 
45B0:  CLRF   03
45B2:  MOVF   xC2,W
45B4:  ADDWF  xBF,W
45B6:  MOVWF  FE9
45B8:  MOVF   xC0,W
45BA:  ADDWFC 03,W
45BC:  MOVWF  FEA
45BE:  CLRF   FEF
....................                } 
45C0:  INCF   xC2,F
45C2:  BRA    45AA
....................                if(nbcar==0)return(FAUX); 
45C4:  MOVF   xC3,F
45C6:  BNZ   45D2
45C8:  MOVF   xC4,F
45CA:  BNZ   45D2
45CC:  MOVLW  00
45CE:  MOVWF  01
45D0:  BRA    464E
....................                fini=VRAI; 
45D2:  MOVLW  01
45D4:  MOVWF  xC5
....................          break; 
45D6:  MOVLB  0
45D8:  BRA    4646
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
45DA:  MOVLB  A
45DC:  MOVF   xC1,W
45DE:  SUBLW  1F
45E0:  BC    4648
45E2:  MOVF   xC1,W
45E4:  SUBLW  7E
45E6:  BNC   4648
45E8:  MOVLW  01
45EA:  SUBWF  xBE,W
45EC:  MOVF   xC4,F
45EE:  BNZ   4648
45F0:  SUBWF  xC3,W
45F2:  BC    4648
....................             { 
....................                chaine[nbcar]=c; 
45F4:  MOVF   xBF,W
45F6:  ADDWF  xC3,W
45F8:  MOVWF  FE9
45FA:  MOVF   xC0,W
45FC:  ADDWFC xC4,W
45FE:  MOVWF  FEA
4600:  MOVFF  AC1,FEF
....................                nbcar++; 
4604:  INCF   xC3,F
4606:  BTFSC  FD8.2
4608:  INCF   xC4,F
....................                if(echo==EN_ECHO) fputc(c,COM2); 
460A:  DECFSZ xBD,W
460C:  BRA    4628
460E:  CLRF   19
4610:  BTFSC  FF2.7
4612:  BSF    19.7
4614:  BCF    FF2.7
4616:  MOVFF  AC1,B16
461A:  MOVLB  0
461C:  CALL   0548
4620:  BTFSC  19.7
4622:  BSF    FF2.7
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
4624:  BRA    4646
4626:  MOVLB  A
4628:  MOVF   xBD,W
462A:  SUBLW  02
462C:  BNZ   4648
462E:  CLRF   19
4630:  BTFSC  FF2.7
4632:  BSF    19.7
4634:  BCF    FF2.7
4636:  MOVLW  2A
4638:  MOVLB  B
463A:  MOVWF  x16
463C:  MOVLB  0
463E:  CALL   0548
4642:  BTFSC  19.7
4644:  BSF    FF2.7
4646:  MOVLB  A
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
4648:  BRA    4522
....................    return(nbcar); 
464A:  MOVFF  AC3,01
.................... } 
464E:  MOVLB  0
4650:  RETURN 0
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
4652:  MOVFF  ABE,AC2
4656:  MOVFF  ABD,AC1
465A:  MOVFF  AC0,AC4
465E:  MOVFF  ABF,AC3
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
4662:  MOVFF  AC2,03
4666:  MOVLB  A
4668:  MOVFF  AC1,FE9
466C:  MOVFF  AC2,FEA
4670:  MOVF   FEF,F
4672:  BZ    46BA
4674:  MOVFF  AC4,03
4678:  MOVFF  AC3,FE9
467C:  MOVFF  AC4,FEA
4680:  MOVF   FEF,F
4682:  BZ    46BA
....................       if(*aa!=*bb) 
4684:  MOVFF  AC1,FE9
4688:  MOVFF  AC2,FEA
468C:  MOVFF  FEF,AC5
4690:  MOVFF  AC4,03
4694:  MOVFF  AC3,FE9
4698:  MOVFF  AC4,FEA
469C:  MOVF   FEF,W
469E:  SUBWF  xC5,W
46A0:  BZ    46A8
....................          return(1); 
46A2:  MOVLW  01
46A4:  MOVWF  01
46A6:  BRA    46E6
....................       aa++; 
46A8:  INCF   xC1,F
46AA:  BTFSC  FD8.2
46AC:  INCF   xC2,F
....................       bb++; 
46AE:  INCF   xC3,F
46B0:  BTFSC  FD8.2
46B2:  INCF   xC4,F
....................    } 
46B4:  MOVLB  0
46B6:  BRA    4662
46B8:  MOVLB  A
....................    if(*aa!=*bb)return(1); 
46BA:  MOVFF  AC2,03
46BE:  MOVFF  AC1,FE9
46C2:  MOVFF  AC2,FEA
46C6:  MOVFF  FEF,AC5
46CA:  MOVFF  AC4,03
46CE:  MOVFF  AC3,FE9
46D2:  MOVFF  AC4,FEA
46D6:  MOVF   FEF,W
46D8:  SUBWF  xC5,W
46DA:  BZ    46E2
46DC:  MOVLW  01
46DE:  MOVWF  01
46E0:  BRA    46E6
....................    return(0); 
46E2:  MOVLW  00
46E4:  MOVWF  01
.................... } 
46E6:  MOVLB  0
46E8:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
*
4C2C:  MOVLB  A
4C2E:  CLRF   xBF
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
4C30:  MOVFF  ABE,03
4C34:  MOVF   xBD,W
4C36:  INCF   xBD,F
4C38:  BTFSC  FD8.2
4C3A:  INCF   xBE,F
4C3C:  MOVWF  FE9
4C3E:  MOVFF  03,FEA
4C42:  MOVFF  FEF,AC1
4C46:  MOVF   xC1,F
4C48:  BZ    4C6C
....................         if (c >= '0' && c <= '9') 
4C4A:  MOVF   xC1,W
4C4C:  SUBLW  2F
4C4E:  BC    4C5E
4C50:  MOVF   xC1,W
4C52:  SUBLW  39
4C54:  BNC   4C5E
....................             digit = (unsigned int) (c - '0'); 
4C56:  MOVLW  30
4C58:  SUBWF  xC1,W
4C5A:  MOVWF  xC0
....................         else 
4C5C:  BRA    4C60
....................             break; 
4C5E:  BRA    4C6C
....................  
....................         val = (val * 10) + digit; 
4C60:  MOVF   xBF,W
4C62:  MULLW  0A
4C64:  MOVF   FF3,W
4C66:  ADDWF  xC0,W
4C68:  MOVWF  xBF
....................     } 
4C6A:  BRA    4C30
....................  
....................     return val; 
4C6C:  CLRF   03
4C6E:  MOVFF  ABF,01
4C72:  MOVFF  03,02
.................... } 
4C76:  MOVLB  0
4C78:  RETURN 0
....................  
.................... #include <GSM.c>  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#include "myRS485.C" 
....................  
.................... #define        EMERGOFF       PIN_A7 
.................... #define        reading_sms_cmd      1 
.................... #define        MSG_avai             2 
.................... #define        analyze_sms          3 
.................... #define        checking_MN          4 
.................... #define        doing_sms            5 
.................... #define        delete_MSG           6 
.................... #define        pre_cmd              7 
.................... #define        MSG_sending          8 
.................... #define        check_st             9 
.................... #define        config               10 
.................... #define        autosending          11 
.................... #define        idle                 12 
.................... #define        data_analyze         13 
.................... #define        SIM_reply            14 
.................... #define        check_comunication   15 
.................... #define        phone_activity_status 16 
.................... #define        check_inbox          17 
.................... //#define     IGT            PIN_A6 
....................  
.................... //#define     batmb    sendto485(0,0x11,1) 
.................... //#define     tatmb    sendto485(0,0x11,0) 
....................  
....................  
.................... unsigned int8 msg_data_sending[280]; 
.................... int8 sim_bug[50]; 
.................... unsigned int8 msg_buffer1[20]; 
.................... unsigned int8 msg_buffer2[50]; 
.................... unsigned int8 reply_buffer[280]; 
.................... unsigned int8 datetime[25]; 
.................... unsigned int8 mobilenumb[26]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... //unsigned int8 buf_checkMBN[16]; 
.................... int16 count_polling=0; 
.................... int8 SIM_state=0,MSG_sending_st=0; 
.................... int16 timing_wait=300; 
.................... int8 auto_sending=0; 
.................... int8 send_oneMSG=0; 
.................... int8 SIM_reply_st=0; 
.................... int8 checking_sim=0; 
.................... int16 count_checking=90; 
.................... //unsigned int8 com_buffer1[20]="it is OK"; 
.................... //============================================== 
.................... void earse_buffer_uart(unsigned int8 numbuf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<numbuf;i++) 
....................    { 
....................        buffer_uart[i]=0; 
....................    } 
.................... } 
.................... //============================================== 
.................... void sim900_init() 
.................... { 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(500); 
....................    fprintf(COM1,"AT+CMGF=1\r\n"); 
....................    delay_ms(500); 
....................    //del_buf(26,mobilenumb); 
....................    //strcpy(mobilenumb,"+84903219082"); 
.................... } 
.................... //============================================== 
.................... int8 get_datasim900(int8 *datin) 
.................... { 
....................    int8 c,i,index=0; 
....................    int8 testtemp[20]; 
....................    while(index<5) 
....................    { 
....................       c = getc(); 
....................       index++; 
....................       fprintf(COM2,"%c", c);  
....................    } 
....................    for(i=0;i<15;i++) 
....................    { 
....................       fprintf(COM2,"%c", testtemp[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", index);//*/ 
....................    return 0; 
.................... } 
.................... //============================================== 
.................... int8 check_module() 
.................... { 
....................    int8 temp=0,i; 
....................    earse_buffer_uart(10); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    UART_index=0; 
....................    delay_ms(200); 
....................    //fputc('c',COM2); 
....................    //fprintf("MSG is OK\r\n"); 
....................    for(i=0;i<10;i++) 
....................    { 
....................       //fputc(buffer_uart[i],COM2); 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) 
....................       { 
....................          i=10; 
....................          temp=1; 
....................          return(temp); 
....................       } 
....................          else temp=0; 
....................    } 
....................    UART_index=0; 
....................    return(temp); 
.................... } 
.................... //============================================== 
.................... void power_on() 
.................... { 
....................    /*while(temp==0) 
....................    { 
....................       temp = check_module(); 
....................       if(temp==0) 
....................       { 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
....................       } 
....................          else break; 
....................    }*/ 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
.................... } 
.................... //============================================== 
.................... void power_off() 
.................... { 
....................    fprintf(COM1,"AT+CPOWD\r\n"); 
.................... } 
.................... //============================================== 
.................... unsigned int8 mymemcmp(void * s1,char *s2,size_t n) 
.................... { 
....................    char *su1, *su2; 
....................    unsigned int8 temp=0,i=0; 
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................       { 
....................          temp=1; 
....................          if(*su1>*su2) 
....................          { 
....................             if((i==0)&&(*su1==(*su2)+32)) temp = 0; 
....................                //else temp = 0; 
....................          } 
....................             else  
....................                { 
....................                   if((i==0)&&(*su2==(*su1)+32)) temp = 0; 
....................                     // else temp = 0; 
....................                } 
....................       } 
....................       i++; 
....................    } 
....................    return (temp); 
.................... } 
.................... //============================================== 
.................... int8 pre_msg(int8 *datin,int8 *datout,int16 index) 
.................... { 
....................    int8 i,len=0; 
....................    len = strlen(datin); 
....................    for(i=0;i<len;i++)datout[index++]=datin[i]; 
....................    return index; 
.................... } 
.................... //============================================== 
.................... void delete_sms(char number_sms) 
.................... { 
....................    switch(number_sms) 
....................    { 
....................        case  1: 
....................             fprintf(COM1,"AT+CMGD=1\r\n");  
....................        break; 
....................        case  2: 
....................             fprintf(COM1,"AT+CMGD=2\r\n"); 
....................        break; 
....................        case  3: 
....................             fprintf(COM1,"AT+CMGD=3\r\n"); 
....................        break; 
....................        case  4: 
....................             fprintf(COM1,"AT+CMGD=4\r\n");        
....................        break; 
....................        case  5: 
....................             fprintf(COM1,"AT+CMGD=5\r\n"); 
....................        break; 
....................        case  6: 
....................             fprintf(COM1,"AT+CMGD=6\r\n"); 
....................        break; 
....................        case  7: 
....................              fprintf(COM1,"AT+CMGD=7\r\n"); 
....................        break;        
....................        case  8: 
....................             fprintf(COM1,"AT+CMGD=8\r\n"); 
....................        break;        
....................    } 
....................    delay_ms(500); 
.................... } 
.................... //============================================== 
.................... void del_multi_sms(int8 num_sms) 
.................... { 
....................    int8 i; 
....................    for(i=1;i<=num_sms;i++) 
....................    { 
....................      delete_sms(i);  
....................      delay_ms(100); 
....................    } 
.................... } 
.................... //============================================== 
.................... //============================================== 
.................... void send_sms(unsigned int8* mobile_num,unsigned int8* MSG) 
.................... { 
....................       unsigned int8 i=0,strl=0; 
....................       strl= strlen(MSG);   
....................       fprintf(COM1,"AT+CMGS="); 
....................       delay_ms(500); 
....................       fputc('"',COM1); 
....................       while((mobile_num[i]!=0)&&(i<20)) 
....................       { 
....................          //fputc(mobile_num[i],COM2); 
....................          //putc(mobile_num[i]); 
....................          fputc(mobile_num[i],COM1); 
....................          i++; 
....................       } 
....................       fputc('"',COM1); 
....................       fprintf(COM1,"\r\n"); 
....................       delay_ms(500);         
....................       for(i=0;i<strl;i++) 
....................       { 
....................          fputc(MSG[i],COM1); 
....................       } 
....................       delay_ms(500); 
....................       fputc(26,COM1); 
.................... } 
.................... //============================================= 
.................... //============================================== 
.................... void reading_sms() 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<16;i++) mobilenumb[i]=0; 
....................    earse_buffer_uart(200); 
....................    printf("AT+CMGF=1\r\n"); 
....................    printf("AT+CMGR=1\r\n");  
....................    UART_index=0;  
....................    delay_ms(1000); 
....................    for(i=0;i<200;i++) 
....................    { 
....................       if((buffer_uart[i]=='a')&&(buffer_uart[i+1]=='d')&&(buffer_uart[i+2]=='m')&&(buffer_uart[i+3]=='i')&&(buffer_uart[i+4]=='n')&&(buffer_uart[i+5]==' ')) 
....................       { 
....................          write_ext_eeprom(strobe_mobile_num1,buffer_uart[i+6]); 
....................          fputc(buffer_uart[i+6],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+1,buffer_uart[i+7]); 
....................          fputc(buffer_uart[i+7],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+2,buffer_uart[i+8]); 
....................          fputc(buffer_uart[i+8],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+3,buffer_uart[i+9]); 
....................          fputc(buffer_uart[i+9],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+4,buffer_uart[i+10]); 
....................          fputc(buffer_uart[i+10],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+5,buffer_uart[i+11]); 
....................          fputc(buffer_uart[i+11],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+6,buffer_uart[i+12]); 
....................          fputc(buffer_uart[i+12],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+7,buffer_uart[i+13]); 
....................          fputc(buffer_uart[i+13],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+8,buffer_uart[i+14]); 
....................          fputc(buffer_uart[i+14],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+9,buffer_uart[i+15]); 
....................          fputc(buffer_uart[i+15],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+10,buffer_uart[i+16]); 
....................          fputc(buffer_uart[i+16],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+11,buffer_uart[i+17]); 
....................          fputc(buffer_uart[i+17],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+12,buffer_uart[i+18]); 
....................          fputc(buffer_uart[i+18],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+13,buffer_uart[i+19]); 
....................          fputc(buffer_uart[i+19],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+14,buffer_uart[i+20]); 
....................          fputc(buffer_uart[i+20],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+15,buffer_uart[i+21]); 
....................          fputc(buffer_uart[i+21],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+16,buffer_uart[i+22]); 
....................          fputc(buffer_uart[i+22],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+17,buffer_uart[i+23]); 
....................          fputc(buffer_uart[i+23],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+18,buffer_uart[i+24]); 
....................          fputc(buffer_uart[i+24],COM2);          
....................          write_ext_eeprom(strobe_mobile_num1+19,buffer_uart[i+25]); 
....................          fputc(buffer_uart[i+25],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+20,buffer_uart[i+26]); 
....................          fputc(buffer_uart[i+26],COM2);          
....................          fprintf(COM2,"\r\n"); 
....................          EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................          i=250; 
....................          sms_unread_flag=0; 
....................          strcpy (msg_data_sending, "done"); 
....................          send_sms(mobilenumb,msg_data_sending); 
....................          delay_ms(5000); 
....................          delete_sms(1); 
....................          delay_ms(5000); 
....................          UART_index=0; 
....................       } 
....................         else  
....................          { 
....................             if(i>198)  
....................             { 
....................                delay_ms(5000); 
....................                delete_sms(1); 
....................                delay_ms(5000); 
....................                UART_index=0; 
....................                sms_unread_flag=0; 
....................                EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................             } 
....................          } 
....................    } 
.................... } 
.................... //============================================== 
.................... /*void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... }*/ 
.................... //============================================================ 
.................... int8 checking_msg_avai() 
.................... { 
....................    int8 i; 
....................    /*for(i=0;i<100;i++) 
....................    { 
....................       fprintf(COM2,"%c", buffer_uart[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", UART_index);//*/ 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) return 1; 
....................    } 
....................    return 0; 
.................... } 
.................... //============================================================ 
.................... int8 SMS_coming() 
.................... { 
.................... //+CMTI: "SM",25 
....................    int8 i,st=0; 
....................    //int8 msg_temp[20],msg_temp1[20]; 
....................    //strncpy(msg_temp1,buffer_uart,20); 
....................    //strcpy(msg_temp,"+CMTI:"); 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='T')&&(buffer_uart[4+i]=='I')&&(buffer_uart[5+i]==':'))  
....................       {  
....................          fprintf(COM2,"\n\rNew SMS\n\r"); 
....................          //output_high(PIN_C2); 
....................          SIM_state=reading_sms_cmd; 
....................          st = 2; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='G')&&(buffer_uart[4+i]=='R')&&(buffer_uart[5+i]==':'))  
....................       {  
....................          fprintf(COM2,"\n\rREC UNREAD\n\r"); 
....................          //output_high(PIN_C2); 
....................          SIM_state=reading_sms_cmd; 
....................          st = 2; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='R')&&(buffer_uart[1+i]=='I')&&(buffer_uart[2+i]=='N')&&(buffer_uart[3+i]=='G'))  
....................       {  
....................          fprintf(COM2,"\n\rRING\n\r"); 
....................          output_high(PIN_C2); 
....................          st = 1; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................    } 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='P')&&(buffer_uart[3+i]=='A')&&(buffer_uart[4+i]=='S')&&(buffer_uart[5+i]==':'))  
....................       {  
....................          if(buffer_uart[7+i]=='0')  
....................          { 
....................             fprintf(COM2,"Ready (MT allows commands from TA/TE)\n\r"); 
....................             SIM_state= check_inbox; 
....................          } 
....................          if(buffer_uart[7+i]=='2') 
....................          { 
....................             fprintf(COM2,"No network\n\r"); 
....................             SIM_state=check_comunication; 
....................          } 
....................          if(buffer_uart[7+i]=='3') fprintf(COM2,"Ringing\n\r"); 
....................          if(buffer_uart[7+i]=='4') fprintf(COM2,"Call in progress\n\r"); 
....................          st = 3; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................    } 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='U')&&(buffer_uart[1+i]=='N')&&(buffer_uart[2+i]=='D')&&(buffer_uart[3+i]=='E')&&(buffer_uart[4+i]=='R')&&(buffer_uart[5+i]=='-')&&(buffer_uart[6+i]=='V')&&(buffer_uart[7+i]=='O')&&(buffer_uart[8+i]=='L'))  
....................       {  
....................          fprintf(COM2,"\n\rUNDER-VOLTAGE WARNNING\n\r"); 
....................          SIM_state=reading_sms_cmd; 
....................          st = 4; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................    } 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[0+i]=='O')&&(buffer_uart[1+i]=='V')&&(buffer_uart[2+i]=='E')&&(buffer_uart[3+i]=='R')&&(buffer_uart[4+i]=='-')&&(buffer_uart[5+i]=='V')&&(buffer_uart[6+i]=='O')&&(buffer_uart[7+i]=='L')&&(buffer_uart[8+i]=='T'))  
....................       {  
....................          fprintf(COM2,"\n\rOVER-VOLTAGE POWER DOWN\n\r"); 
....................          SIM_state=reading_sms_cmd; 
....................          st = 4; 
....................          i=23; 
....................       } 
....................          else st=0; 
....................    } 
....................  
....................    UART_index=0; 
....................    memset(buffer_uart,0,sizeof(buffer_uart));  
....................    return st; 
.................... } 
.................... //============================================================ 
.................... unsigned int8 analyzing_msg(char* MSG,char* mobile_number) 
.................... { 
....................    unsigned int8 i=0,a=0,b=0,d=0,u=0,v=0; 
....................    unsigned int8 st=0,temp; 
....................    del_buf(50,MSG); 
....................    del_buf(20,mobile_number); 
....................    for(i=0;i<100;i++) 
....................    { 
....................       if((buffer_uart[i]=='+')&&(buffer_uart[i+1]=='C')&&(buffer_uart[i+2]=='M')&&(buffer_uart[i+3]=='G')&&(buffer_uart[i+4]=='R')&&(buffer_uart[i+5]==':')&&(buffer_uart[i+6]==' ')&&(buffer_uart[i+7]=='0')&&(buffer_uart[i+8]==',')&&(buffer_uart[i+9]==',')&&(buffer_uart[i+10]=='0'))  
....................       { 
....................          st=0; 
....................          i=200; 
....................          del_buf(100,MSG); 
....................          del_buf(16,mobile_number); 
....................          count_spam=0; 
....................          //output_toggle(pin_a5); 
....................       } 
....................          //else st=2; 
....................      temp = buffer_uart[i]; 
....................      if((a==3))  
....................      { 
....................        if((temp>47)&&(temp<58)||temp=='+') mobile_number[i-b] = temp; 
....................      } 
....................      if(d==2) 
....................      { 
....................          MSG[i-b] = temp; 
....................          st=1; 
....................      } 
....................      if(u==2) 
....................      { 
....................          datetime[i-v]=temp; 
....................      } 
....................       //else st=2; 
....................      if(temp==34)  
....................      { 
....................          if(a<6)a++; 
....................          if(a==3) b = i+1; 
....................      } 
....................      if(a==6) 
....................      { 
....................          if((temp==13)||(temp==10))  
....................          { 
....................             d++; 
....................             if(d==2) b = i+1; 
....................          } 
....................          if(temp==34)  
....................          { 
....................             u++; 
....................             if(u==2)v=i+1; 
....................          } 
....................      } 
....................      //if((temp==',')&&(a==6)) 
....................     // { 
....................          //if(c<2)c++; 
....................      //} 
....................    } 
....................    return(st); 
.................... } 
.................... //================================ 
.................... int8 ascii2int(int8 num1,int8 num2) 
.................... { 
....................    int8 temp; 
....................    temp=(num1-48)*10 + (num2-48); 
....................    return temp; 
.................... } 
.................... //================================ 
.................... void updatetime2ds1307() 
.................... { 
....................    int8 temp; 
....................    year=ascii2int(datetime[0],datetime[1]); 
....................    mon=ascii2int(datetime[3],datetime[4]); 
....................    date=ascii2int(datetime[6],datetime[7]); 
....................    h=ascii2int(datetime[9],datetime[10]); 
....................    min=ascii2int(datetime[12],datetime[13])+1; 
....................    //h=ascii2int(datetime[9],datetime[10]); 
....................    rtc_set_datetime(date,mon,year,day,h,min); 
.................... } 
.................... //================================ 
....................  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
05AE:  MOVLB  B
05B0:  CLRF   x37
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
05B2:  CLRF   x38
05B4:  BTFSC  x2F.0
05B6:  BSF    x38.7
05B8:  SWAPF  x30,W
05BA:  MOVWF  00
05BC:  RLCF   00,F
05BE:  RLCF   00,F
05C0:  MOVLW  C0
05C2:  ANDWF  00,F
05C4:  MOVF   00,W
05C6:  IORWF  x38,F
05C8:  SWAPF  x31,W
05CA:  MOVWF  00
05CC:  RLCF   00,F
05CE:  MOVLW  E0
05D0:  ANDWF  00,F
05D2:  MOVF   00,W
05D4:  IORWF  x38,F
05D6:  SWAPF  x32,W
05D8:  MOVWF  00
05DA:  MOVLW  F0
05DC:  ANDWF  00,F
05DE:  MOVF   00,W
05E0:  IORWF  x38,F
05E2:  RLCF   x33,W
05E4:  MOVWF  00
05E6:  RLCF   00,F
05E8:  RLCF   00,F
05EA:  MOVLW  F8
05EC:  ANDWF  00,F
05EE:  MOVF   00,W
05F0:  IORWF  x38,F
05F2:  RLCF   x34,W
05F4:  MOVWF  00
05F6:  RLCF   00,F
05F8:  MOVLW  FC
05FA:  ANDWF  00,F
05FC:  MOVF   00,W
05FE:  IORWF  x38,F
0600:  BCF    FD8.0
0602:  RLCF   x35,W
0604:  IORWF  x38,F
0606:  MOVF   x36,W
0608:  IORWF  x38,W
060A:  MOVWF  x37
....................    return temp; 
060C:  MOVFF  B37,01
.................... } 
0610:  MOVLB  0
0612:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0614:  MOVLB  B
0616:  CLRF   x1F
....................    int8 temp=0; 
....................    if(direct==0) 
0618:  MOVF   x1A,F
061A:  BNZ   06F0
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
061C:  MOVF   x1D,W
061E:  ADDWF  x1B,W
0620:  MOVWF  FE9
0622:  MOVF   x1E,W
0624:  ADDWFC x1C,W
0626:  MOVWF  FEA
0628:  MOVFF  FEF,B20
062C:  MOVLW  01
062E:  ADDWF  x1B,W
0630:  MOVWF  x21
0632:  MOVLW  00
0634:  ADDWFC x1C,W
0636:  MOVWF  x22
0638:  MOVF   x1D,W
063A:  ADDWF  x21,W
063C:  MOVWF  FE9
063E:  MOVF   x1E,W
0640:  ADDWFC x22,W
0642:  MOVWF  FEA
0644:  MOVF   FEF,W
0646:  XORWF  x20,F
0648:  MOVLW  02
064A:  ADDWF  x1B,W
064C:  MOVWF  x23
064E:  MOVLW  00
0650:  ADDWFC x1C,W
0652:  MOVWF  x24
0654:  MOVF   x1D,W
0656:  ADDWF  x23,W
0658:  MOVWF  FE9
065A:  MOVF   x1E,W
065C:  ADDWFC x24,W
065E:  MOVWF  FEA
0660:  MOVF   FEF,W
0662:  XORWF  x20,F
0664:  MOVLW  03
0666:  ADDWF  x1B,W
0668:  MOVWF  x25
066A:  MOVLW  00
066C:  ADDWFC x1C,W
066E:  MOVWF  x26
0670:  MOVF   x1D,W
0672:  ADDWF  x25,W
0674:  MOVWF  FE9
0676:  MOVF   x1E,W
0678:  ADDWFC x26,W
067A:  MOVWF  FEA
067C:  MOVF   FEF,W
067E:  XORWF  x20,F
0680:  MOVLW  04
0682:  ADDWF  x1B,W
0684:  MOVWF  x27
0686:  MOVLW  00
0688:  ADDWFC x1C,W
068A:  MOVWF  x28
068C:  MOVF   x1D,W
068E:  ADDWF  x27,W
0690:  MOVWF  FE9
0692:  MOVF   x1E,W
0694:  ADDWFC x28,W
0696:  MOVWF  FEA
0698:  MOVF   FEF,W
069A:  XORWF  x20,F
069C:  MOVLW  05
069E:  ADDWF  x1B,W
06A0:  MOVWF  x29
06A2:  MOVLW  00
06A4:  ADDWFC x1C,W
06A6:  MOVWF  x2A
06A8:  MOVF   x1D,W
06AA:  ADDWF  x29,W
06AC:  MOVWF  FE9
06AE:  MOVF   x1E,W
06B0:  ADDWFC x2A,W
06B2:  MOVWF  FEA
06B4:  MOVF   FEF,W
06B6:  XORWF  x20,W
06B8:  BZ    06BE
06BA:  MOVLW  00
06BC:  BRA    06C0
06BE:  MOVLW  01
06C0:  MOVWF  x1F
....................       if(temp==datain[offset+6]) return 1; 
06C2:  MOVLW  06
06C4:  ADDWF  x1B,W
06C6:  MOVWF  x20
06C8:  MOVLW  00
06CA:  ADDWFC x1C,W
06CC:  MOVWF  x21
06CE:  MOVF   x1D,W
06D0:  ADDWF  x20,W
06D2:  MOVWF  FE9
06D4:  MOVF   x1E,W
06D6:  ADDWFC x21,W
06D8:  MOVWF  FEA
06DA:  MOVF   FEF,W
06DC:  SUBWF  x1F,W
06DE:  BNZ   06E8
06E0:  MOVLW  01
06E2:  MOVWF  01
06E4:  BRA    07C0
....................          else return 0; 
06E6:  BRA    06EE
06E8:  MOVLW  00
06EA:  MOVWF  01
06EC:  BRA    07C0
....................    } 
....................       else  
06EE:  BRA    07C0
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
06F0:  MOVF   x1D,W
06F2:  ADDWF  x1B,W
06F4:  MOVWF  FE9
06F6:  MOVF   x1E,W
06F8:  ADDWFC x1C,W
06FA:  MOVWF  FEA
06FC:  MOVFF  FEF,B20
0700:  MOVLW  01
0702:  SUBWF  x1B,W
0704:  MOVWF  x21
0706:  MOVLW  00
0708:  SUBWFB x1C,W
070A:  MOVWF  x22
070C:  MOVF   x1D,W
070E:  ADDWF  x21,W
0710:  MOVWF  FE9
0712:  MOVF   x1E,W
0714:  ADDWFC x22,W
0716:  MOVWF  FEA
0718:  MOVF   FEF,W
071A:  XORWF  x20,F
071C:  MOVLW  02
071E:  SUBWF  x1B,W
0720:  MOVWF  x23
0722:  MOVLW  00
0724:  SUBWFB x1C,W
0726:  MOVWF  x24
0728:  MOVF   x1D,W
072A:  ADDWF  x23,W
072C:  MOVWF  FE9
072E:  MOVF   x1E,W
0730:  ADDWFC x24,W
0732:  MOVWF  FEA
0734:  MOVF   FEF,W
0736:  XORWF  x20,F
0738:  MOVLW  03
073A:  SUBWF  x1B,W
073C:  MOVWF  x25
073E:  MOVLW  00
0740:  SUBWFB x1C,W
0742:  MOVWF  x26
0744:  MOVF   x1D,W
0746:  ADDWF  x25,W
0748:  MOVWF  FE9
074A:  MOVF   x1E,W
074C:  ADDWFC x26,W
074E:  MOVWF  FEA
0750:  MOVF   FEF,W
0752:  XORWF  x20,F
0754:  MOVLW  04
0756:  SUBWF  x1B,W
0758:  MOVWF  x27
075A:  MOVLW  00
075C:  SUBWFB x1C,W
075E:  MOVWF  x28
0760:  MOVF   x1D,W
0762:  ADDWF  x27,W
0764:  MOVWF  FE9
0766:  MOVF   x1E,W
0768:  ADDWFC x28,W
076A:  MOVWF  FEA
076C:  MOVF   FEF,W
076E:  XORWF  x20,F
0770:  MOVLW  05
0772:  SUBWF  x1B,W
0774:  MOVWF  x29
0776:  MOVLW  00
0778:  SUBWFB x1C,W
077A:  MOVWF  x2A
077C:  MOVF   x1D,W
077E:  ADDWF  x29,W
0780:  MOVWF  FE9
0782:  MOVF   x1E,W
0784:  ADDWFC x2A,W
0786:  MOVWF  FEA
0788:  MOVF   FEF,W
078A:  XORWF  x20,W
078C:  BZ    0792
078E:  MOVLW  00
0790:  BRA    0794
0792:  MOVLW  01
0794:  MOVWF  x1F
....................          if(temp==datain[offset-6]) return 1; 
0796:  MOVLW  06
0798:  SUBWF  x1B,W
079A:  MOVWF  x20
079C:  MOVLW  00
079E:  SUBWFB x1C,W
07A0:  MOVWF  x21
07A2:  MOVF   x1D,W
07A4:  ADDWF  x20,W
07A6:  MOVWF  FE9
07A8:  MOVF   x1E,W
07AA:  ADDWFC x21,W
07AC:  MOVWF  FEA
07AE:  MOVF   FEF,W
07B0:  SUBWF  x1F,W
07B2:  BNZ   07BC
07B4:  MOVLW  01
07B6:  MOVWF  01
07B8:  BRA    07C0
....................             else return 0;          
07BA:  BRA    07C0
07BC:  MOVLW  00
07BE:  MOVWF  01
....................       } 
.................... } 
07C0:  MOVLB  0
07C2:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
07C4:  MOVLB  B
07C6:  CLRF   x1F
....................    int8 temp=0; 
....................    if(direct==0) 
07C8:  MOVF   x1A,F
07CA:  BNZ   0868
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
07CC:  MOVF   x1D,W
07CE:  ADDWF  x1B,W
07D0:  MOVWF  FE9
07D2:  MOVF   x1E,W
07D4:  ADDWFC x1C,W
07D6:  MOVWF  FEA
07D8:  MOVFF  FEF,B20
07DC:  MOVLW  01
07DE:  ADDWF  x1B,W
07E0:  MOVWF  x21
07E2:  MOVLW  00
07E4:  ADDWFC x1C,W
07E6:  MOVWF  x22
07E8:  MOVF   x1D,W
07EA:  ADDWF  x21,W
07EC:  MOVWF  FE9
07EE:  MOVF   x1E,W
07F0:  ADDWFC x22,W
07F2:  MOVWF  FEA
07F4:  MOVF   FEF,W
07F6:  XORWF  x20,F
07F8:  MOVLW  02
07FA:  ADDWF  x1B,W
07FC:  MOVWF  x23
07FE:  MOVLW  00
0800:  ADDWFC x1C,W
0802:  MOVWF  x24
0804:  MOVF   x1D,W
0806:  ADDWF  x23,W
0808:  MOVWF  FE9
080A:  MOVF   x1E,W
080C:  ADDWFC x24,W
080E:  MOVWF  FEA
0810:  MOVF   FEF,W
0812:  XORWF  x20,F
0814:  MOVLW  03
0816:  ADDWF  x1B,W
0818:  MOVWF  x25
081A:  MOVLW  00
081C:  ADDWFC x1C,W
081E:  MOVWF  x26
0820:  MOVF   x1D,W
0822:  ADDWF  x25,W
0824:  MOVWF  FE9
0826:  MOVF   x1E,W
0828:  ADDWFC x26,W
082A:  MOVWF  FEA
082C:  MOVF   FEF,W
082E:  XORWF  x20,W
0830:  BZ    0836
0832:  MOVLW  00
0834:  BRA    0838
0836:  MOVLW  01
0838:  MOVWF  x1F
....................       if(temp==datain[offset+4]) return 1; 
083A:  MOVLW  04
083C:  ADDWF  x1B,W
083E:  MOVWF  x20
0840:  MOVLW  00
0842:  ADDWFC x1C,W
0844:  MOVWF  x21
0846:  MOVF   x1D,W
0848:  ADDWF  x20,W
084A:  MOVWF  FE9
084C:  MOVF   x1E,W
084E:  ADDWFC x21,W
0850:  MOVWF  FEA
0852:  MOVF   FEF,W
0854:  SUBWF  x1F,W
0856:  BNZ   0860
0858:  MOVLW  01
085A:  MOVWF  01
085C:  BRA    0900
....................          else return 0; 
085E:  BRA    0866
0860:  MOVLW  00
0862:  MOVWF  01
0864:  BRA    0900
....................    } 
....................    else 
0866:  BRA    0900
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0868:  MOVF   x1D,W
086A:  ADDWF  x1B,W
086C:  MOVWF  FE9
086E:  MOVF   x1E,W
0870:  ADDWFC x1C,W
0872:  MOVWF  FEA
0874:  MOVFF  FEF,B20
0878:  MOVLW  01
087A:  SUBWF  x1B,W
087C:  MOVWF  x21
087E:  MOVLW  00
0880:  SUBWFB x1C,W
0882:  MOVWF  x22
0884:  MOVF   x1D,W
0886:  ADDWF  x21,W
0888:  MOVWF  FE9
088A:  MOVF   x1E,W
088C:  ADDWFC x22,W
088E:  MOVWF  FEA
0890:  MOVF   FEF,W
0892:  XORWF  x20,F
0894:  MOVLW  02
0896:  SUBWF  x1B,W
0898:  MOVWF  x23
089A:  MOVLW  00
089C:  SUBWFB x1C,W
089E:  MOVWF  x24
08A0:  MOVF   x1D,W
08A2:  ADDWF  x23,W
08A4:  MOVWF  FE9
08A6:  MOVF   x1E,W
08A8:  ADDWFC x24,W
08AA:  MOVWF  FEA
08AC:  MOVF   FEF,W
08AE:  XORWF  x20,F
08B0:  MOVLW  03
08B2:  SUBWF  x1B,W
08B4:  MOVWF  x25
08B6:  MOVLW  00
08B8:  SUBWFB x1C,W
08BA:  MOVWF  x26
08BC:  MOVF   x1D,W
08BE:  ADDWF  x25,W
08C0:  MOVWF  FE9
08C2:  MOVF   x1E,W
08C4:  ADDWFC x26,W
08C6:  MOVWF  FEA
08C8:  MOVF   FEF,W
08CA:  XORWF  x20,W
08CC:  BZ    08D2
08CE:  MOVLW  00
08D0:  BRA    08D4
08D2:  MOVLW  01
08D4:  MOVWF  x1F
....................       if(temp==datain[offset-4]) return 1; 
08D6:  MOVLW  04
08D8:  SUBWF  x1B,W
08DA:  MOVWF  x20
08DC:  MOVLW  00
08DE:  SUBWFB x1C,W
08E0:  MOVWF  x21
08E2:  MOVF   x1D,W
08E4:  ADDWF  x20,W
08E6:  MOVWF  FE9
08E8:  MOVF   x1E,W
08EA:  ADDWFC x21,W
08EC:  MOVWF  FEA
08EE:  MOVF   FEF,W
08F0:  SUBWF  x1F,W
08F2:  BNZ   08FC
08F4:  MOVLW  01
08F6:  MOVWF  01
08F8:  BRA    0900
....................          else return 0;                
08FA:  BRA    0900
08FC:  MOVLW  00
08FE:  MOVWF  01
....................    } 
.................... } 
0900:  MOVLB  0
0902:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0904:  MOVLB  A
0906:  CLRF   xFC
0908:  CLRF   xFD
090A:  CLRF   xFE
090C:  CLRF   xFF
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
090E:  CLRF   xF9
0910:  CLRF   xF8
0912:  RRCF   xF5,W
0914:  MOVWF  03
0916:  RRCF   xF4,W
0918:  MOVWF  02
091A:  RRCF   03,F
091C:  RRCF   02,F
091E:  MOVLW  3F
0920:  ANDWF  03,F
0922:  MOVFF  02,01
0926:  MOVF   xF9,W
0928:  SUBWF  03,W
092A:  BTFSS  FD8.0
092C:  GOTO   1104
0930:  BNZ   093C
0932:  MOVF   01,W
0934:  SUBWF  xF8,W
0936:  BTFSC  FD8.0
0938:  GOTO   1104
....................    { 
....................       if(track==0) 
093C:  MOVF   xF3,F
093E:  BTFSS  FD8.2
0940:  BRA    0DAA
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0942:  MOVLW  06
0944:  ADDWF  xF8,W
0946:  MOVLB  B
0948:  MOVWF  x00
094A:  MOVLW  00
094C:  MOVLB  A
094E:  ADDWFC xF9,W
0950:  MOVLB  B
0952:  MOVWF  x01
0954:  MOVLB  A
0956:  MOVF   xF6,W
0958:  MOVLB  B
095A:  ADDWF  x00,W
095C:  MOVWF  FE9
095E:  MOVLB  A
0960:  MOVF   xF7,W
0962:  MOVLB  B
0964:  ADDWFC x01,W
0966:  MOVWF  FEA
0968:  MOVFF  FEF,B02
096C:  MOVLW  05
096E:  MOVLB  A
0970:  ADDWF  xF8,W
0972:  MOVLB  B
0974:  MOVWF  x03
0976:  MOVLW  00
0978:  MOVLB  A
097A:  ADDWFC xF9,W
097C:  MOVLB  B
097E:  MOVWF  x04
0980:  MOVLB  A
0982:  MOVF   xF6,W
0984:  MOVLB  B
0986:  ADDWF  x03,W
0988:  MOVWF  FE9
098A:  MOVLB  A
098C:  MOVF   xF7,W
098E:  MOVLB  B
0990:  ADDWFC x04,W
0992:  MOVWF  FEA
0994:  MOVFF  FEF,B05
0998:  MOVLW  04
099A:  MOVLB  A
099C:  ADDWF  xF8,W
099E:  MOVLB  B
09A0:  MOVWF  x06
09A2:  MOVLW  00
09A4:  MOVLB  A
09A6:  ADDWFC xF9,W
09A8:  MOVLB  B
09AA:  MOVWF  x07
09AC:  MOVLB  A
09AE:  MOVF   xF6,W
09B0:  MOVLB  B
09B2:  ADDWF  x06,W
09B4:  MOVWF  FE9
09B6:  MOVLB  A
09B8:  MOVF   xF7,W
09BA:  MOVLB  B
09BC:  ADDWFC x07,W
09BE:  MOVWF  FEA
09C0:  MOVFF  FEF,B08
09C4:  MOVLW  03
09C6:  MOVLB  A
09C8:  ADDWF  xF8,W
09CA:  MOVLB  B
09CC:  MOVWF  x09
09CE:  MOVLW  00
09D0:  MOVLB  A
09D2:  ADDWFC xF9,W
09D4:  MOVLB  B
09D6:  MOVWF  x0A
09D8:  MOVLB  A
09DA:  MOVF   xF6,W
09DC:  MOVLB  B
09DE:  ADDWF  x09,W
09E0:  MOVWF  FE9
09E2:  MOVLB  A
09E4:  MOVF   xF7,W
09E6:  MOVLB  B
09E8:  ADDWFC x0A,W
09EA:  MOVWF  FEA
09EC:  MOVFF  FEF,B0B
09F0:  MOVLW  02
09F2:  MOVLB  A
09F4:  ADDWF  xF8,W
09F6:  MOVLB  B
09F8:  MOVWF  x0C
09FA:  MOVLW  00
09FC:  MOVLB  A
09FE:  ADDWFC xF9,W
0A00:  MOVLB  B
0A02:  MOVWF  x0D
0A04:  MOVLB  A
0A06:  MOVF   xF6,W
0A08:  MOVLB  B
0A0A:  ADDWF  x0C,W
0A0C:  MOVWF  FE9
0A0E:  MOVLB  A
0A10:  MOVF   xF7,W
0A12:  MOVLB  B
0A14:  ADDWFC x0D,W
0A16:  MOVWF  FEA
0A18:  MOVFF  FEF,B0E
0A1C:  MOVLW  01
0A1E:  MOVLB  A
0A20:  ADDWF  xF8,W
0A22:  MOVLB  B
0A24:  MOVWF  x0F
0A26:  MOVLW  00
0A28:  MOVLB  A
0A2A:  ADDWFC xF9,W
0A2C:  MOVLB  B
0A2E:  MOVWF  x10
0A30:  MOVLB  A
0A32:  MOVF   xF6,W
0A34:  MOVLB  B
0A36:  ADDWF  x0F,W
0A38:  MOVWF  FE9
0A3A:  MOVLB  A
0A3C:  MOVF   xF7,W
0A3E:  MOVLB  B
0A40:  ADDWFC x10,W
0A42:  MOVWF  FEA
0A44:  MOVFF  FEF,B11
0A48:  MOVLB  A
0A4A:  MOVF   xF6,W
0A4C:  ADDWF  xF8,W
0A4E:  MOVWF  FE9
0A50:  MOVF   xF7,W
0A52:  ADDWFC xF9,W
0A54:  MOVWF  FEA
0A56:  MOVFF  FEF,B12
0A5A:  MOVLB  B
0A5C:  CLRF   x2F
0A5E:  MOVFF  B02,B30
0A62:  MOVFF  B05,B31
0A66:  MOVFF  B08,B32
0A6A:  MOVFF  B0B,B33
0A6E:  MOVFF  B0E,B34
0A72:  MOVFF  B11,B35
0A76:  MOVFF  B12,B36
0A7A:  MOVLB  0
0A7C:  RCALL  05AE
0A7E:  MOVFF  01,AFC
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0A82:  MOVLW  0D
0A84:  MOVLB  A
0A86:  ADDWF  xF8,W
0A88:  MOVLB  B
0A8A:  MOVWF  x00
0A8C:  MOVLW  00
0A8E:  MOVLB  A
0A90:  ADDWFC xF9,W
0A92:  MOVLB  B
0A94:  MOVWF  x01
0A96:  MOVLB  A
0A98:  MOVF   xF6,W
0A9A:  MOVLB  B
0A9C:  ADDWF  x00,W
0A9E:  MOVWF  FE9
0AA0:  MOVLB  A
0AA2:  MOVF   xF7,W
0AA4:  MOVLB  B
0AA6:  ADDWFC x01,W
0AA8:  MOVWF  FEA
0AAA:  MOVFF  FEF,B02
0AAE:  MOVLW  0C
0AB0:  MOVLB  A
0AB2:  ADDWF  xF8,W
0AB4:  MOVLB  B
0AB6:  MOVWF  x03
0AB8:  MOVLW  00
0ABA:  MOVLB  A
0ABC:  ADDWFC xF9,W
0ABE:  MOVLB  B
0AC0:  MOVWF  x04
0AC2:  MOVLB  A
0AC4:  MOVF   xF6,W
0AC6:  MOVLB  B
0AC8:  ADDWF  x03,W
0ACA:  MOVWF  FE9
0ACC:  MOVLB  A
0ACE:  MOVF   xF7,W
0AD0:  MOVLB  B
0AD2:  ADDWFC x04,W
0AD4:  MOVWF  FEA
0AD6:  MOVFF  FEF,B05
0ADA:  MOVLW  0B
0ADC:  MOVLB  A
0ADE:  ADDWF  xF8,W
0AE0:  MOVLB  B
0AE2:  MOVWF  x06
0AE4:  MOVLW  00
0AE6:  MOVLB  A
0AE8:  ADDWFC xF9,W
0AEA:  MOVLB  B
0AEC:  MOVWF  x07
0AEE:  MOVLB  A
0AF0:  MOVF   xF6,W
0AF2:  MOVLB  B
0AF4:  ADDWF  x06,W
0AF6:  MOVWF  FE9
0AF8:  MOVLB  A
0AFA:  MOVF   xF7,W
0AFC:  MOVLB  B
0AFE:  ADDWFC x07,W
0B00:  MOVWF  FEA
0B02:  MOVFF  FEF,B08
0B06:  MOVLW  0A
0B08:  MOVLB  A
0B0A:  ADDWF  xF8,W
0B0C:  MOVLB  B
0B0E:  MOVWF  x09
0B10:  MOVLW  00
0B12:  MOVLB  A
0B14:  ADDWFC xF9,W
0B16:  MOVLB  B
0B18:  MOVWF  x0A
0B1A:  MOVLB  A
0B1C:  MOVF   xF6,W
0B1E:  MOVLB  B
0B20:  ADDWF  x09,W
0B22:  MOVWF  FE9
0B24:  MOVLB  A
0B26:  MOVF   xF7,W
0B28:  MOVLB  B
0B2A:  ADDWFC x0A,W
0B2C:  MOVWF  FEA
0B2E:  MOVFF  FEF,B0B
0B32:  MOVLW  09
0B34:  MOVLB  A
0B36:  ADDWF  xF8,W
0B38:  MOVLB  B
0B3A:  MOVWF  x0C
0B3C:  MOVLW  00
0B3E:  MOVLB  A
0B40:  ADDWFC xF9,W
0B42:  MOVLB  B
0B44:  MOVWF  x0D
0B46:  MOVLB  A
0B48:  MOVF   xF6,W
0B4A:  MOVLB  B
0B4C:  ADDWF  x0C,W
0B4E:  MOVWF  FE9
0B50:  MOVLB  A
0B52:  MOVF   xF7,W
0B54:  MOVLB  B
0B56:  ADDWFC x0D,W
0B58:  MOVWF  FEA
0B5A:  MOVFF  FEF,B0E
0B5E:  MOVLW  08
0B60:  MOVLB  A
0B62:  ADDWF  xF8,W
0B64:  MOVLB  B
0B66:  MOVWF  x0F
0B68:  MOVLW  00
0B6A:  MOVLB  A
0B6C:  ADDWFC xF9,W
0B6E:  MOVLB  B
0B70:  MOVWF  x10
0B72:  MOVLB  A
0B74:  MOVF   xF6,W
0B76:  MOVLB  B
0B78:  ADDWF  x0F,W
0B7A:  MOVWF  FE9
0B7C:  MOVLB  A
0B7E:  MOVF   xF7,W
0B80:  MOVLB  B
0B82:  ADDWFC x10,W
0B84:  MOVWF  FEA
0B86:  MOVFF  FEF,B11
0B8A:  MOVLW  07
0B8C:  MOVLB  A
0B8E:  ADDWF  xF8,W
0B90:  MOVLB  B
0B92:  MOVWF  x12
0B94:  MOVLW  00
0B96:  MOVLB  A
0B98:  ADDWFC xF9,W
0B9A:  MOVLB  B
0B9C:  MOVWF  x13
0B9E:  MOVLB  A
0BA0:  MOVF   xF6,W
0BA2:  MOVLB  B
0BA4:  ADDWF  x12,W
0BA6:  MOVWF  FE9
0BA8:  MOVLB  A
0BAA:  MOVF   xF7,W
0BAC:  MOVLB  B
0BAE:  ADDWFC x13,W
0BB0:  MOVWF  FEA
0BB2:  MOVFF  FEF,B14
0BB6:  CLRF   x2F
0BB8:  MOVFF  B02,B30
0BBC:  MOVFF  B05,B31
0BC0:  MOVFF  B08,B32
0BC4:  MOVFF  B0B,B33
0BC8:  MOVFF  B0E,B34
0BCC:  MOVFF  B11,B35
0BD0:  MOVFF  B14,B36
0BD4:  MOVLB  0
0BD6:  RCALL  05AE
0BD8:  MOVFF  01,AFD
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0BDC:  MOVLB  A
0BDE:  MOVF   xFC,W
0BE0:  SUBLW  45
0BE2:  BTFSS  FD8.2
0BE4:  BRA    0DA8
0BE6:  MOVF   xFD,W
0BE8:  SUBLW  7C
0BEA:  BTFSC  FD8.2
0BEC:  BRA    0DA8
0BEE:  MOVF   xFD,W
0BF0:  SUBLW  3E
0BF2:  BTFSC  FD8.2
0BF4:  BRA    0DA8
0BF6:  MOVF   xFD,W
0BF8:  SUBLW  1F
0BFA:  BTFSC  FD8.2
0BFC:  BRA    0DA8
....................          { 
....................             j=i; 
0BFE:  MOVFF  AF9,AFB
0C02:  MOVFF  AF8,AFA
....................             CRC=1; 
0C06:  MOVLW  01
0C08:  MOVWF  xFF
....................             temp2=temp; 
0C0A:  MOVFF  AFC,AFE
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0C0E:  MOVF   xFE,W
0C10:  SUBLW  1F
0C12:  BTFSC  FD8.2
0C14:  BRA    0D92
0C16:  MOVF   xFB,W
0C18:  SUBLW  03
0C1A:  BTFSS  FD8.0
0C1C:  BRA    0D92
0C1E:  BNZ   0C28
0C20:  MOVF   xFA,W
0C22:  SUBLW  E7
0C24:  BTFSS  FD8.0
0C26:  BRA    0D92
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0C28:  MOVLB  B
0C2A:  CLRF   x1A
0C2C:  MOVFF  AFB,B1C
0C30:  MOVFF  AFA,B1B
0C34:  MOVFF  AF7,B1E
0C38:  MOVFF  AF6,B1D
0C3C:  MOVLB  0
0C3E:  RCALL  0614
0C40:  MOVF   01,W
0C42:  MOVLB  A
0C44:  ANDWF  xFF,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0C46:  MOVLW  06
0C48:  ADDWF  xFA,W
0C4A:  MOVLB  B
0C4C:  MOVWF  x00
0C4E:  MOVLW  00
0C50:  MOVLB  A
0C52:  ADDWFC xFB,W
0C54:  MOVLB  B
0C56:  MOVWF  x01
0C58:  MOVLB  A
0C5A:  MOVF   xF6,W
0C5C:  MOVLB  B
0C5E:  ADDWF  x00,W
0C60:  MOVWF  FE9
0C62:  MOVLB  A
0C64:  MOVF   xF7,W
0C66:  MOVLB  B
0C68:  ADDWFC x01,W
0C6A:  MOVWF  FEA
0C6C:  MOVFF  FEF,B02
0C70:  MOVLW  05
0C72:  MOVLB  A
0C74:  ADDWF  xFA,W
0C76:  MOVLB  B
0C78:  MOVWF  x03
0C7A:  MOVLW  00
0C7C:  MOVLB  A
0C7E:  ADDWFC xFB,W
0C80:  MOVLB  B
0C82:  MOVWF  x04
0C84:  MOVLB  A
0C86:  MOVF   xF6,W
0C88:  MOVLB  B
0C8A:  ADDWF  x03,W
0C8C:  MOVWF  FE9
0C8E:  MOVLB  A
0C90:  MOVF   xF7,W
0C92:  MOVLB  B
0C94:  ADDWFC x04,W
0C96:  MOVWF  FEA
0C98:  MOVFF  FEF,B05
0C9C:  MOVLW  04
0C9E:  MOVLB  A
0CA0:  ADDWF  xFA,W
0CA2:  MOVLB  B
0CA4:  MOVWF  x06
0CA6:  MOVLW  00
0CA8:  MOVLB  A
0CAA:  ADDWFC xFB,W
0CAC:  MOVLB  B
0CAE:  MOVWF  x07
0CB0:  MOVLB  A
0CB2:  MOVF   xF6,W
0CB4:  MOVLB  B
0CB6:  ADDWF  x06,W
0CB8:  MOVWF  FE9
0CBA:  MOVLB  A
0CBC:  MOVF   xF7,W
0CBE:  MOVLB  B
0CC0:  ADDWFC x07,W
0CC2:  MOVWF  FEA
0CC4:  MOVFF  FEF,B08
0CC8:  MOVLW  03
0CCA:  MOVLB  A
0CCC:  ADDWF  xFA,W
0CCE:  MOVLB  B
0CD0:  MOVWF  x09
0CD2:  MOVLW  00
0CD4:  MOVLB  A
0CD6:  ADDWFC xFB,W
0CD8:  MOVLB  B
0CDA:  MOVWF  x0A
0CDC:  MOVLB  A
0CDE:  MOVF   xF6,W
0CE0:  MOVLB  B
0CE2:  ADDWF  x09,W
0CE4:  MOVWF  FE9
0CE6:  MOVLB  A
0CE8:  MOVF   xF7,W
0CEA:  MOVLB  B
0CEC:  ADDWFC x0A,W
0CEE:  MOVWF  FEA
0CF0:  MOVFF  FEF,B0B
0CF4:  MOVLW  02
0CF6:  MOVLB  A
0CF8:  ADDWF  xFA,W
0CFA:  MOVLB  B
0CFC:  MOVWF  x0C
0CFE:  MOVLW  00
0D00:  MOVLB  A
0D02:  ADDWFC xFB,W
0D04:  MOVLB  B
0D06:  MOVWF  x0D
0D08:  MOVLB  A
0D0A:  MOVF   xF6,W
0D0C:  MOVLB  B
0D0E:  ADDWF  x0C,W
0D10:  MOVWF  FE9
0D12:  MOVLB  A
0D14:  MOVF   xF7,W
0D16:  MOVLB  B
0D18:  ADDWFC x0D,W
0D1A:  MOVWF  FEA
0D1C:  MOVFF  FEF,B0E
0D20:  MOVLW  01
0D22:  MOVLB  A
0D24:  ADDWF  xFA,W
0D26:  MOVLB  B
0D28:  MOVWF  x0F
0D2A:  MOVLW  00
0D2C:  MOVLB  A
0D2E:  ADDWFC xFB,W
0D30:  MOVLB  B
0D32:  MOVWF  x10
0D34:  MOVLB  A
0D36:  MOVF   xF6,W
0D38:  MOVLB  B
0D3A:  ADDWF  x0F,W
0D3C:  MOVWF  FE9
0D3E:  MOVLB  A
0D40:  MOVF   xF7,W
0D42:  MOVLB  B
0D44:  ADDWFC x10,W
0D46:  MOVWF  FEA
0D48:  MOVFF  FEF,B11
0D4C:  MOVLB  A
0D4E:  MOVF   xF6,W
0D50:  ADDWF  xFA,W
0D52:  MOVWF  FE9
0D54:  MOVF   xF7,W
0D56:  ADDWFC xFB,W
0D58:  MOVWF  FEA
0D5A:  MOVFF  FEF,B12
0D5E:  MOVLB  B
0D60:  CLRF   x2F
0D62:  MOVFF  B02,B30
0D66:  MOVFF  B05,B31
0D6A:  MOVFF  B08,B32
0D6E:  MOVFF  B0B,B33
0D72:  MOVFF  B0E,B34
0D76:  MOVFF  B11,B35
0D7A:  MOVFF  B12,B36
0D7E:  MOVLB  0
0D80:  RCALL  05AE
0D82:  MOVFF  01,AFE
....................                j=j+7; 
0D86:  MOVLW  07
0D88:  MOVLB  A
0D8A:  ADDWF  xFA,F
0D8C:  MOVLW  00
0D8E:  ADDWFC xFB,F
....................             } 
0D90:  BRA    0C0E
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0D92:  DECFSZ xFF,W
0D94:  BRA    0DA8
....................             { 
....................                dir=0; 
0D96:  MOVLB  9
0D98:  CLRF   x90
....................                return i; 
0D9A:  MOVLB  A
0D9C:  MOVFF  AF8,01
0DA0:  MOVFF  AF9,02
0DA4:  GOTO   192C
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0DA8:  BRA    10FC
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0DAA:  MOVLW  04
0DAC:  ADDWF  xF8,W
0DAE:  MOVLB  B
0DB0:  MOVWF  x00
0DB2:  MOVLW  00
0DB4:  MOVLB  A
0DB6:  ADDWFC xF9,W
0DB8:  MOVLB  B
0DBA:  MOVWF  x01
0DBC:  MOVLB  A
0DBE:  MOVF   xF6,W
0DC0:  MOVLB  B
0DC2:  ADDWF  x00,W
0DC4:  MOVWF  FE9
0DC6:  MOVLB  A
0DC8:  MOVF   xF7,W
0DCA:  MOVLB  B
0DCC:  ADDWFC x01,W
0DCE:  MOVWF  FEA
0DD0:  MOVFF  FEF,B02
0DD4:  MOVLW  03
0DD6:  MOVLB  A
0DD8:  ADDWF  xF8,W
0DDA:  MOVLB  B
0DDC:  MOVWF  x03
0DDE:  MOVLW  00
0DE0:  MOVLB  A
0DE2:  ADDWFC xF9,W
0DE4:  MOVLB  B
0DE6:  MOVWF  x04
0DE8:  MOVLB  A
0DEA:  MOVF   xF6,W
0DEC:  MOVLB  B
0DEE:  ADDWF  x03,W
0DF0:  MOVWF  FE9
0DF2:  MOVLB  A
0DF4:  MOVF   xF7,W
0DF6:  MOVLB  B
0DF8:  ADDWFC x04,W
0DFA:  MOVWF  FEA
0DFC:  MOVFF  FEF,B05
0E00:  MOVLW  02
0E02:  MOVLB  A
0E04:  ADDWF  xF8,W
0E06:  MOVLB  B
0E08:  MOVWF  x06
0E0A:  MOVLW  00
0E0C:  MOVLB  A
0E0E:  ADDWFC xF9,W
0E10:  MOVLB  B
0E12:  MOVWF  x07
0E14:  MOVLB  A
0E16:  MOVF   xF6,W
0E18:  MOVLB  B
0E1A:  ADDWF  x06,W
0E1C:  MOVWF  FE9
0E1E:  MOVLB  A
0E20:  MOVF   xF7,W
0E22:  MOVLB  B
0E24:  ADDWFC x07,W
0E26:  MOVWF  FEA
0E28:  MOVFF  FEF,B08
0E2C:  MOVLW  01
0E2E:  MOVLB  A
0E30:  ADDWF  xF8,W
0E32:  MOVLB  B
0E34:  MOVWF  x09
0E36:  MOVLW  00
0E38:  MOVLB  A
0E3A:  ADDWFC xF9,W
0E3C:  MOVLB  B
0E3E:  MOVWF  x0A
0E40:  MOVLB  A
0E42:  MOVF   xF6,W
0E44:  MOVLB  B
0E46:  ADDWF  x09,W
0E48:  MOVWF  FE9
0E4A:  MOVLB  A
0E4C:  MOVF   xF7,W
0E4E:  MOVLB  B
0E50:  ADDWFC x0A,W
0E52:  MOVWF  FEA
0E54:  MOVFF  FEF,B0B
0E58:  MOVLB  A
0E5A:  MOVF   xF6,W
0E5C:  ADDWF  xF8,W
0E5E:  MOVWF  FE9
0E60:  MOVF   xF7,W
0E62:  ADDWFC xF9,W
0E64:  MOVWF  FEA
0E66:  MOVFF  FEF,B0C
0E6A:  MOVLB  B
0E6C:  CLRF   x2F
0E6E:  CLRF   x30
0E70:  CLRF   x31
0E72:  MOVFF  B02,B32
0E76:  MOVFF  B05,B33
0E7A:  MOVFF  B08,B34
0E7E:  MOVFF  B0B,B35
0E82:  MOVFF  B0C,B36
0E86:  MOVLB  0
0E88:  CALL   05AE
0E8C:  MOVFF  01,AFC
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0E90:  MOVLW  09
0E92:  MOVLB  A
0E94:  ADDWF  xF8,W
0E96:  MOVLB  B
0E98:  MOVWF  x00
0E9A:  MOVLW  00
0E9C:  MOVLB  A
0E9E:  ADDWFC xF9,W
0EA0:  MOVLB  B
0EA2:  MOVWF  x01
0EA4:  MOVLB  A
0EA6:  MOVF   xF6,W
0EA8:  MOVLB  B
0EAA:  ADDWF  x00,W
0EAC:  MOVWF  FE9
0EAE:  MOVLB  A
0EB0:  MOVF   xF7,W
0EB2:  MOVLB  B
0EB4:  ADDWFC x01,W
0EB6:  MOVWF  FEA
0EB8:  MOVFF  FEF,B02
0EBC:  MOVLW  08
0EBE:  MOVLB  A
0EC0:  ADDWF  xF8,W
0EC2:  MOVLB  B
0EC4:  MOVWF  x03
0EC6:  MOVLW  00
0EC8:  MOVLB  A
0ECA:  ADDWFC xF9,W
0ECC:  MOVLB  B
0ECE:  MOVWF  x04
0ED0:  MOVLB  A
0ED2:  MOVF   xF6,W
0ED4:  MOVLB  B
0ED6:  ADDWF  x03,W
0ED8:  MOVWF  FE9
0EDA:  MOVLB  A
0EDC:  MOVF   xF7,W
0EDE:  MOVLB  B
0EE0:  ADDWFC x04,W
0EE2:  MOVWF  FEA
0EE4:  MOVFF  FEF,B05
0EE8:  MOVLW  07
0EEA:  MOVLB  A
0EEC:  ADDWF  xF8,W
0EEE:  MOVLB  B
0EF0:  MOVWF  x06
0EF2:  MOVLW  00
0EF4:  MOVLB  A
0EF6:  ADDWFC xF9,W
0EF8:  MOVLB  B
0EFA:  MOVWF  x07
0EFC:  MOVLB  A
0EFE:  MOVF   xF6,W
0F00:  MOVLB  B
0F02:  ADDWF  x06,W
0F04:  MOVWF  FE9
0F06:  MOVLB  A
0F08:  MOVF   xF7,W
0F0A:  MOVLB  B
0F0C:  ADDWFC x07,W
0F0E:  MOVWF  FEA
0F10:  MOVFF  FEF,B08
0F14:  MOVLW  06
0F16:  MOVLB  A
0F18:  ADDWF  xF8,W
0F1A:  MOVLB  B
0F1C:  MOVWF  x09
0F1E:  MOVLW  00
0F20:  MOVLB  A
0F22:  ADDWFC xF9,W
0F24:  MOVLB  B
0F26:  MOVWF  x0A
0F28:  MOVLB  A
0F2A:  MOVF   xF6,W
0F2C:  MOVLB  B
0F2E:  ADDWF  x09,W
0F30:  MOVWF  FE9
0F32:  MOVLB  A
0F34:  MOVF   xF7,W
0F36:  MOVLB  B
0F38:  ADDWFC x0A,W
0F3A:  MOVWF  FEA
0F3C:  MOVFF  FEF,B0B
0F40:  MOVLW  05
0F42:  MOVLB  A
0F44:  ADDWF  xF8,W
0F46:  MOVLB  B
0F48:  MOVWF  x0C
0F4A:  MOVLW  00
0F4C:  MOVLB  A
0F4E:  ADDWFC xF9,W
0F50:  MOVLB  B
0F52:  MOVWF  x0D
0F54:  MOVLB  A
0F56:  MOVF   xF6,W
0F58:  MOVLB  B
0F5A:  ADDWF  x0C,W
0F5C:  MOVWF  FE9
0F5E:  MOVLB  A
0F60:  MOVF   xF7,W
0F62:  MOVLB  B
0F64:  ADDWFC x0D,W
0F66:  MOVWF  FEA
0F68:  MOVFF  FEF,B0E
0F6C:  CLRF   x2F
0F6E:  CLRF   x30
0F70:  CLRF   x31
0F72:  MOVFF  B02,B32
0F76:  MOVFF  B05,B33
0F7A:  MOVFF  B08,B34
0F7E:  MOVFF  B0B,B35
0F82:  MOVFF  B0E,B36
0F86:  MOVLB  0
0F88:  CALL   05AE
0F8C:  MOVFF  01,AFD
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0F90:  MOVLB  A
0F92:  MOVF   xFC,W
0F94:  SUBLW  0B
0F96:  BTFSS  FD8.2
0F98:  BRA    10FC
0F9A:  MOVF   xFD,W
0F9C:  SUBLW  1F
0F9E:  BTFSC  FD8.2
0FA0:  BRA    10FC
0FA2:  MOVF   xFD,W
0FA4:  SUBLW  0F
0FA6:  BTFSC  FD8.2
0FA8:  BRA    10FC
....................             { 
....................                j=i; 
0FAA:  MOVFF  AF9,AFB
0FAE:  MOVFF  AF8,AFA
....................                CRC=1; 
0FB2:  MOVLW  01
0FB4:  MOVWF  xFF
....................                temp2=temp; 
0FB6:  MOVFF  AFC,AFE
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
0FBA:  MOVF   xFE,W
0FBC:  SUBLW  1F
0FBE:  BTFSC  FD8.2
0FC0:  BRA    10E6
0FC2:  MOVF   xFB,W
0FC4:  SUBLW  01
0FC6:  BTFSS  FD8.0
0FC8:  BRA    10E6
0FCA:  BNZ   0FD4
0FCC:  MOVF   xFA,W
0FCE:  SUBLW  F3
0FD0:  BTFSS  FD8.0
0FD2:  BRA    10E6
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
0FD4:  MOVLB  B
0FD6:  CLRF   x1A
0FD8:  MOVFF  AFB,B1C
0FDC:  MOVFF  AFA,B1B
0FE0:  MOVFF  AF7,B1E
0FE4:  MOVFF  AF6,B1D
0FE8:  MOVLB  0
0FEA:  CALL   07C4
0FEE:  MOVF   01,W
0FF0:  MOVLB  A
0FF2:  ANDWF  xFF,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0FF4:  MOVLW  04
0FF6:  ADDWF  xFA,W
0FF8:  MOVLB  B
0FFA:  MOVWF  x00
0FFC:  MOVLW  00
0FFE:  MOVLB  A
1000:  ADDWFC xFB,W
1002:  MOVLB  B
1004:  MOVWF  x01
1006:  MOVLB  A
1008:  MOVF   xF6,W
100A:  MOVLB  B
100C:  ADDWF  x00,W
100E:  MOVWF  FE9
1010:  MOVLB  A
1012:  MOVF   xF7,W
1014:  MOVLB  B
1016:  ADDWFC x01,W
1018:  MOVWF  FEA
101A:  MOVFF  FEF,B02
101E:  MOVLW  03
1020:  MOVLB  A
1022:  ADDWF  xFA,W
1024:  MOVLB  B
1026:  MOVWF  x03
1028:  MOVLW  00
102A:  MOVLB  A
102C:  ADDWFC xFB,W
102E:  MOVLB  B
1030:  MOVWF  x04
1032:  MOVLB  A
1034:  MOVF   xF6,W
1036:  MOVLB  B
1038:  ADDWF  x03,W
103A:  MOVWF  FE9
103C:  MOVLB  A
103E:  MOVF   xF7,W
1040:  MOVLB  B
1042:  ADDWFC x04,W
1044:  MOVWF  FEA
1046:  MOVFF  FEF,B05
104A:  MOVLW  02
104C:  MOVLB  A
104E:  ADDWF  xFA,W
1050:  MOVLB  B
1052:  MOVWF  x06
1054:  MOVLW  00
1056:  MOVLB  A
1058:  ADDWFC xFB,W
105A:  MOVLB  B
105C:  MOVWF  x07
105E:  MOVLB  A
1060:  MOVF   xF6,W
1062:  MOVLB  B
1064:  ADDWF  x06,W
1066:  MOVWF  FE9
1068:  MOVLB  A
106A:  MOVF   xF7,W
106C:  MOVLB  B
106E:  ADDWFC x07,W
1070:  MOVWF  FEA
1072:  MOVFF  FEF,B08
1076:  MOVLW  01
1078:  MOVLB  A
107A:  ADDWF  xFA,W
107C:  MOVLB  B
107E:  MOVWF  x09
1080:  MOVLW  00
1082:  MOVLB  A
1084:  ADDWFC xFB,W
1086:  MOVLB  B
1088:  MOVWF  x0A
108A:  MOVLB  A
108C:  MOVF   xF6,W
108E:  MOVLB  B
1090:  ADDWF  x09,W
1092:  MOVWF  FE9
1094:  MOVLB  A
1096:  MOVF   xF7,W
1098:  MOVLB  B
109A:  ADDWFC x0A,W
109C:  MOVWF  FEA
109E:  MOVFF  FEF,B0B
10A2:  MOVLB  A
10A4:  MOVF   xF6,W
10A6:  ADDWF  xFA,W
10A8:  MOVWF  FE9
10AA:  MOVF   xF7,W
10AC:  ADDWFC xFB,W
10AE:  MOVWF  FEA
10B0:  MOVFF  FEF,B0C
10B4:  MOVLB  B
10B6:  CLRF   x2F
10B8:  CLRF   x30
10BA:  CLRF   x31
10BC:  MOVFF  B02,B32
10C0:  MOVFF  B05,B33
10C4:  MOVFF  B08,B34
10C8:  MOVFF  B0B,B35
10CC:  MOVFF  B0C,B36
10D0:  MOVLB  0
10D2:  CALL   05AE
10D6:  MOVFF  01,AFE
....................                   j=j+5; 
10DA:  MOVLW  05
10DC:  MOVLB  A
10DE:  ADDWF  xFA,F
10E0:  MOVLW  00
10E2:  ADDWFC xFB,F
....................                } 
10E4:  BRA    0FBA
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
10E6:  DECFSZ xFF,W
10E8:  BRA    10FC
....................                { 
....................                   dir=0; 
10EA:  MOVLB  9
10EC:  CLRF   x90
....................                   return i; 
10EE:  MOVLB  A
10F0:  MOVFF  AF8,01
10F4:  MOVFF  AF9,02
10F8:  GOTO   192C
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
10FC:  INCF   xF8,F
10FE:  BTFSC  FD8.2
1100:  INCF   xF9,F
1102:  BRA    0912
....................    for(i=end_point;i>end_point/4;i--) 
1104:  MOVFF  AF5,AF9
1108:  MOVFF  AF4,AF8
110C:  RRCF   xF5,W
110E:  MOVWF  03
1110:  RRCF   xF4,W
1112:  MOVWF  02
1114:  RRCF   03,F
1116:  RRCF   02,F
1118:  MOVLW  3F
111A:  ANDWF  03,F
111C:  MOVFF  02,01
1120:  MOVF   03,W
1122:  SUBWF  xF9,W
1124:  BTFSS  FD8.0
1126:  GOTO   1926
112A:  BNZ   1136
112C:  MOVF   xF8,W
112E:  SUBWF  01,W
1130:  BTFSC  FD8.0
1132:  GOTO   1926
....................    { 
....................       if(track==0) 
1136:  MOVF   xF3,F
1138:  BTFSS  FD8.2
113A:  BRA    15C2
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
113C:  MOVLW  06
113E:  SUBWF  xF8,W
1140:  MOVLB  B
1142:  MOVWF  x00
1144:  MOVLW  00
1146:  MOVLB  A
1148:  SUBWFB xF9,W
114A:  MOVLB  B
114C:  MOVWF  x01
114E:  MOVLB  A
1150:  MOVF   xF6,W
1152:  MOVLB  B
1154:  ADDWF  x00,W
1156:  MOVWF  FE9
1158:  MOVLB  A
115A:  MOVF   xF7,W
115C:  MOVLB  B
115E:  ADDWFC x01,W
1160:  MOVWF  FEA
1162:  MOVFF  FEF,B02
1166:  MOVLW  05
1168:  MOVLB  A
116A:  SUBWF  xF8,W
116C:  MOVLB  B
116E:  MOVWF  x03
1170:  MOVLW  00
1172:  MOVLB  A
1174:  SUBWFB xF9,W
1176:  MOVLB  B
1178:  MOVWF  x04
117A:  MOVLB  A
117C:  MOVF   xF6,W
117E:  MOVLB  B
1180:  ADDWF  x03,W
1182:  MOVWF  FE9
1184:  MOVLB  A
1186:  MOVF   xF7,W
1188:  MOVLB  B
118A:  ADDWFC x04,W
118C:  MOVWF  FEA
118E:  MOVFF  FEF,B05
1192:  MOVLW  04
1194:  MOVLB  A
1196:  SUBWF  xF8,W
1198:  MOVLB  B
119A:  MOVWF  x06
119C:  MOVLW  00
119E:  MOVLB  A
11A0:  SUBWFB xF9,W
11A2:  MOVLB  B
11A4:  MOVWF  x07
11A6:  MOVLB  A
11A8:  MOVF   xF6,W
11AA:  MOVLB  B
11AC:  ADDWF  x06,W
11AE:  MOVWF  FE9
11B0:  MOVLB  A
11B2:  MOVF   xF7,W
11B4:  MOVLB  B
11B6:  ADDWFC x07,W
11B8:  MOVWF  FEA
11BA:  MOVFF  FEF,B08
11BE:  MOVLW  03
11C0:  MOVLB  A
11C2:  SUBWF  xF8,W
11C4:  MOVLB  B
11C6:  MOVWF  x09
11C8:  MOVLW  00
11CA:  MOVLB  A
11CC:  SUBWFB xF9,W
11CE:  MOVLB  B
11D0:  MOVWF  x0A
11D2:  MOVLB  A
11D4:  MOVF   xF6,W
11D6:  MOVLB  B
11D8:  ADDWF  x09,W
11DA:  MOVWF  FE9
11DC:  MOVLB  A
11DE:  MOVF   xF7,W
11E0:  MOVLB  B
11E2:  ADDWFC x0A,W
11E4:  MOVWF  FEA
11E6:  MOVFF  FEF,B0B
11EA:  MOVLW  02
11EC:  MOVLB  A
11EE:  SUBWF  xF8,W
11F0:  MOVLB  B
11F2:  MOVWF  x0C
11F4:  MOVLW  00
11F6:  MOVLB  A
11F8:  SUBWFB xF9,W
11FA:  MOVLB  B
11FC:  MOVWF  x0D
11FE:  MOVLB  A
1200:  MOVF   xF6,W
1202:  MOVLB  B
1204:  ADDWF  x0C,W
1206:  MOVWF  FE9
1208:  MOVLB  A
120A:  MOVF   xF7,W
120C:  MOVLB  B
120E:  ADDWFC x0D,W
1210:  MOVWF  FEA
1212:  MOVFF  FEF,B0E
1216:  MOVLW  01
1218:  MOVLB  A
121A:  SUBWF  xF8,W
121C:  MOVLB  B
121E:  MOVWF  x0F
1220:  MOVLW  00
1222:  MOVLB  A
1224:  SUBWFB xF9,W
1226:  MOVLB  B
1228:  MOVWF  x10
122A:  MOVLB  A
122C:  MOVF   xF6,W
122E:  MOVLB  B
1230:  ADDWF  x0F,W
1232:  MOVWF  FE9
1234:  MOVLB  A
1236:  MOVF   xF7,W
1238:  MOVLB  B
123A:  ADDWFC x10,W
123C:  MOVWF  FEA
123E:  MOVFF  FEF,B11
1242:  MOVLB  A
1244:  MOVF   xF6,W
1246:  ADDWF  xF8,W
1248:  MOVWF  FE9
124A:  MOVF   xF7,W
124C:  ADDWFC xF9,W
124E:  MOVWF  FEA
1250:  MOVFF  FEF,B12
1254:  MOVLB  B
1256:  CLRF   x2F
1258:  MOVFF  B02,B30
125C:  MOVFF  B05,B31
1260:  MOVFF  B08,B32
1264:  MOVFF  B0B,B33
1268:  MOVFF  B0E,B34
126C:  MOVFF  B11,B35
1270:  MOVFF  B12,B36
1274:  MOVLB  0
1276:  CALL   05AE
127A:  MOVFF  01,AFC
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
127E:  MOVLW  0D
1280:  MOVLB  A
1282:  SUBWF  xF8,W
1284:  MOVLB  B
1286:  MOVWF  x00
1288:  MOVLW  00
128A:  MOVLB  A
128C:  SUBWFB xF9,W
128E:  MOVLB  B
1290:  MOVWF  x01
1292:  MOVLB  A
1294:  MOVF   xF6,W
1296:  MOVLB  B
1298:  ADDWF  x00,W
129A:  MOVWF  FE9
129C:  MOVLB  A
129E:  MOVF   xF7,W
12A0:  MOVLB  B
12A2:  ADDWFC x01,W
12A4:  MOVWF  FEA
12A6:  MOVFF  FEF,B02
12AA:  MOVLW  0C
12AC:  MOVLB  A
12AE:  SUBWF  xF8,W
12B0:  MOVLB  B
12B2:  MOVWF  x03
12B4:  MOVLW  00
12B6:  MOVLB  A
12B8:  SUBWFB xF9,W
12BA:  MOVLB  B
12BC:  MOVWF  x04
12BE:  MOVLB  A
12C0:  MOVF   xF6,W
12C2:  MOVLB  B
12C4:  ADDWF  x03,W
12C6:  MOVWF  FE9
12C8:  MOVLB  A
12CA:  MOVF   xF7,W
12CC:  MOVLB  B
12CE:  ADDWFC x04,W
12D0:  MOVWF  FEA
12D2:  MOVFF  FEF,B05
12D6:  MOVLW  0B
12D8:  MOVLB  A
12DA:  SUBWF  xF8,W
12DC:  MOVLB  B
12DE:  MOVWF  x06
12E0:  MOVLW  00
12E2:  MOVLB  A
12E4:  SUBWFB xF9,W
12E6:  MOVLB  B
12E8:  MOVWF  x07
12EA:  MOVLB  A
12EC:  MOVF   xF6,W
12EE:  MOVLB  B
12F0:  ADDWF  x06,W
12F2:  MOVWF  FE9
12F4:  MOVLB  A
12F6:  MOVF   xF7,W
12F8:  MOVLB  B
12FA:  ADDWFC x07,W
12FC:  MOVWF  FEA
12FE:  MOVFF  FEF,B08
1302:  MOVLW  0A
1304:  MOVLB  A
1306:  SUBWF  xF8,W
1308:  MOVLB  B
130A:  MOVWF  x09
130C:  MOVLW  00
130E:  MOVLB  A
1310:  SUBWFB xF9,W
1312:  MOVLB  B
1314:  MOVWF  x0A
1316:  MOVLB  A
1318:  MOVF   xF6,W
131A:  MOVLB  B
131C:  ADDWF  x09,W
131E:  MOVWF  FE9
1320:  MOVLB  A
1322:  MOVF   xF7,W
1324:  MOVLB  B
1326:  ADDWFC x0A,W
1328:  MOVWF  FEA
132A:  MOVFF  FEF,B0B
132E:  MOVLW  09
1330:  MOVLB  A
1332:  SUBWF  xF8,W
1334:  MOVLB  B
1336:  MOVWF  x0C
1338:  MOVLW  00
133A:  MOVLB  A
133C:  SUBWFB xF9,W
133E:  MOVLB  B
1340:  MOVWF  x0D
1342:  MOVLB  A
1344:  MOVF   xF6,W
1346:  MOVLB  B
1348:  ADDWF  x0C,W
134A:  MOVWF  FE9
134C:  MOVLB  A
134E:  MOVF   xF7,W
1350:  MOVLB  B
1352:  ADDWFC x0D,W
1354:  MOVWF  FEA
1356:  MOVFF  FEF,B0E
135A:  MOVLW  08
135C:  MOVLB  A
135E:  SUBWF  xF8,W
1360:  MOVLB  B
1362:  MOVWF  x0F
1364:  MOVLW  00
1366:  MOVLB  A
1368:  SUBWFB xF9,W
136A:  MOVLB  B
136C:  MOVWF  x10
136E:  MOVLB  A
1370:  MOVF   xF6,W
1372:  MOVLB  B
1374:  ADDWF  x0F,W
1376:  MOVWF  FE9
1378:  MOVLB  A
137A:  MOVF   xF7,W
137C:  MOVLB  B
137E:  ADDWFC x10,W
1380:  MOVWF  FEA
1382:  MOVFF  FEF,B11
1386:  MOVLW  07
1388:  MOVLB  A
138A:  SUBWF  xF8,W
138C:  MOVLB  B
138E:  MOVWF  x12
1390:  MOVLW  00
1392:  MOVLB  A
1394:  SUBWFB xF9,W
1396:  MOVLB  B
1398:  MOVWF  x13
139A:  MOVLB  A
139C:  MOVF   xF6,W
139E:  MOVLB  B
13A0:  ADDWF  x12,W
13A2:  MOVWF  FE9
13A4:  MOVLB  A
13A6:  MOVF   xF7,W
13A8:  MOVLB  B
13AA:  ADDWFC x13,W
13AC:  MOVWF  FEA
13AE:  MOVFF  FEF,B14
13B2:  CLRF   x2F
13B4:  MOVFF  B02,B30
13B8:  MOVFF  B05,B31
13BC:  MOVFF  B08,B32
13C0:  MOVFF  B0B,B33
13C4:  MOVFF  B0E,B34
13C8:  MOVFF  B11,B35
13CC:  MOVFF  B14,B36
13D0:  MOVLB  0
13D2:  CALL   05AE
13D6:  MOVFF  01,AFD
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
13DA:  MOVLB  A
13DC:  MOVF   xFC,W
13DE:  SUBLW  45
13E0:  BTFSS  FD8.2
13E2:  BRA    15C0
13E4:  MOVF   xFD,W
13E6:  SUBLW  7C
13E8:  BTFSC  FD8.2
13EA:  BRA    15C0
13EC:  MOVF   xFD,W
13EE:  SUBLW  3E
13F0:  BTFSC  FD8.2
13F2:  BRA    15C0
13F4:  MOVF   xFD,W
13F6:  SUBLW  1F
13F8:  BTFSC  FD8.2
13FA:  BRA    15C0
13FC:  MOVF   xFD,W
13FE:  SUBLW  0F
1400:  BTFSC  FD8.2
1402:  BRA    15C0
1404:  MOVF   xFD,W
1406:  SUBLW  78
1408:  BTFSC  FD8.2
140A:  BRA    15C0
....................          { 
....................             j=i; 
140C:  MOVFF  AF9,AFB
1410:  MOVFF  AF8,AFA
....................             CRC=1; 
1414:  MOVLW  01
1416:  MOVWF  xFF
....................             temp2=temp; 
1418:  MOVFF  AFC,AFE
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
141C:  MOVF   xFE,W
141E:  SUBLW  1F
1420:  BTFSC  FD8.2
1422:  BRA    15A0
1424:  MOVF   xFB,F
1426:  BNZ   1430
1428:  MOVF   xFA,W
142A:  SUBLW  01
142C:  BTFSC  FD8.0
142E:  BRA    15A0
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1430:  MOVLW  01
1432:  MOVLB  B
1434:  MOVWF  x1A
1436:  MOVFF  AFB,B1C
143A:  MOVFF  AFA,B1B
143E:  MOVFF  AF7,B1E
1442:  MOVFF  AF6,B1D
1446:  MOVLB  0
1448:  CALL   0614
144C:  MOVF   01,W
144E:  MOVLB  A
1450:  ANDWF  xFF,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1452:  MOVLW  06
1454:  SUBWF  xFA,W
1456:  MOVLB  B
1458:  MOVWF  x00
145A:  MOVLW  00
145C:  MOVLB  A
145E:  SUBWFB xFB,W
1460:  MOVLB  B
1462:  MOVWF  x01
1464:  MOVLB  A
1466:  MOVF   xF6,W
1468:  MOVLB  B
146A:  ADDWF  x00,W
146C:  MOVWF  FE9
146E:  MOVLB  A
1470:  MOVF   xF7,W
1472:  MOVLB  B
1474:  ADDWFC x01,W
1476:  MOVWF  FEA
1478:  MOVFF  FEF,B02
147C:  MOVLW  05
147E:  MOVLB  A
1480:  SUBWF  xFA,W
1482:  MOVLB  B
1484:  MOVWF  x03
1486:  MOVLW  00
1488:  MOVLB  A
148A:  SUBWFB xFB,W
148C:  MOVLB  B
148E:  MOVWF  x04
1490:  MOVLB  A
1492:  MOVF   xF6,W
1494:  MOVLB  B
1496:  ADDWF  x03,W
1498:  MOVWF  FE9
149A:  MOVLB  A
149C:  MOVF   xF7,W
149E:  MOVLB  B
14A0:  ADDWFC x04,W
14A2:  MOVWF  FEA
14A4:  MOVFF  FEF,B05
14A8:  MOVLW  04
14AA:  MOVLB  A
14AC:  SUBWF  xFA,W
14AE:  MOVLB  B
14B0:  MOVWF  x06
14B2:  MOVLW  00
14B4:  MOVLB  A
14B6:  SUBWFB xFB,W
14B8:  MOVLB  B
14BA:  MOVWF  x07
14BC:  MOVLB  A
14BE:  MOVF   xF6,W
14C0:  MOVLB  B
14C2:  ADDWF  x06,W
14C4:  MOVWF  FE9
14C6:  MOVLB  A
14C8:  MOVF   xF7,W
14CA:  MOVLB  B
14CC:  ADDWFC x07,W
14CE:  MOVWF  FEA
14D0:  MOVFF  FEF,B08
14D4:  MOVLW  03
14D6:  MOVLB  A
14D8:  SUBWF  xFA,W
14DA:  MOVLB  B
14DC:  MOVWF  x09
14DE:  MOVLW  00
14E0:  MOVLB  A
14E2:  SUBWFB xFB,W
14E4:  MOVLB  B
14E6:  MOVWF  x0A
14E8:  MOVLB  A
14EA:  MOVF   xF6,W
14EC:  MOVLB  B
14EE:  ADDWF  x09,W
14F0:  MOVWF  FE9
14F2:  MOVLB  A
14F4:  MOVF   xF7,W
14F6:  MOVLB  B
14F8:  ADDWFC x0A,W
14FA:  MOVWF  FEA
14FC:  MOVFF  FEF,B0B
1500:  MOVLW  02
1502:  MOVLB  A
1504:  SUBWF  xFA,W
1506:  MOVLB  B
1508:  MOVWF  x0C
150A:  MOVLW  00
150C:  MOVLB  A
150E:  SUBWFB xFB,W
1510:  MOVLB  B
1512:  MOVWF  x0D
1514:  MOVLB  A
1516:  MOVF   xF6,W
1518:  MOVLB  B
151A:  ADDWF  x0C,W
151C:  MOVWF  FE9
151E:  MOVLB  A
1520:  MOVF   xF7,W
1522:  MOVLB  B
1524:  ADDWFC x0D,W
1526:  MOVWF  FEA
1528:  MOVFF  FEF,B0E
152C:  MOVLW  01
152E:  MOVLB  A
1530:  SUBWF  xFA,W
1532:  MOVLB  B
1534:  MOVWF  x0F
1536:  MOVLW  00
1538:  MOVLB  A
153A:  SUBWFB xFB,W
153C:  MOVLB  B
153E:  MOVWF  x10
1540:  MOVLB  A
1542:  MOVF   xF6,W
1544:  MOVLB  B
1546:  ADDWF  x0F,W
1548:  MOVWF  FE9
154A:  MOVLB  A
154C:  MOVF   xF7,W
154E:  MOVLB  B
1550:  ADDWFC x10,W
1552:  MOVWF  FEA
1554:  MOVFF  FEF,B11
1558:  MOVLB  A
155A:  MOVF   xF6,W
155C:  ADDWF  xFA,W
155E:  MOVWF  FE9
1560:  MOVF   xF7,W
1562:  ADDWFC xFB,W
1564:  MOVWF  FEA
1566:  MOVFF  FEF,B12
156A:  MOVLB  B
156C:  CLRF   x2F
156E:  MOVFF  B02,B30
1572:  MOVFF  B05,B31
1576:  MOVFF  B08,B32
157A:  MOVFF  B0B,B33
157E:  MOVFF  B0E,B34
1582:  MOVFF  B11,B35
1586:  MOVFF  B12,B36
158A:  MOVLB  0
158C:  CALL   05AE
1590:  MOVFF  01,AFE
....................                j=j-7;             
1594:  MOVLW  07
1596:  MOVLB  A
1598:  SUBWF  xFA,F
159A:  MOVLW  00
159C:  SUBWFB xFB,F
....................              } 
159E:  BRA    141C
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
15A0:  DECFSZ xFF,W
15A2:  BRA    15B8
....................             { 
....................                dir=1; 
15A4:  MOVLW  01
15A6:  MOVLB  9
15A8:  MOVWF  x90
....................                return i; 
15AA:  MOVLB  A
15AC:  MOVFF  AF8,01
15B0:  MOVFF  AF9,02
15B4:  BRA    192C
....................             } 
....................             else return 0; 
15B6:  BRA    15C0
15B8:  MOVLW  00
15BA:  MOVWF  01
15BC:  MOVWF  02
15BE:  BRA    192C
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
15C0:  BRA    191A
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
15C2:  MOVLW  04
15C4:  SUBWF  xF8,W
15C6:  MOVLB  B
15C8:  MOVWF  x00
15CA:  MOVLW  00
15CC:  MOVLB  A
15CE:  SUBWFB xF9,W
15D0:  MOVLB  B
15D2:  MOVWF  x01
15D4:  MOVLB  A
15D6:  MOVF   xF6,W
15D8:  MOVLB  B
15DA:  ADDWF  x00,W
15DC:  MOVWF  FE9
15DE:  MOVLB  A
15E0:  MOVF   xF7,W
15E2:  MOVLB  B
15E4:  ADDWFC x01,W
15E6:  MOVWF  FEA
15E8:  MOVFF  FEF,B02
15EC:  MOVLW  03
15EE:  MOVLB  A
15F0:  SUBWF  xF8,W
15F2:  MOVLB  B
15F4:  MOVWF  x03
15F6:  MOVLW  00
15F8:  MOVLB  A
15FA:  SUBWFB xF9,W
15FC:  MOVLB  B
15FE:  MOVWF  x04
1600:  MOVLB  A
1602:  MOVF   xF6,W
1604:  MOVLB  B
1606:  ADDWF  x03,W
1608:  MOVWF  FE9
160A:  MOVLB  A
160C:  MOVF   xF7,W
160E:  MOVLB  B
1610:  ADDWFC x04,W
1612:  MOVWF  FEA
1614:  MOVFF  FEF,B05
1618:  MOVLW  02
161A:  MOVLB  A
161C:  SUBWF  xF8,W
161E:  MOVLB  B
1620:  MOVWF  x06
1622:  MOVLW  00
1624:  MOVLB  A
1626:  SUBWFB xF9,W
1628:  MOVLB  B
162A:  MOVWF  x07
162C:  MOVLB  A
162E:  MOVF   xF6,W
1630:  MOVLB  B
1632:  ADDWF  x06,W
1634:  MOVWF  FE9
1636:  MOVLB  A
1638:  MOVF   xF7,W
163A:  MOVLB  B
163C:  ADDWFC x07,W
163E:  MOVWF  FEA
1640:  MOVFF  FEF,B08
1644:  MOVLW  01
1646:  MOVLB  A
1648:  SUBWF  xF8,W
164A:  MOVLB  B
164C:  MOVWF  x09
164E:  MOVLW  00
1650:  MOVLB  A
1652:  SUBWFB xF9,W
1654:  MOVLB  B
1656:  MOVWF  x0A
1658:  MOVLB  A
165A:  MOVF   xF6,W
165C:  MOVLB  B
165E:  ADDWF  x09,W
1660:  MOVWF  FE9
1662:  MOVLB  A
1664:  MOVF   xF7,W
1666:  MOVLB  B
1668:  ADDWFC x0A,W
166A:  MOVWF  FEA
166C:  MOVFF  FEF,B0B
1670:  MOVLB  A
1672:  MOVF   xF6,W
1674:  ADDWF  xF8,W
1676:  MOVWF  FE9
1678:  MOVF   xF7,W
167A:  ADDWFC xF9,W
167C:  MOVWF  FEA
167E:  MOVFF  FEF,B0C
1682:  MOVLB  B
1684:  CLRF   x2F
1686:  CLRF   x30
1688:  CLRF   x31
168A:  MOVFF  B02,B32
168E:  MOVFF  B05,B33
1692:  MOVFF  B08,B34
1696:  MOVFF  B0B,B35
169A:  MOVFF  B0C,B36
169E:  MOVLB  0
16A0:  CALL   05AE
16A4:  MOVFF  01,AFC
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
16A8:  MOVLW  09
16AA:  MOVLB  A
16AC:  SUBWF  xF8,W
16AE:  MOVLB  B
16B0:  MOVWF  x00
16B2:  MOVLW  00
16B4:  MOVLB  A
16B6:  SUBWFB xF9,W
16B8:  MOVLB  B
16BA:  MOVWF  x01
16BC:  MOVLB  A
16BE:  MOVF   xF6,W
16C0:  MOVLB  B
16C2:  ADDWF  x00,W
16C4:  MOVWF  FE9
16C6:  MOVLB  A
16C8:  MOVF   xF7,W
16CA:  MOVLB  B
16CC:  ADDWFC x01,W
16CE:  MOVWF  FEA
16D0:  MOVFF  FEF,B02
16D4:  MOVLW  08
16D6:  MOVLB  A
16D8:  SUBWF  xF8,W
16DA:  MOVLB  B
16DC:  MOVWF  x03
16DE:  MOVLW  00
16E0:  MOVLB  A
16E2:  SUBWFB xF9,W
16E4:  MOVLB  B
16E6:  MOVWF  x04
16E8:  MOVLB  A
16EA:  MOVF   xF6,W
16EC:  MOVLB  B
16EE:  ADDWF  x03,W
16F0:  MOVWF  FE9
16F2:  MOVLB  A
16F4:  MOVF   xF7,W
16F6:  MOVLB  B
16F8:  ADDWFC x04,W
16FA:  MOVWF  FEA
16FC:  MOVFF  FEF,B05
1700:  MOVLW  07
1702:  MOVLB  A
1704:  SUBWF  xF8,W
1706:  MOVLB  B
1708:  MOVWF  x06
170A:  MOVLW  00
170C:  MOVLB  A
170E:  SUBWFB xF9,W
1710:  MOVLB  B
1712:  MOVWF  x07
1714:  MOVLB  A
1716:  MOVF   xF6,W
1718:  MOVLB  B
171A:  ADDWF  x06,W
171C:  MOVWF  FE9
171E:  MOVLB  A
1720:  MOVF   xF7,W
1722:  MOVLB  B
1724:  ADDWFC x07,W
1726:  MOVWF  FEA
1728:  MOVFF  FEF,B08
172C:  MOVLW  06
172E:  MOVLB  A
1730:  SUBWF  xF8,W
1732:  MOVLB  B
1734:  MOVWF  x09
1736:  MOVLW  00
1738:  MOVLB  A
173A:  SUBWFB xF9,W
173C:  MOVLB  B
173E:  MOVWF  x0A
1740:  MOVLB  A
1742:  MOVF   xF6,W
1744:  MOVLB  B
1746:  ADDWF  x09,W
1748:  MOVWF  FE9
174A:  MOVLB  A
174C:  MOVF   xF7,W
174E:  MOVLB  B
1750:  ADDWFC x0A,W
1752:  MOVWF  FEA
1754:  MOVFF  FEF,B0B
1758:  MOVLW  05
175A:  MOVLB  A
175C:  SUBWF  xF8,W
175E:  MOVLB  B
1760:  MOVWF  x0C
1762:  MOVLW  00
1764:  MOVLB  A
1766:  SUBWFB xF9,W
1768:  MOVLB  B
176A:  MOVWF  x0D
176C:  MOVLB  A
176E:  MOVF   xF6,W
1770:  MOVLB  B
1772:  ADDWF  x0C,W
1774:  MOVWF  FE9
1776:  MOVLB  A
1778:  MOVF   xF7,W
177A:  MOVLB  B
177C:  ADDWFC x0D,W
177E:  MOVWF  FEA
1780:  MOVFF  FEF,B0E
1784:  CLRF   x2F
1786:  CLRF   x30
1788:  CLRF   x31
178A:  MOVFF  B02,B32
178E:  MOVFF  B05,B33
1792:  MOVFF  B08,B34
1796:  MOVFF  B0B,B35
179A:  MOVFF  B0E,B36
179E:  MOVLB  0
17A0:  CALL   05AE
17A4:  MOVFF  01,AFD
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
17A8:  MOVLB  A
17AA:  MOVF   xFC,W
17AC:  SUBLW  0B
17AE:  BTFSS  FD8.2
17B0:  BRA    191A
17B2:  MOVF   xFD,W
17B4:  SUBLW  1F
17B6:  BTFSC  FD8.2
17B8:  BRA    191A
17BA:  MOVF   xFD,W
17BC:  SUBLW  0F
17BE:  BTFSC  FD8.2
17C0:  BRA    191A
....................             { 
....................                j=i; 
17C2:  MOVFF  AF9,AFB
17C6:  MOVFF  AF8,AFA
....................                CRC=1; 
17CA:  MOVLW  01
17CC:  MOVWF  xFF
....................                temp2=temp; 
17CE:  MOVFF  AFC,AFE
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
17D2:  MOVF   xFE,W
17D4:  SUBLW  1F
17D6:  BTFSC  FD8.2
17D8:  BRA    18FA
17DA:  MOVF   xFB,F
17DC:  BNZ   17E6
17DE:  MOVF   xFA,W
17E0:  SUBLW  01
17E2:  BTFSC  FD8.0
17E4:  BRA    18FA
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
17E6:  MOVLW  01
17E8:  MOVLB  B
17EA:  MOVWF  x1A
17EC:  MOVFF  AFB,B1C
17F0:  MOVFF  AFA,B1B
17F4:  MOVFF  AF7,B1E
17F8:  MOVFF  AF6,B1D
17FC:  MOVLB  0
17FE:  CALL   07C4
1802:  MOVF   01,W
1804:  MOVLB  A
1806:  ANDWF  xFF,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1808:  MOVLW  04
180A:  SUBWF  xFA,W
180C:  MOVLB  B
180E:  MOVWF  x00
1810:  MOVLW  00
1812:  MOVLB  A
1814:  SUBWFB xFB,W
1816:  MOVLB  B
1818:  MOVWF  x01
181A:  MOVLB  A
181C:  MOVF   xF6,W
181E:  MOVLB  B
1820:  ADDWF  x00,W
1822:  MOVWF  FE9
1824:  MOVLB  A
1826:  MOVF   xF7,W
1828:  MOVLB  B
182A:  ADDWFC x01,W
182C:  MOVWF  FEA
182E:  MOVFF  FEF,B02
1832:  MOVLW  03
1834:  MOVLB  A
1836:  SUBWF  xFA,W
1838:  MOVLB  B
183A:  MOVWF  x03
183C:  MOVLW  00
183E:  MOVLB  A
1840:  SUBWFB xFB,W
1842:  MOVLB  B
1844:  MOVWF  x04
1846:  MOVLB  A
1848:  MOVF   xF6,W
184A:  MOVLB  B
184C:  ADDWF  x03,W
184E:  MOVWF  FE9
1850:  MOVLB  A
1852:  MOVF   xF7,W
1854:  MOVLB  B
1856:  ADDWFC x04,W
1858:  MOVWF  FEA
185A:  MOVFF  FEF,B05
185E:  MOVLW  02
1860:  MOVLB  A
1862:  SUBWF  xFA,W
1864:  MOVLB  B
1866:  MOVWF  x06
1868:  MOVLW  00
186A:  MOVLB  A
186C:  SUBWFB xFB,W
186E:  MOVLB  B
1870:  MOVWF  x07
1872:  MOVLB  A
1874:  MOVF   xF6,W
1876:  MOVLB  B
1878:  ADDWF  x06,W
187A:  MOVWF  FE9
187C:  MOVLB  A
187E:  MOVF   xF7,W
1880:  MOVLB  B
1882:  ADDWFC x07,W
1884:  MOVWF  FEA
1886:  MOVFF  FEF,B08
188A:  MOVLW  01
188C:  MOVLB  A
188E:  SUBWF  xFA,W
1890:  MOVLB  B
1892:  MOVWF  x09
1894:  MOVLW  00
1896:  MOVLB  A
1898:  SUBWFB xFB,W
189A:  MOVLB  B
189C:  MOVWF  x0A
189E:  MOVLB  A
18A0:  MOVF   xF6,W
18A2:  MOVLB  B
18A4:  ADDWF  x09,W
18A6:  MOVWF  FE9
18A8:  MOVLB  A
18AA:  MOVF   xF7,W
18AC:  MOVLB  B
18AE:  ADDWFC x0A,W
18B0:  MOVWF  FEA
18B2:  MOVFF  FEF,B0B
18B6:  MOVLB  A
18B8:  MOVF   xF6,W
18BA:  ADDWF  xFA,W
18BC:  MOVWF  FE9
18BE:  MOVF   xF7,W
18C0:  ADDWFC xFB,W
18C2:  MOVWF  FEA
18C4:  MOVFF  FEF,B0C
18C8:  MOVLB  B
18CA:  CLRF   x2F
18CC:  CLRF   x30
18CE:  CLRF   x31
18D0:  MOVFF  B02,B32
18D4:  MOVFF  B05,B33
18D8:  MOVFF  B08,B34
18DC:  MOVFF  B0B,B35
18E0:  MOVFF  B0C,B36
18E4:  MOVLB  0
18E6:  CALL   05AE
18EA:  MOVFF  01,AFE
....................                   j=j-5; 
18EE:  MOVLW  05
18F0:  MOVLB  A
18F2:  SUBWF  xFA,F
18F4:  MOVLW  00
18F6:  SUBWFB xFB,F
....................                } 
18F8:  BRA    17D2
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
18FA:  DECFSZ xFF,W
18FC:  BRA    1912
....................                { 
....................                   dir=1; 
18FE:  MOVLW  01
1900:  MOVLB  9
1902:  MOVWF  x90
....................                   return i; 
1904:  MOVLB  A
1906:  MOVFF  AF8,01
190A:  MOVFF  AF9,02
190E:  BRA    192C
....................                } 
....................                   else return 0; 
1910:  BRA    191A
1912:  MOVLW  00
1914:  MOVWF  01
1916:  MOVWF  02
1918:  BRA    192C
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
191A:  MOVF   xF8,W
191C:  BTFSC  FD8.2
191E:  DECF   xF9,F
1920:  DECF   xF8,F
1922:  GOTO   110C
....................    return 0; 
1926:  MOVLW  00
1928:  MOVWF  01
192A:  MOVWF  02
.................... } 
192C:  MOVLB  0
192E:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
3238:  MOVLB  A
323A:  CLRF   xF2
323C:  MOVLW  01
323E:  MOVWF  xF1
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3240:  MOVFF  AE7,AF3
3244:  MOVFF  AE9,AF5
3248:  MOVFF  AE8,AF4
324C:  MOVFF  AEB,AF7
3250:  MOVFF  AEA,AF6
3254:  MOVLB  0
3256:  CALL   0904
325A:  MOVFF  02,AF2
325E:  MOVFF  01,AF1
....................    if(temp==0) return 0; 
3262:  MOVLB  A
3264:  MOVF   xF1,F
3266:  BNZ   3272
3268:  MOVF   xF2,F
326A:  BNZ   3272
326C:  MOVLW  00
326E:  MOVWF  01
3270:  BRA    3648
....................    j=temp; 
3272:  MOVFF  AF2,AF0
3276:  MOVFF  AF1,AEF
....................    if(dir==0) 
327A:  MOVLB  9
327C:  MOVF   x90,F
327E:  BTFSS  FD8.2
3280:  BRA    3452
....................    { 
....................       if(track==0) 
3282:  MOVLB  A
3284:  MOVF   xE7,F
3286:  BTFSS  FD8.2
3288:  BRA    3394
....................       { 
....................             for(i=0;i<79;i++) 
328A:  CLRF   xEE
328C:  MOVF   xEE,W
328E:  SUBLW  4E
3290:  BTFSS  FD8.0
3292:  BRA    3392
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3294:  CLRF   03
3296:  MOVF   xEE,W
3298:  ADDWF  xEC,W
329A:  MOVWF  01
329C:  MOVF   xED,W
329E:  ADDWFC 03,F
32A0:  MOVFF  01,AF3
32A4:  MOVFF  03,AF4
32A8:  MOVLW  05
32AA:  ADDWF  xEF,W
32AC:  MOVWF  xF5
32AE:  MOVLW  00
32B0:  ADDWFC xF0,W
32B2:  MOVWF  xF6
32B4:  MOVF   xEA,W
32B6:  ADDWF  xF5,W
32B8:  MOVWF  FE9
32BA:  MOVF   xEB,W
32BC:  ADDWFC xF6,W
32BE:  MOVWF  FEA
32C0:  MOVFF  FEF,AF7
32C4:  MOVLW  04
32C6:  ADDWF  xEF,W
32C8:  MOVWF  xF8
32CA:  MOVLW  00
32CC:  ADDWFC xF0,W
32CE:  MOVWF  xF9
32D0:  MOVF   xEA,W
32D2:  ADDWF  xF8,W
32D4:  MOVWF  FE9
32D6:  MOVF   xEB,W
32D8:  ADDWFC xF9,W
32DA:  MOVWF  FEA
32DC:  MOVFF  FEF,AFA
32E0:  MOVLW  03
32E2:  ADDWF  xEF,W
32E4:  MOVWF  xFB
32E6:  MOVLW  00
32E8:  ADDWFC xF0,W
32EA:  MOVWF  xFC
32EC:  MOVF   xEA,W
32EE:  ADDWF  xFB,W
32F0:  MOVWF  FE9
32F2:  MOVF   xEB,W
32F4:  ADDWFC xFC,W
32F6:  MOVWF  FEA
32F8:  MOVFF  FEF,AFD
32FC:  MOVLW  02
32FE:  ADDWF  xEF,W
3300:  MOVWF  xFE
3302:  MOVLW  00
3304:  ADDWFC xF0,W
3306:  MOVWF  xFF
3308:  MOVF   xEA,W
330A:  ADDWF  xFE,W
330C:  MOVWF  FE9
330E:  MOVF   xEB,W
3310:  ADDWFC xFF,W
3312:  MOVWF  FEA
3314:  MOVFF  FEF,B00
3318:  MOVLW  01
331A:  ADDWF  xEF,W
331C:  MOVLB  B
331E:  MOVWF  x01
3320:  MOVLW  00
3322:  MOVLB  A
3324:  ADDWFC xF0,W
3326:  MOVLB  B
3328:  MOVWF  x02
332A:  MOVLB  A
332C:  MOVF   xEA,W
332E:  MOVLB  B
3330:  ADDWF  x01,W
3332:  MOVWF  FE9
3334:  MOVLB  A
3336:  MOVF   xEB,W
3338:  MOVLB  B
333A:  ADDWFC x02,W
333C:  MOVWF  FEA
333E:  MOVFF  FEF,B03
3342:  MOVLB  A
3344:  MOVF   xEA,W
3346:  ADDWF  xEF,W
3348:  MOVWF  FE9
334A:  MOVF   xEB,W
334C:  ADDWFC xF0,W
334E:  MOVWF  FEA
3350:  MOVFF  FEF,B04
3354:  MOVLB  B
3356:  CLRF   x2F
3358:  CLRF   x30
335A:  MOVFF  AF7,B31
335E:  MOVFF  AFA,B32
3362:  MOVFF  AFD,B33
3366:  MOVFF  B00,B34
336A:  MOVFF  B03,B35
336E:  MOVFF  B04,B36
3372:  MOVLB  0
3374:  CALL   05AE
3378:  MOVFF  AF4,FEA
337C:  MOVFF  AF3,FE9
3380:  MOVFF  01,FEF
....................                j=j+7; 
3384:  MOVLW  07
3386:  MOVLB  A
3388:  ADDWF  xEF,F
338A:  MOVLW  00
338C:  ADDWFC xF0,F
....................             } 
338E:  INCF   xEE,F
3390:  BRA    328C
....................       } 
....................          else  
3392:  BRA    344E
....................          { 
....................             for(i=0;i<40;i++) 
3394:  CLRF   xEE
3396:  MOVF   xEE,W
3398:  SUBLW  27
339A:  BNC   344E
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
339C:  CLRF   03
339E:  MOVF   xEE,W
33A0:  ADDWF  xEC,W
33A2:  MOVWF  01
33A4:  MOVF   xED,W
33A6:  ADDWFC 03,F
33A8:  MOVFF  01,AF3
33AC:  MOVFF  03,AF4
33B0:  MOVLW  03
33B2:  ADDWF  xEF,W
33B4:  MOVWF  xF5
33B6:  MOVLW  00
33B8:  ADDWFC xF0,W
33BA:  MOVWF  xF6
33BC:  MOVF   xEA,W
33BE:  ADDWF  xF5,W
33C0:  MOVWF  FE9
33C2:  MOVF   xEB,W
33C4:  ADDWFC xF6,W
33C6:  MOVWF  FEA
33C8:  MOVFF  FEF,AF7
33CC:  MOVLW  02
33CE:  ADDWF  xEF,W
33D0:  MOVWF  xF8
33D2:  MOVLW  00
33D4:  ADDWFC xF0,W
33D6:  MOVWF  xF9
33D8:  MOVF   xEA,W
33DA:  ADDWF  xF8,W
33DC:  MOVWF  FE9
33DE:  MOVF   xEB,W
33E0:  ADDWFC xF9,W
33E2:  MOVWF  FEA
33E4:  MOVFF  FEF,AFA
33E8:  MOVLW  01
33EA:  ADDWF  xEF,W
33EC:  MOVWF  xFB
33EE:  MOVLW  00
33F0:  ADDWFC xF0,W
33F2:  MOVWF  xFC
33F4:  MOVF   xEA,W
33F6:  ADDWF  xFB,W
33F8:  MOVWF  FE9
33FA:  MOVF   xEB,W
33FC:  ADDWFC xFC,W
33FE:  MOVWF  FEA
3400:  MOVFF  FEF,AFD
3404:  MOVF   xEA,W
3406:  ADDWF  xEF,W
3408:  MOVWF  FE9
340A:  MOVF   xEB,W
340C:  ADDWFC xF0,W
340E:  MOVWF  FEA
3410:  MOVFF  FEF,AFE
3414:  MOVLB  B
3416:  CLRF   x2F
3418:  CLRF   x30
341A:  CLRF   x31
341C:  CLRF   x32
341E:  MOVFF  AF7,B33
3422:  MOVFF  AFA,B34
3426:  MOVFF  AFD,B35
342A:  MOVFF  AFE,B36
342E:  MOVLB  0
3430:  CALL   05AE
3434:  MOVFF  AF4,FEA
3438:  MOVFF  AF3,FE9
343C:  MOVFF  01,FEF
....................                j=j+5; 
3440:  MOVLW  05
3442:  MOVLB  A
3444:  ADDWF  xEF,F
3446:  MOVLW  00
3448:  ADDWFC xF0,F
....................             }          
344A:  INCF   xEE,F
344C:  BRA    3396
....................          } 
....................    } 
....................       else  
344E:  BRA    361E
3450:  MOVLB  9
....................       { 
....................          if(track==0) 
3452:  MOVLB  A
3454:  MOVF   xE7,F
3456:  BTFSS  FD8.2
3458:  BRA    3564
....................          { 
....................             for(i=0;i<79;i++) 
345A:  CLRF   xEE
345C:  MOVF   xEE,W
345E:  SUBLW  4E
3460:  BTFSS  FD8.0
3462:  BRA    3562
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3464:  CLRF   03
3466:  MOVF   xEE,W
3468:  ADDWF  xEC,W
346A:  MOVWF  01
346C:  MOVF   xED,W
346E:  ADDWFC 03,F
3470:  MOVFF  01,AF3
3474:  MOVFF  03,AF4
3478:  MOVLW  05
347A:  SUBWF  xEF,W
347C:  MOVWF  xF5
347E:  MOVLW  00
3480:  SUBWFB xF0,W
3482:  MOVWF  xF6
3484:  MOVF   xEA,W
3486:  ADDWF  xF5,W
3488:  MOVWF  FE9
348A:  MOVF   xEB,W
348C:  ADDWFC xF6,W
348E:  MOVWF  FEA
3490:  MOVFF  FEF,AF7
3494:  MOVLW  04
3496:  SUBWF  xEF,W
3498:  MOVWF  xF8
349A:  MOVLW  00
349C:  SUBWFB xF0,W
349E:  MOVWF  xF9
34A0:  MOVF   xEA,W
34A2:  ADDWF  xF8,W
34A4:  MOVWF  FE9
34A6:  MOVF   xEB,W
34A8:  ADDWFC xF9,W
34AA:  MOVWF  FEA
34AC:  MOVFF  FEF,AFA
34B0:  MOVLW  03
34B2:  SUBWF  xEF,W
34B4:  MOVWF  xFB
34B6:  MOVLW  00
34B8:  SUBWFB xF0,W
34BA:  MOVWF  xFC
34BC:  MOVF   xEA,W
34BE:  ADDWF  xFB,W
34C0:  MOVWF  FE9
34C2:  MOVF   xEB,W
34C4:  ADDWFC xFC,W
34C6:  MOVWF  FEA
34C8:  MOVFF  FEF,AFD
34CC:  MOVLW  02
34CE:  SUBWF  xEF,W
34D0:  MOVWF  xFE
34D2:  MOVLW  00
34D4:  SUBWFB xF0,W
34D6:  MOVWF  xFF
34D8:  MOVF   xEA,W
34DA:  ADDWF  xFE,W
34DC:  MOVWF  FE9
34DE:  MOVF   xEB,W
34E0:  ADDWFC xFF,W
34E2:  MOVWF  FEA
34E4:  MOVFF  FEF,B00
34E8:  MOVLW  01
34EA:  SUBWF  xEF,W
34EC:  MOVLB  B
34EE:  MOVWF  x01
34F0:  MOVLW  00
34F2:  MOVLB  A
34F4:  SUBWFB xF0,W
34F6:  MOVLB  B
34F8:  MOVWF  x02
34FA:  MOVLB  A
34FC:  MOVF   xEA,W
34FE:  MOVLB  B
3500:  ADDWF  x01,W
3502:  MOVWF  FE9
3504:  MOVLB  A
3506:  MOVF   xEB,W
3508:  MOVLB  B
350A:  ADDWFC x02,W
350C:  MOVWF  FEA
350E:  MOVFF  FEF,B03
3512:  MOVLB  A
3514:  MOVF   xEA,W
3516:  ADDWF  xEF,W
3518:  MOVWF  FE9
351A:  MOVF   xEB,W
351C:  ADDWFC xF0,W
351E:  MOVWF  FEA
3520:  MOVFF  FEF,B04
3524:  MOVLB  B
3526:  CLRF   x2F
3528:  CLRF   x30
352A:  MOVFF  AF7,B31
352E:  MOVFF  AFA,B32
3532:  MOVFF  AFD,B33
3536:  MOVFF  B00,B34
353A:  MOVFF  B03,B35
353E:  MOVFF  B04,B36
3542:  MOVLB  0
3544:  CALL   05AE
3548:  MOVFF  AF4,FEA
354C:  MOVFF  AF3,FE9
3550:  MOVFF  01,FEF
....................                j=j-7; 
3554:  MOVLW  07
3556:  MOVLB  A
3558:  SUBWF  xEF,F
355A:  MOVLW  00
355C:  SUBWFB xF0,F
....................             } 
355E:  INCF   xEE,F
3560:  BRA    345C
....................          } 
....................             else 
3562:  BRA    361E
....................             { 
....................                for(i=0;i<40;i++) 
3564:  CLRF   xEE
3566:  MOVF   xEE,W
3568:  SUBLW  27
356A:  BNC   361E
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
356C:  CLRF   03
356E:  MOVF   xEE,W
3570:  ADDWF  xEC,W
3572:  MOVWF  01
3574:  MOVF   xED,W
3576:  ADDWFC 03,F
3578:  MOVFF  01,AF3
357C:  MOVFF  03,AF4
3580:  MOVLW  03
3582:  SUBWF  xEF,W
3584:  MOVWF  xF5
3586:  MOVLW  00
3588:  SUBWFB xF0,W
358A:  MOVWF  xF6
358C:  MOVF   xEA,W
358E:  ADDWF  xF5,W
3590:  MOVWF  FE9
3592:  MOVF   xEB,W
3594:  ADDWFC xF6,W
3596:  MOVWF  FEA
3598:  MOVFF  FEF,AF7
359C:  MOVLW  02
359E:  SUBWF  xEF,W
35A0:  MOVWF  xF8
35A2:  MOVLW  00
35A4:  SUBWFB xF0,W
35A6:  MOVWF  xF9
35A8:  MOVF   xEA,W
35AA:  ADDWF  xF8,W
35AC:  MOVWF  FE9
35AE:  MOVF   xEB,W
35B0:  ADDWFC xF9,W
35B2:  MOVWF  FEA
35B4:  MOVFF  FEF,AFA
35B8:  MOVLW  01
35BA:  SUBWF  xEF,W
35BC:  MOVWF  xFB
35BE:  MOVLW  00
35C0:  SUBWFB xF0,W
35C2:  MOVWF  xFC
35C4:  MOVF   xEA,W
35C6:  ADDWF  xFB,W
35C8:  MOVWF  FE9
35CA:  MOVF   xEB,W
35CC:  ADDWFC xFC,W
35CE:  MOVWF  FEA
35D0:  MOVFF  FEF,AFD
35D4:  MOVF   xEA,W
35D6:  ADDWF  xEF,W
35D8:  MOVWF  FE9
35DA:  MOVF   xEB,W
35DC:  ADDWFC xF0,W
35DE:  MOVWF  FEA
35E0:  MOVFF  FEF,AFE
35E4:  MOVLB  B
35E6:  CLRF   x2F
35E8:  CLRF   x30
35EA:  CLRF   x31
35EC:  CLRF   x32
35EE:  MOVFF  AF7,B33
35F2:  MOVFF  AFA,B34
35F6:  MOVFF  AFD,B35
35FA:  MOVFF  AFE,B36
35FE:  MOVLB  0
3600:  CALL   05AE
3604:  MOVFF  AF4,FEA
3608:  MOVFF  AF3,FE9
360C:  MOVFF  01,FEF
....................                   j=j-5; 
3610:  MOVLW  05
3612:  MOVLB  A
3614:  SUBWF  xEF,F
3616:  MOVLW  00
3618:  SUBWFB xF0,F
....................                }             
361A:  INCF   xEE,F
361C:  BRA    3566
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
361E:  MOVF   xE7,F
3620:  BNZ   3636
3622:  MOVLW  52
3624:  MOVWF  xF3
3626:  MOVFF  AEB,AF5
362A:  MOVFF  AEA,AF4
362E:  MOVLB  0
3630:  RCALL  3216
....................          else del_buf(numbyteofbuffer2,datin); 
3632:  BRA    3646
3634:  MOVLB  A
3636:  MOVLW  2C
3638:  MOVWF  xF3
363A:  MOVFF  AEB,AF5
363E:  MOVFF  AEA,AF4
3642:  MOVLB  0
3644:  RCALL  3216
3646:  MOVLB  A
.................... } 
3648:  MOVLB  0
364A:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
1B08:  MOVLW  5E
1B0A:  MOVWF  FF6
1B0C:  MOVLW  04
1B0E:  MOVWF  FF7
1B10:  CALL   058E
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1B14:  MOVLB  A
1B16:  CLRF   xEB
1B18:  CLRF   xEA
1B1A:  MOVF   xEB,W
1B1C:  SUBLW  03
1B1E:  BNC   1B4E
1B20:  BNZ   1B28
1B22:  MOVF   xEA,W
1B24:  SUBLW  51
1B26:  BNC   1B4E
1B28:  MOVLW  0E
1B2A:  ADDWF  xEA,W
1B2C:  MOVWF  FE9
1B2E:  MOVLW  05
1B30:  ADDWFC xEB,W
1B32:  MOVWF  FEA
1B34:  MOVFF  FEF,AEC
1B38:  MOVFF  AEC,AED
1B3C:  MOVLW  18
1B3E:  MOVWF  xEE
1B40:  MOVLB  0
1B42:  RCALL  1A44
1B44:  MOVLB  A
1B46:  INCF   xEA,F
1B48:  BTFSC  FD8.2
1B4A:  INCF   xEB,F
1B4C:  BRA    1B1A
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1B4E:  MOVLW  74
1B50:  MOVWF  FF6
1B52:  MOVLW  04
1B54:  MOVWF  FF7
1B56:  MOVLB  0
1B58:  CALL   058E
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1B5C:  MOVLB  A
1B5E:  CLRF   xEB
1B60:  CLRF   xEA
1B62:  MOVF   xEB,W
1B64:  SUBLW  01
1B66:  BNC   1B96
1B68:  BNZ   1B70
1B6A:  MOVF   xEA,W
1B6C:  SUBLW  2B
1B6E:  BNC   1B96
1B70:  MOVLW  60
1B72:  ADDWF  xEA,W
1B74:  MOVWF  FE9
1B76:  MOVLW  08
1B78:  ADDWFC xEB,W
1B7A:  MOVWF  FEA
1B7C:  MOVFF  FEF,AEC
1B80:  MOVFF  AEC,AED
1B84:  MOVLW  18
1B86:  MOVWF  xEE
1B88:  MOVLB  0
1B8A:  RCALL  1A44
1B8C:  MOVLB  A
1B8E:  INCF   xEA,F
1B90:  BTFSC  FD8.2
1B92:  INCF   xEB,F
1B94:  BRA    1B62
.................... } 
1B96:  MOVLB  0
1B98:  GOTO   1E2E (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
37D8:  MOVLW  01
37DA:  MOVLB  9
37DC:  MOVWF  xA0
....................    rtc_get_date(date,mon,year,day); 
....................    rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
*
388A:  RCALL  31A4
388C:  MOVFF  02,AE8
3890:  MOVFF  01,AE7
3894:  MOVFF  02,AEA
3898:  MOVFF  01,AE9
389C:  MOVLB  A
389E:  CLRF   xEC
38A0:  MOVLW  7C
38A2:  MOVWF  xEB
38A4:  MOVLB  0
38A6:  RCALL  31F4
38A8:  MOVFF  01,AE7
38AC:  MOVLW  96
38AE:  MOVLB  A
38B0:  ADDWF  01,W
38B2:  MOVWF  01
38B4:  MOVLW  00
38B6:  ADDWFC 02,W
38B8:  MOVFF  01,20
38BC:  MOVWF  21
38BE:  CLRF   22
38C0:  CLRF   23
....................    if(datinbuf==0)  
38C2:  MOVLB  9
38C4:  MOVF   x9D,F
38C6:  BNZ   38E8
....................    { 
....................       countbit_T1=0; 
38C8:  CLRF   x92
38CA:  CLRF   x91
....................       countbit_T2=0; 
38CC:  CLRF   x94
38CE:  CLRF   x93
....................       bug_countbit_T1=0; 
38D0:  CLRF   x96
38D2:  CLRF   x95
....................       bug_countbit_T2=0; 
38D4:  CLRF   x98
38D6:  CLRF   x97
....................       if(data_avai==0)charac_timeout=0xffffffff; 
38D8:  MOVF   xA1,F
38DA:  BNZ   38E4
38DC:  MOVLB  0
38DE:  SETF   xFC
38E0:  SETF   xFB
38E2:  MOVLB  9
....................       saving_flag=0; 
38E4:  CLRF   xA0
....................       return; 
38E6:  BRA    3C52
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
38E8:  MOVLW  8A
38EA:  MOVWF  FF6
38EC:  MOVLW  04
38EE:  MOVWF  FF7
38F0:  MOVLB  0
38F2:  CALL   058E
....................    key_timeout=0; 
38F6:  MOVLB  1
38F8:  CLRF   x06
38FA:  CLRF   x05
....................    //key_count=0; 
....................    enable_getpin=1; 
38FC:  MOVLW  01
38FE:  MOVWF  x09
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
3900:  MOVFF  992,AE6
3904:  MOVFF  991,AE5
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
3908:  MOVLB  A
390A:  CLRF   xE7
390C:  MOVFF  AE6,AE9
3910:  MOVFF  AE5,AE8
3914:  MOVLW  05
3916:  MOVWF  xEB
3918:  MOVLW  0E
391A:  MOVWF  xEA
391C:  MOVLW  04
391E:  MOVWF  xED
3920:  MOVLW  97
3922:  MOVWF  xEC
3924:  MOVLB  0
3926:  RCALL  3238
....................    countbit_T1=0; 
3928:  MOVLB  9
392A:  CLRF   x92
392C:  CLRF   x91
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
392E:  MOVFF  994,AE6
3932:  MOVFF  993,AE5
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
3936:  MOVLW  01
3938:  MOVLB  A
393A:  MOVWF  xE7
393C:  MOVFF  AE6,AE9
3940:  MOVFF  AE5,AE8
3944:  MOVLW  08
3946:  MOVWF  xEB
3948:  MOVLW  60
394A:  MOVWF  xEA
394C:  MOVLW  04
394E:  MOVWF  xED
3950:  MOVLW  E6
3952:  MOVWF  xEC
3954:  MOVLB  0
3956:  RCALL  3238
....................    countbit_T2=0; 
3958:  MOVLB  9
395A:  CLRF   x94
395C:  CLRF   x93
....................    saving_flag=0; 
395E:  CLRF   xA0
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
3960:  MOVLW  20
3962:  MOVLB  4
3964:  ADDWF  x97,W
3966:  MOVLB  A
3968:  MOVWF  xE4
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
396A:  MOVF   23,F
396C:  BTFSS  FD8.2
396E:  BRA    3C50
3970:  MOVF   22,F
3972:  BTFSS  FD8.2
3974:  BRA    3C50
3976:  MOVF   21,W
3978:  SUBLW  AA
397A:  BTFSS  FD8.0
397C:  BRA    3C50
397E:  BNZ   3988
3980:  MOVF   20,W
3982:  SUBLW  45
3984:  BTFSS  FD8.0
3986:  BRA    3C50
3988:  MOVF   xE4,W
398A:  SUBLW  25
398C:  BTFSS  FD8.2
398E:  BRA    3C50
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
3990:  MOVFF  23,03
3994:  MOVFF  22,02
3998:  MOVFF  21,01
399C:  MOVFF  20,00
39A0:  MOVLW  01
39A2:  ADDWF  20,F
39A4:  BTFSC  FD8.0
39A6:  INCF   21,F
39A8:  BTFSC  FD8.2
39AA:  INCF   22,F
39AC:  BTFSC  FD8.2
39AE:  INCF   23,F
39B0:  MOVFF  01,AE8
39B4:  MOVFF  00,AE7
39B8:  MOVFF  01,B03
39BC:  MOVFF  00,B02
39C0:  MOVFF  100,B04
39C4:  MOVLB  0
39C6:  RCALL  364C
....................          write_ext_eeprom((long int)ptr_card++,mon); 
39C8:  MOVFF  23,03
39CC:  MOVFF  22,02
39D0:  MOVFF  21,01
39D4:  MOVFF  20,00
39D8:  MOVLW  01
39DA:  ADDWF  20,F
39DC:  BTFSC  FD8.0
39DE:  INCF   21,F
39E0:  BTFSC  FD8.2
39E2:  INCF   22,F
39E4:  BTFSC  FD8.2
39E6:  INCF   23,F
39E8:  MOVFF  01,AE8
39EC:  MOVFF  00,AE7
39F0:  MOVFF  01,B03
39F4:  MOVFF  00,B02
39F8:  MOVFF  FF,B04
39FC:  RCALL  364C
....................          write_ext_eeprom((long int)ptr_card++,h); 
39FE:  MOVFF  23,03
3A02:  MOVFF  22,02
3A06:  MOVFF  21,01
3A0A:  MOVFF  20,00
3A0E:  MOVLW  01
3A10:  ADDWF  20,F
3A12:  BTFSC  FD8.0
3A14:  INCF   21,F
3A16:  BTFSC  FD8.2
3A18:  INCF   22,F
3A1A:  BTFSC  FD8.2
3A1C:  INCF   23,F
3A1E:  MOVFF  01,AE8
3A22:  MOVFF  00,AE7
3A26:  MOVFF  01,B03
3A2A:  MOVFF  00,B02
3A2E:  MOVFF  101,B04
3A32:  RCALL  364C
....................          write_ext_eeprom((long int)ptr_card++,min); 
3A34:  MOVFF  23,03
3A38:  MOVFF  22,02
3A3C:  MOVFF  21,01
3A40:  MOVFF  20,00
3A44:  MOVLW  01
3A46:  ADDWF  20,F
3A48:  BTFSC  FD8.0
3A4A:  INCF   21,F
3A4C:  BTFSC  FD8.2
3A4E:  INCF   22,F
3A50:  BTFSC  FD8.2
3A52:  INCF   23,F
3A54:  MOVFF  01,AE8
3A58:  MOVFF  00,AE7
3A5C:  MOVFF  01,B03
3A60:  MOVFF  00,B02
3A64:  MOVFF  102,B04
3A68:  RCALL  364C
....................          write_ext_eeprom((long int)ptr_card++,sec);           
3A6A:  MOVFF  23,03
3A6E:  MOVFF  22,02
3A72:  MOVFF  21,01
3A76:  MOVFF  20,00
3A7A:  MOVLW  01
3A7C:  ADDWF  20,F
3A7E:  BTFSC  FD8.0
3A80:  INCF   21,F
3A82:  BTFSC  FD8.2
3A84:  INCF   22,F
3A86:  BTFSC  FD8.2
3A88:  INCF   23,F
3A8A:  MOVFF  01,AE8
3A8E:  MOVFF  00,AE7
3A92:  MOVFF  01,B03
3A96:  MOVFF  00,B02
3A9A:  MOVFF  103,B04
3A9E:  RCALL  364C
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
3AA0:  MOVLB  9
3AA2:  CLRF   x9C
3AA4:  CLRF   x9B
3AA6:  MOVF   x9C,F
3AA8:  BNZ   3B08
3AAA:  MOVF   x9B,W
3AAC:  SUBLW  4E
3AAE:  BNC   3B08
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
3AB0:  MOVFF  23,03
3AB4:  MOVFF  22,02
3AB8:  MOVFF  21,01
3ABC:  MOVFF  20,00
3AC0:  MOVLW  01
3AC2:  ADDWF  20,F
3AC4:  BTFSC  FD8.0
3AC6:  INCF   21,F
3AC8:  BTFSC  FD8.2
3ACA:  INCF   22,F
3ACC:  BTFSC  FD8.2
3ACE:  INCF   23,F
3AD0:  MOVFF  01,AE8
3AD4:  MOVFF  00,AE7
3AD8:  MOVLW  97
3ADA:  ADDWF  x9B,W
3ADC:  MOVWF  FE9
3ADE:  MOVLW  04
3AE0:  ADDWFC x9C,W
3AE2:  MOVWF  FEA
3AE4:  MOVF   FEF,W
3AE6:  ANDLW  3F
3AE8:  ADDLW  20
3AEA:  MOVLB  A
3AEC:  MOVWF  xE9
3AEE:  MOVFF  01,B03
3AF2:  MOVFF  00,B02
3AF6:  MOVFF  FE8,B04
3AFA:  MOVLB  0
3AFC:  RCALL  364C
....................              
....................          } 
3AFE:  MOVLB  9
3B00:  INCF   x9B,F
3B02:  BTFSC  FD8.2
3B04:  INCF   x9C,F
3B06:  BRA    3AA6
....................          del_buf(numbyteoftrack1,Track1); 
3B08:  MOVLW  4F
3B0A:  MOVLB  A
3B0C:  MOVWF  xF3
3B0E:  MOVLW  04
3B10:  MOVWF  xF5
3B12:  MOVLW  97
3B14:  MOVWF  xF4
3B16:  MOVLB  0
3B18:  CALL   3216
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
3B1C:  MOVLB  9
3B1E:  CLRF   x9C
3B20:  CLRF   x9B
3B22:  MOVF   x9C,F
3B24:  BNZ   3B84
3B26:  MOVF   x9B,W
3B28:  SUBLW  27
3B2A:  BNC   3B84
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
3B2C:  MOVFF  23,03
3B30:  MOVFF  22,02
3B34:  MOVFF  21,01
3B38:  MOVFF  20,00
3B3C:  MOVLW  01
3B3E:  ADDWF  20,F
3B40:  BTFSC  FD8.0
3B42:  INCF   21,F
3B44:  BTFSC  FD8.2
3B46:  INCF   22,F
3B48:  BTFSC  FD8.2
3B4A:  INCF   23,F
3B4C:  MOVFF  01,AE8
3B50:  MOVFF  00,AE7
3B54:  MOVLW  E6
3B56:  ADDWF  x9B,W
3B58:  MOVWF  FE9
3B5A:  MOVLW  04
3B5C:  ADDWFC x9C,W
3B5E:  MOVWF  FEA
3B60:  MOVF   FEF,W
3B62:  ANDLW  0F
3B64:  ADDLW  30
3B66:  MOVLB  A
3B68:  MOVWF  xE9
3B6A:  MOVFF  01,B03
3B6E:  MOVFF  00,B02
3B72:  MOVFF  FE8,B04
3B76:  MOVLB  0
3B78:  RCALL  364C
....................          }  
3B7A:  MOVLB  9
3B7C:  INCF   x9B,F
3B7E:  BTFSC  FD8.2
3B80:  INCF   x9C,F
3B82:  BRA    3B22
....................          del_buf(numbyteoftrack2,Track2); 
3B84:  MOVLW  28
3B86:  MOVLB  A
3B88:  MOVWF  xF3
3B8A:  MOVLW  04
3B8C:  MOVWF  xF5
3B8E:  MOVLW  E6
3B90:  MOVWF  xF4
3B92:  MOVLB  0
3B94:  CALL   3216
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
3B98:  MOVLW  0D
3B9A:  MOVLB  B
3B9C:  MOVWF  x16
3B9E:  MOVLB  0
3BA0:  CALL   0548
3BA4:  MOVLW  0A
3BA6:  MOVLB  B
3BA8:  MOVWF  x16
3BAA:  MOVLB  0
3BAC:  CALL   0548
....................       fprintf(COM2,"Done"); 
3BB0:  MOVLW  A0
3BB2:  MOVWF  FF6
3BB4:  MOVLW  04
3BB6:  MOVWF  FF7
3BB8:  CALL   058E
....................       if(KP_mode) 
3BBC:  MOVLB  1
3BBE:  MOVF   x0C,F
3BC0:  BZ    3BD8
....................       { 
....................          printf("\n\rKey release\n\r"); 
3BC2:  MOVLW  A6
3BC4:  MOVWF  FF6
3BC6:  MOVLW  04
3BC8:  MOVWF  FF7
3BCA:  MOVLB  0
3BCC:  CALL   058E
....................          keyprss_off; 
3BD0:  BCF    F92.7
3BD2:  BCF    F89.7
....................          kp_st=0; 
3BD4:  MOVLB  1
3BD6:  CLRF   x0D
....................       }   
....................       count_kp=0xffff; 
3BD8:  SETF   x0F
3BDA:  SETF   x0E
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
3BDC:  MOVLW  0D
3BDE:  MOVLB  B
3BE0:  MOVWF  x16
3BE2:  MOVLB  0
3BE4:  CALL   0548
3BE8:  MOVLW  0A
3BEA:  MOVLB  B
3BEC:  MOVWF  x16
3BEE:  MOVLB  0
3BF0:  CALL   0548
....................       fprintf(COM2,"Waiting for PIN number"); 
3BF4:  MOVLW  B6
3BF6:  MOVWF  FF6
3BF8:  MOVLW  04
3BFA:  MOVWF  FF7
3BFC:  CALL   058E
....................       fprintf(COM2,"\r\n"); 
3C00:  MOVLW  0D
3C02:  MOVLB  B
3C04:  MOVWF  x16
3C06:  MOVLB  0
3C08:  CALL   0548
3C0C:  MOVLW  0A
3C0E:  MOVLB  B
3C10:  MOVWF  x16
3C12:  MOVLB  0
3C14:  CALL   0548
....................       charac_timeout=0; 
3C18:  CLRF   xFC
3C1A:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
3C1C:  MOVFF  23,AEA
3C20:  MOVFF  22,AE9
3C24:  MOVFF  21,AE8
3C28:  MOVFF  20,AE7
3C2C:  MOVLW  19
3C2E:  MOVLB  A
3C30:  MOVWF  xEB
3C32:  MOVLB  0
3C34:  RCALL  3752
....................       datinbuf=0; 
3C36:  MOVLB  9
3C38:  CLRF   x9D
....................       saving_flag=0; 
3C3A:  CLRF   xA0
....................       data_avai=1; 
3C3C:  MOVLW  01
3C3E:  MOVWF  xA1
....................       enable_getpin=1; 
3C40:  MOVLB  1
3C42:  MOVWF  x09
....................       charac_timeout=0; 
3C44:  MOVLB  0
3C46:  CLRF   xFC
3C48:  CLRF   xFB
....................       key_count_ms=0; 
3C4A:  MOVLB  1
3C4C:  CLRF   x0B
3C4E:  MOVLB  A
3C50:  MOVLB  9
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
3C52:  MOVLB  0
3C54:  GOTO   3FA4 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
1BC4:  MOVLW  01
1BC6:  MOVLB  A
1BC8:  MOVWF  xE1
1BCA:  MOVWF  xE2
1BCC:  MOVWF  xE3
1BCE:  MOVWF  xE4
1BD0:  CLRF   xE5
1BD2:  MOVWF  xE6
1BD4:  MOVWF  xE7
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
1BD6:  MOVLB  9
1BD8:  CLRF   x9A
1BDA:  CLRF   x99
....................    mcr_timeout=0; 
1BDC:  CLRF   x8F
1BDE:  CLRF   x8E
1BE0:  CLRF   x8D
1BE2:  CLRF   x8C
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
1BE4:  MOVF   x9A,W
1BE6:  SUBLW  FD
1BE8:  BNC   1C06
1BEA:  BNZ   1BF2
1BEC:  MOVF   x99,W
1BEE:  SUBLW  E7
1BF0:  BNC   1C06
1BF2:  BSF    F93.1
1BF4:  BTFSS  F81.1
1BF6:  BRA    1C06
1BF8:  BSF    F94.5
1BFA:  BTFSS  F82.5
1BFC:  BRA    1C06
....................       card_timeout++; 
1BFE:  INCF   x99,F
1C00:  BTFSC  FD8.2
1C02:  INCF   x9A,F
....................    } 
1C04:  BRA    1BE4
....................    card_timeout=0; 
1C06:  CLRF   x9A
1C08:  CLRF   x99
....................    buffertrack1[bug_countbit_T1++]=0; 
1C0A:  MOVFF  996,03
1C0E:  MOVF   x95,W
1C10:  INCF   x95,F
1C12:  BTFSC  FD8.2
1C14:  INCF   x96,F
1C16:  MOVLB  A
1C18:  MOVWF  xEA
1C1A:  MOVLW  0E
1C1C:  ADDWF  xEA,W
1C1E:  MOVWF  FE9
1C20:  MOVLW  05
1C22:  ADDWFC 03,W
1C24:  MOVWF  FEA
1C26:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1C28:  MOVLB  9
1C2A:  MOVFF  996,03
1C2E:  MOVF   x95,W
1C30:  INCF   x95,F
1C32:  BTFSC  FD8.2
1C34:  INCF   x96,F
1C36:  MOVLB  A
1C38:  MOVWF  xEA
1C3A:  MOVLW  0E
1C3C:  ADDWF  xEA,W
1C3E:  MOVWF  FE9
1C40:  MOVLW  05
1C42:  ADDWFC 03,W
1C44:  MOVWF  FEA
1C46:  MOVLW  01
1C48:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1C4A:  MOVLB  9
1C4C:  MOVFF  998,03
1C50:  MOVF   x97,W
1C52:  INCF   x97,F
1C54:  BTFSC  FD8.2
1C56:  INCF   x98,F
1C58:  MOVLB  A
1C5A:  MOVWF  xEA
1C5C:  MOVLW  60
1C5E:  ADDWF  xEA,W
1C60:  MOVWF  FE9
1C62:  MOVLW  08
1C64:  ADDWFC 03,W
1C66:  MOVWF  FEA
1C68:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1C6A:  MOVLB  9
1C6C:  MOVFF  998,03
1C70:  MOVF   x97,W
1C72:  INCF   x97,F
1C74:  BTFSC  FD8.2
1C76:  INCF   x98,F
1C78:  MOVLB  A
1C7A:  MOVWF  xEA
1C7C:  MOVLW  60
1C7E:  ADDWF  xEA,W
1C80:  MOVWF  FE9
1C82:  MOVLW  08
1C84:  ADDWFC 03,W
1C86:  MOVWF  FEA
1C88:  MOVLW  01
1C8A:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1C8C:  MOVLB  9
1C8E:  MOVF   x96,W
1C90:  SUBLW  03
1C92:  BTFSS  FD8.0
1C94:  BRA    1D74
1C96:  BNZ   1CA0
1C98:  MOVF   x95,W
1C9A:  SUBLW  51
1C9C:  BTFSS  FD8.0
1C9E:  BRA    1D74
1CA0:  MOVF   x98,W
1CA2:  SUBLW  01
1CA4:  BTFSS  FD8.0
1CA6:  BRA    1D74
1CA8:  BNZ   1CB0
1CAA:  MOVF   x97,W
1CAC:  SUBLW  2B
1CAE:  BNC   1D74
1CB0:  MOVF   x9A,W
1CB2:  SUBLW  FF
1CB4:  BNC   1D74
1CB6:  BNZ   1CBE
1CB8:  MOVF   x99,W
1CBA:  SUBLW  DB
1CBC:  BNC   1D74
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
1CBE:  MOVF   xA3,F
1CC0:  BZ    1CCA
....................          { 
....................             bug_countbit_T1=0; 
1CC2:  CLRF   x96
1CC4:  CLRF   x95
....................             bug_countbit_T2=0; 
1CC6:  CLRF   x98
1CC8:  CLRF   x97
....................          } 
....................          card_timeout++; 
1CCA:  INCF   x99,F
1CCC:  BTFSC  FD8.2
1CCE:  INCF   x9A,F
....................          mcr_timeout=0; 
1CD0:  CLRF   x8F
1CD2:  CLRF   x8E
1CD4:  CLRF   x8D
1CD6:  CLRF   x8C
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1CD8:  BSF    F93.2
1CDA:  MOVLB  A
1CDC:  CLRF   xE1
1CDE:  BTFSC  F81.2
1CE0:  INCF   xE1,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1CE2:  MOVF   xE1,F
1CE4:  BNZ   1D22
1CE6:  DECFSZ xE2,W
1CE8:  BRA    1D22
....................          { 
....................             ST1_old = 0; 
1CEA:  CLRF   xE2
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1CEC:  MOVLW  0E
1CEE:  MOVLB  9
1CF0:  ADDWF  x95,W
1CF2:  MOVWF  FE9
1CF4:  MOVLW  05
1CF6:  ADDWFC x96,W
1CF8:  MOVWF  FEA
1CFA:  BSF    F93.1
1CFC:  MOVLW  00
1CFE:  BTFSS  F81.1
1D00:  MOVLW  01
1D02:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1D04:  MOVLW  60
1D06:  ADDWF  x97,W
1D08:  MOVWF  FE9
1D0A:  MOVLW  08
1D0C:  ADDWFC x98,W
1D0E:  MOVWF  FEA
1D10:  MOVFF  AE5,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1D14:  INCF   x95,F
1D16:  BTFSC  FD8.2
1D18:  INCF   x96,F
....................             card_timeout=0; 
1D1A:  CLRF   x9A
1D1C:  CLRF   x99
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1D1E:  BRA    1D2C
1D20:  MOVLB  A
1D22:  DECFSZ xE1,W
1D24:  BRA    1D2A
1D26:  MOVLW  01
1D28:  MOVWF  xE2
1D2A:  MOVLB  9
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1D2C:  BSF    F93.3
1D2E:  MOVLB  A
1D30:  CLRF   xE3
1D32:  BTFSC  F81.3
1D34:  INCF   xE3,F
....................          if(ST2 == 0 && ST2_old == 1) 
1D36:  MOVF   xE3,F
1D38:  BNZ   1D58
1D3A:  DECFSZ xE4,W
1D3C:  BRA    1D58
....................          { 
....................             ST2_old = 0; 
1D3E:  CLRF   xE4
....................             Bit_t2 = !input(MCR_DATA2); 
1D40:  BSF    F94.5
1D42:  CLRF   xE5
1D44:  BTFSS  F82.5
1D46:  INCF   xE5,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1D48:  MOVLB  9
1D4A:  INCF   x97,F
1D4C:  BTFSC  FD8.2
1D4E:  INCF   x98,F
....................             card_timeout=0; 
1D50:  CLRF   x9A
1D52:  CLRF   x99
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1D54:  BRA    1D62
1D56:  MOVLB  A
1D58:  DECFSZ xE3,W
1D5A:  BRA    1D60
1D5C:  MOVLW  01
1D5E:  MOVWF  xE4
1D60:  MOVLB  9
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1D62:  BSF    F93.0
1D64:  BTFSS  F81.0
1D66:  BRA    1D72
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1D68:  CLRF   xA3
....................             card_timeout=65500; 
1D6A:  SETF   x9A
1D6C:  MOVLW  DC
1D6E:  MOVWF  x99
....................             break;            
1D70:  BRA    1D74
....................          } 
....................       } 
1D72:  BRA    1C8E
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1D74:  CLRF   x9A
1D76:  CLRF   x99
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1D78:  MOVLB  A
1D7A:  CLRF   xF3
1D7C:  MOVFF  996,AF5
1D80:  MOVFF  995,AF4
1D84:  MOVLW  05
1D86:  MOVWF  xF7
1D88:  MOVLW  0E
1D8A:  MOVWF  xF6
1D8C:  MOVLB  0
1D8E:  CALL   0904
1D92:  MOVFF  01,AE6
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1D96:  MOVLW  01
1D98:  MOVLB  A
1D9A:  MOVWF  xF3
1D9C:  MOVFF  998,AF5
1DA0:  MOVFF  997,AF4
1DA4:  MOVLW  08
1DA6:  MOVWF  xF7
1DA8:  MOVLW  60
1DAA:  MOVWF  xF6
1DAC:  MOVLB  0
1DAE:  CALL   0904
1DB2:  MOVFF  01,AE7
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1DB6:  MOVLB  9
1DB8:  DECFSZ x9E,W
1DBA:  BRA    1E5C
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1DBC:  MOVLW  CE
1DBE:  MOVWF  FF6
1DC0:  MOVLW  04
1DC2:  MOVWF  FF7
1DC4:  MOVLW  0E
1DC6:  MOVLB  B
1DC8:  MOVWF  x0A
1DCA:  MOVLB  0
1DCC:  RCALL  1930
1DCE:  MOVLW  10
1DD0:  MOVWF  FE9
1DD2:  MOVFF  996,AEB
1DD6:  MOVFF  995,AEA
1DDA:  RCALL  195A
1DDC:  MOVLW  0D
1DDE:  MOVLB  B
1DE0:  MOVWF  x16
1DE2:  MOVLB  0
1DE4:  CALL   0548
1DE8:  MOVLW  0A
1DEA:  MOVLB  B
1DEC:  MOVWF  x16
1DEE:  MOVLB  0
1DF0:  CALL   0548
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1DF4:  MOVLW  E2
1DF6:  MOVWF  FF6
1DF8:  MOVLW  04
1DFA:  MOVWF  FF7
1DFC:  MOVLW  0E
1DFE:  MOVLB  B
1E00:  MOVWF  x0A
1E02:  MOVLB  0
1E04:  RCALL  1930
1E06:  MOVLW  10
1E08:  MOVWF  FE9
1E0A:  MOVFF  998,AEB
1E0E:  MOVFF  997,AEA
1E12:  RCALL  195A
1E14:  MOVLW  0D
1E16:  MOVLB  B
1E18:  MOVWF  x16
1E1A:  MOVLB  0
1E1C:  CALL   0548
1E20:  MOVLW  0A
1E22:  MOVLB  B
1E24:  MOVWF  x16
1E26:  MOVLB  0
1E28:  CALL   0548
....................          debug_reader();       
1E2C:  BRA    1B08
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1E2E:  MOVLB  A
1E30:  MOVF   xE6,F
1E32:  BNZ   1E44
1E34:  MOVLW  F6
1E36:  MOVWF  FF6
1E38:  MOVLW  04
1E3A:  MOVWF  FF7
1E3C:  MOVLB  0
1E3E:  CALL   058E
1E42:  MOVLB  A
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1E44:  MOVF   xE7,F
1E46:  BNZ   1E58
1E48:  MOVLW  0C
1E4A:  MOVWF  FF6
1E4C:  MOVLW  05
1E4E:  MOVWF  FF7
1E50:  MOVLB  0
1E52:  CALL   058E
1E56:  MOVLB  A
....................       } 
....................          else 
1E58:  BRA    1E68
1E5A:  MOVLB  9
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1E5C:  MOVLW  0F
1E5E:  MOVLB  A
1E60:  MOVWF  xEA
1E62:  MOVLB  0
1E64:  RCALL  1B9C
1E66:  MOVLB  A
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1E68:  MOVF   xE6,F
1E6A:  BZ    1E70
1E6C:  MOVF   xE7,F
1E6E:  BNZ   1E90
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1E70:  MOVLB  9
1E72:  CLRF   x98
1E74:  CLRF   x97
....................          bug_countbit_T1=0; 
1E76:  CLRF   x96
1E78:  CLRF   x95
....................          reading_fg=0; 
1E7A:  CLRF   xA2
....................          count_reading_error++; 
1E7C:  INCF   xA3,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1E7E:  CLRF   x8F
1E80:  CLRF   x8E
1E82:  CLRF   x8D
1E84:  CLRF   x8C
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1E86:  MOVLW  00
1E88:  MOVWF  01
1E8A:  BRA    1EC8
....................       } 
....................          else  
1E8C:  BRA    1EC4
1E8E:  MOVLB  A
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1E90:  MOVLW  01
1E92:  MOVLB  9
1E94:  MOVWF  x9D
....................             reading_fg=1; 
1E96:  MOVWF  xA2
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1E98:  MOVFF  998,994
1E9C:  MOVFF  997,993
....................             countbit_T1=bug_countbit_T1; 
1EA0:  MOVFF  996,992
1EA4:  MOVFF  995,991
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1EA8:  CLRF   x96
1EAA:  CLRF   x95
....................             bug_countbit_T2=0;  
1EAC:  CLRF   x98
1EAE:  CLRF   x97
....................             mcr_timeout=0; 
1EB0:  CLRF   x8F
1EB2:  CLRF   x8E
1EB4:  CLRF   x8D
1EB6:  CLRF   x8C
....................             charac_timeout=0; 
1EB8:  MOVLB  0
1EBA:  CLRF   xFC
1EBC:  CLRF   xFB
....................             return 1; 
1EBE:  MOVWF  01
1EC0:  MOVLB  9
1EC2:  BRA    1EC8
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1EC4:  MOVLW  00
1EC6:  MOVWF  01
.................... } 
1EC8:  MOVLB  0
1ECA:  GOTO   1F32 (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
1ECE:  MOVLW  02
1ED0:  MOVLB  A
1ED2:  MOVWF  xE1
1ED4:  MOVLW  FA
1ED6:  MOVWF  xE2
1ED8:  MOVLB  0
1EDA:  GOTO   0522
1EDE:  MOVLB  A
1EE0:  DECFSZ xE1,F
1EE2:  BRA    1ED4
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
1EE4:  MOVLB  9
1EE6:  DECFSZ xA0,W
1EE8:  BRA    1EEC
1EEA:  BRA    1F44
....................       if((KP_mode)&&(enable_getpin==0)) 
1EEC:  MOVLB  1
1EEE:  MOVF   x0C,F
1EF0:  BZ    1F2E
1EF2:  MOVF   x09,F
1EF4:  BNZ   1F2E
....................       { 
....................          if(kp_st==1) 
1EF6:  DECFSZ x0D,W
1EF8:  BRA    1F12
....................          { 
....................             printf("\n\rKey release\n\r"); 
1EFA:  MOVLW  4C
1EFC:  MOVWF  FF6
1EFE:  MOVLW  1F
1F00:  MOVWF  FF7
1F02:  MOVLB  0
1F04:  CALL   058E
....................             keyprss_off; 
1F08:  BCF    F92.7
1F0A:  BCF    F89.7
....................             kp_st=0; 
1F0C:  MOVLB  1
1F0E:  CLRF   x0D
....................          } 
....................          else 
1F10:  BRA    1F2E
....................          { 
....................             printf("\n\rKey press\n\r"); 
1F12:  MOVLW  5C
1F14:  MOVWF  FF6
1F16:  MOVLW  1F
1F18:  MOVWF  FF7
1F1A:  MOVLB  0
1F1C:  CALL   058E
....................             keyprss_on; 
1F20:  BCF    F92.7
1F22:  BSF    F89.7
....................             kp_st=1;  
1F24:  MOVLW  01
1F26:  MOVLB  1
1F28:  MOVWF  x0D
....................             count_kp=0; 
1F2A:  CLRF   x0F
1F2C:  CLRF   x0E
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1F2E:  MOVLB  0
1F30:  BRA    1BC4
1F32:  MOVFF  01,99F
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1F36:  MOVLB  9
1F38:  CLRF   x8F
1F3A:  CLRF   x8E
1F3C:  CLRF   x8D
1F3E:  CLRF   x8C
....................       card_timeout=0; 
1F40:  CLRF   x9A
1F42:  CLRF   x99
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1F44:  BCF    FF0.0
1F46:  MOVLB  0
1F48:  GOTO   0084
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
4ACE:  CLRF   19
4AD0:  BTFSC  FF2.7
4AD2:  BSF    19.7
4AD4:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
4AD6:  MOVLB  B
4AD8:  CLRF   x03
4ADA:  MOVLW  94
4ADC:  MOVWF  x02
4ADE:  MOVLW  03
4AE0:  MOVWF  x04
4AE2:  MOVLB  0
4AE4:  CALL   364C
4AE8:  BTFSC  19.7
4AEA:  BSF    FF2.7
4AEC:  CLRF   19
4AEE:  BTFSC  FF2.7
4AF0:  BSF    19.7
4AF2:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaykb,100); 
4AF4:  MOVLB  B
4AF6:  CLRF   x03
4AF8:  MOVLW  95
4AFA:  MOVWF  x02
4AFC:  MOVLW  64
4AFE:  MOVWF  x04
4B00:  MOVLB  0
4B02:  CALL   364C
4B06:  BTFSC  19.7
4B08:  BSF    FF2.7
4B0A:  CLRF   19
4B0C:  BTFSC  FF2.7
4B0E:  BSF    19.7
4B10:  BCF    FF2.7
....................    write_ext_eeprom(KB_time,2); 
4B12:  MOVLB  B
4B14:  CLRF   x03
4B16:  MOVLW  7E
4B18:  MOVWF  x02
4B1A:  MOVLW  02
4B1C:  MOVWF  x04
4B1E:  MOVLB  0
4B20:  CALL   364C
4B24:  BTFSC  19.7
4B26:  BSF    FF2.7
4B28:  CLRF   19
4B2A:  BTFSC  FF2.7
4B2C:  BSF    19.7
4B2E:  BCF    FF2.7
....................    write_ext_eeprom(strobe_Master_SLV,1);    
4B30:  MOVLB  B
4B32:  CLRF   x03
4B34:  MOVLW  91
4B36:  MOVWF  x02
4B38:  MOVLW  01
4B3A:  MOVWF  x04
4B3C:  MOVLB  0
4B3E:  CALL   364C
4B42:  BTFSC  19.7
4B44:  BSF    FF2.7
4B46:  CLRF   19
4B48:  BTFSC  FF2.7
4B4A:  BSF    19.7
4B4C:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
4B4E:  MOVLB  A
4B50:  CLRF   xEE
4B52:  MOVLW  91
4B54:  MOVWF  xED
4B56:  MOVLB  0
4B58:  CALL   30FC
4B5C:  BTFSC  19.7
4B5E:  BSF    FF2.7
4B60:  MOVFF  01,9AA
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
....................    #endif 
....................     
.................... } 
4B64:  GOTO   5452 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
*
4E10:  MOVLW  09
4E12:  MOVWF  FEA
4E14:  MOVLW  AF
4E16:  MOVWF  FE9
4E18:  BRA    46EA
4E1A:  CLRF   19
4E1C:  BTFSC  FF2.7
4E1E:  BSF    19.7
4E20:  BCF    FF2.7
4E22:  MOVLW  3E
4E24:  MOVLB  B
4E26:  MOVWF  x16
4E28:  MOVLB  0
4E2A:  CALL   0548
4E2E:  BTFSC  19.7
4E30:  BSF    FF2.7
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
4E32:  MOVLW  01
4E34:  MOVLB  A
4E36:  MOVWF  xBD
4E38:  MOVLW  14
4E3A:  MOVWF  xBE
4E3C:  MOVLW  01
4E3E:  MOVWF  xC0
4E40:  MOVLW  4A
4E42:  MOVWF  xBF
4E44:  MOVLB  0
4E46:  CALL   451A
4E4A:  CLRF   19
4E4C:  BTFSC  FF2.7
4E4E:  BSF    19.7
4E50:  BCF    FF2.7
....................       printf("\n\r"); 
4E52:  MOVLW  0A
4E54:  MOVLB  B
4E56:  MOVWF  x16
4E58:  MOVLB  0
4E5A:  CALL   0548
4E5E:  BTFSC  19.7
4E60:  BSF    FF2.7
4E62:  CLRF   19
4E64:  BTFSC  FF2.7
4E66:  BSF    19.7
4E68:  BCF    FF2.7
4E6A:  MOVLW  0D
4E6C:  MOVLB  B
4E6E:  MOVWF  x16
4E70:  MOVLB  0
4E72:  CALL   0548
4E76:  BTFSC  19.7
4E78:  BSF    FF2.7
....................       strcpy(buffer2,"d"); 
4E7A:  CLRF   FEA
4E7C:  MOVLW  41
4E7E:  MOVWF  FE9
4E80:  MOVLW  00
4E82:  CALL   010C
4E86:  TBLRD*-
4E88:  TBLRD*+
4E8A:  MOVF   FF5,W
4E8C:  MOVWF  FEE
4E8E:  IORLW  00
4E90:  BNZ   4E88
....................       index=0; 
4E92:  MOVLB  A
4E94:  CLRF   x87
....................       ee_dat=0; 
4E96:  MOVLB  9
4E98:  CLRF   xA5
....................       count_card=1; 
4E9A:  CLRF   xA7
4E9C:  MOVLW  01
4E9E:  MOVWF  xA6
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
4EA0:  MOVLB  A
4EA2:  MOVWF  xBE
4EA4:  MOVLW  4A
4EA6:  MOVWF  xBD
4EA8:  CLRF   xC0
4EAA:  MOVLW  41
4EAC:  MOVWF  xBF
4EAE:  MOVLB  0
4EB0:  CALL   4652
4EB4:  MOVF   01,F
4EB6:  BTFSS  FD8.2
4EB8:  BRA    527C
....................       { 
....................          unsigned long adr=0; 
4EBA:  MOVLB  A
4EBC:  CLRF   xBC
4EBE:  CLRF   xBB
....................          //unsigned int count=0; 
....................          rec[0]=0; 
4EC0:  MOVLB  0
4EC2:  CLRF   x7D
4EC4:  CLRF   19
4EC6:  BTFSC  FF2.7
4EC8:  BSF    19.7
4ECA:  BCF    FF2.7
....................          count_card_tg=get_countcard(); 
4ECC:  CALL   31A4
4ED0:  BTFSC  19.7
4ED2:  BSF    FF2.7
4ED4:  MOVFF  02,9A9
4ED8:  MOVFF  01,9A8
4EDC:  CLRF   19
4EDE:  BTFSC  FF2.7
4EE0:  BSF    19.7
4EE2:  BCF    FF2.7
....................          adr=count_card*numdata; 
4EE4:  MOVFF  9A7,AEA
4EE8:  MOVFF  9A6,AE9
4EEC:  MOVLB  A
4EEE:  CLRF   xEC
4EF0:  MOVLW  7C
4EF2:  MOVWF  xEB
4EF4:  MOVLB  0
4EF6:  CALL   31F4
4EFA:  BTFSC  19.7
4EFC:  BSF    FF2.7
4EFE:  MOVFF  02,ABC
4F02:  MOVFF  01,ABB
....................          addr_key=EEPROM_KEY_ST; 
4F06:  MOVLB  9
4F08:  CLRF   xAE
4F0A:  CLRF   xAD
4F0C:  MOVLW  AA
4F0E:  MOVWF  xAC
4F10:  MOVLW  47
4F12:  MOVWF  xAB
....................          while(count_card<=count_card_tg) 
....................          { 
4F14:  MOVF   xA7,W
4F16:  SUBWF  xA9,W
4F18:  BTFSS  FD8.0
4F1A:  BRA    527A
4F1C:  BNZ   4F26
4F1E:  MOVF   xA6,W
4F20:  SUBWF  xA8,W
4F22:  BTFSS  FD8.0
4F24:  BRA    527A
4F26:  CLRF   19
4F28:  BTFSC  FF2.7
4F2A:  BSF    19.7
4F2C:  BCF    FF2.7
....................             adr=count_card*numdata+ptr_start; 
4F2E:  MOVFF  9A7,AEA
4F32:  MOVFF  9A6,AE9
4F36:  MOVLB  A
4F38:  CLRF   xEC
4F3A:  MOVLW  7C
4F3C:  MOVWF  xEB
4F3E:  MOVLB  0
4F40:  CALL   31F4
4F44:  BTFSC  19.7
4F46:  BSF    FF2.7
4F48:  MOVLW  96
4F4A:  MOVLB  A
4F4C:  ADDWF  01,W
4F4E:  MOVWF  xBB
4F50:  MOVLW  00
4F52:  ADDWFC 02,W
4F54:  MOVWF  xBC
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
4F56:  MOVLW  7C
4F58:  SUBWF  xBB,W
4F5A:  MOVWF  xBD
4F5C:  MOVLW  00
4F5E:  SUBWFB xBC,W
4F60:  MOVWF  xBE
4F62:  MOVWF  xC0
4F64:  MOVFF  ABD,ABF
4F68:  CLRF   xC2
4F6A:  MOVLW  7C
4F6C:  MOVWF  xC1
4F6E:  CLRF   xC4
4F70:  MOVLW  7D
4F72:  MOVWF  xC3
4F74:  MOVLB  0
4F76:  GOTO   471E
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
4F7A:  MOVLW  10
4F7C:  MOVWF  FE9
4F7E:  CLRF   19
4F80:  BTFSC  FF2.7
4F82:  BSF    19.7
4F84:  BCF    FF2.7
4F86:  MOVFF  9A7,AE5
4F8A:  MOVFF  9A6,AE4
4F8E:  CALL   3DF6
4F92:  BTFSC  19.7
4F94:  BSF    FF2.7
4F96:  CLRF   19
4F98:  BTFSC  FF2.7
4F9A:  BSF    19.7
4F9C:  BCF    FF2.7
4F9E:  MOVLW  29
4FA0:  MOVLB  B
4FA2:  MOVWF  x16
4FA4:  MOVLB  0
4FA6:  CALL   0548
4FAA:  BTFSC  19.7
4FAC:  BSF    FF2.7
4FAE:  MOVFF  7D,ABD
4FB2:  MOVLW  01
4FB4:  MOVLB  A
4FB6:  MOVWF  xBE
4FB8:  MOVLB  0
4FBA:  CALL   47A4
4FBE:  CLRF   19
4FC0:  BTFSC  FF2.7
4FC2:  BSF    19.7
4FC4:  BCF    FF2.7
4FC6:  MOVLW  2F
4FC8:  MOVLB  B
4FCA:  MOVWF  x16
4FCC:  MOVLB  0
4FCE:  CALL   0548
4FD2:  BTFSC  19.7
4FD4:  BSF    FF2.7
4FD6:  MOVFF  7E,ABD
4FDA:  MOVLW  01
4FDC:  MOVLB  A
4FDE:  MOVWF  xBE
4FE0:  MOVLB  0
4FE2:  CALL   47A4
4FE6:  CLRF   19
4FE8:  BTFSC  FF2.7
4FEA:  BSF    19.7
4FEC:  BCF    FF2.7
4FEE:  MOVLW  20
4FF0:  MOVLB  B
4FF2:  MOVWF  x16
4FF4:  MOVLB  0
4FF6:  CALL   0548
4FFA:  BTFSC  19.7
4FFC:  BSF    FF2.7
4FFE:  MOVFF  7F,ABD
5002:  MOVLW  01
5004:  MOVLB  A
5006:  MOVWF  xBE
5008:  MOVLB  0
500A:  CALL   47A4
500E:  CLRF   19
5010:  BTFSC  FF2.7
5012:  BSF    19.7
5014:  BCF    FF2.7
5016:  MOVLW  3A
5018:  MOVLB  B
501A:  MOVWF  x16
501C:  MOVLB  0
501E:  CALL   0548
5022:  BTFSC  19.7
5024:  BSF    FF2.7
5026:  MOVFF  80,ABD
502A:  MOVLW  01
502C:  MOVLB  A
502E:  MOVWF  xBE
5030:  MOVLB  0
5032:  CALL   47A4
5036:  CLRF   19
5038:  BTFSC  FF2.7
503A:  BSF    19.7
503C:  BCF    FF2.7
503E:  MOVLW  3A
5040:  MOVLB  B
5042:  MOVWF  x16
5044:  MOVLB  0
5046:  CALL   0548
504A:  BTFSC  19.7
504C:  BSF    FF2.7
504E:  MOVFF  81,ABD
5052:  MOVLW  01
5054:  MOVLB  A
5056:  MOVWF  xBE
5058:  MOVLB  0
505A:  CALL   47A4
....................             ee_dat=0; 
505E:  MOVLB  9
5060:  CLRF   xA5
....................             index=0; 
5062:  MOVLB  A
5064:  CLRF   x87
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
5066:  MOVLW  8E
5068:  MOVWF  FF6
506A:  MOVLW  1F
506C:  MOVWF  FF7
506E:  CLRF   19
5070:  BTFSC  FF2.7
5072:  BSF    19.7
5074:  BCF    FF2.7
5076:  MOVLB  0
5078:  CALL   058E
507C:  BTFSC  19.7
507E:  BSF    FF2.7
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
5080:  MOVLB  A
5082:  MOVF   x87,W
5084:  SUBLW  4E
5086:  BNC   50E4
5088:  MOVLB  9
508A:  MOVF   xA5,W
508C:  SUBLW  3F
508E:  BTFSS  FD8.2
5090:  BRA    5096
5092:  MOVLB  A
5094:  BRA    50E4
....................                ee_dat = rec[index+5]; 
5096:  MOVLW  05
5098:  MOVLB  A
509A:  ADDWF  x87,W
509C:  CLRF   03
509E:  ADDLW  7D
50A0:  MOVWF  FE9
50A2:  MOVLW  00
50A4:  ADDWFC 03,W
50A6:  MOVWF  FEA
50A8:  MOVFF  FEF,9A5
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
50AC:  MOVLB  9
50AE:  MOVF   xA5,W
50B0:  SUBLW  1F
50B2:  BC    50D0
50B4:  MOVF   xA5,W
50B6:  SUBLW  7E
50B8:  BNC   50D0
50BA:  CLRF   19
50BC:  BTFSC  FF2.7
50BE:  BSF    19.7
50C0:  BCF    FF2.7
50C2:  MOVFF  9A5,B16
50C6:  MOVLB  0
50C8:  CALL   0548
50CC:  BTFSC  19.7
50CE:  BSF    FF2.7
....................                index++; 
50D0:  MOVLB  A
50D2:  INCF   x87,F
....................                if(ee_dat==0)break; 
50D4:  MOVLB  9
50D6:  MOVF   xA5,F
50D8:  BNZ   50DE
50DA:  MOVLB  A
50DC:  BRA    50E4
....................             } 
50DE:  MOVLB  0
50E0:  BRA    5080
50E2:  MOVLB  A
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
50E4:  MOVLW  A0
50E6:  MOVWF  FF6
50E8:  MOVLW  1F
50EA:  MOVWF  FF7
50EC:  CLRF   19
50EE:  BTFSC  FF2.7
50F0:  BSF    19.7
50F2:  BCF    FF2.7
50F4:  MOVLB  0
50F6:  CALL   058E
50FA:  BTFSC  19.7
50FC:  BSF    FF2.7
....................             index=0; 
50FE:  MOVLB  A
5100:  CLRF   x87
....................             ee_dat=0; 
5102:  MOVLB  9
5104:  CLRF   xA5
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
5106:  MOVLB  A
5108:  MOVF   x87,W
510A:  SUBLW  27
510C:  BNC   516C
510E:  MOVLB  9
5110:  MOVF   xA5,W
5112:  SUBLW  3F
5114:  BTFSS  FD8.2
5116:  BRA    511C
5118:  MOVLB  A
511A:  BRA    516C
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
511C:  MOVLW  05
511E:  MOVLB  A
5120:  ADDWF  x87,W
5122:  ADDLW  4F
5124:  CLRF   03
5126:  ADDLW  7D
5128:  MOVWF  FE9
512A:  MOVLW  00
512C:  ADDWFC 03,W
512E:  MOVWF  FEA
5130:  MOVFF  FEF,9A5
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
5134:  MOVLB  9
5136:  MOVF   xA5,W
5138:  SUBLW  1F
513A:  BC    5158
513C:  MOVF   xA5,W
513E:  SUBLW  7E
5140:  BNC   5158
5142:  CLRF   19
5144:  BTFSC  FF2.7
5146:  BSF    19.7
5148:  BCF    FF2.7
514A:  MOVFF  9A5,B16
514E:  MOVLB  0
5150:  CALL   0548
5154:  BTFSC  19.7
5156:  BSF    FF2.7
....................                index++; 
5158:  MOVLB  A
515A:  INCF   x87,F
....................                if(ee_dat==0)break; 
515C:  MOVLB  9
515E:  MOVF   xA5,F
5160:  BNZ   5168
5162:  MOVLB  A
5164:  BRA    516C
5166:  MOVLB  9
....................             } 
5168:  BRA    5106
516A:  MOVLB  A
....................             index=0; 
516C:  CLRF   x87
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
516E:  MOVLW  B2
5170:  MOVWF  FF6
5172:  MOVLW  1F
5174:  MOVWF  FF7
5176:  CLRF   19
5178:  BTFSC  FF2.7
517A:  BSF    19.7
517C:  BCF    FF2.7
517E:  MOVLB  0
5180:  CALL   058E
5184:  BTFSC  19.7
5186:  BSF    FF2.7
....................             if(ptr_card_key>addr_key) 
5188:  MOVLB  9
518A:  MOVF   xAE,W
518C:  SUBWF  27,W
518E:  BTFSS  FD8.0
5190:  BRA    5272
5192:  BNZ   51AC
5194:  MOVF   xAD,W
5196:  SUBWF  26,W
5198:  BTFSS  FD8.0
519A:  BRA    5272
519C:  BNZ   51AC
519E:  MOVF   xAC,W
51A0:  SUBWF  25,W
51A2:  BNC   5272
51A4:  BNZ   51AC
51A6:  MOVF   24,W
51A8:  SUBWF  xAB,W
51AA:  BC    5272
....................             { 
....................                i=0; 
51AC:  MOVLB  A
51AE:  CLRF   x88
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
51B0:  MOVF   x88,W
51B2:  MOVLB  9
51B4:  ADDWF  xAB,W
51B6:  MOVLB  A
51B8:  MOVWF  xBD
51BA:  MOVLW  00
51BC:  MOVLB  9
51BE:  ADDWFC xAC,W
51C0:  MOVLB  A
51C2:  MOVWF  xBE
51C4:  CLRF   19
51C6:  BTFSC  FF2.7
51C8:  BSF    19.7
51CA:  BCF    FF2.7
51CC:  MOVWF  xEE
51CE:  MOVFF  ABD,AED
51D2:  MOVLB  0
51D4:  CALL   30FC
51D8:  BTFSC  19.7
51DA:  BSF    FF2.7
51DC:  MOVFF  01,9A5
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<73)) 
51E0:  MOVLB  9
51E2:  MOVF   xA5,W
51E4:  SUBLW  2F
51E6:  BC    51EE
51E8:  MOVF   xA5,W
51EA:  SUBLW  39
51EC:  BC    5206
51EE:  MOVF   xA5,W
51F0:  SUBLW  23
51F2:  BZ    5206
51F4:  MOVF   xA5,W
51F6:  SUBLW  2A
51F8:  BZ    5206
51FA:  MOVF   xA5,W
51FC:  SUBLW  40
51FE:  BC    521C
5200:  MOVF   xA5,W
5202:  SUBLW  48
5204:  BNC   521C
5206:  CLRF   19
5208:  BTFSC  FF2.7
520A:  BSF    19.7
520C:  BCF    FF2.7
....................                      fputc(ee_dat,COM2); 
520E:  MOVFF  9A5,B16
5212:  MOVLB  0
5214:  CALL   0548
5218:  BTFSC  19.7
521A:  BSF    FF2.7
....................                   i++; 
521C:  MOVLB  A
521E:  INCF   x88,F
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
5220:  MOVF   x88,W
5222:  SUBLW  31
5224:  BNC   5232
5226:  MOVLB  9
5228:  MOVF   xA5,F
522A:  BTFSC  FD8.2
522C:  BRA    5232
522E:  MOVLB  A
5230:  BRA    51B0
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+50; 
5232:  MOVLW  32
5234:  MOVLB  9
5236:  ADDWF  xAB,F
5238:  MOVLW  00
523A:  ADDWFC xAC,F
523C:  ADDWFC xAD,F
523E:  ADDWFC xAE,F
5240:  CLRF   19
5242:  BTFSC  FF2.7
5244:  BSF    19.7
5246:  BCF    FF2.7
....................                fprintf(COM2,"\n\r"); 
5248:  MOVLW  0A
524A:  MOVLB  B
524C:  MOVWF  x16
524E:  MOVLB  0
5250:  CALL   0548
5254:  BTFSC  19.7
5256:  BSF    FF2.7
5258:  CLRF   19
525A:  BTFSC  FF2.7
525C:  BSF    19.7
525E:  BCF    FF2.7
5260:  MOVLW  0D
5262:  MOVLB  B
5264:  MOVWF  x16
5266:  MOVLB  0
5268:  CALL   0548
526C:  BTFSC  19.7
526E:  BSF    FF2.7
5270:  MOVLB  9
....................             } 
....................             count_card++; 
5272:  INCF   xA6,F
5274:  BTFSC  FD8.2
5276:  INCF   xA7,F
....................          } 
5278:  BRA    4F14
527A:  MOVLB  0
....................       }  
....................       strcpy(buffer2,"f"); 
527C:  CLRF   FEA
527E:  MOVLW  41
5280:  MOVWF  FE9
5282:  MOVLW  00
5284:  CALL   011E
5288:  TBLRD*-
528A:  TBLRD*+
528C:  MOVF   FF5,W
528E:  MOVWF  FEE
5290:  IORLW  00
5292:  BNZ   528A
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5294:  MOVLW  01
5296:  MOVLB  A
5298:  MOVWF  xBE
529A:  MOVLW  4A
529C:  MOVWF  xBD
529E:  CLRF   xC0
52A0:  MOVLW  41
52A2:  MOVWF  xBF
52A4:  MOVLB  0
52A6:  CALL   4652
52AA:  MOVF   01,F
52AC:  BNZ   52E2
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
52AE:  MOVLW  C2
52B0:  MOVWF  FF6
52B2:  MOVLW  1F
52B4:  MOVWF  FF7
52B6:  CLRF   19
52B8:  BTFSC  FF2.7
52BA:  BSF    19.7
52BC:  BCF    FF2.7
52BE:  CALL   058E
52C2:  BTFSC  19.7
52C4:  BSF    FF2.7
....................          format_eepromext(); 
52C6:  GOTO   48BA
....................          fprintf(COM2," exit\n\r");  
52CA:  MOVLW  D0
52CC:  MOVWF  FF6
52CE:  MOVLW  1F
52D0:  MOVWF  FF7
52D2:  CLRF   19
52D4:  BTFSC  FF2.7
52D6:  BSF    19.7
52D8:  BCF    FF2.7
52DA:  CALL   058E
52DE:  BTFSC  19.7
52E0:  BSF    FF2.7
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
52E2:  CLRF   FEA
52E4:  MOVLW  41
52E6:  MOVWF  FE9
52E8:  MOVLW  00
52EA:  CALL   0130
52EE:  TBLRD*-
52F0:  TBLRD*+
52F2:  MOVF   FF5,W
52F4:  MOVWF  FEE
52F6:  IORLW  00
52F8:  BNZ   52F0
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
52FA:  MOVLW  01
52FC:  MOVLB  A
52FE:  MOVWF  xBE
5300:  MOVLW  4A
5302:  MOVWF  xBD
5304:  CLRF   xC0
5306:  MOVLW  41
5308:  MOVWF  xBF
530A:  MOVLB  0
530C:  CALL   4652
5310:  MOVF   01,F
5312:  BNZ   5348
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
5314:  MOVLW  D8
5316:  MOVWF  FF6
5318:  MOVLW  1F
531A:  MOVWF  FF7
531C:  CLRF   19
531E:  BTFSC  FF2.7
5320:  BSF    19.7
5322:  BCF    FF2.7
5324:  CALL   058E
5328:  BTFSC  19.7
532A:  BSF    FF2.7
....................          ease_eeprom(); 
532C:  GOTO   49DE
....................          fprintf(COM2," exit\n\r");  
5330:  MOVLW  E6
5332:  MOVWF  FF6
5334:  MOVLW  1F
5336:  MOVWF  FF7
5338:  CLRF   19
533A:  BTFSC  FF2.7
533C:  BSF    19.7
533E:  BCF    FF2.7
5340:  CALL   058E
5344:  BTFSC  19.7
5346:  BSF    FF2.7
....................       }     
....................      strcpy(buffer2,"RSPW"); 
5348:  CLRF   FEA
534A:  MOVLW  41
534C:  MOVWF  FE9
534E:  MOVLW  00
5350:  CALL   0146
5354:  TBLRD*-
5356:  TBLRD*+
5358:  MOVF   FF5,W
535A:  MOVWF  FEE
535C:  IORLW  00
535E:  BNZ   5356
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
5360:  MOVLW  01
5362:  MOVLB  A
5364:  MOVWF  xBE
5366:  MOVLW  4A
5368:  MOVWF  xBD
536A:  CLRF   xC0
536C:  MOVLW  41
536E:  MOVWF  xBF
5370:  MOVLB  0
5372:  CALL   4652
5376:  MOVF   01,F
5378:  BNZ   53B2
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
537A:  MOVLW  EE
537C:  MOVWF  FF6
537E:  MOVLW  1F
5380:  MOVWF  FF7
5382:  CLRF   19
5384:  BTFSC  FF2.7
5386:  BSF    19.7
5388:  BCF    FF2.7
538A:  CALL   058E
538E:  BTFSC  19.7
5390:  BSF    FF2.7
....................          reset_password(); 
5392:  GOTO   4A98
....................          init_password(); 
5396:  CALL   420A
....................          fprintf(COM2," exit\n\r");  
539A:  MOVLW  04
539C:  MOVWF  FF6
539E:  MOVLW  20
53A0:  MOVWF  FF7
53A2:  CLRF   19
53A4:  BTFSC  FF2.7
53A6:  BSF    19.7
53A8:  BCF    FF2.7
53AA:  CALL   058E
53AE:  BTFSC  19.7
53B0:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
53B2:  CLRF   FEA
53B4:  MOVLW  41
53B6:  MOVWF  FE9
53B8:  MOVLW  00
53BA:  CALL   015C
53BE:  TBLRD*-
53C0:  TBLRD*+
53C2:  MOVF   FF5,W
53C4:  MOVWF  FEE
53C6:  IORLW  00
53C8:  BNZ   53C0
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
53CA:  MOVLW  01
53CC:  MOVLB  A
53CE:  MOVWF  xBE
53D0:  MOVLW  4A
53D2:  MOVWF  xBD
53D4:  CLRF   xC0
53D6:  MOVLW  41
53D8:  MOVWF  xBF
53DA:  MOVLB  0
53DC:  CALL   4652
53E0:  MOVF   01,F
53E2:  BNZ   5404
....................       { 
....................          keydebug_en=1; 
53E4:  MOVLW  01
53E6:  MOVLB  1
53E8:  MOVWF  x08
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
53EA:  MOVLW  0C
53EC:  MOVWF  FF6
53EE:  MOVLW  20
53F0:  MOVWF  FF7
53F2:  CLRF   19
53F4:  BTFSC  FF2.7
53F6:  BSF    19.7
53F8:  BCF    FF2.7
53FA:  MOVLB  0
53FC:  CALL   058E
5400:  BTFSC  19.7
5402:  BSF    FF2.7
....................       }   
....................       strcpy(buffer2,"rsfact"); 
5404:  CLRF   FEA
5406:  MOVLW  41
5408:  MOVWF  FE9
540A:  MOVLW  00
540C:  CALL   0172
5410:  TBLRD*-
5412:  TBLRD*+
5414:  MOVF   FF5,W
5416:  MOVWF  FEE
5418:  IORLW  00
541A:  BNZ   5412
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
541C:  MOVLW  01
541E:  MOVLB  A
5420:  MOVWF  xBE
5422:  MOVLW  4A
5424:  MOVWF  xBD
5426:  CLRF   xC0
5428:  MOVLW  41
542A:  MOVWF  xBF
542C:  MOVLB  0
542E:  CALL   4652
5432:  MOVF   01,F
5434:  BNZ   5452
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
5436:  MOVLW  20
5438:  MOVWF  FF6
543A:  MOVLW  20
543C:  MOVWF  FF7
543E:  CLRF   19
5440:  BTFSC  FF2.7
5442:  BSF    19.7
5444:  BCF    FF2.7
5446:  CALL   058E
544A:  BTFSC  19.7
544C:  BSF    FF2.7
....................          rstfact(); 
544E:  GOTO   4ACE
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
5452:  CLRF   FEA
5454:  MOVLW  41
5456:  MOVWF  FE9
5458:  MOVLW  00
545A:  CALL   018A
545E:  TBLRD*-
5460:  TBLRD*+
5462:  MOVF   FF5,W
5464:  MOVWF  FEE
5466:  IORLW  00
5468:  BNZ   5460
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
546A:  MOVLW  01
546C:  MOVLB  A
546E:  MOVWF  xBE
5470:  MOVLW  4A
5472:  MOVWF  xBD
5474:  CLRF   xC0
5476:  MOVLW  41
5478:  MOVWF  xBF
547A:  MOVLB  0
547C:  CALL   4652
5480:  MOVF   01,F
5482:  BNZ   54AA
....................       { 
....................          mode=LOGOFF; 
5484:  MOVLB  9
5486:  CLRF   xA4
....................          keydebug_en=0; 
5488:  MOVLB  1
548A:  CLRF   x08
....................          set_tris_a(0xff); 
548C:  MOVLW  FF
548E:  MOVWF  F92
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
5490:  MOVLW  30
5492:  MOVWF  FF6
5494:  MOVLW  20
5496:  MOVWF  FF7
5498:  CLRF   19
549A:  BTFSC  FF2.7
549C:  BSF    19.7
549E:  BCF    FF2.7
54A0:  MOVLB  0
54A2:  CALL   058E
54A6:  BTFSC  19.7
54A8:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
54AA:  CLRF   FEA
54AC:  MOVLW  41
54AE:  MOVWF  FE9
54B0:  MOVLW  00
54B2:  CALL   019C
54B6:  TBLRD*-
54B8:  TBLRD*+
54BA:  MOVF   FF5,W
54BC:  MOVWF  FEE
54BE:  IORLW  00
54C0:  BNZ   54B8
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
54C2:  MOVLW  01
54C4:  MOVLB  A
54C6:  MOVWF  xBE
54C8:  MOVLW  4A
54CA:  MOVWF  xBD
54CC:  CLRF   xC0
54CE:  MOVLW  41
54D0:  MOVWF  xBF
54D2:  MOVLB  0
54D4:  CALL   4652
54D8:  MOVF   01,F
54DA:  BNZ   553C
....................       { 
....................          fprintf(COM2,"New console name>"); 
54DC:  MOVLW  38
54DE:  MOVWF  FF6
54E0:  MOVLW  20
54E2:  MOVWF  FF7
54E4:  CLRF   19
54E6:  BTFSC  FF2.7
54E8:  BSF    19.7
54EA:  BCF    FF2.7
54EC:  CALL   058E
54F0:  BTFSC  19.7
54F2:  BSF    FF2.7
....................          USART_getstring(EN_ECHO,16, console); 
54F4:  MOVLW  01
54F6:  MOVLB  A
54F8:  MOVWF  xBD
54FA:  MOVLW  10
54FC:  MOVWF  xBE
54FE:  MOVLW  09
5500:  MOVWF  xC0
5502:  MOVLW  AF
5504:  MOVWF  xBF
5506:  MOVLB  0
5508:  CALL   451A
....................          EEPROM_write(strobe_nameconsole,16,console); 
550C:  MOVLW  66
550E:  MOVLB  A
5510:  MOVWF  xD2
5512:  MOVLW  10
5514:  MOVWF  xD3
5516:  MOVLW  09
5518:  MOVWF  xD5
551A:  MOVLW  AF
551C:  MOVWF  xD4
551E:  MOVLB  0
5520:  CALL   41B6
....................          fprintf(COM2," OK\n\r"); 
5524:  MOVLW  4A
5526:  MOVWF  FF6
5528:  MOVLW  20
552A:  MOVWF  FF7
552C:  CLRF   19
552E:  BTFSC  FF2.7
5530:  BSF    19.7
5532:  BCF    FF2.7
5534:  CALL   058E
5538:  BTFSC  19.7
553A:  BSF    FF2.7
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
553C:  CLRF   FEA
553E:  MOVLW  41
5540:  MOVWF  FE9
5542:  MOVLW  00
5544:  CALL   01AE
5548:  TBLRD*-
554A:  TBLRD*+
554C:  MOVF   FF5,W
554E:  MOVWF  FEE
5550:  IORLW  00
5552:  BNZ   554A
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
5554:  MOVLW  01
5556:  MOVLB  A
5558:  MOVWF  xBE
555A:  MOVLW  4A
555C:  MOVWF  xBD
555E:  CLRF   xC0
5560:  MOVLW  41
5562:  MOVWF  xBF
5564:  MOVLB  0
5566:  CALL   4652
556A:  MOVF   01,F
556C:  BTFSS  FD8.2
556E:  BRA    57CC
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
*
563A:  MOVLB  A
563C:  CLRF   xEE
563E:  MOVLW  91
5640:  MOVWF  xED
5642:  MOVLB  0
5644:  CALL   30FC
5648:  BTFSC  19.7
564A:  BSF    FF2.7
564C:  MOVFF  01,9AA
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
5650:  MOVLB  9
5652:  MOVF   xAA,F
5654:  BNZ   5674
5656:  MOVLW  50
5658:  MOVWF  FF6
565A:  MOVLW  20
565C:  MOVWF  FF7
565E:  CLRF   19
5660:  BTFSC  FF2.7
5662:  BSF    19.7
5664:  BCF    FF2.7
5666:  MOVLB  0
5668:  CALL   058E
566C:  BTFSC  19.7
566E:  BSF    FF2.7
....................          else fprintf(COM2,"[S]");   
5670:  BRA    568E
5672:  MOVLB  9
5674:  MOVLW  54
5676:  MOVWF  FF6
5678:  MOVLW  20
567A:  MOVWF  FF7
567C:  CLRF   19
567E:  BTFSC  FF2.7
5680:  BSF    19.7
5682:  BCF    FF2.7
5684:  MOVLB  0
5686:  CALL   058E
568A:  BTFSC  19.7
568C:  BSF    FF2.7
568E:  CLRF   19
5690:  BTFSC  FF2.7
5692:  BSF    19.7
5694:  BCF    FF2.7
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
5696:  MOVLB  A
5698:  CLRF   xEE
569A:  MOVLW  94
569C:  MOVWF  xED
569E:  MOVLB  0
56A0:  CALL   30FC
56A4:  BTFSC  19.7
56A6:  BSF    FF2.7
56A8:  MOVFF  01,142
56AC:  CLRF   19
56AE:  BTFSC  FF2.7
56B0:  BSF    19.7
56B2:  BCF    FF2.7
....................          fprintf(COM2,"[%u]",delaycharaction); 
56B4:  MOVLW  5B
56B6:  MOVLB  B
56B8:  MOVWF  x16
56BA:  MOVLB  0
56BC:  CALL   0548
56C0:  BTFSC  19.7
56C2:  BSF    FF2.7
56C4:  MOVFF  142,ABD
56C8:  MOVLW  1B
56CA:  MOVLB  A
56CC:  MOVWF  xBE
56CE:  MOVLB  0
56D0:  GOTO   4B68
56D4:  CLRF   19
56D6:  BTFSC  FF2.7
56D8:  BSF    19.7
56DA:  BCF    FF2.7
56DC:  MOVLW  5D
56DE:  MOVLB  B
56E0:  MOVWF  x16
56E2:  MOVLB  0
56E4:  CALL   0548
56E8:  BTFSC  19.7
56EA:  BSF    FF2.7
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
56EC:  MOVFF  100,ABD
56F0:  MOVLW  01
56F2:  MOVLB  A
56F4:  MOVWF  xBE
56F6:  MOVLB  0
56F8:  CALL   47A4
56FC:  CLRF   19
56FE:  BTFSC  FF2.7
5700:  BSF    19.7
5702:  BCF    FF2.7
5704:  MOVLW  2F
5706:  MOVLB  B
5708:  MOVWF  x16
570A:  MOVLB  0
570C:  CALL   0548
5710:  BTFSC  19.7
5712:  BSF    FF2.7
5714:  MOVFF  FF,ABD
5718:  MOVLW  01
571A:  MOVLB  A
571C:  MOVWF  xBE
571E:  MOVLB  0
5720:  CALL   47A4
5724:  CLRF   19
5726:  BTFSC  FF2.7
5728:  BSF    19.7
572A:  BCF    FF2.7
572C:  MOVLW  20
572E:  MOVLB  B
5730:  MOVWF  x16
5732:  MOVLB  0
5734:  CALL   0548
5738:  BTFSC  19.7
573A:  BSF    FF2.7
573C:  MOVFF  101,ABD
5740:  MOVLW  01
5742:  MOVLB  A
5744:  MOVWF  xBE
5746:  MOVLB  0
5748:  CALL   47A4
574C:  CLRF   19
574E:  BTFSC  FF2.7
5750:  BSF    19.7
5752:  BCF    FF2.7
5754:  MOVLW  3A
5756:  MOVLB  B
5758:  MOVWF  x16
575A:  MOVLB  0
575C:  CALL   0548
5760:  BTFSC  19.7
5762:  BSF    FF2.7
5764:  MOVFF  102,ABD
5768:  MOVLW  01
576A:  MOVLB  A
576C:  MOVWF  xBE
576E:  MOVLB  0
5770:  CALL   47A4
5774:  CLRF   19
5776:  BTFSC  FF2.7
5778:  BSF    19.7
577A:  BCF    FF2.7
577C:  MOVLW  3A
577E:  MOVLB  B
5780:  MOVWF  x16
5782:  MOVLB  0
5784:  CALL   0548
5788:  BTFSC  19.7
578A:  BSF    FF2.7
578C:  MOVFF  103,ABD
5790:  MOVLW  01
5792:  MOVLB  A
5794:  MOVWF  xBE
5796:  MOVLB  0
5798:  CALL   47A4
579C:  CLRF   19
579E:  BTFSC  FF2.7
57A0:  BSF    19.7
57A2:  BCF    FF2.7
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
57A4:  MOVLW  0A
57A6:  MOVLB  B
57A8:  MOVWF  x16
57AA:  MOVLB  0
57AC:  CALL   0548
57B0:  BTFSC  19.7
57B2:  BSF    FF2.7
57B4:  CLRF   19
57B6:  BTFSC  FF2.7
57B8:  BSF    19.7
57BA:  BCF    FF2.7
57BC:  MOVLW  0D
57BE:  MOVLB  B
57C0:  MOVWF  x16
57C2:  MOVLB  0
57C4:  CALL   0548
57C8:  BTFSC  19.7
57CA:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"sc"); 
57CC:  CLRF   FEA
57CE:  MOVLW  41
57D0:  MOVWF  FE9
57D2:  MOVLW  00
57D4:  CALL   01C0
57D8:  TBLRD*-
57DA:  TBLRD*+
57DC:  MOVF   FF5,W
57DE:  MOVWF  FEE
57E0:  IORLW  00
57E2:  BNZ   57DA
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
57E4:  MOVLW  01
57E6:  MOVLB  A
57E8:  MOVWF  xBE
57EA:  MOVLW  4A
57EC:  MOVWF  xBD
57EE:  CLRF   xC0
57F0:  MOVLW  41
57F2:  MOVWF  xBF
57F4:  MOVLB  0
57F6:  CALL   4652
57FA:  MOVF   01,F
57FC:  BTFSS  FD8.2
57FE:  BRA    5A28
....................       { 
....................          fprintf(COM2,"Year>"); 
5800:  MOVLW  58
5802:  MOVWF  FF6
5804:  MOVLW  20
5806:  MOVWF  FF7
5808:  CLRF   19
580A:  BTFSC  FF2.7
580C:  BSF    19.7
580E:  BCF    FF2.7
5810:  CALL   058E
5814:  BTFSC  19.7
5816:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
5818:  MOVLW  01
581A:  MOVLB  A
581C:  MOVWF  xBD
581E:  MOVLW  03
5820:  MOVWF  xBE
5822:  MOVLW  0A
5824:  MOVWF  xC0
5826:  MOVLW  89
5828:  MOVWF  xBF
582A:  MOVLB  0
582C:  CALL   451A
....................          year=(unsigned int8)strtoi(temp); 
5830:  MOVLW  0A
5832:  MOVLB  A
5834:  MOVWF  xBE
5836:  MOVLW  89
5838:  MOVWF  xBD
583A:  MOVLB  0
583C:  CALL   4C2C
5840:  MOVFF  01,FE
....................          fprintf(COM2,"Month>"); 
5844:  MOVLW  5E
5846:  MOVWF  FF6
5848:  MOVLW  20
584A:  MOVWF  FF7
584C:  CLRF   19
584E:  BTFSC  FF2.7
5850:  BSF    19.7
5852:  BCF    FF2.7
5854:  CALL   058E
5858:  BTFSC  19.7
585A:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
585C:  MOVLW  01
585E:  MOVLB  A
5860:  MOVWF  xBD
5862:  MOVLW  03
5864:  MOVWF  xBE
5866:  MOVLW  0A
5868:  MOVWF  xC0
586A:  MOVLW  89
586C:  MOVWF  xBF
586E:  MOVLB  0
5870:  CALL   451A
....................          mon=(unsigned int8)strtoi(temp); 
5874:  MOVLW  0A
5876:  MOVLB  A
5878:  MOVWF  xBE
587A:  MOVLW  89
587C:  MOVWF  xBD
587E:  MOVLB  0
5880:  CALL   4C2C
5884:  MOVFF  01,FF
....................          fprintf(COM2,"Date>"); 
5888:  MOVLW  66
588A:  MOVWF  FF6
588C:  MOVLW  20
588E:  MOVWF  FF7
5890:  CLRF   19
5892:  BTFSC  FF2.7
5894:  BSF    19.7
5896:  BCF    FF2.7
5898:  CALL   058E
589C:  BTFSC  19.7
589E:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
58A0:  MOVLW  01
58A2:  MOVLB  A
58A4:  MOVWF  xBD
58A6:  MOVLW  03
58A8:  MOVWF  xBE
58AA:  MOVLW  0A
58AC:  MOVWF  xC0
58AE:  MOVLW  89
58B0:  MOVWF  xBF
58B2:  MOVLB  0
58B4:  CALL   451A
....................          date = (unsigned int8)strtoi(temp); 
58B8:  MOVLW  0A
58BA:  MOVLB  A
58BC:  MOVWF  xBE
58BE:  MOVLW  89
58C0:  MOVWF  xBD
58C2:  MOVLB  0
58C4:  CALL   4C2C
58C8:  MOVFF  01,100
....................          fprintf(COM2,"Day>"); 
58CC:  MOVLW  6C
58CE:  MOVWF  FF6
58D0:  MOVLW  20
58D2:  MOVWF  FF7
58D4:  CLRF   19
58D6:  BTFSC  FF2.7
58D8:  BSF    19.7
58DA:  BCF    FF2.7
58DC:  CALL   058E
58E0:  BTFSC  19.7
58E2:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
58E4:  MOVLW  01
58E6:  MOVLB  A
58E8:  MOVWF  xBD
58EA:  MOVLW  03
58EC:  MOVWF  xBE
58EE:  MOVLW  0A
58F0:  MOVWF  xC0
58F2:  MOVLW  89
58F4:  MOVWF  xBF
58F6:  MOVLB  0
58F8:  CALL   451A
....................          day = (unsigned int8)strtoi(temp); 
58FC:  MOVLW  0A
58FE:  MOVLB  A
5900:  MOVWF  xBE
5902:  MOVLW  89
5904:  MOVWF  xBD
5906:  MOVLB  0
5908:  CALL   4C2C
590C:  MOVFF  01,FD
....................          fprintf(COM2,"Hour>"); 
5910:  MOVLW  72
5912:  MOVWF  FF6
5914:  MOVLW  20
5916:  MOVWF  FF7
5918:  CLRF   19
591A:  BTFSC  FF2.7
591C:  BSF    19.7
591E:  BCF    FF2.7
5920:  CALL   058E
5924:  BTFSC  19.7
5926:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
5928:  MOVLW  01
592A:  MOVLB  A
592C:  MOVWF  xBD
592E:  MOVLW  03
5930:  MOVWF  xBE
5932:  MOVLW  0A
5934:  MOVWF  xC0
5936:  MOVLW  89
5938:  MOVWF  xBF
593A:  MOVLB  0
593C:  CALL   451A
....................          h = (unsigned int8)strtoi(temp); 
5940:  MOVLW  0A
5942:  MOVLB  A
5944:  MOVWF  xBE
5946:  MOVLW  89
5948:  MOVWF  xBD
594A:  MOVLB  0
594C:  CALL   4C2C
5950:  MOVFF  01,101
....................          fprintf(COM2,"Minutes>"); 
5954:  MOVLW  78
5956:  MOVWF  FF6
5958:  MOVLW  20
595A:  MOVWF  FF7
595C:  CLRF   19
595E:  BTFSC  FF2.7
5960:  BSF    19.7
5962:  BCF    FF2.7
5964:  CALL   058E
5968:  BTFSC  19.7
596A:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
596C:  MOVLW  01
596E:  MOVLB  A
5970:  MOVWF  xBD
5972:  MOVLW  03
5974:  MOVWF  xBE
5976:  MOVLW  0A
5978:  MOVWF  xC0
597A:  MOVLW  89
597C:  MOVWF  xBF
597E:  MOVLB  0
5980:  CALL   451A
....................          min = (unsigned int8)strtoi(temp);                   
5984:  MOVLW  0A
5986:  MOVLB  A
5988:  MOVWF  xBE
598A:  MOVLW  89
598C:  MOVWF  xBD
598E:  MOVLB  0
5990:  CALL   4C2C
5994:  MOVFF  01,102
....................          fprintf(COM2,"Seconds>"); 
5998:  MOVLW  82
599A:  MOVWF  FF6
599C:  MOVLW  20
599E:  MOVWF  FF7
59A0:  CLRF   19
59A2:  BTFSC  FF2.7
59A4:  BSF    19.7
59A6:  BCF    FF2.7
59A8:  CALL   058E
59AC:  BTFSC  19.7
59AE:  BSF    FF2.7
....................          USART_getstring(EN_ECHO, 3, temp); 
59B0:  MOVLW  01
59B2:  MOVLB  A
59B4:  MOVWF  xBD
59B6:  MOVLW  03
59B8:  MOVWF  xBE
59BA:  MOVLW  0A
59BC:  MOVWF  xC0
59BE:  MOVLW  89
59C0:  MOVWF  xBF
59C2:  MOVLB  0
59C4:  CALL   451A
....................          sec = (unsigned int8)strtoi(temp);                   
59C8:  MOVLW  0A
59CA:  MOVLB  A
59CC:  MOVWF  xBE
59CE:  MOVLW  89
59D0:  MOVWF  xBD
59D2:  MOVLB  0
59D4:  CALL   4C2C
59D8:  MOVFF  01,103
59DC:  CLRF   19
59DE:  BTFSC  FF2.7
59E0:  BSF    19.7
59E2:  BCF    FF2.7
....................          fprintf(COM2,"\n\r"); 
59E4:  MOVLW  0A
59E6:  MOVLB  B
59E8:  MOVWF  x16
59EA:  MOVLB  0
59EC:  CALL   0548
59F0:  BTFSC  19.7
59F2:  BSF    FF2.7
59F4:  CLRF   19
59F6:  BTFSC  FF2.7
59F8:  BSF    19.7
59FA:  BCF    FF2.7
59FC:  MOVLW  0D
59FE:  MOVLB  B
5A00:  MOVWF  x16
5A02:  MOVLB  0
5A04:  CALL   0548
5A08:  BTFSC  19.7
5A0A:  BSF    FF2.7
....................          rtc_set_datetime(date,mon,year,day,h,min); 
5A0C:  MOVFF  100,ABD
5A10:  MOVFF  FF,ABE
5A14:  MOVFF  FE,ABF
5A18:  MOVFF  FD,AC0
5A1C:  MOVFF  101,AC1
5A20:  MOVFF  102,AC2
5A24:  GOTO   4D66
....................       } 
....................       strcpy(buffer2,"MS"); 
5A28:  CLRF   FEA
5A2A:  MOVLW  41
5A2C:  MOVWF  FE9
5A2E:  MOVLW  00
5A30:  CALL   01D4
5A34:  TBLRD*-
5A36:  TBLRD*+
5A38:  MOVF   FF5,W
5A3A:  MOVWF  FEE
5A3C:  IORLW  00
5A3E:  BNZ   5A36
....................       if(!stringcomp(buffer_uart,buffer2)) 
5A40:  MOVLW  01
5A42:  MOVLB  A
5A44:  MOVWF  xBE
5A46:  MOVLW  4A
5A48:  MOVWF  xBD
5A4A:  CLRF   xC0
5A4C:  MOVLW  41
5A4E:  MOVWF  xBF
5A50:  MOVLB  0
5A52:  CALL   4652
5A56:  MOVF   01,F
5A58:  BTFSS  FD8.2
5A5A:  BRA    5B6A
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
5A5C:  MOVLW  8C
5A5E:  MOVWF  FF6
5A60:  MOVLW  20
5A62:  MOVWF  FF7
5A64:  CLRF   19
5A66:  BTFSC  FF2.7
5A68:  BSF    19.7
5A6A:  BCF    FF2.7
5A6C:  CALL   058E
5A70:  BTFSC  19.7
5A72:  BSF    FF2.7
5A74:  CLRF   19
5A76:  BTFSC  FF2.7
5A78:  BSF    19.7
5A7A:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5A7C:  MOVLW  0A
5A7E:  MOVLB  B
5A80:  MOVWF  x16
5A82:  MOVLB  0
5A84:  CALL   0548
5A88:  BTFSC  19.7
5A8A:  BSF    FF2.7
5A8C:  CLRF   19
5A8E:  BTFSC  FF2.7
5A90:  BSF    19.7
5A92:  BCF    FF2.7
5A94:  MOVLW  0D
5A96:  MOVLB  B
5A98:  MOVWF  x16
5A9A:  MOVLB  0
5A9C:  CALL   0548
5AA0:  BTFSC  19.7
5AA2:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to select Master mode"); 
5AA4:  MOVLW  AC
5AA6:  MOVWF  FF6
5AA8:  MOVLW  20
5AAA:  MOVWF  FF7
5AAC:  CLRF   19
5AAE:  BTFSC  FF2.7
5AB0:  BSF    19.7
5AB2:  BCF    FF2.7
5AB4:  CALL   058E
5AB8:  BTFSC  19.7
5ABA:  BSF    FF2.7
5ABC:  CLRF   19
5ABE:  BTFSC  FF2.7
5AC0:  BSF    19.7
5AC2:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5AC4:  MOVLW  0A
5AC6:  MOVLB  B
5AC8:  MOVWF  x16
5ACA:  MOVLB  0
5ACC:  CALL   0548
5AD0:  BTFSC  19.7
5AD2:  BSF    FF2.7
5AD4:  CLRF   19
5AD6:  BTFSC  FF2.7
5AD8:  BSF    19.7
5ADA:  BCF    FF2.7
5ADC:  MOVLW  0D
5ADE:  MOVLB  B
5AE0:  MOVWF  x16
5AE2:  MOVLB  0
5AE4:  CALL   0548
5AE8:  BTFSC  19.7
5AEA:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
5AEC:  MOVLW  01
5AEE:  MOVLB  A
5AF0:  MOVWF  xBD
5AF2:  MOVLW  03
5AF4:  MOVWF  xBE
5AF6:  MOVLW  0A
5AF8:  MOVWF  xC0
5AFA:  MOVLW  89
5AFC:  MOVWF  xBF
5AFE:  MOVLB  0
5B00:  CALL   451A
....................           mode_sl = (unsigned int8)strtoi(temp); 
5B04:  MOVLW  0A
5B06:  MOVLB  A
5B08:  MOVWF  xBE
5B0A:  MOVLW  89
5B0C:  MOVWF  xBD
5B0E:  MOVLB  0
5B10:  CALL   4C2C
5B14:  MOVFF  01,9AA
5B18:  CLRF   19
5B1A:  BTFSC  FF2.7
5B1C:  BSF    19.7
5B1E:  BCF    FF2.7
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
5B20:  MOVLB  B
5B22:  CLRF   x03
5B24:  MOVLW  91
5B26:  MOVWF  x02
5B28:  MOVFF  9AA,B04
5B2C:  MOVLB  0
5B2E:  CALL   364C
5B32:  BTFSC  19.7
5B34:  BSF    FF2.7
....................           set_tris_a(0xff); 
5B36:  MOVLW  FF
5B38:  MOVWF  F92
5B3A:  CLRF   19
5B3C:  BTFSC  FF2.7
5B3E:  BSF    19.7
5B40:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5B42:  MOVLW  0A
5B44:  MOVLB  B
5B46:  MOVWF  x16
5B48:  MOVLB  0
5B4A:  CALL   0548
5B4E:  BTFSC  19.7
5B50:  BSF    FF2.7
5B52:  CLRF   19
5B54:  BTFSC  FF2.7
5B56:  BSF    19.7
5B58:  BCF    FF2.7
5B5A:  MOVLW  0D
5B5C:  MOVLB  B
5B5E:  MOVWF  x16
5B60:  MOVLB  0
5B62:  CALL   0548
5B66:  BTFSC  19.7
5B68:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"KP"); 
5B6A:  CLRF   FEA
5B6C:  MOVLW  41
5B6E:  MOVWF  FE9
5B70:  MOVLW  00
5B72:  CALL   01E8
5B76:  TBLRD*-
5B78:  TBLRD*+
5B7A:  MOVF   FF5,W
5B7C:  MOVWF  FEE
5B7E:  IORLW  00
5B80:  BNZ   5B78
....................       if(!stringcomp(buffer_uart,buffer2)) 
5B82:  MOVLW  01
5B84:  MOVLB  A
5B86:  MOVWF  xBE
5B88:  MOVLW  4A
5B8A:  MOVWF  xBD
5B8C:  CLRF   xC0
5B8E:  MOVLW  41
5B90:  MOVWF  xBF
5B92:  MOVLB  0
5B94:  CALL   4652
5B98:  MOVF   01,F
5B9A:  BTFSS  FD8.2
5B9C:  BRA    5CA8
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
5B9E:  MOVLW  CC
5BA0:  MOVWF  FF6
5BA2:  MOVLW  20
5BA4:  MOVWF  FF7
5BA6:  CLRF   19
5BA8:  BTFSC  FF2.7
5BAA:  BSF    19.7
5BAC:  BCF    FF2.7
5BAE:  CALL   058E
5BB2:  BTFSC  19.7
5BB4:  BSF    FF2.7
5BB6:  CLRF   19
5BB8:  BTFSC  FF2.7
5BBA:  BSF    19.7
5BBC:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5BBE:  MOVLW  0A
5BC0:  MOVLB  B
5BC2:  MOVWF  x16
5BC4:  MOVLB  0
5BC6:  CALL   0548
5BCA:  BTFSC  19.7
5BCC:  BSF    FF2.7
5BCE:  CLRF   19
5BD0:  BTFSC  FF2.7
5BD2:  BSF    19.7
5BD4:  BCF    FF2.7
5BD6:  MOVLW  0D
5BD8:  MOVLB  B
5BDA:  MOVWF  x16
5BDC:  MOVLB  0
5BDE:  CALL   0548
5BE2:  BTFSC  19.7
5BE4:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
5BE6:  MOVLW  EA
5BE8:  MOVWF  FF6
5BEA:  MOVLW  20
5BEC:  MOVWF  FF7
5BEE:  CLRF   19
5BF0:  BTFSC  FF2.7
5BF2:  BSF    19.7
5BF4:  BCF    FF2.7
5BF6:  CALL   058E
5BFA:  BTFSC  19.7
5BFC:  BSF    FF2.7
5BFE:  CLRF   19
5C00:  BTFSC  FF2.7
5C02:  BSF    19.7
5C04:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5C06:  MOVLW  0A
5C08:  MOVLB  B
5C0A:  MOVWF  x16
5C0C:  MOVLB  0
5C0E:  CALL   0548
5C12:  BTFSC  19.7
5C14:  BSF    FF2.7
5C16:  CLRF   19
5C18:  BTFSC  FF2.7
5C1A:  BSF    19.7
5C1C:  BCF    FF2.7
5C1E:  MOVLW  0D
5C20:  MOVLB  B
5C22:  MOVWF  x16
5C24:  MOVLB  0
5C26:  CALL   0548
5C2A:  BTFSC  19.7
5C2C:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
5C2E:  MOVLW  01
5C30:  MOVLB  A
5C32:  MOVWF  xBD
5C34:  MOVLW  03
5C36:  MOVWF  xBE
5C38:  MOVLW  0A
5C3A:  MOVWF  xC0
5C3C:  MOVLW  89
5C3E:  MOVWF  xBF
5C40:  MOVLB  0
5C42:  CALL   451A
....................           KP_mode = (unsigned int8)strtoi(temp); 
5C46:  MOVLW  0A
5C48:  MOVLB  A
5C4A:  MOVWF  xBE
5C4C:  MOVLW  89
5C4E:  MOVWF  xBD
5C50:  MOVLB  0
5C52:  CALL   4C2C
5C56:  MOVFF  01,10C
5C5A:  CLRF   19
5C5C:  BTFSC  FF2.7
5C5E:  BSF    19.7
5C60:  BCF    FF2.7
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
5C62:  MOVLB  B
5C64:  CLRF   x03
5C66:  MOVLW  7F
5C68:  MOVWF  x02
5C6A:  MOVFF  10C,B04
5C6E:  MOVLB  0
5C70:  CALL   364C
5C74:  BTFSC  19.7
5C76:  BSF    FF2.7
5C78:  CLRF   19
5C7A:  BTFSC  FF2.7
5C7C:  BSF    19.7
5C7E:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5C80:  MOVLW  0A
5C82:  MOVLB  B
5C84:  MOVWF  x16
5C86:  MOVLB  0
5C88:  CALL   0548
5C8C:  BTFSC  19.7
5C8E:  BSF    FF2.7
5C90:  CLRF   19
5C92:  BTFSC  FF2.7
5C94:  BSF    19.7
5C96:  BCF    FF2.7
5C98:  MOVLW  0D
5C9A:  MOVLB  B
5C9C:  MOVWF  x16
5C9E:  MOVLB  0
5CA0:  CALL   0548
5CA4:  BTFSC  19.7
5CA6:  BSF    FF2.7
....................       } 
....................       strcpy(buffer2,"tran time"); 
5CA8:  CLRF   FEA
5CAA:  MOVLW  41
5CAC:  MOVWF  FE9
5CAE:  MOVLW  00
5CB0:  CALL   01FC
5CB4:  TBLRD*-
5CB6:  TBLRD*+
5CB8:  MOVF   FF5,W
5CBA:  MOVWF  FEE
5CBC:  IORLW  00
5CBE:  BNZ   5CB6
....................       if(!stringcomp(buffer_uart,buffer2)) 
5CC0:  MOVLW  01
5CC2:  MOVLB  A
5CC4:  MOVWF  xBE
5CC6:  MOVLW  4A
5CC8:  MOVWF  xBD
5CCA:  CLRF   xC0
5CCC:  MOVLW  41
5CCE:  MOVWF  xBF
5CD0:  MOVLB  0
5CD2:  CALL   4652
5CD6:  MOVF   01,F
5CD8:  BNZ   5D9C
....................       { 
....................           fprintf(COM2,"Input Number"); 
5CDA:  MOVLW  08
5CDC:  MOVWF  FF6
5CDE:  MOVLW  21
5CE0:  MOVWF  FF7
5CE2:  CLRF   19
5CE4:  BTFSC  FF2.7
5CE6:  BSF    19.7
5CE8:  BCF    FF2.7
5CEA:  CALL   058E
5CEE:  BTFSC  19.7
5CF0:  BSF    FF2.7
5CF2:  CLRF   19
5CF4:  BTFSC  FF2.7
5CF6:  BSF    19.7
5CF8:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5CFA:  MOVLW  0A
5CFC:  MOVLB  B
5CFE:  MOVWF  x16
5D00:  MOVLB  0
5D02:  CALL   0548
5D06:  BTFSC  19.7
5D08:  BSF    FF2.7
5D0A:  CLRF   19
5D0C:  BTFSC  FF2.7
5D0E:  BSF    19.7
5D10:  BCF    FF2.7
5D12:  MOVLW  0D
5D14:  MOVLB  B
5D16:  MOVWF  x16
5D18:  MOVLB  0
5D1A:  CALL   0548
5D1E:  BTFSC  19.7
5D20:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
5D22:  MOVLW  01
5D24:  MOVLB  A
5D26:  MOVWF  xBD
5D28:  MOVLW  03
5D2A:  MOVWF  xBE
5D2C:  MOVLW  0A
5D2E:  MOVWF  xC0
5D30:  MOVLW  89
5D32:  MOVWF  xBF
5D34:  MOVLB  0
5D36:  CALL   451A
....................           delaycharaction = (unsigned int8)strtoi(temp); 
5D3A:  MOVLW  0A
5D3C:  MOVLB  A
5D3E:  MOVWF  xBE
5D40:  MOVLW  89
5D42:  MOVWF  xBD
5D44:  MOVLB  0
5D46:  CALL   4C2C
5D4A:  MOVFF  01,142
5D4E:  CLRF   19
5D50:  BTFSC  FF2.7
5D52:  BSF    19.7
5D54:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
5D56:  MOVLB  B
5D58:  CLRF   x03
5D5A:  MOVLW  94
5D5C:  MOVWF  x02
5D5E:  MOVFF  142,B04
5D62:  MOVLB  0
5D64:  CALL   364C
5D68:  BTFSC  19.7
5D6A:  BSF    FF2.7
5D6C:  CLRF   19
5D6E:  BTFSC  FF2.7
5D70:  BSF    19.7
5D72:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5D74:  MOVLW  0A
5D76:  MOVLB  B
5D78:  MOVWF  x16
5D7A:  MOVLB  0
5D7C:  CALL   0548
5D80:  BTFSC  19.7
5D82:  BSF    FF2.7
5D84:  CLRF   19
5D86:  BTFSC  FF2.7
5D88:  BSF    19.7
5D8A:  BCF    FF2.7
5D8C:  MOVLW  0D
5D8E:  MOVLB  B
5D90:  MOVWF  x16
5D92:  MOVLB  0
5D94:  CALL   0548
5D98:  BTFSC  19.7
5D9A:  BSF    FF2.7
....................       }    
....................       strcpy(buffer2,"delaykb"); 
5D9C:  CLRF   FEA
5D9E:  MOVLW  41
5DA0:  MOVWF  FE9
5DA2:  MOVLW  00
5DA4:  CALL   0216
5DA8:  TBLRD*-
5DAA:  TBLRD*+
5DAC:  MOVF   FF5,W
5DAE:  MOVWF  FEE
5DB0:  IORLW  00
5DB2:  BNZ   5DAA
....................       if(!stringcomp(buffer_uart,buffer2)) 
5DB4:  MOVLW  01
5DB6:  MOVLB  A
5DB8:  MOVWF  xBE
5DBA:  MOVLW  4A
5DBC:  MOVWF  xBD
5DBE:  CLRF   xC0
5DC0:  MOVLW  41
5DC2:  MOVWF  xBF
5DC4:  MOVLB  0
5DC6:  CALL   4652
5DCA:  MOVF   01,F
5DCC:  BNZ   5E90
....................       { 
....................           fprintf(COM2,"Input Number"); 
5DCE:  MOVLW  16
5DD0:  MOVWF  FF6
5DD2:  MOVLW  21
5DD4:  MOVWF  FF7
5DD6:  CLRF   19
5DD8:  BTFSC  FF2.7
5DDA:  BSF    19.7
5DDC:  BCF    FF2.7
5DDE:  CALL   058E
5DE2:  BTFSC  19.7
5DE4:  BSF    FF2.7
5DE6:  CLRF   19
5DE8:  BTFSC  FF2.7
5DEA:  BSF    19.7
5DEC:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5DEE:  MOVLW  0A
5DF0:  MOVLB  B
5DF2:  MOVWF  x16
5DF4:  MOVLB  0
5DF6:  CALL   0548
5DFA:  BTFSC  19.7
5DFC:  BSF    FF2.7
5DFE:  CLRF   19
5E00:  BTFSC  FF2.7
5E02:  BSF    19.7
5E04:  BCF    FF2.7
5E06:  MOVLW  0D
5E08:  MOVLB  B
5E0A:  MOVWF  x16
5E0C:  MOVLB  0
5E0E:  CALL   0548
5E12:  BTFSC  19.7
5E14:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
5E16:  MOVLW  01
5E18:  MOVLB  A
5E1A:  MOVWF  xBD
5E1C:  MOVLW  03
5E1E:  MOVWF  xBE
5E20:  MOVLW  0A
5E22:  MOVWF  xC0
5E24:  MOVLW  89
5E26:  MOVWF  xBF
5E28:  MOVLB  0
5E2A:  CALL   451A
....................           delaykey = (unsigned int8)strtoi(temp); 
5E2E:  MOVLW  0A
5E30:  MOVLB  A
5E32:  MOVWF  xBE
5E34:  MOVLW  89
5E36:  MOVWF  xBD
5E38:  MOVLB  0
5E3A:  CALL   4C2C
5E3E:  MOVFF  01,107
5E42:  CLRF   19
5E44:  BTFSC  FF2.7
5E46:  BSF    19.7
5E48:  BCF    FF2.7
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
5E4A:  MOVLB  B
5E4C:  CLRF   x03
5E4E:  MOVLW  95
5E50:  MOVWF  x02
5E52:  MOVFF  107,B04
5E56:  MOVLB  0
5E58:  CALL   364C
5E5C:  BTFSC  19.7
5E5E:  BSF    FF2.7
5E60:  CLRF   19
5E62:  BTFSC  FF2.7
5E64:  BSF    19.7
5E66:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
5E68:  MOVLW  0A
5E6A:  MOVLB  B
5E6C:  MOVWF  x16
5E6E:  MOVLB  0
5E70:  CALL   0548
5E74:  BTFSC  19.7
5E76:  BSF    FF2.7
5E78:  CLRF   19
5E7A:  BTFSC  FF2.7
5E7C:  BSF    19.7
5E7E:  BCF    FF2.7
5E80:  MOVLW  0D
5E82:  MOVLB  B
5E84:  MOVWF  x16
5E86:  MOVLB  0
5E88:  CALL   0548
5E8C:  BTFSC  19.7
5E8E:  BSF    FF2.7
....................       }  
....................       strcpy(buffer2,"KBtime"); 
5E90:  CLRF   FEA
5E92:  MOVLW  41
5E94:  MOVWF  FE9
5E96:  MOVLW  00
5E98:  CALL   022E
5E9C:  TBLRD*-
5E9E:  TBLRD*+
5EA0:  MOVF   FF5,W
5EA2:  MOVWF  FEE
5EA4:  IORLW  00
5EA6:  BNZ   5E9E
....................       if(!stringcomp(buffer_uart,buffer2)) 
5EA8:  MOVLW  01
5EAA:  MOVLB  A
5EAC:  MOVWF  xBE
5EAE:  MOVLW  4A
5EB0:  MOVWF  xBD
5EB2:  CLRF   xC0
5EB4:  MOVLW  41
5EB6:  MOVWF  xBF
5EB8:  MOVLB  0
5EBA:  CALL   4652
5EBE:  MOVF   01,F
5EC0:  BNZ   5F84
....................       { 
....................           fprintf(COM2,"Input Number"); 
5EC2:  MOVLW  24
5EC4:  MOVWF  FF6
5EC6:  MOVLW  21
5EC8:  MOVWF  FF7
5ECA:  CLRF   19
5ECC:  BTFSC  FF2.7
5ECE:  BSF    19.7
5ED0:  BCF    FF2.7
5ED2:  CALL   058E
5ED6:  BTFSC  19.7
5ED8:  BSF    FF2.7
5EDA:  CLRF   19
5EDC:  BTFSC  FF2.7
5EDE:  BSF    19.7
5EE0:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
5EE2:  MOVLW  0A
5EE4:  MOVLB  B
5EE6:  MOVWF  x16
5EE8:  MOVLB  0
5EEA:  CALL   0548
5EEE:  BTFSC  19.7
5EF0:  BSF    FF2.7
5EF2:  CLRF   19
5EF4:  BTFSC  FF2.7
5EF6:  BSF    19.7
5EF8:  BCF    FF2.7
5EFA:  MOVLW  0D
5EFC:  MOVLB  B
5EFE:  MOVWF  x16
5F00:  MOVLB  0
5F02:  CALL   0548
5F06:  BTFSC  19.7
5F08:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
5F0A:  MOVLW  01
5F0C:  MOVLB  A
5F0E:  MOVWF  xBD
5F10:  MOVLW  03
5F12:  MOVWF  xBE
5F14:  MOVLW  0A
5F16:  MOVWF  xC0
5F18:  MOVLW  89
5F1A:  MOVWF  xBF
5F1C:  MOVLB  0
5F1E:  CALL   451A
....................           write_ext_eeprom(KB_time,(unsigned int8)strtoi(temp)); 
5F22:  MOVLW  0A
5F24:  MOVLB  A
5F26:  MOVWF  xBE
5F28:  MOVLW  89
5F2A:  MOVWF  xBD
5F2C:  MOVLB  0
5F2E:  CALL   4C2C
5F32:  MOVFF  01,ABD
5F36:  CLRF   19
5F38:  BTFSC  FF2.7
5F3A:  BSF    19.7
5F3C:  BCF    FF2.7
5F3E:  MOVLB  B
5F40:  CLRF   x03
5F42:  MOVLW  7E
5F44:  MOVWF  x02
5F46:  MOVFF  01,B04
5F4A:  MOVLB  0
5F4C:  CALL   364C
5F50:  BTFSC  19.7
5F52:  BSF    FF2.7
5F54:  CLRF   19
5F56:  BTFSC  FF2.7
5F58:  BSF    19.7
5F5A:  BCF    FF2.7
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
5F5C:  MOVLW  0A
5F5E:  MOVLB  B
5F60:  MOVWF  x16
5F62:  MOVLB  0
5F64:  CALL   0548
5F68:  BTFSC  19.7
5F6A:  BSF    FF2.7
5F6C:  CLRF   19
5F6E:  BTFSC  FF2.7
5F70:  BSF    19.7
5F72:  BCF    FF2.7
5F74:  MOVLW  0D
5F76:  MOVLB  B
5F78:  MOVWF  x16
5F7A:  MOVLB  0
5F7C:  CALL   0548
5F80:  BTFSC  19.7
5F82:  BSF    FF2.7
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
5F84:  CLRF   FEA
5F86:  MOVLW  41
5F88:  MOVWF  FE9
5F8A:  MOVLW  00
5F8C:  CALL   0246
5F90:  TBLRD*-
5F92:  TBLRD*+
5F94:  MOVF   FF5,W
5F96:  MOVWF  FEE
5F98:  IORLW  00
5F9A:  BNZ   5F92
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
5F9C:  MOVLW  01
5F9E:  MOVLB  A
5FA0:  MOVWF  xBE
5FA2:  MOVLW  4A
5FA4:  MOVWF  xBD
5FA6:  CLRF   xC0
5FA8:  MOVLW  41
5FAA:  MOVWF  xBF
5FAC:  MOVLB  0
5FAE:  CALL   4652
5FB2:  MOVF   01,F
5FB4:  BTFSS  FD8.2
5FB6:  BRA    6210
....................       { 
....................          printf("h-> Help\n\r"); 
5FB8:  MOVLW  32
5FBA:  MOVWF  FF6
5FBC:  MOVLW  21
5FBE:  MOVWF  FF7
5FC0:  CLRF   19
5FC2:  BTFSC  FF2.7
5FC4:  BSF    19.7
5FC6:  BCF    FF2.7
5FC8:  CALL   058E
5FCC:  BTFSC  19.7
5FCE:  BSF    FF2.7
....................          printf("sc-> Set Clock\n\r"); 
5FD0:  MOVLW  3E
5FD2:  MOVWF  FF6
5FD4:  MOVLW  21
5FD6:  MOVWF  FF7
5FD8:  CLRF   19
5FDA:  BTFSC  FF2.7
5FDC:  BSF    19.7
5FDE:  BCF    FF2.7
5FE0:  CALL   058E
5FE4:  BTFSC  19.7
5FE6:  BSF    FF2.7
....................          printf("c-> show Clock\n\r"); 
5FE8:  MOVLW  50
5FEA:  MOVWF  FF6
5FEC:  MOVLW  21
5FEE:  MOVWF  FF7
5FF0:  CLRF   19
5FF2:  BTFSC  FF2.7
5FF4:  BSF    19.7
5FF6:  BCF    FF2.7
5FF8:  CALL   058E
5FFC:  BTFSC  19.7
5FFE:  BSF    FF2.7
....................          printf("password-> changing PASSWORD\n\r"); 
6000:  MOVLW  62
6002:  MOVWF  FF6
6004:  MOVLW  21
6006:  MOVWF  FF7
6008:  CLRF   19
600A:  BTFSC  FF2.7
600C:  BSF    19.7
600E:  BCF    FF2.7
6010:  CALL   058E
6014:  BTFSC  19.7
6016:  BSF    FF2.7
....................          printf("n -> change console Name\n\r"); 
6018:  MOVLW  82
601A:  MOVWF  FF6
601C:  MOVLW  21
601E:  MOVWF  FF7
6020:  CLRF   19
6022:  BTFSC  FF2.7
6024:  BSF    19.7
6026:  BCF    FF2.7
6028:  CALL   058E
602C:  BTFSC  19.7
602E:  BSF    FF2.7
....................          printf("f-> Format\n\r"); 
6030:  MOVLW  9E
6032:  MOVWF  FF6
6034:  MOVLW  21
6036:  MOVWF  FF7
6038:  CLRF   19
603A:  BTFSC  FF2.7
603C:  BSF    19.7
603E:  BCF    FF2.7
6040:  CALL   058E
6044:  BTFSC  19.7
6046:  BSF    FF2.7
....................          printf("e-> Exit\n\r");   
6048:  MOVLW  AC
604A:  MOVWF  FF6
604C:  MOVLW  21
604E:  MOVWF  FF7
6050:  CLRF   19
6052:  BTFSC  FF2.7
6054:  BSF    19.7
6056:  BCF    FF2.7
6058:  CALL   058E
605C:  BTFSC  19.7
605E:  BSF    FF2.7
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
6060:  MOVLW  B8
6062:  MOVWF  FF6
6064:  MOVLW  21
6066:  MOVWF  FF7
6068:  CLRF   19
606A:  BTFSC  FF2.7
606C:  BSF    19.7
606E:  BCF    FF2.7
6070:  CALL   058E
6074:  BTFSC  19.7
6076:  BSF    FF2.7
6078:  CLRF   19
607A:  BTFSC  FF2.7
607C:  BSF    19.7
607E:  BCF    FF2.7
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
6080:  MOVLB  A
6082:  CLRF   xEE
6084:  MOVLW  7F
6086:  MOVWF  xED
6088:  MOVLB  0
608A:  CALL   30FC
608E:  BTFSC  19.7
6090:  BSF    FF2.7
6092:  MOVFF  01,10C
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
6096:  MOVLB  1
6098:  MOVF   x0C,F
609A:  BZ    60BA
609C:  MOVLW  E4
609E:  MOVWF  FF6
60A0:  MOVLW  21
60A2:  MOVWF  FF7
60A4:  CLRF   19
60A6:  BTFSC  FF2.7
60A8:  BSF    19.7
60AA:  BCF    FF2.7
60AC:  MOVLB  0
60AE:  CALL   058E
60B2:  BTFSC  19.7
60B4:  BSF    FF2.7
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
60B6:  BRA    60D4
60B8:  MOVLB  1
60BA:  MOVLW  06
60BC:  MOVWF  FF6
60BE:  MOVLW  22
60C0:  MOVWF  FF7
60C2:  CLRF   19
60C4:  BTFSC  FF2.7
60C6:  BSF    19.7
60C8:  BCF    FF2.7
60CA:  MOVLB  0
60CC:  CALL   058E
60D0:  BTFSC  19.7
60D2:  BSF    FF2.7
....................          printf("tran time-> time of each transaction\n\r"); 
60D4:  MOVLW  2A
60D6:  MOVWF  FF6
60D8:  MOVLW  22
60DA:  MOVWF  FF7
60DC:  CLRF   19
60DE:  BTFSC  FF2.7
60E0:  BSF    19.7
60E2:  BCF    FF2.7
60E4:  CALL   058E
60E8:  BTFSC  19.7
60EA:  BSF    FF2.7
....................          printf("debug-> on/off debug mode\n\r");      
60EC:  MOVLW  52
60EE:  MOVWF  FF6
60F0:  MOVLW  22
60F2:  MOVWF  FF7
60F4:  CLRF   19
60F6:  BTFSC  FF2.7
60F8:  BSF    19.7
60FA:  BCF    FF2.7
60FC:  CALL   058E
6100:  BTFSC  19.7
6102:  BSF    FF2.7
6104:  CLRF   19
6106:  BTFSC  FF2.7
6108:  BSF    19.7
610A:  BCF    FF2.7
....................          printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
610C:  MOVLB  A
610E:  CLRF   xEE
6110:  MOVLW  95
6112:  MOVWF  xED
6114:  MOVLB  0
6116:  CALL   30FC
611A:  BTFSC  19.7
611C:  BSF    FF2.7
611E:  MOVFF  01,ABD
6122:  MOVLW  6E
6124:  MOVWF  FF6
6126:  MOVLW  22
6128:  MOVWF  FF7
612A:  CLRF   19
612C:  BTFSC  FF2.7
612E:  BSF    19.7
6130:  BCF    FF2.7
6132:  MOVLW  08
6134:  MOVLB  B
6136:  MOVWF  x0A
6138:  MOVLB  0
613A:  CALL   1930
613E:  BTFSC  19.7
6140:  BSF    FF2.7
6142:  CLRF   19
6144:  BTFSC  FF2.7
6146:  BSF    19.7
6148:  BCF    FF2.7
614A:  MOVFF  ABD,AED
614E:  MOVLW  18
6150:  MOVLB  A
6152:  MOVWF  xEE
6154:  MOVLB  0
6156:  CALL   1A44
615A:  BTFSC  19.7
615C:  BSF    FF2.7
615E:  MOVLW  78
6160:  MOVWF  FF6
6162:  MOVLW  22
6164:  MOVWF  FF7
6166:  CLRF   19
6168:  BTFSC  FF2.7
616A:  BSF    19.7
616C:  BCF    FF2.7
616E:  MOVLW  17
6170:  MOVLB  B
6172:  MOVWF  x0A
6174:  MOVLB  0
6176:  CALL   1930
617A:  BTFSC  19.7
617C:  BSF    FF2.7
....................          printf("rsfact-> reset factory\n\r");     
617E:  MOVLW  90
6180:  MOVWF  FF6
6182:  MOVLW  22
6184:  MOVWF  FF7
6186:  CLRF   19
6188:  BTFSC  FF2.7
618A:  BSF    19.7
618C:  BCF    FF2.7
618E:  CALL   058E
6192:  BTFSC  19.7
6194:  BSF    FF2.7
6196:  CLRF   19
6198:  BTFSC  FF2.7
619A:  BSF    19.7
619C:  BCF    FF2.7
....................          printf("KBtime %d -> Keyboard's Timeout\n\r",read_ext_eeprom(KB_time));  
619E:  MOVLB  A
61A0:  CLRF   xEE
61A2:  MOVLW  7E
61A4:  MOVWF  xED
61A6:  MOVLB  0
61A8:  CALL   30FC
61AC:  BTFSC  19.7
61AE:  BSF    FF2.7
61B0:  MOVFF  01,ABD
61B4:  MOVLW  AA
61B6:  MOVWF  FF6
61B8:  MOVLW  22
61BA:  MOVWF  FF7
61BC:  CLRF   19
61BE:  BTFSC  FF2.7
61C0:  BSF    19.7
61C2:  BCF    FF2.7
61C4:  MOVLW  07
61C6:  MOVLB  B
61C8:  MOVWF  x0A
61CA:  MOVLB  0
61CC:  CALL   1930
61D0:  BTFSC  19.7
61D2:  BSF    FF2.7
61D4:  CLRF   19
61D6:  BTFSC  FF2.7
61D8:  BSF    19.7
61DA:  BCF    FF2.7
61DC:  MOVFF  ABD,AED
61E0:  MOVLW  18
61E2:  MOVLB  A
61E4:  MOVWF  xEE
61E6:  MOVLB  0
61E8:  CALL   1A44
61EC:  BTFSC  19.7
61EE:  BSF    FF2.7
61F0:  MOVLW  B3
61F2:  MOVWF  FF6
61F4:  MOVLW  22
61F6:  MOVWF  FF7
61F8:  CLRF   19
61FA:  BTFSC  FF2.7
61FC:  BSF    19.7
61FE:  BCF    FF2.7
6200:  MOVLW  18
6202:  MOVLB  B
6204:  MOVWF  x0A
6206:  MOVLB  0
6208:  CALL   1930
620C:  BTFSC  19.7
620E:  BSF    FF2.7
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
6210:  CLRF   FEA
6212:  MOVLW  41
6214:  MOVWF  FE9
6216:  MOVLW  00
6218:  CALL   0258
621C:  TBLRD*-
621E:  TBLRD*+
6220:  MOVF   FF5,W
6222:  MOVWF  FEE
6224:  IORLW  00
6226:  BNZ   621E
....................       if(!stringcomp(buffer_uart,buffer2))  
6228:  MOVLW  01
622A:  MOVLB  A
622C:  MOVWF  xBE
622E:  MOVLW  4A
6230:  MOVWF  xBD
6232:  CLRF   xC0
6234:  MOVLW  41
6236:  MOVWF  xBF
6238:  MOVLB  0
623A:  CALL   4652
623E:  MOVF   01,F
6240:  BTFSS  FD8.2
6242:  BRA    6372
....................       { 
....................          fprintf(COM2,"old password:"); 
6244:  MOVLW  CC
6246:  MOVWF  FF6
6248:  MOVLW  22
624A:  MOVWF  FF7
624C:  CLRF   19
624E:  BTFSC  FF2.7
6250:  BSF    19.7
6252:  BCF    FF2.7
6254:  CALL   058E
6258:  BTFSC  19.7
625A:  BSF    FF2.7
....................          EEPROM_read(strobe_pass_addr,20,password); 
625C:  MOVLB  A
625E:  CLRF   xBD
6260:  MOVLW  14
6262:  MOVWF  xBE
6264:  CLRF   xC0
6266:  MOVLW  55
6268:  MOVWF  xBF
626A:  MOVLB  0
626C:  CALL   415C
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
6270:  MOVLW  02
6272:  MOVLB  A
6274:  MOVWF  xBD
6276:  MOVLW  14
6278:  MOVWF  xBE
627A:  CLRF   xC0
627C:  MOVLW  69
627E:  MOVWF  xBF
6280:  MOVLB  0
6282:  CALL   451A
....................          if(!stringcomp(entpassword,password)) 
6286:  MOVLB  A
6288:  CLRF   xBE
628A:  MOVLW  69
628C:  MOVWF  xBD
628E:  CLRF   xC0
6290:  MOVLW  55
6292:  MOVWF  xBF
6294:  MOVLB  0
6296:  CALL   4652
629A:  MOVF   01,F
629C:  BNZ   635A
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
629E:  MOVLW  DA
62A0:  MOVWF  FF6
62A2:  MOVLW  22
62A4:  MOVWF  FF7
62A6:  CLRF   19
62A8:  BTFSC  FF2.7
62AA:  BSF    19.7
62AC:  BCF    FF2.7
62AE:  CALL   058E
62B2:  BTFSC  19.7
62B4:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
62B6:  MOVLW  02
62B8:  MOVLB  A
62BA:  MOVWF  xBD
62BC:  MOVLW  14
62BE:  MOVWF  xBE
62C0:  CLRF   xC0
62C2:  MOVLW  69
62C4:  MOVWF  xBF
62C6:  MOVLB  0
62C8:  CALL   451A
....................             fprintf(COM2,"\n\ragain:"); 
62CC:  MOVLW  E2
62CE:  MOVWF  FF6
62D0:  MOVLW  22
62D2:  MOVWF  FF7
62D4:  CLRF   19
62D6:  BTFSC  FF2.7
62D8:  BSF    19.7
62DA:  BCF    FF2.7
62DC:  CALL   058E
62E0:  BTFSC  19.7
62E2:  BSF    FF2.7
....................             USART_getstring(STAR_ECHO, 20, password); 
62E4:  MOVLW  02
62E6:  MOVLB  A
62E8:  MOVWF  xBD
62EA:  MOVLW  14
62EC:  MOVWF  xBE
62EE:  CLRF   xC0
62F0:  MOVLW  55
62F2:  MOVWF  xBF
62F4:  MOVLB  0
62F6:  CALL   451A
....................             if(!stringcomp(entpassword,password)) 
62FA:  MOVLB  A
62FC:  CLRF   xBE
62FE:  MOVLW  69
6300:  MOVWF  xBD
6302:  CLRF   xC0
6304:  MOVLW  55
6306:  MOVWF  xBF
6308:  MOVLB  0
630A:  CALL   4652
630E:  MOVF   01,F
6310:  BNZ   6340
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
6312:  MOVLB  A
6314:  CLRF   xD2
6316:  MOVLW  14
6318:  MOVWF  xD3
631A:  CLRF   xD5
631C:  MOVLW  55
631E:  MOVWF  xD4
6320:  MOVLB  0
6322:  CALL   41B6
....................                fprintf(COM2,"\n\rOK\n\r");    
6326:  MOVLW  EC
6328:  MOVWF  FF6
632A:  MOVLW  22
632C:  MOVWF  FF7
632E:  CLRF   19
6330:  BTFSC  FF2.7
6332:  BSF    19.7
6334:  BCF    FF2.7
6336:  CALL   058E
633A:  BTFSC  19.7
633C:  BSF    FF2.7
....................             } 
....................                else 
633E:  BRA    6358
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
6340:  MOVLW  F4
6342:  MOVWF  FF6
6344:  MOVLW  22
6346:  MOVWF  FF7
6348:  CLRF   19
634A:  BTFSC  FF2.7
634C:  BSF    19.7
634E:  BCF    FF2.7
6350:  CALL   058E
6354:  BTFSC  19.7
6356:  BSF    FF2.7
....................                } 
....................          } 
....................             else 
6358:  BRA    6372
....................             { 
....................                fprintf(COM2," X\n\r"); 
635A:  MOVLW  FC
635C:  MOVWF  FF6
635E:  MOVLW  22
6360:  MOVWF  FF7
6362:  CLRF   19
6364:  BTFSC  FF2.7
6366:  BSF    19.7
6368:  BCF    FF2.7
636A:  CALL   058E
636E:  BTFSC  19.7
6370:  BSF    FF2.7
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
6372:  CLRF   FEA
6374:  MOVLW  41
6376:  MOVWF  FE9
6378:  MOVLW  00
637A:  CALL   0272
637E:  TBLRD*-
6380:  TBLRD*+
6382:  MOVF   FF5,W
6384:  MOVWF  FEE
6386:  IORLW  00
6388:  BNZ   6380
....................       if(!stringcomp(buffer_uart,buffer2)) 
638A:  MOVLW  01
638C:  MOVLB  A
638E:  MOVWF  xBE
6390:  MOVLW  4A
6392:  MOVWF  xBD
6394:  CLRF   xC0
6396:  MOVLW  41
6398:  MOVWF  xBF
639A:  MOVLB  0
639C:  CALL   4652
63A0:  MOVF   01,F
63A2:  BTFSS  FD8.2
63A4:  BRA    64B0
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
63A6:  MOVLW  02
63A8:  MOVWF  FF6
63AA:  MOVLW  23
63AC:  MOVWF  FF7
63AE:  CLRF   19
63B0:  BTFSC  FF2.7
63B2:  BSF    19.7
63B4:  BCF    FF2.7
63B6:  CALL   058E
63BA:  BTFSC  19.7
63BC:  BSF    FF2.7
63BE:  CLRF   19
63C0:  BTFSC  FF2.7
63C2:  BSF    19.7
63C4:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
63C6:  MOVLW  0A
63C8:  MOVLB  B
63CA:  MOVWF  x16
63CC:  MOVLB  0
63CE:  CALL   0548
63D2:  BTFSC  19.7
63D4:  BSF    FF2.7
63D6:  CLRF   19
63D8:  BTFSC  FF2.7
63DA:  BSF    19.7
63DC:  BCF    FF2.7
63DE:  MOVLW  0D
63E0:  MOVLB  B
63E2:  MOVWF  x16
63E4:  MOVLB  0
63E6:  CALL   0548
63EA:  BTFSC  19.7
63EC:  BSF    FF2.7
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
63EE:  MOVLW  22
63F0:  MOVWF  FF6
63F2:  MOVLW  23
63F4:  MOVWF  FF7
63F6:  CLRF   19
63F8:  BTFSC  FF2.7
63FA:  BSF    19.7
63FC:  BCF    FF2.7
63FE:  CALL   058E
6402:  BTFSC  19.7
6404:  BSF    FF2.7
6406:  CLRF   19
6408:  BTFSC  FF2.7
640A:  BSF    19.7
640C:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
640E:  MOVLW  0A
6410:  MOVLB  B
6412:  MOVWF  x16
6414:  MOVLB  0
6416:  CALL   0548
641A:  BTFSC  19.7
641C:  BSF    FF2.7
641E:  CLRF   19
6420:  BTFSC  FF2.7
6422:  BSF    19.7
6424:  BCF    FF2.7
6426:  MOVLW  0D
6428:  MOVLB  B
642A:  MOVWF  x16
642C:  MOVLB  0
642E:  CALL   0548
6432:  BTFSC  19.7
6434:  BSF    FF2.7
....................           USART_getstring(EN_ECHO, 3, temp); 
6436:  MOVLW  01
6438:  MOVLB  A
643A:  MOVWF  xBD
643C:  MOVLW  03
643E:  MOVWF  xBE
6440:  MOVLW  0A
6442:  MOVWF  xC0
6444:  MOVLW  89
6446:  MOVWF  xBF
6448:  MOVLB  0
644A:  CALL   451A
....................           debugmode = (unsigned int8)strtoi(temp); 
644E:  MOVLW  0A
6450:  MOVLB  A
6452:  MOVWF  xBE
6454:  MOVLW  89
6456:  MOVWF  xBD
6458:  MOVLB  0
645A:  CALL   4C2C
645E:  MOVFF  01,99E
6462:  CLRF   19
6464:  BTFSC  FF2.7
6466:  BSF    19.7
6468:  BCF    FF2.7
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
646A:  MOVLB  B
646C:  CLRF   x03
646E:  MOVLW  92
6470:  MOVWF  x02
6472:  MOVFF  99E,B04
6476:  MOVLB  0
6478:  CALL   364C
647C:  BTFSC  19.7
647E:  BSF    FF2.7
6480:  CLRF   19
6482:  BTFSC  FF2.7
6484:  BSF    19.7
6486:  BCF    FF2.7
....................           fprintf(COM2,"\n\r"); 
6488:  MOVLW  0A
648A:  MOVLB  B
648C:  MOVWF  x16
648E:  MOVLB  0
6490:  CALL   0548
6494:  BTFSC  19.7
6496:  BSF    FF2.7
6498:  CLRF   19
649A:  BTFSC  FF2.7
649C:  BSF    19.7
649E:  BCF    FF2.7
64A0:  MOVLW  0D
64A2:  MOVLB  B
64A4:  MOVWF  x16
64A6:  MOVLB  0
64A8:  CALL   0548
64AC:  BTFSC  19.7
64AE:  BSF    FF2.7
....................       }    
....................       #endif 
.................... } 
64B0:  GOTO   6912 (RETURN)
.................... //=============================================== 
....................  
....................  
.................... //========================= 
.................... int8 receiver_state=0,booting_done=0; 
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... {   
....................    char c; 
....................    //restart_wdt(); 
....................    //disable_interrupts(INT_TIMER0); 
....................    //set_timer0(0);   
....................    //disable_interrupts(INT_RDA);   
....................    c=fgetc(COM1); 
*
2342:  BTFSS  F9E.5
2344:  BRA    2342
2346:  MOVFF  FAF,AE1
234A:  MOVLB  A
....................    //if((c>127)||(c<30)) return; 
....................    //fprintf(COM2,"%c ",c);   
....................    #if defined(SIM900) 
....................    count_checking=0; 
....................    if(checking_sim==1) 
....................    { 
....................       restart_wdt(); 
....................       setup_wdt(WDT_OFF); 
....................       checking_sim=0; 
....................       fprintf(COM2,"OK\n\r"); 
....................    } 
....................    #endif 
....................    output_toggle(PIN_C2); 
234C:  BCF    F94.2
234E:  BTG    F8B.2
....................    if(booting_done) 
2350:  MOVLB  9
2352:  MOVF   xC0,F
2354:  BZ    238E
....................    { 
....................       buffer_uart[UART_index++]=c; 
2356:  MOVLB  1
2358:  MOVF   xAE,W
235A:  INCF   xAE,F
235C:  CLRF   03
235E:  ADDLW  4A
2360:  MOVWF  FE9
2362:  MOVLW  01
2364:  ADDWFC 03,W
2366:  MOVWF  FEA
2368:  MOVFF  AE1,FEF
....................       if(UART_index>=99) UART_index=0; 
236C:  MOVF   xAE,W
236E:  SUBLW  62
2370:  BTFSS  FD8.0
2372:  CLRF   xAE
....................       //============================= 
....................       //output_toggle(PIN_C2); 
....................       if(receiver_state==0) 
2374:  MOVLB  9
2376:  MOVF   xBF,F
2378:  BNZ   238E
....................       { 
....................          timing_wait=3000; 
237A:  MOVLW  0B
237C:  MOVLB  4
237E:  MOVWF  x90
2380:  MOVLW  B8
2382:  MOVWF  x8F
....................          SIM_state=data_analyze; 
2384:  MOVLW  0D
2386:  MOVWF  x8D
....................          count_polling=0; 
2388:  CLRF   x8C
238A:  CLRF   x8B
238C:  MOVLB  9
....................       } 
....................       //============================= 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................    } 
....................    return; 
....................    //enable_interrupts(INT_TIMER0); 
.................... } 
.................... //========================= 
238E:  BCF    F9E.5
2390:  MOVLB  0
2392:  GOTO   0084
.................... #INT_TIMER1 
.................... void timer1() 
.................... { 
....................    output_toggle(PIN_C2); 
2396:  BCF    F94.2
2398:  BTG    F8B.2
....................    set_timer1(0xffff-50); 
239A:  SETF   FCF
239C:  MOVLW  CD
239E:  MOVWF  FCE
.................... } 
.................... //========================== 
23A0:  BCF    F9E.0
23A2:  GOTO   0084
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
3EEC:  MOVLB  1
3EEE:  MOVF   x0C,F
3EF0:  BZ    3F2C
....................    { 
....................       if(count_kp<500)count_kp++; 
3EF2:  MOVF   x0F,W
3EF4:  SUBLW  01
3EF6:  BNC   3F06
3EF8:  BNZ   3F00
3EFA:  MOVF   x0E,W
3EFC:  SUBLW  F3
3EFE:  BNC   3F06
3F00:  INCF   x0E,F
3F02:  BTFSC  FD8.2
3F04:  INCF   x0F,F
....................       if(count_kp==500) 
3F06:  MOVF   x0E,W
3F08:  SUBLW  F4
3F0A:  BNZ   3F2C
3F0C:  DECFSZ x0F,W
3F0E:  BRA    3F2C
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
3F10:  MOVLW  F0
3F12:  MOVWF  FF6
3F14:  MOVLW  40
3F16:  MOVWF  FF7
3F18:  MOVLB  0
3F1A:  CALL   058E
....................             keyprss_off; 
3F1E:  BCF    F92.7
3F20:  BCF    F89.7
....................             kp_st=0;     
3F22:  MOVLB  1
3F24:  CLRF   x0D
....................             count_kp++; 
3F26:  INCF   x0E,F
3F28:  BTFSC  FD8.2
3F2A:  INCF   x0F,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
3F2C:  DECFSZ x08,W
3F2E:  BRA    3F4A
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
3F30:  MOVLB  9
3F32:  MOVF   xAA,F
3F34:  BNZ   3F3E
3F36:  MOVLB  0
3F38:  CALL   23A6
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
3F3C:  BRA    3F48
3F3E:  MOVLB  0
3F40:  CALL   2DFC
3F44:  MOVFF  01,AE3
3F48:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
3F4A:  DECFSZ x09,W
3F4C:  BRA    3F66
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
3F4E:  MOVLB  9
3F50:  MOVF   xAA,F
3F52:  BNZ   3F5C
3F54:  MOVLB  0
3F56:  CALL   23A6
....................          else temp=kbd_getc_slv(); 
3F5A:  BRA    3F66
3F5C:  MOVLB  0
3F5E:  CALL   2DFC
3F62:  MOVFF  01,AE3
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
3F66:  MOVLB  9
3F68:  MOVF   x8F,F
3F6A:  BNZ   3F8A
3F6C:  MOVF   x8E,F
3F6E:  BNZ   3F8A
3F70:  MOVF   x8D,F
3F72:  BNZ   3F8A
3F74:  MOVF   x8C,W
3F76:  SUBLW  04
3F78:  BNC   3F8A
3F7A:  MOVLW  01
3F7C:  ADDWF  x8C,F
3F7E:  BTFSC  FD8.0
3F80:  INCF   x8D,F
3F82:  BTFSC  FD8.2
3F84:  INCF   x8E,F
3F86:  BTFSC  FD8.2
3F88:  INCF   x8F,F
....................   if(mcr_timeout==5) 
3F8A:  MOVF   x8C,W
3F8C:  SUBLW  05
3F8E:  BNZ   3FE4
3F90:  MOVF   x8D,F
3F92:  BNZ   3FE4
3F94:  MOVF   x8E,F
3F96:  BNZ   3FE4
3F98:  MOVF   x8F,F
3F9A:  BNZ   3FE4
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
3F9C:  DECFSZ xA2,W
3F9E:  BRA    3FA6
3FA0:  MOVLB  0
3FA2:  BRA    37D8
3FA4:  MOVLB  9
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
3FA6:  MOVLW  05
3FA8:  MOVWF  FEA
3FAA:  MOVLW  0E
3FAC:  MOVWF  FE9
3FAE:  CLRF   00
3FB0:  MOVLW  03
3FB2:  MOVWF  02
3FB4:  MOVLW  52
3FB6:  MOVWF  01
3FB8:  MOVLB  0
3FBA:  RCALL  3C58
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
3FBC:  MOVLW  08
3FBE:  MOVWF  FEA
3FC0:  MOVLW  60
3FC2:  MOVWF  FE9
3FC4:  CLRF   00
3FC6:  MOVLW  01
3FC8:  MOVWF  02
3FCA:  MOVLW  2C
3FCC:  MOVWF  01
3FCE:  RCALL  3C58
....................       //debug_card(); 
....................       count_reading_error=0; 
3FD0:  MOVLB  9
3FD2:  CLRF   xA3
....................       mcr_timeout++;   
3FD4:  MOVLW  01
3FD6:  ADDWF  x8C,F
3FD8:  BTFSC  FD8.0
3FDA:  INCF   x8D,F
3FDC:  BTFSC  FD8.2
3FDE:  INCF   x8E,F
3FE0:  BTFSC  FD8.2
3FE2:  INCF   x8F,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
3FE4:  MOVLB  A
3FE6:  CLRF   xEE
3FE8:  MOVLW  94
3FEA:  MOVWF  xED
3FEC:  MOVLB  0
3FEE:  CALL   30FC
3FF2:  MOVFF  01,142
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
3FF6:  MOVLW  02
3FF8:  MOVLB  A
3FFA:  MOVWF  xEA
3FFC:  MOVLW  BC
3FFE:  MOVWF  xE9
4000:  CLRF   xEC
4002:  MOVFF  142,AEB
4006:  MOVLB  0
4008:  CALL   31F4
400C:  MOVFF  02,03
4010:  MOVF   xFC,W
4012:  SUBWF  02,W
4014:  BNC   4024
4016:  BNZ   401E
4018:  MOVF   01,W
401A:  SUBWF  xFB,W
401C:  BC    4024
401E:  INCF   xFB,F
4020:  BTFSC  FD8.2
4022:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
4024:  MOVLW  02
4026:  MOVLB  A
4028:  MOVWF  xEA
402A:  MOVLW  BC
402C:  MOVWF  xE9
402E:  CLRF   xEC
4030:  MOVFF  142,AEB
4034:  MOVLB  0
4036:  CALL   31F4
403A:  MOVFF  02,03
403E:  MOVF   01,W
4040:  SUBWF  xFB,W
4042:  BNZ   40EA
4044:  MOVF   03,W
4046:  SUBWF  xFC,W
4048:  BNZ   40EA
....................   { 
....................       charac_timeout++; 
404A:  INCF   xFB,F
404C:  BTFSC  FD8.2
404E:  INCF   xFC,F
....................       buf=get_countcard(); 
4050:  CALL   31A4
4054:  MOVFF  02,AE2
4058:  MOVFF  01,AE1
....................       if(buf<countcards) 
405C:  MOVLB  A
405E:  MOVF   xE2,W
4060:  SUBLW  01
4062:  BNC   408A
4064:  BNZ   406C
4066:  MOVF   xE1,W
4068:  SUBLW  5D
406A:  BNC   408A
....................       { 
....................          save_key_new(); 
406C:  MOVLB  0
406E:  BRA    3C72
....................          buf=buf+1; 
4070:  MOVLW  01
4072:  MOVLB  A
4074:  ADDWF  xE1,F
4076:  MOVLW  00
4078:  ADDWFC xE2,F
....................          save_coutcard(buf); 
407A:  MOVFF  AE2,AE5
407E:  MOVFF  AE1,AE4
4082:  MOVLB  0
4084:  RCALL  3DBA
....................       } 
....................          else 
4086:  BRA    409A
4088:  MOVLB  A
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
408A:  MOVLW  00
408C:  MOVWF  FF6
408E:  MOVLW  41
4090:  MOVWF  FF7
4092:  MOVLB  0
4094:  CALL   058E
....................             #if defined(SIM900) 
....................                //SIM_state=autosending; 
....................                SIM_state=SIM_reply;   
....................                strcpy(reply_buffer,"Full memory, please format memory"); 
....................             #endif 
....................             return; 
4098:  BRA    40EA
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
409A:  MOVLW  10
409C:  MOVWF  FF6
409E:  MOVLW  41
40A0:  MOVWF  FF7
40A2:  CALL   058E
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
40A6:  MOVLW  20
40A8:  MOVWF  FF6
40AA:  MOVLW  41
40AC:  MOVWF  FF7
40AE:  MOVLW  14
40B0:  MOVLB  B
40B2:  MOVWF  x0A
40B4:  MOVLB  0
40B6:  CALL   1930
40BA:  MOVLW  10
40BC:  MOVWF  FE9
40BE:  MOVFF  AE2,AE5
40C2:  MOVFF  AE1,AE4
40C6:  RCALL  3DF6
40C8:  MOVLW  37
40CA:  MOVWF  FF6
40CC:  MOVLW  41
40CE:  MOVWF  FF7
40D0:  MOVLW  03
40D2:  MOVLB  B
40D4:  MOVWF  x0A
40D6:  MOVLB  0
40D8:  CALL   1930
....................       data_avai=0; 
40DC:  MOVLB  9
40DE:  CLRF   xA1
....................       enable_getpin=0; 
40E0:  MOVLB  1
40E2:  CLRF   x09
....................       //dis_getpin; 
....................       output_low(PIN_C2); 
40E4:  BCF    F94.2
40E6:  BCF    F8B.2
40E8:  MOVLB  0
....................       #if defined(SIM900) 
....................        if(auto_sending==1)SIM_state=autosending; 
....................       #endif 
....................   } 
....................   //================================= 
....................   //================================= 
.................... } 
.................... //========================= 
40EA:  BCF    FF2.2
40EC:  GOTO   0084
.................... void main() 
.................... {  
*
64B4:  CLRF   FF8
64B6:  BCF    FD0.7
64B8:  BSF    07.7
64BA:  CLRF   FEA
64BC:  CLRF   FE9
64BE:  BSF    F7E.3
64C0:  MOVLW  40
64C2:  MOVWF  FB0
64C4:  MOVLW  03
64C6:  MOVWF  F7F
64C8:  MOVLW  A6
64CA:  MOVWF  FAD
64CC:  MOVLW  90
64CE:  MOVWF  FAC
64D0:  BCF    F94.0
64D2:  BSF    F8B.0
64D4:  CLRF   23
64D6:  CLRF   22
64D8:  CLRF   21
64DA:  MOVLW  96
64DC:  MOVWF  20
64DE:  CLRF   27
64E0:  CLRF   26
64E2:  MOVLW  AA
64E4:  MOVWF  25
64E6:  MOVLW  47
64E8:  MOVWF  24
64EA:  CLRF   xFA
64EC:  CLRF   xF9
64EE:  SETF   xFC
64F0:  SETF   xFB
64F2:  MOVLW  0E
64F4:  MOVWF  xFE
64F6:  MOVLW  01
64F8:  MOVWF  xFF
64FA:  MOVLB  1
64FC:  MOVWF  x00
64FE:  CLRF   x01
6500:  CLRF   x02
6502:  CLRF   x03
6504:  CLRF   x04
6506:  MOVLW  03
6508:  MOVWF  x06
650A:  MOVLW  E8
650C:  MOVWF  x05
650E:  CLRF   x07
6510:  CLRF   x08
6512:  CLRF   x09
6514:  MOVLW  64
6516:  MOVWF  x0A
6518:  CLRF   x0B
651A:  CLRF   x0C
651C:  CLRF   x0D
651E:  CLRF   x0F
6520:  CLRF   x0E
6522:  CLRF   x42
6524:  CLRF   x47
6526:  CLRF   xAE
6528:  CLRF   xAF
652A:  MOVLB  4
652C:  CLRF   x8C
652E:  CLRF   x8B
6530:  CLRF   x8D
6532:  CLRF   x8E
6534:  MOVLW  01
6536:  MOVWF  x90
6538:  MOVLW  2C
653A:  MOVWF  x8F
653C:  CLRF   x91
653E:  CLRF   x92
6540:  CLRF   x93
6542:  CLRF   x94
6544:  CLRF   x96
6546:  MOVLW  5A
6548:  MOVWF  x95
654A:  MOVLB  9
654C:  CLRF   x8F
654E:  CLRF   x8E
6550:  CLRF   x8D
6552:  CLRF   x8C
6554:  CLRF   x90
6556:  CLRF   x92
6558:  CLRF   x91
655A:  CLRF   x94
655C:  CLRF   x93
655E:  CLRF   x96
6560:  CLRF   x95
6562:  CLRF   x98
6564:  CLRF   x97
6566:  MOVLW  FD
6568:  MOVWF  x9A
656A:  MOVLW  E8
656C:  MOVWF  x99
656E:  CLRF   x9C
6570:  CLRF   x9B
6572:  CLRF   x9D
6574:  CLRF   x9E
6576:  CLRF   x9F
6578:  CLRF   xA0
657A:  CLRF   xA1
657C:  CLRF   xA2
657E:  CLRF   xA3
6580:  CLRF   xA4
6582:  CLRF   xA5
6584:  CLRF   xA7
6586:  MOVLW  01
6588:  MOVWF  xA6
658A:  CLRF   xA9
658C:  CLRF   xA8
658E:  CLRF   xAA
6590:  CLRF   xAE
6592:  CLRF   xAD
6594:  CLRF   xAC
6596:  CLRF   xAB
6598:  CLRF   xBF
659A:  CLRF   xC0
659C:  MOVLW  FF
659E:  MOVLB  F
65A0:  MOVWF  x48
65A2:  BCF    FC2.6
65A4:  BCF    FC2.7
65A6:  MOVF   x49,W
65A8:  ANDLW  E0
65AA:  IORLW  1F
65AC:  MOVWF  x49
65AE:  CLRF   FD2
65B0:  CLRF   FD1
65B2:  CLRF   1A
65B4:  CLRF   1B
65B6:  MOVLB  1
65B8:  CLRF   x43
65BA:  BCF    x44.0
65BC:  CLRF   x45
65BE:  CLRF   x46
65C0:  CLRF   x48
65C2:  BCF    x44.1
65C4:  CLRF   x49
65C6:  MOVLB  4
65C8:  CLRF   x71
65CA:  CLRF   x72
65CC:  CLRF   x73
65CE:  CLRF   x74
65D0:  CLRF   x75
65D2:  CLRF   x76
65D4:  CLRF   x77
65D6:  CLRF   x78
65D8:  CLRF   x79
65DA:  CLRF   x7A
65DC:  CLRF   x7B
65DE:  CLRF   x7C
65E0:  CLRF   x7D
65E2:  CLRF   x7E
65E4:  CLRF   x7F
65E6:  CLRF   x80
65E8:  CLRF   x81
65EA:  CLRF   x82
65EC:  CLRF   x83
65EE:  CLRF   x84
65F0:  CLRF   x85
65F2:  CLRF   x86
65F4:  CLRF   x87
65F6:  CLRF   x88
65F8:  CLRF   x89
65FA:  CLRF   x8A
65FC:  MOVLB  9
65FE:  CLRF   xC1
6600:  CLRF   xC2
6602:  CLRF   xC3
6604:  CLRF   xC4
6606:  CLRF   xC5
6608:  CLRF   xC6
660A:  CLRF   xC7
660C:  CLRF   xC8
660E:  CLRF   xC9
6610:  CLRF   xCA
6612:  CLRF   xCD
6614:  CLRF   xCF
6616:  CLRF   xCE
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................     RPINR1=5; 
6618:  MOVLW  05
661A:  MOVLB  E
661C:  MOVWF  xE7
....................    SIM_state = 0xff; 
661E:  MOVLB  4
6620:  SETF   x8D
....................    charac_timeout=0xffffffff; 
6622:  MOVLB  0
6624:  SETF   xFC
6626:  SETF   xFB
....................    key_timeout=0xffff; 
6628:  MOVLB  1
662A:  SETF   x06
662C:  SETF   x05
....................    setup_oscillator(OSC_32MHZ); 
662E:  MOVLW  70
6630:  MOVWF  FD3
6632:  MOVLW  40
6634:  MOVWF  F9B
6636:  MOVF   FD3,W
....................    keyprss_off; 
6638:  BCF    F92.7
663A:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
663C:  BCF    FF2.6
663E:  BCF    FF2.7
6640:  BTFSC  FF2.7
6642:  BRA    663E
....................    init_ext_eeprom(); 
6644:  MOVLB  0
6646:  GOTO   4152
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
664A:  MOVLW  04
664C:  MOVLB  A
664E:  MOVWF  x87
6650:  CLRF   19
6652:  BTFSC  FF2.7
6654:  BSF    19.7
6656:  BCF    FF2.7
6658:  MOVLW  FA
665A:  MOVWF  xEA
665C:  MOVLB  0
665E:  CALL   1B9C
6662:  BTFSC  19.7
6664:  BSF    FF2.7
6666:  MOVLB  A
6668:  DECFSZ x87,F
666A:  BRA    6650
....................    init_password(); 
666C:  MOVLB  0
666E:  CALL   420A
....................    EEPROM_read(strobe_pass_addr,20,password); 
6672:  MOVLB  A
6674:  CLRF   xBD
6676:  MOVLW  14
6678:  MOVWF  xBE
667A:  CLRF   xC0
667C:  MOVLW  55
667E:  MOVWF  xBF
6680:  MOVLB  0
6682:  CALL   415C
6686:  CLRF   19
6688:  BTFSC  FF2.7
668A:  BSF    19.7
668C:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
668E:  MOVLB  A
6690:  CLRF   xEE
6692:  MOVLW  7F
6694:  MOVWF  xED
6696:  MOVLB  0
6698:  CALL   30FC
669C:  BTFSC  19.7
669E:  BSF    FF2.7
66A0:  MOVFF  01,10C
....................    //===================================== 
....................    rtc_init(); 
66A4:  GOTO   4276
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
66A8:  MOVLW  19
66AA:  MOVLB  A
66AC:  MOVWF  x87
66AE:  MOVLB  0
66B0:  CALL   438E
66B4:  MOVFF  03,23
66B8:  MOVFF  02,22
66BC:  MOVFF  01,21
66C0:  MOVFF  00,20
....................     
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
66C4:  MOVLW  1E
66C6:  MOVLB  A
66C8:  MOVWF  x87
66CA:  MOVLB  0
66CC:  CALL   438E
66D0:  MOVFF  03,27
66D4:  MOVFF  02,26
66D8:  MOVFF  01,25
66DC:  MOVFF  00,24
66E0:  CLRF   19
66E2:  BTFSC  FF2.7
66E4:  BSF    19.7
66E6:  BCF    FF2.7
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card_key); 
....................    countcard=get_countcard(); 
66E8:  CALL   31A4
66EC:  BTFSC  19.7
66EE:  BSF    FF2.7
66F0:  MOVFF  02,FA
66F4:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
66F8:  SETF   xFC
66FA:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
66FC:  MOVLW  C7
66FE:  MOVWF  FD5
6700:  CLRF   19
6702:  BTFSC  FF2.7
6704:  BSF    19.7
6706:  BCF    FF2.7
....................    //setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
6708:  MOVLB  A
670A:  CLRF   xEE
670C:  MOVLW  94
670E:  MOVWF  xED
6710:  MOVLB  0
6712:  CALL   30FC
6716:  BTFSC  19.7
6718:  BSF    FF2.7
671A:  MOVFF  01,142
....................    if(delaycharaction==0)delaycharaction=1; 
671E:  MOVLB  1
6720:  MOVF   x42,F
6722:  BNZ   6728
6724:  MOVLW  01
6726:  MOVWF  x42
6728:  CLRF   19
672A:  BTFSC  FF2.7
672C:  BSF    19.7
672E:  BCF    FF2.7
....................    delaykey=read_ext_eeprom(strobe_delaykb); 
6730:  MOVLB  A
6732:  CLRF   xEE
6734:  MOVLW  95
6736:  MOVWF  xED
6738:  MOVLB  0
673A:  CALL   30FC
673E:  BTFSC  19.7
6740:  BSF    FF2.7
6742:  MOVFF  01,107
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
6746:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
6748:  BSF    FF0.3
674A:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
674C:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
674E:  MOVLW  C0
6750:  IORWF  FF2,F
....................    //========================================== 
....................    //delay_ms(100); 
....................    //EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................    //reset_password(); 
....................    //init_password(); 
....................    //fprintf(COM2,"Start\r\n"); 
....................    mcr_timeout=10000; 
6752:  MOVLB  9
6754:  CLRF   x8F
6756:  CLRF   x8E
6758:  MOVLW  27
675A:  MOVWF  x8D
675C:  MOVLW  10
675E:  MOVWF  x8C
6760:  CLRF   19
6762:  BTFSC  FF2.7
6764:  BSF    19.7
6766:  BCF    FF2.7
....................    //EEPROM_read(strobe_pass_addr,20,password); 
....................    //========================================== 
....................    //write_ext_eeprom(strobe_Master_SLV,1); 
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6768:  MOVLB  A
676A:  CLRF   xEE
676C:  MOVLW  91
676E:  MOVWF  xED
6770:  MOVLB  0
6772:  CALL   30FC
6776:  BTFSC  19.7
6778:  BSF    FF2.7
677A:  MOVFF  01,9AA
677E:  CLRF   19
6780:  BTFSC  FF2.7
6782:  BSF    19.7
6784:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
6786:  MOVLB  A
6788:  CLRF   xEE
678A:  MOVLW  92
678C:  MOVWF  xED
678E:  MOVLB  0
6790:  CALL   30FC
6794:  BTFSC  19.7
6796:  BSF    FF2.7
6798:  MOVFF  01,99E
679C:  CLRF   19
679E:  BTFSC  FF2.7
67A0:  BSF    19.7
67A2:  BCF    FF2.7
....................     auto_sending=read_ext_eeprom(strobe_autosending); 
67A4:  MOVLB  A
67A6:  CLRF   xEE
67A8:  MOVLW  93
67AA:  MOVWF  xED
67AC:  MOVLB  0
67AE:  CALL   30FC
67B2:  BTFSC  19.7
67B4:  BSF    FF2.7
67B6:  MOVFF  01,491
....................     key_timeout=1000; 
67BA:  MOVLW  03
67BC:  MOVLB  1
67BE:  MOVWF  x06
67C0:  MOVLW  E8
67C2:  MOVWF  x05
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
67C4:  MOVLB  0
67C6:  SETF   xFC
67C8:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    #if defined(SIM900) 
....................       //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................       //output_low(PIN_C7); 
....................       //set_tris_c(0); 
....................       #ASM 
....................          BCF    0xF94.7 
....................       #ENDASM 
....................       SIM_state = 0xff; 
....................       fprintf(COM2,"\r\nbooting...\r\n"); 
....................       delay_ms(10000); 
....................       receiver_state=1; 
....................       fprintf(COM1,"AT\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGF=1\r\n"); 
....................       delay_ms(1000); 
....................       //sim900_init(); 
....................       EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................       fprintf(COM1,"AT+CSMP=17,167,0,245\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGD=1\r\n");  
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGD=2\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGD=3\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGD=4\r\n"); 
....................       delay_ms(1000); 
....................       fprintf(COM1,"AT+CMGD=5\r\n");  
....................       output_high(PIN_C2); 
....................       delay_ms(1000); 
....................       SIM_state= idle; 
....................       #ASM 
....................          BSF    0xF94.7 
....................       #ENDASM 
....................       //set_tris_c(0xff); 
....................       //setup_wdt(WDT_ON); 
....................    #endif 
....................    booting_done=1; 
67CA:  MOVLW  01
67CC:  MOVLB  9
67CE:  MOVWF  xC0
....................    charac_timeout=0xffffffff; 
67D0:  MOVLB  0
67D2:  SETF   xFC
67D4:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
67D6:  MOVLW  66
67D8:  MOVLB  A
67DA:  MOVWF  xBD
67DC:  MOVLW  10
67DE:  MOVWF  xBE
67E0:  MOVLW  09
67E2:  MOVWF  xC0
67E4:  MOVLW  AF
67E6:  MOVWF  xBF
67E8:  MOVLB  0
67EA:  CALL   415C
....................    EEPROM_read(strobe_pass_addr,20,password); 
67EE:  MOVLB  A
67F0:  CLRF   xBD
67F2:  MOVLW  14
67F4:  MOVWF  xBE
67F6:  CLRF   xC0
67F8:  MOVLW  55
67FA:  MOVWF  xBF
67FC:  MOVLB  0
67FE:  CALL   415C
....................    set_tris_a(0xff);  
6802:  MOVLW  FF
6804:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
6806:  MOVLW  E0
6808:  MOVLB  F
680A:  MOVWF  x48
680C:  BCF    FC2.6
680E:  BCF    FC2.7
6810:  MOVF   x49,W
6812:  ANDLW  E0
6814:  IORLW  1F
6816:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
6818:  MOVF   FC1,W
681A:  ANDLW  C0
681C:  IORLW  03
681E:  MOVWF  FC1
6820:  BCF    FC1.7
6822:  BSF    FC2.0
6824:  BSF    FC1.6
6826:  BSF    FC2.1
6828:  BTFSC  FC2.1
682A:  BRA    6828
682C:  BCF    FC1.6
682E:  CLRF   19
6830:  BTFSC  FF2.7
6832:  BSF    19.7
6834:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
6836:  MOVLB  A
6838:  CLRF   xEE
683A:  MOVLW  7F
683C:  MOVWF  xED
683E:  MOVLB  0
6840:  CALL   30FC
6844:  BTFSC  19.7
6846:  BSF    FF2.7
6848:  MOVFF  01,10C
....................    
....................    memset(reply_buffer,0,sizeof(reply_buffer));  
684C:  MOVLW  03
684E:  MOVWF  FEA
6850:  MOVLW  40
6852:  MOVWF  FE9
6854:  CLRF   00
6856:  MOVLW  01
6858:  MOVWF  02
685A:  MOVLW  18
685C:  MOVWF  01
685E:  CALL   3C58
....................    memset(msg_data_sending,0,sizeof(msg_data_sending));  
6862:  MOVLW  01
6864:  MOVWF  FEA
6866:  MOVLW  B0
6868:  MOVWF  FE9
686A:  CLRF   00
686C:  MOVLW  01
686E:  MOVWF  02
6870:  MOVLW  18
6872:  MOVWF  01
6874:  CALL   3C58
....................     
....................    //save_coutcard(349); 
....................    while(1) 
....................    { 
....................      #if defined(SIM900) 
....................       count_polling++; 
....................       if(count_polling>=timing_wait) 
....................       { 
....................          count_polling=0; 
....................          //fprintf(COM2,"SIM_state %d\n\r",SIM_state); 
....................          switch(SIM_state) 
....................          { 
....................             case reading_sms_cmd:             
....................                cards=get_countcard(); 
....................                receiver_state=1; 
....................                memset(buffer_uart,0,sizeof(buffer_uart));  
....................                memset(mobilenumb,0,sizeof(mobilenumb));  
....................                fprintf(COM2,"reading_sms...\n\r"); 
....................                #ASM BCF    0xF94.7 #ENDASM                   
....................                   fprintf(COM1,"AT+CMGR=1\r\n"); 
....................                #ASM BSF    0xF94.7 #ENDASM 
....................                //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................                SIM_state=MSG_avai; 
....................                UART_index=0; 
....................                timing_wait=3000; 
....................                //fprintf(COM2,"device has %lu charactions\n\r",cards); 
....................             break; 
....................             case MSG_avai: 
....................                //fprintf(COM2,"MSG_avai...\n\r"); 
....................                //temp=checking_msg_avai(); 
....................                //fprintf(COM2,"MSG_avai...%d\n\r",temp); 
....................                //if(temp==1) SIM_state=reading_sms_cmd; 
....................                SIM_state=analyze_sms;  
....................                //fprintf(COM2,"\r\ntemp=%d\r\n",temp); 
....................                timing_wait=2000; 
....................             break; 
....................             case analyze_sms: 
....................                fprintf(COM2,"analyze_sms...\n\r");  
....................                del_buf(20,msg_buffer1); 
....................                del_buf(50,msg_buffer2); 
....................                del_buf(50,sim_bug); 
....................                //memset(msg_buffer1,0,sizeof(msg_buffer1)); 
....................                //memset(msg_buffer2,0,sizeof(msg_buffer2)); 
....................                //memset(sim_bug,0,sizeof(sim_bug)); 
....................                analyzing_msg(sim_bug,mobilenumb); 
....................                /*for(i=0;i<25;i++) 
....................                { 
....................                   fprintf(COM2,"%d",sim_bug[i]); 
....................                }*/ 
....................                 
....................                memset(buffer_uart,0,sizeof(buffer_uart));  
....................                SIM_state=checking_MN; 
....................                if((mobilenumb[0]==0)&&(mobilenumb[1]==0)&&(mobilenumb[2]==0)&&(mobilenumb[3]==0)&&(mobilenumb[4]==0))SIM_state= delete_MSG; 
....................                timing_wait=1500; 
....................                count_char=0; 
....................             break; 
....................             case checking_MN: 
....................                fprintf(COM2,"\n\rMobile phone number is "); 
....................                for(i=0;i<20;i++) fprintf(COM2,"%c",mobilenumb[i]);   
....................                fprintf(COM2,"\n\rMSG: "); 
....................                for(i=0;i<50;i++) fprintf(COM2,"%c",sim_bug[i]); 
....................                fprintf(COM2,"\n\rTIME: "); 
....................                for(i=0;i<25;i++) 
....................                { 
....................                   if(datetime[i]=='"')break; 
....................                   fprintf(COM2,"%c",datetime[i]); 
....................                } 
....................                 
....................                EEPROM_read(strobe_mobile_num1,20,msg_buffer1);  
....................               //strcpy(msg_buffer1,"+84903219082"); 
....................               //strcpy(msg_buffer1,"+16612891316");//+16612891316 
....................               strcpy(msg_buffer2,"rstpwd"); 
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
....................               { 
....................                  fprintf(COM2,"\n\rreset the password\n\r"); 
....................                  reset_password(); 
....................                  init_password(); 
....................                  strcpy(reply_buffer,"done"); 
....................                  fprintf(COM2,"done\n\r"); 
....................                  SIM_state=SIM_reply;  
....................                  break; 
....................               } 
....................               if(!stringcomp(mobilenumb,msg_buffer1))   
....................               { 
....................                   fprintf(COM2,"\n\rchecking phone number is done\n\r");  
....................                   updatetime2ds1307(); 
....................                   SIM_state=doing_sms; 
....................               } 
....................                else 
....................                { 
....................                   SIM_state=delete_MSG; 
....................                  strcpy(msg_buffer2,"cfmbn"); 
....................                  if(!strncmp(msg_buffer2,sim_bug,5))  
....................                  { 
....................                    SIM_state=delete_MSG;   
....................                    for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+6];                 
....................                    fprintf(COM2,"\n\rconfigured mobile phone number\n\r");  
....................                    for(i=0;i<20;i++)fprintf(COM2,"%c",msg_buffer2[i]);  
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",msg_buffer2[i]); 
....................                    fprintf(COM2,"\n\r");  
....................                    EEPROM_read(strobe_pass_addr,20,password); 
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%c",password[i]); 
....................                    for(i=0;i<20;i++) 
....................                    { 
....................                      if(password[i]==0)break; 
....................                            else count_char++; 
....................                    } 
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",password[i]); 
....................                    //fprintf(COM2,"count_char=%d\n\r",count_char);  
....................                    //fprintf(COM2,"\n\r"); 
....................                    if(!strncmp(password,msg_buffer2,count_char))  
....................                    { 
....................                       EEPROM_write(strobe_mobile_num1,20,mobilenumb); 
....................                       fprintf(COM2,"changed phone number\n\r("); 
....................                       for(i=0;i<20;i++)fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));  
....................                       strcpy(reply_buffer,"done"); 
....................                       fprintf(COM2,")\n\r"); 
....................                    } 
....................                      else 
....................                      { 
....................                         fprintf(COM2,"wrong password\n\r"); 
....................                         strcpy(reply_buffer,"wrong password"); 
....................                      }                      
....................                    SIM_state=SIM_reply;   
....................                  } 
....................                   else fprintf(COM2,"\n\r this phone unable to send commands \n\r"); 
....................                } 
....................             break; 
....................             case doing_sms: 
....................                
....................               memset(msg_data_sending,0,sizeof(msg_data_sending)); 
....................                
....................               strcpy(msg_buffer2,"password"); 
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
....................               { 
....................                 //SIM_state=delete_MSG;   
....................                 SIM_state=SIM_reply; 
....................                 for(i=0;i<20;i++) 
....................                 { 
....................                   write_ext_eeprom(strobe_pass_addr+i,sim_bug[i+9]); 
....................                   delay_us(10); 
....................                 } 
....................                 //EEPROM_write(strobe_pass_addr,20,sim_bug); 
....................                 fprintf(COM2,"changed the password\n\r");               
....................                 memset(password,0,sizeof(password)); 
....................                 EEPROM_read(strobe_pass_addr,20,password); 
....................                 for(i=0;i<20;i++) fprintf(COM2,"%c",password[i]); 
....................                 fprintf(COM2,"\n\rexit\n\r"); 
....................                 strcpy(reply_buffer,"done"); 
....................                 break; 
....................               } 
....................                
....................               strcpy(msg_buffer2,"keypress"); 
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 //SIM_state=SIM_reply; 
....................                 SIM_state=SIM_reply; 
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+9]; 
....................                 strcpy(msg_buffer1,"on"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
....................                 { 
....................                   fprintf(COM2,"\n\rkeypress turn on\n\r"); 
....................                   KP_mode = 1; 
....................                   write_ext_eeprom(strobe_keypressmode,KP_mode); 
....................                   fprintf(COM2," exit\n\r");                  
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
....................                 { 
....................                   fprintf(COM2,"\n\rkeypress turn off\n\r"); 
....................                   KP_mode = 0; 
....................                   write_ext_eeprom(strobe_keypressmode,KP_mode); 
....................                   fprintf(COM2," exit\n\r"); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................                 } 
....................                 strcpy(reply_buffer,"please check your syntax");  
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
....................                 break; 
....................               } 
....................               strcpy(msg_buffer2,"master"); 
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+7]; 
....................                 strcpy(msg_buffer1,"on"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
....................                 { 
....................                   fprintf(COM2,"\n\rmaster mode turn on\n\r"); 
....................                    mode_sl = 0; 
....................                    write_ext_eeprom(strobe_Master_SLV,mode_sl); 
....................                    strcpy(reply_buffer,"done"); 
....................                    fprintf(COM2," exit\n\r"); 
....................                    break; 
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
....................                 { 
....................                   fprintf(COM2,"\n\rmaster mode turn off\n\r"); 
....................                   mode_sl = 1; 
....................                   write_ext_eeprom(strobe_Master_SLV,mode_sl); 
....................                   strcpy(reply_buffer,"done"); 
....................                   fprintf(COM2," exit\n\r"); 
....................                   break; 
....................                 } 
....................                 strcpy(reply_buffer,"please check your syntax");  
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
....................                 break; 
....................               } 
....................                
....................               strcpy(msg_buffer2,"rsfact"); 
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
....................                   fprintf(COM2,"reset factory\n\r"); 
....................                   rstfact(); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................               }               
....................               strcpy(msg_buffer2,"trantime"); 
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
....................                 memset(msg_buffer2,0,sizeof(msg_buffer2)); 
....................                 //for(i=0;i<3;i++)msg_buffer2[i]=sim_bug[i+9]; 
....................                 if((sim_bug[9]>47)&&(sim_bug[9]<58))  
....................                 { 
....................                    delaycharaction = (sim_bug[9]-48)*10; 
....................                    if((sim_bug[10]>47)&&(sim_bug[10]<58))delaycharaction=delaycharaction+(sim_bug[10]-48); 
....................                      else delaycharaction = sim_bug[9]-48; 
....................                   fprintf(COM2,"tran time = %d\n\r",delaycharaction);   
....................                   write_ext_eeprom(strobe_delaytime,delaycharaction); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................                 } 
....................                   else  
....................                      { 
....................                         fprintf(COM2,"\n\rplease check your syntax\n\r"); 
....................                         strcpy(reply_buffer,"please check your syntax");  
....................                         break; 
....................                      } 
....................                 break; 
....................               } 
....................                 
....................               strcpy(msg_buffer2,"autosending"); 
....................               if(!strncmp(msg_buffer2,sim_bug,11))  
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+12]; 
....................                 strcpy(msg_buffer1,"on"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
....................                 { 
....................                   fprintf(COM2,"\n\rautosending turn on\n\r"); 
....................                   auto_sending = 1; 
....................                   write_ext_eeprom(strobe_autosending,auto_sending); 
....................                   fprintf(COM2," exit\n\r"); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
....................                 { 
....................                   fprintf(COM2,"\n\rautosending turn off\n\r"); 
....................                   auto_sending = 0; 
....................                   write_ext_eeprom(strobe_autosending,auto_sending); 
....................                   fprintf(COM2," exit\n\r"); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................                 } 
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
....................                 strcpy(reply_buffer,"please check your syntax"); 
....................                 //fprintf(COM2," exit\n\r"); 
....................                 break; 
....................               } 
....................  
....................               strcpy(msg_buffer2,"qullf"); 
....................               if(!strncmp(msg_buffer2,sim_bug,5))  
....................               { 
....................                 SIM_state=delete_MSG; 
....................                 fprintf(COM2,"FORMATTING..."); 
....................                 ease_eeprom(); 
....................                 fprintf(COM2," exit\n\r"); 
....................                 break; 
....................               } 
....................               strcpy(msg_buffer2,"format"); 
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
....................                   fprintf(COM2,"FORMATTING..."); 
....................                   format_eepromext(); 
....................                   fprintf(COM2," exit\n\r"); 
....................                   strcpy(reply_buffer,"done"); 
....................                   break; 
....................               } 
....................               strcpy(msg_buffer2,"count tran"); 
....................               if(!strncmp(msg_buffer2,sim_bug,10))  
....................               {   
....................                   len=0; 
....................                   cards=get_countcard(); 
....................                   strcpy(msg_buffer2,"device has "); 
....................                   len=pre_msg(msg_buffer2,msg_data_sending,0); 
....................                   itoa(cards,10,string); 
....................                   len=pre_msg(string,msg_data_sending,len); 
....................                   strcpy(msg_buffer2," transaction "); 
....................                   len=pre_msg(msg_buffer2,msg_data_sending,len); 
....................                   SIM_state=MSG_sending; 
....................                   lastlen=0; 
....................                   fprintf(COM2,"device has %lu transaction \n\r",cards); 
....................                   countc=0; 
....................                   count_dwla=0; 
....................                   break; 
....................               } 
....................               strcpy(msg_buffer2,"download all"); 
....................               if(!strncmp(msg_buffer2,sim_bug,12)) 
....................               { 
....................                    fprintf(COM2,"download all\n\r");   
....................                    count_dwla=get_countcard(); 
....................                    len=0; 
....................                    num_card=count_dwla; 
....................                    SIM_state=pre_cmd; 
....................                    countc=0; 
....................                    break; 
....................               } 
....................               strcpy(msg_buffer2,"download "); 
....................               if(!strncmp(msg_buffer2,sim_bug,9)) 
....................               { 
....................                   if((sim_bug[9]<48)||(sim_bug[9]>57)) 
....................                   { 
....................                      SIM_state=SIM_reply; 
....................                      fprintf(COM2,"\n\rplease check your syntax\n\r"); 
....................                      strcpy(reply_buffer,"please check your syntax"); 
....................                      break; 
....................                   } 
....................                   i=0; 
....................                   temp=sim_bug[9]; 
....................                   while(temp!=0) 
....................                   { 
....................                      temp=sim_bug[i+9]; 
....................                      string[i++]=temp; 
....................                   } 
....................                   countc=atoi(string); 
....................                   //fprintf(COM2,"countc=%lu\n\r",countc); 
....................                   count_dwla=get_countcard(); 
....................                   if(count_dwla<countc) 
....................                   { 
....................                      len=0; 
....................                      strcpy(buftemp2,"Device has only "); 
....................                      len=pre_msg(buftemp2,msg_data_sending,0); 
....................                      itoa(count_dwla,10,string); 
....................                      len=pre_msg(string,msg_data_sending,len); 
....................                      strcpy(buftemp2," transaction ");//transaction\n\r 
....................                      len=pre_msg(buftemp2,msg_data_sending,len); 
....................                      SIM_state=MSG_sending; 
....................                      lastlen=0; 
....................                      count_dwla=0; 
....................                      num_card=0; 
....................                      break; 
....................                   } 
....................                   else  
....................                   { 
....................                      num_card=count_dwla; 
....................                      countc=num_card-countc; 
....................                      if(countc==0)count_dwla=num_card; 
....................                      else count_dwla=0; 
....................                      SIM_state=pre_cmd; 
....................                      break; 
....................                   } 
....................                   //SIM_state=delete_MSG; 
....................               } 
....................               else SIM_state=delete_MSG; 
....................             break; 
....................             case delete_MSG: 
....................                fprintf(COM2,"delete_MSG...\n\r"); 
....................                #ASM BCF    0xF94.7 #ENDASM  
....................                   fprintf(COM1,"AT+CMGD=1\r\n"); 
....................                #ASM BSF    0xF94.7 #ENDASM  
....................                del_buf(200,buffer_uart); 
....................                //SIM_state=sending_cmd;        
....................                timing_wait=10000; 
....................                SIM_state= idle; 
....................                output_low(PIN_C2); 
....................                memset(reply_buffer,0,sizeof(reply_buffer));  
....................                SIM_reply_st=0; 
....................             break; 
....................             case pre_cmd: 
....................                    //fprintf(COM2,"pre_cmd-> num_card,countc, count_dwla=%lu,%lu,%lu\r\n",num_card,countc,count_dwla);   
....................                    if(num_card==0)  
....................                    { 
....................                      SIM_state=delete_MSG; 
....................                      break; 
....................                    } 
....................                    len=0; 
....................                    //num_card=1; 
....................                    memset(msg_data_sending,0,sizeof(msg_data_sending));  
....................                    addr_dat=num_card*numdata+ptr_start; 
....................                    I2CEEPROM_read((unsigned int16)(addr_dat-numdata),numdata,buftemp); 
....................                    itoa(buftemp[0],10,string); 
....................                    len=pre_msg(string,msg_data_sending,0); 
....................                    msg_data_sending[len++]='/'; 
....................                    itoa(buftemp[1],10,string); 
....................                    len=pre_msg(string,msg_data_sending,len); 
....................                    msg_data_sending[len++]='/'; 
....................                    msg_data_sending[len++]=' '; 
....................                    itoa(buftemp[2],10,string); 
....................                    len=pre_msg(string,msg_data_sending,len); 
....................                    msg_data_sending[len++]=':'; 
....................                    itoa(buftemp[3],10,string); 
....................                    len=pre_msg(string,msg_data_sending,len); 
....................                    msg_data_sending[len++]=':'; 
....................                    itoa(buftemp[4],10,string); 
....................                    len=pre_msg(string,msg_data_sending,len); 
....................                    //msg_data_sending[len++]=' '; 
....................                    i=0; 
....................                    strcpy(buftemp2," Track1>"); 
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
....................                    temp=0; 
....................                    while((i<numbyteoftrack1)&&(temp!='?')) 
....................                    { 
....................                      temp = buftemp[i+5]; 
....................                      //fprintf(COM2,"%c",temp);  
....................                      if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
....................                      i++; 
....................                      if(temp==0)break; 
....................                    } 
....................                    i=0; 
....................                    temp=0; 
....................                    strcpy(buftemp2," Track2>"); 
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
....................                    while((i<numbyteoftrack2)&&(temp!='?')) 
....................                    { 
....................                      temp = buftemp[i+5+numbyteoftrack1]; 
....................                      //fprintf(COM2,"%c",temp);  
....................                      if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
....................                      i++; 
....................                      if(temp==0)break; 
....................                    } 
....................                    addr_key=EEPROM_KEY_ST+((num_card-1)*50); 
....................                    //if(ptr_card_key>addr_key) 
....................                    //{ 
....................                       strcpy(buftemp2," PIN:"); 
....................                       len=pre_msg(buftemp2,msg_data_sending,len); 
....................                       j=0; 
....................                       do 
....................                       { 
....................                         temp=read_ext_eeprom(j+addr_key); 
....................                         if(((temp>47)&&(temp<58))||((temp=='#')||(temp=='*'))||(temp>64)&&(temp<73)) 
....................                            msg_data_sending[len++]=temp; 
....................                         j++; 
....................                       } 
....................                       while((j<key_numbyte)&&(temp!=0)); 
....................                       fprintf(COM2,"%lu character\n\r",len);   
....................                      //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                       //addr_key=addr_key+(50); 
....................                     //}        
....................                    lastlen=0;  
....................                    //fprintf(COM2,"countc,num_card =%lu,%lu\n\r",countc,num_card); 
....................                    if((countc==num_card)&&(countc!=0)) 
....................                    { 
....................                      SIM_state=delete_MSG;  
....................                      break; 
....................                    } 
....................                    num_card--; 
....................                    //fprintf(COM2,"send_oneMSG =%d\n\r",send_oneMSG); 
....................                    if(send_oneMSG==1) 
....................                    { 
....................                      num_card=0; 
....................                      send_oneMSG=0; 
....................                    } 
....................                    SIM_state=MSG_sending;               
....................             break; 
....................             case MSG_sending: 
....................                   fprintf(COM2,"MSG_sending %d\n\r",MSG_sending_st); 
....................                   //fprintf(COM2,"MSG_sending_st %d\n\r",MSG_sending_st); 
....................                   timing_wait=10000; 
....................                output_high(PIN_C2); 
....................                #ASM BCF    0xF94.7 #ENDASM  
....................                switch(MSG_sending_st) 
....................                { 
....................                   case 0:// configure MSG 
....................                      receiver_state=1; 
....................                         fprintf(COM1,"AT+CMGF=1\r\n"); // text mode 
....................                      //fprintf(COM2,"AT+CMGF=1\r\n"); // text mode 
....................                      strl= strlen(msg_data_sending); 
....................                      MSG_sending_st=1; 
....................                      //EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
....................                   break; 
....................                   case 1: 
....................                         fprintf(COM1,"AT+CMGS="); 
....................                      //fprintf(COM2,"AT+CMGS="); 
....................                      fputc('"',COM1); 
....................                      i=0; 
....................                      while((mobilenumb[i]!=0)&&(i<20)) 
....................                      { 
....................                         fputc(mobilenumb[i],COM1); 
....................                         //fprintf(COM2,"%c",mobilenumb[i]);  
....................                         i++; 
....................                      } 
....................                      fputc('"',COM1); 
....................                      fprintf(COM1,"\r\n"); 
....................                      MSG_sending_st=2; 
....................                   break; 
....................                   case 2: 
....................                      //while((msg_data_sending[i]!=0)&&(i<140)) 
....................                      for(i=0;i<140;i++) 
....................                      { 
....................                         if(msg_data_sending[i+lastlen]==0) 
....................                         { 
....................                            SIM_state=delete_MSG;    
....................                            MSG_sending_st=0; 
....................                            break; 
....................                         } 
....................                         fputc(msg_data_sending[i+lastlen],COM1); 
....................                      } 
....................                      //fprintf(COM2,"i= %u\n\r",i);  
....................                      fputc(26,COM1); 
....................                      MSG_sending_st=0; 
....................                      if(i<140) 
....................                      { 
....................                         SIM_state=check_st; 
....................                         lastlen=0; 
....................                      } 
....................                      else 
....................                      { 
....................                         lastlen=140; 
....................                         if(msg_data_sending[140]==0)SIM_state=check_st; 
....................                      } 
....................                      if(lastlen==140)SIM_state=MSG_sending; 
....................                      //fprintf(COM2,"lastlen %lu\n\r",lastlen);   
....................                   break; 
....................                } 
....................                #ASM BSF    0xF94.7 #ENDASM  
....................             break; 
....................             case check_st: 
....................                //fprintf(COM2,"check_st->num_card,countc, count_dwla, lastlen =%lu,%lu,%lu,%lu\r\n",num_card,countc,count_dwla,lastlen);   
....................                if(count_dwla>1) 
....................                { 
....................                   count_dwla--; 
....................                   SIM_state=pre_cmd; 
....................                   break; 
....................                } 
....................                else if(countc>0)  
....................                { 
....................                   SIM_state=pre_cmd; 
....................                   break; 
....................                } 
....................                else SIM_state=delete_MSG; 
....................             break; 
....................             case autosending:  
....................                   auto_sending=read_ext_eeprom(strobe_autosending); 
....................                   if(auto_sending==1) 
....................                   { 
....................                      EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
....................                      fprintf(COM2,"\r\nSending...\r\n");  
....................                      num_card=get_countcard(); 
....................                      countc=0; 
....................                      count_dwla=0; 
....................                      lastlen=0; 
....................                      send_oneMSG=1; 
....................                      SIM_state=pre_cmd; 
....................                   } 
....................                   else SIM_state= reading_sms_cmd; 
....................             break; 
....................             case idle: 
....................                   output_toggle(PIN_C2); 
....................                   fprintf(COM2,"idle\n\r"); 
....................                   fprintf(COM1,"AT+CMGF=1\r\n"); 
....................                   output_low(PIN_C2); 
....................                   SIM_state= data_analyze; 
....................                   receiver_state=0; 
....................                   timing_wait=1500; 
....................             break; 
....................             case data_analyze: 
....................                   //fprintf(COM2,"data_analyze=%d\n\r",temp); 
....................                   booting_done=1; 
....................                   output_low(PIN_C2); 
....................                   temp=SMS_coming(); 
....................                   if(temp==2) 
....................                   { 
....................                      output_high(PIN_C2); 
....................                      SIM_state=reading_sms_cmd; 
....................                      count_checking=0; 
....................                   } 
....................                   count_checking++; 
....................                   if(count_checking==100) 
....................                   { 
....................                      //SIM_state=phone_activity_status; 
....................                      SIM_state=check_comunication; 
....................                      count_checking=0; 
....................                   } 
....................             break; 
....................             case SIM_reply: 
....................                   fprintf(COM2,"SIM is replying\n\r"); 
....................                   //send_sms(mobilenumb,reply_buffer); 
....................                   len=0; 
....................                   cards=get_countcard(); 
....................                   //strcpy(msg_buffer2,"device has "); 
....................                   len=pre_msg(reply_buffer,msg_data_sending,0); 
....................                   //itoa(cards,10,string); 
....................                   //len=pre_msg(string,msg_data_sending,len); 
....................                   //strcpy(msg_buffer2," transaction "); 
....................                   //len=pre_msg(msg_buffer2,msg_data_sending,len); 
....................                   SIM_state=MSG_sending; 
....................                   lastlen=0; 
....................                   //fprintf(COM2,"device has %lu transaction \n\r",cards); 
....................                   countc=0; 
....................                   count_dwla=0; 
....................             break; 
....................             case check_comunication: 
....................                fprintf(COM2,"check comunication\n\r"); 
....................                //SIM_state= data_analyze; 
....................                SIM_state= phone_activity_status; 
....................                booting_done=0; 
....................                checking_sim=1; 
....................                setup_wdt(WDT_ON); 
....................                fprintf(COM1,"AT\r\n");   
....................             break; 
....................             case phone_activity_status: 
....................                booting_done=1; 
....................                fprintf(COM2,"SIM activity status\n\r"); 
....................                SIM_state= data_analyze; 
....................                fprintf(COM1,"AT+CPAS\r\n");  
....................             break; 
....................             case check_inbox: 
....................                fprintf(COM2,"check inbox\n\r"); 
....................                SIM_state= data_analyze; 
....................                fprintf(COM1,"AT+CMGR=1\r\n"); 
....................             break; 
....................          }         
....................       } 
....................       //restart_wdt(); 
....................       delay_us(500); 
....................      #else 
....................       if(mode==LOGOFF) 
6878:  MOVLB  9
687A:  MOVF   xA4,F
687C:  BNZ   6908
....................       { 
....................          fprintf(COM2,"password:"); 
687E:  MOVLW  3C
6880:  MOVWF  FF6
6882:  MOVLW  41
6884:  MOVWF  FF7
6886:  CLRF   19
6888:  BTFSC  FF2.7
688A:  BSF    19.7
688C:  BCF    FF2.7
688E:  MOVLB  0
6890:  CALL   058E
6894:  BTFSC  19.7
6896:  BSF    FF2.7
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
6898:  MOVLW  02
689A:  MOVLB  A
689C:  MOVWF  xBD
689E:  MOVLW  14
68A0:  MOVWF  xBE
68A2:  MOVLW  01
68A4:  MOVWF  xC0
68A6:  MOVLW  4A
68A8:  MOVWF  xBF
68AA:  MOVLB  0
68AC:  CALL   451A
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          if(!stringcomp(buffer_uart,password)) 
68B0:  MOVLW  01
68B2:  MOVLB  A
68B4:  MOVWF  xBE
68B6:  MOVLW  4A
68B8:  MOVWF  xBD
68BA:  CLRF   xC0
68BC:  MOVLW  55
68BE:  MOVWF  xBF
68C0:  MOVLB  0
68C2:  CALL   4652
68C6:  MOVF   01,F
68C8:  BNZ   68EC
....................          { 
....................             mode=LOGON; 
68CA:  MOVLW  01
68CC:  MOVLB  9
68CE:  MOVWF  xA4
....................             fprintf(COM2," OK\n\r"); 
68D0:  MOVLW  46
68D2:  MOVWF  FF6
68D4:  MOVLW  41
68D6:  MOVWF  FF7
68D8:  CLRF   19
68DA:  BTFSC  FF2.7
68DC:  BSF    19.7
68DE:  BCF    FF2.7
68E0:  MOVLB  0
68E2:  CALL   058E
68E6:  BTFSC  19.7
68E8:  BSF    FF2.7
....................          } 
....................          else fprintf(COM2," X\n\r"); 
68EA:  BRA    6904
68EC:  MOVLW  4C
68EE:  MOVWF  FF6
68F0:  MOVLW  41
68F2:  MOVWF  FF7
68F4:  CLRF   19
68F6:  BTFSC  FF2.7
68F8:  BSF    19.7
68FA:  BCF    FF2.7
68FC:  CALL   058E
6900:  BTFSC  19.7
6902:  BSF    FF2.7
....................       } 
....................          else if(mode==LOGON)adminmode();//*/ 
6904:  BRA    6912
6906:  MOVLB  9
6908:  DECFSZ xA4,W
690A:  BRA    6914
690C:  MOVLB  0
690E:  GOTO   4E10
6912:  MOVLB  9
....................      #endif     
....................    } 
6914:  BRA    687A
.................... } 
6916:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS

CCS PCH C Compiler, Version 4.140, 33034               06-May-17 18:11

               Filename:   D:\magnertic_card_prj\for chris\(..)(..)(..)(..)(..)(..)(..)(..)fixbug2017\firmware\newGSM -newkeypad -18F46J11\main.lst

               ROM used:   39294 bytes (60%)
                           Largest free fragment is 26230
               RAM used:   2706 (72%) at main() level
                           2801 (74%) worst case
               Stack:     9 worst case (4 in main + 5 for interrupts)

*
0000:  GOTO   6BF2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   470E
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   239E
006C:  BTFSS  FF0.3
006E:  GOTO   0078
0072:  BTFSC  FF0.0
0074:  GOTO   1CB6
0078:  BTFSS  F9D.5
007A:  GOTO   0084
007E:  BTFSC  F9E.5
0080:  GOTO   22CC
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... #define SIM900 
.................... #define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... #device PIC18F26J11 
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0736:  MOVLW  02
0738:  MOVLB  A
073A:  SUBWF  xB4,F
073C:  BNC   0756
073E:  MOVLW  0A
0740:  MOVWF  FEA
0742:  MOVLW  B4
0744:  MOVWF  FE9
0746:  MOVF   FEF,W
0748:  BZ    0756
074A:  BRA    0752
074C:  BRA    074E
074E:  BRA    0750
0750:  NOP   
0752:  DECFSZ FEF,F
0754:  BRA    074C
0756:  MOVLB  0
0758:  RETURN 0
*
1984:  MOVLW  0A
1986:  MOVWF  FEA
1988:  MOVLW  BC
198A:  MOVWF  FE9
198C:  MOVF   FEF,W
198E:  BZ    19AA
1990:  MOVLW  0A
1992:  MOVWF  01
1994:  CLRF   00
1996:  DECFSZ 00,F
1998:  BRA    1996
199A:  DECFSZ 01,F
199C:  BRA    1994
199E:  MOVLW  5F
19A0:  MOVWF  00
19A2:  DECFSZ 00,F
19A4:  BRA    19A2
19A6:  DECFSZ FEF,F
19A8:  BRA    1990
19AA:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
*
6520:  BTFSS  F9E.4
6522:  BRA    6520
6524:  MOVWF  FAE
6526:  RETURN 0
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
075A:  BCF    F94.0
075C:  BCF    F8B.0
075E:  MOVLW  08
0760:  MOVWF  01
0762:  BRA    0764
0764:  NOP   
0766:  BSF    01.7
0768:  BRA    078A
076A:  BCF    01.7
076C:  MOVLB  A
076E:  RRCF   xDF,F
0770:  MOVLB  0
0772:  BTFSC  FD8.0
0774:  BSF    F8B.0
0776:  BTFSS  FD8.0
0778:  BCF    F8B.0
077A:  BSF    01.6
077C:  BRA    078A
077E:  BCF    01.6
0780:  DECFSZ 01,F
0782:  BRA    076C
0784:  BRA    0786
0786:  NOP   
0788:  BSF    F8B.0
078A:  MOVLW  10
078C:  MOVWF  FE9
078E:  DECFSZ FE9,F
0790:  BRA    078E
0792:  BRA    0794
0794:  NOP   
0796:  BTFSC  01.7
0798:  BRA    076A
079A:  BTFSC  01.6
079C:  BRA    077E
079E:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
5696:  MOVLB  A
5698:  MOVF   x92,F
569A:  BNZ   56A0
569C:  MOVF   x93,F
569E:  BZ    5724
....................       if (*s1 != *s2) 
56A0:  MOVFF  A8E,FE9
56A4:  MOVFF  A8F,FEA
56A8:  MOVFF  FEF,A94
56AC:  MOVFF  A91,03
56B0:  MOVFF  A90,FE9
56B4:  MOVFF  A91,FEA
56B8:  MOVF   FEF,W
56BA:  SUBWF  x94,W
56BC:  BZ    56EC
....................          return((*s1 <*s2) ? -1: 1); 
56BE:  MOVFF  A8F,03
56C2:  MOVFF  A8E,FE9
56C6:  MOVFF  A8F,FEA
56CA:  MOVFF  FEF,A94
56CE:  MOVFF  A91,03
56D2:  MOVFF  A90,FE9
56D6:  MOVFF  A91,FEA
56DA:  MOVF   FEF,W
56DC:  SUBWF  x94,W
56DE:  BC    56E4
56E0:  MOVLW  FF
56E2:  BRA    56E6
56E4:  MOVLW  01
56E6:  MOVWF  01
56E8:  BRA    5728
....................       else if (*s1 == '\0') 
56EA:  BRA    5702
56EC:  MOVFF  A8F,03
56F0:  MOVFF  A8E,FE9
56F4:  MOVFF  A8F,FEA
56F8:  MOVF   FEF,F
56FA:  BNZ   5702
....................          return(0); 
56FC:  MOVLW  00
56FE:  MOVWF  01
5700:  BRA    5728
5702:  MOVFF  A8F,03
5706:  MOVF   x8E,W
5708:  INCF   x8E,F
570A:  BTFSC  FD8.2
570C:  INCF   x8F,F
570E:  MOVFF  A91,03
5712:  MOVF   x90,W
5714:  INCF   x90,F
5716:  BTFSC  FD8.2
5718:  INCF   x91,F
571A:  MOVF   x92,W
571C:  BTFSC  FD8.2
571E:  DECF   x93,F
5720:  DECF   x92,F
5722:  BRA    5698
....................    return(0); 
5724:  MOVLW  00
5726:  MOVWF  01
.................... } 
5728:  MOVLB  0
572A:  RETURN 0
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
5EF0:  MOVFF  A97,A99
5EF4:  MOVFF  A96,A98
5EF8:  MOVFF  A99,03
5EFC:  MOVLB  A
5EFE:  MOVFF  A98,FE9
5F02:  MOVFF  A99,FEA
5F06:  MOVF   FEF,F
5F08:  BZ    5F16
5F0A:  INCF   x98,F
5F0C:  BTFSC  FD8.2
5F0E:  INCF   x99,F
5F10:  MOVLB  0
5F12:  BRA    5EF8
5F14:  MOVLB  A
....................    return(sc - s); 
5F16:  MOVF   x96,W
5F18:  SUBWF  x98,W
5F1A:  MOVWF  00
5F1C:  MOVF   x97,W
5F1E:  SUBWFB x99,W
5F20:  MOVWF  03
5F22:  MOVFF  00,01
.................... } 
5F26:  MOVLB  0
5F28:  RETURN 0
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
62F6:  MOVLB  A
62F8:  CLRF   x93
....................    sign = 0; 
62FA:  CLRF   x91
....................    base = 10; 
62FC:  MOVLW  0A
62FE:  MOVWF  x92
....................    result = 0; 
6300:  CLRF   x90
....................  
....................    if (!s) 
6302:  MOVF   x8E,W
6304:  IORWF  x8F,W
6306:  BNZ   630E
....................       return 0; 
6308:  MOVLW  00
630A:  MOVWF  01
630C:  BRA    6494
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
630E:  MOVF   x93,W
6310:  INCF   x93,F
6312:  CLRF   03
6314:  ADDWF  x8E,W
6316:  MOVWF  FE9
6318:  MOVF   x8F,W
631A:  ADDWFC 03,W
631C:  MOVWF  FEA
631E:  MOVFF  FEF,A94
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
6322:  MOVF   x94,W
6324:  SUBLW  2D
6326:  BNZ   6342
....................    { 
....................       sign = 1;         // Set the sign to negative 
6328:  MOVLW  01
632A:  MOVWF  x91
....................       c = s[index++]; 
632C:  MOVF   x93,W
632E:  INCF   x93,F
6330:  CLRF   03
6332:  ADDWF  x8E,W
6334:  MOVWF  FE9
6336:  MOVF   x8F,W
6338:  ADDWFC 03,W
633A:  MOVWF  FEA
633C:  MOVFF  FEF,A94
....................    } 
....................    else if (c == '+') 
6340:  BRA    635C
6342:  MOVF   x94,W
6344:  SUBLW  2B
6346:  BNZ   635C
....................    { 
....................       c = s[index++]; 
6348:  MOVF   x93,W
634A:  INCF   x93,F
634C:  CLRF   03
634E:  ADDWF  x8E,W
6350:  MOVWF  FE9
6352:  MOVF   x8F,W
6354:  ADDWFC 03,W
6356:  MOVWF  FEA
6358:  MOVFF  FEF,A94
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
635C:  MOVF   x94,W
635E:  SUBLW  2F
6360:  BTFSC  FD8.0
6362:  BRA    6484
6364:  MOVF   x94,W
6366:  SUBLW  39
6368:  BTFSS  FD8.0
636A:  BRA    6484
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
636C:  MOVF   x94,W
636E:  SUBLW  30
6370:  BNZ   63B4
6372:  CLRF   03
6374:  MOVF   x93,W
6376:  ADDWF  x8E,W
6378:  MOVWF  FE9
637A:  MOVF   x8F,W
637C:  ADDWFC 03,W
637E:  MOVWF  FEA
6380:  MOVF   FEF,W
6382:  SUBLW  78
6384:  BZ    639A
6386:  CLRF   03
6388:  MOVF   x93,W
638A:  ADDWF  x8E,W
638C:  MOVWF  FE9
638E:  MOVF   x8F,W
6390:  ADDWFC 03,W
6392:  MOVWF  FEA
6394:  MOVF   FEF,W
6396:  SUBLW  58
6398:  BNZ   63B4
....................       { 
....................          base = 16; 
639A:  MOVLW  10
639C:  MOVWF  x92
....................          index++; 
639E:  INCF   x93,F
....................          c = s[index++]; 
63A0:  MOVF   x93,W
63A2:  INCF   x93,F
63A4:  CLRF   03
63A6:  ADDWF  x8E,W
63A8:  MOVWF  FE9
63AA:  MOVF   x8F,W
63AC:  ADDWFC 03,W
63AE:  MOVWF  FEA
63B0:  MOVFF  FEF,A94
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
63B4:  MOVF   x92,W
63B6:  SUBLW  0A
63B8:  BNZ   63F4
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
63BA:  MOVF   x94,W
63BC:  SUBLW  2F
63BE:  BC    63F2
63C0:  MOVF   x94,W
63C2:  SUBLW  39
63C4:  BNC   63F2
....................             result = 10*result + (c - '0'); 
63C6:  MOVLW  0A
63C8:  MOVWF  x95
63CA:  MOVFF  A90,A96
63CE:  MOVLB  0
63D0:  BRA    62A6
63D2:  MOVLW  30
63D4:  MOVLB  A
63D6:  SUBWF  x94,W
63D8:  ADDWF  01,W
63DA:  MOVWF  x90
....................             c = s[index++]; 
63DC:  MOVF   x93,W
63DE:  INCF   x93,F
63E0:  CLRF   03
63E2:  ADDWF  x8E,W
63E4:  MOVWF  FE9
63E6:  MOVF   x8F,W
63E8:  ADDWFC 03,W
63EA:  MOVWF  FEA
63EC:  MOVFF  FEF,A94
....................          } 
63F0:  BRA    63BA
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
63F2:  BRA    6484
63F4:  MOVF   x92,W
63F6:  SUBLW  10
63F8:  BNZ   6484
....................       { 
....................          c = toupper(c); 
63FA:  MOVF   x94,W
63FC:  SUBLW  60
63FE:  BC    640C
6400:  MOVF   x94,W
6402:  SUBLW  7A
6404:  BNC   640C
6406:  MOVF   x94,W
6408:  ANDLW  DF
640A:  BRA    640E
640C:  MOVF   x94,W
640E:  MOVWF  x94
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
6410:  MOVF   x94,W
6412:  SUBLW  2F
6414:  BC    641C
6416:  MOVF   x94,W
6418:  SUBLW  39
641A:  BC    6428
641C:  MOVF   x94,W
641E:  SUBLW  40
6420:  BC    6484
6422:  MOVF   x94,W
6424:  SUBLW  46
6426:  BNC   6484
....................             if (c >= '0' && c <= '9') 
6428:  MOVF   x94,W
642A:  SUBLW  2F
642C:  BC    6446
642E:  MOVF   x94,W
6430:  SUBLW  39
6432:  BNC   6446
....................                result = (result << 4) + (c - '0'); 
6434:  SWAPF  x90,W
6436:  MOVWF  x95
6438:  MOVLW  F0
643A:  ANDWF  x95,F
643C:  MOVLW  30
643E:  SUBWF  x94,W
6440:  ADDWF  x95,W
6442:  MOVWF  x90
....................             else 
6444:  BRA    6458
....................                result = (result << 4) + (c - 'A' + 10); 
6446:  SWAPF  x90,W
6448:  MOVWF  x95
644A:  MOVLW  F0
644C:  ANDWF  x95,F
644E:  MOVLW  41
6450:  SUBWF  x94,W
6452:  ADDLW  0A
6454:  ADDWF  x95,W
6456:  MOVWF  x90
....................  
....................             c = s[index++]; 
6458:  MOVF   x93,W
645A:  INCF   x93,F
645C:  CLRF   03
645E:  ADDWF  x8E,W
6460:  MOVWF  FE9
6462:  MOVF   x8F,W
6464:  ADDWFC 03,W
6466:  MOVWF  FEA
6468:  MOVFF  FEF,A94
....................             c = toupper(c); 
646C:  MOVF   x94,W
646E:  SUBLW  60
6470:  BC    647E
6472:  MOVF   x94,W
6474:  SUBLW  7A
6476:  BNC   647E
6478:  MOVF   x94,W
647A:  ANDLW  DF
647C:  BRA    6480
647E:  MOVF   x94,W
6480:  MOVWF  x94
....................          } 
6482:  BRA    6410
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
6484:  DECFSZ x91,W
6486:  BRA    6490
6488:  MOVF   x92,W
648A:  SUBLW  0A
648C:  BNZ   6490
....................        result = -result; 
648E:  NEGF   x90
....................  
....................    return(result); 
6490:  MOVFF  A90,01
.................... } 
6494:  MOVLB  0
6496:  GOTO   8C86 (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
*
60DA:  MOVLB  A
60DC:  CLRF   x98
60DE:  CLRF   x97
60E0:  CLRF   x96
60E2:  MOVLW  01
60E4:  MOVWF  x95
60E6:  CLRF   x9A
60E8:  CLRF   x9B
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
60EA:  BTFSS  x91.7
60EC:  BRA    6120
....................          sign=1;        // Check for negative number 
60EE:  MOVLW  01
60F0:  MOVWF  x9A
....................          num*=-1; 
60F2:  MOVFF  A91,AA0
60F6:  MOVFF  A90,A9F
60FA:  MOVFF  A8F,A9E
60FE:  MOVFF  A8E,A9D
6102:  SETF   xA4
6104:  SETF   xA3
6106:  SETF   xA2
6108:  SETF   xA1
610A:  MOVLB  0
610C:  BRA    5F92
610E:  MOVFF  03,A91
6112:  MOVFF  02,A90
6116:  MOVFF  01,A8F
611A:  MOVFF  00,A8E
611E:  MOVLB  A
....................      } 
....................  
....................      while(temp>0) { 
6120:  MOVF   x95,F
6122:  BNZ   6130
6124:  MOVF   x96,F
6126:  BNZ   6130
6128:  MOVF   x97,F
612A:  BNZ   6130
612C:  MOVF   x98,F
612E:  BZ    620A
....................          temp=(num/base); 
6130:  BCF    FD8.1
6132:  MOVFF  A91,AA8
6136:  MOVFF  A90,AA7
613A:  MOVFF  A8F,AA6
613E:  MOVFF  A8E,AA5
6142:  CLRF   xAC
6144:  CLRF   xAB
6146:  CLRF   xAA
6148:  MOVFF  A92,AA9
614C:  MOVLB  0
614E:  RCALL  5FF0
6150:  MOVFF  03,A98
6154:  MOVFF  02,A97
6158:  MOVFF  01,A96
615C:  MOVFF  00,A95
....................          s[cnt]=(num%base)+'0';    // Conversion 
6160:  CLRF   03
6162:  MOVLB  A
6164:  MOVF   x9B,W
6166:  ADDWF  x93,W
6168:  MOVWF  01
616A:  MOVF   x94,W
616C:  ADDWFC 03,F
616E:  MOVFF  01,A9D
6172:  MOVFF  03,A9E
6176:  MOVFF  FEA,AA0
617A:  MOVFF  FE9,A9F
617E:  BSF    FD8.1
6180:  MOVLW  0A
6182:  MOVWF  FEA
6184:  MOVLW  A1
6186:  MOVWF  FE9
6188:  MOVFF  A91,AA8
618C:  MOVFF  A90,AA7
6190:  MOVFF  A8F,AA6
6194:  MOVFF  A8E,AA5
6198:  CLRF   xAC
619A:  CLRF   xAB
619C:  CLRF   xAA
619E:  MOVFF  A92,AA9
61A2:  MOVLB  0
61A4:  RCALL  5FF0
61A6:  MOVFF  AA0,FEA
61AA:  MOVFF  A9F,FE9
61AE:  MOVLW  30
61B0:  MOVLB  A
61B2:  ADDWF  xA1,W
61B4:  MOVWF  00
61B6:  MOVLW  00
61B8:  ADDWFC xA2,W
61BA:  MOVLW  00
61BC:  ADDWFC xA3,W
61BE:  MOVLW  00
61C0:  ADDWFC xA4,W
61C2:  MOVFF  A9E,FEA
61C6:  MOVFF  A9D,FE9
61CA:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
61CE:  CLRF   03
61D0:  MOVF   x9B,W
61D2:  ADDWF  x93,W
61D4:  MOVWF  FE9
61D6:  MOVF   x94,W
61D8:  ADDWFC 03,W
61DA:  MOVWF  FEA
61DC:  MOVF   FEF,W
61DE:  SUBLW  39
61E0:  BC    61F6
....................             s[cnt]+=0x7; 
61E2:  CLRF   03
61E4:  MOVF   x9B,W
61E6:  ADDWF  x93,W
61E8:  MOVWF  FE9
61EA:  MOVF   x94,W
61EC:  ADDWFC 03,W
61EE:  MOVWF  FEA
61F0:  MOVLW  07
61F2:  ADDWF  FEF,W
61F4:  MOVWF  FEF
....................  
....................          cnt++; 
61F6:  INCF   x9B,F
....................          num=temp; 
61F8:  MOVFF  A98,A91
61FC:  MOVFF  A97,A90
6200:  MOVFF  A96,A8F
6204:  MOVFF  A95,A8E
....................      } 
6208:  BRA    6120
....................  
....................      if(sign==1) { 
620A:  DECFSZ x9A,W
620C:  BRA    6222
....................          s[cnt]=0x2D;      // Negative sign 
620E:  CLRF   03
6210:  MOVF   x9B,W
6212:  ADDWF  x93,W
6214:  MOVWF  FE9
6216:  MOVF   x94,W
6218:  ADDWFC 03,W
621A:  MOVWF  FEA
621C:  MOVLW  2D
621E:  MOVWF  FEF
....................          cnt++; 
6220:  INCF   x9B,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
6222:  CLRF   x99
6224:  BCF    FD8.0
6226:  RRCF   x9B,W
6228:  SUBWF  x99,W
622A:  BC    628A
....................  
....................          c=s[i]; 
622C:  CLRF   03
622E:  MOVF   x99,W
6230:  ADDWF  x93,W
6232:  MOVWF  FE9
6234:  MOVF   x94,W
6236:  ADDWFC 03,W
6238:  MOVWF  FEA
623A:  MOVFF  FEF,A9C
....................          s[i]=s[cnt-i-1];        // Reverse the number 
623E:  CLRF   03
6240:  MOVF   x99,W
6242:  ADDWF  x93,W
6244:  MOVWF  01
6246:  MOVF   x94,W
6248:  ADDWFC 03,F
624A:  MOVFF  03,A9E
624E:  MOVF   x99,W
6250:  SUBWF  x9B,W
6252:  ADDLW  FF
6254:  CLRF   03
6256:  ADDWF  x93,W
6258:  MOVWF  FE9
625A:  MOVF   x94,W
625C:  ADDWFC 03,W
625E:  MOVWF  FEA
6260:  MOVFF  FEF,A9F
6264:  MOVFF  A9E,FEA
6268:  MOVFF  01,FE9
626C:  MOVFF  A9F,FEF
....................          s[cnt-i-1]=c; 
6270:  MOVF   x99,W
6272:  SUBWF  x9B,W
6274:  ADDLW  FF
6276:  CLRF   03
6278:  ADDWF  x93,W
627A:  MOVWF  FE9
627C:  MOVF   x94,W
627E:  ADDWFC 03,W
6280:  MOVWF  FEA
6282:  MOVFF  A9C,FEF
....................      } 
6286:  INCF   x99,F
6288:  BRA    6224
....................      s[cnt]='\0';     // End the string 
628A:  CLRF   03
628C:  MOVF   x9B,W
628E:  ADDWF  x93,W
6290:  MOVWF  FE9
6292:  MOVF   x94,W
6294:  ADDWFC 03,W
6296:  MOVWF  FEA
6298:  CLRF   FEF
....................      return s; 
629A:  MOVFF  A93,01
629E:  MOVFF  A94,02
.................... } 
62A2:  MOVLB  0
62A4:  RETURN 0
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
379E:  MOVLW  08
37A0:  MOVWF  01
37A2:  MOVLW  0A
37A4:  MOVWF  00
37A6:  DECFSZ 00,F
37A8:  BRA    37A6
37AA:  BCF    F8B.3
37AC:  BCF    F94.3
37AE:  MOVLW  0B
37B0:  MOVWF  00
37B2:  DECFSZ 00,F
37B4:  BRA    37B2
37B6:  MOVLB  A
37B8:  RLCF   xCE,F
37BA:  BCF    F8B.4
37BC:  BTFSC  FD8.0
37BE:  BSF    F94.4
37C0:  BTFSS  FD8.0
37C2:  BCF    F94.4
37C4:  BSF    F94.3
37C6:  BTFSS  F82.3
37C8:  BRA    37C6
37CA:  DECFSZ 01,F
37CC:  BRA    37D0
37CE:  BRA    37D4
37D0:  MOVLB  0
37D2:  BRA    37A2
37D4:  MOVLW  0A
37D6:  MOVWF  00
37D8:  DECFSZ 00,F
37DA:  BRA    37D8
37DC:  BCF    F8B.3
37DE:  BCF    F94.3
37E0:  NOP   
37E2:  BSF    F94.4
37E4:  MOVLW  0B
37E6:  MOVWF  00
37E8:  DECFSZ 00,F
37EA:  BRA    37E8
37EC:  MOVLW  0B
37EE:  MOVWF  00
37F0:  DECFSZ 00,F
37F2:  BRA    37F0
37F4:  BSF    F94.3
37F6:  BTFSS  F82.3
37F8:  BRA    37F6
37FA:  CLRF   01
37FC:  MOVLW  0B
37FE:  MOVWF  00
3800:  DECFSZ 00,F
3802:  BRA    3800
3804:  BTFSC  F82.4
3806:  BSF    01.0
3808:  BCF    F8B.3
380A:  BCF    F94.3
380C:  BCF    F8B.4
380E:  BCF    F94.4
3810:  MOVLB  0
3812:  RETURN 0
3814:  MOVLW  08
3816:  MOVLB  A
3818:  MOVWF  xC3
381A:  MOVFF  00,AC4
381E:  BSF    F94.4
3820:  MOVLW  0B
3822:  MOVWF  00
3824:  DECFSZ 00,F
3826:  BRA    3824
3828:  BSF    F94.3
382A:  BTFSS  F82.3
382C:  BRA    382A
382E:  BTFSC  F82.4
3830:  BSF    FD8.0
3832:  BTFSS  F82.4
3834:  BCF    FD8.0
3836:  RLCF   01,F
3838:  MOVLW  0A
383A:  MOVWF  00
383C:  DECFSZ 00,F
383E:  BRA    383C
3840:  BCF    F94.3
3842:  BCF    F8B.3
3844:  DECFSZ xC3,F
3846:  BRA    381E
3848:  BSF    F94.4
384A:  MOVLW  0B
384C:  MOVWF  00
384E:  DECFSZ 00,F
3850:  BRA    384E
3852:  BCF    F8B.4
3854:  MOVF   xC4,W
3856:  BTFSS  FD8.2
3858:  BCF    F94.4
385A:  NOP   
385C:  BSF    F94.3
385E:  BTFSS  F82.3
3860:  BRA    385E
3862:  MOVLW  0A
3864:  MOVWF  00
3866:  DECFSZ 00,F
3868:  BRA    3866
386A:  BCF    F8B.3
386C:  BCF    F94.3
386E:  MOVLW  0B
3870:  MOVWF  00
3872:  DECFSZ 00,F
3874:  BRA    3872
3876:  BCF    F8B.4
3878:  BCF    F94.4
387A:  MOVLB  0
387C:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... //#define EEPROM_SIZE   65535 
.................... #define EEPROM_SIZE_key    65535 
.................... #define EEPROM_SIZE        43590 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
5058:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
505A:  BSF    F94.4
....................    port_b_pullups(0xff); 
505C:  BCF    FF1.7
.................... } 
505E:  GOTO   6D92 (RETURN)
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
3E6C:  BSF    F94.4
3E6E:  MOVLW  0A
3E70:  MOVWF  00
3E72:  DECFSZ 00,F
3E74:  BRA    3E72
3E76:  BSF    F94.3
3E78:  MOVLW  0B
3E7A:  MOVWF  00
3E7C:  DECFSZ 00,F
3E7E:  BRA    3E7C
3E80:  BCF    F8B.4
3E82:  BCF    F94.4
3E84:  MOVLW  0A
3E86:  MOVWF  00
3E88:  DECFSZ 00,F
3E8A:  BRA    3E88
3E8C:  BCF    F8B.3
3E8E:  BCF    F94.3
....................    i2c_write(0xa0); 
3E90:  MOVLW  A0
3E92:  MOVLB  A
3E94:  MOVWF  xCE
3E96:  MOVLB  0
3E98:  RCALL  379E
....................    i2c_write(address>>8); 
3E9A:  MOVFF  AC8,ACC
3E9E:  MOVLB  A
3EA0:  CLRF   xCD
3EA2:  MOVFF  AC8,ACE
3EA6:  MOVLB  0
3EA8:  RCALL  379E
....................    i2c_write(address); 
3EAA:  MOVFF  AC7,ACE
3EAE:  RCALL  379E
....................    i2c_write(data); 
3EB0:  MOVFF  AC9,ACE
3EB4:  RCALL  379E
....................    i2c_stop(); 
3EB6:  BCF    F94.4
3EB8:  NOP   
3EBA:  BSF    F94.3
3EBC:  BTFSS  F82.3
3EBE:  BRA    3EBC
3EC0:  MOVLW  0A
3EC2:  MOVWF  00
3EC4:  DECFSZ 00,F
3EC6:  BRA    3EC4
3EC8:  BRA    3ECA
3ECA:  NOP   
3ECC:  BSF    F94.4
3ECE:  MOVLW  0A
3ED0:  MOVWF  00
3ED2:  DECFSZ 00,F
3ED4:  BRA    3ED2
....................    i2c_start(); 
3ED6:  BSF    F94.4
3ED8:  MOVLW  0A
3EDA:  MOVWF  00
3EDC:  DECFSZ 00,F
3EDE:  BRA    3EDC
3EE0:  BSF    F94.3
3EE2:  MOVLW  0B
3EE4:  MOVWF  00
3EE6:  DECFSZ 00,F
3EE8:  BRA    3EE6
3EEA:  BCF    F8B.4
3EEC:  BCF    F94.4
3EEE:  MOVLW  0A
3EF0:  MOVWF  00
3EF2:  DECFSZ 00,F
3EF4:  BRA    3EF2
3EF6:  BCF    F8B.3
3EF8:  BCF    F94.3
....................    status=i2c_write(0xa0); 
3EFA:  MOVLW  A0
3EFC:  MOVLB  A
3EFE:  MOVWF  xCE
3F00:  MOVLB  0
3F02:  RCALL  379E
3F04:  MOVF   01,W
3F06:  MOVLB  A
3F08:  BCF    xCA.0
3F0A:  BTFSC  01.0
3F0C:  BSF    xCA.0
....................    while(status==1) 
....................    { 
3F0E:  BTFSS  xCA.0
3F10:  BRA    3F4E
....................       i2c_start(); 
3F12:  BSF    F94.4
3F14:  MOVLW  0A
3F16:  MOVWF  00
3F18:  DECFSZ 00,F
3F1A:  BRA    3F18
3F1C:  BSF    F94.3
3F1E:  MOVLW  0B
3F20:  MOVWF  00
3F22:  DECFSZ 00,F
3F24:  BRA    3F22
3F26:  BTFSS  F82.3
3F28:  BRA    3F26
3F2A:  BCF    F8B.4
3F2C:  BCF    F94.4
3F2E:  MOVLW  0A
3F30:  MOVWF  00
3F32:  DECFSZ 00,F
3F34:  BRA    3F32
3F36:  BCF    F8B.3
3F38:  BCF    F94.3
....................       status=i2c_write(0xa0); 
3F3A:  MOVLW  A0
3F3C:  MOVWF  xCE
3F3E:  MOVLB  0
3F40:  RCALL  379E
3F42:  MOVF   01,W
3F44:  MOVLB  A
3F46:  BCF    xCA.0
3F48:  BTFSC  01.0
3F4A:  BSF    xCA.0
....................    } 
3F4C:  BRA    3F0E
....................    i2c_stop(); 
3F4E:  BCF    F94.4
3F50:  NOP   
3F52:  BSF    F94.3
3F54:  BTFSS  F82.3
3F56:  BRA    3F54
3F58:  MOVLW  0A
3F5A:  MOVWF  00
3F5C:  DECFSZ 00,F
3F5E:  BRA    3F5C
3F60:  BRA    3F62
3F62:  NOP   
3F64:  BSF    F94.4
3F66:  MOVLW  0A
3F68:  MOVWF  00
3F6A:  DECFSZ 00,F
3F6C:  BRA    3F6A
.................... } 
3F6E:  MOVLB  0
3F70:  RETURN 0
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
3948:  BSF    F94.4
394A:  MOVLW  0A
394C:  MOVWF  00
394E:  DECFSZ 00,F
3950:  BRA    394E
3952:  BSF    F94.3
3954:  MOVLW  0B
3956:  MOVWF  00
3958:  DECFSZ 00,F
395A:  BRA    3958
395C:  BCF    F8B.4
395E:  BCF    F94.4
3960:  MOVLW  0A
3962:  MOVWF  00
3964:  DECFSZ 00,F
3966:  BRA    3964
3968:  BCF    F8B.3
396A:  BCF    F94.3
....................    i2c_write(0xa0); 
396C:  MOVLW  A0
396E:  MOVLB  A
3970:  MOVWF  xCE
3972:  MOVLB  0
3974:  RCALL  379E
....................    i2c_write(address>>8); 
3976:  MOVFF  AC0,AC2
397A:  MOVLB  A
397C:  CLRF   xC3
397E:  MOVFF  AC0,ACE
3982:  MOVLB  0
3984:  RCALL  379E
....................    i2c_write(address); 
3986:  MOVFF  ABF,ACE
398A:  RCALL  379E
....................    i2c_start(); 
398C:  BSF    F94.4
398E:  MOVLW  0A
3990:  MOVWF  00
3992:  DECFSZ 00,F
3994:  BRA    3992
3996:  BSF    F94.3
3998:  MOVLW  0B
399A:  MOVWF  00
399C:  DECFSZ 00,F
399E:  BRA    399C
39A0:  BTFSS  F82.3
39A2:  BRA    39A0
39A4:  BCF    F8B.4
39A6:  BCF    F94.4
39A8:  MOVLW  0A
39AA:  MOVWF  00
39AC:  DECFSZ 00,F
39AE:  BRA    39AC
39B0:  BCF    F8B.3
39B2:  BCF    F94.3
....................    i2c_write(0xa1); 
39B4:  MOVLW  A1
39B6:  MOVLB  A
39B8:  MOVWF  xCE
39BA:  MOVLB  0
39BC:  RCALL  379E
....................    data=i2c_read(0); 
39BE:  CLRF   00
39C0:  RCALL  3814
39C2:  MOVFF  01,AC1
....................    i2c_stop(); 
39C6:  BCF    F94.4
39C8:  NOP   
39CA:  BSF    F94.3
39CC:  BTFSS  F82.3
39CE:  BRA    39CC
39D0:  MOVLW  0A
39D2:  MOVWF  00
39D4:  DECFSZ 00,F
39D6:  BRA    39D4
39D8:  BRA    39DA
39DA:  NOP   
39DC:  BSF    F94.4
39DE:  MOVLW  0A
39E0:  MOVWF  00
39E2:  DECFSZ 00,F
39E4:  BRA    39E2
....................    return(data); 
39E6:  MOVLB  A
39E8:  MOVFF  AC1,01
.................... } 
39EC:  MOVLB  0
39EE:  RETURN 0
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
649A:  MOVLB  A
649C:  MOVF   x92,W
649E:  ADDWF  x90,W
64A0:  MOVWF  x98
64A2:  MOVF   x93,W
64A4:  ADDWFC x91,W
64A6:  MOVWF  x99
64A8:  SUBLW  A9
64AA:  BC    64BC
64AC:  XORLW  FF
64AE:  BNZ   64B6
64B0:  MOVF   x98,W
64B2:  SUBLW  45
64B4:  BC    64BC
64B6:  MOVLW  00
64B8:  MOVWF  01
64BA:  BRA    651A
....................    for(i=0;i<len;i++) 
64BC:  CLRF   x97
64BE:  CLRF   x96
64C0:  MOVF   x97,W
64C2:  SUBWF  x93,W
64C4:  BNC   651A
64C6:  BNZ   64CE
64C8:  MOVF   x92,W
64CA:  SUBWF  x96,W
64CC:  BC    651A
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
64CE:  MOVF   x94,W
64D0:  ADDWF  x96,W
64D2:  MOVWF  01
64D4:  MOVF   x95,W
64D6:  ADDWFC x97,W
64D8:  MOVWF  03
64DA:  MOVFF  01,A98
64DE:  MOVWF  x99
64E0:  MOVF   x96,W
64E2:  ADDWF  x90,W
64E4:  MOVWF  x9A
64E6:  MOVF   x97,W
64E8:  ADDWFC x91,W
64EA:  MOVWF  x9B
64EC:  CLRF   19
64EE:  BTFSC  FF2.7
64F0:  BSF    19.7
64F2:  BCF    FF2.7
64F4:  MOVWF  xC0
64F6:  MOVFF  A9A,ABF
64FA:  MOVLB  0
64FC:  CALL   3948
6500:  BTFSC  19.7
6502:  BSF    FF2.7
6504:  MOVFF  A99,FEA
6508:  MOVFF  A98,FE9
650C:  MOVFF  01,FEF
....................    } 
6510:  MOVLB  A
6512:  INCF   x96,F
6514:  BTFSC  FD8.2
6516:  INCF   x97,F
6518:  BRA    64C0
....................     
.................... } 
651A:  MOVLB  0
651C:  GOTO   8F26 (RETURN)
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_mobile_num0        65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_two_number        149 
.................... #define kindofKB                 126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards                350   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
3A62:  MOVLB  A
3A64:  CLRF   xC8
3A66:  MOVF   xC5,W
3A68:  SUBWF  xC8,W
3A6A:  BC    3A80
....................    { 
....................       inputdat[i]=0; 
3A6C:  CLRF   03
3A6E:  MOVF   xC8,W
3A70:  ADDWF  xC6,W
3A72:  MOVWF  FE9
3A74:  MOVF   xC7,W
3A76:  ADDWFC 03,W
3A78:  MOVWF  FEA
3A7A:  CLRF   FEF
....................    } 
3A7C:  INCF   xC8,F
3A7E:  BRA    3A66
.................... } 
3A80:  MOVLB  0
3A82:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_write(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
50BC:  MOVLB  A
50BE:  CLRF   xA7
50C0:  MOVF   xA4,W
50C2:  SUBWF  xA7,W
50C4:  BC    510A
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
50C6:  MOVF   xA7,W
50C8:  ADDWF  xA3,W
50CA:  MOVWF  xA8
50CC:  CLRF   03
50CE:  MOVF   xA7,W
50D0:  ADDWF  xA5,W
50D2:  MOVWF  FE9
50D4:  MOVF   xA6,W
50D6:  ADDWFC 03,W
50D8:  MOVWF  FEA
50DA:  MOVFF  FEF,AA9
50DE:  CLRF   19
50E0:  BTFSC  FF2.7
50E2:  BSF    19.7
50E4:  BCF    FF2.7
50E6:  CLRF   xC8
50E8:  MOVFF  AA8,AC7
50EC:  MOVFF  AA9,AC9
50F0:  MOVLB  0
50F2:  CALL   3E6C
50F6:  BTFSC  19.7
50F8:  BSF    FF2.7
....................       delay_us(10); 
50FA:  MOVLW  1A
50FC:  MOVWF  00
50FE:  DECFSZ 00,F
5100:  BRA    50FE
5102:  NOP   
....................    } 
5104:  MOVLB  A
5106:  INCF   xA7,F
5108:  BRA    50C0
.................... } 
510A:  MOVLB  0
510C:  RETURN 0
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
5062:  MOVLB  A
5064:  CLRF   x92
5066:  MOVF   x8F,W
5068:  SUBWF  x92,W
506A:  BC    50B8
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
506C:  CLRF   03
506E:  MOVF   x92,W
5070:  ADDWF  x90,W
5072:  MOVWF  01
5074:  MOVF   x91,W
5076:  ADDWFC 03,F
5078:  MOVFF  01,A93
507C:  MOVFF  03,A94
5080:  MOVF   x92,W
5082:  ADDWF  x8E,W
5084:  MOVWF  x95
5086:  CLRF   19
5088:  BTFSC  FF2.7
508A:  BSF    19.7
508C:  BCF    FF2.7
508E:  CLRF   xC0
5090:  MOVWF  xBF
5092:  MOVLB  0
5094:  CALL   3948
5098:  BTFSC  19.7
509A:  BSF    FF2.7
509C:  MOVFF  A94,FEA
50A0:  MOVFF  A93,FE9
50A4:  MOVFF  01,FEF
....................       delay_us(10); 
50A8:  MOVLW  1A
50AA:  MOVWF  00
50AC:  DECFSZ 00,F
50AE:  BRA    50AC
50B0:  NOP   
....................    } 
50B2:  MOVLB  A
50B4:  INCF   x92,F
50B6:  BRA    5066
.................... } 
50B8:  MOVLB  0
50BA:  RETURN 0
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
.................... { 
*
5292:  MOVLB  A
5294:  CLRF   x92
5296:  CLRF   x91
5298:  CLRF   x90
529A:  CLRF   x8F
529C:  CLRF   x96
529E:  CLRF   x95
52A0:  CLRF   x94
52A2:  CLRF   x93
52A4:  CLRF   x9A
52A6:  CLRF   x99
52A8:  CLRF   x98
52AA:  CLRF   x97
52AC:  CLRF   x9E
52AE:  CLRF   x9D
52B0:  CLRF   x9C
52B2:  CLRF   x9B
52B4:  CLRF   xA2
52B6:  CLRF   xA1
52B8:  CLRF   xA0
52BA:  CLRF   x9F
52BC:  CLRF   19
52BE:  BTFSC  FF2.7
52C0:  BSF    19.7
52C2:  BCF    FF2.7
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
52C4:  CLRF   xC0
52C6:  MOVFF  A8E,ABF
52CA:  MOVLB  0
52CC:  CALL   3948
52D0:  BTFSC  19.7
52D2:  BSF    FF2.7
52D4:  MOVLB  A
52D6:  MOVFF  01,A93
52DA:  CLRF   x94
52DC:  CLRF   x95
52DE:  CLRF   x96
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
52E0:  MOVLW  01
52E2:  ADDWF  x8E,W
52E4:  MOVWF  xA3
52E6:  CLRF   19
52E8:  BTFSC  FF2.7
52EA:  BSF    19.7
52EC:  BCF    FF2.7
52EE:  CLRF   xC0
52F0:  MOVWF  xBF
52F2:  MOVLB  0
52F4:  CALL   3948
52F8:  BTFSC  19.7
52FA:  BSF    FF2.7
52FC:  MOVLB  A
52FE:  CLRF   x9A
5300:  CLRF   x99
5302:  CLRF   x98
5304:  MOVFF  01,A97
....................    temp2<<=8; 
5308:  MOVFF  A99,A9A
530C:  MOVFF  A98,A99
5310:  MOVFF  A97,A98
5314:  CLRF   x97
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
5316:  MOVLW  02
5318:  ADDWF  x8E,W
531A:  MOVWF  xA3
531C:  CLRF   19
531E:  BTFSC  FF2.7
5320:  BSF    19.7
5322:  BCF    FF2.7
5324:  CLRF   xC0
5326:  MOVWF  xBF
5328:  MOVLB  0
532A:  CALL   3948
532E:  BTFSC  19.7
5330:  BSF    FF2.7
5332:  MOVLB  A
5334:  CLRF   x9E
5336:  CLRF   x9D
5338:  CLRF   x9C
533A:  MOVFF  01,A9B
....................    temp3<<=16; 
533E:  MOVFF  A9C,A9E
5342:  MOVFF  A9B,A9D
5346:  CLRF   x9B
5348:  CLRF   x9C
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
534A:  MOVLW  03
534C:  ADDWF  x8E,W
534E:  MOVWF  xA3
5350:  CLRF   19
5352:  BTFSC  FF2.7
5354:  BSF    19.7
5356:  BCF    FF2.7
5358:  CLRF   xC0
535A:  MOVWF  xBF
535C:  MOVLB  0
535E:  CALL   3948
5362:  BTFSC  19.7
5364:  BSF    FF2.7
5366:  MOVLB  A
5368:  CLRF   xA2
536A:  CLRF   xA1
536C:  CLRF   xA0
536E:  MOVFF  01,A9F
....................    temp4<<=24; 
5372:  MOVFF  A9F,AA2
5376:  CLRF   x9F
5378:  CLRF   xA0
537A:  CLRF   xA1
....................    buffer = temp4|temp3|temp2|temp1; 
537C:  MOVF   x9F,W
537E:  IORWF  x9B,W
5380:  MOVWF  xA3
5382:  MOVF   xA0,W
5384:  IORWF  x9C,W
5386:  MOVWF  xA4
5388:  MOVF   xA1,W
538A:  IORWF  x9D,W
538C:  MOVWF  xA5
538E:  MOVF   xA2,W
5390:  IORWF  x9E,W
5392:  MOVWF  xA6
5394:  MOVF   x97,W
5396:  IORWF  xA3,F
5398:  MOVF   x98,W
539A:  IORWF  xA4,F
539C:  MOVF   x99,W
539E:  IORWF  xA5,F
53A0:  MOVF   x9A,W
53A2:  IORWF  xA6,F
53A4:  MOVF   xA3,W
53A6:  IORWF  x93,W
53A8:  MOVWF  x8F
53AA:  MOVF   xA4,W
53AC:  IORWF  x94,W
53AE:  MOVWF  x90
53B0:  MOVF   xA5,W
53B2:  IORWF  x95,W
53B4:  MOVWF  x91
53B6:  MOVF   xA6,W
53B8:  IORWF  x96,W
53BA:  MOVWF  x92
....................    return(buffer); 
53BC:  MOVFF  A8F,00
53C0:  MOVFF  A90,01
53C4:  MOVFF  A91,02
53C8:  MOVFF  A92,03
.................... } 
53CC:  MOVLB  0
53CE:  RETURN 0
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
.................... { 
*
3F72:  MOVLB  A
3F74:  CLRF   xC1
3F76:  CLRF   xC0
3F78:  CLRF   xBF
3F7A:  CLRF   xBE
3F7C:  CLRF   xC2
3F7E:  CLRF   xC3
3F80:  CLRF   xC4
3F82:  CLRF   xC5
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3F84:  MOVFF  ABC,AC1
3F88:  MOVFF  ABB,AC0
3F8C:  MOVFF  ABA,ABF
3F90:  MOVFF  AB9,ABE
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3F94:  MOVFF  ABE,AC2
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3F98:  MOVFF  ABF,AC3
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3F9C:  MOVFF  AC0,AC4
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3FA0:  MOVFF  AC1,AC5
....................    write_ext_eeprom((addr+0),temp1); 
3FA4:  CLRF   xC8
3FA6:  MOVFF  ABD,AC7
3FAA:  MOVFF  AC2,AC9
3FAE:  MOVLB  0
3FB0:  RCALL  3E6C
....................    write_ext_eeprom((addr+1),temp2); 
3FB2:  MOVLW  01
3FB4:  MOVLB  A
3FB6:  ADDWF  xBD,W
3FB8:  MOVWF  xC6
3FBA:  CLRF   xC8
3FBC:  MOVWF  xC7
3FBE:  MOVFF  AC3,AC9
3FC2:  MOVLB  0
3FC4:  RCALL  3E6C
....................    write_ext_eeprom((addr+2),temp3); 
3FC6:  MOVLW  02
3FC8:  MOVLB  A
3FCA:  ADDWF  xBD,W
3FCC:  MOVWF  xC6
3FCE:  CLRF   xC8
3FD0:  MOVWF  xC7
3FD2:  MOVFF  AC4,AC9
3FD6:  MOVLB  0
3FD8:  RCALL  3E6C
....................    write_ext_eeprom((addr+3),temp4); 
3FDA:  MOVLW  03
3FDC:  MOVLB  A
3FDE:  ADDWF  xBD,W
3FE0:  MOVWF  xC6
3FE2:  CLRF   xC8
3FE4:  MOVWF  xC7
3FE6:  MOVFF  AC5,AC9
3FEA:  MOVLB  0
3FEC:  RCALL  3E6C
.................... } 
3FEE:  RETURN 0
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
.................... { 
*
45DC:  MOVLB  A
45DE:  CLRF   xB9
45E0:  CLRF   xB8
45E2:  CLRF   xBA
45E4:  CLRF   xBB
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
45E6:  MOVFF  AB7,AB9
45EA:  MOVFF  AB6,AB8
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
45EE:  MOVFF  AB8,ABA
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
45F2:  MOVF   xB9,W
45F4:  MOVWF  xBB
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
45F6:  CLRF   xC8
45F8:  MOVLW  28
45FA:  MOVWF  xC7
45FC:  MOVFF  ABA,AC9
4600:  MOVLB  0
4602:  RCALL  3E6C
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
4604:  MOVLB  A
4606:  CLRF   xC8
4608:  MOVLW  29
460A:  MOVWF  xC7
460C:  MOVFF  ABB,AC9
4610:  MOVLB  0
4612:  RCALL  3E6C
.................... } 
4614:  RETURN 0
.................... //============================================= 
.................... unsigned int16 get_countcard() 
.................... { 
*
39F0:  MOVLB  A
39F2:  CLRF   xBA
39F4:  CLRF   xB9
39F6:  CLRF   xBC
39F8:  CLRF   xBB
39FA:  CLRF   xBE
39FC:  CLRF   xBD
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
39FE:  CLRF   xC0
3A00:  MOVLW  28
3A02:  MOVWF  xBF
3A04:  MOVLB  0
3A06:  RCALL  3948
3A08:  MOVLB  A
3A0A:  MOVFF  01,ABB
3A0E:  CLRF   xBC
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3A10:  CLRF   xC0
3A12:  MOVLW  29
3A14:  MOVWF  xBF
3A16:  MOVLB  0
3A18:  RCALL  3948
3A1A:  MOVLB  A
3A1C:  CLRF   xBE
3A1E:  MOVFF  01,ABD
....................    temp2<<=8; 
3A22:  MOVFF  ABD,ABE
3A26:  CLRF   xBD
....................    buffer = temp2|temp1; 
3A28:  MOVF   xBD,W
3A2A:  IORWF  xBB,W
3A2C:  MOVWF  xB9
3A2E:  MOVF   xBE,W
3A30:  IORWF  xBC,W
3A32:  MOVWF  xBA
....................    return(buffer); 
3A34:  MOVFF  AB9,01
3A38:  MOVFF  ABA,02
.................... } 
3A3C:  MOVLB  0
3A3E:  RETURN 0
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int16 i; 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
5DD0:  MOVLW  AA
5DD2:  MOVLB  A
5DD4:  MOVWF  x8F
5DD6:  MOVLW  47
5DD8:  MOVWF  x8E
5DDA:  MOVF   27,F
5DDC:  BNZ   5DF0
5DDE:  MOVF   26,F
5DE0:  BNZ   5DF0
5DE2:  MOVF   x8F,W
5DE4:  SUBWF  25,W
5DE6:  BNC   5E16
5DE8:  BNZ   5DF0
5DEA:  MOVF   24,W
5DEC:  SUBWF  x8E,W
5DEE:  BC    5E16
5DF0:  CLRF   19
5DF2:  BTFSC  FF2.7
5DF4:  BSF    19.7
5DF6:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5DF8:  MOVFF  A8F,AC8
5DFC:  MOVFF  A8E,AC7
5E00:  CLRF   xC9
5E02:  MOVLB  0
5E04:  CALL   3E6C
5E08:  BTFSC  19.7
5E0A:  BSF    FF2.7
....................    } 
5E0C:  MOVLB  A
5E0E:  INCF   x8E,F
5E10:  BTFSC  FD8.2
5E12:  INCF   x8F,F
5E14:  BRA    5DDA
....................    for(i=ptr_start;i<ptr_card;i++) 
5E16:  CLRF   x8F
5E18:  MOVLW  96
5E1A:  MOVWF  x8E
5E1C:  MOVF   23,F
5E1E:  BNZ   5E32
5E20:  MOVF   22,F
5E22:  BNZ   5E32
5E24:  MOVF   x8F,W
5E26:  SUBWF  21,W
5E28:  BNC   5E58
5E2A:  BNZ   5E32
5E2C:  MOVF   20,W
5E2E:  SUBWF  x8E,W
5E30:  BC    5E58
5E32:  CLRF   19
5E34:  BTFSC  FF2.7
5E36:  BSF    19.7
5E38:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5E3A:  MOVFF  A8F,AC8
5E3E:  MOVFF  A8E,AC7
5E42:  CLRF   xC9
5E44:  MOVLB  0
5E46:  CALL   3E6C
5E4A:  BTFSC  19.7
5E4C:  BSF    FF2.7
....................    } 
5E4E:  MOVLB  A
5E50:  INCF   x8E,F
5E52:  BTFSC  FD8.2
5E54:  INCF   x8F,F
5E56:  BRA    5E1C
....................    ptr_card=ptr_start; 
5E58:  CLRF   23
5E5A:  CLRF   22
5E5C:  CLRF   21
5E5E:  MOVLW  96
5E60:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5E62:  CLRF   27
5E64:  CLRF   26
5E66:  MOVLW  AA
5E68:  MOVWF  25
5E6A:  MOVLW  47
5E6C:  MOVWF  24
5E6E:  CLRF   19
5E70:  BTFSC  FF2.7
5E72:  BSF    19.7
5E74:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5E76:  MOVFF  23,ABC
5E7A:  MOVFF  22,ABB
5E7E:  MOVFF  21,ABA
5E82:  MOVFF  20,AB9
5E86:  MOVLW  19
5E88:  MOVWF  xBD
5E8A:  MOVLB  0
5E8C:  CALL   3F72
5E90:  BTFSC  19.7
5E92:  BSF    FF2.7
5E94:  CLRF   19
5E96:  BTFSC  FF2.7
5E98:  BSF    19.7
5E9A:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5E9C:  MOVFF  27,ABC
5EA0:  MOVFF  26,ABB
5EA4:  MOVFF  25,ABA
5EA8:  MOVFF  24,AB9
5EAC:  MOVLW  1E
5EAE:  MOVLB  A
5EB0:  MOVWF  xBD
5EB2:  MOVLB  0
5EB4:  CALL   3F72
5EB8:  BTFSC  19.7
5EBA:  BSF    FF2.7
5EBC:  CLRF   19
5EBE:  BTFSC  FF2.7
5EC0:  BSF    19.7
5EC2:  BCF    FF2.7
....................    save_coutcard(0); 
5EC4:  MOVLB  A
5EC6:  CLRF   xB7
5EC8:  CLRF   xB6
5ECA:  MOVLB  0
5ECC:  CALL   45DC
5ED0:  BTFSC  19.7
5ED2:  BSF    FF2.7
5ED4:  CLRF   19
5ED6:  BTFSC  FF2.7
5ED8:  BSF    19.7
5EDA:  BCF    FF2.7
....................    countcard=get_countcard(); 
5EDC:  CALL   39F0
5EE0:  BTFSC  19.7
5EE2:  BSF    FF2.7
5EE4:  MOVFF  02,FA
5EE8:  MOVFF  01,F9
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
.................... } 
5EEC:  GOTO   894A (RETURN)
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int16 i; 
....................    for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
*
5D18:  MOVLB  A
5D1A:  CLRF   x8F
5D1C:  MOVLW  96
5D1E:  MOVWF  x8E
5D20:  INCFSZ x8E,W
5D22:  BRA    5D2A
5D24:  INCFSZ x8F,W
5D26:  BRA    5D2A
5D28:  BRA    5D50
5D2A:  CLRF   19
5D2C:  BTFSC  FF2.7
5D2E:  BSF    19.7
5D30:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5D32:  MOVFF  A8F,AC8
5D36:  MOVFF  A8E,AC7
5D3A:  CLRF   xC9
5D3C:  MOVLB  0
5D3E:  CALL   3E6C
5D42:  BTFSC  19.7
5D44:  BSF    FF2.7
....................    } 
5D46:  MOVLB  A
5D48:  INCF   x8E,F
5D4A:  BTFSC  FD8.2
5D4C:  INCF   x8F,F
5D4E:  BRA    5D20
....................    ptr_card=ptr_start; 
5D50:  CLRF   23
5D52:  CLRF   22
5D54:  CLRF   21
5D56:  MOVLW  96
5D58:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5D5A:  CLRF   27
5D5C:  CLRF   26
5D5E:  MOVLW  AA
5D60:  MOVWF  25
5D62:  MOVLW  47
5D64:  MOVWF  24
5D66:  CLRF   19
5D68:  BTFSC  FF2.7
5D6A:  BSF    19.7
5D6C:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5D6E:  MOVFF  23,ABC
5D72:  MOVFF  22,ABB
5D76:  MOVFF  21,ABA
5D7A:  MOVFF  20,AB9
5D7E:  MOVLW  19
5D80:  MOVWF  xBD
5D82:  MOVLB  0
5D84:  CALL   3F72
5D88:  BTFSC  19.7
5D8A:  BSF    FF2.7
5D8C:  CLRF   19
5D8E:  BTFSC  FF2.7
5D90:  BSF    19.7
5D92:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5D94:  MOVFF  27,ABC
5D98:  MOVFF  26,ABB
5D9C:  MOVFF  25,ABA
5DA0:  MOVFF  24,AB9
5DA4:  MOVLW  1E
5DA6:  MOVLB  A
5DA8:  MOVWF  xBD
5DAA:  MOVLB  0
5DAC:  CALL   3F72
5DB0:  BTFSC  19.7
5DB2:  BSF    FF2.7
5DB4:  CLRF   19
5DB6:  BTFSC  FF2.7
5DB8:  BSF    19.7
5DBA:  BCF    FF2.7
....................    save_coutcard(0); 
5DBC:  MOVLB  A
5DBE:  CLRF   xB7
5DC0:  CLRF   xB6
5DC2:  MOVLB  0
5DC4:  CALL   45DC
5DC8:  BTFSC  19.7
5DCA:  BSF    FF2.7
.................... } 
5DCC:  GOTO   88CA (RETURN)
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
510E:  MOVLB  A
5110:  CLRF   x8E
5112:  MOVLW  14
5114:  MOVWF  x8F
5116:  CLRF   x91
5118:  MOVLW  55
511A:  MOVWF  x90
511C:  MOVLB  0
511E:  RCALL  5062
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5120:  INCFSZ 55,W
5122:  BRA    517A
5124:  INCFSZ 56,W
5126:  BRA    517A
5128:  INCFSZ x64,W
512A:  BRA    517A
....................       { 
....................          memset(buffer1,0,20); 
512C:  CLRF   FEA
512E:  MOVLW  2D
5130:  MOVWF  FE9
5132:  CLRF   00
5134:  CLRF   02
5136:  MOVLW  14
5138:  MOVWF  01
513A:  CALL   446E
....................          strcpy(buffer1,"admin"); 
513E:  CLRF   FEA
5140:  MOVLW  2D
5142:  MOVWF  FE9
5144:  MOVLW  00
5146:  CALL   00D2
514A:  TBLRD*-
514C:  TBLRD*+
514E:  MOVF   FF5,W
5150:  MOVWF  FEE
5152:  IORLW  00
5154:  BNZ   514C
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
5156:  MOVLB  A
5158:  CLRF   xA3
515A:  MOVLW  14
515C:  MOVWF  xA4
515E:  CLRF   xA6
5160:  MOVLW  2D
5162:  MOVWF  xA5
5164:  MOVLB  0
5166:  RCALL  50BC
....................          EEPROM_read(strobe_pass_addr,20,password); 
5168:  MOVLB  A
516A:  CLRF   x8E
516C:  MOVLW  14
516E:  MOVWF  x8F
5170:  CLRF   x91
5172:  MOVLW  55
5174:  MOVWF  x90
5176:  MOVLB  0
5178:  RCALL  5062
....................       } 
.................... } 
517A:  RETURN 0
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
572C:  MOVLB  A
572E:  CLRF   xA2
5730:  MOVF   xA2,W
5732:  SUBLW  13
5734:  BNC   574A
5736:  CLRF   03
5738:  MOVF   xA2,W
573A:  ADDLW  8E
573C:  MOVWF  FE9
573E:  MOVLW  0A
5740:  ADDWFC 03,W
5742:  MOVWF  FEA
5744:  SETF   FEF
5746:  INCF   xA2,F
5748:  BRA    5730
....................    EEPROM_write(strobe_pass_addr,20,buf); 
574A:  CLRF   xA3
574C:  MOVLW  14
574E:  MOVWF  xA4
5750:  MOVLW  0A
5752:  MOVWF  xA6
5754:  MOVLW  8E
5756:  MOVWF  xA5
5758:  MOVLB  0
575A:  RCALL  50BC
.................... } 
575C:  GOTO   768A (RETURN)
.................... //============================================ 
.................... void reset_2nd_number() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0; 
5760:  MOVLB  A
5762:  CLRF   xA2
5764:  MOVF   xA2,W
5766:  SUBLW  13
5768:  BNC   577E
576A:  CLRF   03
576C:  MOVF   xA2,W
576E:  ADDLW  8E
5770:  MOVWF  FE9
5772:  MOVLW  0A
5774:  ADDWFC 03,W
5776:  MOVWF  FEA
5778:  CLRF   FEF
577A:  INCF   xA2,F
577C:  BRA    5764
....................    EEPROM_write(strobe_mobile_num0,20,buf); 
577E:  MOVLW  41
5780:  MOVWF  xA3
5782:  MOVLW  14
5784:  MOVWF  xA4
5786:  MOVLW  0A
5788:  MOVWF  xA6
578A:  MOVLW  8E
578C:  MOVWF  xA5
578E:  MOVLB  0
5790:  RCALL  50BC
.................... } 
5792:  GOTO   7692 (RETURN)
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
387E:  BSF    F94.4
3880:  MOVLW  0A
3882:  MOVWF  00
3884:  DECFSZ 00,F
3886:  BRA    3884
3888:  BSF    F94.3
388A:  MOVLW  0B
388C:  MOVWF  00
388E:  DECFSZ 00,F
3890:  BRA    388E
3892:  BCF    F8B.4
3894:  BCF    F94.4
3896:  MOVLW  0A
3898:  MOVWF  00
389A:  DECFSZ 00,F
389C:  BRA    389A
389E:  BCF    F8B.3
38A0:  BCF    F94.3
....................    i2c_write(0xD0); 
38A2:  MOVLW  D0
38A4:  MOVLB  A
38A6:  MOVWF  xCE
38A8:  MOVLB  0
38AA:  RCALL  379E
....................    i2c_write(address); 
38AC:  MOVFF  ABD,ACE
38B0:  RCALL  379E
....................    i2c_start(); 
38B2:  BSF    F94.4
38B4:  MOVLW  0A
38B6:  MOVWF  00
38B8:  DECFSZ 00,F
38BA:  BRA    38B8
38BC:  BSF    F94.3
38BE:  MOVLW  0B
38C0:  MOVWF  00
38C2:  DECFSZ 00,F
38C4:  BRA    38C2
38C6:  BTFSS  F82.3
38C8:  BRA    38C6
38CA:  BCF    F8B.4
38CC:  BCF    F94.4
38CE:  MOVLW  0A
38D0:  MOVWF  00
38D2:  DECFSZ 00,F
38D4:  BRA    38D2
38D6:  BCF    F8B.3
38D8:  BCF    F94.3
....................    i2c_write(0xD1); 
38DA:  MOVLW  D1
38DC:  MOVLB  A
38DE:  MOVWF  xCE
38E0:  MOVLB  0
38E2:  RCALL  379E
....................    result = i2c_read(0); 
38E4:  CLRF   00
38E6:  RCALL  3814
38E8:  MOVFF  01,ABE
....................    i2c_stop(); 
38EC:  BCF    F94.4
38EE:  NOP   
38F0:  BSF    F94.3
38F2:  BTFSS  F82.3
38F4:  BRA    38F2
38F6:  MOVLW  0A
38F8:  MOVWF  00
38FA:  DECFSZ 00,F
38FC:  BRA    38FA
38FE:  BRA    3900
3900:  NOP   
3902:  BSF    F94.4
3904:  MOVLW  0A
3906:  MOVWF  00
3908:  DECFSZ 00,F
390A:  BRA    3908
....................     
....................    return(result); 
390C:  MOVLB  A
390E:  MOVFF  ABE,01
.................... } 
3912:  MOVLB  0
3914:  RETURN 0
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
584A:  BSF    F94.4
584C:  MOVLW  0A
584E:  MOVWF  00
5850:  DECFSZ 00,F
5852:  BRA    5850
5854:  BSF    F94.3
5856:  MOVLW  0B
5858:  MOVWF  00
585A:  DECFSZ 00,F
585C:  BRA    585A
585E:  BCF    F8B.4
5860:  BCF    F94.4
5862:  MOVLW  0A
5864:  MOVWF  00
5866:  DECFSZ 00,F
5868:  BRA    5866
586A:  BCF    F8B.3
586C:  BCF    F94.3
....................    delay_us(10); 
586E:  MOVLW  1A
5870:  MOVWF  00
5872:  DECFSZ 00,F
5874:  BRA    5872
5876:  NOP   
5878:  CLRF   19
587A:  BTFSC  FF2.7
587C:  BSF    19.7
587E:  BCF    FF2.7
....................    i2c_write(0xD0); 
5880:  MOVLW  D0
5882:  MOVLB  A
5884:  MOVWF  xCE
5886:  MOVLB  0
5888:  CALL   379E
588C:  BTFSC  19.7
588E:  BSF    FF2.7
....................    delay_us(10); 
5890:  MOVLW  1A
5892:  MOVWF  00
5894:  DECFSZ 00,F
5896:  BRA    5894
5898:  NOP   
589A:  CLRF   19
589C:  BTFSC  FF2.7
589E:  BSF    19.7
58A0:  BCF    FF2.7
....................    i2c_write(address); 
58A2:  MOVFF  A96,ACE
58A6:  CALL   379E
58AA:  BTFSC  19.7
58AC:  BSF    FF2.7
....................    delay_us(10); 
58AE:  MOVLW  1A
58B0:  MOVWF  00
58B2:  DECFSZ 00,F
58B4:  BRA    58B2
58B6:  NOP   
58B8:  CLRF   19
58BA:  BTFSC  FF2.7
58BC:  BSF    19.7
58BE:  BCF    FF2.7
....................    i2c_write(data); 
58C0:  MOVFF  A97,ACE
58C4:  CALL   379E
58C8:  BTFSC  19.7
58CA:  BSF    FF2.7
....................    i2c_stop(); 
58CC:  BCF    F94.4
58CE:  NOP   
58D0:  BSF    F94.3
58D2:  BTFSS  F82.3
58D4:  BRA    58D2
58D6:  MOVLW  0A
58D8:  MOVWF  00
58DA:  DECFSZ 00,F
58DC:  BRA    58DA
58DE:  BRA    58E0
58E0:  NOP   
58E2:  BSF    F94.4
58E4:  MOVLW  0A
58E6:  MOVWF  00
58E8:  DECFSZ 00,F
58EA:  BRA    58E8
....................    delay_us(10); 
58EC:  MOVLW  1A
58EE:  MOVWF  00
58F0:  DECFSZ 00,F
58F2:  BRA    58F0
58F4:  NOP   
.................... } 
58F6:  RETURN 0
....................  
.................... void rtc_init() 
.................... { 
*
517C:  CLRF   19
517E:  BTFSC  FF2.7
5180:  BSF    19.7
5182:  BCF    FF2.7
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
5184:  MOVLB  A
5186:  CLRF   xBD
5188:  MOVLB  0
518A:  CALL   387E
518E:  BTFSC  19.7
5190:  BSF    FF2.7
5192:  MOVFF  01,A8E
....................     
....................    data &= 0x7F; 
5196:  MOVLB  A
5198:  BCF    x8E.7
....................     
....................    i2c_start(); 
519A:  BSF    F94.4
519C:  MOVLW  0A
519E:  MOVWF  00
51A0:  DECFSZ 00,F
51A2:  BRA    51A0
51A4:  BSF    F94.3
51A6:  MOVLW  0B
51A8:  MOVWF  00
51AA:  DECFSZ 00,F
51AC:  BRA    51AA
51AE:  BCF    F8B.4
51B0:  BCF    F94.4
51B2:  MOVLW  0A
51B4:  MOVWF  00
51B6:  DECFSZ 00,F
51B8:  BRA    51B6
51BA:  BCF    F8B.3
51BC:  BCF    F94.3
51BE:  CLRF   19
51C0:  BTFSC  FF2.7
51C2:  BSF    19.7
51C4:  BCF    FF2.7
....................    i2c_write(0xD0); 
51C6:  MOVLW  D0
51C8:  MOVWF  xCE
51CA:  MOVLB  0
51CC:  CALL   379E
51D0:  BTFSC  19.7
51D2:  BSF    FF2.7
51D4:  CLRF   19
51D6:  BTFSC  FF2.7
51D8:  BSF    19.7
51DA:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
51DC:  MOVLB  A
51DE:  CLRF   xCE
51E0:  MOVLB  0
51E2:  CALL   379E
51E6:  BTFSC  19.7
51E8:  BSF    FF2.7
51EA:  CLRF   19
51EC:  BTFSC  FF2.7
51EE:  BSF    19.7
51F0:  BCF    FF2.7
....................    i2c_write(data); 
51F2:  MOVFF  A8E,ACE
51F6:  CALL   379E
51FA:  BTFSC  19.7
51FC:  BSF    FF2.7
....................    i2c_start(); 
51FE:  BSF    F94.4
5200:  MOVLW  0A
5202:  MOVWF  00
5204:  DECFSZ 00,F
5206:  BRA    5204
5208:  BSF    F94.3
520A:  MOVLW  0B
520C:  MOVWF  00
520E:  DECFSZ 00,F
5210:  BRA    520E
5212:  BTFSS  F82.3
5214:  BRA    5212
5216:  BCF    F8B.4
5218:  BCF    F94.4
521A:  MOVLW  0A
521C:  MOVWF  00
521E:  DECFSZ 00,F
5220:  BRA    521E
5222:  BCF    F8B.3
5224:  BCF    F94.3
5226:  CLRF   19
5228:  BTFSC  FF2.7
522A:  BSF    19.7
522C:  BCF    FF2.7
....................    i2c_write(0xD0); 
522E:  MOVLW  D0
5230:  MOVLB  A
5232:  MOVWF  xCE
5234:  MOVLB  0
5236:  CALL   379E
523A:  BTFSC  19.7
523C:  BSF    FF2.7
523E:  CLRF   19
5240:  BTFSC  FF2.7
5242:  BSF    19.7
5244:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
5246:  MOVLW  07
5248:  MOVLB  A
524A:  MOVWF  xCE
524C:  MOVLB  0
524E:  CALL   379E
5252:  BTFSC  19.7
5254:  BSF    FF2.7
5256:  CLRF   19
5258:  BTFSC  FF2.7
525A:  BSF    19.7
525C:  BCF    FF2.7
....................    i2c_write(0x80); 
525E:  MOVLW  80
5260:  MOVLB  A
5262:  MOVWF  xCE
5264:  MOVLB  0
5266:  CALL   379E
526A:  BTFSC  19.7
526C:  BSF    FF2.7
....................    i2c_stop(); 
526E:  BCF    F94.4
5270:  NOP   
5272:  BSF    F94.3
5274:  BTFSS  F82.3
5276:  BRA    5274
5278:  MOVLW  0A
527A:  MOVWF  00
527C:  DECFSZ 00,F
527E:  BRA    527C
5280:  BRA    5282
5282:  NOP   
5284:  BSF    F94.4
5286:  MOVLW  0A
5288:  MOVWF  00
528A:  DECFSZ 00,F
528C:  BRA    528A
.................... } 
528E:  GOTO   6DF0 (RETURN)
....................  
.................... unsigned int8 get_bcd(BYTE data) 
.................... { 
*
58F8:  CLRF   19
58FA:  BTFSC  FF2.7
58FC:  BSF    19.7
58FE:  BCF    FF2.7
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
5900:  MOVFF  A95,AC5
5904:  MOVLW  0A
5906:  MOVLB  A
5908:  MOVWF  xC6
590A:  MOVLB  0
590C:  CALL   1800
5910:  BTFSC  19.7
5912:  BSF    FF2.7
5914:  MOVFF  01,A96
....................    nibl=data-(nibh*10); 
5918:  MOVLB  A
591A:  MOVF   x96,W
591C:  MULLW  0A
591E:  MOVF   FF3,W
5920:  SUBWF  x95,W
5922:  MOVWF  x97
....................  
....................    return((nibh<<4)|nibl); 
5924:  SWAPF  x96,W
5926:  MOVWF  00
5928:  MOVLW  F0
592A:  ANDWF  00,F
592C:  MOVF   00,W
592E:  IORWF  x97,W
5930:  MOVWF  01
.................... } 
5932:  MOVLB  0
5934:  RETURN 0
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
3916:  MOVFF  ABE,ABF
....................    data=(i>>4)*10; 
391A:  MOVLB  A
391C:  SWAPF  xBF,W
391E:  MOVWF  00
3920:  MOVLW  0F
3922:  ANDWF  00,F
3924:  MOVF   00,W
3926:  MULLW  0A
3928:  MOVFF  FF3,ABE
....................    data=data+(i<<4>>4); 
392C:  SWAPF  xBF,W
392E:  MOVWF  00
3930:  MOVLW  F0
3932:  ANDWF  00,F
3934:  MOVF   00,W
3936:  SWAPF  00,F
3938:  MOVLW  0F
393A:  ANDWF  00,F
393C:  MOVF   00,W
393E:  ADDWF  xBE,F
....................  
....................    return data; 
3940:  MOVFF  ABE,01
.................... } 
3944:  MOVLB  0
3946:  RETURN 0
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
5936:  MOVLB  A
5938:  CLRF   x96
593A:  CLRF   x97
593C:  MOVLB  0
593E:  RCALL  584A
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
5940:  MOVFF  A94,A95
5944:  RCALL  58F8
5946:  MOVFF  01,A95
594A:  MOVLW  01
594C:  MOVLB  A
594E:  MOVWF  x96
5950:  MOVFF  01,A97
5954:  MOVLB  0
5956:  RCALL  584A
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
5958:  MOVFF  A93,A95
595C:  RCALL  58F8
595E:  MOVFF  01,A95
5962:  MOVLW  02
5964:  MOVLB  A
5966:  MOVWF  x96
5968:  MOVFF  01,A97
596C:  MOVLB  0
596E:  RCALL  584A
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
5970:  MOVFF  A92,A95
5974:  RCALL  58F8
5976:  MOVFF  01,A95
597A:  MOVLW  03
597C:  MOVLB  A
597E:  MOVWF  x96
5980:  MOVFF  01,A97
5984:  MOVLB  0
5986:  RCALL  584A
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
5988:  MOVFF  A8F,A95
598C:  RCALL  58F8
598E:  MOVFF  01,A95
5992:  MOVLW  04
5994:  MOVLB  A
5996:  MOVWF  x96
5998:  MOVFF  01,A97
599C:  MOVLB  0
599E:  RCALL  584A
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
59A0:  MOVFF  A90,A95
59A4:  RCALL  58F8
59A6:  MOVFF  01,A95
59AA:  MOVLW  05
59AC:  MOVLB  A
59AE:  MOVWF  x96
59B0:  MOVFF  01,A97
59B4:  MOVLB  0
59B6:  RCALL  584A
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
59B8:  MOVFF  A91,A95
59BC:  RCALL  58F8
59BE:  MOVFF  01,A95
59C2:  MOVLW  06
59C4:  MOVLB  A
59C6:  MOVWF  x96
59C8:  MOVFF  01,A97
59CC:  MOVLB  0
59CE:  RCALL  584A
....................    write_DS1307(DS1307_CONTROL,0);    
59D0:  MOVLW  07
59D2:  MOVLB  A
59D4:  MOVWF  x96
59D6:  CLRF   x97
59D8:  MOVLB  0
59DA:  RCALL  584A
.................... } 
59DC:  GOTO   5A46 (RETURN)
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
3FF6:  MOVLW  04
3FF8:  MOVLB  A
3FFA:  MOVWF  xBD
3FFC:  MOVLB  0
3FFE:  RCALL  387E
4000:  MOVFF  01,AB9
4004:  MOVFF  01,ABE
4008:  RCALL  3916
400A:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
400E:  MOVLW  05
4010:  MOVLB  A
4012:  MOVWF  xBD
4014:  MOVLB  0
4016:  RCALL  387E
4018:  MOVFF  01,AB9
401C:  MOVFF  01,ABE
4020:  RCALL  3916
4022:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
4026:  MOVLW  06
4028:  MOVLB  A
402A:  MOVWF  xBD
402C:  MOVLB  0
402E:  RCALL  387E
4030:  MOVFF  01,AB9
4034:  MOVFF  01,ABE
4038:  RCALL  3916
403A:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
403E:  MOVLW  03
4040:  MOVLB  A
4042:  MOVWF  xBD
4044:  MOVLB  0
4046:  RCALL  387E
4048:  MOVFF  01,AB9
404C:  MOVFF  01,ABE
4050:  RCALL  3916
4052:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
4056:  MOVLW  02
4058:  MOVLB  A
405A:  MOVWF  xBD
405C:  MOVLB  0
405E:  RCALL  387E
4060:  MOVFF  01,AB9
4064:  MOVFF  01,ABE
4068:  RCALL  3916
406A:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
406E:  MOVLW  01
4070:  MOVLB  A
4072:  MOVWF  xBD
4074:  MOVLB  0
4076:  RCALL  387E
4078:  MOVFF  01,AB9
407C:  MOVFF  01,ABE
4080:  RCALL  3916
4082:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
4086:  MOVLB  A
4088:  CLRF   xBD
408A:  MOVLB  0
408C:  CALL   387E
4090:  MOVFF  01,AB9
4094:  MOVFF  01,ABE
4098:  RCALL  3916
409A:  MOVFF  01,103
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0,booting=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... int16 count_checking=10; 
.................... #include <scan_key.c> 
....................  
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... int8 type_KB=0; 
.................... #define key_numbyte  50 
....................  
.................... int8 key_data[key_numbyte]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
23AE:  MOVLB  1
23B0:  INCF   x47,F
23B2:  MOVF   x47,W
23B4:  SUBLW  01
23B6:  BTFSC  FD8.0
23B8:  BRA    255E
....................        switch (col) { 
23BA:  MOVF   x4A,W
23BC:  ADDLW  FB
23BE:  BC    2442
23C0:  ADDLW  05
23C2:  MOVLB  0
23C4:  GOTO   2568
....................          case 0   :  
....................                     output_low(COL0); 
23C8:  BCF    F92.5
23CA:  BCF    F89.5
....................                     output_high(COL1); 
23CC:  BCF    F92.3
23CE:  BSF    F89.3
....................                     output_high(COL2); 
23D0:  BCF    F92.2
23D2:  BSF    F89.2
....................                     output_high(COL3); 
23D4:  BCF    F92.1
23D6:  BSF    F89.1
....................                     output_high(COL4); 
23D8:  BCF    F92.0
23DA:  BSF    F89.0
....................                     break; 
23DC:  MOVLB  1
23DE:  BRA    2442
....................          case 1   :  
....................                     output_low(COL1); 
23E0:  BCF    F92.3
23E2:  BCF    F89.3
....................                     output_high(COL0); 
23E4:  BCF    F92.5
23E6:  BSF    F89.5
....................                     output_high(COL2); 
23E8:  BCF    F92.2
23EA:  BSF    F89.2
....................                     output_high(COL3); 
23EC:  BCF    F92.1
23EE:  BSF    F89.1
....................                     output_high(COL4); 
23F0:  BCF    F92.0
23F2:  BSF    F89.0
....................                     break; 
23F4:  MOVLB  1
23F6:  BRA    2442
....................          case 2   :  
....................                     output_low(COL2); 
23F8:  BCF    F92.2
23FA:  BCF    F89.2
....................                     output_high(COL1); 
23FC:  BCF    F92.3
23FE:  BSF    F89.3
....................                     output_high(COL0); 
2400:  BCF    F92.5
2402:  BSF    F89.5
....................                     output_high(COL3); 
2404:  BCF    F92.1
2406:  BSF    F89.1
....................                     output_high(COL4); 
2408:  BCF    F92.0
240A:  BSF    F89.0
....................                     break; 
240C:  MOVLB  1
240E:  BRA    2442
....................          case 3   :  
....................                     output_low(COL3); 
2410:  BCF    F92.1
2412:  BCF    F89.1
....................                     output_high(COL1); 
2414:  BCF    F92.3
2416:  BSF    F89.3
....................                     output_high(COL2); 
2418:  BCF    F92.2
241A:  BSF    F89.2
....................                     output_high(COL0); 
241C:  BCF    F92.5
241E:  BSF    F89.5
....................                     output_high(COL4); 
2420:  BCF    F92.0
2422:  BSF    F89.0
....................                     break; 
2424:  MOVLB  1
2426:  BRA    2442
....................          case 4   :  
....................                     output_low(COL4); 
2428:  BCF    F92.0
242A:  BCF    F89.0
....................                     output_high(COL1); 
242C:  BCF    F92.3
242E:  BSF    F89.3
....................                     output_high(COL2); 
2430:  BCF    F92.2
2432:  BSF    F89.2
....................                     output_high(COL3); 
2434:  BCF    F92.1
2436:  BSF    F89.1
....................                     output_high(COL0); 
2438:  BCF    F92.5
243A:  BSF    F89.5
....................                     break; 
243C:  MOVLB  1
243E:  BRA    2442
2440:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
2442:  BTFSS  x48.0
2444:  BRA    24C4
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2446:  BSF    F93.4
2448:  MOVLW  00
244A:  BTFSC  F81.4
244C:  MOVLW  01
244E:  MOVLB  A
2450:  MOVWF  xB8
2452:  BSF    F93.5
2454:  MOVLW  00
2456:  BTFSC  F81.5
2458:  MOVLW  01
245A:  ANDWF  xB8,F
245C:  BSF    F93.6
245E:  MOVLW  00
2460:  BTFSC  F81.6
2462:  MOVLW  01
2464:  ANDWF  xB8,F
2466:  BSF    F93.7
2468:  MOVLW  00
246A:  BTFSC  F81.7
246C:  MOVLW  01
246E:  ANDWF  xB8,W
2470:  BZ    24C0
....................          { 
....................             kchar=last_key; 
2472:  MOVFF  149,AB6
....................             if(keydebug_en==0) 
2476:  MOVLB  1
2478:  MOVF   x0B,F
247A:  BNZ   24AE
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
247C:  CLRF   x09
247E:  CLRF   x08
....................               charac_timeout=0; 
2480:  MOVLB  0
2482:  CLRF   xFC
2484:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
2486:  MOVLB  1
2488:  MOVF   x0E,W
248A:  SUBLW  31
248C:  BNC   24A2
248E:  MOVF   x0E,W
2490:  INCF   x0E,F
2492:  CLRF   03
2494:  ADDLW  14
2496:  MOVWF  FE9
2498:  MOVLW  01
249A:  ADDWFC 03,W
249C:  MOVWF  FEA
249E:  MOVFF  AB6,FEF
....................                fputc(kchar,COM2); 
24A2:  MOVFF  AB6,ADF
24A6:  MOVLB  0
24A8:  CALL   075A
....................             } 
....................                else fputc(kchar,COM2); 
24AC:  BRA    24B8
24AE:  MOVFF  AB6,ADF
24B2:  MOVLB  0
24B4:  CALL   075A
....................            kbd_down=FALSE; 
24B8:  MOVLB  1
24BA:  BCF    x48.0
....................            last_key=0; 
24BC:  CLRF   x49
24BE:  MOVLB  A
....................          } 
....................        } else 
24C0:  BRA    255A
24C2:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
24C4:  BSF    F93.4
24C6:  MOVLW  00
24C8:  BTFSC  F81.4
24CA:  MOVLW  01
24CC:  MOVLB  A
24CE:  MOVWF  xB8
24D0:  BSF    F93.5
24D2:  MOVLW  00
24D4:  BTFSC  F81.5
24D6:  MOVLW  01
24D8:  ANDWF  xB8,F
24DA:  BSF    F93.6
24DC:  MOVLW  00
24DE:  BTFSC  F81.6
24E0:  MOVLW  01
24E2:  ANDWF  xB8,F
24E4:  BSF    F93.7
24E6:  MOVLW  00
24E8:  BTFSC  F81.7
24EA:  MOVLW  01
24EC:  ANDWF  xB8,W
24EE:  BNZ   254E
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
24F0:  BSF    F93.4
24F2:  BTFSC  F81.4
24F4:  BRA    24FA
....................                   row=0; 
24F6:  CLRF   xB7
....................                 else if(input(ROW1)==0) 
24F8:  BRA    251C
24FA:  BSF    F93.5
24FC:  BTFSC  F81.5
24FE:  BRA    2506
....................                   row=1; 
2500:  MOVLW  01
2502:  MOVWF  xB7
....................                 else if(input(ROW2)==0) 
2504:  BRA    251C
2506:  BSF    F93.6
2508:  BTFSC  F81.6
250A:  BRA    2512
....................                   row=2; 
250C:  MOVLW  02
250E:  MOVWF  xB7
....................                 else if(input(ROW3)==0) 
2510:  BRA    251C
2512:  BSF    F93.7
2514:  BTFSC  F81.7
2516:  BRA    251C
....................                   row=3; 
2518:  MOVLW  03
251A:  MOVWF  xB7
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
251C:  MOVF   xB7,W
251E:  MULLW  05
2520:  MOVF   FF3,W
2522:  CLRF   xB9
2524:  MOVWF  xB8
2526:  CLRF   03
2528:  MOVLB  1
252A:  MOVF   x4A,W
252C:  MOVLB  A
252E:  ADDWF  xB8,W
2530:  MOVWF  01
2532:  MOVF   xB9,W
2534:  ADDWFC 03,F
2536:  MOVF   01,W
2538:  MOVLB  0
253A:  CALL   00E8
253E:  MOVFF  FE8,149
....................                 kbd_down = TRUE; 
2542:  MOVLB  1
2544:  BSF    x48.0
....................                 set_tris_a(0xff); 
2546:  MOVLW  FF
2548:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
254A:  BRA    255A
254C:  MOVLB  A
....................                { 
....................                   ++col; 
254E:  MOVLB  1
2550:  INCF   x4A,F
....................                   if(col==5) col=0; 
2552:  MOVF   x4A,W
2554:  SUBLW  05
2556:  BTFSC  FD8.2
2558:  CLRF   x4A
....................                } 
....................          } 
....................       kbd_call_count=0; 
255A:  MOVLB  1
255C:  CLRF   x47
....................    } 
....................   return(kchar); 
255E:  MOVLB  A
2560:  MOVFF  AB6,01
.................... } 
2564:  MOVLB  0
2566:  RETURN 0
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
258C:  MOVLW  E0
258E:  MOVLB  F
2590:  MOVWF  x48
2592:  BCF    FC2.6
2594:  BCF    FC2.7
2596:  MOVF   x49,W
2598:  ANDLW  E0
259A:  IORLW  17
259C:  MOVWF  x49
....................    switch(col) 
....................    { 
259E:  MOVLB  A
25A0:  MOVF   xD3,W
25A2:  ADDLW  FA
25A4:  BC    2670
25A6:  ADDLW  06
25A8:  MOVLB  0
25AA:  GOTO   2674
....................       case 0: 
....................         set_adc_channel(4); 
25AE:  MOVLW  10
25B0:  MOVWF  01
25B2:  MOVF   FC2,W
25B4:  ANDLW  C3
25B6:  IORWF  01,W
25B8:  MOVWF  FC2
....................         adc=read_adc(); 
25BA:  BSF    FC2.1
25BC:  BTFSC  FC2.1
25BE:  BRA    25BC
25C0:  MOVFF  FC4,AD4
....................         return adc; 
25C4:  MOVLB  A
25C6:  MOVFF  AD4,01
25CA:  BRA    2670
....................       break; 
25CC:  BRA    2670
....................       case 1: 
....................         set_adc_channel(3); 
25CE:  MOVLW  0C
25D0:  MOVWF  01
25D2:  MOVF   FC2,W
25D4:  ANDLW  C3
25D6:  IORWF  01,W
25D8:  MOVWF  FC2
....................         adc=read_adc(); 
25DA:  BSF    FC2.1
25DC:  BTFSC  FC2.1
25DE:  BRA    25DC
25E0:  MOVFF  FC4,AD4
....................         return adc; 
25E4:  MOVLB  A
25E6:  MOVFF  AD4,01
25EA:  BRA    2670
....................       break; 
25EC:  BRA    2670
....................       case 2: 
....................         set_adc_channel(2); 
25EE:  MOVLW  08
25F0:  MOVWF  01
25F2:  MOVF   FC2,W
25F4:  ANDLW  C3
25F6:  IORWF  01,W
25F8:  MOVWF  FC2
....................         adc=read_adc(); 
25FA:  BSF    FC2.1
25FC:  BTFSC  FC2.1
25FE:  BRA    25FC
2600:  MOVFF  FC4,AD4
....................         return adc; 
2604:  MOVLB  A
2606:  MOVFF  AD4,01
260A:  BRA    2670
....................       break; 
260C:  BRA    2670
....................       case 3: 
....................         set_adc_channel(1); 
260E:  MOVLW  04
2610:  MOVWF  01
2612:  MOVF   FC2,W
2614:  ANDLW  C3
2616:  IORWF  01,W
2618:  MOVWF  FC2
....................         adc=read_adc(); 
261A:  BSF    FC2.1
261C:  BTFSC  FC2.1
261E:  BRA    261C
2620:  MOVFF  FC4,AD4
....................         return adc; 
2624:  MOVLB  A
2626:  MOVFF  AD4,01
262A:  BRA    2670
....................       break; 
262C:  BRA    2670
....................       case 4: 
....................         set_adc_channel(0); 
262E:  MOVLW  00
2630:  MOVWF  01
2632:  MOVF   FC2,W
2634:  ANDLW  C3
2636:  IORWF  01,W
2638:  MOVWF  FC2
....................         adc=read_adc(); 
263A:  BSF    FC2.1
263C:  BTFSC  FC2.1
263E:  BRA    263C
2640:  MOVFF  FC4,AD4
....................         return adc; 
2644:  MOVLB  A
2646:  MOVFF  AD4,01
264A:  BRA    2670
....................       break;      
264C:  BRA    2670
....................       case 5: 
....................         set_adc_channel(11); 
264E:  MOVLW  2C
2650:  MOVWF  01
2652:  MOVF   FC2,W
2654:  ANDLW  C3
2656:  IORWF  01,W
2658:  MOVWF  FC2
....................         adc=read_adc(); 
265A:  BSF    FC2.1
265C:  BTFSC  FC2.1
265E:  BRA    265C
2660:  MOVFF  FC4,AD4
....................         return adc; 
2664:  MOVLB  A
2666:  MOVFF  AD4,01
266A:  BRA    2670
....................       break;      
266C:  BRA    2670
266E:  MOVLB  A
....................    } 
.................... } 
2670:  MOVLB  0
2672:  RETURN 0
....................  
.................... //=========================== 
.................... int8 check_col() 
.................... { 
*
27EE:  MOVLB  A
27F0:  CLRF   xBE
27F2:  CLRF   xBD
27F4:  CLRF   xBC
27F6:  CLRF   xBB
27F8:  CLRF   xC2
27FA:  CLRF   xC1
27FC:  CLRF   xC0
27FE:  CLRF   xBF
2800:  CLRF   xC6
2802:  CLRF   xC5
2804:  CLRF   xC4
2806:  CLRF   xC3
2808:  CLRF   xCA
280A:  CLRF   xC9
280C:  CLRF   xC8
280E:  CLRF   xC7
2810:  CLRF   xCE
2812:  CLRF   xCD
2814:  CLRF   xCC
2816:  CLRF   xCB
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2818:  CLRF   xBA
281A:  CLRF   xB9
281C:  MOVF   xBA,W
281E:  SUBLW  01
2820:  BNC   289E
2822:  BNZ   282A
2824:  MOVF   xB9,W
2826:  SUBLW  F3
2828:  BNC   289E
....................    { 
....................       col_0=read_col(0)+col_0; 
282A:  CLRF   xD3
282C:  MOVLB  0
282E:  RCALL  258C
2830:  MOVF   01,W
2832:  MOVLB  A
2834:  ADDWF  xBB,F
2836:  MOVLW  00
2838:  ADDWFC xBC,F
283A:  ADDWFC xBD,F
283C:  ADDWFC xBE,F
....................       col_1=read_col(1)+col_1; 
283E:  MOVLW  01
2840:  MOVWF  xD3
2842:  MOVLB  0
2844:  RCALL  258C
2846:  MOVF   01,W
2848:  MOVLB  A
284A:  ADDWF  xBF,F
284C:  MOVLW  00
284E:  ADDWFC xC0,F
2850:  ADDWFC xC1,F
2852:  ADDWFC xC2,F
....................       col_2=read_col(2)+col_2; 
2854:  MOVLW  02
2856:  MOVWF  xD3
2858:  MOVLB  0
285A:  RCALL  258C
285C:  MOVF   01,W
285E:  MOVLB  A
2860:  ADDWF  xC3,F
2862:  MOVLW  00
2864:  ADDWFC xC4,F
2866:  ADDWFC xC5,F
2868:  ADDWFC xC6,F
....................       col_3=read_col(3)+col_3; 
286A:  MOVLW  03
286C:  MOVWF  xD3
286E:  MOVLB  0
2870:  RCALL  258C
2872:  MOVF   01,W
2874:  MOVLB  A
2876:  ADDWF  xC7,F
2878:  MOVLW  00
287A:  ADDWFC xC8,F
287C:  ADDWFC xC9,F
287E:  ADDWFC xCA,F
....................       col_4=read_col(4)+col_4; 
2880:  MOVLW  04
2882:  MOVWF  xD3
2884:  MOVLB  0
2886:  RCALL  258C
2888:  MOVF   01,W
288A:  MOVLB  A
288C:  ADDWF  xCB,F
288E:  MOVLW  00
2890:  ADDWFC xCC,F
2892:  ADDWFC xCD,F
2894:  ADDWFC xCE,F
....................    } 
2896:  INCF   xB9,F
2898:  BTFSC  FD8.2
289A:  INCF   xBA,F
289C:  BRA    281C
....................    col_0=col_0/500; 
289E:  BCF    FD8.1
28A0:  MOVFF  ABE,AE2
28A4:  MOVFF  ABD,AE1
28A8:  MOVFF  ABC,AE0
28AC:  MOVFF  ABB,ADF
28B0:  CLRF   xE6
28B2:  CLRF   xE5
28B4:  MOVLW  01
28B6:  MOVWF  xE4
28B8:  MOVLW  F4
28BA:  MOVWF  xE3
28BC:  MOVLB  0
28BE:  RCALL  269A
28C0:  MOVFF  03,ABE
28C4:  MOVFF  02,ABD
28C8:  MOVFF  01,ABC
28CC:  MOVFF  00,ABB
....................    col_1=col_1/500; 
28D0:  BCF    FD8.1
28D2:  MOVFF  AC2,AE2
28D6:  MOVFF  AC1,AE1
28DA:  MOVFF  AC0,AE0
28DE:  MOVFF  ABF,ADF
28E2:  MOVLB  A
28E4:  CLRF   xE6
28E6:  CLRF   xE5
28E8:  MOVLW  01
28EA:  MOVWF  xE4
28EC:  MOVLW  F4
28EE:  MOVWF  xE3
28F0:  MOVLB  0
28F2:  RCALL  269A
28F4:  MOVFF  03,AC2
28F8:  MOVFF  02,AC1
28FC:  MOVFF  01,AC0
2900:  MOVFF  00,ABF
....................    col_2=col_2/500; 
2904:  BCF    FD8.1
2906:  MOVFF  AC6,AE2
290A:  MOVFF  AC5,AE1
290E:  MOVFF  AC4,AE0
2912:  MOVFF  AC3,ADF
2916:  MOVLB  A
2918:  CLRF   xE6
291A:  CLRF   xE5
291C:  MOVLW  01
291E:  MOVWF  xE4
2920:  MOVLW  F4
2922:  MOVWF  xE3
2924:  MOVLB  0
2926:  RCALL  269A
2928:  MOVFF  03,AC6
292C:  MOVFF  02,AC5
2930:  MOVFF  01,AC4
2934:  MOVFF  00,AC3
....................    col_3=col_3/500; 
2938:  BCF    FD8.1
293A:  MOVFF  ACA,AE2
293E:  MOVFF  AC9,AE1
2942:  MOVFF  AC8,AE0
2946:  MOVFF  AC7,ADF
294A:  MOVLB  A
294C:  CLRF   xE6
294E:  CLRF   xE5
2950:  MOVLW  01
2952:  MOVWF  xE4
2954:  MOVLW  F4
2956:  MOVWF  xE3
2958:  MOVLB  0
295A:  RCALL  269A
295C:  MOVFF  03,ACA
2960:  MOVFF  02,AC9
2964:  MOVFF  01,AC8
2968:  MOVFF  00,AC7
....................    col_4=col_4/500; 
296C:  BCF    FD8.1
296E:  MOVFF  ACE,AE2
2972:  MOVFF  ACD,AE1
2976:  MOVFF  ACC,AE0
297A:  MOVFF  ACB,ADF
297E:  MOVLB  A
2980:  CLRF   xE6
2982:  CLRF   xE5
2984:  MOVLW  01
2986:  MOVWF  xE4
2988:  MOVLW  F4
298A:  MOVWF  xE3
298C:  MOVLB  0
298E:  RCALL  269A
2990:  MOVFF  03,ACE
2994:  MOVFF  02,ACD
2998:  MOVFF  01,ACC
299C:  MOVFF  00,ACB
....................    if(keydebug_en) 
29A0:  MOVLB  1
29A2:  MOVF   x0B,F
29A4:  BTFSC  FD8.2
29A6:  BRA    2B22
....................    { 
....................       fprintf(COM2,"\r\n");      
29A8:  MOVLW  0D
29AA:  MOVLB  A
29AC:  MOVWF  xDF
29AE:  MOVLB  0
29B0:  CALL   075A
29B4:  MOVLW  0A
29B6:  MOVLB  A
29B8:  MOVWF  xDF
29BA:  MOVLB  0
29BC:  CALL   075A
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
29C0:  MOVLW  26
29C2:  MOVWF  FF6
29C4:  MOVLW  04
29C6:  MOVWF  FF7
29C8:  MOVLW  07
29CA:  MOVLB  A
29CC:  MOVWF  xD3
29CE:  MOVLB  0
29D0:  CALL   1718
29D4:  MOVLW  41
29D6:  MOVWF  FE9
29D8:  MOVFF  ABE,AD6
29DC:  MOVFF  ABD,AD5
29E0:  MOVFF  ABC,AD4
29E4:  MOVFF  ABB,AD3
29E8:  RCALL  272E
29EA:  MOVLW  0D
29EC:  MOVLB  A
29EE:  MOVWF  xDF
29F0:  MOVLB  0
29F2:  CALL   075A
29F6:  MOVLW  0A
29F8:  MOVLB  A
29FA:  MOVWF  xDF
29FC:  MOVLB  0
29FE:  CALL   075A
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2A02:  MOVLW  34
2A04:  MOVWF  FF6
2A06:  MOVLW  04
2A08:  MOVWF  FF7
2A0A:  MOVLW  07
2A0C:  MOVLB  A
2A0E:  MOVWF  xD3
2A10:  MOVLB  0
2A12:  CALL   1718
2A16:  MOVLW  41
2A18:  MOVWF  FE9
2A1A:  MOVFF  AC2,AD6
2A1E:  MOVFF  AC1,AD5
2A22:  MOVFF  AC0,AD4
2A26:  MOVFF  ABF,AD3
2A2A:  RCALL  272E
2A2C:  MOVLW  0D
2A2E:  MOVLB  A
2A30:  MOVWF  xDF
2A32:  MOVLB  0
2A34:  CALL   075A
2A38:  MOVLW  0A
2A3A:  MOVLB  A
2A3C:  MOVWF  xDF
2A3E:  MOVLB  0
2A40:  CALL   075A
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2A44:  MOVLW  42
2A46:  MOVWF  FF6
2A48:  MOVLW  04
2A4A:  MOVWF  FF7
2A4C:  MOVLW  07
2A4E:  MOVLB  A
2A50:  MOVWF  xD3
2A52:  MOVLB  0
2A54:  CALL   1718
2A58:  MOVLW  41
2A5A:  MOVWF  FE9
2A5C:  MOVFF  AC6,AD6
2A60:  MOVFF  AC5,AD5
2A64:  MOVFF  AC4,AD4
2A68:  MOVFF  AC3,AD3
2A6C:  RCALL  272E
2A6E:  MOVLW  0D
2A70:  MOVLB  A
2A72:  MOVWF  xDF
2A74:  MOVLB  0
2A76:  CALL   075A
2A7A:  MOVLW  0A
2A7C:  MOVLB  A
2A7E:  MOVWF  xDF
2A80:  MOVLB  0
2A82:  CALL   075A
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2A86:  MOVLW  50
2A88:  MOVWF  FF6
2A8A:  MOVLW  04
2A8C:  MOVWF  FF7
2A8E:  MOVLW  07
2A90:  MOVLB  A
2A92:  MOVWF  xD3
2A94:  MOVLB  0
2A96:  CALL   1718
2A9A:  MOVLW  41
2A9C:  MOVWF  FE9
2A9E:  MOVFF  ACA,AD6
2AA2:  MOVFF  AC9,AD5
2AA6:  MOVFF  AC8,AD4
2AAA:  MOVFF  AC7,AD3
2AAE:  RCALL  272E
2AB0:  MOVLW  0D
2AB2:  MOVLB  A
2AB4:  MOVWF  xDF
2AB6:  MOVLB  0
2AB8:  CALL   075A
2ABC:  MOVLW  0A
2ABE:  MOVLB  A
2AC0:  MOVWF  xDF
2AC2:  MOVLB  0
2AC4:  CALL   075A
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2AC8:  MOVLW  5E
2ACA:  MOVWF  FF6
2ACC:  MOVLW  04
2ACE:  MOVWF  FF7
2AD0:  MOVLW  07
2AD2:  MOVLB  A
2AD4:  MOVWF  xD3
2AD6:  MOVLB  0
2AD8:  CALL   1718
2ADC:  MOVLW  41
2ADE:  MOVWF  FE9
2AE0:  MOVFF  ACE,AD6
2AE4:  MOVFF  ACD,AD5
2AE8:  MOVFF  ACC,AD4
2AEC:  MOVFF  ACB,AD3
2AF0:  RCALL  272E
2AF2:  MOVLW  0D
2AF4:  MOVLB  A
2AF6:  MOVWF  xDF
2AF8:  MOVLB  0
2AFA:  CALL   075A
2AFE:  MOVLW  0A
2B00:  MOVLB  A
2B02:  MOVWF  xDF
2B04:  MOVLB  0
2B06:  CALL   075A
....................       fprintf(COM2,"\r\n"); 
2B0A:  MOVLW  0D
2B0C:  MOVLB  A
2B0E:  MOVWF  xDF
2B10:  MOVLB  0
2B12:  CALL   075A
2B16:  MOVLW  0A
2B18:  MOVLB  A
2B1A:  MOVWF  xDF
2B1C:  MOVLB  0
2B1E:  CALL   075A
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
2B22:  MOVLB  A
2B24:  MOVF   xBE,F
2B26:  BNZ   2B36
2B28:  MOVF   xBD,F
2B2A:  BNZ   2B36
2B2C:  MOVF   xBC,F
2B2E:  BNZ   2B36
2B30:  MOVF   xBB,W
2B32:  SUBLW  05
2B34:  BC    2B96
2B36:  MOVF   xBE,F
2B38:  BNZ   2B96
2B3A:  MOVF   xBD,F
2B3C:  BNZ   2B96
2B3E:  MOVF   xBC,F
2B40:  BNZ   2B96
2B42:  MOVF   xBB,W
2B44:  SUBLW  3B
2B46:  BNC   2B96
2B48:  MOVF   xC2,F
2B4A:  BNZ   2B5A
2B4C:  MOVF   xC1,F
2B4E:  BNZ   2B5A
2B50:  MOVF   xC0,F
2B52:  BNZ   2B5A
2B54:  MOVF   xBF,W
2B56:  SUBLW  64
2B58:  BC    2B96
2B5A:  MOVF   xC6,F
2B5C:  BNZ   2B6C
2B5E:  MOVF   xC5,F
2B60:  BNZ   2B6C
2B62:  MOVF   xC4,F
2B64:  BNZ   2B6C
2B66:  MOVF   xC3,W
2B68:  SUBLW  64
2B6A:  BC    2B96
2B6C:  MOVF   xCA,F
2B6E:  BNZ   2B7E
2B70:  MOVF   xC9,F
2B72:  BNZ   2B7E
2B74:  MOVF   xC8,F
2B76:  BNZ   2B7E
2B78:  MOVF   xC7,W
2B7A:  SUBLW  64
2B7C:  BC    2B96
2B7E:  MOVF   xCE,F
2B80:  BNZ   2B90
2B82:  MOVF   xCD,F
2B84:  BNZ   2B90
2B86:  MOVF   xCC,F
2B88:  BNZ   2B90
2B8A:  MOVF   xCB,W
2B8C:  SUBLW  64
2B8E:  BC    2B96
2B90:  MOVLW  00
2B92:  MOVWF  01
2B94:  BRA    2E14
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
2B96:  MOVF   xC2,F
2B98:  BNZ   2BA8
2B9A:  MOVF   xC1,F
2B9C:  BNZ   2BA8
2B9E:  MOVF   xC0,F
2BA0:  BNZ   2BA8
2BA2:  MOVF   xBF,W
2BA4:  SUBLW  05
2BA6:  BC    2C08
2BA8:  MOVF   xC2,F
2BAA:  BNZ   2C08
2BAC:  MOVF   xC1,F
2BAE:  BNZ   2C08
2BB0:  MOVF   xC0,F
2BB2:  BNZ   2C08
2BB4:  MOVF   xBF,W
2BB6:  SUBLW  3B
2BB8:  BNC   2C08
2BBA:  MOVF   xBE,F
2BBC:  BNZ   2BCC
2BBE:  MOVF   xBD,F
2BC0:  BNZ   2BCC
2BC2:  MOVF   xBC,F
2BC4:  BNZ   2BCC
2BC6:  MOVF   xBB,W
2BC8:  SUBLW  64
2BCA:  BC    2C08
2BCC:  MOVF   xC6,F
2BCE:  BNZ   2BDE
2BD0:  MOVF   xC5,F
2BD2:  BNZ   2BDE
2BD4:  MOVF   xC4,F
2BD6:  BNZ   2BDE
2BD8:  MOVF   xC3,W
2BDA:  SUBLW  64
2BDC:  BC    2C08
2BDE:  MOVF   xCA,F
2BE0:  BNZ   2BF0
2BE2:  MOVF   xC9,F
2BE4:  BNZ   2BF0
2BE6:  MOVF   xC8,F
2BE8:  BNZ   2BF0
2BEA:  MOVF   xC7,W
2BEC:  SUBLW  64
2BEE:  BC    2C08
2BF0:  MOVF   xCE,F
2BF2:  BNZ   2C02
2BF4:  MOVF   xCD,F
2BF6:  BNZ   2C02
2BF8:  MOVF   xCC,F
2BFA:  BNZ   2C02
2BFC:  MOVF   xCB,W
2BFE:  SUBLW  64
2C00:  BC    2C08
2C02:  MOVLW  01
2C04:  MOVWF  01
2C06:  BRA    2E14
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
2C08:  MOVF   xC6,F
2C0A:  BNZ   2C1A
2C0C:  MOVF   xC5,F
2C0E:  BNZ   2C1A
2C10:  MOVF   xC4,F
2C12:  BNZ   2C1A
2C14:  MOVF   xC3,W
2C16:  SUBLW  05
2C18:  BC    2C7A
2C1A:  MOVF   xC6,F
2C1C:  BNZ   2C7A
2C1E:  MOVF   xC5,F
2C20:  BNZ   2C7A
2C22:  MOVF   xC4,F
2C24:  BNZ   2C7A
2C26:  MOVF   xC3,W
2C28:  SUBLW  3B
2C2A:  BNC   2C7A
2C2C:  MOVF   xC2,F
2C2E:  BNZ   2C3E
2C30:  MOVF   xC1,F
2C32:  BNZ   2C3E
2C34:  MOVF   xC0,F
2C36:  BNZ   2C3E
2C38:  MOVF   xBF,W
2C3A:  SUBLW  64
2C3C:  BC    2C7A
2C3E:  MOVF   xBE,F
2C40:  BNZ   2C50
2C42:  MOVF   xBD,F
2C44:  BNZ   2C50
2C46:  MOVF   xBC,F
2C48:  BNZ   2C50
2C4A:  MOVF   xBB,W
2C4C:  SUBLW  64
2C4E:  BC    2C7A
2C50:  MOVF   xCA,F
2C52:  BNZ   2C62
2C54:  MOVF   xC9,F
2C56:  BNZ   2C62
2C58:  MOVF   xC8,F
2C5A:  BNZ   2C62
2C5C:  MOVF   xC7,W
2C5E:  SUBLW  64
2C60:  BC    2C7A
2C62:  MOVF   xCE,F
2C64:  BNZ   2C74
2C66:  MOVF   xCD,F
2C68:  BNZ   2C74
2C6A:  MOVF   xCC,F
2C6C:  BNZ   2C74
2C6E:  MOVF   xCB,W
2C70:  SUBLW  64
2C72:  BC    2C7A
2C74:  MOVLW  02
2C76:  MOVWF  01
2C78:  BRA    2E14
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2C7A:  MOVF   xCA,F
2C7C:  BNZ   2C8C
2C7E:  MOVF   xC9,F
2C80:  BNZ   2C8C
2C82:  MOVF   xC8,F
2C84:  BNZ   2C8C
2C86:  MOVF   xC7,W
2C88:  SUBLW  05
2C8A:  BC    2CEC
2C8C:  MOVF   xCA,F
2C8E:  BNZ   2CEC
2C90:  MOVF   xC9,F
2C92:  BNZ   2CEC
2C94:  MOVF   xC8,F
2C96:  BNZ   2CEC
2C98:  MOVF   xC7,W
2C9A:  SUBLW  3B
2C9C:  BNC   2CEC
2C9E:  MOVF   xC2,F
2CA0:  BNZ   2CB0
2CA2:  MOVF   xC1,F
2CA4:  BNZ   2CB0
2CA6:  MOVF   xC0,F
2CA8:  BNZ   2CB0
2CAA:  MOVF   xBF,W
2CAC:  SUBLW  64
2CAE:  BC    2CEC
2CB0:  MOVF   xC6,F
2CB2:  BNZ   2CC2
2CB4:  MOVF   xC5,F
2CB6:  BNZ   2CC2
2CB8:  MOVF   xC4,F
2CBA:  BNZ   2CC2
2CBC:  MOVF   xC3,W
2CBE:  SUBLW  64
2CC0:  BC    2CEC
2CC2:  MOVF   xBE,F
2CC4:  BNZ   2CD4
2CC6:  MOVF   xBD,F
2CC8:  BNZ   2CD4
2CCA:  MOVF   xBC,F
2CCC:  BNZ   2CD4
2CCE:  MOVF   xBB,W
2CD0:  SUBLW  64
2CD2:  BC    2CEC
2CD4:  MOVF   xCE,F
2CD6:  BNZ   2CE6
2CD8:  MOVF   xCD,F
2CDA:  BNZ   2CE6
2CDC:  MOVF   xCC,F
2CDE:  BNZ   2CE6
2CE0:  MOVF   xCB,W
2CE2:  SUBLW  64
2CE4:  BC    2CEC
2CE6:  MOVLW  03
2CE8:  MOVWF  01
2CEA:  BRA    2E14
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2CEC:  MOVF   xCE,F
2CEE:  BNZ   2CFE
2CF0:  MOVF   xCD,F
2CF2:  BNZ   2CFE
2CF4:  MOVF   xCC,F
2CF6:  BNZ   2CFE
2CF8:  MOVF   xCB,W
2CFA:  SUBLW  05
2CFC:  BC    2D5E
2CFE:  MOVF   xCE,F
2D00:  BNZ   2D5E
2D02:  MOVF   xCD,F
2D04:  BNZ   2D5E
2D06:  MOVF   xCC,F
2D08:  BNZ   2D5E
2D0A:  MOVF   xCB,W
2D0C:  SUBLW  3B
2D0E:  BNC   2D5E
2D10:  MOVF   xC2,F
2D12:  BNZ   2D22
2D14:  MOVF   xC1,F
2D16:  BNZ   2D22
2D18:  MOVF   xC0,F
2D1A:  BNZ   2D22
2D1C:  MOVF   xBF,W
2D1E:  SUBLW  64
2D20:  BC    2D5E
2D22:  MOVF   xC6,F
2D24:  BNZ   2D34
2D26:  MOVF   xC5,F
2D28:  BNZ   2D34
2D2A:  MOVF   xC4,F
2D2C:  BNZ   2D34
2D2E:  MOVF   xC3,W
2D30:  SUBLW  64
2D32:  BC    2D5E
2D34:  MOVF   xCA,F
2D36:  BNZ   2D46
2D38:  MOVF   xC9,F
2D3A:  BNZ   2D46
2D3C:  MOVF   xC8,F
2D3E:  BNZ   2D46
2D40:  MOVF   xC7,W
2D42:  SUBLW  64
2D44:  BC    2D5E
2D46:  MOVF   xBE,F
2D48:  BNZ   2D58
2D4A:  MOVF   xBD,F
2D4C:  BNZ   2D58
2D4E:  MOVF   xBC,F
2D50:  BNZ   2D58
2D52:  MOVF   xBB,W
2D54:  SUBLW  64
2D56:  BC    2D5E
2D58:  MOVLW  04
2D5A:  MOVWF  01
2D5C:  BRA    2E14
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2D5E:  MOVF   xCE,F
2D60:  BNZ   2D72
2D62:  MOVF   xCD,F
2D64:  BNZ   2D72
2D66:  MOVF   xCC,F
2D68:  BNZ   2D72
2D6A:  MOVF   xCB,W
2D6C:  SUBLW  C8
2D6E:  BTFSC  FD8.0
2D70:  BRA    2E10
2D72:  MOVF   xBE,F
2D74:  BTFSS  FD8.2
2D76:  BRA    2E10
2D78:  MOVF   xBD,F
2D7A:  BTFSS  FD8.2
2D7C:  BRA    2E10
2D7E:  MOVF   xBC,F
2D80:  BTFSS  FD8.2
2D82:  BRA    2E10
2D84:  MOVF   xBB,W
2D86:  SUBLW  B3
2D88:  BNC   2E10
2D8A:  MOVF   xBE,F
2D8C:  BNZ   2D9C
2D8E:  MOVF   xBD,F
2D90:  BNZ   2D9C
2D92:  MOVF   xBC,F
2D94:  BNZ   2D9C
2D96:  MOVF   xBB,W
2D98:  SUBLW  64
2D9A:  BC    2E10
2D9C:  MOVF   xC2,F
2D9E:  BNZ   2E10
2DA0:  MOVF   xC1,F
2DA2:  BNZ   2E10
2DA4:  MOVF   xC0,F
2DA6:  BNZ   2E10
2DA8:  MOVF   xBF,W
2DAA:  SUBLW  B3
2DAC:  BNC   2E10
2DAE:  MOVF   xC2,F
2DB0:  BNZ   2DC0
2DB2:  MOVF   xC1,F
2DB4:  BNZ   2DC0
2DB6:  MOVF   xC0,F
2DB8:  BNZ   2DC0
2DBA:  MOVF   xBF,W
2DBC:  SUBLW  64
2DBE:  BC    2E10
2DC0:  MOVF   xC6,F
2DC2:  BNZ   2E10
2DC4:  MOVF   xC5,F
2DC6:  BNZ   2E10
2DC8:  MOVF   xC4,F
2DCA:  BNZ   2E10
2DCC:  MOVF   xC3,W
2DCE:  SUBLW  B3
2DD0:  BNC   2E10
2DD2:  MOVF   xC6,F
2DD4:  BNZ   2DE4
2DD6:  MOVF   xC5,F
2DD8:  BNZ   2DE4
2DDA:  MOVF   xC4,F
2DDC:  BNZ   2DE4
2DDE:  MOVF   xC3,W
2DE0:  SUBLW  64
2DE2:  BC    2E10
2DE4:  MOVF   xCA,F
2DE6:  BNZ   2E10
2DE8:  MOVF   xC9,F
2DEA:  BNZ   2E10
2DEC:  MOVF   xC8,F
2DEE:  BNZ   2E10
2DF0:  MOVF   xC7,W
2DF2:  SUBLW  B3
2DF4:  BNC   2E10
2DF6:  MOVF   xCA,F
2DF8:  BNZ   2E08
2DFA:  MOVF   xC9,F
2DFC:  BNZ   2E08
2DFE:  MOVF   xC8,F
2E00:  BNZ   2E08
2E02:  MOVF   xC7,W
2E04:  SUBLW  64
2E06:  BC    2E10
2E08:  MOVLW  04
2E0A:  MOVWF  01
2E0C:  BRA    2E14
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2E0E:  BRA    2E14
2E10:  MOVLW  FF
2E12:  MOVWF  01
.................... } 
2E14:  MOVLB  0
2E16:  GOTO   3660 (RETURN)
.................... //=========================================== 
.................... int8 new_check_col() 
.................... { 
2E1A:  MOVLB  A
2E1C:  CLRF   xBE
2E1E:  CLRF   xBD
2E20:  CLRF   xBC
2E22:  CLRF   xBB
2E24:  CLRF   xC2
2E26:  CLRF   xC1
2E28:  CLRF   xC0
2E2A:  CLRF   xBF
2E2C:  CLRF   xC6
2E2E:  CLRF   xC5
2E30:  CLRF   xC4
2E32:  CLRF   xC3
2E34:  CLRF   xCA
2E36:  CLRF   xC9
2E38:  CLRF   xC8
2E3A:  CLRF   xC7
2E3C:  CLRF   xCE
2E3E:  CLRF   xCD
2E40:  CLRF   xCC
2E42:  CLRF   xCB
2E44:  CLRF   xD2
2E46:  CLRF   xD1
2E48:  CLRF   xD0
2E4A:  CLRF   xCF
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2E4C:  CLRF   xBA
2E4E:  CLRF   xB9
2E50:  MOVF   xBA,W
2E52:  SUBLW  01
2E54:  BNC   2EF4
2E56:  BNZ   2E5E
2E58:  MOVF   xB9,W
2E5A:  SUBLW  F3
2E5C:  BNC   2EF4
....................    { 
....................       col_0=read_col(0)+col_0; 
2E5E:  CLRF   xD3
2E60:  MOVLB  0
2E62:  CALL   258C
2E66:  MOVF   01,W
2E68:  MOVLB  A
2E6A:  ADDWF  xBB,F
2E6C:  MOVLW  00
2E6E:  ADDWFC xBC,F
2E70:  ADDWFC xBD,F
2E72:  ADDWFC xBE,F
....................       col_1=read_col(1)+col_1; 
2E74:  MOVLW  01
2E76:  MOVWF  xD3
2E78:  MOVLB  0
2E7A:  CALL   258C
2E7E:  MOVF   01,W
2E80:  MOVLB  A
2E82:  ADDWF  xBF,F
2E84:  MOVLW  00
2E86:  ADDWFC xC0,F
2E88:  ADDWFC xC1,F
2E8A:  ADDWFC xC2,F
....................       col_2=read_col(2)+col_2; 
2E8C:  MOVLW  02
2E8E:  MOVWF  xD3
2E90:  MOVLB  0
2E92:  CALL   258C
2E96:  MOVF   01,W
2E98:  MOVLB  A
2E9A:  ADDWF  xC3,F
2E9C:  MOVLW  00
2E9E:  ADDWFC xC4,F
2EA0:  ADDWFC xC5,F
2EA2:  ADDWFC xC6,F
....................       col_3=read_col(3)+col_3; 
2EA4:  MOVLW  03
2EA6:  MOVWF  xD3
2EA8:  MOVLB  0
2EAA:  CALL   258C
2EAE:  MOVF   01,W
2EB0:  MOVLB  A
2EB2:  ADDWF  xC7,F
2EB4:  MOVLW  00
2EB6:  ADDWFC xC8,F
2EB8:  ADDWFC xC9,F
2EBA:  ADDWFC xCA,F
....................       col_4=read_col(4)+col_4; 
2EBC:  MOVLW  04
2EBE:  MOVWF  xD3
2EC0:  MOVLB  0
2EC2:  CALL   258C
2EC6:  MOVF   01,W
2EC8:  MOVLB  A
2ECA:  ADDWF  xCB,F
2ECC:  MOVLW  00
2ECE:  ADDWFC xCC,F
2ED0:  ADDWFC xCD,F
2ED2:  ADDWFC xCE,F
....................       col_5=read_col(5)+col_5; 
2ED4:  MOVLW  05
2ED6:  MOVWF  xD3
2ED8:  MOVLB  0
2EDA:  CALL   258C
2EDE:  MOVF   01,W
2EE0:  MOVLB  A
2EE2:  ADDWF  xCF,F
2EE4:  MOVLW  00
2EE6:  ADDWFC xD0,F
2EE8:  ADDWFC xD1,F
2EEA:  ADDWFC xD2,F
....................    } 
2EEC:  INCF   xB9,F
2EEE:  BTFSC  FD8.2
2EF0:  INCF   xBA,F
2EF2:  BRA    2E50
....................    col_0=col_0/500; 
2EF4:  BCF    FD8.1
2EF6:  MOVFF  ABE,AE2
2EFA:  MOVFF  ABD,AE1
2EFE:  MOVFF  ABC,AE0
2F02:  MOVFF  ABB,ADF
2F06:  CLRF   xE6
2F08:  CLRF   xE5
2F0A:  MOVLW  01
2F0C:  MOVWF  xE4
2F0E:  MOVLW  F4
2F10:  MOVWF  xE3
2F12:  MOVLB  0
2F14:  CALL   269A
2F18:  MOVFF  03,ABE
2F1C:  MOVFF  02,ABD
2F20:  MOVFF  01,ABC
2F24:  MOVFF  00,ABB
....................    col_1=col_1/500; 
2F28:  BCF    FD8.1
2F2A:  MOVFF  AC2,AE2
2F2E:  MOVFF  AC1,AE1
2F32:  MOVFF  AC0,AE0
2F36:  MOVFF  ABF,ADF
2F3A:  MOVLB  A
2F3C:  CLRF   xE6
2F3E:  CLRF   xE5
2F40:  MOVLW  01
2F42:  MOVWF  xE4
2F44:  MOVLW  F4
2F46:  MOVWF  xE3
2F48:  MOVLB  0
2F4A:  CALL   269A
2F4E:  MOVFF  03,AC2
2F52:  MOVFF  02,AC1
2F56:  MOVFF  01,AC0
2F5A:  MOVFF  00,ABF
....................    col_2=col_2/500; 
2F5E:  BCF    FD8.1
2F60:  MOVFF  AC6,AE2
2F64:  MOVFF  AC5,AE1
2F68:  MOVFF  AC4,AE0
2F6C:  MOVFF  AC3,ADF
2F70:  MOVLB  A
2F72:  CLRF   xE6
2F74:  CLRF   xE5
2F76:  MOVLW  01
2F78:  MOVWF  xE4
2F7A:  MOVLW  F4
2F7C:  MOVWF  xE3
2F7E:  MOVLB  0
2F80:  CALL   269A
2F84:  MOVFF  03,AC6
2F88:  MOVFF  02,AC5
2F8C:  MOVFF  01,AC4
2F90:  MOVFF  00,AC3
....................    col_3=col_3/500; 
2F94:  BCF    FD8.1
2F96:  MOVFF  ACA,AE2
2F9A:  MOVFF  AC9,AE1
2F9E:  MOVFF  AC8,AE0
2FA2:  MOVFF  AC7,ADF
2FA6:  MOVLB  A
2FA8:  CLRF   xE6
2FAA:  CLRF   xE5
2FAC:  MOVLW  01
2FAE:  MOVWF  xE4
2FB0:  MOVLW  F4
2FB2:  MOVWF  xE3
2FB4:  MOVLB  0
2FB6:  CALL   269A
2FBA:  MOVFF  03,ACA
2FBE:  MOVFF  02,AC9
2FC2:  MOVFF  01,AC8
2FC6:  MOVFF  00,AC7
....................    col_4=col_4/500; 
2FCA:  BCF    FD8.1
2FCC:  MOVFF  ACE,AE2
2FD0:  MOVFF  ACD,AE1
2FD4:  MOVFF  ACC,AE0
2FD8:  MOVFF  ACB,ADF
2FDC:  MOVLB  A
2FDE:  CLRF   xE6
2FE0:  CLRF   xE5
2FE2:  MOVLW  01
2FE4:  MOVWF  xE4
2FE6:  MOVLW  F4
2FE8:  MOVWF  xE3
2FEA:  MOVLB  0
2FEC:  CALL   269A
2FF0:  MOVFF  03,ACE
2FF4:  MOVFF  02,ACD
2FF8:  MOVFF  01,ACC
2FFC:  MOVFF  00,ACB
....................    col_5=col_5/500; 
3000:  BCF    FD8.1
3002:  MOVFF  AD2,AE2
3006:  MOVFF  AD1,AE1
300A:  MOVFF  AD0,AE0
300E:  MOVFF  ACF,ADF
3012:  MOVLB  A
3014:  CLRF   xE6
3016:  CLRF   xE5
3018:  MOVLW  01
301A:  MOVWF  xE4
301C:  MOVLW  F4
301E:  MOVWF  xE3
3020:  MOVLB  0
3022:  CALL   269A
3026:  MOVFF  03,AD2
302A:  MOVFF  02,AD1
302E:  MOVFF  01,AD0
3032:  MOVFF  00,ACF
....................    if(keydebug_en) 
3036:  MOVLB  1
3038:  MOVF   x0B,F
303A:  BTFSC  FD8.2
303C:  BRA    3206
....................    { 
....................       fprintf(COM2,"\r\n");      
303E:  MOVLW  0D
3040:  MOVLB  A
3042:  MOVWF  xDF
3044:  MOVLB  0
3046:  CALL   075A
304A:  MOVLW  0A
304C:  MOVLB  A
304E:  MOVWF  xDF
3050:  MOVLB  0
3052:  CALL   075A
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
3056:  MOVLW  6C
3058:  MOVWF  FF6
305A:  MOVLW  04
305C:  MOVWF  FF7
305E:  MOVLW  07
3060:  MOVLB  A
3062:  MOVWF  xD3
3064:  MOVLB  0
3066:  CALL   1718
306A:  MOVLW  41
306C:  MOVWF  FE9
306E:  MOVFF  ABE,AD6
3072:  MOVFF  ABD,AD5
3076:  MOVFF  ABC,AD4
307A:  MOVFF  ABB,AD3
307E:  CALL   272E
3082:  MOVLW  0D
3084:  MOVLB  A
3086:  MOVWF  xDF
3088:  MOVLB  0
308A:  CALL   075A
308E:  MOVLW  0A
3090:  MOVLB  A
3092:  MOVWF  xDF
3094:  MOVLB  0
3096:  CALL   075A
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
309A:  MOVLW  7A
309C:  MOVWF  FF6
309E:  MOVLW  04
30A0:  MOVWF  FF7
30A2:  MOVLW  07
30A4:  MOVLB  A
30A6:  MOVWF  xD3
30A8:  MOVLB  0
30AA:  CALL   1718
30AE:  MOVLW  41
30B0:  MOVWF  FE9
30B2:  MOVFF  AC2,AD6
30B6:  MOVFF  AC1,AD5
30BA:  MOVFF  AC0,AD4
30BE:  MOVFF  ABF,AD3
30C2:  CALL   272E
30C6:  MOVLW  0D
30C8:  MOVLB  A
30CA:  MOVWF  xDF
30CC:  MOVLB  0
30CE:  CALL   075A
30D2:  MOVLW  0A
30D4:  MOVLB  A
30D6:  MOVWF  xDF
30D8:  MOVLB  0
30DA:  CALL   075A
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
30DE:  MOVLW  88
30E0:  MOVWF  FF6
30E2:  MOVLW  04
30E4:  MOVWF  FF7
30E6:  MOVLW  07
30E8:  MOVLB  A
30EA:  MOVWF  xD3
30EC:  MOVLB  0
30EE:  CALL   1718
30F2:  MOVLW  41
30F4:  MOVWF  FE9
30F6:  MOVFF  AC6,AD6
30FA:  MOVFF  AC5,AD5
30FE:  MOVFF  AC4,AD4
3102:  MOVFF  AC3,AD3
3106:  CALL   272E
310A:  MOVLW  0D
310C:  MOVLB  A
310E:  MOVWF  xDF
3110:  MOVLB  0
3112:  CALL   075A
3116:  MOVLW  0A
3118:  MOVLB  A
311A:  MOVWF  xDF
311C:  MOVLB  0
311E:  CALL   075A
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
3122:  MOVLW  96
3124:  MOVWF  FF6
3126:  MOVLW  04
3128:  MOVWF  FF7
312A:  MOVLW  07
312C:  MOVLB  A
312E:  MOVWF  xD3
3130:  MOVLB  0
3132:  CALL   1718
3136:  MOVLW  41
3138:  MOVWF  FE9
313A:  MOVFF  ACA,AD6
313E:  MOVFF  AC9,AD5
3142:  MOVFF  AC8,AD4
3146:  MOVFF  AC7,AD3
314A:  CALL   272E
314E:  MOVLW  0D
3150:  MOVLB  A
3152:  MOVWF  xDF
3154:  MOVLB  0
3156:  CALL   075A
315A:  MOVLW  0A
315C:  MOVLB  A
315E:  MOVWF  xDF
3160:  MOVLB  0
3162:  CALL   075A
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
3166:  MOVLW  A4
3168:  MOVWF  FF6
316A:  MOVLW  04
316C:  MOVWF  FF7
316E:  MOVLW  07
3170:  MOVLB  A
3172:  MOVWF  xD3
3174:  MOVLB  0
3176:  CALL   1718
317A:  MOVLW  41
317C:  MOVWF  FE9
317E:  MOVFF  ACE,AD6
3182:  MOVFF  ACD,AD5
3186:  MOVFF  ACC,AD4
318A:  MOVFF  ACB,AD3
318E:  CALL   272E
3192:  MOVLW  0D
3194:  MOVLB  A
3196:  MOVWF  xDF
3198:  MOVLB  0
319A:  CALL   075A
319E:  MOVLW  0A
31A0:  MOVLB  A
31A2:  MOVWF  xDF
31A4:  MOVLB  0
31A6:  CALL   075A
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
31AA:  MOVLW  B2
31AC:  MOVWF  FF6
31AE:  MOVLW  04
31B0:  MOVWF  FF7
31B2:  MOVLW  07
31B4:  MOVLB  A
31B6:  MOVWF  xD3
31B8:  MOVLB  0
31BA:  CALL   1718
31BE:  MOVLW  41
31C0:  MOVWF  FE9
31C2:  MOVFF  AD2,AD6
31C6:  MOVFF  AD1,AD5
31CA:  MOVFF  AD0,AD4
31CE:  MOVFF  ACF,AD3
31D2:  CALL   272E
31D6:  MOVLW  0D
31D8:  MOVLB  A
31DA:  MOVWF  xDF
31DC:  MOVLB  0
31DE:  CALL   075A
31E2:  MOVLW  0A
31E4:  MOVLB  A
31E6:  MOVWF  xDF
31E8:  MOVLB  0
31EA:  CALL   075A
....................       fprintf(COM2,"\r\n"); 
31EE:  MOVLW  0D
31F0:  MOVLB  A
31F2:  MOVWF  xDF
31F4:  MOVLB  0
31F6:  CALL   075A
31FA:  MOVLW  0A
31FC:  MOVLB  A
31FE:  MOVWF  xDF
3200:  MOVLB  0
3202:  CALL   075A
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
3206:  MOVLB  A
3208:  MOVF   xBE,F
320A:  BNZ   321A
320C:  MOVF   xBD,F
320E:  BNZ   321A
3210:  MOVF   xBC,F
3212:  BNZ   321A
3214:  MOVF   xBB,W
3216:  SUBLW  05
3218:  BC    328C
321A:  MOVF   xBE,F
321C:  BNZ   328C
321E:  MOVF   xBD,F
3220:  BNZ   328C
3222:  MOVF   xBC,F
3224:  BNZ   328C
3226:  MOVF   xBB,W
3228:  SUBLW  3B
322A:  BNC   328C
322C:  MOVF   xC2,F
322E:  BNZ   323E
3230:  MOVF   xC1,F
3232:  BNZ   323E
3234:  MOVF   xC0,F
3236:  BNZ   323E
3238:  MOVF   xBF,W
323A:  SUBLW  64
323C:  BC    328C
323E:  MOVF   xC6,F
3240:  BNZ   3250
3242:  MOVF   xC5,F
3244:  BNZ   3250
3246:  MOVF   xC4,F
3248:  BNZ   3250
324A:  MOVF   xC3,W
324C:  SUBLW  64
324E:  BC    328C
3250:  MOVF   xCA,F
3252:  BNZ   3262
3254:  MOVF   xC9,F
3256:  BNZ   3262
3258:  MOVF   xC8,F
325A:  BNZ   3262
325C:  MOVF   xC7,W
325E:  SUBLW  64
3260:  BC    328C
3262:  MOVF   xCE,F
3264:  BNZ   3274
3266:  MOVF   xCD,F
3268:  BNZ   3274
326A:  MOVF   xCC,F
326C:  BNZ   3274
326E:  MOVF   xCB,W
3270:  SUBLW  64
3272:  BC    328C
3274:  MOVF   xD2,F
3276:  BNZ   3286
3278:  MOVF   xD1,F
327A:  BNZ   3286
327C:  MOVF   xD0,F
327E:  BNZ   3286
3280:  MOVF   xCF,W
3282:  SUBLW  64
3284:  BC    328C
3286:  MOVLW  00
3288:  MOVWF  01
328A:  BRA    3604
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
328C:  MOVF   xC2,F
328E:  BNZ   329E
3290:  MOVF   xC1,F
3292:  BNZ   329E
3294:  MOVF   xC0,F
3296:  BNZ   329E
3298:  MOVF   xBF,W
329A:  SUBLW  05
329C:  BC    3310
329E:  MOVF   xC2,F
32A0:  BNZ   3310
32A2:  MOVF   xC1,F
32A4:  BNZ   3310
32A6:  MOVF   xC0,F
32A8:  BNZ   3310
32AA:  MOVF   xBF,W
32AC:  SUBLW  3B
32AE:  BNC   3310
32B0:  MOVF   xBE,F
32B2:  BNZ   32C2
32B4:  MOVF   xBD,F
32B6:  BNZ   32C2
32B8:  MOVF   xBC,F
32BA:  BNZ   32C2
32BC:  MOVF   xBB,W
32BE:  SUBLW  64
32C0:  BC    3310
32C2:  MOVF   xC6,F
32C4:  BNZ   32D4
32C6:  MOVF   xC5,F
32C8:  BNZ   32D4
32CA:  MOVF   xC4,F
32CC:  BNZ   32D4
32CE:  MOVF   xC3,W
32D0:  SUBLW  64
32D2:  BC    3310
32D4:  MOVF   xCA,F
32D6:  BNZ   32E6
32D8:  MOVF   xC9,F
32DA:  BNZ   32E6
32DC:  MOVF   xC8,F
32DE:  BNZ   32E6
32E0:  MOVF   xC7,W
32E2:  SUBLW  64
32E4:  BC    3310
32E6:  MOVF   xCE,F
32E8:  BNZ   32F8
32EA:  MOVF   xCD,F
32EC:  BNZ   32F8
32EE:  MOVF   xCC,F
32F0:  BNZ   32F8
32F2:  MOVF   xCB,W
32F4:  SUBLW  64
32F6:  BC    3310
32F8:  MOVF   xD2,F
32FA:  BNZ   330A
32FC:  MOVF   xD1,F
32FE:  BNZ   330A
3300:  MOVF   xD0,F
3302:  BNZ   330A
3304:  MOVF   xCF,W
3306:  SUBLW  64
3308:  BC    3310
330A:  MOVLW  01
330C:  MOVWF  01
330E:  BRA    3604
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
3310:  MOVF   xC6,F
3312:  BNZ   3322
3314:  MOVF   xC5,F
3316:  BNZ   3322
3318:  MOVF   xC4,F
331A:  BNZ   3322
331C:  MOVF   xC3,W
331E:  SUBLW  05
3320:  BC    3394
3322:  MOVF   xC6,F
3324:  BNZ   3394
3326:  MOVF   xC5,F
3328:  BNZ   3394
332A:  MOVF   xC4,F
332C:  BNZ   3394
332E:  MOVF   xC3,W
3330:  SUBLW  3B
3332:  BNC   3394
3334:  MOVF   xC2,F
3336:  BNZ   3346
3338:  MOVF   xC1,F
333A:  BNZ   3346
333C:  MOVF   xC0,F
333E:  BNZ   3346
3340:  MOVF   xBF,W
3342:  SUBLW  64
3344:  BC    3394
3346:  MOVF   xBE,F
3348:  BNZ   3358
334A:  MOVF   xBD,F
334C:  BNZ   3358
334E:  MOVF   xBC,F
3350:  BNZ   3358
3352:  MOVF   xBB,W
3354:  SUBLW  64
3356:  BC    3394
3358:  MOVF   xCA,F
335A:  BNZ   336A
335C:  MOVF   xC9,F
335E:  BNZ   336A
3360:  MOVF   xC8,F
3362:  BNZ   336A
3364:  MOVF   xC7,W
3366:  SUBLW  64
3368:  BC    3394
336A:  MOVF   xCE,F
336C:  BNZ   337C
336E:  MOVF   xCD,F
3370:  BNZ   337C
3372:  MOVF   xCC,F
3374:  BNZ   337C
3376:  MOVF   xCB,W
3378:  SUBLW  64
337A:  BC    3394
337C:  MOVF   xD2,F
337E:  BNZ   338E
3380:  MOVF   xD1,F
3382:  BNZ   338E
3384:  MOVF   xD0,F
3386:  BNZ   338E
3388:  MOVF   xCF,W
338A:  SUBLW  64
338C:  BC    3394
338E:  MOVLW  02
3390:  MOVWF  01
3392:  BRA    3604
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
3394:  MOVF   xCA,F
3396:  BNZ   33A6
3398:  MOVF   xC9,F
339A:  BNZ   33A6
339C:  MOVF   xC8,F
339E:  BNZ   33A6
33A0:  MOVF   xC7,W
33A2:  SUBLW  05
33A4:  BC    3418
33A6:  MOVF   xCA,F
33A8:  BNZ   3418
33AA:  MOVF   xC9,F
33AC:  BNZ   3418
33AE:  MOVF   xC8,F
33B0:  BNZ   3418
33B2:  MOVF   xC7,W
33B4:  SUBLW  3B
33B6:  BNC   3418
33B8:  MOVF   xC2,F
33BA:  BNZ   33CA
33BC:  MOVF   xC1,F
33BE:  BNZ   33CA
33C0:  MOVF   xC0,F
33C2:  BNZ   33CA
33C4:  MOVF   xBF,W
33C6:  SUBLW  64
33C8:  BC    3418
33CA:  MOVF   xC6,F
33CC:  BNZ   33DC
33CE:  MOVF   xC5,F
33D0:  BNZ   33DC
33D2:  MOVF   xC4,F
33D4:  BNZ   33DC
33D6:  MOVF   xC3,W
33D8:  SUBLW  64
33DA:  BC    3418
33DC:  MOVF   xBE,F
33DE:  BNZ   33EE
33E0:  MOVF   xBD,F
33E2:  BNZ   33EE
33E4:  MOVF   xBC,F
33E6:  BNZ   33EE
33E8:  MOVF   xBB,W
33EA:  SUBLW  64
33EC:  BC    3418
33EE:  MOVF   xCE,F
33F0:  BNZ   3400
33F2:  MOVF   xCD,F
33F4:  BNZ   3400
33F6:  MOVF   xCC,F
33F8:  BNZ   3400
33FA:  MOVF   xCB,W
33FC:  SUBLW  64
33FE:  BC    3418
3400:  MOVF   xD2,F
3402:  BNZ   3412
3404:  MOVF   xD1,F
3406:  BNZ   3412
3408:  MOVF   xD0,F
340A:  BNZ   3412
340C:  MOVF   xCF,W
340E:  SUBLW  64
3410:  BC    3418
3412:  MOVLW  03
3414:  MOVWF  01
3416:  BRA    3604
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
3418:  MOVF   xCE,F
341A:  BNZ   342A
341C:  MOVF   xCD,F
341E:  BNZ   342A
3420:  MOVF   xCC,F
3422:  BNZ   342A
3424:  MOVF   xCB,W
3426:  SUBLW  05
3428:  BC    349C
342A:  MOVF   xCE,F
342C:  BNZ   349C
342E:  MOVF   xCD,F
3430:  BNZ   349C
3432:  MOVF   xCC,F
3434:  BNZ   349C
3436:  MOVF   xCB,W
3438:  SUBLW  3B
343A:  BNC   349C
343C:  MOVF   xC2,F
343E:  BNZ   344E
3440:  MOVF   xC1,F
3442:  BNZ   344E
3444:  MOVF   xC0,F
3446:  BNZ   344E
3448:  MOVF   xBF,W
344A:  SUBLW  64
344C:  BC    349C
344E:  MOVF   xC6,F
3450:  BNZ   3460
3452:  MOVF   xC5,F
3454:  BNZ   3460
3456:  MOVF   xC4,F
3458:  BNZ   3460
345A:  MOVF   xC3,W
345C:  SUBLW  64
345E:  BC    349C
3460:  MOVF   xCA,F
3462:  BNZ   3472
3464:  MOVF   xC9,F
3466:  BNZ   3472
3468:  MOVF   xC8,F
346A:  BNZ   3472
346C:  MOVF   xC7,W
346E:  SUBLW  64
3470:  BC    349C
3472:  MOVF   xBE,F
3474:  BNZ   3484
3476:  MOVF   xBD,F
3478:  BNZ   3484
347A:  MOVF   xBC,F
347C:  BNZ   3484
347E:  MOVF   xBB,W
3480:  SUBLW  64
3482:  BC    349C
3484:  MOVF   xD2,F
3486:  BNZ   3496
3488:  MOVF   xD1,F
348A:  BNZ   3496
348C:  MOVF   xD0,F
348E:  BNZ   3496
3490:  MOVF   xCF,W
3492:  SUBLW  64
3494:  BC    349C
3496:  MOVLW  04
3498:  MOVWF  01
349A:  BRA    3604
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
349C:  MOVF   xD2,F
349E:  BNZ   34AE
34A0:  MOVF   xD1,F
34A2:  BNZ   34AE
34A4:  MOVF   xD0,F
34A6:  BNZ   34AE
34A8:  MOVF   xCF,W
34AA:  SUBLW  05
34AC:  BC    3520
34AE:  MOVF   xD2,F
34B0:  BNZ   3520
34B2:  MOVF   xD1,F
34B4:  BNZ   3520
34B6:  MOVF   xD0,F
34B8:  BNZ   3520
34BA:  MOVF   xCF,W
34BC:  SUBLW  3B
34BE:  BNC   3520
34C0:  MOVF   xC2,F
34C2:  BNZ   34D2
34C4:  MOVF   xC1,F
34C6:  BNZ   34D2
34C8:  MOVF   xC0,F
34CA:  BNZ   34D2
34CC:  MOVF   xBF,W
34CE:  SUBLW  64
34D0:  BC    3520
34D2:  MOVF   xC6,F
34D4:  BNZ   34E4
34D6:  MOVF   xC5,F
34D8:  BNZ   34E4
34DA:  MOVF   xC4,F
34DC:  BNZ   34E4
34DE:  MOVF   xC3,W
34E0:  SUBLW  64
34E2:  BC    3520
34E4:  MOVF   xCA,F
34E6:  BNZ   34F6
34E8:  MOVF   xC9,F
34EA:  BNZ   34F6
34EC:  MOVF   xC8,F
34EE:  BNZ   34F6
34F0:  MOVF   xC7,W
34F2:  SUBLW  64
34F4:  BC    3520
34F6:  MOVF   xCE,F
34F8:  BNZ   3508
34FA:  MOVF   xCD,F
34FC:  BNZ   3508
34FE:  MOVF   xCC,F
3500:  BNZ   3508
3502:  MOVF   xCB,W
3504:  SUBLW  64
3506:  BC    3520
3508:  MOVF   xBE,F
350A:  BNZ   351A
350C:  MOVF   xBD,F
350E:  BNZ   351A
3510:  MOVF   xBC,F
3512:  BNZ   351A
3514:  MOVF   xBB,W
3516:  SUBLW  64
3518:  BC    3520
351A:  MOVLW  05
351C:  MOVWF  01
351E:  BRA    3604
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
3520:  MOVF   xD2,F
3522:  BNZ   3534
3524:  MOVF   xD1,F
3526:  BNZ   3534
3528:  MOVF   xD0,F
352A:  BNZ   3534
352C:  MOVF   xCF,W
352E:  SUBLW  C8
3530:  BTFSC  FD8.0
3532:  BRA    3600
3534:  MOVF   xBE,F
3536:  BTFSS  FD8.2
3538:  BRA    3600
353A:  MOVF   xBD,F
353C:  BTFSS  FD8.2
353E:  BRA    3600
3540:  MOVF   xBC,F
3542:  BTFSS  FD8.2
3544:  BRA    3600
3546:  MOVF   xBB,W
3548:  SUBLW  B3
354A:  BTFSS  FD8.0
354C:  BRA    3600
354E:  MOVF   xBE,F
3550:  BNZ   3562
3552:  MOVF   xBD,F
3554:  BNZ   3562
3556:  MOVF   xBC,F
3558:  BNZ   3562
355A:  MOVF   xBB,W
355C:  SUBLW  64
355E:  BTFSC  FD8.0
3560:  BRA    3600
3562:  MOVF   xC2,F
3564:  BTFSS  FD8.2
3566:  BRA    3600
3568:  MOVF   xC1,F
356A:  BTFSS  FD8.2
356C:  BRA    3600
356E:  MOVF   xC0,F
3570:  BTFSS  FD8.2
3572:  BRA    3600
3574:  MOVF   xBF,W
3576:  SUBLW  B3
3578:  BNC   3600
357A:  MOVF   xC2,F
357C:  BNZ   358C
357E:  MOVF   xC1,F
3580:  BNZ   358C
3582:  MOVF   xC0,F
3584:  BNZ   358C
3586:  MOVF   xBF,W
3588:  SUBLW  64
358A:  BC    3600
358C:  MOVF   xC6,F
358E:  BNZ   3600
3590:  MOVF   xC5,F
3592:  BNZ   3600
3594:  MOVF   xC4,F
3596:  BNZ   3600
3598:  MOVF   xC3,W
359A:  SUBLW  B3
359C:  BNC   3600
359E:  MOVF   xC6,F
35A0:  BNZ   35B0
35A2:  MOVF   xC5,F
35A4:  BNZ   35B0
35A6:  MOVF   xC4,F
35A8:  BNZ   35B0
35AA:  MOVF   xC3,W
35AC:  SUBLW  64
35AE:  BC    3600
35B0:  MOVF   xCA,F
35B2:  BNZ   3600
35B4:  MOVF   xC9,F
35B6:  BNZ   3600
35B8:  MOVF   xC8,F
35BA:  BNZ   3600
35BC:  MOVF   xC7,W
35BE:  SUBLW  B3
35C0:  BNC   3600
35C2:  MOVF   xCA,F
35C4:  BNZ   35D4
35C6:  MOVF   xC9,F
35C8:  BNZ   35D4
35CA:  MOVF   xC8,F
35CC:  BNZ   35D4
35CE:  MOVF   xC7,W
35D0:  SUBLW  64
35D2:  BC    3600
35D4:  MOVF   xCE,F
35D6:  BNZ   3600
35D8:  MOVF   xCD,F
35DA:  BNZ   3600
35DC:  MOVF   xCC,F
35DE:  BNZ   3600
35E0:  MOVF   xCB,W
35E2:  SUBLW  B3
35E4:  BNC   3600
35E6:  MOVF   xCE,F
35E8:  BNZ   35F8
35EA:  MOVF   xCD,F
35EC:  BNZ   35F8
35EE:  MOVF   xCC,F
35F0:  BNZ   35F8
35F2:  MOVF   xCB,W
35F4:  SUBLW  64
35F6:  BC    3600
35F8:  MOVLW  05
35FA:  MOVWF  01
35FC:  BRA    3604
....................    else return 0xff; 
35FE:  BRA    3604
3600:  MOVLW  FF
3602:  MOVWF  01
.................... } 
3604:  MOVLB  0
3606:  GOTO   366C (RETURN)
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
360A:  MOVLW  20
360C:  MOVLB  A
360E:  MOVWF  xB7
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
3610:  BSF    F93.4
3612:  BTFSS  F81.4
3614:  BRA    3628
3616:  BSF    F93.5
3618:  BTFSS  F81.5
361A:  BRA    3628
361C:  BSF    F93.6
361E:  BTFSS  F81.6
3620:  BRA    3628
3622:  BSF    F93.7
3624:  BTFSC  F81.7
3626:  BRA    3792
....................     { 
....................        if(input(ROW0)==0) 
3628:  BSF    F93.4
362A:  BTFSC  F81.4
362C:  BRA    3632
....................          row=0; 
362E:  CLRF   xB8
....................        else if(input(ROW1)==0) 
3630:  BRA    3654
3632:  BSF    F93.5
3634:  BTFSC  F81.5
3636:  BRA    363E
....................          row=1; 
3638:  MOVLW  01
363A:  MOVWF  xB8
....................        else if(input(ROW2)==0) 
363C:  BRA    3654
363E:  BSF    F93.6
3640:  BTFSC  F81.6
3642:  BRA    364A
....................          row=2; 
3644:  MOVLW  02
3646:  MOVWF  xB8
....................        else if(input(ROW3)==0) 
3648:  BRA    3654
364A:  BSF    F93.7
364C:  BTFSC  F81.7
364E:  BRA    3654
....................          row=3;      
3650:  MOVLW  03
3652:  MOVWF  xB8
....................        if(type_KB==0)col=check_col(); 
3654:  MOVLB  1
3656:  MOVF   x13,F
3658:  BNZ   3666
365A:  MOVLB  0
365C:  GOTO   27EE
3660:  MOVFF  01,AB6
....................          else col=new_check_col(); 
3664:  BRA    3670
3666:  MOVLB  0
3668:  GOTO   2E1A
366C:  MOVFF  01,AB6
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
3670:  MOVLB  A
3672:  INCFSZ xB6,W
3674:  BRA    3678
3676:  BRA    3762
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
3678:  MOVLB  1
367A:  MOVF   x13,F
367C:  BNZ   36A4
367E:  MOVLB  A
3680:  MOVF   xB8,W
3682:  MULLW  05
3684:  MOVF   FF3,W
3686:  CLRF   xBA
3688:  MOVWF  xB9
368A:  CLRF   03
368C:  MOVF   xB6,W
368E:  ADDWF  xB9,W
3690:  MOVWF  01
3692:  MOVF   xBA,W
3694:  ADDWFC 03,F
3696:  MOVF   01,W
3698:  MOVLB  0
369A:  CALL   00E8
369E:  MOVFF  FE8,AB7
....................            else kchar =newKEYS[row][col]; 
36A2:  BRA    36C8
36A4:  MOVLB  A
36A6:  MOVF   xB8,W
36A8:  MULLW  06
36AA:  MOVF   FF3,W
36AC:  CLRF   xBA
36AE:  MOVWF  xB9
36B0:  CLRF   03
36B2:  MOVF   xB6,W
36B4:  ADDWF  xB9,W
36B6:  MOVWF  01
36B8:  MOVF   xBA,W
36BA:  ADDWFC 03,F
36BC:  MOVF   01,W
36BE:  MOVLB  0
36C0:  CALL   010C
36C4:  MOVFF  FE8,AB7
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
36C8:  MOVLB  1
36CA:  MOVF   x0B,F
36CC:  BNZ   3754
....................             { 
....................               charac_timeout=0; 
36CE:  MOVLB  0
36D0:  CLRF   xFC
36D2:  CLRF   xFB
....................                if(key_count_ms<20)key_data[key_count_ms++]=kchar; 
36D4:  MOVLB  1
36D6:  MOVF   x0E,W
36D8:  SUBLW  13
36DA:  BNC   36F0
36DC:  MOVF   x0E,W
36DE:  INCF   x0E,F
36E0:  CLRF   03
36E2:  ADDLW  14
36E4:  MOVWF  FE9
36E6:  MOVLW  01
36E8:  ADDWFC 03,W
36EA:  MOVWF  FEA
36EC:  MOVFF  AB7,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
36F0:  MOVLW  C0
36F2:  MOVWF  FF6
36F4:  MOVLW  04
36F6:  MOVWF  FF7
36F8:  MOVLW  09
36FA:  MOVLB  A
36FC:  MOVWF  xD3
36FE:  MOVLB  0
3700:  CALL   1718
3704:  MOVFF  10E,ABF
3708:  MOVLW  18
370A:  MOVLB  A
370C:  MOVWF  xC0
370E:  MOVLB  0
3710:  CALL   182C
3714:  MOVLW  5D
3716:  MOVLB  A
3718:  MOVWF  xDF
371A:  MOVLB  0
371C:  CALL   075A
3720:  MOVLW  20
3722:  MOVLB  A
3724:  MOVWF  xDF
3726:  MOVLB  0
3728:  CALL   075A
372C:  MOVFF  AB7,ADF
3730:  CALL   075A
3734:  MOVLW  0D
3736:  MOVLB  A
3738:  MOVWF  xDF
373A:  MOVLB  0
373C:  CALL   075A
3740:  MOVLW  0A
3742:  MOVLB  A
3744:  MOVWF  xDF
3746:  MOVLB  0
3748:  CALL   075A
....................                count_checking=0; 
374C:  MOVLB  1
374E:  CLRF   x07
3750:  CLRF   x06
....................             } 
....................                else fputc(kchar,COM2); 
3752:  BRA    3760
3754:  MOVFF  AB7,ADF
3758:  MOVLB  0
375A:  CALL   075A
375E:  MOVLB  1
3760:  MOVLB  A
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3762:  BSF    F93.4
3764:  BTFSS  F81.4
3766:  BRA    3762
3768:  BSF    F93.5
376A:  BTFSS  F81.5
376C:  BRA    3762
376E:  BSF    F93.6
3770:  BTFSS  F81.6
3772:  BRA    3762
3774:  BSF    F93.7
3776:  BTFSS  F81.7
3778:  BRA    3762
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
377A:  BSF    F93.4
377C:  BTFSS  F81.4
377E:  BRA    377A
3780:  BSF    F93.5
3782:  BTFSS  F81.5
3784:  BRA    377A
3786:  BSF    F93.6
3788:  BTFSS  F81.6
378A:  BRA    377A
378C:  BSF    F93.7
378E:  BTFSS  F81.7
3790:  BRA    377A
....................     } 
....................   set_tris_a(0xff);     
3792:  MOVLW  FF
3794:  MOVWF  F92
....................   return(kchar); 
3796:  MOVFF  AB7,01
.................... }//*/ 
379A:  MOVLB  0
379C:  RETURN 0
.................... //============================================ 
....................  
.................... //=========================== 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
4488:  MOVF   27,F
448A:  BTFSS  FD8.2
448C:  BRA    45D8
448E:  MOVF   26,F
4490:  BTFSS  FD8.2
4492:  BRA    45D8
4494:  MOVF   25,W
4496:  SUBLW  FF
4498:  BTFSS  FD8.0
449A:  BRA    45D8
449C:  BNZ   44A6
449E:  MOVF   24,W
44A0:  SUBLW  FE
44A2:  BTFSS  FD8.0
44A4:  BRA    45D8
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
44A6:  MOVLB  1
44A8:  MOVF   x14,F
44AA:  BNZ   44B0
44AC:  MOVF   x0E,F
44AE:  BZ    4586
....................       { 
....................          temp=get_countcard(); 
44B0:  MOVLB  0
44B2:  CALL   39F0
44B6:  MOVFF  02,AB8
44BA:  MOVFF  01,AB7
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
44BE:  MOVFF  AB8,ABC
44C2:  MOVFF  AB7,ABB
44C6:  MOVLB  A
44C8:  CLRF   xBE
44CA:  MOVLW  32
44CC:  MOVWF  xBD
44CE:  MOVLB  0
44D0:  CALL   3A40
44D4:  MOVFF  02,ABA
44D8:  MOVFF  01,AB9
44DC:  MOVLW  46
44DE:  MOVLB  A
44E0:  ADDWF  xB9,F
44E2:  MOVLW  AA
44E4:  ADDWFC xBA,F
44E6:  MOVLW  01
44E8:  ADDWF  xB9,W
44EA:  MOVWF  01
44EC:  MOVLW  00
44EE:  ADDWFC xBA,W
44F0:  MOVFF  01,24
44F4:  MOVWF  25
44F6:  CLRF   26
44F8:  CLRF   27
....................          for(i=0;i<key_numbyte-5;i++) 
44FA:  CLRF   xB6
44FC:  MOVF   xB6,W
44FE:  SUBLW  2C
4500:  BNC   455C
....................          { 
....................             temp=key_data[i]; 
4502:  CLRF   03
4504:  MOVF   xB6,W
4506:  ADDLW  14
4508:  MOVWF  FE9
450A:  MOVLW  01
450C:  ADDWFC 03,W
450E:  MOVWF  FEA
4510:  CLRF   xB8
4512:  MOVFF  FEF,AB7
....................             write_ext_eeprom((long int)ptr_card_key++,temp); 
4516:  MOVFF  27,03
451A:  MOVFF  26,02
451E:  MOVFF  25,01
4522:  MOVFF  24,00
4526:  MOVLW  01
4528:  ADDWF  24,F
452A:  BTFSC  FD8.0
452C:  INCF   25,F
452E:  BTFSC  FD8.2
4530:  INCF   26,F
4532:  BTFSC  FD8.2
4534:  INCF   27,F
4536:  MOVFF  01,ABA
453A:  MOVFF  00,AB9
453E:  MOVFF  01,AC8
4542:  MOVFF  00,AC7
4546:  MOVFF  AB7,AC9
454A:  MOVLB  0
454C:  RCALL  3E6C
....................             //delay_us(100); 
....................             fputc(temp,COM2); 
454E:  MOVFF  AB7,ADF
4552:  CALL   075A
....................          } 
4556:  MOVLB  A
4558:  INCF   xB6,F
455A:  BRA    44FC
....................          write_ext_eeprom((long int)ptr_card_key,0); 
455C:  MOVFF  25,AC8
4560:  MOVFF  24,AC7
4564:  CLRF   xC9
4566:  MOVLB  0
4568:  RCALL  3E6C
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
456A:  MOVFF  27,ABC
456E:  MOVFF  26,ABB
4572:  MOVFF  25,ABA
4576:  MOVFF  24,AB9
457A:  MOVLW  1E
457C:  MOVLB  A
457E:  MOVWF  xBD
4580:  MOVLB  0
4582:  RCALL  3F72
4584:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
4586:  CLRF   x0E
....................       del_buf(key_numbyte,key_data); 
4588:  MOVLW  32
458A:  MOVLB  A
458C:  MOVWF  xC5
458E:  MOVLW  01
4590:  MOVWF  xC7
4592:  MOVLW  14
4594:  MOVWF  xC6
4596:  MOVLB  0
4598:  CALL   3A62
....................       fprintf(COM2,"\r\n"); 
459C:  MOVLW  0D
459E:  MOVLB  A
45A0:  MOVWF  xDF
45A2:  MOVLB  0
45A4:  CALL   075A
45A8:  MOVLW  0A
45AA:  MOVLB  A
45AC:  MOVWF  xDF
45AE:  MOVLB  0
45B0:  CALL   075A
....................       fprintf(COM2,"Done PIN"); 
45B4:  MOVLW  D2
45B6:  MOVWF  FF6
45B8:  MOVLW  04
45BA:  MOVWF  FF7
45BC:  CALL   07A0
....................       fprintf(COM2,"\r\n"); 
45C0:  MOVLW  0D
45C2:  MOVLB  A
45C4:  MOVWF  xDF
45C6:  MOVLB  0
45C8:  CALL   075A
45CC:  MOVLW  0A
45CE:  MOVLB  A
45D0:  MOVWF  xDF
45D2:  MOVLB  0
45D4:  CALL   075A
....................    } 
.................... } 
45D8:  GOTO   4892 (RETURN)
.................... //=========================================== 
.................... void key_press() 
.................... { 
....................    int8 col; 
....................    int32 KB_count_timeout=0; 
....................    fprintf(COM2,"\r\n"); 
....................    fprintf(COM2,"Key"); 
....................    //fprintf(COM2,"\r\n"); 
....................    KB_count_timeout=0; 
....................    while(1) 
....................    { 
....................       
....................       if(KB_count_timeout<150000)KB_count_timeout++; 
....................       if(KB_count_timeout==150000) 
....................       { 
....................          KB_count_timeout++; 
....................           
....................          break;             
....................       }   
....................    } 
.................... } 
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
....................       c = fgetc(COM2);//getc(); 
....................       switch(c) 
....................       { 
....................          case 0x7f:    
....................             if(nbcar>0)   
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
....................                nbcar--; 
....................                fgetc(COM2);//getc(); 
....................             } 
....................             else fputc(0x07,COM2);    
....................          break;  
....................          case 0x0D:   
....................                keydebug_en=0; 
....................                set_tris_a(0xff); 
....................                for(i=nbcar;i<nbcarmax;i++) 
....................                { 
....................                  chaine[i]=0; 
....................                } 
....................                if(nbcar==0)return(FAUX); 
....................                fini=VRAI; 
....................          break; 
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
....................             { 
....................                chaine[nbcar]=c; 
....................                nbcar++; 
....................                if(echo==EN_ECHO) fputc(c,COM2); 
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
....................    return(nbcar); 
.................... } 
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
.................... { 
*
5796:  MOVFF  A8F,A93
579A:  MOVFF  A8E,A92
579E:  MOVFF  A91,A95
57A2:  MOVFF  A90,A94
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
....................    { 
57A6:  MOVFF  A93,03
57AA:  MOVLB  A
57AC:  MOVFF  A92,FE9
57B0:  MOVFF  A93,FEA
57B4:  MOVF   FEF,F
57B6:  BZ    57FE
57B8:  MOVFF  A95,03
57BC:  MOVFF  A94,FE9
57C0:  MOVFF  A95,FEA
57C4:  MOVF   FEF,F
57C6:  BZ    57FE
....................       if(*aa!=*bb) 
57C8:  MOVFF  A92,FE9
57CC:  MOVFF  A93,FEA
57D0:  MOVFF  FEF,A96
57D4:  MOVFF  A95,03
57D8:  MOVFF  A94,FE9
57DC:  MOVFF  A95,FEA
57E0:  MOVF   FEF,W
57E2:  SUBWF  x96,W
57E4:  BZ    57EC
....................          return(1); 
57E6:  MOVLW  01
57E8:  MOVWF  01
57EA:  BRA    582A
....................       aa++; 
57EC:  INCF   x92,F
57EE:  BTFSC  FD8.2
57F0:  INCF   x93,F
....................       bb++; 
57F2:  INCF   x94,F
57F4:  BTFSC  FD8.2
57F6:  INCF   x95,F
....................    } 
57F8:  MOVLB  0
57FA:  BRA    57A6
57FC:  MOVLB  A
....................    if(*aa!=*bb)return(1); 
57FE:  MOVFF  A93,03
5802:  MOVFF  A92,FE9
5806:  MOVFF  A93,FEA
580A:  MOVFF  FEF,A96
580E:  MOVFF  A95,03
5812:  MOVFF  A94,FE9
5816:  MOVFF  A95,FEA
581A:  MOVF   FEF,W
581C:  SUBWF  x96,W
581E:  BZ    5826
5820:  MOVLW  01
5822:  MOVWF  01
5824:  BRA    582A
....................    return(0); 
5826:  MOVLW  00
5828:  MOVWF  01
.................... } 
582A:  MOVLB  0
582C:  RETURN 0
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
....................         if (c >= '0' && c <= '9') 
....................             digit = (unsigned int) (c - '0'); 
....................         else 
....................             break; 
....................  
....................         val = (val * 10) + digit; 
....................     } 
....................  
....................     return val; 
.................... } 
....................  
.................... int8 receiver_state=0,booting_done=0; 
.................... int16 over_byte=0; 
.................... #include <GSM.c>  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#include "myRS485.C" 
....................  
.................... #define        EMERGOFF       PIN_A7 
.................... #define        config_sms           0 
.................... #define        reading_sms_cmd      1 
.................... #define        MSG_avai             2 
.................... #define        analyze_sms          3 
.................... #define        checking_MN          4 
.................... #define        doing_sms            5 
.................... #define        delete_MSG           6 
.................... #define        pre_cmd              7 
.................... #define        MSG_sending          8 
.................... #define        check_st             9 
.................... #define        config               10 
.................... #define        autosending          11 
.................... #define        idle                 12 
.................... #define        data_analyze         13 
.................... #define        SIM_reply            14 
.................... #define        check_comunication   15 
.................... #define        phone_activity_status 16 
.................... #define        check_inbox          17 
.................... #define        checking_MN0         18 
.................... #define        autosending1         19 
.................... #define        reset_module         20 
.................... #if defined(twonumber) 
....................    #define        second_number_en     21 
.................... #endif    
....................  
.................... //#define     IGT            PIN_A6 
....................  
.................... //#define     batmb    sendto485(0,0x11,1) 
.................... //#define     tatmb    sendto485(0,0x11,0) 
....................  
....................  
.................... unsigned int8 msg_data_sending[280]; 
.................... int8 sim_bug[50]; 
.................... unsigned int8 msg_buffer1[20]; 
.................... unsigned int8 msg_buffer2[50]; 
.................... unsigned int8 reply_buffer[280]; 
.................... unsigned int8 datetime[25]; 
.................... unsigned int8 mobilenumb[26]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... //unsigned int8 buf_checkMBN[16]; 
.................... int16 count_polling=0; 
.................... int8 SIM_state=0,MSG_sending_st=0; 
.................... int16 timing_wait=100; 
.................... int8 auto_sending=0; 
.................... int8 send_oneMSG=0; 
.................... int8 SIM_reply_st=0; 
.................... int8 checking_sim=0; 
.................... int8 count_checking_nw=0; 
.................... int8 firstime_pw=0; 
.................... #if defined(twonumber) 
....................   int8 two_number_sending=0;  
....................    
.................... #endif 
.................... //unsigned int8 com_buffer1[20]="it is OK"; 
.................... //============================================== 
.................... void earse_buffer_uart(unsigned int8 numbuf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<numbuf;i++) 
....................    { 
....................        buffer_uart[i]=0; 
....................    } 
.................... } 
.................... //============================================== 
.................... void sim900_init() 
.................... { 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(500); 
....................    fprintf(COM1,"AT+CMGF=1\r\n"); 
....................    delay_ms(500); 
....................    //del_buf(26,mobilenumb); 
....................    //strcpy(mobilenumb,"+84903219082"); 
.................... } 
.................... //============================================== 
.................... int8 get_datasim900(int8 *datin) 
.................... { 
....................    int8 c,i,index=0; 
....................    int8 testtemp[20]; 
....................    while(index<5) 
....................    { 
....................       c = getc(); 
....................       index++; 
....................       fprintf(COM2,"%c", c);  
....................    } 
....................    for(i=0;i<15;i++) 
....................    { 
....................       fprintf(COM2,"%c", testtemp[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", index);//*/ 
....................    return 0; 
.................... } 
.................... //============================================== 
.................... int8 check_module() 
.................... { 
....................    int8 temp=0,i; 
....................    earse_buffer_uart(10); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    UART_index=0; 
....................    delay_ms(200); 
....................    //fputc('c',COM2); 
....................    //fprintf("MSG is OK\r\n"); 
....................    for(i=0;i<10;i++) 
....................    { 
....................       //fputc(buffer_uart[i],COM2); 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) 
....................       { 
....................          i=10; 
....................          temp=1; 
....................          return(temp); 
....................       } 
....................          else temp=0; 
....................    } 
....................    UART_index=0; 
....................    return(temp); 
.................... } 
.................... //============================================== 
.................... void power_on() 
.................... { 
....................    /*while(temp==0) 
....................    { 
....................       temp = check_module(); 
....................       if(temp==0) 
....................       { 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
....................       } 
....................          else break; 
....................    }*/ 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
.................... } 
.................... //============================================== 
.................... void power_off() 
.................... { 
....................    fprintf(COM1,"AT+CPOWD\r\n"); 
.................... } 
.................... //============================================== 
.................... unsigned int8 mymemcmp(void * s1,char *s2,size_t n) 
.................... { 
....................    char *su1, *su2; 
....................    unsigned int8 temp=0,i=0; 
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................       { 
....................          temp=1; 
....................          if(*su1>*su2) 
....................          { 
....................             if((i==0)&&(*su1==(*su2)+32)) temp = 0; 
....................                //else temp = 0; 
....................          } 
....................             else  
....................                { 
....................                   if((i==0)&&(*su2==(*su1)+32)) temp = 0; 
....................                     // else temp = 0; 
....................                } 
....................       } 
....................       i++; 
....................    } 
....................    return (temp); 
.................... } 
.................... //============================================== 
.................... int8 pre_msg(int8 *datin,int8 *datout,int16 index) 
.................... { 
*
5F2A:  MOVLB  A
5F2C:  CLRF   x95
....................    int8 i,len=0; 
....................    len = strlen(datin); 
5F2E:  MOVFF  A8F,A97
5F32:  MOVFF  A8E,A96
5F36:  MOVLB  0
5F38:  RCALL  5EF0
5F3A:  MOVFF  01,A95
....................    for(i=0;i<len;i++)datout[index++]=datin[i]; 
5F3E:  MOVLB  A
5F40:  CLRF   x94
5F42:  MOVF   x95,W
5F44:  SUBWF  x94,W
5F46:  BC    5F8A
5F48:  MOVFF  A93,03
5F4C:  MOVF   x92,W
5F4E:  INCF   x92,F
5F50:  BTFSC  FD8.2
5F52:  INCF   x93,F
5F54:  MOVWF  x96
5F56:  MOVFF  03,A97
5F5A:  MOVF   x90,W
5F5C:  ADDWF  x96,W
5F5E:  MOVWF  01
5F60:  MOVF   x91,W
5F62:  ADDWFC 03,W
5F64:  MOVWF  03
5F66:  MOVWF  x99
5F68:  CLRF   03
5F6A:  MOVF   x94,W
5F6C:  ADDWF  x8E,W
5F6E:  MOVWF  FE9
5F70:  MOVF   x8F,W
5F72:  ADDWFC 03,W
5F74:  MOVWF  FEA
5F76:  MOVFF  FEF,A9A
5F7A:  MOVFF  A99,FEA
5F7E:  MOVFF  01,FE9
5F82:  MOVFF  A9A,FEF
5F86:  INCF   x94,F
5F88:  BRA    5F42
....................    return index; 
5F8A:  MOVFF  A92,01
.................... } 
5F8E:  MOVLB  0
5F90:  RETURN 0
.................... //============================================== 
.................... void delete_sms(char number_sms) 
.................... { 
....................    switch(number_sms) 
....................    { 
....................        case  1: 
....................             fprintf(COM1,"AT+CMGD=1\r\n");  
....................        break; 
....................        case  2: 
....................             fprintf(COM1,"AT+CMGD=2\r\n"); 
....................        break; 
....................        case  3: 
....................             fprintf(COM1,"AT+CMGD=3\r\n"); 
....................        break; 
....................        case  4: 
....................             fprintf(COM1,"AT+CMGD=4\r\n");        
....................        break; 
....................        case  5: 
....................             fprintf(COM1,"AT+CMGD=5\r\n"); 
....................        break; 
....................        case  6: 
....................             fprintf(COM1,"AT+CMGD=6\r\n"); 
....................        break; 
....................        case  7: 
....................              fprintf(COM1,"AT+CMGD=7\r\n"); 
....................        break;        
....................        case  8: 
....................             fprintf(COM1,"AT+CMGD=8\r\n"); 
....................        break;        
....................    } 
....................    delay_ms(500); 
.................... } 
.................... //============================================== 
.................... void del_multi_sms(int8 num_sms) 
.................... { 
....................    int8 i; 
....................    for(i=1;i<=num_sms;i++) 
....................    { 
....................      delete_sms(i);  
....................      delay_ms(100); 
....................    } 
.................... } 
.................... //============================================== 
.................... //============================================== 
.................... void send_sms(unsigned int8* mobile_num,unsigned int8* MSG) 
.................... { 
....................       unsigned int8 i=0,strl=0; 
....................       strl= strlen(MSG);   
....................       fprintf(COM1,"AT+CMGS="); 
....................       delay_ms(500); 
....................       fputc('"',COM1); 
....................       while((mobile_num[i]!=0)&&(i<20)) 
....................       { 
....................          //fputc(mobile_num[i],COM2); 
....................          //putc(mobile_num[i]); 
....................          fputc(mobile_num[i],COM1); 
....................          i++; 
....................       } 
....................       fputc('"',COM1); 
....................       fprintf(COM1,"\r\n"); 
....................       delay_ms(500);         
....................       for(i=0;i<strl;i++) 
....................       { 
....................          fputc(MSG[i],COM1); 
....................       } 
....................       delay_ms(500); 
....................       fputc(26,COM1); 
.................... } 
.................... //============================================= 
.................... //============================================== 
.................... void reading_sms() 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<16;i++) mobilenumb[i]=0; 
....................    earse_buffer_uart(200); 
....................    printf("AT+CMGF=1\r\n"); 
....................    printf("AT+CMGR=1\r\n");  
....................    UART_index=0;  
....................    delay_ms(1000); 
....................    for(i=0;i<200;i++) 
....................    { 
....................       if((buffer_uart[i]=='a')&&(buffer_uart[i+1]=='d')&&(buffer_uart[i+2]=='m')&&(buffer_uart[i+3]=='i')&&(buffer_uart[i+4]=='n')&&(buffer_uart[i+5]==' ')) 
....................       { 
....................          write_ext_eeprom(strobe_mobile_num1,buffer_uart[i+6]); 
....................          fputc(buffer_uart[i+6],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+1,buffer_uart[i+7]); 
....................          fputc(buffer_uart[i+7],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+2,buffer_uart[i+8]); 
....................          fputc(buffer_uart[i+8],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+3,buffer_uart[i+9]); 
....................          fputc(buffer_uart[i+9],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+4,buffer_uart[i+10]); 
....................          fputc(buffer_uart[i+10],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+5,buffer_uart[i+11]); 
....................          fputc(buffer_uart[i+11],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+6,buffer_uart[i+12]); 
....................          fputc(buffer_uart[i+12],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+7,buffer_uart[i+13]); 
....................          fputc(buffer_uart[i+13],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+8,buffer_uart[i+14]); 
....................          fputc(buffer_uart[i+14],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+9,buffer_uart[i+15]); 
....................          fputc(buffer_uart[i+15],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+10,buffer_uart[i+16]); 
....................          fputc(buffer_uart[i+16],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+11,buffer_uart[i+17]); 
....................          fputc(buffer_uart[i+17],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+12,buffer_uart[i+18]); 
....................          fputc(buffer_uart[i+18],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+13,buffer_uart[i+19]); 
....................          fputc(buffer_uart[i+19],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+14,buffer_uart[i+20]); 
....................          fputc(buffer_uart[i+20],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+15,buffer_uart[i+21]); 
....................          fputc(buffer_uart[i+21],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+16,buffer_uart[i+22]); 
....................          fputc(buffer_uart[i+22],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+17,buffer_uart[i+23]); 
....................          fputc(buffer_uart[i+23],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+18,buffer_uart[i+24]); 
....................          fputc(buffer_uart[i+24],COM2);          
....................          write_ext_eeprom(strobe_mobile_num1+19,buffer_uart[i+25]); 
....................          fputc(buffer_uart[i+25],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+20,buffer_uart[i+26]); 
....................          fputc(buffer_uart[i+26],COM2);          
....................          fprintf(COM2,"\r\n"); 
....................          EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................          i=250; 
....................          sms_unread_flag=0; 
....................          strcpy (msg_data_sending, "done"); 
....................          send_sms(mobilenumb,msg_data_sending); 
....................          delay_ms(5000); 
....................          delete_sms(1); 
....................          delay_ms(5000); 
....................          UART_index=0; 
....................       } 
....................         else  
....................          { 
....................             if(i>198)  
....................             { 
....................                delay_ms(5000); 
....................                delete_sms(1); 
....................                delay_ms(5000); 
....................                UART_index=0; 
....................                sms_unread_flag=0; 
....................                EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................             } 
....................          } 
....................    } 
.................... } 
.................... //============================================== 
.................... /*void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... }*/ 
.................... //============================================================ 
.................... int8 checking_msg_avai() 
.................... { 
....................    int8 i; 
....................    /*for(i=0;i<100;i++) 
....................    { 
....................       fprintf(COM2,"%c", buffer_uart[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", UART_index);//*/ 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) return 1; 
....................    } 
....................    return 0; 
.................... } 
.................... //============================================================ 
.................... int8 SMS_coming() 
.................... { 
*
6528:  MOVLB  A
652A:  CLRF   x8F
.................... //+CMTI: "SM",25 
....................    int8 i,st=0; 
....................    //int8 msg_temp[20],msg_temp1[20]; 
....................    //strncpy(msg_temp1,buffer_uart,20); 
....................    //strcpy(msg_temp,"+CMTI:"); 
....................    for(i=0;i<20;i++) 
652C:  CLRF   x8E
652E:  MOVF   x8E,W
6530:  SUBLW  13
6532:  BTFSS  FD8.0
6534:  BRA    6640
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='T')&&(buffer_uart[4+i]=='I')&&(buffer_uart[5+i]==':'))  
6536:  CLRF   03
6538:  MOVF   x8E,W
653A:  ADDLW  4E
653C:  MOVWF  FE9
653E:  MOVLW  01
6540:  ADDWFC 03,W
6542:  MOVWF  FEA
6544:  MOVF   FEF,W
6546:  SUBLW  2B
6548:  BTFSS  FD8.2
654A:  BRA    663A
654C:  MOVLW  01
654E:  ADDWF  x8E,W
6550:  CLRF   03
6552:  ADDLW  4E
6554:  MOVWF  FE9
6556:  MOVLW  01
6558:  ADDWFC 03,W
655A:  MOVWF  FEA
655C:  MOVF   FEF,W
655E:  SUBLW  43
6560:  BNZ   663A
6562:  MOVLW  02
6564:  ADDWF  x8E,W
6566:  CLRF   03
6568:  ADDLW  4E
656A:  MOVWF  FE9
656C:  MOVLW  01
656E:  ADDWFC 03,W
6570:  MOVWF  FEA
6572:  MOVF   FEF,W
6574:  SUBLW  4D
6576:  BNZ   663A
6578:  MOVLW  03
657A:  ADDWF  x8E,W
657C:  CLRF   03
657E:  ADDLW  4E
6580:  MOVWF  FE9
6582:  MOVLW  01
6584:  ADDWFC 03,W
6586:  MOVWF  FEA
6588:  MOVF   FEF,W
658A:  SUBLW  54
658C:  BNZ   663A
658E:  MOVLW  04
6590:  ADDWF  x8E,W
6592:  CLRF   03
6594:  ADDLW  4E
6596:  MOVWF  FE9
6598:  MOVLW  01
659A:  ADDWFC 03,W
659C:  MOVWF  FEA
659E:  MOVF   FEF,W
65A0:  SUBLW  49
65A2:  BNZ   663A
65A4:  MOVLW  05
65A6:  ADDWF  x8E,W
65A8:  CLRF   03
65AA:  ADDLW  4E
65AC:  MOVWF  FE9
65AE:  MOVLW  01
65B0:  ADDWFC 03,W
65B2:  MOVWF  FEA
65B4:  MOVF   FEF,W
65B6:  SUBLW  3A
65B8:  BNZ   663A
....................       {  
....................          fprintf(COM2,"\n\rNew SMS %lu\n\r",over_byte); 
65BA:  MOVLW  9E
65BC:  MOVWF  FF6
65BE:  MOVLW  05
65C0:  MOVWF  FF7
65C2:  CLRF   19
65C4:  BTFSC  FF2.7
65C6:  BSF    19.7
65C8:  BCF    FF2.7
65CA:  MOVLW  0A
65CC:  MOVWF  xD3
65CE:  MOVLB  0
65D0:  CALL   1718
65D4:  BTFSC  19.7
65D6:  BSF    FF2.7
65D8:  MOVLW  10
65DA:  MOVWF  FE9
65DC:  CLRF   19
65DE:  BTFSC  FF2.7
65E0:  BSF    19.7
65E2:  BCF    FF2.7
65E4:  MOVFF  1B7,ABD
65E8:  MOVFF  1B6,ABC
65EC:  CALL   1742
65F0:  BTFSC  19.7
65F2:  BSF    FF2.7
65F4:  CLRF   19
65F6:  BTFSC  FF2.7
65F8:  BSF    19.7
65FA:  BCF    FF2.7
65FC:  MOVLW  0A
65FE:  MOVLB  A
6600:  MOVWF  xDF
6602:  MOVLB  0
6604:  CALL   075A
6608:  BTFSC  19.7
660A:  BSF    FF2.7
660C:  CLRF   19
660E:  BTFSC  FF2.7
6610:  BSF    19.7
6612:  BCF    FF2.7
6614:  MOVLW  0D
6616:  MOVLB  A
6618:  MOVWF  xDF
661A:  MOVLB  0
661C:  CALL   075A
6620:  BTFSC  19.7
6622:  BSF    FF2.7
....................          //output_high(PIN_C2); 
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
6624:  MOVLB  4
6626:  CLRF   x95
....................          over_byte=0; 
6628:  MOVLB  1
662A:  CLRF   xB7
662C:  CLRF   xB6
....................          st = 2; 
662E:  MOVLW  02
6630:  MOVLB  A
6632:  MOVWF  x8F
....................          i=23; 
6634:  MOVLW  17
6636:  MOVWF  x8E
....................       } 
....................          else st=0; 
6638:  BRA    663C
663A:  CLRF   x8F
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
663C:  INCF   x8E,F
663E:  BRA    652E
....................    for(i=0;i<20;i++) 
6640:  CLRF   x8E
6642:  MOVF   x8E,W
6644:  SUBLW  13
6646:  BNC   66FA
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='G')&&(buffer_uart[4+i]=='R')&&(buffer_uart[5+i]==':'))  
6648:  CLRF   03
664A:  MOVF   x8E,W
664C:  ADDLW  4E
664E:  MOVWF  FE9
6650:  MOVLW  01
6652:  ADDWFC 03,W
6654:  MOVWF  FEA
6656:  MOVF   FEF,W
6658:  SUBLW  2B
665A:  BNZ   66F4
665C:  MOVLW  01
665E:  ADDWF  x8E,W
6660:  CLRF   03
6662:  ADDLW  4E
6664:  MOVWF  FE9
6666:  MOVLW  01
6668:  ADDWFC 03,W
666A:  MOVWF  FEA
666C:  MOVF   FEF,W
666E:  SUBLW  43
6670:  BNZ   66F4
6672:  MOVLW  02
6674:  ADDWF  x8E,W
6676:  CLRF   03
6678:  ADDLW  4E
667A:  MOVWF  FE9
667C:  MOVLW  01
667E:  ADDWFC 03,W
6680:  MOVWF  FEA
6682:  MOVF   FEF,W
6684:  SUBLW  4D
6686:  BNZ   66F4
6688:  MOVLW  03
668A:  ADDWF  x8E,W
668C:  CLRF   03
668E:  ADDLW  4E
6690:  MOVWF  FE9
6692:  MOVLW  01
6694:  ADDWFC 03,W
6696:  MOVWF  FEA
6698:  MOVF   FEF,W
669A:  SUBLW  47
669C:  BNZ   66F4
669E:  MOVLW  04
66A0:  ADDWF  x8E,W
66A2:  CLRF   03
66A4:  ADDLW  4E
66A6:  MOVWF  FE9
66A8:  MOVLW  01
66AA:  ADDWFC 03,W
66AC:  MOVWF  FEA
66AE:  MOVF   FEF,W
66B0:  SUBLW  52
66B2:  BNZ   66F4
66B4:  MOVLW  05
66B6:  ADDWF  x8E,W
66B8:  CLRF   03
66BA:  ADDLW  4E
66BC:  MOVWF  FE9
66BE:  MOVLW  01
66C0:  ADDWFC 03,W
66C2:  MOVWF  FEA
66C4:  MOVF   FEF,W
66C6:  SUBLW  3A
66C8:  BNZ   66F4
....................       {  
....................          fprintf(COM2,"\n\rREC UNREAD\n\r"); 
66CA:  MOVLW  AE
66CC:  MOVWF  FF6
66CE:  MOVLW  05
66D0:  MOVWF  FF7
66D2:  CLRF   19
66D4:  BTFSC  FF2.7
66D6:  BSF    19.7
66D8:  BCF    FF2.7
66DA:  MOVLB  0
66DC:  CALL   07A0
66E0:  BTFSC  19.7
66E2:  BSF    FF2.7
....................          //output_high(PIN_C2); 
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
66E4:  MOVLB  4
66E6:  CLRF   x95
....................          st = 2; 
66E8:  MOVLW  02
66EA:  MOVLB  A
66EC:  MOVWF  x8F
....................          i=23; 
66EE:  MOVLW  17
66F0:  MOVWF  x8E
....................       } 
....................          else st=0; 
66F2:  BRA    66F6
66F4:  CLRF   x8F
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
66F6:  INCF   x8E,F
66F8:  BRA    6642
....................    for(i=0;i<20;i++) 
66FA:  CLRF   x8E
66FC:  MOVF   x8E,W
66FE:  SUBLW  13
6700:  BNC   67D8
....................    { 
....................       if((buffer_uart[0+i]=='R')&&(buffer_uart[1+i]=='I')&&(buffer_uart[2+i]=='N')&&(buffer_uart[3+i]=='G'))  
6702:  CLRF   03
6704:  MOVF   x8E,W
6706:  ADDLW  4E
6708:  MOVWF  FE9
670A:  MOVLW  01
670C:  ADDWFC 03,W
670E:  MOVWF  FEA
6710:  MOVF   FEF,W
6712:  SUBLW  52
6714:  BNZ   67D2
6716:  MOVLW  01
6718:  ADDWF  x8E,W
671A:  CLRF   03
671C:  ADDLW  4E
671E:  MOVWF  FE9
6720:  MOVLW  01
6722:  ADDWFC 03,W
6724:  MOVWF  FEA
6726:  MOVF   FEF,W
6728:  SUBLW  49
672A:  BNZ   67D2
672C:  MOVLW  02
672E:  ADDWF  x8E,W
6730:  CLRF   03
6732:  ADDLW  4E
6734:  MOVWF  FE9
6736:  MOVLW  01
6738:  ADDWFC 03,W
673A:  MOVWF  FEA
673C:  MOVF   FEF,W
673E:  SUBLW  4E
6740:  BNZ   67D2
6742:  MOVLW  03
6744:  ADDWF  x8E,W
6746:  CLRF   03
6748:  ADDLW  4E
674A:  MOVWF  FE9
674C:  MOVLW  01
674E:  ADDWFC 03,W
6750:  MOVWF  FEA
6752:  MOVF   FEF,W
6754:  SUBLW  47
6756:  BNZ   67D2
....................       {  
....................          fprintf(COM2,"\n\rRING %lu\n\r",over_byte); 
6758:  MOVLW  BE
675A:  MOVWF  FF6
675C:  MOVLW  05
675E:  MOVWF  FF7
6760:  CLRF   19
6762:  BTFSC  FF2.7
6764:  BSF    19.7
6766:  BCF    FF2.7
6768:  MOVLW  07
676A:  MOVWF  xD3
676C:  MOVLB  0
676E:  CALL   1718
6772:  BTFSC  19.7
6774:  BSF    FF2.7
6776:  MOVLW  10
6778:  MOVWF  FE9
677A:  CLRF   19
677C:  BTFSC  FF2.7
677E:  BSF    19.7
6780:  BCF    FF2.7
6782:  MOVFF  1B7,ABD
6786:  MOVFF  1B6,ABC
678A:  CALL   1742
678E:  BTFSC  19.7
6790:  BSF    FF2.7
6792:  CLRF   19
6794:  BTFSC  FF2.7
6796:  BSF    19.7
6798:  BCF    FF2.7
679A:  MOVLW  0A
679C:  MOVLB  A
679E:  MOVWF  xDF
67A0:  MOVLB  0
67A2:  CALL   075A
67A6:  BTFSC  19.7
67A8:  BSF    FF2.7
67AA:  CLRF   19
67AC:  BTFSC  FF2.7
67AE:  BSF    19.7
67B0:  BCF    FF2.7
67B2:  MOVLW  0D
67B4:  MOVLB  A
67B6:  MOVWF  xDF
67B8:  MOVLB  0
67BA:  CALL   075A
67BE:  BTFSC  19.7
67C0:  BSF    FF2.7
....................          output_high(LED); 
67C2:  BCF    F92.6
67C4:  BSF    F89.6
....................          st = 1; 
67C6:  MOVLW  01
67C8:  MOVLB  A
67CA:  MOVWF  x8F
....................          i=23; 
67CC:  MOVLW  17
67CE:  MOVWF  x8E
....................       } 
....................          else st=0; 
67D0:  BRA    67D4
67D2:  CLRF   x8F
....................    } 
67D4:  INCF   x8E,F
67D6:  BRA    66FC
....................    for(i=0;i<20;i++) 
67D8:  CLRF   x8E
67DA:  MOVF   x8E,W
67DC:  SUBLW  13
67DE:  BTFSS  FD8.0
67E0:  BRA    69CC
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='P')&&(buffer_uart[3+i]=='A')&&(buffer_uart[4+i]=='S')&&(buffer_uart[5+i]==':'))  
67E2:  CLRF   03
67E4:  MOVF   x8E,W
67E6:  ADDLW  4E
67E8:  MOVWF  FE9
67EA:  MOVLW  01
67EC:  ADDWFC 03,W
67EE:  MOVWF  FEA
67F0:  MOVF   FEF,W
67F2:  SUBLW  2B
67F4:  BTFSS  FD8.2
67F6:  BRA    69C6
67F8:  MOVLW  01
67FA:  ADDWF  x8E,W
67FC:  CLRF   03
67FE:  ADDLW  4E
6800:  MOVWF  FE9
6802:  MOVLW  01
6804:  ADDWFC 03,W
6806:  MOVWF  FEA
6808:  MOVF   FEF,W
680A:  SUBLW  43
680C:  BTFSS  FD8.2
680E:  BRA    69C6
6810:  MOVLW  02
6812:  ADDWF  x8E,W
6814:  CLRF   03
6816:  ADDLW  4E
6818:  MOVWF  FE9
681A:  MOVLW  01
681C:  ADDWFC 03,W
681E:  MOVWF  FEA
6820:  MOVF   FEF,W
6822:  SUBLW  50
6824:  BTFSS  FD8.2
6826:  BRA    69C6
6828:  MOVLW  03
682A:  ADDWF  x8E,W
682C:  CLRF   03
682E:  ADDLW  4E
6830:  MOVWF  FE9
6832:  MOVLW  01
6834:  ADDWFC 03,W
6836:  MOVWF  FEA
6838:  MOVF   FEF,W
683A:  SUBLW  41
683C:  BTFSS  FD8.2
683E:  BRA    69C6
6840:  MOVLW  04
6842:  ADDWF  x8E,W
6844:  CLRF   03
6846:  ADDLW  4E
6848:  MOVWF  FE9
684A:  MOVLW  01
684C:  ADDWFC 03,W
684E:  MOVWF  FEA
6850:  MOVF   FEF,W
6852:  SUBLW  53
6854:  BTFSS  FD8.2
6856:  BRA    69C6
6858:  MOVLW  05
685A:  ADDWF  x8E,W
685C:  CLRF   03
685E:  ADDLW  4E
6860:  MOVWF  FE9
6862:  MOVLW  01
6864:  ADDWFC 03,W
6866:  MOVWF  FEA
6868:  MOVF   FEF,W
686A:  SUBLW  3A
686C:  BTFSS  FD8.2
686E:  BRA    69C6
....................       {  
....................          if(buffer_uart[7+i]=='0')  
6870:  MOVLW  07
6872:  ADDWF  x8E,W
6874:  CLRF   03
6876:  ADDLW  4E
6878:  MOVWF  FE9
687A:  MOVLW  01
687C:  ADDWFC 03,W
687E:  MOVWF  FEA
6880:  MOVF   FEF,W
6882:  SUBLW  30
6884:  BNZ   68FE
....................          { 
....................             fprintf(COM2,"Ready (MT allows commands from TA/TE)%lu\n\r",over_byte); 
6886:  MOVLW  CC
6888:  MOVWF  FF6
688A:  MOVLW  05
688C:  MOVWF  FF7
688E:  CLRF   19
6890:  BTFSC  FF2.7
6892:  BSF    19.7
6894:  BCF    FF2.7
6896:  MOVLW  25
6898:  MOVWF  xD3
689A:  MOVLB  0
689C:  CALL   1718
68A0:  BTFSC  19.7
68A2:  BSF    FF2.7
68A4:  MOVLW  10
68A6:  MOVWF  FE9
68A8:  CLRF   19
68AA:  BTFSC  FF2.7
68AC:  BSF    19.7
68AE:  BCF    FF2.7
68B0:  MOVFF  1B7,ABD
68B4:  MOVFF  1B6,ABC
68B8:  CALL   1742
68BC:  BTFSC  19.7
68BE:  BSF    FF2.7
68C0:  CLRF   19
68C2:  BTFSC  FF2.7
68C4:  BSF    19.7
68C6:  BCF    FF2.7
68C8:  MOVLW  0A
68CA:  MOVLB  A
68CC:  MOVWF  xDF
68CE:  MOVLB  0
68D0:  CALL   075A
68D4:  BTFSC  19.7
68D6:  BSF    FF2.7
68D8:  CLRF   19
68DA:  BTFSC  FF2.7
68DC:  BSF    19.7
68DE:  BCF    FF2.7
68E0:  MOVLW  0D
68E2:  MOVLB  A
68E4:  MOVWF  xDF
68E6:  MOVLB  0
68E8:  CALL   075A
68EC:  BTFSC  19.7
68EE:  BSF    FF2.7
....................             SIM_state= check_inbox; 
68F0:  MOVLW  11
68F2:  MOVLB  4
68F4:  MOVWF  x95
....................             over_byte=0; 
68F6:  MOVLB  1
68F8:  CLRF   xB7
68FA:  CLRF   xB6
68FC:  MOVLB  A
....................          } 
....................          if(buffer_uart[7+i]=='2') 
68FE:  MOVLW  07
6900:  ADDWF  x8E,W
6902:  CLRF   03
6904:  ADDLW  4E
6906:  MOVWF  FE9
6908:  MOVLW  01
690A:  ADDWFC 03,W
690C:  MOVWF  FEA
690E:  MOVF   FEF,W
6910:  SUBLW  32
6912:  BNZ   6958
....................          { 
....................             fprintf(COM2,"No network\n\r"); 
6914:  MOVLW  F8
6916:  MOVWF  FF6
6918:  MOVLW  05
691A:  MOVWF  FF7
691C:  CLRF   19
691E:  BTFSC  FF2.7
6920:  BSF    19.7
6922:  BCF    FF2.7
6924:  MOVLB  0
6926:  CALL   07A0
692A:  BTFSC  19.7
692C:  BSF    FF2.7
....................             #if defined(SIM900) 
....................                booting_done=0; 
692E:  MOVLB  1
6930:  CLRF   xB5
....................                output_low(rst_sim); 
6932:  BCF    F94.1
6934:  BCF    F8B.1
....................                fprintf(COM2,"reseting module SIM\n\r"); 
6936:  MOVLW  06
6938:  MOVWF  FF6
693A:  MOVLW  06
693C:  MOVWF  FF7
693E:  CLRF   19
6940:  BTFSC  FF2.7
6942:  BSF    19.7
6944:  BCF    FF2.7
6946:  MOVLB  0
6948:  CALL   07A0
694C:  BTFSC  19.7
694E:  BSF    FF2.7
....................             #endif    
....................             SIM_state=check_comunication; 
6950:  MOVLW  0F
6952:  MOVLB  4
6954:  MOVWF  x95
6956:  MOVLB  A
....................          } 
....................          if(buffer_uart[7+i]=='3') fprintf(COM2,"Ringing\n\r"); 
6958:  MOVLW  07
695A:  ADDWF  x8E,W
695C:  CLRF   03
695E:  ADDLW  4E
6960:  MOVWF  FE9
6962:  MOVLW  01
6964:  ADDWFC 03,W
6966:  MOVWF  FEA
6968:  MOVF   FEF,W
696A:  SUBLW  33
696C:  BNZ   698A
696E:  MOVLW  1C
6970:  MOVWF  FF6
6972:  MOVLW  06
6974:  MOVWF  FF7
6976:  CLRF   19
6978:  BTFSC  FF2.7
697A:  BSF    19.7
697C:  BCF    FF2.7
697E:  MOVLB  0
6980:  CALL   07A0
6984:  BTFSC  19.7
6986:  BSF    FF2.7
6988:  MOVLB  A
....................          if(buffer_uart[7+i]=='4') fprintf(COM2,"Call in progress\n\r"); 
698A:  MOVLW  07
698C:  ADDWF  x8E,W
698E:  CLRF   03
6990:  ADDLW  4E
6992:  MOVWF  FE9
6994:  MOVLW  01
6996:  ADDWFC 03,W
6998:  MOVWF  FEA
699A:  MOVF   FEF,W
699C:  SUBLW  34
699E:  BNZ   69BC
69A0:  MOVLW  26
69A2:  MOVWF  FF6
69A4:  MOVLW  06
69A6:  MOVWF  FF7
69A8:  CLRF   19
69AA:  BTFSC  FF2.7
69AC:  BSF    19.7
69AE:  BCF    FF2.7
69B0:  MOVLB  0
69B2:  CALL   07A0
69B6:  BTFSC  19.7
69B8:  BSF    FF2.7
69BA:  MOVLB  A
....................          st = 3; 
69BC:  MOVLW  03
69BE:  MOVWF  x8F
....................          i=23; 
69C0:  MOVLW  17
69C2:  MOVWF  x8E
....................       } 
....................          else st=0; 
69C4:  BRA    69C8
69C6:  CLRF   x8F
....................    } 
69C8:  INCF   x8E,F
69CA:  BRA    67DA
....................    for(i=0;i<20;i++) 
69CC:  CLRF   x8E
69CE:  MOVF   x8E,W
69D0:  SUBLW  13
69D2:  BTFSS  FD8.0
69D4:  BRA    6ACC
....................    { 
....................       if((buffer_uart[0+i]=='U')&&(buffer_uart[1+i]=='N')&&(buffer_uart[2+i]=='D')&&(buffer_uart[3+i]=='E')&&(buffer_uart[4+i]=='R')&&(buffer_uart[5+i]=='-')&&(buffer_uart[6+i]=='V')&&(buffer_uart[7+i]=='O')&&(buffer_uart[8+i]=='L'))  
69D6:  CLRF   03
69D8:  MOVF   x8E,W
69DA:  ADDLW  4E
69DC:  MOVWF  FE9
69DE:  MOVLW  01
69E0:  ADDWFC 03,W
69E2:  MOVWF  FEA
69E4:  MOVF   FEF,W
69E6:  SUBLW  55
69E8:  BTFSS  FD8.2
69EA:  BRA    6AC6
69EC:  MOVLW  01
69EE:  ADDWF  x8E,W
69F0:  CLRF   03
69F2:  ADDLW  4E
69F4:  MOVWF  FE9
69F6:  MOVLW  01
69F8:  ADDWFC 03,W
69FA:  MOVWF  FEA
69FC:  MOVF   FEF,W
69FE:  SUBLW  4E
6A00:  BNZ   6AC6
6A02:  MOVLW  02
6A04:  ADDWF  x8E,W
6A06:  CLRF   03
6A08:  ADDLW  4E
6A0A:  MOVWF  FE9
6A0C:  MOVLW  01
6A0E:  ADDWFC 03,W
6A10:  MOVWF  FEA
6A12:  MOVF   FEF,W
6A14:  SUBLW  44
6A16:  BNZ   6AC6
6A18:  MOVLW  03
6A1A:  ADDWF  x8E,W
6A1C:  CLRF   03
6A1E:  ADDLW  4E
6A20:  MOVWF  FE9
6A22:  MOVLW  01
6A24:  ADDWFC 03,W
6A26:  MOVWF  FEA
6A28:  MOVF   FEF,W
6A2A:  SUBLW  45
6A2C:  BNZ   6AC6
6A2E:  MOVLW  04
6A30:  ADDWF  x8E,W
6A32:  CLRF   03
6A34:  ADDLW  4E
6A36:  MOVWF  FE9
6A38:  MOVLW  01
6A3A:  ADDWFC 03,W
6A3C:  MOVWF  FEA
6A3E:  MOVF   FEF,W
6A40:  SUBLW  52
6A42:  BNZ   6AC6
6A44:  MOVLW  05
6A46:  ADDWF  x8E,W
6A48:  CLRF   03
6A4A:  ADDLW  4E
6A4C:  MOVWF  FE9
6A4E:  MOVLW  01
6A50:  ADDWFC 03,W
6A52:  MOVWF  FEA
6A54:  MOVF   FEF,W
6A56:  SUBLW  2D
6A58:  BNZ   6AC6
6A5A:  MOVLW  06
6A5C:  ADDWF  x8E,W
6A5E:  CLRF   03
6A60:  ADDLW  4E
6A62:  MOVWF  FE9
6A64:  MOVLW  01
6A66:  ADDWFC 03,W
6A68:  MOVWF  FEA
6A6A:  MOVF   FEF,W
6A6C:  SUBLW  56
6A6E:  BNZ   6AC6
6A70:  MOVLW  07
6A72:  ADDWF  x8E,W
6A74:  CLRF   03
6A76:  ADDLW  4E
6A78:  MOVWF  FE9
6A7A:  MOVLW  01
6A7C:  ADDWFC 03,W
6A7E:  MOVWF  FEA
6A80:  MOVF   FEF,W
6A82:  SUBLW  4F
6A84:  BNZ   6AC6
6A86:  MOVLW  08
6A88:  ADDWF  x8E,W
6A8A:  CLRF   03
6A8C:  ADDLW  4E
6A8E:  MOVWF  FE9
6A90:  MOVLW  01
6A92:  ADDWFC 03,W
6A94:  MOVWF  FEA
6A96:  MOVF   FEF,W
6A98:  SUBLW  4C
6A9A:  BNZ   6AC6
....................       {  
....................          fprintf(COM2,"\n\rUNDER-VOLTAGE WARNNING\n\r"); 
6A9C:  MOVLW  3A
6A9E:  MOVWF  FF6
6AA0:  MOVLW  06
6AA2:  MOVWF  FF7
6AA4:  CLRF   19
6AA6:  BTFSC  FF2.7
6AA8:  BSF    19.7
6AAA:  BCF    FF2.7
6AAC:  MOVLB  0
6AAE:  CALL   07A0
6AB2:  BTFSC  19.7
6AB4:  BSF    FF2.7
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
6AB6:  MOVLB  4
6AB8:  CLRF   x95
....................          st = 4; 
6ABA:  MOVLW  04
6ABC:  MOVLB  A
6ABE:  MOVWF  x8F
....................          i=23; 
6AC0:  MOVLW  17
6AC2:  MOVWF  x8E
....................       } 
....................          else st=0; 
6AC4:  BRA    6AC8
6AC6:  CLRF   x8F
....................    } 
6AC8:  INCF   x8E,F
6ACA:  BRA    69CE
....................    for(i=0;i<20;i++) 
6ACC:  CLRF   x8E
6ACE:  MOVF   x8E,W
6AD0:  SUBLW  13
6AD2:  BTFSS  FD8.0
6AD4:  BRA    6BCC
....................    { 
....................       if((buffer_uart[0+i]=='O')&&(buffer_uart[1+i]=='V')&&(buffer_uart[2+i]=='E')&&(buffer_uart[3+i]=='R')&&(buffer_uart[4+i]=='-')&&(buffer_uart[5+i]=='V')&&(buffer_uart[6+i]=='O')&&(buffer_uart[7+i]=='L')&&(buffer_uart[8+i]=='T'))  
6AD6:  CLRF   03
6AD8:  MOVF   x8E,W
6ADA:  ADDLW  4E
6ADC:  MOVWF  FE9
6ADE:  MOVLW  01
6AE0:  ADDWFC 03,W
6AE2:  MOVWF  FEA
6AE4:  MOVF   FEF,W
6AE6:  SUBLW  4F
6AE8:  BTFSS  FD8.2
6AEA:  BRA    6BC6
6AEC:  MOVLW  01
6AEE:  ADDWF  x8E,W
6AF0:  CLRF   03
6AF2:  ADDLW  4E
6AF4:  MOVWF  FE9
6AF6:  MOVLW  01
6AF8:  ADDWFC 03,W
6AFA:  MOVWF  FEA
6AFC:  MOVF   FEF,W
6AFE:  SUBLW  56
6B00:  BNZ   6BC6
6B02:  MOVLW  02
6B04:  ADDWF  x8E,W
6B06:  CLRF   03
6B08:  ADDLW  4E
6B0A:  MOVWF  FE9
6B0C:  MOVLW  01
6B0E:  ADDWFC 03,W
6B10:  MOVWF  FEA
6B12:  MOVF   FEF,W
6B14:  SUBLW  45
6B16:  BNZ   6BC6
6B18:  MOVLW  03
6B1A:  ADDWF  x8E,W
6B1C:  CLRF   03
6B1E:  ADDLW  4E
6B20:  MOVWF  FE9
6B22:  MOVLW  01
6B24:  ADDWFC 03,W
6B26:  MOVWF  FEA
6B28:  MOVF   FEF,W
6B2A:  SUBLW  52
6B2C:  BNZ   6BC6
6B2E:  MOVLW  04
6B30:  ADDWF  x8E,W
6B32:  CLRF   03
6B34:  ADDLW  4E
6B36:  MOVWF  FE9
6B38:  MOVLW  01
6B3A:  ADDWFC 03,W
6B3C:  MOVWF  FEA
6B3E:  MOVF   FEF,W
6B40:  SUBLW  2D
6B42:  BNZ   6BC6
6B44:  MOVLW  05
6B46:  ADDWF  x8E,W
6B48:  CLRF   03
6B4A:  ADDLW  4E
6B4C:  MOVWF  FE9
6B4E:  MOVLW  01
6B50:  ADDWFC 03,W
6B52:  MOVWF  FEA
6B54:  MOVF   FEF,W
6B56:  SUBLW  56
6B58:  BNZ   6BC6
6B5A:  MOVLW  06
6B5C:  ADDWF  x8E,W
6B5E:  CLRF   03
6B60:  ADDLW  4E
6B62:  MOVWF  FE9
6B64:  MOVLW  01
6B66:  ADDWFC 03,W
6B68:  MOVWF  FEA
6B6A:  MOVF   FEF,W
6B6C:  SUBLW  4F
6B6E:  BNZ   6BC6
6B70:  MOVLW  07
6B72:  ADDWF  x8E,W
6B74:  CLRF   03
6B76:  ADDLW  4E
6B78:  MOVWF  FE9
6B7A:  MOVLW  01
6B7C:  ADDWFC 03,W
6B7E:  MOVWF  FEA
6B80:  MOVF   FEF,W
6B82:  SUBLW  4C
6B84:  BNZ   6BC6
6B86:  MOVLW  08
6B88:  ADDWF  x8E,W
6B8A:  CLRF   03
6B8C:  ADDLW  4E
6B8E:  MOVWF  FE9
6B90:  MOVLW  01
6B92:  ADDWFC 03,W
6B94:  MOVWF  FEA
6B96:  MOVF   FEF,W
6B98:  SUBLW  54
6B9A:  BNZ   6BC6
....................       {  
....................          fprintf(COM2,"\n\rOVER-VOLTAGE POWER DOWN\n\r"); 
6B9C:  MOVLW  56
6B9E:  MOVWF  FF6
6BA0:  MOVLW  06
6BA2:  MOVWF  FF7
6BA4:  CLRF   19
6BA6:  BTFSC  FF2.7
6BA8:  BSF    19.7
6BAA:  BCF    FF2.7
6BAC:  MOVLB  0
6BAE:  CALL   07A0
6BB2:  BTFSC  19.7
6BB4:  BSF    FF2.7
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
6BB6:  MOVLB  4
6BB8:  CLRF   x95
....................          st = 4; 
6BBA:  MOVLW  04
6BBC:  MOVLB  A
6BBE:  MOVWF  x8F
....................          i=23; 
6BC0:  MOVLW  17
6BC2:  MOVWF  x8E
....................       } 
....................          else st=0; 
6BC4:  BRA    6BC8
6BC6:  CLRF   x8F
....................    } 
6BC8:  INCF   x8E,F
6BCA:  BRA    6ACE
....................  
....................    UART_index=0; 
6BCC:  MOVLB  1
6BCE:  CLRF   xB2
....................    memset(buffer_uart,0,sizeof(buffer_uart));  
6BD0:  MOVLW  01
6BD2:  MOVWF  FEA
6BD4:  MOVLW  4E
6BD6:  MOVWF  FE9
6BD8:  CLRF   00
6BDA:  CLRF   02
6BDC:  MOVLW  64
6BDE:  MOVWF  01
6BE0:  MOVLB  0
6BE2:  CALL   446E
....................    return st; 
6BE6:  MOVLB  A
6BE8:  MOVFF  A8F,01
.................... } 
6BEC:  MOVLB  0
6BEE:  GOTO   979E (RETURN)
.................... //============================================================ 
.................... unsigned int8 analyzing_msg(char* MSG,char* mobile_number) 
.................... { 
*
53F2:  MOVLB  A
53F4:  CLRF   x92
53F6:  CLRF   x93
53F8:  CLRF   x94
53FA:  CLRF   x95
53FC:  CLRF   x96
53FE:  CLRF   x97
5400:  CLRF   x98
5402:  CLRF   19
5404:  BTFSC  FF2.7
5406:  BSF    19.7
5408:  BCF    FF2.7
....................    unsigned int8 i=0,a=0,b=0,d=0,u=0,v=0; 
....................    unsigned int8 st=0,temp; 
....................    del_buf(50,MSG); 
540A:  MOVLW  32
540C:  MOVWF  xC5
540E:  MOVFF  A8F,AC7
5412:  MOVFF  A8E,AC6
5416:  MOVLB  0
5418:  CALL   3A62
541C:  BTFSC  19.7
541E:  BSF    FF2.7
5420:  CLRF   19
5422:  BTFSC  FF2.7
5424:  BSF    19.7
5426:  BCF    FF2.7
....................    del_buf(20,mobile_number); 
5428:  MOVLW  14
542A:  MOVLB  A
542C:  MOVWF  xC5
542E:  MOVFF  A91,AC7
5432:  MOVFF  A90,AC6
5436:  MOVLB  0
5438:  CALL   3A62
543C:  BTFSC  19.7
543E:  BSF    FF2.7
....................    for(i=0;i<100;i++) 
5440:  MOVLB  A
5442:  CLRF   x92
5444:  MOVF   x92,W
5446:  SUBLW  63
5448:  BNC   5478
....................    { 
....................       fprintf(COM2,"%c",buffer_uart[i]);  
544A:  CLRF   03
544C:  MOVF   x92,W
544E:  ADDLW  4E
5450:  MOVWF  FE9
5452:  MOVLW  01
5454:  ADDWFC 03,W
5456:  MOVWF  FEA
5458:  MOVFF  FEF,A9A
545C:  CLRF   19
545E:  BTFSC  FF2.7
5460:  BSF    19.7
5462:  BCF    FF2.7
5464:  MOVFF  A9A,ADF
5468:  MOVLB  0
546A:  CALL   075A
546E:  BTFSC  19.7
5470:  BSF    FF2.7
....................    } 
5472:  MOVLB  A
5474:  INCF   x92,F
5476:  BRA    5444
....................    for(i=0;i<100;i++) 
5478:  CLRF   x92
547A:  MOVF   x92,W
547C:  SUBLW  63
547E:  BTFSS  FD8.0
5480:  BRA    568C
....................    { 
....................       if((buffer_uart[i]=='+')&&(buffer_uart[i+1]=='C')&&(buffer_uart[i+2]=='M')&&(buffer_uart[i+3]=='G')&&(buffer_uart[i+4]=='R')&&(buffer_uart[i+5]==':')&&(buffer_uart[i+6]==' ')&&(buffer_uart[i+7]=='0')&&(buffer_uart[i+8]==',')&&(buffer_uart[i+9]==',')&&(buffer_uart[i+10]=='0'))  
5482:  CLRF   03
5484:  MOVF   x92,W
5486:  ADDLW  4E
5488:  MOVWF  FE9
548A:  MOVLW  01
548C:  ADDWFC 03,W
548E:  MOVWF  FEA
5490:  MOVF   FEF,W
5492:  SUBLW  2B
5494:  BTFSS  FD8.2
5496:  BRA    55C4
5498:  MOVLW  01
549A:  ADDWF  x92,W
549C:  CLRF   03
549E:  ADDLW  4E
54A0:  MOVWF  FE9
54A2:  MOVLW  01
54A4:  ADDWFC 03,W
54A6:  MOVWF  FEA
54A8:  MOVF   FEF,W
54AA:  SUBLW  43
54AC:  BTFSS  FD8.2
54AE:  BRA    55C4
54B0:  MOVLW  02
54B2:  ADDWF  x92,W
54B4:  CLRF   03
54B6:  ADDLW  4E
54B8:  MOVWF  FE9
54BA:  MOVLW  01
54BC:  ADDWFC 03,W
54BE:  MOVWF  FEA
54C0:  MOVF   FEF,W
54C2:  SUBLW  4D
54C4:  BTFSS  FD8.2
54C6:  BRA    55C4
54C8:  MOVLW  03
54CA:  ADDWF  x92,W
54CC:  CLRF   03
54CE:  ADDLW  4E
54D0:  MOVWF  FE9
54D2:  MOVLW  01
54D4:  ADDWFC 03,W
54D6:  MOVWF  FEA
54D8:  MOVF   FEF,W
54DA:  SUBLW  47
54DC:  BTFSS  FD8.2
54DE:  BRA    55C4
54E0:  MOVLW  04
54E2:  ADDWF  x92,W
54E4:  CLRF   03
54E6:  ADDLW  4E
54E8:  MOVWF  FE9
54EA:  MOVLW  01
54EC:  ADDWFC 03,W
54EE:  MOVWF  FEA
54F0:  MOVF   FEF,W
54F2:  SUBLW  52
54F4:  BNZ   55C4
54F6:  MOVLW  05
54F8:  ADDWF  x92,W
54FA:  CLRF   03
54FC:  ADDLW  4E
54FE:  MOVWF  FE9
5500:  MOVLW  01
5502:  ADDWFC 03,W
5504:  MOVWF  FEA
5506:  MOVF   FEF,W
5508:  SUBLW  3A
550A:  BNZ   55C4
550C:  MOVLW  06
550E:  ADDWF  x92,W
5510:  CLRF   03
5512:  ADDLW  4E
5514:  MOVWF  FE9
5516:  MOVLW  01
5518:  ADDWFC 03,W
551A:  MOVWF  FEA
551C:  MOVF   FEF,W
551E:  SUBLW  20
5520:  BNZ   55C4
5522:  MOVLW  07
5524:  ADDWF  x92,W
5526:  CLRF   03
5528:  ADDLW  4E
552A:  MOVWF  FE9
552C:  MOVLW  01
552E:  ADDWFC 03,W
5530:  MOVWF  FEA
5532:  MOVF   FEF,W
5534:  SUBLW  30
5536:  BNZ   55C4
5538:  MOVLW  08
553A:  ADDWF  x92,W
553C:  CLRF   03
553E:  ADDLW  4E
5540:  MOVWF  FE9
5542:  MOVLW  01
5544:  ADDWFC 03,W
5546:  MOVWF  FEA
5548:  MOVF   FEF,W
554A:  SUBLW  2C
554C:  BNZ   55C4
554E:  MOVLW  09
5550:  ADDWF  x92,W
5552:  CLRF   03
5554:  ADDLW  4E
5556:  MOVWF  FE9
5558:  MOVLW  01
555A:  ADDWFC 03,W
555C:  MOVWF  FEA
555E:  MOVF   FEF,W
5560:  SUBLW  2C
5562:  BNZ   55C4
5564:  MOVLW  0A
5566:  ADDWF  x92,W
5568:  CLRF   03
556A:  ADDLW  4E
556C:  MOVWF  FE9
556E:  MOVLW  01
5570:  ADDWFC 03,W
5572:  MOVWF  FEA
5574:  MOVF   FEF,W
5576:  SUBLW  30
5578:  BNZ   55C4
....................       { 
....................          st=0; 
557A:  CLRF   x98
....................          i=200; 
557C:  MOVLW  C8
557E:  MOVWF  x92
5580:  CLRF   19
5582:  BTFSC  FF2.7
5584:  BSF    19.7
5586:  BCF    FF2.7
....................          del_buf(100,MSG); 
5588:  MOVLW  64
558A:  MOVWF  xC5
558C:  MOVFF  A8F,AC7
5590:  MOVFF  A8E,AC6
5594:  MOVLB  0
5596:  CALL   3A62
559A:  BTFSC  19.7
559C:  BSF    FF2.7
559E:  CLRF   19
55A0:  BTFSC  FF2.7
55A2:  BSF    19.7
55A4:  BCF    FF2.7
....................          del_buf(16,mobile_number); 
55A6:  MOVLW  10
55A8:  MOVLB  A
55AA:  MOVWF  xC5
55AC:  MOVFF  A91,AC7
55B0:  MOVFF  A90,AC6
55B4:  MOVLB  0
55B6:  CALL   3A62
55BA:  BTFSC  19.7
55BC:  BSF    FF2.7
....................          count_spam=0; 
55BE:  MOVLB  1
55C0:  CLRF   x04
55C2:  MOVLB  A
....................          //output_toggle(pin_a5); 
....................       } 
....................          //else st=2; 
....................      temp = buffer_uart[i]; 
55C4:  CLRF   03
55C6:  MOVF   x92,W
55C8:  ADDLW  4E
55CA:  MOVWF  FE9
55CC:  MOVLW  01
55CE:  ADDWFC 03,W
55D0:  MOVWF  FEA
55D2:  MOVFF  FEF,A99
....................      if((a==3))  
55D6:  MOVF   x93,W
55D8:  SUBLW  03
55DA:  BNZ   5602
....................      { 
....................        if((temp>47)&&(temp<58)||temp=='+') mobile_number[i-b] = temp; 
55DC:  MOVF   x99,W
55DE:  SUBLW  2F
55E0:  BC    55E8
55E2:  MOVF   x99,W
55E4:  SUBLW  39
55E6:  BC    55EE
55E8:  MOVF   x99,W
55EA:  SUBLW  2B
55EC:  BNZ   5602
55EE:  MOVF   x94,W
55F0:  SUBWF  x92,W
55F2:  CLRF   03
55F4:  ADDWF  x90,W
55F6:  MOVWF  FE9
55F8:  MOVF   x91,W
55FA:  ADDWFC 03,W
55FC:  MOVWF  FEA
55FE:  MOVFF  A99,FEF
....................      } 
....................      if(d==2) 
5602:  MOVF   x95,W
5604:  SUBLW  02
5606:  BNZ   5620
....................      { 
....................          MSG[i-b] = temp; 
5608:  MOVF   x94,W
560A:  SUBWF  x92,W
560C:  CLRF   03
560E:  ADDWF  x8E,W
5610:  MOVWF  FE9
5612:  MOVF   x8F,W
5614:  ADDWFC 03,W
5616:  MOVWF  FEA
5618:  MOVFF  A99,FEF
....................          st=1; 
561C:  MOVLW  01
561E:  MOVWF  x98
....................      } 
....................      if(u==2) 
5620:  MOVF   x96,W
5622:  SUBLW  02
5624:  BNZ   563A
....................      { 
....................          datetime[i-v]=temp; 
5626:  MOVF   x97,W
5628:  SUBWF  x92,W
562A:  CLRF   03
562C:  ADDLW  60
562E:  MOVWF  FE9
5630:  MOVLW  04
5632:  ADDWFC 03,W
5634:  MOVWF  FEA
5636:  MOVFF  A99,FEF
....................      } 
....................       //else st=2; 
....................      if(temp==34)  
563A:  MOVF   x99,W
563C:  SUBLW  22
563E:  BNZ   5654
....................      { 
....................          if(a<6)a++; 
5640:  MOVF   x93,W
5642:  SUBLW  05
5644:  BTFSC  FD8.0
5646:  INCF   x93,F
....................          if(a==3) b = i+1; 
5648:  MOVF   x93,W
564A:  SUBLW  03
564C:  BNZ   5654
564E:  MOVLW  01
5650:  ADDWF  x92,W
5652:  MOVWF  x94
....................      } 
....................      if(a==6) 
5654:  MOVF   x93,W
5656:  SUBLW  06
5658:  BNZ   5688
....................      { 
....................          if((temp==13)||(temp==10))  
565A:  MOVF   x99,W
565C:  SUBLW  0D
565E:  BZ    5666
5660:  MOVF   x99,W
5662:  SUBLW  0A
5664:  BNZ   5674
....................          { 
....................             d++; 
5666:  INCF   x95,F
....................             if(d==2) b = i+1; 
5668:  MOVF   x95,W
566A:  SUBLW  02
566C:  BNZ   5674
566E:  MOVLW  01
5670:  ADDWF  x92,W
5672:  MOVWF  x94
....................          } 
....................          if(temp==34)  
5674:  MOVF   x99,W
5676:  SUBLW  22
5678:  BNZ   5688
....................          { 
....................             u++; 
567A:  INCF   x96,F
....................             if(u==2)v=i+1; 
567C:  MOVF   x96,W
567E:  SUBLW  02
5680:  BNZ   5688
5682:  MOVLW  01
5684:  ADDWF  x92,W
5686:  MOVWF  x97
....................          } 
....................      } 
....................      //if((temp==',')&&(a==6)) 
....................     // { 
....................          //if(c<2)c++; 
....................      //} 
....................    } 
5688:  INCF   x92,F
568A:  BRA    547A
....................    return(st); 
568C:  MOVFF  A98,01
.................... } 
5690:  MOVLB  0
5692:  GOTO   7492 (RETURN)
.................... //================================ 
.................... int8 ascii2int(int8 num1,int8 num2) 
.................... { 
....................    int8 temp; 
....................    temp=(num1-48)*10 + (num2-48); 
*
582E:  MOVLW  30
5830:  MOVLB  A
5832:  SUBWF  x8F,W
5834:  MULLW  0A
5836:  MOVFF  FF3,A92
583A:  MOVLW  30
583C:  SUBWF  x90,W
583E:  ADDWF  x92,W
5840:  MOVWF  x91
....................    return temp; 
5842:  MOVFF  A91,01
.................... } 
5846:  MOVLB  0
5848:  RETURN 0
.................... //================================ 
.................... void updatetime2ds1307() 
.................... { 
....................    int8 temp; 
....................    year=ascii2int(datetime[0],datetime[1]); 
*
59E0:  MOVFF  460,A8F
59E4:  MOVFF  461,A90
59E8:  RCALL  582E
59EA:  MOVFF  01,FE
....................    mon=ascii2int(datetime[3],datetime[4]); 
59EE:  MOVFF  463,A8F
59F2:  MOVFF  464,A90
59F6:  RCALL  582E
59F8:  MOVFF  01,FF
....................    date=ascii2int(datetime[6],datetime[7]); 
59FC:  MOVFF  466,A8F
5A00:  MOVFF  467,A90
5A04:  RCALL  582E
5A06:  MOVFF  01,100
....................    h=ascii2int(datetime[9],datetime[10]); 
5A0A:  MOVFF  469,A8F
5A0E:  MOVFF  46A,A90
5A12:  RCALL  582E
5A14:  MOVFF  01,101
....................    min=ascii2int(datetime[12],datetime[13])+1; 
5A18:  MOVFF  46C,A8F
5A1C:  MOVFF  46D,A90
5A20:  RCALL  582E
5A22:  MOVLW  01
5A24:  ADDWF  01,W
5A26:  MOVLB  1
5A28:  MOVWF  x02
....................    //h=ascii2int(datetime[9],datetime[10]); 
....................    rtc_set_datetime(date,mon,year,day,h,min); 
5A2A:  MOVFF  100,A8F
5A2E:  MOVFF  FF,A90
5A32:  MOVFF  FE,A91
5A36:  MOVFF  FD,A92
5A3A:  MOVFF  101,A93
5A3E:  MOVFF  102,A94
5A42:  MOVLB  0
5A44:  BRA    5936
.................... } 
5A46:  RETURN 0
.................... //================================ 
....................  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
.................... { 
*
07C0:  MOVLB  A
07C2:  CLRF   xEF
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
07C4:  CLRF   xF0
07C6:  BTFSC  xE7.0
07C8:  BSF    xF0.7
07CA:  SWAPF  xE8,W
07CC:  MOVWF  00
07CE:  RLCF   00,F
07D0:  RLCF   00,F
07D2:  MOVLW  C0
07D4:  ANDWF  00,F
07D6:  MOVF   00,W
07D8:  IORWF  xF0,F
07DA:  SWAPF  xE9,W
07DC:  MOVWF  00
07DE:  RLCF   00,F
07E0:  MOVLW  E0
07E2:  ANDWF  00,F
07E4:  MOVF   00,W
07E6:  IORWF  xF0,F
07E8:  SWAPF  xEA,W
07EA:  MOVWF  00
07EC:  MOVLW  F0
07EE:  ANDWF  00,F
07F0:  MOVF   00,W
07F2:  IORWF  xF0,F
07F4:  RLCF   xEB,W
07F6:  MOVWF  00
07F8:  RLCF   00,F
07FA:  RLCF   00,F
07FC:  MOVLW  F8
07FE:  ANDWF  00,F
0800:  MOVF   00,W
0802:  IORWF  xF0,F
0804:  RLCF   xEC,W
0806:  MOVWF  00
0808:  RLCF   00,F
080A:  MOVLW  FC
080C:  ANDWF  00,F
080E:  MOVF   00,W
0810:  IORWF  xF0,F
0812:  BCF    FD8.0
0814:  RLCF   xED,W
0816:  IORWF  xF0,F
0818:  MOVF   xEE,W
081A:  IORWF  xF0,W
081C:  MOVWF  xEF
....................    return temp; 
081E:  MOVFF  AEF,01
.................... } 
0822:  MOVLB  0
0824:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
.................... { 
0826:  MOVLB  A
0828:  CLRF   xD7
....................    int8 temp=0; 
....................    if(direct==0) 
082A:  MOVF   xD2,F
082C:  BNZ   0902
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
082E:  MOVF   xD5,W
0830:  ADDWF  xD3,W
0832:  MOVWF  FE9
0834:  MOVF   xD6,W
0836:  ADDWFC xD4,W
0838:  MOVWF  FEA
083A:  MOVFF  FEF,AD8
083E:  MOVLW  01
0840:  ADDWF  xD3,W
0842:  MOVWF  xD9
0844:  MOVLW  00
0846:  ADDWFC xD4,W
0848:  MOVWF  xDA
084A:  MOVF   xD5,W
084C:  ADDWF  xD9,W
084E:  MOVWF  FE9
0850:  MOVF   xD6,W
0852:  ADDWFC xDA,W
0854:  MOVWF  FEA
0856:  MOVF   FEF,W
0858:  XORWF  xD8,F
085A:  MOVLW  02
085C:  ADDWF  xD3,W
085E:  MOVWF  xDB
0860:  MOVLW  00
0862:  ADDWFC xD4,W
0864:  MOVWF  xDC
0866:  MOVF   xD5,W
0868:  ADDWF  xDB,W
086A:  MOVWF  FE9
086C:  MOVF   xD6,W
086E:  ADDWFC xDC,W
0870:  MOVWF  FEA
0872:  MOVF   FEF,W
0874:  XORWF  xD8,F
0876:  MOVLW  03
0878:  ADDWF  xD3,W
087A:  MOVWF  xDD
087C:  MOVLW  00
087E:  ADDWFC xD4,W
0880:  MOVWF  xDE
0882:  MOVF   xD5,W
0884:  ADDWF  xDD,W
0886:  MOVWF  FE9
0888:  MOVF   xD6,W
088A:  ADDWFC xDE,W
088C:  MOVWF  FEA
088E:  MOVF   FEF,W
0890:  XORWF  xD8,F
0892:  MOVLW  04
0894:  ADDWF  xD3,W
0896:  MOVWF  xDF
0898:  MOVLW  00
089A:  ADDWFC xD4,W
089C:  MOVWF  xE0
089E:  MOVF   xD5,W
08A0:  ADDWF  xDF,W
08A2:  MOVWF  FE9
08A4:  MOVF   xD6,W
08A6:  ADDWFC xE0,W
08A8:  MOVWF  FEA
08AA:  MOVF   FEF,W
08AC:  XORWF  xD8,F
08AE:  MOVLW  05
08B0:  ADDWF  xD3,W
08B2:  MOVWF  xE1
08B4:  MOVLW  00
08B6:  ADDWFC xD4,W
08B8:  MOVWF  xE2
08BA:  MOVF   xD5,W
08BC:  ADDWF  xE1,W
08BE:  MOVWF  FE9
08C0:  MOVF   xD6,W
08C2:  ADDWFC xE2,W
08C4:  MOVWF  FEA
08C6:  MOVF   FEF,W
08C8:  XORWF  xD8,W
08CA:  BZ    08D0
08CC:  MOVLW  00
08CE:  BRA    08D2
08D0:  MOVLW  01
08D2:  MOVWF  xD7
....................       if(temp==datain[offset+6]) return 1; 
08D4:  MOVLW  06
08D6:  ADDWF  xD3,W
08D8:  MOVWF  xD8
08DA:  MOVLW  00
08DC:  ADDWFC xD4,W
08DE:  MOVWF  xD9
08E0:  MOVF   xD5,W
08E2:  ADDWF  xD8,W
08E4:  MOVWF  FE9
08E6:  MOVF   xD6,W
08E8:  ADDWFC xD9,W
08EA:  MOVWF  FEA
08EC:  MOVF   FEF,W
08EE:  SUBWF  xD7,W
08F0:  BNZ   08FA
08F2:  MOVLW  01
08F4:  MOVWF  01
08F6:  BRA    09D2
....................          else return 0; 
08F8:  BRA    0900
08FA:  MOVLW  00
08FC:  MOVWF  01
08FE:  BRA    09D2
....................    } 
....................       else  
0900:  BRA    09D2
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
0902:  MOVF   xD5,W
0904:  ADDWF  xD3,W
0906:  MOVWF  FE9
0908:  MOVF   xD6,W
090A:  ADDWFC xD4,W
090C:  MOVWF  FEA
090E:  MOVFF  FEF,AD8
0912:  MOVLW  01
0914:  SUBWF  xD3,W
0916:  MOVWF  xD9
0918:  MOVLW  00
091A:  SUBWFB xD4,W
091C:  MOVWF  xDA
091E:  MOVF   xD5,W
0920:  ADDWF  xD9,W
0922:  MOVWF  FE9
0924:  MOVF   xD6,W
0926:  ADDWFC xDA,W
0928:  MOVWF  FEA
092A:  MOVF   FEF,W
092C:  XORWF  xD8,F
092E:  MOVLW  02
0930:  SUBWF  xD3,W
0932:  MOVWF  xDB
0934:  MOVLW  00
0936:  SUBWFB xD4,W
0938:  MOVWF  xDC
093A:  MOVF   xD5,W
093C:  ADDWF  xDB,W
093E:  MOVWF  FE9
0940:  MOVF   xD6,W
0942:  ADDWFC xDC,W
0944:  MOVWF  FEA
0946:  MOVF   FEF,W
0948:  XORWF  xD8,F
094A:  MOVLW  03
094C:  SUBWF  xD3,W
094E:  MOVWF  xDD
0950:  MOVLW  00
0952:  SUBWFB xD4,W
0954:  MOVWF  xDE
0956:  MOVF   xD5,W
0958:  ADDWF  xDD,W
095A:  MOVWF  FE9
095C:  MOVF   xD6,W
095E:  ADDWFC xDE,W
0960:  MOVWF  FEA
0962:  MOVF   FEF,W
0964:  XORWF  xD8,F
0966:  MOVLW  04
0968:  SUBWF  xD3,W
096A:  MOVWF  xDF
096C:  MOVLW  00
096E:  SUBWFB xD4,W
0970:  MOVWF  xE0
0972:  MOVF   xD5,W
0974:  ADDWF  xDF,W
0976:  MOVWF  FE9
0978:  MOVF   xD6,W
097A:  ADDWFC xE0,W
097C:  MOVWF  FEA
097E:  MOVF   FEF,W
0980:  XORWF  xD8,F
0982:  MOVLW  05
0984:  SUBWF  xD3,W
0986:  MOVWF  xE1
0988:  MOVLW  00
098A:  SUBWFB xD4,W
098C:  MOVWF  xE2
098E:  MOVF   xD5,W
0990:  ADDWF  xE1,W
0992:  MOVWF  FE9
0994:  MOVF   xD6,W
0996:  ADDWFC xE2,W
0998:  MOVWF  FEA
099A:  MOVF   FEF,W
099C:  XORWF  xD8,W
099E:  BZ    09A4
09A0:  MOVLW  00
09A2:  BRA    09A6
09A4:  MOVLW  01
09A6:  MOVWF  xD7
....................          if(temp==datain[offset-6]) return 1; 
09A8:  MOVLW  06
09AA:  SUBWF  xD3,W
09AC:  MOVWF  xD8
09AE:  MOVLW  00
09B0:  SUBWFB xD4,W
09B2:  MOVWF  xD9
09B4:  MOVF   xD5,W
09B6:  ADDWF  xD8,W
09B8:  MOVWF  FE9
09BA:  MOVF   xD6,W
09BC:  ADDWFC xD9,W
09BE:  MOVWF  FEA
09C0:  MOVF   FEF,W
09C2:  SUBWF  xD7,W
09C4:  BNZ   09CE
09C6:  MOVLW  01
09C8:  MOVWF  01
09CA:  BRA    09D2
....................             else return 0;          
09CC:  BRA    09D2
09CE:  MOVLW  00
09D0:  MOVWF  01
....................       } 
.................... } 
09D2:  MOVLB  0
09D4:  RETURN 0
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
.................... { 
09D6:  MOVLB  A
09D8:  CLRF   xD7
....................    int8 temp=0; 
....................    if(direct==0) 
09DA:  MOVF   xD2,F
09DC:  BNZ   0A7A
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
09DE:  MOVF   xD5,W
09E0:  ADDWF  xD3,W
09E2:  MOVWF  FE9
09E4:  MOVF   xD6,W
09E6:  ADDWFC xD4,W
09E8:  MOVWF  FEA
09EA:  MOVFF  FEF,AD8
09EE:  MOVLW  01
09F0:  ADDWF  xD3,W
09F2:  MOVWF  xD9
09F4:  MOVLW  00
09F6:  ADDWFC xD4,W
09F8:  MOVWF  xDA
09FA:  MOVF   xD5,W
09FC:  ADDWF  xD9,W
09FE:  MOVWF  FE9
0A00:  MOVF   xD6,W
0A02:  ADDWFC xDA,W
0A04:  MOVWF  FEA
0A06:  MOVF   FEF,W
0A08:  XORWF  xD8,F
0A0A:  MOVLW  02
0A0C:  ADDWF  xD3,W
0A0E:  MOVWF  xDB
0A10:  MOVLW  00
0A12:  ADDWFC xD4,W
0A14:  MOVWF  xDC
0A16:  MOVF   xD5,W
0A18:  ADDWF  xDB,W
0A1A:  MOVWF  FE9
0A1C:  MOVF   xD6,W
0A1E:  ADDWFC xDC,W
0A20:  MOVWF  FEA
0A22:  MOVF   FEF,W
0A24:  XORWF  xD8,F
0A26:  MOVLW  03
0A28:  ADDWF  xD3,W
0A2A:  MOVWF  xDD
0A2C:  MOVLW  00
0A2E:  ADDWFC xD4,W
0A30:  MOVWF  xDE
0A32:  MOVF   xD5,W
0A34:  ADDWF  xDD,W
0A36:  MOVWF  FE9
0A38:  MOVF   xD6,W
0A3A:  ADDWFC xDE,W
0A3C:  MOVWF  FEA
0A3E:  MOVF   FEF,W
0A40:  XORWF  xD8,W
0A42:  BZ    0A48
0A44:  MOVLW  00
0A46:  BRA    0A4A
0A48:  MOVLW  01
0A4A:  MOVWF  xD7
....................       if(temp==datain[offset+4]) return 1; 
0A4C:  MOVLW  04
0A4E:  ADDWF  xD3,W
0A50:  MOVWF  xD8
0A52:  MOVLW  00
0A54:  ADDWFC xD4,W
0A56:  MOVWF  xD9
0A58:  MOVF   xD5,W
0A5A:  ADDWF  xD8,W
0A5C:  MOVWF  FE9
0A5E:  MOVF   xD6,W
0A60:  ADDWFC xD9,W
0A62:  MOVWF  FEA
0A64:  MOVF   FEF,W
0A66:  SUBWF  xD7,W
0A68:  BNZ   0A72
0A6A:  MOVLW  01
0A6C:  MOVWF  01
0A6E:  BRA    0B12
....................          else return 0; 
0A70:  BRA    0A78
0A72:  MOVLW  00
0A74:  MOVWF  01
0A76:  BRA    0B12
....................    } 
....................    else 
0A78:  BRA    0B12
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0A7A:  MOVF   xD5,W
0A7C:  ADDWF  xD3,W
0A7E:  MOVWF  FE9
0A80:  MOVF   xD6,W
0A82:  ADDWFC xD4,W
0A84:  MOVWF  FEA
0A86:  MOVFF  FEF,AD8
0A8A:  MOVLW  01
0A8C:  SUBWF  xD3,W
0A8E:  MOVWF  xD9
0A90:  MOVLW  00
0A92:  SUBWFB xD4,W
0A94:  MOVWF  xDA
0A96:  MOVF   xD5,W
0A98:  ADDWF  xD9,W
0A9A:  MOVWF  FE9
0A9C:  MOVF   xD6,W
0A9E:  ADDWFC xDA,W
0AA0:  MOVWF  FEA
0AA2:  MOVF   FEF,W
0AA4:  XORWF  xD8,F
0AA6:  MOVLW  02
0AA8:  SUBWF  xD3,W
0AAA:  MOVWF  xDB
0AAC:  MOVLW  00
0AAE:  SUBWFB xD4,W
0AB0:  MOVWF  xDC
0AB2:  MOVF   xD5,W
0AB4:  ADDWF  xDB,W
0AB6:  MOVWF  FE9
0AB8:  MOVF   xD6,W
0ABA:  ADDWFC xDC,W
0ABC:  MOVWF  FEA
0ABE:  MOVF   FEF,W
0AC0:  XORWF  xD8,F
0AC2:  MOVLW  03
0AC4:  SUBWF  xD3,W
0AC6:  MOVWF  xDD
0AC8:  MOVLW  00
0ACA:  SUBWFB xD4,W
0ACC:  MOVWF  xDE
0ACE:  MOVF   xD5,W
0AD0:  ADDWF  xDD,W
0AD2:  MOVWF  FE9
0AD4:  MOVF   xD6,W
0AD6:  ADDWFC xDE,W
0AD8:  MOVWF  FEA
0ADA:  MOVF   FEF,W
0ADC:  XORWF  xD8,W
0ADE:  BZ    0AE4
0AE0:  MOVLW  00
0AE2:  BRA    0AE6
0AE4:  MOVLW  01
0AE6:  MOVWF  xD7
....................       if(temp==datain[offset-4]) return 1; 
0AE8:  MOVLW  04
0AEA:  SUBWF  xD3,W
0AEC:  MOVWF  xD8
0AEE:  MOVLW  00
0AF0:  SUBWFB xD4,W
0AF2:  MOVWF  xD9
0AF4:  MOVF   xD5,W
0AF6:  ADDWF  xD8,W
0AF8:  MOVWF  FE9
0AFA:  MOVF   xD6,W
0AFC:  ADDWFC xD9,W
0AFE:  MOVWF  FEA
0B00:  MOVF   FEF,W
0B02:  SUBWF  xD7,W
0B04:  BNZ   0B0E
0B06:  MOVLW  01
0B08:  MOVWF  01
0B0A:  BRA    0B12
....................          else return 0;                
0B0C:  BRA    0B12
0B0E:  MOVLW  00
0B10:  MOVWF  01
....................    } 
.................... } 
0B12:  MOVLB  0
0B14:  RETURN 0
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
.................... { 
0B16:  MOVLB  A
0B18:  CLRF   xCE
0B1A:  CLRF   xCF
0B1C:  CLRF   xD0
0B1E:  CLRF   xD1
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0B20:  CLRF   xCB
0B22:  CLRF   xCA
0B24:  RRCF   xC7,W
0B26:  MOVWF  03
0B28:  RRCF   xC6,W
0B2A:  MOVWF  02
0B2C:  RRCF   03,F
0B2E:  RRCF   02,F
0B30:  MOVLW  3F
0B32:  ANDWF  03,F
0B34:  MOVFF  02,01
0B38:  MOVF   xCB,W
0B3A:  SUBWF  03,W
0B3C:  BTFSS  FD8.0
0B3E:  BRA    10FE
0B40:  BNZ   0B4A
0B42:  MOVF   01,W
0B44:  SUBWF  xCA,W
0B46:  BTFSC  FD8.0
0B48:  BRA    10FE
....................    { 
....................       if(track==0) 
0B4A:  MOVF   xC5,F
0B4C:  BTFSS  FD8.2
0B4E:  BRA    0E84
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0B50:  MOVLW  06
0B52:  ADDWF  xCA,W
0B54:  MOVWF  xD2
0B56:  MOVLW  00
0B58:  ADDWFC xCB,W
0B5A:  MOVWF  xD3
0B5C:  MOVF   xC8,W
0B5E:  ADDWF  xD2,W
0B60:  MOVWF  FE9
0B62:  MOVF   xC9,W
0B64:  ADDWFC xD3,W
0B66:  MOVWF  FEA
0B68:  MOVFF  FEF,AD4
0B6C:  MOVLW  05
0B6E:  ADDWF  xCA,W
0B70:  MOVWF  xD5
0B72:  MOVLW  00
0B74:  ADDWFC xCB,W
0B76:  MOVWF  xD6
0B78:  MOVF   xC8,W
0B7A:  ADDWF  xD5,W
0B7C:  MOVWF  FE9
0B7E:  MOVF   xC9,W
0B80:  ADDWFC xD6,W
0B82:  MOVWF  FEA
0B84:  MOVFF  FEF,AD7
0B88:  MOVLW  04
0B8A:  ADDWF  xCA,W
0B8C:  MOVWF  xD8
0B8E:  MOVLW  00
0B90:  ADDWFC xCB,W
0B92:  MOVWF  xD9
0B94:  MOVF   xC8,W
0B96:  ADDWF  xD8,W
0B98:  MOVWF  FE9
0B9A:  MOVF   xC9,W
0B9C:  ADDWFC xD9,W
0B9E:  MOVWF  FEA
0BA0:  MOVFF  FEF,ADA
0BA4:  MOVLW  03
0BA6:  ADDWF  xCA,W
0BA8:  MOVWF  xDB
0BAA:  MOVLW  00
0BAC:  ADDWFC xCB,W
0BAE:  MOVWF  xDC
0BB0:  MOVF   xC8,W
0BB2:  ADDWF  xDB,W
0BB4:  MOVWF  FE9
0BB6:  MOVF   xC9,W
0BB8:  ADDWFC xDC,W
0BBA:  MOVWF  FEA
0BBC:  MOVFF  FEF,ADD
0BC0:  MOVLW  02
0BC2:  ADDWF  xCA,W
0BC4:  MOVWF  xDE
0BC6:  MOVLW  00
0BC8:  ADDWFC xCB,W
0BCA:  MOVWF  xDF
0BCC:  MOVF   xC8,W
0BCE:  ADDWF  xDE,W
0BD0:  MOVWF  FE9
0BD2:  MOVF   xC9,W
0BD4:  ADDWFC xDF,W
0BD6:  MOVWF  FEA
0BD8:  MOVFF  FEF,AE0
0BDC:  MOVLW  01
0BDE:  ADDWF  xCA,W
0BE0:  MOVWF  xE1
0BE2:  MOVLW  00
0BE4:  ADDWFC xCB,W
0BE6:  MOVWF  xE2
0BE8:  MOVF   xC8,W
0BEA:  ADDWF  xE1,W
0BEC:  MOVWF  FE9
0BEE:  MOVF   xC9,W
0BF0:  ADDWFC xE2,W
0BF2:  MOVWF  FEA
0BF4:  MOVFF  FEF,AE3
0BF8:  MOVF   xC8,W
0BFA:  ADDWF  xCA,W
0BFC:  MOVWF  FE9
0BFE:  MOVF   xC9,W
0C00:  ADDWFC xCB,W
0C02:  MOVWF  FEA
0C04:  MOVFF  FEF,AE4
0C08:  CLRF   xE7
0C0A:  MOVFF  AD4,AE8
0C0E:  MOVFF  AD7,AE9
0C12:  MOVFF  ADA,AEA
0C16:  MOVFF  ADD,AEB
0C1A:  MOVFF  AE0,AEC
0C1E:  MOVFF  AE3,AED
0C22:  MOVFF  AE4,AEE
0C26:  MOVLB  0
0C28:  RCALL  07C0
0C2A:  MOVFF  01,ACE
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0C2E:  MOVLW  0D
0C30:  MOVLB  A
0C32:  ADDWF  xCA,W
0C34:  MOVWF  xD2
0C36:  MOVLW  00
0C38:  ADDWFC xCB,W
0C3A:  MOVWF  xD3
0C3C:  MOVF   xC8,W
0C3E:  ADDWF  xD2,W
0C40:  MOVWF  FE9
0C42:  MOVF   xC9,W
0C44:  ADDWFC xD3,W
0C46:  MOVWF  FEA
0C48:  MOVFF  FEF,AD4
0C4C:  MOVLW  0C
0C4E:  ADDWF  xCA,W
0C50:  MOVWF  xD5
0C52:  MOVLW  00
0C54:  ADDWFC xCB,W
0C56:  MOVWF  xD6
0C58:  MOVF   xC8,W
0C5A:  ADDWF  xD5,W
0C5C:  MOVWF  FE9
0C5E:  MOVF   xC9,W
0C60:  ADDWFC xD6,W
0C62:  MOVWF  FEA
0C64:  MOVFF  FEF,AD7
0C68:  MOVLW  0B
0C6A:  ADDWF  xCA,W
0C6C:  MOVWF  xD8
0C6E:  MOVLW  00
0C70:  ADDWFC xCB,W
0C72:  MOVWF  xD9
0C74:  MOVF   xC8,W
0C76:  ADDWF  xD8,W
0C78:  MOVWF  FE9
0C7A:  MOVF   xC9,W
0C7C:  ADDWFC xD9,W
0C7E:  MOVWF  FEA
0C80:  MOVFF  FEF,ADA
0C84:  MOVLW  0A
0C86:  ADDWF  xCA,W
0C88:  MOVWF  xDB
0C8A:  MOVLW  00
0C8C:  ADDWFC xCB,W
0C8E:  MOVWF  xDC
0C90:  MOVF   xC8,W
0C92:  ADDWF  xDB,W
0C94:  MOVWF  FE9
0C96:  MOVF   xC9,W
0C98:  ADDWFC xDC,W
0C9A:  MOVWF  FEA
0C9C:  MOVFF  FEF,ADD
0CA0:  MOVLW  09
0CA2:  ADDWF  xCA,W
0CA4:  MOVWF  xDE
0CA6:  MOVLW  00
0CA8:  ADDWFC xCB,W
0CAA:  MOVWF  xDF
0CAC:  MOVF   xC8,W
0CAE:  ADDWF  xDE,W
0CB0:  MOVWF  FE9
0CB2:  MOVF   xC9,W
0CB4:  ADDWFC xDF,W
0CB6:  MOVWF  FEA
0CB8:  MOVFF  FEF,AE0
0CBC:  MOVLW  08
0CBE:  ADDWF  xCA,W
0CC0:  MOVWF  xE1
0CC2:  MOVLW  00
0CC4:  ADDWFC xCB,W
0CC6:  MOVWF  xE2
0CC8:  MOVF   xC8,W
0CCA:  ADDWF  xE1,W
0CCC:  MOVWF  FE9
0CCE:  MOVF   xC9,W
0CD0:  ADDWFC xE2,W
0CD2:  MOVWF  FEA
0CD4:  MOVFF  FEF,AE3
0CD8:  MOVLW  07
0CDA:  ADDWF  xCA,W
0CDC:  MOVWF  xE4
0CDE:  MOVLW  00
0CE0:  ADDWFC xCB,W
0CE2:  MOVWF  xE5
0CE4:  MOVF   xC8,W
0CE6:  ADDWF  xE4,W
0CE8:  MOVWF  FE9
0CEA:  MOVF   xC9,W
0CEC:  ADDWFC xE5,W
0CEE:  MOVWF  FEA
0CF0:  MOVFF  FEF,AE6
0CF4:  CLRF   xE7
0CF6:  MOVFF  AD4,AE8
0CFA:  MOVFF  AD7,AE9
0CFE:  MOVFF  ADA,AEA
0D02:  MOVFF  ADD,AEB
0D06:  MOVFF  AE0,AEC
0D0A:  MOVFF  AE3,AED
0D0E:  MOVFF  AE6,AEE
0D12:  MOVLB  0
0D14:  RCALL  07C0
0D16:  MOVFF  01,ACF
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0D1A:  MOVLB  A
0D1C:  MOVF   xCE,W
0D1E:  SUBLW  45
0D20:  BTFSS  FD8.2
0D22:  BRA    0E82
0D24:  MOVF   xCF,W
0D26:  SUBLW  7C
0D28:  BTFSC  FD8.2
0D2A:  BRA    0E82
0D2C:  MOVF   xCF,W
0D2E:  SUBLW  3E
0D30:  BTFSC  FD8.2
0D32:  BRA    0E82
0D34:  MOVF   xCF,W
0D36:  SUBLW  1F
0D38:  BTFSC  FD8.2
0D3A:  BRA    0E82
....................          { 
....................             j=i; 
0D3C:  MOVFF  ACB,ACD
0D40:  MOVFF  ACA,ACC
....................             CRC=1; 
0D44:  MOVLW  01
0D46:  MOVWF  xD1
....................             temp2=temp; 
0D48:  MOVFF  ACE,AD0
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
....................             { 
0D4C:  MOVF   xD0,W
0D4E:  SUBLW  1F
0D50:  BTFSC  FD8.2
0D52:  BRA    0E6C
0D54:  MOVF   xCD,W
0D56:  SUBLW  03
0D58:  BTFSS  FD8.0
0D5A:  BRA    0E6C
0D5C:  BNZ   0D66
0D5E:  MOVF   xCC,W
0D60:  SUBLW  E7
0D62:  BTFSS  FD8.0
0D64:  BRA    0E6C
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0D66:  CLRF   xD2
0D68:  MOVFF  ACD,AD4
0D6C:  MOVFF  ACC,AD3
0D70:  MOVFF  AC9,AD6
0D74:  MOVFF  AC8,AD5
0D78:  MOVLB  0
0D7A:  RCALL  0826
0D7C:  MOVF   01,W
0D7E:  MOVLB  A
0D80:  ANDWF  xD1,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0D82:  MOVLW  06
0D84:  ADDWF  xCC,W
0D86:  MOVWF  xD2
0D88:  MOVLW  00
0D8A:  ADDWFC xCD,W
0D8C:  MOVWF  xD3
0D8E:  MOVF   xC8,W
0D90:  ADDWF  xD2,W
0D92:  MOVWF  FE9
0D94:  MOVF   xC9,W
0D96:  ADDWFC xD3,W
0D98:  MOVWF  FEA
0D9A:  MOVFF  FEF,AD4
0D9E:  MOVLW  05
0DA0:  ADDWF  xCC,W
0DA2:  MOVWF  xD5
0DA4:  MOVLW  00
0DA6:  ADDWFC xCD,W
0DA8:  MOVWF  xD6
0DAA:  MOVF   xC8,W
0DAC:  ADDWF  xD5,W
0DAE:  MOVWF  FE9
0DB0:  MOVF   xC9,W
0DB2:  ADDWFC xD6,W
0DB4:  MOVWF  FEA
0DB6:  MOVFF  FEF,AD7
0DBA:  MOVLW  04
0DBC:  ADDWF  xCC,W
0DBE:  MOVWF  xD8
0DC0:  MOVLW  00
0DC2:  ADDWFC xCD,W
0DC4:  MOVWF  xD9
0DC6:  MOVF   xC8,W
0DC8:  ADDWF  xD8,W
0DCA:  MOVWF  FE9
0DCC:  MOVF   xC9,W
0DCE:  ADDWFC xD9,W
0DD0:  MOVWF  FEA
0DD2:  MOVFF  FEF,ADA
0DD6:  MOVLW  03
0DD8:  ADDWF  xCC,W
0DDA:  MOVWF  xDB
0DDC:  MOVLW  00
0DDE:  ADDWFC xCD,W
0DE0:  MOVWF  xDC
0DE2:  MOVF   xC8,W
0DE4:  ADDWF  xDB,W
0DE6:  MOVWF  FE9
0DE8:  MOVF   xC9,W
0DEA:  ADDWFC xDC,W
0DEC:  MOVWF  FEA
0DEE:  MOVFF  FEF,ADD
0DF2:  MOVLW  02
0DF4:  ADDWF  xCC,W
0DF6:  MOVWF  xDE
0DF8:  MOVLW  00
0DFA:  ADDWFC xCD,W
0DFC:  MOVWF  xDF
0DFE:  MOVF   xC8,W
0E00:  ADDWF  xDE,W
0E02:  MOVWF  FE9
0E04:  MOVF   xC9,W
0E06:  ADDWFC xDF,W
0E08:  MOVWF  FEA
0E0A:  MOVFF  FEF,AE0
0E0E:  MOVLW  01
0E10:  ADDWF  xCC,W
0E12:  MOVWF  xE1
0E14:  MOVLW  00
0E16:  ADDWFC xCD,W
0E18:  MOVWF  xE2
0E1A:  MOVF   xC8,W
0E1C:  ADDWF  xE1,W
0E1E:  MOVWF  FE9
0E20:  MOVF   xC9,W
0E22:  ADDWFC xE2,W
0E24:  MOVWF  FEA
0E26:  MOVFF  FEF,AE3
0E2A:  MOVF   xC8,W
0E2C:  ADDWF  xCC,W
0E2E:  MOVWF  FE9
0E30:  MOVF   xC9,W
0E32:  ADDWFC xCD,W
0E34:  MOVWF  FEA
0E36:  MOVFF  FEF,AE4
0E3A:  CLRF   xE7
0E3C:  MOVFF  AD4,AE8
0E40:  MOVFF  AD7,AE9
0E44:  MOVFF  ADA,AEA
0E48:  MOVFF  ADD,AEB
0E4C:  MOVFF  AE0,AEC
0E50:  MOVFF  AE3,AED
0E54:  MOVFF  AE4,AEE
0E58:  MOVLB  0
0E5A:  RCALL  07C0
0E5C:  MOVFF  01,AD0
....................                j=j+7; 
0E60:  MOVLW  07
0E62:  MOVLB  A
0E64:  ADDWF  xCC,F
0E66:  MOVLW  00
0E68:  ADDWFC xCD,F
....................             } 
0E6A:  BRA    0D4C
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0E6C:  DECFSZ xD1,W
0E6E:  BRA    0E82
....................             { 
....................                dir=0; 
0E70:  MOVLB  9
0E72:  CLRF   x99
....................                return i; 
0E74:  MOVLB  A
0E76:  MOVFF  ACA,01
0E7A:  MOVFF  ACB,02
0E7E:  GOTO   1714
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else  
0E82:  BRA    10F6
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0E84:  MOVLW  04
0E86:  ADDWF  xCA,W
0E88:  MOVWF  xD2
0E8A:  MOVLW  00
0E8C:  ADDWFC xCB,W
0E8E:  MOVWF  xD3
0E90:  MOVF   xC8,W
0E92:  ADDWF  xD2,W
0E94:  MOVWF  FE9
0E96:  MOVF   xC9,W
0E98:  ADDWFC xD3,W
0E9A:  MOVWF  FEA
0E9C:  MOVFF  FEF,AD4
0EA0:  MOVLW  03
0EA2:  ADDWF  xCA,W
0EA4:  MOVWF  xD5
0EA6:  MOVLW  00
0EA8:  ADDWFC xCB,W
0EAA:  MOVWF  xD6
0EAC:  MOVF   xC8,W
0EAE:  ADDWF  xD5,W
0EB0:  MOVWF  FE9
0EB2:  MOVF   xC9,W
0EB4:  ADDWFC xD6,W
0EB6:  MOVWF  FEA
0EB8:  MOVFF  FEF,AD7
0EBC:  MOVLW  02
0EBE:  ADDWF  xCA,W
0EC0:  MOVWF  xD8
0EC2:  MOVLW  00
0EC4:  ADDWFC xCB,W
0EC6:  MOVWF  xD9
0EC8:  MOVF   xC8,W
0ECA:  ADDWF  xD8,W
0ECC:  MOVWF  FE9
0ECE:  MOVF   xC9,W
0ED0:  ADDWFC xD9,W
0ED2:  MOVWF  FEA
0ED4:  MOVFF  FEF,ADA
0ED8:  MOVLW  01
0EDA:  ADDWF  xCA,W
0EDC:  MOVWF  xDB
0EDE:  MOVLW  00
0EE0:  ADDWFC xCB,W
0EE2:  MOVWF  xDC
0EE4:  MOVF   xC8,W
0EE6:  ADDWF  xDB,W
0EE8:  MOVWF  FE9
0EEA:  MOVF   xC9,W
0EEC:  ADDWFC xDC,W
0EEE:  MOVWF  FEA
0EF0:  MOVFF  FEF,ADD
0EF4:  MOVF   xC8,W
0EF6:  ADDWF  xCA,W
0EF8:  MOVWF  FE9
0EFA:  MOVF   xC9,W
0EFC:  ADDWFC xCB,W
0EFE:  MOVWF  FEA
0F00:  MOVFF  FEF,ADE
0F04:  CLRF   xE7
0F06:  CLRF   xE8
0F08:  CLRF   xE9
0F0A:  MOVFF  AD4,AEA
0F0E:  MOVFF  AD7,AEB
0F12:  MOVFF  ADA,AEC
0F16:  MOVFF  ADD,AED
0F1A:  MOVFF  ADE,AEE
0F1E:  MOVLB  0
0F20:  RCALL  07C0
0F22:  MOVFF  01,ACE
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0F26:  MOVLW  09
0F28:  MOVLB  A
0F2A:  ADDWF  xCA,W
0F2C:  MOVWF  xD2
0F2E:  MOVLW  00
0F30:  ADDWFC xCB,W
0F32:  MOVWF  xD3
0F34:  MOVF   xC8,W
0F36:  ADDWF  xD2,W
0F38:  MOVWF  FE9
0F3A:  MOVF   xC9,W
0F3C:  ADDWFC xD3,W
0F3E:  MOVWF  FEA
0F40:  MOVFF  FEF,AD4
0F44:  MOVLW  08
0F46:  ADDWF  xCA,W
0F48:  MOVWF  xD5
0F4A:  MOVLW  00
0F4C:  ADDWFC xCB,W
0F4E:  MOVWF  xD6
0F50:  MOVF   xC8,W
0F52:  ADDWF  xD5,W
0F54:  MOVWF  FE9
0F56:  MOVF   xC9,W
0F58:  ADDWFC xD6,W
0F5A:  MOVWF  FEA
0F5C:  MOVFF  FEF,AD7
0F60:  MOVLW  07
0F62:  ADDWF  xCA,W
0F64:  MOVWF  xD8
0F66:  MOVLW  00
0F68:  ADDWFC xCB,W
0F6A:  MOVWF  xD9
0F6C:  MOVF   xC8,W
0F6E:  ADDWF  xD8,W
0F70:  MOVWF  FE9
0F72:  MOVF   xC9,W
0F74:  ADDWFC xD9,W
0F76:  MOVWF  FEA
0F78:  MOVFF  FEF,ADA
0F7C:  MOVLW  06
0F7E:  ADDWF  xCA,W
0F80:  MOVWF  xDB
0F82:  MOVLW  00
0F84:  ADDWFC xCB,W
0F86:  MOVWF  xDC
0F88:  MOVF   xC8,W
0F8A:  ADDWF  xDB,W
0F8C:  MOVWF  FE9
0F8E:  MOVF   xC9,W
0F90:  ADDWFC xDC,W
0F92:  MOVWF  FEA
0F94:  MOVFF  FEF,ADD
0F98:  MOVLW  05
0F9A:  ADDWF  xCA,W
0F9C:  MOVWF  xDE
0F9E:  MOVLW  00
0FA0:  ADDWFC xCB,W
0FA2:  MOVWF  xDF
0FA4:  MOVF   xC8,W
0FA6:  ADDWF  xDE,W
0FA8:  MOVWF  FE9
0FAA:  MOVF   xC9,W
0FAC:  ADDWFC xDF,W
0FAE:  MOVWF  FEA
0FB0:  MOVFF  FEF,AE0
0FB4:  CLRF   xE7
0FB6:  CLRF   xE8
0FB8:  CLRF   xE9
0FBA:  MOVFF  AD4,AEA
0FBE:  MOVFF  AD7,AEB
0FC2:  MOVFF  ADA,AEC
0FC6:  MOVFF  ADD,AED
0FCA:  MOVFF  AE0,AEE
0FCE:  MOVLB  0
0FD0:  CALL   07C0
0FD4:  MOVFF  01,ACF
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0FD8:  MOVLB  A
0FDA:  MOVF   xCE,W
0FDC:  SUBLW  0B
0FDE:  BTFSS  FD8.2
0FE0:  BRA    10F6
0FE2:  MOVF   xCF,W
0FE4:  SUBLW  1F
0FE6:  BTFSC  FD8.2
0FE8:  BRA    10F6
0FEA:  MOVF   xCF,W
0FEC:  SUBLW  0F
0FEE:  BTFSC  FD8.2
0FF0:  BRA    10F6
....................             { 
....................                j=i; 
0FF2:  MOVFF  ACB,ACD
0FF6:  MOVFF  ACA,ACC
....................                CRC=1; 
0FFA:  MOVLW  01
0FFC:  MOVWF  xD1
....................                temp2=temp; 
0FFE:  MOVFF  ACE,AD0
....................                while((temp2!=0b00011111)&&(j<500)) 
....................                { 
1002:  MOVF   xD0,W
1004:  SUBLW  1F
1006:  BZ    10E2
1008:  MOVF   xCD,W
100A:  SUBLW  01
100C:  BNC   10E2
100E:  BNZ   1016
1010:  MOVF   xCC,W
1012:  SUBLW  F3
1014:  BNC   10E2
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
1016:  CLRF   xD2
1018:  MOVFF  ACD,AD4
101C:  MOVFF  ACC,AD3
1020:  MOVFF  AC9,AD6
1024:  MOVFF  AC8,AD5
1028:  MOVLB  0
102A:  RCALL  09D6
102C:  MOVF   01,W
102E:  MOVLB  A
1030:  ANDWF  xD1,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
1032:  MOVLW  04
1034:  ADDWF  xCC,W
1036:  MOVWF  xD2
1038:  MOVLW  00
103A:  ADDWFC xCD,W
103C:  MOVWF  xD3
103E:  MOVF   xC8,W
1040:  ADDWF  xD2,W
1042:  MOVWF  FE9
1044:  MOVF   xC9,W
1046:  ADDWFC xD3,W
1048:  MOVWF  FEA
104A:  MOVFF  FEF,AD4
104E:  MOVLW  03
1050:  ADDWF  xCC,W
1052:  MOVWF  xD5
1054:  MOVLW  00
1056:  ADDWFC xCD,W
1058:  MOVWF  xD6
105A:  MOVF   xC8,W
105C:  ADDWF  xD5,W
105E:  MOVWF  FE9
1060:  MOVF   xC9,W
1062:  ADDWFC xD6,W
1064:  MOVWF  FEA
1066:  MOVFF  FEF,AD7
106A:  MOVLW  02
106C:  ADDWF  xCC,W
106E:  MOVWF  xD8
1070:  MOVLW  00
1072:  ADDWFC xCD,W
1074:  MOVWF  xD9
1076:  MOVF   xC8,W
1078:  ADDWF  xD8,W
107A:  MOVWF  FE9
107C:  MOVF   xC9,W
107E:  ADDWFC xD9,W
1080:  MOVWF  FEA
1082:  MOVFF  FEF,ADA
1086:  MOVLW  01
1088:  ADDWF  xCC,W
108A:  MOVWF  xDB
108C:  MOVLW  00
108E:  ADDWFC xCD,W
1090:  MOVWF  xDC
1092:  MOVF   xC8,W
1094:  ADDWF  xDB,W
1096:  MOVWF  FE9
1098:  MOVF   xC9,W
109A:  ADDWFC xDC,W
109C:  MOVWF  FEA
109E:  MOVFF  FEF,ADD
10A2:  MOVF   xC8,W
10A4:  ADDWF  xCC,W
10A6:  MOVWF  FE9
10A8:  MOVF   xC9,W
10AA:  ADDWFC xCD,W
10AC:  MOVWF  FEA
10AE:  MOVFF  FEF,ADE
10B2:  CLRF   xE7
10B4:  CLRF   xE8
10B6:  CLRF   xE9
10B8:  MOVFF  AD4,AEA
10BC:  MOVFF  AD7,AEB
10C0:  MOVFF  ADA,AEC
10C4:  MOVFF  ADD,AED
10C8:  MOVFF  ADE,AEE
10CC:  MOVLB  0
10CE:  CALL   07C0
10D2:  MOVFF  01,AD0
....................                   j=j+5; 
10D6:  MOVLW  05
10D8:  MOVLB  A
10DA:  ADDWF  xCC,F
10DC:  MOVLW  00
10DE:  ADDWFC xCD,F
....................                } 
10E0:  BRA    1002
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
10E2:  DECFSZ xD1,W
10E4:  BRA    10F6
....................                { 
....................                   dir=0; 
10E6:  MOVLB  9
10E8:  CLRF   x99
....................                   return i; 
10EA:  MOVLB  A
10EC:  MOVFF  ACA,01
10F0:  MOVFF  ACB,02
10F4:  BRA    1714
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
....................    } 
10F6:  INCF   xCA,F
10F8:  BTFSC  FD8.2
10FA:  INCF   xCB,F
10FC:  BRA    0B24
....................    for(i=end_point;i>end_point/4;i--) 
10FE:  MOVFF  AC7,ACB
1102:  MOVFF  AC6,ACA
1106:  RRCF   xC7,W
1108:  MOVWF  03
110A:  RRCF   xC6,W
110C:  MOVWF  02
110E:  RRCF   03,F
1110:  RRCF   02,F
1112:  MOVLW  3F
1114:  ANDWF  03,F
1116:  MOVFF  02,01
111A:  MOVF   03,W
111C:  SUBWF  xCB,W
111E:  BTFSS  FD8.0
1120:  BRA    170E
1122:  BNZ   112C
1124:  MOVF   xCA,W
1126:  SUBWF  01,W
1128:  BTFSC  FD8.0
112A:  BRA    170E
....................    { 
....................       if(track==0) 
112C:  MOVF   xC5,F
112E:  BTFSS  FD8.2
1130:  BRA    1484
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1132:  MOVLW  06
1134:  SUBWF  xCA,W
1136:  MOVWF  xD2
1138:  MOVLW  00
113A:  SUBWFB xCB,W
113C:  MOVWF  xD3
113E:  MOVF   xC8,W
1140:  ADDWF  xD2,W
1142:  MOVWF  FE9
1144:  MOVF   xC9,W
1146:  ADDWFC xD3,W
1148:  MOVWF  FEA
114A:  MOVFF  FEF,AD4
114E:  MOVLW  05
1150:  SUBWF  xCA,W
1152:  MOVWF  xD5
1154:  MOVLW  00
1156:  SUBWFB xCB,W
1158:  MOVWF  xD6
115A:  MOVF   xC8,W
115C:  ADDWF  xD5,W
115E:  MOVWF  FE9
1160:  MOVF   xC9,W
1162:  ADDWFC xD6,W
1164:  MOVWF  FEA
1166:  MOVFF  FEF,AD7
116A:  MOVLW  04
116C:  SUBWF  xCA,W
116E:  MOVWF  xD8
1170:  MOVLW  00
1172:  SUBWFB xCB,W
1174:  MOVWF  xD9
1176:  MOVF   xC8,W
1178:  ADDWF  xD8,W
117A:  MOVWF  FE9
117C:  MOVF   xC9,W
117E:  ADDWFC xD9,W
1180:  MOVWF  FEA
1182:  MOVFF  FEF,ADA
1186:  MOVLW  03
1188:  SUBWF  xCA,W
118A:  MOVWF  xDB
118C:  MOVLW  00
118E:  SUBWFB xCB,W
1190:  MOVWF  xDC
1192:  MOVF   xC8,W
1194:  ADDWF  xDB,W
1196:  MOVWF  FE9
1198:  MOVF   xC9,W
119A:  ADDWFC xDC,W
119C:  MOVWF  FEA
119E:  MOVFF  FEF,ADD
11A2:  MOVLW  02
11A4:  SUBWF  xCA,W
11A6:  MOVWF  xDE
11A8:  MOVLW  00
11AA:  SUBWFB xCB,W
11AC:  MOVWF  xDF
11AE:  MOVF   xC8,W
11B0:  ADDWF  xDE,W
11B2:  MOVWF  FE9
11B4:  MOVF   xC9,W
11B6:  ADDWFC xDF,W
11B8:  MOVWF  FEA
11BA:  MOVFF  FEF,AE0
11BE:  MOVLW  01
11C0:  SUBWF  xCA,W
11C2:  MOVWF  xE1
11C4:  MOVLW  00
11C6:  SUBWFB xCB,W
11C8:  MOVWF  xE2
11CA:  MOVF   xC8,W
11CC:  ADDWF  xE1,W
11CE:  MOVWF  FE9
11D0:  MOVF   xC9,W
11D2:  ADDWFC xE2,W
11D4:  MOVWF  FEA
11D6:  MOVFF  FEF,AE3
11DA:  MOVF   xC8,W
11DC:  ADDWF  xCA,W
11DE:  MOVWF  FE9
11E0:  MOVF   xC9,W
11E2:  ADDWFC xCB,W
11E4:  MOVWF  FEA
11E6:  MOVFF  FEF,AE4
11EA:  CLRF   xE7
11EC:  MOVFF  AD4,AE8
11F0:  MOVFF  AD7,AE9
11F4:  MOVFF  ADA,AEA
11F8:  MOVFF  ADD,AEB
11FC:  MOVFF  AE0,AEC
1200:  MOVFF  AE3,AED
1204:  MOVFF  AE4,AEE
1208:  MOVLB  0
120A:  CALL   07C0
120E:  MOVFF  01,ACE
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
1212:  MOVLW  0D
1214:  MOVLB  A
1216:  SUBWF  xCA,W
1218:  MOVWF  xD2
121A:  MOVLW  00
121C:  SUBWFB xCB,W
121E:  MOVWF  xD3
1220:  MOVF   xC8,W
1222:  ADDWF  xD2,W
1224:  MOVWF  FE9
1226:  MOVF   xC9,W
1228:  ADDWFC xD3,W
122A:  MOVWF  FEA
122C:  MOVFF  FEF,AD4
1230:  MOVLW  0C
1232:  SUBWF  xCA,W
1234:  MOVWF  xD5
1236:  MOVLW  00
1238:  SUBWFB xCB,W
123A:  MOVWF  xD6
123C:  MOVF   xC8,W
123E:  ADDWF  xD5,W
1240:  MOVWF  FE9
1242:  MOVF   xC9,W
1244:  ADDWFC xD6,W
1246:  MOVWF  FEA
1248:  MOVFF  FEF,AD7
124C:  MOVLW  0B
124E:  SUBWF  xCA,W
1250:  MOVWF  xD8
1252:  MOVLW  00
1254:  SUBWFB xCB,W
1256:  MOVWF  xD9
1258:  MOVF   xC8,W
125A:  ADDWF  xD8,W
125C:  MOVWF  FE9
125E:  MOVF   xC9,W
1260:  ADDWFC xD9,W
1262:  MOVWF  FEA
1264:  MOVFF  FEF,ADA
1268:  MOVLW  0A
126A:  SUBWF  xCA,W
126C:  MOVWF  xDB
126E:  MOVLW  00
1270:  SUBWFB xCB,W
1272:  MOVWF  xDC
1274:  MOVF   xC8,W
1276:  ADDWF  xDB,W
1278:  MOVWF  FE9
127A:  MOVF   xC9,W
127C:  ADDWFC xDC,W
127E:  MOVWF  FEA
1280:  MOVFF  FEF,ADD
1284:  MOVLW  09
1286:  SUBWF  xCA,W
1288:  MOVWF  xDE
128A:  MOVLW  00
128C:  SUBWFB xCB,W
128E:  MOVWF  xDF
1290:  MOVF   xC8,W
1292:  ADDWF  xDE,W
1294:  MOVWF  FE9
1296:  MOVF   xC9,W
1298:  ADDWFC xDF,W
129A:  MOVWF  FEA
129C:  MOVFF  FEF,AE0
12A0:  MOVLW  08
12A2:  SUBWF  xCA,W
12A4:  MOVWF  xE1
12A6:  MOVLW  00
12A8:  SUBWFB xCB,W
12AA:  MOVWF  xE2
12AC:  MOVF   xC8,W
12AE:  ADDWF  xE1,W
12B0:  MOVWF  FE9
12B2:  MOVF   xC9,W
12B4:  ADDWFC xE2,W
12B6:  MOVWF  FEA
12B8:  MOVFF  FEF,AE3
12BC:  MOVLW  07
12BE:  SUBWF  xCA,W
12C0:  MOVWF  xE4
12C2:  MOVLW  00
12C4:  SUBWFB xCB,W
12C6:  MOVWF  xE5
12C8:  MOVF   xC8,W
12CA:  ADDWF  xE4,W
12CC:  MOVWF  FE9
12CE:  MOVF   xC9,W
12D0:  ADDWFC xE5,W
12D2:  MOVWF  FEA
12D4:  MOVFF  FEF,AE6
12D8:  CLRF   xE7
12DA:  MOVFF  AD4,AE8
12DE:  MOVFF  AD7,AE9
12E2:  MOVFF  ADA,AEA
12E6:  MOVFF  ADD,AEB
12EA:  MOVFF  AE0,AEC
12EE:  MOVFF  AE3,AED
12F2:  MOVFF  AE6,AEE
12F6:  MOVLB  0
12F8:  CALL   07C0
12FC:  MOVFF  01,ACF
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
1300:  MOVLB  A
1302:  MOVF   xCE,W
1304:  SUBLW  45
1306:  BTFSS  FD8.2
1308:  BRA    1482
130A:  MOVF   xCF,W
130C:  SUBLW  7C
130E:  BTFSC  FD8.2
1310:  BRA    1482
1312:  MOVF   xCF,W
1314:  SUBLW  3E
1316:  BTFSC  FD8.2
1318:  BRA    1482
131A:  MOVF   xCF,W
131C:  SUBLW  1F
131E:  BTFSC  FD8.2
1320:  BRA    1482
1322:  MOVF   xCF,W
1324:  SUBLW  0F
1326:  BTFSC  FD8.2
1328:  BRA    1482
132A:  MOVF   xCF,W
132C:  SUBLW  78
132E:  BTFSC  FD8.2
1330:  BRA    1482
....................          { 
....................             j=i; 
1332:  MOVFF  ACB,ACD
1336:  MOVFF  ACA,ACC
....................             CRC=1; 
133A:  MOVLW  01
133C:  MOVWF  xD1
....................             temp2=temp; 
133E:  MOVFF  ACE,AD0
....................              while((temp2!=0b00011111)&&(j>1)) 
....................              { 
1342:  MOVF   xD0,W
1344:  SUBLW  1F
1346:  BTFSC  FD8.2
1348:  BRA    1462
134A:  MOVF   xCD,F
134C:  BNZ   1356
134E:  MOVF   xCC,W
1350:  SUBLW  01
1352:  BTFSC  FD8.0
1354:  BRA    1462
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1356:  MOVLW  01
1358:  MOVWF  xD2
135A:  MOVFF  ACD,AD4
135E:  MOVFF  ACC,AD3
1362:  MOVFF  AC9,AD6
1366:  MOVFF  AC8,AD5
136A:  MOVLB  0
136C:  CALL   0826
1370:  MOVF   01,W
1372:  MOVLB  A
1374:  ANDWF  xD1,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1376:  MOVLW  06
1378:  SUBWF  xCC,W
137A:  MOVWF  xD2
137C:  MOVLW  00
137E:  SUBWFB xCD,W
1380:  MOVWF  xD3
1382:  MOVF   xC8,W
1384:  ADDWF  xD2,W
1386:  MOVWF  FE9
1388:  MOVF   xC9,W
138A:  ADDWFC xD3,W
138C:  MOVWF  FEA
138E:  MOVFF  FEF,AD4
1392:  MOVLW  05
1394:  SUBWF  xCC,W
1396:  MOVWF  xD5
1398:  MOVLW  00
139A:  SUBWFB xCD,W
139C:  MOVWF  xD6
139E:  MOVF   xC8,W
13A0:  ADDWF  xD5,W
13A2:  MOVWF  FE9
13A4:  MOVF   xC9,W
13A6:  ADDWFC xD6,W
13A8:  MOVWF  FEA
13AA:  MOVFF  FEF,AD7
13AE:  MOVLW  04
13B0:  SUBWF  xCC,W
13B2:  MOVWF  xD8
13B4:  MOVLW  00
13B6:  SUBWFB xCD,W
13B8:  MOVWF  xD9
13BA:  MOVF   xC8,W
13BC:  ADDWF  xD8,W
13BE:  MOVWF  FE9
13C0:  MOVF   xC9,W
13C2:  ADDWFC xD9,W
13C4:  MOVWF  FEA
13C6:  MOVFF  FEF,ADA
13CA:  MOVLW  03
13CC:  SUBWF  xCC,W
13CE:  MOVWF  xDB
13D0:  MOVLW  00
13D2:  SUBWFB xCD,W
13D4:  MOVWF  xDC
13D6:  MOVF   xC8,W
13D8:  ADDWF  xDB,W
13DA:  MOVWF  FE9
13DC:  MOVF   xC9,W
13DE:  ADDWFC xDC,W
13E0:  MOVWF  FEA
13E2:  MOVFF  FEF,ADD
13E6:  MOVLW  02
13E8:  SUBWF  xCC,W
13EA:  MOVWF  xDE
13EC:  MOVLW  00
13EE:  SUBWFB xCD,W
13F0:  MOVWF  xDF
13F2:  MOVF   xC8,W
13F4:  ADDWF  xDE,W
13F6:  MOVWF  FE9
13F8:  MOVF   xC9,W
13FA:  ADDWFC xDF,W
13FC:  MOVWF  FEA
13FE:  MOVFF  FEF,AE0
1402:  MOVLW  01
1404:  SUBWF  xCC,W
1406:  MOVWF  xE1
1408:  MOVLW  00
140A:  SUBWFB xCD,W
140C:  MOVWF  xE2
140E:  MOVF   xC8,W
1410:  ADDWF  xE1,W
1412:  MOVWF  FE9
1414:  MOVF   xC9,W
1416:  ADDWFC xE2,W
1418:  MOVWF  FEA
141A:  MOVFF  FEF,AE3
141E:  MOVF   xC8,W
1420:  ADDWF  xCC,W
1422:  MOVWF  FE9
1424:  MOVF   xC9,W
1426:  ADDWFC xCD,W
1428:  MOVWF  FEA
142A:  MOVFF  FEF,AE4
142E:  CLRF   xE7
1430:  MOVFF  AD4,AE8
1434:  MOVFF  AD7,AE9
1438:  MOVFF  ADA,AEA
143C:  MOVFF  ADD,AEB
1440:  MOVFF  AE0,AEC
1444:  MOVFF  AE3,AED
1448:  MOVFF  AE4,AEE
144C:  MOVLB  0
144E:  CALL   07C0
1452:  MOVFF  01,AD0
....................                j=j-7;             
1456:  MOVLW  07
1458:  MOVLB  A
145A:  SUBWF  xCC,F
145C:  MOVLW  00
145E:  SUBWFB xCD,F
....................              } 
1460:  BRA    1342
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
1462:  DECFSZ xD1,W
1464:  BRA    147A
....................             { 
....................                dir=1; 
1466:  MOVLW  01
1468:  MOVLB  9
146A:  MOVWF  x99
....................                return i; 
146C:  MOVLB  A
146E:  MOVFF  ACA,01
1472:  MOVFF  ACB,02
1476:  BRA    1714
....................             } 
....................             else return 0; 
1478:  BRA    1482
147A:  MOVLW  00
147C:  MOVWF  01
147E:  MOVWF  02
1480:  BRA    1714
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
....................          else 
1482:  BRA    1704
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1484:  MOVLW  04
1486:  SUBWF  xCA,W
1488:  MOVWF  xD2
148A:  MOVLW  00
148C:  SUBWFB xCB,W
148E:  MOVWF  xD3
1490:  MOVF   xC8,W
1492:  ADDWF  xD2,W
1494:  MOVWF  FE9
1496:  MOVF   xC9,W
1498:  ADDWFC xD3,W
149A:  MOVWF  FEA
149C:  MOVFF  FEF,AD4
14A0:  MOVLW  03
14A2:  SUBWF  xCA,W
14A4:  MOVWF  xD5
14A6:  MOVLW  00
14A8:  SUBWFB xCB,W
14AA:  MOVWF  xD6
14AC:  MOVF   xC8,W
14AE:  ADDWF  xD5,W
14B0:  MOVWF  FE9
14B2:  MOVF   xC9,W
14B4:  ADDWFC xD6,W
14B6:  MOVWF  FEA
14B8:  MOVFF  FEF,AD7
14BC:  MOVLW  02
14BE:  SUBWF  xCA,W
14C0:  MOVWF  xD8
14C2:  MOVLW  00
14C4:  SUBWFB xCB,W
14C6:  MOVWF  xD9
14C8:  MOVF   xC8,W
14CA:  ADDWF  xD8,W
14CC:  MOVWF  FE9
14CE:  MOVF   xC9,W
14D0:  ADDWFC xD9,W
14D2:  MOVWF  FEA
14D4:  MOVFF  FEF,ADA
14D8:  MOVLW  01
14DA:  SUBWF  xCA,W
14DC:  MOVWF  xDB
14DE:  MOVLW  00
14E0:  SUBWFB xCB,W
14E2:  MOVWF  xDC
14E4:  MOVF   xC8,W
14E6:  ADDWF  xDB,W
14E8:  MOVWF  FE9
14EA:  MOVF   xC9,W
14EC:  ADDWFC xDC,W
14EE:  MOVWF  FEA
14F0:  MOVFF  FEF,ADD
14F4:  MOVF   xC8,W
14F6:  ADDWF  xCA,W
14F8:  MOVWF  FE9
14FA:  MOVF   xC9,W
14FC:  ADDWFC xCB,W
14FE:  MOVWF  FEA
1500:  MOVFF  FEF,ADE
1504:  CLRF   xE7
1506:  CLRF   xE8
1508:  CLRF   xE9
150A:  MOVFF  AD4,AEA
150E:  MOVFF  AD7,AEB
1512:  MOVFF  ADA,AEC
1516:  MOVFF  ADD,AED
151A:  MOVFF  ADE,AEE
151E:  MOVLB  0
1520:  CALL   07C0
1524:  MOVFF  01,ACE
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1528:  MOVLW  09
152A:  MOVLB  A
152C:  SUBWF  xCA,W
152E:  MOVWF  xD2
1530:  MOVLW  00
1532:  SUBWFB xCB,W
1534:  MOVWF  xD3
1536:  MOVF   xC8,W
1538:  ADDWF  xD2,W
153A:  MOVWF  FE9
153C:  MOVF   xC9,W
153E:  ADDWFC xD3,W
1540:  MOVWF  FEA
1542:  MOVFF  FEF,AD4
1546:  MOVLW  08
1548:  SUBWF  xCA,W
154A:  MOVWF  xD5
154C:  MOVLW  00
154E:  SUBWFB xCB,W
1550:  MOVWF  xD6
1552:  MOVF   xC8,W
1554:  ADDWF  xD5,W
1556:  MOVWF  FE9
1558:  MOVF   xC9,W
155A:  ADDWFC xD6,W
155C:  MOVWF  FEA
155E:  MOVFF  FEF,AD7
1562:  MOVLW  07
1564:  SUBWF  xCA,W
1566:  MOVWF  xD8
1568:  MOVLW  00
156A:  SUBWFB xCB,W
156C:  MOVWF  xD9
156E:  MOVF   xC8,W
1570:  ADDWF  xD8,W
1572:  MOVWF  FE9
1574:  MOVF   xC9,W
1576:  ADDWFC xD9,W
1578:  MOVWF  FEA
157A:  MOVFF  FEF,ADA
157E:  MOVLW  06
1580:  SUBWF  xCA,W
1582:  MOVWF  xDB
1584:  MOVLW  00
1586:  SUBWFB xCB,W
1588:  MOVWF  xDC
158A:  MOVF   xC8,W
158C:  ADDWF  xDB,W
158E:  MOVWF  FE9
1590:  MOVF   xC9,W
1592:  ADDWFC xDC,W
1594:  MOVWF  FEA
1596:  MOVFF  FEF,ADD
159A:  MOVLW  05
159C:  SUBWF  xCA,W
159E:  MOVWF  xDE
15A0:  MOVLW  00
15A2:  SUBWFB xCB,W
15A4:  MOVWF  xDF
15A6:  MOVF   xC8,W
15A8:  ADDWF  xDE,W
15AA:  MOVWF  FE9
15AC:  MOVF   xC9,W
15AE:  ADDWFC xDF,W
15B0:  MOVWF  FEA
15B2:  MOVFF  FEF,AE0
15B6:  CLRF   xE7
15B8:  CLRF   xE8
15BA:  CLRF   xE9
15BC:  MOVFF  AD4,AEA
15C0:  MOVFF  AD7,AEB
15C4:  MOVFF  ADA,AEC
15C8:  MOVFF  ADD,AED
15CC:  MOVFF  AE0,AEE
15D0:  MOVLB  0
15D2:  CALL   07C0
15D6:  MOVFF  01,ACF
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
15DA:  MOVLB  A
15DC:  MOVF   xCE,W
15DE:  SUBLW  0B
15E0:  BTFSS  FD8.2
15E2:  BRA    1704
15E4:  MOVF   xCF,W
15E6:  SUBLW  1F
15E8:  BTFSC  FD8.2
15EA:  BRA    1704
15EC:  MOVF   xCF,W
15EE:  SUBLW  0F
15F0:  BTFSC  FD8.2
15F2:  BRA    1704
....................             { 
....................                j=i; 
15F4:  MOVFF  ACB,ACD
15F8:  MOVFF  ACA,ACC
....................                CRC=1; 
15FC:  MOVLW  01
15FE:  MOVWF  xD1
....................                temp2=temp; 
1600:  MOVFF  ACE,AD0
....................                while((temp2!=0b00011111)&&(j>1)) 
....................                { 
1604:  MOVF   xD0,W
1606:  SUBLW  1F
1608:  BZ    16E4
160A:  MOVF   xCD,F
160C:  BNZ   1614
160E:  MOVF   xCC,W
1610:  SUBLW  01
1612:  BC    16E4
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1614:  MOVLW  01
1616:  MOVWF  xD2
1618:  MOVFF  ACD,AD4
161C:  MOVFF  ACC,AD3
1620:  MOVFF  AC9,AD6
1624:  MOVFF  AC8,AD5
1628:  MOVLB  0
162A:  CALL   09D6
162E:  MOVF   01,W
1630:  MOVLB  A
1632:  ANDWF  xD1,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1634:  MOVLW  04
1636:  SUBWF  xCC,W
1638:  MOVWF  xD2
163A:  MOVLW  00
163C:  SUBWFB xCD,W
163E:  MOVWF  xD3
1640:  MOVF   xC8,W
1642:  ADDWF  xD2,W
1644:  MOVWF  FE9
1646:  MOVF   xC9,W
1648:  ADDWFC xD3,W
164A:  MOVWF  FEA
164C:  MOVFF  FEF,AD4
1650:  MOVLW  03
1652:  SUBWF  xCC,W
1654:  MOVWF  xD5
1656:  MOVLW  00
1658:  SUBWFB xCD,W
165A:  MOVWF  xD6
165C:  MOVF   xC8,W
165E:  ADDWF  xD5,W
1660:  MOVWF  FE9
1662:  MOVF   xC9,W
1664:  ADDWFC xD6,W
1666:  MOVWF  FEA
1668:  MOVFF  FEF,AD7
166C:  MOVLW  02
166E:  SUBWF  xCC,W
1670:  MOVWF  xD8
1672:  MOVLW  00
1674:  SUBWFB xCD,W
1676:  MOVWF  xD9
1678:  MOVF   xC8,W
167A:  ADDWF  xD8,W
167C:  MOVWF  FE9
167E:  MOVF   xC9,W
1680:  ADDWFC xD9,W
1682:  MOVWF  FEA
1684:  MOVFF  FEF,ADA
1688:  MOVLW  01
168A:  SUBWF  xCC,W
168C:  MOVWF  xDB
168E:  MOVLW  00
1690:  SUBWFB xCD,W
1692:  MOVWF  xDC
1694:  MOVF   xC8,W
1696:  ADDWF  xDB,W
1698:  MOVWF  FE9
169A:  MOVF   xC9,W
169C:  ADDWFC xDC,W
169E:  MOVWF  FEA
16A0:  MOVFF  FEF,ADD
16A4:  MOVF   xC8,W
16A6:  ADDWF  xCC,W
16A8:  MOVWF  FE9
16AA:  MOVF   xC9,W
16AC:  ADDWFC xCD,W
16AE:  MOVWF  FEA
16B0:  MOVFF  FEF,ADE
16B4:  CLRF   xE7
16B6:  CLRF   xE8
16B8:  CLRF   xE9
16BA:  MOVFF  AD4,AEA
16BE:  MOVFF  AD7,AEB
16C2:  MOVFF  ADA,AEC
16C6:  MOVFF  ADD,AED
16CA:  MOVFF  ADE,AEE
16CE:  MOVLB  0
16D0:  CALL   07C0
16D4:  MOVFF  01,AD0
....................                   j=j-5; 
16D8:  MOVLW  05
16DA:  MOVLB  A
16DC:  SUBWF  xCC,F
16DE:  MOVLW  00
16E0:  SUBWFB xCD,F
....................                } 
16E2:  BRA    1604
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
16E4:  DECFSZ xD1,W
16E6:  BRA    16FC
....................                { 
....................                   dir=1; 
16E8:  MOVLW  01
16EA:  MOVLB  9
16EC:  MOVWF  x99
....................                   return i; 
16EE:  MOVLB  A
16F0:  MOVFF  ACA,01
16F4:  MOVFF  ACB,02
16F8:  BRA    1714
....................                } 
....................                   else return 0; 
16FA:  BRA    1704
16FC:  MOVLW  00
16FE:  MOVWF  01
1700:  MOVWF  02
1702:  BRA    1714
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
....................    } 
1704:  MOVF   xCA,W
1706:  BTFSC  FD8.2
1708:  DECF   xCB,F
170A:  DECF   xCA,F
170C:  BRA    1106
....................    return 0; 
170E:  MOVLW  00
1710:  MOVWF  01
1712:  MOVWF  02
.................... } 
1714:  MOVLB  0
1716:  RETURN 0
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
.................... { 
*
3A84:  MOVLB  A
3A86:  CLRF   xC4
3A88:  MOVLW  01
3A8A:  MOVWF  xC3
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3A8C:  MOVFF  AB9,AC5
3A90:  MOVFF  ABB,AC7
3A94:  MOVFF  ABA,AC6
3A98:  MOVFF  ABD,AC9
3A9C:  MOVFF  ABC,AC8
3AA0:  MOVLB  0
3AA2:  CALL   0B16
3AA6:  MOVFF  02,AC4
3AAA:  MOVFF  01,AC3
....................    if(temp==0) return 0; 
3AAE:  MOVLB  A
3AB0:  MOVF   xC3,F
3AB2:  BNZ   3ABE
3AB4:  MOVF   xC4,F
3AB6:  BNZ   3ABE
3AB8:  MOVLW  00
3ABA:  MOVWF  01
3ABC:  BRA    3E68
....................    j=temp; 
3ABE:  MOVFF  AC4,AC2
3AC2:  MOVFF  AC3,AC1
....................    if(dir==0) 
3AC6:  MOVLB  9
3AC8:  MOVF   x99,F
3ACA:  BTFSS  FD8.2
3ACC:  BRA    3C88
....................    { 
....................       if(track==0) 
3ACE:  MOVLB  A
3AD0:  MOVF   xB9,F
3AD2:  BTFSS  FD8.2
3AD4:  BRA    3BCC
....................       { 
....................             for(i=0;i<79;i++) 
3AD6:  CLRF   xC0
3AD8:  MOVF   xC0,W
3ADA:  SUBLW  4E
3ADC:  BNC   3BCA
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3ADE:  CLRF   03
3AE0:  MOVF   xC0,W
3AE2:  ADDWF  xBE,W
3AE4:  MOVWF  01
3AE6:  MOVF   xBF,W
3AE8:  ADDWFC 03,F
3AEA:  MOVFF  01,AC5
3AEE:  MOVFF  03,AC6
3AF2:  MOVLW  05
3AF4:  ADDWF  xC1,W
3AF6:  MOVWF  xC7
3AF8:  MOVLW  00
3AFA:  ADDWFC xC2,W
3AFC:  MOVWF  xC8
3AFE:  MOVF   xBC,W
3B00:  ADDWF  xC7,W
3B02:  MOVWF  FE9
3B04:  MOVF   xBD,W
3B06:  ADDWFC xC8,W
3B08:  MOVWF  FEA
3B0A:  MOVFF  FEF,AC9
3B0E:  MOVLW  04
3B10:  ADDWF  xC1,W
3B12:  MOVWF  xCA
3B14:  MOVLW  00
3B16:  ADDWFC xC2,W
3B18:  MOVWF  xCB
3B1A:  MOVF   xBC,W
3B1C:  ADDWF  xCA,W
3B1E:  MOVWF  FE9
3B20:  MOVF   xBD,W
3B22:  ADDWFC xCB,W
3B24:  MOVWF  FEA
3B26:  MOVFF  FEF,ACC
3B2A:  MOVLW  03
3B2C:  ADDWF  xC1,W
3B2E:  MOVWF  xCD
3B30:  MOVLW  00
3B32:  ADDWFC xC2,W
3B34:  MOVWF  xCE
3B36:  MOVF   xBC,W
3B38:  ADDWF  xCD,W
3B3A:  MOVWF  FE9
3B3C:  MOVF   xBD,W
3B3E:  ADDWFC xCE,W
3B40:  MOVWF  FEA
3B42:  MOVFF  FEF,ACF
3B46:  MOVLW  02
3B48:  ADDWF  xC1,W
3B4A:  MOVWF  xD0
3B4C:  MOVLW  00
3B4E:  ADDWFC xC2,W
3B50:  MOVWF  xD1
3B52:  MOVF   xBC,W
3B54:  ADDWF  xD0,W
3B56:  MOVWF  FE9
3B58:  MOVF   xBD,W
3B5A:  ADDWFC xD1,W
3B5C:  MOVWF  FEA
3B5E:  MOVFF  FEF,AD2
3B62:  MOVLW  01
3B64:  ADDWF  xC1,W
3B66:  MOVWF  xD3
3B68:  MOVLW  00
3B6A:  ADDWFC xC2,W
3B6C:  MOVWF  xD4
3B6E:  MOVF   xBC,W
3B70:  ADDWF  xD3,W
3B72:  MOVWF  FE9
3B74:  MOVF   xBD,W
3B76:  ADDWFC xD4,W
3B78:  MOVWF  FEA
3B7A:  MOVFF  FEF,AD5
3B7E:  MOVF   xBC,W
3B80:  ADDWF  xC1,W
3B82:  MOVWF  FE9
3B84:  MOVF   xBD,W
3B86:  ADDWFC xC2,W
3B88:  MOVWF  FEA
3B8A:  MOVFF  FEF,AD6
3B8E:  CLRF   xE7
3B90:  CLRF   xE8
3B92:  MOVFF  AC9,AE9
3B96:  MOVFF  ACC,AEA
3B9A:  MOVFF  ACF,AEB
3B9E:  MOVFF  AD2,AEC
3BA2:  MOVFF  AD5,AED
3BA6:  MOVFF  AD6,AEE
3BAA:  MOVLB  0
3BAC:  CALL   07C0
3BB0:  MOVFF  AC6,FEA
3BB4:  MOVFF  AC5,FE9
3BB8:  MOVFF  01,FEF
....................                j=j+7; 
3BBC:  MOVLW  07
3BBE:  MOVLB  A
3BC0:  ADDWF  xC1,F
3BC2:  MOVLW  00
3BC4:  ADDWFC xC2,F
....................             } 
3BC6:  INCF   xC0,F
3BC8:  BRA    3AD8
....................       } 
....................          else  
3BCA:  BRA    3C84
....................          { 
....................             for(i=0;i<40;i++) 
3BCC:  CLRF   xC0
3BCE:  MOVF   xC0,W
3BD0:  SUBLW  27
3BD2:  BNC   3C84
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3BD4:  CLRF   03
3BD6:  MOVF   xC0,W
3BD8:  ADDWF  xBE,W
3BDA:  MOVWF  01
3BDC:  MOVF   xBF,W
3BDE:  ADDWFC 03,F
3BE0:  MOVFF  01,AC5
3BE4:  MOVFF  03,AC6
3BE8:  MOVLW  03
3BEA:  ADDWF  xC1,W
3BEC:  MOVWF  xC7
3BEE:  MOVLW  00
3BF0:  ADDWFC xC2,W
3BF2:  MOVWF  xC8
3BF4:  MOVF   xBC,W
3BF6:  ADDWF  xC7,W
3BF8:  MOVWF  FE9
3BFA:  MOVF   xBD,W
3BFC:  ADDWFC xC8,W
3BFE:  MOVWF  FEA
3C00:  MOVFF  FEF,AC9
3C04:  MOVLW  02
3C06:  ADDWF  xC1,W
3C08:  MOVWF  xCA
3C0A:  MOVLW  00
3C0C:  ADDWFC xC2,W
3C0E:  MOVWF  xCB
3C10:  MOVF   xBC,W
3C12:  ADDWF  xCA,W
3C14:  MOVWF  FE9
3C16:  MOVF   xBD,W
3C18:  ADDWFC xCB,W
3C1A:  MOVWF  FEA
3C1C:  MOVFF  FEF,ACC
3C20:  MOVLW  01
3C22:  ADDWF  xC1,W
3C24:  MOVWF  xCD
3C26:  MOVLW  00
3C28:  ADDWFC xC2,W
3C2A:  MOVWF  xCE
3C2C:  MOVF   xBC,W
3C2E:  ADDWF  xCD,W
3C30:  MOVWF  FE9
3C32:  MOVF   xBD,W
3C34:  ADDWFC xCE,W
3C36:  MOVWF  FEA
3C38:  MOVFF  FEF,ACF
3C3C:  MOVF   xBC,W
3C3E:  ADDWF  xC1,W
3C40:  MOVWF  FE9
3C42:  MOVF   xBD,W
3C44:  ADDWFC xC2,W
3C46:  MOVWF  FEA
3C48:  MOVFF  FEF,AD0
3C4C:  CLRF   xE7
3C4E:  CLRF   xE8
3C50:  CLRF   xE9
3C52:  CLRF   xEA
3C54:  MOVFF  AC9,AEB
3C58:  MOVFF  ACC,AEC
3C5C:  MOVFF  ACF,AED
3C60:  MOVFF  AD0,AEE
3C64:  MOVLB  0
3C66:  CALL   07C0
3C6A:  MOVFF  AC6,FEA
3C6E:  MOVFF  AC5,FE9
3C72:  MOVFF  01,FEF
....................                j=j+5; 
3C76:  MOVLW  05
3C78:  MOVLB  A
3C7A:  ADDWF  xC1,F
3C7C:  MOVLW  00
3C7E:  ADDWFC xC2,F
....................             }          
3C80:  INCF   xC0,F
3C82:  BRA    3BCE
....................          } 
....................    } 
....................       else  
3C84:  BRA    3E3E
3C86:  MOVLB  9
....................       { 
....................          if(track==0) 
3C88:  MOVLB  A
3C8A:  MOVF   xB9,F
3C8C:  BTFSS  FD8.2
3C8E:  BRA    3D86
....................          { 
....................             for(i=0;i<79;i++) 
3C90:  CLRF   xC0
3C92:  MOVF   xC0,W
3C94:  SUBLW  4E
3C96:  BNC   3D84
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3C98:  CLRF   03
3C9A:  MOVF   xC0,W
3C9C:  ADDWF  xBE,W
3C9E:  MOVWF  01
3CA0:  MOVF   xBF,W
3CA2:  ADDWFC 03,F
3CA4:  MOVFF  01,AC5
3CA8:  MOVFF  03,AC6
3CAC:  MOVLW  05
3CAE:  SUBWF  xC1,W
3CB0:  MOVWF  xC7
3CB2:  MOVLW  00
3CB4:  SUBWFB xC2,W
3CB6:  MOVWF  xC8
3CB8:  MOVF   xBC,W
3CBA:  ADDWF  xC7,W
3CBC:  MOVWF  FE9
3CBE:  MOVF   xBD,W
3CC0:  ADDWFC xC8,W
3CC2:  MOVWF  FEA
3CC4:  MOVFF  FEF,AC9
3CC8:  MOVLW  04
3CCA:  SUBWF  xC1,W
3CCC:  MOVWF  xCA
3CCE:  MOVLW  00
3CD0:  SUBWFB xC2,W
3CD2:  MOVWF  xCB
3CD4:  MOVF   xBC,W
3CD6:  ADDWF  xCA,W
3CD8:  MOVWF  FE9
3CDA:  MOVF   xBD,W
3CDC:  ADDWFC xCB,W
3CDE:  MOVWF  FEA
3CE0:  MOVFF  FEF,ACC
3CE4:  MOVLW  03
3CE6:  SUBWF  xC1,W
3CE8:  MOVWF  xCD
3CEA:  MOVLW  00
3CEC:  SUBWFB xC2,W
3CEE:  MOVWF  xCE
3CF0:  MOVF   xBC,W
3CF2:  ADDWF  xCD,W
3CF4:  MOVWF  FE9
3CF6:  MOVF   xBD,W
3CF8:  ADDWFC xCE,W
3CFA:  MOVWF  FEA
3CFC:  MOVFF  FEF,ACF
3D00:  MOVLW  02
3D02:  SUBWF  xC1,W
3D04:  MOVWF  xD0
3D06:  MOVLW  00
3D08:  SUBWFB xC2,W
3D0A:  MOVWF  xD1
3D0C:  MOVF   xBC,W
3D0E:  ADDWF  xD0,W
3D10:  MOVWF  FE9
3D12:  MOVF   xBD,W
3D14:  ADDWFC xD1,W
3D16:  MOVWF  FEA
3D18:  MOVFF  FEF,AD2
3D1C:  MOVLW  01
3D1E:  SUBWF  xC1,W
3D20:  MOVWF  xD3
3D22:  MOVLW  00
3D24:  SUBWFB xC2,W
3D26:  MOVWF  xD4
3D28:  MOVF   xBC,W
3D2A:  ADDWF  xD3,W
3D2C:  MOVWF  FE9
3D2E:  MOVF   xBD,W
3D30:  ADDWFC xD4,W
3D32:  MOVWF  FEA
3D34:  MOVFF  FEF,AD5
3D38:  MOVF   xBC,W
3D3A:  ADDWF  xC1,W
3D3C:  MOVWF  FE9
3D3E:  MOVF   xBD,W
3D40:  ADDWFC xC2,W
3D42:  MOVWF  FEA
3D44:  MOVFF  FEF,AD6
3D48:  CLRF   xE7
3D4A:  CLRF   xE8
3D4C:  MOVFF  AC9,AE9
3D50:  MOVFF  ACC,AEA
3D54:  MOVFF  ACF,AEB
3D58:  MOVFF  AD2,AEC
3D5C:  MOVFF  AD5,AED
3D60:  MOVFF  AD6,AEE
3D64:  MOVLB  0
3D66:  CALL   07C0
3D6A:  MOVFF  AC6,FEA
3D6E:  MOVFF  AC5,FE9
3D72:  MOVFF  01,FEF
....................                j=j-7; 
3D76:  MOVLW  07
3D78:  MOVLB  A
3D7A:  SUBWF  xC1,F
3D7C:  MOVLW  00
3D7E:  SUBWFB xC2,F
....................             } 
3D80:  INCF   xC0,F
3D82:  BRA    3C92
....................          } 
....................             else 
3D84:  BRA    3E3E
....................             { 
....................                for(i=0;i<40;i++) 
3D86:  CLRF   xC0
3D88:  MOVF   xC0,W
3D8A:  SUBLW  27
3D8C:  BNC   3E3E
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3D8E:  CLRF   03
3D90:  MOVF   xC0,W
3D92:  ADDWF  xBE,W
3D94:  MOVWF  01
3D96:  MOVF   xBF,W
3D98:  ADDWFC 03,F
3D9A:  MOVFF  01,AC5
3D9E:  MOVFF  03,AC6
3DA2:  MOVLW  03
3DA4:  SUBWF  xC1,W
3DA6:  MOVWF  xC7
3DA8:  MOVLW  00
3DAA:  SUBWFB xC2,W
3DAC:  MOVWF  xC8
3DAE:  MOVF   xBC,W
3DB0:  ADDWF  xC7,W
3DB2:  MOVWF  FE9
3DB4:  MOVF   xBD,W
3DB6:  ADDWFC xC8,W
3DB8:  MOVWF  FEA
3DBA:  MOVFF  FEF,AC9
3DBE:  MOVLW  02
3DC0:  SUBWF  xC1,W
3DC2:  MOVWF  xCA
3DC4:  MOVLW  00
3DC6:  SUBWFB xC2,W
3DC8:  MOVWF  xCB
3DCA:  MOVF   xBC,W
3DCC:  ADDWF  xCA,W
3DCE:  MOVWF  FE9
3DD0:  MOVF   xBD,W
3DD2:  ADDWFC xCB,W
3DD4:  MOVWF  FEA
3DD6:  MOVFF  FEF,ACC
3DDA:  MOVLW  01
3DDC:  SUBWF  xC1,W
3DDE:  MOVWF  xCD
3DE0:  MOVLW  00
3DE2:  SUBWFB xC2,W
3DE4:  MOVWF  xCE
3DE6:  MOVF   xBC,W
3DE8:  ADDWF  xCD,W
3DEA:  MOVWF  FE9
3DEC:  MOVF   xBD,W
3DEE:  ADDWFC xCE,W
3DF0:  MOVWF  FEA
3DF2:  MOVFF  FEF,ACF
3DF6:  MOVF   xBC,W
3DF8:  ADDWF  xC1,W
3DFA:  MOVWF  FE9
3DFC:  MOVF   xBD,W
3DFE:  ADDWFC xC2,W
3E00:  MOVWF  FEA
3E02:  MOVFF  FEF,AD0
3E06:  CLRF   xE7
3E08:  CLRF   xE8
3E0A:  CLRF   xE9
3E0C:  CLRF   xEA
3E0E:  MOVFF  AC9,AEB
3E12:  MOVFF  ACC,AEC
3E16:  MOVFF  ACF,AED
3E1A:  MOVFF  AD0,AEE
3E1E:  MOVLB  0
3E20:  CALL   07C0
3E24:  MOVFF  AC6,FEA
3E28:  MOVFF  AC5,FE9
3E2C:  MOVFF  01,FEF
....................                   j=j-5; 
3E30:  MOVLW  05
3E32:  MOVLB  A
3E34:  SUBWF  xC1,F
3E36:  MOVLW  00
3E38:  SUBWFB xC2,F
....................                }             
3E3A:  INCF   xC0,F
3E3C:  BRA    3D88
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3E3E:  MOVF   xB9,F
3E40:  BNZ   3E56
3E42:  MOVLW  52
3E44:  MOVWF  xC5
3E46:  MOVFF  ABD,AC7
3E4A:  MOVFF  ABC,AC6
3E4E:  MOVLB  0
3E50:  RCALL  3A62
....................          else del_buf(numbyteofbuffer2,datin); 
3E52:  BRA    3E66
3E54:  MOVLB  A
3E56:  MOVLW  2C
3E58:  MOVWF  xC5
3E5A:  MOVFF  ABD,AC7
3E5E:  MOVFF  ABC,AC6
3E62:  MOVLB  0
3E64:  RCALL  3A62
3E66:  MOVLB  A
.................... } 
3E68:  MOVLB  0
3E6A:  RETURN 0
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
18F0:  MOVLW  72
18F2:  MOVWF  FF6
18F4:  MOVLW  06
18F6:  MOVWF  FF7
18F8:  CALL   07A0
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
18FC:  MOVLB  A
18FE:  CLRF   xBD
1900:  CLRF   xBC
1902:  MOVF   xBD,W
1904:  SUBLW  03
1906:  BNC   1936
1908:  BNZ   1910
190A:  MOVF   xBC,W
190C:  SUBLW  51
190E:  BNC   1936
1910:  MOVLW  17
1912:  ADDWF  xBC,W
1914:  MOVWF  FE9
1916:  MOVLW  05
1918:  ADDWFC xBD,W
191A:  MOVWF  FEA
191C:  MOVFF  FEF,ABE
1920:  MOVFF  ABE,ABF
1924:  MOVLW  18
1926:  MOVWF  xC0
1928:  MOVLB  0
192A:  RCALL  182C
192C:  MOVLB  A
192E:  INCF   xBC,F
1930:  BTFSC  FD8.2
1932:  INCF   xBD,F
1934:  BRA    1902
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1936:  MOVLW  88
1938:  MOVWF  FF6
193A:  MOVLW  06
193C:  MOVWF  FF7
193E:  MOVLB  0
1940:  CALL   07A0
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
1944:  MOVLB  A
1946:  CLRF   xBD
1948:  CLRF   xBC
194A:  MOVF   xBD,W
194C:  SUBLW  01
194E:  BNC   197E
1950:  BNZ   1958
1952:  MOVF   xBC,W
1954:  SUBLW  2B
1956:  BNC   197E
1958:  MOVLW  69
195A:  ADDWF  xBC,W
195C:  MOVWF  FE9
195E:  MOVLW  08
1960:  ADDWFC xBD,W
1962:  MOVWF  FEA
1964:  MOVFF  FEF,ABE
1968:  MOVFF  ABE,ABF
196C:  MOVLW  18
196E:  MOVWF  xC0
1970:  MOVLB  0
1972:  RCALL  182C
1974:  MOVLB  A
1976:  INCF   xBC,F
1978:  BTFSC  FD8.2
197A:  INCF   xBD,F
197C:  BRA    194A
.................... } 
197E:  MOVLB  0
1980:  GOTO   1C16 (RETURN)
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3FF0:  MOVLW  01
3FF2:  MOVLB  9
3FF4:  MOVWF  xA9
....................    rtc_get_date(date,mon,year,day); 
....................    rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
*
409E:  RCALL  39F0
40A0:  MOVFF  02,ABA
40A4:  MOVFF  01,AB9
40A8:  MOVFF  02,ABC
40AC:  MOVFF  01,ABB
40B0:  MOVLB  A
40B2:  CLRF   xBE
40B4:  MOVLW  7C
40B6:  MOVWF  xBD
40B8:  MOVLB  0
40BA:  RCALL  3A40
40BC:  MOVFF  01,AB9
40C0:  MOVLW  96
40C2:  MOVLB  A
40C4:  ADDWF  01,W
40C6:  MOVWF  01
40C8:  MOVLW  00
40CA:  ADDWFC 02,W
40CC:  MOVFF  01,20
40D0:  MOVWF  21
40D2:  CLRF   22
40D4:  CLRF   23
....................    if(datinbuf==0)  
40D6:  MOVLB  9
40D8:  MOVF   xA6,F
40DA:  BNZ   40FC
....................    { 
....................       countbit_T1=0; 
40DC:  CLRF   x9B
40DE:  CLRF   x9A
....................       countbit_T2=0; 
40E0:  CLRF   x9D
40E2:  CLRF   x9C
....................       bug_countbit_T1=0; 
40E4:  CLRF   x9F
40E6:  CLRF   x9E
....................       bug_countbit_T2=0; 
40E8:  CLRF   xA1
40EA:  CLRF   xA0
....................       if(data_avai==0)charac_timeout=0xffffffff; 
40EC:  MOVF   xAA,F
40EE:  BNZ   40F8
40F0:  MOVLB  0
40F2:  SETF   xFC
40F4:  SETF   xFB
40F6:  MOVLB  9
....................       saving_flag=0; 
40F8:  CLRF   xA9
....................       return; 
40FA:  BRA    4468
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
40FC:  MOVLW  9E
40FE:  MOVWF  FF6
4100:  MOVLW  06
4102:  MOVWF  FF7
4104:  MOVLB  0
4106:  CALL   07A0
....................    key_timeout=0; 
410A:  MOVLB  1
410C:  CLRF   x09
410E:  CLRF   x08
....................    //key_count=0; 
....................    enable_getpin=1; 
4110:  MOVLW  01
4112:  MOVWF  x0C
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
4114:  MOVFF  99B,AB8
4118:  MOVFF  99A,AB7
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
411C:  MOVLB  A
411E:  CLRF   xB9
4120:  MOVFF  AB8,ABB
4124:  MOVFF  AB7,ABA
4128:  MOVLW  05
412A:  MOVWF  xBD
412C:  MOVLW  17
412E:  MOVWF  xBC
4130:  MOVLW  04
4132:  MOVWF  xBF
4134:  MOVLW  A0
4136:  MOVWF  xBE
4138:  MOVLB  0
413A:  RCALL  3A84
....................    countbit_T1=0; 
413C:  MOVLB  9
413E:  CLRF   x9B
4140:  CLRF   x9A
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
4142:  MOVFF  99D,AB8
4146:  MOVFF  99C,AB7
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
414A:  MOVLW  01
414C:  MOVLB  A
414E:  MOVWF  xB9
4150:  MOVFF  AB8,ABB
4154:  MOVFF  AB7,ABA
4158:  MOVLW  08
415A:  MOVWF  xBD
415C:  MOVLW  69
415E:  MOVWF  xBC
4160:  MOVLW  04
4162:  MOVWF  xBF
4164:  MOVLW  EF
4166:  MOVWF  xBE
4168:  MOVLB  0
416A:  RCALL  3A84
....................    countbit_T2=0; 
416C:  MOVLB  9
416E:  CLRF   x9D
4170:  CLRF   x9C
....................    saving_flag=0; 
4172:  CLRF   xA9
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
4174:  MOVLW  20
4176:  MOVLB  4
4178:  ADDWF  xA0,W
417A:  MOVLB  A
417C:  MOVWF  xB6
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
417E:  MOVF   23,F
4180:  BTFSS  FD8.2
4182:  BRA    4466
4184:  MOVF   22,F
4186:  BTFSS  FD8.2
4188:  BRA    4466
418A:  MOVF   21,W
418C:  SUBLW  AA
418E:  BTFSS  FD8.0
4190:  BRA    4466
4192:  BNZ   419C
4194:  MOVF   20,W
4196:  SUBLW  45
4198:  BTFSS  FD8.0
419A:  BRA    4466
419C:  MOVF   xB6,W
419E:  SUBLW  25
41A0:  BTFSS  FD8.2
41A2:  BRA    4466
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
41A4:  MOVFF  23,03
41A8:  MOVFF  22,02
41AC:  MOVFF  21,01
41B0:  MOVFF  20,00
41B4:  MOVLW  01
41B6:  ADDWF  20,F
41B8:  BTFSC  FD8.0
41BA:  INCF   21,F
41BC:  BTFSC  FD8.2
41BE:  INCF   22,F
41C0:  BTFSC  FD8.2
41C2:  INCF   23,F
41C4:  MOVFF  01,ABA
41C8:  MOVFF  00,AB9
41CC:  MOVFF  01,AC8
41D0:  MOVFF  00,AC7
41D4:  MOVFF  100,AC9
41D8:  MOVLB  0
41DA:  RCALL  3E6C
....................          write_ext_eeprom((long int)ptr_card++,mon); 
41DC:  MOVFF  23,03
41E0:  MOVFF  22,02
41E4:  MOVFF  21,01
41E8:  MOVFF  20,00
41EC:  MOVLW  01
41EE:  ADDWF  20,F
41F0:  BTFSC  FD8.0
41F2:  INCF   21,F
41F4:  BTFSC  FD8.2
41F6:  INCF   22,F
41F8:  BTFSC  FD8.2
41FA:  INCF   23,F
41FC:  MOVFF  01,ABA
4200:  MOVFF  00,AB9
4204:  MOVFF  01,AC8
4208:  MOVFF  00,AC7
420C:  MOVFF  FF,AC9
4210:  RCALL  3E6C
....................          write_ext_eeprom((long int)ptr_card++,h); 
4212:  MOVFF  23,03
4216:  MOVFF  22,02
421A:  MOVFF  21,01
421E:  MOVFF  20,00
4222:  MOVLW  01
4224:  ADDWF  20,F
4226:  BTFSC  FD8.0
4228:  INCF   21,F
422A:  BTFSC  FD8.2
422C:  INCF   22,F
422E:  BTFSC  FD8.2
4230:  INCF   23,F
4232:  MOVFF  01,ABA
4236:  MOVFF  00,AB9
423A:  MOVFF  01,AC8
423E:  MOVFF  00,AC7
4242:  MOVFF  101,AC9
4246:  RCALL  3E6C
....................          write_ext_eeprom((long int)ptr_card++,min); 
4248:  MOVFF  23,03
424C:  MOVFF  22,02
4250:  MOVFF  21,01
4254:  MOVFF  20,00
4258:  MOVLW  01
425A:  ADDWF  20,F
425C:  BTFSC  FD8.0
425E:  INCF   21,F
4260:  BTFSC  FD8.2
4262:  INCF   22,F
4264:  BTFSC  FD8.2
4266:  INCF   23,F
4268:  MOVFF  01,ABA
426C:  MOVFF  00,AB9
4270:  MOVFF  01,AC8
4274:  MOVFF  00,AC7
4278:  MOVFF  102,AC9
427C:  RCALL  3E6C
....................          write_ext_eeprom((long int)ptr_card++,sec);           
427E:  MOVFF  23,03
4282:  MOVFF  22,02
4286:  MOVFF  21,01
428A:  MOVFF  20,00
428E:  MOVLW  01
4290:  ADDWF  20,F
4292:  BTFSC  FD8.0
4294:  INCF   21,F
4296:  BTFSC  FD8.2
4298:  INCF   22,F
429A:  BTFSC  FD8.2
429C:  INCF   23,F
429E:  MOVFF  01,ABA
42A2:  MOVFF  00,AB9
42A6:  MOVFF  01,AC8
42AA:  MOVFF  00,AC7
42AE:  MOVFF  103,AC9
42B2:  RCALL  3E6C
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
42B4:  MOVLB  9
42B6:  CLRF   xA5
42B8:  CLRF   xA4
42BA:  MOVF   xA5,F
42BC:  BNZ   431A
42BE:  MOVF   xA4,W
42C0:  SUBLW  4E
42C2:  BNC   431A
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
42C4:  MOVFF  23,03
42C8:  MOVFF  22,02
42CC:  MOVFF  21,01
42D0:  MOVFF  20,00
42D4:  MOVLW  01
42D6:  ADDWF  20,F
42D8:  BTFSC  FD8.0
42DA:  INCF   21,F
42DC:  BTFSC  FD8.2
42DE:  INCF   22,F
42E0:  BTFSC  FD8.2
42E2:  INCF   23,F
42E4:  MOVFF  01,ABA
42E8:  MOVFF  00,AB9
42EC:  MOVLW  A0
42EE:  ADDWF  xA4,W
42F0:  MOVWF  FE9
42F2:  MOVLW  04
42F4:  ADDWFC xA5,W
42F6:  MOVWF  FEA
42F8:  MOVF   FEF,W
42FA:  ANDLW  3F
42FC:  ADDLW  20
42FE:  MOVLB  A
4300:  MOVWF  xBB
4302:  MOVFF  01,AC8
4306:  MOVFF  00,AC7
430A:  MOVWF  xC9
430C:  MOVLB  0
430E:  RCALL  3E6C
....................              
....................          } 
4310:  MOVLB  9
4312:  INCF   xA4,F
4314:  BTFSC  FD8.2
4316:  INCF   xA5,F
4318:  BRA    42BA
....................          del_buf(numbyteoftrack1,Track1); 
431A:  MOVLW  4F
431C:  MOVLB  A
431E:  MOVWF  xC5
4320:  MOVLW  04
4322:  MOVWF  xC7
4324:  MOVLW  A0
4326:  MOVWF  xC6
4328:  MOVLB  0
432A:  CALL   3A62
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
432E:  MOVLB  9
4330:  CLRF   xA5
4332:  CLRF   xA4
4334:  MOVF   xA5,F
4336:  BNZ   4394
4338:  MOVF   xA4,W
433A:  SUBLW  27
433C:  BNC   4394
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
433E:  MOVFF  23,03
4342:  MOVFF  22,02
4346:  MOVFF  21,01
434A:  MOVFF  20,00
434E:  MOVLW  01
4350:  ADDWF  20,F
4352:  BTFSC  FD8.0
4354:  INCF   21,F
4356:  BTFSC  FD8.2
4358:  INCF   22,F
435A:  BTFSC  FD8.2
435C:  INCF   23,F
435E:  MOVFF  01,ABA
4362:  MOVFF  00,AB9
4366:  MOVLW  EF
4368:  ADDWF  xA4,W
436A:  MOVWF  FE9
436C:  MOVLW  04
436E:  ADDWFC xA5,W
4370:  MOVWF  FEA
4372:  MOVF   FEF,W
4374:  ANDLW  0F
4376:  ADDLW  30
4378:  MOVLB  A
437A:  MOVWF  xBB
437C:  MOVFF  01,AC8
4380:  MOVFF  00,AC7
4384:  MOVWF  xC9
4386:  MOVLB  0
4388:  RCALL  3E6C
....................          }  
438A:  MOVLB  9
438C:  INCF   xA4,F
438E:  BTFSC  FD8.2
4390:  INCF   xA5,F
4392:  BRA    4334
....................          del_buf(numbyteoftrack2,Track2); 
4394:  MOVLW  28
4396:  MOVLB  A
4398:  MOVWF  xC5
439A:  MOVLW  04
439C:  MOVWF  xC7
439E:  MOVLW  EF
43A0:  MOVWF  xC6
43A2:  MOVLB  0
43A4:  CALL   3A62
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
43A8:  MOVLW  0D
43AA:  MOVLB  A
43AC:  MOVWF  xDF
43AE:  MOVLB  0
43B0:  CALL   075A
43B4:  MOVLW  0A
43B6:  MOVLB  A
43B8:  MOVWF  xDF
43BA:  MOVLB  0
43BC:  CALL   075A
....................       fprintf(COM2,"Done"); 
43C0:  MOVLW  B4
43C2:  MOVWF  FF6
43C4:  MOVLW  06
43C6:  MOVWF  FF7
43C8:  CALL   07A0
....................       if(KP_mode) 
43CC:  MOVLB  1
43CE:  MOVF   x0F,F
43D0:  BZ    43E8
....................       { 
....................          printf("\n\rKey release\n\r"); 
43D2:  MOVLW  BA
43D4:  MOVWF  FF6
43D6:  MOVLW  06
43D8:  MOVWF  FF7
43DA:  MOVLB  0
43DC:  CALL   07A0
....................          keyprss_off; 
43E0:  BCF    F92.7
43E2:  BCF    F89.7
....................          kp_st=0; 
43E4:  MOVLB  1
43E6:  CLRF   x10
....................       }   
....................       count_kp=0xffff; 
43E8:  SETF   x12
43EA:  SETF   x11
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
43EC:  MOVLW  0D
43EE:  MOVLB  A
43F0:  MOVWF  xDF
43F2:  MOVLB  0
43F4:  CALL   075A
43F8:  MOVLW  0A
43FA:  MOVLB  A
43FC:  MOVWF  xDF
43FE:  MOVLB  0
4400:  CALL   075A
....................       fprintf(COM2,"Waiting for PIN number"); 
4404:  MOVLW  CA
4406:  MOVWF  FF6
4408:  MOVLW  06
440A:  MOVWF  FF7
440C:  CALL   07A0
....................       count_checking=0; 
4410:  MOVLB  1
4412:  CLRF   x07
4414:  CLRF   x06
....................       fprintf(COM2,"\r\n"); 
4416:  MOVLW  0D
4418:  MOVLB  A
441A:  MOVWF  xDF
441C:  MOVLB  0
441E:  CALL   075A
4422:  MOVLW  0A
4424:  MOVLB  A
4426:  MOVWF  xDF
4428:  MOVLB  0
442A:  CALL   075A
....................       charac_timeout=0; 
442E:  CLRF   xFC
4430:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
4432:  MOVFF  23,ABC
4436:  MOVFF  22,ABB
443A:  MOVFF  21,ABA
443E:  MOVFF  20,AB9
4442:  MOVLW  19
4444:  MOVLB  A
4446:  MOVWF  xBD
4448:  MOVLB  0
444A:  RCALL  3F72
....................       datinbuf=0; 
444C:  MOVLB  9
444E:  CLRF   xA6
....................       saving_flag=0; 
4450:  CLRF   xA9
....................       data_avai=1; 
4452:  MOVLW  01
4454:  MOVWF  xAA
....................       enable_getpin=1; 
4456:  MOVLB  1
4458:  MOVWF  x0C
....................       charac_timeout=0; 
445A:  MOVLB  0
445C:  CLRF   xFC
445E:  CLRF   xFB
....................       key_count_ms=0; 
4460:  MOVLB  1
4462:  CLRF   x0E
4464:  MOVLB  A
4466:  MOVLB  9
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
4468:  MOVLB  0
446A:  GOTO   47C6 (RETURN)
.................... //========================= 
.................... int8 mcr_read() 
.................... { 
*
19AC:  MOVLW  01
19AE:  MOVLB  A
19B0:  MOVWF  xB3
19B2:  MOVWF  xB4
19B4:  MOVWF  xB5
19B6:  MOVWF  xB6
19B8:  CLRF   xB7
19BA:  MOVWF  xB8
19BC:  MOVWF  xB9
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
19BE:  MOVLB  9
19C0:  CLRF   xA3
19C2:  CLRF   xA2
....................    mcr_timeout=0; 
19C4:  CLRF   x98
19C6:  CLRF   x97
19C8:  CLRF   x96
19CA:  CLRF   x95
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
....................    { 
19CC:  MOVF   xA3,W
19CE:  SUBLW  FD
19D0:  BNC   19EE
19D2:  BNZ   19DA
19D4:  MOVF   xA2,W
19D6:  SUBLW  E7
19D8:  BNC   19EE
19DA:  BSF    F93.1
19DC:  BTFSS  F81.1
19DE:  BRA    19EE
19E0:  BSF    F94.5
19E2:  BTFSS  F82.5
19E4:  BRA    19EE
....................       card_timeout++; 
19E6:  INCF   xA2,F
19E8:  BTFSC  FD8.2
19EA:  INCF   xA3,F
....................    } 
19EC:  BRA    19CC
....................    card_timeout=0; 
19EE:  CLRF   xA3
19F0:  CLRF   xA2
....................    buffertrack1[bug_countbit_T1++]=0; 
19F2:  MOVFF  99F,03
19F6:  MOVF   x9E,W
19F8:  INCF   x9E,F
19FA:  BTFSC  FD8.2
19FC:  INCF   x9F,F
19FE:  MOVLB  A
1A00:  MOVWF  xBC
1A02:  MOVLW  17
1A04:  ADDWF  xBC,W
1A06:  MOVWF  FE9
1A08:  MOVLW  05
1A0A:  ADDWFC 03,W
1A0C:  MOVWF  FEA
1A0E:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1A10:  MOVLB  9
1A12:  MOVFF  99F,03
1A16:  MOVF   x9E,W
1A18:  INCF   x9E,F
1A1A:  BTFSC  FD8.2
1A1C:  INCF   x9F,F
1A1E:  MOVLB  A
1A20:  MOVWF  xBC
1A22:  MOVLW  17
1A24:  ADDWF  xBC,W
1A26:  MOVWF  FE9
1A28:  MOVLW  05
1A2A:  ADDWFC 03,W
1A2C:  MOVWF  FEA
1A2E:  MOVLW  01
1A30:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1A32:  MOVLB  9
1A34:  MOVFF  9A1,03
1A38:  MOVF   xA0,W
1A3A:  INCF   xA0,F
1A3C:  BTFSC  FD8.2
1A3E:  INCF   xA1,F
1A40:  MOVLB  A
1A42:  MOVWF  xBC
1A44:  MOVLW  69
1A46:  ADDWF  xBC,W
1A48:  MOVWF  FE9
1A4A:  MOVLW  08
1A4C:  ADDWFC 03,W
1A4E:  MOVWF  FEA
1A50:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1A52:  MOVLB  9
1A54:  MOVFF  9A1,03
1A58:  MOVF   xA0,W
1A5A:  INCF   xA0,F
1A5C:  BTFSC  FD8.2
1A5E:  INCF   xA1,F
1A60:  MOVLB  A
1A62:  MOVWF  xBC
1A64:  MOVLW  69
1A66:  ADDWF  xBC,W
1A68:  MOVWF  FE9
1A6A:  MOVLW  08
1A6C:  ADDWFC 03,W
1A6E:  MOVWF  FEA
1A70:  MOVLW  01
1A72:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
....................    { 
1A74:  MOVLB  9
1A76:  MOVF   x9F,W
1A78:  SUBLW  03
1A7A:  BTFSS  FD8.0
1A7C:  BRA    1B5C
1A7E:  BNZ   1A88
1A80:  MOVF   x9E,W
1A82:  SUBLW  51
1A84:  BTFSS  FD8.0
1A86:  BRA    1B5C
1A88:  MOVF   xA1,W
1A8A:  SUBLW  01
1A8C:  BTFSS  FD8.0
1A8E:  BRA    1B5C
1A90:  BNZ   1A98
1A92:  MOVF   xA0,W
1A94:  SUBLW  2B
1A96:  BNC   1B5C
1A98:  MOVF   xA3,W
1A9A:  SUBLW  FF
1A9C:  BNC   1B5C
1A9E:  BNZ   1AA6
1AA0:  MOVF   xA2,W
1AA2:  SUBLW  DB
1AA4:  BNC   1B5C
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
1AA6:  MOVF   xAC,F
1AA8:  BZ    1AB2
....................          { 
....................             bug_countbit_T1=0; 
1AAA:  CLRF   x9F
1AAC:  CLRF   x9E
....................             bug_countbit_T2=0; 
1AAE:  CLRF   xA1
1AB0:  CLRF   xA0
....................          } 
....................          card_timeout++; 
1AB2:  INCF   xA2,F
1AB4:  BTFSC  FD8.2
1AB6:  INCF   xA3,F
....................          mcr_timeout=0; 
1AB8:  CLRF   x98
1ABA:  CLRF   x97
1ABC:  CLRF   x96
1ABE:  CLRF   x95
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1AC0:  BSF    F93.2
1AC2:  MOVLB  A
1AC4:  CLRF   xB3
1AC6:  BTFSC  F81.2
1AC8:  INCF   xB3,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1ACA:  MOVF   xB3,F
1ACC:  BNZ   1B0A
1ACE:  DECFSZ xB4,W
1AD0:  BRA    1B0A
....................          { 
....................             ST1_old = 0; 
1AD2:  CLRF   xB4
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1AD4:  MOVLW  17
1AD6:  MOVLB  9
1AD8:  ADDWF  x9E,W
1ADA:  MOVWF  FE9
1ADC:  MOVLW  05
1ADE:  ADDWFC x9F,W
1AE0:  MOVWF  FEA
1AE2:  BSF    F93.1
1AE4:  MOVLW  00
1AE6:  BTFSS  F81.1
1AE8:  MOVLW  01
1AEA:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1AEC:  MOVLW  69
1AEE:  ADDWF  xA0,W
1AF0:  MOVWF  FE9
1AF2:  MOVLW  08
1AF4:  ADDWFC xA1,W
1AF6:  MOVWF  FEA
1AF8:  MOVFF  AB7,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1AFC:  INCF   x9E,F
1AFE:  BTFSC  FD8.2
1B00:  INCF   x9F,F
....................             card_timeout=0; 
1B02:  CLRF   xA3
1B04:  CLRF   xA2
....................          } 
....................          else if(ST1 == 1)ST1_old = 1; 
1B06:  BRA    1B14
1B08:  MOVLB  A
1B0A:  DECFSZ xB3,W
1B0C:  BRA    1B12
1B0E:  MOVLW  01
1B10:  MOVWF  xB4
1B12:  MOVLB  9
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1B14:  BSF    F93.3
1B16:  MOVLB  A
1B18:  CLRF   xB5
1B1A:  BTFSC  F81.3
1B1C:  INCF   xB5,F
....................          if(ST2 == 0 && ST2_old == 1) 
1B1E:  MOVF   xB5,F
1B20:  BNZ   1B40
1B22:  DECFSZ xB6,W
1B24:  BRA    1B40
....................          { 
....................             ST2_old = 0; 
1B26:  CLRF   xB6
....................             Bit_t2 = !input(MCR_DATA2); 
1B28:  BSF    F94.5
1B2A:  CLRF   xB7
1B2C:  BTFSS  F82.5
1B2E:  INCF   xB7,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1B30:  MOVLB  9
1B32:  INCF   xA0,F
1B34:  BTFSC  FD8.2
1B36:  INCF   xA1,F
....................             card_timeout=0; 
1B38:  CLRF   xA3
1B3A:  CLRF   xA2
....................          } 
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1B3C:  BRA    1B4A
1B3E:  MOVLB  A
1B40:  DECFSZ xB5,W
1B42:  BRA    1B48
1B44:  MOVLW  01
1B46:  MOVWF  xB6
1B48:  MOVLB  9
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1B4A:  BSF    F93.0
1B4C:  BTFSS  F81.0
1B4E:  BRA    1B5A
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1B50:  CLRF   xAC
....................             card_timeout=65500; 
1B52:  SETF   xA3
1B54:  MOVLW  DC
1B56:  MOVWF  xA2
....................             break;            
1B58:  BRA    1B5C
....................          } 
....................       } 
1B5A:  BRA    1A76
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1B5C:  CLRF   xA3
1B5E:  CLRF   xA2
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1B60:  MOVLB  A
1B62:  CLRF   xC5
1B64:  MOVFF  99F,AC7
1B68:  MOVFF  99E,AC6
1B6C:  MOVLW  05
1B6E:  MOVWF  xC9
1B70:  MOVLW  17
1B72:  MOVWF  xC8
1B74:  MOVLB  0
1B76:  CALL   0B16
1B7A:  MOVFF  01,AB8
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1B7E:  MOVLW  01
1B80:  MOVLB  A
1B82:  MOVWF  xC5
1B84:  MOVFF  9A1,AC7
1B88:  MOVFF  9A0,AC6
1B8C:  MOVLW  08
1B8E:  MOVWF  xC9
1B90:  MOVLW  69
1B92:  MOVWF  xC8
1B94:  MOVLB  0
1B96:  CALL   0B16
1B9A:  MOVFF  01,AB9
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1B9E:  MOVLB  9
1BA0:  DECFSZ xA7,W
1BA2:  BRA    1C44
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1BA4:  MOVLW  E2
1BA6:  MOVWF  FF6
1BA8:  MOVLW  06
1BAA:  MOVWF  FF7
1BAC:  MOVLW  0E
1BAE:  MOVLB  A
1BB0:  MOVWF  xD3
1BB2:  MOVLB  0
1BB4:  RCALL  1718
1BB6:  MOVLW  10
1BB8:  MOVWF  FE9
1BBA:  MOVFF  99F,ABD
1BBE:  MOVFF  99E,ABC
1BC2:  RCALL  1742
1BC4:  MOVLW  0D
1BC6:  MOVLB  A
1BC8:  MOVWF  xDF
1BCA:  MOVLB  0
1BCC:  CALL   075A
1BD0:  MOVLW  0A
1BD2:  MOVLB  A
1BD4:  MOVWF  xDF
1BD6:  MOVLB  0
1BD8:  CALL   075A
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1BDC:  MOVLW  F6
1BDE:  MOVWF  FF6
1BE0:  MOVLW  06
1BE2:  MOVWF  FF7
1BE4:  MOVLW  0E
1BE6:  MOVLB  A
1BE8:  MOVWF  xD3
1BEA:  MOVLB  0
1BEC:  RCALL  1718
1BEE:  MOVLW  10
1BF0:  MOVWF  FE9
1BF2:  MOVFF  9A1,ABD
1BF6:  MOVFF  9A0,ABC
1BFA:  RCALL  1742
1BFC:  MOVLW  0D
1BFE:  MOVLB  A
1C00:  MOVWF  xDF
1C02:  MOVLB  0
1C04:  CALL   075A
1C08:  MOVLW  0A
1C0A:  MOVLB  A
1C0C:  MOVWF  xDF
1C0E:  MOVLB  0
1C10:  CALL   075A
....................          debug_reader();       
1C14:  BRA    18F0
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1C16:  MOVLB  A
1C18:  MOVF   xB8,F
1C1A:  BNZ   1C2C
1C1C:  MOVLW  0A
1C1E:  MOVWF  FF6
1C20:  MOVLW  07
1C22:  MOVWF  FF7
1C24:  MOVLB  0
1C26:  CALL   07A0
1C2A:  MOVLB  A
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1C2C:  MOVF   xB9,F
1C2E:  BNZ   1C40
1C30:  MOVLW  20
1C32:  MOVWF  FF6
1C34:  MOVLW  07
1C36:  MOVWF  FF7
1C38:  MOVLB  0
1C3A:  CALL   07A0
1C3E:  MOVLB  A
....................       } 
....................          else 
1C40:  BRA    1C50
1C42:  MOVLB  9
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1C44:  MOVLW  0F
1C46:  MOVLB  A
1C48:  MOVWF  xBC
1C4A:  MOVLB  0
1C4C:  RCALL  1984
1C4E:  MOVLB  A
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1C50:  MOVF   xB8,F
1C52:  BZ    1C58
1C54:  MOVF   xB9,F
1C56:  BNZ   1C78
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1C58:  MOVLB  9
1C5A:  CLRF   xA1
1C5C:  CLRF   xA0
....................          bug_countbit_T1=0; 
1C5E:  CLRF   x9F
1C60:  CLRF   x9E
....................          reading_fg=0; 
1C62:  CLRF   xAB
....................          count_reading_error++; 
1C64:  INCF   xAC,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1C66:  CLRF   x98
1C68:  CLRF   x97
1C6A:  CLRF   x96
1C6C:  CLRF   x95
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1C6E:  MOVLW  00
1C70:  MOVWF  01
1C72:  BRA    1CB0
....................       } 
....................          else  
1C74:  BRA    1CAC
1C76:  MOVLB  A
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1C78:  MOVLW  01
1C7A:  MOVLB  9
1C7C:  MOVWF  xA6
....................             reading_fg=1; 
1C7E:  MOVWF  xAB
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1C80:  MOVFF  9A1,99D
1C84:  MOVFF  9A0,99C
....................             countbit_T1=bug_countbit_T1; 
1C88:  MOVFF  99F,99B
1C8C:  MOVFF  99E,99A
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1C90:  CLRF   x9F
1C92:  CLRF   x9E
....................             bug_countbit_T2=0;  
1C94:  CLRF   xA1
1C96:  CLRF   xA0
....................             mcr_timeout=0; 
1C98:  CLRF   x98
1C9A:  CLRF   x97
1C9C:  CLRF   x96
1C9E:  CLRF   x95
....................             charac_timeout=0; 
1CA0:  MOVLB  0
1CA2:  CLRF   xFC
1CA4:  CLRF   xFB
....................             return 1; 
1CA6:  MOVWF  01
1CA8:  MOVLB  9
1CAA:  BRA    1CB0
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1CAC:  MOVLW  00
1CAE:  MOVWF  01
.................... } 
1CB0:  MOVLB  0
1CB2:  GOTO   1D1E (RETURN)
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
1CB6:  MOVLW  02
1CB8:  MOVLB  A
1CBA:  MOVWF  xB3
1CBC:  MOVLW  FA
1CBE:  MOVWF  xB4
1CC0:  MOVLB  0
1CC2:  CALL   0736
1CC6:  MOVLB  A
1CC8:  DECFSZ xB3,F
1CCA:  BRA    1CBC
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
1CCC:  MOVLB  9
1CCE:  DECFSZ xA9,W
1CD0:  BRA    1CD4
1CD2:  BRA    1D30
....................       if((KP_mode)&&(enable_getpin==0)&&(booting==1)) 
1CD4:  MOVLB  1
1CD6:  MOVF   x0F,F
1CD8:  BZ    1D1A
1CDA:  MOVF   x0C,F
1CDC:  BNZ   1D1A
1CDE:  DECFSZ x05,W
1CE0:  BRA    1D1A
....................       { 
....................          if(kp_st==1) 
1CE2:  DECFSZ x10,W
1CE4:  BRA    1CFE
....................          { 
....................             printf("\n\rKey release.\n\r"); 
1CE6:  MOVLW  38
1CE8:  MOVWF  FF6
1CEA:  MOVLW  1D
1CEC:  MOVWF  FF7
1CEE:  MOVLB  0
1CF0:  CALL   07A0
....................             keyprss_off; 
1CF4:  BCF    F92.7
1CF6:  BCF    F89.7
....................             kp_st=0; 
1CF8:  MOVLB  1
1CFA:  CLRF   x10
....................          } 
....................          else 
1CFC:  BRA    1D1A
....................          { 
....................             printf("\n\rKey press.\n\r"); 
1CFE:  MOVLW  4A
1D00:  MOVWF  FF6
1D02:  MOVLW  1D
1D04:  MOVWF  FF7
1D06:  MOVLB  0
1D08:  CALL   07A0
....................             keyprss_on; 
1D0C:  BCF    F92.7
1D0E:  BSF    F89.7
....................             kp_st=1;  
1D10:  MOVLW  01
1D12:  MOVLB  1
1D14:  MOVWF  x10
....................             count_kp=0; 
1D16:  CLRF   x12
1D18:  CLRF   x11
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1D1A:  MOVLB  0
1D1C:  BRA    19AC
1D1E:  MOVFF  01,9A8
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1D22:  MOVLB  9
1D24:  CLRF   x98
1D26:  CLRF   x97
1D28:  CLRF   x96
1D2A:  CLRF   x95
....................       card_timeout=0; 
1D2C:  CLRF   xA3
1D2E:  CLRF   xA2
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
.................... } 
.................... //==================================== 
1D30:  BCF    FF0.0
1D32:  MOVLB  0
1D34:  GOTO   0084
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
.................... { 
*
5A48:  CLRF   19
5A4A:  BTFSC  FF2.7
5A4C:  BSF    19.7
5A4E:  BCF    FF2.7
....................    write_ext_eeprom(strobe_delaytime,3);  
5A50:  MOVLB  A
5A52:  CLRF   xC8
5A54:  MOVLW  94
5A56:  MOVWF  xC7
5A58:  MOVLW  03
5A5A:  MOVWF  xC9
5A5C:  MOVLB  0
5A5E:  CALL   3E6C
5A62:  BTFSC  19.7
5A64:  BSF    FF2.7
5A66:  CLRF   19
5A68:  BTFSC  FF2.7
5A6A:  BSF    19.7
5A6C:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
5A6E:  MOVLB  A
5A70:  CLRF   xC0
5A72:  MOVLW  94
5A74:  MOVWF  xBF
5A76:  MOVLB  0
5A78:  CALL   3948
5A7C:  BTFSC  19.7
5A7E:  BSF    FF2.7
5A80:  MOVFF  01,146
....................    fprintf(COM2,"tran time = %d\n\r",delaycharaction);   
5A84:  MOVLW  7E
5A86:  MOVWF  FF6
5A88:  MOVLW  1D
5A8A:  MOVWF  FF7
5A8C:  CLRF   19
5A8E:  BTFSC  FF2.7
5A90:  BSF    19.7
5A92:  BCF    FF2.7
5A94:  MOVLW  0C
5A96:  MOVLB  A
5A98:  MOVWF  xD3
5A9A:  MOVLB  0
5A9C:  CALL   1718
5AA0:  BTFSC  19.7
5AA2:  BSF    FF2.7
5AA4:  CLRF   19
5AA6:  BTFSC  FF2.7
5AA8:  BSF    19.7
5AAA:  BCF    FF2.7
5AAC:  MOVFF  146,ABF
5AB0:  MOVLW  18
5AB2:  MOVLB  A
5AB4:  MOVWF  xC0
5AB6:  MOVLB  0
5AB8:  CALL   182C
5ABC:  BTFSC  19.7
5ABE:  BSF    FF2.7
5AC0:  CLRF   19
5AC2:  BTFSC  FF2.7
5AC4:  BSF    19.7
5AC6:  BCF    FF2.7
5AC8:  MOVLW  0A
5ACA:  MOVLB  A
5ACC:  MOVWF  xDF
5ACE:  MOVLB  0
5AD0:  CALL   075A
5AD4:  BTFSC  19.7
5AD6:  BSF    FF2.7
5AD8:  CLRF   19
5ADA:  BTFSC  FF2.7
5ADC:  BSF    19.7
5ADE:  BCF    FF2.7
5AE0:  MOVLW  0D
5AE2:  MOVLB  A
5AE4:  MOVWF  xDF
5AE6:  MOVLB  0
5AE8:  CALL   075A
5AEC:  BTFSC  19.7
5AEE:  BSF    FF2.7
5AF0:  CLRF   19
5AF2:  BTFSC  FF2.7
5AF4:  BSF    19.7
5AF6:  BCF    FF2.7
....................  
....................    write_ext_eeprom(strobe_keypressmode,0); 
5AF8:  MOVLB  A
5AFA:  CLRF   xC8
5AFC:  MOVLW  7F
5AFE:  MOVWF  xC7
5B00:  CLRF   xC9
5B02:  MOVLB  0
5B04:  CALL   3E6C
5B08:  BTFSC  19.7
5B0A:  BSF    FF2.7
5B0C:  CLRF   19
5B0E:  BTFSC  FF2.7
5B10:  BSF    19.7
5B12:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
5B14:  MOVLB  A
5B16:  CLRF   xC0
5B18:  MOVLW  7F
5B1A:  MOVWF  xBF
5B1C:  MOVLB  0
5B1E:  CALL   3948
5B22:  BTFSC  19.7
5B24:  BSF    FF2.7
5B26:  MOVFF  01,10F
....................    if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
5B2A:  MOVLB  1
5B2C:  MOVF   x0F,F
5B2E:  BZ    5B4E
5B30:  MOVLW  90
5B32:  MOVWF  FF6
5B34:  MOVLW  1D
5B36:  MOVWF  FF7
5B38:  CLRF   19
5B3A:  BTFSC  FF2.7
5B3C:  BSF    19.7
5B3E:  BCF    FF2.7
5B40:  MOVLB  0
5B42:  CALL   07A0
5B46:  BTFSC  19.7
5B48:  BSF    FF2.7
....................    else printf("KP-> Keypress mode setting (Off)\n\r"); 
5B4A:  BRA    5B68
5B4C:  MOVLB  1
5B4E:  MOVLW  B2
5B50:  MOVWF  FF6
5B52:  MOVLW  1D
5B54:  MOVWF  FF7
5B56:  CLRF   19
5B58:  BTFSC  FF2.7
5B5A:  BSF    19.7
5B5C:  BCF    FF2.7
5B5E:  MOVLB  0
5B60:  CALL   07A0
5B64:  BTFSC  19.7
5B66:  BSF    FF2.7
5B68:  CLRF   19
5B6A:  BTFSC  FF2.7
5B6C:  BSF    19.7
5B6E:  BCF    FF2.7
....................  
....................    write_ext_eeprom(strobe_Master_SLV,1);    
5B70:  MOVLB  A
5B72:  CLRF   xC8
5B74:  MOVLW  91
5B76:  MOVWF  xC7
5B78:  MOVLW  01
5B7A:  MOVWF  xC9
5B7C:  MOVLB  0
5B7E:  CALL   3E6C
5B82:  BTFSC  19.7
5B84:  BSF    FF2.7
5B86:  CLRF   19
5B88:  BTFSC  FF2.7
5B8A:  BSF    19.7
5B8C:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
5B8E:  MOVLB  A
5B90:  CLRF   xC0
5B92:  MOVLW  91
5B94:  MOVWF  xBF
5B96:  MOVLB  0
5B98:  CALL   3948
5B9C:  BTFSC  19.7
5B9E:  BSF    FF2.7
5BA0:  MOVFF  01,9B3
....................    if(mode_sl) printf("Is Slave mode\n\r"); 
5BA4:  MOVLB  9
5BA6:  MOVF   xB3,F
5BA8:  BZ    5BC8
5BAA:  MOVLW  D6
5BAC:  MOVWF  FF6
5BAE:  MOVLW  1D
5BB0:  MOVWF  FF7
5BB2:  CLRF   19
5BB4:  BTFSC  FF2.7
5BB6:  BSF    19.7
5BB8:  BCF    FF2.7
5BBA:  MOVLB  0
5BBC:  CALL   07A0
5BC0:  BTFSC  19.7
5BC2:  BSF    FF2.7
....................    else printf("Is Master mode)\n\r"); 
5BC4:  BRA    5BE2
5BC6:  MOVLB  9
5BC8:  MOVLW  E6
5BCA:  MOVWF  FF6
5BCC:  MOVLW  1D
5BCE:  MOVWF  FF7
5BD0:  CLRF   19
5BD2:  BTFSC  FF2.7
5BD4:  BSF    19.7
5BD6:  BCF    FF2.7
5BD8:  MOVLB  0
5BDA:  CALL   07A0
5BDE:  BTFSC  19.7
5BE0:  BSF    FF2.7
5BE2:  CLRF   19
5BE4:  BTFSC  FF2.7
5BE6:  BSF    19.7
5BE8:  BCF    FF2.7
....................     
....................    write_ext_eeprom(kindofKB,1); 
5BEA:  MOVLB  A
5BEC:  CLRF   xC8
5BEE:  MOVLW  7E
5BF0:  MOVWF  xC7
5BF2:  MOVLW  01
5BF4:  MOVWF  xC9
5BF6:  MOVLB  0
5BF8:  CALL   3E6C
5BFC:  BTFSC  19.7
5BFE:  BSF    FF2.7
5C00:  CLRF   19
5C02:  BTFSC  FF2.7
5C04:  BSF    19.7
5C06:  BCF    FF2.7
....................    type_KB = read_ext_eeprom(kindofKB); 
5C08:  MOVLB  A
5C0A:  CLRF   xC0
5C0C:  MOVLW  7E
5C0E:  MOVWF  xBF
5C10:  MOVLB  0
5C12:  CALL   3948
5C16:  BTFSC  19.7
5C18:  BSF    FF2.7
5C1A:  MOVFF  01,113
....................    if(type_KB) printf("Is 4x6 matrix\n\r"); 
5C1E:  MOVLB  1
5C20:  MOVF   x13,F
5C22:  BZ    5C42
5C24:  MOVLW  F8
5C26:  MOVWF  FF6
5C28:  MOVLW  1D
5C2A:  MOVWF  FF7
5C2C:  CLRF   19
5C2E:  BTFSC  FF2.7
5C30:  BSF    19.7
5C32:  BCF    FF2.7
5C34:  MOVLB  0
5C36:  CALL   07A0
5C3A:  BTFSC  19.7
5C3C:  BSF    FF2.7
....................    else printf("Is 4x5 matrix\n\r"); 
5C3E:  BRA    5C5C
5C40:  MOVLB  1
5C42:  MOVLW  08
5C44:  MOVWF  FF6
5C46:  MOVLW  1E
5C48:  MOVWF  FF7
5C4A:  CLRF   19
5C4C:  BTFSC  FF2.7
5C4E:  BSF    19.7
5C50:  BCF    FF2.7
5C52:  MOVLB  0
5C54:  CALL   07A0
5C58:  BTFSC  19.7
5C5A:  BSF    FF2.7
....................     
....................    ptr_card=ptr_start; 
5C5C:  CLRF   23
5C5E:  CLRF   22
5C60:  CLRF   21
5C62:  MOVLW  96
5C64:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5C66:  CLRF   27
5C68:  CLRF   26
5C6A:  MOVLW  AA
5C6C:  MOVWF  25
5C6E:  MOVLW  47
5C70:  MOVWF  24
5C72:  CLRF   19
5C74:  BTFSC  FF2.7
5C76:  BSF    19.7
5C78:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5C7A:  MOVFF  23,ABC
5C7E:  MOVFF  22,ABB
5C82:  MOVFF  21,ABA
5C86:  MOVFF  20,AB9
5C8A:  MOVLW  19
5C8C:  MOVLB  A
5C8E:  MOVWF  xBD
5C90:  MOVLB  0
5C92:  CALL   3F72
5C96:  BTFSC  19.7
5C98:  BSF    FF2.7
5C9A:  CLRF   19
5C9C:  BTFSC  FF2.7
5C9E:  BSF    19.7
5CA0:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5CA2:  MOVFF  27,ABC
5CA6:  MOVFF  26,ABB
5CAA:  MOVFF  25,ABA
5CAE:  MOVFF  24,AB9
5CB2:  MOVLW  1E
5CB4:  MOVLB  A
5CB6:  MOVWF  xBD
5CB8:  MOVLB  0
5CBA:  CALL   3F72
5CBE:  BTFSC  19.7
5CC0:  BSF    FF2.7
5CC2:  CLRF   19
5CC4:  BTFSC  FF2.7
5CC6:  BSF    19.7
5CC8:  BCF    FF2.7
....................    save_coutcard(0); 
5CCA:  MOVLB  A
5CCC:  CLRF   xB7
5CCE:  CLRF   xB6
5CD0:  MOVLB  0
5CD2:  CALL   45DC
5CD6:  BTFSC  19.7
5CD8:  BSF    FF2.7
5CDA:  CLRF   19
5CDC:  BTFSC  FF2.7
5CDE:  BSF    19.7
5CE0:  BCF    FF2.7
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
5CE2:  MOVLB  A
5CE4:  CLRF   xC8
5CE6:  MOVLW  93
5CE8:  MOVWF  xC7
5CEA:  CLRF   xC9
5CEC:  MOVLB  0
5CEE:  CALL   3E6C
5CF2:  BTFSC  19.7
5CF4:  BSF    FF2.7
5CF6:  CLRF   19
5CF8:  BTFSC  FF2.7
5CFA:  BSF    19.7
5CFC:  BCF    FF2.7
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
5CFE:  MOVLB  A
5D00:  CLRF   xC0
5D02:  MOVLW  93
5D04:  MOVWF  xBF
5D06:  MOVLB  0
5D08:  CALL   3948
5D0C:  BTFSC  19.7
5D0E:  BSF    FF2.7
5D10:  MOVFF  01,499
....................    #endif 
.................... } 
5D14:  GOTO   8358 (RETURN)
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
....................       printf("\n\r"); 
....................       strcpy(buffer2,"d"); 
....................       index=0; 
....................       ee_dat=0; 
....................       count_card=1; 
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
....................       { 
....................          unsigned long adr=0; 
....................          //unsigned int count=0; 
....................          rec[0]=0; 
....................          count_card_tg=get_countcard(); 
....................          adr=count_card*numdata; 
....................          addr_key=EEPROM_KEY_ST; 
....................          while(count_card<=count_card_tg) 
....................          { 
....................             adr=count_card*numdata+ptr_start; 
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
....................             ee_dat=0; 
....................             index=0; 
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
....................                ee_dat = rec[index+5]; 
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
....................                index++; 
....................                if(ee_dat==0)break; 
....................             } 
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................             index=0; 
....................             ee_dat=0; 
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
....................                index++; 
....................                if(ee_dat==0)break; 
....................             } 
....................             index=0; 
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
....................             if(ptr_card_key>addr_key) 
....................             { 
....................                i=0; 
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
....................                      fputc(ee_dat,COM2); 
....................                   i++; 
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+50; 
....................                fprintf(COM2,"\n\r"); 
....................             } 
....................             count_card++; 
....................          } 
....................       }  
....................       strcpy(buffer2,"f"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
....................          format_eepromext(); 
....................          fprintf(COM2," exit\n\r");  
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
....................          ease_eeprom(); 
....................          fprintf(COM2," exit\n\r");  
....................       }     
....................      strcpy(buffer2,"RSPW"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
....................          reset_password(); 
....................          init_password(); 
....................          fprintf(COM2," exit\n\r");  
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
....................       }   
....................       strcpy(buffer2,"rsfact"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
....................          rstfact(); 
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
....................       { 
....................          mode=LOGOFF; 
....................          keydebug_en=0; 
....................          set_tris_a(0xff); 
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          fprintf(COM2,"New console name>"); 
....................          USART_getstring(EN_ECHO,16, console); 
....................          EEPROM_write(strobe_nameconsole,16,console); 
....................          fprintf(COM2," OK\n\r"); 
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
....................          else fprintf(COM2,"[S]");   
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
....................          fprintf(COM2,"[%u]",delaycharaction); 
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
....................       } 
....................       strcpy(buffer2,"sc"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          fprintf(COM2,"Year>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          year=(unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Month>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          mon=(unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Date>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          date = (unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Day>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          day = (unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Hour>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          h = (unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Minutes>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          min = (unsigned int8)strtoi(temp);                   
....................          fprintf(COM2,"Seconds>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          sec = (unsigned int8)strtoi(temp);                   
....................          fprintf(COM2,"\n\r"); 
....................          rtc_set_datetime(date,mon,year,day,h,min); 
....................       } 
....................       strcpy(buffer2,"MS"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to select Master mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           mode_sl = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
....................           set_tris_a(0xff); 
....................           fprintf(COM2,"\n\r"); 
....................       } 
....................       strcpy(buffer2,"KP"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           KP_mode = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
....................           fprintf(COM2,"\n\r"); 
....................       } 
....................       strcpy(buffer2,"tran time"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaycharaction = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           type_KB=(unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(kindofKB,type_KB); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          printf("h-> Help\n\r"); 
....................          printf("sc-> Set Clock\n\r"); 
....................          printf("c-> show Clock\n\r"); 
....................          printf("password-> changing PASSWORD\n\r"); 
....................          printf("n -> change console Name\n\r"); 
....................          printf("f-> Format\n\r"); 
....................          printf("e-> Exit\n\r");   
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
....................          printf("tran time-> time of each transaction\n\r"); 
....................          printf("debug-> on/off debug mode\n\r");      
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
....................          printf("rsfact-> reset factory\n\r");      
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
....................       if(!stringcomp(buffer_uart,buffer2))  
....................       { 
....................          fprintf(COM2,"old password:"); 
....................          EEPROM_read(strobe_pass_addr,20,password); 
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
....................          if(!stringcomp(entpassword,password)) 
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
....................             fprintf(COM2,"\n\ragain:"); 
....................             USART_getstring(STAR_ECHO, 20, password); 
....................             if(!stringcomp(entpassword,password)) 
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
....................                fprintf(COM2,"\n\rOK\n\r");    
....................             } 
....................                else 
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
....................                } 
....................          } 
....................             else 
....................             { 
....................                fprintf(COM2," X\n\r"); 
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           debugmode = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
.................... } 
.................... //=============================================== 
....................  
....................  
.................... //========================= 
....................  
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... {   
....................    char c; 
....................    //restart_wdt(); 
....................    //disable_interrupts(INT_TIMER0); 
....................    //set_timer0(0);   
....................    //disable_interrupts(INT_RDA);   
....................    c=fgetc(COM1); 
*
22CC:  BTFSS  F9E.5
22CE:  BRA    22CC
22D0:  MOVFF  FAF,AB3
22D4:  MOVLB  A
....................    //if((c>127)||(c<30)) return; 
....................    //fprintf(COM2,"%c ",c);   
....................    #if defined(SIM900) 
....................    count_checking=0; 
22D6:  MOVLB  1
22D8:  CLRF   x07
22DA:  CLRF   x06
....................    if(checking_sim==1) 
22DC:  MOVLB  4
22DE:  DECFSZ x9C,W
22E0:  BRA    22F8
....................    { 
....................       restart_wdt(); 
22E2:  CLRWDT
....................       setup_wdt(WDT_OFF); 
22E4:  BCF    FC0.0
....................       checking_sim=0; 
22E6:  CLRF   x9C
....................       fprintf(COM2,"OK\n\r"); 
22E8:  MOVLW  82
22EA:  MOVWF  FF6
22EC:  MOVLW  23
22EE:  MOVWF  FF7
22F0:  MOVLB  0
22F2:  CALL   07A0
22F6:  MOVLB  4
....................    } 
....................    #endif 
....................    output_toggle(LED); 
22F8:  BCF    F92.6
22FA:  BTG    F89.6
....................    if(booting_done) 
22FC:  MOVLB  1
22FE:  MOVF   xB5,F
2300:  BZ    2336
....................    { 
....................       buffer_uart[UART_index++]=c; 
2302:  MOVF   xB2,W
2304:  INCF   xB2,F
2306:  CLRF   03
2308:  ADDLW  4E
230A:  MOVWF  FE9
230C:  MOVLW  01
230E:  ADDWFC 03,W
2310:  MOVWF  FEA
2312:  MOVFF  AB3,FEF
....................       if(UART_index>=99)  
2316:  MOVF   xB2,W
2318:  SUBLW  62
231A:  BC    231E
....................       { 
....................          UART_index=0; 
231C:  CLRF   xB2
....................       } 
....................       //============================= 
....................       //output_toggle(PIN_C2); 
....................       if(receiver_state==0) 
231E:  MOVF   xB4,F
2320:  BNZ   2336
....................       { 
....................          timing_wait=3000;//3000 
2322:  MOVLW  0B
2324:  MOVLB  4
2326:  MOVWF  x98
2328:  MOVLW  B8
232A:  MOVWF  x97
....................          SIM_state=data_analyze; 
232C:  MOVLW  0D
232E:  MOVWF  x95
....................          count_polling=0; 
2330:  CLRF   x94
2332:  CLRF   x93
2334:  MOVLB  1
....................       } 
....................       //============================= 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................    } 
....................    #if defined(SIM900) 
....................    if(SIM_state==data_analyze) 
2336:  MOVLB  4
2338:  MOVF   x95,W
233A:  SUBLW  0D
233C:  BNZ   236C
....................    { 
....................       over_byte++; 
233E:  MOVLB  1
2340:  INCF   xB6,F
2342:  BTFSC  FD8.2
2344:  INCF   xB7,F
....................       if(over_byte>=200) 
2346:  MOVF   xB7,F
2348:  BNZ   2350
234A:  MOVF   xB6,W
234C:  SUBLW  C7
234E:  BC    236A
....................       { 
....................          over_byte=0; 
2350:  CLRF   xB7
2352:  CLRF   xB6
....................          setup_wdt(WDT_ON); 
2354:  BSF    FC0.0
....................          output_low(rst_sim); 
2356:  BCF    F94.1
2358:  BCF    F8B.1
....................          fprintf(COM2,"\n\rDevice will reset\n\r"); 
235A:  MOVLW  88
235C:  MOVWF  FF6
235E:  MOVLW  23
2360:  MOVWF  FF7
2362:  MOVLB  0
2364:  CALL   07A0
2368:  MOVLB  1
236A:  MOVLB  4
....................       } 
....................    } 
....................    if(SIM_state==MSG_sending)over_byte=0; 
236C:  MOVF   x95,W
236E:  SUBLW  08
2370:  BNZ   237A
2372:  MOVLB  1
2374:  CLRF   xB7
2376:  CLRF   xB6
2378:  MOVLB  4
....................    #endif 
....................    return; 
....................    //enable_interrupts(INT_TIMER0); 
.................... } 
.................... //========================= 
237A:  BCF    F9E.5
237C:  MOVLB  0
237E:  GOTO   0084
.................... #INT_TIMER1 
.................... void timer1() 
.................... { 
....................    output_toggle(LED); 
*
239E:  BCF    F92.6
23A0:  BTG    F89.6
....................    set_timer1(0xffff-50); 
23A2:  SETF   FCF
23A4:  MOVLW  CD
23A6:  MOVWF  FCE
.................... } 
.................... //========================== 
23A8:  BCF    F9E.0
23AA:  GOTO   0084
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
470E:  MOVLB  1
4710:  MOVF   x0F,F
4712:  BZ    474E
....................    { 
....................       if(count_kp<500)count_kp++; 
4714:  MOVF   x12,W
4716:  SUBLW  01
4718:  BNC   4728
471A:  BNZ   4722
471C:  MOVF   x11,W
471E:  SUBLW  F3
4720:  BNC   4728
4722:  INCF   x11,F
4724:  BTFSC  FD8.2
4726:  INCF   x12,F
....................       if(count_kp==500) 
4728:  MOVF   x11,W
472A:  SUBLW  F4
472C:  BNZ   474E
472E:  DECFSZ x12,W
4730:  BRA    474E
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
4732:  MOVLW  42
4734:  MOVWF  FF6
4736:  MOVLW  49
4738:  MOVWF  FF7
473A:  MOVLB  0
473C:  CALL   07A0
....................             keyprss_off; 
4740:  BCF    F92.7
4742:  BCF    F89.7
....................             kp_st=0;     
4744:  MOVLB  1
4746:  CLRF   x10
....................             count_kp++; 
4748:  INCF   x11,F
474A:  BTFSC  FD8.2
474C:  INCF   x12,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
474E:  DECFSZ x0B,W
4750:  BRA    476C
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
4752:  MOVLB  9
4754:  MOVF   xB3,F
4756:  BNZ   4760
4758:  MOVLB  0
475A:  CALL   23AE
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
475E:  BRA    476A
4760:  MOVLB  0
4762:  CALL   360A
4766:  MOVFF  01,AB5
476A:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
476C:  DECFSZ x0C,W
476E:  BRA    4788
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
4770:  MOVLB  9
4772:  MOVF   xB3,F
4774:  BNZ   477E
4776:  MOVLB  0
4778:  CALL   23AE
....................          else temp=kbd_getc_slv(); 
477C:  BRA    4788
477E:  MOVLB  0
4780:  CALL   360A
4784:  MOVFF  01,AB5
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
4788:  MOVLB  9
478A:  MOVF   x98,F
478C:  BNZ   47AC
478E:  MOVF   x97,F
4790:  BNZ   47AC
4792:  MOVF   x96,F
4794:  BNZ   47AC
4796:  MOVF   x95,W
4798:  SUBLW  04
479A:  BNC   47AC
479C:  MOVLW  01
479E:  ADDWF  x95,F
47A0:  BTFSC  FD8.0
47A2:  INCF   x96,F
47A4:  BTFSC  FD8.2
47A6:  INCF   x97,F
47A8:  BTFSC  FD8.2
47AA:  INCF   x98,F
....................   if(mcr_timeout==5) 
47AC:  MOVF   x95,W
47AE:  SUBLW  05
47B0:  BNZ   4806
47B2:  MOVF   x96,F
47B4:  BNZ   4806
47B6:  MOVF   x97,F
47B8:  BNZ   4806
47BA:  MOVF   x98,F
47BC:  BNZ   4806
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
47BE:  DECFSZ xAB,W
47C0:  BRA    47C8
47C2:  MOVLB  0
47C4:  BRA    3FF0
47C6:  MOVLB  9
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
47C8:  MOVLW  05
47CA:  MOVWF  FEA
47CC:  MOVLW  17
47CE:  MOVWF  FE9
47D0:  CLRF   00
47D2:  MOVLW  03
47D4:  MOVWF  02
47D6:  MOVLW  52
47D8:  MOVWF  01
47DA:  MOVLB  0
47DC:  RCALL  446E
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
47DE:  MOVLW  08
47E0:  MOVWF  FEA
47E2:  MOVLW  69
47E4:  MOVWF  FE9
47E6:  CLRF   00
47E8:  MOVLW  01
47EA:  MOVWF  02
47EC:  MOVLW  2C
47EE:  MOVWF  01
47F0:  RCALL  446E
....................       //debug_card(); 
....................       count_reading_error=0; 
47F2:  MOVLB  9
47F4:  CLRF   xAC
....................       mcr_timeout++;   
47F6:  MOVLW  01
47F8:  ADDWF  x95,F
47FA:  BTFSC  FD8.0
47FC:  INCF   x96,F
47FE:  BTFSC  FD8.2
4800:  INCF   x97,F
4802:  BTFSC  FD8.2
4804:  INCF   x98,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
4806:  MOVLB  A
4808:  CLRF   xC0
480A:  MOVLW  94
480C:  MOVWF  xBF
480E:  MOVLB  0
4810:  CALL   3948
4814:  MOVFF  01,146
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
4818:  MOVLW  02
481A:  MOVLB  A
481C:  MOVWF  xBC
481E:  MOVLW  BC
4820:  MOVWF  xBB
4822:  CLRF   xBE
4824:  MOVFF  146,ABD
4828:  MOVLB  0
482A:  CALL   3A40
482E:  MOVFF  02,03
4832:  MOVF   xFC,W
4834:  SUBWF  02,W
4836:  BNC   4846
4838:  BNZ   4840
483A:  MOVF   01,W
483C:  SUBWF  xFB,W
483E:  BC    4846
4840:  INCF   xFB,F
4842:  BTFSC  FD8.2
4844:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
4846:  MOVLW  02
4848:  MOVLB  A
484A:  MOVWF  xBC
484C:  MOVLW  BC
484E:  MOVWF  xBB
4850:  CLRF   xBE
4852:  MOVFF  146,ABD
4856:  MOVLB  0
4858:  CALL   3A40
485C:  MOVFF  02,03
4860:  MOVF   01,W
4862:  SUBWF  xFB,W
4864:  BNZ   493C
4866:  MOVF   03,W
4868:  SUBWF  xFC,W
486A:  BNZ   493C
....................   { 
....................       charac_timeout++; 
486C:  INCF   xFB,F
486E:  BTFSC  FD8.2
4870:  INCF   xFC,F
....................       buf=get_countcard(); 
4872:  CALL   39F0
4876:  MOVFF  02,AB4
487A:  MOVFF  01,AB3
....................       if(buf<countcards) 
487E:  MOVLB  A
4880:  MOVF   xB4,W
4882:  SUBLW  01
4884:  BNC   48AC
4886:  BNZ   488E
4888:  MOVF   xB3,W
488A:  SUBLW  5D
488C:  BNC   48AC
....................       { 
....................          save_key_new(); 
488E:  MOVLB  0
4890:  BRA    4488
....................          buf=buf+1; 
4892:  MOVLW  01
4894:  MOVLB  A
4896:  ADDWF  xB3,F
4898:  MOVLW  00
489A:  ADDWFC xB4,F
....................          save_coutcard(buf); 
489C:  MOVFF  AB4,AB7
48A0:  MOVFF  AB3,AB6
48A4:  MOVLB  0
48A6:  RCALL  45DC
....................       } 
....................          else 
48A8:  BRA    48DE
48AA:  MOVLB  A
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
48AC:  MOVLW  52
48AE:  MOVWF  FF6
48B0:  MOVLW  49
48B2:  MOVWF  FF7
48B4:  MOVLB  0
48B6:  CALL   07A0
....................             #if defined(SIM900) 
....................                //SIM_state=autosending; 
....................                SIM_state=SIM_reply;   
48BA:  MOVLW  0E
48BC:  MOVLB  4
48BE:  MOVWF  x95
....................                strcpy(reply_buffer,"Full memory, please format memory"); 
48C0:  MOVLW  03
48C2:  MOVWF  FEA
48C4:  MOVLW  48
48C6:  MOVWF  FE9
48C8:  MOVLW  00
48CA:  MOVLB  0
48CC:  CALL   017C
48D0:  TBLRD*-
48D2:  TBLRD*+
48D4:  MOVF   FF5,W
48D6:  MOVWF  FEE
48D8:  IORLW  00
48DA:  BNZ   48D2
....................             #endif 
....................             return; 
48DC:  BRA    493C
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
48DE:  MOVLW  62
48E0:  MOVWF  FF6
48E2:  MOVLW  49
48E4:  MOVWF  FF7
48E6:  CALL   07A0
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
48EA:  MOVLW  72
48EC:  MOVWF  FF6
48EE:  MOVLW  49
48F0:  MOVWF  FF7
48F2:  MOVLW  14
48F4:  MOVLB  A
48F6:  MOVWF  xD3
48F8:  MOVLB  0
48FA:  CALL   1718
48FE:  MOVLW  10
4900:  MOVWF  FE9
4902:  MOVFF  AB4,AB7
4906:  MOVFF  AB3,AB6
490A:  BRA    4616
490C:  MOVLW  89
490E:  MOVWF  FF6
4910:  MOVLW  49
4912:  MOVWF  FF7
4914:  MOVLW  03
4916:  MOVLB  A
4918:  MOVWF  xD3
491A:  MOVLB  0
491C:  CALL   1718
....................       data_avai=0; 
4920:  MOVLB  9
4922:  CLRF   xAA
....................       enable_getpin=0; 
4924:  MOVLB  1
4926:  CLRF   x0C
....................       //dis_getpin; 
....................       output_low(LED); 
4928:  BCF    F92.6
492A:  BCF    F89.6
....................       #if defined(SIM900) 
....................        if(auto_sending==1)SIM_state=autosending; 
492C:  MOVLB  4
492E:  DECFSZ x99,W
4930:  BRA    4936
4932:  MOVLW  0B
4934:  MOVWF  x95
....................        #if defined(twonumber) 
....................             two_number_sending=1; 
4936:  MOVLW  01
4938:  MOVWF  x9F
493A:  MOVLB  0
....................        #endif 
....................       #endif 
....................   } 
....................   //================================= 
....................   //================================= 
.................... } 
.................... //========================= 
493C:  BCF    FF2.2
493E:  GOTO   0084
.................... void main() 
.................... {  
*
6BF2:  CLRF   FF8
6BF4:  BCF    FD0.7
6BF6:  BSF    07.7
6BF8:  CLRF   FEA
6BFA:  CLRF   FE9
6BFC:  BSF    F7E.3
6BFE:  MOVLW  40
6C00:  MOVWF  FB0
6C02:  MOVLW  03
6C04:  MOVWF  F7F
6C06:  MOVLW  A6
6C08:  MOVWF  FAD
6C0A:  MOVLW  90
6C0C:  MOVWF  FAC
6C0E:  BCF    F94.0
6C10:  BSF    F8B.0
6C12:  CLRF   23
6C14:  CLRF   22
6C16:  CLRF   21
6C18:  MOVLW  96
6C1A:  MOVWF  20
6C1C:  CLRF   27
6C1E:  CLRF   26
6C20:  MOVLW  AA
6C22:  MOVWF  25
6C24:  MOVLW  47
6C26:  MOVWF  24
6C28:  CLRF   xFA
6C2A:  CLRF   xF9
6C2C:  SETF   xFC
6C2E:  SETF   xFB
6C30:  MOVLW  0E
6C32:  MOVWF  xFE
6C34:  MOVLW  01
6C36:  MOVWF  xFF
6C38:  MOVLB  1
6C3A:  MOVWF  x00
6C3C:  CLRF   x01
6C3E:  CLRF   x02
6C40:  CLRF   x03
6C42:  CLRF   x04
6C44:  CLRF   x05
6C46:  CLRF   x07
6C48:  MOVLW  0A
6C4A:  MOVWF  x06
6C4C:  MOVLW  03
6C4E:  MOVWF  x09
6C50:  MOVLW  E8
6C52:  MOVWF  x08
6C54:  CLRF   x0A
6C56:  CLRF   x0B
6C58:  CLRF   x0C
6C5A:  MOVLW  64
6C5C:  MOVWF  x0D
6C5E:  CLRF   x0E
6C60:  CLRF   x0F
6C62:  CLRF   x10
6C64:  CLRF   x12
6C66:  CLRF   x11
6C68:  CLRF   x13
6C6A:  CLRF   x46
6C6C:  CLRF   x4B
6C6E:  CLRF   xB2
6C70:  CLRF   xB3
6C72:  CLRF   xB4
6C74:  CLRF   xB5
6C76:  CLRF   xB7
6C78:  CLRF   xB6
6C7A:  MOVLB  4
6C7C:  CLRF   x94
6C7E:  CLRF   x93
6C80:  CLRF   x95
6C82:  CLRF   x96
6C84:  CLRF   x98
6C86:  MOVWF  x97
6C88:  CLRF   x99
6C8A:  CLRF   x9A
6C8C:  CLRF   x9B
6C8E:  CLRF   x9C
6C90:  CLRF   x9D
6C92:  CLRF   x9E
6C94:  CLRF   x9F
6C96:  MOVLB  9
6C98:  CLRF   x98
6C9A:  CLRF   x97
6C9C:  CLRF   x96
6C9E:  CLRF   x95
6CA0:  CLRF   x99
6CA2:  CLRF   x9B
6CA4:  CLRF   x9A
6CA6:  CLRF   x9D
6CA8:  CLRF   x9C
6CAA:  CLRF   x9F
6CAC:  CLRF   x9E
6CAE:  CLRF   xA1
6CB0:  CLRF   xA0
6CB2:  MOVLW  FD
6CB4:  MOVWF  xA3
6CB6:  MOVLW  E8
6CB8:  MOVWF  xA2
6CBA:  CLRF   xA5
6CBC:  CLRF   xA4
6CBE:  CLRF   xA6
6CC0:  CLRF   xA7
6CC2:  CLRF   xA8
6CC4:  CLRF   xA9
6CC6:  CLRF   xAA
6CC8:  CLRF   xAB
6CCA:  CLRF   xAC
6CCC:  CLRF   xAD
6CCE:  CLRF   xAE
6CD0:  CLRF   xB0
6CD2:  MOVLW  01
6CD4:  MOVWF  xAF
6CD6:  CLRF   xB2
6CD8:  CLRF   xB1
6CDA:  CLRF   xB3
6CDC:  CLRF   xB7
6CDE:  CLRF   xB6
6CE0:  CLRF   xB5
6CE2:  CLRF   xB4
6CE4:  MOVLW  FF
6CE6:  MOVLB  F
6CE8:  MOVWF  x48
6CEA:  BCF    FC2.6
6CEC:  BCF    FC2.7
6CEE:  MOVF   x49,W
6CF0:  ANDLW  E0
6CF2:  IORLW  1F
6CF4:  MOVWF  x49
6CF6:  CLRF   FD2
6CF8:  CLRF   FD1
6CFA:  CLRF   1A
6CFC:  CLRF   1B
6CFE:  MOVLB  1
6D00:  CLRF   x47
6D02:  BCF    x48.0
6D04:  CLRF   x49
6D06:  CLRF   x4A
6D08:  CLRF   x4C
6D0A:  BCF    x48.1
6D0C:  CLRF   x4D
6D0E:  MOVLB  4
6D10:  CLRF   x79
6D12:  CLRF   x7A
6D14:  CLRF   x7B
6D16:  CLRF   x7C
6D18:  CLRF   x7D
6D1A:  CLRF   x7E
6D1C:  CLRF   x7F
6D1E:  CLRF   x80
6D20:  CLRF   x81
6D22:  CLRF   x82
6D24:  CLRF   x83
6D26:  CLRF   x84
6D28:  CLRF   x85
6D2A:  CLRF   x86
6D2C:  CLRF   x87
6D2E:  CLRF   x88
6D30:  CLRF   x89
6D32:  CLRF   x8A
6D34:  CLRF   x8B
6D36:  CLRF   x8C
6D38:  CLRF   x8D
6D3A:  CLRF   x8E
6D3C:  CLRF   x8F
6D3E:  CLRF   x90
6D40:  CLRF   x91
6D42:  CLRF   x92
6D44:  MOVLB  9
6D46:  CLRF   xC8
6D48:  CLRF   xC9
6D4A:  CLRF   xCA
6D4C:  CLRF   xCB
6D4E:  CLRF   xCC
6D50:  CLRF   xCD
6D52:  CLRF   xCE
6D54:  CLRF   xCF
6D56:  CLRF   xD0
6D58:  CLRF   xD1
6D5A:  CLRF   xD4
6D5C:  CLRF   xD6
6D5E:  CLRF   xD5
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................    RPINR1=5; 
6D60:  MOVLW  05
6D62:  MOVLB  E
6D64:  MOVWF  xE7
....................    SIM_state = 0xff; 
6D66:  MOVLB  4
6D68:  SETF   x95
....................    charac_timeout=0xffffffff; 
6D6A:  MOVLB  0
6D6C:  SETF   xFC
6D6E:  SETF   xFB
....................    key_timeout=0xffff; 
6D70:  MOVLB  1
6D72:  SETF   x09
6D74:  SETF   x08
....................    setup_oscillator(OSC_32MHZ); 
6D76:  MOVLW  70
6D78:  MOVWF  FD3
6D7A:  MOVLW  40
6D7C:  MOVWF  F9B
6D7E:  MOVF   FD3,W
....................    keyprss_off; 
6D80:  BCF    F92.7
6D82:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
6D84:  BCF    FF2.6
6D86:  BCF    FF2.7
6D88:  BTFSC  FF2.7
6D8A:  BRA    6D86
....................    init_ext_eeprom(); 
6D8C:  MOVLB  0
6D8E:  GOTO   5058
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
6D92:  MOVLW  04
6D94:  MOVLB  A
6D96:  MOVWF  x8E
6D98:  CLRF   19
6D9A:  BTFSC  FF2.7
6D9C:  BSF    19.7
6D9E:  BCF    FF2.7
6DA0:  MOVLW  FA
6DA2:  MOVWF  xBC
6DA4:  MOVLB  0
6DA6:  CALL   1984
6DAA:  BTFSC  19.7
6DAC:  BSF    FF2.7
6DAE:  MOVLB  A
6DB0:  DECFSZ x8E,F
6DB2:  BRA    6D98
....................    init_password(); 
6DB4:  MOVLB  0
6DB6:  CALL   510E
....................    EEPROM_read(strobe_pass_addr,20,password); 
6DBA:  MOVLB  A
6DBC:  CLRF   x8E
6DBE:  MOVLW  14
6DC0:  MOVWF  x8F
6DC2:  CLRF   x91
6DC4:  MOVLW  55
6DC6:  MOVWF  x90
6DC8:  MOVLB  0
6DCA:  CALL   5062
6DCE:  CLRF   19
6DD0:  BTFSC  FF2.7
6DD2:  BSF    19.7
6DD4:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
6DD6:  MOVLB  A
6DD8:  CLRF   xC0
6DDA:  MOVLW  7F
6DDC:  MOVWF  xBF
6DDE:  MOVLB  0
6DE0:  CALL   3948
6DE4:  BTFSC  19.7
6DE6:  BSF    FF2.7
6DE8:  MOVFF  01,10F
....................    //===================================== 
....................    rtc_init(); 
6DEC:  GOTO   517C
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
6DF0:  MOVLW  19
6DF2:  MOVLB  A
6DF4:  MOVWF  x8E
6DF6:  MOVLB  0
6DF8:  CALL   5292
6DFC:  MOVFF  03,23
6E00:  MOVFF  02,22
6E04:  MOVFF  01,21
6E08:  MOVFF  00,20
....................     
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
6E0C:  MOVLW  1E
6E0E:  MOVLB  A
6E10:  MOVWF  x8E
6E12:  MOVLB  0
6E14:  CALL   5292
6E18:  MOVFF  03,27
6E1C:  MOVFF  02,26
6E20:  MOVFF  01,25
6E24:  MOVFF  00,24
6E28:  CLRF   19
6E2A:  BTFSC  FF2.7
6E2C:  BSF    19.7
6E2E:  BCF    FF2.7
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card_key); 
....................    countcard=get_countcard(); 
6E30:  CALL   39F0
6E34:  BTFSC  19.7
6E36:  BSF    FF2.7
6E38:  MOVFF  02,FA
6E3C:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
6E40:  SETF   xFC
6E42:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
6E44:  MOVLW  C7
6E46:  MOVWF  FD5
6E48:  CLRF   19
6E4A:  BTFSC  FF2.7
6E4C:  BSF    19.7
6E4E:  BCF    FF2.7
....................    //setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
6E50:  MOVLB  A
6E52:  CLRF   xC0
6E54:  MOVLW  94
6E56:  MOVWF  xBF
6E58:  MOVLB  0
6E5A:  CALL   3948
6E5E:  BTFSC  19.7
6E60:  BSF    FF2.7
6E62:  MOVFF  01,146
....................    if(delaycharaction==0)delaycharaction=1; 
6E66:  MOVLB  1
6E68:  MOVF   x46,F
6E6A:  BNZ   6E70
6E6C:  MOVLW  01
6E6E:  MOVWF  x46
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
6E70:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
6E72:  BSF    FF0.3
6E74:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
6E76:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
6E78:  MOVLW  C0
6E7A:  IORWF  FF2,F
....................    //========================================== 
....................    //delay_ms(100); 
....................    //EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................    //reset_password(); 
....................    //init_password(); 
....................    //fprintf(COM2,"Start\r\n"); 
....................    mcr_timeout=10000; 
6E7C:  MOVLB  9
6E7E:  CLRF   x98
6E80:  CLRF   x97
6E82:  MOVLW  27
6E84:  MOVWF  x96
6E86:  MOVLW  10
6E88:  MOVWF  x95
6E8A:  CLRF   19
6E8C:  BTFSC  FF2.7
6E8E:  BSF    19.7
6E90:  BCF    FF2.7
....................    //EEPROM_read(strobe_pass_addr,20,password); 
....................    //========================================== 
....................    //write_ext_eeprom(strobe_Master_SLV,1); 
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6E92:  MOVLB  A
6E94:  CLRF   xC0
6E96:  MOVLW  91
6E98:  MOVWF  xBF
6E9A:  MOVLB  0
6E9C:  CALL   3948
6EA0:  BTFSC  19.7
6EA2:  BSF    FF2.7
6EA4:  MOVFF  01,9B3
6EA8:  CLRF   19
6EAA:  BTFSC  FF2.7
6EAC:  BSF    19.7
6EAE:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
6EB0:  MOVLB  A
6EB2:  CLRF   xC0
6EB4:  MOVLW  92
6EB6:  MOVWF  xBF
6EB8:  MOVLB  0
6EBA:  CALL   3948
6EBE:  BTFSC  19.7
6EC0:  BSF    FF2.7
6EC2:  MOVFF  01,9A7
....................     key_timeout=1000; 
6EC6:  MOVLW  03
6EC8:  MOVLB  1
6ECA:  MOVWF  x09
6ECC:  MOVLW  E8
6ECE:  MOVWF  x08
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
6ED0:  MOVLB  0
6ED2:  SETF   xFC
6ED4:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    #if defined(SIM900) 
....................       disable_interrupts(GLOBAL); 
6ED6:  BCF    FF2.6
6ED8:  BCF    FF2.7
6EDA:  BTFSC  FF2.7
6EDC:  BRA    6ED8
....................       output_high(rst_sim); 
6EDE:  BCF    F94.1
6EE0:  BSF    F8B.1
....................       //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................       //output_low(PIN_C7); 
....................       //set_tris_c(0); 
....................       #ASM 
....................          BCF    0xF94.7 
6EE2:  BCF    F94.7
....................       #ENDASM 
....................       SIM_state = 0xff; 
6EE4:  MOVLB  4
6EE6:  SETF   x95
....................       fprintf(COM2,"\r\nbooting...\r\n"); 
6EE8:  MOVLW  8E
6EEA:  MOVWF  FF6
6EEC:  MOVLW  49
6EEE:  MOVWF  FF7
6EF0:  CLRF   19
6EF2:  BTFSC  FF2.7
6EF4:  BSF    19.7
6EF6:  BCF    FF2.7
6EF8:  MOVLB  0
6EFA:  CALL   07A0
6EFE:  BTFSC  19.7
6F00:  BSF    FF2.7
....................       delay_ms(10000); 
6F02:  MOVLW  28
6F04:  MOVLB  A
6F06:  MOVWF  x8E
6F08:  CLRF   19
6F0A:  BTFSC  FF2.7
6F0C:  BSF    19.7
6F0E:  BCF    FF2.7
6F10:  MOVLW  FA
6F12:  MOVWF  xBC
6F14:  MOVLB  0
6F16:  CALL   1984
6F1A:  BTFSC  19.7
6F1C:  BSF    FF2.7
6F1E:  MOVLB  A
6F20:  DECFSZ x8E,F
6F22:  BRA    6F08
....................       receiver_state=1; 
6F24:  MOVLW  01
6F26:  MOVLB  1
6F28:  MOVWF  xB4
....................       fprintf(COM1,"AT\r\n"); 
6F2A:  MOVLW  9E
6F2C:  MOVWF  FF6
6F2E:  MOVLW  49
6F30:  MOVWF  FF7
6F32:  MOVLB  0
6F34:  CALL   53D0
....................       delay_ms(1000); 
6F38:  MOVLW  04
6F3A:  MOVLB  A
6F3C:  MOVWF  x8E
6F3E:  CLRF   19
6F40:  BTFSC  FF2.7
6F42:  BSF    19.7
6F44:  BCF    FF2.7
6F46:  MOVLW  FA
6F48:  MOVWF  xBC
6F4A:  MOVLB  0
6F4C:  CALL   1984
6F50:  BTFSC  19.7
6F52:  BSF    FF2.7
6F54:  MOVLB  A
6F56:  DECFSZ x8E,F
6F58:  BRA    6F3E
....................       fprintf(COM1,"AT+CMGF=1\r\n"); 
6F5A:  MOVLW  A4
6F5C:  MOVWF  FF6
6F5E:  MOVLW  49
6F60:  MOVWF  FF7
6F62:  MOVLB  0
6F64:  CALL   53D0
....................       delay_ms(1000); 
6F68:  MOVLW  04
6F6A:  MOVLB  A
6F6C:  MOVWF  x8E
6F6E:  CLRF   19
6F70:  BTFSC  FF2.7
6F72:  BSF    19.7
6F74:  BCF    FF2.7
6F76:  MOVLW  FA
6F78:  MOVWF  xBC
6F7A:  MOVLB  0
6F7C:  CALL   1984
6F80:  BTFSC  19.7
6F82:  BSF    FF2.7
6F84:  MOVLB  A
6F86:  DECFSZ x8E,F
6F88:  BRA    6F6E
....................       //sim900_init(); 
....................       EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
6F8A:  MOVLW  55
6F8C:  MOVWF  x8E
6F8E:  MOVLW  14
6F90:  MOVWF  x8F
6F92:  MOVLW  04
6F94:  MOVWF  x91
6F96:  MOVLW  79
6F98:  MOVWF  x90
6F9A:  MOVLB  0
6F9C:  CALL   5062
....................       fprintf(COM1,"AT+CSMP=17,167,0,245\r\n"); 
6FA0:  MOVLW  B0
6FA2:  MOVWF  FF6
6FA4:  MOVLW  49
6FA6:  MOVWF  FF7
6FA8:  CALL   53D0
....................       delay_ms(1000); 
6FAC:  MOVLW  04
6FAE:  MOVLB  A
6FB0:  MOVWF  x8E
6FB2:  CLRF   19
6FB4:  BTFSC  FF2.7
6FB6:  BSF    19.7
6FB8:  BCF    FF2.7
6FBA:  MOVLW  FA
6FBC:  MOVWF  xBC
6FBE:  MOVLB  0
6FC0:  CALL   1984
6FC4:  BTFSC  19.7
6FC6:  BSF    FF2.7
6FC8:  MOVLB  A
6FCA:  DECFSZ x8E,F
6FCC:  BRA    6FB2
....................       fprintf(COM1,"AT+CMGD=1\r\n");  
6FCE:  MOVLW  C8
6FD0:  MOVWF  FF6
6FD2:  MOVLW  49
6FD4:  MOVWF  FF7
6FD6:  MOVLB  0
6FD8:  CALL   53D0
....................       delay_ms(1000); 
6FDC:  MOVLW  04
6FDE:  MOVLB  A
6FE0:  MOVWF  x8E
6FE2:  CLRF   19
6FE4:  BTFSC  FF2.7
6FE6:  BSF    19.7
6FE8:  BCF    FF2.7
6FEA:  MOVLW  FA
6FEC:  MOVWF  xBC
6FEE:  MOVLB  0
6FF0:  CALL   1984
6FF4:  BTFSC  19.7
6FF6:  BSF    FF2.7
6FF8:  MOVLB  A
6FFA:  DECFSZ x8E,F
6FFC:  BRA    6FE2
....................       fprintf(COM1,"AT+CMGD=2\r\n"); 
6FFE:  MOVLW  D4
7000:  MOVWF  FF6
7002:  MOVLW  49
7004:  MOVWF  FF7
7006:  MOVLB  0
7008:  CALL   53D0
....................       delay_ms(1000); 
700C:  MOVLW  04
700E:  MOVLB  A
7010:  MOVWF  x8E
7012:  CLRF   19
7014:  BTFSC  FF2.7
7016:  BSF    19.7
7018:  BCF    FF2.7
701A:  MOVLW  FA
701C:  MOVWF  xBC
701E:  MOVLB  0
7020:  CALL   1984
7024:  BTFSC  19.7
7026:  BSF    FF2.7
7028:  MOVLB  A
702A:  DECFSZ x8E,F
702C:  BRA    7012
....................       fprintf(COM1,"AT+CMGD=3\r\n"); 
702E:  MOVLW  E0
7030:  MOVWF  FF6
7032:  MOVLW  49
7034:  MOVWF  FF7
7036:  MOVLB  0
7038:  CALL   53D0
....................       delay_ms(1000); 
703C:  MOVLW  04
703E:  MOVLB  A
7040:  MOVWF  x8E
7042:  CLRF   19
7044:  BTFSC  FF2.7
7046:  BSF    19.7
7048:  BCF    FF2.7
704A:  MOVLW  FA
704C:  MOVWF  xBC
704E:  MOVLB  0
7050:  CALL   1984
7054:  BTFSC  19.7
7056:  BSF    FF2.7
7058:  MOVLB  A
705A:  DECFSZ x8E,F
705C:  BRA    7042
....................       fprintf(COM1,"AT+CMGD=4\r\n"); 
705E:  MOVLW  EC
7060:  MOVWF  FF6
7062:  MOVLW  49
7064:  MOVWF  FF7
7066:  MOVLB  0
7068:  CALL   53D0
....................       delay_ms(1000); 
706C:  MOVLW  04
706E:  MOVLB  A
7070:  MOVWF  x8E
7072:  CLRF   19
7074:  BTFSC  FF2.7
7076:  BSF    19.7
7078:  BCF    FF2.7
707A:  MOVLW  FA
707C:  MOVWF  xBC
707E:  MOVLB  0
7080:  CALL   1984
7084:  BTFSC  19.7
7086:  BSF    FF2.7
7088:  MOVLB  A
708A:  DECFSZ x8E,F
708C:  BRA    7072
....................       fprintf(COM1,"AT+CMGD=5\r\n");  
708E:  MOVLW  F8
7090:  MOVWF  FF6
7092:  MOVLW  49
7094:  MOVWF  FF7
7096:  MOVLB  0
7098:  CALL   53D0
....................       output_high(LED); 
709C:  BCF    F92.6
709E:  BSF    F89.6
....................       delay_ms(1000); 
70A0:  MOVLW  04
70A2:  MOVLB  A
70A4:  MOVWF  x8E
70A6:  CLRF   19
70A8:  BTFSC  FF2.7
70AA:  BSF    19.7
70AC:  BCF    FF2.7
70AE:  MOVLW  FA
70B0:  MOVWF  xBC
70B2:  MOVLB  0
70B4:  CALL   1984
70B8:  BTFSC  19.7
70BA:  BSF    FF2.7
70BC:  MOVLB  A
70BE:  DECFSZ x8E,F
70C0:  BRA    70A6
....................       SIM_state= idle; 
70C2:  MOVLW  0C
70C4:  MOVLB  4
70C6:  MOVWF  x95
....................       #ASM 
....................          BSF    0xF94.7 
70C8:  BSF    F94.7
....................       #ENDASM 
....................       //set_tris_c(0xff); 
....................       //setup_wdt(WDT_ON); 
....................       enable_interrupts(GLOBAL); 
70CA:  MOVLW  C0
70CC:  IORWF  FF2,F
....................    #endif 
....................    booting=1; 
70CE:  MOVLW  01
70D0:  MOVLB  1
70D2:  MOVWF  x05
....................    charac_timeout=0xffffffff; 
70D4:  MOVLB  0
70D6:  SETF   xFC
70D8:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
70DA:  MOVLW  66
70DC:  MOVLB  A
70DE:  MOVWF  x8E
70E0:  MOVLW  10
70E2:  MOVWF  x8F
70E4:  MOVLW  09
70E6:  MOVWF  x91
70E8:  MOVLW  B8
70EA:  MOVWF  x90
70EC:  MOVLB  0
70EE:  CALL   5062
....................    EEPROM_read(strobe_pass_addr,20,password); 
70F2:  MOVLB  A
70F4:  CLRF   x8E
70F6:  MOVLW  14
70F8:  MOVWF  x8F
70FA:  CLRF   x91
70FC:  MOVLW  55
70FE:  MOVWF  x90
7100:  MOVLB  0
7102:  CALL   5062
....................    set_tris_a(0xff);  
7106:  MOVLW  FF
7108:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
710A:  MOVLW  E0
710C:  MOVLB  F
710E:  MOVWF  x48
7110:  BCF    FC2.6
7112:  BCF    FC2.7
7114:  MOVF   x49,W
7116:  ANDLW  E0
7118:  IORLW  1F
711A:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
711C:  MOVF   FC1,W
711E:  ANDLW  C0
7120:  IORLW  03
7122:  MOVWF  FC1
7124:  BCF    FC1.7
7126:  BSF    FC2.0
7128:  BSF    FC1.6
712A:  BSF    FC2.1
712C:  BTFSC  FC2.1
712E:  BRA    712C
7130:  BCF    FC1.6
7132:  CLRF   19
7134:  BTFSC  FF2.7
7136:  BSF    19.7
7138:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
713A:  MOVLB  A
713C:  CLRF   xC0
713E:  MOVLW  7F
7140:  MOVWF  xBF
7142:  MOVLB  0
7144:  CALL   3948
7148:  BTFSC  19.7
714A:  BSF    FF2.7
714C:  MOVFF  01,10F
7150:  CLRF   19
7152:  BTFSC  FF2.7
7154:  BSF    19.7
7156:  BCF    FF2.7
....................    type_KB=read_ext_eeprom(kindofKB); 
7158:  MOVLB  A
715A:  CLRF   xC0
715C:  MOVLW  7E
715E:  MOVWF  xBF
7160:  MOVLB  0
7162:  CALL   3948
7166:  BTFSC  19.7
7168:  BSF    FF2.7
716A:  MOVFF  01,113
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
716E:  MOVLB  1
7170:  MOVF   x13,F
7172:  BZ    7192
7174:  MOVLW  04
7176:  MOVWF  FF6
7178:  MOVLW  4A
717A:  MOVWF  FF7
717C:  CLRF   19
717E:  BTFSC  FF2.7
7180:  BSF    19.7
7182:  BCF    FF2.7
7184:  MOVLB  0
7186:  CALL   07A0
718A:  BTFSC  19.7
718C:  BSF    FF2.7
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
718E:  BRA    71AC
7190:  MOVLB  1
7192:  MOVLW  18
7194:  MOVWF  FF6
7196:  MOVLW  4A
7198:  MOVWF  FF7
719A:  CLRF   19
719C:  BTFSC  FF2.7
719E:  BSF    19.7
71A0:  BCF    FF2.7
71A2:  MOVLB  0
71A4:  CALL   07A0
71A8:  BTFSC  19.7
71AA:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
71AC:  MOVLB  9
71AE:  MOVF   xB3,F
71B0:  BNZ   71D0
71B2:  MOVLW  2C
71B4:  MOVWF  FF6
71B6:  MOVLW  4A
71B8:  MOVWF  FF7
71BA:  CLRF   19
71BC:  BTFSC  FF2.7
71BE:  BSF    19.7
71C0:  BCF    FF2.7
71C2:  MOVLB  0
71C4:  CALL   07A0
71C8:  BTFSC  19.7
71CA:  BSF    FF2.7
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
71CC:  BRA    71EA
71CE:  MOVLB  9
71D0:  MOVLW  46
71D2:  MOVWF  FF6
71D4:  MOVLW  4A
71D6:  MOVWF  FF7
71D8:  CLRF   19
71DA:  BTFSC  FF2.7
71DC:  BSF    19.7
71DE:  BCF    FF2.7
71E0:  MOVLB  0
71E2:  CALL   07A0
71E6:  BTFSC  19.7
71E8:  BSF    FF2.7
....................     
....................    #if defined(SIM900) 
....................       #if defined(twonumber) 
....................          fprintf(COM2,"two numbers mode ver\n\r"); 
71EA:  MOVLW  5E
71EC:  MOVWF  FF6
71EE:  MOVLW  4A
71F0:  MOVWF  FF7
71F2:  CLRF   19
71F4:  BTFSC  FF2.7
71F6:  BSF    19.7
71F8:  BCF    FF2.7
71FA:  CALL   07A0
71FE:  BTFSC  19.7
7200:  BSF    FF2.7
7202:  CLRF   19
7204:  BTFSC  FF2.7
7206:  BSF    19.7
7208:  BCF    FF2.7
....................          #else    
....................             fprintf(COM2,"one numbers mode ver\n\r"); 
....................       #endif 
....................       //twonumber=read_ext_eeprom(strobe_two_number); 
....................       auto_sending=read_ext_eeprom(strobe_autosending);   
720A:  MOVLB  A
720C:  CLRF   xC0
720E:  MOVLW  93
7210:  MOVWF  xBF
7212:  MOVLB  0
7214:  CALL   3948
7218:  BTFSC  19.7
721A:  BSF    FF2.7
721C:  MOVFF  01,499
....................       if(auto_sending==0)fprintf(COM2,"autosending is disable\n\r"); 
7220:  MOVLB  4
7222:  MOVF   x99,F
7224:  BNZ   7244
7226:  MOVLW  76
7228:  MOVWF  FF6
722A:  MOVLW  4A
722C:  MOVWF  FF7
722E:  CLRF   19
7230:  BTFSC  FF2.7
7232:  BSF    19.7
7234:  BCF    FF2.7
7236:  MOVLB  0
7238:  CALL   07A0
723C:  BTFSC  19.7
723E:  BSF    FF2.7
....................          else fprintf(COM2,"autosending is enable\n\r"); 
7240:  BRA    725E
7242:  MOVLB  4
7244:  MOVLW  90
7246:  MOVWF  FF6
7248:  MOVLW  4A
724A:  MOVWF  FF7
724C:  CLRF   19
724E:  BTFSC  FF2.7
7250:  BSF    19.7
7252:  BCF    FF2.7
7254:  MOVLB  0
7256:  CALL   07A0
725A:  BTFSC  19.7
725C:  BSF    FF2.7
....................    #endif 
....................    memset(reply_buffer,0,sizeof(reply_buffer));  
725E:  MOVLW  03
7260:  MOVWF  FEA
7262:  MOVLW  48
7264:  MOVWF  FE9
7266:  CLRF   00
7268:  MOVLW  01
726A:  MOVWF  02
726C:  MOVLW  18
726E:  MOVWF  01
7270:  CALL   446E
....................    memset(msg_data_sending,0,sizeof(msg_data_sending));  
7274:  MOVLW  01
7276:  MOVWF  FEA
7278:  MOVLW  B8
727A:  MOVWF  FE9
727C:  CLRF   00
727E:  MOVLW  01
7280:  MOVWF  02
7282:  MOVLW  18
7284:  MOVWF  01
7286:  CALL   446E
....................     
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     
....................    while(1) 
....................    { 
....................      #if defined(SIM900) 
....................       count_polling++; 
728A:  MOVLB  4
728C:  INCF   x93,F
728E:  BTFSC  FD8.2
7290:  INCF   x94,F
....................       if(count_polling>=timing_wait) 
7292:  MOVF   x98,W
7294:  SUBWF  x94,W
7296:  BTFSS  FD8.0
7298:  GOTO   9914
729C:  BNZ   72A8
729E:  MOVF   x97,W
72A0:  SUBWF  x93,W
72A2:  BTFSS  FD8.0
72A4:  GOTO   9914
....................       { 
....................          count_polling=0; 
72A8:  CLRF   x94
72AA:  CLRF   x93
....................          //fprintf(COM2,"SIM_state %d\n\r",SIM_state); 
....................          switch(SIM_state) 
....................          { 
72AC:  MOVF   x95,W
72AE:  ADDLW  EB
72B0:  BTFSC  FD8.0
72B2:  GOTO   9914
72B6:  ADDLW  15
72B8:  MOVLB  0
72BA:  GOTO   993E
....................             case config_sms: 
....................                receiver_state=1; 
72BE:  MOVLW  01
72C0:  MOVLB  1
72C2:  MOVWF  xB4
....................                //fprintf(COM2,"AT+CMGF=1...\n\r"); 
....................                fprintf(COM1,"AT+CMGF=1\r\n"); 
72C4:  MOVLW  A8
72C6:  MOVWF  FF6
72C8:  MOVLW  4A
72CA:  MOVWF  FF7
72CC:  MOVLB  0
72CE:  CALL   53D0
....................                SIM_state=reading_sms_cmd; 
72D2:  MOVLW  01
72D4:  MOVLB  4
72D6:  MOVWF  x95
....................                timing_wait=1000; 
72D8:  MOVLW  03
72DA:  MOVWF  x98
72DC:  MOVLW  E8
72DE:  MOVWF  x97
....................             break; 
72E0:  GOTO   9914
....................             case reading_sms_cmd:     
....................                booting_done=1; 
72E4:  MOVLW  01
72E6:  MOVLB  1
72E8:  MOVWF  xB5
72EA:  CLRF   19
72EC:  BTFSC  FF2.7
72EE:  BSF    19.7
72F0:  BCF    FF2.7
....................                cards=get_countcard(); 
72F2:  MOVLB  0
72F4:  CALL   39F0
72F8:  BTFSC  19.7
72FA:  BSF    FF2.7
72FC:  MOVFF  02,9CB
7300:  MOVFF  01,9CA
....................                receiver_state=1; 
7304:  MOVLW  01
7306:  MOVLB  1
7308:  MOVWF  xB4
....................                memset(buffer_uart,0,sizeof(buffer_uart));  
730A:  MOVWF  FEA
730C:  MOVLW  4E
730E:  MOVWF  FE9
7310:  CLRF   00
7312:  CLRF   02
7314:  MOVLW  64
7316:  MOVWF  01
7318:  MOVLB  0
731A:  CALL   446E
....................                memset(mobilenumb,0,sizeof(mobilenumb));  
731E:  MOVLW  04
7320:  MOVWF  FEA
7322:  MOVLW  79
7324:  MOVWF  FE9
7326:  CLRF   00
7328:  CLRF   02
732A:  MOVLW  1A
732C:  MOVWF  01
732E:  CALL   446E
....................                memset(msg_buffer2,0,sizeof(msg_buffer2));                               
7332:  MOVLW  03
7334:  MOVWF  FEA
7336:  MOVLW  16
7338:  MOVWF  FE9
733A:  CLRF   00
733C:  CLRF   02
733E:  MOVLW  32
7340:  MOVWF  01
7342:  CALL   446E
....................                fprintf(COM2,"reading_sms...\n\r"); 
7346:  MOVLW  B4
7348:  MOVWF  FF6
734A:  MOVLW  4A
734C:  MOVWF  FF7
734E:  CLRF   19
7350:  BTFSC  FF2.7
7352:  BSF    19.7
7354:  BCF    FF2.7
7356:  CALL   07A0
735A:  BTFSC  19.7
735C:  BSF    FF2.7
....................                #ASM BCF    0xF94.7 #ENDASM                   
735E:  BCF    F94.7
....................                   fprintf(COM1,"AT+CMGR=1\r\n"); 
7360:  MOVLW  C6
7362:  MOVWF  FF6
7364:  MOVLW  4A
7366:  MOVWF  FF7
7368:  CALL   53D0
....................                #ASM BSF    0xF94.7 #ENDASM 
736C:  BSF    F94.7
....................                //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................                SIM_state=MSG_avai; 
736E:  MOVLW  02
7370:  MOVLB  4
7372:  MOVWF  x95
....................                UART_index=0; 
7374:  MOVLB  1
7376:  CLRF   xB2
....................                timing_wait=5000; 
7378:  MOVLW  13
737A:  MOVLB  4
737C:  MOVWF  x98
737E:  MOVLW  88
7380:  MOVWF  x97
....................                //fprintf(COM2,"device has %lu charactions\n\r",cards); 
....................             break; 
7382:  GOTO   9914
....................             case MSG_avai: 
....................                //fprintf(COM2,"MSG_avai...\n\r"); 
....................                //temp=checking_msg_avai(); 
....................                fprintf(COM2,"MSG_avai...%d\n\r",temp); 
7386:  MOVLW  D2
7388:  MOVWF  FF6
738A:  MOVLW  4A
738C:  MOVWF  FF7
738E:  CLRF   19
7390:  BTFSC  FF2.7
7392:  BSF    19.7
7394:  BCF    FF2.7
7396:  MOVLW  0B
7398:  MOVLB  A
739A:  MOVWF  xD3
739C:  MOVLB  0
739E:  CALL   1718
73A2:  BTFSC  19.7
73A4:  BSF    FF2.7
73A6:  CLRF   19
73A8:  BTFSC  FF2.7
73AA:  BSF    19.7
73AC:  BCF    FF2.7
73AE:  MOVFF  9D3,ABF
73B2:  MOVLW  18
73B4:  MOVLB  A
73B6:  MOVWF  xC0
73B8:  MOVLB  0
73BA:  CALL   182C
73BE:  BTFSC  19.7
73C0:  BSF    FF2.7
73C2:  CLRF   19
73C4:  BTFSC  FF2.7
73C6:  BSF    19.7
73C8:  BCF    FF2.7
73CA:  MOVLW  0A
73CC:  MOVLB  A
73CE:  MOVWF  xDF
73D0:  MOVLB  0
73D2:  CALL   075A
73D6:  BTFSC  19.7
73D8:  BSF    FF2.7
73DA:  CLRF   19
73DC:  BTFSC  FF2.7
73DE:  BSF    19.7
73E0:  BCF    FF2.7
73E2:  MOVLW  0D
73E4:  MOVLB  A
73E6:  MOVWF  xDF
73E8:  MOVLB  0
73EA:  CALL   075A
73EE:  BTFSC  19.7
73F0:  BSF    FF2.7
....................                //if(temp==1) SIM_state=reading_sms_cmd; 
....................                /*for(i=0;i<100;i++) 
....................                { 
....................                   fprintf(COM2,"%c",buffer_uart[i]);  
....................                }*/ 
....................                SIM_state=analyze_sms;  
73F2:  MOVLW  03
73F4:  MOVLB  4
73F6:  MOVWF  x95
....................                //fprintf(COM2,"\r\ntemp=%d\r\n",temp); 
....................                //timing_wait=2000; 
....................             break; 
73F8:  GOTO   9914
....................             case analyze_sms: 
....................                booting_done=0; 
73FC:  MOVLB  1
73FE:  CLRF   xB5
....................                fprintf(COM2,"analyze_sms...\n\r");  
7400:  MOVLW  E2
7402:  MOVWF  FF6
7404:  MOVLW  4A
7406:  MOVWF  FF7
7408:  CLRF   19
740A:  BTFSC  FF2.7
740C:  BSF    19.7
740E:  BCF    FF2.7
7410:  MOVLB  0
7412:  CALL   07A0
7416:  BTFSC  19.7
7418:  BSF    FF2.7
741A:  CLRF   19
741C:  BTFSC  FF2.7
741E:  BSF    19.7
7420:  BCF    FF2.7
....................                del_buf(20,msg_buffer1); 
7422:  MOVLW  14
7424:  MOVLB  A
7426:  MOVWF  xC5
7428:  MOVLW  03
742A:  MOVWF  xC7
742C:  MOVLW  02
742E:  MOVWF  xC6
7430:  MOVLB  0
7432:  CALL   3A62
7436:  BTFSC  19.7
7438:  BSF    FF2.7
743A:  CLRF   19
743C:  BTFSC  FF2.7
743E:  BSF    19.7
7440:  BCF    FF2.7
....................                del_buf(50,msg_buffer2); 
7442:  MOVLW  32
7444:  MOVLB  A
7446:  MOVWF  xC5
7448:  MOVLW  03
744A:  MOVWF  xC7
744C:  MOVLW  16
744E:  MOVWF  xC6
7450:  MOVLB  0
7452:  CALL   3A62
7456:  BTFSC  19.7
7458:  BSF    FF2.7
745A:  CLRF   19
745C:  BTFSC  FF2.7
745E:  BSF    19.7
7460:  BCF    FF2.7
....................                del_buf(50,sim_bug); 
7462:  MOVLW  32
7464:  MOVLB  A
7466:  MOVWF  xC5
7468:  MOVLW  02
746A:  MOVWF  xC7
746C:  MOVLW  D0
746E:  MOVWF  xC6
7470:  MOVLB  0
7472:  CALL   3A62
7476:  BTFSC  19.7
7478:  BSF    FF2.7
....................                //memset(msg_buffer1,0,sizeof(msg_buffer1)); 
....................                //memset(msg_buffer2,0,sizeof(msg_buffer2)); 
....................                //memset(sim_bug,0,sizeof(sim_bug)); 
....................                analyzing_msg(sim_bug,mobilenumb); 
747A:  MOVLW  02
747C:  MOVLB  A
747E:  MOVWF  x8F
7480:  MOVLW  D0
7482:  MOVWF  x8E
7484:  MOVLW  04
7486:  MOVWF  x91
7488:  MOVLW  79
748A:  MOVWF  x90
748C:  MOVLB  0
748E:  GOTO   53F2
....................                /*for(i=0;i<25;i++) 
....................                { 
....................                   fprintf(COM2,"%d",sim_bug[i]); 
....................                }*/ 
....................                 
....................                memset(buffer_uart,0,sizeof(buffer_uart));  
7492:  MOVLW  01
7494:  MOVWF  FEA
7496:  MOVLW  4E
7498:  MOVWF  FE9
749A:  CLRF   00
749C:  CLRF   02
749E:  MOVLW  64
74A0:  MOVWF  01
74A2:  CALL   446E
....................                #if defined(twonumber)  
....................                   SIM_state=checking_MN0; 
74A6:  MOVLW  12
74A8:  MOVLB  4
74AA:  MOVWF  x95
....................                   #else SIM_state=checking_MN; 
....................                #endif     
....................                if((mobilenumb[0]==0)&&(mobilenumb[1]==0)&&(mobilenumb[2]==0)&&(mobilenumb[3]==0)&&(mobilenumb[4]==0)) 
74AC:  MOVF   x79,F
74AE:  BNZ   74E6
74B0:  MOVF   x7A,F
74B2:  BNZ   74E6
74B4:  MOVF   x7B,F
74B6:  BNZ   74E6
74B8:  MOVF   x7C,F
74BA:  BNZ   74E6
74BC:  MOVF   x7D,F
74BE:  BNZ   74E6
....................                { 
....................                   SIM_state= delete_MSG; 
74C0:  MOVLW  06
74C2:  MOVWF  x95
....................                   //SIM_state=config_sms; 
....................                   output_low(rst_sim); 
74C4:  BCF    F94.1
74C6:  BCF    F8B.1
....................                   fprintf(COM2,"the signal is not good, device will reboot\n\r"); 
74C8:  MOVLW  F4
74CA:  MOVWF  FF6
74CC:  MOVLW  4A
74CE:  MOVWF  FF7
74D0:  CLRF   19
74D2:  BTFSC  FF2.7
74D4:  BSF    19.7
74D6:  BCF    FF2.7
74D8:  MOVLB  0
74DA:  CALL   07A0
74DE:  BTFSC  19.7
74E0:  BSF    FF2.7
....................                   setup_wdt(WDT_ON); 
74E2:  BSF    FC0.0
74E4:  MOVLB  4
....................                } 
....................                timing_wait=1500; 
74E6:  MOVLW  05
74E8:  MOVWF  x98
74EA:  MOVLW  DC
74EC:  MOVWF  x97
....................                count_char=0; 
74EE:  MOVLB  9
74F0:  CLRF   xD4
....................             break; 
74F2:  MOVLB  4
74F4:  GOTO   9914
....................             #if defined(twonumber)  
....................             case checking_MN0: 
....................                fprintf(COM2,"\n\rchecking the first number\n\r"); 
74F8:  MOVLW  22
74FA:  MOVWF  FF6
74FC:  MOVLW  4B
74FE:  MOVWF  FF7
7500:  CLRF   19
7502:  BTFSC  FF2.7
7504:  BSF    19.7
7506:  BCF    FF2.7
7508:  CALL   07A0
750C:  BTFSC  19.7
750E:  BSF    FF2.7
....................                fprintf(COM2,"\n\rMobile phone number is "); 
7510:  MOVLW  40
7512:  MOVWF  FF6
7514:  MOVLW  4B
7516:  MOVWF  FF7
7518:  CLRF   19
751A:  BTFSC  FF2.7
751C:  BSF    19.7
751E:  BCF    FF2.7
7520:  CALL   07A0
7524:  BTFSC  19.7
7526:  BSF    FF2.7
....................                for(i=0;i<20;i++) fprintf(COM2,"%c",mobilenumb[i]);  
7528:  MOVLB  9
752A:  CLRF   xD2
752C:  MOVF   xD2,W
752E:  SUBLW  13
7530:  BNC   7560
7532:  CLRF   03
7534:  MOVF   xD2,W
7536:  ADDLW  79
7538:  MOVWF  FE9
753A:  MOVLW  04
753C:  ADDWFC 03,W
753E:  MOVWF  FEA
7540:  MOVFF  FEF,A8E
7544:  CLRF   19
7546:  BTFSC  FF2.7
7548:  BSF    19.7
754A:  BCF    FF2.7
754C:  MOVFF  A8E,ADF
7550:  MOVLB  0
7552:  CALL   075A
7556:  BTFSC  19.7
7558:  BSF    FF2.7
755A:  MOVLB  9
755C:  INCF   xD2,F
755E:  BRA    752C
....................                fprintf(COM2,"\n\rMSG: "); 
7560:  MOVLW  5A
7562:  MOVWF  FF6
7564:  MOVLW  4B
7566:  MOVWF  FF7
7568:  CLRF   19
756A:  BTFSC  FF2.7
756C:  BSF    19.7
756E:  BCF    FF2.7
7570:  MOVLB  0
7572:  CALL   07A0
7576:  BTFSC  19.7
7578:  BSF    FF2.7
....................                for(i=0;i<50;i++) fprintf(COM2,"%c",sim_bug[i]); 
757A:  MOVLB  9
757C:  CLRF   xD2
757E:  MOVF   xD2,W
7580:  SUBLW  31
7582:  BNC   75B2
7584:  CLRF   03
7586:  MOVF   xD2,W
7588:  ADDLW  D0
758A:  MOVWF  FE9
758C:  MOVLW  02
758E:  ADDWFC 03,W
7590:  MOVWF  FEA
7592:  MOVFF  FEF,A8E
7596:  CLRF   19
7598:  BTFSC  FF2.7
759A:  BSF    19.7
759C:  BCF    FF2.7
759E:  MOVFF  A8E,ADF
75A2:  MOVLB  0
75A4:  CALL   075A
75A8:  BTFSC  19.7
75AA:  BSF    FF2.7
75AC:  MOVLB  9
75AE:  INCF   xD2,F
75B0:  BRA    757E
....................                fprintf(COM2,"\n\rTIME: "); 
75B2:  MOVLW  62
75B4:  MOVWF  FF6
75B6:  MOVLW  4B
75B8:  MOVWF  FF7
75BA:  CLRF   19
75BC:  BTFSC  FF2.7
75BE:  BSF    19.7
75C0:  BCF    FF2.7
75C2:  MOVLB  0
75C4:  CALL   07A0
75C8:  BTFSC  19.7
75CA:  BSF    FF2.7
....................                for(i=0;i<25;i++) 
75CC:  MOVLB  9
75CE:  CLRF   xD2
75D0:  MOVF   xD2,W
75D2:  SUBLW  18
75D4:  BNC   761A
....................                { 
....................                   if(datetime[i]=='"')break; 
75D6:  CLRF   03
75D8:  MOVF   xD2,W
75DA:  ADDLW  60
75DC:  MOVWF  FE9
75DE:  MOVLW  04
75E0:  ADDWFC 03,W
75E2:  MOVWF  FEA
75E4:  MOVF   FEF,W
75E6:  SUBLW  22
75E8:  BNZ   75EC
75EA:  BRA    761A
....................                   fprintf(COM2,"%c",datetime[i]); 
75EC:  CLRF   03
75EE:  MOVF   xD2,W
75F0:  ADDLW  60
75F2:  MOVWF  FE9
75F4:  MOVLW  04
75F6:  ADDWFC 03,W
75F8:  MOVWF  FEA
75FA:  MOVFF  FEF,A8E
75FE:  CLRF   19
7600:  BTFSC  FF2.7
7602:  BSF    19.7
7604:  BCF    FF2.7
7606:  MOVFF  A8E,ADF
760A:  MOVLB  0
760C:  CALL   075A
7610:  BTFSC  19.7
7612:  BSF    FF2.7
....................                } 
7614:  MOVLB  9
7616:  INCF   xD2,F
7618:  BRA    75D0
....................                EEPROM_read(strobe_mobile_num0,20,msg_buffer1);  
761A:  MOVLW  41
761C:  MOVLB  A
761E:  MOVWF  x8E
7620:  MOVLW  14
7622:  MOVWF  x8F
7624:  MOVLW  03
7626:  MOVWF  x91
7628:  MOVLW  02
762A:  MOVWF  x90
762C:  MOVLB  0
762E:  CALL   5062
....................                strcpy(msg_buffer2,"redoo"); 
7632:  MOVLW  03
7634:  MOVWF  FEA
7636:  MOVLW  16
7638:  MOVWF  FE9
763A:  MOVLW  00
763C:  CALL   01AE
7640:  TBLRD*-
7642:  TBLRD*+
7644:  MOVF   FF5,W
7646:  MOVWF  FEE
7648:  IORLW  00
764A:  BNZ   7642
....................                if(!strncmp(msg_buffer2,sim_bug,5))  
764C:  MOVLW  03
764E:  MOVLB  A
7650:  MOVWF  x8F
7652:  MOVLW  16
7654:  MOVWF  x8E
7656:  MOVLW  02
7658:  MOVWF  x91
765A:  MOVLW  D0
765C:  MOVWF  x90
765E:  CLRF   x93
7660:  MOVLW  05
7662:  MOVWF  x92
7664:  MOVLB  0
7666:  CALL   5696
766A:  MOVF   01,F
766C:  BNZ   76CE
....................                { 
....................                  fprintf(COM2,"\n\rreset the password\n\r"); 
766E:  MOVLW  6C
7670:  MOVWF  FF6
7672:  MOVLW  4B
7674:  MOVWF  FF7
7676:  CLRF   19
7678:  BTFSC  FF2.7
767A:  BSF    19.7
767C:  BCF    FF2.7
767E:  CALL   07A0
7682:  BTFSC  19.7
7684:  BSF    FF2.7
....................                  reset_password(); 
7686:  GOTO   572C
....................                  init_password(); 
768A:  CALL   510E
....................                  reset_2nd_number(); 
768E:  GOTO   5760
....................                  strcpy(reply_buffer,"done"); 
7692:  MOVLW  03
7694:  MOVWF  FEA
7696:  MOVLW  48
7698:  MOVWF  FE9
769A:  MOVLW  00
769C:  CALL   0134
76A0:  TBLRD*-
76A2:  TBLRD*+
76A4:  MOVF   FF5,W
76A6:  MOVWF  FEE
76A8:  IORLW  00
76AA:  BNZ   76A2
....................                  fprintf(COM2,"done\n\r"); 
76AC:  MOVLW  84
76AE:  MOVWF  FF6
76B0:  MOVLW  4B
76B2:  MOVWF  FF7
76B4:  CLRF   19
76B6:  BTFSC  FF2.7
76B8:  BSF    19.7
76BA:  BCF    FF2.7
76BC:  CALL   07A0
76C0:  BTFSC  19.7
76C2:  BSF    FF2.7
....................                  SIM_state=SIM_reply;  
76C4:  MOVLW  0E
76C6:  MOVLB  4
76C8:  MOVWF  x95
....................                  break; 
76CA:  GOTO   9914
....................                } 
....................                if(!stringcomp(mobilenumb,msg_buffer1))   
76CE:  MOVLW  04
76D0:  MOVLB  A
76D2:  MOVWF  x8F
76D4:  MOVLW  79
76D6:  MOVWF  x8E
76D8:  MOVLW  03
76DA:  MOVWF  x91
76DC:  MOVLW  02
76DE:  MOVWF  x90
76E0:  MOVLB  0
76E2:  CALL   5796
76E6:  MOVF   01,F
76E8:  BNZ   7710
....................                { 
....................                   fprintf(COM2,"\n\rchecking phone number is done\n\r");  
76EA:  MOVLW  8C
76EC:  MOVWF  FF6
76EE:  MOVLW  4B
76F0:  MOVWF  FF7
76F2:  CLRF   19
76F4:  BTFSC  FF2.7
76F6:  BSF    19.7
76F8:  BCF    FF2.7
76FA:  CALL   07A0
76FE:  BTFSC  19.7
7700:  BSF    FF2.7
....................                   updatetime2ds1307(); 
7702:  CALL   59E0
....................                   SIM_state=doing_sms; 
7706:  MOVLW  05
7708:  MOVLB  4
770A:  MOVWF  x95
....................                } 
....................                else 
770C:  BRA    7960
770E:  MOVLB  0
....................                { 
....................                  SIM_state=checking_MN; 
7710:  MOVLW  04
7712:  MOVLB  4
7714:  MOVWF  x95
....................                  strcpy(msg_buffer2,"goodbye"); 
7716:  MOVLW  03
7718:  MOVWF  FEA
771A:  MOVLW  16
771C:  MOVWF  FE9
771E:  MOVLW  00
7720:  MOVLB  0
7722:  CALL   01C4
7726:  TBLRD*-
7728:  TBLRD*+
772A:  MOVF   FF5,W
772C:  MOVWF  FEE
772E:  IORLW  00
7730:  BNZ   7728
....................                  if(!strncmp(msg_buffer2,sim_bug,7))  
7732:  MOVLW  03
7734:  MOVLB  A
7736:  MOVWF  x8F
7738:  MOVLW  16
773A:  MOVWF  x8E
773C:  MOVLW  02
773E:  MOVWF  x91
7740:  MOVLW  D0
7742:  MOVWF  x90
7744:  CLRF   x93
7746:  MOVLW  07
7748:  MOVWF  x92
774A:  MOVLB  0
774C:  CALL   5696
7750:  MOVF   01,F
7752:  BTFSS  FD8.2
7754:  BRA    7962
....................                  { 
....................                    SIM_state=delete_MSG;   
7756:  MOVLW  06
7758:  MOVLB  4
775A:  MOVWF  x95
....................                    for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+8];                 
775C:  MOVLB  9
775E:  CLRF   xD2
7760:  MOVF   xD2,W
7762:  SUBLW  13
7764:  BNC   77A0
7766:  CLRF   03
7768:  MOVF   xD2,W
776A:  ADDLW  16
776C:  MOVWF  01
776E:  MOVLW  03
7770:  ADDWFC 03,F
7772:  MOVFF  03,A8F
7776:  MOVLW  08
7778:  MOVLB  9
777A:  ADDWF  xD2,W
777C:  CLRF   03
777E:  ADDLW  D0
7780:  MOVWF  FE9
7782:  MOVLW  02
7784:  ADDWFC 03,W
7786:  MOVWF  FEA
7788:  MOVFF  FEF,A90
778C:  MOVLB  A
778E:  MOVFF  A8F,FEA
7792:  MOVFF  01,FE9
7796:  MOVFF  A90,FEF
779A:  MOVLB  9
779C:  INCF   xD2,F
779E:  BRA    7760
....................                    fprintf(COM2,"\n\rconfigured mobile phone number\n\r");  
77A0:  MOVLW  AE
77A2:  MOVWF  FF6
77A4:  MOVLW  4B
77A6:  MOVWF  FF7
77A8:  CLRF   19
77AA:  BTFSC  FF2.7
77AC:  BSF    19.7
77AE:  BCF    FF2.7
77B0:  MOVLB  0
77B2:  CALL   07A0
77B6:  BTFSC  19.7
77B8:  BSF    FF2.7
....................                    for(i=0;i<20;i++)fprintf(COM2,"%c",msg_buffer2[i]);  
77BA:  MOVLB  9
77BC:  CLRF   xD2
77BE:  MOVF   xD2,W
77C0:  SUBLW  13
77C2:  BNC   77F2
77C4:  CLRF   03
77C6:  MOVF   xD2,W
77C8:  ADDLW  16
77CA:  MOVWF  FE9
77CC:  MOVLW  03
77CE:  ADDWFC 03,W
77D0:  MOVWF  FEA
77D2:  MOVFF  FEF,A8E
77D6:  CLRF   19
77D8:  BTFSC  FF2.7
77DA:  BSF    19.7
77DC:  BCF    FF2.7
77DE:  MOVFF  A8E,ADF
77E2:  MOVLB  0
77E4:  CALL   075A
77E8:  BTFSC  19.7
77EA:  BSF    FF2.7
77EC:  MOVLB  9
77EE:  INCF   xD2,F
77F0:  BRA    77BE
77F2:  CLRF   19
77F4:  BTFSC  FF2.7
77F6:  BSF    19.7
77F8:  BCF    FF2.7
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",msg_buffer2[i]); 
....................                    fprintf(COM2,"\n\r");  
77FA:  MOVLW  0A
77FC:  MOVLB  A
77FE:  MOVWF  xDF
7800:  MOVLB  0
7802:  CALL   075A
7806:  BTFSC  19.7
7808:  BSF    FF2.7
780A:  CLRF   19
780C:  BTFSC  FF2.7
780E:  BSF    19.7
7810:  BCF    FF2.7
7812:  MOVLW  0D
7814:  MOVLB  A
7816:  MOVWF  xDF
7818:  MOVLB  0
781A:  CALL   075A
781E:  BTFSC  19.7
7820:  BSF    FF2.7
....................                    EEPROM_read(strobe_pass_addr,20,password); 
7822:  MOVLB  A
7824:  CLRF   x8E
7826:  MOVLW  14
7828:  MOVWF  x8F
782A:  CLRF   x91
782C:  MOVLW  55
782E:  MOVWF  x90
7830:  MOVLB  0
7832:  CALL   5062
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%c",password[i]); 
....................                    for(i=0;i<20;i++) 
7836:  MOVLB  9
7838:  CLRF   xD2
783A:  MOVF   xD2,W
783C:  SUBLW  13
783E:  BNC   785C
....................                    { 
....................                      if(password[i]==0)break; 
7840:  CLRF   03
7842:  MOVF   xD2,W
7844:  ADDLW  55
7846:  MOVWF  FE9
7848:  MOVLW  00
784A:  ADDWFC 03,W
784C:  MOVWF  FEA
784E:  MOVF   FEF,F
7850:  BNZ   7856
7852:  BRA    785C
....................                            else count_char++; 
7854:  BRA    7858
7856:  INCF   xD4,F
....................                    } 
7858:  INCF   xD2,F
785A:  BRA    783A
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",password[i]); 
....................                    //fprintf(COM2,"count_char=%d\n\r",count_char);  
....................                    //fprintf(COM2,"\n\r"); 
....................                    if(!strncmp(password,msg_buffer2,count_char))  
785C:  MOVLB  A
785E:  CLRF   x8F
7860:  MOVLW  55
7862:  MOVWF  x8E
7864:  MOVLW  03
7866:  MOVWF  x91
7868:  MOVLW  16
786A:  MOVWF  x90
786C:  CLRF   x93
786E:  MOVFF  9D4,A92
7872:  MOVLB  0
7874:  CALL   5696
7878:  MOVF   01,F
787A:  BNZ   7928
....................                    { 
....................                       EEPROM_write(strobe_mobile_num0,20,mobilenumb); 
787C:  MOVLW  41
787E:  MOVLB  A
7880:  MOVWF  xA3
7882:  MOVLW  14
7884:  MOVWF  xA4
7886:  MOVLW  04
7888:  MOVWF  xA6
788A:  MOVLW  79
788C:  MOVWF  xA5
788E:  MOVLB  0
7890:  CALL   50BC
....................                       fprintf(COM2,"changed phone number\n\r("); 
7894:  MOVLW  D2
7896:  MOVWF  FF6
7898:  MOVLW  4B
789A:  MOVWF  FF7
789C:  CLRF   19
789E:  BTFSC  FF2.7
78A0:  BSF    19.7
78A2:  BCF    FF2.7
78A4:  CALL   07A0
78A8:  BTFSC  19.7
78AA:  BSF    FF2.7
....................                       for(i=0;i<20;i++)fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num0+i));  
78AC:  MOVLB  9
78AE:  CLRF   xD2
78B0:  MOVF   xD2,W
78B2:  SUBLW  13
78B4:  BNC   78F2
78B6:  MOVLW  41
78B8:  ADDWF  xD2,W
78BA:  MOVLB  A
78BC:  MOVWF  x8E
78BE:  CLRF   19
78C0:  BTFSC  FF2.7
78C2:  BSF    19.7
78C4:  BCF    FF2.7
78C6:  CLRF   xC0
78C8:  MOVWF  xBF
78CA:  MOVLB  0
78CC:  CALL   3948
78D0:  BTFSC  19.7
78D2:  BSF    FF2.7
78D4:  MOVFF  01,A8E
78D8:  CLRF   19
78DA:  BTFSC  FF2.7
78DC:  BSF    19.7
78DE:  BCF    FF2.7
78E0:  MOVFF  01,ADF
78E4:  CALL   075A
78E8:  BTFSC  19.7
78EA:  BSF    FF2.7
78EC:  MOVLB  9
78EE:  INCF   xD2,F
78F0:  BRA    78B0
....................                       strcpy(reply_buffer,"done"); 
78F2:  MOVLW  03
78F4:  MOVWF  FEA
78F6:  MOVLW  48
78F8:  MOVWF  FE9
78FA:  MOVLW  00
78FC:  MOVLB  0
78FE:  CALL   0134
7902:  TBLRD*-
7904:  TBLRD*+
7906:  MOVF   FF5,W
7908:  MOVWF  FEE
790A:  IORLW  00
790C:  BNZ   7904
....................                       fprintf(COM2,")\n\r"); 
790E:  MOVLW  EA
7910:  MOVWF  FF6
7912:  MOVLW  4B
7914:  MOVWF  FF7
7916:  CLRF   19
7918:  BTFSC  FF2.7
791A:  BSF    19.7
791C:  BCF    FF2.7
791E:  CALL   07A0
7922:  BTFSC  19.7
7924:  BSF    FF2.7
....................                    } 
....................                      else 
7926:  BRA    795A
....................                      { 
....................                         fprintf(COM2,"wrong password\n\r"); 
7928:  MOVLW  EE
792A:  MOVWF  FF6
792C:  MOVLW  4B
792E:  MOVWF  FF7
7930:  CLRF   19
7932:  BTFSC  FF2.7
7934:  BSF    19.7
7936:  BCF    FF2.7
7938:  CALL   07A0
793C:  BTFSC  19.7
793E:  BSF    FF2.7
....................                         strcpy(reply_buffer,"wrong password"); 
7940:  MOVLW  03
7942:  MOVWF  FEA
7944:  MOVLW  48
7946:  MOVWF  FE9
7948:  MOVLW  00
794A:  CALL   01DC
794E:  TBLRD*-
7950:  TBLRD*+
7952:  MOVF   FF5,W
7954:  MOVWF  FEE
7956:  IORLW  00
7958:  BNZ   7950
....................                      }                      
....................                    SIM_state=SIM_reply;   
795A:  MOVLW  0E
795C:  MOVLB  4
795E:  MOVWF  x95
7960:  MOVLB  0
....................                  } 
....................  
....................                } 
....................             break; 
7962:  MOVLB  4
7964:  GOTO   9914
....................             #endif  
....................             case checking_MN: 
....................                #if defined(twonumber)  
....................                   fprintf(COM2,"\n\rchecking the second number\n\r"); 
7968:  MOVLW  00
796A:  MOVWF  FF6
796C:  MOVLW  4C
796E:  MOVWF  FF7
7970:  CLRF   19
7972:  BTFSC  FF2.7
7974:  BSF    19.7
7976:  BCF    FF2.7
7978:  CALL   07A0
797C:  BTFSC  19.7
797E:  BSF    FF2.7
....................                #endif 
....................                fprintf(COM2,"\n\rMobile phone number is "); 
7980:  MOVLW  20
7982:  MOVWF  FF6
7984:  MOVLW  4C
7986:  MOVWF  FF7
7988:  CLRF   19
798A:  BTFSC  FF2.7
798C:  BSF    19.7
798E:  BCF    FF2.7
7990:  CALL   07A0
7994:  BTFSC  19.7
7996:  BSF    FF2.7
....................                for(i=0;i<20;i++) fprintf(COM2,"%c",mobilenumb[i]);   
7998:  MOVLB  9
799A:  CLRF   xD2
799C:  MOVF   xD2,W
799E:  SUBLW  13
79A0:  BNC   79D0
79A2:  CLRF   03
79A4:  MOVF   xD2,W
79A6:  ADDLW  79
79A8:  MOVWF  FE9
79AA:  MOVLW  04
79AC:  ADDWFC 03,W
79AE:  MOVWF  FEA
79B0:  MOVFF  FEF,A8E
79B4:  CLRF   19
79B6:  BTFSC  FF2.7
79B8:  BSF    19.7
79BA:  BCF    FF2.7
79BC:  MOVFF  A8E,ADF
79C0:  MOVLB  0
79C2:  CALL   075A
79C6:  BTFSC  19.7
79C8:  BSF    FF2.7
79CA:  MOVLB  9
79CC:  INCF   xD2,F
79CE:  BRA    799C
....................                fprintf(COM2,"\n\rMSG: "); 
79D0:  MOVLW  3A
79D2:  MOVWF  FF6
79D4:  MOVLW  4C
79D6:  MOVWF  FF7
79D8:  CLRF   19
79DA:  BTFSC  FF2.7
79DC:  BSF    19.7
79DE:  BCF    FF2.7
79E0:  MOVLB  0
79E2:  CALL   07A0
79E6:  BTFSC  19.7
79E8:  BSF    FF2.7
....................                for(i=0;i<50;i++) fprintf(COM2,"%c",sim_bug[i]); 
79EA:  MOVLB  9
79EC:  CLRF   xD2
79EE:  MOVF   xD2,W
79F0:  SUBLW  31
79F2:  BNC   7A22
79F4:  CLRF   03
79F6:  MOVF   xD2,W
79F8:  ADDLW  D0
79FA:  MOVWF  FE9
79FC:  MOVLW  02
79FE:  ADDWFC 03,W
7A00:  MOVWF  FEA
7A02:  MOVFF  FEF,A8E
7A06:  CLRF   19
7A08:  BTFSC  FF2.7
7A0A:  BSF    19.7
7A0C:  BCF    FF2.7
7A0E:  MOVFF  A8E,ADF
7A12:  MOVLB  0
7A14:  CALL   075A
7A18:  BTFSC  19.7
7A1A:  BSF    FF2.7
7A1C:  MOVLB  9
7A1E:  INCF   xD2,F
7A20:  BRA    79EE
....................                fprintf(COM2,"\n\rTIME: "); 
7A22:  MOVLW  42
7A24:  MOVWF  FF6
7A26:  MOVLW  4C
7A28:  MOVWF  FF7
7A2A:  CLRF   19
7A2C:  BTFSC  FF2.7
7A2E:  BSF    19.7
7A30:  BCF    FF2.7
7A32:  MOVLB  0
7A34:  CALL   07A0
7A38:  BTFSC  19.7
7A3A:  BSF    FF2.7
....................                for(i=0;i<25;i++) 
7A3C:  MOVLB  9
7A3E:  CLRF   xD2
7A40:  MOVF   xD2,W
7A42:  SUBLW  18
7A44:  BNC   7A8A
....................                { 
....................                   if(datetime[i]=='"')break; 
7A46:  CLRF   03
7A48:  MOVF   xD2,W
7A4A:  ADDLW  60
7A4C:  MOVWF  FE9
7A4E:  MOVLW  04
7A50:  ADDWFC 03,W
7A52:  MOVWF  FEA
7A54:  MOVF   FEF,W
7A56:  SUBLW  22
7A58:  BNZ   7A5C
7A5A:  BRA    7A8A
....................                   fprintf(COM2,"%c",datetime[i]); 
7A5C:  CLRF   03
7A5E:  MOVF   xD2,W
7A60:  ADDLW  60
7A62:  MOVWF  FE9
7A64:  MOVLW  04
7A66:  ADDWFC 03,W
7A68:  MOVWF  FEA
7A6A:  MOVFF  FEF,A8E
7A6E:  CLRF   19
7A70:  BTFSC  FF2.7
7A72:  BSF    19.7
7A74:  BCF    FF2.7
7A76:  MOVFF  A8E,ADF
7A7A:  MOVLB  0
7A7C:  CALL   075A
7A80:  BTFSC  19.7
7A82:  BSF    FF2.7
....................                }               
7A84:  MOVLB  9
7A86:  INCF   xD2,F
7A88:  BRA    7A40
....................                EEPROM_read(strobe_mobile_num1,20,msg_buffer1);                 
7A8A:  MOVLW  55
7A8C:  MOVLB  A
7A8E:  MOVWF  x8E
7A90:  MOVLW  14
7A92:  MOVWF  x8F
7A94:  MOVLW  03
7A96:  MOVWF  x91
7A98:  MOVLW  02
7A9A:  MOVWF  x90
7A9C:  MOVLB  0
7A9E:  CALL   5062
....................               //strcpy(msg_buffer1,"+84903219082"); 
....................               //strcpy(msg_buffer1,"+16612891316");//+16612891316 
....................               #if defined(twonumber)  
....................               #else 
....................               strcpy(msg_buffer2,"redoo"); 
....................               if(!strncmp(msg_buffer2,sim_bug,5))  
....................               { 
....................                  fprintf(COM2,"\n\rreset the password\n\r"); 
....................                  reset_password(); 
....................                  init_password(); 
....................                  strcpy(reply_buffer,"done"); 
....................                  fprintf(COM2,"done\n\r"); 
....................                  SIM_state=SIM_reply;  
....................                  break; 
....................               } 
....................               #endif 
....................               if(!stringcomp(mobilenumb,msg_buffer1))   
7AA2:  MOVLW  04
7AA4:  MOVLB  A
7AA6:  MOVWF  x8F
7AA8:  MOVLW  79
7AAA:  MOVWF  x8E
7AAC:  MOVLW  03
7AAE:  MOVWF  x91
7AB0:  MOVLW  02
7AB2:  MOVWF  x90
7AB4:  MOVLB  0
7AB6:  CALL   5796
7ABA:  MOVF   01,F
7ABC:  BNZ   7AE4
....................               { 
....................                   fprintf(COM2,"\n\rchecking phone number is done\n\r");  
7ABE:  MOVLW  4C
7AC0:  MOVWF  FF6
7AC2:  MOVLW  4C
7AC4:  MOVWF  FF7
7AC6:  CLRF   19
7AC8:  BTFSC  FF2.7
7ACA:  BSF    19.7
7ACC:  BCF    FF2.7
7ACE:  CALL   07A0
7AD2:  BTFSC  19.7
7AD4:  BSF    FF2.7
....................                   updatetime2ds1307(); 
7AD6:  CALL   59E0
....................                   SIM_state=doing_sms; 
7ADA:  MOVLW  05
7ADC:  MOVLB  4
7ADE:  MOVWF  x95
....................               } 
....................                else 
7AE0:  BRA    7D52
7AE2:  MOVLB  0
....................                { 
....................                  SIM_state=delete_MSG; 
7AE4:  MOVLW  06
7AE6:  MOVLB  4
7AE8:  MOVWF  x95
....................                  strcpy(msg_buffer2,"hello"); 
7AEA:  MOVLW  03
7AEC:  MOVWF  FEA
7AEE:  MOVLW  16
7AF0:  MOVWF  FE9
7AF2:  MOVLW  00
7AF4:  MOVLB  0
7AF6:  CALL   01FC
7AFA:  TBLRD*-
7AFC:  TBLRD*+
7AFE:  MOVF   FF5,W
7B00:  MOVWF  FEE
7B02:  IORLW  00
7B04:  BNZ   7AFC
....................                  if(!strncmp(msg_buffer2,sim_bug,5))  
7B06:  MOVLW  03
7B08:  MOVLB  A
7B0A:  MOVWF  x8F
7B0C:  MOVLW  16
7B0E:  MOVWF  x8E
7B10:  MOVLW  02
7B12:  MOVWF  x91
7B14:  MOVLW  D0
7B16:  MOVWF  x90
7B18:  CLRF   x93
7B1A:  MOVLW  05
7B1C:  MOVWF  x92
7B1E:  MOVLB  0
7B20:  CALL   5696
7B24:  MOVF   01,F
7B26:  BTFSS  FD8.2
7B28:  BRA    7D38
....................                  { 
....................                    SIM_state=delete_MSG;   
7B2A:  MOVLW  06
7B2C:  MOVLB  4
7B2E:  MOVWF  x95
....................                    for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+6];                 
7B30:  MOVLB  9
7B32:  CLRF   xD2
7B34:  MOVF   xD2,W
7B36:  SUBLW  13
7B38:  BNC   7B74
7B3A:  CLRF   03
7B3C:  MOVF   xD2,W
7B3E:  ADDLW  16
7B40:  MOVWF  01
7B42:  MOVLW  03
7B44:  ADDWFC 03,F
7B46:  MOVFF  03,A8F
7B4A:  MOVLW  06
7B4C:  MOVLB  9
7B4E:  ADDWF  xD2,W
7B50:  CLRF   03
7B52:  ADDLW  D0
7B54:  MOVWF  FE9
7B56:  MOVLW  02
7B58:  ADDWFC 03,W
7B5A:  MOVWF  FEA
7B5C:  MOVFF  FEF,A90
7B60:  MOVLB  A
7B62:  MOVFF  A8F,FEA
7B66:  MOVFF  01,FE9
7B6A:  MOVFF  A90,FEF
7B6E:  MOVLB  9
7B70:  INCF   xD2,F
7B72:  BRA    7B34
....................                    fprintf(COM2,"\n\rconfigured mobile phone number\n\r");  
7B74:  MOVLW  6E
7B76:  MOVWF  FF6
7B78:  MOVLW  4C
7B7A:  MOVWF  FF7
7B7C:  CLRF   19
7B7E:  BTFSC  FF2.7
7B80:  BSF    19.7
7B82:  BCF    FF2.7
7B84:  MOVLB  0
7B86:  CALL   07A0
7B8A:  BTFSC  19.7
7B8C:  BSF    FF2.7
....................                    for(i=0;i<20;i++)fprintf(COM2,"%c",msg_buffer2[i]);  
7B8E:  MOVLB  9
7B90:  CLRF   xD2
7B92:  MOVF   xD2,W
7B94:  SUBLW  13
7B96:  BNC   7BC6
7B98:  CLRF   03
7B9A:  MOVF   xD2,W
7B9C:  ADDLW  16
7B9E:  MOVWF  FE9
7BA0:  MOVLW  03
7BA2:  ADDWFC 03,W
7BA4:  MOVWF  FEA
7BA6:  MOVFF  FEF,A8E
7BAA:  CLRF   19
7BAC:  BTFSC  FF2.7
7BAE:  BSF    19.7
7BB0:  BCF    FF2.7
7BB2:  MOVFF  A8E,ADF
7BB6:  MOVLB  0
7BB8:  CALL   075A
7BBC:  BTFSC  19.7
7BBE:  BSF    FF2.7
7BC0:  MOVLB  9
7BC2:  INCF   xD2,F
7BC4:  BRA    7B92
7BC6:  CLRF   19
7BC8:  BTFSC  FF2.7
7BCA:  BSF    19.7
7BCC:  BCF    FF2.7
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",msg_buffer2[i]); 
....................                    fprintf(COM2,"\n\r");  
7BCE:  MOVLW  0A
7BD0:  MOVLB  A
7BD2:  MOVWF  xDF
7BD4:  MOVLB  0
7BD6:  CALL   075A
7BDA:  BTFSC  19.7
7BDC:  BSF    FF2.7
7BDE:  CLRF   19
7BE0:  BTFSC  FF2.7
7BE2:  BSF    19.7
7BE4:  BCF    FF2.7
7BE6:  MOVLW  0D
7BE8:  MOVLB  A
7BEA:  MOVWF  xDF
7BEC:  MOVLB  0
7BEE:  CALL   075A
7BF2:  BTFSC  19.7
7BF4:  BSF    FF2.7
....................                    EEPROM_read(strobe_pass_addr,20,password); 
7BF6:  MOVLB  A
7BF8:  CLRF   x8E
7BFA:  MOVLW  14
7BFC:  MOVWF  x8F
7BFE:  CLRF   x91
7C00:  MOVLW  55
7C02:  MOVWF  x90
7C04:  MOVLB  0
7C06:  CALL   5062
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%c",password[i]); 
....................                    for(i=0;i<20;i++) 
7C0A:  MOVLB  9
7C0C:  CLRF   xD2
7C0E:  MOVF   xD2,W
7C10:  SUBLW  13
7C12:  BNC   7C30
....................                    { 
....................                      if(password[i]==0)break; 
7C14:  CLRF   03
7C16:  MOVF   xD2,W
7C18:  ADDLW  55
7C1A:  MOVWF  FE9
7C1C:  MOVLW  00
7C1E:  ADDWFC 03,W
7C20:  MOVWF  FEA
7C22:  MOVF   FEF,F
7C24:  BNZ   7C2A
7C26:  BRA    7C30
....................                            else count_char++; 
7C28:  BRA    7C2C
7C2A:  INCF   xD4,F
....................                    } 
7C2C:  INCF   xD2,F
7C2E:  BRA    7C0E
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",password[i]); 
....................                    //fprintf(COM2,"count_char=%d\n\r",count_char);  
....................                    //fprintf(COM2,"\n\r"); 
....................                    if(!strncmp(password,msg_buffer2,count_char))  
7C30:  MOVLB  A
7C32:  CLRF   x8F
7C34:  MOVLW  55
7C36:  MOVWF  x8E
7C38:  MOVLW  03
7C3A:  MOVWF  x91
7C3C:  MOVLW  16
7C3E:  MOVWF  x90
7C40:  CLRF   x93
7C42:  MOVFF  9D4,A92
7C46:  MOVLB  0
7C48:  CALL   5696
7C4C:  MOVF   01,F
7C4E:  BNZ   7CFC
....................                    { 
....................                       EEPROM_write(strobe_mobile_num1,20,mobilenumb); 
7C50:  MOVLW  55
7C52:  MOVLB  A
7C54:  MOVWF  xA3
7C56:  MOVLW  14
7C58:  MOVWF  xA4
7C5A:  MOVLW  04
7C5C:  MOVWF  xA6
7C5E:  MOVLW  79
7C60:  MOVWF  xA5
7C62:  MOVLB  0
7C64:  CALL   50BC
....................                       fprintf(COM2,"changed phone number\n\r("); 
7C68:  MOVLW  92
7C6A:  MOVWF  FF6
7C6C:  MOVLW  4C
7C6E:  MOVWF  FF7
7C70:  CLRF   19
7C72:  BTFSC  FF2.7
7C74:  BSF    19.7
7C76:  BCF    FF2.7
7C78:  CALL   07A0
7C7C:  BTFSC  19.7
7C7E:  BSF    FF2.7
....................                       for(i=0;i<20;i++)fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));  
7C80:  MOVLB  9
7C82:  CLRF   xD2
7C84:  MOVF   xD2,W
7C86:  SUBLW  13
7C88:  BNC   7CC6
7C8A:  MOVLW  55
7C8C:  ADDWF  xD2,W
7C8E:  MOVLB  A
7C90:  MOVWF  x8E
7C92:  CLRF   19
7C94:  BTFSC  FF2.7
7C96:  BSF    19.7
7C98:  BCF    FF2.7
7C9A:  CLRF   xC0
7C9C:  MOVWF  xBF
7C9E:  MOVLB  0
7CA0:  CALL   3948
7CA4:  BTFSC  19.7
7CA6:  BSF    FF2.7
7CA8:  MOVFF  01,A8E
7CAC:  CLRF   19
7CAE:  BTFSC  FF2.7
7CB0:  BSF    19.7
7CB2:  BCF    FF2.7
7CB4:  MOVFF  01,ADF
7CB8:  CALL   075A
7CBC:  BTFSC  19.7
7CBE:  BSF    FF2.7
7CC0:  MOVLB  9
7CC2:  INCF   xD2,F
7CC4:  BRA    7C84
....................                       strcpy(reply_buffer,"done"); 
7CC6:  MOVLW  03
7CC8:  MOVWF  FEA
7CCA:  MOVLW  48
7CCC:  MOVWF  FE9
7CCE:  MOVLW  00
7CD0:  MOVLB  0
7CD2:  CALL   0134
7CD6:  TBLRD*-
7CD8:  TBLRD*+
7CDA:  MOVF   FF5,W
7CDC:  MOVWF  FEE
7CDE:  IORLW  00
7CE0:  BNZ   7CD8
....................                       fprintf(COM2,")\n\r"); 
7CE2:  MOVLW  AA
7CE4:  MOVWF  FF6
7CE6:  MOVLW  4C
7CE8:  MOVWF  FF7
7CEA:  CLRF   19
7CEC:  BTFSC  FF2.7
7CEE:  BSF    19.7
7CF0:  BCF    FF2.7
7CF2:  CALL   07A0
7CF6:  BTFSC  19.7
7CF8:  BSF    FF2.7
....................                    } 
....................                      else 
7CFA:  BRA    7D2E
....................                      { 
....................                         fprintf(COM2,"wrong password\n\r"); 
7CFC:  MOVLW  AE
7CFE:  MOVWF  FF6
7D00:  MOVLW  4C
7D02:  MOVWF  FF7
7D04:  CLRF   19
7D06:  BTFSC  FF2.7
7D08:  BSF    19.7
7D0A:  BCF    FF2.7
7D0C:  CALL   07A0
7D10:  BTFSC  19.7
7D12:  BSF    FF2.7
....................                         strcpy(reply_buffer,"wrong password"); 
7D14:  MOVLW  03
7D16:  MOVWF  FEA
7D18:  MOVLW  48
7D1A:  MOVWF  FE9
7D1C:  MOVLW  00
7D1E:  CALL   01DC
7D22:  TBLRD*-
7D24:  TBLRD*+
7D26:  MOVF   FF5,W
7D28:  MOVWF  FEE
7D2A:  IORLW  00
7D2C:  BNZ   7D24
....................                      }                      
....................                    SIM_state=SIM_reply;   
7D2E:  MOVLW  0E
7D30:  MOVLB  4
7D32:  MOVWF  x95
....................                  } 
....................                   else fprintf(COM2,"\n\r this phone unable to send commands \n\r"); 
7D34:  BRA    7D52
7D36:  MOVLB  0
7D38:  MOVLW  C0
7D3A:  MOVWF  FF6
7D3C:  MOVLW  4C
7D3E:  MOVWF  FF7
7D40:  CLRF   19
7D42:  BTFSC  FF2.7
7D44:  BSF    19.7
7D46:  BCF    FF2.7
7D48:  CALL   07A0
7D4C:  BTFSC  19.7
7D4E:  BSF    FF2.7
7D50:  MOVLB  4
....................                } 
....................             break; 
7D52:  GOTO   9914
....................             case doing_sms: 
....................                
....................               memset(msg_data_sending,0,sizeof(msg_data_sending)); 
7D56:  MOVLW  01
7D58:  MOVWF  FEA
7D5A:  MOVLW  B8
7D5C:  MOVWF  FE9
7D5E:  CLRF   00
7D60:  MOVLW  01
7D62:  MOVWF  02
7D64:  MOVLW  18
7D66:  MOVWF  01
7D68:  CALL   446E
....................                
....................               strcpy(msg_buffer2,"password"); 
7D6C:  MOVLW  03
7D6E:  MOVWF  FEA
7D70:  MOVLW  16
7D72:  MOVWF  FE9
7D74:  MOVLW  00
7D76:  CALL   0162
7D7A:  TBLRD*-
7D7C:  TBLRD*+
7D7E:  MOVF   FF5,W
7D80:  MOVWF  FEE
7D82:  IORLW  00
7D84:  BNZ   7D7C
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
7D86:  MOVLW  03
7D88:  MOVLB  A
7D8A:  MOVWF  x8F
7D8C:  MOVLW  16
7D8E:  MOVWF  x8E
7D90:  MOVLW  02
7D92:  MOVWF  x91
7D94:  MOVLW  D0
7D96:  MOVWF  x90
7D98:  CLRF   x93
7D9A:  MOVLW  08
7D9C:  MOVWF  x92
7D9E:  MOVLB  0
7DA0:  CALL   5696
7DA4:  MOVF   01,F
7DA6:  BTFSS  FD8.2
7DA8:  BRA    7EB0
....................               { 
....................                 //SIM_state=delete_MSG;   
....................                 SIM_state=SIM_reply; 
7DAA:  MOVLW  0E
7DAC:  MOVLB  4
7DAE:  MOVWF  x95
....................                 for(i=0;i<20;i++) 
7DB0:  MOVLB  9
7DB2:  CLRF   xD2
7DB4:  MOVF   xD2,W
7DB6:  SUBLW  13
7DB8:  BNC   7DFC
....................                 { 
....................                   write_ext_eeprom(strobe_pass_addr+i,sim_bug[i+9]); 
7DBA:  MOVLW  09
7DBC:  ADDWF  xD2,W
7DBE:  CLRF   03
7DC0:  ADDLW  D0
7DC2:  MOVWF  FE9
7DC4:  MOVLW  02
7DC6:  ADDWFC 03,W
7DC8:  MOVWF  FEA
7DCA:  MOVFF  FEF,A8E
7DCE:  CLRF   19
7DD0:  BTFSC  FF2.7
7DD2:  BSF    19.7
7DD4:  BCF    FF2.7
7DD6:  MOVLB  A
7DD8:  CLRF   xC8
7DDA:  MOVFF  9D2,AC7
7DDE:  MOVFF  A8E,AC9
7DE2:  MOVLB  0
7DE4:  CALL   3E6C
7DE8:  BTFSC  19.7
7DEA:  BSF    FF2.7
....................                   delay_us(10); 
7DEC:  MOVLW  1A
7DEE:  MOVWF  00
7DF0:  DECFSZ 00,F
7DF2:  BRA    7DF0
7DF4:  NOP   
....................                 } 
7DF6:  MOVLB  9
7DF8:  INCF   xD2,F
7DFA:  BRA    7DB4
....................                 //EEPROM_write(strobe_pass_addr,20,sim_bug); 
....................                 fprintf(COM2,"changed the password\n\r");               
7DFC:  MOVLW  EA
7DFE:  MOVWF  FF6
7E00:  MOVLW  4C
7E02:  MOVWF  FF7
7E04:  CLRF   19
7E06:  BTFSC  FF2.7
7E08:  BSF    19.7
7E0A:  BCF    FF2.7
7E0C:  MOVLB  0
7E0E:  CALL   07A0
7E12:  BTFSC  19.7
7E14:  BSF    FF2.7
....................                 memset(password,0,sizeof(password)); 
7E16:  CLRF   FEA
7E18:  MOVLW  55
7E1A:  MOVWF  FE9
7E1C:  CLRF   00
7E1E:  CLRF   02
7E20:  MOVLW  14
7E22:  MOVWF  01
7E24:  CALL   446E
....................                 EEPROM_read(strobe_pass_addr,20,password); 
7E28:  MOVLB  A
7E2A:  CLRF   x8E
7E2C:  MOVLW  14
7E2E:  MOVWF  x8F
7E30:  CLRF   x91
7E32:  MOVLW  55
7E34:  MOVWF  x90
7E36:  MOVLB  0
7E38:  CALL   5062
....................                 for(i=0;i<20;i++) fprintf(COM2,"%c",password[i]); 
7E3C:  MOVLB  9
7E3E:  CLRF   xD2
7E40:  MOVF   xD2,W
7E42:  SUBLW  13
7E44:  BNC   7E74
7E46:  CLRF   03
7E48:  MOVF   xD2,W
7E4A:  ADDLW  55
7E4C:  MOVWF  FE9
7E4E:  MOVLW  00
7E50:  ADDWFC 03,W
7E52:  MOVWF  FEA
7E54:  MOVFF  FEF,A8E
7E58:  CLRF   19
7E5A:  BTFSC  FF2.7
7E5C:  BSF    19.7
7E5E:  BCF    FF2.7
7E60:  MOVFF  A8E,ADF
7E64:  MOVLB  0
7E66:  CALL   075A
7E6A:  BTFSC  19.7
7E6C:  BSF    FF2.7
7E6E:  MOVLB  9
7E70:  INCF   xD2,F
7E72:  BRA    7E40
....................                 fprintf(COM2,"\n\rexit\n\r"); 
7E74:  MOVLW  02
7E76:  MOVWF  FF6
7E78:  MOVLW  4D
7E7A:  MOVWF  FF7
7E7C:  CLRF   19
7E7E:  BTFSC  FF2.7
7E80:  BSF    19.7
7E82:  BCF    FF2.7
7E84:  MOVLB  0
7E86:  CALL   07A0
7E8A:  BTFSC  19.7
7E8C:  BSF    FF2.7
....................                 strcpy(reply_buffer,"done"); 
7E8E:  MOVLW  03
7E90:  MOVWF  FEA
7E92:  MOVLW  48
7E94:  MOVWF  FE9
7E96:  MOVLW  00
7E98:  CALL   0134
7E9C:  TBLRD*-
7E9E:  TBLRD*+
7EA0:  MOVF   FF5,W
7EA2:  MOVWF  FEE
7EA4:  IORLW  00
7EA6:  BNZ   7E9E
....................                 break; 
7EA8:  MOVLB  4
7EAA:  GOTO   9914
7EAE:  MOVLB  0
....................               } 
....................                
....................               strcpy(msg_buffer2,"keypress"); 
7EB0:  MOVLW  03
7EB2:  MOVWF  FEA
7EB4:  MOVLW  16
7EB6:  MOVWF  FE9
7EB8:  MOVLW  00
7EBA:  CALL   0212
7EBE:  TBLRD*-
7EC0:  TBLRD*+
7EC2:  MOVF   FF5,W
7EC4:  MOVWF  FEE
7EC6:  IORLW  00
7EC8:  BNZ   7EC0
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
7ECA:  MOVLW  03
7ECC:  MOVLB  A
7ECE:  MOVWF  x8F
7ED0:  MOVLW  16
7ED2:  MOVWF  x8E
7ED4:  MOVLW  02
7ED6:  MOVWF  x91
7ED8:  MOVLW  D0
7EDA:  MOVWF  x90
7EDC:  CLRF   x93
7EDE:  MOVLW  08
7EE0:  MOVWF  x92
7EE2:  MOVLB  0
7EE4:  CALL   5696
7EE8:  MOVF   01,F
7EEA:  BTFSS  FD8.2
7EEC:  BRA    80D4
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 //SIM_state=SIM_reply; 
....................                 SIM_state=SIM_reply; 
7EEE:  MOVLW  0E
7EF0:  MOVLB  4
7EF2:  MOVWF  x95
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+9]; 
7EF4:  MOVLB  9
7EF6:  CLRF   xD2
7EF8:  MOVF   xD2,W
7EFA:  SUBLW  13
7EFC:  BNC   7F38
7EFE:  CLRF   03
7F00:  MOVF   xD2,W
7F02:  ADDLW  16
7F04:  MOVWF  01
7F06:  MOVLW  03
7F08:  ADDWFC 03,F
7F0A:  MOVFF  03,A8F
7F0E:  MOVLW  09
7F10:  MOVLB  9
7F12:  ADDWF  xD2,W
7F14:  CLRF   03
7F16:  ADDLW  D0
7F18:  MOVWF  FE9
7F1A:  MOVLW  02
7F1C:  ADDWFC 03,W
7F1E:  MOVWF  FEA
7F20:  MOVFF  FEF,A90
7F24:  MOVLB  A
7F26:  MOVFF  A8F,FEA
7F2A:  MOVFF  01,FE9
7F2E:  MOVFF  A90,FEF
7F32:  MOVLB  9
7F34:  INCF   xD2,F
7F36:  BRA    7EF8
....................                 strcpy(msg_buffer1,"on"); 
7F38:  MOVLW  03
7F3A:  MOVWF  FEA
7F3C:  MOVLW  02
7F3E:  MOVWF  FE9
7F40:  MOVLW  00
7F42:  MOVLB  0
7F44:  CALL   022C
7F48:  TBLRD*-
7F4A:  TBLRD*+
7F4C:  MOVF   FF5,W
7F4E:  MOVWF  FEE
7F50:  IORLW  00
7F52:  BNZ   7F4A
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
7F54:  MOVLW  03
7F56:  MOVLB  A
7F58:  MOVWF  x8F
7F5A:  MOVLW  16
7F5C:  MOVWF  x8E
7F5E:  MOVLW  03
7F60:  MOVWF  x91
7F62:  MOVLW  02
7F64:  MOVWF  x90
7F66:  CLRF   x93
7F68:  MOVWF  x92
7F6A:  MOVLB  0
7F6C:  CALL   5696
7F70:  MOVF   01,F
7F72:  BNZ   7FEA
....................                 { 
....................                   fprintf(COM2,"\n\rkeypress turn on\n\r"); 
7F74:  MOVLW  0C
7F76:  MOVWF  FF6
7F78:  MOVLW  4D
7F7A:  MOVWF  FF7
7F7C:  CLRF   19
7F7E:  BTFSC  FF2.7
7F80:  BSF    19.7
7F82:  BCF    FF2.7
7F84:  CALL   07A0
7F88:  BTFSC  19.7
7F8A:  BSF    FF2.7
....................                   KP_mode = 1; 
7F8C:  MOVLW  01
7F8E:  MOVLB  1
7F90:  MOVWF  x0F
7F92:  CLRF   19
7F94:  BTFSC  FF2.7
7F96:  BSF    19.7
7F98:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_keypressmode,KP_mode); 
7F9A:  MOVLB  A
7F9C:  CLRF   xC8
7F9E:  MOVLW  7F
7FA0:  MOVWF  xC7
7FA2:  MOVFF  10F,AC9
7FA6:  MOVLB  0
7FA8:  CALL   3E6C
7FAC:  BTFSC  19.7
7FAE:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r");                  
7FB0:  MOVLW  22
7FB2:  MOVWF  FF6
7FB4:  MOVLW  4D
7FB6:  MOVWF  FF7
7FB8:  CLRF   19
7FBA:  BTFSC  FF2.7
7FBC:  BSF    19.7
7FBE:  BCF    FF2.7
7FC0:  CALL   07A0
7FC4:  BTFSC  19.7
7FC6:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
7FC8:  MOVLW  03
7FCA:  MOVWF  FEA
7FCC:  MOVLW  48
7FCE:  MOVWF  FE9
7FD0:  MOVLW  00
7FD2:  CALL   0134
7FD6:  TBLRD*-
7FD8:  TBLRD*+
7FDA:  MOVF   FF5,W
7FDC:  MOVWF  FEE
7FDE:  IORLW  00
7FE0:  BNZ   7FD8
....................                   break; 
7FE2:  MOVLB  4
7FE4:  GOTO   9914
7FE8:  MOVLB  0
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
7FEA:  MOVLW  03
7FEC:  MOVWF  FEA
7FEE:  MOVLW  02
7FF0:  MOVWF  FE9
7FF2:  MOVLW  00
7FF4:  CALL   0240
7FF8:  TBLRD*-
7FFA:  TBLRD*+
7FFC:  MOVF   FF5,W
7FFE:  MOVWF  FEE
8000:  IORLW  00
8002:  BNZ   7FFA
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
8004:  MOVLW  03
8006:  MOVLB  A
8008:  MOVWF  x8F
800A:  MOVLW  16
800C:  MOVWF  x8E
800E:  MOVLW  03
8010:  MOVWF  x91
8012:  MOVLW  02
8014:  MOVWF  x90
8016:  CLRF   x93
8018:  MOVLW  03
801A:  MOVWF  x92
801C:  MOVLB  0
801E:  CALL   5696
8022:  MOVF   01,F
8024:  BNZ   809A
....................                 { 
....................                   fprintf(COM2,"\n\rkeypress turn off\n\r"); 
8026:  MOVLW  2A
8028:  MOVWF  FF6
802A:  MOVLW  4D
802C:  MOVWF  FF7
802E:  CLRF   19
8030:  BTFSC  FF2.7
8032:  BSF    19.7
8034:  BCF    FF2.7
8036:  CALL   07A0
803A:  BTFSC  19.7
803C:  BSF    FF2.7
....................                   KP_mode = 0; 
803E:  MOVLB  1
8040:  CLRF   x0F
8042:  CLRF   19
8044:  BTFSC  FF2.7
8046:  BSF    19.7
8048:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_keypressmode,KP_mode); 
804A:  MOVLB  A
804C:  CLRF   xC8
804E:  MOVLW  7F
8050:  MOVWF  xC7
8052:  MOVFF  10F,AC9
8056:  MOVLB  0
8058:  CALL   3E6C
805C:  BTFSC  19.7
805E:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r"); 
8060:  MOVLW  40
8062:  MOVWF  FF6
8064:  MOVLW  4D
8066:  MOVWF  FF7
8068:  CLRF   19
806A:  BTFSC  FF2.7
806C:  BSF    19.7
806E:  BCF    FF2.7
8070:  CALL   07A0
8074:  BTFSC  19.7
8076:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8078:  MOVLW  03
807A:  MOVWF  FEA
807C:  MOVLW  48
807E:  MOVWF  FE9
8080:  MOVLW  00
8082:  CALL   0134
8086:  TBLRD*-
8088:  TBLRD*+
808A:  MOVF   FF5,W
808C:  MOVWF  FEE
808E:  IORLW  00
8090:  BNZ   8088
....................                   break; 
8092:  MOVLB  4
8094:  GOTO   9914
8098:  MOVLB  0
....................                 } 
....................                 strcpy(reply_buffer,"please check your syntax");  
809A:  MOVLW  03
809C:  MOVWF  FEA
809E:  MOVLW  48
80A0:  MOVWF  FE9
80A2:  MOVLW  00
80A4:  CALL   0254
80A8:  TBLRD*-
80AA:  TBLRD*+
80AC:  MOVF   FF5,W
80AE:  MOVWF  FEE
80B0:  IORLW  00
80B2:  BNZ   80AA
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
80B4:  MOVLW  48
80B6:  MOVWF  FF6
80B8:  MOVLW  4D
80BA:  MOVWF  FF7
80BC:  CLRF   19
80BE:  BTFSC  FF2.7
80C0:  BSF    19.7
80C2:  BCF    FF2.7
80C4:  CALL   07A0
80C8:  BTFSC  19.7
80CA:  BSF    FF2.7
....................                 break; 
80CC:  MOVLB  4
80CE:  GOTO   9914
80D2:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"master"); 
80D4:  MOVLW  03
80D6:  MOVWF  FEA
80D8:  MOVLW  16
80DA:  MOVWF  FE9
80DC:  MOVLW  00
80DE:  CALL   027E
80E2:  TBLRD*-
80E4:  TBLRD*+
80E6:  MOVF   FF5,W
80E8:  MOVWF  FEE
80EA:  IORLW  00
80EC:  BNZ   80E4
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
80EE:  MOVLW  03
80F0:  MOVLB  A
80F2:  MOVWF  x8F
80F4:  MOVLW  16
80F6:  MOVWF  x8E
80F8:  MOVLW  02
80FA:  MOVWF  x91
80FC:  MOVLW  D0
80FE:  MOVWF  x90
8100:  CLRF   x93
8102:  MOVLW  06
8104:  MOVWF  x92
8106:  MOVLB  0
8108:  CALL   5696
810C:  MOVF   01,F
810E:  BTFSS  FD8.2
8110:  BRA    82F8
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
8112:  MOVLW  0E
8114:  MOVLB  4
8116:  MOVWF  x95
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+7]; 
8118:  MOVLB  9
811A:  CLRF   xD2
811C:  MOVF   xD2,W
811E:  SUBLW  13
8120:  BNC   815C
8122:  CLRF   03
8124:  MOVF   xD2,W
8126:  ADDLW  16
8128:  MOVWF  01
812A:  MOVLW  03
812C:  ADDWFC 03,F
812E:  MOVFF  03,A8F
8132:  MOVLW  07
8134:  MOVLB  9
8136:  ADDWF  xD2,W
8138:  CLRF   03
813A:  ADDLW  D0
813C:  MOVWF  FE9
813E:  MOVLW  02
8140:  ADDWFC 03,W
8142:  MOVWF  FEA
8144:  MOVFF  FEF,A90
8148:  MOVLB  A
814A:  MOVFF  A8F,FEA
814E:  MOVFF  01,FE9
8152:  MOVFF  A90,FEF
8156:  MOVLB  9
8158:  INCF   xD2,F
815A:  BRA    811C
....................                 strcpy(msg_buffer1,"on"); 
815C:  MOVLW  03
815E:  MOVWF  FEA
8160:  MOVLW  02
8162:  MOVWF  FE9
8164:  MOVLW  00
8166:  MOVLB  0
8168:  CALL   022C
816C:  TBLRD*-
816E:  TBLRD*+
8170:  MOVF   FF5,W
8172:  MOVWF  FEE
8174:  IORLW  00
8176:  BNZ   816E
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
8178:  MOVLW  03
817A:  MOVLB  A
817C:  MOVWF  x8F
817E:  MOVLW  16
8180:  MOVWF  x8E
8182:  MOVLW  03
8184:  MOVWF  x91
8186:  MOVLW  02
8188:  MOVWF  x90
818A:  CLRF   x93
818C:  MOVWF  x92
818E:  MOVLB  0
8190:  CALL   5696
8194:  MOVF   01,F
8196:  BNZ   820C
....................                 { 
....................                   fprintf(COM2,"\n\rmaster mode turn on\n\r"); 
8198:  MOVLW  66
819A:  MOVWF  FF6
819C:  MOVLW  4D
819E:  MOVWF  FF7
81A0:  CLRF   19
81A2:  BTFSC  FF2.7
81A4:  BSF    19.7
81A6:  BCF    FF2.7
81A8:  CALL   07A0
81AC:  BTFSC  19.7
81AE:  BSF    FF2.7
....................                    mode_sl = 0; 
81B0:  MOVLB  9
81B2:  CLRF   xB3
81B4:  CLRF   19
81B6:  BTFSC  FF2.7
81B8:  BSF    19.7
81BA:  BCF    FF2.7
....................                    write_ext_eeprom(strobe_Master_SLV,mode_sl); 
81BC:  MOVLB  A
81BE:  CLRF   xC8
81C0:  MOVLW  91
81C2:  MOVWF  xC7
81C4:  MOVFF  9B3,AC9
81C8:  MOVLB  0
81CA:  CALL   3E6C
81CE:  BTFSC  19.7
81D0:  BSF    FF2.7
....................                    strcpy(reply_buffer,"done"); 
81D2:  MOVLW  03
81D4:  MOVWF  FEA
81D6:  MOVLW  48
81D8:  MOVWF  FE9
81DA:  MOVLW  00
81DC:  CALL   0134
81E0:  TBLRD*-
81E2:  TBLRD*+
81E4:  MOVF   FF5,W
81E6:  MOVWF  FEE
81E8:  IORLW  00
81EA:  BNZ   81E2
....................                    fprintf(COM2," exit\n\r"); 
81EC:  MOVLW  7E
81EE:  MOVWF  FF6
81F0:  MOVLW  4D
81F2:  MOVWF  FF7
81F4:  CLRF   19
81F6:  BTFSC  FF2.7
81F8:  BSF    19.7
81FA:  BCF    FF2.7
81FC:  CALL   07A0
8200:  BTFSC  19.7
8202:  BSF    FF2.7
....................                    break; 
8204:  MOVLB  4
8206:  GOTO   9914
820A:  MOVLB  0
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
820C:  MOVLW  03
820E:  MOVWF  FEA
8210:  MOVLW  02
8212:  MOVWF  FE9
8214:  MOVLW  00
8216:  CALL   0240
821A:  TBLRD*-
821C:  TBLRD*+
821E:  MOVF   FF5,W
8220:  MOVWF  FEE
8222:  IORLW  00
8224:  BNZ   821C
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
8226:  MOVLW  03
8228:  MOVLB  A
822A:  MOVWF  x8F
822C:  MOVLW  16
822E:  MOVWF  x8E
8230:  MOVLW  03
8232:  MOVWF  x91
8234:  MOVLW  02
8236:  MOVWF  x90
8238:  CLRF   x93
823A:  MOVLW  03
823C:  MOVWF  x92
823E:  MOVLB  0
8240:  CALL   5696
8244:  MOVF   01,F
8246:  BNZ   82BE
....................                 { 
....................                   fprintf(COM2,"\n\rmaster mode turn off\n\r"); 
8248:  MOVLW  86
824A:  MOVWF  FF6
824C:  MOVLW  4D
824E:  MOVWF  FF7
8250:  CLRF   19
8252:  BTFSC  FF2.7
8254:  BSF    19.7
8256:  BCF    FF2.7
8258:  CALL   07A0
825C:  BTFSC  19.7
825E:  BSF    FF2.7
....................                   mode_sl = 1; 
8260:  MOVLW  01
8262:  MOVLB  9
8264:  MOVWF  xB3
8266:  CLRF   19
8268:  BTFSC  FF2.7
826A:  BSF    19.7
826C:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_Master_SLV,mode_sl); 
826E:  MOVLB  A
8270:  CLRF   xC8
8272:  MOVLW  91
8274:  MOVWF  xC7
8276:  MOVFF  9B3,AC9
827A:  MOVLB  0
827C:  CALL   3E6C
8280:  BTFSC  19.7
8282:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8284:  MOVLW  03
8286:  MOVWF  FEA
8288:  MOVLW  48
828A:  MOVWF  FE9
828C:  MOVLW  00
828E:  CALL   0134
8292:  TBLRD*-
8294:  TBLRD*+
8296:  MOVF   FF5,W
8298:  MOVWF  FEE
829A:  IORLW  00
829C:  BNZ   8294
....................                   fprintf(COM2," exit\n\r"); 
829E:  MOVLW  A0
82A0:  MOVWF  FF6
82A2:  MOVLW  4D
82A4:  MOVWF  FF7
82A6:  CLRF   19
82A8:  BTFSC  FF2.7
82AA:  BSF    19.7
82AC:  BCF    FF2.7
82AE:  CALL   07A0
82B2:  BTFSC  19.7
82B4:  BSF    FF2.7
....................                   break; 
82B6:  MOVLB  4
82B8:  GOTO   9914
82BC:  MOVLB  0
....................                 } 
....................                 strcpy(reply_buffer,"please check your syntax");  
82BE:  MOVLW  03
82C0:  MOVWF  FEA
82C2:  MOVLW  48
82C4:  MOVWF  FE9
82C6:  MOVLW  00
82C8:  CALL   0254
82CC:  TBLRD*-
82CE:  TBLRD*+
82D0:  MOVF   FF5,W
82D2:  MOVWF  FEE
82D4:  IORLW  00
82D6:  BNZ   82CE
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
82D8:  MOVLW  A8
82DA:  MOVWF  FF6
82DC:  MOVLW  4D
82DE:  MOVWF  FF7
82E0:  CLRF   19
82E2:  BTFSC  FF2.7
82E4:  BSF    19.7
82E6:  BCF    FF2.7
82E8:  CALL   07A0
82EC:  BTFSC  19.7
82EE:  BSF    FF2.7
....................                 break; 
82F0:  MOVLB  4
82F2:  GOTO   9914
82F6:  MOVLB  0
....................               } 
....................                
....................               strcpy(msg_buffer2,"rsfact"); 
82F8:  MOVLW  03
82FA:  MOVWF  FEA
82FC:  MOVLW  16
82FE:  MOVWF  FE9
8300:  MOVLW  00
8302:  CALL   014A
8306:  TBLRD*-
8308:  TBLRD*+
830A:  MOVF   FF5,W
830C:  MOVWF  FEE
830E:  IORLW  00
8310:  BNZ   8308
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
8312:  MOVLW  03
8314:  MOVLB  A
8316:  MOVWF  x8F
8318:  MOVLW  16
831A:  MOVWF  x8E
831C:  MOVLW  02
831E:  MOVWF  x91
8320:  MOVLW  D0
8322:  MOVWF  x90
8324:  CLRF   x93
8326:  MOVLW  06
8328:  MOVWF  x92
832A:  MOVLB  0
832C:  CALL   5696
8330:  MOVF   01,F
8332:  BNZ   837A
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
8334:  MOVLW  0E
8336:  MOVLB  4
8338:  MOVWF  x95
....................                   fprintf(COM2,"reset factory\n\r"); 
833A:  MOVLW  C6
833C:  MOVWF  FF6
833E:  MOVLW  4D
8340:  MOVWF  FF7
8342:  CLRF   19
8344:  BTFSC  FF2.7
8346:  BSF    19.7
8348:  BCF    FF2.7
834A:  MOVLB  0
834C:  CALL   07A0
8350:  BTFSC  19.7
8352:  BSF    FF2.7
....................                   rstfact(); 
8354:  GOTO   5A48
....................                   strcpy(reply_buffer,"done"); 
8358:  MOVLW  03
835A:  MOVWF  FEA
835C:  MOVLW  48
835E:  MOVWF  FE9
8360:  MOVLW  00
8362:  CALL   0134
8366:  TBLRD*-
8368:  TBLRD*+
836A:  MOVF   FF5,W
836C:  MOVWF  FEE
836E:  IORLW  00
8370:  BNZ   8368
....................                   break; 
8372:  MOVLB  4
8374:  GOTO   9914
8378:  MOVLB  0
....................               }    
....................               strcpy(msg_buffer2,"kofkb new"); 
837A:  MOVLW  03
837C:  MOVWF  FEA
837E:  MOVLW  16
8380:  MOVWF  FE9
8382:  MOVLW  00
8384:  CALL   0296
8388:  TBLRD*-
838A:  TBLRD*+
838C:  MOVF   FF5,W
838E:  MOVWF  FEE
8390:  IORLW  00
8392:  BNZ   838A
....................               if(!strncmp(msg_buffer2,sim_bug,9))  
8394:  MOVLW  03
8396:  MOVLB  A
8398:  MOVWF  x8F
839A:  MOVLW  16
839C:  MOVWF  x8E
839E:  MOVLW  02
83A0:  MOVWF  x91
83A2:  MOVLW  D0
83A4:  MOVWF  x90
83A6:  CLRF   x93
83A8:  MOVLW  09
83AA:  MOVWF  x92
83AC:  MOVLB  0
83AE:  CALL   5696
83B2:  MOVF   01,F
83B4:  BNZ   841C
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
83B6:  MOVLW  0E
83B8:  MOVLB  4
83BA:  MOVWF  x95
....................                   fprintf(COM2,"changed to new keyboard\n\r"); 
83BC:  MOVLW  D6
83BE:  MOVWF  FF6
83C0:  MOVLW  4D
83C2:  MOVWF  FF7
83C4:  CLRF   19
83C6:  BTFSC  FF2.7
83C8:  BSF    19.7
83CA:  BCF    FF2.7
83CC:  MOVLB  0
83CE:  CALL   07A0
83D2:  BTFSC  19.7
83D4:  BSF    FF2.7
....................                   type_KB=1; 
83D6:  MOVLW  01
83D8:  MOVLB  1
83DA:  MOVWF  x13
83DC:  CLRF   19
83DE:  BTFSC  FF2.7
83E0:  BSF    19.7
83E2:  BCF    FF2.7
....................                   write_ext_eeprom(kindofKB,type_KB); 
83E4:  MOVLB  A
83E6:  CLRF   xC8
83E8:  MOVLW  7E
83EA:  MOVWF  xC7
83EC:  MOVFF  113,AC9
83F0:  MOVLB  0
83F2:  CALL   3E6C
83F6:  BTFSC  19.7
83F8:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
83FA:  MOVLW  03
83FC:  MOVWF  FEA
83FE:  MOVLW  48
8400:  MOVWF  FE9
8402:  MOVLW  00
8404:  CALL   0134
8408:  TBLRD*-
840A:  TBLRD*+
840C:  MOVF   FF5,W
840E:  MOVWF  FEE
8410:  IORLW  00
8412:  BNZ   840A
....................                   break; 
8414:  MOVLB  4
8416:  GOTO   9914
841A:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"kofkb old"); 
841C:  MOVLW  03
841E:  MOVWF  FEA
8420:  MOVLW  16
8422:  MOVWF  FE9
8424:  MOVLW  00
8426:  CALL   02B0
842A:  TBLRD*-
842C:  TBLRD*+
842E:  MOVF   FF5,W
8430:  MOVWF  FEE
8432:  IORLW  00
8434:  BNZ   842C
....................               if(!strncmp(msg_buffer2,sim_bug,9))  
8436:  MOVLW  03
8438:  MOVLB  A
843A:  MOVWF  x8F
843C:  MOVLW  16
843E:  MOVWF  x8E
8440:  MOVLW  02
8442:  MOVWF  x91
8444:  MOVLW  D0
8446:  MOVWF  x90
8448:  CLRF   x93
844A:  MOVLW  09
844C:  MOVWF  x92
844E:  MOVLB  0
8450:  CALL   5696
8454:  MOVF   01,F
8456:  BNZ   84BC
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
8458:  MOVLW  0E
845A:  MOVLB  4
845C:  MOVWF  x95
....................                   fprintf(COM2,"changed to old keyboard\n\r"); 
845E:  MOVLW  F0
8460:  MOVWF  FF6
8462:  MOVLW  4D
8464:  MOVWF  FF7
8466:  CLRF   19
8468:  BTFSC  FF2.7
846A:  BSF    19.7
846C:  BCF    FF2.7
846E:  MOVLB  0
8470:  CALL   07A0
8474:  BTFSC  19.7
8476:  BSF    FF2.7
....................                   type_KB=0; 
8478:  MOVLB  1
847A:  CLRF   x13
847C:  CLRF   19
847E:  BTFSC  FF2.7
8480:  BSF    19.7
8482:  BCF    FF2.7
....................                   write_ext_eeprom(kindofKB,type_KB); 
8484:  MOVLB  A
8486:  CLRF   xC8
8488:  MOVLW  7E
848A:  MOVWF  xC7
848C:  MOVFF  113,AC9
8490:  MOVLB  0
8492:  CALL   3E6C
8496:  BTFSC  19.7
8498:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
849A:  MOVLW  03
849C:  MOVWF  FEA
849E:  MOVLW  48
84A0:  MOVWF  FE9
84A2:  MOVLW  00
84A4:  CALL   0134
84A8:  TBLRD*-
84AA:  TBLRD*+
84AC:  MOVF   FF5,W
84AE:  MOVWF  FEE
84B0:  IORLW  00
84B2:  BNZ   84AA
....................                   break; 
84B4:  MOVLB  4
84B6:  GOTO   9914
84BA:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"trantime"); 
84BC:  MOVLW  03
84BE:  MOVWF  FEA
84C0:  MOVLW  16
84C2:  MOVWF  FE9
84C4:  MOVLW  00
84C6:  CALL   02CA
84CA:  TBLRD*-
84CC:  TBLRD*+
84CE:  MOVF   FF5,W
84D0:  MOVWF  FEE
84D2:  IORLW  00
84D4:  BNZ   84CC
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
84D6:  MOVLW  03
84D8:  MOVLB  A
84DA:  MOVWF  x8F
84DC:  MOVLW  16
84DE:  MOVWF  x8E
84E0:  MOVLW  02
84E2:  MOVWF  x91
84E4:  MOVLW  D0
84E6:  MOVWF  x90
84E8:  CLRF   x93
84EA:  MOVLW  08
84EC:  MOVWF  x92
84EE:  MOVLB  0
84F0:  CALL   5696
84F4:  MOVF   01,F
84F6:  BTFSS  FD8.2
84F8:  BRA    8640
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
84FA:  MOVLW  0E
84FC:  MOVLB  4
84FE:  MOVWF  x95
....................                 memset(msg_buffer2,0,sizeof(msg_buffer2)); 
8500:  MOVLW  03
8502:  MOVWF  FEA
8504:  MOVLW  16
8506:  MOVWF  FE9
8508:  CLRF   00
850A:  CLRF   02
850C:  MOVLW  32
850E:  MOVWF  01
8510:  MOVLB  0
8512:  CALL   446E
....................                 //for(i=0;i<3;i++)msg_buffer2[i]=sim_bug[i+9]; 
....................                 if((sim_bug[9]>47)&&(sim_bug[9]<58))  
8516:  MOVLB  2
8518:  MOVF   xD9,W
851A:  SUBLW  2F
851C:  BC    8600
851E:  MOVF   xD9,W
8520:  SUBLW  39
8522:  BNC   8600
....................                 { 
....................                    delaycharaction = (sim_bug[9]-48)*10; 
8524:  MOVLW  30
8526:  SUBWF  xD9,W
8528:  MULLW  0A
852A:  MOVFF  FF3,146
852E:  MOVLB  1
....................                    if((sim_bug[10]>47)&&(sim_bug[10]<58))delaycharaction=delaycharaction+(sim_bug[10]-48); 
8530:  MOVLB  2
8532:  MOVF   xDA,W
8534:  SUBLW  2F
8536:  BC    854A
8538:  MOVF   xDA,W
853A:  SUBLW  39
853C:  BNC   854A
853E:  MOVLW  30
8540:  SUBWF  xDA,W
8542:  MOVLB  1
8544:  ADDWF  x46,F
....................                      else delaycharaction = sim_bug[9]-48; 
8546:  BRA    8552
8548:  MOVLB  2
854A:  MOVLW  30
854C:  SUBWF  xD9,W
854E:  MOVLB  1
8550:  MOVWF  x46
....................                   fprintf(COM2,"tran time = %d\n\r",delaycharaction);   
8552:  MOVLW  0A
8554:  MOVWF  FF6
8556:  MOVLW  4E
8558:  MOVWF  FF7
855A:  CLRF   19
855C:  BTFSC  FF2.7
855E:  BSF    19.7
8560:  BCF    FF2.7
8562:  MOVLW  0C
8564:  MOVLB  A
8566:  MOVWF  xD3
8568:  MOVLB  0
856A:  CALL   1718
856E:  BTFSC  19.7
8570:  BSF    FF2.7
8572:  CLRF   19
8574:  BTFSC  FF2.7
8576:  BSF    19.7
8578:  BCF    FF2.7
857A:  MOVFF  146,ABF
857E:  MOVLW  18
8580:  MOVLB  A
8582:  MOVWF  xC0
8584:  MOVLB  0
8586:  CALL   182C
858A:  BTFSC  19.7
858C:  BSF    FF2.7
858E:  CLRF   19
8590:  BTFSC  FF2.7
8592:  BSF    19.7
8594:  BCF    FF2.7
8596:  MOVLW  0A
8598:  MOVLB  A
859A:  MOVWF  xDF
859C:  MOVLB  0
859E:  CALL   075A
85A2:  BTFSC  19.7
85A4:  BSF    FF2.7
85A6:  CLRF   19
85A8:  BTFSC  FF2.7
85AA:  BSF    19.7
85AC:  BCF    FF2.7
85AE:  MOVLW  0D
85B0:  MOVLB  A
85B2:  MOVWF  xDF
85B4:  MOVLB  0
85B6:  CALL   075A
85BA:  BTFSC  19.7
85BC:  BSF    FF2.7
85BE:  CLRF   19
85C0:  BTFSC  FF2.7
85C2:  BSF    19.7
85C4:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_delaytime,delaycharaction); 
85C6:  MOVLB  A
85C8:  CLRF   xC8
85CA:  MOVLW  94
85CC:  MOVWF  xC7
85CE:  MOVFF  146,AC9
85D2:  MOVLB  0
85D4:  CALL   3E6C
85D8:  BTFSC  19.7
85DA:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
85DC:  MOVLW  03
85DE:  MOVWF  FEA
85E0:  MOVLW  48
85E2:  MOVWF  FE9
85E4:  MOVLW  00
85E6:  CALL   0134
85EA:  TBLRD*-
85EC:  TBLRD*+
85EE:  MOVF   FF5,W
85F0:  MOVWF  FEE
85F2:  IORLW  00
85F4:  BNZ   85EC
....................                   break; 
85F6:  MOVLB  4
85F8:  GOTO   9914
....................                 } 
....................                   else  
85FC:  BRA    863A
85FE:  MOVLB  2
....................                      { 
....................                         fprintf(COM2,"\n\rplease check your syntax\n\r"); 
8600:  MOVLW  1C
8602:  MOVWF  FF6
8604:  MOVLW  4E
8606:  MOVWF  FF7
8608:  CLRF   19
860A:  BTFSC  FF2.7
860C:  BSF    19.7
860E:  BCF    FF2.7
8610:  MOVLB  0
8612:  CALL   07A0
8616:  BTFSC  19.7
8618:  BSF    FF2.7
....................                         strcpy(reply_buffer,"please check your syntax");  
861A:  MOVLW  03
861C:  MOVWF  FEA
861E:  MOVLW  48
8620:  MOVWF  FE9
8622:  MOVLW  00
8624:  CALL   0254
8628:  TBLRD*-
862A:  TBLRD*+
862C:  MOVF   FF5,W
862E:  MOVWF  FEE
8630:  IORLW  00
8632:  BNZ   862A
....................                         break; 
8634:  MOVLB  4
8636:  GOTO   9914
....................                      } 
....................                 break; 
863A:  GOTO   9914
863E:  MOVLB  0
....................               } 
....................                 
....................               strcpy(msg_buffer2,"autosending"); 
8640:  MOVLW  03
8642:  MOVWF  FEA
8644:  MOVLW  16
8646:  MOVWF  FE9
8648:  MOVLW  00
864A:  CALL   02E4
864E:  TBLRD*-
8650:  TBLRD*+
8652:  MOVF   FF5,W
8654:  MOVWF  FEE
8656:  IORLW  00
8658:  BNZ   8650
....................               if(!strncmp(msg_buffer2,sim_bug,11))  
865A:  MOVLW  03
865C:  MOVLB  A
865E:  MOVWF  x8F
8660:  MOVLW  16
8662:  MOVWF  x8E
8664:  MOVLW  02
8666:  MOVWF  x91
8668:  MOVLW  D0
866A:  MOVWF  x90
866C:  CLRF   x93
866E:  MOVLW  0B
8670:  MOVWF  x92
8672:  MOVLB  0
8674:  CALL   5696
8678:  MOVF   01,F
867A:  BTFSS  FD8.2
867C:  BRA    886A
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
867E:  MOVLW  0E
8680:  MOVLB  4
8682:  MOVWF  x95
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+12]; 
8684:  MOVLB  9
8686:  CLRF   xD2
8688:  MOVF   xD2,W
868A:  SUBLW  13
868C:  BNC   86C8
868E:  CLRF   03
8690:  MOVF   xD2,W
8692:  ADDLW  16
8694:  MOVWF  01
8696:  MOVLW  03
8698:  ADDWFC 03,F
869A:  MOVFF  03,A8F
869E:  MOVLW  0C
86A0:  MOVLB  9
86A2:  ADDWF  xD2,W
86A4:  CLRF   03
86A6:  ADDLW  D0
86A8:  MOVWF  FE9
86AA:  MOVLW  02
86AC:  ADDWFC 03,W
86AE:  MOVWF  FEA
86B0:  MOVFF  FEF,A90
86B4:  MOVLB  A
86B6:  MOVFF  A8F,FEA
86BA:  MOVFF  01,FE9
86BE:  MOVFF  A90,FEF
86C2:  MOVLB  9
86C4:  INCF   xD2,F
86C6:  BRA    8688
....................                 strcpy(msg_buffer1,"on"); 
86C8:  MOVLW  03
86CA:  MOVWF  FEA
86CC:  MOVLW  02
86CE:  MOVWF  FE9
86D0:  MOVLW  00
86D2:  MOVLB  0
86D4:  CALL   022C
86D8:  TBLRD*-
86DA:  TBLRD*+
86DC:  MOVF   FF5,W
86DE:  MOVWF  FEE
86E0:  IORLW  00
86E2:  BNZ   86DA
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
86E4:  MOVLW  03
86E6:  MOVLB  A
86E8:  MOVWF  x8F
86EA:  MOVLW  16
86EC:  MOVWF  x8E
86EE:  MOVLW  03
86F0:  MOVWF  x91
86F2:  MOVLW  02
86F4:  MOVWF  x90
86F6:  CLRF   x93
86F8:  MOVWF  x92
86FA:  MOVLB  0
86FC:  CALL   5696
8700:  MOVF   01,F
8702:  BNZ   8780
....................                 { 
....................                   #if defined(twonumber)  
....................                      two_number_sending=0; 
8704:  MOVLB  4
8706:  CLRF   x9F
....................                   #endif    
....................                   fprintf(COM2,"\n\rautosending turn on\n\r"); 
8708:  MOVLW  3A
870A:  MOVWF  FF6
870C:  MOVLW  4E
870E:  MOVWF  FF7
8710:  CLRF   19
8712:  BTFSC  FF2.7
8714:  BSF    19.7
8716:  BCF    FF2.7
8718:  MOVLB  0
871A:  CALL   07A0
871E:  BTFSC  19.7
8720:  BSF    FF2.7
....................                   auto_sending = 1; 
8722:  MOVLW  01
8724:  MOVLB  4
8726:  MOVWF  x99
8728:  CLRF   19
872A:  BTFSC  FF2.7
872C:  BSF    19.7
872E:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_autosending,auto_sending); 
8730:  MOVLB  A
8732:  CLRF   xC8
8734:  MOVLW  93
8736:  MOVWF  xC7
8738:  MOVFF  499,AC9
873C:  MOVLB  0
873E:  CALL   3E6C
8742:  BTFSC  19.7
8744:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r"); 
8746:  MOVLW  52
8748:  MOVWF  FF6
874A:  MOVLW  4E
874C:  MOVWF  FF7
874E:  CLRF   19
8750:  BTFSC  FF2.7
8752:  BSF    19.7
8754:  BCF    FF2.7
8756:  CALL   07A0
875A:  BTFSC  19.7
875C:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
875E:  MOVLW  03
8760:  MOVWF  FEA
8762:  MOVLW  48
8764:  MOVWF  FE9
8766:  MOVLW  00
8768:  CALL   0134
876C:  TBLRD*-
876E:  TBLRD*+
8770:  MOVF   FF5,W
8772:  MOVWF  FEE
8774:  IORLW  00
8776:  BNZ   876E
....................                   break; 
8778:  MOVLB  4
877A:  GOTO   9914
877E:  MOVLB  0
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
8780:  MOVLW  03
8782:  MOVWF  FEA
8784:  MOVLW  02
8786:  MOVWF  FE9
8788:  MOVLW  00
878A:  CALL   0240
878E:  TBLRD*-
8790:  TBLRD*+
8792:  MOVF   FF5,W
8794:  MOVWF  FEE
8796:  IORLW  00
8798:  BNZ   8790
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
879A:  MOVLW  03
879C:  MOVLB  A
879E:  MOVWF  x8F
87A0:  MOVLW  16
87A2:  MOVWF  x8E
87A4:  MOVLW  03
87A6:  MOVWF  x91
87A8:  MOVLW  02
87AA:  MOVWF  x90
87AC:  CLRF   x93
87AE:  MOVLW  03
87B0:  MOVWF  x92
87B2:  MOVLB  0
87B4:  CALL   5696
87B8:  MOVF   01,F
87BA:  BNZ   8830
....................                 { 
....................                   fprintf(COM2,"\n\rautosending turn off\n\r"); 
87BC:  MOVLW  5A
87BE:  MOVWF  FF6
87C0:  MOVLW  4E
87C2:  MOVWF  FF7
87C4:  CLRF   19
87C6:  BTFSC  FF2.7
87C8:  BSF    19.7
87CA:  BCF    FF2.7
87CC:  CALL   07A0
87D0:  BTFSC  19.7
87D2:  BSF    FF2.7
....................                   auto_sending = 0; 
87D4:  MOVLB  4
87D6:  CLRF   x99
87D8:  CLRF   19
87DA:  BTFSC  FF2.7
87DC:  BSF    19.7
87DE:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_autosending,auto_sending); 
87E0:  MOVLB  A
87E2:  CLRF   xC8
87E4:  MOVLW  93
87E6:  MOVWF  xC7
87E8:  MOVFF  499,AC9
87EC:  MOVLB  0
87EE:  CALL   3E6C
87F2:  BTFSC  19.7
87F4:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r"); 
87F6:  MOVLW  74
87F8:  MOVWF  FF6
87FA:  MOVLW  4E
87FC:  MOVWF  FF7
87FE:  CLRF   19
8800:  BTFSC  FF2.7
8802:  BSF    19.7
8804:  BCF    FF2.7
8806:  CALL   07A0
880A:  BTFSC  19.7
880C:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
880E:  MOVLW  03
8810:  MOVWF  FEA
8812:  MOVLW  48
8814:  MOVWF  FE9
8816:  MOVLW  00
8818:  CALL   0134
881C:  TBLRD*-
881E:  TBLRD*+
8820:  MOVF   FF5,W
8822:  MOVWF  FEE
8824:  IORLW  00
8826:  BNZ   881E
....................                   break; 
8828:  MOVLB  4
882A:  GOTO   9914
882E:  MOVLB  0
....................                 } 
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
8830:  MOVLW  7C
8832:  MOVWF  FF6
8834:  MOVLW  4E
8836:  MOVWF  FF7
8838:  CLRF   19
883A:  BTFSC  FF2.7
883C:  BSF    19.7
883E:  BCF    FF2.7
8840:  CALL   07A0
8844:  BTFSC  19.7
8846:  BSF    FF2.7
....................                 strcpy(reply_buffer,"please check your syntax"); 
8848:  MOVLW  03
884A:  MOVWF  FEA
884C:  MOVLW  48
884E:  MOVWF  FE9
8850:  MOVLW  00
8852:  CALL   0254
8856:  TBLRD*-
8858:  TBLRD*+
885A:  MOVF   FF5,W
885C:  MOVWF  FEE
885E:  IORLW  00
8860:  BNZ   8858
....................                 //fprintf(COM2," exit\n\r"); 
....................                 break; 
8862:  MOVLB  4
8864:  GOTO   9914
8868:  MOVLB  0
....................               } 
....................  
....................               strcpy(msg_buffer2,"qullf"); 
886A:  MOVLW  03
886C:  MOVWF  FEA
886E:  MOVLW  16
8870:  MOVWF  FE9
8872:  MOVLW  00
8874:  CALL   0300
8878:  TBLRD*-
887A:  TBLRD*+
887C:  MOVF   FF5,W
887E:  MOVWF  FEE
8880:  IORLW  00
8882:  BNZ   887A
....................               if(!strncmp(msg_buffer2,sim_bug,5))  
8884:  MOVLW  03
8886:  MOVLB  A
8888:  MOVWF  x8F
888A:  MOVLW  16
888C:  MOVWF  x8E
888E:  MOVLW  02
8890:  MOVWF  x91
8892:  MOVLW  D0
8894:  MOVWF  x90
8896:  CLRF   x93
8898:  MOVLW  05
889A:  MOVWF  x92
889C:  MOVLB  0
889E:  CALL   5696
88A2:  MOVF   01,F
88A4:  BNZ   88EA
....................               { 
....................                 SIM_state=delete_MSG; 
88A6:  MOVLW  06
88A8:  MOVLB  4
88AA:  MOVWF  x95
....................                 fprintf(COM2,"FORMATTING..."); 
88AC:  MOVLW  9A
88AE:  MOVWF  FF6
88B0:  MOVLW  4E
88B2:  MOVWF  FF7
88B4:  CLRF   19
88B6:  BTFSC  FF2.7
88B8:  BSF    19.7
88BA:  BCF    FF2.7
88BC:  MOVLB  0
88BE:  CALL   07A0
88C2:  BTFSC  19.7
88C4:  BSF    FF2.7
....................                 ease_eeprom(); 
88C6:  GOTO   5D18
....................                 fprintf(COM2," exit\n\r"); 
88CA:  MOVLW  A8
88CC:  MOVWF  FF6
88CE:  MOVLW  4E
88D0:  MOVWF  FF7
88D2:  CLRF   19
88D4:  BTFSC  FF2.7
88D6:  BSF    19.7
88D8:  BCF    FF2.7
88DA:  CALL   07A0
88DE:  BTFSC  19.7
88E0:  BSF    FF2.7
....................                 break; 
88E2:  MOVLB  4
88E4:  GOTO   9914
88E8:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"format"); 
88EA:  MOVLW  03
88EC:  MOVWF  FEA
88EE:  MOVLW  16
88F0:  MOVWF  FE9
88F2:  MOVLW  00
88F4:  CALL   0316
88F8:  TBLRD*-
88FA:  TBLRD*+
88FC:  MOVF   FF5,W
88FE:  MOVWF  FEE
8900:  IORLW  00
8902:  BNZ   88FA
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
8904:  MOVLW  03
8906:  MOVLB  A
8908:  MOVWF  x8F
890A:  MOVLW  16
890C:  MOVWF  x8E
890E:  MOVLW  02
8910:  MOVWF  x91
8912:  MOVLW  D0
8914:  MOVWF  x90
8916:  CLRF   x93
8918:  MOVLW  06
891A:  MOVWF  x92
891C:  MOVLB  0
891E:  CALL   5696
8922:  MOVF   01,F
8924:  BNZ   8984
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
8926:  MOVLW  0E
8928:  MOVLB  4
892A:  MOVWF  x95
....................                   fprintf(COM2,"FORMATTING..."); 
892C:  MOVLW  B0
892E:  MOVWF  FF6
8930:  MOVLW  4E
8932:  MOVWF  FF7
8934:  CLRF   19
8936:  BTFSC  FF2.7
8938:  BSF    19.7
893A:  BCF    FF2.7
893C:  MOVLB  0
893E:  CALL   07A0
8942:  BTFSC  19.7
8944:  BSF    FF2.7
....................                   format_eepromext(); 
8946:  GOTO   5DD0
....................                   fprintf(COM2," exit\n\r"); 
894A:  MOVLW  BE
894C:  MOVWF  FF6
894E:  MOVLW  4E
8950:  MOVWF  FF7
8952:  CLRF   19
8954:  BTFSC  FF2.7
8956:  BSF    19.7
8958:  BCF    FF2.7
895A:  CALL   07A0
895E:  BTFSC  19.7
8960:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8962:  MOVLW  03
8964:  MOVWF  FEA
8966:  MOVLW  48
8968:  MOVWF  FE9
896A:  MOVLW  00
896C:  CALL   0134
8970:  TBLRD*-
8972:  TBLRD*+
8974:  MOVF   FF5,W
8976:  MOVWF  FEE
8978:  IORLW  00
897A:  BNZ   8972
....................                   break; 
897C:  MOVLB  4
897E:  GOTO   9914
8982:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"countrec"); 
8984:  MOVLW  03
8986:  MOVWF  FEA
8988:  MOVLW  16
898A:  MOVWF  FE9
898C:  MOVLW  00
898E:  CALL   032E
8992:  TBLRD*-
8994:  TBLRD*+
8996:  MOVF   FF5,W
8998:  MOVWF  FEE
899A:  IORLW  00
899C:  BNZ   8994
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
899E:  MOVLW  03
89A0:  MOVLB  A
89A2:  MOVWF  x8F
89A4:  MOVLW  16
89A6:  MOVWF  x8E
89A8:  MOVLW  02
89AA:  MOVWF  x91
89AC:  MOVLW  D0
89AE:  MOVWF  x90
89B0:  CLRF   x93
89B2:  MOVLW  08
89B4:  MOVWF  x92
89B6:  MOVLB  0
89B8:  CALL   5696
89BC:  MOVF   01,F
89BE:  BTFSS  FD8.2
89C0:  BRA    8B26
....................               {   
....................                   len=0; 
89C2:  MOVLB  9
89C4:  CLRF   xD6
89C6:  CLRF   xD5
89C8:  CLRF   19
89CA:  BTFSC  FF2.7
89CC:  BSF    19.7
89CE:  BCF    FF2.7
....................                   cards=get_countcard(); 
89D0:  MOVLB  0
89D2:  CALL   39F0
89D6:  BTFSC  19.7
89D8:  BSF    FF2.7
89DA:  MOVFF  02,9CB
89DE:  MOVFF  01,9CA
....................                   strcpy(msg_buffer2,"device has "); 
89E2:  MOVLW  03
89E4:  MOVWF  FEA
89E6:  MOVLW  16
89E8:  MOVWF  FE9
89EA:  MOVLW  00
89EC:  CALL   0348
89F0:  TBLRD*-
89F2:  TBLRD*+
89F4:  MOVF   FF5,W
89F6:  MOVWF  FEE
89F8:  IORLW  00
89FA:  BNZ   89F2
....................                   len=pre_msg(msg_buffer2,msg_data_sending,0); 
89FC:  MOVLW  03
89FE:  MOVLB  A
8A00:  MOVWF  x8F
8A02:  MOVLW  16
8A04:  MOVWF  x8E
8A06:  MOVLW  01
8A08:  MOVWF  x91
8A0A:  MOVLW  B8
8A0C:  MOVWF  x90
8A0E:  CLRF   x93
8A10:  CLRF   x92
8A12:  MOVLB  0
8A14:  CALL   5F2A
8A18:  MOVLB  9
8A1A:  CLRF   xD6
8A1C:  MOVFF  01,9D5
....................                   itoa(cards,10,string); 
8A20:  MOVLB  A
8A22:  CLRF   x91
8A24:  CLRF   x90
8A26:  MOVFF  9CB,A8F
8A2A:  MOVFF  9CA,A8E
8A2E:  MOVLW  0A
8A30:  MOVWF  x92
8A32:  MOVLW  09
8A34:  MOVWF  x94
8A36:  MOVLW  DB
8A38:  MOVWF  x93
8A3A:  MOVLB  0
8A3C:  CALL   60DA
....................                   len=pre_msg(string,msg_data_sending,len); 
8A40:  MOVLW  09
8A42:  MOVLB  A
8A44:  MOVWF  x8F
8A46:  MOVLW  DB
8A48:  MOVWF  x8E
8A4A:  MOVLW  01
8A4C:  MOVWF  x91
8A4E:  MOVLW  B8
8A50:  MOVWF  x90
8A52:  MOVFF  9D6,A93
8A56:  MOVFF  9D5,A92
8A5A:  MOVLB  0
8A5C:  CALL   5F2A
8A60:  MOVLB  9
8A62:  CLRF   xD6
8A64:  MOVFF  01,9D5
....................                   strcpy(msg_buffer2," transaction "); 
8A68:  MOVLW  03
8A6A:  MOVWF  FEA
8A6C:  MOVLW  16
8A6E:  MOVWF  FE9
8A70:  MOVLW  00
8A72:  MOVLB  0
8A74:  CALL   0364
8A78:  TBLRD*-
8A7A:  TBLRD*+
8A7C:  MOVF   FF5,W
8A7E:  MOVWF  FEE
8A80:  IORLW  00
8A82:  BNZ   8A7A
....................                   len=pre_msg(msg_buffer2,msg_data_sending,len); 
8A84:  MOVLW  03
8A86:  MOVLB  A
8A88:  MOVWF  x8F
8A8A:  MOVLW  16
8A8C:  MOVWF  x8E
8A8E:  MOVLW  01
8A90:  MOVWF  x91
8A92:  MOVLW  B8
8A94:  MOVWF  x90
8A96:  MOVFF  9D6,A93
8A9A:  MOVFF  9D5,A92
8A9E:  MOVLB  0
8AA0:  CALL   5F2A
8AA4:  MOVLB  9
8AA6:  CLRF   xD6
8AA8:  MOVFF  01,9D5
....................                   SIM_state=MSG_sending; 
8AAC:  MOVLW  08
8AAE:  MOVLB  4
8AB0:  MOVWF  x95
....................                   lastlen=0; 
8AB2:  MOVLB  9
8AB4:  CLRF   xD1
8AB6:  CLRF   xD0
....................                   fprintf(COM2,"device has %lu transaction \n\r",cards); 
8AB8:  MOVLW  C6
8ABA:  MOVWF  FF6
8ABC:  MOVLW  4E
8ABE:  MOVWF  FF7
8AC0:  CLRF   19
8AC2:  BTFSC  FF2.7
8AC4:  BSF    19.7
8AC6:  BCF    FF2.7
8AC8:  MOVLW  0B
8ACA:  MOVLB  A
8ACC:  MOVWF  xD3
8ACE:  MOVLB  0
8AD0:  CALL   1718
8AD4:  BTFSC  19.7
8AD6:  BSF    FF2.7
8AD8:  MOVLW  10
8ADA:  MOVWF  FE9
8ADC:  CLRF   19
8ADE:  BTFSC  FF2.7
8AE0:  BSF    19.7
8AE2:  BCF    FF2.7
8AE4:  MOVFF  9CB,ABD
8AE8:  MOVFF  9CA,ABC
8AEC:  CALL   1742
8AF0:  BTFSC  19.7
8AF2:  BSF    FF2.7
8AF4:  MOVLW  D4
8AF6:  MOVWF  FF6
8AF8:  MOVLW  4E
8AFA:  MOVWF  FF7
8AFC:  CLRF   19
8AFE:  BTFSC  FF2.7
8B00:  BSF    19.7
8B02:  BCF    FF2.7
8B04:  MOVLW  0F
8B06:  MOVLB  A
8B08:  MOVWF  xD3
8B0A:  MOVLB  0
8B0C:  CALL   1718
8B10:  BTFSC  19.7
8B12:  BSF    FF2.7
....................                   countc=0; 
8B14:  MOVLB  9
8B16:  CLRF   xCD
8B18:  CLRF   xCC
....................                   count_dwla=0; 
8B1A:  CLRF   xCF
8B1C:  CLRF   xCE
....................                   break; 
8B1E:  MOVLB  4
8B20:  GOTO   9914
8B24:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"download all"); 
8B26:  MOVLW  03
8B28:  MOVWF  FEA
8B2A:  MOVLW  16
8B2C:  MOVWF  FE9
8B2E:  MOVLW  00
8B30:  CALL   0382
8B34:  TBLRD*-
8B36:  TBLRD*+
8B38:  MOVF   FF5,W
8B3A:  MOVWF  FEE
8B3C:  IORLW  00
8B3E:  BNZ   8B36
....................               if(!strncmp(msg_buffer2,sim_bug,12)) 
8B40:  MOVLW  03
8B42:  MOVLB  A
8B44:  MOVWF  x8F
8B46:  MOVLW  16
8B48:  MOVWF  x8E
8B4A:  MOVLW  02
8B4C:  MOVWF  x91
8B4E:  MOVLW  D0
8B50:  MOVWF  x90
8B52:  CLRF   x93
8B54:  MOVLW  0C
8B56:  MOVWF  x92
8B58:  MOVLB  0
8B5A:  CALL   5696
8B5E:  MOVF   01,F
8B60:  BNZ   8BB4
....................               { 
....................                    fprintf(COM2,"download all\n\r");   
8B62:  MOVLW  E4
8B64:  MOVWF  FF6
8B66:  MOVLW  4E
8B68:  MOVWF  FF7
8B6A:  CLRF   19
8B6C:  BTFSC  FF2.7
8B6E:  BSF    19.7
8B70:  BCF    FF2.7
8B72:  CALL   07A0
8B76:  BTFSC  19.7
8B78:  BSF    FF2.7
8B7A:  CLRF   19
8B7C:  BTFSC  FF2.7
8B7E:  BSF    19.7
8B80:  BCF    FF2.7
....................                    count_dwla=get_countcard(); 
8B82:  CALL   39F0
8B86:  BTFSC  19.7
8B88:  BSF    FF2.7
8B8A:  MOVFF  02,9CF
8B8E:  MOVFF  01,9CE
....................                    len=0; 
8B92:  MOVLB  9
8B94:  CLRF   xD6
8B96:  CLRF   xD5
....................                    num_card=count_dwla; 
8B98:  MOVFF  9CF,9C9
8B9C:  MOVFF  9CE,9C8
....................                    SIM_state=pre_cmd; 
8BA0:  MOVLW  07
8BA2:  MOVLB  4
8BA4:  MOVWF  x95
....................                    countc=0; 
8BA6:  MOVLB  9
8BA8:  CLRF   xCD
8BAA:  CLRF   xCC
....................                    break; 
8BAC:  MOVLB  4
8BAE:  GOTO   9914
8BB2:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"download "); 
8BB4:  MOVLW  03
8BB6:  MOVWF  FEA
8BB8:  MOVLW  16
8BBA:  MOVWF  FE9
8BBC:  MOVLW  00
8BBE:  CALL   03A0
8BC2:  TBLRD*-
8BC4:  TBLRD*+
8BC6:  MOVF   FF5,W
8BC8:  MOVWF  FEE
8BCA:  IORLW  00
8BCC:  BNZ   8BC4
....................               if(!strncmp(msg_buffer2,sim_bug,9)) 
8BCE:  MOVLW  03
8BD0:  MOVLB  A
8BD2:  MOVWF  x8F
8BD4:  MOVLW  16
8BD6:  MOVWF  x8E
8BD8:  MOVLW  02
8BDA:  MOVWF  x91
8BDC:  MOVLW  D0
8BDE:  MOVWF  x90
8BE0:  CLRF   x93
8BE2:  MOVLW  09
8BE4:  MOVWF  x92
8BE6:  MOVLB  0
8BE8:  CALL   5696
8BEC:  MOVF   01,F
8BEE:  BTFSS  FD8.2
8BF0:  BRA    8DE2
....................               { 
....................                   if((sim_bug[9]<48)||(sim_bug[9]>57)) 
8BF2:  MOVLB  2
8BF4:  MOVF   xD9,W
8BF6:  SUBLW  2F
8BF8:  BC    8C00
8BFA:  MOVF   xD9,W
8BFC:  SUBLW  39
8BFE:  BC    8C40
....................                   { 
....................                      SIM_state=SIM_reply; 
8C00:  MOVLW  0E
8C02:  MOVLB  4
8C04:  MOVWF  x95
....................                      fprintf(COM2,"\n\rplease check your syntax\n\r"); 
8C06:  MOVLW  F4
8C08:  MOVWF  FF6
8C0A:  MOVLW  4E
8C0C:  MOVWF  FF7
8C0E:  CLRF   19
8C10:  BTFSC  FF2.7
8C12:  BSF    19.7
8C14:  BCF    FF2.7
8C16:  MOVLB  0
8C18:  CALL   07A0
8C1C:  BTFSC  19.7
8C1E:  BSF    FF2.7
....................                      strcpy(reply_buffer,"please check your syntax"); 
8C20:  MOVLW  03
8C22:  MOVWF  FEA
8C24:  MOVLW  48
8C26:  MOVWF  FE9
8C28:  MOVLW  00
8C2A:  CALL   0254
8C2E:  TBLRD*-
8C30:  TBLRD*+
8C32:  MOVF   FF5,W
8C34:  MOVWF  FEE
8C36:  IORLW  00
8C38:  BNZ   8C30
....................                      break; 
8C3A:  MOVLB  4
8C3C:  GOTO   9914
....................                   } 
....................                   i=0; 
8C40:  MOVLB  9
8C42:  CLRF   xD2
....................                   temp=sim_bug[9]; 
8C44:  MOVFF  2D9,9D3
....................                   while(temp!=0) 
....................                   { 
8C48:  MOVF   xD3,F
8C4A:  BZ    8C76
....................                      temp=sim_bug[i+9]; 
8C4C:  MOVLW  09
8C4E:  ADDWF  xD2,W
8C50:  CLRF   03
8C52:  ADDLW  D0
8C54:  MOVWF  FE9
8C56:  MOVLW  02
8C58:  ADDWFC 03,W
8C5A:  MOVWF  FEA
8C5C:  MOVFF  FEF,9D3
....................                      string[i++]=temp; 
8C60:  MOVF   xD2,W
8C62:  INCF   xD2,F
8C64:  CLRF   03
8C66:  ADDLW  DB
8C68:  MOVWF  FE9
8C6A:  MOVLW  09
8C6C:  ADDWFC 03,W
8C6E:  MOVWF  FEA
8C70:  MOVFF  9D3,FEF
....................                   } 
8C74:  BRA    8C48
....................                   countc=atoi(string); 
8C76:  MOVLW  09
8C78:  MOVLB  A
8C7A:  MOVWF  x8F
8C7C:  MOVLW  DB
8C7E:  MOVWF  x8E
8C80:  MOVLB  0
8C82:  GOTO   62F6
8C86:  CLRF   03
8C88:  MOVFF  01,9CC
8C8C:  MOVLB  9
8C8E:  MOVFF  03,9CD
8C92:  CLRF   19
8C94:  BTFSC  FF2.7
8C96:  BSF    19.7
8C98:  BCF    FF2.7
....................                   //fprintf(COM2,"countc=%lu\n\r",countc); 
....................                   count_dwla=get_countcard(); 
8C9A:  MOVLB  0
8C9C:  CALL   39F0
8CA0:  BTFSC  19.7
8CA2:  BSF    FF2.7
8CA4:  MOVFF  02,9CF
8CA8:  MOVFF  01,9CE
....................                   if(count_dwla<countc) 
8CAC:  MOVLB  9
8CAE:  MOVF   xCF,W
8CB0:  SUBWF  xCD,W
8CB2:  BTFSS  FD8.0
8CB4:  BRA    8DAC
8CB6:  BNZ   8CBE
8CB8:  MOVF   xCC,W
8CBA:  SUBWF  xCE,W
8CBC:  BC    8DAC
....................                   { 
....................                      len=0; 
8CBE:  CLRF   xD6
8CC0:  CLRF   xD5
....................                      strcpy(buftemp2,"Device has only "); 
8CC2:  MOVLW  0A
8CC4:  MOVWF  FEA
8CC6:  MOVLW  5C
8CC8:  MOVWF  FE9
8CCA:  MOVLW  00
8CCC:  MOVLB  0
8CCE:  CALL   03BA
8CD2:  TBLRD*-
8CD4:  TBLRD*+
8CD6:  MOVF   FF5,W
8CD8:  MOVWF  FEE
8CDA:  IORLW  00
8CDC:  BNZ   8CD4
....................                      len=pre_msg(buftemp2,msg_data_sending,0); 
8CDE:  MOVLW  0A
8CE0:  MOVLB  A
8CE2:  MOVWF  x8F
8CE4:  MOVLW  5C
8CE6:  MOVWF  x8E
8CE8:  MOVLW  01
8CEA:  MOVWF  x91
8CEC:  MOVLW  B8
8CEE:  MOVWF  x90
8CF0:  CLRF   x93
8CF2:  CLRF   x92
8CF4:  MOVLB  0
8CF6:  CALL   5F2A
8CFA:  MOVLB  9
8CFC:  CLRF   xD6
8CFE:  MOVFF  01,9D5
....................                      itoa(count_dwla,10,string); 
8D02:  MOVLB  A
8D04:  CLRF   x91
8D06:  CLRF   x90
8D08:  MOVFF  9CF,A8F
8D0C:  MOVFF  9CE,A8E
8D10:  MOVLW  0A
8D12:  MOVWF  x92
8D14:  MOVLW  09
8D16:  MOVWF  x94
8D18:  MOVLW  DB
8D1A:  MOVWF  x93
8D1C:  MOVLB  0
8D1E:  CALL   60DA
....................                      len=pre_msg(string,msg_data_sending,len); 
8D22:  MOVLW  09
8D24:  MOVLB  A
8D26:  MOVWF  x8F
8D28:  MOVLW  DB
8D2A:  MOVWF  x8E
8D2C:  MOVLW  01
8D2E:  MOVWF  x91
8D30:  MOVLW  B8
8D32:  MOVWF  x90
8D34:  MOVFF  9D6,A93
8D38:  MOVFF  9D5,A92
8D3C:  MOVLB  0
8D3E:  CALL   5F2A
8D42:  MOVLB  9
8D44:  CLRF   xD6
8D46:  MOVFF  01,9D5
....................                      strcpy(buftemp2," transaction ");//transaction\n\r 
8D4A:  MOVLW  0A
8D4C:  MOVWF  FEA
8D4E:  MOVLW  5C
8D50:  MOVWF  FE9
8D52:  MOVLW  00
8D54:  MOVLB  0
8D56:  CALL   0364
8D5A:  TBLRD*-
8D5C:  TBLRD*+
8D5E:  MOVF   FF5,W
8D60:  MOVWF  FEE
8D62:  IORLW  00
8D64:  BNZ   8D5C
....................                      len=pre_msg(buftemp2,msg_data_sending,len); 
8D66:  MOVLW  0A
8D68:  MOVLB  A
8D6A:  MOVWF  x8F
8D6C:  MOVLW  5C
8D6E:  MOVWF  x8E
8D70:  MOVLW  01
8D72:  MOVWF  x91
8D74:  MOVLW  B8
8D76:  MOVWF  x90
8D78:  MOVFF  9D6,A93
8D7C:  MOVFF  9D5,A92
8D80:  MOVLB  0
8D82:  CALL   5F2A
8D86:  MOVLB  9
8D88:  CLRF   xD6
8D8A:  MOVFF  01,9D5
....................                      SIM_state=MSG_sending; 
8D8E:  MOVLW  08
8D90:  MOVLB  4
8D92:  MOVWF  x95
....................                      lastlen=0; 
8D94:  MOVLB  9
8D96:  CLRF   xD1
8D98:  CLRF   xD0
....................                      count_dwla=0; 
8D9A:  CLRF   xCF
8D9C:  CLRF   xCE
....................                      num_card=0; 
8D9E:  CLRF   xC9
8DA0:  CLRF   xC8
....................                      break; 
8DA2:  MOVLB  4
8DA4:  GOTO   9914
....................                   } 
....................                   else  
8DA8:  BRA    8DE0
8DAA:  MOVLB  9
....................                   { 
....................                      num_card=count_dwla; 
8DAC:  MOVFF  9CF,9C9
8DB0:  MOVFF  9CE,9C8
....................                      countc=num_card-countc; 
8DB4:  MOVF   xCC,W
8DB6:  SUBWF  xC8,W
8DB8:  MOVWF  xCC
8DBA:  MOVF   xCD,W
8DBC:  SUBWFB xC9,W
8DBE:  MOVWF  xCD
....................                      if(countc==0)count_dwla=num_card; 
8DC0:  MOVF   xCC,F
8DC2:  BNZ   8DD2
8DC4:  MOVF   xCD,F
8DC6:  BNZ   8DD2
8DC8:  MOVFF  9C9,9CF
8DCC:  MOVFF  9C8,9CE
....................                      else count_dwla=0; 
8DD0:  BRA    8DD6
8DD2:  CLRF   xCF
8DD4:  CLRF   xCE
....................                      SIM_state=pre_cmd; 
8DD6:  MOVLW  07
8DD8:  MOVLB  4
8DDA:  MOVWF  x95
....................                      break; 
8DDC:  GOTO   9914
....................                   } 
....................                   //SIM_state=delete_MSG; 
....................               } 
....................               else SIM_state=delete_MSG; 
8DE0:  BRA    8DE8
8DE2:  MOVLW  06
8DE4:  MOVLB  4
8DE6:  MOVWF  x95
....................             break; 
8DE8:  GOTO   9914
....................             case delete_MSG: 
....................                receiver_state=1; 
8DEC:  MOVLW  01
8DEE:  MOVLB  1
8DF0:  MOVWF  xB4
....................                fprintf(COM2,"delete_MSG...\n\r"); 
8DF2:  MOVLW  12
8DF4:  MOVWF  FF6
8DF6:  MOVLW  4F
8DF8:  MOVWF  FF7
8DFA:  CLRF   19
8DFC:  BTFSC  FF2.7
8DFE:  BSF    19.7
8E00:  BCF    FF2.7
8E02:  MOVLB  0
8E04:  CALL   07A0
8E08:  BTFSC  19.7
8E0A:  BSF    FF2.7
....................                #ASM BCF    0xF94.7 #ENDASM  
8E0C:  BCF    F94.7
....................                   fprintf(COM1,"AT+CMGD=1\r\n"); 
8E0E:  MOVLW  22
8E10:  MOVWF  FF6
8E12:  MOVLW  4F
8E14:  MOVWF  FF7
8E16:  CALL   53D0
....................                #ASM BSF    0xF94.7 #ENDASM  
8E1A:  BSF    F94.7
8E1C:  CLRF   19
8E1E:  BTFSC  FF2.7
8E20:  BSF    19.7
8E22:  BCF    FF2.7
....................                del_buf(200,buffer_uart); 
8E24:  MOVLW  C8
8E26:  MOVLB  A
8E28:  MOVWF  xC5
8E2A:  MOVLW  01
8E2C:  MOVWF  xC7
8E2E:  MOVLW  4E
8E30:  MOVWF  xC6
8E32:  MOVLB  0
8E34:  CALL   3A62
8E38:  BTFSC  19.7
8E3A:  BSF    FF2.7
....................                //SIM_state=sending_cmd;        
....................                timing_wait=10000; 
8E3C:  MOVLW  27
8E3E:  MOVLB  4
8E40:  MOVWF  x98
8E42:  MOVLW  10
8E44:  MOVWF  x97
....................                SIM_state= idle; 
8E46:  MOVLW  0C
8E48:  MOVWF  x95
....................                over_byte=0; 
8E4A:  MOVLB  1
8E4C:  CLRF   xB7
8E4E:  CLRF   xB6
....................                output_low(LED); 
8E50:  BCF    F92.6
8E52:  BCF    F89.6
....................                memset(reply_buffer,0,sizeof(reply_buffer));  
8E54:  MOVLW  03
8E56:  MOVWF  FEA
8E58:  MOVLW  48
8E5A:  MOVWF  FE9
8E5C:  CLRF   00
8E5E:  MOVLW  01
8E60:  MOVWF  02
8E62:  MOVLW  18
8E64:  MOVWF  01
8E66:  MOVLB  0
8E68:  CALL   446E
....................                memset(buffer_uart,0,sizeof(buffer_uart));                 
8E6C:  MOVLW  01
8E6E:  MOVWF  FEA
8E70:  MOVLW  4E
8E72:  MOVWF  FE9
8E74:  CLRF   00
8E76:  CLRF   02
8E78:  MOVLW  64
8E7A:  MOVWF  01
8E7C:  CALL   446E
....................                SIM_reply_st=0; 
8E80:  MOVLB  4
8E82:  CLRF   x9B
....................                #if defined(twonumber) 
....................                   if(two_number_sending==1) 
8E84:  DECFSZ x9F,W
8E86:  BRA    8E8E
....................                   { 
....................                     SIM_state=autosending1;  
8E88:  MOVLW  13
8E8A:  MOVWF  x95
....................                     two_number_sending=0; 
8E8C:  CLRF   x9F
....................                   } 
....................                #endif 
....................             break; 
8E8E:  GOTO   9914
....................             case pre_cmd: 
....................                    //fprintf(COM2,"pre_cmd-> num_card,countc, count_dwla=%lu,%lu,%lu\r\n",num_card,countc,count_dwla);   
....................                    if(num_card==0)  
8E92:  MOVLB  9
8E94:  MOVF   xC8,F
8E96:  BNZ   8EA8
8E98:  MOVF   xC9,F
8E9A:  BNZ   8EA8
....................                    { 
....................                      SIM_state=delete_MSG; 
8E9C:  MOVLW  06
8E9E:  MOVLB  4
8EA0:  MOVWF  x95
....................                      break; 
8EA2:  GOTO   9914
8EA6:  MOVLB  9
....................                    } 
....................                    len=0; 
8EA8:  CLRF   xD6
8EAA:  CLRF   xD5
....................                    //num_card=1; 
....................                    memset(msg_data_sending,0,sizeof(msg_data_sending));  
8EAC:  MOVLW  01
8EAE:  MOVWF  FEA
8EB0:  MOVLW  B8
8EB2:  MOVWF  FE9
8EB4:  CLRF   00
8EB6:  MOVLW  01
8EB8:  MOVWF  02
8EBA:  MOVLW  18
8EBC:  MOVWF  01
8EBE:  MOVLB  0
8EC0:  CALL   446E
8EC4:  CLRF   19
8EC6:  BTFSC  FF2.7
8EC8:  BSF    19.7
8ECA:  BCF    FF2.7
....................                    addr_dat=num_card*numdata+ptr_start; 
8ECC:  MOVFF  9C9,ABC
8ED0:  MOVFF  9C8,ABB
8ED4:  MOVLB  A
8ED6:  CLRF   xBE
8ED8:  MOVLW  7C
8EDA:  MOVWF  xBD
8EDC:  MOVLB  0
8EDE:  CALL   3A40
8EE2:  BTFSC  19.7
8EE4:  BSF    FF2.7
8EE6:  MOVLW  96
8EE8:  MOVLB  A
8EEA:  ADDWF  01,W
8EEC:  MOVLB  9
8EEE:  MOVWF  xD7
8EF0:  MOVLW  00
8EF2:  MOVLB  A
8EF4:  ADDWFC 02,W
8EF6:  MOVLB  9
8EF8:  MOVWF  xD8
....................                    I2CEEPROM_read((unsigned int16)(addr_dat-numdata),numdata,buftemp); 
8EFA:  MOVLW  7C
8EFC:  SUBWF  xD7,W
8EFE:  MOVLB  A
8F00:  MOVWF  x8E
8F02:  MOVLW  00
8F04:  MOVLB  9
8F06:  SUBWFB xD8,W
8F08:  MOVLB  A
8F0A:  MOVWF  x8F
8F0C:  MOVWF  x91
8F0E:  MOVFF  A8E,A90
8F12:  CLRF   x93
8F14:  MOVLW  7C
8F16:  MOVWF  x92
8F18:  MOVLW  09
8F1A:  MOVWF  x95
8F1C:  MOVLW  E0
8F1E:  MOVWF  x94
8F20:  MOVLB  0
8F22:  GOTO   649A
....................                    itoa(buftemp[0],10,string); 
8F26:  MOVLB  A
8F28:  CLRF   x91
8F2A:  CLRF   x90
8F2C:  CLRF   x8F
8F2E:  MOVFF  9E0,A8E
8F32:  MOVLW  0A
8F34:  MOVWF  x92
8F36:  MOVLW  09
8F38:  MOVWF  x94
8F3A:  MOVLW  DB
8F3C:  MOVWF  x93
8F3E:  MOVLB  0
8F40:  CALL   60DA
....................                    len=pre_msg(string,msg_data_sending,0); 
8F44:  MOVLW  09
8F46:  MOVLB  A
8F48:  MOVWF  x8F
8F4A:  MOVLW  DB
8F4C:  MOVWF  x8E
8F4E:  MOVLW  01
8F50:  MOVWF  x91
8F52:  MOVLW  B8
8F54:  MOVWF  x90
8F56:  CLRF   x93
8F58:  CLRF   x92
8F5A:  MOVLB  0
8F5C:  CALL   5F2A
8F60:  MOVLB  9
8F62:  CLRF   xD6
8F64:  MOVFF  01,9D5
....................                    msg_data_sending[len++]='/'; 
8F68:  MOVFF  9D6,03
8F6C:  MOVF   xD5,W
8F6E:  INCF   xD5,F
8F70:  BTFSC  FD8.2
8F72:  INCF   xD6,F
8F74:  MOVLB  A
8F76:  MOVWF  x8E
8F78:  MOVLW  B8
8F7A:  ADDWF  x8E,W
8F7C:  MOVWF  FE9
8F7E:  MOVLW  01
8F80:  ADDWFC 03,W
8F82:  MOVWF  FEA
8F84:  MOVLW  2F
8F86:  MOVWF  FEF
....................                    itoa(buftemp[1],10,string); 
8F88:  CLRF   x91
8F8A:  CLRF   x90
8F8C:  CLRF   x8F
8F8E:  MOVFF  9E1,A8E
8F92:  MOVLW  0A
8F94:  MOVWF  x92
8F96:  MOVLW  09
8F98:  MOVWF  x94
8F9A:  MOVLW  DB
8F9C:  MOVWF  x93
8F9E:  MOVLB  0
8FA0:  CALL   60DA
....................                    len=pre_msg(string,msg_data_sending,len); 
8FA4:  MOVLW  09
8FA6:  MOVLB  A
8FA8:  MOVWF  x8F
8FAA:  MOVLW  DB
8FAC:  MOVWF  x8E
8FAE:  MOVLW  01
8FB0:  MOVWF  x91
8FB2:  MOVLW  B8
8FB4:  MOVWF  x90
8FB6:  MOVFF  9D6,A93
8FBA:  MOVFF  9D5,A92
8FBE:  MOVLB  0
8FC0:  CALL   5F2A
8FC4:  MOVLB  9
8FC6:  CLRF   xD6
8FC8:  MOVFF  01,9D5
....................                    msg_data_sending[len++]='/'; 
8FCC:  MOVFF  9D6,03
8FD0:  MOVF   xD5,W
8FD2:  INCF   xD5,F
8FD4:  BTFSC  FD8.2
8FD6:  INCF   xD6,F
8FD8:  MOVLB  A
8FDA:  MOVWF  x8E
8FDC:  MOVLW  B8
8FDE:  ADDWF  x8E,W
8FE0:  MOVWF  FE9
8FE2:  MOVLW  01
8FE4:  ADDWFC 03,W
8FE6:  MOVWF  FEA
8FE8:  MOVLW  2F
8FEA:  MOVWF  FEF
....................                    msg_data_sending[len++]=' '; 
8FEC:  MOVLB  9
8FEE:  MOVFF  9D6,03
8FF2:  MOVF   xD5,W
8FF4:  INCF   xD5,F
8FF6:  BTFSC  FD8.2
8FF8:  INCF   xD6,F
8FFA:  MOVLB  A
8FFC:  MOVWF  x8E
8FFE:  MOVLW  B8
9000:  ADDWF  x8E,W
9002:  MOVWF  FE9
9004:  MOVLW  01
9006:  ADDWFC 03,W
9008:  MOVWF  FEA
900A:  MOVLW  20
900C:  MOVWF  FEF
....................                    itoa(buftemp[2],10,string); 
900E:  CLRF   x91
9010:  CLRF   x90
9012:  CLRF   x8F
9014:  MOVFF  9E2,A8E
9018:  MOVLW  0A
901A:  MOVWF  x92
901C:  MOVLW  09
901E:  MOVWF  x94
9020:  MOVLW  DB
9022:  MOVWF  x93
9024:  MOVLB  0
9026:  CALL   60DA
....................                    len=pre_msg(string,msg_data_sending,len); 
902A:  MOVLW  09
902C:  MOVLB  A
902E:  MOVWF  x8F
9030:  MOVLW  DB
9032:  MOVWF  x8E
9034:  MOVLW  01
9036:  MOVWF  x91
9038:  MOVLW  B8
903A:  MOVWF  x90
903C:  MOVFF  9D6,A93
9040:  MOVFF  9D5,A92
9044:  MOVLB  0
9046:  CALL   5F2A
904A:  MOVLB  9
904C:  CLRF   xD6
904E:  MOVFF  01,9D5
....................                    msg_data_sending[len++]=':'; 
9052:  MOVFF  9D6,03
9056:  MOVF   xD5,W
9058:  INCF   xD5,F
905A:  BTFSC  FD8.2
905C:  INCF   xD6,F
905E:  MOVLB  A
9060:  MOVWF  x8E
9062:  MOVLW  B8
9064:  ADDWF  x8E,W
9066:  MOVWF  FE9
9068:  MOVLW  01
906A:  ADDWFC 03,W
906C:  MOVWF  FEA
906E:  MOVLW  3A
9070:  MOVWF  FEF
....................                    itoa(buftemp[3],10,string); 
9072:  CLRF   x91
9074:  CLRF   x90
9076:  CLRF   x8F
9078:  MOVFF  9E3,A8E
907C:  MOVLW  0A
907E:  MOVWF  x92
9080:  MOVLW  09
9082:  MOVWF  x94
9084:  MOVLW  DB
9086:  MOVWF  x93
9088:  MOVLB  0
908A:  CALL   60DA
....................                    len=pre_msg(string,msg_data_sending,len); 
908E:  MOVLW  09
9090:  MOVLB  A
9092:  MOVWF  x8F
9094:  MOVLW  DB
9096:  MOVWF  x8E
9098:  MOVLW  01
909A:  MOVWF  x91
909C:  MOVLW  B8
909E:  MOVWF  x90
90A0:  MOVFF  9D6,A93
90A4:  MOVFF  9D5,A92
90A8:  MOVLB  0
90AA:  CALL   5F2A
90AE:  MOVLB  9
90B0:  CLRF   xD6
90B2:  MOVFF  01,9D5
....................                    msg_data_sending[len++]=':'; 
90B6:  MOVFF  9D6,03
90BA:  MOVF   xD5,W
90BC:  INCF   xD5,F
90BE:  BTFSC  FD8.2
90C0:  INCF   xD6,F
90C2:  MOVLB  A
90C4:  MOVWF  x8E
90C6:  MOVLW  B8
90C8:  ADDWF  x8E,W
90CA:  MOVWF  FE9
90CC:  MOVLW  01
90CE:  ADDWFC 03,W
90D0:  MOVWF  FEA
90D2:  MOVLW  3A
90D4:  MOVWF  FEF
....................                    itoa(buftemp[4],10,string); 
90D6:  CLRF   x91
90D8:  CLRF   x90
90DA:  CLRF   x8F
90DC:  MOVFF  9E4,A8E
90E0:  MOVLW  0A
90E2:  MOVWF  x92
90E4:  MOVLW  09
90E6:  MOVWF  x94
90E8:  MOVLW  DB
90EA:  MOVWF  x93
90EC:  MOVLB  0
90EE:  CALL   60DA
....................                    len=pre_msg(string,msg_data_sending,len); 
90F2:  MOVLW  09
90F4:  MOVLB  A
90F6:  MOVWF  x8F
90F8:  MOVLW  DB
90FA:  MOVWF  x8E
90FC:  MOVLW  01
90FE:  MOVWF  x91
9100:  MOVLW  B8
9102:  MOVWF  x90
9104:  MOVFF  9D6,A93
9108:  MOVFF  9D5,A92
910C:  MOVLB  0
910E:  CALL   5F2A
9112:  MOVLB  9
9114:  CLRF   xD6
9116:  MOVFF  01,9D5
....................                    //msg_data_sending[len++]=' '; 
....................                    i=0; 
911A:  CLRF   xD2
....................                    strcpy(buftemp2," Track1>"); 
911C:  MOVLW  0A
911E:  MOVWF  FEA
9120:  MOVLW  5C
9122:  MOVWF  FE9
9124:  MOVLW  00
9126:  MOVLB  0
9128:  CALL   03DC
912C:  TBLRD*-
912E:  TBLRD*+
9130:  MOVF   FF5,W
9132:  MOVWF  FEE
9134:  IORLW  00
9136:  BNZ   912E
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
9138:  MOVLW  0A
913A:  MOVLB  A
913C:  MOVWF  x8F
913E:  MOVLW  5C
9140:  MOVWF  x8E
9142:  MOVLW  01
9144:  MOVWF  x91
9146:  MOVLW  B8
9148:  MOVWF  x90
914A:  MOVFF  9D6,A93
914E:  MOVFF  9D5,A92
9152:  MOVLB  0
9154:  CALL   5F2A
9158:  MOVLB  9
915A:  CLRF   xD6
915C:  MOVFF  01,9D5
....................                    temp=0; 
9160:  CLRF   xD3
....................                    while((i<numbyteoftrack1)&&(temp!='?')) 
....................                    { 
9162:  MOVF   xD2,W
9164:  SUBLW  4E
9166:  BNC   91BA
9168:  MOVF   xD3,W
916A:  SUBLW  3F
916C:  BZ    91BA
....................                      temp = buftemp[i+5]; 
916E:  MOVLW  05
9170:  ADDWF  xD2,W
9172:  CLRF   03
9174:  ADDLW  E0
9176:  MOVWF  FE9
9178:  MOVLW  09
917A:  ADDWFC 03,W
917C:  MOVWF  FEA
917E:  MOVFF  FEF,9D3
....................                      //fprintf(COM2,"%c",temp);  
....................                      if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
9182:  MOVF   xD3,W
9184:  SUBLW  1F
9186:  BC    91B0
9188:  MOVF   xD3,W
918A:  SUBLW  7E
918C:  BNC   91B0
918E:  MOVFF  9D6,03
9192:  MOVF   xD5,W
9194:  INCF   xD5,F
9196:  BTFSC  FD8.2
9198:  INCF   xD6,F
919A:  MOVLB  A
919C:  MOVWF  x8E
919E:  MOVLW  B8
91A0:  ADDWF  x8E,W
91A2:  MOVWF  FE9
91A4:  MOVLW  01
91A6:  ADDWFC 03,W
91A8:  MOVWF  FEA
91AA:  MOVFF  9D3,FEF
91AE:  MOVLB  9
....................                      i++; 
91B0:  INCF   xD2,F
....................                      if(temp==0)break; 
91B2:  MOVF   xD3,F
91B4:  BNZ   91B8
91B6:  BRA    91BA
....................                    } 
91B8:  BRA    9162
....................                    i=0; 
91BA:  CLRF   xD2
....................                    temp=0; 
91BC:  CLRF   xD3
....................                    strcpy(buftemp2," Track2>"); 
91BE:  MOVLW  0A
91C0:  MOVWF  FEA
91C2:  MOVLW  5C
91C4:  MOVWF  FE9
91C6:  MOVLW  00
91C8:  MOVLB  0
91CA:  CALL   03F6
91CE:  TBLRD*-
91D0:  TBLRD*+
91D2:  MOVF   FF5,W
91D4:  MOVWF  FEE
91D6:  IORLW  00
91D8:  BNZ   91D0
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
91DA:  MOVLW  0A
91DC:  MOVLB  A
91DE:  MOVWF  x8F
91E0:  MOVLW  5C
91E2:  MOVWF  x8E
91E4:  MOVLW  01
91E6:  MOVWF  x91
91E8:  MOVLW  B8
91EA:  MOVWF  x90
91EC:  MOVFF  9D6,A93
91F0:  MOVFF  9D5,A92
91F4:  MOVLB  0
91F6:  CALL   5F2A
91FA:  MOVLB  9
91FC:  CLRF   xD6
91FE:  MOVFF  01,9D5
....................                    while((i<numbyteoftrack2)&&(temp!='?')) 
....................                    { 
9202:  MOVF   xD2,W
9204:  SUBLW  27
9206:  BNC   925C
9208:  MOVF   xD3,W
920A:  SUBLW  3F
920C:  BZ    925C
....................                      temp = buftemp[i+5+numbyteoftrack1]; 
920E:  MOVLW  05
9210:  ADDWF  xD2,W
9212:  ADDLW  4F
9214:  CLRF   03
9216:  ADDLW  E0
9218:  MOVWF  FE9
921A:  MOVLW  09
921C:  ADDWFC 03,W
921E:  MOVWF  FEA
9220:  MOVFF  FEF,9D3
....................                      //fprintf(COM2,"%c",temp);  
....................                      if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
9224:  MOVF   xD3,W
9226:  SUBLW  1F
9228:  BC    9252
922A:  MOVF   xD3,W
922C:  SUBLW  7E
922E:  BNC   9252
9230:  MOVFF  9D6,03
9234:  MOVF   xD5,W
9236:  INCF   xD5,F
9238:  BTFSC  FD8.2
923A:  INCF   xD6,F
923C:  MOVLB  A
923E:  MOVWF  x8E
9240:  MOVLW  B8
9242:  ADDWF  x8E,W
9244:  MOVWF  FE9
9246:  MOVLW  01
9248:  ADDWFC 03,W
924A:  MOVWF  FEA
924C:  MOVFF  9D3,FEF
9250:  MOVLB  9
....................                      i++; 
9252:  INCF   xD2,F
....................                      if(temp==0)break; 
9254:  MOVF   xD3,F
9256:  BNZ   925A
9258:  BRA    925C
....................                    } 
925A:  BRA    9202
....................                    addr_key=EEPROM_KEY_ST+((num_card-1)*50); 
925C:  MOVLW  01
925E:  SUBWF  xC8,W
9260:  MOVLB  A
9262:  MOVWF  x8E
9264:  MOVLW  00
9266:  MOVLB  9
9268:  SUBWFB xC9,W
926A:  MOVLB  A
926C:  MOVWF  x8F
926E:  CLRF   19
9270:  BTFSC  FF2.7
9272:  BSF    19.7
9274:  BCF    FF2.7
9276:  MOVWF  xBC
9278:  MOVFF  A8E,ABB
927C:  CLRF   xBE
927E:  MOVLW  32
9280:  MOVWF  xBD
9282:  MOVLB  0
9284:  CALL   3A40
9288:  BTFSC  19.7
928A:  BSF    FF2.7
928C:  MOVF   01,W
928E:  ADDLW  47
9290:  MOVLB  9
9292:  MOVWF  xB4
9294:  MOVLW  AA
9296:  ADDWFC 02,W
9298:  MOVWF  xB5
929A:  CLRF   xB6
929C:  CLRF   xB7
....................                    //if(ptr_card_key>addr_key) 
....................                    //{ 
....................                       strcpy(buftemp2," PIN:"); 
929E:  MOVLW  0A
92A0:  MOVWF  FEA
92A2:  MOVLW  5C
92A4:  MOVWF  FE9
92A6:  MOVLW  00
92A8:  MOVLB  0
92AA:  CALL   0410
92AE:  TBLRD*-
92B0:  TBLRD*+
92B2:  MOVF   FF5,W
92B4:  MOVWF  FEE
92B6:  IORLW  00
92B8:  BNZ   92B0
....................                       len=pre_msg(buftemp2,msg_data_sending,len); 
92BA:  MOVLW  0A
92BC:  MOVLB  A
92BE:  MOVWF  x8F
92C0:  MOVLW  5C
92C2:  MOVWF  x8E
92C4:  MOVLW  01
92C6:  MOVWF  x91
92C8:  MOVLW  B8
92CA:  MOVWF  x90
92CC:  MOVFF  9D6,A93
92D0:  MOVFF  9D5,A92
92D4:  MOVLB  0
92D6:  CALL   5F2A
92DA:  MOVLB  9
92DC:  CLRF   xD6
92DE:  MOVFF  01,9D5
....................                       j=0; 
92E2:  CLRF   xDA
....................                       do 
....................                       { 
....................                         temp=read_ext_eeprom(j+addr_key); 
92E4:  MOVF   xDA,W
92E6:  ADDWF  xB4,W
92E8:  MOVLB  A
92EA:  MOVWF  x8E
92EC:  MOVLW  00
92EE:  MOVLB  9
92F0:  ADDWFC xB5,W
92F2:  MOVLB  A
92F4:  MOVWF  x8F
92F6:  CLRF   19
92F8:  BTFSC  FF2.7
92FA:  BSF    19.7
92FC:  BCF    FF2.7
92FE:  MOVWF  xC0
9300:  MOVFF  A8E,ABF
9304:  MOVLB  0
9306:  CALL   3948
930A:  BTFSC  19.7
930C:  BSF    FF2.7
930E:  MOVFF  01,9D3
....................                         if(((temp>47)&&(temp<58))||((temp=='#')||(temp=='*'))||(temp>64)&&(temp<91)) 
9312:  MOVLB  9
9314:  MOVF   xD3,W
9316:  SUBLW  2F
9318:  BC    9320
931A:  MOVF   xD3,W
931C:  SUBLW  39
931E:  BC    9338
9320:  MOVF   xD3,W
9322:  SUBLW  23
9324:  BZ    9338
9326:  MOVF   xD3,W
9328:  SUBLW  2A
932A:  BZ    9338
932C:  MOVF   xD3,W
932E:  SUBLW  40
9330:  BC    935A
9332:  MOVF   xD3,W
9334:  SUBLW  5A
9336:  BNC   935A
....................                            msg_data_sending[len++]=temp; 
9338:  MOVFF  9D6,03
933C:  MOVF   xD5,W
933E:  INCF   xD5,F
9340:  BTFSC  FD8.2
9342:  INCF   xD6,F
9344:  MOVLB  A
9346:  MOVWF  x8E
9348:  MOVLW  B8
934A:  ADDWF  x8E,W
934C:  MOVWF  FE9
934E:  MOVLW  01
9350:  ADDWFC 03,W
9352:  MOVWF  FEA
9354:  MOVFF  9D3,FEF
9358:  MOVLB  9
....................                         j++; 
935A:  INCF   xDA,F
....................                       } 
....................                       while((j<key_numbyte)&&(temp!=0)); 
935C:  MOVF   xDA,W
935E:  SUBLW  31
9360:  BNC   9366
9362:  MOVF   xD3,F
9364:  BNZ   92E4
....................                       fprintf(COM2,"%lu character\n\r",len);   
9366:  MOVLW  10
9368:  MOVWF  FE9
936A:  CLRF   19
936C:  BTFSC  FF2.7
936E:  BSF    19.7
9370:  BCF    FF2.7
9372:  MOVFF  9D6,ABD
9376:  MOVFF  9D5,ABC
937A:  MOVLB  0
937C:  CALL   1742
9380:  BTFSC  19.7
9382:  BSF    FF2.7
9384:  MOVLW  31
9386:  MOVWF  FF6
9388:  MOVLW  4F
938A:  MOVWF  FF7
938C:  CLRF   19
938E:  BTFSC  FF2.7
9390:  BSF    19.7
9392:  BCF    FF2.7
9394:  MOVLW  0C
9396:  MOVLB  A
9398:  MOVWF  xD3
939A:  MOVLB  0
939C:  CALL   1718
93A0:  BTFSC  19.7
93A2:  BSF    FF2.7
....................                      //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                       //addr_key=addr_key+(50); 
....................                     //}        
....................                    lastlen=0;  
93A4:  MOVLB  9
93A6:  CLRF   xD1
93A8:  CLRF   xD0
....................                    //fprintf(COM2,"countc,num_card =%lu,%lu\n\r",countc,num_card); 
....................                    if((countc==num_card)&&(countc!=0)) 
93AA:  MOVF   xC8,W
93AC:  SUBWF  xCC,W
93AE:  BNZ   93C8
93B0:  MOVF   xC9,W
93B2:  SUBWF  xCD,W
93B4:  BNZ   93C8
93B6:  MOVF   xCC,F
93B8:  BNZ   93BE
93BA:  MOVF   xCD,F
93BC:  BZ    93C8
....................                    { 
....................                      SIM_state=delete_MSG;  
93BE:  MOVLW  06
93C0:  MOVLB  4
93C2:  MOVWF  x95
....................                      break; 
93C4:  BRA    9914
93C6:  MOVLB  9
....................                    } 
....................                    num_card--; 
93C8:  MOVF   xC8,W
93CA:  BTFSC  FD8.2
93CC:  DECF   xC9,F
93CE:  DECF   xC8,F
....................                    //fprintf(COM2,"send_oneMSG =%d\n\r",send_oneMSG); 
....................                    if(send_oneMSG==1) 
93D0:  MOVLB  4
93D2:  DECFSZ x9A,W
93D4:  BRA    93E0
....................                    { 
....................                      num_card=0; 
93D6:  MOVLB  9
93D8:  CLRF   xC9
93DA:  CLRF   xC8
....................                      send_oneMSG=0; 
93DC:  MOVLB  4
93DE:  CLRF   x9A
....................                    } 
....................                    SIM_state=MSG_sending;               
93E0:  MOVLW  08
93E2:  MOVWF  x95
....................             break; 
93E4:  BRA    9914
....................             case MSG_sending: 
....................                   fprintf(COM2,"MSG_sending %d\n\r",MSG_sending_st); 
93E6:  MOVLW  3E
93E8:  MOVWF  FF6
93EA:  MOVLW  4F
93EC:  MOVWF  FF7
93EE:  CLRF   19
93F0:  BTFSC  FF2.7
93F2:  BSF    19.7
93F4:  BCF    FF2.7
93F6:  MOVLW  0C
93F8:  MOVLB  A
93FA:  MOVWF  xD3
93FC:  MOVLB  0
93FE:  CALL   1718
9402:  BTFSC  19.7
9404:  BSF    FF2.7
9406:  CLRF   19
9408:  BTFSC  FF2.7
940A:  BSF    19.7
940C:  BCF    FF2.7
940E:  MOVFF  496,ABF
9412:  MOVLW  18
9414:  MOVLB  A
9416:  MOVWF  xC0
9418:  MOVLB  0
941A:  CALL   182C
941E:  BTFSC  19.7
9420:  BSF    FF2.7
9422:  CLRF   19
9424:  BTFSC  FF2.7
9426:  BSF    19.7
9428:  BCF    FF2.7
942A:  MOVLW  0A
942C:  MOVLB  A
942E:  MOVWF  xDF
9430:  MOVLB  0
9432:  CALL   075A
9436:  BTFSC  19.7
9438:  BSF    FF2.7
943A:  CLRF   19
943C:  BTFSC  FF2.7
943E:  BSF    19.7
9440:  BCF    FF2.7
9442:  MOVLW  0D
9444:  MOVLB  A
9446:  MOVWF  xDF
9448:  MOVLB  0
944A:  CALL   075A
944E:  BTFSC  19.7
9450:  BSF    FF2.7
....................                   //fprintf(COM2,"lastlen = %ld\n\r",lastlen); 
....................                    
....................                   //fprintf(COM2,"MSG_sending_st %d\n\r",MSG_sending_st); 
....................                   timing_wait=10000; 
9452:  MOVLW  27
9454:  MOVLB  4
9456:  MOVWF  x98
9458:  MOVLW  10
945A:  MOVWF  x97
....................                output_high(LED); 
945C:  BCF    F92.6
945E:  BSF    F89.6
....................                #ASM BCF    0xF94.7 #ENDASM  
9460:  BCF    F94.7
....................                switch(MSG_sending_st) 
....................                { 
9462:  MOVF   x96,W
9464:  XORLW  00
9466:  MOVLB  0
9468:  BZ    9474
946A:  XORLW  01
946C:  BZ    94CE
946E:  XORLW  03
9470:  BZ    9540
9472:  BRA    95FE
....................                   case 0:// configure MSG 
....................                      receiver_state=1; 
9474:  MOVLW  01
9476:  MOVLB  1
9478:  MOVWF  xB4
....................                         fprintf(COM1,"AT+CMGF=1\r\n"); // text mode 
947A:  MOVLW  50
947C:  MOVWF  FF6
947E:  MOVLW  4F
9480:  MOVWF  FF7
9482:  MOVLB  0
9484:  CALL   53D0
....................                      //fprintf(COM2,"AT+CMGF=1\r\n"); // text mode 
....................                      strl= strlen(msg_data_sending); 
9488:  MOVLW  01
948A:  MOVLB  A
948C:  MOVWF  x97
948E:  MOVLW  B8
9490:  MOVWF  x96
9492:  MOVLB  0
9494:  CALL   5EF0
9498:  MOVFF  01,9D9
....................                      MSG_sending_st=1; 
949C:  MOVLW  01
949E:  MOVLB  4
94A0:  MOVWF  x96
....................                      if((lastlen==140)&&(msg_data_sending[lastlen]==0)) 
94A2:  MOVLB  9
94A4:  MOVF   xD0,W
94A6:  SUBLW  8C
94A8:  BNZ   94CA
94AA:  MOVF   xD1,F
94AC:  BNZ   94CA
94AE:  MOVLW  B8
94B0:  ADDWF  xD0,W
94B2:  MOVWF  FE9
94B4:  MOVLW  01
94B6:  ADDWFC xD1,W
94B8:  MOVWF  FEA
94BA:  MOVF   FEF,F
94BC:  BNZ   94CA
....................                      { 
....................                         MSG_sending_st=0; 
94BE:  MOVLB  4
94C0:  CLRF   x96
....................                         SIM_state=delete_MSG; 
94C2:  MOVLW  06
94C4:  MOVWF  x95
....................                         break; 
94C6:  MOVLB  0
94C8:  BRA    95FE
....................                      } 
....................                      //EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
....................                   break; 
94CA:  MOVLB  0
94CC:  BRA    95FE
....................                   case 1: 
....................                         fprintf(COM1,"AT+CMGS="); 
94CE:  MOVLW  5C
94D0:  MOVWF  FF6
94D2:  MOVLW  4F
94D4:  MOVWF  FF7
94D6:  CALL   53D0
....................                      //fprintf(COM2,"AT+CMGS="); 
....................                      fputc('"',COM1); 
94DA:  MOVLW  22
94DC:  CALL   6520
....................                      i=0; 
94E0:  MOVLB  9
94E2:  CLRF   xD2
....................                      while((mobilenumb[i]!=0)&&(i<20)) 
....................                      { 
94E4:  CLRF   03
94E6:  MOVF   xD2,W
94E8:  ADDLW  79
94EA:  MOVWF  FE9
94EC:  MOVLW  04
94EE:  ADDWFC 03,W
94F0:  MOVWF  FEA
94F2:  MOVF   FEF,F
94F4:  BZ    951E
94F6:  MOVF   xD2,W
94F8:  SUBLW  13
94FA:  BNC   951E
....................                         fputc(mobilenumb[i],COM1); 
94FC:  CLRF   03
94FE:  MOVF   xD2,W
9500:  ADDLW  79
9502:  MOVWF  FE9
9504:  MOVLW  04
9506:  ADDWFC 03,W
9508:  MOVWF  FEA
950A:  MOVFF  FEF,A8E
950E:  MOVLB  A
9510:  MOVF   x8E,W
9512:  MOVLB  0
9514:  CALL   6520
....................                         //fprintf(COM2,"%c",mobilenumb[i]);  
....................                         i++; 
9518:  MOVLB  9
951A:  INCF   xD2,F
....................                      } 
951C:  BRA    94E4
....................                      fputc('"',COM1); 
951E:  MOVLW  22
9520:  MOVLB  0
9522:  CALL   6520
....................                      fprintf(COM1,"\r\n"); 
9526:  MOVLW  0D
9528:  BTFSS  F9E.4
952A:  BRA    9528
952C:  MOVWF  FAE
952E:  MOVLW  0A
9530:  BTFSS  F9E.4
9532:  BRA    9530
9534:  MOVWF  FAE
....................                      MSG_sending_st=2; 
9536:  MOVLW  02
9538:  MOVLB  4
953A:  MOVWF  x96
....................                   break; 
953C:  MOVLB  0
953E:  BRA    95FE
....................                   case 2: 
....................                      //while((msg_data_sending[i]!=0)&&(i<140)) 
....................                      for(i=0;i<140;i++) 
9540:  MOVLB  9
9542:  CLRF   xD2
9544:  MOVF   xD2,W
9546:  SUBLW  8B
9548:  BNC   95B4
....................                      { 
....................                         if(msg_data_sending[i+lastlen]==0) 
954A:  MOVF   xD2,W
954C:  ADDWF  xD0,W
954E:  MOVLB  A
9550:  MOVWF  x8E
9552:  MOVLW  00
9554:  MOVLB  9
9556:  ADDWFC xD1,W
9558:  MOVLB  A
955A:  MOVWF  x8F
955C:  MOVLW  B8
955E:  ADDWF  x8E,W
9560:  MOVWF  FE9
9562:  MOVLW  01
9564:  ADDWFC x8F,W
9566:  MOVWF  FEA
9568:  MOVF   FEF,F
956A:  BNZ   9582
....................                         { 
....................                            SIM_state=delete_MSG;    
956C:  MOVLW  06
956E:  MOVLB  4
9570:  MOVWF  x95
....................                            MSG_sending_st=0; 
9572:  CLRF   x96
....................                            fputc(26,COM1); 
9574:  MOVLW  1A
9576:  MOVLB  0
9578:  CALL   6520
....................                            break; 
957C:  MOVLB  9
957E:  BRA    95B4
9580:  MOVLB  A
....................                         } 
....................                         fputc(msg_data_sending[i+lastlen],COM1); 
9582:  MOVLB  9
9584:  MOVF   xD2,W
9586:  ADDWF  xD0,W
9588:  MOVLB  A
958A:  MOVWF  x8E
958C:  MOVLW  00
958E:  MOVLB  9
9590:  ADDWFC xD1,W
9592:  MOVLB  A
9594:  MOVWF  x8F
9596:  MOVLW  B8
9598:  ADDWF  x8E,W
959A:  MOVWF  FE9
959C:  MOVLW  01
959E:  ADDWFC x8F,W
95A0:  MOVWF  FEA
95A2:  MOVFF  FEF,A90
95A6:  MOVF   x90,W
95A8:  MOVLB  0
95AA:  CALL   6520
....................                      } 
95AE:  MOVLB  9
95B0:  INCF   xD2,F
95B2:  BRA    9544
....................                      //fprintf(COM2,"i= %u\n\r",i);  
....................                      fputc(26,COM1); 
95B4:  MOVLW  1A
95B6:  MOVLB  0
95B8:  CALL   6520
....................                      MSG_sending_st=0; 
95BC:  MOVLB  4
95BE:  CLRF   x96
....................                      if(i<140) 
95C0:  MOVLB  9
95C2:  MOVF   xD2,W
95C4:  SUBLW  8B
95C6:  BNC   95D6
....................                      { 
....................                         SIM_state=check_st; 
95C8:  MOVLW  09
95CA:  MOVLB  4
95CC:  MOVWF  x95
....................                         lastlen=0; 
95CE:  MOVLB  9
95D0:  CLRF   xD1
95D2:  CLRF   xD0
....................                      } 
....................                      else 
95D4:  BRA    95EC
....................                      { 
....................                         lastlen=140; 
95D6:  CLRF   xD1
95D8:  MOVLW  8C
95DA:  MOVWF  xD0
....................                         if(msg_data_sending[140]==0)SIM_state=check_st; 
95DC:  MOVLB  2
95DE:  MOVF   x44,F
95E0:  BNZ   95EA
95E2:  MOVLW  09
95E4:  MOVLB  4
95E6:  MOVWF  x95
95E8:  MOVLB  2
95EA:  MOVLB  9
....................                      } 
....................                      if(lastlen==140)SIM_state=MSG_sending; 
95EC:  MOVF   xD0,W
95EE:  SUBLW  8C
95F0:  BNZ   95FC
95F2:  MOVF   xD1,F
95F4:  BNZ   95FC
95F6:  MOVLW  08
95F8:  MOVLB  4
95FA:  MOVWF  x95
....................                      //fprintf(COM2,"lastlen %lu\n\r",lastlen);   
....................                   break; 
95FC:  MOVLB  0
....................                } 
....................                #ASM BSF    0xF94.7 #ENDASM  
95FE:  BSF    F94.7
....................             break; 
9600:  MOVLB  4
9602:  BRA    9914
....................             case check_st: 
....................                //fprintf(COM2,"check_st->num_card,countc, count_dwla, lastlen =%lu,%lu,%lu,%lu\r\n",num_card,countc,count_dwla,lastlen);   
....................                if(count_dwla>1) 
9604:  MOVLB  9
9606:  MOVF   xCF,F
9608:  BNZ   9610
960A:  MOVF   xCE,W
960C:  SUBLW  01
960E:  BC    9624
....................                { 
....................                   count_dwla--; 
9610:  MOVF   xCE,W
9612:  BTFSC  FD8.2
9614:  DECF   xCF,F
9616:  DECF   xCE,F
....................                   SIM_state=pre_cmd; 
9618:  MOVLW  07
961A:  MOVLB  4
961C:  MOVWF  x95
....................                   break; 
961E:  BRA    9914
....................                } 
....................                else if(countc>0)  
9620:  BRA    963C
9622:  MOVLB  9
9624:  MOVF   xCC,F
9626:  BNZ   962C
9628:  MOVF   xCD,F
962A:  BZ    9636
....................                { 
....................                   SIM_state=pre_cmd; 
962C:  MOVLW  07
962E:  MOVLB  4
9630:  MOVWF  x95
....................                   break; 
9632:  BRA    9914
....................                } 
....................                else SIM_state=delete_MSG; 
9634:  BRA    963C
9636:  MOVLW  06
9638:  MOVLB  4
963A:  MOVWF  x95
....................             break; 
963C:  BRA    9914
....................             case autosending:  
....................                   //auto_sending=read_ext_eeprom(strobe_autosending); 
....................                   //if(auto_sending==1) 
....................                   //{ 
....................                      EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
963E:  MOVLW  55
9640:  MOVLB  A
9642:  MOVWF  x8E
9644:  MOVLW  14
9646:  MOVWF  x8F
9648:  MOVLW  04
964A:  MOVWF  x91
964C:  MOVLW  79
964E:  MOVWF  x90
9650:  MOVLB  0
9652:  CALL   5062
....................                      #if defined(twonumber)  
....................                         fprintf(COM2,"\r\nSending to the first number\r\n"); 
9656:  MOVLW  66
9658:  MOVWF  FF6
965A:  MOVLW  4F
965C:  MOVWF  FF7
965E:  CLRF   19
9660:  BTFSC  FF2.7
9662:  BSF    19.7
9664:  BCF    FF2.7
9666:  CALL   07A0
966A:  BTFSC  19.7
966C:  BSF    FF2.7
966E:  CLRF   19
9670:  BTFSC  FF2.7
9672:  BSF    19.7
9674:  BCF    FF2.7
....................                      #else  
....................                         fprintf(COM2,"\r\nSending\r\n"); 
....................                      #endif 
....................                      num_card=get_countcard(); 
9676:  CALL   39F0
967A:  BTFSC  19.7
967C:  BSF    FF2.7
967E:  MOVFF  02,9C9
9682:  MOVFF  01,9C8
....................                      countc=0; 
9686:  MOVLB  9
9688:  CLRF   xCD
968A:  CLRF   xCC
....................                      count_dwla=0; 
968C:  CLRF   xCF
968E:  CLRF   xCE
....................                      lastlen=0; 
9690:  CLRF   xD1
9692:  CLRF   xD0
....................                      send_oneMSG=1; 
9694:  MOVLW  01
9696:  MOVLB  4
9698:  MOVWF  x9A
....................                      SIM_state=pre_cmd; 
969A:  MOVLW  07
969C:  MOVWF  x95
....................                   //} 
....................                   //else SIM_state= reading_sms_cmd; 
....................             break; 
969E:  BRA    9914
....................             #if defined(twonumber)  
....................             case autosending1:  
....................                   //auto_sending=read_ext_eeprom(strobe_autosending); 
....................                   //if(auto_sending==1) 
....................                   //{ 
....................                      EEPROM_read(strobe_mobile_num0,20,mobilenumb);  
96A0:  MOVLW  41
96A2:  MOVLB  A
96A4:  MOVWF  x8E
96A6:  MOVLW  14
96A8:  MOVWF  x8F
96AA:  MOVLW  04
96AC:  MOVWF  x91
96AE:  MOVLW  79
96B0:  MOVWF  x90
96B2:  MOVLB  0
96B4:  CALL   5062
....................                      if((mobilenumb[0]==0)&&(mobilenumb[1]==0)&&(mobilenumb[2]==0)&&(mobilenumb[3]==0)&&(mobilenumb[5]==0)&&(mobilenumb[7]==0)&&(mobilenumb[9]==0)) 
96B8:  MOVLB  4
96BA:  MOVF   x79,F
96BC:  BNZ   96FA
96BE:  MOVF   x7A,F
96C0:  BNZ   96FA
96C2:  MOVF   x7B,F
96C4:  BNZ   96FA
96C6:  MOVF   x7C,F
96C8:  BNZ   96FA
96CA:  MOVF   x7E,F
96CC:  BNZ   96FA
96CE:  MOVF   x80,F
96D0:  BNZ   96FA
96D2:  MOVF   x82,F
96D4:  BNZ   96FA
....................                      { 
....................                         send_oneMSG=0; 
96D6:  CLRF   x9A
....................                         fprintf(COM2,"\r\nthe 2nd number is not installed\r\n"); 
96D8:  MOVLW  86
96DA:  MOVWF  FF6
96DC:  MOVLW  4F
96DE:  MOVWF  FF7
96E0:  CLRF   19
96E2:  BTFSC  FF2.7
96E4:  BSF    19.7
96E6:  BCF    FF2.7
96E8:  MOVLB  0
96EA:  CALL   07A0
96EE:  BTFSC  19.7
96F0:  BSF    FF2.7
....................                         SIM_state=delete_MSG;    
96F2:  MOVLW  06
96F4:  MOVLB  4
96F6:  MOVWF  x95
....................                      } 
....................                      else 
96F8:  BRA    973A
....................                      { 
....................                         fprintf(COM2,"\r\nSending to the second number\r\n"); 
96FA:  MOVLW  AA
96FC:  MOVWF  FF6
96FE:  MOVLW  4F
9700:  MOVWF  FF7
9702:  CLRF   19
9704:  BTFSC  FF2.7
9706:  BSF    19.7
9708:  BCF    FF2.7
970A:  MOVLB  0
970C:  CALL   07A0
9710:  BTFSC  19.7
9712:  BSF    FF2.7
....................                         send_oneMSG=1; 
9714:  MOVLW  01
9716:  MOVLB  4
9718:  MOVWF  x9A
971A:  CLRF   19
971C:  BTFSC  FF2.7
971E:  BSF    19.7
9720:  BCF    FF2.7
....................                         num_card=get_countcard(); 
9722:  MOVLB  0
9724:  CALL   39F0
9728:  BTFSC  19.7
972A:  BSF    FF2.7
972C:  MOVFF  02,9C9
9730:  MOVFF  01,9C8
....................                         SIM_state=pre_cmd; 
9734:  MOVLW  07
9736:  MOVLB  4
9738:  MOVWF  x95
....................                      }                      
....................                      countc=0; 
973A:  MOVLB  9
973C:  CLRF   xCD
973E:  CLRF   xCC
....................                      count_dwla=0; 
9740:  CLRF   xCF
9742:  CLRF   xCE
....................                      lastlen=0;                      
9744:  CLRF   xD1
9746:  CLRF   xD0
....................                   //} 
....................                   //else SIM_state= reading_sms_cmd; 
....................             break; 
9748:  MOVLB  4
974A:  BRA    9914
....................             #endif 
....................             case idle: 
....................                   output_toggle(LED); 
974C:  BCF    F92.6
974E:  BTG    F89.6
....................                   fprintf(COM2,"idle\n\r"); 
9750:  MOVLW  CC
9752:  MOVWF  FF6
9754:  MOVLW  4F
9756:  MOVWF  FF7
9758:  CLRF   19
975A:  BTFSC  FF2.7
975C:  BSF    19.7
975E:  BCF    FF2.7
9760:  CALL   07A0
9764:  BTFSC  19.7
9766:  BSF    FF2.7
....................                   fprintf(COM1,"AT+CMGF=1\r\n"); 
9768:  MOVLW  D4
976A:  MOVWF  FF6
976C:  MOVLW  4F
976E:  MOVWF  FF7
9770:  CALL   53D0
....................                   output_low(LED); 
9774:  BCF    F92.6
9776:  BCF    F89.6
....................                   SIM_state= data_analyze; 
9778:  MOVLW  0D
977A:  MOVLB  4
977C:  MOVWF  x95
....................                   receiver_state=0; 
977E:  MOVLB  1
9780:  CLRF   xB4
....................                   timing_wait=1500; 
9782:  MOVLW  05
9784:  MOVLB  4
9786:  MOVWF  x98
9788:  MOVLW  DC
978A:  MOVWF  x97
....................             break; 
978C:  BRA    9914
....................             case data_analyze: 
....................              
....................                   /*use for debug*/ 
....................                   /*fprintf(COM2,"\n\rcard_timeout %lu\n\r",card_timeout); 
....................                   fprintf(COM2,"\n\rbug_countbit_T1 %lu\n\r",bug_countbit_T1); 
....................                   fprintf(COM2,"\n\rbug_countbit_T2 %lu\n\r",bug_countbit_T2);*/                   
....................                   /*use for debug*/ 
....................                   //fprintf(COM2,"data_analyze=%d\n\r",temp); 
....................                   booting_done=1; 
978E:  MOVLW  01
9790:  MOVLB  1
9792:  MOVWF  xB5
....................                   output_low(LED); 
9794:  BCF    F92.6
9796:  BCF    F89.6
....................                   temp=SMS_coming(); 
9798:  MOVLB  0
979A:  GOTO   6528
979E:  MOVFF  01,9D3
....................                   if(temp==2) 
97A2:  MOVLB  9
97A4:  MOVF   xD3,W
97A6:  SUBLW  02
97A8:  BNZ   97BA
....................                   { 
....................                      output_high(LED); 
97AA:  BCF    F92.6
97AC:  BSF    F89.6
....................                      SIM_state=reading_sms_cmd; 
97AE:  MOVLW  01
97B0:  MOVLB  4
97B2:  MOVWF  x95
....................                      count_checking=0; 
97B4:  MOVLB  1
97B6:  CLRF   x07
97B8:  CLRF   x06
....................                   } 
....................                   count_checking++; 
97BA:  MOVLB  1
97BC:  INCF   x06,F
97BE:  BTFSC  FD8.2
97C0:  INCF   x07,F
....................                   if(count_checking==20) 
97C2:  MOVF   x06,W
97C4:  SUBLW  14
97C6:  BNZ   97D8
97C8:  MOVF   x07,F
97CA:  BNZ   97D8
....................                   { 
....................                      //SIM_state=phone_activity_status; 
....................                      SIM_state=check_comunication; 
97CC:  MOVLW  0F
97CE:  MOVLB  4
97D0:  MOVWF  x95
....................                      count_checking=0; 
97D2:  MOVLB  1
97D4:  CLRF   x07
97D6:  CLRF   x06
....................                   } 
....................             break; 
97D8:  MOVLB  4
97DA:  BRA    9914
....................             case SIM_reply: 
....................                   fprintf(COM2,"SIM is replying\n\r"); 
97DC:  MOVLW  E0
97DE:  MOVWF  FF6
97E0:  MOVLW  4F
97E2:  MOVWF  FF7
97E4:  CLRF   19
97E6:  BTFSC  FF2.7
97E8:  BSF    19.7
97EA:  BCF    FF2.7
97EC:  CALL   07A0
97F0:  BTFSC  19.7
97F2:  BSF    FF2.7
....................                   //send_sms(mobilenumb,reply_buffer); 
....................                   len=0; 
97F4:  MOVLB  9
97F6:  CLRF   xD6
97F8:  CLRF   xD5
97FA:  CLRF   19
97FC:  BTFSC  FF2.7
97FE:  BSF    19.7
9800:  BCF    FF2.7
....................                   cards=get_countcard(); 
9802:  MOVLB  0
9804:  CALL   39F0
9808:  BTFSC  19.7
980A:  BSF    FF2.7
980C:  MOVFF  02,9CB
9810:  MOVFF  01,9CA
....................                   //strcpy(msg_buffer2,"device has "); 
....................                   len=pre_msg(reply_buffer,msg_data_sending,0); 
9814:  MOVLW  03
9816:  MOVLB  A
9818:  MOVWF  x8F
981A:  MOVLW  48
981C:  MOVWF  x8E
981E:  MOVLW  01
9820:  MOVWF  x91
9822:  MOVLW  B8
9824:  MOVWF  x90
9826:  CLRF   x93
9828:  CLRF   x92
982A:  MOVLB  0
982C:  CALL   5F2A
9830:  MOVLB  9
9832:  CLRF   xD6
9834:  MOVFF  01,9D5
....................                   //itoa(cards,10,string); 
....................                   //len=pre_msg(string,msg_data_sending,len); 
....................                   //strcpy(msg_buffer2," transaction "); 
....................                   //len=pre_msg(msg_buffer2,msg_data_sending,len); 
....................                   SIM_state=MSG_sending; 
9838:  MOVLW  08
983A:  MOVLB  4
983C:  MOVWF  x95
....................                   lastlen=0; 
983E:  MOVLB  9
9840:  CLRF   xD1
9842:  CLRF   xD0
....................                   //fprintf(COM2,"device has %lu transaction \n\r",cards); 
....................                   countc=0; 
9844:  CLRF   xCD
9846:  CLRF   xCC
....................                   count_dwla=0; 
9848:  CLRF   xCF
984A:  CLRF   xCE
....................             break; 
984C:  MOVLB  4
984E:  BRA    9914
....................             case check_comunication: 
....................                fprintf(COM2,"check comunication\n\r"); 
9850:  MOVLW  F2
9852:  MOVWF  FF6
9854:  MOVLW  4F
9856:  MOVWF  FF7
9858:  CLRF   19
985A:  BTFSC  FF2.7
985C:  BSF    19.7
985E:  BCF    FF2.7
9860:  CALL   07A0
9864:  BTFSC  19.7
9866:  BSF    FF2.7
....................                //SIM_state= data_analyze; 
....................                SIM_state= phone_activity_status; 
9868:  MOVLW  10
986A:  MOVLB  4
986C:  MOVWF  x95
....................                booting_done=0; 
986E:  MOVLB  1
9870:  CLRF   xB5
....................                checking_sim=1; 
9872:  MOVLW  01
9874:  MOVLB  4
9876:  MOVWF  x9C
....................                setup_wdt(WDT_ON); 
9878:  BSF    FC0.0
....................                fprintf(COM1,"AT\r\n");   
987A:  MOVLW  08
987C:  MOVWF  FF6
987E:  MOVLW  50
9880:  MOVWF  FF7
9882:  MOVLB  0
9884:  CALL   53D0
....................             break; 
9888:  MOVLB  4
988A:  BRA    9914
....................             case phone_activity_status: 
....................                booting_done=1; 
988C:  MOVLW  01
988E:  MOVLB  1
9890:  MOVWF  xB5
....................                fprintf(COM2,"SIM activity status\n\r"); 
9892:  MOVLW  0E
9894:  MOVWF  FF6
9896:  MOVLW  50
9898:  MOVWF  FF7
989A:  CLRF   19
989C:  BTFSC  FF2.7
989E:  BSF    19.7
98A0:  BCF    FF2.7
98A2:  MOVLB  0
98A4:  CALL   07A0
98A8:  BTFSC  19.7
98AA:  BSF    FF2.7
....................                SIM_state= data_analyze; 
98AC:  MOVLW  0D
98AE:  MOVLB  4
98B0:  MOVWF  x95
....................                fprintf(COM1,"AT+CPAS\r\n");  
98B2:  MOVLW  24
98B4:  MOVWF  FF6
98B6:  MOVLW  50
98B8:  MOVWF  FF7
98BA:  MOVLB  0
98BC:  CALL   53D0
....................             break; 
98C0:  MOVLB  4
98C2:  BRA    9914
....................             case check_inbox: 
....................                fprintf(COM2,"check inbox\n\r"); 
98C4:  MOVLW  2E
98C6:  MOVWF  FF6
98C8:  MOVLW  50
98CA:  MOVWF  FF7
98CC:  CLRF   19
98CE:  BTFSC  FF2.7
98D0:  BSF    19.7
98D2:  BCF    FF2.7
98D4:  CALL   07A0
98D8:  BTFSC  19.7
98DA:  BSF    FF2.7
....................                SIM_state= data_analyze; 
98DC:  MOVLW  0D
98DE:  MOVLB  4
98E0:  MOVWF  x95
....................                fprintf(COM1,"AT+CMGR=1\r\n"); 
98E2:  MOVLW  3C
98E4:  MOVWF  FF6
98E6:  MOVLW  50
98E8:  MOVWF  FF7
98EA:  MOVLB  0
98EC:  CALL   53D0
....................             break; 
98F0:  MOVLB  4
98F2:  BRA    9914
....................             case reset_module: 
....................                setup_wdt(WDT_ON); 
98F4:  BSF    FC0.0
....................                fprintf(COM2,"reset_module\n\r"); 
98F6:  MOVLW  48
98F8:  MOVWF  FF6
98FA:  MOVLW  50
98FC:  MOVWF  FF7
98FE:  CLRF   19
9900:  BTFSC  FF2.7
9902:  BSF    19.7
9904:  BCF    FF2.7
9906:  CALL   07A0
990A:  BTFSC  19.7
990C:  BSF    FF2.7
....................             break; 
990E:  MOVLB  4
9910:  BRA    9914
9912:  MOVLB  4
....................          }         
....................       } 
....................       //restart_wdt(); 
....................       delay_us(500); 
9914:  MOVLW  02
9916:  MOVLB  A
9918:  MOVWF  x8E
991A:  CLRF   19
991C:  BTFSC  FF2.7
991E:  BSF    19.7
9920:  BCF    FF2.7
9922:  MOVLW  FA
9924:  MOVWF  xB4
9926:  MOVLB  0
9928:  CALL   0736
992C:  BTFSC  19.7
992E:  BSF    FF2.7
9930:  MOVLB  A
9932:  DECFSZ x8E,F
9934:  BRA    991A
....................      #else 
....................       if(mode==LOGOFF) 
....................       { 
....................          fprintf(COM2,"password:"); 
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          if(!stringcomp(buffer_uart,password)) 
....................          { 
....................             mode=LOGON; 
....................             fprintf(COM2," OK\n\r"); 
....................          } 
....................          else fprintf(COM2," X\n\r"); 
....................       } 
....................          else if(mode==LOGON)adminmode();//*/ 
....................      #endif     
....................    } 
9936:  MOVLB  0
9938:  GOTO   728A
.................... } 
993C:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS
